commit 6ef7eef9291c5882dfbec34cc33257db4333912e
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri May 24 13:48:21 2019 +0530

    staging: ks7010: Merge multiple return variables in ks_hostif.c
    
    The function hostif_data_request had two return variables, ret and
    result. When ret is assigned a value, in all cases (except one) this
    assignment is followed immediately by a goto to the end of the
    function. In the last case, the goto takes effect only if ret < 0;
    however, if ret >= 0 then this value of ret is not needed in the
    remainder of that branch. On the other hand result is used (assigned a
    value and returned) only in those branches where ret >= 0 or ret has
    not been used at all.
    As the values of ret and result are not both required at the same point
    in any branch, result can be removed and its occurrences replaced with
    ret.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 3775fd4b89ae..2666f9e30c15 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1067,7 +1067,6 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	unsigned int length = 0;
 	struct hostif_data_request *pp;
 	unsigned char *p;
-	int result;
 	unsigned short eth_proto;
 	struct ether_hdr *eth_hdr;
 	unsigned short keyinfo = 0;
@@ -1209,8 +1208,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	pp->header.event = cpu_to_le16(HIF_DATA_REQ);
 
 	/* tx request */
-	result = ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + skb_len),
-			       send_packet_complete, skb);
+	ret = ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + skb_len),
+			    send_packet_complete, skb);
 
 	/* MIC FAILURE REPORT check */
 	if (eth_proto == ETH_P_PAE &&
@@ -1225,7 +1224,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 			priv->wpa.mic_failure.stop = 1;
 	}
 
-	return result;
+	return ret;
 
 err_kfree:
 	kfree(pp);

commit a7048b38ae443abe06141b75f842b73371c2a0fe
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri May 24 13:33:30 2019 +0530

    staging: ks7010: Remove initialisation in ks_hostif.c
    
    The initial value of return variable result is never used, so it can be
    removed.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index e089366ed02a..3775fd4b89ae 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1067,7 +1067,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	unsigned int length = 0;
 	struct hostif_data_request *pp;
 	unsigned char *p;
-	int result = 0;
+	int result;
 	unsigned short eth_proto;
 	struct ether_hdr *eth_hdr;
 	unsigned short keyinfo = 0;

commit e0dccbdf5ac7ccb9da5612100dedba302f3ebcfe
Merge: cf482a49af56 e2a5be107f52
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 13:31:29 2019 -0700

    Merge tag 'staging-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging / IIO driver updates from Greg KH:
     "Here is the big staging and iio driver update for 5.2-rc1.
    
      Lots of tiny fixes all over the staging and IIO driver trees here,
      along with some new IIO drivers.
    
      The "counter" subsystem was added in here as well, as it is needed by
      the IIO drivers and subsystem.
    
      Also we ended up deleting two drivers, making this pull request remove
      a few hundred thousand lines of code, always a nice thing to see. Both
      of the drivers removed have been replaced with "real" drivers in their
      various subsystem directories, and they will be coming to you from
      those locations during this merge window.
    
      There are some core vt/selection changes in here, that was due to some
      cleanups needed for the speakup fixes. Those have all been acked by
      the various subsystem maintainers (i.e. me), so those are ok.
    
      We also added a few new drivers, for some odd hardware, giving new
      developers plenty to work on with basic coding style cleanups to come
      in the near future.
    
      Other than that, nothing unusual here.
    
      All of these have been in linux-next for a while with no reported
      issues, other than an odd gcc warning for one of the new drivers that
      should be fixed up soon"
    
    [ I fixed up the warning myself  - Linus ]
    
    * tag 'staging-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (663 commits)
      staging: kpc2000: kpc_spi: Fix build error for {read,write}q
      Staging: rtl8192e: Remove extra space before break statement
      Staging: rtl8192u: ieee80211: Fix if-else indentation warning
      Staging: rtl8192u: ieee80211: Fix indentation errors by removing extra spaces
      staging: most: cdev: fix chrdev_region leak in mod_exit
      staging: wlan-ng: Fix improper SPDX comment style
      staging: rtl8192u: ieee80211: Resolve ERROR reported by checkpatch
      staging: vc04_services: bcm2835-camera: Compress two lines into one line
      staging: rtl8723bs: core: Use !x in place of NULL comparison.
      staging: rtl8723bs: core: Prefer using the BIT Macro.
      staging: fieldbus: anybus-s: fix wait_for_completion_timeout return handling
      staging: kpc2000: fix up build problems with readq()
      staging: rtlwifi: move remaining phydm .h files
      staging: rtlwifi: strip down phydm .h files
      staging: rtlwifi: delete the staging driver
      staging: fieldbus: anybus-s: rename bus id field to avoid confusion
      staging: fieldbus: anybus-s: keep device bus id in bus endianness
      Staging: sm750fb: Change *array into *const array
      staging: rtl8192u: ieee80211: Fix spelling mistake
      staging: rtl8192u: ieee80211: Replace bit shifting with BIT macro
      ...

commit 877b5691f27a1aec0d9b53095a323e45c30069e2
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Apr 14 17:37:09 2019 -0700

    crypto: shash - remove shash_desc::flags
    
    The flags field in 'struct shash_desc' never actually does anything.
    The only ostensibly supported flag is CRYPTO_TFM_REQ_MAY_SLEEP.
    However, no shash algorithm ever sleeps, making this flag a no-op.
    
    With this being the case, inevitably some users who can't sleep wrongly
    pass MAY_SLEEP.  These would all need to be fixed if any shash algorithm
    actually started sleeping.  For example, the shash_ahash_*() functions,
    which wrap a shash algorithm with the ahash API, pass through MAY_SLEEP
    from the ahash API to the shash API.  However, the shash functions are
    called under kmap_atomic(), so actually they're assumed to never sleep.
    
    Even if it turns out that some users do need preemption points while
    hashing large buffers, we could easily provide a helper function
    crypto_shash_update_large() which divides the data into smaller chunks
    and calls crypto_shash_update() and cond_resched() for each chunk.  It's
    not necessary to have a flag in 'struct shash_desc', nor is it necessary
    to make individual shash algorithms aware of this at all.
    
    Therefore, remove shash_desc::flags, and document that the
    crypto_shash_*() functions can be called from any context.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 06ebea0be118..122d4c0af363 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -219,7 +219,6 @@ michael_mic(u8 *key, u8 *data, unsigned int len, u8 priority, u8 *result)
 	}
 
 	desc->tfm = tfm;
-	desc->flags = 0;
 
 	ret = crypto_shash_init(desc);
 	if (ret < 0)

commit 7d6009f2821270831ffc6c29b3bf58891e3583d7
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Mar 18 10:57:49 2019 +0000

    staging: ks7010: remove redundant auth_type check
    
    The range check on auth_type is redundant as there is a prior
    check on the auth_type values and the only way the block is entered
    is if auth_type is one of TYPE_PMK1, TYPE_GMK1 and TYPE_GMK2. Hence
    the auth_type check can be removed.
    
    Detected by static analysis with cppcheck.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 06ebea0be118..31a536791d5c 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -362,6 +362,8 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 	     (auth_type == TYPE_GMK2 &&
 	      priv->wpa.group_suite == IW_AUTH_CIPHER_TKIP)) &&
 	    key->key_len) {
+		int ret;
+
 		netdev_dbg(priv->net_dev, "TKIP: protocol=%04X: size=%u\n",
 			   eth_proto, priv->rx_size);
 		/* MIC save */
@@ -369,15 +371,11 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 		       (priv->rxp) + ((priv->rx_size) - sizeof(recv_mic)),
 		       sizeof(recv_mic));
 		priv->rx_size = priv->rx_size - sizeof(recv_mic);
-		if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
-			int ret;
-
-			ret = michael_mic(key->rx_mic_key,
-					  priv->rxp, priv->rx_size,
-					  0, mic);
-			if (ret < 0)
-				return ret;
-		}
+
+		ret = michael_mic(key->rx_mic_key, priv->rxp, priv->rx_size,
+				  0, mic);
+		if (ret < 0)
+			return ret;
 		if (memcmp(mic, recv_mic, sizeof(mic)) != 0) {
 			now = jiffies;
 			mic_failure = &priv->wpa.mic_failure;

commit 8b523f20417d5b8423895dd6b3118a6ab9d91d98
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Thu Feb 28 11:15:56 2019 +0000

    staging: ks7010: removed custom Michael MIC implementation.
    
    Changed the driver to use the kernel's own implementation.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index e48fc36b6ebd..06ebea0be118 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -6,15 +6,18 @@
  *   Copyright (C) 2009 Renesas Technology Corp.
  */
 
+#include <crypto/hash.h>
 #include <linux/circ_buf.h>
 #include <linux/if_arp.h>
 #include <net/iw_handler.h>
 #include <uapi/linux/llc.h>
 #include "eap_packet.h"
 #include "ks_wlan.h"
-#include "michael_mic.h"
 #include "ks_hostif.h"
 
+#define MICHAEL_MIC_KEY_LEN 8
+#define MICHAEL_MIC_LEN     8
+
 static inline void inc_smeqhead(struct ks_wlan_private *priv)
 {
 	priv->sme_i.qhead = (priv->sme_i.qhead + 1) % SME_EVENT_BUFF_SIZE;
@@ -191,6 +194,68 @@ static u8 read_ie(unsigned char *bp, u8 max, u8 *body)
 	return size;
 }
 
+static int
+michael_mic(u8 *key, u8 *data, unsigned int len, u8 priority, u8 *result)
+{
+	u8 pad_data[4] = { priority, 0, 0, 0 };
+	struct crypto_shash *tfm = NULL;
+	struct shash_desc *desc = NULL;
+	int ret;
+
+	tfm = crypto_alloc_shash("michael_mic", 0, 0);
+	if (IS_ERR(tfm)) {
+		ret = PTR_ERR(tfm);
+		goto err;
+	}
+
+	ret = crypto_shash_setkey(tfm, key, MICHAEL_MIC_KEY_LEN);
+	if (ret < 0)
+		goto err_free_tfm;
+
+	desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
+	if (!desc) {
+		ret = -ENOMEM;
+		goto err_free_tfm;
+	}
+
+	desc->tfm = tfm;
+	desc->flags = 0;
+
+	ret = crypto_shash_init(desc);
+	if (ret < 0)
+		goto err_free_desc;
+
+	// Compute the MIC value
+	/*
+	 * IEEE802.11i  page 47
+	 * Figure 43g TKIP MIC processing format
+	 * +--+--+--------+--+----+--+--+--+--+--+--+--+--+
+	 * |6 |6 |1       |3 |M   |1 |1 |1 |1 |1 |1 |1 |1 | Octet
+	 * +--+--+--------+--+----+--+--+--+--+--+--+--+--+
+	 * |DA|SA|Priority|0 |Data|M0|M1|M2|M3|M4|M5|M6|M7|
+	 * +--+--+--------+--+----+--+--+--+--+--+--+--+--+
+	 */
+
+	ret = crypto_shash_update(desc, data, 12);
+	if (ret < 0)
+		goto err_free_desc;
+
+	ret = crypto_shash_update(desc, pad_data, 4);
+	if (ret < 0)
+		goto err_free_desc;
+
+	ret = crypto_shash_finup(desc, data + 12, len - 12, result);
+
+err_free_desc:
+	kzfree(desc);
+
+err_free_tfm:
+	crypto_free_shash(tfm);
+
+err:
+	return ret;
+}
+
 static
 int get_ap_information(struct ks_wlan_private *priv, struct ap_info *ap_info,
 		       struct local_ap *ap)
@@ -273,11 +338,11 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 {
 	struct ether_hdr *eth_hdr;
 	unsigned short eth_proto;
-	unsigned char recv_mic[8];
+	unsigned char recv_mic[MICHAEL_MIC_LEN];
 	char buf[128];
 	unsigned long now;
 	struct mic_failure *mic_failure;
-	struct michael_mic michael_mic;
+	u8 mic[MICHAEL_MIC_LEN];
 	union iwreq_data wrqu;
 	unsigned int key_index = auth_type - 1;
 	struct wpa_key *key = &priv->wpa.key[key_index];
@@ -300,14 +365,20 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 		netdev_dbg(priv->net_dev, "TKIP: protocol=%04X: size=%u\n",
 			   eth_proto, priv->rx_size);
 		/* MIC save */
-		memcpy(&recv_mic[0], (priv->rxp) + ((priv->rx_size) - 8), 8);
-		priv->rx_size = priv->rx_size - 8;
+		memcpy(&recv_mic[0],
+		       (priv->rxp) + ((priv->rx_size) - sizeof(recv_mic)),
+		       sizeof(recv_mic));
+		priv->rx_size = priv->rx_size - sizeof(recv_mic);
 		if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
-			michael_mic_function(&michael_mic, key->rx_mic_key,
-					     priv->rxp, priv->rx_size,
-					     0,	michael_mic.result);
+			int ret;
+
+			ret = michael_mic(key->rx_mic_key,
+					  priv->rxp, priv->rx_size,
+					  0, mic);
+			if (ret < 0)
+				return ret;
 		}
-		if (memcmp(michael_mic.result, recv_mic, 8) != 0) {
+		if (memcmp(mic, recv_mic, sizeof(mic)) != 0) {
 			now = jiffies;
 			mic_failure = &priv->wpa.mic_failure;
 			/* MIC FAILURE */
@@ -1002,7 +1073,6 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	int result = 0;
 	unsigned short eth_proto;
 	struct ether_hdr *eth_hdr;
-	struct michael_mic michael_mic;
 	unsigned short keyinfo = 0;
 	struct ieee802_1x_hdr *aa1x_hdr;
 	struct wpa_eapol_key *eap_key;
@@ -1109,17 +1179,20 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 			pp->auth_type = cpu_to_le16(TYPE_AUTH);
 		} else {
 			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
-				michael_mic_function(&michael_mic,
-						     priv->wpa.key[0].tx_mic_key,
-						     &pp->data[0], skb_len,
-						     0,	michael_mic.result);
-				memcpy(p, michael_mic.result, 8);
-				length += 8;
-				skb_len += 8;
-				p += 8;
+				u8 mic[MICHAEL_MIC_LEN];
+
+				ret = michael_mic(priv->wpa.key[0].tx_mic_key,
+						  &pp->data[0], skb_len,
+						  0, mic);
+				if (ret < 0)
+					goto err_kfree;
+
+				memcpy(p, mic, sizeof(mic));
+				length += sizeof(mic);
+				skb_len += sizeof(mic);
+				p += sizeof(mic);
 				pp->auth_type =
 				    cpu_to_le16(TYPE_DATA);
-
 			} else if (priv->wpa.pairwise_suite ==
 				   IW_AUTH_CIPHER_CCMP) {
 				pp->auth_type =

commit 13a7287edb1ef38d95f4b3fff44895cb9fd9ae64
Author: Bhanusree Pola <bhanusreemahesh@gmail.com>
Date:   Tue Feb 26 05:45:23 2019 +0530

    Staging: ks7010: Match alignments with open parenthesis
    
    Adjust parameters of "netdev_dbg" to match alignment with
    open parenthesis.
    Issue found using checkpatch.pl
    
    Signed-off-by: Bhanusree Pola <bhanusreemahesh@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index d938b0997a53..e48fc36b6ebd 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -730,7 +730,7 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 	priv->scan_ind_count++;
 	if (priv->scan_ind_count < LOCAL_APLIST_MAX + 1) {
 		netdev_dbg(priv->net_dev, " scan_ind_count=%d :: aplist.size=%d\n",
-			priv->scan_ind_count, priv->aplist.size);
+			   priv->scan_ind_count, priv->aplist.size);
 		get_ap_information(priv, (struct ap_info *)(priv->rxp),
 				   &priv->aplist.ap[priv->scan_ind_count - 1]);
 		priv->aplist.size = priv->scan_ind_count;

commit 45a50ab1d684c951ba4d70c1b7bbdd95383bccad
Author: Matt McCoy <mattmccoy110@gmail.com>
Date:   Tue Jan 22 21:18:16 2019 -0500

    staging: ks7010: remove unnecessary parentheses
    
    Remove unnecessary parentheses reported by checkpatch.
    
    Signed-off-by: Matt McCoy <mattmccoy110@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 065bce193fac..d938b0997a53 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -35,7 +35,7 @@ static inline u8 get_byte(struct ks_wlan_private *priv)
 {
 	u8 data;
 
-	data = *(priv->rxp)++;
+	data = *priv->rxp++;
 	/* length check in advance ! */
 	--(priv->rx_size);
 	return data;
@@ -171,7 +171,7 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)
 		   "- rate_set_size=%d\n",
 		   ap->bssid[0], ap->bssid[1], ap->bssid[2],
 		   ap->bssid[3], ap->bssid[4], ap->bssid[5],
-		   &(ap->ssid.body[0]),
+		   &ap->ssid.body[0],
 		   ap->rate_set.body[0], ap->rate_set.body[1],
 		   ap->rate_set.body[2], ap->rate_set.body[3],
 		   ap->rate_set.body[4], ap->rate_set.body[5],
@@ -732,7 +732,7 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 		netdev_dbg(priv->net_dev, " scan_ind_count=%d :: aplist.size=%d\n",
 			priv->scan_ind_count, priv->aplist.size);
 		get_ap_information(priv, (struct ap_info *)(priv->rxp),
-				   &(priv->aplist.ap[priv->scan_ind_count - 1]));
+				   &priv->aplist.ap[priv->scan_ind_count - 1]);
 		priv->aplist.size = priv->scan_ind_count;
 	} else {
 		netdev_dbg(priv->net_dev, " count over :: scan_ind_count=%d\n",

commit 8b8429b00086d0d2a4eb6dd0ec96d4020d5fe8c8
Author: Maya Nakamura <m.maya.nakamura@gmail.com>
Date:   Tue Oct 16 00:53:09 2018 -0700

    staging: ks7010: Remove extra blank line
    
    Remove extra blank line. Issue found by checkpatch.pl.
    
    Signed-off-by: Maya Nakamura <m.maya.nakamura@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Reviewed-by: Vaishali Thakkar <vthakkar@vaishalithakkar.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index ca030d3f609f..065bce193fac 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -191,7 +191,6 @@ static u8 read_ie(unsigned char *bp, u8 max, u8 *body)
 	return size;
 }
 
-
 static
 int get_ap_information(struct ks_wlan_private *priv, struct ap_info *ap_info,
 		       struct local_ap *ap)

commit e7f8f1df634c093e00a2611230b83150c81b0049
Author: Aymen Qader <qader.aymen@gmail.com>
Date:   Sun Sep 30 09:34:21 2018 +0100

    staging: ks7010: Remove unnecessary null check
    
    Remove the unnecessary socket buffer null check in hostif_data_request.
    There is already an appropriate null check in the calling function:
    
    (ks_wlan_net.c) ks_wlan_start_xmit
    
    Signed-off-by: Aymen Qader <qader.aymen@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 0e554e3359b5..ca030d3f609f 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1023,8 +1023,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	    priv->wpa.mic_failure.stop) {
 		if (netif_queue_stopped(priv->net_dev))
 			netif_wake_queue(priv->net_dev);
-		if (skb)
-			dev_kfree_skb(skb);
+
+		dev_kfree_skb(skb);
 
 		return 0;
 	}

commit c88b94a9f43cecdeae4fa3d30cadd9a3f604372f
Merge: 38c6aa2175c3 acb1872577b3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 30 10:13:15 2018 +0200

    Merge 4.18-rc7 into staging-next
    
    We want the staging changes in here for testing and merge issues.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eb37430d402de7d1cb2f37a5fdc80620dd98dc1d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Jul 13 09:36:59 2018 +0200

    staging: ks7010: call 'hostif_mib_set_request_int' instead of 'hostif_mib_set_request_bool'
    
    'hostif_mib_set_request_bool' function receives a bool as value and
    send the received value with MIB_VALUE_TYPE_BOOL type. There is
    one case where the value passed is not a boolean one but
    'MCAST_FILTER_PROMISC' which is '2'. Call hostif_mib_set_request_int
    instead for related multicast enumeration. This changes original
    code behaviour but seems to be the right way to do this.
    
    Fixes: 8ce76bff0e6a ("staging: ks7010: add new helpers to achieve mib set request and simplify code")
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 0ecffab52ec2..abdaf7cf8162 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1842,15 +1842,15 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 	memset(set_address, 0, NIC_MAX_MCAST_LIST * ETH_ALEN);
 
 	if (dev->flags & IFF_PROMISC) {
-		hostif_mib_set_request_bool(priv, LOCAL_MULTICAST_FILTER,
-					    MCAST_FILTER_PROMISC);
+		hostif_mib_set_request_int(priv, LOCAL_MULTICAST_FILTER,
+					   MCAST_FILTER_PROMISC);
 		goto spin_unlock;
 	}
 
 	if ((netdev_mc_count(dev) > NIC_MAX_MCAST_LIST) ||
 	    (dev->flags & IFF_ALLMULTI)) {
-		hostif_mib_set_request_bool(priv, LOCAL_MULTICAST_FILTER,
-					    MCAST_FILTER_MCASTALL);
+		hostif_mib_set_request_int(priv, LOCAL_MULTICAST_FILTER,
+					   MCAST_FILTER_MCASTALL);
 		goto spin_unlock;
 	}
 
@@ -1866,8 +1866,8 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 					       ETH_ALEN * mc_count);
 	} else {
 		priv->sme_i.sme_flag |= SME_MULTICAST;
-		hostif_mib_set_request_bool(priv, LOCAL_MULTICAST_FILTER,
-					    MCAST_FILTER_MCAST);
+		hostif_mib_set_request_int(priv, LOCAL_MULTICAST_FILTER,
+					   MCAST_FILTER_MCAST);
 	}
 
 spin_unlock:

commit 15fc3e4a08872dafe0e4f32a8fda5694ee3a6f03
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Jul 11 11:59:11 2018 +0100

    staging: ks7010: remove redundant variable eth_proto
    
    Variable eth_proto is being assigned but is never used hence it is
    redundant and can be removed.
    
    Cleans up clang warning:
    warning: variable 'eth_proto' set but not used [-Wunused-but-set-variable]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 0ecffab52ec2..a85975f63d26 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -354,7 +354,6 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 	u16 auth_type;
 	unsigned char temp[256];
 	struct ether_hdr *eth_hdr;
-	unsigned short eth_proto;
 	struct ieee802_1x_hdr *aa1x_hdr;
 	size_t size;
 	int ret;
@@ -369,7 +368,6 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 	get_word(priv);	/* Reserve Area */
 
 	eth_hdr = (struct ether_hdr *)(priv->rxp);
-	eth_proto = ntohs(eth_hdr->h_proto);
 
 	/* source address check */
 	if (ether_addr_equal(&priv->eth_addr[0], eth_hdr->h_source)) {

commit b2d187cc765afd4bad6b66664c099c804dda1432
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed May 16 13:25:55 2018 +0200

    staging: ks7010: avoid casting inside cpu_to_* assignments
    
    cpu_to_*() functions already have a cast to u* built in,
    so the cast is never required. Review and remove all of
    them along the code.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 66ab45a20787..0ecffab52ec2 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -989,7 +989,7 @@ static void *hostif_generic_request(size_t size, int event)
 	if (!p)
 		return NULL;
 
-	p->size = cpu_to_le16((u16)(size - sizeof(p->size)));
+	p->size = cpu_to_le16(size - sizeof(p->size));
 	p->event = cpu_to_le16(event);
 
 	return p;
@@ -1109,7 +1109,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 		    priv->wpa.key[1].key_len == 0 &&
 		    priv->wpa.key[2].key_len == 0 &&
 		    priv->wpa.key[3].key_len == 0) {
-			pp->auth_type = cpu_to_le16((u16)TYPE_AUTH);
+			pp->auth_type = cpu_to_le16(TYPE_AUTH);
 		} else {
 			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
 				michael_mic_function(&michael_mic,
@@ -1121,26 +1121,25 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 				skb_len += 8;
 				p += 8;
 				pp->auth_type =
-				    cpu_to_le16((u16)TYPE_DATA);
+				    cpu_to_le16(TYPE_DATA);
 
 			} else if (priv->wpa.pairwise_suite ==
 				   IW_AUTH_CIPHER_CCMP) {
 				pp->auth_type =
-				    cpu_to_le16((u16)TYPE_DATA);
+				    cpu_to_le16(TYPE_DATA);
 			}
 		}
 	} else {
 		if (eth_proto == ETH_P_PAE)
-			pp->auth_type = cpu_to_le16((u16)TYPE_AUTH);
+			pp->auth_type = cpu_to_le16(TYPE_AUTH);
 		else
-			pp->auth_type = cpu_to_le16((u16)TYPE_DATA);
+			pp->auth_type = cpu_to_le16(TYPE_DATA);
 	}
 
 	/* header value set */
 	pp->header.size =
-	    cpu_to_le16((u16)
-			(sizeof(*pp) - sizeof(pp->header.size) + skb_len));
-	pp->header.event = cpu_to_le16((u16)HIF_DATA_REQ);
+	    cpu_to_le16((sizeof(*pp) - sizeof(pp->header.size) + skb_len));
+	pp->header.event = cpu_to_le16(HIF_DATA_REQ);
 
 	/* tx request */
 	result = ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + skb_len),
@@ -1211,7 +1210,7 @@ static void hostif_mib_set_request(struct ks_wlan_private *priv,
 		return;
 
 	pp->mib_attribute = cpu_to_le32(attr);
-	pp->mib_value.size = cpu_to_le16((u16)size);
+	pp->mib_value.size = cpu_to_le16(size);
 	pp->mib_value.type = cpu_to_le16(type);
 	memcpy(&pp->mib_value.body, data, size);
 
@@ -1221,7 +1220,7 @@ static void hostif_mib_set_request(struct ks_wlan_private *priv,
 static inline void hostif_mib_set_request_int(struct ks_wlan_private *priv,
 					      enum mib_attribute attr, int val)
 {
-	__le32 v = cpu_to_le32((u32)val);
+	__le32 v = cpu_to_le32(val);
 	size_t size = sizeof(v);
 
 	hostif_mib_set_request(priv, attr, MIB_VALUE_TYPE_INT, &v, size);
@@ -1231,7 +1230,7 @@ static inline void hostif_mib_set_request_bool(struct ks_wlan_private *priv,
 					       enum mib_attribute attr,
 					       bool val)
 {
-	__le32 v = cpu_to_le32((u32)val);
+	__le32 v = cpu_to_le32(val);
 	size_t size = sizeof(v);
 
 	hostif_mib_set_request(priv, attr, MIB_VALUE_TYPE_BOOL, &v, size);
@@ -1253,7 +1252,7 @@ void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 	if (!pp)
 		return;
 
-	pp->mode = cpu_to_le16((u16)mode);
+	pp->mode = cpu_to_le16(mode);
 
 	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 
@@ -1281,9 +1280,9 @@ static __le16 ks_wlan_cap(struct ks_wlan_private *priv)
 static void init_request(struct ks_wlan_private *priv,
 			 struct hostif_request *req)
 {
-	req->phy_type = cpu_to_le16((u16)(priv->reg.phy_type));
-	req->cts_mode = cpu_to_le16((u16)(priv->reg.cts_mode));
-	req->scan_type = cpu_to_le16((u16)(priv->reg.scan_type));
+	req->phy_type = cpu_to_le16(priv->reg.phy_type);
+	req->cts_mode = cpu_to_le16(priv->reg.cts_mode);
+	req->scan_type = cpu_to_le16(priv->reg.scan_type);
 	req->rate_set.size = priv->reg.rate_set.size;
 	req->capability = ks_wlan_cap(priv);
 	memcpy(&req->rate_set.body[0], &priv->reg.rate_set.body[0],
@@ -1300,7 +1299,7 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 		return;
 
 	init_request(priv, &pp->request);
-	pp->channel = cpu_to_le16((u16)(priv->reg.channel));
+	pp->channel = cpu_to_le16(priv->reg.channel);
 
 	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }
@@ -1318,8 +1317,8 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv, int event)
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
 	pp->beacon_lost_count =
-	    cpu_to_le16((u16)(priv->reg.beacon_lost_count));
-	pp->auth_type = cpu_to_le16((u16)(priv->reg.authenticate_type));
+	    cpu_to_le16(priv->reg.beacon_lost_count);
+	pp->auth_type = cpu_to_le16(priv->reg.authenticate_type);
 
 	pp->channel_list.body[0] = 1;
 	pp->channel_list.body[1] = 8;
@@ -1354,7 +1353,7 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 		return;
 
 	init_request(priv, &pp->request);
-	pp->channel = cpu_to_le16((u16)(priv->reg.channel));
+	pp->channel = cpu_to_le16(priv->reg.channel);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
 
@@ -1403,11 +1402,11 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 		return;
 
 	if (priv->reg.phy_info_timer) {
-		pp->type = cpu_to_le16((u16)TIME_TYPE);
-		pp->time = cpu_to_le16((u16)(priv->reg.phy_info_timer));
+		pp->type = cpu_to_le16(TIME_TYPE);
+		pp->time = cpu_to_le16(priv->reg.phy_info_timer);
 	} else {
-		pp->type = cpu_to_le16((u16)NORMAL_TYPE);
-		pp->time = cpu_to_le16((u16)0);
+		pp->type = cpu_to_le16(NORMAL_TYPE);
+		pp->time = cpu_to_le16(0);
 	}
 
 	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
@@ -1464,8 +1463,8 @@ void hostif_bss_scan_request(struct ks_wlan_private *priv,
 
 	pp->scan_type = scan_type;
 
-	pp->ch_time_min = cpu_to_le32((u32)110);	/* default value */
-	pp->ch_time_max = cpu_to_le32((u32)130);	/* default value */
+	pp->ch_time_min = cpu_to_le32(110);	/* default value */
+	pp->ch_time_max = cpu_to_le32(130);	/* default value */
 	pp->channel_list.body[0] = 1;
 	pp->channel_list.body[1] = 8;
 	pp->channel_list.body[2] = 2;
@@ -1619,7 +1618,7 @@ static void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 
 	switch (type) {
 	case SME_RSN_UCAST_REQUEST:
-		wpa_suite.size = cpu_to_le16((u16)1);
+		wpa_suite.size = cpu_to_le16(1);
 		switch (priv->wpa.pairwise_suite) {
 		case IW_AUTH_CIPHER_NONE:
 			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
@@ -1682,7 +1681,7 @@ static void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 					       CIPHER_ID_LEN);
 		break;
 	case SME_RSN_AUTH_REQUEST:
-		wpa_suite.size = cpu_to_le16((u16)1);
+		wpa_suite.size = cpu_to_le16(1);
 		switch (priv->wpa.key_mgmt_suite) {
 		case IW_AUTH_KEY_MGMT_802_1X:
 			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
@@ -1721,7 +1720,7 @@ static void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 			(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA) ?
 			 RSN_MODE_WPA : RSN_MODE_NONE;
 		rsn_mode.rsn_mode = cpu_to_le32(mode);
-		rsn_mode.rsn_capability = cpu_to_le16((u16)0);
+		rsn_mode.rsn_capability = cpu_to_le16(0);
 		hostif_mib_set_request_ostring(priv, LOCAL_RSN_MODE,
 					       &rsn_mode, sizeof(rsn_mode));
 		break;
@@ -1979,7 +1978,7 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 		memcpy(pmkcache.list[i].pmkid, pmk->pmkid, IW_PMKID_LEN);
 		i++;
 	}
-	pmkcache.size = cpu_to_le16((u16)(priv->pmklist.size));
+	pmkcache.size = cpu_to_le16(priv->pmklist.size);
 	size = sizeof(priv->pmklist.size) +
 	       ((ETH_ALEN + IW_PMKID_LEN) * priv->pmklist.size);
 	hostif_mib_set_request_ostring(priv, LOCAL_PMK, &pmkcache, size);

commit b7369066571ea8a17a424b15f1e4823ab346c3d0
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:58 2018 +0200

    staging: ks7010: replace cast type in assignment in hostif_sme_set_pmksa
    
    There is an assignment inside hostif_sme_set_pmksa function
    which is being used together with cpu_to_le16 using uint16_t as cast
    type. Replace it to use 'u16' instead.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 4e88767ac848..66ab45a20787 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1979,7 +1979,7 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 		memcpy(pmkcache.list[i].pmkid, pmk->pmkid, IW_PMKID_LEN);
 		i++;
 	}
-	pmkcache.size = cpu_to_le16((uint16_t)(priv->pmklist.size));
+	pmkcache.size = cpu_to_le16((u16)(priv->pmklist.size));
 	size = sizeof(priv->pmklist.size) +
 	       ((ETH_ALEN + IW_PMKID_LEN) * priv->pmklist.size);
 	hostif_mib_set_request_ostring(priv, LOCAL_PMK, &pmkcache, size);

commit 88c80162329c83ea3dea2017c9852776892cc6d6
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:57 2018 +0200

    staging: ks7010: use 'u16' for casts in assignments in hostif_sme_set_rsn
    
    There are some assignments inside hostif_sme_set_rsn function
    which are being used together with cpu_to_le16 using uint16_t
    as cast type. Replace all of them to use 'u16' instead.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 1cb5d90403a5..4e88767ac848 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1619,7 +1619,7 @@ static void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 
 	switch (type) {
 	case SME_RSN_UCAST_REQUEST:
-		wpa_suite.size = cpu_to_le16((uint16_t)1);
+		wpa_suite.size = cpu_to_le16((u16)1);
 		switch (priv->wpa.pairwise_suite) {
 		case IW_AUTH_CIPHER_NONE:
 			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
@@ -1682,7 +1682,7 @@ static void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 					       CIPHER_ID_LEN);
 		break;
 	case SME_RSN_AUTH_REQUEST:
-		wpa_suite.size = cpu_to_le16((uint16_t)1);
+		wpa_suite.size = cpu_to_le16((u16)1);
 		switch (priv->wpa.key_mgmt_suite) {
 		case IW_AUTH_KEY_MGMT_802_1X:
 			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
@@ -1721,7 +1721,7 @@ static void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 			(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA) ?
 			 RSN_MODE_WPA : RSN_MODE_NONE;
 		rsn_mode.rsn_mode = cpu_to_le32(mode);
-		rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
+		rsn_mode.rsn_capability = cpu_to_le16((u16)0);
 		hostif_mib_set_request_ostring(priv, LOCAL_RSN_MODE,
 					       &rsn_mode, sizeof(rsn_mode));
 		break;

commit 14b61a520567118088948c8e60d367e870d74d28
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:56 2018 +0200

    staging: ks7010: change two parameter types in hostif_mic_failure_request
    
    Parameters 'failure_count' and 'timer' was declared as unsigned
    short and then there was being casted to u16 inside cpu_to_le16
    to make the assignation. Just declare them as 'u16' and avoid
    casting at all.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 5e7d3fa00ed4..1cb5d90403a5 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1501,8 +1501,7 @@ void hostif_bss_scan_request(struct ks_wlan_private *priv,
 
 static
 void hostif_mic_failure_request(struct ks_wlan_private *priv,
-				unsigned short failure_count,
-				unsigned short timer)
+				u16 failure_count, u16 timer)
 {
 	struct hostif_mic_failure_request *pp;
 
@@ -1510,8 +1509,8 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 	if (!pp)
 		return;
 
-	pp->failure_count = cpu_to_le16((uint16_t)failure_count);
-	pp->timer = cpu_to_le16((uint16_t)timer);
+	pp->failure_count = cpu_to_le16(failure_count);
+	pp->timer = cpu_to_le16(timer);
 
 	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }

commit dea2f1fb84c8b7d3581e90def1834b7bf4bdd585
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:55 2018 +0200

    staging: ks7010: replace uint* type into the u* ones in hostif_bss_scan_request
    
    In function hostif_bss_scan_request parameters 'scan_ssid' and
    'scan_ssid_len' are declared as uint8_t. Change them to be 'u8'
    instead which is preferred. Also update two casts inside the same
    function to use 'u32' instead of 'uint32_t'.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index cf9e98f750a3..5e7d3fa00ed4 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1453,8 +1453,8 @@ void hostif_sleep_request(struct ks_wlan_private *priv,
 
 static
 void hostif_bss_scan_request(struct ks_wlan_private *priv,
-			     unsigned long scan_type, uint8_t *scan_ssid,
-			     uint8_t scan_ssid_len)
+			     unsigned long scan_type, u8 *scan_ssid,
+			     u8 scan_ssid_len)
 {
 	struct hostif_bss_scan_request *pp;
 
@@ -1464,8 +1464,8 @@ void hostif_bss_scan_request(struct ks_wlan_private *priv,
 
 	pp->scan_type = scan_type;
 
-	pp->ch_time_min = cpu_to_le32((uint32_t)110);	/* default value */
-	pp->ch_time_max = cpu_to_le32((uint32_t)130);	/* default value */
+	pp->ch_time_min = cpu_to_le32((u32)110);	/* default value */
+	pp->ch_time_max = cpu_to_le32((u32)130);	/* default value */
 	pp->channel_list.body[0] = 1;
 	pp->channel_list.body[1] = 8;
 	pp->channel_list.body[2] = 2;

commit 9a1420e7a525f8602d84869b6983359799452320
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:54 2018 +0200

    staging: ks7010: replace cast types in assignments in hostif_phy_information_request
    
    There are some assignments inside hostif_phy_information_request
    function which are being used together with cpu_to_le16 using
    uint16_t as cast type. Replace all of them to use 'u16' instead.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index b946f516b4ab..cf9e98f750a3 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1403,11 +1403,11 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 		return;
 
 	if (priv->reg.phy_info_timer) {
-		pp->type = cpu_to_le16((uint16_t)TIME_TYPE);
-		pp->time = cpu_to_le16((uint16_t)(priv->reg.phy_info_timer));
+		pp->type = cpu_to_le16((u16)TIME_TYPE);
+		pp->time = cpu_to_le16((u16)(priv->reg.phy_info_timer));
 	} else {
-		pp->type = cpu_to_le16((uint16_t)NORMAL_TYPE);
-		pp->time = cpu_to_le16((uint16_t)0);
+		pp->type = cpu_to_le16((u16)NORMAL_TYPE);
+		pp->time = cpu_to_le16((u16)0);
 	}
 
 	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));

commit bcbd1f18417ff138e39f7169304fbdb64b64a30a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:53 2018 +0200

    staging: ks7010: replace cast type in assignment in hostif_adhoc_set_request
    
    There is an assignment inside hostif_adhoc_set_request function
    which is being used together with cpu_to_le16 using uint16_t as cast
    type. Replace it to use 'u16' instead.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index bf410e33c55a..b946f516b4ab 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1354,7 +1354,7 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 		return;
 
 	init_request(priv, &pp->request);
-	pp->channel = cpu_to_le16((uint16_t)(priv->reg.channel));
+	pp->channel = cpu_to_le16((u16)(priv->reg.channel));
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
 

commit 78e241718151dab7640f5cd2b742fafc49a2f02b
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:52 2018 +0200

    staging: ks7010: replace cast type in assignments in hostif_infrastructure_set_request
    
    There are some assignments inside hostif_infrastructure_set_request
    function which are being used together with cpu_to_le16 using
    uint16_t as cast type. Replace all of them to use 'u16' instead.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 6d4702ef1d93..bf410e33c55a 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1318,8 +1318,8 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv, int event)
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
 	pp->beacon_lost_count =
-	    cpu_to_le16((uint16_t)(priv->reg.beacon_lost_count));
-	pp->auth_type = cpu_to_le16((uint16_t)(priv->reg.authenticate_type));
+	    cpu_to_le16((u16)(priv->reg.beacon_lost_count));
+	pp->auth_type = cpu_to_le16((u16)(priv->reg.authenticate_type));
 
 	pp->channel_list.body[0] = 1;
 	pp->channel_list.body[1] = 8;

commit 889d7063305f00cc31d97744e2dac0d2162354e8
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:51 2018 +0200

    staging: ks7010: use u16 as type for casting in hostif_ps_adhoc_set_request
    
    There is an assignment inside hostif_ps_adhoc_set_request function
    which is being used together with cpu_to_le16 using uint16_t as cast
    type. Replace it to use 'u16' instead.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 2681e2e57204..6d4702ef1d93 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1300,7 +1300,7 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 		return;
 
 	init_request(priv, &pp->request);
-	pp->channel = cpu_to_le16((uint16_t)(priv->reg.channel));
+	pp->channel = cpu_to_le16((u16)(priv->reg.channel));
 
 	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }

commit 22bef066492536570c9a1156110df59ef42fbec9
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:50 2018 +0200

    staging: ks7010: replace casts to use type u16 in init_request
    
    There are soem assignments inside init_request function which
    are being used together with cpu_to_le16 using uint16_t as cast
    type. Replace all of them to use 'u16' instead.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index ee8dcb3cb342..2681e2e57204 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1281,9 +1281,9 @@ static __le16 ks_wlan_cap(struct ks_wlan_private *priv)
 static void init_request(struct ks_wlan_private *priv,
 			 struct hostif_request *req)
 {
-	req->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
-	req->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
-	req->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+	req->phy_type = cpu_to_le16((u16)(priv->reg.phy_type));
+	req->cts_mode = cpu_to_le16((u16)(priv->reg.cts_mode));
+	req->scan_type = cpu_to_le16((u16)(priv->reg.scan_type));
 	req->rate_set.size = priv->reg.rate_set.size;
 	req->capability = ks_wlan_cap(priv);
 	memcpy(&req->rate_set.body[0], &priv->reg.rate_set.body[0],

commit 5503fd5afd8ea3066616b22e7b617c00bb78993e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:49 2018 +0200

    staging: ks7010: use u16 as cast type in hostif_start_request
    
    Use u16 as cast type in hostif_start_request function replacing
    uint16_t which was being used.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index adc6ccffc87b..ee8dcb3cb342 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1253,7 +1253,7 @@ void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 	if (!pp)
 		return;
 
-	pp->mode = cpu_to_le16((uint16_t)mode);
+	pp->mode = cpu_to_le16((u16)mode);
 
 	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 

commit f7761114be421ae1993ce711a600e993337a6288
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:48 2018 +0200

    staging: ks7010: avoid no needed cast in ks_wlan_cap
    
    In ks_wlan_cap there is a cast to uint16_t to use cpu_to_le16
    with variable 'capability' which is already defined as u16.
    Avoid this cast to clean code.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 9724a48a350c..adc6ccffc87b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1275,7 +1275,7 @@ static __le16 ks_wlan_cap(struct ks_wlan_private *priv)
 		capability &= ~(WLAN_CAPABILITY_DSSS_OFDM);
 	}
 
-	return cpu_to_le16((uint16_t)capability);
+	return cpu_to_le16(capability);
 }
 
 static void init_request(struct ks_wlan_private *priv,

commit 81ad5837d0768031de3792973b5d47e7a7ec0b14
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:47 2018 +0200

    staging: ks7010: change parameter type in hostif_mib_get_request
    
    Second parameter 'mib_attribute' in function hostif_mib_get_request
    is declared as unsigned long and inside the function a cast to uint32_t
    is being used. Just pass a u32 instead and avoid the casting.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index ecdd1341186f..9724a48a350c 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1182,9 +1182,8 @@ static inline void send_request_to_device(struct ks_wlan_private *priv,
 	ks_wlan_hw_tx(priv, data, size, NULL, NULL);
 }
 
-static
-void hostif_mib_get_request(struct ks_wlan_private *priv,
-			    unsigned long mib_attribute)
+static void hostif_mib_get_request(struct ks_wlan_private *priv,
+				   u32 mib_attribute)
 {
 	struct hostif_mib_get_request *pp;
 
@@ -1192,7 +1191,7 @@ void hostif_mib_get_request(struct ks_wlan_private *priv,
 	if (!pp)
 		return;
 
-	pp->mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
+	pp->mib_attribute = cpu_to_le32(mib_attribute);
 
 	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }

commit 521d3f26bc866a79cc3b464e8e3dec555fd34611
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:46 2018 +0200

    staging: ks7010: change some cast type from uint16_t to u16 in hostif_data_request
    
    There are some castings inside the function hostif_data_request
    which are being using with uint16_t type. Fields which have being
    assigned are declared as u16. So update casts types to u16 in all
    of them.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 9d3f7e38f7cc..ecdd1341186f 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1109,7 +1109,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 		    priv->wpa.key[1].key_len == 0 &&
 		    priv->wpa.key[2].key_len == 0 &&
 		    priv->wpa.key[3].key_len == 0) {
-			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);
+			pp->auth_type = cpu_to_le16((u16)TYPE_AUTH);
 		} else {
 			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
 				michael_mic_function(&michael_mic,
@@ -1121,26 +1121,26 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 				skb_len += 8;
 				p += 8;
 				pp->auth_type =
-				    cpu_to_le16((uint16_t)TYPE_DATA);
+				    cpu_to_le16((u16)TYPE_DATA);
 
 			} else if (priv->wpa.pairwise_suite ==
 				   IW_AUTH_CIPHER_CCMP) {
 				pp->auth_type =
-				    cpu_to_le16((uint16_t)TYPE_DATA);
+				    cpu_to_le16((u16)TYPE_DATA);
 			}
 		}
 	} else {
 		if (eth_proto == ETH_P_PAE)
-			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);
+			pp->auth_type = cpu_to_le16((u16)TYPE_AUTH);
 		else
-			pp->auth_type = cpu_to_le16((uint16_t)TYPE_DATA);
+			pp->auth_type = cpu_to_le16((u16)TYPE_DATA);
 	}
 
 	/* header value set */
 	pp->header.size =
-	    cpu_to_le16((uint16_t)
+	    cpu_to_le16((u16)
 			(sizeof(*pp) - sizeof(pp->header.size) + skb_len));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_DATA_REQ);
+	pp->header.event = cpu_to_le16((u16)HIF_DATA_REQ);
 
 	/* tx request */
 	result = ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + skb_len),

commit bc0b3f43ca94c5e52564a13f61b7303a91883185
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:45 2018 +0200

    staging: ks7010: use u16 as type for casting in hostif_data_indication_wpa
    
    Field 'counter' in mic_failure struct is being assigned casting
    value using uint16_t. Replace with u16 which is the correct type
    of the field and the preferred one.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 7b6a3850d55d..9d3f7e38f7cc 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -323,7 +323,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 			} else if (mic_failure->failure == 1) {
 				mic_failure->failure = 2;
 				mic_failure->counter =
-					(uint16_t)((now - mic_failure->last_failure_time) / HZ);
+					(u16)((now - mic_failure->last_failure_time) / HZ);
 				/*  range 1-60 */
 				if (!mic_failure->counter)
 					mic_failure->counter = 1;

commit d82e514003a0e2c426225afe2520de300b8bc8ba
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:51 2018 +0200

    staging: ks7010: review local variable types in hostif_phy_information_confirm
    
    This commit changes types for local variables declared in
    hostif_phy_information_confirm function to use the preferred
    one 'u8' and 'u32'. Its values are get using get_byte and get_dword
    functions which returns 'u8' and 'u32' so it makes sense.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index cf33a1cccc16..7b6a3850d55d 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -866,10 +866,10 @@ static
 void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 {
 	struct iw_statistics *wstats = &priv->wstats;
-	unsigned char rssi, signal, noise;
-	unsigned char link_speed;
-	unsigned int transmitted_frame_count, received_fragment_count;
-	unsigned int failed_count, fcs_error_count;
+	u8 rssi, signal, noise;
+	u8 link_speed;
+	u32 transmitted_frame_count, received_fragment_count;
+	u32 failed_count, fcs_error_count;
 
 	rssi = get_byte(priv);
 	signal = get_byte(priv);

commit 677e281d532024a8621de8d8c854d694ef5e5921
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:50 2018 +0200

    staging: ks7010: use u32 instead of unsigned int in hostif_bss_scan_confirm
    
    Local variable 'result_code' is declared as unsigned int in
    hostif_bss_scan_confirm function. Its value is got calling
    get_dword which returns an 'u32' so change its type to u32
    which is preferred
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index fde5b6ee7ed5..cf33a1cccc16 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -845,7 +845,7 @@ void hostif_associate_indication(struct ks_wlan_private *priv)
 static
 void hostif_bss_scan_confirm(struct ks_wlan_private *priv)
 {
-	unsigned int result_code;
+	u32 result_code;
 	struct net_device *dev = priv->net_dev;
 	union iwreq_data wrqu;
 

commit ab0bb2a4035e7baa5dbfc2fefc7b556ce54f6046
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:49 2018 +0200

    staging: ks7010: use u16 instead of unsigned short in hostif_connect_indication
    
    Local variable 'connect_code' is declared as unsigned short in
    hostif_connect_indication function. Its value is got calling
    get_word which returns an 'u16' so change its type to u16
    which is preferred.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index d4ce9860d4c2..fde5b6ee7ed5 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -655,7 +655,7 @@ void hostif_start_confirm(struct ks_wlan_private *priv)
 static
 void hostif_connect_indication(struct ks_wlan_private *priv)
 {
-	unsigned short connect_code;
+	u16 connect_code;
 	unsigned int tmp = 0;
 	unsigned int old_status = priv->connect_status;
 	struct net_device *netdev = priv->net_dev;

commit 19e8a0d7305713a348a07db06921856104cce3bb
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:48 2018 +0200

    staging: ks7010: use u16 instead of unsigned short in hostif_data_indication
    
    Local variable 'auth_type' is declared as unsigned short in
    hostif_data_indication function. Its value is got calling get_word
    which returns an 'u16' so change its type to u16 which is preferred.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 1a034d5c47a8..d4ce9860d4c2 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -351,7 +351,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 {
 	unsigned int rx_ind_size;	/* indicate data size */
 	struct sk_buff *skb;
-	unsigned short auth_type;
+	u16 auth_type;
 	unsigned char temp[256];
 	struct ether_hdr *eth_hdr;
 	unsigned short eth_proto;

commit 5437e9b2434becbadbc883bc312068a15fd3bb6c
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:47 2018 +0200

    staging: ks7010: use u16 instead of unsigned short in hostif_event_check
    
    Local variable 'event' is declared as unsigned short in hostif_event_check
    function. Its value is got calling get_word which returns an 'u16'
    so change its type to u16 which is preferred.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 3db5679cdaf5..1a034d5c47a8 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -912,7 +912,7 @@ void hostif_mic_failure_confirm(struct ks_wlan_private *priv)
 static
 void hostif_event_check(struct ks_wlan_private *priv)
 {
-	unsigned short event;
+	u16 event;
 
 	event = get_word(priv);
 	switch (event) {

commit d74d0899349221b4356545ba88e4d0882d049d2f
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:46 2018 +0200

    staging: ks7010: refactor LOCAL_EEPROM_SUM case in hostif_mib_get_confirm
    
    This commit simplify conditional paths in LOCAL_EEPROM_SUM case
    inside hostif_mib_get_confirm function. It change logic to handle
    invalid values first and assign good ones at the end if it is the
    case.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 7a511231225f..3db5679cdaf5 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -504,18 +504,15 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		break;
 	case LOCAL_EEPROM_SUM:
 		memcpy(&priv->eeprom_sum, priv->rxp, sizeof(priv->eeprom_sum));
-		if (priv->eeprom_sum.type == 0) {
-			priv->eeprom_checksum = EEPROM_CHECKSUM_NONE;
-		} else if (priv->eeprom_sum.type == 1) {
-			if (priv->eeprom_sum.result == 0) {
-				priv->eeprom_checksum = EEPROM_NG;
-				netdev_info(dev, "LOCAL_EEPROM_SUM NG\n");
-			} else if (priv->eeprom_sum.result == 1) {
-				priv->eeprom_checksum = EEPROM_OK;
-			}
-		} else {
+		if (priv->eeprom_sum.type != 0 &&
+		    priv->eeprom_sum.type != 1) {
 			netdev_err(dev, "LOCAL_EEPROM_SUM error!\n");
+			return;
 		}
+		priv->eeprom_checksum = (priv->eeprom_sum.type == 0) ?
+					 EEPROM_CHECKSUM_NONE :
+					 (priv->eeprom_sum.result == 0) ?
+					 EEPROM_NG : EEPROM_OK;
 		break;
 	default:
 		netdev_err(priv->net_dev, "mib_attribute=%08x\n",

commit 5089cd418962823ff3a1ed1a0ec6a7d764fac27b
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:45 2018 +0200

    staging: ks7010: use CIRC_CNT_TO_END macro in cnt_smeqbody
    
    This commit changes custom implementation of CIRC_CNT_TO_END.
    Just use the linux kernel header one to simplify code.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 359187e1009b..7a511231225f 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -6,6 +6,7 @@
  *   Copyright (C) 2009 Renesas Technology Corp.
  */
 
+#include <linux/circ_buf.h>
 #include <linux/if_arp.h>
 #include <net/iw_handler.h>
 #include <uapi/linux/llc.h>
@@ -26,9 +27,8 @@ static inline void inc_smeqtail(struct ks_wlan_private *priv)
 
 static inline unsigned int cnt_smeqbody(struct ks_wlan_private *priv)
 {
-	unsigned int sme_cnt = priv->sme_i.qtail - priv->sme_i.qhead;
-
-	return (sme_cnt + SME_EVENT_BUFF_SIZE) % SME_EVENT_BUFF_SIZE;
+	return CIRC_CNT_TO_END(priv->sme_i.qhead, priv->sme_i.qtail,
+			       SME_EVENT_BUFF_SIZE);
 }
 
 static inline u8 get_byte(struct ks_wlan_private *priv)

commit d87e9626c000b95c80bda3afe705303f17bbec84
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:38 2018 +0200

    staging: ks7010: refactor hostif_sme_power_mgmt_set function
    
    This commit refactor hostif_sme_power_mgmt_set avoiding to
    use switch-case statement and simplifying data paths. This
    improves readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 3a6385c0349c..359187e1009b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1880,36 +1880,23 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 	spin_unlock(&priv->multicast_spin);
 }
 
-static
-void hostif_sme_power_mgmt_set(struct ks_wlan_private *priv)
+static void hostif_sme_power_mgmt_set(struct ks_wlan_private *priv)
 {
 	u32 mode, wake_up, receive_dtims;
 
-	switch (priv->reg.power_mgmt) {
-	case POWER_MGMT_SAVE1:
-		mode = (priv->reg.operation_mode == MODE_INFRASTRUCTURE) ?
-			POWER_SAVE : POWER_ACTIVE;
-		wake_up = 0;
-		receive_dtims = 0;
-		break;
-	case POWER_MGMT_SAVE2:
-		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
-			mode = POWER_SAVE;
-			wake_up = 0;
-			receive_dtims = 1;
-		} else {
-			mode = POWER_ACTIVE;
-			wake_up = 0;
-			receive_dtims = 0;
-		}
-		break;
-	case POWER_MGMT_ACTIVE:
-	default:
+	if (priv->reg.power_mgmt != POWER_MGMT_SAVE1 &&
+	    priv->reg.power_mgmt != POWER_MGMT_SAVE2) {
 		mode = POWER_ACTIVE;
 		wake_up = 0;
 		receive_dtims = 0;
-		break;
+	} else {
+		mode = (priv->reg.operation_mode == MODE_INFRASTRUCTURE) ?
+			POWER_SAVE : POWER_ACTIVE;
+		wake_up = 0;
+		receive_dtims = (priv->reg.operation_mode == MODE_INFRASTRUCTURE &&
+				 priv->reg.power_mgmt == POWER_MGMT_SAVE2);
 	}
+
 	hostif_power_mgmt_request(priv, mode, wake_up, receive_dtims);
 }
 

commit 0d8be3067f7f43de2eb5efb6edea467640226022
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:37 2018 +0200

    staging: ks7010: change parameter types in hostif_power_mgmt_request
    
    Parameters for hostif_power_mgmt_request are declared as unsigned
    long and then are forced to be change to be u32. Also the caller
    declares explicitly unsigned long parameters just to assign them
    and pass into the function. Change types for those to be u32 instead
    so no conversion is needed at all and code gets more clear.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 08f95f711b6f..3a6385c0349c 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1419,8 +1419,7 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 
 static
 void hostif_power_mgmt_request(struct ks_wlan_private *priv,
-			       unsigned long mode, unsigned long wake_up,
-			       unsigned long receive_dtims)
+			       u32 mode, u32 wake_up, u32 receive_dtims)
 {
 	struct hostif_power_mgmt_request *pp;
 
@@ -1428,9 +1427,9 @@ void hostif_power_mgmt_request(struct ks_wlan_private *priv,
 	if (!pp)
 		return;
 
-	pp->mode = cpu_to_le32((uint32_t)mode);
-	pp->wake_up = cpu_to_le32((uint32_t)wake_up);
-	pp->receive_dtims = cpu_to_le32((uint32_t)receive_dtims);
+	pp->mode = cpu_to_le32(mode);
+	pp->wake_up = cpu_to_le32(wake_up);
+	pp->receive_dtims = cpu_to_le32(receive_dtims);
 
 	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }
@@ -1884,7 +1883,7 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 static
 void hostif_sme_power_mgmt_set(struct ks_wlan_private *priv)
 {
-	unsigned long mode, wake_up, receive_dtims;
+	u32 mode, wake_up, receive_dtims;
 
 	switch (priv->reg.power_mgmt) {
 	case POWER_MGMT_SAVE1:

commit f20703b4cf11f9bde320714f7da933086e087af0
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:36 2018 +0200

    staging: ks7010: refactor hostif_sme_set_rsn function
    
    This commit make use of two introduced local variables
    to make more readable code of hostif_sme_set_rsn function.
    It just assign those local variables in different cases
    where are needed and extract common code to assign them
    at the end.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 30c2d3ad7e2b..08f95f711b6f 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1613,12 +1613,13 @@ struct rsn_mode {
 	__le16 rsn_capability;
 } __packed;
 
-static
-void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
+static void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 {
 	struct wpa_suite wpa_suite;
 	struct rsn_mode rsn_mode;
 	size_t size;
+	u32 mode;
+	const u8 *buf = NULL;
 
 	memset(&wpa_suite, 0, sizeof(wpa_suite));
 
@@ -1627,47 +1628,29 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 		wpa_suite.size = cpu_to_le16((uint16_t)1);
 		switch (priv->wpa.pairwise_suite) {
 		case IW_AUTH_CIPHER_NONE:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA2_NONE, CIPHER_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA_NONE, CIPHER_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				CIPHER_ID_WPA2_NONE : CIPHER_ID_WPA_NONE;
 			break;
 		case IW_AUTH_CIPHER_WEP40:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA2_WEP40, CIPHER_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA_WEP40, CIPHER_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				CIPHER_ID_WPA2_WEP40 : CIPHER_ID_WPA_WEP40;
 			break;
 		case IW_AUTH_CIPHER_TKIP:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA2_TKIP, CIPHER_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA_TKIP, CIPHER_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				CIPHER_ID_WPA2_TKIP : CIPHER_ID_WPA_TKIP;
 			break;
 		case IW_AUTH_CIPHER_CCMP:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA2_CCMP, CIPHER_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA_CCMP, CIPHER_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				CIPHER_ID_WPA2_CCMP : CIPHER_ID_WPA_CCMP;
 			break;
 		case IW_AUTH_CIPHER_WEP104:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA2_WEP104, CIPHER_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA_WEP104, CIPHER_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				CIPHER_ID_WPA2_WEP104 : CIPHER_ID_WPA_WEP104;
 			break;
 		}
 
+		if (buf)
+			memcpy(&wpa_suite.suite[0][0], buf, CIPHER_ID_LEN);
 		size = sizeof(wpa_suite.size) +
 		       (CIPHER_ID_LEN * le16_to_cpu(wpa_suite.size));
 		hostif_mib_set_request_ostring(priv,
@@ -1677,46 +1660,28 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 	case SME_RSN_MCAST_REQUEST:
 		switch (priv->wpa.group_suite) {
 		case IW_AUTH_CIPHER_NONE:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA2_NONE, CIPHER_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA_NONE, CIPHER_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				CIPHER_ID_WPA2_NONE : CIPHER_ID_WPA_NONE;
 			break;
 		case IW_AUTH_CIPHER_WEP40:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA2_WEP40, CIPHER_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA_WEP40, CIPHER_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				CIPHER_ID_WPA2_WEP40 : CIPHER_ID_WPA_WEP40;
 			break;
 		case IW_AUTH_CIPHER_TKIP:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA2_TKIP, CIPHER_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA_TKIP, CIPHER_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				CIPHER_ID_WPA2_TKIP : CIPHER_ID_WPA_TKIP;
 			break;
 		case IW_AUTH_CIPHER_CCMP:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA2_CCMP, CIPHER_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA_CCMP, CIPHER_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				CIPHER_ID_WPA2_CCMP : CIPHER_ID_WPA_CCMP;
 			break;
 		case IW_AUTH_CIPHER_WEP104:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA2_WEP104, CIPHER_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       CIPHER_ID_WPA_WEP104, CIPHER_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				CIPHER_ID_WPA2_WEP104 : CIPHER_ID_WPA_WEP104;
 			break;
 		}
+		if (buf)
+			memcpy(&wpa_suite.suite[0][0], buf, CIPHER_ID_LEN);
 		hostif_mib_set_request_ostring(priv,
 					       DOT11_RSN_CONFIG_MULTICAST_CIPHER,
 					       &wpa_suite.suite[0][0],
@@ -1726,41 +1691,26 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 		wpa_suite.size = cpu_to_le16((uint16_t)1);
 		switch (priv->wpa.key_mgmt_suite) {
 		case IW_AUTH_KEY_MGMT_802_1X:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       KEY_MGMT_ID_WPA2_1X, KEY_MGMT_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       KEY_MGMT_ID_WPA_1X, KEY_MGMT_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				KEY_MGMT_ID_WPA2_1X : KEY_MGMT_ID_WPA_1X;
 			break;
 		case IW_AUTH_KEY_MGMT_PSK:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       KEY_MGMT_ID_WPA2_PSK, KEY_MGMT_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       KEY_MGMT_ID_WPA_PSK, KEY_MGMT_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				KEY_MGMT_ID_WPA2_PSK : KEY_MGMT_ID_WPA_PSK;
 			break;
 		case 0:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       KEY_MGMT_ID_WPA2_NONE, KEY_MGMT_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       KEY_MGMT_ID_WPA_NONE, KEY_MGMT_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				KEY_MGMT_ID_WPA2_NONE : KEY_MGMT_ID_WPA_NONE;
 			break;
 		case 4:
-			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],
-				       KEY_MGMT_ID_WPA2_WPANONE,
-				       KEY_MGMT_ID_LEN);
-			else
-				memcpy(&wpa_suite.suite[0][0],
-				       KEY_MGMT_ID_WPA_WPANONE,
-				       KEY_MGMT_ID_LEN);
+			buf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+				KEY_MGMT_ID_WPA2_WPANONE :
+				KEY_MGMT_ID_WPA_WPANONE;
 			break;
 		}
 
+		if (buf)
+			memcpy(&wpa_suite.suite[0][0], buf, KEY_MGMT_ID_LEN);
 		size = sizeof(wpa_suite.size) +
 		       (KEY_MGMT_ID_LEN * le16_to_cpu(wpa_suite.size));
 		hostif_mib_set_request_ostring(priv,
@@ -1772,19 +1722,12 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 					    priv->wpa.rsn_enabled);
 		break;
 	case SME_RSN_MODE_REQUEST:
-		if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) {
-			rsn_mode.rsn_mode =
-			    cpu_to_le32((uint32_t)RSN_MODE_WPA2);
-			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
-		} else if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA) {
-			rsn_mode.rsn_mode =
-			    cpu_to_le32((uint32_t)RSN_MODE_WPA);
-			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
-		} else {
-			rsn_mode.rsn_mode =
-			    cpu_to_le32((uint32_t)RSN_MODE_NONE);
-			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
-		}
+		mode = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?
+			RSN_MODE_WPA2 :
+			(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA) ?
+			 RSN_MODE_WPA : RSN_MODE_NONE;
+		rsn_mode.rsn_mode = cpu_to_le32(mode);
+		rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
 		hostif_mib_set_request_ostring(priv, LOCAL_RSN_MODE,
 					       &rsn_mode, sizeof(rsn_mode));
 		break;

commit 2152effabe7eded7de15dff2c1270c01a7b8b3b3
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:35 2018 +0200

    staging: ks7010: add blank line between after definitions
    
    Add blank line after definitions in hostif_aplist_init function
    to fix a checkpatch script complain about that.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 644a08347193..30c2d3ad7e2b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2255,6 +2255,7 @@ void hostif_sme_enqueue(struct ks_wlan_private *priv, u16 event)
 static inline void hostif_aplist_init(struct ks_wlan_private *priv)
 {
 	size_t size = LOCAL_APLIST_MAX * sizeof(struct local_ap);
+
 	priv->aplist.size = 0;
 	memset(&priv->aplist.ap[0], 0, size);
 }

commit e4c4cdf17e3d920ecfa65e1959640134c0ad4910
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:34 2018 +0200

    staging: ks7010: fix some style issues in ks_hostif.c
    
    Fix some checkpatch complains about long lines in some
    parts of the code. It also fix some lines where spaces
    instead of tabs were inserted.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 1a592180ee1d..644a08347193 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -153,7 +153,8 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)
 	if (is_connect_status(priv->connect_status)) {
 		ether_addr_copy(wrqu.ap_addr.sa_data, priv->current_ap.bssid);
 		netdev_dbg(priv->net_dev,
-			   "IWEVENT: connect bssid=%pM\n", wrqu.ap_addr.sa_data);
+			   "IWEVENT: connect bssid=%pM\n",
+			   wrqu.ap_addr.sa_data);
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);
 	}
 	netdev_dbg(priv->net_dev, "Link AP\n"
@@ -254,7 +255,8 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info *ap_info,
 		case WLAN_EID_ERP_INFO:
 			break;
 		default:
-			netdev_err(priv->net_dev, "unknown Element ID=%d\n", *bp);
+			netdev_err(priv->net_dev,
+				   "unknown Element ID=%d\n", *bp);
 			break;
 		}
 
@@ -322,7 +324,8 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 				mic_failure->failure = 2;
 				mic_failure->counter =
 					(uint16_t)((now - mic_failure->last_failure_time) / HZ);
-				if (!mic_failure->counter)	/*  range 1-60 */
+				/*  range 1-60 */
+				if (!mic_failure->counter)
 					mic_failure->counter = 1;
 			}
 			priv->wpa.mic_failure.last_failure_time = now;
@@ -712,7 +715,8 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 	int i;
 	struct ap_info *ap_info;
 
-	netdev_dbg(priv->net_dev, "scan_ind_count = %d\n", priv->scan_ind_count);
+	netdev_dbg(priv->net_dev,
+		   "scan_ind_count = %d\n", priv->scan_ind_count);
 	ap_info = (struct ap_info *)(priv->rxp);
 
 	if (priv->scan_ind_count) {
@@ -849,8 +853,8 @@ void hostif_bss_scan_confirm(struct ks_wlan_private *priv)
 	union iwreq_data wrqu;
 
 	result_code = get_dword(priv);
-	netdev_dbg(priv->net_dev, "result=%d :: scan_ind_count=%d\n", result_code,
-		   priv->scan_ind_count);
+	netdev_dbg(priv->net_dev, "result=%d :: scan_ind_count=%d\n",
+		   result_code, priv->scan_ind_count);
 
 	priv->sme_i.sme_flag &= ~SME_AP_SCAN;
 	hostif_sme_enqueue(priv, SME_BSS_SCAN_CONFIRM);
@@ -903,7 +907,8 @@ void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 static
 void hostif_mic_failure_confirm(struct ks_wlan_private *priv)
 {
-	netdev_dbg(priv->net_dev, "mic_failure=%u\n", priv->wpa.mic_failure.failure);
+	netdev_dbg(priv->net_dev, "mic_failure=%u\n",
+		   priv->wpa.mic_failure.failure);
 	hostif_sme_enqueue(priv, SME_MIC_FAILURE_CONFIRM);
 }
 
@@ -1050,8 +1055,9 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	/* skb check */
 	eth = (struct ethhdr *)skb->data;
 	if (!ether_addr_equal(&priv->eth_addr[0], eth->h_source)) {
-		netdev_err(priv->net_dev, "invalid mac address !!\n");
-		netdev_err(priv->net_dev, "ethernet->h_source=%pM\n", eth->h_source);
+		netdev_err(priv->net_dev,
+			   "Invalid mac address: ethernet->h_source=%pM\n",
+			   eth->h_source);
 		ret = -ENXIO;
 		goto err_kfree;
 	}
@@ -1066,7 +1072,6 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	/* EtherType/Length check */
 	if (*(buffer + 1) + (*buffer << 8) > 1500) {
 		/* ProtocolEAP = *(buffer+1) + (*buffer << 8); */
-		/* netdev_dbg(priv->net_dev, "Send [SNAP]Type %x\n",ProtocolEAP); */
 		/* SAP/CTL/OUI(6 byte) add */
 		*p++ = 0xAA;	/* DSAP */
 		*p++ = 0xAA;	/* SSAP */
@@ -1149,7 +1154,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	    priv->wpa.mic_failure.failure > 0) {
 		if (keyinfo & WPA_KEY_INFO_ERROR &&
 		    keyinfo & WPA_KEY_INFO_REQUEST) {
-			netdev_err(priv->net_dev, " MIC ERROR Report SET : %04X\n", keyinfo);
+			netdev_err(priv->net_dev,
+				   "MIC ERROR Report SET : %04X\n", keyinfo);
 			hostif_sme_enqueue(priv, SME_MIC_FAILURE_REQUEST);
 		}
 		if (priv->wpa.mic_failure.failure == 2)
@@ -1592,7 +1598,7 @@ static void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 		break;
 	case SME_WEP_FLAG_REQUEST:
 		hostif_mib_set_request_bool(priv, DOT11_PRIVACY_INVOKED,
-				            priv->reg.privacy_invoked);
+					    priv->reg.privacy_invoked);
 		break;
 	}
 }
@@ -1995,29 +2001,29 @@ void hostif_sme_set_key(struct ks_wlan_private *priv, int type)
 	case SME_SET_KEY2:
 		hostif_mib_set_request_ostring(priv,
 					       DOT11_WEP_DEFAULT_KEY_VALUE2,
-				               &priv->wpa.key[1].key_val[0],
-				               priv->wpa.key[1].key_len);
+					       &priv->wpa.key[1].key_val[0],
+					       priv->wpa.key[1].key_len);
 		break;
 	case SME_SET_KEY3:
 		hostif_mib_set_request_ostring(priv,
 					       DOT11_WEP_DEFAULT_KEY_VALUE3,
 					       &priv->wpa.key[2].key_val[0],
-				               priv->wpa.key[2].key_len);
+					       priv->wpa.key[2].key_len);
 		break;
 	case SME_SET_KEY4:
 		hostif_mib_set_request_ostring(priv,
 					       DOT11_WEP_DEFAULT_KEY_VALUE4,
 					       &priv->wpa.key[3].key_val[0],
-				               priv->wpa.key[3].key_len);
+					       priv->wpa.key[3].key_len);
 		break;
 	case SME_SET_PMK_TSC:
 		hostif_mib_set_request_ostring(priv, DOT11_PMK_TSC,
-				               &priv->wpa.key[0].rx_seq[0],
-				               WPA_RX_SEQ_LEN);
+					       &priv->wpa.key[0].rx_seq[0],
+					       WPA_RX_SEQ_LEN);
 		break;
 	case SME_SET_GMK1_TSC:
 		hostif_mib_set_request_ostring(priv, DOT11_GMK1_TSC,
-				               &priv->wpa.key[1].rx_seq[0],
+					       &priv->wpa.key[1].rx_seq[0],
 					       WPA_RX_SEQ_LEN);
 		break;
 	case SME_SET_GMK2_TSC:
@@ -2151,7 +2157,7 @@ static void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		break;
 	case SME_WPS_ENABLE_REQUEST:
 		hostif_mib_set_request_int(priv, LOCAL_WPS_ENABLE,
-				           priv->wps.wps_enabled);
+					   priv->wps.wps_enabled);
 		break;
 	case SME_WPS_PROBE_REQUEST:
 		hostif_mib_set_request_ostring(priv, LOCAL_WPS_PROBE_REQ,

commit 9e441a661e0f8159b8a305b888631ecc723b8776
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:33 2018 +0200

    staging: ks7010: factor out send_request_to_device function
    
    In all functions related with requests to the device the same
    patter in used and is also adding a comment to make clear the
    intention of the code. Just factor out the pattern into a new
    send_request_to_device function to improve readability and make
    clear code intention.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 8bd27978544b..1a592180ee1d 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1172,6 +1172,13 @@ static inline void ps_confirm_wait_inc(struct ks_wlan_private *priv)
 		atomic_inc(&priv->psstatus.confirm_wait);
 }
 
+static inline void send_request_to_device(struct ks_wlan_private *priv,
+					  void *data, size_t size)
+{
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx(priv, data, size, NULL, NULL);
+}
+
 static
 void hostif_mib_get_request(struct ks_wlan_private *priv,
 			    unsigned long mib_attribute)
@@ -1184,9 +1191,7 @@ void hostif_mib_get_request(struct ks_wlan_private *priv,
 
 	pp->mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
 
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
+	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }
 
 static void hostif_mib_set_request(struct ks_wlan_private *priv,
@@ -1208,9 +1213,7 @@ static void hostif_mib_set_request(struct ks_wlan_private *priv,
 	pp->mib_value.type = cpu_to_le16(type);
 	memcpy(&pp->mib_value.body, data, size);
 
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + size), NULL, NULL);
+	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp) + size));
 }
 
 static inline void hostif_mib_set_request_int(struct ks_wlan_private *priv,
@@ -1250,9 +1253,7 @@ void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 
 	pp->mode = cpu_to_le16((uint16_t)mode);
 
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
+	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 
 	priv->aplist.size = 0;
 	priv->scan_ind_count = 0;
@@ -1299,9 +1300,7 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 	init_request(priv, &pp->request);
 	pp->channel = cpu_to_le16((uint16_t)(priv->reg.channel));
 
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
+	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }
 
 static
@@ -1340,9 +1339,7 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv, int event)
 		pp->channel_list.size = 14;
 	}
 
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
+	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }
 
 static
@@ -1359,9 +1356,7 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
 
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
+	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }
 
 static
@@ -1381,9 +1376,7 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 	pp->channel_list.size = 1;
 	memcpy(pp->bssid, priv->reg.bssid, ETH_ALEN);
 
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
+	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }
 
 static
@@ -1395,9 +1388,7 @@ void hostif_stop_request(struct ks_wlan_private *priv)
 	if (!pp)
 		return;
 
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
+	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }
 
 static
@@ -1417,9 +1408,7 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 		pp->time = cpu_to_le16((uint16_t)0);
 	}
 
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
+	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }
 
 static
@@ -1437,9 +1426,7 @@ void hostif_power_mgmt_request(struct ks_wlan_private *priv,
 	pp->wake_up = cpu_to_le32((uint32_t)wake_up);
 	pp->receive_dtims = cpu_to_le32((uint32_t)receive_dtims);
 
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
+	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }
 
 static
@@ -1453,10 +1440,7 @@ void hostif_sleep_request(struct ks_wlan_private *priv,
 		if (!pp)
 			return;
 
-		/* send to device request */
-		ps_confirm_wait_inc(priv);
-		ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL,
-			      NULL);
+		send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 	} else if (mode == SLP_ACTIVE) {
 		atomic_set(&priv->sleepstatus.wakeup_request, 1);
 		queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
@@ -1508,9 +1492,7 @@ void hostif_bss_scan_request(struct ks_wlan_private *priv,
 		memcpy(&pp->ssid.body[0], scan_ssid, scan_ssid_len);
 	}
 
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
+	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 
 	priv->aplist.size = 0;
 	priv->scan_ind_count = 0;
@@ -1530,9 +1512,7 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 	pp->failure_count = cpu_to_le16((uint16_t)failure_count);
 	pp->timer = cpu_to_le16((uint16_t)timer);
 
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
+	send_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));
 }
 
 /* Device I/O Receive indicate */

commit f2e8f6a6e308dd898c7fef2365570121c60e245a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:32 2018 +0200

    staging: ks7010: move WLAN_EID_DS_PARAMS to different place inside switch
    
    WLAN_EID_DS_PARAMS case inside switch case is just doing nothing
    and it is located inside other cases. There is a place inside
    the switch with other don't do anything cases are located. Move
    this to that place.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 366801f57676..8bd27978544b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -232,8 +232,6 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info *ap_info,
 				    (RATE_SET_MAX_SIZE - ap->rate_set.size);
 			}
 			break;
-		case WLAN_EID_DS_PARAMS:
-			break;
 		case WLAN_EID_RSN:
 			ap->rsn_ie.id = *bp;
 			ap->rsn_ie.size = read_ie(bp, RSN_IE_BODY_MAX,
@@ -247,7 +245,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info *ap_info,
 							  ap->wpa_ie.body);
 			}
 			break;
-
+		case WLAN_EID_DS_PARAMS:
 		case WLAN_EID_FH_PARAMS:
 		case WLAN_EID_CF_PARAMS:
 		case WLAN_EID_TIM:

commit a5f7d6531ea825d0a95ce10eb75488577d075b1b
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:31 2018 +0200

    staging: ks7010: use ether_addr_copy in get_ap_information function
    
    This commit make use of ether_addr_copy to copy ethernet
    address instead of copy it using memcpy.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 00d631828436..366801f57676 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -200,7 +200,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info *ap_info,
 
 	memset(ap, 0, sizeof(struct local_ap));
 
-	memcpy(ap->bssid, ap_info->bssid, ETH_ALEN);
+	ether_addr_copy(ap->bssid, ap_info->bssid);
 	ap->rssi = ap_info->rssi;
 	ap->sq = ap_info->sq;
 	ap->noise = ap_info->noise;

commit 6663f11bd4d8dba3bc058ab49848885600cce5b6
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:30 2018 +0200

    staging: ks7010: use ether_addr_copy to copy ethernet address sa_data
    
    Use ether_addr_copy kernel function to copy an ethernet address
    instead of a simple memcpy with ETH_ALEN size.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 8cd3dac4fcd3..00d631828436 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -151,8 +151,7 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)
 	wrqu.data.flags = 0;
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
 	if (is_connect_status(priv->connect_status)) {
-		memcpy(wrqu.ap_addr.sa_data,
-		       priv->current_ap.bssid, ETH_ALEN);
+		ether_addr_copy(wrqu.ap_addr.sa_data, priv->current_ap.bssid);
 		netdev_dbg(priv->net_dev,
 			   "IWEVENT: connect bssid=%pM\n", wrqu.ap_addr.sa_data);
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);

commit d96f3a7cecdc399af19da3268f69d2d05b07093d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:29 2018 +0200

    staging: ks7010: change type for rsn_enabled in wpa_status struct
    
    Field rsn_enabled included in wpa_status struct is declared as
    unsigned int but it is only be set using 0 and 1 values and
    in conditional if code is just being used as a boolean. Change
    its type to be a boolean.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 0ab2e1b08329..8cd3dac4fcd3 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2296,7 +2296,7 @@ static inline void hostif_sme_init(struct ks_wlan_private *priv)
 static inline void hostif_wpa_init(struct ks_wlan_private *priv)
 {
 	memset(&priv->wpa, 0, sizeof(priv->wpa));
-	priv->wpa.rsn_enabled = 0;
+	priv->wpa.rsn_enabled = false;
 	priv->wpa.mic_failure.failure = 0;
 	priv->wpa.mic_failure.last_failure_time = 0;
 	priv->wpa.mic_failure.stop = 0;

commit acfb2f32b6b09cfbd7bdfffe09cfe48a37e54c3e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:28 2018 +0200

    staging: ks7010: remove non sense comments in ks_hostif.c source file
    
    Comments which say the same as the code are not useful at all
    so just remove them.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index b81201146662..0ab2e1b08329 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -467,10 +467,10 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 	u16 mib_val_size;
 	u16 mib_val_type;
 
-	mib_status = get_dword(priv);	/* MIB status */
-	mib_attribute = get_dword(priv);	/* MIB atttibute */
-	mib_val_size = get_word(priv);	/* MIB value size */
-	mib_val_type = get_word(priv);	/* MIB value type */
+	mib_status = get_dword(priv);
+	mib_attribute = get_dword(priv);
+	mib_val_size = get_word(priv);
+	mib_val_type = get_word(priv);
 
 	if (mib_status) {
 		netdev_err(priv->net_dev, "attribute=%08X, status=%08X\n",
@@ -527,11 +527,11 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 static
 void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 {
-	u32 mib_status;	/* +04 MIB Status */
-	u32 mib_attribute;	/* +08 MIB attribute */
+	u32 mib_status;
+	u32 mib_attribute;
 
-	mib_status = get_dword(priv);	/* MIB Status */
-	mib_attribute = get_dword(priv);	/* MIB attribute */
+	mib_status = get_dword(priv);
+	mib_attribute = get_dword(priv);
 
 	if (mib_status) {
 		/* in case of error */

commit 2fa68297f00c65e484f371b17de7408895ee5fd4
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:27 2018 +0200

    staging: ks7010: avoid two long lines in hostif_sme_mode_setup
    
    This commit avoid two checkpatch script complains about
    two long lines.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 0054c481cf12..b81201146662 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1886,9 +1886,11 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 		break;
 	case MODE_INFRASTRUCTURE:
 		if (!is_valid_ether_addr((u8 *)priv->reg.bssid)) {
-			hostif_infrastructure_set_request(priv, HIF_INFRA_SET_REQ);
+			hostif_infrastructure_set_request(priv,
+							  HIF_INFRA_SET_REQ);
 		} else {
-			hostif_infrastructure_set_request(priv, HIF_INFRA_SET2_REQ);
+			hostif_infrastructure_set_request(priv,
+							  HIF_INFRA_SET2_REQ);
 			netdev_dbg(priv->net_dev,
 				   "Infra bssid = %pM\n", priv->reg.bssid);
 		}

commit 1c800aabfd68b22795f01358d6b36c4cc5b12571
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:26 2018 +0200

    staging: ks7010: move two preprocessor definitions to ks_wlan.h
    
    In ks_wlan_translate_scan function there are two preprocessor
    definitions:
    
        - RSN_INFO_ELEM_ID
        - GENERIC_INFO_ELEM_ID
    
    These can be moved to common ks_wlan.h because they can be used
    in get_current_ap function instead of use hardcoded values.
    GENERIC_INFO_ELEM_ID has been renamed to WPA_INFO_ELEM_ID which
    is more clear.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index f8bca54ffdb8..0054c481cf12 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -132,12 +132,12 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)
 		ap_info->rsn.size : RSN_IE_BODY_MAX;
 	if ((ap_info->rsn_mode & RSN_MODE_WPA2) &&
 	    (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)) {
-		ap->rsn_ie.id = 0x30;
+		ap->rsn_ie.id = RSN_INFO_ELEM_ID;
 		ap->rsn_ie.size = size;
 		memcpy(ap->rsn_ie.body, ap_info->rsn.body, size);
 	} else if ((ap_info->rsn_mode & RSN_MODE_WPA) &&
 		   (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA)) {
-		ap->wpa_ie.id = 0xdd;
+		ap->wpa_ie.id = WPA_INFO_ELEM_ID;
 		ap->wpa_ie.size = size;
 		memcpy(ap->wpa_ie.body, ap_info->rsn.body, size);
 	} else {

commit 76b91c6f9e57ef318243ecdd4612d7856b8d12a5
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:25 2018 +0200

    staging: ks7010: use ether_addr_copy in get_current_ap
    
    Instead of use memcpy to copy ethernet addresses use
    ether_addr_copy created for that.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index b22dc0ce8e3e..f8bca54ffdb8 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -110,7 +110,7 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)
 		return -EPERM;
 	}
 
-	memcpy(ap->bssid, ap_info->bssid, ETH_ALEN);
+	ether_addr_copy(ap->bssid, ap_info->bssid);
 	memcpy(ap->ssid.body, priv->reg.ssid.body,
 	       priv->reg.ssid.size);
 	ap->ssid.size = priv->reg.ssid.size;

commit 8ce76bff0e6a2cbdaa8e52cd34648c8bbc1b8039
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:24 2018 +0200

    staging: ks7010: add new helpers to achieve mib set request and simplify code
    
    New three functions have been created to centralice and simplify
    calls related with set MIB requests:
    
        - hostif_mib_set_request_int
        - hostif_mib_set_request_bool
        - hostif_mib_set_request_ostring
    
    Using these in different calls simplify functions related with
    this mainly when types are bool and int because no more conversions
    are needed in the caller functions. Those conversion details are
    now located in the new helpers improving a lot readability. Calls
    in hostif_sme_set_wep function has change also some if's to check
    invalid value first avoiding one level indentation.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 9b25221fbdea..b22dc0ce8e3e 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1216,6 +1216,32 @@ static void hostif_mib_set_request(struct ks_wlan_private *priv,
 	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + size), NULL, NULL);
 }
 
+static inline void hostif_mib_set_request_int(struct ks_wlan_private *priv,
+					      enum mib_attribute attr, int val)
+{
+	__le32 v = cpu_to_le32((u32)val);
+	size_t size = sizeof(v);
+
+	hostif_mib_set_request(priv, attr, MIB_VALUE_TYPE_INT, &v, size);
+}
+
+static inline void hostif_mib_set_request_bool(struct ks_wlan_private *priv,
+					       enum mib_attribute attr,
+					       bool val)
+{
+	__le32 v = cpu_to_le32((u32)val);
+	size_t size = sizeof(v);
+
+	hostif_mib_set_request(priv, attr, MIB_VALUE_TYPE_BOOL, &v, size);
+}
+
+static inline void hostif_mib_set_request_ostring(struct ks_wlan_private *priv,
+						  enum mib_attribute attr,
+						  void *data, size_t size)
+{
+	hostif_mib_set_request(priv, attr, MIB_VALUE_TYPE_OSTRING, data, size);
+}
+
 static
 void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 {
@@ -1548,53 +1574,48 @@ void hostif_receive(struct ks_wlan_private *priv, unsigned char *p,
 		hostif_event_check(priv);
 }
 
-static
-void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
+static void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 {
-	__le32 val;
-
 	switch (type) {
 	case SME_WEP_INDEX_REQUEST:
-		val = cpu_to_le32((uint32_t)(priv->reg.wep_index));
-		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_ID,
-				       MIB_VALUE_TYPE_INT, &val, sizeof(val));
+		hostif_mib_set_request_int(priv, DOT11_WEP_DEFAULT_KEY_ID,
+					   priv->reg.wep_index);
 		break;
 	case SME_WEP_KEY1_REQUEST:
-		if (!priv->wpa.wpa_enabled)
-			hostif_mib_set_request(priv,
+		if (priv->wpa.wpa_enabled)
+			return;
+		hostif_mib_set_request_ostring(priv,
 					       DOT11_WEP_DEFAULT_KEY_VALUE1,
-					       MIB_VALUE_TYPE_OSTRING,
 					       &priv->reg.wep_key[0].val[0],
 					       priv->reg.wep_key[0].size);
 		break;
 	case SME_WEP_KEY2_REQUEST:
-		if (!priv->wpa.wpa_enabled)
-			hostif_mib_set_request(priv,
+		if (priv->wpa.wpa_enabled)
+			return;
+		hostif_mib_set_request_ostring(priv,
 					       DOT11_WEP_DEFAULT_KEY_VALUE2,
-					       MIB_VALUE_TYPE_OSTRING,
 					       &priv->reg.wep_key[1].val[0],
 					       priv->reg.wep_key[1].size);
 		break;
 	case SME_WEP_KEY3_REQUEST:
-		if (!priv->wpa.wpa_enabled)
-			hostif_mib_set_request(priv,
+		if (priv->wpa.wpa_enabled)
+			return;
+		hostif_mib_set_request_ostring(priv,
 					       DOT11_WEP_DEFAULT_KEY_VALUE3,
-					       MIB_VALUE_TYPE_OSTRING,
 					       &priv->reg.wep_key[2].val[0],
 					       priv->reg.wep_key[2].size);
 		break;
 	case SME_WEP_KEY4_REQUEST:
-		if (!priv->wpa.wpa_enabled)
-			hostif_mib_set_request(priv,
+		if (priv->wpa.wpa_enabled)
+			return;
+		hostif_mib_set_request_ostring(priv,
 					       DOT11_WEP_DEFAULT_KEY_VALUE4,
-					       MIB_VALUE_TYPE_OSTRING,
 					       &priv->reg.wep_key[3].val[0],
 					       priv->reg.wep_key[3].size);
 		break;
 	case SME_WEP_FLAG_REQUEST:
-		val = cpu_to_le32((uint32_t)(priv->reg.privacy_invoked));
-		hostif_mib_set_request(priv, DOT11_PRIVACY_INVOKED,
-				       MIB_VALUE_TYPE_BOOL, &val, sizeof(val));
+		hostif_mib_set_request_bool(priv, DOT11_PRIVACY_INVOKED,
+				            priv->reg.privacy_invoked);
 		break;
 	}
 }
@@ -1614,7 +1635,6 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 {
 	struct wpa_suite wpa_suite;
 	struct rsn_mode rsn_mode;
-	__le32 val;
 	size_t size;
 
 	memset(&wpa_suite, 0, sizeof(wpa_suite));
@@ -1667,9 +1687,9 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 
 		size = sizeof(wpa_suite.size) +
 		       (CIPHER_ID_LEN * le16_to_cpu(wpa_suite.size));
-		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_UNICAST_CIPHER,
-				       MIB_VALUE_TYPE_OSTRING,
-				       &wpa_suite, size);
+		hostif_mib_set_request_ostring(priv,
+					       DOT11_RSN_CONFIG_UNICAST_CIPHER,
+					       &wpa_suite, size);
 		break;
 	case SME_RSN_MCAST_REQUEST:
 		switch (priv->wpa.group_suite) {
@@ -1714,10 +1734,10 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 				       CIPHER_ID_WPA_WEP104, CIPHER_ID_LEN);
 			break;
 		}
-
-		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_MULTICAST_CIPHER,
-				       MIB_VALUE_TYPE_OSTRING,
-				       &wpa_suite.suite[0][0], CIPHER_ID_LEN);
+		hostif_mib_set_request_ostring(priv,
+					       DOT11_RSN_CONFIG_MULTICAST_CIPHER,
+					       &wpa_suite.suite[0][0],
+					       CIPHER_ID_LEN);
 		break;
 	case SME_RSN_AUTH_REQUEST:
 		wpa_suite.size = cpu_to_le16((uint16_t)1);
@@ -1760,14 +1780,13 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 
 		size = sizeof(wpa_suite.size) +
 		       (KEY_MGMT_ID_LEN * le16_to_cpu(wpa_suite.size));
-		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_AUTH_SUITE,
-				       MIB_VALUE_TYPE_OSTRING, &wpa_suite,
-				       size);
+		hostif_mib_set_request_ostring(priv,
+					       DOT11_RSN_CONFIG_AUTH_SUITE,
+					       &wpa_suite, size);
 		break;
 	case SME_RSN_ENABLED_REQUEST:
-		val = cpu_to_le32((uint32_t)(priv->wpa.rsn_enabled));
-		hostif_mib_set_request(priv, DOT11_RSN_ENABLED,
-				       MIB_VALUE_TYPE_BOOL, &val, sizeof(val));
+		hostif_mib_set_request_bool(priv, DOT11_RSN_ENABLED,
+					    priv->wpa.rsn_enabled);
 		break;
 	case SME_RSN_MODE_REQUEST:
 		if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) {
@@ -1783,9 +1802,8 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 			    cpu_to_le32((uint32_t)RSN_MODE_NONE);
 			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
 		}
-		hostif_mib_set_request(priv, LOCAL_RSN_MODE,
-				       MIB_VALUE_TYPE_OSTRING, &rsn_mode,
-				       sizeof(rsn_mode));
+		hostif_mib_set_request_ostring(priv, LOCAL_RSN_MODE,
+					       &rsn_mode, sizeof(rsn_mode));
 		break;
 	}
 }
@@ -1896,7 +1914,6 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 	int mc_count;
 	struct netdev_hw_addr *ha;
 	char set_address[NIC_MAX_MCAST_LIST * ETH_ALEN];
-	__le32 filter_type;
 	int i = 0;
 
 	spin_lock(&priv->multicast_spin);
@@ -1904,19 +1921,15 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 	memset(set_address, 0, NIC_MAX_MCAST_LIST * ETH_ALEN);
 
 	if (dev->flags & IFF_PROMISC) {
-		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_PROMISC);
-		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
-				       MIB_VALUE_TYPE_BOOL,
-				       &filter_type, sizeof(filter_type));
+		hostif_mib_set_request_bool(priv, LOCAL_MULTICAST_FILTER,
+					    MCAST_FILTER_PROMISC);
 		goto spin_unlock;
 	}
 
 	if ((netdev_mc_count(dev) > NIC_MAX_MCAST_LIST) ||
 	    (dev->flags & IFF_ALLMULTI)) {
-		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCASTALL);
-		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
-				       MIB_VALUE_TYPE_BOOL,
-				       &filter_type, sizeof(filter_type));
+		hostif_mib_set_request_bool(priv, LOCAL_MULTICAST_FILTER,
+					    MCAST_FILTER_MCASTALL);
 		goto spin_unlock;
 	}
 
@@ -1927,15 +1940,13 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 			i++;
 		}
 		priv->sme_i.sme_flag &= ~SME_MULTICAST;
-		hostif_mib_set_request(priv, LOCAL_MULTICAST_ADDRESS,
-				       MIB_VALUE_TYPE_OSTRING,
-				       &set_address[0], ETH_ALEN * mc_count);
+		hostif_mib_set_request_ostring(priv, LOCAL_MULTICAST_ADDRESS,
+					       &set_address[0],
+					       ETH_ALEN * mc_count);
 	} else {
-		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCAST);
 		priv->sme_i.sme_flag |= SME_MULTICAST;
-		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
-				       MIB_VALUE_TYPE_BOOL,
-				       &filter_type, sizeof(filter_type));
+		hostif_mib_set_request_bool(priv, LOCAL_MULTICAST_FILTER,
+					    MCAST_FILTER_MCAST);
 	}
 
 spin_unlock:
@@ -1987,60 +1998,53 @@ static void hostif_sme_sleep_set(struct ks_wlan_private *priv)
 static
 void hostif_sme_set_key(struct ks_wlan_private *priv, int type)
 {
-	__le32 val;
-
 	switch (type) {
 	case SME_SET_FLAG:
-		val = cpu_to_le32((uint32_t)(priv->reg.privacy_invoked));
-		hostif_mib_set_request(priv, DOT11_PRIVACY_INVOKED,
-				       MIB_VALUE_TYPE_BOOL, &val, sizeof(val));
+		hostif_mib_set_request_bool(priv, DOT11_PRIVACY_INVOKED,
+					    priv->reg.privacy_invoked);
 		break;
 	case SME_SET_TXKEY:
-		val = cpu_to_le32((uint32_t)(priv->wpa.txkey));
-		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_ID,
-				       MIB_VALUE_TYPE_INT, &val, sizeof(val));
+		hostif_mib_set_request_int(priv, DOT11_WEP_DEFAULT_KEY_ID,
+					   priv->wpa.txkey);
 		break;
 	case SME_SET_KEY1:
-		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE1,
-				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[0].key_val[0],
-				       priv->wpa.key[0].key_len);
+		hostif_mib_set_request_ostring(priv,
+					       DOT11_WEP_DEFAULT_KEY_VALUE1,
+					       &priv->wpa.key[0].key_val[0],
+					       priv->wpa.key[0].key_len);
 		break;
 	case SME_SET_KEY2:
-		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE2,
-				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[1].key_val[0],
-				       priv->wpa.key[1].key_len);
+		hostif_mib_set_request_ostring(priv,
+					       DOT11_WEP_DEFAULT_KEY_VALUE2,
+				               &priv->wpa.key[1].key_val[0],
+				               priv->wpa.key[1].key_len);
 		break;
 	case SME_SET_KEY3:
-		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE3,
-				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[2].key_val[0],
-				       priv->wpa.key[2].key_len);
+		hostif_mib_set_request_ostring(priv,
+					       DOT11_WEP_DEFAULT_KEY_VALUE3,
+					       &priv->wpa.key[2].key_val[0],
+				               priv->wpa.key[2].key_len);
 		break;
 	case SME_SET_KEY4:
-		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE4,
-				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[3].key_val[0],
-				       priv->wpa.key[3].key_len);
+		hostif_mib_set_request_ostring(priv,
+					       DOT11_WEP_DEFAULT_KEY_VALUE4,
+					       &priv->wpa.key[3].key_val[0],
+				               priv->wpa.key[3].key_len);
 		break;
 	case SME_SET_PMK_TSC:
-		hostif_mib_set_request(priv, DOT11_PMK_TSC,
-				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[0].rx_seq[0],
-				       WPA_RX_SEQ_LEN);
+		hostif_mib_set_request_ostring(priv, DOT11_PMK_TSC,
+				               &priv->wpa.key[0].rx_seq[0],
+				               WPA_RX_SEQ_LEN);
 		break;
 	case SME_SET_GMK1_TSC:
-		hostif_mib_set_request(priv, DOT11_GMK1_TSC,
-				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[1].rx_seq[0],
-				       WPA_RX_SEQ_LEN);
+		hostif_mib_set_request_ostring(priv, DOT11_GMK1_TSC,
+				               &priv->wpa.key[1].rx_seq[0],
+					       WPA_RX_SEQ_LEN);
 		break;
 	case SME_SET_GMK2_TSC:
-		hostif_mib_set_request(priv, DOT11_GMK2_TSC,
-				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[2].rx_seq[0],
-				       WPA_RX_SEQ_LEN);
+		hostif_mib_set_request_ostring(priv, DOT11_GMK2_TSC,
+					       &priv->wpa.key[2].rx_seq[0],
+					       WPA_RX_SEQ_LEN);
 		break;
 	}
 }
@@ -2069,14 +2073,12 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 	pmkcache.size = cpu_to_le16((uint16_t)(priv->pmklist.size));
 	size = sizeof(priv->pmklist.size) +
 	       ((ETH_ALEN + IW_PMKID_LEN) * priv->pmklist.size);
-	hostif_mib_set_request(priv, LOCAL_PMK,
-			       MIB_VALUE_TYPE_OSTRING, &pmkcache, size);
+	hostif_mib_set_request_ostring(priv, LOCAL_PMK, &pmkcache, size);
 }
 
 /* execute sme */
 static void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 {
-	__le32 val;
 	u16 failure;
 
 	switch (event) {
@@ -2088,9 +2090,8 @@ static void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_sme_multicast_set(priv);
 		break;
 	case SME_MACADDRESS_SET_REQUEST:
-		hostif_mib_set_request(priv, LOCAL_CURRENTADDRESS,
-				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->eth_addr[0], ETH_ALEN);
+		hostif_mib_set_request_ostring(priv, LOCAL_CURRENTADDRESS,
+					       &priv->eth_addr[0], ETH_ALEN);
 		break;
 	case SME_BSS_SCAN_REQUEST:
 		hostif_bss_scan_request(priv, priv->reg.scan_type,
@@ -2133,14 +2134,12 @@ static void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_stop_request(priv);
 		break;
 	case SME_RTS_THRESHOLD_REQUEST:
-		val = cpu_to_le32((uint32_t)(priv->reg.rts));
-		hostif_mib_set_request(priv, DOT11_RTS_THRESHOLD,
-				       MIB_VALUE_TYPE_INT, &val, sizeof(val));
+		hostif_mib_set_request_int(priv, DOT11_RTS_THRESHOLD,
+					   priv->reg.rts);
 		break;
 	case SME_FRAGMENTATION_THRESHOLD_REQUEST:
-		val = cpu_to_le32((uint32_t)(priv->reg.fragment));
-		hostif_mib_set_request(priv, DOT11_FRAGMENTATION_THRESHOLD,
-				       MIB_VALUE_TYPE_INT, &val, sizeof(val));
+		hostif_mib_set_request_int(priv, DOT11_FRAGMENTATION_THRESHOLD,
+					   priv->reg.fragment);
 		break;
 	case SME_WEP_INDEX_REQUEST:
 	case SME_WEP_KEY1_REQUEST:
@@ -2172,23 +2171,19 @@ static void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_sme_set_pmksa(priv);
 		break;
 	case SME_WPS_ENABLE_REQUEST:
-		hostif_mib_set_request(priv, LOCAL_WPS_ENABLE,
-				       MIB_VALUE_TYPE_INT,
-				       &priv->wps.wps_enabled,
-				       sizeof(priv->wps.wps_enabled));
+		hostif_mib_set_request_int(priv, LOCAL_WPS_ENABLE,
+				           priv->wps.wps_enabled);
 		break;
 	case SME_WPS_PROBE_REQUEST:
-		hostif_mib_set_request(priv, LOCAL_WPS_PROBE_REQ,
-				       MIB_VALUE_TYPE_OSTRING, priv->wps.ie,
-				       priv->wps.ielen);
+		hostif_mib_set_request_ostring(priv, LOCAL_WPS_PROBE_REQ,
+					       priv->wps.ie, priv->wps.ielen);
 		break;
 	case SME_MODE_SET_REQUEST:
 		hostif_sme_mode_setup(priv);
 		break;
 	case SME_SET_GAIN:
-		hostif_mib_set_request(priv, LOCAL_GAIN,
-				       MIB_VALUE_TYPE_OSTRING, &priv->gain,
-				       sizeof(priv->gain));
+		hostif_mib_set_request_ostring(priv, LOCAL_GAIN,
+					       &priv->gain, sizeof(priv->gain));
 		break;
 	case SME_GET_GAIN:
 		hostif_mib_get_request(priv, LOCAL_GAIN);
@@ -2213,9 +2208,7 @@ static void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_sme_sleep_set(priv);
 		break;
 	case SME_SET_REGION:
-		val = cpu_to_le32((uint32_t)(priv->region));
-		hostif_mib_set_request(priv, LOCAL_REGION,
-				       MIB_VALUE_TYPE_INT, &val, sizeof(val));
+		hostif_mib_set_request_int(priv, LOCAL_REGION, priv->region);
 		break;
 	case SME_MULTICAST_CONFIRM:
 	case SME_BSS_SCAN_CONFIRM:

commit 80020cd7a6bfb5d9642c33efb065fcc3823ffc69
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:23 2018 +0200

    staging: ks7010: change parameter types and reorder them in hostif_mib_set_request
    
    This commit changes parameter types to use enum mib_attribute, enum
    mib_data_type and size_t for size instead of unsigned short. It also
    reorder them in a more sense way. Code is updated in different
    calls to use new parameters order using 'size' auxiliar local variables
    in some of them to improve readability a bit.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 5dceadcc4f0b..9b25221fbdea 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1192,10 +1192,10 @@ void hostif_mib_get_request(struct ks_wlan_private *priv,
 	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 }
 
-static
-void hostif_mib_set_request(struct ks_wlan_private *priv,
-			    unsigned long mib_attribute, unsigned short size,
-			    unsigned short type, void *vp)
+static void hostif_mib_set_request(struct ks_wlan_private *priv,
+				   enum mib_attribute attr,
+				   enum mib_data_type type,
+				   void *data, size_t size)
 {
 	struct hostif_mib_set_request_t *pp;
 
@@ -1206,10 +1206,10 @@ void hostif_mib_set_request(struct ks_wlan_private *priv,
 	if (!pp)
 		return;
 
-	pp->mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
-	pp->mib_value.size = cpu_to_le16((uint16_t)size);
-	pp->mib_value.type = cpu_to_le16((uint16_t)type);
-	memcpy(&pp->mib_value.body, vp, size);
+	pp->mib_attribute = cpu_to_le32(attr);
+	pp->mib_value.size = cpu_to_le16((u16)size);
+	pp->mib_value.type = cpu_to_le16(type);
+	memcpy(&pp->mib_value.body, data, size);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1557,44 +1557,44 @@ void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 	case SME_WEP_INDEX_REQUEST:
 		val = cpu_to_le32((uint32_t)(priv->reg.wep_index));
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_ID,
-				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
+				       MIB_VALUE_TYPE_INT, &val, sizeof(val));
 		break;
 	case SME_WEP_KEY1_REQUEST:
 		if (!priv->wpa.wpa_enabled)
 			hostif_mib_set_request(priv,
 					       DOT11_WEP_DEFAULT_KEY_VALUE1,
-					       priv->reg.wep_key[0].size,
 					       MIB_VALUE_TYPE_OSTRING,
-					       &priv->reg.wep_key[0].val[0]);
+					       &priv->reg.wep_key[0].val[0],
+					       priv->reg.wep_key[0].size);
 		break;
 	case SME_WEP_KEY2_REQUEST:
 		if (!priv->wpa.wpa_enabled)
 			hostif_mib_set_request(priv,
 					       DOT11_WEP_DEFAULT_KEY_VALUE2,
-					       priv->reg.wep_key[1].size,
 					       MIB_VALUE_TYPE_OSTRING,
-					       &priv->reg.wep_key[1].val[0]);
+					       &priv->reg.wep_key[1].val[0],
+					       priv->reg.wep_key[1].size);
 		break;
 	case SME_WEP_KEY3_REQUEST:
 		if (!priv->wpa.wpa_enabled)
 			hostif_mib_set_request(priv,
 					       DOT11_WEP_DEFAULT_KEY_VALUE3,
-					       priv->reg.wep_key[2].size,
 					       MIB_VALUE_TYPE_OSTRING,
-					       &priv->reg.wep_key[2].val[0]);
+					       &priv->reg.wep_key[2].val[0],
+					       priv->reg.wep_key[2].size);
 		break;
 	case SME_WEP_KEY4_REQUEST:
 		if (!priv->wpa.wpa_enabled)
 			hostif_mib_set_request(priv,
 					       DOT11_WEP_DEFAULT_KEY_VALUE4,
-					       priv->reg.wep_key[3].size,
 					       MIB_VALUE_TYPE_OSTRING,
-					       &priv->reg.wep_key[3].val[0]);
+					       &priv->reg.wep_key[3].val[0],
+					       priv->reg.wep_key[3].size);
 		break;
 	case SME_WEP_FLAG_REQUEST:
 		val = cpu_to_le32((uint32_t)(priv->reg.privacy_invoked));
 		hostif_mib_set_request(priv, DOT11_PRIVACY_INVOKED,
-				       sizeof(val), MIB_VALUE_TYPE_BOOL, &val);
+				       MIB_VALUE_TYPE_BOOL, &val, sizeof(val));
 		break;
 	}
 }
@@ -1615,6 +1615,7 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 	struct wpa_suite wpa_suite;
 	struct rsn_mode rsn_mode;
 	__le32 val;
+	size_t size;
 
 	memset(&wpa_suite, 0, sizeof(wpa_suite));
 
@@ -1664,11 +1665,11 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 			break;
 		}
 
+		size = sizeof(wpa_suite.size) +
+		       (CIPHER_ID_LEN * le16_to_cpu(wpa_suite.size));
 		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_UNICAST_CIPHER,
-				       sizeof(wpa_suite.size) +
-				       CIPHER_ID_LEN *
-				       le16_to_cpu(wpa_suite.size),
-				       MIB_VALUE_TYPE_OSTRING, &wpa_suite);
+				       MIB_VALUE_TYPE_OSTRING,
+				       &wpa_suite, size);
 		break;
 	case SME_RSN_MCAST_REQUEST:
 		switch (priv->wpa.group_suite) {
@@ -1715,8 +1716,8 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 		}
 
 		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_MULTICAST_CIPHER,
-				       CIPHER_ID_LEN, MIB_VALUE_TYPE_OSTRING,
-				       &wpa_suite.suite[0][0]);
+				       MIB_VALUE_TYPE_OSTRING,
+				       &wpa_suite.suite[0][0], CIPHER_ID_LEN);
 		break;
 	case SME_RSN_AUTH_REQUEST:
 		wpa_suite.size = cpu_to_le16((uint16_t)1);
@@ -1757,16 +1758,16 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 			break;
 		}
 
+		size = sizeof(wpa_suite.size) +
+		       (KEY_MGMT_ID_LEN * le16_to_cpu(wpa_suite.size));
 		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_AUTH_SUITE,
-				       sizeof(wpa_suite.size) +
-				       KEY_MGMT_ID_LEN *
-				       le16_to_cpu(wpa_suite.size),
-				       MIB_VALUE_TYPE_OSTRING, &wpa_suite);
+				       MIB_VALUE_TYPE_OSTRING, &wpa_suite,
+				       size);
 		break;
 	case SME_RSN_ENABLED_REQUEST:
 		val = cpu_to_le32((uint32_t)(priv->wpa.rsn_enabled));
 		hostif_mib_set_request(priv, DOT11_RSN_ENABLED,
-				       sizeof(val), MIB_VALUE_TYPE_BOOL, &val);
+				       MIB_VALUE_TYPE_BOOL, &val, sizeof(val));
 		break;
 	case SME_RSN_MODE_REQUEST:
 		if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) {
@@ -1782,8 +1783,9 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 			    cpu_to_le32((uint32_t)RSN_MODE_NONE);
 			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
 		}
-		hostif_mib_set_request(priv, LOCAL_RSN_MODE, sizeof(rsn_mode),
-				       MIB_VALUE_TYPE_OSTRING, &rsn_mode);
+		hostif_mib_set_request(priv, LOCAL_RSN_MODE,
+				       MIB_VALUE_TYPE_OSTRING, &rsn_mode,
+				       sizeof(rsn_mode));
 		break;
 	}
 }
@@ -1904,8 +1906,8 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 	if (dev->flags & IFF_PROMISC) {
 		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_PROMISC);
 		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
-				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
-				       &filter_type);
+				       MIB_VALUE_TYPE_BOOL,
+				       &filter_type, sizeof(filter_type));
 		goto spin_unlock;
 	}
 
@@ -1913,8 +1915,8 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 	    (dev->flags & IFF_ALLMULTI)) {
 		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCASTALL);
 		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
-				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
-				       &filter_type);
+				       MIB_VALUE_TYPE_BOOL,
+				       &filter_type, sizeof(filter_type));
 		goto spin_unlock;
 	}
 
@@ -1926,15 +1928,14 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 		}
 		priv->sme_i.sme_flag &= ~SME_MULTICAST;
 		hostif_mib_set_request(priv, LOCAL_MULTICAST_ADDRESS,
-				       ETH_ALEN * mc_count,
 				       MIB_VALUE_TYPE_OSTRING,
-				       &set_address[0]);
+				       &set_address[0], ETH_ALEN * mc_count);
 	} else {
 		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCAST);
 		priv->sme_i.sme_flag |= SME_MULTICAST;
 		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
-				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
-				       &filter_type);
+				       MIB_VALUE_TYPE_BOOL,
+				       &filter_type, sizeof(filter_type));
 	}
 
 spin_unlock:
@@ -1992,51 +1993,54 @@ void hostif_sme_set_key(struct ks_wlan_private *priv, int type)
 	case SME_SET_FLAG:
 		val = cpu_to_le32((uint32_t)(priv->reg.privacy_invoked));
 		hostif_mib_set_request(priv, DOT11_PRIVACY_INVOKED,
-				       sizeof(val), MIB_VALUE_TYPE_BOOL, &val);
+				       MIB_VALUE_TYPE_BOOL, &val, sizeof(val));
 		break;
 	case SME_SET_TXKEY:
 		val = cpu_to_le32((uint32_t)(priv->wpa.txkey));
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_ID,
-				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
+				       MIB_VALUE_TYPE_INT, &val, sizeof(val));
 		break;
 	case SME_SET_KEY1:
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE1,
-				       priv->wpa.key[0].key_len,
 				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[0].key_val[0]);
+				       &priv->wpa.key[0].key_val[0],
+				       priv->wpa.key[0].key_len);
 		break;
 	case SME_SET_KEY2:
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE2,
-				       priv->wpa.key[1].key_len,
 				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[1].key_val[0]);
+				       &priv->wpa.key[1].key_val[0],
+				       priv->wpa.key[1].key_len);
 		break;
 	case SME_SET_KEY3:
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE3,
-				       priv->wpa.key[2].key_len,
 				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[2].key_val[0]);
+				       &priv->wpa.key[2].key_val[0],
+				       priv->wpa.key[2].key_len);
 		break;
 	case SME_SET_KEY4:
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE4,
-				       priv->wpa.key[3].key_len,
 				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[3].key_val[0]);
+				       &priv->wpa.key[3].key_val[0],
+				       priv->wpa.key[3].key_len);
 		break;
 	case SME_SET_PMK_TSC:
 		hostif_mib_set_request(priv, DOT11_PMK_TSC,
-				       WPA_RX_SEQ_LEN, MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[0].rx_seq[0]);
+				       MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[0].rx_seq[0],
+				       WPA_RX_SEQ_LEN);
 		break;
 	case SME_SET_GMK1_TSC:
 		hostif_mib_set_request(priv, DOT11_GMK1_TSC,
-				       WPA_RX_SEQ_LEN, MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[1].rx_seq[0]);
+				       MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[1].rx_seq[0],
+				       WPA_RX_SEQ_LEN);
 		break;
 	case SME_SET_GMK2_TSC:
 		hostif_mib_set_request(priv, DOT11_GMK2_TSC,
-				       WPA_RX_SEQ_LEN, MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[2].rx_seq[0]);
+				       MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[2].rx_seq[0],
+				       WPA_RX_SEQ_LEN);
 		break;
 	}
 }
@@ -2052,6 +2056,7 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 		} __packed list[PMK_LIST_MAX];
 	} __packed pmkcache;
 	struct pmk *pmk;
+	size_t size;
 	int i = 0;
 
 	list_for_each_entry(pmk, &priv->pmklist.head, list) {
@@ -2062,11 +2067,10 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 		i++;
 	}
 	pmkcache.size = cpu_to_le16((uint16_t)(priv->pmklist.size));
+	size = sizeof(priv->pmklist.size) +
+	       ((ETH_ALEN + IW_PMKID_LEN) * priv->pmklist.size);
 	hostif_mib_set_request(priv, LOCAL_PMK,
-			       sizeof(priv->pmklist.size) + (ETH_ALEN +
-							     IW_PMKID_LEN) *
-			       (priv->pmklist.size), MIB_VALUE_TYPE_OSTRING,
-			       &pmkcache);
+			       MIB_VALUE_TYPE_OSTRING, &pmkcache, size);
 }
 
 /* execute sme */
@@ -2084,9 +2088,9 @@ static void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_sme_multicast_set(priv);
 		break;
 	case SME_MACADDRESS_SET_REQUEST:
-		hostif_mib_set_request(priv, LOCAL_CURRENTADDRESS, ETH_ALEN,
+		hostif_mib_set_request(priv, LOCAL_CURRENTADDRESS,
 				       MIB_VALUE_TYPE_OSTRING,
-				       &priv->eth_addr[0]);
+				       &priv->eth_addr[0], ETH_ALEN);
 		break;
 	case SME_BSS_SCAN_REQUEST:
 		hostif_bss_scan_request(priv, priv->reg.scan_type,
@@ -2131,12 +2135,12 @@ static void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 	case SME_RTS_THRESHOLD_REQUEST:
 		val = cpu_to_le32((uint32_t)(priv->reg.rts));
 		hostif_mib_set_request(priv, DOT11_RTS_THRESHOLD,
-				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
+				       MIB_VALUE_TYPE_INT, &val, sizeof(val));
 		break;
 	case SME_FRAGMENTATION_THRESHOLD_REQUEST:
 		val = cpu_to_le32((uint32_t)(priv->reg.fragment));
 		hostif_mib_set_request(priv, DOT11_FRAGMENTATION_THRESHOLD,
-				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
+				       MIB_VALUE_TYPE_INT, &val, sizeof(val));
 		break;
 	case SME_WEP_INDEX_REQUEST:
 	case SME_WEP_KEY1_REQUEST:
@@ -2169,22 +2173,22 @@ static void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		break;
 	case SME_WPS_ENABLE_REQUEST:
 		hostif_mib_set_request(priv, LOCAL_WPS_ENABLE,
-				       sizeof(priv->wps.wps_enabled),
 				       MIB_VALUE_TYPE_INT,
-				       &priv->wps.wps_enabled);
+				       &priv->wps.wps_enabled,
+				       sizeof(priv->wps.wps_enabled));
 		break;
 	case SME_WPS_PROBE_REQUEST:
 		hostif_mib_set_request(priv, LOCAL_WPS_PROBE_REQ,
-				       priv->wps.ielen,
-				       MIB_VALUE_TYPE_OSTRING, priv->wps.ie);
+				       MIB_VALUE_TYPE_OSTRING, priv->wps.ie,
+				       priv->wps.ielen);
 		break;
 	case SME_MODE_SET_REQUEST:
 		hostif_sme_mode_setup(priv);
 		break;
 	case SME_SET_GAIN:
 		hostif_mib_set_request(priv, LOCAL_GAIN,
-				       sizeof(priv->gain),
-				       MIB_VALUE_TYPE_OSTRING, &priv->gain);
+				       MIB_VALUE_TYPE_OSTRING, &priv->gain,
+				       sizeof(priv->gain));
 		break;
 	case SME_GET_GAIN:
 		hostif_mib_get_request(priv, LOCAL_GAIN);
@@ -2211,7 +2215,7 @@ static void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 	case SME_SET_REGION:
 		val = cpu_to_le32((uint32_t)(priv->region));
 		hostif_mib_set_request(priv, LOCAL_REGION,
-				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
+				       MIB_VALUE_TYPE_INT, &val, sizeof(val));
 		break;
 	case SME_MULTICAST_CONFIRM:
 	case SME_BSS_SCAN_CONFIRM:

commit f398c5f4de79b851c1362d3ee8f4fd5e2713fab0
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:19 2018 +0200

    staging: ks7010: clean SME_MIC_FAILURE_REQUEST case in hostif_sme_execute
    
    This commit cleans code for the event SME_MIC_FAILURE_REQUEST
    changing if logic to handle invalid value first and using a
    local variable.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 965a23d8218e..5dceadcc4f0b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2070,10 +2070,10 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 }
 
 /* execute sme */
-static
-void hostif_sme_execute(struct ks_wlan_private *priv, int event)
+static void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 {
 	__le32 val;
+	u16 failure;
 
 	switch (event) {
 	case SME_START:
@@ -2099,18 +2099,15 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_phy_information_request(priv);
 		break;
 	case SME_MIC_FAILURE_REQUEST:
-		if (priv->wpa.mic_failure.failure == 1) {
-			hostif_mic_failure_request(priv,
-						   priv->wpa.mic_failure.failure - 1,
-						   0);
-		} else if (priv->wpa.mic_failure.failure == 2) {
-			hostif_mic_failure_request(priv,
-						   priv->wpa.mic_failure.failure - 1,
-						   priv->wpa.mic_failure.counter);
-		} else {
-			netdev_err(priv->net_dev, "SME_MIC_FAILURE_REQUEST: failure count=%u error?\n",
-				   priv->wpa.mic_failure.failure);
+		failure = priv->wpa.mic_failure.failure;
+		if (failure != 1 && failure != 2) {
+			netdev_err(priv->net_dev,
+				   "SME_MIC_FAILURE_REQUEST: failure count=%u error?\n",
+				   failure);
+			return;
 		}
+		hostif_mic_failure_request(priv, failure - 1, (failure == 1) ?
+					    0 : priv->wpa.mic_failure.counter);
 		break;
 	case SME_MIC_FAILURE_CONFIRM:
 		if (priv->wpa.mic_failure.failure == 2) {

commit 2059ebe9bfac9ed6575ffe643ab0eebe666d1701
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:15 2018 +0200

    staging: ks7010: use the same parameter for 'event' in hostif_sme_enqueue
    
    Declaration of second parameter 'event' in ks_hostif .h and .c
    file is different using uint16_t and unsigned short respectively.
    Just unify both using 'u16' which is preferred instead.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index ea484f2e9179..965a23d8218e 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2259,7 +2259,7 @@ void hostif_sme_task(unsigned long dev)
 }
 
 /* send to Station Management Entity module */
-void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
+void hostif_sme_enqueue(struct ks_wlan_private *priv, u16 event)
 {
 	/* enqueue sme event */
 	if (cnt_smeqbody(priv) < (SME_EVENT_BUFF_SIZE - 1)) {

commit a98ebb8f8b1dbc194a60b81d849a2bb939980fbb
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:09 2018 +0200

    staging: ks7010: remove missing WPS preprocessor conditional code
    
    Commit 92c1552caef3661f049c4e967550e933599e2663 removes WPS hardcoded
    definition and its related conditional preprocessor code. There
    was some missing stuff already in this files. Remove it.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index c0a9a67dc0b4..ea484f2e9179 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -611,10 +611,8 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 	case DOT11_PMK_TSC:
 	case LOCAL_PMK:
 	case LOCAL_GAIN:
-#ifdef WPS
 	case LOCAL_WPS_ENABLE:
 	case LOCAL_WPS_PROBE_REQ:
-#endif /* WPS */
 	case LOCAL_REGION:
 	default:
 		break;
@@ -644,7 +642,6 @@ void hostif_sleep_confirm(struct ks_wlan_private *priv)
 static
 void hostif_start_confirm(struct ks_wlan_private *priv)
 {
-#ifdef WPS
 	union iwreq_data wrqu;
 
 	wrqu.data.length = 0;
@@ -654,7 +651,6 @@ void hostif_start_confirm(struct ks_wlan_private *priv)
 		eth_zero_addr(wrqu.ap_addr.sa_data);
 		wireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);
 	}
-#endif
 	netdev_dbg(priv->net_dev, " scan_ind_count=%d\n", priv->scan_ind_count);
 	hostif_sme_enqueue(priv, SME_START_CONFIRM);
 }
@@ -2174,7 +2170,6 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 	case SME_SET_PMKSA:
 		hostif_sme_set_pmksa(priv);
 		break;
-#ifdef WPS
 	case SME_WPS_ENABLE_REQUEST:
 		hostif_mib_set_request(priv, LOCAL_WPS_ENABLE,
 				       sizeof(priv->wps.wps_enabled),
@@ -2186,7 +2181,6 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 				       priv->wps.ielen,
 				       MIB_VALUE_TYPE_OSTRING, priv->wps.ie);
 		break;
-#endif /* WPS */
 	case SME_MODE_SET_REQUEST:
 		hostif_sme_mode_setup(priv);
 		break;

commit a0a954b151d037e8cbf8822eb56a1a79c4caed30
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:05 2018 +0200

    staging: ks7010: add SPDX identifiers to all files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the all of the staging ks7010 files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    Extra GPL text wording can be removed as it is no longer needed at all.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 9a05374d950e..c0a9a67dc0b4 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *   Driver for KeyStream wireless LAN cards.
  *
  *   Copyright (C) 2005-2008 KeyStream Corp.
  *   Copyright (C) 2009 Renesas Technology Corp.
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License version 2 as
- *   published by the Free Software Foundation.
  */
 
 #include <linux/if_arp.h>

commit c9f906810d9bc3de7733691fcd33de39d2b67801
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:50:07 2018 +0200

    staging: ks7010: refactor hostif_sme_set_pmksa function
    
    This commits refactor a bit hostif_sme_set_pmksa function:
     - avoid one level indentation changing if condition.
     - use ether_addr_copy to copy bssid addresses.
     - move 'i' initialization to declaration place.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 8476ec8e3091..9a05374d950e 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2059,16 +2059,14 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 		} __packed list[PMK_LIST_MAX];
 	} __packed pmkcache;
 	struct pmk *pmk;
-	int i;
+	int i = 0;
 
-	i = 0;
 	list_for_each_entry(pmk, &priv->pmklist.head, list) {
-		if (i < PMK_LIST_MAX) {
-			memcpy(pmkcache.list[i].bssid, pmk->bssid, ETH_ALEN);
-			memcpy(pmkcache.list[i].pmkid, pmk->pmkid,
-			       IW_PMKID_LEN);
-			i++;
-		}
+		if (i >= PMK_LIST_MAX)
+			break;
+		ether_addr_copy(pmkcache.list[i].bssid, pmk->bssid);
+		memcpy(pmkcache.list[i].pmkid, pmk->pmkid, IW_PMKID_LEN);
+		i++;
 	}
 	pmkcache.size = cpu_to_le16((uint16_t)(priv->pmklist.size));
 	hostif_mib_set_request(priv, LOCAL_PMK,

commit be4e1341b799b847267674f7f4701c9b940584ce
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:50:06 2018 +0200

    staging: ks7010: use ether_addr_copy in hostif_sme_multicast_set
    
    Use ether_addr_copy to copy ethernet addresses in function
    hostif_sme_multicast_set instead of memcpy.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index fb01594994f7..8476ec8e3091 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1928,7 +1928,7 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 	if (priv->sme_i.sme_flag & SME_MULTICAST) {
 		mc_count = netdev_mc_count(dev);
 		netdev_for_each_mc_addr(ha, dev) {
-			memcpy(&set_address[i * ETH_ALEN], ha->addr, ETH_ALEN);
+			ether_addr_copy(&set_address[i * ETH_ALEN], ha->addr);
 			i++;
 		}
 		priv->sme_i.sme_flag &= ~SME_MULTICAST;

commit f1e8524c98516641c759b47ac3b91162d0380d62
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:50:05 2018 +0200

    staging: ks7010: use ether_addr_equal in hostif_data_request
    
    Use ether_addr_equal to compare addresses in ether_addr_equal
    function instead of comparing using memcmp.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index b1379276c84b..fb01594994f7 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1059,7 +1059,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 
 	/* skb check */
 	eth = (struct ethhdr *)skb->data;
-	if (memcmp(&priv->eth_addr[0], eth->h_source, ETH_ALEN) != 0) {
+	if (!ether_addr_equal(&priv->eth_addr[0], eth->h_source)) {
 		netdev_err(priv->net_dev, "invalid mac address !!\n");
 		netdev_err(priv->net_dev, "ethernet->h_source=%pM\n", eth->h_source);
 		ret = -ENXIO;

commit e9eb9a9d474682be14fa39da0b54e654fb141623
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:50:04 2018 +0200

    staging: ks7010: use ether_addr_equal in hostif_data_indication
    
    Instead of comparing ethernet address using memcmp in function
    hostif_data_indication use ether_addr_equal function created
    for this function.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index fac7f8e98299..b1379276c84b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -375,7 +375,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 	eth_proto = ntohs(eth_hdr->h_proto);
 
 	/* source address check */
-	if (memcmp(&priv->eth_addr[0], eth_hdr->h_source, ETH_ALEN) == 0) {
+	if (ether_addr_equal(&priv->eth_addr[0], eth_hdr->h_source)) {
 		netdev_err(priv->net_dev, "invalid : source is own mac address !!\n");
 		netdev_err(priv->net_dev,
 			   "eth_hdrernet->h_dest=%02X:%02X:%02X:%02X:%02X:%02X\n",

commit 39c3318c674944cd5637913fbdb971456ed3fd20
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:50:03 2018 +0200

    staging: ks7010: use ether_addr_copy in hostif_mib_get_confirm
    
    This commit improves readability changing custom ethernet
    addresses copies in favour of using ether_addr_copy() function.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index b92211faecf6..fac7f8e98299 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -484,16 +484,9 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 	switch (mib_attribute) {
 	case DOT11_MAC_ADDRESS:
 		hostif_sme_enqueue(priv, SME_GET_MAC_ADDRESS);
-		memcpy(priv->eth_addr, priv->rxp, ETH_ALEN);
+		ether_addr_copy(priv->eth_addr, priv->rxp);
 		priv->mac_address_valid = true;
-		dev->dev_addr[0] = priv->eth_addr[0];
-		dev->dev_addr[1] = priv->eth_addr[1];
-		dev->dev_addr[2] = priv->eth_addr[2];
-		dev->dev_addr[3] = priv->eth_addr[3];
-		dev->dev_addr[4] = priv->eth_addr[4];
-		dev->dev_addr[5] = priv->eth_addr[5];
-		dev->dev_addr[6] = 0x00;
-		dev->dev_addr[7] = 0x00;
+		ether_addr_copy(dev->dev_addr, priv->eth_addr);
 		netdev_info(dev, "MAC ADDRESS = %pM\n", priv->eth_addr);
 		break;
 	case DOT11_PRODUCT_VERSION:

commit cb3f0b4b429020f42a66263c353e2b43d35948b7
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:49:54 2018 +0200

    staging: ks7010: avoid use of brackets in single line if
    
    Singles if does not need at all to use brackets in its body
    so just remove them which is the preferred style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index fe19243e192b..b92211faecf6 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1558,9 +1558,8 @@ void hostif_receive(struct ks_wlan_private *priv, unsigned char *p,
 	priv->rxp = p;
 	priv->rx_size = size;
 
-	if (get_word(priv) == priv->rx_size) {
+	if (get_word(priv) == priv->rx_size)
 		hostif_event_check(priv);
-	}
 }
 
 static

commit 9cfd8837ae501cef01205f6dd955fa9dedb5e2d4
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:49:53 2018 +0200

    staging: ks7010: refactor hostif_sme_power_mgmt_set function
    
    Some minor changes have been done in this function to clean
    it a bit:
        - POWER_MGMT_ACTIVE and default case are the same so
          just handle that with the same block of code,
        - POWER_MGMT_SAVE1 replaces if-else with a ternary operator.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 19c8887200f5..fe19243e192b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1962,22 +1962,12 @@ void hostif_sme_power_mgmt_set(struct ks_wlan_private *priv)
 	unsigned long mode, wake_up, receive_dtims;
 
 	switch (priv->reg.power_mgmt) {
-	case POWER_MGMT_ACTIVE:
-		mode = POWER_ACTIVE;
+	case POWER_MGMT_SAVE1:
+		mode = (priv->reg.operation_mode == MODE_INFRASTRUCTURE) ?
+			POWER_SAVE : POWER_ACTIVE;
 		wake_up = 0;
 		receive_dtims = 0;
 		break;
-	case POWER_MGMT_SAVE1:
-		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
-			mode = POWER_SAVE;
-			wake_up = 0;
-			receive_dtims = 0;
-		} else {
-			mode = POWER_ACTIVE;
-			wake_up = 0;
-			receive_dtims = 0;
-		}
-		break;
 	case POWER_MGMT_SAVE2:
 		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 			mode = POWER_SAVE;
@@ -1989,6 +1979,7 @@ void hostif_sme_power_mgmt_set(struct ks_wlan_private *priv)
 			receive_dtims = 0;
 		}
 		break;
+	case POWER_MGMT_ACTIVE:
 	default:
 		mode = POWER_ACTIVE;
 		wake_up = 0;

commit 04e7f80e3561b6b585d1f1c364b0a64ff0c90e7e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:49:52 2018 +0200

    staging: ks7010: use definitions from kernel headers in hostif_data_indication function
    
    Function hostif_data_indication checks some hardcoded values in a
    switch-case block. This values are defined in uapi/linux/llc.h
    header. Just use them and avoid a comment in the code improving
    readability a bit.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index dd6e0198695a..19c8887200f5 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -11,6 +11,7 @@
 
 #include <linux/if_arp.h>
 #include <net/iw_handler.h>
+#include <uapi/linux/llc.h>
 #include "eap_packet.h"
 #include "ks_wlan.h"
 #include "michael_mic.h"
@@ -399,7 +400,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 
 	/* check 13th byte at rx data */
 	switch (*(priv->rxp + 12)) {
-	case 0xAA:	/* SNAP */
+	case LLC_SAP_SNAP:
 		rx_ind_size = priv->rx_size - 6;
 		skb = dev_alloc_skb(rx_ind_size);
 		if (!skb) {
@@ -419,7 +420,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 
 		aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + ETHER_HDR_SIZE);
 		break;
-	case 0xF0:	/* NETBEUI/NetBIOS */
+	case LLC_SAP_NETBEUI:
 		rx_ind_size = (priv->rx_size + 2);
 		skb = dev_alloc_skb(rx_ind_size);
 		if (!skb) {

commit 16ab5400c46eb8916ec681daad566d124100adda
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:49:51 2018 +0200

    staging: ks7010: join some debug traces in get_current_ap function
    
    There is a lot of netdev_dbg calls related with the access point
    in this function and all of them can be joined in only one call.
    This makes code a bit simplier.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 5e8bc9354e56..dd6e0198695a 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -159,14 +159,18 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)
 			   "IWEVENT: connect bssid=%pM\n", wrqu.ap_addr.sa_data);
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);
 	}
-	netdev_dbg(priv->net_dev, "    Link AP\n");
-	netdev_dbg(priv->net_dev, "    bssid=%02X:%02X:%02X:%02X:%02X:%02X\n"
-		   "    essid=%s\n"
-		   "    rate_set=%02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X\n"
-		   "    channel=%d\n"
-		   "    rssi=%d\n"
-		   "    sq=%d\n"
-		   "    capability=%04X\n",
+	netdev_dbg(priv->net_dev, "Link AP\n"
+		   "- bssid=%02X:%02X:%02X:%02X:%02X:%02X\n"
+		   "- essid=%s\n"
+		   "- rate_set=%02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X\n"
+		   "- channel=%d\n"
+		   "- rssi=%d\n"
+		   "- sq=%d\n"
+		   "- capability=%04X\n"
+		   "- rsn.mode=%d\n"
+		   "- rsn.size=%d\n"
+		   "- ext_rate_set_size=%d\n"
+		   "- rate_set_size=%d\n",
 		   ap->bssid[0], ap->bssid[1], ap->bssid[2],
 		   ap->bssid[3], ap->bssid[4], ap->bssid[5],
 		   &(ap->ssid.body[0]),
@@ -174,10 +178,8 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)
 		   ap->rate_set.body[2], ap->rate_set.body[3],
 		   ap->rate_set.body[4], ap->rate_set.body[5],
 		   ap->rate_set.body[6], ap->rate_set.body[7],
-		   ap->channel, ap->rssi, ap->sq, ap->capability);
-	netdev_dbg(priv->net_dev, "    Link AP\n    rsn.mode=%d\n    rsn.size=%d\n",
-		   ap_info->rsn_mode, ap_info->rsn.size);
-	netdev_dbg(priv->net_dev, "    ext_rate_set_size=%d\n    rate_set_size=%d\n",
+		   ap->channel, ap->rssi, ap->sq, ap->capability,
+		   ap_info->rsn_mode, ap_info->rsn.size,
 		   ap_info->ext_rate_set.size, ap_info->rate_set.size);
 
 	return 0;

commit 0ff7968d6a8d8293968e1be55a458f9d34a6dff4
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:49:50 2018 +0200

    staging: ks7010: avoid some if-else code in get_current_ap function
    
    This commits avoid some if-else code extracting common code before
    its use and making use of a new variable 'size' which is assigned
    using a ternary operator. This improves readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index d46a9553e835..5e8bc9354e56 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -103,6 +103,7 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)
 	struct local_ap *ap;
 	union iwreq_data wrqu;
 	struct net_device *netdev = priv->net_dev;
+	u8 size;
 
 	ap = &priv->current_ap;
 
@@ -129,30 +130,18 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)
 	ap->sq = ap_info->sq;
 	ap->noise = ap_info->noise;
 	ap->capability = le16_to_cpu(ap_info->capability);
+	size = (ap_info->rsn.size <= RSN_IE_BODY_MAX) ?
+		ap_info->rsn.size : RSN_IE_BODY_MAX;
 	if ((ap_info->rsn_mode & RSN_MODE_WPA2) &&
 	    (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)) {
 		ap->rsn_ie.id = 0x30;
-		if (ap_info->rsn.size <= RSN_IE_BODY_MAX) {
-			ap->rsn_ie.size = ap_info->rsn.size;
-			memcpy(ap->rsn_ie.body, ap_info->rsn.body,
-			       ap_info->rsn.size);
-		} else {
-			ap->rsn_ie.size = RSN_IE_BODY_MAX;
-			memcpy(ap->rsn_ie.body, ap_info->rsn.body,
-			       RSN_IE_BODY_MAX);
-		}
+		ap->rsn_ie.size = size;
+		memcpy(ap->rsn_ie.body, ap_info->rsn.body, size);
 	} else if ((ap_info->rsn_mode & RSN_MODE_WPA) &&
 		   (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA)) {
 		ap->wpa_ie.id = 0xdd;
-		if (ap_info->rsn.size <= RSN_IE_BODY_MAX) {
-			ap->wpa_ie.size = ap_info->rsn.size;
-			memcpy(ap->wpa_ie.body, ap_info->rsn.body,
-			       ap_info->rsn.size);
-		} else {
-			ap->wpa_ie.size = RSN_IE_BODY_MAX;
-			memcpy(ap->wpa_ie.body, ap_info->rsn.body,
-			       RSN_IE_BODY_MAX);
-		}
+		ap->wpa_ie.size = size;
+		memcpy(ap->wpa_ie.body, ap_info->rsn.body, size);
 	} else {
 		ap->rsn_ie.id = 0;
 		ap->rsn_ie.size = 0;

commit 3df372e0595d1609ac58761f994b1252a21a86c7
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:55 2018 +0200

    staging: ks7010: review includes of ks_hostif file
    
    This commit reviews includes of ks_hostif.c source file.
    Those which are not being used at all have been removed.
    Driver header includes have been moved after the kernel
    header includes to make style consistent in different
    files of the driver. The need of ks_wlan.h header include
    is only because of some preprocessor conditional code
    of WPS definition. This definition is in ks_wlan.h
    so this one must be included before the ks_hostif.h header
    file.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 2d8f304b85a6..d46a9553e835 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -9,15 +9,12 @@
  *   published by the Free Software Foundation.
  */
 
-#include "ks_wlan.h"
-#include "ks_hostif.h"
-#include "eap_packet.h"
-#include "michael_mic.h"
-
-#include <linux/etherdevice.h>
-#include <linux/if_ether.h>
 #include <linux/if_arp.h>
 #include <net/iw_handler.h>
+#include "eap_packet.h"
+#include "ks_wlan.h"
+#include "michael_mic.h"
+#include "ks_hostif.h"
 
 static inline void inc_smeqhead(struct ks_wlan_private *priv)
 {

commit b684a8c5f37df5c579ab7a22831f03232d0debf5
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:52 2018 +0200

    staging: ks7010: avoid blank line between definitions in hostif_data_request
    
    This commit removes a blank line between definition in
    hostif_data_request function.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index cf79ba3a5d24..2d8f304b85a6 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1024,7 +1024,6 @@ static void *hostif_generic_request(size_t size, int event)
 int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 {
 	unsigned int skb_len = 0;
-
 	unsigned char *buffer = NULL;
 	unsigned int length = 0;
 	struct hostif_data_request *pp;

commit 8a90f1a62456a48e7940f2a2d666fc1286dc1857
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:51 2018 +0200

    staging: ks7010: fix warning aout long line in init_request
    
    This commit fix length of the definition line of init_request
    function. Warning from checkpatch script for this is fixed.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 725e29a8dc94..cf79ba3a5d24 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1278,7 +1278,8 @@ static __le16 ks_wlan_cap(struct ks_wlan_private *priv)
 	return cpu_to_le16((uint16_t)capability);
 }
 
-static void init_request(struct ks_wlan_private *priv, struct hostif_request *req)
+static void init_request(struct ks_wlan_private *priv,
+			 struct hostif_request *req)
 {
 	req->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
 	req->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));

commit 25b5fc27bc53576b61b54ad20638d8ab3237f1bb
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:50 2018 +0200

    staging: ks7010: remove superfluous comments in ks_hostif source file
    
    This commit removes some comments which are not necessary at all
    because code is clear enough to understand its intention.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 156e732999f2..725e29a8dc94 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -17,9 +17,7 @@
 #include <linux/etherdevice.h>
 #include <linux/if_ether.h>
 #include <linux/if_arp.h>
-
-/* Include Wireless Extension definition and check version */
-#include <net/iw_handler.h>	/* New driver API */
+#include <net/iw_handler.h>
 
 static inline void inc_smeqhead(struct ks_wlan_private *priv)
 {
@@ -116,34 +114,24 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)
 		return -EPERM;
 	}
 
-	/* bssid */
 	memcpy(ap->bssid, ap_info->bssid, ETH_ALEN);
-	/* essid */
 	memcpy(ap->ssid.body, priv->reg.ssid.body,
 	       priv->reg.ssid.size);
 	ap->ssid.size = priv->reg.ssid.size;
-	/* rate_set */
 	memcpy(ap->rate_set.body, ap_info->rate_set.body,
 	       ap_info->rate_set.size);
 	ap->rate_set.size = ap_info->rate_set.size;
 	if (ap_info->ext_rate_set.size != 0) {
-		/* rate_set */
 		memcpy(&ap->rate_set.body[ap->rate_set.size],
 		       ap_info->ext_rate_set.body,
 		       ap_info->ext_rate_set.size);
 		ap->rate_set.size += ap_info->ext_rate_set.size;
 	}
-	/* channel */
 	ap->channel = ap_info->ds_parameter.channel;
-	/* rssi */
 	ap->rssi = ap_info->rssi;
-	/* sq */
 	ap->sq = ap_info->sq;
-	/* noise */
 	ap->noise = ap_info->noise;
-	/* capability */
 	ap->capability = le16_to_cpu(ap_info->capability);
-	/* rsn */
 	if ((ap_info->rsn_mode & RSN_MODE_WPA2) &&
 	    (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)) {
 		ap->rsn_ie.id = 0x30;
@@ -227,17 +215,11 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info *ap_info,
 
 	memset(ap, 0, sizeof(struct local_ap));
 
-	/* bssid */
 	memcpy(ap->bssid, ap_info->bssid, ETH_ALEN);
-	/* rssi */
 	ap->rssi = ap_info->rssi;
-	/* sq */
 	ap->sq = ap_info->sq;
-	/* noise */
 	ap->noise = ap_info->noise;
-	/* capability */
 	ap->capability = le16_to_cpu(ap_info->capability);
-	/* channel */
 	ap->channel = ap_info->ch_info;
 
 	bp = ap_info->body;
@@ -505,7 +487,6 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 	mib_val_type = get_word(priv);	/* MIB value type */
 
 	if (mib_status) {
-		/* in case of error */
 		netdev_err(priv->net_dev, "attribute=%08X, status=%08X\n",
 			   mib_attribute, mib_status);
 		return;
@@ -513,7 +494,6 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 
 	switch (mib_attribute) {
 	case DOT11_MAC_ADDRESS:
-		/* MAC address */
 		hostif_sme_enqueue(priv, SME_GET_MAC_ADDRESS);
 		memcpy(priv->eth_addr, priv->rxp, ETH_ALEN);
 		priv->mac_address_valid = true;
@@ -528,7 +508,6 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		netdev_info(dev, "MAC ADDRESS = %pM\n", priv->eth_addr);
 		break;
 	case DOT11_PRODUCT_VERSION:
-		/* firmware version */
 		priv->version_size = priv->rx_size;
 		memcpy(priv->firmware_version, priv->rxp, priv->rx_size);
 		priv->firmware_version[priv->rx_size] = '\0';
@@ -713,13 +692,13 @@ void hostif_connect_indication(struct ks_wlan_private *priv)
 	connect_code = get_word(priv);
 
 	switch (connect_code) {
-	case RESULT_CONNECT:	/* connect */
+	case RESULT_CONNECT:
 		if (!(priv->connect_status & FORCE_DISCONNECT))
 			netif_carrier_on(netdev);
 		tmp = FORCE_DISCONNECT & priv->connect_status;
 		priv->connect_status = tmp + CONNECT_STATUS;
 		break;
-	case RESULT_DISCONNECT: /* disconnect */
+	case RESULT_DISCONNECT:
 		netif_carrier_off(netdev);
 		tmp = FORCE_DISCONNECT & priv->connect_status;
 		priv->connect_status = tmp + DISCONNECT_STATUS;
@@ -961,7 +940,7 @@ void hostif_event_check(struct ks_wlan_private *priv)
 {
 	unsigned short event;
 
-	event = get_word(priv);	/* get event */
+	event = get_word(priv);
 	switch (event) {
 	case HIF_DATA_IND:
 		hostif_data_indication(priv);
@@ -1565,7 +1544,7 @@ static void devio_rec_ind(struct ks_wlan_private *priv, unsigned char *p,
 	if (!priv->is_device_open)
 		return;
 
-	spin_lock(&priv->dev_read_lock);	/* request spin lock */
+	spin_lock(&priv->dev_read_lock);
 	priv->dev_data[atomic_read(&priv->rec_count)] = p;
 	priv->dev_size[atomic_read(&priv->rec_count)] = size;
 
@@ -1579,7 +1558,6 @@ static void devio_rec_ind(struct ks_wlan_private *priv, unsigned char *p,
 
 	wake_up_interruptible_all(&priv->devread_wait);
 
-	/* release spin lock */
 	spin_unlock(&priv->dev_read_lock);
 }
 
@@ -1591,8 +1569,8 @@ void hostif_receive(struct ks_wlan_private *priv, unsigned char *p,
 	priv->rxp = p;
 	priv->rx_size = size;
 
-	if (get_word(priv) == priv->rx_size) {	/* length check !! */
-		hostif_event_check(priv);	/* event check */
+	if (get_word(priv) == priv->rx_size) {
+		hostif_event_check(priv);
 	}
 }
 
@@ -1910,11 +1888,9 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 
 	switch (priv->reg.operation_mode) {
 	case MODE_PSEUDO_ADHOC:
-		/* Pseudo Ad-Hoc mode */
 		hostif_ps_adhoc_set_request(priv);
 		break;
 	case MODE_INFRASTRUCTURE:
-		/* Infrastructure mode */
 		if (!is_valid_ether_addr((u8 *)priv->reg.bssid)) {
 			hostif_infrastructure_set_request(priv, HIF_INFRA_SET_REQ);
 		} else {
@@ -1924,7 +1900,6 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 		}
 		break;
 	case MODE_ADHOC:
-		/* IEEE802.11 Ad-Hoc mode */
 		if (!is_valid_ether_addr((u8 *)priv->reg.bssid)) {
 			hostif_adhoc_set_request(priv);
 		} else {

commit 81dac3c2c939a451a5b1c81e7defadf6e2b090ed
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:49 2018 +0200

    staging: ks7010: avoid one level indentation in devio_rec_ind function
    
    This commit changes logic to handle with the status of the device
    at first checking for close state to return directly instead
    of just do the stuff when device is open. This improves readability
    avoiding one level indentation.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 3b10f9ac0fa0..156e732999f2 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1562,24 +1562,25 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 static void devio_rec_ind(struct ks_wlan_private *priv, unsigned char *p,
 			  unsigned int size)
 {
-	if (priv->is_device_open) {
-		spin_lock(&priv->dev_read_lock);	/* request spin lock */
-		priv->dev_data[atomic_read(&priv->rec_count)] = p;
-		priv->dev_size[atomic_read(&priv->rec_count)] = size;
-
-		if (atomic_read(&priv->event_count) != DEVICE_STOCK_COUNT) {
-			/* rx event count inc */
-			atomic_inc(&priv->event_count);
-		}
-		atomic_inc(&priv->rec_count);
-		if (atomic_read(&priv->rec_count) == DEVICE_STOCK_COUNT)
-			atomic_set(&priv->rec_count, 0);
+	if (!priv->is_device_open)
+		return;
 
-		wake_up_interruptible_all(&priv->devread_wait);
+	spin_lock(&priv->dev_read_lock);	/* request spin lock */
+	priv->dev_data[atomic_read(&priv->rec_count)] = p;
+	priv->dev_size[atomic_read(&priv->rec_count)] = size;
 
-		/* release spin lock */
-		spin_unlock(&priv->dev_read_lock);
+	if (atomic_read(&priv->event_count) != DEVICE_STOCK_COUNT) {
+		/* rx event count inc */
+		atomic_inc(&priv->event_count);
 	}
+	atomic_inc(&priv->rec_count);
+	if (atomic_read(&priv->rec_count) == DEVICE_STOCK_COUNT)
+		atomic_set(&priv->rec_count, 0);
+
+	wake_up_interruptible_all(&priv->devread_wait);
+
+	/* release spin lock */
+	spin_unlock(&priv->dev_read_lock);
 }
 
 void hostif_receive(struct ks_wlan_private *priv, unsigned char *p,

commit d892cc1cfe0c1ce4e4eb58a1877835802953adac
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:48 2018 +0200

    staging: ks7010: change name and type for device_open_status field
    
    This commit changes type for device_open_status field of ks_wlan_private
    structure from int to bool. This variable is only be set to 1
    on ks_wlan_net_start and set to 0 on ks_wlan_net_stop. For this
    purpose it is not necessary at all to use an integer because a bool
    is enough. This also renames field name from device_open_status to
    is_device_open.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index d11b0a2259e2..3b10f9ac0fa0 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1562,7 +1562,7 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 static void devio_rec_ind(struct ks_wlan_private *priv, unsigned char *p,
 			  unsigned int size)
 {
-	if (priv->device_open_status) {
+	if (priv->is_device_open) {
 		spin_lock(&priv->dev_read_lock);	/* request spin lock */
 		priv->dev_data[atomic_read(&priv->rec_count)] = p;
 		priv->dev_size[atomic_read(&priv->rec_count)] = size;

commit 5e5cd8089ae91183679213d8273a7682edbc2e06
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:34 2018 +0200

    staging: ks7010: avoid casts in michael_mic_function calls
    
    This commit removes casts in calls to michael_mic_function.
    Most of them are nosense because types match perfectly function
    parameters. To avoid also int casting for len parameter just
    pass unsigned len to function which makes sense because is only
    being called with unsigned int len parameters.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index e5657dc3fd51..d11b0a2259e2 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -337,12 +337,9 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 		memcpy(&recv_mic[0], (priv->rxp) + ((priv->rx_size) - 8), 8);
 		priv->rx_size = priv->rx_size - 8;
 		if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
-			michael_mic_function(&michael_mic,
-					     (uint8_t *)key->rx_mic_key,
-					     (uint8_t *)priv->rxp,
-					     (int)priv->rx_size,
-					     (uint8_t)0,	/* priority */
-					     (uint8_t *)michael_mic.result);
+			michael_mic_function(&michael_mic, key->rx_mic_key,
+					     priv->rxp, priv->rx_size,
+					     0,	michael_mic.result);
 		}
 		if (memcmp(michael_mic.result, recv_mic, 8) != 0) {
 			now = jiffies;
@@ -1164,11 +1161,9 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 		} else {
 			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
 				michael_mic_function(&michael_mic,
-						     (uint8_t *)priv->wpa.key[0].tx_mic_key,
-						     (uint8_t *)&pp->data[0],
-						     (int)skb_len,
-						     (uint8_t)0,	/* priority */
-						     (uint8_t *)michael_mic.result);
+						     priv->wpa.key[0].tx_mic_key,
+						     &pp->data[0], skb_len,
+						     0,	michael_mic.result);
 				memcpy(p, michael_mic.result, 8);
 				length += 8;
 				skb_len += 8;

commit 6704ddbb850e41f8f8dfb23dc090a20aaaaaba88
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 16 12:29:32 2018 +0200

    staging: ks7010: group some cases in switch-case block in hostif_mib_set_confirm
    
    This commit groups some case statements because its behaviour is
    just do nothing which is the same as the default. Clean 'break'
    keyword in those which are affected.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 04688e1841e9..e5657dc3fd51 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -645,8 +645,6 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 	case DOT11_RSN_CONFIG_AUTH_SUITE:
 		hostif_sme_enqueue(priv, SME_RSN_AUTH_CONFIRM);
 		break;
-	case DOT11_PMK_TSC:
-		break;
 	case DOT11_GMK1_TSC:
 		if (atomic_read(&priv->psstatus.snooze_guard))
 			atomic_set(&priv->psstatus.snooze_guard, 0);
@@ -655,15 +653,12 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 		if (atomic_read(&priv->psstatus.snooze_guard))
 			atomic_set(&priv->psstatus.snooze_guard, 0);
 		break;
+	case DOT11_PMK_TSC:
 	case LOCAL_PMK:
-		break;
 	case LOCAL_GAIN:
-		break;
 #ifdef WPS
 	case LOCAL_WPS_ENABLE:
-		break;
 	case LOCAL_WPS_PROBE_REQ:
-		break;
 #endif /* WPS */
 	case LOCAL_REGION:
 	default:

commit d6a72502e3f37f4ae8118c724cf269a17dc73529
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 16 12:29:29 2018 +0200

    staging: ks7010: refactor code for hostif_sme_sleep_set function
    
    This commit refactors code for hostif_sme_sleep_set function. This
    function was using a switch-case block to handle only two states
    where the action to do for them is the same. Just refactor a bit
    to check for return condition at first and doing the common action
    after in other case.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 22033628db05..04688e1841e9 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2043,19 +2043,13 @@ void hostif_sme_power_mgmt_set(struct ks_wlan_private *priv)
 	hostif_power_mgmt_request(priv, mode, wake_up, receive_dtims);
 }
 
-static
-void hostif_sme_sleep_set(struct ks_wlan_private *priv)
+static void hostif_sme_sleep_set(struct ks_wlan_private *priv)
 {
-	switch (priv->sleep_mode) {
-	case SLP_SLEEP:
-		hostif_sleep_request(priv, priv->sleep_mode);
-		break;
-	case SLP_ACTIVE:
-		hostif_sleep_request(priv, priv->sleep_mode);
-		break;
-	default:
-		break;
-	}
+	if (priv->sleep_mode != SLP_SLEEP &&
+	    priv->sleep_mode != SLP_ACTIVE)
+		return;
+
+	hostif_sleep_request(priv, priv->sleep_mode);
 }
 
 static

commit d3bef56b75ca494bcf249c760152bdb03e488da5
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 16 12:29:28 2018 +0200

    staging: ks7010: remove nonsense break from case block
    
    This commit removes 'break' from case block because the
    code is just using the 'default' break for some cases and
    this one can be included also there.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index b646b46f5bd4..22033628db05 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2314,7 +2314,6 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 	case SME_RSN_ENABLED_CONFIRM:
 	case SME_RSN_MODE_CONFIRM:
 	case SME_MODE_SET_CONFIRM:
-		break;
 	case SME_TERMINATE:
 	default:
 		break;

commit abca20adc5ebd968ea330763c8f7004de62b25e2
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 16 12:29:27 2018 +0200

    staging: ks7010: change return value of ks_wlan_do_power_save function
    
    This commit change return value of ks_wlan_do_power_save function
    from int to void. This function is just returning zero and return
    value is not being checked also, so it is nonsense to return an
    integer.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index f720d281310b..b646b46f5bd4 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -94,14 +94,12 @@ static void ks_wlan_hw_wakeup_task(struct work_struct *work)
 		tasklet_enable(&priv->sme_task);
 }
 
-static
-int ks_wlan_do_power_save(struct ks_wlan_private *priv)
+static void ks_wlan_do_power_save(struct ks_wlan_private *priv)
 {
 	if (is_connect_status(priv->connect_status))
 		hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
 	else
 		priv->dev_state = DEVICE_STATE_READY;
-	return 0;
 }
 
 static

commit d0d3777ca21a529cba5b82acc90961f3da2d86fc
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Apr 6 14:37:44 2018 +0200

    staging: ks7010: remove KS_WLAN_MEM_FLAG definition
    
    This commit removes KS_WLAN_MEM_FLAG definition which is
    hiding GFP_ATOMIC along the code. It is better to use directly
    GFP_ATOMIC in kmalloc's because this it is easier to read.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index ff624f8c8951..f720d281310b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -38,8 +38,6 @@ static inline unsigned int cnt_smeqbody(struct ks_wlan_private *priv)
 	return (sme_cnt + SME_EVENT_BUFF_SIZE) % SME_EVENT_BUFF_SIZE;
 }
 
-#define KS_WLAN_MEM_FLAG (GFP_ATOMIC)
-
 static inline u8 get_byte(struct ks_wlan_private *priv)
 {
 	u8 data;
@@ -1044,7 +1042,7 @@ static void *hostif_generic_request(size_t size, int event)
 {
 	struct hostif_hdr *p;
 
-	p = kzalloc(hif_align_size(size), KS_WLAN_MEM_FLAG);
+	p = kzalloc(hif_align_size(size), GFP_ATOMIC);
 	if (!p)
 		return NULL;
 
@@ -1098,7 +1096,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	}
 
 	size = sizeof(*pp) + 6 + skb_len + 8;
-	pp = kmalloc(hif_align_size(size), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(size), GFP_ATOMIC);
 	if (!pp) {
 		ret = -ENOMEM;
 		goto err_kfree_skb;

commit e5082ba1d0a31a85e6cf9e59d65be202de9f3638
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:47 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct michael_mic_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct michael_mic_t' with 'struct michael_mic'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 42f1cd823672..ff624f8c8951 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -315,7 +315,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 	char buf[128];
 	unsigned long now;
 	struct mic_failure *mic_failure;
-	struct michael_mic_t michael_mic;
+	struct michael_mic michael_mic;
 	union iwreq_data wrqu;
 	unsigned int key_index = auth_type - 1;
 	struct wpa_key *key = &priv->wpa.key[key_index];
@@ -1065,7 +1065,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	int result = 0;
 	unsigned short eth_proto;
 	struct ether_hdr *eth_hdr;
-	struct michael_mic_t michael_mic;
+	struct michael_mic michael_mic;
 	unsigned short keyinfo = 0;
 	struct ieee802_1x_hdr *aa1x_hdr;
 	struct wpa_eapol_key *eap_key;

commit b74024743e2530d0fe10b2e4cc6754c8c5af2be5
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:45 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct pmk_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct pmk_t' with 'struct pmk'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 85b9e2678fd3..42f1cd823672 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2130,7 +2130,7 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 			u8 pmkid[IW_PMKID_LEN];
 		} __packed list[PMK_LIST_MAX];
 	} __packed pmkcache;
-	struct pmk_t *pmk;
+	struct pmk *pmk;
 	int i;
 
 	i = 0;

commit 9b0b63a4d126426b8f60bfffdf8d0a9fbccb2b46
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:42 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct mic_failure_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct mic_failure_t' with 'struct mic_failure'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index d5be57e974ac..85b9e2678fd3 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -314,7 +314,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 	unsigned char recv_mic[8];
 	char buf[128];
 	unsigned long now;
-	struct mic_failure_t *mic_failure;
+	struct mic_failure *mic_failure;
 	struct michael_mic_t michael_mic;
 	union iwreq_data wrqu;
 	unsigned int key_index = auth_type - 1;

commit 8b76eb091b5b8aec094b0fde9cf58856a8e699cb
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:41 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct wpa_key_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct wpa_key_t' with 'struct wpa_key'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 442f5e2b44e5..d5be57e974ac 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -318,7 +318,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 	struct michael_mic_t michael_mic;
 	union iwreq_data wrqu;
 	unsigned int key_index = auth_type - 1;
-	struct wpa_key_t *key = &priv->wpa.key[key_index];
+	struct wpa_key *key = &priv->wpa.key[key_index];
 
 	eth_hdr = (struct ether_hdr *)(priv->rxp);
 	eth_proto = ntohs(eth_hdr->h_proto);

commit 01d391d45701790be830e6af0a18fece388cc1f4
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:34 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct local_ap_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct local_ap_t' with 'struct local_ap'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 92865d1363c4..442f5e2b44e5 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -109,14 +109,14 @@ int ks_wlan_do_power_save(struct ks_wlan_private *priv)
 static
 int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)
 {
-	struct local_ap_t *ap;
+	struct local_ap *ap;
 	union iwreq_data wrqu;
 	struct net_device *netdev = priv->net_dev;
 
 	ap = &priv->current_ap;
 
 	if (is_disconnect_status(priv->connect_status)) {
-		memset(ap, 0, sizeof(struct local_ap_t));
+		memset(ap, 0, sizeof(struct local_ap));
 		return -EPERM;
 	}
 
@@ -224,12 +224,12 @@ static u8 read_ie(unsigned char *bp, u8 max, u8 *body)
 
 static
 int get_ap_information(struct ks_wlan_private *priv, struct ap_info *ap_info,
-		       struct local_ap_t *ap)
+		       struct local_ap *ap)
 {
 	unsigned char *bp;
 	int bsize, offset;
 
-	memset(ap, 0, sizeof(struct local_ap_t));
+	memset(ap, 0, sizeof(struct local_ap));
 
 	/* bssid */
 	memcpy(ap->bssid, ap_info->bssid, ETH_ALEN);
@@ -2359,7 +2359,7 @@ void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
 
 static inline void hostif_aplist_init(struct ks_wlan_private *priv)
 {
-	size_t size = LOCAL_APLIST_MAX * sizeof(struct local_ap_t);
+	size_t size = LOCAL_APLIST_MAX * sizeof(struct local_ap);
 	priv->aplist.size = 0;
 	memset(&priv->aplist.ap[0], 0, size);
 }

commit d56c80caf12ad3ca9a32a73f0c3f03d6a0d322aa
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:29 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_mic_failure_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_mic_failure_request_t' with 'struct
    hostif_mic_failure_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 19063ae09974..92865d1363c4 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1558,7 +1558,7 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 				unsigned short failure_count,
 				unsigned short timer)
 {
-	struct hostif_mic_failure_request_t *pp;
+	struct hostif_mic_failure_request *pp;
 
 	pp = hostif_generic_request(sizeof(*pp), HIF_MIC_FAILURE_REQ);
 	if (!pp)

commit cee85e47b4df43e1b598feea298d1044a7ffac4a
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:27 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_sleep_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_sleep_request_t' with 'struct
    hostif_sleep_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 085e7cd7260b..19063ae09974 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1483,7 +1483,7 @@ static
 void hostif_sleep_request(struct ks_wlan_private *priv,
 			  enum sleep_mode_type mode)
 {
-	struct hostif_sleep_request_t *pp;
+	struct hostif_sleep_request *pp;
 
 	if (mode == SLP_SLEEP) {
 		pp = hostif_generic_request(sizeof(*pp), HIF_SLEEP_REQ);

commit 3d01c771a68bd08546f10a943f193e1785a9e05a
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:25 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_phy_information_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_phy_information_request_t' with 'struct
    hostif_phy_information_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 7b014032fc64..085e7cd7260b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1440,7 +1440,7 @@ void hostif_stop_request(struct ks_wlan_private *priv)
 static
 void hostif_phy_information_request(struct ks_wlan_private *priv)
 {
-	struct hostif_phy_information_request_t *pp;
+	struct hostif_phy_information_request *pp;
 
 	pp = hostif_generic_request(sizeof(*pp), HIF_PHY_INFO_REQ);
 	if (!pp)

commit 81ac43bf396070cc1c999c6080ccef3a481bf530
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:23 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_bss_scan_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_bss_scan_request_t' with 'struct
    hostif_bss_scan_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 8d4705c8b846..7b014032fc64 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1508,7 +1508,7 @@ void hostif_bss_scan_request(struct ks_wlan_private *priv,
 			     unsigned long scan_type, uint8_t *scan_ssid,
 			     uint8_t scan_ssid_len)
 {
-	struct hostif_bss_scan_request_t *pp;
+	struct hostif_bss_scan_request *pp;
 
 	pp = hostif_generic_request(sizeof(*pp), HIF_SCAN_REQ);
 	if (!pp)

commit f43036cc5e3d4c0c6b8c7cd7e74ef5b6593cd3fc
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:21 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct association_response_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct association_response_t' with 'struct
    association_response'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 9d6dcfd9858f..8d4705c8b846 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -864,7 +864,7 @@ static
 void hostif_associate_indication(struct ks_wlan_private *priv)
 {
 	struct association_request *assoc_req;
-	struct association_response_t *assoc_resp;
+	struct association_response *assoc_resp;
 	unsigned char *pb;
 	union iwreq_data wrqu;
 	char buf[IW_CUSTOM_MAX];
@@ -875,7 +875,7 @@ void hostif_associate_indication(struct ks_wlan_private *priv)
 	static const char associnfo_leader1[] = " RespIEs=";
 
 	assoc_req = (struct association_request *)(priv->rxp);
-	assoc_resp = (struct association_response_t *)(assoc_req + 1);
+	assoc_resp = (struct association_response *)(assoc_req + 1);
 	pb = (unsigned char *)(assoc_resp + 1);
 
 	memset(&wrqu, 0, sizeof(wrqu));

commit e80ce487a3128c060590494def3dd9e5e578e708
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:20 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct association_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct association_request_t' with 'struct
    association_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 2956f8d8b9f3..9d6dcfd9858f 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -863,7 +863,7 @@ void hostif_adhoc_set_confirm(struct ks_wlan_private *priv)
 static
 void hostif_associate_indication(struct ks_wlan_private *priv)
 {
-	struct association_request_t *assoc_req;
+	struct association_request *assoc_req;
 	struct association_response_t *assoc_resp;
 	unsigned char *pb;
 	union iwreq_data wrqu;
@@ -874,7 +874,7 @@ void hostif_associate_indication(struct ks_wlan_private *priv)
 	static const char associnfo_leader0[] = "ASSOCINFO(ReqIEs=";
 	static const char associnfo_leader1[] = " RespIEs=";
 
-	assoc_req = (struct association_request_t *)(priv->rxp);
+	assoc_req = (struct association_request *)(priv->rxp);
 	assoc_resp = (struct association_response_t *)(assoc_req + 1);
 	pb = (unsigned char *)(assoc_resp + 1);
 

commit 9445eb38da66dd47a9f6dbcae801535935f93ded
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:17 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_adhoc_set2_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_adhoc_set2_request_t' with 'struct
    hostif_adhoc_set2_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 93859aa8cc64..2956f8d8b9f3 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1404,7 +1404,7 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 static
 void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 {
-	struct hostif_adhoc_set2_request_t *pp;
+	struct hostif_adhoc_set2_request *pp;
 
 	pp = hostif_generic_request(sizeof(*pp), HIF_ADH_SET_REQ);
 	if (!pp)

commit 5dfcd3fb0a327cc3885d4acdbbd7cfbb068b97c4
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:16 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_adhoc_set_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_adhoc_set_request_t' with 'struct
    hostif_adhoc_set_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 82b64fde1824..93859aa8cc64 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1385,7 +1385,7 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv, int event)
 static
 void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 {
-	struct hostif_adhoc_set_request_t *pp;
+	struct hostif_adhoc_set_request *pp;
 
 	pp = hostif_generic_request(sizeof(*pp), HIF_ADH_SET_REQ);
 	if (!pp)

commit 3071e00c7376b5c797a7912abbd77f53035060e4
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:14 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_infrastructure_set_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_infrastructure_set_request_t' with
    'struct hostif_infrastructure_set_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 22227933d9d6..82b64fde1824 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1344,7 +1344,7 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 static
 void hostif_infrastructure_set_request(struct ks_wlan_private *priv, int event)
 {
-	struct hostif_infrastructure_set_request_t *pp;
+	struct hostif_infrastructure_set_request *pp;
 
 	pp = hostif_generic_request(sizeof(*pp), event);
 	if (!pp)

commit 54839a56e098596a6f5ad7d790385ee853af8d54
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:12 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_ps_adhoc_set_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_ps_adhoc_set_request_t' with 'struct
    hostif_ps_adhoc_set_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index d276dd16fc8d..22227933d9d6 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1327,7 +1327,7 @@ static void init_request(struct ks_wlan_private *priv, struct hostif_request *re
 static
 void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 {
-	struct hostif_ps_adhoc_set_request_t *pp;
+	struct hostif_ps_adhoc_set_request *pp;
 
 	pp = hostif_generic_request(sizeof(*pp), HIF_PS_ADH_SET_REQ);
 	if (!pp)

commit 0af037ab32d44196c64c5a016eb140425db58e62
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:11 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_request_t' with 'struct hostif_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index b24fafd4bdd0..d276dd16fc8d 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1313,7 +1313,7 @@ static __le16 ks_wlan_cap(struct ks_wlan_private *priv)
 	return cpu_to_le16((uint16_t)capability);
 }
 
-static void init_request(struct ks_wlan_private *priv, struct hostif_request_t *req)
+static void init_request(struct ks_wlan_private *priv, struct hostif_request *req)
 {
 	req->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
 	req->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));

commit 9f2ae0a40c23d6d35cab2e74474ade3ef886881d
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:09 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_stop_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_stop_request_t' with 'struct
    hostif_stop_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 5effc51430ab..b24fafd4bdd0 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1426,7 +1426,7 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 static
 void hostif_stop_request(struct ks_wlan_private *priv)
 {
-	struct hostif_stop_request_t *pp;
+	struct hostif_stop_request *pp;
 
 	pp = hostif_generic_request(sizeof(*pp), HIF_STOP_REQ);
 	if (!pp)

commit 8f86d60cda4a61aa61203b31216b47e4cd8ed5ad
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:07 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct link_ap_info_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct link_ap_info_t' with 'struct link_ap_info'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index aa87c6e97ba5..5effc51430ab 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -107,7 +107,7 @@ int ks_wlan_do_power_save(struct ks_wlan_private *priv)
 }
 
 static
-int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
+int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)
 {
 	struct local_ap_t *ap;
 	union iwreq_data wrqu;
@@ -745,7 +745,7 @@ void hostif_connect_indication(struct ks_wlan_private *priv)
 		break;
 	}
 
-	get_current_ap(priv, (struct link_ap_info_t *)priv->rxp);
+	get_current_ap(priv, (struct link_ap_info *)priv->rxp);
 	if (is_connect_status(priv->connect_status) &&
 	    is_disconnect_status(old_status)) {
 		/* for power save */

commit 15265353a605f65faa2a9ef7b22164eba212c534
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:06 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct ap_info_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct ap_info_t' with 'struct ap_info'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 30dafee4f413..aa87c6e97ba5 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -223,7 +223,7 @@ static u8 read_ie(unsigned char *bp, u8 max, u8 *body)
 
 
 static
-int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
+int get_ap_information(struct ks_wlan_private *priv, struct ap_info *ap_info,
 		       struct local_ap_t *ap)
 {
 	unsigned char *bp;
@@ -771,10 +771,10 @@ static
 void hostif_scan_indication(struct ks_wlan_private *priv)
 {
 	int i;
-	struct ap_info_t *ap_info;
+	struct ap_info *ap_info;
 
 	netdev_dbg(priv->net_dev, "scan_ind_count = %d\n", priv->scan_ind_count);
-	ap_info = (struct ap_info_t *)(priv->rxp);
+	ap_info = (struct ap_info *)(priv->rxp);
 
 	if (priv->scan_ind_count) {
 		/* bssid check */
@@ -794,7 +794,7 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 	if (priv->scan_ind_count < LOCAL_APLIST_MAX + 1) {
 		netdev_dbg(priv->net_dev, " scan_ind_count=%d :: aplist.size=%d\n",
 			priv->scan_ind_count, priv->aplist.size);
-		get_ap_information(priv, (struct ap_info_t *)(priv->rxp),
+		get_ap_information(priv, (struct ap_info *)(priv->rxp),
 				   &(priv->aplist.ap[priv->scan_ind_count - 1]));
 		priv->aplist.size = priv->scan_ind_count;
 	} else {

commit 75bff08f23112b42b7eb91ca8d93c9aa444e76ae
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:07:55 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_start_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_start_request_t' with 'struct
    hostif_start_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index f22356f79c04..30dafee4f413 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1280,7 +1280,7 @@ void hostif_mib_set_request(struct ks_wlan_private *priv,
 static
 void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 {
-	struct hostif_start_request_t *pp;
+	struct hostif_start_request *pp;
 
 	pp = hostif_generic_request(sizeof(*pp), HIF_START_REQ);
 	if (!pp)

commit 985d6eb905ba3f120da404ef6a1b7d5a9b074b66
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:07:53 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_power_mgmt_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_power_mgmt_request_t' with 'struct
    hostif_power_mgmt_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index b0209d553c5c..f22356f79c04 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1464,7 +1464,7 @@ void hostif_power_mgmt_request(struct ks_wlan_private *priv,
 			       unsigned long mode, unsigned long wake_up,
 			       unsigned long receive_dtims)
 {
-	struct hostif_power_mgmt_request_t *pp;
+	struct hostif_power_mgmt_request *pp;
 
 	pp = hostif_generic_request(sizeof(*pp), HIF_POWER_MGMT_REQ);
 	if (!pp)

commit 81daad4b9490b811e74cb98293db301e354d4449
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:07:48 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_mib_get_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_mib_get_request_t' with 'struct
    hostif_mib_get_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index c486f6e57939..b0209d553c5c 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1240,7 +1240,7 @@ static
 void hostif_mib_get_request(struct ks_wlan_private *priv,
 			    unsigned long mib_attribute)
 {
-	struct hostif_mib_get_request_t *pp;
+	struct hostif_mib_get_request *pp;
 
 	pp = hostif_generic_request(sizeof(*pp), HIF_MIB_GET_REQ);
 	if (!pp)

commit 5b8946b13d40f7980897da35908c2afdfcdb3f97
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:07:45 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_data_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_data_request_t' with 'struct
    hostif_data_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 30cd9f20ab6a..c486f6e57939 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1060,7 +1060,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 
 	unsigned char *buffer = NULL;
 	unsigned int length = 0;
-	struct hostif_data_request_t *pp;
+	struct hostif_data_request *pp;
 	unsigned char *p;
 	int result = 0;
 	unsigned short eth_proto;

commit d8f20c2f5db69d1a2c3879a2da461b82888c5475
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:07:44 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct pmk_cache_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct pmk_cache_t' with 'struct pmk_cache'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 4dde1d380887..30cd9f20ab6a 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2123,7 +2123,7 @@ void hostif_sme_set_key(struct ks_wlan_private *priv, int type)
 static
 void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 {
-	struct pmk_cache_t {
+	struct pmk_cache {
 		__le16 size;
 		struct {
 			u8 bssid[ETH_ALEN];

commit f4fb42e4e695ea2c0b7998d2ee8d1da6f78e0bdb
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:07:43 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct rsn_mode_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct rsn_mode_t' with 'struct rsn_mode'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 081f68911456..4dde1d380887 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1665,7 +1665,7 @@ struct wpa_suite {
 	unsigned char suite[4][CIPHER_ID_LEN];
 } __packed;
 
-struct rsn_mode_t {
+struct rsn_mode {
 	__le32 rsn_mode;
 	__le16 rsn_capability;
 } __packed;
@@ -1674,7 +1674,7 @@ static
 void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 {
 	struct wpa_suite wpa_suite;
-	struct rsn_mode_t rsn_mode;
+	struct rsn_mode rsn_mode;
 	__le32 val;
 
 	memset(&wpa_suite, 0, sizeof(wpa_suite));

commit c5ad1e944a070d806d39231520eef68f19cb5a5f
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:07:42 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct wpa_suite_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct wpa_suite_t' with 'struct wpa_suite'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index e336d25b5671..081f68911456 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1660,7 +1660,7 @@ void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 	}
 }
 
-struct wpa_suite_t {
+struct wpa_suite {
 	__le16 size;
 	unsigned char suite[4][CIPHER_ID_LEN];
 } __packed;
@@ -1673,7 +1673,7 @@ struct rsn_mode_t {
 static
 void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 {
-	struct wpa_suite_t wpa_suite;
+	struct wpa_suite wpa_suite;
 	struct rsn_mode_t rsn_mode;
 	__le32 val;
 

commit ea5522370ea8e9838dcad800cb9bc7e03392decf
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Mar 29 20:07:54 2018 +0200

    staging: ks7010: IS_OFDM_EXT_RATE macro with inline function
    
    This commit replaces IS_OFDM_EXT_RATE macro with is_11b_rate
    inline function to improve readability.
    
    It also fix a checkpatch script warning because a line with more
    than 80 spaces.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index cca2d57fd224..e336d25b5671 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1900,7 +1900,7 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 			if (!is_11bg_rate(priv->reg.rate_set.body[i]))
 				break;
 
-			if (IS_OFDM_EXT_RATE(priv->reg.rate_set.body[i])) {
+			if (is_ofdm_ext_rate(priv->reg.rate_set.body[i])) {
 				rate_octet[i] = priv->reg.rate_set.body[i] &
 						RATE_MASK;
 			} else {

commit 8710f5b17436ac9cd8208fc4b004052b13e7da05
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Mar 29 20:07:53 2018 +0200

    staging: ks7010: replace IS_11BG_RATE macro with inline function
    
    This commit replaces IS_11BG_RATE macro with is_11b_rate inline
    function to improve readability.
    
    It also fix a checkpatch script warning because a line with more
    than 80 spaces.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 9f6d49e04d87..cca2d57fd224 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1897,7 +1897,7 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 
 	} else {	/* D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE */
 		for (i = 0; i < priv->reg.rate_set.size; i++) {
-			if (!IS_11BG_RATE(priv->reg.rate_set.body[i]))
+			if (!is_11bg_rate(priv->reg.rate_set.body[i]))
 				break;
 
 			if (IS_OFDM_EXT_RATE(priv->reg.rate_set.body[i])) {

commit b67cd79f38c6afe2f355c01c569a5c7c58cc1c06
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Mar 29 20:07:51 2018 +0200

    staging: ks7010: replace IS_11B_RATE macro with inline function
    
    This commit replaces IS_11B_RATE macro with is_11b_rate inline
    function to improve readability.
    
    It also fix a checkpatch script warning because a line with more
    than 80 spaces.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 676961cf4103..9f6d49e04d87 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1884,7 +1884,7 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 	/* rate mask by phy setting */
 	if (priv->reg.phy_type == D_11B_ONLY_MODE) {
 		for (i = 0; i < priv->reg.rate_set.size; i++) {
-			if (!IS_11B_RATE(priv->reg.rate_set.body[i]))
+			if (!is_11b_rate(priv->reg.rate_set.body[i]))
 				break;
 
 			if ((priv->reg.rate_set.body[i] & RATE_MASK) >= TX_RATE_5M) {

commit f40cd66b45b3fc2822e3abb254929c6e2820ab91
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Wed Mar 28 22:51:48 2018 -0700

    staging: ks7010: Change mac_address_valid to a bool instead of int.
    
    'mac_address_valid' is only ever assigned 0 or 1, so it makes more sense
    to use a bool type for this variable.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 923f196213b6..676961cf4103 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -523,7 +523,7 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		/* MAC address */
 		hostif_sme_enqueue(priv, SME_GET_MAC_ADDRESS);
 		memcpy(priv->eth_addr, priv->rxp, ETH_ALEN);
-		priv->mac_address_valid = 1;
+		priv->mac_address_valid = true;
 		dev->dev_addr[0] = priv->eth_addr[0];
 		dev->dev_addr[1] = priv->eth_addr[1];
 		dev->dev_addr[2] = priv->eth_addr[2];
@@ -638,7 +638,7 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 		hostif_sme_enqueue(priv, SME_MULTICAST_CONFIRM);
 		break;
 	case LOCAL_CURRENTADDRESS:
-		priv->mac_address_valid = 1;
+		priv->mac_address_valid = true;
 		break;
 	case DOT11_RSN_CONFIG_MULTICAST_CIPHER:
 		hostif_sme_enqueue(priv, SME_RSN_MCAST_CONFIRM);

commit c9be56329a398cf24a5f665850b3ba7fc4064b2d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Mar 28 17:24:17 2018 +0200

    staging: ks7010: avoid camel cases in MichaelMICFunction
    
    This commit replace camel cases for name and params used in
    MichaelMICFunction. This improves a bit readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index a02b73e4e81f..923f196213b6 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -341,12 +341,12 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 		memcpy(&recv_mic[0], (priv->rxp) + ((priv->rx_size) - 8), 8);
 		priv->rx_size = priv->rx_size - 8;
 		if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
-			MichaelMICFunction(&michael_mic,
-					   (uint8_t *)key->rx_mic_key,
-					   (uint8_t *)priv->rxp,
-					   (int)priv->rx_size,
-					   (uint8_t)0,	/* priority */
-					   (uint8_t *)michael_mic.result);
+			michael_mic_function(&michael_mic,
+					     (uint8_t *)key->rx_mic_key,
+					     (uint8_t *)priv->rxp,
+					     (int)priv->rx_size,
+					     (uint8_t)0,	/* priority */
+					     (uint8_t *)michael_mic.result);
 		}
 		if (memcmp(michael_mic.result, recv_mic, 8) != 0) {
 			now = jiffies;
@@ -1172,12 +1172,12 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);
 		} else {
 			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
-				MichaelMICFunction(&michael_mic,
-						   (uint8_t *)priv->wpa.key[0].tx_mic_key,
-						   (uint8_t *)&pp->data[0],
-						   (int)skb_len,
-						   (uint8_t)0,	/* priority */
-						   (uint8_t *)michael_mic.result);
+				michael_mic_function(&michael_mic,
+						     (uint8_t *)priv->wpa.key[0].tx_mic_key,
+						     (uint8_t *)&pp->data[0],
+						     (int)skb_len,
+						     (uint8_t)0,	/* priority */
+						     (uint8_t *)michael_mic.result);
 				memcpy(p, michael_mic.result, 8);
 				length += 8;
 				skb_len += 8;

commit 527947677bbd96ebb6190ea92d5a2f0529599a3a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Mar 26 18:52:52 2018 +0200

    staging: ks7010: factor out some functions from hostif_init
    
    This commit factors out some init functions from hostif_init
    to improve readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index e0ddf3f0327e..a02b73e4e81f 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2357,50 +2357,79 @@ void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
 	tasklet_schedule(&priv->sme_task);
 }
 
-int hostif_init(struct ks_wlan_private *priv)
+static inline void hostif_aplist_init(struct ks_wlan_private *priv)
 {
-	int i;
-
+	size_t size = LOCAL_APLIST_MAX * sizeof(struct local_ap_t);
 	priv->aplist.size = 0;
-	for (i = 0; i < LOCAL_APLIST_MAX; i++)
-		memset(&priv->aplist.ap[i], 0, sizeof(struct local_ap_t));
+	memset(&priv->aplist.ap[0], 0, size);
+}
+
+static inline void hostif_status_init(struct ks_wlan_private *priv)
+{
 	priv->infra_status = 0;
 	priv->current_rate = 4;
 	priv->connect_status = DISCONNECT_STATUS;
+}
 
-	spin_lock_init(&priv->multicast_spin);
+static inline void hostif_sme_init(struct ks_wlan_private *priv)
+{
+	priv->sme_i.sme_status = SME_IDLE;
+	priv->sme_i.qhead = 0;
+	priv->sme_i.qtail = 0;
+	spin_lock_init(&priv->sme_i.sme_spin);
+	priv->sme_i.sme_flag = 0;
+	tasklet_init(&priv->sme_task, hostif_sme_task, (unsigned long)priv);
+}
 
-	spin_lock_init(&priv->dev_read_lock);
-	init_waitqueue_head(&priv->devread_wait);
-	priv->dev_count = 0;
-	atomic_set(&priv->event_count, 0);
-	atomic_set(&priv->rec_count, 0);
+static inline void hostif_wpa_init(struct ks_wlan_private *priv)
+{
+	memset(&priv->wpa, 0, sizeof(priv->wpa));
+	priv->wpa.rsn_enabled = 0;
+	priv->wpa.mic_failure.failure = 0;
+	priv->wpa.mic_failure.last_failure_time = 0;
+	priv->wpa.mic_failure.stop = 0;
+}
 
-	/* for power save */
+static inline void hostif_power_save_init(struct ks_wlan_private *priv)
+{
 	atomic_set(&priv->psstatus.status, PS_NONE);
 	atomic_set(&priv->psstatus.confirm_wait, 0);
 	atomic_set(&priv->psstatus.snooze_guard, 0);
 	init_completion(&priv->psstatus.wakeup_wait);
 	INIT_WORK(&priv->wakeup_work, ks_wlan_hw_wakeup_task);
+}
+
+static inline void hostif_pmklist_init(struct ks_wlan_private *priv)
+{
+	int i;
 
-	/* WPA */
-	memset(&priv->wpa, 0, sizeof(priv->wpa));
-	priv->wpa.rsn_enabled = 0;
-	priv->wpa.mic_failure.failure = 0;
-	priv->wpa.mic_failure.last_failure_time = 0;
-	priv->wpa.mic_failure.stop = 0;
 	memset(&priv->pmklist, 0, sizeof(priv->pmklist));
 	INIT_LIST_HEAD(&priv->pmklist.head);
 	for (i = 0; i < PMK_LIST_MAX; i++)
 		INIT_LIST_HEAD(&priv->pmklist.pmk[i].list);
+}
 
-	priv->sme_i.sme_status = SME_IDLE;
-	priv->sme_i.qhead = 0;
-	priv->sme_i.qtail = 0;
-	spin_lock_init(&priv->sme_i.sme_spin);
-	priv->sme_i.sme_flag = 0;
+static inline void hostif_counters_init(struct ks_wlan_private *priv)
+{
+	priv->dev_count = 0;
+	atomic_set(&priv->event_count, 0);
+	atomic_set(&priv->rec_count, 0);
+}
 
-	tasklet_init(&priv->sme_task, hostif_sme_task, (unsigned long)priv);
+int hostif_init(struct ks_wlan_private *priv)
+{
+	hostif_aplist_init(priv);
+	hostif_status_init(priv);
+
+	spin_lock_init(&priv->multicast_spin);
+	spin_lock_init(&priv->dev_read_lock);
+	init_waitqueue_head(&priv->devread_wait);
+
+	hostif_counters_init(priv);
+	hostif_power_save_init(priv);
+	hostif_wpa_init(priv);
+	hostif_pmklist_init(priv);
+	hostif_sme_init(priv);
 
 	return 0;
 }

commit 07934dc8a2786b574c60724ae06699430f2ae7c9
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Mar 26 18:52:51 2018 +0200

    staging: ks7010: avoid camel case in function name get_DWORD
    
    This commit renames function get_DWORD into get_dword to avoid
    camel case.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index a43d41601035..e0ddf3f0327e 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -59,8 +59,7 @@ static inline u16 get_word(struct ks_wlan_private *priv)
 	return data;
 }
 
-static
-inline u32 get_DWORD(struct ks_wlan_private *priv)
+static inline u32 get_dword(struct ks_wlan_private *priv)
 {
 	u32 data;
 
@@ -507,8 +506,8 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 	u16 mib_val_size;
 	u16 mib_val_type;
 
-	mib_status = get_DWORD(priv);	/* MIB status */
-	mib_attribute = get_DWORD(priv);	/* MIB atttibute */
+	mib_status = get_dword(priv);	/* MIB status */
+	mib_attribute = get_dword(priv);	/* MIB atttibute */
 	mib_val_size = get_word(priv);	/* MIB value size */
 	mib_val_type = get_word(priv);	/* MIB value type */
 
@@ -580,8 +579,8 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 	u32 mib_status;	/* +04 MIB Status */
 	u32 mib_attribute;	/* +08 MIB attribute */
 
-	mib_status = get_DWORD(priv);	/* MIB Status */
-	mib_attribute = get_DWORD(priv);	/* MIB attribute */
+	mib_status = get_dword(priv);	/* MIB Status */
+	mib_attribute = get_dword(priv);	/* MIB attribute */
 
 	if (mib_status) {
 		/* in case of error */
@@ -910,7 +909,7 @@ void hostif_bss_scan_confirm(struct ks_wlan_private *priv)
 	struct net_device *dev = priv->net_dev;
 	union iwreq_data wrqu;
 
-	result_code = get_DWORD(priv);
+	result_code = get_dword(priv);
 	netdev_dbg(priv->net_dev, "result=%d :: scan_ind_count=%d\n", result_code,
 		   priv->scan_ind_count);
 
@@ -936,10 +935,10 @@ void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 	signal = get_byte(priv);
 	noise = get_byte(priv);
 	link_speed = get_byte(priv);
-	transmitted_frame_count = get_DWORD(priv);
-	received_fragment_count = get_DWORD(priv);
-	failed_count = get_DWORD(priv);
-	fcs_error_count = get_DWORD(priv);
+	transmitted_frame_count = get_dword(priv);
+	received_fragment_count = get_dword(priv);
+	failed_count = get_dword(priv);
+	fcs_error_count = get_dword(priv);
 
 	netdev_dbg(priv->net_dev, "phyinfo confirm rssi=%d signal=%d\n",
 		   rssi, signal);

commit ef3f0d5f8224325aa007c52a1449bf8b19e8448e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Mar 26 18:52:50 2018 +0200

    staging: ks7010: avoid camel case in function name get_WORD
    
    This commit renames get_WORD function into get_word to avoid
    camel case.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 86b6e02bef6f..a43d41601035 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -50,8 +50,7 @@ static inline u8 get_byte(struct ks_wlan_private *priv)
 	return data;
 }
 
-static
-inline u16 get_WORD(struct ks_wlan_private *priv)
+static inline u16 get_word(struct ks_wlan_private *priv)
 {
 	u16 data;
 
@@ -406,8 +405,8 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 		return;
 	}
 
-	auth_type = get_WORD(priv);	/* AuthType */
-	get_WORD(priv);	/* Reserve Area */
+	auth_type = get_word(priv);	/* AuthType */
+	get_word(priv);	/* Reserve Area */
 
 	eth_hdr = (struct ether_hdr *)(priv->rxp);
 	eth_proto = ntohs(eth_hdr->h_proto);
@@ -510,8 +509,8 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 
 	mib_status = get_DWORD(priv);	/* MIB status */
 	mib_attribute = get_DWORD(priv);	/* MIB atttibute */
-	mib_val_size = get_WORD(priv);	/* MIB value size */
-	mib_val_type = get_WORD(priv);	/* MIB value type */
+	mib_val_size = get_word(priv);	/* MIB value size */
+	mib_val_type = get_word(priv);	/* MIB value type */
 
 	if (mib_status) {
 		/* in case of error */
@@ -724,7 +723,7 @@ void hostif_connect_indication(struct ks_wlan_private *priv)
 	struct net_device *netdev = priv->net_dev;
 	union iwreq_data wrqu0;
 
-	connect_code = get_WORD(priv);
+	connect_code = get_word(priv);
 
 	switch (connect_code) {
 	case RESULT_CONNECT:	/* connect */
@@ -850,7 +849,7 @@ void hostif_infrastructure_set_confirm(struct ks_wlan_private *priv)
 {
 	u16 result_code;
 
-	result_code = get_WORD(priv);
+	result_code = get_word(priv);
 	priv->infra_status = 1;	/* infrastructure mode set */
 	hostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);
 }
@@ -975,7 +974,7 @@ void hostif_event_check(struct ks_wlan_private *priv)
 {
 	unsigned short event;
 
-	event = get_WORD(priv);	/* get event */
+	event = get_word(priv);	/* get event */
 	switch (event) {
 	case HIF_DATA_IND:
 		hostif_data_indication(priv);
@@ -1606,7 +1605,7 @@ void hostif_receive(struct ks_wlan_private *priv, unsigned char *p,
 	priv->rxp = p;
 	priv->rx_size = size;
 
-	if (get_WORD(priv) == priv->rx_size) {	/* length check !! */
+	if (get_word(priv) == priv->rx_size) {	/* length check !! */
 		hostif_event_check(priv);	/* event check */
 	}
 }

commit 232a8bac79c3bb1444e51a55aedcf53c4ecb617e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Mar 26 18:52:49 2018 +0200

    staging: ks7010: avoid camel case in function name get_BYTE
    
    This commit renames get_BYTE function in favour of get_byte
    to avoid camel case.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index f90af84aecbc..86b6e02bef6f 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -40,8 +40,7 @@ static inline unsigned int cnt_smeqbody(struct ks_wlan_private *priv)
 
 #define KS_WLAN_MEM_FLAG (GFP_ATOMIC)
 
-static
-inline u8 get_BYTE(struct ks_wlan_private *priv)
+static inline u8 get_byte(struct ks_wlan_private *priv)
 {
 	u8 data;
 
@@ -56,8 +55,8 @@ inline u16 get_WORD(struct ks_wlan_private *priv)
 {
 	u16 data;
 
-	data = (get_BYTE(priv) & 0xff);
-	data |= ((get_BYTE(priv) << 8) & 0xff00);
+	data = (get_byte(priv) & 0xff);
+	data |= ((get_byte(priv) << 8) & 0xff00);
 	return data;
 }
 
@@ -66,10 +65,10 @@ inline u32 get_DWORD(struct ks_wlan_private *priv)
 {
 	u32 data;
 
-	data = (get_BYTE(priv) & 0xff);
-	data |= ((get_BYTE(priv) << 8) & 0x0000ff00);
-	data |= ((get_BYTE(priv) << 16) & 0x00ff0000);
-	data |= ((get_BYTE(priv) << 24) & 0xff000000);
+	data = (get_byte(priv) & 0xff);
+	data |= ((get_byte(priv) << 8) & 0x0000ff00);
+	data |= ((get_byte(priv) << 16) & 0x00ff0000);
+	data |= ((get_byte(priv) << 24) & 0xff000000);
 	return data;
 }
 
@@ -934,10 +933,10 @@ void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 	unsigned int transmitted_frame_count, received_fragment_count;
 	unsigned int failed_count, fcs_error_count;
 
-	rssi = get_BYTE(priv);
-	signal = get_BYTE(priv);
-	noise = get_BYTE(priv);
-	link_speed = get_BYTE(priv);
+	rssi = get_byte(priv);
+	signal = get_byte(priv);
+	noise = get_byte(priv);
+	link_speed = get_byte(priv);
 	transmitted_frame_count = get_DWORD(priv);
 	received_fragment_count = get_DWORD(priv);
 	failed_count = get_DWORD(priv);

commit 16b102e7815251687b0890d7bf1e9650de0b1cd9
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Mar 23 14:05:09 2018 +0100

    staging: ks7010: use lower case names in michael_mic_t struct fields
    
    Replace upper case fields and camel cases for fields included in
    michael_mic_t structure
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 143413c3cae2..f90af84aecbc 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -349,9 +349,9 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 					   (uint8_t *)priv->rxp,
 					   (int)priv->rx_size,
 					   (uint8_t)0,	/* priority */
-					   (uint8_t *)michael_mic.Result);
+					   (uint8_t *)michael_mic.result);
 		}
-		if (memcmp(michael_mic.Result, recv_mic, 8) != 0) {
+		if (memcmp(michael_mic.result, recv_mic, 8) != 0) {
 			now = jiffies;
 			mic_failure = &priv->wpa.mic_failure;
 			/* MIC FAILURE */
@@ -1180,8 +1180,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 						   (uint8_t *)&pp->data[0],
 						   (int)skb_len,
 						   (uint8_t)0,	/* priority */
-						   (uint8_t *)michael_mic.Result);
-				memcpy(p, michael_mic.Result, 8);
+						   (uint8_t *)michael_mic.result);
+				memcpy(p, michael_mic.result, 8);
 				length += 8;
 				skb_len += 8;
 				p += 8;

commit b90a6e10f114ee136314763ec5bc302044d5ee90
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Thu Mar 22 22:07:45 2018 -0700

    staging: ks7010: Remove hostif_infrastructure_set2_request_t.
    
    The handling of hostif_infrastructure_set_request_t and
    hostif_infrastructure_set2_request_t is identical, with the exception
    of the event type value.  Merge the two structs so they can be handled
    by a single function ('hostif_infrastructure_set_request').
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 21219d0bbb6a..143413c3cae2 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1345,11 +1345,11 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 }
 
 static
-void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
+void hostif_infrastructure_set_request(struct ks_wlan_private *priv, int event)
 {
 	struct hostif_infrastructure_set_request_t *pp;
 
-	pp = hostif_generic_request(sizeof(*pp), HIF_INFRA_SET_REQ);
+	pp = hostif_generic_request(sizeof(*pp), event);
 	if (!pp)
 		return;
 
@@ -1385,48 +1385,6 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 }
 
-static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
-{
-	struct hostif_infrastructure_set2_request_t *pp;
-
-	pp = hostif_generic_request(sizeof(*pp), HIF_INFRA_SET2_REQ);
-	if (!pp)
-		return;
-
-	init_request(priv, &pp->request);
-	pp->ssid.size = priv->reg.ssid.size;
-	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
-	pp->beacon_lost_count =
-	    cpu_to_le16((uint16_t)(priv->reg.beacon_lost_count));
-	pp->auth_type = cpu_to_le16((uint16_t)(priv->reg.authenticate_type));
-
-	pp->channel_list.body[0] = 1;
-	pp->channel_list.body[1] = 8;
-	pp->channel_list.body[2] = 2;
-	pp->channel_list.body[3] = 9;
-	pp->channel_list.body[4] = 3;
-	pp->channel_list.body[5] = 10;
-	pp->channel_list.body[6] = 4;
-	pp->channel_list.body[7] = 11;
-	pp->channel_list.body[8] = 5;
-	pp->channel_list.body[9] = 12;
-	pp->channel_list.body[10] = 6;
-	pp->channel_list.body[11] = 13;
-	pp->channel_list.body[12] = 7;
-	if (priv->reg.phy_type == D_11G_ONLY_MODE) {
-		pp->channel_list.size = 13;
-	} else {
-		pp->channel_list.body[13] = 14;
-		pp->channel_list.size = 14;
-	}
-
-	memcpy(pp->bssid, priv->reg.bssid, ETH_ALEN);
-
-	/* send to device request */
-	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
-}
-
 static
 void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 {
@@ -1974,9 +1932,9 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 	case MODE_INFRASTRUCTURE:
 		/* Infrastructure mode */
 		if (!is_valid_ether_addr((u8 *)priv->reg.bssid)) {
-			hostif_infrastructure_set_request(priv);
+			hostif_infrastructure_set_request(priv, HIF_INFRA_SET_REQ);
 		} else {
-			hostif_infrastructure_set2_request(priv);
+			hostif_infrastructure_set_request(priv, HIF_INFRA_SET2_REQ);
 			netdev_dbg(priv->net_dev,
 				   "Infra bssid = %pM\n", priv->reg.bssid);
 		}

commit 72d73d63a7c914cb1f93e89101aa3374708c66ad
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Thu Mar 22 22:07:44 2018 -0700

    staging: ks7010: Factor out repeated code for reading IEs.
    
    Some of the code for reading IEs is replicated multiple times in the
    switch statement for get_ap_information().  Factor that code out into
    read_ie().
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 1a0fe15e842e..21219d0bbb6a 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -216,6 +216,15 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	return 0;
 }
 
+static u8 read_ie(unsigned char *bp, u8 max, u8 *body)
+{
+	u8 size = (*(bp + 1) <= max) ? *(bp + 1) : max;
+
+	memcpy(body, bp + 2, size);
+	return size;
+}
+
+
 static
 int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 		       struct local_ap_t *ap)
@@ -245,11 +254,8 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 	while (bsize > offset) {
 		switch (*bp) { /* Information Element ID */
 		case WLAN_EID_SSID:
-			if (*(bp + 1) <= IEEE80211_MAX_SSID_LEN)
-				ap->ssid.size = *(bp + 1);
-			else
-				ap->ssid.size = IEEE80211_MAX_SSID_LEN;
-			memcpy(ap->ssid.body, bp + 2, ap->ssid.size);
+			ap->ssid.size = read_ie(bp, IEEE80211_MAX_SSID_LEN,
+						ap->ssid.body);
 			break;
 		case WLAN_EID_SUPP_RATES:
 		case WLAN_EID_EXT_SUPP_RATES:
@@ -270,22 +276,15 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 			break;
 		case WLAN_EID_RSN:
 			ap->rsn_ie.id = *bp;
-			if (*(bp + 1) <= RSN_IE_BODY_MAX)
-				ap->rsn_ie.size = *(bp + 1);
-			else
-				ap->rsn_ie.size = RSN_IE_BODY_MAX;
-			memcpy(ap->rsn_ie.body, bp + 2, ap->rsn_ie.size);
+			ap->rsn_ie.size = read_ie(bp, RSN_IE_BODY_MAX,
+						  ap->rsn_ie.body);
 			break;
 		case WLAN_EID_VENDOR_SPECIFIC: /* WPA */
 			/* WPA OUI check */
 			if (memcmp(bp + 2, CIPHER_ID_WPA_WEP40, 4) == 0) {
 				ap->wpa_ie.id = *bp;
-				if (*(bp + 1) <= RSN_IE_BODY_MAX)
-					ap->wpa_ie.size = *(bp + 1);
-				else
-					ap->wpa_ie.size = RSN_IE_BODY_MAX;
-				memcpy(ap->wpa_ie.body, bp + 2,
-				       ap->wpa_ie.size);
+				ap->wpa_ie.size = read_ie(bp, RSN_IE_BODY_MAX,
+							  ap->wpa_ie.body);
 			}
 			break;
 

commit f9b280fa9f31750a71db37ceb6ae909defe68b95
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Thu Mar 22 22:07:43 2018 -0700

    staging: ks7010: Replace memcmp() operation with ether_addr_equal().
    
    Instead of using memcmp() to directly compare BSSIDs, use
    ether_addr_equal() from 'linux/etherdevice.h'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 32f35d297628..1a0fe15e842e 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -783,8 +783,9 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 	if (priv->scan_ind_count) {
 		/* bssid check */
 		for (i = 0; i < priv->aplist.size; i++) {
-			if (memcmp(ap_info->bssid,
-				   priv->aplist.ap[i].bssid, ETH_ALEN) != 0)
+			u8 *bssid = priv->aplist.ap[i].bssid;
+
+			if (ether_addr_equal(ap_info->bssid, bssid))
 				continue;
 
 			if (ap_info->frame_type == IEEE80211_STYPE_PROBE_RESP)

commit 6024089f0bdad0695a54b32f2c498b2a1ae63c66
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Thu Mar 22 22:07:41 2018 -0700

    staging: ks7010: Factor out common members in request structs.
    
    Most of the request structures defined in ks_hostif.h have common
    members:
    * __le16 phy_type;
    * __le16 cts_mode;
    * __le16 scan_type;
    * __le16 capability;
    * struct rate_set16_t rate_set;
    
    Factor out these members into a common substructure of type
    'hostif_request_t'.  This allows a large portion of the request
    initialization code in ks_hostif.c to be factored out into the
    'init_request' function.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 653f6aae3420..32f35d297628 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1316,6 +1316,17 @@ static __le16 ks_wlan_cap(struct ks_wlan_private *priv)
 	return cpu_to_le16((uint16_t)capability);
 }
 
+static void init_request(struct ks_wlan_private *priv, struct hostif_request_t *req)
+{
+	req->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
+	req->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
+	req->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+	req->rate_set.size = priv->reg.rate_set.size;
+	req->capability = ks_wlan_cap(priv);
+	memcpy(&req->rate_set.body[0], &priv->reg.rate_set.body[0],
+	       priv->reg.rate_set.size);
+}
+
 static
 void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 {
@@ -1325,14 +1336,8 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 	if (!pp)
 		return;
 
-	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+	init_request(priv, &pp->request);
 	pp->channel = cpu_to_le16((uint16_t)(priv->reg.channel));
-	pp->rate_set.size = priv->reg.rate_set.size;
-	pp->capability = ks_wlan_cap(priv);
-	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
-	       priv->reg.rate_set.size);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1348,16 +1353,9 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 	if (!pp)
 		return;
 
-	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
-
-	pp->rate_set.size = priv->reg.rate_set.size;
-	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
-	       priv->reg.rate_set.size);
+	init_request(priv, &pp->request);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
-	pp->capability = ks_wlan_cap(priv);
 	pp->beacon_lost_count =
 	    cpu_to_le16((uint16_t)(priv->reg.beacon_lost_count));
 	pp->auth_type = cpu_to_le16((uint16_t)(priv->reg.authenticate_type));
@@ -1395,16 +1393,9 @@ static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 	if (!pp)
 		return;
 
-	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
-
-	pp->rate_set.size = priv->reg.rate_set.size;
-	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
-	       priv->reg.rate_set.size);
+	init_request(priv, &pp->request);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
-	pp->capability = ks_wlan_cap(priv);
 	pp->beacon_lost_count =
 	    cpu_to_le16((uint16_t)(priv->reg.beacon_lost_count));
 	pp->auth_type = cpu_to_le16((uint16_t)(priv->reg.authenticate_type));
@@ -1445,16 +1436,10 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 	if (!pp)
 		return;
 
-	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+	init_request(priv, &pp->request);
 	pp->channel = cpu_to_le16((uint16_t)(priv->reg.channel));
-	pp->rate_set.size = priv->reg.rate_set.size;
-	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
-	       priv->reg.rate_set.size);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
-	pp->capability = ks_wlan_cap(priv);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1470,15 +1455,9 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 	if (!pp)
 		return;
 
-	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
-	pp->rate_set.size = priv->reg.rate_set.size;
-	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
-	       priv->reg.rate_set.size);
+	init_request(priv, &pp->request);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
-	pp->capability = ks_wlan_cap(priv);
 
 	pp->channel_list.body[0] = priv->reg.channel;
 	pp->channel_list.size = 1;

commit 20e9cb0a646c08918ee509ac55376bc3d436c0e1
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Thu Mar 22 22:07:40 2018 -0700

    staging: ks7010: Fix lines over 80 characters due to comments.
    
    There are several instances where comments are spaced so far to the
    right they cause the line to go over the 80 character limit.  Move
    these comments to above the statements they describe instead.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 534cca95bfb9..653f6aae3420 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -277,7 +277,8 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 			memcpy(ap->rsn_ie.body, bp + 2, ap->rsn_ie.size);
 			break;
 		case WLAN_EID_VENDOR_SPECIFIC: /* WPA */
-			if (memcmp(bp + 2, CIPHER_ID_WPA_WEP40, 4) == 0) { /* WPA OUI check */
+			/* WPA OUI check */
+			if (memcmp(bp + 2, CIPHER_ID_WPA_WEP40, 4) == 0) {
 				ap->wpa_ie.id = *bp;
 				if (*(bp + 1) <= RSN_IE_BODY_MAX)
 					ap->wpa_ie.size = *(bp + 1);
@@ -469,13 +470,16 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 		netdev_dbg(priv->net_dev, "NETBEUI/NetBIOS rx_ind_size=%d\n",
 			   rx_ind_size);
 
-		skb_put_data(skb, priv->rxp, 12);	/* 8802/FDDI MAC copy */
+		/* 8802/FDDI MAC copy */
+		skb_put_data(skb, priv->rxp, 12);
 
-		temp[0] = (((rx_ind_size - 12) >> 8) & 0xff);	/* NETBEUI size add */
+		/* NETBEUI size add */
+		temp[0] = (((rx_ind_size - 12) >> 8) & 0xff);
 		temp[1] = ((rx_ind_size - 12) & 0xff);
 		skb_put_data(skb, temp, 2);
 
-		skb_put_data(skb, priv->rxp + 12, rx_ind_size - 14);	/* copy after Type */
+		/* copy after Type */
+		skb_put_data(skb, priv->rxp + 12, rx_ind_size - 14);
 
 		aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 14);
 		break;
@@ -1090,8 +1094,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 		return 0;
 	}
 
-	/* for PowerSave */
-	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {	/* power save wakeup */
+	/* power save wakeup */
+	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 		if (!netif_queue_stopped(priv->net_dev))
 			netif_stop_queue(priv->net_dev);
 	}
@@ -1163,11 +1167,12 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	}
 
 	if (priv->wpa.rsn_enabled && priv->wpa.key[0].key_len) {
+		/* no encryption */
 		if (eth_proto == ETH_P_PAE &&
 		    priv->wpa.key[1].key_len == 0 &&
 		    priv->wpa.key[2].key_len == 0 &&
 		    priv->wpa.key[3].key_len == 0) {
-			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);	/* no encryption */
+			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);
 		} else {
 			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
 				MichaelMICFunction(&michael_mic,

commit 5927cb347e69dffeb6250e59238dedf240d9e73e
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Thu Mar 22 22:07:39 2018 -0700

    staging: ks7010: Fix line over 80 characters.
    
    There is no reason for comment describing the BSSID check for loop
    to be spaced so far to the right.  Move it above the for loop.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 3ef9126ab810..534cca95bfb9 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -777,7 +777,8 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 	ap_info = (struct ap_info_t *)(priv->rxp);
 
 	if (priv->scan_ind_count) {
-		for (i = 0; i < priv->aplist.size; i++) {	/* bssid check */
+		/* bssid check */
+		for (i = 0; i < priv->aplist.size; i++) {
 			if (memcmp(ap_info->bssid,
 				   priv->aplist.ap[i].bssid, ETH_ALEN) != 0)
 				continue;

commit 38fc31e73c475733d21a204811be04755deec8a2
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Mar 20 18:13:13 2018 +0100

    staging: ks7010: replace some custom defines with the ones in uapi/linux/if_ether.h
    
    This commit reviews some custom defines changing them for the
    globals defined in if_ether header file.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index ce1ac119a031..3ef9126ab810 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1152,7 +1152,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	eth_proto = ntohs(eth_hdr->h_proto);
 
 	/* for MIC FAILURE REPORT check */
-	if (eth_proto == ETHER_PROTOCOL_TYPE_EAP &&
+	if (eth_proto == ETH_P_PAE &&
 	    priv->wpa.mic_failure.failure > 0) {
 		aa1x_hdr = (struct ieee802_1x_hdr *)(eth_hdr + 1);
 		if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY) {
@@ -1162,7 +1162,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	}
 
 	if (priv->wpa.rsn_enabled && priv->wpa.key[0].key_len) {
-		if (eth_proto == ETHER_PROTOCOL_TYPE_EAP &&
+		if (eth_proto == ETH_P_PAE &&
 		    priv->wpa.key[1].key_len == 0 &&
 		    priv->wpa.key[2].key_len == 0 &&
 		    priv->wpa.key[3].key_len == 0) {
@@ -1189,7 +1189,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 			}
 		}
 	} else {
-		if (eth_proto == ETHER_PROTOCOL_TYPE_EAP)
+		if (eth_proto == ETH_P_PAE)
 			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);
 		else
 			pp->auth_type = cpu_to_le16((uint16_t)TYPE_DATA);
@@ -1206,7 +1206,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 			       send_packet_complete, skb);
 
 	/* MIC FAILURE REPORT check */
-	if (eth_proto == ETHER_PROTOCOL_TYPE_EAP &&
+	if (eth_proto == ETH_P_PAE &&
 	    priv->wpa.mic_failure.failure > 0) {
 		if (keyinfo & WPA_KEY_INFO_ERROR &&
 		    keyinfo & WPA_KEY_INFO_REQUEST) {

commit a00c38a335a858ec87ebc6c456e779966c58934e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Mar 20 15:36:44 2018 +0100

    staging: ks7010: remove max_event_count field which is only being used in debug
    
    This patch removes max_event_count field of sme_info structure which is a
    write only variable just being used for debug purposes.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 81391df9e6d2..ce1ac119a031 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2409,10 +2409,6 @@ void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
 	if (cnt_smeqbody(priv) < (SME_EVENT_BUFF_SIZE - 1)) {
 		priv->sme_i.event_buff[priv->sme_i.qtail] = event;
 		inc_smeqtail(priv);
-#ifdef DEBUG
-		if (priv->sme_i.max_event_count < cnt_smeqbody(priv))
-			priv->sme_i.max_event_count = cnt_smeqbody(priv);
-#endif
 	} else {
 		/* in case of buffer overflow */
 		netdev_err(priv->net_dev, "sme queue buffer overflow\n");
@@ -2461,9 +2457,6 @@ int hostif_init(struct ks_wlan_private *priv)
 	priv->sme_i.sme_status = SME_IDLE;
 	priv->sme_i.qhead = 0;
 	priv->sme_i.qtail = 0;
-#ifdef DEBUG
-	priv->sme_i.max_event_count = 0;
-#endif
 	spin_lock_init(&priv->sme_i.sme_spin);
 	priv->sme_i.sme_flag = 0;
 

commit 31ce0d861cd1053b3950cf405c73f32ca9ed73ea
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Mar 20 15:36:43 2018 +0100

    staging: ks7010: replace KS_WLAN_DEBUG with DEBUG preprocessor directive
    
    This commit replaces custom KS_WLAN_DEBUG which is not being used anymore
    in favour of DEBUG which is the one included when debugging is enabled.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index d644a1d7b564..81391df9e6d2 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2409,10 +2409,10 @@ void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
 	if (cnt_smeqbody(priv) < (SME_EVENT_BUFF_SIZE - 1)) {
 		priv->sme_i.event_buff[priv->sme_i.qtail] = event;
 		inc_smeqtail(priv);
-#ifdef KS_WLAN_DEBUG
+#ifdef DEBUG
 		if (priv->sme_i.max_event_count < cnt_smeqbody(priv))
 			priv->sme_i.max_event_count = cnt_smeqbody(priv);
-#endif /* KS_WLAN_DEBUG */
+#endif
 	} else {
 		/* in case of buffer overflow */
 		netdev_err(priv->net_dev, "sme queue buffer overflow\n");
@@ -2461,7 +2461,7 @@ int hostif_init(struct ks_wlan_private *priv)
 	priv->sme_i.sme_status = SME_IDLE;
 	priv->sme_i.qhead = 0;
 	priv->sme_i.qtail = 0;
-#ifdef KS_WLAN_DEBUG
+#ifdef DEBUG
 	priv->sme_i.max_event_count = 0;
 #endif
 	spin_lock_init(&priv->sme_i.sme_spin);

commit 5259b3293617ea88842a658793ffaa61ea0e0ef4
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Mar 15 20:09:22 2018 +0100

    staging: ks7010: replace DPRINTK traces in favour of netdev_*
    
    This commit removes custom defined DPRINTK macro and replaces all the
    associated debug and other traces for preferred ones netdev_*.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index a25c0fb698b0..d644a1d7b564 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -88,7 +88,7 @@ static void ks_wlan_hw_wakeup_task(struct work_struct *work)
 				&priv->psstatus.wakeup_wait,
 				msecs_to_jiffies(20));
 		if (time_left <= 0) {
-			DPRINTK(1, "wake up timeout or interrupted !!!\n");
+			netdev_dbg(priv->net_dev, "wake up timeout or interrupted !!!\n");
 			schedule_work(&priv->wakeup_work);
 			return;
 		}
@@ -188,30 +188,30 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	if (is_connect_status(priv->connect_status)) {
 		memcpy(wrqu.ap_addr.sa_data,
 		       priv->current_ap.bssid, ETH_ALEN);
-		DPRINTK(3,
-			"IWEVENT: connect bssid=%pM\n", wrqu.ap_addr.sa_data);
+		netdev_dbg(priv->net_dev,
+			   "IWEVENT: connect bssid=%pM\n", wrqu.ap_addr.sa_data);
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);
 	}
-	DPRINTK(4, "\n    Link AP\n");
-	DPRINTK(4, "    bssid=%02X:%02X:%02X:%02X:%02X:%02X\n"
+	netdev_dbg(priv->net_dev, "    Link AP\n");
+	netdev_dbg(priv->net_dev, "    bssid=%02X:%02X:%02X:%02X:%02X:%02X\n"
 		   "    essid=%s\n"
 		   "    rate_set=%02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X\n"
 		   "    channel=%d\n"
 		   "    rssi=%d\n"
 		   "    sq=%d\n"
 		   "    capability=%04X\n",
-		ap->bssid[0], ap->bssid[1], ap->bssid[2],
-		ap->bssid[3], ap->bssid[4], ap->bssid[5],
-		&(ap->ssid.body[0]),
-		ap->rate_set.body[0], ap->rate_set.body[1],
-		ap->rate_set.body[2], ap->rate_set.body[3],
-		ap->rate_set.body[4], ap->rate_set.body[5],
-		ap->rate_set.body[6], ap->rate_set.body[7],
-		ap->channel, ap->rssi, ap->sq, ap->capability);
-	DPRINTK(4, "\n    Link AP\n    rsn.mode=%d\n    rsn.size=%d\n",
-		ap_info->rsn_mode, ap_info->rsn.size);
-	DPRINTK(4, "\n    ext_rate_set_size=%d\n    rate_set_size=%d\n",
-		ap_info->ext_rate_set.size, ap_info->rate_set.size);
+		   ap->bssid[0], ap->bssid[1], ap->bssid[2],
+		   ap->bssid[3], ap->bssid[4], ap->bssid[5],
+		   &(ap->ssid.body[0]),
+		   ap->rate_set.body[0], ap->rate_set.body[1],
+		   ap->rate_set.body[2], ap->rate_set.body[3],
+		   ap->rate_set.body[4], ap->rate_set.body[5],
+		   ap->rate_set.body[6], ap->rate_set.body[7],
+		   ap->channel, ap->rssi, ap->sq, ap->capability);
+	netdev_dbg(priv->net_dev, "    Link AP\n    rsn.mode=%d\n    rsn.size=%d\n",
+		   ap_info->rsn_mode, ap_info->rsn.size);
+	netdev_dbg(priv->net_dev, "    ext_rate_set_size=%d\n    rate_set_size=%d\n",
+		   ap_info->ext_rate_set.size, ap_info->rate_set.size);
 
 	return 0;
 }
@@ -296,7 +296,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 		case WLAN_EID_ERP_INFO:
 			break;
 		default:
-			DPRINTK(4, "unknown Element ID=%d\n", *bp);
+			netdev_err(priv->net_dev, "unknown Element ID=%d\n", *bp);
 			break;
 		}
 
@@ -327,7 +327,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 	eth_proto = ntohs(eth_hdr->h_proto);
 
 	if (eth_hdr->h_dest_snap != eth_hdr->h_source_snap) {
-		DPRINTK(1, "invalid data format\n");
+		netdev_err(priv->net_dev, "invalid data format\n");
 		priv->nstats.rx_errors++;
 		return -EINVAL;
 	}
@@ -338,8 +338,8 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 	     (auth_type == TYPE_GMK2 &&
 	      priv->wpa.group_suite == IW_AUTH_CIPHER_TKIP)) &&
 	    key->key_len) {
-		DPRINTK(4, "TKIP: protocol=%04X: size=%u\n",
-			eth_proto, priv->rx_size);
+		netdev_dbg(priv->net_dev, "TKIP: protocol=%04X: size=%u\n",
+			   eth_proto, priv->rx_size);
 		/* MIC save */
 		memcpy(&recv_mic[0], (priv->rxp) + ((priv->rx_size) - 8), 8);
 		priv->rx_size = priv->rx_size - 8;
@@ -359,7 +359,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 			    (now - mic_failure->last_failure_time) / HZ >= 60) {
 				mic_failure->failure = 0;
 			}
-			DPRINTK(4, "MIC FAILURE\n");
+			netdev_err(priv->net_dev, "MIC FAILURE\n");
 			if (mic_failure->failure == 0) {
 				mic_failure->failure = 1;
 				mic_failure->counter = 0;
@@ -415,12 +415,12 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 
 	/* source address check */
 	if (memcmp(&priv->eth_addr[0], eth_hdr->h_source, ETH_ALEN) == 0) {
-		DPRINTK(1, "invalid : source is own mac address !!\n");
-		DPRINTK(1,
-			"eth_hdrernet->h_dest=%02X:%02X:%02X:%02X:%02X:%02X\n",
-			eth_hdr->h_source[0], eth_hdr->h_source[1],
-			eth_hdr->h_source[2], eth_hdr->h_source[3],
-			eth_hdr->h_source[4], eth_hdr->h_source[5]);
+		netdev_err(priv->net_dev, "invalid : source is own mac address !!\n");
+		netdev_err(priv->net_dev,
+			   "eth_hdrernet->h_dest=%02X:%02X:%02X:%02X:%02X:%02X\n",
+			   eth_hdr->h_source[0], eth_hdr->h_source[1],
+			   eth_hdr->h_source[2], eth_hdr->h_source[3],
+			   eth_hdr->h_source[4], eth_hdr->h_source[5]);
 		priv->nstats.rx_errors++;
 		return;
 	}
@@ -446,7 +446,8 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 			priv->nstats.rx_dropped++;
 			return;
 		}
-		DPRINTK(4, "SNAP, rx_ind_size = %d\n", rx_ind_size);
+		netdev_dbg(priv->net_dev, "SNAP, rx_ind_size = %d\n",
+			   rx_ind_size);
 
 		size = ETH_ALEN * 2;
 		skb_put_data(skb, priv->rxp, size);
@@ -465,7 +466,8 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 			priv->nstats.rx_dropped++;
 			return;
 		}
-		DPRINTK(3, "NETBEUI/NetBIOS rx_ind_size=%d\n", rx_ind_size);
+		netdev_dbg(priv->net_dev, "NETBEUI/NetBIOS rx_ind_size=%d\n",
+			   rx_ind_size);
 
 		skb_put_data(skb, priv->rxp, 12);	/* 8802/FDDI MAC copy */
 
@@ -478,7 +480,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 		aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 14);
 		break;
 	default:	/* other rx data */
-		DPRINTK(2, "invalid data format\n");
+		netdev_err(priv->net_dev, "invalid data format\n");
 		priv->nstats.rx_errors++;
 		return;
 	}
@@ -511,8 +513,8 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 
 	if (mib_status) {
 		/* in case of error */
-		DPRINTK(1, "attribute=%08X, status=%08X\n", mib_attribute,
-			mib_status);
+		netdev_err(priv->net_dev, "attribute=%08X, status=%08X\n",
+			   mib_attribute, mib_status);
 		return;
 	}
 
@@ -545,9 +547,9 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		break;
 	case LOCAL_GAIN:
 		memcpy(&priv->gain, priv->rxp, sizeof(priv->gain));
-		DPRINTK(3, "tx_mode=%d, rx_mode=%d, tx_gain=%d, rx_gain=%d\n",
-			priv->gain.tx_mode, priv->gain.rx_mode,
-			priv->gain.tx_gain, priv->gain.rx_gain);
+		netdev_dbg(priv->net_dev, "tx_mode=%d, rx_mode=%d, tx_gain=%d, rx_gain=%d\n",
+			   priv->gain.tx_mode, priv->gain.rx_mode,
+			   priv->gain.tx_gain, priv->gain.rx_gain);
 		break;
 	case LOCAL_EEPROM_SUM:
 		memcpy(&priv->eeprom_sum, priv->rxp, sizeof(priv->eeprom_sum));
@@ -565,7 +567,8 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		}
 		break;
 	default:
-		DPRINTK(1, "mib_attribute=%08x\n", (unsigned int)mib_attribute);
+		netdev_err(priv->net_dev, "mib_attribute=%08x\n",
+			   (unsigned int)mib_attribute);
 		break;
 	}
 }
@@ -581,8 +584,8 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 
 	if (mib_status) {
 		/* in case of error */
-		DPRINTK(1, "error :: attribute=%08X, status=%08X\n",
-			mib_attribute, mib_status);
+		netdev_err(priv->net_dev, "error :: attribute=%08X, status=%08X\n",
+			   mib_attribute, mib_status);
 	}
 
 	switch (mib_attribute) {
@@ -706,7 +709,7 @@ void hostif_start_confirm(struct ks_wlan_private *priv)
 		wireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);
 	}
 #endif
-	DPRINTK(3, " scan_ind_count=%d\n", priv->scan_ind_count);
+	netdev_dbg(priv->net_dev, " scan_ind_count=%d\n", priv->scan_ind_count);
 	hostif_sme_enqueue(priv, SME_START_CONFIRM);
 }
 
@@ -734,8 +737,8 @@ void hostif_connect_indication(struct ks_wlan_private *priv)
 		priv->connect_status = tmp + DISCONNECT_STATUS;
 		break;
 	default:
-		DPRINTK(1, "unknown connect_code=%d :: scan_ind_count=%d\n",
-			connect_code, priv->scan_ind_count);
+		netdev_dbg(priv->net_dev, "unknown connect_code=%d :: scan_ind_count=%d\n",
+			   connect_code, priv->scan_ind_count);
 		netif_carrier_off(netdev);
 		tmp = FORCE_DISCONNECT & priv->connect_status;
 		priv->connect_status = tmp + DISCONNECT_STATUS;
@@ -757,8 +760,8 @@ void hostif_connect_indication(struct ks_wlan_private *priv)
 	if (is_disconnect_status(priv->connect_status) &&
 	    is_connect_status(old_status)) {
 		eth_zero_addr(wrqu0.ap_addr.sa_data);
-		DPRINTK(3, "disconnect :: scan_ind_count=%d\n",
-			priv->scan_ind_count);
+		netdev_dbg(priv->net_dev, "disconnect :: scan_ind_count=%d\n",
+			   priv->scan_ind_count);
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu0, NULL);
 	}
 	priv->scan_ind_count = 0;
@@ -770,7 +773,7 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 	int i;
 	struct ap_info_t *ap_info;
 
-	DPRINTK(3, "scan_ind_count = %d\n", priv->scan_ind_count);
+	netdev_dbg(priv->net_dev, "scan_ind_count = %d\n", priv->scan_ind_count);
 	ap_info = (struct ap_info_t *)(priv->rxp);
 
 	if (priv->scan_ind_count) {
@@ -787,14 +790,14 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 	}
 	priv->scan_ind_count++;
 	if (priv->scan_ind_count < LOCAL_APLIST_MAX + 1) {
-		DPRINTK(4, " scan_ind_count=%d :: aplist.size=%d\n",
+		netdev_dbg(priv->net_dev, " scan_ind_count=%d :: aplist.size=%d\n",
 			priv->scan_ind_count, priv->aplist.size);
 		get_ap_information(priv, (struct ap_info_t *)(priv->rxp),
 				   &(priv->aplist.ap[priv->scan_ind_count - 1]));
 		priv->aplist.size = priv->scan_ind_count;
 	} else {
-		DPRINTK(4, " count over :: scan_ind_count=%d\n",
-			priv->scan_ind_count);
+		netdev_dbg(priv->net_dev, " count over :: scan_ind_count=%d\n",
+			   priv->scan_ind_count);
 	}
 }
 
@@ -905,8 +908,8 @@ void hostif_bss_scan_confirm(struct ks_wlan_private *priv)
 	union iwreq_data wrqu;
 
 	result_code = get_DWORD(priv);
-	DPRINTK(2, "result=%d :: scan_ind_count=%d\n", result_code,
-		priv->scan_ind_count);
+	netdev_dbg(priv->net_dev, "result=%d :: scan_ind_count=%d\n", result_code,
+		   priv->scan_ind_count);
 
 	priv->sme_i.sme_flag &= ~SME_AP_SCAN;
 	hostif_sme_enqueue(priv, SME_BSS_SCAN_CONFIRM);
@@ -935,22 +938,23 @@ void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 	failed_count = get_DWORD(priv);
 	fcs_error_count = get_DWORD(priv);
 
-	DPRINTK(4, "phyinfo confirm rssi=%d signal=%d\n", rssi, signal);
+	netdev_dbg(priv->net_dev, "phyinfo confirm rssi=%d signal=%d\n",
+		   rssi, signal);
 	priv->current_rate = (link_speed & RATE_MASK);
 	wstats->qual.qual = signal;
 	wstats->qual.level = 256 - rssi;
 	wstats->qual.noise = 0;	/* invalid noise value */
 	wstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
 
-	DPRINTK(3, "\n    rssi=%u\n"
+	netdev_dbg(priv->net_dev, "\n    rssi=%u\n"
 		   "    signal=%u\n"
 		   "    link_speed=%ux500Kbps\n"
 		   "    transmitted_frame_count=%u\n"
 		   "    received_fragment_count=%u\n"
 		   "    failed_count=%u\n"
 		   "    fcs_error_count=%u\n",
-		rssi, signal, link_speed, transmitted_frame_count,
-		received_fragment_count, failed_count, fcs_error_count);
+		   rssi, signal, link_speed, transmitted_frame_count,
+		   received_fragment_count, failed_count, fcs_error_count);
 	/* wake_up_interruptible_all(&priv->confirm_wait); */
 	complete(&priv->confirm_wait);
 }
@@ -958,7 +962,7 @@ void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 static
 void hostif_mic_failure_confirm(struct ks_wlan_private *priv)
 {
-	DPRINTK(3, "mic_failure=%u\n", priv->wpa.mic_failure.failure);
+	netdev_dbg(priv->net_dev, "mic_failure=%u\n", priv->wpa.mic_failure.failure);
 	hostif_sme_enqueue(priv, SME_MIC_FAILURE_CONFIRM);
 }
 
@@ -1069,7 +1073,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 
 	skb_len = skb->len;
 	if (skb_len > ETH_FRAME_LEN) {
-		DPRINTK(1, "bad length skb_len=%d\n", skb_len);
+		netdev_err(priv->net_dev, "bad length skb_len=%d\n", skb_len);
 		ret = -EOVERFLOW;
 		goto err_kfree_skb;
 	}
@@ -1106,8 +1110,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	/* skb check */
 	eth = (struct ethhdr *)skb->data;
 	if (memcmp(&priv->eth_addr[0], eth->h_source, ETH_ALEN) != 0) {
-		DPRINTK(1, "invalid mac address !!\n");
-		DPRINTK(1, "ethernet->h_source=%pM\n", eth->h_source);
+		netdev_err(priv->net_dev, "invalid mac address !!\n");
+		netdev_err(priv->net_dev, "ethernet->h_source=%pM\n", eth->h_source);
 		ret = -ENXIO;
 		goto err_kfree;
 	}
@@ -1122,7 +1126,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	/* EtherType/Length check */
 	if (*(buffer + 1) + (*buffer << 8) > 1500) {
 		/* ProtocolEAP = *(buffer+1) + (*buffer << 8); */
-		/* DPRINTK(2, "Send [SNAP]Type %x\n",ProtocolEAP); */
+		/* netdev_dbg(priv->net_dev, "Send [SNAP]Type %x\n",ProtocolEAP); */
 		/* SAP/CTL/OUI(6 byte) add */
 		*p++ = 0xAA;	/* DSAP */
 		*p++ = 0xAA;	/* SSAP */
@@ -1206,7 +1210,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	    priv->wpa.mic_failure.failure > 0) {
 		if (keyinfo & WPA_KEY_INFO_ERROR &&
 		    keyinfo & WPA_KEY_INFO_REQUEST) {
-			DPRINTK(3, " MIC ERROR Report SET : %04X\n", keyinfo);
+			netdev_err(priv->net_dev, " MIC ERROR Report SET : %04X\n", keyinfo);
 			hostif_sme_enqueue(priv, SME_MIC_FAILURE_REQUEST);
 		}
 		if (priv->wpa.mic_failure.failure == 2)
@@ -1554,7 +1558,7 @@ void hostif_sleep_request(struct ks_wlan_private *priv,
 		atomic_set(&priv->sleepstatus.wakeup_request, 1);
 		queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 	} else {
-		DPRINTK(3, "invalid mode %ld\n", (long)mode);
+		netdev_err(priv->net_dev, "invalid mode %ld\n", (long)mode);
 		return;
 	}
 }
@@ -1988,8 +1992,8 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 			hostif_infrastructure_set_request(priv);
 		} else {
 			hostif_infrastructure_set2_request(priv);
-			DPRINTK(2,
-				"Infra bssid = %pM\n", priv->reg.bssid);
+			netdev_dbg(priv->net_dev,
+				   "Infra bssid = %pM\n", priv->reg.bssid);
 		}
 		break;
 	case MODE_ADHOC:
@@ -1998,8 +2002,8 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 			hostif_adhoc_set_request(priv);
 		} else {
 			hostif_adhoc_set2_request(priv);
-			DPRINTK(2,
-				"Adhoc bssid = %pM\n", priv->reg.bssid);
+			netdev_dbg(priv->net_dev,
+				   "Adhoc bssid = %pM\n", priv->reg.bssid);
 		}
 		break;
 	default:
@@ -2245,8 +2249,8 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 						   priv->wpa.mic_failure.failure - 1,
 						   priv->wpa.mic_failure.counter);
 		} else {
-			DPRINTK(4, "SME_MIC_FAILURE_REQUEST: failure count=%u error?\n",
-				priv->wpa.mic_failure.failure);
+			netdev_err(priv->net_dev, "SME_MIC_FAILURE_REQUEST: failure count=%u error?\n",
+				   priv->wpa.mic_failure.failure);
 		}
 		break;
 	case SME_MIC_FAILURE_CONFIRM:

commit 7acf4002e348913c86015337ea0810acbb5443e0
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Mar 15 20:09:21 2018 +0100

    staging: ks7010: remove useless DPRINTK traces
    
    This commit removes some useless traces in some source files
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index c05102d75ea1..a25c0fb698b0 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -92,22 +92,16 @@ static void ks_wlan_hw_wakeup_task(struct work_struct *work)
 			schedule_work(&priv->wakeup_work);
 			return;
 		}
-	} else {
-		DPRINTK(1, "ps_status=%d\n", ps_status);
 	}
 
 	/* power save */
-	if (atomic_read(&priv->sme_task.count) > 0) {
-		DPRINTK(4, "sme task enable.\n");
+	if (atomic_read(&priv->sme_task.count) > 0)
 		tasklet_enable(&priv->sme_task);
-	}
 }
 
 static
 int ks_wlan_do_power_save(struct ks_wlan_private *priv)
 {
-	DPRINTK(4, "psstatus.status=%d\n", atomic_read(&priv->psstatus.status));
-
 	if (is_connect_status(priv->connect_status))
 		hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
 	else
@@ -122,7 +116,6 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	union iwreq_data wrqu;
 	struct net_device *netdev = priv->net_dev;
 
-	DPRINTK(3, "\n");
 	ap = &priv->current_ap;
 
 	if (is_disconnect_status(priv->connect_status)) {
@@ -230,7 +223,6 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 	unsigned char *bp;
 	int bsize, offset;
 
-	DPRINTK(3, "\n");
 	memset(ap, 0, sizeof(struct local_ap_t));
 
 	/* bssid */
@@ -253,13 +245,10 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 	while (bsize > offset) {
 		switch (*bp) { /* Information Element ID */
 		case WLAN_EID_SSID:
-			if (*(bp + 1) <= IEEE80211_MAX_SSID_LEN) {
+			if (*(bp + 1) <= IEEE80211_MAX_SSID_LEN)
 				ap->ssid.size = *(bp + 1);
-			} else {
-				DPRINTK(1, "size over :: ssid size=%d\n",
-					*(bp + 1));
+			else
 				ap->ssid.size = IEEE80211_MAX_SSID_LEN;
-			}
 			memcpy(ap->ssid.body, bp + 2, ap->ssid.size);
 			break;
 		case WLAN_EID_SUPP_RATES:
@@ -270,8 +259,6 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 				       bp + 2, *(bp + 1));
 				ap->rate_set.size += *(bp + 1);
 			} else {
-				DPRINTK(1, "size over :: rate size=%d\n",
-					(*(bp + 1) + ap->rate_set.size));
 				memcpy(&ap->rate_set.body[ap->rate_set.size],
 				       bp + 2,
 				       RATE_SET_MAX_SIZE - ap->rate_set.size);
@@ -283,26 +270,19 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 			break;
 		case WLAN_EID_RSN:
 			ap->rsn_ie.id = *bp;
-			if (*(bp + 1) <= RSN_IE_BODY_MAX) {
+			if (*(bp + 1) <= RSN_IE_BODY_MAX)
 				ap->rsn_ie.size = *(bp + 1);
-			} else {
-				DPRINTK(1, "size over :: rsn size=%d\n",
-					*(bp + 1));
+			else
 				ap->rsn_ie.size = RSN_IE_BODY_MAX;
-			}
 			memcpy(ap->rsn_ie.body, bp + 2, ap->rsn_ie.size);
 			break;
 		case WLAN_EID_VENDOR_SPECIFIC: /* WPA */
 			if (memcmp(bp + 2, CIPHER_ID_WPA_WEP40, 4) == 0) { /* WPA OUI check */
 				ap->wpa_ie.id = *bp;
-				if (*(bp + 1) <= RSN_IE_BODY_MAX) {
+				if (*(bp + 1) <= RSN_IE_BODY_MAX)
 					ap->wpa_ie.size = *(bp + 1);
-				} else {
-					DPRINTK(1,
-						"size over :: wpa size=%d\n",
-						*(bp + 1));
+				else
 					ap->wpa_ie.size = RSN_IE_BODY_MAX;
-				}
 				memcpy(ap->wpa_ie.body, bp + 2,
 				       ap->wpa_ie.size);
 			}
@@ -400,7 +380,6 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 				eth_hdr->h_source);
 			memset(&wrqu, 0, sizeof(wrqu));
 			wrqu.data.length = strlen(buf);
-			DPRINTK(4, "IWEVENT:MICHAELMICFAILURE\n");
 			wireless_send_event(priv->net_dev, IWEVCUSTOM, &wrqu,
 					    buf);
 			return -EINVAL;
@@ -422,11 +401,8 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 	size_t size;
 	int ret;
 
-	DPRINTK(3, "\n");
-
 	/* min length check */
 	if (priv->rx_size <= ETH_HLEN) {
-		DPRINTK(3, "rx_size = %d\n", priv->rx_size);
 		priv->nstats.rx_errors++;
 		return;
 	}
@@ -436,7 +412,6 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 
 	eth_hdr = (struct ether_hdr *)(priv->rxp);
 	eth_proto = ntohs(eth_hdr->h_proto);
-	DPRINTK(3, "ether protocol = %04X\n", eth_proto);
 
 	/* source address check */
 	if (memcmp(&priv->eth_addr[0], eth_hdr->h_source, ETH_ALEN) == 0) {
@@ -529,8 +504,6 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 	u16 mib_val_size;
 	u16 mib_val_type;
 
-	DPRINTK(3, "\n");
-
 	mib_status = get_DWORD(priv);	/* MIB status */
 	mib_attribute = get_DWORD(priv);	/* MIB atttibute */
 	mib_val_size = get_WORD(priv);	/* MIB value size */
@@ -546,7 +519,6 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 	switch (mib_attribute) {
 	case DOT11_MAC_ADDRESS:
 		/* MAC address */
-		DPRINTK(3, " mib_attribute=DOT11_MAC_ADDRESS\n");
 		hostif_sme_enqueue(priv, SME_GET_MAC_ADDRESS);
 		memcpy(priv->eth_addr, priv->rxp, ETH_ALEN);
 		priv->mac_address_valid = 1;
@@ -562,7 +534,6 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		break;
 	case DOT11_PRODUCT_VERSION:
 		/* firmware version */
-		DPRINTK(3, " mib_attribute=DOT11_PRODUCT_VERSION\n");
 		priv->version_size = priv->rx_size;
 		memcpy(priv->firmware_version, priv->rxp, priv->rx_size);
 		priv->firmware_version[priv->rx_size] = '\0';
@@ -580,8 +551,6 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		break;
 	case LOCAL_EEPROM_SUM:
 		memcpy(&priv->eeprom_sum, priv->rxp, sizeof(priv->eeprom_sum));
-		DPRINTK(1, "eeprom_sum.type=%x, eeprom_sum.result=%x\n",
-			priv->eeprom_sum.type, priv->eeprom_sum.result);
 		if (priv->eeprom_sum.type == 0) {
 			priv->eeprom_checksum = EEPROM_CHECKSUM_NONE;
 		} else if (priv->eeprom_sum.type == 1) {
@@ -607,8 +576,6 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 	u32 mib_status;	/* +04 MIB Status */
 	u32 mib_attribute;	/* +08 MIB attribute */
 
-	DPRINTK(3, "\n");
-
 	mib_status = get_DWORD(priv);	/* MIB Status */
 	mib_attribute = get_DWORD(priv);	/* MIB attribute */
 
@@ -630,32 +597,24 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 			hostif_sme_enqueue(priv, SME_WEP_INDEX_CONFIRM);
 		break;
 	case DOT11_WEP_DEFAULT_KEY_VALUE1:
-		DPRINTK(2, "DOT11_WEP_DEFAULT_KEY_VALUE1:mib_status=%d\n",
-			(int)mib_status);
 		if (priv->wpa.rsn_enabled)
 			hostif_sme_enqueue(priv, SME_SET_PMK_TSC);
 		else
 			hostif_sme_enqueue(priv, SME_WEP_KEY1_CONFIRM);
 		break;
 	case DOT11_WEP_DEFAULT_KEY_VALUE2:
-		DPRINTK(2, "DOT11_WEP_DEFAULT_KEY_VALUE2:mib_status=%d\n",
-			(int)mib_status);
 		if (priv->wpa.rsn_enabled)
 			hostif_sme_enqueue(priv, SME_SET_GMK1_TSC);
 		else
 			hostif_sme_enqueue(priv, SME_WEP_KEY2_CONFIRM);
 		break;
 	case DOT11_WEP_DEFAULT_KEY_VALUE3:
-		DPRINTK(2, "DOT11_WEP_DEFAULT_KEY_VALUE3:mib_status=%d\n",
-			(int)mib_status);
 		if (priv->wpa.rsn_enabled)
 			hostif_sme_enqueue(priv, SME_SET_GMK2_TSC);
 		else
 			hostif_sme_enqueue(priv, SME_WEP_KEY3_CONFIRM);
 		break;
 	case DOT11_WEP_DEFAULT_KEY_VALUE4:
-		DPRINTK(2, "DOT11_WEP_DEFAULT_KEY_VALUE4:mib_status=%d\n",
-			(int)mib_status);
 		if (!priv->wpa.rsn_enabled)
 			hostif_sme_enqueue(priv, SME_WEP_KEY4_CONFIRM);
 		break;
@@ -664,8 +623,6 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 			hostif_sme_enqueue(priv, SME_WEP_FLAG_CONFIRM);
 		break;
 	case DOT11_RSN_ENABLED:
-		DPRINTK(2, "DOT11_RSN_ENABLED:mib_status=%d\n",
-			(int)mib_status);
 		hostif_sme_enqueue(priv, SME_RSN_ENABLED_CONFIRM);
 		break;
 	case LOCAL_RSN_MODE:
@@ -681,50 +638,35 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 		priv->mac_address_valid = 1;
 		break;
 	case DOT11_RSN_CONFIG_MULTICAST_CIPHER:
-		DPRINTK(2, "DOT11_RSN_CONFIG_MULTICAST_CIPHER:mib_status=%d\n",
-			(int)mib_status);
 		hostif_sme_enqueue(priv, SME_RSN_MCAST_CONFIRM);
 		break;
 	case DOT11_RSN_CONFIG_UNICAST_CIPHER:
-		DPRINTK(2, "DOT11_RSN_CONFIG_UNICAST_CIPHER:mib_status=%d\n",
-			(int)mib_status);
 		hostif_sme_enqueue(priv, SME_RSN_UCAST_CONFIRM);
 		break;
 	case DOT11_RSN_CONFIG_AUTH_SUITE:
-		DPRINTK(2, "DOT11_RSN_CONFIG_AUTH_SUITE:mib_status=%d\n",
-			(int)mib_status);
 		hostif_sme_enqueue(priv, SME_RSN_AUTH_CONFIRM);
 		break;
 	case DOT11_PMK_TSC:
-		DPRINTK(2, "DOT11_PMK_TSC:mib_status=%d\n", (int)mib_status);
 		break;
 	case DOT11_GMK1_TSC:
-		DPRINTK(2, "DOT11_GMK1_TSC:mib_status=%d\n", (int)mib_status);
 		if (atomic_read(&priv->psstatus.snooze_guard))
 			atomic_set(&priv->psstatus.snooze_guard, 0);
 		break;
 	case DOT11_GMK2_TSC:
-		DPRINTK(2, "DOT11_GMK2_TSC:mib_status=%d\n", (int)mib_status);
 		if (atomic_read(&priv->psstatus.snooze_guard))
 			atomic_set(&priv->psstatus.snooze_guard, 0);
 		break;
 	case LOCAL_PMK:
-		DPRINTK(2, "LOCAL_PMK:mib_status=%d\n", (int)mib_status);
 		break;
 	case LOCAL_GAIN:
-		DPRINTK(2, "LOCAL_GAIN:mib_status=%d\n", (int)mib_status);
 		break;
 #ifdef WPS
 	case LOCAL_WPS_ENABLE:
-		DPRINTK(2, "LOCAL_WPS_ENABLE:mib_status=%d\n", (int)mib_status);
 		break;
 	case LOCAL_WPS_PROBE_REQ:
-		DPRINTK(2, "LOCAL_WPS_PROBE_REQ:mib_status=%d\n",
-			(int)mib_status);
 		break;
 #endif /* WPS */
 	case LOCAL_REGION:
-		DPRINTK(2, "LOCAL_REGION:mib_status=%d\n", (int)mib_status);
 	default:
 		break;
 	}
@@ -733,8 +675,6 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 static
 void hostif_power_mgmt_confirm(struct ks_wlan_private *priv)
 {
-	DPRINTK(3, "\n");
-
 	if (priv->reg.power_mgmt > POWER_MGMT_ACTIVE &&
 	    priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 		atomic_set(&priv->psstatus.confirm_wait, 0);
@@ -748,8 +688,6 @@ void hostif_power_mgmt_confirm(struct ks_wlan_private *priv)
 static
 void hostif_sleep_confirm(struct ks_wlan_private *priv)
 {
-	DPRINTK(3, "\n");
-
 	atomic_set(&priv->sleepstatus.doze_request, 1);
 	queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 }
@@ -765,7 +703,6 @@ void hostif_start_confirm(struct ks_wlan_private *priv)
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
 	if (is_connect_status(priv->connect_status)) {
 		eth_zero_addr(wrqu.ap_addr.sa_data);
-		DPRINTK(3, "IWEVENT: disconnect\n");
 		wireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);
 	}
 #endif
@@ -786,16 +723,12 @@ void hostif_connect_indication(struct ks_wlan_private *priv)
 
 	switch (connect_code) {
 	case RESULT_CONNECT:	/* connect */
-		DPRINTK(3, "connect :: scan_ind_count=%d\n",
-			priv->scan_ind_count);
 		if (!(priv->connect_status & FORCE_DISCONNECT))
 			netif_carrier_on(netdev);
 		tmp = FORCE_DISCONNECT & priv->connect_status;
 		priv->connect_status = tmp + CONNECT_STATUS;
 		break;
-	case RESULT_DISCONNECT:	/* disconnect */
-		DPRINTK(3, "disconnect :: scan_ind_count=%d\n",
-			priv->scan_ind_count);
+	case RESULT_DISCONNECT: /* disconnect */
 		netif_carrier_off(netdev);
 		tmp = FORCE_DISCONNECT & priv->connect_status;
 		priv->connect_status = tmp + DISCONNECT_STATUS;
@@ -824,7 +757,6 @@ void hostif_connect_indication(struct ks_wlan_private *priv)
 	if (is_disconnect_status(priv->connect_status) &&
 	    is_connect_status(old_status)) {
 		eth_zero_addr(wrqu0.ap_addr.sa_data);
-		DPRINTK(3, "IWEVENT: disconnect\n");
 		DPRINTK(3, "disconnect :: scan_ind_count=%d\n",
 			priv->scan_ind_count);
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu0, NULL);
@@ -874,7 +806,6 @@ void hostif_stop_confirm(struct ks_wlan_private *priv)
 	struct net_device *netdev = priv->net_dev;
 	union iwreq_data wrqu0;
 
-	DPRINTK(3, "\n");
 	if (priv->dev_state == DEVICE_STATE_SLEEP)
 		priv->dev_state = DEVICE_STATE_READY;
 
@@ -891,10 +822,7 @@ void hostif_stop_confirm(struct ks_wlan_private *priv)
 		if (is_disconnect_status(priv->connect_status) &&
 		    is_connect_status(old_status)) {
 			eth_zero_addr(wrqu0.ap_addr.sa_data);
-			DPRINTK(3, "IWEVENT: disconnect\n");
 			netdev_info(netdev, "IWEVENT: disconnect\n");
-			DPRINTK(3, "disconnect :: scan_ind_count=%d\n",
-				priv->scan_ind_count);
 			wireless_send_event(netdev, SIOCGIWAP, &wrqu0, NULL);
 		}
 		priv->scan_ind_count = 0;
@@ -906,7 +834,6 @@ void hostif_stop_confirm(struct ks_wlan_private *priv)
 static
 void hostif_ps_adhoc_set_confirm(struct ks_wlan_private *priv)
 {
-	DPRINTK(3, "\n");
 	priv->infra_status = 0;	/* infrastructure mode cancel */
 	hostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);
 }
@@ -916,9 +843,7 @@ void hostif_infrastructure_set_confirm(struct ks_wlan_private *priv)
 {
 	u16 result_code;
 
-	DPRINTK(3, "\n");
 	result_code = get_WORD(priv);
-	DPRINTK(3, "result code = %d\n", result_code);
 	priv->infra_status = 1;	/* infrastructure mode set */
 	hostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);
 }
@@ -926,7 +851,6 @@ void hostif_infrastructure_set_confirm(struct ks_wlan_private *priv)
 static
 void hostif_adhoc_set_confirm(struct ks_wlan_private *priv)
 {
-	DPRINTK(3, "\n");
 	priv->infra_status = 1;	/* infrastructure mode set */
 	hostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);
 }
@@ -945,7 +869,6 @@ void hostif_associate_indication(struct ks_wlan_private *priv)
 	static const char associnfo_leader0[] = "ASSOCINFO(ReqIEs=";
 	static const char associnfo_leader1[] = " RespIEs=";
 
-	DPRINTK(3, "\n");
 	assoc_req = (struct association_request_t *)(priv->rxp);
 	assoc_resp = (struct association_response_t *)(assoc_req + 1);
 	pb = (unsigned char *)(assoc_resp + 1);
@@ -971,7 +894,6 @@ void hostif_associate_indication(struct ks_wlan_private *priv)
 	pbuf += sprintf(pbuf, ")");
 	wrqu.data.length += 1;
 
-	DPRINTK(3, "IWEVENT:ASSOCINFO\n");
 	wireless_send_event(priv->net_dev, IWEVCUSTOM, &wrqu, buf);
 }
 
@@ -991,7 +913,6 @@ void hostif_bss_scan_confirm(struct ks_wlan_private *priv)
 
 	wrqu.data.length = 0;
 	wrqu.data.flags = 0;
-	DPRINTK(3, "IWEVENT: SCAN CONFIRM\n");
 	wireless_send_event(dev, SIOCGIWSCAN, &wrqu, NULL);
 	priv->scan_ind_count = 0;
 }
@@ -1005,7 +926,6 @@ void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 	unsigned int transmitted_frame_count, received_fragment_count;
 	unsigned int failed_count, fcs_error_count;
 
-	DPRINTK(3, "\n");
 	rssi = get_BYTE(priv);
 	signal = get_BYTE(priv);
 	noise = get_BYTE(priv);
@@ -1047,7 +967,6 @@ void hostif_event_check(struct ks_wlan_private *priv)
 {
 	unsigned short event;
 
-	DPRINTK(4, "\n");
 	event = get_WORD(priv);	/* get event */
 	switch (event) {
 	case HIF_DATA_IND:
@@ -1103,7 +1022,6 @@ void hostif_event_check(struct ks_wlan_private *priv)
 		break;
 	case HIF_AP_SET_CONF:
 	default:
-		//DPRINTK(1, "undefined event[%04X]\n", event);
 		netdev_err(priv->net_dev, "undefined event[%04X]\n", event);
 		/* wake_up_all(&priv->confirm_wait); */
 		complete(&priv->confirm_wait);
@@ -1159,7 +1077,6 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	if (is_disconnect_status(priv->connect_status) ||
 	    (priv->connect_status & FORCE_DISCONNECT) ||
 	    priv->wpa.mic_failure.stop) {
-		DPRINTK(3, " DISCONNECT\n");
 		if (netif_queue_stopped(priv->net_dev))
 			netif_wake_queue(priv->net_dev);
 		if (skb)
@@ -1215,7 +1132,6 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 		*p++ = 0x00;	/* OUI ("000000") */
 		skb_len += 6;
 	} else {
-		DPRINTK(4, "DIX\n");
 		/* Length(2 byte) delete */
 		buffer += 2;
 		length -= 2;
@@ -1319,8 +1235,6 @@ void hostif_mib_get_request(struct ks_wlan_private *priv,
 {
 	struct hostif_mib_get_request_t *pp;
 
-	DPRINTK(3, "\n");
-
 	pp = hostif_generic_request(sizeof(*pp), HIF_MIB_GET_REQ);
 	if (!pp)
 		return;
@@ -1339,12 +1253,8 @@ void hostif_mib_set_request(struct ks_wlan_private *priv,
 {
 	struct hostif_mib_set_request_t *pp;
 
-	DPRINTK(3, "\n");
-
-	if (priv->dev_state < DEVICE_STATE_BOOT) {
-		DPRINTK(3, "DeviceRemove\n");
+	if (priv->dev_state < DEVICE_STATE_BOOT)
 		return;
-	}
 
 	pp = hostif_generic_request(sizeof(*pp), HIF_MIB_SET_REQ);
 	if (!pp)
@@ -1365,8 +1275,6 @@ void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 {
 	struct hostif_start_request_t *pp;
 
-	DPRINTK(3, "\n");
-
 	pp = hostif_generic_request(sizeof(*pp), HIF_START_REQ);
 	if (!pp)
 		return;
@@ -1403,8 +1311,6 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 {
 	struct hostif_ps_adhoc_set_request_t *pp;
 
-	DPRINTK(3, "\n");
-
 	pp = hostif_generic_request(sizeof(*pp), HIF_PS_ADH_SET_REQ);
 	if (!pp)
 		return;
@@ -1428,8 +1334,6 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 {
 	struct hostif_infrastructure_set_request_t *pp;
 
-	DPRINTK(3, "ssid.size=%d\n", priv->reg.ssid.size);
-
 	pp = hostif_generic_request(sizeof(*pp), HIF_INFRA_SET_REQ);
 	if (!pp)
 		return;
@@ -1477,8 +1381,6 @@ static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 {
 	struct hostif_infrastructure_set2_request_t *pp;
 
-	DPRINTK(2, "ssid.size=%d\n", priv->reg.ssid.size);
-
 	pp = hostif_generic_request(sizeof(*pp), HIF_INFRA_SET2_REQ);
 	if (!pp)
 		return;
@@ -1529,8 +1431,6 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 {
 	struct hostif_adhoc_set_request_t *pp;
 
-	DPRINTK(3, "\n");
-
 	pp = hostif_generic_request(sizeof(*pp), HIF_ADH_SET_REQ);
 	if (!pp)
 		return;
@@ -1556,8 +1456,6 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 {
 	struct hostif_adhoc_set2_request_t *pp;
 
-	DPRINTK(3, "\n");
-
 	pp = hostif_generic_request(sizeof(*pp), HIF_ADH_SET_REQ);
 	if (!pp)
 		return;
@@ -1586,8 +1484,6 @@ void hostif_stop_request(struct ks_wlan_private *priv)
 {
 	struct hostif_stop_request_t *pp;
 
-	DPRINTK(3, "\n");
-
 	pp = hostif_generic_request(sizeof(*pp), HIF_STOP_REQ);
 	if (!pp)
 		return;
@@ -1602,8 +1498,6 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 {
 	struct hostif_phy_information_request_t *pp;
 
-	DPRINTK(3, "\n");
-
 	pp = hostif_generic_request(sizeof(*pp), HIF_PHY_INFO_REQ);
 	if (!pp)
 		return;
@@ -1628,9 +1522,6 @@ void hostif_power_mgmt_request(struct ks_wlan_private *priv,
 {
 	struct hostif_power_mgmt_request_t *pp;
 
-	DPRINTK(3, "mode=%lu wake_up=%lu receive_dtims=%lu\n", mode, wake_up,
-		receive_dtims);
-
 	pp = hostif_generic_request(sizeof(*pp), HIF_POWER_MGMT_REQ);
 	if (!pp)
 		return;
@@ -1650,8 +1541,6 @@ void hostif_sleep_request(struct ks_wlan_private *priv,
 {
 	struct hostif_sleep_request_t *pp;
 
-	DPRINTK(3, "mode=%lu\n", (long)mode);
-
 	if (mode == SLP_SLEEP) {
 		pp = hostif_generic_request(sizeof(*pp), HIF_SLEEP_REQ);
 		if (!pp)
@@ -1677,8 +1566,6 @@ void hostif_bss_scan_request(struct ks_wlan_private *priv,
 {
 	struct hostif_bss_scan_request_t *pp;
 
-	DPRINTK(2, "\n");
-
 	pp = hostif_generic_request(sizeof(*pp), HIF_SCAN_REQ);
 	if (!pp)
 		return;
@@ -1729,8 +1616,6 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 {
 	struct hostif_mic_failure_request_t *pp;
 
-	DPRINTK(3, "count=%d :: timer=%d\n", failure_count, timer);
-
 	pp = hostif_generic_request(sizeof(*pp), HIF_MIC_FAILURE_REQ);
 	if (!pp)
 		return;
@@ -1770,8 +1655,6 @@ static void devio_rec_ind(struct ks_wlan_private *priv, unsigned char *p,
 void hostif_receive(struct ks_wlan_private *priv, unsigned char *p,
 		    unsigned int size)
 {
-	DPRINTK(4, "\n");
-
 	devio_rec_ind(priv, p, size);
 
 	priv->rxp = p;
@@ -2134,8 +2017,6 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 	__le32 filter_type;
 	int i = 0;
 
-	DPRINTK(3, "\n");
-
 	spin_lock(&priv->multicast_spin);
 
 	memset(set_address, 0, NIC_MAX_MCAST_LIST * ETH_ALEN);
@@ -2185,7 +2066,6 @@ void hostif_sme_power_mgmt_set(struct ks_wlan_private *priv)
 {
 	unsigned long mode, wake_up, receive_dtims;
 
-	DPRINTK(3, "\n");
 	switch (priv->reg.power_mgmt) {
 	case POWER_MGMT_ACTIVE:
 		mode = POWER_ACTIVE;
@@ -2226,7 +2106,6 @@ void hostif_sme_power_mgmt_set(struct ks_wlan_private *priv)
 static
 void hostif_sme_sleep_set(struct ks_wlan_private *priv)
 {
-	DPRINTK(3, "\n");
 	switch (priv->sleep_mode) {
 	case SLP_SLEEP:
 		hostif_sleep_request(priv, priv->sleep_mode);
@@ -2310,7 +2189,6 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 	struct pmk_t *pmk;
 	int i;
 
-	DPRINTK(4, "pmklist.size=%d\n", priv->pmklist.size);
 	i = 0;
 	list_for_each_entry(pmk, &priv->pmklist.head, list) {
 		if (i < PMK_LIST_MAX) {
@@ -2334,7 +2212,6 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 {
 	__le32 val;
 
-	DPRINTK(3, "event=%d\n", event);
 	switch (event) {
 	case SME_START:
 		if (priv->dev_state == DEVICE_STATE_BOOT)
@@ -2509,8 +2386,6 @@ void hostif_sme_task(unsigned long dev)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
 
-	DPRINTK(3, "\n");
-
 	if (priv->dev_state < DEVICE_STATE_BOOT)
 		return;
 
@@ -2526,8 +2401,6 @@ void hostif_sme_task(unsigned long dev)
 /* send to Station Management Entity module */
 void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
 {
-	DPRINTK(3, "\n");
-
 	/* enqueue sme event */
 	if (cnt_smeqbody(priv) < (SME_EVENT_BUFF_SIZE - 1)) {
 		priv->sme_i.event_buff[priv->sme_i.qtail] = event;
@@ -2548,8 +2421,6 @@ int hostif_init(struct ks_wlan_private *priv)
 {
 	int i;
 
-	DPRINTK(3, "\n");
-
 	priv->aplist.size = 0;
 	for (i = 0; i < LOCAL_APLIST_MAX; i++)
 		memset(&priv->aplist.ap[i], 0, sizeof(struct local_ap_t));

commit 816148138518da9362a3b0c46f3cdf3d97282008
Author: Nishka Dasgupta <nishka.dasgupta_ug18@ashoka.edu.in>
Date:   Wed Mar 14 18:29:30 2018 +0000

    staging: ks7010: Remove braces around single statement
    
    Remove braces around single statement. Issue found with checkpatch.
    
    Signed-off-by: Nishka Dasgupta <nishka.dasgupta_ug18@ashoka.edu.in>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 05f7be4638fe..c05102d75ea1 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1385,9 +1385,8 @@ static __le16 ks_wlan_cap(struct ks_wlan_private *priv)
 {
 	u16 capability = 0x0000;
 
-	if (priv->reg.preamble == SHORT_PREAMBLE) {
+	if (priv->reg.preamble == SHORT_PREAMBLE)
 		capability |= WLAN_CAPABILITY_SHORT_PREAMBLE;
-	}
 
 	capability &= ~(WLAN_CAPABILITY_PBCC);	/* pbcc not support */
 

commit 33f328f7ab6d7e38164f80f3d784448a7ba94d8c
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Tue Mar 6 02:00:04 2018 -0800

    staging: ks7010: Replace literal with constant.
    
    Replace literal bytestring with CIPHER_ID_WPA_WEP40 constant.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 7935ba56bb1d..05f7be4638fe 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -293,7 +293,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 			memcpy(ap->rsn_ie.body, bp + 2, ap->rsn_ie.size);
 			break;
 		case WLAN_EID_VENDOR_SPECIFIC: /* WPA */
-			if (memcmp(bp + 2, "\x00\x50\xf2\x01", 4) == 0) { /* WPA OUI check */
+			if (memcmp(bp + 2, CIPHER_ID_WPA_WEP40, 4) == 0) { /* WPA OUI check */
 				ap->wpa_ie.id = *bp;
 				if (*(bp + 1) <= RSN_IE_BODY_MAX) {
 					ap->wpa_ie.size = *(bp + 1);

commit 58060d000469a1bb148ae2cb41d7486f9d263704
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Wed Feb 28 21:19:11 2018 -0800

    staging: ks7010: Replace local frame type constants with kernel constants.
    
    This driver defined constants FRAME_TYPE_* to represent frame control
    field codes; however, these constants are already defined in the header
    'linux/ieee80211.h' as  IEEE80211_STYPE_*.  This change removes the locally
    defined constants and substitutes the kernel's constants.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Reviewed-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index f425975fbcbc..7935ba56bb1d 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -847,7 +847,7 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 				   priv->aplist.ap[i].bssid, ETH_ALEN) != 0)
 				continue;
 
-			if (ap_info->frame_type == FRAME_TYPE_PROBE_RESP)
+			if (ap_info->frame_type == IEEE80211_STYPE_PROBE_RESP)
 				get_ap_information(priv, ap_info,
 						   &priv->aplist.ap[i]);
 			return;

commit c468d584cd687386c33f730b7c5114501f731e85
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Wed Feb 28 21:19:10 2018 -0800

    staging: ks7010: Replace local capability constants with kernel constants.
    
    This driver defined constants BSS_CAP_* to represent WLAN capability
    codes; however, these constants are already defined in the header
    'linux/ieee80211.h' as WLAN_CAPABILITY_*.  This change removes the locally
    defined constants and substitutes the kernel's constants.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Reviewed-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 4d11627a3d72..f425975fbcbc 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1386,14 +1386,14 @@ static __le16 ks_wlan_cap(struct ks_wlan_private *priv)
 	u16 capability = 0x0000;
 
 	if (priv->reg.preamble == SHORT_PREAMBLE) {
-		capability |= BSS_CAP_SHORT_PREAMBLE;
+		capability |= WLAN_CAPABILITY_SHORT_PREAMBLE;
 	}
 
-	capability &= ~(BSS_CAP_PBCC);	/* pbcc not support */
+	capability &= ~(WLAN_CAPABILITY_PBCC);	/* pbcc not support */
 
 	if (priv->reg.phy_type != D_11B_ONLY_MODE) {
-		capability |= BSS_CAP_SHORT_SLOT_TIME;
-		capability &= ~(BSS_CAP_DSSS_OFDM);
+		capability |= WLAN_CAPABILITY_SHORT_SLOT_TIME;
+		capability &= ~(WLAN_CAPABILITY_DSSS_OFDM);
 	}
 
 	return cpu_to_le16((uint16_t)capability);

commit ecad5e1e2012b0986ac398d506379265eb436ba2
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Wed Feb 28 21:19:09 2018 -0800

    staging: ks7010: Factor out repeated code into function 'ks_wlan_cap()'.
    
    The code that generates a WLAN capability mask is repeated in five
    functions.  This change refactors that code into a new function, which is
    called now in each of those functions.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Reviewed-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 59f7c4e422d3..4d11627a3d72 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1381,11 +1381,28 @@ void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 	priv->scan_ind_count = 0;
 }
 
+static __le16 ks_wlan_cap(struct ks_wlan_private *priv)
+{
+	u16 capability = 0x0000;
+
+	if (priv->reg.preamble == SHORT_PREAMBLE) {
+		capability |= BSS_CAP_SHORT_PREAMBLE;
+	}
+
+	capability &= ~(BSS_CAP_PBCC);	/* pbcc not support */
+
+	if (priv->reg.phy_type != D_11B_ONLY_MODE) {
+		capability |= BSS_CAP_SHORT_SLOT_TIME;
+		capability &= ~(BSS_CAP_DSSS_OFDM);
+	}
+
+	return cpu_to_le16((uint16_t)capability);
+}
+
 static
 void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 {
 	struct hostif_ps_adhoc_set_request_t *pp;
-	u16 capability;
 
 	DPRINTK(3, "\n");
 
@@ -1398,21 +1415,10 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
 	pp->channel = cpu_to_le16((uint16_t)(priv->reg.channel));
 	pp->rate_set.size = priv->reg.rate_set.size;
+	pp->capability = ks_wlan_cap(priv);
 	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
 	       priv->reg.rate_set.size);
 
-	capability = 0x0000;
-	if (priv->reg.preamble == SHORT_PREAMBLE) {
-		/* short preamble */
-		capability |= BSS_CAP_SHORT_PREAMBLE;
-	}
-	capability &= ~(BSS_CAP_PBCC);	/* pbcc not support */
-	if (priv->reg.phy_type != D_11B_ONLY_MODE) {
-		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
-		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM */
-	}
-	pp->capability = cpu_to_le16((uint16_t)capability);
-
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
 	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
@@ -1422,7 +1428,6 @@ static
 void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 {
 	struct hostif_infrastructure_set_request_t *pp;
-	u16 capability;
 
 	DPRINTK(3, "ssid.size=%d\n", priv->reg.ssid.size);
 
@@ -1439,18 +1444,7 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 	       priv->reg.rate_set.size);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
-
-	capability = 0x0000;
-	if (priv->reg.preamble == SHORT_PREAMBLE) {
-		/* short preamble */
-		capability |= BSS_CAP_SHORT_PREAMBLE;
-	}
-	capability &= ~(BSS_CAP_PBCC);	/* pbcc not support */
-	if (priv->reg.phy_type != D_11B_ONLY_MODE) {
-		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
-		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
-	}
-	pp->capability = cpu_to_le16((uint16_t)capability);
+	pp->capability = ks_wlan_cap(priv);
 	pp->beacon_lost_count =
 	    cpu_to_le16((uint16_t)(priv->reg.beacon_lost_count));
 	pp->auth_type = cpu_to_le16((uint16_t)(priv->reg.authenticate_type));
@@ -1483,7 +1477,6 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 {
 	struct hostif_infrastructure_set2_request_t *pp;
-	u16 capability;
 
 	DPRINTK(2, "ssid.size=%d\n", priv->reg.ssid.size);
 
@@ -1500,18 +1493,7 @@ static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 	       priv->reg.rate_set.size);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
-
-	capability = 0x0000;
-	if (priv->reg.preamble == SHORT_PREAMBLE) {
-		/* short preamble */
-		capability |= BSS_CAP_SHORT_PREAMBLE;
-	}
-	capability &= ~(BSS_CAP_PBCC);	/* pbcc not support */
-	if (priv->reg.phy_type != D_11B_ONLY_MODE) {
-		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
-		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
-	}
-	pp->capability = cpu_to_le16((uint16_t)capability);
+	pp->capability = ks_wlan_cap(priv);
 	pp->beacon_lost_count =
 	    cpu_to_le16((uint16_t)(priv->reg.beacon_lost_count));
 	pp->auth_type = cpu_to_le16((uint16_t)(priv->reg.authenticate_type));
@@ -1547,7 +1529,6 @@ static
 void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 {
 	struct hostif_adhoc_set_request_t *pp;
-	u16 capability;
 
 	DPRINTK(3, "\n");
 
@@ -1564,18 +1545,7 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 	       priv->reg.rate_set.size);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
-
-	capability = 0x0000;
-	if (priv->reg.preamble == SHORT_PREAMBLE) {
-		/* short preamble */
-		capability |= BSS_CAP_SHORT_PREAMBLE;
-	}
-	capability &= ~(BSS_CAP_PBCC);	/* pbcc not support */
-	if (priv->reg.phy_type != D_11B_ONLY_MODE) {
-		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
-		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
-	}
-	pp->capability = cpu_to_le16((uint16_t)capability);
+	pp->capability = ks_wlan_cap(priv);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1586,7 +1556,6 @@ static
 void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 {
 	struct hostif_adhoc_set2_request_t *pp;
-	u16 capability;
 
 	DPRINTK(3, "\n");
 
@@ -1602,18 +1571,7 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 	       priv->reg.rate_set.size);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
-
-	capability = 0x0000;
-	if (priv->reg.preamble == SHORT_PREAMBLE) {
-		/* short preamble */
-		capability |= BSS_CAP_SHORT_PREAMBLE;
-	}
-	capability &= ~(BSS_CAP_PBCC);	/* pbcc not support */
-	if (priv->reg.phy_type != D_11B_ONLY_MODE) {
-		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
-		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
-	}
-	pp->capability = cpu_to_le16((uint16_t)capability);
+	pp->capability = ks_wlan_cap(priv);
 
 	pp->channel_list.body[0] = priv->reg.channel;
 	pp->channel_list.size = 1;

commit 15b6d73eaa7c35f52feb797e3e35a6477b41a624
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Wed Feb 28 21:19:08 2018 -0800

    staging: ks7010: Replace SSID_MAX_SIZE with IEEE80211_MAX_SSID_LEN.
    
    SSID_MAX_SIZE is a constant defined locally in ks_hostif.h, but it should
    be replaced with IEEE80211_MAX_SSID_LEN from the kernel's 802.11 header,
    of which it is just a copy.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Reviewed-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 67cf32433023..59f7c4e422d3 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -253,12 +253,12 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 	while (bsize > offset) {
 		switch (*bp) { /* Information Element ID */
 		case WLAN_EID_SSID:
-			if (*(bp + 1) <= SSID_MAX_SIZE) {
+			if (*(bp + 1) <= IEEE80211_MAX_SSID_LEN) {
 				ap->ssid.size = *(bp + 1);
 			} else {
 				DPRINTK(1, "size over :: ssid size=%d\n",
 					*(bp + 1));
-				ap->ssid.size = SSID_MAX_SIZE;
+				ap->ssid.size = IEEE80211_MAX_SSID_LEN;
 			}
 			memcpy(ap->ssid.body, bp + 2, ap->ssid.size);
 			break;

commit dc13498ab47fdfae3cda4df712beb2e4244b3fe0
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Wed Feb 28 21:19:07 2018 -0800

    staging: ks7010: Use constants from ieee80211_eid instead of literal ints.
    
    The case statement in get_ap_information() should not use literal integers
    to parse information element IDs when these values are provided by name
    in 'enum ieee80211_eid' in the header 'linux/ieee80211.h'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Reviewed-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 74a08417bd0b..67cf32433023 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -251,9 +251,8 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 	offset = 0;
 
 	while (bsize > offset) {
-		/* DPRINTK(4, "Element ID=%d\n",*bp); */
-		switch (*bp) {
-		case 0:	/* ssid */
+		switch (*bp) { /* Information Element ID */
+		case WLAN_EID_SSID:
 			if (*(bp + 1) <= SSID_MAX_SIZE) {
 				ap->ssid.size = *(bp + 1);
 			} else {
@@ -263,8 +262,8 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 			}
 			memcpy(ap->ssid.body, bp + 2, ap->ssid.size);
 			break;
-		case 1:	/* rate */
-		case 50:	/* ext rate */
+		case WLAN_EID_SUPP_RATES:
+		case WLAN_EID_EXT_SUPP_RATES:
 			if ((*(bp + 1) + ap->rate_set.size) <=
 			    RATE_SET_MAX_SIZE) {
 				memcpy(&ap->rate_set.body[ap->rate_set.size],
@@ -280,9 +279,9 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 				    (RATE_SET_MAX_SIZE - ap->rate_set.size);
 			}
 			break;
-		case 3:	/* DS parameter */
+		case WLAN_EID_DS_PARAMS:
 			break;
-		case 48:	/* RSN(WPA2) */
+		case WLAN_EID_RSN:
 			ap->rsn_ie.id = *bp;
 			if (*(bp + 1) <= RSN_IE_BODY_MAX) {
 				ap->rsn_ie.size = *(bp + 1);
@@ -293,8 +292,8 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 			}
 			memcpy(ap->rsn_ie.body, bp + 2, ap->rsn_ie.size);
 			break;
-		case 221:	/* WPA */
-			if (memcmp(bp + 2, "\x00\x50\xf2\x01", 4) == 0) {	/* WPA OUI check */
+		case WLAN_EID_VENDOR_SPECIFIC: /* WPA */
+			if (memcmp(bp + 2, "\x00\x50\xf2\x01", 4) == 0) { /* WPA OUI check */
 				ap->wpa_ie.id = *bp;
 				if (*(bp + 1) <= RSN_IE_BODY_MAX) {
 					ap->wpa_ie.size = *(bp + 1);
@@ -309,18 +308,18 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 			}
 			break;
 
-		case 2:	/* FH parameter */
-		case 4:	/* CF parameter */
-		case 5:	/* TIM */
-		case 6:	/* IBSS parameter */
-		case 7:	/* Country */
-		case 42:	/* ERP information */
-		case 47:	/* Reserve ID 47 Broadcom AP */
+		case WLAN_EID_FH_PARAMS:
+		case WLAN_EID_CF_PARAMS:
+		case WLAN_EID_TIM:
+		case WLAN_EID_IBSS_PARAMS:
+		case WLAN_EID_COUNTRY:
+		case WLAN_EID_ERP_INFO:
 			break;
 		default:
 			DPRINTK(4, "unknown Element ID=%d\n", *bp);
 			break;
 		}
+
 		offset += 2;	/* id & size field */
 		offset += *(bp + 1);	/* +size offset */
 		bp += (*(bp + 1) + 2);	/* pointer update */

commit b6520468c4078ca25c0cda43e3e543112d87c98a
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Mon Feb 19 22:35:38 2018 -0800

    Staging: ks7010: hostif: Convert the ps_confirm_wait_inc() macro to a real function.
    
    Convert the unsafe macro into an inline function.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index f554477fe6bc..74a08417bd0b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1308,11 +1308,11 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	return ret;
 }
 
-#define ps_confirm_wait_inc(priv)					 \
-	do {								 \
-		if (atomic_read(&priv->psstatus.status) > PS_ACTIVE_SET) \
-			atomic_inc(&priv->psstatus.confirm_wait);	 \
-	} while (0)
+static inline void ps_confirm_wait_inc(struct ks_wlan_private *priv)
+{
+	if (atomic_read(&priv->psstatus.status) > PS_ACTIVE_SET)
+		atomic_inc(&priv->psstatus.confirm_wait);
+}
 
 static
 void hostif_mib_get_request(struct ks_wlan_private *priv,

commit e4281f385b28d716493f6666db13e61849d6f798
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Mon Feb 19 22:35:37 2018 -0800

    Staging: ks7010: hostif: Convert SME queue macros to real functions.
    
    Convert the unsafe macros into inline functions.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 975dbbb3abd0..f554477fe6bc 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -21,13 +21,22 @@
 /* Include Wireless Extension definition and check version */
 #include <net/iw_handler.h>	/* New driver API */
 
-/* macro */
-#define inc_smeqhead(priv) \
-	(priv->sme_i.qhead = (priv->sme_i.qhead + 1) % SME_EVENT_BUFF_SIZE)
-#define inc_smeqtail(priv) \
-	(priv->sme_i.qtail = (priv->sme_i.qtail + 1) % SME_EVENT_BUFF_SIZE)
-#define cnt_smeqbody(priv) \
-	(((priv->sme_i.qtail + SME_EVENT_BUFF_SIZE) - (priv->sme_i.qhead)) % SME_EVENT_BUFF_SIZE)
+static inline void inc_smeqhead(struct ks_wlan_private *priv)
+{
+	priv->sme_i.qhead = (priv->sme_i.qhead + 1) % SME_EVENT_BUFF_SIZE;
+}
+
+static inline void inc_smeqtail(struct ks_wlan_private *priv)
+{
+	priv->sme_i.qtail = (priv->sme_i.qtail + 1) % SME_EVENT_BUFF_SIZE;
+}
+
+static inline unsigned int cnt_smeqbody(struct ks_wlan_private *priv)
+{
+	unsigned int sme_cnt = priv->sme_i.qtail - priv->sme_i.qhead;
+
+	return (sme_cnt + SME_EVENT_BUFF_SIZE) % SME_EVENT_BUFF_SIZE;
+}
 
 #define KS_WLAN_MEM_FLAG (GFP_ATOMIC)
 

commit d894e25b5265d5999dc0ac12ee6b047773c7be3a
Author: Jonathan Whitaker <jon.b.whitaker@gmail.com>
Date:   Mon Aug 28 17:35:22 2017 -0600

    Staging: ks7010: Fix alignment should match open parenthesis.
    
    This commit fixes alignment styling as reported by checkpatch.pl.
    
    Signed-off-by: Jonathan Whitaker <jon.b.whitaker@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 24a63161f92c..975dbbb3abd0 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1658,8 +1658,8 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 
 static
 void hostif_power_mgmt_request(struct ks_wlan_private *priv,
-				unsigned long mode, unsigned long wake_up,
-				unsigned long receive_dtims)
+			       unsigned long mode, unsigned long wake_up,
+			       unsigned long receive_dtims)
 {
 	struct hostif_power_mgmt_request_t *pp;
 

commit 5518b69b76680a4f2df96b1deca260059db0c2de
Merge: 8ad06e56dcbc 0e72582270c0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 5 12:31:59 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
     "Reasonably busy this cycle, but perhaps not as busy as in the 4.12
      merge window:
    
       1) Several optimizations for UDP processing under high load from
          Paolo Abeni.
    
       2) Support pacing internally in TCP when using the sch_fq packet
          scheduler for this is not practical. From Eric Dumazet.
    
       3) Support mutliple filter chains per qdisc, from Jiri Pirko.
    
       4) Move to 1ms TCP timestamp clock, from Eric Dumazet.
    
       5) Add batch dequeueing to vhost_net, from Jason Wang.
    
       6) Flesh out more completely SCTP checksum offload support, from
          Davide Caratti.
    
       7) More plumbing of extended netlink ACKs, from David Ahern, Pablo
          Neira Ayuso, and Matthias Schiffer.
    
       8) Add devlink support to nfp driver, from Simon Horman.
    
       9) Add RTM_F_FIB_MATCH flag to RTM_GETROUTE queries, from Roopa
          Prabhu.
    
      10) Add stack depth tracking to BPF verifier and use this information
          in the various eBPF JITs. From Alexei Starovoitov.
    
      11) Support XDP on qed device VFs, from Yuval Mintz.
    
      12) Introduce BPF PROG ID for better introspection of installed BPF
          programs. From Martin KaFai Lau.
    
      13) Add bpf_set_hash helper for TC bpf programs, from Daniel Borkmann.
    
      14) For loads, allow narrower accesses in bpf verifier checking, from
          Yonghong Song.
    
      15) Support MIPS in the BPF selftests and samples infrastructure, the
          MIPS eBPF JIT will be merged in via the MIPS GIT tree. From David
          Daney.
    
      16) Support kernel based TLS, from Dave Watson and others.
    
      17) Remove completely DST garbage collection, from Wei Wang.
    
      18) Allow installing TCP MD5 rules using prefixes, from Ivan
          Delalande.
    
      19) Add XDP support to Intel i40e driver, from Björn Töpel
    
      20) Add support for TC flower offload in nfp driver, from Simon
          Horman, Pieter Jansen van Vuuren, Benjamin LaHaise, Jakub
          Kicinski, and Bert van Leeuwen.
    
      21) IPSEC offloading support in mlx5, from Ilan Tayari.
    
      22) Add HW PTP support to macb driver, from Rafal Ozieblo.
    
      23) Networking refcount_t conversions, From Elena Reshetova.
    
      24) Add sock_ops support to BPF, from Lawrence Brako. This is useful
          for tuning the TCP sockopt settings of a group of applications,
          currently via CGROUPs"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1899 commits)
      net: phy: dp83867: add workaround for incorrect RX_CTRL pin strap
      dt-bindings: phy: dp83867: provide a workaround for incorrect RX_CTRL pin strap
      cxgb4: Support for get_ts_info ethtool method
      cxgb4: Add PTP Hardware Clock (PHC) support
      cxgb4: time stamping interface for PTP
      nfp: default to chained metadata prepend format
      nfp: remove legacy MAC address lookup
      nfp: improve order of interfaces in breakout mode
      net: macb: remove extraneous return when MACB_EXT_DESC is defined
      bpf: add missing break in for the TCP_BPF_SNDCWND_CLAMP case
      bpf: fix return in load_bpf_file
      mpls: fix rtm policy in mpls_getroute
      net, ax25: convert ax25_cb.refcount from atomic_t to refcount_t
      net, ax25: convert ax25_route.refcount from atomic_t to refcount_t
      net, ax25: convert ax25_uid_assoc.refcount from atomic_t to refcount_t
      net, sctp: convert sctp_ep_common.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_transport.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_chunk.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_datamsg.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_auth_bytes.refcnt from atomic_t to refcount_t
      ...

commit 59ae1d127ac0ae404baf414c434ba2651b793f46
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:20 2017 +0200

    networking: introduce and use skb_put_data()
    
    A common pattern with skb_put() is to just want to memcpy()
    some data into the new space, introduce skb_put_data() for
    this.
    
    An spatch similar to the one for skb_put_zero() converts many
    of the places using it:
    
        @@
        identifier p, p2;
        expression len, skb, data;
        type t, t2;
        @@
        (
        -p = skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        |
        -p = (t)skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, len);
        |
        -memcpy(p, data, len);
        )
    
        @@
        type t, t2;
        identifier p, p2;
        expression skb, data;
        @@
        t *p;
        ...
        (
        -p = skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        |
        -p = (t *)skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, sizeof(*p));
        |
        -memcpy(p, data, sizeof(*p));
        )
    
        @@
        expression skb, len, data;
        @@
        -memcpy(skb_put(skb, len), data, len);
        +skb_put_data(skb, data, len);
    
    (again, manually post-processed to retain some comments)
    
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 49e95426ac30..da801d3e0585 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -466,12 +466,12 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 		DPRINTK(4, "SNAP, rx_ind_size = %d\n", rx_ind_size);
 
 		size = ETH_ALEN * 2;
-		memcpy(skb_put(skb, size), priv->rxp, size);
+		skb_put_data(skb, priv->rxp, size);
 
 		/* (SNAP+UI..) skip */
 
 		size = rx_ind_size - (ETH_ALEN * 2);
-		memcpy(skb_put(skb, size), &eth_hdr->h_proto, size);
+		skb_put_data(skb, &eth_hdr->h_proto, size);
 
 		aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + ETHER_HDR_SIZE);
 		break;
@@ -484,14 +484,13 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 		}
 		DPRINTK(3, "NETBEUI/NetBIOS rx_ind_size=%d\n", rx_ind_size);
 
-		memcpy(skb_put(skb, 12), priv->rxp, 12);	/* 8802/FDDI MAC copy */
+		skb_put_data(skb, priv->rxp, 12);	/* 8802/FDDI MAC copy */
 
 		temp[0] = (((rx_ind_size - 12) >> 8) & 0xff);	/* NETBEUI size add */
 		temp[1] = ((rx_ind_size - 12) & 0xff);
-		memcpy(skb_put(skb, 2), temp, 2);
+		skb_put_data(skb, temp, 2);
 
-		memcpy(skb_put(skb, rx_ind_size - 14), priv->rxp + 12,
-		       rx_ind_size - 14);	/* copy after Type */
+		skb_put_data(skb, priv->rxp + 12, rx_ind_size - 14);	/* copy after Type */
 
 		aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 14);
 		break;

commit f6e8716a3acb7e9e8396450b359ce04f128e0e79
Author: Perry Hooker <perry.hooker@gmail.com>
Date:   Thu Jun 8 23:06:54 2017 -0600

    staging: ks7010: use little-endian types
    
    This patch fixes a number of sparse warnings of the form:
    drivers/staging/ks7010/ks_hostif.c:2187:29:
            warning: incorrect type in assignment (different base types)
    generated when storing little-endian data in variables
    that do not have a specified endianness.
    
    Signed-off-by: Perry Hooker <perry.hooker@gmail.com>
    Reviewed-By: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 697347bb8760..db01a486a5a4 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1821,7 +1821,7 @@ void hostif_receive(struct ks_wlan_private *priv, unsigned char *p,
 static
 void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 {
-	u32 val;
+	__le32 val;
 
 	switch (type) {
 	case SME_WEP_INDEX_REQUEST:
@@ -1870,13 +1870,13 @@ void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 }
 
 struct wpa_suite_t {
-	unsigned short size;
+	__le16 size;
 	unsigned char suite[4][CIPHER_ID_LEN];
 } __packed;
 
 struct rsn_mode_t {
-	u32 rsn_mode;
-	u16 rsn_capability;
+	__le32 rsn_mode;
+	__le16 rsn_capability;
 } __packed;
 
 static
@@ -1884,7 +1884,7 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 {
 	struct wpa_suite_t wpa_suite;
 	struct rsn_mode_t rsn_mode;
-	u32 val;
+	__le32 val;
 
 	memset(&wpa_suite, 0, sizeof(wpa_suite));
 
@@ -1936,7 +1936,8 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 
 		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_UNICAST_CIPHER,
 				       sizeof(wpa_suite.size) +
-				       CIPHER_ID_LEN * wpa_suite.size,
+				       CIPHER_ID_LEN *
+				       le16_to_cpu(wpa_suite.size),
 				       MIB_VALUE_TYPE_OSTRING, &wpa_suite);
 		break;
 	case SME_RSN_MCAST_REQUEST:
@@ -2028,7 +2029,8 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 
 		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_AUTH_SUITE,
 				       sizeof(wpa_suite.size) +
-				       KEY_MGMT_ID_LEN * wpa_suite.size,
+				       KEY_MGMT_ID_LEN *
+				       le16_to_cpu(wpa_suite.size),
 				       MIB_VALUE_TYPE_OSTRING, &wpa_suite);
 		break;
 	case SME_RSN_ENABLED_REQUEST:
@@ -2165,7 +2167,7 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 	int mc_count;
 	struct netdev_hw_addr *ha;
 	char set_address[NIC_MAX_MCAST_LIST * ETH_ALEN];
-	unsigned long filter_type;
+	__le32 filter_type;
 	int i = 0;
 
 	DPRINTK(3, "\n");
@@ -2276,7 +2278,7 @@ void hostif_sme_sleep_set(struct ks_wlan_private *priv)
 static
 void hostif_sme_set_key(struct ks_wlan_private *priv, int type)
 {
-	u32 val;
+	__le32 val;
 
 	switch (type) {
 	case SME_SET_FLAG:
@@ -2335,7 +2337,7 @@ static
 void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 {
 	struct pmk_cache_t {
-		u16 size;
+		__le16 size;
 		struct {
 			u8 bssid[ETH_ALEN];
 			u8 pmkid[IW_PMKID_LEN];
@@ -2366,7 +2368,7 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 static
 void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 {
-	u32 val;
+	__le32 val;
 
 	DPRINTK(3, "event=%d\n", event);
 	switch (event) {

commit 9f98c6e67ffd1961884e70023a33e81730cd7fcb
Author: Richard Porter <dick@acm.org>
Date:   Sun Jun 4 11:10:12 2017 +0100

    staging: ks7010: use le16_to_cpu() to access __le16 field
    
    Fixes sparse warning:
    drivers/staging/ks7010/ks_hostif.c:959:24: warning: restricted __le16
    degrades to integer
    
    Signed-off-by: Richard Porter <dick@acm.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 79634be1b873..697347bb8760 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -956,7 +956,7 @@ void hostif_associate_indication(struct ks_wlan_private *priv)
 	wrqu.data.length += sizeof(associnfo_leader1) - 1;
 	pbuf += sizeof(associnfo_leader1) - 1;
 
-	pb += assoc_req->req_ies_size;
+	pb += le16_to_cpu(assoc_req->req_ies_size);
 	for (i = 0; i < le16_to_cpu(assoc_resp->resp_ies_size); i++)
 		pbuf += sprintf(pbuf, "%02x", *(pb + i));
 	wrqu.data.length += (le16_to_cpu(assoc_resp->resp_ies_size)) * 2;

commit 16bd2c482c328e58ba50c0b03f41b885699208c4
Author: Janusz Lisiecki <janusz.lisiecki@gmail.com>
Date:   Tue May 16 17:34:57 2017 +0200

    staging: ks7010: avoid CamelCase: receiveDTIMs
    
    Replace CamelCase variable name with underscores to comply
    with the standard kernel coding style.
    
    Signed-off-by: Janusz Lisiecki <janusz.lisiecki@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index d9161be71f4a..79634be1b873 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1659,13 +1659,13 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 
 static
 void hostif_power_mgmt_request(struct ks_wlan_private *priv,
-			       unsigned long mode, unsigned long wake_up,
-			       unsigned long receiveDTIMs)
+				unsigned long mode, unsigned long wake_up,
+				unsigned long receive_dtims)
 {
 	struct hostif_power_mgmt_request_t *pp;
 
-	DPRINTK(3, "mode=%lu wake_up=%lu receiveDTIMs=%lu\n", mode, wake_up,
-		receiveDTIMs);
+	DPRINTK(3, "mode=%lu wake_up=%lu receive_dtims=%lu\n", mode, wake_up,
+		receive_dtims);
 
 	pp = hostif_generic_request(sizeof(*pp), HIF_POWER_MGMT_REQ);
 	if (!pp)
@@ -1673,7 +1673,7 @@ void hostif_power_mgmt_request(struct ks_wlan_private *priv,
 
 	pp->mode = cpu_to_le32((uint32_t)mode);
 	pp->wake_up = cpu_to_le32((uint32_t)wake_up);
-	pp->receiveDTIMs = cpu_to_le32((uint32_t)receiveDTIMs);
+	pp->receive_dtims = cpu_to_le32((uint32_t)receive_dtims);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -2217,44 +2217,44 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 static
 void hostif_sme_power_mgmt_set(struct ks_wlan_private *priv)
 {
-	unsigned long mode, wake_up, receiveDTIMs;
+	unsigned long mode, wake_up, receive_dtims;
 
 	DPRINTK(3, "\n");
 	switch (priv->reg.power_mgmt) {
 	case POWER_MGMT_ACTIVE:
 		mode = POWER_ACTIVE;
 		wake_up = 0;
-		receiveDTIMs = 0;
+		receive_dtims = 0;
 		break;
 	case POWER_MGMT_SAVE1:
 		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 			mode = POWER_SAVE;
 			wake_up = 0;
-			receiveDTIMs = 0;
+			receive_dtims = 0;
 		} else {
 			mode = POWER_ACTIVE;
 			wake_up = 0;
-			receiveDTIMs = 0;
+			receive_dtims = 0;
 		}
 		break;
 	case POWER_MGMT_SAVE2:
 		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 			mode = POWER_SAVE;
 			wake_up = 0;
-			receiveDTIMs = 1;
+			receive_dtims = 1;
 		} else {
 			mode = POWER_ACTIVE;
 			wake_up = 0;
-			receiveDTIMs = 0;
+			receive_dtims = 0;
 		}
 		break;
 	default:
 		mode = POWER_ACTIVE;
 		wake_up = 0;
-		receiveDTIMs = 0;
+		receive_dtims = 0;
 		break;
 	}
-	hostif_power_mgmt_request(priv, mode, wake_up, receiveDTIMs);
+	hostif_power_mgmt_request(priv, mode, wake_up, receive_dtims);
 }
 
 static

commit 95dddaa9d1a723367409844d4e6423bcda09d582
Author: Janusz Lisiecki <janusz.lisiecki@gmail.com>
Date:   Mon May 15 20:55:46 2017 +0200

    staging: ks7010: avoid CamelCase: local variables in ks_hostif.c
    
    Replace CamelCase local variables' name with underscores to comply
    with the standard kernel coding style.
    Changed:
    - LinkSpeed
    - TransmittedFrameCount
    - ReceivedFragmentCount
    - FailedCount
    - FCSErrorCount
    
    Signed-off-by: Janusz Lisiecki <janusz.lisiecki@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index cf9b22feb451..d9161be71f4a 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -994,22 +994,22 @@ void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 {
 	struct iw_statistics *wstats = &priv->wstats;
 	unsigned char rssi, signal, noise;
-	unsigned char LinkSpeed;
-	unsigned int TransmittedFrameCount, ReceivedFragmentCount;
-	unsigned int FailedCount, FCSErrorCount;
+	unsigned char link_speed;
+	unsigned int transmitted_frame_count, received_fragment_count;
+	unsigned int failed_count, fcs_error_count;
 
 	DPRINTK(3, "\n");
 	rssi = get_BYTE(priv);
 	signal = get_BYTE(priv);
 	noise = get_BYTE(priv);
-	LinkSpeed = get_BYTE(priv);
-	TransmittedFrameCount = get_DWORD(priv);
-	ReceivedFragmentCount = get_DWORD(priv);
-	FailedCount = get_DWORD(priv);
-	FCSErrorCount = get_DWORD(priv);
+	link_speed = get_BYTE(priv);
+	transmitted_frame_count = get_DWORD(priv);
+	received_fragment_count = get_DWORD(priv);
+	failed_count = get_DWORD(priv);
+	fcs_error_count = get_DWORD(priv);
 
 	DPRINTK(4, "phyinfo confirm rssi=%d signal=%d\n", rssi, signal);
-	priv->current_rate = (LinkSpeed & RATE_MASK);
+	priv->current_rate = (link_speed & RATE_MASK);
 	wstats->qual.qual = signal;
 	wstats->qual.level = 256 - rssi;
 	wstats->qual.noise = 0;	/* invalid noise value */
@@ -1017,14 +1017,13 @@ void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 
 	DPRINTK(3, "\n    rssi=%u\n"
 		   "    signal=%u\n"
-		   "    LinkSpeed=%ux500Kbps\n"
-		   "    TransmittedFrameCount=%u\n"
-		   "    ReceivedFragmentCount=%u\n"
-		   "    FailedCount=%u\n"
-		   "    FCSErrorCount=%u\n",
-		rssi, signal, LinkSpeed, TransmittedFrameCount,
-		ReceivedFragmentCount, FailedCount, FCSErrorCount);
-
+		   "    link_speed=%ux500Kbps\n"
+		   "    transmitted_frame_count=%u\n"
+		   "    received_fragment_count=%u\n"
+		   "    failed_count=%u\n"
+		   "    fcs_error_count=%u\n",
+		rssi, signal, link_speed, transmitted_frame_count,
+		received_fragment_count, failed_count, fcs_error_count);
 	/* wake_up_interruptible_all(&priv->confirm_wait); */
 	complete(&priv->confirm_wait);
 }

commit 683356d16b0f5f97058e2377590bf365fdc97d79
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon May 8 14:29:43 2017 +1000

    staging: ks7010: hostif, u16 data types to __le16
    
    Target device is little endian. Host interface data structures used
    for building frames to pass to target device should use little endian
    data types. All u16 structure members in ks_hostif.h need to be
    changed to __le16, Sparse can then be used to make sure we update all
    code that touches these data.
    
    Change all u16 data types in host interface structures to be
    __le16. Update all code that touches modified data types. Check using
    Sparse.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index caf2551bc087..cf9b22feb451 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -147,7 +147,7 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	/* noise */
 	ap->noise = ap_info->noise;
 	/* capability */
-	ap->capability = ap_info->capability;
+	ap->capability = le16_to_cpu(ap_info->capability);
 	/* rsn */
 	if ((ap_info->rsn_mode & RSN_MODE_WPA2) &&
 	    (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)) {
@@ -233,12 +233,12 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 	/* noise */
 	ap->noise = ap_info->noise;
 	/* capability */
-	ap->capability = ap_info->capability;
+	ap->capability = le16_to_cpu(ap_info->capability);
 	/* channel */
 	ap->channel = ap_info->ch_info;
 
 	bp = ap_info->body;
-	bsize = ap_info->body_size;
+	bsize = le16_to_cpu(ap_info->body_size);
 	offset = 0;
 
 	while (bsize > offset) {
@@ -948,18 +948,18 @@ void hostif_associate_indication(struct ks_wlan_private *priv)
 	wrqu.data.length += sizeof(associnfo_leader0) - 1;
 	pbuf += sizeof(associnfo_leader0) - 1;
 
-	for (i = 0; i < assoc_req->req_ies_size; i++)
+	for (i = 0; i < le16_to_cpu(assoc_req->req_ies_size); i++)
 		pbuf += sprintf(pbuf, "%02x", *(pb + i));
-	wrqu.data.length += (assoc_req->req_ies_size) * 2;
+	wrqu.data.length += (le16_to_cpu(assoc_req->req_ies_size)) * 2;
 
 	memcpy(pbuf, associnfo_leader1, sizeof(associnfo_leader1) - 1);
 	wrqu.data.length += sizeof(associnfo_leader1) - 1;
 	pbuf += sizeof(associnfo_leader1) - 1;
 
 	pb += assoc_req->req_ies_size;
-	for (i = 0; i < assoc_resp->resp_ies_size; i++)
+	for (i = 0; i < le16_to_cpu(assoc_resp->resp_ies_size); i++)
 		pbuf += sprintf(pbuf, "%02x", *(pb + i));
-	wrqu.data.length += (assoc_resp->resp_ies_size) * 2;
+	wrqu.data.length += (le16_to_cpu(assoc_resp->resp_ies_size)) * 2;
 
 	pbuf += sprintf(pbuf, ")");
 	wrqu.data.length += 1;

commit 1d6c26224b8346efb8b08b8c1d6bc6bf58c5d2bf
Author: Janusz Lisiecki <janusz.lisiecki@gmail.com>
Date:   Sat Apr 29 22:58:47 2017 +0200

    staging: ks7010: avoid CamelCase: reqIEs_size and respIEs_size
    
    Replace CamelCase association_request_t and association_response_t
    struct field names with underscores to comply with the standard kernel
    coding style.
    
    Signed-off-by: Janusz Lisiecki <janusz.lisiecki@gmail.com>
    Reviewed-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 6d6cbe1e1f9c..caf2551bc087 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -948,18 +948,18 @@ void hostif_associate_indication(struct ks_wlan_private *priv)
 	wrqu.data.length += sizeof(associnfo_leader0) - 1;
 	pbuf += sizeof(associnfo_leader0) - 1;
 
-	for (i = 0; i < assoc_req->reqIEs_size; i++)
+	for (i = 0; i < assoc_req->req_ies_size; i++)
 		pbuf += sprintf(pbuf, "%02x", *(pb + i));
-	wrqu.data.length += (assoc_req->reqIEs_size) * 2;
+	wrqu.data.length += (assoc_req->req_ies_size) * 2;
 
 	memcpy(pbuf, associnfo_leader1, sizeof(associnfo_leader1) - 1);
 	wrqu.data.length += sizeof(associnfo_leader1) - 1;
 	pbuf += sizeof(associnfo_leader1) - 1;
 
-	pb += assoc_req->reqIEs_size;
-	for (i = 0; i < assoc_resp->respIEs_size; i++)
+	pb += assoc_req->req_ies_size;
+	for (i = 0; i < assoc_resp->resp_ies_size; i++)
 		pbuf += sprintf(pbuf, "%02x", *(pb + i));
-	wrqu.data.length += (assoc_resp->respIEs_size) * 2;
+	wrqu.data.length += (assoc_resp->resp_ies_size) * 2;
 
 	pbuf += sprintf(pbuf, ")");
 	wrqu.data.length += 1;

commit 93270634a32b2c4e5ff7c3f1987a5473b484623f
Author: Janusz Lisiecki <janusz.lisiecki@gmail.com>
Date:   Sat Apr 29 22:58:41 2017 +0200

    staging: ks7010: avoid CamelCase in fields of struct local_gain_t
    
    Replace CamelCase fields of struct with underscores to comply
    with the standard kernel coding style
    
    Signed-off-by: Janusz Lisiecki <janusz.lisiecki@gmail.com>
    Reviewed-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 49e95426ac30..6d6cbe1e1f9c 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -567,9 +567,9 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		break;
 	case LOCAL_GAIN:
 		memcpy(&priv->gain, priv->rxp, sizeof(priv->gain));
-		DPRINTK(3, "TxMode=%d, RxMode=%d, TxGain=%d, RxGain=%d\n",
-			priv->gain.TxMode, priv->gain.RxMode, priv->gain.TxGain,
-			priv->gain.RxGain);
+		DPRINTK(3, "tx_mode=%d, rx_mode=%d, tx_gain=%d, rx_gain=%d\n",
+			priv->gain.tx_mode, priv->gain.rx_mode,
+			priv->gain.tx_gain, priv->gain.rx_gain);
 		break;
 	case LOCAL_EEPROM_SUM:
 		memcpy(&priv->eeprom_sum, priv->rxp, sizeof(priv->eeprom_sum));

commit ec4d9227d79a6f0d1cedbbb8f023c92779c16551
Author: Ilia Sergachev <ilia.sergachev@unibas.ch>
Date:   Fri Apr 28 17:30:55 2017 +0200

    staging: ks7010: remove line continuations in quoted strings
    
    Checkpatch emits WARNING: Avoid line continuations in quoted strings.
    
    Remove line continuations - split strings using quotes.
    
    Signed-off-by: Ilia Sergachev <ilia.sergachev@unibas.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index a8d334a8e52c..49e95426ac30 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -191,9 +191,21 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);
 	}
 	DPRINTK(4, "\n    Link AP\n");
-	DPRINTK(4, "    bssid=%02X:%02X:%02X:%02X:%02X:%02X\n \
-   essid=%s\n    rate_set=%02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X\n    channel=%d\n \
-   rssi=%d\n    sq=%d\n    capability=%04X\n", ap->bssid[0], ap->bssid[1], ap->bssid[2], ap->bssid[3], ap->bssid[4], ap->bssid[5], &(ap->ssid.body[0]), ap->rate_set.body[0], ap->rate_set.body[1], ap->rate_set.body[2], ap->rate_set.body[3], ap->rate_set.body[4], ap->rate_set.body[5], ap->rate_set.body[6], ap->rate_set.body[7], ap->channel, ap->rssi, ap->sq, ap->capability);
+	DPRINTK(4, "    bssid=%02X:%02X:%02X:%02X:%02X:%02X\n"
+		   "    essid=%s\n"
+		   "    rate_set=%02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X\n"
+		   "    channel=%d\n"
+		   "    rssi=%d\n"
+		   "    sq=%d\n"
+		   "    capability=%04X\n",
+		ap->bssid[0], ap->bssid[1], ap->bssid[2],
+		ap->bssid[3], ap->bssid[4], ap->bssid[5],
+		&(ap->ssid.body[0]),
+		ap->rate_set.body[0], ap->rate_set.body[1],
+		ap->rate_set.body[2], ap->rate_set.body[3],
+		ap->rate_set.body[4], ap->rate_set.body[5],
+		ap->rate_set.body[6], ap->rate_set.body[7],
+		ap->channel, ap->rssi, ap->sq, ap->capability);
 	DPRINTK(4, "\n    Link AP\n    rsn.mode=%d\n    rsn.size=%d\n",
 		ap_info->rsn_mode, ap_info->rsn.size);
 	DPRINTK(4, "\n    ext_rate_set_size=%d\n    rate_set_size=%d\n",
@@ -1003,9 +1015,15 @@ void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 	wstats->qual.noise = 0;	/* invalid noise value */
 	wstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
 
-	DPRINTK(3, "\n    rssi=%u\n    signal=%u\n    LinkSpeed=%ux500Kbps\n \
-   TransmittedFrameCount=%u\n    ReceivedFragmentCount=%u\n    FailedCount=%u\n \
-   FCSErrorCount=%u\n", rssi, signal, LinkSpeed, TransmittedFrameCount, ReceivedFragmentCount, FailedCount, FCSErrorCount);
+	DPRINTK(3, "\n    rssi=%u\n"
+		   "    signal=%u\n"
+		   "    LinkSpeed=%ux500Kbps\n"
+		   "    TransmittedFrameCount=%u\n"
+		   "    ReceivedFragmentCount=%u\n"
+		   "    FailedCount=%u\n"
+		   "    FCSErrorCount=%u\n",
+		rssi, signal, LinkSpeed, TransmittedFrameCount,
+		ReceivedFragmentCount, FailedCount, FCSErrorCount);
 
 	/* wake_up_interruptible_all(&priv->confirm_wait); */
 	complete(&priv->confirm_wait);

commit 72f78682da2af5fa57f89f39d4c789123288274d
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:25 2017 +1000

    staging: ks7010: clean up macro ps_confirm_wait_inc
    
    Macro includes commented out code. Removing dead code line enables
    braces to be removed. Macro is easier to read if the code is clean.
    
    Clean up macro ps_confirm_wait_inc.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index b19583cd5d77..a8d334a8e52c 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1283,11 +1283,11 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	return ret;
 }
 
-#define ps_confirm_wait_inc(priv) do { \
-	if (atomic_read(&priv->psstatus.status) > PS_ACTIVE_SET) { \
-		atomic_inc(&priv->psstatus.confirm_wait); \
-		/* atomic_set(&priv->psstatus.status, PS_CONF_WAIT);*/ \
-	} } while (0)
+#define ps_confirm_wait_inc(priv)					 \
+	do {								 \
+		if (atomic_read(&priv->psstatus.status) > PS_ACTIVE_SET) \
+			atomic_inc(&priv->psstatus.confirm_wait);	 \
+	} while (0)
 
 static
 void hostif_mib_get_request(struct ks_wlan_private *priv,

commit e04f2ec6c3266336784919d719b12ab67edaa74a
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:24 2017 +1000

    staging: ks7010: continue from loop on unmatched mac
    
    Inside loop, code block is guarded with an 'if' statement. Instead of
    guarding the block we can invert the 'if' statement conditional and
    continue the loop. Doing so allows subsequent code indentation to be
    reduced and aids the readability of the code.
    
    Invert 'if' statement conditional, continue loop if new conditional
    evaluates to true. Reduce subsequent code indentation level. Do not
    change program logic.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index fede3823e95a..b19583cd5d77 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -825,13 +825,13 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 	if (priv->scan_ind_count) {
 		for (i = 0; i < priv->aplist.size; i++) {	/* bssid check */
 			if (memcmp(ap_info->bssid,
-				   priv->aplist.ap[i].bssid, ETH_ALEN) == 0) {
-				if (ap_info->frame_type ==
-				    FRAME_TYPE_PROBE_RESP)
-					get_ap_information(priv, ap_info,
-							   &priv->aplist.ap[i]);
-				return;
-			}
+				   priv->aplist.ap[i].bssid, ETH_ALEN) != 0)
+				continue;
+
+			if (ap_info->frame_type == FRAME_TYPE_PROBE_RESP)
+				get_ap_information(priv, ap_info,
+						   &priv->aplist.ap[i]);
+			return;
 		}
 	}
 	priv->scan_ind_count++;

commit 8fb8e05ccafaa0e09fd93d9bffd0b4037cc36317
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:22 2017 +1000

    staging: ks7010: make abbreviation mgmt uniform
    
    Driver currently uses abbreviations 'mgt' and 'mngmt' for
    'management'. Also 'power' is sometimes abbreviated to 'pow' and other
    times not. It makes the code easier to read and easier to modify if
    one abbreviation is used throughout the driver. 'mgmt' is widely
    accepted as an abbreviation of 'management'. 'power' can be spelled
    out in full, the extra two characters aids readability without an
    excessive cost.
    
    Make abbreviation of 'management' uniform across the driver, function
    names, preprocessor defined constants, and enumeration types.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 672efa3fd02b..fede3823e95a 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -712,11 +712,11 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 }
 
 static
-void hostif_power_mngmt_confirm(struct ks_wlan_private *priv)
+void hostif_power_mgmt_confirm(struct ks_wlan_private *priv)
 {
 	DPRINTK(3, "\n");
 
-	if (priv->reg.powermgt > POWMGT_ACTIVE_MODE &&
+	if (priv->reg.power_mgmt > POWER_MGMT_ACTIVE &&
 	    priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 		atomic_set(&priv->psstatus.confirm_wait, 0);
 		priv->dev_state = DEVICE_STATE_SLEEP;
@@ -1035,8 +1035,8 @@ void hostif_event_check(struct ks_wlan_private *priv)
 	case HIF_MIB_SET_CONF:
 		hostif_mib_set_confirm(priv);
 		break;
-	case HIF_POWERMGT_CONF:
-		hostif_power_mngmt_confirm(priv);
+	case HIF_POWER_MGMT_CONF:
+		hostif_power_mgmt_confirm(priv);
 		break;
 	case HIF_SLEEP_CONF:
 		hostif_sleep_confirm(priv);
@@ -1641,16 +1641,16 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 }
 
 static
-void hostif_power_mngmt_request(struct ks_wlan_private *priv,
-				unsigned long mode, unsigned long wake_up,
-				unsigned long receiveDTIMs)
+void hostif_power_mgmt_request(struct ks_wlan_private *priv,
+			       unsigned long mode, unsigned long wake_up,
+			       unsigned long receiveDTIMs)
 {
-	struct hostif_power_mngmt_request_t *pp;
+	struct hostif_power_mgmt_request_t *pp;
 
 	DPRINTK(3, "mode=%lu wake_up=%lu receiveDTIMs=%lu\n", mode, wake_up,
 		receiveDTIMs);
 
-	pp = hostif_generic_request(sizeof(*pp), HIF_POWERMGT_REQ);
+	pp = hostif_generic_request(sizeof(*pp), HIF_POWER_MGMT_REQ);
 	if (!pp)
 		return;
 
@@ -2198,18 +2198,18 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 }
 
 static
-void hostif_sme_powermgt_set(struct ks_wlan_private *priv)
+void hostif_sme_power_mgmt_set(struct ks_wlan_private *priv)
 {
 	unsigned long mode, wake_up, receiveDTIMs;
 
 	DPRINTK(3, "\n");
-	switch (priv->reg.powermgt) {
-	case POWMGT_ACTIVE_MODE:
+	switch (priv->reg.power_mgmt) {
+	case POWER_MGMT_ACTIVE:
 		mode = POWER_ACTIVE;
 		wake_up = 0;
 		receiveDTIMs = 0;
 		break;
-	case POWMGT_SAVE1_MODE:
+	case POWER_MGMT_SAVE1:
 		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 			mode = POWER_SAVE;
 			wake_up = 0;
@@ -2220,7 +2220,7 @@ void hostif_sme_powermgt_set(struct ks_wlan_private *priv)
 			receiveDTIMs = 0;
 		}
 		break;
-	case POWMGT_SAVE2_MODE:
+	case POWER_MGMT_SAVE2:
 		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 			mode = POWER_SAVE;
 			wake_up = 0;
@@ -2237,7 +2237,7 @@ void hostif_sme_powermgt_set(struct ks_wlan_private *priv)
 		receiveDTIMs = 0;
 		break;
 	}
-	hostif_power_mngmt_request(priv, mode, wake_up, receiveDTIMs);
+	hostif_power_mgmt_request(priv, mode, wake_up, receiveDTIMs);
 }
 
 static
@@ -2370,7 +2370,7 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 					priv->scan_ssid, priv->scan_ssid_len);
 		break;
 	case SME_POW_MNGMT_REQUEST:
-		hostif_sme_powermgt_set(priv);
+		hostif_sme_power_mgmt_set(priv);
 		break;
 	case SME_PHY_INFO_REQUEST:
 		hostif_phy_information_request(priv);

commit 27476f01d311ebbb4847f32f8258f2be25d8aea6
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:21 2017 +1000

    staging: ks7010: fix checkpatch LINE_SPACING
    
    Checkpatch emits CHECK: Please don't use multiple blank lines.
    
    Remove multiple blank lines.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 81419227ea54..672efa3fd02b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1217,7 +1217,6 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 		}
 	}
 
-
 	if (priv->wpa.rsn_enabled && priv->wpa.key[0].key_len) {
 		if (eth_proto == ETHER_PROTOCOL_TYPE_EAP &&
 		    priv->wpa.key[1].key_len == 0 &&

commit 63c31af3e5efa8ebe0aaa60de183fb94989420f8
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:20 2017 +1000

    staging: ks7010: add enum sleep_mode_type
    
    Driver uses preprocessor directives to define SLP_ASLEEP and
    SLP_ACTIVE. These can be defined using an enumeration type. Doing so
    adds to the readability and gives the usual compiler benefits of
    having an enum. Functions that currently accept integer types can now
    use the new enumeration type, further aiding readability.
    
    Add enumeration type sleep_mode_type. Update code that handles sleep
    mode to use the new enumeration type.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 3f2fd6cde4eb..81419227ea54 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1665,11 +1665,12 @@ void hostif_power_mngmt_request(struct ks_wlan_private *priv,
 }
 
 static
-void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
+void hostif_sleep_request(struct ks_wlan_private *priv,
+			  enum sleep_mode_type mode)
 {
 	struct hostif_sleep_request_t *pp;
 
-	DPRINTK(3, "mode=%lu\n", mode);
+	DPRINTK(3, "mode=%lu\n", (long)mode);
 
 	if (mode == SLP_SLEEP) {
 		pp = hostif_generic_request(sizeof(*pp), HIF_SLEEP_REQ);
@@ -1684,7 +1685,7 @@ void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
 		atomic_set(&priv->sleepstatus.wakeup_request, 1);
 		queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 	} else {
-		DPRINTK(3, "invalid mode %ld\n", mode);
+		DPRINTK(3, "invalid mode %ld\n", (long)mode);
 		return;
 	}
 }

commit 0e24eb8abf93a2e80ecbe97419d2d1fe089a7386
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:19 2017 +1000

    staging: ks7010: abstract connection status
    
    Host interface connection status is handled using a 32 bit type. Top
    byte is used as for FORCE_DISCONNECT status, low bits are used for
    connect/disconnect status. Driver masks and checks integers to
    ascertain status. If functions are defined to do the masking and
    equality check then the details of how the status integer is used are
    abstracted away. This makes the code easier to read. Also future
    updates to the status handling will be easier because the code is in
    one place.
    
    Driver currently uses the CONNECT_STATUS and DISCONNECT_STATUS as
    values, as apposed to opaque values. Because of this driver code
    checks for equality with CONNECT_STATUS and DISCONNECT_STATUS as
    apposed to negating a single check (ie 'foo != CONNECT_STATUS). In
    order to maintain the current functionality we define two separate
    functions is_connect_status() and is_disconnect_status().
    
    Add functions to abstract the status integer check. Update all sites
    that do the check manually to use the newly defined functions.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 48210295b2d8..3f2fd6cde4eb 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -99,7 +99,7 @@ int ks_wlan_do_power_save(struct ks_wlan_private *priv)
 {
 	DPRINTK(4, "psstatus.status=%d\n", atomic_read(&priv->psstatus.status));
 
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS)
+	if (is_connect_status(priv->connect_status))
 		hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
 	else
 		priv->dev_state = DEVICE_STATE_READY;
@@ -116,7 +116,7 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	DPRINTK(3, "\n");
 	ap = &priv->current_ap;
 
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS) {
+	if (is_disconnect_status(priv->connect_status)) {
 		memset(ap, 0, sizeof(struct local_ap_t));
 		return -EPERM;
 	}
@@ -183,7 +183,7 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	wrqu.data.length = 0;
 	wrqu.data.flags = 0;
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
+	if (is_connect_status(priv->connect_status)) {
 		memcpy(wrqu.ap_addr.sa_data,
 		       priv->current_ap.bssid, ETH_ALEN);
 		DPRINTK(3,
@@ -744,7 +744,7 @@ void hostif_start_confirm(struct ks_wlan_private *priv)
 	wrqu.data.length = 0;
 	wrqu.data.flags = 0;
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
+	if (is_connect_status(priv->connect_status)) {
 		eth_zero_addr(wrqu.ap_addr.sa_data);
 		DPRINTK(3, "IWEVENT: disconnect\n");
 		wireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);
@@ -791,8 +791,8 @@ void hostif_connect_indication(struct ks_wlan_private *priv)
 	}
 
 	get_current_ap(priv, (struct link_ap_info_t *)priv->rxp);
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS &&
-	    (old_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS) {
+	if (is_connect_status(priv->connect_status) &&
+	    is_disconnect_status(old_status)) {
 		/* for power save */
 		atomic_set(&priv->psstatus.snooze_guard, 0);
 		atomic_set(&priv->psstatus.confirm_wait, 0);
@@ -802,8 +802,8 @@ void hostif_connect_indication(struct ks_wlan_private *priv)
 	wrqu0.data.length = 0;
 	wrqu0.data.flags = 0;
 	wrqu0.ap_addr.sa_family = ARPHRD_ETHER;
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS &&
-	    (old_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
+	if (is_disconnect_status(priv->connect_status) &&
+	    is_connect_status(old_status)) {
 		eth_zero_addr(wrqu0.ap_addr.sa_data);
 		DPRINTK(3, "IWEVENT: disconnect\n");
 		DPRINTK(3, "disconnect :: scan_ind_count=%d\n",
@@ -860,7 +860,7 @@ void hostif_stop_confirm(struct ks_wlan_private *priv)
 		priv->dev_state = DEVICE_STATE_READY;
 
 	/* disconnect indication */
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
+	if (is_connect_status(priv->connect_status)) {
 		netif_carrier_off(netdev);
 		tmp = FORCE_DISCONNECT & priv->connect_status;
 		priv->connect_status = tmp | DISCONNECT_STATUS;
@@ -869,8 +869,8 @@ void hostif_stop_confirm(struct ks_wlan_private *priv)
 		wrqu0.data.length = 0;
 		wrqu0.data.flags = 0;
 		wrqu0.ap_addr.sa_family = ARPHRD_ETHER;
-		if ((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS &&
-		    (old_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
+		if (is_disconnect_status(priv->connect_status) &&
+		    is_connect_status(old_status)) {
 			eth_zero_addr(wrqu0.ap_addr.sa_data);
 			DPRINTK(3, "IWEVENT: disconnect\n");
 			netdev_info(netdev, "IWEVENT: disconnect\n");
@@ -1132,7 +1132,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 		goto err_kfree_skb;
 	}
 
-	if (((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS) ||
+	if (is_disconnect_status(priv->connect_status) ||
 	    (priv->connect_status & FORCE_DISCONNECT) ||
 	    priv->wpa.mic_failure.stop) {
 		DPRINTK(3, " DISCONNECT\n");

commit 11ce16da7b0f5335c7622ccc7c8151a387b44853
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:18 2017 +1000

    staging: ks7010: add hostif_generic_request()
    
    Driver contains duplicate code. Host interface has numerous request
    functions which allocate memory for a request header. Each request
    header is different but all contain, as the first member, a hostif_hdr
    structure. This structure has size and event members which need to be
    set. By defining a helper function to allocate the memory and set the
    initial hostif_hdr members code duplication is reduced.
    
    Add function to allocate  memory for a host interface request. Set
    'size' and 'event' members. Remove duplicate code using newly defined
    function.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 7e9855f45a78..48210295b2d8 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1091,6 +1091,21 @@ void hostif_event_check(struct ks_wlan_private *priv)
 	priv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;
 }
 
+/* allocate size bytes, set header size and event */
+static void *hostif_generic_request(size_t size, int event)
+{
+	struct hostif_hdr *p;
+
+	p = kzalloc(hif_align_size(size), KS_WLAN_MEM_FLAG);
+	if (!p)
+		return NULL;
+
+	p->size = cpu_to_le16((u16)(size - sizeof(p->size)));
+	p->event = cpu_to_le16(event);
+
+	return p;
+}
+
 int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 {
 	unsigned int skb_len = 0;
@@ -1283,15 +1298,10 @@ void hostif_mib_get_request(struct ks_wlan_private *priv,
 
 	DPRINTK(3, "\n");
 
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+	pp = hostif_generic_request(sizeof(*pp), HIF_MIB_GET_REQ);
+	if (!pp)
 		return;
-	}
-	pp->header.size =
-	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_MIB_GET_REQ);
+
 	pp->mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
 
 	/* send to device request */
@@ -1313,17 +1323,10 @@ void hostif_mib_set_request(struct ks_wlan_private *priv,
 		return;
 	}
 
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp) + size), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+	pp = hostif_generic_request(sizeof(*pp), HIF_MIB_SET_REQ);
+	if (!pp)
 		return;
-	}
 
-	pp->header.size =
-	    cpu_to_le16((uint16_t)
-			(sizeof(*pp) - sizeof(pp->header.size) + size));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_MIB_SET_REQ);
 	pp->mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
 	pp->mib_value.size = cpu_to_le16((uint16_t)size);
 	pp->mib_value.type = cpu_to_le16((uint16_t)type);
@@ -1341,15 +1344,10 @@ void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 
 	DPRINTK(3, "\n");
 
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+	pp = hostif_generic_request(sizeof(*pp), HIF_START_REQ);
+	if (!pp)
 		return;
-	}
-	pp->header.size =
-	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_START_REQ);
+
 	pp->mode = cpu_to_le16((uint16_t)mode);
 
 	/* send to device request */
@@ -1368,16 +1366,10 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 
 	DPRINTK(3, "\n");
 
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+	pp = hostif_generic_request(sizeof(*pp), HIF_PS_ADH_SET_REQ);
+	if (!pp)
 		return;
-	}
-	memset(pp, 0, sizeof(*pp));
-	pp->header.size =
-	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_PS_ADH_SET_REQ);
+
 	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
 	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
 	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
@@ -1411,15 +1403,10 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 
 	DPRINTK(3, "ssid.size=%d\n", priv->reg.ssid.size);
 
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+	pp = hostif_generic_request(sizeof(*pp), HIF_INFRA_SET_REQ);
+	if (!pp)
 		return;
-	}
-	pp->header.size =
-	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_INFRA_SET_REQ);
+
 	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
 	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
 	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
@@ -1477,15 +1464,10 @@ static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 
 	DPRINTK(2, "ssid.size=%d\n", priv->reg.ssid.size);
 
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+	pp = hostif_generic_request(sizeof(*pp), HIF_INFRA_SET2_REQ);
+	if (!pp)
 		return;
-	}
-	pp->header.size =
-	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_INFRA_SET2_REQ);
+
 	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
 	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
 	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
@@ -1546,16 +1528,10 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 
 	DPRINTK(3, "\n");
 
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+	pp = hostif_generic_request(sizeof(*pp), HIF_ADH_SET_REQ);
+	if (!pp)
 		return;
-	}
-	memset(pp, 0, sizeof(*pp));
-	pp->header.size =
-	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_ADH_SET_REQ);
+
 	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
 	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
 	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
@@ -1591,16 +1567,10 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 
 	DPRINTK(3, "\n");
 
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+	pp = hostif_generic_request(sizeof(*pp), HIF_ADH_SET_REQ);
+	if (!pp)
 		return;
-	}
-	memset(pp, 0, sizeof(*pp));
-	pp->header.size =
-	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_ADH_SET_REQ);
+
 	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
 	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
 	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
@@ -1638,15 +1608,9 @@ void hostif_stop_request(struct ks_wlan_private *priv)
 
 	DPRINTK(3, "\n");
 
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+	pp = hostif_generic_request(sizeof(*pp), HIF_STOP_REQ);
+	if (!pp)
 		return;
-	}
-	pp->header.size =
-	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_STOP_REQ);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1660,15 +1624,10 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 
 	DPRINTK(3, "\n");
 
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+	pp = hostif_generic_request(sizeof(*pp), HIF_PHY_INFO_REQ);
+	if (!pp)
 		return;
-	}
-	pp->header.size =
-	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_PHY_INFO_REQ);
+
 	if (priv->reg.phy_info_timer) {
 		pp->type = cpu_to_le16((uint16_t)TIME_TYPE);
 		pp->time = cpu_to_le16((uint16_t)(priv->reg.phy_info_timer));
@@ -1691,15 +1650,11 @@ void hostif_power_mngmt_request(struct ks_wlan_private *priv,
 
 	DPRINTK(3, "mode=%lu wake_up=%lu receiveDTIMs=%lu\n", mode, wake_up,
 		receiveDTIMs);
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+
+	pp = hostif_generic_request(sizeof(*pp), HIF_POWERMGT_REQ);
+	if (!pp)
 		return;
-	}
-	pp->header.size =
-	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_POWERMGT_REQ);
+
 	pp->mode = cpu_to_le32((uint32_t)mode);
 	pp->wake_up = cpu_to_le32((uint32_t)wake_up);
 	pp->receiveDTIMs = cpu_to_le32((uint32_t)receiveDTIMs);
@@ -1717,15 +1672,9 @@ void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
 	DPRINTK(3, "mode=%lu\n", mode);
 
 	if (mode == SLP_SLEEP) {
-		/* make primitive */
-		pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-		if (!pp) {
-			DPRINTK(3, "allocate memory failed..\n");
+		pp = hostif_generic_request(sizeof(*pp), HIF_SLEEP_REQ);
+		if (!pp)
 			return;
-		}
-		pp->header.size =
-		    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-		pp->header.event = cpu_to_le16((uint16_t)HIF_SLEEP_REQ);
 
 		/* send to device request */
 		ps_confirm_wait_inc(priv);
@@ -1748,15 +1697,11 @@ void hostif_bss_scan_request(struct ks_wlan_private *priv,
 	struct hostif_bss_scan_request_t *pp;
 
 	DPRINTK(2, "\n");
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+
+	pp = hostif_generic_request(sizeof(*pp), HIF_SCAN_REQ);
+	if (!pp)
 		return;
-	}
-	pp->header.size =
-	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_SCAN_REQ);
+
 	pp->scan_type = scan_type;
 
 	pp->ch_time_min = cpu_to_le32((uint32_t)110);	/* default value */
@@ -1804,15 +1749,11 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 	struct hostif_mic_failure_request_t *pp;
 
 	DPRINTK(3, "count=%d :: timer=%d\n", failure_count, timer);
-	/* make primitive */
-	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+
+	pp = hostif_generic_request(sizeof(*pp), HIF_MIC_FAILURE_REQ);
+	if (!pp)
 		return;
-	}
-	pp->header.size =
-	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_MIC_FAILURE_REQ);
+
 	pp->failure_count = cpu_to_le16((uint16_t)failure_count);
 	pp->timer = cpu_to_le16((uint16_t)timer);
 

commit 95e72fba95fd1d9b9ef3ab080aafe1076f42a10a
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:17 2017 +1000

    staging: ks7010: clean memory allocation
    
    Memory allocation code contains unneeded debug statements, failed
    kmalloc() calls typically do not require a debug message. Introduction
    of a local 'size' variable allows kmalloc() call to be marginally
    cleaner, still uses magic numbers but these require a more substantial
    fix. Moving the magic numbers onto a single line opens the way for
    further refactoring.
    
    Clean memory allocation code, remove debug statements.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 8755bd93ac37..7e9855f45a78 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1135,12 +1135,9 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 			netif_stop_queue(priv->net_dev);
 	}
 
-	DPRINTK(4, "skb_buff length=%d\n", skb_len);
-	pp = kmalloc(hif_align_size(sizeof(*pp) + 6 + skb_len + 8),
-		     KS_WLAN_MEM_FLAG);
-
+	size = sizeof(*pp) + 6 + skb_len + 8;
+	pp = kmalloc(hif_align_size(size), KS_WLAN_MEM_FLAG);
 	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
 		ret = -ENOMEM;
 		goto err_kfree_skb;
 	}

commit 8215fc607f50c516ceeb47fac046c3e4ea7acc4e
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:16 2017 +1000

    staging: ks7010: remove duplicate code
    
    Current switch statement has duplicate code in branches. This code can
    be put after the switch statement so as to remove the duplication.
    
    Move code to after switch statement, remove duplicate code. Make error
    branch return so as not to execute the moved code block. Do not change
    the program logic.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 8cfda6089b98..8755bd93ac37 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -462,17 +462,6 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 		memcpy(skb_put(skb, size), &eth_hdr->h_proto, size);
 
 		aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + ETHER_HDR_SIZE);
-		if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
-		    priv->wpa.rsn_enabled)
-			atomic_set(&priv->psstatus.snooze_guard, 1);
-
-		/* rx indication */
-		skb->dev = priv->net_dev;
-		skb->protocol = eth_type_trans(skb, skb->dev);
-		priv->nstats.rx_packets++;
-		priv->nstats.rx_bytes += rx_ind_size;
-		netif_rx(skb);
-
 		break;
 	case 0xF0:	/* NETBEUI/NetBIOS */
 		rx_ind_size = (priv->rx_size + 2);
@@ -493,22 +482,23 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 		       rx_ind_size - 14);	/* copy after Type */
 
 		aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 14);
-		if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
-		    priv->wpa.rsn_enabled)
-			atomic_set(&priv->psstatus.snooze_guard, 1);
-
-		/* rx indication */
-		skb->dev = priv->net_dev;
-		skb->protocol = eth_type_trans(skb, skb->dev);
-		priv->nstats.rx_packets++;
-		priv->nstats.rx_bytes += rx_ind_size;
-		netif_rx(skb);
-
 		break;
 	default:	/* other rx data */
 		DPRINTK(2, "invalid data format\n");
 		priv->nstats.rx_errors++;
+		return;
 	}
+
+	if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
+	    priv->wpa.rsn_enabled)
+		atomic_set(&priv->psstatus.snooze_guard, 1);
+
+	/* rx indication */
+	skb->dev = priv->net_dev;
+	skb->protocol = eth_type_trans(skb, skb->dev);
+	priv->nstats.rx_packets++;
+	priv->nstats.rx_bytes += rx_ind_size;
+	netif_rx(skb);
 }
 
 static

commit 08484ef41927a52fbd0d46c5cd19a65535d768ea
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:15 2017 +1000

    staging: ks7010: remove magic numbers
    
    Driver includes magic numbers. Defining constants or using existing
    constants aids the readability of the code.
    
    Magic number '12' is used for two ethernet addresses (6 bytes
    each). ETH_ALEN is already defined within the kernel to 6. We can us
    the expression '2 * ETH_ALEN' to make this code explicit.
    
    Magic number '20' refers to the data size, in bytes, of a struct
    ether_hdr (described in eap_packet.h). We can define a constant for
    this purpose, making the code explicit and easier to read.
    
    Define constant. Remove magic numbers, using newly defined constant
    and/or expression using existing kernel constant.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 7c20585edc50..8cfda6089b98 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -399,6 +399,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 	struct ether_hdr *eth_hdr;
 	unsigned short eth_proto;
 	struct ieee802_1x_hdr *aa1x_hdr;
+	size_t size;
 	int ret;
 
 	DPRINTK(3, "\n");
@@ -452,12 +453,15 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 		}
 		DPRINTK(4, "SNAP, rx_ind_size = %d\n", rx_ind_size);
 
-		memcpy(skb_put(skb, 12), priv->rxp, 12);	/* 8802/FDDI MAC copy */
+		size = ETH_ALEN * 2;
+		memcpy(skb_put(skb, size), priv->rxp, size);
+
 		/* (SNAP+UI..) skip */
-		memcpy(skb_put(skb, rx_ind_size - 12), priv->rxp + 18,
-		       rx_ind_size - 12);	/* copy after Type */
 
-		aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 20);
+		size = rx_ind_size - (ETH_ALEN * 2);
+		memcpy(skb_put(skb, size), &eth_hdr->h_proto, size);
+
+		aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + ETHER_HDR_SIZE);
 		if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
 		    priv->wpa.rsn_enabled)
 			atomic_set(&priv->psstatus.snooze_guard, 1);
@@ -1113,6 +1117,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	struct ieee802_1x_hdr *aa1x_hdr;
 	struct wpa_eapol_key *eap_key;
 	struct ethhdr *eth;
+	size_t size;
 	int ret;
 
 	skb_len = skb->len;
@@ -1164,11 +1169,13 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 		goto err_kfree;
 	}
 
-	/* MAC address copy */
-	memcpy(p, buffer, 12);	/* DST/SRC MAC address */
-	p += 12;
-	buffer += 12;
-	length -= 12;
+	/* dest and src MAC address copy */
+	size = ETH_ALEN * 2;
+	memcpy(p, buffer, size);
+	p += size;
+	buffer += size;
+	length -= size;
+
 	/* EtherType/Length check */
 	if (*(buffer + 1) + (*buffer << 8) > 1500) {
 		/* ProtocolEAP = *(buffer+1) + (*buffer << 8); */

commit 8cd1dbe1db97ad74c5265e09c3490eeb7986f623
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:14 2017 +1000

    staging: ks7010: move skb null check near allocation
    
    Currently, after allocating an sk_buff, driver fills the sk_buff
    within code block guarded by a NULL check on the sk_buff. If a NULL
    check is done immediately after the allocation, and code returns on
    error, then the subsequent code need not be guarded and the level of
    indentation may be reduced. This aids the readability of the code and
    makes explicit the error path.
    
    Check for NULL directly after allocating the sk_buff, return if
    allocation fails. Reduce indentation of subsequent code. Do not change
    the program logic.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index fbebe22caa51..7c20585edc50 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -446,56 +446,60 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 	case 0xAA:	/* SNAP */
 		rx_ind_size = priv->rx_size - 6;
 		skb = dev_alloc_skb(rx_ind_size);
-		DPRINTK(4, "SNAP, rx_ind_size = %d\n", rx_ind_size);
-
-		if (skb) {
-			memcpy(skb_put(skb, 12), priv->rxp, 12);	/* 8802/FDDI MAC copy */
-			/* (SNAP+UI..) skip */
-			memcpy(skb_put(skb, rx_ind_size - 12), priv->rxp + 18, rx_ind_size - 12);	/* copy after Type */
-
-			aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 20);
-			if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
-			    priv->wpa.rsn_enabled)
-				atomic_set(&priv->psstatus.snooze_guard, 1);
-
-			/* rx indication */
-			skb->dev = priv->net_dev;
-			skb->protocol = eth_type_trans(skb, skb->dev);
-			priv->nstats.rx_packets++;
-			priv->nstats.rx_bytes += rx_ind_size;
-			netif_rx(skb);
-		} else {
+		if (!skb) {
 			priv->nstats.rx_dropped++;
+			return;
 		}
+		DPRINTK(4, "SNAP, rx_ind_size = %d\n", rx_ind_size);
+
+		memcpy(skb_put(skb, 12), priv->rxp, 12);	/* 8802/FDDI MAC copy */
+		/* (SNAP+UI..) skip */
+		memcpy(skb_put(skb, rx_ind_size - 12), priv->rxp + 18,
+		       rx_ind_size - 12);	/* copy after Type */
+
+		aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 20);
+		if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
+		    priv->wpa.rsn_enabled)
+			atomic_set(&priv->psstatus.snooze_guard, 1);
+
+		/* rx indication */
+		skb->dev = priv->net_dev;
+		skb->protocol = eth_type_trans(skb, skb->dev);
+		priv->nstats.rx_packets++;
+		priv->nstats.rx_bytes += rx_ind_size;
+		netif_rx(skb);
+
 		break;
 	case 0xF0:	/* NETBEUI/NetBIOS */
 		rx_ind_size = (priv->rx_size + 2);
 		skb = dev_alloc_skb(rx_ind_size);
+		if (!skb) {
+			priv->nstats.rx_dropped++;
+			return;
+		}
 		DPRINTK(3, "NETBEUI/NetBIOS rx_ind_size=%d\n", rx_ind_size);
 
-		if (skb) {
-			memcpy(skb_put(skb, 12), priv->rxp, 12);	/* 8802/FDDI MAC copy */
+		memcpy(skb_put(skb, 12), priv->rxp, 12);	/* 8802/FDDI MAC copy */
 
-			temp[0] = (((rx_ind_size - 12) >> 8) & 0xff);	/* NETBEUI size add */
-			temp[1] = ((rx_ind_size - 12) & 0xff);
-			memcpy(skb_put(skb, 2), temp, 2);
+		temp[0] = (((rx_ind_size - 12) >> 8) & 0xff);	/* NETBEUI size add */
+		temp[1] = ((rx_ind_size - 12) & 0xff);
+		memcpy(skb_put(skb, 2), temp, 2);
 
-			memcpy(skb_put(skb, rx_ind_size - 14), priv->rxp + 12, rx_ind_size - 14);	/* copy after Type */
+		memcpy(skb_put(skb, rx_ind_size - 14), priv->rxp + 12,
+		       rx_ind_size - 14);	/* copy after Type */
 
-			aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 14);
-			if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
-			    priv->wpa.rsn_enabled)
-				atomic_set(&priv->psstatus.snooze_guard, 1);
+		aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 14);
+		if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
+		    priv->wpa.rsn_enabled)
+			atomic_set(&priv->psstatus.snooze_guard, 1);
+
+		/* rx indication */
+		skb->dev = priv->net_dev;
+		skb->protocol = eth_type_trans(skb, skb->dev);
+		priv->nstats.rx_packets++;
+		priv->nstats.rx_bytes += rx_ind_size;
+		netif_rx(skb);
 
-			/* rx indication */
-			skb->dev = priv->net_dev;
-			skb->protocol = eth_type_trans(skb, skb->dev);
-			priv->nstats.rx_packets++;
-			priv->nstats.rx_bytes += rx_ind_size;
-			netif_rx(skb);
-		} else {
-			priv->nstats.rx_dropped++;
-		}
 		break;
 	default:	/* other rx data */
 		DPRINTK(2, "invalid data format\n");

commit 69f3fecc49cabaadf4839dda4227427fc15b4c7e
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:13 2017 +1000

    staging: ks7010: remove unused local variable eap_key
    
    Code declares and assigns to a local variable that is never used, it
    can be safely removed.
    
    Remove unused local variable.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 2216409bcb3d..fbebe22caa51 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -399,7 +399,6 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 	struct ether_hdr *eth_hdr;
 	unsigned short eth_proto;
 	struct ieee802_1x_hdr *aa1x_hdr;
-	struct wpa_eapol_key *eap_key;
 	int ret;
 
 	DPRINTK(3, "\n");
@@ -456,10 +455,8 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 
 			aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 20);
 			if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
-			    priv->wpa.rsn_enabled) {
-				eap_key = (struct wpa_eapol_key *)(aa1x_hdr + 1);
+			    priv->wpa.rsn_enabled)
 				atomic_set(&priv->psstatus.snooze_guard, 1);
-			}
 
 			/* rx indication */
 			skb->dev = priv->net_dev;
@@ -487,10 +484,8 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 
 			aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 14);
 			if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
-			    priv->wpa.rsn_enabled) {
-				eap_key = (struct wpa_eapol_key *)(aa1x_hdr + 1);
+			    priv->wpa.rsn_enabled)
 				atomic_set(&priv->psstatus.snooze_guard, 1);
-			}
 
 			/* rx indication */
 			skb->dev = priv->net_dev;

commit 208c66f2fb3d9cd398386785aae116753a27e8c4
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:12 2017 +1000

    staging: ks7010: remove unnecessary address check
    
    Currently source and destination ethernet addresses are checked twice,
    once in hostif_data_indication() and then again in
    hostif_data_indication_wpa(). The second of these functions is called
    from the first right after the address check is done. This check is a
    duplicate and is unnecessary.
    
    Remove unnecessary duplicate address check.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 7151f16e2f9c..2216409bcb3d 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -326,10 +326,6 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 	eth_hdr = (struct ether_hdr *)(priv->rxp);
 	eth_proto = ntohs(eth_hdr->h_proto);
 
-	/* source address check */
-	if (memcmp(&eth_hdr->h_source[0], &priv->eth_addr[0], ETH_ALEN) == 0)
-		return 0;
-
 	if (eth_hdr->h_dest_snap != eth_hdr->h_source_snap) {
 		DPRINTK(1, "invalid data format\n");
 		priv->nstats.rx_errors++;

commit 18bd6dd1f849105b0aca7666d8eb3528b8cd8a8e
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:35 2017 +1000

    staging: ks7010: move hw info into dev private data
    
    Currently driver uses a hardware information struct description to
    group some SDIO related functionality (work, work queue, sdio private
    data pointer). This structure is then embedded in the device private
    data structure. Having nested structures described in different header
    files means that to view the device private data programmers must open
    two header files. This structure could be embedded anonymously in the
    device private data and achieve the same result (grouping of function
    specific to SDIO) without the need to open multiple headers. However,
    the SDIO private data structure already has various different data and
    pointers, adding the embedded structure adds little extra meaning and
    lengthens all the dereferences throughout the driver, often meaning
    addition line breaks and braces. We can increase readability and
    reduce code complexity by moving the hardware information data and
    pointers to directly be within the device private data structure
    description.
    
    While preparing for this refactoring it was noted that the identifier
    currently used for the delayed work is 'rw_wq', this is confusing
    since the 'wq' suffix typically means 'work queue'. This identifier
    would be more meaningful if it used the suffix 'dwork' as does the
    declaration of queue_delayed_work() (include/linux/workqueue.h).
    
    The identifier for the work queue is currently 'ks7010sdio_wq'. This
    identifier can be shortened without loss of meaning because there is
    only one work queue within the driver. Identifier 'wq' is typical
    within in-tree driver code and aptly describes the pointer.
    
    Current pointer to the SDIO private data is identified by 'sdio_card',
    this is sufficiently meaningful from within the hw_info structure but
    once the hw_info_t structure is removed the pointer would be better to
    have a prefix appended to it to retain the prior level of meaning.
    
    Move members from struct hw_info_t to struct ks_wlan_private.
    
    Rename identifiers;
    struct delayed_work pointer 'rw_wq' to 'rw_dwork'.
    struct workqueue_struct pointer 'ks7010sdio_wq' to 'wq'.
    struct ks_sdio_card  pointer 'sdio_card' to 'ks_sdio_card'.
    
    Remove structure description hw_info_t. Fix init/destroy calls. Fix
    all call sites, SDIO private data access calls, and queuing calls.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 2a54b4cb59b4..7151f16e2f9c 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -743,8 +743,7 @@ void hostif_sleep_confirm(struct ks_wlan_private *priv)
 	DPRINTK(3, "\n");
 
 	atomic_set(&priv->sleepstatus.doze_request, 1);
-	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-			   &priv->ks_wlan_hw.rw_wq, 1);
+	queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 }
 
 static
@@ -1745,8 +1744,7 @@ void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
 			      NULL);
 	} else if (mode == SLP_ACTIVE) {
 		atomic_set(&priv->sleepstatus.wakeup_request, 1);
-		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-				   &priv->ks_wlan_hw.rw_wq, 1);
+		queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 	} else {
 		DPRINTK(3, "invalid mode %ld\n", mode);
 		return;

commit 07e483c14bd5d149b1c214562654798a5be104b0
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:33 2017 +1000

    staging: ks7010: rename wakeup work struct
    
    struct work_struct uses identifier ks_wlan_wakeup_task, this is
    confusing because the 'task' suffix implies that this is a
    tasklet_struct instead of a work struct. Suffix 'work' would be more
    clear. The code would be easier to read if it followed the principle
    of least surprise and used the 'work' suffix for a work_struct
    identifier.
    
    Rename work_struct structure 'ks_wlan_wakeup_task' to 'wakeup_work'.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index a04e4e337176..2a54b4cb59b4 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -66,11 +66,13 @@ inline u32 get_DWORD(struct ks_wlan_private *priv)
 
 static void ks_wlan_hw_wakeup_task(struct work_struct *work)
 {
-	struct ks_wlan_private *priv =
-	    container_of(work, struct ks_wlan_private, ks_wlan_wakeup_task);
-	int ps_status = atomic_read(&priv->psstatus.status);
+	struct ks_wlan_private *priv;
+	int ps_status;
 	long time_left;
 
+	priv = container_of(work, struct ks_wlan_private, wakeup_work);
+	ps_status = atomic_read(&priv->psstatus.status);
+
 	if (ps_status == PS_SNOOZE) {
 		ks_wlan_hw_wakeup_request(priv);
 		time_left = wait_for_completion_interruptible_timeout(
@@ -78,7 +80,7 @@ static void ks_wlan_hw_wakeup_task(struct work_struct *work)
 				msecs_to_jiffies(20));
 		if (time_left <= 0) {
 			DPRINTK(1, "wake up timeout or interrupted !!!\n");
-			schedule_work(&priv->ks_wlan_wakeup_task);
+			schedule_work(&priv->wakeup_work);
 			return;
 		}
 	} else {
@@ -2656,10 +2658,8 @@ int hostif_init(struct ks_wlan_private *priv)
 	atomic_set(&priv->psstatus.status, PS_NONE);
 	atomic_set(&priv->psstatus.confirm_wait, 0);
 	atomic_set(&priv->psstatus.snooze_guard, 0);
-	/* init_waitqueue_head(&priv->psstatus.wakeup_wait); */
 	init_completion(&priv->psstatus.wakeup_wait);
-	//INIT_WORK(&priv->ks_wlan_wakeup_task, ks_wlan_hw_wakeup_task, (void *)priv);
-	INIT_WORK(&priv->ks_wlan_wakeup_task, ks_wlan_hw_wakeup_task);
+	INIT_WORK(&priv->wakeup_work, ks_wlan_hw_wakeup_task);
 
 	/* WPA */
 	memset(&priv->wpa, 0, sizeof(priv->wpa));

commit 055da4f9b95dd2a50c653b5a4559b9186081fb75
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:31 2017 +1000

    staging: ks7010: fix complete_handler
    
    complete_handler() takes void * types as parameters. void * parameters are then
    cast to struct types. Call sites for this function either pass in NULL
    or pointers to the struct types cast to void *. This casting is
    unnecessary and can be removed.
    
    Struct tx_device_buffer (which contains a pointer member to the
    complete_handler() function) has as member 'ks_wlan_priv *priv' this is
    unnecessary, we always have a pointer to this struct there is no need
    to store it here.
    
    The complete_handler can be more clearly defined by using struct
    pointer types instead of void * types. The code is currently
    unnecessarily complex, storing and passing extraneous pointer
    parameters.
    
    Remove unnecessary parameters, unnecessary casting to/from 'void
    *'. Fix all call sites involving complete_handler().
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 5292463519b1..a04e4e337176 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1254,10 +1254,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	pp->header.event = cpu_to_le16((uint16_t)HIF_DATA_REQ);
 
 	/* tx request */
-	result =
-	    ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + skb_len),
-			  (void *)send_packet_complete, (void *)priv,
-			  (void *)skb);
+	result = ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + skb_len),
+			       send_packet_complete, skb);
 
 	/* MIC FAILURE REPORT check */
 	if (eth_proto == ETHER_PROTOCOL_TYPE_EAP &&
@@ -1308,7 +1306,7 @@ void hostif_mib_get_request(struct ks_wlan_private *priv,
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 }
 
 static
@@ -1343,8 +1341,7 @@ void hostif_mib_set_request(struct ks_wlan_private *priv,
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + size), NULL, NULL,
-		      NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + size), NULL, NULL);
 }
 
 static
@@ -1367,7 +1364,7 @@ void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 
 	priv->aplist.size = 0;
 	priv->scan_ind_count = 0;
@@ -1413,7 +1410,7 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 }
 
 static
@@ -1480,7 +1477,7 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 }
 
 static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
@@ -1548,7 +1545,7 @@ static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 }
 
 static
@@ -1593,7 +1590,7 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 }
 
 static
@@ -1641,7 +1638,7 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 }
 
 static
@@ -1663,7 +1660,7 @@ void hostif_stop_request(struct ks_wlan_private *priv)
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 }
 
 static
@@ -1692,7 +1689,7 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 }
 
 static
@@ -1719,7 +1716,7 @@ void hostif_power_mngmt_request(struct ks_wlan_private *priv,
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 }
 
 static
@@ -1742,7 +1739,7 @@ void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
 
 		/* send to device request */
 		ps_confirm_wait_inc(priv);
-		ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL,
+		ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL,
 			      NULL);
 	} else if (mode == SLP_ACTIVE) {
 		atomic_set(&priv->sleepstatus.wakeup_request, 1);
@@ -1804,7 +1801,7 @@ void hostif_bss_scan_request(struct ks_wlan_private *priv,
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 
 	priv->aplist.size = 0;
 	priv->scan_ind_count = 0;
@@ -1832,7 +1829,7 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL);
 }
 
 /* Device I/O Receive indicate */

commit d317d054b14df4cbce5324454925dc6c9858a8c4
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:16:01 2017 +1000

    staging: ks7010: move check and break to top of loop
    
    Function uses an if statement within a for loop to guard a block of
    code. If 'if' statement conditional evaluates to false, loop breaks. The
    same logic can be expressed by inverting the conditional and breaking
    when new conditional evaluates to true. This allows the subsequent code
    to be indented one level less, aiding readability. Reduced indentation
    also allows for the code to be laid out more clearly and fixes two
    checkpatch warnings.
    
    Invert if statement conditional, break from for loop if new
    conditional evaluates to true. Reduce indentation in subsequent code,
    fix whitespace issues. Do not change program logic.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 597280882dc8..5292463519b1 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2147,33 +2147,27 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 	/* rate mask by phy setting */
 	if (priv->reg.phy_type == D_11B_ONLY_MODE) {
 		for (i = 0; i < priv->reg.rate_set.size; i++) {
-			if (IS_11B_RATE(priv->reg.rate_set.body[i])) {
-				if ((priv->reg.rate_set.body[i] & RATE_MASK) >=
-				    TX_RATE_5M)
-					rate_octet[i] =
-					    priv->reg.rate_set.
-					    body[i] & RATE_MASK;
-				else
-					rate_octet[i] =
-					    priv->reg.rate_set.body[i];
-			} else {
+			if (!IS_11B_RATE(priv->reg.rate_set.body[i]))
 				break;
+
+			if ((priv->reg.rate_set.body[i] & RATE_MASK) >= TX_RATE_5M) {
+				rate_octet[i] = priv->reg.rate_set.body[i] &
+						RATE_MASK;
+			} else {
+				rate_octet[i] = priv->reg.rate_set.body[i];
 			}
 		}
 
 	} else {	/* D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE */
 		for (i = 0; i < priv->reg.rate_set.size; i++) {
-			if (IS_11BG_RATE(priv->reg.rate_set.body[i])) {
-				if (IS_OFDM_EXT_RATE
-				    (priv->reg.rate_set.body[i]))
-					rate_octet[i] =
-					    priv->reg.rate_set.
-					    body[i] & RATE_MASK;
-				else
-					rate_octet[i] =
-					    priv->reg.rate_set.body[i];
-			} else {
+			if (!IS_11BG_RATE(priv->reg.rate_set.body[i]))
 				break;
+
+			if (IS_OFDM_EXT_RATE(priv->reg.rate_set.body[i])) {
+				rate_octet[i] = priv->reg.rate_set.body[i] &
+						RATE_MASK;
+			} else {
+				rate_octet[i] = priv->reg.rate_set.body[i];
 			}
 		}
 	}

commit eb8c4e546961cbdb7d448458c24dfae9d1622510
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:16:00 2017 +1000

    staging: ks7010: remove multi-way decision
    
    Function uses multi-way decision for control flow. Final statement of
    function is spin_unlock(). Code can be simplified by adding a goto label
    labelling the call to spin_unlock() and jumping to label instead of
    using multi-way decision. This allows the code to be indented one
    level less which adds to the readability.
    
    Add goto label. Remove multi-way decision by jumping to label. Reduce
    indentation in subsequent code. Do not change program logic.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index a505c4ec6f32..597280882dc8 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2241,36 +2241,38 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
 				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
 				       &filter_type);
-	} else if ((netdev_mc_count(dev) > NIC_MAX_MCAST_LIST) ||
-		   (dev->flags & IFF_ALLMULTI)) {
+		goto spin_unlock;
+	}
+
+	if ((netdev_mc_count(dev) > NIC_MAX_MCAST_LIST) ||
+	    (dev->flags & IFF_ALLMULTI)) {
 		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCASTALL);
 		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
 				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
 				       &filter_type);
-	} else {
-		if (priv->sme_i.sme_flag & SME_MULTICAST) {
-			mc_count = netdev_mc_count(dev);
-			netdev_for_each_mc_addr(ha, dev) {
-				memcpy(&set_address[i * ETH_ALEN], ha->addr,
-				       ETH_ALEN);
-				i++;
-			}
-			priv->sme_i.sme_flag &= ~SME_MULTICAST;
-			hostif_mib_set_request(priv, LOCAL_MULTICAST_ADDRESS,
-					       (ETH_ALEN * mc_count),
-					       MIB_VALUE_TYPE_OSTRING,
-					       &set_address[0]);
-		} else {
-			filter_type =
-			    cpu_to_le32((uint32_t)MCAST_FILTER_MCAST);
-			priv->sme_i.sme_flag |= SME_MULTICAST;
-			hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
-					       sizeof(filter_type),
-					       MIB_VALUE_TYPE_BOOL,
-					       &filter_type);
+		goto spin_unlock;
+	}
+
+	if (priv->sme_i.sme_flag & SME_MULTICAST) {
+		mc_count = netdev_mc_count(dev);
+		netdev_for_each_mc_addr(ha, dev) {
+			memcpy(&set_address[i * ETH_ALEN], ha->addr, ETH_ALEN);
+			i++;
 		}
+		priv->sme_i.sme_flag &= ~SME_MULTICAST;
+		hostif_mib_set_request(priv, LOCAL_MULTICAST_ADDRESS,
+				       ETH_ALEN * mc_count,
+				       MIB_VALUE_TYPE_OSTRING,
+				       &set_address[0]);
+	} else {
+		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCAST);
+		priv->sme_i.sme_flag |= SME_MULTICAST;
+		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
+				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
+				       &filter_type);
 	}
 
+spin_unlock:
 	spin_unlock(&priv->multicast_spin);
 }
 

commit 1e0aa795daf9b7adeb4fccb7394c12e39f31c020
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:59 2017 +1000

    staging: ks7010: remove unused macro
    
    Macro CHECK_ALINE is defined and never used.
    
    Remove unused macro.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 47adc779565f..a505c4ec6f32 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1101,8 +1101,6 @@ void hostif_event_check(struct ks_wlan_private *priv)
 	priv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;
 }
 
-#define CHECK_ALINE(size) (size % 4 ? (size + (4 - (size % 4))) : size)
-
 int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 {
 	unsigned int skb_len = 0;

commit 4906be2486996d09b4049782a0accbece3a37eed
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:58 2017 +1000

    staging: ks7010: fix checkpatch MULTILINE_DEREFERENCE
    
    Checkpatch emits WARNING: Avoid multiple line dereference.
    
    Fix up layout of function call, move dereference to single line.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 154764a42ca5..47adc779565f 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -849,8 +849,7 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 		DPRINTK(4, " scan_ind_count=%d :: aplist.size=%d\n",
 			priv->scan_ind_count, priv->aplist.size);
 		get_ap_information(priv, (struct ap_info_t *)(priv->rxp),
-				   &(priv->aplist.
-				     ap[priv->scan_ind_count - 1]));
+				   &(priv->aplist.ap[priv->scan_ind_count - 1]));
 		priv->aplist.size = priv->scan_ind_count;
 	} else {
 		DPRINTK(4, " count over :: scan_ind_count=%d\n",
@@ -1224,9 +1223,12 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);	/* no encryption */
 		} else {
 			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
-				MichaelMICFunction(&michael_mic, (uint8_t *)priv->wpa.key[0].tx_mic_key, (uint8_t *)&pp->data[0], (int)skb_len, (uint8_t)0,	/* priority */
-						   (uint8_t *)michael_mic.
-						   Result);
+				MichaelMICFunction(&michael_mic,
+						   (uint8_t *)priv->wpa.key[0].tx_mic_key,
+						   (uint8_t *)&pp->data[0],
+						   (int)skb_len,
+						   (uint8_t)0,	/* priority */
+						   (uint8_t *)michael_mic.Result);
 				memcpy(p, michael_mic.Result, 8);
 				length += 8;
 				skb_len += 8;

commit 331454f43850894c102e4d24f44257abb32b6fca
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:57 2017 +1000

    staging: ks7010: fix checkpatch LOGICAL_CONTINUATIONS
    
    Checkpatch emits multiple CHECK: Logical continuations should be on the
    previous line.
    
    Move logical continuations to the end of the previous line.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 39004d81c8e5..154764a42ca5 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -147,8 +147,8 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	/* capability */
 	ap->capability = ap_info->capability;
 	/* rsn */
-	if ((ap_info->rsn_mode & RSN_MODE_WPA2)
-	    && (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)) {
+	if ((ap_info->rsn_mode & RSN_MODE_WPA2) &&
+	    (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)) {
 		ap->rsn_ie.id = 0x30;
 		if (ap_info->rsn.size <= RSN_IE_BODY_MAX) {
 			ap->rsn_ie.size = ap_info->rsn.size;
@@ -159,8 +159,8 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 			memcpy(ap->rsn_ie.body, ap_info->rsn.body,
 			       RSN_IE_BODY_MAX);
 		}
-	} else if ((ap_info->rsn_mode & RSN_MODE_WPA)
-		   && (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA)) {
+	} else if ((ap_info->rsn_mode & RSN_MODE_WPA) &&
+		   (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA)) {
 		ap->wpa_ie.id = 0xdd;
 		if (ap_info->rsn.size <= RSN_IE_BODY_MAX) {
 			ap->wpa_ie.size = ap_info->rsn.size;
@@ -457,10 +457,9 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 			memcpy(skb_put(skb, rx_ind_size - 12), priv->rxp + 18, rx_ind_size - 12);	/* copy after Type */
 
 			aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 20);
-			if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY
-			    && priv->wpa.rsn_enabled) {
-				eap_key =
-				    (struct wpa_eapol_key *)(aa1x_hdr + 1);
+			if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
+			    priv->wpa.rsn_enabled) {
+				eap_key = (struct wpa_eapol_key *)(aa1x_hdr + 1);
 				atomic_set(&priv->psstatus.snooze_guard, 1);
 			}
 
@@ -489,10 +488,9 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 			memcpy(skb_put(skb, rx_ind_size - 14), priv->rxp + 12, rx_ind_size - 14);	/* copy after Type */
 
 			aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 14);
-			if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY
-			    && priv->wpa.rsn_enabled) {
-				eap_key =
-				    (struct wpa_eapol_key *)(aa1x_hdr + 1);
+			if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
+			    priv->wpa.rsn_enabled) {
+				eap_key = (struct wpa_eapol_key *)(aa1x_hdr + 1);
 				atomic_set(&priv->psstatus.snooze_guard, 1);
 			}
 
@@ -882,9 +880,8 @@ void hostif_stop_confirm(struct ks_wlan_private *priv)
 		wrqu0.data.length = 0;
 		wrqu0.data.flags = 0;
 		wrqu0.ap_addr.sa_family = ARPHRD_ETHER;
-		if ((priv->connect_status & CONNECT_STATUS_MASK) ==
-		    DISCONNECT_STATUS
-		    && (old_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
+		if ((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS &&
+		    (old_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
 			eth_zero_addr(wrqu0.ap_addr.sa_data);
 			DPRINTK(3, "IWEVENT: disconnect\n");
 			netdev_info(netdev, "IWEVENT: disconnect\n");
@@ -1132,9 +1129,9 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 		goto err_kfree_skb;
 	}
 
-	if (((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS)
-	    || (priv->connect_status & FORCE_DISCONNECT)
-	    || priv->wpa.mic_failure.stop) {
+	if (((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS) ||
+	    (priv->connect_status & FORCE_DISCONNECT) ||
+	    priv->wpa.mic_failure.stop) {
 		DPRINTK(3, " DISCONNECT\n");
 		if (netif_queue_stopped(priv->net_dev))
 			netif_wake_queue(priv->net_dev);
@@ -1209,8 +1206,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 	eth_proto = ntohs(eth_hdr->h_proto);
 
 	/* for MIC FAILURE REPORT check */
-	if (eth_proto == ETHER_PROTOCOL_TYPE_EAP
-	    && priv->wpa.mic_failure.failure > 0) {
+	if (eth_proto == ETHER_PROTOCOL_TYPE_EAP &&
+	    priv->wpa.mic_failure.failure > 0) {
 		aa1x_hdr = (struct ieee802_1x_hdr *)(eth_hdr + 1);
 		if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY) {
 			eap_key = (struct wpa_eapol_key *)(aa1x_hdr + 1);
@@ -1218,11 +1215,12 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 		}
 	}
 
+
 	if (priv->wpa.rsn_enabled && priv->wpa.key[0].key_len) {
-		if (eth_proto == ETHER_PROTOCOL_TYPE_EAP
-		    && !(priv->wpa.key[1].key_len)
-		    && !(priv->wpa.key[2].key_len)
-		    && !(priv->wpa.key[3].key_len)) {
+		if (eth_proto == ETHER_PROTOCOL_TYPE_EAP &&
+		    priv->wpa.key[1].key_len == 0 &&
+		    priv->wpa.key[2].key_len == 0 &&
+		    priv->wpa.key[3].key_len == 0) {
 			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);	/* no encryption */
 		} else {
 			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
@@ -1262,10 +1260,10 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 			  (void *)skb);
 
 	/* MIC FAILURE REPORT check */
-	if (eth_proto == ETHER_PROTOCOL_TYPE_EAP
-	    && priv->wpa.mic_failure.failure > 0) {
-		if (keyinfo & WPA_KEY_INFO_ERROR
-		    && keyinfo & WPA_KEY_INFO_REQUEST) {
+	if (eth_proto == ETHER_PROTOCOL_TYPE_EAP &&
+	    priv->wpa.mic_failure.failure > 0) {
+		if (keyinfo & WPA_KEY_INFO_ERROR &&
+		    keyinfo & WPA_KEY_INFO_REQUEST) {
 			DPRINTK(3, " MIC ERROR Report SET : %04X\n", keyinfo);
 			hostif_sme_enqueue(priv, SME_MIC_FAILURE_REQUEST);
 		}
@@ -2243,8 +2241,8 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
 				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
 				       &filter_type);
-	} else if ((netdev_mc_count(dev) > NIC_MAX_MCAST_LIST)
-		   || (dev->flags & IFF_ALLMULTI)) {
+	} else if ((netdev_mc_count(dev) > NIC_MAX_MCAST_LIST) ||
+		   (dev->flags & IFF_ALLMULTI)) {
 		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCASTALL);
 		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
 				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,

commit 78037ef122afa7468c5addbb10885b984b3eef05
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:56 2017 +1000

    staging: ks7010: rename identifier packet to skb
    
    Kernel networking code predominately uses the identifier 'skb' for a struct
    sk_buff pointer. Of 8088 instances of 'struct sk_buff *' within
    net/ 6670 are named 'skb'. Following the principle of least surprise,
    new networking code should use the identifier 'skb' for variables of
    type 'struct sk_buff *'.
    
    Rename identifier 'packet' to 'skb'.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 78cdec8fd9aa..39004d81c8e5 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1107,9 +1107,9 @@ void hostif_event_check(struct ks_wlan_private *priv)
 
 #define CHECK_ALINE(size) (size % 4 ? (size + (4 - (size % 4))) : size)
 
-int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
+int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)
 {
-	unsigned int packet_len = 0;
+	unsigned int skb_len = 0;
 
 	unsigned char *buffer = NULL;
 	unsigned int length = 0;
@@ -1125,9 +1125,9 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	struct ethhdr *eth;
 	int ret;
 
-	packet_len = packet->len;
-	if (packet_len > ETH_FRAME_LEN) {
-		DPRINTK(1, "bad length packet_len=%d\n", packet_len);
+	skb_len = skb->len;
+	if (skb_len > ETH_FRAME_LEN) {
+		DPRINTK(1, "bad length skb_len=%d\n", skb_len);
 		ret = -EOVERFLOW;
 		goto err_kfree_skb;
 	}
@@ -1138,8 +1138,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 		DPRINTK(3, " DISCONNECT\n");
 		if (netif_queue_stopped(priv->net_dev))
 			netif_wake_queue(priv->net_dev);
-		if (packet)
-			dev_kfree_skb(packet);
+		if (skb)
+			dev_kfree_skb(skb);
 
 		return 0;
 	}
@@ -1150,8 +1150,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 			netif_stop_queue(priv->net_dev);
 	}
 
-	DPRINTK(4, "skb_buff length=%d\n", packet_len);
-	pp = kmalloc(hif_align_size(sizeof(*pp) + 6 + packet_len + 8),
+	DPRINTK(4, "skb_buff length=%d\n", skb_len);
+	pp = kmalloc(hif_align_size(sizeof(*pp) + 6 + skb_len + 8),
 		     KS_WLAN_MEM_FLAG);
 
 	if (!pp) {
@@ -1162,11 +1162,11 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 
 	p = (unsigned char *)pp->data;
 
-	buffer = packet->data;
-	length = packet->len;
+	buffer = skb->data;
+	length = skb->len;
 
-	/* packet check */
-	eth = (struct ethhdr *)packet->data;
+	/* skb check */
+	eth = (struct ethhdr *)skb->data;
 	if (memcmp(&priv->eth_addr[0], eth->h_source, ETH_ALEN) != 0) {
 		DPRINTK(1, "invalid mac address !!\n");
 		DPRINTK(1, "ethernet->h_source=%pM\n", eth->h_source);
@@ -1190,13 +1190,13 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 		*p++ = 0x00;	/* OUI ("000000") */
 		*p++ = 0x00;	/* OUI ("000000") */
 		*p++ = 0x00;	/* OUI ("000000") */
-		packet_len += 6;
+		skb_len += 6;
 	} else {
 		DPRINTK(4, "DIX\n");
 		/* Length(2 byte) delete */
 		buffer += 2;
 		length -= 2;
-		packet_len -= 2;
+		skb_len -= 2;
 	}
 
 	/* pp->data copy */
@@ -1226,12 +1226,12 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);	/* no encryption */
 		} else {
 			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
-				MichaelMICFunction(&michael_mic, (uint8_t *)priv->wpa.key[0].tx_mic_key, (uint8_t *)&pp->data[0], (int)packet_len, (uint8_t)0,	/* priority */
+				MichaelMICFunction(&michael_mic, (uint8_t *)priv->wpa.key[0].tx_mic_key, (uint8_t *)&pp->data[0], (int)skb_len, (uint8_t)0,	/* priority */
 						   (uint8_t *)michael_mic.
 						   Result);
 				memcpy(p, michael_mic.Result, 8);
 				length += 8;
-				packet_len += 8;
+				skb_len += 8;
 				p += 8;
 				pp->auth_type =
 				    cpu_to_le16((uint16_t)TYPE_DATA);
@@ -1252,14 +1252,14 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	/* header value set */
 	pp->header.size =
 	    cpu_to_le16((uint16_t)
-			(sizeof(*pp) - sizeof(pp->header.size) + packet_len));
+			(sizeof(*pp) - sizeof(pp->header.size) + skb_len));
 	pp->header.event = cpu_to_le16((uint16_t)HIF_DATA_REQ);
 
 	/* tx request */
 	result =
-	    ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + packet_len),
+	    ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + skb_len),
 			  (void *)send_packet_complete, (void *)priv,
-			  (void *)packet);
+			  (void *)skb);
 
 	/* MIC FAILURE REPORT check */
 	if (eth_proto == ETHER_PROTOCOL_TYPE_EAP
@@ -1278,7 +1278,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 err_kfree:
 	kfree(pp);
 err_kfree_skb:
-	dev_kfree_skb(packet);
+	dev_kfree_skb(skb);
 
 	return ret;
 }

commit 37ab542e9a8a9005b92601ee9d0b882c7ee3c13e
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:54 2017 +1000

    staging: ks7010: rename RecvMIC to recv_mic
    
    Identifier uses camel case, standard kernel style does not use camel
    case.
    
    Rename buffer 'RecvMIC' to 'recv_mic'.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index e17ce229f1a8..78cdec8fd9aa 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -312,7 +312,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 {
 	struct ether_hdr *eth_hdr;
 	unsigned short eth_proto;
-	unsigned char RecvMIC[8];
+	unsigned char recv_mic[8];
 	char buf[128];
 	unsigned long now;
 	struct mic_failure_t *mic_failure;
@@ -343,7 +343,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 		DPRINTK(4, "TKIP: protocol=%04X: size=%u\n",
 			eth_proto, priv->rx_size);
 		/* MIC save */
-		memcpy(&RecvMIC[0], (priv->rxp) + ((priv->rx_size) - 8), 8);
+		memcpy(&recv_mic[0], (priv->rxp) + ((priv->rx_size) - 8), 8);
 		priv->rx_size = priv->rx_size - 8;
 		if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
 			MichaelMICFunction(&michael_mic,
@@ -353,7 +353,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 					   (uint8_t)0,	/* priority */
 					   (uint8_t *)michael_mic.Result);
 		}
-		if (memcmp(michael_mic.Result, RecvMIC, 8) != 0) {
+		if (memcmp(michael_mic.Result, recv_mic, 8) != 0) {
 			now = jiffies;
 			mic_failure = &priv->wpa.mic_failure;
 			/* MIC FAILURE */

commit 2c4951adfae24d901c699ebb918bb6e5c7865ab7
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 22 13:06:27 2017 +1100

    staging: ks7010: invert if statement conditionals
    
    Checkpatch emits WARNING: Avoid multiple line dereference.
    
    Function uses if statement blocks to guard the body of the
    function. If we invert these conditionals and return, then the code
    becomes more readable and subsequent code is indented less. The
    checkpatch fix then follows trivially.
    
    Invert conditionals, return from function if new conditional evaluates
    to true. Reduce the level of indentation in subsequent code.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index d329735fda1d..e17ce229f1a8 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2607,16 +2607,16 @@ void hostif_sme_task(unsigned long dev)
 
 	DPRINTK(3, "\n");
 
-	if (priv->dev_state >= DEVICE_STATE_BOOT) {
-		if (cnt_smeqbody(priv) > 0) {
-			hostif_sme_execute(priv,
-					   priv->sme_i.event_buff[priv->sme_i.
-								  qhead]);
-			inc_smeqhead(priv);
-			if (cnt_smeqbody(priv) > 0)
-				tasklet_schedule(&priv->sme_task);
-		}
-	}
+	if (priv->dev_state < DEVICE_STATE_BOOT)
+		return;
+
+	if (cnt_smeqbody(priv) <= 0)
+		return;
+
+	hostif_sme_execute(priv, priv->sme_i.event_buff[priv->sme_i.qhead]);
+	inc_smeqhead(priv);
+	if (cnt_smeqbody(priv) > 0)
+		tasklet_schedule(&priv->sme_task);
 }
 
 /* send to Station Management Entity module */

commit 6ad6e21bd4e4edd1a3f59dc74b5f238455c05e71
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 22 13:06:26 2017 +1100

    staging: ks7010: remove redundant check
    
    Function checks for condition inside a loop that checks the same
    condition, this is redundant. Fix also removes checkpatch CHECK.
    
    Remove redundant check.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 38ea7a27bc08..d329735fda1d 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2608,8 +2608,7 @@ void hostif_sme_task(unsigned long dev)
 	DPRINTK(3, "\n");
 
 	if (priv->dev_state >= DEVICE_STATE_BOOT) {
-		if (cnt_smeqbody(priv) > 0
-		    && priv->dev_state >= DEVICE_STATE_BOOT) {
+		if (cnt_smeqbody(priv) > 0) {
 			hostif_sme_execute(priv,
 					   priv->sme_i.event_buff[priv->sme_i.
 								  qhead]);

commit 61082bf69662ccd32c2d9de911fc3b9d1d1adeb1
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 22 11:59:55 2017 +1100

    staging: ks7010: add braces to multi-line indent
    
    The addition of curly braces around single statements that span
    multiple lines makes the code more readable in general.
    
    Add curly braces to multi-line indented statement.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 24feee3ffa54..38ea7a27bc08 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2455,16 +2455,18 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_phy_information_request(priv);
 		break;
 	case SME_MIC_FAILURE_REQUEST:
-		if (priv->wpa.mic_failure.failure == 1)
-			hostif_mic_failure_request(
-				priv, priv->wpa.mic_failure.failure - 1, 0);
-		else if (priv->wpa.mic_failure.failure == 2)
-			hostif_mic_failure_request(
-				priv, priv->wpa.mic_failure.failure - 1,
-				priv->wpa.mic_failure.counter);
-		else
+		if (priv->wpa.mic_failure.failure == 1) {
+			hostif_mic_failure_request(priv,
+						   priv->wpa.mic_failure.failure - 1,
+						   0);
+		} else if (priv->wpa.mic_failure.failure == 2) {
+			hostif_mic_failure_request(priv,
+						   priv->wpa.mic_failure.failure - 1,
+						   priv->wpa.mic_failure.counter);
+		} else {
 			DPRINTK(4, "SME_MIC_FAILURE_REQUEST: failure count=%u error?\n",
 				priv->wpa.mic_failure.failure);
+		}
 		break;
 	case SME_MIC_FAILURE_CONFIRM:
 		if (priv->wpa.mic_failure.failure == 2) {

commit 310e916f54579b2d9a33fd6501cc46acc2d4dc70
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 22 11:59:54 2017 +1100

    staging: ks7010: add explicit check to 'size' variables
    
    When checking the value of a variable that holds a 0 an explicit check
    is good style. i.e
    
      -    if (!size)
      +    if (size == 0)
    
    Update checks on 'numerical' variables to use explicit checks.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index dc730a3c98c2..24feee3ffa54 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -129,7 +129,7 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	memcpy(ap->rate_set.body, ap_info->rate_set.body,
 	       ap_info->rate_set.size);
 	ap->rate_set.size = ap_info->rate_set.size;
-	if (ap_info->ext_rate_set.size) {
+	if (ap_info->ext_rate_set.size != 0) {
 		/* rate_set */
 		memcpy(&ap->rate_set.body[ap->rate_set.size],
 		       ap_info->ext_rate_set.body,

commit b5ca039ac17594e870a12c68ca8847700aa300dd
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 22 11:59:53 2017 +1100

    staging: ks7010: add explicit check to memcmp() calls
    
    Calls to functions memcmp() and strcmp() are more clearly readable
    when the return value is explicitly checked. i.e
    
    if (memcmp(foo, bar, size) == 0)
    
    Modify driver to use an explicit check on the value returned by
    memcmp().
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 460ab1385c09..dc730a3c98c2 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -271,7 +271,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 			memcpy(ap->rsn_ie.body, bp + 2, ap->rsn_ie.size);
 			break;
 		case 221:	/* WPA */
-			if (!memcmp(bp + 2, "\x00\x50\xf2\x01", 4)) {	/* WPA OUI check */
+			if (memcmp(bp + 2, "\x00\x50\xf2\x01", 4) == 0) {	/* WPA OUI check */
 				ap->wpa_ie.id = *bp;
 				if (*(bp + 1) <= RSN_IE_BODY_MAX) {
 					ap->wpa_ie.size = *(bp + 1);
@@ -325,7 +325,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 	eth_proto = ntohs(eth_hdr->h_proto);
 
 	/* source address check */
-	if (!memcmp(&eth_hdr->h_source[0], &priv->eth_addr[0], ETH_ALEN))
+	if (memcmp(&eth_hdr->h_source[0], &priv->eth_addr[0], ETH_ALEN) == 0)
 		return 0;
 
 	if (eth_hdr->h_dest_snap != eth_hdr->h_source_snap) {
@@ -353,7 +353,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 					   (uint8_t)0,	/* priority */
 					   (uint8_t *)michael_mic.Result);
 		}
-		if (memcmp(michael_mic.Result, RecvMIC, 8)) {
+		if (memcmp(michael_mic.Result, RecvMIC, 8) != 0) {
 			now = jiffies;
 			mic_failure = &priv->wpa.mic_failure;
 			/* MIC FAILURE */
@@ -421,7 +421,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 	DPRINTK(3, "ether protocol = %04X\n", eth_proto);
 
 	/* source address check */
-	if (!memcmp(&priv->eth_addr[0], eth_hdr->h_source, ETH_ALEN)) {
+	if (memcmp(&priv->eth_addr[0], eth_hdr->h_source, ETH_ALEN) == 0) {
 		DPRINTK(1, "invalid : source is own mac address !!\n");
 		DPRINTK(1,
 			"eth_hdrernet->h_dest=%02X:%02X:%02X:%02X:%02X:%02X\n",
@@ -836,9 +836,8 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 
 	if (priv->scan_ind_count) {
 		for (i = 0; i < priv->aplist.size; i++) {	/* bssid check */
-			if (!memcmp
-			    (ap_info->bssid,
-			     priv->aplist.ap[i].bssid, ETH_ALEN)) {
+			if (memcmp(ap_info->bssid,
+				   priv->aplist.ap[i].bssid, ETH_ALEN) == 0) {
 				if (ap_info->frame_type ==
 				    FRAME_TYPE_PROBE_RESP)
 					get_ap_information(priv, ap_info,
@@ -1168,7 +1167,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 
 	/* packet check */
 	eth = (struct ethhdr *)packet->data;
-	if (memcmp(&priv->eth_addr[0], eth->h_source, ETH_ALEN)) {
+	if (memcmp(&priv->eth_addr[0], eth->h_source, ETH_ALEN) != 0) {
 		DPRINTK(1, "invalid mac address !!\n");
 		DPRINTK(1, "ethernet->h_source=%pM\n", eth->h_source);
 		ret = -ENXIO;

commit 1770ae9d3f7f2849d7a7a24f93af44a59790a647
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:12 2017 +1100

    staging: ks7010: rename return value identifier
    
    Driver uses multiple identifier names for the same task (retval, ret,
    rc). It would be easier to read the code if a single task is
    identified with a single name. 'ret' is the most common return value
    identifier name found in the kernel tree, following the principle of
    least surprise using 'ret' is a decent choice.
    
    Rename rc -> ret
    Rename retval -> ret
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 83cda1faf7ce..460ab1385c09 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -402,7 +402,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 	unsigned short eth_proto;
 	struct ieee802_1x_hdr *aa1x_hdr;
 	struct wpa_eapol_key *eap_key;
-	int rc;
+	int ret;
 
 	DPRINTK(3, "\n");
 
@@ -434,8 +434,8 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 
 	/*  for WPA */
 	if (auth_type != TYPE_DATA && priv->wpa.rsn_enabled) {
-		rc = hostif_data_indication_wpa(priv, auth_type);
-		if (rc)
+		ret = hostif_data_indication_wpa(priv, auth_type);
+		if (ret)
 			return;
 	}
 
@@ -1124,12 +1124,12 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	struct ieee802_1x_hdr *aa1x_hdr;
 	struct wpa_eapol_key *eap_key;
 	struct ethhdr *eth;
-	int rc;
+	int ret;
 
 	packet_len = packet->len;
 	if (packet_len > ETH_FRAME_LEN) {
 		DPRINTK(1, "bad length packet_len=%d\n", packet_len);
-		rc = -EOVERFLOW;
+		ret = -EOVERFLOW;
 		goto err_kfree_skb;
 	}
 
@@ -1157,7 +1157,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
-		rc = -ENOMEM;
+		ret = -ENOMEM;
 		goto err_kfree_skb;
 	}
 
@@ -1171,7 +1171,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	if (memcmp(&priv->eth_addr[0], eth->h_source, ETH_ALEN)) {
 		DPRINTK(1, "invalid mac address !!\n");
 		DPRINTK(1, "ethernet->h_source=%pM\n", eth->h_source);
-		rc = -ENXIO;
+		ret = -ENXIO;
 		goto err_kfree;
 	}
 
@@ -1281,7 +1281,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 err_kfree_skb:
 	dev_kfree_skb(packet);
 
-	return rc;
+	return ret;
 }
 
 #define ps_confirm_wait_inc(priv) do { \

commit c133b9bd8ff18323f57859c5add3be9e872224c3
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:10 2017 +1100

    staging: ks7010: remove non-zero comparison
    
    Comparison, does not equal zero, is redundant
    
    'if (foo != 0)'  is equal to  'if (foo)'
    
    Typical kernel coding style is to use the shorter form.
    
    Remove unnecessary non-zero comparison.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 3eb0f2e5189e..83cda1faf7ce 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -528,7 +528,7 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 	mib_val_size = get_WORD(priv);	/* MIB value size */
 	mib_val_type = get_WORD(priv);	/* MIB value type */
 
-	if (mib_status != 0) {
+	if (mib_status) {
 		/* in case of error */
 		DPRINTK(1, "attribute=%08X, status=%08X\n", mib_attribute,
 			mib_status);
@@ -604,7 +604,7 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 	mib_status = get_DWORD(priv);	/* MIB Status */
 	mib_attribute = get_DWORD(priv);	/* MIB attribute */
 
-	if (mib_status != 0) {
+	if (mib_status) {
 		/* in case of error */
 		DPRINTK(1, "error :: attribute=%08X, status=%08X\n",
 			mib_attribute, mib_status);
@@ -834,7 +834,7 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 	DPRINTK(3, "scan_ind_count = %d\n", priv->scan_ind_count);
 	ap_info = (struct ap_info_t *)(priv->rxp);
 
-	if (priv->scan_ind_count != 0) {
+	if (priv->scan_ind_count) {
 		for (i = 0; i < priv->aplist.size; i++) {	/* bssid check */
 			if (!memcmp
 			    (ap_info->bssid,

commit 0185f6c9637211757256aef3f519202dcc54b231
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:07 2017 +1100

    staging: ks7010: fix checkpatch MULTIPLE_ASSIGNMENTS
    
    Checkpatch emits CHECK: multiple assignments should be avoided.
    
    Move multiple line assignment to individual lines.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 68e26f42a4c8..3eb0f2e5189e 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2682,7 +2682,8 @@ int hostif_init(struct ks_wlan_private *priv)
 		INIT_LIST_HEAD(&priv->pmklist.pmk[i].list);
 
 	priv->sme_i.sme_status = SME_IDLE;
-	priv->sme_i.qhead = priv->sme_i.qtail = 0;
+	priv->sme_i.qhead = 0;
+	priv->sme_i.qtail = 0;
 #ifdef KS_WLAN_DEBUG
 	priv->sme_i.max_event_count = 0;
 #endif

commit 5a21405ddbd58a4985081b2642837b978a5d7011
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:06 2017 +1100

    staging: ks7010: fix checkpatch BRACES
    
    Checkpatch emits CHECK: Unbalanced braces around else
    statement. Statements in question are single statements so we do not
    need braces. Checkpatch also warns about multiple line dereference for
    this code.
    
    Fix if/else/else if statement use of braces. Fix function argument layout
    at the same time since it is the same statement.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index db10e168ab3e..68e26f42a4c8 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2456,19 +2456,15 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_phy_information_request(priv);
 		break;
 	case SME_MIC_FAILURE_REQUEST:
-		if (priv->wpa.mic_failure.failure == 1) {
-			hostif_mic_failure_request(priv,
-						   priv->wpa.mic_failure.
-						   failure - 1, 0);
-		} else if (priv->wpa.mic_failure.failure == 2) {
-			hostif_mic_failure_request(priv,
-						   priv->wpa.mic_failure.
-						   failure - 1,
-						   priv->wpa.mic_failure.
-						   counter);
-		} else
-			DPRINTK(4,
-				"SME_MIC_FAILURE_REQUEST: failure count=%u error?\n",
+		if (priv->wpa.mic_failure.failure == 1)
+			hostif_mic_failure_request(
+				priv, priv->wpa.mic_failure.failure - 1, 0);
+		else if (priv->wpa.mic_failure.failure == 2)
+			hostif_mic_failure_request(
+				priv, priv->wpa.mic_failure.failure - 1,
+				priv->wpa.mic_failure.counter);
+		else
+			DPRINTK(4, "SME_MIC_FAILURE_REQUEST: failure count=%u error?\n",
 				priv->wpa.mic_failure.failure);
 		break;
 	case SME_MIC_FAILURE_CONFIRM:

commit aa6ca807baace49992ad6990c9aeda22289be5cd
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 21:20:12 2017 +1100

    staging: ks7010: remove custom return values
    
    Driver code uses custom return values (often positive) to signal error
    condition instead of using standard kernel error codes.
    
    Replace custom return values with standard kernel error codes.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 1e497171f316..db10e168ab3e 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -110,14 +110,13 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	struct local_ap_t *ap;
 	union iwreq_data wrqu;
 	struct net_device *netdev = priv->net_dev;
-	int rc = 0;
 
 	DPRINTK(3, "\n");
 	ap = &priv->current_ap;
 
 	if ((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS) {
 		memset(ap, 0, sizeof(struct local_ap_t));
-		return 1;
+		return -EPERM;
 	}
 
 	/* bssid */
@@ -198,7 +197,7 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	DPRINTK(4, "\n    ext_rate_set_size=%d\n    rate_set_size=%d\n",
 		ap_info->ext_rate_set.size, ap_info->rate_set.size);
 
-	return rc;
+	return 0;
 }
 
 static
@@ -1125,12 +1124,13 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	struct ieee802_1x_hdr *aa1x_hdr;
 	struct wpa_eapol_key *eap_key;
 	struct ethhdr *eth;
+	int rc;
 
 	packet_len = packet->len;
 	if (packet_len > ETH_FRAME_LEN) {
 		DPRINTK(1, "bad length packet_len=%d\n", packet_len);
-		dev_kfree_skb(packet);
-		return -1;
+		rc = -EOVERFLOW;
+		goto err_kfree_skb;
 	}
 
 	if (((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS)
@@ -1157,8 +1157,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
-		dev_kfree_skb(packet);
-		return -2;
+		rc = -ENOMEM;
+		goto err_kfree_skb;
 	}
 
 	p = (unsigned char *)pp->data;
@@ -1171,9 +1171,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	if (memcmp(&priv->eth_addr[0], eth->h_source, ETH_ALEN)) {
 		DPRINTK(1, "invalid mac address !!\n");
 		DPRINTK(1, "ethernet->h_source=%pM\n", eth->h_source);
-		dev_kfree_skb(packet);
-		kfree(pp);
-		return -3;
+		rc = -ENXIO;
+		goto err_kfree;
 	}
 
 	/* MAC address copy */
@@ -1276,6 +1275,13 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	}
 
 	return result;
+
+err_kfree:
+	kfree(pp);
+err_kfree_skb:
+	dev_kfree_skb(packet);
+
+	return rc;
 }
 
 #define ps_confirm_wait_inc(priv) do { \

commit 86ea6167cde51212319155c8515db22d58bf89b6
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 10:46:42 2017 +1100

    staging: ks7010: fix spelling of Michael MIC
    
    Driver mixes spelling michael and michel in symbol names and
    comments. Michael here references the IEEE 802.11i Message Integrity
    Code. It is incorrect to spell it michel and confusing having two
    spellings for the same thing.
    
    Change michel -> micheal in both symbol names and comments.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 310928fe2991..1e497171f316 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -317,7 +317,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 	char buf[128];
 	unsigned long now;
 	struct mic_failure_t *mic_failure;
-	struct michel_mic_t michel_mic;
+	struct michael_mic_t michael_mic;
 	union iwreq_data wrqu;
 	unsigned int key_index = auth_type - 1;
 	struct wpa_key_t *key = &priv->wpa.key[key_index];
@@ -347,14 +347,14 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 		memcpy(&RecvMIC[0], (priv->rxp) + ((priv->rx_size) - 8), 8);
 		priv->rx_size = priv->rx_size - 8;
 		if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
-			MichaelMICFunction(&michel_mic,
+			MichaelMICFunction(&michael_mic,
 					   (uint8_t *)key->rx_mic_key,
 					   (uint8_t *)priv->rxp,
 					   (int)priv->rx_size,
 					   (uint8_t)0,	/* priority */
-					   (uint8_t *)michel_mic.Result);
+					   (uint8_t *)michael_mic.Result);
 		}
-		if (memcmp(michel_mic.Result, RecvMIC, 8)) {
+		if (memcmp(michael_mic.Result, RecvMIC, 8)) {
 			now = jiffies;
 			mic_failure = &priv->wpa.mic_failure;
 			/* MIC FAILURE */
@@ -1120,7 +1120,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	int result = 0;
 	unsigned short eth_proto;
 	struct ether_hdr *eth_hdr;
-	struct michel_mic_t michel_mic;
+	struct michael_mic_t michael_mic;
 	unsigned short keyinfo = 0;
 	struct ieee802_1x_hdr *aa1x_hdr;
 	struct wpa_eapol_key *eap_key;
@@ -1228,10 +1228,10 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);	/* no encryption */
 		} else {
 			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
-				MichaelMICFunction(&michel_mic, (uint8_t *)priv->wpa.key[0].tx_mic_key, (uint8_t *)&pp->data[0], (int)packet_len, (uint8_t)0,	/* priority */
-						   (uint8_t *)michel_mic.
+				MichaelMICFunction(&michael_mic, (uint8_t *)priv->wpa.key[0].tx_mic_key, (uint8_t *)&pp->data[0], (int)packet_len, (uint8_t)0,	/* priority */
+						   (uint8_t *)michael_mic.
 						   Result);
-				memcpy(p, michel_mic.Result, 8);
+				memcpy(p, michael_mic.Result, 8);
 				length += 8;
 				packet_len += 8;
 				p += 8;

commit dfe41b4f4c8d9d46a95da6959d2852757dfa8b3b
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Mar 13 17:38:22 2017 +1100

    staging: ks7010: add variables key, key_index
    
    'auth_type - 1' is used as an index into a key table. Adding a variable
    appropriately named simplifies the code and adds meaning when
    reading. Adding a pointer variable of type struct *kpa_key_t adds to
    readability by removing the table access each time the key is used.
    
    The key index is used to create a string so having it named adds
    additional meaning when creating the string.
    
    Declare variable 'key_index' and define it at declaration time. Declare
    a pointer variable 'key' and define it to point to the correct key in
    the key table.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index a93b104a5116..310928fe2991 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -319,6 +319,8 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 	struct mic_failure_t *mic_failure;
 	struct michel_mic_t michel_mic;
 	union iwreq_data wrqu;
+	unsigned int key_index = auth_type - 1;
+	struct wpa_key_t *key = &priv->wpa.key[key_index];
 
 	eth_hdr = (struct ether_hdr *)(priv->rxp);
 	eth_proto = ntohs(eth_hdr->h_proto);
@@ -338,7 +340,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 	      priv->wpa.group_suite == IW_AUTH_CIPHER_TKIP) ||
 	     (auth_type == TYPE_GMK2 &&
 	      priv->wpa.group_suite == IW_AUTH_CIPHER_TKIP)) &&
-	    priv->wpa.key[auth_type - 1].key_len) {
+	    key->key_len) {
 		DPRINTK(4, "TKIP: protocol=%04X: size=%u\n",
 			eth_proto, priv->rx_size);
 		/* MIC save */
@@ -346,7 +348,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 		priv->rx_size = priv->rx_size - 8;
 		if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
 			MichaelMICFunction(&michel_mic,
-					   (uint8_t *)priv->wpa.key[auth_type - 1].rx_mic_key,
+					   (uint8_t *)key->rx_mic_key,
 					   (uint8_t *)priv->rxp,
 					   (int)priv->rx_size,
 					   (uint8_t)0,	/* priority */
@@ -376,7 +378,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 			/*  needed parameters: count, keyid, key type, TSC */
 			sprintf(buf,
 				"MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr=%pM)",
-				auth_type - 1,
+				key_index,
 				eth_hdr->h_dest[0] & 0x01 ? "broad" : "uni",
 				eth_hdr->h_source);
 			memset(&wrqu, 0, sizeof(wrqu));

commit 1b45ba65091483cbdfae57b2afc256936e3a3d96
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Mar 13 17:38:21 2017 +1100

    staging: ks7010: reduce length of comment string
    
    Comment string is unnecessarily verbose. Checkpatch emits WARNING:
    line over 80 characters.
    
    Reduce comment string without loss of meaning.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index f262e399318f..a93b104a5116 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -368,7 +368,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 				mic_failure->failure = 2;
 				mic_failure->counter =
 					(uint16_t)((now - mic_failure->last_failure_time) / HZ);
-				if (!mic_failure->counter)	/* mic_failure counter value range 1-60 */
+				if (!mic_failure->counter)	/*  range 1-60 */
 					mic_failure->counter = 1;
 			}
 			priv->wpa.mic_failure.last_failure_time = now;

commit 6e37c7154a91bde5ca8b7f9bf2bec93518f74553
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Mar 13 17:38:20 2017 +1100

    staging: ks7010: move quoted string onto single line
    
    Checkpatch emits WARNING: quoted string split across lines. Line is
    already over 80 characters long, adding 3 more does little to effect
    line length while improving readibility.
    
    Concatenate split string into single line.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 5bb9f3526f60..f262e399318f 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -375,8 +375,7 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 
 			/*  needed parameters: count, keyid, key type, TSC */
 			sprintf(buf,
-				"MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
-				"%pM)",
+				"MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr=%pM)",
 				auth_type - 1,
 				eth_hdr->h_dest[0] & 0x01 ? "broad" : "uni",
 				eth_hdr->h_source);

commit c60b486d4bbb65c764b654588bb0e90bd953d1d5
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Mar 13 17:38:19 2017 +1100

    staging: ks7010: refactor newly separated function
    
    Checkpatch emits various warnings and checks;
    
    WARNING: Avoid multiple line dereference
    CHECK: Alignment should match open parenthesis
    WARNING: line over 80 characters
    CHECK: Blank lines aren't necessary before a close brace '}'
    
    These are all whitespace fixes.
    
    Refactor whitespace inline with kernel coding style. Fix various
    checkpatch warnings.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 461482b6e479..5bb9f3526f60 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -342,21 +342,22 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 		DPRINTK(4, "TKIP: protocol=%04X: size=%u\n",
 			eth_proto, priv->rx_size);
 		/* MIC save */
-		memcpy(&RecvMIC[0],
-			(priv->rxp) + ((priv->rx_size) - 8), 8);
+		memcpy(&RecvMIC[0], (priv->rxp) + ((priv->rx_size) - 8), 8);
 		priv->rx_size = priv->rx_size - 8;
 		if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
-			MichaelMICFunction(&michel_mic, (uint8_t *)priv->wpa.key[auth_type - 1].rx_mic_key, (uint8_t *)priv->rxp, (int)priv->rx_size, (uint8_t)0,	/* priority */
-					(uint8_t *)michel_mic.Result);
+			MichaelMICFunction(&michel_mic,
+					   (uint8_t *)priv->wpa.key[auth_type - 1].rx_mic_key,
+					   (uint8_t *)priv->rxp,
+					   (int)priv->rx_size,
+					   (uint8_t)0,	/* priority */
+					   (uint8_t *)michel_mic.Result);
 		}
 		if (memcmp(michel_mic.Result, RecvMIC, 8)) {
 			now = jiffies;
 			mic_failure = &priv->wpa.mic_failure;
 			/* MIC FAILURE */
 			if (mic_failure->last_failure_time &&
-				(now -
-					mic_failure->last_failure_time) /
-				HZ >= 60) {
+			    (now - mic_failure->last_failure_time) / HZ >= 60) {
 				mic_failure->failure = 0;
 			}
 			DPRINTK(4, "MIC FAILURE\n");
@@ -366,39 +367,30 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 			} else if (mic_failure->failure == 1) {
 				mic_failure->failure = 2;
 				mic_failure->counter =
-					(uint16_t)((now -
-							mic_failure->
-							last_failure_time)
-						/ HZ);
+					(uint16_t)((now - mic_failure->last_failure_time) / HZ);
 				if (!mic_failure->counter)	/* mic_failure counter value range 1-60 */
-					mic_failure->counter =
-						1;
+					mic_failure->counter = 1;
 			}
-			priv->wpa.mic_failure.
-				last_failure_time = now;
+			priv->wpa.mic_failure.last_failure_time = now;
+
 			/*  needed parameters: count, keyid, key type, TSC */
 			sprintf(buf,
 				"MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
 				"%pM)",
 				auth_type - 1,
-				eth_hdr->
-				h_dest[0] & 0x01 ? "broad" :
-				"uni", eth_hdr->h_source);
+				eth_hdr->h_dest[0] & 0x01 ? "broad" : "uni",
+				eth_hdr->h_source);
 			memset(&wrqu, 0, sizeof(wrqu));
 			wrqu.data.length = strlen(buf);
-			DPRINTK(4,
-				"IWEVENT:MICHAELMICFAILURE\n");
-			wireless_send_event(priv->net_dev,
-					IWEVCUSTOM, &wrqu,
-					buf);
+			DPRINTK(4, "IWEVENT:MICHAELMICFAILURE\n");
+			wireless_send_event(priv->net_dev, IWEVCUSTOM, &wrqu,
+					    buf);
 			return -EINVAL;
-
 		}
 	}
 	return 0;
 }
 
-
 static
 void hostif_data_indication(struct ks_wlan_private *priv)
 {

commit 6422c6efb3b1d296ee2b79b6961a02952a75ee53
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Mar 13 17:38:18 2017 +1100

    staging: ks7010: fix line continuations
    
    Checkpatch emits CHECK: Logical continuations should be on the
    previous line. Also the same code section causes checkpatch to emit
    WARNING: Avoid multiple line dereference.
    
    Move logical line continuations onto the previous line. Move multiple
    line dereferences onto single line.
    
    Make these two changes in a single patch to give review a chance
    to critique the final layout of the *complex* logical statement.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 54ff06d1e799..461482b6e479 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -332,16 +332,13 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 		priv->nstats.rx_errors++;
 		return -EINVAL;
 	}
-	if (((auth_type == TYPE_PMK1
-				&& priv->wpa.pairwise_suite ==
-				IW_AUTH_CIPHER_TKIP) || (auth_type == TYPE_GMK1
-							&& priv->wpa.
-							group_suite ==
-							IW_AUTH_CIPHER_TKIP)
-			|| (auth_type == TYPE_GMK2
-				&& priv->wpa.group_suite ==
-				IW_AUTH_CIPHER_TKIP))
-		&& priv->wpa.key[auth_type - 1].key_len) {
+	if (((auth_type == TYPE_PMK1 &&
+	      priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) ||
+	     (auth_type == TYPE_GMK1 &&
+	      priv->wpa.group_suite == IW_AUTH_CIPHER_TKIP) ||
+	     (auth_type == TYPE_GMK2 &&
+	      priv->wpa.group_suite == IW_AUTH_CIPHER_TKIP)) &&
+	    priv->wpa.key[auth_type - 1].key_len) {
 		DPRINTK(4, "TKIP: protocol=%04X: size=%u\n",
 			eth_proto, priv->rx_size);
 		/* MIC save */

commit dfd6b480c9e63d520aac932b2ed1a729a1f4a6a6
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Mar 13 17:38:17 2017 +1100

    staging: ks7010: reduce level of indentation
    
    Code is deeply nested. One level of indentation may be removed by
    inverting if statement conditional.
    
    Invert conditional, return if new conditional evaluates to true.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index ed9969c6f59a..54ff06d1e799 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -323,77 +323,79 @@ int hostif_data_indication_wpa(struct ks_wlan_private *priv,
 	eth_hdr = (struct ether_hdr *)(priv->rxp);
 	eth_proto = ntohs(eth_hdr->h_proto);
 
-	if (memcmp(&eth_hdr->h_source[0], &priv->eth_addr[0], ETH_ALEN)) {	/* source address check */
-		if (eth_hdr->h_dest_snap != eth_hdr->h_source_snap) {
-			DPRINTK(1, "invalid data format\n");
-			priv->nstats.rx_errors++;
-			return -EINVAL;
+	/* source address check */
+	if (!memcmp(&eth_hdr->h_source[0], &priv->eth_addr[0], ETH_ALEN))
+		return 0;
+
+	if (eth_hdr->h_dest_snap != eth_hdr->h_source_snap) {
+		DPRINTK(1, "invalid data format\n");
+		priv->nstats.rx_errors++;
+		return -EINVAL;
+	}
+	if (((auth_type == TYPE_PMK1
+				&& priv->wpa.pairwise_suite ==
+				IW_AUTH_CIPHER_TKIP) || (auth_type == TYPE_GMK1
+							&& priv->wpa.
+							group_suite ==
+							IW_AUTH_CIPHER_TKIP)
+			|| (auth_type == TYPE_GMK2
+				&& priv->wpa.group_suite ==
+				IW_AUTH_CIPHER_TKIP))
+		&& priv->wpa.key[auth_type - 1].key_len) {
+		DPRINTK(4, "TKIP: protocol=%04X: size=%u\n",
+			eth_proto, priv->rx_size);
+		/* MIC save */
+		memcpy(&RecvMIC[0],
+			(priv->rxp) + ((priv->rx_size) - 8), 8);
+		priv->rx_size = priv->rx_size - 8;
+		if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
+			MichaelMICFunction(&michel_mic, (uint8_t *)priv->wpa.key[auth_type - 1].rx_mic_key, (uint8_t *)priv->rxp, (int)priv->rx_size, (uint8_t)0,	/* priority */
+					(uint8_t *)michel_mic.Result);
 		}
-		if (((auth_type == TYPE_PMK1
-					&& priv->wpa.pairwise_suite ==
-					IW_AUTH_CIPHER_TKIP) || (auth_type == TYPE_GMK1
-								&& priv->wpa.
-								group_suite ==
-								IW_AUTH_CIPHER_TKIP)
-				|| (auth_type == TYPE_GMK2
-					&& priv->wpa.group_suite ==
-					IW_AUTH_CIPHER_TKIP))
-			&& priv->wpa.key[auth_type - 1].key_len) {
-			DPRINTK(4, "TKIP: protocol=%04X: size=%u\n",
-				eth_proto, priv->rx_size);
-			/* MIC save */
-			memcpy(&RecvMIC[0],
-				(priv->rxp) + ((priv->rx_size) - 8), 8);
-			priv->rx_size = priv->rx_size - 8;
-			if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
-				MichaelMICFunction(&michel_mic, (uint8_t *)priv->wpa.key[auth_type - 1].rx_mic_key, (uint8_t *)priv->rxp, (int)priv->rx_size, (uint8_t)0,	/* priority */
-						(uint8_t *)michel_mic.Result);
+		if (memcmp(michel_mic.Result, RecvMIC, 8)) {
+			now = jiffies;
+			mic_failure = &priv->wpa.mic_failure;
+			/* MIC FAILURE */
+			if (mic_failure->last_failure_time &&
+				(now -
+					mic_failure->last_failure_time) /
+				HZ >= 60) {
+				mic_failure->failure = 0;
 			}
-			if (memcmp(michel_mic.Result, RecvMIC, 8)) {
-				now = jiffies;
-				mic_failure = &priv->wpa.mic_failure;
-				/* MIC FAILURE */
-				if (mic_failure->last_failure_time &&
-					(now -
-						mic_failure->last_failure_time) /
-					HZ >= 60) {
-					mic_failure->failure = 0;
-				}
-				DPRINTK(4, "MIC FAILURE\n");
-				if (mic_failure->failure == 0) {
-					mic_failure->failure = 1;
-					mic_failure->counter = 0;
-				} else if (mic_failure->failure == 1) {
-					mic_failure->failure = 2;
+			DPRINTK(4, "MIC FAILURE\n");
+			if (mic_failure->failure == 0) {
+				mic_failure->failure = 1;
+				mic_failure->counter = 0;
+			} else if (mic_failure->failure == 1) {
+				mic_failure->failure = 2;
+				mic_failure->counter =
+					(uint16_t)((now -
+							mic_failure->
+							last_failure_time)
+						/ HZ);
+				if (!mic_failure->counter)	/* mic_failure counter value range 1-60 */
 					mic_failure->counter =
-						(uint16_t)((now -
-								mic_failure->
-								last_failure_time)
-							/ HZ);
-					if (!mic_failure->counter)	/* mic_failure counter value range 1-60 */
-						mic_failure->counter =
-							1;
-				}
-				priv->wpa.mic_failure.
-					last_failure_time = now;
-				/*  needed parameters: count, keyid, key type, TSC */
-				sprintf(buf,
-					"MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
-					"%pM)",
-					auth_type - 1,
-					eth_hdr->
-					h_dest[0] & 0x01 ? "broad" :
-					"uni", eth_hdr->h_source);
-				memset(&wrqu, 0, sizeof(wrqu));
-				wrqu.data.length = strlen(buf);
-				DPRINTK(4,
-					"IWEVENT:MICHAELMICFAILURE\n");
-				wireless_send_event(priv->net_dev,
-						IWEVCUSTOM, &wrqu,
-						buf);
-				return -EINVAL;
-
+						1;
 			}
+			priv->wpa.mic_failure.
+				last_failure_time = now;
+			/*  needed parameters: count, keyid, key type, TSC */
+			sprintf(buf,
+				"MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
+				"%pM)",
+				auth_type - 1,
+				eth_hdr->
+				h_dest[0] & 0x01 ? "broad" :
+				"uni", eth_hdr->h_source);
+			memset(&wrqu, 0, sizeof(wrqu));
+			wrqu.data.length = strlen(buf);
+			DPRINTK(4,
+				"IWEVENT:MICHAELMICFAILURE\n");
+			wireless_send_event(priv->net_dev,
+					IWEVCUSTOM, &wrqu,
+					buf);
+			return -EINVAL;
+
 		}
 	}
 	return 0;

commit 034a7178d21381d82dd83330776cff30a707bc00
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Mar 13 17:38:16 2017 +1100

    staging: ks7010: move WPA code to separate function
    
    Checkpatch emits WARNING: Too many leading tabs - consider code
    refactoring. Function contains 5 levels of nesting and 14 local
    variables. Code can be simplified and nesting reduced by refactoring
    into separate functions.
    
    WPA code is contained and may be factored out into a separate
    function. This will reduce the length and complexity of
    hostif_data_indication(). At times within the WPA code errors result
    in the function returning. In order to maintain this behaviour new
    function should return a status integer.
    
    Factor out WPA code into separate function. Add only code needed to
    get compilation to pass, including modifying return statements. Make
    no other code changes, program logic is unchanged.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index b1fff903bce6..ed9969c6f59a 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -307,6 +307,99 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 	return 0;
 }
 
+static
+int hostif_data_indication_wpa(struct ks_wlan_private *priv,
+			       unsigned short auth_type)
+{
+	struct ether_hdr *eth_hdr;
+	unsigned short eth_proto;
+	unsigned char RecvMIC[8];
+	char buf[128];
+	unsigned long now;
+	struct mic_failure_t *mic_failure;
+	struct michel_mic_t michel_mic;
+	union iwreq_data wrqu;
+
+	eth_hdr = (struct ether_hdr *)(priv->rxp);
+	eth_proto = ntohs(eth_hdr->h_proto);
+
+	if (memcmp(&eth_hdr->h_source[0], &priv->eth_addr[0], ETH_ALEN)) {	/* source address check */
+		if (eth_hdr->h_dest_snap != eth_hdr->h_source_snap) {
+			DPRINTK(1, "invalid data format\n");
+			priv->nstats.rx_errors++;
+			return -EINVAL;
+		}
+		if (((auth_type == TYPE_PMK1
+					&& priv->wpa.pairwise_suite ==
+					IW_AUTH_CIPHER_TKIP) || (auth_type == TYPE_GMK1
+								&& priv->wpa.
+								group_suite ==
+								IW_AUTH_CIPHER_TKIP)
+				|| (auth_type == TYPE_GMK2
+					&& priv->wpa.group_suite ==
+					IW_AUTH_CIPHER_TKIP))
+			&& priv->wpa.key[auth_type - 1].key_len) {
+			DPRINTK(4, "TKIP: protocol=%04X: size=%u\n",
+				eth_proto, priv->rx_size);
+			/* MIC save */
+			memcpy(&RecvMIC[0],
+				(priv->rxp) + ((priv->rx_size) - 8), 8);
+			priv->rx_size = priv->rx_size - 8;
+			if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
+				MichaelMICFunction(&michel_mic, (uint8_t *)priv->wpa.key[auth_type - 1].rx_mic_key, (uint8_t *)priv->rxp, (int)priv->rx_size, (uint8_t)0,	/* priority */
+						(uint8_t *)michel_mic.Result);
+			}
+			if (memcmp(michel_mic.Result, RecvMIC, 8)) {
+				now = jiffies;
+				mic_failure = &priv->wpa.mic_failure;
+				/* MIC FAILURE */
+				if (mic_failure->last_failure_time &&
+					(now -
+						mic_failure->last_failure_time) /
+					HZ >= 60) {
+					mic_failure->failure = 0;
+				}
+				DPRINTK(4, "MIC FAILURE\n");
+				if (mic_failure->failure == 0) {
+					mic_failure->failure = 1;
+					mic_failure->counter = 0;
+				} else if (mic_failure->failure == 1) {
+					mic_failure->failure = 2;
+					mic_failure->counter =
+						(uint16_t)((now -
+								mic_failure->
+								last_failure_time)
+							/ HZ);
+					if (!mic_failure->counter)	/* mic_failure counter value range 1-60 */
+						mic_failure->counter =
+							1;
+				}
+				priv->wpa.mic_failure.
+					last_failure_time = now;
+				/*  needed parameters: count, keyid, key type, TSC */
+				sprintf(buf,
+					"MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
+					"%pM)",
+					auth_type - 1,
+					eth_hdr->
+					h_dest[0] & 0x01 ? "broad" :
+					"uni", eth_hdr->h_source);
+				memset(&wrqu, 0, sizeof(wrqu));
+				wrqu.data.length = strlen(buf);
+				DPRINTK(4,
+					"IWEVENT:MICHAELMICFAILURE\n");
+				wireless_send_event(priv->net_dev,
+						IWEVCUSTOM, &wrqu,
+						buf);
+				return -EINVAL;
+
+			}
+		}
+	}
+	return 0;
+}
+
+
 static
 void hostif_data_indication(struct ks_wlan_private *priv)
 {
@@ -314,17 +407,11 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 	struct sk_buff *skb;
 	unsigned short auth_type;
 	unsigned char temp[256];
-
-	unsigned char RecvMIC[8];
-	char buf[128];
 	struct ether_hdr *eth_hdr;
 	unsigned short eth_proto;
-	unsigned long now;
-	struct mic_failure_t *mic_failure;
 	struct ieee802_1x_hdr *aa1x_hdr;
 	struct wpa_eapol_key *eap_key;
-	struct michel_mic_t michel_mic;
-	union iwreq_data wrqu;
+	int rc;
 
 	DPRINTK(3, "\n");
 
@@ -356,78 +443,9 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 
 	/*  for WPA */
 	if (auth_type != TYPE_DATA && priv->wpa.rsn_enabled) {
-		if (memcmp(&eth_hdr->h_source[0], &priv->eth_addr[0], ETH_ALEN)) {	/* source address check */
-			if (eth_hdr->h_dest_snap != eth_hdr->h_source_snap) {
-				DPRINTK(1, "invalid data format\n");
-				priv->nstats.rx_errors++;
-				return;
-			}
-			if (((auth_type == TYPE_PMK1
-			      && priv->wpa.pairwise_suite ==
-			      IW_AUTH_CIPHER_TKIP) || (auth_type == TYPE_GMK1
-						       && priv->wpa.
-						       group_suite ==
-						       IW_AUTH_CIPHER_TKIP)
-			     || (auth_type == TYPE_GMK2
-				 && priv->wpa.group_suite ==
-				 IW_AUTH_CIPHER_TKIP))
-			    && priv->wpa.key[auth_type - 1].key_len) {
-				DPRINTK(4, "TKIP: protocol=%04X: size=%u\n",
-					eth_proto, priv->rx_size);
-				/* MIC save */
-				memcpy(&RecvMIC[0],
-				       (priv->rxp) + ((priv->rx_size) - 8), 8);
-				priv->rx_size = priv->rx_size - 8;
-				if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
-					MichaelMICFunction(&michel_mic, (uint8_t *)priv->wpa.key[auth_type - 1].rx_mic_key, (uint8_t *)priv->rxp, (int)priv->rx_size, (uint8_t)0,	/* priority */
-							   (uint8_t *)michel_mic.Result);
-				}
-				if (memcmp(michel_mic.Result, RecvMIC, 8)) {
-					now = jiffies;
-					mic_failure = &priv->wpa.mic_failure;
-					/* MIC FAILURE */
-					if (mic_failure->last_failure_time &&
-					    (now -
-					     mic_failure->last_failure_time) /
-					    HZ >= 60) {
-						mic_failure->failure = 0;
-					}
-					DPRINTK(4, "MIC FAILURE\n");
-					if (mic_failure->failure == 0) {
-						mic_failure->failure = 1;
-						mic_failure->counter = 0;
-					} else if (mic_failure->failure == 1) {
-						mic_failure->failure = 2;
-						mic_failure->counter =
-						    (uint16_t)((now -
-								 mic_failure->
-								 last_failure_time)
-								/ HZ);
-						if (!mic_failure->counter)	/* mic_failure counter value range 1-60 */
-							mic_failure->counter =
-							    1;
-					}
-					priv->wpa.mic_failure.
-					    last_failure_time = now;
-					/*  needed parameters: count, keyid, key type, TSC */
-					sprintf(buf,
-						"MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
-						"%pM)",
-						auth_type - 1,
-						eth_hdr->
-						h_dest[0] & 0x01 ? "broad" :
-						"uni", eth_hdr->h_source);
-					memset(&wrqu, 0, sizeof(wrqu));
-					wrqu.data.length = strlen(buf);
-					DPRINTK(4,
-						"IWEVENT:MICHAELMICFAILURE\n");
-					wireless_send_event(priv->net_dev,
-							    IWEVCUSTOM, &wrqu,
-							    buf);
-					return;
-				}
-			}
-		}
+		rc = hostif_data_indication_wpa(priv, auth_type);
+		if (rc)
+			return;
 	}
 
 	if ((priv->connect_status & FORCE_DISCONNECT) ||

commit 5e4e2ef774138958036cfe1dd7a907c7dd3cb1bb
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Sun Mar 12 03:30:01 2017 +0100

    Staging: ks7010: ks_hostif.*: Use preferred 'u32' kernel type over 'uint32_t'
    
    Fix prefer kernel type 'u32' over 'uint32_t' checks.
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 2cbb04305f33..b1fff903bce6 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -507,8 +507,8 @@ static
 void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 {
 	struct net_device *dev = priv->net_dev;
-	uint32_t mib_status;
-	uint32_t mib_attribute;
+	u32 mib_status;
+	u32 mib_attribute;
 	u16 mib_val_size;
 	u16 mib_val_type;
 
@@ -587,8 +587,8 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 static
 void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 {
-	uint32_t mib_status;	/* +04 MIB Status */
-	uint32_t mib_attribute;	/* +08 MIB attribute */
+	u32 mib_status;	/* +04 MIB Status */
+	u32 mib_attribute;	/* +08 MIB attribute */
 
 	DPRINTK(3, "\n");
 
@@ -1864,7 +1864,7 @@ void hostif_receive(struct ks_wlan_private *priv, unsigned char *p,
 static
 void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 {
-	uint32_t val;
+	u32 val;
 
 	switch (type) {
 	case SME_WEP_INDEX_REQUEST:
@@ -1918,7 +1918,7 @@ struct wpa_suite_t {
 } __packed;
 
 struct rsn_mode_t {
-	uint32_t rsn_mode;
+	u32 rsn_mode;
 	u16 rsn_capability;
 } __packed;
 
@@ -1927,7 +1927,7 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 {
 	struct wpa_suite_t wpa_suite;
 	struct rsn_mode_t rsn_mode;
-	uint32_t val;
+	u32 val;
 
 	memset(&wpa_suite, 0, sizeof(wpa_suite));
 
@@ -2323,7 +2323,7 @@ void hostif_sme_sleep_set(struct ks_wlan_private *priv)
 static
 void hostif_sme_set_key(struct ks_wlan_private *priv, int type)
 {
-	uint32_t val;
+	u32 val;
 
 	switch (type) {
 	case SME_SET_FLAG:
@@ -2413,7 +2413,7 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 static
 void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 {
-	uint32_t val;
+	u32 val;
 
 	DPRINTK(3, "event=%d\n", event);
 	switch (event) {

commit 81952f3876c2cef2a7310f2154d4061ad519ba64
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Sun Mar 12 03:30:00 2017 +0100

    Staging: ks7010: ks_hostif.*: Use preferred 'u16' kernel type over 'uint16_t'
    
    Fix prefer kernel type 'u16' over 'uint16_t' checks.
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 0d6bbe61131c..2cbb04305f33 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -509,8 +509,8 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 	struct net_device *dev = priv->net_dev;
 	uint32_t mib_status;
 	uint32_t mib_attribute;
-	uint16_t mib_val_size;
-	uint16_t mib_val_type;
+	u16 mib_val_size;
+	u16 mib_val_type;
 
 	DPRINTK(3, "\n");
 
@@ -901,7 +901,7 @@ void hostif_ps_adhoc_set_confirm(struct ks_wlan_private *priv)
 static
 void hostif_infrastructure_set_confirm(struct ks_wlan_private *priv)
 {
-	uint16_t result_code;
+	u16 result_code;
 
 	DPRINTK(3, "\n");
 	result_code = get_WORD(priv);
@@ -1364,7 +1364,7 @@ static
 void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 {
 	struct hostif_ps_adhoc_set_request_t *pp;
-	uint16_t capability;
+	u16 capability;
 
 	DPRINTK(3, "\n");
 
@@ -1407,7 +1407,7 @@ static
 void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 {
 	struct hostif_infrastructure_set_request_t *pp;
-	uint16_t capability;
+	u16 capability;
 
 	DPRINTK(3, "ssid.size=%d\n", priv->reg.ssid.size);
 
@@ -1473,7 +1473,7 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 {
 	struct hostif_infrastructure_set2_request_t *pp;
-	uint16_t capability;
+	u16 capability;
 
 	DPRINTK(2, "ssid.size=%d\n", priv->reg.ssid.size);
 
@@ -1542,7 +1542,7 @@ static
 void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 {
 	struct hostif_adhoc_set_request_t *pp;
-	uint16_t capability;
+	u16 capability;
 
 	DPRINTK(3, "\n");
 
@@ -1587,7 +1587,7 @@ static
 void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 {
 	struct hostif_adhoc_set2_request_t *pp;
-	uint16_t capability;
+	u16 capability;
 
 	DPRINTK(3, "\n");
 
@@ -1919,7 +1919,7 @@ struct wpa_suite_t {
 
 struct rsn_mode_t {
 	uint32_t rsn_mode;
-	uint16_t rsn_capability;
+	u16 rsn_capability;
 } __packed;
 
 static
@@ -2382,7 +2382,7 @@ static
 void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 {
 	struct pmk_cache_t {
-		uint16_t size;
+		u16 size;
 		struct {
 			u8 bssid[ETH_ALEN];
 			u8 pmkid[IW_PMKID_LEN];

commit 184eb0c5b6d7293947bd02058eef9323cc2c8631
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Sun Mar 12 03:29:59 2017 +0100

    Staging: ks7010: ks_*: Use preferred 'u8' kernel type over 'uint8_t'
    
    Fix prefer kernel type 'u8' over 'uint8_t' checks.
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 6522bc3d30d5..0d6bbe61131c 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2384,8 +2384,8 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 	struct pmk_cache_t {
 		uint16_t size;
 		struct {
-			uint8_t bssid[ETH_ALEN];
-			uint8_t pmkid[IW_PMKID_LEN];
+			u8 bssid[ETH_ALEN];
+			u8 pmkid[IW_PMKID_LEN];
 		} __packed list[PMK_LIST_MAX];
 	} __packed pmkcache;
 	struct pmk_t *pmk;

commit 745cab03e94c605de8b6966b770f6d520fa70107
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Mar 9 15:47:02 2017 +1100

    staging: ks7010: fix checkpatch CONSTANT_COMPARISON
    
    Checkpatch emits WARNING: Comparisons should place the constant on the
    right side of the test.
    
    Move comparison constant to the right side of the test.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index bf77483cbf51..6522bc3d30d5 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2595,13 +2595,13 @@ void hostif_sme_task(unsigned long dev)
 	DPRINTK(3, "\n");
 
 	if (priv->dev_state >= DEVICE_STATE_BOOT) {
-		if (0 < cnt_smeqbody(priv)
+		if (cnt_smeqbody(priv) > 0
 		    && priv->dev_state >= DEVICE_STATE_BOOT) {
 			hostif_sme_execute(priv,
 					   priv->sme_i.event_buff[priv->sme_i.
 								  qhead]);
 			inc_smeqhead(priv);
-			if (0 < cnt_smeqbody(priv))
+			if (cnt_smeqbody(priv) > 0)
 				tasklet_schedule(&priv->sme_task);
 		}
 	}

commit c88ff5ae49a7f0e9eb2da2ddaba58475d45fbf31
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Mar 9 15:47:01 2017 +1100

    staging: ks7010: fix checkpatch whitespace warnings
    
    Checkpatch emits various warnings/errors pointing to misplaced
    spaces.
    
    - trailing whitespace
    - please, no spaces at the start of a line
    - please, no space before tabs
    - Unnecessary space before function pointer arguments
    - unnecessary whitespace before a quoted newline
    - code indent should use tabs where possible
    
    Remove all undesirable whitespace.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 946bb784935f..bf77483cbf51 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2616,14 +2616,12 @@ void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
 	if (cnt_smeqbody(priv) < (SME_EVENT_BUFF_SIZE - 1)) {
 		priv->sme_i.event_buff[priv->sme_i.qtail] = event;
 		inc_smeqtail(priv);
-		//DPRINTK(3,"inc_smeqtail \n");
 #ifdef KS_WLAN_DEBUG
 		if (priv->sme_i.max_event_count < cnt_smeqbody(priv))
 			priv->sme_i.max_event_count = cnt_smeqbody(priv);
 #endif /* KS_WLAN_DEBUG */
 	} else {
 		/* in case of buffer overflow */
-		//DPRINTK(2,"sme queue buffer overflow\n");
 		netdev_err(priv->net_dev, "sme queue buffer overflow\n");
 	}
 

commit be04661703522d201590c4541248cb8c92d89f2e
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Wed Mar 1 16:27:54 2017 +0530

    staging: ks7010: Unnecessary parentheses removed and improved coding style.
    
    Unnecessary parentheses are removed as reported by checkpatch.pl
    to make coder nicer and to improve readability.
    Also coding style is improved as it's often nicer to read if
     &(foo[0]) is converted to foo like:
     memcpy(&(ap->bssid[0]), &(ap_info->bssid[0]), ETH_ALEN);
     memcpy(ap->bssid, ap_info->bssid, ETH_ALEN);
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index ae7cf3ffae8e..946bb784935f 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -239,19 +239,19 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 					*(bp + 1));
 				ap->ssid.size = SSID_MAX_SIZE;
 			}
-			memcpy(&(ap->ssid.body[0]), bp + 2, ap->ssid.size);
+			memcpy(ap->ssid.body, bp + 2, ap->ssid.size);
 			break;
 		case 1:	/* rate */
 		case 50:	/* ext rate */
 			if ((*(bp + 1) + ap->rate_set.size) <=
 			    RATE_SET_MAX_SIZE) {
-				memcpy(&(ap->rate_set.body[ap->rate_set.size]),
+				memcpy(&ap->rate_set.body[ap->rate_set.size],
 				       bp + 2, *(bp + 1));
 				ap->rate_set.size += *(bp + 1);
 			} else {
 				DPRINTK(1, "size over :: rate size=%d\n",
 					(*(bp + 1) + ap->rate_set.size));
-				memcpy(&(ap->rate_set.body[ap->rate_set.size]),
+				memcpy(&ap->rate_set.body[ap->rate_set.size],
 				       bp + 2,
 				       RATE_SET_MAX_SIZE - ap->rate_set.size);
 				ap->rate_set.size +=
@@ -269,7 +269,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 					*(bp + 1));
 				ap->rsn_ie.size = RSN_IE_BODY_MAX;
 			}
-			memcpy(&(ap->rsn_ie.body[0]), bp + 2, ap->rsn_ie.size);
+			memcpy(ap->rsn_ie.body, bp + 2, ap->rsn_ie.size);
 			break;
 		case 221:	/* WPA */
 			if (!memcmp(bp + 2, "\x00\x50\xf2\x01", 4)) {	/* WPA OUI check */
@@ -282,7 +282,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 						*(bp + 1));
 					ap->wpa_ie.size = RSN_IE_BODY_MAX;
 				}
-				memcpy(&(ap->wpa_ie.body[0]), bp + 2,
+				memcpy(ap->wpa_ie.body, bp + 2,
 				       ap->wpa_ie.size);
 			}
 			break;
@@ -828,13 +828,12 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 	if (priv->scan_ind_count != 0) {
 		for (i = 0; i < priv->aplist.size; i++) {	/* bssid check */
 			if (!memcmp
-			    (&(ap_info->bssid[0]),
-			     &(priv->aplist.ap[i].bssid[0]), ETH_ALEN)) {
+			    (ap_info->bssid,
+			     priv->aplist.ap[i].bssid, ETH_ALEN)) {
 				if (ap_info->frame_type ==
 				    FRAME_TYPE_PROBE_RESP)
 					get_ap_information(priv, ap_info,
-							   &(priv->aplist.
-							     ap[i]));
+							   &priv->aplist.ap[i]);
 				return;
 			}
 		}
@@ -2639,7 +2638,7 @@ int hostif_init(struct ks_wlan_private *priv)
 
 	priv->aplist.size = 0;
 	for (i = 0; i < LOCAL_APLIST_MAX; i++)
-		memset(&(priv->aplist.ap[i]), 0, sizeof(struct local_ap_t));
+		memset(&priv->aplist.ap[i], 0, sizeof(struct local_ap_t));
 	priv->infra_status = 0;
 	priv->current_rate = 4;
 	priv->connect_status = DISCONNECT_STATUS;
@@ -2662,12 +2661,12 @@ int hostif_init(struct ks_wlan_private *priv)
 	INIT_WORK(&priv->ks_wlan_wakeup_task, ks_wlan_hw_wakeup_task);
 
 	/* WPA */
-	memset(&(priv->wpa), 0, sizeof(priv->wpa));
+	memset(&priv->wpa, 0, sizeof(priv->wpa));
 	priv->wpa.rsn_enabled = 0;
 	priv->wpa.mic_failure.failure = 0;
 	priv->wpa.mic_failure.last_failure_time = 0;
 	priv->wpa.mic_failure.stop = 0;
-	memset(&(priv->pmklist), 0, sizeof(priv->pmklist));
+	memset(&priv->pmklist, 0, sizeof(priv->pmklist));
 	INIT_LIST_HEAD(&priv->pmklist.head);
 	for (i = 0; i < PMK_LIST_MAX; i++)
 		INIT_LIST_HEAD(&priv->pmklist.pmk[i].list);

commit 1935c1450a8035bafee41cb3878880ffe8b4bccd
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Tue Feb 28 16:38:25 2017 +0530

    staging: ks7010: Unnecessary parentheses removed and improved coding style.
    
    Unnecessary parentheses are removed as reported by checkpatch.pl
    to make coder nicer and to improve readability.
    Also coding style is improved as it's often nicer to read if
     &(foo[0]) is converted to foo like:
     memcpy(&(ap->bssid[0]), &(ap_info->bssid[0]), ETH_ALEN);
     memcpy(ap->bssid, ap_info->bssid, ETH_ALEN);
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index a533408cf0b9..ae7cf3ffae8e 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -113,7 +113,7 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	int rc = 0;
 
 	DPRINTK(3, "\n");
-	ap = &(priv->current_ap);
+	ap = &priv->current_ap;
 
 	if ((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS) {
 		memset(ap, 0, sizeof(struct local_ap_t));
@@ -121,19 +121,19 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	}
 
 	/* bssid */
-	memcpy(&(ap->bssid[0]), &(ap_info->bssid[0]), ETH_ALEN);
+	memcpy(ap->bssid, ap_info->bssid, ETH_ALEN);
 	/* essid */
-	memcpy(&(ap->ssid.body[0]), &(priv->reg.ssid.body[0]),
+	memcpy(ap->ssid.body, priv->reg.ssid.body,
 	       priv->reg.ssid.size);
 	ap->ssid.size = priv->reg.ssid.size;
 	/* rate_set */
-	memcpy(&(ap->rate_set.body[0]), &(ap_info->rate_set.body[0]),
+	memcpy(ap->rate_set.body, ap_info->rate_set.body,
 	       ap_info->rate_set.size);
 	ap->rate_set.size = ap_info->rate_set.size;
 	if (ap_info->ext_rate_set.size) {
 		/* rate_set */
-		memcpy(&(ap->rate_set.body[ap->rate_set.size]),
-		       &(ap_info->ext_rate_set.body[0]),
+		memcpy(&ap->rate_set.body[ap->rate_set.size],
+		       ap_info->ext_rate_set.body,
 		       ap_info->ext_rate_set.size);
 		ap->rate_set.size += ap_info->ext_rate_set.size;
 	}
@@ -153,11 +153,11 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 		ap->rsn_ie.id = 0x30;
 		if (ap_info->rsn.size <= RSN_IE_BODY_MAX) {
 			ap->rsn_ie.size = ap_info->rsn.size;
-			memcpy(&(ap->rsn_ie.body[0]), &(ap_info->rsn.body[0]),
+			memcpy(ap->rsn_ie.body, ap_info->rsn.body,
 			       ap_info->rsn.size);
 		} else {
 			ap->rsn_ie.size = RSN_IE_BODY_MAX;
-			memcpy(&(ap->rsn_ie.body[0]), &(ap_info->rsn.body[0]),
+			memcpy(ap->rsn_ie.body, ap_info->rsn.body,
 			       RSN_IE_BODY_MAX);
 		}
 	} else if ((ap_info->rsn_mode & RSN_MODE_WPA)
@@ -165,11 +165,11 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 		ap->wpa_ie.id = 0xdd;
 		if (ap_info->rsn.size <= RSN_IE_BODY_MAX) {
 			ap->wpa_ie.size = ap_info->rsn.size;
-			memcpy(&(ap->wpa_ie.body[0]), &(ap_info->rsn.body[0]),
+			memcpy(ap->wpa_ie.body, ap_info->rsn.body,
 			       ap_info->rsn.size);
 		} else {
 			ap->wpa_ie.size = RSN_IE_BODY_MAX;
-			memcpy(&(ap->wpa_ie.body[0]), &(ap_info->rsn.body[0]),
+			memcpy(ap->wpa_ie.body, ap_info->rsn.body,
 			       RSN_IE_BODY_MAX);
 		}
 	} else {
@@ -184,7 +184,7 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
 	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
 		memcpy(wrqu.ap_addr.sa_data,
-		       &(priv->current_ap.bssid[0]), ETH_ALEN);
+		       priv->current_ap.bssid, ETH_ALEN);
 		DPRINTK(3,
 			"IWEVENT: connect bssid=%pM\n", wrqu.ap_addr.sa_data);
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);
@@ -212,7 +212,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 	memset(ap, 0, sizeof(struct local_ap_t));
 
 	/* bssid */
-	memcpy(&(ap->bssid[0]), &(ap_info->bssid[0]), ETH_ALEN);
+	memcpy(ap->bssid, ap_info->bssid, ETH_ALEN);
 	/* rssi */
 	ap->rssi = ap_info->rssi;
 	/* sq */
@@ -224,7 +224,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 	/* channel */
 	ap->channel = ap_info->ch_info;
 
-	bp = &(ap_info->body[0]);
+	bp = ap_info->body;
 	bsize = ap_info->body_size;
 	offset = 0;
 

commit d680d24eacac3124fc0d6a2fab0eef0074f09efd
Author: Katie Dunne <kdunne@mail.ccsf.edu>
Date:   Sun Feb 19 18:30:00 2017 -0800

    staging: ks7010: remove unecessary spaces after casts
    
    Remove spaces after casts found by checkpatch.pl. In some cases,
    remove returns after casts and place them on a single line.
    
    Signed-off-by: Katie Dunne <kdunne@mail.ccsf.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index fab06f29ec8b..a533408cf0b9 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -379,9 +379,8 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 				       (priv->rxp) + ((priv->rx_size) - 8), 8);
 				priv->rx_size = priv->rx_size - 8;
 				if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
-					MichaelMICFunction(&michel_mic, (uint8_t *) priv->wpa.key[auth_type - 1].rx_mic_key, (uint8_t *) priv->rxp, (int)priv->rx_size, (uint8_t) 0,	/* priority */
-							   (uint8_t *)
-							   michel_mic.Result);
+					MichaelMICFunction(&michel_mic, (uint8_t *)priv->wpa.key[auth_type - 1].rx_mic_key, (uint8_t *)priv->rxp, (int)priv->rx_size, (uint8_t)0,	/* priority */
+							   (uint8_t *)michel_mic.Result);
 				}
 				if (memcmp(michel_mic.Result, RecvMIC, 8)) {
 					now = jiffies;
@@ -400,7 +399,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 					} else if (mic_failure->failure == 1) {
 						mic_failure->failure = 2;
 						mic_failure->counter =
-						    (uint16_t) ((now -
+						    (uint16_t)((now -
 								 mic_failure->
 								 last_failure_time)
 								/ HZ);
@@ -1217,37 +1216,37 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 		    && !(priv->wpa.key[1].key_len)
 		    && !(priv->wpa.key[2].key_len)
 		    && !(priv->wpa.key[3].key_len)) {
-			pp->auth_type = cpu_to_le16((uint16_t) TYPE_AUTH);	/* no encryption */
+			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);	/* no encryption */
 		} else {
 			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
-				MichaelMICFunction(&michel_mic, (uint8_t *) priv->wpa.key[0].tx_mic_key, (uint8_t *) &pp->data[0], (int)packet_len, (uint8_t) 0,	/* priority */
-						   (uint8_t *) michel_mic.
+				MichaelMICFunction(&michel_mic, (uint8_t *)priv->wpa.key[0].tx_mic_key, (uint8_t *)&pp->data[0], (int)packet_len, (uint8_t)0,	/* priority */
+						   (uint8_t *)michel_mic.
 						   Result);
 				memcpy(p, michel_mic.Result, 8);
 				length += 8;
 				packet_len += 8;
 				p += 8;
 				pp->auth_type =
-				    cpu_to_le16((uint16_t) TYPE_DATA);
+				    cpu_to_le16((uint16_t)TYPE_DATA);
 
 			} else if (priv->wpa.pairwise_suite ==
 				   IW_AUTH_CIPHER_CCMP) {
 				pp->auth_type =
-				    cpu_to_le16((uint16_t) TYPE_DATA);
+				    cpu_to_le16((uint16_t)TYPE_DATA);
 			}
 		}
 	} else {
 		if (eth_proto == ETHER_PROTOCOL_TYPE_EAP)
-			pp->auth_type = cpu_to_le16((uint16_t) TYPE_AUTH);
+			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);
 		else
-			pp->auth_type = cpu_to_le16((uint16_t) TYPE_DATA);
+			pp->auth_type = cpu_to_le16((uint16_t)TYPE_DATA);
 	}
 
 	/* header value set */
 	pp->header.size =
 	    cpu_to_le16((uint16_t)
 			(sizeof(*pp) - sizeof(pp->header.size) + packet_len));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_DATA_REQ);
+	pp->header.event = cpu_to_le16((uint16_t)HIF_DATA_REQ);
 
 	/* tx request */
 	result =
@@ -1291,9 +1290,9 @@ void hostif_mib_get_request(struct ks_wlan_private *priv,
 		return;
 	}
 	pp->header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_MIB_GET_REQ);
-	pp->mib_attribute = cpu_to_le32((uint32_t) mib_attribute);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_MIB_GET_REQ);
+	pp->mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1324,10 +1323,10 @@ void hostif_mib_set_request(struct ks_wlan_private *priv,
 	pp->header.size =
 	    cpu_to_le16((uint16_t)
 			(sizeof(*pp) - sizeof(pp->header.size) + size));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_MIB_SET_REQ);
-	pp->mib_attribute = cpu_to_le32((uint32_t) mib_attribute);
-	pp->mib_value.size = cpu_to_le16((uint16_t) size);
-	pp->mib_value.type = cpu_to_le16((uint16_t) type);
+	pp->header.event = cpu_to_le16((uint16_t)HIF_MIB_SET_REQ);
+	pp->mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
+	pp->mib_value.size = cpu_to_le16((uint16_t)size);
+	pp->mib_value.type = cpu_to_le16((uint16_t)type);
 	memcpy(&pp->mib_value.body, vp, size);
 
 	/* send to device request */
@@ -1350,9 +1349,9 @@ void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 		return;
 	}
 	pp->header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_START_REQ);
-	pp->mode = cpu_to_le16((uint16_t) mode);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_START_REQ);
+	pp->mode = cpu_to_le16((uint16_t)mode);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1378,12 +1377,12 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 	}
 	memset(pp, 0, sizeof(*pp));
 	pp->header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_PS_ADH_SET_REQ);
-	pp->phy_type = cpu_to_le16((uint16_t) (priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t) (priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t) (priv->reg.scan_type));
-	pp->channel = cpu_to_le16((uint16_t) (priv->reg.channel));
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_PS_ADH_SET_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+	pp->channel = cpu_to_le16((uint16_t)(priv->reg.channel));
 	pp->rate_set.size = priv->reg.rate_set.size;
 	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
 	       priv->reg.rate_set.size);
@@ -1398,7 +1397,7 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
 		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM */
 	}
-	pp->capability = cpu_to_le16((uint16_t) capability);
+	pp->capability = cpu_to_le16((uint16_t)capability);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1420,11 +1419,11 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 		return;
 	}
 	pp->header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_INFRA_SET_REQ);
-	pp->phy_type = cpu_to_le16((uint16_t) (priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t) (priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t) (priv->reg.scan_type));
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_INFRA_SET_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
 
 	pp->rate_set.size = priv->reg.rate_set.size;
 	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
@@ -1442,10 +1441,10 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
 		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
 	}
-	pp->capability = cpu_to_le16((uint16_t) capability);
+	pp->capability = cpu_to_le16((uint16_t)capability);
 	pp->beacon_lost_count =
-	    cpu_to_le16((uint16_t) (priv->reg.beacon_lost_count));
-	pp->auth_type = cpu_to_le16((uint16_t) (priv->reg.authenticate_type));
+	    cpu_to_le16((uint16_t)(priv->reg.beacon_lost_count));
+	pp->auth_type = cpu_to_le16((uint16_t)(priv->reg.authenticate_type));
 
 	pp->channel_list.body[0] = 1;
 	pp->channel_list.body[1] = 8;
@@ -1486,11 +1485,11 @@ static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 		return;
 	}
 	pp->header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_INFRA_SET2_REQ);
-	pp->phy_type = cpu_to_le16((uint16_t) (priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t) (priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t) (priv->reg.scan_type));
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_INFRA_SET2_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
 
 	pp->rate_set.size = priv->reg.rate_set.size;
 	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
@@ -1508,10 +1507,10 @@ static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
 		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
 	}
-	pp->capability = cpu_to_le16((uint16_t) capability);
+	pp->capability = cpu_to_le16((uint16_t)capability);
 	pp->beacon_lost_count =
-	    cpu_to_le16((uint16_t) (priv->reg.beacon_lost_count));
-	pp->auth_type = cpu_to_le16((uint16_t) (priv->reg.authenticate_type));
+	    cpu_to_le16((uint16_t)(priv->reg.beacon_lost_count));
+	pp->auth_type = cpu_to_le16((uint16_t)(priv->reg.authenticate_type));
 
 	pp->channel_list.body[0] = 1;
 	pp->channel_list.body[1] = 8;
@@ -1556,12 +1555,12 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 	}
 	memset(pp, 0, sizeof(*pp));
 	pp->header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_ADH_SET_REQ);
-	pp->phy_type = cpu_to_le16((uint16_t) (priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t) (priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t) (priv->reg.scan_type));
-	pp->channel = cpu_to_le16((uint16_t) (priv->reg.channel));
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_ADH_SET_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+	pp->channel = cpu_to_le16((uint16_t)(priv->reg.channel));
 	pp->rate_set.size = priv->reg.rate_set.size;
 	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
 	       priv->reg.rate_set.size);
@@ -1578,7 +1577,7 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
 		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
 	}
-	pp->capability = cpu_to_le16((uint16_t) capability);
+	pp->capability = cpu_to_le16((uint16_t)capability);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1601,11 +1600,11 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 	}
 	memset(pp, 0, sizeof(*pp));
 	pp->header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_ADH_SET_REQ);
-	pp->phy_type = cpu_to_le16((uint16_t) (priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t) (priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t) (priv->reg.scan_type));
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_ADH_SET_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
 	pp->rate_set.size = priv->reg.rate_set.size;
 	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
 	       priv->reg.rate_set.size);
@@ -1622,7 +1621,7 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
 		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
 	}
-	pp->capability = cpu_to_le16((uint16_t) capability);
+	pp->capability = cpu_to_le16((uint16_t)capability);
 
 	pp->channel_list.body[0] = priv->reg.channel;
 	pp->channel_list.size = 1;
@@ -1647,8 +1646,8 @@ void hostif_stop_request(struct ks_wlan_private *priv)
 		return;
 	}
 	pp->header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_STOP_REQ);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_STOP_REQ);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1669,14 +1668,14 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 		return;
 	}
 	pp->header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_PHY_INFO_REQ);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_PHY_INFO_REQ);
 	if (priv->reg.phy_info_timer) {
-		pp->type = cpu_to_le16((uint16_t) TIME_TYPE);
-		pp->time = cpu_to_le16((uint16_t) (priv->reg.phy_info_timer));
+		pp->type = cpu_to_le16((uint16_t)TIME_TYPE);
+		pp->time = cpu_to_le16((uint16_t)(priv->reg.phy_info_timer));
 	} else {
-		pp->type = cpu_to_le16((uint16_t) NORMAL_TYPE);
-		pp->time = cpu_to_le16((uint16_t) 0);
+		pp->type = cpu_to_le16((uint16_t)NORMAL_TYPE);
+		pp->time = cpu_to_le16((uint16_t)0);
 	}
 
 	/* send to device request */
@@ -1700,11 +1699,11 @@ void hostif_power_mngmt_request(struct ks_wlan_private *priv,
 		return;
 	}
 	pp->header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_POWERMGT_REQ);
-	pp->mode = cpu_to_le32((uint32_t) mode);
-	pp->wake_up = cpu_to_le32((uint32_t) wake_up);
-	pp->receiveDTIMs = cpu_to_le32((uint32_t) receiveDTIMs);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_POWERMGT_REQ);
+	pp->mode = cpu_to_le32((uint32_t)mode);
+	pp->wake_up = cpu_to_le32((uint32_t)wake_up);
+	pp->receiveDTIMs = cpu_to_le32((uint32_t)receiveDTIMs);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1726,9 +1725,8 @@ void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
 			return;
 		}
 		pp->header.size =
-		    cpu_to_le16((uint16_t)
-				(sizeof(*pp) - sizeof(pp->header.size)));
-		pp->header.event = cpu_to_le16((uint16_t) HIF_SLEEP_REQ);
+		    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+		pp->header.event = cpu_to_le16((uint16_t)HIF_SLEEP_REQ);
 
 		/* send to device request */
 		ps_confirm_wait_inc(priv);
@@ -1759,12 +1757,12 @@ void hostif_bss_scan_request(struct ks_wlan_private *priv,
 		return;
 	}
 	pp->header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_SCAN_REQ);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_SCAN_REQ);
 	pp->scan_type = scan_type;
 
-	pp->ch_time_min = cpu_to_le32((uint32_t) 110);	/* default value */
-	pp->ch_time_max = cpu_to_le32((uint32_t) 130);	/* default value */
+	pp->ch_time_min = cpu_to_le32((uint32_t)110);	/* default value */
+	pp->ch_time_max = cpu_to_le32((uint32_t)130);	/* default value */
 	pp->channel_list.body[0] = 1;
 	pp->channel_list.body[1] = 8;
 	pp->channel_list.body[2] = 2;
@@ -1815,10 +1813,10 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 		return;
 	}
 	pp->header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t) HIF_MIC_FAILURE_REQ);
-	pp->failure_count = cpu_to_le16((uint16_t) failure_count);
-	pp->timer = cpu_to_le16((uint16_t) timer);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_MIC_FAILURE_REQ);
+	pp->failure_count = cpu_to_le16((uint16_t)failure_count);
+	pp->timer = cpu_to_le16((uint16_t)timer);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1871,7 +1869,7 @@ void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 
 	switch (type) {
 	case SME_WEP_INDEX_REQUEST:
-		val = cpu_to_le32((uint32_t) (priv->reg.wep_index));
+		val = cpu_to_le32((uint32_t)(priv->reg.wep_index));
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_ID,
 				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
 		break;
@@ -1908,7 +1906,7 @@ void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 					       &priv->reg.wep_key[3].val[0]);
 		break;
 	case SME_WEP_FLAG_REQUEST:
-		val = cpu_to_le32((uint32_t) (priv->reg.privacy_invoked));
+		val = cpu_to_le32((uint32_t)(priv->reg.privacy_invoked));
 		hostif_mib_set_request(priv, DOT11_PRIVACY_INVOKED,
 				       sizeof(val), MIB_VALUE_TYPE_BOOL, &val);
 		break;
@@ -1936,7 +1934,7 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 
 	switch (type) {
 	case SME_RSN_UCAST_REQUEST:
-		wpa_suite.size = cpu_to_le16((uint16_t) 1);
+		wpa_suite.size = cpu_to_le16((uint16_t)1);
 		switch (priv->wpa.pairwise_suite) {
 		case IW_AUTH_CIPHER_NONE:
 			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
@@ -2034,7 +2032,7 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 				       &wpa_suite.suite[0][0]);
 		break;
 	case SME_RSN_AUTH_REQUEST:
-		wpa_suite.size = cpu_to_le16((uint16_t) 1);
+		wpa_suite.size = cpu_to_le16((uint16_t)1);
 		switch (priv->wpa.key_mgmt_suite) {
 		case IW_AUTH_KEY_MGMT_802_1X:
 			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
@@ -2078,23 +2076,23 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 				       MIB_VALUE_TYPE_OSTRING, &wpa_suite);
 		break;
 	case SME_RSN_ENABLED_REQUEST:
-		val = cpu_to_le32((uint32_t) (priv->wpa.rsn_enabled));
+		val = cpu_to_le32((uint32_t)(priv->wpa.rsn_enabled));
 		hostif_mib_set_request(priv, DOT11_RSN_ENABLED,
 				       sizeof(val), MIB_VALUE_TYPE_BOOL, &val);
 		break;
 	case SME_RSN_MODE_REQUEST:
 		if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) {
 			rsn_mode.rsn_mode =
-			    cpu_to_le32((uint32_t) RSN_MODE_WPA2);
-			rsn_mode.rsn_capability = cpu_to_le16((uint16_t) 0);
+			    cpu_to_le32((uint32_t)RSN_MODE_WPA2);
+			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
 		} else if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA) {
 			rsn_mode.rsn_mode =
-			    cpu_to_le32((uint32_t) RSN_MODE_WPA);
-			rsn_mode.rsn_capability = cpu_to_le16((uint16_t) 0);
+			    cpu_to_le32((uint32_t)RSN_MODE_WPA);
+			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
 		} else {
 			rsn_mode.rsn_mode =
-			    cpu_to_le32((uint32_t) RSN_MODE_NONE);
-			rsn_mode.rsn_capability = cpu_to_le16((uint16_t) 0);
+			    cpu_to_le32((uint32_t)RSN_MODE_NONE);
+			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
 		}
 		hostif_mib_set_request(priv, LOCAL_RSN_MODE, sizeof(rsn_mode),
 				       MIB_VALUE_TYPE_OSTRING, &rsn_mode);
@@ -2187,7 +2185,7 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 		break;
 	case MODE_INFRASTRUCTURE:
 		/* Infrastructure mode */
-		if (!is_valid_ether_addr((u8 *) priv->reg.bssid)) {
+		if (!is_valid_ether_addr((u8 *)priv->reg.bssid)) {
 			hostif_infrastructure_set_request(priv);
 		} else {
 			hostif_infrastructure_set2_request(priv);
@@ -2197,7 +2195,7 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 		break;
 	case MODE_ADHOC:
 		/* IEEE802.11 Ad-Hoc mode */
-		if (!is_valid_ether_addr((u8 *) priv->reg.bssid)) {
+		if (!is_valid_ether_addr((u8 *)priv->reg.bssid)) {
 			hostif_adhoc_set_request(priv);
 		} else {
 			hostif_adhoc_set2_request(priv);
@@ -2227,13 +2225,13 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 	memset(set_address, 0, NIC_MAX_MCAST_LIST * ETH_ALEN);
 
 	if (dev->flags & IFF_PROMISC) {
-		filter_type = cpu_to_le32((uint32_t) MCAST_FILTER_PROMISC);
+		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_PROMISC);
 		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
 				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
 				       &filter_type);
 	} else if ((netdev_mc_count(dev) > NIC_MAX_MCAST_LIST)
 		   || (dev->flags & IFF_ALLMULTI)) {
-		filter_type = cpu_to_le32((uint32_t) MCAST_FILTER_MCASTALL);
+		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCASTALL);
 		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
 				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
 				       &filter_type);
@@ -2252,7 +2250,7 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 					       &set_address[0]);
 		} else {
 			filter_type =
-			    cpu_to_le32((uint32_t) MCAST_FILTER_MCAST);
+			    cpu_to_le32((uint32_t)MCAST_FILTER_MCAST);
 			priv->sme_i.sme_flag |= SME_MULTICAST;
 			hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
 					       sizeof(filter_type),
@@ -2330,12 +2328,12 @@ void hostif_sme_set_key(struct ks_wlan_private *priv, int type)
 
 	switch (type) {
 	case SME_SET_FLAG:
-		val = cpu_to_le32((uint32_t) (priv->reg.privacy_invoked));
+		val = cpu_to_le32((uint32_t)(priv->reg.privacy_invoked));
 		hostif_mib_set_request(priv, DOT11_PRIVACY_INVOKED,
 				       sizeof(val), MIB_VALUE_TYPE_BOOL, &val);
 		break;
 	case SME_SET_TXKEY:
-		val = cpu_to_le32((uint32_t) (priv->wpa.txkey));
+		val = cpu_to_le32((uint32_t)(priv->wpa.txkey));
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_ID,
 				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
 		break;
@@ -2404,7 +2402,7 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 			i++;
 		}
 	}
-	pmkcache.size = cpu_to_le16((uint16_t) (priv->pmklist.size));
+	pmkcache.size = cpu_to_le16((uint16_t)(priv->pmklist.size));
 	hostif_mib_set_request(priv, LOCAL_PMK,
 			       sizeof(priv->pmklist.size) + (ETH_ALEN +
 							     IW_PMKID_LEN) *
@@ -2478,12 +2476,12 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_stop_request(priv);
 		break;
 	case SME_RTS_THRESHOLD_REQUEST:
-		val = cpu_to_le32((uint32_t) (priv->reg.rts));
+		val = cpu_to_le32((uint32_t)(priv->reg.rts));
 		hostif_mib_set_request(priv, DOT11_RTS_THRESHOLD,
 				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
 		break;
 	case SME_FRAGMENTATION_THRESHOLD_REQUEST:
-		val = cpu_to_le32((uint32_t) (priv->reg.fragment));
+		val = cpu_to_le32((uint32_t)(priv->reg.fragment));
 		hostif_mib_set_request(priv, DOT11_FRAGMENTATION_THRESHOLD,
 				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
 		break;
@@ -2560,7 +2558,7 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_sme_sleep_set(priv);
 		break;
 	case SME_SET_REGION:
-		val = cpu_to_le32((uint32_t) (priv->region));
+		val = cpu_to_le32((uint32_t)(priv->region));
 		hostif_mib_set_request(priv, LOCAL_REGION,
 				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
 		break;

commit 8f4d00cd2390f68336337c5b6ac175090021ffdd
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Fri Feb 17 22:41:54 2017 +0100

    Staging: ks7010: ks_*: Braces should be used on all arms of these statements
    
    Braces should be used on all arms of these statements (CHECK)..
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index da7c42ef05f5..fab06f29ec8b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2146,8 +2146,9 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 				else
 					rate_octet[i] =
 					    priv->reg.rate_set.body[i];
-			} else
+			} else {
 				break;
+			}
 		}
 
 	} else {	/* D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE */
@@ -2161,8 +2162,9 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 				else
 					rate_octet[i] =
 					    priv->reg.rate_set.body[i];
-			} else
+			} else {
 				break;
+			}
 		}
 	}
 	rate_size = i;

commit caa59428971d5ad81d19512365c9ba580d83268c
Merge: b2064617c74f 0a441275018b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 22 12:14:01 2017 -0800

    Merge tag 'staging-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging/iio driver updates from Greg KH:
     "Here is the big staging and iio driver patchsets for 4.11-rc1.
    
      We almost broke even this time around, with only a few thousand lines
      added overall, as we removed the old and obsolete i4l code, but added
      some new drivers for the RPi platform, as well as adding some new IIO
      drivers.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'staging-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (669 commits)
      Staging: vc04_services: Fix the "space prohibited" code style errors
      Staging: vc04_services: Fix the "wrong indent" code style errors
      staging: octeon: Use net_device_stats from struct net_device
      Staging: rtl8192u: ieee80211: ieee80211.h - style fix
      Staging: rtl8192u: ieee80211: ieee80211_tx.c - style fix
      Staging: rtl8192u: ieee80211: rtl819x_BAProc.c - style fix
      Staging: rtl8192u: ieee80211: ieee80211_module.c - style fix
      Staging: rtl8192u: ieee80211: rtl819x_TSProc.c - style fix
      Staging: rtl8192u: r8192U.h - style fix
      Staging: rtl8192u: r8192U_core.c - style fix
      Staging: rtl8192u: r819xU_cmdpkt.c - style fix
      staging: rtl8192u: blank lines aren't necessary before a close brace '}'
      staging: rtl8192u: Adding space after enum and struct definition
      staging: rtl8192u: Adding space after struct definition
      Staging: ks7010: Add required and preferred spaces around operators
      Staging: ks7010: ks*: Remove redundant blank lines
      Staging: ks7010: ks*: Add missing blank lines after declarations
      staging: visorbus, replace init_timer with setup_timer
      staging: vt6656: rxtx.c Removed multiple dereferencing
      staging: vt6656: Alignment match open parenthesis
      ...

commit db224d31bbcd04fe1e85b40649e61ced97776720
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Thu Feb 16 17:13:25 2017 +0100

    Staging: ks7010: Add required and preferred spaces around operators
    
    Spaces should be added around operators to improve readability
    and are required in some cases.
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 4f430a0c845b..97d7b56c592a 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1101,7 +1101,7 @@ void hostif_event_check(struct ks_wlan_private *priv)
 	priv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;
 }
 
-#define CHECK_ALINE(size) (size%4 ? (size+(4-(size%4))):size)
+#define CHECK_ALINE(size) (size % 4 ? (size + (4 - (size % 4))) : size)
 
 int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 {

commit fac103e0ab8dfc8fecf1462f6f3777ea9744fc4d
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Fri Feb 10 17:08:14 2017 +0100

    Staging: ks7010: ks_*: Removed blank lines before and after braces.
    
    Removing unnecessary blank lines around braces to solve CHECKS.
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 1fbd495e5e63..4f430a0c845b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -729,7 +729,6 @@ void hostif_power_mngmt_confirm(struct ks_wlan_private *priv)
 	} else {
 		priv->dev_state = DEVICE_STATE_READY;
 	}
-
 }
 
 static
@@ -855,7 +854,6 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 		DPRINTK(4, " count over :: scan_ind_count=%d\n",
 			priv->scan_ind_count);
 	}
-
 }
 
 static
@@ -902,7 +900,6 @@ void hostif_ps_adhoc_set_confirm(struct ks_wlan_private *priv)
 	DPRINTK(3, "\n");
 	priv->infra_status = 0;	/* infrastructure mode cancel */
 	hostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);
-
 }
 
 static
@@ -1918,7 +1915,6 @@ void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 				       sizeof(val), MIB_VALUE_TYPE_BOOL, &val);
 		break;
 	}
-
 }
 
 struct wpa_suite_t {
@@ -2105,7 +2101,6 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 		hostif_mib_set_request(priv, LOCAL_RSN_MODE, sizeof(rsn_mode),
 				       MIB_VALUE_TYPE_OSTRING, &rsn_mode);
 		break;
-
 	}
 }
 
@@ -2213,13 +2208,11 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 	default:
 		break;
 	}
-
 }
 
 static
 void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 {
-
 	struct net_device *dev = priv->net_dev;
 	int mc_count;
 	struct netdev_hw_addr *ha;
@@ -2269,7 +2262,6 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 	}
 
 	spin_unlock(&priv->multicast_spin);
-
 }
 
 static
@@ -2313,7 +2305,6 @@ void hostif_sme_powermgt_set(struct ks_wlan_private *priv)
 		break;
 	}
 	hostif_power_mngmt_request(priv, mode, wake_up, receiveDTIMs);
-
 }
 
 static
@@ -2330,7 +2321,6 @@ void hostif_sme_sleep_set(struct ks_wlan_private *priv)
 	default:
 		break;
 	}
-
 }
 
 static
@@ -2641,7 +2631,6 @@ void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
 	}
 
 	tasklet_schedule(&priv->sme_task);
-
 }
 
 int hostif_init(struct ks_wlan_private *priv)

commit 4a7c972644c1151f6dd34ff4b5f7eacb239e22ee
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Jan 18 17:45:01 2017 +0100

    net: Remove usage of net_device last_rx member
    
    The network stack no longer uses the last_rx member of struct net_device
    since the bonding driver switched to use its own private last_rx in
    commit 9f242738376d ("bonding: use last_arp_rx in slave_last_rx()").
    
    However, some drivers still (ab)use the field for their own purposes and
    some driver just update it without actually using it.
    
    Previously, there was an accompanying comment for the last_rx member
    added in commit 4dc89133f49b ("net: add a comment on netdev->last_rx")
    which asked drivers not to update is, unless really needed. However,
    this commend was removed in commit f8ff080dacec ("bonding: remove
    useless updating of slave->dev->last_rx"), so some drivers added later
    on still did update last_rx.
    
    Remove all usage of last_rx and switch three drivers (sky2, atp and
    smc91c92_cs) which actually read and write it to use their own private
    copy in netdev_priv.
    
    Compile-tested with allyesconfig and allmodconfig on x86 and arm.
    
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Jay Vosburgh <j.vosburgh@gmail.com>
    Cc: Veaceslav Falico <vfalico@gmail.com>
    Cc: Andy Gospodarek <andy@greyhouse.net>
    Cc: Mirko Lindner <mlindner@marvell.com>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Reviewed-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 1fbd495e5e63..c7652c35be19 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -461,7 +461,6 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 			skb->protocol = eth_type_trans(skb, skb->dev);
 			priv->nstats.rx_packets++;
 			priv->nstats.rx_bytes += rx_ind_size;
-			skb->dev->last_rx = jiffies;
 			netif_rx(skb);
 		} else {
 			priv->nstats.rx_dropped++;
@@ -494,7 +493,6 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 			skb->protocol = eth_type_trans(skb, skb->dev);
 			priv->nstats.rx_packets++;
 			priv->nstats.rx_bytes += rx_ind_size;
-			skb->dev->last_rx = jiffies;
 			netif_rx(skb);
 		} else {
 			priv->nstats.rx_dropped++;

commit 35092b6d9b74d4ff555191f86c44a54e35708893
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Tue Oct 18 14:37:47 2016 +0000

    staging: ks7010: convert list_for_each to entry variant
    
    convert list_for_each() to list_for_each_entry() where
    applicable.
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index cbf49c951514..1fbd495e5e63 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2402,13 +2402,11 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 		} __packed list[PMK_LIST_MAX];
 	} __packed pmkcache;
 	struct pmk_t *pmk;
-	struct list_head *ptr;
 	int i;
 
 	DPRINTK(4, "pmklist.size=%d\n", priv->pmklist.size);
 	i = 0;
-	list_for_each(ptr, &priv->pmklist.head) {
-		pmk = list_entry(ptr, struct pmk_t, list);
+	list_for_each_entry(pmk, &priv->pmklist.head, list) {
 		if (i < PMK_LIST_MAX) {
 			memcpy(pmkcache.list[i].bssid, pmk->bssid, ETH_ALEN);
 			memcpy(pmkcache.list[i].pmkid, pmk->pmkid,

commit bd46a80110dcc5c0216ee25acd8b1303ab23455f
Author: Sabitha George <sabitha.george@gmail.com>
Date:   Sun Oct 16 21:44:26 2016 +0530

    staging: ks7010: Remove braces around single statement blocks
    
    Fixes checkpatch warning: braces{} are not necessary for
    single statment blocks
    
    Signed-off-by: Sabitha George <sabitha.george@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index ad840f9f4b77..cbf49c951514 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -97,11 +97,10 @@ int ks_wlan_do_power_save(struct ks_wlan_private *priv)
 {
 	DPRINTK(4, "psstatus.status=%d\n", atomic_read(&priv->psstatus.status));
 
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS)
 		hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
-	} else {
+	else
 		priv->dev_state = DEVICE_STATE_READY;
-	}
 	return 0;
 }
 
@@ -687,15 +686,13 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 		break;
 	case DOT11_GMK1_TSC:
 		DPRINTK(2, "DOT11_GMK1_TSC:mib_status=%d\n", (int)mib_status);
-		if (atomic_read(&priv->psstatus.snooze_guard)) {
+		if (atomic_read(&priv->psstatus.snooze_guard))
 			atomic_set(&priv->psstatus.snooze_guard, 0);
-		}
 		break;
 	case DOT11_GMK2_TSC:
 		DPRINTK(2, "DOT11_GMK2_TSC:mib_status=%d\n", (int)mib_status);
-		if (atomic_read(&priv->psstatus.snooze_guard)) {
+		if (atomic_read(&priv->psstatus.snooze_guard))
 			atomic_set(&priv->psstatus.snooze_guard, 0);
-		}
 		break;
 	case LOCAL_PMK:
 		DPRINTK(2, "LOCAL_PMK:mib_status=%d\n", (int)mib_status);
@@ -2436,9 +2433,8 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 	DPRINTK(3, "event=%d\n", event);
 	switch (event) {
 	case SME_START:
-		if (priv->dev_state == DEVICE_STATE_BOOT) {
+		if (priv->dev_state == DEVICE_STATE_BOOT)
 			hostif_mib_get_request(priv, DOT11_MAC_ADDRESS);
-		}
 		break;
 	case SME_MULTICAST_REQUEST:
 		hostif_sme_multicast_set(priv);
@@ -2483,14 +2479,12 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		}
 		break;
 	case SME_GET_MAC_ADDRESS:
-		if (priv->dev_state == DEVICE_STATE_BOOT) {
+		if (priv->dev_state == DEVICE_STATE_BOOT)
 			hostif_mib_get_request(priv, DOT11_PRODUCT_VERSION);
-		}
 		break;
 	case SME_GET_PRODUCT_VERSION:
-		if (priv->dev_state == DEVICE_STATE_BOOT) {
+		if (priv->dev_state == DEVICE_STATE_BOOT)
 			priv->dev_state = DEVICE_STATE_PREINIT;
-		}
 		break;
 	case SME_STOP_REQUEST:
 		hostif_stop_request(priv);
@@ -2569,9 +2563,8 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		/* for power save */
 		atomic_set(&priv->psstatus.snooze_guard, 0);
 		atomic_set(&priv->psstatus.confirm_wait, 0);
-		if (priv->dev_state == DEVICE_STATE_PREINIT) {
+		if (priv->dev_state == DEVICE_STATE_PREINIT)
 			priv->dev_state = DEVICE_STATE_INIT;
-		}
 		/* wake_up_interruptible_all(&priv->confirm_wait); */
 		complete(&priv->confirm_wait);
 		break;

commit ab1effc09519f3bb4b84dd6d8276cedf07b17a1b
Author: Sabitha George <sabitha.george@gmail.com>
Date:   Sun Oct 16 21:42:44 2016 +0530

    staging: ks7010: Add blank line after declarations
    
    Fixes checkpatch.pl warning :Missing a blank line
    after declarations
    
    Signed-off-by: Sabitha George <sabitha.george@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 1f9f63e6e996..ad840f9f4b77 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -750,6 +750,7 @@ void hostif_start_confirm(struct ks_wlan_private *priv)
 {
 #ifdef WPS
 	union iwreq_data wrqu;
+
 	wrqu.data.length = 0;
 	wrqu.data.flags = 0;
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
@@ -771,6 +772,7 @@ void hostif_connect_indication(struct ks_wlan_private *priv)
 	unsigned int old_status = priv->connect_status;
 	struct net_device *netdev = priv->net_dev;
 	union iwreq_data wrqu0;
+
 	connect_code = get_WORD(priv);
 
 	switch (connect_code) {
@@ -910,6 +912,7 @@ static
 void hostif_infrastructure_set_confirm(struct ks_wlan_private *priv)
 {
 	uint16_t result_code;
+
 	DPRINTK(3, "\n");
 	result_code = get_WORD(priv);
 	DPRINTK(3, "result code = %d\n", result_code);
@@ -975,6 +978,7 @@ void hostif_bss_scan_confirm(struct ks_wlan_private *priv)
 	unsigned int result_code;
 	struct net_device *dev = priv->net_dev;
 	union iwreq_data wrqu;
+
 	result_code = get_DWORD(priv);
 	DPRINTK(2, "result=%d :: scan_ind_count=%d\n", result_code,
 		priv->scan_ind_count);
@@ -1872,6 +1876,7 @@ static
 void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 {
 	uint32_t val;
+
 	switch (type) {
 	case SME_WEP_INDEX_REQUEST:
 		val = cpu_to_le32((uint32_t) (priv->reg.wep_index));
@@ -2335,6 +2340,7 @@ static
 void hostif_sme_set_key(struct ks_wlan_private *priv, int type)
 {
 	uint32_t val;
+
 	switch (type) {
 	case SME_SET_FLAG:
 		val = cpu_to_le32((uint32_t) (priv->reg.privacy_invoked));

commit 4ba165e76b9420ddfa0e68d91db18249d86155e1
Author: Sabitha George <sabitha.george@gmail.com>
Date:   Mon Oct 10 12:03:12 2016 +0530

    staging: ks7010: use netdev_* instead of printk()
    
    1. Fixes checkpatch warning on printk usage in ks_hostif.c
    2. Dropped "ks_wlan" prefix from the messages
    3. Removed the "Memory squeeze,dropping packet" messages
    
    Signed-off-by: Sabitha George <sabitha.george@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 5714cf758831..1f9f63e6e996 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -465,8 +465,6 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 			skb->dev->last_rx = jiffies;
 			netif_rx(skb);
 		} else {
-			printk(KERN_WARNING
-			       "ks_wlan: Memory squeeze, dropping packet.\n");
 			priv->nstats.rx_dropped++;
 		}
 		break;
@@ -500,8 +498,6 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 			skb->dev->last_rx = jiffies;
 			netif_rx(skb);
 		} else {
-			printk(KERN_WARNING
-			       "ks_wlan: Memory squeeze, dropping packet.\n");
 			priv->nstats.rx_dropped++;
 		}
 		break;
@@ -549,7 +545,7 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		dev->dev_addr[5] = priv->eth_addr[5];
 		dev->dev_addr[6] = 0x00;
 		dev->dev_addr[7] = 0x00;
-		printk(KERN_INFO "ks_wlan: MAC ADDRESS = %pM\n", priv->eth_addr);
+		netdev_info(dev, "MAC ADDRESS = %pM\n", priv->eth_addr);
 		break;
 	case DOT11_PRODUCT_VERSION:
 		/* firmware version */
@@ -557,8 +553,8 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		priv->version_size = priv->rx_size;
 		memcpy(priv->firmware_version, priv->rxp, priv->rx_size);
 		priv->firmware_version[priv->rx_size] = '\0';
-		printk(KERN_INFO "ks_wlan: firmware ver. = %s\n",
-		       priv->firmware_version);
+		netdev_info(dev, "firmware ver. = %s\n",
+			    priv->firmware_version);
 		hostif_sme_enqueue(priv, SME_GET_PRODUCT_VERSION);
 		/* wake_up_interruptible_all(&priv->confirm_wait); */
 		complete(&priv->confirm_wait);
@@ -578,12 +574,12 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		} else if (priv->eeprom_sum.type == 1) {
 			if (priv->eeprom_sum.result == 0) {
 				priv->eeprom_checksum = EEPROM_NG;
-				printk("LOCAL_EEPROM_SUM NG\n");
+				netdev_info(dev, "LOCAL_EEPROM_SUM NG\n");
 			} else if (priv->eeprom_sum.result == 1) {
 				priv->eeprom_checksum = EEPROM_OK;
 			}
 		} else {
-			printk("LOCAL_EEPROM_SUM error!\n");
+			netdev_err(dev, "LOCAL_EEPROM_SUM error!\n");
 		}
 		break;
 	default:
@@ -880,7 +876,7 @@ void hostif_stop_confirm(struct ks_wlan_private *priv)
 		netif_carrier_off(netdev);
 		tmp = FORCE_DISCONNECT & priv->connect_status;
 		priv->connect_status = tmp | DISCONNECT_STATUS;
-		printk("IWEVENT: disconnect\n");
+		netdev_info(netdev, "IWEVENT: disconnect\n");
 
 		wrqu0.data.length = 0;
 		wrqu0.data.flags = 0;
@@ -890,7 +886,7 @@ void hostif_stop_confirm(struct ks_wlan_private *priv)
 		    && (old_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
 			eth_zero_addr(wrqu0.ap_addr.sa_data);
 			DPRINTK(3, "IWEVENT: disconnect\n");
-			printk("IWEVENT: disconnect\n");
+			netdev_info(netdev, "IWEVENT: disconnect\n");
 			DPRINTK(3, "disconnect :: scan_ind_count=%d\n",
 				priv->scan_ind_count);
 			wireless_send_event(netdev, SIOCGIWAP, &wrqu0, NULL);
@@ -1096,7 +1092,7 @@ void hostif_event_check(struct ks_wlan_private *priv)
 	case HIF_AP_SET_CONF:
 	default:
 		//DPRINTK(1, "undefined event[%04X]\n", event);
-		printk("undefined event[%04X]\n", event);
+		netdev_err(priv->net_dev, "undefined event[%04X]\n", event);
 		/* wake_up_all(&priv->confirm_wait); */
 		complete(&priv->confirm_wait);
 		break;
@@ -2644,7 +2640,7 @@ void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
 	} else {
 		/* in case of buffer overflow */
 		//DPRINTK(2,"sme queue buffer overflow\n");
-		printk("sme queue buffer overflow\n");
+		netdev_err(priv->net_dev, "sme queue buffer overflow\n");
 	}
 
 	tasklet_schedule(&priv->sme_task);

commit c44893aafbd06504d21c64bc7de3621f5cb7c728
Author: Mihaela Muraru <mihaela.muraru21@gmail.com>
Date:   Sat Oct 8 10:22:17 2016 +0300

    Staging: ks7010: Delete unnecessary return statement
    
    This is a patch to ks_hostif.c file that fixes up a checkpatch.pl
    
    WARNING: void function return statements are not generally useful.
    
    The 'return' statement is not useful here, because it is not necessary to be
    forced the exit of the function.
    
    Signed-off-by: Mihaela Muraru <mihaela.muraru21@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 07954ee78d7c..5714cf758831 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1921,7 +1921,6 @@ void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 		break;
 	}
 
-	return;
 }
 
 struct wpa_suite_t {
@@ -2110,7 +2109,6 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 		break;
 
 	}
-	return;
 }
 
 static
@@ -2218,7 +2216,6 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 		break;
 	}
 
-	return;
 }
 
 static
@@ -2319,7 +2316,6 @@ void hostif_sme_powermgt_set(struct ks_wlan_private *priv)
 	}
 	hostif_power_mngmt_request(priv, mode, wake_up, receiveDTIMs);
 
-	return;
 }
 
 static
@@ -2337,7 +2333,6 @@ void hostif_sme_sleep_set(struct ks_wlan_private *priv)
 		break;
 	}
 
-	return;
 }
 
 static
@@ -2395,7 +2390,6 @@ void hostif_sme_set_key(struct ks_wlan_private *priv, int type)
 				       &priv->wpa.key[2].rx_seq[0]);
 		break;
 	}
-	return;
 }
 
 static
@@ -2631,7 +2625,6 @@ void hostif_sme_task(unsigned long dev)
 				tasklet_schedule(&priv->sme_task);
 		}
 	}
-	return;
 }
 
 /* send to Station Management Entity module */
@@ -2715,5 +2708,4 @@ int hostif_init(struct ks_wlan_private *priv)
 void hostif_exit(struct ks_wlan_private *priv)
 {
 	tasklet_kill(&priv->sme_task);
-	return;
 }

commit 31a86a533a1134e71f3eaae5f027ecf4934f5dca
Author: Mihaela Muraru <mihaela.muraru21@gmail.com>
Date:   Sat Oct 8 01:58:11 2016 +0300

    Staging: ks7010: __packed instedad of __attribute__((packed))
    
    Fix a issue found by  checkpatch.pl tool:
    
    "WARNING: __packed is preferred over __attribute__((packed))".
    
    Replace  __attribute__((packed)) with __packed.
    
    Signed-off-by: Mihaela Muraru <mihaela.muraru21@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 25c32ab8211d..07954ee78d7c 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1927,12 +1927,12 @@ void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 struct wpa_suite_t {
 	unsigned short size;
 	unsigned char suite[4][CIPHER_ID_LEN];
-} __attribute__ ((packed));
+} __packed;
 
 struct rsn_mode_t {
 	uint32_t rsn_mode;
 	uint16_t rsn_capability;
-} __attribute__ ((packed));
+} __packed;
 
 static
 void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
@@ -2406,8 +2406,8 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 		struct {
 			uint8_t bssid[ETH_ALEN];
 			uint8_t pmkid[IW_PMKID_LEN];
-		} __attribute__ ((packed)) list[PMK_LIST_MAX];
-	} __attribute__ ((packed)) pmkcache;
+		} __packed list[PMK_LIST_MAX];
+	} __packed pmkcache;
 	struct pmk_t *pmk;
 	struct list_head *ptr;
 	int i;

commit 7a98abccd28e264a60c55df5b8cf59337ec338ba
Author: Pontus Fuchs <pontus.fuchs@gmail.com>
Date:   Thu Oct 6 22:50:20 2016 +0200

    staging: ks7010: Use printk format specifier for MAC addresses
    
    Convert to %pM instead of custom code.
    
    Signed-off-by: Pontus Fuchs <pontus.fuchs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index aff3eae239ab..25c32ab8211d 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -187,13 +187,7 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 		memcpy(wrqu.ap_addr.sa_data,
 		       &(priv->current_ap.bssid[0]), ETH_ALEN);
 		DPRINTK(3,
-			"IWEVENT: connect bssid=%02x:%02x:%02x:%02x:%02x:%02x\n",
-			(unsigned char)wrqu.ap_addr.sa_data[0],
-			(unsigned char)wrqu.ap_addr.sa_data[1],
-			(unsigned char)wrqu.ap_addr.sa_data[2],
-			(unsigned char)wrqu.ap_addr.sa_data[3],
-			(unsigned char)wrqu.ap_addr.sa_data[4],
-			(unsigned char)wrqu.ap_addr.sa_data[5]);
+			"IWEVENT: connect bssid=%pM\n", wrqu.ap_addr.sa_data);
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);
 	}
 	DPRINTK(4, "\n    Link AP\n");
@@ -420,16 +414,11 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 					/*  needed parameters: count, keyid, key type, TSC */
 					sprintf(buf,
 						"MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
-						"%02x:%02x:%02x:%02x:%02x:%02x)",
+						"%pM)",
 						auth_type - 1,
 						eth_hdr->
 						h_dest[0] & 0x01 ? "broad" :
-						"uni", eth_hdr->h_source[0],
-						eth_hdr->h_source[1],
-						eth_hdr->h_source[2],
-						eth_hdr->h_source[3],
-						eth_hdr->h_source[4],
-						eth_hdr->h_source[5]);
+						"uni", eth_hdr->h_source);
 					memset(&wrqu, 0, sizeof(wrqu));
 					wrqu.data.length = strlen(buf);
 					DPRINTK(4,
@@ -560,10 +549,7 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		dev->dev_addr[5] = priv->eth_addr[5];
 		dev->dev_addr[6] = 0x00;
 		dev->dev_addr[7] = 0x00;
-		printk(KERN_INFO
-		       "ks_wlan: MAC ADDRESS = %02x:%02x:%02x:%02x:%02x:%02x\n",
-		       priv->eth_addr[0], priv->eth_addr[1], priv->eth_addr[2],
-		       priv->eth_addr[3], priv->eth_addr[4], priv->eth_addr[5]);
+		printk(KERN_INFO "ks_wlan: MAC ADDRESS = %pM\n", priv->eth_addr);
 		break;
 	case DOT11_PRODUCT_VERSION:
 		/* firmware version */
@@ -1184,9 +1170,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	eth = (struct ethhdr *)packet->data;
 	if (memcmp(&priv->eth_addr[0], eth->h_source, ETH_ALEN)) {
 		DPRINTK(1, "invalid mac address !!\n");
-		DPRINTK(1, "ethernet->h_source=%02X:%02X:%02X:%02X:%02X:%02X\n",
-			eth->h_source[0], eth->h_source[1], eth->h_source[2],
-			eth->h_source[3], eth->h_source[4], eth->h_source[5]);
+		DPRINTK(1, "ethernet->h_source=%pM\n", eth->h_source);
 		dev_kfree_skb(packet);
 		kfree(pp);
 		return -3;
@@ -2217,10 +2201,7 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 		} else {
 			hostif_infrastructure_set2_request(priv);
 			DPRINTK(2,
-				"Infra bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
-				priv->reg.bssid[0], priv->reg.bssid[1],
-				priv->reg.bssid[2], priv->reg.bssid[3],
-				priv->reg.bssid[4], priv->reg.bssid[5]);
+				"Infra bssid = %pM\n", priv->reg.bssid);
 		}
 		break;
 	case MODE_ADHOC:
@@ -2230,10 +2211,7 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 		} else {
 			hostif_adhoc_set2_request(priv);
 			DPRINTK(2,
-				"Adhoc bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
-				priv->reg.bssid[0], priv->reg.bssid[1],
-				priv->reg.bssid[2], priv->reg.bssid[3],
-				priv->reg.bssid[4], priv->reg.bssid[5]);
+				"Adhoc bssid = %pM\n", priv->reg.bssid);
 		}
 		break;
 	default:

commit 3f64b35e3352f6cc70d6fc59bcd32e8e610d8a06
Author: Philipp Hoefflin <p.hoefflin@posteo.de>
Date:   Mon Oct 3 02:57:26 2016 +0200

    staging: ks7010: fix checkpatch "space after #ifdef" error
    
    Fix checkpatch "ERROR: exactly one space required after that #ifdef"
    error in ks_hostif.c.
    
    Signed-off-by: Philipp Hoefflin <p.hoefflin@posteo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index e81e905aab64..aff3eae239ab 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -766,7 +766,7 @@ void hostif_sleep_confirm(struct ks_wlan_private *priv)
 static
 void hostif_start_confirm(struct ks_wlan_private *priv)
 {
-#ifdef  WPS
+#ifdef WPS
 	union iwreq_data wrqu;
 	wrqu.data.length = 0;
 	wrqu.data.flags = 0;

commit 0157403e8a31e8895974ecefa75e8915d01a4535
Author: Philipp Hoefflin <p.hoefflin@posteo.de>
Date:   Mon Oct 3 02:57:25 2016 +0200

    staging: ks7010: reformat makro ps_confirm_wait_inc()
    
    Reformat the makro ps_confirm_wait_inc() to fix several checkpatch
    errors and warnings:
      - ERROR: space required before the open brace '{'
      - ERROR: space required before the open parenthesis '('
      - ERROR: code indent should use tabs where possible
      - ERROR: space required after that close brace '}'
      - ERROR: space required before the open parenthesis '('
      - WARNING: line over 80 characters
      - WARNING: please, no spaces at the start of a line
    
    Signed-off-by: Philipp Hoefflin <p.hoefflin@posteo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 309c7dc91584..e81e905aab64 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1294,10 +1294,11 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	return result;
 }
 
-#define ps_confirm_wait_inc(priv)  do{if(atomic_read(&priv->psstatus.status) > PS_ACTIVE_SET){ \
-                                                  atomic_inc(&priv->psstatus.confirm_wait); \
-                                                  /* atomic_set(&priv->psstatus.status, PS_CONF_WAIT);*/ \
-                                      } }while(0)
+#define ps_confirm_wait_inc(priv) do { \
+	if (atomic_read(&priv->psstatus.status) > PS_ACTIVE_SET) { \
+		atomic_inc(&priv->psstatus.confirm_wait); \
+		/* atomic_set(&priv->psstatus.status, PS_CONF_WAIT);*/ \
+	} } while (0)
 
 static
 void hostif_mib_get_request(struct ks_wlan_private *priv,

commit ec9d6dcefc767f6ea79ab7d676be8a88e8a94ee4
Author: Philipp Hoefflin <p.hoefflin@posteo.de>
Date:   Mon Oct 3 02:57:24 2016 +0200

    staging: ks7010: use tabs for indentation
    
    Fix all occurences of checkpatch "ERROR: code indent should use tabs
    where possible" errors in ks_hostif.c.
    
    Signed-off-by: Philipp Hoefflin <p.hoefflin@posteo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index c26d18b108ff..309c7dc91584 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -23,11 +23,11 @@
 
 /* macro */
 #define inc_smeqhead(priv) \
-        (priv->sme_i.qhead = (priv->sme_i.qhead + 1) % SME_EVENT_BUFF_SIZE)
+	(priv->sme_i.qhead = (priv->sme_i.qhead + 1) % SME_EVENT_BUFF_SIZE)
 #define inc_smeqtail(priv) \
-        (priv->sme_i.qtail = (priv->sme_i.qtail + 1) % SME_EVENT_BUFF_SIZE)
+	(priv->sme_i.qtail = (priv->sme_i.qtail + 1) % SME_EVENT_BUFF_SIZE)
 #define cnt_smeqbody(priv) \
-        (((priv->sme_i.qtail + SME_EVENT_BUFF_SIZE) - (priv->sme_i.qhead)) % SME_EVENT_BUFF_SIZE)
+	(((priv->sme_i.qtail + SME_EVENT_BUFF_SIZE) - (priv->sme_i.qhead)) % SME_EVENT_BUFF_SIZE)
 
 #define KS_WLAN_MEM_FLAG (GFP_ATOMIC)
 

commit 6f88006826734f661d146098424f467923300552
Author: Philipp Hoefflin <p.hoefflin@posteo.de>
Date:   Mon Oct 3 02:57:23 2016 +0200

    staging: ks7010: fix "prohibited space" errors reported by checkpatch
    
    Fix all occurences of the following checkpatch errors in ks_hostif.c:
      - ERROR: space prohibited after that '&' (ctx:WxW)
      - ERROR: space prohibited after that open parenthesis '('
      - ERROR: space prohibited before that close parenthesis ')'
    
    Signed-off-by: Philipp Hoefflin <p.hoefflin@posteo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index c57ca581550a..c26d18b108ff 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -23,11 +23,11 @@
 
 /* macro */
 #define inc_smeqhead(priv) \
-        ( priv->sme_i.qhead = (priv->sme_i.qhead + 1) % SME_EVENT_BUFF_SIZE )
+        (priv->sme_i.qhead = (priv->sme_i.qhead + 1) % SME_EVENT_BUFF_SIZE)
 #define inc_smeqtail(priv) \
-        ( priv->sme_i.qtail = (priv->sme_i.qtail + 1) % SME_EVENT_BUFF_SIZE )
+        (priv->sme_i.qtail = (priv->sme_i.qtail + 1) % SME_EVENT_BUFF_SIZE)
 #define cnt_smeqbody(priv) \
-        (((priv->sme_i.qtail + SME_EVENT_BUFF_SIZE) - (priv->sme_i.qhead)) % SME_EVENT_BUFF_SIZE )
+        (((priv->sme_i.qtail + SME_EVENT_BUFF_SIZE) - (priv->sme_i.qhead)) % SME_EVENT_BUFF_SIZE)
 
 #define KS_WLAN_MEM_FLAG (GFP_ATOMIC)
 
@@ -1244,7 +1244,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 			pp->auth_type = cpu_to_le16((uint16_t) TYPE_AUTH);	/* no encryption */
 		} else {
 			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
-				MichaelMICFunction(&michel_mic, (uint8_t *) priv->wpa.key[0].tx_mic_key, (uint8_t *) & pp->data[0], (int)packet_len, (uint8_t) 0,	/* priority */
+				MichaelMICFunction(&michel_mic, (uint8_t *) priv->wpa.key[0].tx_mic_key, (uint8_t *) &pp->data[0], (int)packet_len, (uint8_t) 0,	/* priority */
 						   (uint8_t *) michel_mic.
 						   Result);
 				memcpy(p, michel_mic.Result, 8);

commit d30924a032722d72d19fc0ad13f24c7b5a6adf27
Author: Johan Svensson <johan.svensson692@gmail.com>
Date:   Thu Sep 22 20:11:21 2016 +0200

    staging: ks7010: add blank line after variable declarations
    
    Fixes warnings found by checkpatch
    Missing a blank line after declarations
    
    Signed-off-by: Johan Svensson <johan.svensson692@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index aad80487316c..c57ca581550a 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -35,6 +35,7 @@ static
 inline u8 get_BYTE(struct ks_wlan_private *priv)
 {
 	u8 data;
+
 	data = *(priv->rxp)++;
 	/* length check in advance ! */
 	--(priv->rx_size);
@@ -45,6 +46,7 @@ static
 inline u16 get_WORD(struct ks_wlan_private *priv)
 {
 	u16 data;
+
 	data = (get_BYTE(priv) & 0xff);
 	data |= ((get_BYTE(priv) << 8) & 0xff00);
 	return data;
@@ -54,6 +56,7 @@ static
 inline u32 get_DWORD(struct ks_wlan_private *priv)
 {
 	u32 data;
+
 	data = (get_BYTE(priv) & 0xff);
 	data |= ((get_BYTE(priv) << 8) & 0x0000ff00);
 	data |= ((get_BYTE(priv) << 16) & 0x00ff0000);

commit 55d6aacd43f808746e9e929d6a0ff8a9b14d2374
Author: Sandhya Bankar <bankarsandhya512@gmail.com>
Date:   Tue Sep 20 12:15:15 2016 +0530

    Staging: ks7010: Use "foo *bar" instead of "foo * bar"
    
    This patch was found by checkpatch.
    
    Signed-off-by: Sandhya Bankar <bankarsandhya512@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index e6f6445bab4c..aad80487316c 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1766,7 +1766,7 @@ void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
 
 static
 void hostif_bss_scan_request(struct ks_wlan_private *priv,
-			     unsigned long scan_type, uint8_t * scan_ssid,
+			     unsigned long scan_type, uint8_t *scan_ssid,
 			     uint8_t scan_ssid_len)
 {
 	struct hostif_bss_scan_request_t *pp;

commit 0525a57b1879370fe0e330708bda3b1c25c937f1
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Mon Sep 19 01:46:34 2016 +0530

    staging: ks7010: Remove unnecessary variable used to store return value
    
    This patch removes an unnecessary variable used to store return values in order
    to reduce memory usage.
    Done using coccinelle:
    @@
    type T;
    constant C;
    identifier ret;
    @@
    - T ret = C;
    ... when != ret
    return
    - ret
    + C
    ;
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index f2bdd4715ecc..e6f6445bab4c 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -92,8 +92,6 @@ static void ks_wlan_hw_wakeup_task(struct work_struct *work)
 static
 int ks_wlan_do_power_save(struct ks_wlan_private *priv)
 {
-	int rc = 0;
-
 	DPRINTK(4, "psstatus.status=%d\n", atomic_read(&priv->psstatus.status));
 
 	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
@@ -101,7 +99,7 @@ int ks_wlan_do_power_save(struct ks_wlan_private *priv)
 	} else {
 		priv->dev_state = DEVICE_STATE_READY;
 	}
-	return rc;
+	return 0;
 }
 
 static
@@ -213,7 +211,6 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 {
 	unsigned char *bp;
 	int bsize, offset;
-	int rc = 0;
 
 	DPRINTK(3, "\n");
 	memset(ap, 0, sizeof(struct local_ap_t));
@@ -311,7 +308,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 		bp += (*(bp + 1) + 2);	/* pointer update */
 	}
 
-	return rc;
+	return 0;
 }
 
 static
@@ -2681,7 +2678,6 @@ void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
 
 int hostif_init(struct ks_wlan_private *priv)
 {
-	int rc = 0;
 	int i;
 
 	DPRINTK(3, "\n");
@@ -2731,7 +2727,7 @@ int hostif_init(struct ks_wlan_private *priv)
 
 	tasklet_init(&priv->sme_task, hostif_sme_task, (unsigned long)priv);
 
-	return rc;
+	return 0;
 }
 
 void hostif_exit(struct ks_wlan_private *priv)

commit 197cc86e8e0de1f9f4d2a738e73b9acf34bdc347
Author: Hariharan R <hariharanrangasamy@gmail.com>
Date:   Sun Sep 18 20:16:03 2016 -0400

    staging: ks7010: fixes typo in ks_hostif.c
    
    Fixes typo,
    FAILUER -> FAILURE
    Recieve -> Receive
    
    Signed-off-by: Hariharan R <hariharanrangasamy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index eb0192da66c1..f2bdd4715ecc 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1226,7 +1226,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	eth_hdr = (struct ether_hdr *)&pp->data[0];
 	eth_proto = ntohs(eth_hdr->h_proto);
 
-	/* for MIC FAILUER REPORT check */
+	/* for MIC FAILURE REPORT check */
 	if (eth_proto == ETHER_PROTOCOL_TYPE_EAP
 	    && priv->wpa.mic_failure.failure > 0) {
 		aa1x_hdr = (struct ieee802_1x_hdr *)(eth_hdr + 1);
@@ -1279,7 +1279,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 			  (void *)send_packet_complete, (void *)priv,
 			  (void *)packet);
 
-	/* MIC FAILUER REPORT check */
+	/* MIC FAILURE REPORT check */
 	if (eth_proto == ETHER_PROTOCOL_TYPE_EAP
 	    && priv->wpa.mic_failure.failure > 0) {
 		if (keyinfo & WPA_KEY_INFO_ERROR
@@ -1848,7 +1848,7 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 }
 
-/* Device I/O Recieve indicate */
+/* Device I/O Receive indicate */
 static void devio_rec_ind(struct ks_wlan_private *priv, unsigned char *p,
 			  unsigned int size)
 {

commit 2751bc918e61a114704f2a6673d316a38878319d
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Sep 17 13:09:13 2016 +0530

    Staging: ks7010: Remove extern keyword from function declaration
    
    Remove extern specifier from function declaration as they have
    it by default. Also move extern declaration from .c files to
    their respective header file 'ks_hostif.h'. Coccinelle was used
    to remove extern and other changes were done by hand.
    Script:
    @@
    identifier func;
    type T;
    @@
    - extern
    T func(...);
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index deb82ab6e4a3..eb0192da66c1 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -21,15 +21,6 @@
 /* Include Wireless Extension definition and check version */
 #include <net/iw_handler.h>	/* New driver API */
 
-extern int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p,
-			 unsigned long size,
-			 void (*complete_handler) (void *arg1, void *arg2),
-			 void *arg1, void *arg2);
-extern void send_packet_complete(void *, void *);
-
-extern void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv);
-extern int ks_wlan_hw_power_save(struct ks_wlan_private *priv);
-
 /* macro */
 #define inc_smeqhead(priv) \
         ( priv->sme_i.qhead = (priv->sme_i.qhead + 1) % SME_EVENT_BUFF_SIZE )

commit 30b48e2dbe7f4d78fb8f7abbef9851ec36a93dff
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Fri Sep 16 19:54:37 2016 +0530

    Staging: ks7010: Replace memset with eth_zero_addr
    
    Use eth_zero_addr to assign zero address to the given address array
    instead of memset when the second argument in memset is address
    of zero. Coccinelle was used to do the replacement and add the
    header file linux/etherdevice.h if not already present.
    Script:
    @header@
    @@
    #include <linux/etherdevice.h>
    
    @r1@
    expression e;
    @@
    
    -memset(e,0,ETH_ALEN);
    +eth_zero_addr(e);
    
    @includeheader depends on r1 && !header@
    @@
    + #include <linux/etherdevice.h>
    #include <...>
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index e3cc8ce26344..deb82ab6e4a3 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -14,6 +14,7 @@
 #include "eap_packet.h"
 #include "michael_mic.h"
 
+#include <linux/etherdevice.h>
 #include <linux/if_ether.h>
 #include <linux/if_arp.h>
 
@@ -780,7 +781,7 @@ void hostif_start_confirm(struct ks_wlan_private *priv)
 	wrqu.data.flags = 0;
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
 	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
-		memset(wrqu.ap_addr.sa_data, '\0', ETH_ALEN);
+		eth_zero_addr(wrqu.ap_addr.sa_data);
 		DPRINTK(3, "IWEVENT: disconnect\n");
 		wireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);
 	}
@@ -838,7 +839,7 @@ void hostif_connect_indication(struct ks_wlan_private *priv)
 	wrqu0.ap_addr.sa_family = ARPHRD_ETHER;
 	if ((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS &&
 	    (old_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
-		memset(wrqu0.ap_addr.sa_data, '\0', ETH_ALEN);
+		eth_zero_addr(wrqu0.ap_addr.sa_data);
 		DPRINTK(3, "IWEVENT: disconnect\n");
 		DPRINTK(3, "disconnect :: scan_ind_count=%d\n",
 			priv->scan_ind_count);
@@ -910,7 +911,7 @@ void hostif_stop_confirm(struct ks_wlan_private *priv)
 		if ((priv->connect_status & CONNECT_STATUS_MASK) ==
 		    DISCONNECT_STATUS
 		    && (old_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
-			memset(wrqu0.ap_addr.sa_data, '\0', ETH_ALEN);
+			eth_zero_addr(wrqu0.ap_addr.sa_data);
 			DPRINTK(3, "IWEVENT: disconnect\n");
 			printk("IWEVENT: disconnect\n");
 			DPRINTK(3, "disconnect :: scan_ind_count=%d\n",

commit a1a736df3a811241100737b90f21582742529cff
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Thu Sep 15 14:08:22 2016 +0530

    staging: ks7010: Remove the explicit cast on kmalloc
    
    The assignment operator implicitly converts a void pointer to the type of the
    pointer it is assigned to. Hence an explicit cast on the result of the kmalloc
    function is not required.
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 76ba2366caca..e3cc8ce26344 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1174,9 +1174,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	}
 
 	DPRINTK(4, "skb_buff length=%d\n", packet_len);
-	pp = (struct hostif_data_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp) + 6 + packet_len + 8),
-		    KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp) + 6 + packet_len + 8),
+		     KS_WLAN_MEM_FLAG);
 
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
@@ -1317,8 +1316,7 @@ void hostif_mib_get_request(struct ks_wlan_private *priv,
 	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_mib_get_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
@@ -1348,8 +1346,7 @@ void hostif_mib_set_request(struct ks_wlan_private *priv,
 	}
 
 	/* make primitive */
-	pp = (struct hostif_mib_set_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp) + size), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp) + size), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
@@ -1378,8 +1375,7 @@ void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_start_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
@@ -1406,8 +1402,7 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_ps_adhoc_set_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
@@ -1450,8 +1445,7 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 	DPRINTK(3, "ssid.size=%d\n", priv->reg.ssid.size);
 
 	/* make primitive */
-	pp = (struct hostif_infrastructure_set_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
@@ -1517,8 +1511,7 @@ static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 	DPRINTK(2, "ssid.size=%d\n", priv->reg.ssid.size);
 
 	/* make primitive */
-	pp = (struct hostif_infrastructure_set2_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
@@ -1587,8 +1580,7 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_adhoc_set_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
@@ -1633,8 +1625,7 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_adhoc_set2_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
@@ -1681,8 +1672,7 @@ void hostif_stop_request(struct ks_wlan_private *priv)
 	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_stop_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
@@ -1704,8 +1694,7 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_phy_information_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
@@ -1736,8 +1725,7 @@ void hostif_power_mngmt_request(struct ks_wlan_private *priv,
 	DPRINTK(3, "mode=%lu wake_up=%lu receiveDTIMs=%lu\n", mode, wake_up,
 		receiveDTIMs);
 	/* make primitive */
-	pp = (struct hostif_power_mngmt_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
@@ -1763,8 +1751,7 @@ void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
 
 	if (mode == SLP_SLEEP) {
 		/* make primitive */
-		pp = (struct hostif_sleep_request_t *)
-		    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+		pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 		if (!pp) {
 			DPRINTK(3, "allocate memory failed..\n");
 			return;
@@ -1797,8 +1784,7 @@ void hostif_bss_scan_request(struct ks_wlan_private *priv,
 
 	DPRINTK(2, "\n");
 	/* make primitive */
-	pp = (struct hostif_bss_scan_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
@@ -1854,8 +1840,7 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 
 	DPRINTK(3, "count=%d :: timer=%d\n", failure_count, timer);
 	/* make primitive */
-	pp = (struct hostif_mic_failure_request_t *)
-	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	pp = kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
 	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;

commit c8abeaf8021b1d78ba3b86235815047c8d648f4a
Author: Rehas Sachdeva <aquannie@gmail.com>
Date:   Thu Sep 15 00:52:58 2016 +0530

    staging: ks7010: Remove whitespace before newline
    
    This patch fixes the checkpatch.pl warning:
    WARNING: unnecessary whitespace before a quoted newline.
    
    Signed-off-by: Rehas Sachdeva <aquannie@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 8e33a43ca46b..76ba2366caca 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -244,13 +244,13 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 	offset = 0;
 
 	while (bsize > offset) {
-		/* DPRINTK(4, "Element ID=%d \n",*bp); */
+		/* DPRINTK(4, "Element ID=%d\n",*bp); */
 		switch (*bp) {
 		case 0:	/* ssid */
 			if (*(bp + 1) <= SSID_MAX_SIZE) {
 				ap->ssid.size = *(bp + 1);
 			} else {
-				DPRINTK(1, "size over :: ssid size=%d \n",
+				DPRINTK(1, "size over :: ssid size=%d\n",
 					*(bp + 1));
 				ap->ssid.size = SSID_MAX_SIZE;
 			}
@@ -264,7 +264,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 				       bp + 2, *(bp + 1));
 				ap->rate_set.size += *(bp + 1);
 			} else {
-				DPRINTK(1, "size over :: rate size=%d \n",
+				DPRINTK(1, "size over :: rate size=%d\n",
 					(*(bp + 1) + ap->rate_set.size));
 				memcpy(&(ap->rate_set.body[ap->rate_set.size]),
 				       bp + 2,
@@ -280,7 +280,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 			if (*(bp + 1) <= RSN_IE_BODY_MAX) {
 				ap->rsn_ie.size = *(bp + 1);
 			} else {
-				DPRINTK(1, "size over :: rsn size=%d \n",
+				DPRINTK(1, "size over :: rsn size=%d\n",
 					*(bp + 1));
 				ap->rsn_ie.size = RSN_IE_BODY_MAX;
 			}
@@ -293,7 +293,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 					ap->wpa_ie.size = *(bp + 1);
 				} else {
 					DPRINTK(1,
-						"size over :: wpa size=%d \n",
+						"size over :: wpa size=%d\n",
 						*(bp + 1));
 					ap->wpa_ie.size = RSN_IE_BODY_MAX;
 				}
@@ -311,7 +311,7 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 		case 47:	/* Reserve ID 47 Broadcom AP */
 			break;
 		default:
-			DPRINTK(4, "unknown Element ID=%d \n", *bp);
+			DPRINTK(4, "unknown Element ID=%d\n", *bp);
 			break;
 		}
 		offset += 2;	/* id & size field */
@@ -408,7 +408,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 					    HZ >= 60) {
 						mic_failure->failure = 0;
 					}
-					DPRINTK(4, "MIC FAILURE \n");
+					DPRINTK(4, "MIC FAILURE\n");
 					if (mic_failure->failure == 0) {
 						mic_failure->failure = 1;
 						mic_failure->counter = 0;
@@ -1150,7 +1150,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 
 	packet_len = packet->len;
 	if (packet_len > ETH_FRAME_LEN) {
-		DPRINTK(1, "bad length packet_len=%d \n", packet_len);
+		DPRINTK(1, "bad length packet_len=%d\n", packet_len);
 		dev_kfree_skb(packet);
 		return -1;
 	}
@@ -1447,7 +1447,7 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 	struct hostif_infrastructure_set_request_t *pp;
 	uint16_t capability;
 
-	DPRINTK(3, "ssid.size=%d \n", priv->reg.ssid.size);
+	DPRINTK(3, "ssid.size=%d\n", priv->reg.ssid.size);
 
 	/* make primitive */
 	pp = (struct hostif_infrastructure_set_request_t *)
@@ -1514,7 +1514,7 @@ static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 	struct hostif_infrastructure_set2_request_t *pp;
 	uint16_t capability;
 
-	DPRINTK(2, "ssid.size=%d \n", priv->reg.ssid.size);
+	DPRINTK(2, "ssid.size=%d\n", priv->reg.ssid.size);
 
 	/* make primitive */
 	pp = (struct hostif_infrastructure_set2_request_t *)
@@ -1759,7 +1759,7 @@ void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
 {
 	struct hostif_sleep_request_t *pp;
 
-	DPRINTK(3, "mode=%lu \n", mode);
+	DPRINTK(3, "mode=%lu\n", mode);
 
 	if (mode == SLP_SLEEP) {
 		/* make primitive */
@@ -1783,7 +1783,7 @@ void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
 		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
 				   &priv->ks_wlan_hw.rw_wq, 1);
 	} else {
-		DPRINTK(3, "invalid mode %ld \n", mode);
+		DPRINTK(3, "invalid mode %ld\n", mode);
 		return;
 	}
 }

commit c7e65f4d2f7968de8605ef1b83ac1019e8e51d22
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Tue Sep 13 02:47:28 2016 +0530

    staging: ks7010: Remove the explicit NULL comparison
    
    The patch removes the explicit null comparisons entirely for the ks7010 driver.
    This was detected by checkpatch.pl
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index e09df36016ad..8e33a43ca46b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1178,7 +1178,7 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	    kmalloc(hif_align_size(sizeof(*pp) + 6 + packet_len + 8),
 		    KS_WLAN_MEM_FLAG);
 
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		dev_kfree_skb(packet);
 		return -2;
@@ -1319,7 +1319,7 @@ void hostif_mib_get_request(struct ks_wlan_private *priv,
 	/* make primitive */
 	pp = (struct hostif_mib_get_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
@@ -1350,7 +1350,7 @@ void hostif_mib_set_request(struct ks_wlan_private *priv,
 	/* make primitive */
 	pp = (struct hostif_mib_set_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp) + size), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
@@ -1380,7 +1380,7 @@ void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 	/* make primitive */
 	pp = (struct hostif_start_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
@@ -1408,7 +1408,7 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 	/* make primitive */
 	pp = (struct hostif_ps_adhoc_set_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
@@ -1452,7 +1452,7 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 	/* make primitive */
 	pp = (struct hostif_infrastructure_set_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
@@ -1519,7 +1519,7 @@ static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 	/* make primitive */
 	pp = (struct hostif_infrastructure_set2_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
@@ -1589,7 +1589,7 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 	/* make primitive */
 	pp = (struct hostif_adhoc_set_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
@@ -1635,7 +1635,7 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 	/* make primitive */
 	pp = (struct hostif_adhoc_set2_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
@@ -1683,7 +1683,7 @@ void hostif_stop_request(struct ks_wlan_private *priv)
 	/* make primitive */
 	pp = (struct hostif_stop_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
@@ -1706,7 +1706,7 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 	/* make primitive */
 	pp = (struct hostif_phy_information_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
@@ -1738,7 +1738,7 @@ void hostif_power_mngmt_request(struct ks_wlan_private *priv,
 	/* make primitive */
 	pp = (struct hostif_power_mngmt_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
@@ -1765,7 +1765,7 @@ void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
 		/* make primitive */
 		pp = (struct hostif_sleep_request_t *)
 		    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-		if (pp == NULL) {
+		if (!pp) {
 			DPRINTK(3, "allocate memory failed..\n");
 			return;
 		}
@@ -1799,7 +1799,7 @@ void hostif_bss_scan_request(struct ks_wlan_private *priv,
 	/* make primitive */
 	pp = (struct hostif_bss_scan_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
@@ -1856,7 +1856,7 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 	/* make primitive */
 	pp = (struct hostif_mic_failure_request_t *)
 	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
-	if (pp == NULL) {
+	if (!pp) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}

commit aeaf5d86faa5d8c64674465da544c26c97e9404a
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Sep 9 16:56:38 2016 +0100

    staging: ks7010: fix two memory leaks on error return path
    
    On the error case where there is an invalid MAC address there is
    memory leak on packet and pp on the error return. Free these first
    before returning to fix the leak.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index c5fc31c0038d..e09df36016ad 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1196,6 +1196,8 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 		DPRINTK(1, "ethernet->h_source=%02X:%02X:%02X:%02X:%02X:%02X\n",
 			eth->h_source[0], eth->h_source[1], eth->h_source[2],
 			eth->h_source[3], eth->h_source[4], eth->h_source[5]);
+		dev_kfree_skb(packet);
+		kfree(pp);
 		return -3;
 	}
 

commit 95d2a324660ac46420b64481507dcedab7341dad
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Aug 15 15:45:04 2016 +0100

    staging: ks7010: don't print skb->dev->name if skb is null
    
    A null pointer dereference will occur when skb is null and
    skb->dev->name is printed.  Replace the skb->dev->name with
    plain text "ks_wlan" to fix this.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index f4cee811cabd..c5fc31c0038d 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -485,8 +485,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 			netif_rx(skb);
 		} else {
 			printk(KERN_WARNING
-			       "%s: Memory squeeze, dropping packet.\n",
-			       skb->dev->name);
+			       "ks_wlan: Memory squeeze, dropping packet.\n");
 			priv->nstats.rx_dropped++;
 		}
 		break;
@@ -521,8 +520,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 			netif_rx(skb);
 		} else {
 			printk(KERN_WARNING
-			       "%s: Memory squeeze, dropping packet.\n",
-			       skb->dev->name);
+			       "ks_wlan: Memory squeeze, dropping packet.\n");
 			priv->nstats.rx_dropped++;
 		}
 		break;

commit 9afe11e956766eaac4643adaaf49f223dd536c92
Author: Nicholas Mc Guire <hofrat@osadl.org>
Date:   Mon Jul 25 21:22:27 2016 +0200

    staging: ks7010: declare private functions static
    
    Private functions in ks_hostif.c can be declared static.
    
    Fixes: 13a9930d15b4 ("staging: ks7010: add driver from Nanonote extra-repository")
    
    Signed-off-by: Nicholas Mc Guire <hofrat@osadl.org>
    Reviewed-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 6deee462eca7..f4cee811cabd 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -69,7 +69,7 @@ inline u32 get_DWORD(struct ks_wlan_private *priv)
 	return data;
 }
 
-void ks_wlan_hw_wakeup_task(struct work_struct *work)
+static void ks_wlan_hw_wakeup_task(struct work_struct *work)
 {
 	struct ks_wlan_private *priv =
 	    container_of(work, struct ks_wlan_private, ks_wlan_wakeup_task);
@@ -1509,7 +1509,7 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 }
 
-void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
+static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 {
 	struct hostif_infrastructure_set2_request_t *pp;
 	uint16_t capability;

commit 9d29f14db1095f52ca00b8162b242d6fce07d19f
Author: Nicholas Mc Guire <hofrat@osadl.org>
Date:   Mon Jul 25 21:21:50 2016 +0200

    staging: ks7010: fix wait_for_completion_interruptible_timeout return handling
    
    wait_for_completion_interruptible_timeout return 0 on timeout and
    -ERESTARTSYS if interrupted. The check for
    !wait_for_completion_interruptible_timeout() would report an interrupt
    as timeout. Further, while HZ/50 will work most of the time it could
    fail for HZ < 50, so this is switched to msecs_to_jiffies(20).
    
    Fixes: 13a9930d15b4 ("staging: ks7010: add driver from Nanonote extra-repository")
    
    Signed-off-by: Nicholas Mc Guire <hofrat@osadl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index a8822fe2bd60..6deee462eca7 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -74,11 +74,15 @@ void ks_wlan_hw_wakeup_task(struct work_struct *work)
 	struct ks_wlan_private *priv =
 	    container_of(work, struct ks_wlan_private, ks_wlan_wakeup_task);
 	int ps_status = atomic_read(&priv->psstatus.status);
+	long time_left;
 
 	if (ps_status == PS_SNOOZE) {
 		ks_wlan_hw_wakeup_request(priv);
-		if (!wait_for_completion_interruptible_timeout(&priv->psstatus.wakeup_wait, HZ / 50)) {	/* 20ms timeout */
-			DPRINTK(1, "wake up timeout !!!\n");
+		time_left = wait_for_completion_interruptible_timeout(
+				&priv->psstatus.wakeup_wait,
+				msecs_to_jiffies(20));
+		if (time_left <= 0) {
+			DPRINTK(1, "wake up timeout or interrupted !!!\n");
 			schedule_work(&priv->ks_wlan_wakeup_task);
 			return;
 		}

commit c5d9a03031a645a8c63fdaa6a650113f8bd55b2b
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:43 2016 +0200

    staging: ks7010: cleanup file headers
    
    Remove svn-ids and fix typos in the licence declaration. Add my
    copyright to the sdio code which I worked on mainly.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index f2a65c0ae630..a8822fe2bd60 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -1,15 +1,12 @@
 /*
  *   Driver for KeyStream wireless LAN cards.
  *
- *   ks_hostif.c
- *   $Id: ks_hostif.c 996 2009-09-14 02:54:21Z sekine $
- *
  *   Copyright (C) 2005-2008 KeyStream Corp.
  *   Copyright (C) 2009 Renesas Technology Corp.
  *
  *   This program is free software; you can redistribute it and/or modify
- *   it undr the terms of the GNU General Public License version 2 as
- *   published by the Free Sotware Foundation.
+ *   it under the terms of the GNU General Public License version 2 as
+ *   published by the Free Software Foundation.
  */
 
 #include "ks_wlan.h"

commit 20c4f9c52e619a12e0a63eea708f0225b248e788
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:30 2016 +0200

    staging: ks7010: indent ks_hostif.c
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 497b8aaf6dae..f2a65c0ae630 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -23,9 +23,10 @@
 /* Include Wireless Extension definition and check version */
 #include <net/iw_handler.h>	/* New driver API */
 
-extern int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
-			 void (*complete_handler)(void *arg1, void *arg2),
-			 void *arg1, void *arg2 );
+extern int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p,
+			 unsigned long size,
+			 void (*complete_handler) (void *arg1, void *arg2),
+			 void *arg1, void *arg2);
 extern void send_packet_complete(void *, void *);
 
 extern void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv);
@@ -55,7 +56,7 @@ static
 inline u16 get_WORD(struct ks_wlan_private *priv)
 {
 	u16 data;
-	data  = (get_BYTE(priv) & 0xff);
+	data = (get_BYTE(priv) & 0xff);
 	data |= ((get_BYTE(priv) << 8) & 0xff00);
 	return data;
 }
@@ -64,7 +65,7 @@ static
 inline u32 get_DWORD(struct ks_wlan_private *priv)
 {
 	u32 data;
-	data  = (get_BYTE(priv) & 0xff);
+	data = (get_BYTE(priv) & 0xff);
 	data |= ((get_BYTE(priv) << 8) & 0x0000ff00);
 	data |= ((get_BYTE(priv) << 16) & 0x00ff0000);
 	data |= ((get_BYTE(priv) << 24) & 0xff000000);
@@ -73,24 +74,24 @@ inline u32 get_DWORD(struct ks_wlan_private *priv)
 
 void ks_wlan_hw_wakeup_task(struct work_struct *work)
 {
-	struct ks_wlan_private *priv = container_of(work, struct ks_wlan_private, ks_wlan_wakeup_task);
+	struct ks_wlan_private *priv =
+	    container_of(work, struct ks_wlan_private, ks_wlan_wakeup_task);
 	int ps_status = atomic_read(&priv->psstatus.status);
 
-	if(ps_status==PS_SNOOZE){
+	if (ps_status == PS_SNOOZE) {
 		ks_wlan_hw_wakeup_request(priv);
-		if(!wait_for_completion_interruptible_timeout(&priv->psstatus.wakeup_wait,HZ/50)){ /* 20ms timeout */
-			DPRINTK(1,"wake up timeout !!!\n");
+		if (!wait_for_completion_interruptible_timeout(&priv->psstatus.wakeup_wait, HZ / 50)) {	/* 20ms timeout */
+			DPRINTK(1, "wake up timeout !!!\n");
 			schedule_work(&priv->ks_wlan_wakeup_task);
 			return;
 		}
-	}
-	else{
-		DPRINTK(1,"ps_status=%d\n",ps_status);
+	} else {
+		DPRINTK(1, "ps_status=%d\n", ps_status);
 	}
 
 	/* power save */
-	if(atomic_read(&priv->sme_task.count) > 0){
-		DPRINTK(4,"sme task enable.\n");
+	if (atomic_read(&priv->sme_task.count) > 0) {
+		DPRINTK(4, "sme task enable.\n");
 		tasklet_enable(&priv->sme_task);
 	}
 }
@@ -98,14 +99,13 @@ void ks_wlan_hw_wakeup_task(struct work_struct *work)
 static
 int ks_wlan_do_power_save(struct ks_wlan_private *priv)
 {
-	int rc=0;
+	int rc = 0;
 
-	DPRINTK(4,"psstatus.status=%d\n",atomic_read(&priv->psstatus.status));
+	DPRINTK(4, "psstatus.status=%d\n", atomic_read(&priv->psstatus.status));
 
-	if((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS){
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
 		hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
-	}
-	else{
+	} else {
 		priv->dev_state = DEVICE_STATE_READY;
 	}
 	return rc;
@@ -116,26 +116,28 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 {
 	struct local_ap_t *ap;
 	union iwreq_data wrqu;
-	struct net_device *netdev=priv->net_dev;
-	int rc=0;
+	struct net_device *netdev = priv->net_dev;
+	int rc = 0;
 
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 	ap = &(priv->current_ap);
 
-	if((priv->connect_status & CONNECT_STATUS_MASK)== DISCONNECT_STATUS){
-		memset(ap,0,sizeof(struct local_ap_t));
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS) {
+		memset(ap, 0, sizeof(struct local_ap_t));
 		return 1;
 	}
 
 	/* bssid */
-	memcpy(&(ap->bssid[0]),&(ap_info->bssid[0]),ETH_ALEN);
+	memcpy(&(ap->bssid[0]), &(ap_info->bssid[0]), ETH_ALEN);
 	/* essid */
-	memcpy(&(ap->ssid.body[0]),&(priv->reg.ssid.body[0]),priv->reg.ssid.size);
+	memcpy(&(ap->ssid.body[0]), &(priv->reg.ssid.body[0]),
+	       priv->reg.ssid.size);
 	ap->ssid.size = priv->reg.ssid.size;
 	/* rate_set */
-	memcpy(&(ap->rate_set.body[0]),&(ap_info->rate_set.body[0]),ap_info->rate_set.size);
+	memcpy(&(ap->rate_set.body[0]), &(ap_info->rate_set.body[0]),
+	       ap_info->rate_set.size);
 	ap->rate_set.size = ap_info->rate_set.size;
-	if(ap_info->ext_rate_set.size){
+	if (ap_info->ext_rate_set.size) {
 		/* rate_set */
 		memcpy(&(ap->rate_set.body[ap->rate_set.size]),
 		       &(ap_info->ext_rate_set.body[0]),
@@ -153,29 +155,31 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	/* capability */
 	ap->capability = ap_info->capability;
 	/* rsn */
-	if((ap_info->rsn_mode & RSN_MODE_WPA2) && (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)){
+	if ((ap_info->rsn_mode & RSN_MODE_WPA2)
+	    && (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)) {
 		ap->rsn_ie.id = 0x30;
-		if(ap_info->rsn.size <= RSN_IE_BODY_MAX){
+		if (ap_info->rsn.size <= RSN_IE_BODY_MAX) {
 			ap->rsn_ie.size = ap_info->rsn.size;
-			memcpy(&(ap->rsn_ie.body[0]),&(ap_info->rsn.body[0]),ap_info->rsn.size);
-		}
-		else{
+			memcpy(&(ap->rsn_ie.body[0]), &(ap_info->rsn.body[0]),
+			       ap_info->rsn.size);
+		} else {
 			ap->rsn_ie.size = RSN_IE_BODY_MAX;
-			memcpy(&(ap->rsn_ie.body[0]),&(ap_info->rsn.body[0]),RSN_IE_BODY_MAX);
+			memcpy(&(ap->rsn_ie.body[0]), &(ap_info->rsn.body[0]),
+			       RSN_IE_BODY_MAX);
 		}
-	}
-	else if((ap_info->rsn_mode & RSN_MODE_WPA) && (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA)){
+	} else if ((ap_info->rsn_mode & RSN_MODE_WPA)
+		   && (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA)) {
 		ap->wpa_ie.id = 0xdd;
-		if(ap_info->rsn.size <= RSN_IE_BODY_MAX){
+		if (ap_info->rsn.size <= RSN_IE_BODY_MAX) {
 			ap->wpa_ie.size = ap_info->rsn.size;
-			memcpy(&(ap->wpa_ie.body[0]),&(ap_info->rsn.body[0]),ap_info->rsn.size);
-		}
-		else{
+			memcpy(&(ap->wpa_ie.body[0]), &(ap_info->rsn.body[0]),
+			       ap_info->rsn.size);
+		} else {
 			ap->wpa_ie.size = RSN_IE_BODY_MAX;
-			memcpy(&(ap->wpa_ie.body[0]),&(ap_info->rsn.body[0]),RSN_IE_BODY_MAX);
+			memcpy(&(ap->wpa_ie.body[0]), &(ap_info->rsn.body[0]),
+			       RSN_IE_BODY_MAX);
 		}
-	}
-	else{
+	} else {
 		ap->rsn_ie.id = 0;
 		ap->rsn_ie.size = 0;
 		ap->wpa_ie.id = 0;
@@ -185,45 +189,44 @@ int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 	wrqu.data.length = 0;
 	wrqu.data.flags = 0;
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-	if((priv->connect_status & CONNECT_STATUS_MASK)==CONNECT_STATUS){
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
 		memcpy(wrqu.ap_addr.sa_data,
 		       &(priv->current_ap.bssid[0]), ETH_ALEN);
-		DPRINTK(3,"IWEVENT: connect bssid=%02x:%02x:%02x:%02x:%02x:%02x\n",
-			(unsigned char)wrqu.ap_addr.sa_data[0],(unsigned char)wrqu.ap_addr.sa_data[1],
-			(unsigned char)wrqu.ap_addr.sa_data[2],(unsigned char)wrqu.ap_addr.sa_data[3],
-			(unsigned char)wrqu.ap_addr.sa_data[4],(unsigned char)wrqu.ap_addr.sa_data[5]);
+		DPRINTK(3,
+			"IWEVENT: connect bssid=%02x:%02x:%02x:%02x:%02x:%02x\n",
+			(unsigned char)wrqu.ap_addr.sa_data[0],
+			(unsigned char)wrqu.ap_addr.sa_data[1],
+			(unsigned char)wrqu.ap_addr.sa_data[2],
+			(unsigned char)wrqu.ap_addr.sa_data[3],
+			(unsigned char)wrqu.ap_addr.sa_data[4],
+			(unsigned char)wrqu.ap_addr.sa_data[5]);
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);
 	}
-	DPRINTK(4,"\n    Link AP\n");
-	DPRINTK(4,"    bssid=%02X:%02X:%02X:%02X:%02X:%02X\n \
+	DPRINTK(4, "\n    Link AP\n");
+	DPRINTK(4, "    bssid=%02X:%02X:%02X:%02X:%02X:%02X\n \
    essid=%s\n    rate_set=%02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X\n    channel=%d\n \
-   rssi=%d\n    sq=%d\n    capability=%04X\n",
-		ap->bssid[0],ap->bssid[1],ap->bssid[2],ap->bssid[3],ap->bssid[4],
-		ap->bssid[5],&(ap->ssid.body[0]),ap->rate_set.body[0],ap->rate_set.body[1],
-		ap->rate_set.body[2],ap->rate_set.body[3],ap->rate_set.body[4],
-		ap->rate_set.body[5],ap->rate_set.body[6],ap->rate_set.body[7],
-		ap->channel,ap->rssi,ap->sq,ap->capability);
-	DPRINTK(4,"\n    Link AP\n    rsn.mode=%d\n    rsn.size=%d\n",
-		ap_info->rsn_mode,ap_info->rsn.size);
-	DPRINTK(4,"\n    ext_rate_set_size=%d\n    rate_set_size=%d\n",
-		ap_info->ext_rate_set.size,ap_info->rate_set.size);
-
+   rssi=%d\n    sq=%d\n    capability=%04X\n", ap->bssid[0], ap->bssid[1], ap->bssid[2], ap->bssid[3], ap->bssid[4], ap->bssid[5], &(ap->ssid.body[0]), ap->rate_set.body[0], ap->rate_set.body[1], ap->rate_set.body[2], ap->rate_set.body[3], ap->rate_set.body[4], ap->rate_set.body[5], ap->rate_set.body[6], ap->rate_set.body[7], ap->channel, ap->rssi, ap->sq, ap->capability);
+	DPRINTK(4, "\n    Link AP\n    rsn.mode=%d\n    rsn.size=%d\n",
+		ap_info->rsn_mode, ap_info->rsn.size);
+	DPRINTK(4, "\n    ext_rate_set_size=%d\n    rate_set_size=%d\n",
+		ap_info->ext_rate_set.size, ap_info->rate_set.size);
 
 	return rc;
 }
 
 static
-int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info, struct local_ap_t *ap)
+int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
+		       struct local_ap_t *ap)
 {
 	unsigned char *bp;
-	int bsize,offset;
-	int rc=0;
+	int bsize, offset;
+	int rc = 0;
 
-	DPRINTK(3,"\n");
-	memset(ap,0,sizeof(struct local_ap_t));
+	DPRINTK(3, "\n");
+	memset(ap, 0, sizeof(struct local_ap_t));
 
 	/* bssid */
-	memcpy(&(ap->bssid[0]),&(ap_info->bssid[0]),ETH_ALEN);
+	memcpy(&(ap->bssid[0]), &(ap_info->bssid[0]), ETH_ALEN);
 	/* rssi */
 	ap->rssi = ap_info->rssi;
 	/* sq */
@@ -239,73 +242,80 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 	bsize = ap_info->body_size;
 	offset = 0;
 
-	while(bsize > offset){
+	while (bsize > offset) {
 		/* DPRINTK(4, "Element ID=%d \n",*bp); */
-		switch(*bp){
-		case 0: /* ssid */
-			if(*(bp+1) <= SSID_MAX_SIZE){
-				ap->ssid.size = *(bp+1);
-			}
-			else {
-				DPRINTK(1, "size over :: ssid size=%d \n",*(bp+1));
+		switch (*bp) {
+		case 0:	/* ssid */
+			if (*(bp + 1) <= SSID_MAX_SIZE) {
+				ap->ssid.size = *(bp + 1);
+			} else {
+				DPRINTK(1, "size over :: ssid size=%d \n",
+					*(bp + 1));
 				ap->ssid.size = SSID_MAX_SIZE;
 			}
-			memcpy(&(ap->ssid.body[0]),bp+2,ap->ssid.size);
+			memcpy(&(ap->ssid.body[0]), bp + 2, ap->ssid.size);
 			break;
-		case 1: /* rate */
-		case 50: /* ext rate */
-			if((*(bp+1) + ap->rate_set.size) <= RATE_SET_MAX_SIZE){
-				memcpy(&(ap->rate_set.body[ap->rate_set.size]),bp+2,*(bp+1));
-				ap->rate_set.size += *(bp+1);
-			}
-			else{
+		case 1:	/* rate */
+		case 50:	/* ext rate */
+			if ((*(bp + 1) + ap->rate_set.size) <=
+			    RATE_SET_MAX_SIZE) {
+				memcpy(&(ap->rate_set.body[ap->rate_set.size]),
+				       bp + 2, *(bp + 1));
+				ap->rate_set.size += *(bp + 1);
+			} else {
 				DPRINTK(1, "size over :: rate size=%d \n",
-					(*(bp+1) + ap->rate_set.size));
-				memcpy(&(ap->rate_set.body[ap->rate_set.size]),bp+2,
+					(*(bp + 1) + ap->rate_set.size));
+				memcpy(&(ap->rate_set.body[ap->rate_set.size]),
+				       bp + 2,
 				       RATE_SET_MAX_SIZE - ap->rate_set.size);
-				ap->rate_set.size += (RATE_SET_MAX_SIZE - ap->rate_set.size);
+				ap->rate_set.size +=
+				    (RATE_SET_MAX_SIZE - ap->rate_set.size);
 			}
 			break;
-		case 3: /* DS parameter */
+		case 3:	/* DS parameter */
 			break;
-		case 48: /* RSN(WPA2) */
+		case 48:	/* RSN(WPA2) */
 			ap->rsn_ie.id = *bp;
-			if(*(bp+1) <= RSN_IE_BODY_MAX){
-				ap->rsn_ie.size = *(bp+1);
-			}else{
-				DPRINTK(1, "size over :: rsn size=%d \n",*(bp+1));
+			if (*(bp + 1) <= RSN_IE_BODY_MAX) {
+				ap->rsn_ie.size = *(bp + 1);
+			} else {
+				DPRINTK(1, "size over :: rsn size=%d \n",
+					*(bp + 1));
 				ap->rsn_ie.size = RSN_IE_BODY_MAX;
 			}
-			memcpy(&(ap->rsn_ie.body[0]),bp+2,ap->rsn_ie.size);
+			memcpy(&(ap->rsn_ie.body[0]), bp + 2, ap->rsn_ie.size);
 			break;
-		case 221: /* WPA */
-			if(!memcmp(bp+2, "\x00\x50\xf2\x01", 4)){ /* WPA OUI check */
+		case 221:	/* WPA */
+			if (!memcmp(bp + 2, "\x00\x50\xf2\x01", 4)) {	/* WPA OUI check */
 				ap->wpa_ie.id = *bp;
-				if(*(bp+1) <= RSN_IE_BODY_MAX){
-					ap->wpa_ie.size = *(bp+1);
-				}else{
-					DPRINTK(1, "size over :: wpa size=%d \n",*(bp+1));
+				if (*(bp + 1) <= RSN_IE_BODY_MAX) {
+					ap->wpa_ie.size = *(bp + 1);
+				} else {
+					DPRINTK(1,
+						"size over :: wpa size=%d \n",
+						*(bp + 1));
 					ap->wpa_ie.size = RSN_IE_BODY_MAX;
 				}
-				memcpy(&(ap->wpa_ie.body[0]),bp+2,ap->wpa_ie.size);
+				memcpy(&(ap->wpa_ie.body[0]), bp + 2,
+				       ap->wpa_ie.size);
 			}
 			break;
 
-		case 2: /* FH parameter */
-		case 4: /* CF parameter */
-		case 5: /* TIM */
-		case 6: /* IBSS parameter */
-		case 7: /* Country */
-		case 42: /* ERP information */
-		case 47: /* Reserve ID 47 Broadcom AP */
+		case 2:	/* FH parameter */
+		case 4:	/* CF parameter */
+		case 5:	/* TIM */
+		case 6:	/* IBSS parameter */
+		case 7:	/* Country */
+		case 42:	/* ERP information */
+		case 47:	/* Reserve ID 47 Broadcom AP */
 			break;
 		default:
-			DPRINTK(4, "unknown Element ID=%d \n",*bp);
+			DPRINTK(4, "unknown Element ID=%d \n", *bp);
 			break;
 		}
-		offset += 2;		/* id & size field */
-		offset += *(bp+1);	/* +size offset */
-		bp += (*(bp+1) + 2);	/* pointer update */
+		offset += 2;	/* id & size field */
+		offset += *(bp + 1);	/* +size offset */
+		bp += (*(bp + 1) + 2);	/* pointer update */
 	}
 
 	return rc;
@@ -314,12 +324,12 @@ int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info,
 static
 void hostif_data_indication(struct ks_wlan_private *priv)
 {
-	unsigned int	rx_ind_size;	/* indicate data size */
+	unsigned int rx_ind_size;	/* indicate data size */
 	struct sk_buff *skb;
-	unsigned short   auth_type;
-	unsigned char	temp[256];
+	unsigned short auth_type;
+	unsigned char temp[256];
 
-	unsigned char	RecvMIC[8];
+	unsigned char RecvMIC[8];
 	char buf[128];
 	struct ether_hdr *eth_hdr;
 	unsigned short eth_proto;
@@ -330,162 +340,193 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 	struct michel_mic_t michel_mic;
 	union iwreq_data wrqu;
 
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
 	/* min length check */
 	if (priv->rx_size <= ETH_HLEN) {
-		DPRINTK(3,"rx_size = %d\n", priv->rx_size);
+		DPRINTK(3, "rx_size = %d\n", priv->rx_size);
 		priv->nstats.rx_errors++;
 		return;
 	}
 
-	auth_type = get_WORD(priv); /* AuthType */
-	get_WORD(priv); /* Reserve Area */
+	auth_type = get_WORD(priv);	/* AuthType */
+	get_WORD(priv);	/* Reserve Area */
 
 	eth_hdr = (struct ether_hdr *)(priv->rxp);
 	eth_proto = ntohs(eth_hdr->h_proto);
-	DPRINTK(3,"ether protocol = %04X\n", eth_proto);
+	DPRINTK(3, "ether protocol = %04X\n", eth_proto);
 
 	/* source address check */
-	if (!memcmp(&priv->eth_addr[0],eth_hdr->h_source, ETH_ALEN)){
+	if (!memcmp(&priv->eth_addr[0], eth_hdr->h_source, ETH_ALEN)) {
 		DPRINTK(1, "invalid : source is own mac address !!\n");
-		DPRINTK(1, "eth_hdrernet->h_dest=%02X:%02X:%02X:%02X:%02X:%02X\n",
-			eth_hdr->h_source[0],eth_hdr->h_source[1],eth_hdr->h_source[2],
-			eth_hdr->h_source[3],eth_hdr->h_source[4],eth_hdr->h_source[5]);
+		DPRINTK(1,
+			"eth_hdrernet->h_dest=%02X:%02X:%02X:%02X:%02X:%02X\n",
+			eth_hdr->h_source[0], eth_hdr->h_source[1],
+			eth_hdr->h_source[2], eth_hdr->h_source[3],
+			eth_hdr->h_source[4], eth_hdr->h_source[5]);
 		priv->nstats.rx_errors++;
 		return;
 	}
 
 	/*  for WPA */
-	if (auth_type != TYPE_DATA && priv->wpa.rsn_enabled){
-		if(memcmp(&eth_hdr->h_source[0],&priv->eth_addr[0],ETH_ALEN)){ /* source address check */
-			if (eth_hdr->h_dest_snap != eth_hdr->h_source_snap){
-				DPRINTK(1,"invalid data format\n");
+	if (auth_type != TYPE_DATA && priv->wpa.rsn_enabled) {
+		if (memcmp(&eth_hdr->h_source[0], &priv->eth_addr[0], ETH_ALEN)) {	/* source address check */
+			if (eth_hdr->h_dest_snap != eth_hdr->h_source_snap) {
+				DPRINTK(1, "invalid data format\n");
 				priv->nstats.rx_errors++;
 				return;
 			}
-			if(((auth_type==TYPE_PMK1 && priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP)||
-			    (auth_type==TYPE_GMK1 && priv->wpa.group_suite == IW_AUTH_CIPHER_TKIP)||
-			    (auth_type==TYPE_GMK2 && priv->wpa.group_suite == IW_AUTH_CIPHER_TKIP))
-			   && priv->wpa.key[auth_type-1].key_len){
-				DPRINTK(4,"TKIP: protocol=%04X: size=%u\n", eth_proto, priv->rx_size);
+			if (((auth_type == TYPE_PMK1
+			      && priv->wpa.pairwise_suite ==
+			      IW_AUTH_CIPHER_TKIP) || (auth_type == TYPE_GMK1
+						       && priv->wpa.
+						       group_suite ==
+						       IW_AUTH_CIPHER_TKIP)
+			     || (auth_type == TYPE_GMK2
+				 && priv->wpa.group_suite ==
+				 IW_AUTH_CIPHER_TKIP))
+			    && priv->wpa.key[auth_type - 1].key_len) {
+				DPRINTK(4, "TKIP: protocol=%04X: size=%u\n",
+					eth_proto, priv->rx_size);
 				/* MIC save */
-				memcpy(&RecvMIC[0], (priv->rxp)+((priv->rx_size)-8), 8);
+				memcpy(&RecvMIC[0],
+				       (priv->rxp) + ((priv->rx_size) - 8), 8);
 				priv->rx_size = priv->rx_size - 8;
-				if(auth_type > 0 && auth_type < 4){ /* auth_type check */
-					MichaelMICFunction(&michel_mic,
-							   (uint8_t*)priv->wpa.key[auth_type-1].rx_mic_key,
-							   (uint8_t*)priv->rxp,
-							   (int)priv->rx_size,
-							   (uint8_t)0, /* priority */
-							   (uint8_t*)michel_mic.Result);
+				if (auth_type > 0 && auth_type < 4) {	/* auth_type check */
+					MichaelMICFunction(&michel_mic, (uint8_t *) priv->wpa.key[auth_type - 1].rx_mic_key, (uint8_t *) priv->rxp, (int)priv->rx_size, (uint8_t) 0,	/* priority */
+							   (uint8_t *)
+							   michel_mic.Result);
 				}
-				if(memcmp(michel_mic.Result, RecvMIC, 8)){
+				if (memcmp(michel_mic.Result, RecvMIC, 8)) {
 					now = jiffies;
 					mic_failure = &priv->wpa.mic_failure;
 					/* MIC FAILURE */
-					if(mic_failure->last_failure_time &&
-					   (now - mic_failure->last_failure_time)/HZ >= 60){
-						mic_failure->failure=0;
+					if (mic_failure->last_failure_time &&
+					    (now -
+					     mic_failure->last_failure_time) /
+					    HZ >= 60) {
+						mic_failure->failure = 0;
 					}
-					DPRINTK(4,"MIC FAILURE \n");
-					if(mic_failure->failure==0){
-						mic_failure->failure=1;
-						mic_failure->counter=0;
-					}else if(mic_failure->failure==1){
-						mic_failure->failure=2;
+					DPRINTK(4, "MIC FAILURE \n");
+					if (mic_failure->failure == 0) {
+						mic_failure->failure = 1;
+						mic_failure->counter = 0;
+					} else if (mic_failure->failure == 1) {
+						mic_failure->failure = 2;
 						mic_failure->counter =
-							(uint16_t)((now - mic_failure->last_failure_time)/HZ);
-						if(!mic_failure->counter) /* mic_failure counter value range 1-60 */
-							mic_failure->counter = 1;
+						    (uint16_t) ((now -
+								 mic_failure->
+								 last_failure_time)
+								/ HZ);
+						if (!mic_failure->counter)	/* mic_failure counter value range 1-60 */
+							mic_failure->counter =
+							    1;
 					}
-					priv->wpa.mic_failure.last_failure_time = now;
+					priv->wpa.mic_failure.
+					    last_failure_time = now;
 					/*  needed parameters: count, keyid, key type, TSC */
-					sprintf(buf, "MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
+					sprintf(buf,
+						"MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
 						"%02x:%02x:%02x:%02x:%02x:%02x)",
-						auth_type-1, eth_hdr->h_dest[0] & 0x01 ? "broad" : "uni",
-						eth_hdr->h_source[0],eth_hdr->h_source[1],
-						eth_hdr->h_source[2],eth_hdr->h_source[3],
-						eth_hdr->h_source[4],eth_hdr->h_source[5]);
+						auth_type - 1,
+						eth_hdr->
+						h_dest[0] & 0x01 ? "broad" :
+						"uni", eth_hdr->h_source[0],
+						eth_hdr->h_source[1],
+						eth_hdr->h_source[2],
+						eth_hdr->h_source[3],
+						eth_hdr->h_source[4],
+						eth_hdr->h_source[5]);
 					memset(&wrqu, 0, sizeof(wrqu));
 					wrqu.data.length = strlen(buf);
-					DPRINTK(4,"IWEVENT:MICHAELMICFAILURE\n");
-					wireless_send_event(priv->net_dev, IWEVCUSTOM, &wrqu, buf);
+					DPRINTK(4,
+						"IWEVENT:MICHAELMICFAILURE\n");
+					wireless_send_event(priv->net_dev,
+							    IWEVCUSTOM, &wrqu,
+							    buf);
 					return;
 				}
 			}
 		}
 	}
 
-	if((priv->connect_status & FORCE_DISCONNECT)||
-	   priv->wpa.mic_failure.failure==2){
+	if ((priv->connect_status & FORCE_DISCONNECT) ||
+	    priv->wpa.mic_failure.failure == 2) {
 		return;
 	}
 
 	/* check 13th byte at rx data */
-	switch (*(priv->rxp+12)) {
-	case 0xAA: /* SNAP */
+	switch (*(priv->rxp + 12)) {
+	case 0xAA:	/* SNAP */
 		rx_ind_size = priv->rx_size - 6;
-		skb = dev_alloc_skb (rx_ind_size);
-		DPRINTK(4,"SNAP, rx_ind_size = %d\n", rx_ind_size);
-
-		if(skb) {
-		        memcpy(skb_put(skb,12),priv->rxp,12); /* 8802/FDDI MAC copy */
-		        /* (SNAP+UI..) skip */
-			memcpy(skb_put(skb,rx_ind_size-12),priv->rxp+18,rx_ind_size-12); /* copy after Type */
-
-			aa1x_hdr=(struct ieee802_1x_hdr *)(priv->rxp+20);
-			if(aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY  && priv->wpa.rsn_enabled){
-				eap_key = (struct wpa_eapol_key *)(aa1x_hdr+1);
+		skb = dev_alloc_skb(rx_ind_size);
+		DPRINTK(4, "SNAP, rx_ind_size = %d\n", rx_ind_size);
+
+		if (skb) {
+			memcpy(skb_put(skb, 12), priv->rxp, 12);	/* 8802/FDDI MAC copy */
+			/* (SNAP+UI..) skip */
+			memcpy(skb_put(skb, rx_ind_size - 12), priv->rxp + 18, rx_ind_size - 12);	/* copy after Type */
+
+			aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 20);
+			if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY
+			    && priv->wpa.rsn_enabled) {
+				eap_key =
+				    (struct wpa_eapol_key *)(aa1x_hdr + 1);
 				atomic_set(&priv->psstatus.snooze_guard, 1);
 			}
 
 			/* rx indication */
 			skb->dev = priv->net_dev;
-			skb->protocol = eth_type_trans (skb, skb->dev);
+			skb->protocol = eth_type_trans(skb, skb->dev);
 			priv->nstats.rx_packets++;
 			priv->nstats.rx_bytes += rx_ind_size;
 			skb->dev->last_rx = jiffies;
-			netif_rx (skb);
+			netif_rx(skb);
 		} else {
-			printk (KERN_WARNING"%s: Memory squeeze, dropping packet.\n",skb->dev->name);
+			printk(KERN_WARNING
+			       "%s: Memory squeeze, dropping packet.\n",
+			       skb->dev->name);
 			priv->nstats.rx_dropped++;
 		}
 		break;
-	case 0xF0: /* NETBEUI/NetBIOS */
+	case 0xF0:	/* NETBEUI/NetBIOS */
 		rx_ind_size = (priv->rx_size + 2);
-		skb = dev_alloc_skb (rx_ind_size);
-		DPRINTK(3,"NETBEUI/NetBIOS rx_ind_size=%d\n", rx_ind_size);
+		skb = dev_alloc_skb(rx_ind_size);
+		DPRINTK(3, "NETBEUI/NetBIOS rx_ind_size=%d\n", rx_ind_size);
 
-		if(skb) {
-		        memcpy(skb_put(skb,12),priv->rxp,12); /* 8802/FDDI MAC copy */
+		if (skb) {
+			memcpy(skb_put(skb, 12), priv->rxp, 12);	/* 8802/FDDI MAC copy */
 
-			temp[0] = (((rx_ind_size-12) >> 8) & 0xff); /* NETBEUI size add */
-			temp[1] = ((rx_ind_size-12) & 0xff);
-			memcpy(skb_put(skb,2),temp,2);
+			temp[0] = (((rx_ind_size - 12) >> 8) & 0xff);	/* NETBEUI size add */
+			temp[1] = ((rx_ind_size - 12) & 0xff);
+			memcpy(skb_put(skb, 2), temp, 2);
 
-			memcpy(skb_put(skb,rx_ind_size-14),priv->rxp+12,rx_ind_size-14); /* copy after Type */
+			memcpy(skb_put(skb, rx_ind_size - 14), priv->rxp + 12, rx_ind_size - 14);	/* copy after Type */
 
-			aa1x_hdr=(struct ieee802_1x_hdr *)(priv->rxp+14);
-			if(aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY && priv->wpa.rsn_enabled){
-				eap_key = (struct wpa_eapol_key *)(aa1x_hdr+1);
+			aa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 14);
+			if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY
+			    && priv->wpa.rsn_enabled) {
+				eap_key =
+				    (struct wpa_eapol_key *)(aa1x_hdr + 1);
 				atomic_set(&priv->psstatus.snooze_guard, 1);
 			}
 
 			/* rx indication */
 			skb->dev = priv->net_dev;
-			skb->protocol = eth_type_trans (skb, skb->dev);
+			skb->protocol = eth_type_trans(skb, skb->dev);
 			priv->nstats.rx_packets++;
 			priv->nstats.rx_bytes += rx_ind_size;
 			skb->dev->last_rx = jiffies;
-			netif_rx (skb);
+			netif_rx(skb);
 		} else {
-			printk (KERN_WARNING"%s: Memory squeeze, dropping packet.\n",skb->dev->name);
+			printk(KERN_WARNING
+			       "%s: Memory squeeze, dropping packet.\n",
+			       skb->dev->name);
 			priv->nstats.rx_dropped++;
 		}
 		break;
-	default: /* other rx data */
-		DPRINTK(2,"invalid data format\n");
+	default:	/* other rx data */
+		DPRINTK(2, "invalid data format\n");
 		priv->nstats.rx_errors++;
 	}
 }
@@ -493,29 +534,30 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 static
 void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 {
-	struct net_device *dev=priv->net_dev;
-	uint32_t	mib_status;
-	uint32_t	mib_attribute;
-	uint16_t	mib_val_size;
-	uint16_t	mib_val_type;
+	struct net_device *dev = priv->net_dev;
+	uint32_t mib_status;
+	uint32_t mib_attribute;
+	uint16_t mib_val_size;
+	uint16_t mib_val_type;
 
 	DPRINTK(3, "\n");
 
-	mib_status = get_DWORD(priv);		/* MIB status */
-	mib_attribute = get_DWORD(priv);		/* MIB atttibute */
-	mib_val_size = get_WORD(priv);		/* MIB value size */
-	mib_val_type = get_WORD(priv);		/* MIB value type */
+	mib_status = get_DWORD(priv);	/* MIB status */
+	mib_attribute = get_DWORD(priv);	/* MIB atttibute */
+	mib_val_size = get_WORD(priv);	/* MIB value size */
+	mib_val_type = get_WORD(priv);	/* MIB value type */
 
 	if (mib_status != 0) {
 		/* in case of error */
-		DPRINTK(1, "attribute=%08X, status=%08X\n", mib_attribute, mib_status);
+		DPRINTK(1, "attribute=%08X, status=%08X\n", mib_attribute,
+			mib_status);
 		return;
 	}
 
 	switch (mib_attribute) {
 	case DOT11_MAC_ADDRESS:
 		/* MAC address */
-		DPRINTK(3," mib_attribute=DOT11_MAC_ADDRESS\n");
+		DPRINTK(3, " mib_attribute=DOT11_MAC_ADDRESS\n");
 		hostif_sme_enqueue(priv, SME_GET_MAC_ADDRESS);
 		memcpy(priv->eth_addr, priv->rxp, ETH_ALEN);
 		priv->mac_address_valid = 1;
@@ -527,44 +569,48 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 		dev->dev_addr[5] = priv->eth_addr[5];
 		dev->dev_addr[6] = 0x00;
 		dev->dev_addr[7] = 0x00;
-		printk(KERN_INFO "ks_wlan: MAC ADDRESS = %02x:%02x:%02x:%02x:%02x:%02x\n",
-		       priv->eth_addr[0],priv->eth_addr[1],priv->eth_addr[2],
-		       priv->eth_addr[3],priv->eth_addr[4],priv->eth_addr[5]);
+		printk(KERN_INFO
+		       "ks_wlan: MAC ADDRESS = %02x:%02x:%02x:%02x:%02x:%02x\n",
+		       priv->eth_addr[0], priv->eth_addr[1], priv->eth_addr[2],
+		       priv->eth_addr[3], priv->eth_addr[4], priv->eth_addr[5]);
 		break;
 	case DOT11_PRODUCT_VERSION:
 		/* firmware version */
-		DPRINTK(3," mib_attribute=DOT11_PRODUCT_VERSION\n");
+		DPRINTK(3, " mib_attribute=DOT11_PRODUCT_VERSION\n");
 		priv->version_size = priv->rx_size;
 		memcpy(priv->firmware_version, priv->rxp, priv->rx_size);
 		priv->firmware_version[priv->rx_size] = '\0';
-	        printk(KERN_INFO "ks_wlan: firmware ver. = %s\n",priv->firmware_version);
+		printk(KERN_INFO "ks_wlan: firmware ver. = %s\n",
+		       priv->firmware_version);
 		hostif_sme_enqueue(priv, SME_GET_PRODUCT_VERSION);
 		/* wake_up_interruptible_all(&priv->confirm_wait); */
 		complete(&priv->confirm_wait);
 		break;
 	case LOCAL_GAIN:
 		memcpy(&priv->gain, priv->rxp, sizeof(priv->gain));
-	        DPRINTK(3, "TxMode=%d, RxMode=%d, TxGain=%d, RxGain=%d\n",
-			priv->gain.TxMode, priv->gain.RxMode, priv->gain.TxGain, priv->gain.RxGain);
+		DPRINTK(3, "TxMode=%d, RxMode=%d, TxGain=%d, RxGain=%d\n",
+			priv->gain.TxMode, priv->gain.RxMode, priv->gain.TxGain,
+			priv->gain.RxGain);
 		break;
 	case LOCAL_EEPROM_SUM:
 		memcpy(&priv->eeprom_sum, priv->rxp, sizeof(priv->eeprom_sum));
-	        DPRINTK(1, "eeprom_sum.type=%x, eeprom_sum.result=%x\n", priv->eeprom_sum.type, priv->eeprom_sum.result);
-		if(priv->eeprom_sum.type == 0){
+		DPRINTK(1, "eeprom_sum.type=%x, eeprom_sum.result=%x\n",
+			priv->eeprom_sum.type, priv->eeprom_sum.result);
+		if (priv->eeprom_sum.type == 0) {
 			priv->eeprom_checksum = EEPROM_CHECKSUM_NONE;
-		}else if(priv->eeprom_sum.type == 1){
-			if(priv->eeprom_sum.result == 0){
+		} else if (priv->eeprom_sum.type == 1) {
+			if (priv->eeprom_sum.result == 0) {
 				priv->eeprom_checksum = EEPROM_NG;
 				printk("LOCAL_EEPROM_SUM NG\n");
-			}else if(priv->eeprom_sum.result == 1){
+			} else if (priv->eeprom_sum.result == 1) {
 				priv->eeprom_checksum = EEPROM_OK;
 			}
-		}else{
+		} else {
 			printk("LOCAL_EEPROM_SUM error!\n");
 		}
 		break;
 	default:
-		DPRINTK(1,"mib_attribute=%08x\n",(unsigned int)mib_attribute);
+		DPRINTK(1, "mib_attribute=%08x\n", (unsigned int)mib_attribute);
 		break;
 	}
 }
@@ -572,17 +618,18 @@ void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 static
 void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 {
-	uint32_t	mib_status;	/* +04 MIB Status */
-	uint32_t	mib_attribute;	/* +08 MIB attribute */
+	uint32_t mib_status;	/* +04 MIB Status */
+	uint32_t mib_attribute;	/* +08 MIB attribute */
 
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
-	mib_status	= get_DWORD(priv);	/* MIB Status */
-	mib_attribute	= get_DWORD(priv);	/* MIB attribute */
+	mib_status = get_DWORD(priv);	/* MIB Status */
+	mib_attribute = get_DWORD(priv);	/* MIB attribute */
 
 	if (mib_status != 0) {
 		/* in case of error */
-		DPRINTK(1, "error :: attribute=%08X, status=%08X\n", mib_attribute, mib_status);
+		DPRINTK(1, "error :: attribute=%08X, status=%08X\n",
+			mib_attribute, mib_status);
 	}
 
 	switch (mib_attribute) {
@@ -593,41 +640,46 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 		hostif_sme_enqueue(priv, SME_FRAGMENTATION_THRESHOLD_CONFIRM);
 		break;
 	case DOT11_WEP_DEFAULT_KEY_ID:
-		if(!priv->wpa.wpa_enabled)
+		if (!priv->wpa.wpa_enabled)
 			hostif_sme_enqueue(priv, SME_WEP_INDEX_CONFIRM);
 		break;
 	case DOT11_WEP_DEFAULT_KEY_VALUE1:
-		DPRINTK(2,"DOT11_WEP_DEFAULT_KEY_VALUE1:mib_status=%d\n",(int)mib_status);
-		if(priv->wpa.rsn_enabled)
+		DPRINTK(2, "DOT11_WEP_DEFAULT_KEY_VALUE1:mib_status=%d\n",
+			(int)mib_status);
+		if (priv->wpa.rsn_enabled)
 			hostif_sme_enqueue(priv, SME_SET_PMK_TSC);
 		else
 			hostif_sme_enqueue(priv, SME_WEP_KEY1_CONFIRM);
 		break;
 	case DOT11_WEP_DEFAULT_KEY_VALUE2:
-		DPRINTK(2,"DOT11_WEP_DEFAULT_KEY_VALUE2:mib_status=%d\n",(int)mib_status);
-		if(priv->wpa.rsn_enabled)
+		DPRINTK(2, "DOT11_WEP_DEFAULT_KEY_VALUE2:mib_status=%d\n",
+			(int)mib_status);
+		if (priv->wpa.rsn_enabled)
 			hostif_sme_enqueue(priv, SME_SET_GMK1_TSC);
 		else
 			hostif_sme_enqueue(priv, SME_WEP_KEY2_CONFIRM);
 		break;
 	case DOT11_WEP_DEFAULT_KEY_VALUE3:
-		DPRINTK(2,"DOT11_WEP_DEFAULT_KEY_VALUE3:mib_status=%d\n",(int)mib_status);
-		if(priv->wpa.rsn_enabled)
+		DPRINTK(2, "DOT11_WEP_DEFAULT_KEY_VALUE3:mib_status=%d\n",
+			(int)mib_status);
+		if (priv->wpa.rsn_enabled)
 			hostif_sme_enqueue(priv, SME_SET_GMK2_TSC);
 		else
 			hostif_sme_enqueue(priv, SME_WEP_KEY3_CONFIRM);
 		break;
 	case DOT11_WEP_DEFAULT_KEY_VALUE4:
-		DPRINTK(2,"DOT11_WEP_DEFAULT_KEY_VALUE4:mib_status=%d\n",(int)mib_status);
-		if(!priv->wpa.rsn_enabled)
+		DPRINTK(2, "DOT11_WEP_DEFAULT_KEY_VALUE4:mib_status=%d\n",
+			(int)mib_status);
+		if (!priv->wpa.rsn_enabled)
 			hostif_sme_enqueue(priv, SME_WEP_KEY4_CONFIRM);
 		break;
 	case DOT11_PRIVACY_INVOKED:
-		if(!priv->wpa.rsn_enabled)
+		if (!priv->wpa.rsn_enabled)
 			hostif_sme_enqueue(priv, SME_WEP_FLAG_CONFIRM);
 		break;
 	case DOT11_RSN_ENABLED:
-		DPRINTK(2,"DOT11_RSN_ENABLED:mib_status=%d\n",(int)mib_status);
+		DPRINTK(2, "DOT11_RSN_ENABLED:mib_status=%d\n",
+			(int)mib_status);
 		hostif_sme_enqueue(priv, SME_RSN_ENABLED_CONFIRM);
 		break;
 	case LOCAL_RSN_MODE:
@@ -643,49 +695,53 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 		priv->mac_address_valid = 1;
 		break;
 	case DOT11_RSN_CONFIG_MULTICAST_CIPHER:
-		DPRINTK(2,"DOT11_RSN_CONFIG_MULTICAST_CIPHER:mib_status=%d\n",(int)mib_status);
+		DPRINTK(2, "DOT11_RSN_CONFIG_MULTICAST_CIPHER:mib_status=%d\n",
+			(int)mib_status);
 		hostif_sme_enqueue(priv, SME_RSN_MCAST_CONFIRM);
 		break;
 	case DOT11_RSN_CONFIG_UNICAST_CIPHER:
-		DPRINTK(2,"DOT11_RSN_CONFIG_UNICAST_CIPHER:mib_status=%d\n",(int)mib_status);
+		DPRINTK(2, "DOT11_RSN_CONFIG_UNICAST_CIPHER:mib_status=%d\n",
+			(int)mib_status);
 		hostif_sme_enqueue(priv, SME_RSN_UCAST_CONFIRM);
 		break;
 	case DOT11_RSN_CONFIG_AUTH_SUITE:
-		DPRINTK(2,"DOT11_RSN_CONFIG_AUTH_SUITE:mib_status=%d\n",(int)mib_status);
+		DPRINTK(2, "DOT11_RSN_CONFIG_AUTH_SUITE:mib_status=%d\n",
+			(int)mib_status);
 		hostif_sme_enqueue(priv, SME_RSN_AUTH_CONFIRM);
 		break;
 	case DOT11_PMK_TSC:
-		DPRINTK(2,"DOT11_PMK_TSC:mib_status=%d\n",(int)mib_status);
+		DPRINTK(2, "DOT11_PMK_TSC:mib_status=%d\n", (int)mib_status);
 		break;
 	case DOT11_GMK1_TSC:
-		DPRINTK(2,"DOT11_GMK1_TSC:mib_status=%d\n",(int)mib_status);
-		if(atomic_read(&priv->psstatus.snooze_guard)){
+		DPRINTK(2, "DOT11_GMK1_TSC:mib_status=%d\n", (int)mib_status);
+		if (atomic_read(&priv->psstatus.snooze_guard)) {
 			atomic_set(&priv->psstatus.snooze_guard, 0);
 		}
 		break;
 	case DOT11_GMK2_TSC:
-		DPRINTK(2,"DOT11_GMK2_TSC:mib_status=%d\n",(int)mib_status);
-		if(atomic_read(&priv->psstatus.snooze_guard)){
+		DPRINTK(2, "DOT11_GMK2_TSC:mib_status=%d\n", (int)mib_status);
+		if (atomic_read(&priv->psstatus.snooze_guard)) {
 			atomic_set(&priv->psstatus.snooze_guard, 0);
 		}
 		break;
 	case LOCAL_PMK:
-		DPRINTK(2,"LOCAL_PMK:mib_status=%d\n",(int)mib_status);
+		DPRINTK(2, "LOCAL_PMK:mib_status=%d\n", (int)mib_status);
 		break;
 	case LOCAL_GAIN:
-		DPRINTK(2,"LOCAL_GAIN:mib_status=%d\n",(int)mib_status);
+		DPRINTK(2, "LOCAL_GAIN:mib_status=%d\n", (int)mib_status);
 		break;
 #ifdef WPS
 	case LOCAL_WPS_ENABLE:
-		DPRINTK(2,"LOCAL_WPS_ENABLE:mib_status=%d\n",(int)mib_status);
+		DPRINTK(2, "LOCAL_WPS_ENABLE:mib_status=%d\n", (int)mib_status);
 		break;
 	case LOCAL_WPS_PROBE_REQ:
-		DPRINTK(2,"LOCAL_WPS_PROBE_REQ:mib_status=%d\n",(int)mib_status);
+		DPRINTK(2, "LOCAL_WPS_PROBE_REQ:mib_status=%d\n",
+			(int)mib_status);
 		break;
 #endif /* WPS */
 	case LOCAL_REGION:
-		DPRINTK(2,"LOCAL_REGION:mib_status=%d\n",(int)mib_status);
-	default :
+		DPRINTK(2, "LOCAL_REGION:mib_status=%d\n", (int)mib_status);
+	default:
 		break;
 	}
 }
@@ -693,14 +749,14 @@ void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 static
 void hostif_power_mngmt_confirm(struct ks_wlan_private *priv)
 {
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
-	if(priv->reg.powermgt > POWMGT_ACTIVE_MODE &&
-	   priv->reg.operation_mode == MODE_INFRASTRUCTURE){
+	if (priv->reg.powermgt > POWMGT_ACTIVE_MODE &&
+	    priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 		atomic_set(&priv->psstatus.confirm_wait, 0);
 		priv->dev_state = DEVICE_STATE_SLEEP;
 		ks_wlan_hw_power_save(priv);
-	}else{
+	} else {
 		priv->dev_state = DEVICE_STATE_READY;
 	}
 
@@ -709,27 +765,28 @@ void hostif_power_mngmt_confirm(struct ks_wlan_private *priv)
 static
 void hostif_sleep_confirm(struct ks_wlan_private *priv)
 {
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
-	atomic_set(&priv->sleepstatus.doze_request,1);
-	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+	atomic_set(&priv->sleepstatus.doze_request, 1);
+	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+			   &priv->ks_wlan_hw.rw_wq, 1);
 }
 
 static
 void hostif_start_confirm(struct ks_wlan_private *priv)
 {
 #ifdef  WPS
-       union iwreq_data        wrqu;
-       wrqu.data.length = 0;
-       wrqu.data.flags = 0;
-       wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-       if((priv->connect_status & CONNECT_STATUS_MASK)== CONNECT_STATUS){
-               memset(wrqu.ap_addr.sa_data, '\0', ETH_ALEN);
-               DPRINTK(3,"IWEVENT: disconnect\n");
-               wireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);
-       }
+	union iwreq_data wrqu;
+	wrqu.data.length = 0;
+	wrqu.data.flags = 0;
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
+		memset(wrqu.ap_addr.sa_data, '\0', ETH_ALEN);
+		DPRINTK(3, "IWEVENT: disconnect\n");
+		wireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);
+	}
 #endif
-	DPRINTK(3," scan_ind_count=%d\n",priv->scan_ind_count);
+	DPRINTK(3, " scan_ind_count=%d\n", priv->scan_ind_count);
 	hostif_sme_enqueue(priv, SME_START_CONFIRM);
 }
 
@@ -737,29 +794,31 @@ static
 void hostif_connect_indication(struct ks_wlan_private *priv)
 {
 	unsigned short connect_code;
-	unsigned int tmp=0;
-	unsigned int old_status=priv->connect_status;
-	struct net_device *netdev=priv->net_dev;
+	unsigned int tmp = 0;
+	unsigned int old_status = priv->connect_status;
+	struct net_device *netdev = priv->net_dev;
 	union iwreq_data wrqu0;
 	connect_code = get_WORD(priv);
 
-	switch(connect_code){
-	case RESULT_CONNECT: /* connect */
-		DPRINTK(3,"connect :: scan_ind_count=%d\n",priv->scan_ind_count);
-		if(!(priv->connect_status & FORCE_DISCONNECT))
+	switch (connect_code) {
+	case RESULT_CONNECT:	/* connect */
+		DPRINTK(3, "connect :: scan_ind_count=%d\n",
+			priv->scan_ind_count);
+		if (!(priv->connect_status & FORCE_DISCONNECT))
 			netif_carrier_on(netdev);
 		tmp = FORCE_DISCONNECT & priv->connect_status;
 		priv->connect_status = tmp + CONNECT_STATUS;
 		break;
-	case RESULT_DISCONNECT: /* disconnect */
-		DPRINTK(3,"disconnect :: scan_ind_count=%d\n",priv->scan_ind_count);
+	case RESULT_DISCONNECT:	/* disconnect */
+		DPRINTK(3, "disconnect :: scan_ind_count=%d\n",
+			priv->scan_ind_count);
 		netif_carrier_off(netdev);
 		tmp = FORCE_DISCONNECT & priv->connect_status;
 		priv->connect_status = tmp + DISCONNECT_STATUS;
 		break;
 	default:
-		DPRINTK(1,"unknown connect_code=%d :: scan_ind_count=%d\n",
-			connect_code,priv->scan_ind_count);
+		DPRINTK(1, "unknown connect_code=%d :: scan_ind_count=%d\n",
+			connect_code, priv->scan_ind_count);
 		netif_carrier_off(netdev);
 		tmp = FORCE_DISCONNECT & priv->connect_status;
 		priv->connect_status = tmp + DISCONNECT_STATUS;
@@ -767,25 +826,26 @@ void hostif_connect_indication(struct ks_wlan_private *priv)
 	}
 
 	get_current_ap(priv, (struct link_ap_info_t *)priv->rxp);
-	if((priv->connect_status & CONNECT_STATUS_MASK)== CONNECT_STATUS &&
-	   (old_status & CONNECT_STATUS_MASK)==DISCONNECT_STATUS ){
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS &&
+	    (old_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS) {
 		/* for power save */
 		atomic_set(&priv->psstatus.snooze_guard, 0);
-		atomic_set(&priv->psstatus.confirm_wait,0);
+		atomic_set(&priv->psstatus.confirm_wait, 0);
 	}
 	ks_wlan_do_power_save(priv);
 
 	wrqu0.data.length = 0;
 	wrqu0.data.flags = 0;
 	wrqu0.ap_addr.sa_family = ARPHRD_ETHER;
-	if((priv->connect_status & CONNECT_STATUS_MASK)== DISCONNECT_STATUS &&
-	   (old_status & CONNECT_STATUS_MASK)==CONNECT_STATUS ){
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS &&
+	    (old_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
 		memset(wrqu0.ap_addr.sa_data, '\0', ETH_ALEN);
-		DPRINTK(3,"IWEVENT: disconnect\n");
-		DPRINTK(3,"disconnect :: scan_ind_count=%d\n",priv->scan_ind_count);
+		DPRINTK(3, "IWEVENT: disconnect\n");
+		DPRINTK(3, "disconnect :: scan_ind_count=%d\n",
+			priv->scan_ind_count);
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu0, NULL);
 	}
-	priv->scan_ind_count=0;
+	priv->scan_ind_count = 0;
 }
 
 static
@@ -794,45 +854,52 @@ void hostif_scan_indication(struct ks_wlan_private *priv)
 	int i;
 	struct ap_info_t *ap_info;
 
-	DPRINTK(3,"scan_ind_count = %d\n", priv->scan_ind_count);
+	DPRINTK(3, "scan_ind_count = %d\n", priv->scan_ind_count);
 	ap_info = (struct ap_info_t *)(priv->rxp);
 
-	if(priv->scan_ind_count!=0){
-		for(i=0;i<priv->aplist.size;i++){ /* bssid check */
-			if(!memcmp(&(ap_info->bssid[0]),&(priv->aplist.ap[i].bssid[0]),ETH_ALEN)){
-				if(ap_info->frame_type == FRAME_TYPE_PROBE_RESP)
-					get_ap_information(priv,ap_info,&(priv->aplist.ap[i]));
+	if (priv->scan_ind_count != 0) {
+		for (i = 0; i < priv->aplist.size; i++) {	/* bssid check */
+			if (!memcmp
+			    (&(ap_info->bssid[0]),
+			     &(priv->aplist.ap[i].bssid[0]), ETH_ALEN)) {
+				if (ap_info->frame_type ==
+				    FRAME_TYPE_PROBE_RESP)
+					get_ap_information(priv, ap_info,
+							   &(priv->aplist.
+							     ap[i]));
 				return;
 			}
 		}
 	}
 	priv->scan_ind_count++;
-	if(priv->scan_ind_count < LOCAL_APLIST_MAX+1){
-		DPRINTK(4," scan_ind_count=%d :: aplist.size=%d\n", priv->scan_ind_count, priv->aplist.size);
-		get_ap_information(priv,(struct ap_info_t *)(priv->rxp),&(priv->aplist.ap[priv->scan_ind_count-1]));
+	if (priv->scan_ind_count < LOCAL_APLIST_MAX + 1) {
+		DPRINTK(4, " scan_ind_count=%d :: aplist.size=%d\n",
+			priv->scan_ind_count, priv->aplist.size);
+		get_ap_information(priv, (struct ap_info_t *)(priv->rxp),
+				   &(priv->aplist.
+				     ap[priv->scan_ind_count - 1]));
 		priv->aplist.size = priv->scan_ind_count;
+	} else {
+		DPRINTK(4, " count over :: scan_ind_count=%d\n",
+			priv->scan_ind_count);
 	}
-	else{
-		DPRINTK(4," count over :: scan_ind_count=%d\n", priv->scan_ind_count);
-	}
-
 
 }
 
 static
 void hostif_stop_confirm(struct ks_wlan_private *priv)
 {
-	unsigned int tmp=0;
-	unsigned int old_status=priv->connect_status;
-	struct net_device *netdev=priv->net_dev;
+	unsigned int tmp = 0;
+	unsigned int old_status = priv->connect_status;
+	struct net_device *netdev = priv->net_dev;
 	union iwreq_data wrqu0;
 
-	DPRINTK(3,"\n");
-	if(priv->dev_state == DEVICE_STATE_SLEEP)
+	DPRINTK(3, "\n");
+	if (priv->dev_state == DEVICE_STATE_SLEEP)
 		priv->dev_state = DEVICE_STATE_READY;
 
 	/* disconnect indication */
-	if( (priv->connect_status & CONNECT_STATUS_MASK)== CONNECT_STATUS){
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
 		netif_carrier_off(netdev);
 		tmp = FORCE_DISCONNECT & priv->connect_status;
 		priv->connect_status = tmp | DISCONNECT_STATUS;
@@ -841,15 +908,17 @@ void hostif_stop_confirm(struct ks_wlan_private *priv)
 		wrqu0.data.length = 0;
 		wrqu0.data.flags = 0;
 		wrqu0.ap_addr.sa_family = ARPHRD_ETHER;
-		if((priv->connect_status & CONNECT_STATUS_MASK)== DISCONNECT_STATUS &&
-		   (old_status & CONNECT_STATUS_MASK)==CONNECT_STATUS ){
+		if ((priv->connect_status & CONNECT_STATUS_MASK) ==
+		    DISCONNECT_STATUS
+		    && (old_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
 			memset(wrqu0.ap_addr.sa_data, '\0', ETH_ALEN);
-			DPRINTK(3,"IWEVENT: disconnect\n");
+			DPRINTK(3, "IWEVENT: disconnect\n");
 			printk("IWEVENT: disconnect\n");
-			DPRINTK(3,"disconnect :: scan_ind_count=%d\n",priv->scan_ind_count);
+			DPRINTK(3, "disconnect :: scan_ind_count=%d\n",
+				priv->scan_ind_count);
 			wireless_send_event(netdev, SIOCGIWAP, &wrqu0, NULL);
 		}
-		priv->scan_ind_count=0;
+		priv->scan_ind_count = 0;
 	}
 
 	hostif_sme_enqueue(priv, SME_STOP_CONFIRM);
@@ -858,8 +927,8 @@ void hostif_stop_confirm(struct ks_wlan_private *priv)
 static
 void hostif_ps_adhoc_set_confirm(struct ks_wlan_private *priv)
 {
-	DPRINTK(3,"\n");
-	priv->infra_status = 0; /* infrastructure mode cancel */
+	DPRINTK(3, "\n");
+	priv->infra_status = 0;	/* infrastructure mode cancel */
 	hostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);
 
 }
@@ -868,18 +937,18 @@ static
 void hostif_infrastructure_set_confirm(struct ks_wlan_private *priv)
 {
 	uint16_t result_code;
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 	result_code = get_WORD(priv);
-	DPRINTK(3,"result code = %d\n",result_code);
-	priv->infra_status = 1; /* infrastructure mode set */
+	DPRINTK(3, "result code = %d\n", result_code);
+	priv->infra_status = 1;	/* infrastructure mode set */
 	hostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);
 }
 
 static
 void hostif_adhoc_set_confirm(struct ks_wlan_private *priv)
 {
-	DPRINTK(3,"\n");
-	priv->infra_status = 1; /* infrastructure mode set */
+	DPRINTK(3, "\n");
+	priv->infra_status = 1;	/* infrastructure mode set */
 	hostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);
 }
 
@@ -897,33 +966,33 @@ void hostif_associate_indication(struct ks_wlan_private *priv)
 	static const char associnfo_leader0[] = "ASSOCINFO(ReqIEs=";
 	static const char associnfo_leader1[] = " RespIEs=";
 
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 	assoc_req = (struct association_request_t *)(priv->rxp);
-	assoc_resp = (struct association_response_t *)(assoc_req+1);
-	pb = (unsigned char *)(assoc_resp+1);
+	assoc_resp = (struct association_response_t *)(assoc_req + 1);
+	pb = (unsigned char *)(assoc_resp + 1);
 
 	memset(&wrqu, 0, sizeof(wrqu));
-	memcpy(pbuf,associnfo_leader0,sizeof(associnfo_leader0)-1);
-	wrqu.data.length += sizeof(associnfo_leader0)-1;
-	pbuf += sizeof(associnfo_leader0)-1;
+	memcpy(pbuf, associnfo_leader0, sizeof(associnfo_leader0) - 1);
+	wrqu.data.length += sizeof(associnfo_leader0) - 1;
+	pbuf += sizeof(associnfo_leader0) - 1;
 
 	for (i = 0; i < assoc_req->reqIEs_size; i++)
-		pbuf += sprintf(pbuf, "%02x", *(pb+i));
-	wrqu.data.length += (assoc_req->reqIEs_size)*2;
+		pbuf += sprintf(pbuf, "%02x", *(pb + i));
+	wrqu.data.length += (assoc_req->reqIEs_size) * 2;
 
-	memcpy(pbuf,associnfo_leader1,sizeof(associnfo_leader1)-1);
-	wrqu.data.length += sizeof(associnfo_leader1)-1;
-	pbuf += sizeof(associnfo_leader1)-1;
+	memcpy(pbuf, associnfo_leader1, sizeof(associnfo_leader1) - 1);
+	wrqu.data.length += sizeof(associnfo_leader1) - 1;
+	pbuf += sizeof(associnfo_leader1) - 1;
 
 	pb += assoc_req->reqIEs_size;
 	for (i = 0; i < assoc_resp->respIEs_size; i++)
-		pbuf += sprintf(pbuf, "%02x", *(pb+i));
-	wrqu.data.length += (assoc_resp->respIEs_size)*2;
+		pbuf += sprintf(pbuf, "%02x", *(pb + i));
+	wrqu.data.length += (assoc_resp->respIEs_size) * 2;
 
 	pbuf += sprintf(pbuf, ")");
 	wrqu.data.length += 1;
 
-	DPRINTK(3,"IWEVENT:ASSOCINFO\n");
+	DPRINTK(3, "IWEVENT:ASSOCINFO\n");
 	wireless_send_event(priv->net_dev, IWEVCUSTOM, &wrqu, buf);
 }
 
@@ -934,28 +1003,29 @@ void hostif_bss_scan_confirm(struct ks_wlan_private *priv)
 	struct net_device *dev = priv->net_dev;
 	union iwreq_data wrqu;
 	result_code = get_DWORD(priv);
-	DPRINTK(2,"result=%d :: scan_ind_count=%d\n", result_code, priv->scan_ind_count);
+	DPRINTK(2, "result=%d :: scan_ind_count=%d\n", result_code,
+		priv->scan_ind_count);
 
 	priv->sme_i.sme_flag &= ~SME_AP_SCAN;
 	hostif_sme_enqueue(priv, SME_BSS_SCAN_CONFIRM);
 
 	wrqu.data.length = 0;
 	wrqu.data.flags = 0;
-	DPRINTK(3,"IWEVENT: SCAN CONFIRM\n");
+	DPRINTK(3, "IWEVENT: SCAN CONFIRM\n");
 	wireless_send_event(dev, SIOCGIWSCAN, &wrqu, NULL);
-	priv->scan_ind_count=0;
+	priv->scan_ind_count = 0;
 }
 
 static
 void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 {
 	struct iw_statistics *wstats = &priv->wstats;
-	unsigned char rssi,signal,noise;
+	unsigned char rssi, signal, noise;
 	unsigned char LinkSpeed;
 	unsigned int TransmittedFrameCount, ReceivedFragmentCount;
 	unsigned int FailedCount, FCSErrorCount;
 
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 	rssi = get_BYTE(priv);
 	signal = get_BYTE(priv);
 	noise = get_BYTE(priv);
@@ -969,14 +1039,12 @@ void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 	priv->current_rate = (LinkSpeed & RATE_MASK);
 	wstats->qual.qual = signal;
 	wstats->qual.level = 256 - rssi;
-	wstats->qual.noise = 0; /* invalid noise value */
+	wstats->qual.noise = 0;	/* invalid noise value */
 	wstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
 
-	DPRINTK(3,"\n    rssi=%u\n    signal=%u\n    LinkSpeed=%ux500Kbps\n \
+	DPRINTK(3, "\n    rssi=%u\n    signal=%u\n    LinkSpeed=%ux500Kbps\n \
    TransmittedFrameCount=%u\n    ReceivedFragmentCount=%u\n    FailedCount=%u\n \
-   FCSErrorCount=%u\n",
-		rssi,signal,LinkSpeed,TransmittedFrameCount,
-		ReceivedFragmentCount,FailedCount,FCSErrorCount);
+   FCSErrorCount=%u\n", rssi, signal, LinkSpeed, TransmittedFrameCount, ReceivedFragmentCount, FailedCount, FCSErrorCount);
 
 	/* wake_up_interruptible_all(&priv->confirm_wait); */
 	complete(&priv->confirm_wait);
@@ -985,18 +1053,17 @@ void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 static
 void hostif_mic_failure_confirm(struct ks_wlan_private *priv)
 {
-	DPRINTK(3,"mic_failure=%u\n",priv->wpa.mic_failure.failure);
+	DPRINTK(3, "mic_failure=%u\n", priv->wpa.mic_failure.failure);
 	hostif_sme_enqueue(priv, SME_MIC_FAILURE_CONFIRM);
 }
 
-
 static
 void hostif_event_check(struct ks_wlan_private *priv)
 {
 	unsigned short event;
 
 	DPRINTK(4, "\n");
-	event = get_WORD(priv); /* get event */
+	event = get_WORD(priv);	/* get event */
 	switch (event) {
 	case HIF_DATA_IND:
 		hostif_data_indication(priv);
@@ -1060,56 +1127,59 @@ void hostif_event_check(struct ks_wlan_private *priv)
 
 	/* add event to hostt buffer */
 	priv->hostt.buff[priv->hostt.qtail] = event;
-        priv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;
+	priv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;
 }
 
 #define CHECK_ALINE(size) (size%4 ? (size+(4-(size%4))):size)
 
 int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 {
-	unsigned int		packet_len=0;
+	unsigned int packet_len = 0;
 
-	unsigned char		*buffer=NULL;
-	unsigned int		length=0;
+	unsigned char *buffer = NULL;
+	unsigned int length = 0;
 	struct hostif_data_request_t *pp;
-	unsigned char		*p;
-	int	        result=0;
+	unsigned char *p;
+	int result = 0;
 	unsigned short eth_proto;
 	struct ether_hdr *eth_hdr;
 	struct michel_mic_t michel_mic;
-	unsigned short keyinfo=0;
+	unsigned short keyinfo = 0;
 	struct ieee802_1x_hdr *aa1x_hdr;
 	struct wpa_eapol_key *eap_key;
 	struct ethhdr *eth;
 
 	packet_len = packet->len;
 	if (packet_len > ETH_FRAME_LEN) {
-		DPRINTK(1,"bad length packet_len=%d \n", packet_len);
+		DPRINTK(1, "bad length packet_len=%d \n", packet_len);
 		dev_kfree_skb(packet);
 		return -1;
 	}
 
-	if(((priv->connect_status & CONNECT_STATUS_MASK)== DISCONNECT_STATUS) ||
-	   (priv->connect_status & FORCE_DISCONNECT) || priv->wpa.mic_failure.stop){
-		DPRINTK(3," DISCONNECT\n");
-		if(netif_queue_stopped(priv->net_dev))
+	if (((priv->connect_status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS)
+	    || (priv->connect_status & FORCE_DISCONNECT)
+	    || priv->wpa.mic_failure.stop) {
+		DPRINTK(3, " DISCONNECT\n");
+		if (netif_queue_stopped(priv->net_dev))
 			netif_wake_queue(priv->net_dev);
-		if(packet)
+		if (packet)
 			dev_kfree_skb(packet);
 
 		return 0;
 	}
 
 	/* for PowerSave */
-	if(atomic_read(&priv->psstatus.status)==PS_SNOOZE){ /* power save wakeup */
-		if(!netif_queue_stopped(priv->net_dev))
+	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {	/* power save wakeup */
+		if (!netif_queue_stopped(priv->net_dev))
 			netif_stop_queue(priv->net_dev);
 	}
 
 	DPRINTK(4, "skb_buff length=%d\n", packet_len);
-	pp = (struct hostif_data_request_t *)kmalloc(hif_align_size(sizeof(*pp)+6+packet_len+8),KS_WLAN_MEM_FLAG );
+	pp = (struct hostif_data_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp) + 6 + packet_len + 8),
+		    KS_WLAN_MEM_FLAG);
 
-	if (pp==NULL) {
+	if (pp == NULL) {
 		DPRINTK(3, "allocate memory failed..\n");
 		dev_kfree_skb(packet);
 		return -2;
@@ -1122,34 +1192,34 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 
 	/* packet check */
 	eth = (struct ethhdr *)packet->data;
-	if (memcmp(&priv->eth_addr[0],eth->h_source, ETH_ALEN)){
+	if (memcmp(&priv->eth_addr[0], eth->h_source, ETH_ALEN)) {
 		DPRINTK(1, "invalid mac address !!\n");
 		DPRINTK(1, "ethernet->h_source=%02X:%02X:%02X:%02X:%02X:%02X\n",
-			eth->h_source[0],eth->h_source[1],eth->h_source[2],
-			eth->h_source[3],eth->h_source[4],eth->h_source[5]);
+			eth->h_source[0], eth->h_source[1], eth->h_source[2],
+			eth->h_source[3], eth->h_source[4], eth->h_source[5]);
 		return -3;
 	}
 
 	/* MAC address copy */
-        memcpy(p, buffer, 12);	/* DST/SRC MAC address */
+	memcpy(p, buffer, 12);	/* DST/SRC MAC address */
 	p += 12;
 	buffer += 12;
 	length -= 12;
 	/* EtherType/Length check */
-	if (*(buffer+1) + (*buffer << 8) > 1500) {
+	if (*(buffer + 1) + (*buffer << 8) > 1500) {
 		/* ProtocolEAP = *(buffer+1) + (*buffer << 8); */
-	        /* DPRINTK(2, "Send [SNAP]Type %x\n",ProtocolEAP); */
+		/* DPRINTK(2, "Send [SNAP]Type %x\n",ProtocolEAP); */
 		/* SAP/CTL/OUI(6 byte) add */
-	        *p++ = 0xAA;		/* DSAP */
-		*p++ = 0xAA;		/* SSAP */
-		*p++ = 0x03;		/* CTL */
-		*p++ = 0x00;		/* OUI ("000000") */
-		*p++ = 0x00;		/* OUI ("000000") */
-		*p++ = 0x00;		/* OUI ("000000") */
+		*p++ = 0xAA;	/* DSAP */
+		*p++ = 0xAA;	/* SSAP */
+		*p++ = 0x03;	/* CTL */
+		*p++ = 0x00;	/* OUI ("000000") */
+		*p++ = 0x00;	/* OUI ("000000") */
+		*p++ = 0x00;	/* OUI ("000000") */
 		packet_len += 6;
 	} else {
-		DPRINTK(4,"DIX\n");
-	        /* Length(2 byte) delete */
+		DPRINTK(4, "DIX\n");
+		/* Length(2 byte) delete */
 		buffer += 2;
 		length -= 2;
 		packet_len -= 2;
@@ -1165,61 +1235,68 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 	eth_proto = ntohs(eth_hdr->h_proto);
 
 	/* for MIC FAILUER REPORT check */
-	if(eth_proto == ETHER_PROTOCOL_TYPE_EAP && priv->wpa.mic_failure.failure>0){
-		aa1x_hdr=(struct ieee802_1x_hdr *)(eth_hdr+1);
-		if(aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY){
-			eap_key = (struct wpa_eapol_key *)(aa1x_hdr+1);
-			keyinfo=ntohs(eap_key->key_info);
+	if (eth_proto == ETHER_PROTOCOL_TYPE_EAP
+	    && priv->wpa.mic_failure.failure > 0) {
+		aa1x_hdr = (struct ieee802_1x_hdr *)(eth_hdr + 1);
+		if (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY) {
+			eap_key = (struct wpa_eapol_key *)(aa1x_hdr + 1);
+			keyinfo = ntohs(eap_key->key_info);
 		}
 	}
 
-	if (priv->wpa.rsn_enabled && priv->wpa.key[0].key_len){
-		if(eth_proto == ETHER_PROTOCOL_TYPE_EAP && !(priv->wpa.key[1].key_len) &&
-		   !(priv->wpa.key[2].key_len) && !(priv->wpa.key[3].key_len)){
-			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH); /* no encryption */
-		}
-		else{
-			if(priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP){
-				MichaelMICFunction( &michel_mic,
-						   (uint8_t*)priv->wpa.key[0].tx_mic_key,
-						   (uint8_t*)&pp->data[0],
-						   (int)packet_len,
-						   (uint8_t)0, /* priority */
-						   (uint8_t*)michel_mic.Result );
+	if (priv->wpa.rsn_enabled && priv->wpa.key[0].key_len) {
+		if (eth_proto == ETHER_PROTOCOL_TYPE_EAP
+		    && !(priv->wpa.key[1].key_len)
+		    && !(priv->wpa.key[2].key_len)
+		    && !(priv->wpa.key[3].key_len)) {
+			pp->auth_type = cpu_to_le16((uint16_t) TYPE_AUTH);	/* no encryption */
+		} else {
+			if (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
+				MichaelMICFunction(&michel_mic, (uint8_t *) priv->wpa.key[0].tx_mic_key, (uint8_t *) & pp->data[0], (int)packet_len, (uint8_t) 0,	/* priority */
+						   (uint8_t *) michel_mic.
+						   Result);
 				memcpy(p, michel_mic.Result, 8);
 				length += 8;
 				packet_len += 8;
 				p += 8;
-				pp->auth_type = cpu_to_le16((uint16_t)TYPE_DATA);
+				pp->auth_type =
+				    cpu_to_le16((uint16_t) TYPE_DATA);
 
-			}else if(priv->wpa.pairwise_suite == IW_AUTH_CIPHER_CCMP){
-				pp->auth_type = cpu_to_le16((uint16_t)TYPE_DATA);
+			} else if (priv->wpa.pairwise_suite ==
+				   IW_AUTH_CIPHER_CCMP) {
+				pp->auth_type =
+				    cpu_to_le16((uint16_t) TYPE_DATA);
 			}
 		}
-	}
-	else{
-		if(eth_proto == ETHER_PROTOCOL_TYPE_EAP)
-			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);
+	} else {
+		if (eth_proto == ETHER_PROTOCOL_TYPE_EAP)
+			pp->auth_type = cpu_to_le16((uint16_t) TYPE_AUTH);
 		else
-			pp->auth_type = cpu_to_le16((uint16_t)TYPE_DATA);
+			pp->auth_type = cpu_to_le16((uint16_t) TYPE_DATA);
 	}
 
 	/* header value set */
-	pp->header.size  = cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)+packet_len));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_DATA_REQ);
+	pp->header.size =
+	    cpu_to_le16((uint16_t)
+			(sizeof(*pp) - sizeof(pp->header.size) + packet_len));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_DATA_REQ);
 
 	/* tx request */
-	result = ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + packet_len),
-			      (void *)send_packet_complete, (void *)priv, (void *)packet);
+	result =
+	    ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + packet_len),
+			  (void *)send_packet_complete, (void *)priv,
+			  (void *)packet);
 
 	/* MIC FAILUER REPORT check */
-	if(eth_proto == ETHER_PROTOCOL_TYPE_EAP && priv->wpa.mic_failure.failure>0){
-		if(keyinfo & WPA_KEY_INFO_ERROR && keyinfo & WPA_KEY_INFO_REQUEST){
-			DPRINTK(3," MIC ERROR Report SET : %04X\n", keyinfo);
+	if (eth_proto == ETHER_PROTOCOL_TYPE_EAP
+	    && priv->wpa.mic_failure.failure > 0) {
+		if (keyinfo & WPA_KEY_INFO_ERROR
+		    && keyinfo & WPA_KEY_INFO_REQUEST) {
+			DPRINTK(3, " MIC ERROR Report SET : %04X\n", keyinfo);
 			hostif_sme_enqueue(priv, SME_MIC_FAILURE_REQUEST);
 		}
-		if(priv->wpa.mic_failure.failure==2)
-			priv->wpa.mic_failure.stop=1;
+		if (priv->wpa.mic_failure.failure == 2)
+			priv->wpa.mic_failure.stop = 1;
 	}
 
 	return result;
@@ -1231,83 +1308,92 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
                                       } }while(0)
 
 static
-void hostif_mib_get_request( struct ks_wlan_private *priv, unsigned long mib_attribute)
+void hostif_mib_get_request(struct ks_wlan_private *priv,
+			    unsigned long mib_attribute)
 {
 	struct hostif_mib_get_request_t *pp;
 
 	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_mib_get_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
-		DPRINTK(3,"allocate memory failed..\n");
+	pp = (struct hostif_mib_get_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_MIB_GET_REQ);
-	pp->mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
+	pp->header.size =
+	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_MIB_GET_REQ);
+	pp->mib_attribute = cpu_to_le32((uint32_t) mib_attribute);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 }
 
 static
-void hostif_mib_set_request( struct ks_wlan_private *priv, unsigned long mib_attribute,
-			     unsigned short size, unsigned short type,
-			     void *vp )
+void hostif_mib_set_request(struct ks_wlan_private *priv,
+			    unsigned long mib_attribute, unsigned short size,
+			    unsigned short type, void *vp)
 {
 	struct hostif_mib_set_request_t *pp;
 
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
 	if (priv->dev_state < DEVICE_STATE_BOOT) {
-		DPRINTK(3,"DeviceRemove\n");
+		DPRINTK(3, "DeviceRemove\n");
 		return;
 	}
 
 	/* make primitive */
-	pp = (struct hostif_mib_set_request_t *)kmalloc(hif_align_size(sizeof(*pp)+size), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
+	pp = (struct hostif_mib_set_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp) + size), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
 
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)+size));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_MIB_SET_REQ);
-	pp->mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
-	pp->mib_value.size = cpu_to_le16((uint16_t)size);
-	pp->mib_value.type = cpu_to_le16((uint16_t)type);
+	pp->header.size =
+	    cpu_to_le16((uint16_t)
+			(sizeof(*pp) - sizeof(pp->header.size) + size));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_MIB_SET_REQ);
+	pp->mib_attribute = cpu_to_le32((uint32_t) mib_attribute);
+	pp->mib_value.size = cpu_to_le16((uint16_t) size);
+	pp->mib_value.type = cpu_to_le16((uint16_t) type);
 	memcpy(&pp->mib_value.body, vp, size);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + size), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + size), NULL, NULL,
+		      NULL);
 }
 
 static
-void hostif_start_request( struct ks_wlan_private *priv, unsigned char mode )
+void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 {
 	struct hostif_start_request_t *pp;
 
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_start_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
+	pp = (struct hostif_start_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_START_REQ);
-	pp->mode = cpu_to_le16((uint16_t)mode);
+	pp->header.size =
+	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_START_REQ);
+	pp->mode = cpu_to_le16((uint16_t) mode);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
 	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 
 	priv->aplist.size = 0;
-	priv->scan_ind_count=0;
+	priv->scan_ind_count = 0;
 }
 
 static
@@ -1316,35 +1402,38 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 	struct hostif_ps_adhoc_set_request_t *pp;
 	uint16_t capability;
 
-        DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_ps_adhoc_set_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
+	pp = (struct hostif_ps_adhoc_set_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
 	memset(pp, 0, sizeof(*pp));
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_PS_ADH_SET_REQ);
-	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
-	pp->channel = cpu_to_le16((uint16_t)(priv->reg.channel));
+	pp->header.size =
+	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_PS_ADH_SET_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t) (priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t) (priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t) (priv->reg.scan_type));
+	pp->channel = cpu_to_le16((uint16_t) (priv->reg.channel));
 	pp->rate_set.size = priv->reg.rate_set.size;
-	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0], priv->reg.rate_set.size);
+	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
+	       priv->reg.rate_set.size);
 
 	capability = 0x0000;
-	if (priv->reg.preamble==SHORT_PREAMBLE) {
+	if (priv->reg.preamble == SHORT_PREAMBLE) {
 		/* short preamble */
 		capability |= BSS_CAP_SHORT_PREAMBLE;
 	}
-	capability &= ~(BSS_CAP_PBCC);  /* pbcc not support */
-	if(priv->reg.phy_type != D_11B_ONLY_MODE){
-		capability |= BSS_CAP_SHORT_SLOT_TIME;      /* ShortSlotTime support */
-		capability &= ~(BSS_CAP_DSSS_OFDM);         /* DSSS OFDM */
+	capability &= ~(BSS_CAP_PBCC);	/* pbcc not support */
+	if (priv->reg.phy_type != D_11B_ONLY_MODE) {
+		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
+		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM */
 	}
-	pp->capability = cpu_to_le16((uint16_t)capability);
+	pp->capability = cpu_to_le16((uint16_t) capability);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1357,38 +1446,42 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 	struct hostif_infrastructure_set_request_t *pp;
 	uint16_t capability;
 
-	DPRINTK(3, "ssid.size=%d \n",priv->reg.ssid.size);
+	DPRINTK(3, "ssid.size=%d \n", priv->reg.ssid.size);
 
 	/* make primitive */
-	pp = (struct hostif_infrastructure_set_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
+	pp = (struct hostif_infrastructure_set_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_INFRA_SET_REQ);
-	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+	pp->header.size =
+	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_INFRA_SET_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t) (priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t) (priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t) (priv->reg.scan_type));
 
 	pp->rate_set.size = priv->reg.rate_set.size;
-	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0], priv->reg.rate_set.size);
+	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
+	       priv->reg.rate_set.size);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
 
 	capability = 0x0000;
-	if (priv->reg.preamble==SHORT_PREAMBLE) {
+	if (priv->reg.preamble == SHORT_PREAMBLE) {
 		/* short preamble */
 		capability |= BSS_CAP_SHORT_PREAMBLE;
 	}
-	capability &= ~(BSS_CAP_PBCC); /* pbcc not support */
-	if(priv->reg.phy_type != D_11B_ONLY_MODE){
-		capability |= BSS_CAP_SHORT_SLOT_TIME;      /* ShortSlotTime support */
-		capability &= ~(BSS_CAP_DSSS_OFDM);         /* DSSS OFDM not support */
+	capability &= ~(BSS_CAP_PBCC);	/* pbcc not support */
+	if (priv->reg.phy_type != D_11B_ONLY_MODE) {
+		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
+		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
 	}
-	pp->capability = cpu_to_le16((uint16_t)capability);
-	pp->beacon_lost_count = cpu_to_le16((uint16_t)(priv->reg.beacon_lost_count));
-	pp->auth_type = cpu_to_le16((uint16_t)(priv->reg.authenticate_type));
+	pp->capability = cpu_to_le16((uint16_t) capability);
+	pp->beacon_lost_count =
+	    cpu_to_le16((uint16_t) (priv->reg.beacon_lost_count));
+	pp->auth_type = cpu_to_le16((uint16_t) (priv->reg.authenticate_type));
 
 	pp->channel_list.body[0] = 1;
 	pp->channel_list.body[1] = 8;
@@ -1403,16 +1496,16 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 	pp->channel_list.body[10] = 6;
 	pp->channel_list.body[11] = 13;
 	pp->channel_list.body[12] = 7;
-	if(priv->reg.phy_type == D_11G_ONLY_MODE){
+	if (priv->reg.phy_type == D_11G_ONLY_MODE) {
 		pp->channel_list.size = 13;
-	}else{
+	} else {
 		pp->channel_list.body[13] = 14;
 		pp->channel_list.size = 14;
 	}
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)),NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 }
 
 void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
@@ -1420,38 +1513,42 @@ void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 	struct hostif_infrastructure_set2_request_t *pp;
 	uint16_t capability;
 
-	DPRINTK(2, "ssid.size=%d \n",priv->reg.ssid.size);
+	DPRINTK(2, "ssid.size=%d \n", priv->reg.ssid.size);
 
 	/* make primitive */
-	pp = (struct hostif_infrastructure_set2_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
+	pp = (struct hostif_infrastructure_set2_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_INFRA_SET2_REQ);
-	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+	pp->header.size =
+	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_INFRA_SET2_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t) (priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t) (priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t) (priv->reg.scan_type));
 
 	pp->rate_set.size = priv->reg.rate_set.size;
-	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0], priv->reg.rate_set.size);
+	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
+	       priv->reg.rate_set.size);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
 
 	capability = 0x0000;
-	if (priv->reg.preamble==SHORT_PREAMBLE) {
+	if (priv->reg.preamble == SHORT_PREAMBLE) {
 		/* short preamble */
 		capability |= BSS_CAP_SHORT_PREAMBLE;
 	}
-	capability &= ~(BSS_CAP_PBCC); /* pbcc not support */
-	if(priv->reg.phy_type != D_11B_ONLY_MODE){
-		capability |= BSS_CAP_SHORT_SLOT_TIME;      /* ShortSlotTime support */
-		capability &= ~(BSS_CAP_DSSS_OFDM);         /* DSSS OFDM not support */
+	capability &= ~(BSS_CAP_PBCC);	/* pbcc not support */
+	if (priv->reg.phy_type != D_11B_ONLY_MODE) {
+		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
+		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
 	}
-	pp->capability = cpu_to_le16((uint16_t)capability);
-	pp->beacon_lost_count = cpu_to_le16((uint16_t)(priv->reg.beacon_lost_count));
-	pp->auth_type = cpu_to_le16((uint16_t)(priv->reg.authenticate_type));
+	pp->capability = cpu_to_le16((uint16_t) capability);
+	pp->beacon_lost_count =
+	    cpu_to_le16((uint16_t) (priv->reg.beacon_lost_count));
+	pp->auth_type = cpu_to_le16((uint16_t) (priv->reg.authenticate_type));
 
 	pp->channel_list.body[0] = 1;
 	pp->channel_list.body[1] = 8;
@@ -1466,9 +1563,9 @@ void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 	pp->channel_list.body[10] = 6;
 	pp->channel_list.body[11] = 13;
 	pp->channel_list.body[12] = 7;
-	if(priv->reg.phy_type == D_11G_ONLY_MODE){
+	if (priv->reg.phy_type == D_11G_ONLY_MODE) {
 		pp->channel_list.size = 13;
-	}else{
+	} else {
 		pp->channel_list.body[13] = 14;
 		pp->channel_list.size = 14;
 	}
@@ -1477,7 +1574,7 @@ void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)),NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 }
 
 static
@@ -1489,38 +1586,41 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_adhoc_set_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
+	pp = (struct hostif_adhoc_set_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
 	memset(pp, 0, sizeof(*pp));
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_ADH_SET_REQ);
-	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
-	pp->channel = cpu_to_le16((uint16_t)(priv->reg.channel));
+	pp->header.size =
+	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_ADH_SET_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t) (priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t) (priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t) (priv->reg.scan_type));
+	pp->channel = cpu_to_le16((uint16_t) (priv->reg.channel));
 	pp->rate_set.size = priv->reg.rate_set.size;
-	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0], priv->reg.rate_set.size);
+	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
+	       priv->reg.rate_set.size);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
 
 	capability = 0x0000;
-	if (priv->reg.preamble==SHORT_PREAMBLE) {
+	if (priv->reg.preamble == SHORT_PREAMBLE) {
 		/* short preamble */
 		capability |= BSS_CAP_SHORT_PREAMBLE;
 	}
-	capability &= ~(BSS_CAP_PBCC); /* pbcc not support */
-	if(priv->reg.phy_type != D_11B_ONLY_MODE){
-		capability |= BSS_CAP_SHORT_SLOT_TIME;      /* ShortSlotTime support */
-		capability &= ~(BSS_CAP_DSSS_OFDM);         /* DSSS OFDM not support */
+	capability &= ~(BSS_CAP_PBCC);	/* pbcc not support */
+	if (priv->reg.phy_type != D_11B_ONLY_MODE) {
+		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
+		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
 	}
-	pp->capability = cpu_to_le16((uint16_t)capability);
+	pp->capability = cpu_to_le16((uint16_t) capability);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 }
 
 static
@@ -1532,33 +1632,36 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_adhoc_set2_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
+	pp = (struct hostif_adhoc_set2_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
 	memset(pp, 0, sizeof(*pp));
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_ADH_SET_REQ);
-	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
-	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
-	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+	pp->header.size =
+	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_ADH_SET_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t) (priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t) (priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t) (priv->reg.scan_type));
 	pp->rate_set.size = priv->reg.rate_set.size;
-	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0], priv->reg.rate_set.size);
+	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0],
+	       priv->reg.rate_set.size);
 	pp->ssid.size = priv->reg.ssid.size;
 	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
 
 	capability = 0x0000;
-	if (priv->reg.preamble==SHORT_PREAMBLE) {
+	if (priv->reg.preamble == SHORT_PREAMBLE) {
 		/* short preamble */
 		capability |= BSS_CAP_SHORT_PREAMBLE;
 	}
-	capability &= ~(BSS_CAP_PBCC); /* pbcc not support */
-	if(priv->reg.phy_type != D_11B_ONLY_MODE){
-		capability |= BSS_CAP_SHORT_SLOT_TIME;      /* ShortSlotTime support */
-		capability &= ~(BSS_CAP_DSSS_OFDM);         /* DSSS OFDM not support */
+	capability &= ~(BSS_CAP_PBCC);	/* pbcc not support */
+	if (priv->reg.phy_type != D_11B_ONLY_MODE) {
+		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
+		capability &= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
 	}
-	pp->capability = cpu_to_le16((uint16_t)capability);
+	pp->capability = cpu_to_le16((uint16_t) capability);
 
 	pp->channel_list.body[0] = priv->reg.channel;
 	pp->channel_list.size = 1;
@@ -1566,130 +1669,146 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 }
 
 static
-void hostif_stop_request( struct ks_wlan_private *priv )
+void hostif_stop_request(struct ks_wlan_private *priv)
 {
 	struct hostif_stop_request_t *pp;
 
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_stop_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
-		DPRINTK(3,"allocate memory failed..\n");
+	pp = (struct hostif_stop_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_STOP_REQ);
+	pp->header.size =
+	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_STOP_REQ);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 }
 
 static
-void hostif_phy_information_request( struct ks_wlan_private *priv )
+void hostif_phy_information_request(struct ks_wlan_private *priv)
 {
 	struct hostif_phy_information_request_t *pp;
 
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
 	/* make primitive */
-	pp = (struct hostif_phy_information_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
+	pp = (struct hostif_phy_information_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
 		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_PHY_INFO_REQ);
-	if(priv->reg.phy_info_timer){
-		pp->type = cpu_to_le16((uint16_t)TIME_TYPE);
-		pp->time = cpu_to_le16((uint16_t)(priv->reg.phy_info_timer));
-	}else{
-		pp->type = cpu_to_le16((uint16_t)NORMAL_TYPE);
-		pp->time = cpu_to_le16((uint16_t)0);
+	pp->header.size =
+	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_PHY_INFO_REQ);
+	if (priv->reg.phy_info_timer) {
+		pp->type = cpu_to_le16((uint16_t) TIME_TYPE);
+		pp->time = cpu_to_le16((uint16_t) (priv->reg.phy_info_timer));
+	} else {
+		pp->type = cpu_to_le16((uint16_t) NORMAL_TYPE);
+		pp->time = cpu_to_le16((uint16_t) 0);
 	}
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 }
 
 static
-void hostif_power_mngmt_request( struct ks_wlan_private *priv, unsigned long mode,
-				 unsigned long wake_up, unsigned long receiveDTIMs )
+void hostif_power_mngmt_request(struct ks_wlan_private *priv,
+				unsigned long mode, unsigned long wake_up,
+				unsigned long receiveDTIMs)
 {
 	struct hostif_power_mngmt_request_t *pp;
 
-	DPRINTK(3,"mode=%lu wake_up=%lu receiveDTIMs=%lu\n",mode,wake_up,receiveDTIMs);
+	DPRINTK(3, "mode=%lu wake_up=%lu receiveDTIMs=%lu\n", mode, wake_up,
+		receiveDTIMs);
 	/* make primitive */
-	pp = (struct hostif_power_mngmt_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
-		DPRINTK(3,"allocate memory failed..\n");
+	pp = (struct hostif_power_mngmt_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_POWERMGT_REQ);
-	pp->mode = cpu_to_le32((uint32_t)mode);
-	pp->wake_up = cpu_to_le32((uint32_t)wake_up);
-	pp->receiveDTIMs = cpu_to_le32((uint32_t)receiveDTIMs);
+	pp->header.size =
+	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_POWERMGT_REQ);
+	pp->mode = cpu_to_le32((uint32_t) mode);
+	pp->wake_up = cpu_to_le32((uint32_t) wake_up);
+	pp->receiveDTIMs = cpu_to_le32((uint32_t) receiveDTIMs);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 }
 
 static
-void hostif_sleep_request( struct ks_wlan_private *priv, unsigned long mode)
+void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
 {
 	struct hostif_sleep_request_t *pp;
 
-	DPRINTK(3,"mode=%lu \n",mode);
+	DPRINTK(3, "mode=%lu \n", mode);
 
-	if(mode == SLP_SLEEP){
+	if (mode == SLP_SLEEP) {
 		/* make primitive */
-		pp = (struct hostif_sleep_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-		if (pp==NULL) {
-			DPRINTK(3,"allocate memory failed..\n");
+		pp = (struct hostif_sleep_request_t *)
+		    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+		if (pp == NULL) {
+			DPRINTK(3, "allocate memory failed..\n");
 			return;
 		}
-		pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-		pp->header.event = cpu_to_le16((uint16_t)HIF_SLEEP_REQ);
+		pp->header.size =
+		    cpu_to_le16((uint16_t)
+				(sizeof(*pp) - sizeof(pp->header.size)));
+		pp->header.event = cpu_to_le16((uint16_t) HIF_SLEEP_REQ);
 
 		/* send to device request */
 		ps_confirm_wait_inc(priv);
-		ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
-	}else if(mode == SLP_ACTIVE){
-		atomic_set(&priv->sleepstatus.wakeup_request,1);
-		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
-	}else{
-		DPRINTK(3,"invalid mode %ld \n", mode);
+		ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL,
+			      NULL);
+	} else if (mode == SLP_ACTIVE) {
+		atomic_set(&priv->sleepstatus.wakeup_request, 1);
+		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+				   &priv->ks_wlan_hw.rw_wq, 1);
+	} else {
+		DPRINTK(3, "invalid mode %ld \n", mode);
 		return;
 	}
 }
 
-
 static
-void hostif_bss_scan_request( struct ks_wlan_private *priv, unsigned long scan_type , uint8_t *scan_ssid, uint8_t scan_ssid_len)
+void hostif_bss_scan_request(struct ks_wlan_private *priv,
+			     unsigned long scan_type, uint8_t * scan_ssid,
+			     uint8_t scan_ssid_len)
 {
 	struct hostif_bss_scan_request_t *pp;
 
-	DPRINTK(2,"\n");
+	DPRINTK(2, "\n");
 	/* make primitive */
-	pp = (struct hostif_bss_scan_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
-		DPRINTK(3,"allocate memory failed..\n");
+	pp = (struct hostif_bss_scan_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-	pp->header.event = cpu_to_le16((uint16_t)HIF_SCAN_REQ);
+	pp->header.size =
+	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_SCAN_REQ);
 	pp->scan_type = scan_type;
 
-	pp->ch_time_min = cpu_to_le32((uint32_t)110); /* default value */
-	pp->ch_time_max = cpu_to_le32((uint32_t)130); /* default value */
+	pp->ch_time_min = cpu_to_le32((uint32_t) 110);	/* default value */
+	pp->ch_time_max = cpu_to_le32((uint32_t) 130);	/* default value */
 	pp->channel_list.body[0] = 1;
 	pp->channel_list.body[1] = 8;
 	pp->channel_list.body[2] = 2;
@@ -1703,57 +1822,60 @@ void hostif_bss_scan_request( struct ks_wlan_private *priv, unsigned long scan_t
 	pp->channel_list.body[10] = 6;
 	pp->channel_list.body[11] = 13;
 	pp->channel_list.body[12] = 7;
-	if(priv->reg.phy_type == D_11G_ONLY_MODE){
+	if (priv->reg.phy_type == D_11G_ONLY_MODE) {
 		pp->channel_list.size = 13;
-	}else{
+	} else {
 		pp->channel_list.body[13] = 14;
 		pp->channel_list.size = 14;
 	}
 	pp->ssid.size = 0;
 
 	/* specified SSID SCAN */
-	if(scan_ssid_len > 0 && scan_ssid_len <= 32){
+	if (scan_ssid_len > 0 && scan_ssid_len <= 32) {
 		pp->ssid.size = scan_ssid_len;
 		memcpy(&pp->ssid.body[0], scan_ssid, scan_ssid_len);
 	}
 
-
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 
 	priv->aplist.size = 0;
-	priv->scan_ind_count=0;
+	priv->scan_ind_count = 0;
 }
 
 static
-void hostif_mic_failure_request( struct ks_wlan_private *priv, unsigned short failure_count,
-				 unsigned short timer )
+void hostif_mic_failure_request(struct ks_wlan_private *priv,
+				unsigned short failure_count,
+				unsigned short timer)
 {
 	struct hostif_mic_failure_request_t *pp;
 
-	DPRINTK(3,"count=%d :: timer=%d\n",failure_count,timer);
+	DPRINTK(3, "count=%d :: timer=%d\n", failure_count, timer);
 	/* make primitive */
-	pp = (struct hostif_mic_failure_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
-	if (pp==NULL) {
-		DPRINTK(3,"allocate memory failed..\n");
+	pp = (struct hostif_mic_failure_request_t *)
+	    kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG);
+	if (pp == NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
 		return;
 	}
-	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-	pp->header.event =  cpu_to_le16((uint16_t)HIF_MIC_FAILURE_REQ);
-	pp->failure_count = cpu_to_le16((uint16_t)failure_count);
-	pp->timer = cpu_to_le16((uint16_t)timer);
+	pp->header.size =
+	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t) HIF_MIC_FAILURE_REQ);
+	pp->failure_count = cpu_to_le16((uint16_t) failure_count);
+	pp->timer = cpu_to_le16((uint16_t) timer);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
-	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 }
 
 /* Device I/O Recieve indicate */
-static void devio_rec_ind(struct ks_wlan_private *priv, unsigned char *p, unsigned int size)
+static void devio_rec_ind(struct ks_wlan_private *priv, unsigned char *p,
+			  unsigned int size)
 {
 	if (priv->device_open_status) {
-		spin_lock(&priv->dev_read_lock); /* request spin lock */
+		spin_lock(&priv->dev_read_lock);	/* request spin lock */
 		priv->dev_data[atomic_read(&priv->rec_count)] = p;
 		priv->dev_size[atomic_read(&priv->rec_count)] = size;
 
@@ -1762,86 +1884,92 @@ static void devio_rec_ind(struct ks_wlan_private *priv, unsigned char *p, unsign
 			atomic_inc(&priv->event_count);
 		}
 		atomic_inc(&priv->rec_count);
-		if (atomic_read(&priv->rec_count)==DEVICE_STOCK_COUNT)
+		if (atomic_read(&priv->rec_count) == DEVICE_STOCK_COUNT)
 			atomic_set(&priv->rec_count, 0);
 
-	        wake_up_interruptible_all(&priv->devread_wait);
+		wake_up_interruptible_all(&priv->devread_wait);
 
 		/* release spin lock */
 		spin_unlock(&priv->dev_read_lock);
 	}
 }
 
-void hostif_receive( struct ks_wlan_private *priv, unsigned char *p, unsigned int size )
+void hostif_receive(struct ks_wlan_private *priv, unsigned char *p,
+		    unsigned int size)
 {
-	DPRINTK(4,"\n");
+	DPRINTK(4, "\n");
 
 	devio_rec_ind(priv, p, size);
 
 	priv->rxp = p;
 	priv->rx_size = size;
 
-	if (get_WORD(priv) == priv->rx_size) { /* length check !! */
-		hostif_event_check(priv); /* event check */
+	if (get_WORD(priv) == priv->rx_size) {	/* length check !! */
+		hostif_event_check(priv);	/* event check */
 	}
 }
 
-
 static
 void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 {
 	uint32_t val;
-	switch(type){
+	switch (type) {
 	case SME_WEP_INDEX_REQUEST:
-		val = cpu_to_le32((uint32_t)(priv->reg.wep_index));
+		val = cpu_to_le32((uint32_t) (priv->reg.wep_index));
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_ID,
-				       sizeof(val), MIB_VALUE_TYPE_INT,
-				       &val );
+				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
 		break;
 	case SME_WEP_KEY1_REQUEST:
-		if(!priv->wpa.wpa_enabled)
-			hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE1,
-					       priv->reg.wep_key[0].size, MIB_VALUE_TYPE_OSTRING,
-					       &priv->reg.wep_key[0].val[0] );
+		if (!priv->wpa.wpa_enabled)
+			hostif_mib_set_request(priv,
+					       DOT11_WEP_DEFAULT_KEY_VALUE1,
+					       priv->reg.wep_key[0].size,
+					       MIB_VALUE_TYPE_OSTRING,
+					       &priv->reg.wep_key[0].val[0]);
 		break;
 	case SME_WEP_KEY2_REQUEST:
-		if(!priv->wpa.wpa_enabled)
-			hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE2,
-					       priv->reg.wep_key[1].size, MIB_VALUE_TYPE_OSTRING,
+		if (!priv->wpa.wpa_enabled)
+			hostif_mib_set_request(priv,
+					       DOT11_WEP_DEFAULT_KEY_VALUE2,
+					       priv->reg.wep_key[1].size,
+					       MIB_VALUE_TYPE_OSTRING,
 					       &priv->reg.wep_key[1].val[0]);
 		break;
 	case SME_WEP_KEY3_REQUEST:
-		if(!priv->wpa.wpa_enabled)
-			hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE3,
-					       priv->reg.wep_key[2].size, MIB_VALUE_TYPE_OSTRING,
-					       &priv->reg.wep_key[2].val[0] );
+		if (!priv->wpa.wpa_enabled)
+			hostif_mib_set_request(priv,
+					       DOT11_WEP_DEFAULT_KEY_VALUE3,
+					       priv->reg.wep_key[2].size,
+					       MIB_VALUE_TYPE_OSTRING,
+					       &priv->reg.wep_key[2].val[0]);
 		break;
 	case SME_WEP_KEY4_REQUEST:
-		if(!priv->wpa.wpa_enabled)
-			hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE4,
-					       priv->reg.wep_key[3].size, MIB_VALUE_TYPE_OSTRING,
+		if (!priv->wpa.wpa_enabled)
+			hostif_mib_set_request(priv,
+					       DOT11_WEP_DEFAULT_KEY_VALUE4,
+					       priv->reg.wep_key[3].size,
+					       MIB_VALUE_TYPE_OSTRING,
 					       &priv->reg.wep_key[3].val[0]);
 		break;
 	case SME_WEP_FLAG_REQUEST:
-		val = cpu_to_le32((uint32_t)(priv->reg.privacy_invoked));
+		val = cpu_to_le32((uint32_t) (priv->reg.privacy_invoked));
 		hostif_mib_set_request(priv, DOT11_PRIVACY_INVOKED,
-				       sizeof(val), MIB_VALUE_TYPE_BOOL,
-				       &val );
+				       sizeof(val), MIB_VALUE_TYPE_BOOL, &val);
 		break;
 	}
 
-	return ;
+	return;
 }
 
 struct wpa_suite_t {
 	unsigned short size;
 	unsigned char suite[4][CIPHER_ID_LEN];
-} __attribute__((packed));
+} __attribute__ ((packed));
 
 struct rsn_mode_t {
 	uint32_t rsn_mode;
 	uint16_t rsn_capability;
-} __attribute__((packed));
+} __attribute__ ((packed));
 
 static
 void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
@@ -1850,140 +1978,172 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 	struct rsn_mode_t rsn_mode;
 	uint32_t val;
 
-	memset(&wpa_suite,0,sizeof(wpa_suite));
+	memset(&wpa_suite, 0, sizeof(wpa_suite));
 
-	switch(type){
+	switch (type) {
 	case SME_RSN_UCAST_REQUEST:
-		wpa_suite.size=cpu_to_le16((uint16_t)1);
-		switch(priv->wpa.pairwise_suite){
+		wpa_suite.size = cpu_to_le16((uint16_t) 1);
+		switch (priv->wpa.pairwise_suite) {
 		case IW_AUTH_CIPHER_NONE:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_NONE,CIPHER_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA2_NONE, CIPHER_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_NONE,CIPHER_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA_NONE, CIPHER_ID_LEN);
 			break;
 		case IW_AUTH_CIPHER_WEP40:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_WEP40,CIPHER_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA2_WEP40, CIPHER_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_WEP40,CIPHER_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA_WEP40, CIPHER_ID_LEN);
 			break;
 		case IW_AUTH_CIPHER_TKIP:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_TKIP,CIPHER_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA2_TKIP, CIPHER_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_TKIP,CIPHER_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA_TKIP, CIPHER_ID_LEN);
 			break;
 		case IW_AUTH_CIPHER_CCMP:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_CCMP,CIPHER_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA2_CCMP, CIPHER_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_CCMP,CIPHER_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA_CCMP, CIPHER_ID_LEN);
 			break;
 		case IW_AUTH_CIPHER_WEP104:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_WEP104,CIPHER_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA2_WEP104, CIPHER_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_WEP104,CIPHER_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA_WEP104, CIPHER_ID_LEN);
 			break;
 		}
 
 		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_UNICAST_CIPHER,
-				       sizeof(wpa_suite.size)+CIPHER_ID_LEN*wpa_suite.size,
+				       sizeof(wpa_suite.size) +
+				       CIPHER_ID_LEN * wpa_suite.size,
 				       MIB_VALUE_TYPE_OSTRING, &wpa_suite);
 		break;
 	case SME_RSN_MCAST_REQUEST:
-		switch(priv->wpa.group_suite){
+		switch (priv->wpa.group_suite) {
 		case IW_AUTH_CIPHER_NONE:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_NONE,CIPHER_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA2_NONE, CIPHER_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_NONE,CIPHER_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA_NONE, CIPHER_ID_LEN);
 			break;
 		case IW_AUTH_CIPHER_WEP40:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_WEP40,CIPHER_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA2_WEP40, CIPHER_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_WEP40,CIPHER_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA_WEP40, CIPHER_ID_LEN);
 			break;
 		case IW_AUTH_CIPHER_TKIP:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_TKIP,CIPHER_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA2_TKIP, CIPHER_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_TKIP,CIPHER_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA_TKIP, CIPHER_ID_LEN);
 			break;
 		case IW_AUTH_CIPHER_CCMP:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_CCMP,CIPHER_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA2_CCMP, CIPHER_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_CCMP,CIPHER_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA_CCMP, CIPHER_ID_LEN);
 			break;
 		case IW_AUTH_CIPHER_WEP104:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_WEP104,CIPHER_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA2_WEP104, CIPHER_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_WEP104,CIPHER_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       CIPHER_ID_WPA_WEP104, CIPHER_ID_LEN);
 			break;
 		}
 
 		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_MULTICAST_CIPHER,
 				       CIPHER_ID_LEN, MIB_VALUE_TYPE_OSTRING,
-				       &wpa_suite.suite[0][0] );
+				       &wpa_suite.suite[0][0]);
 		break;
 	case SME_RSN_AUTH_REQUEST:
-		wpa_suite.size=cpu_to_le16((uint16_t)1);
-		switch(priv->wpa.key_mgmt_suite){
+		wpa_suite.size = cpu_to_le16((uint16_t) 1);
+		switch (priv->wpa.key_mgmt_suite) {
 		case IW_AUTH_KEY_MGMT_802_1X:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA2_1X,KEY_MGMT_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       KEY_MGMT_ID_WPA2_1X, KEY_MGMT_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA_1X,KEY_MGMT_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       KEY_MGMT_ID_WPA_1X, KEY_MGMT_ID_LEN);
 			break;
 		case IW_AUTH_KEY_MGMT_PSK:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA2_PSK,KEY_MGMT_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       KEY_MGMT_ID_WPA2_PSK, KEY_MGMT_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA_PSK,KEY_MGMT_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       KEY_MGMT_ID_WPA_PSK, KEY_MGMT_ID_LEN);
 			break;
 		case 0:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA2_NONE,KEY_MGMT_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       KEY_MGMT_ID_WPA2_NONE, KEY_MGMT_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA_NONE,KEY_MGMT_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       KEY_MGMT_ID_WPA_NONE, KEY_MGMT_ID_LEN);
 			break;
 		case 4:
-			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
-				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA2_WPANONE,KEY_MGMT_ID_LEN);
+			if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],
+				       KEY_MGMT_ID_WPA2_WPANONE,
+				       KEY_MGMT_ID_LEN);
 			else
-				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA_WPANONE,KEY_MGMT_ID_LEN);
+				memcpy(&wpa_suite.suite[0][0],
+				       KEY_MGMT_ID_WPA_WPANONE,
+				       KEY_MGMT_ID_LEN);
 			break;
 		}
 
 		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_AUTH_SUITE,
-				       sizeof(wpa_suite.size)+KEY_MGMT_ID_LEN*wpa_suite.size,
+				       sizeof(wpa_suite.size) +
+				       KEY_MGMT_ID_LEN * wpa_suite.size,
 				       MIB_VALUE_TYPE_OSTRING, &wpa_suite);
 		break;
 	case SME_RSN_ENABLED_REQUEST:
-		val = cpu_to_le32((uint32_t)(priv->wpa.rsn_enabled));
+		val = cpu_to_le32((uint32_t) (priv->wpa.rsn_enabled));
 		hostif_mib_set_request(priv, DOT11_RSN_ENABLED,
-				       sizeof(val), MIB_VALUE_TYPE_BOOL,
-				       &val );
+				       sizeof(val), MIB_VALUE_TYPE_BOOL, &val);
 		break;
 	case SME_RSN_MODE_REQUEST:
-		if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2){
-			rsn_mode.rsn_mode = cpu_to_le32((uint32_t)RSN_MODE_WPA2);
-			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
-		}
-		else if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA){
-			rsn_mode.rsn_mode = cpu_to_le32((uint32_t)RSN_MODE_WPA);
-			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
-		}
-		else{
-			rsn_mode.rsn_mode = cpu_to_le32((uint32_t)RSN_MODE_NONE);
-			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
+		if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) {
+			rsn_mode.rsn_mode =
+			    cpu_to_le32((uint32_t) RSN_MODE_WPA2);
+			rsn_mode.rsn_capability = cpu_to_le16((uint16_t) 0);
+		} else if (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA) {
+			rsn_mode.rsn_mode =
+			    cpu_to_le32((uint32_t) RSN_MODE_WPA);
+			rsn_mode.rsn_capability = cpu_to_le16((uint16_t) 0);
+		} else {
+			rsn_mode.rsn_mode =
+			    cpu_to_le32((uint32_t) RSN_MODE_NONE);
+			rsn_mode.rsn_capability = cpu_to_le16((uint16_t) 0);
 		}
-		hostif_mib_set_request(priv, LOCAL_RSN_MODE,sizeof(rsn_mode),
-				       MIB_VALUE_TYPE_OSTRING,&rsn_mode );
+		hostif_mib_set_request(priv, LOCAL_RSN_MODE, sizeof(rsn_mode),
+				       MIB_VALUE_TYPE_OSTRING, &rsn_mode);
 		break;
 
 	}
@@ -1995,64 +2155,70 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 {
 	unsigned char rate_size;
 	unsigned char rate_octet[RATE_SET_MAX_SIZE];
-	int i=0;
+	int i = 0;
 
-	/* rate setting if rate segging is auto for changing phy_type (#94)*/
-	if(priv->reg.tx_rate == TX_RATE_FULL_AUTO){
-		if(priv->reg.phy_type == D_11B_ONLY_MODE){
+	/* rate setting if rate segging is auto for changing phy_type (#94) */
+	if (priv->reg.tx_rate == TX_RATE_FULL_AUTO) {
+		if (priv->reg.phy_type == D_11B_ONLY_MODE) {
 			priv->reg.rate_set.body[3] = TX_RATE_11M;
 			priv->reg.rate_set.body[2] = TX_RATE_5M;
-			priv->reg.rate_set.body[1] = TX_RATE_2M|BASIC_RATE;
-			priv->reg.rate_set.body[0] = TX_RATE_1M|BASIC_RATE;
+			priv->reg.rate_set.body[1] = TX_RATE_2M | BASIC_RATE;
+			priv->reg.rate_set.body[0] = TX_RATE_1M | BASIC_RATE;
 			priv->reg.rate_set.size = 4;
-		}else{ /* D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE */
+		} else {	/* D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE */
 			priv->reg.rate_set.body[11] = TX_RATE_54M;
 			priv->reg.rate_set.body[10] = TX_RATE_48M;
 			priv->reg.rate_set.body[9] = TX_RATE_36M;
 			priv->reg.rate_set.body[8] = TX_RATE_18M;
 			priv->reg.rate_set.body[7] = TX_RATE_9M;
-			priv->reg.rate_set.body[6] = TX_RATE_24M|BASIC_RATE;
-			priv->reg.rate_set.body[5] = TX_RATE_12M|BASIC_RATE;
-			priv->reg.rate_set.body[4] = TX_RATE_6M|BASIC_RATE;
-			priv->reg.rate_set.body[3] = TX_RATE_11M|BASIC_RATE;
-			priv->reg.rate_set.body[2] = TX_RATE_5M|BASIC_RATE;
-			priv->reg.rate_set.body[1] = TX_RATE_2M|BASIC_RATE;
-			priv->reg.rate_set.body[0] = TX_RATE_1M|BASIC_RATE;
+			priv->reg.rate_set.body[6] = TX_RATE_24M | BASIC_RATE;
+			priv->reg.rate_set.body[5] = TX_RATE_12M | BASIC_RATE;
+			priv->reg.rate_set.body[4] = TX_RATE_6M | BASIC_RATE;
+			priv->reg.rate_set.body[3] = TX_RATE_11M | BASIC_RATE;
+			priv->reg.rate_set.body[2] = TX_RATE_5M | BASIC_RATE;
+			priv->reg.rate_set.body[1] = TX_RATE_2M | BASIC_RATE;
+			priv->reg.rate_set.body[0] = TX_RATE_1M | BASIC_RATE;
 			priv->reg.rate_set.size = 12;
 		}
 	}
 
 	/* rate mask by phy setting */
-	if(priv->reg.phy_type == D_11B_ONLY_MODE){
-		for(i=0;i<priv->reg.rate_set.size;i++){
-			if(IS_11B_RATE(priv->reg.rate_set.body[i])){
-				if((priv->reg.rate_set.body[i] & RATE_MASK) >= TX_RATE_5M)
-					rate_octet[i] = priv->reg.rate_set.body[i] & RATE_MASK ;
+	if (priv->reg.phy_type == D_11B_ONLY_MODE) {
+		for (i = 0; i < priv->reg.rate_set.size; i++) {
+			if (IS_11B_RATE(priv->reg.rate_set.body[i])) {
+				if ((priv->reg.rate_set.body[i] & RATE_MASK) >=
+				    TX_RATE_5M)
+					rate_octet[i] =
+					    priv->reg.rate_set.
+					    body[i] & RATE_MASK;
 				else
-					rate_octet[i] = priv->reg.rate_set.body[i];
-			}
-			else
+					rate_octet[i] =
+					    priv->reg.rate_set.body[i];
+			} else
 				break;
 		}
 
-	}else{ /* D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE */
-		for(i=0;i<priv->reg.rate_set.size;i++){
-			if(IS_11BG_RATE(priv->reg.rate_set.body[i])){
-				if(IS_OFDM_EXT_RATE(priv->reg.rate_set.body[i]))
-					rate_octet[i] = priv->reg.rate_set.body[i] & RATE_MASK ;
+	} else {	/* D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE */
+		for (i = 0; i < priv->reg.rate_set.size; i++) {
+			if (IS_11BG_RATE(priv->reg.rate_set.body[i])) {
+				if (IS_OFDM_EXT_RATE
+				    (priv->reg.rate_set.body[i]))
+					rate_octet[i] =
+					    priv->reg.rate_set.
+					    body[i] & RATE_MASK;
 				else
-					rate_octet[i] = priv->reg.rate_set.body[i];
-			}
-			else
+					rate_octet[i] =
+					    priv->reg.rate_set.body[i];
+			} else
 				break;
 		}
 	}
 	rate_size = i;
-	if(rate_size==0){
-		if(priv->reg.phy_type == D_11G_ONLY_MODE)
-			rate_octet[0]=TX_RATE_6M | BASIC_RATE;
+	if (rate_size == 0) {
+		if (priv->reg.phy_type == D_11G_ONLY_MODE)
+			rate_octet[0] = TX_RATE_6M | BASIC_RATE;
 		else
-			rate_octet[0]=TX_RATE_2M | BASIC_RATE;
+			rate_octet[0] = TX_RATE_2M | BASIC_RATE;
 		rate_size = 1;
 	}
 
@@ -2060,84 +2226,93 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 	priv->reg.rate_set.size = rate_size;
 	memcpy(&priv->reg.rate_set.body[0], &rate_octet[0], rate_size);
 
-	switch ( priv->reg.operation_mode ) {
+	switch (priv->reg.operation_mode) {
 	case MODE_PSEUDO_ADHOC:
 		/* Pseudo Ad-Hoc mode */
 		hostif_ps_adhoc_set_request(priv);
 		break;
 	case MODE_INFRASTRUCTURE:
 		/* Infrastructure mode */
-		if (!is_valid_ether_addr((u8 *)priv->reg.bssid)) {
+		if (!is_valid_ether_addr((u8 *) priv->reg.bssid)) {
 			hostif_infrastructure_set_request(priv);
-		}
-		else {
+		} else {
 			hostif_infrastructure_set2_request(priv);
-			DPRINTK(2, "Infra bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
-			       priv->reg.bssid[0],priv->reg.bssid[1],priv->reg.bssid[2],
-			       priv->reg.bssid[3],priv->reg.bssid[4],priv->reg.bssid[5]);
+			DPRINTK(2,
+				"Infra bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
+				priv->reg.bssid[0], priv->reg.bssid[1],
+				priv->reg.bssid[2], priv->reg.bssid[3],
+				priv->reg.bssid[4], priv->reg.bssid[5]);
 		}
 		break;
 	case MODE_ADHOC:
 		/* IEEE802.11 Ad-Hoc mode */
-		if (!is_valid_ether_addr((u8 *)priv->reg.bssid)) {
+		if (!is_valid_ether_addr((u8 *) priv->reg.bssid)) {
 			hostif_adhoc_set_request(priv);
-		}
-		else {
+		} else {
 			hostif_adhoc_set2_request(priv);
-			DPRINTK(2, "Adhoc bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
-			       priv->reg.bssid[0],priv->reg.bssid[1],priv->reg.bssid[2],
-    			   priv->reg.bssid[3],priv->reg.bssid[4],priv->reg.bssid[5]);
+			DPRINTK(2,
+				"Adhoc bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
+				priv->reg.bssid[0], priv->reg.bssid[1],
+				priv->reg.bssid[2], priv->reg.bssid[3],
+				priv->reg.bssid[4], priv->reg.bssid[5]);
 		}
 		break;
 	default:
 		break;
 	}
 
-	return ;
+	return;
 }
 
 static
 void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 {
 
-        struct net_device *dev = priv->net_dev;
+	struct net_device *dev = priv->net_dev;
 	int mc_count;
 	struct netdev_hw_addr *ha;
-	char	set_address[NIC_MAX_MCAST_LIST*ETH_ALEN];
+	char set_address[NIC_MAX_MCAST_LIST * ETH_ALEN];
 	unsigned long filter_type;
 	int i = 0;
 
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
 	spin_lock(&priv->multicast_spin);
 
-	memset(set_address, 0, NIC_MAX_MCAST_LIST*ETH_ALEN);
-
-	if (dev->flags & IFF_PROMISC ){
-		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_PROMISC);
-		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER, sizeof(filter_type),
-				       MIB_VALUE_TYPE_BOOL, &filter_type);
-	}
-	else if ((netdev_mc_count(dev) > NIC_MAX_MCAST_LIST) || (dev->flags & IFF_ALLMULTI)){
-		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCASTALL);
-		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER, sizeof(filter_type),
-				       MIB_VALUE_TYPE_BOOL, &filter_type);
-	}
-	else {
-		if (priv->sme_i.sme_flag & SME_MULTICAST){
+	memset(set_address, 0, NIC_MAX_MCAST_LIST * ETH_ALEN);
+
+	if (dev->flags & IFF_PROMISC) {
+		filter_type = cpu_to_le32((uint32_t) MCAST_FILTER_PROMISC);
+		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
+				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
+				       &filter_type);
+	} else if ((netdev_mc_count(dev) > NIC_MAX_MCAST_LIST)
+		   || (dev->flags & IFF_ALLMULTI)) {
+		filter_type = cpu_to_le32((uint32_t) MCAST_FILTER_MCASTALL);
+		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
+				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
+				       &filter_type);
+	} else {
+		if (priv->sme_i.sme_flag & SME_MULTICAST) {
 			mc_count = netdev_mc_count(dev);
 			netdev_for_each_mc_addr(ha, dev) {
-				memcpy(&set_address[i*ETH_ALEN], ha->addr, ETH_ALEN);
+				memcpy(&set_address[i * ETH_ALEN], ha->addr,
+				       ETH_ALEN);
 				i++;
 			}
 			priv->sme_i.sme_flag &= ~SME_MULTICAST;
 			hostif_mib_set_request(priv, LOCAL_MULTICAST_ADDRESS,
-					       (ETH_ALEN*mc_count), MIB_VALUE_TYPE_OSTRING, &set_address[0]);
-		}else {
-			filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCAST);
+					       (ETH_ALEN * mc_count),
+					       MIB_VALUE_TYPE_OSTRING,
+					       &set_address[0]);
+		} else {
+			filter_type =
+			    cpu_to_le32((uint32_t) MCAST_FILTER_MCAST);
 			priv->sme_i.sme_flag |= SME_MULTICAST;
-			hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER, sizeof(filter_type),
-					       MIB_VALUE_TYPE_BOOL, &filter_type);
+			hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
+					       sizeof(filter_type),
+					       MIB_VALUE_TYPE_BOOL,
+					       &filter_type);
 		}
 	}
 
@@ -2148,17 +2323,17 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 static
 void hostif_sme_powermgt_set(struct ks_wlan_private *priv)
 {
-	unsigned long mode,wake_up,receiveDTIMs ;
+	unsigned long mode, wake_up, receiveDTIMs;
 
-	DPRINTK(3,"\n");
-	switch(priv->reg.powermgt){
+	DPRINTK(3, "\n");
+	switch (priv->reg.powermgt) {
 	case POWMGT_ACTIVE_MODE:
 		mode = POWER_ACTIVE;
 		wake_up = 0;
 		receiveDTIMs = 0;
 		break;
 	case POWMGT_SAVE1_MODE:
-		if(priv->reg.operation_mode == MODE_INFRASTRUCTURE){
+		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 			mode = POWER_SAVE;
 			wake_up = 0;
 			receiveDTIMs = 0;
@@ -2169,7 +2344,7 @@ void hostif_sme_powermgt_set(struct ks_wlan_private *priv)
 		}
 		break;
 	case POWMGT_SAVE2_MODE:
-		if(priv->reg.operation_mode == MODE_INFRASTRUCTURE){
+		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 			mode = POWER_SAVE;
 			wake_up = 0;
 			receiveDTIMs = 1;
@@ -2193,8 +2368,8 @@ void hostif_sme_powermgt_set(struct ks_wlan_private *priv)
 static
 void hostif_sme_sleep_set(struct ks_wlan_private *priv)
 {
-	DPRINTK(3,"\n");
-	switch(priv->sleep_mode){
+	DPRINTK(3, "\n");
+	switch (priv->sleep_mode) {
 	case SLP_SLEEP:
 		hostif_sleep_request(priv, priv->sleep_mode);
 		break;
@@ -2212,53 +2387,55 @@ static
 void hostif_sme_set_key(struct ks_wlan_private *priv, int type)
 {
 	uint32_t val;
-	switch(type){
+	switch (type) {
 	case SME_SET_FLAG:
-		val = cpu_to_le32((uint32_t)(priv->reg.privacy_invoked));
+		val = cpu_to_le32((uint32_t) (priv->reg.privacy_invoked));
 		hostif_mib_set_request(priv, DOT11_PRIVACY_INVOKED,
-				       sizeof(val), MIB_VALUE_TYPE_BOOL,
-				       &val );
+				       sizeof(val), MIB_VALUE_TYPE_BOOL, &val);
 		break;
 	case SME_SET_TXKEY:
-		val = cpu_to_le32((uint32_t)(priv->wpa.txkey));
+		val = cpu_to_le32((uint32_t) (priv->wpa.txkey));
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_ID,
-				       sizeof(val), MIB_VALUE_TYPE_INT,
-				       &val );
+				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
 		break;
 	case SME_SET_KEY1:
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE1,
-				       priv->wpa.key[0].key_len, MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[0].key_val[0] );
+				       priv->wpa.key[0].key_len,
+				       MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[0].key_val[0]);
 		break;
 	case SME_SET_KEY2:
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE2,
-				       priv->wpa.key[1].key_len, MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[1].key_val[0] );
+				       priv->wpa.key[1].key_len,
+				       MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[1].key_val[0]);
 		break;
 	case SME_SET_KEY3:
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE3,
-				       priv->wpa.key[2].key_len, MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[2].key_val[0] );
+				       priv->wpa.key[2].key_len,
+				       MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[2].key_val[0]);
 		break;
 	case SME_SET_KEY4:
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE4,
-				       priv->wpa.key[3].key_len, MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[3].key_val[0] );
+				       priv->wpa.key[3].key_len,
+				       MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[3].key_val[0]);
 		break;
 	case SME_SET_PMK_TSC:
 		hostif_mib_set_request(priv, DOT11_PMK_TSC,
 				       WPA_RX_SEQ_LEN, MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[0].rx_seq[0] );
+				       &priv->wpa.key[0].rx_seq[0]);
 		break;
 	case SME_SET_GMK1_TSC:
 		hostif_mib_set_request(priv, DOT11_GMK1_TSC,
 				       WPA_RX_SEQ_LEN, MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[1].rx_seq[0] );
+				       &priv->wpa.key[1].rx_seq[0]);
 		break;
 	case SME_SET_GMK2_TSC:
 		hostif_mib_set_request(priv, DOT11_GMK2_TSC,
 				       WPA_RX_SEQ_LEN, MIB_VALUE_TYPE_OSTRING,
-				       &priv->wpa.key[2].rx_seq[0] );
+				       &priv->wpa.key[2].rx_seq[0]);
 		break;
 	}
 	return;
@@ -2270,28 +2447,31 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 	struct pmk_cache_t {
 		uint16_t size;
 		struct {
-			uint8_t	bssid[ETH_ALEN];
-			uint8_t	pmkid[IW_PMKID_LEN];
-		} __attribute__((packed)) list[PMK_LIST_MAX];
-	} __attribute__((packed)) pmkcache;
+			uint8_t bssid[ETH_ALEN];
+			uint8_t pmkid[IW_PMKID_LEN];
+		} __attribute__ ((packed)) list[PMK_LIST_MAX];
+	} __attribute__ ((packed)) pmkcache;
 	struct pmk_t *pmk;
 	struct list_head *ptr;
 	int i;
 
-	DPRINTK(4,"pmklist.size=%d\n",priv->pmklist.size);
-	i=0;
-	list_for_each(ptr, &priv->pmklist.head){
+	DPRINTK(4, "pmklist.size=%d\n", priv->pmklist.size);
+	i = 0;
+	list_for_each(ptr, &priv->pmklist.head) {
 		pmk = list_entry(ptr, struct pmk_t, list);
-		if(i<PMK_LIST_MAX){
+		if (i < PMK_LIST_MAX) {
 			memcpy(pmkcache.list[i].bssid, pmk->bssid, ETH_ALEN);
-			memcpy(pmkcache.list[i].pmkid, pmk->pmkid, IW_PMKID_LEN);
+			memcpy(pmkcache.list[i].pmkid, pmk->pmkid,
+			       IW_PMKID_LEN);
 			i++;
 		}
 	}
-	pmkcache.size = cpu_to_le16((uint16_t)(priv->pmklist.size));
+	pmkcache.size = cpu_to_le16((uint16_t) (priv->pmklist.size));
 	hostif_mib_set_request(priv, LOCAL_PMK,
-			       sizeof(priv->pmklist.size)+(ETH_ALEN+IW_PMKID_LEN)*(priv->pmklist.size),
-			       MIB_VALUE_TYPE_OSTRING,&pmkcache );
+			       sizeof(priv->pmklist.size) + (ETH_ALEN +
+							     IW_PMKID_LEN) *
+			       (priv->pmklist.size), MIB_VALUE_TYPE_OSTRING,
+			       &pmkcache);
 }
 
 /* execute sme */
@@ -2300,10 +2480,10 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 {
 	uint32_t val;
 
-	DPRINTK(3,"event=%d\n",event);
+	DPRINTK(3, "event=%d\n", event);
 	switch (event) {
 	case SME_START:
-		if ( priv->dev_state == DEVICE_STATE_BOOT ){
+		if (priv->dev_state == DEVICE_STATE_BOOT) {
 			hostif_mib_get_request(priv, DOT11_MAC_ADDRESS);
 		}
 		break;
@@ -2312,10 +2492,12 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		break;
 	case SME_MACADDRESS_SET_REQUEST:
 		hostif_mib_set_request(priv, LOCAL_CURRENTADDRESS, ETH_ALEN,
-				       MIB_VALUE_TYPE_OSTRING, &priv->eth_addr[0]);
+				       MIB_VALUE_TYPE_OSTRING,
+				       &priv->eth_addr[0]);
 		break;
 	case SME_BSS_SCAN_REQUEST:
-		hostif_bss_scan_request(priv, priv->reg.scan_type, priv->scan_ssid, priv->scan_ssid_len);
+		hostif_bss_scan_request(priv, priv->reg.scan_type,
+					priv->scan_ssid, priv->scan_ssid_len);
 		break;
 	case SME_POW_MNGMT_REQUEST:
 		hostif_sme_powermgt_set(priv);
@@ -2324,30 +2506,36 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_phy_information_request(priv);
 		break;
 	case SME_MIC_FAILURE_REQUEST:
-		if(priv->wpa.mic_failure.failure == 1){
-			hostif_mic_failure_request(priv, priv->wpa.mic_failure.failure-1, 0);
-		}else if(priv->wpa.mic_failure.failure == 2){
-			hostif_mic_failure_request(priv, priv->wpa.mic_failure.failure-1,
-						   priv->wpa.mic_failure.counter);
-		}else
-			DPRINTK(4,"SME_MIC_FAILURE_REQUEST: failure count=%u error?\n",
+		if (priv->wpa.mic_failure.failure == 1) {
+			hostif_mic_failure_request(priv,
+						   priv->wpa.mic_failure.
+						   failure - 1, 0);
+		} else if (priv->wpa.mic_failure.failure == 2) {
+			hostif_mic_failure_request(priv,
+						   priv->wpa.mic_failure.
+						   failure - 1,
+						   priv->wpa.mic_failure.
+						   counter);
+		} else
+			DPRINTK(4,
+				"SME_MIC_FAILURE_REQUEST: failure count=%u error?\n",
 				priv->wpa.mic_failure.failure);
 		break;
 	case SME_MIC_FAILURE_CONFIRM:
-		if(priv->wpa.mic_failure.failure == 2){
-			if(priv->wpa.mic_failure.stop)
+		if (priv->wpa.mic_failure.failure == 2) {
+			if (priv->wpa.mic_failure.stop)
 				priv->wpa.mic_failure.stop = 0;
 			priv->wpa.mic_failure.failure = 0;
-			hostif_start_request( priv, priv->reg.operation_mode );
+			hostif_start_request(priv, priv->reg.operation_mode);
 		}
 		break;
 	case SME_GET_MAC_ADDRESS:
-		if ( priv->dev_state == DEVICE_STATE_BOOT ){
+		if (priv->dev_state == DEVICE_STATE_BOOT) {
 			hostif_mib_get_request(priv, DOT11_PRODUCT_VERSION);
 		}
 		break;
 	case SME_GET_PRODUCT_VERSION:
-		if ( priv->dev_state == DEVICE_STATE_BOOT ){
+		if (priv->dev_state == DEVICE_STATE_BOOT) {
 			priv->dev_state = DEVICE_STATE_PREINIT;
 		}
 		break;
@@ -2355,33 +2543,40 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_stop_request(priv);
 		break;
 	case SME_RTS_THRESHOLD_REQUEST:
-		val = cpu_to_le32((uint32_t)(priv->reg.rts));
+		val = cpu_to_le32((uint32_t) (priv->reg.rts));
 		hostif_mib_set_request(priv, DOT11_RTS_THRESHOLD,
-				       sizeof(val), MIB_VALUE_TYPE_INT,
-				       &val );
+				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
 		break;
 	case SME_FRAGMENTATION_THRESHOLD_REQUEST:
-		val = cpu_to_le32((uint32_t)(priv->reg.fragment));
+		val = cpu_to_le32((uint32_t) (priv->reg.fragment));
 		hostif_mib_set_request(priv, DOT11_FRAGMENTATION_THRESHOLD,
-				       sizeof(val), MIB_VALUE_TYPE_INT,
-				       &val );
+				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
 		break;
-	case SME_WEP_INDEX_REQUEST: case SME_WEP_KEY1_REQUEST:
-	case SME_WEP_KEY2_REQUEST:  case SME_WEP_KEY3_REQUEST:
-	case SME_WEP_KEY4_REQUEST:  case SME_WEP_FLAG_REQUEST:
-		hostif_sme_set_wep(priv,event);
+	case SME_WEP_INDEX_REQUEST:
+	case SME_WEP_KEY1_REQUEST:
+	case SME_WEP_KEY2_REQUEST:
+	case SME_WEP_KEY3_REQUEST:
+	case SME_WEP_KEY4_REQUEST:
+	case SME_WEP_FLAG_REQUEST:
+		hostif_sme_set_wep(priv, event);
 		break;
-	case SME_RSN_UCAST_REQUEST: case SME_RSN_MCAST_REQUEST:
-	case SME_RSN_AUTH_REQUEST: case SME_RSN_ENABLED_REQUEST:
+	case SME_RSN_UCAST_REQUEST:
+	case SME_RSN_MCAST_REQUEST:
+	case SME_RSN_AUTH_REQUEST:
+	case SME_RSN_ENABLED_REQUEST:
 	case SME_RSN_MODE_REQUEST:
-		hostif_sme_set_rsn(priv,event);
+		hostif_sme_set_rsn(priv, event);
 		break;
-	case SME_SET_FLAG:    case SME_SET_TXKEY:
-	case SME_SET_KEY1:    case SME_SET_KEY2:
-	case SME_SET_KEY3:    case SME_SET_KEY4:
-	case SME_SET_PMK_TSC: case SME_SET_GMK1_TSC:
+	case SME_SET_FLAG:
+	case SME_SET_TXKEY:
+	case SME_SET_KEY1:
+	case SME_SET_KEY2:
+	case SME_SET_KEY3:
+	case SME_SET_KEY4:
+	case SME_SET_PMK_TSC:
+	case SME_SET_GMK1_TSC:
 	case SME_SET_GMK2_TSC:
-		hostif_sme_set_key(priv,event);
+		hostif_sme_set_key(priv, event);
 		break;
 	case SME_SET_PMKSA:
 		hostif_sme_set_pmksa(priv);
@@ -2390,7 +2585,8 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 	case SME_WPS_ENABLE_REQUEST:
 		hostif_mib_set_request(priv, LOCAL_WPS_ENABLE,
 				       sizeof(priv->wps.wps_enabled),
-				       MIB_VALUE_TYPE_INT, &priv->wps.wps_enabled );
+				       MIB_VALUE_TYPE_INT,
+				       &priv->wps.wps_enabled);
 		break;
 	case SME_WPS_PROBE_REQUEST:
 		hostif_mib_set_request(priv, LOCAL_WPS_PROBE_REQ,
@@ -2403,8 +2599,8 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		break;
 	case SME_SET_GAIN:
 		hostif_mib_set_request(priv, LOCAL_GAIN,
-				       sizeof(priv->gain), MIB_VALUE_TYPE_OSTRING,
-				       &priv->gain);
+				       sizeof(priv->gain),
+				       MIB_VALUE_TYPE_OSTRING, &priv->gain);
 		break;
 	case SME_GET_GAIN:
 		hostif_mib_get_request(priv, LOCAL_GAIN);
@@ -2414,13 +2610,13 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_mib_get_request(priv, LOCAL_EEPROM_SUM);
 		break;
 	case SME_START_REQUEST:
-		hostif_start_request( priv, priv->reg.operation_mode );
+		hostif_start_request(priv, priv->reg.operation_mode);
 		break;
 	case SME_START_CONFIRM:
 		/* for power save */
 		atomic_set(&priv->psstatus.snooze_guard, 0);
-		atomic_set(&priv->psstatus.confirm_wait,0);
-		if ( priv->dev_state == DEVICE_STATE_PREINIT ){
+		atomic_set(&priv->psstatus.confirm_wait, 0);
+		if (priv->dev_state == DEVICE_STATE_PREINIT) {
 			priv->dev_state = DEVICE_STATE_INIT;
 		}
 		/* wake_up_interruptible_all(&priv->confirm_wait); */
@@ -2430,10 +2626,9 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_sme_sleep_set(priv);
 		break;
 	case SME_SET_REGION:
-		val = cpu_to_le32((uint32_t)(priv->region));
+		val = cpu_to_le32((uint32_t) (priv->region));
 		hostif_mib_set_request(priv, LOCAL_REGION,
-				       sizeof(val), MIB_VALUE_TYPE_INT,
-				       &val );
+				       sizeof(val), MIB_VALUE_TYPE_INT, &val);
 		break;
 	case SME_MULTICAST_CONFIRM:
 	case SME_BSS_SCAN_CONFIRM:
@@ -2442,11 +2637,16 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 	case SME_STOP_CONFIRM:
 	case SME_RTS_THRESHOLD_CONFIRM:
 	case SME_FRAGMENTATION_THRESHOLD_CONFIRM:
-	case SME_WEP_INDEX_CONFIRM: case SME_WEP_KEY1_CONFIRM:
-	case SME_WEP_KEY2_CONFIRM:  case SME_WEP_KEY3_CONFIRM:
-	case SME_WEP_KEY4_CONFIRM:  case SME_WEP_FLAG_CONFIRM:
-	case SME_RSN_UCAST_CONFIRM: case SME_RSN_MCAST_CONFIRM:
-	case SME_RSN_AUTH_CONFIRM:  case SME_RSN_ENABLED_CONFIRM:
+	case SME_WEP_INDEX_CONFIRM:
+	case SME_WEP_KEY1_CONFIRM:
+	case SME_WEP_KEY2_CONFIRM:
+	case SME_WEP_KEY3_CONFIRM:
+	case SME_WEP_KEY4_CONFIRM:
+	case SME_WEP_FLAG_CONFIRM:
+	case SME_RSN_UCAST_CONFIRM:
+	case SME_RSN_MCAST_CONFIRM:
+	case SME_RSN_AUTH_CONFIRM:
+	case SME_RSN_ENABLED_CONFIRM:
 	case SME_RSN_MODE_CONFIRM:
 	case SME_MODE_SET_CONFIRM:
 		break;
@@ -2457,18 +2657,21 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 }
 
 static
-void hostif_sme_task( unsigned long dev )
+void hostif_sme_task(unsigned long dev)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
 
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
-	if(priv->dev_state >= DEVICE_STATE_BOOT){
-		if (0 < cnt_smeqbody(priv) && priv->dev_state >= DEVICE_STATE_BOOT) {
-			hostif_sme_execute(priv, priv->sme_i.event_buff[priv->sme_i.qhead]);
+	if (priv->dev_state >= DEVICE_STATE_BOOT) {
+		if (0 < cnt_smeqbody(priv)
+		    && priv->dev_state >= DEVICE_STATE_BOOT) {
+			hostif_sme_execute(priv,
+					   priv->sme_i.event_buff[priv->sme_i.
+								  qhead]);
 			inc_smeqhead(priv);
 			if (0 < cnt_smeqbody(priv))
-			        tasklet_schedule(&priv->sme_task);
+				tasklet_schedule(&priv->sme_task);
 		}
 	}
 	return;
@@ -2477,9 +2680,7 @@ void hostif_sme_task( unsigned long dev )
 /* send to Station Management Entity module */
 void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
 {
-	DPRINTK(3,"\n");
-
-
+	DPRINTK(3, "\n");
 
 	/* enqueue sme event */
 	if (cnt_smeqbody(priv) < (SME_EVENT_BUFF_SIZE - 1)) {
@@ -2500,16 +2701,16 @@ void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
 
 }
 
-int hostif_init( struct ks_wlan_private *priv )
+int hostif_init(struct ks_wlan_private *priv)
 {
-	int rc=0;
+	int rc = 0;
 	int i;
 
-	DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
-	priv->aplist.size =0;
-	for(i=0;i<LOCAL_APLIST_MAX;i++)
-		memset(&(priv->aplist.ap[i]),0,sizeof(struct local_ap_t));
+	priv->aplist.size = 0;
+	for (i = 0; i < LOCAL_APLIST_MAX; i++)
+		memset(&(priv->aplist.ap[i]), 0, sizeof(struct local_ap_t));
 	priv->infra_status = 0;
 	priv->current_rate = 4;
 	priv->connect_status = DISCONNECT_STATUS;
@@ -2517,7 +2718,7 @@ int hostif_init( struct ks_wlan_private *priv )
 	spin_lock_init(&priv->multicast_spin);
 
 	spin_lock_init(&priv->dev_read_lock);
-	init_waitqueue_head (&priv->devread_wait);
+	init_waitqueue_head(&priv->devread_wait);
 	priv->dev_count = 0;
 	atomic_set(&priv->event_count, 0);
 	atomic_set(&priv->rec_count, 0);
@@ -2539,7 +2740,7 @@ int hostif_init( struct ks_wlan_private *priv )
 	priv->wpa.mic_failure.stop = 0;
 	memset(&(priv->pmklist), 0, sizeof(priv->pmklist));
 	INIT_LIST_HEAD(&priv->pmklist.head);
-	for(i=0;i<PMK_LIST_MAX;i++)
+	for (i = 0; i < PMK_LIST_MAX; i++)
 		INIT_LIST_HEAD(&priv->pmklist.pmk[i].list);
 
 	priv->sme_i.sme_status = SME_IDLE;
@@ -2547,7 +2748,7 @@ int hostif_init( struct ks_wlan_private *priv )
 #ifdef KS_WLAN_DEBUG
 	priv->sme_i.max_event_count = 0;
 #endif
-        spin_lock_init(&priv->sme_i.sme_spin);
+	spin_lock_init(&priv->sme_i.sme_spin);
 	priv->sme_i.sme_flag = 0;
 
 	tasklet_init(&priv->sme_task, hostif_sme_task, (unsigned long)priv);
@@ -2555,9 +2756,8 @@ int hostif_init( struct ks_wlan_private *priv )
 	return rc;
 }
 
-void hostif_exit( struct ks_wlan_private *priv )
+void hostif_exit(struct ks_wlan_private *priv)
 {
 	tasklet_kill(&priv->sme_task);
 	return;
 }
-

commit feedcf1a5f3d4fc964d9f7b4d755fc0992378abf
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:26 2016 +0200

    staging: ks7010: remove unecessary typedef
    
    Let's simply specify the struct to keep in sync with kernel coding
    style.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index b0a0a53d3a00..497b8aaf6dae 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -23,13 +23,13 @@
 /* Include Wireless Extension definition and check version */
 #include <net/iw_handler.h>	/* New driver API */
 
-extern int ks_wlan_hw_tx(ks_wlan_private *priv, void *p, unsigned long size,
+extern int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
 			 void (*complete_handler)(void *arg1, void *arg2),
 			 void *arg1, void *arg2 );
 extern void send_packet_complete(void *, void *);
 
-extern void ks_wlan_hw_wakeup_request(ks_wlan_private *priv);
-extern int ks_wlan_hw_power_save(ks_wlan_private *priv);
+extern void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv);
+extern int ks_wlan_hw_power_save(struct ks_wlan_private *priv);
 
 /* macro */
 #define inc_smeqhead(priv) \
@@ -42,7 +42,7 @@ extern int ks_wlan_hw_power_save(ks_wlan_private *priv);
 #define KS_WLAN_MEM_FLAG (GFP_ATOMIC)
 
 static
-inline u8 get_BYTE(ks_wlan_private *priv)
+inline u8 get_BYTE(struct ks_wlan_private *priv)
 {
 	u8 data;
 	data = *(priv->rxp)++;
@@ -52,7 +52,7 @@ inline u8 get_BYTE(ks_wlan_private *priv)
 }
 
 static
-inline u16 get_WORD(ks_wlan_private *priv)
+inline u16 get_WORD(struct ks_wlan_private *priv)
 {
 	u16 data;
 	data  = (get_BYTE(priv) & 0xff);
@@ -61,7 +61,7 @@ inline u16 get_WORD(ks_wlan_private *priv)
 }
 
 static
-inline u32 get_DWORD(ks_wlan_private *priv)
+inline u32 get_DWORD(struct ks_wlan_private *priv)
 {
 	u32 data;
 	data  = (get_BYTE(priv) & 0xff);
@@ -73,7 +73,7 @@ inline u32 get_DWORD(ks_wlan_private *priv)
 
 void ks_wlan_hw_wakeup_task(struct work_struct *work)
 {
-	ks_wlan_private *priv = container_of(work, struct ks_wlan_private, ks_wlan_wakeup_task);
+	struct ks_wlan_private *priv = container_of(work, struct ks_wlan_private, ks_wlan_wakeup_task);
 	int ps_status = atomic_read(&priv->psstatus.status);
 
 	if(ps_status==PS_SNOOZE){
@@ -96,7 +96,7 @@ void ks_wlan_hw_wakeup_task(struct work_struct *work)
 }
 
 static
-int ks_wlan_do_power_save(ks_wlan_private *priv)
+int ks_wlan_do_power_save(struct ks_wlan_private *priv)
 {
 	int rc=0;
 
@@ -112,7 +112,7 @@ int ks_wlan_do_power_save(ks_wlan_private *priv)
 }
 
 static
-int get_current_ap(ks_wlan_private *priv, struct link_ap_info_t *ap_info)
+int get_current_ap(struct ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 {
 	struct local_ap_t *ap;
 	union iwreq_data wrqu;
@@ -213,7 +213,7 @@ int get_current_ap(ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 }
 
 static
-int get_ap_information(ks_wlan_private *priv, struct ap_info_t *ap_info, struct local_ap_t *ap)
+int get_ap_information(struct ks_wlan_private *priv, struct ap_info_t *ap_info, struct local_ap_t *ap)
 {
 	unsigned char *bp;
 	int bsize,offset;
@@ -312,7 +312,7 @@ int get_ap_information(ks_wlan_private *priv, struct ap_info_t *ap_info, struct
 }
 
 static
-void hostif_data_indication(ks_wlan_private *priv)
+void hostif_data_indication(struct ks_wlan_private *priv)
 {
 	unsigned int	rx_ind_size;	/* indicate data size */
 	struct sk_buff *skb;
@@ -491,7 +491,7 @@ void hostif_data_indication(ks_wlan_private *priv)
 }
 
 static
-void hostif_mib_get_confirm(ks_wlan_private *priv)
+void hostif_mib_get_confirm(struct ks_wlan_private *priv)
 {
 	struct net_device *dev=priv->net_dev;
 	uint32_t	mib_status;
@@ -570,7 +570,7 @@ void hostif_mib_get_confirm(ks_wlan_private *priv)
 }
 
 static
-void hostif_mib_set_confirm(ks_wlan_private *priv)
+void hostif_mib_set_confirm(struct ks_wlan_private *priv)
 {
 	uint32_t	mib_status;	/* +04 MIB Status */
 	uint32_t	mib_attribute;	/* +08 MIB attribute */
@@ -691,7 +691,7 @@ void hostif_mib_set_confirm(ks_wlan_private *priv)
 }
 
 static
-void hostif_power_mngmt_confirm(ks_wlan_private *priv)
+void hostif_power_mngmt_confirm(struct ks_wlan_private *priv)
 {
 	DPRINTK(3,"\n");
 
@@ -707,7 +707,7 @@ void hostif_power_mngmt_confirm(ks_wlan_private *priv)
 }
 
 static
-void hostif_sleep_confirm(ks_wlan_private *priv)
+void hostif_sleep_confirm(struct ks_wlan_private *priv)
 {
 	DPRINTK(3,"\n");
 
@@ -716,7 +716,7 @@ void hostif_sleep_confirm(ks_wlan_private *priv)
 }
 
 static
-void hostif_start_confirm(ks_wlan_private *priv)
+void hostif_start_confirm(struct ks_wlan_private *priv)
 {
 #ifdef  WPS
        union iwreq_data        wrqu;
@@ -734,7 +734,7 @@ void hostif_start_confirm(ks_wlan_private *priv)
 }
 
 static
-void hostif_connect_indication(ks_wlan_private *priv)
+void hostif_connect_indication(struct ks_wlan_private *priv)
 {
 	unsigned short connect_code;
 	unsigned int tmp=0;
@@ -789,7 +789,7 @@ void hostif_connect_indication(ks_wlan_private *priv)
 }
 
 static
-void hostif_scan_indication(ks_wlan_private *priv)
+void hostif_scan_indication(struct ks_wlan_private *priv)
 {
 	int i;
 	struct ap_info_t *ap_info;
@@ -820,7 +820,7 @@ void hostif_scan_indication(ks_wlan_private *priv)
 }
 
 static
-void hostif_stop_confirm(ks_wlan_private *priv)
+void hostif_stop_confirm(struct ks_wlan_private *priv)
 {
 	unsigned int tmp=0;
 	unsigned int old_status=priv->connect_status;
@@ -856,7 +856,7 @@ void hostif_stop_confirm(ks_wlan_private *priv)
 }
 
 static
-void hostif_ps_adhoc_set_confirm(ks_wlan_private *priv)
+void hostif_ps_adhoc_set_confirm(struct ks_wlan_private *priv)
 {
 	DPRINTK(3,"\n");
 	priv->infra_status = 0; /* infrastructure mode cancel */
@@ -865,7 +865,7 @@ void hostif_ps_adhoc_set_confirm(ks_wlan_private *priv)
 }
 
 static
-void hostif_infrastructure_set_confirm(ks_wlan_private *priv)
+void hostif_infrastructure_set_confirm(struct ks_wlan_private *priv)
 {
 	uint16_t result_code;
 	DPRINTK(3,"\n");
@@ -876,7 +876,7 @@ void hostif_infrastructure_set_confirm(ks_wlan_private *priv)
 }
 
 static
-void hostif_adhoc_set_confirm(ks_wlan_private *priv)
+void hostif_adhoc_set_confirm(struct ks_wlan_private *priv)
 {
 	DPRINTK(3,"\n");
 	priv->infra_status = 1; /* infrastructure mode set */
@@ -884,7 +884,7 @@ void hostif_adhoc_set_confirm(ks_wlan_private *priv)
 }
 
 static
-void hostif_associate_indication(ks_wlan_private *priv)
+void hostif_associate_indication(struct ks_wlan_private *priv)
 {
 	struct association_request_t *assoc_req;
 	struct association_response_t *assoc_resp;
@@ -928,7 +928,7 @@ void hostif_associate_indication(ks_wlan_private *priv)
 }
 
 static
-void hostif_bss_scan_confirm(ks_wlan_private *priv)
+void hostif_bss_scan_confirm(struct ks_wlan_private *priv)
 {
 	unsigned int result_code;
 	struct net_device *dev = priv->net_dev;
@@ -947,7 +947,7 @@ void hostif_bss_scan_confirm(ks_wlan_private *priv)
 }
 
 static
-void hostif_phy_information_confirm(ks_wlan_private *priv)
+void hostif_phy_information_confirm(struct ks_wlan_private *priv)
 {
 	struct iw_statistics *wstats = &priv->wstats;
 	unsigned char rssi,signal,noise;
@@ -983,7 +983,7 @@ void hostif_phy_information_confirm(ks_wlan_private *priv)
 }
 
 static
-void hostif_mic_failure_confirm(ks_wlan_private *priv)
+void hostif_mic_failure_confirm(struct ks_wlan_private *priv)
 {
 	DPRINTK(3,"mic_failure=%u\n",priv->wpa.mic_failure.failure);
 	hostif_sme_enqueue(priv, SME_MIC_FAILURE_CONFIRM);
@@ -991,7 +991,7 @@ void hostif_mic_failure_confirm(ks_wlan_private *priv)
 
 
 static
-void hostif_event_check(ks_wlan_private *priv)
+void hostif_event_check(struct ks_wlan_private *priv)
 {
 	unsigned short event;
 
@@ -1065,7 +1065,7 @@ void hostif_event_check(ks_wlan_private *priv)
 
 #define CHECK_ALINE(size) (size%4 ? (size+(4-(size%4))):size)
 
-int hostif_data_request(ks_wlan_private *priv, struct sk_buff *packet)
+int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 {
 	unsigned int		packet_len=0;
 
@@ -1231,7 +1231,7 @@ int hostif_data_request(ks_wlan_private *priv, struct sk_buff *packet)
                                       } }while(0)
 
 static
-void hostif_mib_get_request( ks_wlan_private *priv, unsigned long mib_attribute)
+void hostif_mib_get_request( struct ks_wlan_private *priv, unsigned long mib_attribute)
 {
 	struct hostif_mib_get_request_t *pp;
 
@@ -1253,7 +1253,7 @@ void hostif_mib_get_request( ks_wlan_private *priv, unsigned long mib_attribute)
 }
 
 static
-void hostif_mib_set_request( ks_wlan_private *priv, unsigned long mib_attribute,
+void hostif_mib_set_request( struct ks_wlan_private *priv, unsigned long mib_attribute,
 			     unsigned short size, unsigned short type,
 			     void *vp )
 {
@@ -1286,7 +1286,7 @@ void hostif_mib_set_request( ks_wlan_private *priv, unsigned long mib_attribute,
 }
 
 static
-void hostif_start_request( ks_wlan_private *priv, unsigned char mode )
+void hostif_start_request( struct ks_wlan_private *priv, unsigned char mode )
 {
 	struct hostif_start_request_t *pp;
 
@@ -1311,7 +1311,7 @@ void hostif_start_request( ks_wlan_private *priv, unsigned char mode )
 }
 
 static
-void hostif_ps_adhoc_set_request(ks_wlan_private *priv)
+void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 {
 	struct hostif_ps_adhoc_set_request_t *pp;
 	uint16_t capability;
@@ -1352,7 +1352,7 @@ void hostif_ps_adhoc_set_request(ks_wlan_private *priv)
 }
 
 static
-void hostif_infrastructure_set_request(ks_wlan_private *priv)
+void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 {
 	struct hostif_infrastructure_set_request_t *pp;
 	uint16_t capability;
@@ -1415,7 +1415,7 @@ void hostif_infrastructure_set_request(ks_wlan_private *priv)
 	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)),NULL, NULL, NULL);
 }
 
-void hostif_infrastructure_set2_request(ks_wlan_private *priv)
+void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 {
 	struct hostif_infrastructure_set2_request_t *pp;
 	uint16_t capability;
@@ -1481,7 +1481,7 @@ void hostif_infrastructure_set2_request(ks_wlan_private *priv)
 }
 
 static
-void hostif_adhoc_set_request(ks_wlan_private *priv)
+void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 {
 	struct hostif_adhoc_set_request_t *pp;
 	uint16_t capability;
@@ -1524,7 +1524,7 @@ void hostif_adhoc_set_request(ks_wlan_private *priv)
 }
 
 static
-void hostif_adhoc_set2_request(ks_wlan_private *priv)
+void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 {
 	struct hostif_adhoc_set2_request_t *pp;
 	uint16_t capability;
@@ -1570,7 +1570,7 @@ void hostif_adhoc_set2_request(ks_wlan_private *priv)
 }
 
 static
-void hostif_stop_request( ks_wlan_private *priv )
+void hostif_stop_request( struct ks_wlan_private *priv )
 {
 	struct hostif_stop_request_t *pp;
 
@@ -1591,7 +1591,7 @@ void hostif_stop_request( ks_wlan_private *priv )
 }
 
 static
-void hostif_phy_information_request( ks_wlan_private *priv )
+void hostif_phy_information_request( struct ks_wlan_private *priv )
 {
 	struct hostif_phy_information_request_t *pp;
 
@@ -1619,7 +1619,7 @@ void hostif_phy_information_request( ks_wlan_private *priv )
 }
 
 static
-void hostif_power_mngmt_request( ks_wlan_private *priv, unsigned long mode,
+void hostif_power_mngmt_request( struct ks_wlan_private *priv, unsigned long mode,
 				 unsigned long wake_up, unsigned long receiveDTIMs )
 {
 	struct hostif_power_mngmt_request_t *pp;
@@ -1643,7 +1643,7 @@ void hostif_power_mngmt_request( ks_wlan_private *priv, unsigned long mode,
 }
 
 static
-void hostif_sleep_request( ks_wlan_private *priv, unsigned long mode)
+void hostif_sleep_request( struct ks_wlan_private *priv, unsigned long mode)
 {
 	struct hostif_sleep_request_t *pp;
 
@@ -1673,7 +1673,7 @@ void hostif_sleep_request( ks_wlan_private *priv, unsigned long mode)
 
 
 static
-void hostif_bss_scan_request( ks_wlan_private *priv, unsigned long scan_type , uint8_t *scan_ssid, uint8_t scan_ssid_len)
+void hostif_bss_scan_request( struct ks_wlan_private *priv, unsigned long scan_type , uint8_t *scan_ssid, uint8_t scan_ssid_len)
 {
 	struct hostif_bss_scan_request_t *pp;
 
@@ -1727,7 +1727,7 @@ void hostif_bss_scan_request( ks_wlan_private *priv, unsigned long scan_type , u
 }
 
 static
-void hostif_mic_failure_request( ks_wlan_private *priv, unsigned short failure_count,
+void hostif_mic_failure_request( struct ks_wlan_private *priv, unsigned short failure_count,
 				 unsigned short timer )
 {
 	struct hostif_mic_failure_request_t *pp;
@@ -1750,7 +1750,7 @@ void hostif_mic_failure_request( ks_wlan_private *priv, unsigned short failure_c
 }
 
 /* Device I/O Recieve indicate */
-static void devio_rec_ind(ks_wlan_private *priv, unsigned char *p, unsigned int size)
+static void devio_rec_ind(struct ks_wlan_private *priv, unsigned char *p, unsigned int size)
 {
 	if (priv->device_open_status) {
 		spin_lock(&priv->dev_read_lock); /* request spin lock */
@@ -1772,7 +1772,7 @@ static void devio_rec_ind(ks_wlan_private *priv, unsigned char *p, unsigned int
 	}
 }
 
-void hostif_receive( ks_wlan_private *priv, unsigned char *p, unsigned int size )
+void hostif_receive( struct ks_wlan_private *priv, unsigned char *p, unsigned int size )
 {
 	DPRINTK(4,"\n");
 
@@ -1788,7 +1788,7 @@ void hostif_receive( ks_wlan_private *priv, unsigned char *p, unsigned int size
 
 
 static
-void hostif_sme_set_wep(ks_wlan_private *priv, int type)
+void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 {
 	uint32_t val;
 	switch(type){
@@ -1844,7 +1844,7 @@ struct rsn_mode_t {
 } __attribute__((packed));
 
 static
-void hostif_sme_set_rsn(ks_wlan_private *priv, int type)
+void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 {
 	struct wpa_suite_t wpa_suite;
 	struct rsn_mode_t rsn_mode;
@@ -1991,7 +1991,7 @@ void hostif_sme_set_rsn(ks_wlan_private *priv, int type)
 }
 
 static
-void hostif_sme_mode_setup(ks_wlan_private *priv)
+void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 {
 	unsigned char rate_size;
 	unsigned char rate_octet[RATE_SET_MAX_SIZE];
@@ -2097,7 +2097,7 @@ void hostif_sme_mode_setup(ks_wlan_private *priv)
 }
 
 static
-void hostif_sme_multicast_set(ks_wlan_private *priv)
+void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 {
 
         struct net_device *dev = priv->net_dev;
@@ -2146,7 +2146,7 @@ void hostif_sme_multicast_set(ks_wlan_private *priv)
 }
 
 static
-void hostif_sme_powermgt_set(ks_wlan_private *priv)
+void hostif_sme_powermgt_set(struct ks_wlan_private *priv)
 {
 	unsigned long mode,wake_up,receiveDTIMs ;
 
@@ -2191,7 +2191,7 @@ void hostif_sme_powermgt_set(ks_wlan_private *priv)
 }
 
 static
-void hostif_sme_sleep_set(ks_wlan_private *priv)
+void hostif_sme_sleep_set(struct ks_wlan_private *priv)
 {
 	DPRINTK(3,"\n");
 	switch(priv->sleep_mode){
@@ -2209,7 +2209,7 @@ void hostif_sme_sleep_set(ks_wlan_private *priv)
 }
 
 static
-void hostif_sme_set_key(ks_wlan_private *priv, int type)
+void hostif_sme_set_key(struct ks_wlan_private *priv, int type)
 {
 	uint32_t val;
 	switch(type){
@@ -2265,7 +2265,7 @@ void hostif_sme_set_key(ks_wlan_private *priv, int type)
 }
 
 static
-void hostif_sme_set_pmksa(ks_wlan_private *priv)
+void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 {
 	struct pmk_cache_t {
 		uint16_t size;
@@ -2296,7 +2296,7 @@ void hostif_sme_set_pmksa(ks_wlan_private *priv)
 
 /* execute sme */
 static
-void hostif_sme_execute(ks_wlan_private *priv, int event)
+void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 {
 	uint32_t val;
 
@@ -2459,7 +2459,7 @@ void hostif_sme_execute(ks_wlan_private *priv, int event)
 static
 void hostif_sme_task( unsigned long dev )
 {
-	ks_wlan_private	*priv = (ks_wlan_private *)dev;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
 
 	DPRINTK(3,"\n");
 
@@ -2475,7 +2475,7 @@ void hostif_sme_task( unsigned long dev )
 }
 
 /* send to Station Management Entity module */
-void hostif_sme_enqueue(ks_wlan_private *priv, unsigned short event)
+void hostif_sme_enqueue(struct ks_wlan_private *priv, unsigned short event)
 {
 	DPRINTK(3,"\n");
 
@@ -2500,7 +2500,7 @@ void hostif_sme_enqueue(ks_wlan_private *priv, unsigned short event)
 
 }
 
-int hostif_init( ks_wlan_private *priv )
+int hostif_init( struct ks_wlan_private *priv )
 {
 	int rc=0;
 	int i;
@@ -2555,7 +2555,7 @@ int hostif_init( ks_wlan_private *priv )
 	return rc;
 }
 
-void hostif_exit( ks_wlan_private *priv )
+void hostif_exit( struct ks_wlan_private *priv )
 {
 	tasklet_kill(&priv->sme_task);
 	return;

commit f88e6d3317907b93d7e8cbdbc0e26012cc1b1a48
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:22 2016 +0200

    staging: ks7010: really iterate over multicast addresses
    
    The loop variable was defined but not really used. Fix this.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 367d487cef1b..b0a0a53d3a00 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2105,7 +2105,7 @@ void hostif_sme_multicast_set(ks_wlan_private *priv)
 	struct netdev_hw_addr *ha;
 	char	set_address[NIC_MAX_MCAST_LIST*ETH_ALEN];
 	unsigned long filter_type;
-	int i;
+	int i = 0;
 
 	DPRINTK(3,"\n");
 
@@ -2128,6 +2128,7 @@ void hostif_sme_multicast_set(ks_wlan_private *priv)
 			mc_count = netdev_mc_count(dev);
 			netdev_for_each_mc_addr(ha, dev) {
 				memcpy(&set_address[i*ETH_ALEN], ha->addr, ETH_ALEN);
+				i++;
 			}
 			priv->sme_i.sme_flag &= ~SME_MULTICAST;
 			hostif_mib_set_request(priv, LOCAL_MULTICAST_ADDRESS,

commit 564efd793545d245ed158e5855dbee9706864365
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:21 2016 +0200

    staging: ks7010: delete seperate debug header
    
    Move the one debug macro to the generic wlan header.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 146a1357909b..367d487cef1b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -13,7 +13,6 @@
  */
 
 #include "ks_wlan.h"
-#include "ks_debug.h"
 #include "ks_hostif.h"
 #include "eap_packet.h"
 #include "michael_mic.h"

commit 72bf750007297c33fe2331d2125118d4885367c2
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:17 2016 +0200

    staging: ks7010: remove code for old kernel versions
    
    No need to be backwards compatible.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 6bea699655ee..146a1357909b 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -2103,11 +2103,7 @@ void hostif_sme_multicast_set(ks_wlan_private *priv)
 
         struct net_device *dev = priv->net_dev;
 	int mc_count;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
 	struct netdev_hw_addr *ha;
-#else
-	struct dev_mc_list *mclist;
-#endif
 	char	set_address[NIC_MAX_MCAST_LIST*ETH_ALEN];
 	unsigned long filter_type;
 	int i;
@@ -2131,14 +2127,9 @@ void hostif_sme_multicast_set(ks_wlan_private *priv)
 	else {
 		if (priv->sme_i.sme_flag & SME_MULTICAST){
 			mc_count = netdev_mc_count(dev);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
 			netdev_for_each_mc_addr(ha, dev) {
 				memcpy(&set_address[i*ETH_ALEN], ha->addr, ETH_ALEN);
 			}
-#else
-			for (i = 0, mclist = dev->mc_list; mclist && i < mc_count; i++, mclist = mclist->next)
-				memcpy(&set_address[i*ETH_ALEN], mclist->dmi_addr, ETH_ALEN);
-#endif
 			priv->sme_i.sme_flag &= ~SME_MULTICAST;
 			hostif_mib_set_request(priv, LOCAL_MULTICAST_ADDRESS,
 					       (ETH_ALEN*mc_count), MIB_VALUE_TYPE_OSTRING, &set_address[0]);

commit 4ab274017bc31cea220a531358e8c3e2d08d87fc
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:16 2016 +0200

    staging: ks7010: remove checks for WIRELESS_EXT version
    
    We are by far newer than that anyhow.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 0295bb4921fa..6bea699655ee 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -22,12 +22,7 @@
 #include <linux/if_arp.h>
 
 /* Include Wireless Extension definition and check version */
-#ifndef WIRELESS_EXT
-#include <linux/wireless.h>
-#endif /* WIRELESS_EXT */
-#if WIRELESS_EXT > 12
 #include <net/iw_handler.h>	/* New driver API */
-#endif	/* WIRELESS_EXT > 12 */
 
 extern int ks_wlan_hw_tx(ks_wlan_private *priv, void *p, unsigned long size,
 			 void (*complete_handler)(void *arg1, void *arg2),
@@ -121,10 +116,8 @@ static
 int get_current_ap(ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 {
 	struct local_ap_t *ap;
-#if WIRELESS_EXT > 13
 	union iwreq_data wrqu;
 	struct net_device *netdev=priv->net_dev;
-#endif /* WIRELESS_EXT > 13 */
 	int rc=0;
 
 	DPRINTK(3,"\n");
@@ -190,7 +183,6 @@ int get_current_ap(ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 		ap->wpa_ie.size = 0;
 	}
 
-#if WIRELESS_EXT > 13
 	wrqu.data.length = 0;
 	wrqu.data.flags = 0;
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
@@ -203,7 +195,6 @@ int get_current_ap(ks_wlan_private *priv, struct link_ap_info_t *ap_info)
 			(unsigned char)wrqu.ap_addr.sa_data[4],(unsigned char)wrqu.ap_addr.sa_data[5]);
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);
 	}
-#endif
 	DPRINTK(4,"\n    Link AP\n");
 	DPRINTK(4,"    bssid=%02X:%02X:%02X:%02X:%02X:%02X\n \
    essid=%s\n    rate_set=%02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X\n    channel=%d\n \
@@ -338,9 +329,7 @@ void hostif_data_indication(ks_wlan_private *priv)
 	struct ieee802_1x_hdr *aa1x_hdr;
 	struct wpa_eapol_key *eap_key;
 	struct michel_mic_t michel_mic;
-#if WIRELESS_EXT > 14
 	union iwreq_data wrqu;
-#endif /* WIRELESS_EXT > 14 */
 
 	DPRINTK(3,"\n");
 
@@ -412,7 +401,6 @@ void hostif_data_indication(ks_wlan_private *priv)
 							mic_failure->counter = 1;
 					}
 					priv->wpa.mic_failure.last_failure_time = now;
-#if WIRELESS_EXT > 14
 					/*  needed parameters: count, keyid, key type, TSC */
 					sprintf(buf, "MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
 						"%02x:%02x:%02x:%02x:%02x:%02x)",
@@ -424,7 +412,6 @@ void hostif_data_indication(ks_wlan_private *priv)
 					wrqu.data.length = strlen(buf);
 					DPRINTK(4,"IWEVENT:MICHAELMICFAILURE\n");
 					wireless_send_event(priv->net_dev, IWEVCUSTOM, &wrqu, buf);
-#endif /* WIRELESS_EXT > 14 */
 					return;
 				}
 			}
@@ -754,9 +741,7 @@ void hostif_connect_indication(ks_wlan_private *priv)
 	unsigned int tmp=0;
 	unsigned int old_status=priv->connect_status;
 	struct net_device *netdev=priv->net_dev;
-#if WIRELESS_EXT > 13
 	union iwreq_data wrqu0;
-#endif /* WIRELESS_EXT > 13 */
 	connect_code = get_WORD(priv);
 
 	switch(connect_code){
@@ -791,7 +776,6 @@ void hostif_connect_indication(ks_wlan_private *priv)
 	}
 	ks_wlan_do_power_save(priv);
 
-#if WIRELESS_EXT > 13
 	wrqu0.data.length = 0;
 	wrqu0.data.flags = 0;
 	wrqu0.ap_addr.sa_family = ARPHRD_ETHER;
@@ -802,7 +786,6 @@ void hostif_connect_indication(ks_wlan_private *priv)
 		DPRINTK(3,"disconnect :: scan_ind_count=%d\n",priv->scan_ind_count);
 		wireless_send_event(netdev, SIOCGIWAP, &wrqu0, NULL);
 	}
-#endif /* WIRELESS_EXT > 13 */
 	priv->scan_ind_count=0;
 }
 
@@ -904,7 +887,6 @@ void hostif_adhoc_set_confirm(ks_wlan_private *priv)
 static
 void hostif_associate_indication(ks_wlan_private *priv)
 {
-#if WIRELESS_EXT > 14
 	struct association_request_t *assoc_req;
 	struct association_response_t *assoc_resp;
 	unsigned char *pb;
@@ -944,29 +926,24 @@ void hostif_associate_indication(ks_wlan_private *priv)
 
 	DPRINTK(3,"IWEVENT:ASSOCINFO\n");
 	wireless_send_event(priv->net_dev, IWEVCUSTOM, &wrqu, buf);
-#endif /* WIRELESS_EXT > 14 */
 }
 
 static
 void hostif_bss_scan_confirm(ks_wlan_private *priv)
 {
 	unsigned int result_code;
-#if WIRELESS_EXT > 13
 	struct net_device *dev = priv->net_dev;
 	union iwreq_data wrqu;
-#endif /* WIRELESS_EXT > 13 */
 	result_code = get_DWORD(priv);
 	DPRINTK(2,"result=%d :: scan_ind_count=%d\n", result_code, priv->scan_ind_count);
 
 	priv->sme_i.sme_flag &= ~SME_AP_SCAN;
 	hostif_sme_enqueue(priv, SME_BSS_SCAN_CONFIRM);
 
-#if WIRELESS_EXT > 13
 	wrqu.data.length = 0;
 	wrqu.data.flags = 0;
 	DPRINTK(3,"IWEVENT: SCAN CONFIRM\n");
 	wireless_send_event(dev, SIOCGIWSCAN, &wrqu, NULL);
-#endif /* WIRELESS_EXT > 13 */
 	priv->scan_ind_count=0;
 }
 

commit 021873f650658fb1d8da5f3ee7d31eba40b21a93
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:14 2016 +0200

    staging: ks7010: remove non-SDIO code and #ifdefs
    
    I couldn't find any trace of code or even products using ks7010 with
    something else than SDIO. So, remove the conditionals.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index 402ddba400ff..0295bb4921fa 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -108,51 +108,12 @@ int ks_wlan_do_power_save(ks_wlan_private *priv)
 
 	DPRINTK(4,"psstatus.status=%d\n",atomic_read(&priv->psstatus.status));
 
-#ifdef _SDIO_
 	if((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS){
 		hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
 	}
 	else{
 		priv->dev_state = DEVICE_STATE_READY;
 	}
-#else
-	if((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS){
-		switch(atomic_read(&priv->psstatus.status)){
-		case PS_ACTIVE_SET:
-		case PS_WAKEUP:
-		case PS_SAVE_SET:
-		case PS_SNOOZE:
-			break;
-		case PS_CONF_WAIT:
-			atomic_set(&priv->psstatus.confirm_wait,0);
-			break;
-		case PS_NONE:
-		default:
-			hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
-			break;
-		}
-
-	}
-	else{
-		switch(atomic_read(&priv->psstatus.status)){
-		case PS_ACTIVE_SET:
-		case PS_WAKEUP:
-		case PS_SAVE_SET:
-			break;
-		case PS_CONF_WAIT:
-			atomic_set(&priv->psstatus.confirm_wait,0);
-			atomic_set(&priv->psstatus.status, PS_WAKEUP);
-			break;
-		case PS_SNOOZE:
-			ks_wlan_hw_power_save(priv);
-			break;
-		case PS_NONE:
-		default:
-			hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
-			break;
-		}
-	}
-#endif
 	return rc;
 }
 
@@ -750,17 +711,11 @@ void hostif_power_mngmt_confirm(ks_wlan_private *priv)
 
 	if(priv->reg.powermgt > POWMGT_ACTIVE_MODE &&
 	   priv->reg.operation_mode == MODE_INFRASTRUCTURE){
-#if !defined(_SDIO_)
-		atomic_set(&priv->psstatus.status,PS_SAVE_SET);
-#endif
 		atomic_set(&priv->psstatus.confirm_wait, 0);
 		priv->dev_state = DEVICE_STATE_SLEEP;
 		ks_wlan_hw_power_save(priv);
 	}else{
 		priv->dev_state = DEVICE_STATE_READY;
-#if !defined(_SDIO_)
-		atomic_set(&priv->psstatus.status,PS_ACTIVE_SET);
-#endif
 	}
 
 }
@@ -833,9 +788,6 @@ void hostif_connect_indication(ks_wlan_private *priv)
 		/* for power save */
 		atomic_set(&priv->psstatus.snooze_guard, 0);
 		atomic_set(&priv->psstatus.confirm_wait,0);
-#if !defined(_SDIO_)
-		atomic_set(&priv->psstatus.status, PS_NONE);
-#endif
 	}
 	ks_wlan_do_power_save(priv);
 
@@ -894,10 +846,8 @@ void hostif_stop_confirm(ks_wlan_private *priv)
 	union iwreq_data wrqu0;
 
 	DPRINTK(3,"\n");
-#ifdef _SDIO_
 	if(priv->dev_state == DEVICE_STATE_SLEEP)
 		priv->dev_state = DEVICE_STATE_READY;
-#endif
 
 	/* disconnect indication */
 	if( (priv->connect_status & CONNECT_STATUS_MASK)== CONNECT_STATUS){
@@ -1178,9 +1128,6 @@ int hostif_data_request(ks_wlan_private *priv, struct sk_buff *packet)
 	if(atomic_read(&priv->psstatus.status)==PS_SNOOZE){ /* power save wakeup */
 		if(!netif_queue_stopped(priv->net_dev))
 			netif_stop_queue(priv->net_dev);
-#if !defined(_SDIO_)
-		schedule_work(&priv->ks_wlan_wakeup_task);
-#endif
 	}
 
 	DPRINTK(4, "skb_buff length=%d\n", packet_len);
@@ -1302,14 +1249,10 @@ int hostif_data_request(ks_wlan_private *priv, struct sk_buff *packet)
 	return result;
 }
 
-#if defined(_SPI_)
-#define ps_confirm_wait_inc(priv)
-#else
 #define ps_confirm_wait_inc(priv)  do{if(atomic_read(&priv->psstatus.status) > PS_ACTIVE_SET){ \
                                                   atomic_inc(&priv->psstatus.confirm_wait); \
                                                   /* atomic_set(&priv->psstatus.status, PS_CONF_WAIT);*/ \
                                       } }while(0)
-#endif
 
 static
 void hostif_mib_get_request( ks_wlan_private *priv, unsigned long mib_attribute)
@@ -2509,9 +2452,6 @@ void hostif_sme_execute(ks_wlan_private *priv, int event)
 		/* for power save */
 		atomic_set(&priv->psstatus.snooze_guard, 0);
 		atomic_set(&priv->psstatus.confirm_wait,0);
-#if !defined(_SDIO_)
-		atomic_set(&priv->psstatus.status, PS_NONE);
-#endif
 		if ( priv->dev_state == DEVICE_STATE_PREINIT ){
 			priv->dev_state = DEVICE_STATE_INIT;
 		}
@@ -2571,16 +2511,6 @@ void hostif_sme_enqueue(ks_wlan_private *priv, unsigned short event)
 {
 	DPRINTK(3,"\n");
 
-#if !defined(_SDIO_)
-	if(atomic_read(&priv->psstatus.status)==PS_SNOOZE && event < SME_START_CONFIRM){ /* power save wakeup*/
-		schedule_work(&priv->ks_wlan_wakeup_task);
-		if(atomic_read(&priv->sme_task.count) <= 0){
-			/* schedule_work(&priv->ks_wlan_wakeup_task); */
-			DPRINTK(4,"sme task disable.\n");
-			tasklet_disable(&priv->sme_task);
-		}
-	}
-#endif
 
 
 	/* enqueue sme event */

commit 13a9930d15b424ab7d3b906af8ba7ff8c409edfe
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:13 2016 +0200

    staging: ks7010: add driver from Nanonote extra-repository
    
    See the TODO for details where this driver came from. Only a few minor
    changes were made to make the driver suitable for staging:
    
    * updated Kconfig help text and dependencies
    * added TODO
    * removed two __DATE__ and __TIME__ printouts to allow reproducible builds
    * added to staging main Kconfig + Makefile
    
    Tested on a Renesas Salvator-X board with a Spectec SDW-823 card. I
    could connect to a WPA-protected network.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
new file mode 100644
index 000000000000..402ddba400ff
--- /dev/null
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -0,0 +1,2665 @@
+/*
+ *   Driver for KeyStream wireless LAN cards.
+ *
+ *   ks_hostif.c
+ *   $Id: ks_hostif.c 996 2009-09-14 02:54:21Z sekine $
+ *
+ *   Copyright (C) 2005-2008 KeyStream Corp.
+ *   Copyright (C) 2009 Renesas Technology Corp.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it undr the terms of the GNU General Public License version 2 as
+ *   published by the Free Sotware Foundation.
+ */
+
+#include "ks_wlan.h"
+#include "ks_debug.h"
+#include "ks_hostif.h"
+#include "eap_packet.h"
+#include "michael_mic.h"
+
+#include <linux/if_ether.h>
+#include <linux/if_arp.h>
+
+/* Include Wireless Extension definition and check version */
+#ifndef WIRELESS_EXT
+#include <linux/wireless.h>
+#endif /* WIRELESS_EXT */
+#if WIRELESS_EXT > 12
+#include <net/iw_handler.h>	/* New driver API */
+#endif	/* WIRELESS_EXT > 12 */
+
+extern int ks_wlan_hw_tx(ks_wlan_private *priv, void *p, unsigned long size,
+			 void (*complete_handler)(void *arg1, void *arg2),
+			 void *arg1, void *arg2 );
+extern void send_packet_complete(void *, void *);
+
+extern void ks_wlan_hw_wakeup_request(ks_wlan_private *priv);
+extern int ks_wlan_hw_power_save(ks_wlan_private *priv);
+
+/* macro */
+#define inc_smeqhead(priv) \
+        ( priv->sme_i.qhead = (priv->sme_i.qhead + 1) % SME_EVENT_BUFF_SIZE )
+#define inc_smeqtail(priv) \
+        ( priv->sme_i.qtail = (priv->sme_i.qtail + 1) % SME_EVENT_BUFF_SIZE )
+#define cnt_smeqbody(priv) \
+        (((priv->sme_i.qtail + SME_EVENT_BUFF_SIZE) - (priv->sme_i.qhead)) % SME_EVENT_BUFF_SIZE )
+
+#define KS_WLAN_MEM_FLAG (GFP_ATOMIC)
+
+static
+inline u8 get_BYTE(ks_wlan_private *priv)
+{
+	u8 data;
+	data = *(priv->rxp)++;
+	/* length check in advance ! */
+	--(priv->rx_size);
+	return data;
+}
+
+static
+inline u16 get_WORD(ks_wlan_private *priv)
+{
+	u16 data;
+	data  = (get_BYTE(priv) & 0xff);
+	data |= ((get_BYTE(priv) << 8) & 0xff00);
+	return data;
+}
+
+static
+inline u32 get_DWORD(ks_wlan_private *priv)
+{
+	u32 data;
+	data  = (get_BYTE(priv) & 0xff);
+	data |= ((get_BYTE(priv) << 8) & 0x0000ff00);
+	data |= ((get_BYTE(priv) << 16) & 0x00ff0000);
+	data |= ((get_BYTE(priv) << 24) & 0xff000000);
+	return data;
+}
+
+void ks_wlan_hw_wakeup_task(struct work_struct *work)
+{
+	ks_wlan_private *priv = container_of(work, struct ks_wlan_private, ks_wlan_wakeup_task);
+	int ps_status = atomic_read(&priv->psstatus.status);
+
+	if(ps_status==PS_SNOOZE){
+		ks_wlan_hw_wakeup_request(priv);
+		if(!wait_for_completion_interruptible_timeout(&priv->psstatus.wakeup_wait,HZ/50)){ /* 20ms timeout */
+			DPRINTK(1,"wake up timeout !!!\n");
+			schedule_work(&priv->ks_wlan_wakeup_task);
+			return;
+		}
+	}
+	else{
+		DPRINTK(1,"ps_status=%d\n",ps_status);
+	}
+
+	/* power save */
+	if(atomic_read(&priv->sme_task.count) > 0){
+		DPRINTK(4,"sme task enable.\n");
+		tasklet_enable(&priv->sme_task);
+	}
+}
+
+static
+int ks_wlan_do_power_save(ks_wlan_private *priv)
+{
+	int rc=0;
+
+	DPRINTK(4,"psstatus.status=%d\n",atomic_read(&priv->psstatus.status));
+
+#ifdef _SDIO_
+	if((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS){
+		hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
+	}
+	else{
+		priv->dev_state = DEVICE_STATE_READY;
+	}
+#else
+	if((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS){
+		switch(atomic_read(&priv->psstatus.status)){
+		case PS_ACTIVE_SET:
+		case PS_WAKEUP:
+		case PS_SAVE_SET:
+		case PS_SNOOZE:
+			break;
+		case PS_CONF_WAIT:
+			atomic_set(&priv->psstatus.confirm_wait,0);
+			break;
+		case PS_NONE:
+		default:
+			hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
+			break;
+		}
+
+	}
+	else{
+		switch(atomic_read(&priv->psstatus.status)){
+		case PS_ACTIVE_SET:
+		case PS_WAKEUP:
+		case PS_SAVE_SET:
+			break;
+		case PS_CONF_WAIT:
+			atomic_set(&priv->psstatus.confirm_wait,0);
+			atomic_set(&priv->psstatus.status, PS_WAKEUP);
+			break;
+		case PS_SNOOZE:
+			ks_wlan_hw_power_save(priv);
+			break;
+		case PS_NONE:
+		default:
+			hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
+			break;
+		}
+	}
+#endif
+	return rc;
+}
+
+static
+int get_current_ap(ks_wlan_private *priv, struct link_ap_info_t *ap_info)
+{
+	struct local_ap_t *ap;
+#if WIRELESS_EXT > 13
+	union iwreq_data wrqu;
+	struct net_device *netdev=priv->net_dev;
+#endif /* WIRELESS_EXT > 13 */
+	int rc=0;
+
+	DPRINTK(3,"\n");
+	ap = &(priv->current_ap);
+
+	if((priv->connect_status & CONNECT_STATUS_MASK)== DISCONNECT_STATUS){
+		memset(ap,0,sizeof(struct local_ap_t));
+		return 1;
+	}
+
+	/* bssid */
+	memcpy(&(ap->bssid[0]),&(ap_info->bssid[0]),ETH_ALEN);
+	/* essid */
+	memcpy(&(ap->ssid.body[0]),&(priv->reg.ssid.body[0]),priv->reg.ssid.size);
+	ap->ssid.size = priv->reg.ssid.size;
+	/* rate_set */
+	memcpy(&(ap->rate_set.body[0]),&(ap_info->rate_set.body[0]),ap_info->rate_set.size);
+	ap->rate_set.size = ap_info->rate_set.size;
+	if(ap_info->ext_rate_set.size){
+		/* rate_set */
+		memcpy(&(ap->rate_set.body[ap->rate_set.size]),
+		       &(ap_info->ext_rate_set.body[0]),
+		       ap_info->ext_rate_set.size);
+		ap->rate_set.size += ap_info->ext_rate_set.size;
+	}
+	/* channel */
+	ap->channel = ap_info->ds_parameter.channel;
+	/* rssi */
+	ap->rssi = ap_info->rssi;
+	/* sq */
+	ap->sq = ap_info->sq;
+	/* noise */
+	ap->noise = ap_info->noise;
+	/* capability */
+	ap->capability = ap_info->capability;
+	/* rsn */
+	if((ap_info->rsn_mode & RSN_MODE_WPA2) && (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)){
+		ap->rsn_ie.id = 0x30;
+		if(ap_info->rsn.size <= RSN_IE_BODY_MAX){
+			ap->rsn_ie.size = ap_info->rsn.size;
+			memcpy(&(ap->rsn_ie.body[0]),&(ap_info->rsn.body[0]),ap_info->rsn.size);
+		}
+		else{
+			ap->rsn_ie.size = RSN_IE_BODY_MAX;
+			memcpy(&(ap->rsn_ie.body[0]),&(ap_info->rsn.body[0]),RSN_IE_BODY_MAX);
+		}
+	}
+	else if((ap_info->rsn_mode & RSN_MODE_WPA) && (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA)){
+		ap->wpa_ie.id = 0xdd;
+		if(ap_info->rsn.size <= RSN_IE_BODY_MAX){
+			ap->wpa_ie.size = ap_info->rsn.size;
+			memcpy(&(ap->wpa_ie.body[0]),&(ap_info->rsn.body[0]),ap_info->rsn.size);
+		}
+		else{
+			ap->wpa_ie.size = RSN_IE_BODY_MAX;
+			memcpy(&(ap->wpa_ie.body[0]),&(ap_info->rsn.body[0]),RSN_IE_BODY_MAX);
+		}
+	}
+	else{
+		ap->rsn_ie.id = 0;
+		ap->rsn_ie.size = 0;
+		ap->wpa_ie.id = 0;
+		ap->wpa_ie.size = 0;
+	}
+
+#if WIRELESS_EXT > 13
+	wrqu.data.length = 0;
+	wrqu.data.flags = 0;
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	if((priv->connect_status & CONNECT_STATUS_MASK)==CONNECT_STATUS){
+		memcpy(wrqu.ap_addr.sa_data,
+		       &(priv->current_ap.bssid[0]), ETH_ALEN);
+		DPRINTK(3,"IWEVENT: connect bssid=%02x:%02x:%02x:%02x:%02x:%02x\n",
+			(unsigned char)wrqu.ap_addr.sa_data[0],(unsigned char)wrqu.ap_addr.sa_data[1],
+			(unsigned char)wrqu.ap_addr.sa_data[2],(unsigned char)wrqu.ap_addr.sa_data[3],
+			(unsigned char)wrqu.ap_addr.sa_data[4],(unsigned char)wrqu.ap_addr.sa_data[5]);
+		wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);
+	}
+#endif
+	DPRINTK(4,"\n    Link AP\n");
+	DPRINTK(4,"    bssid=%02X:%02X:%02X:%02X:%02X:%02X\n \
+   essid=%s\n    rate_set=%02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X\n    channel=%d\n \
+   rssi=%d\n    sq=%d\n    capability=%04X\n",
+		ap->bssid[0],ap->bssid[1],ap->bssid[2],ap->bssid[3],ap->bssid[4],
+		ap->bssid[5],&(ap->ssid.body[0]),ap->rate_set.body[0],ap->rate_set.body[1],
+		ap->rate_set.body[2],ap->rate_set.body[3],ap->rate_set.body[4],
+		ap->rate_set.body[5],ap->rate_set.body[6],ap->rate_set.body[7],
+		ap->channel,ap->rssi,ap->sq,ap->capability);
+	DPRINTK(4,"\n    Link AP\n    rsn.mode=%d\n    rsn.size=%d\n",
+		ap_info->rsn_mode,ap_info->rsn.size);
+	DPRINTK(4,"\n    ext_rate_set_size=%d\n    rate_set_size=%d\n",
+		ap_info->ext_rate_set.size,ap_info->rate_set.size);
+
+
+	return rc;
+}
+
+static
+int get_ap_information(ks_wlan_private *priv, struct ap_info_t *ap_info, struct local_ap_t *ap)
+{
+	unsigned char *bp;
+	int bsize,offset;
+	int rc=0;
+
+	DPRINTK(3,"\n");
+	memset(ap,0,sizeof(struct local_ap_t));
+
+	/* bssid */
+	memcpy(&(ap->bssid[0]),&(ap_info->bssid[0]),ETH_ALEN);
+	/* rssi */
+	ap->rssi = ap_info->rssi;
+	/* sq */
+	ap->sq = ap_info->sq;
+	/* noise */
+	ap->noise = ap_info->noise;
+	/* capability */
+	ap->capability = ap_info->capability;
+	/* channel */
+	ap->channel = ap_info->ch_info;
+
+	bp = &(ap_info->body[0]);
+	bsize = ap_info->body_size;
+	offset = 0;
+
+	while(bsize > offset){
+		/* DPRINTK(4, "Element ID=%d \n",*bp); */
+		switch(*bp){
+		case 0: /* ssid */
+			if(*(bp+1) <= SSID_MAX_SIZE){
+				ap->ssid.size = *(bp+1);
+			}
+			else {
+				DPRINTK(1, "size over :: ssid size=%d \n",*(bp+1));
+				ap->ssid.size = SSID_MAX_SIZE;
+			}
+			memcpy(&(ap->ssid.body[0]),bp+2,ap->ssid.size);
+			break;
+		case 1: /* rate */
+		case 50: /* ext rate */
+			if((*(bp+1) + ap->rate_set.size) <= RATE_SET_MAX_SIZE){
+				memcpy(&(ap->rate_set.body[ap->rate_set.size]),bp+2,*(bp+1));
+				ap->rate_set.size += *(bp+1);
+			}
+			else{
+				DPRINTK(1, "size over :: rate size=%d \n",
+					(*(bp+1) + ap->rate_set.size));
+				memcpy(&(ap->rate_set.body[ap->rate_set.size]),bp+2,
+				       RATE_SET_MAX_SIZE - ap->rate_set.size);
+				ap->rate_set.size += (RATE_SET_MAX_SIZE - ap->rate_set.size);
+			}
+			break;
+		case 3: /* DS parameter */
+			break;
+		case 48: /* RSN(WPA2) */
+			ap->rsn_ie.id = *bp;
+			if(*(bp+1) <= RSN_IE_BODY_MAX){
+				ap->rsn_ie.size = *(bp+1);
+			}else{
+				DPRINTK(1, "size over :: rsn size=%d \n",*(bp+1));
+				ap->rsn_ie.size = RSN_IE_BODY_MAX;
+			}
+			memcpy(&(ap->rsn_ie.body[0]),bp+2,ap->rsn_ie.size);
+			break;
+		case 221: /* WPA */
+			if(!memcmp(bp+2, "\x00\x50\xf2\x01", 4)){ /* WPA OUI check */
+				ap->wpa_ie.id = *bp;
+				if(*(bp+1) <= RSN_IE_BODY_MAX){
+					ap->wpa_ie.size = *(bp+1);
+				}else{
+					DPRINTK(1, "size over :: wpa size=%d \n",*(bp+1));
+					ap->wpa_ie.size = RSN_IE_BODY_MAX;
+				}
+				memcpy(&(ap->wpa_ie.body[0]),bp+2,ap->wpa_ie.size);
+			}
+			break;
+
+		case 2: /* FH parameter */
+		case 4: /* CF parameter */
+		case 5: /* TIM */
+		case 6: /* IBSS parameter */
+		case 7: /* Country */
+		case 42: /* ERP information */
+		case 47: /* Reserve ID 47 Broadcom AP */
+			break;
+		default:
+			DPRINTK(4, "unknown Element ID=%d \n",*bp);
+			break;
+		}
+		offset += 2;		/* id & size field */
+		offset += *(bp+1);	/* +size offset */
+		bp += (*(bp+1) + 2);	/* pointer update */
+	}
+
+	return rc;
+}
+
+static
+void hostif_data_indication(ks_wlan_private *priv)
+{
+	unsigned int	rx_ind_size;	/* indicate data size */
+	struct sk_buff *skb;
+	unsigned short   auth_type;
+	unsigned char	temp[256];
+
+	unsigned char	RecvMIC[8];
+	char buf[128];
+	struct ether_hdr *eth_hdr;
+	unsigned short eth_proto;
+	unsigned long now;
+	struct mic_failure_t *mic_failure;
+	struct ieee802_1x_hdr *aa1x_hdr;
+	struct wpa_eapol_key *eap_key;
+	struct michel_mic_t michel_mic;
+#if WIRELESS_EXT > 14
+	union iwreq_data wrqu;
+#endif /* WIRELESS_EXT > 14 */
+
+	DPRINTK(3,"\n");
+
+	/* min length check */
+	if (priv->rx_size <= ETH_HLEN) {
+		DPRINTK(3,"rx_size = %d\n", priv->rx_size);
+		priv->nstats.rx_errors++;
+		return;
+	}
+
+	auth_type = get_WORD(priv); /* AuthType */
+	get_WORD(priv); /* Reserve Area */
+
+	eth_hdr = (struct ether_hdr *)(priv->rxp);
+	eth_proto = ntohs(eth_hdr->h_proto);
+	DPRINTK(3,"ether protocol = %04X\n", eth_proto);
+
+	/* source address check */
+	if (!memcmp(&priv->eth_addr[0],eth_hdr->h_source, ETH_ALEN)){
+		DPRINTK(1, "invalid : source is own mac address !!\n");
+		DPRINTK(1, "eth_hdrernet->h_dest=%02X:%02X:%02X:%02X:%02X:%02X\n",
+			eth_hdr->h_source[0],eth_hdr->h_source[1],eth_hdr->h_source[2],
+			eth_hdr->h_source[3],eth_hdr->h_source[4],eth_hdr->h_source[5]);
+		priv->nstats.rx_errors++;
+		return;
+	}
+
+	/*  for WPA */
+	if (auth_type != TYPE_DATA && priv->wpa.rsn_enabled){
+		if(memcmp(&eth_hdr->h_source[0],&priv->eth_addr[0],ETH_ALEN)){ /* source address check */
+			if (eth_hdr->h_dest_snap != eth_hdr->h_source_snap){
+				DPRINTK(1,"invalid data format\n");
+				priv->nstats.rx_errors++;
+				return;
+			}
+			if(((auth_type==TYPE_PMK1 && priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP)||
+			    (auth_type==TYPE_GMK1 && priv->wpa.group_suite == IW_AUTH_CIPHER_TKIP)||
+			    (auth_type==TYPE_GMK2 && priv->wpa.group_suite == IW_AUTH_CIPHER_TKIP))
+			   && priv->wpa.key[auth_type-1].key_len){
+				DPRINTK(4,"TKIP: protocol=%04X: size=%u\n", eth_proto, priv->rx_size);
+				/* MIC save */
+				memcpy(&RecvMIC[0], (priv->rxp)+((priv->rx_size)-8), 8);
+				priv->rx_size = priv->rx_size - 8;
+				if(auth_type > 0 && auth_type < 4){ /* auth_type check */
+					MichaelMICFunction(&michel_mic,
+							   (uint8_t*)priv->wpa.key[auth_type-1].rx_mic_key,
+							   (uint8_t*)priv->rxp,
+							   (int)priv->rx_size,
+							   (uint8_t)0, /* priority */
+							   (uint8_t*)michel_mic.Result);
+				}
+				if(memcmp(michel_mic.Result, RecvMIC, 8)){
+					now = jiffies;
+					mic_failure = &priv->wpa.mic_failure;
+					/* MIC FAILURE */
+					if(mic_failure->last_failure_time &&
+					   (now - mic_failure->last_failure_time)/HZ >= 60){
+						mic_failure->failure=0;
+					}
+					DPRINTK(4,"MIC FAILURE \n");
+					if(mic_failure->failure==0){
+						mic_failure->failure=1;
+						mic_failure->counter=0;
+					}else if(mic_failure->failure==1){
+						mic_failure->failure=2;
+						mic_failure->counter =
+							(uint16_t)((now - mic_failure->last_failure_time)/HZ);
+						if(!mic_failure->counter) /* mic_failure counter value range 1-60 */
+							mic_failure->counter = 1;
+					}
+					priv->wpa.mic_failure.last_failure_time = now;
+#if WIRELESS_EXT > 14
+					/*  needed parameters: count, keyid, key type, TSC */
+					sprintf(buf, "MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
+						"%02x:%02x:%02x:%02x:%02x:%02x)",
+						auth_type-1, eth_hdr->h_dest[0] & 0x01 ? "broad" : "uni",
+						eth_hdr->h_source[0],eth_hdr->h_source[1],
+						eth_hdr->h_source[2],eth_hdr->h_source[3],
+						eth_hdr->h_source[4],eth_hdr->h_source[5]);
+					memset(&wrqu, 0, sizeof(wrqu));
+					wrqu.data.length = strlen(buf);
+					DPRINTK(4,"IWEVENT:MICHAELMICFAILURE\n");
+					wireless_send_event(priv->net_dev, IWEVCUSTOM, &wrqu, buf);
+#endif /* WIRELESS_EXT > 14 */
+					return;
+				}
+			}
+		}
+	}
+
+	if((priv->connect_status & FORCE_DISCONNECT)||
+	   priv->wpa.mic_failure.failure==2){
+		return;
+	}
+
+	/* check 13th byte at rx data */
+	switch (*(priv->rxp+12)) {
+	case 0xAA: /* SNAP */
+		rx_ind_size = priv->rx_size - 6;
+		skb = dev_alloc_skb (rx_ind_size);
+		DPRINTK(4,"SNAP, rx_ind_size = %d\n", rx_ind_size);
+
+		if(skb) {
+		        memcpy(skb_put(skb,12),priv->rxp,12); /* 8802/FDDI MAC copy */
+		        /* (SNAP+UI..) skip */
+			memcpy(skb_put(skb,rx_ind_size-12),priv->rxp+18,rx_ind_size-12); /* copy after Type */
+
+			aa1x_hdr=(struct ieee802_1x_hdr *)(priv->rxp+20);
+			if(aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY  && priv->wpa.rsn_enabled){
+				eap_key = (struct wpa_eapol_key *)(aa1x_hdr+1);
+				atomic_set(&priv->psstatus.snooze_guard, 1);
+			}
+
+			/* rx indication */
+			skb->dev = priv->net_dev;
+			skb->protocol = eth_type_trans (skb, skb->dev);
+			priv->nstats.rx_packets++;
+			priv->nstats.rx_bytes += rx_ind_size;
+			skb->dev->last_rx = jiffies;
+			netif_rx (skb);
+		} else {
+			printk (KERN_WARNING"%s: Memory squeeze, dropping packet.\n",skb->dev->name);
+			priv->nstats.rx_dropped++;
+		}
+		break;
+	case 0xF0: /* NETBEUI/NetBIOS */
+		rx_ind_size = (priv->rx_size + 2);
+		skb = dev_alloc_skb (rx_ind_size);
+		DPRINTK(3,"NETBEUI/NetBIOS rx_ind_size=%d\n", rx_ind_size);
+
+		if(skb) {
+		        memcpy(skb_put(skb,12),priv->rxp,12); /* 8802/FDDI MAC copy */
+
+			temp[0] = (((rx_ind_size-12) >> 8) & 0xff); /* NETBEUI size add */
+			temp[1] = ((rx_ind_size-12) & 0xff);
+			memcpy(skb_put(skb,2),temp,2);
+
+			memcpy(skb_put(skb,rx_ind_size-14),priv->rxp+12,rx_ind_size-14); /* copy after Type */
+
+			aa1x_hdr=(struct ieee802_1x_hdr *)(priv->rxp+14);
+			if(aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY && priv->wpa.rsn_enabled){
+				eap_key = (struct wpa_eapol_key *)(aa1x_hdr+1);
+				atomic_set(&priv->psstatus.snooze_guard, 1);
+			}
+
+			/* rx indication */
+			skb->dev = priv->net_dev;
+			skb->protocol = eth_type_trans (skb, skb->dev);
+			priv->nstats.rx_packets++;
+			priv->nstats.rx_bytes += rx_ind_size;
+			skb->dev->last_rx = jiffies;
+			netif_rx (skb);
+		} else {
+			printk (KERN_WARNING"%s: Memory squeeze, dropping packet.\n",skb->dev->name);
+			priv->nstats.rx_dropped++;
+		}
+		break;
+	default: /* other rx data */
+		DPRINTK(2,"invalid data format\n");
+		priv->nstats.rx_errors++;
+	}
+}
+
+static
+void hostif_mib_get_confirm(ks_wlan_private *priv)
+{
+	struct net_device *dev=priv->net_dev;
+	uint32_t	mib_status;
+	uint32_t	mib_attribute;
+	uint16_t	mib_val_size;
+	uint16_t	mib_val_type;
+
+	DPRINTK(3, "\n");
+
+	mib_status = get_DWORD(priv);		/* MIB status */
+	mib_attribute = get_DWORD(priv);		/* MIB atttibute */
+	mib_val_size = get_WORD(priv);		/* MIB value size */
+	mib_val_type = get_WORD(priv);		/* MIB value type */
+
+	if (mib_status != 0) {
+		/* in case of error */
+		DPRINTK(1, "attribute=%08X, status=%08X\n", mib_attribute, mib_status);
+		return;
+	}
+
+	switch (mib_attribute) {
+	case DOT11_MAC_ADDRESS:
+		/* MAC address */
+		DPRINTK(3," mib_attribute=DOT11_MAC_ADDRESS\n");
+		hostif_sme_enqueue(priv, SME_GET_MAC_ADDRESS);
+		memcpy(priv->eth_addr, priv->rxp, ETH_ALEN);
+		priv->mac_address_valid = 1;
+		dev->dev_addr[0] = priv->eth_addr[0];
+		dev->dev_addr[1] = priv->eth_addr[1];
+		dev->dev_addr[2] = priv->eth_addr[2];
+		dev->dev_addr[3] = priv->eth_addr[3];
+		dev->dev_addr[4] = priv->eth_addr[4];
+		dev->dev_addr[5] = priv->eth_addr[5];
+		dev->dev_addr[6] = 0x00;
+		dev->dev_addr[7] = 0x00;
+		printk(KERN_INFO "ks_wlan: MAC ADDRESS = %02x:%02x:%02x:%02x:%02x:%02x\n",
+		       priv->eth_addr[0],priv->eth_addr[1],priv->eth_addr[2],
+		       priv->eth_addr[3],priv->eth_addr[4],priv->eth_addr[5]);
+		break;
+	case DOT11_PRODUCT_VERSION:
+		/* firmware version */
+		DPRINTK(3," mib_attribute=DOT11_PRODUCT_VERSION\n");
+		priv->version_size = priv->rx_size;
+		memcpy(priv->firmware_version, priv->rxp, priv->rx_size);
+		priv->firmware_version[priv->rx_size] = '\0';
+	        printk(KERN_INFO "ks_wlan: firmware ver. = %s\n",priv->firmware_version);
+		hostif_sme_enqueue(priv, SME_GET_PRODUCT_VERSION);
+		/* wake_up_interruptible_all(&priv->confirm_wait); */
+		complete(&priv->confirm_wait);
+		break;
+	case LOCAL_GAIN:
+		memcpy(&priv->gain, priv->rxp, sizeof(priv->gain));
+	        DPRINTK(3, "TxMode=%d, RxMode=%d, TxGain=%d, RxGain=%d\n",
+			priv->gain.TxMode, priv->gain.RxMode, priv->gain.TxGain, priv->gain.RxGain);
+		break;
+	case LOCAL_EEPROM_SUM:
+		memcpy(&priv->eeprom_sum, priv->rxp, sizeof(priv->eeprom_sum));
+	        DPRINTK(1, "eeprom_sum.type=%x, eeprom_sum.result=%x\n", priv->eeprom_sum.type, priv->eeprom_sum.result);
+		if(priv->eeprom_sum.type == 0){
+			priv->eeprom_checksum = EEPROM_CHECKSUM_NONE;
+		}else if(priv->eeprom_sum.type == 1){
+			if(priv->eeprom_sum.result == 0){
+				priv->eeprom_checksum = EEPROM_NG;
+				printk("LOCAL_EEPROM_SUM NG\n");
+			}else if(priv->eeprom_sum.result == 1){
+				priv->eeprom_checksum = EEPROM_OK;
+			}
+		}else{
+			printk("LOCAL_EEPROM_SUM error!\n");
+		}
+		break;
+	default:
+		DPRINTK(1,"mib_attribute=%08x\n",(unsigned int)mib_attribute);
+		break;
+	}
+}
+
+static
+void hostif_mib_set_confirm(ks_wlan_private *priv)
+{
+	uint32_t	mib_status;	/* +04 MIB Status */
+	uint32_t	mib_attribute;	/* +08 MIB attribute */
+
+	DPRINTK(3,"\n");
+
+	mib_status	= get_DWORD(priv);	/* MIB Status */
+	mib_attribute	= get_DWORD(priv);	/* MIB attribute */
+
+	if (mib_status != 0) {
+		/* in case of error */
+		DPRINTK(1, "error :: attribute=%08X, status=%08X\n", mib_attribute, mib_status);
+	}
+
+	switch (mib_attribute) {
+	case DOT11_RTS_THRESHOLD:
+		hostif_sme_enqueue(priv, SME_RTS_THRESHOLD_CONFIRM);
+		break;
+	case DOT11_FRAGMENTATION_THRESHOLD:
+		hostif_sme_enqueue(priv, SME_FRAGMENTATION_THRESHOLD_CONFIRM);
+		break;
+	case DOT11_WEP_DEFAULT_KEY_ID:
+		if(!priv->wpa.wpa_enabled)
+			hostif_sme_enqueue(priv, SME_WEP_INDEX_CONFIRM);
+		break;
+	case DOT11_WEP_DEFAULT_KEY_VALUE1:
+		DPRINTK(2,"DOT11_WEP_DEFAULT_KEY_VALUE1:mib_status=%d\n",(int)mib_status);
+		if(priv->wpa.rsn_enabled)
+			hostif_sme_enqueue(priv, SME_SET_PMK_TSC);
+		else
+			hostif_sme_enqueue(priv, SME_WEP_KEY1_CONFIRM);
+		break;
+	case DOT11_WEP_DEFAULT_KEY_VALUE2:
+		DPRINTK(2,"DOT11_WEP_DEFAULT_KEY_VALUE2:mib_status=%d\n",(int)mib_status);
+		if(priv->wpa.rsn_enabled)
+			hostif_sme_enqueue(priv, SME_SET_GMK1_TSC);
+		else
+			hostif_sme_enqueue(priv, SME_WEP_KEY2_CONFIRM);
+		break;
+	case DOT11_WEP_DEFAULT_KEY_VALUE3:
+		DPRINTK(2,"DOT11_WEP_DEFAULT_KEY_VALUE3:mib_status=%d\n",(int)mib_status);
+		if(priv->wpa.rsn_enabled)
+			hostif_sme_enqueue(priv, SME_SET_GMK2_TSC);
+		else
+			hostif_sme_enqueue(priv, SME_WEP_KEY3_CONFIRM);
+		break;
+	case DOT11_WEP_DEFAULT_KEY_VALUE4:
+		DPRINTK(2,"DOT11_WEP_DEFAULT_KEY_VALUE4:mib_status=%d\n",(int)mib_status);
+		if(!priv->wpa.rsn_enabled)
+			hostif_sme_enqueue(priv, SME_WEP_KEY4_CONFIRM);
+		break;
+	case DOT11_PRIVACY_INVOKED:
+		if(!priv->wpa.rsn_enabled)
+			hostif_sme_enqueue(priv, SME_WEP_FLAG_CONFIRM);
+		break;
+	case DOT11_RSN_ENABLED:
+		DPRINTK(2,"DOT11_RSN_ENABLED:mib_status=%d\n",(int)mib_status);
+		hostif_sme_enqueue(priv, SME_RSN_ENABLED_CONFIRM);
+		break;
+	case LOCAL_RSN_MODE:
+		hostif_sme_enqueue(priv, SME_RSN_MODE_CONFIRM);
+		break;
+	case LOCAL_MULTICAST_ADDRESS:
+		hostif_sme_enqueue(priv, SME_MULTICAST_REQUEST);
+		break;
+	case LOCAL_MULTICAST_FILTER:
+		hostif_sme_enqueue(priv, SME_MULTICAST_CONFIRM);
+		break;
+	case LOCAL_CURRENTADDRESS:
+		priv->mac_address_valid = 1;
+		break;
+	case DOT11_RSN_CONFIG_MULTICAST_CIPHER:
+		DPRINTK(2,"DOT11_RSN_CONFIG_MULTICAST_CIPHER:mib_status=%d\n",(int)mib_status);
+		hostif_sme_enqueue(priv, SME_RSN_MCAST_CONFIRM);
+		break;
+	case DOT11_RSN_CONFIG_UNICAST_CIPHER:
+		DPRINTK(2,"DOT11_RSN_CONFIG_UNICAST_CIPHER:mib_status=%d\n",(int)mib_status);
+		hostif_sme_enqueue(priv, SME_RSN_UCAST_CONFIRM);
+		break;
+	case DOT11_RSN_CONFIG_AUTH_SUITE:
+		DPRINTK(2,"DOT11_RSN_CONFIG_AUTH_SUITE:mib_status=%d\n",(int)mib_status);
+		hostif_sme_enqueue(priv, SME_RSN_AUTH_CONFIRM);
+		break;
+	case DOT11_PMK_TSC:
+		DPRINTK(2,"DOT11_PMK_TSC:mib_status=%d\n",(int)mib_status);
+		break;
+	case DOT11_GMK1_TSC:
+		DPRINTK(2,"DOT11_GMK1_TSC:mib_status=%d\n",(int)mib_status);
+		if(atomic_read(&priv->psstatus.snooze_guard)){
+			atomic_set(&priv->psstatus.snooze_guard, 0);
+		}
+		break;
+	case DOT11_GMK2_TSC:
+		DPRINTK(2,"DOT11_GMK2_TSC:mib_status=%d\n",(int)mib_status);
+		if(atomic_read(&priv->psstatus.snooze_guard)){
+			atomic_set(&priv->psstatus.snooze_guard, 0);
+		}
+		break;
+	case LOCAL_PMK:
+		DPRINTK(2,"LOCAL_PMK:mib_status=%d\n",(int)mib_status);
+		break;
+	case LOCAL_GAIN:
+		DPRINTK(2,"LOCAL_GAIN:mib_status=%d\n",(int)mib_status);
+		break;
+#ifdef WPS
+	case LOCAL_WPS_ENABLE:
+		DPRINTK(2,"LOCAL_WPS_ENABLE:mib_status=%d\n",(int)mib_status);
+		break;
+	case LOCAL_WPS_PROBE_REQ:
+		DPRINTK(2,"LOCAL_WPS_PROBE_REQ:mib_status=%d\n",(int)mib_status);
+		break;
+#endif /* WPS */
+	case LOCAL_REGION:
+		DPRINTK(2,"LOCAL_REGION:mib_status=%d\n",(int)mib_status);
+	default :
+		break;
+	}
+}
+
+static
+void hostif_power_mngmt_confirm(ks_wlan_private *priv)
+{
+	DPRINTK(3,"\n");
+
+	if(priv->reg.powermgt > POWMGT_ACTIVE_MODE &&
+	   priv->reg.operation_mode == MODE_INFRASTRUCTURE){
+#if !defined(_SDIO_)
+		atomic_set(&priv->psstatus.status,PS_SAVE_SET);
+#endif
+		atomic_set(&priv->psstatus.confirm_wait, 0);
+		priv->dev_state = DEVICE_STATE_SLEEP;
+		ks_wlan_hw_power_save(priv);
+	}else{
+		priv->dev_state = DEVICE_STATE_READY;
+#if !defined(_SDIO_)
+		atomic_set(&priv->psstatus.status,PS_ACTIVE_SET);
+#endif
+	}
+
+}
+
+static
+void hostif_sleep_confirm(ks_wlan_private *priv)
+{
+	DPRINTK(3,"\n");
+
+	atomic_set(&priv->sleepstatus.doze_request,1);
+	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+}
+
+static
+void hostif_start_confirm(ks_wlan_private *priv)
+{
+#ifdef  WPS
+       union iwreq_data        wrqu;
+       wrqu.data.length = 0;
+       wrqu.data.flags = 0;
+       wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+       if((priv->connect_status & CONNECT_STATUS_MASK)== CONNECT_STATUS){
+               memset(wrqu.ap_addr.sa_data, '\0', ETH_ALEN);
+               DPRINTK(3,"IWEVENT: disconnect\n");
+               wireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);
+       }
+#endif
+	DPRINTK(3," scan_ind_count=%d\n",priv->scan_ind_count);
+	hostif_sme_enqueue(priv, SME_START_CONFIRM);
+}
+
+static
+void hostif_connect_indication(ks_wlan_private *priv)
+{
+	unsigned short connect_code;
+	unsigned int tmp=0;
+	unsigned int old_status=priv->connect_status;
+	struct net_device *netdev=priv->net_dev;
+#if WIRELESS_EXT > 13
+	union iwreq_data wrqu0;
+#endif /* WIRELESS_EXT > 13 */
+	connect_code = get_WORD(priv);
+
+	switch(connect_code){
+	case RESULT_CONNECT: /* connect */
+		DPRINTK(3,"connect :: scan_ind_count=%d\n",priv->scan_ind_count);
+		if(!(priv->connect_status & FORCE_DISCONNECT))
+			netif_carrier_on(netdev);
+		tmp = FORCE_DISCONNECT & priv->connect_status;
+		priv->connect_status = tmp + CONNECT_STATUS;
+		break;
+	case RESULT_DISCONNECT: /* disconnect */
+		DPRINTK(3,"disconnect :: scan_ind_count=%d\n",priv->scan_ind_count);
+		netif_carrier_off(netdev);
+		tmp = FORCE_DISCONNECT & priv->connect_status;
+		priv->connect_status = tmp + DISCONNECT_STATUS;
+		break;
+	default:
+		DPRINTK(1,"unknown connect_code=%d :: scan_ind_count=%d\n",
+			connect_code,priv->scan_ind_count);
+		netif_carrier_off(netdev);
+		tmp = FORCE_DISCONNECT & priv->connect_status;
+		priv->connect_status = tmp + DISCONNECT_STATUS;
+		break;
+	}
+
+	get_current_ap(priv, (struct link_ap_info_t *)priv->rxp);
+	if((priv->connect_status & CONNECT_STATUS_MASK)== CONNECT_STATUS &&
+	   (old_status & CONNECT_STATUS_MASK)==DISCONNECT_STATUS ){
+		/* for power save */
+		atomic_set(&priv->psstatus.snooze_guard, 0);
+		atomic_set(&priv->psstatus.confirm_wait,0);
+#if !defined(_SDIO_)
+		atomic_set(&priv->psstatus.status, PS_NONE);
+#endif
+	}
+	ks_wlan_do_power_save(priv);
+
+#if WIRELESS_EXT > 13
+	wrqu0.data.length = 0;
+	wrqu0.data.flags = 0;
+	wrqu0.ap_addr.sa_family = ARPHRD_ETHER;
+	if((priv->connect_status & CONNECT_STATUS_MASK)== DISCONNECT_STATUS &&
+	   (old_status & CONNECT_STATUS_MASK)==CONNECT_STATUS ){
+		memset(wrqu0.ap_addr.sa_data, '\0', ETH_ALEN);
+		DPRINTK(3,"IWEVENT: disconnect\n");
+		DPRINTK(3,"disconnect :: scan_ind_count=%d\n",priv->scan_ind_count);
+		wireless_send_event(netdev, SIOCGIWAP, &wrqu0, NULL);
+	}
+#endif /* WIRELESS_EXT > 13 */
+	priv->scan_ind_count=0;
+}
+
+static
+void hostif_scan_indication(ks_wlan_private *priv)
+{
+	int i;
+	struct ap_info_t *ap_info;
+
+	DPRINTK(3,"scan_ind_count = %d\n", priv->scan_ind_count);
+	ap_info = (struct ap_info_t *)(priv->rxp);
+
+	if(priv->scan_ind_count!=0){
+		for(i=0;i<priv->aplist.size;i++){ /* bssid check */
+			if(!memcmp(&(ap_info->bssid[0]),&(priv->aplist.ap[i].bssid[0]),ETH_ALEN)){
+				if(ap_info->frame_type == FRAME_TYPE_PROBE_RESP)
+					get_ap_information(priv,ap_info,&(priv->aplist.ap[i]));
+				return;
+			}
+		}
+	}
+	priv->scan_ind_count++;
+	if(priv->scan_ind_count < LOCAL_APLIST_MAX+1){
+		DPRINTK(4," scan_ind_count=%d :: aplist.size=%d\n", priv->scan_ind_count, priv->aplist.size);
+		get_ap_information(priv,(struct ap_info_t *)(priv->rxp),&(priv->aplist.ap[priv->scan_ind_count-1]));
+		priv->aplist.size = priv->scan_ind_count;
+	}
+	else{
+		DPRINTK(4," count over :: scan_ind_count=%d\n", priv->scan_ind_count);
+	}
+
+
+}
+
+static
+void hostif_stop_confirm(ks_wlan_private *priv)
+{
+	unsigned int tmp=0;
+	unsigned int old_status=priv->connect_status;
+	struct net_device *netdev=priv->net_dev;
+	union iwreq_data wrqu0;
+
+	DPRINTK(3,"\n");
+#ifdef _SDIO_
+	if(priv->dev_state == DEVICE_STATE_SLEEP)
+		priv->dev_state = DEVICE_STATE_READY;
+#endif
+
+	/* disconnect indication */
+	if( (priv->connect_status & CONNECT_STATUS_MASK)== CONNECT_STATUS){
+		netif_carrier_off(netdev);
+		tmp = FORCE_DISCONNECT & priv->connect_status;
+		priv->connect_status = tmp | DISCONNECT_STATUS;
+		printk("IWEVENT: disconnect\n");
+
+		wrqu0.data.length = 0;
+		wrqu0.data.flags = 0;
+		wrqu0.ap_addr.sa_family = ARPHRD_ETHER;
+		if((priv->connect_status & CONNECT_STATUS_MASK)== DISCONNECT_STATUS &&
+		   (old_status & CONNECT_STATUS_MASK)==CONNECT_STATUS ){
+			memset(wrqu0.ap_addr.sa_data, '\0', ETH_ALEN);
+			DPRINTK(3,"IWEVENT: disconnect\n");
+			printk("IWEVENT: disconnect\n");
+			DPRINTK(3,"disconnect :: scan_ind_count=%d\n",priv->scan_ind_count);
+			wireless_send_event(netdev, SIOCGIWAP, &wrqu0, NULL);
+		}
+		priv->scan_ind_count=0;
+	}
+
+	hostif_sme_enqueue(priv, SME_STOP_CONFIRM);
+}
+
+static
+void hostif_ps_adhoc_set_confirm(ks_wlan_private *priv)
+{
+	DPRINTK(3,"\n");
+	priv->infra_status = 0; /* infrastructure mode cancel */
+	hostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);
+
+}
+
+static
+void hostif_infrastructure_set_confirm(ks_wlan_private *priv)
+{
+	uint16_t result_code;
+	DPRINTK(3,"\n");
+	result_code = get_WORD(priv);
+	DPRINTK(3,"result code = %d\n",result_code);
+	priv->infra_status = 1; /* infrastructure mode set */
+	hostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);
+}
+
+static
+void hostif_adhoc_set_confirm(ks_wlan_private *priv)
+{
+	DPRINTK(3,"\n");
+	priv->infra_status = 1; /* infrastructure mode set */
+	hostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);
+}
+
+static
+void hostif_associate_indication(ks_wlan_private *priv)
+{
+#if WIRELESS_EXT > 14
+	struct association_request_t *assoc_req;
+	struct association_response_t *assoc_resp;
+	unsigned char *pb;
+	union iwreq_data wrqu;
+	char buf[IW_CUSTOM_MAX];
+	char *pbuf = &buf[0];
+	int i;
+
+	static const char associnfo_leader0[] = "ASSOCINFO(ReqIEs=";
+	static const char associnfo_leader1[] = " RespIEs=";
+
+	DPRINTK(3,"\n");
+	assoc_req = (struct association_request_t *)(priv->rxp);
+	assoc_resp = (struct association_response_t *)(assoc_req+1);
+	pb = (unsigned char *)(assoc_resp+1);
+
+	memset(&wrqu, 0, sizeof(wrqu));
+	memcpy(pbuf,associnfo_leader0,sizeof(associnfo_leader0)-1);
+	wrqu.data.length += sizeof(associnfo_leader0)-1;
+	pbuf += sizeof(associnfo_leader0)-1;
+
+	for (i = 0; i < assoc_req->reqIEs_size; i++)
+		pbuf += sprintf(pbuf, "%02x", *(pb+i));
+	wrqu.data.length += (assoc_req->reqIEs_size)*2;
+
+	memcpy(pbuf,associnfo_leader1,sizeof(associnfo_leader1)-1);
+	wrqu.data.length += sizeof(associnfo_leader1)-1;
+	pbuf += sizeof(associnfo_leader1)-1;
+
+	pb += assoc_req->reqIEs_size;
+	for (i = 0; i < assoc_resp->respIEs_size; i++)
+		pbuf += sprintf(pbuf, "%02x", *(pb+i));
+	wrqu.data.length += (assoc_resp->respIEs_size)*2;
+
+	pbuf += sprintf(pbuf, ")");
+	wrqu.data.length += 1;
+
+	DPRINTK(3,"IWEVENT:ASSOCINFO\n");
+	wireless_send_event(priv->net_dev, IWEVCUSTOM, &wrqu, buf);
+#endif /* WIRELESS_EXT > 14 */
+}
+
+static
+void hostif_bss_scan_confirm(ks_wlan_private *priv)
+{
+	unsigned int result_code;
+#if WIRELESS_EXT > 13
+	struct net_device *dev = priv->net_dev;
+	union iwreq_data wrqu;
+#endif /* WIRELESS_EXT > 13 */
+	result_code = get_DWORD(priv);
+	DPRINTK(2,"result=%d :: scan_ind_count=%d\n", result_code, priv->scan_ind_count);
+
+	priv->sme_i.sme_flag &= ~SME_AP_SCAN;
+	hostif_sme_enqueue(priv, SME_BSS_SCAN_CONFIRM);
+
+#if WIRELESS_EXT > 13
+	wrqu.data.length = 0;
+	wrqu.data.flags = 0;
+	DPRINTK(3,"IWEVENT: SCAN CONFIRM\n");
+	wireless_send_event(dev, SIOCGIWSCAN, &wrqu, NULL);
+#endif /* WIRELESS_EXT > 13 */
+	priv->scan_ind_count=0;
+}
+
+static
+void hostif_phy_information_confirm(ks_wlan_private *priv)
+{
+	struct iw_statistics *wstats = &priv->wstats;
+	unsigned char rssi,signal,noise;
+	unsigned char LinkSpeed;
+	unsigned int TransmittedFrameCount, ReceivedFragmentCount;
+	unsigned int FailedCount, FCSErrorCount;
+
+	DPRINTK(3,"\n");
+	rssi = get_BYTE(priv);
+	signal = get_BYTE(priv);
+	noise = get_BYTE(priv);
+	LinkSpeed = get_BYTE(priv);
+	TransmittedFrameCount = get_DWORD(priv);
+	ReceivedFragmentCount = get_DWORD(priv);
+	FailedCount = get_DWORD(priv);
+	FCSErrorCount = get_DWORD(priv);
+
+	DPRINTK(4, "phyinfo confirm rssi=%d signal=%d\n", rssi, signal);
+	priv->current_rate = (LinkSpeed & RATE_MASK);
+	wstats->qual.qual = signal;
+	wstats->qual.level = 256 - rssi;
+	wstats->qual.noise = 0; /* invalid noise value */
+	wstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
+
+	DPRINTK(3,"\n    rssi=%u\n    signal=%u\n    LinkSpeed=%ux500Kbps\n \
+   TransmittedFrameCount=%u\n    ReceivedFragmentCount=%u\n    FailedCount=%u\n \
+   FCSErrorCount=%u\n",
+		rssi,signal,LinkSpeed,TransmittedFrameCount,
+		ReceivedFragmentCount,FailedCount,FCSErrorCount);
+
+	/* wake_up_interruptible_all(&priv->confirm_wait); */
+	complete(&priv->confirm_wait);
+}
+
+static
+void hostif_mic_failure_confirm(ks_wlan_private *priv)
+{
+	DPRINTK(3,"mic_failure=%u\n",priv->wpa.mic_failure.failure);
+	hostif_sme_enqueue(priv, SME_MIC_FAILURE_CONFIRM);
+}
+
+
+static
+void hostif_event_check(ks_wlan_private *priv)
+{
+	unsigned short event;
+
+	DPRINTK(4, "\n");
+	event = get_WORD(priv); /* get event */
+	switch (event) {
+	case HIF_DATA_IND:
+		hostif_data_indication(priv);
+		break;
+	case HIF_MIB_GET_CONF:
+		hostif_mib_get_confirm(priv);
+		break;
+	case HIF_MIB_SET_CONF:
+		hostif_mib_set_confirm(priv);
+		break;
+	case HIF_POWERMGT_CONF:
+		hostif_power_mngmt_confirm(priv);
+		break;
+	case HIF_SLEEP_CONF:
+		hostif_sleep_confirm(priv);
+		break;
+	case HIF_START_CONF:
+		hostif_start_confirm(priv);
+		break;
+	case HIF_CONNECT_IND:
+		hostif_connect_indication(priv);
+		break;
+	case HIF_STOP_CONF:
+		hostif_stop_confirm(priv);
+		break;
+	case HIF_PS_ADH_SET_CONF:
+		hostif_ps_adhoc_set_confirm(priv);
+		break;
+	case HIF_INFRA_SET_CONF:
+	case HIF_INFRA_SET2_CONF:
+		hostif_infrastructure_set_confirm(priv);
+		break;
+	case HIF_ADH_SET_CONF:
+	case HIF_ADH_SET2_CONF:
+		hostif_adhoc_set_confirm(priv);
+		break;
+	case HIF_ASSOC_INFO_IND:
+		hostif_associate_indication(priv);
+		break;
+	case HIF_MIC_FAILURE_CONF:
+		hostif_mic_failure_confirm(priv);
+		break;
+	case HIF_SCAN_CONF:
+		hostif_bss_scan_confirm(priv);
+		break;
+	case HIF_PHY_INFO_CONF:
+	case HIF_PHY_INFO_IND:
+		hostif_phy_information_confirm(priv);
+		break;
+	case HIF_SCAN_IND:
+		hostif_scan_indication(priv);
+		break;
+	case HIF_AP_SET_CONF:
+	default:
+		//DPRINTK(1, "undefined event[%04X]\n", event);
+		printk("undefined event[%04X]\n", event);
+		/* wake_up_all(&priv->confirm_wait); */
+		complete(&priv->confirm_wait);
+		break;
+	}
+
+	/* add event to hostt buffer */
+	priv->hostt.buff[priv->hostt.qtail] = event;
+        priv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;
+}
+
+#define CHECK_ALINE(size) (size%4 ? (size+(4-(size%4))):size)
+
+int hostif_data_request(ks_wlan_private *priv, struct sk_buff *packet)
+{
+	unsigned int		packet_len=0;
+
+	unsigned char		*buffer=NULL;
+	unsigned int		length=0;
+	struct hostif_data_request_t *pp;
+	unsigned char		*p;
+	int	        result=0;
+	unsigned short eth_proto;
+	struct ether_hdr *eth_hdr;
+	struct michel_mic_t michel_mic;
+	unsigned short keyinfo=0;
+	struct ieee802_1x_hdr *aa1x_hdr;
+	struct wpa_eapol_key *eap_key;
+	struct ethhdr *eth;
+
+	packet_len = packet->len;
+	if (packet_len > ETH_FRAME_LEN) {
+		DPRINTK(1,"bad length packet_len=%d \n", packet_len);
+		dev_kfree_skb(packet);
+		return -1;
+	}
+
+	if(((priv->connect_status & CONNECT_STATUS_MASK)== DISCONNECT_STATUS) ||
+	   (priv->connect_status & FORCE_DISCONNECT) || priv->wpa.mic_failure.stop){
+		DPRINTK(3," DISCONNECT\n");
+		if(netif_queue_stopped(priv->net_dev))
+			netif_wake_queue(priv->net_dev);
+		if(packet)
+			dev_kfree_skb(packet);
+
+		return 0;
+	}
+
+	/* for PowerSave */
+	if(atomic_read(&priv->psstatus.status)==PS_SNOOZE){ /* power save wakeup */
+		if(!netif_queue_stopped(priv->net_dev))
+			netif_stop_queue(priv->net_dev);
+#if !defined(_SDIO_)
+		schedule_work(&priv->ks_wlan_wakeup_task);
+#endif
+	}
+
+	DPRINTK(4, "skb_buff length=%d\n", packet_len);
+	pp = (struct hostif_data_request_t *)kmalloc(hif_align_size(sizeof(*pp)+6+packet_len+8),KS_WLAN_MEM_FLAG );
+
+	if (pp==NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
+		dev_kfree_skb(packet);
+		return -2;
+	}
+
+	p = (unsigned char *)pp->data;
+
+	buffer = packet->data;
+	length = packet->len;
+
+	/* packet check */
+	eth = (struct ethhdr *)packet->data;
+	if (memcmp(&priv->eth_addr[0],eth->h_source, ETH_ALEN)){
+		DPRINTK(1, "invalid mac address !!\n");
+		DPRINTK(1, "ethernet->h_source=%02X:%02X:%02X:%02X:%02X:%02X\n",
+			eth->h_source[0],eth->h_source[1],eth->h_source[2],
+			eth->h_source[3],eth->h_source[4],eth->h_source[5]);
+		return -3;
+	}
+
+	/* MAC address copy */
+        memcpy(p, buffer, 12);	/* DST/SRC MAC address */
+	p += 12;
+	buffer += 12;
+	length -= 12;
+	/* EtherType/Length check */
+	if (*(buffer+1) + (*buffer << 8) > 1500) {
+		/* ProtocolEAP = *(buffer+1) + (*buffer << 8); */
+	        /* DPRINTK(2, "Send [SNAP]Type %x\n",ProtocolEAP); */
+		/* SAP/CTL/OUI(6 byte) add */
+	        *p++ = 0xAA;		/* DSAP */
+		*p++ = 0xAA;		/* SSAP */
+		*p++ = 0x03;		/* CTL */
+		*p++ = 0x00;		/* OUI ("000000") */
+		*p++ = 0x00;		/* OUI ("000000") */
+		*p++ = 0x00;		/* OUI ("000000") */
+		packet_len += 6;
+	} else {
+		DPRINTK(4,"DIX\n");
+	        /* Length(2 byte) delete */
+		buffer += 2;
+		length -= 2;
+		packet_len -= 2;
+	}
+
+	/* pp->data copy */
+	memcpy(p, buffer, length);
+
+	p += length;
+
+	/* for WPA */
+	eth_hdr = (struct ether_hdr *)&pp->data[0];
+	eth_proto = ntohs(eth_hdr->h_proto);
+
+	/* for MIC FAILUER REPORT check */
+	if(eth_proto == ETHER_PROTOCOL_TYPE_EAP && priv->wpa.mic_failure.failure>0){
+		aa1x_hdr=(struct ieee802_1x_hdr *)(eth_hdr+1);
+		if(aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY){
+			eap_key = (struct wpa_eapol_key *)(aa1x_hdr+1);
+			keyinfo=ntohs(eap_key->key_info);
+		}
+	}
+
+	if (priv->wpa.rsn_enabled && priv->wpa.key[0].key_len){
+		if(eth_proto == ETHER_PROTOCOL_TYPE_EAP && !(priv->wpa.key[1].key_len) &&
+		   !(priv->wpa.key[2].key_len) && !(priv->wpa.key[3].key_len)){
+			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH); /* no encryption */
+		}
+		else{
+			if(priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP){
+				MichaelMICFunction( &michel_mic,
+						   (uint8_t*)priv->wpa.key[0].tx_mic_key,
+						   (uint8_t*)&pp->data[0],
+						   (int)packet_len,
+						   (uint8_t)0, /* priority */
+						   (uint8_t*)michel_mic.Result );
+				memcpy(p, michel_mic.Result, 8);
+				length += 8;
+				packet_len += 8;
+				p += 8;
+				pp->auth_type = cpu_to_le16((uint16_t)TYPE_DATA);
+
+			}else if(priv->wpa.pairwise_suite == IW_AUTH_CIPHER_CCMP){
+				pp->auth_type = cpu_to_le16((uint16_t)TYPE_DATA);
+			}
+		}
+	}
+	else{
+		if(eth_proto == ETHER_PROTOCOL_TYPE_EAP)
+			pp->auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);
+		else
+			pp->auth_type = cpu_to_le16((uint16_t)TYPE_DATA);
+	}
+
+	/* header value set */
+	pp->header.size  = cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)+packet_len));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_DATA_REQ);
+
+	/* tx request */
+	result = ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + packet_len),
+			      (void *)send_packet_complete, (void *)priv, (void *)packet);
+
+	/* MIC FAILUER REPORT check */
+	if(eth_proto == ETHER_PROTOCOL_TYPE_EAP && priv->wpa.mic_failure.failure>0){
+		if(keyinfo & WPA_KEY_INFO_ERROR && keyinfo & WPA_KEY_INFO_REQUEST){
+			DPRINTK(3," MIC ERROR Report SET : %04X\n", keyinfo);
+			hostif_sme_enqueue(priv, SME_MIC_FAILURE_REQUEST);
+		}
+		if(priv->wpa.mic_failure.failure==2)
+			priv->wpa.mic_failure.stop=1;
+	}
+
+	return result;
+}
+
+#if defined(_SPI_)
+#define ps_confirm_wait_inc(priv)
+#else
+#define ps_confirm_wait_inc(priv)  do{if(atomic_read(&priv->psstatus.status) > PS_ACTIVE_SET){ \
+                                                  atomic_inc(&priv->psstatus.confirm_wait); \
+                                                  /* atomic_set(&priv->psstatus.status, PS_CONF_WAIT);*/ \
+                                      } }while(0)
+#endif
+
+static
+void hostif_mib_get_request( ks_wlan_private *priv, unsigned long mib_attribute)
+{
+	struct hostif_mib_get_request_t *pp;
+
+	DPRINTK(3, "\n");
+
+	/* make primitive */
+	pp = (struct hostif_mib_get_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3,"allocate memory failed..\n");
+		return;
+	}
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_MIB_GET_REQ);
+	pp->mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+}
+
+static
+void hostif_mib_set_request( ks_wlan_private *priv, unsigned long mib_attribute,
+			     unsigned short size, unsigned short type,
+			     void *vp )
+{
+	struct hostif_mib_set_request_t *pp;
+
+	DPRINTK(3,"\n");
+
+	if (priv->dev_state < DEVICE_STATE_BOOT) {
+		DPRINTK(3,"DeviceRemove\n");
+		return;
+	}
+
+	/* make primitive */
+	pp = (struct hostif_mib_set_request_t *)kmalloc(hif_align_size(sizeof(*pp)+size), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
+		return;
+	}
+
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)+size));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_MIB_SET_REQ);
+	pp->mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
+	pp->mib_value.size = cpu_to_le16((uint16_t)size);
+	pp->mib_value.type = cpu_to_le16((uint16_t)type);
+	memcpy(&pp->mib_value.body, vp, size);
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + size), NULL, NULL, NULL);
+}
+
+static
+void hostif_start_request( ks_wlan_private *priv, unsigned char mode )
+{
+	struct hostif_start_request_t *pp;
+
+	DPRINTK(3,"\n");
+
+	/* make primitive */
+	pp = (struct hostif_start_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
+		return;
+	}
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_START_REQ);
+	pp->mode = cpu_to_le16((uint16_t)mode);
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+
+	priv->aplist.size = 0;
+	priv->scan_ind_count=0;
+}
+
+static
+void hostif_ps_adhoc_set_request(ks_wlan_private *priv)
+{
+	struct hostif_ps_adhoc_set_request_t *pp;
+	uint16_t capability;
+
+        DPRINTK(3,"\n");
+
+	/* make primitive */
+	pp = (struct hostif_ps_adhoc_set_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
+		return;
+	}
+	memset(pp, 0, sizeof(*pp));
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_PS_ADH_SET_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+	pp->channel = cpu_to_le16((uint16_t)(priv->reg.channel));
+	pp->rate_set.size = priv->reg.rate_set.size;
+	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0], priv->reg.rate_set.size);
+
+	capability = 0x0000;
+	if (priv->reg.preamble==SHORT_PREAMBLE) {
+		/* short preamble */
+		capability |= BSS_CAP_SHORT_PREAMBLE;
+	}
+	capability &= ~(BSS_CAP_PBCC);  /* pbcc not support */
+	if(priv->reg.phy_type != D_11B_ONLY_MODE){
+		capability |= BSS_CAP_SHORT_SLOT_TIME;      /* ShortSlotTime support */
+		capability &= ~(BSS_CAP_DSSS_OFDM);         /* DSSS OFDM */
+	}
+	pp->capability = cpu_to_le16((uint16_t)capability);
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+}
+
+static
+void hostif_infrastructure_set_request(ks_wlan_private *priv)
+{
+	struct hostif_infrastructure_set_request_t *pp;
+	uint16_t capability;
+
+	DPRINTK(3, "ssid.size=%d \n",priv->reg.ssid.size);
+
+	/* make primitive */
+	pp = (struct hostif_infrastructure_set_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
+		return;
+	}
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_INFRA_SET_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+
+	pp->rate_set.size = priv->reg.rate_set.size;
+	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0], priv->reg.rate_set.size);
+	pp->ssid.size = priv->reg.ssid.size;
+	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
+
+	capability = 0x0000;
+	if (priv->reg.preamble==SHORT_PREAMBLE) {
+		/* short preamble */
+		capability |= BSS_CAP_SHORT_PREAMBLE;
+	}
+	capability &= ~(BSS_CAP_PBCC); /* pbcc not support */
+	if(priv->reg.phy_type != D_11B_ONLY_MODE){
+		capability |= BSS_CAP_SHORT_SLOT_TIME;      /* ShortSlotTime support */
+		capability &= ~(BSS_CAP_DSSS_OFDM);         /* DSSS OFDM not support */
+	}
+	pp->capability = cpu_to_le16((uint16_t)capability);
+	pp->beacon_lost_count = cpu_to_le16((uint16_t)(priv->reg.beacon_lost_count));
+	pp->auth_type = cpu_to_le16((uint16_t)(priv->reg.authenticate_type));
+
+	pp->channel_list.body[0] = 1;
+	pp->channel_list.body[1] = 8;
+	pp->channel_list.body[2] = 2;
+	pp->channel_list.body[3] = 9;
+	pp->channel_list.body[4] = 3;
+	pp->channel_list.body[5] = 10;
+	pp->channel_list.body[6] = 4;
+	pp->channel_list.body[7] = 11;
+	pp->channel_list.body[8] = 5;
+	pp->channel_list.body[9] = 12;
+	pp->channel_list.body[10] = 6;
+	pp->channel_list.body[11] = 13;
+	pp->channel_list.body[12] = 7;
+	if(priv->reg.phy_type == D_11G_ONLY_MODE){
+		pp->channel_list.size = 13;
+	}else{
+		pp->channel_list.body[13] = 14;
+		pp->channel_list.size = 14;
+	}
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)),NULL, NULL, NULL);
+}
+
+void hostif_infrastructure_set2_request(ks_wlan_private *priv)
+{
+	struct hostif_infrastructure_set2_request_t *pp;
+	uint16_t capability;
+
+	DPRINTK(2, "ssid.size=%d \n",priv->reg.ssid.size);
+
+	/* make primitive */
+	pp = (struct hostif_infrastructure_set2_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
+		return;
+	}
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_INFRA_SET2_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+
+	pp->rate_set.size = priv->reg.rate_set.size;
+	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0], priv->reg.rate_set.size);
+	pp->ssid.size = priv->reg.ssid.size;
+	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
+
+	capability = 0x0000;
+	if (priv->reg.preamble==SHORT_PREAMBLE) {
+		/* short preamble */
+		capability |= BSS_CAP_SHORT_PREAMBLE;
+	}
+	capability &= ~(BSS_CAP_PBCC); /* pbcc not support */
+	if(priv->reg.phy_type != D_11B_ONLY_MODE){
+		capability |= BSS_CAP_SHORT_SLOT_TIME;      /* ShortSlotTime support */
+		capability &= ~(BSS_CAP_DSSS_OFDM);         /* DSSS OFDM not support */
+	}
+	pp->capability = cpu_to_le16((uint16_t)capability);
+	pp->beacon_lost_count = cpu_to_le16((uint16_t)(priv->reg.beacon_lost_count));
+	pp->auth_type = cpu_to_le16((uint16_t)(priv->reg.authenticate_type));
+
+	pp->channel_list.body[0] = 1;
+	pp->channel_list.body[1] = 8;
+	pp->channel_list.body[2] = 2;
+	pp->channel_list.body[3] = 9;
+	pp->channel_list.body[4] = 3;
+	pp->channel_list.body[5] = 10;
+	pp->channel_list.body[6] = 4;
+	pp->channel_list.body[7] = 11;
+	pp->channel_list.body[8] = 5;
+	pp->channel_list.body[9] = 12;
+	pp->channel_list.body[10] = 6;
+	pp->channel_list.body[11] = 13;
+	pp->channel_list.body[12] = 7;
+	if(priv->reg.phy_type == D_11G_ONLY_MODE){
+		pp->channel_list.size = 13;
+	}else{
+		pp->channel_list.body[13] = 14;
+		pp->channel_list.size = 14;
+	}
+
+	memcpy(pp->bssid, priv->reg.bssid, ETH_ALEN);
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)),NULL, NULL, NULL);
+}
+
+static
+void hostif_adhoc_set_request(ks_wlan_private *priv)
+{
+	struct hostif_adhoc_set_request_t *pp;
+	uint16_t capability;
+
+	DPRINTK(3, "\n");
+
+	/* make primitive */
+	pp = (struct hostif_adhoc_set_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
+		return;
+	}
+	memset(pp, 0, sizeof(*pp));
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_ADH_SET_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+	pp->channel = cpu_to_le16((uint16_t)(priv->reg.channel));
+	pp->rate_set.size = priv->reg.rate_set.size;
+	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0], priv->reg.rate_set.size);
+	pp->ssid.size = priv->reg.ssid.size;
+	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
+
+	capability = 0x0000;
+	if (priv->reg.preamble==SHORT_PREAMBLE) {
+		/* short preamble */
+		capability |= BSS_CAP_SHORT_PREAMBLE;
+	}
+	capability &= ~(BSS_CAP_PBCC); /* pbcc not support */
+	if(priv->reg.phy_type != D_11B_ONLY_MODE){
+		capability |= BSS_CAP_SHORT_SLOT_TIME;      /* ShortSlotTime support */
+		capability &= ~(BSS_CAP_DSSS_OFDM);         /* DSSS OFDM not support */
+	}
+	pp->capability = cpu_to_le16((uint16_t)capability);
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+}
+
+static
+void hostif_adhoc_set2_request(ks_wlan_private *priv)
+{
+	struct hostif_adhoc_set2_request_t *pp;
+	uint16_t capability;
+
+	DPRINTK(3, "\n");
+
+	/* make primitive */
+	pp = (struct hostif_adhoc_set2_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
+		return;
+	}
+	memset(pp, 0, sizeof(*pp));
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_ADH_SET_REQ);
+	pp->phy_type = cpu_to_le16((uint16_t)(priv->reg.phy_type));
+	pp->cts_mode = cpu_to_le16((uint16_t)(priv->reg.cts_mode));
+	pp->scan_type = cpu_to_le16((uint16_t)(priv->reg.scan_type));
+	pp->rate_set.size = priv->reg.rate_set.size;
+	memcpy(&pp->rate_set.body[0], &priv->reg.rate_set.body[0], priv->reg.rate_set.size);
+	pp->ssid.size = priv->reg.ssid.size;
+	memcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);
+
+	capability = 0x0000;
+	if (priv->reg.preamble==SHORT_PREAMBLE) {
+		/* short preamble */
+		capability |= BSS_CAP_SHORT_PREAMBLE;
+	}
+	capability &= ~(BSS_CAP_PBCC); /* pbcc not support */
+	if(priv->reg.phy_type != D_11B_ONLY_MODE){
+		capability |= BSS_CAP_SHORT_SLOT_TIME;      /* ShortSlotTime support */
+		capability &= ~(BSS_CAP_DSSS_OFDM);         /* DSSS OFDM not support */
+	}
+	pp->capability = cpu_to_le16((uint16_t)capability);
+
+	pp->channel_list.body[0] = priv->reg.channel;
+	pp->channel_list.size = 1;
+	memcpy(pp->bssid, priv->reg.bssid, ETH_ALEN);
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+}
+
+static
+void hostif_stop_request( ks_wlan_private *priv )
+{
+	struct hostif_stop_request_t *pp;
+
+	DPRINTK(3,"\n");
+
+	/* make primitive */
+	pp = (struct hostif_stop_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3,"allocate memory failed..\n");
+		return;
+	}
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_STOP_REQ);
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+}
+
+static
+void hostif_phy_information_request( ks_wlan_private *priv )
+{
+	struct hostif_phy_information_request_t *pp;
+
+	DPRINTK(3,"\n");
+
+	/* make primitive */
+	pp = (struct hostif_phy_information_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3, "allocate memory failed..\n");
+		return;
+	}
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_PHY_INFO_REQ);
+	if(priv->reg.phy_info_timer){
+		pp->type = cpu_to_le16((uint16_t)TIME_TYPE);
+		pp->time = cpu_to_le16((uint16_t)(priv->reg.phy_info_timer));
+	}else{
+		pp->type = cpu_to_le16((uint16_t)NORMAL_TYPE);
+		pp->time = cpu_to_le16((uint16_t)0);
+	}
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+}
+
+static
+void hostif_power_mngmt_request( ks_wlan_private *priv, unsigned long mode,
+				 unsigned long wake_up, unsigned long receiveDTIMs )
+{
+	struct hostif_power_mngmt_request_t *pp;
+
+	DPRINTK(3,"mode=%lu wake_up=%lu receiveDTIMs=%lu\n",mode,wake_up,receiveDTIMs);
+	/* make primitive */
+	pp = (struct hostif_power_mngmt_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3,"allocate memory failed..\n");
+		return;
+	}
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_POWERMGT_REQ);
+	pp->mode = cpu_to_le32((uint32_t)mode);
+	pp->wake_up = cpu_to_le32((uint32_t)wake_up);
+	pp->receiveDTIMs = cpu_to_le32((uint32_t)receiveDTIMs);
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+}
+
+static
+void hostif_sleep_request( ks_wlan_private *priv, unsigned long mode)
+{
+	struct hostif_sleep_request_t *pp;
+
+	DPRINTK(3,"mode=%lu \n",mode);
+
+	if(mode == SLP_SLEEP){
+		/* make primitive */
+		pp = (struct hostif_sleep_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+		if (pp==NULL) {
+			DPRINTK(3,"allocate memory failed..\n");
+			return;
+		}
+		pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+		pp->header.event = cpu_to_le16((uint16_t)HIF_SLEEP_REQ);
+
+		/* send to device request */
+		ps_confirm_wait_inc(priv);
+		ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+	}else if(mode == SLP_ACTIVE){
+		atomic_set(&priv->sleepstatus.wakeup_request,1);
+		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+	}else{
+		DPRINTK(3,"invalid mode %ld \n", mode);
+		return;
+	}
+}
+
+
+static
+void hostif_bss_scan_request( ks_wlan_private *priv, unsigned long scan_type , uint8_t *scan_ssid, uint8_t scan_ssid_len)
+{
+	struct hostif_bss_scan_request_t *pp;
+
+	DPRINTK(2,"\n");
+	/* make primitive */
+	pp = (struct hostif_bss_scan_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3,"allocate memory failed..\n");
+		return;
+	}
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+	pp->header.event = cpu_to_le16((uint16_t)HIF_SCAN_REQ);
+	pp->scan_type = scan_type;
+
+	pp->ch_time_min = cpu_to_le32((uint32_t)110); /* default value */
+	pp->ch_time_max = cpu_to_le32((uint32_t)130); /* default value */
+	pp->channel_list.body[0] = 1;
+	pp->channel_list.body[1] = 8;
+	pp->channel_list.body[2] = 2;
+	pp->channel_list.body[3] = 9;
+	pp->channel_list.body[4] = 3;
+	pp->channel_list.body[5] = 10;
+	pp->channel_list.body[6] = 4;
+	pp->channel_list.body[7] = 11;
+	pp->channel_list.body[8] = 5;
+	pp->channel_list.body[9] = 12;
+	pp->channel_list.body[10] = 6;
+	pp->channel_list.body[11] = 13;
+	pp->channel_list.body[12] = 7;
+	if(priv->reg.phy_type == D_11G_ONLY_MODE){
+		pp->channel_list.size = 13;
+	}else{
+		pp->channel_list.body[13] = 14;
+		pp->channel_list.size = 14;
+	}
+	pp->ssid.size = 0;
+
+	/* specified SSID SCAN */
+	if(scan_ssid_len > 0 && scan_ssid_len <= 32){
+		pp->ssid.size = scan_ssid_len;
+		memcpy(&pp->ssid.body[0], scan_ssid, scan_ssid_len);
+	}
+
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+
+	priv->aplist.size = 0;
+	priv->scan_ind_count=0;
+}
+
+static
+void hostif_mic_failure_request( ks_wlan_private *priv, unsigned short failure_count,
+				 unsigned short timer )
+{
+	struct hostif_mic_failure_request_t *pp;
+
+	DPRINTK(3,"count=%d :: timer=%d\n",failure_count,timer);
+	/* make primitive */
+	pp = (struct hostif_mic_failure_request_t *)kmalloc(hif_align_size(sizeof(*pp)), KS_WLAN_MEM_FLAG );
+	if (pp==NULL) {
+		DPRINTK(3,"allocate memory failed..\n");
+		return;
+	}
+	pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+	pp->header.event =  cpu_to_le16((uint16_t)HIF_MIC_FAILURE_REQ);
+	pp->failure_count = cpu_to_le16((uint16_t)failure_count);
+	pp->timer = cpu_to_le16((uint16_t)timer);
+
+	/* send to device request */
+	ps_confirm_wait_inc(priv);
+	ks_wlan_hw_tx( priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
+}
+
+/* Device I/O Recieve indicate */
+static void devio_rec_ind(ks_wlan_private *priv, unsigned char *p, unsigned int size)
+{
+	if (priv->device_open_status) {
+		spin_lock(&priv->dev_read_lock); /* request spin lock */
+		priv->dev_data[atomic_read(&priv->rec_count)] = p;
+		priv->dev_size[atomic_read(&priv->rec_count)] = size;
+
+		if (atomic_read(&priv->event_count) != DEVICE_STOCK_COUNT) {
+			/* rx event count inc */
+			atomic_inc(&priv->event_count);
+		}
+		atomic_inc(&priv->rec_count);
+		if (atomic_read(&priv->rec_count)==DEVICE_STOCK_COUNT)
+			atomic_set(&priv->rec_count, 0);
+
+	        wake_up_interruptible_all(&priv->devread_wait);
+
+		/* release spin lock */
+		spin_unlock(&priv->dev_read_lock);
+	}
+}
+
+void hostif_receive( ks_wlan_private *priv, unsigned char *p, unsigned int size )
+{
+	DPRINTK(4,"\n");
+
+	devio_rec_ind(priv, p, size);
+
+	priv->rxp = p;
+	priv->rx_size = size;
+
+	if (get_WORD(priv) == priv->rx_size) { /* length check !! */
+		hostif_event_check(priv); /* event check */
+	}
+}
+
+
+static
+void hostif_sme_set_wep(ks_wlan_private *priv, int type)
+{
+	uint32_t val;
+	switch(type){
+	case SME_WEP_INDEX_REQUEST:
+		val = cpu_to_le32((uint32_t)(priv->reg.wep_index));
+		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_ID,
+				       sizeof(val), MIB_VALUE_TYPE_INT,
+				       &val );
+		break;
+	case SME_WEP_KEY1_REQUEST:
+		if(!priv->wpa.wpa_enabled)
+			hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE1,
+					       priv->reg.wep_key[0].size, MIB_VALUE_TYPE_OSTRING,
+					       &priv->reg.wep_key[0].val[0] );
+		break;
+	case SME_WEP_KEY2_REQUEST:
+		if(!priv->wpa.wpa_enabled)
+			hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE2,
+					       priv->reg.wep_key[1].size, MIB_VALUE_TYPE_OSTRING,
+					       &priv->reg.wep_key[1].val[0]);
+		break;
+	case SME_WEP_KEY3_REQUEST:
+		if(!priv->wpa.wpa_enabled)
+			hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE3,
+					       priv->reg.wep_key[2].size, MIB_VALUE_TYPE_OSTRING,
+					       &priv->reg.wep_key[2].val[0] );
+		break;
+	case SME_WEP_KEY4_REQUEST:
+		if(!priv->wpa.wpa_enabled)
+			hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE4,
+					       priv->reg.wep_key[3].size, MIB_VALUE_TYPE_OSTRING,
+					       &priv->reg.wep_key[3].val[0]);
+		break;
+	case SME_WEP_FLAG_REQUEST:
+		val = cpu_to_le32((uint32_t)(priv->reg.privacy_invoked));
+		hostif_mib_set_request(priv, DOT11_PRIVACY_INVOKED,
+				       sizeof(val), MIB_VALUE_TYPE_BOOL,
+				       &val );
+		break;
+	}
+
+	return ;
+}
+
+struct wpa_suite_t {
+	unsigned short size;
+	unsigned char suite[4][CIPHER_ID_LEN];
+} __attribute__((packed));
+
+struct rsn_mode_t {
+	uint32_t rsn_mode;
+	uint16_t rsn_capability;
+} __attribute__((packed));
+
+static
+void hostif_sme_set_rsn(ks_wlan_private *priv, int type)
+{
+	struct wpa_suite_t wpa_suite;
+	struct rsn_mode_t rsn_mode;
+	uint32_t val;
+
+	memset(&wpa_suite,0,sizeof(wpa_suite));
+
+	switch(type){
+	case SME_RSN_UCAST_REQUEST:
+		wpa_suite.size=cpu_to_le16((uint16_t)1);
+		switch(priv->wpa.pairwise_suite){
+		case IW_AUTH_CIPHER_NONE:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_NONE,CIPHER_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_NONE,CIPHER_ID_LEN);
+			break;
+		case IW_AUTH_CIPHER_WEP40:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_WEP40,CIPHER_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_WEP40,CIPHER_ID_LEN);
+			break;
+		case IW_AUTH_CIPHER_TKIP:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_TKIP,CIPHER_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_TKIP,CIPHER_ID_LEN);
+			break;
+		case IW_AUTH_CIPHER_CCMP:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_CCMP,CIPHER_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_CCMP,CIPHER_ID_LEN);
+			break;
+		case IW_AUTH_CIPHER_WEP104:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_WEP104,CIPHER_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_WEP104,CIPHER_ID_LEN);
+			break;
+		}
+
+		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_UNICAST_CIPHER,
+				       sizeof(wpa_suite.size)+CIPHER_ID_LEN*wpa_suite.size,
+				       MIB_VALUE_TYPE_OSTRING, &wpa_suite);
+		break;
+	case SME_RSN_MCAST_REQUEST:
+		switch(priv->wpa.group_suite){
+		case IW_AUTH_CIPHER_NONE:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_NONE,CIPHER_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_NONE,CIPHER_ID_LEN);
+			break;
+		case IW_AUTH_CIPHER_WEP40:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_WEP40,CIPHER_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_WEP40,CIPHER_ID_LEN);
+			break;
+		case IW_AUTH_CIPHER_TKIP:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_TKIP,CIPHER_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_TKIP,CIPHER_ID_LEN);
+			break;
+		case IW_AUTH_CIPHER_CCMP:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_CCMP,CIPHER_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_CCMP,CIPHER_ID_LEN);
+			break;
+		case IW_AUTH_CIPHER_WEP104:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA2_WEP104,CIPHER_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],CIPHER_ID_WPA_WEP104,CIPHER_ID_LEN);
+			break;
+		}
+
+		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_MULTICAST_CIPHER,
+				       CIPHER_ID_LEN, MIB_VALUE_TYPE_OSTRING,
+				       &wpa_suite.suite[0][0] );
+		break;
+	case SME_RSN_AUTH_REQUEST:
+		wpa_suite.size=cpu_to_le16((uint16_t)1);
+		switch(priv->wpa.key_mgmt_suite){
+		case IW_AUTH_KEY_MGMT_802_1X:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA2_1X,KEY_MGMT_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA_1X,KEY_MGMT_ID_LEN);
+			break;
+		case IW_AUTH_KEY_MGMT_PSK:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA2_PSK,KEY_MGMT_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA_PSK,KEY_MGMT_ID_LEN);
+			break;
+		case 0:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA2_NONE,KEY_MGMT_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA_NONE,KEY_MGMT_ID_LEN);
+			break;
+		case 4:
+			if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)
+				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA2_WPANONE,KEY_MGMT_ID_LEN);
+			else
+				memcpy(&wpa_suite.suite[0][0],KEY_MGMT_ID_WPA_WPANONE,KEY_MGMT_ID_LEN);
+			break;
+		}
+
+		hostif_mib_set_request(priv, DOT11_RSN_CONFIG_AUTH_SUITE,
+				       sizeof(wpa_suite.size)+KEY_MGMT_ID_LEN*wpa_suite.size,
+				       MIB_VALUE_TYPE_OSTRING, &wpa_suite);
+		break;
+	case SME_RSN_ENABLED_REQUEST:
+		val = cpu_to_le32((uint32_t)(priv->wpa.rsn_enabled));
+		hostif_mib_set_request(priv, DOT11_RSN_ENABLED,
+				       sizeof(val), MIB_VALUE_TYPE_BOOL,
+				       &val );
+		break;
+	case SME_RSN_MODE_REQUEST:
+		if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2){
+			rsn_mode.rsn_mode = cpu_to_le32((uint32_t)RSN_MODE_WPA2);
+			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
+		}
+		else if(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA){
+			rsn_mode.rsn_mode = cpu_to_le32((uint32_t)RSN_MODE_WPA);
+			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
+		}
+		else{
+			rsn_mode.rsn_mode = cpu_to_le32((uint32_t)RSN_MODE_NONE);
+			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
+		}
+		hostif_mib_set_request(priv, LOCAL_RSN_MODE,sizeof(rsn_mode),
+				       MIB_VALUE_TYPE_OSTRING,&rsn_mode );
+		break;
+
+	}
+	return;
+}
+
+static
+void hostif_sme_mode_setup(ks_wlan_private *priv)
+{
+	unsigned char rate_size;
+	unsigned char rate_octet[RATE_SET_MAX_SIZE];
+	int i=0;
+
+	/* rate setting if rate segging is auto for changing phy_type (#94)*/
+	if(priv->reg.tx_rate == TX_RATE_FULL_AUTO){
+		if(priv->reg.phy_type == D_11B_ONLY_MODE){
+			priv->reg.rate_set.body[3] = TX_RATE_11M;
+			priv->reg.rate_set.body[2] = TX_RATE_5M;
+			priv->reg.rate_set.body[1] = TX_RATE_2M|BASIC_RATE;
+			priv->reg.rate_set.body[0] = TX_RATE_1M|BASIC_RATE;
+			priv->reg.rate_set.size = 4;
+		}else{ /* D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE */
+			priv->reg.rate_set.body[11] = TX_RATE_54M;
+			priv->reg.rate_set.body[10] = TX_RATE_48M;
+			priv->reg.rate_set.body[9] = TX_RATE_36M;
+			priv->reg.rate_set.body[8] = TX_RATE_18M;
+			priv->reg.rate_set.body[7] = TX_RATE_9M;
+			priv->reg.rate_set.body[6] = TX_RATE_24M|BASIC_RATE;
+			priv->reg.rate_set.body[5] = TX_RATE_12M|BASIC_RATE;
+			priv->reg.rate_set.body[4] = TX_RATE_6M|BASIC_RATE;
+			priv->reg.rate_set.body[3] = TX_RATE_11M|BASIC_RATE;
+			priv->reg.rate_set.body[2] = TX_RATE_5M|BASIC_RATE;
+			priv->reg.rate_set.body[1] = TX_RATE_2M|BASIC_RATE;
+			priv->reg.rate_set.body[0] = TX_RATE_1M|BASIC_RATE;
+			priv->reg.rate_set.size = 12;
+		}
+	}
+
+	/* rate mask by phy setting */
+	if(priv->reg.phy_type == D_11B_ONLY_MODE){
+		for(i=0;i<priv->reg.rate_set.size;i++){
+			if(IS_11B_RATE(priv->reg.rate_set.body[i])){
+				if((priv->reg.rate_set.body[i] & RATE_MASK) >= TX_RATE_5M)
+					rate_octet[i] = priv->reg.rate_set.body[i] & RATE_MASK ;
+				else
+					rate_octet[i] = priv->reg.rate_set.body[i];
+			}
+			else
+				break;
+		}
+
+	}else{ /* D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE */
+		for(i=0;i<priv->reg.rate_set.size;i++){
+			if(IS_11BG_RATE(priv->reg.rate_set.body[i])){
+				if(IS_OFDM_EXT_RATE(priv->reg.rate_set.body[i]))
+					rate_octet[i] = priv->reg.rate_set.body[i] & RATE_MASK ;
+				else
+					rate_octet[i] = priv->reg.rate_set.body[i];
+			}
+			else
+				break;
+		}
+	}
+	rate_size = i;
+	if(rate_size==0){
+		if(priv->reg.phy_type == D_11G_ONLY_MODE)
+			rate_octet[0]=TX_RATE_6M | BASIC_RATE;
+		else
+			rate_octet[0]=TX_RATE_2M | BASIC_RATE;
+		rate_size = 1;
+	}
+
+	/* rate set update */
+	priv->reg.rate_set.size = rate_size;
+	memcpy(&priv->reg.rate_set.body[0], &rate_octet[0], rate_size);
+
+	switch ( priv->reg.operation_mode ) {
+	case MODE_PSEUDO_ADHOC:
+		/* Pseudo Ad-Hoc mode */
+		hostif_ps_adhoc_set_request(priv);
+		break;
+	case MODE_INFRASTRUCTURE:
+		/* Infrastructure mode */
+		if (!is_valid_ether_addr((u8 *)priv->reg.bssid)) {
+			hostif_infrastructure_set_request(priv);
+		}
+		else {
+			hostif_infrastructure_set2_request(priv);
+			DPRINTK(2, "Infra bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
+			       priv->reg.bssid[0],priv->reg.bssid[1],priv->reg.bssid[2],
+			       priv->reg.bssid[3],priv->reg.bssid[4],priv->reg.bssid[5]);
+		}
+		break;
+	case MODE_ADHOC:
+		/* IEEE802.11 Ad-Hoc mode */
+		if (!is_valid_ether_addr((u8 *)priv->reg.bssid)) {
+			hostif_adhoc_set_request(priv);
+		}
+		else {
+			hostif_adhoc_set2_request(priv);
+			DPRINTK(2, "Adhoc bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
+			       priv->reg.bssid[0],priv->reg.bssid[1],priv->reg.bssid[2],
+    			   priv->reg.bssid[3],priv->reg.bssid[4],priv->reg.bssid[5]);
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ;
+}
+
+static
+void hostif_sme_multicast_set(ks_wlan_private *priv)
+{
+
+        struct net_device *dev = priv->net_dev;
+	int mc_count;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
+	struct netdev_hw_addr *ha;
+#else
+	struct dev_mc_list *mclist;
+#endif
+	char	set_address[NIC_MAX_MCAST_LIST*ETH_ALEN];
+	unsigned long filter_type;
+	int i;
+
+	DPRINTK(3,"\n");
+
+	spin_lock(&priv->multicast_spin);
+
+	memset(set_address, 0, NIC_MAX_MCAST_LIST*ETH_ALEN);
+
+	if (dev->flags & IFF_PROMISC ){
+		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_PROMISC);
+		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER, sizeof(filter_type),
+				       MIB_VALUE_TYPE_BOOL, &filter_type);
+	}
+	else if ((netdev_mc_count(dev) > NIC_MAX_MCAST_LIST) || (dev->flags & IFF_ALLMULTI)){
+		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCASTALL);
+		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER, sizeof(filter_type),
+				       MIB_VALUE_TYPE_BOOL, &filter_type);
+	}
+	else {
+		if (priv->sme_i.sme_flag & SME_MULTICAST){
+			mc_count = netdev_mc_count(dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
+			netdev_for_each_mc_addr(ha, dev) {
+				memcpy(&set_address[i*ETH_ALEN], ha->addr, ETH_ALEN);
+			}
+#else
+			for (i = 0, mclist = dev->mc_list; mclist && i < mc_count; i++, mclist = mclist->next)
+				memcpy(&set_address[i*ETH_ALEN], mclist->dmi_addr, ETH_ALEN);
+#endif
+			priv->sme_i.sme_flag &= ~SME_MULTICAST;
+			hostif_mib_set_request(priv, LOCAL_MULTICAST_ADDRESS,
+					       (ETH_ALEN*mc_count), MIB_VALUE_TYPE_OSTRING, &set_address[0]);
+		}else {
+			filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCAST);
+			priv->sme_i.sme_flag |= SME_MULTICAST;
+			hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER, sizeof(filter_type),
+					       MIB_VALUE_TYPE_BOOL, &filter_type);
+		}
+	}
+
+	spin_unlock(&priv->multicast_spin);
+
+}
+
+static
+void hostif_sme_powermgt_set(ks_wlan_private *priv)
+{
+	unsigned long mode,wake_up,receiveDTIMs ;
+
+	DPRINTK(3,"\n");
+	switch(priv->reg.powermgt){
+	case POWMGT_ACTIVE_MODE:
+		mode = POWER_ACTIVE;
+		wake_up = 0;
+		receiveDTIMs = 0;
+		break;
+	case POWMGT_SAVE1_MODE:
+		if(priv->reg.operation_mode == MODE_INFRASTRUCTURE){
+			mode = POWER_SAVE;
+			wake_up = 0;
+			receiveDTIMs = 0;
+		} else {
+			mode = POWER_ACTIVE;
+			wake_up = 0;
+			receiveDTIMs = 0;
+		}
+		break;
+	case POWMGT_SAVE2_MODE:
+		if(priv->reg.operation_mode == MODE_INFRASTRUCTURE){
+			mode = POWER_SAVE;
+			wake_up = 0;
+			receiveDTIMs = 1;
+		} else {
+			mode = POWER_ACTIVE;
+			wake_up = 0;
+			receiveDTIMs = 0;
+		}
+		break;
+	default:
+		mode = POWER_ACTIVE;
+		wake_up = 0;
+		receiveDTIMs = 0;
+		break;
+	}
+	hostif_power_mngmt_request(priv, mode, wake_up, receiveDTIMs);
+
+	return;
+}
+
+static
+void hostif_sme_sleep_set(ks_wlan_private *priv)
+{
+	DPRINTK(3,"\n");
+	switch(priv->sleep_mode){
+	case SLP_SLEEP:
+		hostif_sleep_request(priv, priv->sleep_mode);
+		break;
+	case SLP_ACTIVE:
+		hostif_sleep_request(priv, priv->sleep_mode);
+		break;
+	default:
+		break;
+	}
+
+	return;
+}
+
+static
+void hostif_sme_set_key(ks_wlan_private *priv, int type)
+{
+	uint32_t val;
+	switch(type){
+	case SME_SET_FLAG:
+		val = cpu_to_le32((uint32_t)(priv->reg.privacy_invoked));
+		hostif_mib_set_request(priv, DOT11_PRIVACY_INVOKED,
+				       sizeof(val), MIB_VALUE_TYPE_BOOL,
+				       &val );
+		break;
+	case SME_SET_TXKEY:
+		val = cpu_to_le32((uint32_t)(priv->wpa.txkey));
+		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_ID,
+				       sizeof(val), MIB_VALUE_TYPE_INT,
+				       &val );
+		break;
+	case SME_SET_KEY1:
+		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE1,
+				       priv->wpa.key[0].key_len, MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[0].key_val[0] );
+		break;
+	case SME_SET_KEY2:
+		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE2,
+				       priv->wpa.key[1].key_len, MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[1].key_val[0] );
+		break;
+	case SME_SET_KEY3:
+		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE3,
+				       priv->wpa.key[2].key_len, MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[2].key_val[0] );
+		break;
+	case SME_SET_KEY4:
+		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_VALUE4,
+				       priv->wpa.key[3].key_len, MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[3].key_val[0] );
+		break;
+	case SME_SET_PMK_TSC:
+		hostif_mib_set_request(priv, DOT11_PMK_TSC,
+				       WPA_RX_SEQ_LEN, MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[0].rx_seq[0] );
+		break;
+	case SME_SET_GMK1_TSC:
+		hostif_mib_set_request(priv, DOT11_GMK1_TSC,
+				       WPA_RX_SEQ_LEN, MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[1].rx_seq[0] );
+		break;
+	case SME_SET_GMK2_TSC:
+		hostif_mib_set_request(priv, DOT11_GMK2_TSC,
+				       WPA_RX_SEQ_LEN, MIB_VALUE_TYPE_OSTRING,
+				       &priv->wpa.key[2].rx_seq[0] );
+		break;
+	}
+	return;
+}
+
+static
+void hostif_sme_set_pmksa(ks_wlan_private *priv)
+{
+	struct pmk_cache_t {
+		uint16_t size;
+		struct {
+			uint8_t	bssid[ETH_ALEN];
+			uint8_t	pmkid[IW_PMKID_LEN];
+		} __attribute__((packed)) list[PMK_LIST_MAX];
+	} __attribute__((packed)) pmkcache;
+	struct pmk_t *pmk;
+	struct list_head *ptr;
+	int i;
+
+	DPRINTK(4,"pmklist.size=%d\n",priv->pmklist.size);
+	i=0;
+	list_for_each(ptr, &priv->pmklist.head){
+		pmk = list_entry(ptr, struct pmk_t, list);
+		if(i<PMK_LIST_MAX){
+			memcpy(pmkcache.list[i].bssid, pmk->bssid, ETH_ALEN);
+			memcpy(pmkcache.list[i].pmkid, pmk->pmkid, IW_PMKID_LEN);
+			i++;
+		}
+	}
+	pmkcache.size = cpu_to_le16((uint16_t)(priv->pmklist.size));
+	hostif_mib_set_request(priv, LOCAL_PMK,
+			       sizeof(priv->pmklist.size)+(ETH_ALEN+IW_PMKID_LEN)*(priv->pmklist.size),
+			       MIB_VALUE_TYPE_OSTRING,&pmkcache );
+}
+
+/* execute sme */
+static
+void hostif_sme_execute(ks_wlan_private *priv, int event)
+{
+	uint32_t val;
+
+	DPRINTK(3,"event=%d\n",event);
+	switch (event) {
+	case SME_START:
+		if ( priv->dev_state == DEVICE_STATE_BOOT ){
+			hostif_mib_get_request(priv, DOT11_MAC_ADDRESS);
+		}
+		break;
+	case SME_MULTICAST_REQUEST:
+		hostif_sme_multicast_set(priv);
+		break;
+	case SME_MACADDRESS_SET_REQUEST:
+		hostif_mib_set_request(priv, LOCAL_CURRENTADDRESS, ETH_ALEN,
+				       MIB_VALUE_TYPE_OSTRING, &priv->eth_addr[0]);
+		break;
+	case SME_BSS_SCAN_REQUEST:
+		hostif_bss_scan_request(priv, priv->reg.scan_type, priv->scan_ssid, priv->scan_ssid_len);
+		break;
+	case SME_POW_MNGMT_REQUEST:
+		hostif_sme_powermgt_set(priv);
+		break;
+	case SME_PHY_INFO_REQUEST:
+		hostif_phy_information_request(priv);
+		break;
+	case SME_MIC_FAILURE_REQUEST:
+		if(priv->wpa.mic_failure.failure == 1){
+			hostif_mic_failure_request(priv, priv->wpa.mic_failure.failure-1, 0);
+		}else if(priv->wpa.mic_failure.failure == 2){
+			hostif_mic_failure_request(priv, priv->wpa.mic_failure.failure-1,
+						   priv->wpa.mic_failure.counter);
+		}else
+			DPRINTK(4,"SME_MIC_FAILURE_REQUEST: failure count=%u error?\n",
+				priv->wpa.mic_failure.failure);
+		break;
+	case SME_MIC_FAILURE_CONFIRM:
+		if(priv->wpa.mic_failure.failure == 2){
+			if(priv->wpa.mic_failure.stop)
+				priv->wpa.mic_failure.stop = 0;
+			priv->wpa.mic_failure.failure = 0;
+			hostif_start_request( priv, priv->reg.operation_mode );
+		}
+		break;
+	case SME_GET_MAC_ADDRESS:
+		if ( priv->dev_state == DEVICE_STATE_BOOT ){
+			hostif_mib_get_request(priv, DOT11_PRODUCT_VERSION);
+		}
+		break;
+	case SME_GET_PRODUCT_VERSION:
+		if ( priv->dev_state == DEVICE_STATE_BOOT ){
+			priv->dev_state = DEVICE_STATE_PREINIT;
+		}
+		break;
+	case SME_STOP_REQUEST:
+		hostif_stop_request(priv);
+		break;
+	case SME_RTS_THRESHOLD_REQUEST:
+		val = cpu_to_le32((uint32_t)(priv->reg.rts));
+		hostif_mib_set_request(priv, DOT11_RTS_THRESHOLD,
+				       sizeof(val), MIB_VALUE_TYPE_INT,
+				       &val );
+		break;
+	case SME_FRAGMENTATION_THRESHOLD_REQUEST:
+		val = cpu_to_le32((uint32_t)(priv->reg.fragment));
+		hostif_mib_set_request(priv, DOT11_FRAGMENTATION_THRESHOLD,
+				       sizeof(val), MIB_VALUE_TYPE_INT,
+				       &val );
+		break;
+	case SME_WEP_INDEX_REQUEST: case SME_WEP_KEY1_REQUEST:
+	case SME_WEP_KEY2_REQUEST:  case SME_WEP_KEY3_REQUEST:
+	case SME_WEP_KEY4_REQUEST:  case SME_WEP_FLAG_REQUEST:
+		hostif_sme_set_wep(priv,event);
+		break;
+	case SME_RSN_UCAST_REQUEST: case SME_RSN_MCAST_REQUEST:
+	case SME_RSN_AUTH_REQUEST: case SME_RSN_ENABLED_REQUEST:
+	case SME_RSN_MODE_REQUEST:
+		hostif_sme_set_rsn(priv,event);
+		break;
+	case SME_SET_FLAG:    case SME_SET_TXKEY:
+	case SME_SET_KEY1:    case SME_SET_KEY2:
+	case SME_SET_KEY3:    case SME_SET_KEY4:
+	case SME_SET_PMK_TSC: case SME_SET_GMK1_TSC:
+	case SME_SET_GMK2_TSC:
+		hostif_sme_set_key(priv,event);
+		break;
+	case SME_SET_PMKSA:
+		hostif_sme_set_pmksa(priv);
+		break;
+#ifdef WPS
+	case SME_WPS_ENABLE_REQUEST:
+		hostif_mib_set_request(priv, LOCAL_WPS_ENABLE,
+				       sizeof(priv->wps.wps_enabled),
+				       MIB_VALUE_TYPE_INT, &priv->wps.wps_enabled );
+		break;
+	case SME_WPS_PROBE_REQUEST:
+		hostif_mib_set_request(priv, LOCAL_WPS_PROBE_REQ,
+				       priv->wps.ielen,
+				       MIB_VALUE_TYPE_OSTRING, priv->wps.ie);
+		break;
+#endif /* WPS */
+	case SME_MODE_SET_REQUEST:
+		hostif_sme_mode_setup(priv);
+		break;
+	case SME_SET_GAIN:
+		hostif_mib_set_request(priv, LOCAL_GAIN,
+				       sizeof(priv->gain), MIB_VALUE_TYPE_OSTRING,
+				       &priv->gain);
+		break;
+	case SME_GET_GAIN:
+		hostif_mib_get_request(priv, LOCAL_GAIN);
+		break;
+	case SME_GET_EEPROM_CKSUM:
+		priv->eeprom_checksum = EEPROM_FW_NOT_SUPPORT;	/* initialize */
+		hostif_mib_get_request(priv, LOCAL_EEPROM_SUM);
+		break;
+	case SME_START_REQUEST:
+		hostif_start_request( priv, priv->reg.operation_mode );
+		break;
+	case SME_START_CONFIRM:
+		/* for power save */
+		atomic_set(&priv->psstatus.snooze_guard, 0);
+		atomic_set(&priv->psstatus.confirm_wait,0);
+#if !defined(_SDIO_)
+		atomic_set(&priv->psstatus.status, PS_NONE);
+#endif
+		if ( priv->dev_state == DEVICE_STATE_PREINIT ){
+			priv->dev_state = DEVICE_STATE_INIT;
+		}
+		/* wake_up_interruptible_all(&priv->confirm_wait); */
+		complete(&priv->confirm_wait);
+		break;
+	case SME_SLEEP_REQUEST:
+		hostif_sme_sleep_set(priv);
+		break;
+	case SME_SET_REGION:
+		val = cpu_to_le32((uint32_t)(priv->region));
+		hostif_mib_set_request(priv, LOCAL_REGION,
+				       sizeof(val), MIB_VALUE_TYPE_INT,
+				       &val );
+		break;
+	case SME_MULTICAST_CONFIRM:
+	case SME_BSS_SCAN_CONFIRM:
+	case SME_POW_MNGMT_CONFIRM:
+	case SME_PHY_INFO_CONFIRM:
+	case SME_STOP_CONFIRM:
+	case SME_RTS_THRESHOLD_CONFIRM:
+	case SME_FRAGMENTATION_THRESHOLD_CONFIRM:
+	case SME_WEP_INDEX_CONFIRM: case SME_WEP_KEY1_CONFIRM:
+	case SME_WEP_KEY2_CONFIRM:  case SME_WEP_KEY3_CONFIRM:
+	case SME_WEP_KEY4_CONFIRM:  case SME_WEP_FLAG_CONFIRM:
+	case SME_RSN_UCAST_CONFIRM: case SME_RSN_MCAST_CONFIRM:
+	case SME_RSN_AUTH_CONFIRM:  case SME_RSN_ENABLED_CONFIRM:
+	case SME_RSN_MODE_CONFIRM:
+	case SME_MODE_SET_CONFIRM:
+		break;
+	case SME_TERMINATE:
+	default:
+		break;
+	}
+}
+
+static
+void hostif_sme_task( unsigned long dev )
+{
+	ks_wlan_private	*priv = (ks_wlan_private *)dev;
+
+	DPRINTK(3,"\n");
+
+	if(priv->dev_state >= DEVICE_STATE_BOOT){
+		if (0 < cnt_smeqbody(priv) && priv->dev_state >= DEVICE_STATE_BOOT) {
+			hostif_sme_execute(priv, priv->sme_i.event_buff[priv->sme_i.qhead]);
+			inc_smeqhead(priv);
+			if (0 < cnt_smeqbody(priv))
+			        tasklet_schedule(&priv->sme_task);
+		}
+	}
+	return;
+}
+
+/* send to Station Management Entity module */
+void hostif_sme_enqueue(ks_wlan_private *priv, unsigned short event)
+{
+	DPRINTK(3,"\n");
+
+#if !defined(_SDIO_)
+	if(atomic_read(&priv->psstatus.status)==PS_SNOOZE && event < SME_START_CONFIRM){ /* power save wakeup*/
+		schedule_work(&priv->ks_wlan_wakeup_task);
+		if(atomic_read(&priv->sme_task.count) <= 0){
+			/* schedule_work(&priv->ks_wlan_wakeup_task); */
+			DPRINTK(4,"sme task disable.\n");
+			tasklet_disable(&priv->sme_task);
+		}
+	}
+#endif
+
+
+	/* enqueue sme event */
+	if (cnt_smeqbody(priv) < (SME_EVENT_BUFF_SIZE - 1)) {
+		priv->sme_i.event_buff[priv->sme_i.qtail] = event;
+		inc_smeqtail(priv);
+		//DPRINTK(3,"inc_smeqtail \n");
+#ifdef KS_WLAN_DEBUG
+		if (priv->sme_i.max_event_count < cnt_smeqbody(priv))
+			priv->sme_i.max_event_count = cnt_smeqbody(priv);
+#endif /* KS_WLAN_DEBUG */
+	} else {
+		/* in case of buffer overflow */
+		//DPRINTK(2,"sme queue buffer overflow\n");
+		printk("sme queue buffer overflow\n");
+	}
+
+	tasklet_schedule(&priv->sme_task);
+
+}
+
+int hostif_init( ks_wlan_private *priv )
+{
+	int rc=0;
+	int i;
+
+	DPRINTK(3,"\n");
+
+	priv->aplist.size =0;
+	for(i=0;i<LOCAL_APLIST_MAX;i++)
+		memset(&(priv->aplist.ap[i]),0,sizeof(struct local_ap_t));
+	priv->infra_status = 0;
+	priv->current_rate = 4;
+	priv->connect_status = DISCONNECT_STATUS;
+
+	spin_lock_init(&priv->multicast_spin);
+
+	spin_lock_init(&priv->dev_read_lock);
+	init_waitqueue_head (&priv->devread_wait);
+	priv->dev_count = 0;
+	atomic_set(&priv->event_count, 0);
+	atomic_set(&priv->rec_count, 0);
+
+	/* for power save */
+	atomic_set(&priv->psstatus.status, PS_NONE);
+	atomic_set(&priv->psstatus.confirm_wait, 0);
+	atomic_set(&priv->psstatus.snooze_guard, 0);
+	/* init_waitqueue_head(&priv->psstatus.wakeup_wait); */
+	init_completion(&priv->psstatus.wakeup_wait);
+	//INIT_WORK(&priv->ks_wlan_wakeup_task, ks_wlan_hw_wakeup_task, (void *)priv);
+	INIT_WORK(&priv->ks_wlan_wakeup_task, ks_wlan_hw_wakeup_task);
+
+	/* WPA */
+	memset(&(priv->wpa), 0, sizeof(priv->wpa));
+	priv->wpa.rsn_enabled = 0;
+	priv->wpa.mic_failure.failure = 0;
+	priv->wpa.mic_failure.last_failure_time = 0;
+	priv->wpa.mic_failure.stop = 0;
+	memset(&(priv->pmklist), 0, sizeof(priv->pmklist));
+	INIT_LIST_HEAD(&priv->pmklist.head);
+	for(i=0;i<PMK_LIST_MAX;i++)
+		INIT_LIST_HEAD(&priv->pmklist.pmk[i].list);
+
+	priv->sme_i.sme_status = SME_IDLE;
+	priv->sme_i.qhead = priv->sme_i.qtail = 0;
+#ifdef KS_WLAN_DEBUG
+	priv->sme_i.max_event_count = 0;
+#endif
+        spin_lock_init(&priv->sme_i.sme_spin);
+	priv->sme_i.sme_flag = 0;
+
+	tasklet_init(&priv->sme_task, hostif_sme_task, (unsigned long)priv);
+
+	return rc;
+}
+
+void hostif_exit( ks_wlan_private *priv )
+{
+	tasklet_kill(&priv->sme_task);
+	return;
+}
+
