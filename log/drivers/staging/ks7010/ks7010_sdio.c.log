commit a5e7d27e2d7d2ae090729b5d94c35c082b85dc6d
Author: Payal Kshirsagar <payalskshirsagar1234@gmail.com>
Date:   Sun Mar 8 18:08:34 2020 +0530

    staging: ks7010: remove line over 80 characters
    
    Remove line over 80 characters.
    
    Signed-off-by: Payal Kshirsagar <payalskshirsagar1234@gmail.com>
    Reviewed-by: Stefano Brivio <sbrivio@redhat.com>
    Link: https://lore.kernel.org/r/20200308123834.3377-1-payalskshirsagar1234@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 4b379542ecd5..6b2660c94f4e 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -446,7 +446,8 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, size_t size)
 				     DUMP_PREFIX_OFFSET,
 				     rx_buffer->data, 32);
 #endif
-		ret = ks7010_sdio_writeb(priv, READ_STATUS_REG, REG_STATUS_IDLE);
+		ret = ks7010_sdio_writeb(priv, READ_STATUS_REG,
+					 REG_STATUS_IDLE);
 		if (ret)
 			netdev_err(priv->net_dev, "write READ_STATUS_REG\n");
 

commit 0fce66606ef91ff23b69217dfa0f10e2704e1224
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri May 24 14:28:42 2019 +0530

    staging: ks7010: Remove initialisation in ks7010_sdio.c
    
    As the initial value of the return variable result is never used, it can
    be removed.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 74551eb717fc..4b379542ecd5 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -380,7 +380,7 @@ int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
 					   struct sk_buff *skb),
 		  struct sk_buff *skb)
 {
-	int result = 0;
+	int result;
 	struct hostif_hdr *hdr;
 
 	hdr = (struct hostif_hdr *)p;

commit b2d187cc765afd4bad6b66664c099c804dda1432
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed May 16 13:25:55 2018 +0200

    staging: ks7010: avoid casting inside cpu_to_* assignments
    
    cpu_to_*() functions already have a cast to u* built in,
    so the cast is never required. Review and remove all of
    them along the code.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index e9047400254f..74551eb717fc 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1061,8 +1061,8 @@ static int send_stop_request(struct sdio_func *func)
 		return -ENOMEM;
 
 	size = sizeof(*pp) - sizeof(pp->header.size);
-	pp->header.size = cpu_to_le16((u16)size);
-	pp->header.event = cpu_to_le16((u16)HIF_STOP_REQ);
+	pp->header.size = cpu_to_le16(size);
+	pp->header.event = cpu_to_le16(HIF_STOP_REQ);
 
 	sdio_claim_host(func);
 	write_to_device(card->priv, (u8 *)pp, hif_align_size(sizeof(*pp)));

commit 89467e74aae4ab6c73514d4a54c23c6080cec5da
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:40 2018 +0200

    staging: ks7010: change parameter type in ks_wlan_hw_rx function
    
    The parameter 'size' in function ks_wlan_hw_rx is declared as
    uint16_t and can be declared as size_t which makes more sense.
    It is being passed to hif_align_size function which also expects
    a size_t as parameter so just change its type. Also update two
    casts in calls to this function.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index a51b5e8d1a56..e9047400254f 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -420,7 +420,7 @@ static void rx_event_task(unsigned long dev)
 	}
 }
 
-static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
+static void ks_wlan_hw_rx(struct ks_wlan_private *priv, size_t size)
 {
 	int ret;
 	struct rx_device_buffer *rx_buffer;
@@ -526,7 +526,7 @@ static void ks7010_rw_function(struct work_struct *work)
 	}
 
 	if (byte & RSIZE_MASK) {	/* Read schedule */
-		ks_wlan_hw_rx(priv, (uint16_t)((byte & RSIZE_MASK) << 4));
+		ks_wlan_hw_rx(priv, (size_t)((byte & RSIZE_MASK) << 4));
 	}
 	if ((byte & WSTATUS_MASK))
 		tx_device_task(priv);
@@ -586,7 +586,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 		}
 		rsize = byte & RSIZE_MASK;
 		if (rsize != 0)		/* Read schedule */
-			ks_wlan_hw_rx(priv, (uint16_t)(rsize << 4));
+			ks_wlan_hw_rx(priv, (size_t)(rsize << 4));
 
 		if (byte & WSTATUS_MASK) {
 			if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {

commit 83911837f892ecd5c77c5cdafab569ea018be641
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:39 2018 +0200

    staging: ks7010: change cast from uint16_t to u16
    
    Header size and event fields of header are declared
    as __le16 and being casted using uint16_t in cpu_to_le16.
    Change cast to use preferred u16.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index f56db0772b45..a51b5e8d1a56 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1061,8 +1061,8 @@ static int send_stop_request(struct sdio_func *func)
 		return -ENOMEM;
 
 	size = sizeof(*pp) - sizeof(pp->header.size);
-	pp->header.size = cpu_to_le16((uint16_t)size);
-	pp->header.event = cpu_to_le16((uint16_t)HIF_STOP_REQ);
+	pp->header.size = cpu_to_le16((u16)size);
+	pp->header.event = cpu_to_le16((u16)HIF_STOP_REQ);
 
 	sdio_claim_host(func);
 	write_to_device(card->priv, (u8 *)pp, hif_align_size(sizeof(*pp)));

commit 62a37b72ced4f73d605c1a8654417c5f1625ce06
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:38 2018 +0200

    staging: ks7010: replace unsigned char type with u8
    
    Variable 'byte' in ks7010_upload_firmware function is declared
    as unsigned char and is only being used to read hardware
    registers which are expected in sdio_read_byteb function as u8.
    Change 'byte' variable type to u8 which is preferred.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index d236dfec3359..f56db0772b45 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -752,7 +752,7 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	struct ks_wlan_private *priv = card->priv;
 	struct sdio_func *func = ks7010_to_func(priv);
 	unsigned int n;
-	unsigned char byte = 0;
+	u8 byte = 0;
 	int ret;
 	const struct firmware *fw_entry = NULL;
 

commit 449f9eefa19c7255913db2ef10980982d3e79c0c
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:37 2018 +0200

    staging: ks7010: remove no necessary blank line
    
    There was two blank lines between definitions and statements
    in ks7010_upload_firmware function. Remove one of them.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 0b1e35217e1f..d236dfec3359 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -756,7 +756,6 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	int ret;
 	const struct firmware *fw_entry = NULL;
 
-
 	sdio_claim_host(func);
 
 	/* Firmware running ? */

commit 3c6b759189c77b7fa656ac474b7b8a147a0e4757
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:17 2018 +0200

    staging: ks7010: change local variable type in ks_wlan_hw_rx
    
    Local variable event in ks_wlan_hw_rx function is declared
    as unsigned short and can be declared as u16 which is preferred
    style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 0c487ed2da3e..0b1e35217e1f 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -425,7 +425,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 	int ret;
 	struct rx_device_buffer *rx_buffer;
 	struct hostif_hdr *hdr;
-	unsigned short event = 0;
+	u16 event = 0;
 
 	/* receive data */
 	if (rxq_count(priv) >= (RX_DEVICE_BUFF_SIZE - 1)) {

commit f0d5a975e2acf4ac310ba13bc3b4df6a5fb8398d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:16 2018 +0200

    staging: ks7010: refactor ks7010_sme_enqueue_events function
    
    Event to send to init the card are always the same so change
    code to be more readable putting them into an array and
    enqueuing also using a for loop.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 9085ed752411..0c487ed2da3e 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -806,24 +806,19 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 
 static void ks7010_sme_enqueue_events(struct ks_wlan_private *priv)
 {
-	hostif_sme_enqueue(priv, SME_GET_EEPROM_CKSUM);
-
-	/* load initial wireless parameter */
-	hostif_sme_enqueue(priv, SME_STOP_REQUEST);
-
-	hostif_sme_enqueue(priv, SME_RTS_THRESHOLD_REQUEST);
-	hostif_sme_enqueue(priv, SME_FRAGMENTATION_THRESHOLD_REQUEST);
-
-	hostif_sme_enqueue(priv, SME_WEP_INDEX_REQUEST);
-	hostif_sme_enqueue(priv, SME_WEP_KEY1_REQUEST);
-	hostif_sme_enqueue(priv, SME_WEP_KEY2_REQUEST);
-	hostif_sme_enqueue(priv, SME_WEP_KEY3_REQUEST);
-	hostif_sme_enqueue(priv, SME_WEP_KEY4_REQUEST);
-
-	hostif_sme_enqueue(priv, SME_WEP_FLAG_REQUEST);
-	hostif_sme_enqueue(priv, SME_RSN_ENABLED_REQUEST);
-	hostif_sme_enqueue(priv, SME_MODE_SET_REQUEST);
-	hostif_sme_enqueue(priv, SME_START_REQUEST);
+	static const u16 init_events[] = {
+		SME_GET_EEPROM_CKSUM, SME_STOP_REQUEST,
+		SME_RTS_THRESHOLD_REQUEST, SME_FRAGMENTATION_THRESHOLD_REQUEST,
+		SME_WEP_INDEX_REQUEST, SME_WEP_KEY1_REQUEST,
+		SME_WEP_KEY2_REQUEST, SME_WEP_KEY3_REQUEST,
+		SME_WEP_KEY4_REQUEST, SME_WEP_FLAG_REQUEST,
+		SME_RSN_ENABLED_REQUEST, SME_MODE_SET_REQUEST,
+		SME_START_REQUEST
+	};
+	int ev;
+
+	for (ev = 0; ev < ARRAY_SIZE(init_events); ev++)
+		hostif_sme_enqueue(priv, init_events[ev]);
 }
 
 static void ks7010_card_init(struct ks_wlan_private *priv)

commit 58f8128eccbcdf0dff8e82925284b023002b7fae
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:14 2018 +0200

    staging: ks7010: change local variable type in ks7010_sdio_init_irqs
    
    Local variable 'byte' in ks7010_sdio_init_irqs is declared as
    unsigned char and can be declared as u8 which is preferred.
    It is being used in calls to ks7010_sdio_writeb which is already
    expected an u8.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index db954f148fd0..9085ed752411 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -904,7 +904,7 @@ static int ks7010_sdio_setup_irqs(struct sdio_func *func)
 static void ks7010_sdio_init_irqs(struct sdio_func *func,
 				  struct ks_wlan_private *priv)
 {
-	unsigned char byte;
+	u8 byte;
 	int ret;
 
 	/*

commit 29699193df74cf993e4eee37709ec12cf7def743
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:13 2018 +0200

    staging: ks7010: change some local variables type in ks_sdio_interrupt
    
    Local variables 'status', 'rsize' and 'byte' are declared as
    unsigned char and can be declared as u8 which is preferred.
    They are being used in ks7010_sdio_readb calls which is already
    expected an u8.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index dab44bb7a1c9..db954f148fd0 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -542,7 +542,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	int ret;
 	struct ks_sdio_card *card;
 	struct ks_wlan_private *priv;
-	unsigned char status, rsize, byte;
+	u8 status, rsize, byte;
 
 	card = sdio_get_drvdata(func);
 	priv = card->priv;

commit a51333d17578c63621c0ef5aa24eaabdec094c1e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:12 2018 +0200

    staging: ks7010: change local variable type in ks7010_rw_function
    
    Local variable 'byte' in ks7010_rw_function is declared as unsigned
    char and can be declared as u8 which is preferred. It is being used
    in ks7010_sdio_readb which is already expecting an u8.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 3574a2292021..dab44bb7a1c9 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -477,7 +477,7 @@ static void ks7010_rw_function(struct work_struct *work)
 						    struct ks_wlan_private,
 						    rw_dwork.work);
 	struct sdio_func *func = ks7010_to_func(priv);
-	unsigned char byte;
+	u8 byte;
 	int ret;
 
 	/* wait after DOZE */

commit 9d418fa883b4cee9c20fba35b9c93d1680c79ccc
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:11 2018 +0200

    staging: ks7010: change local variable type in _ks_wlan_hw_power_save
    
    Local variable 'byte' in _ks_wlan_hw_power_save function is declared
    as unsigned char and can be declared as u8 which is preferred. It
    is being using with ks7010_sdio_readb which expects u8 already.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 71e12d62feeb..3574a2292021 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -217,7 +217,7 @@ void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 
 static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 {
-	unsigned char byte;
+	u8 byte;
 	int ret;
 
 	if (priv->reg.power_mgmt == POWER_MGMT_ACTIVE)

commit 49705f9a0ddd5bc4b694fae9bcfe03a2c0eb9cdd
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:10 2018 +0200

    staging: ks7010: use u8 instead of unsigned char in write_to_device function
    
    Parameter buffer in write_to_device function is declared as
    a pointer to unsigned char and can be declared as an u8 type
    which is preferred. Internally it calls to ks7010_sdio_write
    which is using also u8 as parameter type. Update calls to this
    function as well.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 078f37e7ac4e..71e12d62feeb 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -318,7 +318,7 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 }
 
 /* write data */
-static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
+static int write_to_device(struct ks_wlan_private *priv, u8 *buffer,
 			   unsigned long size)
 {
 	struct hostif_hdr *hdr;
@@ -1071,8 +1071,7 @@ static int send_stop_request(struct sdio_func *func)
 	pp->header.event = cpu_to_le16((uint16_t)HIF_STOP_REQ);
 
 	sdio_claim_host(func);
-	write_to_device(card->priv, (unsigned char *)pp,
-			hif_align_size(sizeof(*pp)));
+	write_to_device(card->priv, (u8 *)pp, hif_align_size(sizeof(*pp)));
 	sdio_release_host(func);
 
 	kfree(pp);

commit 832ec535590fb705659b66e194cfe452144fa8cd
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:08 2018 +0200

    staging: ks7010: change netdev_dbg msg to avoid a long line
    
    This commit avoids a long line changing a bit message in
    _ks_wlan_hw_power_save function.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index d71c82612d29..078f37e7ac4e 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -235,7 +235,12 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE)
 		return;
 
-	netdev_dbg(priv->net_dev, "\npsstatus.status=%d\npsstatus.confirm_wait=%d\npsstatus.snooze_guard=%d\ncnt_txqbody=%d\n",
+	netdev_dbg(priv->net_dev,
+		   "STATUS:\n"
+		   "- psstatus.status = %d\n"
+		   "- psstatus.confirm_wait = %d\n"
+		   "- psstatus.snooze_guard = %d\n"
+		   "- txq_count = %d\n",
 		   atomic_read(&priv->psstatus.status),
 		   atomic_read(&priv->psstatus.confirm_wait),
 		   atomic_read(&priv->psstatus.snooze_guard),

commit 075116293e8b2ea6365f0b98963d925486900b58
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:07 2018 +0200

    staging: ks7010: avoid ks_sdio_card dependency in ks_wlan header
    
    ks_wlan_private struct has a pointer to struct ks_sdio_card in its
    fields. Because of that a forward declaration in needed in ks_wlan.h
    header and also it makes necessary to have ks_sdio_card public in
    a ks7010_sdio.h header. Changing this pointer into a void pointer
    makes no longer necessary to have ks7010_sdio.h header as well as
    removes the forward dependency in ks_wlan.h. Declaration of
    ks_sdio_card has been moved to ks7010_sdio.c source file and To make
    code cleaner inside this file a new ks7010_to_func function has been
    added. The code has been updated to this changes.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 9c22a7672f6c..d71c82612d29 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -16,7 +16,6 @@
 #include <linux/workqueue.h>
 #include "ks_wlan.h"
 #include "ks_hostif.h"
-#include "ks7010_sdio.h"
 
 #define ROM_FILE "ks7010sd.rom"
 
@@ -97,11 +96,31 @@ enum gen_com_reg_b {
 
 #define KS7010_IO_BLOCK_SIZE 512
 
+/**
+ * struct ks_sdio_card - SDIO device data.
+ *
+ * Structure is used as the &struct sdio_func private data.
+ *
+ * @func: Pointer to the SDIO function device.
+ * @priv: Pointer to the &struct net_device private data.
+ */
+struct ks_sdio_card {
+	struct sdio_func *func;
+	struct ks_wlan_private *priv;
+};
+
+static struct sdio_func *ks7010_to_func(struct ks_wlan_private *priv)
+{
+	struct ks_sdio_card *ks_sdio = priv->if_hw;
+
+	return ks_sdio->func;
+}
+
 /* Read single byte from device address into byte (CMD52) */
 static int ks7010_sdio_readb(struct ks_wlan_private *priv,
 			     u32 address, u8 *byte)
 {
-	struct sdio_func *func = priv->ks_sdio_card->func;
+	struct sdio_func *func = ks7010_to_func(priv);
 	int ret;
 
 	*byte = sdio_readb(func, address, &ret);
@@ -113,7 +132,7 @@ static int ks7010_sdio_readb(struct ks_wlan_private *priv,
 static int ks7010_sdio_read(struct ks_wlan_private *priv, u32 address,
 			    u8 *buffer, unsigned int length)
 {
-	struct sdio_func *func = priv->ks_sdio_card->func;
+	struct sdio_func *func = ks7010_to_func(priv);
 
 	return sdio_memcpy_fromio(func, buffer, address, length);
 }
@@ -122,7 +141,7 @@ static int ks7010_sdio_read(struct ks_wlan_private *priv, u32 address,
 static int ks7010_sdio_writeb(struct ks_wlan_private *priv,
 			      u32 address, u8 byte)
 {
-	struct sdio_func *func = priv->ks_sdio_card->func;
+	struct sdio_func *func = ks7010_to_func(priv);
 	int ret;
 
 	sdio_writeb(func, byte, address, &ret);
@@ -134,7 +153,7 @@ static int ks7010_sdio_writeb(struct ks_wlan_private *priv,
 static int ks7010_sdio_write(struct ks_wlan_private *priv, u32 address,
 			     u8 *buffer, unsigned int length)
 {
-	struct sdio_func *func = priv->ks_sdio_card->func;
+	struct sdio_func *func = ks7010_to_func(priv);
 
 	return sdio_memcpy_toio(func, address, buffer, length);
 }
@@ -449,12 +468,13 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 
 static void ks7010_rw_function(struct work_struct *work)
 {
-	struct ks_wlan_private *priv;
+	struct ks_wlan_private *priv = container_of(work,
+						    struct ks_wlan_private,
+						    rw_dwork.work);
+	struct sdio_func *func = ks7010_to_func(priv);
 	unsigned char byte;
 	int ret;
 
-	priv = container_of(work, struct ks_wlan_private, rw_dwork.work);
-
 	/* wait after DOZE */
 	if (time_after(priv->last_doze + msecs_to_jiffies(30), jiffies)) {
 		netdev_dbg(priv->net_dev, "wait after DOZE\n");
@@ -465,13 +485,12 @@ static void ks7010_rw_function(struct work_struct *work)
 	/* wait after WAKEUP */
 	while (time_after(priv->last_wakeup + msecs_to_jiffies(30), jiffies)) {
 		netdev_dbg(priv->net_dev, "wait after WAKEUP\n");
-		dev_info(&priv->ks_sdio_card->func->dev,
-			 "wake: %lu %lu\n",
+		dev_info(&func->dev, "wake: %lu %lu\n",
 			 priv->last_wakeup + msecs_to_jiffies(30), jiffies);
 		msleep(30);
 	}
 
-	sdio_claim_host(priv->ks_sdio_card->func);
+	sdio_claim_host(func);
 
 	/* power save wakeup */
 	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
@@ -510,7 +529,7 @@ static void ks7010_rw_function(struct work_struct *work)
 	_ks_wlan_hw_power_save(priv);
 
 release_host:
-	sdio_release_host(priv->ks_sdio_card->func);
+	sdio_release_host(func);
 }
 
 static void ks_sdio_interrupt(struct sdio_func *func)
@@ -726,13 +745,14 @@ static int ks7010_copy_firmware(struct ks_wlan_private *priv,
 static int ks7010_upload_firmware(struct ks_sdio_card *card)
 {
 	struct ks_wlan_private *priv = card->priv;
+	struct sdio_func *func = ks7010_to_func(priv);
 	unsigned int n;
 	unsigned char byte = 0;
 	int ret;
 	const struct firmware *fw_entry = NULL;
 
 
-	sdio_claim_host(card->func);
+	sdio_claim_host(func);
 
 	/* Firmware running ? */
 	ret = ks7010_sdio_readb(priv, GCR_A_REG, &byte);
@@ -745,7 +765,7 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	}
 
 	ret = request_firmware(&fw_entry, ROM_FILE,
-			       &priv->ks_sdio_card->func->dev);
+			       &func->dev);
 	if (ret)
 		goto release_host;
 
@@ -774,7 +794,7 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
  release_firmware:
 	release_firmware(fw_entry);
  release_host:
-	sdio_release_host(card->func);
+	sdio_release_host(func);
 
 	return ret;
 }
@@ -907,7 +927,7 @@ static void ks7010_private_init(struct ks_wlan_private *priv,
 				struct net_device *netdev)
 {
 	/* private memory initialize */
-	priv->ks_sdio_card = card;
+	priv->if_hw = card;
 
 	priv->dev_state = DEVICE_STATE_PREBOOT;
 	priv->net_dev = netdev;

commit 57c6f08dfe27b81cf39f4b7d1d4a24bb1f49477b
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:06 2018 +0200

    staging: ks7010: move tx and rx queues definitions into ks_wlan.h header
    
    There are some definitions for rx and tx queues in ks7010_sdio
    which is not the best place to put them. Changing them into the
    ks_wlan header file there is no need to explicity include ks7010_sdio.h
    which makes no sense at all and can be resolved easily using
    forward declarations. The functions related with the queues circular
    buffers have been moved also into this header.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 6a5565d479ac..9c22a7672f6c 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -8,7 +8,6 @@
  */
 
 #include <linux/atomic.h>
-#include <linux/circ_buf.h>
 #include <linux/firmware.h>
 #include <linux/jiffies.h>
 #include <linux/mmc/card.h>
@@ -98,50 +97,6 @@ enum gen_com_reg_b {
 
 #define KS7010_IO_BLOCK_SIZE 512
 
-static inline void inc_txqhead(struct ks_wlan_private *priv)
-{
-	priv->tx_dev.qhead = (priv->tx_dev.qhead + 1) % TX_DEVICE_BUFF_SIZE;
-}
-
-static inline void inc_txqtail(struct ks_wlan_private *priv)
-{
-	priv->tx_dev.qtail = (priv->tx_dev.qtail + 1) % TX_DEVICE_BUFF_SIZE;
-}
-
-static inline bool txq_has_space(struct ks_wlan_private *priv)
-{
-	return (CIRC_SPACE(priv->tx_dev.qhead, priv->tx_dev.qtail,
-			   TX_DEVICE_BUFF_SIZE) > 0);
-}
-
-static inline void inc_rxqhead(struct ks_wlan_private *priv)
-{
-	priv->rx_dev.qhead = (priv->rx_dev.qhead + 1) % RX_DEVICE_BUFF_SIZE;
-}
-
-static inline void inc_rxqtail(struct ks_wlan_private *priv)
-{
-	priv->rx_dev.qtail = (priv->rx_dev.qtail + 1) % RX_DEVICE_BUFF_SIZE;
-}
-
-static inline bool rxq_has_space(struct ks_wlan_private *priv)
-{
-	return (CIRC_SPACE(priv->rx_dev.qhead, priv->rx_dev.qtail,
-			   RX_DEVICE_BUFF_SIZE) > 0);
-}
-
-static inline unsigned int txq_count(struct ks_wlan_private *priv)
-{
-	return CIRC_CNT_TO_END(priv->tx_dev.qhead, priv->tx_dev.qtail,
-			       TX_DEVICE_BUFF_SIZE);
-}
-
-static inline unsigned int rxq_count(struct ks_wlan_private *priv)
-{
-	return CIRC_CNT_TO_END(priv->rx_dev.qhead, priv->rx_dev.qtail,
-			       RX_DEVICE_BUFF_SIZE);
-}
-
 /* Read single byte from device address into byte (CMD52) */
 static int ks7010_sdio_readb(struct ks_wlan_private *priv,
 			     u32 address, u8 *byte)

commit a0a954b151d037e8cbf8822eb56a1a79c4caed30
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:05 2018 +0200

    staging: ks7010: add SPDX identifiers to all files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the all of the staging ks7010 files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    Extra GPL text wording can be removed as it is no longer needed at all.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index b29f48c421cc..6a5565d479ac 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *   Driver for KeyStream, KS7010 based SDIO cards.
  *
  *   Copyright (C) 2006-2008 KeyStream Corp.
  *   Copyright (C) 2009 Renesas Technology Corp.
  *   Copyright (C) 2016 Sang Engineering, Wolfram Sang
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License version 2 as
- *   published by the Free Software Foundation.
  */
 
 #include <linux/atomic.h>

commit 06176b874a2e25343ffe4ed83c3c4d6290e97cf0
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:47 2018 +0200

    staging: ks7010: assign dev_alloc_name() result to variable before check it
    
    This commit assigns dev_alloc_name() call to 'ret' variable to
    check it after instead of check directly the call in the if
    condition. This improves a bit readability. It also add an empty
    line before the new assignment to separate it from the previous
    check statement block.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 130e0be284db..b29f48c421cc 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1021,7 +1021,9 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 		dev_err(&card->func->dev, "Unable to alloc new net device\n");
 		goto err_release_irq;
 	}
-	if (dev_alloc_name(netdev, "wlan%d") < 0) {
+
+	ret = dev_alloc_name(netdev, "wlan%d");
+	if (ret < 0) {
 		dev_err(&card->func->dev, "Couldn't get name!\n");
 		goto err_free_netdev;
 	}

commit a7360b184b47077ff60293d6b211c637e016ff75
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:46 2018 +0200

    staging: ks7010: use u8 instead of unsigned char for firmware buffers
    
    This commit replaces type unsigned char which is the one which
    is being used for firmware buffers with u8 type which is preferred.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 5293b48c3086..130e0be284db 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -689,10 +689,10 @@ static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 
 #define ROM_BUFF_SIZE (64 * 1024)
 static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
-				    unsigned char *data, unsigned int size)
+				    u8 *data, unsigned int size)
 {
 	int ret;
-	unsigned char *read_buf;
+	u8 *read_buf;
 
 	read_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
 	if (!read_buf)
@@ -723,7 +723,7 @@ static int ks7010_copy_firmware(struct ks_wlan_private *priv,
 	unsigned int size;
 	unsigned int offset;
 	unsigned int n = 0;
-	unsigned char *rom_buf;
+	u8 *rom_buf;
 	int ret;
 
 	rom_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);

commit 0cc053ddd47c217abb500bb65ffdadd12d878700
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:45 2018 +0200

    staging: ks7010: fix error paths in ks7010_sdio_remove function
    
    This commit reviews and fixes error paths in ks7010_sdio_remove
    driver function. It change logic to handle error directly
    after priv dereference to avoid one level indentation. It also
    removes a temporal netdev variable which wasn't being used in all
    of the function calls. Also if send_stop_request call fails it
    was making a direct 'return' instead of doing a properly cleaning.
    Because of this a new 'err_free_card' label has been added.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 1d569ef96f45..5293b48c3086 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1112,39 +1112,39 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 		return;
 
 	priv = card->priv;
-	if (priv) {
-		struct net_device *netdev = priv->net_dev;
+	if (!priv)
+		goto err_free_card;
 
-		ks_wlan_net_stop(netdev);
+	ks_wlan_net_stop(priv->net_dev);
 
-		/* interrupt disable */
-		sdio_claim_host(func);
-		sdio_writeb(func, 0, INT_ENABLE_REG, &ret);
-		sdio_writeb(func, 0xff, INT_PENDING_REG, &ret);
-		sdio_release_host(func);
+	/* interrupt disable */
+	sdio_claim_host(func);
+	sdio_writeb(func, 0, INT_ENABLE_REG, &ret);
+	sdio_writeb(func, 0xff, INT_PENDING_REG, &ret);
+	sdio_release_host(func);
 
-		ret = send_stop_request(func);
-		if (ret)	/* memory allocation failure */
-			return;
+	ret = send_stop_request(func);
+	if (ret)	/* memory allocation failure */
+		goto err_free_card;
 
-		if (priv->wq) {
-			flush_workqueue(priv->wq);
-			destroy_workqueue(priv->wq);
-		}
+	if (priv->wq) {
+		flush_workqueue(priv->wq);
+		destroy_workqueue(priv->wq);
+	}
 
-		hostif_exit(priv);
+	hostif_exit(priv);
 
-		unregister_netdev(netdev);
+	unregister_netdev(priv->net_dev);
 
-		trx_device_exit(priv);
-		free_netdev(priv->net_dev);
-		card->priv = NULL;
-	}
+	trx_device_exit(priv);
+	free_netdev(priv->net_dev);
+	card->priv = NULL;
 
 	sdio_claim_host(func);
 	sdio_release_irq(func);
 	sdio_disable_func(func);
 	sdio_release_host(func);
+err_free_card:
 	sdio_set_drvdata(func, NULL);
 	kfree(card);
 }

commit 31d7b1b142a17764ab9f21e37c02163b518d571b
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:44 2018 +0200

    staging: ks7010: check sdio_set_block_size return value
    
    This commit checks sdio_set_block_size function return value.
    If it fails abort driver initialization.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index fe4beb04f010..1d569ef96f45 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -994,6 +994,9 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	sdio_claim_host(func);
 
 	ret = sdio_set_block_size(func, KS7010_IO_BLOCK_SIZE);
+	if (ret)
+		goto err_free_card;
+
 	dev_dbg(&card->func->dev, "multi_block=%d sdio_set_block_size()=%d %d\n",
 		func->card->cccr.multi_block, func->cur_blksize, ret);
 

commit 4487cf88f8371f5ae4375dc26b0c697047e2121c
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:43 2018 +0200

    staging: ks7010: replace create_workqueue with alloc_workqueue
    
    This commit replaces deprecated create_workqueue call with the
    alloc_workqueue one which is the one to be used now for this
    purpose.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 31022e40d8ed..fe4beb04f010 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1041,7 +1041,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 
 	priv->dev_state = DEVICE_STATE_BOOT;
 
-	priv->wq = create_workqueue("wq");
+	priv->wq = alloc_workqueue("wq", WQ_MEM_RECLAIM, 1);
 	if (!priv->wq) {
 		netdev_err(priv->net_dev, "create_workqueue failed !!\n");
 		goto err_free_netdev;

commit 78c74a5fe1fe89e6c6acc69f2448655b0e65f54a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:42 2018 +0200

    staging: ks7010: move MODULE_DEVICE_TABLE related code
    
    This commit moves MODULE_DEVICE_TABLE related code to the end of
    the file. This is not necessary at all but moving it just before
    its use improves readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 434d5e8c8028..31022e40d8ed 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -101,13 +101,6 @@ enum gen_com_reg_b {
 
 #define KS7010_IO_BLOCK_SIZE 512
 
-static const struct sdio_device_id ks7010_sdio_ids[] = {
-	{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_A, SDIO_DEVICE_ID_KS_7010)},
-	{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_B, SDIO_DEVICE_ID_KS_7010)},
-	{ /* all zero */ }
-};
-MODULE_DEVICE_TABLE(sdio, ks7010_sdio_ids);
-
 static inline void inc_txqhead(struct ks_wlan_private *priv)
 {
 	priv->tx_dev.qhead = (priv->tx_dev.qhead + 1) % TX_DEVICE_BUFF_SIZE;
@@ -1153,6 +1146,13 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 	kfree(card);
 }
 
+static const struct sdio_device_id ks7010_sdio_ids[] = {
+	{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_A, SDIO_DEVICE_ID_KS_7010)},
+	{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_B, SDIO_DEVICE_ID_KS_7010)},
+	{ /* all zero */ }
+};
+MODULE_DEVICE_TABLE(sdio, ks7010_sdio_ids);
+
 static struct sdio_driver ks7010_sdio_driver = {
 	.name = "ks7010_sdio",
 	.id_table = ks7010_sdio_ids,

commit 7570d757ac549ee9dd4e1a25f7a392a67ab04a98
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:41 2018 +0200

    staging: ks7010: avoid one extra level indentation in ks_wlan_hw_rx function
    
    This commit use an and operator in a if condition to avoid one
    indentation level which is not needed at all.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index b16a668fa7fa..434d5e8c8028 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -494,11 +494,9 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 	if (ret)
 		netdev_err(priv->net_dev, "write READ_STATUS_REG\n");
 
-	if (atomic_read(&priv->psstatus.confirm_wait)) {
-		if (is_hif_conf(event)) {
-			netdev_dbg(priv->net_dev, "IS_HIF_CONF true !!\n");
-			atomic_dec(&priv->psstatus.confirm_wait);
-		}
+	if (atomic_read(&priv->psstatus.confirm_wait) && is_hif_conf(event)) {
+		netdev_dbg(priv->net_dev, "IS_HIF_CONF true !!\n");
+		atomic_dec(&priv->psstatus.confirm_wait);
 	}
 
 	tasklet_schedule(&priv->rx_bh_task);

commit 156f2703e27806dc98ffb62400dc953862e5abe9
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:40 2018 +0200

    staging: ks7010: review debug and error messages in ks7010_sdio source
    
    This commit reviews debug and error messages in code located
    in ks7010_sdio source file avoiding to use 'error' or 'ks7010'
    because this file is using netdev_* functions and has non
    sense to repeat information in log messages.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 23bfdf3cc806..b16a668fa7fa 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -204,7 +204,7 @@ static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 	if (atomic_read(&priv->sleepstatus.status) == 0) {
 		ret = ks7010_sdio_writeb(priv, GCR_B_REG, GCR_B_DOZE);
 		if (ret) {
-			netdev_err(priv->net_dev, " error : GCR_B_REG\n");
+			netdev_err(priv->net_dev, "write GCR_B_REG\n");
 			goto set_sleep_mode;
 		}
 		atomic_set(&priv->sleepstatus.status, 1);
@@ -225,7 +225,7 @@ static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 	if (atomic_read(&priv->sleepstatus.status) == 1) {
 		ret = ks7010_sdio_writeb(priv, WAKEUP_REG, WAKEUP_REQ);
 		if (ret) {
-			netdev_err(priv->net_dev, " error : WAKEUP_REG\n");
+			netdev_err(priv->net_dev, "write WAKEUP_REG\n");
 			goto set_sleep_mode;
 		}
 		atomic_set(&priv->sleepstatus.status, 0);
@@ -244,7 +244,7 @@ void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 		ret = ks7010_sdio_writeb(priv, WAKEUP_REG, WAKEUP_REQ);
 		if (ret)
-			netdev_err(priv->net_dev, " error : WAKEUP_REG\n");
+			netdev_err(priv->net_dev, "write WAKEUP_REG\n");
 
 		priv->last_wakeup = jiffies;
 		++priv->wakeup_count;
@@ -286,7 +286,7 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 
 	ret = ks7010_sdio_readb(priv, INT_PENDING_REG, &byte);
 	if (ret) {
-		netdev_err(priv->net_dev, " error : INT_PENDING_REG\n");
+		netdev_err(priv->net_dev, "read INT_PENDING_REG\n");
 		goto queue_delayed_work;
 	}
 	if (byte)
@@ -294,7 +294,7 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 
 	ret = ks7010_sdio_writeb(priv, GCR_B_REG, GCR_B_DOZE);
 	if (ret) {
-		netdev_err(priv->net_dev, " error : GCR_B_REG\n");
+		netdev_err(priv->net_dev, "write GCR_B_REG\n");
 		goto queue_delayed_work;
 	}
 	atomic_set(&priv->psstatus.status, PS_SNOOZE);
@@ -365,13 +365,13 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 
 	ret = ks7010_sdio_write(priv, DATA_WINDOW, buffer, size);
 	if (ret) {
-		netdev_err(priv->net_dev, " write error : retval=%d\n", ret);
+		netdev_err(priv->net_dev, "write DATA_WINDOW\n");
 		return ret;
 	}
 
 	ret = ks7010_sdio_writeb(priv, WRITE_STATUS_REG, REG_STATUS_BUSY);
 	if (ret) {
-		netdev_err(priv->net_dev, " error : WRITE_STATUS_REG\n");
+		netdev_err(priv->net_dev, "write WRITE_STATUS_REG\n");
 		return ret;
 	}
 
@@ -479,7 +479,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 #endif
 		ret = ks7010_sdio_writeb(priv, READ_STATUS_REG, REG_STATUS_IDLE);
 		if (ret)
-			netdev_err(priv->net_dev, " error : READ_STATUS_REG\n");
+			netdev_err(priv->net_dev, "write READ_STATUS_REG\n");
 
 		/* length check fail */
 		return;
@@ -492,7 +492,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 
 	ret = ks7010_sdio_writeb(priv, READ_STATUS_REG, REG_STATUS_IDLE);
 	if (ret)
-		netdev_err(priv->net_dev, " error : READ_STATUS_REG\n");
+		netdev_err(priv->net_dev, "write READ_STATUS_REG\n");
 
 	if (atomic_read(&priv->psstatus.confirm_wait)) {
 		if (is_hif_conf(event)) {
@@ -553,7 +553,7 @@ static void ks7010_rw_function(struct work_struct *work)
 	/* read (WriteStatus/ReadDataSize FN1:00_0014) */
 	ret = ks7010_sdio_readb(priv, WSTATUS_RSIZE_REG, &byte);
 	if (ret) {
-		netdev_err(priv->net_dev, " error : WSTATUS_RSIZE_REG psstatus=%d\n",
+		netdev_err(priv->net_dev, "read WSTATUS_RSIZE_REG psstatus=%d\n",
 			   atomic_read(&priv->psstatus.status));
 		goto release_host;
 	}
@@ -585,7 +585,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 
 	ret = ks7010_sdio_readb(priv, INT_PENDING_REG, &status);
 	if (ret) {
-		netdev_err(priv->net_dev, "error : INT_PENDING_REG\n");
+		netdev_err(priv->net_dev, "read INT_PENDING_REG\n");
 		goto queue_delayed_work;
 	}
 
@@ -598,7 +598,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	    atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 		ret = ks7010_sdio_readb(priv, GCR_B_REG, &byte);
 		if (ret) {
-			netdev_err(priv->net_dev, " error : GCR_B_REG\n");
+			netdev_err(priv->net_dev, "read GCR_B_REG\n");
 			goto queue_delayed_work;
 		}
 		if (byte == GCR_B_ACTIVE) {
@@ -614,7 +614,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 		/* read (WriteStatus/ReadDataSize FN1:00_0014) */
 		ret = ks7010_sdio_readb(priv, WSTATUS_RSIZE_REG, &byte);
 		if (ret) {
-			netdev_err(priv->net_dev, " error : WSTATUS_RSIZE_REG\n");
+			netdev_err(priv->net_dev, "read WSTATUS_RSIZE_REG\n");
 			goto queue_delayed_work;
 		}
 		rsize = byte & RSIZE_MASK;
@@ -948,7 +948,7 @@ static void ks7010_sdio_init_irqs(struct sdio_func *func,
 	ret = ks7010_sdio_writeb(priv, INT_PENDING_REG, 0xff);
 	sdio_release_host(func);
 	if (ret)
-		netdev_err(priv->net_dev, " error : INT_PENDING_REG\n");
+		netdev_err(priv->net_dev, "write INT_PENDING_REG\n");
 
 	/* enable ks7010sdio interrupt */
 	byte = (INT_GCR_B | INT_READ_STATUS | INT_WRITE_STATUS);
@@ -956,7 +956,7 @@ static void ks7010_sdio_init_irqs(struct sdio_func *func,
 	ret = ks7010_sdio_writeb(priv, INT_ENABLE_REG, byte);
 	sdio_release_host(func);
 	if (ret)
-		netdev_err(priv->net_dev, " err : INT_ENABLE_REG\n");
+		netdev_err(priv->net_dev, "write INT_ENABLE_REG\n");
 }
 
 static void ks7010_private_init(struct ks_wlan_private *priv,
@@ -1024,12 +1024,11 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	/* private memory allocate */
 	netdev = alloc_etherdev(sizeof(*priv));
 	if (!netdev) {
-		dev_err(&card->func->dev, "ks7010 : Unable to alloc new net device\n");
+		dev_err(&card->func->dev, "Unable to alloc new net device\n");
 		goto err_release_irq;
 	}
 	if (dev_alloc_name(netdev, "wlan%d") < 0) {
-		dev_err(&card->func->dev,
-			"ks7010 :  Couldn't get name!\n");
+		dev_err(&card->func->dev, "Couldn't get name!\n");
 		goto err_free_netdev;
 	}
 
@@ -1043,8 +1042,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	ret = ks7010_upload_firmware(card);
 	if (ret) {
 		netdev_err(priv->net_dev,
-			   "ks7010: firmware load failed !! return code = %d\n",
-			   ret);
+			   "firmware load failed !! ret = %d\n", ret);
 		goto err_free_netdev;
 	}
 

commit 004e43c24d24b87f737f0482646c9094fb2cf14d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:39 2018 +0200

    staging: ks7010: review comment style in ks7010_sdio source file
    
    This commit reviews comment style used in ks7010_sdio source file
    in order to be coherent with the rest of the code. Most comments
    in this source are before definitions but only two of them have
    been written at the right. So, be coherent moving this two to the
    top of definitions. Also fix one multiline comment style to use
    the normal preferred kernel style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index cf9f347ecc9d..23bfdf3cc806 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -48,12 +48,17 @@ enum reg_status_type {
 /* Write Index Register */
 #define WRITE_INDEX_REG		0x000010
 
-/* Write Status/Read Data Size Register
+/*
+ * Write Status/Read Data Size Register
  * for network packet (less than 2048 bytes data)
  */
 #define WSTATUS_RSIZE_REG	0x000014
-#define WSTATUS_MASK		0x80	/* Write Status Register value */
-#define RSIZE_MASK		0x7F	/* Read Data Size Register value [10:4] */
+
+/* Write Status Register value */
+#define WSTATUS_MASK		0x80
+
+/* Read Data Size Register value [10:4] */
+#define RSIZE_MASK		0x7F
 
 /* ARM to SD interrupt Enable */
 #define INT_ENABLE_REG		0x000020

commit a704a1bcd521993c9332f748cfa7d416aa6abf48
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:38 2018 +0200

    staging: ks7010: add REG suffix to sdio register definitions
    
    This commit adds REG suffix to register definitions related
    with SDIO in order to improve readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 817268ae5735..cf9f347ecc9d 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -32,33 +32,33 @@
 #define SDIO_DEVICE_ID_KS_7010		0x7910
 
 /* Read/Write Status Register */
-#define READ_STATUS		0x000000
-#define WRITE_STATUS		0x00000C
+#define READ_STATUS_REG		0x000000
+#define WRITE_STATUS_REG	0x00000C
 enum reg_status_type {
 	REG_STATUS_BUSY,
 	REG_STATUS_IDLE
 };
 
 /* Read Index Register */
-#define READ_INDEX		0x000004
+#define READ_INDEX_REG		0x000004
 
 /* Read Data Size Register */
-#define READ_DATA_SIZE		0x000008
+#define READ_DATA_SIZE_REG	0x000008
 
 /* Write Index Register */
-#define WRITE_INDEX		0x000010
+#define WRITE_INDEX_REG		0x000010
 
 /* Write Status/Read Data Size Register
  * for network packet (less than 2048 bytes data)
  */
-#define WSTATUS_RSIZE		0x000014
+#define WSTATUS_RSIZE_REG	0x000014
 #define WSTATUS_MASK		0x80	/* Write Status Register value */
 #define RSIZE_MASK		0x7F	/* Read Data Size Register value [10:4] */
 
 /* ARM to SD interrupt Enable */
-#define INT_ENABLE		0x000020
+#define INT_ENABLE_REG		0x000020
 /* ARM to SD interrupt Pending */
-#define INT_PENDING		0x000024
+#define INT_PENDING_REG		0x000024
 
 #define INT_GCR_B              BIT(7)
 #define INT_GCR_A              BIT(6)
@@ -70,7 +70,7 @@ enum reg_status_type {
 #define INT_READ_SIZE          BIT(0)
 
 /* General Communication Register A */
-#define GCR_A			0x000028
+#define GCR_A_REG		0x000028
 enum gen_com_reg_a {
 	GCR_A_INIT,
 	GCR_A_REMAP,
@@ -78,14 +78,14 @@ enum gen_com_reg_a {
 };
 
 /* General Communication Register B */
-#define GCR_B			0x00002C
+#define GCR_B_REG		0x00002C
 enum gen_com_reg_b {
 	GCR_B_ACTIVE,
 	GCR_B_DOZE
 };
 
 /* Wakeup Register */
-#define WAKEUP			0x008018
+#define WAKEUP_REG		0x008018
 #define WAKEUP_REQ		0x5a
 
 /* AHB Data Window  0x010000-0x01FFFF */
@@ -197,9 +197,9 @@ static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 	atomic_set(&priv->sleepstatus.doze_request, 0);
 
 	if (atomic_read(&priv->sleepstatus.status) == 0) {
-		ret = ks7010_sdio_writeb(priv, GCR_B, GCR_B_DOZE);
+		ret = ks7010_sdio_writeb(priv, GCR_B_REG, GCR_B_DOZE);
 		if (ret) {
-			netdev_err(priv->net_dev, " error : GCR_B\n");
+			netdev_err(priv->net_dev, " error : GCR_B_REG\n");
 			goto set_sleep_mode;
 		}
 		atomic_set(&priv->sleepstatus.status, 1);
@@ -218,9 +218,9 @@ static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 	atomic_set(&priv->sleepstatus.wakeup_request, 0);
 
 	if (atomic_read(&priv->sleepstatus.status) == 1) {
-		ret = ks7010_sdio_writeb(priv, WAKEUP, WAKEUP_REQ);
+		ret = ks7010_sdio_writeb(priv, WAKEUP_REG, WAKEUP_REQ);
 		if (ret) {
-			netdev_err(priv->net_dev, " error : WAKEUP\n");
+			netdev_err(priv->net_dev, " error : WAKEUP_REG\n");
 			goto set_sleep_mode;
 		}
 		atomic_set(&priv->sleepstatus.status, 0);
@@ -237,9 +237,9 @@ void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 	int ret;
 
 	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
-		ret = ks7010_sdio_writeb(priv, WAKEUP, WAKEUP_REQ);
+		ret = ks7010_sdio_writeb(priv, WAKEUP_REG, WAKEUP_REQ);
 		if (ret)
-			netdev_err(priv->net_dev, " error : WAKEUP\n");
+			netdev_err(priv->net_dev, " error : WAKEUP_REG\n");
 
 		priv->last_wakeup = jiffies;
 		++priv->wakeup_count;
@@ -279,17 +279,17 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 		return;
 	}
 
-	ret = ks7010_sdio_readb(priv, INT_PENDING, &byte);
+	ret = ks7010_sdio_readb(priv, INT_PENDING_REG, &byte);
 	if (ret) {
-		netdev_err(priv->net_dev, " error : INT_PENDING\n");
+		netdev_err(priv->net_dev, " error : INT_PENDING_REG\n");
 		goto queue_delayed_work;
 	}
 	if (byte)
 		goto queue_delayed_work;
 
-	ret = ks7010_sdio_writeb(priv, GCR_B, GCR_B_DOZE);
+	ret = ks7010_sdio_writeb(priv, GCR_B_REG, GCR_B_DOZE);
 	if (ret) {
-		netdev_err(priv->net_dev, " error : GCR_B\n");
+		netdev_err(priv->net_dev, " error : GCR_B_REG\n");
 		goto queue_delayed_work;
 	}
 	atomic_set(&priv->psstatus.status, PS_SNOOZE);
@@ -364,9 +364,9 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 		return ret;
 	}
 
-	ret = ks7010_sdio_writeb(priv, WRITE_STATUS, REG_STATUS_BUSY);
+	ret = ks7010_sdio_writeb(priv, WRITE_STATUS_REG, REG_STATUS_BUSY);
 	if (ret) {
-		netdev_err(priv->net_dev, " error : WRITE_STATUS\n");
+		netdev_err(priv->net_dev, " error : WRITE_STATUS_REG\n");
 		return ret;
 	}
 
@@ -472,9 +472,9 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 				     DUMP_PREFIX_OFFSET,
 				     rx_buffer->data, 32);
 #endif
-		ret = ks7010_sdio_writeb(priv, READ_STATUS, REG_STATUS_IDLE);
+		ret = ks7010_sdio_writeb(priv, READ_STATUS_REG, REG_STATUS_IDLE);
 		if (ret)
-			netdev_err(priv->net_dev, " error : READ_STATUS\n");
+			netdev_err(priv->net_dev, " error : READ_STATUS_REG\n");
 
 		/* length check fail */
 		return;
@@ -485,9 +485,9 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 	event = le16_to_cpu(hdr->event);
 	inc_rxqtail(priv);
 
-	ret = ks7010_sdio_writeb(priv, READ_STATUS, REG_STATUS_IDLE);
+	ret = ks7010_sdio_writeb(priv, READ_STATUS_REG, REG_STATUS_IDLE);
 	if (ret)
-		netdev_err(priv->net_dev, " error : READ_STATUS\n");
+		netdev_err(priv->net_dev, " error : READ_STATUS_REG\n");
 
 	if (atomic_read(&priv->psstatus.confirm_wait)) {
 		if (is_hif_conf(event)) {
@@ -546,9 +546,9 @@ static void ks7010_rw_function(struct work_struct *work)
 	}
 
 	/* read (WriteStatus/ReadDataSize FN1:00_0014) */
-	ret = ks7010_sdio_readb(priv, WSTATUS_RSIZE, &byte);
+	ret = ks7010_sdio_readb(priv, WSTATUS_RSIZE_REG, &byte);
 	if (ret) {
-		netdev_err(priv->net_dev, " error : WSTATUS_RSIZE psstatus=%d\n",
+		netdev_err(priv->net_dev, " error : WSTATUS_RSIZE_REG psstatus=%d\n",
 			   atomic_read(&priv->psstatus.status));
 		goto release_host;
 	}
@@ -578,9 +578,9 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	if (priv->dev_state < DEVICE_STATE_BOOT)
 		goto queue_delayed_work;
 
-	ret = ks7010_sdio_readb(priv, INT_PENDING, &status);
+	ret = ks7010_sdio_readb(priv, INT_PENDING_REG, &status);
 	if (ret) {
-		netdev_err(priv->net_dev, "error : INT_PENDING\n");
+		netdev_err(priv->net_dev, "error : INT_PENDING_REG\n");
 		goto queue_delayed_work;
 	}
 
@@ -591,9 +591,9 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	/* bit2 -> Read Status Busy  */
 	if (status & INT_GCR_B ||
 	    atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
-		ret = ks7010_sdio_readb(priv, GCR_B, &byte);
+		ret = ks7010_sdio_readb(priv, GCR_B_REG, &byte);
 		if (ret) {
-			netdev_err(priv->net_dev, " error : GCR_B\n");
+			netdev_err(priv->net_dev, " error : GCR_B_REG\n");
 			goto queue_delayed_work;
 		}
 		if (byte == GCR_B_ACTIVE) {
@@ -607,9 +607,9 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 
 	do {
 		/* read (WriteStatus/ReadDataSize FN1:00_0014) */
-		ret = ks7010_sdio_readb(priv, WSTATUS_RSIZE, &byte);
+		ret = ks7010_sdio_readb(priv, WSTATUS_RSIZE_REG, &byte);
 		if (ret) {
-			netdev_err(priv->net_dev, " error : WSTATUS_RSIZE\n");
+			netdev_err(priv->net_dev, " error : WSTATUS_RSIZE_REG\n");
 			goto queue_delayed_work;
 		}
 		rsize = byte & RSIZE_MASK;
@@ -675,11 +675,11 @@ static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 	if (!data_buf)
 		return -ENOMEM;
 
-	ret = ks7010_sdio_write(priv, WRITE_INDEX, data_buf, sizeof(index));
+	ret = ks7010_sdio_write(priv, WRITE_INDEX_REG, data_buf, sizeof(index));
 	if (ret)
 		goto err_free_data_buf;
 
-	ret = ks7010_sdio_write(priv, READ_INDEX, data_buf, sizeof(index));
+	ret = ks7010_sdio_write(priv, READ_INDEX_REG, data_buf, sizeof(index));
 	if (ret)
 		goto err_free_data_buf;
 
@@ -768,7 +768,7 @@ static int ks7010_copy_firmware(struct ks_wlan_private *priv,
 
 	} while (size);
 
-	ret = ks7010_sdio_writeb(priv, GCR_A, GCR_A_REMAP);
+	ret = ks7010_sdio_writeb(priv, GCR_A_REG, GCR_A_REMAP);
 
 free_rom_buf:
 	kfree(rom_buf);
@@ -787,7 +787,7 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	sdio_claim_host(card->func);
 
 	/* Firmware running ? */
-	ret = ks7010_sdio_readb(priv, GCR_A, &byte);
+	ret = ks7010_sdio_readb(priv, GCR_A_REG, &byte);
 	if (ret)
 		goto release_host;
 	if (byte == GCR_A_RUN) {
@@ -808,7 +808,7 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	/* Firmware running check */
 	for (n = 0; n < 50; ++n) {
 		usleep_range(10000, 11000);	/* wait_ms(10); */
-		ret = ks7010_sdio_readb(priv, GCR_A, &byte);
+		ret = ks7010_sdio_readb(priv, GCR_A_REG, &byte);
 		if (ret)
 			goto release_firmware;
 
@@ -913,11 +913,11 @@ static int ks7010_sdio_setup_irqs(struct sdio_func *func)
 	int ret;
 
 	/* interrupt disable */
-	sdio_writeb(func, 0, INT_ENABLE, &ret);
+	sdio_writeb(func, 0, INT_ENABLE_REG, &ret);
 	if (ret)
 		goto irq_error;
 
-	sdio_writeb(func, 0xff, INT_PENDING, &ret);
+	sdio_writeb(func, 0xff, INT_PENDING_REG, &ret);
 	if (ret)
 		goto irq_error;
 
@@ -940,18 +940,18 @@ static void ks7010_sdio_init_irqs(struct sdio_func *func,
 	 * (ARMtoSD_InterruptPending FN1:00_0024)
 	 */
 	sdio_claim_host(func);
-	ret = ks7010_sdio_writeb(priv, INT_PENDING, 0xff);
+	ret = ks7010_sdio_writeb(priv, INT_PENDING_REG, 0xff);
 	sdio_release_host(func);
 	if (ret)
-		netdev_err(priv->net_dev, " error : INT_PENDING\n");
+		netdev_err(priv->net_dev, " error : INT_PENDING_REG\n");
 
 	/* enable ks7010sdio interrupt */
 	byte = (INT_GCR_B | INT_READ_STATUS | INT_WRITE_STATUS);
 	sdio_claim_host(func);
-	ret = ks7010_sdio_writeb(priv, INT_ENABLE, byte);
+	ret = ks7010_sdio_writeb(priv, INT_ENABLE_REG, byte);
 	sdio_release_host(func);
 	if (ret)
-		netdev_err(priv->net_dev, " err : INT_ENABLE\n");
+		netdev_err(priv->net_dev, " err : INT_ENABLE_REG\n");
 }
 
 static void ks7010_private_init(struct ks_wlan_private *priv,
@@ -1122,8 +1122,8 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 
 		/* interrupt disable */
 		sdio_claim_host(func);
-		sdio_writeb(func, 0, INT_ENABLE, &ret);
-		sdio_writeb(func, 0xff, INT_PENDING, &ret);
+		sdio_writeb(func, 0, INT_ENABLE_REG, &ret);
+		sdio_writeb(func, 0xff, INT_PENDING_REG, &ret);
 		sdio_release_host(func);
 
 		ret = send_stop_request(func);

commit b60f5f06278f0f3c8e6ca2100a4ba074c525802f
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:37 2018 +0200

    staging: ks7010: delete not used definitions in ks7010_sdio source
    
    This commit removes two definitions inside ks7010_sdio source file
    because they are not being used at all.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 2029b49196ed..817268ae5735 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -94,10 +94,7 @@ enum gen_com_reg_b {
 
 #define KS7010_IRAM_ADDRESS	0x06000000
 
-
-#define KS7010_FUNC_NUM 1
 #define KS7010_IO_BLOCK_SIZE 512
-#define KS7010_MAX_CLOCK 25000000
 
 static const struct sdio_device_id ks7010_sdio_ids[] = {
 	{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_A, SDIO_DEVICE_ID_KS_7010)},

commit 48ecb2256a1dd1bbd71fc4e722a91d27e0990ffd
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:36 2018 +0200

    staging: ks7010: move sdio specific register definitions into source file
    
    This commit moves SDIO related register definitions from header
    to source file. There is no need to have those into the header
    because they are only being used in specific SDIO code.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index d3401242d9b7..2029b49196ed 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -23,6 +23,78 @@
 #include "ks7010_sdio.h"
 
 #define ROM_FILE "ks7010sd.rom"
+
+/*  SDIO KeyStream vendor and device */
+#define SDIO_VENDOR_ID_KS_CODE_A	0x005b
+#define SDIO_VENDOR_ID_KS_CODE_B	0x0023
+
+/* Older sources suggest earlier versions were named 7910 or 79xx */
+#define SDIO_DEVICE_ID_KS_7010		0x7910
+
+/* Read/Write Status Register */
+#define READ_STATUS		0x000000
+#define WRITE_STATUS		0x00000C
+enum reg_status_type {
+	REG_STATUS_BUSY,
+	REG_STATUS_IDLE
+};
+
+/* Read Index Register */
+#define READ_INDEX		0x000004
+
+/* Read Data Size Register */
+#define READ_DATA_SIZE		0x000008
+
+/* Write Index Register */
+#define WRITE_INDEX		0x000010
+
+/* Write Status/Read Data Size Register
+ * for network packet (less than 2048 bytes data)
+ */
+#define WSTATUS_RSIZE		0x000014
+#define WSTATUS_MASK		0x80	/* Write Status Register value */
+#define RSIZE_MASK		0x7F	/* Read Data Size Register value [10:4] */
+
+/* ARM to SD interrupt Enable */
+#define INT_ENABLE		0x000020
+/* ARM to SD interrupt Pending */
+#define INT_PENDING		0x000024
+
+#define INT_GCR_B              BIT(7)
+#define INT_GCR_A              BIT(6)
+#define INT_WRITE_STATUS       BIT(5)
+#define INT_WRITE_INDEX        BIT(4)
+#define INT_WRITE_SIZE         BIT(3)
+#define INT_READ_STATUS        BIT(2)
+#define INT_READ_INDEX         BIT(1)
+#define INT_READ_SIZE          BIT(0)
+
+/* General Communication Register A */
+#define GCR_A			0x000028
+enum gen_com_reg_a {
+	GCR_A_INIT,
+	GCR_A_REMAP,
+	GCR_A_RUN
+};
+
+/* General Communication Register B */
+#define GCR_B			0x00002C
+enum gen_com_reg_b {
+	GCR_B_ACTIVE,
+	GCR_B_DOZE
+};
+
+/* Wakeup Register */
+#define WAKEUP			0x008018
+#define WAKEUP_REQ		0x5a
+
+/* AHB Data Window  0x010000-0x01FFFF */
+#define DATA_WINDOW		0x010000
+#define WINDOW_SIZE		(64 * 1024)
+
+#define KS7010_IRAM_ADDRESS	0x06000000
+
+
 #define KS7010_FUNC_NUM 1
 #define KS7010_IO_BLOCK_SIZE 512
 #define KS7010_MAX_CLOCK 25000000

commit 2c54ee54d45299b53ee0b8df2fb3b5b6a3f93fd9
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:35 2018 +0200

    staging: ks7010: move ROM_FILE definition into source file
    
    This commit moves ROM_FILE from header to source file because
    there is not being used outside this.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index c1bd7de4007f..d3401242d9b7 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -22,6 +22,7 @@
 #include "ks_hostif.h"
 #include "ks7010_sdio.h"
 
+#define ROM_FILE "ks7010sd.rom"
 #define KS7010_FUNC_NUM 1
 #define KS7010_IO_BLOCK_SIZE 512
 #define KS7010_MAX_CLOCK 25000000

commit 2c3f894567c6556772048b54d306b48c2d87b4a6
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Apr 19 07:08:15 2018 +0200

    staging: ks7010: init local variables when they are declared in ks7010_sdio_probe
    
    This commit change init point of two variables to forward them to
    init time. This variables are just being assigned some lines after
    and it is more clear to init them when the init value is known and
    in this case this is known when they are declared.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 164d44a5f36c..c1bd7de4007f 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -914,14 +914,11 @@ static void ks7010_private_init(struct ks_wlan_private *priv,
 static int ks7010_sdio_probe(struct sdio_func *func,
 			     const struct sdio_device_id *device)
 {
-	struct ks_wlan_private *priv;
+	struct ks_wlan_private *priv = NULL;
+	struct net_device *netdev = NULL;
 	struct ks_sdio_card *card;
-	struct net_device *netdev;
 	int ret;
 
-	priv = NULL;
-	netdev = NULL;
-
 	card = kzalloc(sizeof(*card), GFP_KERNEL);
 	if (!card)
 		return -ENOMEM;

commit fa3fd846186110abf9c15026ae33c0b6920a9122
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Apr 19 07:08:09 2018 +0200

    staging: ks7010: review includes of ks7010_sdio file
    
    This commit reviews includes of ks7010_sdio.c source
    file removing those which are not being used at all.
    Kernel header includes have been ordered alphabetically
    also.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 81394ba0f186..164d44a5f36c 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -10,17 +10,15 @@
  *   published by the Free Software Foundation.
  */
 
-#include <linux/module.h>
+#include <linux/atomic.h>
 #include <linux/circ_buf.h>
 #include <linux/firmware.h>
+#include <linux/jiffies.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/sdio_func.h>
+#include <linux/module.h>
 #include <linux/workqueue.h>
-#include <linux/atomic.h>
-#include <linux/jiffies.h>
-
 #include "ks_wlan.h"
-#include "ks_wlan_ioctl.h"
 #include "ks_hostif.h"
 #include "ks7010_sdio.h"
 

commit 549f625c856163202c16cd7228d6bdf290953ba7
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Apr 19 07:08:04 2018 +0200

    staging: ks7010: review includes of ks_wlan.h file
    
    This commit reviews includes of ks_wlan.h header file.
    It removes those which are not being used at all. It
    also reorder remaining ones in alphabetical order.
    The linux/module.h include file has been moved to the
    correct file which is ks7010_sdio.c in order to be able
    to compile the driver without problems.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 84243275cf11..81394ba0f186 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -10,6 +10,7 @@
  *   published by the Free Software Foundation.
  */
 
+#include <linux/module.h>
 #include <linux/circ_buf.h>
 #include <linux/firmware.h>
 #include <linux/mmc/card.h>

commit e6bc5053b8533725f649898d6df57a4dd49ac848
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 16 12:29:23 2018 +0200

    staging: ks7010: use linux circular buffer header macros to handle tx and rx queues
    
    This commit replace current custom implementation of some circular
    buffer head and tail logic in favour of the use of macros defined
    in linux circ_buf.h header. Queue related inline function names
    have been review also.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index d8ebe98efcf1..84243275cf11 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -10,6 +10,7 @@
  *   published by the Free Software Foundation.
  */
 
+#include <linux/circ_buf.h>
 #include <linux/firmware.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/sdio_func.h>
@@ -43,11 +44,10 @@ static inline void inc_txqtail(struct ks_wlan_private *priv)
 	priv->tx_dev.qtail = (priv->tx_dev.qtail + 1) % TX_DEVICE_BUFF_SIZE;
 }
 
-static inline unsigned int cnt_txqbody(struct ks_wlan_private *priv)
+static inline bool txq_has_space(struct ks_wlan_private *priv)
 {
-	unsigned int tx_cnt = priv->tx_dev.qtail - priv->tx_dev.qhead;
-
-	return (tx_cnt + TX_DEVICE_BUFF_SIZE) % TX_DEVICE_BUFF_SIZE;
+	return (CIRC_SPACE(priv->tx_dev.qhead, priv->tx_dev.qtail,
+			   TX_DEVICE_BUFF_SIZE) > 0);
 }
 
 static inline void inc_rxqhead(struct ks_wlan_private *priv)
@@ -60,11 +60,22 @@ static inline void inc_rxqtail(struct ks_wlan_private *priv)
 	priv->rx_dev.qtail = (priv->rx_dev.qtail + 1) % RX_DEVICE_BUFF_SIZE;
 }
 
-static inline unsigned int cnt_rxqbody(struct ks_wlan_private *priv)
+static inline bool rxq_has_space(struct ks_wlan_private *priv)
+{
+	return (CIRC_SPACE(priv->rx_dev.qhead, priv->rx_dev.qtail,
+			   RX_DEVICE_BUFF_SIZE) > 0);
+}
+
+static inline unsigned int txq_count(struct ks_wlan_private *priv)
 {
-	unsigned int rx_cnt = priv->rx_dev.qtail - priv->rx_dev.qhead;
+	return CIRC_CNT_TO_END(priv->tx_dev.qhead, priv->tx_dev.qtail,
+			       TX_DEVICE_BUFF_SIZE);
+}
 
-	return (rx_cnt + RX_DEVICE_BUFF_SIZE) % RX_DEVICE_BUFF_SIZE;
+static inline unsigned int rxq_count(struct ks_wlan_private *priv)
+{
+	return CIRC_CNT_TO_END(priv->rx_dev.qhead, priv->rx_dev.qtail,
+			       RX_DEVICE_BUFF_SIZE);
 }
 
 /* Read single byte from device address into byte (CMD52) */
@@ -190,11 +201,11 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 		   atomic_read(&priv->psstatus.status),
 		   atomic_read(&priv->psstatus.confirm_wait),
 		   atomic_read(&priv->psstatus.snooze_guard),
-		   cnt_txqbody(priv));
+		   txq_count(priv));
 
 	if (atomic_read(&priv->psstatus.confirm_wait) ||
 	    atomic_read(&priv->psstatus.snooze_guard) ||
-	    cnt_txqbody(priv)) {
+	    txq_has_space(priv)) {
 		queue_delayed_work(priv->wq, &priv->rw_dwork, 0);
 		return;
 	}
@@ -240,7 +251,7 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 		goto err_complete;
 	}
 
-	if ((TX_DEVICE_BUFF_SIZE - 1) <= cnt_txqbody(priv)) {
+	if ((TX_DEVICE_BUFF_SIZE - 1) <= txq_count(priv)) {
 		netdev_err(priv->net_dev, "tx buffer overflow\n");
 		ret = -EOVERFLOW;
 		goto err_complete;
@@ -298,7 +309,7 @@ static void tx_device_task(struct ks_wlan_private *priv)
 	struct tx_device_buffer *sp;
 	int ret;
 
-	if (cnt_txqbody(priv) <= 0 ||
+	if (!txq_has_space(priv) ||
 	    atomic_read(&priv->psstatus.status) == PS_SNOOZE)
 		return;
 
@@ -317,7 +328,7 @@ static void tx_device_task(struct ks_wlan_private *priv)
 		(*sp->complete_handler)(priv, sp->skb);
 	inc_txqhead(priv);
 
-	if (cnt_txqbody(priv) > 0)
+	if (txq_has_space(priv))
 		queue_delayed_work(priv->wq, &priv->rw_dwork, 0);
 }
 
@@ -345,7 +356,7 @@ int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
 	result = enqueue_txdev(priv, p, size, complete_handler, skb);
 	spin_unlock(&priv->tx_dev.tx_dev_lock);
 
-	if (cnt_txqbody(priv) > 0)
+	if (txq_has_space(priv))
 		queue_delayed_work(priv->wq, &priv->rw_dwork, 0);
 
 	return result;
@@ -356,12 +367,12 @@ static void rx_event_task(unsigned long dev)
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
 	struct rx_device_buffer *rp;
 
-	if (cnt_rxqbody(priv) > 0 && priv->dev_state >= DEVICE_STATE_BOOT) {
+	if (rxq_has_space(priv) && priv->dev_state >= DEVICE_STATE_BOOT) {
 		rp = &priv->rx_dev.rx_dev_buff[priv->rx_dev.qhead];
 		hostif_receive(priv, rp->data, rp->size);
 		inc_rxqhead(priv);
 
-		if (cnt_rxqbody(priv) > 0)
+		if (rxq_has_space(priv))
 			tasklet_schedule(&priv->rx_bh_task);
 	}
 }
@@ -374,7 +385,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 	unsigned short event = 0;
 
 	/* receive data */
-	if (cnt_rxqbody(priv) >= (RX_DEVICE_BUFF_SIZE - 1)) {
+	if (rxq_count(priv) >= (RX_DEVICE_BUFF_SIZE - 1)) {
 		netdev_err(priv->net_dev, "rx buffer overflow\n");
 		return;
 	}
@@ -447,7 +458,7 @@ static void ks7010_rw_function(struct work_struct *work)
 
 	/* power save wakeup */
 	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
-		if (cnt_txqbody(priv) > 0) {
+		if (txq_has_space(priv)) {
 			ks_wlan_hw_wakeup_request(priv);
 			queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 		}
@@ -538,7 +549,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 
 		if (byte & WSTATUS_MASK) {
 			if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
-				if (cnt_txqbody(priv)) {
+				if (txq_has_space(priv)) {
 					ks_wlan_hw_wakeup_request(priv);
 					queue_delayed_work(priv->wq,
 							   &priv->rw_dwork, 1);
@@ -575,7 +586,7 @@ static void trx_device_exit(struct ks_wlan_private *priv)
 	struct tx_device_buffer *sp;
 
 	/* tx buffer clear */
-	while (cnt_txqbody(priv) > 0) {
+	while (txq_has_space(priv)) {
 		sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];
 		kfree(sp->sendp);
 		if (sp->complete_handler)	/* TX Complete */

commit 6adc30b17922ea67d4ad93887b8d59d4c7d4516d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Apr 6 14:37:51 2018 +0200

    staging: ks7010: use msecs_to_jiffies in ks7010_rw_function function
    
    This commit replaces custom time calculations done in ks7010_rw_function
    with msecs_to_jiffies() function which has the same behaviour.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 03f348bf8d71..d8ebe98efcf1 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -15,6 +15,7 @@
 #include <linux/mmc/sdio_func.h>
 #include <linux/workqueue.h>
 #include <linux/atomic.h>
+#include <linux/jiffies.h>
 
 #include "ks_wlan.h"
 #include "ks_wlan_ioctl.h"
@@ -427,19 +428,18 @@ static void ks7010_rw_function(struct work_struct *work)
 	priv = container_of(work, struct ks_wlan_private, rw_dwork.work);
 
 	/* wait after DOZE */
-	if (time_after(priv->last_doze + ((30 * HZ) / 1000), jiffies)) {
+	if (time_after(priv->last_doze + msecs_to_jiffies(30), jiffies)) {
 		netdev_dbg(priv->net_dev, "wait after DOZE\n");
 		queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 		return;
 	}
 
 	/* wait after WAKEUP */
-	while (time_after(priv->last_wakeup + ((30 * HZ) / 1000), jiffies)) {
+	while (time_after(priv->last_wakeup + msecs_to_jiffies(30), jiffies)) {
 		netdev_dbg(priv->net_dev, "wait after WAKEUP\n");
 		dev_info(&priv->ks_sdio_card->func->dev,
 			 "wake: %lu %lu\n",
-			 priv->last_wakeup + (30 * HZ) / 1000,
-				jiffies);
+			 priv->last_wakeup + msecs_to_jiffies(30), jiffies);
 		msleep(30);
 	}
 

commit e0ba53a43ee3919d0c78ff8d26b15257129110ec
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Apr 6 14:37:50 2018 +0200

    staging: ks7010: change sdio related read/write function parameter types
    
    This commit reviews and changes SDIO related read and write
    functions parameter types to use the preferred u* kernel types.
    Also length parameter which was defined as int has nonsense
    because calls to this functions are called useing an unsigned
    instead. Because of this length parameters have been changed
    also into unsigned int.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 3ad2f731702b..03f348bf8d71 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -67,8 +67,8 @@ static inline unsigned int cnt_rxqbody(struct ks_wlan_private *priv)
 }
 
 /* Read single byte from device address into byte (CMD52) */
-static int ks7010_sdio_readb(struct ks_wlan_private *priv, unsigned int address,
-			     unsigned char *byte)
+static int ks7010_sdio_readb(struct ks_wlan_private *priv,
+			     u32 address, u8 *byte)
 {
 	struct sdio_func *func = priv->ks_sdio_card->func;
 	int ret;
@@ -79,8 +79,8 @@ static int ks7010_sdio_readb(struct ks_wlan_private *priv, unsigned int address,
 }
 
 /* Read length bytes from device address into buffer (CMD53) */
-static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
-			    unsigned char *buffer, int length)
+static int ks7010_sdio_read(struct ks_wlan_private *priv, u32 address,
+			    u8 *buffer, unsigned int length)
 {
 	struct sdio_func *func = priv->ks_sdio_card->func;
 
@@ -89,7 +89,7 @@ static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
 
 /* Write single byte to device address (CMD52) */
 static int ks7010_sdio_writeb(struct ks_wlan_private *priv,
-			      unsigned int address, unsigned char byte)
+			      u32 address, u8 byte)
 {
 	struct sdio_func *func = priv->ks_sdio_card->func;
 	int ret;
@@ -100,8 +100,8 @@ static int ks7010_sdio_writeb(struct ks_wlan_private *priv,
 }
 
 /* Write length bytes to device address from buffer (CMD53) */
-static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
-			     unsigned char *buffer, int length)
+static int ks7010_sdio_write(struct ks_wlan_private *priv, u32 address,
+			     u8 *buffer, unsigned int length)
 {
 	struct sdio_func *func = priv->ks_sdio_card->func;
 

commit 7dd51ea1f6cd64b2933d952ed467b89a27f3174f
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Apr 6 14:37:49 2018 +0200

    staging: ks7010: fix remaining long line warnings in ks7010_sdio source
    
    This commit fixes remaining checkpatch warnings because of
    the use of lines longer than 80 characters in ks7010_sdio
    source file. After this clean, this file has no remaining
    warnings around.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 2f709ae68ee2..3ad2f731702b 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -305,7 +305,8 @@ static void tx_device_task(struct ks_wlan_private *priv)
 	if (priv->dev_state >= DEVICE_STATE_BOOT) {
 		ret = write_to_device(priv, sp->sendp, sp->size);
 		if (ret) {
-			netdev_err(priv->net_dev, "write_to_device error !!(%d)\n", ret);
+			netdev_err(priv->net_dev,
+				   "write_to_device error !!(%d)\n", ret);
 			queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 			return;
 		}
@@ -539,7 +540,8 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 			if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 				if (cnt_txqbody(priv)) {
 					ks_wlan_hw_wakeup_request(priv);
-					queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
+					queue_delayed_work(priv->wq,
+							   &priv->rw_dwork, 1);
 					return;
 				}
 			} else {

commit e4844d6f875ef3d8201f1d049705f0349c7817b8
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Apr 6 14:37:48 2018 +0200

    staging: ks7010: remove nonsense comment
    
    This commit removes a comment which has nonsense because
    it is obvious what the code does just reading SET_NETDEV_DEV
    declaration. This also fixes a checkpatch warning because a
    line longer than 80 characters.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index ec2e9bf395b1..2f709ae68ee2 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -952,7 +952,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	priv = netdev_priv(netdev);
 
 	card->priv = priv;
-	SET_NETDEV_DEV(netdev, &card->func->dev);	/* for create sysfs symlinks */
+	SET_NETDEV_DEV(netdev, &card->func->dev);
 
 	ks7010_private_init(priv, card, netdev);
 

commit 9962d86dda3b99d2c7b4b87c921dd1c607a636e0
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Apr 12 11:23:51 2018 -0500

    staging: ks7010_sdio: fix NULL pointer dereference and memory leak
    
    priv is being explicitly dereferenced when it is still null, when
    jumping to goto label err_free_netdev, before it is properly
    updated with a valid memory address.
    
    Also, when this happens, memory allocated for netdev at line 854:
    netdev = alloc_etherdev(sizeof(*priv)) is not being free'd before
    return, hence there is a memory leak.
    
    The current code looks a bit too complicated and can be replaced
    by just directly freeing netdev before return.
    
    Notice that card->priv = NULL isn't required because the next thing
    we do to card is kfree(card).
    
    Addresses-Coverity-ID: 1467844 ("Explicit null dereferenced")
    Suggested-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index b5b8d362fc26..ec2e9bf395b1 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -984,8 +984,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	return 0;
 
  err_free_netdev:
-	free_netdev(priv->net_dev);
-	card->priv = NULL;
+	free_netdev(netdev);
  err_release_irq:
 	sdio_claim_host(func);
 	sdio_release_irq(func);

commit 95751f19b6942680f2884b44a127490c91aa4291
Author: Jia-Ju Bai <baijiaju1990@gmail.com>
Date:   Tue Apr 10 16:58:54 2018 +0800

    staging: ks7010: Replace mdelay with usleep_range in ks7010_upload_firmware
    
    ks7010_upload_firmware() is never called in atomic context.
    
    The call chain ending up at ks7010_upload_firmware() is:
    [1] ks7010_upload_firmware() <- ks7010_sdio_probe()
    
    ks7010_sdio_probe() is set as ".probe" in struct sdio_driver.
    This function is not called in atomic context.
    
    Despite never getting called from atomic context, ks7010_upload_firmware()
    calls mdelay() to busily wait.
    This is not necessary and can be replaced with usleep_range() to
    avoid busy waiting.
    
    This is found by a static analysis tool named DCNS written by myself.
    And I also manually check it.
    
    Signed-off-by: Jia-Ju Bai <baijiaju1990@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 9978915278f6..b5b8d362fc26 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -725,7 +725,7 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 
 	/* Firmware running check */
 	for (n = 0; n < 50; ++n) {
-		mdelay(10);	/* wait_ms(10); */
+		usleep_range(10000, 11000);	/* wait_ms(10); */
 		ret = ks7010_sdio_readb(priv, GCR_A, &byte);
 		if (ret)
 			goto release_firmware;

commit 47bda74a2b1978f0740fdd025dc7b44c026764a8
Author: Ji-Hun Kim <ji_hun.kim@samsung.com>
Date:   Fri Apr 6 13:57:20 2018 +0900

    staging: ks7010: replace kmalloc() + memcpy() with kmemdup()
    
    Use kmemdup rather than duplicating its implementation.
    
    Signed-off-by: Ji-Hun Kim <ji_hun.kim@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index a79438bfdcfc..9978915278f6 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -589,11 +589,10 @@ static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 	int ret;
 	unsigned char *data_buf;
 
-	data_buf = kmalloc(sizeof(u32), GFP_KERNEL);
+	data_buf = kmemdup(&index, sizeof(u32), GFP_KERNEL);
 	if (!data_buf)
 		return -ENOMEM;
 
-	memcpy(data_buf, &index, sizeof(index));
 	ret = ks7010_sdio_write(priv, WRITE_INDEX, data_buf, sizeof(index));
 	if (ret)
 		goto err_free_data_buf;

commit bd6dad98f68bdfcacf3c04c138fee504ee8fcd35
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 3 17:13:02 2018 +0200

    staging: ks7010: fix some style issues about long lines
    
    This commit just fixes some checkpatch reported issues about
    lines longer than 80 characters.
    
    A new blank line has been added also to improve readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 45c4f576d787..a79438bfdcfc 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -665,10 +665,12 @@ static int ks7010_copy_firmware(struct ks_wlan_private *priv,
 		}
 		if (size == 0)
 			break;
+
 		memcpy(rom_buf, fw_entry->data + n, size);
 
 		offset = n;
-		ret = ks7010_sdio_update_index(priv, KS7010_IRAM_ADDRESS + offset);
+		ret = ks7010_sdio_update_index(priv,
+					       KS7010_IRAM_ADDRESS + offset);
 		if (ret)
 			goto free_rom_buf;
 
@@ -676,7 +678,8 @@ static int ks7010_copy_firmware(struct ks_wlan_private *priv,
 		if (ret)
 			goto free_rom_buf;
 
-		ret = ks7010_sdio_data_compare(priv, DATA_WINDOW, rom_buf, size);
+		ret = ks7010_sdio_data_compare(priv,
+					       DATA_WINDOW, rom_buf, size);
 		if (ret)
 			goto free_rom_buf;
 

commit 67082c22033b7f7bbc3cdfa172aec64bfdda84bf
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 3 17:13:01 2018 +0200

    staging: ks7010: ks7010: factor out firmware copy process into ks7010_copy_firmware
    
    This commit extracts firmware copy process into a new function
    ks7010_copy_firmware. Because rom_buf is only needed for this
    process, memory request for it has been also moved to this new
    function so the error handling label release_host_and_free has
    been renamed to release_host into ks7010_upload_firmware original
    function.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 4d794ac84872..45c4f576d787 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -639,40 +639,22 @@ static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 	return ret;
 }
 
-static int ks7010_upload_firmware(struct ks_sdio_card *card)
+static int ks7010_copy_firmware(struct ks_wlan_private *priv,
+				const struct firmware *fw_entry)
 {
-	struct ks_wlan_private *priv = card->priv;
-	unsigned int size, offset, n = 0;
+	unsigned int length;
+	unsigned int size;
+	unsigned int offset;
+	unsigned int n = 0;
 	unsigned char *rom_buf;
-	unsigned char byte = 0;
 	int ret;
-	unsigned int length;
-	const struct firmware *fw_entry = NULL;
 
 	rom_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
 	if (!rom_buf)
 		return -ENOMEM;
 
-	sdio_claim_host(card->func);
-
-	/* Firmware running ? */
-	ret = ks7010_sdio_readb(priv, GCR_A, &byte);
-	if (ret)
-		goto release_host_and_free;
-	if (byte == GCR_A_RUN) {
-		netdev_dbg(priv->net_dev, "MAC firmware running ...\n");
-		ret = -EBUSY;
-		goto release_host_and_free;
-	}
-
-	ret = request_firmware(&fw_entry, ROM_FILE,
-			       &priv->ks_sdio_card->func->dev);
-	if (ret)
-		goto release_host_and_free;
-
 	length = fw_entry->size;
 
-	n = 0;
 	do {
 		if (length >= ROM_BUFF_SIZE) {
 			size = ROM_BUFF_SIZE;
@@ -688,21 +670,54 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 		offset = n;
 		ret = ks7010_sdio_update_index(priv, KS7010_IRAM_ADDRESS + offset);
 		if (ret)
-			goto release_firmware;
+			goto free_rom_buf;
 
 		ret = ks7010_sdio_write(priv, DATA_WINDOW, rom_buf, size);
 		if (ret)
-			goto release_firmware;
+			goto free_rom_buf;
 
 		ret = ks7010_sdio_data_compare(priv, DATA_WINDOW, rom_buf, size);
 		if (ret)
-			goto release_firmware;
+			goto free_rom_buf;
 
 		n += size;
 
 	} while (size);
 
 	ret = ks7010_sdio_writeb(priv, GCR_A, GCR_A_REMAP);
+
+free_rom_buf:
+	kfree(rom_buf);
+	return ret;
+}
+
+static int ks7010_upload_firmware(struct ks_sdio_card *card)
+{
+	struct ks_wlan_private *priv = card->priv;
+	unsigned int n;
+	unsigned char byte = 0;
+	int ret;
+	const struct firmware *fw_entry = NULL;
+
+
+	sdio_claim_host(card->func);
+
+	/* Firmware running ? */
+	ret = ks7010_sdio_readb(priv, GCR_A, &byte);
+	if (ret)
+		goto release_host;
+	if (byte == GCR_A_RUN) {
+		netdev_dbg(priv->net_dev, "MAC firmware running ...\n");
+		ret = -EBUSY;
+		goto release_host;
+	}
+
+	ret = request_firmware(&fw_entry, ROM_FILE,
+			       &priv->ks_sdio_card->func->dev);
+	if (ret)
+		goto release_host;
+
+	ret = ks7010_copy_firmware(priv, fw_entry);
 	if (ret)
 		goto release_firmware;
 
@@ -726,9 +741,8 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 
  release_firmware:
 	release_firmware(fw_entry);
- release_host_and_free:
+ release_host:
 	sdio_release_host(card->func);
-	kfree(rom_buf);
 
 	return ret;
 }

commit 6e043704fb99e3e1d7a1bb02030e49c093cdd943
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 3 17:13:00 2018 +0200

    staging: ks7010: fix error handling in ks7010_upload_firmware
    
    This commit checks missing error code check when checking
    if the firmware is running reading General Communication
    Register A (GCR_A).
    
    It also set ret to EBUSY if firmware is running before
    copying it.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 9907c0cec958..4d794ac84872 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -657,8 +657,11 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 
 	/* Firmware running ? */
 	ret = ks7010_sdio_readb(priv, GCR_A, &byte);
+	if (ret)
+		goto release_host_and_free;
 	if (byte == GCR_A_RUN) {
 		netdev_dbg(priv->net_dev, "MAC firmware running ...\n");
+		ret = -EBUSY;
 		goto release_host_and_free;
 	}
 

commit 6e6156f614da0df8078a8f453c8a2e23cbb9338f
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 3 17:12:59 2018 +0200

    staging: ks7010: factor out initial enqueue process into ks7010_sme_enqueue_events
    
    This commit extract initial enqueue process into a new
    ks7010_sme_enqueue_events function.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 9af79ac32b1b..9907c0cec958 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -730,21 +730,8 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	return ret;
 }
 
-static void ks7010_card_init(struct ks_wlan_private *priv)
+static void ks7010_sme_enqueue_events(struct ks_wlan_private *priv)
 {
-	init_completion(&priv->confirm_wait);
-
-	/* get mac address & firmware version */
-	hostif_sme_enqueue(priv, SME_START);
-
-	if (!wait_for_completion_interruptible_timeout
-	    (&priv->confirm_wait, 5 * HZ)) {
-		netdev_dbg(priv->net_dev, "wait time out!! SME_START\n");
-	}
-
-	if (priv->mac_address_valid && priv->version_size != 0)
-		priv->dev_state = DEVICE_STATE_PREINIT;
-
 	hostif_sme_enqueue(priv, SME_GET_EEPROM_CKSUM);
 
 	/* load initial wireless parameter */
@@ -763,6 +750,24 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 	hostif_sme_enqueue(priv, SME_RSN_ENABLED_REQUEST);
 	hostif_sme_enqueue(priv, SME_MODE_SET_REQUEST);
 	hostif_sme_enqueue(priv, SME_START_REQUEST);
+}
+
+static void ks7010_card_init(struct ks_wlan_private *priv)
+{
+	init_completion(&priv->confirm_wait);
+
+	/* get mac address & firmware version */
+	hostif_sme_enqueue(priv, SME_START);
+
+	if (!wait_for_completion_interruptible_timeout
+	    (&priv->confirm_wait, 5 * HZ)) {
+		netdev_dbg(priv->net_dev, "wait time out!! SME_START\n");
+	}
+
+	if (priv->mac_address_valid && priv->version_size != 0)
+		priv->dev_state = DEVICE_STATE_PREINIT;
+
+	ks7010_sme_enqueue_events(priv);
 
 	if (!wait_for_completion_interruptible_timeout
 	    (&priv->confirm_wait, 5 * HZ)) {

commit 5df835e80e04b64b74cbdc0dcbaa8b9517f49106
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 3 17:12:58 2018 +0200

    staging: ks7010: factor out ks_wlan_private init process into ks7010_private_init
    
    This commit extract ks_wlan_private initialization process
    into a new function ks7010_private_init to improve a bit
    readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 98ef6206976d..9af79ac32b1b 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -848,6 +848,33 @@ static void ks7010_sdio_init_irqs(struct sdio_func *func,
 		netdev_err(priv->net_dev, " err : INT_ENABLE\n");
 }
 
+static void ks7010_private_init(struct ks_wlan_private *priv,
+				struct ks_sdio_card *card,
+				struct net_device *netdev)
+{
+	/* private memory initialize */
+	priv->ks_sdio_card = card;
+
+	priv->dev_state = DEVICE_STATE_PREBOOT;
+	priv->net_dev = netdev;
+	priv->firmware_version[0] = '\0';
+	priv->version_size = 0;
+	priv->last_doze = jiffies;
+	priv->last_wakeup = jiffies;
+	memset(&priv->nstats, 0, sizeof(priv->nstats));
+	memset(&priv->wstats, 0, sizeof(priv->wstats));
+
+	/* sleep mode */
+	atomic_set(&priv->sleepstatus.doze_request, 0);
+	atomic_set(&priv->sleepstatus.wakeup_request, 0);
+	atomic_set(&priv->sleepstatus.wakeup_request, 0);
+
+	trx_device_init(priv);
+	hostif_init(priv);
+	ks_wlan_net_start(netdev);
+	ks7010_init_defaults(priv);
+}
+
 static int ks7010_sdio_probe(struct sdio_func *func,
 			     const struct sdio_device_id *device)
 {
@@ -903,28 +930,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	card->priv = priv;
 	SET_NETDEV_DEV(netdev, &card->func->dev);	/* for create sysfs symlinks */
 
-	/* private memory initialize */
-	priv->ks_sdio_card = card;
-
-	priv->dev_state = DEVICE_STATE_PREBOOT;
-	priv->net_dev = netdev;
-	priv->firmware_version[0] = '\0';
-	priv->version_size = 0;
-	priv->last_doze = jiffies;
-	priv->last_wakeup = jiffies;
-	memset(&priv->nstats, 0, sizeof(priv->nstats));
-	memset(&priv->wstats, 0, sizeof(priv->wstats));
-
-	/* sleep mode */
-	atomic_set(&priv->sleepstatus.doze_request, 0);
-	atomic_set(&priv->sleepstatus.wakeup_request, 0);
-	atomic_set(&priv->sleepstatus.wakeup_request, 0);
-
-	trx_device_init(priv);
-	hostif_init(priv);
-	ks_wlan_net_start(netdev);
-
-	ks7010_init_defaults(priv);
+	ks7010_private_init(priv, card, netdev);
 
 	ret = ks7010_upload_firmware(card);
 	if (ret) {

commit 8d4ab8f7f5afcca5fae47d2e570ff1fc62d7989a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 3 17:12:57 2018 +0200

    staging: ks7010: factor out irq setup process to ks7010_sdio_setup_irqs
    
    This commit extract sdio irq setup process into a new
    function ks7010_sdio_setup_irqs to improve readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 64a58e8e2b90..98ef6206976d 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -802,6 +802,26 @@ static void ks7010_init_defaults(struct ks_wlan_private *priv)
 	priv->reg.rate_set.size = 12;
 }
 
+static int ks7010_sdio_setup_irqs(struct sdio_func *func)
+{
+	int ret;
+
+	/* interrupt disable */
+	sdio_writeb(func, 0, INT_ENABLE, &ret);
+	if (ret)
+		goto irq_error;
+
+	sdio_writeb(func, 0xff, INT_PENDING, &ret);
+	if (ret)
+		goto irq_error;
+
+	/* setup interrupt handler */
+	ret = sdio_claim_irq(func, ks_sdio_interrupt);
+
+irq_error:
+	return ret;
+}
+
 static void ks7010_sdio_init_irqs(struct sdio_func *func,
 				  struct ks_wlan_private *priv)
 {
@@ -855,17 +875,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	if (ret)
 		goto err_free_card;
 
-	/* interrupt disable */
-	sdio_writeb(func, 0, INT_ENABLE, &ret);
-	if (ret)
-		goto err_disable_func;
-
-	sdio_writeb(func, 0xff, INT_PENDING, &ret);
-	if (ret)
-		goto err_disable_func;
-
-	/* setup interrupt handler */
-	ret = sdio_claim_irq(func, ks_sdio_interrupt);
+	ret = ks7010_sdio_setup_irqs(func);
 	if (ret)
 		goto err_disable_func;
 

commit f4f540565896d6a1392997b17148b701017832ac
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 3 17:12:56 2018 +0200

    staging: ks7010: fix label to jump to in error case
    
    This commit fixs the label to jump to when in case
    an error occurs disabling interrupts. At this point
    of the code sdio_enable_func() function has been
    successfully called.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 6ba8109fa120..64a58e8e2b90 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -858,7 +858,8 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	/* interrupt disable */
 	sdio_writeb(func, 0, INT_ENABLE, &ret);
 	if (ret)
-		goto err_free_card;
+		goto err_disable_func;
+
 	sdio_writeb(func, 0xff, INT_PENDING, &ret);
 	if (ret)
 		goto err_disable_func;

commit 0e80e31afb78bbb40b53f79c2c6a96ac3184a770
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 3 17:12:55 2018 +0200

    staging: ks7010: factor out irq enable process to ks7010_sdio_init_irqs
    
    This commit extracts sdio irq enable process to a new function
    ks7010_sdio_init_irqs to improve readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 48c7cc83d4a3..6ba8109fa120 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -802,13 +802,38 @@ static void ks7010_init_defaults(struct ks_wlan_private *priv)
 	priv->reg.rate_set.size = 12;
 }
 
+static void ks7010_sdio_init_irqs(struct sdio_func *func,
+				  struct ks_wlan_private *priv)
+{
+	unsigned char byte;
+	int ret;
+
+	/*
+	 * interrupt setting
+	 * clear Interrupt status write
+	 * (ARMtoSD_InterruptPending FN1:00_0024)
+	 */
+	sdio_claim_host(func);
+	ret = ks7010_sdio_writeb(priv, INT_PENDING, 0xff);
+	sdio_release_host(func);
+	if (ret)
+		netdev_err(priv->net_dev, " error : INT_PENDING\n");
+
+	/* enable ks7010sdio interrupt */
+	byte = (INT_GCR_B | INT_READ_STATUS | INT_WRITE_STATUS);
+	sdio_claim_host(func);
+	ret = ks7010_sdio_writeb(priv, INT_ENABLE, byte);
+	sdio_release_host(func);
+	if (ret)
+		netdev_err(priv->net_dev, " err : INT_ENABLE\n");
+}
+
 static int ks7010_sdio_probe(struct sdio_func *func,
 			     const struct sdio_device_id *device)
 {
 	struct ks_wlan_private *priv;
 	struct ks_sdio_card *card;
 	struct net_device *netdev;
-	unsigned char byte;
 	int ret;
 
 	priv = NULL;
@@ -898,21 +923,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 		goto err_free_netdev;
 	}
 
-	/* interrupt setting */
-	/* clear Interrupt status write (ARMtoSD_InterruptPending FN1:00_0024) */
-	sdio_claim_host(func);
-	ret = ks7010_sdio_writeb(priv, INT_PENDING, 0xff);
-	sdio_release_host(func);
-	if (ret)
-		netdev_err(priv->net_dev, " error : INT_PENDING\n");
-
-	/* enable ks7010sdio interrupt */
-	byte = (INT_GCR_B | INT_READ_STATUS | INT_WRITE_STATUS);
-	sdio_claim_host(func);
-	ret = ks7010_sdio_writeb(priv, INT_ENABLE, byte);
-	sdio_release_host(func);
-	if (ret)
-		netdev_err(priv->net_dev, " err : INT_ENABLE\n");
+	ks7010_sdio_init_irqs(func, priv);
 
 	priv->dev_state = DEVICE_STATE_BOOT;
 

commit cea78d6124efe56efccd12793ac45e86b9afe3f4
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 3 17:12:54 2018 +0200

    staging: ks7010: remove unnecessary 'out of memory' message
    
    This commit removes unnecessay out of memory message
    fixing the following checkpach.pl warning:
    WARNING: Possible unnecessary 'out of memory' message
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 53c9afc06df3..48c7cc83d4a3 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -957,10 +957,8 @@ static int send_stop_request(struct sdio_func *func)
 	card = sdio_get_drvdata(func);
 
 	pp = kzalloc(hif_align_size(sizeof(*pp)), GFP_KERNEL);
-	if (!pp) {
-		netdev_err(card->priv->net_dev, "allocate memory failed..\n");
+	if (!pp)
 		return -ENOMEM;
-	}
 
 	size = sizeof(*pp) - sizeof(pp->header.size);
 	pp->header.size = cpu_to_le16((uint16_t)size);

commit 9f2ae0a40c23d6d35cab2e74474ade3ef886881d
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:09 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct hostif_stop_request_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct hostif_stop_request_t' with 'struct
    hostif_stop_request'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 0cc14ac9e8e1..53c9afc06df3 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -950,7 +950,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 /* send stop request to MAC */
 static int send_stop_request(struct sdio_func *func)
 {
-	struct hostif_stop_request_t *pp;
+	struct hostif_stop_request *pp;
 	struct ks_sdio_card *card;
 	size_t size;
 

commit b1e04ba095a9761b786d745cf716c3354cf2aa4b
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Mar 29 20:07:56 2018 +0200

    staging: ks7010: replace IS_HIF_CONF with inline function
    
    This commit replaces IS_HIF_CONF macro with is_11b_rate inline
    function to improve readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index b8f55a11ee1c..0cc14ac9e8e1 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -408,7 +408,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 		netdev_err(priv->net_dev, " error : READ_STATUS\n");
 
 	if (atomic_read(&priv->psstatus.confirm_wait)) {
-		if (IS_HIF_CONF(event)) {
+		if (is_hif_conf(event)) {
 			netdev_dbg(priv->net_dev, "IS_HIF_CONF true !!\n");
 			atomic_dec(&priv->psstatus.confirm_wait);
 		}

commit 31ce0d861cd1053b3950cf405c73f32ca9ed73ea
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Mar 20 15:36:43 2018 +0100

    staging: ks7010: replace KS_WLAN_DEBUG with DEBUG preprocessor directive
    
    This commit replaces custom KS_WLAN_DEBUG which is not being used anymore
    in favour of DEBUG which is the one included when debugging is enabled.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 50a7a15a93f1..b8f55a11ee1c 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -385,11 +385,10 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 
 	/* length check */
 	if (size > 2046 || size == 0) {
-#ifdef KS_WLAN_DEBUG
-		if (KS_WLAN_DEBUG > 5)
-			print_hex_dump_bytes("INVALID DATA dump: ",
-					     DUMP_PREFIX_OFFSET,
-					     rx_buffer->data, 32);
+#ifdef DEBUG
+		print_hex_dump_bytes("INVALID DATA dump: ",
+				     DUMP_PREFIX_OFFSET,
+				     rx_buffer->data, 32);
 #endif
 		ret = ks7010_sdio_writeb(priv, READ_STATUS, REG_STATUS_IDLE);
 		if (ret)

commit 5259b3293617ea88842a658793ffaa61ea0e0ef4
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Mar 15 20:09:22 2018 +0100

    staging: ks7010: replace DPRINTK traces in favour of netdev_*
    
    This commit removes custom defined DPRINTK macro and replaces all the
    associated debug and other traces for preferred ones netdev_*.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index beb689b7d54e..50a7a15a93f1 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -118,7 +118,7 @@ static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 	if (atomic_read(&priv->sleepstatus.status) == 0) {
 		ret = ks7010_sdio_writeb(priv, GCR_B, GCR_B_DOZE);
 		if (ret) {
-			DPRINTK(1, " error : GCR_B\n");
+			netdev_err(priv->net_dev, " error : GCR_B\n");
 			goto set_sleep_mode;
 		}
 		atomic_set(&priv->sleepstatus.status, 1);
@@ -139,7 +139,7 @@ static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 	if (atomic_read(&priv->sleepstatus.status) == 1) {
 		ret = ks7010_sdio_writeb(priv, WAKEUP, WAKEUP_REQ);
 		if (ret) {
-			DPRINTK(1, " error : WAKEUP\n");
+			netdev_err(priv->net_dev, " error : WAKEUP\n");
 			goto set_sleep_mode;
 		}
 		atomic_set(&priv->sleepstatus.status, 0);
@@ -158,7 +158,7 @@ void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 		ret = ks7010_sdio_writeb(priv, WAKEUP, WAKEUP_REQ);
 		if (ret)
-			DPRINTK(1, " error : WAKEUP\n");
+			netdev_err(priv->net_dev, " error : WAKEUP\n");
 
 		priv->last_wakeup = jiffies;
 		++priv->wakeup_count;
@@ -185,11 +185,11 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE)
 		return;
 
-	DPRINTK(5, "\npsstatus.status=%d\npsstatus.confirm_wait=%d\npsstatus.snooze_guard=%d\ncnt_txqbody=%d\n",
-		atomic_read(&priv->psstatus.status),
-		atomic_read(&priv->psstatus.confirm_wait),
-		atomic_read(&priv->psstatus.snooze_guard),
-		cnt_txqbody(priv));
+	netdev_dbg(priv->net_dev, "\npsstatus.status=%d\npsstatus.confirm_wait=%d\npsstatus.snooze_guard=%d\ncnt_txqbody=%d\n",
+		   atomic_read(&priv->psstatus.status),
+		   atomic_read(&priv->psstatus.confirm_wait),
+		   atomic_read(&priv->psstatus.snooze_guard),
+		   cnt_txqbody(priv));
 
 	if (atomic_read(&priv->psstatus.confirm_wait) ||
 	    atomic_read(&priv->psstatus.snooze_guard) ||
@@ -200,7 +200,7 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 
 	ret = ks7010_sdio_readb(priv, INT_PENDING, &byte);
 	if (ret) {
-		DPRINTK(1, " error : INT_PENDING\n");
+		netdev_err(priv->net_dev, " error : INT_PENDING\n");
 		goto queue_delayed_work;
 	}
 	if (byte)
@@ -208,7 +208,7 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 
 	ret = ks7010_sdio_writeb(priv, GCR_B, GCR_B_DOZE);
 	if (ret) {
-		DPRINTK(1, " error : GCR_B\n");
+		netdev_err(priv->net_dev, " error : GCR_B\n");
 		goto queue_delayed_work;
 	}
 	atomic_set(&priv->psstatus.status, PS_SNOOZE);
@@ -240,7 +240,7 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 	}
 
 	if ((TX_DEVICE_BUFF_SIZE - 1) <= cnt_txqbody(priv)) {
-		DPRINTK(1, "tx buffer overflow\n");
+		netdev_err(priv->net_dev, "tx buffer overflow\n");
 		ret = -EOVERFLOW;
 		goto err_complete;
 	}
@@ -273,19 +273,19 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 
 	if (le16_to_cpu(hdr->event) < HIF_DATA_REQ ||
 	    le16_to_cpu(hdr->event) > HIF_REQ_MAX) {
-		DPRINTK(1, "unknown event=%04X\n", hdr->event);
+		netdev_err(priv->net_dev, "unknown event=%04X\n", hdr->event);
 		return 0;
 	}
 
 	ret = ks7010_sdio_write(priv, DATA_WINDOW, buffer, size);
 	if (ret) {
-		DPRINTK(1, " write error : retval=%d\n", ret);
+		netdev_err(priv->net_dev, " write error : retval=%d\n", ret);
 		return ret;
 	}
 
 	ret = ks7010_sdio_writeb(priv, WRITE_STATUS, REG_STATUS_BUSY);
 	if (ret) {
-		DPRINTK(1, " error : WRITE_STATUS\n");
+		netdev_err(priv->net_dev, " error : WRITE_STATUS\n");
 		return ret;
 	}
 
@@ -305,7 +305,7 @@ static void tx_device_task(struct ks_wlan_private *priv)
 	if (priv->dev_state >= DEVICE_STATE_BOOT) {
 		ret = write_to_device(priv, sp->sendp, sp->size);
 		if (ret) {
-			DPRINTK(1, "write_to_device error !!(%d)\n", ret);
+			netdev_err(priv->net_dev, "write_to_device error !!(%d)\n", ret);
 			queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 			return;
 		}
@@ -331,7 +331,7 @@ int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
 
 	if (le16_to_cpu(hdr->event) < HIF_DATA_REQ ||
 	    le16_to_cpu(hdr->event) > HIF_REQ_MAX) {
-		DPRINTK(1, "unknown event=%04X\n", hdr->event);
+		netdev_err(priv->net_dev, "unknown event=%04X\n", hdr->event);
 		return 0;
 	}
 
@@ -373,7 +373,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 
 	/* receive data */
 	if (cnt_rxqbody(priv) >= (RX_DEVICE_BUFF_SIZE - 1)) {
-		DPRINTK(1, "rx buffer overflow\n");
+		netdev_err(priv->net_dev, "rx buffer overflow\n");
 		return;
 	}
 	rx_buffer = &priv->rx_dev.rx_dev_buff[priv->rx_dev.qtail];
@@ -393,7 +393,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 #endif
 		ret = ks7010_sdio_writeb(priv, READ_STATUS, REG_STATUS_IDLE);
 		if (ret)
-			DPRINTK(1, " error : READ_STATUS\n");
+			netdev_err(priv->net_dev, " error : READ_STATUS\n");
 
 		/* length check fail */
 		return;
@@ -406,11 +406,11 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 
 	ret = ks7010_sdio_writeb(priv, READ_STATUS, REG_STATUS_IDLE);
 	if (ret)
-		DPRINTK(1, " error : READ_STATUS\n");
+		netdev_err(priv->net_dev, " error : READ_STATUS\n");
 
 	if (atomic_read(&priv->psstatus.confirm_wait)) {
 		if (IS_HIF_CONF(event)) {
-			DPRINTK(4, "IS_HIF_CONF true !!\n");
+			netdev_dbg(priv->net_dev, "IS_HIF_CONF true !!\n");
 			atomic_dec(&priv->psstatus.confirm_wait);
 		}
 	}
@@ -428,14 +428,14 @@ static void ks7010_rw_function(struct work_struct *work)
 
 	/* wait after DOZE */
 	if (time_after(priv->last_doze + ((30 * HZ) / 1000), jiffies)) {
-		DPRINTK(4, "wait after DOZE\n");
+		netdev_dbg(priv->net_dev, "wait after DOZE\n");
 		queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 		return;
 	}
 
 	/* wait after WAKEUP */
 	while (time_after(priv->last_wakeup + ((30 * HZ) / 1000), jiffies)) {
-		DPRINTK(4, "wait after WAKEUP\n");
+		netdev_dbg(priv->net_dev, "wait after WAKEUP\n");
 		dev_info(&priv->ks_sdio_card->func->dev,
 			 "wake: %lu %lu\n",
 			 priv->last_wakeup + (30 * HZ) / 1000,
@@ -468,8 +468,8 @@ static void ks7010_rw_function(struct work_struct *work)
 	/* read (WriteStatus/ReadDataSize FN1:00_0014) */
 	ret = ks7010_sdio_readb(priv, WSTATUS_RSIZE, &byte);
 	if (ret) {
-		DPRINTK(1, " error : WSTATUS_RSIZE psstatus=%d\n",
-			atomic_read(&priv->psstatus.status));
+		netdev_err(priv->net_dev, " error : WSTATUS_RSIZE psstatus=%d\n",
+			   atomic_read(&priv->psstatus.status));
 		goto release_host;
 	}
 
@@ -500,7 +500,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 
 	ret = ks7010_sdio_readb(priv, INT_PENDING, &status);
 	if (ret) {
-		DPRINTK(1, "error : INT_PENDING\n");
+		netdev_err(priv->net_dev, "error : INT_PENDING\n");
 		goto queue_delayed_work;
 	}
 
@@ -513,7 +513,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	    atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 		ret = ks7010_sdio_readb(priv, GCR_B, &byte);
 		if (ret) {
-			DPRINTK(1, " error : GCR_B\n");
+			netdev_err(priv->net_dev, " error : GCR_B\n");
 			goto queue_delayed_work;
 		}
 		if (byte == GCR_B_ACTIVE) {
@@ -529,7 +529,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 		/* read (WriteStatus/ReadDataSize FN1:00_0014) */
 		ret = ks7010_sdio_readb(priv, WSTATUS_RSIZE, &byte);
 		if (ret) {
-			DPRINTK(1, " error : WSTATUS_RSIZE\n");
+			netdev_err(priv->net_dev, " error : WSTATUS_RSIZE\n");
 			goto queue_delayed_work;
 		}
 		rsize = byte & RSIZE_MASK;
@@ -628,7 +628,7 @@ static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 
 	if (memcmp(data, read_buf, size) != 0) {
 		ret = -EIO;
-		DPRINTK(0, "data compare error (%d)\n", ret);
+		netdev_err(priv->net_dev, "data compare error (%d)\n", ret);
 		goto err_free_read_buf;
 	}
 
@@ -659,7 +659,7 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	/* Firmware running ? */
 	ret = ks7010_sdio_readb(priv, GCR_A, &byte);
 	if (byte == GCR_A_RUN) {
-		DPRINTK(0, "MAC firmware running ...\n");
+		netdev_dbg(priv->net_dev, "MAC firmware running ...\n");
 		goto release_host_and_free;
 	}
 
@@ -715,7 +715,7 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 			break;
 	}
 	if ((50) <= n) {
-		DPRINTK(1, "firmware can't start\n");
+		netdev_err(priv->net_dev, "firmware can't start\n");
 		ret = -EIO;
 		goto release_firmware;
 	}
@@ -740,7 +740,7 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 
 	if (!wait_for_completion_interruptible_timeout
 	    (&priv->confirm_wait, 5 * HZ)) {
-		DPRINTK(1, "wait time out!! SME_START\n");
+		netdev_dbg(priv->net_dev, "wait time out!! SME_START\n");
 	}
 
 	if (priv->mac_address_valid && priv->version_size != 0)
@@ -767,11 +767,11 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 
 	if (!wait_for_completion_interruptible_timeout
 	    (&priv->confirm_wait, 5 * HZ)) {
-		DPRINTK(1, "wait time out!! wireless parameter set\n");
+		netdev_dbg(priv->net_dev, "wait time out!! wireless parameter set\n");
 	}
 
 	if (priv->dev_state >= DEVICE_STATE_PREINIT) {
-		DPRINTK(1, "DEVICE READY!!\n");
+		netdev_dbg(priv->net_dev, "DEVICE READY!!\n");
 		priv->dev_state = DEVICE_STATE_READY;
 	}
 }
@@ -824,7 +824,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	sdio_claim_host(func);
 
 	ret = sdio_set_block_size(func, KS7010_IO_BLOCK_SIZE);
-	DPRINTK(5, "multi_block=%d sdio_set_block_size()=%d %d\n",
+	dev_dbg(&card->func->dev, "multi_block=%d sdio_set_block_size()=%d %d\n",
 		func->card->cccr.multi_block, func->cur_blksize, ret);
 
 	ret = sdio_enable_func(func);
@@ -848,7 +848,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 
 	sdio_set_drvdata(func, card);
 
-	DPRINTK(5, "class = 0x%X, vendor = 0x%X, device = 0x%X\n",
+	dev_dbg(&card->func->dev, "class = 0x%X, vendor = 0x%X, device = 0x%X\n",
 		func->class, func->vendor, func->device);
 
 	/* private memory allocate */
@@ -893,9 +893,9 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 
 	ret = ks7010_upload_firmware(card);
 	if (ret) {
-		dev_err(&card->func->dev,
-			"ks7010: firmware load failed !! return code = %d\n",
-			 ret);
+		netdev_err(priv->net_dev,
+			   "ks7010: firmware load failed !! return code = %d\n",
+			   ret);
 		goto err_free_netdev;
 	}
 
@@ -905,7 +905,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	ret = ks7010_sdio_writeb(priv, INT_PENDING, 0xff);
 	sdio_release_host(func);
 	if (ret)
-		DPRINTK(1, " error : INT_PENDING\n");
+		netdev_err(priv->net_dev, " error : INT_PENDING\n");
 
 	/* enable ks7010sdio interrupt */
 	byte = (INT_GCR_B | INT_READ_STATUS | INT_WRITE_STATUS);
@@ -913,13 +913,13 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	ret = ks7010_sdio_writeb(priv, INT_ENABLE, byte);
 	sdio_release_host(func);
 	if (ret)
-		DPRINTK(1, " err : INT_ENABLE\n");
+		netdev_err(priv->net_dev, " err : INT_ENABLE\n");
 
 	priv->dev_state = DEVICE_STATE_BOOT;
 
 	priv->wq = create_workqueue("wq");
 	if (!priv->wq) {
-		DPRINTK(1, "create_workqueue failed !!\n");
+		netdev_err(priv->net_dev, "create_workqueue failed !!\n");
 		goto err_free_netdev;
 	}
 
@@ -959,7 +959,7 @@ static int send_stop_request(struct sdio_func *func)
 
 	pp = kzalloc(hif_align_size(sizeof(*pp)), GFP_KERNEL);
 	if (!pp) {
-		DPRINTK(3, "allocate memory failed..\n");
+		netdev_err(card->priv->net_dev, "allocate memory failed..\n");
 		return -ENOMEM;
 	}
 

commit 7acf4002e348913c86015337ea0810acbb5443e0
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Mar 15 20:09:21 2018 +0100

    staging: ks7010: remove useless DPRINTK traces
    
    This commit removes some useless traces in some source files
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 7de78d1758b8..beb689b7d54e 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -112,8 +112,6 @@ static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 {
 	int ret;
 
-	DPRINTK(4, "\n");
-
 	/* clear request */
 	atomic_set(&priv->sleepstatus.doze_request, 0);
 
@@ -123,11 +121,8 @@ static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 			DPRINTK(1, " error : GCR_B\n");
 			goto set_sleep_mode;
 		}
-		DPRINTK(3, "sleep_mode=SLP_SLEEP\n");
 		atomic_set(&priv->sleepstatus.status, 1);
 		priv->last_doze = jiffies;
-	} else {
-		DPRINTK(1, "sleep_mode=%d\n", priv->sleep_mode);
 	}
 
 set_sleep_mode:
@@ -138,8 +133,6 @@ static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 {
 	int ret;
 
-	DPRINTK(4, "\n");
-
 	/* clear request */
 	atomic_set(&priv->sleepstatus.wakeup_request, 0);
 
@@ -149,12 +142,9 @@ static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 			DPRINTK(1, " error : WAKEUP\n");
 			goto set_sleep_mode;
 		}
-		DPRINTK(4, "wake up : WAKEUP\n");
 		atomic_set(&priv->sleepstatus.status, 0);
 		priv->last_wakeup = jiffies;
 		++priv->wakeup_count;
-	} else {
-		DPRINTK(1, "sleep_mode=%d\n", priv->sleep_mode);
 	}
 
 set_sleep_mode:
@@ -165,19 +155,13 @@ void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 {
 	int ret;
 
-	DPRINTK(4, "\n");
 	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 		ret = ks7010_sdio_writeb(priv, WAKEUP, WAKEUP_REQ);
 		if (ret)
 			DPRINTK(1, " error : WAKEUP\n");
-		else
-			DPRINTK(4, "wake up : WAKEUP\n");
 
 		priv->last_wakeup = jiffies;
 		++priv->wakeup_count;
-	} else {
-		DPRINTK(1, "psstatus=%d\n",
-			atomic_read(&priv->psstatus.status));
 	}
 }
 
@@ -228,7 +212,6 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 		goto queue_delayed_work;
 	}
 	atomic_set(&priv->psstatus.status, PS_SNOOZE);
-	DPRINTK(3, "psstatus.status=PS_SNOOZE\n");
 
 	return;
 
@@ -288,7 +271,6 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 
 	hdr = (struct hostif_hdr *)buffer;
 
-	DPRINTK(4, "size=%d\n", hdr->size);
 	if (le16_to_cpu(hdr->event) < HIF_DATA_REQ ||
 	    le16_to_cpu(hdr->event) > HIF_REQ_MAX) {
 		DPRINTK(1, "unknown event=%04X\n", hdr->event);
@@ -315,7 +297,6 @@ static void tx_device_task(struct ks_wlan_private *priv)
 	struct tx_device_buffer *sp;
 	int ret;
 
-	DPRINTK(4, "\n");
 	if (cnt_txqbody(priv) <= 0 ||
 	    atomic_read(&priv->psstatus.status) == PS_SNOOZE)
 		return;
@@ -358,7 +339,6 @@ int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
 	priv->hostt.buff[priv->hostt.qtail] = le16_to_cpu(hdr->event);
 	priv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;
 
-	DPRINTK(4, "event=%04X\n", hdr->event);
 	spin_lock(&priv->tx_dev.tx_dev_lock);
 	result = enqueue_txdev(priv, p, size, complete_handler, skb);
 	spin_unlock(&priv->tx_dev.tx_dev_lock);
@@ -374,8 +354,6 @@ static void rx_event_task(unsigned long dev)
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
 	struct rx_device_buffer *rp;
 
-	DPRINTK(4, "\n");
-
 	if (cnt_rxqbody(priv) > 0 && priv->dev_state >= DEVICE_STATE_BOOT) {
 		rp = &priv->rx_dev.rx_dev_buff[priv->rx_dev.qhead];
 		hostif_receive(priv, rp->data, rp->size);
@@ -393,8 +371,6 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 	struct hostif_hdr *hdr;
 	unsigned short event = 0;
 
-	DPRINTK(4, "\n");
-
 	/* receive data */
 	if (cnt_rxqbody(priv) >= (RX_DEVICE_BUFF_SIZE - 1)) {
 		DPRINTK(1, "rx buffer overflow\n");
@@ -450,8 +426,6 @@ static void ks7010_rw_function(struct work_struct *work)
 
 	priv = container_of(work, struct ks_wlan_private, rw_dwork.work);
 
-	DPRINTK(4, "\n");
-
 	/* wait after DOZE */
 	if (time_after(priv->last_doze + ((30 * HZ) / 1000), jiffies)) {
 		DPRINTK(4, "wait after DOZE\n");
@@ -498,7 +472,6 @@ static void ks7010_rw_function(struct work_struct *work)
 			atomic_read(&priv->psstatus.status));
 		goto release_host;
 	}
-	DPRINTK(4, "WSTATUS_RSIZE=%02X\n", byte);
 
 	if (byte & RSIZE_MASK) {	/* Read schedule */
 		ks_wlan_hw_rx(priv, (uint16_t)((byte & RSIZE_MASK) << 4));
@@ -521,7 +494,6 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 
 	card = sdio_get_drvdata(func);
 	priv = card->priv;
-	DPRINTK(4, "\n");
 
 	if (priv->dev_state < DEVICE_STATE_BOOT)
 		goto queue_delayed_work;
@@ -531,7 +503,6 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 		DPRINTK(1, "error : INT_PENDING\n");
 		goto queue_delayed_work;
 	}
-	DPRINTK(4, "INT_PENDING=%02X\n", status);
 
 	/* schedule task for interrupt status */
 	/* bit7 -> Write General Communication B register */
@@ -561,7 +532,6 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 			DPRINTK(1, " error : WSTATUS_RSIZE\n");
 			goto queue_delayed_work;
 		}
-		DPRINTK(4, "WSTATUS_RSIZE=%02X\n", byte);
 		rsize = byte & RSIZE_MASK;
 		if (rsize != 0)		/* Read schedule */
 			ks_wlan_hw_rx(priv, (uint16_t)(rsize << 4));
@@ -709,7 +679,6 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 			size = length;
 			length = 0;
 		}
-		DPRINTK(4, "size = %d\n", size);
 		if (size == 0)
 			break;
 		memcpy(rom_buf, fw_entry->data + n, size);
@@ -735,8 +704,6 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	if (ret)
 		goto release_firmware;
 
-	DPRINTK(4, " REMAP Request : GCR_A\n");
-
 	/* Firmware running check */
 	for (n = 0; n < 50; ++n) {
 		mdelay(10);	/* wait_ms(10); */
@@ -747,7 +714,6 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 		if (byte == GCR_A_RUN)
 			break;
 	}
-	DPRINTK(4, "firmware wakeup (%d)!!!!\n", n);
 	if ((50) <= n) {
 		DPRINTK(1, "firmware can't start\n");
 		ret = -EIO;
@@ -767,17 +733,11 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 
 static void ks7010_card_init(struct ks_wlan_private *priv)
 {
-	DPRINTK(5, "\ncard_init_task()\n");
-
 	init_completion(&priv->confirm_wait);
 
-	DPRINTK(5, "init_completion()\n");
-
 	/* get mac address & firmware version */
 	hostif_sme_enqueue(priv, SME_START);
 
-	DPRINTK(5, "hostif_sme_enqueu()\n");
-
 	if (!wait_for_completion_interruptible_timeout
 	    (&priv->confirm_wait, 5 * HZ)) {
 		DPRINTK(1, "wait time out!! SME_START\n");
@@ -813,8 +773,6 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 	if (priv->dev_state >= DEVICE_STATE_PREINIT) {
 		DPRINTK(1, "DEVICE READY!!\n");
 		priv->dev_state = DEVICE_STATE_READY;
-	} else {
-		DPRINTK(1, "dev_state=%d\n", priv->dev_state);
 	}
 }
 
@@ -870,7 +828,6 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 		func->card->cccr.multi_block, func->cur_blksize, ret);
 
 	ret = sdio_enable_func(func);
-	DPRINTK(5, "sdio_enable_func() %d\n", ret);
 	if (ret)
 		goto err_free_card;
 
@@ -958,7 +915,6 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	if (ret)
 		DPRINTK(1, " err : INT_ENABLE\n");
 
-	DPRINTK(4, " enable Interrupt : INT_ENABLE=%02X\n", byte);
 	priv->dev_state = DEVICE_STATE_BOOT;
 
 	priv->wq = create_workqueue("wq");
@@ -1031,35 +987,28 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 	if (!card)
 		return;
 
-	DPRINTK(1, "priv = card->priv\n");
 	priv = card->priv;
 	if (priv) {
 		struct net_device *netdev = priv->net_dev;
 
 		ks_wlan_net_stop(netdev);
-		DPRINTK(1, "ks_wlan_net_stop\n");
 
 		/* interrupt disable */
 		sdio_claim_host(func);
 		sdio_writeb(func, 0, INT_ENABLE, &ret);
 		sdio_writeb(func, 0xff, INT_PENDING, &ret);
 		sdio_release_host(func);
-		DPRINTK(1, "interrupt disable\n");
 
 		ret = send_stop_request(func);
 		if (ret)	/* memory allocation failure */
 			return;
 
-		DPRINTK(1, "STOP Req\n");
-
 		if (priv->wq) {
 			flush_workqueue(priv->wq);
 			destroy_workqueue(priv->wq);
 		}
-		DPRINTK(1, "destroy_workqueue(priv->wq);\n");
 
 		hostif_exit(priv);
-		DPRINTK(1, "hostif_exit\n");
 
 		unregister_netdev(netdev);
 
@@ -1070,17 +1019,10 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 
 	sdio_claim_host(func);
 	sdio_release_irq(func);
-	DPRINTK(1, "sdio_release_irq()\n");
 	sdio_disable_func(func);
-	DPRINTK(1, "sdio_disable_func()\n");
 	sdio_release_host(func);
-
 	sdio_set_drvdata(func, NULL);
-
 	kfree(card);
-	DPRINTK(1, "kfree()\n");
-
-	DPRINTK(5, " Bye !!\n");
 }
 
 static struct sdio_driver ks7010_sdio_driver = {

commit 2ec999e5545598df373dd00d32527bb11e7070c0
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Mon Feb 19 22:35:36 2018 -0800

    Staging: ks7010: sdio: Convert RX/TX queue macros into real functions.
    
    Convert the unsafe macros into inline functions.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 8cfdff198334..7de78d1758b8 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -32,19 +32,39 @@ static const struct sdio_device_id ks7010_sdio_ids[] = {
 };
 MODULE_DEVICE_TABLE(sdio, ks7010_sdio_ids);
 
-#define inc_txqhead(priv) \
-	(priv->tx_dev.qhead = (priv->tx_dev.qhead + 1) % TX_DEVICE_BUFF_SIZE)
-#define inc_txqtail(priv) \
-	(priv->tx_dev.qtail = (priv->tx_dev.qtail + 1) % TX_DEVICE_BUFF_SIZE)
-#define cnt_txqbody(priv) \
-	(((priv->tx_dev.qtail + TX_DEVICE_BUFF_SIZE) - (priv->tx_dev.qhead)) % TX_DEVICE_BUFF_SIZE)
-
-#define inc_rxqhead(priv) \
-	(priv->rx_dev.qhead = (priv->rx_dev.qhead + 1) % RX_DEVICE_BUFF_SIZE)
-#define inc_rxqtail(priv) \
-	(priv->rx_dev.qtail = (priv->rx_dev.qtail + 1) % RX_DEVICE_BUFF_SIZE)
-#define cnt_rxqbody(priv) \
-	(((priv->rx_dev.qtail + RX_DEVICE_BUFF_SIZE) - (priv->rx_dev.qhead)) % RX_DEVICE_BUFF_SIZE)
+static inline void inc_txqhead(struct ks_wlan_private *priv)
+{
+	priv->tx_dev.qhead = (priv->tx_dev.qhead + 1) % TX_DEVICE_BUFF_SIZE;
+}
+
+static inline void inc_txqtail(struct ks_wlan_private *priv)
+{
+	priv->tx_dev.qtail = (priv->tx_dev.qtail + 1) % TX_DEVICE_BUFF_SIZE;
+}
+
+static inline unsigned int cnt_txqbody(struct ks_wlan_private *priv)
+{
+	unsigned int tx_cnt = priv->tx_dev.qtail - priv->tx_dev.qhead;
+
+	return (tx_cnt + TX_DEVICE_BUFF_SIZE) % TX_DEVICE_BUFF_SIZE;
+}
+
+static inline void inc_rxqhead(struct ks_wlan_private *priv)
+{
+	priv->rx_dev.qhead = (priv->rx_dev.qhead + 1) % RX_DEVICE_BUFF_SIZE;
+}
+
+static inline void inc_rxqtail(struct ks_wlan_private *priv)
+{
+	priv->rx_dev.qtail = (priv->rx_dev.qtail + 1) % RX_DEVICE_BUFF_SIZE;
+}
+
+static inline unsigned int cnt_rxqbody(struct ks_wlan_private *priv)
+{
+	unsigned int rx_cnt = priv->rx_dev.qtail - priv->rx_dev.qhead;
+
+	return (rx_cnt + RX_DEVICE_BUFF_SIZE) % RX_DEVICE_BUFF_SIZE;
+}
 
 /* Read single byte from device address into byte (CMD52) */
 static int ks7010_sdio_readb(struct ks_wlan_private *priv, unsigned int address,

commit aef0278e108b2e0a0fbe75f545772c23abce8c40
Author: Jonathan Whitaker <jon.b.whitaker@gmail.com>
Date:   Wed Aug 30 22:24:53 2017 -0600

    staging: ks7010: Fix coding style and remove checkpatch.pl warnings.
    
    Removed printk statements for debugging. The same information can be
    acquired via ftrace, so these print statements are uneccessary.
    
    Signed-off-by: Jonathan Whitaker <jon.b.whitaker@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 9b28ee1cfb1e..8cfdff198334 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -834,8 +834,6 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	unsigned char byte;
 	int ret;
 
-	DPRINTK(5, "ks7010_sdio_probe()\n");
-
 	priv = NULL;
 	netdev = NULL;
 
@@ -1008,8 +1006,6 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 	struct ks_sdio_card *card;
 	struct ks_wlan_private *priv;
 
-	DPRINTK(1, "ks7010_sdio_remove()\n");
-
 	card = sdio_get_drvdata(func);
 
 	if (!card)

commit d9d1ffd4bf80ebf77609c145e2e97e2cfd4f8f02
Author: Cezary Gapinski <gapalinux@gmail.com>
Date:   Sat Apr 29 19:54:30 2017 +0200

    staging/ks7010: Fix type assignment for struct hostif_hdr
    
    Sparse spits out a warnings about __le16 and unsigned short assignment.
    Change the type of size and event members of struct hostif_hdr
    to __le16 and correct conversion to the proper cpu type.
    
    Signed-off-by: Cezary Gapinski <gapalinux@gmail.com>
    Reviewed-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index c325f4846209..9b28ee1cfb1e 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -269,7 +269,8 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 	hdr = (struct hostif_hdr *)buffer;
 
 	DPRINTK(4, "size=%d\n", hdr->size);
-	if (hdr->event < HIF_DATA_REQ || HIF_REQ_MAX < hdr->event) {
+	if (le16_to_cpu(hdr->event) < HIF_DATA_REQ ||
+	    le16_to_cpu(hdr->event) > HIF_REQ_MAX) {
 		DPRINTK(1, "unknown event=%04X\n", hdr->event);
 		return 0;
 	}
@@ -327,13 +328,14 @@ int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
 
 	hdr = (struct hostif_hdr *)p;
 
-	if (hdr->event < HIF_DATA_REQ || HIF_REQ_MAX < hdr->event) {
+	if (le16_to_cpu(hdr->event) < HIF_DATA_REQ ||
+	    le16_to_cpu(hdr->event) > HIF_REQ_MAX) {
 		DPRINTK(1, "unknown event=%04X\n", hdr->event);
 		return 0;
 	}
 
 	/* add event to hostt buffer */
-	priv->hostt.buff[priv->hostt.qtail] = hdr->event;
+	priv->hostt.buff[priv->hostt.qtail] = le16_to_cpu(hdr->event);
 	priv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;
 
 	DPRINTK(4, "event=%04X\n", hdr->event);
@@ -403,7 +405,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 
 	hdr = (struct hostif_hdr *)&rx_buffer->data[0];
 	rx_buffer->size = le16_to_cpu(hdr->size) + sizeof(hdr->size);
-	event = hdr->event;
+	event = le16_to_cpu(hdr->event);
 	inc_rxqtail(priv);
 
 	ret = ks7010_sdio_writeb(priv, READ_STATUS, REG_STATUS_IDLE);

commit 8fb8e05ccafaa0e09fd93d9bffd0b4037cc36317
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:22 2017 +1000

    staging: ks7010: make abbreviation mgmt uniform
    
    Driver currently uses abbreviations 'mgt' and 'mngmt' for
    'management'. Also 'power' is sometimes abbreviated to 'pow' and other
    times not. It makes the code easier to read and easier to modify if
    one abbreviation is used throughout the driver. 'mgmt' is widely
    accepted as an abbreviation of 'management'. 'power' can be spelled
    out in full, the extra two characters aids readability without an
    excessive cost.
    
    Make abbreviation of 'management' uniform across the driver, function
    names, preprocessor defined constants, and enumeration types.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index e36c1d0f7053..c325f4846209 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -166,7 +166,7 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	unsigned char byte;
 	int ret;
 
-	if (priv->reg.powermgt == POWMGT_ACTIVE_MODE)
+	if (priv->reg.power_mgmt == POWER_MGMT_ACTIVE)
 		return;
 
 	if (priv->reg.operation_mode != MODE_INFRASTRUCTURE)
@@ -800,7 +800,7 @@ static void ks7010_init_defaults(struct ks_wlan_private *priv)
 {
 	priv->reg.tx_rate = TX_RATE_AUTO;
 	priv->reg.preamble = LONG_PREAMBLE;
-	priv->reg.powermgt = POWMGT_ACTIVE_MODE;
+	priv->reg.power_mgmt = POWER_MGMT_ACTIVE;
 	priv->reg.scan_type = ACTIVE_SCAN;
 	priv->reg.beacon_lost_count = 20;
 	priv->reg.rts = 2347UL;

commit 0e24eb8abf93a2e80ecbe97419d2d1fe089a7386
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:19 2017 +1000

    staging: ks7010: abstract connection status
    
    Host interface connection status is handled using a 32 bit type. Top
    byte is used as for FORCE_DISCONNECT status, low bits are used for
    connect/disconnect status. Driver masks and checks integers to
    ascertain status. If functions are defined to do the masking and
    equality check then the details of how the status integer is used are
    abstracted away. This makes the code easier to read. Also future
    updates to the status handling will be easier because the code is in
    one place.
    
    Driver currently uses the CONNECT_STATUS and DISCONNECT_STATUS as
    values, as apposed to opaque values. Because of this driver code
    checks for equality with CONNECT_STATUS and DISCONNECT_STATUS as
    apposed to negating a single check (ie 'foo != CONNECT_STATUS). In
    order to maintain the current functionality we define two separate
    functions is_connect_status() and is_disconnect_status().
    
    Add functions to abstract the status integer check. Update all sites
    that do the check manually to use the newly defined functions.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index ec1179916106..e36c1d0f7053 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -172,7 +172,7 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	if (priv->reg.operation_mode != MODE_INFRASTRUCTURE)
 		return;
 
-	if ((priv->connect_status & CONNECT_STATUS_MASK) != CONNECT_STATUS)
+	if (!is_connect_status(priv->connect_status))
 		return;
 
 	if (priv->dev_state != DEVICE_STATE_SLEEP)

commit 7c1c43615d784833f84d27e26d2fd046dea5f435
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:42 2017 +1000

    staging: ks7010: fix checkpatch SPLIT_STRING
    
    Checkpatch emits WARNING: quoted string split across lines.
    
    Concatenate string onto single line.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 4e62241164c1..ec1179916106 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -871,8 +871,8 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 
 	sdio_set_drvdata(func, card);
 
-	DPRINTK(5, "class = 0x%X, vendor = 0x%X, "
-		"device = 0x%X\n", func->class, func->vendor, func->device);
+	DPRINTK(5, "class = 0x%X, vendor = 0x%X, device = 0x%X\n",
+		func->class, func->vendor, func->device);
 
 	/* private memory allocate */
 	netdev = alloc_etherdev(sizeof(*priv));

commit f1e79f4b96c1fa21dfbfda48d511cc88c84e875f
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:41 2017 +1000

    staging: ks7010: refactor SDIO read/write helpers
    
    Driver SDIO code uses helper functions to do IO to the SDIO
    device. Current helpers handle IO of a single byte as well as
    multi-byte. Driver predominately uses single byte IO. If the
    common case is made simple it simplifies the whole driver. The common
    case can be made simple by splitting the multi-byte and single byte
    calls into separate functions, i.e 4 functions in total, read single
    byte, read multi-byte, write single byte, write multi-byte.
    
    Also, we need to handle the debug code. Currently debug calls after
    read/write fail access the IO buffer. This buffer, at best, does not hold
    useful data on the error path, at worst is uninitialized and holds
    garbage.
    
    Split read/write helper functions into two functions each, one for
    single byte IO and one for multi-byte IO. Fix all call sites. Do not
    change the program logic.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index aca7205e9c6f..4e62241164c1 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -46,51 +46,50 @@ MODULE_DEVICE_TABLE(sdio, ks7010_sdio_ids);
 #define cnt_rxqbody(priv) \
 	(((priv->rx_dev.qtail + RX_DEVICE_BUFF_SIZE) - (priv->rx_dev.qhead)) % RX_DEVICE_BUFF_SIZE)
 
-static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
-			    unsigned char *buffer, int length)
+/* Read single byte from device address into byte (CMD52) */
+static int ks7010_sdio_readb(struct ks_wlan_private *priv, unsigned int address,
+			     unsigned char *byte)
 {
-	struct ks_sdio_card *card;
+	struct sdio_func *func = priv->ks_sdio_card->func;
 	int ret;
 
-	card = priv->ks_sdio_card;
+	*byte = sdio_readb(func, address, &ret);
 
-	if (length == 1)	/* CMD52 */
-		*buffer = sdio_readb(card->func, address, &ret);
-	else	/* CMD53 multi-block transfer */
-		ret = sdio_memcpy_fromio(card->func, buffer, address, length);
+	return ret;
+}
 
-	if (ret) {
-		DPRINTK(1, "sdio error=%d size=%d\n", ret, length);
-		return ret;
-	}
+/* Read length bytes from device address into buffer (CMD53) */
+static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
+			    unsigned char *buffer, int length)
+{
+	struct sdio_func *func = priv->ks_sdio_card->func;
 
-	return 0;
+	return sdio_memcpy_fromio(func, buffer, address, length);
 }
 
-static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
-			     unsigned char *buffer, int length)
+/* Write single byte to device address (CMD52) */
+static int ks7010_sdio_writeb(struct ks_wlan_private *priv,
+			      unsigned int address, unsigned char byte)
 {
-	struct ks_sdio_card *card;
+	struct sdio_func *func = priv->ks_sdio_card->func;
 	int ret;
 
-	card = priv->ks_sdio_card;
+	sdio_writeb(func, byte, address, &ret);
 
-	if (length == 1)	/* CMD52 */
-		sdio_writeb(card->func, *buffer, address, &ret);
-	else	/* CMD53 */
-		ret = sdio_memcpy_toio(card->func, address, buffer, length);
+	return ret;
+}
 
-	if (ret) {
-		DPRINTK(1, "sdio error=%d size=%d\n", ret, length);
-		return ret;
-	}
+/* Write length bytes to device address from buffer (CMD53) */
+static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
+			     unsigned char *buffer, int length)
+{
+	struct sdio_func *func = priv->ks_sdio_card->func;
 
-	return 0;
+	return sdio_memcpy_toio(func, address, buffer, length);
 }
 
 static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 {
-	unsigned char rw_data;
 	int ret;
 
 	DPRINTK(4, "\n");
@@ -99,13 +98,11 @@ static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 	atomic_set(&priv->sleepstatus.doze_request, 0);
 
 	if (atomic_read(&priv->sleepstatus.status) == 0) {
-		rw_data = GCR_B_DOZE;
-		ret = ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
+		ret = ks7010_sdio_writeb(priv, GCR_B, GCR_B_DOZE);
 		if (ret) {
-			DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
+			DPRINTK(1, " error : GCR_B\n");
 			goto set_sleep_mode;
 		}
-		DPRINTK(4, "PMG SET!! : GCR_B=%02X\n", rw_data);
 		DPRINTK(3, "sleep_mode=SLP_SLEEP\n");
 		atomic_set(&priv->sleepstatus.status, 1);
 		priv->last_doze = jiffies;
@@ -119,7 +116,6 @@ static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 
 static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 {
-	unsigned char rw_data;
 	int ret;
 
 	DPRINTK(4, "\n");
@@ -128,13 +124,12 @@ static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 	atomic_set(&priv->sleepstatus.wakeup_request, 0);
 
 	if (atomic_read(&priv->sleepstatus.status) == 1) {
-		rw_data = WAKEUP_REQ;
-		ret = ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
+		ret = ks7010_sdio_writeb(priv, WAKEUP, WAKEUP_REQ);
 		if (ret) {
-			DPRINTK(1, " error : WAKEUP=%02X\n", rw_data);
+			DPRINTK(1, " error : WAKEUP\n");
 			goto set_sleep_mode;
 		}
-		DPRINTK(4, "wake up : WAKEUP=%02X\n", rw_data);
+		DPRINTK(4, "wake up : WAKEUP\n");
 		atomic_set(&priv->sleepstatus.status, 0);
 		priv->last_wakeup = jiffies;
 		++priv->wakeup_count;
@@ -148,17 +143,16 @@ static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 
 void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 {
-	unsigned char rw_data;
 	int ret;
 
 	DPRINTK(4, "\n");
 	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
-		rw_data = WAKEUP_REQ;
-		ret = ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
+		ret = ks7010_sdio_writeb(priv, WAKEUP, WAKEUP_REQ);
 		if (ret)
-			DPRINTK(1, " error : WAKEUP=%02X\n", rw_data);
+			DPRINTK(1, " error : WAKEUP\n");
+		else
+			DPRINTK(4, "wake up : WAKEUP\n");
 
-		DPRINTK(4, "wake up : WAKEUP=%02X\n", rw_data);
 		priv->last_wakeup = jiffies;
 		++priv->wakeup_count;
 	} else {
@@ -169,7 +163,7 @@ void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 
 static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 {
-	unsigned char rw_data;
+	unsigned char byte;
 	int ret;
 
 	if (priv->reg.powermgt == POWMGT_ACTIVE_MODE)
@@ -200,21 +194,19 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 		return;
 	}
 
-	ret = ks7010_sdio_read(priv, INT_PENDING, &rw_data, sizeof(rw_data));
+	ret = ks7010_sdio_readb(priv, INT_PENDING, &byte);
 	if (ret) {
-		DPRINTK(1, " error : INT_PENDING=%02X\n", rw_data);
+		DPRINTK(1, " error : INT_PENDING\n");
 		goto queue_delayed_work;
 	}
-	if (rw_data)
+	if (byte)
 		goto queue_delayed_work;
 
-	rw_data = GCR_B_DOZE;
-	ret = ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
+	ret = ks7010_sdio_writeb(priv, GCR_B, GCR_B_DOZE);
 	if (ret) {
-		DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
+		DPRINTK(1, " error : GCR_B\n");
 		goto queue_delayed_work;
 	}
-	DPRINTK(4, "PMG SET!! : GCR_B=%02X\n", rw_data);
 	atomic_set(&priv->psstatus.status, PS_SNOOZE);
 	DPRINTK(3, "psstatus.status=PS_SNOOZE\n");
 
@@ -271,7 +263,6 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 			   unsigned long size)
 {
-	unsigned char rw_data;
 	struct hostif_hdr *hdr;
 	int ret;
 
@@ -289,10 +280,9 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 		return ret;
 	}
 
-	rw_data = REG_STATUS_BUSY;
-	ret = ks7010_sdio_write(priv, WRITE_STATUS, &rw_data, sizeof(rw_data));
+	ret = ks7010_sdio_writeb(priv, WRITE_STATUS, REG_STATUS_BUSY);
 	if (ret) {
-		DPRINTK(1, " error : WRITE_STATUS=%02X\n", rw_data);
+		DPRINTK(1, " error : WRITE_STATUS\n");
 		return ret;
 	}
 
@@ -379,7 +369,6 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 	int ret;
 	struct rx_device_buffer *rx_buffer;
 	struct hostif_hdr *hdr;
-	unsigned char read_status;
 	unsigned short event = 0;
 
 	DPRINTK(4, "\n");
@@ -404,12 +393,9 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 					     DUMP_PREFIX_OFFSET,
 					     rx_buffer->data, 32);
 #endif
-		/* rx_status update */
-		read_status = REG_STATUS_IDLE;
-		ret = ks7010_sdio_write(priv, READ_STATUS, &read_status,
-					sizeof(read_status));
+		ret = ks7010_sdio_writeb(priv, READ_STATUS, REG_STATUS_IDLE);
 		if (ret)
-			DPRINTK(1, " error : READ_STATUS=%02X\n", read_status);
+			DPRINTK(1, " error : READ_STATUS\n");
 
 		/* length check fail */
 		return;
@@ -420,14 +406,9 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 	event = hdr->event;
 	inc_rxqtail(priv);
 
-	/* read status update */
-	read_status = REG_STATUS_IDLE;
-	ret = ks7010_sdio_write(priv, READ_STATUS, &read_status,
-				sizeof(read_status));
+	ret = ks7010_sdio_writeb(priv, READ_STATUS, REG_STATUS_IDLE);
 	if (ret)
-		DPRINTK(1, " error : READ_STATUS=%02X\n", read_status);
-
-	DPRINTK(4, "READ_STATUS=%02X\n", read_status);
+		DPRINTK(1, " error : READ_STATUS\n");
 
 	if (atomic_read(&priv->psstatus.confirm_wait)) {
 		if (IS_HIF_CONF(event)) {
@@ -442,7 +423,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 static void ks7010_rw_function(struct work_struct *work)
 {
 	struct ks_wlan_private *priv;
-	unsigned char rw_data;
+	unsigned char byte;
 	int ret;
 
 	priv = container_of(work, struct ks_wlan_private, rw_dwork.work);
@@ -489,18 +470,18 @@ static void ks7010_rw_function(struct work_struct *work)
 	}
 
 	/* read (WriteStatus/ReadDataSize FN1:00_0014) */
-	ret = ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data, sizeof(rw_data));
+	ret = ks7010_sdio_readb(priv, WSTATUS_RSIZE, &byte);
 	if (ret) {
-		DPRINTK(1, " error : WSTATUS_RSIZE=%02X psstatus=%d\n", rw_data,
+		DPRINTK(1, " error : WSTATUS_RSIZE psstatus=%d\n",
 			atomic_read(&priv->psstatus.status));
 		goto release_host;
 	}
-	DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
+	DPRINTK(4, "WSTATUS_RSIZE=%02X\n", byte);
 
-	if (rw_data & RSIZE_MASK) {	/* Read schedule */
-		ks_wlan_hw_rx(priv, (uint16_t)((rw_data & RSIZE_MASK) << 4));
+	if (byte & RSIZE_MASK) {	/* Read schedule */
+		ks_wlan_hw_rx(priv, (uint16_t)((byte & RSIZE_MASK) << 4));
 	}
-	if ((rw_data & WSTATUS_MASK))
+	if ((byte & WSTATUS_MASK))
 		tx_device_task(priv);
 
 	_ks_wlan_hw_power_save(priv);
@@ -514,7 +495,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	int ret;
 	struct ks_sdio_card *card;
 	struct ks_wlan_private *priv;
-	unsigned char status, rsize, rw_data;
+	unsigned char status, rsize, byte;
 
 	card = sdio_get_drvdata(func);
 	priv = card->priv;
@@ -523,12 +504,12 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	if (priv->dev_state < DEVICE_STATE_BOOT)
 		goto queue_delayed_work;
 
-	ret = ks7010_sdio_read(priv, INT_PENDING, &status, sizeof(status));
+	ret = ks7010_sdio_readb(priv, INT_PENDING, &status);
 	if (ret) {
-		DPRINTK(1, "read INT_PENDING Failed!!(%d)\n", ret);
+		DPRINTK(1, "error : INT_PENDING\n");
 		goto queue_delayed_work;
 	}
-	DPRINTK(4, "INT_PENDING=%02X\n", rw_data);
+	DPRINTK(4, "INT_PENDING=%02X\n", status);
 
 	/* schedule task for interrupt status */
 	/* bit7 -> Write General Communication B register */
@@ -537,13 +518,12 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	/* bit2 -> Read Status Busy  */
 	if (status & INT_GCR_B ||
 	    atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
-		ret = ks7010_sdio_read(priv, GCR_B, &rw_data,
-				       sizeof(rw_data));
+		ret = ks7010_sdio_readb(priv, GCR_B, &byte);
 		if (ret) {
-			DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
+			DPRINTK(1, " error : GCR_B\n");
 			goto queue_delayed_work;
 		}
-		if (rw_data == GCR_B_ACTIVE) {
+		if (byte == GCR_B_ACTIVE) {
 			if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 				atomic_set(&priv->psstatus.status, PS_WAKEUP);
 				priv->wakeup_count = 0;
@@ -554,18 +534,17 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 
 	do {
 		/* read (WriteStatus/ReadDataSize FN1:00_0014) */
-		ret = ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data,
-				       sizeof(rw_data));
+		ret = ks7010_sdio_readb(priv, WSTATUS_RSIZE, &byte);
 		if (ret) {
-			DPRINTK(1, " error : WSTATUS_RSIZE=%02X\n", rw_data);
+			DPRINTK(1, " error : WSTATUS_RSIZE\n");
 			goto queue_delayed_work;
 		}
-		DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
-		rsize = rw_data & RSIZE_MASK;
+		DPRINTK(4, "WSTATUS_RSIZE=%02X\n", byte);
+		rsize = byte & RSIZE_MASK;
 		if (rsize != 0)		/* Read schedule */
 			ks_wlan_hw_rx(priv, (uint16_t)(rsize << 4));
 
-		if (rw_data & WSTATUS_MASK) {
+		if (byte & WSTATUS_MASK) {
 			if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 				if (cnt_txqbody(priv)) {
 					ks_wlan_hw_wakeup_request(priv);
@@ -674,7 +653,7 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	struct ks_wlan_private *priv = card->priv;
 	unsigned int size, offset, n = 0;
 	unsigned char *rom_buf;
-	unsigned char rw_data = 0;
+	unsigned char byte = 0;
 	int ret;
 	unsigned int length;
 	const struct firmware *fw_entry = NULL;
@@ -686,8 +665,8 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	sdio_claim_host(card->func);
 
 	/* Firmware running ? */
-	ret = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
-	if (rw_data == GCR_A_RUN) {
+	ret = ks7010_sdio_readb(priv, GCR_A, &byte);
+	if (byte == GCR_A_RUN) {
 		DPRINTK(0, "MAC firmware running ...\n");
 		goto release_host_and_free;
 	}
@@ -730,21 +709,20 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 
 	} while (size);
 
-	rw_data = GCR_A_REMAP;
-	ret = ks7010_sdio_write(priv, GCR_A, &rw_data, sizeof(rw_data));
+	ret = ks7010_sdio_writeb(priv, GCR_A, GCR_A_REMAP);
 	if (ret)
 		goto release_firmware;
 
-	DPRINTK(4, " REMAP Request : GCR_A=%02X\n", rw_data);
+	DPRINTK(4, " REMAP Request : GCR_A\n");
 
 	/* Firmware running check */
 	for (n = 0; n < 50; ++n) {
 		mdelay(10);	/* wait_ms(10); */
-		ret = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
+		ret = ks7010_sdio_readb(priv, GCR_A, &byte);
 		if (ret)
 			goto release_firmware;
 
-		if (rw_data == GCR_A_RUN)
+		if (byte == GCR_A_RUN)
 			break;
 	}
 	DPRINTK(4, "firmware wakeup (%d)!!!!\n", n);
@@ -851,7 +829,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	struct ks_wlan_private *priv;
 	struct ks_sdio_card *card;
 	struct net_device *netdev;
-	unsigned char rw_data;
+	unsigned char byte;
 	int ret;
 
 	DPRINTK(5, "ks7010_sdio_probe()\n");
@@ -946,24 +924,21 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 
 	/* interrupt setting */
 	/* clear Interrupt status write (ARMtoSD_InterruptPending FN1:00_0024) */
-	rw_data = 0xff;
 	sdio_claim_host(func);
-	ret = ks7010_sdio_write(priv, INT_PENDING, &rw_data, sizeof(rw_data));
+	ret = ks7010_sdio_writeb(priv, INT_PENDING, 0xff);
 	sdio_release_host(func);
 	if (ret)
-		DPRINTK(1, " error : INT_PENDING=%02X\n", rw_data);
-
-	DPRINTK(4, " clear Interrupt : INT_PENDING=%02X\n", rw_data);
+		DPRINTK(1, " error : INT_PENDING\n");
 
-	/* enable ks7010sdio interrupt (INT_GCR_B|INT_READ_STATUS|INT_WRITE_STATUS) */
-	rw_data = (INT_GCR_B | INT_READ_STATUS | INT_WRITE_STATUS);
+	/* enable ks7010sdio interrupt */
+	byte = (INT_GCR_B | INT_READ_STATUS | INT_WRITE_STATUS);
 	sdio_claim_host(func);
-	ret = ks7010_sdio_write(priv, INT_ENABLE, &rw_data, sizeof(rw_data));
+	ret = ks7010_sdio_writeb(priv, INT_ENABLE, byte);
 	sdio_release_host(func);
 	if (ret)
-		DPRINTK(1, " err : INT_ENABLE=%02X\n", rw_data);
+		DPRINTK(1, " err : INT_ENABLE\n");
 
-	DPRINTK(4, " enable Interrupt : INT_ENABLE=%02X\n", rw_data);
+	DPRINTK(4, " enable Interrupt : INT_ENABLE=%02X\n", byte);
 	priv->dev_state = DEVICE_STATE_BOOT;
 
 	priv->wq = create_workqueue("wq");

commit a9d58d9ad8b48c9363cb157f41e92ba144462990
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:40 2017 +1000

    staging: ks7010: fix checkpatch LINE_SPACING
    
    Checkpatch emits CHECK: Please don't use multiple blank lines.
    
    Remove multiple blank lines.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 5cd78337a451..aca7205e9c6f 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1025,7 +1025,6 @@ static int send_stop_request(struct sdio_func *func)
 	return 0;
 }
 
-
 static void ks7010_sdio_remove(struct sdio_func *func)
 {
 	int ret;

commit 132f541532efb9d4d716eaa719ecfc9eb2cb95fc
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:39 2017 +1000

    staging: ks7010: fix checkpatch SPACE_BEFORE_TAB
    
    Checkpatch emits WARNING: please, no space before tabs.
    
    Remove space before tabs.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 13d5de930615..5cd78337a451 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -562,7 +562,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 		}
 		DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
 		rsize = rw_data & RSIZE_MASK;
-		if (rsize != 0) 	/* Read schedule */
+		if (rsize != 0)		/* Read schedule */
 			ks_wlan_hw_rx(priv, (uint16_t)(rsize << 4));
 
 		if (rw_data & WSTATUS_MASK) {

commit 0dd30a74b9dd69858721da0c695ccc293fffe973
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:38 2017 +1000

    staging: ks7010: remove err_ from non-error path label
    
    goto label includes 'err_' suffix but is executed on non-error paths.
    
    Remove err_ suffix from goto label.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 87d5519b6ccb..13d5de930615 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -474,18 +474,18 @@ static void ks7010_rw_function(struct work_struct *work)
 			ks_wlan_hw_wakeup_request(priv);
 			queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 		}
-		goto err_release_host;
+		goto release_host;
 	}
 
 	/* sleep mode doze */
 	if (atomic_read(&priv->sleepstatus.doze_request) == 1) {
 		ks_wlan_hw_sleep_doze_request(priv);
-		goto err_release_host;
+		goto release_host;
 	}
 	/* sleep mode wakeup */
 	if (atomic_read(&priv->sleepstatus.wakeup_request) == 1) {
 		ks_wlan_hw_sleep_wakeup_request(priv);
-		goto err_release_host;
+		goto release_host;
 	}
 
 	/* read (WriteStatus/ReadDataSize FN1:00_0014) */
@@ -493,7 +493,7 @@ static void ks7010_rw_function(struct work_struct *work)
 	if (ret) {
 		DPRINTK(1, " error : WSTATUS_RSIZE=%02X psstatus=%d\n", rw_data,
 			atomic_read(&priv->psstatus.status));
-		goto err_release_host;
+		goto release_host;
 	}
 	DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
 
@@ -505,7 +505,7 @@ static void ks7010_rw_function(struct work_struct *work)
 
 	_ks_wlan_hw_power_save(priv);
 
-err_release_host:
+release_host:
 	sdio_release_host(priv->ks_sdio_card->func);
 }
 

commit e61e73d71b48911009fb5bbd5f85ff579c4a9a79
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:37 2017 +1000

    staging: ks7010: clean up SDIO source comments
    
    SDIO code currently has a number of unneeded comments. Following
    kernel coding style we do not need extraneous comments, especially on
    code where it is clear what is being done. Spelling typos can be
    fixed.
    
    Remove unnecessary comments, fix typos in comments.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index e3e298995164..87d5519b6ccb 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -32,8 +32,6 @@ static const struct sdio_device_id ks7010_sdio_ids[] = {
 };
 MODULE_DEVICE_TABLE(sdio, ks7010_sdio_ids);
 
-/* macro */
-
 #define inc_txqhead(priv) \
 	(priv->tx_dev.qhead = (priv->tx_dev.qhead + 1) % TX_DEVICE_BUFF_SIZE)
 #define inc_txqtail(priv) \
@@ -247,7 +245,6 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 	}
 
 	if ((TX_DEVICE_BUFF_SIZE - 1) <= cnt_txqbody(priv)) {
-		/* in case of buffer overflow */
 		DPRINTK(1, "tx buffer overflow\n");
 		ret = -EOVERFLOW;
 		goto err_complete;
@@ -389,7 +386,6 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 
 	/* receive data */
 	if (cnt_rxqbody(priv) >= (RX_DEVICE_BUFF_SIZE - 1)) {
-		/* in case of buffer overflow */
 		DPRINTK(1, "rx buffer overflow\n");
 		return;
 	}
@@ -453,14 +449,14 @@ static void ks7010_rw_function(struct work_struct *work)
 
 	DPRINTK(4, "\n");
 
-	/* wiat after DOZE */
+	/* wait after DOZE */
 	if (time_after(priv->last_doze + ((30 * HZ) / 1000), jiffies)) {
 		DPRINTK(4, "wait after DOZE\n");
 		queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 		return;
 	}
 
-	/* wiat after WAKEUP */
+	/* wait after WAKEUP */
 	while (time_after(priv->last_wakeup + ((30 * HZ) / 1000), jiffies)) {
 		DPRINTK(4, "wait after WAKEUP\n");
 		dev_info(&priv->ks_sdio_card->func->dev,
@@ -588,15 +584,12 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 
 static int trx_device_init(struct ks_wlan_private *priv)
 {
-	/* initialize values (tx) */
 	priv->tx_dev.qhead = 0;
 	priv->tx_dev.qtail = 0;
 
-	/* initialize values (rx) */
 	priv->rx_dev.qhead = 0;
 	priv->rx_dev.qtail = 0;
 
-	/* initialize spinLock (tx,rx) */
 	spin_lock_init(&priv->tx_dev.tx_dev_lock);
 	spin_lock_init(&priv->rx_dev.rx_dev_lock);
 
@@ -612,7 +605,7 @@ static void trx_device_exit(struct ks_wlan_private *priv)
 	/* tx buffer clear */
 	while (cnt_txqbody(priv) > 0) {
 		sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];
-		kfree(sp->sendp);	/* allocated memory free */
+		kfree(sp->sendp);
 		if (sp->complete_handler)	/* TX Complete */
 			(*sp->complete_handler)(priv, sp->skb);
 		inc_txqhead(priv);
@@ -686,7 +679,6 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	unsigned int length;
 	const struct firmware *fw_entry = NULL;
 
-	/* buffer allocate */
 	rom_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
 	if (!rom_buf)
 		return -ENOMEM;
@@ -707,7 +699,6 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 
 	length = fw_entry->size;
 
-	/* Load Program */
 	n = 0;
 	do {
 		if (length >= ROM_BUFF_SIZE) {
@@ -721,18 +712,16 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 		if (size == 0)
 			break;
 		memcpy(rom_buf, fw_entry->data + n, size);
-		/* Update write index */
+
 		offset = n;
 		ret = ks7010_sdio_update_index(priv, KS7010_IRAM_ADDRESS + offset);
 		if (ret)
 			goto release_firmware;
 
-		/* Write data */
 		ret = ks7010_sdio_write(priv, DATA_WINDOW, rom_buf, size);
 		if (ret)
 			goto release_firmware;
 
-		/* compare */
 		ret = ks7010_sdio_data_compare(priv, DATA_WINDOW, rom_buf, size);
 		if (ret)
 			goto release_firmware;
@@ -741,7 +730,6 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 
 	} while (size);
 
-	/* Remap request */
 	rw_data = GCR_A_REMAP;
 	ret = ks7010_sdio_write(priv, GCR_A, &rw_data, sizeof(rw_data));
 	if (ret)
@@ -781,7 +769,6 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 {
 	DPRINTK(5, "\ncard_init_task()\n");
 
-	/* init_waitqueue_head(&priv->confirm_wait); */
 	init_completion(&priv->confirm_wait);
 
 	DPRINTK(5, "init_completion()\n");
@@ -872,27 +859,18 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	priv = NULL;
 	netdev = NULL;
 
-	/* initialize ks_sdio_card */
 	card = kzalloc(sizeof(*card), GFP_KERNEL);
 	if (!card)
 		return -ENOMEM;
 
 	card->func = func;
 
-	/*** Initialize  SDIO ***/
 	sdio_claim_host(func);
 
-	/* bus setting  */
-	/* Issue config request to override clock rate */
-
-	/* function blocksize set */
 	ret = sdio_set_block_size(func, KS7010_IO_BLOCK_SIZE);
 	DPRINTK(5, "multi_block=%d sdio_set_block_size()=%d %d\n",
 		func->card->cccr.multi_block, func->cur_blksize, ret);
 
-	/* Allocate the slot current */
-
-	/* function enable */
 	ret = sdio_enable_func(func);
 	DPRINTK(5, "sdio_enable_func() %d\n", ret);
 	if (ret)
@@ -942,7 +920,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	priv->net_dev = netdev;
 	priv->firmware_version[0] = '\0';
 	priv->version_size = 0;
-	priv->last_doze = jiffies;	/* set current jiffies */
+	priv->last_doze = jiffies;
 	priv->last_wakeup = jiffies;
 	memset(&priv->nstats, 0, sizeof(priv->nstats));
 	memset(&priv->wstats, 0, sizeof(priv->wstats));

commit 18bd6dd1f849105b0aca7666d8eb3528b8cd8a8e
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:35 2017 +1000

    staging: ks7010: move hw info into dev private data
    
    Currently driver uses a hardware information struct description to
    group some SDIO related functionality (work, work queue, sdio private
    data pointer). This structure is then embedded in the device private
    data structure. Having nested structures described in different header
    files means that to view the device private data programmers must open
    two header files. This structure could be embedded anonymously in the
    device private data and achieve the same result (grouping of function
    specific to SDIO) without the need to open multiple headers. However,
    the SDIO private data structure already has various different data and
    pointers, adding the embedded structure adds little extra meaning and
    lengthens all the dereferences throughout the driver, often meaning
    addition line breaks and braces. We can increase readability and
    reduce code complexity by moving the hardware information data and
    pointers to directly be within the device private data structure
    description.
    
    While preparing for this refactoring it was noted that the identifier
    currently used for the delayed work is 'rw_wq', this is confusing
    since the 'wq' suffix typically means 'work queue'. This identifier
    would be more meaningful if it used the suffix 'dwork' as does the
    declaration of queue_delayed_work() (include/linux/workqueue.h).
    
    The identifier for the work queue is currently 'ks7010sdio_wq'. This
    identifier can be shortened without loss of meaning because there is
    only one work queue within the driver. Identifier 'wq' is typical
    within in-tree driver code and aptly describes the pointer.
    
    Current pointer to the SDIO private data is identified by 'sdio_card',
    this is sufficiently meaningful from within the hw_info structure but
    once the hw_info_t structure is removed the pointer would be better to
    have a prefix appended to it to retain the prior level of meaning.
    
    Move members from struct hw_info_t to struct ks_wlan_private.
    
    Rename identifiers;
    struct delayed_work pointer 'rw_wq' to 'rw_dwork'.
    struct workqueue_struct pointer 'ks7010sdio_wq' to 'wq'.
    struct ks_sdio_card  pointer 'sdio_card' to 'ks_sdio_card'.
    
    Remove structure description hw_info_t. Fix init/destroy calls. Fix
    all call sites, SDIO private data access calls, and queuing calls.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 2d73ebb71a2e..e3e298995164 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -54,7 +54,7 @@ static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
 	struct ks_sdio_card *card;
 	int ret;
 
-	card = priv->ks_wlan_hw.sdio_card;
+	card = priv->ks_sdio_card;
 
 	if (length == 1)	/* CMD52 */
 		*buffer = sdio_readb(card->func, address, &ret);
@@ -75,7 +75,7 @@ static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
 	struct ks_sdio_card *card;
 	int ret;
 
-	card = priv->ks_wlan_hw.sdio_card;
+	card = priv->ks_sdio_card;
 
 	if (length == 1)	/* CMD52 */
 		sdio_writeb(card->func, *buffer, address, &ret);
@@ -198,8 +198,7 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	if (atomic_read(&priv->psstatus.confirm_wait) ||
 	    atomic_read(&priv->psstatus.snooze_guard) ||
 	    cnt_txqbody(priv)) {
-		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-				   &priv->ks_wlan_hw.rw_wq, 0);
+		queue_delayed_work(priv->wq, &priv->rw_dwork, 0);
 		return;
 	}
 
@@ -224,14 +223,12 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	return;
 
 queue_delayed_work:
-	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-			   &priv->ks_wlan_hw.rw_wq, 1);
+	queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 }
 
 int ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 {
-	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-			   &priv->ks_wlan_hw.rw_wq, 1);
+	queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 	return 0;
 }
 
@@ -320,8 +317,7 @@ static void tx_device_task(struct ks_wlan_private *priv)
 		ret = write_to_device(priv, sp->sendp, sp->size);
 		if (ret) {
 			DPRINTK(1, "write_to_device error !!(%d)\n", ret);
-			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-					   &priv->ks_wlan_hw.rw_wq, 1);
+			queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 			return;
 		}
 	}
@@ -330,10 +326,8 @@ static void tx_device_task(struct ks_wlan_private *priv)
 		(*sp->complete_handler)(priv, sp->skb);
 	inc_txqhead(priv);
 
-	if (cnt_txqbody(priv) > 0) {
-		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-				   &priv->ks_wlan_hw.rw_wq, 0);
-	}
+	if (cnt_txqbody(priv) > 0)
+		queue_delayed_work(priv->wq, &priv->rw_dwork, 0);
 }
 
 int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
@@ -360,10 +354,9 @@ int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
 	result = enqueue_txdev(priv, p, size, complete_handler, skb);
 	spin_unlock(&priv->tx_dev.tx_dev_lock);
 
-	if (cnt_txqbody(priv) > 0) {
-		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-				   &priv->ks_wlan_hw.rw_wq, 0);
-	}
+	if (cnt_txqbody(priv) > 0)
+		queue_delayed_work(priv->wq, &priv->rw_dwork, 0);
+
 	return result;
 }
 
@@ -452,42 +445,38 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 
 static void ks7010_rw_function(struct work_struct *work)
 {
-	struct hw_info_t *hw;
 	struct ks_wlan_private *priv;
 	unsigned char rw_data;
 	int ret;
 
-	hw = container_of(work, struct hw_info_t, rw_wq.work);
-	priv = container_of(hw, struct ks_wlan_private, ks_wlan_hw);
+	priv = container_of(work, struct ks_wlan_private, rw_dwork.work);
 
 	DPRINTK(4, "\n");
 
 	/* wiat after DOZE */
 	if (time_after(priv->last_doze + ((30 * HZ) / 1000), jiffies)) {
 		DPRINTK(4, "wait after DOZE\n");
-		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-				   &priv->ks_wlan_hw.rw_wq, 1);
+		queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 		return;
 	}
 
 	/* wiat after WAKEUP */
 	while (time_after(priv->last_wakeup + ((30 * HZ) / 1000), jiffies)) {
 		DPRINTK(4, "wait after WAKEUP\n");
-		dev_info(&priv->ks_wlan_hw.sdio_card->func->dev,
+		dev_info(&priv->ks_sdio_card->func->dev,
 			 "wake: %lu %lu\n",
 			 priv->last_wakeup + (30 * HZ) / 1000,
 				jiffies);
 		msleep(30);
 	}
 
-	sdio_claim_host(priv->ks_wlan_hw.sdio_card->func);
+	sdio_claim_host(priv->ks_sdio_card->func);
 
 	/* power save wakeup */
 	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 		if (cnt_txqbody(priv) > 0) {
 			ks_wlan_hw_wakeup_request(priv);
-			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-					   &priv->ks_wlan_hw.rw_wq, 1);
+			queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 		}
 		goto err_release_host;
 	}
@@ -521,7 +510,7 @@ static void ks7010_rw_function(struct work_struct *work)
 	_ks_wlan_hw_power_save(priv);
 
 err_release_host:
-	sdio_release_host(priv->ks_wlan_hw.sdio_card->func);
+	sdio_release_host(priv->ks_sdio_card->func);
 }
 
 static void ks_sdio_interrupt(struct sdio_func *func)
@@ -584,8 +573,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 			if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 				if (cnt_txqbody(priv)) {
 					ks_wlan_hw_wakeup_request(priv);
-					queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-							   &priv->ks_wlan_hw.rw_wq, 1);
+					queue_delayed_work(priv->wq, &priv->rw_dwork, 1);
 					return;
 				}
 			} else {
@@ -595,8 +583,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	} while (rsize);
 
 queue_delayed_work:
-	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-			   &priv->ks_wlan_hw.rw_wq, 0);
+	queue_delayed_work(priv->wq, &priv->rw_dwork, 0);
 }
 
 static int trx_device_init(struct ks_wlan_private *priv)
@@ -714,7 +701,7 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	}
 
 	ret = request_firmware(&fw_entry, ROM_FILE,
-			       &priv->ks_wlan_hw.sdio_card->func->dev);
+			       &priv->ks_sdio_card->func->dev);
 	if (ret)
 		goto release_host_and_free;
 
@@ -949,7 +936,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	SET_NETDEV_DEV(netdev, &card->func->dev);	/* for create sysfs symlinks */
 
 	/* private memory initialize */
-	priv->ks_wlan_hw.sdio_card = card;
+	priv->ks_sdio_card = card;
 
 	priv->dev_state = DEVICE_STATE_PREBOOT;
 	priv->net_dev = netdev;
@@ -1001,13 +988,13 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	DPRINTK(4, " enable Interrupt : INT_ENABLE=%02X\n", rw_data);
 	priv->dev_state = DEVICE_STATE_BOOT;
 
-	priv->ks_wlan_hw.ks7010sdio_wq = create_workqueue("ks7010sdio_wq");
-	if (!priv->ks_wlan_hw.ks7010sdio_wq) {
+	priv->wq = create_workqueue("wq");
+	if (!priv->wq) {
 		DPRINTK(1, "create_workqueue failed !!\n");
 		goto err_free_netdev;
 	}
 
-	INIT_DELAYED_WORK(&priv->ks_wlan_hw.rw_wq, ks7010_rw_function);
+	INIT_DELAYED_WORK(&priv->rw_dwork, ks7010_rw_function);
 	ks7010_card_init(priv);
 
 	ret = register_netdev(priv->net_dev);
@@ -1095,12 +1082,11 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 
 		DPRINTK(1, "STOP Req\n");
 
-		if (priv->ks_wlan_hw.ks7010sdio_wq) {
-			flush_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);
-			destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);
+		if (priv->wq) {
+			flush_workqueue(priv->wq);
+			destroy_workqueue(priv->wq);
 		}
-		DPRINTK(1,
-			"destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);\n");
+		DPRINTK(1, "destroy_workqueue(priv->wq);\n");
 
 		hostif_exit(priv);
 		DPRINTK(1, "hostif_exit\n");

commit 321dabdc746d995a962d02dd81ecf23ddc3b3169
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:34 2017 +1000

    staging: ks7010: move tasklet_struct to ks_wlan_private
    
    Currently a pointer to the tasklet_struct used for bottom half
    processing on the receive path is within the hw_info_t structure. This
    structure is then embedded in the device private data
    structure. Having the tasklet_struct nested does not add meaning to
    the device private data, device private data already (and typically)
    has various data relating to the device, there is no real need to
    separate the tasklet_struct to a SDIO specific structure. While not
    adding allot of extra meaning having the nested structure means the
    programmer must open two header files to read the description of the
    device private data, the code would be easier to read if the device
    private data struct description was not spread over two files.
    
    Move tasklet_struct out of sdio header file and into the device
    private data structure description.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 0f173c31066a..2d73ebb71a2e 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -380,7 +380,7 @@ static void rx_event_task(unsigned long dev)
 		inc_rxqhead(priv);
 
 		if (cnt_rxqbody(priv) > 0)
-			tasklet_schedule(&priv->ks_wlan_hw.rx_bh_task);
+			tasklet_schedule(&priv->rx_bh_task);
 	}
 }
 
@@ -447,8 +447,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 		}
 	}
 
-	/* rx_event_task((void *)priv); */
-	tasklet_schedule(&priv->ks_wlan_hw.rx_bh_task);
+	tasklet_schedule(&priv->rx_bh_task);
 }
 
 static void ks7010_rw_function(struct work_struct *work)
@@ -614,8 +613,7 @@ static int trx_device_init(struct ks_wlan_private *priv)
 	spin_lock_init(&priv->tx_dev.tx_dev_lock);
 	spin_lock_init(&priv->rx_dev.rx_dev_lock);
 
-	tasklet_init(&priv->ks_wlan_hw.rx_bh_task, rx_event_task,
-		     (unsigned long)priv);
+	tasklet_init(&priv->rx_bh_task, rx_event_task, (unsigned long)priv);
 
 	return 0;
 }
@@ -633,7 +631,7 @@ static void trx_device_exit(struct ks_wlan_private *priv)
 		inc_txqhead(priv);
 	}
 
-	tasklet_kill(&priv->ks_wlan_hw.rx_bh_task);
+	tasklet_kill(&priv->rx_bh_task);
 }
 
 static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)

commit 055da4f9b95dd2a50c653b5a4559b9186081fb75
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:31 2017 +1000

    staging: ks7010: fix complete_handler
    
    complete_handler() takes void * types as parameters. void * parameters are then
    cast to struct types. Call sites for this function either pass in NULL
    or pointers to the struct types cast to void *. This casting is
    unnecessary and can be removed.
    
    Struct tx_device_buffer (which contains a pointer member to the
    complete_handler() function) has as member 'ks_wlan_priv *priv' this is
    unnecessary, we always have a pointer to this struct there is no need
    to store it here.
    
    The complete_handler can be more clearly defined by using struct
    pointer types instead of void * types. The code is currently
    unnecessarily complex, storing and passing extraneous pointer
    parameters.
    
    Remove unnecessary parameters, unnecessary casting to/from 'void
    *'. Fix all call sites involving complete_handler().
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index b103a20ad490..0f173c31066a 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -237,8 +237,9 @@ int ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 
 static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 			 unsigned long size,
-			 void (*complete_handler)(void *arg1, void *arg2),
-			 void *arg1, void *arg2)
+			 void (*complete_handler)(struct ks_wlan_private *priv,
+						  struct sk_buff *skb),
+			 struct sk_buff *skb)
 {
 	struct tx_device_buffer *sp;
 	int ret;
@@ -259,8 +260,7 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 	sp->sendp = p;
 	sp->size = size;
 	sp->complete_handler = complete_handler;
-	sp->arg1 = arg1;
-	sp->arg2 = arg2;
+	sp->skb = skb;
 	inc_txqtail(priv);
 
 	return 0;
@@ -268,7 +268,7 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 err_complete:
 	kfree(p);
 	if (complete_handler)
-		(*complete_handler) (arg1, arg2);
+		(*complete_handler)(priv, skb);
 
 	return ret;
 }
@@ -327,7 +327,7 @@ static void tx_device_task(struct ks_wlan_private *priv)
 	}
 	kfree(sp->sendp);
 	if (sp->complete_handler)	/* TX Complete */
-		(*sp->complete_handler) (sp->arg1, sp->arg2);
+		(*sp->complete_handler)(priv, sp->skb);
 	inc_txqhead(priv);
 
 	if (cnt_txqbody(priv) > 0) {
@@ -337,8 +337,9 @@ static void tx_device_task(struct ks_wlan_private *priv)
 }
 
 int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
-		  void (*complete_handler)(void *arg1, void *arg2),
-		  void *arg1, void *arg2)
+		  void (*complete_handler)(struct ks_wlan_private *priv,
+					   struct sk_buff *skb),
+		  struct sk_buff *skb)
 {
 	int result = 0;
 	struct hostif_hdr *hdr;
@@ -356,7 +357,7 @@ int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
 
 	DPRINTK(4, "event=%04X\n", hdr->event);
 	spin_lock(&priv->tx_dev.tx_dev_lock);
-	result = enqueue_txdev(priv, p, size, complete_handler, arg1, arg2);
+	result = enqueue_txdev(priv, p, size, complete_handler, skb);
 	spin_unlock(&priv->tx_dev.tx_dev_lock);
 
 	if (cnt_txqbody(priv) > 0) {
@@ -628,7 +629,7 @@ static void trx_device_exit(struct ks_wlan_private *priv)
 		sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];
 		kfree(sp->sendp);	/* allocated memory free */
 		if (sp->complete_handler)	/* TX Complete */
-			(*sp->complete_handler) (sp->arg1, sp->arg2);
+			(*sp->complete_handler)(priv, sp->skb);
 		inc_txqhead(priv);
 	}
 

commit bfee6a231903b1f1f8d72cc638be6862d7099377
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:29 2017 +1000

    staging: ks7010: create reg_status_type enum type
    
    SDIO header currently defines unused constants READ_STATUS_BUSY and
    WRITE_STATUS_IDLE. There are reciprocal constants that are used
    READ_STATUS_IDLE and WRITE_STATUS_BUSY. We can roll these into a
    single enumeration type and remove the two that are unused.
    
    Add enumeration type containing IDLE/BUSY pair that are currently used
    within the SDIO source. Change source to use new enum types.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 59451f8881aa..b103a20ad490 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -295,7 +295,7 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 		return ret;
 	}
 
-	rw_data = WRITE_STATUS_BUSY;
+	rw_data = REG_STATUS_BUSY;
 	ret = ks7010_sdio_write(priv, WRITE_STATUS, &rw_data, sizeof(rw_data));
 	if (ret) {
 		DPRINTK(1, " error : WRITE_STATUS=%02X\n", rw_data);
@@ -415,7 +415,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 					     rx_buffer->data, 32);
 #endif
 		/* rx_status update */
-		read_status = READ_STATUS_IDLE;
+		read_status = REG_STATUS_IDLE;
 		ret = ks7010_sdio_write(priv, READ_STATUS, &read_status,
 					sizeof(read_status));
 		if (ret)
@@ -431,7 +431,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 	inc_rxqtail(priv);
 
 	/* read status update */
-	read_status = READ_STATUS_IDLE;
+	read_status = REG_STATUS_IDLE;
 	ret = ks7010_sdio_write(priv, READ_STATUS, &read_status,
 				sizeof(read_status));
 	if (ret)

commit 4f22b8954b13f6a75d57498b49084fc409257c61
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Apr 12 09:56:50 2017 +1000

    staging: ks7010: remove unused spin_lock
    
    Driver SDIO private data structure description includes a spin_lock
    that is never used. This data structure only contains a pointer to the
    sdio_func and a pointer to the main device private data. A spin_lock
    is not required here.
    
    Remove unused spin_lock.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 5f14fd00f87f..59451f8881aa 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -892,7 +892,6 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 		return -ENOMEM;
 
 	card->func = func;
-	spin_lock_init(&card->lock);
 
 	/*** Initialize  SDIO ***/
 	sdio_claim_host(func);

commit cf10e78e1b297f9a314be1e3d2a3cab184a120d7
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Apr 12 09:56:48 2017 +1000

    staging: ks7010: remove unused read_buf
    
    Driver SDIO code allocates memory for a buffer that is never used. It
    can be safely removed.
    
    Remove unused buffer, including allocation and freeing of memory.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index c7e01801764f..5f14fd00f87f 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -952,10 +952,6 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 
 	/* private memory initialize */
 	priv->ks_wlan_hw.sdio_card = card;
-	priv->ks_wlan_hw.read_buf = NULL;
-	priv->ks_wlan_hw.read_buf = kmalloc(RX_DATA_SIZE, GFP_KERNEL);
-	if (!priv->ks_wlan_hw.read_buf)
-		goto err_free_netdev;
 
 	priv->dev_state = DEVICE_STATE_PREBOOT;
 	priv->net_dev = netdev;
@@ -982,7 +978,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 		dev_err(&card->func->dev,
 			"ks7010: firmware load failed !! return code = %d\n",
 			 ret);
-		goto err_free_read_buf;
+		goto err_free_netdev;
 	}
 
 	/* interrupt setting */
@@ -1010,7 +1006,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	priv->ks_wlan_hw.ks7010sdio_wq = create_workqueue("ks7010sdio_wq");
 	if (!priv->ks_wlan_hw.ks7010sdio_wq) {
 		DPRINTK(1, "create_workqueue failed !!\n");
-		goto err_free_read_buf;
+		goto err_free_netdev;
 	}
 
 	INIT_DELAYED_WORK(&priv->ks_wlan_hw.rw_wq, ks7010_rw_function);
@@ -1018,13 +1014,10 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 
 	ret = register_netdev(priv->net_dev);
 	if (ret)
-		goto err_free_read_buf;
+		goto err_free_netdev;
 
 	return 0;
 
- err_free_read_buf:
-	kfree(priv->ks_wlan_hw.read_buf);
-	priv->ks_wlan_hw.read_buf = NULL;
  err_free_netdev:
 	free_netdev(priv->net_dev);
 	card->priv = NULL;
@@ -1117,7 +1110,6 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 		unregister_netdev(netdev);
 
 		trx_device_exit(priv);
-		kfree(priv->ks_wlan_hw.read_buf);
 		free_netdev(priv->net_dev);
 		card->priv = NULL;
 	}

commit fa125ae482085650d5740af355bdcb5532865295
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Apr 12 09:56:47 2017 +1000

    staging: ks7010: remove unused completion
    
    Driver SDIO code initializes a completion that is never used. It can
    be safely removed.
    
    Remove unused completion.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 9afa06b9ae30..c7e01801764f 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -952,7 +952,6 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 
 	/* private memory initialize */
 	priv->ks_wlan_hw.sdio_card = card;
-	init_completion(&priv->ks_wlan_hw.ks7010_sdio_wait);
 	priv->ks_wlan_hw.read_buf = NULL;
 	priv->ks_wlan_hw.read_buf = kmalloc(RX_DATA_SIZE, GFP_KERNEL);
 	if (!priv->ks_wlan_hw.read_buf)

commit 2ab6fd596317c89b96f0cfd8811f12dd047bbd9e
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:47 2017 +1000

    staging: ks7010: factor out send stop request
    
    Function contains compound statement delineated by lone braces. This
    statement represents a discreet set of functionality and thus can be
    factored out into a separate function. Using a separate function
    instead of a compound statement increases readability, reduces code
    indentation, reduces function length, and generally looks more tidy.
    
    Factor compound statement out to separate function.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 2be1c654189a..9afa06b9ae30 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1042,6 +1042,35 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	return -ENODEV;
 }
 
+/* send stop request to MAC */
+static int send_stop_request(struct sdio_func *func)
+{
+	struct hostif_stop_request_t *pp;
+	struct ks_sdio_card *card;
+	size_t size;
+
+	card = sdio_get_drvdata(func);
+
+	pp = kzalloc(hif_align_size(sizeof(*pp)), GFP_KERNEL);
+	if (!pp) {
+		DPRINTK(3, "allocate memory failed..\n");
+		return -ENOMEM;
+	}
+
+	size = sizeof(*pp) - sizeof(pp->header.size);
+	pp->header.size = cpu_to_le16((uint16_t)size);
+	pp->header.event = cpu_to_le16((uint16_t)HIF_STOP_REQ);
+
+	sdio_claim_host(func);
+	write_to_device(card->priv, (unsigned char *)pp,
+			hif_align_size(sizeof(*pp)));
+	sdio_release_host(func);
+
+	kfree(pp);
+	return 0;
+}
+
+
 static void ks7010_sdio_remove(struct sdio_func *func)
 {
 	int ret;
@@ -1070,27 +1099,10 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 		sdio_release_host(func);
 		DPRINTK(1, "interrupt disable\n");
 
-		/* send stop request to MAC */
-		{
-			struct hostif_stop_request_t *pp;
+		ret = send_stop_request(func);
+		if (ret)	/* memory allocation failure */
+			return;
 
-			pp = kzalloc(hif_align_size(sizeof(*pp)), GFP_KERNEL);
-			if (!pp) {
-				DPRINTK(3, "allocate memory failed..\n");
-				return;	/* to do goto ni suru */
-			}
-			pp->header.size =
-			    cpu_to_le16((uint16_t)
-					(sizeof(*pp) -
-					 sizeof(pp->header.size)));
-			pp->header.event = cpu_to_le16((uint16_t)HIF_STOP_REQ);
-
-			sdio_claim_host(func);
-			write_to_device(priv, (unsigned char *)pp,
-					hif_align_size(sizeof(*pp)));
-			sdio_release_host(func);
-			kfree(pp);
-		}
 		DPRINTK(1, "STOP Req\n");
 
 		if (priv->ks_wlan_hw.ks7010sdio_wq) {

commit f8641485ffb4ba573daa3f7d0532720634e5f44b
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:46 2017 +1000

    staging: ks7010: fix function return code path
    
    Function has duplicate code clean up sequences; identical function
    call followed by return. This would be better expressed with the use
    of a goto statement, as is typical in-tree.
    
    One call site places the clean up code within the 'else' branch of an
    multi-way decision. This can be more clearly expressed by inverting
    the initial decision conditional and jumping directly to the cleanup
    code. Subsequent code indentation can then be reduced, aiding
    readability.
    
    Fix function return code execution path. Move clean up code to end of
    function with a label. Replace duplicate clean up code within function
    with a jump to label. Invert conditional, jump to label if new
    conditional evaluates to true, reduce indentation in subsequent code.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 42e96e113747..2be1c654189a 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -206,29 +206,26 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	ret = ks7010_sdio_read(priv, INT_PENDING, &rw_data, sizeof(rw_data));
 	if (ret) {
 		DPRINTK(1, " error : INT_PENDING=%02X\n", rw_data);
-		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-				   &priv->ks_wlan_hw.rw_wq, 1);
-		return;
+		goto queue_delayed_work;
 	}
+	if (rw_data)
+		goto queue_delayed_work;
 
-	if (!rw_data) {
-		rw_data = GCR_B_DOZE;
-		ret = ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
-		if (ret) {
-			DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
-			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-					   &priv->ks_wlan_hw.rw_wq, 1);
-			return;
-		}
-		DPRINTK(4, "PMG SET!! : GCR_B=%02X\n", rw_data);
-		atomic_set(&priv->psstatus.status, PS_SNOOZE);
-		DPRINTK(3, "psstatus.status=PS_SNOOZE\n");
-	} else {
-		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-				   &priv->ks_wlan_hw.rw_wq, 1);
+	rw_data = GCR_B_DOZE;
+	ret = ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
+	if (ret) {
+		DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
+		goto queue_delayed_work;
 	}
+	DPRINTK(4, "PMG SET!! : GCR_B=%02X\n", rw_data);
+	atomic_set(&priv->psstatus.status, PS_SNOOZE);
+	DPRINTK(3, "psstatus.status=PS_SNOOZE\n");
 
 	return;
+
+queue_delayed_work:
+	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+			   &priv->ks_wlan_hw.rw_wq, 1);
 }
 
 int ks_wlan_hw_power_save(struct ks_wlan_private *priv)

commit 482c03c7b5f6d323f333ae59bf1c55ef2e24b1f2
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:45 2017 +1000

    staging: ks7010: separate dissimilar checks
    
    Function contains a list of four checks, for no apparent reason two of them
    are OR'ed together. Having two OR'ed together and the other two not
    implies some connection between the two that are combined. It is
    easier to read this code if the four unrelated checks are done as
    separate statements.
    
    Move dissimilar expressions out of logical continuation and into
    separate statement.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 1db59c6946bc..42e96e113747 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -177,8 +177,10 @@ static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	if (priv->reg.powermgt == POWMGT_ACTIVE_MODE)
 		return;
 
-	if (priv->reg.operation_mode != MODE_INFRASTRUCTURE ||
-	    (priv->connect_status & CONNECT_STATUS_MASK) != CONNECT_STATUS)
+	if (priv->reg.operation_mode != MODE_INFRASTRUCTURE)
+		return;
+
+	if ((priv->connect_status & CONNECT_STATUS_MASK) != CONNECT_STATUS)
 		return;
 
 	if (priv->dev_state != DEVICE_STATE_SLEEP)

commit fa740a9e2e19708bc38993375da671c979082095
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:44 2017 +1000

    staging: ks7010: change static function return type
    
    Function has return type 'int'. Function has internal linkage. Function
    returns 0 on all execution paths. Function is called only once in the
    driver and the return value is not checked. Removal of this return
    value does not change the program logic. The 'int' return type is not
    adding any information thus it is better to remove it.
    
    Change return type of function with internal linkage from 'int' to
    'void'.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index b34850dddf30..1db59c6946bc 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -169,23 +169,23 @@ void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 	}
 }
 
-static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
+static void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
 	int ret;
 
 	if (priv->reg.powermgt == POWMGT_ACTIVE_MODE)
-		return 0;
+		return;
 
 	if (priv->reg.operation_mode != MODE_INFRASTRUCTURE ||
 	    (priv->connect_status & CONNECT_STATUS_MASK) != CONNECT_STATUS)
-		return 0;
+		return;
 
 	if (priv->dev_state != DEVICE_STATE_SLEEP)
-		return 0;
+		return;
 
 	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE)
-		return 0;
+		return;
 
 	DPRINTK(5, "\npsstatus.status=%d\npsstatus.confirm_wait=%d\npsstatus.snooze_guard=%d\ncnt_txqbody=%d\n",
 		atomic_read(&priv->psstatus.status),
@@ -193,40 +193,40 @@ static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 		atomic_read(&priv->psstatus.snooze_guard),
 		cnt_txqbody(priv));
 
-	if (!atomic_read(&priv->psstatus.confirm_wait) &&
-	    !atomic_read(&priv->psstatus.snooze_guard) &&
-	    !cnt_txqbody(priv)) {
-		ret = ks7010_sdio_read(priv, INT_PENDING, &rw_data,
-				       sizeof(rw_data));
+	if (atomic_read(&priv->psstatus.confirm_wait) ||
+	    atomic_read(&priv->psstatus.snooze_guard) ||
+	    cnt_txqbody(priv)) {
+		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+				   &priv->ks_wlan_hw.rw_wq, 0);
+		return;
+	}
+
+	ret = ks7010_sdio_read(priv, INT_PENDING, &rw_data, sizeof(rw_data));
+	if (ret) {
+		DPRINTK(1, " error : INT_PENDING=%02X\n", rw_data);
+		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+				   &priv->ks_wlan_hw.rw_wq, 1);
+		return;
+	}
+
+	if (!rw_data) {
+		rw_data = GCR_B_DOZE;
+		ret = ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
 		if (ret) {
-			DPRINTK(1, " error : INT_PENDING=%02X\n", rw_data);
-			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-					   &priv->ks_wlan_hw.rw_wq, 1);
-			return 0;
-		}
-		if (!rw_data) {
-			rw_data = GCR_B_DOZE;
-			ret = ks7010_sdio_write(priv, GCR_B, &rw_data,
-						sizeof(rw_data));
-			if (ret) {
-				DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
-				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-						   &priv->ks_wlan_hw.rw_wq, 1);
-				return 0;
-			}
-			DPRINTK(4, "PMG SET!! : GCR_B=%02X\n", rw_data);
-			atomic_set(&priv->psstatus.status, PS_SNOOZE);
-			DPRINTK(3, "psstatus.status=PS_SNOOZE\n");
-		} else {
+			DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
 			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
 					   &priv->ks_wlan_hw.rw_wq, 1);
+			return;
 		}
+		DPRINTK(4, "PMG SET!! : GCR_B=%02X\n", rw_data);
+		atomic_set(&priv->psstatus.status, PS_SNOOZE);
+		DPRINTK(3, "psstatus.status=PS_SNOOZE\n");
 	} else {
 		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-				   &priv->ks_wlan_hw.rw_wq, 0);
+				   &priv->ks_wlan_hw.rw_wq, 1);
 	}
 
-	return 0;
+	return;
 }
 
 int ks_wlan_hw_power_save(struct ks_wlan_private *priv)

commit 638a75b653c208ff86adeba8fa770685721343e9
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:43 2017 +1000

    staging: ks7010: invert conditional, reduce indentation
    
    A number of functions have blocks of code guarded by an if statement.
    
    if (foo) {
            /* block of code */
    }
    
    This can, on occasion, more succinctly be expressed as
    
    if (!foo)
            return
    
    /* block of code */
    
    This change will mean a number of whitespace issues need to be
    addressed/fixed. The diff can be a little hard to read when there are
    multiple lines that are very similar (for example error return
    code). Splitting the indentation reduction and the whitespace fixes
    into two separate patches was not found to aid reading the
    diff. Therefor we fix the whitespace issues at the same time. We need
    to be very sure to not make any changes to the program logic, this is
    ensured by only doing what is stated - invert the conditional, fix
    whitespace.
    
    Invert if statement conditionals. Return if new conditional evaluates
    to true. Reduce level of indentation in subsequent code. Fix white
    space issues.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 0185d3d924d8..b34850dddf30 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -312,28 +312,29 @@ static void tx_device_task(struct ks_wlan_private *priv)
 	int ret;
 
 	DPRINTK(4, "\n");
-	if (cnt_txqbody(priv) > 0 &&
-	    atomic_read(&priv->psstatus.status) != PS_SNOOZE) {
-		sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];
-		if (priv->dev_state >= DEVICE_STATE_BOOT) {
-			ret = write_to_device(priv, sp->sendp, sp->size);
-			if (ret) {
-				DPRINTK(1, "write_to_device error !!(%d)\n", ret);
-				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-						   &priv->ks_wlan_hw.rw_wq, 1);
-				return;
-			}
-		}
-		kfree(sp->sendp);	/* allocated memory free */
-		if (sp->complete_handler)	/* TX Complete */
-			(*sp->complete_handler) (sp->arg1, sp->arg2);
-		inc_txqhead(priv);
+	if (cnt_txqbody(priv) <= 0 ||
+	    atomic_read(&priv->psstatus.status) == PS_SNOOZE)
+		return;
 
-		if (cnt_txqbody(priv) > 0) {
+	sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];
+	if (priv->dev_state >= DEVICE_STATE_BOOT) {
+		ret = write_to_device(priv, sp->sendp, sp->size);
+		if (ret) {
+			DPRINTK(1, "write_to_device error !!(%d)\n", ret);
 			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-					   &priv->ks_wlan_hw.rw_wq, 0);
+					   &priv->ks_wlan_hw.rw_wq, 1);
+			return;
 		}
 	}
+	kfree(sp->sendp);
+	if (sp->complete_handler)	/* TX Complete */
+		(*sp->complete_handler) (sp->arg1, sp->arg2);
+	inc_txqhead(priv);
+
+	if (cnt_txqbody(priv) > 0) {
+		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+				   &priv->ks_wlan_hw.rw_wq, 0);
+	}
 }
 
 int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
@@ -535,71 +536,64 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	priv = card->priv;
 	DPRINTK(4, "\n");
 
-	if (priv->dev_state >= DEVICE_STATE_BOOT) {
-		ret = ks7010_sdio_read(priv, INT_PENDING, &status,
-				       sizeof(status));
+	if (priv->dev_state < DEVICE_STATE_BOOT)
+		goto queue_delayed_work;
+
+	ret = ks7010_sdio_read(priv, INT_PENDING, &status, sizeof(status));
+	if (ret) {
+		DPRINTK(1, "read INT_PENDING Failed!!(%d)\n", ret);
+		goto queue_delayed_work;
+	}
+	DPRINTK(4, "INT_PENDING=%02X\n", rw_data);
+
+	/* schedule task for interrupt status */
+	/* bit7 -> Write General Communication B register */
+	/* read (General Communication B register) */
+	/* bit5 -> Write Status Idle */
+	/* bit2 -> Read Status Busy  */
+	if (status & INT_GCR_B ||
+	    atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
+		ret = ks7010_sdio_read(priv, GCR_B, &rw_data,
+				       sizeof(rw_data));
 		if (ret) {
-			DPRINTK(1, "read INT_PENDING Failed!!(%d)\n", ret);
+			DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
 			goto queue_delayed_work;
 		}
-		DPRINTK(4, "INT_PENDING=%02X\n", rw_data);
-
-		/* schedule task for interrupt status */
-		/* bit7 -> Write General Communication B register */
-		/* read (General Communication B register) */
-		/* bit5 -> Write Status Idle */
-		/* bit2 -> Read Status Busy  */
-		if (status & INT_GCR_B ||
-		    atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
-			ret = ks7010_sdio_read(priv, GCR_B, &rw_data,
-					       sizeof(rw_data));
-			if (ret) {
-				DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
-				goto queue_delayed_work;
-			}
-			/* DPRINTK(1, "GCR_B=%02X\n", rw_data); */
-			if (rw_data == GCR_B_ACTIVE) {
-				if (atomic_read(&priv->psstatus.status) ==
-				    PS_SNOOZE) {
-					atomic_set(&priv->psstatus.status,
-						   PS_WAKEUP);
-					priv->wakeup_count = 0;
-				}
-				complete(&priv->psstatus.wakeup_wait);
+		if (rw_data == GCR_B_ACTIVE) {
+			if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
+				atomic_set(&priv->psstatus.status, PS_WAKEUP);
+				priv->wakeup_count = 0;
 			}
+			complete(&priv->psstatus.wakeup_wait);
 		}
+	}
 
-		do {
-			/* read (WriteStatus/ReadDataSize FN1:00_0014) */
-			ret = ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data,
-					       sizeof(rw_data));
-			if (ret) {
-				DPRINTK(1, " error : WSTATUS_RSIZE=%02X\n",
-					rw_data);
-				goto queue_delayed_work;
-			}
-			DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
-			rsize = rw_data & RSIZE_MASK;
-			if (rsize != 0) 	/* Read schedule */
-				ks_wlan_hw_rx(priv, (uint16_t)(rsize << 4));
-
-			if (rw_data & WSTATUS_MASK) {
-				if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
-					if (cnt_txqbody(priv)) {
-						ks_wlan_hw_wakeup_request(priv);
-						queue_delayed_work
-							(priv->ks_wlan_hw.
-								ks7010sdio_wq,
-								&priv->ks_wlan_hw.
-								rw_wq, 1);
-						return;
-					}
-				} else {
-					tx_device_task(priv);
+	do {
+		/* read (WriteStatus/ReadDataSize FN1:00_0014) */
+		ret = ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data,
+				       sizeof(rw_data));
+		if (ret) {
+			DPRINTK(1, " error : WSTATUS_RSIZE=%02X\n", rw_data);
+			goto queue_delayed_work;
+		}
+		DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
+		rsize = rw_data & RSIZE_MASK;
+		if (rsize != 0) 	/* Read schedule */
+			ks_wlan_hw_rx(priv, (uint16_t)(rsize << 4));
+
+		if (rw_data & WSTATUS_MASK) {
+			if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
+				if (cnt_txqbody(priv)) {
+					ks_wlan_hw_wakeup_request(priv);
+					queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+							   &priv->ks_wlan_hw.rw_wq, 1);
+					return;
 				}
+			} else {
+				tx_device_task(priv);
 			}
-		} while (rsize);
-	}
+		}
+	} while (rsize);
 
 queue_delayed_work:
 	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,

commit f717248713c9672526005fefd85d6d5bc44d8603
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:42 2017 +1000

    staging: ks7010: rename identifier retval to ret
    
    Function uses identifier 'retval' to hold the error return value. The
    rest of the driver uses 'ret' for this purpose. Being uniform in the
    choice of identifiers generally adds to the cleanliness of the code,
    also it is arguably easier to follow the code if one name is used for
    one task.
    
    Rename identifier 'retval' to 'ret'.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 467c0c4708b4..0185d3d924d8 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -172,7 +172,7 @@ void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
-	int retval;
+	int ret;
 
 	if (priv->reg.powermgt == POWMGT_ACTIVE_MODE)
 		return 0;
@@ -196,9 +196,9 @@ static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	if (!atomic_read(&priv->psstatus.confirm_wait) &&
 	    !atomic_read(&priv->psstatus.snooze_guard) &&
 	    !cnt_txqbody(priv)) {
-		retval = ks7010_sdio_read(priv, INT_PENDING, &rw_data,
-					  sizeof(rw_data));
-		if (retval) {
+		ret = ks7010_sdio_read(priv, INT_PENDING, &rw_data,
+				       sizeof(rw_data));
+		if (ret) {
 			DPRINTK(1, " error : INT_PENDING=%02X\n", rw_data);
 			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
 					   &priv->ks_wlan_hw.rw_wq, 1);
@@ -206,9 +206,9 @@ static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 		}
 		if (!rw_data) {
 			rw_data = GCR_B_DOZE;
-			retval = ks7010_sdio_write(priv, GCR_B, &rw_data,
-						   sizeof(rw_data));
-			if (retval) {
+			ret = ks7010_sdio_write(priv, GCR_B, &rw_data,
+						sizeof(rw_data));
+			if (ret) {
 				DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
 				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
 						   &priv->ks_wlan_hw.rw_wq, 1);
@@ -385,7 +385,7 @@ static void rx_event_task(unsigned long dev)
 
 static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 {
-	int retval;
+	int ret;
 	struct rx_device_buffer *rx_buffer;
 	struct hostif_hdr *hdr;
 	unsigned char read_status;
@@ -401,10 +401,9 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 	}
 	rx_buffer = &priv->rx_dev.rx_dev_buff[priv->rx_dev.qtail];
 
-	retval =
-	    ks7010_sdio_read(priv, DATA_WINDOW, &rx_buffer->data[0],
-			     hif_align_size(size));
-	if (retval)
+	ret = ks7010_sdio_read(priv, DATA_WINDOW, &rx_buffer->data[0],
+			       hif_align_size(size));
+	if (ret)
 		return;
 
 	/* length check */
@@ -417,10 +416,9 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 #endif
 		/* rx_status update */
 		read_status = READ_STATUS_IDLE;
-		retval =
-		    ks7010_sdio_write(priv, READ_STATUS, &read_status,
-				      sizeof(read_status));
-		if (retval)
+		ret = ks7010_sdio_write(priv, READ_STATUS, &read_status,
+					sizeof(read_status));
+		if (ret)
 			DPRINTK(1, " error : READ_STATUS=%02X\n", read_status);
 
 		/* length check fail */
@@ -434,10 +432,9 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 
 	/* read status update */
 	read_status = READ_STATUS_IDLE;
-	retval =
-	    ks7010_sdio_write(priv, READ_STATUS, &read_status,
-			      sizeof(read_status));
-	if (retval)
+	ret = ks7010_sdio_write(priv, READ_STATUS, &read_status,
+				sizeof(read_status));
+	if (ret)
 		DPRINTK(1, " error : READ_STATUS=%02X\n", read_status);
 
 	DPRINTK(4, "READ_STATUS=%02X\n", read_status);
@@ -529,7 +526,7 @@ static void ks7010_rw_function(struct work_struct *work)
 
 static void ks_sdio_interrupt(struct sdio_func *func)
 {
-	int retval;
+	int ret;
 	struct ks_sdio_card *card;
 	struct ks_wlan_private *priv;
 	unsigned char status, rsize, rw_data;
@@ -539,11 +536,10 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	DPRINTK(4, "\n");
 
 	if (priv->dev_state >= DEVICE_STATE_BOOT) {
-		retval =
-		    ks7010_sdio_read(priv, INT_PENDING, &status,
-				     sizeof(status));
-		if (retval) {
-			DPRINTK(1, "read INT_PENDING Failed!!(%d)\n", retval);
+		ret = ks7010_sdio_read(priv, INT_PENDING, &status,
+				       sizeof(status));
+		if (ret) {
+			DPRINTK(1, "read INT_PENDING Failed!!(%d)\n", ret);
 			goto queue_delayed_work;
 		}
 		DPRINTK(4, "INT_PENDING=%02X\n", rw_data);
@@ -555,10 +551,9 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 		/* bit2 -> Read Status Busy  */
 		if (status & INT_GCR_B ||
 		    atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
-			retval =
-			    ks7010_sdio_read(priv, GCR_B, &rw_data,
-					     sizeof(rw_data));
-			if (retval) {
+			ret = ks7010_sdio_read(priv, GCR_B, &rw_data,
+					       sizeof(rw_data));
+			if (ret) {
 				DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
 				goto queue_delayed_work;
 			}
@@ -576,10 +571,9 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 
 		do {
 			/* read (WriteStatus/ReadDataSize FN1:00_0014) */
-			retval =
-			    ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data,
-					     sizeof(rw_data));
-			if (retval) {
+			ret = ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data,
+					       sizeof(rw_data));
+			if (ret) {
 				DPRINTK(1, " error : WSTATUS_RSIZE=%02X\n",
 					rw_data);
 				goto queue_delayed_work;

commit 03b0244924795d30e1619894d8aa13c0fcfe233c
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:41 2017 +1000

    staging: ks7010: rename identifier rc to ret
    
    Driver uses identifier 'rc' to hold the value for error return
    code. The rest of the driver predominately uses 'ret' for this
    purpose. It is easier to follow the code if one name is used for one
    task.
    
    Rename identifier 'rc' to 'ret'.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index b93c9a478709..467c0c4708b4 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -309,19 +309,17 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 static void tx_device_task(struct ks_wlan_private *priv)
 {
 	struct tx_device_buffer *sp;
-	int rc = 0;
+	int ret;
 
 	DPRINTK(4, "\n");
 	if (cnt_txqbody(priv) > 0 &&
 	    atomic_read(&priv->psstatus.status) != PS_SNOOZE) {
 		sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];
 		if (priv->dev_state >= DEVICE_STATE_BOOT) {
-			rc = write_to_device(priv, sp->sendp, sp->size);
-			if (rc) {
-				DPRINTK(1, "write_to_device error !!(%d)\n",
-					rc);
-				queue_delayed_work(priv->ks_wlan_hw.
-						   ks7010sdio_wq,
+			ret = write_to_device(priv, sp->sendp, sp->size);
+			if (ret) {
+				DPRINTK(1, "write_to_device error !!(%d)\n", ret);
+				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
 						   &priv->ks_wlan_hw.rw_wq, 1);
 				return;
 			}

commit 881f76b976e8e1ce8bb0498d0a85f3a43a6397dd
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:40 2017 +1000

    staging: ks7010: change length type to unsigned
    
    Length undergoes type conversion when passed (indirectly) as an
    argument for parameter of type 'unsigned int'. If length is negative
    this is a bug (the value after conversion is large).
    
    Declare 'length' to be an unsigned type instead of a signed type.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 3403eddaa8e8..b93c9a478709 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -712,7 +712,7 @@ static int ks7010_upload_firmware(struct ks_sdio_card *card)
 	unsigned char *rom_buf;
 	unsigned char rw_data = 0;
 	int ret;
-	int length;
+	unsigned int length;
 	const struct firmware *fw_entry = NULL;
 
 	/* buffer allocate */

commit 5141e9c6346892d9705558ccf27489806c2bdddf
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:39 2017 +1000

    staging: ks7010: remove void * cast
    
    Functions accept a parameter of type 'void *', this is then cast to a
    struct ks_wlan_private pointer. All call sites have a struct
    ks_wlan_private pointer and cast it to 'void *'. We can remove the
    unnecessary casting by changing the parameter type to match the
    usage. Functions changed all have internal linkage.
    
    Replace parameter of type 'void *' with 'struct ks_wlan_private
    *'. Remove unnecessary casting to and from 'void *'.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index f80e2533e26a..3403eddaa8e8 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -306,9 +306,8 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 	return 0;
 }
 
-static void tx_device_task(void *dev)
+static void tx_device_task(struct ks_wlan_private *priv)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
 	struct tx_device_buffer *sp;
 	int rc = 0;
 
@@ -386,9 +385,8 @@ static void rx_event_task(unsigned long dev)
 	}
 }
 
-static void ks_wlan_hw_rx(void *dev, uint16_t size)
+static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
 	int retval;
 	struct rx_device_buffer *rx_buffer;
 	struct hostif_hdr *hdr;
@@ -520,11 +518,10 @@ static void ks7010_rw_function(struct work_struct *work)
 	DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
 
 	if (rw_data & RSIZE_MASK) {	/* Read schedule */
-		ks_wlan_hw_rx((void *)priv,
-			      (uint16_t)((rw_data & RSIZE_MASK) << 4));
+		ks_wlan_hw_rx(priv, (uint16_t)((rw_data & RSIZE_MASK) << 4));
 	}
 	if ((rw_data & WSTATUS_MASK))
-		tx_device_task((void *)priv);
+		tx_device_task(priv);
 
 	_ks_wlan_hw_power_save(priv);
 
@@ -591,10 +588,9 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 			}
 			DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
 			rsize = rw_data & RSIZE_MASK;
-			if (rsize != 0) {	/* Read schedule */
-				ks_wlan_hw_rx((void *)priv,
-					      (uint16_t)(rsize << 4));
-			}
+			if (rsize != 0) 	/* Read schedule */
+				ks_wlan_hw_rx(priv, (uint16_t)(rsize << 4));
+
 			if (rw_data & WSTATUS_MASK) {
 				if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 					if (cnt_txqbody(priv)) {
@@ -607,7 +603,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 						return;
 					}
 				} else {
-					tx_device_task((void *)priv);
+					tx_device_task(priv);
 				}
 			}
 		} while (rsize);

commit ed246b9ecc9212aa899721af74d97bbbcdc84add
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:38 2017 +1000

    staging: ks7010: remove unnecessary function parameter
    
    Function ks7010_upload_firmware() takes as parameters, two struct
    pointers, one of which is a member of the other. This is unnecessary
    since one can be accessed via the other.
    
    Remove function parameter and fix all call sites.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index b16618b41253..f80e2533e26a 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -709,9 +709,9 @@ static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 	return ret;
 }
 
-static int ks7010_upload_firmware(struct ks_wlan_private *priv,
-				  struct ks_sdio_card *card)
+static int ks7010_upload_firmware(struct ks_sdio_card *card)
 {
+	struct ks_wlan_private *priv = card->priv;
 	unsigned int size, offset, n = 0;
 	unsigned char *rom_buf;
 	unsigned char rw_data = 0;
@@ -997,8 +997,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 
 	ks7010_init_defaults(priv);
 
-	/* Upload firmware */
-	ret = ks7010_upload_firmware(priv, card);	/* firmware load */
+	ret = ks7010_upload_firmware(card);
 	if (ret) {
 		dev_err(&card->func->dev,
 			"ks7010: firmware load failed !! return code = %d\n",

commit ddd10774a1b8d5c980477943576bc19d31419043
Author: Xiangyang Zhang <xyz.sun.ok@gmail.com>
Date:   Wed Mar 22 16:47:13 2017 +0800

    staging: ks7010: fixed a coding style issue
    
    Fixed checkpatch.pl CHECK: Logical continuations should be on the
    previous line
    
    Signed-off-by: Xiangyang Zhang <xyz.sun.ok@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 882998959829..b16618b41253 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -313,8 +313,8 @@ static void tx_device_task(void *dev)
 	int rc = 0;
 
 	DPRINTK(4, "\n");
-	if (cnt_txqbody(priv) > 0
-	    && atomic_read(&priv->psstatus.status) != PS_SNOOZE) {
+	if (cnt_txqbody(priv) > 0 &&
+	    atomic_read(&priv->psstatus.status) != PS_SNOOZE) {
 		sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];
 		if (priv->dev_state >= DEVICE_STATE_BOOT) {
 			rc = write_to_device(priv, sp->sendp, sp->size);
@@ -558,8 +558,8 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 		/* read (General Communication B register) */
 		/* bit5 -> Write Status Idle */
 		/* bit2 -> Read Status Busy  */
-		if (status & INT_GCR_B
-		    || atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
+		if (status & INT_GCR_B ||
+		    atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 			retval =
 			    ks7010_sdio_read(priv, GCR_B, &rw_data,
 					     sizeof(rw_data));

commit 310e916f54579b2d9a33fd6501cc46acc2d4dc70
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 22 11:59:54 2017 +1100

    staging: ks7010: add explicit check to 'size' variables
    
    When checking the value of a variable that holds a 0 an explicit check
    is good style. i.e
    
      -    if (!size)
      +    if (size == 0)
    
    Update checks on 'numerical' variables to use explicit checks.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index dbb1f0538b48..882998959829 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -591,7 +591,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 			}
 			DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
 			rsize = rw_data & RSIZE_MASK;
-			if (rsize) {	/* Read schedule */
+			if (rsize != 0) {	/* Read schedule */
 				ks_wlan_hw_rx((void *)priv,
 					      (uint16_t)(rsize << 4));
 			}
@@ -829,7 +829,7 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 		DPRINTK(1, "wait time out!! SME_START\n");
 	}
 
-	if (priv->mac_address_valid && priv->version_size)
+	if (priv->mac_address_valid && priv->version_size != 0)
 		priv->dev_state = DEVICE_STATE_PREINIT;
 
 	hostif_sme_enqueue(priv, SME_GET_EEPROM_CKSUM);

commit 58af272b333eeba428ca53b5b80dbbcf120fe57a
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 22 11:59:52 2017 +1100

    staging: ks7010: fix memcmp() bug
    
    Call site to memcmp() treats return value as if it were an error code,
    it is not. If memcmp() finds inputs to be not the same, an error
    return code should be set explicitly.
    
    Correctly handle return value from call to memcmp(), set error code
    explicitly.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 28b91be8415c..dbb1f0538b48 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -695,8 +695,8 @@ static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 	if (ret)
 		goto err_free_read_buf;
 
-	ret = memcmp(data, read_buf, size);
-	if (ret) {
+	if (memcmp(data, read_buf, size) != 0) {
+		ret = -EIO;
 		DPRINTK(0, "data compare error (%d)\n", ret);
 		goto err_free_read_buf;
 	}

commit 1770ae9d3f7f2849d7a7a24f93af44a59790a647
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:12 2017 +1100

    staging: ks7010: rename return value identifier
    
    Driver uses multiple identifier names for the same task (retval, ret,
    rc). It would be easier to read the code if a single task is
    identified with a single name. 'ret' is the most common return value
    identifier name found in the kernel tree, following the principle of
    least surprise using 'ret' is a decent choice.
    
    Rename rc -> ret
    Rename retval -> ret
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 8823e934aff7..28b91be8415c 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -52,44 +52,48 @@ static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
 			    unsigned char *buffer, int length)
 {
 	struct ks_sdio_card *card;
-	int rc;
+	int ret;
 
 	card = priv->ks_wlan_hw.sdio_card;
 
 	if (length == 1)	/* CMD52 */
-		*buffer = sdio_readb(card->func, address, &rc);
+		*buffer = sdio_readb(card->func, address, &ret);
 	else	/* CMD53 multi-block transfer */
-		rc = sdio_memcpy_fromio(card->func, buffer, address, length);
+		ret = sdio_memcpy_fromio(card->func, buffer, address, length);
 
-	if (rc)
-		DPRINTK(1, "sdio error=%d size=%d\n", rc, length);
+	if (ret) {
+		DPRINTK(1, "sdio error=%d size=%d\n", ret, length);
+		return ret;
+	}
 
-	return rc;
+	return 0;
 }
 
 static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
 			     unsigned char *buffer, int length)
 {
 	struct ks_sdio_card *card;
-	int rc;
+	int ret;
 
 	card = priv->ks_wlan_hw.sdio_card;
 
 	if (length == 1)	/* CMD52 */
-		sdio_writeb(card->func, *buffer, address, &rc);
+		sdio_writeb(card->func, *buffer, address, &ret);
 	else	/* CMD53 */
-		rc = sdio_memcpy_toio(card->func, address, buffer, length);
+		ret = sdio_memcpy_toio(card->func, address, buffer, length);
 
-	if (rc)
-		DPRINTK(1, "sdio error=%d size=%d\n", rc, length);
+	if (ret) {
+		DPRINTK(1, "sdio error=%d size=%d\n", ret, length);
+		return ret;
+	}
 
-	return rc;
+	return 0;
 }
 
 static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
-	int retval;
+	int ret;
 
 	DPRINTK(4, "\n");
 
@@ -98,9 +102,8 @@ static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 
 	if (atomic_read(&priv->sleepstatus.status) == 0) {
 		rw_data = GCR_B_DOZE;
-		retval =
-		    ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
-		if (retval) {
+		ret = ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
+		if (ret) {
 			DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
 			goto set_sleep_mode;
 		}
@@ -119,7 +122,7 @@ static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
-	int retval;
+	int ret;
 
 	DPRINTK(4, "\n");
 
@@ -128,9 +131,8 @@ static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 
 	if (atomic_read(&priv->sleepstatus.status) == 1) {
 		rw_data = WAKEUP_REQ;
-		retval =
-		    ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
-		if (retval) {
+		ret = ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
+		if (ret) {
 			DPRINTK(1, " error : WAKEUP=%02X\n", rw_data);
 			goto set_sleep_mode;
 		}
@@ -149,14 +151,13 @@ static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
-	int retval;
+	int ret;
 
 	DPRINTK(4, "\n");
 	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 		rw_data = WAKEUP_REQ;
-		retval =
-		    ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
-		if (retval)
+		ret = ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
+		if (ret)
 			DPRINTK(1, " error : WAKEUP=%02X\n", rw_data);
 
 		DPRINTK(4, "wake up : WAKEUP=%02X\n", rw_data);
@@ -241,17 +242,17 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 			 void *arg1, void *arg2)
 {
 	struct tx_device_buffer *sp;
-	int rc;
+	int ret;
 
 	if (priv->dev_state < DEVICE_STATE_BOOT) {
-		rc = -EPERM;
+		ret = -EPERM;
 		goto err_complete;
 	}
 
 	if ((TX_DEVICE_BUFF_SIZE - 1) <= cnt_txqbody(priv)) {
 		/* in case of buffer overflow */
 		DPRINTK(1, "tx buffer overflow\n");
-		rc = -EOVERFLOW;
+		ret = -EOVERFLOW;
 		goto err_complete;
 	}
 
@@ -270,7 +271,7 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 	if (complete_handler)
 		(*complete_handler) (arg1, arg2);
 
-	return rc;
+	return ret;
 }
 
 /* write data */
@@ -279,7 +280,7 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 {
 	unsigned char rw_data;
 	struct hostif_hdr *hdr;
-	int rc;
+	int ret;
 
 	hdr = (struct hostif_hdr *)buffer;
 
@@ -289,17 +290,17 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 		return 0;
 	}
 
-	rc = ks7010_sdio_write(priv, DATA_WINDOW, buffer, size);
-	if (rc) {
-		DPRINTK(1, " write error : retval=%d\n", rc);
-		return rc;
+	ret = ks7010_sdio_write(priv, DATA_WINDOW, buffer, size);
+	if (ret) {
+		DPRINTK(1, " write error : retval=%d\n", ret);
+		return ret;
 	}
 
 	rw_data = WRITE_STATUS_BUSY;
-	rc = ks7010_sdio_write(priv, WRITE_STATUS, &rw_data, sizeof(rw_data));
-	if (rc) {
+	ret = ks7010_sdio_write(priv, WRITE_STATUS, &rw_data, sizeof(rw_data));
+	if (ret) {
 		DPRINTK(1, " error : WRITE_STATUS=%02X\n", rw_data);
-		return rc;
+		return ret;
 	}
 
 	return 0;
@@ -461,7 +462,7 @@ static void ks7010_rw_function(struct work_struct *work)
 	struct hw_info_t *hw;
 	struct ks_wlan_private *priv;
 	unsigned char rw_data;
-	int retval;
+	int ret;
 
 	hw = container_of(work, struct hw_info_t, rw_wq.work);
 	priv = container_of(hw, struct ks_wlan_private, ks_wlan_hw);
@@ -510,9 +511,8 @@ static void ks7010_rw_function(struct work_struct *work)
 	}
 
 	/* read (WriteStatus/ReadDataSize FN1:00_0014) */
-	retval =
-	    ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data, sizeof(rw_data));
-	if (retval) {
+	ret = ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data, sizeof(rw_data));
+	if (ret) {
 		DPRINTK(1, " error : WSTATUS_RSIZE=%02X psstatus=%d\n", rw_data,
 			atomic_read(&priv->psstatus.status));
 		goto err_release_host;
@@ -656,7 +656,7 @@ static void trx_device_exit(struct ks_wlan_private *priv)
 
 static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 {
-	int rc;
+	int ret;
 	unsigned char *data_buf;
 
 	data_buf = kmalloc(sizeof(u32), GFP_KERNEL);
@@ -664,12 +664,12 @@ static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 		return -ENOMEM;
 
 	memcpy(data_buf, &index, sizeof(index));
-	rc = ks7010_sdio_write(priv, WRITE_INDEX, data_buf, sizeof(index));
-	if (rc)
+	ret = ks7010_sdio_write(priv, WRITE_INDEX, data_buf, sizeof(index));
+	if (ret)
 		goto err_free_data_buf;
 
-	rc = ks7010_sdio_write(priv, READ_INDEX, data_buf, sizeof(index));
-	if (rc)
+	ret = ks7010_sdio_write(priv, READ_INDEX, data_buf, sizeof(index));
+	if (ret)
 		goto err_free_data_buf;
 
 	return 0;
@@ -677,27 +677,27 @@ static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 err_free_data_buf:
 	kfree(data_buf);
 
-	return rc;
+	return ret;
 }
 
 #define ROM_BUFF_SIZE (64 * 1024)
 static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 				    unsigned char *data, unsigned int size)
 {
-	int rc;
+	int ret;
 	unsigned char *read_buf;
 
 	read_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
 	if (!read_buf)
 		return -ENOMEM;
 
-	rc = ks7010_sdio_read(priv, address, read_buf, size);
-	if (rc)
+	ret = ks7010_sdio_read(priv, address, read_buf, size);
+	if (ret)
 		goto err_free_read_buf;
 
-	rc = memcmp(data, read_buf, size);
-	if (rc) {
-		DPRINTK(0, "data compare error (%d)\n", rc);
+	ret = memcmp(data, read_buf, size);
+	if (ret) {
+		DPRINTK(0, "data compare error (%d)\n", ret);
 		goto err_free_read_buf;
 	}
 
@@ -706,7 +706,7 @@ static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 err_free_read_buf:
 	kfree(read_buf);
 
-	return rc;
+	return ret;
 }
 
 static int ks7010_upload_firmware(struct ks_wlan_private *priv,
@@ -715,7 +715,7 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 	unsigned int size, offset, n = 0;
 	unsigned char *rom_buf;
 	unsigned char rw_data = 0;
-	int rc;
+	int ret;
 	int length;
 	const struct firmware *fw_entry = NULL;
 
@@ -727,14 +727,15 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 	sdio_claim_host(card->func);
 
 	/* Firmware running ? */
-	rc = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
+	ret = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
 	if (rw_data == GCR_A_RUN) {
 		DPRINTK(0, "MAC firmware running ...\n");
 		goto release_host_and_free;
 	}
 
-	rc = request_firmware(&fw_entry, ROM_FILE, &priv->ks_wlan_hw.sdio_card->func->dev);
-	if (rc)
+	ret = request_firmware(&fw_entry, ROM_FILE,
+			       &priv->ks_wlan_hw.sdio_card->func->dev);
+	if (ret)
 		goto release_host_and_free;
 
 	length = fw_entry->size;
@@ -755,19 +756,18 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 		memcpy(rom_buf, fw_entry->data + n, size);
 		/* Update write index */
 		offset = n;
-		rc = ks7010_sdio_update_index(priv,
-					      KS7010_IRAM_ADDRESS + offset);
-		if (rc)
+		ret = ks7010_sdio_update_index(priv, KS7010_IRAM_ADDRESS + offset);
+		if (ret)
 			goto release_firmware;
 
 		/* Write data */
-		rc = ks7010_sdio_write(priv, DATA_WINDOW, rom_buf, size);
-		if (rc)
+		ret = ks7010_sdio_write(priv, DATA_WINDOW, rom_buf, size);
+		if (ret)
 			goto release_firmware;
 
 		/* compare */
-		rc = ks7010_sdio_data_compare(priv, DATA_WINDOW, rom_buf, size);
-		if (rc)
+		ret = ks7010_sdio_data_compare(priv, DATA_WINDOW, rom_buf, size);
+		if (ret)
 			goto release_firmware;
 
 		n += size;
@@ -776,8 +776,8 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 
 	/* Remap request */
 	rw_data = GCR_A_REMAP;
-	rc = ks7010_sdio_write(priv, GCR_A, &rw_data, sizeof(rw_data));
-	if (rc)
+	ret = ks7010_sdio_write(priv, GCR_A, &rw_data, sizeof(rw_data));
+	if (ret)
 		goto release_firmware;
 
 	DPRINTK(4, " REMAP Request : GCR_A=%02X\n", rw_data);
@@ -785,8 +785,8 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 	/* Firmware running check */
 	for (n = 0; n < 50; ++n) {
 		mdelay(10);	/* wait_ms(10); */
-		rc = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
-		if (rc)
+		ret = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
+		if (ret)
 			goto release_firmware;
 
 		if (rw_data == GCR_A_RUN)
@@ -795,11 +795,11 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 	DPRINTK(4, "firmware wakeup (%d)!!!!\n", n);
 	if ((50) <= n) {
 		DPRINTK(1, "firmware can't start\n");
-		rc = -EIO;
+		ret = -EIO;
 		goto release_firmware;
 	}
 
-	rc = 0;
+	ret = 0;
 
  release_firmware:
 	release_firmware(fw_entry);
@@ -807,7 +807,7 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 	sdio_release_host(card->func);
 	kfree(rom_buf);
 
-	return rc;
+	return ret;
 }
 
 static void ks7010_card_init(struct ks_wlan_private *priv)

commit c133b9bd8ff18323f57859c5add3be9e872224c3
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:10 2017 +1100

    staging: ks7010: remove non-zero comparison
    
    Comparison, does not equal zero, is redundant
    
    'if (foo != 0)'  is equal to  'if (foo)'
    
    Typical kernel coding style is to use the shorter form.
    
    Remove unnecessary non-zero comparison.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 40ec028de9ac..8823e934aff7 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -61,7 +61,7 @@ static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
 	else	/* CMD53 multi-block transfer */
 		rc = sdio_memcpy_fromio(card->func, buffer, address, length);
 
-	if (rc != 0)
+	if (rc)
 		DPRINTK(1, "sdio error=%d size=%d\n", rc, length);
 
 	return rc;
@@ -80,7 +80,7 @@ static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
 	else	/* CMD53 */
 		rc = sdio_memcpy_toio(card->func, address, buffer, length);
 
-	if (rc != 0)
+	if (rc)
 		DPRINTK(1, "sdio error=%d size=%d\n", rc, length);
 
 	return rc;

commit f283dd6901cad0d823cf469e71db5700d456d1f6
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:09 2017 +1100

    staging: ks7010: make goto labels uniform
    
    Driver uses different label forms for similar purposes. It would be
    more clear if single use case has uniform label. 'out' is generic and
    adds no meaning to label.
    
    Documentation/process/coding-style.rst:
    Choose label names which say what the goto does or why the goto
    exists.
    
    Rename labels so as to better describe what they do. If an execution
    path only exists for the label on an error, prefix the label with
    'err_'. If a non-error execution path exist do not use prefix.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 3dab7006a10c..40ec028de9ac 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -102,7 +102,7 @@ static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 		    ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
 		if (retval) {
 			DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
-			goto out;
+			goto set_sleep_mode;
 		}
 		DPRINTK(4, "PMG SET!! : GCR_B=%02X\n", rw_data);
 		DPRINTK(3, "sleep_mode=SLP_SLEEP\n");
@@ -112,7 +112,7 @@ static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 		DPRINTK(1, "sleep_mode=%d\n", priv->sleep_mode);
 	}
 
- out:
+set_sleep_mode:
 	priv->sleep_mode = atomic_read(&priv->sleepstatus.status);
 }
 
@@ -132,7 +132,7 @@ static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 		    ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
 		if (retval) {
 			DPRINTK(1, " error : WAKEUP=%02X\n", rw_data);
-			goto out;
+			goto set_sleep_mode;
 		}
 		DPRINTK(4, "wake up : WAKEUP=%02X\n", rw_data);
 		atomic_set(&priv->sleepstatus.status, 0);
@@ -142,7 +142,7 @@ static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 		DPRINTK(1, "sleep_mode=%d\n", priv->sleep_mode);
 	}
 
- out:
+set_sleep_mode:
 	priv->sleep_mode = atomic_read(&priv->sleepstatus.status);
 }
 
@@ -495,18 +495,18 @@ static void ks7010_rw_function(struct work_struct *work)
 			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
 					   &priv->ks_wlan_hw.rw_wq, 1);
 		}
-		goto err_out;
+		goto err_release_host;
 	}
 
 	/* sleep mode doze */
 	if (atomic_read(&priv->sleepstatus.doze_request) == 1) {
 		ks_wlan_hw_sleep_doze_request(priv);
-		goto err_out;
+		goto err_release_host;
 	}
 	/* sleep mode wakeup */
 	if (atomic_read(&priv->sleepstatus.wakeup_request) == 1) {
 		ks_wlan_hw_sleep_wakeup_request(priv);
-		goto err_out;
+		goto err_release_host;
 	}
 
 	/* read (WriteStatus/ReadDataSize FN1:00_0014) */
@@ -515,7 +515,7 @@ static void ks7010_rw_function(struct work_struct *work)
 	if (retval) {
 		DPRINTK(1, " error : WSTATUS_RSIZE=%02X psstatus=%d\n", rw_data,
 			atomic_read(&priv->psstatus.status));
-		goto err_out;
+		goto err_release_host;
 	}
 	DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
 
@@ -528,7 +528,7 @@ static void ks7010_rw_function(struct work_struct *work)
 
 	_ks_wlan_hw_power_save(priv);
 
- err_out:
+err_release_host:
 	sdio_release_host(priv->ks_wlan_hw.sdio_card->func);
 }
 
@@ -549,7 +549,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 				     sizeof(status));
 		if (retval) {
 			DPRINTK(1, "read INT_PENDING Failed!!(%d)\n", retval);
-			goto intr_out;
+			goto queue_delayed_work;
 		}
 		DPRINTK(4, "INT_PENDING=%02X\n", rw_data);
 
@@ -565,7 +565,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 					     sizeof(rw_data));
 			if (retval) {
 				DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
-				goto intr_out;
+				goto queue_delayed_work;
 			}
 			/* DPRINTK(1, "GCR_B=%02X\n", rw_data); */
 			if (rw_data == GCR_B_ACTIVE) {
@@ -587,7 +587,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 			if (retval) {
 				DPRINTK(1, " error : WSTATUS_RSIZE=%02X\n",
 					rw_data);
-				goto intr_out;
+				goto queue_delayed_work;
 			}
 			DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
 			rsize = rw_data & RSIZE_MASK;
@@ -613,7 +613,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 		} while (rsize);
 	}
 
- intr_out:
+queue_delayed_work:
 	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
 			   &priv->ks_wlan_hw.rw_wq, 0);
 }
@@ -666,15 +666,15 @@ static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 	memcpy(data_buf, &index, sizeof(index));
 	rc = ks7010_sdio_write(priv, WRITE_INDEX, data_buf, sizeof(index));
 	if (rc)
-		goto error_out;
+		goto err_free_data_buf;
 
 	rc = ks7010_sdio_write(priv, READ_INDEX, data_buf, sizeof(index));
 	if (rc)
-		goto error_out;
+		goto err_free_data_buf;
 
 	return 0;
 
- error_out:
+err_free_data_buf:
 	kfree(data_buf);
 
 	return rc;
@@ -693,17 +693,17 @@ static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 
 	rc = ks7010_sdio_read(priv, address, read_buf, size);
 	if (rc)
-		goto error_out;
+		goto err_free_read_buf;
 
 	rc = memcmp(data, read_buf, size);
 	if (rc) {
 		DPRINTK(0, "data compare error (%d)\n", rc);
-		goto error_out;
+		goto err_free_read_buf;
 	}
 
 	return 0;
 
- error_out:
+err_free_read_buf:
 	kfree(read_buf);
 
 	return rc;
@@ -930,20 +930,20 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	ret = sdio_enable_func(func);
 	DPRINTK(5, "sdio_enable_func() %d\n", ret);
 	if (ret)
-		goto error_free_card;
+		goto err_free_card;
 
 	/* interrupt disable */
 	sdio_writeb(func, 0, INT_ENABLE, &ret);
 	if (ret)
-		goto error_free_card;
+		goto err_free_card;
 	sdio_writeb(func, 0xff, INT_PENDING, &ret);
 	if (ret)
-		goto error_disable_func;
+		goto err_disable_func;
 
 	/* setup interrupt handler */
 	ret = sdio_claim_irq(func, ks_sdio_interrupt);
 	if (ret)
-		goto error_disable_func;
+		goto err_disable_func;
 
 	sdio_release_host(func);
 
@@ -956,12 +956,12 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	netdev = alloc_etherdev(sizeof(*priv));
 	if (!netdev) {
 		dev_err(&card->func->dev, "ks7010 : Unable to alloc new net device\n");
-		goto error_release_irq;
+		goto err_release_irq;
 	}
 	if (dev_alloc_name(netdev, "wlan%d") < 0) {
 		dev_err(&card->func->dev,
 			"ks7010 :  Couldn't get name!\n");
-		goto error_free_netdev;
+		goto err_free_netdev;
 	}
 
 	priv = netdev_priv(netdev);
@@ -975,7 +975,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	priv->ks_wlan_hw.read_buf = NULL;
 	priv->ks_wlan_hw.read_buf = kmalloc(RX_DATA_SIZE, GFP_KERNEL);
 	if (!priv->ks_wlan_hw.read_buf)
-		goto error_free_netdev;
+		goto err_free_netdev;
 
 	priv->dev_state = DEVICE_STATE_PREBOOT;
 	priv->net_dev = netdev;
@@ -1003,7 +1003,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 		dev_err(&card->func->dev,
 			"ks7010: firmware load failed !! return code = %d\n",
 			 ret);
-		goto error_free_read_buf;
+		goto err_free_read_buf;
 	}
 
 	/* interrupt setting */
@@ -1023,7 +1023,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	ret = ks7010_sdio_write(priv, INT_ENABLE, &rw_data, sizeof(rw_data));
 	sdio_release_host(func);
 	if (ret)
-		DPRINTK(1, " error : INT_ENABLE=%02X\n", rw_data);
+		DPRINTK(1, " err : INT_ENABLE=%02X\n", rw_data);
 
 	DPRINTK(4, " enable Interrupt : INT_ENABLE=%02X\n", rw_data);
 	priv->dev_state = DEVICE_STATE_BOOT;
@@ -1031,7 +1031,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	priv->ks_wlan_hw.ks7010sdio_wq = create_workqueue("ks7010sdio_wq");
 	if (!priv->ks_wlan_hw.ks7010sdio_wq) {
 		DPRINTK(1, "create_workqueue failed !!\n");
-		goto error_free_read_buf;
+		goto err_free_read_buf;
 	}
 
 	INIT_DELAYED_WORK(&priv->ks_wlan_hw.rw_wq, ks7010_rw_function);
@@ -1039,22 +1039,22 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 
 	ret = register_netdev(priv->net_dev);
 	if (ret)
-		goto error_free_read_buf;
+		goto err_free_read_buf;
 
 	return 0;
 
- error_free_read_buf:
+ err_free_read_buf:
 	kfree(priv->ks_wlan_hw.read_buf);
 	priv->ks_wlan_hw.read_buf = NULL;
- error_free_netdev:
+ err_free_netdev:
 	free_netdev(priv->net_dev);
 	card->priv = NULL;
- error_release_irq:
+ err_release_irq:
 	sdio_claim_host(func);
 	sdio_release_irq(func);
- error_disable_func:
+ err_disable_func:
 	sdio_disable_func(func);
- error_free_card:
+ err_free_card:
 	sdio_release_host(func);
 	sdio_set_drvdata(func, NULL);
 	kfree(card);

commit 13b05e467d8f22c8ce871ffc7daa536df1beb0ce
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:08 2017 +1100

    staging: ks7010: return directly on error
    
    Function uses goto label with no clean up code. In this case we
    should just return directly.
    
    Remove goto statement, return directly on error.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 1d3a15f03365..3dab7006a10c 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -400,7 +400,7 @@ static void ks_wlan_hw_rx(void *dev, uint16_t size)
 	if (cnt_rxqbody(priv) >= (RX_DEVICE_BUFF_SIZE - 1)) {
 		/* in case of buffer overflow */
 		DPRINTK(1, "rx buffer overflow\n");
-		goto error_out;
+		return;
 	}
 	rx_buffer = &priv->rx_dev.rx_dev_buff[priv->rx_dev.qtail];
 
@@ -408,7 +408,7 @@ static void ks_wlan_hw_rx(void *dev, uint16_t size)
 	    ks7010_sdio_read(priv, DATA_WINDOW, &rx_buffer->data[0],
 			     hif_align_size(size));
 	if (retval)
-		goto error_out;
+		return;
 
 	/* length check */
 	if (size > 2046 || size == 0) {
@@ -426,7 +426,8 @@ static void ks_wlan_hw_rx(void *dev, uint16_t size)
 		if (retval)
 			DPRINTK(1, " error : READ_STATUS=%02X\n", read_status);
 
-		goto error_out;
+		/* length check fail */
+		return;
 	}
 
 	hdr = (struct hostif_hdr *)&rx_buffer->data[0];
@@ -453,9 +454,6 @@ static void ks_wlan_hw_rx(void *dev, uint16_t size)
 
 	/* rx_event_task((void *)priv); */
 	tasklet_schedule(&priv->ks_wlan_hw.rx_bh_task);
-
- error_out:
-	return;
 }
 
 static void ks7010_rw_function(struct work_struct *work)

commit 44c3cd5e0459fe1b6611bba9eb6b4d7d8c650686
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:05 2017 +1100

    staging: ks7010: fix checkpatch PARENTHESIS_ALIGNMENT
    
    Checkpatch emits CHECK: Alignment should match open parenthesis.
    
    Fix alignment to open parenthesis in line with kernel coding style.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 0fa13cd58dec..1d3a15f03365 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -193,8 +193,8 @@ static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 		cnt_txqbody(priv));
 
 	if (!atomic_read(&priv->psstatus.confirm_wait) &&
-		!atomic_read(&priv->psstatus.snooze_guard) &&
-		!cnt_txqbody(priv)) {
+	    !atomic_read(&priv->psstatus.snooze_guard) &&
+	    !cnt_txqbody(priv)) {
 		retval = ks7010_sdio_read(priv, INT_PENDING, &rw_data,
 					  sizeof(rw_data));
 		if (retval) {

commit 6cdd65389892c6017666c499993fb1affc16223e
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 15 13:57:32 2017 +1100

    staging: ks7010: remove dead code
    
    Driver has dead code compiled out using preprocessor directives. TODO
    file asks for these not to be removed - ignore this.
    
    Remove dead code. Remove 'do not remove #if 0/1 ...' from TODO file.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index f3ae9dba36bc..0fa13cd58dec 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -598,39 +598,19 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 					      (uint16_t)(rsize << 4));
 			}
 			if (rw_data & WSTATUS_MASK) {
-#if 0
-				if (status & INT_WRITE_STATUS
-				    && !cnt_txqbody(priv)) {
-					/* dummy write for interrupt clear */
-					rw_data = 0;
-					retval =
-					    ks7010_sdio_write(priv, DATA_WINDOW,
-							      &rw_data,
-							      sizeof(rw_data));
-					if (retval) {
-						DPRINTK(1,
-							"write DATA_WINDOW Failed!!(%d)\n",
-							retval);
+				if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
+					if (cnt_txqbody(priv)) {
+						ks_wlan_hw_wakeup_request(priv);
+						queue_delayed_work
+							(priv->ks_wlan_hw.
+								ks7010sdio_wq,
+								&priv->ks_wlan_hw.
+								rw_wq, 1);
+						return;
 					}
-					status &= ~INT_WRITE_STATUS;
 				} else {
-#endif
-					if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
-						if (cnt_txqbody(priv)) {
-							ks_wlan_hw_wakeup_request(priv);
-							queue_delayed_work
-							    (priv->ks_wlan_hw.
-							     ks7010sdio_wq,
-							     &priv->ks_wlan_hw.
-							     rw_wq, 1);
-							return;
-						}
-					} else {
-						tx_device_task((void *)priv);
-					}
-#if 0
+					tx_device_task((void *)priv);
 				}
-#endif
 			}
 		} while (rsize);
 	}

commit aa6ca807baace49992ad6990c9aeda22289be5cd
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 21:20:12 2017 +1100

    staging: ks7010: remove custom return values
    
    Driver code uses custom return values (often positive) to signal error
    condition instead of using standard kernel error codes.
    
    Replace custom return values with standard kernel error codes.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index df90c20fcb69..f3ae9dba36bc 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -241,21 +241,18 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 			 void *arg1, void *arg2)
 {
 	struct tx_device_buffer *sp;
+	int rc;
 
 	if (priv->dev_state < DEVICE_STATE_BOOT) {
-		kfree(p);
-		if (complete_handler)
-			(*complete_handler) (arg1, arg2);
-		return 1;
+		rc = -EPERM;
+		goto err_complete;
 	}
 
 	if ((TX_DEVICE_BUFF_SIZE - 1) <= cnt_txqbody(priv)) {
 		/* in case of buffer overflow */
 		DPRINTK(1, "tx buffer overflow\n");
-		kfree(p);
-		if (complete_handler)
-			(*complete_handler) (arg1, arg2);
-		return 1;
+		rc = -EOVERFLOW;
+		goto err_complete;
 	}
 
 	sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qtail];
@@ -267,15 +264,22 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 	inc_txqtail(priv);
 
 	return 0;
+
+err_complete:
+	kfree(p);
+	if (complete_handler)
+		(*complete_handler) (arg1, arg2);
+
+	return rc;
 }
 
 /* write data */
 static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 			   unsigned long size)
 {
-	int retval;
 	unsigned char rw_data;
 	struct hostif_hdr *hdr;
+	int rc;
 
 	hdr = (struct hostif_hdr *)buffer;
 
@@ -285,18 +289,17 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 		return 0;
 	}
 
-	retval = ks7010_sdio_write(priv, DATA_WINDOW, buffer, size);
-	if (retval) {
-		DPRINTK(1, " write error : retval=%d\n", retval);
-		return -4;
+	rc = ks7010_sdio_write(priv, DATA_WINDOW, buffer, size);
+	if (rc) {
+		DPRINTK(1, " write error : retval=%d\n", rc);
+		return rc;
 	}
 
 	rw_data = WRITE_STATUS_BUSY;
-	retval =
-	    ks7010_sdio_write(priv, WRITE_STATUS, &rw_data, sizeof(rw_data));
-	if (retval) {
+	rc = ks7010_sdio_write(priv, WRITE_STATUS, &rw_data, sizeof(rw_data));
+	if (rc) {
 		DPRINTK(1, " error : WRITE_STATUS=%02X\n", rw_data);
-		return -3;
+		return rc;
 	}
 
 	return 0;
@@ -675,30 +678,27 @@ static void trx_device_exit(struct ks_wlan_private *priv)
 
 static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 {
-	int rc = 0;
-	int retval;
+	int rc;
 	unsigned char *data_buf;
 
 	data_buf = kmalloc(sizeof(u32), GFP_KERNEL);
-	if (!data_buf) {
-		rc = 1;
-		goto error_out;
-	}
+	if (!data_buf)
+		return -ENOMEM;
 
 	memcpy(data_buf, &index, sizeof(index));
-	retval = ks7010_sdio_write(priv, WRITE_INDEX, data_buf, sizeof(index));
-	if (retval) {
-		rc = 2;
+	rc = ks7010_sdio_write(priv, WRITE_INDEX, data_buf, sizeof(index));
+	if (rc)
 		goto error_out;
-	}
 
-	retval = ks7010_sdio_write(priv, READ_INDEX, data_buf, sizeof(index));
-	if (retval) {
-		rc = 3;
+	rc = ks7010_sdio_write(priv, READ_INDEX, data_buf, sizeof(index));
+	if (rc)
 		goto error_out;
-	}
+
+	return 0;
+
  error_out:
 	kfree(data_buf);
+
 	return rc;
 }
 
@@ -706,29 +706,28 @@ static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 				    unsigned char *data, unsigned int size)
 {
-	int rc = 0;
-	int retval;
+	int rc;
 	unsigned char *read_buf;
 
 	read_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
-	if (!read_buf) {
-		rc = 1;
-		goto error_out;
-	}
-	retval = ks7010_sdio_read(priv, address, read_buf, size);
-	if (retval) {
-		rc = 2;
+	if (!read_buf)
+		return -ENOMEM;
+
+	rc = ks7010_sdio_read(priv, address, read_buf, size);
+	if (rc)
 		goto error_out;
-	}
-	retval = memcmp(data, read_buf, size);
 
-	if (retval) {
-		DPRINTK(0, "data compare error (%d)\n", retval);
-		rc = 3;
+	rc = memcmp(data, read_buf, size);
+	if (rc) {
+		DPRINTK(0, "data compare error (%d)\n", rc);
 		goto error_out;
 	}
+
+	return 0;
+
  error_out:
 	kfree(read_buf);
+
 	return rc;
 }
 
@@ -738,28 +737,27 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 	unsigned int size, offset, n = 0;
 	unsigned char *rom_buf;
 	unsigned char rw_data = 0;
-	int retval, rc = 0;
+	int rc;
 	int length;
 	const struct firmware *fw_entry = NULL;
 
 	/* buffer allocate */
 	rom_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
 	if (!rom_buf)
-		return 3;
+		return -ENOMEM;
 
 	sdio_claim_host(card->func);
 
 	/* Firmware running ? */
-	retval = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
+	rc = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
 	if (rw_data == GCR_A_RUN) {
 		DPRINTK(0, "MAC firmware running ...\n");
-		rc = 0;
-		goto error_out0;
+		goto release_host_and_free;
 	}
 
-	retval = request_firmware(&fw_entry, ROM_FILE, &priv->ks_wlan_hw.sdio_card->func->dev);
-	if (retval)
-		goto error_out0;
+	rc = request_firmware(&fw_entry, ROM_FILE, &priv->ks_wlan_hw.sdio_card->func->dev);
+	if (rc)
+		goto release_host_and_free;
 
 	length = fw_entry->size;
 
@@ -779,67 +777,58 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 		memcpy(rom_buf, fw_entry->data + n, size);
 		/* Update write index */
 		offset = n;
-		retval =
-		    ks7010_sdio_update_index(priv,
-					     KS7010_IRAM_ADDRESS + offset);
-		if (retval) {
-			rc = 6;
-			goto error_out1;
-		}
+		rc = ks7010_sdio_update_index(priv,
+					      KS7010_IRAM_ADDRESS + offset);
+		if (rc)
+			goto release_firmware;
 
 		/* Write data */
-		retval = ks7010_sdio_write(priv, DATA_WINDOW, rom_buf, size);
-		if (retval) {
-			rc = 8;
-			goto error_out1;
-		}
+		rc = ks7010_sdio_write(priv, DATA_WINDOW, rom_buf, size);
+		if (rc)
+			goto release_firmware;
 
 		/* compare */
-		retval =
-		    ks7010_sdio_data_compare(priv, DATA_WINDOW, rom_buf, size);
-		if (retval) {
-			rc = 9;
-			goto error_out1;
-		}
+		rc = ks7010_sdio_data_compare(priv, DATA_WINDOW, rom_buf, size);
+		if (rc)
+			goto release_firmware;
+
 		n += size;
 
 	} while (size);
 
 	/* Remap request */
 	rw_data = GCR_A_REMAP;
-	retval = ks7010_sdio_write(priv, GCR_A, &rw_data, sizeof(rw_data));
-	if (retval) {
-		rc = 11;
-		goto error_out1;
-	}
+	rc = ks7010_sdio_write(priv, GCR_A, &rw_data, sizeof(rw_data));
+	if (rc)
+		goto release_firmware;
+
 	DPRINTK(4, " REMAP Request : GCR_A=%02X\n", rw_data);
 
 	/* Firmware running check */
 	for (n = 0; n < 50; ++n) {
 		mdelay(10);	/* wait_ms(10); */
-		retval =
-		    ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
-		if (retval) {
-			rc = 11;
-			goto error_out1;
-		}
+		rc = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
+		if (rc)
+			goto release_firmware;
+
 		if (rw_data == GCR_A_RUN)
 			break;
 	}
 	DPRINTK(4, "firmware wakeup (%d)!!!!\n", n);
 	if ((50) <= n) {
 		DPRINTK(1, "firmware can't start\n");
-		rc = 12;
-		goto error_out1;
+		rc = -EIO;
+		goto release_firmware;
 	}
 
 	rc = 0;
 
- error_out1:
+ release_firmware:
 	release_firmware(fw_entry);
- error_out0:
+ release_host_and_free:
 	sdio_release_host(card->func);
 	kfree(rom_buf);
+
 	return rc;
 }
 

commit 83e4e8d2c20c0fa4158c49d07a34ed87447160a9
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Thu Mar 9 21:43:46 2017 +0530

    staging: ks7010: removed code in comments.
    
    Commenting Code Is a Bad Idea.
    Comments are their to explain the code and how the code achieves its
    goal and as codes in the comments  does not explain what the code is
    doing so there is no use of commenting them.
    So in this patch codes in the comments are removed.
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 14580cb4c755..df90c20fcb69 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -478,8 +478,6 @@ static void ks7010_rw_function(struct work_struct *work)
 	/* wiat after WAKEUP */
 	while (time_after(priv->last_wakeup + ((30 * HZ) / 1000), jiffies)) {
 		DPRINTK(4, "wait after WAKEUP\n");
-/*		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq,
-		(priv->last_wakeup + ((30*HZ)/1000) - jiffies));*/
 		dev_info(&priv->ks_wlan_hw.sdio_card->func->dev,
 			 "wake: %lu %lu\n",
 			 priv->last_wakeup + (30 * HZ) / 1000,

commit dad5980e313ec44f87f6306cc9186ed50cfecc8a
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Feb 27 14:14:48 2017 +1100

    staging: ks7010: refactor function call parameters
    
    Function call parameters are split over more lines than
    necessary. Also assignment statements are split after the '=' sign.
    This adds extra lines to the function and may also reduces
    readability.
    
    Refactor function call parameters and reduce the number of lines
    used. Put assignment statements onto single line.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 04130fb01842..14580cb4c755 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -195,48 +195,34 @@ static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	if (!atomic_read(&priv->psstatus.confirm_wait) &&
 		!atomic_read(&priv->psstatus.snooze_guard) &&
 		!cnt_txqbody(priv)) {
-		retval =
-			ks7010_sdio_read(priv, INT_PENDING,
-					&rw_data,
-					sizeof(rw_data));
+		retval = ks7010_sdio_read(priv, INT_PENDING, &rw_data,
+					  sizeof(rw_data));
 		if (retval) {
-			DPRINTK(1,
-				" error : INT_PENDING=%02X\n",
-				rw_data);
+			DPRINTK(1, " error : INT_PENDING=%02X\n", rw_data);
 			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-					&priv->ks_wlan_hw.rw_wq, 1);
+					   &priv->ks_wlan_hw.rw_wq, 1);
 			return 0;
 		}
 		if (!rw_data) {
 			rw_data = GCR_B_DOZE;
-			retval =
-				ks7010_sdio_write(priv,
-						GCR_B,
-						&rw_data,
-						sizeof(rw_data));
+			retval = ks7010_sdio_write(priv, GCR_B, &rw_data,
+						   sizeof(rw_data));
 			if (retval) {
-				DPRINTK(1,
-					" error : GCR_B=%02X\n",
-					rw_data);
-				queue_delayed_work
-					(priv->ks_wlan_hw.ks7010sdio_wq,
-						&priv->ks_wlan_hw.rw_wq, 1);
+				DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
+				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+						   &priv->ks_wlan_hw.rw_wq, 1);
 				return 0;
 			}
-			DPRINTK(4,
-				"PMG SET!! : GCR_B=%02X\n",
-				rw_data);
+			DPRINTK(4, "PMG SET!! : GCR_B=%02X\n", rw_data);
 			atomic_set(&priv->psstatus.status, PS_SNOOZE);
-			DPRINTK(3,
-				"psstatus.status=PS_SNOOZE\n");
+			DPRINTK(3, "psstatus.status=PS_SNOOZE\n");
 		} else {
 			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-					&priv->ks_wlan_hw.rw_wq, 1);
+					   &priv->ks_wlan_hw.rw_wq, 1);
 		}
 	} else {
 		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-				&priv->ks_wlan_hw.rw_wq,
-				0);
+				   &priv->ks_wlan_hw.rw_wq, 0);
 	}
 
 	return 0;

commit 3188bc092655a0ef032eda9d5a251323b3008d40
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Feb 27 14:14:47 2017 +1100

    staging: ks7010: remove switch statement
    
    Switch statement uses one [trivial] case and a default case holding
    bulk of code. We can swap the switch statement with an if/return
    statement as replacement for the original switch. This can be done
    without changing the program logic.
    
    Remove switch statement. Use original switch parameter as conditional
    and return if conditional evaluates to true. Reduce level of
    indentation. Do not change the program logic.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 0e07b83d3fd6..04130fb01842 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -183,63 +183,60 @@ static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	if (priv->dev_state != DEVICE_STATE_SLEEP)
 		return 0;
 
-	switch (atomic_read(&priv->psstatus.status)) {
-	case PS_SNOOZE:	/* 4 */
-		break;
-	default:
-		DPRINTK(5, "\npsstatus.status=%d\npsstatus.confirm_wait=%d\npsstatus.snooze_guard=%d\ncnt_txqbody=%d\n",
-			atomic_read(&priv->psstatus.status),
-			atomic_read(&priv->psstatus.confirm_wait),
-			atomic_read(&priv->psstatus.snooze_guard),
-			cnt_txqbody(priv));
-
-		if (!atomic_read(&priv->psstatus.confirm_wait) &&
-		    !atomic_read(&priv->psstatus.snooze_guard) &&
-		    !cnt_txqbody(priv)) {
+	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE)
+		return 0;
+
+	DPRINTK(5, "\npsstatus.status=%d\npsstatus.confirm_wait=%d\npsstatus.snooze_guard=%d\ncnt_txqbody=%d\n",
+		atomic_read(&priv->psstatus.status),
+		atomic_read(&priv->psstatus.confirm_wait),
+		atomic_read(&priv->psstatus.snooze_guard),
+		cnt_txqbody(priv));
+
+	if (!atomic_read(&priv->psstatus.confirm_wait) &&
+		!atomic_read(&priv->psstatus.snooze_guard) &&
+		!cnt_txqbody(priv)) {
+		retval =
+			ks7010_sdio_read(priv, INT_PENDING,
+					&rw_data,
+					sizeof(rw_data));
+		if (retval) {
+			DPRINTK(1,
+				" error : INT_PENDING=%02X\n",
+				rw_data);
+			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+					&priv->ks_wlan_hw.rw_wq, 1);
+			return 0;
+		}
+		if (!rw_data) {
+			rw_data = GCR_B_DOZE;
 			retval =
-				ks7010_sdio_read(priv, INT_PENDING,
+				ks7010_sdio_write(priv,
+						GCR_B,
 						&rw_data,
 						sizeof(rw_data));
 			if (retval) {
 				DPRINTK(1,
-					" error : INT_PENDING=%02X\n",
+					" error : GCR_B=%02X\n",
 					rw_data);
-				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-						&priv->ks_wlan_hw.rw_wq, 1);
-				break;
-			}
-			if (!rw_data) {
-				rw_data = GCR_B_DOZE;
-				retval =
-					ks7010_sdio_write(priv,
-							GCR_B,
-							&rw_data,
-							sizeof(rw_data));
-				if (retval) {
-					DPRINTK(1,
-						" error : GCR_B=%02X\n",
-						rw_data);
-					queue_delayed_work
-						(priv->ks_wlan_hw.ks7010sdio_wq,
-							&priv->ks_wlan_hw.rw_wq, 1);
-					break;
-				}
-				DPRINTK(4,
-					"PMG SET!! : GCR_B=%02X\n",
-					rw_data);
-				atomic_set(&priv->psstatus.status, PS_SNOOZE);
-				DPRINTK(3,
-					"psstatus.status=PS_SNOOZE\n");
-			} else {
-				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+				queue_delayed_work
+					(priv->ks_wlan_hw.ks7010sdio_wq,
 						&priv->ks_wlan_hw.rw_wq, 1);
+				return 0;
 			}
+			DPRINTK(4,
+				"PMG SET!! : GCR_B=%02X\n",
+				rw_data);
+			atomic_set(&priv->psstatus.status, PS_SNOOZE);
+			DPRINTK(3,
+				"psstatus.status=PS_SNOOZE\n");
 		} else {
 			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-					&priv->ks_wlan_hw.rw_wq,
-					0);
+					&priv->ks_wlan_hw.rw_wq, 1);
 		}
-		break;
+	} else {
+		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+				&priv->ks_wlan_hw.rw_wq,
+				0);
 	}
 
 	return 0;

commit cf57e659d5be6459e642dd451268bdb3437af7ff
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Feb 27 14:14:46 2017 +1100

    staging: ks7010: move logic operator to end of line
    
    Logic operator (&&) is place at the start of the line. Kernel
    standards suggest that logical operators should be placed at the end
    of the line.
    
    Move logical operator to the end of the previous line.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 4ce5867113ed..0e07b83d3fd6 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -193,9 +193,9 @@ static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 			atomic_read(&priv->psstatus.snooze_guard),
 			cnt_txqbody(priv));
 
-		if (!atomic_read(&priv->psstatus.confirm_wait)
-			&& !atomic_read(&priv->psstatus.snooze_guard)
-			&& !cnt_txqbody(priv)) {
+		if (!atomic_read(&priv->psstatus.confirm_wait) &&
+		    !atomic_read(&priv->psstatus.snooze_guard) &&
+		    !cnt_txqbody(priv)) {
 			retval =
 				ks7010_sdio_read(priv, INT_PENDING,
 						&rw_data,

commit 9f9d7030e4e1f9c9096a60dcb6429b41868e0ba9
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Feb 27 14:14:45 2017 +1100

    staging: ks7010: fix checkpatch MULTILINE_DEREFERENCE
    
    Checkpatch emits WARNING: Avoid multiple line dereference.
    
    Move dereference onto single line.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 1cf8b12f87f2..4ce5867113ed 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -227,8 +227,7 @@ static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 				DPRINTK(4,
 					"PMG SET!! : GCR_B=%02X\n",
 					rw_data);
-				atomic_set(&priv->psstatus.
-					status, PS_SNOOZE);
+				atomic_set(&priv->psstatus.status, PS_SNOOZE);
 				DPRINTK(3,
 					"psstatus.status=PS_SNOOZE\n");
 			} else {
@@ -236,8 +235,7 @@ static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 						&priv->ks_wlan_hw.rw_wq, 1);
 			}
 		} else {
-			queue_delayed_work(priv->ks_wlan_hw.
-					ks7010sdio_wq,
+			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
 					&priv->ks_wlan_hw.rw_wq,
 					0);
 		}

commit d5f1db31fb03072a11d8e5bb1e81c9b3982195b7
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Feb 27 14:14:44 2017 +1100

    staging: ks7010: invert conditional, reduce indent
    
    Function _ks_wlan_hw_power_save has 5 levels of indentation. Reducing
    the amount of indentation may make code clearer to read. Also a number
    of other checkpatch warnings may be removed if we first reduce the
    level of indentation in this function.
    
    Invert conditional and return from function if new conditional
    evaluates to true. Repeat on subsequent conditional. Reduce
    indentation without changing the program logic.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 6f9f746a3a61..1cf8b12f87f2 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -176,70 +176,72 @@ static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	if (priv->reg.powermgt == POWMGT_ACTIVE_MODE)
 		return 0;
 
-	if (priv->reg.operation_mode == MODE_INFRASTRUCTURE &&
-	    (priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
-		if (priv->dev_state == DEVICE_STATE_SLEEP) {
-			switch (atomic_read(&priv->psstatus.status)) {
-			case PS_SNOOZE:	/* 4 */
+	if (priv->reg.operation_mode != MODE_INFRASTRUCTURE ||
+	    (priv->connect_status & CONNECT_STATUS_MASK) != CONNECT_STATUS)
+		return 0;
+
+	if (priv->dev_state != DEVICE_STATE_SLEEP)
+		return 0;
+
+	switch (atomic_read(&priv->psstatus.status)) {
+	case PS_SNOOZE:	/* 4 */
+		break;
+	default:
+		DPRINTK(5, "\npsstatus.status=%d\npsstatus.confirm_wait=%d\npsstatus.snooze_guard=%d\ncnt_txqbody=%d\n",
+			atomic_read(&priv->psstatus.status),
+			atomic_read(&priv->psstatus.confirm_wait),
+			atomic_read(&priv->psstatus.snooze_guard),
+			cnt_txqbody(priv));
+
+		if (!atomic_read(&priv->psstatus.confirm_wait)
+			&& !atomic_read(&priv->psstatus.snooze_guard)
+			&& !cnt_txqbody(priv)) {
+			retval =
+				ks7010_sdio_read(priv, INT_PENDING,
+						&rw_data,
+						sizeof(rw_data));
+			if (retval) {
+				DPRINTK(1,
+					" error : INT_PENDING=%02X\n",
+					rw_data);
+				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+						&priv->ks_wlan_hw.rw_wq, 1);
 				break;
-			default:
-				DPRINTK(5, "\npsstatus.status=%d\npsstatus.confirm_wait=%d\npsstatus.snooze_guard=%d\ncnt_txqbody=%d\n",
-					atomic_read(&priv->psstatus.status),
-					atomic_read(&priv->psstatus.confirm_wait),
-					atomic_read(&priv->psstatus.snooze_guard),
-					cnt_txqbody(priv));
-
-				if (!atomic_read(&priv->psstatus.confirm_wait)
-				    && !atomic_read(&priv->psstatus.snooze_guard)
-				    && !cnt_txqbody(priv)) {
-					retval =
-					    ks7010_sdio_read(priv, INT_PENDING,
-							     &rw_data,
-							     sizeof(rw_data));
-					if (retval) {
-						DPRINTK(1,
-							" error : INT_PENDING=%02X\n",
-							rw_data);
-						queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-								   &priv->ks_wlan_hw.rw_wq, 1);
-						break;
-					}
-					if (!rw_data) {
-						rw_data = GCR_B_DOZE;
-						retval =
-						    ks7010_sdio_write(priv,
-								      GCR_B,
-								      &rw_data,
-								      sizeof(rw_data));
-						if (retval) {
-							DPRINTK(1,
-								" error : GCR_B=%02X\n",
-								rw_data);
-							queue_delayed_work
-							    (priv->ks_wlan_hw.ks7010sdio_wq,
-							     &priv->ks_wlan_hw.rw_wq, 1);
-							break;
-						}
-						DPRINTK(4,
-							"PMG SET!! : GCR_B=%02X\n",
-							rw_data);
-						atomic_set(&priv->psstatus.
-							   status, PS_SNOOZE);
-						DPRINTK(3,
-							"psstatus.status=PS_SNOOZE\n");
-					} else {
-						queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
-								   &priv->ks_wlan_hw.rw_wq, 1);
-					}
-				} else {
-					queue_delayed_work(priv->ks_wlan_hw.
-							   ks7010sdio_wq,
-							   &priv->ks_wlan_hw.rw_wq,
-							   0);
+			}
+			if (!rw_data) {
+				rw_data = GCR_B_DOZE;
+				retval =
+					ks7010_sdio_write(priv,
+							GCR_B,
+							&rw_data,
+							sizeof(rw_data));
+				if (retval) {
+					DPRINTK(1,
+						" error : GCR_B=%02X\n",
+						rw_data);
+					queue_delayed_work
+						(priv->ks_wlan_hw.ks7010sdio_wq,
+							&priv->ks_wlan_hw.rw_wq, 1);
+					break;
 				}
-				break;
+				DPRINTK(4,
+					"PMG SET!! : GCR_B=%02X\n",
+					rw_data);
+				atomic_set(&priv->psstatus.
+					status, PS_SNOOZE);
+				DPRINTK(3,
+					"psstatus.status=PS_SNOOZE\n");
+			} else {
+				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+						&priv->ks_wlan_hw.rw_wq, 1);
 			}
+		} else {
+			queue_delayed_work(priv->ks_wlan_hw.
+					ks7010sdio_wq,
+					&priv->ks_wlan_hw.rw_wq,
+					0);
 		}
+		break;
 	}
 
 	return 0;

commit d9eb486147270d15110dc3153203dfe65ccd15e6
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Thu Feb 16 16:31:02 2017 +0100

    Staging: ks7010: ks*: Remove redundant blank lines
    
    Multiple blank lines shouldn't be used.
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index a604c83c957e..6f9f746a3a61 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -884,7 +884,6 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 	if (priv->mac_address_valid && priv->version_size)
 		priv->dev_state = DEVICE_STATE_PREINIT;
 
-
 	hostif_sme_enqueue(priv, SME_GET_EEPROM_CKSUM);
 
 	/* load initial wireless parameter */

commit 20358d1384c39e385d8ed873049b7f4fdbcc585e
Author: Nick Rosbrook <nrosbrook@mail.smcvt.edu>
Date:   Fri Oct 21 13:15:13 2016 -0400

    staging: ks7010: ks7010_sdio.c: Fixing multiple assignments
    
    Running checkpatch on ks7010_sdio.c shows two locations where
    multiple assignment statements are used.
    
    This patch modifies the assignments into single assignments.
    
    Signed-off-by: Nick Rosbrook <nrosbrook@mail.smcvt.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 6f76d1a8c92a..a604c83c957e 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -659,10 +659,12 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 static int trx_device_init(struct ks_wlan_private *priv)
 {
 	/* initialize values (tx) */
-	priv->tx_dev.qtail = priv->tx_dev.qhead = 0;
+	priv->tx_dev.qhead = 0;
+	priv->tx_dev.qtail = 0;
 
 	/* initialize values (rx) */
-	priv->rx_dev.qtail = priv->rx_dev.qhead = 0;
+	priv->rx_dev.qhead = 0;
+	priv->rx_dev.qtail = 0;
 
 	/* initialize spinLock (tx,rx) */
 	spin_lock_init(&priv->tx_dev.tx_dev_lock);

commit f3f2d351db4e63d4a5bcdacab7d74b8e5a114d35
Author: Nick Rosbrook <nrosbrook@mail.smcvt.edu>
Date:   Thu Oct 20 13:08:06 2016 -0400

    staging: ks7010: Corrected a spelling mistake
    
    This patch corrects the spelling of 'initialize' in ks7010_sdio.c.
    
    The issue was found by checkpatch.
    
    Signed-off-by: Nick Rosbrook <nrosbrook@mail.smcvt.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 55ece81af3ab..6f76d1a8c92a 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -956,7 +956,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	priv = NULL;
 	netdev = NULL;
 
-	/* initilize ks_sdio_card */
+	/* initialize ks_sdio_card */
 	card = kzalloc(sizeof(*card), GFP_KERNEL);
 	if (!card)
 		return -ENOMEM;

commit 0966c755040d16f923121175ac9e5f7d315e8e6e
Author: Nick Rosbrook <nrosbrook@mail.smcvt.edu>
Date:   Wed Oct 19 18:52:04 2016 -0400

    staging: ks7010: Add spaces around '*'
    
    Added spaces around a '*' in ks7010_sdio.c. Issue found by checkpatch.
    
    Signed-off-by: Nick Rosbrook <nrosbrook@mail.smcvt.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index b02980d9bec2..55ece81af3ab 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -719,7 +719,7 @@ static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 	return rc;
 }
 
-#define ROM_BUFF_SIZE (64*1024)
+#define ROM_BUFF_SIZE (64 * 1024)
 static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 				    unsigned char *data, unsigned int size)
 {

commit 71a476e48dbdfc62f510396b645fe75a7ac8647b
Author: Akshay Mariyanna <akmlkcc@gmail.com>
Date:   Mon Oct 10 00:42:20 2016 +0530

    staging: ks7010: fix space related style issues in ks7010_sdio.c
    
    This fixes the following checkpatch warnings:
    WARNING: Unnecessary space before function pointer arguments
    WARNING: unnecessary whitespace before a quoted newline
    
    Signed-off-by: Akshay Mariyanna <akmlkcc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index a37cadffe539..b02980d9bec2 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -254,7 +254,7 @@ int ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 
 static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 			 unsigned long size,
-			 void (*complete_handler) (void *arg1, void *arg2),
+			 void (*complete_handler)(void *arg1, void *arg2),
 			 void *arg1, void *arg2)
 {
 	struct tx_device_buffer *sp;
@@ -353,7 +353,7 @@ static void tx_device_task(void *dev)
 }
 
 int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
-		  void (*complete_handler) (void *arg1, void *arg2),
+		  void (*complete_handler)(void *arg1, void *arg2),
 		  void *arg1, void *arg2)
 {
 	int result = 0;
@@ -413,7 +413,7 @@ static void ks_wlan_hw_rx(void *dev, uint16_t size)
 	/* receive data */
 	if (cnt_rxqbody(priv) >= (RX_DEVICE_BUFF_SIZE - 1)) {
 		/* in case of buffer overflow */
-		DPRINTK(1, "rx buffer overflow \n");
+		DPRINTK(1, "rx buffer overflow\n");
 		goto error_out;
 	}
 	rx_buffer = &priv->rx_dev.rx_dev_buff[priv->rx_dev.qtail];

commit 4fdaa0d700e4fae4ea99a5b2bb857c4c0e619dfe
Author: Akshay Mariyanna <akmlkcc@gmail.com>
Date:   Mon Oct 10 00:42:18 2016 +0530

    staging: ks7010: fix indent style in ks7010_sdio.c
    
    This patch fixes the following checkpatch error:
    ERROR: code indent should use tabs where possible
    
    Signed-off-by: Akshay Mariyanna <akmlkcc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 1f97161e4945..a37cadffe539 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -35,18 +35,18 @@ MODULE_DEVICE_TABLE(sdio, ks7010_sdio_ids);
 /* macro */
 
 #define inc_txqhead(priv) \
-        (priv->tx_dev.qhead = (priv->tx_dev.qhead + 1) % TX_DEVICE_BUFF_SIZE)
+	(priv->tx_dev.qhead = (priv->tx_dev.qhead + 1) % TX_DEVICE_BUFF_SIZE)
 #define inc_txqtail(priv) \
-        (priv->tx_dev.qtail = (priv->tx_dev.qtail + 1) % TX_DEVICE_BUFF_SIZE)
+	(priv->tx_dev.qtail = (priv->tx_dev.qtail + 1) % TX_DEVICE_BUFF_SIZE)
 #define cnt_txqbody(priv) \
-        (((priv->tx_dev.qtail + TX_DEVICE_BUFF_SIZE) - (priv->tx_dev.qhead)) % TX_DEVICE_BUFF_SIZE)
+	(((priv->tx_dev.qtail + TX_DEVICE_BUFF_SIZE) - (priv->tx_dev.qhead)) % TX_DEVICE_BUFF_SIZE)
 
 #define inc_rxqhead(priv) \
-        (priv->rx_dev.qhead = (priv->rx_dev.qhead + 1) % RX_DEVICE_BUFF_SIZE)
+	(priv->rx_dev.qhead = (priv->rx_dev.qhead + 1) % RX_DEVICE_BUFF_SIZE)
 #define inc_rxqtail(priv) \
-        (priv->rx_dev.qtail = (priv->rx_dev.qtail + 1) % RX_DEVICE_BUFF_SIZE)
+	(priv->rx_dev.qtail = (priv->rx_dev.qtail + 1) % RX_DEVICE_BUFF_SIZE)
 #define cnt_rxqbody(priv) \
-        (((priv->rx_dev.qtail + RX_DEVICE_BUFF_SIZE) - (priv->rx_dev.qhead)) % RX_DEVICE_BUFF_SIZE)
+	(((priv->rx_dev.qtail + RX_DEVICE_BUFF_SIZE) - (priv->rx_dev.qhead)) % RX_DEVICE_BUFF_SIZE)
 
 static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
 			    unsigned char *buffer, int length)

commit 0af454793a247b11b19506fa504ccde63d8372ac
Author: Pontus Fuchs <pontus.fuchs@gmail.com>
Date:   Thu Oct 6 22:50:19 2016 +0200

    staging: ks7010: Remove unnecessary cast
    
    sdio functions takes unsigned int as address. No need to cast.
    
    Signed-off-by: Pontus Fuchs <pontus.fuchs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 33f3351ae271..1f97161e4945 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -76,10 +76,9 @@ static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
 	card = priv->ks_wlan_hw.sdio_card;
 
 	if (length == 1)	/* CMD52 */
-		sdio_writeb(card->func, *buffer, (unsigned int)address, &rc);
+		sdio_writeb(card->func, *buffer, address, &rc);
 	else	/* CMD53 */
-		rc = sdio_memcpy_toio(card->func, (unsigned int)address, buffer,
-				      length);
+		rc = sdio_memcpy_toio(card->func, address, buffer, length);
 
 	if (rc != 0)
 		DPRINTK(1, "sdio error=%d size=%d\n", rc, length);

commit 697f9f7f8441dd4595a1653c1b2b4c8177299bf8
Author: Muraru Mihaela <mihaela.muraru21@gmail.com>
Date:   Mon Oct 3 22:28:52 2016 +0300

    Staging: ks7010: add blank line after declaration
    
    This patch fixes a coding style WARNING:
    Missing a blank line after declaration, found by checkpatch.pl.
    By adding a blank line after declaration of a variable.
    
    Signed-off-by: Muraru Mihaela <mihaela.muraru21@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 81c46f4d0935..33f3351ae271 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -294,6 +294,7 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 	int retval;
 	unsigned char rw_data;
 	struct hostif_hdr *hdr;
+
 	hdr = (struct hostif_hdr *)buffer;
 
 	DPRINTK(4, "size=%d\n", hdr->size);
@@ -358,6 +359,7 @@ int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
 {
 	int result = 0;
 	struct hostif_hdr *hdr;
+
 	hdr = (struct hostif_hdr *)p;
 
 	if (hdr->event < HIF_DATA_REQ || HIF_REQ_MAX < hdr->event) {
@@ -1117,6 +1119,7 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 	int ret;
 	struct ks_sdio_card *card;
 	struct ks_wlan_private *priv;
+
 	DPRINTK(1, "ks7010_sdio_remove()\n");
 
 	card = sdio_get_drvdata(func);
@@ -1142,6 +1145,7 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 		/* send stop request to MAC */
 		{
 			struct hostif_stop_request_t *pp;
+
 			pp = kzalloc(hif_align_size(sizeof(*pp)), GFP_KERNEL);
 			if (!pp) {
 				DPRINTK(3, "allocate memory failed..\n");

commit 4433459a49a186f8e253d7a2211b188040c8661d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Sep 27 19:39:43 2016 +0200

    staging: ks7010: declare private functions static
    
    Private functions in ks7010_sdio.c can be declared static.
    
    Fixes sparse warnings 'was not declared. Should it be static?'.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 28fb5a0c20b0..81c46f4d0935 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -87,7 +87,7 @@ static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
 	return rc;
 }
 
-void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
+static void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
 	int retval;
@@ -117,7 +117,7 @@ void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 	priv->sleep_mode = atomic_read(&priv->sleepstatus.status);
 }
 
-void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
+static void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
 	int retval;
@@ -169,7 +169,7 @@ void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 	}
 }
 
-int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
+static int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
 	int retval;

commit 9887b5e51fafaf919601ccb8bdae1e0ad749032f
Author: Sabitha George <sabitha.george@gmail.com>
Date:   Mon Sep 26 22:40:16 2016 +0530

    staging: ks7010: Fix warnings on printk() usage
    
    This patch fixes the following warnings on ks7010_sdio.c
    1. printk() should include KERN_ facility level
    2. Prefer [subsystem eg: netdev]_err([subsystem]dev, ...
    then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
    
    Signed-off-by: Sabitha George <sabitha.george@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index b27e9b054a94..28fb5a0c20b0 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -496,8 +496,10 @@ static void ks7010_rw_function(struct work_struct *work)
 		DPRINTK(4, "wait after WAKEUP\n");
 /*		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq,
 		(priv->last_wakeup + ((30*HZ)/1000) - jiffies));*/
-		printk("wake: %lu %lu\n", priv->last_wakeup + (30 * HZ) / 1000,
-		       jiffies);
+		dev_info(&priv->ks_wlan_hw.sdio_card->func->dev,
+			 "wake: %lu %lu\n",
+			 priv->last_wakeup + (30 * HZ) / 1000,
+				jiffies);
 		msleep(30);
 	}
 
@@ -1003,11 +1005,12 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	/* private memory allocate */
 	netdev = alloc_etherdev(sizeof(*priv));
 	if (!netdev) {
-		printk(KERN_ERR "ks7010 : Unable to alloc new net device\n");
+		dev_err(&card->func->dev, "ks7010 : Unable to alloc new net device\n");
 		goto error_release_irq;
 	}
 	if (dev_alloc_name(netdev, "wlan%d") < 0) {
-		printk(KERN_ERR "ks7010 :  Couldn't get name!\n");
+		dev_err(&card->func->dev,
+			"ks7010 :  Couldn't get name!\n");
 		goto error_free_netdev;
 	}
 
@@ -1047,9 +1050,9 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	/* Upload firmware */
 	ret = ks7010_upload_firmware(priv, card);	/* firmware load */
 	if (ret) {
-		printk(KERN_ERR
-		       "ks7010: firmware load failed !! retern code = %d\n",
-		       ret);
+		dev_err(&card->func->dev,
+			"ks7010: firmware load failed !! return code = %d\n",
+			 ret);
 		goto error_free_read_buf;
 	}
 

commit 7d359a847cf65cafa3582ee0c52f68e629fe0547
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Wed Sep 21 23:47:55 2016 +0530

    staging: ks7010: Remove unnecessary variable used to store return value
    
    This patch removes an unnecessary variable used to store return values
    in order to reduce memory usage.
    Done using coccinelle:
    @@
    type T;
    constant C;
    identifier ret;
    @@
    - T ret = C;
    ... when != ret
    return
    - ret
    + C
    ;
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 37a4ba37bf5d..b27e9b054a94 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -171,12 +171,11 @@ void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 
 int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 {
-	int rc = 0;
 	unsigned char rw_data;
 	int retval;
 
 	if (priv->reg.powermgt == POWMGT_ACTIVE_MODE)
-		return rc;
+		return 0;
 
 	if (priv->reg.operation_mode == MODE_INFRASTRUCTURE &&
 	    (priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
@@ -244,7 +243,7 @@ int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 		}
 	}
 
-	return rc;
+	return 0;
 }
 
 int ks_wlan_hw_power_save(struct ks_wlan_private *priv)

commit 2d738bd28c813d35f80fa7f9931f6d16dba47dbb
Author: Sandhya Bankar <bankarsandhya512@gmail.com>
Date:   Tue Sep 20 11:55:47 2016 +0530

    Staging: ks7010: Use sizeof structure *pointer over sizeof structure in kzalloc()
    
    This issue was found by checkpatch.
    
    Signed-off-by: Sandhya Bankar <bankarsandhya512@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 25ad43d34bd6..37a4ba37bf5d 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -955,7 +955,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	netdev = NULL;
 
 	/* initilize ks_sdio_card */
-	card = kzalloc(sizeof(struct ks_sdio_card), GFP_KERNEL);
+	card = kzalloc(sizeof(*card), GFP_KERNEL);
 	if (!card)
 		return -ENOMEM;
 

commit cbb351ccdfa1e2b3261a024fae7980597f56549f
Author: Sandhya Bankar <bankarsandhya512@gmail.com>
Date:   Sun Sep 18 04:55:26 2016 +0530

    Staging: ks7010: Drop memory allocation cast.
    
    Drop cast on the result of kzalloc.
    
    The semantic patch that makes this change is as follows:
    
    @@
    type T;
    @@
    - (T *)
      (\(kmalloc\|kzalloc\|kcalloc\|kmem_cache_alloc\|kmem_cache_zalloc\|
       kmem_cache_alloc_node\|kmalloc_node\|kzalloc_node\)(...))
    
    Signed-off-by: Sandhya Bankar <bankarsandhya512@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index f7ed8dba58ac..25ad43d34bd6 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1140,8 +1140,7 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 		/* send stop request to MAC */
 		{
 			struct hostif_stop_request_t *pp;
-			pp = (struct hostif_stop_request_t *)
-			    kzalloc(hif_align_size(sizeof(*pp)), GFP_KERNEL);
+			pp = kzalloc(hif_align_size(sizeof(*pp)), GFP_KERNEL);
 			if (!pp) {
 				DPRINTK(3, "allocate memory failed..\n");
 				return;	/* to do goto ni suru */

commit 149ad082a2f4873daca28f57d59ec3deb47685ac
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Sun Sep 18 12:56:25 2016 +0530

    staging: ks7010: Remove extra round braces around expressions/variables
    
    This patch removes excess round braces around expressions/variables.
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index a9fac712ee2c..f7ed8dba58ac 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -537,7 +537,7 @@ static void ks7010_rw_function(struct work_struct *work)
 
 	if (rw_data & RSIZE_MASK) {	/* Read schedule */
 		ks_wlan_hw_rx((void *)priv,
-			      (uint16_t)(((rw_data & RSIZE_MASK) << 4)));
+			      (uint16_t)((rw_data & RSIZE_MASK) << 4));
 	}
 	if ((rw_data & WSTATUS_MASK))
 		tx_device_task((void *)priv);
@@ -609,7 +609,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 			rsize = rw_data & RSIZE_MASK;
 			if (rsize) {	/* Read schedule */
 				ks_wlan_hw_rx((void *)priv,
-					      (uint16_t)(((rsize) << 4)));
+					      (uint16_t)(rsize << 4));
 			}
 			if (rw_data & WSTATUS_MASK) {
 #if 0

commit ca4765152e9c7cc713a6f52073027648d70ff4c5
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Sun Sep 18 12:55:32 2016 +0530

    staging: ks7010: Remove the space after a type cast
    
    The patch removes an unnecessary space after a cast, as detected by
    checkpatch.pl.
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index d35cda8fb45b..a9fac712ee2c 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -537,7 +537,7 @@ static void ks7010_rw_function(struct work_struct *work)
 
 	if (rw_data & RSIZE_MASK) {	/* Read schedule */
 		ks_wlan_hw_rx((void *)priv,
-			      (uint16_t) (((rw_data & RSIZE_MASK) << 4)));
+			      (uint16_t)(((rw_data & RSIZE_MASK) << 4)));
 	}
 	if ((rw_data & WSTATUS_MASK))
 		tx_device_task((void *)priv);
@@ -609,7 +609,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 			rsize = rw_data & RSIZE_MASK;
 			if (rsize) {	/* Read schedule */
 				ks_wlan_hw_rx((void *)priv,
-					      (uint16_t) (((rsize) << 4)));
+					      (uint16_t)(((rsize) << 4)));
 			}
 			if (rw_data & WSTATUS_MASK) {
 #if 0
@@ -1150,7 +1150,7 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 			    cpu_to_le16((uint16_t)
 					(sizeof(*pp) -
 					 sizeof(pp->header.size)));
-			pp->header.event = cpu_to_le16((uint16_t) HIF_STOP_REQ);
+			pp->header.event = cpu_to_le16((uint16_t)HIF_STOP_REQ);
 
 			sdio_claim_host(func);
 			write_to_device(priv, (unsigned char *)pp,

commit 7333c6fd438d64b55c7f31909f5274b26eb62c03
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Sun Sep 18 12:54:43 2016 +0530

    staging: ks7010: Remove unnecessary blank lines and commented code
    
    The patch removes unnecessary blank lines as detected by checkpatch.pl. Also,
    it removes a commented line of unrequired code.
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 54d055ccc5d2..d35cda8fb45b 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -180,8 +180,6 @@ int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 
 	if (priv->reg.operation_mode == MODE_INFRASTRUCTURE &&
 	    (priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
-
-		//DPRINTK(1,"psstatus.status=%d\n",atomic_read(&priv->psstatus.status));
 		if (priv->dev_state == DEVICE_STATE_SLEEP) {
 			switch (atomic_read(&priv->psstatus.status)) {
 			case PS_SNOOZE:	/* 4 */
@@ -244,7 +242,6 @@ int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 				break;
 			}
 		}
-
 	}
 
 	return rc;
@@ -343,7 +340,6 @@ static void tx_device_task(void *dev)
 						   &priv->ks_wlan_hw.rw_wq, 1);
 				return;
 			}
-
 		}
 		kfree(sp->sendp);	/* allocated memory free */
 		if (sp->complete_handler)	/* TX Complete */
@@ -597,7 +593,6 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 				}
 				complete(&priv->psstatus.wakeup_wait);
 			}
-
 		}
 
 		do {

commit 3d4a2cacc43fdae5c2c681455955c88d22561649
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Sun Sep 18 12:53:49 2016 +0530

    staging: ks7010: Remove space after '(' and before ')'
    
    The patch fixes the following errors detected by checkpatch.pl:
    ERROR: space prohibited before that close parenthesis ')'
    ERROR: space prohibited after that open parenthesis '('
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 42415b4e01a4..54d055ccc5d2 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -35,18 +35,18 @@ MODULE_DEVICE_TABLE(sdio, ks7010_sdio_ids);
 /* macro */
 
 #define inc_txqhead(priv) \
-        ( priv->tx_dev.qhead = (priv->tx_dev.qhead + 1) % TX_DEVICE_BUFF_SIZE )
+        (priv->tx_dev.qhead = (priv->tx_dev.qhead + 1) % TX_DEVICE_BUFF_SIZE)
 #define inc_txqtail(priv) \
-        ( priv->tx_dev.qtail = (priv->tx_dev.qtail + 1) % TX_DEVICE_BUFF_SIZE )
+        (priv->tx_dev.qtail = (priv->tx_dev.qtail + 1) % TX_DEVICE_BUFF_SIZE)
 #define cnt_txqbody(priv) \
-        (((priv->tx_dev.qtail + TX_DEVICE_BUFF_SIZE) - (priv->tx_dev.qhead)) % TX_DEVICE_BUFF_SIZE )
+        (((priv->tx_dev.qtail + TX_DEVICE_BUFF_SIZE) - (priv->tx_dev.qhead)) % TX_DEVICE_BUFF_SIZE)
 
 #define inc_rxqhead(priv) \
-        ( priv->rx_dev.qhead = (priv->rx_dev.qhead + 1) % RX_DEVICE_BUFF_SIZE )
+        (priv->rx_dev.qhead = (priv->rx_dev.qhead + 1) % RX_DEVICE_BUFF_SIZE)
 #define inc_rxqtail(priv) \
-        ( priv->rx_dev.qtail = (priv->rx_dev.qtail + 1) % RX_DEVICE_BUFF_SIZE )
+        (priv->rx_dev.qtail = (priv->rx_dev.qtail + 1) % RX_DEVICE_BUFF_SIZE)
 #define cnt_rxqbody(priv) \
-        (((priv->rx_dev.qtail + RX_DEVICE_BUFF_SIZE) - (priv->rx_dev.qhead)) % RX_DEVICE_BUFF_SIZE )
+        (((priv->rx_dev.qtail + RX_DEVICE_BUFF_SIZE) - (priv->rx_dev.qhead)) % RX_DEVICE_BUFF_SIZE)
 
 static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
 			    unsigned char *buffer, int length)

commit 53638cef86bfa613bd635f9c8c9462524c8dc6d7
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Sun Sep 18 12:52:27 2016 +0530

    staging: ks7010: Remove braces following single statement blocks
    
    The patch removes braces {} for single statement blocks, as suggested by
    checkpatch.pl.
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 394cb14fbc74..42415b4e01a4 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -157,9 +157,9 @@ void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 		rw_data = WAKEUP_REQ;
 		retval =
 		    ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
-		if (retval) {
+		if (retval)
 			DPRINTK(1, " error : WAKEUP=%02X\n", rw_data);
-		}
+
 		DPRINTK(4, "wake up : WAKEUP=%02X\n", rw_data);
 		priv->last_wakeup = jiffies;
 		++priv->wakeup_count;
@@ -398,9 +398,8 @@ static void rx_event_task(unsigned long dev)
 		hostif_receive(priv, rp->data, rp->size);
 		inc_rxqhead(priv);
 
-		if (cnt_rxqbody(priv) > 0) {
+		if (cnt_rxqbody(priv) > 0)
 			tasklet_schedule(&priv->ks_wlan_hw.rx_bh_task);
-		}
 	}
 }
 
@@ -426,9 +425,8 @@ static void ks_wlan_hw_rx(void *dev, uint16_t size)
 	retval =
 	    ks7010_sdio_read(priv, DATA_WINDOW, &rx_buffer->data[0],
 			     hif_align_size(size));
-	if (retval) {
+	if (retval)
 		goto error_out;
-	}
 
 	/* length check */
 	if (size > 2046 || size == 0) {
@@ -443,9 +441,9 @@ static void ks_wlan_hw_rx(void *dev, uint16_t size)
 		retval =
 		    ks7010_sdio_write(priv, READ_STATUS, &read_status,
 				      sizeof(read_status));
-		if (retval) {
+		if (retval)
 			DPRINTK(1, " error : READ_STATUS=%02X\n", read_status);
-		}
+
 		goto error_out;
 	}
 
@@ -459,9 +457,9 @@ static void ks_wlan_hw_rx(void *dev, uint16_t size)
 	retval =
 	    ks7010_sdio_write(priv, READ_STATUS, &read_status,
 			      sizeof(read_status));
-	if (retval) {
+	if (retval)
 		DPRINTK(1, " error : READ_STATUS=%02X\n", read_status);
-	}
+
 	DPRINTK(4, "READ_STATUS=%02X\n", read_status);
 
 	if (atomic_read(&priv->psstatus.confirm_wait)) {
@@ -545,9 +543,9 @@ static void ks7010_rw_function(struct work_struct *work)
 		ks_wlan_hw_rx((void *)priv,
 			      (uint16_t) (((rw_data & RSIZE_MASK) << 4)));
 	}
-	if ((rw_data & WSTATUS_MASK)) {
+	if ((rw_data & WSTATUS_MASK))
 		tx_device_task((void *)priv);
-	}
+
 	_ks_wlan_hw_power_save(priv);
 
  err_out:
@@ -884,9 +882,9 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 		DPRINTK(1, "wait time out!! SME_START\n");
 	}
 
-	if (priv->mac_address_valid && priv->version_size) {
+	if (priv->mac_address_valid && priv->version_size)
 		priv->dev_state = DEVICE_STATE_PREINIT;
-	}
+
 
 	hostif_sme_enqueue(priv, SME_GET_EEPROM_CKSUM);
 
@@ -1029,9 +1027,9 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	init_completion(&priv->ks_wlan_hw.ks7010_sdio_wait);
 	priv->ks_wlan_hw.read_buf = NULL;
 	priv->ks_wlan_hw.read_buf = kmalloc(RX_DATA_SIZE, GFP_KERNEL);
-	if (!priv->ks_wlan_hw.read_buf) {
+	if (!priv->ks_wlan_hw.read_buf)
 		goto error_free_netdev;
-	}
+
 	priv->dev_state = DEVICE_STATE_PREBOOT;
 	priv->net_dev = netdev;
 	priv->firmware_version[0] = '\0';
@@ -1067,9 +1065,9 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	sdio_claim_host(func);
 	ret = ks7010_sdio_write(priv, INT_PENDING, &rw_data, sizeof(rw_data));
 	sdio_release_host(func);
-	if (ret) {
+	if (ret)
 		DPRINTK(1, " error : INT_PENDING=%02X\n", rw_data);
-	}
+
 	DPRINTK(4, " clear Interrupt : INT_PENDING=%02X\n", rw_data);
 
 	/* enable ks7010sdio interrupt (INT_GCR_B|INT_READ_STATUS|INT_WRITE_STATUS) */
@@ -1077,9 +1075,9 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	sdio_claim_host(func);
 	ret = ks7010_sdio_write(priv, INT_ENABLE, &rw_data, sizeof(rw_data));
 	sdio_release_host(func);
-	if (ret) {
+	if (ret)
 		DPRINTK(1, " error : INT_ENABLE=%02X\n", rw_data);
-	}
+
 	DPRINTK(4, " enable Interrupt : INT_ENABLE=%02X\n", rw_data);
 	priv->dev_state = DEVICE_STATE_BOOT;
 

commit 041c4d754ae3901b0ac9295a110c4ad920d63201
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Sun Sep 18 12:51:03 2016 +0530

    staging: ks7010: Use #include <linux/atomic.h> instead of <asm/atomic.h>
    
    This patch replaces <asm/atomic.h> with <linux/atomic.h>, as suggested
    by checkpatch.pl.
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index f9aec4fbcb5c..394cb14fbc74 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -14,7 +14,7 @@
 #include <linux/mmc/card.h>
 #include <linux/mmc/sdio_func.h>
 #include <linux/workqueue.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 
 #include "ks_wlan.h"
 #include "ks_wlan_ioctl.h"

commit c8abeaf8021b1d78ba3b86235815047c8d648f4a
Author: Rehas Sachdeva <aquannie@gmail.com>
Date:   Thu Sep 15 00:52:58 2016 +0530

    staging: ks7010: Remove whitespace before newline
    
    This patch fixes the checkpatch.pl warning:
    WARNING: unnecessary whitespace before a quoted newline.
    
    Signed-off-by: Rehas Sachdeva <aquannie@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index d5299f032179..f9aec4fbcb5c 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -492,7 +492,7 @@ static void ks7010_rw_function(struct work_struct *work)
 
 	/* wiat after DOZE */
 	if (time_after(priv->last_doze + ((30 * HZ) / 1000), jiffies)) {
-		DPRINTK(4, "wait after DOZE \n");
+		DPRINTK(4, "wait after DOZE\n");
 		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
 				   &priv->ks_wlan_hw.rw_wq, 1);
 		return;
@@ -500,7 +500,7 @@ static void ks7010_rw_function(struct work_struct *work)
 
 	/* wiat after WAKEUP */
 	while (time_after(priv->last_wakeup + ((30 * HZ) / 1000), jiffies)) {
-		DPRINTK(4, "wait after WAKEUP \n");
+		DPRINTK(4, "wait after WAKEUP\n");
 /*		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq,
 		(priv->last_wakeup + ((30*HZ)/1000) - jiffies));*/
 		printk("wake: %lu %lu\n", priv->last_wakeup + (30 * HZ) / 1000,
@@ -745,7 +745,7 @@ static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 	retval = memcmp(data, read_buf, size);
 
 	if (retval) {
-		DPRINTK(0, "data compare error (%d) \n", retval);
+		DPRINTK(0, "data compare error (%d)\n", retval);
 		rc = 3;
 		goto error_out;
 	}

commit c7e65f4d2f7968de8605ef1b83ac1019e8e51d22
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Tue Sep 13 02:47:28 2016 +0530

    staging: ks7010: Remove the explicit NULL comparison
    
    The patch removes the explicit null comparisons entirely for the ks7010 driver.
    This was detected by checkpatch.pl
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 632253c11cd4..d5299f032179 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -266,7 +266,7 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 
 	if (priv->dev_state < DEVICE_STATE_BOOT) {
 		kfree(p);
-		if (complete_handler != NULL)
+		if (complete_handler)
 			(*complete_handler) (arg1, arg2);
 		return 1;
 	}
@@ -275,7 +275,7 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 		/* in case of buffer overflow */
 		DPRINTK(1, "tx buffer overflow\n");
 		kfree(p);
-		if (complete_handler != NULL)
+		if (complete_handler)
 			(*complete_handler) (arg1, arg2);
 		return 1;
 	}
@@ -346,7 +346,7 @@ static void tx_device_task(void *dev)
 
 		}
 		kfree(sp->sendp);	/* allocated memory free */
-		if (sp->complete_handler != NULL)	/* TX Complete */
+		if (sp->complete_handler)	/* TX Complete */
 			(*sp->complete_handler) (sp->arg1, sp->arg2);
 		inc_txqhead(priv);
 
@@ -687,7 +687,7 @@ static void trx_device_exit(struct ks_wlan_private *priv)
 	while (cnt_txqbody(priv) > 0) {
 		sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];
 		kfree(sp->sendp);	/* allocated memory free */
-		if (sp->complete_handler != NULL)	/* TX Complete */
+		if (sp->complete_handler)	/* TX Complete */
 			(*sp->complete_handler) (sp->arg1, sp->arg2);
 		inc_txqhead(priv);
 	}
@@ -1010,7 +1010,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 
 	/* private memory allocate */
 	netdev = alloc_etherdev(sizeof(*priv));
-	if (netdev == NULL) {
+	if (!netdev) {
 		printk(KERN_ERR "ks7010 : Unable to alloc new net device\n");
 		goto error_release_irq;
 	}
@@ -1126,7 +1126,7 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 
 	card = sdio_get_drvdata(func);
 
-	if (card == NULL)
+	if (!card)
 		return;
 
 	DPRINTK(1, "priv = card->priv\n");
@@ -1149,7 +1149,7 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 			struct hostif_stop_request_t *pp;
 			pp = (struct hostif_stop_request_t *)
 			    kzalloc(hif_align_size(sizeof(*pp)), GFP_KERNEL);
-			if (pp == NULL) {
+			if (!pp) {
 				DPRINTK(3, "allocate memory failed..\n");
 				return;	/* to do goto ni suru */
 			}

commit f5dc9399c07ee141924bcdccfeeacd7597a44cfe
Author: Hariharan R <hariharanrangasamy@gmail.com>
Date:   Mon Sep 5 18:22:46 2016 -0400

    staging: ks7010: fix warning on return for void functions
    
    This patch fixes the checkpatch warning in ks7010_sdio.c
    'void function return statements are not generally useful'
    
    Signed-off-by: Hariharan R <hariharanrangasamy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 86cdebe47db6..632253c11cd4 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -115,7 +115,6 @@ void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 
  out:
 	priv->sleep_mode = atomic_read(&priv->sleepstatus.status);
-	return;
 }
 
 void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
@@ -146,7 +145,6 @@ void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 
  out:
 	priv->sleep_mode = atomic_read(&priv->sleepstatus.status);
-	return;
 }
 
 void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
@@ -357,7 +355,6 @@ static void tx_device_task(void *dev)
 					   &priv->ks_wlan_hw.rw_wq, 0);
 		}
 	}
-	return;
 }
 
 int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
@@ -405,8 +402,6 @@ static void rx_event_task(unsigned long dev)
 			tasklet_schedule(&priv->ks_wlan_hw.rx_bh_task);
 		}
 	}
-
-	return;
 }
 
 static void ks_wlan_hw_rx(void *dev, uint16_t size)
@@ -557,8 +552,6 @@ static void ks7010_rw_function(struct work_struct *work)
 
  err_out:
 	sdio_release_host(priv->ks_wlan_hw.sdio_card->func);
-
-	return;
 }
 
 static void ks_sdio_interrupt(struct sdio_func *func)
@@ -666,7 +659,6 @@ static void ks_sdio_interrupt(struct sdio_func *func)
  intr_out:
 	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
 			   &priv->ks_wlan_hw.rw_wq, 0);
-	return;
 }
 
 static int trx_device_init(struct ks_wlan_private *priv)
@@ -701,8 +693,6 @@ static void trx_device_exit(struct ks_wlan_private *priv)
 	}
 
 	tasklet_kill(&priv->ks_wlan_hw.rx_bh_task);
-
-	return;
 }
 
 static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
@@ -1208,7 +1198,6 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 	DPRINTK(1, "kfree()\n");
 
 	DPRINTK(5, " Bye !!\n");
-	return;
 }
 
 static struct sdio_driver ks7010_sdio_driver = {

commit b80cfea24b02bcdc94cdbf67091d7b1c27ba6cd4
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Sun Sep 4 20:30:19 2016 +0530

    staging: ks7010: fix memory leak
    
    If the firmware request failed we were just returning but we missed
    freeing the memory and releasing the MMC Host.
    
    Signed-off-by: Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 7bcf1ea61861..86cdebe47db6 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -791,7 +791,7 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 
 	retval = request_firmware(&fw_entry, ROM_FILE, &priv->ks_wlan_hw.sdio_card->func->dev);
 	if (retval)
-		return retval;
+		goto error_out0;
 
 	length = fw_entry->size;
 

commit 369e1b69c1a2ed9fb66cfd2a6fe2f7340c64cd49
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Sun Sep 4 20:30:18 2016 +0530

    staging: ks7010: return on failure
    
    On failure we were jumping to error_out0 where we were trying
    sdio_release_host() but at this point of execution we still have not
    done sdio_claim_host() and as a result host->claimed can still be 0.
    And if host->claimed is 0 then WARN_ON(!host->claimed) will give
    a warning.
    Moreover, if it is still not claimed then mmc_host->claim_cnt will be 0
    and mmc_release_host() will do "if (--host->claim_cnt)" and thus the
    condition will become true.
    Lets just return the value on allocation failure instead of trying to
    release the host before claiming it.
    
    Signed-off-by: Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 47b69cbdb45b..7bcf1ea61861 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -776,10 +776,8 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 
 	/* buffer allocate */
 	rom_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
-	if (!rom_buf) {
-		rc = 3;
-		goto error_out0;
-	}
+	if (!rom_buf)
+		return 3;
 
 	sdio_claim_host(card->func);
 

commit 803394d03b43ba0ef4a9ed148de19c01d87cd13a
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Aug 13 19:52:38 2016 +0100

    staging: ks7010: do not dereference priv if priv is null
    
    priv is being dereferenced before a check for it being null
    is made, so there is a possibililty a null pointer deference
    can occur. Instead, only dereference priv if it is non-null.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index a0facfc54e4b..47b69cbdb45b 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1134,7 +1134,6 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 	int ret;
 	struct ks_sdio_card *card;
 	struct ks_wlan_private *priv;
-	struct net_device *netdev;
 	DPRINTK(1, "ks7010_sdio_remove()\n");
 
 	card = sdio_get_drvdata(func);
@@ -1144,8 +1143,9 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 
 	DPRINTK(1, "priv = card->priv\n");
 	priv = card->priv;
-	netdev = priv->net_dev;
 	if (priv) {
+		struct net_device *netdev = priv->net_dev;
+
 		ks_wlan_net_stop(netdev);
 		DPRINTK(1, "ks_wlan_net_stop\n");
 

commit 695872eae5cb8292ad5a748451453468f0576001
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sun Jul 17 19:26:15 2016 +0200

    staging: ks7010: Delete a variable in write_to_device()
    
    The local variable "rc" was assigned a zero at one place.
    But it was not read within this function. Thus delete it.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Reviewed-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 3622fba8fd36..a0facfc54e4b 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -297,11 +297,10 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 			   unsigned long size)
 {
-	int rc, retval;
+	int retval;
 	unsigned char rw_data;
 	struct hostif_hdr *hdr;
 	hdr = (struct hostif_hdr *)buffer;
-	rc = 0;
 
 	DPRINTK(4, "size=%d\n", hdr->size);
 	if (hdr->event < HIF_DATA_REQ || HIF_REQ_MAX < hdr->event) {

commit eeed92c0c0829e63c04a9f2c0c1926a4a48f6c0a
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sun Jul 17 13:38:46 2016 +0200

    staging: ks7010: Delete unnecessary assignments for buffer variables
    
    A few variables were assigned a null pointer despite of the detail
    that they were immediately reassigned by the following statement.
    Thus remove such unnecessary assignments.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Reviewed-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 7da6c841e2cc..3622fba8fd36 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -711,7 +711,6 @@ static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 	int rc = 0;
 	int retval;
 	unsigned char *data_buf;
-	data_buf = NULL;
 
 	data_buf = kmalloc(sizeof(u32), GFP_KERNEL);
 	if (!data_buf) {
@@ -743,7 +742,7 @@ static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 	int rc = 0;
 	int retval;
 	unsigned char *read_buf;
-	read_buf = NULL;
+
 	read_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
 	if (!read_buf) {
 		rc = 1;
@@ -776,8 +775,6 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 	int length;
 	const struct firmware *fw_entry = NULL;
 
-	rom_buf = NULL;
-
 	/* buffer allocate */
 	rom_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
 	if (!rom_buf) {

commit 58043f2527fe012e48ce30a5386c9763c88e5dd3
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sun Jul 17 13:14:57 2016 +0200

    staging: ks7010: Delete unnecessary checks before the function call "kfree"
    
    The kfree() function tests whether its argument is NULL and then
    returns immediately. Thus the test around the calls is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index b7337fd813d5..7da6c841e2cc 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -732,8 +732,7 @@ static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 		goto error_out;
 	}
  error_out:
-	if (data_buf)
-		kfree(data_buf);
+	kfree(data_buf);
 	return rc;
 }
 
@@ -763,8 +762,7 @@ static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 		goto error_out;
 	}
  error_out:
-	if (read_buf)
-		kfree(read_buf);
+	kfree(read_buf);
 	return rc;
 }
 
@@ -879,8 +877,7 @@ static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 	release_firmware(fw_entry);
  error_out0:
 	sdio_release_host(card->func);
-	if (rom_buf)
-		kfree(rom_buf);
+	kfree(rom_buf);
 	return rc;
 }
 
@@ -1199,9 +1196,7 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 		unregister_netdev(netdev);
 
 		trx_device_exit(priv);
-		if (priv->ks_wlan_hw.read_buf) {
-			kfree(priv->ks_wlan_hw.read_buf);
-		}
+		kfree(priv->ks_wlan_hw.read_buf);
 		free_netdev(priv->net_dev);
 		card->priv = NULL;
 	}

commit 6634cff1b545b8a6353e347c7871302353e5b7ca
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri Jun 17 10:46:59 2016 +0200

    staging: ks7010: report interface as wlan not eth
    
    Until we switch to cfg80211 (if ever), we must do this manually.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index c3035b80dac7..b7337fd813d5 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1033,7 +1033,7 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 		printk(KERN_ERR "ks7010 : Unable to alloc new net device\n");
 		goto error_release_irq;
 	}
-	if (dev_alloc_name(netdev, netdev->name) < 0) {
+	if (dev_alloc_name(netdev, "wlan%d") < 0) {
 		printk(KERN_ERR "ks7010 :  Couldn't get name!\n");
 		goto error_free_netdev;
 	}

commit 3fb54d7590a4a4d4cf99279c5c228bea788b9628
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri Jun 17 10:46:58 2016 +0200

    staging: ks7010: bail out when registering netdevice fails
    
    There is no need to continue then. Also, this enables us to remove an
    ugly static variable.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 16b9d76478b1..c3035b80dac7 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -25,8 +25,6 @@
 #define KS7010_IO_BLOCK_SIZE 512
 #define KS7010_MAX_CLOCK 25000000
 
-static int reg_net = 0;
-
 static const struct sdio_device_id ks7010_sdio_ids[] = {
 	{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_A, SDIO_DEVICE_ID_KS_7010)},
 	{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_B, SDIO_DEVICE_ID_KS_7010)},
@@ -936,8 +934,6 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 	if (priv->dev_state >= DEVICE_STATE_PREINIT) {
 		DPRINTK(1, "DEVICE READY!!\n");
 		priv->dev_state = DEVICE_STATE_READY;
-		reg_net = register_netdev(priv->net_dev);
-		DPRINTK(3, "register_netdev=%d\n", reg_net);
 	} else {
 		DPRINTK(1, "dev_state=%d\n", priv->dev_state);
 	}
@@ -1115,6 +1111,10 @@ static int ks7010_sdio_probe(struct sdio_func *func,
 	INIT_DELAYED_WORK(&priv->ks_wlan_hw.rw_wq, ks7010_rw_function);
 	ks7010_card_init(priv);
 
+	ret = register_netdev(priv->net_dev);
+	if (ret)
+		goto error_free_read_buf;
+
 	return 0;
 
  error_free_read_buf:
@@ -1196,9 +1196,7 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 		hostif_exit(priv);
 		DPRINTK(1, "hostif_exit\n");
 
-		if (!reg_net)
-			unregister_netdev(netdev);
-		DPRINTK(1, "unregister_netdev\n");
+		unregister_netdev(netdev);
 
 		trx_device_exit(priv);
 		if (priv->ks_wlan_hw.read_buf) {

commit 4c0d46d2cf62c9cd199cc3323d0b670e7b755650
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri Jun 17 10:46:57 2016 +0200

    staging: ks7010: sdio: remove forward declarations
    
    Move read/write functions to the top and driver struct to the end, so we
    can remove all forward declarations.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 8c2b62bc4d14..16b9d76478b1 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -34,14 +34,6 @@ static const struct sdio_device_id ks7010_sdio_ids[] = {
 };
 MODULE_DEVICE_TABLE(sdio, ks7010_sdio_ids);
 
-static int ks7010_sdio_probe(struct sdio_func *function,
-			     const struct sdio_device_id *device);
-static void ks7010_sdio_remove(struct sdio_func *function);
-static void ks7010_rw_function(struct work_struct *work);
-static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
-			    unsigned char *buffer, int length);
-static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
-			     unsigned char *buffer, int length);
 /* macro */
 
 #define inc_txqhead(priv) \
@@ -58,6 +50,45 @@ static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
 #define cnt_rxqbody(priv) \
         (((priv->rx_dev.qtail + RX_DEVICE_BUFF_SIZE) - (priv->rx_dev.qhead)) % RX_DEVICE_BUFF_SIZE )
 
+static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
+			    unsigned char *buffer, int length)
+{
+	struct ks_sdio_card *card;
+	int rc;
+
+	card = priv->ks_wlan_hw.sdio_card;
+
+	if (length == 1)	/* CMD52 */
+		*buffer = sdio_readb(card->func, address, &rc);
+	else	/* CMD53 multi-block transfer */
+		rc = sdio_memcpy_fromio(card->func, buffer, address, length);
+
+	if (rc != 0)
+		DPRINTK(1, "sdio error=%d size=%d\n", rc, length);
+
+	return rc;
+}
+
+static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
+			     unsigned char *buffer, int length)
+{
+	struct ks_sdio_card *card;
+	int rc;
+
+	card = priv->ks_wlan_hw.sdio_card;
+
+	if (length == 1)	/* CMD52 */
+		sdio_writeb(card->func, *buffer, (unsigned int)address, &rc);
+	else	/* CMD53 */
+		rc = sdio_memcpy_toio(card->func, (unsigned int)address, buffer,
+				      length);
+
+	if (rc != 0)
+		DPRINTK(1, "sdio error=%d size=%d\n", rc, length);
+
+	return rc;
+}
+
 void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
@@ -230,45 +261,6 @@ int ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 	return 0;
 }
 
-static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
-			    unsigned char *buffer, int length)
-{
-	struct ks_sdio_card *card;
-	int rc;
-
-	card = priv->ks_wlan_hw.sdio_card;
-
-	if (length == 1)	/* CMD52 */
-		*buffer = sdio_readb(card->func, address, &rc);
-	else	/* CMD53 multi-block transfer */
-		rc = sdio_memcpy_fromio(card->func, buffer, address, length);
-
-	if (rc != 0)
-		DPRINTK(1, "sdio error=%d size=%d\n", rc, length);
-
-	return rc;
-}
-
-static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
-			     unsigned char *buffer, int length)
-{
-	struct ks_sdio_card *card;
-	int rc;
-
-	card = priv->ks_wlan_hw.sdio_card;
-
-	if (length == 1)	/* CMD52 */
-		sdio_writeb(card->func, *buffer, (unsigned int)address, &rc);
-	else	/* CMD53 */
-		rc = sdio_memcpy_toio(card->func, (unsigned int)address, buffer,
-				      length);
-
-	if (rc != 0)
-		DPRINTK(1, "sdio error=%d size=%d\n", rc, length);
-
-	return rc;
-}
-
 static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
 			 unsigned long size,
 			 void (*complete_handler) (void *arg1, void *arg2),
@@ -951,13 +943,6 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 	}
 }
 
-static struct sdio_driver ks7010_sdio_driver = {
-	.name = "ks7010_sdio",
-	.id_table = ks7010_sdio_ids,
-	.probe = ks7010_sdio_probe,
-	.remove = ks7010_sdio_remove,
-};
-
 static void ks7010_init_defaults(struct ks_wlan_private *priv)
 {
 	priv->reg.tx_rate = TX_RATE_AUTO;
@@ -1239,6 +1224,13 @@ static void ks7010_sdio_remove(struct sdio_func *func)
 	return;
 }
 
+static struct sdio_driver ks7010_sdio_driver = {
+	.name = "ks7010_sdio",
+	.id_table = ks7010_sdio_ids,
+	.probe = ks7010_sdio_probe,
+	.remove = ks7010_sdio_remove,
+};
+
 module_driver(ks7010_sdio_driver, sdio_register_driver, sdio_unregister_driver);
 MODULE_AUTHOR("Sang Engineering, Qi-Hardware, KeyStream");
 MODULE_DESCRIPTION("Driver for KeyStream KS7010 based SDIO cards");

commit c4730a92766dacc336f6740c5c1e6181334ef316
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri Jun 17 10:46:56 2016 +0200

    staging: ks7010: unify naming to ks7010
    
    No 79xx anymore, this is confusing. Add a comment saying that old
    versions were probably named 7910/79xx.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 280cbfb6aa7f..8c2b62bc4d14 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -34,9 +34,9 @@ static const struct sdio_device_id ks7010_sdio_ids[] = {
 };
 MODULE_DEVICE_TABLE(sdio, ks7010_sdio_ids);
 
-static int ks7910_sdio_probe(struct sdio_func *function,
+static int ks7010_sdio_probe(struct sdio_func *function,
 			     const struct sdio_device_id *device);
-static void ks7910_sdio_remove(struct sdio_func *function);
+static void ks7010_sdio_remove(struct sdio_func *function);
 static void ks7010_rw_function(struct work_struct *work);
 static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
 			    unsigned char *buffer, int length);
@@ -778,7 +778,7 @@ static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 	return rc;
 }
 
-static int ks79xx_upload_firmware(struct ks_wlan_private *priv,
+static int ks7010_upload_firmware(struct ks_wlan_private *priv,
 				  struct ks_sdio_card *card)
 {
 	unsigned int size, offset, n = 0;
@@ -952,10 +952,10 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 }
 
 static struct sdio_driver ks7010_sdio_driver = {
-	.name = "ks7910_sdio",
+	.name = "ks7010_sdio",
 	.id_table = ks7010_sdio_ids,
-	.probe = ks7910_sdio_probe,
-	.remove = ks7910_sdio_remove,
+	.probe = ks7010_sdio_probe,
+	.remove = ks7010_sdio_remove,
 };
 
 static void ks7010_init_defaults(struct ks_wlan_private *priv)
@@ -985,7 +985,7 @@ static void ks7010_init_defaults(struct ks_wlan_private *priv)
 	priv->reg.rate_set.size = 12;
 }
 
-static int ks7910_sdio_probe(struct sdio_func *func,
+static int ks7010_sdio_probe(struct sdio_func *func,
 			     const struct sdio_device_id *device)
 {
 	struct ks_wlan_private *priv;
@@ -994,7 +994,7 @@ static int ks7910_sdio_probe(struct sdio_func *func,
 	unsigned char rw_data;
 	int ret;
 
-	DPRINTK(5, "ks7910_sdio_probe()\n");
+	DPRINTK(5, "ks7010_sdio_probe()\n");
 
 	priv = NULL;
 	netdev = NULL;
@@ -1049,11 +1049,11 @@ static int ks7910_sdio_probe(struct sdio_func *func,
 	/* private memory allocate */
 	netdev = alloc_etherdev(sizeof(*priv));
 	if (netdev == NULL) {
-		printk(KERN_ERR "ks79xx : Unable to alloc new net device\n");
+		printk(KERN_ERR "ks7010 : Unable to alloc new net device\n");
 		goto error_release_irq;
 	}
 	if (dev_alloc_name(netdev, netdev->name) < 0) {
-		printk(KERN_ERR "ks79xx :  Couldn't get name!\n");
+		printk(KERN_ERR "ks7010 :  Couldn't get name!\n");
 		goto error_free_netdev;
 	}
 
@@ -1091,10 +1091,10 @@ static int ks7910_sdio_probe(struct sdio_func *func,
 	ks7010_init_defaults(priv);
 
 	/* Upload firmware */
-	ret = ks79xx_upload_firmware(priv, card);	/* firmware load */
+	ret = ks7010_upload_firmware(priv, card);	/* firmware load */
 	if (ret) {
 		printk(KERN_ERR
-		       "ks79xx: firmware load failed !! retern code = %d\n",
+		       "ks7010: firmware load failed !! retern code = %d\n",
 		       ret);
 		goto error_free_read_buf;
 	}
@@ -1151,13 +1151,13 @@ static int ks7910_sdio_probe(struct sdio_func *func,
 	return -ENODEV;
 }
 
-static void ks7910_sdio_remove(struct sdio_func *func)
+static void ks7010_sdio_remove(struct sdio_func *func)
 {
 	int ret;
 	struct ks_sdio_card *card;
 	struct ks_wlan_private *priv;
 	struct net_device *netdev;
-	DPRINTK(1, "ks7910_sdio_remove()\n");
+	DPRINTK(1, "ks7010_sdio_remove()\n");
 
 	card = sdio_get_drvdata(func);
 

commit f9b5bd05a1b43de072da29649b192130411a982c
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri Jun 17 10:46:55 2016 +0200

    staging: ks7010: export sdio ids
    
    So the module will be loaded automatically on card insertion. Rename the
    array while here.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index b3c98ebaec14..280cbfb6aa7f 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -27,11 +27,12 @@
 
 static int reg_net = 0;
 
-static const struct sdio_device_id if_sdio_ids[] = {
+static const struct sdio_device_id ks7010_sdio_ids[] = {
 	{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_A, SDIO_DEVICE_ID_KS_7010)},
 	{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_B, SDIO_DEVICE_ID_KS_7010)},
 	{ /* all zero */ }
 };
+MODULE_DEVICE_TABLE(sdio, ks7010_sdio_ids);
 
 static int ks7910_sdio_probe(struct sdio_func *function,
 			     const struct sdio_device_id *device);
@@ -952,7 +953,7 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 
 static struct sdio_driver ks7010_sdio_driver = {
 	.name = "ks7910_sdio",
-	.id_table = if_sdio_ids,
+	.id_table = ks7010_sdio_ids,
 	.probe = ks7910_sdio_probe,
 	.remove = ks7910_sdio_remove,
 };

commit 1c013a5ca630eba9ee532eaa77aa67ad4164c298
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri Jun 17 10:46:54 2016 +0200

    staging: ks7010: collect all includes and sort them
    
    Includes probably need a driver-wide clean up, but for now let's at
    least group all includes from the sdio file together.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 714f933a7d85..b3c98ebaec14 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -10,15 +10,15 @@
  *   published by the Free Software Foundation.
  */
 
-#include <linux/workqueue.h>
-#include <asm/atomic.h>
+#include <linux/firmware.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/sdio_func.h>
+#include <linux/workqueue.h>
+#include <asm/atomic.h>
 
 #include "ks_wlan.h"
 #include "ks_wlan_ioctl.h"
 #include "ks_hostif.h"
-
 #include "ks7010_sdio.h"
 
 #define KS7010_FUNC_NUM 1
@@ -777,7 +777,6 @@ static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 	return rc;
 }
 
-#include <linux/firmware.h>
 static int ks79xx_upload_firmware(struct ks_wlan_private *priv,
 				  struct ks_sdio_card *card)
 {

commit 30776cf921cd9033d88da56d33707515ce892a8a
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri Jun 17 10:46:53 2016 +0200

    staging: ks7010: function declaration should be in a header file
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index d4cce78106a7..714f933a7d85 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -958,9 +958,6 @@ static struct sdio_driver ks7010_sdio_driver = {
 	.remove = ks7910_sdio_remove,
 };
 
-extern int ks_wlan_net_start(struct net_device *dev);
-extern int ks_wlan_net_stop(struct net_device *dev);
-
 static void ks7010_init_defaults(struct ks_wlan_private *priv)
 {
 	priv->reg.tx_rate = TX_RATE_AUTO;

commit 6ee9169b407f70334f59cdf5a40a72a5d27f0ec2
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri Jun 17 10:46:52 2016 +0200

    staging: ks7010: remove cfg file handling
    
    I verified that all but two settings from the config file can be set up
    also via 'iwconfig' or 'iwpriv'. The two missing are ROM_FILE and
    PhyInformationTimer. ROM_FILE can be easily dropped. There is only one
    known firmware floating on the net, so, the name is fix and we can make
    this constant. Frankly, I don't know when PhyInformationTimer needs to
    be set to non-zero. But if we need it somewhen, there is already
    (currently commented out) code to add this as another private method, so
    we could use that. Summa summarum: We can remove the config file
    handling and the example config file. The only useful action,
    initialization of the configuration struct, is now moved to the sdio
    main file.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index c340254cc895..d4cce78106a7 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -807,15 +807,10 @@ static int ks79xx_upload_firmware(struct ks_wlan_private *priv,
 		goto error_out0;
 	}
 
-	if (request_firmware
-	    (&fw_entry, priv->reg.rom_file,
-	     &priv->ks_wlan_hw.sdio_card->func->dev) != 0) {
-		DPRINTK(1, "error request_firmware() file=%s\n",
-			priv->reg.rom_file);
-		return 1;
-	}
-	DPRINTK(4, "success request_firmware() file=%s size=%zu\n",
-		priv->reg.rom_file, fw_entry->size);
+	retval = request_firmware(&fw_entry, ROM_FILE, &priv->ks_wlan_hw.sdio_card->func->dev);
+	if (retval)
+		return retval;
+
 	length = fw_entry->size;
 
 	/* Load Program */
@@ -966,6 +961,33 @@ static struct sdio_driver ks7010_sdio_driver = {
 extern int ks_wlan_net_start(struct net_device *dev);
 extern int ks_wlan_net_stop(struct net_device *dev);
 
+static void ks7010_init_defaults(struct ks_wlan_private *priv)
+{
+	priv->reg.tx_rate = TX_RATE_AUTO;
+	priv->reg.preamble = LONG_PREAMBLE;
+	priv->reg.powermgt = POWMGT_ACTIVE_MODE;
+	priv->reg.scan_type = ACTIVE_SCAN;
+	priv->reg.beacon_lost_count = 20;
+	priv->reg.rts = 2347UL;
+	priv->reg.fragment = 2346UL;
+	priv->reg.phy_type = D_11BG_COMPATIBLE_MODE;
+	priv->reg.cts_mode = CTS_MODE_FALSE;
+	priv->reg.rate_set.body[11] = TX_RATE_54M;
+	priv->reg.rate_set.body[10] = TX_RATE_48M;
+	priv->reg.rate_set.body[9] = TX_RATE_36M;
+	priv->reg.rate_set.body[8] = TX_RATE_18M;
+	priv->reg.rate_set.body[7] = TX_RATE_9M;
+	priv->reg.rate_set.body[6] = TX_RATE_24M | BASIC_RATE;
+	priv->reg.rate_set.body[5] = TX_RATE_12M | BASIC_RATE;
+	priv->reg.rate_set.body[4] = TX_RATE_6M | BASIC_RATE;
+	priv->reg.rate_set.body[3] = TX_RATE_11M | BASIC_RATE;
+	priv->reg.rate_set.body[2] = TX_RATE_5M | BASIC_RATE;
+	priv->reg.rate_set.body[1] = TX_RATE_2M | BASIC_RATE;
+	priv->reg.rate_set.body[0] = TX_RATE_1M | BASIC_RATE;
+	priv->reg.tx_rate = TX_RATE_FULL_AUTO;
+	priv->reg.rate_set.size = 12;
+}
+
 static int ks7910_sdio_probe(struct sdio_func *func,
 			     const struct sdio_device_id *device)
 {
@@ -1069,14 +1091,7 @@ static int ks7910_sdio_probe(struct sdio_func *func,
 	hostif_init(priv);
 	ks_wlan_net_start(netdev);
 
-	/* Read config file */
-	ret = ks_wlan_read_config_file(priv);
-	if (ret) {
-		printk(KERN_ERR
-		       "ks79xx: read configuration file failed !! retern code = %d\n",
-		       ret);
-		goto error_free_read_buf;
-	}
+	ks7010_init_defaults(priv);
 
 	/* Upload firmware */
 	ret = ks79xx_upload_firmware(priv, card);	/* firmware load */

commit c5d9a03031a645a8c63fdaa6a650113f8bd55b2b
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:43 2016 +0200

    staging: ks7010: cleanup file headers
    
    Remove svn-ids and fix typos in the licence declaration. Add my
    copyright to the sdio code which I worked on mainly.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index c166022b652e..c340254cc895 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1,15 +1,13 @@
 /*
  *   Driver for KeyStream, KS7010 based SDIO cards.
  *
- *   ks7010_sdio.c
- *   $Id: ks7010_sdio.c 996 2009-09-14 02:54:21Z sekine $
- *
  *   Copyright (C) 2006-2008 KeyStream Corp.
  *   Copyright (C) 2009 Renesas Technology Corp.
+ *   Copyright (C) 2016 Sang Engineering, Wolfram Sang
  *
  *   This program is free software; you can redistribute it and/or modify
- *   it undr the terms of the GNU General Public License version 2 as
- *   published by the Free Sotware Foundation.
+ *   it under the terms of the GNU General Public License version 2 as
+ *   published by the Free Software Foundation.
  */
 
 #include <linux/workqueue.h>

commit 9adca34b7eea096db6757ee7263fbc002e64c5eb
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:42 2016 +0200

    staging: ks7010: drop counting sd errors
    
    They were counted but never really used anywhere. Also change the printk
    to a debug print, since it mostly shows on the expected -ENOMEDIUM on
    card removal.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index a8a14f928d42..c166022b652e 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -234,8 +234,8 @@ int ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
 			    unsigned char *buffer, int length)
 {
-	int rc = -1;
 	struct ks_sdio_card *card;
+	int rc;
 
 	card = priv->ks_wlan_hw.sdio_card;
 
@@ -244,12 +244,8 @@ static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
 	else	/* CMD53 multi-block transfer */
 		rc = sdio_memcpy_fromio(card->func, buffer, address, length);
 
-	if (rc != 0) {
-		printk("sdio error erorr=%d size=%d\n", rc, length);
-		++priv->sdio_error_count;
-	} else {
-		priv->sdio_error_count = 0;
-	}
+	if (rc != 0)
+		DPRINTK(1, "sdio error=%d size=%d\n", rc, length);
 
 	return rc;
 }
@@ -257,8 +253,8 @@ static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
 static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
 			     unsigned char *buffer, int length)
 {
-	int rc = -1;
 	struct ks_sdio_card *card;
+	int rc;
 
 	card = priv->ks_wlan_hw.sdio_card;
 
@@ -268,12 +264,8 @@ static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
 		rc = sdio_memcpy_toio(card->func, (unsigned int)address, buffer,
 				      length);
 
-	if (rc != 0) {
-		printk("sdio error erorr=%d size=%d\n", rc, length);
-		++priv->sdio_error_count;
-	} else {
-		priv->sdio_error_count = 0;
-	}
+	if (rc != 0)
+		DPRINTK(1, "sdio error=%d size=%d\n", rc, length);
 
 	return rc;
 }

commit 6b0cb0b02ec8c03a16d1bdff4ae79b27874138e1
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:41 2016 +0200

    staging: ks7010: simplify module_init/exit
    
    The printouts are not needed, the driver core has enough debug output
    for this if wanted. So, use a helper to save boilerplate code.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 8c0d1bb58dcd..a8a14f928d42 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1237,30 +1237,7 @@ static void ks7910_sdio_remove(struct sdio_func *func)
 	return;
 }
 
-static int __init ks7010_sdio_init(void)
-{
-	int status;
-
-	/* register with bus driver core */
-	status = sdio_register_driver(&ks7010_sdio_driver);
-	if (status != 0) {
-		DPRINTK(1,
-			"ks79xx_sdio : failed to register with bus driver, %d\n",
-			status);
-	}
-	return status;
-}
-
-static void __exit ks7010_sdio_exit(void)
-{
-	DPRINTK(5, " \n");
-	sdio_unregister_driver(&ks7010_sdio_driver);
-	return;
-}
-
-module_init(ks7010_sdio_init);
-module_exit(ks7010_sdio_exit);
-
+module_driver(ks7010_sdio_driver, sdio_register_driver, sdio_unregister_driver);
 MODULE_AUTHOR("Sang Engineering, Qi-Hardware, KeyStream");
 MODULE_DESCRIPTION("Driver for KeyStream KS7010 based SDIO cards");
 MODULE_LICENSE("GPL v2");

commit e1240140f9e9a749eb938e7a6866355a6ed1b8d1
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:39 2016 +0200

    staging: ks7010: fix module annotations
    
    List all authors, beautify description, match license to what is stated
    in file headers, add firmware information.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 8e8476b52ced..8c0d1bb58dcd 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -1261,9 +1261,7 @@ static void __exit ks7010_sdio_exit(void)
 module_init(ks7010_sdio_init);
 module_exit(ks7010_sdio_exit);
 
-MODULE_AUTHOR("Qi-Hardware based on KeyStream driver");
-MODULE_DESCRIPTION("Driver for KeyStream, KS7010 based SDIO cards. ");
-#ifdef MODULE_LICENSE
-MODULE_LICENSE("GPL");
-#endif
-MODULE_SUPPORTED_DEVICE("KS7910");
+MODULE_AUTHOR("Sang Engineering, Qi-Hardware, KeyStream");
+MODULE_DESCRIPTION("Driver for KeyStream KS7010 based SDIO cards");
+MODULE_LICENSE("GPL v2");
+MODULE_FIRMWARE(ROM_FILE);

commit 2801d7a289bd435ae4920a792c5497a6450686ef
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:38 2016 +0200

    staging: ks7010: remove supported card table with one element
    
    There is only this card supported, no need to iterate over the table.
    The resulting firmware filename wasn't used anyway, but came from the
    config file or hardcoded default.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index ed4d579300ad..8e8476b52ced 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -35,19 +35,6 @@ static const struct sdio_device_id if_sdio_ids[] = {
 	{ /* all zero */ }
 };
 
-struct ks_sdio_model {
-	int model;
-	const char *firmware;
-};
-
-static struct ks_sdio_model ks_sdio_models[] = {
-	{
-		/* ks7010 */
-		.model = 0x10,
-		.firmware = "ks7010sd.rom",
-	},
-};
-
 static int ks7910_sdio_probe(struct sdio_func *function,
 			     const struct sdio_device_id *device);
 static void ks7910_sdio_remove(struct sdio_func *function);
@@ -996,7 +983,7 @@ static int ks7910_sdio_probe(struct sdio_func *func,
 	struct ks_sdio_card *card;
 	struct net_device *netdev;
 	unsigned char rw_data;
-	int i = 0, ret;
+	int ret;
 
 	DPRINTK(5, "ks7910_sdio_probe()\n");
 
@@ -1009,22 +996,8 @@ static int ks7910_sdio_probe(struct sdio_func *func,
 		return -ENOMEM;
 
 	card->func = func;
-	card->model = 0x10;
 	spin_lock_init(&card->lock);
 
-	/* select model */
-	for (i = 0; i < ARRAY_SIZE(ks_sdio_models); i++) {
-		if (card->model == ks_sdio_models[i].model)
-			break;
-	}
-
-	if (i == ARRAY_SIZE(ks_sdio_models)) {
-		DPRINTK(5, "unkown card model 0x%x\n", card->model);
-		goto error;
-	}
-
-	card->firmware = ks_sdio_models[i].firmware;
-
 	/*** Initialize  SDIO ***/
 	sdio_claim_host(func);
 
@@ -1172,7 +1145,7 @@ static int ks7910_sdio_probe(struct sdio_func *func,
 	sdio_release_host(func);
 	sdio_set_drvdata(func, NULL);
 	kfree(card);
- error:
+
 	return -ENODEV;
 }
 

commit cdf6ecc5eed103190f1df9cdd09659ef2cc7d23a
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:37 2016 +0200

    staging: ks7010: indent ks7010_sdio.c
    
    Unlike the previous patches which are plain indent outcomes, this has
    some manual fixups to be not overly strict with the 80 char limit.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index fb9f0b533d86..ed4d579300ad 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -30,31 +30,32 @@
 static int reg_net = 0;
 
 static const struct sdio_device_id if_sdio_ids[] = {
-	{ SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_A, SDIO_DEVICE_ID_KS_7010) },
-	{ SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_B, SDIO_DEVICE_ID_KS_7010) },
+	{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_A, SDIO_DEVICE_ID_KS_7010)},
+	{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_B, SDIO_DEVICE_ID_KS_7010)},
 	{ /* all zero */ }
 };
 
 struct ks_sdio_model {
-        int model;
-        const char *firmware;
+	int model;
+	const char *firmware;
 };
 
 static struct ks_sdio_model ks_sdio_models[] = {
-        {
-                /* ks7010 */
-                .model = 0x10,
-                .firmware = "ks7010sd.rom",
-        },
+	{
+		/* ks7010 */
+		.model = 0x10,
+		.firmware = "ks7010sd.rom",
+	},
 };
 
-static int ks7910_sdio_probe(struct sdio_func *function, const struct sdio_device_id *device);
+static int ks7910_sdio_probe(struct sdio_func *function,
+			     const struct sdio_device_id *device);
 static void ks7910_sdio_remove(struct sdio_func *function);
 static void ks7010_rw_function(struct work_struct *work);
-static int ks7010_sdio_read( struct ks_wlan_private *priv, unsigned int address,
-			     unsigned char *buffer, int length );
-static int ks7010_sdio_write( struct ks_wlan_private *priv, unsigned int address,
-			      unsigned char *buffer, int length );
+static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
+			    unsigned char *buffer, int length);
+static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
+			     unsigned char *buffer, int length);
 /* macro */
 
 #define inc_txqhead(priv) \
@@ -79,25 +80,25 @@ void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 	DPRINTK(4, "\n");
 
 	/* clear request */
-	atomic_set(&priv->sleepstatus.doze_request,0);
+	atomic_set(&priv->sleepstatus.doze_request, 0);
 
-	if( atomic_read(&priv->sleepstatus.status) == 0){
+	if (atomic_read(&priv->sleepstatus.status) == 0) {
 		rw_data = GCR_B_DOZE;
-		retval = ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
-		if(retval){
+		retval =
+		    ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
+		if (retval) {
 			DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
 			goto out;
 		}
 		DPRINTK(4, "PMG SET!! : GCR_B=%02X\n", rw_data);
-		DPRINTK(3,"sleep_mode=SLP_SLEEP\n");
+		DPRINTK(3, "sleep_mode=SLP_SLEEP\n");
 		atomic_set(&priv->sleepstatus.status, 1);
- 		priv->last_doze = jiffies;
-	}
-	else{
-		DPRINTK(1,"sleep_mode=%d\n",priv->sleep_mode);
+		priv->last_doze = jiffies;
+	} else {
+		DPRINTK(1, "sleep_mode=%d\n", priv->sleep_mode);
 	}
 
-out:
+ out:
 	priv->sleep_mode = atomic_read(&priv->sleepstatus.status);
 	return;
 }
@@ -110,110 +111,126 @@ void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 	DPRINTK(4, "\n");
 
 	/* clear request */
-	atomic_set(&priv->sleepstatus.wakeup_request,0);
+	atomic_set(&priv->sleepstatus.wakeup_request, 0);
 
-	if( atomic_read(&priv->sleepstatus.status) == 1){
+	if (atomic_read(&priv->sleepstatus.status) == 1) {
 		rw_data = WAKEUP_REQ;
-		retval = ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
-		if(retval){
+		retval =
+		    ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
+		if (retval) {
 			DPRINTK(1, " error : WAKEUP=%02X\n", rw_data);
 			goto out;
 		}
 		DPRINTK(4, "wake up : WAKEUP=%02X\n", rw_data);
 		atomic_set(&priv->sleepstatus.status, 0);
- 		priv->last_wakeup = jiffies;
+		priv->last_wakeup = jiffies;
 		++priv->wakeup_count;
-	}
-	else{
-		DPRINTK(1,"sleep_mode=%d\n",priv->sleep_mode);
+	} else {
+		DPRINTK(1, "sleep_mode=%d\n", priv->sleep_mode);
 	}
 
-out:
+ out:
 	priv->sleep_mode = atomic_read(&priv->sleepstatus.status);
 	return;
 }
 
-
 void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
 	int retval;
 
 	DPRINTK(4, "\n");
-	if(atomic_read(&priv->psstatus.status)==PS_SNOOZE){
+	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
 		rw_data = WAKEUP_REQ;
-		retval = ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
-		if(retval){
+		retval =
+		    ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
+		if (retval) {
 			DPRINTK(1, " error : WAKEUP=%02X\n", rw_data);
 		}
 		DPRINTK(4, "wake up : WAKEUP=%02X\n", rw_data);
- 		priv->last_wakeup = jiffies;
+		priv->last_wakeup = jiffies;
 		++priv->wakeup_count;
-	}
-	else{
-		DPRINTK(1,"psstatus=%d\n",atomic_read(&priv->psstatus.status));
+	} else {
+		DPRINTK(1, "psstatus=%d\n",
+			atomic_read(&priv->psstatus.status));
 	}
 }
 
 int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 {
-	int rc=0;
+	int rc = 0;
 	unsigned char rw_data;
 	int retval;
 
-	if(priv->reg.powermgt == POWMGT_ACTIVE_MODE)
+	if (priv->reg.powermgt == POWMGT_ACTIVE_MODE)
 		return rc;
 
-	if(priv->reg.operation_mode == MODE_INFRASTRUCTURE &&
-	   (priv->connect_status & CONNECT_STATUS_MASK)== CONNECT_STATUS){
+	if (priv->reg.operation_mode == MODE_INFRASTRUCTURE &&
+	    (priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
 
 		//DPRINTK(1,"psstatus.status=%d\n",atomic_read(&priv->psstatus.status));
-	if (priv->dev_state == DEVICE_STATE_SLEEP) {
-		switch(atomic_read(&priv->psstatus.status)){
-		case PS_SNOOZE: /* 4 */
-			break;
-		default:
-			DPRINTK(5,"\n\
-				psstatus.status=%d\n\
-				psstatus.confirm_wait=%d\n\
-				psstatus.snooze_guard=%d\n\
-				cnt_txqbody=%d\n",
-				atomic_read(&priv->psstatus.status),
-				atomic_read(&priv->psstatus.confirm_wait),
-				atomic_read(&priv->psstatus.snooze_guard),
-				cnt_txqbody(priv));
-
-			if(!atomic_read(&priv->psstatus.confirm_wait)&&
-			   !atomic_read(&priv->psstatus.snooze_guard)&&
-			   !cnt_txqbody(priv)){
-				retval = ks7010_sdio_read(priv, INT_PENDING, &rw_data, sizeof(rw_data));
-				if(retval){
-					DPRINTK(1, " error : INT_PENDING=%02X\n", rw_data);
-					queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
-					break;
-				}
-				if(!rw_data){
-					rw_data = GCR_B_DOZE;
-					retval = ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
-					if(retval){
-						DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
-						queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+		if (priv->dev_state == DEVICE_STATE_SLEEP) {
+			switch (atomic_read(&priv->psstatus.status)) {
+			case PS_SNOOZE:	/* 4 */
+				break;
+			default:
+				DPRINTK(5, "\npsstatus.status=%d\npsstatus.confirm_wait=%d\npsstatus.snooze_guard=%d\ncnt_txqbody=%d\n",
+					atomic_read(&priv->psstatus.status),
+					atomic_read(&priv->psstatus.confirm_wait),
+					atomic_read(&priv->psstatus.snooze_guard),
+					cnt_txqbody(priv));
+
+				if (!atomic_read(&priv->psstatus.confirm_wait)
+				    && !atomic_read(&priv->psstatus.snooze_guard)
+				    && !cnt_txqbody(priv)) {
+					retval =
+					    ks7010_sdio_read(priv, INT_PENDING,
+							     &rw_data,
+							     sizeof(rw_data));
+					if (retval) {
+						DPRINTK(1,
+							" error : INT_PENDING=%02X\n",
+							rw_data);
+						queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+								   &priv->ks_wlan_hw.rw_wq, 1);
 						break;
 					}
-					DPRINTK(4, "PMG SET!! : GCR_B=%02X\n", rw_data);
-					atomic_set(&priv->psstatus.status, PS_SNOOZE);
-					DPRINTK(3,"psstatus.status=PS_SNOOZE\n");
-				}
-				else{
-					queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+					if (!rw_data) {
+						rw_data = GCR_B_DOZE;
+						retval =
+						    ks7010_sdio_write(priv,
+								      GCR_B,
+								      &rw_data,
+								      sizeof(rw_data));
+						if (retval) {
+							DPRINTK(1,
+								" error : GCR_B=%02X\n",
+								rw_data);
+							queue_delayed_work
+							    (priv->ks_wlan_hw.ks7010sdio_wq,
+							     &priv->ks_wlan_hw.rw_wq, 1);
+							break;
+						}
+						DPRINTK(4,
+							"PMG SET!! : GCR_B=%02X\n",
+							rw_data);
+						atomic_set(&priv->psstatus.
+							   status, PS_SNOOZE);
+						DPRINTK(3,
+							"psstatus.status=PS_SNOOZE\n");
+					} else {
+						queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+								   &priv->ks_wlan_hw.rw_wq, 1);
+					}
+				} else {
+					queue_delayed_work(priv->ks_wlan_hw.
+							   ks7010sdio_wq,
+							   &priv->ks_wlan_hw.rw_wq,
+							   0);
 				}
+				break;
 			}
-			else{
-				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 0);
-			}
-			break;
 		}
-	}
 
 	}
 
@@ -222,7 +239,8 @@ int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 
 int ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 {
-	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+			   &priv->ks_wlan_hw.rw_wq, 1);
 	return 0;
 }
 
@@ -234,16 +252,16 @@ static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
 
 	card = priv->ks_wlan_hw.sdio_card;
 
-	if (length == 1) /* CMD52 */
+	if (length == 1)	/* CMD52 */
 		*buffer = sdio_readb(card->func, address, &rc);
-	else /* CMD53 multi-block transfer */
+	else	/* CMD53 multi-block transfer */
 		rc = sdio_memcpy_fromio(card->func, buffer, address, length);
 
-	if(rc != 0){
+	if (rc != 0) {
 		printk("sdio error erorr=%d size=%d\n", rc, length);
 		++priv->sdio_error_count;
-	}else{
-		priv->sdio_error_count=0;
+	} else {
+		priv->sdio_error_count = 0;
 	}
 
 	return rc;
@@ -257,40 +275,42 @@ static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
 
 	card = priv->ks_wlan_hw.sdio_card;
 
-	if (length == 1) /* CMD52 */
-		sdio_writeb(card->func, *buffer, (unsigned int) address,  &rc);
-	else 		 /* CMD53 */
-		rc = sdio_memcpy_toio(card->func, (unsigned int) address, buffer, length);
+	if (length == 1)	/* CMD52 */
+		sdio_writeb(card->func, *buffer, (unsigned int)address, &rc);
+	else	/* CMD53 */
+		rc = sdio_memcpy_toio(card->func, (unsigned int)address, buffer,
+				      length);
 
-	if(rc != 0){
+	if (rc != 0) {
 		printk("sdio error erorr=%d size=%d\n", rc, length);
 		++priv->sdio_error_count;
-	}else{
-		priv->sdio_error_count=0;
+	} else {
+		priv->sdio_error_count = 0;
 	}
 
 	return rc;
 }
 
-static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p, unsigned long size,
-		  void (*complete_handler)(void *arg1, void *arg2),
-		  void *arg1, void *arg2 )
+static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,
+			 unsigned long size,
+			 void (*complete_handler) (void *arg1, void *arg2),
+			 void *arg1, void *arg2)
 {
 	struct tx_device_buffer *sp;
 
 	if (priv->dev_state < DEVICE_STATE_BOOT) {
 		kfree(p);
 		if (complete_handler != NULL)
-			(*complete_handler)(arg1, arg2);
+			(*complete_handler) (arg1, arg2);
 		return 1;
 	}
 
-	if ((TX_DEVICE_BUFF_SIZE - 1) <=  cnt_txqbody(priv)) {
+	if ((TX_DEVICE_BUFF_SIZE - 1) <= cnt_txqbody(priv)) {
 		/* in case of buffer overflow */
-		DPRINTK(1,"tx buffer overflow\n");
+		DPRINTK(1, "tx buffer overflow\n");
 		kfree(p);
 		if (complete_handler != NULL)
-			(*complete_handler)(arg1, arg2);
+			(*complete_handler) (arg1, arg2);
 		return 1;
 	}
 
@@ -306,29 +326,31 @@ static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p, unsigne
 }
 
 /* write data */
-static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer, unsigned long size )
+static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
+			   unsigned long size)
 {
-	int rc,retval;
+	int rc, retval;
 	unsigned char rw_data;
 	struct hostif_hdr *hdr;
 	hdr = (struct hostif_hdr *)buffer;
-	rc=0;
+	rc = 0;
 
-	DPRINTK(4,"size=%d\n", hdr->size);
-	if(hdr->event < HIF_DATA_REQ || HIF_REQ_MAX < hdr->event){
-		DPRINTK(1,"unknown event=%04X\n",hdr->event);
+	DPRINTK(4, "size=%d\n", hdr->size);
+	if (hdr->event < HIF_DATA_REQ || HIF_REQ_MAX < hdr->event) {
+		DPRINTK(1, "unknown event=%04X\n", hdr->event);
 		return 0;
 	}
 
 	retval = ks7010_sdio_write(priv, DATA_WINDOW, buffer, size);
-	if(retval){
+	if (retval) {
 		DPRINTK(1, " write error : retval=%d\n", retval);
 		return -4;
 	}
 
 	rw_data = WRITE_STATUS_BUSY;
-	retval = ks7010_sdio_write(priv, WRITE_STATUS, &rw_data, sizeof(rw_data));
-	if(retval){
+	retval =
+	    ks7010_sdio_write(priv, WRITE_STATUS, &rw_data, sizeof(rw_data));
+	if (retval) {
 		DPRINTK(1, " error : WRITE_STATUS=%02X\n", rw_data);
 		return -3;
 	}
@@ -339,74 +361,80 @@ static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer,
 static void tx_device_task(void *dev)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
-	struct tx_device_buffer	*sp;
+	struct tx_device_buffer *sp;
 	int rc = 0;
 
 	DPRINTK(4, "\n");
-	if(cnt_txqbody(priv)>0 && atomic_read(&priv->psstatus.status) != PS_SNOOZE){
+	if (cnt_txqbody(priv) > 0
+	    && atomic_read(&priv->psstatus.status) != PS_SNOOZE) {
 		sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];
-		if(priv->dev_state >= DEVICE_STATE_BOOT){
+		if (priv->dev_state >= DEVICE_STATE_BOOT) {
 			rc = write_to_device(priv, sp->sendp, sp->size);
-			if(rc){
-				DPRINTK(1, "write_to_device error !!(%d)\n", rc);
-				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+			if (rc) {
+				DPRINTK(1, "write_to_device error !!(%d)\n",
+					rc);
+				queue_delayed_work(priv->ks_wlan_hw.
+						   ks7010sdio_wq,
+						   &priv->ks_wlan_hw.rw_wq, 1);
 				return;
 			}
 
 		}
-		kfree(sp->sendp); /* allocated memory free */
-		if(sp->complete_handler != NULL) /* TX Complete */
-			(*sp->complete_handler)(sp->arg1, sp->arg2);
+		kfree(sp->sendp);	/* allocated memory free */
+		if (sp->complete_handler != NULL)	/* TX Complete */
+			(*sp->complete_handler) (sp->arg1, sp->arg2);
 		inc_txqhead(priv);
 
-		if(cnt_txqbody(priv)>0){
-			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 0);
+		if (cnt_txqbody(priv) > 0) {
+			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+					   &priv->ks_wlan_hw.rw_wq, 0);
 		}
 	}
 	return;
 }
 
-int ks_wlan_hw_tx( struct ks_wlan_private *priv, void *p, unsigned long size,
-		   void (*complete_handler)(void *arg1, void *arg2),
-		   void *arg1, void *arg2 )
+int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
+		  void (*complete_handler) (void *arg1, void *arg2),
+		  void *arg1, void *arg2)
 {
-	int result=0;
+	int result = 0;
 	struct hostif_hdr *hdr;
 	hdr = (struct hostif_hdr *)p;
 
-	if(hdr->event < HIF_DATA_REQ || HIF_REQ_MAX < hdr->event){
-		DPRINTK(1,"unknown event=%04X\n",hdr->event);
+	if (hdr->event < HIF_DATA_REQ || HIF_REQ_MAX < hdr->event) {
+		DPRINTK(1, "unknown event=%04X\n", hdr->event);
 		return 0;
 	}
 
 	/* add event to hostt buffer */
 	priv->hostt.buff[priv->hostt.qtail] = hdr->event;
-        priv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;
+	priv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;
 
-	DPRINTK(4, "event=%04X\n",hdr->event);
+	DPRINTK(4, "event=%04X\n", hdr->event);
 	spin_lock(&priv->tx_dev.tx_dev_lock);
 	result = enqueue_txdev(priv, p, size, complete_handler, arg1, arg2);
 	spin_unlock(&priv->tx_dev.tx_dev_lock);
 
-	if(cnt_txqbody(priv)>0){
-		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 0);
+	if (cnt_txqbody(priv) > 0) {
+		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+				   &priv->ks_wlan_hw.rw_wq, 0);
 	}
 	return result;
 }
 
 static void rx_event_task(unsigned long dev)
 {
-        struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
-	struct rx_device_buffer	*rp;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
+	struct rx_device_buffer *rp;
 
-	DPRINTK(4,"\n");
+	DPRINTK(4, "\n");
 
-	if(cnt_rxqbody(priv) > 0 && priv->dev_state >= DEVICE_STATE_BOOT){
+	if (cnt_rxqbody(priv) > 0 && priv->dev_state >= DEVICE_STATE_BOOT) {
 		rp = &priv->rx_dev.rx_dev_buff[priv->rx_dev.qhead];
 		hostif_receive(priv, rp->data, rp->size);
 		inc_rxqhead(priv);
 
-		if(cnt_rxqbody(priv) > 0){
+		if (cnt_rxqbody(priv) > 0) {
 			tasklet_schedule(&priv->ks_wlan_hw.rx_bh_task);
 		}
 	}
@@ -420,35 +448,40 @@ static void ks_wlan_hw_rx(void *dev, uint16_t size)
 	int retval;
 	struct rx_device_buffer *rx_buffer;
 	struct hostif_hdr *hdr;
-	unsigned char	read_status;
-	unsigned short event=0;
+	unsigned char read_status;
+	unsigned short event = 0;
 
-	DPRINTK(4,"\n");
+	DPRINTK(4, "\n");
 
 	/* receive data */
-	if (cnt_rxqbody(priv) >= (RX_DEVICE_BUFF_SIZE-1)) {
+	if (cnt_rxqbody(priv) >= (RX_DEVICE_BUFF_SIZE - 1)) {
 		/* in case of buffer overflow */
-		DPRINTK(1,"rx buffer overflow \n");
+		DPRINTK(1, "rx buffer overflow \n");
 		goto error_out;
 	}
 	rx_buffer = &priv->rx_dev.rx_dev_buff[priv->rx_dev.qtail];
 
-	retval = ks7010_sdio_read(priv, DATA_WINDOW, &rx_buffer->data[0], hif_align_size(size));
-	if(retval){
+	retval =
+	    ks7010_sdio_read(priv, DATA_WINDOW, &rx_buffer->data[0],
+			     hif_align_size(size));
+	if (retval) {
 		goto error_out;
 	}
 
 	/* length check */
-	if(size > 2046 || size == 0){
+	if (size > 2046 || size == 0) {
 #ifdef KS_WLAN_DEBUG
 		if (KS_WLAN_DEBUG > 5)
-			print_hex_dump_bytes("INVALID DATA dump: ", DUMP_PREFIX_OFFSET,
+			print_hex_dump_bytes("INVALID DATA dump: ",
+					     DUMP_PREFIX_OFFSET,
 					     rx_buffer->data, 32);
 #endif
 		/* rx_status update */
 		read_status = READ_STATUS_IDLE;
-		retval = ks7010_sdio_write(priv, READ_STATUS, &read_status, sizeof(read_status));
-		if(retval){
+		retval =
+		    ks7010_sdio_write(priv, READ_STATUS, &read_status,
+				      sizeof(read_status));
+		if (retval) {
 			DPRINTK(1, " error : READ_STATUS=%02X\n", read_status);
 		}
 		goto error_out;
@@ -461,14 +494,16 @@ static void ks_wlan_hw_rx(void *dev, uint16_t size)
 
 	/* read status update */
 	read_status = READ_STATUS_IDLE;
-	retval = ks7010_sdio_write(priv, READ_STATUS, &read_status, sizeof(read_status));
-	if(retval){
+	retval =
+	    ks7010_sdio_write(priv, READ_STATUS, &read_status,
+			      sizeof(read_status));
+	if (retval) {
 		DPRINTK(1, " error : READ_STATUS=%02X\n", read_status);
 	}
 	DPRINTK(4, "READ_STATUS=%02X\n", read_status);
 
-	if(atomic_read(&priv->psstatus.confirm_wait)){
-		if(IS_HIF_CONF(event)){
+	if (atomic_read(&priv->psstatus.confirm_wait)) {
+		if (IS_HIF_CONF(event)) {
 			DPRINTK(4, "IS_HIF_CONF true !!\n");
 			atomic_dec(&priv->psstatus.confirm_wait);
 		}
@@ -477,7 +512,7 @@ static void ks_wlan_hw_rx(void *dev, uint16_t size)
 	/* rx_event_task((void *)priv); */
 	tasklet_schedule(&priv->ks_wlan_hw.rx_bh_task);
 
-error_out:
+ error_out:
 	return;
 }
 
@@ -491,71 +526,74 @@ static void ks7010_rw_function(struct work_struct *work)
 	hw = container_of(work, struct hw_info_t, rw_wq.work);
 	priv = container_of(hw, struct ks_wlan_private, ks_wlan_hw);
 
-	DPRINTK(4,"\n");
-
+	DPRINTK(4, "\n");
 
- 	/* wiat after DOZE */
- 	if(time_after(priv->last_doze + ((30*HZ)/1000), jiffies )){
- 		DPRINTK(4, "wait after DOZE \n");
-		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+	/* wiat after DOZE */
+	if (time_after(priv->last_doze + ((30 * HZ) / 1000), jiffies)) {
+		DPRINTK(4, "wait after DOZE \n");
+		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+				   &priv->ks_wlan_hw.rw_wq, 1);
 		return;
 	}
 
 	/* wiat after WAKEUP */
-	while(time_after(priv->last_wakeup + ((30*HZ)/1000), jiffies )){
+	while (time_after(priv->last_wakeup + ((30 * HZ) / 1000), jiffies)) {
 		DPRINTK(4, "wait after WAKEUP \n");
 /*		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq,
 		(priv->last_wakeup + ((30*HZ)/1000) - jiffies));*/
-		printk("wake: %lu %lu\n", priv->last_wakeup + (30* HZ)/1000, jiffies);
+		printk("wake: %lu %lu\n", priv->last_wakeup + (30 * HZ) / 1000,
+		       jiffies);
 		msleep(30);
 	}
 
 	sdio_claim_host(priv->ks_wlan_hw.sdio_card->func);
 
 	/* power save wakeup */
-	if(atomic_read(&priv->psstatus.status)==PS_SNOOZE){
-		if(cnt_txqbody(priv)>0){
+	if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
+		if (cnt_txqbody(priv) > 0) {
 			ks_wlan_hw_wakeup_request(priv);
-			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+					   &priv->ks_wlan_hw.rw_wq, 1);
 		}
 		goto err_out;
 	}
 
 	/* sleep mode doze */
-	if(atomic_read(&priv->sleepstatus.doze_request)==1){
+	if (atomic_read(&priv->sleepstatus.doze_request) == 1) {
 		ks_wlan_hw_sleep_doze_request(priv);
 		goto err_out;
 	}
 	/* sleep mode wakeup */
-	if(atomic_read(&priv->sleepstatus.wakeup_request)==1){
+	if (atomic_read(&priv->sleepstatus.wakeup_request) == 1) {
 		ks_wlan_hw_sleep_wakeup_request(priv);
 		goto err_out;
 	}
 
 	/* read (WriteStatus/ReadDataSize FN1:00_0014) */
-	retval = ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data, sizeof(rw_data));
-	if(retval){
-		DPRINTK(1, " error : WSTATUS_RSIZE=%02X psstatus=%d\n", rw_data,atomic_read(&priv->psstatus.status));
+	retval =
+	    ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data, sizeof(rw_data));
+	if (retval) {
+		DPRINTK(1, " error : WSTATUS_RSIZE=%02X psstatus=%d\n", rw_data,
+			atomic_read(&priv->psstatus.status));
 		goto err_out;
 	}
 	DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
 
-	if(rw_data&RSIZE_MASK){ /* Read schedule */
-		ks_wlan_hw_rx((void *)priv, (uint16_t)(((rw_data&RSIZE_MASK)<<4)));
+	if (rw_data & RSIZE_MASK) {	/* Read schedule */
+		ks_wlan_hw_rx((void *)priv,
+			      (uint16_t) (((rw_data & RSIZE_MASK) << 4)));
 	}
-	if((rw_data&WSTATUS_MASK)){
+	if ((rw_data & WSTATUS_MASK)) {
 		tx_device_task((void *)priv);
 	}
 	_ks_wlan_hw_power_save(priv);
 
-err_out:
+ err_out:
 	sdio_release_host(priv->ks_wlan_hw.sdio_card->func);
 
 	return;
 }
 
-
-
 static void ks_sdio_interrupt(struct sdio_func *func)
 {
 	int retval;
@@ -567,10 +605,12 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	priv = card->priv;
 	DPRINTK(4, "\n");
 
-	if(priv->dev_state >= DEVICE_STATE_BOOT){
-		retval = ks7010_sdio_read(priv, INT_PENDING, &status, sizeof(status));
-		if(retval){
-			DPRINTK(1, "read INT_PENDING Failed!!(%d)\n",retval);
+	if (priv->dev_state >= DEVICE_STATE_BOOT) {
+		retval =
+		    ks7010_sdio_read(priv, INT_PENDING, &status,
+				     sizeof(status));
+		if (retval) {
+			DPRINTK(1, "read INT_PENDING Failed!!(%d)\n", retval);
 			goto intr_out;
 		}
 		DPRINTK(4, "INT_PENDING=%02X\n", rw_data);
@@ -580,70 +620,89 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 		/* read (General Communication B register) */
 		/* bit5 -> Write Status Idle */
 		/* bit2 -> Read Status Busy  */
-		if(status&INT_GCR_B || atomic_read(&priv->psstatus.status)==PS_SNOOZE){
-			retval = ks7010_sdio_read(priv, GCR_B, &rw_data, sizeof(rw_data));
-			if(retval){
+		if (status & INT_GCR_B
+		    || atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
+			retval =
+			    ks7010_sdio_read(priv, GCR_B, &rw_data,
+					     sizeof(rw_data));
+			if (retval) {
 				DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
 				goto intr_out;
 			}
 			/* DPRINTK(1, "GCR_B=%02X\n", rw_data); */
-			if(rw_data == GCR_B_ACTIVE){
-				if(atomic_read(&priv->psstatus.status)==PS_SNOOZE){
-					atomic_set(&priv->psstatus.status, PS_WAKEUP);
-					priv->wakeup_count=0;
+			if (rw_data == GCR_B_ACTIVE) {
+				if (atomic_read(&priv->psstatus.status) ==
+				    PS_SNOOZE) {
+					atomic_set(&priv->psstatus.status,
+						   PS_WAKEUP);
+					priv->wakeup_count = 0;
 				}
 				complete(&priv->psstatus.wakeup_wait);
 			}
 
-
 		}
 
-		do{
+		do {
 			/* read (WriteStatus/ReadDataSize FN1:00_0014) */
-			retval = ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data, sizeof(rw_data));
-			if(retval){
-				DPRINTK(1, " error : WSTATUS_RSIZE=%02X\n", rw_data);
+			retval =
+			    ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data,
+					     sizeof(rw_data));
+			if (retval) {
+				DPRINTK(1, " error : WSTATUS_RSIZE=%02X\n",
+					rw_data);
 				goto intr_out;
 			}
 			DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
-			rsize=rw_data&RSIZE_MASK;
-			if(rsize){ /* Read schedule */
-				ks_wlan_hw_rx((void *)priv, (uint16_t)(((rsize)<<4)));
+			rsize = rw_data & RSIZE_MASK;
+			if (rsize) {	/* Read schedule */
+				ks_wlan_hw_rx((void *)priv,
+					      (uint16_t) (((rsize) << 4)));
 			}
-			if(rw_data&WSTATUS_MASK){
+			if (rw_data & WSTATUS_MASK) {
 #if 0
-				if(status&INT_WRITE_STATUS && !cnt_txqbody(priv)){
+				if (status & INT_WRITE_STATUS
+				    && !cnt_txqbody(priv)) {
 					/* dummy write for interrupt clear */
-					rw_data =0;
-					retval = ks7010_sdio_write(priv, DATA_WINDOW, &rw_data, sizeof(rw_data));
+					rw_data = 0;
+					retval =
+					    ks7010_sdio_write(priv, DATA_WINDOW,
+							      &rw_data,
+							      sizeof(rw_data));
 					if (retval) {
-						DPRINTK(1, "write DATA_WINDOW Failed!!(%d)\n",retval);
+						DPRINTK(1,
+							"write DATA_WINDOW Failed!!(%d)\n",
+							retval);
 					}
 					status &= ~INT_WRITE_STATUS;
-				}
-				else{
+				} else {
 #endif
-					if(atomic_read(&priv->psstatus.status)==PS_SNOOZE){
-						if(cnt_txqbody(priv)){
+					if (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {
+						if (cnt_txqbody(priv)) {
 							ks_wlan_hw_wakeup_request(priv);
-							queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq, &priv->ks_wlan_hw.rw_wq, 1);
+							queue_delayed_work
+							    (priv->ks_wlan_hw.
+							     ks7010sdio_wq,
+							     &priv->ks_wlan_hw.
+							     rw_wq, 1);
 							return;
 						}
-					}
-					else{
+					} else {
 						tx_device_task((void *)priv);
 					}
-//				}
+#if 0
+				}
+#endif
 			}
-		}while(rsize);
+		} while (rsize);
 	}
 
-intr_out:
-	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 0);
+ intr_out:
+	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,
+			   &priv->ks_wlan_hw.rw_wq, 0);
 	return;
 }
 
-static int trx_device_init( struct ks_wlan_private *priv )
+static int trx_device_init(struct ks_wlan_private *priv)
 {
 	/* initialize values (tx) */
 	priv->tx_dev.qtail = priv->tx_dev.qhead = 0;
@@ -655,21 +714,22 @@ static int trx_device_init( struct ks_wlan_private *priv )
 	spin_lock_init(&priv->tx_dev.tx_dev_lock);
 	spin_lock_init(&priv->rx_dev.rx_dev_lock);
 
-	tasklet_init(&priv->ks_wlan_hw.rx_bh_task, rx_event_task, (unsigned long)priv);
+	tasklet_init(&priv->ks_wlan_hw.rx_bh_task, rx_event_task,
+		     (unsigned long)priv);
 
 	return 0;
 }
 
-static void trx_device_exit( struct ks_wlan_private *priv )
+static void trx_device_exit(struct ks_wlan_private *priv)
 {
-	struct tx_device_buffer	*sp;
+	struct tx_device_buffer *sp;
 
 	/* tx buffer clear */
-	while (cnt_txqbody(priv)>0) {
+	while (cnt_txqbody(priv) > 0) {
 		sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];
-		kfree(sp->sendp); /* allocated memory free */
-		if (sp->complete_handler != NULL) /* TX Complete */
-			(*sp->complete_handler)(sp->arg1, sp->arg2);
+		kfree(sp->sendp);	/* allocated memory free */
+		if (sp->complete_handler != NULL)	/* TX Complete */
+			(*sp->complete_handler) (sp->arg1, sp->arg2);
 		inc_txqhead(priv);
 	}
 
@@ -677,24 +737,35 @@ static void trx_device_exit( struct ks_wlan_private *priv )
 
 	return;
 }
+
 static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 {
-	int rc=0;
+	int rc = 0;
 	int retval;
 	unsigned char *data_buf;
 	data_buf = NULL;
 
 	data_buf = kmalloc(sizeof(u32), GFP_KERNEL);
-	if(!data_buf){ rc = 1; goto error_out; }
+	if (!data_buf) {
+		rc = 1;
+		goto error_out;
+	}
 
 	memcpy(data_buf, &index, sizeof(index));
 	retval = ks7010_sdio_write(priv, WRITE_INDEX, data_buf, sizeof(index));
-	if(retval){ rc = 2; goto error_out; }
+	if (retval) {
+		rc = 2;
+		goto error_out;
+	}
 
 	retval = ks7010_sdio_write(priv, READ_INDEX, data_buf, sizeof(index));
-	if(retval){ rc = 3; goto error_out; }
-error_out:
-	if(data_buf) kfree(data_buf);
+	if (retval) {
+		rc = 3;
+		goto error_out;
+	}
+ error_out:
+	if (data_buf)
+		kfree(data_buf);
 	return rc;
 }
 
@@ -702,30 +773,41 @@ static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 				    unsigned char *data, unsigned int size)
 {
-	int rc=0;
+	int rc = 0;
 	int retval;
 	unsigned char *read_buf;
 	read_buf = NULL;
 	read_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
-	if(!read_buf){ rc = 1; goto error_out; }
+	if (!read_buf) {
+		rc = 1;
+		goto error_out;
+	}
 	retval = ks7010_sdio_read(priv, address, read_buf, size);
-	if(retval){ rc = 2; goto error_out; }
+	if (retval) {
+		rc = 2;
+		goto error_out;
+	}
 	retval = memcmp(data, read_buf, size);
 
-	if(retval){
-		DPRINTK(0, "data compare error (%d) \n",retval); rc = 3; goto error_out;
+	if (retval) {
+		DPRINTK(0, "data compare error (%d) \n", retval);
+		rc = 3;
+		goto error_out;
 	}
-error_out:
-	if(read_buf) kfree(read_buf);
+ error_out:
+	if (read_buf)
+		kfree(read_buf);
 	return rc;
 }
+
 #include <linux/firmware.h>
-static int ks79xx_upload_firmware(struct ks_wlan_private *priv, struct ks_sdio_card *card)
+static int ks79xx_upload_firmware(struct ks_wlan_private *priv,
+				  struct ks_sdio_card *card)
 {
-	unsigned int	size, offset,  n = 0;
-	unsigned char	*rom_buf;
-	unsigned char rw_data =0;
-	int retval, rc=0;
+	unsigned int size, offset, n = 0;
+	unsigned char *rom_buf;
+	unsigned char rw_data = 0;
+	int retval, rc = 0;
 	int length;
 	const struct firmware *fw_entry = NULL;
 
@@ -733,76 +815,99 @@ static int ks79xx_upload_firmware(struct ks_wlan_private *priv, struct ks_sdio_c
 
 	/* buffer allocate */
 	rom_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
-	if(!rom_buf){ rc = 3; goto error_out0; }
-
+	if (!rom_buf) {
+		rc = 3;
+		goto error_out0;
+	}
 
 	sdio_claim_host(card->func);
 
 	/* Firmware running ? */
 	retval = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
-	if(rw_data == GCR_A_RUN){
-		DPRINTK( 0, "MAC firmware running ...\n");
+	if (rw_data == GCR_A_RUN) {
+		DPRINTK(0, "MAC firmware running ...\n");
 		rc = 0;
 		goto error_out0;
 	}
 
-	if(request_firmware(&fw_entry, priv->reg.rom_file, &priv->ks_wlan_hw.sdio_card->func->dev)!=0){
-		DPRINTK(1,"error request_firmware() file=%s\n", priv->reg.rom_file);
+	if (request_firmware
+	    (&fw_entry, priv->reg.rom_file,
+	     &priv->ks_wlan_hw.sdio_card->func->dev) != 0) {
+		DPRINTK(1, "error request_firmware() file=%s\n",
+			priv->reg.rom_file);
 		return 1;
 	}
-	DPRINTK(4,"success request_firmware() file=%s size=%zu\n", priv->reg.rom_file, fw_entry->size);
+	DPRINTK(4, "success request_firmware() file=%s size=%zu\n",
+		priv->reg.rom_file, fw_entry->size);
 	length = fw_entry->size;
 
 	/* Load Program */
 	n = 0;
-        do {
-		if(length >= ROM_BUFF_SIZE){
+	do {
+		if (length >= ROM_BUFF_SIZE) {
 			size = ROM_BUFF_SIZE;
 			length = length - ROM_BUFF_SIZE;
+		} else {
+			size = length;
+			length = 0;
 		}
-		else{
-			size=length;
-			length=0;
-		}
-		DPRINTK(4, "size = %d\n",size);
-		if(size == 0) break;
-		memcpy(rom_buf,fw_entry->data+n,size);
+		DPRINTK(4, "size = %d\n", size);
+		if (size == 0)
+			break;
+		memcpy(rom_buf, fw_entry->data + n, size);
 		/* Update write index */
 		offset = n;
-		retval = ks7010_sdio_update_index(priv, KS7010_IRAM_ADDRESS+offset);
-		if(retval){ rc = 6; goto error_out1; }
+		retval =
+		    ks7010_sdio_update_index(priv,
+					     KS7010_IRAM_ADDRESS + offset);
+		if (retval) {
+			rc = 6;
+			goto error_out1;
+		}
 
 		/* Write data */
 		retval = ks7010_sdio_write(priv, DATA_WINDOW, rom_buf, size);
-		if(retval){ rc = 8; goto error_out1; }
+		if (retval) {
+			rc = 8;
+			goto error_out1;
+		}
 
 		/* compare */
-		retval = ks7010_sdio_data_compare(priv, DATA_WINDOW, rom_buf, size);
-		if(retval){ rc = 9; goto error_out1; }
+		retval =
+		    ks7010_sdio_data_compare(priv, DATA_WINDOW, rom_buf, size);
+		if (retval) {
+			rc = 9;
+			goto error_out1;
+		}
 		n += size;
 
-       }while(size);
+	} while (size);
 
 	/* Remap request */
 	rw_data = GCR_A_REMAP;
 	retval = ks7010_sdio_write(priv, GCR_A, &rw_data, sizeof(rw_data));
-	if(retval){
+	if (retval) {
 		rc = 11;
 		goto error_out1;
 	}
-	DPRINTK( 4, " REMAP Request : GCR_A=%02X\n", rw_data);
+	DPRINTK(4, " REMAP Request : GCR_A=%02X\n", rw_data);
 
 	/* Firmware running check */
 	for (n = 0; n < 50; ++n) {
-		mdelay(10);/* wait_ms(10); */
-		retval = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
-		if(retval){ rc = 11; goto error_out1; }
-		if(rw_data == GCR_A_RUN) break;
+		mdelay(10);	/* wait_ms(10); */
+		retval =
+		    ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
+		if (retval) {
+			rc = 11;
+			goto error_out1;
+		}
+		if (rw_data == GCR_A_RUN)
+			break;
 	}
-	DPRINTK(4, "firmware wakeup (%d)!!!!\n",n);
+	DPRINTK(4, "firmware wakeup (%d)!!!!\n", n);
 	if ((50) <= n) {
 		DPRINTK(1, "firmware can't start\n");
-                rc = 12;
+		rc = 12;
 		goto error_out1;
 	}
 
@@ -812,30 +917,31 @@ static int ks79xx_upload_firmware(struct ks_wlan_private *priv, struct ks_sdio_c
 	release_firmware(fw_entry);
  error_out0:
 	sdio_release_host(card->func);
-	if(rom_buf)
+	if (rom_buf)
 		kfree(rom_buf);
 	return rc;
 }
 
 static void ks7010_card_init(struct ks_wlan_private *priv)
 {
-	DPRINTK(5,"\ncard_init_task()\n");
+	DPRINTK(5, "\ncard_init_task()\n");
 
 	/* init_waitqueue_head(&priv->confirm_wait); */
 	init_completion(&priv->confirm_wait);
 
-	DPRINTK(5,"init_completion()\n");
+	DPRINTK(5, "init_completion()\n");
 
 	/* get mac address & firmware version */
 	hostif_sme_enqueue(priv, SME_START);
 
-	DPRINTK(5,"hostif_sme_enqueu()\n");
+	DPRINTK(5, "hostif_sme_enqueu()\n");
 
-	if(!wait_for_completion_interruptible_timeout(&priv->confirm_wait,5*HZ)){
-		DPRINTK(1,"wait time out!! SME_START\n");
+	if (!wait_for_completion_interruptible_timeout
+	    (&priv->confirm_wait, 5 * HZ)) {
+		DPRINTK(1, "wait time out!! SME_START\n");
 	}
 
-	if(priv->mac_address_valid && priv->version_size){
+	if (priv->mac_address_valid && priv->version_size) {
 		priv->dev_state = DEVICE_STATE_PREINIT;
 	}
 
@@ -858,57 +964,56 @@ static void ks7010_card_init(struct ks_wlan_private *priv)
 	hostif_sme_enqueue(priv, SME_MODE_SET_REQUEST);
 	hostif_sme_enqueue(priv, SME_START_REQUEST);
 
-	if(!wait_for_completion_interruptible_timeout(&priv->confirm_wait,5*HZ)){
-		DPRINTK(1,"wait time out!! wireless parameter set\n");
+	if (!wait_for_completion_interruptible_timeout
+	    (&priv->confirm_wait, 5 * HZ)) {
+		DPRINTK(1, "wait time out!! wireless parameter set\n");
 	}
 
-	if(priv->dev_state >= DEVICE_STATE_PREINIT){
+	if (priv->dev_state >= DEVICE_STATE_PREINIT) {
 		DPRINTK(1, "DEVICE READY!!\n");
 		priv->dev_state = DEVICE_STATE_READY;
-		reg_net = register_netdev (priv->net_dev);
-		DPRINTK(3, "register_netdev=%d\n",reg_net);
-	}
-	else {
-		DPRINTK(1, "dev_state=%d\n",priv->dev_state);
+		reg_net = register_netdev(priv->net_dev);
+		DPRINTK(3, "register_netdev=%d\n", reg_net);
+	} else {
+		DPRINTK(1, "dev_state=%d\n", priv->dev_state);
 	}
 }
 
 static struct sdio_driver ks7010_sdio_driver = {
-	.name		= "ks7910_sdio",
-	.id_table	= if_sdio_ids,
-	.probe		= ks7910_sdio_probe,
-	.remove		= ks7910_sdio_remove,
+	.name = "ks7910_sdio",
+	.id_table = if_sdio_ids,
+	.probe = ks7910_sdio_probe,
+	.remove = ks7910_sdio_remove,
 };
 
-
 extern int ks_wlan_net_start(struct net_device *dev);
 extern int ks_wlan_net_stop(struct net_device *dev);
 
-static int ks7910_sdio_probe(struct sdio_func *func, const struct sdio_device_id *device)
+static int ks7910_sdio_probe(struct sdio_func *func,
+			     const struct sdio_device_id *device)
 {
 	struct ks_wlan_private *priv;
 	struct ks_sdio_card *card;
 	struct net_device *netdev;
 	unsigned char rw_data;
-	int i=0, ret;
+	int i = 0, ret;
 
 	DPRINTK(5, "ks7910_sdio_probe()\n");
 
 	priv = NULL;
-	netdev=NULL;
-
+	netdev = NULL;
 
 	/* initilize ks_sdio_card */
 	card = kzalloc(sizeof(struct ks_sdio_card), GFP_KERNEL);
 	if (!card)
 		return -ENOMEM;
 
-	card->func  = func;
+	card->func = func;
 	card->model = 0x10;
 	spin_lock_init(&card->lock);
 
 	/* select model */
-	for (i = 0;i < ARRAY_SIZE(ks_sdio_models);i++) {
+	for (i = 0; i < ARRAY_SIZE(ks_sdio_models); i++) {
 		if (card->model == ks_sdio_models[i].model)
 			break;
 	}
@@ -920,7 +1025,6 @@ static int ks7910_sdio_probe(struct sdio_func *func, const struct sdio_device_id
 
 	card->firmware = ks_sdio_models[i].firmware;
 
-
 	/*** Initialize  SDIO ***/
 	sdio_claim_host(func);
 
@@ -929,7 +1033,8 @@ static int ks7910_sdio_probe(struct sdio_func *func, const struct sdio_device_id
 
 	/* function blocksize set */
 	ret = sdio_set_block_size(func, KS7010_IO_BLOCK_SIZE);
-	DPRINTK(5, "multi_block=%d sdio_set_block_size()=%d %d\n", func->card->cccr.multi_block, func->cur_blksize,  ret);
+	DPRINTK(5, "multi_block=%d sdio_set_block_size()=%d %d\n",
+		func->card->cccr.multi_block, func->cur_blksize, ret);
 
 	/* Allocate the slot current */
 
@@ -940,10 +1045,10 @@ static int ks7910_sdio_probe(struct sdio_func *func, const struct sdio_device_id
 		goto error_free_card;
 
 	/* interrupt disable */
-	sdio_writeb(func, 0, INT_ENABLE,  &ret);
+	sdio_writeb(func, 0, INT_ENABLE, &ret);
 	if (ret)
 		goto error_free_card;
-	sdio_writeb(func, 0xff, INT_PENDING,  &ret);
+	sdio_writeb(func, 0xff, INT_PENDING, &ret);
 	if (ret)
 		goto error_disable_func;
 
@@ -957,18 +1062,16 @@ static int ks7910_sdio_probe(struct sdio_func *func, const struct sdio_device_id
 	sdio_set_drvdata(func, card);
 
 	DPRINTK(5, "class = 0x%X, vendor = 0x%X, "
-		"device = 0x%X\n",
-		func->class, func->vendor, func->device);
-
+		"device = 0x%X\n", func->class, func->vendor, func->device);
 
 	/* private memory allocate */
 	netdev = alloc_etherdev(sizeof(*priv));
 	if (netdev == NULL) {
-		printk (KERN_ERR "ks79xx : Unable to alloc new net device\n");
+		printk(KERN_ERR "ks79xx : Unable to alloc new net device\n");
 		goto error_release_irq;
 	}
 	if (dev_alloc_name(netdev, netdev->name) < 0) {
-		printk (KERN_ERR "ks79xx :  Couldn't get name!\n");
+		printk(KERN_ERR "ks79xx :  Couldn't get name!\n");
 		goto error_free_netdev;
 	}
 
@@ -982,7 +1085,7 @@ static int ks7910_sdio_probe(struct sdio_func *func, const struct sdio_device_id
 	init_completion(&priv->ks_wlan_hw.ks7010_sdio_wait);
 	priv->ks_wlan_hw.read_buf = NULL;
 	priv->ks_wlan_hw.read_buf = kmalloc(RX_DATA_SIZE, GFP_KERNEL);
-	if(!priv->ks_wlan_hw.read_buf){
+	if (!priv->ks_wlan_hw.read_buf) {
 		goto error_free_netdev;
 	}
 	priv->dev_state = DEVICE_STATE_PREBOOT;
@@ -995,25 +1098,29 @@ static int ks7910_sdio_probe(struct sdio_func *func, const struct sdio_device_id
 	memset(&priv->wstats, 0, sizeof(priv->wstats));
 
 	/* sleep mode */
-	atomic_set(&priv->sleepstatus.doze_request,0);
-	atomic_set(&priv->sleepstatus.wakeup_request,0);
-	atomic_set(&priv->sleepstatus.wakeup_request,0);
+	atomic_set(&priv->sleepstatus.doze_request, 0);
+	atomic_set(&priv->sleepstatus.wakeup_request, 0);
+	atomic_set(&priv->sleepstatus.wakeup_request, 0);
 
 	trx_device_init(priv);
 	hostif_init(priv);
-        ks_wlan_net_start(netdev);
+	ks_wlan_net_start(netdev);
 
 	/* Read config file */
 	ret = ks_wlan_read_config_file(priv);
 	if (ret) {
-		printk(KERN_ERR "ks79xx: read configuration file failed !! retern code = %d\n", ret);
+		printk(KERN_ERR
+		       "ks79xx: read configuration file failed !! retern code = %d\n",
+		       ret);
 		goto error_free_read_buf;
 	}
 
 	/* Upload firmware */
-	ret = ks79xx_upload_firmware(priv, card); /* firmware load */
-	if(ret){
-		printk(KERN_ERR "ks79xx: firmware load failed !! retern code = %d\n", ret);
+	ret = ks79xx_upload_firmware(priv, card);	/* firmware load */
+	if (ret) {
+		printk(KERN_ERR
+		       "ks79xx: firmware load failed !! retern code = %d\n",
+		       ret);
 		goto error_free_read_buf;
 	}
 
@@ -1023,25 +1130,24 @@ static int ks7910_sdio_probe(struct sdio_func *func, const struct sdio_device_id
 	sdio_claim_host(func);
 	ret = ks7010_sdio_write(priv, INT_PENDING, &rw_data, sizeof(rw_data));
 	sdio_release_host(func);
-	if(ret){
+	if (ret) {
 		DPRINTK(1, " error : INT_PENDING=%02X\n", rw_data);
 	}
 	DPRINTK(4, " clear Interrupt : INT_PENDING=%02X\n", rw_data);
 
-
 	/* enable ks7010sdio interrupt (INT_GCR_B|INT_READ_STATUS|INT_WRITE_STATUS) */
-	rw_data = (INT_GCR_B|INT_READ_STATUS|INT_WRITE_STATUS);
+	rw_data = (INT_GCR_B | INT_READ_STATUS | INT_WRITE_STATUS);
 	sdio_claim_host(func);
 	ret = ks7010_sdio_write(priv, INT_ENABLE, &rw_data, sizeof(rw_data));
 	sdio_release_host(func);
-	if(ret){
+	if (ret) {
 		DPRINTK(1, " error : INT_ENABLE=%02X\n", rw_data);
 	}
 	DPRINTK(4, " enable Interrupt : INT_ENABLE=%02X\n", rw_data);
 	priv->dev_state = DEVICE_STATE_BOOT;
 
 	priv->ks_wlan_hw.ks7010sdio_wq = create_workqueue("ks7010sdio_wq");
-	if(!priv->ks_wlan_hw.ks7010sdio_wq){
+	if (!priv->ks_wlan_hw.ks7010sdio_wq) {
 		DPRINTK(1, "create_workqueue failed !!\n");
 		goto error_free_read_buf;
 	}
@@ -1051,22 +1157,22 @@ static int ks7910_sdio_probe(struct sdio_func *func, const struct sdio_device_id
 
 	return 0;
 
-error_free_read_buf:
+ error_free_read_buf:
 	kfree(priv->ks_wlan_hw.read_buf);
 	priv->ks_wlan_hw.read_buf = NULL;
-error_free_netdev:
+ error_free_netdev:
 	free_netdev(priv->net_dev);
 	card->priv = NULL;
-error_release_irq:
+ error_release_irq:
 	sdio_claim_host(func);
 	sdio_release_irq(func);
-error_disable_func:
+ error_disable_func:
 	sdio_disable_func(func);
-error_free_card:
+ error_free_card:
 	sdio_release_host(func);
 	sdio_set_drvdata(func, NULL);
 	kfree(card);
-error:
+ error:
 	return -ENODEV;
 }
 
@@ -1080,56 +1186,62 @@ static void ks7910_sdio_remove(struct sdio_func *func)
 
 	card = sdio_get_drvdata(func);
 
-	if(card == NULL)
+	if (card == NULL)
 		return;
 
 	DPRINTK(1, "priv = card->priv\n");
 	priv = card->priv;
 	netdev = priv->net_dev;
-	if(priv){
+	if (priv) {
 		ks_wlan_net_stop(netdev);
 		DPRINTK(1, "ks_wlan_net_stop\n");
 
 		/* interrupt disable */
 		sdio_claim_host(func);
-		sdio_writeb(func, 0, INT_ENABLE,  &ret);
-		sdio_writeb(func, 0xff, INT_PENDING,  &ret);
+		sdio_writeb(func, 0, INT_ENABLE, &ret);
+		sdio_writeb(func, 0xff, INT_PENDING, &ret);
 		sdio_release_host(func);
 		DPRINTK(1, "interrupt disable\n");
 
 		/* send stop request to MAC */
 		{
 			struct hostif_stop_request_t *pp;
-			pp = (struct hostif_stop_request_t *)kzalloc(hif_align_size(sizeof(*pp)), GFP_KERNEL );
-			if (pp==NULL) {
-				DPRINTK(3,"allocate memory failed..\n");
-				return; /* to do goto ni suru*/
+			pp = (struct hostif_stop_request_t *)
+			    kzalloc(hif_align_size(sizeof(*pp)), GFP_KERNEL);
+			if (pp == NULL) {
+				DPRINTK(3, "allocate memory failed..\n");
+				return;	/* to do goto ni suru */
 			}
-			pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
-			pp->header.event = cpu_to_le16((uint16_t)HIF_STOP_REQ);
+			pp->header.size =
+			    cpu_to_le16((uint16_t)
+					(sizeof(*pp) -
+					 sizeof(pp->header.size)));
+			pp->header.event = cpu_to_le16((uint16_t) HIF_STOP_REQ);
 
 			sdio_claim_host(func);
-			write_to_device(priv, (unsigned char *) pp, hif_align_size(sizeof(*pp)));
+			write_to_device(priv, (unsigned char *)pp,
+					hif_align_size(sizeof(*pp)));
 			sdio_release_host(func);
 			kfree(pp);
 		}
 		DPRINTK(1, "STOP Req\n");
 
-		if(priv->ks_wlan_hw.ks7010sdio_wq){
+		if (priv->ks_wlan_hw.ks7010sdio_wq) {
 			flush_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);
 			destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);
 		}
-		DPRINTK(1, "destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);\n");
+		DPRINTK(1,
+			"destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);\n");
 
 		hostif_exit(priv);
 		DPRINTK(1, "hostif_exit\n");
 
-		if(!reg_net)
+		if (!reg_net)
 			unregister_netdev(netdev);
 		DPRINTK(1, "unregister_netdev\n");
 
 		trx_device_exit(priv);
-		if(priv->ks_wlan_hw.read_buf){
+		if (priv->ks_wlan_hw.read_buf) {
 			kfree(priv->ks_wlan_hw.read_buf);
 		}
 		free_netdev(priv->net_dev);
@@ -1148,26 +1260,27 @@ static void ks7910_sdio_remove(struct sdio_func *func)
 	kfree(card);
 	DPRINTK(1, "kfree()\n");
 
-
-	DPRINTK(5," Bye !!\n");
+	DPRINTK(5, " Bye !!\n");
 	return;
 }
 
-static int __init ks7010_sdio_init( void )
+static int __init ks7010_sdio_init(void)
 {
 	int status;
 
 	/* register with bus driver core */
 	status = sdio_register_driver(&ks7010_sdio_driver);
-	if(status != 0){
-		DPRINTK(1,"ks79xx_sdio : failed to register with bus driver, %d\n", status );
+	if (status != 0) {
+		DPRINTK(1,
+			"ks79xx_sdio : failed to register with bus driver, %d\n",
+			status);
 	}
 	return status;
 }
 
-static void __exit ks7010_sdio_exit( void )
+static void __exit ks7010_sdio_exit(void)
 {
-	DPRINTK(5," \n");
+	DPRINTK(5, " \n");
 	sdio_unregister_driver(&ks7010_sdio_driver);
 	return;
 }

commit feedcf1a5f3d4fc964d9f7b4d755fc0992378abf
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:26 2016 +0200

    staging: ks7010: remove unecessary typedef
    
    Let's simply specify the struct to keep in sync with kernel coding
    style.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 50364909449a..fb9f0b533d86 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -51,9 +51,9 @@ static struct ks_sdio_model ks_sdio_models[] = {
 static int ks7910_sdio_probe(struct sdio_func *function, const struct sdio_device_id *device);
 static void ks7910_sdio_remove(struct sdio_func *function);
 static void ks7010_rw_function(struct work_struct *work);
-static int ks7010_sdio_read( ks_wlan_private *priv, unsigned int address,
+static int ks7010_sdio_read( struct ks_wlan_private *priv, unsigned int address,
 			     unsigned char *buffer, int length );
-static int ks7010_sdio_write( ks_wlan_private *priv, unsigned int address,
+static int ks7010_sdio_write( struct ks_wlan_private *priv, unsigned int address,
 			      unsigned char *buffer, int length );
 /* macro */
 
@@ -71,7 +71,7 @@ static int ks7010_sdio_write( ks_wlan_private *priv, unsigned int address,
 #define cnt_rxqbody(priv) \
         (((priv->rx_dev.qtail + RX_DEVICE_BUFF_SIZE) - (priv->rx_dev.qhead)) % RX_DEVICE_BUFF_SIZE )
 
-void ks_wlan_hw_sleep_doze_request(ks_wlan_private *priv)
+void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
 	int retval;
@@ -102,7 +102,7 @@ void ks_wlan_hw_sleep_doze_request(ks_wlan_private *priv)
 	return;
 }
 
-void ks_wlan_hw_sleep_wakeup_request(ks_wlan_private *priv)
+void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
 	int retval;
@@ -134,7 +134,7 @@ void ks_wlan_hw_sleep_wakeup_request(ks_wlan_private *priv)
 }
 
 
-void ks_wlan_hw_wakeup_request(ks_wlan_private *priv)
+void ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)
 {
 	unsigned char rw_data;
 	int retval;
@@ -155,7 +155,7 @@ void ks_wlan_hw_wakeup_request(ks_wlan_private *priv)
 	}
 }
 
-int _ks_wlan_hw_power_save(ks_wlan_private *priv)
+int _ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 {
 	int rc=0;
 	unsigned char rw_data;
@@ -220,13 +220,13 @@ int _ks_wlan_hw_power_save(ks_wlan_private *priv)
 	return rc;
 }
 
-int ks_wlan_hw_power_save(ks_wlan_private *priv)
+int ks_wlan_hw_power_save(struct ks_wlan_private *priv)
 {
 	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
 	return 0;
 }
 
-static int ks7010_sdio_read(ks_wlan_private *priv, unsigned int address,
+static int ks7010_sdio_read(struct ks_wlan_private *priv, unsigned int address,
 			    unsigned char *buffer, int length)
 {
 	int rc = -1;
@@ -249,7 +249,7 @@ static int ks7010_sdio_read(ks_wlan_private *priv, unsigned int address,
 	return rc;
 }
 
-static int ks7010_sdio_write(ks_wlan_private *priv, unsigned int address,
+static int ks7010_sdio_write(struct ks_wlan_private *priv, unsigned int address,
 			     unsigned char *buffer, int length)
 {
 	int rc = -1;
@@ -272,7 +272,7 @@ static int ks7010_sdio_write(ks_wlan_private *priv, unsigned int address,
 	return rc;
 }
 
-static int enqueue_txdev(ks_wlan_private *priv, unsigned char *p, unsigned long size,
+static int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p, unsigned long size,
 		  void (*complete_handler)(void *arg1, void *arg2),
 		  void *arg1, void *arg2 )
 {
@@ -306,7 +306,7 @@ static int enqueue_txdev(ks_wlan_private *priv, unsigned char *p, unsigned long
 }
 
 /* write data */
-static int write_to_device(ks_wlan_private *priv, unsigned char *buffer, unsigned long size )
+static int write_to_device(struct ks_wlan_private *priv, unsigned char *buffer, unsigned long size )
 {
 	int rc,retval;
 	unsigned char rw_data;
@@ -338,7 +338,7 @@ static int write_to_device(ks_wlan_private *priv, unsigned char *buffer, unsigne
 
 static void tx_device_task(void *dev)
 {
-	ks_wlan_private	*priv = (ks_wlan_private *)dev;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
 	struct tx_device_buffer	*sp;
 	int rc = 0;
 
@@ -366,7 +366,7 @@ static void tx_device_task(void *dev)
 	return;
 }
 
-int ks_wlan_hw_tx( ks_wlan_private *priv, void *p, unsigned long size,
+int ks_wlan_hw_tx( struct ks_wlan_private *priv, void *p, unsigned long size,
 		   void (*complete_handler)(void *arg1, void *arg2),
 		   void *arg1, void *arg2 )
 {
@@ -396,7 +396,7 @@ int ks_wlan_hw_tx( ks_wlan_private *priv, void *p, unsigned long size,
 
 static void rx_event_task(unsigned long dev)
 {
-        ks_wlan_private *priv = (ks_wlan_private *)dev;
+        struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
 	struct rx_device_buffer	*rp;
 
 	DPRINTK(4,"\n");
@@ -416,7 +416,7 @@ static void rx_event_task(unsigned long dev)
 
 static void ks_wlan_hw_rx(void *dev, uint16_t size)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)dev;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev;
 	int retval;
 	struct rx_device_buffer *rx_buffer;
 	struct hostif_hdr *hdr;
@@ -560,7 +560,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 {
 	int retval;
 	struct ks_sdio_card *card;
-	ks_wlan_private *priv;
+	struct ks_wlan_private *priv;
 	unsigned char status, rsize, rw_data;
 
 	card = sdio_get_drvdata(func);
@@ -643,7 +643,7 @@ static void ks_sdio_interrupt(struct sdio_func *func)
 	return;
 }
 
-static int trx_device_init( ks_wlan_private *priv )
+static int trx_device_init( struct ks_wlan_private *priv )
 {
 	/* initialize values (tx) */
 	priv->tx_dev.qtail = priv->tx_dev.qhead = 0;
@@ -660,7 +660,7 @@ static int trx_device_init( ks_wlan_private *priv )
 	return 0;
 }
 
-static void trx_device_exit( ks_wlan_private *priv )
+static void trx_device_exit( struct ks_wlan_private *priv )
 {
 	struct tx_device_buffer	*sp;
 
@@ -677,7 +677,7 @@ static void trx_device_exit( ks_wlan_private *priv )
 
 	return;
 }
-static int ks7010_sdio_update_index(ks_wlan_private *priv, u32 index)
+static int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)
 {
 	int rc=0;
 	int retval;
@@ -699,7 +699,7 @@ static int ks7010_sdio_update_index(ks_wlan_private *priv, u32 index)
 }
 
 #define ROM_BUFF_SIZE (64*1024)
-static int ks7010_sdio_data_compare(ks_wlan_private *priv, u32 address,
+static int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,
 				    unsigned char *data, unsigned int size)
 {
 	int rc=0;
@@ -720,7 +720,7 @@ static int ks7010_sdio_data_compare(ks_wlan_private *priv, u32 address,
 	return rc;
 }
 #include <linux/firmware.h>
-static int ks79xx_upload_firmware(ks_wlan_private *priv, struct ks_sdio_card *card)
+static int ks79xx_upload_firmware(struct ks_wlan_private *priv, struct ks_sdio_card *card)
 {
 	unsigned int	size, offset,  n = 0;
 	unsigned char	*rom_buf;
@@ -886,7 +886,7 @@ extern int ks_wlan_net_stop(struct net_device *dev);
 
 static int ks7910_sdio_probe(struct sdio_func *func, const struct sdio_device_id *device)
 {
-	ks_wlan_private *priv;
+	struct ks_wlan_private *priv;
 	struct ks_sdio_card *card;
 	struct net_device *netdev;
 	unsigned char rw_data;

commit f8d72df83ca4d3b80517d721bef6d124393a35e7
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:24 2016 +0200

    staging: ks7010: fix printk format warnings
    
    Use proper type for size_t.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 3fb432c9dd31..50364909449a 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -750,7 +750,7 @@ static int ks79xx_upload_firmware(ks_wlan_private *priv, struct ks_sdio_card *ca
 		DPRINTK(1,"error request_firmware() file=%s\n", priv->reg.rom_file);
 		return 1;
 	}
-	DPRINTK(4,"success request_firmware() file=%s size=%d\n", priv->reg.rom_file, fw_entry->size);
+	DPRINTK(4,"success request_firmware() file=%s size=%zu\n", priv->reg.rom_file, fw_entry->size);
 	length = fw_entry->size;
 
 	/* Load Program */

commit 564efd793545d245ed158e5855dbee9706864365
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:21 2016 +0200

    staging: ks7010: delete seperate debug header
    
    Move the one debug macro to the generic wlan header.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 1a1a43ff306a..3fb432c9dd31 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -19,7 +19,6 @@
 
 #include "ks_wlan.h"
 #include "ks_wlan_ioctl.h"
-#include "ks_debug.h"
 #include "ks_hostif.h"
 
 #include "ks7010_sdio.h"

commit 3215bb1a4ba4a6f26272497b4789093549b060e7
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:20 2016 +0200

    staging: ks7010: use kernel helper to print buffer
    
    No need for an open coded one.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 5b78522fad1e..1a1a43ff306a 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -441,10 +441,11 @@ static void ks_wlan_hw_rx(void *dev, uint16_t size)
 
 	/* length check */
 	if(size > 2046 || size == 0){
-
-		DPRINTK(5,"-INVAILED DATA dump\n");
-		print_buffer(&rx_buffer->data[0],32);
-
+#ifdef KS_WLAN_DEBUG
+		if (KS_WLAN_DEBUG > 5)
+			print_hex_dump_bytes("INVALID DATA dump: ", DUMP_PREFIX_OFFSET,
+					     rx_buffer->data, 32);
+#endif
 		/* rx_status update */
 		read_status = READ_STATUS_IDLE;
 		retval = ks7010_sdio_write(priv, READ_STATUS, &read_status, sizeof(read_status));

commit e8593a8abf8cc35073b1c26bb0492f7e361b6ac1
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:18 2016 +0200

    staging: ks7010: avoid workqueue races
    
    My Spectec SDW823 card oopsed when it was already inserted during boot.
    When debugging this, I noticed that the card init was done in a seperate
    workqueue which was only activated once in probe. After removing the
    workqueue and calling the card init directly from probe, the OOPS went
    away. It turned out this is the same OOPS which happened when removing
    the card, so this seems possible now. Note: There is still a
    not-understood card-removed event during boot, but at least it doesn't
    crash anymore and the card will be re-probed right away.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 9300658c4aed..5b78522fad1e 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -817,14 +817,8 @@ static int ks79xx_upload_firmware(ks_wlan_private *priv, struct ks_sdio_card *ca
 	return rc;
 }
 
-static void card_init_task(struct work_struct *work)
+static void ks7010_card_init(struct ks_wlan_private *priv)
 {
-	struct hw_info_t *hw;
-	struct ks_wlan_private *priv;
-
-	hw = container_of(work, struct hw_info_t, init_task);
-	priv = container_of(hw, struct ks_wlan_private, ks_wlan_hw);
-
 	DPRINTK(5,"\ncard_init_task()\n");
 
 	/* init_waitqueue_head(&priv->confirm_wait); */
@@ -1052,23 +1046,11 @@ static int ks7910_sdio_probe(struct sdio_func *func, const struct sdio_device_id
 		goto error_free_read_buf;
 	}
 
-	priv->ks_wlan_hw.ks7010sdio_init = create_singlethread_workqueue("ks7010sdio_init");
-	if(!priv->ks_wlan_hw.ks7010sdio_init){
-		DPRINTK(1, "create_workqueue failed !!\n");
-		goto error_free_sdio_wq;
-	}
-
-	INIT_WORK(&priv->ks_wlan_hw.init_task, card_init_task);
 	INIT_DELAYED_WORK(&priv->ks_wlan_hw.rw_wq, ks7010_rw_function);
-
-	queue_work(priv->ks_wlan_hw.ks7010sdio_init, &priv->ks_wlan_hw.init_task);
+	ks7010_card_init(priv);
 
 	return 0;
 
-error_free_sdio_wq:
-	flush_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);
-	destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);
-	priv->ks_wlan_hw.ks7010sdio_wq = NULL;
 error_free_read_buf:
 	kfree(priv->ks_wlan_hw.read_buf);
 	priv->ks_wlan_hw.read_buf = NULL;
@@ -1139,12 +1121,6 @@ static void ks7910_sdio_remove(struct sdio_func *func)
 		}
 		DPRINTK(1, "destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);\n");
 
-		if(priv->ks_wlan_hw.ks7010sdio_init){
-			flush_workqueue(priv->ks_wlan_hw.ks7010sdio_init);
-			destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_init);
-		}
-		DPRINTK(1, "destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_init);\n");
-
 		hostif_exit(priv);
 		DPRINTK(1, "hostif_exit\n");
 

commit c3fe667f0a99712a2f2ba2f936b35598cf806286
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:15 2016 +0200

    staging: ks7010: remove custom firmware loader
    
    FW_LOADER works fine, no need for a open coded fallback.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
index 7cc49a4ccac5..9300658c4aed 100644
--- a/drivers/staging/ks7010/ks7010_sdio.c
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -56,10 +56,6 @@ static int ks7010_sdio_read( ks_wlan_private *priv, unsigned int address,
 			     unsigned char *buffer, int length );
 static int ks7010_sdio_write( ks_wlan_private *priv, unsigned int address,
 			      unsigned char *buffer, int length );
-#ifdef NO_FIRMWARE_CLASS
-static char *romfile = ROM_FILE;
-module_param(romfile, charp, S_IRUGO);
-#endif
 /* macro */
 
 #define inc_txqhead(priv) \
@@ -723,23 +719,15 @@ static int ks7010_sdio_data_compare(ks_wlan_private *priv, u32 address,
 	if(read_buf) kfree(read_buf);
 	return rc;
 }
-#ifndef NO_FIRMWARE_CLASS
 #include <linux/firmware.h>
-#endif
 static int ks79xx_upload_firmware(ks_wlan_private *priv, struct ks_sdio_card *card)
 {
 	unsigned int	size, offset,  n = 0;
 	unsigned char	*rom_buf;
 	unsigned char rw_data =0;
 	int retval, rc=0;
-#ifndef NO_FIRMWARE_CLASS
 	int length;
 	const struct firmware *fw_entry = NULL;
-#else
-	int orgfsuid, orgfsgid;
-	struct file     *srcf;
-	mm_segment_t orgfs;
-#endif
 
 	rom_buf = NULL;
 
@@ -758,38 +746,16 @@ static int ks79xx_upload_firmware(ks_wlan_private *priv, struct ks_sdio_card *ca
 		goto error_out0;
 	}
 
-#ifndef NO_FIRMWARE_CLASS
 	if(request_firmware(&fw_entry, priv->reg.rom_file, &priv->ks_wlan_hw.sdio_card->func->dev)!=0){
 		DPRINTK(1,"error request_firmware() file=%s\n", priv->reg.rom_file);
 		return 1;
 	}
 	DPRINTK(4,"success request_firmware() file=%s size=%d\n", priv->reg.rom_file, fw_entry->size);
 	length = fw_entry->size;
-#else
-	orgfsuid=current->fsuid;
-	orgfsgid=current->fsgid;
-	current->fsuid=current->fsgid=0;
-	orgfs=get_fs();
-	set_fs(KERNEL_DS);
-
-	srcf = filp_open(romfile, O_RDONLY, 0);
-	if (IS_ERR(srcf)) {
-		DPRINTK(1, "error %ld opening %s\n", -PTR_ERR(srcf),romfile);
-		rc = 1;
-		goto error_out1;
-	}
-
-        if (!(srcf->f_op && srcf->f_op->read)) {
-                DPRINTK(1, "%s does not have a read method\n", romfile);
-                rc = 2;
-                goto error_out2;
-        }
-#endif
 
 	/* Load Program */
 	n = 0;
         do {
-#ifndef NO_FIRMWARE_CLASS
 		if(length >= ROM_BUFF_SIZE){
 			size = ROM_BUFF_SIZE;
 			length = length - ROM_BUFF_SIZE;
@@ -801,16 +767,6 @@ static int ks79xx_upload_firmware(ks_wlan_private *priv, struct ks_sdio_card *ca
 		DPRINTK(4, "size = %d\n",size);
 		if(size == 0) break;
 		memcpy(rom_buf,fw_entry->data+n,size);
-#else
-		/* The object must have a read method */
-		size = srcf->f_op->read(srcf, rom_buf, ROM_BUFF_SIZE, &srcf->f_pos);
-		if (size < 0) {
-			DPRINTK(1, "Read %s error %d\n", priv->reg.rom_file, -retval);
-			rc = 5;
-			goto error_out2;
-		}
-		else if (size == 0) break;
-#endif
 		/* Update write index */
 		offset = n;
 		retval = ks7010_sdio_update_index(priv, KS7010_IRAM_ADDRESS+offset);
@@ -852,20 +808,8 @@ static int ks79xx_upload_firmware(ks_wlan_private *priv, struct ks_sdio_card *ca
 
 	rc = 0;
 
-#ifdef NO_FIRMWARE_CLASS
- error_out2:
-	retval=filp_close(srcf ,NULL);
-	if (retval)
-		DPRINTK(1, "error %d closing %s\n", -retval,priv->reg.rom_file);
-
- error_out1:
-	set_fs(orgfs);
-	current->fsuid=orgfsuid;
-	current->fsgid=orgfsgid;
-#else
  error_out1:
 	release_firmware(fw_entry);
-#endif
  error_out0:
 	sdio_release_host(card->func);
 	if(rom_buf)

commit 13a9930d15b424ab7d3b906af8ba7ff8c409edfe
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:13 2016 +0200

    staging: ks7010: add driver from Nanonote extra-repository
    
    See the TODO for details where this driver came from. Only a few minor
    changes were made to make the driver suitable for staging:
    
    * updated Kconfig help text and dependencies
    * added TODO
    * removed two __DATE__ and __TIME__ printouts to allow reproducible builds
    * added to staging main Kconfig + Makefile
    
    Tested on a Renesas Salvator-X board with a Spectec SDW-823 card. I
    could connect to a WPA-protected network.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c
new file mode 100644
index 000000000000..7cc49a4ccac5
--- /dev/null
+++ b/drivers/staging/ks7010/ks7010_sdio.c
@@ -0,0 +1,1263 @@
+/*
+ *   Driver for KeyStream, KS7010 based SDIO cards.
+ *
+ *   ks7010_sdio.c
+ *   $Id: ks7010_sdio.c 996 2009-09-14 02:54:21Z sekine $
+ *
+ *   Copyright (C) 2006-2008 KeyStream Corp.
+ *   Copyright (C) 2009 Renesas Technology Corp.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it undr the terms of the GNU General Public License version 2 as
+ *   published by the Free Sotware Foundation.
+ */
+
+#include <linux/workqueue.h>
+#include <asm/atomic.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+
+#include "ks_wlan.h"
+#include "ks_wlan_ioctl.h"
+#include "ks_debug.h"
+#include "ks_hostif.h"
+
+#include "ks7010_sdio.h"
+
+#define KS7010_FUNC_NUM 1
+#define KS7010_IO_BLOCK_SIZE 512
+#define KS7010_MAX_CLOCK 25000000
+
+static int reg_net = 0;
+
+static const struct sdio_device_id if_sdio_ids[] = {
+	{ SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_A, SDIO_DEVICE_ID_KS_7010) },
+	{ SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_B, SDIO_DEVICE_ID_KS_7010) },
+	{ /* all zero */ }
+};
+
+struct ks_sdio_model {
+        int model;
+        const char *firmware;
+};
+
+static struct ks_sdio_model ks_sdio_models[] = {
+        {
+                /* ks7010 */
+                .model = 0x10,
+                .firmware = "ks7010sd.rom",
+        },
+};
+
+static int ks7910_sdio_probe(struct sdio_func *function, const struct sdio_device_id *device);
+static void ks7910_sdio_remove(struct sdio_func *function);
+static void ks7010_rw_function(struct work_struct *work);
+static int ks7010_sdio_read( ks_wlan_private *priv, unsigned int address,
+			     unsigned char *buffer, int length );
+static int ks7010_sdio_write( ks_wlan_private *priv, unsigned int address,
+			      unsigned char *buffer, int length );
+#ifdef NO_FIRMWARE_CLASS
+static char *romfile = ROM_FILE;
+module_param(romfile, charp, S_IRUGO);
+#endif
+/* macro */
+
+#define inc_txqhead(priv) \
+        ( priv->tx_dev.qhead = (priv->tx_dev.qhead + 1) % TX_DEVICE_BUFF_SIZE )
+#define inc_txqtail(priv) \
+        ( priv->tx_dev.qtail = (priv->tx_dev.qtail + 1) % TX_DEVICE_BUFF_SIZE )
+#define cnt_txqbody(priv) \
+        (((priv->tx_dev.qtail + TX_DEVICE_BUFF_SIZE) - (priv->tx_dev.qhead)) % TX_DEVICE_BUFF_SIZE )
+
+#define inc_rxqhead(priv) \
+        ( priv->rx_dev.qhead = (priv->rx_dev.qhead + 1) % RX_DEVICE_BUFF_SIZE )
+#define inc_rxqtail(priv) \
+        ( priv->rx_dev.qtail = (priv->rx_dev.qtail + 1) % RX_DEVICE_BUFF_SIZE )
+#define cnt_rxqbody(priv) \
+        (((priv->rx_dev.qtail + RX_DEVICE_BUFF_SIZE) - (priv->rx_dev.qhead)) % RX_DEVICE_BUFF_SIZE )
+
+void ks_wlan_hw_sleep_doze_request(ks_wlan_private *priv)
+{
+	unsigned char rw_data;
+	int retval;
+
+	DPRINTK(4, "\n");
+
+	/* clear request */
+	atomic_set(&priv->sleepstatus.doze_request,0);
+
+	if( atomic_read(&priv->sleepstatus.status) == 0){
+		rw_data = GCR_B_DOZE;
+		retval = ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
+		if(retval){
+			DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
+			goto out;
+		}
+		DPRINTK(4, "PMG SET!! : GCR_B=%02X\n", rw_data);
+		DPRINTK(3,"sleep_mode=SLP_SLEEP\n");
+		atomic_set(&priv->sleepstatus.status, 1);
+ 		priv->last_doze = jiffies;
+	}
+	else{
+		DPRINTK(1,"sleep_mode=%d\n",priv->sleep_mode);
+	}
+
+out:
+	priv->sleep_mode = atomic_read(&priv->sleepstatus.status);
+	return;
+}
+
+void ks_wlan_hw_sleep_wakeup_request(ks_wlan_private *priv)
+{
+	unsigned char rw_data;
+	int retval;
+
+	DPRINTK(4, "\n");
+
+	/* clear request */
+	atomic_set(&priv->sleepstatus.wakeup_request,0);
+
+	if( atomic_read(&priv->sleepstatus.status) == 1){
+		rw_data = WAKEUP_REQ;
+		retval = ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
+		if(retval){
+			DPRINTK(1, " error : WAKEUP=%02X\n", rw_data);
+			goto out;
+		}
+		DPRINTK(4, "wake up : WAKEUP=%02X\n", rw_data);
+		atomic_set(&priv->sleepstatus.status, 0);
+ 		priv->last_wakeup = jiffies;
+		++priv->wakeup_count;
+	}
+	else{
+		DPRINTK(1,"sleep_mode=%d\n",priv->sleep_mode);
+	}
+
+out:
+	priv->sleep_mode = atomic_read(&priv->sleepstatus.status);
+	return;
+}
+
+
+void ks_wlan_hw_wakeup_request(ks_wlan_private *priv)
+{
+	unsigned char rw_data;
+	int retval;
+
+	DPRINTK(4, "\n");
+	if(atomic_read(&priv->psstatus.status)==PS_SNOOZE){
+		rw_data = WAKEUP_REQ;
+		retval = ks7010_sdio_write(priv, WAKEUP, &rw_data, sizeof(rw_data));
+		if(retval){
+			DPRINTK(1, " error : WAKEUP=%02X\n", rw_data);
+		}
+		DPRINTK(4, "wake up : WAKEUP=%02X\n", rw_data);
+ 		priv->last_wakeup = jiffies;
+		++priv->wakeup_count;
+	}
+	else{
+		DPRINTK(1,"psstatus=%d\n",atomic_read(&priv->psstatus.status));
+	}
+}
+
+int _ks_wlan_hw_power_save(ks_wlan_private *priv)
+{
+	int rc=0;
+	unsigned char rw_data;
+	int retval;
+
+	if(priv->reg.powermgt == POWMGT_ACTIVE_MODE)
+		return rc;
+
+	if(priv->reg.operation_mode == MODE_INFRASTRUCTURE &&
+	   (priv->connect_status & CONNECT_STATUS_MASK)== CONNECT_STATUS){
+
+		//DPRINTK(1,"psstatus.status=%d\n",atomic_read(&priv->psstatus.status));
+	if (priv->dev_state == DEVICE_STATE_SLEEP) {
+		switch(atomic_read(&priv->psstatus.status)){
+		case PS_SNOOZE: /* 4 */
+			break;
+		default:
+			DPRINTK(5,"\n\
+				psstatus.status=%d\n\
+				psstatus.confirm_wait=%d\n\
+				psstatus.snooze_guard=%d\n\
+				cnt_txqbody=%d\n",
+				atomic_read(&priv->psstatus.status),
+				atomic_read(&priv->psstatus.confirm_wait),
+				atomic_read(&priv->psstatus.snooze_guard),
+				cnt_txqbody(priv));
+
+			if(!atomic_read(&priv->psstatus.confirm_wait)&&
+			   !atomic_read(&priv->psstatus.snooze_guard)&&
+			   !cnt_txqbody(priv)){
+				retval = ks7010_sdio_read(priv, INT_PENDING, &rw_data, sizeof(rw_data));
+				if(retval){
+					DPRINTK(1, " error : INT_PENDING=%02X\n", rw_data);
+					queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+					break;
+				}
+				if(!rw_data){
+					rw_data = GCR_B_DOZE;
+					retval = ks7010_sdio_write(priv, GCR_B, &rw_data, sizeof(rw_data));
+					if(retval){
+						DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
+						queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+						break;
+					}
+					DPRINTK(4, "PMG SET!! : GCR_B=%02X\n", rw_data);
+					atomic_set(&priv->psstatus.status, PS_SNOOZE);
+					DPRINTK(3,"psstatus.status=PS_SNOOZE\n");
+				}
+				else{
+					queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+				}
+			}
+			else{
+				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 0);
+			}
+			break;
+		}
+	}
+
+	}
+
+	return rc;
+}
+
+int ks_wlan_hw_power_save(ks_wlan_private *priv)
+{
+	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+	return 0;
+}
+
+static int ks7010_sdio_read(ks_wlan_private *priv, unsigned int address,
+			    unsigned char *buffer, int length)
+{
+	int rc = -1;
+	struct ks_sdio_card *card;
+
+	card = priv->ks_wlan_hw.sdio_card;
+
+	if (length == 1) /* CMD52 */
+		*buffer = sdio_readb(card->func, address, &rc);
+	else /* CMD53 multi-block transfer */
+		rc = sdio_memcpy_fromio(card->func, buffer, address, length);
+
+	if(rc != 0){
+		printk("sdio error erorr=%d size=%d\n", rc, length);
+		++priv->sdio_error_count;
+	}else{
+		priv->sdio_error_count=0;
+	}
+
+	return rc;
+}
+
+static int ks7010_sdio_write(ks_wlan_private *priv, unsigned int address,
+			     unsigned char *buffer, int length)
+{
+	int rc = -1;
+	struct ks_sdio_card *card;
+
+	card = priv->ks_wlan_hw.sdio_card;
+
+	if (length == 1) /* CMD52 */
+		sdio_writeb(card->func, *buffer, (unsigned int) address,  &rc);
+	else 		 /* CMD53 */
+		rc = sdio_memcpy_toio(card->func, (unsigned int) address, buffer, length);
+
+	if(rc != 0){
+		printk("sdio error erorr=%d size=%d\n", rc, length);
+		++priv->sdio_error_count;
+	}else{
+		priv->sdio_error_count=0;
+	}
+
+	return rc;
+}
+
+static int enqueue_txdev(ks_wlan_private *priv, unsigned char *p, unsigned long size,
+		  void (*complete_handler)(void *arg1, void *arg2),
+		  void *arg1, void *arg2 )
+{
+	struct tx_device_buffer *sp;
+
+	if (priv->dev_state < DEVICE_STATE_BOOT) {
+		kfree(p);
+		if (complete_handler != NULL)
+			(*complete_handler)(arg1, arg2);
+		return 1;
+	}
+
+	if ((TX_DEVICE_BUFF_SIZE - 1) <=  cnt_txqbody(priv)) {
+		/* in case of buffer overflow */
+		DPRINTK(1,"tx buffer overflow\n");
+		kfree(p);
+		if (complete_handler != NULL)
+			(*complete_handler)(arg1, arg2);
+		return 1;
+	}
+
+	sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qtail];
+	sp->sendp = p;
+	sp->size = size;
+	sp->complete_handler = complete_handler;
+	sp->arg1 = arg1;
+	sp->arg2 = arg2;
+	inc_txqtail(priv);
+
+	return 0;
+}
+
+/* write data */
+static int write_to_device(ks_wlan_private *priv, unsigned char *buffer, unsigned long size )
+{
+	int rc,retval;
+	unsigned char rw_data;
+	struct hostif_hdr *hdr;
+	hdr = (struct hostif_hdr *)buffer;
+	rc=0;
+
+	DPRINTK(4,"size=%d\n", hdr->size);
+	if(hdr->event < HIF_DATA_REQ || HIF_REQ_MAX < hdr->event){
+		DPRINTK(1,"unknown event=%04X\n",hdr->event);
+		return 0;
+	}
+
+	retval = ks7010_sdio_write(priv, DATA_WINDOW, buffer, size);
+	if(retval){
+		DPRINTK(1, " write error : retval=%d\n", retval);
+		return -4;
+	}
+
+	rw_data = WRITE_STATUS_BUSY;
+	retval = ks7010_sdio_write(priv, WRITE_STATUS, &rw_data, sizeof(rw_data));
+	if(retval){
+		DPRINTK(1, " error : WRITE_STATUS=%02X\n", rw_data);
+		return -3;
+	}
+
+	return 0;
+}
+
+static void tx_device_task(void *dev)
+{
+	ks_wlan_private	*priv = (ks_wlan_private *)dev;
+	struct tx_device_buffer	*sp;
+	int rc = 0;
+
+	DPRINTK(4, "\n");
+	if(cnt_txqbody(priv)>0 && atomic_read(&priv->psstatus.status) != PS_SNOOZE){
+		sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];
+		if(priv->dev_state >= DEVICE_STATE_BOOT){
+			rc = write_to_device(priv, sp->sendp, sp->size);
+			if(rc){
+				DPRINTK(1, "write_to_device error !!(%d)\n", rc);
+				queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+				return;
+			}
+
+		}
+		kfree(sp->sendp); /* allocated memory free */
+		if(sp->complete_handler != NULL) /* TX Complete */
+			(*sp->complete_handler)(sp->arg1, sp->arg2);
+		inc_txqhead(priv);
+
+		if(cnt_txqbody(priv)>0){
+			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 0);
+		}
+	}
+	return;
+}
+
+int ks_wlan_hw_tx( ks_wlan_private *priv, void *p, unsigned long size,
+		   void (*complete_handler)(void *arg1, void *arg2),
+		   void *arg1, void *arg2 )
+{
+	int result=0;
+	struct hostif_hdr *hdr;
+	hdr = (struct hostif_hdr *)p;
+
+	if(hdr->event < HIF_DATA_REQ || HIF_REQ_MAX < hdr->event){
+		DPRINTK(1,"unknown event=%04X\n",hdr->event);
+		return 0;
+	}
+
+	/* add event to hostt buffer */
+	priv->hostt.buff[priv->hostt.qtail] = hdr->event;
+        priv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;
+
+	DPRINTK(4, "event=%04X\n",hdr->event);
+	spin_lock(&priv->tx_dev.tx_dev_lock);
+	result = enqueue_txdev(priv, p, size, complete_handler, arg1, arg2);
+	spin_unlock(&priv->tx_dev.tx_dev_lock);
+
+	if(cnt_txqbody(priv)>0){
+		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 0);
+	}
+	return result;
+}
+
+static void rx_event_task(unsigned long dev)
+{
+        ks_wlan_private *priv = (ks_wlan_private *)dev;
+	struct rx_device_buffer	*rp;
+
+	DPRINTK(4,"\n");
+
+	if(cnt_rxqbody(priv) > 0 && priv->dev_state >= DEVICE_STATE_BOOT){
+		rp = &priv->rx_dev.rx_dev_buff[priv->rx_dev.qhead];
+		hostif_receive(priv, rp->data, rp->size);
+		inc_rxqhead(priv);
+
+		if(cnt_rxqbody(priv) > 0){
+			tasklet_schedule(&priv->ks_wlan_hw.rx_bh_task);
+		}
+	}
+
+	return;
+}
+
+static void ks_wlan_hw_rx(void *dev, uint16_t size)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)dev;
+	int retval;
+	struct rx_device_buffer *rx_buffer;
+	struct hostif_hdr *hdr;
+	unsigned char	read_status;
+	unsigned short event=0;
+
+	DPRINTK(4,"\n");
+
+	/* receive data */
+	if (cnt_rxqbody(priv) >= (RX_DEVICE_BUFF_SIZE-1)) {
+		/* in case of buffer overflow */
+		DPRINTK(1,"rx buffer overflow \n");
+		goto error_out;
+	}
+	rx_buffer = &priv->rx_dev.rx_dev_buff[priv->rx_dev.qtail];
+
+	retval = ks7010_sdio_read(priv, DATA_WINDOW, &rx_buffer->data[0], hif_align_size(size));
+	if(retval){
+		goto error_out;
+	}
+
+	/* length check */
+	if(size > 2046 || size == 0){
+
+		DPRINTK(5,"-INVAILED DATA dump\n");
+		print_buffer(&rx_buffer->data[0],32);
+
+		/* rx_status update */
+		read_status = READ_STATUS_IDLE;
+		retval = ks7010_sdio_write(priv, READ_STATUS, &read_status, sizeof(read_status));
+		if(retval){
+			DPRINTK(1, " error : READ_STATUS=%02X\n", read_status);
+		}
+		goto error_out;
+	}
+
+	hdr = (struct hostif_hdr *)&rx_buffer->data[0];
+	rx_buffer->size = le16_to_cpu(hdr->size) + sizeof(hdr->size);
+	event = hdr->event;
+	inc_rxqtail(priv);
+
+	/* read status update */
+	read_status = READ_STATUS_IDLE;
+	retval = ks7010_sdio_write(priv, READ_STATUS, &read_status, sizeof(read_status));
+	if(retval){
+		DPRINTK(1, " error : READ_STATUS=%02X\n", read_status);
+	}
+	DPRINTK(4, "READ_STATUS=%02X\n", read_status);
+
+	if(atomic_read(&priv->psstatus.confirm_wait)){
+		if(IS_HIF_CONF(event)){
+			DPRINTK(4, "IS_HIF_CONF true !!\n");
+			atomic_dec(&priv->psstatus.confirm_wait);
+		}
+	}
+
+	/* rx_event_task((void *)priv); */
+	tasklet_schedule(&priv->ks_wlan_hw.rx_bh_task);
+
+error_out:
+	return;
+}
+
+static void ks7010_rw_function(struct work_struct *work)
+{
+	struct hw_info_t *hw;
+	struct ks_wlan_private *priv;
+	unsigned char rw_data;
+	int retval;
+
+	hw = container_of(work, struct hw_info_t, rw_wq.work);
+	priv = container_of(hw, struct ks_wlan_private, ks_wlan_hw);
+
+	DPRINTK(4,"\n");
+
+
+ 	/* wiat after DOZE */
+ 	if(time_after(priv->last_doze + ((30*HZ)/1000), jiffies )){
+ 		DPRINTK(4, "wait after DOZE \n");
+		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+		return;
+	}
+
+	/* wiat after WAKEUP */
+	while(time_after(priv->last_wakeup + ((30*HZ)/1000), jiffies )){
+		DPRINTK(4, "wait after WAKEUP \n");
+/*		queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq,
+		(priv->last_wakeup + ((30*HZ)/1000) - jiffies));*/
+		printk("wake: %lu %lu\n", priv->last_wakeup + (30* HZ)/1000, jiffies);
+		msleep(30);
+	}
+
+	sdio_claim_host(priv->ks_wlan_hw.sdio_card->func);
+
+	/* power save wakeup */
+	if(atomic_read(&priv->psstatus.status)==PS_SNOOZE){
+		if(cnt_txqbody(priv)>0){
+			ks_wlan_hw_wakeup_request(priv);
+			queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 1);
+		}
+		goto err_out;
+	}
+
+	/* sleep mode doze */
+	if(atomic_read(&priv->sleepstatus.doze_request)==1){
+		ks_wlan_hw_sleep_doze_request(priv);
+		goto err_out;
+	}
+	/* sleep mode wakeup */
+	if(atomic_read(&priv->sleepstatus.wakeup_request)==1){
+		ks_wlan_hw_sleep_wakeup_request(priv);
+		goto err_out;
+	}
+
+	/* read (WriteStatus/ReadDataSize FN1:00_0014) */
+	retval = ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data, sizeof(rw_data));
+	if(retval){
+		DPRINTK(1, " error : WSTATUS_RSIZE=%02X psstatus=%d\n", rw_data,atomic_read(&priv->psstatus.status));
+		goto err_out;
+	}
+	DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
+
+	if(rw_data&RSIZE_MASK){ /* Read schedule */
+		ks_wlan_hw_rx((void *)priv, (uint16_t)(((rw_data&RSIZE_MASK)<<4)));
+	}
+	if((rw_data&WSTATUS_MASK)){
+		tx_device_task((void *)priv);
+	}
+	_ks_wlan_hw_power_save(priv);
+
+err_out:
+	sdio_release_host(priv->ks_wlan_hw.sdio_card->func);
+
+	return;
+}
+
+
+
+static void ks_sdio_interrupt(struct sdio_func *func)
+{
+	int retval;
+	struct ks_sdio_card *card;
+	ks_wlan_private *priv;
+	unsigned char status, rsize, rw_data;
+
+	card = sdio_get_drvdata(func);
+	priv = card->priv;
+	DPRINTK(4, "\n");
+
+	if(priv->dev_state >= DEVICE_STATE_BOOT){
+		retval = ks7010_sdio_read(priv, INT_PENDING, &status, sizeof(status));
+		if(retval){
+			DPRINTK(1, "read INT_PENDING Failed!!(%d)\n",retval);
+			goto intr_out;
+		}
+		DPRINTK(4, "INT_PENDING=%02X\n", rw_data);
+
+		/* schedule task for interrupt status */
+		/* bit7 -> Write General Communication B register */
+		/* read (General Communication B register) */
+		/* bit5 -> Write Status Idle */
+		/* bit2 -> Read Status Busy  */
+		if(status&INT_GCR_B || atomic_read(&priv->psstatus.status)==PS_SNOOZE){
+			retval = ks7010_sdio_read(priv, GCR_B, &rw_data, sizeof(rw_data));
+			if(retval){
+				DPRINTK(1, " error : GCR_B=%02X\n", rw_data);
+				goto intr_out;
+			}
+			/* DPRINTK(1, "GCR_B=%02X\n", rw_data); */
+			if(rw_data == GCR_B_ACTIVE){
+				if(atomic_read(&priv->psstatus.status)==PS_SNOOZE){
+					atomic_set(&priv->psstatus.status, PS_WAKEUP);
+					priv->wakeup_count=0;
+				}
+				complete(&priv->psstatus.wakeup_wait);
+			}
+
+
+		}
+
+		do{
+			/* read (WriteStatus/ReadDataSize FN1:00_0014) */
+			retval = ks7010_sdio_read(priv, WSTATUS_RSIZE, &rw_data, sizeof(rw_data));
+			if(retval){
+				DPRINTK(1, " error : WSTATUS_RSIZE=%02X\n", rw_data);
+				goto intr_out;
+			}
+			DPRINTK(4, "WSTATUS_RSIZE=%02X\n", rw_data);
+			rsize=rw_data&RSIZE_MASK;
+			if(rsize){ /* Read schedule */
+				ks_wlan_hw_rx((void *)priv, (uint16_t)(((rsize)<<4)));
+			}
+			if(rw_data&WSTATUS_MASK){
+#if 0
+				if(status&INT_WRITE_STATUS && !cnt_txqbody(priv)){
+					/* dummy write for interrupt clear */
+					rw_data =0;
+					retval = ks7010_sdio_write(priv, DATA_WINDOW, &rw_data, sizeof(rw_data));
+					if (retval) {
+						DPRINTK(1, "write DATA_WINDOW Failed!!(%d)\n",retval);
+					}
+					status &= ~INT_WRITE_STATUS;
+				}
+				else{
+#endif
+					if(atomic_read(&priv->psstatus.status)==PS_SNOOZE){
+						if(cnt_txqbody(priv)){
+							ks_wlan_hw_wakeup_request(priv);
+							queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq, &priv->ks_wlan_hw.rw_wq, 1);
+							return;
+						}
+					}
+					else{
+						tx_device_task((void *)priv);
+					}
+//				}
+			}
+		}while(rsize);
+	}
+
+intr_out:
+	queue_delayed_work(priv->ks_wlan_hw.ks7010sdio_wq,&priv->ks_wlan_hw.rw_wq, 0);
+	return;
+}
+
+static int trx_device_init( ks_wlan_private *priv )
+{
+	/* initialize values (tx) */
+	priv->tx_dev.qtail = priv->tx_dev.qhead = 0;
+
+	/* initialize values (rx) */
+	priv->rx_dev.qtail = priv->rx_dev.qhead = 0;
+
+	/* initialize spinLock (tx,rx) */
+	spin_lock_init(&priv->tx_dev.tx_dev_lock);
+	spin_lock_init(&priv->rx_dev.rx_dev_lock);
+
+	tasklet_init(&priv->ks_wlan_hw.rx_bh_task, rx_event_task, (unsigned long)priv);
+
+	return 0;
+}
+
+static void trx_device_exit( ks_wlan_private *priv )
+{
+	struct tx_device_buffer	*sp;
+
+	/* tx buffer clear */
+	while (cnt_txqbody(priv)>0) {
+		sp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];
+		kfree(sp->sendp); /* allocated memory free */
+		if (sp->complete_handler != NULL) /* TX Complete */
+			(*sp->complete_handler)(sp->arg1, sp->arg2);
+		inc_txqhead(priv);
+	}
+
+	tasklet_kill(&priv->ks_wlan_hw.rx_bh_task);
+
+	return;
+}
+static int ks7010_sdio_update_index(ks_wlan_private *priv, u32 index)
+{
+	int rc=0;
+	int retval;
+	unsigned char *data_buf;
+	data_buf = NULL;
+
+	data_buf = kmalloc(sizeof(u32), GFP_KERNEL);
+	if(!data_buf){ rc = 1; goto error_out; }
+
+	memcpy(data_buf, &index, sizeof(index));
+	retval = ks7010_sdio_write(priv, WRITE_INDEX, data_buf, sizeof(index));
+	if(retval){ rc = 2; goto error_out; }
+
+	retval = ks7010_sdio_write(priv, READ_INDEX, data_buf, sizeof(index));
+	if(retval){ rc = 3; goto error_out; }
+error_out:
+	if(data_buf) kfree(data_buf);
+	return rc;
+}
+
+#define ROM_BUFF_SIZE (64*1024)
+static int ks7010_sdio_data_compare(ks_wlan_private *priv, u32 address,
+				    unsigned char *data, unsigned int size)
+{
+	int rc=0;
+	int retval;
+	unsigned char *read_buf;
+	read_buf = NULL;
+	read_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
+	if(!read_buf){ rc = 1; goto error_out; }
+	retval = ks7010_sdio_read(priv, address, read_buf, size);
+	if(retval){ rc = 2; goto error_out; }
+	retval = memcmp(data, read_buf, size);
+
+	if(retval){
+		DPRINTK(0, "data compare error (%d) \n",retval); rc = 3; goto error_out;
+	}
+error_out:
+	if(read_buf) kfree(read_buf);
+	return rc;
+}
+#ifndef NO_FIRMWARE_CLASS
+#include <linux/firmware.h>
+#endif
+static int ks79xx_upload_firmware(ks_wlan_private *priv, struct ks_sdio_card *card)
+{
+	unsigned int	size, offset,  n = 0;
+	unsigned char	*rom_buf;
+	unsigned char rw_data =0;
+	int retval, rc=0;
+#ifndef NO_FIRMWARE_CLASS
+	int length;
+	const struct firmware *fw_entry = NULL;
+#else
+	int orgfsuid, orgfsgid;
+	struct file     *srcf;
+	mm_segment_t orgfs;
+#endif
+
+	rom_buf = NULL;
+
+	/* buffer allocate */
+	rom_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);
+	if(!rom_buf){ rc = 3; goto error_out0; }
+
+
+	sdio_claim_host(card->func);
+
+	/* Firmware running ? */
+	retval = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
+	if(rw_data == GCR_A_RUN){
+		DPRINTK( 0, "MAC firmware running ...\n");
+		rc = 0;
+		goto error_out0;
+	}
+
+#ifndef NO_FIRMWARE_CLASS
+	if(request_firmware(&fw_entry, priv->reg.rom_file, &priv->ks_wlan_hw.sdio_card->func->dev)!=0){
+		DPRINTK(1,"error request_firmware() file=%s\n", priv->reg.rom_file);
+		return 1;
+	}
+	DPRINTK(4,"success request_firmware() file=%s size=%d\n", priv->reg.rom_file, fw_entry->size);
+	length = fw_entry->size;
+#else
+	orgfsuid=current->fsuid;
+	orgfsgid=current->fsgid;
+	current->fsuid=current->fsgid=0;
+	orgfs=get_fs();
+	set_fs(KERNEL_DS);
+
+	srcf = filp_open(romfile, O_RDONLY, 0);
+	if (IS_ERR(srcf)) {
+		DPRINTK(1, "error %ld opening %s\n", -PTR_ERR(srcf),romfile);
+		rc = 1;
+		goto error_out1;
+	}
+
+        if (!(srcf->f_op && srcf->f_op->read)) {
+                DPRINTK(1, "%s does not have a read method\n", romfile);
+                rc = 2;
+                goto error_out2;
+        }
+#endif
+
+	/* Load Program */
+	n = 0;
+        do {
+#ifndef NO_FIRMWARE_CLASS
+		if(length >= ROM_BUFF_SIZE){
+			size = ROM_BUFF_SIZE;
+			length = length - ROM_BUFF_SIZE;
+		}
+		else{
+			size=length;
+			length=0;
+		}
+		DPRINTK(4, "size = %d\n",size);
+		if(size == 0) break;
+		memcpy(rom_buf,fw_entry->data+n,size);
+#else
+		/* The object must have a read method */
+		size = srcf->f_op->read(srcf, rom_buf, ROM_BUFF_SIZE, &srcf->f_pos);
+		if (size < 0) {
+			DPRINTK(1, "Read %s error %d\n", priv->reg.rom_file, -retval);
+			rc = 5;
+			goto error_out2;
+		}
+		else if (size == 0) break;
+#endif
+		/* Update write index */
+		offset = n;
+		retval = ks7010_sdio_update_index(priv, KS7010_IRAM_ADDRESS+offset);
+		if(retval){ rc = 6; goto error_out1; }
+
+		/* Write data */
+		retval = ks7010_sdio_write(priv, DATA_WINDOW, rom_buf, size);
+		if(retval){ rc = 8; goto error_out1; }
+
+		/* compare */
+		retval = ks7010_sdio_data_compare(priv, DATA_WINDOW, rom_buf, size);
+		if(retval){ rc = 9; goto error_out1; }
+		n += size;
+
+       }while(size);
+
+	/* Remap request */
+	rw_data = GCR_A_REMAP;
+	retval = ks7010_sdio_write(priv, GCR_A, &rw_data, sizeof(rw_data));
+	if(retval){
+		rc = 11;
+		goto error_out1;
+	}
+	DPRINTK( 4, " REMAP Request : GCR_A=%02X\n", rw_data);
+
+	/* Firmware running check */
+	for (n = 0; n < 50; ++n) {
+		mdelay(10);/* wait_ms(10); */
+		retval = ks7010_sdio_read(priv, GCR_A, &rw_data, sizeof(rw_data));
+		if(retval){ rc = 11; goto error_out1; }
+		if(rw_data == GCR_A_RUN) break;
+	}
+	DPRINTK(4, "firmware wakeup (%d)!!!!\n",n);
+	if ((50) <= n) {
+		DPRINTK(1, "firmware can't start\n");
+                rc = 12;
+		goto error_out1;
+	}
+
+	rc = 0;
+
+#ifdef NO_FIRMWARE_CLASS
+ error_out2:
+	retval=filp_close(srcf ,NULL);
+	if (retval)
+		DPRINTK(1, "error %d closing %s\n", -retval,priv->reg.rom_file);
+
+ error_out1:
+	set_fs(orgfs);
+	current->fsuid=orgfsuid;
+	current->fsgid=orgfsgid;
+#else
+ error_out1:
+	release_firmware(fw_entry);
+#endif
+ error_out0:
+	sdio_release_host(card->func);
+	if(rom_buf)
+		kfree(rom_buf);
+	return rc;
+}
+
+static void card_init_task(struct work_struct *work)
+{
+	struct hw_info_t *hw;
+	struct ks_wlan_private *priv;
+
+	hw = container_of(work, struct hw_info_t, init_task);
+	priv = container_of(hw, struct ks_wlan_private, ks_wlan_hw);
+
+	DPRINTK(5,"\ncard_init_task()\n");
+
+	/* init_waitqueue_head(&priv->confirm_wait); */
+	init_completion(&priv->confirm_wait);
+
+	DPRINTK(5,"init_completion()\n");
+
+	/* get mac address & firmware version */
+	hostif_sme_enqueue(priv, SME_START);
+
+	DPRINTK(5,"hostif_sme_enqueu()\n");
+
+	if(!wait_for_completion_interruptible_timeout(&priv->confirm_wait,5*HZ)){
+		DPRINTK(1,"wait time out!! SME_START\n");
+	}
+
+	if(priv->mac_address_valid && priv->version_size){
+		priv->dev_state = DEVICE_STATE_PREINIT;
+	}
+
+	hostif_sme_enqueue(priv, SME_GET_EEPROM_CKSUM);
+
+	/* load initial wireless parameter */
+	hostif_sme_enqueue(priv, SME_STOP_REQUEST);
+
+	hostif_sme_enqueue(priv, SME_RTS_THRESHOLD_REQUEST);
+	hostif_sme_enqueue(priv, SME_FRAGMENTATION_THRESHOLD_REQUEST);
+
+	hostif_sme_enqueue(priv, SME_WEP_INDEX_REQUEST);
+	hostif_sme_enqueue(priv, SME_WEP_KEY1_REQUEST);
+	hostif_sme_enqueue(priv, SME_WEP_KEY2_REQUEST);
+	hostif_sme_enqueue(priv, SME_WEP_KEY3_REQUEST);
+	hostif_sme_enqueue(priv, SME_WEP_KEY4_REQUEST);
+
+	hostif_sme_enqueue(priv, SME_WEP_FLAG_REQUEST);
+	hostif_sme_enqueue(priv, SME_RSN_ENABLED_REQUEST);
+	hostif_sme_enqueue(priv, SME_MODE_SET_REQUEST);
+	hostif_sme_enqueue(priv, SME_START_REQUEST);
+
+	if(!wait_for_completion_interruptible_timeout(&priv->confirm_wait,5*HZ)){
+		DPRINTK(1,"wait time out!! wireless parameter set\n");
+	}
+
+	if(priv->dev_state >= DEVICE_STATE_PREINIT){
+		DPRINTK(1, "DEVICE READY!!\n");
+		priv->dev_state = DEVICE_STATE_READY;
+		reg_net = register_netdev (priv->net_dev);
+		DPRINTK(3, "register_netdev=%d\n",reg_net);
+	}
+	else {
+		DPRINTK(1, "dev_state=%d\n",priv->dev_state);
+	}
+}
+
+static struct sdio_driver ks7010_sdio_driver = {
+	.name		= "ks7910_sdio",
+	.id_table	= if_sdio_ids,
+	.probe		= ks7910_sdio_probe,
+	.remove		= ks7910_sdio_remove,
+};
+
+
+extern int ks_wlan_net_start(struct net_device *dev);
+extern int ks_wlan_net_stop(struct net_device *dev);
+
+static int ks7910_sdio_probe(struct sdio_func *func, const struct sdio_device_id *device)
+{
+	ks_wlan_private *priv;
+	struct ks_sdio_card *card;
+	struct net_device *netdev;
+	unsigned char rw_data;
+	int i=0, ret;
+
+	DPRINTK(5, "ks7910_sdio_probe()\n");
+
+	priv = NULL;
+	netdev=NULL;
+
+
+	/* initilize ks_sdio_card */
+	card = kzalloc(sizeof(struct ks_sdio_card), GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+
+	card->func  = func;
+	card->model = 0x10;
+	spin_lock_init(&card->lock);
+
+	/* select model */
+	for (i = 0;i < ARRAY_SIZE(ks_sdio_models);i++) {
+		if (card->model == ks_sdio_models[i].model)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(ks_sdio_models)) {
+		DPRINTK(5, "unkown card model 0x%x\n", card->model);
+		goto error;
+	}
+
+	card->firmware = ks_sdio_models[i].firmware;
+
+
+	/*** Initialize  SDIO ***/
+	sdio_claim_host(func);
+
+	/* bus setting  */
+	/* Issue config request to override clock rate */
+
+	/* function blocksize set */
+	ret = sdio_set_block_size(func, KS7010_IO_BLOCK_SIZE);
+	DPRINTK(5, "multi_block=%d sdio_set_block_size()=%d %d\n", func->card->cccr.multi_block, func->cur_blksize,  ret);
+
+	/* Allocate the slot current */
+
+	/* function enable */
+	ret = sdio_enable_func(func);
+	DPRINTK(5, "sdio_enable_func() %d\n", ret);
+	if (ret)
+		goto error_free_card;
+
+	/* interrupt disable */
+	sdio_writeb(func, 0, INT_ENABLE,  &ret);
+	if (ret)
+		goto error_free_card;
+	sdio_writeb(func, 0xff, INT_PENDING,  &ret);
+	if (ret)
+		goto error_disable_func;
+
+	/* setup interrupt handler */
+	ret = sdio_claim_irq(func, ks_sdio_interrupt);
+	if (ret)
+		goto error_disable_func;
+
+	sdio_release_host(func);
+
+	sdio_set_drvdata(func, card);
+
+	DPRINTK(5, "class = 0x%X, vendor = 0x%X, "
+		"device = 0x%X\n",
+		func->class, func->vendor, func->device);
+
+
+	/* private memory allocate */
+	netdev = alloc_etherdev(sizeof(*priv));
+	if (netdev == NULL) {
+		printk (KERN_ERR "ks79xx : Unable to alloc new net device\n");
+		goto error_release_irq;
+	}
+	if (dev_alloc_name(netdev, netdev->name) < 0) {
+		printk (KERN_ERR "ks79xx :  Couldn't get name!\n");
+		goto error_free_netdev;
+	}
+
+	priv = netdev_priv(netdev);
+
+	card->priv = priv;
+	SET_NETDEV_DEV(netdev, &card->func->dev);	/* for create sysfs symlinks */
+
+	/* private memory initialize */
+	priv->ks_wlan_hw.sdio_card = card;
+	init_completion(&priv->ks_wlan_hw.ks7010_sdio_wait);
+	priv->ks_wlan_hw.read_buf = NULL;
+	priv->ks_wlan_hw.read_buf = kmalloc(RX_DATA_SIZE, GFP_KERNEL);
+	if(!priv->ks_wlan_hw.read_buf){
+		goto error_free_netdev;
+	}
+	priv->dev_state = DEVICE_STATE_PREBOOT;
+	priv->net_dev = netdev;
+	priv->firmware_version[0] = '\0';
+	priv->version_size = 0;
+	priv->last_doze = jiffies;	/* set current jiffies */
+	priv->last_wakeup = jiffies;
+	memset(&priv->nstats, 0, sizeof(priv->nstats));
+	memset(&priv->wstats, 0, sizeof(priv->wstats));
+
+	/* sleep mode */
+	atomic_set(&priv->sleepstatus.doze_request,0);
+	atomic_set(&priv->sleepstatus.wakeup_request,0);
+	atomic_set(&priv->sleepstatus.wakeup_request,0);
+
+	trx_device_init(priv);
+	hostif_init(priv);
+        ks_wlan_net_start(netdev);
+
+	/* Read config file */
+	ret = ks_wlan_read_config_file(priv);
+	if (ret) {
+		printk(KERN_ERR "ks79xx: read configuration file failed !! retern code = %d\n", ret);
+		goto error_free_read_buf;
+	}
+
+	/* Upload firmware */
+	ret = ks79xx_upload_firmware(priv, card); /* firmware load */
+	if(ret){
+		printk(KERN_ERR "ks79xx: firmware load failed !! retern code = %d\n", ret);
+		goto error_free_read_buf;
+	}
+
+	/* interrupt setting */
+	/* clear Interrupt status write (ARMtoSD_InterruptPending FN1:00_0024) */
+	rw_data = 0xff;
+	sdio_claim_host(func);
+	ret = ks7010_sdio_write(priv, INT_PENDING, &rw_data, sizeof(rw_data));
+	sdio_release_host(func);
+	if(ret){
+		DPRINTK(1, " error : INT_PENDING=%02X\n", rw_data);
+	}
+	DPRINTK(4, " clear Interrupt : INT_PENDING=%02X\n", rw_data);
+
+
+	/* enable ks7010sdio interrupt (INT_GCR_B|INT_READ_STATUS|INT_WRITE_STATUS) */
+	rw_data = (INT_GCR_B|INT_READ_STATUS|INT_WRITE_STATUS);
+	sdio_claim_host(func);
+	ret = ks7010_sdio_write(priv, INT_ENABLE, &rw_data, sizeof(rw_data));
+	sdio_release_host(func);
+	if(ret){
+		DPRINTK(1, " error : INT_ENABLE=%02X\n", rw_data);
+	}
+	DPRINTK(4, " enable Interrupt : INT_ENABLE=%02X\n", rw_data);
+	priv->dev_state = DEVICE_STATE_BOOT;
+
+	priv->ks_wlan_hw.ks7010sdio_wq = create_workqueue("ks7010sdio_wq");
+	if(!priv->ks_wlan_hw.ks7010sdio_wq){
+		DPRINTK(1, "create_workqueue failed !!\n");
+		goto error_free_read_buf;
+	}
+
+	priv->ks_wlan_hw.ks7010sdio_init = create_singlethread_workqueue("ks7010sdio_init");
+	if(!priv->ks_wlan_hw.ks7010sdio_init){
+		DPRINTK(1, "create_workqueue failed !!\n");
+		goto error_free_sdio_wq;
+	}
+
+	INIT_WORK(&priv->ks_wlan_hw.init_task, card_init_task);
+	INIT_DELAYED_WORK(&priv->ks_wlan_hw.rw_wq, ks7010_rw_function);
+
+	queue_work(priv->ks_wlan_hw.ks7010sdio_init, &priv->ks_wlan_hw.init_task);
+
+	return 0;
+
+error_free_sdio_wq:
+	flush_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);
+	destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);
+	priv->ks_wlan_hw.ks7010sdio_wq = NULL;
+error_free_read_buf:
+	kfree(priv->ks_wlan_hw.read_buf);
+	priv->ks_wlan_hw.read_buf = NULL;
+error_free_netdev:
+	free_netdev(priv->net_dev);
+	card->priv = NULL;
+error_release_irq:
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+error_disable_func:
+	sdio_disable_func(func);
+error_free_card:
+	sdio_release_host(func);
+	sdio_set_drvdata(func, NULL);
+	kfree(card);
+error:
+	return -ENODEV;
+}
+
+static void ks7910_sdio_remove(struct sdio_func *func)
+{
+	int ret;
+	struct ks_sdio_card *card;
+	struct ks_wlan_private *priv;
+	struct net_device *netdev;
+	DPRINTK(1, "ks7910_sdio_remove()\n");
+
+	card = sdio_get_drvdata(func);
+
+	if(card == NULL)
+		return;
+
+	DPRINTK(1, "priv = card->priv\n");
+	priv = card->priv;
+	netdev = priv->net_dev;
+	if(priv){
+		ks_wlan_net_stop(netdev);
+		DPRINTK(1, "ks_wlan_net_stop\n");
+
+		/* interrupt disable */
+		sdio_claim_host(func);
+		sdio_writeb(func, 0, INT_ENABLE,  &ret);
+		sdio_writeb(func, 0xff, INT_PENDING,  &ret);
+		sdio_release_host(func);
+		DPRINTK(1, "interrupt disable\n");
+
+		/* send stop request to MAC */
+		{
+			struct hostif_stop_request_t *pp;
+			pp = (struct hostif_stop_request_t *)kzalloc(hif_align_size(sizeof(*pp)), GFP_KERNEL );
+			if (pp==NULL) {
+				DPRINTK(3,"allocate memory failed..\n");
+				return; /* to do goto ni suru*/
+			}
+			pp->header.size	= cpu_to_le16((uint16_t)(sizeof(*pp)-sizeof(pp->header.size)));
+			pp->header.event = cpu_to_le16((uint16_t)HIF_STOP_REQ);
+
+			sdio_claim_host(func);
+			write_to_device(priv, (unsigned char *) pp, hif_align_size(sizeof(*pp)));
+			sdio_release_host(func);
+			kfree(pp);
+		}
+		DPRINTK(1, "STOP Req\n");
+
+		if(priv->ks_wlan_hw.ks7010sdio_wq){
+			flush_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);
+			destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);
+		}
+		DPRINTK(1, "destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_wq);\n");
+
+		if(priv->ks_wlan_hw.ks7010sdio_init){
+			flush_workqueue(priv->ks_wlan_hw.ks7010sdio_init);
+			destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_init);
+		}
+		DPRINTK(1, "destroy_workqueue(priv->ks_wlan_hw.ks7010sdio_init);\n");
+
+		hostif_exit(priv);
+		DPRINTK(1, "hostif_exit\n");
+
+		if(!reg_net)
+			unregister_netdev(netdev);
+		DPRINTK(1, "unregister_netdev\n");
+
+		trx_device_exit(priv);
+		if(priv->ks_wlan_hw.read_buf){
+			kfree(priv->ks_wlan_hw.read_buf);
+		}
+		free_netdev(priv->net_dev);
+		card->priv = NULL;
+	}
+
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+	DPRINTK(1, "sdio_release_irq()\n");
+	sdio_disable_func(func);
+	DPRINTK(1, "sdio_disable_func()\n");
+	sdio_release_host(func);
+
+	sdio_set_drvdata(func, NULL);
+
+	kfree(card);
+	DPRINTK(1, "kfree()\n");
+
+
+	DPRINTK(5," Bye !!\n");
+	return;
+}
+
+static int __init ks7010_sdio_init( void )
+{
+	int status;
+
+	/* register with bus driver core */
+	status = sdio_register_driver(&ks7010_sdio_driver);
+	if(status != 0){
+		DPRINTK(1,"ks79xx_sdio : failed to register with bus driver, %d\n", status );
+	}
+	return status;
+}
+
+static void __exit ks7010_sdio_exit( void )
+{
+	DPRINTK(5," \n");
+	sdio_unregister_driver(&ks7010_sdio_driver);
+	return;
+}
+
+module_init(ks7010_sdio_init);
+module_exit(ks7010_sdio_exit);
+
+MODULE_AUTHOR("Qi-Hardware based on KeyStream driver");
+MODULE_DESCRIPTION("Driver for KeyStream, KS7010 based SDIO cards. ");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
+MODULE_SUPPORTED_DEVICE("KS7910");
