commit 0290bd291cc0e0488e35e66bf39efcd7d9d9122b
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Tue Dec 10 09:23:51 2019 -0500

    netdev: pass the stuck queue to the timeout handler
    
    This allows incrementing the correct timeout statistic without any mess.
    Down the road, devices can learn to reset just the specific queue.
    
    The patch was generated with the following script:
    
    use strict;
    use warnings;
    
    our $^I = '.bak';
    
    my @work = (
    ["arch/m68k/emu/nfeth.c", "nfeth_tx_timeout"],
    ["arch/um/drivers/net_kern.c", "uml_net_tx_timeout"],
    ["arch/um/drivers/vector_kern.c", "vector_net_tx_timeout"],
    ["arch/xtensa/platforms/iss/network.c", "iss_net_tx_timeout"],
    ["drivers/char/pcmcia/synclink_cs.c", "hdlcdev_tx_timeout"],
    ["drivers/infiniband/ulp/ipoib/ipoib_main.c", "ipoib_timeout"],
    ["drivers/infiniband/ulp/ipoib/ipoib_main.c", "ipoib_timeout"],
    ["drivers/message/fusion/mptlan.c", "mpt_lan_tx_timeout"],
    ["drivers/misc/sgi-xp/xpnet.c", "xpnet_dev_tx_timeout"],
    ["drivers/net/appletalk/cops.c", "cops_timeout"],
    ["drivers/net/arcnet/arcdevice.h", "arcnet_timeout"],
    ["drivers/net/arcnet/arcnet.c", "arcnet_timeout"],
    ["drivers/net/arcnet/com20020.c", "arcnet_timeout"],
    ["drivers/net/ethernet/3com/3c509.c", "el3_tx_timeout"],
    ["drivers/net/ethernet/3com/3c515.c", "corkscrew_timeout"],
    ["drivers/net/ethernet/3com/3c574_cs.c", "el3_tx_timeout"],
    ["drivers/net/ethernet/3com/3c589_cs.c", "el3_tx_timeout"],
    ["drivers/net/ethernet/3com/3c59x.c", "vortex_tx_timeout"],
    ["drivers/net/ethernet/3com/3c59x.c", "vortex_tx_timeout"],
    ["drivers/net/ethernet/3com/typhoon.c", "typhoon_tx_timeout"],
    ["drivers/net/ethernet/8390/8390.h", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/8390.h", "eip_tx_timeout"],
    ["drivers/net/ethernet/8390/8390.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/8390p.c", "eip_tx_timeout"],
    ["drivers/net/ethernet/8390/ax88796.c", "ax_ei_tx_timeout"],
    ["drivers/net/ethernet/8390/axnet_cs.c", "axnet_tx_timeout"],
    ["drivers/net/ethernet/8390/etherh.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/hydra.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/mac8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/mcf8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/lib8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/ne2k-pci.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/pcnet_cs.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/smc-ultra.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/wd.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/zorro8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/adaptec/starfire.c", "tx_timeout"],
    ["drivers/net/ethernet/agere/et131x.c", "et131x_tx_timeout"],
    ["drivers/net/ethernet/allwinner/sun4i-emac.c", "emac_timeout"],
    ["drivers/net/ethernet/alteon/acenic.c", "ace_watchdog"],
    ["drivers/net/ethernet/amazon/ena/ena_netdev.c", "ena_tx_timeout"],
    ["drivers/net/ethernet/amd/7990.h", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/7990.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/a2065.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/am79c961a.c", "am79c961_timeout"],
    ["drivers/net/ethernet/amd/amd8111e.c", "amd8111e_tx_timeout"],
    ["drivers/net/ethernet/amd/ariadne.c", "ariadne_tx_timeout"],
    ["drivers/net/ethernet/amd/atarilance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/au1000_eth.c", "au1000_tx_timeout"],
    ["drivers/net/ethernet/amd/declance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/lance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/mvme147.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/ni65.c", "ni65_timeout"],
    ["drivers/net/ethernet/amd/nmclan_cs.c", "mace_tx_timeout"],
    ["drivers/net/ethernet/amd/pcnet32.c", "pcnet32_tx_timeout"],
    ["drivers/net/ethernet/amd/sunlance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/xgbe/xgbe-drv.c", "xgbe_tx_timeout"],
    ["drivers/net/ethernet/apm/xgene-v2/main.c", "xge_timeout"],
    ["drivers/net/ethernet/apm/xgene/xgene_enet_main.c", "xgene_enet_timeout"],
    ["drivers/net/ethernet/apple/macmace.c", "mace_tx_timeout"],
    ["drivers/net/ethernet/atheros/ag71xx.c", "ag71xx_tx_timeout"],
    ["drivers/net/ethernet/atheros/alx/main.c", "alx_tx_timeout"],
    ["drivers/net/ethernet/atheros/atl1c/atl1c_main.c", "atl1c_tx_timeout"],
    ["drivers/net/ethernet/atheros/atl1e/atl1e_main.c", "atl1e_tx_timeout"],
    ["drivers/net/ethernet/atheros/atlx/atl.c", "atlx_tx_timeout"],
    ["drivers/net/ethernet/atheros/atlx/atl1.c", "atlx_tx_timeout"],
    ["drivers/net/ethernet/atheros/atlx/atl2.c", "atl2_tx_timeout"],
    ["drivers/net/ethernet/broadcom/b44.c", "b44_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bcmsysport.c", "bcm_sysport_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2.c", "bnx2_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h", "bnx2x_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c", "bnx2x_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c", "bnx2x_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnxt/bnxt.c", "bnxt_tx_timeout"],
    ["drivers/net/ethernet/broadcom/genet/bcmgenet.c", "bcmgenet_timeout"],
    ["drivers/net/ethernet/broadcom/sb1250-mac.c", "sbmac_tx_timeout"],
    ["drivers/net/ethernet/broadcom/tg3.c", "tg3_tx_timeout"],
    ["drivers/net/ethernet/calxeda/xgmac.c", "xgmac_tx_timeout"],
    ["drivers/net/ethernet/cavium/liquidio/lio_main.c", "liquidio_tx_timeout"],
    ["drivers/net/ethernet/cavium/liquidio/lio_vf_main.c", "liquidio_tx_timeout"],
    ["drivers/net/ethernet/cavium/liquidio/lio_vf_rep.c", "lio_vf_rep_tx_timeout"],
    ["drivers/net/ethernet/cavium/thunder/nicvf_main.c", "nicvf_tx_timeout"],
    ["drivers/net/ethernet/cirrus/cs89x0.c", "net_timeout"],
    ["drivers/net/ethernet/cisco/enic/enic_main.c", "enic_tx_timeout"],
    ["drivers/net/ethernet/cisco/enic/enic_main.c", "enic_tx_timeout"],
    ["drivers/net/ethernet/cortina/gemini.c", "gmac_tx_timeout"],
    ["drivers/net/ethernet/davicom/dm9000.c", "dm9000_timeout"],
    ["drivers/net/ethernet/dec/tulip/de2104x.c", "de_tx_timeout"],
    ["drivers/net/ethernet/dec/tulip/tulip_core.c", "tulip_tx_timeout"],
    ["drivers/net/ethernet/dec/tulip/winbond-840.c", "tx_timeout"],
    ["drivers/net/ethernet/dlink/dl2k.c", "rio_tx_timeout"],
    ["drivers/net/ethernet/dlink/sundance.c", "tx_timeout"],
    ["drivers/net/ethernet/emulex/benet/be_main.c", "be_tx_timeout"],
    ["drivers/net/ethernet/ethoc.c", "ethoc_tx_timeout"],
    ["drivers/net/ethernet/faraday/ftgmac100.c", "ftgmac100_tx_timeout"],
    ["drivers/net/ethernet/fealnx.c", "fealnx_tx_timeout"],
    ["drivers/net/ethernet/freescale/dpaa/dpaa_eth.c", "dpaa_tx_timeout"],
    ["drivers/net/ethernet/freescale/fec_main.c", "fec_timeout"],
    ["drivers/net/ethernet/freescale/fec_mpc52xx.c", "mpc52xx_fec_tx_timeout"],
    ["drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c", "fs_timeout"],
    ["drivers/net/ethernet/freescale/gianfar.c", "gfar_timeout"],
    ["drivers/net/ethernet/freescale/ucc_geth.c", "ucc_geth_timeout"],
    ["drivers/net/ethernet/fujitsu/fmvj18x_cs.c", "fjn_tx_timeout"],
    ["drivers/net/ethernet/google/gve/gve_main.c", "gve_tx_timeout"],
    ["drivers/net/ethernet/hisilicon/hip04_eth.c", "hip04_timeout"],
    ["drivers/net/ethernet/hisilicon/hix5hd2_gmac.c", "hix5hd2_net_timeout"],
    ["drivers/net/ethernet/hisilicon/hns/hns_enet.c", "hns_nic_net_timeout"],
    ["drivers/net/ethernet/hisilicon/hns3/hns3_enet.c", "hns3_nic_net_timeout"],
    ["drivers/net/ethernet/huawei/hinic/hinic_main.c", "hinic_tx_timeout"],
    ["drivers/net/ethernet/i825xx/82596.c", "i596_tx_timeout"],
    ["drivers/net/ethernet/i825xx/ether1.c", "ether1_timeout"],
    ["drivers/net/ethernet/i825xx/lib82596.c", "i596_tx_timeout"],
    ["drivers/net/ethernet/i825xx/sun3_82586.c", "sun3_82586_timeout"],
    ["drivers/net/ethernet/ibm/ehea/ehea_main.c", "ehea_tx_watchdog"],
    ["drivers/net/ethernet/ibm/emac/core.c", "emac_tx_timeout"],
    ["drivers/net/ethernet/ibm/emac/core.c", "emac_tx_timeout"],
    ["drivers/net/ethernet/ibm/ibmvnic.c", "ibmvnic_tx_timeout"],
    ["drivers/net/ethernet/intel/e100.c", "e100_tx_timeout"],
    ["drivers/net/ethernet/intel/e1000/e1000_main.c", "e1000_tx_timeout"],
    ["drivers/net/ethernet/intel/e1000e/netdev.c", "e1000_tx_timeout"],
    ["drivers/net/ethernet/intel/fm10k/fm10k_netdev.c", "fm10k_tx_timeout"],
    ["drivers/net/ethernet/intel/i40e/i40e_main.c", "i40e_tx_timeout"],
    ["drivers/net/ethernet/intel/iavf/iavf_main.c", "iavf_tx_timeout"],
    ["drivers/net/ethernet/intel/ice/ice_main.c", "ice_tx_timeout"],
    ["drivers/net/ethernet/intel/ice/ice_main.c", "ice_tx_timeout"],
    ["drivers/net/ethernet/intel/igb/igb_main.c", "igb_tx_timeout"],
    ["drivers/net/ethernet/intel/igbvf/netdev.c", "igbvf_tx_timeout"],
    ["drivers/net/ethernet/intel/ixgb/ixgb_main.c", "ixgb_tx_timeout"],
    ["drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c", "adapter->netdev->netdev_ops->ndo_tx_timeout(adapter->netdev);"],
    ["drivers/net/ethernet/intel/ixgbe/ixgbe_main.c", "ixgbe_tx_timeout"],
    ["drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c", "ixgbevf_tx_timeout"],
    ["drivers/net/ethernet/jme.c", "jme_tx_timeout"],
    ["drivers/net/ethernet/korina.c", "korina_tx_timeout"],
    ["drivers/net/ethernet/lantiq_etop.c", "ltq_etop_tx_timeout"],
    ["drivers/net/ethernet/marvell/mv643xx_eth.c", "mv643xx_eth_tx_timeout"],
    ["drivers/net/ethernet/marvell/pxa168_eth.c", "pxa168_eth_tx_timeout"],
    ["drivers/net/ethernet/marvell/skge.c", "skge_tx_timeout"],
    ["drivers/net/ethernet/marvell/sky2.c", "sky2_tx_timeout"],
    ["drivers/net/ethernet/marvell/sky2.c", "sky2_tx_timeout"],
    ["drivers/net/ethernet/mediatek/mtk_eth_soc.c", "mtk_tx_timeout"],
    ["drivers/net/ethernet/mellanox/mlx4/en_netdev.c", "mlx4_en_tx_timeout"],
    ["drivers/net/ethernet/mellanox/mlx4/en_netdev.c", "mlx4_en_tx_timeout"],
    ["drivers/net/ethernet/mellanox/mlx5/core/en_main.c", "mlx5e_tx_timeout"],
    ["drivers/net/ethernet/micrel/ks8842.c", "ks8842_tx_timeout"],
    ["drivers/net/ethernet/micrel/ksz884x.c", "netdev_tx_timeout"],
    ["drivers/net/ethernet/microchip/enc28j60.c", "enc28j60_tx_timeout"],
    ["drivers/net/ethernet/microchip/encx24j600.c", "encx24j600_tx_timeout"],
    ["drivers/net/ethernet/natsemi/sonic.h", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/sonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/jazzsonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/macsonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/natsemi.c", "ns_tx_timeout"],
    ["drivers/net/ethernet/natsemi/ns83820.c", "ns83820_tx_timeout"],
    ["drivers/net/ethernet/natsemi/xtsonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/neterion/s2io.h", "s2io_tx_watchdog"],
    ["drivers/net/ethernet/neterion/s2io.c", "s2io_tx_watchdog"],
    ["drivers/net/ethernet/neterion/vxge/vxge-main.c", "vxge_tx_watchdog"],
    ["drivers/net/ethernet/netronome/nfp/nfp_net_common.c", "nfp_net_tx_timeout"],
    ["drivers/net/ethernet/nvidia/forcedeth.c", "nv_tx_timeout"],
    ["drivers/net/ethernet/nvidia/forcedeth.c", "nv_tx_timeout"],
    ["drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c", "pch_gbe_tx_timeout"],
    ["drivers/net/ethernet/packetengines/hamachi.c", "hamachi_tx_timeout"],
    ["drivers/net/ethernet/packetengines/yellowfin.c", "yellowfin_tx_timeout"],
    ["drivers/net/ethernet/pensando/ionic/ionic_lif.c", "ionic_tx_timeout"],
    ["drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c", "netxen_tx_timeout"],
    ["drivers/net/ethernet/qlogic/qla3xxx.c", "ql3xxx_tx_timeout"],
    ["drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c", "qlcnic_tx_timeout"],
    ["drivers/net/ethernet/qualcomm/emac/emac.c", "emac_tx_timeout"],
    ["drivers/net/ethernet/qualcomm/qca_spi.c", "qcaspi_netdev_tx_timeout"],
    ["drivers/net/ethernet/qualcomm/qca_uart.c", "qcauart_netdev_tx_timeout"],
    ["drivers/net/ethernet/rdc/r6040.c", "r6040_tx_timeout"],
    ["drivers/net/ethernet/realtek/8139cp.c", "cp_tx_timeout"],
    ["drivers/net/ethernet/realtek/8139too.c", "rtl8139_tx_timeout"],
    ["drivers/net/ethernet/realtek/atp.c", "tx_timeout"],
    ["drivers/net/ethernet/realtek/r8169_main.c", "rtl8169_tx_timeout"],
    ["drivers/net/ethernet/renesas/ravb_main.c", "ravb_tx_timeout"],
    ["drivers/net/ethernet/renesas/sh_eth.c", "sh_eth_tx_timeout"],
    ["drivers/net/ethernet/renesas/sh_eth.c", "sh_eth_tx_timeout"],
    ["drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c", "sxgbe_tx_timeout"],
    ["drivers/net/ethernet/seeq/ether3.c", "ether3_timeout"],
    ["drivers/net/ethernet/seeq/sgiseeq.c", "timeout"],
    ["drivers/net/ethernet/sfc/efx.c", "efx_watchdog"],
    ["drivers/net/ethernet/sfc/falcon/efx.c", "ef4_watchdog"],
    ["drivers/net/ethernet/sgi/ioc3-eth.c", "ioc3_timeout"],
    ["drivers/net/ethernet/sgi/meth.c", "meth_tx_timeout"],
    ["drivers/net/ethernet/silan/sc92031.c", "sc92031_tx_timeout"],
    ["drivers/net/ethernet/sis/sis190.c", "sis190_tx_timeout"],
    ["drivers/net/ethernet/sis/sis900.c", "sis900_tx_timeout"],
    ["drivers/net/ethernet/smsc/epic100.c", "epic_tx_timeout"],
    ["drivers/net/ethernet/smsc/smc911x.c", "smc911x_timeout"],
    ["drivers/net/ethernet/smsc/smc9194.c", "smc_timeout"],
    ["drivers/net/ethernet/smsc/smc91c92_cs.c", "smc_tx_timeout"],
    ["drivers/net/ethernet/smsc/smc91x.c", "smc_timeout"],
    ["drivers/net/ethernet/stmicro/stmmac/stmmac_main.c", "stmmac_tx_timeout"],
    ["drivers/net/ethernet/sun/cassini.c", "cas_tx_timeout"],
    ["drivers/net/ethernet/sun/ldmvsw.c", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/sun/niu.c", "niu_tx_timeout"],
    ["drivers/net/ethernet/sun/sunbmac.c", "bigmac_tx_timeout"],
    ["drivers/net/ethernet/sun/sungem.c", "gem_tx_timeout"],
    ["drivers/net/ethernet/sun/sunhme.c", "happy_meal_tx_timeout"],
    ["drivers/net/ethernet/sun/sunqe.c", "qe_tx_timeout"],
    ["drivers/net/ethernet/sun/sunvnet.c", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/sun/sunvnet_common.c", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/sun/sunvnet_common.h", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/synopsys/dwc-xlgmac-net.c", "xlgmac_tx_timeout"],
    ["drivers/net/ethernet/ti/cpmac.c", "cpmac_tx_timeout"],
    ["drivers/net/ethernet/ti/cpsw.c", "cpsw_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/cpsw_priv.c", "cpsw_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/cpsw_priv.h", "cpsw_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/davinci_emac.c", "emac_dev_tx_timeout"],
    ["drivers/net/ethernet/ti/netcp_core.c", "netcp_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/tlan.c", "tlan_tx_timeout"],
    ["drivers/net/ethernet/toshiba/ps3_gelic_net.h", "gelic_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/ps3_gelic_net.c", "gelic_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/ps3_gelic_wireless.c", "gelic_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/spider_net.c", "spider_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/tc35815.c", "tc35815_tx_timeout"],
    ["drivers/net/ethernet/via/via-rhine.c", "rhine_tx_timeout"],
    ["drivers/net/ethernet/wiznet/w5100.c", "w5100_tx_timeout"],
    ["drivers/net/ethernet/wiznet/w5300.c", "w5300_tx_timeout"],
    ["drivers/net/ethernet/xilinx/xilinx_emaclite.c", "xemaclite_tx_timeout"],
    ["drivers/net/ethernet/xircom/xirc2ps_cs.c", "xirc_tx_timeout"],
    ["drivers/net/fjes/fjes_main.c", "fjes_tx_retry"],
    ["drivers/net/slip/slip.c", "sl_tx_timeout"],
    ["include/linux/usb/usbnet.h", "usbnet_tx_timeout"],
    ["drivers/net/usb/aqc111.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/ax88172a.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/ax88179_178a.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/catc.c", "catc_tx_timeout"],
    ["drivers/net/usb/cdc_mbim.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/cdc_ncm.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/dm9601.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/hso.c", "hso_net_tx_timeout"],
    ["drivers/net/usb/int51x1.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/ipheth.c", "ipheth_tx_timeout"],
    ["drivers/net/usb/kaweth.c", "kaweth_tx_timeout"],
    ["drivers/net/usb/lan78xx.c", "lan78xx_tx_timeout"],
    ["drivers/net/usb/mcs7830.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/pegasus.c", "pegasus_tx_timeout"],
    ["drivers/net/usb/qmi_wwan.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/r8152.c", "rtl8152_tx_timeout"],
    ["drivers/net/usb/rndis_host.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/rtl8150.c", "rtl8150_tx_timeout"],
    ["drivers/net/usb/sierra_net.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/smsc75xx.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/smsc95xx.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/sr9700.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/sr9800.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/usbnet.c", "usbnet_tx_timeout"],
    ["drivers/net/vmxnet3/vmxnet3_drv.c", "vmxnet3_tx_timeout"],
    ["drivers/net/wan/cosa.c", "cosa_net_timeout"],
    ["drivers/net/wan/farsync.c", "fst_tx_timeout"],
    ["drivers/net/wan/fsl_ucc_hdlc.c", "uhdlc_tx_timeout"],
    ["drivers/net/wan/lmc/lmc_main.c", "lmc_driver_timeout"],
    ["drivers/net/wan/x25_asy.c", "x25_asy_timeout"],
    ["drivers/net/wimax/i2400m/netdev.c", "i2400m_tx_timeout"],
    ["drivers/net/wireless/intel/ipw2x00/ipw2100.c", "ipw2100_tx_timeout"],
    ["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
    ["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
    ["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
    ["drivers/net/wireless/intersil/orinoco/main.c", "orinoco_tx_timeout"],
    ["drivers/net/wireless/intersil/orinoco/orinoco_usb.c", "orinoco_tx_timeout"],
    ["drivers/net/wireless/intersil/orinoco/orinoco.h", "orinoco_tx_timeout"],
    ["drivers/net/wireless/intersil/prism54/islpci_dev.c", "islpci_eth_tx_timeout"],
    ["drivers/net/wireless/intersil/prism54/islpci_eth.c", "islpci_eth_tx_timeout"],
    ["drivers/net/wireless/intersil/prism54/islpci_eth.h", "islpci_eth_tx_timeout"],
    ["drivers/net/wireless/marvell/mwifiex/main.c", "mwifiex_tx_timeout"],
    ["drivers/net/wireless/quantenna/qtnfmac/core.c", "qtnf_netdev_tx_timeout"],
    ["drivers/net/wireless/quantenna/qtnfmac/core.h", "qtnf_netdev_tx_timeout"],
    ["drivers/net/wireless/rndis_wlan.c", "usbnet_tx_timeout"],
    ["drivers/net/wireless/wl3501_cs.c", "wl3501_tx_timeout"],
    ["drivers/net/wireless/zydas/zd1201.c", "zd1201_tx_timeout"],
    ["drivers/s390/net/qeth_core.h", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_core_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l2_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l2_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l3_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l3_main.c", "qeth_tx_timeout"],
    ["drivers/staging/ks7010/ks_wlan_net.c", "ks_wlan_tx_timeout"],
    ["drivers/staging/qlge/qlge_main.c", "qlge_tx_timeout"],
    ["drivers/staging/rtl8192e/rtl8192e/rtl_core.c", "_rtl92e_tx_timeout"],
    ["drivers/staging/rtl8192u/r8192U_core.c", "tx_timeout"],
    ["drivers/staging/unisys/visornic/visornic_main.c", "visornic_xmit_timeout"],
    ["drivers/staging/wlan-ng/p80211netdev.c", "p80211knetdev_tx_timeout"],
    ["drivers/tty/n_gsm.c", "gsm_mux_net_tx_timeout"],
    ["drivers/tty/synclink.c", "hdlcdev_tx_timeout"],
    ["drivers/tty/synclink_gt.c", "hdlcdev_tx_timeout"],
    ["drivers/tty/synclinkmp.c", "hdlcdev_tx_timeout"],
    ["net/atm/lec.c", "lec_tx_timeout"],
    ["net/bluetooth/bnep/netdev.c", "bnep_net_timeout"]
    );
    
    for my $p (@work) {
            my @pair = @$p;
            my $file = $pair[0];
            my $func = $pair[1];
            print STDERR $file , ": ", $func,"\n";
            our @ARGV = ($file);
            while (<ARGV>) {
                    if (m/($func\s*\(struct\s+net_device\s+\*[A-Za-z_]?[A-Za-z-0-9_]*)(\))/) {
                            print STDERR "found $1+$2 in $file\n";
                    }
                    if (s/($func\s*\(struct\s+net_device\s+\*[A-Za-z_]?[A-Za-z-0-9_]*)(\))/$1, unsigned int txqueue$2/) {
                            print STDERR "$func found in $file\n";
                    }
                    print;
            }
    }
    
    where the list of files and functions is simply from:
    
    git grep ndo_tx_timeout, with manual addition of headers
    in the rare cases where the function is from a header,
    then manually changing the few places which actually
    call ndo_tx_timeout.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Heiner Kallweit <hkallweit1@gmail.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Shannon Nelson <snelson@pensando.io>
    Reviewed-by: Martin Habets <mhabets@solarflare.com>
    
    changes from v9:
            fixup a forward declaration
    changes from v9:
            more leftovers from v3 change
    changes from v8:
            fix up a missing direct call to timeout
            rebased on net-next
    changes from v7:
            fixup leftovers from v3 change
    changes from v6:
            fix typo in rtl driver
    changes from v5:
            add missing files (allow any net device argument name)
    changes from v4:
            add a missing driver header
    changes from v3:
            change queue # to unsigned
    Changes from v2:
            added headers
    Changes from v1:
            Fix errors found by kbuild:
            generalize the pattern a bit, to pick up
            a couple of instances missed by the previous
            version.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 3cffc8be6656..211dd4a11cac 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -45,7 +45,7 @@ struct wep_key {
  *	function prototypes
  */
 static int ks_wlan_open(struct net_device *dev);
-static void ks_wlan_tx_timeout(struct net_device *dev);
+static void ks_wlan_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev);
 static int ks_wlan_close(struct net_device *dev);
 static void ks_wlan_set_rx_mode(struct net_device *dev);
@@ -2498,7 +2498,7 @@ int ks_wlan_set_mac_address(struct net_device *dev, void *addr)
 }
 
 static
-void ks_wlan_tx_timeout(struct net_device *dev)
+void ks_wlan_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 

commit 08b9bee66e3e5736ff3632e0b000a2098b00d6be
Author: Wentao Cai <etsai042@gmail.com>
Date:   Fri Mar 1 15:17:25 2019 +0800

    Staging: ks7010: Replace typecast to int
    
    This patch fixes the checkpatch.pl warning:
    WARNING: Unnecessary typecast of c90 int constant
    
    Signed-off-by: Wentao Cai <etsai042@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index dc5459ae0b51..3cffc8be6656 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -182,7 +182,7 @@ static int ks_wlan_set_freq(struct net_device *dev,
 	/* for SLEEP MODE */
 	/* If setting by frequency, convert to a channel */
 	if ((fwrq->freq.e == 1) &&
-	    (fwrq->freq.m >= (int)2.412e8) && (fwrq->freq.m <= (int)2.487e8)) {
+	    (fwrq->freq.m >= 241200000) && (fwrq->freq.m <= 248700000)) {
 		int f = fwrq->freq.m / 100000;
 		int c = 0;
 

commit f647b8e1ffcd0ded55feb5445afbb9d421c3155c
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:43 2018 +0200

    staging: ks7010: replace uint8_t with u8 in ks_wlan_set_rx_gain
    
    In function ks_wlan_set_rx_gain a cast to uint8_t is being used
    to assign reception gain. 'rx_gain' field is defined as u8 so
    replace the cast to the correct type
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index c85ea83d23e1..dc5459ae0b51 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2155,7 +2155,7 @@ static int ks_wlan_set_rx_gain(struct net_device *dev,
 	if (*uwrq > 0xFF)
 		return -EINVAL;
 
-	priv->gain.rx_gain = (uint8_t)*uwrq;
+	priv->gain.rx_gain = (u8)*uwrq;
 	priv->gain.rx_mode = (priv->gain.rx_gain < 0xFF) ? 1 : 0;
 	hostif_sme_enqueue(priv, SME_SET_GAIN);
 	return 0;

commit ace98ed095631588bd5a7ca8524b07076c690824
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:42 2018 +0200

    staging: ks7010: replace uint8_t with u8 in ks_wlan_set_tx_gain
    
    In function ks_wlan_set_tx_gain a cast to uint8_t is being used
    to assign transmission gain. 'tx_gain' field is defined as u8 so
    replace the cast to the correct type.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 1cd690a0b7ab..c85ea83d23e1 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2123,7 +2123,7 @@ static int ks_wlan_set_tx_gain(struct net_device *dev,
 	if (*uwrq > 0xFF)
 		return -EINVAL;
 
-	priv->gain.tx_gain = (uint8_t)*uwrq;
+	priv->gain.tx_gain = (u8)*uwrq;
 	priv->gain.tx_mode = (priv->gain.tx_gain < 0xFF) ? 1 : 0;
 	hostif_sme_enqueue(priv, SME_SET_GAIN);
 	return 0;

commit 255d4e1ddc9f1d46a7e25298af24429d61378d9c
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun May 13 20:35:41 2018 +0200

    staging: ks7010: change uint8_t casts to u8 in ks_wlan_set_rate
    
    There are some casts to uint8_t in ks_wlan_set_rate function to
    assign values of the bitrate. Just change it to u8 which is the one
    defined for the field 'body' of the struct which is in use.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 6d5ac6258d99..1cd690a0b7ab 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -406,12 +406,12 @@ static int ks_wlan_set_rate(struct net_device *dev,
 			case 11000000:
 			case 5500000:
 				priv->reg.rate_set.body[0] =
-				    (uint8_t)(vwrq->bitrate.value / 500000);
+				    (u8)(vwrq->bitrate.value / 500000);
 				break;
 			case 2000000:
 			case 1000000:
 				priv->reg.rate_set.body[0] =
-				    ((uint8_t)(vwrq->bitrate.value / 500000)) |
+				    ((u8)(vwrq->bitrate.value / 500000)) |
 				    BASIC_RATE;
 				break;
 			default:
@@ -466,7 +466,7 @@ static int ks_wlan_set_rate(struct net_device *dev,
 			case 18000000:
 			case 9000000:
 				priv->reg.rate_set.body[0] =
-				    (uint8_t)(vwrq->bitrate.value / 500000);
+				    (u8)(vwrq->bitrate.value / 500000);
 				break;
 			case 24000000:
 			case 12000000:
@@ -476,7 +476,7 @@ static int ks_wlan_set_rate(struct net_device *dev,
 			case 2000000:
 			case 1000000:
 				priv->reg.rate_set.body[0] =
-				    ((uint8_t)(vwrq->bitrate.value / 500000)) |
+				    ((u8)(vwrq->bitrate.value / 500000)) |
 				    BASIC_RATE;
 				break;
 			default:

commit 6d6612deaf559c42ab4df207e3842aa92a5af71d
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Sun May 6 15:03:00 2018 -0700

    staging: ks7010: Remove unnecessary limit checks
    
    uwrq is an unsigned 32-bit integer, it cannot be less than zero.
    
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index ee164ab571a9..6d5ac6258d99 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1920,7 +1920,7 @@ static int ks_wlan_set_beacon_lost(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	if (*uwrq < BEACON_LOST_COUNT_MIN || *uwrq > BEACON_LOST_COUNT_MAX)
+	if (*uwrq > BEACON_LOST_COUNT_MAX)
 		return -EINVAL;
 
 	priv->reg.beacon_lost_count = *uwrq;
@@ -2120,7 +2120,7 @@ static int ks_wlan_set_tx_gain(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	if (*uwrq < 0 || *uwrq > 0xFF)
+	if (*uwrq > 0xFF)
 		return -EINVAL;
 
 	priv->gain.tx_gain = (uint8_t)*uwrq;
@@ -2152,7 +2152,7 @@ static int ks_wlan_set_rx_gain(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	if (*uwrq < 0 || *uwrq > 0xFF)
+	if (*uwrq > 0xFF)
 		return -EINVAL;
 
 	priv->gain.rx_gain = (uint8_t)*uwrq;

commit 203ad5a1c8c1b7b31b845d103cd26f7ce449c73d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:44 2018 +0200

    staging: ks7010: refactor ks_get_wireless_stats function
    
    This commit refactor a bit ks_get_wireless_stats using
    ternary operator for return code. It also change a comment
    to use preferred style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 30f8cee8f88c..ee164ab571a9 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1743,14 +1743,11 @@ static struct iw_statistics *ks_get_wireless_stats(struct net_device *dev)
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_statistics *wstats = &priv->wstats;
 
-	if (!atomic_read(&update_phyinfo)) {
-		if (priv->dev_state < DEVICE_STATE_READY)
-			return NULL;	/* not finished initialize */
-		else
-			return wstats;
-	}
+	if (!atomic_read(&update_phyinfo))
+		return (priv->dev_state < DEVICE_STATE_READY) ? NULL : wstats;
 
-	/* Packets discarded in the wireless adapter due to wireless
+	/*
+	 * Packets discarded in the wireless adapter due to wireless
 	 * specific problems
 	 */
 	wstats->discard.nwid = 0;	/* Rx invalid nwid      */

commit 2d1de1e3186d13725ea152c643804ed59b1621aa
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:43 2018 +0200

    staging: ks7010: refactor ks_wlan_set_mlme function
    
    This commit refactors ks_wlan_set_mlme function changing
    switch-case block for more simple if paths improving
    readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 62a9d55e854a..30f8cee8f88c 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1787,23 +1787,20 @@ static int ks_wlan_set_mlme(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_mlme *mlme = (struct iw_mlme *)extra;
-	__u32 mode;
+	__u32 mode = 1;
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
-	/* for SLEEP MODE */
-	switch (mlme->cmd) {
-	case IW_MLME_DEAUTH:
-		if (mlme->reason_code == WLAN_REASON_MIC_FAILURE)
-			return 0;
-		/* fall through */
-	case IW_MLME_DISASSOC:
-		mode = 1;
-		return ks_wlan_set_stop_request(dev, NULL, &mode, NULL);
-	default:
-		return -EOPNOTSUPP;	/* Not Support */
-	}
+	if (mlme->cmd != IW_MLME_DEAUTH &&
+	    mlme->cmd != IW_MLME_DISASSOC)
+		return -EOPNOTSUPP;
+
+	if (mlme->cmd == IW_MLME_DEAUTH &&
+	    mlme->reason_code == WLAN_REASON_MIC_FAILURE)
+		return 0;
+
+	return ks_wlan_set_stop_request(dev, NULL, &mode, NULL);
 }
 
 static int ks_wlan_get_firmware_version(struct net_device *dev,

commit 81255d867c7fa3e3e5c3b0000a7938466c492265
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:42 2018 +0200

    staging: ks7010: refactor ks_wlan_set_phy_type function
    
    Handle invalid values first and assign good ones at the
    end if it is the case. This makes code simplier.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 53288c80df51..62a9d55e854a 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1960,17 +1960,14 @@ static int ks_wlan_set_phy_type(struct net_device *dev,
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	/* for SLEEP MODE */
-	if (*uwrq == D_11B_ONLY_MODE) {	/* 0 */
-		priv->reg.phy_type = D_11B_ONLY_MODE;
-	} else if (*uwrq == D_11G_ONLY_MODE) {	/* 1 */
-		priv->reg.phy_type = D_11G_ONLY_MODE;
-	} else if (*uwrq == D_11BG_COMPATIBLE_MODE) {	/* 2 */
-		priv->reg.phy_type = D_11BG_COMPATIBLE_MODE;
-	} else {
+
+	if (*uwrq != D_11B_ONLY_MODE &&
+	    *uwrq != D_11G_ONLY_MODE &&
+	    *uwrq != D_11BG_COMPATIBLE_MODE)
 		return -EINVAL;
-	}
 
+	/* for SLEEP MODE */
+	priv->reg.phy_type = *uwrq;
 	priv->need_commit |= SME_MODE_SET;
 	return -EINPROGRESS;	/* Call commit handler */
 }

commit 7f3c8bb5bcf3a133d1eeb171cf90888bc5253a69
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:41 2018 +0200

    staging: ks7010: refactor ks_wlan_set_sleep_mode function
    
    This commit refactors ks_wlan_set_sleep_mode function
    avoiding to use switch-case statement ans using simple
    if logic to handle invalid values first. This simplifies
    data paths as well as improves readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index a5401db1d565..53288c80df51 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2028,22 +2028,20 @@ static int ks_wlan_set_sleep_mode(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	if (*uwrq == SLP_SLEEP) {
-		priv->sleep_mode = *uwrq;
-		netdev_info(dev, "SET_SLEEP_MODE %d\n", priv->sleep_mode);
-
-		hostif_sme_enqueue(priv, SME_STOP_REQUEST);
-		hostif_sme_enqueue(priv, SME_SLEEP_REQUEST);
-
-	} else if (*uwrq == SLP_ACTIVE) {
-		priv->sleep_mode = *uwrq;
-		netdev_info(dev, "SET_SLEEP_MODE %d\n", priv->sleep_mode);
-		hostif_sme_enqueue(priv, SME_SLEEP_REQUEST);
-	} else {
+	if (*uwrq != SLP_SLEEP &&
+	    *uwrq != SLP_ACTIVE) {
 		netdev_err(dev, "SET_SLEEP_MODE %d error\n", *uwrq);
 		return -EINVAL;
 	}
 
+	priv->sleep_mode = *uwrq;
+	netdev_info(dev, "SET_SLEEP_MODE %d\n", priv->sleep_mode);
+
+	if (*uwrq == SLP_SLEEP)
+		hostif_sme_enqueue(priv, SME_STOP_REQUEST);
+
+	hostif_sme_enqueue(priv, SME_SLEEP_REQUEST);
+
 	return 0;
 }
 

commit 97d173c64301427174e144eeda4cb7af756589b6
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:40 2018 +0200

    staging: ks7010: use ether_addr_copy in ks_wlan_net_start
    
    Instead of use memcpy for copying ethernet addresses, use
    ether_addr_copy that do the same.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index bb8ec048afe5..a5401db1d565 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2633,7 +2633,7 @@ int ks_wlan_net_start(struct net_device *dev)
 	timer_setup(&update_phyinfo_timer, ks_wlan_update_phyinfo_timeout, 0);
 
 	/* dummy address set */
-	memcpy(priv->eth_addr, dummy_addr, ETH_ALEN);
+	ether_addr_copy(priv->eth_addr, dummy_addr);
 	ether_addr_copy(dev->dev_addr, priv->eth_addr);
 
 	/* The ks_wlan-specific entries in the device structure. */

commit 3ec51bb250b3f56bbd3da5bdfc61924cf355d690
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:39 2018 +0200

    staging: ks7010: use ether_addr_copy in ks_wlan_set_mac_address
    
    Use ether_addr_copy to copy ethernet address instad of using
    memcpy in ks_wlan_set_mac_address function.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 8b4a1ed636bd..bb8ec048afe5 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2500,7 +2500,7 @@ int ks_wlan_set_mac_address(struct net_device *dev, void *addr)
 	if (netif_running(dev))
 		return -EBUSY;
 	memcpy(dev->dev_addr, mac_addr->sa_data, dev->addr_len);
-	memcpy(priv->eth_addr, mac_addr->sa_data, ETH_ALEN);
+	ether_addr_copy(priv->eth_addr, mac_addr->sa_data);
 
 	priv->mac_address_valid = false;
 	hostif_sme_enqueue(priv, SME_MACADDRESS_SET_REQUEST);

commit d96f3a7cecdc399af19da3268f69d2d05b07093d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:29 2018 +0200

    staging: ks7010: change type for rsn_enabled in wpa_status struct
    
    Field rsn_enabled included in wpa_status struct is declared as
    unsigned int but it is only be set using 0 and 1 values and
    in conditional if code is just being used as a boolean. Change
    its type to be a boolean.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 838db49898d4..8b4a1ed636bd 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1372,14 +1372,14 @@ static int ks_wlan_set_auth_mode(struct net_device *dev,
 		case IW_AUTH_WPA_VERSION_DISABLED:
 			priv->wpa.version = value;
 			if (priv->wpa.rsn_enabled)
-				priv->wpa.rsn_enabled = 0;
+				priv->wpa.rsn_enabled = false;
 			priv->need_commit |= SME_RSN;
 			break;
 		case IW_AUTH_WPA_VERSION_WPA:
 		case IW_AUTH_WPA_VERSION_WPA2:
 			priv->wpa.version = value;
 			if (!(priv->wpa.rsn_enabled))
-				priv->wpa.rsn_enabled = 1;
+				priv->wpa.rsn_enabled = true;
 			priv->need_commit |= SME_RSN;
 			break;
 		default:

commit 1c800aabfd68b22795f01358d6b36c4cc5b12571
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:26 2018 +0200

    staging: ks7010: move two preprocessor definitions to ks_wlan.h
    
    In ks_wlan_translate_scan function there are two preprocessor
    definitions:
    
        - RSN_INFO_ELEM_ID
        - GENERIC_INFO_ELEM_ID
    
    These can be moved to common ks_wlan.h because they can be used
    in get_current_ap function instead of use hardcoded values.
    GENERIC_INFO_ELEM_ID has been renamed to WPA_INFO_ELEM_ID which
    is more clear.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index e96477937f65..838db49898d4 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1268,14 +1268,12 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 	if ((current_val - current_ev) > IW_EV_LCP_LEN)
 		current_ev = current_val;
 
-#define GENERIC_INFO_ELEM_ID 0xdd
-#define RSN_INFO_ELEM_ID 0x30
 	if (ap->rsn_ie.id == RSN_INFO_ELEM_ID && ap->rsn_ie.size != 0)
 		current_ev = ks_wlan_add_leader_event(rsn_leader, end_buf,
 						      current_ev, &ap->rsn_ie,
 						      &iwe, info);
 
-	if (ap->wpa_ie.id == GENERIC_INFO_ELEM_ID && ap->wpa_ie.size != 0)
+	if (ap->wpa_ie.id == WPA_INFO_ELEM_ID && ap->wpa_ie.size != 0)
 		current_ev = ks_wlan_add_leader_event(wpa_leader, end_buf,
 						      current_ev, &ap->wpa_ie,
 						      &iwe, info);

commit a0a954b151d037e8cbf8822eb56a1a79c4caed30
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri May 4 06:16:05 2018 +0200

    staging: ks7010: add SPDX identifiers to all files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the all of the staging ks7010 files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    Extra GPL text wording can be removed as it is no longer needed at all.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 694decc05c88..e96477937f65 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *   Driver for KeyStream 11b/g wireless LAN
  *
  *   Copyright (C) 2005-2008 KeyStream Corp.
  *   Copyright (C) 2009 Renesas Technology Corp.
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License version 2 as
- *   published by the Free Software Foundation.
  */
 
 #include <linux/atomic.h>

commit bcb53e8a466f2a95b2f3089006931b0b5984103b
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:55 2018 +0200

    staging: ks7010: refactor ks_wlan_translate_scan function
    
    This commit refactors ks_wlan_translate_scan function with
    the following changes:
    
        - reorder local variables
        - use ether_addr_copy to copy ethernet addresses
        - change style in 'current_ev' variable assignments
        - make use of some ternaries avoiding if-else code
        - use preferred style for comments
        - extract common code into a new ks_wlan_add_leader_event
          function
    
    After this changes readability has been improved.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index f208b940e841..694decc05c88 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1146,6 +1146,33 @@ static int ks_wlan_set_scan(struct net_device *dev,
 	return 0;
 }
 
+static char *ks_wlan_add_leader_event(const char *rsn_leader, char *end_buf,
+				      char *current_ev, struct rsn_ie *rsn,
+				      struct iw_event *iwe,
+				      struct iw_request_info *info)
+{
+	char buffer[RSN_IE_BODY_MAX * 2 + 30];
+	char *pbuf;
+	int i;
+
+	pbuf = &buffer[0];
+	memset(iwe, 0, sizeof(*iwe));
+	iwe->cmd = IWEVCUSTOM;
+	memcpy(buffer, rsn_leader, sizeof(rsn_leader) - 1);
+	iwe->u.data.length += sizeof(rsn_leader) - 1;
+	pbuf += sizeof(rsn_leader) - 1;
+	pbuf += sprintf(pbuf, "%02x", rsn->id);
+	pbuf += sprintf(pbuf, "%02x", rsn->size);
+	iwe->u.data.length += 4;
+
+	for (i = 0; i < rsn->size; i++)
+		pbuf += sprintf(pbuf, "%02x", rsn->body[i]);
+
+	iwe->u.data.length += rsn->size * 2;
+
+	return iwe_stream_add_point(info, current_ev, end_buf, iwe, &buffer[0]);
+}
+
 /*
  * Translate scan data returned from the card to a card independent
  * format that the Wireless Tools will understand - Jean II
@@ -1156,22 +1183,19 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 					   struct local_ap *ap)
 {
 	/* struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv; */
+	static const char rsn_leader[] = "rsn_ie=";
+	static const char wpa_leader[] = "wpa_ie=";
 	struct iw_event iwe;	/* Temporary buffer */
 	u16 capabilities;
 	char *current_val;	/* For rates */
 	int i;
-	static const char rsn_leader[] = "rsn_ie=";
-	static const char wpa_leader[] = "wpa_ie=";
-	char buf0[RSN_IE_BODY_MAX * 2 + 30];
-	char buf1[RSN_IE_BODY_MAX * 2 + 30];
-	char *pbuf;
+
 	/* First entry *MUST* be the AP MAC address */
 	iwe.cmd = SIOCGIWAP;
 	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
-	memcpy(iwe.u.ap_addr.sa_data, ap->bssid, ETH_ALEN);
-	current_ev =
-	    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
-				 IW_EV_ADDR_LEN);
+	ether_addr_copy(iwe.u.ap_addr.sa_data, ap->bssid);
+	current_ev = iwe_stream_add_event(info, current_ev,
+					  end_buf, &iwe, IW_EV_ADDR_LEN);
 
 	/* Other entries will be displayed in the order we give them */
 
@@ -1181,21 +1205,17 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 		iwe.u.data.length = 32;
 	iwe.cmd = SIOCGIWESSID;
 	iwe.u.data.flags = 1;
-	current_ev =
-	    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
-				 ap->ssid.body);
+	current_ev = iwe_stream_add_point(info, current_ev,
+					  end_buf, &iwe, ap->ssid.body);
 
 	/* Add mode */
 	iwe.cmd = SIOCGIWMODE;
 	capabilities = ap->capability;
 	if (capabilities & (WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS)) {
-		if (capabilities & WLAN_CAPABILITY_ESS)
-			iwe.u.mode = IW_MODE_INFRA;
-		else
-			iwe.u.mode = IW_MODE_ADHOC;
-		current_ev =
-		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
-					 IW_EV_UINT_LEN);
+		iwe.u.mode = (capabilities & WLAN_CAPABILITY_ESS) ?
+			      IW_MODE_INFRA : IW_MODE_ADHOC;
+		current_ev = iwe_stream_add_event(info, current_ev,
+						  end_buf, &iwe, IW_EV_UINT_LEN);
 	}
 
 	/* Add frequency */
@@ -1203,32 +1223,29 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 	iwe.u.freq.m = ap->channel;
 	iwe.u.freq.m = frequency_list[iwe.u.freq.m - 1] * 100000;
 	iwe.u.freq.e = 1;
-	current_ev =
-	    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
-				 IW_EV_FREQ_LEN);
+	current_ev = iwe_stream_add_event(info, current_ev,
+					  end_buf, &iwe, IW_EV_FREQ_LEN);
 
 	/* Add quality statistics */
 	iwe.cmd = IWEVQUAL;
 	iwe.u.qual.level = 256 - ap->rssi;
 	iwe.u.qual.qual = ap->sq;
 	iwe.u.qual.noise = 0;	/* invalid noise value */
-	current_ev =
-	    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
-				 IW_EV_QUAL_LEN);
+	current_ev = iwe_stream_add_event(info, current_ev, end_buf,
+					  &iwe, IW_EV_QUAL_LEN);
 
 	/* Add encryption capability */
 	iwe.cmd = SIOCGIWENCODE;
-	if (capabilities & WLAN_CAPABILITY_PRIVACY)
-		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
-	else
-		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	iwe.u.data.flags = (capabilities & WLAN_CAPABILITY_PRIVACY) ?
+			    (IW_ENCODE_ENABLED | IW_ENCODE_NOKEY) :
+			     IW_ENCODE_DISABLED;
 	iwe.u.data.length = 0;
-	current_ev =
-	    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
-				 ap->ssid.body);
+	current_ev = iwe_stream_add_point(info, current_ev, end_buf,
+					  &iwe, ap->ssid.body);
 
-	/* Rate : stuffing multiple values in a single event require a bit
-	 * more of magic - Jean II
+	/*
+	 * Rate : stuffing multiple values in a single event
+	 * require a bit more of magic - Jean II
 	 */
 	current_val = current_ev + IW_EV_LCP_LEN;
 
@@ -1246,9 +1263,9 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 		/* Bit rate given in 500 kb/s units (+ 0x80) */
 		iwe.u.bitrate.value = ((ap->rate_set.body[i] & 0x7f) * 500000);
 		/* Add new value to event */
-		current_val =
-		    iwe_stream_add_value(info, current_ev, current_val, end_buf,
-					 &iwe, IW_EV_PARAM_LEN);
+		current_val = iwe_stream_add_value(info, current_ev,
+						   current_val, end_buf, &iwe,
+						   IW_EV_PARAM_LEN);
 	}
 	/* Check if we added any event */
 	if ((current_val - current_ev) > IW_EV_LCP_LEN)
@@ -1256,53 +1273,18 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 
 #define GENERIC_INFO_ELEM_ID 0xdd
 #define RSN_INFO_ELEM_ID 0x30
-	if (ap->rsn_ie.id == RSN_INFO_ELEM_ID && ap->rsn_ie.size != 0) {
-		pbuf = &buf0[0];
-		memset(&iwe, 0, sizeof(iwe));
-		iwe.cmd = IWEVCUSTOM;
-		memcpy(buf0, rsn_leader, sizeof(rsn_leader) - 1);
-		iwe.u.data.length += sizeof(rsn_leader) - 1;
-		pbuf += sizeof(rsn_leader) - 1;
-
-		pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.id);
-		pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.size);
-		iwe.u.data.length += 4;
-
-		for (i = 0; i < ap->rsn_ie.size; i++)
-			pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.body[i]);
-		iwe.u.data.length += (ap->rsn_ie.size) * 2;
-
-		netdev_dbg(dev, "ap->rsn.size=%d\n", ap->rsn_ie.size);
-
-		current_ev =
-		    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
-					 &buf0[0]);
-	}
-	if (ap->wpa_ie.id == GENERIC_INFO_ELEM_ID && ap->wpa_ie.size != 0) {
-		pbuf = &buf1[0];
-		memset(&iwe, 0, sizeof(iwe));
-		iwe.cmd = IWEVCUSTOM;
-		memcpy(buf1, wpa_leader, sizeof(wpa_leader) - 1);
-		iwe.u.data.length += sizeof(wpa_leader) - 1;
-		pbuf += sizeof(wpa_leader) - 1;
-
-		pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.id);
-		pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.size);
-		iwe.u.data.length += 4;
-
-		for (i = 0; i < ap->wpa_ie.size; i++)
-			pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.body[i]);
-		iwe.u.data.length += (ap->wpa_ie.size) * 2;
-
-		netdev_dbg(dev, "ap->rsn.size=%d\n", ap->wpa_ie.size);
-		netdev_dbg(dev, "iwe.u.data.length=%d\n", iwe.u.data.length);
-
-		current_ev =
-		    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
-					 &buf1[0]);
-	}
-
-	/* The other data in the scan result are not really
+	if (ap->rsn_ie.id == RSN_INFO_ELEM_ID && ap->rsn_ie.size != 0)
+		current_ev = ks_wlan_add_leader_event(rsn_leader, end_buf,
+						      current_ev, &ap->rsn_ie,
+						      &iwe, info);
+
+	if (ap->wpa_ie.id == GENERIC_INFO_ELEM_ID && ap->wpa_ie.size != 0)
+		current_ev = ks_wlan_add_leader_event(wpa_leader, end_buf,
+						      current_ev, &ap->wpa_ie,
+						      &iwe, info);
+
+	/*
+	 * The other data in the scan result are not really
 	 * interesting, so for now drop it - Jean II
 	 */
 	return current_ev;

commit 55b56be2c40ca2eb59888d87a629c77329836747
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:54 2018 +0200

    staging: ks7010: avoid blank line between declarations in ks_wlan_get_aplist
    
    This commit removes a blank line which is included between
    declarations and it has not sense at all.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index d2a213b5817a..f208b940e841 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1094,7 +1094,6 @@ static int ks_wlan_get_aplist(struct net_device *dev,
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct sockaddr *address = (struct sockaddr *)extra;
 	struct iw_quality qual[LOCAL_APLIST_MAX];
-
 	int i;
 
 	if (priv->sleep_mode == SLP_SLEEP)

commit 77b948df47a9b81fde0ee34c313b5c8c009daff6
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:53 2018 +0200

    staging: ks7010: use ether_addr_copy in ks_wlan_get_aplist
    
    Use ether_addr_copy to copy ethernet addresses instead of
    using custom memcpy for that.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 3d09e3605f46..d2a213b5817a 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1101,8 +1101,7 @@ static int ks_wlan_get_aplist(struct net_device *dev,
 		return -EPERM;
 	/* for SLEEP MODE */
 	for (i = 0; i < priv->aplist.size; i++) {
-		memcpy(address[i].sa_data, &(priv->aplist.ap[i].bssid[0]),
-		       ETH_ALEN);
+		ether_addr_copy(address[i].sa_data, priv->aplist.ap[i].bssid);
 		address[i].sa_family = ARPHRD_ETHER;
 		qual[i].level = 256 - priv->aplist.ap[i].rssi;
 		qual[i].qual = priv->aplist.ap[i].sq;

commit 1df964acca5a5e85de8aae30133ed8e7ef610f84
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:52 2018 +0200

    staging: ks7010: avoid if-else condition in ks_wlan_get_power
    
    The if-else code in ks_wlan_get_power function is not needed
    at all and can be achieved with a simple boolean assignation.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 9d79af9eefc8..3d09e3605f46 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1064,10 +1064,7 @@ static int ks_wlan_get_power(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	if (priv->reg.power_mgmt > 0)
-		vwrq->power.disabled = 0;
-	else
-		vwrq->power.disabled = 1;
+	vwrq->power.disabled = (priv->reg.power_mgmt <= 0);
 
 	return 0;
 }

commit f3b0bd23956524c8c98ce0a25f7b7bf897d4af85
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:51 2018 +0200

    staging: ks7010: avoid an 'else' in ks_wlan_set_power
    
    Change if logic to handle invalid case for operation_mode
    at first avoiding an 'else' path.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 45f850a20ed6..9d79af9eefc8 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1045,10 +1045,9 @@ static int ks_wlan_set_power(struct net_device *dev,
 	if (vwrq->power.disabled) {
 		priv->reg.power_mgmt = POWER_MGMT_ACTIVE;
 	} else {
-		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
-			priv->reg.power_mgmt = POWER_MGMT_SAVE1;
-		else
+		if (priv->reg.operation_mode != MODE_INFRASTRUCTURE)
 			return -EINVAL;
+		priv->reg.power_mgmt = POWER_MGMT_SAVE1;
 	}
 
 	hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);

commit afa10db0e10c269f8d3824f645c9f6caacf504b3
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:50 2018 +0200

    staging: ks7010: use ether_addr_copy in ks_wlan_get_wap
    
    Use ether_addr_copy to copy ethernet addresses instead
    of a custom memcpy. This improves readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index f23838e2330e..45f850a20ed6 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -346,7 +346,7 @@ static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 
 	/* for SLEEP MODE */
 	if (is_connect_status(priv->connect_status))
-		memcpy(awrq->ap_addr.sa_data, priv->current_ap.bssid, ETH_ALEN);
+		ether_addr_copy(awrq->ap_addr.sa_data, priv->current_ap.bssid);
 	else
 		eth_zero_addr(awrq->ap_addr.sa_data);
 

commit 90db591233907386010c05a4bd060bb8dd3c515b
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:49 2018 +0200

    staging: ks7010: refactor ks_wlan_set_wap function
    
    Make use of ether_addr_copy instead of memcpy for copying
    ethernet address data in ks_wlan_set_wap function and avoid
    an 'else' just changing if logic to check invalid values first.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index b4b38d86f4f8..f23838e2330e 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -316,18 +316,16 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	if (priv->reg.operation_mode == MODE_ADHOC ||
-	    priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
-		memcpy(priv->reg.bssid, &awrq->ap_addr.sa_data, ETH_ALEN);
-
-		if (is_valid_ether_addr((u8 *)priv->reg.bssid))
-			priv->need_commit |= SME_MODE_SET;
-
-	} else {
+	if (priv->reg.operation_mode != MODE_ADHOC &&
+	    priv->reg.operation_mode != MODE_INFRASTRUCTURE) {
 		eth_zero_addr(priv->reg.bssid);
 		return -EOPNOTSUPP;
 	}
 
+	ether_addr_copy(priv->reg.bssid, awrq->ap_addr.sa_data);
+	if (is_valid_ether_addr((u8 *)priv->reg.bssid))
+		priv->need_commit |= SME_MODE_SET;
+
 	netdev_dbg(dev, "bssid = %pM\n", priv->reg.bssid);
 
 	/* Write it to the card */

commit 60d4125d79c3bc41c123fd0a333d2eb159c8b141
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:48 2018 +0200

    staging: ks7010: align values in frequency_list array
    
    To avoid a long line align values in static array
    frequency_list array.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 8f4da53d3c43..b4b38d86f4f8 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -31,7 +31,8 @@ static int wep_on_off;
 #include <net/iw_handler.h>	/* New driver API */
 
 /* Frequency list (map channels to frequencies) */
-static const long frequency_list[] = { 2412, 2417, 2422, 2427, 2432, 2437, 2442,
+static const long frequency_list[] = {
+	2412, 2417, 2422, 2427, 2432, 2437, 2442,
 	2447, 2452, 2457, 2462, 2467, 2472, 2484
 };
 

commit b8cbbc1261bed209e4ecbf5ba5fa0f4f684c7ad0
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:47 2018 +0200

    staging: ks7010: use ether_addr_copy in ks_wlan_set_encode_ext
    
    Instead of manually memcpy ethernet addresses use ether_addr_copy
    function for this purpose.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index f3e83f9aa283..8f4da53d3c43 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1594,7 +1594,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 		memcpy(&key->rx_seq[0], &enc->rx_seq[0], IW_ENCODE_SEQ_MAX_SIZE);
 	}
 
-	memcpy(&key->addr.sa_data[0], &enc->addr.sa_data[0], ETH_ALEN);
+	ether_addr_copy(&key->addr.sa_data[0], &enc->addr.sa_data[0]);
 
 	switch (enc->alg) {
 	case IW_ENCODE_ALG_NONE:

commit 092f239e9f03b35705129082a4962e25f6c0965d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:46 2018 +0200

    staging: ks7010: refactor ks_wlan_set_pmksa function
    
    This commit cleans a bit ks_wlan_set_pmksa function removing
    nonsense comments as well as make use of ether_addr_* family
    functions written to not do manually things that were being
    here. Minor single if brackets has been removed also.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index a398b6a2b3e3..f3e83f9aa283 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1694,68 +1694,65 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 
 	switch (pmksa->cmd) {
 	case IW_PMKSA_ADD:
-		if (list_empty(&priv->pmklist.head)) {	/* new list */
+		if (list_empty(&priv->pmklist.head)) {
 			for (i = 0; i < PMK_LIST_MAX; i++) {
 				pmk = &priv->pmklist.pmk[i];
-				if (memcmp("\x00\x00\x00\x00\x00\x00",
-					   pmk->bssid, ETH_ALEN) == 0)
-					break; /* loop */
+				if (is_zero_ether_addr(pmk->bssid))
+					break;
 			}
-			memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
+			ether_addr_copy(pmk->bssid, pmksa->bssid.sa_data);
 			memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
 			list_add(&pmk->list, &priv->pmklist.head);
 			priv->pmklist.size++;
-			break;	/* case */
+			break;
 		}
 		/* search cache data */
 		list_for_each(ptr, &priv->pmklist.head) {
 			pmk = list_entry(ptr, struct pmk, list);
-			if (memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN) == 0) {
+			if (ether_addr_equal(pmksa->bssid.sa_data, pmk->bssid)) {
 				memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
 				list_move(&pmk->list, &priv->pmklist.head);
-				break; /* list_for_each */
+				break;
 			}
 		}
-		if (ptr != &priv->pmklist.head)	/* not find address. */
-			break;	/* case */
-
-		if (priv->pmklist.size < PMK_LIST_MAX) {	/* new cache data */
+		/* not find address. */
+		if (ptr != &priv->pmklist.head)
+			break;
+		/* new cache data */
+		if (priv->pmklist.size < PMK_LIST_MAX) {
 			for (i = 0; i < PMK_LIST_MAX; i++) {
 				pmk = &priv->pmklist.pmk[i];
-				if (memcmp("\x00\x00\x00\x00\x00\x00",
-					   pmk->bssid, ETH_ALEN) == 0)
-					break; /* loop */
+				if (is_zero_ether_addr(pmk->bssid))
+					break;
 			}
-			memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
+			ether_addr_copy(pmk->bssid, pmksa->bssid.sa_data);
 			memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
 			list_add(&pmk->list, &priv->pmklist.head);
 			priv->pmklist.size++;
-		} else {	/* overwrite old cache data */
+		} else { /* overwrite old cache data */
 			pmk = list_entry(priv->pmklist.head.prev, struct pmk,
 					 list);
-			memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
+			ether_addr_copy(pmk->bssid, pmksa->bssid.sa_data);
 			memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
 			list_move(&pmk->list, &priv->pmklist.head);
 		}
 		break;
 	case IW_PMKSA_REMOVE:
-		if (list_empty(&priv->pmklist.head)) {	/* list empty */
+		if (list_empty(&priv->pmklist.head))
 			return -EINVAL;
-		}
 		/* search cache data */
 		list_for_each(ptr, &priv->pmklist.head) {
 			pmk = list_entry(ptr, struct pmk, list);
-			if (memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN) == 0) {
+			if (ether_addr_equal(pmksa->bssid.sa_data, pmk->bssid)) {
 				eth_zero_addr(pmk->bssid);
 				memset(pmk->pmkid, 0, IW_PMKID_LEN);
 				list_del_init(&pmk->list);
 				break;
 			}
 		}
-		if (ptr == &priv->pmklist.head) {	/* not find address. */
+		/* not find address. */
+		if (ptr == &priv->pmklist.head)
 			return 0;
-		}
-
 		break;
 	case IW_PMKSA_FLUSH:
 		memset(&priv->pmklist, 0, sizeof(priv->pmklist));

commit bf338a9054a48bdc48e05ef1dc960889097a32f2
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:45 2018 +0200

    staging: ks7010: refactor ks_wlan_set_cts_mode function
    
    This commit refactors ks_wlan_set_cts_mode function to
    handle invalid values first and then assign the good
    one changing a bit logic to use a ternary operator.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 87c051958bf3..a398b6a2b3e3 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2030,18 +2030,13 @@ static int ks_wlan_set_cts_mode(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	if (*uwrq == CTS_MODE_FALSE) {	/* 0 */
-		priv->reg.cts_mode = CTS_MODE_FALSE;
-	} else if (*uwrq == CTS_MODE_TRUE) {	/* 1 */
-		if (priv->reg.phy_type == D_11G_ONLY_MODE ||
-		    priv->reg.phy_type == D_11BG_COMPATIBLE_MODE) {
-			priv->reg.cts_mode = CTS_MODE_TRUE;
-		} else {
-			priv->reg.cts_mode = CTS_MODE_FALSE;
-		}
-	} else {
+	if (*uwrq != CTS_MODE_FALSE && *uwrq != CTS_MODE_TRUE)
 		return -EINVAL;
-	}
+
+	priv->reg.cts_mode = (*uwrq == CTS_MODE_FALSE) ? *uwrq :
+			      (priv->reg.phy_type == D_11G_ONLY_MODE ||
+			       priv->reg.phy_type == D_11BG_COMPATIBLE_MODE) ?
+			       *uwrq : !*uwrq;
 
 	priv->need_commit |= SME_MODE_SET;
 	return -EINPROGRESS;	/* Call commit handler */

commit 8521b4e65e2330e5b952d4341976fe3b98c4efa0
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:44 2018 +0200

    staging: ks7010: refactor ks_wlan_set_preamble function
    
    Change if logic to handle invalid values first and just
    assign at the end the valid one if it is the case.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 3c9fbb9bcd52..87c051958bf3 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1860,14 +1860,10 @@ static int ks_wlan_set_preamble(struct net_device *dev,
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	if (*uwrq == LONG_PREAMBLE) {	/* 0 */
-		priv->reg.preamble = LONG_PREAMBLE;
-	} else if (*uwrq == SHORT_PREAMBLE) {	/* 1 */
-		priv->reg.preamble = SHORT_PREAMBLE;
-	} else {
+	if (*uwrq != LONG_PREAMBLE && *uwrq != SHORT_PREAMBLE)
 		return -EINVAL;
-	}
 
+	priv->reg.preamble = *uwrq;
 	priv->need_commit |= SME_MODE_SET;
 	return -EINPROGRESS;	/* Call commit handler */
 }

commit c87125805216ba3c66d3cb8ed3ff5c36d2ddff01
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:43 2018 +0200

    staging: ks7010: refactor ks_wlan_set_power_mgmt function
    
    This commit change logic to simplify conditional paths in
    ks_wlan_set_power_mgmt function. It handles invalid's first
    and just finally assign a valid value.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index e943d372c393..3c9fbb9bcd52 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1895,23 +1895,16 @@ static int ks_wlan_set_power_mgmt(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
-	/* for SLEEP MODE */
-	if (*uwrq == POWER_MGMT_ACTIVE) {	/* 0 */
-		priv->reg.power_mgmt = POWER_MGMT_ACTIVE;
-	} else if (*uwrq == POWER_MGMT_SAVE1) {	/* 1 */
-		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
-			priv->reg.power_mgmt = POWER_MGMT_SAVE1;
-		else
-			return -EINVAL;
-	} else if (*uwrq == POWER_MGMT_SAVE2) {	/* 2 */
-		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
-			priv->reg.power_mgmt = POWER_MGMT_SAVE2;
-		else
-			return -EINVAL;
-	} else {
+	if (*uwrq != POWER_MGMT_ACTIVE &&
+	    *uwrq != POWER_MGMT_SAVE1 &&
+	    *uwrq != POWER_MGMT_SAVE2)
+		return -EINVAL;
+
+	if ((*uwrq == POWER_MGMT_SAVE1 || *uwrq == POWER_MGMT_SAVE2) &&
+	    (priv->reg.operation_mode != MODE_INFRASTRUCTURE))
 		return -EINVAL;
-	}
 
+	priv->reg.power_mgmt = *uwrq;
 	hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
 
 	return 0;

commit 7a2cc8db50b801d9a384959a5b6c663559c139dd
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:42 2018 +0200

    staging: ks7010: refactor ks_wlan_set_scan_type function
    
    This commit changes logic to handle invalid values first
    and just assign valid ones afterwards.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index e2e72cd7e457..e943d372c393 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1940,14 +1940,11 @@ static int ks_wlan_set_scan_type(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	if (*uwrq == ACTIVE_SCAN) {	/* 0 */
-		priv->reg.scan_type = ACTIVE_SCAN;
-	} else if (*uwrq == PASSIVE_SCAN) {	/* 1 */
-		priv->reg.scan_type = PASSIVE_SCAN;
-	} else {
+
+	if (*uwrq != ACTIVE_SCAN && *uwrq != PASSIVE_SCAN)
 		return -EINVAL;
-	}
 
+	priv->reg.scan_type = *uwrq;
 	return 0;
 }
 

commit 25ee63eb2da2a908685c8318b891054accfc6d0d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Apr 25 16:01:41 2018 +0200

    staging: ks7010: refactor ks_wlan_set_beacon_lost function
    
    Change if condition to handle invalid value first and
    avoid nonsense else's path improving readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index aaa57c263002..e2e72cd7e457 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1973,17 +1973,17 @@ static int ks_wlan_set_beacon_lost(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	if (*uwrq >= BEACON_LOST_COUNT_MIN && *uwrq <= BEACON_LOST_COUNT_MAX)
-		priv->reg.beacon_lost_count = *uwrq;
-	else
+	if (*uwrq < BEACON_LOST_COUNT_MIN || *uwrq > BEACON_LOST_COUNT_MAX)
 		return -EINVAL;
 
+	priv->reg.beacon_lost_count = *uwrq;
+
 	if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 		priv->need_commit |= SME_MODE_SET;
 		return -EINPROGRESS;	/* Call commit handler */
-	} else {
-		return 0;
 	}
+
+	return 0;
 }
 
 static int ks_wlan_get_beacon_lost(struct net_device *dev,

commit 07335253e121a6b3c4e63c46f34fe57ddb8a521a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:50:02 2018 +0200

    staging: ks7010: use ether_addr_copy() instead of custom copy
    
    In order to achieve ethernet address copies, ether_addr_copy()
    function exists. So just use it and avoid the byte by byte copy.
    This increase readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 81d66ac898c6..aaa57c263002 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2686,14 +2686,7 @@ int ks_wlan_net_start(struct net_device *dev)
 
 	/* dummy address set */
 	memcpy(priv->eth_addr, dummy_addr, ETH_ALEN);
-	dev->dev_addr[0] = priv->eth_addr[0];
-	dev->dev_addr[1] = priv->eth_addr[1];
-	dev->dev_addr[2] = priv->eth_addr[2];
-	dev->dev_addr[3] = priv->eth_addr[3];
-	dev->dev_addr[4] = priv->eth_addr[4];
-	dev->dev_addr[5] = priv->eth_addr[5];
-	dev->dev_addr[6] = 0x00;
-	dev->dev_addr[7] = 0x00;
+	ether_addr_copy(dev->dev_addr, priv->eth_addr);
 
 	/* The ks_wlan-specific entries in the device structure. */
 	dev->netdev_ops = &ks_wlan_netdev_ops;

commit f445594240fb18a43aebed7f0ce917c09e9dd87a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:50:01 2018 +0200

    staging: ks7010: remove duplicated ks_wlan_handler_def declaration
    
    This declaration is declared twice so just remove this one because
    the other one is the one which contains static struct initializers.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index a9fdf25b45c0..81d66ac898c6 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -43,9 +43,6 @@ struct wep_key {
 	u8 key[16];	/* 40-bit and 104-bit keys */
 };
 
-/* List of Wireless Handlers (new API) */
-static const struct iw_handler_def ks_wlan_handler_def;
-
 /*
  *	function prototypes
  */

commit 92c1552caef3661f049c4e967550e933599e2663
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:50:00 2018 +0200

    staging: ks7010: remove WPS definition conditional code
    
    WPS definition was defined by default in ks_wlan.h header
    file. So it makes no sense to have conditional preprocessor
    stuff along the code about this.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 3f631d9a45ba..a9fdf25b45c0 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2113,8 +2113,6 @@ static int ks_wlan_get_sleep_mode(struct net_device *dev,
 	return 0;
 }
 
-#ifdef WPS
-
 static int ks_wlan_set_wps_enable(struct net_device *dev,
 				  struct iw_request_info *info, __u32 *uwrq,
 				  char *extra)
@@ -2178,7 +2176,6 @@ static int ks_wlan_set_wps_probe_req(struct net_device *dev,
 
 	return 0;
 }
-#endif /* WPS */
 
 static int ks_wlan_set_tx_gain(struct net_device *dev,
 			       struct iw_request_info *info, __u32 *uwrq,
@@ -2389,14 +2386,12 @@ static const struct iw_priv_args ks_wlan_private_args[] = {
 /*{ cmd, set_args, get_args, name[16] } */
 	{KS_WLAN_GET_FIRM_VERSION, IW_PRIV_TYPE_NONE,
 	 IW_PRIV_TYPE_CHAR | (128 + 1), "GetFirmwareVer"},
-#ifdef WPS
 	{KS_WLAN_SET_WPS_ENABLE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
 	 IW_PRIV_TYPE_NONE, "SetWPSEnable"},
 	{KS_WLAN_GET_WPS_ENABLE, IW_PRIV_TYPE_NONE,
 	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetW"},
 	{KS_WLAN_SET_WPS_PROBE_REQ, IW_PRIV_TYPE_BYTE | 2047, IW_PRIV_TYPE_NONE,
 	 "SetWPSProbeReq"},
-#endif /* WPS */
 	{KS_WLAN_SET_PREAMBLE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
 	 IW_PRIV_TYPE_NONE, "SetPreamble"},
 	{KS_WLAN_GET_PREAMBLE, IW_PRIV_TYPE_NONE,
@@ -2482,15 +2477,9 @@ static const iw_handler ks_wlan_private_handler[] = {
 	(iw_handler)NULL,			/* 1, KS_WLAN_GET_DRIVER_VERSION */
 	(iw_handler)NULL,			/* 2 */
 	(iw_handler)ks_wlan_get_firmware_version,/* 3 KS_WLAN_GET_FIRM_VERSION */
-#ifdef WPS
 	(iw_handler)ks_wlan_set_wps_enable,	/* 4 KS_WLAN_SET_WPS_ENABLE */
 	(iw_handler)ks_wlan_get_wps_enable,	/* 5 KS_WLAN_GET_WPS_ENABLE */
 	(iw_handler)ks_wlan_set_wps_probe_req,	/* 6 KS_WLAN_SET_WPS_PROBE_REQ */
-#else
-	(iw_handler)NULL,			/* 4 */
-	(iw_handler)NULL,			/* 5 */
-	(iw_handler)NULL,			/* 6 */
-#endif /* WPS */
 	(iw_handler)ks_wlan_get_eeprom_cksum,	/* 7 KS_WLAN_GET_CONNECT */
 	(iw_handler)ks_wlan_set_preamble,	/* 8 KS_WLAN_SET_PREAMBLE */
 	(iw_handler)ks_wlan_get_preamble,	/* 9 KS_WLAN_GET_PREAMBLE */

commit e83cfca1abbeee6ad77e2c8543183483eba10eab
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:49:59 2018 +0200

    staging: ks7010: fix line exceding 80 characters in ks_wlan_get_range
    
    Avoid very long if condition just changing its style. This makes
    checkpatch script not complains about this line.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index ccec25ed155a..3f631d9a45ba 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -933,7 +933,8 @@ static int ks_wlan_get_range(struct net_device *dev,
 		range->freq[k++].e = 1;	/* Values in table in MHz -> * 10^5 * 10 */
 	}
 	range->num_frequency = k;
-	if (priv->reg.phy_type == D_11B_ONLY_MODE || priv->reg.phy_type == D_11BG_COMPATIBLE_MODE) {	/* channel 14 */
+	if (priv->reg.phy_type == D_11B_ONLY_MODE ||
+	    priv->reg.phy_type == D_11BG_COMPATIBLE_MODE) {	/* channel 14 */
 		range->freq[13].i = 14;	/* List index */
 		range->freq[13].m = frequency_list[13] * 100000;
 		range->freq[13].e = 1;	/* Values in table in MHz -> * 10^5 * 10 */

commit ca94697252370f8d8dc1346d0007508b98f95ca7
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:49:58 2018 +0200

    staging: ks7010: refactor ks_wlan_get_mode function
    
    Avoid the use of switch-case block which is not necessary
    at all and just use a ternary operator to achieve this.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index cb3d0a898b5f..ccec25ed155a 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -765,18 +765,9 @@ static int ks_wlan_get_mode(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
-	/* for SLEEP MODE */
 	/* If not managed, assume it's ad-hoc */
-	switch (priv->reg.operation_mode) {
-	case MODE_INFRASTRUCTURE:
-		uwrq->mode = IW_MODE_INFRA;
-		break;
-	case MODE_ADHOC:
-		uwrq->mode = IW_MODE_ADHOC;
-		break;
-	default:
-		uwrq->mode = IW_MODE_ADHOC;
-	}
+	uwrq->mode = (priv->reg.operation_mode == MODE_INFRASTRUCTURE) ?
+		      IW_MODE_INFRA : IW_MODE_ADHOC;
 
 	return 0;
 }

commit 1e4c7fb3a54ec2b1be17c7d2d1b53c593f959a1d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:49:57 2018 +0200

    staging: ks7010: refactor ks_wlan_set_mode function
    
    Most cases which are being handled in the switch-case of
    ks_wlan_set_mode function are just returning EINVAL. Avoid
    the use of switch-case stament and just use a simple if
    to handle those. This decrease LOC as well as improves
    readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 58226789812f..cb3d0a898b5f 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -745,24 +745,13 @@ static int ks_wlan_set_mode(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
-	/* for SLEEP MODE */
-	switch (uwrq->mode) {
-	case IW_MODE_ADHOC:
-		priv->reg.operation_mode = MODE_ADHOC;
-		priv->need_commit |= SME_MODE_SET;
-		break;
-	case IW_MODE_INFRA:
-		priv->reg.operation_mode = MODE_INFRASTRUCTURE;
-		priv->need_commit |= SME_MODE_SET;
-		break;
-	case IW_MODE_AUTO:
-	case IW_MODE_MASTER:
-	case IW_MODE_REPEAT:
-	case IW_MODE_SECOND:
-	case IW_MODE_MONITOR:
-	default:
+	if (uwrq->mode != IW_MODE_ADHOC &&
+	    uwrq->mode != IW_MODE_INFRA)
 		return -EINVAL;
-	}
+
+	priv->reg.operation_mode = (uwrq->mode == IW_MODE_ADHOC) ?
+				    MODE_ADHOC : MODE_INFRASTRUCTURE;
+	priv->need_commit |= SME_MODE_SET;
 
 	return -EINPROGRESS;	/* Call commit handler */
 }

commit b58e1ddaa25fc07ea995f3a0ccb5fcc0820f61f3
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Apr 24 15:49:56 2018 +0200

    staging: ks7010: remove some duplicated definitions in ks_wlan_net.c
    
    This definitions are in linux/wireless.h header so it is not
    necessary at all to have this compatibility stuff duplicated here.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 2f79e6a797ca..58226789812f 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -43,12 +43,6 @@ struct wep_key {
 	u8 key[16];	/* 40-bit and 104-bit keys */
 };
 
-/* Backward compatibility */
-#ifndef IW_ENCODE_NOKEY
-#define IW_ENCODE_NOKEY 0x0800	/* Key is write only, so not present */
-#define IW_ENCODE_MODE  (IW_ENCODE_DISABLED | IW_ENCODE_RESTRICTED | IW_ENCODE_OPEN)
-#endif /* IW_ENCODE_NOKEY */
-
 /* List of Wireless Handlers (new API) */
 static const struct iw_handler_def ks_wlan_handler_def;
 

commit 5dfd0cfeeee5440b242b2c8578fc41a09aa26430
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:57 2018 +0200

    staging: ks7010: remove KSC_OPNOTSUPP related code
    
    This commit reviews KSC_OPNOTSUPP related code. The
    preprocessor KSC_OPNOTSUPP is defined by default so
    related wext functions are not being used. Just clean
    code removing all of this stuff.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 05cdeb1edb1e..2f79e6a797ca 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -52,8 +52,6 @@ struct wep_key {
 /* List of Wireless Handlers (new API) */
 static const struct iw_handler_def ks_wlan_handler_def;
 
-#define KSC_OPNOTSUPP	/* Operation Not Support */
-
 /*
  *	function prototypes
  */
@@ -934,52 +932,6 @@ static int ks_wlan_get_encode(struct net_device *dev,
 	return 0;
 }
 
-#ifndef KSC_OPNOTSUPP
-static int ks_wlan_set_txpow(struct net_device *dev,
-			     struct iw_request_info *info,
-			     union iwreq_data *vwrq, char *extra)
-{
-	return -EOPNOTSUPP;	/* Not Support */
-}
-
-static int ks_wlan_get_txpow(struct net_device *dev,
-			     struct iw_request_info *info,
-			     union iwreq_data *vwrq, char *extra)
-{
-	if (priv->sleep_mode == SLP_SLEEP)
-		return -EPERM;
-
-	/* for SLEEP MODE */
-	/* Not Support */
-	vwrq->txpower.value = 0;
-	vwrq->txpower.disabled = (vwrq->txpower.value == 0);
-	vwrq->txpower.fixed = 1;
-	return 0;
-}
-
-static int ks_wlan_set_retry(struct net_device *dev,
-			     struct iw_request_info *info,
-			     union iwreq_data *vwrq, char *extra)
-{
-	return -EOPNOTSUPP;	/* Not Support */
-}
-
-static int ks_wlan_get_retry(struct net_device *dev,
-			     struct iw_request_info *info,
-			     union iwreq_data *vwrq, char *extra)
-{
-	if (priv->sleep_mode == SLP_SLEEP)
-		return -EPERM;
-
-	/* for SLEEP MODE */
-	/* Not Support */
-	vwrq->retry.value = 0;
-	vwrq->retry.disabled = (vwrq->retry.value == 0);
-	vwrq->retry.fixed = 1;
-	return 0;
-}
-#endif /* KSC_OPNOTSUPP */
-
 static int ks_wlan_get_range(struct net_device *dev,
 			     struct iw_request_info *info,
 			     union iwreq_data *dwrq, char *extra)
@@ -1167,27 +1119,6 @@ static int ks_wlan_get_iwstats(struct net_device *dev,
 	return 0;
 }
 
-#ifndef KSC_OPNOTSUPP
-
-static int ks_wlan_set_sens(struct net_device *dev,
-			    struct iw_request_info *info,
-			    union iwreq_data *vwrq, char *extra)
-{
-	return -EOPNOTSUPP;	/* Not Support */
-}
-
-static int ks_wlan_get_sens(struct net_device *dev,
-			    struct iw_request_info *info,
-			    union iwreq_data *vwrq, char *extra)
-{
-	/* Not Support */
-	vwrq->sens.value = 0;
-	vwrq->sens.disabled = (vwrq->sens.value == 0);
-	vwrq->sens.fixed = 1;
-	return 0;
-}
-#endif /* KSC_OPNOTSUPP */
-
 /* Note : this is deprecated in favor of IWSCAN */
 static int ks_wlan_get_aplist(struct net_device *dev,
 			      struct iw_request_info *info,
@@ -2540,10 +2471,6 @@ static const iw_handler ks_wlan_handler[] = {
 	IW_HANDLER(SIOCGIWFREQ, ks_wlan_get_freq),
 	IW_HANDLER(SIOCSIWMODE, ks_wlan_set_mode),
 	IW_HANDLER(SIOCGIWMODE, ks_wlan_get_mode),
-#ifndef KSC_OPNOTSUPP
-	IW_HANDLER(SIOCSIWSENS, ks_wlan_set_sens),
-	IW_HANDLER(SIOCGIWSENS, ks_wlan_get_sens),
-#endif /* KSC_OPNOTSUPP */
 	IW_HANDLER(SIOCGIWRANGE, ks_wlan_get_range),
 	IW_HANDLER(SIOCGIWSTATS, ks_wlan_get_iwstats),
 	IW_HANDLER(SIOCSIWAP, ks_wlan_set_wap),
@@ -2562,12 +2489,6 @@ static const iw_handler ks_wlan_handler[] = {
 	IW_HANDLER(SIOCGIWRTS, ks_wlan_get_rts),
 	IW_HANDLER(SIOCSIWFRAG, ks_wlan_set_frag),
 	IW_HANDLER(SIOCGIWFRAG, ks_wlan_get_frag),
-#ifndef KSC_OPNOTSUPP
-	IW_HANDLER(SIOCSIWTXPOW, ks_wlan_set_txpow),
-	IW_HANDLER(SIOCGIWTXPOW, ks_wlan_get_txpow),
-	IW_HANDLER(SIOCSIWRETRY, ks_wlan_set_retry),
-	IW_HANDLER(SIOCGIWRETRY, ks_wlan_get_retry),
-#endif /* KSC_OPNOTSUPP */
 	IW_HANDLER(SIOCSIWENCODE, ks_wlan_set_encode),
 	IW_HANDLER(SIOCGIWENCODE, ks_wlan_get_encode),
 	IW_HANDLER(SIOCSIWPOWER, ks_wlan_set_power),

commit 18e76e23740a4fd86808ef97cb023cf76f7cc942
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:56 2018 +0200

    staging: ks7010: use IW_HANDLER macro in ks_wlan_handler
    
    This commit make use of IW_HANDLER to set wext operations
    of the device. Using this, comments are not neccessary anymore
    and also NULL entries so readability is clearly increased.
    In order to avoid casting because of the use of a different
    prototype in all related functions, those which are affected
    have been updated also to make use of the  union iwreq_data
    as third parameter updating code accordly.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 76ed4ed9d167..05cdeb1edb1e 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -160,7 +160,8 @@ int ks_wlan_setup_parameter(struct ks_wlan_private *priv,
  */
 
 static int ks_wlan_get_name(struct net_device *dev,
-			    struct iw_request_info *info, char *cwrq,
+			    struct iw_request_info *info,
+			    union iwreq_data *cwrq,
 			    char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
@@ -170,20 +171,20 @@ static int ks_wlan_get_name(struct net_device *dev,
 
 	/* for SLEEP MODE */
 	if (priv->dev_state < DEVICE_STATE_READY)
-		strcpy(cwrq, "NOT READY!");
+		strcpy(cwrq->name, "NOT READY!");
 	else if (priv->reg.phy_type == D_11B_ONLY_MODE)
-		strcpy(cwrq, "IEEE 802.11b");
+		strcpy(cwrq->name, "IEEE 802.11b");
 	else if (priv->reg.phy_type == D_11G_ONLY_MODE)
-		strcpy(cwrq, "IEEE 802.11g");
+		strcpy(cwrq->name, "IEEE 802.11g");
 	else
-		strcpy(cwrq, "IEEE 802.11b/g");
+		strcpy(cwrq->name, "IEEE 802.11b/g");
 
 	return 0;
 }
 
 static int ks_wlan_set_freq(struct net_device *dev,
-			    struct iw_request_info *info, struct iw_freq *fwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *fwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	int channel;
@@ -193,28 +194,28 @@ static int ks_wlan_set_freq(struct net_device *dev,
 
 	/* for SLEEP MODE */
 	/* If setting by frequency, convert to a channel */
-	if ((fwrq->e == 1) &&
-	    (fwrq->m >= (int)2.412e8) && (fwrq->m <= (int)2.487e8)) {
-		int f = fwrq->m / 100000;
+	if ((fwrq->freq.e == 1) &&
+	    (fwrq->freq.m >= (int)2.412e8) && (fwrq->freq.m <= (int)2.487e8)) {
+		int f = fwrq->freq.m / 100000;
 		int c = 0;
 
 		while ((c < 14) && (f != frequency_list[c]))
 			c++;
 		/* Hack to fall through... */
-		fwrq->e = 0;
-		fwrq->m = c + 1;
+		fwrq->freq.e = 0;
+		fwrq->freq.m = c + 1;
 	}
 	/* Setting by channel number */
-	if ((fwrq->m > 1000) || (fwrq->e > 0))
+	if ((fwrq->freq.m > 1000) || (fwrq->freq.e > 0))
 		return -EOPNOTSUPP;
 
-	channel = fwrq->m;
+	channel = fwrq->freq.m;
 	/* We should do a better check than that,
 	 * based on the card capability !!!
 	 */
 	if ((channel < 1) || (channel > 14)) {
 		netdev_dbg(dev, "%s: New channel value of %d is invalid!\n",
-			   dev->name, fwrq->m);
+			   dev->name, fwrq->freq.m);
 		return -EINVAL;
 	}
 
@@ -226,8 +227,8 @@ static int ks_wlan_set_freq(struct net_device *dev,
 }
 
 static int ks_wlan_get_freq(struct net_device *dev,
-			    struct iw_request_info *info, struct iw_freq *fwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *fwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	int f;
@@ -241,15 +242,15 @@ static int ks_wlan_get_freq(struct net_device *dev,
 	else
 		f = (int)priv->reg.channel;
 
-	fwrq->m = frequency_list[f - 1] * 100000;
-	fwrq->e = 1;
+	fwrq->freq.m = frequency_list[f - 1] * 100000;
+	fwrq->freq.e = 1;
 
 	return 0;
 }
 
 static int ks_wlan_set_essid(struct net_device *dev,
 			     struct iw_request_info *info,
-			     struct iw_point *dwrq, char *extra)
+			     union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	size_t len;
@@ -259,12 +260,12 @@ static int ks_wlan_set_essid(struct net_device *dev,
 
 	/* for SLEEP MODE */
 	/* Check if we asked for `any' */
-	if (!dwrq->flags) {
+	if (!dwrq->essid.flags) {
 		/* Just send an empty SSID list */
 		memset(priv->reg.ssid.body, 0, sizeof(priv->reg.ssid.body));
 		priv->reg.ssid.size = 0;
 	} else {
-		len = dwrq->length;
+		len = dwrq->essid.length;
 		/* iwconfig uses nul termination in SSID.. */
 		if (len > 0 && extra[len - 1] == '\0')
 			len--;
@@ -288,7 +289,7 @@ static int ks_wlan_set_essid(struct net_device *dev,
 
 static int ks_wlan_get_essid(struct net_device *dev,
 			     struct iw_request_info *info,
-			     struct iw_point *dwrq, char *extra)
+			     union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -306,18 +307,18 @@ static int ks_wlan_get_essid(struct net_device *dev,
 		/* If none, we may want to get the one that was set */
 
 		/* Push it out ! */
-		dwrq->length = priv->reg.ssid.size;
-		dwrq->flags = 1;	/* active */
+		dwrq->essid.length = priv->reg.ssid.size;
+		dwrq->essid.flags = 1;	/* active */
 	} else {
-		dwrq->length = 0;
-		dwrq->flags = 0;	/* ANY */
+		dwrq->essid.length = 0;
+		dwrq->essid.flags = 0;	/* ANY */
 	}
 
 	return 0;
 }
 
 static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
-			   struct sockaddr *ap_addr, char *extra)
+			   union iwreq_data *awrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -327,7 +328,7 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 	/* for SLEEP MODE */
 	if (priv->reg.operation_mode == MODE_ADHOC ||
 	    priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
-		memcpy(priv->reg.bssid, &ap_addr->sa_data, ETH_ALEN);
+		memcpy(priv->reg.bssid, &awrq->ap_addr.sa_data, ETH_ALEN);
 
 		if (is_valid_ether_addr((u8 *)priv->reg.bssid))
 			priv->need_commit |= SME_MODE_SET;
@@ -348,7 +349,7 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 }
 
 static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
-			   struct sockaddr *awrq, char *extra)
+			   union iwreq_data *awrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -357,18 +358,18 @@ static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 
 	/* for SLEEP MODE */
 	if (is_connect_status(priv->connect_status))
-		memcpy(awrq->sa_data, priv->current_ap.bssid, ETH_ALEN);
+		memcpy(awrq->ap_addr.sa_data, priv->current_ap.bssid, ETH_ALEN);
 	else
-		eth_zero_addr(awrq->sa_data);
+		eth_zero_addr(awrq->ap_addr.sa_data);
 
-	awrq->sa_family = ARPHRD_ETHER;
+	awrq->ap_addr.sa_family = ARPHRD_ETHER;
 
 	return 0;
 }
 
 static int ks_wlan_set_nick(struct net_device *dev,
-			    struct iw_request_info *info, struct iw_point *dwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -377,18 +378,18 @@ static int ks_wlan_set_nick(struct net_device *dev,
 
 	/* for SLEEP MODE */
 	/* Check the size of the string */
-	if (dwrq->length > 16 + 1)
+	if (dwrq->data.length > 16 + 1)
 		return -E2BIG;
 
 	memset(priv->nick, 0, sizeof(priv->nick));
-	memcpy(priv->nick, extra, dwrq->length);
+	memcpy(priv->nick, extra, dwrq->data.length);
 
 	return -EINPROGRESS;	/* Call commit handler */
 }
 
 static int ks_wlan_get_nick(struct net_device *dev,
-			    struct iw_request_info *info, struct iw_point *dwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -398,14 +399,14 @@ static int ks_wlan_get_nick(struct net_device *dev,
 	/* for SLEEP MODE */
 	strncpy(extra, priv->nick, 16);
 	extra[16] = '\0';
-	dwrq->length = strlen(extra) + 1;
+	dwrq->data.length = strlen(extra) + 1;
 
 	return 0;
 }
 
 static int ks_wlan_set_rate(struct net_device *dev,
-			    struct iw_request_info *info, struct iw_param *vwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *vwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	int i = 0;
@@ -415,17 +416,17 @@ static int ks_wlan_set_rate(struct net_device *dev,
 
 	/* for SLEEP MODE */
 	if (priv->reg.phy_type == D_11B_ONLY_MODE) {
-		if (vwrq->fixed == 1) {
-			switch (vwrq->value) {
+		if (vwrq->bitrate.fixed == 1) {
+			switch (vwrq->bitrate.value) {
 			case 11000000:
 			case 5500000:
 				priv->reg.rate_set.body[0] =
-				    (uint8_t)(vwrq->value / 500000);
+				    (uint8_t)(vwrq->bitrate.value / 500000);
 				break;
 			case 2000000:
 			case 1000000:
 				priv->reg.rate_set.body[0] =
-				    ((uint8_t)(vwrq->value / 500000)) |
+				    ((uint8_t)(vwrq->bitrate.value / 500000)) |
 				    BASIC_RATE;
 				break;
 			default:
@@ -434,8 +435,8 @@ static int ks_wlan_set_rate(struct net_device *dev,
 			priv->reg.tx_rate = TX_RATE_FIXED;
 			priv->reg.rate_set.size = 1;
 		} else {	/* vwrq->fixed == 0 */
-			if (vwrq->value > 0) {
-				switch (vwrq->value) {
+			if (vwrq->bitrate.value > 0) {
+				switch (vwrq->bitrate.value) {
 				case 11000000:
 					priv->reg.rate_set.body[3] =
 					    TX_RATE_11M;
@@ -472,15 +473,15 @@ static int ks_wlan_set_rate(struct net_device *dev,
 			}
 		}
 	} else {	/* D_11B_ONLY_MODE or  D_11BG_COMPATIBLE_MODE */
-		if (vwrq->fixed == 1) {
-			switch (vwrq->value) {
+		if (vwrq->bitrate.fixed == 1) {
+			switch (vwrq->bitrate.value) {
 			case 54000000:
 			case 48000000:
 			case 36000000:
 			case 18000000:
 			case 9000000:
 				priv->reg.rate_set.body[0] =
-				    (uint8_t)(vwrq->value / 500000);
+				    (uint8_t)(vwrq->bitrate.value / 500000);
 				break;
 			case 24000000:
 			case 12000000:
@@ -490,7 +491,7 @@ static int ks_wlan_set_rate(struct net_device *dev,
 			case 2000000:
 			case 1000000:
 				priv->reg.rate_set.body[0] =
-				    ((uint8_t)(vwrq->value / 500000)) |
+				    ((uint8_t)(vwrq->bitrate.value / 500000)) |
 				    BASIC_RATE;
 				break;
 			default:
@@ -499,8 +500,8 @@ static int ks_wlan_set_rate(struct net_device *dev,
 			priv->reg.tx_rate = TX_RATE_FIXED;
 			priv->reg.rate_set.size = 1;
 		} else {	/* vwrq->fixed == 0 */
-			if (vwrq->value > 0) {
-				switch (vwrq->value) {
+			if (vwrq->bitrate.value > 0) {
+				switch (vwrq->bitrate.value) {
 				case 54000000:
 					priv->reg.rate_set.body[11] =
 					    TX_RATE_54M;
@@ -522,7 +523,7 @@ static int ks_wlan_set_rate(struct net_device *dev,
 				case 11000000:
 				case 9000000:
 				case 6000000:
-					if (vwrq->value == 24000000) {
+					if (vwrq->bitrate.value == 24000000) {
 						priv->reg.rate_set.body[8] =
 						    TX_RATE_18M;
 						i++;
@@ -541,7 +542,7 @@ static int ks_wlan_set_rate(struct net_device *dev,
 						priv->reg.rate_set.body[3] =
 						    TX_RATE_11M | BASIC_RATE;
 						i++;
-					} else if (vwrq->value == 18000000) {
+					} else if (vwrq->bitrate.value == 18000000) {
 						priv->reg.rate_set.body[7] =
 						    TX_RATE_18M;
 						i++;
@@ -557,7 +558,7 @@ static int ks_wlan_set_rate(struct net_device *dev,
 						priv->reg.rate_set.body[3] =
 						    TX_RATE_11M | BASIC_RATE;
 						i++;
-					} else if (vwrq->value == 12000000) {
+					} else if (vwrq->bitrate.value == 12000000) {
 						priv->reg.rate_set.body[6] =
 						    TX_RATE_9M;
 						i++;
@@ -570,7 +571,7 @@ static int ks_wlan_set_rate(struct net_device *dev,
 						priv->reg.rate_set.body[3] =
 						    TX_RATE_11M | BASIC_RATE;
 						i++;
-					} else if (vwrq->value == 11000000) {
+					} else if (vwrq->bitrate.value == 11000000) {
 						priv->reg.rate_set.body[5] =
 						    TX_RATE_9M;
 						i++;
@@ -580,7 +581,7 @@ static int ks_wlan_set_rate(struct net_device *dev,
 						priv->reg.rate_set.body[3] =
 						    TX_RATE_11M | BASIC_RATE;
 						i++;
-					} else if (vwrq->value == 9000000) {
+					} else if (vwrq->bitrate.value == 9000000) {
 						priv->reg.rate_set.body[4] =
 						    TX_RATE_9M;
 						i++;
@@ -645,8 +646,8 @@ static int ks_wlan_set_rate(struct net_device *dev,
 }
 
 static int ks_wlan_get_rate(struct net_device *dev,
-			    struct iw_request_info *info, struct iw_param *vwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *vwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -660,23 +661,23 @@ static int ks_wlan_get_rate(struct net_device *dev,
 	if (!atomic_read(&update_phyinfo))
 		ks_wlan_update_phy_information(priv);
 
-	vwrq->value = ((priv->current_rate) & RATE_MASK) * 500000;
-	vwrq->fixed = (priv->reg.tx_rate == TX_RATE_FIXED) ? 1 : 0;
+	vwrq->bitrate.value = ((priv->current_rate) & RATE_MASK) * 500000;
+	vwrq->bitrate.fixed = (priv->reg.tx_rate == TX_RATE_FIXED) ? 1 : 0;
 
 	return 0;
 }
 
 static int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
-			   struct iw_param *vwrq, char *extra)
+			   union iwreq_data *vwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
-	int rthr = vwrq->value;
+	int rthr = vwrq->rts.value;
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	if (vwrq->disabled)
+	if (vwrq->rts.disabled)
 		rthr = 2347;
 	if ((rthr < 0) || (rthr > 2347))
 		return -EINVAL;
@@ -688,7 +689,7 @@ static int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
 }
 
 static int ks_wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
-			   struct iw_param *vwrq, char *extra)
+			   union iwreq_data *vwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -696,25 +697,25 @@ static int ks_wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	vwrq->value = priv->reg.rts;
-	vwrq->disabled = (vwrq->value >= 2347);
-	vwrq->fixed = 1;
+	vwrq->rts.value = priv->reg.rts;
+	vwrq->rts.disabled = (vwrq->rts.value >= 2347);
+	vwrq->rts.fixed = 1;
 
 	return 0;
 }
 
 static int ks_wlan_set_frag(struct net_device *dev,
-			    struct iw_request_info *info, struct iw_param *vwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *vwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
-	int fthr = vwrq->value;
+	int fthr = vwrq->frag.value;
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	if (vwrq->disabled)
+	if (vwrq->frag.disabled)
 		fthr = 2346;
 	if ((fthr < 256) || (fthr > 2346))
 		return -EINVAL;
@@ -727,8 +728,8 @@ static int ks_wlan_set_frag(struct net_device *dev,
 }
 
 static int ks_wlan_get_frag(struct net_device *dev,
-			    struct iw_request_info *info, struct iw_param *vwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *vwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -736,16 +737,16 @@ static int ks_wlan_get_frag(struct net_device *dev,
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	vwrq->value = priv->reg.fragment;
-	vwrq->disabled = (vwrq->value >= 2346);
-	vwrq->fixed = 1;
+	vwrq->frag.value = priv->reg.fragment;
+	vwrq->frag.disabled = (vwrq->frag.value >= 2346);
+	vwrq->frag.fixed = 1;
 
 	return 0;
 }
 
 static int ks_wlan_set_mode(struct net_device *dev,
-			    struct iw_request_info *info, __u32 *uwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *uwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -753,7 +754,7 @@ static int ks_wlan_set_mode(struct net_device *dev,
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	switch (*uwrq) {
+	switch (uwrq->mode) {
 	case IW_MODE_ADHOC:
 		priv->reg.operation_mode = MODE_ADHOC;
 		priv->need_commit |= SME_MODE_SET;
@@ -775,8 +776,8 @@ static int ks_wlan_set_mode(struct net_device *dev,
 }
 
 static int ks_wlan_get_mode(struct net_device *dev,
-			    struct iw_request_info *info, __u32 *uwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *uwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -787,13 +788,13 @@ static int ks_wlan_get_mode(struct net_device *dev,
 	/* If not managed, assume it's ad-hoc */
 	switch (priv->reg.operation_mode) {
 	case MODE_INFRASTRUCTURE:
-		*uwrq = IW_MODE_INFRA;
+		uwrq->mode = IW_MODE_INFRA;
 		break;
 	case MODE_ADHOC:
-		*uwrq = IW_MODE_ADHOC;
+		uwrq->mode = IW_MODE_ADHOC;
 		break;
 	default:
-		*uwrq = IW_MODE_ADHOC;
+		uwrq->mode = IW_MODE_ADHOC;
 	}
 
 	return 0;
@@ -801,16 +802,17 @@ static int ks_wlan_get_mode(struct net_device *dev,
 
 static int ks_wlan_set_encode(struct net_device *dev,
 			      struct iw_request_info *info,
-			      struct iw_point *dwrq, char *extra)
+			      union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
+	struct iw_point *enc = &dwrq->encoding;
 	struct wep_key key;
-	int index = (dwrq->flags & IW_ENCODE_INDEX);
+	int index = (enc->flags & IW_ENCODE_INDEX);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
-	if (dwrq->length > MAX_KEY_SIZE)
+	if (enc->length > MAX_KEY_SIZE)
 		return -EINVAL;
 
 	/* for SLEEP MODE */
@@ -821,21 +823,21 @@ static int ks_wlan_set_encode(struct net_device *dev,
 
 	/* Is WEP supported ? */
 	/* Basic checking: do we have a key to set ? */
-	if (dwrq->length > 0) {
-		key.len = (dwrq->length > MIN_KEY_SIZE) ?
+	if (enc->length > 0) {
+		key.len = (enc->length > MIN_KEY_SIZE) ?
 			   MAX_KEY_SIZE : MIN_KEY_SIZE;
 		priv->reg.privacy_invoked = 0x01;
 		priv->need_commit |= SME_WEP_FLAG;
-		wep_on_off = (dwrq->length > MIN_KEY_SIZE) ?
+		wep_on_off = (enc->length > MIN_KEY_SIZE) ?
 			      WEP_ON_128BIT : WEP_ON_64BIT;
 		/* Check if the key is not marked as invalid */
-		if (dwrq->flags & IW_ENCODE_NOKEY)
+		if (enc->flags & IW_ENCODE_NOKEY)
 			return 0;
 
 		/* Cleanup */
 		memset(key.key, 0, MAX_KEY_SIZE);
 		/* Copy the key in the driver */
-		if (copy_from_user(key.key, dwrq->pointer, dwrq->length)) {
+		if (copy_from_user(key.key, enc->pointer, enc->length)) {
 			key.len = 0;
 			return -EFAULT;
 		}
@@ -847,7 +849,7 @@ static int ks_wlan_set_encode(struct net_device *dev,
 		priv->reg.wep_index = index;
 		priv->need_commit |= SME_WEP_INDEX;
 	} else {
-		if (dwrq->flags & IW_ENCODE_DISABLED) {
+		if (enc->flags & IW_ENCODE_DISABLED) {
 			priv->reg.wep_key[0].size = 0;
 			priv->reg.wep_key[1].size = 0;
 			priv->reg.wep_key[2].size = 0;
@@ -869,15 +871,15 @@ static int ks_wlan_set_encode(struct net_device *dev,
 	}
 
 	/* Commit the changes if needed */
-	if (dwrq->flags & IW_ENCODE_MODE)
+	if (enc->flags & IW_ENCODE_MODE)
 		priv->need_commit |= SME_WEP_FLAG;
 
-	if (dwrq->flags & IW_ENCODE_OPEN) {
+	if (enc->flags & IW_ENCODE_OPEN) {
 		if (priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY)
 			priv->need_commit |= SME_MODE_SET;
 
 		priv->reg.authenticate_type = AUTH_TYPE_OPEN_SYSTEM;
-	} else if (dwrq->flags & IW_ENCODE_RESTRICTED) {
+	} else if (enc->flags & IW_ENCODE_RESTRICTED) {
 		if (priv->reg.authenticate_type == AUTH_TYPE_OPEN_SYSTEM)
 			priv->need_commit |= SME_MODE_SET;
 
@@ -892,24 +894,25 @@ static int ks_wlan_set_encode(struct net_device *dev,
 
 static int ks_wlan_get_encode(struct net_device *dev,
 			      struct iw_request_info *info,
-			      struct iw_point *dwrq, char *extra)
+			      union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
-	int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
+	struct iw_point *enc = &dwrq->encoding;
+	int index = (enc->flags & IW_ENCODE_INDEX) - 1;
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	dwrq->flags = IW_ENCODE_DISABLED;
+	enc->flags = IW_ENCODE_DISABLED;
 
 	/* Check encryption mode */
 	switch (priv->reg.authenticate_type) {
 	case AUTH_TYPE_OPEN_SYSTEM:
-		dwrq->flags = IW_ENCODE_OPEN;
+		enc->flags = IW_ENCODE_OPEN;
 		break;
 	case AUTH_TYPE_SHARED_KEY:
-		dwrq->flags = IW_ENCODE_RESTRICTED;
+		enc->flags = IW_ENCODE_RESTRICTED;
 		break;
 	}
 
@@ -917,15 +920,15 @@ static int ks_wlan_get_encode(struct net_device *dev,
 	if ((index < 0) || (index >= 4))
 		index = priv->reg.wep_index;
 	if (priv->reg.privacy_invoked) {
-		dwrq->flags &= ~IW_ENCODE_DISABLED;
+		enc->flags &= ~IW_ENCODE_DISABLED;
 		/* dwrq->flags |= IW_ENCODE_NOKEY; */
 	}
-	dwrq->flags |= index + 1;
+	enc->flags |= index + 1;
 	/* Copy the key to the user buffer */
 	if (index >= 0 && index < 4) {
-		dwrq->length = (priv->reg.wep_key[index].size <= 16) ?
+		enc->length = (priv->reg.wep_key[index].size <= 16) ?
 				priv->reg.wep_key[index].size : 0;
-		memcpy(extra, priv->reg.wep_key[index].val, dwrq->length);
+		memcpy(extra, priv->reg.wep_key[index].val, enc->length);
 	}
 
 	return 0;
@@ -934,52 +937,52 @@ static int ks_wlan_get_encode(struct net_device *dev,
 #ifndef KSC_OPNOTSUPP
 static int ks_wlan_set_txpow(struct net_device *dev,
 			     struct iw_request_info *info,
-			     struct iw_param *vwrq, char *extra)
+			     union iwreq_data *vwrq, char *extra)
 {
 	return -EOPNOTSUPP;	/* Not Support */
 }
 
 static int ks_wlan_get_txpow(struct net_device *dev,
 			     struct iw_request_info *info,
-			     struct iw_param *vwrq, char *extra)
+			     union iwreq_data *vwrq, char *extra)
 {
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
 	/* for SLEEP MODE */
 	/* Not Support */
-	vwrq->value = 0;
-	vwrq->disabled = (vwrq->value == 0);
-	vwrq->fixed = 1;
+	vwrq->txpower.value = 0;
+	vwrq->txpower.disabled = (vwrq->txpower.value == 0);
+	vwrq->txpower.fixed = 1;
 	return 0;
 }
 
 static int ks_wlan_set_retry(struct net_device *dev,
 			     struct iw_request_info *info,
-			     struct iw_param *vwrq, char *extra)
+			     union iwreq_data *vwrq, char *extra)
 {
 	return -EOPNOTSUPP;	/* Not Support */
 }
 
 static int ks_wlan_get_retry(struct net_device *dev,
 			     struct iw_request_info *info,
-			     struct iw_param *vwrq, char *extra)
+			     union iwreq_data *vwrq, char *extra)
 {
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
 	/* for SLEEP MODE */
 	/* Not Support */
-	vwrq->value = 0;
-	vwrq->disabled = (vwrq->value == 0);
-	vwrq->fixed = 1;
+	vwrq->retry.value = 0;
+	vwrq->retry.disabled = (vwrq->retry.value == 0);
+	vwrq->retry.fixed = 1;
 	return 0;
 }
 #endif /* KSC_OPNOTSUPP */
 
 static int ks_wlan_get_range(struct net_device *dev,
 			     struct iw_request_info *info,
-			     struct iw_point *dwrq, char *extra)
+			     union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_range *range = (struct iw_range *)extra;
@@ -989,7 +992,7 @@ static int ks_wlan_get_range(struct net_device *dev,
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	dwrq->length = sizeof(struct iw_range);
+	dwrq->data.length = sizeof(struct iw_range);
 	memset(range, 0, sizeof(*range));
 	range->min_nwid = 0x0000;
 	range->max_nwid = 0x0000;
@@ -1109,14 +1112,14 @@ static int ks_wlan_get_range(struct net_device *dev,
 
 static int ks_wlan_set_power(struct net_device *dev,
 			     struct iw_request_info *info,
-			     struct iw_param *vwrq, char *extra)
+			     union iwreq_data *vwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
-	if (vwrq->disabled) {
+	if (vwrq->power.disabled) {
 		priv->reg.power_mgmt = POWER_MGMT_ACTIVE;
 	} else {
 		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
@@ -1132,7 +1135,7 @@ static int ks_wlan_set_power(struct net_device *dev,
 
 static int ks_wlan_get_power(struct net_device *dev,
 			     struct iw_request_info *info,
-			     struct iw_param *vwrq, char *extra)
+			     union iwreq_data *vwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -1140,26 +1143,26 @@ static int ks_wlan_get_power(struct net_device *dev,
 		return -EPERM;
 	/* for SLEEP MODE */
 	if (priv->reg.power_mgmt > 0)
-		vwrq->disabled = 0;
+		vwrq->power.disabled = 0;
 	else
-		vwrq->disabled = 1;
+		vwrq->power.disabled = 1;
 
 	return 0;
 }
 
 static int ks_wlan_get_iwstats(struct net_device *dev,
 			       struct iw_request_info *info,
-			       struct iw_quality *vwrq, char *extra)
+			       union iwreq_data *vwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	vwrq->qual = 0;	/* not supported */
-	vwrq->level = priv->wstats.qual.level;
-	vwrq->noise = 0;	/* not supported */
-	vwrq->updated = 0;
+	vwrq->qual.qual = 0;	/* not supported */
+	vwrq->qual.level = priv->wstats.qual.level;
+	vwrq->qual.noise = 0;	/* not supported */
+	vwrq->qual.updated = 0;
 
 	return 0;
 }
@@ -1167,20 +1170,20 @@ static int ks_wlan_get_iwstats(struct net_device *dev,
 #ifndef KSC_OPNOTSUPP
 
 static int ks_wlan_set_sens(struct net_device *dev,
-			    struct iw_request_info *info, struct iw_param *vwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *vwrq, char *extra)
 {
 	return -EOPNOTSUPP;	/* Not Support */
 }
 
 static int ks_wlan_get_sens(struct net_device *dev,
-			    struct iw_request_info *info, struct iw_param *vwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *vwrq, char *extra)
 {
 	/* Not Support */
-	vwrq->value = 0;
-	vwrq->disabled = (vwrq->value == 0);
-	vwrq->fixed = 1;
+	vwrq->sens.value = 0;
+	vwrq->sens.disabled = (vwrq->sens.value == 0);
+	vwrq->sens.fixed = 1;
 	return 0;
 }
 #endif /* KSC_OPNOTSUPP */
@@ -1188,7 +1191,7 @@ static int ks_wlan_get_sens(struct net_device *dev,
 /* Note : this is deprecated in favor of IWSCAN */
 static int ks_wlan_get_aplist(struct net_device *dev,
 			      struct iw_request_info *info,
-			      struct iw_point *dwrq, char *extra)
+			      union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct sockaddr *address = (struct sockaddr *)extra;
@@ -1209,11 +1212,11 @@ static int ks_wlan_get_aplist(struct net_device *dev,
 		qual[i].updated = 7;
 	}
 	if (i) {
-		dwrq->flags = 1;	/* Should be define'd */
+		dwrq->data.flags = 1;	/* Should be define'd */
 		memcpy(extra + sizeof(struct sockaddr) * i,
 		       &qual, sizeof(struct iw_quality) * i);
 	}
-	dwrq->length = i;
+	dwrq->data.length = i;
 
 	return 0;
 }
@@ -1410,8 +1413,8 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 }
 
 static int ks_wlan_get_scan(struct net_device *dev,
-			    struct iw_request_info *info, struct iw_point *dwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	int i;
@@ -1432,25 +1435,26 @@ static int ks_wlan_get_scan(struct net_device *dev,
 
 	/* Read and parse all entries */
 	for (i = 0; i < priv->aplist.size; i++) {
-		if ((extra + dwrq->length) - current_ev <= IW_EV_ADDR_LEN) {
-			dwrq->length = 0;
+		if ((extra + dwrq->data.length) - current_ev <= IW_EV_ADDR_LEN) {
+			dwrq->data.length = 0;
 			return -E2BIG;
 		}
 		/* Translate to WE format this entry */
 		current_ev = ks_wlan_translate_scan(dev, info, current_ev,
-						    extra + dwrq->length,
+						    extra + dwrq->data.length,
 						    &priv->aplist.ap[i]);
 	}
 	/* Length of data */
-	dwrq->length = (current_ev - extra);
-	dwrq->flags = 0;
+	dwrq->data.length = (current_ev - extra);
+	dwrq->data.flags = 0;
 
 	return 0;
 }
 
 /* called after a bunch of SET operations */
 static int ks_wlan_config_commit(struct net_device *dev,
-				 struct iw_request_info *info, void *zwrq,
+				 struct iw_request_info *info,
+				 union iwreq_data *zwrq,
 				 char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
@@ -1466,7 +1470,7 @@ static int ks_wlan_config_commit(struct net_device *dev,
 /* set association ie params */
 static int ks_wlan_set_genie(struct net_device *dev,
 			     struct iw_request_info *info,
-			     struct iw_point *dwrq, char *extra)
+			     union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -1479,11 +1483,12 @@ static int ks_wlan_set_genie(struct net_device *dev,
 
 static int ks_wlan_set_auth_mode(struct net_device *dev,
 				 struct iw_request_info *info,
-				 struct iw_param *vwrq, char *extra)
+				 union iwreq_data *vwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
-	int index = (vwrq->flags & IW_AUTH_INDEX);
-	int value = vwrq->value;
+	struct iw_param *param = &vwrq->param;
+	int index = (param->flags & IW_AUTH_INDEX);
+	int value = param->value;
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -1611,10 +1616,11 @@ static int ks_wlan_set_auth_mode(struct net_device *dev,
 
 static int ks_wlan_get_auth_mode(struct net_device *dev,
 				 struct iw_request_info *info,
-				 struct iw_param *vwrq, char *extra)
+				 union iwreq_data *vwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
-	int index = (vwrq->flags & IW_AUTH_INDEX);
+	struct iw_param *param = &vwrq->param;
+	int index = (param->flags & IW_AUTH_INDEX);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -1623,22 +1629,22 @@ static int ks_wlan_get_auth_mode(struct net_device *dev,
 	/*  WPA (not used ?? wpa_supplicant) */
 	switch (index) {
 	case IW_AUTH_WPA_VERSION:
-		vwrq->value = priv->wpa.version;
+		param->value = priv->wpa.version;
 		break;
 	case IW_AUTH_CIPHER_PAIRWISE:
-		vwrq->value = priv->wpa.pairwise_suite;
+		param->value = priv->wpa.pairwise_suite;
 		break;
 	case IW_AUTH_CIPHER_GROUP:
-		vwrq->value = priv->wpa.group_suite;
+		param->value = priv->wpa.group_suite;
 		break;
 	case IW_AUTH_KEY_MGMT:
-		vwrq->value = priv->wpa.key_mgmt_suite;
+		param->value = priv->wpa.key_mgmt_suite;
 		break;
 	case IW_AUTH_80211_AUTH_ALG:
-		vwrq->value = priv->wpa.auth_alg;
+		param->value = priv->wpa.auth_alg;
 		break;
 	case IW_AUTH_WPA_ENABLED:
-		vwrq->value = priv->wpa.rsn_enabled;
+		param->value = priv->wpa.rsn_enabled;
 		break;
 	case IW_AUTH_RX_UNENCRYPTED_EAPOL:	/* OK??? */
 	case IW_AUTH_TKIP_COUNTERMEASURES:
@@ -1653,11 +1659,11 @@ static int ks_wlan_get_auth_mode(struct net_device *dev,
 /* set encoding token & mode (WPA)*/
 static int ks_wlan_set_encode_ext(struct net_device *dev,
 				  struct iw_request_info *info,
-				  struct iw_point *dwrq, char *extra)
+				  union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_encode_ext *enc;
-	int index = dwrq->flags & IW_ENCODE_INDEX;
+	int index = dwrq->encoding.flags & IW_ENCODE_INDEX;
 	unsigned int commit = 0;
 	struct wpa_key *key;
 
@@ -1674,7 +1680,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	index--;
 	key = &priv->wpa.key[index];
 
-	if (dwrq->flags & IW_ENCODE_DISABLED)
+	if (dwrq->encoding.flags & IW_ENCODE_DISABLED)
 		key->key_len = 0;
 
 	key->ext_flags = enc->ext_flags;
@@ -1746,7 +1752,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 /* get encoding token & mode (WPA)*/
 static int ks_wlan_get_encode_ext(struct net_device *dev,
 				  struct iw_request_info *info,
-				  struct iw_point *dwrq, char *extra)
+				  union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -1766,7 +1772,7 @@ static int ks_wlan_get_encode_ext(struct net_device *dev,
 
 static int ks_wlan_set_pmksa(struct net_device *dev,
 			     struct iw_request_info *info,
-			     struct iw_point *dwrq, char *extra)
+			     union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_pmksa *pmksa;
@@ -1906,8 +1912,8 @@ static int ks_wlan_set_stop_request(struct net_device *dev,
 
 #include <linux/ieee80211.h>
 static int ks_wlan_set_mlme(struct net_device *dev,
-			    struct iw_request_info *info, struct iw_point *dwrq,
-			    char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_mlme *mlme = (struct iw_mlme *)extra;
@@ -2528,76 +2534,50 @@ static const struct iw_priv_args ks_wlan_private_args[] = {
 };
 
 static const iw_handler ks_wlan_handler[] = {
-	(iw_handler)ks_wlan_config_commit,	/* SIOCSIWCOMMIT */
-	(iw_handler)ks_wlan_get_name,	/* SIOCGIWNAME */
-	(iw_handler)NULL,	/* SIOCSIWNWID */
-	(iw_handler)NULL,	/* SIOCGIWNWID */
-	(iw_handler)ks_wlan_set_freq,	/* SIOCSIWFREQ */
-	(iw_handler)ks_wlan_get_freq,	/* SIOCGIWFREQ */
-	(iw_handler)ks_wlan_set_mode,	/* SIOCSIWMODE */
-	(iw_handler)ks_wlan_get_mode,	/* SIOCGIWMODE */
+	IW_HANDLER(SIOCSIWCOMMIT, ks_wlan_config_commit),
+	IW_HANDLER(SIOCGIWNAME, ks_wlan_get_name),
+	IW_HANDLER(SIOCSIWFREQ, ks_wlan_set_freq),
+	IW_HANDLER(SIOCGIWFREQ, ks_wlan_get_freq),
+	IW_HANDLER(SIOCSIWMODE, ks_wlan_set_mode),
+	IW_HANDLER(SIOCGIWMODE, ks_wlan_get_mode),
 #ifndef KSC_OPNOTSUPP
-	(iw_handler)ks_wlan_set_sens,	/* SIOCSIWSENS */
-	(iw_handler)ks_wlan_get_sens,	/* SIOCGIWSENS */
-#else /* KSC_OPNOTSUPP */
-	(iw_handler)NULL,	/* SIOCSIWSENS */
-	(iw_handler)NULL,	/* SIOCGIWSENS */
+	IW_HANDLER(SIOCSIWSENS, ks_wlan_set_sens),
+	IW_HANDLER(SIOCGIWSENS, ks_wlan_get_sens),
 #endif /* KSC_OPNOTSUPP */
-	(iw_handler)NULL,	/* SIOCSIWRANGE */
-	(iw_handler)ks_wlan_get_range,	/* SIOCGIWRANGE */
-	(iw_handler)NULL,	/* SIOCSIWPRIV */
-	(iw_handler)NULL,	/* SIOCGIWPRIV */
-	(iw_handler)NULL,	/* SIOCSIWSTATS */
-	(iw_handler)ks_wlan_get_iwstats,	/* SIOCGIWSTATS */
-	(iw_handler)NULL,	/* SIOCSIWSPY */
-	(iw_handler)NULL,	/* SIOCGIWSPY */
-	(iw_handler)NULL,	/* SIOCSIWTHRSPY */
-	(iw_handler)NULL,	/* SIOCGIWTHRSPY */
-	(iw_handler)ks_wlan_set_wap,	/* SIOCSIWAP */
-	(iw_handler)ks_wlan_get_wap,	/* SIOCGIWAP */
-//      (iw_handler)NULL,                      /* SIOCSIWMLME */
-	(iw_handler)ks_wlan_set_mlme,	/* SIOCSIWMLME */
-	(iw_handler)ks_wlan_get_aplist,	/* SIOCGIWAPLIST */
-	(iw_handler)ks_wlan_set_scan,	/* SIOCSIWSCAN */
-	(iw_handler)ks_wlan_get_scan,	/* SIOCGIWSCAN */
-	(iw_handler)ks_wlan_set_essid,	/* SIOCSIWESSID */
-	(iw_handler)ks_wlan_get_essid,	/* SIOCGIWESSID */
-	(iw_handler)ks_wlan_set_nick,	/* SIOCSIWNICKN */
-	(iw_handler)ks_wlan_get_nick,	/* SIOCGIWNICKN */
-	(iw_handler)NULL,	/* -- hole -- */
-	(iw_handler)NULL,	/* -- hole -- */
-	(iw_handler)ks_wlan_set_rate,	/* SIOCSIWRATE */
-	(iw_handler)ks_wlan_get_rate,	/* SIOCGIWRATE */
-	(iw_handler)ks_wlan_set_rts,	/* SIOCSIWRTS */
-	(iw_handler)ks_wlan_get_rts,	/* SIOCGIWRTS */
-	(iw_handler)ks_wlan_set_frag,	/* SIOCSIWFRAG */
-	(iw_handler)ks_wlan_get_frag,	/* SIOCGIWFRAG */
+	IW_HANDLER(SIOCGIWRANGE, ks_wlan_get_range),
+	IW_HANDLER(SIOCGIWSTATS, ks_wlan_get_iwstats),
+	IW_HANDLER(SIOCSIWAP, ks_wlan_set_wap),
+	IW_HANDLER(SIOCGIWAP, ks_wlan_get_wap),
+	IW_HANDLER(SIOCSIWMLME, ks_wlan_set_mlme),
+	IW_HANDLER(SIOCGIWAPLIST, ks_wlan_get_aplist),
+	IW_HANDLER(SIOCSIWSCAN, ks_wlan_set_scan),
+	IW_HANDLER(SIOCGIWSCAN, ks_wlan_get_scan),
+	IW_HANDLER(SIOCSIWESSID, ks_wlan_set_essid),
+	IW_HANDLER(SIOCGIWESSID, ks_wlan_get_essid),
+	IW_HANDLER(SIOCSIWNICKN, ks_wlan_set_nick),
+	IW_HANDLER(SIOCGIWNICKN, ks_wlan_get_nick),
+	IW_HANDLER(SIOCSIWRATE, ks_wlan_set_rate),
+	IW_HANDLER(SIOCGIWRATE, ks_wlan_get_rate),
+	IW_HANDLER(SIOCSIWRTS, ks_wlan_set_rts),
+	IW_HANDLER(SIOCGIWRTS, ks_wlan_get_rts),
+	IW_HANDLER(SIOCSIWFRAG, ks_wlan_set_frag),
+	IW_HANDLER(SIOCGIWFRAG, ks_wlan_get_frag),
 #ifndef KSC_OPNOTSUPP
-	(iw_handler)ks_wlan_set_txpow,	/* SIOCSIWTXPOW */
-	(iw_handler)ks_wlan_get_txpow,	/* SIOCGIWTXPOW */
-	(iw_handler)ks_wlan_set_retry,	/* SIOCSIWRETRY */
-	(iw_handler)ks_wlan_get_retry,	/* SIOCGIWRETRY */
-#else /* KSC_OPNOTSUPP */
-	(iw_handler)NULL,	/* SIOCSIWTXPOW */
-	(iw_handler)NULL,	/* SIOCGIWTXPOW */
-	(iw_handler)NULL,	/* SIOCSIWRETRY */
-	(iw_handler)NULL,	/* SIOCGIWRETRY */
+	IW_HANDLER(SIOCSIWTXPOW, ks_wlan_set_txpow),
+	IW_HANDLER(SIOCGIWTXPOW, ks_wlan_get_txpow),
+	IW_HANDLER(SIOCSIWRETRY, ks_wlan_set_retry),
+	IW_HANDLER(SIOCGIWRETRY, ks_wlan_get_retry),
 #endif /* KSC_OPNOTSUPP */
-	(iw_handler)ks_wlan_set_encode,	/* SIOCSIWENCODE */
-	(iw_handler)ks_wlan_get_encode,	/* SIOCGIWENCODE */
-	(iw_handler)ks_wlan_set_power,	/* SIOCSIWPOWER */
-	(iw_handler)ks_wlan_get_power,	/* SIOCGIWPOWER */
-	(iw_handler)NULL,	/* -- hole -- */
-	(iw_handler)NULL,	/* -- hole -- */
-//      (iw_handler)NULL,                      /* SIOCSIWGENIE */
-	(iw_handler)ks_wlan_set_genie,	/* SIOCSIWGENIE */
-	(iw_handler)NULL,	/* SIOCGIWGENIE */
-	(iw_handler)ks_wlan_set_auth_mode,	/* SIOCSIWAUTH */
-	(iw_handler)ks_wlan_get_auth_mode,	/* SIOCGIWAUTH */
-	(iw_handler)ks_wlan_set_encode_ext,	/* SIOCSIWENCODEEXT */
-	(iw_handler)ks_wlan_get_encode_ext,	/* SIOCGIWENCODEEXT */
-	(iw_handler)ks_wlan_set_pmksa,	/* SIOCSIWPMKSA */
-	(iw_handler)NULL,	/* -- hole -- */
+	IW_HANDLER(SIOCSIWENCODE, ks_wlan_set_encode),
+	IW_HANDLER(SIOCGIWENCODE, ks_wlan_get_encode),
+	IW_HANDLER(SIOCSIWPOWER, ks_wlan_set_power),
+	IW_HANDLER(SIOCGIWPOWER, ks_wlan_get_power),
+	IW_HANDLER(SIOCSIWGENIE, ks_wlan_set_genie),
+	IW_HANDLER(SIOCSIWAUTH, ks_wlan_set_auth_mode),
+	IW_HANDLER(SIOCGIWAUTH, ks_wlan_get_auth_mode),
+	IW_HANDLER(SIOCSIWENCODEEXT, ks_wlan_set_encode_ext),
+	IW_HANDLER(SIOCGIWENCODEEXT, ks_wlan_get_encode_ext),
+	IW_HANDLER(SIOCSIWPMKSA, ks_wlan_set_pmksa),
 };
 
 /* private_handler */

commit d892cc1cfe0c1ce4e4eb58a1877835802953adac
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 23 15:44:48 2018 +0200

    staging: ks7010: change name and type for device_open_status field
    
    This commit changes type for device_open_status field of ks_wlan_private
    structure from int to bool. This variable is only be set to 1
    on ks_wlan_net_start and set to 0 on ks_wlan_net_stop. For this
    purpose it is not necessary at all to use an integer because a bool
    is enough. This also renames field name from device_open_status to
    is_device_open.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 05f8216e502b..76ed4ed9d167 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2816,9 +2816,8 @@ int ks_wlan_net_start(struct net_device *dev)
 
 	priv = netdev_priv(dev);
 	priv->mac_address_valid = false;
-	priv->device_open_status = true;
+	priv->is_device_open = true;
 	priv->need_commit = 0;
-
 	/* phy information update timer */
 	atomic_set(&update_phyinfo, 0);
 	timer_setup(&update_phyinfo_timer, ks_wlan_update_phyinfo_timeout, 0);
@@ -2848,7 +2847,7 @@ int ks_wlan_net_stop(struct net_device *dev)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	priv->device_open_status = false;
+	priv->is_device_open = false;
 	del_timer_sync(&update_phyinfo_timer);
 
 	if (netif_running(dev))

commit 5e8779dcdcc51fda2437f39deef26b6b6af5058a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Apr 19 07:08:13 2018 +0200

    staging: ks7010: align comments in ks_wlan_private_handler
    
    This commit align comment inside ks_wlan_private_handler
    WEXT private driver operations. This improves readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index c53a61458bf2..05f8216e502b 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2602,31 +2602,30 @@ static const iw_handler ks_wlan_handler[] = {
 
 /* private_handler */
 static const iw_handler ks_wlan_private_handler[] = {
-	(iw_handler)NULL,	/*  0 */
-	(iw_handler)NULL,	/*  1, used to be: KS_WLAN_GET_DRIVER_VERSION */
-	(iw_handler)NULL,	/*  2 */
-	(iw_handler)ks_wlan_get_firmware_version,	/*  3 KS_WLAN_GET_FIRM_VERSION */
+	(iw_handler)NULL,			/* 0 */
+	(iw_handler)NULL,			/* 1, KS_WLAN_GET_DRIVER_VERSION */
+	(iw_handler)NULL,			/* 2 */
+	(iw_handler)ks_wlan_get_firmware_version,/* 3 KS_WLAN_GET_FIRM_VERSION */
 #ifdef WPS
-	(iw_handler)ks_wlan_set_wps_enable,	/*  4 KS_WLAN_SET_WPS_ENABLE  */
-	(iw_handler)ks_wlan_get_wps_enable,	/*  5 KS_WLAN_GET_WPS_ENABLE  */
-	(iw_handler)ks_wlan_set_wps_probe_req,	/*  6 KS_WLAN_SET_WPS_PROBE_REQ */
+	(iw_handler)ks_wlan_set_wps_enable,	/* 4 KS_WLAN_SET_WPS_ENABLE */
+	(iw_handler)ks_wlan_get_wps_enable,	/* 5 KS_WLAN_GET_WPS_ENABLE */
+	(iw_handler)ks_wlan_set_wps_probe_req,	/* 6 KS_WLAN_SET_WPS_PROBE_REQ */
 #else
-	(iw_handler)NULL,	/*  4 */
-	(iw_handler)NULL,	/*  5 */
-	(iw_handler)NULL,	/*  6 */
+	(iw_handler)NULL,			/* 4 */
+	(iw_handler)NULL,			/* 5 */
+	(iw_handler)NULL,			/* 6 */
 #endif /* WPS */
-
-	(iw_handler)ks_wlan_get_eeprom_cksum,	/*  7 KS_WLAN_GET_CONNECT */
-	(iw_handler)ks_wlan_set_preamble,	/*  8 KS_WLAN_SET_PREAMBLE */
-	(iw_handler)ks_wlan_get_preamble,	/*  9 KS_WLAN_GET_PREAMBLE */
+	(iw_handler)ks_wlan_get_eeprom_cksum,	/* 7 KS_WLAN_GET_CONNECT */
+	(iw_handler)ks_wlan_set_preamble,	/* 8 KS_WLAN_SET_PREAMBLE */
+	(iw_handler)ks_wlan_get_preamble,	/* 9 KS_WLAN_GET_PREAMBLE */
 	(iw_handler)ks_wlan_set_power_mgmt,	/* 10 KS_WLAN_SET_POWER_SAVE */
 	(iw_handler)ks_wlan_get_power_mgmt,	/* 11 KS_WLAN_GET_POWER_SAVE */
 	(iw_handler)ks_wlan_set_scan_type,	/* 12 KS_WLAN_SET_SCAN_TYPE */
 	(iw_handler)ks_wlan_get_scan_type,	/* 13 KS_WLAN_GET_SCAN_TYPE */
 	(iw_handler)ks_wlan_set_rx_gain,	/* 14 KS_WLAN_SET_RX_GAIN */
 	(iw_handler)ks_wlan_get_rx_gain,	/* 15 KS_WLAN_GET_RX_GAIN */
-	(iw_handler)ks_wlan_hostt,	/* 16 KS_WLAN_HOSTT */
-	(iw_handler)NULL,	/* 17 */
+	(iw_handler)ks_wlan_hostt,		/* 16 KS_WLAN_HOSTT */
+	(iw_handler)NULL,			/* 17 */
 	(iw_handler)ks_wlan_set_beacon_lost,	/* 18 KS_WLAN_SET_BECAN_LOST */
 	(iw_handler)ks_wlan_get_beacon_lost,	/* 19 KS_WLAN_GET_BECAN_LOST */
 	(iw_handler)ks_wlan_set_tx_gain,	/* 20 KS_WLAN_SET_TX_GAIN */
@@ -2635,12 +2634,12 @@ static const iw_handler ks_wlan_private_handler[] = {
 	(iw_handler)ks_wlan_get_phy_type,	/* 23 KS_WLAN_GET_PHY_TYPE */
 	(iw_handler)ks_wlan_set_cts_mode,	/* 24 KS_WLAN_SET_CTS_MODE */
 	(iw_handler)ks_wlan_get_cts_mode,	/* 25 KS_WLAN_GET_CTS_MODE */
-	(iw_handler)NULL,	/* 26 */
-	(iw_handler)NULL,	/* 27 */
+	(iw_handler)NULL,			/* 26 */
+	(iw_handler)NULL,			/* 27 */
 	(iw_handler)ks_wlan_set_sleep_mode,	/* 28 KS_WLAN_SET_SLEEP_MODE */
 	(iw_handler)ks_wlan_get_sleep_mode,	/* 29 KS_WLAN_GET_SLEEP_MODE */
-	(iw_handler)NULL,	/* 30 */
-	(iw_handler)NULL,	/* 31 */
+	(iw_handler)NULL,			/* 30 */
+	(iw_handler)NULL,			/* 31 */
 };
 
 static const struct iw_handler_def ks_wlan_handler_def = {

commit 8a4e6ab3f544f409b1ec6e3d7ebb47a598afb929
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Apr 19 07:08:03 2018 +0200

    staging: ks7010: review includes of ks_wlan_net.c file
    
    This commit reviews really needed includes in ks_wlan_net.c
    source file. It removes those which are not needed at all.
    It also reorder the remaining ones in alphabetical order.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 74946e964a25..c53a61458bf2 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -9,23 +9,11 @@
  *   published by the Free Software Foundation.
  */
 
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/compiler.h>
-#include <linux/init.h>
-#include <linux/ioport.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/if_arp.h>
-#include <linux/rtnetlink.h>
-#include <linux/delay.h>
+#include <linux/atomic.h>
 #include <linux/completion.h>
-#include <linux/mii.h>
-#include <linux/pci.h>
-#include <linux/ctype.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
 #include <linux/timer.h>
-#include <linux/atomic.h>
-#include <linux/io.h>
 #include <linux/uaccess.h>
 
 static int wep_on_off;

commit 6519967b959b2b412b6d6012f251a9d80e1f920c
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Apr 19 07:08:02 2018 +0200

    staging: ks7010: refactor ks_wlan_set_wps_enable function
    
    This commit refactors ks_wlan_set_wps_enable function to
    improve readability handling the error first to avoid an
    'else'.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 81889a5b2251..74946e964a25 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2224,11 +2224,10 @@ static int ks_wlan_set_wps_enable(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	if (*uwrq == 0 || *uwrq == 1)
-		priv->wps.wps_enabled = *uwrq;
-	else
+	if (*uwrq != 0 && *uwrq != 1)
 		return -EINVAL;
 
+	priv->wps.wps_enabled = *uwrq;
 	hostif_sme_enqueue(priv, SME_WPS_ENABLE_REQUEST);
 
 	return 0;

commit 86357f794b9692e8754718183801ce5d6f163392
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Apr 19 07:08:01 2018 +0200

    staging: ks7010: refactor ks_wlan_set_tx_gain function
    
    This commit refactors ks_wlan_set_rx_gain function to
    improve readability:
        - error condition is handling the error to avoid an 'else'
        - ternary operator is used to clean if-else block assignment.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 2fbacc56abdd..81889a5b2251 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2290,16 +2290,11 @@ static int ks_wlan_set_tx_gain(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	if (*uwrq >= 0 && *uwrq <= 0xFF)	/* 0-255 */
-		priv->gain.tx_gain = (uint8_t)*uwrq;
-	else
+	if (*uwrq < 0 || *uwrq > 0xFF)
 		return -EINVAL;
 
-	if (priv->gain.tx_gain < 0xFF)
-		priv->gain.tx_mode = 1;
-	else
-		priv->gain.tx_mode = 0;
-
+	priv->gain.tx_gain = (uint8_t)*uwrq;
+	priv->gain.tx_mode = (priv->gain.tx_gain < 0xFF) ? 1 : 0;
 	hostif_sme_enqueue(priv, SME_SET_GAIN);
 	return 0;
 }

commit 6cb3e6062bcae0d841188d59091c6720ff8981c3
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Apr 19 07:08:00 2018 +0200

    staging: ks7010: refactor ks_wlan_set_rx_gain function
    
    This commit refactors ks_wlan_set_rx_gain function to
    improve readability:
        - error condition is handling the error to avoid an 'else'
        - ternary operator is used to clean if-else block assignment.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 6a0ec9c66603..2fbacc56abdd 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2327,16 +2327,11 @@ static int ks_wlan_set_rx_gain(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	if (*uwrq >= 0 && *uwrq <= 0xFF)	/* 0-255 */
-		priv->gain.rx_gain = (uint8_t)*uwrq;
-	else
+	if (*uwrq < 0 || *uwrq > 0xFF)
 		return -EINVAL;
 
-	if (priv->gain.rx_gain < 0xFF)
-		priv->gain.rx_mode = 1;
-	else
-		priv->gain.rx_mode = 0;
-
+	priv->gain.rx_gain = (uint8_t)*uwrq;
+	priv->gain.rx_mode = (priv->gain.rx_gain < 0xFF) ? 1 : 0;
 	hostif_sme_enqueue(priv, SME_SET_GAIN);
 	return 0;
 }

commit 9dbeb16aab70af79ab853e5237d23c7a24b8d820
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Apr 19 07:07:59 2018 +0200

    staging: ks7010: change if-else condition assignment to use ternary operator
    
    This commit changes an if-else block used to just assign a
    variable to use a ternary operator to do the same improving
    readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 1f2e9f3e2f85..6a0ec9c66603 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -673,10 +673,7 @@ static int ks_wlan_get_rate(struct net_device *dev,
 		ks_wlan_update_phy_information(priv);
 
 	vwrq->value = ((priv->current_rate) & RATE_MASK) * 500000;
-	if (priv->reg.tx_rate == TX_RATE_FIXED)
-		vwrq->fixed = 1;
-	else
-		vwrq->fixed = 0;
+	vwrq->fixed = (priv->reg.tx_rate == TX_RATE_FIXED) ? 1 : 0;
 
 	return 0;
 }

commit 6cf070d231d82d31248dfd204260ba8817f72d43
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Apr 19 07:07:58 2018 +0200

    staging: ks7010: refactor ks_wlan_set_encode function
    
    This commit refactors ks_wlan_set_encode function to improve
    readability. It just removes level indentation in some paths
    as well as removes not needed conditions paths which was
    checked before. Changes are as follows:
    
     - (dwrq->length > MAX_KEY_SIZE) check has been moved to the top.
     - extra check about (dwrq->length > 0) inside an if block where
       that was the condition to enter inside it has been removed.
     - (dwrq->flags & IW_ENCODE_NOKEY) check has been turned to avoid
       one level indentation.
     - extra check (index >= 0) && (index < 4) has been removed. In
       the top of the file invalid index values are being checked
       so it has no sense to check that again.
     - remove commented line.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index d0350a2c527e..1f2e9f3e2f85 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -819,64 +819,48 @@ static int ks_wlan_set_encode(struct net_device *dev,
 			      struct iw_point *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
-
 	struct wep_key key;
 	int index = (dwrq->flags & IW_ENCODE_INDEX);
-	int current_index = priv->reg.wep_index;
-	int i;
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
+	if (dwrq->length > MAX_KEY_SIZE)
+		return -EINVAL;
+
 	/* for SLEEP MODE */
-	/* index check */
 	if ((index < 0) || (index > 4))
 		return -EINVAL;
-	else if (index == 0)
-		index = current_index;
-	else
-		index--;
+
+	index = (index == 0) ? priv->reg.wep_index : (index - 1);
 
 	/* Is WEP supported ? */
 	/* Basic checking: do we have a key to set ? */
 	if (dwrq->length > 0) {
-		if (dwrq->length > MAX_KEY_SIZE) {	/* Check the size of the key */
-			return -EINVAL;
-		}
-		if (dwrq->length > MIN_KEY_SIZE) {	/* Set the length */
-			key.len = MAX_KEY_SIZE;
-			priv->reg.privacy_invoked = 0x01;
-			priv->need_commit |= SME_WEP_FLAG;
-			wep_on_off = WEP_ON_128BIT;
-		} else {
-			if (dwrq->length > 0) {
-				key.len = MIN_KEY_SIZE;
-				priv->reg.privacy_invoked = 0x01;
-				priv->need_commit |= SME_WEP_FLAG;
-				wep_on_off = WEP_ON_64BIT;
-			} else {	/* Disable the key */
-				key.len = 0;
-			}
-		}
+		key.len = (dwrq->length > MIN_KEY_SIZE) ?
+			   MAX_KEY_SIZE : MIN_KEY_SIZE;
+		priv->reg.privacy_invoked = 0x01;
+		priv->need_commit |= SME_WEP_FLAG;
+		wep_on_off = (dwrq->length > MIN_KEY_SIZE) ?
+			      WEP_ON_128BIT : WEP_ON_64BIT;
 		/* Check if the key is not marked as invalid */
-		if (!(dwrq->flags & IW_ENCODE_NOKEY)) {
-			/* Cleanup */
-			memset(key.key, 0, MAX_KEY_SIZE);
-			/* Copy the key in the driver */
-			if (copy_from_user
-			    (key.key, dwrq->pointer, dwrq->length)) {
-				key.len = 0;
-				return -EFAULT;
-			}
-			/* Send the key to the card */
-			priv->reg.wep_key[index].size = key.len;
-			for (i = 0; i < (priv->reg.wep_key[index].size); i++)
-				priv->reg.wep_key[index].val[i] = key.key[i];
+		if (dwrq->flags & IW_ENCODE_NOKEY)
+			return 0;
 
-			priv->need_commit |= (SME_WEP_VAL1 << index);
-			priv->reg.wep_index = index;
-			priv->need_commit |= SME_WEP_INDEX;
+		/* Cleanup */
+		memset(key.key, 0, MAX_KEY_SIZE);
+		/* Copy the key in the driver */
+		if (copy_from_user(key.key, dwrq->pointer, dwrq->length)) {
+			key.len = 0;
+			return -EFAULT;
 		}
+		/* Send the key to the card */
+		priv->reg.wep_key[index].size = key.len;
+		memcpy(&priv->reg.wep_key[index].val[0], &key.key[0],
+		       priv->reg.wep_key[index].size);
+		priv->need_commit |= (SME_WEP_VAL1 << index);
+		priv->reg.wep_index = index;
+		priv->need_commit |= SME_WEP_INDEX;
 	} else {
 		if (dwrq->flags & IW_ENCODE_DISABLED) {
 			priv->reg.wep_key[0].size = 0;
@@ -891,16 +875,11 @@ static int ks_wlan_set_encode(struct net_device *dev,
 			wep_on_off = WEP_OFF;
 			priv->need_commit |= SME_WEP_FLAG;
 		} else {
-			/* Do we want to just set the transmit key index ? */
-			if ((index >= 0) && (index < 4)) {
-				/* set_wep_key(priv, index, 0, 0, 1);   xxx */
-				if (priv->reg.wep_key[index].size != 0) {
-					priv->reg.wep_index = index;
-					priv->need_commit |= SME_WEP_INDEX;
-				} else {
-					return -EINVAL;
-				}
-			}
+			/* set_wep_key(priv, index, 0, 0, 1);   xxx */
+			if (priv->reg.wep_key[index].size == 0)
+				return -EINVAL;
+			priv->reg.wep_index = index;
+			priv->need_commit |= SME_WEP_INDEX;
 		}
 	}
 
@@ -919,7 +898,6 @@ static int ks_wlan_set_encode(struct net_device *dev,
 
 		priv->reg.authenticate_type = AUTH_TYPE_SHARED_KEY;
 	}
-//      return -EINPROGRESS;            /* Call commit handler */
 	if (priv->need_commit) {
 		ks_wlan_setup_parameter(priv, priv->need_commit);
 		priv->need_commit = 0;

commit fffe8becb7cf67c78f954721689e6906cc936c68
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Apr 19 07:07:57 2018 +0200

    staging: ks7010: remove auxiliar zeros buffer in ks_wlan_get_encode
    
    This commit removes the local buffer zeros in ks_wlan_get_encode
    function. It also refactors related conditions in order to fill
    'extra' output parameter of the function. Originally this zeros
    is just memset to zeros and only being used if drw->length is
    truncated to zero because of priv->reg.wep_key[index].size is
    greater than 16 chars. In those cases the final if statement is
    just using zeros but it is using memcpy with a length of zero
    bytes which has no sense. Instead of that just handle the good
    case copying from the same source the number of bytes of
    priv->reg.wep_key[index].size. If it is zero the final 'extra'
    parameter won't be copied at all because the number of bytes to
    copy will be zero. With this change the code gets simplified.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index eaee49d76dff..d0350a2c527e 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -932,7 +932,6 @@ static int ks_wlan_get_encode(struct net_device *dev,
 			      struct iw_point *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
-	char zeros[16];
 	int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -951,8 +950,6 @@ static int ks_wlan_get_encode(struct net_device *dev,
 		break;
 	}
 
-	memset(zeros, 0, sizeof(zeros));
-
 	/* Which key do we want ? -1 -> tx index */
 	if ((index < 0) || (index >= 4))
 		index = priv->reg.wep_index;
@@ -962,16 +959,10 @@ static int ks_wlan_get_encode(struct net_device *dev,
 	}
 	dwrq->flags |= index + 1;
 	/* Copy the key to the user buffer */
-	if ((index >= 0) && (index < 4))
-		dwrq->length = priv->reg.wep_key[index].size;
-	if (dwrq->length > 16)
-		dwrq->length = 0;
-	if (dwrq->length) {
-		if ((index >= 0) && (index < 4))
-			memcpy(extra, priv->reg.wep_key[index].val,
-			       dwrq->length);
-	} else {
-		memcpy(extra, zeros, dwrq->length);
+	if (index >= 0 && index < 4) {
+		dwrq->length = (priv->reg.wep_key[index].size <= 16) ?
+				priv->reg.wep_key[index].size : 0;
+		memcpy(extra, priv->reg.wep_key[index].val, dwrq->length);
 	}
 
 	return 0;

commit 9b5124319d89321edfbb7c92de19b1afacd13042
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Apr 6 14:37:45 2018 +0200

    staging: ks7010: remove nosense #if 1 directive
    
    This commit removes #if 1 directive from code to
    improve readability. It is always true, so it makes
    no sense to have it there.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 138d19a48a4c..eaee49d76dff 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -966,7 +966,6 @@ static int ks_wlan_get_encode(struct net_device *dev,
 		dwrq->length = priv->reg.wep_key[index].size;
 	if (dwrq->length > 16)
 		dwrq->length = 0;
-#if 1	/* IW_ENCODE_NOKEY; */
 	if (dwrq->length) {
 		if ((index >= 0) && (index < 4))
 			memcpy(extra, priv->reg.wep_key[index].val,
@@ -974,7 +973,7 @@ static int ks_wlan_get_encode(struct net_device *dev,
 	} else {
 		memcpy(extra, zeros, dwrq->length);
 	}
-#endif
+
 	return 0;
 }
 

commit e9f830334ff97844ea98bc7fcac5a7baf10a9d91
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:53 2018 -0700

    staging: ks7010: Remove unnecessary casts in 'struct ks_wlan_handler_def'.
    
    The casts used when initializing members of this data structure mirror
    the types the variables already have.  Remove the casts.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 9f9a51e96ab5..138d19a48a4c 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2705,9 +2705,9 @@ static const struct iw_handler_def ks_wlan_handler_def = {
 	.num_standard = ARRAY_SIZE(ks_wlan_handler),
 	.num_private = ARRAY_SIZE(ks_wlan_private_handler),
 	.num_private_args = ARRAY_SIZE(ks_wlan_private_args),
-	.standard = (iw_handler *)ks_wlan_handler,
-	.private = (iw_handler *)ks_wlan_private_handler,
-	.private_args = (struct iw_priv_args *)ks_wlan_private_args,
+	.standard = ks_wlan_handler,
+	.private = ks_wlan_private_handler,
+	.private_args = ks_wlan_private_args,
 	.get_wireless_stats = ks_get_wireless_stats,
 };
 

commit 8102f61d453edada4395bfc664538c3e11c6464d
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:52 2018 -0700

    staging: ks7010: Change 'device_open_status' to a bool.
    
    The 'device_open_status' member of 'struct ks_wlan_private' is only
    ever set to zero or one, so it makes more sense for it to be a bool
    instead of an int.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index c4d94211b01b..9f9a51e96ab5 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2875,10 +2875,9 @@ int ks_wlan_net_start(struct net_device *dev)
 
 	priv = netdev_priv(dev);
 	priv->mac_address_valid = false;
+	priv->device_open_status = true;
 	priv->need_commit = 0;
 
-	priv->device_open_status = 1;
-
 	/* phy information update timer */
 	atomic_set(&update_phyinfo, 0);
 	timer_setup(&update_phyinfo_timer, ks_wlan_update_phyinfo_timeout, 0);
@@ -2908,7 +2907,7 @@ int ks_wlan_net_stop(struct net_device *dev)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	priv->device_open_status = 0;
+	priv->device_open_status = false;
 	del_timer_sync(&update_phyinfo_timer);
 
 	if (netif_running(dev))

commit 582475a29c85bf7f15b3a6fd82371970dc7856bd
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:50 2018 -0700

    staging: ks7010: Rename ks_wlan_set_multicast_list()
    
    All of the net_device_ops callbacks are named after their counterparts
    in the kernel's 'struct net_device_ops', except
    ks_wlan_set_multicast_list().  Rename it to ks_wlan_set_rx_mode() for
    greater consistency.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 72a52c6f9fd2..c4d94211b01b 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -73,7 +73,7 @@ static int ks_wlan_open(struct net_device *dev);
 static void ks_wlan_tx_timeout(struct net_device *dev);
 static int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev);
 static int ks_wlan_close(struct net_device *dev);
-static void ks_wlan_set_multicast_list(struct net_device *dev);
+static void ks_wlan_set_rx_mode(struct net_device *dev);
 static struct net_device_stats *ks_wlan_get_stats(struct net_device *dev);
 static int ks_wlan_set_mac_address(struct net_device *dev, void *addr);
 static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq,
@@ -2817,7 +2817,7 @@ void send_packet_complete(struct ks_wlan_private *priv, struct sk_buff *skb)
  * This routine is not state sensitive and need not be SMP locked.
  */
 static
-void ks_wlan_set_multicast_list(struct net_device *dev)
+void ks_wlan_set_rx_mode(struct net_device *dev)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
@@ -2865,7 +2865,7 @@ static const struct net_device_ops ks_wlan_netdev_ops = {
 	.ndo_set_mac_address = ks_wlan_set_mac_address,
 	.ndo_get_stats = ks_wlan_get_stats,
 	.ndo_tx_timeout = ks_wlan_tx_timeout,
-	.ndo_set_rx_mode = ks_wlan_set_multicast_list,
+	.ndo_set_rx_mode = ks_wlan_set_rx_mode,
 };
 
 int ks_wlan_net_start(struct net_device *dev)

commit b74024743e2530d0fe10b2e4cc6754c8c5af2be5
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:45 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct pmk_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct pmk_t' with 'struct pmk'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 1b8234720d78..72a52c6f9fd2 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1818,7 +1818,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_pmksa *pmksa;
 	int i;
-	struct pmk_t *pmk;
+	struct pmk *pmk;
 	struct list_head *ptr;
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -1847,7 +1847,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 		}
 		/* search cache data */
 		list_for_each(ptr, &priv->pmklist.head) {
-			pmk = list_entry(ptr, struct pmk_t, list);
+			pmk = list_entry(ptr, struct pmk, list);
 			if (memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN) == 0) {
 				memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
 				list_move(&pmk->list, &priv->pmklist.head);
@@ -1869,7 +1869,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 			list_add(&pmk->list, &priv->pmklist.head);
 			priv->pmklist.size++;
 		} else {	/* overwrite old cache data */
-			pmk = list_entry(priv->pmklist.head.prev, struct pmk_t,
+			pmk = list_entry(priv->pmklist.head.prev, struct pmk,
 					 list);
 			memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
 			memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
@@ -1882,7 +1882,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 		}
 		/* search cache data */
 		list_for_each(ptr, &priv->pmklist.head) {
-			pmk = list_entry(ptr, struct pmk_t, list);
+			pmk = list_entry(ptr, struct pmk, list);
 			if (memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN) == 0) {
 				eth_zero_addr(pmk->bssid);
 				memset(pmk->pmkid, 0, IW_PMKID_LEN);

commit 8b76eb091b5b8aec094b0fde9cf58856a8e699cb
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:41 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct wpa_key_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct wpa_key_t' with 'struct wpa_key'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index a4f10bec865f..1b8234720d78 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1706,7 +1706,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	struct iw_encode_ext *enc;
 	int index = dwrq->flags & IW_ENCODE_INDEX;
 	unsigned int commit = 0;
-	struct wpa_key_t *key;
+	struct wpa_key *key;
 
 	enc = (struct iw_encode_ext *)extra;
 	if (!enc)

commit 01d391d45701790be830e6af0a18fece388cc1f4
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:08:34 2018 -0700

    staging: ks7010: Remove trailing _t from 'struct local_ap_t'.
    
    The "_t" suffix is not needed for structure names in this driver, and is a
    reflection of an older typedef system that is no longer in place. Replace
    all occurences of 'struct local_ap_t' with 'struct local_ap'.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 533feef604a9..a4f10bec865f 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1301,7 +1301,7 @@ static int ks_wlan_set_scan(struct net_device *dev,
 static inline char *ks_wlan_translate_scan(struct net_device *dev,
 					   struct iw_request_info *info,
 					   char *current_ev, char *end_buf,
-					   struct local_ap_t *ap)
+					   struct local_ap *ap)
 {
 	/* struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv; */
 	struct iw_event iwe;	/* Temporary buffer */

commit 5312af9ecad609dd283974620e34445a085df227
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Fri Mar 30 23:07:41 2018 -0700

    staging: ks7010: Use the ARRAY_SIZE() macro to calculate array sizes.
    
    This macro, provided in 'linux/kernel.h', will calculate the size
    more succinctly than a division operation.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 9078e13b0d4a..533feef604a9 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2702,10 +2702,9 @@ static const iw_handler ks_wlan_private_handler[] = {
 };
 
 static const struct iw_handler_def ks_wlan_handler_def = {
-	.num_standard = sizeof(ks_wlan_handler) / sizeof(iw_handler),
-	.num_private = sizeof(ks_wlan_private_handler) / sizeof(iw_handler),
-	.num_private_args =
-	    sizeof(ks_wlan_private_args) / sizeof(struct iw_priv_args),
+	.num_standard = ARRAY_SIZE(ks_wlan_handler),
+	.num_private = ARRAY_SIZE(ks_wlan_private_handler),
+	.num_private_args = ARRAY_SIZE(ks_wlan_private_args),
 	.standard = (iw_handler *)ks_wlan_handler,
 	.private = (iw_handler *)ks_wlan_private_handler,
 	.private_args = (struct iw_priv_args *)ks_wlan_private_args,

commit f40cd66b45b3fc2822e3abb254929c6e2820ab91
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Wed Mar 28 22:51:48 2018 -0700

    staging: ks7010: Change mac_address_valid to a bool instead of int.
    
    'mac_address_valid' is only ever assigned 0 or 1, so it makes more sense
    to use a bool type for this variable.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 9693e8fe98b9..9078e13b0d4a 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2752,7 +2752,7 @@ int ks_wlan_set_mac_address(struct net_device *dev, void *addr)
 	memcpy(dev->dev_addr, mac_addr->sa_data, dev->addr_len);
 	memcpy(priv->eth_addr, mac_addr->sa_data, ETH_ALEN);
 
-	priv->mac_address_valid = 0;
+	priv->mac_address_valid = false;
 	hostif_sme_enqueue(priv, SME_MACADDRESS_SET_REQUEST);
 	netdev_info(dev, "ks_wlan:  MAC ADDRESS = %pM\n", priv->eth_addr);
 	return 0;
@@ -2875,7 +2875,7 @@ int ks_wlan_net_start(struct net_device *dev)
 	/* int rc; */
 
 	priv = netdev_priv(dev);
-	priv->mac_address_valid = 0;
+	priv->mac_address_valid = false;
 	priv->need_commit = 0;
 
 	priv->device_open_status = 1;

commit 019ec78508d5dd21589c3ff60ecbe90a54a7a14b
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Wed Mar 28 22:51:45 2018 -0700

    staging: ks7010: Remove unecessary cast.
    
    The driver casts '&ks_wlan_handler_def' to 'struct iw_handler_def *',
    but it is already of that type.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 4019f3a904b0..9693e8fe98b9 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2897,7 +2897,7 @@ int ks_wlan_net_start(struct net_device *dev)
 
 	/* The ks_wlan-specific entries in the device structure. */
 	dev->netdev_ops = &ks_wlan_netdev_ops;
-	dev->wireless_handlers = (struct iw_handler_def *)&ks_wlan_handler_def;
+	dev->wireless_handlers = &ks_wlan_handler_def;
 	dev->watchdog_timeo = TX_TIMEOUT;
 
 	netif_carrier_off(dev);

commit c0a2a25460a755db63750eeea89a74657e7eda0d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Mar 28 17:24:25 2018 +0200

    staging: ks7010: remove some dead code from ks_wlan_set_essid function
    
    This commit removes death code which is not being used at all. The
    statements which are contained inside the else block of preprocessor
    #if 1 directive are no sense. Also remove #if 1 preprocessor stuff
    just because it is just true and being executed always.
    This change improves a bit readability of ks_wlan_set_essid function.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 6106e79c5163..4019f3a904b0 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -276,7 +276,6 @@ static int ks_wlan_set_essid(struct net_device *dev,
 		memset(priv->reg.ssid.body, 0, sizeof(priv->reg.ssid.body));
 		priv->reg.ssid.size = 0;
 	} else {
-#if 1
 		len = dwrq->length;
 		/* iwconfig uses nul termination in SSID.. */
 		if (len > 0 && extra[len - 1] == '\0')
@@ -286,28 +285,14 @@ static int ks_wlan_set_essid(struct net_device *dev,
 		if (len > IW_ESSID_MAX_SIZE)
 			return -EINVAL;
 
-#else
-		/* Check the size of the string */
-		if (dwrq->length > IW_ESSID_MAX_SIZE + 1)
-			return -E2BIG;
-
-#endif
-
 		/* Set the SSID */
 		memset(priv->reg.ssid.body, 0, sizeof(priv->reg.ssid.body));
-
-#if 1
 		memcpy(priv->reg.ssid.body, extra, len);
 		priv->reg.ssid.size = len;
-#else
-		memcpy(priv->reg.ssid.body, extra, dwrq->length);
-		priv->reg.ssid.size = dwrq->length;
-#endif
 	}
 	/* Write it to the card */
 	priv->need_commit |= SME_MODE_SET;
 
-//      return  -EINPROGRESS;   /* Call commit handler */
 	ks_wlan_setup_parameter(priv, priv->need_commit);
 	priv->need_commit = 0;
 	return 0;

commit 5259b3293617ea88842a658793ffaa61ea0e0ef4
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Mar 15 20:09:22 2018 +0100

    staging: ks7010: replace DPRINTK traces in favour of netdev_*
    
    This commit removes custom defined DPRINTK macro and replaces all the
    associated debug and other traces for preferred ones netdev_*.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index d138eb2eaaa2..6106e79c5163 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -86,7 +86,7 @@ int ks_wlan_update_phy_information(struct ks_wlan_private *priv)
 {
 	struct iw_statistics *wstats = &priv->wstats;
 
-	DPRINTK(4, "in_interrupt = %ld\n", in_interrupt());
+	netdev_dbg(priv->net_dev, "in_interrupt = %ld\n", in_interrupt());
 
 	if (priv->dev_state < DEVICE_STATE_READY)
 		return -EBUSY;	/* not finished initialize */
@@ -103,7 +103,7 @@ int ks_wlan_update_phy_information(struct ks_wlan_private *priv)
 	/* interruptible_sleep_on_timeout(&priv->confirm_wait, HZ/2); */
 	if (!wait_for_completion_interruptible_timeout
 	    (&priv->confirm_wait, HZ / 2)) {
-		DPRINTK(1, "wait time out!!\n");
+		netdev_dbg(priv->net_dev, "wait time out!!\n");
 	}
 
 	atomic_inc(&update_phyinfo);
@@ -116,7 +116,7 @@ int ks_wlan_update_phy_information(struct ks_wlan_private *priv)
 static
 void ks_wlan_update_phyinfo_timeout(struct timer_list *unused)
 {
-	DPRINTK(4, "in_interrupt = %ld\n", in_interrupt());
+	pr_debug("in_interrupt = %ld\n", in_interrupt());
 	atomic_set(&update_phyinfo, 0);
 }
 
@@ -364,7 +364,7 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 		return -EOPNOTSUPP;
 	}
 
-	DPRINTK(2, "bssid = %pM\n", priv->reg.bssid);
+	netdev_dbg(dev, "bssid = %pM\n", priv->reg.bssid);
 
 	/* Write it to the card */
 	if (priv->need_commit) {
@@ -677,8 +677,8 @@ static int ks_wlan_get_rate(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(2, "in_interrupt = %ld update_phyinfo = %d\n",
-		in_interrupt(), atomic_read(&update_phyinfo));
+	netdev_dbg(dev, "in_interrupt = %ld update_phyinfo = %d\n",
+		   in_interrupt(), atomic_read(&update_phyinfo));
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -1435,7 +1435,7 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 			pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.body[i]);
 		iwe.u.data.length += (ap->rsn_ie.size) * 2;
 
-		DPRINTK(4, "ap->rsn.size=%d\n", ap->rsn_ie.size);
+		netdev_dbg(dev, "ap->rsn.size=%d\n", ap->rsn_ie.size);
 
 		current_ev =
 		    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
@@ -1457,8 +1457,8 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 			pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.body[i]);
 		iwe.u.data.length += (ap->wpa_ie.size) * 2;
 
-		DPRINTK(4, "ap->rsn.size=%d\n", ap->wpa_ie.size);
-		DPRINTK(4, "iwe.u.data.length=%d\n", iwe.u.data.length);
+		netdev_dbg(dev, "ap->rsn.size=%d\n", ap->wpa_ie.size);
+		netdev_dbg(dev, "iwe.u.data.length=%d\n", iwe.u.data.length);
 
 		current_ev =
 		    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
@@ -2320,10 +2320,10 @@ static int ks_wlan_set_wps_probe_req(struct net_device *dev,
 	memcpy(priv->wps.ie, &len, sizeof(len));
 	p = memcpy(priv->wps.ie + 1, p, len);
 
-	DPRINTK(2, "%d(%#x): %02X %02X %02X %02X ... %02X %02X %02X\n",
-		priv->wps.ielen, priv->wps.ielen, p[0], p[1], p[2], p[3],
-		p[priv->wps.ielen - 3], p[priv->wps.ielen - 2],
-		p[priv->wps.ielen - 1]);
+	netdev_dbg(dev, "%d(%#x): %02X %02X %02X %02X ... %02X %02X %02X\n",
+		   priv->wps.ielen, priv->wps.ielen, p[0], p[1], p[2], p[3],
+		   p[priv->wps.ielen - 3], p[priv->wps.ielen - 2],
+		   p[priv->wps.ielen - 1]);
 
 	hostif_sme_enqueue(priv, SME_WPS_PROBE_REQUEST);
 
@@ -2778,8 +2778,8 @@ void ks_wlan_tx_timeout(struct net_device *dev)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(1, "head(%d) tail(%d)!!\n", priv->tx_dev.qhead,
-		priv->tx_dev.qtail);
+	netdev_dbg(dev, "head(%d) tail(%d)!!\n", priv->tx_dev.qhead,
+		   priv->tx_dev.qtail);
 	if (!netif_queue_stopped(dev))
 		netif_stop_queue(dev);
 	priv->nstats.tx_errors++;
@@ -2792,7 +2792,7 @@ int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	int ret;
 
-	DPRINTK(3, "in_interrupt()=%ld\n", in_interrupt());
+	netdev_dbg(dev, "in_interrupt()=%ld\n", in_interrupt());
 
 	if (!skb) {
 		netdev_err(dev, "ks_wlan:  skb == NULL!!!\n");
@@ -2810,7 +2810,7 @@ int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	netif_trans_update(dev);
 
 	if (ret)
-		DPRINTK(4, "hostif_data_request error: =%d\n", ret);
+		netdev_err(dev, "hostif_data_request error: =%d\n", ret);
 
 	return 0;
 }

commit 7acf4002e348913c86015337ea0810acbb5443e0
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Mar 15 20:09:21 2018 +0100

    staging: ks7010: remove useless DPRINTK traces
    
    This commit removes some useless traces in some source files
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 91acf87ab8dd..d138eb2eaaa2 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -123,8 +123,6 @@ void ks_wlan_update_phyinfo_timeout(struct timer_list *unused)
 int ks_wlan_setup_parameter(struct ks_wlan_private *priv,
 			    unsigned int commit_flag)
 {
-	DPRINTK(2, "\n");
-
 	hostif_sme_enqueue(priv, SME_STOP_REQUEST);
 
 	if (commit_flag & SME_RTS)
@@ -268,8 +266,6 @@ static int ks_wlan_set_essid(struct net_device *dev,
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	size_t len;
 
-	DPRINTK(2, " %d\n", dwrq->flags);
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
@@ -352,8 +348,6 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(2, "\n");
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
@@ -785,8 +779,6 @@ static int ks_wlan_set_mode(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(2, "mode=%d\n", *uwrq);
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
@@ -848,8 +840,6 @@ static int ks_wlan_set_encode(struct net_device *dev,
 	int current_index = priv->reg.wep_index;
 	int i;
 
-	DPRINTK(2, "flags=%04X\n", dwrq->flags);
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
@@ -986,7 +976,6 @@ static int ks_wlan_get_encode(struct net_device *dev,
 		/* dwrq->flags |= IW_ENCODE_NOKEY; */
 	}
 	dwrq->flags |= index + 1;
-	DPRINTK(2, "encoding flag = 0x%04X\n", dwrq->flags);
 	/* Copy the key to the user buffer */
 	if ((index >= 0) && (index < 4))
 		dwrq->length = priv->reg.wep_key[index].size;
@@ -1058,8 +1047,6 @@ static int ks_wlan_get_range(struct net_device *dev,
 	struct iw_range *range = (struct iw_range *)extra;
 	int i, k;
 
-	DPRINTK(2, "\n");
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
@@ -1300,8 +1287,6 @@ static int ks_wlan_set_scan(struct net_device *dev,
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_scan_req *req = NULL;
 
-	DPRINTK(2, "\n");
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
@@ -1494,21 +1479,16 @@ static int ks_wlan_get_scan(struct net_device *dev,
 	int i;
 	char *current_ev = extra;
 
-	DPRINTK(2, "\n");
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	if (priv->sme_i.sme_flag & SME_AP_SCAN) {
-		DPRINTK(2, "flag AP_SCAN\n");
+	if (priv->sme_i.sme_flag & SME_AP_SCAN)
 		return -EAGAIN;
-	}
 
 	if (priv->aplist.size == 0) {
 		/* Client error, no scan results...
 		 * The caller need to restart the scan.
 		 */
-		DPRINTK(2, "aplist 0\n");
 		return -ENODATA;
 	}
 
@@ -1552,8 +1532,6 @@ static int ks_wlan_set_genie(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(2, "\n");
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
@@ -1569,8 +1547,6 @@ static int ks_wlan_set_auth_mode(struct net_device *dev,
 	int index = (vwrq->flags & IW_AUTH_INDEX);
 	int value = vwrq->value;
 
-	DPRINTK(2, "index=%d:value=%08X\n", index, value);
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
@@ -1702,8 +1678,6 @@ static int ks_wlan_get_auth_mode(struct net_device *dev,
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	int index = (vwrq->flags & IW_AUTH_INDEX);
 
-	DPRINTK(2, "index=%d\n", index);
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
@@ -1753,9 +1727,6 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	if (!enc)
 		return -EINVAL;
 
-	DPRINTK(2, "flags=%04X:: ext_flags=%08X\n", dwrq->flags,
-		enc->ext_flags);
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
@@ -1865,8 +1836,6 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 	struct pmk_t *pmk;
 	struct list_head *ptr;
 
-	DPRINTK(2, "\n");
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
@@ -1875,7 +1844,6 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 		return -EINVAL;
 
 	pmksa = (struct iw_pmksa *)extra;
-	DPRINTK(2, "cmd=%d\n", pmksa->cmd);
 
 	switch (pmksa->cmd) {
 	case IW_PMKSA_ADD:
@@ -1987,8 +1955,6 @@ static int ks_wlan_set_stop_request(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(2, "\n");
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
@@ -2009,8 +1975,6 @@ static int ks_wlan_set_mlme(struct net_device *dev,
 	struct iw_mlme *mlme = (struct iw_mlme *)extra;
 	__u32 mode;
 
-	DPRINTK(2, ":%d :%d\n", mlme->cmd, mlme->reason_code);
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
@@ -2269,8 +2233,6 @@ static int ks_wlan_set_sleep_mode(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(2, "\n");
-
 	if (*uwrq == SLP_SLEEP) {
 		priv->sleep_mode = *uwrq;
 		netdev_info(dev, "SET_SLEEP_MODE %d\n", priv->sleep_mode);
@@ -2296,7 +2258,6 @@ static int ks_wlan_get_sleep_mode(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(2, "GET_SLEEP_MODE %d\n", priv->sleep_mode);
 	*uwrq = priv->sleep_mode;
 
 	return 0;
@@ -2310,8 +2271,6 @@ static int ks_wlan_set_wps_enable(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(2, "\n");
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
@@ -2331,8 +2290,6 @@ static int ks_wlan_get_wps_enable(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(2, "\n");
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
@@ -2350,12 +2307,8 @@ static int ks_wlan_set_wps_probe_req(struct net_device *dev,
 	unsigned char len;
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(2, "\n");
-
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	/* for SLEEP MODE */
-	DPRINTK(2, "dwrq->length=%d\n", dwrq->length);
 
 	/* length check */
 	if (p[1] + 2 != dwrq->length || dwrq->length > 256)
@@ -2789,7 +2742,6 @@ static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq,
 		ret = -EOPNOTSUPP;
 	}
 
-	DPRINTK(5, "return=%d\n", ret);
 	return ret;
 }
 
@@ -2865,8 +2817,6 @@ int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 void send_packet_complete(struct ks_wlan_private *priv, struct sk_buff *skb)
 {
-	DPRINTK(3, "\n");
-
 	priv->nstats.tx_packets++;
 
 	if (netif_queue_stopped(priv->net_dev))
@@ -2887,7 +2837,6 @@ void ks_wlan_set_multicast_list(struct net_device *dev)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(4, "\n");
 	if (priv->dev_state < DEVICE_STATE_READY)
 		return;	/* not finished initialize */
 	hostif_sme_enqueue(priv, SME_MULTICAST_REQUEST);
@@ -2914,9 +2863,6 @@ int ks_wlan_close(struct net_device *dev)
 {
 	netif_stop_queue(dev);
 
-	DPRINTK(4, "%s: Shutting down ethercard, status was 0x%4.4x.\n",
-		dev->name, 0x00);
-
 	return 0;
 }
 

commit c468d584cd687386c33f730b7c5114501f731e85
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Wed Feb 28 21:19:10 2018 -0800

    staging: ks7010: Replace local capability constants with kernel constants.
    
    This driver defined constants BSS_CAP_* to represent WLAN capability
    codes; however, these constants are already defined in the header
    'linux/ieee80211.h' as WLAN_CAPABILITY_*.  This change removes the locally
    defined constants and substitutes the kernel's constants.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Reviewed-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index e48c55769c94..91acf87ab8dd 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1366,8 +1366,8 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 	/* Add mode */
 	iwe.cmd = SIOCGIWMODE;
 	capabilities = ap->capability;
-	if (capabilities & (BSS_CAP_ESS | BSS_CAP_IBSS)) {
-		if (capabilities & BSS_CAP_ESS)
+	if (capabilities & (WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS)) {
+		if (capabilities & WLAN_CAPABILITY_ESS)
 			iwe.u.mode = IW_MODE_INFRA;
 		else
 			iwe.u.mode = IW_MODE_ADHOC;
@@ -1396,7 +1396,7 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 
 	/* Add encryption capability */
 	iwe.cmd = SIOCGIWENCODE;
-	if (capabilities & BSS_CAP_PRIVACY)
+	if (capabilities & WLAN_CAPABILITY_PRIVACY)
 		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
 	else
 		iwe.u.data.flags = IW_ENCODE_DISABLED;

commit 0a20a614658b79660e2aaef28fd03854d50e45de
Author: SUNIL KALLUR RAMEGOWDA <kallur.sunil@gmail.com>
Date:   Wed Dec 13 22:12:04 2017 +0100

    Staging: ks7010: ks_wlan_net: Fixing coding style warning
    
    Removing the extra spaces before tabs, checkpatch:
    WARNING: please, no space before tabs
    
    Signed-off-by: SUNIL KALLUR RAMEGOWDA <kallur.sunil@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 880085e2f24a..e48c55769c94 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2990,7 +2990,7 @@ int ks_wlan_net_stop(struct net_device *dev)
 /**
  * is_connect_status() - return true if status is 'connected'
  * @status: high bit is used as FORCE_DISCONNECT, low bits used for
- * 	connect status.
+ *	connect status.
  */
 bool is_connect_status(u32 status)
 {
@@ -3000,7 +3000,7 @@ bool is_connect_status(u32 status)
 /**
  * is_disconnect_status() - return true if status is 'disconnected'
  * @status: high bit is used as FORCE_DISCONNECT, low bits used for
- * 	disconnect status.
+ *	disconnect status.
  */
 bool is_disconnect_status(u32 status)
 {

commit 8a81f7491655f1fd9398c63048700351cb713471
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 01:26:09 2017 -0700

    staging: ks7010: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Tobin C. Harding" <me@tobin.cc>
    Cc: devel@driverdev.osuosl.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index b82b515a514f..880085e2f24a 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -114,7 +114,7 @@ int ks_wlan_update_phy_information(struct ks_wlan_private *priv)
 }
 
 static
-void ks_wlan_update_phyinfo_timeout(unsigned long ptr)
+void ks_wlan_update_phyinfo_timeout(struct timer_list *unused)
 {
 	DPRINTK(4, "in_interrupt = %ld\n", in_interrupt());
 	atomic_set(&update_phyinfo, 0);
@@ -2951,8 +2951,7 @@ int ks_wlan_net_start(struct net_device *dev)
 
 	/* phy information update timer */
 	atomic_set(&update_phyinfo, 0);
-	setup_timer(&update_phyinfo_timer, ks_wlan_update_phyinfo_timeout,
-		    (unsigned long)priv);
+	timer_setup(&update_phyinfo_timer, ks_wlan_update_phyinfo_timeout, 0);
 
 	/* dummy address set */
 	memcpy(priv->eth_addr, dummy_addr, ETH_ALEN);

commit 583d6a93a5d5fd81a61d8f077c166825f857d48f
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Thu Oct 12 11:15:17 2017 -0500

    staging: ks7010: ks_wlan_net: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Addresses-Coverity-ID: 1364489
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 0f9348ba5d84..b82b515a514f 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -473,13 +473,16 @@ static int ks_wlan_set_rate(struct net_device *dev,
 					priv->reg.rate_set.body[3] =
 					    TX_RATE_11M;
 					i++;
+					/* fall through */
 				case 5500000:
 					priv->reg.rate_set.body[2] = TX_RATE_5M;
 					i++;
+					/* fall through */
 				case 2000000:
 					priv->reg.rate_set.body[1] =
 					    TX_RATE_2M | BASIC_RATE;
 					i++;
+					/* fall through */
 				case 1000000:
 					priv->reg.rate_set.body[0] =
 					    TX_RATE_1M | BASIC_RATE;
@@ -535,14 +538,17 @@ static int ks_wlan_set_rate(struct net_device *dev,
 					priv->reg.rate_set.body[11] =
 					    TX_RATE_54M;
 					i++;
+					/* fall through */
 				case 48000000:
 					priv->reg.rate_set.body[10] =
 					    TX_RATE_48M;
 					i++;
+					/* fall through */
 				case 36000000:
 					priv->reg.rate_set.body[9] =
 					    TX_RATE_36M;
 					i++;
+					/* fall through */
 				case 24000000:
 				case 18000000:
 				case 12000000:
@@ -619,14 +625,17 @@ static int ks_wlan_set_rate(struct net_device *dev,
 						    TX_RATE_6M | BASIC_RATE;
 						i++;
 					}
+					/* fall through */
 				case 5500000:
 					priv->reg.rate_set.body[2] =
 					    TX_RATE_5M | BASIC_RATE;
 					i++;
+					/* fall through */
 				case 2000000:
 					priv->reg.rate_set.body[1] =
 					    TX_RATE_2M | BASIC_RATE;
 					i++;
+					/* fall through */
 				case 1000000:
 					priv->reg.rate_set.body[0] =
 					    TX_RATE_1M | BASIC_RATE;
@@ -2010,6 +2019,7 @@ static int ks_wlan_set_mlme(struct net_device *dev,
 	case IW_MLME_DEAUTH:
 		if (mlme->reason_code == WLAN_REASON_MIC_FAILURE)
 			return 0;
+		/* fall through */
 	case IW_MLME_DISASSOC:
 		mode = 1;
 		return ks_wlan_set_stop_request(dev, NULL, &mode, NULL);

commit 7b379dba14f8039fac06db0fced2e68b86570ddf
Author: Janusz Lisiecki <janusz.lisiecki@gmail.com>
Date:   Mon Jul 3 06:41:39 2017 +0200

    staging: ks7010: Fix cast to restricted __le16 in ks_wlan_net.c
    
    This patch fixes the following Sparse warnings in ks_wlan_net.c:
    drivers/staging/ks7010/ks_wlan_net.c:1359:24: warning: cast to restricted __le16
    link_ap_info_t structure field 'capability' has native order and is used everywhere
    in the code in such way (i.e get_ap_information, get_current_ap). Both sides of
    assignment are u16 (native order) so 'le16_to_cpu' is not needed and wrong.
    
    Signed-off-by: Janusz Lisiecki <janusz.lisiecki@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 8aa12e813bd7..0f9348ba5d84 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1356,7 +1356,7 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 
 	/* Add mode */
 	iwe.cmd = SIOCGIWMODE;
-	capabilities = le16_to_cpu(ap->capability);
+	capabilities = ap->capability;
 	if (capabilities & (BSS_CAP_ESS | BSS_CAP_IBSS)) {
 		if (capabilities & BSS_CAP_ESS)
 			iwe.u.mode = IW_MODE_INFRA;

commit a9cbe2ad656f3e9fc2054853ffc4adda71477fe6
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Jun 28 17:11:29 2017 +0100

    staging: ks7010: fix spelling mistake: "errror" -> "error"
    
    Trivial fix to spelling mistake in netdev_err message
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 0c778aa4bb7a..8aa12e813bd7 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2273,7 +2273,7 @@ static int ks_wlan_set_sleep_mode(struct net_device *dev,
 		netdev_info(dev, "SET_SLEEP_MODE %d\n", priv->sleep_mode);
 		hostif_sme_enqueue(priv, SME_SLEEP_REQUEST);
 	} else {
-		netdev_err(dev, "SET_SLEEP_MODE %d errror\n", *uwrq);
+		netdev_err(dev, "SET_SLEEP_MODE %d error\n", *uwrq);
 		return -EINVAL;
 	}
 

commit 93270634a32b2c4e5ff7c3f1987a5473b484623f
Author: Janusz Lisiecki <janusz.lisiecki@gmail.com>
Date:   Sat Apr 29 22:58:41 2017 +0200

    staging: ks7010: avoid CamelCase in fields of struct local_gain_t
    
    Replace CamelCase fields of struct with underscores to comply
    with the standard kernel coding style
    
    Signed-off-by: Janusz Lisiecki <janusz.lisiecki@gmail.com>
    Reviewed-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 5a43f193dcc8..0c778aa4bb7a 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2378,14 +2378,14 @@ static int ks_wlan_set_tx_gain(struct net_device *dev,
 		return -EPERM;
 	/* for SLEEP MODE */
 	if (*uwrq >= 0 && *uwrq <= 0xFF)	/* 0-255 */
-		priv->gain.TxGain = (uint8_t)*uwrq;
+		priv->gain.tx_gain = (uint8_t)*uwrq;
 	else
 		return -EINVAL;
 
-	if (priv->gain.TxGain < 0xFF)
-		priv->gain.TxMode = 1;
+	if (priv->gain.tx_gain < 0xFF)
+		priv->gain.tx_mode = 1;
 	else
-		priv->gain.TxMode = 0;
+		priv->gain.tx_mode = 0;
 
 	hostif_sme_enqueue(priv, SME_SET_GAIN);
 	return 0;
@@ -2400,7 +2400,7 @@ static int ks_wlan_get_tx_gain(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	*uwrq = priv->gain.TxGain;
+	*uwrq = priv->gain.tx_gain;
 	hostif_sme_enqueue(priv, SME_GET_GAIN);
 	return 0;
 }
@@ -2415,14 +2415,14 @@ static int ks_wlan_set_rx_gain(struct net_device *dev,
 		return -EPERM;
 	/* for SLEEP MODE */
 	if (*uwrq >= 0 && *uwrq <= 0xFF)	/* 0-255 */
-		priv->gain.RxGain = (uint8_t)*uwrq;
+		priv->gain.rx_gain = (uint8_t)*uwrq;
 	else
 		return -EINVAL;
 
-	if (priv->gain.RxGain < 0xFF)
-		priv->gain.RxMode = 1;
+	if (priv->gain.rx_gain < 0xFF)
+		priv->gain.rx_mode = 1;
 	else
-		priv->gain.RxMode = 0;
+		priv->gain.rx_mode = 0;
 
 	hostif_sme_enqueue(priv, SME_SET_GAIN);
 	return 0;
@@ -2437,7 +2437,7 @@ static int ks_wlan_get_rx_gain(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	*uwrq = priv->gain.RxGain;
+	*uwrq = priv->gain.rx_gain;
 	hostif_sme_enqueue(priv, SME_GET_GAIN);
 	return 0;
 }

commit 2b0d92b265324cfe42839a23cb46677bb0112c2c
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:23 2017 +1000

    staging: ks7010: remove cast from netdev_priv()
    
    The returned pointer from netdev_priv() (void *) does not need to be
    cast.
    
    Remove unnecessary cast of void * returned by netdev_priv().
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 0329963374f5..5a43f193dcc8 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -177,8 +177,7 @@ static int ks_wlan_get_name(struct net_device *dev,
 			    struct iw_request_info *info, char *cwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -200,8 +199,7 @@ static int ks_wlan_set_freq(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_freq *fwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	int channel;
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -245,8 +243,7 @@ static int ks_wlan_get_freq(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_freq *fwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	int f;
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -268,8 +265,7 @@ static int ks_wlan_set_essid(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	size_t len;
 
 	DPRINTK(2, " %d\n", dwrq->flags);
@@ -325,8 +321,7 @@ static int ks_wlan_get_essid(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -355,8 +350,7 @@ static int ks_wlan_get_essid(struct net_device *dev,
 static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 			   struct sockaddr *ap_addr, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	DPRINTK(2, "\n");
 
@@ -389,8 +383,7 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 			   struct sockaddr *awrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -410,8 +403,7 @@ static int ks_wlan_set_nick(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_point *dwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -431,8 +423,7 @@ static int ks_wlan_get_nick(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_point *dwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -449,8 +440,7 @@ static int ks_wlan_set_rate(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_param *vwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	int i = 0;
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -682,8 +672,7 @@ static int ks_wlan_get_rate(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_param *vwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	DPRINTK(2, "in_interrupt = %ld update_phyinfo = %d\n",
 		in_interrupt(), atomic_read(&update_phyinfo));
@@ -707,8 +696,7 @@ static int ks_wlan_get_rate(struct net_device *dev,
 static int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
 			   struct iw_param *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	int rthr = vwrq->value;
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -729,8 +717,7 @@ static int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
 static int ks_wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
 			   struct iw_param *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -747,8 +734,7 @@ static int ks_wlan_set_frag(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_param *vwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	int fthr = vwrq->value;
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -771,8 +757,7 @@ static int ks_wlan_get_frag(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_param *vwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -789,8 +774,7 @@ static int ks_wlan_set_mode(struct net_device *dev,
 			    struct iw_request_info *info, __u32 *uwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	DPRINTK(2, "mode=%d\n", *uwrq);
 
@@ -823,8 +807,7 @@ static int ks_wlan_get_mode(struct net_device *dev,
 			    struct iw_request_info *info, __u32 *uwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -849,8 +832,7 @@ static int ks_wlan_set_encode(struct net_device *dev,
 			      struct iw_request_info *info,
 			      struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	struct wep_key key;
 	int index = (dwrq->flags & IW_ENCODE_INDEX);
@@ -965,8 +947,7 @@ static int ks_wlan_get_encode(struct net_device *dev,
 			      struct iw_request_info *info,
 			      struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	char zeros[16];
 	int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
 
@@ -1064,8 +1045,7 @@ static int ks_wlan_get_range(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_range *range = (struct iw_range *)extra;
 	int i, k;
 
@@ -1197,8 +1177,7 @@ static int ks_wlan_set_power(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_param *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -1221,8 +1200,7 @@ static int ks_wlan_get_power(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_param *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -1239,8 +1217,7 @@ static int ks_wlan_get_iwstats(struct net_device *dev,
 			       struct iw_request_info *info,
 			       struct iw_quality *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -1279,8 +1256,7 @@ static int ks_wlan_get_aplist(struct net_device *dev,
 			      struct iw_request_info *info,
 			      struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct sockaddr *address = (struct sockaddr *)extra;
 	struct iw_quality qual[LOCAL_APLIST_MAX];
 
@@ -1312,8 +1288,7 @@ static int ks_wlan_set_scan(struct net_device *dev,
 			    struct iw_request_info *info,
 			    union iwreq_data *wrqu, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_scan_req *req = NULL;
 
 	DPRINTK(2, "\n");
@@ -1506,8 +1481,7 @@ static int ks_wlan_get_scan(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_point *dwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	int i;
 	char *current_ev = extra;
 
@@ -1552,8 +1526,7 @@ static int ks_wlan_config_commit(struct net_device *dev,
 				 struct iw_request_info *info, void *zwrq,
 				 char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (!priv->need_commit)
 		return 0;
@@ -1568,8 +1541,7 @@ static int ks_wlan_set_genie(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	DPRINTK(2, "\n");
 
@@ -1584,8 +1556,7 @@ static int ks_wlan_set_auth_mode(struct net_device *dev,
 				 struct iw_request_info *info,
 				 struct iw_param *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	int index = (vwrq->flags & IW_AUTH_INDEX);
 	int value = vwrq->value;
 
@@ -1719,8 +1690,7 @@ static int ks_wlan_get_auth_mode(struct net_device *dev,
 				 struct iw_request_info *info,
 				 struct iw_param *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	int index = (vwrq->flags & IW_AUTH_INDEX);
 
 	DPRINTK(2, "index=%d\n", index);
@@ -1764,8 +1734,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 				  struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_encode_ext *enc;
 	int index = dwrq->flags & IW_ENCODE_INDEX;
 	unsigned int commit = 0;
@@ -1861,8 +1830,7 @@ static int ks_wlan_get_encode_ext(struct net_device *dev,
 				  struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -1882,8 +1850,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_pmksa *pmksa;
 	int i;
 	struct pmk_t *pmk;
@@ -1982,8 +1949,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 
 static struct iw_statistics *ks_get_wireless_stats(struct net_device *dev)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_statistics *wstats = &priv->wstats;
 
 	if (!atomic_read(&update_phyinfo)) {
@@ -2010,8 +1976,8 @@ static int ks_wlan_set_stop_request(struct net_device *dev,
 				    struct iw_request_info *info, __u32 *uwrq,
 				    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
+
 	DPRINTK(2, "\n");
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -2030,8 +1996,7 @@ static int ks_wlan_set_mlme(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_point *dwrq,
 			    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct iw_mlme *mlme = (struct iw_mlme *)extra;
 	__u32 mode;
 
@@ -2057,8 +2022,8 @@ static int ks_wlan_get_firmware_version(struct net_device *dev,
 					struct iw_request_info *info,
 					struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
+
 	strcpy(extra, priv->firmware_version);
 	dwrq->length = priv->version_size + 1;
 	return 0;
@@ -2068,8 +2033,7 @@ static int ks_wlan_set_preamble(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2091,8 +2055,7 @@ static int ks_wlan_get_preamble(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2106,8 +2069,7 @@ static int ks_wlan_set_power_mgmt(struct net_device *dev,
 				  struct iw_request_info *info, __u32 *uwrq,
 				  char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2138,8 +2100,7 @@ static int ks_wlan_get_power_mgmt(struct net_device *dev,
 				  struct iw_request_info *info, __u32 *uwrq,
 				  char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2153,8 +2114,7 @@ static int ks_wlan_set_scan_type(struct net_device *dev,
 				 struct iw_request_info *info, __u32 *uwrq,
 				 char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2174,8 +2134,7 @@ static int ks_wlan_get_scan_type(struct net_device *dev,
 				 struct iw_request_info *info, __u32 *uwrq,
 				 char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2188,8 +2147,7 @@ static int ks_wlan_set_beacon_lost(struct net_device *dev,
 				   struct iw_request_info *info, __u32 *uwrq,
 				   char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2211,8 +2169,7 @@ static int ks_wlan_get_beacon_lost(struct net_device *dev,
 				   struct iw_request_info *info, __u32 *uwrq,
 				   char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2225,8 +2182,7 @@ static int ks_wlan_set_phy_type(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2249,8 +2205,7 @@ static int ks_wlan_get_phy_type(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2263,8 +2218,7 @@ static int ks_wlan_set_cts_mode(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2290,8 +2244,7 @@ static int ks_wlan_get_cts_mode(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2304,8 +2257,7 @@ static int ks_wlan_set_sleep_mode(struct net_device *dev,
 				  struct iw_request_info *info,
 				  __u32 *uwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	DPRINTK(2, "\n");
 
@@ -2332,8 +2284,7 @@ static int ks_wlan_get_sleep_mode(struct net_device *dev,
 				  struct iw_request_info *info,
 				  __u32 *uwrq, char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	DPRINTK(2, "GET_SLEEP_MODE %d\n", priv->sleep_mode);
 	*uwrq = priv->sleep_mode;
@@ -2347,8 +2298,8 @@ static int ks_wlan_set_wps_enable(struct net_device *dev,
 				  struct iw_request_info *info, __u32 *uwrq,
 				  char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
+
 	DPRINTK(2, "\n");
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -2368,8 +2319,8 @@ static int ks_wlan_get_wps_enable(struct net_device *dev,
 				  struct iw_request_info *info, __u32 *uwrq,
 				  char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
+
 	DPRINTK(2, "\n");
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -2387,8 +2338,7 @@ static int ks_wlan_set_wps_probe_req(struct net_device *dev,
 {
 	u8 *p = extra;
 	unsigned char len;
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	DPRINTK(2, "\n");
 
@@ -2422,8 +2372,7 @@ static int ks_wlan_set_tx_gain(struct net_device *dev,
 			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2446,8 +2395,7 @@ static int ks_wlan_get_tx_gain(struct net_device *dev,
 			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2461,8 +2409,7 @@ static int ks_wlan_set_rx_gain(struct net_device *dev,
 			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2485,8 +2432,7 @@ static int ks_wlan_get_rx_gain(struct net_device *dev,
 			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -2500,8 +2446,7 @@ static int ks_wlan_get_eeprom_cksum(struct net_device *dev,
 				    struct iw_request_info *info, __u32 *uwrq,
 				    char *extra)
 {
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	*uwrq = priv->eeprom_checksum;
 	return 0;
@@ -2625,8 +2570,7 @@ static int ks_wlan_hostt(struct net_device *dev, struct iw_request_info *info,
 			 __u32 *uwrq, char *extra)
 {
 	int i, event;
-	struct ks_wlan_private *priv =
-	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	for (i = 63; i >= 0; i--) {
 		event =

commit 8fb8e05ccafaa0e09fd93d9bffd0b4037cc36317
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:22 2017 +1000

    staging: ks7010: make abbreviation mgmt uniform
    
    Driver currently uses abbreviations 'mgt' and 'mngmt' for
    'management'. Also 'power' is sometimes abbreviated to 'pow' and other
    times not. It makes the code easier to read and easier to modify if
    one abbreviation is used throughout the driver. 'mgmt' is widely
    accepted as an abbreviation of 'management'. 'power' can be spelled
    out in full, the extra two characters aids readability without an
    excessive cost.
    
    Make abbreviation of 'management' uniform across the driver, function
    names, preprocessor defined constants, and enumeration types.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 18e2d1f84150..0329963374f5 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1204,10 +1204,10 @@ static int ks_wlan_set_power(struct net_device *dev,
 		return -EPERM;
 
 	if (vwrq->disabled) {
-		priv->reg.powermgt = POWMGT_ACTIVE_MODE;
+		priv->reg.power_mgmt = POWER_MGMT_ACTIVE;
 	} else {
 		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
-			priv->reg.powermgt = POWMGT_SAVE1_MODE;
+			priv->reg.power_mgmt = POWER_MGMT_SAVE1;
 		else
 			return -EINVAL;
 	}
@@ -1227,7 +1227,7 @@ static int ks_wlan_get_power(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	if (priv->reg.powermgt > 0)
+	if (priv->reg.power_mgmt > 0)
 		vwrq->disabled = 0;
 	else
 		vwrq->disabled = 1;
@@ -2102,9 +2102,9 @@ static int ks_wlan_get_preamble(struct net_device *dev,
 	return 0;
 }
 
-static int ks_wlan_set_powermgt(struct net_device *dev,
-				struct iw_request_info *info, __u32 *uwrq,
-				char *extra)
+static int ks_wlan_set_power_mgmt(struct net_device *dev,
+				  struct iw_request_info *info, __u32 *uwrq,
+				  char *extra)
 {
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
@@ -2113,16 +2113,16 @@ static int ks_wlan_set_powermgt(struct net_device *dev,
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	if (*uwrq == POWMGT_ACTIVE_MODE) {	/* 0 */
-		priv->reg.powermgt = POWMGT_ACTIVE_MODE;
-	} else if (*uwrq == POWMGT_SAVE1_MODE) {	/* 1 */
+	if (*uwrq == POWER_MGMT_ACTIVE) {	/* 0 */
+		priv->reg.power_mgmt = POWER_MGMT_ACTIVE;
+	} else if (*uwrq == POWER_MGMT_SAVE1) {	/* 1 */
 		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
-			priv->reg.powermgt = POWMGT_SAVE1_MODE;
+			priv->reg.power_mgmt = POWER_MGMT_SAVE1;
 		else
 			return -EINVAL;
-	} else if (*uwrq == POWMGT_SAVE2_MODE) {	/* 2 */
+	} else if (*uwrq == POWER_MGMT_SAVE2) {	/* 2 */
 		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
-			priv->reg.powermgt = POWMGT_SAVE2_MODE;
+			priv->reg.power_mgmt = POWER_MGMT_SAVE2;
 		else
 			return -EINVAL;
 	} else {
@@ -2134,9 +2134,9 @@ static int ks_wlan_set_powermgt(struct net_device *dev,
 	return 0;
 }
 
-static int ks_wlan_get_powermgt(struct net_device *dev,
-				struct iw_request_info *info, __u32 *uwrq,
-				char *extra)
+static int ks_wlan_get_power_mgmt(struct net_device *dev,
+				  struct iw_request_info *info, __u32 *uwrq,
+				  char *extra)
 {
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
@@ -2145,7 +2145,7 @@ static int ks_wlan_get_powermgt(struct net_device *dev,
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	*uwrq = priv->reg.powermgt;
+	*uwrq = priv->reg.power_mgmt;
 	return 0;
 }
 
@@ -2528,11 +2528,11 @@ static void print_hif_event(struct net_device *dev, int event)
 	case HIF_MIB_SET_CONF:
 		netdev_info(dev, "HIF_MIB_SET_CONF\n");
 		break;
-	case HIF_POWERMGT_REQ:
-		netdev_info(dev, "HIF_POWERMGT_REQ\n");
+	case HIF_POWER_MGMT_REQ:
+		netdev_info(dev, "HIF_POWER_MGMT_REQ\n");
 		break;
-	case HIF_POWERMGT_CONF:
-		netdev_info(dev, "HIF_POWERMGT_CONF\n");
+	case HIF_POWER_MGMT_CONF:
+		netdev_info(dev, "HIF_POWER_MGMT_CONF\n");
 		break;
 	case HIF_START_REQ:
 		netdev_info(dev, "HIF_START_REQ\n");
@@ -2785,8 +2785,8 @@ static const iw_handler ks_wlan_private_handler[] = {
 	(iw_handler)ks_wlan_get_eeprom_cksum,	/*  7 KS_WLAN_GET_CONNECT */
 	(iw_handler)ks_wlan_set_preamble,	/*  8 KS_WLAN_SET_PREAMBLE */
 	(iw_handler)ks_wlan_get_preamble,	/*  9 KS_WLAN_GET_PREAMBLE */
-	(iw_handler)ks_wlan_set_powermgt,	/* 10 KS_WLAN_SET_POWER_SAVE */
-	(iw_handler)ks_wlan_get_powermgt,	/* 11 KS_WLAN_GET_POWER_SAVE */
+	(iw_handler)ks_wlan_set_power_mgmt,	/* 10 KS_WLAN_SET_POWER_SAVE */
+	(iw_handler)ks_wlan_get_power_mgmt,	/* 11 KS_WLAN_GET_POWER_SAVE */
 	(iw_handler)ks_wlan_set_scan_type,	/* 12 KS_WLAN_SET_SCAN_TYPE */
 	(iw_handler)ks_wlan_get_scan_type,	/* 13 KS_WLAN_GET_SCAN_TYPE */
 	(iw_handler)ks_wlan_set_rx_gain,	/* 14 KS_WLAN_SET_RX_GAIN */

commit 0e24eb8abf93a2e80ecbe97419d2d1fe089a7386
Author: Tobin C. Harding <me@tobin.cc>
Date:   Thu Apr 27 11:25:19 2017 +1000

    staging: ks7010: abstract connection status
    
    Host interface connection status is handled using a 32 bit type. Top
    byte is used as for FORCE_DISCONNECT status, low bits are used for
    connect/disconnect status. Driver masks and checks integers to
    ascertain status. If functions are defined to do the masking and
    equality check then the details of how the status integer is used are
    abstracted away. This makes the code easier to read. Also future
    updates to the status handling will be easier because the code is in
    one place.
    
    Driver currently uses the CONNECT_STATUS and DISCONNECT_STATUS as
    values, as apposed to opaque values. Because of this driver code
    checks for equality with CONNECT_STATUS and DISCONNECT_STATUS as
    apposed to negating a single check (ie 'foo != CONNECT_STATUS). In
    order to maintain the current functionality we define two separate
    functions is_connect_status() and is_disconnect_status().
    
    Add functions to abstract the status integer check. Update all sites
    that do the check manually to use the newly defined functions.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 0ef52c85a50b..18e2d1f84150 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -253,10 +253,11 @@ static int ks_wlan_get_freq(struct net_device *dev,
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS)
+	if (is_connect_status(priv->connect_status))
 		f = (int)priv->current_ap.channel;
-		else
+	else
 		f = (int)priv->reg.channel;
+
 	fwrq->m = frequency_list[f - 1] * 100000;
 	fwrq->e = 1;
 
@@ -395,7 +396,7 @@ static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS)
+	if (is_connect_status(priv->connect_status))
 		memcpy(awrq->sa_data, priv->current_ap.bssid, ETH_ALEN);
 	else
 		eth_zero_addr(awrq->sa_data);
@@ -3032,3 +3033,23 @@ int ks_wlan_net_stop(struct net_device *dev)
 
 	return 0;
 }
+
+/**
+ * is_connect_status() - return true if status is 'connected'
+ * @status: high bit is used as FORCE_DISCONNECT, low bits used for
+ * 	connect status.
+ */
+bool is_connect_status(u32 status)
+{
+	return (status & CONNECT_STATUS_MASK) == CONNECT_STATUS;
+}
+
+/**
+ * is_disconnect_status() - return true if status is 'disconnected'
+ * @status: high bit is used as FORCE_DISCONNECT, low bits used for
+ * 	disconnect status.
+ */
+bool is_disconnect_status(u32 status)
+{
+	return (status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS;
+}

commit 055da4f9b95dd2a50c653b5a4559b9186081fb75
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Apr 18 10:35:31 2017 +1000

    staging: ks7010: fix complete_handler
    
    complete_handler() takes void * types as parameters. void * parameters are then
    cast to struct types. Call sites for this function either pass in NULL
    or pointers to the struct types cast to void *. This casting is
    unnecessary and can be removed.
    
    Struct tx_device_buffer (which contains a pointer member to the
    complete_handler() function) has as member 'ks_wlan_priv *priv' this is
    unnecessary, we always have a pointer to this struct there is no need
    to store it here.
    
    The complete_handler can be more clearly defined by using struct
    pointer types instead of void * types. The code is currently
    unnecessarily complex, storing and passing extraneous pointer
    parameters.
    
    Remove unnecessary parameters, unnecessary casting to/from 'void
    *'. Fix all call sites involving complete_handler().
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index a34ff47e4ac9..0ef52c85a50b 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2908,11 +2908,8 @@ int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	return 0;
 }
 
-void send_packet_complete(void *arg1, void *arg2)
+void send_packet_complete(struct ks_wlan_private *priv, struct sk_buff *skb)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)arg1;
-	struct sk_buff *packet = (struct sk_buff *)arg2;
-
 	DPRINTK(3, "\n");
 
 	priv->nstats.tx_packets++;
@@ -2920,10 +2917,9 @@ void send_packet_complete(void *arg1, void *arg2)
 	if (netif_queue_stopped(priv->net_dev))
 		netif_wake_queue(priv->net_dev);
 
-	if (packet) {
-		priv->nstats.tx_bytes += packet->len;
-		dev_kfree_skb(packet);
-		packet = NULL;
+	if (skb) {
+		priv->nstats.tx_bytes += skb->len;
+		dev_kfree_skb(skb);
 	}
 }
 

commit ba9328768b1e7d827ac86f94340af9bd084be8d5
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:53 2017 +1000

    staging: ks7010: fix checkpatch UNNECESSARY_ELSE
    
    Checkpatch emits WARNING: else is not generally useful after a break
    or return. Two warnings of this type are emitted for this code block,
    in both cases 'else' statements are unnecessary.
    
    Remove unnecessary 'else' statements, reduce indentation in subsequent
    code.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 3172bf35879e..a34ff47e4ac9 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -202,6 +202,7 @@ static int ks_wlan_set_freq(struct net_device *dev,
 {
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
+	int channel;
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -220,25 +221,23 @@ static int ks_wlan_set_freq(struct net_device *dev,
 		fwrq->m = c + 1;
 	}
 	/* Setting by channel number */
-	if ((fwrq->m > 1000) || (fwrq->e > 0)) {
+	if ((fwrq->m > 1000) || (fwrq->e > 0))
 		return -EOPNOTSUPP;
-	} else {
-		int channel = fwrq->m;
-		/* We should do a better check than that,
-		 * based on the card capability !!!
-		 */
-		if ((channel < 1) || (channel > 14)) {
-			netdev_dbg(dev,
-				   "%s: New channel value of %d is invalid!\n",
-				   dev->name, fwrq->m);
-			return -EINVAL;
-		} else {
-			/* Yes ! We can set it !!! */
-			priv->reg.channel = (u8)(channel);
-			priv->need_commit |= SME_MODE_SET;
-		}
+
+	channel = fwrq->m;
+	/* We should do a better check than that,
+	 * based on the card capability !!!
+	 */
+	if ((channel < 1) || (channel > 14)) {
+		netdev_dbg(dev, "%s: New channel value of %d is invalid!\n",
+			   dev->name, fwrq->m);
+		return -EINVAL;
 	}
 
+	/* Yes ! We can set it !!! */
+	priv->reg.channel = (u8)(channel);
+	priv->need_commit |= SME_MODE_SET;
+
 	return -EINPROGRESS;	/* Call commit handler */
 }
 

commit 8f0ef774b8379adaa985506da3c7c185d938502b
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:52 2017 +1000

    staging: ks7010: fix checkpatch PARENTHESIS_ALIGNMENT
    
    Checkpatch emits CHECK: Alignment should match open parenthesis.
    
    Align argument to open parenthesis.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index c36ce652c994..3172bf35879e 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1932,7 +1932,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 			for (i = 0; i < PMK_LIST_MAX; i++) {
 				pmk = &priv->pmklist.pmk[i];
 				if (memcmp("\x00\x00\x00\x00\x00\x00",
-					    pmk->bssid, ETH_ALEN) == 0)
+					   pmk->bssid, ETH_ALEN) == 0)
 					break; /* loop */
 			}
 			memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);

commit 3da1b2371ec27accebe601e84a41f8b67f9b5688
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:51 2017 +1000

    staging: ks7010: utilize local variable
    
    Function contains a local pointer variable defined to a memory location
    within a structure. This memory location is later used by
    dereferencing the struct instead of using the local pointer. The code
    is cleaner if all references of the same memory location use the
    local variable.
    
    Utilize existing local pointer variable instead of dereferencing
    struct.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 9ee83a72714a..c36ce652c994 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1788,9 +1788,9 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	key = &priv->wpa.key[index];
 
 	if (dwrq->flags & IW_ENCODE_DISABLED)
-		priv->wpa.key[index].key_len = 0;
+		key->key_len = 0;
 
-	priv->wpa.key[index].ext_flags = enc->ext_flags;
+	key->ext_flags = enc->ext_flags;
 	if (enc->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
 		priv->wpa.txkey = index;
 		commit |= SME_WEP_INDEX;
@@ -1806,7 +1806,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 			priv->reg.privacy_invoked = 0x00;
 			commit |= SME_WEP_FLAG;
 		}
-		priv->wpa.key[index].key_len = 0;
+		key->key_len = 0;
 
 		break;
 	case IW_ENCODE_ALG_WEP:
@@ -1842,7 +1842,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	default:
 		return -EINVAL;
 	}
-	priv->wpa.key[index].alg = enc->alg;
+	key->alg = enc->alg;
 
 	if (commit) {
 		if (commit & SME_WEP_INDEX)

commit b121d84882b97b8668be0b95e9ba50cfd01aa0f1
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:50 2017 +1000

    staging: ks7010: simplify calls to memcpy()
    
    Function uses overly complex calls to memcpy(). Code may be simplified
    by the use of a local variable. Code sometimes uses explicit address
    of initial array element and sometimes does not. Uniformity aids
    readability. If array pointers are explicit it aids readability further.
    
    Simplify calls to memcpy(). Add local pointer variable, define it to
    the correct memory location. Use newly defined variable in calls to
    memcpy(). Be uniform in use of explicit address of first element of
    array (&foo[0]).
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index eb3573e5365d..9ee83a72714a 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1769,6 +1769,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	struct iw_encode_ext *enc;
 	int index = dwrq->flags & IW_ENCODE_INDEX;
 	unsigned int commit = 0;
+	struct wpa_key_t *key;
 
 	enc = (struct iw_encode_ext *)extra;
 	if (!enc)
@@ -1784,6 +1785,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	if (index < 1 || index > 4)
 		return -EINVAL;
 	index--;
+	key = &priv->wpa.key[index];
 
 	if (dwrq->flags & IW_ENCODE_DISABLED)
 		priv->wpa.key[index].key_len = 0;
@@ -1793,12 +1795,10 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 		priv->wpa.txkey = index;
 		commit |= SME_WEP_INDEX;
 	} else if (enc->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
-		memcpy(&priv->wpa.key[index].rx_seq[0],
-		       enc->rx_seq, IW_ENCODE_SEQ_MAX_SIZE);
+		memcpy(&key->rx_seq[0], &enc->rx_seq[0], IW_ENCODE_SEQ_MAX_SIZE);
 	}
 
-	memcpy(&priv->wpa.key[index].addr.sa_data[0],
-	       &enc->addr.sa_data[0], ETH_ALEN);
+	memcpy(&key->addr.sa_data[0], &enc->addr.sa_data[0], ETH_ALEN);
 
 	switch (enc->alg) {
 	case IW_ENCODE_ALG_NONE:
@@ -1816,9 +1816,8 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 			commit |= SME_WEP_FLAG;
 		}
 		if (enc->key_len) {
-			memcpy(&priv->wpa.key[index].key_val[0],
-			       &enc->key[0], enc->key_len);
-			priv->wpa.key[index].key_len = enc->key_len;
+			memcpy(&key->key_val[0], &enc->key[0], enc->key_len);
+			key->key_len = enc->key_len;
 			commit |= (SME_WEP_VAL1 << index);
 		}
 		break;
@@ -1828,20 +1827,14 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 			commit |= SME_WEP_FLAG;
 		}
 		if (enc->key_len == 32) {
-			memcpy(&priv->wpa.key[index].key_val[0],
-			       &enc->key[0], enc->key_len - 16);
-			priv->wpa.key[index].key_len =
-				enc->key_len - 16;
+			memcpy(&key->key_val[0], &enc->key[0], enc->key_len - 16);
+			key->key_len = enc->key_len - 16;
 			if (priv->wpa.key_mgmt_suite == 4) {	/* WPA_NONE */
-				memcpy(&priv->wpa.key[index].
-				       tx_mic_key[0], &enc->key[16], 8);
-				memcpy(&priv->wpa.key[index].
-				       rx_mic_key[0], &enc->key[16], 8);
+				memcpy(&key->tx_mic_key[0], &enc->key[16], 8);
+				memcpy(&key->rx_mic_key[0], &enc->key[16], 8);
 			} else {
-				memcpy(&priv->wpa.key[index].
-				       tx_mic_key[0], &enc->key[16], 8);
-				memcpy(&priv->wpa.key[index].
-				       rx_mic_key[0], &enc->key[24], 8);
+				memcpy(&key->tx_mic_key[0], &enc->key[16], 8);
+				memcpy(&key->rx_mic_key[0], &enc->key[24], 8);
 			}
 			commit |= (SME_WEP_VAL1 << index);
 		}

commit 9ff19a6e35ab460c07dc40c563b57b0ad866e2e9
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:49 2017 +1000

    staging: ks7010: move null check before dereference
    
    Function parameter is cast to a local pointer which is then
    dereferenced before it is checked to be non-NULL.
    
    Move pointer null check to be before the pointer is dereferenced.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 89fcd23e8f94..eb3573e5365d 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1771,6 +1771,8 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	unsigned int commit = 0;
 
 	enc = (struct iw_encode_ext *)extra;
+	if (!enc)
+		return -EINVAL;
 
 	DPRINTK(2, "flags=%04X:: ext_flags=%08X\n", dwrq->flags,
 		enc->ext_flags);
@@ -1786,9 +1788,6 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	if (dwrq->flags & IW_ENCODE_DISABLED)
 		priv->wpa.key[index].key_len = 0;
 
-	if (!enc)
-		return -EINVAL;
-
 	priv->wpa.key[index].ext_flags = enc->ext_flags;
 	if (enc->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
 		priv->wpa.txkey = index;

commit dc59ef2af26de72289b5ac576298445c676f2c5b
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:48 2017 +1000

    staging: ks7010: fix multi-way decision
    
    Multi-way decision contains two anomalies.
    
    Firstly, a local variable is defined to be the inverse truth variable
    of a struct member. This local variable is used as the conditional to
    the multi-way decision. This is unnecessary, the same logic can be
    expressed using the struct member directly.
    
    Secondly, there are four branches in the multi-way decision, two of
    which can never be executed. This is dead code.
    
    Remove unnecessary local variable. Remove two branches of multi-way
    decision statement that can never be executed.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index e86e5e2b6d5c..89fcd23e8f94 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1199,27 +1199,17 @@ static int ks_wlan_set_power(struct net_device *dev,
 {
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
-	short enabled;
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
-	/* for SLEEP MODE */
-	enabled = vwrq->disabled ? 0 : 1;
-	if (enabled == 0) {	/* 0 */
+	if (vwrq->disabled) {
 		priv->reg.powermgt = POWMGT_ACTIVE_MODE;
-	} else if (enabled) {	/* 1 */
+	} else {
 		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
 			priv->reg.powermgt = POWMGT_SAVE1_MODE;
 		else
 			return -EINVAL;
-	} else if (enabled) {	/* 2 */
-		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
-			priv->reg.powermgt = POWMGT_SAVE2_MODE;
-		else
-			return -EINVAL;
-	} else {
-		return -EINVAL;
 	}
 
 	hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);

commit 03b0244924795d30e1619894d8aa13c0fcfe233c
Author: Tobin C. Harding <me@tobin.cc>
Date:   Mon Apr 10 13:15:41 2017 +1000

    staging: ks7010: rename identifier rc to ret
    
    Driver uses identifier 'rc' to hold the value for error return
    code. The rest of the driver predominately uses 'ret' for this
    purpose. It is easier to follow the code if one name is used for one
    task.
    
    Rename identifier 'rc' to 'ret'.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 5e686996e1ce..e86e5e2b6d5c 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2902,7 +2902,7 @@ static
 int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
-	int rc = 0;
+	int ret;
 
 	DPRINTK(3, "in_interrupt()=%ld\n", in_interrupt());
 
@@ -2918,14 +2918,13 @@ int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	if (netif_running(dev))
 		netif_stop_queue(dev);
 
-	rc = hostif_data_request(priv, skb);
+	ret = hostif_data_request(priv, skb);
 	netif_trans_update(dev);
 
-	DPRINTK(4, "rc=%d\n", rc);
-	if (rc)
-		rc = 0;
+	if (ret)
+		DPRINTK(4, "hostif_data_request error: =%d\n", ret);
 
-	return rc;
+	return 0;
 }
 
 void send_packet_complete(void *arg1, void *arg2)

commit 310e916f54579b2d9a33fd6501cc46acc2d4dc70
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 22 11:59:54 2017 +1100

    staging: ks7010: add explicit check to 'size' variables
    
    When checking the value of a variable that holds a 0 an explicit check
    is good style. i.e
    
      -    if (!size)
      +    if (size == 0)
    
    Update checks on 'numerical' variables to use explicit checks.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index c097ecd576db..5e686996e1ce 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -335,7 +335,7 @@ static int ks_wlan_get_essid(struct net_device *dev,
 	/* Note : if dwrq->flags != 0, we should
 	 * get the relevant SSID from the SSID list...
 	 */
-	if (priv->reg.ssid.size) {
+	if (priv->reg.ssid.size != 0) {
 		/* Get the current SSID */
 		memcpy(extra, priv->reg.ssid.body, priv->reg.ssid.size);
 
@@ -928,7 +928,7 @@ static int ks_wlan_set_encode(struct net_device *dev,
 			/* Do we want to just set the transmit key index ? */
 			if ((index >= 0) && (index < 4)) {
 				/* set_wep_key(priv, index, 0, 0, 1);   xxx */
-				if (priv->reg.wep_key[index].size) {
+				if (priv->reg.wep_key[index].size != 0) {
 					priv->reg.wep_index = index;
 					priv->need_commit |= SME_WEP_INDEX;
 				} else {
@@ -1531,7 +1531,7 @@ static int ks_wlan_get_scan(struct net_device *dev,
 		return -EAGAIN;
 	}
 
-	if (!priv->aplist.size) {
+	if (priv->aplist.size == 0) {
 		/* Client error, no scan results...
 		 * The caller need to restart the scan.
 		 */

commit b5ca039ac17594e870a12c68ca8847700aa300dd
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 22 11:59:53 2017 +1100

    staging: ks7010: add explicit check to memcmp() calls
    
    Calls to functions memcmp() and strcmp() are more clearly readable
    when the return value is explicitly checked. i.e
    
    if (memcmp(foo, bar, size) == 0)
    
    Modify driver to use an explicit check on the value returned by
    memcmp().
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 3f9eba4065bd..c097ecd576db 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1924,9 +1924,8 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 		if (list_empty(&priv->pmklist.head)) {	/* new list */
 			for (i = 0; i < PMK_LIST_MAX; i++) {
 				pmk = &priv->pmklist.pmk[i];
-				if (!memcmp
-				    ("\x00\x00\x00\x00\x00\x00", pmk->bssid,
-				     ETH_ALEN))
+				if (memcmp("\x00\x00\x00\x00\x00\x00",
+					   pmk->bssid, ETH_ALEN) == 0)
 					break; /* loop */
 			}
 			memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
@@ -1938,7 +1937,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 		/* search cache data */
 		list_for_each(ptr, &priv->pmklist.head) {
 			pmk = list_entry(ptr, struct pmk_t, list);
-			if (!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)) {	/* match address! list move to head. */
+			if (memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN) == 0) {
 				memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
 				list_move(&pmk->list, &priv->pmklist.head);
 				break; /* list_for_each */
@@ -1950,8 +1949,8 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 		if (priv->pmklist.size < PMK_LIST_MAX) {	/* new cache data */
 			for (i = 0; i < PMK_LIST_MAX; i++) {
 				pmk = &priv->pmklist.pmk[i];
-				if (!memcmp("\x00\x00\x00\x00\x00\x00",
-					    pmk->bssid, ETH_ALEN))
+				if (memcmp("\x00\x00\x00\x00\x00\x00",
+					    pmk->bssid, ETH_ALEN) == 0)
 					break; /* loop */
 			}
 			memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
@@ -1973,7 +1972,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 		/* search cache data */
 		list_for_each(ptr, &priv->pmklist.head) {
 			pmk = list_entry(ptr, struct pmk_t, list);
-			if (!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)) {	/* match address! list del. */
+			if (memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN) == 0) {
 				eth_zero_addr(pmk->bssid);
 				memset(pmk->pmkid, 0, IW_PMKID_LEN);
 				list_del_init(&pmk->list);

commit 1770ae9d3f7f2849d7a7a24f93af44a59790a647
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:12 2017 +1100

    staging: ks7010: rename return value identifier
    
    Driver uses multiple identifier names for the same task (retval, ret,
    rc). It would be easier to read the code if a single task is
    identified with a single name. 'ret' is the most common return value
    identifier name found in the kernel tree, following the principle of
    least surprise using 'ret' is a decent choice.
    
    Rename rc -> ret
    Rename retval -> ret
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 7d4c7f3dd8c5..3f9eba4065bd 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2842,20 +2842,20 @@ static const struct iw_handler_def ks_wlan_handler_def = {
 static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq,
 				int cmd)
 {
-	int rc = 0;
+	int ret;
 	struct iwreq *wrq = (struct iwreq *)rq;
 
 	switch (cmd) {
 	case SIOCIWFIRSTPRIV + 20:	/* KS_WLAN_SET_STOP_REQ */
-		rc = ks_wlan_set_stop_request(dev, NULL, &wrq->u.mode, NULL);
+		ret = ks_wlan_set_stop_request(dev, NULL, &wrq->u.mode, NULL);
 		break;
 		// All other calls are currently unsupported
 	default:
-		rc = -EOPNOTSUPP;
+		ret = -EOPNOTSUPP;
 	}
 
-	DPRINTK(5, "return=%d\n", rc);
-	return rc;
+	DPRINTK(5, "return=%d\n", ret);
+	return ret;
 }
 
 static

commit 1e765f318824b2f182dedb5e74e05b9f132e07ca
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:11 2017 +1100

    staging: ks7010: remove zero comparison
    
    Comparison, equal to zero, is redundant
    
    'if (foo == 0)'  is equal to  'if (!foo)'
    
    Typical kernel coding style is to use the shorter form.
    
    Remove unnecessary zero comparison.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index d96eed6c8e58..7d4c7f3dd8c5 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -279,7 +279,7 @@ static int ks_wlan_set_essid(struct net_device *dev,
 
 	/* for SLEEP MODE */
 	/* Check if we asked for `any' */
-	if (dwrq->flags == 0) {
+	if (!dwrq->flags) {
 		/* Just send an empty SSID list */
 		memset(priv->reg.ssid.body, 0, sizeof(priv->reg.ssid.body));
 		priv->reg.ssid.size = 0;
@@ -1531,7 +1531,7 @@ static int ks_wlan_get_scan(struct net_device *dev,
 		return -EAGAIN;
 	}
 
-	if (priv->aplist.size == 0) {
+	if (!priv->aplist.size) {
 		/* Client error, no scan results...
 		 * The caller need to restart the scan.
 		 */

commit 13b05e467d8f22c8ce871ffc7daa536df1beb0ce
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:08 2017 +1100

    staging: ks7010: return directly on error
    
    Function uses goto label with no clean up code. In this case we
    should just return directly.
    
    Remove goto statement, return directly on error.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index f18ff56adf0e..d96eed6c8e58 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -202,7 +202,6 @@ static int ks_wlan_set_freq(struct net_device *dev,
 {
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
-	int rc = -EINPROGRESS;	/* Call commit handler */
 
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
@@ -222,7 +221,7 @@ static int ks_wlan_set_freq(struct net_device *dev,
 	}
 	/* Setting by channel number */
 	if ((fwrq->m > 1000) || (fwrq->e > 0)) {
-		rc = -EOPNOTSUPP;
+		return -EOPNOTSUPP;
 	} else {
 		int channel = fwrq->m;
 		/* We should do a better check than that,
@@ -232,7 +231,7 @@ static int ks_wlan_set_freq(struct net_device *dev,
 			netdev_dbg(dev,
 				   "%s: New channel value of %d is invalid!\n",
 				   dev->name, fwrq->m);
-			rc = -EINVAL;
+			return -EINVAL;
 		} else {
 			/* Yes ! We can set it !!! */
 			priv->reg.channel = (u8)(channel);
@@ -240,7 +239,7 @@ static int ks_wlan_set_freq(struct net_device *dev,
 		}
 	}
 
-	return rc;
+	return -EINPROGRESS;	/* Call commit handler */
 }
 
 static int ks_wlan_get_freq(struct net_device *dev,

commit 44c3cd5e0459fe1b6611bba9eb6b4d7d8c650686
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:05 2017 +1100

    staging: ks7010: fix checkpatch PARENTHESIS_ALIGNMENT
    
    Checkpatch emits CHECK: Alignment should match open parenthesis.
    
    Fix alignment to open parenthesis in line with kernel coding style.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index f6f7ffda28c8..f18ff56adf0e 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1806,11 +1806,11 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 		commit |= SME_WEP_INDEX;
 	} else if (enc->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
 		memcpy(&priv->wpa.key[index].rx_seq[0],
-			enc->rx_seq, IW_ENCODE_SEQ_MAX_SIZE);
+		       enc->rx_seq, IW_ENCODE_SEQ_MAX_SIZE);
 	}
 
 	memcpy(&priv->wpa.key[index].addr.sa_data[0],
-		&enc->addr.sa_data[0], ETH_ALEN);
+	       &enc->addr.sa_data[0], ETH_ALEN);
 
 	switch (enc->alg) {
 	case IW_ENCODE_ALG_NONE:
@@ -1829,7 +1829,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 		}
 		if (enc->key_len) {
 			memcpy(&priv->wpa.key[index].key_val[0],
-				&enc->key[0], enc->key_len);
+			       &enc->key[0], enc->key_len);
 			priv->wpa.key[index].key_len = enc->key_len;
 			commit |= (SME_WEP_VAL1 << index);
 		}
@@ -1841,19 +1841,19 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 		}
 		if (enc->key_len == 32) {
 			memcpy(&priv->wpa.key[index].key_val[0],
-				&enc->key[0], enc->key_len - 16);
+			       &enc->key[0], enc->key_len - 16);
 			priv->wpa.key[index].key_len =
 				enc->key_len - 16;
 			if (priv->wpa.key_mgmt_suite == 4) {	/* WPA_NONE */
 				memcpy(&priv->wpa.key[index].
-					tx_mic_key[0], &enc->key[16], 8);
+				       tx_mic_key[0], &enc->key[16], 8);
 				memcpy(&priv->wpa.key[index].
-					rx_mic_key[0], &enc->key[16], 8);
+				       rx_mic_key[0], &enc->key[16], 8);
 			} else {
 				memcpy(&priv->wpa.key[index].
-					tx_mic_key[0], &enc->key[16], 8);
+				       tx_mic_key[0], &enc->key[16], 8);
 				memcpy(&priv->wpa.key[index].
-					rx_mic_key[0], &enc->key[24], 8);
+				       rx_mic_key[0], &enc->key[24], 8);
 			}
 			commit |= (SME_WEP_VAL1 << index);
 		}

commit 44f2bf55e2f8e000d7e6e6384844a899f66e78ab
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 21 13:37:03 2017 +1100

    staging: ks7010: fix checkpatch LINE_SPACING
    
    Checkpatch emits CHECK: Please use a blank line after
    function/struct/union/enum declarations.
    
    Add blank line after function definition.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 1b7027c6724f..f6f7ffda28c8 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2360,6 +2360,7 @@ static int ks_wlan_get_sleep_mode(struct net_device *dev,
 
 	return 0;
 }
+
 #ifdef WPS
 
 static int ks_wlan_set_wps_enable(struct net_device *dev,

commit 6cdd65389892c6017666c499993fb1affc16223e
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 15 13:57:32 2017 +1100

    staging: ks7010: remove dead code
    
    Driver has dead code compiled out using preprocessor directives. TODO
    file asks for these not to be removed - ignore this.
    
    Remove dead code. Remove 'do not remove #if 0/1 ...' from TODO file.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 2b13c004bdae..1b7027c6724f 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -339,25 +339,14 @@ static int ks_wlan_get_essid(struct net_device *dev,
 	if (priv->reg.ssid.size) {
 		/* Get the current SSID */
 		memcpy(extra, priv->reg.ssid.body, priv->reg.ssid.size);
-#if 0
-		extra[priv->reg.ssid.size] = '\0';
-#endif
+
 		/* If none, we may want to get the one that was set */
 
 		/* Push it out ! */
-#if 1
 		dwrq->length = priv->reg.ssid.size;
-#else
-		dwrq->length = priv->reg.ssid.size + 1;
-#endif
 		dwrq->flags = 1;	/* active */
 	} else {
-#if 1
 		dwrq->length = 0;
-#else
-		extra[0] = '\0';
-		dwrq->length = 1;
-#endif
 		dwrq->flags = 0;	/* ANY */
 	}
 
@@ -1550,18 +1539,7 @@ static int ks_wlan_get_scan(struct net_device *dev,
 		DPRINTK(2, "aplist 0\n");
 		return -ENODATA;
 	}
-#if 0
-	/* current connect ap */
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
-		if ((extra + dwrq->length) - current_ev <= IW_EV_ADDR_LEN) {
-			dwrq->length = 0;
-			return -E2BIG;
-		}
-		current_ev = ks_wlan_translate_scan(dev, current_ev,
-						    extra + dwrq->length,
-						    &priv->current_ap);
-	}
-#endif
+
 	/* Read and parse all entries */
 	for (i = 0; i < priv->aplist.size; i++) {
 		if ((extra + dwrq->length) - current_ev <= IW_EV_ADDR_LEN) {
@@ -2106,66 +2084,6 @@ static int ks_wlan_get_firmware_version(struct net_device *dev,
 	return 0;
 }
 
-#if 0
-/*------------------------------------------------------------------*/
-/* Private handler : set force disconnect status */
-static int ks_wlan_set_detach(struct net_device *dev,
-			      struct iw_request_info *info, __u32 *uwrq,
-			      char *extra)
-{
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-
-	if (priv->sleep_mode == SLP_SLEEP)
-		return -EPERM;
-
-	/* for SLEEP MODE */
-	if (*uwrq == CONNECT_STATUS) {	/* 0 */
-		priv->connect_status &= ~FORCE_DISCONNECT;
-		if ((priv->connect_status & CONNECT_STATUS_MASK) ==
-		    CONNECT_STATUS)
-			netif_carrier_on(dev);
-	} else if (*uwrq == DISCONNECT_STATUS) {	/* 1 */
-		priv->connect_status |= FORCE_DISCONNECT;
-		netif_carrier_off(dev);
-	} else {
-		return -EINVAL;
-	}
-	return 0;
-}
-
-/*------------------------------------------------------------------*/
-/* Private handler : get force disconnect status */
-static int ks_wlan_get_detach(struct net_device *dev,
-			      struct iw_request_info *info, __u32 *uwrq,
-			      char *extra)
-{
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-
-	if (priv->sleep_mode == SLP_SLEEP)
-		return -EPERM;
-
-	/* for SLEEP MODE */
-	*uwrq = ((priv->connect_status & FORCE_DISCONNECT) ? 1 : 0);
-	return 0;
-}
-
-/*------------------------------------------------------------------*/
-/* Private handler : get connect status */
-static int ks_wlan_get_connect(struct net_device *dev,
-			       struct iw_request_info *info, __u32 *uwrq,
-			       char *extra)
-{
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-
-	if (priv->sleep_mode == SLP_SLEEP)
-		return -EPERM;
-
-	/* for SLEEP MODE */
-	*uwrq = (priv->connect_status & CONNECT_STATUS_MASK);
-	return 0;
-}
-#endif
-
 static int ks_wlan_set_preamble(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
@@ -2286,137 +2204,6 @@ static int ks_wlan_get_scan_type(struct net_device *dev,
 	return 0;
 }
 
-#if 0
-/*------------------------------------------------------------------*/
-/* Private handler : write raw data to device */
-static int ks_wlan_data_write(struct net_device *dev,
-			      struct iw_request_info *info,
-			      struct iw_point *dwrq, char *extra)
-{
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-	unsigned char *wbuff = NULL;
-
-	if (priv->sleep_mode == SLP_SLEEP)
-		return -EPERM;
-	/* for SLEEP MODE */
-	wbuff = kmalloc(dwrq->length, GFP_ATOMIC);
-	if (!wbuff)
-		return -EFAULT;
-	memcpy(wbuff, extra, dwrq->length);
-
-	/* write to device */
-	ks_wlan_hw_tx(priv, wbuff, dwrq->length, NULL, NULL, NULL);
-
-	return 0;
-}
-
-/*------------------------------------------------------------------*/
-/* Private handler : read raw data form device */
-static int ks_wlan_data_read(struct net_device *dev,
-			     struct iw_request_info *info,
-			     struct iw_point *dwrq, char *extra)
-{
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-	unsigned short read_length;
-
-	if (priv->sleep_mode == SLP_SLEEP)
-		return -EPERM;
-	/* for SLEEP MODE */
-	if (!atomic_read(&priv->event_count)) {
-		if (priv->dev_state < DEVICE_STATE_BOOT) {	/* Remove device */
-			read_length = 4;
-			memset(extra, 0xff, read_length);
-			dwrq->length = read_length;
-			return 0;
-		}
-		read_length = 0;
-		*extra = '\0';
-		dwrq->length = 0;
-		return 0;
-	}
-
-	if (atomic_read(&priv->event_count) > 0)
-		atomic_dec(&priv->event_count);
-
-	spin_lock(&priv->dev_read_lock);	/* request spin lock */
-
-	/* Copy length max size 0x07ff */
-	if (priv->dev_size[priv->dev_count] > 2047)
-		read_length = 2047;
-	else
-		read_length = priv->dev_size[priv->dev_count];
-
-	/* Copy data */
-	memcpy(extra, &priv->dev_data[priv->dev_count][0], read_length);
-
-	spin_unlock(&priv->dev_read_lock);	/* release spin lock */
-
-	/* Initialize */
-	priv->dev_data[priv->dev_count] = 0;
-	priv->dev_size[priv->dev_count] = 0;
-
-	priv->dev_count++;
-	if (priv->dev_count == DEVICE_STOCK_COUNT)
-		priv->dev_count = 0;
-
-	/* Set read size */
-	dwrq->length = read_length;
-
-	return 0;
-}
-#endif
-
-#if 0
-/*------------------------------------------------------------------*/
-/* Private handler : get wep string */
-#define WEP_ASCII_BUFF_SIZE (17 + 64 * 4 + 1)
-static int ks_wlan_get_wep_ascii(struct net_device *dev,
-				 struct iw_request_info *info,
-				 struct iw_point *dwrq, char *extra)
-{
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-	int i, j, len = 0;
-	char tmp[WEP_ASCII_BUFF_SIZE];
-
-	if (priv->sleep_mode == SLP_SLEEP)
-		return -EPERM;
-	/* for SLEEP MODE */
-	strcpy(tmp, " WEP keys ASCII \n");
-	len += strlen(" WEP keys ASCII \n");
-
-	for (i = 0; i < 4; i++) {
-		strcpy(tmp + len, "\t[");
-		len += strlen("\t[");
-		tmp[len] = '1' + i;
-		len++;
-		strcpy(tmp + len, "] ");
-		len += strlen("] ");
-		if (priv->reg.wep_key[i].size) {
-			strcpy(tmp + len,
-			       (priv->reg.wep_key[i].size <
-				6 ? "(40bits) [" : "(104bits) ["));
-			len +=
-			    strlen((priv->reg.wep_key[i].size <
-				    6 ? "(40bits) [" : "(104bits) ["));
-			for (j = 0; j < priv->reg.wep_key[i].size; j++, len++)
-				tmp[len] =
-				    (isprint(priv->reg.wep_key[i].val[j]) ?
-				     priv->reg.wep_key[i].val[j] : ' ');
-
-			strcpy(tmp + len, "]\n");
-			len += strlen("]\n");
-		} else {
-			strcpy(tmp + len, "off\n");
-			len += strlen("off\n");
-		}
-	}
-
-	memcpy(extra, tmp, len);
-	dwrq->length = len + 1;
-	return 0;
-}
-#endif
-
 static int ks_wlan_set_beacon_lost(struct net_device *dev,
 				   struct iw_request_info *info, __u32 *uwrq,
 				   char *extra)
@@ -2573,46 +2360,8 @@ static int ks_wlan_get_sleep_mode(struct net_device *dev,
 
 	return 0;
 }
-
-#if 0
-/*------------------------------------------------------------------*/
-/* Private handler : set phy information timer */
-static int ks_wlan_set_phy_information_timer(struct net_device *dev,
-					     struct iw_request_info *info,
-					     __u32 *uwrq, char *extra)
-{
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-
-	if (priv->sleep_mode == SLP_SLEEP)
-		return -EPERM;
-	/* for SLEEP MODE */
-	if (*uwrq >= 0 && *uwrq <= 0xFFFF)	/* 0-65535 */
-		priv->reg.phy_info_timer = (uint16_t)*uwrq;
-	else
-		return -EINVAL;
-
-	hostif_sme_enqueue(priv, SME_PHY_INFO_REQUEST);
-
-	return 0;
-}
-
-/*------------------------------------------------------------------*/
-/* Private handler : get phy information timer */
-static int ks_wlan_get_phy_information_timer(struct net_device *dev,
-					     struct iw_request_info *info,
-					     __u32 *uwrq, char *extra)
-{
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-
-	if (priv->sleep_mode == SLP_SLEEP)
-		return -EPERM;
-	/* for SLEEP MODE */
-	*uwrq = priv->reg.phy_info_timer;
-	return 0;
-}
-#endif
-
 #ifdef WPS
+
 static int ks_wlan_set_wps_enable(struct net_device *dev,
 				  struct iw_request_info *info, __u32 *uwrq,
 				  char *extra)
@@ -2686,24 +2435,6 @@ static int ks_wlan_set_wps_probe_req(struct net_device *dev,
 
 	return 0;
 }
-
-#if 0
-/*------------------------------------------------------------------*/
-/* Private handler : get WPS probe req */
-static int ks_wlan_get_wps_probe_req(struct net_device *dev,
-				     struct iw_request_info *info,
-				     __u32 *uwrq, char *extra)
-{
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-
-	DPRINTK(2, "\n");
-
-	if (priv->sleep_mode == SLP_SLEEP)
-		return -EPERM;
-	/* for SLEEP MODE */
-	return 0;
-}
-#endif
 #endif /* WPS */
 
 static int ks_wlan_set_tx_gain(struct net_device *dev,
@@ -2784,28 +2515,6 @@ static int ks_wlan_get_rx_gain(struct net_device *dev,
 	return 0;
 }
 
-#if 0
-/*------------------------------------------------------------------*/
-/* Private handler : set region value */
-static int ks_wlan_set_region(struct net_device *dev,
-			      struct iw_request_info *info, __u32 *uwrq,
-			      char *extra)
-{
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-
-	if (priv->sleep_mode == SLP_SLEEP)
-		return -EPERM;
-	/* for SLEEP MODE */
-	if (*uwrq >= 0x9 && *uwrq <= 0xF)	/* 0x9-0xf */
-		priv->region = (uint8_t)*uwrq;
-	else
-		return -EINVAL;
-
-	hostif_sme_enqueue(priv, SME_SET_REGION);
-	return 0;
-}
-#endif
-
 static int ks_wlan_get_eeprom_cksum(struct net_device *dev,
 				    struct iw_request_info *info, __u32 *uwrq,
 				    char *extra)

commit f160bc206489b9b2ee128bc3b39acdec92bc4297
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 15 13:57:31 2017 +1100

    staging: ks7010: remove superfluous comments
    
    Driver uses custom function comment format. These comments are on
    functions with internal likage. Comment string /*--------/* adds
    nothing to the driver. Comment 'Wireless Handler' does not have allot
    of meaning.
    
    Remove superfluous function comments. Leave comments that add meaning.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 76079dc29660..2b13c004bdae 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -173,8 +173,6 @@ int ks_wlan_setup_parameter(struct ks_wlan_private *priv,
  * would not work at all... - Jean II
  */
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get protocol name */
 static int ks_wlan_get_name(struct net_device *dev,
 			    struct iw_request_info *info, char *cwrq,
 			    char *extra)
@@ -198,8 +196,6 @@ static int ks_wlan_get_name(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set frequency */
 static int ks_wlan_set_freq(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_freq *fwrq,
 			    char *extra)
@@ -247,8 +243,6 @@ static int ks_wlan_set_freq(struct net_device *dev,
 	return rc;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get frequency */
 static int ks_wlan_get_freq(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_freq *fwrq,
 			    char *extra)
@@ -271,8 +265,6 @@ static int ks_wlan_get_freq(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set ESSID */
 static int ks_wlan_set_essid(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_point *dwrq, char *extra)
@@ -330,8 +322,6 @@ static int ks_wlan_set_essid(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get ESSID */
 static int ks_wlan_get_essid(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_point *dwrq, char *extra)
@@ -374,8 +364,6 @@ static int ks_wlan_get_essid(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set AP address */
 static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 			   struct sockaddr *ap_addr, char *extra)
 {
@@ -410,8 +398,6 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get AP address */
 static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 			   struct sockaddr *awrq, char *extra)
 {
@@ -432,8 +418,6 @@ static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set Nickname */
 static int ks_wlan_set_nick(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_point *dwrq,
 			    char *extra)
@@ -455,8 +439,6 @@ static int ks_wlan_set_nick(struct net_device *dev,
 	return -EINPROGRESS;	/* Call commit handler */
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get Nickname */
 static int ks_wlan_get_nick(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_point *dwrq,
 			    char *extra)
@@ -475,8 +457,6 @@ static int ks_wlan_get_nick(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set Bit-Rate */
 static int ks_wlan_set_rate(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_param *vwrq,
 			    char *extra)
@@ -710,8 +690,6 @@ static int ks_wlan_set_rate(struct net_device *dev,
 	return -EINPROGRESS;	/* Call commit handler */
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get Bit-Rate */
 static int ks_wlan_get_rate(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_param *vwrq,
 			    char *extra)
@@ -738,8 +716,6 @@ static int ks_wlan_get_rate(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set RTS threshold */
 static int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
 			   struct iw_param *vwrq, char *extra)
 {
@@ -762,8 +738,6 @@ static int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
 	return -EINPROGRESS;	/* Call commit handler */
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get RTS threshold */
 static int ks_wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
 			   struct iw_param *vwrq, char *extra)
 {
@@ -781,8 +755,6 @@ static int ks_wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set Fragmentation threshold */
 static int ks_wlan_set_frag(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_param *vwrq,
 			    char *extra)
@@ -807,8 +779,6 @@ static int ks_wlan_set_frag(struct net_device *dev,
 	return -EINPROGRESS;	/* Call commit handler */
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get Fragmentation threshold */
 static int ks_wlan_get_frag(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_param *vwrq,
 			    char *extra)
@@ -827,8 +797,6 @@ static int ks_wlan_get_frag(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set Mode of Operation */
 static int ks_wlan_set_mode(struct net_device *dev,
 			    struct iw_request_info *info, __u32 *uwrq,
 			    char *extra)
@@ -863,8 +831,6 @@ static int ks_wlan_set_mode(struct net_device *dev,
 	return -EINPROGRESS;	/* Call commit handler */
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get Mode of Operation */
 static int ks_wlan_get_mode(struct net_device *dev,
 			    struct iw_request_info *info, __u32 *uwrq,
 			    char *extra)
@@ -891,8 +857,6 @@ static int ks_wlan_get_mode(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set Encryption Key */
 static int ks_wlan_set_encode(struct net_device *dev,
 			      struct iw_request_info *info,
 			      struct iw_point *dwrq, char *extra)
@@ -1009,8 +973,6 @@ static int ks_wlan_set_encode(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get Encryption Key */
 static int ks_wlan_get_encode(struct net_device *dev,
 			      struct iw_request_info *info,
 			      struct iw_point *dwrq, char *extra)
@@ -1065,8 +1027,6 @@ static int ks_wlan_get_encode(struct net_device *dev,
 }
 
 #ifndef KSC_OPNOTSUPP
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set Tx-Power */
 static int ks_wlan_set_txpow(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_param *vwrq, char *extra)
@@ -1074,8 +1034,6 @@ static int ks_wlan_set_txpow(struct net_device *dev,
 	return -EOPNOTSUPP;	/* Not Support */
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get Tx-Power */
 static int ks_wlan_get_txpow(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_param *vwrq, char *extra)
@@ -1091,8 +1049,6 @@ static int ks_wlan_get_txpow(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set Retry limits */
 static int ks_wlan_set_retry(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_param *vwrq, char *extra)
@@ -1100,8 +1056,6 @@ static int ks_wlan_set_retry(struct net_device *dev,
 	return -EOPNOTSUPP;	/* Not Support */
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get Retry limits */
 static int ks_wlan_get_retry(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_param *vwrq, char *extra)
@@ -1118,8 +1072,6 @@ static int ks_wlan_get_retry(struct net_device *dev,
 }
 #endif /* KSC_OPNOTSUPP */
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get range info */
 static int ks_wlan_get_range(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_point *dwrq, char *extra)
@@ -1253,8 +1205,6 @@ static int ks_wlan_get_range(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set Power Management */
 static int ks_wlan_set_power(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_param *vwrq, char *extra)
@@ -1289,8 +1239,6 @@ static int ks_wlan_set_power(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get Power Management */
 static int ks_wlan_get_power(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_param *vwrq, char *extra)
@@ -1309,8 +1257,6 @@ static int ks_wlan_get_power(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get wirless statistics */
 static int ks_wlan_get_iwstats(struct net_device *dev,
 			       struct iw_request_info *info,
 			       struct iw_quality *vwrq, char *extra)
@@ -1330,8 +1276,7 @@ static int ks_wlan_get_iwstats(struct net_device *dev,
 }
 
 #ifndef KSC_OPNOTSUPP
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set Sensitivity */
+
 static int ks_wlan_set_sens(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_param *vwrq,
 			    char *extra)
@@ -1339,8 +1284,6 @@ static int ks_wlan_set_sens(struct net_device *dev,
 	return -EOPNOTSUPP;	/* Not Support */
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get Sensitivity */
 static int ks_wlan_get_sens(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_param *vwrq,
 			    char *extra)
@@ -1353,8 +1296,6 @@ static int ks_wlan_get_sens(struct net_device *dev,
 }
 #endif /* KSC_OPNOTSUPP */
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get AP List */
 /* Note : this is deprecated in favor of IWSCAN */
 static int ks_wlan_get_aplist(struct net_device *dev,
 			      struct iw_request_info *info,
@@ -1389,8 +1330,6 @@ static int ks_wlan_get_aplist(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : Initiate Scan */
 static int ks_wlan_set_scan(struct net_device *dev,
 			    struct iw_request_info *info,
 			    union iwreq_data *wrqu, char *extra)
@@ -1423,7 +1362,6 @@ static int ks_wlan_set_scan(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
 /*
  * Translate scan data returned from the card to a card independent
  * format that the Wireless Tools will understand - Jean II
@@ -1586,8 +1524,6 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 	return current_ev;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : Read Scan Results */
 static int ks_wlan_get_scan(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_point *dwrq,
 			    char *extra)
@@ -1644,8 +1580,7 @@ static int ks_wlan_get_scan(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Commit handler : called after a bunch of SET operations */
+/* called after a bunch of SET operations */
 static int ks_wlan_config_commit(struct net_device *dev,
 				 struct iw_request_info *info, void *zwrq,
 				 char *extra)
@@ -1661,8 +1596,7 @@ static int ks_wlan_config_commit(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless handler : set association ie params */
+/* set association ie params */
 static int ks_wlan_set_genie(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_point *dwrq, char *extra)
@@ -1679,8 +1613,6 @@ static int ks_wlan_set_genie(struct net_device *dev,
 //      return -EOPNOTSUPP;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless handler : set authentication mode params */
 static int ks_wlan_set_auth_mode(struct net_device *dev,
 				 struct iw_request_info *info,
 				 struct iw_param *vwrq, char *extra)
@@ -1816,8 +1748,6 @@ static int ks_wlan_set_auth_mode(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless handler : get authentication mode params */
 static int ks_wlan_get_auth_mode(struct net_device *dev,
 				 struct iw_request_info *info,
 				 struct iw_param *vwrq, char *extra)
@@ -1862,8 +1792,7 @@ static int ks_wlan_get_auth_mode(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set encoding token & mode (WPA)*/
+/* set encoding token & mode (WPA)*/
 static int ks_wlan_set_encode_ext(struct net_device *dev,
 				  struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
@@ -1968,8 +1897,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : get encoding token & mode (WPA)*/
+/* get encoding token & mode (WPA)*/
 static int ks_wlan_get_encode_ext(struct net_device *dev,
 				  struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
@@ -1991,8 +1919,6 @@ static int ks_wlan_get_encode_ext(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : PMKSA cache operation (WPA2) */
 static int ks_wlan_set_pmksa(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_point *dwrq, char *extra)
@@ -2122,8 +2048,6 @@ static struct iw_statistics *ks_get_wireless_stats(struct net_device *dev)
 	return wstats;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : set stop request */
 static int ks_wlan_set_stop_request(struct net_device *dev,
 				    struct iw_request_info *info, __u32 *uwrq,
 				    char *extra)
@@ -2143,8 +2067,6 @@ static int ks_wlan_set_stop_request(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Wireless Handler : set MLME */
 #include <linux/ieee80211.h>
 static int ks_wlan_set_mlme(struct net_device *dev,
 			    struct iw_request_info *info, struct iw_point *dwrq,
@@ -2173,8 +2095,6 @@ static int ks_wlan_set_mlme(struct net_device *dev,
 	}
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get firemware version */
 static int ks_wlan_get_firmware_version(struct net_device *dev,
 					struct iw_request_info *info,
 					struct iw_point *dwrq, char *extra)
@@ -2246,8 +2166,6 @@ static int ks_wlan_get_connect(struct net_device *dev,
 }
 #endif
 
-/*------------------------------------------------------------------*/
-/* Private handler : set preamble */
 static int ks_wlan_set_preamble(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
@@ -2271,8 +2189,6 @@ static int ks_wlan_set_preamble(struct net_device *dev,
 	return -EINPROGRESS;	/* Call commit handler */
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get preamble */
 static int ks_wlan_get_preamble(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
@@ -2288,8 +2204,6 @@ static int ks_wlan_get_preamble(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : set power save mode */
 static int ks_wlan_set_powermgt(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
@@ -2322,8 +2236,6 @@ static int ks_wlan_set_powermgt(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get power save made */
 static int ks_wlan_get_powermgt(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
@@ -2339,8 +2251,6 @@ static int ks_wlan_get_powermgt(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : set scan type */
 static int ks_wlan_set_scan_type(struct net_device *dev,
 				 struct iw_request_info *info, __u32 *uwrq,
 				 char *extra)
@@ -2362,8 +2272,6 @@ static int ks_wlan_set_scan_type(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get scan type */
 static int ks_wlan_get_scan_type(struct net_device *dev,
 				 struct iw_request_info *info, __u32 *uwrq,
 				 char *extra)
@@ -2509,8 +2417,6 @@ static int ks_wlan_get_wep_ascii(struct net_device *dev,
 }
 #endif
 
-/*------------------------------------------------------------------*/
-/* Private handler : set beacon lost count */
 static int ks_wlan_set_beacon_lost(struct net_device *dev,
 				   struct iw_request_info *info, __u32 *uwrq,
 				   char *extra)
@@ -2534,8 +2440,6 @@ static int ks_wlan_set_beacon_lost(struct net_device *dev,
 	}
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get beacon lost count */
 static int ks_wlan_get_beacon_lost(struct net_device *dev,
 				   struct iw_request_info *info, __u32 *uwrq,
 				   char *extra)
@@ -2550,8 +2454,6 @@ static int ks_wlan_get_beacon_lost(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : set phy type */
 static int ks_wlan_set_phy_type(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
@@ -2576,8 +2478,6 @@ static int ks_wlan_set_phy_type(struct net_device *dev,
 	return -EINPROGRESS;	/* Call commit handler */
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get phy type */
 static int ks_wlan_get_phy_type(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
@@ -2592,8 +2492,6 @@ static int ks_wlan_get_phy_type(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : set cts mode */
 static int ks_wlan_set_cts_mode(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
@@ -2621,8 +2519,6 @@ static int ks_wlan_set_cts_mode(struct net_device *dev,
 	return -EINPROGRESS;	/* Call commit handler */
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get cts mode */
 static int ks_wlan_get_cts_mode(struct net_device *dev,
 				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
@@ -2637,8 +2533,6 @@ static int ks_wlan_get_cts_mode(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : set sleep mode */
 static int ks_wlan_set_sleep_mode(struct net_device *dev,
 				  struct iw_request_info *info,
 				  __u32 *uwrq, char *extra)
@@ -2667,8 +2561,6 @@ static int ks_wlan_set_sleep_mode(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get sleep mode */
 static int ks_wlan_get_sleep_mode(struct net_device *dev,
 				  struct iw_request_info *info,
 				  __u32 *uwrq, char *extra)
@@ -2721,8 +2613,6 @@ static int ks_wlan_get_phy_information_timer(struct net_device *dev,
 #endif
 
 #ifdef WPS
-/*------------------------------------------------------------------*/
-/* Private handler : set WPS enable */
 static int ks_wlan_set_wps_enable(struct net_device *dev,
 				  struct iw_request_info *info, __u32 *uwrq,
 				  char *extra)
@@ -2744,8 +2634,6 @@ static int ks_wlan_set_wps_enable(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get WPS enable */
 static int ks_wlan_get_wps_enable(struct net_device *dev,
 				  struct iw_request_info *info, __u32 *uwrq,
 				  char *extra)
@@ -2763,8 +2651,6 @@ static int ks_wlan_get_wps_enable(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : set WPS probe req */
 static int ks_wlan_set_wps_probe_req(struct net_device *dev,
 				     struct iw_request_info *info,
 				     struct iw_point *dwrq, char *extra)
@@ -2820,8 +2706,6 @@ static int ks_wlan_get_wps_probe_req(struct net_device *dev,
 #endif
 #endif /* WPS */
 
-/*------------------------------------------------------------------*/
-/* Private handler : set tx gain control value */
 static int ks_wlan_set_tx_gain(struct net_device *dev,
 			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
@@ -2846,8 +2730,6 @@ static int ks_wlan_set_tx_gain(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get tx gain control value */
 static int ks_wlan_get_tx_gain(struct net_device *dev,
 			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
@@ -2863,8 +2745,6 @@ static int ks_wlan_get_tx_gain(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : set rx gain control value */
 static int ks_wlan_set_rx_gain(struct net_device *dev,
 			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
@@ -2889,8 +2769,6 @@ static int ks_wlan_set_rx_gain(struct net_device *dev,
 	return 0;
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get rx gain control value */
 static int ks_wlan_get_rx_gain(struct net_device *dev,
 			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
@@ -2928,8 +2806,6 @@ static int ks_wlan_set_region(struct net_device *dev,
 }
 #endif
 
-/*------------------------------------------------------------------*/
-/* Private handler : get eeprom checksum result */
 static int ks_wlan_get_eeprom_cksum(struct net_device *dev,
 				    struct iw_request_info *info, __u32 *uwrq,
 				    char *extra)
@@ -3054,8 +2930,7 @@ static void print_hif_event(struct net_device *dev, int event)
 	}
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get host command history */
+/* get host command history */
 static int ks_wlan_hostt(struct net_device *dev, struct iw_request_info *info,
 			 __u32 *uwrq, char *extra)
 {

commit aa6ca807baace49992ad6990c9aeda22289be5cd
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 21:20:12 2017 +1100

    staging: ks7010: remove custom return values
    
    Driver code uses custom return values (often positive) to signal error
    condition instead of using standard kernel error codes.
    
    Replace custom return values with standard kernel error codes.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 651d4799733b..76079dc29660 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -89,10 +89,10 @@ int ks_wlan_update_phy_information(struct ks_wlan_private *priv)
 	DPRINTK(4, "in_interrupt = %ld\n", in_interrupt());
 
 	if (priv->dev_state < DEVICE_STATE_READY)
-		return -1;	/* not finished initialize */
+		return -EBUSY;	/* not finished initialize */
 
 	if (atomic_read(&update_phyinfo))
-		return 1;
+		return -EPERM;
 
 	/* The status */
 	wstats->status = priv->reg.operation_mode;	/* Operation mode */

commit 7bb6313d011f16405b338a228f540d3ab5aee58a
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Mar 15 12:01:07 2017 +1100

    staging: ks7010: fix off by one error
    
    Bug introduced in commit 7676b72 by Tobin C. Harding.
    
    Remove equals sign from comparison, fixing off by one error.
    
    Fixes: 7676b72428e8 ("staging: ks7010: move comparison to right hand side")
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 0852a1d97595..651d4799733b 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2044,7 +2044,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 		if (ptr != &priv->pmklist.head)	/* not find address. */
 			break;	/* case */
 
-		if (priv->pmklist.size <= PMK_LIST_MAX) {	/* new cache data */
+		if (priv->pmklist.size < PMK_LIST_MAX) {	/* new cache data */
 			for (i = 0; i < PMK_LIST_MAX; i++) {
 				pmk = &priv->pmklist.pmk[i];
 				if (!memcmp("\x00\x00\x00\x00\x00\x00",

commit 902f49ca3cbd20d4a4c8fd8b7cc6178a731cdc3f
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 09:54:10 2017 +1100

    staging: ks7010: refactor, whitespace only
    
    Code may be refactored to take advantage of previous patches which
    reduced the level of indentation. Function parameter line breaks can
    be adjusted in line with kernel coding standards.
    
    Refactor layout of function call parameters. Make whitespace changes
    only.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index f771b39c1396..0852a1d97595 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2036,10 +2036,8 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 		list_for_each(ptr, &priv->pmklist.head) {
 			pmk = list_entry(ptr, struct pmk_t, list);
 			if (!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)) {	/* match address! list move to head. */
-				memcpy(pmk->pmkid, pmksa->pmkid,
-					IW_PMKID_LEN);
-				list_move(&pmk->list,
-					&priv->pmklist.head);
+				memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
+				list_move(&pmk->list, &priv->pmklist.head);
 				break; /* list_for_each */
 			}
 		}
@@ -2049,28 +2047,20 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 		if (priv->pmklist.size <= PMK_LIST_MAX) {	/* new cache data */
 			for (i = 0; i < PMK_LIST_MAX; i++) {
 				pmk = &priv->pmklist.pmk[i];
-				if (!memcmp
-					("\x00\x00\x00\x00\x00\x00",
-						pmk->bssid, ETH_ALEN))
-					break;
+				if (!memcmp("\x00\x00\x00\x00\x00\x00",
+					    pmk->bssid, ETH_ALEN))
+					break; /* loop */
 			}
-			memcpy(pmk->bssid, pmksa->bssid.sa_data,
-				ETH_ALEN);
-			memcpy(pmk->pmkid, pmksa->pmkid,
-				IW_PMKID_LEN);
-			list_add(&pmk->list,
-				&priv->pmklist.head);
+			memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
+			memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
+			list_add(&pmk->list, &priv->pmklist.head);
 			priv->pmklist.size++;
 		} else {	/* overwrite old cache data */
-			pmk =
-				list_entry(priv->pmklist.head.prev,
-					struct pmk_t, list);
-			memcpy(pmk->bssid, pmksa->bssid.sa_data,
-				ETH_ALEN);
-			memcpy(pmk->pmkid, pmksa->pmkid,
-				IW_PMKID_LEN);
-			list_move(&pmk->list,
-				&priv->pmklist.head);
+			pmk = list_entry(priv->pmklist.head.prev, struct pmk_t,
+					 list);
+			memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
+			memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
+			list_move(&pmk->list, &priv->pmklist.head);
 		}
 		break;
 	case IW_PMKSA_REMOVE:

commit f0a4c596f2f8106d1060bf0cc6ed1e3c2ed3b16d
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 09:54:09 2017 +1100

    staging: ks7010: reduce level of indentation
    
    Checkpatch emits WARNING: Too many leading tabs - consider code
    refactoring. One level of indentation may be removed by inverting an
    if statement conditional (and returning if new conditional evaluates
    to true). Code contains switch statement that also contains multiple
    layers of indentation. Indentation may be reduced by breaking out of
    the case statement in multiple places instead of guarding code with
    if/else statements.
    
    Invert conditional. Return original error code if new conditional
    evaluates to true. Break out of case blocks instead of using
    if/else. Do not modify program logic.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index d07b724a3442..f771b39c1396 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1890,72 +1890,71 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	if (dwrq->flags & IW_ENCODE_DISABLED)
 		priv->wpa.key[index].key_len = 0;
 
-	if (enc) {
-		priv->wpa.key[index].ext_flags = enc->ext_flags;
-		if (enc->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
-			priv->wpa.txkey = index;
-			commit |= SME_WEP_INDEX;
-		} else if (enc->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
-			memcpy(&priv->wpa.key[index].rx_seq[0],
-			       enc->rx_seq, IW_ENCODE_SEQ_MAX_SIZE);
-		}
+	if (!enc)
+		return -EINVAL;
 
-		memcpy(&priv->wpa.key[index].addr.sa_data[0],
-		       &enc->addr.sa_data[0], ETH_ALEN);
+	priv->wpa.key[index].ext_flags = enc->ext_flags;
+	if (enc->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+		priv->wpa.txkey = index;
+		commit |= SME_WEP_INDEX;
+	} else if (enc->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
+		memcpy(&priv->wpa.key[index].rx_seq[0],
+			enc->rx_seq, IW_ENCODE_SEQ_MAX_SIZE);
+	}
 
-		switch (enc->alg) {
-		case IW_ENCODE_ALG_NONE:
-			if (priv->reg.privacy_invoked) {
-				priv->reg.privacy_invoked = 0x00;
-				commit |= SME_WEP_FLAG;
-			}
-			priv->wpa.key[index].key_len = 0;
+	memcpy(&priv->wpa.key[index].addr.sa_data[0],
+		&enc->addr.sa_data[0], ETH_ALEN);
 
-			break;
-		case IW_ENCODE_ALG_WEP:
-		case IW_ENCODE_ALG_CCMP:
-			if (!priv->reg.privacy_invoked) {
-				priv->reg.privacy_invoked = 0x01;
-				commit |= SME_WEP_FLAG;
-			}
-			if (enc->key_len) {
-				memcpy(&priv->wpa.key[index].key_val[0],
-				       &enc->key[0], enc->key_len);
-				priv->wpa.key[index].key_len = enc->key_len;
-				commit |= (SME_WEP_VAL1 << index);
-			}
-			break;
-		case IW_ENCODE_ALG_TKIP:
-			if (!priv->reg.privacy_invoked) {
-				priv->reg.privacy_invoked = 0x01;
-				commit |= SME_WEP_FLAG;
-			}
-			if (enc->key_len == 32) {
-				memcpy(&priv->wpa.key[index].key_val[0],
-				       &enc->key[0], enc->key_len - 16);
-				priv->wpa.key[index].key_len =
-				    enc->key_len - 16;
-				if (priv->wpa.key_mgmt_suite == 4) {	/* WPA_NONE */
-					memcpy(&priv->wpa.key[index].
-					       tx_mic_key[0], &enc->key[16], 8);
-					memcpy(&priv->wpa.key[index].
-					       rx_mic_key[0], &enc->key[16], 8);
-				} else {
-					memcpy(&priv->wpa.key[index].
-					       tx_mic_key[0], &enc->key[16], 8);
-					memcpy(&priv->wpa.key[index].
-					       rx_mic_key[0], &enc->key[24], 8);
-				}
-				commit |= (SME_WEP_VAL1 << index);
+	switch (enc->alg) {
+	case IW_ENCODE_ALG_NONE:
+		if (priv->reg.privacy_invoked) {
+			priv->reg.privacy_invoked = 0x00;
+			commit |= SME_WEP_FLAG;
+		}
+		priv->wpa.key[index].key_len = 0;
+
+		break;
+	case IW_ENCODE_ALG_WEP:
+	case IW_ENCODE_ALG_CCMP:
+		if (!priv->reg.privacy_invoked) {
+			priv->reg.privacy_invoked = 0x01;
+			commit |= SME_WEP_FLAG;
+		}
+		if (enc->key_len) {
+			memcpy(&priv->wpa.key[index].key_val[0],
+				&enc->key[0], enc->key_len);
+			priv->wpa.key[index].key_len = enc->key_len;
+			commit |= (SME_WEP_VAL1 << index);
+		}
+		break;
+	case IW_ENCODE_ALG_TKIP:
+		if (!priv->reg.privacy_invoked) {
+			priv->reg.privacy_invoked = 0x01;
+			commit |= SME_WEP_FLAG;
+		}
+		if (enc->key_len == 32) {
+			memcpy(&priv->wpa.key[index].key_val[0],
+				&enc->key[0], enc->key_len - 16);
+			priv->wpa.key[index].key_len =
+				enc->key_len - 16;
+			if (priv->wpa.key_mgmt_suite == 4) {	/* WPA_NONE */
+				memcpy(&priv->wpa.key[index].
+					tx_mic_key[0], &enc->key[16], 8);
+				memcpy(&priv->wpa.key[index].
+					rx_mic_key[0], &enc->key[16], 8);
+			} else {
+				memcpy(&priv->wpa.key[index].
+					tx_mic_key[0], &enc->key[16], 8);
+				memcpy(&priv->wpa.key[index].
+					rx_mic_key[0], &enc->key[24], 8);
 			}
-			break;
-		default:
-			return -EINVAL;
+			commit |= (SME_WEP_VAL1 << index);
 		}
-		priv->wpa.key[index].alg = enc->alg;
-	} else {
+		break;
+	default:
 		return -EINVAL;
 	}
+	priv->wpa.key[index].alg = enc->alg;
 
 	if (commit) {
 		if (commit & SME_WEP_INDEX)
@@ -2025,51 +2024,53 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 				if (!memcmp
 				    ("\x00\x00\x00\x00\x00\x00", pmk->bssid,
 				     ETH_ALEN))
-					break;
+					break; /* loop */
 			}
 			memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
 			memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
 			list_add(&pmk->list, &priv->pmklist.head);
 			priv->pmklist.size++;
-		} else {	/* search cache data */
-			list_for_each(ptr, &priv->pmklist.head) {
-				pmk = list_entry(ptr, struct pmk_t, list);
-				if (!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)) {	/* match address! list move to head. */
-					memcpy(pmk->pmkid, pmksa->pmkid,
-					       IW_PMKID_LEN);
-					list_move(&pmk->list,
-						  &priv->pmklist.head);
-					break;
-				}
+			break;	/* case */
+		}
+		/* search cache data */
+		list_for_each(ptr, &priv->pmklist.head) {
+			pmk = list_entry(ptr, struct pmk_t, list);
+			if (!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)) {	/* match address! list move to head. */
+				memcpy(pmk->pmkid, pmksa->pmkid,
+					IW_PMKID_LEN);
+				list_move(&pmk->list,
+					&priv->pmklist.head);
+				break; /* list_for_each */
 			}
-			if (ptr == &priv->pmklist.head) {	/* not find address. */
-				if (priv->pmklist.size <= PMK_LIST_MAX) {	/* new cache data */
-					for (i = 0; i < PMK_LIST_MAX; i++) {
-						pmk = &priv->pmklist.pmk[i];
-						if (!memcmp
-						    ("\x00\x00\x00\x00\x00\x00",
-						     pmk->bssid, ETH_ALEN))
-							break;
-					}
-					memcpy(pmk->bssid, pmksa->bssid.sa_data,
-					       ETH_ALEN);
-					memcpy(pmk->pmkid, pmksa->pmkid,
-					       IW_PMKID_LEN);
-					list_add(&pmk->list,
-						 &priv->pmklist.head);
-					priv->pmklist.size++;
-				} else {	/* overwrite old cache data */
-					pmk =
-					    list_entry(priv->pmklist.head.prev,
-						       struct pmk_t, list);
-					memcpy(pmk->bssid, pmksa->bssid.sa_data,
-					       ETH_ALEN);
-					memcpy(pmk->pmkid, pmksa->pmkid,
-					       IW_PMKID_LEN);
-					list_move(&pmk->list,
-						  &priv->pmklist.head);
-				}
+		}
+		if (ptr != &priv->pmklist.head)	/* not find address. */
+			break;	/* case */
+
+		if (priv->pmklist.size <= PMK_LIST_MAX) {	/* new cache data */
+			for (i = 0; i < PMK_LIST_MAX; i++) {
+				pmk = &priv->pmklist.pmk[i];
+				if (!memcmp
+					("\x00\x00\x00\x00\x00\x00",
+						pmk->bssid, ETH_ALEN))
+					break;
 			}
+			memcpy(pmk->bssid, pmksa->bssid.sa_data,
+				ETH_ALEN);
+			memcpy(pmk->pmkid, pmksa->pmkid,
+				IW_PMKID_LEN);
+			list_add(&pmk->list,
+				&priv->pmklist.head);
+			priv->pmklist.size++;
+		} else {	/* overwrite old cache data */
+			pmk =
+				list_entry(priv->pmklist.head.prev,
+					struct pmk_t, list);
+			memcpy(pmk->bssid, pmksa->bssid.sa_data,
+				ETH_ALEN);
+			memcpy(pmk->pmkid, pmksa->pmkid,
+				IW_PMKID_LEN);
+			list_move(&pmk->list,
+				&priv->pmklist.head);
 		}
 		break;
 	case IW_PMKSA_REMOVE:

commit f0b7d3a67bce75bc1e5910e30c3890ae01e3be04
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 09:54:08 2017 +1100

    staging: ks7010: fix checkpatch memset warning
    
    Checkpatch emits WARNING: single byte memset is suspicious. Swapped
    2nd/3rd argument? Call site in question is correct but is an unusual
    use of memset() to zero a single byte. The same can be achieved by
    assigning 0 directly to the memory location.
    
    Dereference pointer and assign 0 to that memory location. Use '\0' to
    make explicit that it is a char pointer.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 9fa1ee7255ca..d07b724a3442 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2431,7 +2431,7 @@ static int ks_wlan_data_read(struct net_device *dev,
 			return 0;
 		}
 		read_length = 0;
-		memset(extra, 0, 1);
+		*extra = '\0';
 		dwrq->length = 0;
 		return 0;
 	}

commit ad1e187f41a6dc008e5057805dc713551108799a
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 09:54:07 2017 +1100

    staging: ks7010: remove unnecessary cast
    
    Return value from kmalloc() does not require a cast.
    
    Remove unnecessary cast.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index d55b5e30c038..9fa1ee7255ca 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2400,7 +2400,7 @@ static int ks_wlan_data_write(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 	/* for SLEEP MODE */
-	wbuff = (unsigned char *)kmalloc(dwrq->length, GFP_ATOMIC);
+	wbuff = kmalloc(dwrq->length, GFP_ATOMIC);
 	if (!wbuff)
 		return -EFAULT;
 	memcpy(wbuff, extra, dwrq->length);

commit 44dc9c86f9ed0e49b864e8337f98bbb1c09e0570
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 09:54:06 2017 +1100

    staging: ks7010: remove unnecessary else statement
    
    Checkpatch emits WARNING: else is not generally useful after a break
    or return. Two warnings of this type are emitted, both are the result
    of a else statement after a return statement. The 'else' can safely be
    removed.
    
    Remove unnecessary else statement.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 78204401220d..d55b5e30c038 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1885,8 +1885,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	/* for SLEEP MODE */
 	if (index < 1 || index > 4)
 		return -EINVAL;
-	else
-		index--;
+	index--;
 
 	if (dwrq->flags & IW_ENCODE_DISABLED)
 		priv->wpa.key[index].key_len = 0;
@@ -2076,20 +2075,21 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 	case IW_PMKSA_REMOVE:
 		if (list_empty(&priv->pmklist.head)) {	/* list empty */
 			return -EINVAL;
-		} else {	/* search cache data */
-			list_for_each(ptr, &priv->pmklist.head) {
-				pmk = list_entry(ptr, struct pmk_t, list);
-				if (!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)) {	/* match address! list del. */
-					eth_zero_addr(pmk->bssid);
-					memset(pmk->pmkid, 0, IW_PMKID_LEN);
-					list_del_init(&pmk->list);
-					break;
-				}
-			}
-			if (ptr == &priv->pmklist.head) {	/* not find address. */
-				return 0;
+		}
+		/* search cache data */
+		list_for_each(ptr, &priv->pmklist.head) {
+			pmk = list_entry(ptr, struct pmk_t, list);
+			if (!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)) {	/* match address! list del. */
+				eth_zero_addr(pmk->bssid);
+				memset(pmk->pmkid, 0, IW_PMKID_LEN);
+				list_del_init(&pmk->list);
+				break;
 			}
 		}
+		if (ptr == &priv->pmklist.head) {	/* not find address. */
+			return 0;
+		}
+
 		break;
 	case IW_PMKSA_FLUSH:
 		memset(&priv->pmklist, 0, sizeof(priv->pmklist));

commit 7676b72428e84f344bd64fecc1d4c840e57a68d8
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 09:54:05 2017 +1100

    staging: ks7010: move comparison to right hand side
    
    Checkpatch emits WARNING: Comparisons should place the constant on the
    right side of the test.
    
    Move constant to right hand side of test, modify operator to ensure
    logic is maintained.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 648170dc53d5..78204401220d 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2044,7 +2044,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 				}
 			}
 			if (ptr == &priv->pmklist.head) {	/* not find address. */
-				if (PMK_LIST_MAX > priv->pmklist.size) {	/* new cache data */
+				if (priv->pmklist.size <= PMK_LIST_MAX) {	/* new cache data */
 					for (i = 0; i < PMK_LIST_MAX; i++) {
 						pmk = &priv->pmklist.pmk[i];
 						if (!memcmp

commit e00b9bb34e2784f41bdfc7083c7d37ca1b97aca3
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 09:54:04 2017 +1100

    staging: ks7010: remove multiple assignment
    
    Checkpatch emits CHECK: multiple assignments should be avoided.
    
    Move multiple assignment onto separate lines. Fix comment to use more
    natural English.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 5d206832e5e0..648170dc53d5 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1511,8 +1511,10 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 	current_val = current_ev + IW_EV_LCP_LEN;
 
 	iwe.cmd = SIOCGIWRATE;
-	/* Those two flags are ignored... */
-	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+
+	/* These two flags are ignored... */
+	iwe.u.bitrate.fixed = 0;
+	iwe.u.bitrate.disabled = 0;
 
 	/* Max 16 values */
 	for (i = 0; i < 16; i++) {

commit b5492d65eab0b56766a72a501469415a09a83e96
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 09:54:03 2017 +1100

    staging: ks7010: remove dead code
    
    Checkpatch emits CHECK: Alignment should match open parenthesis. This
    is due to commented out code.
    
    Remove commented out (dead) code.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index d843793d8504..5d206832e5e0 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1620,7 +1620,6 @@ static int ks_wlan_get_scan(struct net_device *dev,
 			return -E2BIG;
 		}
 		current_ev = ks_wlan_translate_scan(dev, current_ev,
-//                                                  extra + IW_SCAN_MAX_DATA,
 						    extra + dwrq->length,
 						    &priv->current_ap);
 	}
@@ -1633,7 +1632,6 @@ static int ks_wlan_get_scan(struct net_device *dev,
 		}
 		/* Translate to WE format this entry */
 		current_ev = ks_wlan_translate_scan(dev, info, current_ev,
-//                                                  extra + IW_SCAN_MAX_DATA,
 						    extra + dwrq->length,
 						    &priv->aplist.ap[i]);
 	}

commit a359491ad28183756ad883cf49e2bb3a0235145d
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 09:54:02 2017 +1100

    staging: ks7010: fix logical line continuation
    
    Checkpatch emits CHECK: Logical continuations should be on the
    previous line.
    
    Move logical continuation to previous line.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 1ff19480ae51..d843793d8504 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1406,8 +1406,8 @@ static int ks_wlan_set_scan(struct net_device *dev,
 
 	/* for SLEEP MODE */
 	/* specified SSID SCAN */
-	if (wrqu->data.length == sizeof(struct iw_scan_req)
-	    && wrqu->data.flags & IW_SCAN_THIS_ESSID) {
+	if (wrqu->data.length == sizeof(struct iw_scan_req) &&
+	    wrqu->data.flags & IW_SCAN_THIS_ESSID) {
 		req = (struct iw_scan_req *)extra;
 		priv->scan_ssid_len = req->essid_len;
 		memcpy(priv->scan_ssid, req->essid, priv->scan_ssid_len);

commit 64068bc31547946f635aed3beadb67031a473157
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 09:54:00 2017 +1100

    staging: ks7010: fix checkpatch BLOCK_COMMENT_STYLE
    
    Checkpatch emits block comments warnings.
    
    Change comments blocks to be inline with kernel coding style for
    networking code.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 75e42a7f0ca9..1ff19480ae51 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -230,7 +230,8 @@ static int ks_wlan_set_freq(struct net_device *dev,
 	} else {
 		int channel = fwrq->m;
 		/* We should do a better check than that,
-		 * based on the card capability !!! */
+		 * based on the card capability !!!
+		 */
 		if ((channel < 1) || (channel > 14)) {
 			netdev_dbg(dev,
 				   "%s: New channel value of %d is invalid!\n",
@@ -343,7 +344,8 @@ static int ks_wlan_get_essid(struct net_device *dev,
 
 	/* for SLEEP MODE */
 	/* Note : if dwrq->flags != 0, we should
-	 * get the relevant SSID from the SSID list... */
+	 * get the relevant SSID from the SSID list...
+	 */
 	if (priv->reg.ssid.size) {
 		/* Get the current SSID */
 		memcpy(extra, priv->reg.ssid.body, priv->reg.ssid.size);
@@ -1139,7 +1141,8 @@ static int ks_wlan_get_range(struct net_device *dev,
 	range->max_nwid = 0x0000;
 	range->num_channels = 14;
 	/* Should be based on cap_rid.country to give only
-	 * what the current card support */
+	 * what the current card support
+	 */
 	k = 0;
 	for (i = 0; i < 13; i++) {	/* channel 1 -- 13 */
 		range->freq[k].i = i + 1;	/* List index */
@@ -1191,7 +1194,8 @@ static int ks_wlan_get_range(struct net_device *dev,
 
 	/* Set an indication of the max TCP throughput
 	 * in bit/s that we can expect using this interface.
-	 * May be use for QoS stuff... Jean II */
+	 * May be use for QoS stuff... Jean II
+	 */
 	if (i > 2)
 		range->throughput = 5000 * 1000;
 	else
@@ -1225,9 +1229,11 @@ static int ks_wlan_get_range(struct net_device *dev,
 	range->retry_flags = IW_RETRY_ON;
 	range->r_time_flags = IW_RETRY_ON;
 
-	/* Experimental measurements - boundary 11/5.5 Mb/s */
-	/* Note : with or without the (local->rssi), results
-	 * are somewhat different. - Jean II */
+	/* Experimental measurements - boundary 11/5.5 Mb/s
+	 *
+	 * Note : with or without the (local->rssi), results
+	 * are somewhat different. - Jean II
+	 */
 	range->avg_qual.qual = 50;
 	range->avg_qual.level = 186;	/* -70 dBm */
 	range->avg_qual.noise = 0;
@@ -1500,7 +1506,8 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 				 ap->ssid.body);
 
 	/* Rate : stuffing multiple values in a single event require a bit
-	 * more of magic - Jean II */
+	 * more of magic - Jean II
+	 */
 	current_val = current_ev + IW_EV_LCP_LEN;
 
 	iwe.cmd = SIOCGIWRATE;
@@ -1572,7 +1579,8 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 	}
 
 	/* The other data in the scan result are not really
-	 * interesting, so for now drop it - Jean II */
+	 * interesting, so for now drop it - Jean II
+	 */
 	return current_ev;
 }
 
@@ -1599,7 +1607,8 @@ static int ks_wlan_get_scan(struct net_device *dev,
 
 	if (priv->aplist.size == 0) {
 		/* Client error, no scan results...
-		 * The caller need to restart the scan. */
+		 * The caller need to restart the scan.
+		 */
 		DPRINTK(2, "aplist 0\n");
 		return -ENODATA;
 	}
@@ -1974,12 +1983,13 @@ static int ks_wlan_get_encode_ext(struct net_device *dev,
 		return -EPERM;
 
 	/* for SLEEP MODE */
-	/*  WPA (not used ?? wpa_supplicant)
-	   struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-	   struct iw_encode_ext *enc;
-	   enc = (struct iw_encode_ext *)extra;
-	   int index = dwrq->flags & IW_ENCODE_INDEX;
-	   WPA (not used ?? wpa_supplicant) */
+	/* WPA (not used ?? wpa_supplicant)
+	 * struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
+	 * struct iw_encode_ext *enc;
+	 * enc = (struct iw_encode_ext *)extra;
+	 * int index = dwrq->flags & IW_ENCODE_INDEX;
+	 * WPA (not used ?? wpa_supplicant)
+	 */
 	return 0;
 }
 
@@ -2109,7 +2119,8 @@ static struct iw_statistics *ks_get_wireless_stats(struct net_device *dev)
 	}
 
 	/* Packets discarded in the wireless adapter due to wireless
-	 * specific problems */
+	 * specific problems
+	 */
 	wstats->discard.nwid = 0;	/* Rx invalid nwid      */
 	wstats->discard.code = 0;	/* Rx invalid crypt     */
 	wstats->discard.fragment = 0;	/* Rx invalid frag      */
@@ -3362,8 +3373,10 @@ void send_packet_complete(void *arg1, void *arg2)
 	}
 }
 
-/* Set or clear the multicast filter for this adaptor.
-   This routine is not state sensitive and need not be SMP locked. */
+/*
+ * Set or clear the multicast filter for this adaptor.
+ * This routine is not state sensitive and need not be SMP locked.
+ */
 static
 void ks_wlan_set_multicast_list(struct net_device *dev)
 {

commit 03d55ab9f486ae46755a649e33949faac84beaf7
Author: Tobin C. Harding <me@tobin.cc>
Date:   Tue Mar 14 09:53:59 2017 +1100

    staging: ks7010: fix checkpatch SPACING
    
    Checkpatch emits over 100 instances of CHECK: No space is necessary
    after a cast.
    
    Remove unnecessary space.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 2b4d6c1cb037..75e42a7f0ca9 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -238,7 +238,7 @@ static int ks_wlan_set_freq(struct net_device *dev,
 			rc = -EINVAL;
 		} else {
 			/* Yes ! We can set it !!! */
-			priv->reg.channel = (u8) (channel);
+			priv->reg.channel = (u8)(channel);
 			priv->need_commit |= SME_MODE_SET;
 		}
 	}
@@ -493,12 +493,12 @@ static int ks_wlan_set_rate(struct net_device *dev,
 			case 11000000:
 			case 5500000:
 				priv->reg.rate_set.body[0] =
-				    (uint8_t) (vwrq->value / 500000);
+				    (uint8_t)(vwrq->value / 500000);
 				break;
 			case 2000000:
 			case 1000000:
 				priv->reg.rate_set.body[0] =
-				    ((uint8_t) (vwrq->value / 500000)) |
+				    ((uint8_t)(vwrq->value / 500000)) |
 				    BASIC_RATE;
 				break;
 			default:
@@ -550,7 +550,7 @@ static int ks_wlan_set_rate(struct net_device *dev,
 			case 18000000:
 			case 9000000:
 				priv->reg.rate_set.body[0] =
-				    (uint8_t) (vwrq->value / 500000);
+				    (uint8_t)(vwrq->value / 500000);
 				break;
 			case 24000000:
 			case 12000000:
@@ -560,7 +560,7 @@ static int ks_wlan_set_rate(struct net_device *dev,
 			case 2000000:
 			case 1000000:
 				priv->reg.rate_set.body[0] =
-				    ((uint8_t) (vwrq->value / 500000)) |
+				    ((uint8_t)(vwrq->value / 500000)) |
 				    BASIC_RATE;
 				break;
 			default:
@@ -3127,119 +3127,119 @@ static const struct iw_priv_args ks_wlan_private_args[] = {
 };
 
 static const iw_handler ks_wlan_handler[] = {
-	(iw_handler) ks_wlan_config_commit,	/* SIOCSIWCOMMIT */
-	(iw_handler) ks_wlan_get_name,	/* SIOCGIWNAME */
-	(iw_handler) NULL,	/* SIOCSIWNWID */
-	(iw_handler) NULL,	/* SIOCGIWNWID */
-	(iw_handler) ks_wlan_set_freq,	/* SIOCSIWFREQ */
-	(iw_handler) ks_wlan_get_freq,	/* SIOCGIWFREQ */
-	(iw_handler) ks_wlan_set_mode,	/* SIOCSIWMODE */
-	(iw_handler) ks_wlan_get_mode,	/* SIOCGIWMODE */
+	(iw_handler)ks_wlan_config_commit,	/* SIOCSIWCOMMIT */
+	(iw_handler)ks_wlan_get_name,	/* SIOCGIWNAME */
+	(iw_handler)NULL,	/* SIOCSIWNWID */
+	(iw_handler)NULL,	/* SIOCGIWNWID */
+	(iw_handler)ks_wlan_set_freq,	/* SIOCSIWFREQ */
+	(iw_handler)ks_wlan_get_freq,	/* SIOCGIWFREQ */
+	(iw_handler)ks_wlan_set_mode,	/* SIOCSIWMODE */
+	(iw_handler)ks_wlan_get_mode,	/* SIOCGIWMODE */
 #ifndef KSC_OPNOTSUPP
-	(iw_handler) ks_wlan_set_sens,	/* SIOCSIWSENS */
-	(iw_handler) ks_wlan_get_sens,	/* SIOCGIWSENS */
+	(iw_handler)ks_wlan_set_sens,	/* SIOCSIWSENS */
+	(iw_handler)ks_wlan_get_sens,	/* SIOCGIWSENS */
 #else /* KSC_OPNOTSUPP */
-	(iw_handler) NULL,	/* SIOCSIWSENS */
-	(iw_handler) NULL,	/* SIOCGIWSENS */
+	(iw_handler)NULL,	/* SIOCSIWSENS */
+	(iw_handler)NULL,	/* SIOCGIWSENS */
 #endif /* KSC_OPNOTSUPP */
-	(iw_handler) NULL,	/* SIOCSIWRANGE */
-	(iw_handler) ks_wlan_get_range,	/* SIOCGIWRANGE */
-	(iw_handler) NULL,	/* SIOCSIWPRIV */
-	(iw_handler) NULL,	/* SIOCGIWPRIV */
-	(iw_handler) NULL,	/* SIOCSIWSTATS */
-	(iw_handler) ks_wlan_get_iwstats,	/* SIOCGIWSTATS */
-	(iw_handler) NULL,	/* SIOCSIWSPY */
-	(iw_handler) NULL,	/* SIOCGIWSPY */
-	(iw_handler) NULL,	/* SIOCSIWTHRSPY */
-	(iw_handler) NULL,	/* SIOCGIWTHRSPY */
-	(iw_handler) ks_wlan_set_wap,	/* SIOCSIWAP */
-	(iw_handler) ks_wlan_get_wap,	/* SIOCGIWAP */
-//      (iw_handler) NULL,                      /* SIOCSIWMLME */
-	(iw_handler) ks_wlan_set_mlme,	/* SIOCSIWMLME */
-	(iw_handler) ks_wlan_get_aplist,	/* SIOCGIWAPLIST */
-	(iw_handler) ks_wlan_set_scan,	/* SIOCSIWSCAN */
-	(iw_handler) ks_wlan_get_scan,	/* SIOCGIWSCAN */
-	(iw_handler) ks_wlan_set_essid,	/* SIOCSIWESSID */
-	(iw_handler) ks_wlan_get_essid,	/* SIOCGIWESSID */
-	(iw_handler) ks_wlan_set_nick,	/* SIOCSIWNICKN */
-	(iw_handler) ks_wlan_get_nick,	/* SIOCGIWNICKN */
-	(iw_handler) NULL,	/* -- hole -- */
-	(iw_handler) NULL,	/* -- hole -- */
-	(iw_handler) ks_wlan_set_rate,	/* SIOCSIWRATE */
-	(iw_handler) ks_wlan_get_rate,	/* SIOCGIWRATE */
-	(iw_handler) ks_wlan_set_rts,	/* SIOCSIWRTS */
-	(iw_handler) ks_wlan_get_rts,	/* SIOCGIWRTS */
-	(iw_handler) ks_wlan_set_frag,	/* SIOCSIWFRAG */
-	(iw_handler) ks_wlan_get_frag,	/* SIOCGIWFRAG */
+	(iw_handler)NULL,	/* SIOCSIWRANGE */
+	(iw_handler)ks_wlan_get_range,	/* SIOCGIWRANGE */
+	(iw_handler)NULL,	/* SIOCSIWPRIV */
+	(iw_handler)NULL,	/* SIOCGIWPRIV */
+	(iw_handler)NULL,	/* SIOCSIWSTATS */
+	(iw_handler)ks_wlan_get_iwstats,	/* SIOCGIWSTATS */
+	(iw_handler)NULL,	/* SIOCSIWSPY */
+	(iw_handler)NULL,	/* SIOCGIWSPY */
+	(iw_handler)NULL,	/* SIOCSIWTHRSPY */
+	(iw_handler)NULL,	/* SIOCGIWTHRSPY */
+	(iw_handler)ks_wlan_set_wap,	/* SIOCSIWAP */
+	(iw_handler)ks_wlan_get_wap,	/* SIOCGIWAP */
+//      (iw_handler)NULL,                      /* SIOCSIWMLME */
+	(iw_handler)ks_wlan_set_mlme,	/* SIOCSIWMLME */
+	(iw_handler)ks_wlan_get_aplist,	/* SIOCGIWAPLIST */
+	(iw_handler)ks_wlan_set_scan,	/* SIOCSIWSCAN */
+	(iw_handler)ks_wlan_get_scan,	/* SIOCGIWSCAN */
+	(iw_handler)ks_wlan_set_essid,	/* SIOCSIWESSID */
+	(iw_handler)ks_wlan_get_essid,	/* SIOCGIWESSID */
+	(iw_handler)ks_wlan_set_nick,	/* SIOCSIWNICKN */
+	(iw_handler)ks_wlan_get_nick,	/* SIOCGIWNICKN */
+	(iw_handler)NULL,	/* -- hole -- */
+	(iw_handler)NULL,	/* -- hole -- */
+	(iw_handler)ks_wlan_set_rate,	/* SIOCSIWRATE */
+	(iw_handler)ks_wlan_get_rate,	/* SIOCGIWRATE */
+	(iw_handler)ks_wlan_set_rts,	/* SIOCSIWRTS */
+	(iw_handler)ks_wlan_get_rts,	/* SIOCGIWRTS */
+	(iw_handler)ks_wlan_set_frag,	/* SIOCSIWFRAG */
+	(iw_handler)ks_wlan_get_frag,	/* SIOCGIWFRAG */
 #ifndef KSC_OPNOTSUPP
-	(iw_handler) ks_wlan_set_txpow,	/* SIOCSIWTXPOW */
-	(iw_handler) ks_wlan_get_txpow,	/* SIOCGIWTXPOW */
-	(iw_handler) ks_wlan_set_retry,	/* SIOCSIWRETRY */
-	(iw_handler) ks_wlan_get_retry,	/* SIOCGIWRETRY */
+	(iw_handler)ks_wlan_set_txpow,	/* SIOCSIWTXPOW */
+	(iw_handler)ks_wlan_get_txpow,	/* SIOCGIWTXPOW */
+	(iw_handler)ks_wlan_set_retry,	/* SIOCSIWRETRY */
+	(iw_handler)ks_wlan_get_retry,	/* SIOCGIWRETRY */
 #else /* KSC_OPNOTSUPP */
-	(iw_handler) NULL,	/* SIOCSIWTXPOW */
-	(iw_handler) NULL,	/* SIOCGIWTXPOW */
-	(iw_handler) NULL,	/* SIOCSIWRETRY */
-	(iw_handler) NULL,	/* SIOCGIWRETRY */
+	(iw_handler)NULL,	/* SIOCSIWTXPOW */
+	(iw_handler)NULL,	/* SIOCGIWTXPOW */
+	(iw_handler)NULL,	/* SIOCSIWRETRY */
+	(iw_handler)NULL,	/* SIOCGIWRETRY */
 #endif /* KSC_OPNOTSUPP */
-	(iw_handler) ks_wlan_set_encode,	/* SIOCSIWENCODE */
-	(iw_handler) ks_wlan_get_encode,	/* SIOCGIWENCODE */
-	(iw_handler) ks_wlan_set_power,	/* SIOCSIWPOWER */
-	(iw_handler) ks_wlan_get_power,	/* SIOCGIWPOWER */
-	(iw_handler) NULL,	/* -- hole -- */
-	(iw_handler) NULL,	/* -- hole -- */
-//      (iw_handler) NULL,                      /* SIOCSIWGENIE */
-	(iw_handler) ks_wlan_set_genie,	/* SIOCSIWGENIE */
-	(iw_handler) NULL,	/* SIOCGIWGENIE */
-	(iw_handler) ks_wlan_set_auth_mode,	/* SIOCSIWAUTH */
-	(iw_handler) ks_wlan_get_auth_mode,	/* SIOCGIWAUTH */
-	(iw_handler) ks_wlan_set_encode_ext,	/* SIOCSIWENCODEEXT */
-	(iw_handler) ks_wlan_get_encode_ext,	/* SIOCGIWENCODEEXT */
-	(iw_handler) ks_wlan_set_pmksa,	/* SIOCSIWPMKSA */
-	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler)ks_wlan_set_encode,	/* SIOCSIWENCODE */
+	(iw_handler)ks_wlan_get_encode,	/* SIOCGIWENCODE */
+	(iw_handler)ks_wlan_set_power,	/* SIOCSIWPOWER */
+	(iw_handler)ks_wlan_get_power,	/* SIOCGIWPOWER */
+	(iw_handler)NULL,	/* -- hole -- */
+	(iw_handler)NULL,	/* -- hole -- */
+//      (iw_handler)NULL,                      /* SIOCSIWGENIE */
+	(iw_handler)ks_wlan_set_genie,	/* SIOCSIWGENIE */
+	(iw_handler)NULL,	/* SIOCGIWGENIE */
+	(iw_handler)ks_wlan_set_auth_mode,	/* SIOCSIWAUTH */
+	(iw_handler)ks_wlan_get_auth_mode,	/* SIOCGIWAUTH */
+	(iw_handler)ks_wlan_set_encode_ext,	/* SIOCSIWENCODEEXT */
+	(iw_handler)ks_wlan_get_encode_ext,	/* SIOCGIWENCODEEXT */
+	(iw_handler)ks_wlan_set_pmksa,	/* SIOCSIWPMKSA */
+	(iw_handler)NULL,	/* -- hole -- */
 };
 
 /* private_handler */
 static const iw_handler ks_wlan_private_handler[] = {
-	(iw_handler) NULL,	/*  0 */
-	(iw_handler) NULL,	/*  1, used to be: KS_WLAN_GET_DRIVER_VERSION */
-	(iw_handler) NULL,	/*  2 */
-	(iw_handler) ks_wlan_get_firmware_version,	/*  3 KS_WLAN_GET_FIRM_VERSION */
+	(iw_handler)NULL,	/*  0 */
+	(iw_handler)NULL,	/*  1, used to be: KS_WLAN_GET_DRIVER_VERSION */
+	(iw_handler)NULL,	/*  2 */
+	(iw_handler)ks_wlan_get_firmware_version,	/*  3 KS_WLAN_GET_FIRM_VERSION */
 #ifdef WPS
-	(iw_handler) ks_wlan_set_wps_enable,	/*  4 KS_WLAN_SET_WPS_ENABLE  */
-	(iw_handler) ks_wlan_get_wps_enable,	/*  5 KS_WLAN_GET_WPS_ENABLE  */
-	(iw_handler) ks_wlan_set_wps_probe_req,	/*  6 KS_WLAN_SET_WPS_PROBE_REQ */
+	(iw_handler)ks_wlan_set_wps_enable,	/*  4 KS_WLAN_SET_WPS_ENABLE  */
+	(iw_handler)ks_wlan_get_wps_enable,	/*  5 KS_WLAN_GET_WPS_ENABLE  */
+	(iw_handler)ks_wlan_set_wps_probe_req,	/*  6 KS_WLAN_SET_WPS_PROBE_REQ */
 #else
-	(iw_handler) NULL,	/*  4 */
-	(iw_handler) NULL,	/*  5 */
-	(iw_handler) NULL,	/*  6 */
+	(iw_handler)NULL,	/*  4 */
+	(iw_handler)NULL,	/*  5 */
+	(iw_handler)NULL,	/*  6 */
 #endif /* WPS */
 
-	(iw_handler) ks_wlan_get_eeprom_cksum,	/*  7 KS_WLAN_GET_CONNECT */
-	(iw_handler) ks_wlan_set_preamble,	/*  8 KS_WLAN_SET_PREAMBLE */
-	(iw_handler) ks_wlan_get_preamble,	/*  9 KS_WLAN_GET_PREAMBLE */
-	(iw_handler) ks_wlan_set_powermgt,	/* 10 KS_WLAN_SET_POWER_SAVE */
-	(iw_handler) ks_wlan_get_powermgt,	/* 11 KS_WLAN_GET_POWER_SAVE */
-	(iw_handler) ks_wlan_set_scan_type,	/* 12 KS_WLAN_SET_SCAN_TYPE */
-	(iw_handler) ks_wlan_get_scan_type,	/* 13 KS_WLAN_GET_SCAN_TYPE */
-	(iw_handler) ks_wlan_set_rx_gain,	/* 14 KS_WLAN_SET_RX_GAIN */
-	(iw_handler) ks_wlan_get_rx_gain,	/* 15 KS_WLAN_GET_RX_GAIN */
-	(iw_handler) ks_wlan_hostt,	/* 16 KS_WLAN_HOSTT */
-	(iw_handler) NULL,	/* 17 */
-	(iw_handler) ks_wlan_set_beacon_lost,	/* 18 KS_WLAN_SET_BECAN_LOST */
-	(iw_handler) ks_wlan_get_beacon_lost,	/* 19 KS_WLAN_GET_BECAN_LOST */
-	(iw_handler) ks_wlan_set_tx_gain,	/* 20 KS_WLAN_SET_TX_GAIN */
-	(iw_handler) ks_wlan_get_tx_gain,	/* 21 KS_WLAN_GET_TX_GAIN */
-	(iw_handler) ks_wlan_set_phy_type,	/* 22 KS_WLAN_SET_PHY_TYPE */
-	(iw_handler) ks_wlan_get_phy_type,	/* 23 KS_WLAN_GET_PHY_TYPE */
-	(iw_handler) ks_wlan_set_cts_mode,	/* 24 KS_WLAN_SET_CTS_MODE */
-	(iw_handler) ks_wlan_get_cts_mode,	/* 25 KS_WLAN_GET_CTS_MODE */
-	(iw_handler) NULL,	/* 26 */
-	(iw_handler) NULL,	/* 27 */
-	(iw_handler) ks_wlan_set_sleep_mode,	/* 28 KS_WLAN_SET_SLEEP_MODE */
-	(iw_handler) ks_wlan_get_sleep_mode,	/* 29 KS_WLAN_GET_SLEEP_MODE */
-	(iw_handler) NULL,	/* 30 */
-	(iw_handler) NULL,	/* 31 */
+	(iw_handler)ks_wlan_get_eeprom_cksum,	/*  7 KS_WLAN_GET_CONNECT */
+	(iw_handler)ks_wlan_set_preamble,	/*  8 KS_WLAN_SET_PREAMBLE */
+	(iw_handler)ks_wlan_get_preamble,	/*  9 KS_WLAN_GET_PREAMBLE */
+	(iw_handler)ks_wlan_set_powermgt,	/* 10 KS_WLAN_SET_POWER_SAVE */
+	(iw_handler)ks_wlan_get_powermgt,	/* 11 KS_WLAN_GET_POWER_SAVE */
+	(iw_handler)ks_wlan_set_scan_type,	/* 12 KS_WLAN_SET_SCAN_TYPE */
+	(iw_handler)ks_wlan_get_scan_type,	/* 13 KS_WLAN_GET_SCAN_TYPE */
+	(iw_handler)ks_wlan_set_rx_gain,	/* 14 KS_WLAN_SET_RX_GAIN */
+	(iw_handler)ks_wlan_get_rx_gain,	/* 15 KS_WLAN_GET_RX_GAIN */
+	(iw_handler)ks_wlan_hostt,	/* 16 KS_WLAN_HOSTT */
+	(iw_handler)NULL,	/* 17 */
+	(iw_handler)ks_wlan_set_beacon_lost,	/* 18 KS_WLAN_SET_BECAN_LOST */
+	(iw_handler)ks_wlan_get_beacon_lost,	/* 19 KS_WLAN_GET_BECAN_LOST */
+	(iw_handler)ks_wlan_set_tx_gain,	/* 20 KS_WLAN_SET_TX_GAIN */
+	(iw_handler)ks_wlan_get_tx_gain,	/* 21 KS_WLAN_GET_TX_GAIN */
+	(iw_handler)ks_wlan_set_phy_type,	/* 22 KS_WLAN_SET_PHY_TYPE */
+	(iw_handler)ks_wlan_get_phy_type,	/* 23 KS_WLAN_GET_PHY_TYPE */
+	(iw_handler)ks_wlan_set_cts_mode,	/* 24 KS_WLAN_SET_CTS_MODE */
+	(iw_handler)ks_wlan_get_cts_mode,	/* 25 KS_WLAN_GET_CTS_MODE */
+	(iw_handler)NULL,	/* 26 */
+	(iw_handler)NULL,	/* 27 */
+	(iw_handler)ks_wlan_set_sleep_mode,	/* 28 KS_WLAN_SET_SLEEP_MODE */
+	(iw_handler)ks_wlan_get_sleep_mode,	/* 29 KS_WLAN_GET_SLEEP_MODE */
+	(iw_handler)NULL,	/* 30 */
+	(iw_handler)NULL,	/* 31 */
 };
 
 static const struct iw_handler_def ks_wlan_handler_def = {
@@ -3247,8 +3247,8 @@ static const struct iw_handler_def ks_wlan_handler_def = {
 	.num_private = sizeof(ks_wlan_private_handler) / sizeof(iw_handler),
 	.num_private_args =
 	    sizeof(ks_wlan_private_args) / sizeof(struct iw_priv_args),
-	.standard = (iw_handler *) ks_wlan_handler,
-	.private = (iw_handler *) ks_wlan_private_handler,
+	.standard = (iw_handler *)ks_wlan_handler,
+	.private = (iw_handler *)ks_wlan_private_handler,
 	.private_args = (struct iw_priv_args *)ks_wlan_private_args,
 	.get_wireless_stats = ks_get_wireless_stats,
 };

commit 184eb0c5b6d7293947bd02058eef9323cc2c8631
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Sun Mar 12 03:29:59 2017 +0100

    Staging: ks7010: ks_*: Use preferred 'u8' kernel type over 'uint8_t'
    
    Fix prefer kernel type 'u8' over 'uint8_t' checks.
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index d06dfe0f6732..2b4d6c1cb037 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2767,7 +2767,7 @@ static int ks_wlan_set_wps_probe_req(struct net_device *dev,
 				     struct iw_request_info *info,
 				     struct iw_point *dwrq, char *extra)
 {
-	uint8_t *p = extra;
+	u8 *p = extra;
 	unsigned char len;
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);

commit be04661703522d201590c4541248cb8c92d89f2e
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Wed Mar 1 16:27:54 2017 +0530

    staging: ks7010: Unnecessary parentheses removed and improved coding style.
    
    Unnecessary parentheses are removed as reported by checkpatch.pl
    to make coder nicer and to improve readability.
    Also coding style is improved as it's often nicer to read if
     &(foo[0]) is converted to foo like:
     memcpy(&(ap->bssid[0]), &(ap_info->bssid[0]), ETH_ALEN);
     memcpy(ap->bssid, ap_info->bssid, ETH_ALEN);
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 9cec19f1babc..d06dfe0f6732 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -421,7 +421,7 @@ static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 
 	/* for SLEEP MODE */
 	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS)
-		memcpy(awrq->sa_data, &(priv->current_ap.bssid[0]), ETH_ALEN);
+		memcpy(awrq->sa_data, priv->current_ap.bssid, ETH_ALEN);
 	else
 		eth_zero_addr(awrq->sa_data);
 
@@ -1455,7 +1455,7 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 	iwe.u.data.flags = 1;
 	current_ev =
 	    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
-				 &(ap->ssid.body[0]));
+				 ap->ssid.body);
 
 	/* Add mode */
 	iwe.cmd = SIOCGIWMODE;
@@ -1497,7 +1497,7 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev,
 	iwe.u.data.length = 0;
 	current_ev =
 	    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
-				 &(ap->ssid.body[0]));
+				 ap->ssid.body);
 
 	/* Rate : stuffing multiple values in a single event require a bit
 	 * more of magic - Jean II */
@@ -1613,7 +1613,7 @@ static int ks_wlan_get_scan(struct net_device *dev,
 		current_ev = ks_wlan_translate_scan(dev, current_ev,
 //                                                  extra + IW_SCAN_MAX_DATA,
 						    extra + dwrq->length,
-						    &(priv->current_ap));
+						    &priv->current_ap);
 	}
 #endif
 	/* Read and parse all entries */
@@ -1626,7 +1626,7 @@ static int ks_wlan_get_scan(struct net_device *dev,
 		current_ev = ks_wlan_translate_scan(dev, info, current_ev,
 //                                                  extra + IW_SCAN_MAX_DATA,
 						    extra + dwrq->length,
-						    &(priv->aplist.ap[i]));
+						    &priv->aplist.ap[i]);
 	}
 	/* Length of data */
 	dwrq->length = (current_ev - extra);
@@ -2082,7 +2082,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 		}
 		break;
 	case IW_PMKSA_FLUSH:
-		memset(&(priv->pmklist), 0, sizeof(priv->pmklist));
+		memset(&priv->pmklist, 0, sizeof(priv->pmklist));
 		INIT_LIST_HEAD(&priv->pmklist.head);
 		for (i = 0; i < PMK_LIST_MAX; i++)
 			INIT_LIST_HEAD(&priv->pmklist.pmk[i].list);
@@ -2179,7 +2179,7 @@ static int ks_wlan_get_firmware_version(struct net_device *dev,
 {
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
-	strcpy(extra, &(priv->firmware_version[0]));
+	strcpy(extra, priv->firmware_version);
 	dwrq->length = priv->version_size + 1;
 	return 0;
 }
@@ -2437,7 +2437,7 @@ static int ks_wlan_data_read(struct net_device *dev,
 		read_length = priv->dev_size[priv->dev_count];
 
 	/* Copy data */
-	memcpy(extra, &(priv->dev_data[priv->dev_count][0]), read_length);
+	memcpy(extra, &priv->dev_data[priv->dev_count][0], read_length);
 
 	spin_unlock(&priv->dev_read_lock);	/* release spin lock */
 
@@ -3261,7 +3261,7 @@ static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq,
 
 	switch (cmd) {
 	case SIOCIWFIRSTPRIV + 20:	/* KS_WLAN_SET_STOP_REQ */
-		rc = ks_wlan_set_stop_request(dev, NULL, &(wrq->u.mode), NULL);
+		rc = ks_wlan_set_stop_request(dev, NULL, &wrq->u.mode, NULL);
 		break;
 		// All other calls are currently unsupported
 	default:

commit 8f4d00cd2390f68336337c5b6ac175090021ffdd
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Fri Feb 17 22:41:54 2017 +0100

    Staging: ks7010: ks_*: Braces should be used on all arms of these statements
    
    Braces should be used on all arms of these statements (CHECK)..
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 121e1530fdba..9cec19f1babc 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -225,9 +225,9 @@ static int ks_wlan_set_freq(struct net_device *dev,
 		fwrq->m = c + 1;
 	}
 	/* Setting by channel number */
-	if ((fwrq->m > 1000) || (fwrq->e > 0))
+	if ((fwrq->m > 1000) || (fwrq->e > 0)) {
 		rc = -EOPNOTSUPP;
-	else {
+	} else {
 		int channel = fwrq->m;
 		/* We should do a better check than that,
 		 * based on the card capability !!! */
@@ -977,8 +977,9 @@ static int ks_wlan_set_encode(struct net_device *dev,
 				if (priv->reg.wep_key[index].size) {
 					priv->reg.wep_index = index;
 					priv->need_commit |= SME_WEP_INDEX;
-				} else
+				} else {
 					return -EINVAL;
+				}
 			}
 		}
 	}
@@ -1054,8 +1055,9 @@ static int ks_wlan_get_encode(struct net_device *dev,
 		if ((index >= 0) && (index < 4))
 			memcpy(extra, priv->reg.wep_key[index].val,
 			       dwrq->length);
-	} else
+	} else {
 		memcpy(extra, zeros, dwrq->length);
+	}
 #endif
 	return 0;
 }
@@ -1272,8 +1274,9 @@ static int ks_wlan_set_power(struct net_device *dev,
 			priv->reg.powermgt = POWMGT_SAVE2_MODE;
 		else
 			return -EINVAL;
-	} else
+	} else {
 		return -EINVAL;
+	}
 
 	hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
 
@@ -1942,8 +1945,9 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 			return -EINVAL;
 		}
 		priv->wpa.key[index].alg = enc->alg;
-	} else
+	} else {
 		return -EINVAL;
+	}
 
 	if (commit) {
 		if (commit & SME_WEP_INDEX)
@@ -2201,8 +2205,9 @@ static int ks_wlan_set_detach(struct net_device *dev,
 	} else if (*uwrq == DISCONNECT_STATUS) {	/* 1 */
 		priv->connect_status |= FORCE_DISCONNECT;
 		netif_carrier_off(dev);
-	} else
+	} else {
 		return -EINVAL;
+	}
 	return 0;
 }
 
@@ -2256,8 +2261,9 @@ static int ks_wlan_set_preamble(struct net_device *dev,
 		priv->reg.preamble = LONG_PREAMBLE;
 	} else if (*uwrq == SHORT_PREAMBLE) {	/* 1 */
 		priv->reg.preamble = SHORT_PREAMBLE;
-	} else
+	} else {
 		return -EINVAL;
+	}
 
 	priv->need_commit |= SME_MODE_SET;
 	return -EINPROGRESS;	/* Call commit handler */
@@ -2305,8 +2311,9 @@ static int ks_wlan_set_powermgt(struct net_device *dev,
 			priv->reg.powermgt = POWMGT_SAVE2_MODE;
 		else
 			return -EINVAL;
-	} else
+	} else {
 		return -EINVAL;
+	}
 
 	hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
 
@@ -2346,8 +2353,9 @@ static int ks_wlan_set_scan_type(struct net_device *dev,
 		priv->reg.scan_type = ACTIVE_SCAN;
 	} else if (*uwrq == PASSIVE_SCAN) {	/* 1 */
 		priv->reg.scan_type = PASSIVE_SCAN;
-	} else
+	} else {
 		return -EINVAL;
+	}
 
 	return 0;
 }
@@ -2519,8 +2527,9 @@ static int ks_wlan_set_beacon_lost(struct net_device *dev,
 	if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 		priv->need_commit |= SME_MODE_SET;
 		return -EINPROGRESS;	/* Call commit handler */
-	} else
+	} else {
 		return 0;
+	}
 }
 
 /*------------------------------------------------------------------*/
@@ -2557,8 +2566,9 @@ static int ks_wlan_set_phy_type(struct net_device *dev,
 		priv->reg.phy_type = D_11G_ONLY_MODE;
 	} else if (*uwrq == D_11BG_COMPATIBLE_MODE) {	/* 2 */
 		priv->reg.phy_type = D_11BG_COMPATIBLE_MODE;
-	} else
+	} else {
 		return -EINVAL;
+	}
 
 	priv->need_commit |= SME_MODE_SET;
 	return -EINPROGRESS;	/* Call commit handler */
@@ -2596,12 +2606,14 @@ static int ks_wlan_set_cts_mode(struct net_device *dev,
 		priv->reg.cts_mode = CTS_MODE_FALSE;
 	} else if (*uwrq == CTS_MODE_TRUE) {	/* 1 */
 		if (priv->reg.phy_type == D_11G_ONLY_MODE ||
-		    priv->reg.phy_type == D_11BG_COMPATIBLE_MODE)
+		    priv->reg.phy_type == D_11BG_COMPATIBLE_MODE) {
 			priv->reg.cts_mode = CTS_MODE_TRUE;
-		else
+		} else {
 			priv->reg.cts_mode = CTS_MODE_FALSE;
-	} else
+		}
+	} else {
 		return -EINVAL;
+	}
 
 	priv->need_commit |= SME_MODE_SET;
 	return -EINPROGRESS;	/* Call commit handler */

commit db224d31bbcd04fe1e85b40649e61ced97776720
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Thu Feb 16 17:13:25 2017 +0100

    Staging: ks7010: Add required and preferred spaces around operators
    
    Spaces should be added around operators to improve readability
    and are required in some cases.
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index e7cbe001235b..121e1530fdba 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2451,7 +2451,7 @@ static int ks_wlan_data_read(struct net_device *dev,
 #if 0
 /*------------------------------------------------------------------*/
 /* Private handler : get wep string */
-#define WEP_ASCII_BUFF_SIZE (17+64*4+1)
+#define WEP_ASCII_BUFF_SIZE (17 + 64 * 4 + 1)
 static int ks_wlan_get_wep_ascii(struct net_device *dev,
 				 struct iw_request_info *info,
 				 struct iw_point *dwrq, char *extra)
@@ -3392,7 +3392,7 @@ int ks_wlan_close(struct net_device *dev)
 
 /* Operational parameters that usually are not changed. */
 /* Time in jiffies before concluding the transmitter is hung. */
-#define TX_TIMEOUT  (3*HZ)
+#define TX_TIMEOUT  (3 * HZ)
 static const unsigned char dummy_addr[] = {
 	0x00, 0x0b, 0xe3, 0x00, 0x00, 0x00
 };

commit d9eb486147270d15110dc3153203dfe65ccd15e6
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Thu Feb 16 16:31:02 2017 +0100

    Staging: ks7010: ks*: Remove redundant blank lines
    
    Multiple blank lines shouldn't be used.
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index c7503a9306cd..e7cbe001235b 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -285,7 +285,6 @@ static int ks_wlan_set_essid(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
-
 	/* for SLEEP MODE */
 	/* Check if we asked for `any' */
 	if (dwrq->flags == 0) {
@@ -342,7 +341,6 @@ static int ks_wlan_get_essid(struct net_device *dev,
 	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
 
-
 	/* for SLEEP MODE */
 	/* Note : if dwrq->flags != 0, we should
 	 * get the relevant SSID from the SSID list... */

commit fac103e0ab8dfc8fecf1462f6f3777ea9744fc4d
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Fri Feb 10 17:08:14 2017 +0100

    Staging: ks7010: ks_*: Removed blank lines before and after braces.
    
    Removing unnecessary blank lines around braces to solve CHECKS.
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 8c55428b71c7..c7503a9306cd 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2095,7 +2095,6 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 
 static struct iw_statistics *ks_get_wireless_stats(struct net_device *dev)
 {
-
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	struct iw_statistics *wstats = &priv->wstats;
@@ -2264,7 +2263,6 @@ static int ks_wlan_set_preamble(struct net_device *dev,
 
 	priv->need_commit |= SME_MODE_SET;
 	return -EINPROGRESS;	/* Call commit handler */
-
 }
 
 /*------------------------------------------------------------------*/
@@ -2933,7 +2931,6 @@ static int ks_wlan_get_eeprom_cksum(struct net_device *dev,
 
 static void print_hif_event(struct net_device *dev, int event)
 {
-
 	switch (event) {
 	case HIF_DATA_REQ:
 		netdev_info(dev, "HIF_DATA_REQ\n");
@@ -3353,7 +3350,6 @@ void send_packet_complete(void *arg1, void *arg2)
 		dev_kfree_skb(packet);
 		packet = NULL;
 	}
-
 }
 
 /* Set or clear the multicast filter for this adaptor.
@@ -3388,7 +3384,6 @@ int ks_wlan_open(struct net_device *dev)
 static
 int ks_wlan_close(struct net_device *dev)
 {
-
 	netif_stop_queue(dev);
 
 	DPRINTK(4, "%s: Shutting down ethercard, status was 0x%4.4x.\n",

commit 9a8936d62c1cf97b44b9ec48d54d90723a461814
Author: David Wittman <dwittman@gmail.com>
Date:   Sat Jan 14 17:26:07 2017 -0600

    staging: ks7010: Fix brace style issue in ks_wlan_net.c
    
    This change fixes a checkpatch error for "that open brace { should be
    on the previous line" as well as a related spacing warning.
    
    Signed-off-by: David Wittman <dwittman@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index e5d04adaeb1a..8c55428b71c7 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -3400,8 +3400,9 @@ int ks_wlan_close(struct net_device *dev)
 /* Operational parameters that usually are not changed. */
 /* Time in jiffies before concluding the transmitter is hung. */
 #define TX_TIMEOUT  (3*HZ)
-static const unsigned char dummy_addr[] =
-    { 0x00, 0x0b, 0xe3, 0x00, 0x00, 0x00 };
+static const unsigned char dummy_addr[] = {
+	0x00, 0x0b, 0xe3, 0x00, 0x00, 0x00
+};
 
 static const struct net_device_ops ks_wlan_netdev_ops = {
 	.ndo_start_xmit = ks_wlan_start_xmit,

commit f416e264577c73bb550d3a64943f5e59d11c6abc
Author: Yamanappagouda Patil <goudapatilk@gmail.com>
Date:   Sat Dec 3 18:29:31 2016 +0530

    staging: ks7010: fixed 'space prohibited after that *' erros.
    
    Fixed checkpatch.pl errors related to "space prohibited after that '*'
    or '&'" in ks_wlan_net.c file.
    
    Signed-off-by: Yamanappagouda Patil <goudapatilk@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 3fe9b3c97a47..e5d04adaeb1a 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -390,9 +390,9 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 	/* for SLEEP MODE */
 	if (priv->reg.operation_mode == MODE_ADHOC ||
 	    priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
-		memcpy(priv->reg.bssid, (u8 *) & ap_addr->sa_data, ETH_ALEN);
+		memcpy(priv->reg.bssid, &ap_addr->sa_data, ETH_ALEN);
 
-		if (is_valid_ether_addr((u8 *) priv->reg.bssid))
+		if (is_valid_ether_addr((u8 *)priv->reg.bssid))
 			priv->need_commit |= SME_MODE_SET;
 
 	} else {
@@ -2685,7 +2685,7 @@ static int ks_wlan_set_phy_information_timer(struct net_device *dev,
 		return -EPERM;
 	/* for SLEEP MODE */
 	if (*uwrq >= 0 && *uwrq <= 0xFFFF)	/* 0-65535 */
-		priv->reg.phy_info_timer = (uint16_t) * uwrq;
+		priv->reg.phy_info_timer = (uint16_t)*uwrq;
 	else
 		return -EINVAL;
 
@@ -2823,7 +2823,7 @@ static int ks_wlan_set_tx_gain(struct net_device *dev,
 		return -EPERM;
 	/* for SLEEP MODE */
 	if (*uwrq >= 0 && *uwrq <= 0xFF)	/* 0-255 */
-		priv->gain.TxGain = (uint8_t) * uwrq;
+		priv->gain.TxGain = (uint8_t)*uwrq;
 	else
 		return -EINVAL;
 
@@ -2866,7 +2866,7 @@ static int ks_wlan_set_rx_gain(struct net_device *dev,
 		return -EPERM;
 	/* for SLEEP MODE */
 	if (*uwrq >= 0 && *uwrq <= 0xFF)	/* 0-255 */
-		priv->gain.RxGain = (uint8_t) * uwrq;
+		priv->gain.RxGain = (uint8_t)*uwrq;
 	else
 		return -EINVAL;
 
@@ -2909,7 +2909,7 @@ static int ks_wlan_set_region(struct net_device *dev,
 		return -EPERM;
 	/* for SLEEP MODE */
 	if (*uwrq >= 0x9 && *uwrq <= 0xF)	/* 0x9-0xf */
-		priv->region = (uint8_t) * uwrq;
+		priv->region = (uint8_t)*uwrq;
 	else
 		return -EINVAL;
 

commit fe4975306926117d6f3312aee531b1ad5727c093
Author: Yamanappagouda Patil <goudapatilk@gmail.com>
Date:   Sat Dec 3 19:34:12 2016 +0530

    staging: ks7010: Fixed 'missing blank line after declaration' warnings.
    
    Fixed checkpatch.pl warnings 'Missing blank line after declaration'
    in ks_wlan_net.c file.
    
    Signed-off-by: Yamanappagouda Patil <goudapatilk@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 43bba522e242..3fe9b3c97a47 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -217,6 +217,7 @@ static int ks_wlan_set_freq(struct net_device *dev,
 	    (fwrq->m >= (int)2.412e8) && (fwrq->m <= (int)2.487e8)) {
 		int f = fwrq->m / 100000;
 		int c = 0;
+
 		while ((c < 14) && (f != frequency_list[c]))
 			c++;
 		/* Hack to fall through... */
@@ -1390,6 +1391,7 @@ static int ks_wlan_set_scan(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	struct iw_scan_req *req = NULL;
+
 	DPRINTK(2, "\n");
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -1583,6 +1585,7 @@ static int ks_wlan_get_scan(struct net_device *dev,
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	int i;
 	char *current_ev = extra;
+
 	DPRINTK(2, "\n");
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -1812,6 +1815,7 @@ static int ks_wlan_get_auth_mode(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	int index = (vwrq->flags & IW_AUTH_INDEX);
+
 	DPRINTK(2, "index=%d\n", index);
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -2795,6 +2799,7 @@ static int ks_wlan_get_wps_probe_req(struct net_device *dev,
 				     __u32 *uwrq, char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
+
 	DPRINTK(2, "\n");
 
 	if (priv->sleep_mode == SLP_SLEEP)
@@ -3246,6 +3251,7 @@ static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq,
 {
 	int rc = 0;
 	struct iwreq *wrq = (struct iwreq *)rq;
+
 	switch (cmd) {
 	case SIOCIWFIRSTPRIV + 20:	/* KS_WLAN_SET_STOP_REQ */
 		rc = ks_wlan_set_stop_request(dev, NULL, &(wrq->u.mode), NULL);
@@ -3275,6 +3281,7 @@ int ks_wlan_set_mac_address(struct net_device *dev, void *addr)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct sockaddr *mac_addr = (struct sockaddr *)addr;
+
 	if (netif_running(dev))
 		return -EBUSY;
 	memcpy(dev->dev_addr, mac_addr->sa_data, dev->addr_len);

commit e0d648151d00fe50f062132d9fb59ecc9910c80a
Author: Yamanappagouda Patil <goudapatilk@gmail.com>
Date:   Thu Nov 24 14:49:16 2016 +0530

    Staging: ks7010: Fixed {} brace warnings for single statement blocks.
    
    Fixed checkpatch.pl warnings related to {} brace warnings for single
    statement blocks.
    
    Signed-off-by: Yamanappagouda Patil <goudapatilk@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 3c58f8427e03..43bba522e242 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1290,9 +1290,8 @@ static int ks_wlan_get_power(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	if (priv->reg.powermgt > 0)
 		vwrq->disabled = 0;
@@ -1311,9 +1310,8 @@ static int ks_wlan_get_iwstats(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	vwrq->qual = 0;	/* not supported */
 	vwrq->level = priv->wstats.qual.level;
@@ -1361,9 +1359,8 @@ static int ks_wlan_get_aplist(struct net_device *dev,
 
 	int i;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	for (i = 0; i < priv->aplist.size; i++) {
 		memcpy(address[i].sa_data, &(priv->aplist.ap[i].bssid[0]),
@@ -1395,9 +1392,8 @@ static int ks_wlan_set_scan(struct net_device *dev,
 	struct iw_scan_req *req = NULL;
 	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 
 	/* for SLEEP MODE */
 	/* specified SSID SCAN */
@@ -1589,9 +1585,8 @@ static int ks_wlan_get_scan(struct net_device *dev,
 	char *current_ev = extra;
 	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	if (priv->sme_i.sme_flag & SME_AP_SCAN) {
 		DPRINTK(2, "flag AP_SCAN\n");
@@ -1664,9 +1659,8 @@ static int ks_wlan_set_genie(struct net_device *dev,
 
 	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	return 0;
 //      return -EOPNOTSUPP;
@@ -1685,26 +1679,23 @@ static int ks_wlan_set_auth_mode(struct net_device *dev,
 
 	DPRINTK(2, "index=%d:value=%08X\n", index, value);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	switch (index) {
 	case IW_AUTH_WPA_VERSION:	/* 0 */
 		switch (value) {
 		case IW_AUTH_WPA_VERSION_DISABLED:
 			priv->wpa.version = value;
-			if (priv->wpa.rsn_enabled) {
+			if (priv->wpa.rsn_enabled)
 				priv->wpa.rsn_enabled = 0;
-			}
 			priv->need_commit |= SME_RSN;
 			break;
 		case IW_AUTH_WPA_VERSION_WPA:
 		case IW_AUTH_WPA_VERSION_WPA2:
 			priv->wpa.version = value;
-			if (!(priv->wpa.rsn_enabled)) {
+			if (!(priv->wpa.rsn_enabled))
 				priv->wpa.rsn_enabled = 1;
-			}
 			priv->need_commit |= SME_RSN;
 			break;
 		default:
@@ -1823,9 +1814,8 @@ static int ks_wlan_get_auth_mode(struct net_device *dev,
 	int index = (vwrq->flags & IW_AUTH_INDEX);
 	DPRINTK(2, "index=%d\n", index);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 
 	/* for SLEEP MODE */
 	/*  WPA (not used ?? wpa_supplicant) */
@@ -1875,18 +1865,17 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 	DPRINTK(2, "flags=%04X:: ext_flags=%08X\n", dwrq->flags,
 		enc->ext_flags);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	if (index < 1 || index > 4)
 		return -EINVAL;
 	else
 		index--;
 
-	if (dwrq->flags & IW_ENCODE_DISABLED) {
+	if (dwrq->flags & IW_ENCODE_DISABLED)
 		priv->wpa.key[index].key_len = 0;
-	}
 
 	if (enc) {
 		priv->wpa.key[index].ext_flags = enc->ext_flags;
@@ -1975,9 +1964,8 @@ static int ks_wlan_get_encode_ext(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 
 	/* for SLEEP MODE */
 	/*  WPA (not used ?? wpa_supplicant)
@@ -2004,13 +1992,13 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 
 	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
-	if (!extra) {
+	if (!extra)
 		return -EINVAL;
-	}
+
 	pmksa = (struct iw_pmksa *)extra;
 	DPRINTK(2, "cmd=%d\n", pmksa->cmd);
 
@@ -2137,9 +2125,9 @@ static int ks_wlan_set_stop_request(struct net_device *dev,
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	if (!(*uwrq))
 		return -EINVAL;
@@ -2162,15 +2150,14 @@ static int ks_wlan_set_mlme(struct net_device *dev,
 
 	DPRINTK(2, ":%d :%d\n", mlme->cmd, mlme->reason_code);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	switch (mlme->cmd) {
 	case IW_MLME_DEAUTH:
-		if (mlme->reason_code == WLAN_REASON_MIC_FAILURE) {
+		if (mlme->reason_code == WLAN_REASON_MIC_FAILURE)
 			return 0;
-		}
 	case IW_MLME_DISASSOC:
 		mode = 1;
 		return ks_wlan_set_stop_request(dev, NULL, &mode, NULL);
@@ -2201,9 +2188,9 @@ static int ks_wlan_set_detach(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	if (*uwrq == CONNECT_STATUS) {	/* 0 */
 		priv->connect_status &= ~FORCE_DISCONNECT;
@@ -2226,9 +2213,9 @@ static int ks_wlan_get_detach(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	*uwrq = ((priv->connect_status & FORCE_DISCONNECT) ? 1 : 0);
 	return 0;
@@ -2242,9 +2229,9 @@ static int ks_wlan_get_connect(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	*uwrq = (priv->connect_status & CONNECT_STATUS_MASK);
 	return 0;
@@ -2260,9 +2247,9 @@ static int ks_wlan_set_preamble(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	if (*uwrq == LONG_PREAMBLE) {	/* 0 */
 		priv->reg.preamble = LONG_PREAMBLE;
@@ -2285,9 +2272,9 @@ static int ks_wlan_get_preamble(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	*uwrq = priv->reg.preamble;
 	return 0;
@@ -2302,9 +2289,9 @@ static int ks_wlan_set_powermgt(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	if (*uwrq == POWMGT_ACTIVE_MODE) {	/* 0 */
 		priv->reg.powermgt = POWMGT_ACTIVE_MODE;
@@ -2335,9 +2322,9 @@ static int ks_wlan_get_powermgt(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	*uwrq = priv->reg.powermgt;
 	return 0;
@@ -2352,9 +2339,8 @@ static int ks_wlan_set_scan_type(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	if (*uwrq == ACTIVE_SCAN) {	/* 0 */
 		priv->reg.scan_type = ACTIVE_SCAN;
@@ -2375,9 +2361,8 @@ static int ks_wlan_get_scan_type(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	*uwrq = priv->reg.scan_type;
 	return 0;
@@ -2393,9 +2378,8 @@ static int ks_wlan_data_write(struct net_device *dev,
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 	unsigned char *wbuff = NULL;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	wbuff = (unsigned char *)kmalloc(dwrq->length, GFP_ATOMIC);
 	if (!wbuff)
@@ -2417,9 +2401,8 @@ static int ks_wlan_data_read(struct net_device *dev,
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 	unsigned short read_length;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	if (!atomic_read(&priv->event_count)) {
 		if (priv->dev_state < DEVICE_STATE_BOOT) {	/* Remove device */
@@ -2477,9 +2460,8 @@ static int ks_wlan_get_wep_ascii(struct net_device *dev,
 	int i, j, len = 0;
 	char tmp[WEP_ASCII_BUFF_SIZE];
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	strcpy(tmp, " WEP keys ASCII \n");
 	len += strlen(" WEP keys ASCII \n");
@@ -2526,13 +2508,12 @@ static int ks_wlan_set_beacon_lost(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
-	if (*uwrq >= BEACON_LOST_COUNT_MIN && *uwrq <= BEACON_LOST_COUNT_MAX) {
+	if (*uwrq >= BEACON_LOST_COUNT_MIN && *uwrq <= BEACON_LOST_COUNT_MAX)
 		priv->reg.beacon_lost_count = *uwrq;
-	} else
+	else
 		return -EINVAL;
 
 	if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
@@ -2551,9 +2532,8 @@ static int ks_wlan_get_beacon_lost(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	*uwrq = priv->reg.beacon_lost_count;
 	return 0;
@@ -2568,9 +2548,8 @@ static int ks_wlan_set_phy_type(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	if (*uwrq == D_11B_ONLY_MODE) {	/* 0 */
 		priv->reg.phy_type = D_11B_ONLY_MODE;
@@ -2594,9 +2573,8 @@ static int ks_wlan_get_phy_type(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	*uwrq = priv->reg.phy_type;
 	return 0;
@@ -2611,9 +2589,8 @@ static int ks_wlan_set_cts_mode(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	if (*uwrq == CTS_MODE_FALSE) {	/* 0 */
 		priv->reg.cts_mode = CTS_MODE_FALSE;
@@ -2639,9 +2616,8 @@ static int ks_wlan_get_cts_mode(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	*uwrq = priv->reg.cts_mode;
 	return 0;
@@ -2701,9 +2677,8 @@ static int ks_wlan_set_phy_information_timer(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	if (*uwrq >= 0 && *uwrq <= 0xFFFF)	/* 0-65535 */
 		priv->reg.phy_info_timer = (uint16_t) * uwrq;
@@ -2723,9 +2698,8 @@ static int ks_wlan_get_phy_information_timer(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	*uwrq = priv->reg.phy_info_timer;
 	return 0;
@@ -2743,9 +2717,8 @@ static int ks_wlan_set_wps_enable(struct net_device *dev,
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	if (*uwrq == 0 || *uwrq == 1)
 		priv->wps.wps_enabled = *uwrq;
@@ -2767,9 +2740,8 @@ static int ks_wlan_get_wps_enable(struct net_device *dev,
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	*uwrq = priv->wps.wps_enabled;
 	netdev_info(dev, "return=%d\n", *uwrq);
@@ -2790,16 +2762,14 @@ static int ks_wlan_set_wps_probe_req(struct net_device *dev,
 
 	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	DPRINTK(2, "dwrq->length=%d\n", dwrq->length);
 
 	/* length check */
-	if (p[1] + 2 != dwrq->length || dwrq->length > 256) {
+	if (p[1] + 2 != dwrq->length || dwrq->length > 256)
 		return -EINVAL;
-	}
 
 	priv->wps.ielen = p[1] + 2 + 1;	/* IE header + IE + sizeof(len) */
 	len = p[1] + 2;	/* IE header + IE */
@@ -2827,9 +2797,8 @@ static int ks_wlan_get_wps_probe_req(struct net_device *dev,
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	return 0;
 }
@@ -2845,9 +2814,8 @@ static int ks_wlan_set_tx_gain(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	if (*uwrq >= 0 && *uwrq <= 0xFF)	/* 0-255 */
 		priv->gain.TxGain = (uint8_t) * uwrq;
@@ -2872,9 +2840,8 @@ static int ks_wlan_get_tx_gain(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	*uwrq = priv->gain.TxGain;
 	hostif_sme_enqueue(priv, SME_GET_GAIN);
@@ -2890,9 +2857,8 @@ static int ks_wlan_set_rx_gain(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	if (*uwrq >= 0 && *uwrq <= 0xFF)	/* 0-255 */
 		priv->gain.RxGain = (uint8_t) * uwrq;
@@ -2917,9 +2883,8 @@ static int ks_wlan_get_rx_gain(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	*uwrq = priv->gain.RxGain;
 	hostif_sme_enqueue(priv, SME_GET_GAIN);
@@ -2935,9 +2900,8 @@ static int ks_wlan_set_region(struct net_device *dev,
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 	/* for SLEEP MODE */
 	if (*uwrq >= 0x9 && *uwrq <= 0xF)	/* 0x9-0xf */
 		priv->region = (uint8_t) * uwrq;
@@ -3300,9 +3264,8 @@ struct net_device_stats *ks_wlan_get_stats(struct net_device *dev)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	if (priv->dev_state < DEVICE_STATE_READY) {
+	if (priv->dev_state < DEVICE_STATE_READY)
 		return NULL;	/* not finished initialize */
-	}
 
 	return &priv->nstats;
 }
@@ -3330,9 +3293,8 @@ void ks_wlan_tx_timeout(struct net_device *dev)
 
 	DPRINTK(1, "head(%d) tail(%d)!!\n", priv->tx_dev.qhead,
 		priv->tx_dev.qtail);
-	if (!netif_queue_stopped(dev)) {
+	if (!netif_queue_stopped(dev))
 		netif_stop_queue(dev);
-	}
 	priv->nstats.tx_errors++;
 	netif_wake_queue(dev);
 }
@@ -3361,9 +3323,8 @@ int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	netif_trans_update(dev);
 
 	DPRINTK(4, "rc=%d\n", rc);
-	if (rc) {
+	if (rc)
 		rc = 0;
-	}
 
 	return rc;
 }
@@ -3396,9 +3357,8 @@ void ks_wlan_set_multicast_list(struct net_device *dev)
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	DPRINTK(4, "\n");
-	if (priv->dev_state < DEVICE_STATE_READY) {
+	if (priv->dev_state < DEVICE_STATE_READY)
 		return;	/* not finished initialize */
-	}
 	hostif_sme_enqueue(priv, SME_MULTICAST_REQUEST);
 }
 

commit 0371fa4f6a9efb6ebdc3529e9210218d727c3d4d
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Tue Oct 18 14:38:33 2016 +0000

    staging: ks7010: ks_wlan_net: Use setup_timer instead of init_timer and data fields
    
    Use setup_timer function instead of initializing timer with the function
    and data fields
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 7b864c02348b..3c58f8427e03 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -3460,9 +3460,8 @@ int ks_wlan_net_start(struct net_device *dev)
 
 	/* phy information update timer */
 	atomic_set(&update_phyinfo, 0);
-	init_timer(&update_phyinfo_timer);
-	update_phyinfo_timer.function = ks_wlan_update_phyinfo_timeout;
-	update_phyinfo_timer.data = (unsigned long)priv;
+	setup_timer(&update_phyinfo_timer, ks_wlan_update_phyinfo_timeout,
+		    (unsigned long)priv);
 
 	/* dummy address set */
 	memcpy(priv->eth_addr, dummy_addr, ETH_ALEN);

commit acefb6450d74417ed7ba4381fa2ea073a30f9244
Author: Sabitha George <sabitha.george@gmail.com>
Date:   Thu Oct 13 22:36:23 2016 +0530

    staging: ks7010: Fixes warning :do not add new typedefs
    
    Fixes checkpatch.pl warning: do not add new typedefs in
    ks_wlan_net.c
    
    Signed-off-by: Sabitha George <sabitha.george@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 84edd3b929b0..7b864c02348b 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -50,10 +50,10 @@ static const long frequency_list[] = { 2412, 2417, 2422, 2427, 2432, 2437, 2442,
 /* A few details needed for WEP (Wireless Equivalent Privacy) */
 #define MAX_KEY_SIZE 13	/* 128 (?) bits */
 #define MIN_KEY_SIZE  5	/* 40 bits RC4 - WEP */
-typedef struct wep_key_t {
+struct wep_key {
 	u16 len;
 	u8 key[16];	/* 40-bit and 104-bit keys */
-} wep_key_t;
+};
 
 /* Backward compatibility */
 #ifndef IW_ENCODE_NOKEY
@@ -899,7 +899,7 @@ static int ks_wlan_set_encode(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	wep_key_t key;
+	struct wep_key key;
 	int index = (dwrq->flags & IW_ENCODE_INDEX);
 	int current_index = priv->reg.wep_index;
 	int i;

commit 96268418f9e27d8b0dde6a6c3837979c30a996aa
Author: Sabitha George <sabitha.george@gmail.com>
Date:   Mon Oct 10 23:24:10 2016 +0530

    staging: ks7010: Fixes error "foo * bar should be foo *bar"
    
    Fixes checkpatch warning on ks_wlan_net.c:
    foo * bar should be foo *bar
    
    Signed-off-by: Sabitha George <sabitha.george@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index cda635a1f20f..84edd3b929b0 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -829,7 +829,7 @@ static int ks_wlan_get_frag(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set Mode of Operation */
 static int ks_wlan_set_mode(struct net_device *dev,
-			    struct iw_request_info *info, __u32 * uwrq,
+			    struct iw_request_info *info, __u32 *uwrq,
 			    char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -865,7 +865,7 @@ static int ks_wlan_set_mode(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get Mode of Operation */
 static int ks_wlan_get_mode(struct net_device *dev,
-			    struct iw_request_info *info, __u32 * uwrq,
+			    struct iw_request_info *info, __u32 *uwrq,
 			    char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2130,7 +2130,7 @@ static struct iw_statistics *ks_get_wireless_stats(struct net_device *dev)
 /*------------------------------------------------------------------*/
 /* Private handler : set stop request */
 static int ks_wlan_set_stop_request(struct net_device *dev,
-				    struct iw_request_info *info, __u32 * uwrq,
+				    struct iw_request_info *info, __u32 *uwrq,
 				    char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2196,7 +2196,7 @@ static int ks_wlan_get_firmware_version(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : set force disconnect status */
 static int ks_wlan_set_detach(struct net_device *dev,
-			      struct iw_request_info *info, __u32 * uwrq,
+			      struct iw_request_info *info, __u32 *uwrq,
 			      char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
@@ -2221,7 +2221,7 @@ static int ks_wlan_set_detach(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : get force disconnect status */
 static int ks_wlan_get_detach(struct net_device *dev,
-			      struct iw_request_info *info, __u32 * uwrq,
+			      struct iw_request_info *info, __u32 *uwrq,
 			      char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
@@ -2237,7 +2237,7 @@ static int ks_wlan_get_detach(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : get connect status */
 static int ks_wlan_get_connect(struct net_device *dev,
-			       struct iw_request_info *info, __u32 * uwrq,
+			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
@@ -2254,7 +2254,7 @@ static int ks_wlan_get_connect(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : set preamble */
 static int ks_wlan_set_preamble(struct net_device *dev,
-				struct iw_request_info *info, __u32 * uwrq,
+				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2279,7 +2279,7 @@ static int ks_wlan_set_preamble(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : get preamble */
 static int ks_wlan_get_preamble(struct net_device *dev,
-				struct iw_request_info *info, __u32 * uwrq,
+				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2296,7 +2296,7 @@ static int ks_wlan_get_preamble(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : set power save mode */
 static int ks_wlan_set_powermgt(struct net_device *dev,
-				struct iw_request_info *info, __u32 * uwrq,
+				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2329,7 +2329,7 @@ static int ks_wlan_set_powermgt(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : get power save made */
 static int ks_wlan_get_powermgt(struct net_device *dev,
-				struct iw_request_info *info, __u32 * uwrq,
+				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2346,7 +2346,7 @@ static int ks_wlan_get_powermgt(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : set scan type */
 static int ks_wlan_set_scan_type(struct net_device *dev,
-				 struct iw_request_info *info, __u32 * uwrq,
+				 struct iw_request_info *info, __u32 *uwrq,
 				 char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2369,7 +2369,7 @@ static int ks_wlan_set_scan_type(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : get scan type */
 static int ks_wlan_get_scan_type(struct net_device *dev,
-				 struct iw_request_info *info, __u32 * uwrq,
+				 struct iw_request_info *info, __u32 *uwrq,
 				 char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2520,7 +2520,7 @@ static int ks_wlan_get_wep_ascii(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : set beacon lost count */
 static int ks_wlan_set_beacon_lost(struct net_device *dev,
-				   struct iw_request_info *info, __u32 * uwrq,
+				   struct iw_request_info *info, __u32 *uwrq,
 				   char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2545,7 +2545,7 @@ static int ks_wlan_set_beacon_lost(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : get beacon lost count */
 static int ks_wlan_get_beacon_lost(struct net_device *dev,
-				   struct iw_request_info *info, __u32 * uwrq,
+				   struct iw_request_info *info, __u32 *uwrq,
 				   char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2562,7 +2562,7 @@ static int ks_wlan_get_beacon_lost(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : set phy type */
 static int ks_wlan_set_phy_type(struct net_device *dev,
-				struct iw_request_info *info, __u32 * uwrq,
+				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2588,7 +2588,7 @@ static int ks_wlan_set_phy_type(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : get phy type */
 static int ks_wlan_get_phy_type(struct net_device *dev,
-				struct iw_request_info *info, __u32 * uwrq,
+				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2605,7 +2605,7 @@ static int ks_wlan_get_phy_type(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : set cts mode */
 static int ks_wlan_set_cts_mode(struct net_device *dev,
-				struct iw_request_info *info, __u32 * uwrq,
+				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2633,7 +2633,7 @@ static int ks_wlan_set_cts_mode(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : get cts mode */
 static int ks_wlan_get_cts_mode(struct net_device *dev,
-				struct iw_request_info *info, __u32 * uwrq,
+				struct iw_request_info *info, __u32 *uwrq,
 				char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2651,7 +2651,7 @@ static int ks_wlan_get_cts_mode(struct net_device *dev,
 /* Private handler : set sleep mode */
 static int ks_wlan_set_sleep_mode(struct net_device *dev,
 				  struct iw_request_info *info,
-				  __u32 * uwrq, char *extra)
+				  __u32 *uwrq, char *extra)
 {
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
@@ -2681,7 +2681,7 @@ static int ks_wlan_set_sleep_mode(struct net_device *dev,
 /* Private handler : get sleep mode */
 static int ks_wlan_get_sleep_mode(struct net_device *dev,
 				  struct iw_request_info *info,
-				  __u32 * uwrq, char *extra)
+				  __u32 *uwrq, char *extra)
 {
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
@@ -2697,7 +2697,7 @@ static int ks_wlan_get_sleep_mode(struct net_device *dev,
 /* Private handler : set phy information timer */
 static int ks_wlan_set_phy_information_timer(struct net_device *dev,
 					     struct iw_request_info *info,
-					     __u32 * uwrq, char *extra)
+					     __u32 *uwrq, char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
@@ -2719,7 +2719,7 @@ static int ks_wlan_set_phy_information_timer(struct net_device *dev,
 /* Private handler : get phy information timer */
 static int ks_wlan_get_phy_information_timer(struct net_device *dev,
 					     struct iw_request_info *info,
-					     __u32 * uwrq, char *extra)
+					     __u32 *uwrq, char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
@@ -2736,7 +2736,7 @@ static int ks_wlan_get_phy_information_timer(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : set WPS enable */
 static int ks_wlan_set_wps_enable(struct net_device *dev,
-				  struct iw_request_info *info, __u32 * uwrq,
+				  struct iw_request_info *info, __u32 *uwrq,
 				  char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2760,7 +2760,7 @@ static int ks_wlan_set_wps_enable(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : get WPS enable */
 static int ks_wlan_get_wps_enable(struct net_device *dev,
-				  struct iw_request_info *info, __u32 * uwrq,
+				  struct iw_request_info *info, __u32 *uwrq,
 				  char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2822,7 +2822,7 @@ static int ks_wlan_set_wps_probe_req(struct net_device *dev,
 /* Private handler : get WPS probe req */
 static int ks_wlan_get_wps_probe_req(struct net_device *dev,
 				     struct iw_request_info *info,
-				     __u32 * uwrq, char *extra)
+				     __u32 *uwrq, char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 	DPRINTK(2, "\n");
@@ -2839,7 +2839,7 @@ static int ks_wlan_get_wps_probe_req(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : set tx gain control value */
 static int ks_wlan_set_tx_gain(struct net_device *dev,
-			       struct iw_request_info *info, __u32 * uwrq,
+			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2866,7 +2866,7 @@ static int ks_wlan_set_tx_gain(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : get tx gain control value */
 static int ks_wlan_get_tx_gain(struct net_device *dev,
-			       struct iw_request_info *info, __u32 * uwrq,
+			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2884,7 +2884,7 @@ static int ks_wlan_get_tx_gain(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : set rx gain control value */
 static int ks_wlan_set_rx_gain(struct net_device *dev,
-			       struct iw_request_info *info, __u32 * uwrq,
+			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2911,7 +2911,7 @@ static int ks_wlan_set_rx_gain(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : get rx gain control value */
 static int ks_wlan_get_rx_gain(struct net_device *dev,
-			       struct iw_request_info *info, __u32 * uwrq,
+			       struct iw_request_info *info, __u32 *uwrq,
 			       char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -2930,7 +2930,7 @@ static int ks_wlan_get_rx_gain(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : set region value */
 static int ks_wlan_set_region(struct net_device *dev,
-			      struct iw_request_info *info, __u32 * uwrq,
+			      struct iw_request_info *info, __u32 *uwrq,
 			      char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
@@ -2952,7 +2952,7 @@ static int ks_wlan_set_region(struct net_device *dev,
 /*------------------------------------------------------------------*/
 /* Private handler : get eeprom checksum result */
 static int ks_wlan_get_eeprom_cksum(struct net_device *dev,
-				    struct iw_request_info *info, __u32 * uwrq,
+				    struct iw_request_info *info, __u32 *uwrq,
 				    char *extra)
 {
 	struct ks_wlan_private *priv =
@@ -3079,7 +3079,7 @@ static void print_hif_event(struct net_device *dev, int event)
 /*------------------------------------------------------------------*/
 /* Private handler : get host command history */
 static int ks_wlan_hostt(struct net_device *dev, struct iw_request_info *info,
-			 __u32 * uwrq, char *extra)
+			 __u32 *uwrq, char *extra)
 {
 	int i, event;
 	struct ks_wlan_private *priv =

commit 99a751c74baf90535a232376d81fef957ebad63f
Author: Sabitha George <sabitha.george@gmail.com>
Date:   Mon Oct 10 23:23:15 2016 +0530

    staging: ks7010: Replace asm/uaccess.h and asm/atomic.h
    
    Replaces  inclusion of asm/uaccess.h with linux/uaccess.h
    and asm/atomic.h with linux/atomic.h in ks_wlan_net.c
    
    Signed-off-by: Sabitha George <sabitha.george@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 14bb008754d7..cda635a1f20f 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -24,9 +24,9 @@
 #include <linux/pci.h>
 #include <linux/ctype.h>
 #include <linux/timer.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #include <linux/io.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 static int wep_on_off;
 #define	WEP_OFF		0

commit e33c759a1e7c3f73e0059063e9090bcd2df4a66e
Author: Ebru Akagunduz <ebru.akagunduz@gmail.com>
Date:   Fri Oct 7 14:17:49 2016 +0300

    staging: ks7010: remove unnecessary else statement
    
    This patch removes else statement which is not
    usefull after a return. Issue found by checkpatch.pl.
    
    Signed-off-by: Ebru Akagunduz <ebru.akagunduz@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index b0432fc77c62..14bb008754d7 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -3412,8 +3412,8 @@ int ks_wlan_open(struct net_device *dev)
 	if (!priv->mac_address_valid) {
 		netdev_err(dev, "ks_wlan : %s Not READY !!\n", dev->name);
 		return -EBUSY;
-	} else
-		netif_start_queue(dev);
+	}
+	netif_start_queue(dev);
 
 	return 0;
 }

commit 7a98abccd28e264a60c55df5b8cf59337ec338ba
Author: Pontus Fuchs <pontus.fuchs@gmail.com>
Date:   Thu Oct 6 22:50:20 2016 +0200

    staging: ks7010: Use printk format specifier for MAC addresses
    
    Convert to %pM instead of custom code.
    
    Signed-off-by: Pontus Fuchs <pontus.fuchs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 77a77a96ec22..b0432fc77c62 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -399,9 +399,7 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 		return -EOPNOTSUPP;
 	}
 
-	DPRINTK(2, "bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
-		priv->reg.bssid[0], priv->reg.bssid[1], priv->reg.bssid[2],
-		priv->reg.bssid[3], priv->reg.bssid[4], priv->reg.bssid[5]);
+	DPRINTK(2, "bssid = %pM\n", priv->reg.bssid);
 
 	/* Write it to the card */
 	if (priv->need_commit) {
@@ -3321,10 +3319,7 @@ int ks_wlan_set_mac_address(struct net_device *dev, void *addr)
 
 	priv->mac_address_valid = 0;
 	hostif_sme_enqueue(priv, SME_MACADDRESS_SET_REQUEST);
-	netdev_info(dev,
-	       "ks_wlan: MAC ADDRESS = %02x:%02x:%02x:%02x:%02x:%02x\n",
-	       priv->eth_addr[0], priv->eth_addr[1], priv->eth_addr[2],
-	       priv->eth_addr[3], priv->eth_addr[4], priv->eth_addr[5]);
+	netdev_info(dev, "ks_wlan:  MAC ADDRESS = %pM\n", priv->eth_addr);
 	return 0;
 }
 

commit 6b750fac60896949e7e41a667cc63ad777692b09
Author: Muraru Mihaela <mihaela.muraru21@gmail.com>
Date:   Tue Oct 4 23:08:25 2016 +0300

    Staging: ks7010: fix brace coding style issue
    
    This is a patch to the ks_wlan_net.c file that fixes up a brace coding
    style warning found by checkpatch.pl tool, by deleting the unnecessary braces for single statement blocks.
    
    Signed-off-by: Muraru Mihaela <mihaela.muraru21@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index b2b4fa4c3834..77a77a96ec22 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -88,9 +88,9 @@ int ks_wlan_update_phy_information(struct ks_wlan_private *priv)
 
 	DPRINTK(4, "in_interrupt = %ld\n", in_interrupt());
 
-	if (priv->dev_state < DEVICE_STATE_READY) {
+	if (priv->dev_state < DEVICE_STATE_READY)
 		return -1;	/* not finished initialize */
-	}
+
 	if (atomic_read(&update_phyinfo))
 		return 1;
 
@@ -182,19 +182,18 @@ static int ks_wlan_get_name(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
-	if (priv->dev_state < DEVICE_STATE_READY) {
+	if (priv->dev_state < DEVICE_STATE_READY)
 		strcpy(cwrq, "NOT READY!");
-	} else if (priv->reg.phy_type == D_11B_ONLY_MODE) {
+	else if (priv->reg.phy_type == D_11B_ONLY_MODE)
 		strcpy(cwrq, "IEEE 802.11b");
-	} else if (priv->reg.phy_type == D_11G_ONLY_MODE) {
+	else if (priv->reg.phy_type == D_11G_ONLY_MODE)
 		strcpy(cwrq, "IEEE 802.11g");
-	} else {
+	else
 		strcpy(cwrq, "IEEE 802.11b/g");
-	}
 
 	return 0;
 }
@@ -209,9 +208,8 @@ static int ks_wlan_set_freq(struct net_device *dev,
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	int rc = -EINPROGRESS;	/* Call commit handler */
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 
 	/* for SLEEP MODE */
 	/* If setting by frequency, convert to a channel */
@@ -257,13 +255,13 @@ static int ks_wlan_get_freq(struct net_device *dev,
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	int f;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS)
 		f = (int)priv->current_ap.channel;
-	} else
+		else
 		f = (int)priv->reg.channel;
 	fwrq->m = frequency_list[f - 1] * 100000;
 	fwrq->e = 1;
@@ -283,9 +281,9 @@ static int ks_wlan_set_essid(struct net_device *dev,
 
 	DPRINTK(2, " %d\n", dwrq->flags);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 
 	/* for SLEEP MODE */
 	/* Check if we asked for `any' */
@@ -301,14 +299,14 @@ static int ks_wlan_set_essid(struct net_device *dev,
 			len--;
 
 		/* Check the size of the string */
-		if (len > IW_ESSID_MAX_SIZE) {
+		if (len > IW_ESSID_MAX_SIZE)
 			return -EINVAL;
-		}
+
 #else
 		/* Check the size of the string */
-		if (dwrq->length > IW_ESSID_MAX_SIZE + 1) {
+		if (dwrq->length > IW_ESSID_MAX_SIZE + 1)
 			return -E2BIG;
-		}
+
 #endif
 
 		/* Set the SSID */
@@ -340,9 +338,9 @@ static int ks_wlan_get_essid(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 
 	/* for SLEEP MODE */
 	/* Note : if dwrq->flags != 0, we should
@@ -385,17 +383,17 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 
 	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	if (priv->reg.operation_mode == MODE_ADHOC ||
 	    priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 		memcpy(priv->reg.bssid, (u8 *) & ap_addr->sa_data, ETH_ALEN);
 
-		if (is_valid_ether_addr((u8 *) priv->reg.bssid)) {
+		if (is_valid_ether_addr((u8 *) priv->reg.bssid))
 			priv->need_commit |= SME_MODE_SET;
-		}
+
 	} else {
 		eth_zero_addr(priv->reg.bssid);
 		return -EOPNOTSUPP;
@@ -421,15 +419,14 @@ static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
-	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS)
 		memcpy(awrq->sa_data, &(priv->current_ap.bssid[0]), ETH_ALEN);
-	} else {
+	else
 		eth_zero_addr(awrq->sa_data);
-	}
 
 	awrq->sa_family = ARPHRD_ETHER;
 
@@ -445,15 +442,14 @@ static int ks_wlan_set_nick(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 
 	/* for SLEEP MODE */
 	/* Check the size of the string */
-	if (dwrq->length > 16 + 1) {
+	if (dwrq->length > 16 + 1)
 		return -E2BIG;
-	}
+
 	memset(priv->nick, 0, sizeof(priv->nick));
 	memcpy(priv->nick, extra, dwrq->length);
 
@@ -469,9 +465,9 @@ static int ks_wlan_get_nick(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	strncpy(extra, priv->nick, 16);
 	extra[16] = '\0';
@@ -490,9 +486,9 @@ static int ks_wlan_set_rate(struct net_device *dev,
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	int i = 0;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	if (priv->reg.phy_type == D_11B_ONLY_MODE) {
 		if (vwrq->fixed == 1) {
@@ -727,13 +723,13 @@ static int ks_wlan_get_rate(struct net_device *dev,
 	DPRINTK(2, "in_interrupt = %ld update_phyinfo = %d\n",
 		in_interrupt(), atomic_read(&update_phyinfo));
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
-	if (!atomic_read(&update_phyinfo)) {
+	if (!atomic_read(&update_phyinfo))
 		ks_wlan_update_phy_information(priv);
-	}
+
 	vwrq->value = ((priv->current_rate) & RATE_MASK) * 500000;
 	if (priv->reg.tx_rate == TX_RATE_FIXED)
 		vwrq->fixed = 1;
@@ -752,15 +748,15 @@ static int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	int rthr = vwrq->value;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	if (vwrq->disabled)
 		rthr = 2347;
-	if ((rthr < 0) || (rthr > 2347)) {
+	if ((rthr < 0) || (rthr > 2347))
 		return -EINVAL;
-	}
+
 	priv->reg.rts = rthr;
 	priv->need_commit |= SME_RTS;
 
@@ -775,9 +771,9 @@ static int ks_wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	vwrq->value = priv->reg.rts;
 	vwrq->disabled = (vwrq->value >= 2347);
@@ -796,15 +792,15 @@ static int ks_wlan_set_frag(struct net_device *dev,
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	int fthr = vwrq->value;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	if (vwrq->disabled)
 		fthr = 2346;
-	if ((fthr < 256) || (fthr > 2346)) {
+	if ((fthr < 256) || (fthr > 2346))
 		return -EINVAL;
-	}
+
 	fthr &= ~0x1;	/* Get an even value - is it really needed ??? */
 	priv->reg.fragment = fthr;
 	priv->need_commit |= SME_FRAG;
@@ -821,9 +817,9 @@ static int ks_wlan_get_frag(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	vwrq->value = priv->reg.fragment;
 	vwrq->disabled = (vwrq->value >= 2346);
@@ -843,9 +839,9 @@ static int ks_wlan_set_mode(struct net_device *dev,
 
 	DPRINTK(2, "mode=%d\n", *uwrq);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	switch (*uwrq) {
 	case IW_MODE_ADHOC:
@@ -877,9 +873,8 @@ static int ks_wlan_get_mode(struct net_device *dev,
 	struct ks_wlan_private *priv =
 	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 
 	/* for SLEEP MODE */
 	/* If not managed, assume it's ad-hoc */
@@ -913,9 +908,8 @@ static int ks_wlan_set_encode(struct net_device *dev,
 
 	DPRINTK(2, "flags=%04X\n", dwrq->flags);
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 
 	/* for SLEEP MODE */
 	/* index check */
@@ -959,9 +953,9 @@ static int ks_wlan_set_encode(struct net_device *dev,
 			}
 			/* Send the key to the card */
 			priv->reg.wep_key[index].size = key.len;
-			for (i = 0; i < (priv->reg.wep_key[index].size); i++) {
+			for (i = 0; i < (priv->reg.wep_key[index].size); i++)
 				priv->reg.wep_key[index].val[i] = key.key[i];
-			}
+
 			priv->need_commit |= (SME_WEP_VAL1 << index);
 			priv->reg.wep_index = index;
 			priv->need_commit |= SME_WEP_INDEX;
@@ -973,9 +967,9 @@ static int ks_wlan_set_encode(struct net_device *dev,
 			priv->reg.wep_key[2].size = 0;
 			priv->reg.wep_key[3].size = 0;
 			priv->reg.privacy_invoked = 0x00;
-			if (priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY) {
+			if (priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY)
 				priv->need_commit |= SME_MODE_SET;
-			}
+
 			priv->reg.authenticate_type = AUTH_TYPE_OPEN_SYSTEM;
 			wep_on_off = WEP_OFF;
 			priv->need_commit |= SME_WEP_FLAG;
@@ -997,14 +991,14 @@ static int ks_wlan_set_encode(struct net_device *dev,
 		priv->need_commit |= SME_WEP_FLAG;
 
 	if (dwrq->flags & IW_ENCODE_OPEN) {
-		if (priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY) {
+		if (priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY)
 			priv->need_commit |= SME_MODE_SET;
-		}
+
 		priv->reg.authenticate_type = AUTH_TYPE_OPEN_SYSTEM;
 	} else if (dwrq->flags & IW_ENCODE_RESTRICTED) {
-		if (priv->reg.authenticate_type == AUTH_TYPE_OPEN_SYSTEM) {
+		if (priv->reg.authenticate_type == AUTH_TYPE_OPEN_SYSTEM)
 			priv->need_commit |= SME_MODE_SET;
-		}
+
 		priv->reg.authenticate_type = AUTH_TYPE_SHARED_KEY;
 	}
 //      return -EINPROGRESS;            /* Call commit handler */
@@ -1026,9 +1020,9 @@ static int ks_wlan_get_encode(struct net_device *dev,
 	char zeros[16];
 	int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	dwrq->flags = IW_ENCODE_DISABLED;
 
@@ -1056,9 +1050,8 @@ static int ks_wlan_get_encode(struct net_device *dev,
 	/* Copy the key to the user buffer */
 	if ((index >= 0) && (index < 4))
 		dwrq->length = priv->reg.wep_key[index].size;
-	if (dwrq->length > 16) {
+	if (dwrq->length > 16)
 		dwrq->length = 0;
-	}
 #if 1	/* IW_ENCODE_NOKEY; */
 	if (dwrq->length) {
 		if ((index >= 0) && (index < 4))
@@ -1086,9 +1079,8 @@ static int ks_wlan_get_txpow(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_param *vwrq, char *extra)
 {
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 
 	/* for SLEEP MODE */
 	/* Not Support */
@@ -1113,9 +1105,8 @@ static int ks_wlan_get_retry(struct net_device *dev,
 			     struct iw_request_info *info,
 			     struct iw_param *vwrq, char *extra)
 {
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
 
 	/* for SLEEP MODE */
 	/* Not Support */
@@ -1139,9 +1130,9 @@ static int ks_wlan_get_range(struct net_device *dev,
 
 	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	dwrq->length = sizeof(struct iw_range);
 	memset(range, 0, sizeof(*range));
@@ -1267,9 +1258,9 @@ static int ks_wlan_set_power(struct net_device *dev,
 	    (struct ks_wlan_private *)netdev_priv(dev);
 	short enabled;
 
-	if (priv->sleep_mode == SLP_SLEEP) {
+	if (priv->sleep_mode == SLP_SLEEP)
 		return -EPERM;
-	}
+
 	/* for SLEEP MODE */
 	enabled = vwrq->disabled ? 0 : 1;
 	if (enabled == 0) {	/* 0 */

commit 03806ab307c369b2598097a12c9ceed245f9ade0
Author: Georgiana Rodica Chelu <georgiana.chelu93@gmail.com>
Date:   Mon Sep 26 14:07:52 2016 +0300

    staging: ks7010: ks_wlan_net: Use netdev_info instead of printk
    
    Pass the net_device structure to print_hif_event function
    in order to use netdev_info instead of printk.
    
    Signed-off-by: Georgiana Rodica Chelu <georgiana.chelu93@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 4a14327cc20d..b2b4fa4c3834 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2973,117 +2973,117 @@ static int ks_wlan_get_eeprom_cksum(struct net_device *dev,
 	return 0;
 }
 
-static void print_hif_event(int event)
+static void print_hif_event(struct net_device *dev, int event)
 {
 
 	switch (event) {
 	case HIF_DATA_REQ:
-		printk("HIF_DATA_REQ\n");
+		netdev_info(dev, "HIF_DATA_REQ\n");
 		break;
 	case HIF_DATA_IND:
-		printk("HIF_DATA_IND\n");
+		netdev_info(dev, "HIF_DATA_IND\n");
 		break;
 	case HIF_MIB_GET_REQ:
-		printk("HIF_MIB_GET_REQ\n");
+		netdev_info(dev, "HIF_MIB_GET_REQ\n");
 		break;
 	case HIF_MIB_GET_CONF:
-		printk("HIF_MIB_GET_CONF\n");
+		netdev_info(dev, "HIF_MIB_GET_CONF\n");
 		break;
 	case HIF_MIB_SET_REQ:
-		printk("HIF_MIB_SET_REQ\n");
+		netdev_info(dev, "HIF_MIB_SET_REQ\n");
 		break;
 	case HIF_MIB_SET_CONF:
-		printk("HIF_MIB_SET_CONF\n");
+		netdev_info(dev, "HIF_MIB_SET_CONF\n");
 		break;
 	case HIF_POWERMGT_REQ:
-		printk("HIF_POWERMGT_REQ\n");
+		netdev_info(dev, "HIF_POWERMGT_REQ\n");
 		break;
 	case HIF_POWERMGT_CONF:
-		printk("HIF_POWERMGT_CONF\n");
+		netdev_info(dev, "HIF_POWERMGT_CONF\n");
 		break;
 	case HIF_START_REQ:
-		printk("HIF_START_REQ\n");
+		netdev_info(dev, "HIF_START_REQ\n");
 		break;
 	case HIF_START_CONF:
-		printk("HIF_START_CONF\n");
+		netdev_info(dev, "HIF_START_CONF\n");
 		break;
 	case HIF_CONNECT_IND:
-		printk("HIF_CONNECT_IND\n");
+		netdev_info(dev, "HIF_CONNECT_IND\n");
 		break;
 	case HIF_STOP_REQ:
-		printk("HIF_STOP_REQ\n");
+		netdev_info(dev, "HIF_STOP_REQ\n");
 		break;
 	case HIF_STOP_CONF:
-		printk("HIF_STOP_CONF\n");
+		netdev_info(dev, "HIF_STOP_CONF\n");
 		break;
 	case HIF_PS_ADH_SET_REQ:
-		printk("HIF_PS_ADH_SET_REQ\n");
+		netdev_info(dev, "HIF_PS_ADH_SET_REQ\n");
 		break;
 	case HIF_PS_ADH_SET_CONF:
-		printk("HIF_PS_ADH_SET_CONF\n");
+		netdev_info(dev, "HIF_PS_ADH_SET_CONF\n");
 		break;
 	case HIF_INFRA_SET_REQ:
-		printk("HIF_INFRA_SET_REQ\n");
+		netdev_info(dev, "HIF_INFRA_SET_REQ\n");
 		break;
 	case HIF_INFRA_SET_CONF:
-		printk("HIF_INFRA_SET_CONF\n");
+		netdev_info(dev, "HIF_INFRA_SET_CONF\n");
 		break;
 	case HIF_ADH_SET_REQ:
-		printk("HIF_ADH_SET_REQ\n");
+		netdev_info(dev, "HIF_ADH_SET_REQ\n");
 		break;
 	case HIF_ADH_SET_CONF:
-		printk("HIF_ADH_SET_CONF\n");
+		netdev_info(dev, "HIF_ADH_SET_CONF\n");
 		break;
 	case HIF_AP_SET_REQ:
-		printk("HIF_AP_SET_REQ\n");
+		netdev_info(dev, "HIF_AP_SET_REQ\n");
 		break;
 	case HIF_AP_SET_CONF:
-		printk("HIF_AP_SET_CONF\n");
+		netdev_info(dev, "HIF_AP_SET_CONF\n");
 		break;
 	case HIF_ASSOC_INFO_IND:
-		printk("HIF_ASSOC_INFO_IND\n");
+		netdev_info(dev, "HIF_ASSOC_INFO_IND\n");
 		break;
 	case HIF_MIC_FAILURE_REQ:
-		printk("HIF_MIC_FAILURE_REQ\n");
+		netdev_info(dev, "HIF_MIC_FAILURE_REQ\n");
 		break;
 	case HIF_MIC_FAILURE_CONF:
-		printk("HIF_MIC_FAILURE_CONF\n");
+		netdev_info(dev, "HIF_MIC_FAILURE_CONF\n");
 		break;
 	case HIF_SCAN_REQ:
-		printk("HIF_SCAN_REQ\n");
+		netdev_info(dev, "HIF_SCAN_REQ\n");
 		break;
 	case HIF_SCAN_CONF:
-		printk("HIF_SCAN_CONF\n");
+		netdev_info(dev, "HIF_SCAN_CONF\n");
 		break;
 	case HIF_PHY_INFO_REQ:
-		printk("HIF_PHY_INFO_REQ\n");
+		netdev_info(dev, "HIF_PHY_INFO_REQ\n");
 		break;
 	case HIF_PHY_INFO_CONF:
-		printk("HIF_PHY_INFO_CONF\n");
+		netdev_info(dev, "HIF_PHY_INFO_CONF\n");
 		break;
 	case HIF_SLEEP_REQ:
-		printk("HIF_SLEEP_REQ\n");
+		netdev_info(dev, "HIF_SLEEP_REQ\n");
 		break;
 	case HIF_SLEEP_CONF:
-		printk("HIF_SLEEP_CONF\n");
+		netdev_info(dev, "HIF_SLEEP_CONF\n");
 		break;
 	case HIF_PHY_INFO_IND:
-		printk("HIF_PHY_INFO_IND\n");
+		netdev_info(dev, "HIF_PHY_INFO_IND\n");
 		break;
 	case HIF_SCAN_IND:
-		printk("HIF_SCAN_IND\n");
+		netdev_info(dev, "HIF_SCAN_IND\n");
 		break;
 	case HIF_INFRA_SET2_REQ:
-		printk("HIF_INFRA_SET2_REQ\n");
+		netdev_info(dev, "HIF_INFRA_SET2_REQ\n");
 		break;
 	case HIF_INFRA_SET2_CONF:
-		printk("HIF_INFRA_SET2_CONF\n");
+		netdev_info(dev, "HIF_INFRA_SET2_CONF\n");
 		break;
 	case HIF_ADH_SET2_REQ:
-		printk("HIF_ADH_SET2_REQ\n");
+		netdev_info(dev, "HIF_ADH_SET2_REQ\n");
 		break;
 	case HIF_ADH_SET2_CONF:
-		printk("HIF_ADH_SET2_CONF\n");
+		netdev_info(dev, "HIF_ADH_SET2_CONF\n");
 	}
 }
 
@@ -3100,7 +3100,7 @@ static int ks_wlan_hostt(struct net_device *dev, struct iw_request_info *info,
 		event =
 		    priv->hostt.buff[(priv->hostt.qtail - 1 - i) %
 				     SME_EVENT_BUFF_SIZE];
-		print_hif_event(event);
+		print_hif_event(dev, event);
 	}
 	return 0;
 }

commit c8be6461054c8c1f536e3085b15b539c1a9c4c7e
Author: Georgiana Rodica Chelu <georgiana.chelu93@gmail.com>
Date:   Mon Sep 26 11:15:56 2016 +0300

    staging: ks7010: ks_wlan_net: Use netdev_ instead of printk
    
    The checkpatch.pl script found the following warning:
    
    WARNING: printk() should include KERN_ facility level
    
    After adding the KERN_ facility level to printk(), the script showed
    another warning:
    
    WARNING: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then
    dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
    
    The warning is similar for KERN_ERR and KERN_DEBUG. In conclusion,
    use netdev_info(), netdev_err() or netdev_dbg() when there is
    a netdev device.
    
    Signed-off-by: Georgiana Rodica Chelu <georgiana.chelu93@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 9e2bdd6f1ded..4a14327cc20d 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -233,9 +233,9 @@ static int ks_wlan_set_freq(struct net_device *dev,
 		/* We should do a better check than that,
 		 * based on the card capability !!! */
 		if ((channel < 1) || (channel > 14)) {
-			printk(KERN_DEBUG
-			       "%s: New channel value of %d is invalid!\n",
-			       dev->name, fwrq->m);
+			netdev_dbg(dev,
+				   "%s: New channel value of %d is invalid!\n",
+				   dev->name, fwrq->m);
 			rc = -EINVAL;
 		} else {
 			/* Yes ! We can set it !!! */
@@ -2671,17 +2671,17 @@ static int ks_wlan_set_sleep_mode(struct net_device *dev,
 
 	if (*uwrq == SLP_SLEEP) {
 		priv->sleep_mode = *uwrq;
-		printk("SET_SLEEP_MODE %d\n", priv->sleep_mode);
+		netdev_info(dev, "SET_SLEEP_MODE %d\n", priv->sleep_mode);
 
 		hostif_sme_enqueue(priv, SME_STOP_REQUEST);
 		hostif_sme_enqueue(priv, SME_SLEEP_REQUEST);
 
 	} else if (*uwrq == SLP_ACTIVE) {
 		priv->sleep_mode = *uwrq;
-		printk("SET_SLEEP_MODE %d\n", priv->sleep_mode);
+		netdev_info(dev, "SET_SLEEP_MODE %d\n", priv->sleep_mode);
 		hostif_sme_enqueue(priv, SME_SLEEP_REQUEST);
 	} else {
-		printk("SET_SLEEP_MODE %d errror\n", *uwrq);
+		netdev_err(dev, "SET_SLEEP_MODE %d errror\n", *uwrq);
 		return -EINVAL;
 	}
 
@@ -2783,7 +2783,7 @@ static int ks_wlan_get_wps_enable(struct net_device *dev,
 	}
 	/* for SLEEP MODE */
 	*uwrq = priv->wps.wps_enabled;
-	printk("return=%d\n", *uwrq);
+	netdev_info(dev, "return=%d\n", *uwrq);
 
 	return 0;
 }
@@ -3330,7 +3330,7 @@ int ks_wlan_set_mac_address(struct net_device *dev, void *addr)
 
 	priv->mac_address_valid = 0;
 	hostif_sme_enqueue(priv, SME_MACADDRESS_SET_REQUEST);
-	printk(KERN_INFO
+	netdev_info(dev,
 	       "ks_wlan: MAC ADDRESS = %02x:%02x:%02x:%02x:%02x:%02x\n",
 	       priv->eth_addr[0], priv->eth_addr[1], priv->eth_addr[2],
 	       priv->eth_addr[3], priv->eth_addr[4], priv->eth_addr[5]);
@@ -3360,7 +3360,7 @@ int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	DPRINTK(3, "in_interrupt()=%ld\n", in_interrupt());
 
 	if (!skb) {
-		printk(KERN_ERR "ks_wlan:  skb == NULL!!!\n");
+		netdev_err(dev, "ks_wlan:  skb == NULL!!!\n");
 		return 0;
 	}
 	if (priv->dev_state < DEVICE_STATE_READY) {
@@ -3424,7 +3424,7 @@ int ks_wlan_open(struct net_device *dev)
 	priv->cur_rx = 0;
 
 	if (!priv->mac_address_valid) {
-		printk(KERN_ERR "ks_wlan : %s Not READY !!\n", dev->name);
+		netdev_err(dev, "ks_wlan : %s Not READY !!\n", dev->name);
 		return -EBUSY;
 	} else
 		netif_start_queue(dev);

commit 7a4abee97f2a158e73746fd67b2c84454ac2194b
Author: Georgiana Rodica Chelu <georgiana.chelu93@gmail.com>
Date:   Sat Sep 24 22:49:02 2016 +0300

    staging: ks7010: ks_wlan_net: Remove return statement from void function
    
    Remove the return statement from the end of a void function
    to clean up the code.
    
    Issue found by checkpatch.pl script.
    
    Signed-off-by: Georgiana Rodica Chelu <georgiana.chelu93@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index d13a06bf4f6b..9e2bdd6f1ded 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -3349,8 +3349,6 @@ void ks_wlan_tx_timeout(struct net_device *dev)
 	}
 	priv->nstats.tx_errors++;
 	netif_wake_queue(dev);
-
-	return;
 }
 
 static
@@ -3416,8 +3414,6 @@ void ks_wlan_set_multicast_list(struct net_device *dev)
 		return;	/* not finished initialize */
 	}
 	hostif_sme_enqueue(priv, SME_MULTICAST_REQUEST);
-
-	return;
 }
 
 static

commit 55adb7bf5a3e466b471eae8db8334f1196c3a2f8
Author: Georgiana Rodica Chelu <georgiana.chelu93@gmail.com>
Date:   Fri Sep 23 22:45:25 2016 +0300

    staging: ks7010: ks_wlan_net: Remove unnecessary variable used to store return value
    
    Remove unneeded code in order to make clear
    that the function returns 0(success) in all cases.
    
    Done using returnvar.cocci script.
    
    Signed-off-by: Georgiana Rodica Chelu <georgiana.chelu93@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index f1cd90e9c752..d13a06bf4f6b 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -3507,12 +3507,11 @@ int ks_wlan_net_stop(struct net_device *dev)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	int ret = 0;
 	priv->device_open_status = 0;
 	del_timer_sync(&update_phyinfo_timer);
 
 	if (netif_running(dev))
 		netif_stop_queue(dev);
 
-	return ret;
+	return 0;
 }

commit e4e8d968a319a311908b2dd8f241442b5c529b5f
Author: Baoyou Xie <baoyou.xie@linaro.org>
Date:   Fri Sep 23 21:21:33 2016 +0800

    Staging: ks7010: remove unused function in ks_wlan_net.c
    
    We get 1 warning when building kernel with W=1:
    drivers/staging/ks7010/ks_wlan_net.c:3520:5: warning: no previous prototype for 'ks_wlan_reset' [-Wmissing-prototypes]
    
    In fact, these functions are unused in
    ks_wlan_net.c, but should be removed.
    
    So this patch removes the unused function.
    
    Signed-off-by: Baoyou Xie <baoyou.xie@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index ee9c8f3828cf..f1cd90e9c752 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -3516,8 +3516,3 @@ int ks_wlan_net_stop(struct net_device *dev)
 
 	return ret;
 }
-
-int ks_wlan_reset(struct net_device *dev)
-{
-	return 0;
-}

commit 2751bc918e61a114704f2a6673d316a38878319d
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Sep 17 13:09:13 2016 +0530

    Staging: ks7010: Remove extern keyword from function declaration
    
    Remove extern specifier from function declaration as they have
    it by default. Also move extern declaration from .c files to
    their respective header file 'ks_hostif.h'. Coccinelle was used
    to remove extern and other changes were done by hand.
    Script:
    @@
    identifier func;
    type T;
    @@
    - extern
    T func(...);
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 70cc9bee96c1..ee9c8f3828cf 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -69,10 +69,6 @@ static const struct iw_handler_def ks_wlan_handler_def;
 /*
  *	function prototypes
  */
-extern int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p,
-			 unsigned long size,
-			 void (*complete_handler) (void *arg1, void *arg2),
-			 void *arg1, void *arg2);
 static int ks_wlan_open(struct net_device *dev);
 static void ks_wlan_tx_timeout(struct net_device *dev);
 static int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev);

commit 30b48e2dbe7f4d78fb8f7abbef9851ec36a93dff
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Fri Sep 16 19:54:37 2016 +0530

    Staging: ks7010: Replace memset with eth_zero_addr
    
    Use eth_zero_addr to assign zero address to the given address array
    instead of memset when the second argument in memset is address
    of zero. Coccinelle was used to do the replacement and add the
    header file linux/etherdevice.h if not already present.
    Script:
    @header@
    @@
    #include <linux/etherdevice.h>
    
    @r1@
    expression e;
    @@
    
    -memset(e,0,ETH_ALEN);
    +eth_zero_addr(e);
    
    @includeheader depends on r1 && !header@
    @@
    + #include <linux/etherdevice.h>
    #include <...>
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index c17c45d66a3f..70cc9bee96c1 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -401,7 +401,7 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 			priv->need_commit |= SME_MODE_SET;
 		}
 	} else {
-		memset(priv->reg.bssid, 0x0, ETH_ALEN);
+		eth_zero_addr(priv->reg.bssid);
 		return -EOPNOTSUPP;
 	}
 
@@ -432,7 +432,7 @@ static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
 		memcpy(awrq->sa_data, &(priv->current_ap.bssid[0]), ETH_ALEN);
 	} else {
-		memset(awrq->sa_data, 0, ETH_ALEN);
+		eth_zero_addr(awrq->sa_data);
 	}
 
 	awrq->sa_family = ARPHRD_ETHER;
@@ -2091,7 +2091,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev,
 			list_for_each(ptr, &priv->pmklist.head) {
 				pmk = list_entry(ptr, struct pmk_t, list);
 				if (!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)) {	/* match address! list del. */
-					memset(pmk->bssid, 0, ETH_ALEN);
+					eth_zero_addr(pmk->bssid);
 					memset(pmk->pmkid, 0, IW_PMKID_LEN);
 					list_del_init(&pmk->list);
 					break;

commit e30ed33d197ccabfb7b46a6b1354a2fdfb546c8f
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Thu Sep 15 10:13:04 2016 +0000

    staging: ks7010: remove unused including <linux/version.h>
    
    Remove including <linux/version.h> that don't need it.
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index a35325ed26fc..c17c45d66a3f 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -9,7 +9,6 @@
  *   published by the Free Software Foundation.
  */
 
-#include <linux/version.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/compiler.h>

commit c7e65f4d2f7968de8605ef1b83ac1019e8e51d22
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Tue Sep 13 02:47:28 2016 +0530

    staging: ks7010: Remove the explicit NULL comparison
    
    The patch removes the explicit null comparisons entirely for the ks7010 driver.
    This was detected by checkpatch.pl
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index d69b4c945d21..a35325ed26fc 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -3366,7 +3366,7 @@ int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	DPRINTK(3, "in_interrupt()=%ld\n", in_interrupt());
 
-	if (skb == NULL) {
+	if (!skb) {
 		printk(KERN_ERR "ks_wlan:  skb == NULL!!!\n");
 		return 0;
 	}

commit 8defffb20854500825162d336bdd183d2d218cf9
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Sep 7 17:23:09 2016 +0100

    staging: ks7010: avoid dereferencing packet if it is null
    
    Updating tx_bytes from packet->len if packet is null will cause
    a null pointer dereference, so only update tx_bytes if it packet
    is not null.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 1e21eb1c4667..d69b4c945d21 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -3396,13 +3396,13 @@ void send_packet_complete(void *arg1, void *arg2)
 
 	DPRINTK(3, "\n");
 
-	priv->nstats.tx_bytes += packet->len;
 	priv->nstats.tx_packets++;
 
 	if (netif_queue_stopped(priv->net_dev))
 		netif_wake_queue(priv->net_dev);
 
 	if (packet) {
+		priv->nstats.tx_bytes += packet->len;
 		dev_kfree_skb(packet);
 		packet = NULL;
 	}

commit 453e102db531ac1ffa55f3e03c4907c063125859
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 14 14:17:02 2016 +0300

    staging: ks7010: remove bogus NULL checks
    
    enc->rx_seq[] and enc->key[] are arrays, not pointers and they can't be
    NULL.  Let's remove these NULL checks.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 26dbb75da826..1e21eb1c4667 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1910,11 +1910,8 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 			priv->wpa.txkey = index;
 			commit |= SME_WEP_INDEX;
 		} else if (enc->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
-			if (enc->rx_seq)
-				memcpy(&priv->wpa.key[index].rx_seq[0],
-				       enc->rx_seq, IW_ENCODE_SEQ_MAX_SIZE);
-			else
-				return -EINVAL;
+			memcpy(&priv->wpa.key[index].rx_seq[0],
+			       enc->rx_seq, IW_ENCODE_SEQ_MAX_SIZE);
 		}
 
 		memcpy(&priv->wpa.key[index].addr.sa_data[0],
@@ -1935,7 +1932,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 				priv->reg.privacy_invoked = 0x01;
 				commit |= SME_WEP_FLAG;
 			}
-			if (enc->key && enc->key_len) {
+			if (enc->key_len) {
 				memcpy(&priv->wpa.key[index].key_val[0],
 				       &enc->key[0], enc->key_len);
 				priv->wpa.key[index].key_len = enc->key_len;
@@ -1947,7 +1944,7 @@ static int ks_wlan_set_encode_ext(struct net_device *dev,
 				priv->reg.privacy_invoked = 0x01;
 				commit |= SME_WEP_FLAG;
 			}
-			if (enc->key && enc->key_len == 32) {
+			if (enc->key_len == 32) {
 				memcpy(&priv->wpa.key[index].key_val[0],
 				       &enc->key[0], enc->key_len - 16);
 				priv->wpa.key[index].key_len =

commit 516a4f04a39712cdb0d3cee263158853603376aa
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri Jun 17 10:47:00 2016 +0200

    staging: ks7010: drop private handler for driver version
    
    We are upstream now, we don't need seperate driver versioning.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 8ef0f111cf39..26dbb75da826 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -2198,17 +2198,6 @@ static int ks_wlan_set_mlme(struct net_device *dev,
 	}
 }
 
-/*------------------------------------------------------------------*/
-/* Private handler : get driver version */
-static int ks_wlan_get_driver_version(struct net_device *dev,
-				      struct iw_request_info *info,
-				      struct iw_point *dwrq, char *extra)
-{
-	strcpy(extra, KS_WLAN_DRIVER_VERSION_INFO);
-	dwrq->length = strlen(KS_WLAN_DRIVER_VERSION_INFO) + 1;
-	return 0;
-}
-
 /*------------------------------------------------------------------*/
 /* Private handler : get firemware version */
 static int ks_wlan_get_firmware_version(struct net_device *dev,
@@ -3128,8 +3117,6 @@ static int ks_wlan_hostt(struct net_device *dev, struct iw_request_info *info,
 
 static const struct iw_priv_args ks_wlan_private_args[] = {
 /*{ cmd, set_args, get_args, name[16] } */
-	{KS_WLAN_GET_DRIVER_VERSION, IW_PRIV_TYPE_NONE,
-	 IW_PRIV_TYPE_CHAR | (128 + 1), "GetDriverVer"},
 	{KS_WLAN_GET_FIRM_VERSION, IW_PRIV_TYPE_NONE,
 	 IW_PRIV_TYPE_CHAR | (128 + 1), "GetFirmwareVer"},
 #ifdef WPS
@@ -3258,7 +3245,7 @@ static const iw_handler ks_wlan_handler[] = {
 /* private_handler */
 static const iw_handler ks_wlan_private_handler[] = {
 	(iw_handler) NULL,	/*  0 */
-	(iw_handler) ks_wlan_get_driver_version,	/*  1 KS_WLAN_GET_DRIVER_VERSION */
+	(iw_handler) NULL,	/*  1, used to be: KS_WLAN_GET_DRIVER_VERSION */
 	(iw_handler) NULL,	/*  2 */
 	(iw_handler) ks_wlan_get_firmware_version,	/*  3 KS_WLAN_GET_FIRM_VERSION */
 #ifdef WPS

commit c5d9a03031a645a8c63fdaa6a650113f8bd55b2b
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:43 2016 +0200

    staging: ks7010: cleanup file headers
    
    Remove svn-ids and fix typos in the licence declaration. Add my
    copyright to the sdio code which I worked on mainly.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index ac3354bf6f8c..8ef0f111cf39 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -1,15 +1,12 @@
 /*
  *   Driver for KeyStream 11b/g wireless LAN
  *
- *   ks_wlan_net.c
- *   $Id: ks_wlan_net.c 1020 2009-09-28 05:48:31Z sekine $
- *
  *   Copyright (C) 2005-2008 KeyStream Corp.
  *   Copyright (C) 2009 Renesas Technology Corp.
  *
  *   This program is free software; you can redistribute it and/or modify
- *   it undr the terms of the GNU General Public License version 2 as
- *   published by the Free Sotware Foundation.
+ *   it under the terms of the GNU General Public License version 2 as
+ *   published by the Free Software Foundation.
  */
 
 #include <linux/version.h>

commit 4e66308e7dc43e15237cedb4079b830858a597aa
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:40 2016 +0200

    staging: ks7010: adapt to new trans_start handling
    
    trans_start is gone from netdevice, so use the new helper function to
    set the mark.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 3e2828333723..ac3354bf6f8c 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -3398,7 +3398,7 @@ int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		netif_stop_queue(dev);
 
 	rc = hostif_data_request(priv, skb);
-	dev->trans_start = jiffies;
+	netif_trans_update(dev);
 
 	DPRINTK(4, "rc=%d\n", rc);
 	if (rc) {

commit 1df655478eeb909192bd6f2eafe62d46d83a25e0
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:34 2016 +0200

    staging: ks7010: indent ks_wlan_net.c
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index ec5c452f3672..3e2828333723 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -43,62 +43,63 @@ static int wep_on_off;
 
 /* Include Wireless Extension definition and check version */
 #include <linux/wireless.h>
-#define WIRELESS_SPY		/* enable iwspy support */
+#define WIRELESS_SPY	/* enable iwspy support */
 #include <net/iw_handler.h>	/* New driver API */
 
 /* Frequency list (map channels to frequencies) */
 static const long frequency_list[] = { 2412, 2417, 2422, 2427, 2432, 2437, 2442,
-				       2447, 2452, 2457, 2462, 2467, 2472, 2484 };
+	2447, 2452, 2457, 2462, 2467, 2472, 2484
+};
 
 /* A few details needed for WEP (Wireless Equivalent Privacy) */
 #define MAX_KEY_SIZE 13	/* 128 (?) bits */
 #define MIN_KEY_SIZE  5	/* 40 bits RC4 - WEP */
 typedef struct wep_key_t {
-	u16	len;
-	u8	key[16]; /* 40-bit and 104-bit keys */
+	u16 len;
+	u8 key[16];	/* 40-bit and 104-bit keys */
 } wep_key_t;
 
 /* Backward compatibility */
 #ifndef IW_ENCODE_NOKEY
-#define IW_ENCODE_NOKEY 0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_NOKEY 0x0800	/* Key is write only, so not present */
 #define IW_ENCODE_MODE  (IW_ENCODE_DISABLED | IW_ENCODE_RESTRICTED | IW_ENCODE_OPEN)
 #endif /* IW_ENCODE_NOKEY */
 
 /* List of Wireless Handlers (new API) */
-static const struct iw_handler_def	ks_wlan_handler_def;
-
-#define KSC_OPNOTSUPP /* Operation Not Support*/
+static const struct iw_handler_def ks_wlan_handler_def;
 
+#define KSC_OPNOTSUPP	/* Operation Not Support */
 
 /*
  *	function prototypes
  */
-extern int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
-			void (*complete_handler)(void *arg1, void *arg2),
-			void *arg1,
-			void *arg2 );
-static int ks_wlan_open (struct net_device *dev);
-static void ks_wlan_tx_timeout (struct net_device *dev);
-static int ks_wlan_start_xmit (struct sk_buff *skb, struct net_device *dev);
-static int ks_wlan_close (struct net_device *dev);
-static void ks_wlan_set_multicast_list (struct net_device *dev);
-static struct net_device_stats *ks_wlan_get_stats (struct net_device *dev);
+extern int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p,
+			 unsigned long size,
+			 void (*complete_handler) (void *arg1, void *arg2),
+			 void *arg1, void *arg2);
+static int ks_wlan_open(struct net_device *dev);
+static void ks_wlan_tx_timeout(struct net_device *dev);
+static int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev);
+static int ks_wlan_close(struct net_device *dev);
+static void ks_wlan_set_multicast_list(struct net_device *dev);
+static struct net_device_stats *ks_wlan_get_stats(struct net_device *dev);
 static int ks_wlan_set_mac_address(struct net_device *dev, void *addr);
-static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq,
+				int cmd);
 
 static atomic_t update_phyinfo;
 static struct timer_list update_phyinfo_timer;
 static
 int ks_wlan_update_phy_information(struct ks_wlan_private *priv)
 {
-		struct iw_statistics *wstats = &priv->wstats;
+	struct iw_statistics *wstats = &priv->wstats;
 
 	DPRINTK(4, "in_interrupt = %ld\n", in_interrupt());
 
 	if (priv->dev_state < DEVICE_STATE_READY) {
-				return -1; /* not finished initialize */
-		}
-	if(atomic_read(&update_phyinfo))
+		return -1;	/* not finished initialize */
+	}
+	if (atomic_read(&update_phyinfo))
 		return 1;
 
 	/* The status */
@@ -108,12 +109,13 @@ int ks_wlan_update_phy_information(struct ks_wlan_private *priv)
 	hostif_sme_enqueue(priv, SME_PHY_INFO_REQUEST);
 
 	/* interruptible_sleep_on_timeout(&priv->confirm_wait, HZ/2); */
-	if(!wait_for_completion_interruptible_timeout(&priv->confirm_wait,HZ/2)){
-		DPRINTK(1,"wait time out!!\n");
+	if (!wait_for_completion_interruptible_timeout
+	    (&priv->confirm_wait, HZ / 2)) {
+		DPRINTK(1, "wait time out!!\n");
 	}
 
 	atomic_inc(&update_phyinfo);
-	update_phyinfo_timer.expires = jiffies + HZ; /* 1sec */
+	update_phyinfo_timer.expires = jiffies + HZ;	/* 1sec */
 	add_timer(&update_phyinfo_timer);
 
 	return 0;
@@ -123,42 +125,43 @@ static
 void ks_wlan_update_phyinfo_timeout(unsigned long ptr)
 {
 	DPRINTK(4, "in_interrupt = %ld\n", in_interrupt());
-	atomic_set(&update_phyinfo,0);
+	atomic_set(&update_phyinfo, 0);
 }
 
-int ks_wlan_setup_parameter(struct ks_wlan_private *priv, unsigned int commit_flag)
+int ks_wlan_setup_parameter(struct ks_wlan_private *priv,
+			    unsigned int commit_flag)
 {
-	DPRINTK(2,"\n");
+	DPRINTK(2, "\n");
 
 	hostif_sme_enqueue(priv, SME_STOP_REQUEST);
 
-	if(commit_flag & SME_RTS)
+	if (commit_flag & SME_RTS)
 		hostif_sme_enqueue(priv, SME_RTS_THRESHOLD_REQUEST);
-	if(commit_flag & SME_FRAG)
+	if (commit_flag & SME_FRAG)
 		hostif_sme_enqueue(priv, SME_FRAGMENTATION_THRESHOLD_REQUEST);
 
-	if(commit_flag & SME_WEP_INDEX)
+	if (commit_flag & SME_WEP_INDEX)
 		hostif_sme_enqueue(priv, SME_WEP_INDEX_REQUEST);
-	if(commit_flag & SME_WEP_VAL1)
+	if (commit_flag & SME_WEP_VAL1)
 		hostif_sme_enqueue(priv, SME_WEP_KEY1_REQUEST);
-	if(commit_flag & SME_WEP_VAL2)
+	if (commit_flag & SME_WEP_VAL2)
 		hostif_sme_enqueue(priv, SME_WEP_KEY2_REQUEST);
-	if(commit_flag & SME_WEP_VAL3)
+	if (commit_flag & SME_WEP_VAL3)
 		hostif_sme_enqueue(priv, SME_WEP_KEY3_REQUEST);
-	if(commit_flag & SME_WEP_VAL4)
+	if (commit_flag & SME_WEP_VAL4)
 		hostif_sme_enqueue(priv, SME_WEP_KEY4_REQUEST);
-	if(commit_flag & SME_WEP_FLAG)
+	if (commit_flag & SME_WEP_FLAG)
 		hostif_sme_enqueue(priv, SME_WEP_FLAG_REQUEST);
 
-	if(commit_flag & SME_RSN){
+	if (commit_flag & SME_RSN) {
 		hostif_sme_enqueue(priv, SME_RSN_ENABLED_REQUEST);
 		hostif_sme_enqueue(priv, SME_RSN_MODE_REQUEST);
 	}
-	if(commit_flag & SME_RSN_MULTICAST)
+	if (commit_flag & SME_RSN_MULTICAST)
 		hostif_sme_enqueue(priv, SME_RSN_MCAST_REQUEST);
-	if(commit_flag & SME_RSN_UNICAST)
+	if (commit_flag & SME_RSN_UNICAST)
 		hostif_sme_enqueue(priv, SME_RSN_UCAST_REQUEST);
-	if(commit_flag & SME_RSN_AUTH)
+	if (commit_flag & SME_RSN_AUTH)
 		hostif_sme_enqueue(priv, SME_RSN_AUTH_REQUEST);
 
 	hostif_sme_enqueue(priv, SME_MODE_SET_REQUEST);
@@ -180,23 +183,24 @@ int ks_wlan_setup_parameter(struct ks_wlan_private *priv, unsigned int commit_fl
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get protocol name */
-static int ks_wlan_get_name(struct net_device *dev, struct iw_request_info *info,
-				char *cwrq, char *extra)
+static int ks_wlan_get_name(struct net_device *dev,
+			    struct iw_request_info *info, char *cwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *) netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	if (priv->dev_state < DEVICE_STATE_READY) {
 		strcpy(cwrq, "NOT READY!");
-		}
-	else if(priv->reg.phy_type == D_11B_ONLY_MODE){
+	} else if (priv->reg.phy_type == D_11B_ONLY_MODE) {
 		strcpy(cwrq, "IEEE 802.11b");
-	}
-	else if(priv->reg.phy_type == D_11G_ONLY_MODE){
+	} else if (priv->reg.phy_type == D_11G_ONLY_MODE) {
 		strcpy(cwrq, "IEEE 802.11g");
-	}
-	else {
+	} else {
 		strcpy(cwrq, "IEEE 802.11b/g");
 	}
 
@@ -205,39 +209,45 @@ static int ks_wlan_get_name(struct net_device *dev, struct iw_request_info *info
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set frequency */
-static int ks_wlan_set_freq(struct net_device *dev, struct iw_request_info *info,
-				struct iw_freq *fwrq, char *extra)
+static int ks_wlan_set_freq(struct net_device *dev,
+			    struct iw_request_info *info, struct iw_freq *fwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-	int rc = -EINPROGRESS;		/* Call commit handler */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
+	int rc = -EINPROGRESS;	/* Call commit handler */
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
 
+	/* for SLEEP MODE */
 	/* If setting by frequency, convert to a channel */
-	if((fwrq->e == 1) &&
-	   (fwrq->m >= (int) 2.412e8) &&
-	   (fwrq->m <= (int) 2.487e8)) {
+	if ((fwrq->e == 1) &&
+	    (fwrq->m >= (int)2.412e8) && (fwrq->m <= (int)2.487e8)) {
 		int f = fwrq->m / 100000;
 		int c = 0;
-		while((c < 14) && (f != frequency_list[c]))
+		while ((c < 14) && (f != frequency_list[c]))
 			c++;
 		/* Hack to fall through... */
 		fwrq->e = 0;
 		fwrq->m = c + 1;
 	}
 	/* Setting by channel number */
-	if((fwrq->m > 1000) || (fwrq->e > 0))
+	if ((fwrq->m > 1000) || (fwrq->e > 0))
 		rc = -EOPNOTSUPP;
 	else {
 		int channel = fwrq->m;
 		/* We should do a better check than that,
 		 * based on the card capability !!! */
-		if((channel < 1) || (channel > 14)) {
-			printk(KERN_DEBUG "%s: New channel value of %d is invalid!\n", dev->name, fwrq->m);
+		if ((channel < 1) || (channel > 14)) {
+			printk(KERN_DEBUG
+			       "%s: New channel value of %d is invalid!\n",
+			       dev->name, fwrq->m);
 			rc = -EINVAL;
 		} else {
 			/* Yes ! We can set it !!! */
-			priv->reg.channel = (u8)(channel);
+			priv->reg.channel = (u8) (channel);
 			priv->need_commit |= SME_MODE_SET;
 		}
 	}
@@ -247,20 +257,23 @@ static int ks_wlan_set_freq(struct net_device *dev, struct iw_request_info *info
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get frequency */
-static int ks_wlan_get_freq(struct net_device *dev, struct iw_request_info *info,
-				struct iw_freq *fwrq, char *extra)
+static int ks_wlan_get_freq(struct net_device *dev,
+			    struct iw_request_info *info, struct iw_freq *fwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	int f;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS){
-		f = (int)priv->current_ap.channel;
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
 	}
-	else
+	/* for SLEEP MODE */
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
+		f = (int)priv->current_ap.channel;
+	} else
 		f = (int)priv->reg.channel;
-	fwrq->m = frequency_list[f-1] * 100000;
+	fwrq->m = frequency_list[f - 1] * 100000;
 	fwrq->e = 1;
 
 	return 0;
@@ -268,18 +281,23 @@ static int ks_wlan_get_freq(struct net_device *dev, struct iw_request_info *info
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set ESSID */
-static int ks_wlan_set_essid(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_point *dwrq, char *extra)
+static int ks_wlan_set_essid(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	size_t len;
 
-	DPRINTK(2," %d\n", dwrq->flags);
+	DPRINTK(2, " %d\n", dwrq->flags);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
 
+	/* for SLEEP MODE */
 	/* Check if we asked for `any' */
-	if(dwrq->flags == 0) {
+	if (dwrq->flags == 0) {
 		/* Just send an empty SSID list */
 		memset(priv->reg.ssid.body, 0, sizeof(priv->reg.ssid.body));
 		priv->reg.ssid.size = 0;
@@ -291,13 +309,13 @@ static int ks_wlan_set_essid(struct net_device *dev, struct iw_request_info *inf
 			len--;
 
 		/* Check the size of the string */
-		if(len > IW_ESSID_MAX_SIZE) {
+		if (len > IW_ESSID_MAX_SIZE) {
 			return -EINVAL;
 		}
 #else
 		/* Check the size of the string */
-		if(dwrq->length > IW_ESSID_MAX_SIZE+1) {
-			return -E2BIG ;
+		if (dwrq->length > IW_ESSID_MAX_SIZE + 1) {
+			return -E2BIG;
 		}
 #endif
 
@@ -315,25 +333,29 @@ static int ks_wlan_set_essid(struct net_device *dev, struct iw_request_info *inf
 	/* Write it to the card */
 	priv->need_commit |= SME_MODE_SET;
 
-//	return  -EINPROGRESS;	/* Call commit handler */
+//      return  -EINPROGRESS;   /* Call commit handler */
 	ks_wlan_setup_parameter(priv, priv->need_commit);
-	priv->need_commit=0;
-	return  0;
+	priv->need_commit = 0;
+	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get ESSID */
-static int ks_wlan_get_essid(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_point *dwrq, char *extra)
+static int ks_wlan_get_essid(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
 
+	/* for SLEEP MODE */
 	/* Note : if dwrq->flags != 0, we should
 	 * get the relevant SSID from the SSID list... */
-
-	if(priv->reg.ssid.size){
+	if (priv->reg.ssid.size) {
 		/* Get the current SSID */
 		memcpy(extra, priv->reg.ssid.body, priv->reg.ssid.size);
 #if 0
@@ -345,17 +367,17 @@ static int ks_wlan_get_essid(struct net_device *dev, struct iw_request_info *inf
 #if 1
 		dwrq->length = priv->reg.ssid.size;
 #else
-		dwrq->length = priv->reg.ssid.size+1;
+		dwrq->length = priv->reg.ssid.size + 1;
 #endif
-		dwrq->flags = 1; /* active */
-	}else{
+		dwrq->flags = 1;	/* active */
+	} else {
 #if 1
 		dwrq->length = 0;
 #else
 		extra[0] = '\0';
 		dwrq->length = 1;
 #endif
-		dwrq->flags = 0; /* ANY */
+		dwrq->flags = 0;	/* ANY */
 	}
 
 	return 0;
@@ -366,33 +388,35 @@ static int ks_wlan_get_essid(struct net_device *dev, struct iw_request_info *inf
 static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 			   struct sockaddr *ap_addr, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	DPRINTK(2,"\n");
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	DPRINTK(2, "\n");
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	if (priv->reg.operation_mode == MODE_ADHOC ||
-		priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
-		memcpy(priv->reg.bssid, (u8 *)&ap_addr->sa_data, ETH_ALEN);
+	    priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
+		memcpy(priv->reg.bssid, (u8 *) & ap_addr->sa_data, ETH_ALEN);
 
-		if (is_valid_ether_addr((u8 *)priv->reg.bssid)) {
+		if (is_valid_ether_addr((u8 *) priv->reg.bssid)) {
 			priv->need_commit |= SME_MODE_SET;
 		}
-	}
-	else {
+	} else {
 		memset(priv->reg.bssid, 0x0, ETH_ALEN);
 		return -EOPNOTSUPP;
 	}
 
 	DPRINTK(2, "bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
-			   priv->reg.bssid[0],priv->reg.bssid[1],priv->reg.bssid[2],
-			   priv->reg.bssid[3],priv->reg.bssid[4],priv->reg.bssid[5]);
+		priv->reg.bssid[0], priv->reg.bssid[1], priv->reg.bssid[2],
+		priv->reg.bssid[3], priv->reg.bssid[4], priv->reg.bssid[5]);
 
 	/* Write it to the card */
 	if (priv->need_commit) {
 		priv->need_commit |= SME_MODE_SET;
-		return  -EINPROGRESS;	/* Call commit handler */
+		return -EINPROGRESS;	/* Call commit handler */
 	}
 	return 0;
 }
@@ -402,14 +426,16 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 			   struct sockaddr *awrq, char *extra)
 {
-		struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS){
-		memcpy(awrq->sa_data, &(priv->current_ap.bssid[0]), ETH_ALEN);
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
 	}
-	else{
+	/* for SLEEP MODE */
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
+		memcpy(awrq->sa_data, &(priv->current_ap.bssid[0]), ETH_ALEN);
+	} else {
 		memset(awrq->sa_data, 0, ETH_ALEN);
 	}
 
@@ -420,15 +446,20 @@ static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set Nickname */
-static int ks_wlan_set_nick(struct net_device *dev, struct iw_request_info *info,
-				struct iw_point *dwrq, char *extra)
+static int ks_wlan_set_nick(struct net_device *dev,
+			    struct iw_request_info *info, struct iw_point *dwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
 
+	/* for SLEEP MODE */
 	/* Check the size of the string */
-	if(dwrq->length > 16 + 1) {
+	if (dwrq->length > 16 + 1) {
 		return -E2BIG;
 	}
 	memset(priv->nick, 0, sizeof(priv->nick));
@@ -439,13 +470,17 @@ static int ks_wlan_set_nick(struct net_device *dev, struct iw_request_info *info
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get Nickname */
-static int ks_wlan_get_nick(struct net_device *dev, struct iw_request_info *info,
-				struct iw_point *dwrq, char *extra)
+static int ks_wlan_get_nick(struct net_device *dev,
+			    struct iw_request_info *info, struct iw_point *dwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	strncpy(extra, priv->nick, 16);
 	extra[16] = '\0';
 	dwrq->length = strlen(extra) + 1;
@@ -455,144 +490,228 @@ static int ks_wlan_get_nick(struct net_device *dev, struct iw_request_info *info
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set Bit-Rate */
-static int ks_wlan_set_rate(struct net_device *dev, struct iw_request_info *info,
-				struct iw_param *vwrq, char *extra)
+static int ks_wlan_set_rate(struct net_device *dev,
+			    struct iw_request_info *info, struct iw_param *vwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	int i = 0;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if(priv->reg.phy_type == D_11B_ONLY_MODE){
-		if(vwrq->fixed == 1) {
-			switch(vwrq->value){
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (priv->reg.phy_type == D_11B_ONLY_MODE) {
+		if (vwrq->fixed == 1) {
+			switch (vwrq->value) {
 			case 11000000:
-			case  5500000:
-				priv->reg.rate_set.body[0] = (uint8_t)(vwrq->value/500000);
+			case 5500000:
+				priv->reg.rate_set.body[0] =
+				    (uint8_t) (vwrq->value / 500000);
 				break;
-			case  2000000:
-			case  1000000:
-				priv->reg.rate_set.body[0] = ((uint8_t)(vwrq->value/500000))|BASIC_RATE;
+			case 2000000:
+			case 1000000:
+				priv->reg.rate_set.body[0] =
+				    ((uint8_t) (vwrq->value / 500000)) |
+				    BASIC_RATE;
 				break;
 			default:
 				return -EINVAL;
 			}
 			priv->reg.tx_rate = TX_RATE_FIXED;
 			priv->reg.rate_set.size = 1;
-		}else{  /* vwrq->fixed == 0 */
-			if(vwrq->value > 0){
-				switch(vwrq->value){
+		} else {	/* vwrq->fixed == 0 */
+			if (vwrq->value > 0) {
+				switch (vwrq->value) {
 				case 11000000:
-					priv->reg.rate_set.body[3] = TX_RATE_11M; i++;
-				case  5500000:
-					priv->reg.rate_set.body[2] = TX_RATE_5M; i++;
-				case  2000000:
-					priv->reg.rate_set.body[1] = TX_RATE_2M|BASIC_RATE; i++;
-				case  1000000:
-					priv->reg.rate_set.body[0] = TX_RATE_1M|BASIC_RATE; i++;
+					priv->reg.rate_set.body[3] =
+					    TX_RATE_11M;
+					i++;
+				case 5500000:
+					priv->reg.rate_set.body[2] = TX_RATE_5M;
+					i++;
+				case 2000000:
+					priv->reg.rate_set.body[1] =
+					    TX_RATE_2M | BASIC_RATE;
+					i++;
+				case 1000000:
+					priv->reg.rate_set.body[0] =
+					    TX_RATE_1M | BASIC_RATE;
+					i++;
 					break;
 				default:
 					return -EINVAL;
 				}
 				priv->reg.tx_rate = TX_RATE_MANUAL_AUTO;
 				priv->reg.rate_set.size = i;
-			}else{
+			} else {
 				priv->reg.rate_set.body[3] = TX_RATE_11M;
 				priv->reg.rate_set.body[2] = TX_RATE_5M;
-				priv->reg.rate_set.body[1] = TX_RATE_2M|BASIC_RATE;
-				priv->reg.rate_set.body[0] = TX_RATE_1M|BASIC_RATE;
+				priv->reg.rate_set.body[1] =
+				    TX_RATE_2M | BASIC_RATE;
+				priv->reg.rate_set.body[0] =
+				    TX_RATE_1M | BASIC_RATE;
 				priv->reg.tx_rate = TX_RATE_FULL_AUTO;
 				priv->reg.rate_set.size = 4;
 			}
 		}
-	}else{ /* D_11B_ONLY_MODE or  D_11BG_COMPATIBLE_MODE */
-		if(vwrq->fixed == 1) {
-			switch(vwrq->value){
+	} else {	/* D_11B_ONLY_MODE or  D_11BG_COMPATIBLE_MODE */
+		if (vwrq->fixed == 1) {
+			switch (vwrq->value) {
 			case 54000000:
 			case 48000000:
 			case 36000000:
 			case 18000000:
-			case  9000000:
-				priv->reg.rate_set.body[0] = (uint8_t)(vwrq->value/500000);
+			case 9000000:
+				priv->reg.rate_set.body[0] =
+				    (uint8_t) (vwrq->value / 500000);
 				break;
 			case 24000000:
 			case 12000000:
 			case 11000000:
-			case  6000000:
-			case  5500000:
-			case  2000000:
-			case  1000000:
-				priv->reg.rate_set.body[0] = ((uint8_t)(vwrq->value/500000))|BASIC_RATE;
+			case 6000000:
+			case 5500000:
+			case 2000000:
+			case 1000000:
+				priv->reg.rate_set.body[0] =
+				    ((uint8_t) (vwrq->value / 500000)) |
+				    BASIC_RATE;
 				break;
 			default:
 				return -EINVAL;
 			}
 			priv->reg.tx_rate = TX_RATE_FIXED;
 			priv->reg.rate_set.size = 1;
-		}else{  /* vwrq->fixed == 0 */
-			if(vwrq->value > 0){
-				switch(vwrq->value){
+		} else {	/* vwrq->fixed == 0 */
+			if (vwrq->value > 0) {
+				switch (vwrq->value) {
 				case 54000000:
-					priv->reg.rate_set.body[11] = TX_RATE_54M; i++;
+					priv->reg.rate_set.body[11] =
+					    TX_RATE_54M;
+					i++;
 				case 48000000:
-					priv->reg.rate_set.body[10] = TX_RATE_48M; i++;
+					priv->reg.rate_set.body[10] =
+					    TX_RATE_48M;
+					i++;
 				case 36000000:
-					priv->reg.rate_set.body[9] = TX_RATE_36M; i++;
-				case 24000000: case 18000000: case 12000000:
-				case 11000000: case  9000000: case  6000000:
-					if(vwrq->value == 24000000){
-						priv->reg.rate_set.body[8] = TX_RATE_18M; i++;
-						priv->reg.rate_set.body[7] = TX_RATE_9M; i++;
-						priv->reg.rate_set.body[6] = TX_RATE_24M|BASIC_RATE; i++;
-						priv->reg.rate_set.body[5] = TX_RATE_12M|BASIC_RATE; i++;
-						priv->reg.rate_set.body[4] = TX_RATE_6M|BASIC_RATE; i++;
-						priv->reg.rate_set.body[3] = TX_RATE_11M|BASIC_RATE; i++;
-					}else if(vwrq->value == 18000000){
-						priv->reg.rate_set.body[7] = TX_RATE_18M; i++;
-						priv->reg.rate_set.body[6] = TX_RATE_9M; i++;
-						priv->reg.rate_set.body[5] = TX_RATE_12M|BASIC_RATE; i++;
-						priv->reg.rate_set.body[4] = TX_RATE_6M|BASIC_RATE; i++;
-						priv->reg.rate_set.body[3] = TX_RATE_11M|BASIC_RATE; i++;
-					}else if(vwrq->value == 12000000){
-						priv->reg.rate_set.body[6] = TX_RATE_9M; i++;
-						priv->reg.rate_set.body[5] = TX_RATE_12M|BASIC_RATE; i++;
-						priv->reg.rate_set.body[4] = TX_RATE_6M|BASIC_RATE; i++;
-						priv->reg.rate_set.body[3] = TX_RATE_11M|BASIC_RATE; i++;
-					}else if(vwrq->value == 11000000){
-						priv->reg.rate_set.body[5] = TX_RATE_9M; i++;
-						priv->reg.rate_set.body[4] = TX_RATE_6M|BASIC_RATE; i++;
-						priv->reg.rate_set.body[3] = TX_RATE_11M|BASIC_RATE; i++;
-					}else if(vwrq->value == 9000000){
-						priv->reg.rate_set.body[4] = TX_RATE_9M; i++;
-						priv->reg.rate_set.body[3] = TX_RATE_6M|BASIC_RATE; i++;
-					}else{ /* vwrq->value == 6000000 */
-						priv->reg.rate_set.body[3] = TX_RATE_6M|BASIC_RATE; i++;
+					priv->reg.rate_set.body[9] =
+					    TX_RATE_36M;
+					i++;
+				case 24000000:
+				case 18000000:
+				case 12000000:
+				case 11000000:
+				case 9000000:
+				case 6000000:
+					if (vwrq->value == 24000000) {
+						priv->reg.rate_set.body[8] =
+						    TX_RATE_18M;
+						i++;
+						priv->reg.rate_set.body[7] =
+						    TX_RATE_9M;
+						i++;
+						priv->reg.rate_set.body[6] =
+						    TX_RATE_24M | BASIC_RATE;
+						i++;
+						priv->reg.rate_set.body[5] =
+						    TX_RATE_12M | BASIC_RATE;
+						i++;
+						priv->reg.rate_set.body[4] =
+						    TX_RATE_6M | BASIC_RATE;
+						i++;
+						priv->reg.rate_set.body[3] =
+						    TX_RATE_11M | BASIC_RATE;
+						i++;
+					} else if (vwrq->value == 18000000) {
+						priv->reg.rate_set.body[7] =
+						    TX_RATE_18M;
+						i++;
+						priv->reg.rate_set.body[6] =
+						    TX_RATE_9M;
+						i++;
+						priv->reg.rate_set.body[5] =
+						    TX_RATE_12M | BASIC_RATE;
+						i++;
+						priv->reg.rate_set.body[4] =
+						    TX_RATE_6M | BASIC_RATE;
+						i++;
+						priv->reg.rate_set.body[3] =
+						    TX_RATE_11M | BASIC_RATE;
+						i++;
+					} else if (vwrq->value == 12000000) {
+						priv->reg.rate_set.body[6] =
+						    TX_RATE_9M;
+						i++;
+						priv->reg.rate_set.body[5] =
+						    TX_RATE_12M | BASIC_RATE;
+						i++;
+						priv->reg.rate_set.body[4] =
+						    TX_RATE_6M | BASIC_RATE;
+						i++;
+						priv->reg.rate_set.body[3] =
+						    TX_RATE_11M | BASIC_RATE;
+						i++;
+					} else if (vwrq->value == 11000000) {
+						priv->reg.rate_set.body[5] =
+						    TX_RATE_9M;
+						i++;
+						priv->reg.rate_set.body[4] =
+						    TX_RATE_6M | BASIC_RATE;
+						i++;
+						priv->reg.rate_set.body[3] =
+						    TX_RATE_11M | BASIC_RATE;
+						i++;
+					} else if (vwrq->value == 9000000) {
+						priv->reg.rate_set.body[4] =
+						    TX_RATE_9M;
+						i++;
+						priv->reg.rate_set.body[3] =
+						    TX_RATE_6M | BASIC_RATE;
+						i++;
+					} else {	/* vwrq->value == 6000000 */
+						priv->reg.rate_set.body[3] =
+						    TX_RATE_6M | BASIC_RATE;
+						i++;
 					}
-				case  5500000:
-					priv->reg.rate_set.body[2] = TX_RATE_5M|BASIC_RATE; i++;
-				case  2000000:
-					priv->reg.rate_set.body[1] = TX_RATE_2M|BASIC_RATE; i++;
-				case  1000000:
-					priv->reg.rate_set.body[0] = TX_RATE_1M|BASIC_RATE; i++;
+				case 5500000:
+					priv->reg.rate_set.body[2] =
+					    TX_RATE_5M | BASIC_RATE;
+					i++;
+				case 2000000:
+					priv->reg.rate_set.body[1] =
+					    TX_RATE_2M | BASIC_RATE;
+					i++;
+				case 1000000:
+					priv->reg.rate_set.body[0] =
+					    TX_RATE_1M | BASIC_RATE;
+					i++;
 					break;
 				default:
 					return -EINVAL;
 				}
 				priv->reg.tx_rate = TX_RATE_MANUAL_AUTO;
 				priv->reg.rate_set.size = i;
-			}else{
+			} else {
 				priv->reg.rate_set.body[11] = TX_RATE_54M;
 				priv->reg.rate_set.body[10] = TX_RATE_48M;
 				priv->reg.rate_set.body[9] = TX_RATE_36M;
 				priv->reg.rate_set.body[8] = TX_RATE_18M;
 				priv->reg.rate_set.body[7] = TX_RATE_9M;
-				priv->reg.rate_set.body[6] = TX_RATE_24M|BASIC_RATE;
-				priv->reg.rate_set.body[5] = TX_RATE_12M|BASIC_RATE;
-				priv->reg.rate_set.body[4] = TX_RATE_6M|BASIC_RATE;
-				priv->reg.rate_set.body[3] = TX_RATE_11M|BASIC_RATE;
-				priv->reg.rate_set.body[2] = TX_RATE_5M|BASIC_RATE;
-				priv->reg.rate_set.body[1] = TX_RATE_2M|BASIC_RATE;
-				priv->reg.rate_set.body[0] = TX_RATE_1M|BASIC_RATE;
+				priv->reg.rate_set.body[6] =
+				    TX_RATE_24M | BASIC_RATE;
+				priv->reg.rate_set.body[5] =
+				    TX_RATE_12M | BASIC_RATE;
+				priv->reg.rate_set.body[4] =
+				    TX_RATE_6M | BASIC_RATE;
+				priv->reg.rate_set.body[3] =
+				    TX_RATE_11M | BASIC_RATE;
+				priv->reg.rate_set.body[2] =
+				    TX_RATE_5M | BASIC_RATE;
+				priv->reg.rate_set.body[1] =
+				    TX_RATE_2M | BASIC_RATE;
+				priv->reg.rate_set.body[0] =
+				    TX_RATE_1M | BASIC_RATE;
 				priv->reg.tx_rate = TX_RATE_FULL_AUTO;
 				priv->reg.rate_set.size = 12;
 			}
@@ -606,21 +725,25 @@ static int ks_wlan_set_rate(struct net_device *dev, struct iw_request_info *info
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get Bit-Rate */
-static int ks_wlan_get_rate(struct net_device *dev, struct iw_request_info *info,
-				struct iw_param *vwrq, char *extra)
+static int ks_wlan_get_rate(struct net_device *dev,
+			    struct iw_request_info *info, struct iw_param *vwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
 	DPRINTK(2, "in_interrupt = %ld update_phyinfo = %d\n",
-		in_interrupt(),atomic_read(&update_phyinfo));
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+		in_interrupt(), atomic_read(&update_phyinfo));
 
-	if(!atomic_read(&update_phyinfo)){
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (!atomic_read(&update_phyinfo)) {
 		ks_wlan_update_phy_information(priv);
 	}
 	vwrq->value = ((priv->current_rate) & RATE_MASK) * 500000;
-	if(priv->reg.tx_rate == TX_RATE_FIXED)
+	if (priv->reg.tx_rate == TX_RATE_FIXED)
 		vwrq->fixed = 1;
 	else
 		vwrq->fixed = 0;
@@ -633,14 +756,17 @@ static int ks_wlan_get_rate(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
 			   struct iw_param *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	int rthr = vwrq->value;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if(vwrq->disabled)
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (vwrq->disabled)
 		rthr = 2347;
-	if((rthr < 0) || (rthr > 2347)) {
+	if ((rthr < 0) || (rthr > 2347)) {
 		return -EINVAL;
 	}
 	priv->reg.rts = rthr;
@@ -654,10 +780,13 @@ static int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
 static int ks_wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
 			   struct iw_param *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	vwrq->value = priv->reg.rts;
 	vwrq->disabled = (vwrq->value >= 2347);
 	vwrq->fixed = 1;
@@ -667,17 +796,21 @@ static int ks_wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set Fragmentation threshold */
-static int ks_wlan_set_frag(struct net_device *dev, struct iw_request_info *info,
-				struct iw_param *vwrq, char *extra)
+static int ks_wlan_set_frag(struct net_device *dev,
+			    struct iw_request_info *info, struct iw_param *vwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	int fthr = vwrq->value;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if(vwrq->disabled)
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (vwrq->disabled)
 		fthr = 2346;
-	if((fthr < 256) || (fthr > 2346)) {
+	if ((fthr < 256) || (fthr > 2346)) {
 		return -EINVAL;
 	}
 	fthr &= ~0x1;	/* Get an even value - is it really needed ??? */
@@ -689,13 +822,17 @@ static int ks_wlan_set_frag(struct net_device *dev, struct iw_request_info *info
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get Fragmentation threshold */
-static int ks_wlan_get_frag(struct net_device *dev, struct iw_request_info *info,
-				struct iw_param *vwrq, char *extra)
+static int ks_wlan_get_frag(struct net_device *dev,
+			    struct iw_request_info *info, struct iw_param *vwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	vwrq->value = priv->reg.fragment;
 	vwrq->disabled = (vwrq->value >= 2346);
 	vwrq->fixed = 1;
@@ -705,16 +842,20 @@ static int ks_wlan_get_frag(struct net_device *dev, struct iw_request_info *info
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set Mode of Operation */
-static int ks_wlan_set_mode(struct net_device *dev, struct iw_request_info *info,
-				__u32 *uwrq, char *extra)
+static int ks_wlan_set_mode(struct net_device *dev,
+			    struct iw_request_info *info, __u32 * uwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	DPRINTK(2,"mode=%d\n",*uwrq);
+	DPRINTK(2, "mode=%d\n", *uwrq);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	switch(*uwrq) {
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	switch (*uwrq) {
 	case IW_MODE_ADHOC:
 		priv->reg.operation_mode = MODE_ADHOC;
 		priv->need_commit |= SME_MODE_SET;
@@ -732,28 +873,33 @@ static int ks_wlan_set_mode(struct net_device *dev, struct iw_request_info *info
 		return -EINVAL;
 	}
 
-	return -EINPROGRESS;		/* Call commit handler */
+	return -EINPROGRESS;	/* Call commit handler */
 }
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get Mode of Operation */
-static int ks_wlan_get_mode(struct net_device *dev, struct iw_request_info *info,
-				__u32 *uwrq, char *extra)
+static int ks_wlan_get_mode(struct net_device *dev,
+			    struct iw_request_info *info, __u32 * uwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
 
+	/* for SLEEP MODE */
 	/* If not managed, assume it's ad-hoc */
 	switch (priv->reg.operation_mode) {
-		case MODE_INFRASTRUCTURE:
-			*uwrq = IW_MODE_INFRA;
-			break;
-		case MODE_ADHOC:
-			*uwrq = IW_MODE_ADHOC;
-			break;
-		default:
-			*uwrq = IW_MODE_ADHOC;
+	case MODE_INFRASTRUCTURE:
+		*uwrq = IW_MODE_INFRA;
+		break;
+	case MODE_ADHOC:
+		*uwrq = IW_MODE_ADHOC;
+		break;
+	default:
+		*uwrq = IW_MODE_ADHOC;
 	}
 
 	return 0;
@@ -761,24 +907,29 @@ static int ks_wlan_get_mode(struct net_device *dev, struct iw_request_info *info
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set Encryption Key */
-static int ks_wlan_set_encode(struct net_device *dev, struct iw_request_info *info,
-				  struct iw_point *dwrq, char *extra)
+static int ks_wlan_set_encode(struct net_device *dev,
+			      struct iw_request_info *info,
+			      struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
 	wep_key_t key;
 	int index = (dwrq->flags & IW_ENCODE_INDEX);
 	int current_index = priv->reg.wep_index;
 	int i;
 
-	DPRINTK(2,"flags=%04X\n",dwrq->flags);
+	DPRINTK(2, "flags=%04X\n", dwrq->flags);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
 
+	/* for SLEEP MODE */
 	/* index check */
-	if((index<0) || (index>4))
+	if ((index < 0) || (index > 4))
 		return -EINVAL;
-	else if (index==0)
+	else if (index == 0)
 		index = current_index;
 	else
 		index--;
@@ -786,10 +937,10 @@ static int ks_wlan_set_encode(struct net_device *dev, struct iw_request_info *in
 	/* Is WEP supported ? */
 	/* Basic checking: do we have a key to set ? */
 	if (dwrq->length > 0) {
-		if (dwrq->length > MAX_KEY_SIZE) { /* Check the size of the key */
+		if (dwrq->length > MAX_KEY_SIZE) {	/* Check the size of the key */
 			return -EINVAL;
 		}
-		if (dwrq->length > MIN_KEY_SIZE) { /* Set the length */
+		if (dwrq->length > MIN_KEY_SIZE) {	/* Set the length */
 			key.len = MAX_KEY_SIZE;
 			priv->reg.privacy_invoked = 0x01;
 			priv->need_commit |= SME_WEP_FLAG;
@@ -800,94 +951,97 @@ static int ks_wlan_set_encode(struct net_device *dev, struct iw_request_info *in
 				priv->reg.privacy_invoked = 0x01;
 				priv->need_commit |= SME_WEP_FLAG;
 				wep_on_off = WEP_ON_64BIT;
-			} else { /* Disable the key */
+			} else {	/* Disable the key */
 				key.len = 0;
 			}
 		}
 		/* Check if the key is not marked as invalid */
-		if(!(dwrq->flags & IW_ENCODE_NOKEY)) {
+		if (!(dwrq->flags & IW_ENCODE_NOKEY)) {
 			/* Cleanup */
 			memset(key.key, 0, MAX_KEY_SIZE);
 			/* Copy the key in the driver */
-			if(copy_from_user(key.key,dwrq->pointer,dwrq->length)) {
+			if (copy_from_user
+			    (key.key, dwrq->pointer, dwrq->length)) {
 				key.len = 0;
 				return -EFAULT;
 			}
 			/* Send the key to the card */
 			priv->reg.wep_key[index].size = key.len;
-			for (i=0; i<(priv->reg.wep_key[index].size); i++) {
+			for (i = 0; i < (priv->reg.wep_key[index].size); i++) {
 				priv->reg.wep_key[index].val[i] = key.key[i];
 			}
-			priv->need_commit |= (SME_WEP_VAL1<<index);
+			priv->need_commit |= (SME_WEP_VAL1 << index);
 			priv->reg.wep_index = index;
 			priv->need_commit |= SME_WEP_INDEX;
 		}
 	} else {
-		if(dwrq->flags & IW_ENCODE_DISABLED){
+		if (dwrq->flags & IW_ENCODE_DISABLED) {
 			priv->reg.wep_key[0].size = 0;
 			priv->reg.wep_key[1].size = 0;
 			priv->reg.wep_key[2].size = 0;
 			priv->reg.wep_key[3].size = 0;
 			priv->reg.privacy_invoked = 0x00;
-			if(priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY){
+			if (priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY) {
 				priv->need_commit |= SME_MODE_SET;
 			}
 			priv->reg.authenticate_type = AUTH_TYPE_OPEN_SYSTEM;
 			wep_on_off = WEP_OFF;
 			priv->need_commit |= SME_WEP_FLAG;
-		}else{
+		} else {
 			/* Do we want to just set the transmit key index ? */
-			if ((index>=0) && (index<4)) {
-				/* set_wep_key(priv, index, 0, 0, 1);	xxx */
-				if(priv->reg.wep_key[index].size){
+			if ((index >= 0) && (index < 4)) {
+				/* set_wep_key(priv, index, 0, 0, 1);   xxx */
+				if (priv->reg.wep_key[index].size) {
 					priv->reg.wep_index = index;
 					priv->need_commit |= SME_WEP_INDEX;
-				}
-				else
+				} else
 					return -EINVAL;
 			}
 		}
 	}
 
 	/* Commit the changes if needed */
-	if(dwrq->flags & IW_ENCODE_MODE)
+	if (dwrq->flags & IW_ENCODE_MODE)
 		priv->need_commit |= SME_WEP_FLAG;
 
-	if(dwrq->flags & IW_ENCODE_OPEN) {
-		if(priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY){
+	if (dwrq->flags & IW_ENCODE_OPEN) {
+		if (priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY) {
 			priv->need_commit |= SME_MODE_SET;
 		}
 		priv->reg.authenticate_type = AUTH_TYPE_OPEN_SYSTEM;
-	} else if(dwrq->flags & IW_ENCODE_RESTRICTED) {
-		if(priv->reg.authenticate_type == AUTH_TYPE_OPEN_SYSTEM){
+	} else if (dwrq->flags & IW_ENCODE_RESTRICTED) {
+		if (priv->reg.authenticate_type == AUTH_TYPE_OPEN_SYSTEM) {
 			priv->need_commit |= SME_MODE_SET;
 		}
 		priv->reg.authenticate_type = AUTH_TYPE_SHARED_KEY;
 	}
-
-//	return -EINPROGRESS;		/* Call commit handler */
-	if(priv->need_commit){
+//      return -EINPROGRESS;            /* Call commit handler */
+	if (priv->need_commit) {
 		ks_wlan_setup_parameter(priv, priv->need_commit);
-		priv->need_commit=0;
+		priv->need_commit = 0;
 	}
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get Encryption Key */
-static int ks_wlan_get_encode(struct net_device *dev, struct iw_request_info *info,
-				  struct iw_point *dwrq, char *extra)
+static int ks_wlan_get_encode(struct net_device *dev,
+			      struct iw_request_info *info,
+			      struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	char zeros[16];
 	int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	dwrq->flags = IW_ENCODE_DISABLED;
 
 	/* Check encryption mode */
-	switch(priv->reg.authenticate_type) {
+	switch (priv->reg.authenticate_type) {
 	case AUTH_TYPE_OPEN_SYSTEM:
 		dwrq->flags = IW_ENCODE_OPEN;
 		break;
@@ -896,29 +1050,30 @@ static int ks_wlan_get_encode(struct net_device *dev, struct iw_request_info *in
 		break;
 	}
 
-	memset(zeros,0, sizeof(zeros));
+	memset(zeros, 0, sizeof(zeros));
 
 	/* Which key do we want ? -1 -> tx index */
-	if((index < 0) || (index >= 4))
+	if ((index < 0) || (index >= 4))
 		index = priv->reg.wep_index;
-	if (priv->reg.privacy_invoked){
+	if (priv->reg.privacy_invoked) {
 		dwrq->flags &= ~IW_ENCODE_DISABLED;
 		/* dwrq->flags |= IW_ENCODE_NOKEY; */
 	}
 	dwrq->flags |= index + 1;
-	DPRINTK(2,"encoding flag = 0x%04X\n",dwrq->flags);
+	DPRINTK(2, "encoding flag = 0x%04X\n", dwrq->flags);
 	/* Copy the key to the user buffer */
-	if((index >= 0) && (index < 4))
+	if ((index >= 0) && (index < 4))
 		dwrq->length = priv->reg.wep_key[index].size;
 	if (dwrq->length > 16) {
-		dwrq->length=0;
+		dwrq->length = 0;
 	}
-#if 1 /* IW_ENCODE_NOKEY; */
+#if 1	/* IW_ENCODE_NOKEY; */
 	if (dwrq->length) {
-		if((index >= 0) && (index < 4))
-			memcpy(extra,priv->reg.wep_key[index].val,dwrq->length);
+		if ((index >= 0) && (index < 4))
+			memcpy(extra, priv->reg.wep_key[index].val,
+			       dwrq->length);
 	} else
-		memcpy(extra,zeros,dwrq->length);
+		memcpy(extra, zeros, dwrq->length);
 #endif
 	return 0;
 }
@@ -926,19 +1081,24 @@ static int ks_wlan_get_encode(struct net_device *dev, struct iw_request_info *in
 #ifndef KSC_OPNOTSUPP
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set Tx-Power */
-static int ks_wlan_set_txpow(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_param *vwrq, char *extra)
+static int ks_wlan_set_txpow(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_param *vwrq, char *extra)
 {
-	return -EOPNOTSUPP; /* Not Support */
+	return -EOPNOTSUPP;	/* Not Support */
 }
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get Tx-Power */
-static int ks_wlan_get_txpow(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_param *vwrq, char *extra)
+static int ks_wlan_get_txpow(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_param *vwrq, char *extra)
 {
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
 
+	/* for SLEEP MODE */
 	/* Not Support */
 	vwrq->value = 0;
 	vwrq->disabled = (vwrq->value == 0);
@@ -948,19 +1108,24 @@ static int ks_wlan_get_txpow(struct net_device *dev, struct iw_request_info *inf
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set Retry limits */
-static int ks_wlan_set_retry(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_param *vwrq, char *extra)
+static int ks_wlan_set_retry(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_param *vwrq, char *extra)
 {
-	return -EOPNOTSUPP; /* Not Support */
+	return -EOPNOTSUPP;	/* Not Support */
 }
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get Retry limits */
-static int ks_wlan_get_retry(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_param *vwrq, char *extra)
+static int ks_wlan_get_retry(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_param *vwrq, char *extra)
 {
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
 
+	/* for SLEEP MODE */
 	/* Not Support */
 	vwrq->value = 0;
 	vwrq->disabled = (vwrq->value == 0);
@@ -971,17 +1136,21 @@ static int ks_wlan_get_retry(struct net_device *dev, struct iw_request_info *inf
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get range info */
-static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_point *dwrq, char *extra)
+static int ks_wlan_get_range(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-	struct iw_range *range = (struct iw_range *) extra;
-	int i,k;
-
-	DPRINTK(2,"\n");
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct iw_range *range = (struct iw_range *)extra;
+	int i, k;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	DPRINTK(2, "\n");
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	dwrq->length = sizeof(struct iw_range);
 	memset(range, 0, sizeof(*range));
 	range->min_nwid = 0x0000;
@@ -990,15 +1159,14 @@ static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *inf
 	/* Should be based on cap_rid.country to give only
 	 * what the current card support */
 	k = 0;
-	for(i = 0; i < 13; i++) { /* channel 1 -- 13*/
-		range->freq[k].i = i + 1; /* List index */
+	for (i = 0; i < 13; i++) {	/* channel 1 -- 13 */
+		range->freq[k].i = i + 1;	/* List index */
 		range->freq[k].m = frequency_list[i] * 100000;
 		range->freq[k++].e = 1;	/* Values in table in MHz -> * 10^5 * 10 */
 	}
 	range->num_frequency = k;
-	if(priv->reg.phy_type == D_11B_ONLY_MODE ||
-	   priv->reg.phy_type == D_11BG_COMPATIBLE_MODE){ /* channel 14 */
-		range->freq[13].i = 14; /* List index */
+	if (priv->reg.phy_type == D_11B_ONLY_MODE || priv->reg.phy_type == D_11BG_COMPATIBLE_MODE) {	/* channel 14 */
+		range->freq[13].i = 14;	/* List index */
 		range->freq[13].m = frequency_list[13] * 100000;
 		range->freq[13].e = 1;	/* Values in table in MHz -> * 10^5 * 10 */
 		range->num_frequency = 14;
@@ -1008,16 +1176,15 @@ static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *inf
 	range->max_qual.qual = 100;
 	range->max_qual.level = 256 - 128;	/* 0 dBm? */
 	range->max_qual.noise = 256 - 128;
-		range->sensitivity = 1;
+	range->sensitivity = 1;
 
-	if(priv->reg.phy_type == D_11B_ONLY_MODE){
+	if (priv->reg.phy_type == D_11B_ONLY_MODE) {
 		range->bitrate[0] = 1e6;
 		range->bitrate[1] = 2e6;
 		range->bitrate[2] = 5.5e6;
 		range->bitrate[3] = 11e6;
 		range->num_bitrates = 4;
-	}
-	else{ /* D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE */
+	} else {	/* D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE */
 		range->bitrate[0] = 1e6;
 		range->bitrate[1] = 2e6;
 		range->bitrate[2] = 5.5e6;
@@ -1026,10 +1193,10 @@ static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *inf
 		range->bitrate[4] = 6e6;
 		range->bitrate[5] = 9e6;
 		range->bitrate[6] = 12e6;
-		if(IW_MAX_BITRATES < 9){
+		if (IW_MAX_BITRATES < 9) {
 			range->bitrate[7] = 54e6;
 			range->num_bitrates = 8;
-		}else{
+		} else {
 			range->bitrate[7] = 18e6;
 			range->bitrate[8] = 24e6;
 			range->bitrate[9] = 36e6;
@@ -1043,7 +1210,7 @@ static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *inf
 	/* Set an indication of the max TCP throughput
 	 * in bit/s that we can expect using this interface.
 	 * May be use for QoS stuff... Jean II */
-	if(i > 2)
+	if (i > 2)
 		range->throughput = 5000 * 1000;
 	else
 		range->throughput = 1500 * 1000;
@@ -1053,9 +1220,9 @@ static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *inf
 	range->min_frag = 256;
 	range->max_frag = 2346;
 
-		range->encoding_size[0] = 5;  /* WEP: RC4 40 bits */
-		range->encoding_size[1] = 13; /* WEP: RC4 ~128 bits */
-		range->num_encoding_sizes = 2;
+	range->encoding_size[0] = 5;	/* WEP: RC4 40 bits */
+	range->encoding_size[1] = 13;	/* WEP: RC4 ~128 bits */
+	range->num_encoding_sizes = 2;
 	range->max_encoding_tokens = 4;
 
 	/* power management not support */
@@ -1064,7 +1231,7 @@ static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *inf
 	range->pm_capa = 0;
 
 	/* Transmit Power - values are in dBm( or mW) */
-	range->txpower[0]=-256;
+	range->txpower[0] = -256;
 	range->num_txpower = 1;
 	range->txpower_capa = IW_TXPOW_DBM;
 	/* range->txpower_capa = IW_TXPOW_MWATT; */
@@ -1073,8 +1240,8 @@ static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *inf
 	range->we_version_compiled = WIRELESS_EXT;
 
 	range->retry_capa = IW_RETRY_ON;
-		range->retry_flags = IW_RETRY_ON;
-		range->r_time_flags = IW_RETRY_ON;
+	range->retry_flags = IW_RETRY_ON;
+	range->r_time_flags = IW_RETRY_ON;
 
 	/* Experimental measurements - boundary 11/5.5 Mb/s */
 	/* Note : with or without the (local->rssi), results
@@ -1092,39 +1259,41 @@ static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *inf
 				IW_EVENT_CAPA_MASK(IWEVMICHAELMICFAILURE));
 
 	/* encode extension (WPA) capability */
-	range->enc_capa = (IW_ENC_CAPA_WPA  |
+	range->enc_capa = (IW_ENC_CAPA_WPA |
 			   IW_ENC_CAPA_WPA2 |
-			   IW_ENC_CAPA_CIPHER_TKIP |
-			   IW_ENC_CAPA_CIPHER_CCMP);
+			   IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP);
 	return 0;
 }
 
-
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set Power Management */
-static int ks_wlan_set_power(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_param *vwrq, char *extra)
+static int ks_wlan_set_power(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_param *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	short enabled;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	enabled = vwrq->disabled ? 0 : 1;
-	if(enabled == 0 ){ /* 0 */
+	if (enabled == 0) {	/* 0 */
 		priv->reg.powermgt = POWMGT_ACTIVE_MODE;
-	}else if(enabled){  /* 1 */
-		if(priv->reg.operation_mode == MODE_INFRASTRUCTURE)
-			 priv->reg.powermgt = POWMGT_SAVE1_MODE;
-		 else
-			 return  -EINVAL;
-	}else if(enabled){  /* 2 */
-		if(priv->reg.operation_mode == MODE_INFRASTRUCTURE)
+	} else if (enabled) {	/* 1 */
+		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
+			priv->reg.powermgt = POWMGT_SAVE1_MODE;
+		else
+			return -EINVAL;
+	} else if (enabled) {	/* 2 */
+		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
 			priv->reg.powermgt = POWMGT_SAVE2_MODE;
 		else
 			return -EINVAL;
-	}else
-		return  -EINVAL;
+	} else
+		return -EINVAL;
 
 	hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
 
@@ -1133,33 +1302,41 @@ static int ks_wlan_set_power(struct net_device *dev, struct iw_request_info *inf
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get Power Management */
-static int ks_wlan_get_power(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_param *vwrq, char *extra)
+static int ks_wlan_get_power(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_param *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if(priv->reg.powermgt > 0)
-		vwrq->disabled =  0;
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (priv->reg.powermgt > 0)
+		vwrq->disabled = 0;
 	else
-		vwrq->disabled =  1;
+		vwrq->disabled = 1;
 
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get wirless statistics */
-static int ks_wlan_get_iwstats(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_quality *vwrq, char *extra)
+static int ks_wlan_get_iwstats(struct net_device *dev,
+			       struct iw_request_info *info,
+			       struct iw_quality *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	vwrq->qual    = 0;	/* not supported */
-	vwrq->level   = priv->wstats.qual.level;
-	vwrq->noise   = 0;	/* not supported */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	vwrq->qual = 0;	/* not supported */
+	vwrq->level = priv->wstats.qual.level;
+	vwrq->noise = 0;	/* not supported */
 	vwrq->updated = 0;
 
 	return 0;
@@ -1168,16 +1345,18 @@ static int ks_wlan_get_iwstats(struct net_device *dev, struct iw_request_info *i
 #ifndef KSC_OPNOTSUPP
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set Sensitivity */
-static int ks_wlan_set_sens(struct net_device *dev, struct iw_request_info *info,
-				struct iw_param *vwrq, char *extra)
+static int ks_wlan_set_sens(struct net_device *dev,
+			    struct iw_request_info *info, struct iw_param *vwrq,
+			    char *extra)
 {
-	return -EOPNOTSUPP;  /* Not Support */
+	return -EOPNOTSUPP;	/* Not Support */
 }
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get Sensitivity */
-static int ks_wlan_get_sens(struct net_device *dev, struct iw_request_info *info,
-				struct iw_param *vwrq, char *extra)
+static int ks_wlan_get_sens(struct net_device *dev,
+			    struct iw_request_info *info, struct iw_param *vwrq,
+			    char *extra)
 {
 	/* Not Support */
 	vwrq->value = 0;
@@ -1187,33 +1366,37 @@ static int ks_wlan_get_sens(struct net_device *dev, struct iw_request_info *info
 }
 #endif /* KSC_OPNOTSUPP */
 
-
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get AP List */
 /* Note : this is deprecated in favor of IWSCAN */
-static int ks_wlan_get_aplist(struct net_device *dev, struct iw_request_info *info,
-				  struct iw_point *dwrq, char *extra)
+static int ks_wlan_get_aplist(struct net_device *dev,
+			      struct iw_request_info *info,
+			      struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-	struct sockaddr *address = (struct sockaddr *) extra;
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct sockaddr *address = (struct sockaddr *)extra;
 	struct iw_quality qual[LOCAL_APLIST_MAX];
 
 	int i;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	for (i = 0; i < priv->aplist.size; i++) {
-		memcpy(address[i].sa_data, &(priv->aplist.ap[i].bssid[0]), ETH_ALEN);
+		memcpy(address[i].sa_data, &(priv->aplist.ap[i].bssid[0]),
+		       ETH_ALEN);
 		address[i].sa_family = ARPHRD_ETHER;
 		qual[i].level = 256 - priv->aplist.ap[i].rssi;
 		qual[i].qual = priv->aplist.ap[i].sq;
-		qual[i].noise = 0; /* invalid noise value */
+		qual[i].noise = 0;	/* invalid noise value */
 		qual[i].updated = 7;
 	}
-	if (i){
-		dwrq->flags = 1; /* Should be define'd */
-		memcpy(extra + sizeof(struct sockaddr)*i,
-			   &qual,  sizeof(struct iw_quality)*i);
+	if (i) {
+		dwrq->flags = 1;	/* Should be define'd */
+		memcpy(extra + sizeof(struct sockaddr) * i,
+		       &qual, sizeof(struct iw_quality) * i);
 	}
 	dwrq->length = i;
 
@@ -1222,25 +1405,30 @@ static int ks_wlan_get_aplist(struct net_device *dev, struct iw_request_info *in
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : Initiate Scan */
-static int ks_wlan_set_scan(struct net_device *dev, struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
+static int ks_wlan_set_scan(struct net_device *dev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	struct iw_scan_req *req = NULL;
-	DPRINTK(2,"\n");
+	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
 
+	/* for SLEEP MODE */
 	/* specified SSID SCAN */
-	if(wrqu->data.length == sizeof(struct iw_scan_req) && wrqu->data.flags & IW_SCAN_THIS_ESSID){
-		req = (struct iw_scan_req *) extra;
+	if (wrqu->data.length == sizeof(struct iw_scan_req)
+	    && wrqu->data.flags & IW_SCAN_THIS_ESSID) {
+		req = (struct iw_scan_req *)extra;
 		priv->scan_ssid_len = req->essid_len;
 		memcpy(priv->scan_ssid, req->essid, priv->scan_ssid_len);
-	}else{
+	} else {
 		priv->scan_ssid_len = 0;
 	}
 
-
 	priv->sme_i.sme_flag |= SME_AP_SCAN;
 	hostif_sme_enqueue(priv, SME_BSS_SCAN_REQUEST);
 
@@ -1254,68 +1442,82 @@ static int ks_wlan_set_scan(struct net_device *dev, struct iw_request_info *info
  * Translate scan data returned from the card to a card independent
  * format that the Wireless Tools will understand - Jean II
  */
-static inline char *ks_wlan_translate_scan(struct net_device *dev, struct iw_request_info *info, char *current_ev,
-					   char *end_buf, struct local_ap_t *ap)
+static inline char *ks_wlan_translate_scan(struct net_device *dev,
+					   struct iw_request_info *info,
+					   char *current_ev, char *end_buf,
+					   struct local_ap_t *ap)
 {
 	/* struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv; */
-	struct iw_event	iwe;		/* Temporary buffer */
+	struct iw_event iwe;	/* Temporary buffer */
 	u16 capabilities;
 	char *current_val;	/* For rates */
 	int i;
 	static const char rsn_leader[] = "rsn_ie=";
 	static const char wpa_leader[] = "wpa_ie=";
-	char buf0[RSN_IE_BODY_MAX*2 + 30];
-	char buf1[RSN_IE_BODY_MAX*2 + 30];
+	char buf0[RSN_IE_BODY_MAX * 2 + 30];
+	char buf1[RSN_IE_BODY_MAX * 2 + 30];
 	char *pbuf;
 	/* First entry *MUST* be the AP MAC address */
 	iwe.cmd = SIOCGIWAP;
 	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
 	memcpy(iwe.u.ap_addr.sa_data, ap->bssid, ETH_ALEN);
-	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_ADDR_LEN);
+	current_ev =
+	    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+				 IW_EV_ADDR_LEN);
 
 	/* Other entries will be displayed in the order we give them */
 
 	/* Add the ESSID */
 	iwe.u.data.length = ap->ssid.size;
-	if(iwe.u.data.length > 32)
+	if (iwe.u.data.length > 32)
 		iwe.u.data.length = 32;
 	iwe.cmd = SIOCGIWESSID;
 	iwe.u.data.flags = 1;
-	current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, &(ap->ssid.body[0]));
+	current_ev =
+	    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
+				 &(ap->ssid.body[0]));
 
 	/* Add mode */
 	iwe.cmd = SIOCGIWMODE;
 	capabilities = le16_to_cpu(ap->capability);
-	if(capabilities & (BSS_CAP_ESS | BSS_CAP_IBSS)) {
-		if(capabilities & BSS_CAP_ESS)
+	if (capabilities & (BSS_CAP_ESS | BSS_CAP_IBSS)) {
+		if (capabilities & BSS_CAP_ESS)
 			iwe.u.mode = IW_MODE_INFRA;
 		else
 			iwe.u.mode = IW_MODE_ADHOC;
-		current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_UINT_LEN);
+		current_ev =
+		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+					 IW_EV_UINT_LEN);
 	}
 
 	/* Add frequency */
 	iwe.cmd = SIOCGIWFREQ;
 	iwe.u.freq.m = ap->channel;
-	iwe.u.freq.m = frequency_list[iwe.u.freq.m-1] * 100000;
+	iwe.u.freq.m = frequency_list[iwe.u.freq.m - 1] * 100000;
 	iwe.u.freq.e = 1;
-	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_FREQ_LEN);
+	current_ev =
+	    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+				 IW_EV_FREQ_LEN);
 
 	/* Add quality statistics */
 	iwe.cmd = IWEVQUAL;
 	iwe.u.qual.level = 256 - ap->rssi;
 	iwe.u.qual.qual = ap->sq;
-	iwe.u.qual.noise = 0; /* invalid noise value */
-	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_QUAL_LEN);
+	iwe.u.qual.noise = 0;	/* invalid noise value */
+	current_ev =
+	    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+				 IW_EV_QUAL_LEN);
 
 	/* Add encryption capability */
 	iwe.cmd = SIOCGIWENCODE;
-	if(capabilities & BSS_CAP_PRIVACY)
+	if (capabilities & BSS_CAP_PRIVACY)
 		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
 	else
 		iwe.u.data.flags = IW_ENCODE_DISABLED;
 	iwe.u.data.length = 0;
-	current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, &(ap->ssid.body[0]));
+	current_ev =
+	    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
+				 &(ap->ssid.body[0]));
 
 	/* Rate : stuffing multiple values in a single event require a bit
 	 * more of magic - Jean II */
@@ -1326,62 +1528,68 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev, struct iw_req
 	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
 
 	/* Max 16 values */
-	for(i = 0 ; i < 16 ; i++) {
+	for (i = 0; i < 16; i++) {
 		/* NULL terminated */
-		if(i >= ap->rate_set.size)
+		if (i >= ap->rate_set.size)
 			break;
 		/* Bit rate given in 500 kb/s units (+ 0x80) */
 		iwe.u.bitrate.value = ((ap->rate_set.body[i] & 0x7f) * 500000);
 		/* Add new value to event */
-		current_val = iwe_stream_add_value(info, current_ev, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);
+		current_val =
+		    iwe_stream_add_value(info, current_ev, current_val, end_buf,
+					 &iwe, IW_EV_PARAM_LEN);
 	}
 	/* Check if we added any event */
-	if((current_val - current_ev) > IW_EV_LCP_LEN)
+	if ((current_val - current_ev) > IW_EV_LCP_LEN)
 		current_ev = current_val;
 
 #define GENERIC_INFO_ELEM_ID 0xdd
 #define RSN_INFO_ELEM_ID 0x30
-		if (ap->rsn_ie.id == RSN_INFO_ELEM_ID && ap->rsn_ie.size != 0) {
-			pbuf = &buf0[0];
-			memset(&iwe, 0, sizeof(iwe));
-			iwe.cmd = IWEVCUSTOM;
-			memcpy(buf0,rsn_leader,sizeof(rsn_leader)-1);
-			iwe.u.data.length += sizeof(rsn_leader)-1;
-			pbuf += sizeof(rsn_leader)-1;
+	if (ap->rsn_ie.id == RSN_INFO_ELEM_ID && ap->rsn_ie.size != 0) {
+		pbuf = &buf0[0];
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = IWEVCUSTOM;
+		memcpy(buf0, rsn_leader, sizeof(rsn_leader) - 1);
+		iwe.u.data.length += sizeof(rsn_leader) - 1;
+		pbuf += sizeof(rsn_leader) - 1;
 
-			pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.id);
-			pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.size);
-			iwe.u.data.length += 4;
+		pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.id);
+		pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.size);
+		iwe.u.data.length += 4;
 
-			for (i = 0; i < ap->rsn_ie.size; i++)
-				pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.body[i]);
-			iwe.u.data.length += (ap->rsn_ie.size)*2;
+		for (i = 0; i < ap->rsn_ie.size; i++)
+			pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.body[i]);
+		iwe.u.data.length += (ap->rsn_ie.size) * 2;
 
-			DPRINTK(4,"ap->rsn.size=%d\n",ap->rsn_ie.size);
+		DPRINTK(4, "ap->rsn.size=%d\n", ap->rsn_ie.size);
 
-			current_ev = iwe_stream_add_point(info, current_ev, end_buf,&iwe, &buf0[0]);
-		}
-		if (ap->wpa_ie.id == GENERIC_INFO_ELEM_ID && ap->wpa_ie.size != 0) {
-			pbuf = &buf1[0];
-			memset(&iwe, 0, sizeof(iwe));
-			iwe.cmd = IWEVCUSTOM;
-			memcpy(buf1,wpa_leader,sizeof(wpa_leader)-1);
-			iwe.u.data.length += sizeof(wpa_leader)-1;
-			pbuf += sizeof(wpa_leader)-1;
-
-			pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.id);
-			pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.size);
-			iwe.u.data.length += 4;
-
-			for (i = 0; i < ap->wpa_ie.size; i++)
-				pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.body[i]);
-			iwe.u.data.length += (ap->wpa_ie.size)*2;
-
-			DPRINTK(4,"ap->rsn.size=%d\n",ap->wpa_ie.size);
-			DPRINTK(4,"iwe.u.data.length=%d\n",iwe.u.data.length);
-
-			current_ev = iwe_stream_add_point(info, current_ev, end_buf,&iwe, &buf1[0]);
-		}
+		current_ev =
+		    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
+					 &buf0[0]);
+	}
+	if (ap->wpa_ie.id == GENERIC_INFO_ELEM_ID && ap->wpa_ie.size != 0) {
+		pbuf = &buf1[0];
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = IWEVCUSTOM;
+		memcpy(buf1, wpa_leader, sizeof(wpa_leader) - 1);
+		iwe.u.data.length += sizeof(wpa_leader) - 1;
+		pbuf += sizeof(wpa_leader) - 1;
+
+		pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.id);
+		pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.size);
+		iwe.u.data.length += 4;
+
+		for (i = 0; i < ap->wpa_ie.size; i++)
+			pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.body[i]);
+		iwe.u.data.length += (ap->wpa_ie.size) * 2;
+
+		DPRINTK(4, "ap->rsn.size=%d\n", ap->wpa_ie.size);
+		DPRINTK(4, "iwe.u.data.length=%d\n", iwe.u.data.length);
+
+		current_ev =
+		    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
+					 &buf1[0]);
+	}
 
 	/* The other data in the scan result are not really
 	 * interesting, so for now drop it - Jean II */
@@ -1390,49 +1598,53 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev, struct iw_req
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : Read Scan Results */
-static int ks_wlan_get_scan(struct net_device *dev, struct iw_request_info *info,
-				struct iw_point *dwrq, char *extra)
+static int ks_wlan_get_scan(struct net_device *dev,
+			    struct iw_request_info *info, struct iw_point *dwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	int i;
 	char *current_ev = extra;
-	DPRINTK(2,"\n");
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	DPRINTK(2, "\n");
 
-	if(priv->sme_i.sme_flag & SME_AP_SCAN) {
-DPRINTK(2,"flag AP_SCAN\n");
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (priv->sme_i.sme_flag & SME_AP_SCAN) {
+		DPRINTK(2, "flag AP_SCAN\n");
 		return -EAGAIN;
 	}
 
-	if(priv->aplist.size == 0) {
+	if (priv->aplist.size == 0) {
 		/* Client error, no scan results...
 		 * The caller need to restart the scan. */
-DPRINTK(2,"aplist 0\n");
+		DPRINTK(2, "aplist 0\n");
 		return -ENODATA;
 	}
 #if 0
 	/* current connect ap */
-	if((priv->connect_status & CONNECT_STATUS_MASK)== CONNECT_STATUS){
+	if ((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS) {
 		if ((extra + dwrq->length) - current_ev <= IW_EV_ADDR_LEN) {
 			dwrq->length = 0;
 			return -E2BIG;
 		}
 		current_ev = ks_wlan_translate_scan(dev, current_ev,
-//						    extra + IW_SCAN_MAX_DATA,
+//                                                  extra + IW_SCAN_MAX_DATA,
 						    extra + dwrq->length,
 						    &(priv->current_ap));
 	}
 #endif
 	/* Read and parse all entries */
-	for(i=0; i < priv->aplist.size; i++) {
+	for (i = 0; i < priv->aplist.size; i++) {
 		if ((extra + dwrq->length) - current_ev <= IW_EV_ADDR_LEN) {
 			dwrq->length = 0;
 			return -E2BIG;
 		}
 		/* Translate to WE format this entry */
 		current_ev = ks_wlan_translate_scan(dev, info, current_ev,
-//						    extra + IW_SCAN_MAX_DATA,
+//                                                  extra + IW_SCAN_MAX_DATA,
 						    extra + dwrq->length,
 						    &(priv->aplist.ap[i]));
 	}
@@ -1445,53 +1657,63 @@ DPRINTK(2,"aplist 0\n");
 
 /*------------------------------------------------------------------*/
 /* Commit handler : called after a bunch of SET operations */
-static int ks_wlan_config_commit(struct net_device *dev, struct iw_request_info *info,
-				 void *zwrq, char *extra)
+static int ks_wlan_config_commit(struct net_device *dev,
+				 struct iw_request_info *info, void *zwrq,
+				 char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (!priv->need_commit)
 		return 0;
 
 	ks_wlan_setup_parameter(priv, priv->need_commit);
-	priv->need_commit=0;
+	priv->need_commit = 0;
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Wireless handler : set association ie params */
-static int ks_wlan_set_genie(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_point *dwrq, char *extra)
+static int ks_wlan_set_genie(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
 	DPRINTK(2, "\n");
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	return 0;
-//	return -EOPNOTSUPP;
+//      return -EOPNOTSUPP;
 }
 
 /*------------------------------------------------------------------*/
 /* Wireless handler : set authentication mode params */
-static int ks_wlan_set_auth_mode(struct net_device *dev, struct iw_request_info *info,
+static int ks_wlan_set_auth_mode(struct net_device *dev,
+				 struct iw_request_info *info,
 				 struct iw_param *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	int index = (vwrq->flags & IW_AUTH_INDEX);
 	int value = vwrq->value;
 
-	DPRINTK(2,"index=%d:value=%08X\n",index,value);
+	DPRINTK(2, "index=%d:value=%08X\n", index, value);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	switch(index){
-	case IW_AUTH_WPA_VERSION: /* 0 */
-		switch(value){
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	switch (index) {
+	case IW_AUTH_WPA_VERSION:	/* 0 */
+		switch (value) {
 		case IW_AUTH_WPA_VERSION_DISABLED:
 			priv->wpa.version = value;
-			if(priv->wpa.rsn_enabled){
+			if (priv->wpa.rsn_enabled) {
 				priv->wpa.rsn_enabled = 0;
 			}
 			priv->need_commit |= SME_RSN;
@@ -1499,7 +1721,7 @@ static int ks_wlan_set_auth_mode(struct net_device *dev, struct iw_request_info
 		case IW_AUTH_WPA_VERSION_WPA:
 		case IW_AUTH_WPA_VERSION_WPA2:
 			priv->wpa.version = value;
-			if(!(priv->wpa.rsn_enabled)){
+			if (!(priv->wpa.rsn_enabled)) {
 				priv->wpa.rsn_enabled = 1;
 			}
 			priv->need_commit |= SME_RSN;
@@ -1508,10 +1730,10 @@ static int ks_wlan_set_auth_mode(struct net_device *dev, struct iw_request_info
 			return -EOPNOTSUPP;
 		}
 		break;
-	case IW_AUTH_CIPHER_PAIRWISE: /* 1 */
-		switch(value){
+	case IW_AUTH_CIPHER_PAIRWISE:	/* 1 */
+		switch (value) {
 		case IW_AUTH_CIPHER_NONE:
-			if(priv->reg.privacy_invoked){
+			if (priv->reg.privacy_invoked) {
 				priv->reg.privacy_invoked = 0x00;
 				priv->need_commit |= SME_WEP_FLAG;
 			}
@@ -1520,7 +1742,7 @@ static int ks_wlan_set_auth_mode(struct net_device *dev, struct iw_request_info
 		case IW_AUTH_CIPHER_TKIP:
 		case IW_AUTH_CIPHER_CCMP:
 		case IW_AUTH_CIPHER_WEP104:
-			if(!priv->reg.privacy_invoked){
+			if (!priv->reg.privacy_invoked) {
 				priv->reg.privacy_invoked = 0x01;
 				priv->need_commit |= SME_WEP_FLAG;
 			}
@@ -1531,10 +1753,10 @@ static int ks_wlan_set_auth_mode(struct net_device *dev, struct iw_request_info
 			return -EOPNOTSUPP;
 		}
 		break;
-	case IW_AUTH_CIPHER_GROUP: /* 2 */
-		switch(value){
+	case IW_AUTH_CIPHER_GROUP:	/* 2 */
+		switch (value) {
 		case IW_AUTH_CIPHER_NONE:
-			if(priv->reg.privacy_invoked){
+			if (priv->reg.privacy_invoked) {
 				priv->reg.privacy_invoked = 0x00;
 				priv->need_commit |= SME_WEP_FLAG;
 			}
@@ -1543,7 +1765,7 @@ static int ks_wlan_set_auth_mode(struct net_device *dev, struct iw_request_info
 		case IW_AUTH_CIPHER_TKIP:
 		case IW_AUTH_CIPHER_CCMP:
 		case IW_AUTH_CIPHER_WEP104:
-			if(!priv->reg.privacy_invoked){
+			if (!priv->reg.privacy_invoked) {
 				priv->reg.privacy_invoked = 0x01;
 				priv->need_commit |= SME_WEP_FLAG;
 			}
@@ -1554,12 +1776,12 @@ static int ks_wlan_set_auth_mode(struct net_device *dev, struct iw_request_info
 			return -EOPNOTSUPP;
 		}
 		break;
-	case IW_AUTH_KEY_MGMT: /* 3 */
-		switch(value){
+	case IW_AUTH_KEY_MGMT:	/* 3 */
+		switch (value) {
 		case IW_AUTH_KEY_MGMT_802_1X:
 		case IW_AUTH_KEY_MGMT_PSK:
-		case 0: /* NONE or 802_1X_NO_WPA */
-		case 4: /* WPA_NONE */
+		case 0:	/* NONE or 802_1X_NO_WPA */
+		case 4:	/* WPA_NONE */
 			priv->wpa.key_mgmt_suite = value;
 			priv->need_commit |= SME_RSN_AUTH;
 			break;
@@ -1567,8 +1789,8 @@ static int ks_wlan_set_auth_mode(struct net_device *dev, struct iw_request_info
 			return -EOPNOTSUPP;
 		}
 		break;
-	case IW_AUTH_80211_AUTH_ALG: /* 6 */
-		switch(value){
+	case IW_AUTH_80211_AUTH_ALG:	/* 6 */
+		switch (value) {
 		case IW_AUTH_ALG_OPEN_SYSTEM:
 			priv->wpa.auth_alg = value;
 			priv->reg.authenticate_type = AUTH_TYPE_OPEN_SYSTEM;
@@ -1583,45 +1805,50 @@ static int ks_wlan_set_auth_mode(struct net_device *dev, struct iw_request_info
 		}
 		priv->need_commit |= SME_MODE_SET;
 		break;
-	case IW_AUTH_WPA_ENABLED: /* 7 */
+	case IW_AUTH_WPA_ENABLED:	/* 7 */
 		priv->wpa.wpa_enabled = value;
 		break;
-	case IW_AUTH_PRIVACY_INVOKED: /* 10 */
-		if((value && !priv->reg.privacy_invoked)||
-		   (!value && priv->reg.privacy_invoked)){
-			priv->reg.privacy_invoked = value?0x01:0x00;
+	case IW_AUTH_PRIVACY_INVOKED:	/* 10 */
+		if ((value && !priv->reg.privacy_invoked) ||
+		    (!value && priv->reg.privacy_invoked)) {
+			priv->reg.privacy_invoked = value ? 0x01 : 0x00;
 			priv->need_commit |= SME_WEP_FLAG;
 		}
 		break;
-	case IW_AUTH_RX_UNENCRYPTED_EAPOL: /* 4 */
-	case IW_AUTH_TKIP_COUNTERMEASURES: /* 5 */
-	case IW_AUTH_DROP_UNENCRYPTED: /* 8 */
-	case IW_AUTH_ROAMING_CONTROL: /* 9 */
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:	/* 4 */
+	case IW_AUTH_TKIP_COUNTERMEASURES:	/* 5 */
+	case IW_AUTH_DROP_UNENCRYPTED:	/* 8 */
+	case IW_AUTH_ROAMING_CONTROL:	/* 9 */
 	default:
 		break;
 	}
 
 	/* return -EINPROGRESS; */
-	if(priv->need_commit){
+	if (priv->need_commit) {
 		ks_wlan_setup_parameter(priv, priv->need_commit);
-		priv->need_commit=0;
+		priv->need_commit = 0;
 	}
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Wireless handler : get authentication mode params */
-static int ks_wlan_get_auth_mode(struct net_device *dev, struct iw_request_info *info,
+static int ks_wlan_get_auth_mode(struct net_device *dev,
+				 struct iw_request_info *info,
 				 struct iw_param *vwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	int index = (vwrq->flags & IW_AUTH_INDEX);
-	DPRINTK(2,"index=%d\n",index);
+	DPRINTK(2, "index=%d\n", index);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
 
+	/* for SLEEP MODE */
 	/*  WPA (not used ?? wpa_supplicant) */
-	switch(index){
+	switch (index) {
 	case IW_AUTH_WPA_VERSION:
 		vwrq->value = priv->wpa.version;
 		break;
@@ -1640,7 +1867,7 @@ static int ks_wlan_get_auth_mode(struct net_device *dev, struct iw_request_info
 	case IW_AUTH_WPA_ENABLED:
 		vwrq->value = priv->wpa.rsn_enabled;
 		break;
-	case IW_AUTH_RX_UNENCRYPTED_EAPOL: /* OK??? */
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:	/* OK??? */
 	case IW_AUTH_TKIP_COUNTERMEASURES:
 	case IW_AUTH_DROP_UNENCRYPTED:
 	default:
@@ -1652,36 +1879,41 @@ static int ks_wlan_get_auth_mode(struct net_device *dev, struct iw_request_info
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set encoding token & mode (WPA)*/
-static int ks_wlan_set_encode_ext(struct net_device *dev, struct iw_request_info *info,
+static int ks_wlan_set_encode_ext(struct net_device *dev,
+				  struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	struct iw_encode_ext *enc;
 	int index = dwrq->flags & IW_ENCODE_INDEX;
-	unsigned int commit=0;
+	unsigned int commit = 0;
 
 	enc = (struct iw_encode_ext *)extra;
 
-	DPRINTK(2,"flags=%04X:: ext_flags=%08X\n",dwrq->flags, enc->ext_flags);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	DPRINTK(2, "flags=%04X:: ext_flags=%08X\n", dwrq->flags,
+		enc->ext_flags);
 
-	if(index<1||index>4)
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (index < 1 || index > 4)
 		return -EINVAL;
 	else
 		index--;
 
-	if(dwrq->flags & IW_ENCODE_DISABLED){
-		priv->wpa.key[index].key_len=0;
+	if (dwrq->flags & IW_ENCODE_DISABLED) {
+		priv->wpa.key[index].key_len = 0;
 	}
 
-	if(enc){
-		priv->wpa.key[index].ext_flags=enc->ext_flags;
-		if(enc->ext_flags&IW_ENCODE_EXT_SET_TX_KEY){
-			priv->wpa.txkey=index;
+	if (enc) {
+		priv->wpa.key[index].ext_flags = enc->ext_flags;
+		if (enc->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+			priv->wpa.txkey = index;
 			commit |= SME_WEP_INDEX;
-		}else if(enc->ext_flags&IW_ENCODE_EXT_RX_SEQ_VALID){
-			if(enc->rx_seq)
+		} else if (enc->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
+			if (enc->rx_seq)
 				memcpy(&priv->wpa.key[index].rx_seq[0],
 				       enc->rx_seq, IW_ENCODE_SEQ_MAX_SIZE);
 			else
@@ -1689,11 +1921,11 @@ static int ks_wlan_set_encode_ext(struct net_device *dev, struct iw_request_info
 		}
 
 		memcpy(&priv->wpa.key[index].addr.sa_data[0],
-			   &enc->addr.sa_data[0], ETH_ALEN);
+		       &enc->addr.sa_data[0], ETH_ALEN);
 
 		switch (enc->alg) {
 		case IW_ENCODE_ALG_NONE:
-			if(priv->reg.privacy_invoked){
+			if (priv->reg.privacy_invoked) {
 				priv->reg.privacy_invoked = 0x00;
 				commit |= SME_WEP_FLAG;
 			}
@@ -1702,11 +1934,11 @@ static int ks_wlan_set_encode_ext(struct net_device *dev, struct iw_request_info
 			break;
 		case IW_ENCODE_ALG_WEP:
 		case IW_ENCODE_ALG_CCMP:
-			if(!priv->reg.privacy_invoked){
+			if (!priv->reg.privacy_invoked) {
 				priv->reg.privacy_invoked = 0x01;
 				commit |= SME_WEP_FLAG;
 			}
-			if(enc->key && enc->key_len){
+			if (enc->key && enc->key_len) {
 				memcpy(&priv->wpa.key[index].key_val[0],
 				       &enc->key[0], enc->key_len);
 				priv->wpa.key[index].key_len = enc->key_len;
@@ -1714,24 +1946,25 @@ static int ks_wlan_set_encode_ext(struct net_device *dev, struct iw_request_info
 			}
 			break;
 		case IW_ENCODE_ALG_TKIP:
-			if(!priv->reg.privacy_invoked){
+			if (!priv->reg.privacy_invoked) {
 				priv->reg.privacy_invoked = 0x01;
 				commit |= SME_WEP_FLAG;
 			}
-			if(enc->key && enc->key_len == 32){
+			if (enc->key && enc->key_len == 32) {
 				memcpy(&priv->wpa.key[index].key_val[0],
-				       &enc->key[0], enc->key_len-16);
-				priv->wpa.key[index].key_len = enc->key_len-16;
-				if(priv->wpa.key_mgmt_suite==4){ /* WPA_NONE */
-					memcpy(&priv->wpa.key[index].tx_mic_key[0],
-					       &enc->key[16],8);
-					memcpy(&priv->wpa.key[index].rx_mic_key[0],
-					       &enc->key[16],8);
-				}else{
-					memcpy(&priv->wpa.key[index].tx_mic_key[0],
-					       &enc->key[16],8);
-					memcpy(&priv->wpa.key[index].rx_mic_key[0],
-					       &enc->key[24],8);
+				       &enc->key[0], enc->key_len - 16);
+				priv->wpa.key[index].key_len =
+				    enc->key_len - 16;
+				if (priv->wpa.key_mgmt_suite == 4) {	/* WPA_NONE */
+					memcpy(&priv->wpa.key[index].
+					       tx_mic_key[0], &enc->key[16], 8);
+					memcpy(&priv->wpa.key[index].
+					       rx_mic_key[0], &enc->key[16], 8);
+				} else {
+					memcpy(&priv->wpa.key[index].
+					       tx_mic_key[0], &enc->key[16], 8);
+					memcpy(&priv->wpa.key[index].
+					       rx_mic_key[0], &enc->key[24], 8);
 				}
 				commit |= (SME_WEP_VAL1 << index);
 			}
@@ -1739,17 +1972,16 @@ static int ks_wlan_set_encode_ext(struct net_device *dev, struct iw_request_info
 		default:
 			return -EINVAL;
 		}
-		priv->wpa.key[index].alg=enc->alg;
-	}
-	else
+		priv->wpa.key[index].alg = enc->alg;
+	} else
 		return -EINVAL;
 
-	if(commit){
-		if(commit&SME_WEP_INDEX)
+	if (commit) {
+		if (commit & SME_WEP_INDEX)
 			hostif_sme_enqueue(priv, SME_SET_TXKEY);
-		if(commit&SME_WEP_VAL_MASK)
-			hostif_sme_enqueue(priv, SME_SET_KEY1+index);
-		if(commit&SME_WEP_FLAG)
+		if (commit & SME_WEP_VAL_MASK)
+			hostif_sme_enqueue(priv, SME_SET_KEY1 + index);
+		if (commit & SME_WEP_FLAG)
 			hostif_sme_enqueue(priv, SME_WEP_FLAG_REQUEST);
 	}
 
@@ -1758,101 +1990,121 @@ static int ks_wlan_set_encode_ext(struct net_device *dev, struct iw_request_info
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : get encoding token & mode (WPA)*/
-static int ks_wlan_get_encode_ext(struct net_device *dev, struct iw_request_info *info,
+static int ks_wlan_get_encode_ext(struct net_device *dev,
+				  struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
 
+	/* for SLEEP MODE */
 	/*  WPA (not used ?? wpa_supplicant)
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-	struct iw_encode_ext *enc;
-	enc = (struct iw_encode_ext *)extra;
-	int index = dwrq->flags & IW_ENCODE_INDEX;
-	 WPA (not used ?? wpa_supplicant) */
+	   struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
+	   struct iw_encode_ext *enc;
+	   enc = (struct iw_encode_ext *)extra;
+	   int index = dwrq->flags & IW_ENCODE_INDEX;
+	   WPA (not used ?? wpa_supplicant) */
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Wireless Handler : PMKSA cache operation (WPA2) */
-static int ks_wlan_set_pmksa(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_point *dwrq, char *extra)
+static int ks_wlan_set_pmksa(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-	struct iw_pmksa *pmksa ;
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct iw_pmksa *pmksa;
 	int i;
 	struct pmk_t *pmk;
 	struct list_head *ptr;
 
-	DPRINTK(2,"\n");
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	DPRINTK(2, "\n");
 
-	if(!extra){
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (!extra) {
 		return -EINVAL;
 	}
 	pmksa = (struct iw_pmksa *)extra;
-	DPRINTK(2,"cmd=%d\n",pmksa->cmd);
+	DPRINTK(2, "cmd=%d\n", pmksa->cmd);
 
-	switch(pmksa->cmd){
+	switch (pmksa->cmd) {
 	case IW_PMKSA_ADD:
-		if(list_empty(&priv->pmklist.head)){ /* new list */
-			for(i=0;i<PMK_LIST_MAX;i++){
+		if (list_empty(&priv->pmklist.head)) {	/* new list */
+			for (i = 0; i < PMK_LIST_MAX; i++) {
 				pmk = &priv->pmklist.pmk[i];
-				if(!memcmp("\x00\x00\x00\x00\x00\x00",pmk->bssid,ETH_ALEN))
+				if (!memcmp
+				    ("\x00\x00\x00\x00\x00\x00", pmk->bssid,
+				     ETH_ALEN))
 					break;
 			}
 			memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
 			memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
-			list_add(&pmk->list,&priv->pmklist.head);
+			list_add(&pmk->list, &priv->pmklist.head);
 			priv->pmklist.size++;
-		}
-		else { /* search cache data */
-			list_for_each(ptr, &priv->pmklist.head){
+		} else {	/* search cache data */
+			list_for_each(ptr, &priv->pmklist.head) {
 				pmk = list_entry(ptr, struct pmk_t, list);
-				if(!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)){ /* match address! list move to head. */
-					memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
-					list_move(&pmk->list, &priv->pmklist.head);
+				if (!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)) {	/* match address! list move to head. */
+					memcpy(pmk->pmkid, pmksa->pmkid,
+					       IW_PMKID_LEN);
+					list_move(&pmk->list,
+						  &priv->pmklist.head);
 					break;
 				}
 			}
-			if(ptr == &priv->pmklist.head){ /* not find address. */
-				if(PMK_LIST_MAX > priv->pmklist.size){ /* new cache data */
-					for(i=0;i<PMK_LIST_MAX;i++){
+			if (ptr == &priv->pmklist.head) {	/* not find address. */
+				if (PMK_LIST_MAX > priv->pmklist.size) {	/* new cache data */
+					for (i = 0; i < PMK_LIST_MAX; i++) {
 						pmk = &priv->pmklist.pmk[i];
-						if(!memcmp("\x00\x00\x00\x00\x00\x00",pmk->bssid,ETH_ALEN))
+						if (!memcmp
+						    ("\x00\x00\x00\x00\x00\x00",
+						     pmk->bssid, ETH_ALEN))
 							break;
 					}
-					memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
-					memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
-					list_add(&pmk->list,&priv->pmklist.head);
+					memcpy(pmk->bssid, pmksa->bssid.sa_data,
+					       ETH_ALEN);
+					memcpy(pmk->pmkid, pmksa->pmkid,
+					       IW_PMKID_LEN);
+					list_add(&pmk->list,
+						 &priv->pmklist.head);
 					priv->pmklist.size++;
-				}
-				else{ /* overwrite old cache data */
-					pmk = list_entry(priv->pmklist.head.prev, struct pmk_t, list);
-					memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
-					memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
-					list_move(&pmk->list,&priv->pmklist.head);
+				} else {	/* overwrite old cache data */
+					pmk =
+					    list_entry(priv->pmklist.head.prev,
+						       struct pmk_t, list);
+					memcpy(pmk->bssid, pmksa->bssid.sa_data,
+					       ETH_ALEN);
+					memcpy(pmk->pmkid, pmksa->pmkid,
+					       IW_PMKID_LEN);
+					list_move(&pmk->list,
+						  &priv->pmklist.head);
 				}
 			}
 		}
 		break;
 	case IW_PMKSA_REMOVE:
-		if(list_empty(&priv->pmklist.head)){ /* list empty */
+		if (list_empty(&priv->pmklist.head)) {	/* list empty */
 			return -EINVAL;
-		}
-		else{ /* search cache data */
-			list_for_each(ptr, &priv->pmklist.head){
+		} else {	/* search cache data */
+			list_for_each(ptr, &priv->pmklist.head) {
 				pmk = list_entry(ptr, struct pmk_t, list);
-				if(!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)){ /* match address! list del. */
+				if (!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)) {	/* match address! list del. */
 					memset(pmk->bssid, 0, ETH_ALEN);
 					memset(pmk->pmkid, 0, IW_PMKID_LEN);
 					list_del_init(&pmk->list);
 					break;
 				}
 			}
-			if(ptr == &priv->pmklist.head){ /* not find address. */
+			if (ptr == &priv->pmklist.head) {	/* not find address. */
 				return 0;
 			}
 		}
@@ -1860,7 +2112,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev, struct iw_request_info *inf
 	case IW_PMKSA_FLUSH:
 		memset(&(priv->pmklist), 0, sizeof(priv->pmklist));
 		INIT_LIST_HEAD(&priv->pmklist.head);
-		for(i=0;i<PMK_LIST_MAX;i++)
+		for (i = 0; i < PMK_LIST_MAX; i++)
 			INIT_LIST_HEAD(&priv->pmklist.pmk[i].list);
 		break;
 	default:
@@ -1874,40 +2126,45 @@ static int ks_wlan_set_pmksa(struct net_device *dev, struct iw_request_info *inf
 static struct iw_statistics *ks_get_wireless_stats(struct net_device *dev)
 {
 
-	struct ks_wlan_private *priv = (struct ks_wlan_private *) netdev_priv(dev);
-		struct iw_statistics *wstats = &priv->wstats;
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
+	struct iw_statistics *wstats = &priv->wstats;
 
-	if(!atomic_read(&update_phyinfo)){
+	if (!atomic_read(&update_phyinfo)) {
 		if (priv->dev_state < DEVICE_STATE_READY)
-			return NULL; /* not finished initialize */
+			return NULL;	/* not finished initialize */
 		else
 			return wstats;
 	}
 
 	/* Packets discarded in the wireless adapter due to wireless
 	 * specific problems */
-	wstats->discard.nwid = 0;	/* Rx invalid nwid	*/
-	wstats->discard.code = 0;	/* Rx invalid crypt	*/
-	wstats->discard.fragment = 0;	/* Rx invalid frag	*/
-	wstats->discard.retries = 0;	/* Tx excessive retries	*/
-	wstats->discard.misc = 0;	/* Invalid misc		*/
-	wstats->miss.beacon = 0;	/* Missed beacon	*/
+	wstats->discard.nwid = 0;	/* Rx invalid nwid      */
+	wstats->discard.code = 0;	/* Rx invalid crypt     */
+	wstats->discard.fragment = 0;	/* Rx invalid frag      */
+	wstats->discard.retries = 0;	/* Tx excessive retries */
+	wstats->discard.misc = 0;	/* Invalid misc         */
+	wstats->miss.beacon = 0;	/* Missed beacon        */
 
-		return wstats;
+	return wstats;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : set stop request */
-static int ks_wlan_set_stop_request(struct net_device *dev, struct iw_request_info *info,
-				    __u32 *uwrq, char *extra)
+static int ks_wlan_set_stop_request(struct net_device *dev,
+				    struct iw_request_info *info, __u32 * uwrq,
+				    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-	DPRINTK(2,"\n");
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
+	DPRINTK(2, "\n");
 
-	if(!(*uwrq))
-		return  -EINVAL;
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (!(*uwrq))
+		return -EINVAL;
 
 	hostif_sme_enqueue(priv, SME_STOP_REQUEST);
 	return 0;
@@ -1916,17 +2173,21 @@ static int ks_wlan_set_stop_request(struct net_device *dev, struct iw_request_in
 /*------------------------------------------------------------------*/
 /* Wireless Handler : set MLME */
 #include <linux/ieee80211.h>
-static int ks_wlan_set_mlme(struct net_device *dev, struct iw_request_info *info,
-				  struct iw_point *dwrq, char *extra)
+static int ks_wlan_set_mlme(struct net_device *dev,
+			    struct iw_request_info *info, struct iw_point *dwrq,
+			    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	struct iw_mlme *mlme = (struct iw_mlme *)extra;
 	__u32 mode;
 
 	DPRINTK(2, ":%d :%d\n", mlme->cmd, mlme->reason_code);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	switch (mlme->cmd) {
 	case IW_MLME_DEAUTH:
 		if (mlme->reason_code == WLAN_REASON_MIC_FAILURE) {
@@ -1936,75 +2197,88 @@ static int ks_wlan_set_mlme(struct net_device *dev, struct iw_request_info *info
 		mode = 1;
 		return ks_wlan_set_stop_request(dev, NULL, &mode, NULL);
 	default:
-		return -EOPNOTSUPP;  /* Not Support */
+		return -EOPNOTSUPP;	/* Not Support */
 	}
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : get driver version */
-static int ks_wlan_get_driver_version(struct net_device *dev, struct iw_request_info *info,
+static int ks_wlan_get_driver_version(struct net_device *dev,
+				      struct iw_request_info *info,
 				      struct iw_point *dwrq, char *extra)
 {
 	strcpy(extra, KS_WLAN_DRIVER_VERSION_INFO);
-	dwrq->length = strlen(KS_WLAN_DRIVER_VERSION_INFO)+1;
+	dwrq->length = strlen(KS_WLAN_DRIVER_VERSION_INFO) + 1;
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : get firemware version */
-static int ks_wlan_get_firmware_version(struct net_device *dev, struct iw_request_info *info,
+static int ks_wlan_get_firmware_version(struct net_device *dev,
+					struct iw_request_info *info,
 					struct iw_point *dwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 	strcpy(extra, &(priv->firmware_version[0]));
-	dwrq->length = priv->version_size+1;
+	dwrq->length = priv->version_size + 1;
 	return 0;
 }
 
 #if 0
 /*------------------------------------------------------------------*/
 /* Private handler : set force disconnect status */
-static int ks_wlan_set_detach(struct net_device *dev, struct iw_request_info *info,
-				  __u32 *uwrq, char *extra)
+static int ks_wlan_set_detach(struct net_device *dev,
+			      struct iw_request_info *info, __u32 * uwrq,
+			      char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if(*uwrq == CONNECT_STATUS){ /* 0 */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (*uwrq == CONNECT_STATUS) {	/* 0 */
 		priv->connect_status &= ~FORCE_DISCONNECT;
-		if((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS)
+		if ((priv->connect_status & CONNECT_STATUS_MASK) ==
+		    CONNECT_STATUS)
 			netif_carrier_on(dev);
-	}else if(*uwrq == DISCONNECT_STATUS){ /* 1 */
+	} else if (*uwrq == DISCONNECT_STATUS) {	/* 1 */
 		priv->connect_status |= FORCE_DISCONNECT;
 		netif_carrier_off(dev);
-	}else
-		return  -EINVAL;
+	} else
+		return -EINVAL;
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : get force disconnect status */
-static int ks_wlan_get_detach(struct net_device *dev, struct iw_request_info *info,
-				  __u32 *uwrq, char *extra)
+static int ks_wlan_get_detach(struct net_device *dev,
+			      struct iw_request_info *info, __u32 * uwrq,
+			      char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	*uwrq = ((priv->connect_status & FORCE_DISCONNECT) ? 1 : 0 );
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	*uwrq = ((priv->connect_status & FORCE_DISCONNECT) ? 1 : 0);
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : get connect status */
-static int ks_wlan_get_connect(struct net_device *dev, struct iw_request_info *info,
-				   __u32 *uwrq, char *extra)
+static int ks_wlan_get_connect(struct net_device *dev,
+			       struct iw_request_info *info, __u32 * uwrq,
+			       char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	*uwrq = (priv->connect_status & CONNECT_STATUS_MASK);
 	return 0;
 }
@@ -2012,61 +2286,73 @@ static int ks_wlan_get_connect(struct net_device *dev, struct iw_request_info *i
 
 /*------------------------------------------------------------------*/
 /* Private handler : set preamble */
-static int ks_wlan_set_preamble(struct net_device *dev, struct iw_request_info *info,
-				__u32 *uwrq, char *extra)
+static int ks_wlan_set_preamble(struct net_device *dev,
+				struct iw_request_info *info, __u32 * uwrq,
+				char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if(*uwrq == LONG_PREAMBLE){ /* 0 */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (*uwrq == LONG_PREAMBLE) {	/* 0 */
 		priv->reg.preamble = LONG_PREAMBLE;
-	}else if(*uwrq == SHORT_PREAMBLE){ /* 1 */
+	} else if (*uwrq == SHORT_PREAMBLE) {	/* 1 */
 		priv->reg.preamble = SHORT_PREAMBLE;
-	}else
-		return  -EINVAL;
+	} else
+		return -EINVAL;
 
 	priv->need_commit |= SME_MODE_SET;
-	return -EINPROGRESS;		/* Call commit handler */
+	return -EINPROGRESS;	/* Call commit handler */
 
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : get preamble */
-static int ks_wlan_get_preamble(struct net_device *dev, struct iw_request_info *info,
-				__u32 *uwrq, char *extra)
+static int ks_wlan_get_preamble(struct net_device *dev,
+				struct iw_request_info *info, __u32 * uwrq,
+				char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	*uwrq = priv->reg.preamble;
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : set power save mode */
-static int ks_wlan_set_powermgt(struct net_device *dev, struct iw_request_info *info,
-				__u32 *uwrq, char *extra)
+static int ks_wlan_set_powermgt(struct net_device *dev,
+				struct iw_request_info *info, __u32 * uwrq,
+				char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if(*uwrq == POWMGT_ACTIVE_MODE){ /* 0 */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (*uwrq == POWMGT_ACTIVE_MODE) {	/* 0 */
 		priv->reg.powermgt = POWMGT_ACTIVE_MODE;
-	}else if(*uwrq == POWMGT_SAVE1_MODE){  /* 1 */
-		if(priv->reg.operation_mode == MODE_INFRASTRUCTURE)
-			 priv->reg.powermgt = POWMGT_SAVE1_MODE;
-		 else
-			 return  -EINVAL;
-	}else if(*uwrq == POWMGT_SAVE2_MODE){  /* 2 */
-		if(priv->reg.operation_mode == MODE_INFRASTRUCTURE)
+	} else if (*uwrq == POWMGT_SAVE1_MODE) {	/* 1 */
+		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
+			priv->reg.powermgt = POWMGT_SAVE1_MODE;
+		else
+			return -EINVAL;
+	} else if (*uwrq == POWMGT_SAVE2_MODE) {	/* 2 */
+		if (priv->reg.operation_mode == MODE_INFRASTRUCTURE)
 			priv->reg.powermgt = POWMGT_SAVE2_MODE;
 		else
 			return -EINVAL;
-	}else
-		return  -EINVAL;
+	} else
+		return -EINVAL;
 
 	hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
 
@@ -2075,100 +2361,119 @@ static int ks_wlan_set_powermgt(struct net_device *dev, struct iw_request_info *
 
 /*------------------------------------------------------------------*/
 /* Private handler : get power save made */
-static int ks_wlan_get_powermgt(struct net_device *dev, struct iw_request_info *info,
-				__u32 *uwrq, char *extra)
+static int ks_wlan_get_powermgt(struct net_device *dev,
+				struct iw_request_info *info, __u32 * uwrq,
+				char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	*uwrq = priv->reg.powermgt;
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : set scan type */
-static int ks_wlan_set_scan_type(struct net_device *dev, struct iw_request_info *info,
-				 __u32 *uwrq, char *extra)
+static int ks_wlan_set_scan_type(struct net_device *dev,
+				 struct iw_request_info *info, __u32 * uwrq,
+				 char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if(*uwrq == ACTIVE_SCAN){ /* 0 */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (*uwrq == ACTIVE_SCAN) {	/* 0 */
 		priv->reg.scan_type = ACTIVE_SCAN;
-	}else if(*uwrq == PASSIVE_SCAN){ /* 1 */
+	} else if (*uwrq == PASSIVE_SCAN) {	/* 1 */
 		priv->reg.scan_type = PASSIVE_SCAN;
-	}else
-		return  -EINVAL;
+	} else
+		return -EINVAL;
 
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : get scan type */
-static int ks_wlan_get_scan_type(struct net_device *dev, struct iw_request_info *info,
-				 __u32 *uwrq, char *extra)
+static int ks_wlan_get_scan_type(struct net_device *dev,
+				 struct iw_request_info *info, __u32 * uwrq,
+				 char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	*uwrq = priv->reg.scan_type;
 	return 0;
 }
+
 #if 0
 /*------------------------------------------------------------------*/
 /* Private handler : write raw data to device */
-static int ks_wlan_data_write(struct net_device *dev, struct iw_request_info *info,
-				  struct iw_point *dwrq, char *extra)
+static int ks_wlan_data_write(struct net_device *dev,
+			      struct iw_request_info *info,
+			      struct iw_point *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 	unsigned char *wbuff = NULL;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	wbuff = (unsigned char *)kmalloc(dwrq->length, GFP_ATOMIC);
-	if(!wbuff)
-			return  -EFAULT;
+	if (!wbuff)
+		return -EFAULT;
 	memcpy(wbuff, extra, dwrq->length);
 
 	/* write to device */
-	ks_wlan_hw_tx( priv, wbuff, dwrq->length, NULL, NULL, NULL);
+	ks_wlan_hw_tx(priv, wbuff, dwrq->length, NULL, NULL, NULL);
 
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : read raw data form device */
-static int ks_wlan_data_read(struct net_device *dev, struct iw_request_info *info,
-				 struct iw_point *dwrq, char *extra)
+static int ks_wlan_data_read(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_point *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 	unsigned short read_length;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if(!atomic_read(&priv->event_count)){
-		if (priv->dev_state < DEVICE_STATE_BOOT) { /* Remove device */
-				read_length = 4;
-			memset(extra,0xff,read_length);
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (!atomic_read(&priv->event_count)) {
+		if (priv->dev_state < DEVICE_STATE_BOOT) {	/* Remove device */
+			read_length = 4;
+			memset(extra, 0xff, read_length);
 			dwrq->length = read_length;
 			return 0;
 		}
 		read_length = 0;
-		memset(extra,0,1);
+		memset(extra, 0, 1);
 		dwrq->length = 0;
 		return 0;
 	}
 
-	if(atomic_read(&priv->event_count)>0)
-			atomic_dec(&priv->event_count);
+	if (atomic_read(&priv->event_count) > 0)
+		atomic_dec(&priv->event_count);
 
 	spin_lock(&priv->dev_read_lock);	/* request spin lock */
 
-		/* Copy length max size 0x07ff */
-	if(priv->dev_size[priv->dev_count] > 2047)
+	/* Copy length max size 0x07ff */
+	if (priv->dev_size[priv->dev_count] > 2047)
 		read_length = 2047;
 	else
 		read_length = priv->dev_size[priv->dev_count];
@@ -2176,15 +2481,15 @@ static int ks_wlan_data_read(struct net_device *dev, struct iw_request_info *inf
 	/* Copy data */
 	memcpy(extra, &(priv->dev_data[priv->dev_count][0]), read_length);
 
-	spin_unlock(&priv->dev_read_lock); /* release spin lock */
+	spin_unlock(&priv->dev_read_lock);	/* release spin lock */
 
 	/* Initialize */
 	priv->dev_data[priv->dev_count] = 0;
 	priv->dev_size[priv->dev_count] = 0;
 
 	priv->dev_count++;
-	if(priv->dev_count == DEVICE_STOCK_COUNT)
-			 priv->dev_count=0;
+	if (priv->dev_count == DEVICE_STOCK_COUNT)
+		priv->dev_count = 0;
 
 	/* Set read size */
 	dwrq->length = read_length;
@@ -2197,150 +2502,180 @@ static int ks_wlan_data_read(struct net_device *dev, struct iw_request_info *inf
 /*------------------------------------------------------------------*/
 /* Private handler : get wep string */
 #define WEP_ASCII_BUFF_SIZE (17+64*4+1)
-static int ks_wlan_get_wep_ascii(struct net_device *dev, struct iw_request_info *info,
+static int ks_wlan_get_wep_ascii(struct net_device *dev,
+				 struct iw_request_info *info,
 				 struct iw_point *dwrq, char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-	int i,j,len=0;
+	int i, j, len = 0;
 	char tmp[WEP_ASCII_BUFF_SIZE];
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	strcpy(tmp," WEP keys ASCII \n");
-	len+=strlen(" WEP keys ASCII \n");
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	strcpy(tmp, " WEP keys ASCII \n");
+	len += strlen(" WEP keys ASCII \n");
 
-	for(i=0;i<4;i++){
-		strcpy(tmp+len,"\t[");
-		len+=strlen("\t[");
-		tmp[len] = '1'+i;
+	for (i = 0; i < 4; i++) {
+		strcpy(tmp + len, "\t[");
+		len += strlen("\t[");
+		tmp[len] = '1' + i;
 		len++;
-		strcpy(tmp+len,"] ");
-		len+=strlen("] ");
-		if(priv->reg.wep_key[i].size){
-			strcpy(tmp+len,(priv->reg.wep_key[i].size < 6 ? "(40bits) [" : "(104bits) ["));
-			len+=strlen((priv->reg.wep_key[i].size < 6 ? "(40bits) [" : "(104bits) ["));
-			for(j=0;j<priv->reg.wep_key[i].size;j++,len++)
-				tmp[len]=(isprint(priv->reg.wep_key[i].val[j]) ? priv->reg.wep_key[i].val[j] : ' ');
-
-			strcpy(tmp+len,"]\n");
-			len+=strlen("]\n");
-		}
-		else{
-			strcpy(tmp+len,"off\n");
-			len+=strlen("off\n");
+		strcpy(tmp + len, "] ");
+		len += strlen("] ");
+		if (priv->reg.wep_key[i].size) {
+			strcpy(tmp + len,
+			       (priv->reg.wep_key[i].size <
+				6 ? "(40bits) [" : "(104bits) ["));
+			len +=
+			    strlen((priv->reg.wep_key[i].size <
+				    6 ? "(40bits) [" : "(104bits) ["));
+			for (j = 0; j < priv->reg.wep_key[i].size; j++, len++)
+				tmp[len] =
+				    (isprint(priv->reg.wep_key[i].val[j]) ?
+				     priv->reg.wep_key[i].val[j] : ' ');
+
+			strcpy(tmp + len, "]\n");
+			len += strlen("]\n");
+		} else {
+			strcpy(tmp + len, "off\n");
+			len += strlen("off\n");
 		}
 	}
 
 	memcpy(extra, tmp, len);
-	dwrq->length = len+1;
+	dwrq->length = len + 1;
 	return 0;
 }
 #endif
 
 /*------------------------------------------------------------------*/
 /* Private handler : set beacon lost count */
-static int ks_wlan_set_beacon_lost(struct net_device *dev, struct iw_request_info *info,
-				   __u32 *uwrq, char *extra)
+static int ks_wlan_set_beacon_lost(struct net_device *dev,
+				   struct iw_request_info *info, __u32 * uwrq,
+				   char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if(*uwrq >= BEACON_LOST_COUNT_MIN &&
-	   *uwrq <= BEACON_LOST_COUNT_MAX){
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (*uwrq >= BEACON_LOST_COUNT_MIN && *uwrq <= BEACON_LOST_COUNT_MAX) {
 		priv->reg.beacon_lost_count = *uwrq;
-	}else
-		return  -EINVAL;
+	} else
+		return -EINVAL;
 
-	if(priv->reg.operation_mode == MODE_INFRASTRUCTURE){
+	if (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
 		priv->need_commit |= SME_MODE_SET;
-		return -EINPROGRESS;		/* Call commit handler */
-	}
-	else
+		return -EINPROGRESS;	/* Call commit handler */
+	} else
 		return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : get beacon lost count */
-static int ks_wlan_get_beacon_lost(struct net_device *dev, struct iw_request_info *info,
-				   __u32 *uwrq, char *extra)
+static int ks_wlan_get_beacon_lost(struct net_device *dev,
+				   struct iw_request_info *info, __u32 * uwrq,
+				   char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	*uwrq = priv->reg.beacon_lost_count;
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : set phy type */
-static int ks_wlan_set_phy_type(struct net_device *dev, struct iw_request_info *info,
-				__u32 *uwrq, char *extra)
+static int ks_wlan_set_phy_type(struct net_device *dev,
+				struct iw_request_info *info, __u32 * uwrq,
+				char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if(*uwrq == D_11B_ONLY_MODE){ /* 0 */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (*uwrq == D_11B_ONLY_MODE) {	/* 0 */
 		priv->reg.phy_type = D_11B_ONLY_MODE;
-	}else if(*uwrq == D_11G_ONLY_MODE){ /* 1 */
+	} else if (*uwrq == D_11G_ONLY_MODE) {	/* 1 */
 		priv->reg.phy_type = D_11G_ONLY_MODE;
-	}else if(*uwrq == D_11BG_COMPATIBLE_MODE){ /* 2 */
+	} else if (*uwrq == D_11BG_COMPATIBLE_MODE) {	/* 2 */
 		priv->reg.phy_type = D_11BG_COMPATIBLE_MODE;
-	}else
-		return  -EINVAL;
+	} else
+		return -EINVAL;
 
 	priv->need_commit |= SME_MODE_SET;
-	return -EINPROGRESS;		/* Call commit handler */
+	return -EINPROGRESS;	/* Call commit handler */
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : get phy type */
-static int ks_wlan_get_phy_type(struct net_device *dev, struct iw_request_info *info,
-				__u32 *uwrq, char *extra)
+static int ks_wlan_get_phy_type(struct net_device *dev,
+				struct iw_request_info *info, __u32 * uwrq,
+				char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	*uwrq = priv->reg.phy_type;
 	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : set cts mode */
-static int ks_wlan_set_cts_mode(struct net_device *dev, struct iw_request_info *info,
-				__u32 *uwrq, char *extra)
+static int ks_wlan_set_cts_mode(struct net_device *dev,
+				struct iw_request_info *info, __u32 * uwrq,
+				char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if(*uwrq == CTS_MODE_FALSE){ /* 0 */
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (*uwrq == CTS_MODE_FALSE) {	/* 0 */
 		priv->reg.cts_mode = CTS_MODE_FALSE;
-	}else if(*uwrq == CTS_MODE_TRUE){ /* 1 */
-		if(priv->reg.phy_type == D_11G_ONLY_MODE ||
-		   priv->reg.phy_type == D_11BG_COMPATIBLE_MODE)
+	} else if (*uwrq == CTS_MODE_TRUE) {	/* 1 */
+		if (priv->reg.phy_type == D_11G_ONLY_MODE ||
+		    priv->reg.phy_type == D_11BG_COMPATIBLE_MODE)
 			priv->reg.cts_mode = CTS_MODE_TRUE;
 		else
 			priv->reg.cts_mode = CTS_MODE_FALSE;
-	}else
-		return  -EINVAL;
+	} else
+		return -EINVAL;
 
 	priv->need_commit |= SME_MODE_SET;
-	return -EINPROGRESS;		/* Call commit handler */
+	return -EINPROGRESS;	/* Call commit handler */
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : get cts mode */
-static int ks_wlan_get_cts_mode(struct net_device *dev, struct iw_request_info *info,
-				__u32 *uwrq, char *extra)
+static int ks_wlan_get_cts_mode(struct net_device *dev,
+				struct iw_request_info *info, __u32 * uwrq,
+				char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	*uwrq = priv->reg.cts_mode;
 	return 0;
 }
@@ -2348,38 +2683,41 @@ static int ks_wlan_get_cts_mode(struct net_device *dev, struct iw_request_info *
 /*------------------------------------------------------------------*/
 /* Private handler : set sleep mode */
 static int ks_wlan_set_sleep_mode(struct net_device *dev,
-				     struct iw_request_info *info,
-				     __u32 *uwrq, char *extra)
+				  struct iw_request_info *info,
+				  __u32 * uwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	DPRINTK(2,"\n");
+	DPRINTK(2, "\n");
 
-	if(*uwrq == SLP_SLEEP){
+	if (*uwrq == SLP_SLEEP) {
 		priv->sleep_mode = *uwrq;
 		printk("SET_SLEEP_MODE %d\n", priv->sleep_mode);
 
 		hostif_sme_enqueue(priv, SME_STOP_REQUEST);
 		hostif_sme_enqueue(priv, SME_SLEEP_REQUEST);
 
-	}else if(*uwrq == SLP_ACTIVE) {
+	} else if (*uwrq == SLP_ACTIVE) {
 		priv->sleep_mode = *uwrq;
 		printk("SET_SLEEP_MODE %d\n", priv->sleep_mode);
 		hostif_sme_enqueue(priv, SME_SLEEP_REQUEST);
-	}else{
+	} else {
 		printk("SET_SLEEP_MODE %d errror\n", *uwrq);
-		return  -EINVAL;
+		return -EINVAL;
 	}
 
 	return 0;
 }
+
 /*------------------------------------------------------------------*/
 /* Private handler : get sleep mode */
 static int ks_wlan_get_sleep_mode(struct net_device *dev,
-				     struct iw_request_info *info,
-				     __u32 *uwrq, char *extra)
+				  struct iw_request_info *info,
+				  __u32 * uwrq, char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
 	DPRINTK(2, "GET_SLEEP_MODE %d\n", priv->sleep_mode);
 	*uwrq = priv->sleep_mode;
@@ -2390,17 +2728,20 @@ static int ks_wlan_get_sleep_mode(struct net_device *dev,
 #if 0
 /*------------------------------------------------------------------*/
 /* Private handler : set phy information timer */
-static int ks_wlan_set_phy_information_timer(struct net_device *dev, struct iw_request_info *info,
-					     __u32 *uwrq, char *extra)
+static int ks_wlan_set_phy_information_timer(struct net_device *dev,
+					     struct iw_request_info *info,
+					     __u32 * uwrq, char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if(*uwrq >= 0 && *uwrq <= 0xFFFF) /* 0-65535 */
-		priv->reg.phy_info_timer = (uint16_t)*uwrq;
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (*uwrq >= 0 && *uwrq <= 0xFFFF)	/* 0-65535 */
+		priv->reg.phy_info_timer = (uint16_t) * uwrq;
 	else
-		return  -EINVAL;
+		return -EINVAL;
 
 	hostif_sme_enqueue(priv, SME_PHY_INFO_REQUEST);
 
@@ -2409,13 +2750,16 @@ static int ks_wlan_set_phy_information_timer(struct net_device *dev, struct iw_r
 
 /*------------------------------------------------------------------*/
 /* Private handler : get phy information timer */
-static int ks_wlan_get_phy_information_timer(struct net_device *dev, struct iw_request_info *info,
-					     __u32 *uwrq, char *extra)
+static int ks_wlan_get_phy_information_timer(struct net_device *dev,
+					     struct iw_request_info *info,
+					     __u32 * uwrq, char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	*uwrq = priv->reg.phy_info_timer;
 	return 0;
 }
@@ -2424,38 +2768,48 @@ static int ks_wlan_get_phy_information_timer(struct net_device *dev, struct iw_r
 #ifdef WPS
 /*------------------------------------------------------------------*/
 /* Private handler : set WPS enable */
-static int ks_wlan_set_wps_enable(struct net_device *dev, struct iw_request_info *info,
-				  __u32 *uwrq, char *extra)
+static int ks_wlan_set_wps_enable(struct net_device *dev,
+				  struct iw_request_info *info, __u32 * uwrq,
+				  char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-	DPRINTK(2,"\n");
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
+	DPRINTK(2, "\n");
 
-	if(*uwrq == 0 || *uwrq == 1)
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (*uwrq == 0 || *uwrq == 1)
 		priv->wps.wps_enabled = *uwrq;
 	else
-		return  -EINVAL;
+		return -EINVAL;
 
 	hostif_sme_enqueue(priv, SME_WPS_ENABLE_REQUEST);
 
 	return 0;
 }
+
 /*------------------------------------------------------------------*/
 /* Private handler : get WPS enable */
-static int ks_wlan_get_wps_enable(struct net_device *dev, struct iw_request_info *info,
-				  __u32 *uwrq, char *extra)
+static int ks_wlan_get_wps_enable(struct net_device *dev,
+				  struct iw_request_info *info, __u32 * uwrq,
+				  char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-	DPRINTK(2,"\n");
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
+	DPRINTK(2, "\n");
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	*uwrq = priv->wps.wps_enabled;
 	printk("return=%d\n", *uwrq);
 
 	return 0;
 }
+
 /*------------------------------------------------------------------*/
 /* Private handler : set WPS probe req */
 static int ks_wlan_set_wps_probe_req(struct net_device *dev,
@@ -2464,45 +2818,52 @@ static int ks_wlan_set_wps_probe_req(struct net_device *dev,
 {
 	uint8_t *p = extra;
 	unsigned char len;
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	DPRINTK(2,"\n");
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	DPRINTK(2, "\n");
 
-	DPRINTK(2,"dwrq->length=%d\n", dwrq->length);
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	DPRINTK(2, "dwrq->length=%d\n", dwrq->length);
 
 	/* length check */
-	if(p[1] + 2  != dwrq->length  || dwrq->length > 256  ){
+	if (p[1] + 2 != dwrq->length || dwrq->length > 256) {
 		return -EINVAL;
 	}
 
-	priv->wps.ielen = p[1] + 2 + 1;  /* IE header + IE + sizeof(len) */
-	len = p[1] + 2;              /* IE header + IE */
+	priv->wps.ielen = p[1] + 2 + 1;	/* IE header + IE + sizeof(len) */
+	len = p[1] + 2;	/* IE header + IE */
 
 	memcpy(priv->wps.ie, &len, sizeof(len));
-	p = memcpy(priv->wps.ie+1, p, len);
+	p = memcpy(priv->wps.ie + 1, p, len);
 
-	DPRINTK(2,"%d(%#x): %02X %02X %02X %02X ... %02X %02X %02X\n",
+	DPRINTK(2, "%d(%#x): %02X %02X %02X %02X ... %02X %02X %02X\n",
 		priv->wps.ielen, priv->wps.ielen, p[0], p[1], p[2], p[3],
-		p[priv->wps.ielen-3], p[priv->wps.ielen-2], p[priv->wps.ielen-1]);
+		p[priv->wps.ielen - 3], p[priv->wps.ielen - 2],
+		p[priv->wps.ielen - 1]);
 
 	hostif_sme_enqueue(priv, SME_WPS_PROBE_REQUEST);
 
 	return 0;
 }
+
 #if 0
 /*------------------------------------------------------------------*/
 /* Private handler : get WPS probe req */
 static int ks_wlan_get_wps_probe_req(struct net_device *dev,
 				     struct iw_request_info *info,
-				     __u32 *uwrq, char *extra)
+				     __u32 * uwrq, char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
-	DPRINTK(2,"\n");
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	DPRINTK(2, "\n");
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	return 0;
 }
 #endif
@@ -2510,37 +2871,44 @@ static int ks_wlan_get_wps_probe_req(struct net_device *dev,
 
 /*------------------------------------------------------------------*/
 /* Private handler : set tx gain control value */
-static int ks_wlan_set_tx_gain(struct net_device *dev, struct iw_request_info *info,
-					     __u32 *uwrq, char *extra)
+static int ks_wlan_set_tx_gain(struct net_device *dev,
+			       struct iw_request_info *info, __u32 * uwrq,
+			       char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if(*uwrq >= 0 && *uwrq <= 0xFF) /* 0-255 */
-		priv->gain.TxGain = (uint8_t)*uwrq;
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (*uwrq >= 0 && *uwrq <= 0xFF)	/* 0-255 */
+		priv->gain.TxGain = (uint8_t) * uwrq;
 	else
-		return  -EINVAL;
+		return -EINVAL;
 
-	if(priv->gain.TxGain < 0xFF)
+	if (priv->gain.TxGain < 0xFF)
 		priv->gain.TxMode = 1;
 	else
 		priv->gain.TxMode = 0;
 
-
 	hostif_sme_enqueue(priv, SME_SET_GAIN);
-	return  0;
+	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : get tx gain control value */
-static int ks_wlan_get_tx_gain(struct net_device *dev, struct iw_request_info *info,
-					     __u32 *uwrq, char *extra)
+static int ks_wlan_get_tx_gain(struct net_device *dev,
+			       struct iw_request_info *info, __u32 * uwrq,
+			       char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	*uwrq = priv->gain.TxGain;
 	hostif_sme_enqueue(priv, SME_GET_GAIN);
 	return 0;
@@ -2548,180 +2916,195 @@ static int ks_wlan_get_tx_gain(struct net_device *dev, struct iw_request_info *i
 
 /*------------------------------------------------------------------*/
 /* Private handler : set rx gain control value */
-static int ks_wlan_set_rx_gain(struct net_device *dev, struct iw_request_info *info,
-					     __u32 *uwrq, char *extra)
+static int ks_wlan_set_rx_gain(struct net_device *dev,
+			       struct iw_request_info *info, __u32 * uwrq,
+			       char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if(*uwrq >= 0 && *uwrq <= 0xFF) /* 0-255 */
-		priv->gain.RxGain = (uint8_t)*uwrq;
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (*uwrq >= 0 && *uwrq <= 0xFF)	/* 0-255 */
+		priv->gain.RxGain = (uint8_t) * uwrq;
 	else
-		return  -EINVAL;
+		return -EINVAL;
 
-	if(priv->gain.RxGain < 0xFF)
+	if (priv->gain.RxGain < 0xFF)
 		priv->gain.RxMode = 1;
 	else
 		priv->gain.RxMode = 0;
 
 	hostif_sme_enqueue(priv, SME_SET_GAIN);
-	return  0;
+	return 0;
 }
 
 /*------------------------------------------------------------------*/
 /* Private handler : get rx gain control value */
-static int ks_wlan_get_rx_gain(struct net_device *dev, struct iw_request_info *info,
-					     __u32 *uwrq, char *extra)
+static int ks_wlan_get_rx_gain(struct net_device *dev,
+			       struct iw_request_info *info, __u32 * uwrq,
+			       char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
-
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
 	*uwrq = priv->gain.RxGain;
 	hostif_sme_enqueue(priv, SME_GET_GAIN);
 	return 0;
 }
+
 #if 0
 /*------------------------------------------------------------------*/
 /* Private handler : set region value */
-static int ks_wlan_set_region(struct net_device *dev, struct iw_request_info *info,
-					     __u32 *uwrq, char *extra)
+static int ks_wlan_set_region(struct net_device *dev,
+			      struct iw_request_info *info, __u32 * uwrq,
+			      char *extra)
 {
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
-	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
-
-	if(*uwrq >= 0x9 && *uwrq <= 0xF) /* 0x9-0xf */
-		priv->region = (uint8_t)*uwrq;
+	if (priv->sleep_mode == SLP_SLEEP) {
+		return -EPERM;
+	}
+	/* for SLEEP MODE */
+	if (*uwrq >= 0x9 && *uwrq <= 0xF)	/* 0x9-0xf */
+		priv->region = (uint8_t) * uwrq;
 	else
-		return  -EINVAL;
+		return -EINVAL;
 
 	hostif_sme_enqueue(priv, SME_SET_REGION);
-	return  0;
+	return 0;
 }
 #endif
 
 /*------------------------------------------------------------------*/
 /* Private handler : get eeprom checksum result */
-static int ks_wlan_get_eeprom_cksum(struct net_device *dev, struct iw_request_info *info,
-					     __u32 *uwrq, char *extra)
+static int ks_wlan_get_eeprom_cksum(struct net_device *dev,
+				    struct iw_request_info *info, __u32 * uwrq,
+				    char *extra)
 {
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
 	*uwrq = priv->eeprom_checksum;
 	return 0;
 }
 
-static void print_hif_event(int event){
+static void print_hif_event(int event)
+{
 
-	switch(event){
-	case HIF_DATA_REQ	:
+	switch (event) {
+	case HIF_DATA_REQ:
 		printk("HIF_DATA_REQ\n");
 		break;
-	case HIF_DATA_IND	:
+	case HIF_DATA_IND:
 		printk("HIF_DATA_IND\n");
 		break;
-	case HIF_MIB_GET_REQ	:
+	case HIF_MIB_GET_REQ:
 		printk("HIF_MIB_GET_REQ\n");
 		break;
-	case HIF_MIB_GET_CONF	:
+	case HIF_MIB_GET_CONF:
 		printk("HIF_MIB_GET_CONF\n");
 		break;
-	case HIF_MIB_SET_REQ	:
+	case HIF_MIB_SET_REQ:
 		printk("HIF_MIB_SET_REQ\n");
 		break;
-	case HIF_MIB_SET_CONF	:
+	case HIF_MIB_SET_CONF:
 		printk("HIF_MIB_SET_CONF\n");
 		break;
-	case HIF_POWERMGT_REQ	:
+	case HIF_POWERMGT_REQ:
 		printk("HIF_POWERMGT_REQ\n");
 		break;
-	case HIF_POWERMGT_CONF	:
+	case HIF_POWERMGT_CONF:
 		printk("HIF_POWERMGT_CONF\n");
 		break;
-	case HIF_START_REQ	:
+	case HIF_START_REQ:
 		printk("HIF_START_REQ\n");
 		break;
-	case HIF_START_CONF	:
+	case HIF_START_CONF:
 		printk("HIF_START_CONF\n");
 		break;
-	case HIF_CONNECT_IND	:
+	case HIF_CONNECT_IND:
 		printk("HIF_CONNECT_IND\n");
 		break;
-	case HIF_STOP_REQ	:
+	case HIF_STOP_REQ:
 		printk("HIF_STOP_REQ\n");
 		break;
-	case HIF_STOP_CONF	:
+	case HIF_STOP_CONF:
 		printk("HIF_STOP_CONF\n");
 		break;
-	case HIF_PS_ADH_SET_REQ	:
+	case HIF_PS_ADH_SET_REQ:
 		printk("HIF_PS_ADH_SET_REQ\n");
 		break;
 	case HIF_PS_ADH_SET_CONF:
 		printk("HIF_PS_ADH_SET_CONF\n");
 		break;
-	case HIF_INFRA_SET_REQ	:
+	case HIF_INFRA_SET_REQ:
 		printk("HIF_INFRA_SET_REQ\n");
 		break;
-	case HIF_INFRA_SET_CONF	:
+	case HIF_INFRA_SET_CONF:
 		printk("HIF_INFRA_SET_CONF\n");
 		break;
-	case HIF_ADH_SET_REQ	:
+	case HIF_ADH_SET_REQ:
 		printk("HIF_ADH_SET_REQ\n");
 		break;
-	case HIF_ADH_SET_CONF	:
+	case HIF_ADH_SET_CONF:
 		printk("HIF_ADH_SET_CONF\n");
 		break;
-	case HIF_AP_SET_REQ	:
+	case HIF_AP_SET_REQ:
 		printk("HIF_AP_SET_REQ\n");
 		break;
-	case HIF_AP_SET_CONF	:
+	case HIF_AP_SET_CONF:
 		printk("HIF_AP_SET_CONF\n");
 		break;
-	case HIF_ASSOC_INFO_IND	:
+	case HIF_ASSOC_INFO_IND:
 		printk("HIF_ASSOC_INFO_IND\n");
 		break;
 	case HIF_MIC_FAILURE_REQ:
 		printk("HIF_MIC_FAILURE_REQ\n");
 		break;
-	case HIF_MIC_FAILURE_CONF	:
+	case HIF_MIC_FAILURE_CONF:
 		printk("HIF_MIC_FAILURE_CONF\n");
 		break;
-	case HIF_SCAN_REQ	:
+	case HIF_SCAN_REQ:
 		printk("HIF_SCAN_REQ\n");
 		break;
-	case HIF_SCAN_CONF	:
+	case HIF_SCAN_CONF:
 		printk("HIF_SCAN_CONF\n");
 		break;
-	case HIF_PHY_INFO_REQ	:
+	case HIF_PHY_INFO_REQ:
 		printk("HIF_PHY_INFO_REQ\n");
 		break;
-	case HIF_PHY_INFO_CONF	:
+	case HIF_PHY_INFO_CONF:
 		printk("HIF_PHY_INFO_CONF\n");
 		break;
-	case HIF_SLEEP_REQ	:
+	case HIF_SLEEP_REQ:
 		printk("HIF_SLEEP_REQ\n");
 		break;
-	case HIF_SLEEP_CONF	:
+	case HIF_SLEEP_CONF:
 		printk("HIF_SLEEP_CONF\n");
 		break;
-	case HIF_PHY_INFO_IND	:
+	case HIF_PHY_INFO_IND:
 		printk("HIF_PHY_INFO_IND\n");
 		break;
-	case HIF_SCAN_IND	:
+	case HIF_SCAN_IND:
 		printk("HIF_SCAN_IND\n");
 		break;
-	case HIF_INFRA_SET2_REQ	:
+	case HIF_INFRA_SET2_REQ:
 		printk("HIF_INFRA_SET2_REQ\n");
 		break;
 	case HIF_INFRA_SET2_CONF:
 		printk("HIF_INFRA_SET2_CONF\n");
 		break;
-	case HIF_ADH_SET2_REQ	:
+	case HIF_ADH_SET2_REQ:
 		printk("HIF_ADH_SET2_REQ\n");
 		break;
-	case HIF_ADH_SET2_CONF	:
+	case HIF_ADH_SET2_CONF:
 		printk("HIF_ADH_SET2_CONF\n");
 	}
 }
@@ -2729,13 +3112,16 @@ static void print_hif_event(int event){
 /*------------------------------------------------------------------*/
 /* Private handler : get host command history */
 static int ks_wlan_hostt(struct net_device *dev, struct iw_request_info *info,
-					     __u32 *uwrq, char *extra)
+			 __u32 * uwrq, char *extra)
 {
-	int i,event;
-	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
+	int i, event;
+	struct ks_wlan_private *priv =
+	    (struct ks_wlan_private *)netdev_priv(dev);
 
-	for(i = 63; i >= 0; i--){
-		event =	priv->hostt.buff[(priv->hostt.qtail -1 -i)%SME_EVENT_BUFF_SIZE] ;
+	for (i = 63; i >= 0; i--) {
+		event =
+		    priv->hostt.buff[(priv->hostt.qtail - 1 - i) %
+				     SME_EVENT_BUFF_SIZE];
 		print_hif_event(event);
 	}
 	return 0;
@@ -2745,190 +3131,213 @@ static int ks_wlan_hostt(struct net_device *dev, struct iw_request_info *info,
 
 static const struct iw_priv_args ks_wlan_private_args[] = {
 /*{ cmd, set_args, get_args, name[16] } */
-  { KS_WLAN_GET_DRIVER_VERSION, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | (128+1), "GetDriverVer" },
-  { KS_WLAN_GET_FIRM_VERSION,   IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | (128+1), "GetFirmwareVer" },
+	{KS_WLAN_GET_DRIVER_VERSION, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_CHAR | (128 + 1), "GetDriverVer"},
+	{KS_WLAN_GET_FIRM_VERSION, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_CHAR | (128 + 1), "GetFirmwareVer"},
 #ifdef WPS
-  { KS_WLAN_SET_WPS_ENABLE,     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetWPSEnable" },
-  { KS_WLAN_GET_WPS_ENABLE,     IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetW" },
-  { KS_WLAN_SET_WPS_PROBE_REQ, IW_PRIV_TYPE_BYTE | 2047, IW_PRIV_TYPE_NONE, "SetWPSProbeReq" },
+	{KS_WLAN_SET_WPS_ENABLE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 IW_PRIV_TYPE_NONE, "SetWPSEnable"},
+	{KS_WLAN_GET_WPS_ENABLE, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetW"},
+	{KS_WLAN_SET_WPS_PROBE_REQ, IW_PRIV_TYPE_BYTE | 2047, IW_PRIV_TYPE_NONE,
+	 "SetWPSProbeReq"},
 #endif /* WPS */
-  { KS_WLAN_SET_PREAMBLE,       IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetPreamble" },
-  { KS_WLAN_GET_PREAMBLE,       IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetPreamble" },
-  { KS_WLAN_SET_POWER_SAVE,     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetPowerSave" },
-  { KS_WLAN_GET_POWER_SAVE,     IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetPowerSave" },
-  { KS_WLAN_SET_SCAN_TYPE,      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetScanType" },
-  { KS_WLAN_GET_SCAN_TYPE,      IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetScanType" },
-  { KS_WLAN_SET_RX_GAIN,        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetRxGain" },
-  { KS_WLAN_GET_RX_GAIN,        IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetRxGain" },
-  { KS_WLAN_HOSTT,      	IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | (128+1), "hostt" },
-  { KS_WLAN_SET_BEACON_LOST,    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetBeaconLost" },
-  { KS_WLAN_GET_BEACON_LOST,    IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetBeaconLost" },
-  { KS_WLAN_SET_SLEEP_MODE,     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetSleepMode" },
-  { KS_WLAN_GET_SLEEP_MODE,     IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetSleepMode" },
-  { KS_WLAN_SET_TX_GAIN,        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetTxGain" },
-  { KS_WLAN_GET_TX_GAIN,        IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetTxGain" },
-  { KS_WLAN_SET_PHY_TYPE,       IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetPhyType" },
-  { KS_WLAN_GET_PHY_TYPE,       IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetPhyType" },
-  { KS_WLAN_SET_CTS_MODE,       IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetCtsMode" },
-  { KS_WLAN_GET_CTS_MODE,       IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetCtsMode" },
-  { KS_WLAN_GET_EEPROM_CKSUM,   IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetChecksum" },
+	{KS_WLAN_SET_PREAMBLE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 IW_PRIV_TYPE_NONE, "SetPreamble"},
+	{KS_WLAN_GET_PREAMBLE, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetPreamble"},
+	{KS_WLAN_SET_POWER_SAVE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 IW_PRIV_TYPE_NONE, "SetPowerSave"},
+	{KS_WLAN_GET_POWER_SAVE, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetPowerSave"},
+	{KS_WLAN_SET_SCAN_TYPE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 IW_PRIV_TYPE_NONE, "SetScanType"},
+	{KS_WLAN_GET_SCAN_TYPE, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetScanType"},
+	{KS_WLAN_SET_RX_GAIN, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 IW_PRIV_TYPE_NONE, "SetRxGain"},
+	{KS_WLAN_GET_RX_GAIN, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetRxGain"},
+	{KS_WLAN_HOSTT, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | (128 + 1),
+	 "hostt"},
+	{KS_WLAN_SET_BEACON_LOST, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 IW_PRIV_TYPE_NONE, "SetBeaconLost"},
+	{KS_WLAN_GET_BEACON_LOST, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetBeaconLost"},
+	{KS_WLAN_SET_SLEEP_MODE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 IW_PRIV_TYPE_NONE, "SetSleepMode"},
+	{KS_WLAN_GET_SLEEP_MODE, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetSleepMode"},
+	{KS_WLAN_SET_TX_GAIN, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 IW_PRIV_TYPE_NONE, "SetTxGain"},
+	{KS_WLAN_GET_TX_GAIN, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetTxGain"},
+	{KS_WLAN_SET_PHY_TYPE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 IW_PRIV_TYPE_NONE, "SetPhyType"},
+	{KS_WLAN_GET_PHY_TYPE, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetPhyType"},
+	{KS_WLAN_SET_CTS_MODE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 IW_PRIV_TYPE_NONE, "SetCtsMode"},
+	{KS_WLAN_GET_CTS_MODE, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetCtsMode"},
+	{KS_WLAN_GET_EEPROM_CKSUM, IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetChecksum"},
 };
-static const iw_handler		ks_wlan_handler[] =
-{
+
+static const iw_handler ks_wlan_handler[] = {
 	(iw_handler) ks_wlan_config_commit,	/* SIOCSIWCOMMIT */
-	(iw_handler) ks_wlan_get_name,		/* SIOCGIWNAME */
-	(iw_handler) NULL,			/* SIOCSIWNWID */
-	(iw_handler) NULL,			/* SIOCGIWNWID */
-	(iw_handler) ks_wlan_set_freq,		/* SIOCSIWFREQ */
-	(iw_handler) ks_wlan_get_freq,		/* SIOCGIWFREQ */
-	(iw_handler) ks_wlan_set_mode,		/* SIOCSIWMODE */
-	(iw_handler) ks_wlan_get_mode,		/* SIOCGIWMODE */
+	(iw_handler) ks_wlan_get_name,	/* SIOCGIWNAME */
+	(iw_handler) NULL,	/* SIOCSIWNWID */
+	(iw_handler) NULL,	/* SIOCGIWNWID */
+	(iw_handler) ks_wlan_set_freq,	/* SIOCSIWFREQ */
+	(iw_handler) ks_wlan_get_freq,	/* SIOCGIWFREQ */
+	(iw_handler) ks_wlan_set_mode,	/* SIOCSIWMODE */
+	(iw_handler) ks_wlan_get_mode,	/* SIOCGIWMODE */
 #ifndef KSC_OPNOTSUPP
-	(iw_handler) ks_wlan_set_sens,		/* SIOCSIWSENS */
-	(iw_handler) ks_wlan_get_sens,		/* SIOCGIWSENS */
+	(iw_handler) ks_wlan_set_sens,	/* SIOCSIWSENS */
+	(iw_handler) ks_wlan_get_sens,	/* SIOCGIWSENS */
 #else /* KSC_OPNOTSUPP */
-	(iw_handler) NULL,		        /* SIOCSIWSENS */
-	(iw_handler) NULL,		        /* SIOCGIWSENS */
+	(iw_handler) NULL,	/* SIOCSIWSENS */
+	(iw_handler) NULL,	/* SIOCGIWSENS */
 #endif /* KSC_OPNOTSUPP */
-	(iw_handler) NULL,			/* SIOCSIWRANGE */
-	(iw_handler) ks_wlan_get_range,		/* SIOCGIWRANGE */
-	(iw_handler) NULL,			/* SIOCSIWPRIV */
-	(iw_handler) NULL,			/* SIOCGIWPRIV */
-	(iw_handler) NULL,			/* SIOCSIWSTATS */
+	(iw_handler) NULL,	/* SIOCSIWRANGE */
+	(iw_handler) ks_wlan_get_range,	/* SIOCGIWRANGE */
+	(iw_handler) NULL,	/* SIOCSIWPRIV */
+	(iw_handler) NULL,	/* SIOCGIWPRIV */
+	(iw_handler) NULL,	/* SIOCSIWSTATS */
 	(iw_handler) ks_wlan_get_iwstats,	/* SIOCGIWSTATS */
-	(iw_handler) NULL,			/* SIOCSIWSPY */
-	(iw_handler) NULL,			/* SIOCGIWSPY */
-	(iw_handler) NULL,			/* SIOCSIWTHRSPY */
-	(iw_handler) NULL,			/* SIOCGIWTHRSPY */
-	(iw_handler) ks_wlan_set_wap,		/* SIOCSIWAP */
-	(iw_handler) ks_wlan_get_wap,		/* SIOCGIWAP */
-//	(iw_handler) NULL,			/* SIOCSIWMLME */
-	(iw_handler) ks_wlan_set_mlme,		/* SIOCSIWMLME */
+	(iw_handler) NULL,	/* SIOCSIWSPY */
+	(iw_handler) NULL,	/* SIOCGIWSPY */
+	(iw_handler) NULL,	/* SIOCSIWTHRSPY */
+	(iw_handler) NULL,	/* SIOCGIWTHRSPY */
+	(iw_handler) ks_wlan_set_wap,	/* SIOCSIWAP */
+	(iw_handler) ks_wlan_get_wap,	/* SIOCGIWAP */
+//      (iw_handler) NULL,                      /* SIOCSIWMLME */
+	(iw_handler) ks_wlan_set_mlme,	/* SIOCSIWMLME */
 	(iw_handler) ks_wlan_get_aplist,	/* SIOCGIWAPLIST */
-	(iw_handler) ks_wlan_set_scan,		/* SIOCSIWSCAN */
-	(iw_handler) ks_wlan_get_scan,		/* SIOCGIWSCAN */
-	(iw_handler) ks_wlan_set_essid,		/* SIOCSIWESSID */
-	(iw_handler) ks_wlan_get_essid,		/* SIOCGIWESSID */
-	(iw_handler) ks_wlan_set_nick,		/* SIOCSIWNICKN */
-	(iw_handler) ks_wlan_get_nick,		/* SIOCGIWNICKN */
-	(iw_handler) NULL,			/* -- hole -- */
-	(iw_handler) NULL,			/* -- hole -- */
-	(iw_handler) ks_wlan_set_rate,		/* SIOCSIWRATE */
-	(iw_handler) ks_wlan_get_rate,		/* SIOCGIWRATE */
-	(iw_handler) ks_wlan_set_rts,		/* SIOCSIWRTS */
-	(iw_handler) ks_wlan_get_rts,		/* SIOCGIWRTS */
-	(iw_handler) ks_wlan_set_frag,		/* SIOCSIWFRAG */
-	(iw_handler) ks_wlan_get_frag,		/* SIOCGIWFRAG */
+	(iw_handler) ks_wlan_set_scan,	/* SIOCSIWSCAN */
+	(iw_handler) ks_wlan_get_scan,	/* SIOCGIWSCAN */
+	(iw_handler) ks_wlan_set_essid,	/* SIOCSIWESSID */
+	(iw_handler) ks_wlan_get_essid,	/* SIOCGIWESSID */
+	(iw_handler) ks_wlan_set_nick,	/* SIOCSIWNICKN */
+	(iw_handler) ks_wlan_get_nick,	/* SIOCGIWNICKN */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) ks_wlan_set_rate,	/* SIOCSIWRATE */
+	(iw_handler) ks_wlan_get_rate,	/* SIOCGIWRATE */
+	(iw_handler) ks_wlan_set_rts,	/* SIOCSIWRTS */
+	(iw_handler) ks_wlan_get_rts,	/* SIOCGIWRTS */
+	(iw_handler) ks_wlan_set_frag,	/* SIOCSIWFRAG */
+	(iw_handler) ks_wlan_get_frag,	/* SIOCGIWFRAG */
 #ifndef KSC_OPNOTSUPP
-	(iw_handler) ks_wlan_set_txpow,		/* SIOCSIWTXPOW */
-	(iw_handler) ks_wlan_get_txpow,		/* SIOCGIWTXPOW */
-	(iw_handler) ks_wlan_set_retry,		/* SIOCSIWRETRY */
-	(iw_handler) ks_wlan_get_retry,		/* SIOCGIWRETRY */
+	(iw_handler) ks_wlan_set_txpow,	/* SIOCSIWTXPOW */
+	(iw_handler) ks_wlan_get_txpow,	/* SIOCGIWTXPOW */
+	(iw_handler) ks_wlan_set_retry,	/* SIOCSIWRETRY */
+	(iw_handler) ks_wlan_get_retry,	/* SIOCGIWRETRY */
 #else /* KSC_OPNOTSUPP */
-	(iw_handler) NULL,    		        /* SIOCSIWTXPOW */
-	(iw_handler) NULL,		        /* SIOCGIWTXPOW */
-	(iw_handler) NULL,		        /* SIOCSIWRETRY */
-	(iw_handler) NULL,		        /* SIOCGIWRETRY */
+	(iw_handler) NULL,	/* SIOCSIWTXPOW */
+	(iw_handler) NULL,	/* SIOCGIWTXPOW */
+	(iw_handler) NULL,	/* SIOCSIWRETRY */
+	(iw_handler) NULL,	/* SIOCGIWRETRY */
 #endif /* KSC_OPNOTSUPP */
 	(iw_handler) ks_wlan_set_encode,	/* SIOCSIWENCODE */
 	(iw_handler) ks_wlan_get_encode,	/* SIOCGIWENCODE */
-	(iw_handler) ks_wlan_set_power,		/* SIOCSIWPOWER */
-	(iw_handler) ks_wlan_get_power,		/* SIOCGIWPOWER */
-	(iw_handler) NULL,			/* -- hole -- */
-	(iw_handler) NULL,			/* -- hole -- */
-//	(iw_handler) NULL,			/* SIOCSIWGENIE */
-	(iw_handler) ks_wlan_set_genie,		/* SIOCSIWGENIE */
-	(iw_handler) NULL,			/* SIOCGIWGENIE */
+	(iw_handler) ks_wlan_set_power,	/* SIOCSIWPOWER */
+	(iw_handler) ks_wlan_get_power,	/* SIOCGIWPOWER */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+//      (iw_handler) NULL,                      /* SIOCSIWGENIE */
+	(iw_handler) ks_wlan_set_genie,	/* SIOCSIWGENIE */
+	(iw_handler) NULL,	/* SIOCGIWGENIE */
 	(iw_handler) ks_wlan_set_auth_mode,	/* SIOCSIWAUTH */
 	(iw_handler) ks_wlan_get_auth_mode,	/* SIOCGIWAUTH */
 	(iw_handler) ks_wlan_set_encode_ext,	/* SIOCSIWENCODEEXT */
 	(iw_handler) ks_wlan_get_encode_ext,	/* SIOCGIWENCODEEXT */
-	(iw_handler) ks_wlan_set_pmksa,		/* SIOCSIWPMKSA */
-	(iw_handler) NULL,			/* -- hole -- */
+	(iw_handler) ks_wlan_set_pmksa,	/* SIOCSIWPMKSA */
+	(iw_handler) NULL,	/* -- hole -- */
 };
 
 /* private_handler */
-static const iw_handler		ks_wlan_private_handler[] =
-{
-	(iw_handler) NULL,				/*  0 */
+static const iw_handler ks_wlan_private_handler[] = {
+	(iw_handler) NULL,	/*  0 */
 	(iw_handler) ks_wlan_get_driver_version,	/*  1 KS_WLAN_GET_DRIVER_VERSION */
-	(iw_handler) NULL,				/*  2 */
+	(iw_handler) NULL,	/*  2 */
 	(iw_handler) ks_wlan_get_firmware_version,	/*  3 KS_WLAN_GET_FIRM_VERSION */
 #ifdef WPS
-	(iw_handler) ks_wlan_set_wps_enable, 		/*  4 KS_WLAN_SET_WPS_ENABLE  */
-	(iw_handler) ks_wlan_get_wps_enable, 		/*  5 KS_WLAN_GET_WPS_ENABLE  */
-	(iw_handler) ks_wlan_set_wps_probe_req, 	/*  6 KS_WLAN_SET_WPS_PROBE_REQ */
+	(iw_handler) ks_wlan_set_wps_enable,	/*  4 KS_WLAN_SET_WPS_ENABLE  */
+	(iw_handler) ks_wlan_get_wps_enable,	/*  5 KS_WLAN_GET_WPS_ENABLE  */
+	(iw_handler) ks_wlan_set_wps_probe_req,	/*  6 KS_WLAN_SET_WPS_PROBE_REQ */
 #else
-	(iw_handler) NULL,				/*  4 */
-	(iw_handler) NULL,				/*  5 */
-	(iw_handler) NULL,				/*  6 */
+	(iw_handler) NULL,	/*  4 */
+	(iw_handler) NULL,	/*  5 */
+	(iw_handler) NULL,	/*  6 */
 #endif /* WPS */
 
-	(iw_handler) ks_wlan_get_eeprom_cksum,		/*  7 KS_WLAN_GET_CONNECT */
-	(iw_handler) ks_wlan_set_preamble,		/*  8 KS_WLAN_SET_PREAMBLE */
-	(iw_handler) ks_wlan_get_preamble,		/*  9 KS_WLAN_GET_PREAMBLE */
-	(iw_handler) ks_wlan_set_powermgt,		/* 10 KS_WLAN_SET_POWER_SAVE */
-	(iw_handler) ks_wlan_get_powermgt,		/* 11 KS_WLAN_GET_POWER_SAVE */
-	(iw_handler) ks_wlan_set_scan_type,		/* 12 KS_WLAN_SET_SCAN_TYPE */
-	(iw_handler) ks_wlan_get_scan_type,		/* 13 KS_WLAN_GET_SCAN_TYPE */
-	(iw_handler) ks_wlan_set_rx_gain,		/* 14 KS_WLAN_SET_RX_GAIN */
-	(iw_handler) ks_wlan_get_rx_gain,		/* 15 KS_WLAN_GET_RX_GAIN */
-	(iw_handler) ks_wlan_hostt,			/* 16 KS_WLAN_HOSTT */
-	(iw_handler) NULL,				/* 17 */
-	(iw_handler) ks_wlan_set_beacon_lost,		/* 18 KS_WLAN_SET_BECAN_LOST */
-	(iw_handler) ks_wlan_get_beacon_lost,		/* 19 KS_WLAN_GET_BECAN_LOST */
-	(iw_handler) ks_wlan_set_tx_gain,		/* 20 KS_WLAN_SET_TX_GAIN */
-	(iw_handler) ks_wlan_get_tx_gain,		/* 21 KS_WLAN_GET_TX_GAIN */
-	(iw_handler) ks_wlan_set_phy_type,		/* 22 KS_WLAN_SET_PHY_TYPE */
-	(iw_handler) ks_wlan_get_phy_type,		/* 23 KS_WLAN_GET_PHY_TYPE */
-	(iw_handler) ks_wlan_set_cts_mode,		/* 24 KS_WLAN_SET_CTS_MODE */
-	(iw_handler) ks_wlan_get_cts_mode,		/* 25 KS_WLAN_GET_CTS_MODE */
-	(iw_handler) NULL,				/* 26 */
-	(iw_handler) NULL,				/* 27 */
- 	(iw_handler) ks_wlan_set_sleep_mode,		/* 28 KS_WLAN_SET_SLEEP_MODE */
- 	(iw_handler) ks_wlan_get_sleep_mode,		/* 29 KS_WLAN_GET_SLEEP_MODE */
-	(iw_handler) NULL,				/* 30 */
-	(iw_handler) NULL,				/* 31 */
+	(iw_handler) ks_wlan_get_eeprom_cksum,	/*  7 KS_WLAN_GET_CONNECT */
+	(iw_handler) ks_wlan_set_preamble,	/*  8 KS_WLAN_SET_PREAMBLE */
+	(iw_handler) ks_wlan_get_preamble,	/*  9 KS_WLAN_GET_PREAMBLE */
+	(iw_handler) ks_wlan_set_powermgt,	/* 10 KS_WLAN_SET_POWER_SAVE */
+	(iw_handler) ks_wlan_get_powermgt,	/* 11 KS_WLAN_GET_POWER_SAVE */
+	(iw_handler) ks_wlan_set_scan_type,	/* 12 KS_WLAN_SET_SCAN_TYPE */
+	(iw_handler) ks_wlan_get_scan_type,	/* 13 KS_WLAN_GET_SCAN_TYPE */
+	(iw_handler) ks_wlan_set_rx_gain,	/* 14 KS_WLAN_SET_RX_GAIN */
+	(iw_handler) ks_wlan_get_rx_gain,	/* 15 KS_WLAN_GET_RX_GAIN */
+	(iw_handler) ks_wlan_hostt,	/* 16 KS_WLAN_HOSTT */
+	(iw_handler) NULL,	/* 17 */
+	(iw_handler) ks_wlan_set_beacon_lost,	/* 18 KS_WLAN_SET_BECAN_LOST */
+	(iw_handler) ks_wlan_get_beacon_lost,	/* 19 KS_WLAN_GET_BECAN_LOST */
+	(iw_handler) ks_wlan_set_tx_gain,	/* 20 KS_WLAN_SET_TX_GAIN */
+	(iw_handler) ks_wlan_get_tx_gain,	/* 21 KS_WLAN_GET_TX_GAIN */
+	(iw_handler) ks_wlan_set_phy_type,	/* 22 KS_WLAN_SET_PHY_TYPE */
+	(iw_handler) ks_wlan_get_phy_type,	/* 23 KS_WLAN_GET_PHY_TYPE */
+	(iw_handler) ks_wlan_set_cts_mode,	/* 24 KS_WLAN_SET_CTS_MODE */
+	(iw_handler) ks_wlan_get_cts_mode,	/* 25 KS_WLAN_GET_CTS_MODE */
+	(iw_handler) NULL,	/* 26 */
+	(iw_handler) NULL,	/* 27 */
+	(iw_handler) ks_wlan_set_sleep_mode,	/* 28 KS_WLAN_SET_SLEEP_MODE */
+	(iw_handler) ks_wlan_get_sleep_mode,	/* 29 KS_WLAN_GET_SLEEP_MODE */
+	(iw_handler) NULL,	/* 30 */
+	(iw_handler) NULL,	/* 31 */
 };
 
-static const struct iw_handler_def	ks_wlan_handler_def =
-{
-	.num_standard	= sizeof(ks_wlan_handler)/sizeof(iw_handler),
-	.num_private	= sizeof(ks_wlan_private_handler)/sizeof(iw_handler),
-	.num_private_args = sizeof(ks_wlan_private_args)/sizeof(struct iw_priv_args),
-	.standard	= (iw_handler *) ks_wlan_handler,
-	.private	= (iw_handler *) ks_wlan_private_handler,
-	.private_args	= (struct iw_priv_args *) ks_wlan_private_args,
+static const struct iw_handler_def ks_wlan_handler_def = {
+	.num_standard = sizeof(ks_wlan_handler) / sizeof(iw_handler),
+	.num_private = sizeof(ks_wlan_private_handler) / sizeof(iw_handler),
+	.num_private_args =
+	    sizeof(ks_wlan_private_args) / sizeof(struct iw_priv_args),
+	.standard = (iw_handler *) ks_wlan_handler,
+	.private = (iw_handler *) ks_wlan_private_handler,
+	.private_args = (struct iw_priv_args *)ks_wlan_private_args,
 	.get_wireless_stats = ks_get_wireless_stats,
 };
 
-
-static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq,
+				int cmd)
 {
 	int rc = 0;
-	struct iwreq *wrq = (struct iwreq *) rq;
+	struct iwreq *wrq = (struct iwreq *)rq;
 	switch (cmd) {
-	case SIOCIWFIRSTPRIV+20: /* KS_WLAN_SET_STOP_REQ */
+	case SIOCIWFIRSTPRIV + 20:	/* KS_WLAN_SET_STOP_REQ */
 		rc = ks_wlan_set_stop_request(dev, NULL, &(wrq->u.mode), NULL);
 		break;
-	// All other calls are currently unsupported
+		// All other calls are currently unsupported
 	default:
 		rc = -EOPNOTSUPP;
 	}
 
-	DPRINTK(5,"return=%d\n",rc);
+	DPRINTK(5, "return=%d\n", rc);
 	return rc;
 }
 
-
 static
 struct net_device_stats *ks_wlan_get_stats(struct net_device *dev)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->dev_state < DEVICE_STATE_READY) {
-				return NULL; /* not finished initialize */
-		}
+		return NULL;	/* not finished initialize */
+	}
 
 	return &priv->nstats;
 }
@@ -2937,7 +3346,7 @@ static
 int ks_wlan_set_mac_address(struct net_device *dev, void *addr)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
-	struct sockaddr *mac_addr=(struct sockaddr *)addr;
+	struct sockaddr *mac_addr = (struct sockaddr *)addr;
 	if (netif_running(dev))
 		return -EBUSY;
 	memcpy(dev->dev_addr, mac_addr->sa_data, dev->addr_len);
@@ -2945,20 +3354,21 @@ int ks_wlan_set_mac_address(struct net_device *dev, void *addr)
 
 	priv->mac_address_valid = 0;
 	hostif_sme_enqueue(priv, SME_MACADDRESS_SET_REQUEST);
-	printk(KERN_INFO "ks_wlan: MAC ADDRESS = %02x:%02x:%02x:%02x:%02x:%02x\n",
-			   priv->eth_addr[0],priv->eth_addr[1],priv->eth_addr[2],
-			   priv->eth_addr[3],priv->eth_addr[4],priv->eth_addr[5]);
+	printk(KERN_INFO
+	       "ks_wlan: MAC ADDRESS = %02x:%02x:%02x:%02x:%02x:%02x\n",
+	       priv->eth_addr[0], priv->eth_addr[1], priv->eth_addr[2],
+	       priv->eth_addr[3], priv->eth_addr[4], priv->eth_addr[5]);
 	return 0;
 }
 
-
 static
 void ks_wlan_tx_timeout(struct net_device *dev)
 {
-		struct ks_wlan_private *priv = netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(1,"head(%d) tail(%d)!!\n",priv->tx_dev.qhead, priv->tx_dev.qtail);
-	if(!netif_queue_stopped(dev)){
+	DPRINTK(1, "head(%d) tail(%d)!!\n", priv->tx_dev.qhead,
+		priv->tx_dev.qtail);
+	if (!netif_queue_stopped(dev)) {
 		netif_stop_queue(dev);
 	}
 	priv->nstats.tx_errors++;
@@ -2973,26 +3383,26 @@ int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct ks_wlan_private *priv = netdev_priv(dev);
 	int rc = 0;
 
-	DPRINTK(3,"in_interrupt()=%ld\n",in_interrupt());
+	DPRINTK(3, "in_interrupt()=%ld\n", in_interrupt());
 
-	if ( skb == NULL ) {
-		printk( KERN_ERR "ks_wlan:  skb == NULL!!!\n" );
+	if (skb == NULL) {
+		printk(KERN_ERR "ks_wlan:  skb == NULL!!!\n");
 		return 0;
 	}
 	if (priv->dev_state < DEVICE_STATE_READY) {
 		dev_kfree_skb(skb);
-		return 0; /* not finished initialize */
-		}
+		return 0;	/* not finished initialize */
+	}
 
-	if(netif_running(dev))
+	if (netif_running(dev))
 		netif_stop_queue(dev);
 
 	rc = hostif_data_request(priv, skb);
 	dev->trans_start = jiffies;
 
-	DPRINTK(4,"rc=%d\n",rc);
-	if (rc){
-		rc=0;
+	DPRINTK(4, "rc=%d\n", rc);
+	if (rc) {
+		rc = 0;
 	}
 
 	return rc;
@@ -3003,17 +3413,17 @@ void send_packet_complete(void *arg1, void *arg2)
 	struct ks_wlan_private *priv = (struct ks_wlan_private *)arg1;
 	struct sk_buff *packet = (struct sk_buff *)arg2;
 
-		DPRINTK(3,"\n");
+	DPRINTK(3, "\n");
 
-		priv->nstats.tx_bytes += packet->len;
+	priv->nstats.tx_bytes += packet->len;
 	priv->nstats.tx_packets++;
 
-	if(netif_queue_stopped(priv->net_dev))
-			netif_wake_queue(priv->net_dev);
+	if (netif_queue_stopped(priv->net_dev))
+		netif_wake_queue(priv->net_dev);
 
-	if(packet){
+	if (packet) {
 		dev_kfree_skb(packet);
-		packet=NULL;
+		packet = NULL;
 	}
 
 }
@@ -3025,9 +3435,9 @@ void ks_wlan_set_multicast_list(struct net_device *dev)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
-	DPRINTK(4,"\n");
+	DPRINTK(4, "\n");
 	if (priv->dev_state < DEVICE_STATE_READY) {
-				return ; /* not finished initialize */
+		return;	/* not finished initialize */
 	}
 	hostif_sme_enqueue(priv, SME_MULTICAST_REQUEST);
 
@@ -3041,12 +3451,11 @@ int ks_wlan_open(struct net_device *dev)
 
 	priv->cur_rx = 0;
 
-	if(!priv->mac_address_valid){
+	if (!priv->mac_address_valid) {
 		printk(KERN_ERR "ks_wlan : %s Not READY !!\n", dev->name);
 		return -EBUSY;
-	}
-	else
-		netif_start_queue (dev);
+	} else
+		netif_start_queue(dev);
 
 	return 0;
 }
@@ -3055,7 +3464,7 @@ static
 int ks_wlan_close(struct net_device *dev)
 {
 
-	netif_stop_queue (dev);
+	netif_stop_queue(dev);
 
 	DPRINTK(4, "%s: Shutting down ethercard, status was 0x%4.4x.\n",
 		dev->name, 0x00);
@@ -3063,21 +3472,21 @@ int ks_wlan_close(struct net_device *dev)
 	return 0;
 }
 
-
 /* Operational parameters that usually are not changed. */
 /* Time in jiffies before concluding the transmitter is hung. */
 #define TX_TIMEOUT  (3*HZ)
-static const unsigned char dummy_addr[] = {0x00,0x0b,0xe3,0x00,0x00,0x00};
+static const unsigned char dummy_addr[] =
+    { 0x00, 0x0b, 0xe3, 0x00, 0x00, 0x00 };
 
 static const struct net_device_ops ks_wlan_netdev_ops = {
-	.ndo_start_xmit         = ks_wlan_start_xmit,
-	.ndo_open               = ks_wlan_open,
-	.ndo_stop               = ks_wlan_close,
-	.ndo_do_ioctl           = ks_wlan_netdev_ioctl,
-	.ndo_set_mac_address    = ks_wlan_set_mac_address,
-	.ndo_get_stats 		= ks_wlan_get_stats,
-	.ndo_tx_timeout         = ks_wlan_tx_timeout,
-	.ndo_set_rx_mode        = ks_wlan_set_multicast_list,
+	.ndo_start_xmit = ks_wlan_start_xmit,
+	.ndo_open = ks_wlan_open,
+	.ndo_stop = ks_wlan_close,
+	.ndo_do_ioctl = ks_wlan_netdev_ioctl,
+	.ndo_set_mac_address = ks_wlan_set_mac_address,
+	.ndo_get_stats = ks_wlan_get_stats,
+	.ndo_tx_timeout = ks_wlan_tx_timeout,
+	.ndo_set_rx_mode = ks_wlan_set_multicast_list,
 };
 
 int ks_wlan_net_start(struct net_device *dev)
@@ -3092,9 +3501,9 @@ int ks_wlan_net_start(struct net_device *dev)
 	priv->device_open_status = 1;
 
 	/* phy information update timer */
-	atomic_set(&update_phyinfo,0);
+	atomic_set(&update_phyinfo, 0);
 	init_timer(&update_phyinfo_timer);
-	update_phyinfo_timer.function=ks_wlan_update_phyinfo_timeout;
+	update_phyinfo_timer.function = ks_wlan_update_phyinfo_timeout;
 	update_phyinfo_timer.data = (unsigned long)priv;
 
 	/* dummy address set */
@@ -3118,7 +3527,6 @@ int ks_wlan_net_start(struct net_device *dev)
 	return 0;
 }
 
-
 int ks_wlan_net_stop(struct net_device *dev)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
@@ -3127,7 +3535,7 @@ int ks_wlan_net_stop(struct net_device *dev)
 	priv->device_open_status = 0;
 	del_timer_sync(&update_phyinfo_timer);
 
-	if(netif_running(dev))
+	if (netif_running(dev))
 		netif_stop_queue(dev);
 
 	return ret;

commit feedcf1a5f3d4fc964d9f7b4d755fc0992378abf
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:26 2016 +0200

    staging: ks7010: remove unecessary typedef
    
    Let's simply specify the struct to keep in sync with kernel coding
    style.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 1da2768ea9f3..ec5c452f3672 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -73,7 +73,7 @@ static const struct iw_handler_def	ks_wlan_handler_def;
 /*
  *	function prototypes
  */
-extern int ks_wlan_hw_tx(ks_wlan_private *priv, void *p, unsigned long size,
+extern int ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,
 			void (*complete_handler)(void *arg1, void *arg2),
 			void *arg1,
 			void *arg2 );
@@ -89,7 +89,7 @@ static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cm
 static atomic_t update_phyinfo;
 static struct timer_list update_phyinfo_timer;
 static
-int ks_wlan_update_phy_information(ks_wlan_private *priv)
+int ks_wlan_update_phy_information(struct ks_wlan_private *priv)
 {
 		struct iw_statistics *wstats = &priv->wstats;
 
@@ -126,7 +126,7 @@ void ks_wlan_update_phyinfo_timeout(unsigned long ptr)
 	atomic_set(&update_phyinfo,0);
 }
 
-int ks_wlan_setup_parameter(ks_wlan_private *priv, unsigned int commit_flag)
+int ks_wlan_setup_parameter(struct ks_wlan_private *priv, unsigned int commit_flag)
 {
 	DPRINTK(2,"\n");
 
@@ -183,7 +183,7 @@ int ks_wlan_setup_parameter(ks_wlan_private *priv, unsigned int commit_flag)
 static int ks_wlan_get_name(struct net_device *dev, struct iw_request_info *info,
 				char *cwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *) netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *) netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -208,7 +208,7 @@ static int ks_wlan_get_name(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_set_freq(struct net_device *dev, struct iw_request_info *info,
 				struct iw_freq *fwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	int rc = -EINPROGRESS;		/* Call commit handler */
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
@@ -250,7 +250,7 @@ static int ks_wlan_set_freq(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_get_freq(struct net_device *dev, struct iw_request_info *info,
 				struct iw_freq *fwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	int f;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
@@ -271,7 +271,7 @@ static int ks_wlan_get_freq(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_set_essid(struct net_device *dev, struct iw_request_info *info,
 				 struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	size_t len;
 
 	DPRINTK(2," %d\n", dwrq->flags);
@@ -326,7 +326,7 @@ static int ks_wlan_set_essid(struct net_device *dev, struct iw_request_info *inf
 static int ks_wlan_get_essid(struct net_device *dev, struct iw_request_info *info,
 				 struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -366,7 +366,7 @@ static int ks_wlan_get_essid(struct net_device *dev, struct iw_request_info *inf
 static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 			   struct sockaddr *ap_addr, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	DPRINTK(2,"\n");
 
@@ -402,7 +402,7 @@ static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
 static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 			   struct sockaddr *awrq, char *extra)
 {
-		ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+		struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -423,7 +423,7 @@ static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
 static int ks_wlan_set_nick(struct net_device *dev, struct iw_request_info *info,
 				struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -442,7 +442,7 @@ static int ks_wlan_set_nick(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_get_nick(struct net_device *dev, struct iw_request_info *info,
 				struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -458,7 +458,7 @@ static int ks_wlan_get_nick(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_set_rate(struct net_device *dev, struct iw_request_info *info,
 				struct iw_param *vwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	int i = 0;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
@@ -609,7 +609,7 @@ static int ks_wlan_set_rate(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_get_rate(struct net_device *dev, struct iw_request_info *info,
 				struct iw_param *vwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	DPRINTK(2, "in_interrupt = %ld update_phyinfo = %d\n",
 		in_interrupt(),atomic_read(&update_phyinfo));
@@ -633,7 +633,7 @@ static int ks_wlan_get_rate(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
 			   struct iw_param *vwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	int rthr = vwrq->value;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
@@ -654,7 +654,7 @@ static int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
 static int ks_wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
 			   struct iw_param *vwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -670,7 +670,7 @@ static int ks_wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
 static int ks_wlan_set_frag(struct net_device *dev, struct iw_request_info *info,
 				struct iw_param *vwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	int fthr = vwrq->value;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
@@ -692,7 +692,7 @@ static int ks_wlan_set_frag(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_get_frag(struct net_device *dev, struct iw_request_info *info,
 				struct iw_param *vwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -708,7 +708,7 @@ static int ks_wlan_get_frag(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_set_mode(struct net_device *dev, struct iw_request_info *info,
 				__u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	DPRINTK(2,"mode=%d\n",*uwrq);
 
@@ -740,7 +740,7 @@ static int ks_wlan_set_mode(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_get_mode(struct net_device *dev, struct iw_request_info *info,
 				__u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -764,7 +764,7 @@ static int ks_wlan_get_mode(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_set_encode(struct net_device *dev, struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	wep_key_t key;
 	int index = (dwrq->flags & IW_ENCODE_INDEX);
@@ -878,7 +878,7 @@ static int ks_wlan_set_encode(struct net_device *dev, struct iw_request_info *in
 static int ks_wlan_get_encode(struct net_device *dev, struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	char zeros[16];
 	int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
 
@@ -974,7 +974,7 @@ static int ks_wlan_get_retry(struct net_device *dev, struct iw_request_info *inf
 static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *info,
 				 struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	struct iw_range *range = (struct iw_range *) extra;
 	int i,k;
 
@@ -1105,7 +1105,7 @@ static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *inf
 static int ks_wlan_set_power(struct net_device *dev, struct iw_request_info *info,
 				 struct iw_param *vwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	short enabled;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
@@ -1136,7 +1136,7 @@ static int ks_wlan_set_power(struct net_device *dev, struct iw_request_info *inf
 static int ks_wlan_get_power(struct net_device *dev, struct iw_request_info *info,
 				 struct iw_param *vwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -1153,7 +1153,7 @@ static int ks_wlan_get_power(struct net_device *dev, struct iw_request_info *inf
 static int ks_wlan_get_iwstats(struct net_device *dev, struct iw_request_info *info,
 				 struct iw_quality *vwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -1194,7 +1194,7 @@ static int ks_wlan_get_sens(struct net_device *dev, struct iw_request_info *info
 static int ks_wlan_get_aplist(struct net_device *dev, struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	struct sockaddr *address = (struct sockaddr *) extra;
 	struct iw_quality qual[LOCAL_APLIST_MAX];
 
@@ -1225,7 +1225,7 @@ static int ks_wlan_get_aplist(struct net_device *dev, struct iw_request_info *in
 static int ks_wlan_set_scan(struct net_device *dev, struct iw_request_info *info,
 				union iwreq_data *wrqu, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	struct iw_scan_req *req = NULL;
 	DPRINTK(2,"\n");
 
@@ -1257,7 +1257,7 @@ static int ks_wlan_set_scan(struct net_device *dev, struct iw_request_info *info
 static inline char *ks_wlan_translate_scan(struct net_device *dev, struct iw_request_info *info, char *current_ev,
 					   char *end_buf, struct local_ap_t *ap)
 {
-	/* ks_wlan_private *priv = (ks_wlan_private *)dev->priv; */
+	/* struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv; */
 	struct iw_event	iwe;		/* Temporary buffer */
 	u16 capabilities;
 	char *current_val;	/* For rates */
@@ -1393,7 +1393,7 @@ static inline char *ks_wlan_translate_scan(struct net_device *dev, struct iw_req
 static int ks_wlan_get_scan(struct net_device *dev, struct iw_request_info *info,
 				struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	int i;
 	char *current_ev = extra;
 	DPRINTK(2,"\n");
@@ -1448,7 +1448,7 @@ DPRINTK(2,"aplist 0\n");
 static int ks_wlan_config_commit(struct net_device *dev, struct iw_request_info *info,
 				 void *zwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (!priv->need_commit)
 		return 0;
@@ -1463,7 +1463,7 @@ static int ks_wlan_config_commit(struct net_device *dev, struct iw_request_info
 static int ks_wlan_set_genie(struct net_device *dev, struct iw_request_info *info,
 				 struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	DPRINTK(2, "\n");
 
@@ -1478,7 +1478,7 @@ static int ks_wlan_set_genie(struct net_device *dev, struct iw_request_info *inf
 static int ks_wlan_set_auth_mode(struct net_device *dev, struct iw_request_info *info,
 				 struct iw_param *vwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	int index = (vwrq->flags & IW_AUTH_INDEX);
 	int value = vwrq->value;
 
@@ -1614,7 +1614,7 @@ static int ks_wlan_set_auth_mode(struct net_device *dev, struct iw_request_info
 static int ks_wlan_get_auth_mode(struct net_device *dev, struct iw_request_info *info,
 				 struct iw_param *vwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	int index = (vwrq->flags & IW_AUTH_INDEX);
 	DPRINTK(2,"index=%d\n",index);
 
@@ -1655,7 +1655,7 @@ static int ks_wlan_get_auth_mode(struct net_device *dev, struct iw_request_info
 static int ks_wlan_set_encode_ext(struct net_device *dev, struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	struct iw_encode_ext *enc;
 	int index = dwrq->flags & IW_ENCODE_INDEX;
 	unsigned int commit=0;
@@ -1761,12 +1761,12 @@ static int ks_wlan_set_encode_ext(struct net_device *dev, struct iw_request_info
 static int ks_wlan_get_encode_ext(struct net_device *dev, struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
 	/*  WPA (not used ?? wpa_supplicant)
-	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 	struct iw_encode_ext *enc;
 	enc = (struct iw_encode_ext *)extra;
 	int index = dwrq->flags & IW_ENCODE_INDEX;
@@ -1779,7 +1779,7 @@ static int ks_wlan_get_encode_ext(struct net_device *dev, struct iw_request_info
 static int ks_wlan_set_pmksa(struct net_device *dev, struct iw_request_info *info,
 				 struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	struct iw_pmksa *pmksa ;
 	int i;
 	struct pmk_t *pmk;
@@ -1874,7 +1874,7 @@ static int ks_wlan_set_pmksa(struct net_device *dev, struct iw_request_info *inf
 static struct iw_statistics *ks_get_wireless_stats(struct net_device *dev)
 {
 
-	ks_wlan_private *priv = (ks_wlan_private *) netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *) netdev_priv(dev);
 		struct iw_statistics *wstats = &priv->wstats;
 
 	if(!atomic_read(&update_phyinfo)){
@@ -1901,7 +1901,7 @@ static struct iw_statistics *ks_get_wireless_stats(struct net_device *dev)
 static int ks_wlan_set_stop_request(struct net_device *dev, struct iw_request_info *info,
 				    __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	DPRINTK(2,"\n");
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
@@ -1919,7 +1919,7 @@ static int ks_wlan_set_stop_request(struct net_device *dev, struct iw_request_in
 static int ks_wlan_set_mlme(struct net_device *dev, struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	struct iw_mlme *mlme = (struct iw_mlme *)extra;
 	__u32 mode;
 
@@ -1955,7 +1955,7 @@ static int ks_wlan_get_driver_version(struct net_device *dev, struct iw_request_
 static int ks_wlan_get_firmware_version(struct net_device *dev, struct iw_request_info *info,
 					struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	strcpy(extra, &(priv->firmware_version[0]));
 	dwrq->length = priv->version_size+1;
 	return 0;
@@ -1967,7 +1967,7 @@ static int ks_wlan_get_firmware_version(struct net_device *dev, struct iw_reques
 static int ks_wlan_set_detach(struct net_device *dev, struct iw_request_info *info,
 				  __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -1988,7 +1988,7 @@ static int ks_wlan_set_detach(struct net_device *dev, struct iw_request_info *in
 static int ks_wlan_get_detach(struct net_device *dev, struct iw_request_info *info,
 				  __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2001,7 +2001,7 @@ static int ks_wlan_get_detach(struct net_device *dev, struct iw_request_info *in
 static int ks_wlan_get_connect(struct net_device *dev, struct iw_request_info *info,
 				   __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2015,7 +2015,7 @@ static int ks_wlan_get_connect(struct net_device *dev, struct iw_request_info *i
 static int ks_wlan_set_preamble(struct net_device *dev, struct iw_request_info *info,
 				__u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2036,7 +2036,7 @@ static int ks_wlan_set_preamble(struct net_device *dev, struct iw_request_info *
 static int ks_wlan_get_preamble(struct net_device *dev, struct iw_request_info *info,
 				__u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2049,7 +2049,7 @@ static int ks_wlan_get_preamble(struct net_device *dev, struct iw_request_info *
 static int ks_wlan_set_powermgt(struct net_device *dev, struct iw_request_info *info,
 				__u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2078,7 +2078,7 @@ static int ks_wlan_set_powermgt(struct net_device *dev, struct iw_request_info *
 static int ks_wlan_get_powermgt(struct net_device *dev, struct iw_request_info *info,
 				__u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2091,7 +2091,7 @@ static int ks_wlan_get_powermgt(struct net_device *dev, struct iw_request_info *
 static int ks_wlan_set_scan_type(struct net_device *dev, struct iw_request_info *info,
 				 __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2110,7 +2110,7 @@ static int ks_wlan_set_scan_type(struct net_device *dev, struct iw_request_info
 static int ks_wlan_get_scan_type(struct net_device *dev, struct iw_request_info *info,
 				 __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2123,7 +2123,7 @@ static int ks_wlan_get_scan_type(struct net_device *dev, struct iw_request_info
 static int ks_wlan_data_write(struct net_device *dev, struct iw_request_info *info,
 				  struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 	unsigned char *wbuff = NULL;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
@@ -2144,7 +2144,7 @@ static int ks_wlan_data_write(struct net_device *dev, struct iw_request_info *in
 static int ks_wlan_data_read(struct net_device *dev, struct iw_request_info *info,
 				 struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 	unsigned short read_length;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
@@ -2200,7 +2200,7 @@ static int ks_wlan_data_read(struct net_device *dev, struct iw_request_info *inf
 static int ks_wlan_get_wep_ascii(struct net_device *dev, struct iw_request_info *info,
 				 struct iw_point *dwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 	int i,j,len=0;
 	char tmp[WEP_ASCII_BUFF_SIZE];
 
@@ -2242,7 +2242,7 @@ static int ks_wlan_get_wep_ascii(struct net_device *dev, struct iw_request_info
 static int ks_wlan_set_beacon_lost(struct net_device *dev, struct iw_request_info *info,
 				   __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2265,7 +2265,7 @@ static int ks_wlan_set_beacon_lost(struct net_device *dev, struct iw_request_inf
 static int ks_wlan_get_beacon_lost(struct net_device *dev, struct iw_request_info *info,
 				   __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2278,7 +2278,7 @@ static int ks_wlan_get_beacon_lost(struct net_device *dev, struct iw_request_inf
 static int ks_wlan_set_phy_type(struct net_device *dev, struct iw_request_info *info,
 				__u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2300,7 +2300,7 @@ static int ks_wlan_set_phy_type(struct net_device *dev, struct iw_request_info *
 static int ks_wlan_get_phy_type(struct net_device *dev, struct iw_request_info *info,
 				__u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2313,7 +2313,7 @@ static int ks_wlan_get_phy_type(struct net_device *dev, struct iw_request_info *
 static int ks_wlan_set_cts_mode(struct net_device *dev, struct iw_request_info *info,
 				__u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2337,7 +2337,7 @@ static int ks_wlan_set_cts_mode(struct net_device *dev, struct iw_request_info *
 static int ks_wlan_get_cts_mode(struct net_device *dev, struct iw_request_info *info,
 				__u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2351,7 +2351,7 @@ static int ks_wlan_set_sleep_mode(struct net_device *dev,
 				     struct iw_request_info *info,
 				     __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	DPRINTK(2,"\n");
 
@@ -2379,7 +2379,7 @@ static int ks_wlan_get_sleep_mode(struct net_device *dev,
 				     struct iw_request_info *info,
 				     __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	DPRINTK(2, "GET_SLEEP_MODE %d\n", priv->sleep_mode);
 	*uwrq = priv->sleep_mode;
@@ -2393,7 +2393,7 @@ static int ks_wlan_get_sleep_mode(struct net_device *dev,
 static int ks_wlan_set_phy_information_timer(struct net_device *dev, struct iw_request_info *info,
 					     __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2412,7 +2412,7 @@ static int ks_wlan_set_phy_information_timer(struct net_device *dev, struct iw_r
 static int ks_wlan_get_phy_information_timer(struct net_device *dev, struct iw_request_info *info,
 					     __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2427,7 +2427,7 @@ static int ks_wlan_get_phy_information_timer(struct net_device *dev, struct iw_r
 static int ks_wlan_set_wps_enable(struct net_device *dev, struct iw_request_info *info,
 				  __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	DPRINTK(2,"\n");
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
@@ -2446,7 +2446,7 @@ static int ks_wlan_set_wps_enable(struct net_device *dev, struct iw_request_info
 static int ks_wlan_get_wps_enable(struct net_device *dev, struct iw_request_info *info,
 				  __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 	DPRINTK(2,"\n");
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
@@ -2464,7 +2464,7 @@ static int ks_wlan_set_wps_probe_req(struct net_device *dev,
 {
 	uint8_t *p = extra;
 	unsigned char len;
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	DPRINTK(2,"\n");
 
@@ -2498,7 +2498,7 @@ static int ks_wlan_get_wps_probe_req(struct net_device *dev,
 				     struct iw_request_info *info,
 				     __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 	DPRINTK(2,"\n");
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
@@ -2513,7 +2513,7 @@ static int ks_wlan_get_wps_probe_req(struct net_device *dev,
 static int ks_wlan_set_tx_gain(struct net_device *dev, struct iw_request_info *info,
 					     __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2537,7 +2537,7 @@ static int ks_wlan_set_tx_gain(struct net_device *dev, struct iw_request_info *i
 static int ks_wlan_get_tx_gain(struct net_device *dev, struct iw_request_info *info,
 					     __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2551,7 +2551,7 @@ static int ks_wlan_get_tx_gain(struct net_device *dev, struct iw_request_info *i
 static int ks_wlan_set_rx_gain(struct net_device *dev, struct iw_request_info *info,
 					     __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2574,7 +2574,7 @@ static int ks_wlan_set_rx_gain(struct net_device *dev, struct iw_request_info *i
 static int ks_wlan_get_rx_gain(struct net_device *dev, struct iw_request_info *info,
 					     __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2588,7 +2588,7 @@ static int ks_wlan_get_rx_gain(struct net_device *dev, struct iw_request_info *i
 static int ks_wlan_set_region(struct net_device *dev, struct iw_request_info *info,
 					     __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)dev->priv;
 
 	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
 
@@ -2607,7 +2607,7 @@ static int ks_wlan_set_region(struct net_device *dev, struct iw_request_info *in
 static int ks_wlan_get_eeprom_cksum(struct net_device *dev, struct iw_request_info *info,
 					     __u32 *uwrq, char *extra)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	*uwrq = priv->eeprom_checksum;
 	return 0;
@@ -2732,7 +2732,7 @@ static int ks_wlan_hostt(struct net_device *dev, struct iw_request_info *info,
 					     __u32 *uwrq, char *extra)
 {
 	int i,event;
-	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)netdev_priv(dev);
 
 	for(i = 63; i >= 0; i--){
 		event =	priv->hostt.buff[(priv->hostt.qtail -1 -i)%SME_EVENT_BUFF_SIZE] ;
@@ -2924,7 +2924,7 @@ static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cm
 static
 struct net_device_stats *ks_wlan_get_stats(struct net_device *dev)
 {
-	ks_wlan_private *priv = netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	if (priv->dev_state < DEVICE_STATE_READY) {
 				return NULL; /* not finished initialize */
@@ -2936,7 +2936,7 @@ struct net_device_stats *ks_wlan_get_stats(struct net_device *dev)
 static
 int ks_wlan_set_mac_address(struct net_device *dev, void *addr)
 {
-	ks_wlan_private *priv = netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	struct sockaddr *mac_addr=(struct sockaddr *)addr;
 	if (netif_running(dev))
 		return -EBUSY;
@@ -2955,7 +2955,7 @@ int ks_wlan_set_mac_address(struct net_device *dev, void *addr)
 static
 void ks_wlan_tx_timeout(struct net_device *dev)
 {
-		ks_wlan_private *priv = netdev_priv(dev);
+		struct ks_wlan_private *priv = netdev_priv(dev);
 
 	DPRINTK(1,"head(%d) tail(%d)!!\n",priv->tx_dev.qhead, priv->tx_dev.qtail);
 	if(!netif_queue_stopped(dev)){
@@ -2970,7 +2970,7 @@ void ks_wlan_tx_timeout(struct net_device *dev)
 static
 int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	ks_wlan_private *priv = netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 	int rc = 0;
 
 	DPRINTK(3,"in_interrupt()=%ld\n",in_interrupt());
@@ -3000,7 +3000,7 @@ int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 void send_packet_complete(void *arg1, void *arg2)
 {
-	ks_wlan_private *priv = (ks_wlan_private *)arg1;
+	struct ks_wlan_private *priv = (struct ks_wlan_private *)arg1;
 	struct sk_buff *packet = (struct sk_buff *)arg2;
 
 		DPRINTK(3,"\n");
@@ -3023,7 +3023,7 @@ void send_packet_complete(void *arg1, void *arg2)
 static
 void ks_wlan_set_multicast_list(struct net_device *dev)
 {
-	ks_wlan_private *priv = netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	DPRINTK(4,"\n");
 	if (priv->dev_state < DEVICE_STATE_READY) {
@@ -3037,7 +3037,7 @@ void ks_wlan_set_multicast_list(struct net_device *dev)
 static
 int ks_wlan_open(struct net_device *dev)
 {
-	ks_wlan_private *priv = netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	priv->cur_rx = 0;
 
@@ -3082,7 +3082,7 @@ static const struct net_device_ops ks_wlan_netdev_ops = {
 
 int ks_wlan_net_start(struct net_device *dev)
 {
-	ks_wlan_private *priv;
+	struct ks_wlan_private *priv;
 	/* int rc; */
 
 	priv = netdev_priv(dev);
@@ -3121,7 +3121,7 @@ int ks_wlan_net_start(struct net_device *dev)
 
 int ks_wlan_net_stop(struct net_device *dev)
 {
-	ks_wlan_private *priv = netdev_priv(dev);
+	struct ks_wlan_private *priv = netdev_priv(dev);
 
 	int ret = 0;
 	priv->device_open_status = 0;

commit 564efd793545d245ed158e5855dbee9706864365
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:21 2016 +0200

    staging: ks7010: delete seperate debug header
    
    Move the one debug macro to the generic wlan header.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 776a54403149..1da2768ea9f3 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -40,7 +40,6 @@ static int wep_on_off;
 #include "ks_wlan.h"
 #include "ks_hostif.h"
 #include "ks_wlan_ioctl.h"
-#include "ks_debug.h"
 
 /* Include Wireless Extension definition and check version */
 #include <linux/wireless.h>

commit 72bf750007297c33fe2331d2125118d4885367c2
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:17 2016 +0200

    staging: ks7010: remove code for old kernel versions
    
    No need to be backwards compatible.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 185630cb423d..776a54403149 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -13,9 +13,6 @@
  */
 
 #include <linux/version.h>
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
-#include <linux/config.h>
-#endif
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/compiler.h>

commit 4ab274017bc31cea220a531358e8c3e2d08d87fc
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:16 2016 +0200

    staging: ks7010: remove checks for WIRELESS_EXT version
    
    We are by far newer than that anyhow.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index 546a25609397..185630cb423d 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -50,7 +50,6 @@ static int wep_on_off;
 #define WIRELESS_SPY		/* enable iwspy support */
 #include <net/iw_handler.h>	/* New driver API */
 
-#ifdef WIRELESS_EXT
 /* Frequency list (map channels to frequencies) */
 static const long frequency_list[] = { 2412, 2417, 2422, 2427, 2432, 2437, 2442,
 				       2447, 2452, 2457, 2462, 2467, 2472, 2484 };
@@ -74,7 +73,6 @@ static const struct iw_handler_def	ks_wlan_handler_def;
 
 #define KSC_OPNOTSUPP /* Operation Not Support*/
 
-#endif /* WIRELESS_EXT */
 
 /*
  *	function prototypes
@@ -174,7 +172,6 @@ int ks_wlan_setup_parameter(ks_wlan_private *priv, unsigned int commit_flag)
 	return 0;
 }
 
-#ifdef WIRELESS_EXT
 /*
  * Initial Wireless Extension code for Ks_Wlannet driver by :
  *	Jean Tourrilhes <jt@hpl.hp.com> - HPL - 17 November 00
@@ -1090,7 +1087,6 @@ static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *inf
 	range->avg_qual.level = 186;	/* -70 dBm */
 	range->avg_qual.noise = 0;
 
-#if defined(WIRELESS_EXT)
 	/* Event capability (kernel + driver) */
 	range->event_capa[0] = (IW_EVENT_CAPA_K_0 |
 				IW_EVENT_CAPA_MASK(SIOCGIWAP) |
@@ -1104,7 +1100,6 @@ static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *inf
 			   IW_ENC_CAPA_WPA2 |
 			   IW_ENC_CAPA_CIPHER_TKIP |
 			   IW_ENC_CAPA_CIPHER_CCMP);
-#endif
 	return 0;
 }
 
@@ -1229,7 +1224,6 @@ static int ks_wlan_get_aplist(struct net_device *dev, struct iw_request_info *in
 	return 0;
 }
 
-#if defined(WIRELESS_EXT)
 /*------------------------------------------------------------------*/
 /* Wireless Handler : Initiate Scan */
 static int ks_wlan_set_scan(struct net_device *dev, struct iw_request_info *info,
@@ -1452,7 +1446,6 @@ DPRINTK(2,"aplist 0\n");
 
 	return 0;
 }
-#endif	/* WIRELESS_EXT  */
 
 /*------------------------------------------------------------------*/
 /* Commit handler : called after a bunch of SET operations */
@@ -1469,7 +1462,6 @@ static int ks_wlan_config_commit(struct net_device *dev, struct iw_request_info
 	return 0;
 }
 
-#ifdef WIRELESS_EXT
 /*------------------------------------------------------------------*/
 /* Wireless handler : set association ie params */
 static int ks_wlan_set_genie(struct net_device *dev, struct iw_request_info *info,
@@ -1951,7 +1943,6 @@ static int ks_wlan_set_mlme(struct net_device *dev, struct iw_request_info *info
 		return -EOPNOTSUPP;  /* Not Support */
 	}
 }
-#endif /* WIRELESS_EXT  */
 
 /*------------------------------------------------------------------*/
 /* Private handler : get driver version */
@@ -2915,20 +2906,15 @@ static const struct iw_handler_def	ks_wlan_handler_def =
 	.get_wireless_stats = ks_get_wireless_stats,
 };
 
-#endif /* WIRELESS_EXT */
 
 static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int rc = 0;
-#if defined(WIRELESS_EXT)
 	struct iwreq *wrq = (struct iwreq *) rq;
-#endif /* WIRELESS_EXT */
 	switch (cmd) {
-#if defined(WIRELESS_EXT)
 	case SIOCIWFIRSTPRIV+20: /* KS_WLAN_SET_STOP_REQ */
 		rc = ks_wlan_set_stop_request(dev, NULL, &(wrq->u.mode), NULL);
 		break;
-#endif /* WIRELESS_EXT >17 */
 	// All other calls are currently unsupported
 	default:
 		rc = -EOPNOTSUPP;

commit 13a9930d15b424ab7d3b906af8ba7ff8c409edfe
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue May 31 12:56:13 2016 +0200

    staging: ks7010: add driver from Nanonote extra-repository
    
    See the TODO for details where this driver came from. Only a few minor
    changes were made to make the driver suitable for staging:
    
    * updated Kconfig help text and dependencies
    * added TODO
    * removed two __DATE__ and __TIME__ printouts to allow reproducible builds
    * added to staging main Kconfig + Makefile
    
    Tested on a Renesas Salvator-X board with a Spectec SDW-823 card. I
    could connect to a WPA-protected network.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
new file mode 100644
index 000000000000..546a25609397
--- /dev/null
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -0,0 +1,3157 @@
+/*
+ *   Driver for KeyStream 11b/g wireless LAN
+ *
+ *   ks_wlan_net.c
+ *   $Id: ks_wlan_net.c 1020 2009-09-28 05:48:31Z sekine $
+ *
+ *   Copyright (C) 2005-2008 KeyStream Corp.
+ *   Copyright (C) 2009 Renesas Technology Corp.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it undr the terms of the GNU General Public License version 2 as
+ *   published by the Free Sotware Foundation.
+ */
+
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#include <linux/config.h>
+#endif
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/compiler.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/delay.h>
+#include <linux/completion.h>
+#include <linux/mii.h>
+#include <linux/pci.h>
+#include <linux/ctype.h>
+#include <linux/timer.h>
+#include <asm/atomic.h>
+#include <linux/io.h>
+#include <asm/uaccess.h>
+
+static int wep_on_off;
+#define	WEP_OFF		0
+#define	WEP_ON_64BIT	1
+#define	WEP_ON_128BIT	2
+
+#include "ks_wlan.h"
+#include "ks_hostif.h"
+#include "ks_wlan_ioctl.h"
+#include "ks_debug.h"
+
+/* Include Wireless Extension definition and check version */
+#include <linux/wireless.h>
+#define WIRELESS_SPY		/* enable iwspy support */
+#include <net/iw_handler.h>	/* New driver API */
+
+#ifdef WIRELESS_EXT
+/* Frequency list (map channels to frequencies) */
+static const long frequency_list[] = { 2412, 2417, 2422, 2427, 2432, 2437, 2442,
+				       2447, 2452, 2457, 2462, 2467, 2472, 2484 };
+
+/* A few details needed for WEP (Wireless Equivalent Privacy) */
+#define MAX_KEY_SIZE 13	/* 128 (?) bits */
+#define MIN_KEY_SIZE  5	/* 40 bits RC4 - WEP */
+typedef struct wep_key_t {
+	u16	len;
+	u8	key[16]; /* 40-bit and 104-bit keys */
+} wep_key_t;
+
+/* Backward compatibility */
+#ifndef IW_ENCODE_NOKEY
+#define IW_ENCODE_NOKEY 0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_MODE  (IW_ENCODE_DISABLED | IW_ENCODE_RESTRICTED | IW_ENCODE_OPEN)
+#endif /* IW_ENCODE_NOKEY */
+
+/* List of Wireless Handlers (new API) */
+static const struct iw_handler_def	ks_wlan_handler_def;
+
+#define KSC_OPNOTSUPP /* Operation Not Support*/
+
+#endif /* WIRELESS_EXT */
+
+/*
+ *	function prototypes
+ */
+extern int ks_wlan_hw_tx(ks_wlan_private *priv, void *p, unsigned long size,
+			void (*complete_handler)(void *arg1, void *arg2),
+			void *arg1,
+			void *arg2 );
+static int ks_wlan_open (struct net_device *dev);
+static void ks_wlan_tx_timeout (struct net_device *dev);
+static int ks_wlan_start_xmit (struct sk_buff *skb, struct net_device *dev);
+static int ks_wlan_close (struct net_device *dev);
+static void ks_wlan_set_multicast_list (struct net_device *dev);
+static struct net_device_stats *ks_wlan_get_stats (struct net_device *dev);
+static int ks_wlan_set_mac_address(struct net_device *dev, void *addr);
+static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+
+static atomic_t update_phyinfo;
+static struct timer_list update_phyinfo_timer;
+static
+int ks_wlan_update_phy_information(ks_wlan_private *priv)
+{
+		struct iw_statistics *wstats = &priv->wstats;
+
+	DPRINTK(4, "in_interrupt = %ld\n", in_interrupt());
+
+	if (priv->dev_state < DEVICE_STATE_READY) {
+				return -1; /* not finished initialize */
+		}
+	if(atomic_read(&update_phyinfo))
+		return 1;
+
+	/* The status */
+	wstats->status = priv->reg.operation_mode;	/* Operation mode */
+
+	/* Signal quality and co. But where is the noise level ??? */
+	hostif_sme_enqueue(priv, SME_PHY_INFO_REQUEST);
+
+	/* interruptible_sleep_on_timeout(&priv->confirm_wait, HZ/2); */
+	if(!wait_for_completion_interruptible_timeout(&priv->confirm_wait,HZ/2)){
+		DPRINTK(1,"wait time out!!\n");
+	}
+
+	atomic_inc(&update_phyinfo);
+	update_phyinfo_timer.expires = jiffies + HZ; /* 1sec */
+	add_timer(&update_phyinfo_timer);
+
+	return 0;
+}
+
+static
+void ks_wlan_update_phyinfo_timeout(unsigned long ptr)
+{
+	DPRINTK(4, "in_interrupt = %ld\n", in_interrupt());
+	atomic_set(&update_phyinfo,0);
+}
+
+int ks_wlan_setup_parameter(ks_wlan_private *priv, unsigned int commit_flag)
+{
+	DPRINTK(2,"\n");
+
+	hostif_sme_enqueue(priv, SME_STOP_REQUEST);
+
+	if(commit_flag & SME_RTS)
+		hostif_sme_enqueue(priv, SME_RTS_THRESHOLD_REQUEST);
+	if(commit_flag & SME_FRAG)
+		hostif_sme_enqueue(priv, SME_FRAGMENTATION_THRESHOLD_REQUEST);
+
+	if(commit_flag & SME_WEP_INDEX)
+		hostif_sme_enqueue(priv, SME_WEP_INDEX_REQUEST);
+	if(commit_flag & SME_WEP_VAL1)
+		hostif_sme_enqueue(priv, SME_WEP_KEY1_REQUEST);
+	if(commit_flag & SME_WEP_VAL2)
+		hostif_sme_enqueue(priv, SME_WEP_KEY2_REQUEST);
+	if(commit_flag & SME_WEP_VAL3)
+		hostif_sme_enqueue(priv, SME_WEP_KEY3_REQUEST);
+	if(commit_flag & SME_WEP_VAL4)
+		hostif_sme_enqueue(priv, SME_WEP_KEY4_REQUEST);
+	if(commit_flag & SME_WEP_FLAG)
+		hostif_sme_enqueue(priv, SME_WEP_FLAG_REQUEST);
+
+	if(commit_flag & SME_RSN){
+		hostif_sme_enqueue(priv, SME_RSN_ENABLED_REQUEST);
+		hostif_sme_enqueue(priv, SME_RSN_MODE_REQUEST);
+	}
+	if(commit_flag & SME_RSN_MULTICAST)
+		hostif_sme_enqueue(priv, SME_RSN_MCAST_REQUEST);
+	if(commit_flag & SME_RSN_UNICAST)
+		hostif_sme_enqueue(priv, SME_RSN_UCAST_REQUEST);
+	if(commit_flag & SME_RSN_AUTH)
+		hostif_sme_enqueue(priv, SME_RSN_AUTH_REQUEST);
+
+	hostif_sme_enqueue(priv, SME_MODE_SET_REQUEST);
+
+	hostif_sme_enqueue(priv, SME_START_REQUEST);
+
+	return 0;
+}
+
+#ifdef WIRELESS_EXT
+/*
+ * Initial Wireless Extension code for Ks_Wlannet driver by :
+ *	Jean Tourrilhes <jt@hpl.hp.com> - HPL - 17 November 00
+ * Conversion to new driver API by :
+ *	Jean Tourrilhes <jt@hpl.hp.com> - HPL - 26 March 02
+ * Javier also did a good amount of work here, adding some new extensions
+ * and fixing my code. Let's just say that without him this code just
+ * would not work at all... - Jean II
+ */
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get protocol name */
+static int ks_wlan_get_name(struct net_device *dev, struct iw_request_info *info,
+				char *cwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *) netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if (priv->dev_state < DEVICE_STATE_READY) {
+		strcpy(cwrq, "NOT READY!");
+		}
+	else if(priv->reg.phy_type == D_11B_ONLY_MODE){
+		strcpy(cwrq, "IEEE 802.11b");
+	}
+	else if(priv->reg.phy_type == D_11G_ONLY_MODE){
+		strcpy(cwrq, "IEEE 802.11g");
+	}
+	else {
+		strcpy(cwrq, "IEEE 802.11b/g");
+	}
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set frequency */
+static int ks_wlan_set_freq(struct net_device *dev, struct iw_request_info *info,
+				struct iw_freq *fwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	int rc = -EINPROGRESS;		/* Call commit handler */
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	/* If setting by frequency, convert to a channel */
+	if((fwrq->e == 1) &&
+	   (fwrq->m >= (int) 2.412e8) &&
+	   (fwrq->m <= (int) 2.487e8)) {
+		int f = fwrq->m / 100000;
+		int c = 0;
+		while((c < 14) && (f != frequency_list[c]))
+			c++;
+		/* Hack to fall through... */
+		fwrq->e = 0;
+		fwrq->m = c + 1;
+	}
+	/* Setting by channel number */
+	if((fwrq->m > 1000) || (fwrq->e > 0))
+		rc = -EOPNOTSUPP;
+	else {
+		int channel = fwrq->m;
+		/* We should do a better check than that,
+		 * based on the card capability !!! */
+		if((channel < 1) || (channel > 14)) {
+			printk(KERN_DEBUG "%s: New channel value of %d is invalid!\n", dev->name, fwrq->m);
+			rc = -EINVAL;
+		} else {
+			/* Yes ! We can set it !!! */
+			priv->reg.channel = (u8)(channel);
+			priv->need_commit |= SME_MODE_SET;
+		}
+	}
+
+	return rc;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get frequency */
+static int ks_wlan_get_freq(struct net_device *dev, struct iw_request_info *info,
+				struct iw_freq *fwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	int f;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS){
+		f = (int)priv->current_ap.channel;
+	}
+	else
+		f = (int)priv->reg.channel;
+	fwrq->m = frequency_list[f-1] * 100000;
+	fwrq->e = 1;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set ESSID */
+static int ks_wlan_set_essid(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	size_t len;
+
+	DPRINTK(2," %d\n", dwrq->flags);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	/* Check if we asked for `any' */
+	if(dwrq->flags == 0) {
+		/* Just send an empty SSID list */
+		memset(priv->reg.ssid.body, 0, sizeof(priv->reg.ssid.body));
+		priv->reg.ssid.size = 0;
+	} else {
+#if 1
+		len = dwrq->length;
+		/* iwconfig uses nul termination in SSID.. */
+		if (len > 0 && extra[len - 1] == '\0')
+			len--;
+
+		/* Check the size of the string */
+		if(len > IW_ESSID_MAX_SIZE) {
+			return -EINVAL;
+		}
+#else
+		/* Check the size of the string */
+		if(dwrq->length > IW_ESSID_MAX_SIZE+1) {
+			return -E2BIG ;
+		}
+#endif
+
+		/* Set the SSID */
+		memset(priv->reg.ssid.body, 0, sizeof(priv->reg.ssid.body));
+
+#if 1
+		memcpy(priv->reg.ssid.body, extra, len);
+		priv->reg.ssid.size = len;
+#else
+		memcpy(priv->reg.ssid.body, extra, dwrq->length);
+		priv->reg.ssid.size = dwrq->length;
+#endif
+	}
+	/* Write it to the card */
+	priv->need_commit |= SME_MODE_SET;
+
+//	return  -EINPROGRESS;	/* Call commit handler */
+	ks_wlan_setup_parameter(priv, priv->need_commit);
+	priv->need_commit=0;
+	return  0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get ESSID */
+static int ks_wlan_get_essid(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	/* Note : if dwrq->flags != 0, we should
+	 * get the relevant SSID from the SSID list... */
+
+	if(priv->reg.ssid.size){
+		/* Get the current SSID */
+		memcpy(extra, priv->reg.ssid.body, priv->reg.ssid.size);
+#if 0
+		extra[priv->reg.ssid.size] = '\0';
+#endif
+		/* If none, we may want to get the one that was set */
+
+		/* Push it out ! */
+#if 1
+		dwrq->length = priv->reg.ssid.size;
+#else
+		dwrq->length = priv->reg.ssid.size+1;
+#endif
+		dwrq->flags = 1; /* active */
+	}else{
+#if 1
+		dwrq->length = 0;
+#else
+		extra[0] = '\0';
+		dwrq->length = 1;
+#endif
+		dwrq->flags = 0; /* ANY */
+	}
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set AP address */
+static int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
+			   struct sockaddr *ap_addr, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	DPRINTK(2,"\n");
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if (priv->reg.operation_mode == MODE_ADHOC ||
+		priv->reg.operation_mode == MODE_INFRASTRUCTURE) {
+		memcpy(priv->reg.bssid, (u8 *)&ap_addr->sa_data, ETH_ALEN);
+
+		if (is_valid_ether_addr((u8 *)priv->reg.bssid)) {
+			priv->need_commit |= SME_MODE_SET;
+		}
+	}
+	else {
+		memset(priv->reg.bssid, 0x0, ETH_ALEN);
+		return -EOPNOTSUPP;
+	}
+
+	DPRINTK(2, "bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
+			   priv->reg.bssid[0],priv->reg.bssid[1],priv->reg.bssid[2],
+			   priv->reg.bssid[3],priv->reg.bssid[4],priv->reg.bssid[5]);
+
+	/* Write it to the card */
+	if (priv->need_commit) {
+		priv->need_commit |= SME_MODE_SET;
+		return  -EINPROGRESS;	/* Call commit handler */
+	}
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get AP address */
+static int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
+			   struct sockaddr *awrq, char *extra)
+{
+		ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS){
+		memcpy(awrq->sa_data, &(priv->current_ap.bssid[0]), ETH_ALEN);
+	}
+	else{
+		memset(awrq->sa_data, 0, ETH_ALEN);
+	}
+
+	awrq->sa_family = ARPHRD_ETHER;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set Nickname */
+static int ks_wlan_set_nick(struct net_device *dev, struct iw_request_info *info,
+				struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	/* Check the size of the string */
+	if(dwrq->length > 16 + 1) {
+		return -E2BIG;
+	}
+	memset(priv->nick, 0, sizeof(priv->nick));
+	memcpy(priv->nick, extra, dwrq->length);
+
+	return -EINPROGRESS;	/* Call commit handler */
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get Nickname */
+static int ks_wlan_get_nick(struct net_device *dev, struct iw_request_info *info,
+				struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	strncpy(extra, priv->nick, 16);
+	extra[16] = '\0';
+	dwrq->length = strlen(extra) + 1;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set Bit-Rate */
+static int ks_wlan_set_rate(struct net_device *dev, struct iw_request_info *info,
+				struct iw_param *vwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	int i = 0;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(priv->reg.phy_type == D_11B_ONLY_MODE){
+		if(vwrq->fixed == 1) {
+			switch(vwrq->value){
+			case 11000000:
+			case  5500000:
+				priv->reg.rate_set.body[0] = (uint8_t)(vwrq->value/500000);
+				break;
+			case  2000000:
+			case  1000000:
+				priv->reg.rate_set.body[0] = ((uint8_t)(vwrq->value/500000))|BASIC_RATE;
+				break;
+			default:
+				return -EINVAL;
+			}
+			priv->reg.tx_rate = TX_RATE_FIXED;
+			priv->reg.rate_set.size = 1;
+		}else{  /* vwrq->fixed == 0 */
+			if(vwrq->value > 0){
+				switch(vwrq->value){
+				case 11000000:
+					priv->reg.rate_set.body[3] = TX_RATE_11M; i++;
+				case  5500000:
+					priv->reg.rate_set.body[2] = TX_RATE_5M; i++;
+				case  2000000:
+					priv->reg.rate_set.body[1] = TX_RATE_2M|BASIC_RATE; i++;
+				case  1000000:
+					priv->reg.rate_set.body[0] = TX_RATE_1M|BASIC_RATE; i++;
+					break;
+				default:
+					return -EINVAL;
+				}
+				priv->reg.tx_rate = TX_RATE_MANUAL_AUTO;
+				priv->reg.rate_set.size = i;
+			}else{
+				priv->reg.rate_set.body[3] = TX_RATE_11M;
+				priv->reg.rate_set.body[2] = TX_RATE_5M;
+				priv->reg.rate_set.body[1] = TX_RATE_2M|BASIC_RATE;
+				priv->reg.rate_set.body[0] = TX_RATE_1M|BASIC_RATE;
+				priv->reg.tx_rate = TX_RATE_FULL_AUTO;
+				priv->reg.rate_set.size = 4;
+			}
+		}
+	}else{ /* D_11B_ONLY_MODE or  D_11BG_COMPATIBLE_MODE */
+		if(vwrq->fixed == 1) {
+			switch(vwrq->value){
+			case 54000000:
+			case 48000000:
+			case 36000000:
+			case 18000000:
+			case  9000000:
+				priv->reg.rate_set.body[0] = (uint8_t)(vwrq->value/500000);
+				break;
+			case 24000000:
+			case 12000000:
+			case 11000000:
+			case  6000000:
+			case  5500000:
+			case  2000000:
+			case  1000000:
+				priv->reg.rate_set.body[0] = ((uint8_t)(vwrq->value/500000))|BASIC_RATE;
+				break;
+			default:
+				return -EINVAL;
+			}
+			priv->reg.tx_rate = TX_RATE_FIXED;
+			priv->reg.rate_set.size = 1;
+		}else{  /* vwrq->fixed == 0 */
+			if(vwrq->value > 0){
+				switch(vwrq->value){
+				case 54000000:
+					priv->reg.rate_set.body[11] = TX_RATE_54M; i++;
+				case 48000000:
+					priv->reg.rate_set.body[10] = TX_RATE_48M; i++;
+				case 36000000:
+					priv->reg.rate_set.body[9] = TX_RATE_36M; i++;
+				case 24000000: case 18000000: case 12000000:
+				case 11000000: case  9000000: case  6000000:
+					if(vwrq->value == 24000000){
+						priv->reg.rate_set.body[8] = TX_RATE_18M; i++;
+						priv->reg.rate_set.body[7] = TX_RATE_9M; i++;
+						priv->reg.rate_set.body[6] = TX_RATE_24M|BASIC_RATE; i++;
+						priv->reg.rate_set.body[5] = TX_RATE_12M|BASIC_RATE; i++;
+						priv->reg.rate_set.body[4] = TX_RATE_6M|BASIC_RATE; i++;
+						priv->reg.rate_set.body[3] = TX_RATE_11M|BASIC_RATE; i++;
+					}else if(vwrq->value == 18000000){
+						priv->reg.rate_set.body[7] = TX_RATE_18M; i++;
+						priv->reg.rate_set.body[6] = TX_RATE_9M; i++;
+						priv->reg.rate_set.body[5] = TX_RATE_12M|BASIC_RATE; i++;
+						priv->reg.rate_set.body[4] = TX_RATE_6M|BASIC_RATE; i++;
+						priv->reg.rate_set.body[3] = TX_RATE_11M|BASIC_RATE; i++;
+					}else if(vwrq->value == 12000000){
+						priv->reg.rate_set.body[6] = TX_RATE_9M; i++;
+						priv->reg.rate_set.body[5] = TX_RATE_12M|BASIC_RATE; i++;
+						priv->reg.rate_set.body[4] = TX_RATE_6M|BASIC_RATE; i++;
+						priv->reg.rate_set.body[3] = TX_RATE_11M|BASIC_RATE; i++;
+					}else if(vwrq->value == 11000000){
+						priv->reg.rate_set.body[5] = TX_RATE_9M; i++;
+						priv->reg.rate_set.body[4] = TX_RATE_6M|BASIC_RATE; i++;
+						priv->reg.rate_set.body[3] = TX_RATE_11M|BASIC_RATE; i++;
+					}else if(vwrq->value == 9000000){
+						priv->reg.rate_set.body[4] = TX_RATE_9M; i++;
+						priv->reg.rate_set.body[3] = TX_RATE_6M|BASIC_RATE; i++;
+					}else{ /* vwrq->value == 6000000 */
+						priv->reg.rate_set.body[3] = TX_RATE_6M|BASIC_RATE; i++;
+					}
+				case  5500000:
+					priv->reg.rate_set.body[2] = TX_RATE_5M|BASIC_RATE; i++;
+				case  2000000:
+					priv->reg.rate_set.body[1] = TX_RATE_2M|BASIC_RATE; i++;
+				case  1000000:
+					priv->reg.rate_set.body[0] = TX_RATE_1M|BASIC_RATE; i++;
+					break;
+				default:
+					return -EINVAL;
+				}
+				priv->reg.tx_rate = TX_RATE_MANUAL_AUTO;
+				priv->reg.rate_set.size = i;
+			}else{
+				priv->reg.rate_set.body[11] = TX_RATE_54M;
+				priv->reg.rate_set.body[10] = TX_RATE_48M;
+				priv->reg.rate_set.body[9] = TX_RATE_36M;
+				priv->reg.rate_set.body[8] = TX_RATE_18M;
+				priv->reg.rate_set.body[7] = TX_RATE_9M;
+				priv->reg.rate_set.body[6] = TX_RATE_24M|BASIC_RATE;
+				priv->reg.rate_set.body[5] = TX_RATE_12M|BASIC_RATE;
+				priv->reg.rate_set.body[4] = TX_RATE_6M|BASIC_RATE;
+				priv->reg.rate_set.body[3] = TX_RATE_11M|BASIC_RATE;
+				priv->reg.rate_set.body[2] = TX_RATE_5M|BASIC_RATE;
+				priv->reg.rate_set.body[1] = TX_RATE_2M|BASIC_RATE;
+				priv->reg.rate_set.body[0] = TX_RATE_1M|BASIC_RATE;
+				priv->reg.tx_rate = TX_RATE_FULL_AUTO;
+				priv->reg.rate_set.size = 12;
+			}
+		}
+	}
+
+	priv->need_commit |= SME_MODE_SET;
+
+	return -EINPROGRESS;	/* Call commit handler */
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get Bit-Rate */
+static int ks_wlan_get_rate(struct net_device *dev, struct iw_request_info *info,
+				struct iw_param *vwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	DPRINTK(2, "in_interrupt = %ld update_phyinfo = %d\n",
+		in_interrupt(),atomic_read(&update_phyinfo));
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(!atomic_read(&update_phyinfo)){
+		ks_wlan_update_phy_information(priv);
+	}
+	vwrq->value = ((priv->current_rate) & RATE_MASK) * 500000;
+	if(priv->reg.tx_rate == TX_RATE_FIXED)
+		vwrq->fixed = 1;
+	else
+		vwrq->fixed = 0;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set RTS threshold */
+static int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
+			   struct iw_param *vwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	int rthr = vwrq->value;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(vwrq->disabled)
+		rthr = 2347;
+	if((rthr < 0) || (rthr > 2347)) {
+		return -EINVAL;
+	}
+	priv->reg.rts = rthr;
+	priv->need_commit |= SME_RTS;
+
+	return -EINPROGRESS;	/* Call commit handler */
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get RTS threshold */
+static int ks_wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
+			   struct iw_param *vwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	vwrq->value = priv->reg.rts;
+	vwrq->disabled = (vwrq->value >= 2347);
+	vwrq->fixed = 1;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set Fragmentation threshold */
+static int ks_wlan_set_frag(struct net_device *dev, struct iw_request_info *info,
+				struct iw_param *vwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	int fthr = vwrq->value;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(vwrq->disabled)
+		fthr = 2346;
+	if((fthr < 256) || (fthr > 2346)) {
+		return -EINVAL;
+	}
+	fthr &= ~0x1;	/* Get an even value - is it really needed ??? */
+	priv->reg.fragment = fthr;
+	priv->need_commit |= SME_FRAG;
+
+	return -EINPROGRESS;	/* Call commit handler */
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get Fragmentation threshold */
+static int ks_wlan_get_frag(struct net_device *dev, struct iw_request_info *info,
+				struct iw_param *vwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	vwrq->value = priv->reg.fragment;
+	vwrq->disabled = (vwrq->value >= 2346);
+	vwrq->fixed = 1;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set Mode of Operation */
+static int ks_wlan_set_mode(struct net_device *dev, struct iw_request_info *info,
+				__u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	DPRINTK(2,"mode=%d\n",*uwrq);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	switch(*uwrq) {
+	case IW_MODE_ADHOC:
+		priv->reg.operation_mode = MODE_ADHOC;
+		priv->need_commit |= SME_MODE_SET;
+		break;
+	case IW_MODE_INFRA:
+		priv->reg.operation_mode = MODE_INFRASTRUCTURE;
+		priv->need_commit |= SME_MODE_SET;
+		break;
+	case IW_MODE_AUTO:
+	case IW_MODE_MASTER:
+	case IW_MODE_REPEAT:
+	case IW_MODE_SECOND:
+	case IW_MODE_MONITOR:
+	default:
+		return -EINVAL;
+	}
+
+	return -EINPROGRESS;		/* Call commit handler */
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get Mode of Operation */
+static int ks_wlan_get_mode(struct net_device *dev, struct iw_request_info *info,
+				__u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	/* If not managed, assume it's ad-hoc */
+	switch (priv->reg.operation_mode) {
+		case MODE_INFRASTRUCTURE:
+			*uwrq = IW_MODE_INFRA;
+			break;
+		case MODE_ADHOC:
+			*uwrq = IW_MODE_ADHOC;
+			break;
+		default:
+			*uwrq = IW_MODE_ADHOC;
+	}
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set Encryption Key */
+static int ks_wlan_set_encode(struct net_device *dev, struct iw_request_info *info,
+				  struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	wep_key_t key;
+	int index = (dwrq->flags & IW_ENCODE_INDEX);
+	int current_index = priv->reg.wep_index;
+	int i;
+
+	DPRINTK(2,"flags=%04X\n",dwrq->flags);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	/* index check */
+	if((index<0) || (index>4))
+		return -EINVAL;
+	else if (index==0)
+		index = current_index;
+	else
+		index--;
+
+	/* Is WEP supported ? */
+	/* Basic checking: do we have a key to set ? */
+	if (dwrq->length > 0) {
+		if (dwrq->length > MAX_KEY_SIZE) { /* Check the size of the key */
+			return -EINVAL;
+		}
+		if (dwrq->length > MIN_KEY_SIZE) { /* Set the length */
+			key.len = MAX_KEY_SIZE;
+			priv->reg.privacy_invoked = 0x01;
+			priv->need_commit |= SME_WEP_FLAG;
+			wep_on_off = WEP_ON_128BIT;
+		} else {
+			if (dwrq->length > 0) {
+				key.len = MIN_KEY_SIZE;
+				priv->reg.privacy_invoked = 0x01;
+				priv->need_commit |= SME_WEP_FLAG;
+				wep_on_off = WEP_ON_64BIT;
+			} else { /* Disable the key */
+				key.len = 0;
+			}
+		}
+		/* Check if the key is not marked as invalid */
+		if(!(dwrq->flags & IW_ENCODE_NOKEY)) {
+			/* Cleanup */
+			memset(key.key, 0, MAX_KEY_SIZE);
+			/* Copy the key in the driver */
+			if(copy_from_user(key.key,dwrq->pointer,dwrq->length)) {
+				key.len = 0;
+				return -EFAULT;
+			}
+			/* Send the key to the card */
+			priv->reg.wep_key[index].size = key.len;
+			for (i=0; i<(priv->reg.wep_key[index].size); i++) {
+				priv->reg.wep_key[index].val[i] = key.key[i];
+			}
+			priv->need_commit |= (SME_WEP_VAL1<<index);
+			priv->reg.wep_index = index;
+			priv->need_commit |= SME_WEP_INDEX;
+		}
+	} else {
+		if(dwrq->flags & IW_ENCODE_DISABLED){
+			priv->reg.wep_key[0].size = 0;
+			priv->reg.wep_key[1].size = 0;
+			priv->reg.wep_key[2].size = 0;
+			priv->reg.wep_key[3].size = 0;
+			priv->reg.privacy_invoked = 0x00;
+			if(priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY){
+				priv->need_commit |= SME_MODE_SET;
+			}
+			priv->reg.authenticate_type = AUTH_TYPE_OPEN_SYSTEM;
+			wep_on_off = WEP_OFF;
+			priv->need_commit |= SME_WEP_FLAG;
+		}else{
+			/* Do we want to just set the transmit key index ? */
+			if ((index>=0) && (index<4)) {
+				/* set_wep_key(priv, index, 0, 0, 1);	xxx */
+				if(priv->reg.wep_key[index].size){
+					priv->reg.wep_index = index;
+					priv->need_commit |= SME_WEP_INDEX;
+				}
+				else
+					return -EINVAL;
+			}
+		}
+	}
+
+	/* Commit the changes if needed */
+	if(dwrq->flags & IW_ENCODE_MODE)
+		priv->need_commit |= SME_WEP_FLAG;
+
+	if(dwrq->flags & IW_ENCODE_OPEN) {
+		if(priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY){
+			priv->need_commit |= SME_MODE_SET;
+		}
+		priv->reg.authenticate_type = AUTH_TYPE_OPEN_SYSTEM;
+	} else if(dwrq->flags & IW_ENCODE_RESTRICTED) {
+		if(priv->reg.authenticate_type == AUTH_TYPE_OPEN_SYSTEM){
+			priv->need_commit |= SME_MODE_SET;
+		}
+		priv->reg.authenticate_type = AUTH_TYPE_SHARED_KEY;
+	}
+
+//	return -EINPROGRESS;		/* Call commit handler */
+	if(priv->need_commit){
+		ks_wlan_setup_parameter(priv, priv->need_commit);
+		priv->need_commit=0;
+	}
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get Encryption Key */
+static int ks_wlan_get_encode(struct net_device *dev, struct iw_request_info *info,
+				  struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	char zeros[16];
+	int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	dwrq->flags = IW_ENCODE_DISABLED;
+
+	/* Check encryption mode */
+	switch(priv->reg.authenticate_type) {
+	case AUTH_TYPE_OPEN_SYSTEM:
+		dwrq->flags = IW_ENCODE_OPEN;
+		break;
+	case AUTH_TYPE_SHARED_KEY:
+		dwrq->flags = IW_ENCODE_RESTRICTED;
+		break;
+	}
+
+	memset(zeros,0, sizeof(zeros));
+
+	/* Which key do we want ? -1 -> tx index */
+	if((index < 0) || (index >= 4))
+		index = priv->reg.wep_index;
+	if (priv->reg.privacy_invoked){
+		dwrq->flags &= ~IW_ENCODE_DISABLED;
+		/* dwrq->flags |= IW_ENCODE_NOKEY; */
+	}
+	dwrq->flags |= index + 1;
+	DPRINTK(2,"encoding flag = 0x%04X\n",dwrq->flags);
+	/* Copy the key to the user buffer */
+	if((index >= 0) && (index < 4))
+		dwrq->length = priv->reg.wep_key[index].size;
+	if (dwrq->length > 16) {
+		dwrq->length=0;
+	}
+#if 1 /* IW_ENCODE_NOKEY; */
+	if (dwrq->length) {
+		if((index >= 0) && (index < 4))
+			memcpy(extra,priv->reg.wep_key[index].val,dwrq->length);
+	} else
+		memcpy(extra,zeros,dwrq->length);
+#endif
+	return 0;
+}
+
+#ifndef KSC_OPNOTSUPP
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set Tx-Power */
+static int ks_wlan_set_txpow(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_param *vwrq, char *extra)
+{
+	return -EOPNOTSUPP; /* Not Support */
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get Tx-Power */
+static int ks_wlan_get_txpow(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_param *vwrq, char *extra)
+{
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	/* Not Support */
+	vwrq->value = 0;
+	vwrq->disabled = (vwrq->value == 0);
+	vwrq->fixed = 1;
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set Retry limits */
+static int ks_wlan_set_retry(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_param *vwrq, char *extra)
+{
+	return -EOPNOTSUPP; /* Not Support */
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get Retry limits */
+static int ks_wlan_get_retry(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_param *vwrq, char *extra)
+{
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	/* Not Support */
+	vwrq->value = 0;
+	vwrq->disabled = (vwrq->value == 0);
+	vwrq->fixed = 1;
+	return 0;
+}
+#endif /* KSC_OPNOTSUPP */
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get range info */
+static int ks_wlan_get_range(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct iw_range *range = (struct iw_range *) extra;
+	int i,k;
+
+	DPRINTK(2,"\n");
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	dwrq->length = sizeof(struct iw_range);
+	memset(range, 0, sizeof(*range));
+	range->min_nwid = 0x0000;
+	range->max_nwid = 0x0000;
+	range->num_channels = 14;
+	/* Should be based on cap_rid.country to give only
+	 * what the current card support */
+	k = 0;
+	for(i = 0; i < 13; i++) { /* channel 1 -- 13*/
+		range->freq[k].i = i + 1; /* List index */
+		range->freq[k].m = frequency_list[i] * 100000;
+		range->freq[k++].e = 1;	/* Values in table in MHz -> * 10^5 * 10 */
+	}
+	range->num_frequency = k;
+	if(priv->reg.phy_type == D_11B_ONLY_MODE ||
+	   priv->reg.phy_type == D_11BG_COMPATIBLE_MODE){ /* channel 14 */
+		range->freq[13].i = 14; /* List index */
+		range->freq[13].m = frequency_list[13] * 100000;
+		range->freq[13].e = 1;	/* Values in table in MHz -> * 10^5 * 10 */
+		range->num_frequency = 14;
+	}
+
+	/* Hum... Should put the right values there */
+	range->max_qual.qual = 100;
+	range->max_qual.level = 256 - 128;	/* 0 dBm? */
+	range->max_qual.noise = 256 - 128;
+		range->sensitivity = 1;
+
+	if(priv->reg.phy_type == D_11B_ONLY_MODE){
+		range->bitrate[0] = 1e6;
+		range->bitrate[1] = 2e6;
+		range->bitrate[2] = 5.5e6;
+		range->bitrate[3] = 11e6;
+		range->num_bitrates = 4;
+	}
+	else{ /* D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE */
+		range->bitrate[0] = 1e6;
+		range->bitrate[1] = 2e6;
+		range->bitrate[2] = 5.5e6;
+		range->bitrate[3] = 11e6;
+
+		range->bitrate[4] = 6e6;
+		range->bitrate[5] = 9e6;
+		range->bitrate[6] = 12e6;
+		if(IW_MAX_BITRATES < 9){
+			range->bitrate[7] = 54e6;
+			range->num_bitrates = 8;
+		}else{
+			range->bitrate[7] = 18e6;
+			range->bitrate[8] = 24e6;
+			range->bitrate[9] = 36e6;
+			range->bitrate[10] = 48e6;
+			range->bitrate[11] = 54e6;
+
+			range->num_bitrates = 12;
+		}
+	}
+
+	/* Set an indication of the max TCP throughput
+	 * in bit/s that we can expect using this interface.
+	 * May be use for QoS stuff... Jean II */
+	if(i > 2)
+		range->throughput = 5000 * 1000;
+	else
+		range->throughput = 1500 * 1000;
+
+	range->min_rts = 0;
+	range->max_rts = 2347;
+	range->min_frag = 256;
+	range->max_frag = 2346;
+
+		range->encoding_size[0] = 5;  /* WEP: RC4 40 bits */
+		range->encoding_size[1] = 13; /* WEP: RC4 ~128 bits */
+		range->num_encoding_sizes = 2;
+	range->max_encoding_tokens = 4;
+
+	/* power management not support */
+	range->pmp_flags = IW_POWER_ON;
+	range->pmt_flags = IW_POWER_ON;
+	range->pm_capa = 0;
+
+	/* Transmit Power - values are in dBm( or mW) */
+	range->txpower[0]=-256;
+	range->num_txpower = 1;
+	range->txpower_capa = IW_TXPOW_DBM;
+	/* range->txpower_capa = IW_TXPOW_MWATT; */
+
+	range->we_version_source = 21;
+	range->we_version_compiled = WIRELESS_EXT;
+
+	range->retry_capa = IW_RETRY_ON;
+		range->retry_flags = IW_RETRY_ON;
+		range->r_time_flags = IW_RETRY_ON;
+
+	/* Experimental measurements - boundary 11/5.5 Mb/s */
+	/* Note : with or without the (local->rssi), results
+	 * are somewhat different. - Jean II */
+	range->avg_qual.qual = 50;
+	range->avg_qual.level = 186;	/* -70 dBm */
+	range->avg_qual.noise = 0;
+
+#if defined(WIRELESS_EXT)
+	/* Event capability (kernel + driver) */
+	range->event_capa[0] = (IW_EVENT_CAPA_K_0 |
+				IW_EVENT_CAPA_MASK(SIOCGIWAP) |
+				IW_EVENT_CAPA_MASK(SIOCGIWSCAN));
+	range->event_capa[1] = IW_EVENT_CAPA_K_1;
+	range->event_capa[4] = (IW_EVENT_CAPA_MASK(IWEVCUSTOM) |
+				IW_EVENT_CAPA_MASK(IWEVMICHAELMICFAILURE));
+
+	/* encode extension (WPA) capability */
+	range->enc_capa = (IW_ENC_CAPA_WPA  |
+			   IW_ENC_CAPA_WPA2 |
+			   IW_ENC_CAPA_CIPHER_TKIP |
+			   IW_ENC_CAPA_CIPHER_CCMP);
+#endif
+	return 0;
+}
+
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set Power Management */
+static int ks_wlan_set_power(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_param *vwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	short enabled;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	enabled = vwrq->disabled ? 0 : 1;
+	if(enabled == 0 ){ /* 0 */
+		priv->reg.powermgt = POWMGT_ACTIVE_MODE;
+	}else if(enabled){  /* 1 */
+		if(priv->reg.operation_mode == MODE_INFRASTRUCTURE)
+			 priv->reg.powermgt = POWMGT_SAVE1_MODE;
+		 else
+			 return  -EINVAL;
+	}else if(enabled){  /* 2 */
+		if(priv->reg.operation_mode == MODE_INFRASTRUCTURE)
+			priv->reg.powermgt = POWMGT_SAVE2_MODE;
+		else
+			return -EINVAL;
+	}else
+		return  -EINVAL;
+
+	hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get Power Management */
+static int ks_wlan_get_power(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_param *vwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(priv->reg.powermgt > 0)
+		vwrq->disabled =  0;
+	else
+		vwrq->disabled =  1;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get wirless statistics */
+static int ks_wlan_get_iwstats(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_quality *vwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	vwrq->qual    = 0;	/* not supported */
+	vwrq->level   = priv->wstats.qual.level;
+	vwrq->noise   = 0;	/* not supported */
+	vwrq->updated = 0;
+
+	return 0;
+}
+
+#ifndef KSC_OPNOTSUPP
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set Sensitivity */
+static int ks_wlan_set_sens(struct net_device *dev, struct iw_request_info *info,
+				struct iw_param *vwrq, char *extra)
+{
+	return -EOPNOTSUPP;  /* Not Support */
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get Sensitivity */
+static int ks_wlan_get_sens(struct net_device *dev, struct iw_request_info *info,
+				struct iw_param *vwrq, char *extra)
+{
+	/* Not Support */
+	vwrq->value = 0;
+	vwrq->disabled = (vwrq->value == 0);
+	vwrq->fixed = 1;
+	return 0;
+}
+#endif /* KSC_OPNOTSUPP */
+
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get AP List */
+/* Note : this is deprecated in favor of IWSCAN */
+static int ks_wlan_get_aplist(struct net_device *dev, struct iw_request_info *info,
+				  struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct sockaddr *address = (struct sockaddr *) extra;
+	struct iw_quality qual[LOCAL_APLIST_MAX];
+
+	int i;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	for (i = 0; i < priv->aplist.size; i++) {
+		memcpy(address[i].sa_data, &(priv->aplist.ap[i].bssid[0]), ETH_ALEN);
+		address[i].sa_family = ARPHRD_ETHER;
+		qual[i].level = 256 - priv->aplist.ap[i].rssi;
+		qual[i].qual = priv->aplist.ap[i].sq;
+		qual[i].noise = 0; /* invalid noise value */
+		qual[i].updated = 7;
+	}
+	if (i){
+		dwrq->flags = 1; /* Should be define'd */
+		memcpy(extra + sizeof(struct sockaddr)*i,
+			   &qual,  sizeof(struct iw_quality)*i);
+	}
+	dwrq->length = i;
+
+	return 0;
+}
+
+#if defined(WIRELESS_EXT)
+/*------------------------------------------------------------------*/
+/* Wireless Handler : Initiate Scan */
+static int ks_wlan_set_scan(struct net_device *dev, struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct iw_scan_req *req = NULL;
+	DPRINTK(2,"\n");
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	/* specified SSID SCAN */
+	if(wrqu->data.length == sizeof(struct iw_scan_req) && wrqu->data.flags & IW_SCAN_THIS_ESSID){
+		req = (struct iw_scan_req *) extra;
+		priv->scan_ssid_len = req->essid_len;
+		memcpy(priv->scan_ssid, req->essid, priv->scan_ssid_len);
+	}else{
+		priv->scan_ssid_len = 0;
+	}
+
+
+	priv->sme_i.sme_flag |= SME_AP_SCAN;
+	hostif_sme_enqueue(priv, SME_BSS_SCAN_REQUEST);
+
+	/* At this point, just return to the user. */
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Translate scan data returned from the card to a card independent
+ * format that the Wireless Tools will understand - Jean II
+ */
+static inline char *ks_wlan_translate_scan(struct net_device *dev, struct iw_request_info *info, char *current_ev,
+					   char *end_buf, struct local_ap_t *ap)
+{
+	/* ks_wlan_private *priv = (ks_wlan_private *)dev->priv; */
+	struct iw_event	iwe;		/* Temporary buffer */
+	u16 capabilities;
+	char *current_val;	/* For rates */
+	int i;
+	static const char rsn_leader[] = "rsn_ie=";
+	static const char wpa_leader[] = "wpa_ie=";
+	char buf0[RSN_IE_BODY_MAX*2 + 30];
+	char buf1[RSN_IE_BODY_MAX*2 + 30];
+	char *pbuf;
+	/* First entry *MUST* be the AP MAC address */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+	memcpy(iwe.u.ap_addr.sa_data, ap->bssid, ETH_ALEN);
+	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_ADDR_LEN);
+
+	/* Other entries will be displayed in the order we give them */
+
+	/* Add the ESSID */
+	iwe.u.data.length = ap->ssid.size;
+	if(iwe.u.data.length > 32)
+		iwe.u.data.length = 32;
+	iwe.cmd = SIOCGIWESSID;
+	iwe.u.data.flags = 1;
+	current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, &(ap->ssid.body[0]));
+
+	/* Add mode */
+	iwe.cmd = SIOCGIWMODE;
+	capabilities = le16_to_cpu(ap->capability);
+	if(capabilities & (BSS_CAP_ESS | BSS_CAP_IBSS)) {
+		if(capabilities & BSS_CAP_ESS)
+			iwe.u.mode = IW_MODE_INFRA;
+		else
+			iwe.u.mode = IW_MODE_ADHOC;
+		current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_UINT_LEN);
+	}
+
+	/* Add frequency */
+	iwe.cmd = SIOCGIWFREQ;
+	iwe.u.freq.m = ap->channel;
+	iwe.u.freq.m = frequency_list[iwe.u.freq.m-1] * 100000;
+	iwe.u.freq.e = 1;
+	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_FREQ_LEN);
+
+	/* Add quality statistics */
+	iwe.cmd = IWEVQUAL;
+	iwe.u.qual.level = 256 - ap->rssi;
+	iwe.u.qual.qual = ap->sq;
+	iwe.u.qual.noise = 0; /* invalid noise value */
+	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_QUAL_LEN);
+
+	/* Add encryption capability */
+	iwe.cmd = SIOCGIWENCODE;
+	if(capabilities & BSS_CAP_PRIVACY)
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	iwe.u.data.length = 0;
+	current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, &(ap->ssid.body[0]));
+
+	/* Rate : stuffing multiple values in a single event require a bit
+	 * more of magic - Jean II */
+	current_val = current_ev + IW_EV_LCP_LEN;
+
+	iwe.cmd = SIOCGIWRATE;
+	/* Those two flags are ignored... */
+	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+
+	/* Max 16 values */
+	for(i = 0 ; i < 16 ; i++) {
+		/* NULL terminated */
+		if(i >= ap->rate_set.size)
+			break;
+		/* Bit rate given in 500 kb/s units (+ 0x80) */
+		iwe.u.bitrate.value = ((ap->rate_set.body[i] & 0x7f) * 500000);
+		/* Add new value to event */
+		current_val = iwe_stream_add_value(info, current_ev, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);
+	}
+	/* Check if we added any event */
+	if((current_val - current_ev) > IW_EV_LCP_LEN)
+		current_ev = current_val;
+
+#define GENERIC_INFO_ELEM_ID 0xdd
+#define RSN_INFO_ELEM_ID 0x30
+		if (ap->rsn_ie.id == RSN_INFO_ELEM_ID && ap->rsn_ie.size != 0) {
+			pbuf = &buf0[0];
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			memcpy(buf0,rsn_leader,sizeof(rsn_leader)-1);
+			iwe.u.data.length += sizeof(rsn_leader)-1;
+			pbuf += sizeof(rsn_leader)-1;
+
+			pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.id);
+			pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.size);
+			iwe.u.data.length += 4;
+
+			for (i = 0; i < ap->rsn_ie.size; i++)
+				pbuf += sprintf(pbuf, "%02x", ap->rsn_ie.body[i]);
+			iwe.u.data.length += (ap->rsn_ie.size)*2;
+
+			DPRINTK(4,"ap->rsn.size=%d\n",ap->rsn_ie.size);
+
+			current_ev = iwe_stream_add_point(info, current_ev, end_buf,&iwe, &buf0[0]);
+		}
+		if (ap->wpa_ie.id == GENERIC_INFO_ELEM_ID && ap->wpa_ie.size != 0) {
+			pbuf = &buf1[0];
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			memcpy(buf1,wpa_leader,sizeof(wpa_leader)-1);
+			iwe.u.data.length += sizeof(wpa_leader)-1;
+			pbuf += sizeof(wpa_leader)-1;
+
+			pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.id);
+			pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.size);
+			iwe.u.data.length += 4;
+
+			for (i = 0; i < ap->wpa_ie.size; i++)
+				pbuf += sprintf(pbuf, "%02x", ap->wpa_ie.body[i]);
+			iwe.u.data.length += (ap->wpa_ie.size)*2;
+
+			DPRINTK(4,"ap->rsn.size=%d\n",ap->wpa_ie.size);
+			DPRINTK(4,"iwe.u.data.length=%d\n",iwe.u.data.length);
+
+			current_ev = iwe_stream_add_point(info, current_ev, end_buf,&iwe, &buf1[0]);
+		}
+
+	/* The other data in the scan result are not really
+	 * interesting, so for now drop it - Jean II */
+	return current_ev;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : Read Scan Results */
+static int ks_wlan_get_scan(struct net_device *dev, struct iw_request_info *info,
+				struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	int i;
+	char *current_ev = extra;
+	DPRINTK(2,"\n");
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(priv->sme_i.sme_flag & SME_AP_SCAN) {
+DPRINTK(2,"flag AP_SCAN\n");
+		return -EAGAIN;
+	}
+
+	if(priv->aplist.size == 0) {
+		/* Client error, no scan results...
+		 * The caller need to restart the scan. */
+DPRINTK(2,"aplist 0\n");
+		return -ENODATA;
+	}
+#if 0
+	/* current connect ap */
+	if((priv->connect_status & CONNECT_STATUS_MASK)== CONNECT_STATUS){
+		if ((extra + dwrq->length) - current_ev <= IW_EV_ADDR_LEN) {
+			dwrq->length = 0;
+			return -E2BIG;
+		}
+		current_ev = ks_wlan_translate_scan(dev, current_ev,
+//						    extra + IW_SCAN_MAX_DATA,
+						    extra + dwrq->length,
+						    &(priv->current_ap));
+	}
+#endif
+	/* Read and parse all entries */
+	for(i=0; i < priv->aplist.size; i++) {
+		if ((extra + dwrq->length) - current_ev <= IW_EV_ADDR_LEN) {
+			dwrq->length = 0;
+			return -E2BIG;
+		}
+		/* Translate to WE format this entry */
+		current_ev = ks_wlan_translate_scan(dev, info, current_ev,
+//						    extra + IW_SCAN_MAX_DATA,
+						    extra + dwrq->length,
+						    &(priv->aplist.ap[i]));
+	}
+	/* Length of data */
+	dwrq->length = (current_ev - extra);
+	dwrq->flags = 0;
+
+	return 0;
+}
+#endif	/* WIRELESS_EXT  */
+
+/*------------------------------------------------------------------*/
+/* Commit handler : called after a bunch of SET operations */
+static int ks_wlan_config_commit(struct net_device *dev, struct iw_request_info *info,
+				 void *zwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (!priv->need_commit)
+		return 0;
+
+	ks_wlan_setup_parameter(priv, priv->need_commit);
+	priv->need_commit=0;
+	return 0;
+}
+
+#ifdef WIRELESS_EXT
+/*------------------------------------------------------------------*/
+/* Wireless handler : set association ie params */
+static int ks_wlan_set_genie(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	DPRINTK(2, "\n");
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	return 0;
+//	return -EOPNOTSUPP;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless handler : set authentication mode params */
+static int ks_wlan_set_auth_mode(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_param *vwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	int index = (vwrq->flags & IW_AUTH_INDEX);
+	int value = vwrq->value;
+
+	DPRINTK(2,"index=%d:value=%08X\n",index,value);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	switch(index){
+	case IW_AUTH_WPA_VERSION: /* 0 */
+		switch(value){
+		case IW_AUTH_WPA_VERSION_DISABLED:
+			priv->wpa.version = value;
+			if(priv->wpa.rsn_enabled){
+				priv->wpa.rsn_enabled = 0;
+			}
+			priv->need_commit |= SME_RSN;
+			break;
+		case IW_AUTH_WPA_VERSION_WPA:
+		case IW_AUTH_WPA_VERSION_WPA2:
+			priv->wpa.version = value;
+			if(!(priv->wpa.rsn_enabled)){
+				priv->wpa.rsn_enabled = 1;
+			}
+			priv->need_commit |= SME_RSN;
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE: /* 1 */
+		switch(value){
+		case IW_AUTH_CIPHER_NONE:
+			if(priv->reg.privacy_invoked){
+				priv->reg.privacy_invoked = 0x00;
+				priv->need_commit |= SME_WEP_FLAG;
+			}
+			break;
+		case IW_AUTH_CIPHER_WEP40:
+		case IW_AUTH_CIPHER_TKIP:
+		case IW_AUTH_CIPHER_CCMP:
+		case IW_AUTH_CIPHER_WEP104:
+			if(!priv->reg.privacy_invoked){
+				priv->reg.privacy_invoked = 0x01;
+				priv->need_commit |= SME_WEP_FLAG;
+			}
+			priv->wpa.pairwise_suite = value;
+			priv->need_commit |= SME_RSN_UNICAST;
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	case IW_AUTH_CIPHER_GROUP: /* 2 */
+		switch(value){
+		case IW_AUTH_CIPHER_NONE:
+			if(priv->reg.privacy_invoked){
+				priv->reg.privacy_invoked = 0x00;
+				priv->need_commit |= SME_WEP_FLAG;
+			}
+			break;
+		case IW_AUTH_CIPHER_WEP40:
+		case IW_AUTH_CIPHER_TKIP:
+		case IW_AUTH_CIPHER_CCMP:
+		case IW_AUTH_CIPHER_WEP104:
+			if(!priv->reg.privacy_invoked){
+				priv->reg.privacy_invoked = 0x01;
+				priv->need_commit |= SME_WEP_FLAG;
+			}
+			priv->wpa.group_suite = value;
+			priv->need_commit |= SME_RSN_MULTICAST;
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	case IW_AUTH_KEY_MGMT: /* 3 */
+		switch(value){
+		case IW_AUTH_KEY_MGMT_802_1X:
+		case IW_AUTH_KEY_MGMT_PSK:
+		case 0: /* NONE or 802_1X_NO_WPA */
+		case 4: /* WPA_NONE */
+			priv->wpa.key_mgmt_suite = value;
+			priv->need_commit |= SME_RSN_AUTH;
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	case IW_AUTH_80211_AUTH_ALG: /* 6 */
+		switch(value){
+		case IW_AUTH_ALG_OPEN_SYSTEM:
+			priv->wpa.auth_alg = value;
+			priv->reg.authenticate_type = AUTH_TYPE_OPEN_SYSTEM;
+			break;
+		case IW_AUTH_ALG_SHARED_KEY:
+			priv->wpa.auth_alg = value;
+			priv->reg.authenticate_type = AUTH_TYPE_SHARED_KEY;
+			break;
+		case IW_AUTH_ALG_LEAP:
+		default:
+			return -EOPNOTSUPP;
+		}
+		priv->need_commit |= SME_MODE_SET;
+		break;
+	case IW_AUTH_WPA_ENABLED: /* 7 */
+		priv->wpa.wpa_enabled = value;
+		break;
+	case IW_AUTH_PRIVACY_INVOKED: /* 10 */
+		if((value && !priv->reg.privacy_invoked)||
+		   (!value && priv->reg.privacy_invoked)){
+			priv->reg.privacy_invoked = value?0x01:0x00;
+			priv->need_commit |= SME_WEP_FLAG;
+		}
+		break;
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL: /* 4 */
+	case IW_AUTH_TKIP_COUNTERMEASURES: /* 5 */
+	case IW_AUTH_DROP_UNENCRYPTED: /* 8 */
+	case IW_AUTH_ROAMING_CONTROL: /* 9 */
+	default:
+		break;
+	}
+
+	/* return -EINPROGRESS; */
+	if(priv->need_commit){
+		ks_wlan_setup_parameter(priv, priv->need_commit);
+		priv->need_commit=0;
+	}
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless handler : get authentication mode params */
+static int ks_wlan_get_auth_mode(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_param *vwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	int index = (vwrq->flags & IW_AUTH_INDEX);
+	DPRINTK(2,"index=%d\n",index);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	/*  WPA (not used ?? wpa_supplicant) */
+	switch(index){
+	case IW_AUTH_WPA_VERSION:
+		vwrq->value = priv->wpa.version;
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE:
+		vwrq->value = priv->wpa.pairwise_suite;
+		break;
+	case IW_AUTH_CIPHER_GROUP:
+		vwrq->value = priv->wpa.group_suite;
+		break;
+	case IW_AUTH_KEY_MGMT:
+		vwrq->value = priv->wpa.key_mgmt_suite;
+		break;
+	case IW_AUTH_80211_AUTH_ALG:
+		vwrq->value = priv->wpa.auth_alg;
+		break;
+	case IW_AUTH_WPA_ENABLED:
+		vwrq->value = priv->wpa.rsn_enabled;
+		break;
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL: /* OK??? */
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+	case IW_AUTH_DROP_UNENCRYPTED:
+	default:
+		/* return -EOPNOTSUPP; */
+		break;
+	}
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set encoding token & mode (WPA)*/
+static int ks_wlan_set_encode_ext(struct net_device *dev, struct iw_request_info *info,
+				  struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct iw_encode_ext *enc;
+	int index = dwrq->flags & IW_ENCODE_INDEX;
+	unsigned int commit=0;
+
+	enc = (struct iw_encode_ext *)extra;
+
+	DPRINTK(2,"flags=%04X:: ext_flags=%08X\n",dwrq->flags, enc->ext_flags);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(index<1||index>4)
+		return -EINVAL;
+	else
+		index--;
+
+	if(dwrq->flags & IW_ENCODE_DISABLED){
+		priv->wpa.key[index].key_len=0;
+	}
+
+	if(enc){
+		priv->wpa.key[index].ext_flags=enc->ext_flags;
+		if(enc->ext_flags&IW_ENCODE_EXT_SET_TX_KEY){
+			priv->wpa.txkey=index;
+			commit |= SME_WEP_INDEX;
+		}else if(enc->ext_flags&IW_ENCODE_EXT_RX_SEQ_VALID){
+			if(enc->rx_seq)
+				memcpy(&priv->wpa.key[index].rx_seq[0],
+				       enc->rx_seq, IW_ENCODE_SEQ_MAX_SIZE);
+			else
+				return -EINVAL;
+		}
+
+		memcpy(&priv->wpa.key[index].addr.sa_data[0],
+			   &enc->addr.sa_data[0], ETH_ALEN);
+
+		switch (enc->alg) {
+		case IW_ENCODE_ALG_NONE:
+			if(priv->reg.privacy_invoked){
+				priv->reg.privacy_invoked = 0x00;
+				commit |= SME_WEP_FLAG;
+			}
+			priv->wpa.key[index].key_len = 0;
+
+			break;
+		case IW_ENCODE_ALG_WEP:
+		case IW_ENCODE_ALG_CCMP:
+			if(!priv->reg.privacy_invoked){
+				priv->reg.privacy_invoked = 0x01;
+				commit |= SME_WEP_FLAG;
+			}
+			if(enc->key && enc->key_len){
+				memcpy(&priv->wpa.key[index].key_val[0],
+				       &enc->key[0], enc->key_len);
+				priv->wpa.key[index].key_len = enc->key_len;
+				commit |= (SME_WEP_VAL1 << index);
+			}
+			break;
+		case IW_ENCODE_ALG_TKIP:
+			if(!priv->reg.privacy_invoked){
+				priv->reg.privacy_invoked = 0x01;
+				commit |= SME_WEP_FLAG;
+			}
+			if(enc->key && enc->key_len == 32){
+				memcpy(&priv->wpa.key[index].key_val[0],
+				       &enc->key[0], enc->key_len-16);
+				priv->wpa.key[index].key_len = enc->key_len-16;
+				if(priv->wpa.key_mgmt_suite==4){ /* WPA_NONE */
+					memcpy(&priv->wpa.key[index].tx_mic_key[0],
+					       &enc->key[16],8);
+					memcpy(&priv->wpa.key[index].rx_mic_key[0],
+					       &enc->key[16],8);
+				}else{
+					memcpy(&priv->wpa.key[index].tx_mic_key[0],
+					       &enc->key[16],8);
+					memcpy(&priv->wpa.key[index].rx_mic_key[0],
+					       &enc->key[24],8);
+				}
+				commit |= (SME_WEP_VAL1 << index);
+			}
+			break;
+		default:
+			return -EINVAL;
+		}
+		priv->wpa.key[index].alg=enc->alg;
+	}
+	else
+		return -EINVAL;
+
+	if(commit){
+		if(commit&SME_WEP_INDEX)
+			hostif_sme_enqueue(priv, SME_SET_TXKEY);
+		if(commit&SME_WEP_VAL_MASK)
+			hostif_sme_enqueue(priv, SME_SET_KEY1+index);
+		if(commit&SME_WEP_FLAG)
+			hostif_sme_enqueue(priv, SME_WEP_FLAG_REQUEST);
+	}
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : get encoding token & mode (WPA)*/
+static int ks_wlan_get_encode_ext(struct net_device *dev, struct iw_request_info *info,
+				  struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	/*  WPA (not used ?? wpa_supplicant)
+	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	struct iw_encode_ext *enc;
+	enc = (struct iw_encode_ext *)extra;
+	int index = dwrq->flags & IW_ENCODE_INDEX;
+	 WPA (not used ?? wpa_supplicant) */
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : PMKSA cache operation (WPA2) */
+static int ks_wlan_set_pmksa(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct iw_pmksa *pmksa ;
+	int i;
+	struct pmk_t *pmk;
+	struct list_head *ptr;
+
+	DPRINTK(2,"\n");
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(!extra){
+		return -EINVAL;
+	}
+	pmksa = (struct iw_pmksa *)extra;
+	DPRINTK(2,"cmd=%d\n",pmksa->cmd);
+
+	switch(pmksa->cmd){
+	case IW_PMKSA_ADD:
+		if(list_empty(&priv->pmklist.head)){ /* new list */
+			for(i=0;i<PMK_LIST_MAX;i++){
+				pmk = &priv->pmklist.pmk[i];
+				if(!memcmp("\x00\x00\x00\x00\x00\x00",pmk->bssid,ETH_ALEN))
+					break;
+			}
+			memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
+			memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
+			list_add(&pmk->list,&priv->pmklist.head);
+			priv->pmklist.size++;
+		}
+		else { /* search cache data */
+			list_for_each(ptr, &priv->pmklist.head){
+				pmk = list_entry(ptr, struct pmk_t, list);
+				if(!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)){ /* match address! list move to head. */
+					memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
+					list_move(&pmk->list, &priv->pmklist.head);
+					break;
+				}
+			}
+			if(ptr == &priv->pmklist.head){ /* not find address. */
+				if(PMK_LIST_MAX > priv->pmklist.size){ /* new cache data */
+					for(i=0;i<PMK_LIST_MAX;i++){
+						pmk = &priv->pmklist.pmk[i];
+						if(!memcmp("\x00\x00\x00\x00\x00\x00",pmk->bssid,ETH_ALEN))
+							break;
+					}
+					memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
+					memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
+					list_add(&pmk->list,&priv->pmklist.head);
+					priv->pmklist.size++;
+				}
+				else{ /* overwrite old cache data */
+					pmk = list_entry(priv->pmklist.head.prev, struct pmk_t, list);
+					memcpy(pmk->bssid, pmksa->bssid.sa_data, ETH_ALEN);
+					memcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);
+					list_move(&pmk->list,&priv->pmklist.head);
+				}
+			}
+		}
+		break;
+	case IW_PMKSA_REMOVE:
+		if(list_empty(&priv->pmklist.head)){ /* list empty */
+			return -EINVAL;
+		}
+		else{ /* search cache data */
+			list_for_each(ptr, &priv->pmklist.head){
+				pmk = list_entry(ptr, struct pmk_t, list);
+				if(!memcmp(pmksa->bssid.sa_data, pmk->bssid, ETH_ALEN)){ /* match address! list del. */
+					memset(pmk->bssid, 0, ETH_ALEN);
+					memset(pmk->pmkid, 0, IW_PMKID_LEN);
+					list_del_init(&pmk->list);
+					break;
+				}
+			}
+			if(ptr == &priv->pmklist.head){ /* not find address. */
+				return 0;
+			}
+		}
+		break;
+	case IW_PMKSA_FLUSH:
+		memset(&(priv->pmklist), 0, sizeof(priv->pmklist));
+		INIT_LIST_HEAD(&priv->pmklist.head);
+		for(i=0;i<PMK_LIST_MAX;i++)
+			INIT_LIST_HEAD(&priv->pmklist.pmk[i].list);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	hostif_sme_enqueue(priv, SME_SET_PMKSA);
+	return 0;
+}
+
+static struct iw_statistics *ks_get_wireless_stats(struct net_device *dev)
+{
+
+	ks_wlan_private *priv = (ks_wlan_private *) netdev_priv(dev);
+		struct iw_statistics *wstats = &priv->wstats;
+
+	if(!atomic_read(&update_phyinfo)){
+		if (priv->dev_state < DEVICE_STATE_READY)
+			return NULL; /* not finished initialize */
+		else
+			return wstats;
+	}
+
+	/* Packets discarded in the wireless adapter due to wireless
+	 * specific problems */
+	wstats->discard.nwid = 0;	/* Rx invalid nwid	*/
+	wstats->discard.code = 0;	/* Rx invalid crypt	*/
+	wstats->discard.fragment = 0;	/* Rx invalid frag	*/
+	wstats->discard.retries = 0;	/* Tx excessive retries	*/
+	wstats->discard.misc = 0;	/* Invalid misc		*/
+	wstats->miss.beacon = 0;	/* Missed beacon	*/
+
+		return wstats;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : set stop request */
+static int ks_wlan_set_stop_request(struct net_device *dev, struct iw_request_info *info,
+				    __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	DPRINTK(2,"\n");
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(!(*uwrq))
+		return  -EINVAL;
+
+	hostif_sme_enqueue(priv, SME_STOP_REQUEST);
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Wireless Handler : set MLME */
+#include <linux/ieee80211.h>
+static int ks_wlan_set_mlme(struct net_device *dev, struct iw_request_info *info,
+				  struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	struct iw_mlme *mlme = (struct iw_mlme *)extra;
+	__u32 mode;
+
+	DPRINTK(2, ":%d :%d\n", mlme->cmd, mlme->reason_code);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	switch (mlme->cmd) {
+	case IW_MLME_DEAUTH:
+		if (mlme->reason_code == WLAN_REASON_MIC_FAILURE) {
+			return 0;
+		}
+	case IW_MLME_DISASSOC:
+		mode = 1;
+		return ks_wlan_set_stop_request(dev, NULL, &mode, NULL);
+	default:
+		return -EOPNOTSUPP;  /* Not Support */
+	}
+}
+#endif /* WIRELESS_EXT  */
+
+/*------------------------------------------------------------------*/
+/* Private handler : get driver version */
+static int ks_wlan_get_driver_version(struct net_device *dev, struct iw_request_info *info,
+				      struct iw_point *dwrq, char *extra)
+{
+	strcpy(extra, KS_WLAN_DRIVER_VERSION_INFO);
+	dwrq->length = strlen(KS_WLAN_DRIVER_VERSION_INFO)+1;
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get firemware version */
+static int ks_wlan_get_firmware_version(struct net_device *dev, struct iw_request_info *info,
+					struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	strcpy(extra, &(priv->firmware_version[0]));
+	dwrq->length = priv->version_size+1;
+	return 0;
+}
+
+#if 0
+/*------------------------------------------------------------------*/
+/* Private handler : set force disconnect status */
+static int ks_wlan_set_detach(struct net_device *dev, struct iw_request_info *info,
+				  __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(*uwrq == CONNECT_STATUS){ /* 0 */
+		priv->connect_status &= ~FORCE_DISCONNECT;
+		if((priv->connect_status & CONNECT_STATUS_MASK) == CONNECT_STATUS)
+			netif_carrier_on(dev);
+	}else if(*uwrq == DISCONNECT_STATUS){ /* 1 */
+		priv->connect_status |= FORCE_DISCONNECT;
+		netif_carrier_off(dev);
+	}else
+		return  -EINVAL;
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get force disconnect status */
+static int ks_wlan_get_detach(struct net_device *dev, struct iw_request_info *info,
+				  __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	*uwrq = ((priv->connect_status & FORCE_DISCONNECT) ? 1 : 0 );
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get connect status */
+static int ks_wlan_get_connect(struct net_device *dev, struct iw_request_info *info,
+				   __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	*uwrq = (priv->connect_status & CONNECT_STATUS_MASK);
+	return 0;
+}
+#endif
+
+/*------------------------------------------------------------------*/
+/* Private handler : set preamble */
+static int ks_wlan_set_preamble(struct net_device *dev, struct iw_request_info *info,
+				__u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(*uwrq == LONG_PREAMBLE){ /* 0 */
+		priv->reg.preamble = LONG_PREAMBLE;
+	}else if(*uwrq == SHORT_PREAMBLE){ /* 1 */
+		priv->reg.preamble = SHORT_PREAMBLE;
+	}else
+		return  -EINVAL;
+
+	priv->need_commit |= SME_MODE_SET;
+	return -EINPROGRESS;		/* Call commit handler */
+
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get preamble */
+static int ks_wlan_get_preamble(struct net_device *dev, struct iw_request_info *info,
+				__u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	*uwrq = priv->reg.preamble;
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : set power save mode */
+static int ks_wlan_set_powermgt(struct net_device *dev, struct iw_request_info *info,
+				__u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(*uwrq == POWMGT_ACTIVE_MODE){ /* 0 */
+		priv->reg.powermgt = POWMGT_ACTIVE_MODE;
+	}else if(*uwrq == POWMGT_SAVE1_MODE){  /* 1 */
+		if(priv->reg.operation_mode == MODE_INFRASTRUCTURE)
+			 priv->reg.powermgt = POWMGT_SAVE1_MODE;
+		 else
+			 return  -EINVAL;
+	}else if(*uwrq == POWMGT_SAVE2_MODE){  /* 2 */
+		if(priv->reg.operation_mode == MODE_INFRASTRUCTURE)
+			priv->reg.powermgt = POWMGT_SAVE2_MODE;
+		else
+			return -EINVAL;
+	}else
+		return  -EINVAL;
+
+	hostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get power save made */
+static int ks_wlan_get_powermgt(struct net_device *dev, struct iw_request_info *info,
+				__u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	*uwrq = priv->reg.powermgt;
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : set scan type */
+static int ks_wlan_set_scan_type(struct net_device *dev, struct iw_request_info *info,
+				 __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(*uwrq == ACTIVE_SCAN){ /* 0 */
+		priv->reg.scan_type = ACTIVE_SCAN;
+	}else if(*uwrq == PASSIVE_SCAN){ /* 1 */
+		priv->reg.scan_type = PASSIVE_SCAN;
+	}else
+		return  -EINVAL;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get scan type */
+static int ks_wlan_get_scan_type(struct net_device *dev, struct iw_request_info *info,
+				 __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	*uwrq = priv->reg.scan_type;
+	return 0;
+}
+#if 0
+/*------------------------------------------------------------------*/
+/* Private handler : write raw data to device */
+static int ks_wlan_data_write(struct net_device *dev, struct iw_request_info *info,
+				  struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	unsigned char *wbuff = NULL;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	wbuff = (unsigned char *)kmalloc(dwrq->length, GFP_ATOMIC);
+	if(!wbuff)
+			return  -EFAULT;
+	memcpy(wbuff, extra, dwrq->length);
+
+	/* write to device */
+	ks_wlan_hw_tx( priv, wbuff, dwrq->length, NULL, NULL, NULL);
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : read raw data form device */
+static int ks_wlan_data_read(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	unsigned short read_length;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(!atomic_read(&priv->event_count)){
+		if (priv->dev_state < DEVICE_STATE_BOOT) { /* Remove device */
+				read_length = 4;
+			memset(extra,0xff,read_length);
+			dwrq->length = read_length;
+			return 0;
+		}
+		read_length = 0;
+		memset(extra,0,1);
+		dwrq->length = 0;
+		return 0;
+	}
+
+	if(atomic_read(&priv->event_count)>0)
+			atomic_dec(&priv->event_count);
+
+	spin_lock(&priv->dev_read_lock);	/* request spin lock */
+
+		/* Copy length max size 0x07ff */
+	if(priv->dev_size[priv->dev_count] > 2047)
+		read_length = 2047;
+	else
+		read_length = priv->dev_size[priv->dev_count];
+
+	/* Copy data */
+	memcpy(extra, &(priv->dev_data[priv->dev_count][0]), read_length);
+
+	spin_unlock(&priv->dev_read_lock); /* release spin lock */
+
+	/* Initialize */
+	priv->dev_data[priv->dev_count] = 0;
+	priv->dev_size[priv->dev_count] = 0;
+
+	priv->dev_count++;
+	if(priv->dev_count == DEVICE_STOCK_COUNT)
+			 priv->dev_count=0;
+
+	/* Set read size */
+	dwrq->length = read_length;
+
+	return 0;
+}
+#endif
+
+#if 0
+/*------------------------------------------------------------------*/
+/* Private handler : get wep string */
+#define WEP_ASCII_BUFF_SIZE (17+64*4+1)
+static int ks_wlan_get_wep_ascii(struct net_device *dev, struct iw_request_info *info,
+				 struct iw_point *dwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	int i,j,len=0;
+	char tmp[WEP_ASCII_BUFF_SIZE];
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	strcpy(tmp," WEP keys ASCII \n");
+	len+=strlen(" WEP keys ASCII \n");
+
+	for(i=0;i<4;i++){
+		strcpy(tmp+len,"\t[");
+		len+=strlen("\t[");
+		tmp[len] = '1'+i;
+		len++;
+		strcpy(tmp+len,"] ");
+		len+=strlen("] ");
+		if(priv->reg.wep_key[i].size){
+			strcpy(tmp+len,(priv->reg.wep_key[i].size < 6 ? "(40bits) [" : "(104bits) ["));
+			len+=strlen((priv->reg.wep_key[i].size < 6 ? "(40bits) [" : "(104bits) ["));
+			for(j=0;j<priv->reg.wep_key[i].size;j++,len++)
+				tmp[len]=(isprint(priv->reg.wep_key[i].val[j]) ? priv->reg.wep_key[i].val[j] : ' ');
+
+			strcpy(tmp+len,"]\n");
+			len+=strlen("]\n");
+		}
+		else{
+			strcpy(tmp+len,"off\n");
+			len+=strlen("off\n");
+		}
+	}
+
+	memcpy(extra, tmp, len);
+	dwrq->length = len+1;
+	return 0;
+}
+#endif
+
+/*------------------------------------------------------------------*/
+/* Private handler : set beacon lost count */
+static int ks_wlan_set_beacon_lost(struct net_device *dev, struct iw_request_info *info,
+				   __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(*uwrq >= BEACON_LOST_COUNT_MIN &&
+	   *uwrq <= BEACON_LOST_COUNT_MAX){
+		priv->reg.beacon_lost_count = *uwrq;
+	}else
+		return  -EINVAL;
+
+	if(priv->reg.operation_mode == MODE_INFRASTRUCTURE){
+		priv->need_commit |= SME_MODE_SET;
+		return -EINPROGRESS;		/* Call commit handler */
+	}
+	else
+		return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get beacon lost count */
+static int ks_wlan_get_beacon_lost(struct net_device *dev, struct iw_request_info *info,
+				   __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	*uwrq = priv->reg.beacon_lost_count;
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : set phy type */
+static int ks_wlan_set_phy_type(struct net_device *dev, struct iw_request_info *info,
+				__u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(*uwrq == D_11B_ONLY_MODE){ /* 0 */
+		priv->reg.phy_type = D_11B_ONLY_MODE;
+	}else if(*uwrq == D_11G_ONLY_MODE){ /* 1 */
+		priv->reg.phy_type = D_11G_ONLY_MODE;
+	}else if(*uwrq == D_11BG_COMPATIBLE_MODE){ /* 2 */
+		priv->reg.phy_type = D_11BG_COMPATIBLE_MODE;
+	}else
+		return  -EINVAL;
+
+	priv->need_commit |= SME_MODE_SET;
+	return -EINPROGRESS;		/* Call commit handler */
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get phy type */
+static int ks_wlan_get_phy_type(struct net_device *dev, struct iw_request_info *info,
+				__u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	*uwrq = priv->reg.phy_type;
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : set cts mode */
+static int ks_wlan_set_cts_mode(struct net_device *dev, struct iw_request_info *info,
+				__u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(*uwrq == CTS_MODE_FALSE){ /* 0 */
+		priv->reg.cts_mode = CTS_MODE_FALSE;
+	}else if(*uwrq == CTS_MODE_TRUE){ /* 1 */
+		if(priv->reg.phy_type == D_11G_ONLY_MODE ||
+		   priv->reg.phy_type == D_11BG_COMPATIBLE_MODE)
+			priv->reg.cts_mode = CTS_MODE_TRUE;
+		else
+			priv->reg.cts_mode = CTS_MODE_FALSE;
+	}else
+		return  -EINVAL;
+
+	priv->need_commit |= SME_MODE_SET;
+	return -EINPROGRESS;		/* Call commit handler */
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get cts mode */
+static int ks_wlan_get_cts_mode(struct net_device *dev, struct iw_request_info *info,
+				__u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	*uwrq = priv->reg.cts_mode;
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : set sleep mode */
+static int ks_wlan_set_sleep_mode(struct net_device *dev,
+				     struct iw_request_info *info,
+				     __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	DPRINTK(2,"\n");
+
+	if(*uwrq == SLP_SLEEP){
+		priv->sleep_mode = *uwrq;
+		printk("SET_SLEEP_MODE %d\n", priv->sleep_mode);
+
+		hostif_sme_enqueue(priv, SME_STOP_REQUEST);
+		hostif_sme_enqueue(priv, SME_SLEEP_REQUEST);
+
+	}else if(*uwrq == SLP_ACTIVE) {
+		priv->sleep_mode = *uwrq;
+		printk("SET_SLEEP_MODE %d\n", priv->sleep_mode);
+		hostif_sme_enqueue(priv, SME_SLEEP_REQUEST);
+	}else{
+		printk("SET_SLEEP_MODE %d errror\n", *uwrq);
+		return  -EINVAL;
+	}
+
+	return 0;
+}
+/*------------------------------------------------------------------*/
+/* Private handler : get sleep mode */
+static int ks_wlan_get_sleep_mode(struct net_device *dev,
+				     struct iw_request_info *info,
+				     __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	DPRINTK(2, "GET_SLEEP_MODE %d\n", priv->sleep_mode);
+	*uwrq = priv->sleep_mode;
+
+	return 0;
+}
+
+#if 0
+/*------------------------------------------------------------------*/
+/* Private handler : set phy information timer */
+static int ks_wlan_set_phy_information_timer(struct net_device *dev, struct iw_request_info *info,
+					     __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(*uwrq >= 0 && *uwrq <= 0xFFFF) /* 0-65535 */
+		priv->reg.phy_info_timer = (uint16_t)*uwrq;
+	else
+		return  -EINVAL;
+
+	hostif_sme_enqueue(priv, SME_PHY_INFO_REQUEST);
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get phy information timer */
+static int ks_wlan_get_phy_information_timer(struct net_device *dev, struct iw_request_info *info,
+					     __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	*uwrq = priv->reg.phy_info_timer;
+	return 0;
+}
+#endif
+
+#ifdef WPS
+/*------------------------------------------------------------------*/
+/* Private handler : set WPS enable */
+static int ks_wlan_set_wps_enable(struct net_device *dev, struct iw_request_info *info,
+				  __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	DPRINTK(2,"\n");
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(*uwrq == 0 || *uwrq == 1)
+		priv->wps.wps_enabled = *uwrq;
+	else
+		return  -EINVAL;
+
+	hostif_sme_enqueue(priv, SME_WPS_ENABLE_REQUEST);
+
+	return 0;
+}
+/*------------------------------------------------------------------*/
+/* Private handler : get WPS enable */
+static int ks_wlan_get_wps_enable(struct net_device *dev, struct iw_request_info *info,
+				  __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+	DPRINTK(2,"\n");
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	*uwrq = priv->wps.wps_enabled;
+	printk("return=%d\n", *uwrq);
+
+	return 0;
+}
+/*------------------------------------------------------------------*/
+/* Private handler : set WPS probe req */
+static int ks_wlan_set_wps_probe_req(struct net_device *dev,
+				     struct iw_request_info *info,
+				     struct iw_point *dwrq, char *extra)
+{
+	uint8_t *p = extra;
+	unsigned char len;
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	DPRINTK(2,"\n");
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	DPRINTK(2,"dwrq->length=%d\n", dwrq->length);
+
+	/* length check */
+	if(p[1] + 2  != dwrq->length  || dwrq->length > 256  ){
+		return -EINVAL;
+	}
+
+	priv->wps.ielen = p[1] + 2 + 1;  /* IE header + IE + sizeof(len) */
+	len = p[1] + 2;              /* IE header + IE */
+
+	memcpy(priv->wps.ie, &len, sizeof(len));
+	p = memcpy(priv->wps.ie+1, p, len);
+
+	DPRINTK(2,"%d(%#x): %02X %02X %02X %02X ... %02X %02X %02X\n",
+		priv->wps.ielen, priv->wps.ielen, p[0], p[1], p[2], p[3],
+		p[priv->wps.ielen-3], p[priv->wps.ielen-2], p[priv->wps.ielen-1]);
+
+	hostif_sme_enqueue(priv, SME_WPS_PROBE_REQUEST);
+
+	return 0;
+}
+#if 0
+/*------------------------------------------------------------------*/
+/* Private handler : get WPS probe req */
+static int ks_wlan_get_wps_probe_req(struct net_device *dev,
+				     struct iw_request_info *info,
+				     __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+	DPRINTK(2,"\n");
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	return 0;
+}
+#endif
+#endif /* WPS */
+
+/*------------------------------------------------------------------*/
+/* Private handler : set tx gain control value */
+static int ks_wlan_set_tx_gain(struct net_device *dev, struct iw_request_info *info,
+					     __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(*uwrq >= 0 && *uwrq <= 0xFF) /* 0-255 */
+		priv->gain.TxGain = (uint8_t)*uwrq;
+	else
+		return  -EINVAL;
+
+	if(priv->gain.TxGain < 0xFF)
+		priv->gain.TxMode = 1;
+	else
+		priv->gain.TxMode = 0;
+
+
+	hostif_sme_enqueue(priv, SME_SET_GAIN);
+	return  0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get tx gain control value */
+static int ks_wlan_get_tx_gain(struct net_device *dev, struct iw_request_info *info,
+					     __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	*uwrq = priv->gain.TxGain;
+	hostif_sme_enqueue(priv, SME_GET_GAIN);
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : set rx gain control value */
+static int ks_wlan_set_rx_gain(struct net_device *dev, struct iw_request_info *info,
+					     __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(*uwrq >= 0 && *uwrq <= 0xFF) /* 0-255 */
+		priv->gain.RxGain = (uint8_t)*uwrq;
+	else
+		return  -EINVAL;
+
+	if(priv->gain.RxGain < 0xFF)
+		priv->gain.RxMode = 1;
+	else
+		priv->gain.RxMode = 0;
+
+	hostif_sme_enqueue(priv, SME_SET_GAIN);
+	return  0;
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get rx gain control value */
+static int ks_wlan_get_rx_gain(struct net_device *dev, struct iw_request_info *info,
+					     __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	*uwrq = priv->gain.RxGain;
+	hostif_sme_enqueue(priv, SME_GET_GAIN);
+	return 0;
+}
+#if 0
+/*------------------------------------------------------------------*/
+/* Private handler : set region value */
+static int ks_wlan_set_region(struct net_device *dev, struct iw_request_info *info,
+					     __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)dev->priv;
+
+	if (priv->sleep_mode == SLP_SLEEP){ return -EPERM; }  /* for SLEEP MODE */
+
+	if(*uwrq >= 0x9 && *uwrq <= 0xF) /* 0x9-0xf */
+		priv->region = (uint8_t)*uwrq;
+	else
+		return  -EINVAL;
+
+	hostif_sme_enqueue(priv, SME_SET_REGION);
+	return  0;
+}
+#endif
+
+/*------------------------------------------------------------------*/
+/* Private handler : get eeprom checksum result */
+static int ks_wlan_get_eeprom_cksum(struct net_device *dev, struct iw_request_info *info,
+					     __u32 *uwrq, char *extra)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	*uwrq = priv->eeprom_checksum;
+	return 0;
+}
+
+static void print_hif_event(int event){
+
+	switch(event){
+	case HIF_DATA_REQ	:
+		printk("HIF_DATA_REQ\n");
+		break;
+	case HIF_DATA_IND	:
+		printk("HIF_DATA_IND\n");
+		break;
+	case HIF_MIB_GET_REQ	:
+		printk("HIF_MIB_GET_REQ\n");
+		break;
+	case HIF_MIB_GET_CONF	:
+		printk("HIF_MIB_GET_CONF\n");
+		break;
+	case HIF_MIB_SET_REQ	:
+		printk("HIF_MIB_SET_REQ\n");
+		break;
+	case HIF_MIB_SET_CONF	:
+		printk("HIF_MIB_SET_CONF\n");
+		break;
+	case HIF_POWERMGT_REQ	:
+		printk("HIF_POWERMGT_REQ\n");
+		break;
+	case HIF_POWERMGT_CONF	:
+		printk("HIF_POWERMGT_CONF\n");
+		break;
+	case HIF_START_REQ	:
+		printk("HIF_START_REQ\n");
+		break;
+	case HIF_START_CONF	:
+		printk("HIF_START_CONF\n");
+		break;
+	case HIF_CONNECT_IND	:
+		printk("HIF_CONNECT_IND\n");
+		break;
+	case HIF_STOP_REQ	:
+		printk("HIF_STOP_REQ\n");
+		break;
+	case HIF_STOP_CONF	:
+		printk("HIF_STOP_CONF\n");
+		break;
+	case HIF_PS_ADH_SET_REQ	:
+		printk("HIF_PS_ADH_SET_REQ\n");
+		break;
+	case HIF_PS_ADH_SET_CONF:
+		printk("HIF_PS_ADH_SET_CONF\n");
+		break;
+	case HIF_INFRA_SET_REQ	:
+		printk("HIF_INFRA_SET_REQ\n");
+		break;
+	case HIF_INFRA_SET_CONF	:
+		printk("HIF_INFRA_SET_CONF\n");
+		break;
+	case HIF_ADH_SET_REQ	:
+		printk("HIF_ADH_SET_REQ\n");
+		break;
+	case HIF_ADH_SET_CONF	:
+		printk("HIF_ADH_SET_CONF\n");
+		break;
+	case HIF_AP_SET_REQ	:
+		printk("HIF_AP_SET_REQ\n");
+		break;
+	case HIF_AP_SET_CONF	:
+		printk("HIF_AP_SET_CONF\n");
+		break;
+	case HIF_ASSOC_INFO_IND	:
+		printk("HIF_ASSOC_INFO_IND\n");
+		break;
+	case HIF_MIC_FAILURE_REQ:
+		printk("HIF_MIC_FAILURE_REQ\n");
+		break;
+	case HIF_MIC_FAILURE_CONF	:
+		printk("HIF_MIC_FAILURE_CONF\n");
+		break;
+	case HIF_SCAN_REQ	:
+		printk("HIF_SCAN_REQ\n");
+		break;
+	case HIF_SCAN_CONF	:
+		printk("HIF_SCAN_CONF\n");
+		break;
+	case HIF_PHY_INFO_REQ	:
+		printk("HIF_PHY_INFO_REQ\n");
+		break;
+	case HIF_PHY_INFO_CONF	:
+		printk("HIF_PHY_INFO_CONF\n");
+		break;
+	case HIF_SLEEP_REQ	:
+		printk("HIF_SLEEP_REQ\n");
+		break;
+	case HIF_SLEEP_CONF	:
+		printk("HIF_SLEEP_CONF\n");
+		break;
+	case HIF_PHY_INFO_IND	:
+		printk("HIF_PHY_INFO_IND\n");
+		break;
+	case HIF_SCAN_IND	:
+		printk("HIF_SCAN_IND\n");
+		break;
+	case HIF_INFRA_SET2_REQ	:
+		printk("HIF_INFRA_SET2_REQ\n");
+		break;
+	case HIF_INFRA_SET2_CONF:
+		printk("HIF_INFRA_SET2_CONF\n");
+		break;
+	case HIF_ADH_SET2_REQ	:
+		printk("HIF_ADH_SET2_REQ\n");
+		break;
+	case HIF_ADH_SET2_CONF	:
+		printk("HIF_ADH_SET2_CONF\n");
+	}
+}
+
+/*------------------------------------------------------------------*/
+/* Private handler : get host command history */
+static int ks_wlan_hostt(struct net_device *dev, struct iw_request_info *info,
+					     __u32 *uwrq, char *extra)
+{
+	int i,event;
+	ks_wlan_private *priv = (ks_wlan_private *)netdev_priv(dev);
+
+	for(i = 63; i >= 0; i--){
+		event =	priv->hostt.buff[(priv->hostt.qtail -1 -i)%SME_EVENT_BUFF_SIZE] ;
+		print_hif_event(event);
+	}
+	return 0;
+}
+
+/* Structures to export the Wireless Handlers */
+
+static const struct iw_priv_args ks_wlan_private_args[] = {
+/*{ cmd, set_args, get_args, name[16] } */
+  { KS_WLAN_GET_DRIVER_VERSION, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | (128+1), "GetDriverVer" },
+  { KS_WLAN_GET_FIRM_VERSION,   IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | (128+1), "GetFirmwareVer" },
+#ifdef WPS
+  { KS_WLAN_SET_WPS_ENABLE,     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetWPSEnable" },
+  { KS_WLAN_GET_WPS_ENABLE,     IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetW" },
+  { KS_WLAN_SET_WPS_PROBE_REQ, IW_PRIV_TYPE_BYTE | 2047, IW_PRIV_TYPE_NONE, "SetWPSProbeReq" },
+#endif /* WPS */
+  { KS_WLAN_SET_PREAMBLE,       IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetPreamble" },
+  { KS_WLAN_GET_PREAMBLE,       IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetPreamble" },
+  { KS_WLAN_SET_POWER_SAVE,     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetPowerSave" },
+  { KS_WLAN_GET_POWER_SAVE,     IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetPowerSave" },
+  { KS_WLAN_SET_SCAN_TYPE,      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetScanType" },
+  { KS_WLAN_GET_SCAN_TYPE,      IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetScanType" },
+  { KS_WLAN_SET_RX_GAIN,        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetRxGain" },
+  { KS_WLAN_GET_RX_GAIN,        IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetRxGain" },
+  { KS_WLAN_HOSTT,      	IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | (128+1), "hostt" },
+  { KS_WLAN_SET_BEACON_LOST,    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetBeaconLost" },
+  { KS_WLAN_GET_BEACON_LOST,    IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetBeaconLost" },
+  { KS_WLAN_SET_SLEEP_MODE,     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetSleepMode" },
+  { KS_WLAN_GET_SLEEP_MODE,     IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetSleepMode" },
+  { KS_WLAN_SET_TX_GAIN,        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetTxGain" },
+  { KS_WLAN_GET_TX_GAIN,        IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetTxGain" },
+  { KS_WLAN_SET_PHY_TYPE,       IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetPhyType" },
+  { KS_WLAN_GET_PHY_TYPE,       IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetPhyType" },
+  { KS_WLAN_SET_CTS_MODE,       IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE, "SetCtsMode" },
+  { KS_WLAN_GET_CTS_MODE,       IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetCtsMode" },
+  { KS_WLAN_GET_EEPROM_CKSUM,   IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "GetChecksum" },
+};
+static const iw_handler		ks_wlan_handler[] =
+{
+	(iw_handler) ks_wlan_config_commit,	/* SIOCSIWCOMMIT */
+	(iw_handler) ks_wlan_get_name,		/* SIOCGIWNAME */
+	(iw_handler) NULL,			/* SIOCSIWNWID */
+	(iw_handler) NULL,			/* SIOCGIWNWID */
+	(iw_handler) ks_wlan_set_freq,		/* SIOCSIWFREQ */
+	(iw_handler) ks_wlan_get_freq,		/* SIOCGIWFREQ */
+	(iw_handler) ks_wlan_set_mode,		/* SIOCSIWMODE */
+	(iw_handler) ks_wlan_get_mode,		/* SIOCGIWMODE */
+#ifndef KSC_OPNOTSUPP
+	(iw_handler) ks_wlan_set_sens,		/* SIOCSIWSENS */
+	(iw_handler) ks_wlan_get_sens,		/* SIOCGIWSENS */
+#else /* KSC_OPNOTSUPP */
+	(iw_handler) NULL,		        /* SIOCSIWSENS */
+	(iw_handler) NULL,		        /* SIOCGIWSENS */
+#endif /* KSC_OPNOTSUPP */
+	(iw_handler) NULL,			/* SIOCSIWRANGE */
+	(iw_handler) ks_wlan_get_range,		/* SIOCGIWRANGE */
+	(iw_handler) NULL,			/* SIOCSIWPRIV */
+	(iw_handler) NULL,			/* SIOCGIWPRIV */
+	(iw_handler) NULL,			/* SIOCSIWSTATS */
+	(iw_handler) ks_wlan_get_iwstats,	/* SIOCGIWSTATS */
+	(iw_handler) NULL,			/* SIOCSIWSPY */
+	(iw_handler) NULL,			/* SIOCGIWSPY */
+	(iw_handler) NULL,			/* SIOCSIWTHRSPY */
+	(iw_handler) NULL,			/* SIOCGIWTHRSPY */
+	(iw_handler) ks_wlan_set_wap,		/* SIOCSIWAP */
+	(iw_handler) ks_wlan_get_wap,		/* SIOCGIWAP */
+//	(iw_handler) NULL,			/* SIOCSIWMLME */
+	(iw_handler) ks_wlan_set_mlme,		/* SIOCSIWMLME */
+	(iw_handler) ks_wlan_get_aplist,	/* SIOCGIWAPLIST */
+	(iw_handler) ks_wlan_set_scan,		/* SIOCSIWSCAN */
+	(iw_handler) ks_wlan_get_scan,		/* SIOCGIWSCAN */
+	(iw_handler) ks_wlan_set_essid,		/* SIOCSIWESSID */
+	(iw_handler) ks_wlan_get_essid,		/* SIOCGIWESSID */
+	(iw_handler) ks_wlan_set_nick,		/* SIOCSIWNICKN */
+	(iw_handler) ks_wlan_get_nick,		/* SIOCGIWNICKN */
+	(iw_handler) NULL,			/* -- hole -- */
+	(iw_handler) NULL,			/* -- hole -- */
+	(iw_handler) ks_wlan_set_rate,		/* SIOCSIWRATE */
+	(iw_handler) ks_wlan_get_rate,		/* SIOCGIWRATE */
+	(iw_handler) ks_wlan_set_rts,		/* SIOCSIWRTS */
+	(iw_handler) ks_wlan_get_rts,		/* SIOCGIWRTS */
+	(iw_handler) ks_wlan_set_frag,		/* SIOCSIWFRAG */
+	(iw_handler) ks_wlan_get_frag,		/* SIOCGIWFRAG */
+#ifndef KSC_OPNOTSUPP
+	(iw_handler) ks_wlan_set_txpow,		/* SIOCSIWTXPOW */
+	(iw_handler) ks_wlan_get_txpow,		/* SIOCGIWTXPOW */
+	(iw_handler) ks_wlan_set_retry,		/* SIOCSIWRETRY */
+	(iw_handler) ks_wlan_get_retry,		/* SIOCGIWRETRY */
+#else /* KSC_OPNOTSUPP */
+	(iw_handler) NULL,    		        /* SIOCSIWTXPOW */
+	(iw_handler) NULL,		        /* SIOCGIWTXPOW */
+	(iw_handler) NULL,		        /* SIOCSIWRETRY */
+	(iw_handler) NULL,		        /* SIOCGIWRETRY */
+#endif /* KSC_OPNOTSUPP */
+	(iw_handler) ks_wlan_set_encode,	/* SIOCSIWENCODE */
+	(iw_handler) ks_wlan_get_encode,	/* SIOCGIWENCODE */
+	(iw_handler) ks_wlan_set_power,		/* SIOCSIWPOWER */
+	(iw_handler) ks_wlan_get_power,		/* SIOCGIWPOWER */
+	(iw_handler) NULL,			/* -- hole -- */
+	(iw_handler) NULL,			/* -- hole -- */
+//	(iw_handler) NULL,			/* SIOCSIWGENIE */
+	(iw_handler) ks_wlan_set_genie,		/* SIOCSIWGENIE */
+	(iw_handler) NULL,			/* SIOCGIWGENIE */
+	(iw_handler) ks_wlan_set_auth_mode,	/* SIOCSIWAUTH */
+	(iw_handler) ks_wlan_get_auth_mode,	/* SIOCGIWAUTH */
+	(iw_handler) ks_wlan_set_encode_ext,	/* SIOCSIWENCODEEXT */
+	(iw_handler) ks_wlan_get_encode_ext,	/* SIOCGIWENCODEEXT */
+	(iw_handler) ks_wlan_set_pmksa,		/* SIOCSIWPMKSA */
+	(iw_handler) NULL,			/* -- hole -- */
+};
+
+/* private_handler */
+static const iw_handler		ks_wlan_private_handler[] =
+{
+	(iw_handler) NULL,				/*  0 */
+	(iw_handler) ks_wlan_get_driver_version,	/*  1 KS_WLAN_GET_DRIVER_VERSION */
+	(iw_handler) NULL,				/*  2 */
+	(iw_handler) ks_wlan_get_firmware_version,	/*  3 KS_WLAN_GET_FIRM_VERSION */
+#ifdef WPS
+	(iw_handler) ks_wlan_set_wps_enable, 		/*  4 KS_WLAN_SET_WPS_ENABLE  */
+	(iw_handler) ks_wlan_get_wps_enable, 		/*  5 KS_WLAN_GET_WPS_ENABLE  */
+	(iw_handler) ks_wlan_set_wps_probe_req, 	/*  6 KS_WLAN_SET_WPS_PROBE_REQ */
+#else
+	(iw_handler) NULL,				/*  4 */
+	(iw_handler) NULL,				/*  5 */
+	(iw_handler) NULL,				/*  6 */
+#endif /* WPS */
+
+	(iw_handler) ks_wlan_get_eeprom_cksum,		/*  7 KS_WLAN_GET_CONNECT */
+	(iw_handler) ks_wlan_set_preamble,		/*  8 KS_WLAN_SET_PREAMBLE */
+	(iw_handler) ks_wlan_get_preamble,		/*  9 KS_WLAN_GET_PREAMBLE */
+	(iw_handler) ks_wlan_set_powermgt,		/* 10 KS_WLAN_SET_POWER_SAVE */
+	(iw_handler) ks_wlan_get_powermgt,		/* 11 KS_WLAN_GET_POWER_SAVE */
+	(iw_handler) ks_wlan_set_scan_type,		/* 12 KS_WLAN_SET_SCAN_TYPE */
+	(iw_handler) ks_wlan_get_scan_type,		/* 13 KS_WLAN_GET_SCAN_TYPE */
+	(iw_handler) ks_wlan_set_rx_gain,		/* 14 KS_WLAN_SET_RX_GAIN */
+	(iw_handler) ks_wlan_get_rx_gain,		/* 15 KS_WLAN_GET_RX_GAIN */
+	(iw_handler) ks_wlan_hostt,			/* 16 KS_WLAN_HOSTT */
+	(iw_handler) NULL,				/* 17 */
+	(iw_handler) ks_wlan_set_beacon_lost,		/* 18 KS_WLAN_SET_BECAN_LOST */
+	(iw_handler) ks_wlan_get_beacon_lost,		/* 19 KS_WLAN_GET_BECAN_LOST */
+	(iw_handler) ks_wlan_set_tx_gain,		/* 20 KS_WLAN_SET_TX_GAIN */
+	(iw_handler) ks_wlan_get_tx_gain,		/* 21 KS_WLAN_GET_TX_GAIN */
+	(iw_handler) ks_wlan_set_phy_type,		/* 22 KS_WLAN_SET_PHY_TYPE */
+	(iw_handler) ks_wlan_get_phy_type,		/* 23 KS_WLAN_GET_PHY_TYPE */
+	(iw_handler) ks_wlan_set_cts_mode,		/* 24 KS_WLAN_SET_CTS_MODE */
+	(iw_handler) ks_wlan_get_cts_mode,		/* 25 KS_WLAN_GET_CTS_MODE */
+	(iw_handler) NULL,				/* 26 */
+	(iw_handler) NULL,				/* 27 */
+ 	(iw_handler) ks_wlan_set_sleep_mode,		/* 28 KS_WLAN_SET_SLEEP_MODE */
+ 	(iw_handler) ks_wlan_get_sleep_mode,		/* 29 KS_WLAN_GET_SLEEP_MODE */
+	(iw_handler) NULL,				/* 30 */
+	(iw_handler) NULL,				/* 31 */
+};
+
+static const struct iw_handler_def	ks_wlan_handler_def =
+{
+	.num_standard	= sizeof(ks_wlan_handler)/sizeof(iw_handler),
+	.num_private	= sizeof(ks_wlan_private_handler)/sizeof(iw_handler),
+	.num_private_args = sizeof(ks_wlan_private_args)/sizeof(struct iw_priv_args),
+	.standard	= (iw_handler *) ks_wlan_handler,
+	.private	= (iw_handler *) ks_wlan_private_handler,
+	.private_args	= (struct iw_priv_args *) ks_wlan_private_args,
+	.get_wireless_stats = ks_get_wireless_stats,
+};
+
+#endif /* WIRELESS_EXT */
+
+static int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	int rc = 0;
+#if defined(WIRELESS_EXT)
+	struct iwreq *wrq = (struct iwreq *) rq;
+#endif /* WIRELESS_EXT */
+	switch (cmd) {
+#if defined(WIRELESS_EXT)
+	case SIOCIWFIRSTPRIV+20: /* KS_WLAN_SET_STOP_REQ */
+		rc = ks_wlan_set_stop_request(dev, NULL, &(wrq->u.mode), NULL);
+		break;
+#endif /* WIRELESS_EXT >17 */
+	// All other calls are currently unsupported
+	default:
+		rc = -EOPNOTSUPP;
+	}
+
+	DPRINTK(5,"return=%d\n",rc);
+	return rc;
+}
+
+
+static
+struct net_device_stats *ks_wlan_get_stats(struct net_device *dev)
+{
+	ks_wlan_private *priv = netdev_priv(dev);
+
+	if (priv->dev_state < DEVICE_STATE_READY) {
+				return NULL; /* not finished initialize */
+		}
+
+	return &priv->nstats;
+}
+
+static
+int ks_wlan_set_mac_address(struct net_device *dev, void *addr)
+{
+	ks_wlan_private *priv = netdev_priv(dev);
+	struct sockaddr *mac_addr=(struct sockaddr *)addr;
+	if (netif_running(dev))
+		return -EBUSY;
+	memcpy(dev->dev_addr, mac_addr->sa_data, dev->addr_len);
+	memcpy(priv->eth_addr, mac_addr->sa_data, ETH_ALEN);
+
+	priv->mac_address_valid = 0;
+	hostif_sme_enqueue(priv, SME_MACADDRESS_SET_REQUEST);
+	printk(KERN_INFO "ks_wlan: MAC ADDRESS = %02x:%02x:%02x:%02x:%02x:%02x\n",
+			   priv->eth_addr[0],priv->eth_addr[1],priv->eth_addr[2],
+			   priv->eth_addr[3],priv->eth_addr[4],priv->eth_addr[5]);
+	return 0;
+}
+
+
+static
+void ks_wlan_tx_timeout(struct net_device *dev)
+{
+		ks_wlan_private *priv = netdev_priv(dev);
+
+	DPRINTK(1,"head(%d) tail(%d)!!\n",priv->tx_dev.qhead, priv->tx_dev.qtail);
+	if(!netif_queue_stopped(dev)){
+		netif_stop_queue(dev);
+	}
+	priv->nstats.tx_errors++;
+	netif_wake_queue(dev);
+
+	return;
+}
+
+static
+int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	ks_wlan_private *priv = netdev_priv(dev);
+	int rc = 0;
+
+	DPRINTK(3,"in_interrupt()=%ld\n",in_interrupt());
+
+	if ( skb == NULL ) {
+		printk( KERN_ERR "ks_wlan:  skb == NULL!!!\n" );
+		return 0;
+	}
+	if (priv->dev_state < DEVICE_STATE_READY) {
+		dev_kfree_skb(skb);
+		return 0; /* not finished initialize */
+		}
+
+	if(netif_running(dev))
+		netif_stop_queue(dev);
+
+	rc = hostif_data_request(priv, skb);
+	dev->trans_start = jiffies;
+
+	DPRINTK(4,"rc=%d\n",rc);
+	if (rc){
+		rc=0;
+	}
+
+	return rc;
+}
+
+void send_packet_complete(void *arg1, void *arg2)
+{
+	ks_wlan_private *priv = (ks_wlan_private *)arg1;
+	struct sk_buff *packet = (struct sk_buff *)arg2;
+
+		DPRINTK(3,"\n");
+
+		priv->nstats.tx_bytes += packet->len;
+	priv->nstats.tx_packets++;
+
+	if(netif_queue_stopped(priv->net_dev))
+			netif_wake_queue(priv->net_dev);
+
+	if(packet){
+		dev_kfree_skb(packet);
+		packet=NULL;
+	}
+
+}
+
+/* Set or clear the multicast filter for this adaptor.
+   This routine is not state sensitive and need not be SMP locked. */
+static
+void ks_wlan_set_multicast_list(struct net_device *dev)
+{
+	ks_wlan_private *priv = netdev_priv(dev);
+
+	DPRINTK(4,"\n");
+	if (priv->dev_state < DEVICE_STATE_READY) {
+				return ; /* not finished initialize */
+	}
+	hostif_sme_enqueue(priv, SME_MULTICAST_REQUEST);
+
+	return;
+}
+
+static
+int ks_wlan_open(struct net_device *dev)
+{
+	ks_wlan_private *priv = netdev_priv(dev);
+
+	priv->cur_rx = 0;
+
+	if(!priv->mac_address_valid){
+		printk(KERN_ERR "ks_wlan : %s Not READY !!\n", dev->name);
+		return -EBUSY;
+	}
+	else
+		netif_start_queue (dev);
+
+	return 0;
+}
+
+static
+int ks_wlan_close(struct net_device *dev)
+{
+
+	netif_stop_queue (dev);
+
+	DPRINTK(4, "%s: Shutting down ethercard, status was 0x%4.4x.\n",
+		dev->name, 0x00);
+
+	return 0;
+}
+
+
+/* Operational parameters that usually are not changed. */
+/* Time in jiffies before concluding the transmitter is hung. */
+#define TX_TIMEOUT  (3*HZ)
+static const unsigned char dummy_addr[] = {0x00,0x0b,0xe3,0x00,0x00,0x00};
+
+static const struct net_device_ops ks_wlan_netdev_ops = {
+	.ndo_start_xmit         = ks_wlan_start_xmit,
+	.ndo_open               = ks_wlan_open,
+	.ndo_stop               = ks_wlan_close,
+	.ndo_do_ioctl           = ks_wlan_netdev_ioctl,
+	.ndo_set_mac_address    = ks_wlan_set_mac_address,
+	.ndo_get_stats 		= ks_wlan_get_stats,
+	.ndo_tx_timeout         = ks_wlan_tx_timeout,
+	.ndo_set_rx_mode        = ks_wlan_set_multicast_list,
+};
+
+int ks_wlan_net_start(struct net_device *dev)
+{
+	ks_wlan_private *priv;
+	/* int rc; */
+
+	priv = netdev_priv(dev);
+	priv->mac_address_valid = 0;
+	priv->need_commit = 0;
+
+	priv->device_open_status = 1;
+
+	/* phy information update timer */
+	atomic_set(&update_phyinfo,0);
+	init_timer(&update_phyinfo_timer);
+	update_phyinfo_timer.function=ks_wlan_update_phyinfo_timeout;
+	update_phyinfo_timer.data = (unsigned long)priv;
+
+	/* dummy address set */
+	memcpy(priv->eth_addr, dummy_addr, ETH_ALEN);
+	dev->dev_addr[0] = priv->eth_addr[0];
+	dev->dev_addr[1] = priv->eth_addr[1];
+	dev->dev_addr[2] = priv->eth_addr[2];
+	dev->dev_addr[3] = priv->eth_addr[3];
+	dev->dev_addr[4] = priv->eth_addr[4];
+	dev->dev_addr[5] = priv->eth_addr[5];
+	dev->dev_addr[6] = 0x00;
+	dev->dev_addr[7] = 0x00;
+
+	/* The ks_wlan-specific entries in the device structure. */
+	dev->netdev_ops = &ks_wlan_netdev_ops;
+	dev->wireless_handlers = (struct iw_handler_def *)&ks_wlan_handler_def;
+	dev->watchdog_timeo = TX_TIMEOUT;
+
+	netif_carrier_off(dev);
+
+	return 0;
+}
+
+
+int ks_wlan_net_stop(struct net_device *dev)
+{
+	ks_wlan_private *priv = netdev_priv(dev);
+
+	int ret = 0;
+	priv->device_open_status = 0;
+	del_timer_sync(&update_phyinfo_timer);
+
+	if(netif_running(dev))
+		netif_stop_queue(dev);
+
+	return ret;
+}
+
+int ks_wlan_reset(struct net_device *dev)
+{
+	return 0;
+}
