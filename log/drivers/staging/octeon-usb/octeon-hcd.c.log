commit 5979afa2c4d1c8acce28a176ebe27ea13265626a
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Feb 20 07:29:08 2020 -0600

    staging: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20200220132908.GA30501@embeddedor
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 582c9187559d..61471a19d4e6 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -406,7 +406,7 @@ struct octeon_hcd {
  */
 struct octeon_temp_buffer {
 	void *orig_buffer;
-	u8 data[0];
+	u8 data[];
 };
 
 static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)

commit 96b06c0a16f737e9ea7dff1e23dd5f6d847e6731
Author: Chris Packham <chris.packham@alliedtelesis.co.nz>
Date:   Wed Feb 5 13:11:11 2020 +1300

    Revert "staging: octeon-usb: delete the octeon usb host controller driver"
    
    This reverts commit 95ace52e4036482da1895b6e19f15141802cc3dd. Re-instate
    the code so subsequent commits can clean it up and get it building
    properly.
    
    Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
    Link: https://lore.kernel.org/r/20200205001116.14096-2-chris.packham@alliedtelesis.co.nz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
new file mode 100644
index 000000000000..582c9187559d
--- /dev/null
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -0,0 +1,3737 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2008 Cavium Networks
+ *
+ * Some parts of the code were originally released under BSD license:
+ *
+ * Copyright (c) 2003-2010 Cavium Networks (support@cavium.com). All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *
+ *   * Neither the name of Cavium Networks nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export
+ * control laws, including the U.S. Export Administration Act and its associated
+ * regulations, and may be subject to export or import regulations in other
+ * countries.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION
+ * OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ */
+
+#include <linux/usb.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/usb/hcd.h>
+#include <linux/prefetch.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+
+#include <asm/octeon/octeon.h>
+
+#include "octeon-hcd.h"
+
+/**
+ * enum cvmx_usb_speed - the possible USB device speeds
+ *
+ * @CVMX_USB_SPEED_HIGH: Device is operation at 480Mbps
+ * @CVMX_USB_SPEED_FULL: Device is operation at 12Mbps
+ * @CVMX_USB_SPEED_LOW:  Device is operation at 1.5Mbps
+ */
+enum cvmx_usb_speed {
+	CVMX_USB_SPEED_HIGH = 0,
+	CVMX_USB_SPEED_FULL = 1,
+	CVMX_USB_SPEED_LOW = 2,
+};
+
+/**
+ * enum cvmx_usb_transfer - the possible USB transfer types
+ *
+ * @CVMX_USB_TRANSFER_CONTROL:	   USB transfer type control for hub and status
+ *				   transfers
+ * @CVMX_USB_TRANSFER_ISOCHRONOUS: USB transfer type isochronous for low
+ *				   priority periodic transfers
+ * @CVMX_USB_TRANSFER_BULK:	   USB transfer type bulk for large low priority
+ *				   transfers
+ * @CVMX_USB_TRANSFER_INTERRUPT:   USB transfer type interrupt for high priority
+ *				   periodic transfers
+ */
+enum cvmx_usb_transfer {
+	CVMX_USB_TRANSFER_CONTROL = 0,
+	CVMX_USB_TRANSFER_ISOCHRONOUS = 1,
+	CVMX_USB_TRANSFER_BULK = 2,
+	CVMX_USB_TRANSFER_INTERRUPT = 3,
+};
+
+/**
+ * enum cvmx_usb_direction - the transfer directions
+ *
+ * @CVMX_USB_DIRECTION_OUT: Data is transferring from Octeon to the device/host
+ * @CVMX_USB_DIRECTION_IN:  Data is transferring from the device/host to Octeon
+ */
+enum cvmx_usb_direction {
+	CVMX_USB_DIRECTION_OUT,
+	CVMX_USB_DIRECTION_IN,
+};
+
+/**
+ * enum cvmx_usb_status - possible callback function status codes
+ *
+ * @CVMX_USB_STATUS_OK:		  The transaction / operation finished without
+ *				  any errors
+ * @CVMX_USB_STATUS_SHORT:	  FIXME: This is currently not implemented
+ * @CVMX_USB_STATUS_CANCEL:	  The transaction was canceled while in flight
+ *				  by a user call to cvmx_usb_cancel
+ * @CVMX_USB_STATUS_ERROR:	  The transaction aborted with an unexpected
+ *				  error status
+ * @CVMX_USB_STATUS_STALL:	  The transaction received a USB STALL response
+ *				  from the device
+ * @CVMX_USB_STATUS_XACTERR:	  The transaction failed with an error from the
+ *				  device even after a number of retries
+ * @CVMX_USB_STATUS_DATATGLERR:	  The transaction failed with a data toggle
+ *				  error even after a number of retries
+ * @CVMX_USB_STATUS_BABBLEERR:	  The transaction failed with a babble error
+ * @CVMX_USB_STATUS_FRAMEERR:	  The transaction failed with a frame error
+ *				  even after a number of retries
+ */
+enum cvmx_usb_status {
+	CVMX_USB_STATUS_OK,
+	CVMX_USB_STATUS_SHORT,
+	CVMX_USB_STATUS_CANCEL,
+	CVMX_USB_STATUS_ERROR,
+	CVMX_USB_STATUS_STALL,
+	CVMX_USB_STATUS_XACTERR,
+	CVMX_USB_STATUS_DATATGLERR,
+	CVMX_USB_STATUS_BABBLEERR,
+	CVMX_USB_STATUS_FRAMEERR,
+};
+
+/**
+ * struct cvmx_usb_port_status - the USB port status information
+ *
+ * @port_enabled:	1 = Usb port is enabled, 0 = disabled
+ * @port_over_current:	1 = Over current detected, 0 = Over current not
+ *			detected. Octeon doesn't support over current detection.
+ * @port_powered:	1 = Port power is being supplied to the device, 0 =
+ *			power is off. Octeon doesn't support turning port power
+ *			off.
+ * @port_speed:		Current port speed.
+ * @connected:		1 = A device is connected to the port, 0 = No device is
+ *			connected.
+ * @connect_change:	1 = Device connected state changed since the last set
+ *			status call.
+ */
+struct cvmx_usb_port_status {
+	u32 reserved			: 25;
+	u32 port_enabled		: 1;
+	u32 port_over_current		: 1;
+	u32 port_powered		: 1;
+	enum cvmx_usb_speed port_speed	: 2;
+	u32 connected			: 1;
+	u32 connect_change		: 1;
+};
+
+/**
+ * struct cvmx_usb_iso_packet - descriptor for Isochronous packets
+ *
+ * @offset:	This is the offset in bytes into the main buffer where this data
+ *		is stored.
+ * @length:	This is the length in bytes of the data.
+ * @status:	This is the status of this individual packet transfer.
+ */
+struct cvmx_usb_iso_packet {
+	int offset;
+	int length;
+	enum cvmx_usb_status status;
+};
+
+/**
+ * enum cvmx_usb_initialize_flags - flags used by the initialization function
+ *
+ * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI:    The USB port uses a 12MHz crystal
+ *					      as clock source at USB_XO and
+ *					      USB_XI.
+ * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND:   The USB port uses 12/24/48MHz 2.5V
+ *					      board clock source at USB_XO.
+ *					      USB_XI should be tied to GND.
+ * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK: Mask for clock speed field
+ * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ:    Speed of reference clock or
+ *					      crystal
+ * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ:    Speed of reference clock
+ * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ:    Speed of reference clock
+ * @CVMX_USB_INITIALIZE_FLAGS_NO_DMA:	      Disable DMA and used polled IO for
+ *					      data transfer use for the USB
+ */
+enum cvmx_usb_initialize_flags {
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI		= 1 << 0,
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND		= 1 << 1,
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK	= 3 << 3,
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ		= 1 << 3,
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ		= 2 << 3,
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ		= 3 << 3,
+	/* Bits 3-4 used to encode the clock frequency */
+	CVMX_USB_INITIALIZE_FLAGS_NO_DMA		= 1 << 5,
+};
+
+/**
+ * enum cvmx_usb_pipe_flags - internal flags for a pipe.
+ *
+ * @CVMX_USB_PIPE_FLAGS_SCHEDULED: Used internally to determine if a pipe is
+ *				   actively using hardware.
+ * @CVMX_USB_PIPE_FLAGS_NEED_PING: Used internally to determine if a high speed
+ *				   pipe is in the ping state.
+ */
+enum cvmx_usb_pipe_flags {
+	CVMX_USB_PIPE_FLAGS_SCHEDULED	= 1 << 17,
+	CVMX_USB_PIPE_FLAGS_NEED_PING	= 1 << 18,
+};
+
+/* Maximum number of times to retry failed transactions */
+#define MAX_RETRIES		3
+
+/* Maximum number of hardware channels supported by the USB block */
+#define MAX_CHANNELS		8
+
+/*
+ * The low level hardware can transfer a maximum of this number of bytes in each
+ * transfer. The field is 19 bits wide
+ */
+#define MAX_TRANSFER_BYTES	((1 << 19) - 1)
+
+/*
+ * The low level hardware can transfer a maximum of this number of packets in
+ * each transfer. The field is 10 bits wide
+ */
+#define MAX_TRANSFER_PACKETS	((1 << 10) - 1)
+
+/**
+ * Logical transactions may take numerous low level
+ * transactions, especially when splits are concerned. This
+ * enum represents all of the possible stages a transaction can
+ * be in. Note that split completes are always even. This is so
+ * the NAK handler can backup to the previous low level
+ * transaction with a simple clearing of bit 0.
+ */
+enum cvmx_usb_stage {
+	CVMX_USB_STAGE_NON_CONTROL,
+	CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE,
+	CVMX_USB_STAGE_SETUP,
+	CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE,
+	CVMX_USB_STAGE_DATA,
+	CVMX_USB_STAGE_DATA_SPLIT_COMPLETE,
+	CVMX_USB_STAGE_STATUS,
+	CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE,
+};
+
+/**
+ * struct cvmx_usb_transaction - describes each pending USB transaction
+ *				 regardless of type. These are linked together
+ *				 to form a list of pending requests for a pipe.
+ *
+ * @node:		List node for transactions in the pipe.
+ * @type:		Type of transaction, duplicated of the pipe.
+ * @flags:		State flags for this transaction.
+ * @buffer:		User's physical buffer address to read/write.
+ * @buffer_length:	Size of the user's buffer in bytes.
+ * @control_header:	For control transactions, physical address of the 8
+ *			byte standard header.
+ * @iso_start_frame:	For ISO transactions, the starting frame number.
+ * @iso_number_packets:	For ISO transactions, the number of packets in the
+ *			request.
+ * @iso_packets:	For ISO transactions, the sub packets in the request.
+ * @actual_bytes:	Actual bytes transfer for this transaction.
+ * @stage:		For control transactions, the current stage.
+ * @urb:		URB.
+ */
+struct cvmx_usb_transaction {
+	struct list_head node;
+	enum cvmx_usb_transfer type;
+	u64 buffer;
+	int buffer_length;
+	u64 control_header;
+	int iso_start_frame;
+	int iso_number_packets;
+	struct cvmx_usb_iso_packet *iso_packets;
+	int xfersize;
+	int pktcnt;
+	int retries;
+	int actual_bytes;
+	enum cvmx_usb_stage stage;
+	struct urb *urb;
+};
+
+/**
+ * struct cvmx_usb_pipe - a pipe represents a virtual connection between Octeon
+ *			  and some USB device. It contains a list of pending
+ *			  request to the device.
+ *
+ * @node:		List node for pipe list
+ * @next:		Pipe after this one in the list
+ * @transactions:	List of pending transactions
+ * @interval:		For periodic pipes, the interval between packets in
+ *			frames
+ * @next_tx_frame:	The next frame this pipe is allowed to transmit on
+ * @flags:		State flags for this pipe
+ * @device_speed:	Speed of device connected to this pipe
+ * @transfer_type:	Type of transaction supported by this pipe
+ * @transfer_dir:	IN or OUT. Ignored for Control
+ * @multi_count:	Max packet in a row for the device
+ * @max_packet:		The device's maximum packet size in bytes
+ * @device_addr:	USB device address at other end of pipe
+ * @endpoint_num:	USB endpoint number at other end of pipe
+ * @hub_device_addr:	Hub address this device is connected to
+ * @hub_port:		Hub port this device is connected to
+ * @pid_toggle:		This toggles between 0/1 on every packet send to track
+ *			the data pid needed
+ * @channel:		Hardware DMA channel for this pipe
+ * @split_sc_frame:	The low order bits of the frame number the split
+ *			complete should be sent on
+ */
+struct cvmx_usb_pipe {
+	struct list_head node;
+	struct list_head transactions;
+	u64 interval;
+	u64 next_tx_frame;
+	enum cvmx_usb_pipe_flags flags;
+	enum cvmx_usb_speed device_speed;
+	enum cvmx_usb_transfer transfer_type;
+	enum cvmx_usb_direction transfer_dir;
+	int multi_count;
+	u16 max_packet;
+	u8 device_addr;
+	u8 endpoint_num;
+	u8 hub_device_addr;
+	u8 hub_port;
+	u8 pid_toggle;
+	u8 channel;
+	s8 split_sc_frame;
+};
+
+struct cvmx_usb_tx_fifo {
+	struct {
+		int channel;
+		int size;
+		u64 address;
+	} entry[MAX_CHANNELS + 1];
+	int head;
+	int tail;
+};
+
+/**
+ * struct octeon_hcd - the state of the USB block
+ *
+ * lock:		   Serialization lock.
+ * init_flags:		   Flags passed to initialize.
+ * index:		   Which USB block this is for.
+ * idle_hardware_channels: Bit set for every idle hardware channel.
+ * usbcx_hprt:		   Stored port status so we don't need to read a CSR to
+ *			   determine splits.
+ * pipe_for_channel:	   Map channels to pipes.
+ * pipe:		   Storage for pipes.
+ * indent:		   Used by debug output to indent functions.
+ * port_status:		   Last port status used for change notification.
+ * idle_pipes:		   List of open pipes that have no transactions.
+ * active_pipes:	   Active pipes indexed by transfer type.
+ * frame_number:	   Increments every SOF interrupt for time keeping.
+ * active_split:	   Points to the current active split, or NULL.
+ */
+struct octeon_hcd {
+	spinlock_t lock; /* serialization lock */
+	int init_flags;
+	int index;
+	int idle_hardware_channels;
+	union cvmx_usbcx_hprt usbcx_hprt;
+	struct cvmx_usb_pipe *pipe_for_channel[MAX_CHANNELS];
+	int indent;
+	struct cvmx_usb_port_status port_status;
+	struct list_head idle_pipes;
+	struct list_head active_pipes[4];
+	u64 frame_number;
+	struct cvmx_usb_transaction *active_split;
+	struct cvmx_usb_tx_fifo periodic;
+	struct cvmx_usb_tx_fifo nonperiodic;
+};
+
+/*
+ * This macro logically sets a single field in a CSR. It does the sequence
+ * read, modify, and write
+ */
+#define USB_SET_FIELD32(address, _union, field, value)		\
+	do {							\
+		union _union c;					\
+								\
+		c.u32 = cvmx_usb_read_csr32(usb, address);	\
+		c.s.field = value;				\
+		cvmx_usb_write_csr32(usb, address, c.u32);	\
+	} while (0)
+
+/* Returns the IO address to push/pop stuff data from the FIFOs */
+#define USB_FIFO_ADDRESS(channel, usb_index) \
+	(CVMX_USBCX_GOTGCTL(usb_index) + ((channel) + 1) * 0x1000)
+
+/**
+ * struct octeon_temp_buffer - a bounce buffer for USB transfers
+ * @orig_buffer: the original buffer passed by the USB stack
+ * @data:	 the newly allocated temporary buffer (excluding meta-data)
+ *
+ * Both the DMA engine and FIFO mode will always transfer full 32-bit words. If
+ * the buffer is too short, we need to allocate a temporary one, and this struct
+ * represents it.
+ */
+struct octeon_temp_buffer {
+	void *orig_buffer;
+	u8 data[0];
+};
+
+static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
+{
+	return container_of((void *)p, struct usb_hcd, hcd_priv);
+}
+
+/**
+ * octeon_alloc_temp_buffer - allocate a temporary buffer for USB transfer
+ *                            (if needed)
+ * @urb:	URB.
+ * @mem_flags:	Memory allocation flags.
+ *
+ * This function allocates a temporary bounce buffer whenever it's needed
+ * due to HW limitations.
+ */
+static int octeon_alloc_temp_buffer(struct urb *urb, gfp_t mem_flags)
+{
+	struct octeon_temp_buffer *temp;
+
+	if (urb->num_sgs || urb->sg ||
+	    (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP) ||
+	    !(urb->transfer_buffer_length % sizeof(u32)))
+		return 0;
+
+	temp = kmalloc(ALIGN(urb->transfer_buffer_length, sizeof(u32)) +
+		       sizeof(*temp), mem_flags);
+	if (!temp)
+		return -ENOMEM;
+
+	temp->orig_buffer = urb->transfer_buffer;
+	if (usb_urb_dir_out(urb))
+		memcpy(temp->data, urb->transfer_buffer,
+		       urb->transfer_buffer_length);
+	urb->transfer_buffer = temp->data;
+	urb->transfer_flags |= URB_ALIGNED_TEMP_BUFFER;
+
+	return 0;
+}
+
+/**
+ * octeon_free_temp_buffer - free a temporary buffer used by USB transfers.
+ * @urb: URB.
+ *
+ * Frees a buffer allocated by octeon_alloc_temp_buffer().
+ */
+static void octeon_free_temp_buffer(struct urb *urb)
+{
+	struct octeon_temp_buffer *temp;
+	size_t length;
+
+	if (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))
+		return;
+
+	temp = container_of(urb->transfer_buffer, struct octeon_temp_buffer,
+			    data);
+	if (usb_urb_dir_in(urb)) {
+		if (usb_pipeisoc(urb->pipe))
+			length = urb->transfer_buffer_length;
+		else
+			length = urb->actual_length;
+
+		memcpy(temp->orig_buffer, urb->transfer_buffer, length);
+	}
+	urb->transfer_buffer = temp->orig_buffer;
+	urb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;
+	kfree(temp);
+}
+
+/**
+ * octeon_map_urb_for_dma - Octeon-specific map_urb_for_dma().
+ * @hcd:	USB HCD structure.
+ * @urb:	URB.
+ * @mem_flags:	Memory allocation flags.
+ */
+static int octeon_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
+				  gfp_t mem_flags)
+{
+	int ret;
+
+	ret = octeon_alloc_temp_buffer(urb, mem_flags);
+	if (ret)
+		return ret;
+
+	ret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);
+	if (ret)
+		octeon_free_temp_buffer(urb);
+
+	return ret;
+}
+
+/**
+ * octeon_unmap_urb_for_dma - Octeon-specific unmap_urb_for_dma()
+ * @hcd:	USB HCD structure.
+ * @urb:	URB.
+ */
+static void octeon_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
+{
+	usb_hcd_unmap_urb_for_dma(hcd, urb);
+	octeon_free_temp_buffer(urb);
+}
+
+/**
+ * Read a USB 32bit CSR. It performs the necessary address swizzle
+ * for 32bit CSRs and logs the value in a readable format if
+ * debugging is on.
+ *
+ * @usb:     USB block this access is for
+ * @address: 64bit address to read
+ *
+ * Returns: Result of the read
+ */
+static inline u32 cvmx_usb_read_csr32(struct octeon_hcd *usb, u64 address)
+{
+	return cvmx_read64_uint32(address ^ 4);
+}
+
+/**
+ * Write a USB 32bit CSR. It performs the necessary address
+ * swizzle for 32bit CSRs and logs the value in a readable format
+ * if debugging is on.
+ *
+ * @usb:     USB block this access is for
+ * @address: 64bit address to write
+ * @value:   Value to write
+ */
+static inline void cvmx_usb_write_csr32(struct octeon_hcd *usb,
+					u64 address, u32 value)
+{
+	cvmx_write64_uint32(address ^ 4, value);
+	cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
+}
+
+/**
+ * Return non zero if this pipe connects to a non HIGH speed
+ * device through a high speed hub.
+ *
+ * @usb:    USB block this access is for
+ * @pipe:   Pipe to check
+ *
+ * Returns: Non zero if we need to do split transactions
+ */
+static inline int cvmx_usb_pipe_needs_split(struct octeon_hcd *usb,
+					    struct cvmx_usb_pipe *pipe)
+{
+	return pipe->device_speed != CVMX_USB_SPEED_HIGH &&
+	       usb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_HIGH;
+}
+
+/**
+ * Trivial utility function to return the correct PID for a pipe
+ *
+ * @pipe:   pipe to check
+ *
+ * Returns: PID for pipe
+ */
+static inline int cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)
+{
+	if (pipe->pid_toggle)
+		return 2; /* Data1 */
+	return 0; /* Data0 */
+}
+
+/* Loops through register until txfflsh or rxfflsh become zero.*/
+static int cvmx_wait_tx_rx(struct octeon_hcd *usb, int fflsh_type)
+{
+	int result;
+	u64 address = CVMX_USBCX_GRSTCTL(usb->index);
+	u64 done = cvmx_get_cycle() + 100 *
+		   (u64)octeon_get_clock_rate / 1000000;
+	union cvmx_usbcx_grstctl c;
+
+	while (1) {
+		c.u32 = cvmx_usb_read_csr32(usb, address);
+		if (fflsh_type == 0 && c.s.txfflsh == 0) {
+			result = 0;
+			break;
+		} else if (fflsh_type == 1 && c.s.rxfflsh == 0) {
+			result = 0;
+			break;
+		} else if (cvmx_get_cycle() > done) {
+			result = -1;
+			break;
+		}
+
+		__delay(100);
+	}
+	return result;
+}
+
+static void cvmx_fifo_setup(struct octeon_hcd *usb)
+{
+	union cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;
+	union cvmx_usbcx_gnptxfsiz npsiz;
+	union cvmx_usbcx_hptxfsiz psiz;
+
+	usbcx_ghwcfg3.u32 = cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_GHWCFG3(usb->index));
+
+	/*
+	 * Program the USBC_GRXFSIZ register to select the size of the receive
+	 * FIFO (25%).
+	 */
+	USB_SET_FIELD32(CVMX_USBCX_GRXFSIZ(usb->index), cvmx_usbcx_grxfsiz,
+			rxfdep, usbcx_ghwcfg3.s.dfifodepth / 4);
+
+	/*
+	 * Program the USBC_GNPTXFSIZ register to select the size and the start
+	 * address of the non-periodic transmit FIFO for nonperiodic
+	 * transactions (50%).
+	 */
+	npsiz.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index));
+	npsiz.s.nptxfdep = usbcx_ghwcfg3.s.dfifodepth / 2;
+	npsiz.s.nptxfstaddr = usbcx_ghwcfg3.s.dfifodepth / 4;
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index), npsiz.u32);
+
+	/*
+	 * Program the USBC_HPTXFSIZ register to select the size and start
+	 * address of the periodic transmit FIFO for periodic transactions
+	 * (25%).
+	 */
+	psiz.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index));
+	psiz.s.ptxfsize = usbcx_ghwcfg3.s.dfifodepth / 4;
+	psiz.s.ptxfstaddr = 3 * usbcx_ghwcfg3.s.dfifodepth / 4;
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index), psiz.u32);
+
+	/* Flush all FIFOs */
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			cvmx_usbcx_grstctl, txfnum, 0x10);
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			cvmx_usbcx_grstctl, txfflsh, 1);
+	cvmx_wait_tx_rx(usb, 0);
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			cvmx_usbcx_grstctl, rxfflsh, 1);
+	cvmx_wait_tx_rx(usb, 1);
+}
+
+/**
+ * Shutdown a USB port after a call to cvmx_usb_initialize().
+ * The port should be disabled with all pipes closed when this
+ * function is called.
+ *
+ * @usb: USB device state populated by cvmx_usb_initialize().
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_shutdown(struct octeon_hcd *usb)
+{
+	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
+
+	/* Make sure all pipes are closed */
+	if (!list_empty(&usb->idle_pipes) ||
+	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_ISOCHRONOUS]) ||
+	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_INTERRUPT]) ||
+	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_CONTROL]) ||
+	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_BULK]))
+		return -EBUSY;
+
+	/* Disable the clocks and put them in power on reset */
+	usbn_clk_ctl.u64 = cvmx_read64_uint64(CVMX_USBNX_CLK_CTL(usb->index));
+	usbn_clk_ctl.s.enable = 1;
+	usbn_clk_ctl.s.por = 1;
+	usbn_clk_ctl.s.hclk_rst = 1;
+	usbn_clk_ctl.s.prst = 0;
+	usbn_clk_ctl.s.hrst = 0;
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	return 0;
+}
+
+/**
+ * Initialize a USB port for use. This must be called before any
+ * other access to the Octeon USB port is made. The port starts
+ * off in the disabled state.
+ *
+ * @dev:	 Pointer to struct device for logging purposes.
+ * @usb:	 Pointer to struct octeon_hcd.
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_initialize(struct device *dev,
+			       struct octeon_hcd *usb)
+{
+	int channel;
+	int divisor;
+	int retries = 0;
+	union cvmx_usbcx_hcfg usbcx_hcfg;
+	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
+	union cvmx_usbcx_gintsts usbc_gintsts;
+	union cvmx_usbcx_gahbcfg usbcx_gahbcfg;
+	union cvmx_usbcx_gintmsk usbcx_gintmsk;
+	union cvmx_usbcx_gusbcfg usbcx_gusbcfg;
+	union cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;
+
+retry:
+	/*
+	 * Power On Reset and PHY Initialization
+	 *
+	 * 1. Wait for DCOK to assert (nothing to do)
+	 *
+	 * 2a. Write USBN0/1_CLK_CTL[POR] = 1 and
+	 *     USBN0/1_CLK_CTL[HRST,PRST,HCLK_RST] = 0
+	 */
+	usbn_clk_ctl.u64 = cvmx_read64_uint64(CVMX_USBNX_CLK_CTL(usb->index));
+	usbn_clk_ctl.s.por = 1;
+	usbn_clk_ctl.s.hrst = 0;
+	usbn_clk_ctl.s.prst = 0;
+	usbn_clk_ctl.s.hclk_rst = 0;
+	usbn_clk_ctl.s.enable = 0;
+	/*
+	 * 2b. Select the USB reference clock/crystal parameters by writing
+	 *     appropriate values to USBN0/1_CLK_CTL[P_C_SEL, P_RTYPE, P_COM_ON]
+	 */
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND) {
+		/*
+		 * The USB port uses 12/24/48MHz 2.5V board clock
+		 * source at USB_XO. USB_XI should be tied to GND.
+		 * Most Octeon evaluation boards require this setting
+		 */
+		if (OCTEON_IS_MODEL(OCTEON_CN3XXX) ||
+		    OCTEON_IS_MODEL(OCTEON_CN56XX) ||
+		    OCTEON_IS_MODEL(OCTEON_CN50XX))
+			/* From CN56XX,CN50XX,CN31XX,CN30XX manuals */
+			usbn_clk_ctl.s.p_rtype = 2; /* p_rclk=1 & p_xenbn=0 */
+		else
+			/* From CN52XX manual */
+			usbn_clk_ctl.s.p_rtype = 1;
+
+		switch (usb->init_flags &
+			CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK) {
+		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ:
+			usbn_clk_ctl.s.p_c_sel = 0;
+			break;
+		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ:
+			usbn_clk_ctl.s.p_c_sel = 1;
+			break;
+		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ:
+			usbn_clk_ctl.s.p_c_sel = 2;
+			break;
+		}
+	} else {
+		/*
+		 * The USB port uses a 12MHz crystal as clock source
+		 * at USB_XO and USB_XI
+		 */
+		if (OCTEON_IS_MODEL(OCTEON_CN3XXX))
+			/* From CN31XX,CN30XX manual */
+			usbn_clk_ctl.s.p_rtype = 3; /* p_rclk=1 & p_xenbn=1 */
+		else
+			/* From CN56XX,CN52XX,CN50XX manuals. */
+			usbn_clk_ctl.s.p_rtype = 0;
+
+		usbn_clk_ctl.s.p_c_sel = 0;
+	}
+	/*
+	 * 2c. Select the HCLK via writing USBN0/1_CLK_CTL[DIVIDE, DIVIDE2] and
+	 *     setting USBN0/1_CLK_CTL[ENABLE] = 1. Divide the core clock down
+	 *     such that USB is as close as possible to 125Mhz
+	 */
+	divisor = DIV_ROUND_UP(octeon_get_clock_rate(), 125000000);
+	/* Lower than 4 doesn't seem to work properly */
+	if (divisor < 4)
+		divisor = 4;
+	usbn_clk_ctl.s.divide = divisor;
+	usbn_clk_ctl.s.divide2 = 0;
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+
+	/* 2d. Write USBN0/1_CLK_CTL[HCLK_RST] = 1 */
+	usbn_clk_ctl.s.hclk_rst = 1;
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	/* 2e.  Wait 64 core-clock cycles for HCLK to stabilize */
+	__delay(64);
+	/*
+	 * 3. Program the power-on reset field in the USBN clock-control
+	 *    register:
+	 *    USBN_CLK_CTL[POR] = 0
+	 */
+	usbn_clk_ctl.s.por = 0;
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	/* 4. Wait 1 ms for PHY clock to start */
+	mdelay(1);
+	/*
+	 * 5. Program the Reset input from automatic test equipment field in the
+	 *    USBP control and status register:
+	 *    USBN_USBP_CTL_STATUS[ATE_RESET] = 1
+	 */
+	usbn_usbp_ctl_status.u64 =
+		cvmx_read64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index));
+	usbn_usbp_ctl_status.s.ate_reset = 1;
+	cvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),
+			    usbn_usbp_ctl_status.u64);
+	/* 6. Wait 10 cycles */
+	__delay(10);
+	/*
+	 * 7. Clear ATE_RESET field in the USBN clock-control register:
+	 *    USBN_USBP_CTL_STATUS[ATE_RESET] = 0
+	 */
+	usbn_usbp_ctl_status.s.ate_reset = 0;
+	cvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),
+			    usbn_usbp_ctl_status.u64);
+	/*
+	 * 8. Program the PHY reset field in the USBN clock-control register:
+	 *    USBN_CLK_CTL[PRST] = 1
+	 */
+	usbn_clk_ctl.s.prst = 1;
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	/*
+	 * 9. Program the USBP control and status register to select host or
+	 *    device mode. USBN_USBP_CTL_STATUS[HST_MODE] = 0 for host, = 1 for
+	 *    device
+	 */
+	usbn_usbp_ctl_status.s.hst_mode = 0;
+	cvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),
+			    usbn_usbp_ctl_status.u64);
+	/* 10. Wait 1 us */
+	udelay(1);
+	/*
+	 * 11. Program the hreset_n field in the USBN clock-control register:
+	 *     USBN_CLK_CTL[HRST] = 1
+	 */
+	usbn_clk_ctl.s.hrst = 1;
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	/* 12. Proceed to USB core initialization */
+	usbn_clk_ctl.s.enable = 1;
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	udelay(1);
+
+	/*
+	 * USB Core Initialization
+	 *
+	 * 1. Read USBC_GHWCFG1, USBC_GHWCFG2, USBC_GHWCFG3, USBC_GHWCFG4 to
+	 *    determine USB core configuration parameters.
+	 *
+	 *    Nothing needed
+	 *
+	 * 2. Program the following fields in the global AHB configuration
+	 *    register (USBC_GAHBCFG)
+	 *    DMA mode, USBC_GAHBCFG[DMAEn]: 1 = DMA mode, 0 = slave mode
+	 *    Burst length, USBC_GAHBCFG[HBSTLEN] = 0
+	 *    Nonperiodic TxFIFO empty level (slave mode only),
+	 *    USBC_GAHBCFG[NPTXFEMPLVL]
+	 *    Periodic TxFIFO empty level (slave mode only),
+	 *    USBC_GAHBCFG[PTXFEMPLVL]
+	 *    Global interrupt mask, USBC_GAHBCFG[GLBLINTRMSK] = 1
+	 */
+	usbcx_gahbcfg.u32 = 0;
+	usbcx_gahbcfg.s.dmaen = !(usb->init_flags &
+				  CVMX_USB_INITIALIZE_FLAGS_NO_DMA);
+	usbcx_gahbcfg.s.hbstlen = 0;
+	usbcx_gahbcfg.s.nptxfemplvl = 1;
+	usbcx_gahbcfg.s.ptxfemplvl = 1;
+	usbcx_gahbcfg.s.glblintrmsk = 1;
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_GAHBCFG(usb->index),
+			     usbcx_gahbcfg.u32);
+
+	/*
+	 * 3. Program the following fields in USBC_GUSBCFG register.
+	 *    HS/FS timeout calibration, USBC_GUSBCFG[TOUTCAL] = 0
+	 *    ULPI DDR select, USBC_GUSBCFG[DDRSEL] = 0
+	 *    USB turnaround time, USBC_GUSBCFG[USBTRDTIM] = 0x5
+	 *    PHY low-power clock select, USBC_GUSBCFG[PHYLPWRCLKSEL] = 0
+	 */
+	usbcx_gusbcfg.u32 = cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_GUSBCFG(usb->index));
+	usbcx_gusbcfg.s.toutcal = 0;
+	usbcx_gusbcfg.s.ddrsel = 0;
+	usbcx_gusbcfg.s.usbtrdtim = 0x5;
+	usbcx_gusbcfg.s.phylpwrclksel = 0;
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index),
+			     usbcx_gusbcfg.u32);
+
+	/*
+	 * 4. The software must unmask the following bits in the USBC_GINTMSK
+	 *    register.
+	 *    OTG interrupt mask, USBC_GINTMSK[OTGINTMSK] = 1
+	 *    Mode mismatch interrupt mask, USBC_GINTMSK[MODEMISMSK] = 1
+	 */
+	usbcx_gintmsk.u32 = cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_GINTMSK(usb->index));
+	usbcx_gintmsk.s.otgintmsk = 1;
+	usbcx_gintmsk.s.modemismsk = 1;
+	usbcx_gintmsk.s.hchintmsk = 1;
+	usbcx_gintmsk.s.sofmsk = 0;
+	/* We need RX FIFO interrupts if we don't have DMA */
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+		usbcx_gintmsk.s.rxflvlmsk = 1;
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTMSK(usb->index),
+			     usbcx_gintmsk.u32);
+
+	/*
+	 * Disable all channel interrupts. We'll enable them per channel later.
+	 */
+	for (channel = 0; channel < 8; channel++)
+		cvmx_usb_write_csr32(usb,
+				     CVMX_USBCX_HCINTMSKX(channel, usb->index),
+				     0);
+
+	/*
+	 * Host Port Initialization
+	 *
+	 * 1. Program the host-port interrupt-mask field to unmask,
+	 *    USBC_GINTMSK[PRTINT] = 1
+	 */
+	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+			cvmx_usbcx_gintmsk, prtintmsk, 1);
+	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+			cvmx_usbcx_gintmsk, disconnintmsk, 1);
+
+	/*
+	 * 2. Program the USBC_HCFG register to select full-speed host
+	 *    or high-speed host.
+	 */
+	usbcx_hcfg.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HCFG(usb->index));
+	usbcx_hcfg.s.fslssupp = 0;
+	usbcx_hcfg.s.fslspclksel = 0;
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_HCFG(usb->index), usbcx_hcfg.u32);
+
+	cvmx_fifo_setup(usb);
+
+	/*
+	 * If the controller is getting port events right after the reset, it
+	 * means the initialization failed. Try resetting the controller again
+	 * in such case. This is seen to happen after cold boot on DSR-1000N.
+	 */
+	usbc_gintsts.u32 = cvmx_usb_read_csr32(usb,
+					       CVMX_USBCX_GINTSTS(usb->index));
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index),
+			     usbc_gintsts.u32);
+	dev_dbg(dev, "gintsts after reset: 0x%x\n", (int)usbc_gintsts.u32);
+	if (!usbc_gintsts.s.disconnint && !usbc_gintsts.s.prtint)
+		return 0;
+	if (retries++ >= 5)
+		return -EAGAIN;
+	dev_info(dev, "controller reset failed (gintsts=0x%x) - retrying\n",
+		 (int)usbc_gintsts.u32);
+	msleep(50);
+	cvmx_usb_shutdown(usb);
+	msleep(50);
+	goto retry;
+}
+
+/**
+ * Reset a USB port. After this call succeeds, the USB port is
+ * online and servicing requests.
+ *
+ * @usb: USB device state populated by cvmx_usb_initialize().
+ */
+static void cvmx_usb_reset_port(struct octeon_hcd *usb)
+{
+	usb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,
+						  CVMX_USBCX_HPRT(usb->index));
+
+	/* Program the port reset bit to start the reset process */
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,
+			prtrst, 1);
+
+	/*
+	 * Wait at least 50ms (high speed), or 10ms (full speed) for the reset
+	 * process to complete.
+	 */
+	mdelay(50);
+
+	/* Program the port reset bit to 0, USBC_HPRT[PRTRST] = 0 */
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,
+			prtrst, 0);
+
+	/*
+	 * Read the port speed field to get the enumerated speed,
+	 * USBC_HPRT[PRTSPD].
+	 */
+	usb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,
+						  CVMX_USBCX_HPRT(usb->index));
+}
+
+/**
+ * Disable a USB port. After this call the USB port will not
+ * generate data transfers and will not generate events.
+ * Transactions in process will fail and call their
+ * associated callbacks.
+ *
+ * @usb: USB device state populated by cvmx_usb_initialize().
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_disable(struct octeon_hcd *usb)
+{
+	/* Disable the port */
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,
+			prtena, 1);
+	return 0;
+}
+
+/**
+ * Get the current state of the USB port. Use this call to
+ * determine if the usb port has anything connected, is enabled,
+ * or has some sort of error condition. The return value of this
+ * call has "changed" bits to signal of the value of some fields
+ * have changed between calls.
+ *
+ * @usb: USB device state populated by cvmx_usb_initialize().
+ *
+ * Returns: Port status information
+ */
+static struct cvmx_usb_port_status cvmx_usb_get_status(struct octeon_hcd *usb)
+{
+	union cvmx_usbcx_hprt usbc_hprt;
+	struct cvmx_usb_port_status result;
+
+	memset(&result, 0, sizeof(result));
+
+	usbc_hprt.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+	result.port_enabled = usbc_hprt.s.prtena;
+	result.port_over_current = usbc_hprt.s.prtovrcurract;
+	result.port_powered = usbc_hprt.s.prtpwr;
+	result.port_speed = usbc_hprt.s.prtspd;
+	result.connected = usbc_hprt.s.prtconnsts;
+	result.connect_change =
+		result.connected != usb->port_status.connected;
+
+	return result;
+}
+
+/**
+ * Open a virtual pipe between the host and a USB device. A pipe
+ * must be opened before data can be transferred between a device
+ * and Octeon.
+ *
+ * @usb:	     USB device state populated by cvmx_usb_initialize().
+ * @device_addr:
+ *		     USB device address to open the pipe to
+ *		     (0-127).
+ * @endpoint_num:
+ *		     USB endpoint number to open the pipe to
+ *		     (0-15).
+ * @device_speed:
+ *		     The speed of the device the pipe is going
+ *		     to. This must match the device's speed,
+ *		     which may be different than the port speed.
+ * @max_packet:	     The maximum packet length the device can
+ *		     transmit/receive (low speed=0-8, full
+ *		     speed=0-1023, high speed=0-1024). This value
+ *		     comes from the standard endpoint descriptor
+ *		     field wMaxPacketSize bits <10:0>.
+ * @transfer_type:
+ *		     The type of transfer this pipe is for.
+ * @transfer_dir:
+ *		     The direction the pipe is in. This is not
+ *		     used for control pipes.
+ * @interval:	     For ISOCHRONOUS and INTERRUPT transfers,
+ *		     this is how often the transfer is scheduled
+ *		     for. All other transfers should specify
+ *		     zero. The units are in frames (8000/sec at
+ *		     high speed, 1000/sec for full speed).
+ * @multi_count:
+ *		     For high speed devices, this is the maximum
+ *		     allowed number of packet per microframe.
+ *		     Specify zero for non high speed devices. This
+ *		     value comes from the standard endpoint descriptor
+ *		     field wMaxPacketSize bits <12:11>.
+ * @hub_device_addr:
+ *		     Hub device address this device is connected
+ *		     to. Devices connected directly to Octeon
+ *		     use zero. This is only used when the device
+ *		     is full/low speed behind a high speed hub.
+ *		     The address will be of the high speed hub,
+ *		     not and full speed hubs after it.
+ * @hub_port:	     Which port on the hub the device is
+ *		     connected. Use zero for devices connected
+ *		     directly to Octeon. Like hub_device_addr,
+ *		     this is only used for full/low speed
+ *		     devices behind a high speed hub.
+ *
+ * Returns: A non-NULL value is a pipe. NULL means an error.
+ */
+static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct octeon_hcd *usb,
+						int device_addr,
+						int endpoint_num,
+						enum cvmx_usb_speed
+							device_speed,
+						int max_packet,
+						enum cvmx_usb_transfer
+							transfer_type,
+						enum cvmx_usb_direction
+							transfer_dir,
+						int interval, int multi_count,
+						int hub_device_addr,
+						int hub_port)
+{
+	struct cvmx_usb_pipe *pipe;
+
+	pipe = kzalloc(sizeof(*pipe), GFP_ATOMIC);
+	if (!pipe)
+		return NULL;
+	if ((device_speed == CVMX_USB_SPEED_HIGH) &&
+	    (transfer_dir == CVMX_USB_DIRECTION_OUT) &&
+	    (transfer_type == CVMX_USB_TRANSFER_BULK))
+		pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
+	pipe->device_addr = device_addr;
+	pipe->endpoint_num = endpoint_num;
+	pipe->device_speed = device_speed;
+	pipe->max_packet = max_packet;
+	pipe->transfer_type = transfer_type;
+	pipe->transfer_dir = transfer_dir;
+	INIT_LIST_HEAD(&pipe->transactions);
+
+	/*
+	 * All pipes use interval to rate limit NAK processing. Force an
+	 * interval if one wasn't supplied
+	 */
+	if (!interval)
+		interval = 1;
+	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+		pipe->interval = interval * 8;
+		/* Force start splits to be schedule on uFrame 0 */
+		pipe->next_tx_frame = ((usb->frame_number + 7) & ~7) +
+					pipe->interval;
+	} else {
+		pipe->interval = interval;
+		pipe->next_tx_frame = usb->frame_number + pipe->interval;
+	}
+	pipe->multi_count = multi_count;
+	pipe->hub_device_addr = hub_device_addr;
+	pipe->hub_port = hub_port;
+	pipe->pid_toggle = 0;
+	pipe->split_sc_frame = -1;
+	list_add_tail(&pipe->node, &usb->idle_pipes);
+
+	/*
+	 * We don't need to tell the hardware about this pipe yet since
+	 * it doesn't have any submitted requests
+	 */
+
+	return pipe;
+}
+
+/**
+ * Poll the RX FIFOs and remove data as needed. This function is only used
+ * in non DMA mode. It is very important that this function be called quickly
+ * enough to prevent FIFO overflow.
+ *
+ * @usb:	USB device state populated by cvmx_usb_initialize().
+ */
+static void cvmx_usb_poll_rx_fifo(struct octeon_hcd *usb)
+{
+	union cvmx_usbcx_grxstsph rx_status;
+	int channel;
+	int bytes;
+	u64 address;
+	u32 *ptr;
+
+	rx_status.u32 = cvmx_usb_read_csr32(usb,
+					    CVMX_USBCX_GRXSTSPH(usb->index));
+	/* Only read data if IN data is there */
+	if (rx_status.s.pktsts != 2)
+		return;
+	/* Check if no data is available */
+	if (!rx_status.s.bcnt)
+		return;
+
+	channel = rx_status.s.chnum;
+	bytes = rx_status.s.bcnt;
+	if (!bytes)
+		return;
+
+	/* Get where the DMA engine would have written this data */
+	address = cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index) +
+				     channel * 8);
+
+	ptr = cvmx_phys_to_ptr(address);
+	cvmx_write64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel * 8,
+			    address + bytes);
+
+	/* Loop writing the FIFO data for this packet into memory */
+	while (bytes > 0) {
+		*ptr++ = cvmx_usb_read_csr32(usb,
+					USB_FIFO_ADDRESS(channel, usb->index));
+		bytes -= 4;
+	}
+	CVMX_SYNCW;
+}
+
+/**
+ * Fill the TX hardware fifo with data out of the software
+ * fifos
+ *
+ * @usb:	    USB device state populated by cvmx_usb_initialize().
+ * @fifo:	    Software fifo to use
+ * @available:	    Amount of space in the hardware fifo
+ *
+ * Returns: Non zero if the hardware fifo was too small and needs
+ *	    to be serviced again.
+ */
+static int cvmx_usb_fill_tx_hw(struct octeon_hcd *usb,
+			       struct cvmx_usb_tx_fifo *fifo, int available)
+{
+	/*
+	 * We're done either when there isn't anymore space or the software FIFO
+	 * is empty
+	 */
+	while (available && (fifo->head != fifo->tail)) {
+		int i = fifo->tail;
+		const u32 *ptr = cvmx_phys_to_ptr(fifo->entry[i].address);
+		u64 csr_address = USB_FIFO_ADDRESS(fifo->entry[i].channel,
+						   usb->index) ^ 4;
+		int words = available;
+
+		/* Limit the amount of data to what the SW fifo has */
+		if (fifo->entry[i].size <= available) {
+			words = fifo->entry[i].size;
+			fifo->tail++;
+			if (fifo->tail > MAX_CHANNELS)
+				fifo->tail = 0;
+		}
+
+		/* Update the next locations and counts */
+		available -= words;
+		fifo->entry[i].address += words * 4;
+		fifo->entry[i].size -= words;
+
+		/*
+		 * Write the HW fifo data. The read every three writes is due
+		 * to an errata on CN3XXX chips
+		 */
+		while (words > 3) {
+			cvmx_write64_uint32(csr_address, *ptr++);
+			cvmx_write64_uint32(csr_address, *ptr++);
+			cvmx_write64_uint32(csr_address, *ptr++);
+			cvmx_read64_uint64(
+					CVMX_USBNX_DMA0_INB_CHN0(usb->index));
+			words -= 3;
+		}
+		cvmx_write64_uint32(csr_address, *ptr++);
+		if (--words) {
+			cvmx_write64_uint32(csr_address, *ptr++);
+			if (--words)
+				cvmx_write64_uint32(csr_address, *ptr++);
+		}
+		cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
+	}
+	return fifo->head != fifo->tail;
+}
+
+/**
+ * Check the hardware FIFOs and fill them as needed
+ *
+ * @usb:	USB device state populated by cvmx_usb_initialize().
+ */
+static void cvmx_usb_poll_tx_fifo(struct octeon_hcd *usb)
+{
+	if (usb->periodic.head != usb->periodic.tail) {
+		union cvmx_usbcx_hptxsts tx_status;
+
+		tx_status.u32 = cvmx_usb_read_csr32(usb,
+					CVMX_USBCX_HPTXSTS(usb->index));
+		if (cvmx_usb_fill_tx_hw(usb, &usb->periodic,
+					tx_status.s.ptxfspcavail))
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+					cvmx_usbcx_gintmsk, ptxfempmsk, 1);
+		else
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+					cvmx_usbcx_gintmsk, ptxfempmsk, 0);
+	}
+
+	if (usb->nonperiodic.head != usb->nonperiodic.tail) {
+		union cvmx_usbcx_gnptxsts tx_status;
+
+		tx_status.u32 = cvmx_usb_read_csr32(usb,
+					CVMX_USBCX_GNPTXSTS(usb->index));
+		if (cvmx_usb_fill_tx_hw(usb, &usb->nonperiodic,
+					tx_status.s.nptxfspcavail))
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+					cvmx_usbcx_gintmsk, nptxfempmsk, 1);
+		else
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+					cvmx_usbcx_gintmsk, nptxfempmsk, 0);
+	}
+}
+
+/**
+ * Fill the TX FIFO with an outgoing packet
+ *
+ * @usb:	  USB device state populated by cvmx_usb_initialize().
+ * @channel:	  Channel number to get packet from
+ */
+static void cvmx_usb_fill_tx_fifo(struct octeon_hcd *usb, int channel)
+{
+	union cvmx_usbcx_hccharx hcchar;
+	union cvmx_usbcx_hcspltx usbc_hcsplt;
+	union cvmx_usbcx_hctsizx usbc_hctsiz;
+	struct cvmx_usb_tx_fifo *fifo;
+
+	/* We only need to fill data on outbound channels */
+	hcchar.u32 = cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HCCHARX(channel, usb->index));
+	if (hcchar.s.epdir != CVMX_USB_DIRECTION_OUT)
+		return;
+
+	/* OUT Splits only have data on the start and not the complete */
+	usbc_hcsplt.u32 = cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCSPLTX(channel, usb->index));
+	if (usbc_hcsplt.s.spltena && usbc_hcsplt.s.compsplt)
+		return;
+
+	/*
+	 * Find out how many bytes we need to fill and convert it into 32bit
+	 * words.
+	 */
+	usbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCTSIZX(channel, usb->index));
+	if (!usbc_hctsiz.s.xfersize)
+		return;
+
+	if ((hcchar.s.eptype == CVMX_USB_TRANSFER_INTERRUPT) ||
+	    (hcchar.s.eptype == CVMX_USB_TRANSFER_ISOCHRONOUS))
+		fifo = &usb->periodic;
+	else
+		fifo = &usb->nonperiodic;
+
+	fifo->entry[fifo->head].channel = channel;
+	fifo->entry[fifo->head].address =
+		cvmx_read64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +
+				   channel * 8);
+	fifo->entry[fifo->head].size = (usbc_hctsiz.s.xfersize + 3) >> 2;
+	fifo->head++;
+	if (fifo->head > MAX_CHANNELS)
+		fifo->head = 0;
+
+	cvmx_usb_poll_tx_fifo(usb);
+}
+
+/**
+ * Perform channel specific setup for Control transactions. All
+ * the generic stuff will already have been done in cvmx_usb_start_channel().
+ *
+ * @usb:	  USB device state populated by cvmx_usb_initialize().
+ * @channel:	  Channel to setup
+ * @pipe:	  Pipe for control transaction
+ */
+static void cvmx_usb_start_channel_control(struct octeon_hcd *usb,
+					   int channel,
+					   struct cvmx_usb_pipe *pipe)
+{
+	struct usb_hcd *hcd = octeon_to_hcd(usb);
+	struct device *dev = hcd->self.controller;
+	struct cvmx_usb_transaction *transaction =
+		list_first_entry(&pipe->transactions, typeof(*transaction),
+				 node);
+	struct usb_ctrlrequest *header =
+		cvmx_phys_to_ptr(transaction->control_header);
+	int bytes_to_transfer = transaction->buffer_length -
+		transaction->actual_bytes;
+	int packets_to_transfer;
+	union cvmx_usbcx_hctsizx usbc_hctsiz;
+
+	usbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCTSIZX(channel, usb->index));
+
+	switch (transaction->stage) {
+	case CVMX_USB_STAGE_NON_CONTROL:
+	case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
+		dev_err(dev, "%s: ERROR - Non control stage\n", __func__);
+		break;
+	case CVMX_USB_STAGE_SETUP:
+		usbc_hctsiz.s.pid = 3; /* Setup */
+		bytes_to_transfer = sizeof(*header);
+		/* All Control operations start with a setup going OUT */
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				cvmx_usbcx_hccharx, epdir,
+				CVMX_USB_DIRECTION_OUT);
+		/*
+		 * Setup send the control header instead of the buffer data. The
+		 * buffer data will be used in the next stage
+		 */
+		cvmx_write64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +
+					channel * 8,
+				    transaction->control_header);
+		break;
+	case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
+		usbc_hctsiz.s.pid = 3; /* Setup */
+		bytes_to_transfer = 0;
+		/* All Control operations start with a setup going OUT */
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				cvmx_usbcx_hccharx, epdir,
+				CVMX_USB_DIRECTION_OUT);
+
+		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
+				cvmx_usbcx_hcspltx, compsplt, 1);
+		break;
+	case CVMX_USB_STAGE_DATA:
+		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
+		if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+			if (header->bRequestType & USB_DIR_IN)
+				bytes_to_transfer = 0;
+			else if (bytes_to_transfer > pipe->max_packet)
+				bytes_to_transfer = pipe->max_packet;
+		}
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				cvmx_usbcx_hccharx, epdir,
+				((header->bRequestType & USB_DIR_IN) ?
+					CVMX_USB_DIRECTION_IN :
+					CVMX_USB_DIRECTION_OUT));
+		break;
+	case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
+		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
+		if (!(header->bRequestType & USB_DIR_IN))
+			bytes_to_transfer = 0;
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				cvmx_usbcx_hccharx, epdir,
+				((header->bRequestType & USB_DIR_IN) ?
+					CVMX_USB_DIRECTION_IN :
+					CVMX_USB_DIRECTION_OUT));
+		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
+				cvmx_usbcx_hcspltx, compsplt, 1);
+		break;
+	case CVMX_USB_STAGE_STATUS:
+		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
+		bytes_to_transfer = 0;
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				cvmx_usbcx_hccharx, epdir,
+				((header->bRequestType & USB_DIR_IN) ?
+					CVMX_USB_DIRECTION_OUT :
+					CVMX_USB_DIRECTION_IN));
+		break;
+	case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
+		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
+		bytes_to_transfer = 0;
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				cvmx_usbcx_hccharx, epdir,
+				((header->bRequestType & USB_DIR_IN) ?
+					CVMX_USB_DIRECTION_OUT :
+					CVMX_USB_DIRECTION_IN));
+		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
+				cvmx_usbcx_hcspltx, compsplt, 1);
+		break;
+	}
+
+	/*
+	 * Make sure the transfer never exceeds the byte limit of the hardware.
+	 * Further bytes will be sent as continued transactions
+	 */
+	if (bytes_to_transfer > MAX_TRANSFER_BYTES) {
+		/* Round MAX_TRANSFER_BYTES to a multiple of out packet size */
+		bytes_to_transfer = MAX_TRANSFER_BYTES / pipe->max_packet;
+		bytes_to_transfer *= pipe->max_packet;
+	}
+
+	/*
+	 * Calculate the number of packets to transfer. If the length is zero
+	 * we still need to transfer one packet
+	 */
+	packets_to_transfer = DIV_ROUND_UP(bytes_to_transfer,
+					   pipe->max_packet);
+	if (packets_to_transfer == 0) {
+		packets_to_transfer = 1;
+	} else if ((packets_to_transfer > 1) &&
+			(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
+		/*
+		 * Limit to one packet when not using DMA. Channels must be
+		 * restarted between every packet for IN transactions, so there
+		 * is no reason to do multiple packets in a row
+		 */
+		packets_to_transfer = 1;
+		bytes_to_transfer = packets_to_transfer * pipe->max_packet;
+	} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {
+		/*
+		 * Limit the number of packet and data transferred to what the
+		 * hardware can handle
+		 */
+		packets_to_transfer = MAX_TRANSFER_PACKETS;
+		bytes_to_transfer = packets_to_transfer * pipe->max_packet;
+	}
+
+	usbc_hctsiz.s.xfersize = bytes_to_transfer;
+	usbc_hctsiz.s.pktcnt = packets_to_transfer;
+
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index),
+			     usbc_hctsiz.u32);
+}
+
+/**
+ * Start a channel to perform the pipe's head transaction
+ *
+ * @usb:	  USB device state populated by cvmx_usb_initialize().
+ * @channel:	  Channel to setup
+ * @pipe:	  Pipe to start
+ */
+static void cvmx_usb_start_channel(struct octeon_hcd *usb, int channel,
+				   struct cvmx_usb_pipe *pipe)
+{
+	struct cvmx_usb_transaction *transaction =
+		list_first_entry(&pipe->transactions, typeof(*transaction),
+				 node);
+
+	/* Make sure all writes to the DMA region get flushed */
+	CVMX_SYNCW;
+
+	/* Attach the channel to the pipe */
+	usb->pipe_for_channel[channel] = pipe;
+	pipe->channel = channel;
+	pipe->flags |= CVMX_USB_PIPE_FLAGS_SCHEDULED;
+
+	/* Mark this channel as in use */
+	usb->idle_hardware_channels &= ~(1 << channel);
+
+	/* Enable the channel interrupt bits */
+	{
+		union cvmx_usbcx_hcintx usbc_hcint;
+		union cvmx_usbcx_hcintmskx usbc_hcintmsk;
+		union cvmx_usbcx_haintmsk usbc_haintmsk;
+
+		/* Clear all channel status bits */
+		usbc_hcint.u32 = cvmx_usb_read_csr32(usb,
+					CVMX_USBCX_HCINTX(channel, usb->index));
+
+		cvmx_usb_write_csr32(usb,
+				     CVMX_USBCX_HCINTX(channel, usb->index),
+				     usbc_hcint.u32);
+
+		usbc_hcintmsk.u32 = 0;
+		usbc_hcintmsk.s.chhltdmsk = 1;
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
+			/*
+			 * Channels need these extra interrupts when we aren't
+			 * in DMA mode.
+			 */
+			usbc_hcintmsk.s.datatglerrmsk = 1;
+			usbc_hcintmsk.s.frmovrunmsk = 1;
+			usbc_hcintmsk.s.bblerrmsk = 1;
+			usbc_hcintmsk.s.xacterrmsk = 1;
+			if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+				/*
+				 * Splits don't generate xfercompl, so we need
+				 * ACK and NYET.
+				 */
+				usbc_hcintmsk.s.nyetmsk = 1;
+				usbc_hcintmsk.s.ackmsk = 1;
+			}
+			usbc_hcintmsk.s.nakmsk = 1;
+			usbc_hcintmsk.s.stallmsk = 1;
+			usbc_hcintmsk.s.xfercomplmsk = 1;
+		}
+		cvmx_usb_write_csr32(usb,
+				     CVMX_USBCX_HCINTMSKX(channel, usb->index),
+				     usbc_hcintmsk.u32);
+
+		/* Enable the channel interrupt to propagate */
+		usbc_haintmsk.u32 = cvmx_usb_read_csr32(usb,
+					CVMX_USBCX_HAINTMSK(usb->index));
+		usbc_haintmsk.s.haintmsk |= 1 << channel;
+		cvmx_usb_write_csr32(usb, CVMX_USBCX_HAINTMSK(usb->index),
+				     usbc_haintmsk.u32);
+	}
+
+	/* Setup the location the DMA engine uses. */
+	{
+		u64 reg;
+		u64 dma_address = transaction->buffer +
+				  transaction->actual_bytes;
+
+		if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
+			dma_address = transaction->buffer +
+					transaction->iso_packets[0].offset +
+					transaction->actual_bytes;
+
+		if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT)
+			reg = CVMX_USBNX_DMA0_OUTB_CHN0(usb->index);
+		else
+			reg = CVMX_USBNX_DMA0_INB_CHN0(usb->index);
+		cvmx_write64_uint64(reg + channel * 8, dma_address);
+	}
+
+	/* Setup both the size of the transfer and the SPLIT characteristics */
+	{
+		union cvmx_usbcx_hcspltx usbc_hcsplt = {.u32 = 0};
+		union cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 = 0};
+		int packets_to_transfer;
+		int bytes_to_transfer = transaction->buffer_length -
+			transaction->actual_bytes;
+
+		/*
+		 * ISOCHRONOUS transactions store each individual transfer size
+		 * in the packet structure, not the global buffer_length
+		 */
+		if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
+			bytes_to_transfer =
+				transaction->iso_packets[0].length -
+				transaction->actual_bytes;
+
+		/*
+		 * We need to do split transactions when we are talking to non
+		 * high speed devices that are behind a high speed hub
+		 */
+		if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+			/*
+			 * On the start split phase (stage is even) record the
+			 * frame number we will need to send the split complete.
+			 * We only store the lower two bits since the time ahead
+			 * can only be two frames
+			 */
+			if ((transaction->stage & 1) == 0) {
+				if (transaction->type == CVMX_USB_TRANSFER_BULK)
+					pipe->split_sc_frame =
+						(usb->frame_number + 1) & 0x7f;
+				else
+					pipe->split_sc_frame =
+						(usb->frame_number + 2) & 0x7f;
+			} else {
+				pipe->split_sc_frame = -1;
+			}
+
+			usbc_hcsplt.s.spltena = 1;
+			usbc_hcsplt.s.hubaddr = pipe->hub_device_addr;
+			usbc_hcsplt.s.prtaddr = pipe->hub_port;
+			usbc_hcsplt.s.compsplt = (transaction->stage ==
+				CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE);
+
+			/*
+			 * SPLIT transactions can only ever transmit one data
+			 * packet so limit the transfer size to the max packet
+			 * size
+			 */
+			if (bytes_to_transfer > pipe->max_packet)
+				bytes_to_transfer = pipe->max_packet;
+
+			/*
+			 * ISOCHRONOUS OUT splits are unique in that they limit
+			 * data transfers to 188 byte chunks representing the
+			 * begin/middle/end of the data or all
+			 */
+			if (!usbc_hcsplt.s.compsplt &&
+			    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) &&
+			    (pipe->transfer_type ==
+			     CVMX_USB_TRANSFER_ISOCHRONOUS)) {
+				/*
+				 * Clear the split complete frame number as
+				 * there isn't going to be a split complete
+				 */
+				pipe->split_sc_frame = -1;
+				/*
+				 * See if we've started this transfer and sent
+				 * data
+				 */
+				if (transaction->actual_bytes == 0) {
+					/*
+					 * Nothing sent yet, this is either a
+					 * begin or the entire payload
+					 */
+					if (bytes_to_transfer <= 188)
+						/* Entire payload in one go */
+						usbc_hcsplt.s.xactpos = 3;
+					else
+						/* First part of payload */
+						usbc_hcsplt.s.xactpos = 2;
+				} else {
+					/*
+					 * Continuing the previous data, we must
+					 * either be in the middle or at the end
+					 */
+					if (bytes_to_transfer <= 188)
+						/* End of payload */
+						usbc_hcsplt.s.xactpos = 1;
+					else
+						/* Middle of payload */
+						usbc_hcsplt.s.xactpos = 0;
+				}
+				/*
+				 * Again, the transfer size is limited to 188
+				 * bytes
+				 */
+				if (bytes_to_transfer > 188)
+					bytes_to_transfer = 188;
+			}
+		}
+
+		/*
+		 * Make sure the transfer never exceeds the byte limit of the
+		 * hardware. Further bytes will be sent as continued
+		 * transactions
+		 */
+		if (bytes_to_transfer > MAX_TRANSFER_BYTES) {
+			/*
+			 * Round MAX_TRANSFER_BYTES to a multiple of out packet
+			 * size
+			 */
+			bytes_to_transfer = MAX_TRANSFER_BYTES /
+				pipe->max_packet;
+			bytes_to_transfer *= pipe->max_packet;
+		}
+
+		/*
+		 * Calculate the number of packets to transfer. If the length is
+		 * zero we still need to transfer one packet
+		 */
+		packets_to_transfer =
+			DIV_ROUND_UP(bytes_to_transfer, pipe->max_packet);
+		if (packets_to_transfer == 0) {
+			packets_to_transfer = 1;
+		} else if ((packets_to_transfer > 1) &&
+			   (usb->init_flags &
+			    CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
+			/*
+			 * Limit to one packet when not using DMA. Channels must
+			 * be restarted between every packet for IN
+			 * transactions, so there is no reason to do multiple
+			 * packets in a row
+			 */
+			packets_to_transfer = 1;
+			bytes_to_transfer = packets_to_transfer *
+				pipe->max_packet;
+		} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {
+			/*
+			 * Limit the number of packet and data transferred to
+			 * what the hardware can handle
+			 */
+			packets_to_transfer = MAX_TRANSFER_PACKETS;
+			bytes_to_transfer = packets_to_transfer *
+				pipe->max_packet;
+		}
+
+		usbc_hctsiz.s.xfersize = bytes_to_transfer;
+		usbc_hctsiz.s.pktcnt = packets_to_transfer;
+
+		/* Update the DATA0/DATA1 toggle */
+		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
+		/*
+		 * High speed pipes may need a hardware ping before they start
+		 */
+		if (pipe->flags & CVMX_USB_PIPE_FLAGS_NEED_PING)
+			usbc_hctsiz.s.dopng = 1;
+
+		cvmx_usb_write_csr32(usb,
+				     CVMX_USBCX_HCSPLTX(channel, usb->index),
+				     usbc_hcsplt.u32);
+		cvmx_usb_write_csr32(usb,
+				     CVMX_USBCX_HCTSIZX(channel, usb->index),
+				     usbc_hctsiz.u32);
+	}
+
+	/* Setup the Host Channel Characteristics Register */
+	{
+		union cvmx_usbcx_hccharx usbc_hcchar = {.u32 = 0};
+
+		/*
+		 * Set the startframe odd/even properly. This is only used for
+		 * periodic
+		 */
+		usbc_hcchar.s.oddfrm = usb->frame_number & 1;
+
+		/*
+		 * Set the number of back to back packets allowed by this
+		 * endpoint. Split transactions interpret "ec" as the number of
+		 * immediate retries of failure. These retries happen too
+		 * quickly, so we disable these entirely for splits
+		 */
+		if (cvmx_usb_pipe_needs_split(usb, pipe))
+			usbc_hcchar.s.ec = 1;
+		else if (pipe->multi_count < 1)
+			usbc_hcchar.s.ec = 1;
+		else if (pipe->multi_count > 3)
+			usbc_hcchar.s.ec = 3;
+		else
+			usbc_hcchar.s.ec = pipe->multi_count;
+
+		/* Set the rest of the endpoint specific settings */
+		usbc_hcchar.s.devaddr = pipe->device_addr;
+		usbc_hcchar.s.eptype = transaction->type;
+		usbc_hcchar.s.lspddev =
+			(pipe->device_speed == CVMX_USB_SPEED_LOW);
+		usbc_hcchar.s.epdir = pipe->transfer_dir;
+		usbc_hcchar.s.epnum = pipe->endpoint_num;
+		usbc_hcchar.s.mps = pipe->max_packet;
+		cvmx_usb_write_csr32(usb,
+				     CVMX_USBCX_HCCHARX(channel, usb->index),
+				     usbc_hcchar.u32);
+	}
+
+	/* Do transaction type specific fixups as needed */
+	switch (transaction->type) {
+	case CVMX_USB_TRANSFER_CONTROL:
+		cvmx_usb_start_channel_control(usb, channel, pipe);
+		break;
+	case CVMX_USB_TRANSFER_BULK:
+	case CVMX_USB_TRANSFER_INTERRUPT:
+		break;
+	case CVMX_USB_TRANSFER_ISOCHRONOUS:
+		if (!cvmx_usb_pipe_needs_split(usb, pipe)) {
+			/*
+			 * ISO transactions require different PIDs depending on
+			 * direction and how many packets are needed
+			 */
+			if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {
+				if (pipe->multi_count < 2) /* Need DATA0 */
+					USB_SET_FIELD32(
+						CVMX_USBCX_HCTSIZX(channel,
+								   usb->index),
+						cvmx_usbcx_hctsizx, pid, 0);
+				else /* Need MDATA */
+					USB_SET_FIELD32(
+						CVMX_USBCX_HCTSIZX(channel,
+								   usb->index),
+						cvmx_usbcx_hctsizx, pid, 3);
+			}
+		}
+		break;
+	}
+	{
+		union cvmx_usbcx_hctsizx usbc_hctsiz = { .u32 =
+			cvmx_usb_read_csr32(usb,
+					    CVMX_USBCX_HCTSIZX(channel,
+							       usb->index))
+		};
+		transaction->xfersize = usbc_hctsiz.s.xfersize;
+		transaction->pktcnt = usbc_hctsiz.s.pktcnt;
+	}
+	/* Remember when we start a split transaction */
+	if (cvmx_usb_pipe_needs_split(usb, pipe))
+		usb->active_split = transaction;
+	USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+			cvmx_usbcx_hccharx, chena, 1);
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+		cvmx_usb_fill_tx_fifo(usb, channel);
+}
+
+/**
+ * Find a pipe that is ready to be scheduled to hardware.
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
+ * @xfer_type:	 Transfer type
+ *
+ * Returns: Pipe or NULL if none are ready
+ */
+static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(struct octeon_hcd *usb,
+		enum cvmx_usb_transfer xfer_type)
+{
+	struct list_head *list = usb->active_pipes + xfer_type;
+	u64 current_frame = usb->frame_number;
+	struct cvmx_usb_pipe *pipe;
+
+	list_for_each_entry(pipe, list, node) {
+		struct cvmx_usb_transaction *t =
+			list_first_entry(&pipe->transactions, typeof(*t),
+					 node);
+		if (!(pipe->flags & CVMX_USB_PIPE_FLAGS_SCHEDULED) && t &&
+		    (pipe->next_tx_frame <= current_frame) &&
+		    ((pipe->split_sc_frame == -1) ||
+		     ((((int)current_frame - pipe->split_sc_frame) & 0x7f) <
+		      0x40)) &&
+		    (!usb->active_split || (usb->active_split == t))) {
+			prefetch(t);
+			return pipe;
+		}
+	}
+	return NULL;
+}
+
+static struct cvmx_usb_pipe *cvmx_usb_next_pipe(struct octeon_hcd *usb,
+						int is_sof)
+{
+	struct cvmx_usb_pipe *pipe;
+
+	/* Find a pipe needing service. */
+	if (is_sof) {
+		/*
+		 * Only process periodic pipes on SOF interrupts. This way we
+		 * are sure that the periodic data is sent in the beginning of
+		 * the frame.
+		 */
+		pipe = cvmx_usb_find_ready_pipe(usb,
+						CVMX_USB_TRANSFER_ISOCHRONOUS);
+		if (pipe)
+			return pipe;
+		pipe = cvmx_usb_find_ready_pipe(usb,
+						CVMX_USB_TRANSFER_INTERRUPT);
+		if (pipe)
+			return pipe;
+	}
+	pipe = cvmx_usb_find_ready_pipe(usb, CVMX_USB_TRANSFER_CONTROL);
+	if (pipe)
+		return pipe;
+	return cvmx_usb_find_ready_pipe(usb, CVMX_USB_TRANSFER_BULK);
+}
+
+/**
+ * Called whenever a pipe might need to be scheduled to the
+ * hardware.
+ *
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
+ * @is_sof:	 True if this schedule was called on a SOF interrupt.
+ */
+static void cvmx_usb_schedule(struct octeon_hcd *usb, int is_sof)
+{
+	int channel;
+	struct cvmx_usb_pipe *pipe;
+	int need_sof;
+	enum cvmx_usb_transfer ttype;
+
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
+		/*
+		 * Without DMA we need to be careful to not schedule something
+		 * at the end of a frame and cause an overrun.
+		 */
+		union cvmx_usbcx_hfnum hfnum = {
+			.u32 = cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_HFNUM(usb->index))
+		};
+
+		union cvmx_usbcx_hfir hfir = {
+			.u32 = cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_HFIR(usb->index))
+		};
+
+		if (hfnum.s.frrem < hfir.s.frint / 4)
+			goto done;
+	}
+
+	while (usb->idle_hardware_channels) {
+		/* Find an idle channel */
+		channel = __fls(usb->idle_hardware_channels);
+		if (unlikely(channel > 7))
+			break;
+
+		pipe = cvmx_usb_next_pipe(usb, is_sof);
+		if (!pipe)
+			break;
+
+		cvmx_usb_start_channel(usb, channel, pipe);
+	}
+
+done:
+	/*
+	 * Only enable SOF interrupts when we have transactions pending in the
+	 * future that might need to be scheduled
+	 */
+	need_sof = 0;
+	for (ttype = CVMX_USB_TRANSFER_CONTROL;
+	     ttype <= CVMX_USB_TRANSFER_INTERRUPT; ttype++) {
+		list_for_each_entry(pipe, &usb->active_pipes[ttype], node) {
+			if (pipe->next_tx_frame > usb->frame_number) {
+				need_sof = 1;
+				break;
+			}
+		}
+	}
+	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+			cvmx_usbcx_gintmsk, sofmsk, need_sof);
+}
+
+static void octeon_usb_urb_complete_callback(struct octeon_hcd *usb,
+					     enum cvmx_usb_status status,
+					     struct cvmx_usb_pipe *pipe,
+					     struct cvmx_usb_transaction
+						*transaction,
+					     int bytes_transferred,
+					     struct urb *urb)
+{
+	struct usb_hcd *hcd = octeon_to_hcd(usb);
+	struct device *dev = hcd->self.controller;
+
+	if (likely(status == CVMX_USB_STATUS_OK))
+		urb->actual_length = bytes_transferred;
+	else
+		urb->actual_length = 0;
+
+	urb->hcpriv = NULL;
+
+	/* For Isochronous transactions we need to update the URB packet status
+	 * list from data in our private copy
+	 */
+	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
+		int i;
+		/*
+		 * The pointer to the private list is stored in the setup_packet
+		 * field.
+		 */
+		struct cvmx_usb_iso_packet *iso_packet =
+			(struct cvmx_usb_iso_packet *)urb->setup_packet;
+		/* Recalculate the transfer size by adding up each packet */
+		urb->actual_length = 0;
+		for (i = 0; i < urb->number_of_packets; i++) {
+			if (iso_packet[i].status == CVMX_USB_STATUS_OK) {
+				urb->iso_frame_desc[i].status = 0;
+				urb->iso_frame_desc[i].actual_length =
+					iso_packet[i].length;
+				urb->actual_length +=
+					urb->iso_frame_desc[i].actual_length;
+			} else {
+				dev_dbg(dev, "ISOCHRONOUS packet=%d of %d status=%d pipe=%p transaction=%p size=%d\n",
+					i, urb->number_of_packets,
+					iso_packet[i].status, pipe,
+					transaction, iso_packet[i].length);
+				urb->iso_frame_desc[i].status = -EREMOTEIO;
+			}
+		}
+		/* Free the private list now that we don't need it anymore */
+		kfree(iso_packet);
+		urb->setup_packet = NULL;
+	}
+
+	switch (status) {
+	case CVMX_USB_STATUS_OK:
+		urb->status = 0;
+		break;
+	case CVMX_USB_STATUS_CANCEL:
+		if (urb->status == 0)
+			urb->status = -ENOENT;
+		break;
+	case CVMX_USB_STATUS_STALL:
+		dev_dbg(dev, "status=stall pipe=%p transaction=%p size=%d\n",
+			pipe, transaction, bytes_transferred);
+		urb->status = -EPIPE;
+		break;
+	case CVMX_USB_STATUS_BABBLEERR:
+		dev_dbg(dev, "status=babble pipe=%p transaction=%p size=%d\n",
+			pipe, transaction, bytes_transferred);
+		urb->status = -EPIPE;
+		break;
+	case CVMX_USB_STATUS_SHORT:
+		dev_dbg(dev, "status=short pipe=%p transaction=%p size=%d\n",
+			pipe, transaction, bytes_transferred);
+		urb->status = -EREMOTEIO;
+		break;
+	case CVMX_USB_STATUS_ERROR:
+	case CVMX_USB_STATUS_XACTERR:
+	case CVMX_USB_STATUS_DATATGLERR:
+	case CVMX_USB_STATUS_FRAMEERR:
+		dev_dbg(dev, "status=%d pipe=%p transaction=%p size=%d\n",
+			status, pipe, transaction, bytes_transferred);
+		urb->status = -EPROTO;
+		break;
+	}
+	usb_hcd_unlink_urb_from_ep(octeon_to_hcd(usb), urb);
+	spin_unlock(&usb->lock);
+	usb_hcd_giveback_urb(octeon_to_hcd(usb), urb, urb->status);
+	spin_lock(&usb->lock);
+}
+
+/**
+ * Signal the completion of a transaction and free it. The
+ * transaction will be removed from the pipe transaction list.
+ *
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
+ * @pipe:	 Pipe the transaction is on
+ * @transaction:
+ *		 Transaction that completed
+ * @complete_code:
+ *		 Completion code
+ */
+static void cvmx_usb_complete(struct octeon_hcd *usb,
+			      struct cvmx_usb_pipe *pipe,
+			      struct cvmx_usb_transaction *transaction,
+			      enum cvmx_usb_status complete_code)
+{
+	/* If this was a split then clear our split in progress marker */
+	if (usb->active_split == transaction)
+		usb->active_split = NULL;
+
+	/*
+	 * Isochronous transactions need extra processing as they might not be
+	 * done after a single data transfer
+	 */
+	if (unlikely(transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)) {
+		/* Update the number of bytes transferred in this ISO packet */
+		transaction->iso_packets[0].length = transaction->actual_bytes;
+		transaction->iso_packets[0].status = complete_code;
+
+		/*
+		 * If there are more ISOs pending and we succeeded, schedule the
+		 * next one
+		 */
+		if ((transaction->iso_number_packets > 1) &&
+		    (complete_code == CVMX_USB_STATUS_OK)) {
+			/* No bytes transferred for this packet as of yet */
+			transaction->actual_bytes = 0;
+			/* One less ISO waiting to transfer */
+			transaction->iso_number_packets--;
+			/* Increment to the next location in our packet array */
+			transaction->iso_packets++;
+			transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+			return;
+		}
+	}
+
+	/* Remove the transaction from the pipe list */
+	list_del(&transaction->node);
+	if (list_empty(&pipe->transactions))
+		list_move_tail(&pipe->node, &usb->idle_pipes);
+	octeon_usb_urb_complete_callback(usb, complete_code, pipe,
+					 transaction,
+					 transaction->actual_bytes,
+					 transaction->urb);
+	kfree(transaction);
+}
+
+/**
+ * Submit a usb transaction to a pipe. Called for all types
+ * of transactions.
+ *
+ * @usb:
+ * @pipe:	    Which pipe to submit to.
+ * @type:	    Transaction type
+ * @buffer:	    User buffer for the transaction
+ * @buffer_length:
+ *		    User buffer's length in bytes
+ * @control_header:
+ *		    For control transactions, the 8 byte standard header
+ * @iso_start_frame:
+ *		    For ISO transactions, the start frame
+ * @iso_number_packets:
+ *		    For ISO, the number of packet in the transaction.
+ * @iso_packets:
+ *		    A description of each ISO packet
+ * @urb:	    URB for the callback
+ *
+ * Returns: Transaction or NULL on failure.
+ */
+static struct cvmx_usb_transaction *cvmx_usb_submit_transaction(
+				struct octeon_hcd *usb,
+				struct cvmx_usb_pipe *pipe,
+				enum cvmx_usb_transfer type,
+				u64 buffer,
+				int buffer_length,
+				u64 control_header,
+				int iso_start_frame,
+				int iso_number_packets,
+				struct cvmx_usb_iso_packet *iso_packets,
+				struct urb *urb)
+{
+	struct cvmx_usb_transaction *transaction;
+
+	if (unlikely(pipe->transfer_type != type))
+		return NULL;
+
+	transaction = kzalloc(sizeof(*transaction), GFP_ATOMIC);
+	if (unlikely(!transaction))
+		return NULL;
+
+	transaction->type = type;
+	transaction->buffer = buffer;
+	transaction->buffer_length = buffer_length;
+	transaction->control_header = control_header;
+	/* FIXME: This is not used, implement it. */
+	transaction->iso_start_frame = iso_start_frame;
+	transaction->iso_number_packets = iso_number_packets;
+	transaction->iso_packets = iso_packets;
+	transaction->urb = urb;
+	if (transaction->type == CVMX_USB_TRANSFER_CONTROL)
+		transaction->stage = CVMX_USB_STAGE_SETUP;
+	else
+		transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+
+	if (!list_empty(&pipe->transactions)) {
+		list_add_tail(&transaction->node, &pipe->transactions);
+	} else {
+		list_add_tail(&transaction->node, &pipe->transactions);
+		list_move_tail(&pipe->node,
+			       &usb->active_pipes[pipe->transfer_type]);
+
+		/*
+		 * We may need to schedule the pipe if this was the head of the
+		 * pipe.
+		 */
+		cvmx_usb_schedule(usb, 0);
+	}
+
+	return transaction;
+}
+
+/**
+ * Call to submit a USB Bulk transfer to a pipe.
+ *
+ * @usb:	    USB device state populated by cvmx_usb_initialize().
+ * @pipe:	    Handle to the pipe for the transfer.
+ * @urb:	    URB.
+ *
+ * Returns: A submitted transaction or NULL on failure.
+ */
+static struct cvmx_usb_transaction *cvmx_usb_submit_bulk(
+						struct octeon_hcd *usb,
+						struct cvmx_usb_pipe *pipe,
+						struct urb *urb)
+{
+	return cvmx_usb_submit_transaction(usb, pipe, CVMX_USB_TRANSFER_BULK,
+					   urb->transfer_dma,
+					   urb->transfer_buffer_length,
+					   0, /* control_header */
+					   0, /* iso_start_frame */
+					   0, /* iso_number_packets */
+					   NULL, /* iso_packets */
+					   urb);
+}
+
+/**
+ * Call to submit a USB Interrupt transfer to a pipe.
+ *
+ * @usb:	    USB device state populated by cvmx_usb_initialize().
+ * @pipe:	    Handle to the pipe for the transfer.
+ * @urb:	    URB returned when the callback is called.
+ *
+ * Returns: A submitted transaction or NULL on failure.
+ */
+static struct cvmx_usb_transaction *cvmx_usb_submit_interrupt(
+						struct octeon_hcd *usb,
+						struct cvmx_usb_pipe *pipe,
+						struct urb *urb)
+{
+	return cvmx_usb_submit_transaction(usb, pipe,
+					   CVMX_USB_TRANSFER_INTERRUPT,
+					   urb->transfer_dma,
+					   urb->transfer_buffer_length,
+					   0, /* control_header */
+					   0, /* iso_start_frame */
+					   0, /* iso_number_packets */
+					   NULL, /* iso_packets */
+					   urb);
+}
+
+/**
+ * Call to submit a USB Control transfer to a pipe.
+ *
+ * @usb:	    USB device state populated by cvmx_usb_initialize().
+ * @pipe:	    Handle to the pipe for the transfer.
+ * @urb:	    URB.
+ *
+ * Returns: A submitted transaction or NULL on failure.
+ */
+static struct cvmx_usb_transaction *cvmx_usb_submit_control(
+						struct octeon_hcd *usb,
+						struct cvmx_usb_pipe *pipe,
+						struct urb *urb)
+{
+	int buffer_length = urb->transfer_buffer_length;
+	u64 control_header = urb->setup_dma;
+	struct usb_ctrlrequest *header = cvmx_phys_to_ptr(control_header);
+
+	if ((header->bRequestType & USB_DIR_IN) == 0)
+		buffer_length = le16_to_cpu(header->wLength);
+
+	return cvmx_usb_submit_transaction(usb, pipe,
+					   CVMX_USB_TRANSFER_CONTROL,
+					   urb->transfer_dma, buffer_length,
+					   control_header,
+					   0, /* iso_start_frame */
+					   0, /* iso_number_packets */
+					   NULL, /* iso_packets */
+					   urb);
+}
+
+/**
+ * Call to submit a USB Isochronous transfer to a pipe.
+ *
+ * @usb:	    USB device state populated by cvmx_usb_initialize().
+ * @pipe:	    Handle to the pipe for the transfer.
+ * @urb:	    URB returned when the callback is called.
+ *
+ * Returns: A submitted transaction or NULL on failure.
+ */
+static struct cvmx_usb_transaction *cvmx_usb_submit_isochronous(
+						struct octeon_hcd *usb,
+						struct cvmx_usb_pipe *pipe,
+						struct urb *urb)
+{
+	struct cvmx_usb_iso_packet *packets;
+
+	packets = (struct cvmx_usb_iso_packet *)urb->setup_packet;
+	return cvmx_usb_submit_transaction(usb, pipe,
+					   CVMX_USB_TRANSFER_ISOCHRONOUS,
+					   urb->transfer_dma,
+					   urb->transfer_buffer_length,
+					   0, /* control_header */
+					   urb->start_frame,
+					   urb->number_of_packets,
+					   packets, urb);
+}
+
+/**
+ * Cancel one outstanding request in a pipe. Canceling a request
+ * can fail if the transaction has already completed before cancel
+ * is called. Even after a successful cancel call, it may take
+ * a frame or two for the cvmx_usb_poll() function to call the
+ * associated callback.
+ *
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
+ * @pipe:	 Pipe to cancel requests in.
+ * @transaction: Transaction to cancel, returned by the submit function.
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_cancel(struct octeon_hcd *usb,
+			   struct cvmx_usb_pipe *pipe,
+			   struct cvmx_usb_transaction *transaction)
+{
+	/*
+	 * If the transaction is the HEAD of the queue and scheduled. We need to
+	 * treat it special
+	 */
+	if (list_first_entry(&pipe->transactions, typeof(*transaction), node) ==
+	    transaction && (pipe->flags & CVMX_USB_PIPE_FLAGS_SCHEDULED)) {
+		union cvmx_usbcx_hccharx usbc_hcchar;
+
+		usb->pipe_for_channel[pipe->channel] = NULL;
+		pipe->flags &= ~CVMX_USB_PIPE_FLAGS_SCHEDULED;
+
+		CVMX_SYNCW;
+
+		usbc_hcchar.u32 = cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCCHARX(pipe->channel, usb->index));
+		/*
+		 * If the channel isn't enabled then the transaction already
+		 * completed.
+		 */
+		if (usbc_hcchar.s.chena) {
+			usbc_hcchar.s.chdis = 1;
+			cvmx_usb_write_csr32(usb,
+					     CVMX_USBCX_HCCHARX(pipe->channel,
+								usb->index),
+					     usbc_hcchar.u32);
+		}
+	}
+	cvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_CANCEL);
+	return 0;
+}
+
+/**
+ * Cancel all outstanding requests in a pipe. Logically all this
+ * does is call cvmx_usb_cancel() in a loop.
+ *
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
+ * @pipe:	 Pipe to cancel requests in.
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_cancel_all(struct octeon_hcd *usb,
+			       struct cvmx_usb_pipe *pipe)
+{
+	struct cvmx_usb_transaction *transaction, *next;
+
+	/* Simply loop through and attempt to cancel each transaction */
+	list_for_each_entry_safe(transaction, next, &pipe->transactions, node) {
+		int result = cvmx_usb_cancel(usb, pipe, transaction);
+
+		if (unlikely(result != 0))
+			return result;
+	}
+	return 0;
+}
+
+/**
+ * Close a pipe created with cvmx_usb_open_pipe().
+ *
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
+ * @pipe:	 Pipe to close.
+ *
+ * Returns: 0 or a negative error code. EBUSY is returned if the pipe has
+ *	    outstanding transfers.
+ */
+static int cvmx_usb_close_pipe(struct octeon_hcd *usb,
+			       struct cvmx_usb_pipe *pipe)
+{
+	/* Fail if the pipe has pending transactions */
+	if (!list_empty(&pipe->transactions))
+		return -EBUSY;
+
+	list_del(&pipe->node);
+	kfree(pipe);
+
+	return 0;
+}
+
+/**
+ * Get the current USB protocol level frame number. The frame
+ * number is always in the range of 0-0x7ff.
+ *
+ * @usb: USB device state populated by cvmx_usb_initialize().
+ *
+ * Returns: USB frame number
+ */
+static int cvmx_usb_get_frame_number(struct octeon_hcd *usb)
+{
+	union cvmx_usbcx_hfnum usbc_hfnum;
+
+	usbc_hfnum.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
+
+	return usbc_hfnum.s.frnum;
+}
+
+static void cvmx_usb_transfer_control(struct octeon_hcd *usb,
+				      struct cvmx_usb_pipe *pipe,
+				      struct cvmx_usb_transaction *transaction,
+				      union cvmx_usbcx_hccharx usbc_hcchar,
+				      int buffer_space_left,
+				      int bytes_in_last_packet)
+{
+	switch (transaction->stage) {
+	case CVMX_USB_STAGE_NON_CONTROL:
+	case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
+		/* This should be impossible */
+		cvmx_usb_complete(usb, pipe, transaction,
+				  CVMX_USB_STATUS_ERROR);
+		break;
+	case CVMX_USB_STAGE_SETUP:
+		pipe->pid_toggle = 1;
+		if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+			transaction->stage =
+				CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE;
+		} else {
+			struct usb_ctrlrequest *header =
+				cvmx_phys_to_ptr(transaction->control_header);
+			if (header->wLength)
+				transaction->stage = CVMX_USB_STAGE_DATA;
+			else
+				transaction->stage = CVMX_USB_STAGE_STATUS;
+		}
+		break;
+	case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
+		{
+			struct usb_ctrlrequest *header =
+				cvmx_phys_to_ptr(transaction->control_header);
+			if (header->wLength)
+				transaction->stage = CVMX_USB_STAGE_DATA;
+			else
+				transaction->stage = CVMX_USB_STAGE_STATUS;
+		}
+		break;
+	case CVMX_USB_STAGE_DATA:
+		if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+			transaction->stage = CVMX_USB_STAGE_DATA_SPLIT_COMPLETE;
+			/*
+			 * For setup OUT data that are splits,
+			 * the hardware doesn't appear to count
+			 * transferred data. Here we manually
+			 * update the data transferred
+			 */
+			if (!usbc_hcchar.s.epdir) {
+				if (buffer_space_left < pipe->max_packet)
+					transaction->actual_bytes +=
+						buffer_space_left;
+				else
+					transaction->actual_bytes +=
+						pipe->max_packet;
+			}
+		} else if ((buffer_space_left == 0) ||
+			   (bytes_in_last_packet < pipe->max_packet)) {
+			pipe->pid_toggle = 1;
+			transaction->stage = CVMX_USB_STAGE_STATUS;
+		}
+		break;
+	case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
+		if ((buffer_space_left == 0) ||
+		    (bytes_in_last_packet < pipe->max_packet)) {
+			pipe->pid_toggle = 1;
+			transaction->stage = CVMX_USB_STAGE_STATUS;
+		} else {
+			transaction->stage = CVMX_USB_STAGE_DATA;
+		}
+		break;
+	case CVMX_USB_STAGE_STATUS:
+		if (cvmx_usb_pipe_needs_split(usb, pipe))
+			transaction->stage =
+				CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;
+		else
+			cvmx_usb_complete(usb, pipe, transaction,
+					  CVMX_USB_STATUS_OK);
+		break;
+	case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
+		cvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_OK);
+		break;
+	}
+}
+
+static void cvmx_usb_transfer_bulk(struct octeon_hcd *usb,
+				   struct cvmx_usb_pipe *pipe,
+				   struct cvmx_usb_transaction *transaction,
+				   union cvmx_usbcx_hcintx usbc_hcint,
+				   int buffer_space_left,
+				   int bytes_in_last_packet)
+{
+	/*
+	 * The only time a bulk transfer isn't complete when it finishes with
+	 * an ACK is during a split transaction. For splits we need to continue
+	 * the transfer if more data is needed.
+	 */
+	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+		if (transaction->stage == CVMX_USB_STAGE_NON_CONTROL)
+			transaction->stage =
+				CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
+		else if (buffer_space_left &&
+			 (bytes_in_last_packet == pipe->max_packet))
+			transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+		else
+			cvmx_usb_complete(usb, pipe, transaction,
+					  CVMX_USB_STATUS_OK);
+	} else {
+		if ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&
+		    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) &&
+		    (usbc_hcint.s.nak))
+			pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
+		if (!buffer_space_left ||
+		    (bytes_in_last_packet < pipe->max_packet))
+			cvmx_usb_complete(usb, pipe, transaction,
+					  CVMX_USB_STATUS_OK);
+	}
+}
+
+static void cvmx_usb_transfer_intr(struct octeon_hcd *usb,
+				   struct cvmx_usb_pipe *pipe,
+				   struct cvmx_usb_transaction *transaction,
+				   int buffer_space_left,
+				   int bytes_in_last_packet)
+{
+	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+		if (transaction->stage == CVMX_USB_STAGE_NON_CONTROL) {
+			transaction->stage =
+				CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
+		} else if (buffer_space_left &&
+			   (bytes_in_last_packet == pipe->max_packet)) {
+			transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+		} else {
+			pipe->next_tx_frame += pipe->interval;
+			cvmx_usb_complete(usb, pipe, transaction,
+					  CVMX_USB_STATUS_OK);
+		}
+	} else if (!buffer_space_left ||
+		   (bytes_in_last_packet < pipe->max_packet)) {
+		pipe->next_tx_frame += pipe->interval;
+		cvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_OK);
+	}
+}
+
+static void cvmx_usb_transfer_isoc(struct octeon_hcd *usb,
+				   struct cvmx_usb_pipe *pipe,
+				   struct cvmx_usb_transaction *transaction,
+				   int buffer_space_left,
+				   int bytes_in_last_packet,
+				   int bytes_this_transfer)
+{
+	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+		/*
+		 * ISOCHRONOUS OUT splits don't require a complete split stage.
+		 * Instead they use a sequence of begin OUT splits to transfer
+		 * the data 188 bytes at a time. Once the transfer is complete,
+		 * the pipe sleeps until the next schedule interval.
+		 */
+		if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {
+			/*
+			 * If no space left or this wasn't a max size packet
+			 * then this transfer is complete. Otherwise start it
+			 * again to send the next 188 bytes
+			 */
+			if (!buffer_space_left || (bytes_this_transfer < 188)) {
+				pipe->next_tx_frame += pipe->interval;
+				cvmx_usb_complete(usb, pipe, transaction,
+						  CVMX_USB_STATUS_OK);
+			}
+			return;
+		}
+		if (transaction->stage ==
+		    CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE) {
+			/*
+			 * We are in the incoming data phase. Keep getting data
+			 * until we run out of space or get a small packet
+			 */
+			if ((buffer_space_left == 0) ||
+			    (bytes_in_last_packet < pipe->max_packet)) {
+				pipe->next_tx_frame += pipe->interval;
+				cvmx_usb_complete(usb, pipe, transaction,
+						  CVMX_USB_STATUS_OK);
+			}
+		} else {
+			transaction->stage =
+				CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
+		}
+	} else {
+		pipe->next_tx_frame += pipe->interval;
+		cvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_OK);
+	}
+}
+
+/**
+ * Poll a channel for status
+ *
+ * @usb:     USB device
+ * @channel: Channel to poll
+ *
+ * Returns: Zero on success
+ */
+static int cvmx_usb_poll_channel(struct octeon_hcd *usb, int channel)
+{
+	struct usb_hcd *hcd = octeon_to_hcd(usb);
+	struct device *dev = hcd->self.controller;
+	union cvmx_usbcx_hcintx usbc_hcint;
+	union cvmx_usbcx_hctsizx usbc_hctsiz;
+	union cvmx_usbcx_hccharx usbc_hcchar;
+	struct cvmx_usb_pipe *pipe;
+	struct cvmx_usb_transaction *transaction;
+	int bytes_this_transfer;
+	int bytes_in_last_packet;
+	int packets_processed;
+	int buffer_space_left;
+
+	/* Read the interrupt status bits for the channel */
+	usbc_hcint.u32 = cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCINTX(channel, usb->index));
+
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
+		usbc_hcchar.u32 = cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCCHARX(channel, usb->index));
+
+		if (usbc_hcchar.s.chena && usbc_hcchar.s.chdis) {
+			/*
+			 * There seems to be a bug in CN31XX which can cause
+			 * interrupt IN transfers to get stuck until we do a
+			 * write of HCCHARX without changing things
+			 */
+			cvmx_usb_write_csr32(usb,
+					     CVMX_USBCX_HCCHARX(channel,
+								usb->index),
+					     usbc_hcchar.u32);
+			return 0;
+		}
+
+		/*
+		 * In non DMA mode the channels don't halt themselves. We need
+		 * to manually disable channels that are left running
+		 */
+		if (!usbc_hcint.s.chhltd) {
+			if (usbc_hcchar.s.chena) {
+				union cvmx_usbcx_hcintmskx hcintmsk;
+				/* Disable all interrupts except CHHLTD */
+				hcintmsk.u32 = 0;
+				hcintmsk.s.chhltdmsk = 1;
+				cvmx_usb_write_csr32(usb,
+						     CVMX_USBCX_HCINTMSKX(channel, usb->index),
+						     hcintmsk.u32);
+				usbc_hcchar.s.chdis = 1;
+				cvmx_usb_write_csr32(usb,
+						     CVMX_USBCX_HCCHARX(channel, usb->index),
+						     usbc_hcchar.u32);
+				return 0;
+			} else if (usbc_hcint.s.xfercompl) {
+				/*
+				 * Successful IN/OUT with transfer complete.
+				 * Channel halt isn't needed.
+				 */
+			} else {
+				dev_err(dev, "USB%d: Channel %d interrupt without halt\n",
+					usb->index, channel);
+				return 0;
+			}
+		}
+	} else {
+		/*
+		 * There is are no interrupts that we need to process when the
+		 * channel is still running
+		 */
+		if (!usbc_hcint.s.chhltd)
+			return 0;
+	}
+
+	/* Disable the channel interrupts now that it is done */
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
+	usb->idle_hardware_channels |= (1 << channel);
+
+	/* Make sure this channel is tied to a valid pipe */
+	pipe = usb->pipe_for_channel[channel];
+	prefetch(pipe);
+	if (!pipe)
+		return 0;
+	transaction = list_first_entry(&pipe->transactions,
+				       typeof(*transaction),
+				       node);
+	prefetch(transaction);
+
+	/*
+	 * Disconnect this pipe from the HW channel. Later the schedule
+	 * function will figure out which pipe needs to go
+	 */
+	usb->pipe_for_channel[channel] = NULL;
+	pipe->flags &= ~CVMX_USB_PIPE_FLAGS_SCHEDULED;
+
+	/*
+	 * Read the channel config info so we can figure out how much data
+	 * transferred
+	 */
+	usbc_hcchar.u32 = cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HCCHARX(channel, usb->index));
+	usbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HCTSIZX(channel, usb->index));
+
+	/*
+	 * Calculating the number of bytes successfully transferred is dependent
+	 * on the transfer direction
+	 */
+	packets_processed = transaction->pktcnt - usbc_hctsiz.s.pktcnt;
+	if (usbc_hcchar.s.epdir) {
+		/*
+		 * IN transactions are easy. For every byte received the
+		 * hardware decrements xfersize. All we need to do is subtract
+		 * the current value of xfersize from its starting value and we
+		 * know how many bytes were written to the buffer
+		 */
+		bytes_this_transfer = transaction->xfersize -
+			usbc_hctsiz.s.xfersize;
+	} else {
+		/*
+		 * OUT transaction don't decrement xfersize. Instead pktcnt is
+		 * decremented on every successful packet send. The hardware
+		 * does this when it receives an ACK, or NYET. If it doesn't
+		 * receive one of these responses pktcnt doesn't change
+		 */
+		bytes_this_transfer = packets_processed * usbc_hcchar.s.mps;
+		/*
+		 * The last packet may not be a full transfer if we didn't have
+		 * enough data
+		 */
+		if (bytes_this_transfer > transaction->xfersize)
+			bytes_this_transfer = transaction->xfersize;
+	}
+	/* Figure out how many bytes were in the last packet of the transfer */
+	if (packets_processed)
+		bytes_in_last_packet = bytes_this_transfer -
+			(packets_processed - 1) * usbc_hcchar.s.mps;
+	else
+		bytes_in_last_packet = bytes_this_transfer;
+
+	/*
+	 * As a special case, setup transactions output the setup header, not
+	 * the user's data. For this reason we don't count setup data as bytes
+	 * transferred
+	 */
+	if ((transaction->stage == CVMX_USB_STAGE_SETUP) ||
+	    (transaction->stage == CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE))
+		bytes_this_transfer = 0;
+
+	/*
+	 * Add the bytes transferred to the running total. It is important that
+	 * bytes_this_transfer doesn't count any data that needs to be
+	 * retransmitted
+	 */
+	transaction->actual_bytes += bytes_this_transfer;
+	if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
+		buffer_space_left = transaction->iso_packets[0].length -
+			transaction->actual_bytes;
+	else
+		buffer_space_left = transaction->buffer_length -
+			transaction->actual_bytes;
+
+	/*
+	 * We need to remember the PID toggle state for the next transaction.
+	 * The hardware already updated it for the next transaction
+	 */
+	pipe->pid_toggle = !(usbc_hctsiz.s.pid == 0);
+
+	/*
+	 * For high speed bulk out, assume the next transaction will need to do
+	 * a ping before proceeding. If this isn't true the ACK processing below
+	 * will clear this flag
+	 */
+	if ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&
+	    (pipe->transfer_type == CVMX_USB_TRANSFER_BULK) &&
+	    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT))
+		pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
+
+	if (WARN_ON_ONCE(bytes_this_transfer < 0)) {
+		/*
+		 * In some rare cases the DMA engine seems to get stuck and
+		 * keeps substracting same byte count over and over again. In
+		 * such case we just need to fail every transaction.
+		 */
+		cvmx_usb_complete(usb, pipe, transaction,
+				  CVMX_USB_STATUS_ERROR);
+		return 0;
+	}
+
+	if (usbc_hcint.s.stall) {
+		/*
+		 * STALL as a response means this transaction cannot be
+		 * completed because the device can't process transactions. Tell
+		 * the user. Any data that was transferred will be counted on
+		 * the actual bytes transferred
+		 */
+		pipe->pid_toggle = 0;
+		cvmx_usb_complete(usb, pipe, transaction,
+				  CVMX_USB_STATUS_STALL);
+	} else if (usbc_hcint.s.xacterr) {
+		/*
+		 * XactErr as a response means the device signaled
+		 * something wrong with the transfer. For example, PID
+		 * toggle errors cause these.
+		 */
+		cvmx_usb_complete(usb, pipe, transaction,
+				  CVMX_USB_STATUS_XACTERR);
+	} else if (usbc_hcint.s.bblerr) {
+		/* Babble Error (BblErr) */
+		cvmx_usb_complete(usb, pipe, transaction,
+				  CVMX_USB_STATUS_BABBLEERR);
+	} else if (usbc_hcint.s.datatglerr) {
+		/* Data toggle error */
+		cvmx_usb_complete(usb, pipe, transaction,
+				  CVMX_USB_STATUS_DATATGLERR);
+	} else if (usbc_hcint.s.nyet) {
+		/*
+		 * NYET as a response is only allowed in three cases: as a
+		 * response to a ping, as a response to a split transaction, and
+		 * as a response to a bulk out. The ping case is handled by
+		 * hardware, so we only have splits and bulk out
+		 */
+		if (!cvmx_usb_pipe_needs_split(usb, pipe)) {
+			transaction->retries = 0;
+			/*
+			 * If there is more data to go then we need to try
+			 * again. Otherwise this transaction is complete
+			 */
+			if ((buffer_space_left == 0) ||
+			    (bytes_in_last_packet < pipe->max_packet))
+				cvmx_usb_complete(usb, pipe,
+						  transaction,
+						  CVMX_USB_STATUS_OK);
+		} else {
+			/*
+			 * Split transactions retry the split complete 4 times
+			 * then rewind to the start split and do the entire
+			 * transactions again
+			 */
+			transaction->retries++;
+			if ((transaction->retries & 0x3) == 0) {
+				/*
+				 * Rewind to the beginning of the transaction by
+				 * anding off the split complete bit
+				 */
+				transaction->stage &= ~1;
+				pipe->split_sc_frame = -1;
+			}
+		}
+	} else if (usbc_hcint.s.ack) {
+		transaction->retries = 0;
+		/*
+		 * The ACK bit can only be checked after the other error bits.
+		 * This is because a multi packet transfer may succeed in a
+		 * number of packets and then get a different response on the
+		 * last packet. In this case both ACK and the last response bit
+		 * will be set. If none of the other response bits is set, then
+		 * the last packet must have been an ACK
+		 *
+		 * Since we got an ACK, we know we don't need to do a ping on
+		 * this pipe
+		 */
+		pipe->flags &= ~CVMX_USB_PIPE_FLAGS_NEED_PING;
+
+		switch (transaction->type) {
+		case CVMX_USB_TRANSFER_CONTROL:
+			cvmx_usb_transfer_control(usb, pipe, transaction,
+						  usbc_hcchar,
+						  buffer_space_left,
+						  bytes_in_last_packet);
+			break;
+		case CVMX_USB_TRANSFER_BULK:
+			cvmx_usb_transfer_bulk(usb, pipe, transaction,
+					       usbc_hcint, buffer_space_left,
+					       bytes_in_last_packet);
+			break;
+		case CVMX_USB_TRANSFER_INTERRUPT:
+			cvmx_usb_transfer_intr(usb, pipe, transaction,
+					       buffer_space_left,
+					       bytes_in_last_packet);
+			break;
+		case CVMX_USB_TRANSFER_ISOCHRONOUS:
+			cvmx_usb_transfer_isoc(usb, pipe, transaction,
+					       buffer_space_left,
+					       bytes_in_last_packet,
+					       bytes_this_transfer);
+			break;
+		}
+	} else if (usbc_hcint.s.nak) {
+		/*
+		 * If this was a split then clear our split in progress marker.
+		 */
+		if (usb->active_split == transaction)
+			usb->active_split = NULL;
+		/*
+		 * NAK as a response means the device couldn't accept the
+		 * transaction, but it should be retried in the future. Rewind
+		 * to the beginning of the transaction by anding off the split
+		 * complete bit. Retry in the next interval
+		 */
+		transaction->retries = 0;
+		transaction->stage &= ~1;
+		pipe->next_tx_frame += pipe->interval;
+		if (pipe->next_tx_frame < usb->frame_number)
+			pipe->next_tx_frame = usb->frame_number +
+				pipe->interval -
+				(usb->frame_number - pipe->next_tx_frame) %
+				pipe->interval;
+	} else {
+		struct cvmx_usb_port_status port;
+
+		port = cvmx_usb_get_status(usb);
+		if (port.port_enabled) {
+			/* We'll retry the exact same transaction again */
+			transaction->retries++;
+		} else {
+			/*
+			 * We get channel halted interrupts with no result bits
+			 * sets when the cable is unplugged
+			 */
+			cvmx_usb_complete(usb, pipe, transaction,
+					  CVMX_USB_STATUS_ERROR);
+		}
+	}
+	return 0;
+}
+
+static void octeon_usb_port_callback(struct octeon_hcd *usb)
+{
+	spin_unlock(&usb->lock);
+	usb_hcd_poll_rh_status(octeon_to_hcd(usb));
+	spin_lock(&usb->lock);
+}
+
+/**
+ * Poll the USB block for status and call all needed callback
+ * handlers. This function is meant to be called in the interrupt
+ * handler for the USB controller. It can also be called
+ * periodically in a loop for non-interrupt based operation.
+ *
+ * @usb: USB device state populated by cvmx_usb_initialize().
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_poll(struct octeon_hcd *usb)
+{
+	union cvmx_usbcx_hfnum usbc_hfnum;
+	union cvmx_usbcx_gintsts usbc_gintsts;
+
+	prefetch_range(usb, sizeof(*usb));
+
+	/* Update the frame counter */
+	usbc_hfnum.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
+	if ((usb->frame_number & 0x3fff) > usbc_hfnum.s.frnum)
+		usb->frame_number += 0x4000;
+	usb->frame_number &= ~0x3fffull;
+	usb->frame_number |= usbc_hfnum.s.frnum;
+
+	/* Read the pending interrupts */
+	usbc_gintsts.u32 = cvmx_usb_read_csr32(usb,
+					       CVMX_USBCX_GINTSTS(usb->index));
+
+	/* Clear the interrupts now that we know about them */
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index),
+			     usbc_gintsts.u32);
+
+	if (usbc_gintsts.s.rxflvl) {
+		/*
+		 * RxFIFO Non-Empty (RxFLvl)
+		 * Indicates that there is at least one packet pending to be
+		 * read from the RxFIFO.
+		 *
+		 * In DMA mode this is handled by hardware
+		 */
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+			cvmx_usb_poll_rx_fifo(usb);
+	}
+	if (usbc_gintsts.s.ptxfemp || usbc_gintsts.s.nptxfemp) {
+		/* Fill the Tx FIFOs when not in DMA mode */
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+			cvmx_usb_poll_tx_fifo(usb);
+	}
+	if (usbc_gintsts.s.disconnint || usbc_gintsts.s.prtint) {
+		union cvmx_usbcx_hprt usbc_hprt;
+		/*
+		 * Disconnect Detected Interrupt (DisconnInt)
+		 * Asserted when a device disconnect is detected.
+		 *
+		 * Host Port Interrupt (PrtInt)
+		 * The core sets this bit to indicate a change in port status of
+		 * one of the O2P USB core ports in Host mode. The application
+		 * must read the Host Port Control and Status (HPRT) register to
+		 * determine the exact event that caused this interrupt. The
+		 * application must clear the appropriate status bit in the Host
+		 * Port Control and Status register to clear this bit.
+		 *
+		 * Call the user's port callback
+		 */
+		octeon_usb_port_callback(usb);
+		/* Clear the port change bits */
+		usbc_hprt.u32 =
+			cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+		usbc_hprt.s.prtena = 0;
+		cvmx_usb_write_csr32(usb, CVMX_USBCX_HPRT(usb->index),
+				     usbc_hprt.u32);
+	}
+	if (usbc_gintsts.s.hchint) {
+		/*
+		 * Host Channels Interrupt (HChInt)
+		 * The core sets this bit to indicate that an interrupt is
+		 * pending on one of the channels of the core (in Host mode).
+		 * The application must read the Host All Channels Interrupt
+		 * (HAINT) register to determine the exact number of the channel
+		 * on which the interrupt occurred, and then read the
+		 * corresponding Host Channel-n Interrupt (HCINTn) register to
+		 * determine the exact cause of the interrupt. The application
+		 * must clear the appropriate status bit in the HCINTn register
+		 * to clear this bit.
+		 */
+		union cvmx_usbcx_haint usbc_haint;
+
+		usbc_haint.u32 = cvmx_usb_read_csr32(usb,
+					CVMX_USBCX_HAINT(usb->index));
+		while (usbc_haint.u32) {
+			int channel;
+
+			channel = __fls(usbc_haint.u32);
+			cvmx_usb_poll_channel(usb, channel);
+			usbc_haint.u32 ^= 1 << channel;
+		}
+	}
+
+	cvmx_usb_schedule(usb, usbc_gintsts.s.sof);
+
+	return 0;
+}
+
+/* convert between an HCD pointer and the corresponding struct octeon_hcd */
+static inline struct octeon_hcd *hcd_to_octeon(struct usb_hcd *hcd)
+{
+	return (struct octeon_hcd *)(hcd->hcd_priv);
+}
+
+static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
+{
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
+	unsigned long flags;
+
+	spin_lock_irqsave(&usb->lock, flags);
+	cvmx_usb_poll(usb);
+	spin_unlock_irqrestore(&usb->lock, flags);
+	return IRQ_HANDLED;
+}
+
+static int octeon_usb_start(struct usb_hcd *hcd)
+{
+	hcd->state = HC_STATE_RUNNING;
+	return 0;
+}
+
+static void octeon_usb_stop(struct usb_hcd *hcd)
+{
+	hcd->state = HC_STATE_HALT;
+}
+
+static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
+{
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
+
+	return cvmx_usb_get_frame_number(usb);
+}
+
+static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
+				  struct urb *urb,
+				  gfp_t mem_flags)
+{
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
+	struct device *dev = hcd->self.controller;
+	struct cvmx_usb_transaction *transaction = NULL;
+	struct cvmx_usb_pipe *pipe;
+	unsigned long flags;
+	struct cvmx_usb_iso_packet *iso_packet;
+	struct usb_host_endpoint *ep = urb->ep;
+	int rc;
+
+	urb->status = 0;
+	spin_lock_irqsave(&usb->lock, flags);
+
+	rc = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (rc) {
+		spin_unlock_irqrestore(&usb->lock, flags);
+		return rc;
+	}
+
+	if (!ep->hcpriv) {
+		enum cvmx_usb_transfer transfer_type;
+		enum cvmx_usb_speed speed;
+		int split_device = 0;
+		int split_port = 0;
+
+		switch (usb_pipetype(urb->pipe)) {
+		case PIPE_ISOCHRONOUS:
+			transfer_type = CVMX_USB_TRANSFER_ISOCHRONOUS;
+			break;
+		case PIPE_INTERRUPT:
+			transfer_type = CVMX_USB_TRANSFER_INTERRUPT;
+			break;
+		case PIPE_CONTROL:
+			transfer_type = CVMX_USB_TRANSFER_CONTROL;
+			break;
+		default:
+			transfer_type = CVMX_USB_TRANSFER_BULK;
+			break;
+		}
+		switch (urb->dev->speed) {
+		case USB_SPEED_LOW:
+			speed = CVMX_USB_SPEED_LOW;
+			break;
+		case USB_SPEED_FULL:
+			speed = CVMX_USB_SPEED_FULL;
+			break;
+		default:
+			speed = CVMX_USB_SPEED_HIGH;
+			break;
+		}
+		/*
+		 * For slow devices on high speed ports we need to find the hub
+		 * that does the speed translation so we know where to send the
+		 * split transactions.
+		 */
+		if (speed != CVMX_USB_SPEED_HIGH) {
+			/*
+			 * Start at this device and work our way up the usb
+			 * tree.
+			 */
+			struct usb_device *dev = urb->dev;
+
+			while (dev->parent) {
+				/*
+				 * If our parent is high speed then he'll
+				 * receive the splits.
+				 */
+				if (dev->parent->speed == USB_SPEED_HIGH) {
+					split_device = dev->parent->devnum;
+					split_port = dev->portnum;
+					break;
+				}
+				/*
+				 * Move up the tree one level. If we make it all
+				 * the way up the tree, then the port must not
+				 * be in high speed mode and we don't need a
+				 * split.
+				 */
+				dev = dev->parent;
+			}
+		}
+		pipe = cvmx_usb_open_pipe(usb, usb_pipedevice(urb->pipe),
+					  usb_pipeendpoint(urb->pipe), speed,
+					  le16_to_cpu(ep->desc.wMaxPacketSize)
+					  & 0x7ff,
+					  transfer_type,
+					  usb_pipein(urb->pipe) ?
+						CVMX_USB_DIRECTION_IN :
+						CVMX_USB_DIRECTION_OUT,
+					  urb->interval,
+					  (le16_to_cpu(ep->desc.wMaxPacketSize)
+					   >> 11) & 0x3,
+					  split_device, split_port);
+		if (!pipe) {
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
+			spin_unlock_irqrestore(&usb->lock, flags);
+			dev_dbg(dev, "Failed to create pipe\n");
+			return -ENOMEM;
+		}
+		ep->hcpriv = pipe;
+	} else {
+		pipe = ep->hcpriv;
+	}
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_ISOCHRONOUS:
+		dev_dbg(dev, "Submit isochronous to %d.%d\n",
+			usb_pipedevice(urb->pipe),
+			usb_pipeendpoint(urb->pipe));
+		/*
+		 * Allocate a structure to use for our private list of
+		 * isochronous packets.
+		 */
+		iso_packet = kmalloc_array(urb->number_of_packets,
+					   sizeof(struct cvmx_usb_iso_packet),
+					   GFP_ATOMIC);
+		if (iso_packet) {
+			int i;
+			/* Fill the list with the data from the URB */
+			for (i = 0; i < urb->number_of_packets; i++) {
+				iso_packet[i].offset =
+					urb->iso_frame_desc[i].offset;
+				iso_packet[i].length =
+					urb->iso_frame_desc[i].length;
+				iso_packet[i].status = CVMX_USB_STATUS_ERROR;
+			}
+			/*
+			 * Store a pointer to the list in the URB setup_packet
+			 * field. We know this currently isn't being used and
+			 * this saves us a bunch of logic.
+			 */
+			urb->setup_packet = (char *)iso_packet;
+			transaction = cvmx_usb_submit_isochronous(usb,
+								  pipe, urb);
+			/*
+			 * If submit failed we need to free our private packet
+			 * list.
+			 */
+			if (!transaction) {
+				urb->setup_packet = NULL;
+				kfree(iso_packet);
+			}
+		}
+		break;
+	case PIPE_INTERRUPT:
+		dev_dbg(dev, "Submit interrupt to %d.%d\n",
+			usb_pipedevice(urb->pipe),
+			usb_pipeendpoint(urb->pipe));
+		transaction = cvmx_usb_submit_interrupt(usb, pipe, urb);
+		break;
+	case PIPE_CONTROL:
+		dev_dbg(dev, "Submit control to %d.%d\n",
+			usb_pipedevice(urb->pipe),
+			usb_pipeendpoint(urb->pipe));
+		transaction = cvmx_usb_submit_control(usb, pipe, urb);
+		break;
+	case PIPE_BULK:
+		dev_dbg(dev, "Submit bulk to %d.%d\n",
+			usb_pipedevice(urb->pipe),
+			usb_pipeendpoint(urb->pipe));
+		transaction = cvmx_usb_submit_bulk(usb, pipe, urb);
+		break;
+	}
+	if (!transaction) {
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+		spin_unlock_irqrestore(&usb->lock, flags);
+		dev_dbg(dev, "Failed to submit\n");
+		return -ENOMEM;
+	}
+	urb->hcpriv = transaction;
+	spin_unlock_irqrestore(&usb->lock, flags);
+	return 0;
+}
+
+static int octeon_usb_urb_dequeue(struct usb_hcd *hcd,
+				  struct urb *urb,
+				  int status)
+{
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
+	unsigned long flags;
+	int rc;
+
+	if (!urb->dev)
+		return -EINVAL;
+
+	spin_lock_irqsave(&usb->lock, flags);
+
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto out;
+
+	urb->status = status;
+	cvmx_usb_cancel(usb, urb->ep->hcpriv, urb->hcpriv);
+
+out:
+	spin_unlock_irqrestore(&usb->lock, flags);
+
+	return rc;
+}
+
+static void octeon_usb_endpoint_disable(struct usb_hcd *hcd,
+					struct usb_host_endpoint *ep)
+{
+	struct device *dev = hcd->self.controller;
+
+	if (ep->hcpriv) {
+		struct octeon_hcd *usb = hcd_to_octeon(hcd);
+		struct cvmx_usb_pipe *pipe = ep->hcpriv;
+		unsigned long flags;
+
+		spin_lock_irqsave(&usb->lock, flags);
+		cvmx_usb_cancel_all(usb, pipe);
+		if (cvmx_usb_close_pipe(usb, pipe))
+			dev_dbg(dev, "Closing pipe %p failed\n", pipe);
+		spin_unlock_irqrestore(&usb->lock, flags);
+		ep->hcpriv = NULL;
+	}
+}
+
+static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
+	struct cvmx_usb_port_status port_status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&usb->lock, flags);
+	port_status = cvmx_usb_get_status(usb);
+	spin_unlock_irqrestore(&usb->lock, flags);
+	buf[0] = port_status.connect_change << 1;
+
+	return buf[0] != 0;
+}
+
+static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
+				  u16 wIndex, char *buf, u16 wLength)
+{
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
+	struct device *dev = hcd->self.controller;
+	struct cvmx_usb_port_status usb_port_status;
+	int port_status;
+	struct usb_hub_descriptor *desc;
+	unsigned long flags;
+
+	switch (typeReq) {
+	case ClearHubFeature:
+		dev_dbg(dev, "ClearHubFeature\n");
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* Nothing required here */
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case ClearPortFeature:
+		dev_dbg(dev, "ClearPortFeature\n");
+		if (wIndex != 1) {
+			dev_dbg(dev, " INVALID\n");
+			return -EINVAL;
+		}
+
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			dev_dbg(dev, " ENABLE\n");
+			spin_lock_irqsave(&usb->lock, flags);
+			cvmx_usb_disable(usb);
+			spin_unlock_irqrestore(&usb->lock, flags);
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			dev_dbg(dev, " SUSPEND\n");
+			/* Not supported on Octeon */
+			break;
+		case USB_PORT_FEAT_POWER:
+			dev_dbg(dev, " POWER\n");
+			/* Not supported on Octeon */
+			break;
+		case USB_PORT_FEAT_INDICATOR:
+			dev_dbg(dev, " INDICATOR\n");
+			/* Port inidicator not supported */
+			break;
+		case USB_PORT_FEAT_C_CONNECTION:
+			dev_dbg(dev, " C_CONNECTION\n");
+			/* Clears drivers internal connect status change flag */
+			spin_lock_irqsave(&usb->lock, flags);
+			usb->port_status = cvmx_usb_get_status(usb);
+			spin_unlock_irqrestore(&usb->lock, flags);
+			break;
+		case USB_PORT_FEAT_C_RESET:
+			dev_dbg(dev, " C_RESET\n");
+			/*
+			 * Clears the driver's internal Port Reset Change flag.
+			 */
+			spin_lock_irqsave(&usb->lock, flags);
+			usb->port_status = cvmx_usb_get_status(usb);
+			spin_unlock_irqrestore(&usb->lock, flags);
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+			dev_dbg(dev, " C_ENABLE\n");
+			/*
+			 * Clears the driver's internal Port Enable/Disable
+			 * Change flag.
+			 */
+			spin_lock_irqsave(&usb->lock, flags);
+			usb->port_status = cvmx_usb_get_status(usb);
+			spin_unlock_irqrestore(&usb->lock, flags);
+			break;
+		case USB_PORT_FEAT_C_SUSPEND:
+			dev_dbg(dev, " C_SUSPEND\n");
+			/*
+			 * Clears the driver's internal Port Suspend Change
+			 * flag, which is set when resume signaling on the host
+			 * port is complete.
+			 */
+			break;
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+			dev_dbg(dev, " C_OVER_CURRENT\n");
+			/* Clears the driver's overcurrent Change flag */
+			spin_lock_irqsave(&usb->lock, flags);
+			usb->port_status = cvmx_usb_get_status(usb);
+			spin_unlock_irqrestore(&usb->lock, flags);
+			break;
+		default:
+			dev_dbg(dev, " UNKNOWN\n");
+			return -EINVAL;
+		}
+		break;
+	case GetHubDescriptor:
+		dev_dbg(dev, "GetHubDescriptor\n");
+		desc = (struct usb_hub_descriptor *)buf;
+		desc->bDescLength = 9;
+		desc->bDescriptorType = 0x29;
+		desc->bNbrPorts = 1;
+		desc->wHubCharacteristics = cpu_to_le16(0x08);
+		desc->bPwrOn2PwrGood = 1;
+		desc->bHubContrCurrent = 0;
+		desc->u.hs.DeviceRemovable[0] = 0;
+		desc->u.hs.DeviceRemovable[1] = 0xff;
+		break;
+	case GetHubStatus:
+		dev_dbg(dev, "GetHubStatus\n");
+		*(__le32 *)buf = 0;
+		break;
+	case GetPortStatus:
+		dev_dbg(dev, "GetPortStatus\n");
+		if (wIndex != 1) {
+			dev_dbg(dev, " INVALID\n");
+			return -EINVAL;
+		}
+
+		spin_lock_irqsave(&usb->lock, flags);
+		usb_port_status = cvmx_usb_get_status(usb);
+		spin_unlock_irqrestore(&usb->lock, flags);
+		port_status = 0;
+
+		if (usb_port_status.connect_change) {
+			port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
+			dev_dbg(dev, " C_CONNECTION\n");
+		}
+
+		if (usb_port_status.port_enabled) {
+			port_status |= (1 << USB_PORT_FEAT_C_ENABLE);
+			dev_dbg(dev, " C_ENABLE\n");
+		}
+
+		if (usb_port_status.connected) {
+			port_status |= (1 << USB_PORT_FEAT_CONNECTION);
+			dev_dbg(dev, " CONNECTION\n");
+		}
+
+		if (usb_port_status.port_enabled) {
+			port_status |= (1 << USB_PORT_FEAT_ENABLE);
+			dev_dbg(dev, " ENABLE\n");
+		}
+
+		if (usb_port_status.port_over_current) {
+			port_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);
+			dev_dbg(dev, " OVER_CURRENT\n");
+		}
+
+		if (usb_port_status.port_powered) {
+			port_status |= (1 << USB_PORT_FEAT_POWER);
+			dev_dbg(dev, " POWER\n");
+		}
+
+		if (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH) {
+			port_status |= USB_PORT_STAT_HIGH_SPEED;
+			dev_dbg(dev, " HIGHSPEED\n");
+		} else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW) {
+			port_status |= (1 << USB_PORT_FEAT_LOWSPEED);
+			dev_dbg(dev, " LOWSPEED\n");
+		}
+
+		*((__le32 *)buf) = cpu_to_le32(port_status);
+		break;
+	case SetHubFeature:
+		dev_dbg(dev, "SetHubFeature\n");
+		/* No HUB features supported */
+		break;
+	case SetPortFeature:
+		dev_dbg(dev, "SetPortFeature\n");
+		if (wIndex != 1) {
+			dev_dbg(dev, " INVALID\n");
+			return -EINVAL;
+		}
+
+		switch (wValue) {
+		case USB_PORT_FEAT_SUSPEND:
+			dev_dbg(dev, " SUSPEND\n");
+			return -EINVAL;
+		case USB_PORT_FEAT_POWER:
+			dev_dbg(dev, " POWER\n");
+			/*
+			 * Program the port power bit to drive VBUS on the USB.
+			 */
+			spin_lock_irqsave(&usb->lock, flags);
+			USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index),
+					cvmx_usbcx_hprt, prtpwr, 1);
+			spin_unlock_irqrestore(&usb->lock, flags);
+			return 0;
+		case USB_PORT_FEAT_RESET:
+			dev_dbg(dev, " RESET\n");
+			spin_lock_irqsave(&usb->lock, flags);
+			cvmx_usb_reset_port(usb);
+			spin_unlock_irqrestore(&usb->lock, flags);
+			return 0;
+		case USB_PORT_FEAT_INDICATOR:
+			dev_dbg(dev, " INDICATOR\n");
+			/* Not supported */
+			break;
+		default:
+			dev_dbg(dev, " UNKNOWN\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_dbg(dev, "Unknown root hub request\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static const struct hc_driver octeon_hc_driver = {
+	.description		= "Octeon USB",
+	.product_desc		= "Octeon Host Controller",
+	.hcd_priv_size		= sizeof(struct octeon_hcd),
+	.irq			= octeon_usb_irq,
+	.flags			= HCD_MEMORY | HCD_DMA | HCD_USB2,
+	.start			= octeon_usb_start,
+	.stop			= octeon_usb_stop,
+	.urb_enqueue		= octeon_usb_urb_enqueue,
+	.urb_dequeue		= octeon_usb_urb_dequeue,
+	.endpoint_disable	= octeon_usb_endpoint_disable,
+	.get_frame_number	= octeon_usb_get_frame_number,
+	.hub_status_data	= octeon_usb_hub_status_data,
+	.hub_control		= octeon_usb_hub_control,
+	.map_urb_for_dma	= octeon_map_urb_for_dma,
+	.unmap_urb_for_dma	= octeon_unmap_urb_for_dma,
+};
+
+static int octeon_usb_probe(struct platform_device *pdev)
+{
+	int status;
+	int initialize_flags;
+	int usb_num;
+	struct resource *res_mem;
+	struct device_node *usbn_node;
+	int irq = platform_get_irq(pdev, 0);
+	struct device *dev = &pdev->dev;
+	struct octeon_hcd *usb;
+	struct usb_hcd *hcd;
+	u32 clock_rate = 48000000;
+	bool is_crystal_clock = false;
+	const char *clock_type;
+	int i;
+
+	if (!dev->of_node) {
+		dev_err(dev, "Error: empty of_node\n");
+		return -ENXIO;
+	}
+	usbn_node = dev->of_node->parent;
+
+	i = of_property_read_u32(usbn_node,
+				 "clock-frequency", &clock_rate);
+	if (i)
+		i = of_property_read_u32(usbn_node,
+					 "refclk-frequency", &clock_rate);
+	if (i) {
+		dev_err(dev, "No USBN \"clock-frequency\"\n");
+		return -ENXIO;
+	}
+	switch (clock_rate) {
+	case 12000000:
+		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ;
+		break;
+	case 24000000:
+		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ;
+		break;
+	case 48000000:
+		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ;
+		break;
+	default:
+		dev_err(dev, "Illegal USBN \"clock-frequency\" %u\n",
+			clock_rate);
+		return -ENXIO;
+	}
+
+	i = of_property_read_string(usbn_node,
+				    "cavium,refclk-type", &clock_type);
+	if (i)
+		i = of_property_read_string(usbn_node,
+					    "refclk-type", &clock_type);
+
+	if (!i && strcmp("crystal", clock_type) == 0)
+		is_crystal_clock = true;
+
+	if (is_crystal_clock)
+		initialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI;
+	else
+		initialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND;
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res_mem) {
+		dev_err(dev, "found no memory resource\n");
+		return -ENXIO;
+	}
+	usb_num = (res_mem->start >> 44) & 1;
+
+	if (irq < 0) {
+		/* Defective device tree, but we know how to fix it. */
+		irq_hw_number_t hwirq = usb_num ? (1 << 6) + 17 : 56;
+
+		irq = irq_create_mapping(NULL, hwirq);
+	}
+
+	/*
+	 * Set the DMA mask to 64bits so we get buffers already translated for
+	 * DMA.
+	 */
+	i = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(64));
+	if (i)
+		return i;
+
+	/*
+	 * Only cn52XX and cn56XX have DWC_OTG USB hardware and the
+	 * IOB priority registers.  Under heavy network load USB
+	 * hardware can be starved by the IOB causing a crash.  Give
+	 * it a priority boost if it has been waiting more than 400
+	 * cycles to avoid this situation.
+	 *
+	 * Testing indicates that a cnt_val of 8192 is not sufficient,
+	 * but no failures are seen with 4096.  We choose a value of
+	 * 400 to give a safety factor of 10.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX)) {
+		union cvmx_iob_n2c_l2c_pri_cnt pri_cnt;
+
+		pri_cnt.u64 = 0;
+		pri_cnt.s.cnt_enb = 1;
+		pri_cnt.s.cnt_val = 400;
+		cvmx_write_csr(CVMX_IOB_N2C_L2C_PRI_CNT, pri_cnt.u64);
+	}
+
+	hcd = usb_create_hcd(&octeon_hc_driver, dev, dev_name(dev));
+	if (!hcd) {
+		dev_dbg(dev, "Failed to allocate memory for HCD\n");
+		return -1;
+	}
+	hcd->uses_new_polling = 1;
+	usb = (struct octeon_hcd *)hcd->hcd_priv;
+
+	spin_lock_init(&usb->lock);
+
+	usb->init_flags = initialize_flags;
+
+	/* Initialize the USB state structure */
+	usb->index = usb_num;
+	INIT_LIST_HEAD(&usb->idle_pipes);
+	for (i = 0; i < ARRAY_SIZE(usb->active_pipes); i++)
+		INIT_LIST_HEAD(&usb->active_pipes[i]);
+
+	/* Due to an errata, CN31XX doesn't support DMA */
+	if (OCTEON_IS_MODEL(OCTEON_CN31XX)) {
+		usb->init_flags |= CVMX_USB_INITIALIZE_FLAGS_NO_DMA;
+		/* Only use one channel with non DMA */
+		usb->idle_hardware_channels = 0x1;
+	} else if (OCTEON_IS_MODEL(OCTEON_CN5XXX)) {
+		/* CN5XXX have an errata with channel 3 */
+		usb->idle_hardware_channels = 0xf7;
+	} else {
+		usb->idle_hardware_channels = 0xff;
+	}
+
+	status = cvmx_usb_initialize(dev, usb);
+	if (status) {
+		dev_dbg(dev, "USB initialization failed with %d\n", status);
+		usb_put_hcd(hcd);
+		return -1;
+	}
+
+	status = usb_add_hcd(hcd, irq, 0);
+	if (status) {
+		dev_dbg(dev, "USB add HCD failed with %d\n", status);
+		usb_put_hcd(hcd);
+		return -1;
+	}
+	device_wakeup_enable(hcd->self.controller);
+
+	dev_info(dev, "Registered HCD for port %d on irq %d\n", usb_num, irq);
+
+	return 0;
+}
+
+static int octeon_usb_remove(struct platform_device *pdev)
+{
+	int status;
+	struct device *dev = &pdev->dev;
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
+	unsigned long flags;
+
+	usb_remove_hcd(hcd);
+	spin_lock_irqsave(&usb->lock, flags);
+	status = cvmx_usb_shutdown(usb);
+	spin_unlock_irqrestore(&usb->lock, flags);
+	if (status)
+		dev_dbg(dev, "USB shutdown failed with %d\n", status);
+
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+static const struct of_device_id octeon_usb_match[] = {
+	{
+		.compatible = "cavium,octeon-5750-usbc",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, octeon_usb_match);
+
+static struct platform_driver octeon_usb_driver = {
+	.driver = {
+		.name		= "octeon-hcd",
+		.of_match_table = octeon_usb_match,
+	},
+	.probe      = octeon_usb_probe,
+	.remove     = octeon_usb_remove,
+};
+
+static int __init octeon_usb_driver_init(void)
+{
+	if (usb_disabled())
+		return 0;
+
+	return platform_driver_register(&octeon_usb_driver);
+}
+module_init(octeon_usb_driver_init);
+
+static void __exit octeon_usb_driver_exit(void)
+{
+	if (usb_disabled())
+		return;
+
+	platform_driver_unregister(&octeon_usb_driver);
+}
+module_exit(octeon_usb_driver_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium, Inc. <support@cavium.com>");
+MODULE_DESCRIPTION("Cavium Inc. OCTEON USB Host driver.");

commit 95ace52e4036482da1895b6e19f15141802cc3dd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Dec 10 10:15:09 2019 +0100

    staging: octeon-usb: delete the octeon usb host controller driver
    
    This driver was merged back in 2013 and shows no progress toward every
    being merged into the "correct" part of the kernel.  The code doesn't
    even build for anyone unless you have the specific hardware platform
    selected, so odds are it doesn't even work anymore.
    
    Remove it for now and is someone comes along that has the hardware and
    is willing to fix it up, it can be reverted.
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: David Daney <ddaney.cavm@gmail.com>
    Cc: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Cc: Himadri Pandya <himadri18.07@gmail.com>
    Cc: "Frank A. Cancio Bello" <frank@generalsoftwareinc.com>
    Cc: Sumit Pundir <pundirsumit11@gmail.com>
    Cc: Laura Lazzati <laura.lazzati.15@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20191210091509.3546251-2-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
deleted file mode 100644
index 582c9187559d..000000000000
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ /dev/null
@@ -1,3737 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 2008 Cavium Networks
- *
- * Some parts of the code were originally released under BSD license:
- *
- * Copyright (c) 2003-2010 Cavium Networks (support@cavium.com). All rights
- * reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *
- *   * Neither the name of Cavium Networks nor the names of
- *     its contributors may be used to endorse or promote products
- *     derived from this software without specific prior written
- *     permission.
- *
- * This Software, including technical data, may be subject to U.S. export
- * control laws, including the U.S. Export Administration Act and its associated
- * regulations, and may be subject to export or import regulations in other
- * countries.
- *
- * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
- * AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
- * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
- * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION
- * OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
- * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
- * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
- * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR
- * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
- */
-
-#include <linux/usb.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/usb/hcd.h>
-#include <linux/prefetch.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_device.h>
-
-#include <asm/octeon/octeon.h>
-
-#include "octeon-hcd.h"
-
-/**
- * enum cvmx_usb_speed - the possible USB device speeds
- *
- * @CVMX_USB_SPEED_HIGH: Device is operation at 480Mbps
- * @CVMX_USB_SPEED_FULL: Device is operation at 12Mbps
- * @CVMX_USB_SPEED_LOW:  Device is operation at 1.5Mbps
- */
-enum cvmx_usb_speed {
-	CVMX_USB_SPEED_HIGH = 0,
-	CVMX_USB_SPEED_FULL = 1,
-	CVMX_USB_SPEED_LOW = 2,
-};
-
-/**
- * enum cvmx_usb_transfer - the possible USB transfer types
- *
- * @CVMX_USB_TRANSFER_CONTROL:	   USB transfer type control for hub and status
- *				   transfers
- * @CVMX_USB_TRANSFER_ISOCHRONOUS: USB transfer type isochronous for low
- *				   priority periodic transfers
- * @CVMX_USB_TRANSFER_BULK:	   USB transfer type bulk for large low priority
- *				   transfers
- * @CVMX_USB_TRANSFER_INTERRUPT:   USB transfer type interrupt for high priority
- *				   periodic transfers
- */
-enum cvmx_usb_transfer {
-	CVMX_USB_TRANSFER_CONTROL = 0,
-	CVMX_USB_TRANSFER_ISOCHRONOUS = 1,
-	CVMX_USB_TRANSFER_BULK = 2,
-	CVMX_USB_TRANSFER_INTERRUPT = 3,
-};
-
-/**
- * enum cvmx_usb_direction - the transfer directions
- *
- * @CVMX_USB_DIRECTION_OUT: Data is transferring from Octeon to the device/host
- * @CVMX_USB_DIRECTION_IN:  Data is transferring from the device/host to Octeon
- */
-enum cvmx_usb_direction {
-	CVMX_USB_DIRECTION_OUT,
-	CVMX_USB_DIRECTION_IN,
-};
-
-/**
- * enum cvmx_usb_status - possible callback function status codes
- *
- * @CVMX_USB_STATUS_OK:		  The transaction / operation finished without
- *				  any errors
- * @CVMX_USB_STATUS_SHORT:	  FIXME: This is currently not implemented
- * @CVMX_USB_STATUS_CANCEL:	  The transaction was canceled while in flight
- *				  by a user call to cvmx_usb_cancel
- * @CVMX_USB_STATUS_ERROR:	  The transaction aborted with an unexpected
- *				  error status
- * @CVMX_USB_STATUS_STALL:	  The transaction received a USB STALL response
- *				  from the device
- * @CVMX_USB_STATUS_XACTERR:	  The transaction failed with an error from the
- *				  device even after a number of retries
- * @CVMX_USB_STATUS_DATATGLERR:	  The transaction failed with a data toggle
- *				  error even after a number of retries
- * @CVMX_USB_STATUS_BABBLEERR:	  The transaction failed with a babble error
- * @CVMX_USB_STATUS_FRAMEERR:	  The transaction failed with a frame error
- *				  even after a number of retries
- */
-enum cvmx_usb_status {
-	CVMX_USB_STATUS_OK,
-	CVMX_USB_STATUS_SHORT,
-	CVMX_USB_STATUS_CANCEL,
-	CVMX_USB_STATUS_ERROR,
-	CVMX_USB_STATUS_STALL,
-	CVMX_USB_STATUS_XACTERR,
-	CVMX_USB_STATUS_DATATGLERR,
-	CVMX_USB_STATUS_BABBLEERR,
-	CVMX_USB_STATUS_FRAMEERR,
-};
-
-/**
- * struct cvmx_usb_port_status - the USB port status information
- *
- * @port_enabled:	1 = Usb port is enabled, 0 = disabled
- * @port_over_current:	1 = Over current detected, 0 = Over current not
- *			detected. Octeon doesn't support over current detection.
- * @port_powered:	1 = Port power is being supplied to the device, 0 =
- *			power is off. Octeon doesn't support turning port power
- *			off.
- * @port_speed:		Current port speed.
- * @connected:		1 = A device is connected to the port, 0 = No device is
- *			connected.
- * @connect_change:	1 = Device connected state changed since the last set
- *			status call.
- */
-struct cvmx_usb_port_status {
-	u32 reserved			: 25;
-	u32 port_enabled		: 1;
-	u32 port_over_current		: 1;
-	u32 port_powered		: 1;
-	enum cvmx_usb_speed port_speed	: 2;
-	u32 connected			: 1;
-	u32 connect_change		: 1;
-};
-
-/**
- * struct cvmx_usb_iso_packet - descriptor for Isochronous packets
- *
- * @offset:	This is the offset in bytes into the main buffer where this data
- *		is stored.
- * @length:	This is the length in bytes of the data.
- * @status:	This is the status of this individual packet transfer.
- */
-struct cvmx_usb_iso_packet {
-	int offset;
-	int length;
-	enum cvmx_usb_status status;
-};
-
-/**
- * enum cvmx_usb_initialize_flags - flags used by the initialization function
- *
- * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI:    The USB port uses a 12MHz crystal
- *					      as clock source at USB_XO and
- *					      USB_XI.
- * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND:   The USB port uses 12/24/48MHz 2.5V
- *					      board clock source at USB_XO.
- *					      USB_XI should be tied to GND.
- * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK: Mask for clock speed field
- * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ:    Speed of reference clock or
- *					      crystal
- * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ:    Speed of reference clock
- * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ:    Speed of reference clock
- * @CVMX_USB_INITIALIZE_FLAGS_NO_DMA:	      Disable DMA and used polled IO for
- *					      data transfer use for the USB
- */
-enum cvmx_usb_initialize_flags {
-	CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI		= 1 << 0,
-	CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND		= 1 << 1,
-	CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK	= 3 << 3,
-	CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ		= 1 << 3,
-	CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ		= 2 << 3,
-	CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ		= 3 << 3,
-	/* Bits 3-4 used to encode the clock frequency */
-	CVMX_USB_INITIALIZE_FLAGS_NO_DMA		= 1 << 5,
-};
-
-/**
- * enum cvmx_usb_pipe_flags - internal flags for a pipe.
- *
- * @CVMX_USB_PIPE_FLAGS_SCHEDULED: Used internally to determine if a pipe is
- *				   actively using hardware.
- * @CVMX_USB_PIPE_FLAGS_NEED_PING: Used internally to determine if a high speed
- *				   pipe is in the ping state.
- */
-enum cvmx_usb_pipe_flags {
-	CVMX_USB_PIPE_FLAGS_SCHEDULED	= 1 << 17,
-	CVMX_USB_PIPE_FLAGS_NEED_PING	= 1 << 18,
-};
-
-/* Maximum number of times to retry failed transactions */
-#define MAX_RETRIES		3
-
-/* Maximum number of hardware channels supported by the USB block */
-#define MAX_CHANNELS		8
-
-/*
- * The low level hardware can transfer a maximum of this number of bytes in each
- * transfer. The field is 19 bits wide
- */
-#define MAX_TRANSFER_BYTES	((1 << 19) - 1)
-
-/*
- * The low level hardware can transfer a maximum of this number of packets in
- * each transfer. The field is 10 bits wide
- */
-#define MAX_TRANSFER_PACKETS	((1 << 10) - 1)
-
-/**
- * Logical transactions may take numerous low level
- * transactions, especially when splits are concerned. This
- * enum represents all of the possible stages a transaction can
- * be in. Note that split completes are always even. This is so
- * the NAK handler can backup to the previous low level
- * transaction with a simple clearing of bit 0.
- */
-enum cvmx_usb_stage {
-	CVMX_USB_STAGE_NON_CONTROL,
-	CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE,
-	CVMX_USB_STAGE_SETUP,
-	CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE,
-	CVMX_USB_STAGE_DATA,
-	CVMX_USB_STAGE_DATA_SPLIT_COMPLETE,
-	CVMX_USB_STAGE_STATUS,
-	CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE,
-};
-
-/**
- * struct cvmx_usb_transaction - describes each pending USB transaction
- *				 regardless of type. These are linked together
- *				 to form a list of pending requests for a pipe.
- *
- * @node:		List node for transactions in the pipe.
- * @type:		Type of transaction, duplicated of the pipe.
- * @flags:		State flags for this transaction.
- * @buffer:		User's physical buffer address to read/write.
- * @buffer_length:	Size of the user's buffer in bytes.
- * @control_header:	For control transactions, physical address of the 8
- *			byte standard header.
- * @iso_start_frame:	For ISO transactions, the starting frame number.
- * @iso_number_packets:	For ISO transactions, the number of packets in the
- *			request.
- * @iso_packets:	For ISO transactions, the sub packets in the request.
- * @actual_bytes:	Actual bytes transfer for this transaction.
- * @stage:		For control transactions, the current stage.
- * @urb:		URB.
- */
-struct cvmx_usb_transaction {
-	struct list_head node;
-	enum cvmx_usb_transfer type;
-	u64 buffer;
-	int buffer_length;
-	u64 control_header;
-	int iso_start_frame;
-	int iso_number_packets;
-	struct cvmx_usb_iso_packet *iso_packets;
-	int xfersize;
-	int pktcnt;
-	int retries;
-	int actual_bytes;
-	enum cvmx_usb_stage stage;
-	struct urb *urb;
-};
-
-/**
- * struct cvmx_usb_pipe - a pipe represents a virtual connection between Octeon
- *			  and some USB device. It contains a list of pending
- *			  request to the device.
- *
- * @node:		List node for pipe list
- * @next:		Pipe after this one in the list
- * @transactions:	List of pending transactions
- * @interval:		For periodic pipes, the interval between packets in
- *			frames
- * @next_tx_frame:	The next frame this pipe is allowed to transmit on
- * @flags:		State flags for this pipe
- * @device_speed:	Speed of device connected to this pipe
- * @transfer_type:	Type of transaction supported by this pipe
- * @transfer_dir:	IN or OUT. Ignored for Control
- * @multi_count:	Max packet in a row for the device
- * @max_packet:		The device's maximum packet size in bytes
- * @device_addr:	USB device address at other end of pipe
- * @endpoint_num:	USB endpoint number at other end of pipe
- * @hub_device_addr:	Hub address this device is connected to
- * @hub_port:		Hub port this device is connected to
- * @pid_toggle:		This toggles between 0/1 on every packet send to track
- *			the data pid needed
- * @channel:		Hardware DMA channel for this pipe
- * @split_sc_frame:	The low order bits of the frame number the split
- *			complete should be sent on
- */
-struct cvmx_usb_pipe {
-	struct list_head node;
-	struct list_head transactions;
-	u64 interval;
-	u64 next_tx_frame;
-	enum cvmx_usb_pipe_flags flags;
-	enum cvmx_usb_speed device_speed;
-	enum cvmx_usb_transfer transfer_type;
-	enum cvmx_usb_direction transfer_dir;
-	int multi_count;
-	u16 max_packet;
-	u8 device_addr;
-	u8 endpoint_num;
-	u8 hub_device_addr;
-	u8 hub_port;
-	u8 pid_toggle;
-	u8 channel;
-	s8 split_sc_frame;
-};
-
-struct cvmx_usb_tx_fifo {
-	struct {
-		int channel;
-		int size;
-		u64 address;
-	} entry[MAX_CHANNELS + 1];
-	int head;
-	int tail;
-};
-
-/**
- * struct octeon_hcd - the state of the USB block
- *
- * lock:		   Serialization lock.
- * init_flags:		   Flags passed to initialize.
- * index:		   Which USB block this is for.
- * idle_hardware_channels: Bit set for every idle hardware channel.
- * usbcx_hprt:		   Stored port status so we don't need to read a CSR to
- *			   determine splits.
- * pipe_for_channel:	   Map channels to pipes.
- * pipe:		   Storage for pipes.
- * indent:		   Used by debug output to indent functions.
- * port_status:		   Last port status used for change notification.
- * idle_pipes:		   List of open pipes that have no transactions.
- * active_pipes:	   Active pipes indexed by transfer type.
- * frame_number:	   Increments every SOF interrupt for time keeping.
- * active_split:	   Points to the current active split, or NULL.
- */
-struct octeon_hcd {
-	spinlock_t lock; /* serialization lock */
-	int init_flags;
-	int index;
-	int idle_hardware_channels;
-	union cvmx_usbcx_hprt usbcx_hprt;
-	struct cvmx_usb_pipe *pipe_for_channel[MAX_CHANNELS];
-	int indent;
-	struct cvmx_usb_port_status port_status;
-	struct list_head idle_pipes;
-	struct list_head active_pipes[4];
-	u64 frame_number;
-	struct cvmx_usb_transaction *active_split;
-	struct cvmx_usb_tx_fifo periodic;
-	struct cvmx_usb_tx_fifo nonperiodic;
-};
-
-/*
- * This macro logically sets a single field in a CSR. It does the sequence
- * read, modify, and write
- */
-#define USB_SET_FIELD32(address, _union, field, value)		\
-	do {							\
-		union _union c;					\
-								\
-		c.u32 = cvmx_usb_read_csr32(usb, address);	\
-		c.s.field = value;				\
-		cvmx_usb_write_csr32(usb, address, c.u32);	\
-	} while (0)
-
-/* Returns the IO address to push/pop stuff data from the FIFOs */
-#define USB_FIFO_ADDRESS(channel, usb_index) \
-	(CVMX_USBCX_GOTGCTL(usb_index) + ((channel) + 1) * 0x1000)
-
-/**
- * struct octeon_temp_buffer - a bounce buffer for USB transfers
- * @orig_buffer: the original buffer passed by the USB stack
- * @data:	 the newly allocated temporary buffer (excluding meta-data)
- *
- * Both the DMA engine and FIFO mode will always transfer full 32-bit words. If
- * the buffer is too short, we need to allocate a temporary one, and this struct
- * represents it.
- */
-struct octeon_temp_buffer {
-	void *orig_buffer;
-	u8 data[0];
-};
-
-static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
-{
-	return container_of((void *)p, struct usb_hcd, hcd_priv);
-}
-
-/**
- * octeon_alloc_temp_buffer - allocate a temporary buffer for USB transfer
- *                            (if needed)
- * @urb:	URB.
- * @mem_flags:	Memory allocation flags.
- *
- * This function allocates a temporary bounce buffer whenever it's needed
- * due to HW limitations.
- */
-static int octeon_alloc_temp_buffer(struct urb *urb, gfp_t mem_flags)
-{
-	struct octeon_temp_buffer *temp;
-
-	if (urb->num_sgs || urb->sg ||
-	    (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP) ||
-	    !(urb->transfer_buffer_length % sizeof(u32)))
-		return 0;
-
-	temp = kmalloc(ALIGN(urb->transfer_buffer_length, sizeof(u32)) +
-		       sizeof(*temp), mem_flags);
-	if (!temp)
-		return -ENOMEM;
-
-	temp->orig_buffer = urb->transfer_buffer;
-	if (usb_urb_dir_out(urb))
-		memcpy(temp->data, urb->transfer_buffer,
-		       urb->transfer_buffer_length);
-	urb->transfer_buffer = temp->data;
-	urb->transfer_flags |= URB_ALIGNED_TEMP_BUFFER;
-
-	return 0;
-}
-
-/**
- * octeon_free_temp_buffer - free a temporary buffer used by USB transfers.
- * @urb: URB.
- *
- * Frees a buffer allocated by octeon_alloc_temp_buffer().
- */
-static void octeon_free_temp_buffer(struct urb *urb)
-{
-	struct octeon_temp_buffer *temp;
-	size_t length;
-
-	if (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))
-		return;
-
-	temp = container_of(urb->transfer_buffer, struct octeon_temp_buffer,
-			    data);
-	if (usb_urb_dir_in(urb)) {
-		if (usb_pipeisoc(urb->pipe))
-			length = urb->transfer_buffer_length;
-		else
-			length = urb->actual_length;
-
-		memcpy(temp->orig_buffer, urb->transfer_buffer, length);
-	}
-	urb->transfer_buffer = temp->orig_buffer;
-	urb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;
-	kfree(temp);
-}
-
-/**
- * octeon_map_urb_for_dma - Octeon-specific map_urb_for_dma().
- * @hcd:	USB HCD structure.
- * @urb:	URB.
- * @mem_flags:	Memory allocation flags.
- */
-static int octeon_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
-				  gfp_t mem_flags)
-{
-	int ret;
-
-	ret = octeon_alloc_temp_buffer(urb, mem_flags);
-	if (ret)
-		return ret;
-
-	ret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);
-	if (ret)
-		octeon_free_temp_buffer(urb);
-
-	return ret;
-}
-
-/**
- * octeon_unmap_urb_for_dma - Octeon-specific unmap_urb_for_dma()
- * @hcd:	USB HCD structure.
- * @urb:	URB.
- */
-static void octeon_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
-{
-	usb_hcd_unmap_urb_for_dma(hcd, urb);
-	octeon_free_temp_buffer(urb);
-}
-
-/**
- * Read a USB 32bit CSR. It performs the necessary address swizzle
- * for 32bit CSRs and logs the value in a readable format if
- * debugging is on.
- *
- * @usb:     USB block this access is for
- * @address: 64bit address to read
- *
- * Returns: Result of the read
- */
-static inline u32 cvmx_usb_read_csr32(struct octeon_hcd *usb, u64 address)
-{
-	return cvmx_read64_uint32(address ^ 4);
-}
-
-/**
- * Write a USB 32bit CSR. It performs the necessary address
- * swizzle for 32bit CSRs and logs the value in a readable format
- * if debugging is on.
- *
- * @usb:     USB block this access is for
- * @address: 64bit address to write
- * @value:   Value to write
- */
-static inline void cvmx_usb_write_csr32(struct octeon_hcd *usb,
-					u64 address, u32 value)
-{
-	cvmx_write64_uint32(address ^ 4, value);
-	cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
-}
-
-/**
- * Return non zero if this pipe connects to a non HIGH speed
- * device through a high speed hub.
- *
- * @usb:    USB block this access is for
- * @pipe:   Pipe to check
- *
- * Returns: Non zero if we need to do split transactions
- */
-static inline int cvmx_usb_pipe_needs_split(struct octeon_hcd *usb,
-					    struct cvmx_usb_pipe *pipe)
-{
-	return pipe->device_speed != CVMX_USB_SPEED_HIGH &&
-	       usb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_HIGH;
-}
-
-/**
- * Trivial utility function to return the correct PID for a pipe
- *
- * @pipe:   pipe to check
- *
- * Returns: PID for pipe
- */
-static inline int cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)
-{
-	if (pipe->pid_toggle)
-		return 2; /* Data1 */
-	return 0; /* Data0 */
-}
-
-/* Loops through register until txfflsh or rxfflsh become zero.*/
-static int cvmx_wait_tx_rx(struct octeon_hcd *usb, int fflsh_type)
-{
-	int result;
-	u64 address = CVMX_USBCX_GRSTCTL(usb->index);
-	u64 done = cvmx_get_cycle() + 100 *
-		   (u64)octeon_get_clock_rate / 1000000;
-	union cvmx_usbcx_grstctl c;
-
-	while (1) {
-		c.u32 = cvmx_usb_read_csr32(usb, address);
-		if (fflsh_type == 0 && c.s.txfflsh == 0) {
-			result = 0;
-			break;
-		} else if (fflsh_type == 1 && c.s.rxfflsh == 0) {
-			result = 0;
-			break;
-		} else if (cvmx_get_cycle() > done) {
-			result = -1;
-			break;
-		}
-
-		__delay(100);
-	}
-	return result;
-}
-
-static void cvmx_fifo_setup(struct octeon_hcd *usb)
-{
-	union cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;
-	union cvmx_usbcx_gnptxfsiz npsiz;
-	union cvmx_usbcx_hptxfsiz psiz;
-
-	usbcx_ghwcfg3.u32 = cvmx_usb_read_csr32(usb,
-						CVMX_USBCX_GHWCFG3(usb->index));
-
-	/*
-	 * Program the USBC_GRXFSIZ register to select the size of the receive
-	 * FIFO (25%).
-	 */
-	USB_SET_FIELD32(CVMX_USBCX_GRXFSIZ(usb->index), cvmx_usbcx_grxfsiz,
-			rxfdep, usbcx_ghwcfg3.s.dfifodepth / 4);
-
-	/*
-	 * Program the USBC_GNPTXFSIZ register to select the size and the start
-	 * address of the non-periodic transmit FIFO for nonperiodic
-	 * transactions (50%).
-	 */
-	npsiz.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index));
-	npsiz.s.nptxfdep = usbcx_ghwcfg3.s.dfifodepth / 2;
-	npsiz.s.nptxfstaddr = usbcx_ghwcfg3.s.dfifodepth / 4;
-	cvmx_usb_write_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index), npsiz.u32);
-
-	/*
-	 * Program the USBC_HPTXFSIZ register to select the size and start
-	 * address of the periodic transmit FIFO for periodic transactions
-	 * (25%).
-	 */
-	psiz.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index));
-	psiz.s.ptxfsize = usbcx_ghwcfg3.s.dfifodepth / 4;
-	psiz.s.ptxfstaddr = 3 * usbcx_ghwcfg3.s.dfifodepth / 4;
-	cvmx_usb_write_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index), psiz.u32);
-
-	/* Flush all FIFOs */
-	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			cvmx_usbcx_grstctl, txfnum, 0x10);
-	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			cvmx_usbcx_grstctl, txfflsh, 1);
-	cvmx_wait_tx_rx(usb, 0);
-	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			cvmx_usbcx_grstctl, rxfflsh, 1);
-	cvmx_wait_tx_rx(usb, 1);
-}
-
-/**
- * Shutdown a USB port after a call to cvmx_usb_initialize().
- * The port should be disabled with all pipes closed when this
- * function is called.
- *
- * @usb: USB device state populated by cvmx_usb_initialize().
- *
- * Returns: 0 or a negative error code.
- */
-static int cvmx_usb_shutdown(struct octeon_hcd *usb)
-{
-	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
-
-	/* Make sure all pipes are closed */
-	if (!list_empty(&usb->idle_pipes) ||
-	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_ISOCHRONOUS]) ||
-	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_INTERRUPT]) ||
-	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_CONTROL]) ||
-	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_BULK]))
-		return -EBUSY;
-
-	/* Disable the clocks and put them in power on reset */
-	usbn_clk_ctl.u64 = cvmx_read64_uint64(CVMX_USBNX_CLK_CTL(usb->index));
-	usbn_clk_ctl.s.enable = 1;
-	usbn_clk_ctl.s.por = 1;
-	usbn_clk_ctl.s.hclk_rst = 1;
-	usbn_clk_ctl.s.prst = 0;
-	usbn_clk_ctl.s.hrst = 0;
-	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
-	return 0;
-}
-
-/**
- * Initialize a USB port for use. This must be called before any
- * other access to the Octeon USB port is made. The port starts
- * off in the disabled state.
- *
- * @dev:	 Pointer to struct device for logging purposes.
- * @usb:	 Pointer to struct octeon_hcd.
- *
- * Returns: 0 or a negative error code.
- */
-static int cvmx_usb_initialize(struct device *dev,
-			       struct octeon_hcd *usb)
-{
-	int channel;
-	int divisor;
-	int retries = 0;
-	union cvmx_usbcx_hcfg usbcx_hcfg;
-	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
-	union cvmx_usbcx_gintsts usbc_gintsts;
-	union cvmx_usbcx_gahbcfg usbcx_gahbcfg;
-	union cvmx_usbcx_gintmsk usbcx_gintmsk;
-	union cvmx_usbcx_gusbcfg usbcx_gusbcfg;
-	union cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;
-
-retry:
-	/*
-	 * Power On Reset and PHY Initialization
-	 *
-	 * 1. Wait for DCOK to assert (nothing to do)
-	 *
-	 * 2a. Write USBN0/1_CLK_CTL[POR] = 1 and
-	 *     USBN0/1_CLK_CTL[HRST,PRST,HCLK_RST] = 0
-	 */
-	usbn_clk_ctl.u64 = cvmx_read64_uint64(CVMX_USBNX_CLK_CTL(usb->index));
-	usbn_clk_ctl.s.por = 1;
-	usbn_clk_ctl.s.hrst = 0;
-	usbn_clk_ctl.s.prst = 0;
-	usbn_clk_ctl.s.hclk_rst = 0;
-	usbn_clk_ctl.s.enable = 0;
-	/*
-	 * 2b. Select the USB reference clock/crystal parameters by writing
-	 *     appropriate values to USBN0/1_CLK_CTL[P_C_SEL, P_RTYPE, P_COM_ON]
-	 */
-	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND) {
-		/*
-		 * The USB port uses 12/24/48MHz 2.5V board clock
-		 * source at USB_XO. USB_XI should be tied to GND.
-		 * Most Octeon evaluation boards require this setting
-		 */
-		if (OCTEON_IS_MODEL(OCTEON_CN3XXX) ||
-		    OCTEON_IS_MODEL(OCTEON_CN56XX) ||
-		    OCTEON_IS_MODEL(OCTEON_CN50XX))
-			/* From CN56XX,CN50XX,CN31XX,CN30XX manuals */
-			usbn_clk_ctl.s.p_rtype = 2; /* p_rclk=1 & p_xenbn=0 */
-		else
-			/* From CN52XX manual */
-			usbn_clk_ctl.s.p_rtype = 1;
-
-		switch (usb->init_flags &
-			CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK) {
-		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ:
-			usbn_clk_ctl.s.p_c_sel = 0;
-			break;
-		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ:
-			usbn_clk_ctl.s.p_c_sel = 1;
-			break;
-		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ:
-			usbn_clk_ctl.s.p_c_sel = 2;
-			break;
-		}
-	} else {
-		/*
-		 * The USB port uses a 12MHz crystal as clock source
-		 * at USB_XO and USB_XI
-		 */
-		if (OCTEON_IS_MODEL(OCTEON_CN3XXX))
-			/* From CN31XX,CN30XX manual */
-			usbn_clk_ctl.s.p_rtype = 3; /* p_rclk=1 & p_xenbn=1 */
-		else
-			/* From CN56XX,CN52XX,CN50XX manuals. */
-			usbn_clk_ctl.s.p_rtype = 0;
-
-		usbn_clk_ctl.s.p_c_sel = 0;
-	}
-	/*
-	 * 2c. Select the HCLK via writing USBN0/1_CLK_CTL[DIVIDE, DIVIDE2] and
-	 *     setting USBN0/1_CLK_CTL[ENABLE] = 1. Divide the core clock down
-	 *     such that USB is as close as possible to 125Mhz
-	 */
-	divisor = DIV_ROUND_UP(octeon_get_clock_rate(), 125000000);
-	/* Lower than 4 doesn't seem to work properly */
-	if (divisor < 4)
-		divisor = 4;
-	usbn_clk_ctl.s.divide = divisor;
-	usbn_clk_ctl.s.divide2 = 0;
-	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
-
-	/* 2d. Write USBN0/1_CLK_CTL[HCLK_RST] = 1 */
-	usbn_clk_ctl.s.hclk_rst = 1;
-	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
-	/* 2e.  Wait 64 core-clock cycles for HCLK to stabilize */
-	__delay(64);
-	/*
-	 * 3. Program the power-on reset field in the USBN clock-control
-	 *    register:
-	 *    USBN_CLK_CTL[POR] = 0
-	 */
-	usbn_clk_ctl.s.por = 0;
-	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
-	/* 4. Wait 1 ms for PHY clock to start */
-	mdelay(1);
-	/*
-	 * 5. Program the Reset input from automatic test equipment field in the
-	 *    USBP control and status register:
-	 *    USBN_USBP_CTL_STATUS[ATE_RESET] = 1
-	 */
-	usbn_usbp_ctl_status.u64 =
-		cvmx_read64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index));
-	usbn_usbp_ctl_status.s.ate_reset = 1;
-	cvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),
-			    usbn_usbp_ctl_status.u64);
-	/* 6. Wait 10 cycles */
-	__delay(10);
-	/*
-	 * 7. Clear ATE_RESET field in the USBN clock-control register:
-	 *    USBN_USBP_CTL_STATUS[ATE_RESET] = 0
-	 */
-	usbn_usbp_ctl_status.s.ate_reset = 0;
-	cvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),
-			    usbn_usbp_ctl_status.u64);
-	/*
-	 * 8. Program the PHY reset field in the USBN clock-control register:
-	 *    USBN_CLK_CTL[PRST] = 1
-	 */
-	usbn_clk_ctl.s.prst = 1;
-	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
-	/*
-	 * 9. Program the USBP control and status register to select host or
-	 *    device mode. USBN_USBP_CTL_STATUS[HST_MODE] = 0 for host, = 1 for
-	 *    device
-	 */
-	usbn_usbp_ctl_status.s.hst_mode = 0;
-	cvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),
-			    usbn_usbp_ctl_status.u64);
-	/* 10. Wait 1 us */
-	udelay(1);
-	/*
-	 * 11. Program the hreset_n field in the USBN clock-control register:
-	 *     USBN_CLK_CTL[HRST] = 1
-	 */
-	usbn_clk_ctl.s.hrst = 1;
-	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
-	/* 12. Proceed to USB core initialization */
-	usbn_clk_ctl.s.enable = 1;
-	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
-	udelay(1);
-
-	/*
-	 * USB Core Initialization
-	 *
-	 * 1. Read USBC_GHWCFG1, USBC_GHWCFG2, USBC_GHWCFG3, USBC_GHWCFG4 to
-	 *    determine USB core configuration parameters.
-	 *
-	 *    Nothing needed
-	 *
-	 * 2. Program the following fields in the global AHB configuration
-	 *    register (USBC_GAHBCFG)
-	 *    DMA mode, USBC_GAHBCFG[DMAEn]: 1 = DMA mode, 0 = slave mode
-	 *    Burst length, USBC_GAHBCFG[HBSTLEN] = 0
-	 *    Nonperiodic TxFIFO empty level (slave mode only),
-	 *    USBC_GAHBCFG[NPTXFEMPLVL]
-	 *    Periodic TxFIFO empty level (slave mode only),
-	 *    USBC_GAHBCFG[PTXFEMPLVL]
-	 *    Global interrupt mask, USBC_GAHBCFG[GLBLINTRMSK] = 1
-	 */
-	usbcx_gahbcfg.u32 = 0;
-	usbcx_gahbcfg.s.dmaen = !(usb->init_flags &
-				  CVMX_USB_INITIALIZE_FLAGS_NO_DMA);
-	usbcx_gahbcfg.s.hbstlen = 0;
-	usbcx_gahbcfg.s.nptxfemplvl = 1;
-	usbcx_gahbcfg.s.ptxfemplvl = 1;
-	usbcx_gahbcfg.s.glblintrmsk = 1;
-	cvmx_usb_write_csr32(usb, CVMX_USBCX_GAHBCFG(usb->index),
-			     usbcx_gahbcfg.u32);
-
-	/*
-	 * 3. Program the following fields in USBC_GUSBCFG register.
-	 *    HS/FS timeout calibration, USBC_GUSBCFG[TOUTCAL] = 0
-	 *    ULPI DDR select, USBC_GUSBCFG[DDRSEL] = 0
-	 *    USB turnaround time, USBC_GUSBCFG[USBTRDTIM] = 0x5
-	 *    PHY low-power clock select, USBC_GUSBCFG[PHYLPWRCLKSEL] = 0
-	 */
-	usbcx_gusbcfg.u32 = cvmx_usb_read_csr32(usb,
-						CVMX_USBCX_GUSBCFG(usb->index));
-	usbcx_gusbcfg.s.toutcal = 0;
-	usbcx_gusbcfg.s.ddrsel = 0;
-	usbcx_gusbcfg.s.usbtrdtim = 0x5;
-	usbcx_gusbcfg.s.phylpwrclksel = 0;
-	cvmx_usb_write_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index),
-			     usbcx_gusbcfg.u32);
-
-	/*
-	 * 4. The software must unmask the following bits in the USBC_GINTMSK
-	 *    register.
-	 *    OTG interrupt mask, USBC_GINTMSK[OTGINTMSK] = 1
-	 *    Mode mismatch interrupt mask, USBC_GINTMSK[MODEMISMSK] = 1
-	 */
-	usbcx_gintmsk.u32 = cvmx_usb_read_csr32(usb,
-						CVMX_USBCX_GINTMSK(usb->index));
-	usbcx_gintmsk.s.otgintmsk = 1;
-	usbcx_gintmsk.s.modemismsk = 1;
-	usbcx_gintmsk.s.hchintmsk = 1;
-	usbcx_gintmsk.s.sofmsk = 0;
-	/* We need RX FIFO interrupts if we don't have DMA */
-	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
-		usbcx_gintmsk.s.rxflvlmsk = 1;
-	cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTMSK(usb->index),
-			     usbcx_gintmsk.u32);
-
-	/*
-	 * Disable all channel interrupts. We'll enable them per channel later.
-	 */
-	for (channel = 0; channel < 8; channel++)
-		cvmx_usb_write_csr32(usb,
-				     CVMX_USBCX_HCINTMSKX(channel, usb->index),
-				     0);
-
-	/*
-	 * Host Port Initialization
-	 *
-	 * 1. Program the host-port interrupt-mask field to unmask,
-	 *    USBC_GINTMSK[PRTINT] = 1
-	 */
-	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-			cvmx_usbcx_gintmsk, prtintmsk, 1);
-	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-			cvmx_usbcx_gintmsk, disconnintmsk, 1);
-
-	/*
-	 * 2. Program the USBC_HCFG register to select full-speed host
-	 *    or high-speed host.
-	 */
-	usbcx_hcfg.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HCFG(usb->index));
-	usbcx_hcfg.s.fslssupp = 0;
-	usbcx_hcfg.s.fslspclksel = 0;
-	cvmx_usb_write_csr32(usb, CVMX_USBCX_HCFG(usb->index), usbcx_hcfg.u32);
-
-	cvmx_fifo_setup(usb);
-
-	/*
-	 * If the controller is getting port events right after the reset, it
-	 * means the initialization failed. Try resetting the controller again
-	 * in such case. This is seen to happen after cold boot on DSR-1000N.
-	 */
-	usbc_gintsts.u32 = cvmx_usb_read_csr32(usb,
-					       CVMX_USBCX_GINTSTS(usb->index));
-	cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index),
-			     usbc_gintsts.u32);
-	dev_dbg(dev, "gintsts after reset: 0x%x\n", (int)usbc_gintsts.u32);
-	if (!usbc_gintsts.s.disconnint && !usbc_gintsts.s.prtint)
-		return 0;
-	if (retries++ >= 5)
-		return -EAGAIN;
-	dev_info(dev, "controller reset failed (gintsts=0x%x) - retrying\n",
-		 (int)usbc_gintsts.u32);
-	msleep(50);
-	cvmx_usb_shutdown(usb);
-	msleep(50);
-	goto retry;
-}
-
-/**
- * Reset a USB port. After this call succeeds, the USB port is
- * online and servicing requests.
- *
- * @usb: USB device state populated by cvmx_usb_initialize().
- */
-static void cvmx_usb_reset_port(struct octeon_hcd *usb)
-{
-	usb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,
-						  CVMX_USBCX_HPRT(usb->index));
-
-	/* Program the port reset bit to start the reset process */
-	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,
-			prtrst, 1);
-
-	/*
-	 * Wait at least 50ms (high speed), or 10ms (full speed) for the reset
-	 * process to complete.
-	 */
-	mdelay(50);
-
-	/* Program the port reset bit to 0, USBC_HPRT[PRTRST] = 0 */
-	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,
-			prtrst, 0);
-
-	/*
-	 * Read the port speed field to get the enumerated speed,
-	 * USBC_HPRT[PRTSPD].
-	 */
-	usb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,
-						  CVMX_USBCX_HPRT(usb->index));
-}
-
-/**
- * Disable a USB port. After this call the USB port will not
- * generate data transfers and will not generate events.
- * Transactions in process will fail and call their
- * associated callbacks.
- *
- * @usb: USB device state populated by cvmx_usb_initialize().
- *
- * Returns: 0 or a negative error code.
- */
-static int cvmx_usb_disable(struct octeon_hcd *usb)
-{
-	/* Disable the port */
-	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,
-			prtena, 1);
-	return 0;
-}
-
-/**
- * Get the current state of the USB port. Use this call to
- * determine if the usb port has anything connected, is enabled,
- * or has some sort of error condition. The return value of this
- * call has "changed" bits to signal of the value of some fields
- * have changed between calls.
- *
- * @usb: USB device state populated by cvmx_usb_initialize().
- *
- * Returns: Port status information
- */
-static struct cvmx_usb_port_status cvmx_usb_get_status(struct octeon_hcd *usb)
-{
-	union cvmx_usbcx_hprt usbc_hprt;
-	struct cvmx_usb_port_status result;
-
-	memset(&result, 0, sizeof(result));
-
-	usbc_hprt.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
-	result.port_enabled = usbc_hprt.s.prtena;
-	result.port_over_current = usbc_hprt.s.prtovrcurract;
-	result.port_powered = usbc_hprt.s.prtpwr;
-	result.port_speed = usbc_hprt.s.prtspd;
-	result.connected = usbc_hprt.s.prtconnsts;
-	result.connect_change =
-		result.connected != usb->port_status.connected;
-
-	return result;
-}
-
-/**
- * Open a virtual pipe between the host and a USB device. A pipe
- * must be opened before data can be transferred between a device
- * and Octeon.
- *
- * @usb:	     USB device state populated by cvmx_usb_initialize().
- * @device_addr:
- *		     USB device address to open the pipe to
- *		     (0-127).
- * @endpoint_num:
- *		     USB endpoint number to open the pipe to
- *		     (0-15).
- * @device_speed:
- *		     The speed of the device the pipe is going
- *		     to. This must match the device's speed,
- *		     which may be different than the port speed.
- * @max_packet:	     The maximum packet length the device can
- *		     transmit/receive (low speed=0-8, full
- *		     speed=0-1023, high speed=0-1024). This value
- *		     comes from the standard endpoint descriptor
- *		     field wMaxPacketSize bits <10:0>.
- * @transfer_type:
- *		     The type of transfer this pipe is for.
- * @transfer_dir:
- *		     The direction the pipe is in. This is not
- *		     used for control pipes.
- * @interval:	     For ISOCHRONOUS and INTERRUPT transfers,
- *		     this is how often the transfer is scheduled
- *		     for. All other transfers should specify
- *		     zero. The units are in frames (8000/sec at
- *		     high speed, 1000/sec for full speed).
- * @multi_count:
- *		     For high speed devices, this is the maximum
- *		     allowed number of packet per microframe.
- *		     Specify zero for non high speed devices. This
- *		     value comes from the standard endpoint descriptor
- *		     field wMaxPacketSize bits <12:11>.
- * @hub_device_addr:
- *		     Hub device address this device is connected
- *		     to. Devices connected directly to Octeon
- *		     use zero. This is only used when the device
- *		     is full/low speed behind a high speed hub.
- *		     The address will be of the high speed hub,
- *		     not and full speed hubs after it.
- * @hub_port:	     Which port on the hub the device is
- *		     connected. Use zero for devices connected
- *		     directly to Octeon. Like hub_device_addr,
- *		     this is only used for full/low speed
- *		     devices behind a high speed hub.
- *
- * Returns: A non-NULL value is a pipe. NULL means an error.
- */
-static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct octeon_hcd *usb,
-						int device_addr,
-						int endpoint_num,
-						enum cvmx_usb_speed
-							device_speed,
-						int max_packet,
-						enum cvmx_usb_transfer
-							transfer_type,
-						enum cvmx_usb_direction
-							transfer_dir,
-						int interval, int multi_count,
-						int hub_device_addr,
-						int hub_port)
-{
-	struct cvmx_usb_pipe *pipe;
-
-	pipe = kzalloc(sizeof(*pipe), GFP_ATOMIC);
-	if (!pipe)
-		return NULL;
-	if ((device_speed == CVMX_USB_SPEED_HIGH) &&
-	    (transfer_dir == CVMX_USB_DIRECTION_OUT) &&
-	    (transfer_type == CVMX_USB_TRANSFER_BULK))
-		pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
-	pipe->device_addr = device_addr;
-	pipe->endpoint_num = endpoint_num;
-	pipe->device_speed = device_speed;
-	pipe->max_packet = max_packet;
-	pipe->transfer_type = transfer_type;
-	pipe->transfer_dir = transfer_dir;
-	INIT_LIST_HEAD(&pipe->transactions);
-
-	/*
-	 * All pipes use interval to rate limit NAK processing. Force an
-	 * interval if one wasn't supplied
-	 */
-	if (!interval)
-		interval = 1;
-	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-		pipe->interval = interval * 8;
-		/* Force start splits to be schedule on uFrame 0 */
-		pipe->next_tx_frame = ((usb->frame_number + 7) & ~7) +
-					pipe->interval;
-	} else {
-		pipe->interval = interval;
-		pipe->next_tx_frame = usb->frame_number + pipe->interval;
-	}
-	pipe->multi_count = multi_count;
-	pipe->hub_device_addr = hub_device_addr;
-	pipe->hub_port = hub_port;
-	pipe->pid_toggle = 0;
-	pipe->split_sc_frame = -1;
-	list_add_tail(&pipe->node, &usb->idle_pipes);
-
-	/*
-	 * We don't need to tell the hardware about this pipe yet since
-	 * it doesn't have any submitted requests
-	 */
-
-	return pipe;
-}
-
-/**
- * Poll the RX FIFOs and remove data as needed. This function is only used
- * in non DMA mode. It is very important that this function be called quickly
- * enough to prevent FIFO overflow.
- *
- * @usb:	USB device state populated by cvmx_usb_initialize().
- */
-static void cvmx_usb_poll_rx_fifo(struct octeon_hcd *usb)
-{
-	union cvmx_usbcx_grxstsph rx_status;
-	int channel;
-	int bytes;
-	u64 address;
-	u32 *ptr;
-
-	rx_status.u32 = cvmx_usb_read_csr32(usb,
-					    CVMX_USBCX_GRXSTSPH(usb->index));
-	/* Only read data if IN data is there */
-	if (rx_status.s.pktsts != 2)
-		return;
-	/* Check if no data is available */
-	if (!rx_status.s.bcnt)
-		return;
-
-	channel = rx_status.s.chnum;
-	bytes = rx_status.s.bcnt;
-	if (!bytes)
-		return;
-
-	/* Get where the DMA engine would have written this data */
-	address = cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index) +
-				     channel * 8);
-
-	ptr = cvmx_phys_to_ptr(address);
-	cvmx_write64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel * 8,
-			    address + bytes);
-
-	/* Loop writing the FIFO data for this packet into memory */
-	while (bytes > 0) {
-		*ptr++ = cvmx_usb_read_csr32(usb,
-					USB_FIFO_ADDRESS(channel, usb->index));
-		bytes -= 4;
-	}
-	CVMX_SYNCW;
-}
-
-/**
- * Fill the TX hardware fifo with data out of the software
- * fifos
- *
- * @usb:	    USB device state populated by cvmx_usb_initialize().
- * @fifo:	    Software fifo to use
- * @available:	    Amount of space in the hardware fifo
- *
- * Returns: Non zero if the hardware fifo was too small and needs
- *	    to be serviced again.
- */
-static int cvmx_usb_fill_tx_hw(struct octeon_hcd *usb,
-			       struct cvmx_usb_tx_fifo *fifo, int available)
-{
-	/*
-	 * We're done either when there isn't anymore space or the software FIFO
-	 * is empty
-	 */
-	while (available && (fifo->head != fifo->tail)) {
-		int i = fifo->tail;
-		const u32 *ptr = cvmx_phys_to_ptr(fifo->entry[i].address);
-		u64 csr_address = USB_FIFO_ADDRESS(fifo->entry[i].channel,
-						   usb->index) ^ 4;
-		int words = available;
-
-		/* Limit the amount of data to what the SW fifo has */
-		if (fifo->entry[i].size <= available) {
-			words = fifo->entry[i].size;
-			fifo->tail++;
-			if (fifo->tail > MAX_CHANNELS)
-				fifo->tail = 0;
-		}
-
-		/* Update the next locations and counts */
-		available -= words;
-		fifo->entry[i].address += words * 4;
-		fifo->entry[i].size -= words;
-
-		/*
-		 * Write the HW fifo data. The read every three writes is due
-		 * to an errata on CN3XXX chips
-		 */
-		while (words > 3) {
-			cvmx_write64_uint32(csr_address, *ptr++);
-			cvmx_write64_uint32(csr_address, *ptr++);
-			cvmx_write64_uint32(csr_address, *ptr++);
-			cvmx_read64_uint64(
-					CVMX_USBNX_DMA0_INB_CHN0(usb->index));
-			words -= 3;
-		}
-		cvmx_write64_uint32(csr_address, *ptr++);
-		if (--words) {
-			cvmx_write64_uint32(csr_address, *ptr++);
-			if (--words)
-				cvmx_write64_uint32(csr_address, *ptr++);
-		}
-		cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
-	}
-	return fifo->head != fifo->tail;
-}
-
-/**
- * Check the hardware FIFOs and fill them as needed
- *
- * @usb:	USB device state populated by cvmx_usb_initialize().
- */
-static void cvmx_usb_poll_tx_fifo(struct octeon_hcd *usb)
-{
-	if (usb->periodic.head != usb->periodic.tail) {
-		union cvmx_usbcx_hptxsts tx_status;
-
-		tx_status.u32 = cvmx_usb_read_csr32(usb,
-					CVMX_USBCX_HPTXSTS(usb->index));
-		if (cvmx_usb_fill_tx_hw(usb, &usb->periodic,
-					tx_status.s.ptxfspcavail))
-			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-					cvmx_usbcx_gintmsk, ptxfempmsk, 1);
-		else
-			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-					cvmx_usbcx_gintmsk, ptxfempmsk, 0);
-	}
-
-	if (usb->nonperiodic.head != usb->nonperiodic.tail) {
-		union cvmx_usbcx_gnptxsts tx_status;
-
-		tx_status.u32 = cvmx_usb_read_csr32(usb,
-					CVMX_USBCX_GNPTXSTS(usb->index));
-		if (cvmx_usb_fill_tx_hw(usb, &usb->nonperiodic,
-					tx_status.s.nptxfspcavail))
-			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-					cvmx_usbcx_gintmsk, nptxfempmsk, 1);
-		else
-			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-					cvmx_usbcx_gintmsk, nptxfempmsk, 0);
-	}
-}
-
-/**
- * Fill the TX FIFO with an outgoing packet
- *
- * @usb:	  USB device state populated by cvmx_usb_initialize().
- * @channel:	  Channel number to get packet from
- */
-static void cvmx_usb_fill_tx_fifo(struct octeon_hcd *usb, int channel)
-{
-	union cvmx_usbcx_hccharx hcchar;
-	union cvmx_usbcx_hcspltx usbc_hcsplt;
-	union cvmx_usbcx_hctsizx usbc_hctsiz;
-	struct cvmx_usb_tx_fifo *fifo;
-
-	/* We only need to fill data on outbound channels */
-	hcchar.u32 = cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_HCCHARX(channel, usb->index));
-	if (hcchar.s.epdir != CVMX_USB_DIRECTION_OUT)
-		return;
-
-	/* OUT Splits only have data on the start and not the complete */
-	usbc_hcsplt.u32 = cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_HCSPLTX(channel, usb->index));
-	if (usbc_hcsplt.s.spltena && usbc_hcsplt.s.compsplt)
-		return;
-
-	/*
-	 * Find out how many bytes we need to fill and convert it into 32bit
-	 * words.
-	 */
-	usbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_HCTSIZX(channel, usb->index));
-	if (!usbc_hctsiz.s.xfersize)
-		return;
-
-	if ((hcchar.s.eptype == CVMX_USB_TRANSFER_INTERRUPT) ||
-	    (hcchar.s.eptype == CVMX_USB_TRANSFER_ISOCHRONOUS))
-		fifo = &usb->periodic;
-	else
-		fifo = &usb->nonperiodic;
-
-	fifo->entry[fifo->head].channel = channel;
-	fifo->entry[fifo->head].address =
-		cvmx_read64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +
-				   channel * 8);
-	fifo->entry[fifo->head].size = (usbc_hctsiz.s.xfersize + 3) >> 2;
-	fifo->head++;
-	if (fifo->head > MAX_CHANNELS)
-		fifo->head = 0;
-
-	cvmx_usb_poll_tx_fifo(usb);
-}
-
-/**
- * Perform channel specific setup for Control transactions. All
- * the generic stuff will already have been done in cvmx_usb_start_channel().
- *
- * @usb:	  USB device state populated by cvmx_usb_initialize().
- * @channel:	  Channel to setup
- * @pipe:	  Pipe for control transaction
- */
-static void cvmx_usb_start_channel_control(struct octeon_hcd *usb,
-					   int channel,
-					   struct cvmx_usb_pipe *pipe)
-{
-	struct usb_hcd *hcd = octeon_to_hcd(usb);
-	struct device *dev = hcd->self.controller;
-	struct cvmx_usb_transaction *transaction =
-		list_first_entry(&pipe->transactions, typeof(*transaction),
-				 node);
-	struct usb_ctrlrequest *header =
-		cvmx_phys_to_ptr(transaction->control_header);
-	int bytes_to_transfer = transaction->buffer_length -
-		transaction->actual_bytes;
-	int packets_to_transfer;
-	union cvmx_usbcx_hctsizx usbc_hctsiz;
-
-	usbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_HCTSIZX(channel, usb->index));
-
-	switch (transaction->stage) {
-	case CVMX_USB_STAGE_NON_CONTROL:
-	case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
-		dev_err(dev, "%s: ERROR - Non control stage\n", __func__);
-		break;
-	case CVMX_USB_STAGE_SETUP:
-		usbc_hctsiz.s.pid = 3; /* Setup */
-		bytes_to_transfer = sizeof(*header);
-		/* All Control operations start with a setup going OUT */
-		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-				cvmx_usbcx_hccharx, epdir,
-				CVMX_USB_DIRECTION_OUT);
-		/*
-		 * Setup send the control header instead of the buffer data. The
-		 * buffer data will be used in the next stage
-		 */
-		cvmx_write64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +
-					channel * 8,
-				    transaction->control_header);
-		break;
-	case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
-		usbc_hctsiz.s.pid = 3; /* Setup */
-		bytes_to_transfer = 0;
-		/* All Control operations start with a setup going OUT */
-		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-				cvmx_usbcx_hccharx, epdir,
-				CVMX_USB_DIRECTION_OUT);
-
-		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
-				cvmx_usbcx_hcspltx, compsplt, 1);
-		break;
-	case CVMX_USB_STAGE_DATA:
-		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
-		if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-			if (header->bRequestType & USB_DIR_IN)
-				bytes_to_transfer = 0;
-			else if (bytes_to_transfer > pipe->max_packet)
-				bytes_to_transfer = pipe->max_packet;
-		}
-		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-				cvmx_usbcx_hccharx, epdir,
-				((header->bRequestType & USB_DIR_IN) ?
-					CVMX_USB_DIRECTION_IN :
-					CVMX_USB_DIRECTION_OUT));
-		break;
-	case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
-		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
-		if (!(header->bRequestType & USB_DIR_IN))
-			bytes_to_transfer = 0;
-		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-				cvmx_usbcx_hccharx, epdir,
-				((header->bRequestType & USB_DIR_IN) ?
-					CVMX_USB_DIRECTION_IN :
-					CVMX_USB_DIRECTION_OUT));
-		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
-				cvmx_usbcx_hcspltx, compsplt, 1);
-		break;
-	case CVMX_USB_STAGE_STATUS:
-		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
-		bytes_to_transfer = 0;
-		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-				cvmx_usbcx_hccharx, epdir,
-				((header->bRequestType & USB_DIR_IN) ?
-					CVMX_USB_DIRECTION_OUT :
-					CVMX_USB_DIRECTION_IN));
-		break;
-	case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
-		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
-		bytes_to_transfer = 0;
-		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-				cvmx_usbcx_hccharx, epdir,
-				((header->bRequestType & USB_DIR_IN) ?
-					CVMX_USB_DIRECTION_OUT :
-					CVMX_USB_DIRECTION_IN));
-		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
-				cvmx_usbcx_hcspltx, compsplt, 1);
-		break;
-	}
-
-	/*
-	 * Make sure the transfer never exceeds the byte limit of the hardware.
-	 * Further bytes will be sent as continued transactions
-	 */
-	if (bytes_to_transfer > MAX_TRANSFER_BYTES) {
-		/* Round MAX_TRANSFER_BYTES to a multiple of out packet size */
-		bytes_to_transfer = MAX_TRANSFER_BYTES / pipe->max_packet;
-		bytes_to_transfer *= pipe->max_packet;
-	}
-
-	/*
-	 * Calculate the number of packets to transfer. If the length is zero
-	 * we still need to transfer one packet
-	 */
-	packets_to_transfer = DIV_ROUND_UP(bytes_to_transfer,
-					   pipe->max_packet);
-	if (packets_to_transfer == 0) {
-		packets_to_transfer = 1;
-	} else if ((packets_to_transfer > 1) &&
-			(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
-		/*
-		 * Limit to one packet when not using DMA. Channels must be
-		 * restarted between every packet for IN transactions, so there
-		 * is no reason to do multiple packets in a row
-		 */
-		packets_to_transfer = 1;
-		bytes_to_transfer = packets_to_transfer * pipe->max_packet;
-	} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {
-		/*
-		 * Limit the number of packet and data transferred to what the
-		 * hardware can handle
-		 */
-		packets_to_transfer = MAX_TRANSFER_PACKETS;
-		bytes_to_transfer = packets_to_transfer * pipe->max_packet;
-	}
-
-	usbc_hctsiz.s.xfersize = bytes_to_transfer;
-	usbc_hctsiz.s.pktcnt = packets_to_transfer;
-
-	cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index),
-			     usbc_hctsiz.u32);
-}
-
-/**
- * Start a channel to perform the pipe's head transaction
- *
- * @usb:	  USB device state populated by cvmx_usb_initialize().
- * @channel:	  Channel to setup
- * @pipe:	  Pipe to start
- */
-static void cvmx_usb_start_channel(struct octeon_hcd *usb, int channel,
-				   struct cvmx_usb_pipe *pipe)
-{
-	struct cvmx_usb_transaction *transaction =
-		list_first_entry(&pipe->transactions, typeof(*transaction),
-				 node);
-
-	/* Make sure all writes to the DMA region get flushed */
-	CVMX_SYNCW;
-
-	/* Attach the channel to the pipe */
-	usb->pipe_for_channel[channel] = pipe;
-	pipe->channel = channel;
-	pipe->flags |= CVMX_USB_PIPE_FLAGS_SCHEDULED;
-
-	/* Mark this channel as in use */
-	usb->idle_hardware_channels &= ~(1 << channel);
-
-	/* Enable the channel interrupt bits */
-	{
-		union cvmx_usbcx_hcintx usbc_hcint;
-		union cvmx_usbcx_hcintmskx usbc_hcintmsk;
-		union cvmx_usbcx_haintmsk usbc_haintmsk;
-
-		/* Clear all channel status bits */
-		usbc_hcint.u32 = cvmx_usb_read_csr32(usb,
-					CVMX_USBCX_HCINTX(channel, usb->index));
-
-		cvmx_usb_write_csr32(usb,
-				     CVMX_USBCX_HCINTX(channel, usb->index),
-				     usbc_hcint.u32);
-
-		usbc_hcintmsk.u32 = 0;
-		usbc_hcintmsk.s.chhltdmsk = 1;
-		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
-			/*
-			 * Channels need these extra interrupts when we aren't
-			 * in DMA mode.
-			 */
-			usbc_hcintmsk.s.datatglerrmsk = 1;
-			usbc_hcintmsk.s.frmovrunmsk = 1;
-			usbc_hcintmsk.s.bblerrmsk = 1;
-			usbc_hcintmsk.s.xacterrmsk = 1;
-			if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-				/*
-				 * Splits don't generate xfercompl, so we need
-				 * ACK and NYET.
-				 */
-				usbc_hcintmsk.s.nyetmsk = 1;
-				usbc_hcintmsk.s.ackmsk = 1;
-			}
-			usbc_hcintmsk.s.nakmsk = 1;
-			usbc_hcintmsk.s.stallmsk = 1;
-			usbc_hcintmsk.s.xfercomplmsk = 1;
-		}
-		cvmx_usb_write_csr32(usb,
-				     CVMX_USBCX_HCINTMSKX(channel, usb->index),
-				     usbc_hcintmsk.u32);
-
-		/* Enable the channel interrupt to propagate */
-		usbc_haintmsk.u32 = cvmx_usb_read_csr32(usb,
-					CVMX_USBCX_HAINTMSK(usb->index));
-		usbc_haintmsk.s.haintmsk |= 1 << channel;
-		cvmx_usb_write_csr32(usb, CVMX_USBCX_HAINTMSK(usb->index),
-				     usbc_haintmsk.u32);
-	}
-
-	/* Setup the location the DMA engine uses. */
-	{
-		u64 reg;
-		u64 dma_address = transaction->buffer +
-				  transaction->actual_bytes;
-
-		if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
-			dma_address = transaction->buffer +
-					transaction->iso_packets[0].offset +
-					transaction->actual_bytes;
-
-		if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT)
-			reg = CVMX_USBNX_DMA0_OUTB_CHN0(usb->index);
-		else
-			reg = CVMX_USBNX_DMA0_INB_CHN0(usb->index);
-		cvmx_write64_uint64(reg + channel * 8, dma_address);
-	}
-
-	/* Setup both the size of the transfer and the SPLIT characteristics */
-	{
-		union cvmx_usbcx_hcspltx usbc_hcsplt = {.u32 = 0};
-		union cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 = 0};
-		int packets_to_transfer;
-		int bytes_to_transfer = transaction->buffer_length -
-			transaction->actual_bytes;
-
-		/*
-		 * ISOCHRONOUS transactions store each individual transfer size
-		 * in the packet structure, not the global buffer_length
-		 */
-		if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
-			bytes_to_transfer =
-				transaction->iso_packets[0].length -
-				transaction->actual_bytes;
-
-		/*
-		 * We need to do split transactions when we are talking to non
-		 * high speed devices that are behind a high speed hub
-		 */
-		if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-			/*
-			 * On the start split phase (stage is even) record the
-			 * frame number we will need to send the split complete.
-			 * We only store the lower two bits since the time ahead
-			 * can only be two frames
-			 */
-			if ((transaction->stage & 1) == 0) {
-				if (transaction->type == CVMX_USB_TRANSFER_BULK)
-					pipe->split_sc_frame =
-						(usb->frame_number + 1) & 0x7f;
-				else
-					pipe->split_sc_frame =
-						(usb->frame_number + 2) & 0x7f;
-			} else {
-				pipe->split_sc_frame = -1;
-			}
-
-			usbc_hcsplt.s.spltena = 1;
-			usbc_hcsplt.s.hubaddr = pipe->hub_device_addr;
-			usbc_hcsplt.s.prtaddr = pipe->hub_port;
-			usbc_hcsplt.s.compsplt = (transaction->stage ==
-				CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE);
-
-			/*
-			 * SPLIT transactions can only ever transmit one data
-			 * packet so limit the transfer size to the max packet
-			 * size
-			 */
-			if (bytes_to_transfer > pipe->max_packet)
-				bytes_to_transfer = pipe->max_packet;
-
-			/*
-			 * ISOCHRONOUS OUT splits are unique in that they limit
-			 * data transfers to 188 byte chunks representing the
-			 * begin/middle/end of the data or all
-			 */
-			if (!usbc_hcsplt.s.compsplt &&
-			    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) &&
-			    (pipe->transfer_type ==
-			     CVMX_USB_TRANSFER_ISOCHRONOUS)) {
-				/*
-				 * Clear the split complete frame number as
-				 * there isn't going to be a split complete
-				 */
-				pipe->split_sc_frame = -1;
-				/*
-				 * See if we've started this transfer and sent
-				 * data
-				 */
-				if (transaction->actual_bytes == 0) {
-					/*
-					 * Nothing sent yet, this is either a
-					 * begin or the entire payload
-					 */
-					if (bytes_to_transfer <= 188)
-						/* Entire payload in one go */
-						usbc_hcsplt.s.xactpos = 3;
-					else
-						/* First part of payload */
-						usbc_hcsplt.s.xactpos = 2;
-				} else {
-					/*
-					 * Continuing the previous data, we must
-					 * either be in the middle or at the end
-					 */
-					if (bytes_to_transfer <= 188)
-						/* End of payload */
-						usbc_hcsplt.s.xactpos = 1;
-					else
-						/* Middle of payload */
-						usbc_hcsplt.s.xactpos = 0;
-				}
-				/*
-				 * Again, the transfer size is limited to 188
-				 * bytes
-				 */
-				if (bytes_to_transfer > 188)
-					bytes_to_transfer = 188;
-			}
-		}
-
-		/*
-		 * Make sure the transfer never exceeds the byte limit of the
-		 * hardware. Further bytes will be sent as continued
-		 * transactions
-		 */
-		if (bytes_to_transfer > MAX_TRANSFER_BYTES) {
-			/*
-			 * Round MAX_TRANSFER_BYTES to a multiple of out packet
-			 * size
-			 */
-			bytes_to_transfer = MAX_TRANSFER_BYTES /
-				pipe->max_packet;
-			bytes_to_transfer *= pipe->max_packet;
-		}
-
-		/*
-		 * Calculate the number of packets to transfer. If the length is
-		 * zero we still need to transfer one packet
-		 */
-		packets_to_transfer =
-			DIV_ROUND_UP(bytes_to_transfer, pipe->max_packet);
-		if (packets_to_transfer == 0) {
-			packets_to_transfer = 1;
-		} else if ((packets_to_transfer > 1) &&
-			   (usb->init_flags &
-			    CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
-			/*
-			 * Limit to one packet when not using DMA. Channels must
-			 * be restarted between every packet for IN
-			 * transactions, so there is no reason to do multiple
-			 * packets in a row
-			 */
-			packets_to_transfer = 1;
-			bytes_to_transfer = packets_to_transfer *
-				pipe->max_packet;
-		} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {
-			/*
-			 * Limit the number of packet and data transferred to
-			 * what the hardware can handle
-			 */
-			packets_to_transfer = MAX_TRANSFER_PACKETS;
-			bytes_to_transfer = packets_to_transfer *
-				pipe->max_packet;
-		}
-
-		usbc_hctsiz.s.xfersize = bytes_to_transfer;
-		usbc_hctsiz.s.pktcnt = packets_to_transfer;
-
-		/* Update the DATA0/DATA1 toggle */
-		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
-		/*
-		 * High speed pipes may need a hardware ping before they start
-		 */
-		if (pipe->flags & CVMX_USB_PIPE_FLAGS_NEED_PING)
-			usbc_hctsiz.s.dopng = 1;
-
-		cvmx_usb_write_csr32(usb,
-				     CVMX_USBCX_HCSPLTX(channel, usb->index),
-				     usbc_hcsplt.u32);
-		cvmx_usb_write_csr32(usb,
-				     CVMX_USBCX_HCTSIZX(channel, usb->index),
-				     usbc_hctsiz.u32);
-	}
-
-	/* Setup the Host Channel Characteristics Register */
-	{
-		union cvmx_usbcx_hccharx usbc_hcchar = {.u32 = 0};
-
-		/*
-		 * Set the startframe odd/even properly. This is only used for
-		 * periodic
-		 */
-		usbc_hcchar.s.oddfrm = usb->frame_number & 1;
-
-		/*
-		 * Set the number of back to back packets allowed by this
-		 * endpoint. Split transactions interpret "ec" as the number of
-		 * immediate retries of failure. These retries happen too
-		 * quickly, so we disable these entirely for splits
-		 */
-		if (cvmx_usb_pipe_needs_split(usb, pipe))
-			usbc_hcchar.s.ec = 1;
-		else if (pipe->multi_count < 1)
-			usbc_hcchar.s.ec = 1;
-		else if (pipe->multi_count > 3)
-			usbc_hcchar.s.ec = 3;
-		else
-			usbc_hcchar.s.ec = pipe->multi_count;
-
-		/* Set the rest of the endpoint specific settings */
-		usbc_hcchar.s.devaddr = pipe->device_addr;
-		usbc_hcchar.s.eptype = transaction->type;
-		usbc_hcchar.s.lspddev =
-			(pipe->device_speed == CVMX_USB_SPEED_LOW);
-		usbc_hcchar.s.epdir = pipe->transfer_dir;
-		usbc_hcchar.s.epnum = pipe->endpoint_num;
-		usbc_hcchar.s.mps = pipe->max_packet;
-		cvmx_usb_write_csr32(usb,
-				     CVMX_USBCX_HCCHARX(channel, usb->index),
-				     usbc_hcchar.u32);
-	}
-
-	/* Do transaction type specific fixups as needed */
-	switch (transaction->type) {
-	case CVMX_USB_TRANSFER_CONTROL:
-		cvmx_usb_start_channel_control(usb, channel, pipe);
-		break;
-	case CVMX_USB_TRANSFER_BULK:
-	case CVMX_USB_TRANSFER_INTERRUPT:
-		break;
-	case CVMX_USB_TRANSFER_ISOCHRONOUS:
-		if (!cvmx_usb_pipe_needs_split(usb, pipe)) {
-			/*
-			 * ISO transactions require different PIDs depending on
-			 * direction and how many packets are needed
-			 */
-			if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {
-				if (pipe->multi_count < 2) /* Need DATA0 */
-					USB_SET_FIELD32(
-						CVMX_USBCX_HCTSIZX(channel,
-								   usb->index),
-						cvmx_usbcx_hctsizx, pid, 0);
-				else /* Need MDATA */
-					USB_SET_FIELD32(
-						CVMX_USBCX_HCTSIZX(channel,
-								   usb->index),
-						cvmx_usbcx_hctsizx, pid, 3);
-			}
-		}
-		break;
-	}
-	{
-		union cvmx_usbcx_hctsizx usbc_hctsiz = { .u32 =
-			cvmx_usb_read_csr32(usb,
-					    CVMX_USBCX_HCTSIZX(channel,
-							       usb->index))
-		};
-		transaction->xfersize = usbc_hctsiz.s.xfersize;
-		transaction->pktcnt = usbc_hctsiz.s.pktcnt;
-	}
-	/* Remember when we start a split transaction */
-	if (cvmx_usb_pipe_needs_split(usb, pipe))
-		usb->active_split = transaction;
-	USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-			cvmx_usbcx_hccharx, chena, 1);
-	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
-		cvmx_usb_fill_tx_fifo(usb, channel);
-}
-
-/**
- * Find a pipe that is ready to be scheduled to hardware.
- * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @xfer_type:	 Transfer type
- *
- * Returns: Pipe or NULL if none are ready
- */
-static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(struct octeon_hcd *usb,
-		enum cvmx_usb_transfer xfer_type)
-{
-	struct list_head *list = usb->active_pipes + xfer_type;
-	u64 current_frame = usb->frame_number;
-	struct cvmx_usb_pipe *pipe;
-
-	list_for_each_entry(pipe, list, node) {
-		struct cvmx_usb_transaction *t =
-			list_first_entry(&pipe->transactions, typeof(*t),
-					 node);
-		if (!(pipe->flags & CVMX_USB_PIPE_FLAGS_SCHEDULED) && t &&
-		    (pipe->next_tx_frame <= current_frame) &&
-		    ((pipe->split_sc_frame == -1) ||
-		     ((((int)current_frame - pipe->split_sc_frame) & 0x7f) <
-		      0x40)) &&
-		    (!usb->active_split || (usb->active_split == t))) {
-			prefetch(t);
-			return pipe;
-		}
-	}
-	return NULL;
-}
-
-static struct cvmx_usb_pipe *cvmx_usb_next_pipe(struct octeon_hcd *usb,
-						int is_sof)
-{
-	struct cvmx_usb_pipe *pipe;
-
-	/* Find a pipe needing service. */
-	if (is_sof) {
-		/*
-		 * Only process periodic pipes on SOF interrupts. This way we
-		 * are sure that the periodic data is sent in the beginning of
-		 * the frame.
-		 */
-		pipe = cvmx_usb_find_ready_pipe(usb,
-						CVMX_USB_TRANSFER_ISOCHRONOUS);
-		if (pipe)
-			return pipe;
-		pipe = cvmx_usb_find_ready_pipe(usb,
-						CVMX_USB_TRANSFER_INTERRUPT);
-		if (pipe)
-			return pipe;
-	}
-	pipe = cvmx_usb_find_ready_pipe(usb, CVMX_USB_TRANSFER_CONTROL);
-	if (pipe)
-		return pipe;
-	return cvmx_usb_find_ready_pipe(usb, CVMX_USB_TRANSFER_BULK);
-}
-
-/**
- * Called whenever a pipe might need to be scheduled to the
- * hardware.
- *
- * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @is_sof:	 True if this schedule was called on a SOF interrupt.
- */
-static void cvmx_usb_schedule(struct octeon_hcd *usb, int is_sof)
-{
-	int channel;
-	struct cvmx_usb_pipe *pipe;
-	int need_sof;
-	enum cvmx_usb_transfer ttype;
-
-	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
-		/*
-		 * Without DMA we need to be careful to not schedule something
-		 * at the end of a frame and cause an overrun.
-		 */
-		union cvmx_usbcx_hfnum hfnum = {
-			.u32 = cvmx_usb_read_csr32(usb,
-						CVMX_USBCX_HFNUM(usb->index))
-		};
-
-		union cvmx_usbcx_hfir hfir = {
-			.u32 = cvmx_usb_read_csr32(usb,
-						CVMX_USBCX_HFIR(usb->index))
-		};
-
-		if (hfnum.s.frrem < hfir.s.frint / 4)
-			goto done;
-	}
-
-	while (usb->idle_hardware_channels) {
-		/* Find an idle channel */
-		channel = __fls(usb->idle_hardware_channels);
-		if (unlikely(channel > 7))
-			break;
-
-		pipe = cvmx_usb_next_pipe(usb, is_sof);
-		if (!pipe)
-			break;
-
-		cvmx_usb_start_channel(usb, channel, pipe);
-	}
-
-done:
-	/*
-	 * Only enable SOF interrupts when we have transactions pending in the
-	 * future that might need to be scheduled
-	 */
-	need_sof = 0;
-	for (ttype = CVMX_USB_TRANSFER_CONTROL;
-	     ttype <= CVMX_USB_TRANSFER_INTERRUPT; ttype++) {
-		list_for_each_entry(pipe, &usb->active_pipes[ttype], node) {
-			if (pipe->next_tx_frame > usb->frame_number) {
-				need_sof = 1;
-				break;
-			}
-		}
-	}
-	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-			cvmx_usbcx_gintmsk, sofmsk, need_sof);
-}
-
-static void octeon_usb_urb_complete_callback(struct octeon_hcd *usb,
-					     enum cvmx_usb_status status,
-					     struct cvmx_usb_pipe *pipe,
-					     struct cvmx_usb_transaction
-						*transaction,
-					     int bytes_transferred,
-					     struct urb *urb)
-{
-	struct usb_hcd *hcd = octeon_to_hcd(usb);
-	struct device *dev = hcd->self.controller;
-
-	if (likely(status == CVMX_USB_STATUS_OK))
-		urb->actual_length = bytes_transferred;
-	else
-		urb->actual_length = 0;
-
-	urb->hcpriv = NULL;
-
-	/* For Isochronous transactions we need to update the URB packet status
-	 * list from data in our private copy
-	 */
-	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
-		int i;
-		/*
-		 * The pointer to the private list is stored in the setup_packet
-		 * field.
-		 */
-		struct cvmx_usb_iso_packet *iso_packet =
-			(struct cvmx_usb_iso_packet *)urb->setup_packet;
-		/* Recalculate the transfer size by adding up each packet */
-		urb->actual_length = 0;
-		for (i = 0; i < urb->number_of_packets; i++) {
-			if (iso_packet[i].status == CVMX_USB_STATUS_OK) {
-				urb->iso_frame_desc[i].status = 0;
-				urb->iso_frame_desc[i].actual_length =
-					iso_packet[i].length;
-				urb->actual_length +=
-					urb->iso_frame_desc[i].actual_length;
-			} else {
-				dev_dbg(dev, "ISOCHRONOUS packet=%d of %d status=%d pipe=%p transaction=%p size=%d\n",
-					i, urb->number_of_packets,
-					iso_packet[i].status, pipe,
-					transaction, iso_packet[i].length);
-				urb->iso_frame_desc[i].status = -EREMOTEIO;
-			}
-		}
-		/* Free the private list now that we don't need it anymore */
-		kfree(iso_packet);
-		urb->setup_packet = NULL;
-	}
-
-	switch (status) {
-	case CVMX_USB_STATUS_OK:
-		urb->status = 0;
-		break;
-	case CVMX_USB_STATUS_CANCEL:
-		if (urb->status == 0)
-			urb->status = -ENOENT;
-		break;
-	case CVMX_USB_STATUS_STALL:
-		dev_dbg(dev, "status=stall pipe=%p transaction=%p size=%d\n",
-			pipe, transaction, bytes_transferred);
-		urb->status = -EPIPE;
-		break;
-	case CVMX_USB_STATUS_BABBLEERR:
-		dev_dbg(dev, "status=babble pipe=%p transaction=%p size=%d\n",
-			pipe, transaction, bytes_transferred);
-		urb->status = -EPIPE;
-		break;
-	case CVMX_USB_STATUS_SHORT:
-		dev_dbg(dev, "status=short pipe=%p transaction=%p size=%d\n",
-			pipe, transaction, bytes_transferred);
-		urb->status = -EREMOTEIO;
-		break;
-	case CVMX_USB_STATUS_ERROR:
-	case CVMX_USB_STATUS_XACTERR:
-	case CVMX_USB_STATUS_DATATGLERR:
-	case CVMX_USB_STATUS_FRAMEERR:
-		dev_dbg(dev, "status=%d pipe=%p transaction=%p size=%d\n",
-			status, pipe, transaction, bytes_transferred);
-		urb->status = -EPROTO;
-		break;
-	}
-	usb_hcd_unlink_urb_from_ep(octeon_to_hcd(usb), urb);
-	spin_unlock(&usb->lock);
-	usb_hcd_giveback_urb(octeon_to_hcd(usb), urb, urb->status);
-	spin_lock(&usb->lock);
-}
-
-/**
- * Signal the completion of a transaction and free it. The
- * transaction will be removed from the pipe transaction list.
- *
- * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @pipe:	 Pipe the transaction is on
- * @transaction:
- *		 Transaction that completed
- * @complete_code:
- *		 Completion code
- */
-static void cvmx_usb_complete(struct octeon_hcd *usb,
-			      struct cvmx_usb_pipe *pipe,
-			      struct cvmx_usb_transaction *transaction,
-			      enum cvmx_usb_status complete_code)
-{
-	/* If this was a split then clear our split in progress marker */
-	if (usb->active_split == transaction)
-		usb->active_split = NULL;
-
-	/*
-	 * Isochronous transactions need extra processing as they might not be
-	 * done after a single data transfer
-	 */
-	if (unlikely(transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)) {
-		/* Update the number of bytes transferred in this ISO packet */
-		transaction->iso_packets[0].length = transaction->actual_bytes;
-		transaction->iso_packets[0].status = complete_code;
-
-		/*
-		 * If there are more ISOs pending and we succeeded, schedule the
-		 * next one
-		 */
-		if ((transaction->iso_number_packets > 1) &&
-		    (complete_code == CVMX_USB_STATUS_OK)) {
-			/* No bytes transferred for this packet as of yet */
-			transaction->actual_bytes = 0;
-			/* One less ISO waiting to transfer */
-			transaction->iso_number_packets--;
-			/* Increment to the next location in our packet array */
-			transaction->iso_packets++;
-			transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
-			return;
-		}
-	}
-
-	/* Remove the transaction from the pipe list */
-	list_del(&transaction->node);
-	if (list_empty(&pipe->transactions))
-		list_move_tail(&pipe->node, &usb->idle_pipes);
-	octeon_usb_urb_complete_callback(usb, complete_code, pipe,
-					 transaction,
-					 transaction->actual_bytes,
-					 transaction->urb);
-	kfree(transaction);
-}
-
-/**
- * Submit a usb transaction to a pipe. Called for all types
- * of transactions.
- *
- * @usb:
- * @pipe:	    Which pipe to submit to.
- * @type:	    Transaction type
- * @buffer:	    User buffer for the transaction
- * @buffer_length:
- *		    User buffer's length in bytes
- * @control_header:
- *		    For control transactions, the 8 byte standard header
- * @iso_start_frame:
- *		    For ISO transactions, the start frame
- * @iso_number_packets:
- *		    For ISO, the number of packet in the transaction.
- * @iso_packets:
- *		    A description of each ISO packet
- * @urb:	    URB for the callback
- *
- * Returns: Transaction or NULL on failure.
- */
-static struct cvmx_usb_transaction *cvmx_usb_submit_transaction(
-				struct octeon_hcd *usb,
-				struct cvmx_usb_pipe *pipe,
-				enum cvmx_usb_transfer type,
-				u64 buffer,
-				int buffer_length,
-				u64 control_header,
-				int iso_start_frame,
-				int iso_number_packets,
-				struct cvmx_usb_iso_packet *iso_packets,
-				struct urb *urb)
-{
-	struct cvmx_usb_transaction *transaction;
-
-	if (unlikely(pipe->transfer_type != type))
-		return NULL;
-
-	transaction = kzalloc(sizeof(*transaction), GFP_ATOMIC);
-	if (unlikely(!transaction))
-		return NULL;
-
-	transaction->type = type;
-	transaction->buffer = buffer;
-	transaction->buffer_length = buffer_length;
-	transaction->control_header = control_header;
-	/* FIXME: This is not used, implement it. */
-	transaction->iso_start_frame = iso_start_frame;
-	transaction->iso_number_packets = iso_number_packets;
-	transaction->iso_packets = iso_packets;
-	transaction->urb = urb;
-	if (transaction->type == CVMX_USB_TRANSFER_CONTROL)
-		transaction->stage = CVMX_USB_STAGE_SETUP;
-	else
-		transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
-
-	if (!list_empty(&pipe->transactions)) {
-		list_add_tail(&transaction->node, &pipe->transactions);
-	} else {
-		list_add_tail(&transaction->node, &pipe->transactions);
-		list_move_tail(&pipe->node,
-			       &usb->active_pipes[pipe->transfer_type]);
-
-		/*
-		 * We may need to schedule the pipe if this was the head of the
-		 * pipe.
-		 */
-		cvmx_usb_schedule(usb, 0);
-	}
-
-	return transaction;
-}
-
-/**
- * Call to submit a USB Bulk transfer to a pipe.
- *
- * @usb:	    USB device state populated by cvmx_usb_initialize().
- * @pipe:	    Handle to the pipe for the transfer.
- * @urb:	    URB.
- *
- * Returns: A submitted transaction or NULL on failure.
- */
-static struct cvmx_usb_transaction *cvmx_usb_submit_bulk(
-						struct octeon_hcd *usb,
-						struct cvmx_usb_pipe *pipe,
-						struct urb *urb)
-{
-	return cvmx_usb_submit_transaction(usb, pipe, CVMX_USB_TRANSFER_BULK,
-					   urb->transfer_dma,
-					   urb->transfer_buffer_length,
-					   0, /* control_header */
-					   0, /* iso_start_frame */
-					   0, /* iso_number_packets */
-					   NULL, /* iso_packets */
-					   urb);
-}
-
-/**
- * Call to submit a USB Interrupt transfer to a pipe.
- *
- * @usb:	    USB device state populated by cvmx_usb_initialize().
- * @pipe:	    Handle to the pipe for the transfer.
- * @urb:	    URB returned when the callback is called.
- *
- * Returns: A submitted transaction or NULL on failure.
- */
-static struct cvmx_usb_transaction *cvmx_usb_submit_interrupt(
-						struct octeon_hcd *usb,
-						struct cvmx_usb_pipe *pipe,
-						struct urb *urb)
-{
-	return cvmx_usb_submit_transaction(usb, pipe,
-					   CVMX_USB_TRANSFER_INTERRUPT,
-					   urb->transfer_dma,
-					   urb->transfer_buffer_length,
-					   0, /* control_header */
-					   0, /* iso_start_frame */
-					   0, /* iso_number_packets */
-					   NULL, /* iso_packets */
-					   urb);
-}
-
-/**
- * Call to submit a USB Control transfer to a pipe.
- *
- * @usb:	    USB device state populated by cvmx_usb_initialize().
- * @pipe:	    Handle to the pipe for the transfer.
- * @urb:	    URB.
- *
- * Returns: A submitted transaction or NULL on failure.
- */
-static struct cvmx_usb_transaction *cvmx_usb_submit_control(
-						struct octeon_hcd *usb,
-						struct cvmx_usb_pipe *pipe,
-						struct urb *urb)
-{
-	int buffer_length = urb->transfer_buffer_length;
-	u64 control_header = urb->setup_dma;
-	struct usb_ctrlrequest *header = cvmx_phys_to_ptr(control_header);
-
-	if ((header->bRequestType & USB_DIR_IN) == 0)
-		buffer_length = le16_to_cpu(header->wLength);
-
-	return cvmx_usb_submit_transaction(usb, pipe,
-					   CVMX_USB_TRANSFER_CONTROL,
-					   urb->transfer_dma, buffer_length,
-					   control_header,
-					   0, /* iso_start_frame */
-					   0, /* iso_number_packets */
-					   NULL, /* iso_packets */
-					   urb);
-}
-
-/**
- * Call to submit a USB Isochronous transfer to a pipe.
- *
- * @usb:	    USB device state populated by cvmx_usb_initialize().
- * @pipe:	    Handle to the pipe for the transfer.
- * @urb:	    URB returned when the callback is called.
- *
- * Returns: A submitted transaction or NULL on failure.
- */
-static struct cvmx_usb_transaction *cvmx_usb_submit_isochronous(
-						struct octeon_hcd *usb,
-						struct cvmx_usb_pipe *pipe,
-						struct urb *urb)
-{
-	struct cvmx_usb_iso_packet *packets;
-
-	packets = (struct cvmx_usb_iso_packet *)urb->setup_packet;
-	return cvmx_usb_submit_transaction(usb, pipe,
-					   CVMX_USB_TRANSFER_ISOCHRONOUS,
-					   urb->transfer_dma,
-					   urb->transfer_buffer_length,
-					   0, /* control_header */
-					   urb->start_frame,
-					   urb->number_of_packets,
-					   packets, urb);
-}
-
-/**
- * Cancel one outstanding request in a pipe. Canceling a request
- * can fail if the transaction has already completed before cancel
- * is called. Even after a successful cancel call, it may take
- * a frame or two for the cvmx_usb_poll() function to call the
- * associated callback.
- *
- * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @pipe:	 Pipe to cancel requests in.
- * @transaction: Transaction to cancel, returned by the submit function.
- *
- * Returns: 0 or a negative error code.
- */
-static int cvmx_usb_cancel(struct octeon_hcd *usb,
-			   struct cvmx_usb_pipe *pipe,
-			   struct cvmx_usb_transaction *transaction)
-{
-	/*
-	 * If the transaction is the HEAD of the queue and scheduled. We need to
-	 * treat it special
-	 */
-	if (list_first_entry(&pipe->transactions, typeof(*transaction), node) ==
-	    transaction && (pipe->flags & CVMX_USB_PIPE_FLAGS_SCHEDULED)) {
-		union cvmx_usbcx_hccharx usbc_hcchar;
-
-		usb->pipe_for_channel[pipe->channel] = NULL;
-		pipe->flags &= ~CVMX_USB_PIPE_FLAGS_SCHEDULED;
-
-		CVMX_SYNCW;
-
-		usbc_hcchar.u32 = cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_HCCHARX(pipe->channel, usb->index));
-		/*
-		 * If the channel isn't enabled then the transaction already
-		 * completed.
-		 */
-		if (usbc_hcchar.s.chena) {
-			usbc_hcchar.s.chdis = 1;
-			cvmx_usb_write_csr32(usb,
-					     CVMX_USBCX_HCCHARX(pipe->channel,
-								usb->index),
-					     usbc_hcchar.u32);
-		}
-	}
-	cvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_CANCEL);
-	return 0;
-}
-
-/**
- * Cancel all outstanding requests in a pipe. Logically all this
- * does is call cvmx_usb_cancel() in a loop.
- *
- * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @pipe:	 Pipe to cancel requests in.
- *
- * Returns: 0 or a negative error code.
- */
-static int cvmx_usb_cancel_all(struct octeon_hcd *usb,
-			       struct cvmx_usb_pipe *pipe)
-{
-	struct cvmx_usb_transaction *transaction, *next;
-
-	/* Simply loop through and attempt to cancel each transaction */
-	list_for_each_entry_safe(transaction, next, &pipe->transactions, node) {
-		int result = cvmx_usb_cancel(usb, pipe, transaction);
-
-		if (unlikely(result != 0))
-			return result;
-	}
-	return 0;
-}
-
-/**
- * Close a pipe created with cvmx_usb_open_pipe().
- *
- * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @pipe:	 Pipe to close.
- *
- * Returns: 0 or a negative error code. EBUSY is returned if the pipe has
- *	    outstanding transfers.
- */
-static int cvmx_usb_close_pipe(struct octeon_hcd *usb,
-			       struct cvmx_usb_pipe *pipe)
-{
-	/* Fail if the pipe has pending transactions */
-	if (!list_empty(&pipe->transactions))
-		return -EBUSY;
-
-	list_del(&pipe->node);
-	kfree(pipe);
-
-	return 0;
-}
-
-/**
- * Get the current USB protocol level frame number. The frame
- * number is always in the range of 0-0x7ff.
- *
- * @usb: USB device state populated by cvmx_usb_initialize().
- *
- * Returns: USB frame number
- */
-static int cvmx_usb_get_frame_number(struct octeon_hcd *usb)
-{
-	union cvmx_usbcx_hfnum usbc_hfnum;
-
-	usbc_hfnum.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
-
-	return usbc_hfnum.s.frnum;
-}
-
-static void cvmx_usb_transfer_control(struct octeon_hcd *usb,
-				      struct cvmx_usb_pipe *pipe,
-				      struct cvmx_usb_transaction *transaction,
-				      union cvmx_usbcx_hccharx usbc_hcchar,
-				      int buffer_space_left,
-				      int bytes_in_last_packet)
-{
-	switch (transaction->stage) {
-	case CVMX_USB_STAGE_NON_CONTROL:
-	case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
-		/* This should be impossible */
-		cvmx_usb_complete(usb, pipe, transaction,
-				  CVMX_USB_STATUS_ERROR);
-		break;
-	case CVMX_USB_STAGE_SETUP:
-		pipe->pid_toggle = 1;
-		if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-			transaction->stage =
-				CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE;
-		} else {
-			struct usb_ctrlrequest *header =
-				cvmx_phys_to_ptr(transaction->control_header);
-			if (header->wLength)
-				transaction->stage = CVMX_USB_STAGE_DATA;
-			else
-				transaction->stage = CVMX_USB_STAGE_STATUS;
-		}
-		break;
-	case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
-		{
-			struct usb_ctrlrequest *header =
-				cvmx_phys_to_ptr(transaction->control_header);
-			if (header->wLength)
-				transaction->stage = CVMX_USB_STAGE_DATA;
-			else
-				transaction->stage = CVMX_USB_STAGE_STATUS;
-		}
-		break;
-	case CVMX_USB_STAGE_DATA:
-		if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-			transaction->stage = CVMX_USB_STAGE_DATA_SPLIT_COMPLETE;
-			/*
-			 * For setup OUT data that are splits,
-			 * the hardware doesn't appear to count
-			 * transferred data. Here we manually
-			 * update the data transferred
-			 */
-			if (!usbc_hcchar.s.epdir) {
-				if (buffer_space_left < pipe->max_packet)
-					transaction->actual_bytes +=
-						buffer_space_left;
-				else
-					transaction->actual_bytes +=
-						pipe->max_packet;
-			}
-		} else if ((buffer_space_left == 0) ||
-			   (bytes_in_last_packet < pipe->max_packet)) {
-			pipe->pid_toggle = 1;
-			transaction->stage = CVMX_USB_STAGE_STATUS;
-		}
-		break;
-	case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
-		if ((buffer_space_left == 0) ||
-		    (bytes_in_last_packet < pipe->max_packet)) {
-			pipe->pid_toggle = 1;
-			transaction->stage = CVMX_USB_STAGE_STATUS;
-		} else {
-			transaction->stage = CVMX_USB_STAGE_DATA;
-		}
-		break;
-	case CVMX_USB_STAGE_STATUS:
-		if (cvmx_usb_pipe_needs_split(usb, pipe))
-			transaction->stage =
-				CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;
-		else
-			cvmx_usb_complete(usb, pipe, transaction,
-					  CVMX_USB_STATUS_OK);
-		break;
-	case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
-		cvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_OK);
-		break;
-	}
-}
-
-static void cvmx_usb_transfer_bulk(struct octeon_hcd *usb,
-				   struct cvmx_usb_pipe *pipe,
-				   struct cvmx_usb_transaction *transaction,
-				   union cvmx_usbcx_hcintx usbc_hcint,
-				   int buffer_space_left,
-				   int bytes_in_last_packet)
-{
-	/*
-	 * The only time a bulk transfer isn't complete when it finishes with
-	 * an ACK is during a split transaction. For splits we need to continue
-	 * the transfer if more data is needed.
-	 */
-	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-		if (transaction->stage == CVMX_USB_STAGE_NON_CONTROL)
-			transaction->stage =
-				CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
-		else if (buffer_space_left &&
-			 (bytes_in_last_packet == pipe->max_packet))
-			transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
-		else
-			cvmx_usb_complete(usb, pipe, transaction,
-					  CVMX_USB_STATUS_OK);
-	} else {
-		if ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&
-		    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) &&
-		    (usbc_hcint.s.nak))
-			pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
-		if (!buffer_space_left ||
-		    (bytes_in_last_packet < pipe->max_packet))
-			cvmx_usb_complete(usb, pipe, transaction,
-					  CVMX_USB_STATUS_OK);
-	}
-}
-
-static void cvmx_usb_transfer_intr(struct octeon_hcd *usb,
-				   struct cvmx_usb_pipe *pipe,
-				   struct cvmx_usb_transaction *transaction,
-				   int buffer_space_left,
-				   int bytes_in_last_packet)
-{
-	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-		if (transaction->stage == CVMX_USB_STAGE_NON_CONTROL) {
-			transaction->stage =
-				CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
-		} else if (buffer_space_left &&
-			   (bytes_in_last_packet == pipe->max_packet)) {
-			transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
-		} else {
-			pipe->next_tx_frame += pipe->interval;
-			cvmx_usb_complete(usb, pipe, transaction,
-					  CVMX_USB_STATUS_OK);
-		}
-	} else if (!buffer_space_left ||
-		   (bytes_in_last_packet < pipe->max_packet)) {
-		pipe->next_tx_frame += pipe->interval;
-		cvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_OK);
-	}
-}
-
-static void cvmx_usb_transfer_isoc(struct octeon_hcd *usb,
-				   struct cvmx_usb_pipe *pipe,
-				   struct cvmx_usb_transaction *transaction,
-				   int buffer_space_left,
-				   int bytes_in_last_packet,
-				   int bytes_this_transfer)
-{
-	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-		/*
-		 * ISOCHRONOUS OUT splits don't require a complete split stage.
-		 * Instead they use a sequence of begin OUT splits to transfer
-		 * the data 188 bytes at a time. Once the transfer is complete,
-		 * the pipe sleeps until the next schedule interval.
-		 */
-		if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {
-			/*
-			 * If no space left or this wasn't a max size packet
-			 * then this transfer is complete. Otherwise start it
-			 * again to send the next 188 bytes
-			 */
-			if (!buffer_space_left || (bytes_this_transfer < 188)) {
-				pipe->next_tx_frame += pipe->interval;
-				cvmx_usb_complete(usb, pipe, transaction,
-						  CVMX_USB_STATUS_OK);
-			}
-			return;
-		}
-		if (transaction->stage ==
-		    CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE) {
-			/*
-			 * We are in the incoming data phase. Keep getting data
-			 * until we run out of space or get a small packet
-			 */
-			if ((buffer_space_left == 0) ||
-			    (bytes_in_last_packet < pipe->max_packet)) {
-				pipe->next_tx_frame += pipe->interval;
-				cvmx_usb_complete(usb, pipe, transaction,
-						  CVMX_USB_STATUS_OK);
-			}
-		} else {
-			transaction->stage =
-				CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
-		}
-	} else {
-		pipe->next_tx_frame += pipe->interval;
-		cvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_OK);
-	}
-}
-
-/**
- * Poll a channel for status
- *
- * @usb:     USB device
- * @channel: Channel to poll
- *
- * Returns: Zero on success
- */
-static int cvmx_usb_poll_channel(struct octeon_hcd *usb, int channel)
-{
-	struct usb_hcd *hcd = octeon_to_hcd(usb);
-	struct device *dev = hcd->self.controller;
-	union cvmx_usbcx_hcintx usbc_hcint;
-	union cvmx_usbcx_hctsizx usbc_hctsiz;
-	union cvmx_usbcx_hccharx usbc_hcchar;
-	struct cvmx_usb_pipe *pipe;
-	struct cvmx_usb_transaction *transaction;
-	int bytes_this_transfer;
-	int bytes_in_last_packet;
-	int packets_processed;
-	int buffer_space_left;
-
-	/* Read the interrupt status bits for the channel */
-	usbc_hcint.u32 = cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_HCINTX(channel, usb->index));
-
-	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
-		usbc_hcchar.u32 = cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_HCCHARX(channel, usb->index));
-
-		if (usbc_hcchar.s.chena && usbc_hcchar.s.chdis) {
-			/*
-			 * There seems to be a bug in CN31XX which can cause
-			 * interrupt IN transfers to get stuck until we do a
-			 * write of HCCHARX without changing things
-			 */
-			cvmx_usb_write_csr32(usb,
-					     CVMX_USBCX_HCCHARX(channel,
-								usb->index),
-					     usbc_hcchar.u32);
-			return 0;
-		}
-
-		/*
-		 * In non DMA mode the channels don't halt themselves. We need
-		 * to manually disable channels that are left running
-		 */
-		if (!usbc_hcint.s.chhltd) {
-			if (usbc_hcchar.s.chena) {
-				union cvmx_usbcx_hcintmskx hcintmsk;
-				/* Disable all interrupts except CHHLTD */
-				hcintmsk.u32 = 0;
-				hcintmsk.s.chhltdmsk = 1;
-				cvmx_usb_write_csr32(usb,
-						     CVMX_USBCX_HCINTMSKX(channel, usb->index),
-						     hcintmsk.u32);
-				usbc_hcchar.s.chdis = 1;
-				cvmx_usb_write_csr32(usb,
-						     CVMX_USBCX_HCCHARX(channel, usb->index),
-						     usbc_hcchar.u32);
-				return 0;
-			} else if (usbc_hcint.s.xfercompl) {
-				/*
-				 * Successful IN/OUT with transfer complete.
-				 * Channel halt isn't needed.
-				 */
-			} else {
-				dev_err(dev, "USB%d: Channel %d interrupt without halt\n",
-					usb->index, channel);
-				return 0;
-			}
-		}
-	} else {
-		/*
-		 * There is are no interrupts that we need to process when the
-		 * channel is still running
-		 */
-		if (!usbc_hcint.s.chhltd)
-			return 0;
-	}
-
-	/* Disable the channel interrupts now that it is done */
-	cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
-	usb->idle_hardware_channels |= (1 << channel);
-
-	/* Make sure this channel is tied to a valid pipe */
-	pipe = usb->pipe_for_channel[channel];
-	prefetch(pipe);
-	if (!pipe)
-		return 0;
-	transaction = list_first_entry(&pipe->transactions,
-				       typeof(*transaction),
-				       node);
-	prefetch(transaction);
-
-	/*
-	 * Disconnect this pipe from the HW channel. Later the schedule
-	 * function will figure out which pipe needs to go
-	 */
-	usb->pipe_for_channel[channel] = NULL;
-	pipe->flags &= ~CVMX_USB_PIPE_FLAGS_SCHEDULED;
-
-	/*
-	 * Read the channel config info so we can figure out how much data
-	 * transferred
-	 */
-	usbc_hcchar.u32 = cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_HCCHARX(channel, usb->index));
-	usbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_HCTSIZX(channel, usb->index));
-
-	/*
-	 * Calculating the number of bytes successfully transferred is dependent
-	 * on the transfer direction
-	 */
-	packets_processed = transaction->pktcnt - usbc_hctsiz.s.pktcnt;
-	if (usbc_hcchar.s.epdir) {
-		/*
-		 * IN transactions are easy. For every byte received the
-		 * hardware decrements xfersize. All we need to do is subtract
-		 * the current value of xfersize from its starting value and we
-		 * know how many bytes were written to the buffer
-		 */
-		bytes_this_transfer = transaction->xfersize -
-			usbc_hctsiz.s.xfersize;
-	} else {
-		/*
-		 * OUT transaction don't decrement xfersize. Instead pktcnt is
-		 * decremented on every successful packet send. The hardware
-		 * does this when it receives an ACK, or NYET. If it doesn't
-		 * receive one of these responses pktcnt doesn't change
-		 */
-		bytes_this_transfer = packets_processed * usbc_hcchar.s.mps;
-		/*
-		 * The last packet may not be a full transfer if we didn't have
-		 * enough data
-		 */
-		if (bytes_this_transfer > transaction->xfersize)
-			bytes_this_transfer = transaction->xfersize;
-	}
-	/* Figure out how many bytes were in the last packet of the transfer */
-	if (packets_processed)
-		bytes_in_last_packet = bytes_this_transfer -
-			(packets_processed - 1) * usbc_hcchar.s.mps;
-	else
-		bytes_in_last_packet = bytes_this_transfer;
-
-	/*
-	 * As a special case, setup transactions output the setup header, not
-	 * the user's data. For this reason we don't count setup data as bytes
-	 * transferred
-	 */
-	if ((transaction->stage == CVMX_USB_STAGE_SETUP) ||
-	    (transaction->stage == CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE))
-		bytes_this_transfer = 0;
-
-	/*
-	 * Add the bytes transferred to the running total. It is important that
-	 * bytes_this_transfer doesn't count any data that needs to be
-	 * retransmitted
-	 */
-	transaction->actual_bytes += bytes_this_transfer;
-	if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
-		buffer_space_left = transaction->iso_packets[0].length -
-			transaction->actual_bytes;
-	else
-		buffer_space_left = transaction->buffer_length -
-			transaction->actual_bytes;
-
-	/*
-	 * We need to remember the PID toggle state for the next transaction.
-	 * The hardware already updated it for the next transaction
-	 */
-	pipe->pid_toggle = !(usbc_hctsiz.s.pid == 0);
-
-	/*
-	 * For high speed bulk out, assume the next transaction will need to do
-	 * a ping before proceeding. If this isn't true the ACK processing below
-	 * will clear this flag
-	 */
-	if ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&
-	    (pipe->transfer_type == CVMX_USB_TRANSFER_BULK) &&
-	    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT))
-		pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
-
-	if (WARN_ON_ONCE(bytes_this_transfer < 0)) {
-		/*
-		 * In some rare cases the DMA engine seems to get stuck and
-		 * keeps substracting same byte count over and over again. In
-		 * such case we just need to fail every transaction.
-		 */
-		cvmx_usb_complete(usb, pipe, transaction,
-				  CVMX_USB_STATUS_ERROR);
-		return 0;
-	}
-
-	if (usbc_hcint.s.stall) {
-		/*
-		 * STALL as a response means this transaction cannot be
-		 * completed because the device can't process transactions. Tell
-		 * the user. Any data that was transferred will be counted on
-		 * the actual bytes transferred
-		 */
-		pipe->pid_toggle = 0;
-		cvmx_usb_complete(usb, pipe, transaction,
-				  CVMX_USB_STATUS_STALL);
-	} else if (usbc_hcint.s.xacterr) {
-		/*
-		 * XactErr as a response means the device signaled
-		 * something wrong with the transfer. For example, PID
-		 * toggle errors cause these.
-		 */
-		cvmx_usb_complete(usb, pipe, transaction,
-				  CVMX_USB_STATUS_XACTERR);
-	} else if (usbc_hcint.s.bblerr) {
-		/* Babble Error (BblErr) */
-		cvmx_usb_complete(usb, pipe, transaction,
-				  CVMX_USB_STATUS_BABBLEERR);
-	} else if (usbc_hcint.s.datatglerr) {
-		/* Data toggle error */
-		cvmx_usb_complete(usb, pipe, transaction,
-				  CVMX_USB_STATUS_DATATGLERR);
-	} else if (usbc_hcint.s.nyet) {
-		/*
-		 * NYET as a response is only allowed in three cases: as a
-		 * response to a ping, as a response to a split transaction, and
-		 * as a response to a bulk out. The ping case is handled by
-		 * hardware, so we only have splits and bulk out
-		 */
-		if (!cvmx_usb_pipe_needs_split(usb, pipe)) {
-			transaction->retries = 0;
-			/*
-			 * If there is more data to go then we need to try
-			 * again. Otherwise this transaction is complete
-			 */
-			if ((buffer_space_left == 0) ||
-			    (bytes_in_last_packet < pipe->max_packet))
-				cvmx_usb_complete(usb, pipe,
-						  transaction,
-						  CVMX_USB_STATUS_OK);
-		} else {
-			/*
-			 * Split transactions retry the split complete 4 times
-			 * then rewind to the start split and do the entire
-			 * transactions again
-			 */
-			transaction->retries++;
-			if ((transaction->retries & 0x3) == 0) {
-				/*
-				 * Rewind to the beginning of the transaction by
-				 * anding off the split complete bit
-				 */
-				transaction->stage &= ~1;
-				pipe->split_sc_frame = -1;
-			}
-		}
-	} else if (usbc_hcint.s.ack) {
-		transaction->retries = 0;
-		/*
-		 * The ACK bit can only be checked after the other error bits.
-		 * This is because a multi packet transfer may succeed in a
-		 * number of packets and then get a different response on the
-		 * last packet. In this case both ACK and the last response bit
-		 * will be set. If none of the other response bits is set, then
-		 * the last packet must have been an ACK
-		 *
-		 * Since we got an ACK, we know we don't need to do a ping on
-		 * this pipe
-		 */
-		pipe->flags &= ~CVMX_USB_PIPE_FLAGS_NEED_PING;
-
-		switch (transaction->type) {
-		case CVMX_USB_TRANSFER_CONTROL:
-			cvmx_usb_transfer_control(usb, pipe, transaction,
-						  usbc_hcchar,
-						  buffer_space_left,
-						  bytes_in_last_packet);
-			break;
-		case CVMX_USB_TRANSFER_BULK:
-			cvmx_usb_transfer_bulk(usb, pipe, transaction,
-					       usbc_hcint, buffer_space_left,
-					       bytes_in_last_packet);
-			break;
-		case CVMX_USB_TRANSFER_INTERRUPT:
-			cvmx_usb_transfer_intr(usb, pipe, transaction,
-					       buffer_space_left,
-					       bytes_in_last_packet);
-			break;
-		case CVMX_USB_TRANSFER_ISOCHRONOUS:
-			cvmx_usb_transfer_isoc(usb, pipe, transaction,
-					       buffer_space_left,
-					       bytes_in_last_packet,
-					       bytes_this_transfer);
-			break;
-		}
-	} else if (usbc_hcint.s.nak) {
-		/*
-		 * If this was a split then clear our split in progress marker.
-		 */
-		if (usb->active_split == transaction)
-			usb->active_split = NULL;
-		/*
-		 * NAK as a response means the device couldn't accept the
-		 * transaction, but it should be retried in the future. Rewind
-		 * to the beginning of the transaction by anding off the split
-		 * complete bit. Retry in the next interval
-		 */
-		transaction->retries = 0;
-		transaction->stage &= ~1;
-		pipe->next_tx_frame += pipe->interval;
-		if (pipe->next_tx_frame < usb->frame_number)
-			pipe->next_tx_frame = usb->frame_number +
-				pipe->interval -
-				(usb->frame_number - pipe->next_tx_frame) %
-				pipe->interval;
-	} else {
-		struct cvmx_usb_port_status port;
-
-		port = cvmx_usb_get_status(usb);
-		if (port.port_enabled) {
-			/* We'll retry the exact same transaction again */
-			transaction->retries++;
-		} else {
-			/*
-			 * We get channel halted interrupts with no result bits
-			 * sets when the cable is unplugged
-			 */
-			cvmx_usb_complete(usb, pipe, transaction,
-					  CVMX_USB_STATUS_ERROR);
-		}
-	}
-	return 0;
-}
-
-static void octeon_usb_port_callback(struct octeon_hcd *usb)
-{
-	spin_unlock(&usb->lock);
-	usb_hcd_poll_rh_status(octeon_to_hcd(usb));
-	spin_lock(&usb->lock);
-}
-
-/**
- * Poll the USB block for status and call all needed callback
- * handlers. This function is meant to be called in the interrupt
- * handler for the USB controller. It can also be called
- * periodically in a loop for non-interrupt based operation.
- *
- * @usb: USB device state populated by cvmx_usb_initialize().
- *
- * Returns: 0 or a negative error code.
- */
-static int cvmx_usb_poll(struct octeon_hcd *usb)
-{
-	union cvmx_usbcx_hfnum usbc_hfnum;
-	union cvmx_usbcx_gintsts usbc_gintsts;
-
-	prefetch_range(usb, sizeof(*usb));
-
-	/* Update the frame counter */
-	usbc_hfnum.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
-	if ((usb->frame_number & 0x3fff) > usbc_hfnum.s.frnum)
-		usb->frame_number += 0x4000;
-	usb->frame_number &= ~0x3fffull;
-	usb->frame_number |= usbc_hfnum.s.frnum;
-
-	/* Read the pending interrupts */
-	usbc_gintsts.u32 = cvmx_usb_read_csr32(usb,
-					       CVMX_USBCX_GINTSTS(usb->index));
-
-	/* Clear the interrupts now that we know about them */
-	cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index),
-			     usbc_gintsts.u32);
-
-	if (usbc_gintsts.s.rxflvl) {
-		/*
-		 * RxFIFO Non-Empty (RxFLvl)
-		 * Indicates that there is at least one packet pending to be
-		 * read from the RxFIFO.
-		 *
-		 * In DMA mode this is handled by hardware
-		 */
-		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
-			cvmx_usb_poll_rx_fifo(usb);
-	}
-	if (usbc_gintsts.s.ptxfemp || usbc_gintsts.s.nptxfemp) {
-		/* Fill the Tx FIFOs when not in DMA mode */
-		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
-			cvmx_usb_poll_tx_fifo(usb);
-	}
-	if (usbc_gintsts.s.disconnint || usbc_gintsts.s.prtint) {
-		union cvmx_usbcx_hprt usbc_hprt;
-		/*
-		 * Disconnect Detected Interrupt (DisconnInt)
-		 * Asserted when a device disconnect is detected.
-		 *
-		 * Host Port Interrupt (PrtInt)
-		 * The core sets this bit to indicate a change in port status of
-		 * one of the O2P USB core ports in Host mode. The application
-		 * must read the Host Port Control and Status (HPRT) register to
-		 * determine the exact event that caused this interrupt. The
-		 * application must clear the appropriate status bit in the Host
-		 * Port Control and Status register to clear this bit.
-		 *
-		 * Call the user's port callback
-		 */
-		octeon_usb_port_callback(usb);
-		/* Clear the port change bits */
-		usbc_hprt.u32 =
-			cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
-		usbc_hprt.s.prtena = 0;
-		cvmx_usb_write_csr32(usb, CVMX_USBCX_HPRT(usb->index),
-				     usbc_hprt.u32);
-	}
-	if (usbc_gintsts.s.hchint) {
-		/*
-		 * Host Channels Interrupt (HChInt)
-		 * The core sets this bit to indicate that an interrupt is
-		 * pending on one of the channels of the core (in Host mode).
-		 * The application must read the Host All Channels Interrupt
-		 * (HAINT) register to determine the exact number of the channel
-		 * on which the interrupt occurred, and then read the
-		 * corresponding Host Channel-n Interrupt (HCINTn) register to
-		 * determine the exact cause of the interrupt. The application
-		 * must clear the appropriate status bit in the HCINTn register
-		 * to clear this bit.
-		 */
-		union cvmx_usbcx_haint usbc_haint;
-
-		usbc_haint.u32 = cvmx_usb_read_csr32(usb,
-					CVMX_USBCX_HAINT(usb->index));
-		while (usbc_haint.u32) {
-			int channel;
-
-			channel = __fls(usbc_haint.u32);
-			cvmx_usb_poll_channel(usb, channel);
-			usbc_haint.u32 ^= 1 << channel;
-		}
-	}
-
-	cvmx_usb_schedule(usb, usbc_gintsts.s.sof);
-
-	return 0;
-}
-
-/* convert between an HCD pointer and the corresponding struct octeon_hcd */
-static inline struct octeon_hcd *hcd_to_octeon(struct usb_hcd *hcd)
-{
-	return (struct octeon_hcd *)(hcd->hcd_priv);
-}
-
-static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
-{
-	struct octeon_hcd *usb = hcd_to_octeon(hcd);
-	unsigned long flags;
-
-	spin_lock_irqsave(&usb->lock, flags);
-	cvmx_usb_poll(usb);
-	spin_unlock_irqrestore(&usb->lock, flags);
-	return IRQ_HANDLED;
-}
-
-static int octeon_usb_start(struct usb_hcd *hcd)
-{
-	hcd->state = HC_STATE_RUNNING;
-	return 0;
-}
-
-static void octeon_usb_stop(struct usb_hcd *hcd)
-{
-	hcd->state = HC_STATE_HALT;
-}
-
-static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
-{
-	struct octeon_hcd *usb = hcd_to_octeon(hcd);
-
-	return cvmx_usb_get_frame_number(usb);
-}
-
-static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
-				  struct urb *urb,
-				  gfp_t mem_flags)
-{
-	struct octeon_hcd *usb = hcd_to_octeon(hcd);
-	struct device *dev = hcd->self.controller;
-	struct cvmx_usb_transaction *transaction = NULL;
-	struct cvmx_usb_pipe *pipe;
-	unsigned long flags;
-	struct cvmx_usb_iso_packet *iso_packet;
-	struct usb_host_endpoint *ep = urb->ep;
-	int rc;
-
-	urb->status = 0;
-	spin_lock_irqsave(&usb->lock, flags);
-
-	rc = usb_hcd_link_urb_to_ep(hcd, urb);
-	if (rc) {
-		spin_unlock_irqrestore(&usb->lock, flags);
-		return rc;
-	}
-
-	if (!ep->hcpriv) {
-		enum cvmx_usb_transfer transfer_type;
-		enum cvmx_usb_speed speed;
-		int split_device = 0;
-		int split_port = 0;
-
-		switch (usb_pipetype(urb->pipe)) {
-		case PIPE_ISOCHRONOUS:
-			transfer_type = CVMX_USB_TRANSFER_ISOCHRONOUS;
-			break;
-		case PIPE_INTERRUPT:
-			transfer_type = CVMX_USB_TRANSFER_INTERRUPT;
-			break;
-		case PIPE_CONTROL:
-			transfer_type = CVMX_USB_TRANSFER_CONTROL;
-			break;
-		default:
-			transfer_type = CVMX_USB_TRANSFER_BULK;
-			break;
-		}
-		switch (urb->dev->speed) {
-		case USB_SPEED_LOW:
-			speed = CVMX_USB_SPEED_LOW;
-			break;
-		case USB_SPEED_FULL:
-			speed = CVMX_USB_SPEED_FULL;
-			break;
-		default:
-			speed = CVMX_USB_SPEED_HIGH;
-			break;
-		}
-		/*
-		 * For slow devices on high speed ports we need to find the hub
-		 * that does the speed translation so we know where to send the
-		 * split transactions.
-		 */
-		if (speed != CVMX_USB_SPEED_HIGH) {
-			/*
-			 * Start at this device and work our way up the usb
-			 * tree.
-			 */
-			struct usb_device *dev = urb->dev;
-
-			while (dev->parent) {
-				/*
-				 * If our parent is high speed then he'll
-				 * receive the splits.
-				 */
-				if (dev->parent->speed == USB_SPEED_HIGH) {
-					split_device = dev->parent->devnum;
-					split_port = dev->portnum;
-					break;
-				}
-				/*
-				 * Move up the tree one level. If we make it all
-				 * the way up the tree, then the port must not
-				 * be in high speed mode and we don't need a
-				 * split.
-				 */
-				dev = dev->parent;
-			}
-		}
-		pipe = cvmx_usb_open_pipe(usb, usb_pipedevice(urb->pipe),
-					  usb_pipeendpoint(urb->pipe), speed,
-					  le16_to_cpu(ep->desc.wMaxPacketSize)
-					  & 0x7ff,
-					  transfer_type,
-					  usb_pipein(urb->pipe) ?
-						CVMX_USB_DIRECTION_IN :
-						CVMX_USB_DIRECTION_OUT,
-					  urb->interval,
-					  (le16_to_cpu(ep->desc.wMaxPacketSize)
-					   >> 11) & 0x3,
-					  split_device, split_port);
-		if (!pipe) {
-			usb_hcd_unlink_urb_from_ep(hcd, urb);
-			spin_unlock_irqrestore(&usb->lock, flags);
-			dev_dbg(dev, "Failed to create pipe\n");
-			return -ENOMEM;
-		}
-		ep->hcpriv = pipe;
-	} else {
-		pipe = ep->hcpriv;
-	}
-
-	switch (usb_pipetype(urb->pipe)) {
-	case PIPE_ISOCHRONOUS:
-		dev_dbg(dev, "Submit isochronous to %d.%d\n",
-			usb_pipedevice(urb->pipe),
-			usb_pipeendpoint(urb->pipe));
-		/*
-		 * Allocate a structure to use for our private list of
-		 * isochronous packets.
-		 */
-		iso_packet = kmalloc_array(urb->number_of_packets,
-					   sizeof(struct cvmx_usb_iso_packet),
-					   GFP_ATOMIC);
-		if (iso_packet) {
-			int i;
-			/* Fill the list with the data from the URB */
-			for (i = 0; i < urb->number_of_packets; i++) {
-				iso_packet[i].offset =
-					urb->iso_frame_desc[i].offset;
-				iso_packet[i].length =
-					urb->iso_frame_desc[i].length;
-				iso_packet[i].status = CVMX_USB_STATUS_ERROR;
-			}
-			/*
-			 * Store a pointer to the list in the URB setup_packet
-			 * field. We know this currently isn't being used and
-			 * this saves us a bunch of logic.
-			 */
-			urb->setup_packet = (char *)iso_packet;
-			transaction = cvmx_usb_submit_isochronous(usb,
-								  pipe, urb);
-			/*
-			 * If submit failed we need to free our private packet
-			 * list.
-			 */
-			if (!transaction) {
-				urb->setup_packet = NULL;
-				kfree(iso_packet);
-			}
-		}
-		break;
-	case PIPE_INTERRUPT:
-		dev_dbg(dev, "Submit interrupt to %d.%d\n",
-			usb_pipedevice(urb->pipe),
-			usb_pipeendpoint(urb->pipe));
-		transaction = cvmx_usb_submit_interrupt(usb, pipe, urb);
-		break;
-	case PIPE_CONTROL:
-		dev_dbg(dev, "Submit control to %d.%d\n",
-			usb_pipedevice(urb->pipe),
-			usb_pipeendpoint(urb->pipe));
-		transaction = cvmx_usb_submit_control(usb, pipe, urb);
-		break;
-	case PIPE_BULK:
-		dev_dbg(dev, "Submit bulk to %d.%d\n",
-			usb_pipedevice(urb->pipe),
-			usb_pipeendpoint(urb->pipe));
-		transaction = cvmx_usb_submit_bulk(usb, pipe, urb);
-		break;
-	}
-	if (!transaction) {
-		usb_hcd_unlink_urb_from_ep(hcd, urb);
-		spin_unlock_irqrestore(&usb->lock, flags);
-		dev_dbg(dev, "Failed to submit\n");
-		return -ENOMEM;
-	}
-	urb->hcpriv = transaction;
-	spin_unlock_irqrestore(&usb->lock, flags);
-	return 0;
-}
-
-static int octeon_usb_urb_dequeue(struct usb_hcd *hcd,
-				  struct urb *urb,
-				  int status)
-{
-	struct octeon_hcd *usb = hcd_to_octeon(hcd);
-	unsigned long flags;
-	int rc;
-
-	if (!urb->dev)
-		return -EINVAL;
-
-	spin_lock_irqsave(&usb->lock, flags);
-
-	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
-	if (rc)
-		goto out;
-
-	urb->status = status;
-	cvmx_usb_cancel(usb, urb->ep->hcpriv, urb->hcpriv);
-
-out:
-	spin_unlock_irqrestore(&usb->lock, flags);
-
-	return rc;
-}
-
-static void octeon_usb_endpoint_disable(struct usb_hcd *hcd,
-					struct usb_host_endpoint *ep)
-{
-	struct device *dev = hcd->self.controller;
-
-	if (ep->hcpriv) {
-		struct octeon_hcd *usb = hcd_to_octeon(hcd);
-		struct cvmx_usb_pipe *pipe = ep->hcpriv;
-		unsigned long flags;
-
-		spin_lock_irqsave(&usb->lock, flags);
-		cvmx_usb_cancel_all(usb, pipe);
-		if (cvmx_usb_close_pipe(usb, pipe))
-			dev_dbg(dev, "Closing pipe %p failed\n", pipe);
-		spin_unlock_irqrestore(&usb->lock, flags);
-		ep->hcpriv = NULL;
-	}
-}
-
-static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
-{
-	struct octeon_hcd *usb = hcd_to_octeon(hcd);
-	struct cvmx_usb_port_status port_status;
-	unsigned long flags;
-
-	spin_lock_irqsave(&usb->lock, flags);
-	port_status = cvmx_usb_get_status(usb);
-	spin_unlock_irqrestore(&usb->lock, flags);
-	buf[0] = port_status.connect_change << 1;
-
-	return buf[0] != 0;
-}
-
-static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
-				  u16 wIndex, char *buf, u16 wLength)
-{
-	struct octeon_hcd *usb = hcd_to_octeon(hcd);
-	struct device *dev = hcd->self.controller;
-	struct cvmx_usb_port_status usb_port_status;
-	int port_status;
-	struct usb_hub_descriptor *desc;
-	unsigned long flags;
-
-	switch (typeReq) {
-	case ClearHubFeature:
-		dev_dbg(dev, "ClearHubFeature\n");
-		switch (wValue) {
-		case C_HUB_LOCAL_POWER:
-		case C_HUB_OVER_CURRENT:
-			/* Nothing required here */
-			break;
-		default:
-			return -EINVAL;
-		}
-		break;
-	case ClearPortFeature:
-		dev_dbg(dev, "ClearPortFeature\n");
-		if (wIndex != 1) {
-			dev_dbg(dev, " INVALID\n");
-			return -EINVAL;
-		}
-
-		switch (wValue) {
-		case USB_PORT_FEAT_ENABLE:
-			dev_dbg(dev, " ENABLE\n");
-			spin_lock_irqsave(&usb->lock, flags);
-			cvmx_usb_disable(usb);
-			spin_unlock_irqrestore(&usb->lock, flags);
-			break;
-		case USB_PORT_FEAT_SUSPEND:
-			dev_dbg(dev, " SUSPEND\n");
-			/* Not supported on Octeon */
-			break;
-		case USB_PORT_FEAT_POWER:
-			dev_dbg(dev, " POWER\n");
-			/* Not supported on Octeon */
-			break;
-		case USB_PORT_FEAT_INDICATOR:
-			dev_dbg(dev, " INDICATOR\n");
-			/* Port inidicator not supported */
-			break;
-		case USB_PORT_FEAT_C_CONNECTION:
-			dev_dbg(dev, " C_CONNECTION\n");
-			/* Clears drivers internal connect status change flag */
-			spin_lock_irqsave(&usb->lock, flags);
-			usb->port_status = cvmx_usb_get_status(usb);
-			spin_unlock_irqrestore(&usb->lock, flags);
-			break;
-		case USB_PORT_FEAT_C_RESET:
-			dev_dbg(dev, " C_RESET\n");
-			/*
-			 * Clears the driver's internal Port Reset Change flag.
-			 */
-			spin_lock_irqsave(&usb->lock, flags);
-			usb->port_status = cvmx_usb_get_status(usb);
-			spin_unlock_irqrestore(&usb->lock, flags);
-			break;
-		case USB_PORT_FEAT_C_ENABLE:
-			dev_dbg(dev, " C_ENABLE\n");
-			/*
-			 * Clears the driver's internal Port Enable/Disable
-			 * Change flag.
-			 */
-			spin_lock_irqsave(&usb->lock, flags);
-			usb->port_status = cvmx_usb_get_status(usb);
-			spin_unlock_irqrestore(&usb->lock, flags);
-			break;
-		case USB_PORT_FEAT_C_SUSPEND:
-			dev_dbg(dev, " C_SUSPEND\n");
-			/*
-			 * Clears the driver's internal Port Suspend Change
-			 * flag, which is set when resume signaling on the host
-			 * port is complete.
-			 */
-			break;
-		case USB_PORT_FEAT_C_OVER_CURRENT:
-			dev_dbg(dev, " C_OVER_CURRENT\n");
-			/* Clears the driver's overcurrent Change flag */
-			spin_lock_irqsave(&usb->lock, flags);
-			usb->port_status = cvmx_usb_get_status(usb);
-			spin_unlock_irqrestore(&usb->lock, flags);
-			break;
-		default:
-			dev_dbg(dev, " UNKNOWN\n");
-			return -EINVAL;
-		}
-		break;
-	case GetHubDescriptor:
-		dev_dbg(dev, "GetHubDescriptor\n");
-		desc = (struct usb_hub_descriptor *)buf;
-		desc->bDescLength = 9;
-		desc->bDescriptorType = 0x29;
-		desc->bNbrPorts = 1;
-		desc->wHubCharacteristics = cpu_to_le16(0x08);
-		desc->bPwrOn2PwrGood = 1;
-		desc->bHubContrCurrent = 0;
-		desc->u.hs.DeviceRemovable[0] = 0;
-		desc->u.hs.DeviceRemovable[1] = 0xff;
-		break;
-	case GetHubStatus:
-		dev_dbg(dev, "GetHubStatus\n");
-		*(__le32 *)buf = 0;
-		break;
-	case GetPortStatus:
-		dev_dbg(dev, "GetPortStatus\n");
-		if (wIndex != 1) {
-			dev_dbg(dev, " INVALID\n");
-			return -EINVAL;
-		}
-
-		spin_lock_irqsave(&usb->lock, flags);
-		usb_port_status = cvmx_usb_get_status(usb);
-		spin_unlock_irqrestore(&usb->lock, flags);
-		port_status = 0;
-
-		if (usb_port_status.connect_change) {
-			port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
-			dev_dbg(dev, " C_CONNECTION\n");
-		}
-
-		if (usb_port_status.port_enabled) {
-			port_status |= (1 << USB_PORT_FEAT_C_ENABLE);
-			dev_dbg(dev, " C_ENABLE\n");
-		}
-
-		if (usb_port_status.connected) {
-			port_status |= (1 << USB_PORT_FEAT_CONNECTION);
-			dev_dbg(dev, " CONNECTION\n");
-		}
-
-		if (usb_port_status.port_enabled) {
-			port_status |= (1 << USB_PORT_FEAT_ENABLE);
-			dev_dbg(dev, " ENABLE\n");
-		}
-
-		if (usb_port_status.port_over_current) {
-			port_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);
-			dev_dbg(dev, " OVER_CURRENT\n");
-		}
-
-		if (usb_port_status.port_powered) {
-			port_status |= (1 << USB_PORT_FEAT_POWER);
-			dev_dbg(dev, " POWER\n");
-		}
-
-		if (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH) {
-			port_status |= USB_PORT_STAT_HIGH_SPEED;
-			dev_dbg(dev, " HIGHSPEED\n");
-		} else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW) {
-			port_status |= (1 << USB_PORT_FEAT_LOWSPEED);
-			dev_dbg(dev, " LOWSPEED\n");
-		}
-
-		*((__le32 *)buf) = cpu_to_le32(port_status);
-		break;
-	case SetHubFeature:
-		dev_dbg(dev, "SetHubFeature\n");
-		/* No HUB features supported */
-		break;
-	case SetPortFeature:
-		dev_dbg(dev, "SetPortFeature\n");
-		if (wIndex != 1) {
-			dev_dbg(dev, " INVALID\n");
-			return -EINVAL;
-		}
-
-		switch (wValue) {
-		case USB_PORT_FEAT_SUSPEND:
-			dev_dbg(dev, " SUSPEND\n");
-			return -EINVAL;
-		case USB_PORT_FEAT_POWER:
-			dev_dbg(dev, " POWER\n");
-			/*
-			 * Program the port power bit to drive VBUS on the USB.
-			 */
-			spin_lock_irqsave(&usb->lock, flags);
-			USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index),
-					cvmx_usbcx_hprt, prtpwr, 1);
-			spin_unlock_irqrestore(&usb->lock, flags);
-			return 0;
-		case USB_PORT_FEAT_RESET:
-			dev_dbg(dev, " RESET\n");
-			spin_lock_irqsave(&usb->lock, flags);
-			cvmx_usb_reset_port(usb);
-			spin_unlock_irqrestore(&usb->lock, flags);
-			return 0;
-		case USB_PORT_FEAT_INDICATOR:
-			dev_dbg(dev, " INDICATOR\n");
-			/* Not supported */
-			break;
-		default:
-			dev_dbg(dev, " UNKNOWN\n");
-			return -EINVAL;
-		}
-		break;
-	default:
-		dev_dbg(dev, "Unknown root hub request\n");
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static const struct hc_driver octeon_hc_driver = {
-	.description		= "Octeon USB",
-	.product_desc		= "Octeon Host Controller",
-	.hcd_priv_size		= sizeof(struct octeon_hcd),
-	.irq			= octeon_usb_irq,
-	.flags			= HCD_MEMORY | HCD_DMA | HCD_USB2,
-	.start			= octeon_usb_start,
-	.stop			= octeon_usb_stop,
-	.urb_enqueue		= octeon_usb_urb_enqueue,
-	.urb_dequeue		= octeon_usb_urb_dequeue,
-	.endpoint_disable	= octeon_usb_endpoint_disable,
-	.get_frame_number	= octeon_usb_get_frame_number,
-	.hub_status_data	= octeon_usb_hub_status_data,
-	.hub_control		= octeon_usb_hub_control,
-	.map_urb_for_dma	= octeon_map_urb_for_dma,
-	.unmap_urb_for_dma	= octeon_unmap_urb_for_dma,
-};
-
-static int octeon_usb_probe(struct platform_device *pdev)
-{
-	int status;
-	int initialize_flags;
-	int usb_num;
-	struct resource *res_mem;
-	struct device_node *usbn_node;
-	int irq = platform_get_irq(pdev, 0);
-	struct device *dev = &pdev->dev;
-	struct octeon_hcd *usb;
-	struct usb_hcd *hcd;
-	u32 clock_rate = 48000000;
-	bool is_crystal_clock = false;
-	const char *clock_type;
-	int i;
-
-	if (!dev->of_node) {
-		dev_err(dev, "Error: empty of_node\n");
-		return -ENXIO;
-	}
-	usbn_node = dev->of_node->parent;
-
-	i = of_property_read_u32(usbn_node,
-				 "clock-frequency", &clock_rate);
-	if (i)
-		i = of_property_read_u32(usbn_node,
-					 "refclk-frequency", &clock_rate);
-	if (i) {
-		dev_err(dev, "No USBN \"clock-frequency\"\n");
-		return -ENXIO;
-	}
-	switch (clock_rate) {
-	case 12000000:
-		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ;
-		break;
-	case 24000000:
-		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ;
-		break;
-	case 48000000:
-		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ;
-		break;
-	default:
-		dev_err(dev, "Illegal USBN \"clock-frequency\" %u\n",
-			clock_rate);
-		return -ENXIO;
-	}
-
-	i = of_property_read_string(usbn_node,
-				    "cavium,refclk-type", &clock_type);
-	if (i)
-		i = of_property_read_string(usbn_node,
-					    "refclk-type", &clock_type);
-
-	if (!i && strcmp("crystal", clock_type) == 0)
-		is_crystal_clock = true;
-
-	if (is_crystal_clock)
-		initialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI;
-	else
-		initialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND;
-
-	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res_mem) {
-		dev_err(dev, "found no memory resource\n");
-		return -ENXIO;
-	}
-	usb_num = (res_mem->start >> 44) & 1;
-
-	if (irq < 0) {
-		/* Defective device tree, but we know how to fix it. */
-		irq_hw_number_t hwirq = usb_num ? (1 << 6) + 17 : 56;
-
-		irq = irq_create_mapping(NULL, hwirq);
-	}
-
-	/*
-	 * Set the DMA mask to 64bits so we get buffers already translated for
-	 * DMA.
-	 */
-	i = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(64));
-	if (i)
-		return i;
-
-	/*
-	 * Only cn52XX and cn56XX have DWC_OTG USB hardware and the
-	 * IOB priority registers.  Under heavy network load USB
-	 * hardware can be starved by the IOB causing a crash.  Give
-	 * it a priority boost if it has been waiting more than 400
-	 * cycles to avoid this situation.
-	 *
-	 * Testing indicates that a cnt_val of 8192 is not sufficient,
-	 * but no failures are seen with 4096.  We choose a value of
-	 * 400 to give a safety factor of 10.
-	 */
-	if (OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX)) {
-		union cvmx_iob_n2c_l2c_pri_cnt pri_cnt;
-
-		pri_cnt.u64 = 0;
-		pri_cnt.s.cnt_enb = 1;
-		pri_cnt.s.cnt_val = 400;
-		cvmx_write_csr(CVMX_IOB_N2C_L2C_PRI_CNT, pri_cnt.u64);
-	}
-
-	hcd = usb_create_hcd(&octeon_hc_driver, dev, dev_name(dev));
-	if (!hcd) {
-		dev_dbg(dev, "Failed to allocate memory for HCD\n");
-		return -1;
-	}
-	hcd->uses_new_polling = 1;
-	usb = (struct octeon_hcd *)hcd->hcd_priv;
-
-	spin_lock_init(&usb->lock);
-
-	usb->init_flags = initialize_flags;
-
-	/* Initialize the USB state structure */
-	usb->index = usb_num;
-	INIT_LIST_HEAD(&usb->idle_pipes);
-	for (i = 0; i < ARRAY_SIZE(usb->active_pipes); i++)
-		INIT_LIST_HEAD(&usb->active_pipes[i]);
-
-	/* Due to an errata, CN31XX doesn't support DMA */
-	if (OCTEON_IS_MODEL(OCTEON_CN31XX)) {
-		usb->init_flags |= CVMX_USB_INITIALIZE_FLAGS_NO_DMA;
-		/* Only use one channel with non DMA */
-		usb->idle_hardware_channels = 0x1;
-	} else if (OCTEON_IS_MODEL(OCTEON_CN5XXX)) {
-		/* CN5XXX have an errata with channel 3 */
-		usb->idle_hardware_channels = 0xf7;
-	} else {
-		usb->idle_hardware_channels = 0xff;
-	}
-
-	status = cvmx_usb_initialize(dev, usb);
-	if (status) {
-		dev_dbg(dev, "USB initialization failed with %d\n", status);
-		usb_put_hcd(hcd);
-		return -1;
-	}
-
-	status = usb_add_hcd(hcd, irq, 0);
-	if (status) {
-		dev_dbg(dev, "USB add HCD failed with %d\n", status);
-		usb_put_hcd(hcd);
-		return -1;
-	}
-	device_wakeup_enable(hcd->self.controller);
-
-	dev_info(dev, "Registered HCD for port %d on irq %d\n", usb_num, irq);
-
-	return 0;
-}
-
-static int octeon_usb_remove(struct platform_device *pdev)
-{
-	int status;
-	struct device *dev = &pdev->dev;
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct octeon_hcd *usb = hcd_to_octeon(hcd);
-	unsigned long flags;
-
-	usb_remove_hcd(hcd);
-	spin_lock_irqsave(&usb->lock, flags);
-	status = cvmx_usb_shutdown(usb);
-	spin_unlock_irqrestore(&usb->lock, flags);
-	if (status)
-		dev_dbg(dev, "USB shutdown failed with %d\n", status);
-
-	usb_put_hcd(hcd);
-
-	return 0;
-}
-
-static const struct of_device_id octeon_usb_match[] = {
-	{
-		.compatible = "cavium,octeon-5750-usbc",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, octeon_usb_match);
-
-static struct platform_driver octeon_usb_driver = {
-	.driver = {
-		.name		= "octeon-hcd",
-		.of_match_table = octeon_usb_match,
-	},
-	.probe      = octeon_usb_probe,
-	.remove     = octeon_usb_remove,
-};
-
-static int __init octeon_usb_driver_init(void)
-{
-	if (usb_disabled())
-		return 0;
-
-	return platform_driver_register(&octeon_usb_driver);
-}
-module_init(octeon_usb_driver_init);
-
-static void __exit octeon_usb_driver_exit(void)
-{
-	if (usb_disabled())
-		return;
-
-	platform_driver_unregister(&octeon_usb_driver);
-}
-module_exit(octeon_usb_driver_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Cavium, Inc. <support@cavium.com>");
-MODULE_DESCRIPTION("Cavium Inc. OCTEON USB Host driver.");

commit f3a54e19d466689035276a2eb45032f396570b09
Author: Frank A. Cancio Bello <frank@generalsoftwareinc.com>
Date:   Mon Oct 28 04:21:11 2019 +0000

    staging: octeon-usb: Fix line ending with a '('
    
    checkpatch.pl message:
    "CHECK:OPEN_ENDED_LINE: Lines should not end with a '('"
    
    Signed-off-by: Frank A. Cancio Bello <frank@generalsoftwareinc.com>
    Link: https://lore.kernel.org/r/20191028042111.tzfhugs6f4erohir@linux-kernel-dev
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index a5321cc692c5..582c9187559d 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1836,8 +1836,7 @@ static void cvmx_usb_start_channel(struct octeon_hcd *usb, int channel,
  *
  * Returns: Pipe or NULL if none are ready
  */
-static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(
-		struct octeon_hcd *usb,
+static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(struct octeon_hcd *usb,
 		enum cvmx_usb_transfer xfer_type)
 {
 	struct list_head *list = usb->active_pipes + xfer_type;

commit 7b81cb6bddd2c4f2489506771070924bd0ae9902
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 16 08:24:32 2019 +0200

    usb: add a HCD_DMA flag instead of guestimating DMA capabilities
    
    The usb core is the only major place in the kernel that checks for
    a non-NULL device dma_mask to see if a device is DMA capable.  This
    is generally a bad idea, as all major busses always set up a DMA mask,
    even if the device is not DMA capable - in fact bus layers like PCI
    can't even know if a device is DMA capable at enumeration time.  This
    leads to lots of workaround in HCD drivers, and also prevented us from
    setting up a DMA mask for platform devices by default last time we
    tried.
    
    Replace this guess with an explicit HCD_DMA that is set by drivers that
    appear to have DMA support.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20190816062435.881-4-hch@lst.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index cd2b777073c4..a5321cc692c5 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3512,7 +3512,7 @@ static const struct hc_driver octeon_hc_driver = {
 	.product_desc		= "Octeon Host Controller",
 	.hcd_priv_size		= sizeof(struct octeon_hcd),
 	.irq			= octeon_usb_irq,
-	.flags			= HCD_MEMORY | HCD_USB2,
+	.flags			= HCD_MEMORY | HCD_DMA | HCD_USB2,
 	.start			= octeon_usb_start,
 	.stop			= octeon_usb_stop,
 	.urb_enqueue		= octeon_usb_urb_enqueue,

commit 8fe0260030b8e6c944fceb452a6a36fc1c7daf87
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Wed May 29 18:38:35 2019 +0530

    staging: octeon-usb: Remove return variable
    
    Remove return variable result and return the value directly.
    Issue found using Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index aeec16314e0d..cd2b777073c4 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -521,8 +521,7 @@ static void octeon_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
  */
 static inline u32 cvmx_usb_read_csr32(struct octeon_hcd *usb, u64 address)
 {
-	u32 result = cvmx_read64_uint32(address ^ 4);
-	return result;
+	return cvmx_read64_uint32(address ^ 4);
 }
 
 /**

commit b92f5d83fa1d6d9eacf2f43630cd5f9c30bd3c24
Author: Himadri Pandya <himadri18.07@gmail.com>
Date:   Sat Mar 9 15:01:58 2019 +0530

    staging: octeon-usb: remove unnecessary variable frame_number
    
    Remove unnecessary local variable "frame_number" and its assignments from function
    cvmx_usb_get_frame_numbe. Suggested by Coccinelle.
    
    Signed-off-by: Himadri Pandya <himadri18.07@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 14982b6472a0..aeec16314e0d 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2385,13 +2385,11 @@ static int cvmx_usb_close_pipe(struct octeon_hcd *usb,
  */
 static int cvmx_usb_get_frame_number(struct octeon_hcd *usb)
 {
-	int frame_number;
 	union cvmx_usbcx_hfnum usbc_hfnum;
 
 	usbc_hfnum.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
-	frame_number = usbc_hfnum.s.frnum;
 
-	return frame_number;
+	return usbc_hfnum.s.frnum;
 }
 
 static void cvmx_usb_transfer_control(struct octeon_hcd *usb,

commit b5630e3019b6ddad12aafdbb7b44114690f0a679
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Wed Dec 5 00:19:26 2018 +0200

    staging: octeon-usb: use a helper function to set the DMA mask
    
    Use a helper function to set the DMA mask.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 9c766f5b812f..14982b6472a0 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -50,6 +50,7 @@
 #include <linux/module.h>
 #include <linux/usb/hcd.h>
 #include <linux/prefetch.h>
+#include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
 
 #include <asm/octeon/octeon.h>
@@ -3606,8 +3607,9 @@ static int octeon_usb_probe(struct platform_device *pdev)
 	 * Set the DMA mask to 64bits so we get buffers already translated for
 	 * DMA.
 	 */
-	dev->coherent_dma_mask = ~0;
-	dev->dma_mask = &dev->coherent_dma_mask;
+	i = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(64));
+	if (i)
+		return i;
 
 	/*
 	 * Only cn52XX and cn56XX have DWC_OTG USB hardware and the

commit 009e451c4ff6b7f145eae8db2a90fdbe44e312d4
Author: Igor Stoppa <igor.stoppa@gmail.com>
Date:   Fri Sep 7 20:08:20 2018 +0300

    staging: octeon-hcd: remove unnecessary unlikely()
    
    WARN_ON() already contains an unlikely(), so it's not necessary to
    wrap it into another.
    
    Signed-off-by: Igor Stoppa <igor.stoppa@huawei.com>
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: devel@driverdev.osuosl.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index f188e19c6fc1..9c766f5b812f 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2770,7 +2770,7 @@ static int cvmx_usb_poll_channel(struct octeon_hcd *usb, int channel)
 	    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT))
 		pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
 
-	if (unlikely(WARN_ON_ONCE(bytes_this_transfer < 0))) {
+	if (WARN_ON_ONCE(bytes_this_transfer < 0)) {
 		/*
 		 * In some rare cases the DMA engine seems to get stuck and
 		 * keeps substracting same byte count over and over again. In

commit 3e195a80e096887692f97f5078a8c98e9b2dc39d
Author: Georgios Tsotsos <tsotsos@gmail.com>
Date:   Mon Aug 13 19:25:29 2018 +0300

    Staging: octeon-usb: Replaces CVMX_WAIT_FOR_FIELD32 macro with a function
    
    Replaces CVMX_WAIT_FOR_FIELD32 macro with equivalent function.
    
    Signed-off-by: Georgios Tsotsos <tsotsos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index cff5e790b196..f188e19c6fc1 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -377,29 +377,6 @@ struct octeon_hcd {
 	struct cvmx_usb_tx_fifo nonperiodic;
 };
 
-/* This macro spins on a register waiting for it to reach a condition. */
-#define CVMX_WAIT_FOR_FIELD32(address, _union, cond, timeout_usec)	    \
-	({int result;							    \
-	do {								    \
-		u64 done = cvmx_get_cycle() + (u64)timeout_usec *	    \
-			   octeon_get_clock_rate() / 1000000;		    \
-		union _union c;						    \
-									    \
-		while (1) {						    \
-			c.u32 = cvmx_usb_read_csr32(usb, address);	    \
-									    \
-			if (cond) {					    \
-				result = 0;				    \
-				break;					    \
-			} else if (cvmx_get_cycle() > done) {		    \
-				result = -1;				    \
-				break;					    \
-			} else						    \
-				__delay(100);				    \
-		}							    \
-	} while (0);							    \
-	result; })
-
 /*
  * This macro logically sets a single field in a CSR. It does the sequence
  * read, modify, and write
@@ -593,6 +570,33 @@ static inline int cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)
 	return 0; /* Data0 */
 }
 
+/* Loops through register until txfflsh or rxfflsh become zero.*/
+static int cvmx_wait_tx_rx(struct octeon_hcd *usb, int fflsh_type)
+{
+	int result;
+	u64 address = CVMX_USBCX_GRSTCTL(usb->index);
+	u64 done = cvmx_get_cycle() + 100 *
+		   (u64)octeon_get_clock_rate / 1000000;
+	union cvmx_usbcx_grstctl c;
+
+	while (1) {
+		c.u32 = cvmx_usb_read_csr32(usb, address);
+		if (fflsh_type == 0 && c.s.txfflsh == 0) {
+			result = 0;
+			break;
+		} else if (fflsh_type == 1 && c.s.rxfflsh == 0) {
+			result = 0;
+			break;
+		} else if (cvmx_get_cycle() > done) {
+			result = -1;
+			break;
+		}
+
+		__delay(100);
+	}
+	return result;
+}
+
 static void cvmx_fifo_setup(struct octeon_hcd *usb)
 {
 	union cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;
@@ -634,12 +638,10 @@ static void cvmx_fifo_setup(struct octeon_hcd *usb)
 			cvmx_usbcx_grstctl, txfnum, 0x10);
 	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
 			cvmx_usbcx_grstctl, txfflsh, 1);
-	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			      cvmx_usbcx_grstctl, c.s.txfflsh == 0, 100);
+	cvmx_wait_tx_rx(usb, 0);
 	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
 			cvmx_usbcx_grstctl, rxfflsh, 1);
-	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			      cvmx_usbcx_grstctl, c.s.rxfflsh == 0, 100);
+	cvmx_wait_tx_rx(usb, 1);
 }
 
 /**

commit 4e336dff0dcc250175f0068e45fdebf526f45b91
Author: Georgios Tsotsos <tsotsos@gmail.com>
Date:   Thu Jul 26 18:41:51 2018 +0300

    Staging: octeon-usb: Adding SPDX license identifier
    
    Adding appropriate SPDX-License-Identifier (GPL-2) that were missing
    from code, header and make files.
    
    Signed-off-by: Georgios Tsotsos <tsotsos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index cded30f145aa..cff5e790b196 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive

commit 0590cdfead8cd6319cc58b5dbe8ab9fbaabae131
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Nov 17 09:50:10 2017 +0200

    staging: octeon-usb: use __delay() instead of cvmx_wait()
    
    Commit edf188bee1d9 ("MIPS: Octeon: Remove usage of cvmx_wait()
    everywhere.") deleted cvmx_wait() but forgot to update OCTEON USB
    staging driver. Fix that to allow driver build.
    
    Fixes: edf188bee1d9 ("MIPS: Octeon: Remove usage of cvmx_wait() everywhere.")
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Reviewed-by: James Hogan <jhogan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 068aece25d37..cded30f145aa 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -394,7 +394,7 @@ struct octeon_hcd {
 				result = -1;				    \
 				break;					    \
 			} else						    \
-				cvmx_wait(100);				    \
+				__delay(100);				    \
 		}							    \
 	} while (0);							    \
 	result; })
@@ -774,7 +774,7 @@ static int cvmx_usb_initialize(struct device *dev,
 	usbn_clk_ctl.s.hclk_rst = 1;
 	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
 	/* 2e.  Wait 64 core-clock cycles for HCLK to stabilize */
-	cvmx_wait(64);
+	__delay(64);
 	/*
 	 * 3. Program the power-on reset field in the USBN clock-control
 	 *    register:
@@ -795,7 +795,7 @@ static int cvmx_usb_initialize(struct device *dev,
 	cvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),
 			    usbn_usbp_ctl_status.u64);
 	/* 6. Wait 10 cycles */
-	cvmx_wait(10);
+	__delay(10);
 	/*
 	 * 7. Clear ATE_RESET field in the USBN clock-control register:
 	 *    USBN_USBP_CTL_STATUS[ATE_RESET] = 0

commit 9bbf84e6041fb0d7f67208ec8557473ffcd7157c
Author: Anton Bondarenko <anton.bondarenko.sama@gmail.com>
Date:   Tue May 9 01:33:15 2017 +0200

    staging: octeon-usb: use correct function for hcd cleanup
    
    Use usb_put_hdc to release hdc allocated by usb_create_hcd.
    This is needed to handle sub-allocations and HCD sharing correctly.
    
    Signed-off-by: Anton Bondarenko <anton.bondarenko.sama@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 9a7858a300fd..068aece25d37 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3659,14 +3659,14 @@ static int octeon_usb_probe(struct platform_device *pdev)
 	status = cvmx_usb_initialize(dev, usb);
 	if (status) {
 		dev_dbg(dev, "USB initialization failed with %d\n", status);
-		kfree(hcd);
+		usb_put_hcd(hcd);
 		return -1;
 	}
 
 	status = usb_add_hcd(hcd, irq, 0);
 	if (status) {
 		dev_dbg(dev, "USB add HCD failed with %d\n", status);
-		kfree(hcd);
+		usb_put_hcd(hcd);
 		return -1;
 	}
 	device_wakeup_enable(hcd->self.controller);
@@ -3691,7 +3691,7 @@ static int octeon_usb_remove(struct platform_device *pdev)
 	if (status)
 		dev_dbg(dev, "USB shutdown failed with %d\n", status);
 
-	kfree(hcd);
+	usb_put_hcd(hcd);
 
 	return 0;
 }

commit efb35d12b352c0603fe21a2199ba54aa61d22a54
Author: Rehas Sachdeva <aquannie@gmail.com>
Date:   Wed Sep 21 23:38:00 2016 +0530

    staging: octeon-usb: Remove unnecessary assignment
    
    Remove 'x=a;' from a consecutive double assignment of the form 'x=a; x=b;'.
    Issue detected by the semantic patch found here:
    https://github.com/coccinelle/coccinellery/blob/master/write2/write2.cocci
    
    Signed-off-by: Rehas Sachdeva <aquannie@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 17442b3ed849..9a7858a300fd 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3292,7 +3292,6 @@ static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
 	spin_lock_irqsave(&usb->lock, flags);
 	port_status = cvmx_usb_get_status(usb);
 	spin_unlock_irqrestore(&usb->lock, flags);
-	buf[0] = 0;
 	buf[0] = port_status.connect_change << 1;
 
 	return buf[0] != 0;

commit a00265de2380b0ec9bd59da293bf0b2b0eea937d
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:14:05 2016 +0200

    staging: octeon-usb: avoid an overlong line
    
    Avoid an overlong line.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 298fcaab76ad..17442b3ed849 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2989,8 +2989,8 @@ static int cvmx_usb_poll(struct octeon_hcd *usb)
 		 */
 		octeon_usb_port_callback(usb);
 		/* Clear the port change bits */
-		usbc_hprt.u32 = cvmx_usb_read_csr32(usb,
-						    CVMX_USBCX_HPRT(usb->index));
+		usbc_hprt.u32 =
+			cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
 		usbc_hprt.s.prtena = 0;
 		cvmx_usb_write_csr32(usb, CVMX_USBCX_HPRT(usb->index),
 				     usbc_hprt.u32);

commit d07374987fa3ba0d04e3a425450f87828916665c
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:14:04 2016 +0200

    staging: octeon-usb: move next pipe selection into a separate function
    
    Move next pipe selection into a separate function to avoid deep
    nesting.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 12ea995478b8..298fcaab76ad 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1858,6 +1858,33 @@ static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(
 	return NULL;
 }
 
+static struct cvmx_usb_pipe *cvmx_usb_next_pipe(struct octeon_hcd *usb,
+						int is_sof)
+{
+	struct cvmx_usb_pipe *pipe;
+
+	/* Find a pipe needing service. */
+	if (is_sof) {
+		/*
+		 * Only process periodic pipes on SOF interrupts. This way we
+		 * are sure that the periodic data is sent in the beginning of
+		 * the frame.
+		 */
+		pipe = cvmx_usb_find_ready_pipe(usb,
+						CVMX_USB_TRANSFER_ISOCHRONOUS);
+		if (pipe)
+			return pipe;
+		pipe = cvmx_usb_find_ready_pipe(usb,
+						CVMX_USB_TRANSFER_INTERRUPT);
+		if (pipe)
+			return pipe;
+	}
+	pipe = cvmx_usb_find_ready_pipe(usb, CVMX_USB_TRANSFER_CONTROL);
+	if (pipe)
+		return pipe;
+	return cvmx_usb_find_ready_pipe(usb, CVMX_USB_TRANSFER_BULK);
+}
+
 /**
  * Called whenever a pipe might need to be scheduled to the
  * hardware.
@@ -1897,27 +1924,7 @@ static void cvmx_usb_schedule(struct octeon_hcd *usb, int is_sof)
 		if (unlikely(channel > 7))
 			break;
 
-		/* Find a pipe needing service */
-		pipe = NULL;
-		if (is_sof) {
-			/*
-			 * Only process periodic pipes on SOF interrupts. This
-			 * way we are sure that the periodic data is sent in the
-			 * beginning of the frame
-			 */
-			pipe = cvmx_usb_find_ready_pipe(usb,
-							CVMX_USB_TRANSFER_ISOCHRONOUS);
-			if (likely(!pipe))
-				pipe = cvmx_usb_find_ready_pipe(usb,
-								CVMX_USB_TRANSFER_INTERRUPT);
-		}
-		if (likely(!pipe)) {
-			pipe = cvmx_usb_find_ready_pipe(usb,
-							CVMX_USB_TRANSFER_CONTROL);
-			if (likely(!pipe))
-				pipe = cvmx_usb_find_ready_pipe(usb,
-								CVMX_USB_TRANSFER_BULK);
-		}
+		pipe = cvmx_usb_next_pipe(usb, is_sof);
 		if (!pipe)
 			break;
 

commit dd588994fa24d45e5d4e37cc679140d2d24fd831
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:14:03 2016 +0200

    staging: octeon-usb: move isoc transfer handling into separate function
    
    Move isochronous transfer handling into a separate function to
    avoid deep indentation.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 644a7e8654fc..12ea995478b8 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2526,6 +2526,55 @@ static void cvmx_usb_transfer_intr(struct octeon_hcd *usb,
 	}
 }
 
+static void cvmx_usb_transfer_isoc(struct octeon_hcd *usb,
+				   struct cvmx_usb_pipe *pipe,
+				   struct cvmx_usb_transaction *transaction,
+				   int buffer_space_left,
+				   int bytes_in_last_packet,
+				   int bytes_this_transfer)
+{
+	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+		/*
+		 * ISOCHRONOUS OUT splits don't require a complete split stage.
+		 * Instead they use a sequence of begin OUT splits to transfer
+		 * the data 188 bytes at a time. Once the transfer is complete,
+		 * the pipe sleeps until the next schedule interval.
+		 */
+		if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {
+			/*
+			 * If no space left or this wasn't a max size packet
+			 * then this transfer is complete. Otherwise start it
+			 * again to send the next 188 bytes
+			 */
+			if (!buffer_space_left || (bytes_this_transfer < 188)) {
+				pipe->next_tx_frame += pipe->interval;
+				cvmx_usb_complete(usb, pipe, transaction,
+						  CVMX_USB_STATUS_OK);
+			}
+			return;
+		}
+		if (transaction->stage ==
+		    CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE) {
+			/*
+			 * We are in the incoming data phase. Keep getting data
+			 * until we run out of space or get a small packet
+			 */
+			if ((buffer_space_left == 0) ||
+			    (bytes_in_last_packet < pipe->max_packet)) {
+				pipe->next_tx_frame += pipe->interval;
+				cvmx_usb_complete(usb, pipe, transaction,
+						  CVMX_USB_STATUS_OK);
+			}
+		} else {
+			transaction->stage =
+				CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
+		}
+	} else {
+		pipe->next_tx_frame += pipe->interval;
+		cvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_OK);
+	}
+}
+
 /**
  * Poll a channel for status
  *
@@ -2815,59 +2864,10 @@ static int cvmx_usb_poll_channel(struct octeon_hcd *usb, int channel)
 					       bytes_in_last_packet);
 			break;
 		case CVMX_USB_TRANSFER_ISOCHRONOUS:
-			if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-				/*
-				 * ISOCHRONOUS OUT splits don't require a
-				 * complete split stage. Instead they use a
-				 * sequence of begin OUT splits to transfer the
-				 * data 188 bytes at a time. Once the transfer
-				 * is complete, the pipe sleeps until the next
-				 * schedule interval
-				 */
-				if (pipe->transfer_dir ==
-				    CVMX_USB_DIRECTION_OUT) {
-					/*
-					 * If no space left or this wasn't a max
-					 * size packet then this transfer is
-					 * complete. Otherwise start it again to
-					 * send the next 188 bytes
-					 */
-					if (!buffer_space_left ||
-					    (bytes_this_transfer < 188)) {
-						pipe->next_tx_frame +=
-							pipe->interval;
-						cvmx_usb_complete(usb, pipe,
-								  transaction,
-								  CVMX_USB_STATUS_OK);
-					}
-				} else {
-					if (transaction->stage ==
-					    CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE) {
-						/*
-						 * We are in the incoming data
-						 * phase. Keep getting data
-						 * until we run out of space or
-						 * get a small packet
-						 */
-						if ((buffer_space_left == 0) ||
-						    (bytes_in_last_packet <
-						     pipe->max_packet)) {
-							pipe->next_tx_frame +=
-								pipe->interval;
-							cvmx_usb_complete(usb,
-									  pipe,
-									  transaction,
-									  CVMX_USB_STATUS_OK);
-						}
-					} else
-						transaction->stage =
-							CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
-				}
-			} else {
-				pipe->next_tx_frame += pipe->interval;
-				cvmx_usb_complete(usb, pipe, transaction,
-						  CVMX_USB_STATUS_OK);
-			}
+			cvmx_usb_transfer_isoc(usb, pipe, transaction,
+					       buffer_space_left,
+					       bytes_in_last_packet,
+					       bytes_this_transfer);
 			break;
 		}
 	} else if (usbc_hcint.s.nak) {

commit dfce62674cfb72b111e13a7c0a607e97f816247f
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:14:02 2016 +0200

    staging: octeon-usb: move interrupt transfer handling into separate function
    
    Move bulk transfer handling into a separate function to avoid
    deep indentation.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index d8c032f1d919..644a7e8654fc 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2501,6 +2501,31 @@ static void cvmx_usb_transfer_bulk(struct octeon_hcd *usb,
 	}
 }
 
+static void cvmx_usb_transfer_intr(struct octeon_hcd *usb,
+				   struct cvmx_usb_pipe *pipe,
+				   struct cvmx_usb_transaction *transaction,
+				   int buffer_space_left,
+				   int bytes_in_last_packet)
+{
+	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+		if (transaction->stage == CVMX_USB_STAGE_NON_CONTROL) {
+			transaction->stage =
+				CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
+		} else if (buffer_space_left &&
+			   (bytes_in_last_packet == pipe->max_packet)) {
+			transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+		} else {
+			pipe->next_tx_frame += pipe->interval;
+			cvmx_usb_complete(usb, pipe, transaction,
+					  CVMX_USB_STATUS_OK);
+		}
+	} else if (!buffer_space_left ||
+		   (bytes_in_last_packet < pipe->max_packet)) {
+		pipe->next_tx_frame += pipe->interval;
+		cvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_OK);
+	}
+}
+
 /**
  * Poll a channel for status
  *
@@ -2785,52 +2810,9 @@ static int cvmx_usb_poll_channel(struct octeon_hcd *usb, int channel)
 					       bytes_in_last_packet);
 			break;
 		case CVMX_USB_TRANSFER_INTERRUPT:
-			/*
-			 * The only time a bulk transfer isn't complete when it
-			 * finishes with an ACK is during a split transaction.
-			 * For splits we need to continue the transfer if more
-			 * data is needed
-			 */
-			if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-				if (transaction->stage ==
-				    CVMX_USB_STAGE_NON_CONTROL) {
-					transaction->stage =
-						CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
-				} else if (buffer_space_left &&
-					   (bytes_in_last_packet ==
-					   pipe->max_packet)) {
-					transaction->stage =
-						CVMX_USB_STAGE_NON_CONTROL;
-				} else {
-					if (transaction->type ==
-					    CVMX_USB_TRANSFER_INTERRUPT)
-						pipe->next_tx_frame +=
-							pipe->interval;
-					cvmx_usb_complete(usb, pipe,
-							  transaction,
-							  CVMX_USB_STATUS_OK);
-				}
-			} else {
-				if ((pipe->device_speed ==
-				     CVMX_USB_SPEED_HIGH) &&
-				    (pipe->transfer_type ==
-				     CVMX_USB_TRANSFER_BULK) &&
-				    (pipe->transfer_dir ==
-				     CVMX_USB_DIRECTION_OUT) &&
-				    (usbc_hcint.s.nak))
-					pipe->flags |=
-						CVMX_USB_PIPE_FLAGS_NEED_PING;
-				if (!buffer_space_left ||
-				    (bytes_in_last_packet < pipe->max_packet)) {
-					if (transaction->type ==
-					    CVMX_USB_TRANSFER_INTERRUPT)
-						pipe->next_tx_frame +=
-							pipe->interval;
-					cvmx_usb_complete(usb, pipe,
-							  transaction,
-							  CVMX_USB_STATUS_OK);
-				}
-			}
+			cvmx_usb_transfer_intr(usb, pipe, transaction,
+					       buffer_space_left,
+					       bytes_in_last_packet);
 			break;
 		case CVMX_USB_TRANSFER_ISOCHRONOUS:
 			if (cvmx_usb_pipe_needs_split(usb, pipe)) {

commit 8ed3094c62232a4e1f2e2ef0ce8f4edb07e5a90e
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:14:01 2016 +0200

    staging: octeon-usb: move bulk transfer handling into separate function
    
    Move bulk transfer handling into a separate function to avoid
    deep indentation.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 65908d924fb9..d8c032f1d919 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2467,6 +2467,40 @@ static void cvmx_usb_transfer_control(struct octeon_hcd *usb,
 	}
 }
 
+static void cvmx_usb_transfer_bulk(struct octeon_hcd *usb,
+				   struct cvmx_usb_pipe *pipe,
+				   struct cvmx_usb_transaction *transaction,
+				   union cvmx_usbcx_hcintx usbc_hcint,
+				   int buffer_space_left,
+				   int bytes_in_last_packet)
+{
+	/*
+	 * The only time a bulk transfer isn't complete when it finishes with
+	 * an ACK is during a split transaction. For splits we need to continue
+	 * the transfer if more data is needed.
+	 */
+	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+		if (transaction->stage == CVMX_USB_STAGE_NON_CONTROL)
+			transaction->stage =
+				CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
+		else if (buffer_space_left &&
+			 (bytes_in_last_packet == pipe->max_packet))
+			transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+		else
+			cvmx_usb_complete(usb, pipe, transaction,
+					  CVMX_USB_STATUS_OK);
+	} else {
+		if ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&
+		    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) &&
+		    (usbc_hcint.s.nak))
+			pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
+		if (!buffer_space_left ||
+		    (bytes_in_last_packet < pipe->max_packet))
+			cvmx_usb_complete(usb, pipe, transaction,
+					  CVMX_USB_STATUS_OK);
+	}
+}
+
 /**
  * Poll a channel for status
  *
@@ -2746,6 +2780,10 @@ static int cvmx_usb_poll_channel(struct octeon_hcd *usb, int channel)
 						  bytes_in_last_packet);
 			break;
 		case CVMX_USB_TRANSFER_BULK:
+			cvmx_usb_transfer_bulk(usb, pipe, transaction,
+					       usbc_hcint, buffer_space_left,
+					       bytes_in_last_packet);
+			break;
 		case CVMX_USB_TRANSFER_INTERRUPT:
 			/*
 			 * The only time a bulk transfer isn't complete when it

commit 81a71bad40b549370556d653f4a114612c12b5ea
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:14:00 2016 +0200

    staging: octeon-usb: move control transfer handling into separate function
    
    Move control transfer handling into a separate function to
    avoid deep indentation.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 4da55e503fb5..65908d924fb9 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2383,6 +2383,90 @@ static int cvmx_usb_get_frame_number(struct octeon_hcd *usb)
 	return frame_number;
 }
 
+static void cvmx_usb_transfer_control(struct octeon_hcd *usb,
+				      struct cvmx_usb_pipe *pipe,
+				      struct cvmx_usb_transaction *transaction,
+				      union cvmx_usbcx_hccharx usbc_hcchar,
+				      int buffer_space_left,
+				      int bytes_in_last_packet)
+{
+	switch (transaction->stage) {
+	case CVMX_USB_STAGE_NON_CONTROL:
+	case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
+		/* This should be impossible */
+		cvmx_usb_complete(usb, pipe, transaction,
+				  CVMX_USB_STATUS_ERROR);
+		break;
+	case CVMX_USB_STAGE_SETUP:
+		pipe->pid_toggle = 1;
+		if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+			transaction->stage =
+				CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE;
+		} else {
+			struct usb_ctrlrequest *header =
+				cvmx_phys_to_ptr(transaction->control_header);
+			if (header->wLength)
+				transaction->stage = CVMX_USB_STAGE_DATA;
+			else
+				transaction->stage = CVMX_USB_STAGE_STATUS;
+		}
+		break;
+	case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
+		{
+			struct usb_ctrlrequest *header =
+				cvmx_phys_to_ptr(transaction->control_header);
+			if (header->wLength)
+				transaction->stage = CVMX_USB_STAGE_DATA;
+			else
+				transaction->stage = CVMX_USB_STAGE_STATUS;
+		}
+		break;
+	case CVMX_USB_STAGE_DATA:
+		if (cvmx_usb_pipe_needs_split(usb, pipe)) {
+			transaction->stage = CVMX_USB_STAGE_DATA_SPLIT_COMPLETE;
+			/*
+			 * For setup OUT data that are splits,
+			 * the hardware doesn't appear to count
+			 * transferred data. Here we manually
+			 * update the data transferred
+			 */
+			if (!usbc_hcchar.s.epdir) {
+				if (buffer_space_left < pipe->max_packet)
+					transaction->actual_bytes +=
+						buffer_space_left;
+				else
+					transaction->actual_bytes +=
+						pipe->max_packet;
+			}
+		} else if ((buffer_space_left == 0) ||
+			   (bytes_in_last_packet < pipe->max_packet)) {
+			pipe->pid_toggle = 1;
+			transaction->stage = CVMX_USB_STAGE_STATUS;
+		}
+		break;
+	case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
+		if ((buffer_space_left == 0) ||
+		    (bytes_in_last_packet < pipe->max_packet)) {
+			pipe->pid_toggle = 1;
+			transaction->stage = CVMX_USB_STAGE_STATUS;
+		} else {
+			transaction->stage = CVMX_USB_STAGE_DATA;
+		}
+		break;
+	case CVMX_USB_STAGE_STATUS:
+		if (cvmx_usb_pipe_needs_split(usb, pipe))
+			transaction->stage =
+				CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;
+		else
+			cvmx_usb_complete(usb, pipe, transaction,
+					  CVMX_USB_STATUS_OK);
+		break;
+	case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
+		cvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_OK);
+		break;
+	}
+}
+
 /**
  * Poll a channel for status
  *
@@ -2656,92 +2740,10 @@ static int cvmx_usb_poll_channel(struct octeon_hcd *usb, int channel)
 
 		switch (transaction->type) {
 		case CVMX_USB_TRANSFER_CONTROL:
-			switch (transaction->stage) {
-			case CVMX_USB_STAGE_NON_CONTROL:
-			case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
-				/* This should be impossible */
-				cvmx_usb_complete(usb, pipe, transaction,
-						  CVMX_USB_STATUS_ERROR);
-				break;
-			case CVMX_USB_STAGE_SETUP:
-				pipe->pid_toggle = 1;
-				if (cvmx_usb_pipe_needs_split(usb, pipe))
-					transaction->stage =
-						CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE;
-				else {
-					struct usb_ctrlrequest *header =
-						cvmx_phys_to_ptr(transaction->control_header);
-					if (header->wLength)
-						transaction->stage =
-							CVMX_USB_STAGE_DATA;
-					else
-						transaction->stage =
-							CVMX_USB_STAGE_STATUS;
-				}
-				break;
-			case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
-				{
-					struct usb_ctrlrequest *header =
-						cvmx_phys_to_ptr(transaction->control_header);
-					if (header->wLength)
-						transaction->stage =
-							CVMX_USB_STAGE_DATA;
-					else
-						transaction->stage =
-							CVMX_USB_STAGE_STATUS;
-				}
-				break;
-			case CVMX_USB_STAGE_DATA:
-				if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-					transaction->stage =
-						CVMX_USB_STAGE_DATA_SPLIT_COMPLETE;
-					/*
-					 * For setup OUT data that are splits,
-					 * the hardware doesn't appear to count
-					 * transferred data. Here we manually
-					 * update the data transferred
-					 */
-					if (!usbc_hcchar.s.epdir) {
-						if (buffer_space_left < pipe->max_packet)
-							transaction->actual_bytes +=
-								buffer_space_left;
-						else
-							transaction->actual_bytes +=
-								pipe->max_packet;
-					}
-				} else if ((buffer_space_left == 0) ||
-					   (bytes_in_last_packet <
-					    pipe->max_packet)) {
-					pipe->pid_toggle = 1;
-					transaction->stage =
-						CVMX_USB_STAGE_STATUS;
-				}
-				break;
-			case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
-				if ((buffer_space_left == 0) ||
-				    (bytes_in_last_packet < pipe->max_packet)) {
-					pipe->pid_toggle = 1;
-					transaction->stage =
-						CVMX_USB_STAGE_STATUS;
-				} else {
-					transaction->stage =
-						CVMX_USB_STAGE_DATA;
-				}
-				break;
-			case CVMX_USB_STAGE_STATUS:
-				if (cvmx_usb_pipe_needs_split(usb, pipe))
-					transaction->stage =
-						CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;
-				else
-					cvmx_usb_complete(usb, pipe,
-							  transaction,
-							  CVMX_USB_STATUS_OK);
-				break;
-			case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
-				cvmx_usb_complete(usb, pipe, transaction,
-						  CVMX_USB_STATUS_OK);
-				break;
-			}
+			cvmx_usb_transfer_control(usb, pipe, transaction,
+						  usbc_hcchar,
+						  buffer_space_left,
+						  bytes_in_last_packet);
 			break;
 		case CVMX_USB_TRANSFER_BULK:
 		case CVMX_USB_TRANSFER_INTERRUPT:

commit 8b07d2fe3853eb97af447230a2c739a2d33f0c43
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:13:59 2016 +0200

    staging: octeon-usb: fold cvmx_usb_state into octeon_hcd
    
    Fold cvmx_usb_state into octeon_hcd.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index c42ca0de391c..4da55e503fb5 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -342,8 +342,9 @@ struct cvmx_usb_tx_fifo {
 };
 
 /**
- * struct cvmx_usb_state - the state of the USB block
+ * struct octeon_hcd - the state of the USB block
  *
+ * lock:		   Serialization lock.
  * init_flags:		   Flags passed to initialize.
  * index:		   Which USB block this is for.
  * idle_hardware_channels: Bit set for every idle hardware channel.
@@ -358,7 +359,8 @@ struct cvmx_usb_tx_fifo {
  * frame_number:	   Increments every SOF interrupt for time keeping.
  * active_split:	   Points to the current active split, or NULL.
  */
-struct cvmx_usb_state {
+struct octeon_hcd {
+	spinlock_t lock; /* serialization lock */
 	int init_flags;
 	int index;
 	int idle_hardware_channels;
@@ -374,11 +376,6 @@ struct cvmx_usb_state {
 	struct cvmx_usb_tx_fifo nonperiodic;
 };
 
-struct octeon_hcd {
-	spinlock_t lock;
-	struct cvmx_usb_state usb;
-};
-
 /* This macro spins on a register waiting for it to reach a condition. */
 #define CVMX_WAIT_FOR_FIELD32(address, _union, cond, timeout_usec)	    \
 	({int result;							    \
@@ -433,11 +430,6 @@ struct octeon_temp_buffer {
 	u8 data[0];
 };
 
-static inline struct octeon_hcd *cvmx_usb_to_octeon(struct cvmx_usb_state *p)
-{
-	return container_of(p, struct octeon_hcd, usb);
-}
-
 static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
 {
 	return container_of((void *)p, struct usb_hcd, hcd_priv);
@@ -548,7 +540,7 @@ static void octeon_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
  *
  * Returns: Result of the read
  */
-static inline u32 cvmx_usb_read_csr32(struct cvmx_usb_state *usb, u64 address)
+static inline u32 cvmx_usb_read_csr32(struct octeon_hcd *usb, u64 address)
 {
 	u32 result = cvmx_read64_uint32(address ^ 4);
 	return result;
@@ -563,7 +555,7 @@ static inline u32 cvmx_usb_read_csr32(struct cvmx_usb_state *usb, u64 address)
  * @address: 64bit address to write
  * @value:   Value to write
  */
-static inline void cvmx_usb_write_csr32(struct cvmx_usb_state *usb,
+static inline void cvmx_usb_write_csr32(struct octeon_hcd *usb,
 					u64 address, u32 value)
 {
 	cvmx_write64_uint32(address ^ 4, value);
@@ -579,7 +571,7 @@ static inline void cvmx_usb_write_csr32(struct cvmx_usb_state *usb,
  *
  * Returns: Non zero if we need to do split transactions
  */
-static inline int cvmx_usb_pipe_needs_split(struct cvmx_usb_state *usb,
+static inline int cvmx_usb_pipe_needs_split(struct octeon_hcd *usb,
 					    struct cvmx_usb_pipe *pipe)
 {
 	return pipe->device_speed != CVMX_USB_SPEED_HIGH &&
@@ -600,7 +592,7 @@ static inline int cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)
 	return 0; /* Data0 */
 }
 
-static void cvmx_fifo_setup(struct cvmx_usb_state *usb)
+static void cvmx_fifo_setup(struct octeon_hcd *usb)
 {
 	union cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;
 	union cvmx_usbcx_gnptxfsiz npsiz;
@@ -658,7 +650,7 @@ static void cvmx_fifo_setup(struct cvmx_usb_state *usb)
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_shutdown(struct cvmx_usb_state *usb)
+static int cvmx_usb_shutdown(struct octeon_hcd *usb)
 {
 	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
 
@@ -687,12 +679,12 @@ static int cvmx_usb_shutdown(struct cvmx_usb_state *usb)
  * off in the disabled state.
  *
  * @dev:	 Pointer to struct device for logging purposes.
- * @usb:	 Pointer to struct cvmx_usb_state.
+ * @usb:	 Pointer to struct octeon_hcd.
  *
  * Returns: 0 or a negative error code.
  */
 static int cvmx_usb_initialize(struct device *dev,
-			       struct cvmx_usb_state *usb)
+			       struct octeon_hcd *usb)
 {
 	int channel;
 	int divisor;
@@ -958,7 +950,7 @@ static int cvmx_usb_initialize(struct device *dev,
  *
  * @usb: USB device state populated by cvmx_usb_initialize().
  */
-static void cvmx_usb_reset_port(struct cvmx_usb_state *usb)
+static void cvmx_usb_reset_port(struct octeon_hcd *usb)
 {
 	usb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,
 						  CVMX_USBCX_HPRT(usb->index));
@@ -995,7 +987,7 @@ static void cvmx_usb_reset_port(struct cvmx_usb_state *usb)
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_disable(struct cvmx_usb_state *usb)
+static int cvmx_usb_disable(struct octeon_hcd *usb)
 {
 	/* Disable the port */
 	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,
@@ -1014,8 +1006,7 @@ static int cvmx_usb_disable(struct cvmx_usb_state *usb)
  *
  * Returns: Port status information
  */
-static struct cvmx_usb_port_status cvmx_usb_get_status(
-		struct cvmx_usb_state *usb)
+static struct cvmx_usb_port_status cvmx_usb_get_status(struct octeon_hcd *usb)
 {
 	union cvmx_usbcx_hprt usbc_hprt;
 	struct cvmx_usb_port_status result;
@@ -1086,7 +1077,7 @@ static struct cvmx_usb_port_status cvmx_usb_get_status(
  *
  * Returns: A non-NULL value is a pipe. NULL means an error.
  */
-static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
+static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct octeon_hcd *usb,
 						int device_addr,
 						int endpoint_num,
 						enum cvmx_usb_speed
@@ -1154,7 +1145,7 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
  *
  * @usb:	USB device state populated by cvmx_usb_initialize().
  */
-static void cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
+static void cvmx_usb_poll_rx_fifo(struct octeon_hcd *usb)
 {
 	union cvmx_usbcx_grxstsph rx_status;
 	int channel;
@@ -1204,7 +1195,7 @@ static void cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
  * Returns: Non zero if the hardware fifo was too small and needs
  *	    to be serviced again.
  */
-static int cvmx_usb_fill_tx_hw(struct cvmx_usb_state *usb,
+static int cvmx_usb_fill_tx_hw(struct octeon_hcd *usb,
 			       struct cvmx_usb_tx_fifo *fifo, int available)
 {
 	/*
@@ -1259,7 +1250,7 @@ static int cvmx_usb_fill_tx_hw(struct cvmx_usb_state *usb,
  *
  * @usb:	USB device state populated by cvmx_usb_initialize().
  */
-static void cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
+static void cvmx_usb_poll_tx_fifo(struct octeon_hcd *usb)
 {
 	if (usb->periodic.head != usb->periodic.tail) {
 		union cvmx_usbcx_hptxsts tx_status;
@@ -1296,7 +1287,7 @@ static void cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
  * @usb:	  USB device state populated by cvmx_usb_initialize().
  * @channel:	  Channel number to get packet from
  */
-static void cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
+static void cvmx_usb_fill_tx_fifo(struct octeon_hcd *usb, int channel)
 {
 	union cvmx_usbcx_hccharx hcchar;
 	union cvmx_usbcx_hcspltx usbc_hcsplt;
@@ -1350,12 +1341,11 @@ static void cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
  * @channel:	  Channel to setup
  * @pipe:	  Pipe for control transaction
  */
-static void cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
+static void cvmx_usb_start_channel_control(struct octeon_hcd *usb,
 					   int channel,
 					   struct cvmx_usb_pipe *pipe)
 {
-	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
-	struct usb_hcd *hcd = octeon_to_hcd(priv);
+	struct usb_hcd *hcd = octeon_to_hcd(usb);
 	struct device *dev = hcd->self.controller;
 	struct cvmx_usb_transaction *transaction =
 		list_first_entry(&pipe->transactions, typeof(*transaction),
@@ -1499,7 +1489,7 @@ static void cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
  * @channel:	  Channel to setup
  * @pipe:	  Pipe to start
  */
-static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
+static void cvmx_usb_start_channel(struct octeon_hcd *usb, int channel,
 				   struct cvmx_usb_pipe *pipe)
 {
 	struct cvmx_usb_transaction *transaction =
@@ -1844,7 +1834,7 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
  * Returns: Pipe or NULL if none are ready
  */
 static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(
-		struct cvmx_usb_state *usb,
+		struct octeon_hcd *usb,
 		enum cvmx_usb_transfer xfer_type)
 {
 	struct list_head *list = usb->active_pipes + xfer_type;
@@ -1875,7 +1865,7 @@ static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(
  * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @is_sof:	 True if this schedule was called on a SOF interrupt.
  */
-static void cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
+static void cvmx_usb_schedule(struct octeon_hcd *usb, int is_sof)
 {
 	int channel;
 	struct cvmx_usb_pipe *pipe;
@@ -1953,7 +1943,7 @@ static void cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 			cvmx_usbcx_gintmsk, sofmsk, need_sof);
 }
 
-static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
+static void octeon_usb_urb_complete_callback(struct octeon_hcd *usb,
 					     enum cvmx_usb_status status,
 					     struct cvmx_usb_pipe *pipe,
 					     struct cvmx_usb_transaction
@@ -1961,8 +1951,7 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 					     int bytes_transferred,
 					     struct urb *urb)
 {
-	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
-	struct usb_hcd *hcd = octeon_to_hcd(priv);
+	struct usb_hcd *hcd = octeon_to_hcd(usb);
 	struct device *dev = hcd->self.controller;
 
 	if (likely(status == CVMX_USB_STATUS_OK))
@@ -2037,10 +2026,10 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 		urb->status = -EPROTO;
 		break;
 	}
-	usb_hcd_unlink_urb_from_ep(octeon_to_hcd(priv), urb);
-	spin_unlock(&priv->lock);
-	usb_hcd_giveback_urb(octeon_to_hcd(priv), urb, urb->status);
-	spin_lock(&priv->lock);
+	usb_hcd_unlink_urb_from_ep(octeon_to_hcd(usb), urb);
+	spin_unlock(&usb->lock);
+	usb_hcd_giveback_urb(octeon_to_hcd(usb), urb, urb->status);
+	spin_lock(&usb->lock);
 }
 
 /**
@@ -2054,7 +2043,7 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
  * @complete_code:
  *		 Completion code
  */
-static void cvmx_usb_complete(struct cvmx_usb_state *usb,
+static void cvmx_usb_complete(struct octeon_hcd *usb,
 			      struct cvmx_usb_pipe *pipe,
 			      struct cvmx_usb_transaction *transaction,
 			      enum cvmx_usb_status complete_code)
@@ -2123,7 +2112,7 @@ static void cvmx_usb_complete(struct cvmx_usb_state *usb,
  * Returns: Transaction or NULL on failure.
  */
 static struct cvmx_usb_transaction *cvmx_usb_submit_transaction(
-				struct cvmx_usb_state *usb,
+				struct octeon_hcd *usb,
 				struct cvmx_usb_pipe *pipe,
 				enum cvmx_usb_transfer type,
 				u64 buffer,
@@ -2184,7 +2173,7 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_transaction(
  * Returns: A submitted transaction or NULL on failure.
  */
 static struct cvmx_usb_transaction *cvmx_usb_submit_bulk(
-						struct cvmx_usb_state *usb,
+						struct octeon_hcd *usb,
 						struct cvmx_usb_pipe *pipe,
 						struct urb *urb)
 {
@@ -2208,7 +2197,7 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_bulk(
  * Returns: A submitted transaction or NULL on failure.
  */
 static struct cvmx_usb_transaction *cvmx_usb_submit_interrupt(
-						struct cvmx_usb_state *usb,
+						struct octeon_hcd *usb,
 						struct cvmx_usb_pipe *pipe,
 						struct urb *urb)
 {
@@ -2233,7 +2222,7 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_interrupt(
  * Returns: A submitted transaction or NULL on failure.
  */
 static struct cvmx_usb_transaction *cvmx_usb_submit_control(
-						struct cvmx_usb_state *usb,
+						struct octeon_hcd *usb,
 						struct cvmx_usb_pipe *pipe,
 						struct urb *urb)
 {
@@ -2264,7 +2253,7 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_control(
  * Returns: A submitted transaction or NULL on failure.
  */
 static struct cvmx_usb_transaction *cvmx_usb_submit_isochronous(
-						struct cvmx_usb_state *usb,
+						struct octeon_hcd *usb,
 						struct cvmx_usb_pipe *pipe,
 						struct urb *urb)
 {
@@ -2294,7 +2283,7 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_isochronous(
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
+static int cvmx_usb_cancel(struct octeon_hcd *usb,
 			   struct cvmx_usb_pipe *pipe,
 			   struct cvmx_usb_transaction *transaction)
 {
@@ -2338,7 +2327,7 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_cancel_all(struct cvmx_usb_state *usb,
+static int cvmx_usb_cancel_all(struct octeon_hcd *usb,
 			       struct cvmx_usb_pipe *pipe)
 {
 	struct cvmx_usb_transaction *transaction, *next;
@@ -2362,7 +2351,7 @@ static int cvmx_usb_cancel_all(struct cvmx_usb_state *usb,
  * Returns: 0 or a negative error code. EBUSY is returned if the pipe has
  *	    outstanding transfers.
  */
-static int cvmx_usb_close_pipe(struct cvmx_usb_state *usb,
+static int cvmx_usb_close_pipe(struct octeon_hcd *usb,
 			       struct cvmx_usb_pipe *pipe)
 {
 	/* Fail if the pipe has pending transactions */
@@ -2383,7 +2372,7 @@ static int cvmx_usb_close_pipe(struct cvmx_usb_state *usb,
  *
  * Returns: USB frame number
  */
-static int cvmx_usb_get_frame_number(struct cvmx_usb_state *usb)
+static int cvmx_usb_get_frame_number(struct octeon_hcd *usb)
 {
 	int frame_number;
 	union cvmx_usbcx_hfnum usbc_hfnum;
@@ -2402,10 +2391,9 @@ static int cvmx_usb_get_frame_number(struct cvmx_usb_state *usb)
  *
  * Returns: Zero on success
  */
-static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
+static int cvmx_usb_poll_channel(struct octeon_hcd *usb, int channel)
 {
-	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
-	struct usb_hcd *hcd = octeon_to_hcd(priv);
+	struct usb_hcd *hcd = octeon_to_hcd(usb);
 	struct device *dev = hcd->self.controller;
 	union cvmx_usbcx_hcintx usbc_hcint;
 	union cvmx_usbcx_hctsizx usbc_hctsiz;
@@ -2899,13 +2887,11 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	return 0;
 }
 
-static void octeon_usb_port_callback(struct cvmx_usb_state *usb)
+static void octeon_usb_port_callback(struct octeon_hcd *usb)
 {
-	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
-
-	spin_unlock(&priv->lock);
-	usb_hcd_poll_rh_status(octeon_to_hcd(priv));
-	spin_lock(&priv->lock);
+	spin_unlock(&usb->lock);
+	usb_hcd_poll_rh_status(octeon_to_hcd(usb));
+	spin_lock(&usb->lock);
 }
 
 /**
@@ -2918,7 +2904,7 @@ static void octeon_usb_port_callback(struct cvmx_usb_state *usb)
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_poll(struct cvmx_usb_state *usb)
+static int cvmx_usb_poll(struct octeon_hcd *usb)
 {
 	union cvmx_usbcx_hfnum usbc_hfnum;
 	union cvmx_usbcx_gintsts usbc_gintsts;
@@ -3019,12 +3005,12 @@ static inline struct octeon_hcd *hcd_to_octeon(struct usb_hcd *hcd)
 
 static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
 {
-	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
 	unsigned long flags;
 
-	spin_lock_irqsave(&priv->lock, flags);
-	cvmx_usb_poll(&priv->usb);
-	spin_unlock_irqrestore(&priv->lock, flags);
+	spin_lock_irqsave(&usb->lock, flags);
+	cvmx_usb_poll(usb);
+	spin_unlock_irqrestore(&usb->lock, flags);
 	return IRQ_HANDLED;
 }
 
@@ -3041,16 +3027,16 @@ static void octeon_usb_stop(struct usb_hcd *hcd)
 
 static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
 {
-	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
 
-	return cvmx_usb_get_frame_number(&priv->usb);
+	return cvmx_usb_get_frame_number(usb);
 }
 
 static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 				  struct urb *urb,
 				  gfp_t mem_flags)
 {
-	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
 	struct device *dev = hcd->self.controller;
 	struct cvmx_usb_transaction *transaction = NULL;
 	struct cvmx_usb_pipe *pipe;
@@ -3060,11 +3046,11 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	int rc;
 
 	urb->status = 0;
-	spin_lock_irqsave(&priv->lock, flags);
+	spin_lock_irqsave(&usb->lock, flags);
 
 	rc = usb_hcd_link_urb_to_ep(hcd, urb);
 	if (rc) {
-		spin_unlock_irqrestore(&priv->lock, flags);
+		spin_unlock_irqrestore(&usb->lock, flags);
 		return rc;
 	}
 
@@ -3130,7 +3116,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 				dev = dev->parent;
 			}
 		}
-		pipe = cvmx_usb_open_pipe(&priv->usb, usb_pipedevice(urb->pipe),
+		pipe = cvmx_usb_open_pipe(usb, usb_pipedevice(urb->pipe),
 					  usb_pipeendpoint(urb->pipe), speed,
 					  le16_to_cpu(ep->desc.wMaxPacketSize)
 					  & 0x7ff,
@@ -3144,7 +3130,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 					  split_device, split_port);
 		if (!pipe) {
 			usb_hcd_unlink_urb_from_ep(hcd, urb);
-			spin_unlock_irqrestore(&priv->lock, flags);
+			spin_unlock_irqrestore(&usb->lock, flags);
 			dev_dbg(dev, "Failed to create pipe\n");
 			return -ENOMEM;
 		}
@@ -3181,7 +3167,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 			 * this saves us a bunch of logic.
 			 */
 			urb->setup_packet = (char *)iso_packet;
-			transaction = cvmx_usb_submit_isochronous(&priv->usb,
+			transaction = cvmx_usb_submit_isochronous(usb,
 								  pipe, urb);
 			/*
 			 * If submit failed we need to free our private packet
@@ -3197,29 +3183,29 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		dev_dbg(dev, "Submit interrupt to %d.%d\n",
 			usb_pipedevice(urb->pipe),
 			usb_pipeendpoint(urb->pipe));
-		transaction = cvmx_usb_submit_interrupt(&priv->usb, pipe, urb);
+		transaction = cvmx_usb_submit_interrupt(usb, pipe, urb);
 		break;
 	case PIPE_CONTROL:
 		dev_dbg(dev, "Submit control to %d.%d\n",
 			usb_pipedevice(urb->pipe),
 			usb_pipeendpoint(urb->pipe));
-		transaction = cvmx_usb_submit_control(&priv->usb, pipe, urb);
+		transaction = cvmx_usb_submit_control(usb, pipe, urb);
 		break;
 	case PIPE_BULK:
 		dev_dbg(dev, "Submit bulk to %d.%d\n",
 			usb_pipedevice(urb->pipe),
 			usb_pipeendpoint(urb->pipe));
-		transaction = cvmx_usb_submit_bulk(&priv->usb, pipe, urb);
+		transaction = cvmx_usb_submit_bulk(usb, pipe, urb);
 		break;
 	}
 	if (!transaction) {
 		usb_hcd_unlink_urb_from_ep(hcd, urb);
-		spin_unlock_irqrestore(&priv->lock, flags);
+		spin_unlock_irqrestore(&usb->lock, flags);
 		dev_dbg(dev, "Failed to submit\n");
 		return -ENOMEM;
 	}
 	urb->hcpriv = transaction;
-	spin_unlock_irqrestore(&priv->lock, flags);
+	spin_unlock_irqrestore(&usb->lock, flags);
 	return 0;
 }
 
@@ -3227,24 +3213,24 @@ static int octeon_usb_urb_dequeue(struct usb_hcd *hcd,
 				  struct urb *urb,
 				  int status)
 {
-	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
 	unsigned long flags;
 	int rc;
 
 	if (!urb->dev)
 		return -EINVAL;
 
-	spin_lock_irqsave(&priv->lock, flags);
+	spin_lock_irqsave(&usb->lock, flags);
 
 	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
 	if (rc)
 		goto out;
 
 	urb->status = status;
-	cvmx_usb_cancel(&priv->usb, urb->ep->hcpriv, urb->hcpriv);
+	cvmx_usb_cancel(usb, urb->ep->hcpriv, urb->hcpriv);
 
 out:
-	spin_unlock_irqrestore(&priv->lock, flags);
+	spin_unlock_irqrestore(&usb->lock, flags);
 
 	return rc;
 }
@@ -3255,28 +3241,28 @@ static void octeon_usb_endpoint_disable(struct usb_hcd *hcd,
 	struct device *dev = hcd->self.controller;
 
 	if (ep->hcpriv) {
-		struct octeon_hcd *priv = hcd_to_octeon(hcd);
+		struct octeon_hcd *usb = hcd_to_octeon(hcd);
 		struct cvmx_usb_pipe *pipe = ep->hcpriv;
 		unsigned long flags;
 
-		spin_lock_irqsave(&priv->lock, flags);
-		cvmx_usb_cancel_all(&priv->usb, pipe);
-		if (cvmx_usb_close_pipe(&priv->usb, pipe))
+		spin_lock_irqsave(&usb->lock, flags);
+		cvmx_usb_cancel_all(usb, pipe);
+		if (cvmx_usb_close_pipe(usb, pipe))
 			dev_dbg(dev, "Closing pipe %p failed\n", pipe);
-		spin_unlock_irqrestore(&priv->lock, flags);
+		spin_unlock_irqrestore(&usb->lock, flags);
 		ep->hcpriv = NULL;
 	}
 }
 
 static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
 {
-	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
 	struct cvmx_usb_port_status port_status;
 	unsigned long flags;
 
-	spin_lock_irqsave(&priv->lock, flags);
-	port_status = cvmx_usb_get_status(&priv->usb);
-	spin_unlock_irqrestore(&priv->lock, flags);
+	spin_lock_irqsave(&usb->lock, flags);
+	port_status = cvmx_usb_get_status(usb);
+	spin_unlock_irqrestore(&usb->lock, flags);
 	buf[0] = 0;
 	buf[0] = port_status.connect_change << 1;
 
@@ -3286,10 +3272,9 @@ static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
 static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 				  u16 wIndex, char *buf, u16 wLength)
 {
-	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
 	struct device *dev = hcd->self.controller;
 	struct cvmx_usb_port_status usb_port_status;
-	struct cvmx_usb_state *usb = &priv->usb;
 	int port_status;
 	struct usb_hub_descriptor *desc;
 	unsigned long flags;
@@ -3316,9 +3301,9 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		switch (wValue) {
 		case USB_PORT_FEAT_ENABLE:
 			dev_dbg(dev, " ENABLE\n");
-			spin_lock_irqsave(&priv->lock, flags);
-			cvmx_usb_disable(&priv->usb);
-			spin_unlock_irqrestore(&priv->lock, flags);
+			spin_lock_irqsave(&usb->lock, flags);
+			cvmx_usb_disable(usb);
+			spin_unlock_irqrestore(&usb->lock, flags);
 			break;
 		case USB_PORT_FEAT_SUSPEND:
 			dev_dbg(dev, " SUSPEND\n");
@@ -3335,20 +3320,18 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		case USB_PORT_FEAT_C_CONNECTION:
 			dev_dbg(dev, " C_CONNECTION\n");
 			/* Clears drivers internal connect status change flag */
-			spin_lock_irqsave(&priv->lock, flags);
-			priv->usb.port_status =
-				cvmx_usb_get_status(&priv->usb);
-			spin_unlock_irqrestore(&priv->lock, flags);
+			spin_lock_irqsave(&usb->lock, flags);
+			usb->port_status = cvmx_usb_get_status(usb);
+			spin_unlock_irqrestore(&usb->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_RESET:
 			dev_dbg(dev, " C_RESET\n");
 			/*
 			 * Clears the driver's internal Port Reset Change flag.
 			 */
-			spin_lock_irqsave(&priv->lock, flags);
-			priv->usb.port_status =
-				cvmx_usb_get_status(&priv->usb);
-			spin_unlock_irqrestore(&priv->lock, flags);
+			spin_lock_irqsave(&usb->lock, flags);
+			usb->port_status = cvmx_usb_get_status(usb);
+			spin_unlock_irqrestore(&usb->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_ENABLE:
 			dev_dbg(dev, " C_ENABLE\n");
@@ -3356,10 +3339,9 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			 * Clears the driver's internal Port Enable/Disable
 			 * Change flag.
 			 */
-			spin_lock_irqsave(&priv->lock, flags);
-			priv->usb.port_status =
-				cvmx_usb_get_status(&priv->usb);
-			spin_unlock_irqrestore(&priv->lock, flags);
+			spin_lock_irqsave(&usb->lock, flags);
+			usb->port_status = cvmx_usb_get_status(usb);
+			spin_unlock_irqrestore(&usb->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			dev_dbg(dev, " C_SUSPEND\n");
@@ -3372,10 +3354,9 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		case USB_PORT_FEAT_C_OVER_CURRENT:
 			dev_dbg(dev, " C_OVER_CURRENT\n");
 			/* Clears the driver's overcurrent Change flag */
-			spin_lock_irqsave(&priv->lock, flags);
-			priv->usb.port_status =
-				cvmx_usb_get_status(&priv->usb);
-			spin_unlock_irqrestore(&priv->lock, flags);
+			spin_lock_irqsave(&usb->lock, flags);
+			usb->port_status = cvmx_usb_get_status(usb);
+			spin_unlock_irqrestore(&usb->lock, flags);
 			break;
 		default:
 			dev_dbg(dev, " UNKNOWN\n");
@@ -3405,9 +3386,9 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			return -EINVAL;
 		}
 
-		spin_lock_irqsave(&priv->lock, flags);
-		usb_port_status = cvmx_usb_get_status(&priv->usb);
-		spin_unlock_irqrestore(&priv->lock, flags);
+		spin_lock_irqsave(&usb->lock, flags);
+		usb_port_status = cvmx_usb_get_status(usb);
+		spin_unlock_irqrestore(&usb->lock, flags);
 		port_status = 0;
 
 		if (usb_port_status.connect_change) {
@@ -3470,16 +3451,16 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			/*
 			 * Program the port power bit to drive VBUS on the USB.
 			 */
-			spin_lock_irqsave(&priv->lock, flags);
+			spin_lock_irqsave(&usb->lock, flags);
 			USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index),
 					cvmx_usbcx_hprt, prtpwr, 1);
-			spin_unlock_irqrestore(&priv->lock, flags);
+			spin_unlock_irqrestore(&usb->lock, flags);
 			return 0;
 		case USB_PORT_FEAT_RESET:
 			dev_dbg(dev, " RESET\n");
-			spin_lock_irqsave(&priv->lock, flags);
-			cvmx_usb_reset_port(&priv->usb);
-			spin_unlock_irqrestore(&priv->lock, flags);
+			spin_lock_irqsave(&usb->lock, flags);
+			cvmx_usb_reset_port(usb);
+			spin_unlock_irqrestore(&usb->lock, flags);
 			return 0;
 		case USB_PORT_FEAT_INDICATOR:
 			dev_dbg(dev, " INDICATOR\n");
@@ -3524,7 +3505,7 @@ static int octeon_usb_probe(struct platform_device *pdev)
 	struct device_node *usbn_node;
 	int irq = platform_get_irq(pdev, 0);
 	struct device *dev = &pdev->dev;
-	struct octeon_hcd *priv;
+	struct octeon_hcd *usb;
 	struct usb_hcd *hcd;
 	u32 clock_rate = 48000000;
 	bool is_crystal_clock = false;
@@ -3623,31 +3604,31 @@ static int octeon_usb_probe(struct platform_device *pdev)
 		return -1;
 	}
 	hcd->uses_new_polling = 1;
-	priv = (struct octeon_hcd *)hcd->hcd_priv;
+	usb = (struct octeon_hcd *)hcd->hcd_priv;
 
-	spin_lock_init(&priv->lock);
+	spin_lock_init(&usb->lock);
 
-	priv->usb.init_flags = initialize_flags;
+	usb->init_flags = initialize_flags;
 
 	/* Initialize the USB state structure */
-	priv->usb.index = usb_num;
-	INIT_LIST_HEAD(&priv->usb.idle_pipes);
-	for (i = 0; i < ARRAY_SIZE(priv->usb.active_pipes); i++)
-		INIT_LIST_HEAD(&priv->usb.active_pipes[i]);
+	usb->index = usb_num;
+	INIT_LIST_HEAD(&usb->idle_pipes);
+	for (i = 0; i < ARRAY_SIZE(usb->active_pipes); i++)
+		INIT_LIST_HEAD(&usb->active_pipes[i]);
 
 	/* Due to an errata, CN31XX doesn't support DMA */
 	if (OCTEON_IS_MODEL(OCTEON_CN31XX)) {
-		priv->usb.init_flags |= CVMX_USB_INITIALIZE_FLAGS_NO_DMA;
+		usb->init_flags |= CVMX_USB_INITIALIZE_FLAGS_NO_DMA;
 		/* Only use one channel with non DMA */
-		priv->usb.idle_hardware_channels = 0x1;
+		usb->idle_hardware_channels = 0x1;
 	} else if (OCTEON_IS_MODEL(OCTEON_CN5XXX)) {
 		/* CN5XXX have an errata with channel 3 */
-		priv->usb.idle_hardware_channels = 0xf7;
+		usb->idle_hardware_channels = 0xf7;
 	} else {
-		priv->usb.idle_hardware_channels = 0xff;
+		usb->idle_hardware_channels = 0xff;
 	}
 
-	status = cvmx_usb_initialize(dev, &priv->usb);
+	status = cvmx_usb_initialize(dev, usb);
 	if (status) {
 		dev_dbg(dev, "USB initialization failed with %d\n", status);
 		kfree(hcd);
@@ -3672,13 +3653,13 @@ static int octeon_usb_remove(struct platform_device *pdev)
 	int status;
 	struct device *dev = &pdev->dev;
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	struct octeon_hcd *usb = hcd_to_octeon(hcd);
 	unsigned long flags;
 
 	usb_remove_hcd(hcd);
-	spin_lock_irqsave(&priv->lock, flags);
-	status = cvmx_usb_shutdown(&priv->usb);
-	spin_unlock_irqrestore(&priv->lock, flags);
+	spin_lock_irqsave(&usb->lock, flags);
+	status = cvmx_usb_shutdown(usb);
+	spin_unlock_irqrestore(&usb->lock, flags);
 	if (status)
 		dev_dbg(dev, "USB shutdown failed with %d\n", status);
 

commit b186eb64d47633d4dfbbf68971b125608c240615
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:13:58 2016 +0200

    staging: octeon-usb: rename STATUS_SUCCESS to STATUS_OK
    
    Rename STATUS_SUCCESS to STATUS_OK.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 73a250b0920b..c42ca0de391c 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -101,7 +101,7 @@ enum cvmx_usb_direction {
 /**
  * enum cvmx_usb_status - possible callback function status codes
  *
- * @CVMX_USB_STATUS_SUCCESS:	  The transaction / operation finished without
+ * @CVMX_USB_STATUS_OK:		  The transaction / operation finished without
  *				  any errors
  * @CVMX_USB_STATUS_SHORT:	  FIXME: This is currently not implemented
  * @CVMX_USB_STATUS_CANCEL:	  The transaction was canceled while in flight
@@ -119,7 +119,7 @@ enum cvmx_usb_direction {
  *				  even after a number of retries
  */
 enum cvmx_usb_status {
-	CVMX_USB_STATUS_SUCCESS,
+	CVMX_USB_STATUS_OK,
 	CVMX_USB_STATUS_SHORT,
 	CVMX_USB_STATUS_CANCEL,
 	CVMX_USB_STATUS_ERROR,
@@ -1965,7 +1965,7 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 	struct usb_hcd *hcd = octeon_to_hcd(priv);
 	struct device *dev = hcd->self.controller;
 
-	if (likely(status == CVMX_USB_STATUS_SUCCESS))
+	if (likely(status == CVMX_USB_STATUS_OK))
 		urb->actual_length = bytes_transferred;
 	else
 		urb->actual_length = 0;
@@ -1986,7 +1986,7 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 		/* Recalculate the transfer size by adding up each packet */
 		urb->actual_length = 0;
 		for (i = 0; i < urb->number_of_packets; i++) {
-			if (iso_packet[i].status == CVMX_USB_STATUS_SUCCESS) {
+			if (iso_packet[i].status == CVMX_USB_STATUS_OK) {
 				urb->iso_frame_desc[i].status = 0;
 				urb->iso_frame_desc[i].actual_length =
 					iso_packet[i].length;
@@ -2006,7 +2006,7 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 	}
 
 	switch (status) {
-	case CVMX_USB_STATUS_SUCCESS:
+	case CVMX_USB_STATUS_OK:
 		urb->status = 0;
 		break;
 	case CVMX_USB_STATUS_CANCEL:
@@ -2077,7 +2077,7 @@ static void cvmx_usb_complete(struct cvmx_usb_state *usb,
 		 * next one
 		 */
 		if ((transaction->iso_number_packets > 1) &&
-		    (complete_code == CVMX_USB_STATUS_SUCCESS)) {
+		    (complete_code == CVMX_USB_STATUS_OK)) {
 			/* No bytes transferred for this packet as of yet */
 			transaction->actual_bytes = 0;
 			/* One less ISO waiting to transfer */
@@ -2634,7 +2634,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			    (bytes_in_last_packet < pipe->max_packet))
 				cvmx_usb_complete(usb, pipe,
 						  transaction,
-						  CVMX_USB_STATUS_SUCCESS);
+						  CVMX_USB_STATUS_OK);
 		} else {
 			/*
 			 * Split transactions retry the split complete 4 times
@@ -2747,11 +2747,11 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				else
 					cvmx_usb_complete(usb, pipe,
 							  transaction,
-							  CVMX_USB_STATUS_SUCCESS);
+							  CVMX_USB_STATUS_OK);
 				break;
 			case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
 				cvmx_usb_complete(usb, pipe, transaction,
-						  CVMX_USB_STATUS_SUCCESS);
+						  CVMX_USB_STATUS_OK);
 				break;
 			}
 			break;
@@ -2780,7 +2780,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 							pipe->interval;
 					cvmx_usb_complete(usb, pipe,
 							  transaction,
-							  CVMX_USB_STATUS_SUCCESS);
+							  CVMX_USB_STATUS_OK);
 				}
 			} else {
 				if ((pipe->device_speed ==
@@ -2800,7 +2800,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 							pipe->interval;
 					cvmx_usb_complete(usb, pipe,
 							  transaction,
-							  CVMX_USB_STATUS_SUCCESS);
+							  CVMX_USB_STATUS_OK);
 				}
 			}
 			break;
@@ -2828,7 +2828,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 							pipe->interval;
 						cvmx_usb_complete(usb, pipe,
 								  transaction,
-								  CVMX_USB_STATUS_SUCCESS);
+								  CVMX_USB_STATUS_OK);
 					}
 				} else {
 					if (transaction->stage ==
@@ -2847,7 +2847,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 							cvmx_usb_complete(usb,
 									  pipe,
 									  transaction,
-									  CVMX_USB_STATUS_SUCCESS);
+									  CVMX_USB_STATUS_OK);
 						}
 					} else
 						transaction->stage =
@@ -2856,7 +2856,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			} else {
 				pipe->next_tx_frame += pipe->interval;
 				cvmx_usb_complete(usb, pipe, transaction,
-						  CVMX_USB_STATUS_SUCCESS);
+						  CVMX_USB_STATUS_OK);
 			}
 			break;
 		}

commit e6bff5a070fe793dce3a638a5180ca18abd5aadf
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:13:57 2016 +0200

    staging: octeon-usb: rename cvmx_usb_perform_complete to cvmx_usb_complete
    
    Rename cvmx_usb_perform_complete to cvmx_usb_complete.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index c6fd955b4287..73a250b0920b 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2054,10 +2054,10 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
  * @complete_code:
  *		 Completion code
  */
-static void cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
-				      struct cvmx_usb_pipe *pipe,
-				      struct cvmx_usb_transaction *transaction,
-				      enum cvmx_usb_status complete_code)
+static void cvmx_usb_complete(struct cvmx_usb_state *usb,
+			      struct cvmx_usb_pipe *pipe,
+			      struct cvmx_usb_transaction *transaction,
+			      enum cvmx_usb_status complete_code)
 {
 	/* If this was a split then clear our split in progress marker */
 	if (usb->active_split == transaction)
@@ -2325,8 +2325,7 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 					     usbc_hcchar.u32);
 		}
 	}
-	cvmx_usb_perform_complete(usb, pipe, transaction,
-				  CVMX_USB_STATUS_CANCEL);
+	cvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_CANCEL);
 	return 0;
 }
 
@@ -2587,8 +2586,8 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		 * keeps substracting same byte count over and over again. In
 		 * such case we just need to fail every transaction.
 		 */
-		cvmx_usb_perform_complete(usb, pipe, transaction,
-					  CVMX_USB_STATUS_ERROR);
+		cvmx_usb_complete(usb, pipe, transaction,
+				  CVMX_USB_STATUS_ERROR);
 		return 0;
 	}
 
@@ -2600,24 +2599,24 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		 * the actual bytes transferred
 		 */
 		pipe->pid_toggle = 0;
-		cvmx_usb_perform_complete(usb, pipe, transaction,
-					  CVMX_USB_STATUS_STALL);
+		cvmx_usb_complete(usb, pipe, transaction,
+				  CVMX_USB_STATUS_STALL);
 	} else if (usbc_hcint.s.xacterr) {
 		/*
 		 * XactErr as a response means the device signaled
 		 * something wrong with the transfer. For example, PID
 		 * toggle errors cause these.
 		 */
-		cvmx_usb_perform_complete(usb, pipe, transaction,
-					  CVMX_USB_STATUS_XACTERR);
+		cvmx_usb_complete(usb, pipe, transaction,
+				  CVMX_USB_STATUS_XACTERR);
 	} else if (usbc_hcint.s.bblerr) {
 		/* Babble Error (BblErr) */
-		cvmx_usb_perform_complete(usb, pipe, transaction,
-					  CVMX_USB_STATUS_BABBLEERR);
+		cvmx_usb_complete(usb, pipe, transaction,
+				  CVMX_USB_STATUS_BABBLEERR);
 	} else if (usbc_hcint.s.datatglerr) {
 		/* Data toggle error */
-		cvmx_usb_perform_complete(usb, pipe, transaction,
-					  CVMX_USB_STATUS_DATATGLERR);
+		cvmx_usb_complete(usb, pipe, transaction,
+				  CVMX_USB_STATUS_DATATGLERR);
 	} else if (usbc_hcint.s.nyet) {
 		/*
 		 * NYET as a response is only allowed in three cases: as a
@@ -2633,9 +2632,9 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 */
 			if ((buffer_space_left == 0) ||
 			    (bytes_in_last_packet < pipe->max_packet))
-				cvmx_usb_perform_complete(usb, pipe,
-							  transaction,
-							  CVMX_USB_STATUS_SUCCESS);
+				cvmx_usb_complete(usb, pipe,
+						  transaction,
+						  CVMX_USB_STATUS_SUCCESS);
 		} else {
 			/*
 			 * Split transactions retry the split complete 4 times
@@ -2673,9 +2672,8 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			case CVMX_USB_STAGE_NON_CONTROL:
 			case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
 				/* This should be impossible */
-				cvmx_usb_perform_complete(usb, pipe,
-							  transaction,
-							  CVMX_USB_STATUS_ERROR);
+				cvmx_usb_complete(usb, pipe, transaction,
+						  CVMX_USB_STATUS_ERROR);
 				break;
 			case CVMX_USB_STAGE_SETUP:
 				pipe->pid_toggle = 1;
@@ -2747,15 +2745,14 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					transaction->stage =
 						CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;
 				else
-					cvmx_usb_perform_complete(usb, pipe,
-								  transaction,
-								  CVMX_USB_STATUS_SUCCESS);
-				break;
-			case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
-				cvmx_usb_perform_complete(usb, pipe,
+					cvmx_usb_complete(usb, pipe,
 							  transaction,
 							  CVMX_USB_STATUS_SUCCESS);
 				break;
+			case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
+				cvmx_usb_complete(usb, pipe, transaction,
+						  CVMX_USB_STATUS_SUCCESS);
+				break;
 			}
 			break;
 		case CVMX_USB_TRANSFER_BULK:
@@ -2781,10 +2778,9 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					    CVMX_USB_TRANSFER_INTERRUPT)
 						pipe->next_tx_frame +=
 							pipe->interval;
-					cvmx_usb_perform_complete(usb,
-								  pipe,
-								  transaction,
-								  CVMX_USB_STATUS_SUCCESS);
+					cvmx_usb_complete(usb, pipe,
+							  transaction,
+							  CVMX_USB_STATUS_SUCCESS);
 				}
 			} else {
 				if ((pipe->device_speed ==
@@ -2802,9 +2798,9 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					    CVMX_USB_TRANSFER_INTERRUPT)
 						pipe->next_tx_frame +=
 							pipe->interval;
-					cvmx_usb_perform_complete(usb, pipe,
-								  transaction,
-								  CVMX_USB_STATUS_SUCCESS);
+					cvmx_usb_complete(usb, pipe,
+							  transaction,
+							  CVMX_USB_STATUS_SUCCESS);
 				}
 			}
 			break;
@@ -2830,9 +2826,9 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					    (bytes_this_transfer < 188)) {
 						pipe->next_tx_frame +=
 							pipe->interval;
-						cvmx_usb_perform_complete(usb,
-									  pipe, transaction,
-									  CVMX_USB_STATUS_SUCCESS);
+						cvmx_usb_complete(usb, pipe,
+								  transaction,
+								  CVMX_USB_STATUS_SUCCESS);
 					}
 				} else {
 					if (transaction->stage ==
@@ -2848,10 +2844,10 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 						     pipe->max_packet)) {
 							pipe->next_tx_frame +=
 								pipe->interval;
-							cvmx_usb_perform_complete(usb,
-										  pipe,
-										  transaction,
-										  CVMX_USB_STATUS_SUCCESS);
+							cvmx_usb_complete(usb,
+									  pipe,
+									  transaction,
+									  CVMX_USB_STATUS_SUCCESS);
 						}
 					} else
 						transaction->stage =
@@ -2859,9 +2855,8 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				}
 			} else {
 				pipe->next_tx_frame += pipe->interval;
-				cvmx_usb_perform_complete(usb, pipe,
-							  transaction,
-							  CVMX_USB_STATUS_SUCCESS);
+				cvmx_usb_complete(usb, pipe, transaction,
+						  CVMX_USB_STATUS_SUCCESS);
 			}
 			break;
 		}
@@ -2897,8 +2892,8 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * We get channel halted interrupts with no result bits
 			 * sets when the cable is unplugged
 			 */
-			cvmx_usb_perform_complete(usb, pipe, transaction,
-						  CVMX_USB_STATUS_ERROR);
+			cvmx_usb_complete(usb, pipe, transaction,
+					  CVMX_USB_STATUS_ERROR);
 		}
 	}
 	return 0;

commit add3ea324c588b29da50ebddfa2a3e095965dd99
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:13:56 2016 +0200

    staging: octeon-usb: rename cvmx_usb_complete to cvmx_usb_status
    
    Rename cvmx_usb_complete to cvmx_usb_status.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 39854ab09e32..c6fd955b4287 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -99,35 +99,35 @@ enum cvmx_usb_direction {
 };
 
 /**
- * enum cvmx_usb_complete - possible callback function status codes
+ * enum cvmx_usb_status - possible callback function status codes
  *
- * @CVMX_USB_COMPLETE_SUCCESS:	  The transaction / operation finished without
+ * @CVMX_USB_STATUS_SUCCESS:	  The transaction / operation finished without
  *				  any errors
- * @CVMX_USB_COMPLETE_SHORT:	  FIXME: This is currently not implemented
- * @CVMX_USB_COMPLETE_CANCEL:	  The transaction was canceled while in flight
+ * @CVMX_USB_STATUS_SHORT:	  FIXME: This is currently not implemented
+ * @CVMX_USB_STATUS_CANCEL:	  The transaction was canceled while in flight
  *				  by a user call to cvmx_usb_cancel
- * @CVMX_USB_COMPLETE_ERROR:	  The transaction aborted with an unexpected
+ * @CVMX_USB_STATUS_ERROR:	  The transaction aborted with an unexpected
  *				  error status
- * @CVMX_USB_COMPLETE_STALL:	  The transaction received a USB STALL response
+ * @CVMX_USB_STATUS_STALL:	  The transaction received a USB STALL response
  *				  from the device
- * @CVMX_USB_COMPLETE_XACTERR:	  The transaction failed with an error from the
+ * @CVMX_USB_STATUS_XACTERR:	  The transaction failed with an error from the
  *				  device even after a number of retries
- * @CVMX_USB_COMPLETE_DATATGLERR: The transaction failed with a data toggle
+ * @CVMX_USB_STATUS_DATATGLERR:	  The transaction failed with a data toggle
  *				  error even after a number of retries
- * @CVMX_USB_COMPLETE_BABBLEERR:  The transaction failed with a babble error
- * @CVMX_USB_COMPLETE_FRAMEERR:	  The transaction failed with a frame error
+ * @CVMX_USB_STATUS_BABBLEERR:	  The transaction failed with a babble error
+ * @CVMX_USB_STATUS_FRAMEERR:	  The transaction failed with a frame error
  *				  even after a number of retries
  */
-enum cvmx_usb_complete {
-	CVMX_USB_COMPLETE_SUCCESS,
-	CVMX_USB_COMPLETE_SHORT,
-	CVMX_USB_COMPLETE_CANCEL,
-	CVMX_USB_COMPLETE_ERROR,
-	CVMX_USB_COMPLETE_STALL,
-	CVMX_USB_COMPLETE_XACTERR,
-	CVMX_USB_COMPLETE_DATATGLERR,
-	CVMX_USB_COMPLETE_BABBLEERR,
-	CVMX_USB_COMPLETE_FRAMEERR,
+enum cvmx_usb_status {
+	CVMX_USB_STATUS_SUCCESS,
+	CVMX_USB_STATUS_SHORT,
+	CVMX_USB_STATUS_CANCEL,
+	CVMX_USB_STATUS_ERROR,
+	CVMX_USB_STATUS_STALL,
+	CVMX_USB_STATUS_XACTERR,
+	CVMX_USB_STATUS_DATATGLERR,
+	CVMX_USB_STATUS_BABBLEERR,
+	CVMX_USB_STATUS_FRAMEERR,
 };
 
 /**
@@ -166,7 +166,7 @@ struct cvmx_usb_port_status {
 struct cvmx_usb_iso_packet {
 	int offset;
 	int length;
-	enum cvmx_usb_complete status;
+	enum cvmx_usb_status status;
 };
 
 /**
@@ -1954,7 +1954,7 @@ static void cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 }
 
 static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
-					     enum cvmx_usb_complete status,
+					     enum cvmx_usb_status status,
 					     struct cvmx_usb_pipe *pipe,
 					     struct cvmx_usb_transaction
 						*transaction,
@@ -1965,7 +1965,7 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 	struct usb_hcd *hcd = octeon_to_hcd(priv);
 	struct device *dev = hcd->self.controller;
 
-	if (likely(status == CVMX_USB_COMPLETE_SUCCESS))
+	if (likely(status == CVMX_USB_STATUS_SUCCESS))
 		urb->actual_length = bytes_transferred;
 	else
 		urb->actual_length = 0;
@@ -1986,7 +1986,7 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 		/* Recalculate the transfer size by adding up each packet */
 		urb->actual_length = 0;
 		for (i = 0; i < urb->number_of_packets; i++) {
-			if (iso_packet[i].status == CVMX_USB_COMPLETE_SUCCESS) {
+			if (iso_packet[i].status == CVMX_USB_STATUS_SUCCESS) {
 				urb->iso_frame_desc[i].status = 0;
 				urb->iso_frame_desc[i].actual_length =
 					iso_packet[i].length;
@@ -2006,32 +2006,32 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 	}
 
 	switch (status) {
-	case CVMX_USB_COMPLETE_SUCCESS:
+	case CVMX_USB_STATUS_SUCCESS:
 		urb->status = 0;
 		break;
-	case CVMX_USB_COMPLETE_CANCEL:
+	case CVMX_USB_STATUS_CANCEL:
 		if (urb->status == 0)
 			urb->status = -ENOENT;
 		break;
-	case CVMX_USB_COMPLETE_STALL:
+	case CVMX_USB_STATUS_STALL:
 		dev_dbg(dev, "status=stall pipe=%p transaction=%p size=%d\n",
 			pipe, transaction, bytes_transferred);
 		urb->status = -EPIPE;
 		break;
-	case CVMX_USB_COMPLETE_BABBLEERR:
+	case CVMX_USB_STATUS_BABBLEERR:
 		dev_dbg(dev, "status=babble pipe=%p transaction=%p size=%d\n",
 			pipe, transaction, bytes_transferred);
 		urb->status = -EPIPE;
 		break;
-	case CVMX_USB_COMPLETE_SHORT:
+	case CVMX_USB_STATUS_SHORT:
 		dev_dbg(dev, "status=short pipe=%p transaction=%p size=%d\n",
 			pipe, transaction, bytes_transferred);
 		urb->status = -EREMOTEIO;
 		break;
-	case CVMX_USB_COMPLETE_ERROR:
-	case CVMX_USB_COMPLETE_XACTERR:
-	case CVMX_USB_COMPLETE_DATATGLERR:
-	case CVMX_USB_COMPLETE_FRAMEERR:
+	case CVMX_USB_STATUS_ERROR:
+	case CVMX_USB_STATUS_XACTERR:
+	case CVMX_USB_STATUS_DATATGLERR:
+	case CVMX_USB_STATUS_FRAMEERR:
 		dev_dbg(dev, "status=%d pipe=%p transaction=%p size=%d\n",
 			status, pipe, transaction, bytes_transferred);
 		urb->status = -EPROTO;
@@ -2057,7 +2057,7 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 static void cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 				      struct cvmx_usb_pipe *pipe,
 				      struct cvmx_usb_transaction *transaction,
-				      enum cvmx_usb_complete complete_code)
+				      enum cvmx_usb_status complete_code)
 {
 	/* If this was a split then clear our split in progress marker */
 	if (usb->active_split == transaction)
@@ -2077,7 +2077,7 @@ static void cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 		 * next one
 		 */
 		if ((transaction->iso_number_packets > 1) &&
-		    (complete_code == CVMX_USB_COMPLETE_SUCCESS)) {
+		    (complete_code == CVMX_USB_STATUS_SUCCESS)) {
 			/* No bytes transferred for this packet as of yet */
 			transaction->actual_bytes = 0;
 			/* One less ISO waiting to transfer */
@@ -2326,7 +2326,7 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 		}
 	}
 	cvmx_usb_perform_complete(usb, pipe, transaction,
-				  CVMX_USB_COMPLETE_CANCEL);
+				  CVMX_USB_STATUS_CANCEL);
 	return 0;
 }
 
@@ -2588,7 +2588,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		 * such case we just need to fail every transaction.
 		 */
 		cvmx_usb_perform_complete(usb, pipe, transaction,
-					  CVMX_USB_COMPLETE_ERROR);
+					  CVMX_USB_STATUS_ERROR);
 		return 0;
 	}
 
@@ -2601,7 +2601,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		 */
 		pipe->pid_toggle = 0;
 		cvmx_usb_perform_complete(usb, pipe, transaction,
-					  CVMX_USB_COMPLETE_STALL);
+					  CVMX_USB_STATUS_STALL);
 	} else if (usbc_hcint.s.xacterr) {
 		/*
 		 * XactErr as a response means the device signaled
@@ -2609,15 +2609,15 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		 * toggle errors cause these.
 		 */
 		cvmx_usb_perform_complete(usb, pipe, transaction,
-					  CVMX_USB_COMPLETE_XACTERR);
+					  CVMX_USB_STATUS_XACTERR);
 	} else if (usbc_hcint.s.bblerr) {
 		/* Babble Error (BblErr) */
 		cvmx_usb_perform_complete(usb, pipe, transaction,
-					  CVMX_USB_COMPLETE_BABBLEERR);
+					  CVMX_USB_STATUS_BABBLEERR);
 	} else if (usbc_hcint.s.datatglerr) {
 		/* Data toggle error */
 		cvmx_usb_perform_complete(usb, pipe, transaction,
-					  CVMX_USB_COMPLETE_DATATGLERR);
+					  CVMX_USB_STATUS_DATATGLERR);
 	} else if (usbc_hcint.s.nyet) {
 		/*
 		 * NYET as a response is only allowed in three cases: as a
@@ -2635,7 +2635,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			    (bytes_in_last_packet < pipe->max_packet))
 				cvmx_usb_perform_complete(usb, pipe,
 							  transaction,
-							  CVMX_USB_COMPLETE_SUCCESS);
+							  CVMX_USB_STATUS_SUCCESS);
 		} else {
 			/*
 			 * Split transactions retry the split complete 4 times
@@ -2675,7 +2675,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				/* This should be impossible */
 				cvmx_usb_perform_complete(usb, pipe,
 							  transaction,
-							  CVMX_USB_COMPLETE_ERROR);
+							  CVMX_USB_STATUS_ERROR);
 				break;
 			case CVMX_USB_STAGE_SETUP:
 				pipe->pid_toggle = 1;
@@ -2749,12 +2749,12 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				else
 					cvmx_usb_perform_complete(usb, pipe,
 								  transaction,
-								  CVMX_USB_COMPLETE_SUCCESS);
+								  CVMX_USB_STATUS_SUCCESS);
 				break;
 			case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
 				cvmx_usb_perform_complete(usb, pipe,
 							  transaction,
-							  CVMX_USB_COMPLETE_SUCCESS);
+							  CVMX_USB_STATUS_SUCCESS);
 				break;
 			}
 			break;
@@ -2784,7 +2784,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					cvmx_usb_perform_complete(usb,
 								  pipe,
 								  transaction,
-								  CVMX_USB_COMPLETE_SUCCESS);
+								  CVMX_USB_STATUS_SUCCESS);
 				}
 			} else {
 				if ((pipe->device_speed ==
@@ -2804,7 +2804,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 							pipe->interval;
 					cvmx_usb_perform_complete(usb, pipe,
 								  transaction,
-								  CVMX_USB_COMPLETE_SUCCESS);
+								  CVMX_USB_STATUS_SUCCESS);
 				}
 			}
 			break;
@@ -2832,7 +2832,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 							pipe->interval;
 						cvmx_usb_perform_complete(usb,
 									  pipe, transaction,
-									  CVMX_USB_COMPLETE_SUCCESS);
+									  CVMX_USB_STATUS_SUCCESS);
 					}
 				} else {
 					if (transaction->stage ==
@@ -2851,7 +2851,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 							cvmx_usb_perform_complete(usb,
 										  pipe,
 										  transaction,
-										  CVMX_USB_COMPLETE_SUCCESS);
+										  CVMX_USB_STATUS_SUCCESS);
 						}
 					} else
 						transaction->stage =
@@ -2861,7 +2861,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				pipe->next_tx_frame += pipe->interval;
 				cvmx_usb_perform_complete(usb, pipe,
 							  transaction,
-							  CVMX_USB_COMPLETE_SUCCESS);
+							  CVMX_USB_STATUS_SUCCESS);
 			}
 			break;
 		}
@@ -2898,7 +2898,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * sets when the cable is unplugged
 			 */
 			cvmx_usb_perform_complete(usb, pipe, transaction,
-						  CVMX_USB_COMPLETE_ERROR);
+						  CVMX_USB_STATUS_ERROR);
 		}
 	}
 	return 0;
@@ -3178,8 +3178,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 					urb->iso_frame_desc[i].offset;
 				iso_packet[i].length =
 					urb->iso_frame_desc[i].length;
-				iso_packet[i].status =
-					CVMX_USB_COMPLETE_ERROR;
+				iso_packet[i].status = CVMX_USB_STATUS_ERROR;
 			}
 			/*
 			 * Store a pointer to the list in the URB setup_packet

commit 284ea26aaaceeb251b350d78faa19ecd2fa450ce
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:13:55 2016 +0200

    staging: octeon-usb: simplify if statement
    
    Simplify if statement to avoid deep nesting.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 726ec5d5013f..39854ab09e32 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2768,26 +2768,23 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 */
 			if (cvmx_usb_pipe_needs_split(usb, pipe)) {
 				if (transaction->stage ==
-				    CVMX_USB_STAGE_NON_CONTROL)
+				    CVMX_USB_STAGE_NON_CONTROL) {
 					transaction->stage =
 						CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
-				else {
-					if (buffer_space_left &&
-					    (bytes_in_last_packet ==
-					     pipe->max_packet))
-						transaction->stage =
-							CVMX_USB_STAGE_NON_CONTROL;
-					else {
-						if (transaction->type ==
-						    CVMX_USB_TRANSFER_INTERRUPT)
-							pipe->next_tx_frame +=
-								pipe->interval;
-							cvmx_usb_perform_complete(
-								usb,
-								pipe,
-								transaction,
-								CVMX_USB_COMPLETE_SUCCESS);
-					}
+				} else if (buffer_space_left &&
+					   (bytes_in_last_packet ==
+					   pipe->max_packet)) {
+					transaction->stage =
+						CVMX_USB_STAGE_NON_CONTROL;
+				} else {
+					if (transaction->type ==
+					    CVMX_USB_TRANSFER_INTERRUPT)
+						pipe->next_tx_frame +=
+							pipe->interval;
+					cvmx_usb_perform_complete(usb,
+								  pipe,
+								  transaction,
+								  CVMX_USB_COMPLETE_SUCCESS);
 				}
 			} else {
 				if ((pipe->device_speed ==

commit 25adcca6ec76a4136b54eb9fe80e3fce97c744f3
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:13:54 2016 +0200

    staging: octeon-usb: pass transfer type to find_ready_pipe
    
    Since we always search the same list, we can just pass the transfer type.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 0f5744e250cf..726ec5d5013f 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1839,14 +1839,15 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 /**
  * Find a pipe that is ready to be scheduled to hardware.
  * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @list:	 Pipe list to search
+ * @xfer_type:	 Transfer type
  *
  * Returns: Pipe or NULL if none are ready
  */
 static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(
 		struct cvmx_usb_state *usb,
-		struct list_head *list)
+		enum cvmx_usb_transfer xfer_type)
 {
+	struct list_head *list = usb->active_pipes + xfer_type;
 	u64 current_frame = usb->frame_number;
 	struct cvmx_usb_pipe *pipe;
 
@@ -1915,17 +1916,17 @@ static void cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 			 * beginning of the frame
 			 */
 			pipe = cvmx_usb_find_ready_pipe(usb,
-							usb->active_pipes + CVMX_USB_TRANSFER_ISOCHRONOUS);
+							CVMX_USB_TRANSFER_ISOCHRONOUS);
 			if (likely(!pipe))
 				pipe = cvmx_usb_find_ready_pipe(usb,
-								usb->active_pipes + CVMX_USB_TRANSFER_INTERRUPT);
+								CVMX_USB_TRANSFER_INTERRUPT);
 		}
 		if (likely(!pipe)) {
 			pipe = cvmx_usb_find_ready_pipe(usb,
-							usb->active_pipes + CVMX_USB_TRANSFER_CONTROL);
+							CVMX_USB_TRANSFER_CONTROL);
 			if (likely(!pipe))
 				pipe = cvmx_usb_find_ready_pipe(usb,
-								usb->active_pipes + CVMX_USB_TRANSFER_BULK);
+								CVMX_USB_TRANSFER_BULK);
 		}
 		if (!pipe)
 			break;

commit 38492ccbd1752ce1109e35ac2be33db65259f549
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:13:53 2016 +0200

    staging: octeon-usb: eliminate redundant parameter from find_ready_pipe
    
    current_frame always equals usb->frame_number.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index a2308029001e..0f5744e250cf 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1840,16 +1840,14 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
  * Find a pipe that is ready to be scheduled to hardware.
  * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @list:	 Pipe list to search
- * @current_frame:
- *		 Frame counter to use as a time reference.
  *
  * Returns: Pipe or NULL if none are ready
  */
 static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(
 		struct cvmx_usb_state *usb,
-		struct list_head *list,
-		u64 current_frame)
+		struct list_head *list)
 {
+	u64 current_frame = usb->frame_number;
 	struct cvmx_usb_pipe *pipe;
 
 	list_for_each_entry(pipe, list, node) {
@@ -1917,21 +1915,17 @@ static void cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 			 * beginning of the frame
 			 */
 			pipe = cvmx_usb_find_ready_pipe(usb,
-							usb->active_pipes + CVMX_USB_TRANSFER_ISOCHRONOUS,
-							usb->frame_number);
+							usb->active_pipes + CVMX_USB_TRANSFER_ISOCHRONOUS);
 			if (likely(!pipe))
 				pipe = cvmx_usb_find_ready_pipe(usb,
-								usb->active_pipes + CVMX_USB_TRANSFER_INTERRUPT,
-								usb->frame_number);
+								usb->active_pipes + CVMX_USB_TRANSFER_INTERRUPT);
 		}
 		if (likely(!pipe)) {
 			pipe = cvmx_usb_find_ready_pipe(usb,
-							usb->active_pipes + CVMX_USB_TRANSFER_CONTROL,
-							usb->frame_number);
+							usb->active_pipes + CVMX_USB_TRANSFER_CONTROL);
 			if (likely(!pipe))
 				pipe = cvmx_usb_find_ready_pipe(usb,
-								usb->active_pipes + CVMX_USB_TRANSFER_BULK,
-								usb->frame_number);
+								usb->active_pipes + CVMX_USB_TRANSFER_BULK);
 		}
 		if (!pipe)
 			break;

commit 68ea33801754b1da75e20842c2625802e9eeadbe
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:13:52 2016 +0200

    staging: octeon-usb: align split lines to match open parenthesis
    
    Align split lines to match open parenthesis.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 27a754202156..a2308029001e 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1106,8 +1106,8 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 	if (!pipe)
 		return NULL;
 	if ((device_speed == CVMX_USB_SPEED_HIGH) &&
-		(transfer_dir == CVMX_USB_DIRECTION_OUT) &&
-		(transfer_type == CVMX_USB_TRANSFER_BULK))
+	    (transfer_dir == CVMX_USB_DIRECTION_OUT) &&
+	    (transfer_type == CVMX_USB_TRANSFER_BULK))
 		pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
 	pipe->device_addr = device_addr;
 	pipe->endpoint_num = endpoint_num;
@@ -1325,7 +1325,7 @@ static void cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
 		return;
 
 	if ((hcchar.s.eptype == CVMX_USB_TRANSFER_INTERRUPT) ||
-		(hcchar.s.eptype == CVMX_USB_TRANSFER_ISOCHRONOUS))
+	    (hcchar.s.eptype == CVMX_USB_TRANSFER_ISOCHRONOUS))
 		fifo = &usb->periodic;
 	else
 		fifo = &usb->nonperiodic;
@@ -1555,8 +1555,8 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 			usbc_hcintmsk.s.xfercomplmsk = 1;
 		}
 		cvmx_usb_write_csr32(usb,
-				CVMX_USBCX_HCINTMSKX(channel, usb->index),
-				usbc_hcintmsk.u32);
+				     CVMX_USBCX_HCINTMSKX(channel, usb->index),
+				     usbc_hcintmsk.u32);
 
 		/* Enable the channel interrupt to propagate */
 		usbc_haintmsk.u32 = cvmx_usb_read_csr32(usb,
@@ -1643,10 +1643,9 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 			 * begin/middle/end of the data or all
 			 */
 			if (!usbc_hcsplt.s.compsplt &&
-				(pipe->transfer_dir ==
-				 CVMX_USB_DIRECTION_OUT) &&
-				(pipe->transfer_type ==
-				 CVMX_USB_TRANSFER_ISOCHRONOUS)) {
+			    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) &&
+			    (pipe->transfer_type ==
+			     CVMX_USB_TRANSFER_ISOCHRONOUS)) {
 				/*
 				 * Clear the split complete frame number as
 				 * there isn't going to be a split complete
@@ -1712,8 +1711,8 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 		if (packets_to_transfer == 0) {
 			packets_to_transfer = 1;
 		} else if ((packets_to_transfer > 1) &&
-				(usb->init_flags &
-				 CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
+			   (usb->init_flags &
+			    CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
 			/*
 			 * Limit to one packet when not using DMA. Channels must
 			 * be restarted between every packet for IN
@@ -1820,9 +1819,11 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 		break;
 	}
 	{
-		union cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 =
+		union cvmx_usbcx_hctsizx usbc_hctsiz = { .u32 =
 			cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_HCTSIZX(channel, usb->index))};
+					    CVMX_USBCX_HCTSIZX(channel,
+							       usb->index))
+		};
 		transaction->xfersize = usbc_hctsiz.s.xfersize;
 		transaction->pktcnt = usbc_hctsiz.s.pktcnt;
 	}
@@ -1856,11 +1857,11 @@ static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(
 			list_first_entry(&pipe->transactions, typeof(*t),
 					 node);
 		if (!(pipe->flags & CVMX_USB_PIPE_FLAGS_SCHEDULED) && t &&
-			(pipe->next_tx_frame <= current_frame) &&
-			((pipe->split_sc_frame == -1) ||
-			 ((((int)current_frame - (int)pipe->split_sc_frame)
-			   & 0x7f) < 0x40)) &&
-			(!usb->active_split || (usb->active_split == t))) {
+		    (pipe->next_tx_frame <= current_frame) &&
+		    ((pipe->split_sc_frame == -1) ||
+		     ((((int)current_frame - pipe->split_sc_frame) & 0x7f) <
+		      0x40)) &&
+		    (!usb->active_split || (usb->active_split == t))) {
 			prefetch(t);
 			return pipe;
 		}
@@ -1916,25 +1917,21 @@ static void cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 			 * beginning of the frame
 			 */
 			pipe = cvmx_usb_find_ready_pipe(usb,
-					usb->active_pipes +
-					CVMX_USB_TRANSFER_ISOCHRONOUS,
-					usb->frame_number);
+							usb->active_pipes + CVMX_USB_TRANSFER_ISOCHRONOUS,
+							usb->frame_number);
 			if (likely(!pipe))
 				pipe = cvmx_usb_find_ready_pipe(usb,
-						usb->active_pipes +
-						CVMX_USB_TRANSFER_INTERRUPT,
-						usb->frame_number);
+								usb->active_pipes + CVMX_USB_TRANSFER_INTERRUPT,
+								usb->frame_number);
 		}
 		if (likely(!pipe)) {
 			pipe = cvmx_usb_find_ready_pipe(usb,
-					usb->active_pipes +
-					CVMX_USB_TRANSFER_CONTROL,
-					usb->frame_number);
+							usb->active_pipes + CVMX_USB_TRANSFER_CONTROL,
+							usb->frame_number);
 			if (likely(!pipe))
 				pipe = cvmx_usb_find_ready_pipe(usb,
-						usb->active_pipes +
-						CVMX_USB_TRANSFER_BULK,
-						usb->frame_number);
+								usb->active_pipes + CVMX_USB_TRANSFER_BULK,
+								usb->frame_number);
 		}
 		if (!pipe)
 			break;
@@ -1949,7 +1946,7 @@ static void cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 	 */
 	need_sof = 0;
 	for (ttype = CVMX_USB_TRANSFER_CONTROL;
-			ttype <= CVMX_USB_TRANSFER_INTERRUPT; ttype++) {
+	     ttype <= CVMX_USB_TRANSFER_INTERRUPT; ttype++) {
 		list_for_each_entry(pipe, &usb->active_pipes[ttype], node) {
 			if (pipe->next_tx_frame > usb->frame_number) {
 				need_sof = 1;
@@ -1994,8 +1991,7 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 		/* Recalculate the transfer size by adding up each packet */
 		urb->actual_length = 0;
 		for (i = 0; i < urb->number_of_packets; i++) {
-			if (iso_packet[i].status ==
-					CVMX_USB_COMPLETE_SUCCESS) {
+			if (iso_packet[i].status == CVMX_USB_COMPLETE_SUCCESS) {
 				urb->iso_frame_desc[i].status = 0;
 				urb->iso_frame_desc[i].actual_length =
 					iso_packet[i].length;
@@ -2086,7 +2082,7 @@ static void cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 		 * next one
 		 */
 		if ((transaction->iso_number_packets > 1) &&
-			(complete_code == CVMX_USB_COMPLETE_SUCCESS)) {
+		    (complete_code == CVMX_USB_COMPLETE_SUCCESS)) {
 			/* No bytes transferred for this packet as of yet */
 			transaction->actual_bytes = 0;
 			/* One less ISO waiting to transfer */
@@ -2329,9 +2325,9 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 		if (usbc_hcchar.s.chena) {
 			usbc_hcchar.s.chdis = 1;
 			cvmx_usb_write_csr32(usb,
-					CVMX_USBCX_HCCHARX(pipe->channel,
-						usb->index),
-					usbc_hcchar.u32);
+					     CVMX_USBCX_HCCHARX(pipe->channel,
+								usb->index),
+					     usbc_hcchar.u32);
 		}
 	}
 	cvmx_usb_perform_complete(usb, pipe, transaction,
@@ -2442,9 +2438,9 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * write of HCCHARX without changing things
 			 */
 			cvmx_usb_write_csr32(usb,
-					CVMX_USBCX_HCCHARX(channel,
-							   usb->index),
-					usbc_hcchar.u32);
+					     CVMX_USBCX_HCCHARX(channel,
+								usb->index),
+					     usbc_hcchar.u32);
 			return 0;
 		}
 
@@ -2459,14 +2455,12 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				hcintmsk.u32 = 0;
 				hcintmsk.s.chhltdmsk = 1;
 				cvmx_usb_write_csr32(usb,
-						CVMX_USBCX_HCINTMSKX(channel,
-							usb->index),
-						hcintmsk.u32);
+						     CVMX_USBCX_HCINTMSKX(channel, usb->index),
+						     hcintmsk.u32);
 				usbc_hcchar.s.chdis = 1;
 				cvmx_usb_write_csr32(usb,
-						CVMX_USBCX_HCCHARX(channel,
-							usb->index),
-						usbc_hcchar.u32);
+						     CVMX_USBCX_HCCHARX(channel, usb->index),
+						     usbc_hcchar.u32);
 				return 0;
 			} else if (usbc_hcint.s.xfercompl) {
 				/*
@@ -2560,7 +2554,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	 * transferred
 	 */
 	if ((transaction->stage == CVMX_USB_STAGE_SETUP) ||
-		(transaction->stage == CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE))
+	    (transaction->stage == CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE))
 		bytes_this_transfer = 0;
 
 	/*
@@ -2588,8 +2582,8 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	 * will clear this flag
 	 */
 	if ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&
-		(pipe->transfer_type == CVMX_USB_TRANSFER_BULK) &&
-		(pipe->transfer_dir == CVMX_USB_DIRECTION_OUT))
+	    (pipe->transfer_type == CVMX_USB_TRANSFER_BULK) &&
+	    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT))
 		pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
 
 	if (unlikely(WARN_ON_ONCE(bytes_this_transfer < 0))) {
@@ -2643,10 +2637,10 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * again. Otherwise this transaction is complete
 			 */
 			if ((buffer_space_left == 0) ||
-				(bytes_in_last_packet < pipe->max_packet))
+			    (bytes_in_last_packet < pipe->max_packet))
 				cvmx_usb_perform_complete(usb, pipe,
-						transaction,
-						CVMX_USB_COMPLETE_SUCCESS);
+							  transaction,
+							  CVMX_USB_COMPLETE_SUCCESS);
 		} else {
 			/*
 			 * Split transactions retry the split complete 4 times
@@ -2685,7 +2679,8 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
 				/* This should be impossible */
 				cvmx_usb_perform_complete(usb, pipe,
-					transaction, CVMX_USB_COMPLETE_ERROR);
+							  transaction,
+							  CVMX_USB_COMPLETE_ERROR);
 				break;
 			case CVMX_USB_STAGE_SETUP:
 				pipe->pid_toggle = 1;
@@ -2734,8 +2729,8 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 								pipe->max_packet;
 					}
 				} else if ((buffer_space_left == 0) ||
-						(bytes_in_last_packet <
-						 pipe->max_packet)) {
+					   (bytes_in_last_packet <
+					    pipe->max_packet)) {
 					pipe->pid_toggle = 1;
 					transaction->stage =
 						CVMX_USB_STAGE_STATUS;
@@ -2743,8 +2738,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				break;
 			case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
 				if ((buffer_space_left == 0) ||
-						(bytes_in_last_packet <
-						 pipe->max_packet)) {
+				    (bytes_in_last_packet < pipe->max_packet)) {
 					pipe->pid_toggle = 1;
 					transaction->stage =
 						CVMX_USB_STAGE_STATUS;
@@ -2759,13 +2753,13 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 						CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;
 				else
 					cvmx_usb_perform_complete(usb, pipe,
-						transaction,
-						CVMX_USB_COMPLETE_SUCCESS);
+								  transaction,
+								  CVMX_USB_COMPLETE_SUCCESS);
 				break;
 			case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
 				cvmx_usb_perform_complete(usb, pipe,
-						transaction,
-						CVMX_USB_COMPLETE_SUCCESS);
+							  transaction,
+							  CVMX_USB_COMPLETE_SUCCESS);
 				break;
 			}
 			break;
@@ -2779,18 +2773,18 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 */
 			if (cvmx_usb_pipe_needs_split(usb, pipe)) {
 				if (transaction->stage ==
-						CVMX_USB_STAGE_NON_CONTROL)
+				    CVMX_USB_STAGE_NON_CONTROL)
 					transaction->stage =
 						CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
 				else {
 					if (buffer_space_left &&
-						(bytes_in_last_packet ==
-						 pipe->max_packet))
+					    (bytes_in_last_packet ==
+					     pipe->max_packet))
 						transaction->stage =
 							CVMX_USB_STAGE_NON_CONTROL;
 					else {
 						if (transaction->type ==
-							CVMX_USB_TRANSFER_INTERRUPT)
+						    CVMX_USB_TRANSFER_INTERRUPT)
 							pipe->next_tx_frame +=
 								pipe->interval;
 							cvmx_usb_perform_complete(
@@ -2802,7 +2796,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				}
 			} else {
 				if ((pipe->device_speed ==
-					CVMX_USB_SPEED_HIGH) &&
+				     CVMX_USB_SPEED_HIGH) &&
 				    (pipe->transfer_type ==
 				     CVMX_USB_TRANSFER_BULK) &&
 				    (pipe->transfer_dir ==
@@ -2811,15 +2805,14 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					pipe->flags |=
 						CVMX_USB_PIPE_FLAGS_NEED_PING;
 				if (!buffer_space_left ||
-					(bytes_in_last_packet <
-					 pipe->max_packet)) {
+				    (bytes_in_last_packet < pipe->max_packet)) {
 					if (transaction->type ==
-						CVMX_USB_TRANSFER_INTERRUPT)
+					    CVMX_USB_TRANSFER_INTERRUPT)
 						pipe->next_tx_frame +=
 							pipe->interval;
 					cvmx_usb_perform_complete(usb, pipe,
-						transaction,
-						CVMX_USB_COMPLETE_SUCCESS);
+								  transaction,
+								  CVMX_USB_COMPLETE_SUCCESS);
 				}
 			}
 			break;
@@ -2834,7 +2827,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				 * schedule interval
 				 */
 				if (pipe->transfer_dir ==
-					CVMX_USB_DIRECTION_OUT) {
+				    CVMX_USB_DIRECTION_OUT) {
 					/*
 					 * If no space left or this wasn't a max
 					 * size packet then this transfer is
@@ -2842,16 +2835,16 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					 * send the next 188 bytes
 					 */
 					if (!buffer_space_left ||
-						(bytes_this_transfer < 188)) {
+					    (bytes_this_transfer < 188)) {
 						pipe->next_tx_frame +=
 							pipe->interval;
 						cvmx_usb_perform_complete(usb,
-							pipe, transaction,
-							CVMX_USB_COMPLETE_SUCCESS);
+									  pipe, transaction,
+									  CVMX_USB_COMPLETE_SUCCESS);
 					}
 				} else {
 					if (transaction->stage ==
-						CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE) {
+					    CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE) {
 						/*
 						 * We are in the incoming data
 						 * phase. Keep getting data
@@ -2859,15 +2852,14 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 						 * get a small packet
 						 */
 						if ((buffer_space_left == 0) ||
-							(bytes_in_last_packet <
-							 pipe->max_packet)) {
+						    (bytes_in_last_packet <
+						     pipe->max_packet)) {
 							pipe->next_tx_frame +=
 								pipe->interval;
-							cvmx_usb_perform_complete(
-								usb,
-								pipe,
-								transaction,
-								CVMX_USB_COMPLETE_SUCCESS);
+							cvmx_usb_perform_complete(usb,
+										  pipe,
+										  transaction,
+										  CVMX_USB_COMPLETE_SUCCESS);
 						}
 					} else
 						transaction->stage =
@@ -2876,8 +2868,8 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			} else {
 				pipe->next_tx_frame += pipe->interval;
 				cvmx_usb_perform_complete(usb, pipe,
-						transaction,
-						CVMX_USB_COMPLETE_SUCCESS);
+							  transaction,
+							  CVMX_USB_COMPLETE_SUCCESS);
 			}
 			break;
 		}
@@ -2914,7 +2906,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * sets when the cable is unplugged
 			 */
 			cvmx_usb_perform_complete(usb, pipe, transaction,
-					CVMX_USB_COMPLETE_ERROR);
+						  CVMX_USB_COMPLETE_ERROR);
 		}
 	}
 	return 0;
@@ -2996,7 +2988,7 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 		octeon_usb_port_callback(usb);
 		/* Clear the port change bits */
 		usbc_hprt.u32 = cvmx_usb_read_csr32(usb,
-					CVMX_USBCX_HPRT(usb->index));
+						    CVMX_USBCX_HPRT(usb->index));
 		usbc_hprt.s.prtena = 0;
 		cvmx_usb_write_csr32(usb, CVMX_USBCX_HPRT(usb->index),
 				     usbc_hprt.u32);
@@ -3306,7 +3298,7 @@ static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
 }
 
 static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
-				u16 wIndex, char *buf, u16 wLength)
+				  u16 wIndex, char *buf, u16 wLength)
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	struct device *dev = hcd->self.controller;
@@ -3580,7 +3572,7 @@ static int octeon_usb_probe(struct platform_device *pdev)
 		break;
 	default:
 		dev_err(dev, "Illegal USBN \"clock-frequency\" %u\n",
-				clock_rate);
+			clock_rate);
 		return -ENXIO;
 	}
 

commit a2fcca426db1e3330a9a2f4a3f5ad04624ba108a
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Feb 26 02:13:51 2016 +0200

    staging: octeon-usb: use preferred style for NULL comparison
    
    Use preferred coding style for NULL comparison.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 1ec890625323..27a754202156 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3553,7 +3553,7 @@ static int octeon_usb_probe(struct platform_device *pdev)
 	const char *clock_type;
 	int i;
 
-	if (dev->of_node == NULL) {
+	if (!dev->of_node) {
 		dev_err(dev, "Error: empty of_node\n");
 		return -ENXIO;
 	}
@@ -3599,7 +3599,7 @@ static int octeon_usb_probe(struct platform_device *pdev)
 		initialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND;
 
 	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (res_mem == NULL) {
+	if (!res_mem) {
 		dev_err(dev, "found no memory resource\n");
 		return -ENXIO;
 	}

commit a89e28e3e20f141b777d544b9342be6864dd1577
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Wed Feb 17 00:22:18 2016 +0200

    staging: octeon-usb: make driver name to match the file name
    
    Make driver name to match the file name.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 68e42fe4d589..1ec890625323 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3719,7 +3719,7 @@ MODULE_DEVICE_TABLE(of, octeon_usb_match);
 
 static struct platform_driver octeon_usb_driver = {
 	.driver = {
-		.name       = "OcteonUSB",
+		.name		= "octeon-hcd",
 		.of_match_table = octeon_usb_match,
 	},
 	.probe      = octeon_usb_probe,

commit 3c98ef90f0053eda1782737042dcfaddd594baa6
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Wed Feb 17 00:22:17 2016 +0200

    staging: octeon-usb: add spaces around operator
    
    Add spaces around operator to improve readability.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 7c299e9eec36..68e42fe4d589 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -220,13 +220,13 @@ enum cvmx_usb_pipe_flags {
  * The low level hardware can transfer a maximum of this number of bytes in each
  * transfer. The field is 19 bits wide
  */
-#define MAX_TRANSFER_BYTES	((1<<19)-1)
+#define MAX_TRANSFER_BYTES	((1 << 19) - 1)
 
 /*
  * The low level hardware can transfer a maximum of this number of packets in
  * each transfer. The field is 10 bits wide
  */
-#define MAX_TRANSFER_PACKETS	((1<<10)-1)
+#define MAX_TRANSFER_PACKETS	((1 << 10) - 1)
 
 /**
  * Logical transactions may take numerous low level
@@ -336,7 +336,7 @@ struct cvmx_usb_tx_fifo {
 		int channel;
 		int size;
 		u64 address;
-	} entry[MAX_CHANNELS+1];
+	} entry[MAX_CHANNELS + 1];
 	int head;
 	int tail;
 };
@@ -417,7 +417,7 @@ struct octeon_hcd {
 
 /* Returns the IO address to push/pop stuff data from the FIFOs */
 #define USB_FIFO_ADDRESS(channel, usb_index) \
-	(CVMX_USBCX_GOTGCTL(usb_index) + ((channel)+1)*0x1000)
+	(CVMX_USBCX_GOTGCTL(usb_index) + ((channel) + 1) * 0x1000)
 
 /**
  * struct octeon_temp_buffer - a bounce buffer for USB transfers
@@ -1124,9 +1124,9 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 	if (!interval)
 		interval = 1;
 	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
-		pipe->interval = interval*8;
+		pipe->interval = interval * 8;
 		/* Force start splits to be schedule on uFrame 0 */
-		pipe->next_tx_frame = ((usb->frame_number+7)&~7) +
+		pipe->next_tx_frame = ((usb->frame_number + 7) & ~7) +
 					pipe->interval;
 	} else {
 		pipe->interval = interval;
@@ -1334,7 +1334,7 @@ static void cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
 	fifo->entry[fifo->head].address =
 		cvmx_read64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +
 				   channel * 8);
-	fifo->entry[fifo->head].size = (usbc_hctsiz.s.xfersize+3)>>2;
+	fifo->entry[fifo->head].size = (usbc_hctsiz.s.xfersize + 3) >> 2;
 	fifo->head++;
 	if (fifo->head > MAX_CHANNELS)
 		fifo->head = 0;
@@ -1515,7 +1515,7 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 	pipe->flags |= CVMX_USB_PIPE_FLAGS_SCHEDULED;
 
 	/* Mark this channel as in use */
-	usb->idle_hardware_channels &= ~(1<<channel);
+	usb->idle_hardware_channels &= ~(1 << channel);
 
 	/* Enable the channel interrupt bits */
 	{
@@ -1561,7 +1561,7 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 		/* Enable the channel interrupt to propagate */
 		usbc_haintmsk.u32 = cvmx_usb_read_csr32(usb,
 					CVMX_USBCX_HAINTMSK(usb->index));
-		usbc_haintmsk.s.haintmsk |= 1<<channel;
+		usbc_haintmsk.s.haintmsk |= 1 << channel;
 		cvmx_usb_write_csr32(usb, CVMX_USBCX_HAINTMSK(usb->index),
 				     usbc_haintmsk.u32);
 	}
@@ -1612,7 +1612,7 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 			 * We only store the lower two bits since the time ahead
 			 * can only be two frames
 			 */
-			if ((transaction->stage&1) == 0) {
+			if ((transaction->stage & 1) == 0) {
 				if (transaction->type == CVMX_USB_TRANSFER_BULK)
 					pipe->split_sc_frame =
 						(usb->frame_number + 1) & 0x7f;
@@ -1760,7 +1760,7 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 		 * Set the startframe odd/even properly. This is only used for
 		 * periodic
 		 */
-		usbc_hcchar.s.oddfrm = usb->frame_number&1;
+		usbc_hcchar.s.oddfrm = usb->frame_number & 1;
 
 		/*
 		 * Set the number of back to back packets allowed by this
@@ -1897,7 +1897,7 @@ static void cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 						CVMX_USBCX_HFIR(usb->index))
 		};
 
-		if (hfnum.s.frrem < hfir.s.frint/4)
+		if (hfnum.s.frrem < hfir.s.frint / 4)
 			goto done;
 	}
 
@@ -2490,7 +2490,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 
 	/* Disable the channel interrupts now that it is done */
 	cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
-	usb->idle_hardware_channels |= (1<<channel);
+	usb->idle_hardware_channels |= (1 << channel);
 
 	/* Make sure this channel is tied to a valid pipe */
 	pipe = usb->pipe_for_channel[channel];
@@ -2948,7 +2948,7 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 
 	/* Update the frame counter */
 	usbc_hfnum.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
-	if ((usb->frame_number&0x3fff) > usbc_hfnum.s.frnum)
+	if ((usb->frame_number & 0x3fff) > usbc_hfnum.s.frnum)
 		usb->frame_number += 0x4000;
 	usb->frame_number &= ~0x3fffull;
 	usb->frame_number |= usbc_hfnum.s.frnum;
@@ -3023,7 +3023,7 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 
 			channel = __fls(usbc_haint.u32);
 			cvmx_usb_poll_channel(usb, channel);
-			usbc_haint.u32 ^= 1<<channel;
+			usbc_haint.u32 ^= 1 << channel;
 		}
 	}
 

commit cce66005b41a6bfbb257594321b75d045501dd2e
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Wed Feb 17 00:22:16 2016 +0200

    staging: octeon-usb: switch to use kernel types
    
    Switch to use kernel types:
    
            uint64_t -> u64
            uint32_t -> u32
            uint16_t -> u16
            uint8_t  -> u8
            int8_t   -> s8
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 316584997912..7c299e9eec36 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -146,13 +146,13 @@ enum cvmx_usb_complete {
  *			status call.
  */
 struct cvmx_usb_port_status {
-	uint32_t reserved		: 25;
-	uint32_t port_enabled		: 1;
-	uint32_t port_over_current	: 1;
-	uint32_t port_powered		: 1;
+	u32 reserved			: 25;
+	u32 port_enabled		: 1;
+	u32 port_over_current		: 1;
+	u32 port_powered		: 1;
 	enum cvmx_usb_speed port_speed	: 2;
-	uint32_t connected		: 1;
-	uint32_t connect_change		: 1;
+	u32 connected			: 1;
+	u32 connect_change		: 1;
 };
 
 /**
@@ -270,9 +270,9 @@ enum cvmx_usb_stage {
 struct cvmx_usb_transaction {
 	struct list_head node;
 	enum cvmx_usb_transfer type;
-	uint64_t buffer;
+	u64 buffer;
 	int buffer_length;
-	uint64_t control_header;
+	u64 control_header;
 	int iso_start_frame;
 	int iso_number_packets;
 	struct cvmx_usb_iso_packet *iso_packets;
@@ -314,28 +314,28 @@ struct cvmx_usb_transaction {
 struct cvmx_usb_pipe {
 	struct list_head node;
 	struct list_head transactions;
-	uint64_t interval;
-	uint64_t next_tx_frame;
+	u64 interval;
+	u64 next_tx_frame;
 	enum cvmx_usb_pipe_flags flags;
 	enum cvmx_usb_speed device_speed;
 	enum cvmx_usb_transfer transfer_type;
 	enum cvmx_usb_direction transfer_dir;
 	int multi_count;
-	uint16_t max_packet;
-	uint8_t device_addr;
-	uint8_t endpoint_num;
-	uint8_t hub_device_addr;
-	uint8_t hub_port;
-	uint8_t pid_toggle;
-	uint8_t channel;
-	int8_t split_sc_frame;
+	u16 max_packet;
+	u8 device_addr;
+	u8 endpoint_num;
+	u8 hub_device_addr;
+	u8 hub_port;
+	u8 pid_toggle;
+	u8 channel;
+	s8 split_sc_frame;
 };
 
 struct cvmx_usb_tx_fifo {
 	struct {
 		int channel;
 		int size;
-		uint64_t address;
+		u64 address;
 	} entry[MAX_CHANNELS+1];
 	int head;
 	int tail;
@@ -368,7 +368,7 @@ struct cvmx_usb_state {
 	struct cvmx_usb_port_status port_status;
 	struct list_head idle_pipes;
 	struct list_head active_pipes[4];
-	uint64_t frame_number;
+	u64 frame_number;
 	struct cvmx_usb_transaction *active_split;
 	struct cvmx_usb_tx_fifo periodic;
 	struct cvmx_usb_tx_fifo nonperiodic;
@@ -383,8 +383,8 @@ struct octeon_hcd {
 #define CVMX_WAIT_FOR_FIELD32(address, _union, cond, timeout_usec)	    \
 	({int result;							    \
 	do {								    \
-		uint64_t done = cvmx_get_cycle() + (uint64_t)timeout_usec * \
-			octeon_get_clock_rate() / 1000000;		    \
+		u64 done = cvmx_get_cycle() + (u64)timeout_usec *	    \
+			   octeon_get_clock_rate() / 1000000;		    \
 		union _union c;						    \
 									    \
 		while (1) {						    \
@@ -548,10 +548,9 @@ static void octeon_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
  *
  * Returns: Result of the read
  */
-static inline uint32_t cvmx_usb_read_csr32(struct cvmx_usb_state *usb,
-					   uint64_t address)
+static inline u32 cvmx_usb_read_csr32(struct cvmx_usb_state *usb, u64 address)
 {
-	uint32_t result = cvmx_read64_uint32(address ^ 4);
+	u32 result = cvmx_read64_uint32(address ^ 4);
 	return result;
 }
 
@@ -565,7 +564,7 @@ static inline uint32_t cvmx_usb_read_csr32(struct cvmx_usb_state *usb,
  * @value:   Value to write
  */
 static inline void cvmx_usb_write_csr32(struct cvmx_usb_state *usb,
-					uint64_t address, uint32_t value)
+					u64 address, u32 value)
 {
 	cvmx_write64_uint32(address ^ 4, value);
 	cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
@@ -1160,8 +1159,8 @@ static void cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
 	union cvmx_usbcx_grxstsph rx_status;
 	int channel;
 	int bytes;
-	uint64_t address;
-	uint32_t *ptr;
+	u64 address;
+	u32 *ptr;
 
 	rx_status.u32 = cvmx_usb_read_csr32(usb,
 					    CVMX_USBCX_GRXSTSPH(usb->index));
@@ -1214,9 +1213,9 @@ static int cvmx_usb_fill_tx_hw(struct cvmx_usb_state *usb,
 	 */
 	while (available && (fifo->head != fifo->tail)) {
 		int i = fifo->tail;
-		const uint32_t *ptr = cvmx_phys_to_ptr(fifo->entry[i].address);
-		uint64_t csr_address = USB_FIFO_ADDRESS(fifo->entry[i].channel,
-							usb->index) ^ 4;
+		const u32 *ptr = cvmx_phys_to_ptr(fifo->entry[i].address);
+		u64 csr_address = USB_FIFO_ADDRESS(fifo->entry[i].channel,
+						   usb->index) ^ 4;
 		int words = available;
 
 		/* Limit the amount of data to what the SW fifo has */
@@ -1569,9 +1568,9 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 
 	/* Setup the location the DMA engine uses. */
 	{
-		uint64_t reg;
-		uint64_t dma_address = transaction->buffer +
-					transaction->actual_bytes;
+		u64 reg;
+		u64 dma_address = transaction->buffer +
+				  transaction->actual_bytes;
 
 		if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
 			dma_address = transaction->buffer +
@@ -1848,7 +1847,7 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(
 		struct cvmx_usb_state *usb,
 		struct list_head *list,
-		uint64_t current_frame)
+		u64 current_frame)
 {
 	struct cvmx_usb_pipe *pipe;
 
@@ -2136,9 +2135,9 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_transaction(
 				struct cvmx_usb_state *usb,
 				struct cvmx_usb_pipe *pipe,
 				enum cvmx_usb_transfer type,
-				uint64_t buffer,
+				u64 buffer,
 				int buffer_length,
-				uint64_t control_header,
+				u64 control_header,
 				int iso_start_frame,
 				int iso_number_packets,
 				struct cvmx_usb_iso_packet *iso_packets,
@@ -2248,7 +2247,7 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_control(
 						struct urb *urb)
 {
 	int buffer_length = urb->transfer_buffer_length;
-	uint64_t control_header = urb->setup_dma;
+	u64 control_header = urb->setup_dma;
 	struct usb_ctrlrequest *header = cvmx_phys_to_ptr(control_header);
 
 	if ((header->bRequestType & USB_DIR_IN) == 0)

commit 466657314b2357a123409da59bd32ca0bd0cd390
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Wed Feb 17 00:22:15 2016 +0200

    staging: octeon-usb: clean up includes
    
    Clean up includes.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 010b861439f5..316584997912 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -43,29 +43,15 @@
  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR
  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
  */
-#include <linux/kernel.h>
+
+#include <linux/usb.h>
+#include <linux/slab.h>
 #include <linux/module.h>
-#include <linux/init.h>
-#include <linux/pci.h>
+#include <linux/usb/hcd.h>
 #include <linux/prefetch.h>
-#include <linux/interrupt.h>
 #include <linux/platform_device.h>
-#include <linux/usb.h>
-
-#include <linux/time.h>
-#include <linux/delay.h>
-
-#include <asm/octeon/cvmx.h>
-#include <asm/octeon/cvmx-iob-defs.h>
-
-#include <linux/usb/hcd.h>
-
-#include <linux/err.h>
 
 #include <asm/octeon/octeon.h>
-#include <asm/octeon/cvmx-helper.h>
-#include <asm/octeon/cvmx-sysinfo.h>
-#include <asm/octeon/cvmx-helper-board.h>
 
 #include "octeon-hcd.h"
 

commit ec7c4d7d52c6465f2640240f30722c29b6c3a5af
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Wed Feb 17 00:22:14 2016 +0200

    staging: octeon-usb: delete space after cast
    
    Delete space after cast.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 28726535500c..010b861439f5 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2005,7 +2005,7 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 		 * field.
 		 */
 		struct cvmx_usb_iso_packet *iso_packet =
-			(struct cvmx_usb_iso_packet *) urb->setup_packet;
+			(struct cvmx_usb_iso_packet *)urb->setup_packet;
 		/* Recalculate the transfer size by adding up each packet */
 		urb->actual_length = 0;
 		for (i = 0; i < urb->number_of_packets; i++) {
@@ -2294,7 +2294,7 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_isochronous(
 {
 	struct cvmx_usb_iso_packet *packets;
 
-	packets = (struct cvmx_usb_iso_packet *) urb->setup_packet;
+	packets = (struct cvmx_usb_iso_packet *)urb->setup_packet;
 	return cvmx_usb_submit_transaction(usb, pipe,
 					   CVMX_USB_TRANSFER_ISOCHRONOUS,
 					   urb->transfer_dma,
@@ -3433,7 +3433,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		break;
 	case GetHubStatus:
 		dev_dbg(dev, "GetHubStatus\n");
-		*(__le32 *) buf = 0;
+		*(__le32 *)buf = 0;
 		break;
 	case GetPortStatus:
 		dev_dbg(dev, "GetPortStatus\n");
@@ -3485,7 +3485,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			dev_dbg(dev, " LOWSPEED\n");
 		}
 
-		*((__le32 *) buf) = cpu_to_le32(port_status);
+		*((__le32 *)buf) = cpu_to_le32(port_status);
 		break;
 	case SetHubFeature:
 		dev_dbg(dev, "SetHubFeature\n");

commit 6de14f12c31d4462e8963897b39d00704ccefaab
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Wed Feb 17 00:22:13 2016 +0200

    staging: octeon-usb: add missing braces
    
    Some if branches are missing braces as required by coding style.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 91fce2cd75a5..28726535500c 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1480,9 +1480,9 @@ static void cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 	 */
 	packets_to_transfer = DIV_ROUND_UP(bytes_to_transfer,
 					   pipe->max_packet);
-	if (packets_to_transfer == 0)
+	if (packets_to_transfer == 0) {
 		packets_to_transfer = 1;
-	else if ((packets_to_transfer > 1) &&
+	} else if ((packets_to_transfer > 1) &&
 			(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
 		/*
 		 * Limit to one packet when not using DMA. Channels must be
@@ -1634,8 +1634,9 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 				else
 					pipe->split_sc_frame =
 						(usb->frame_number + 2) & 0x7f;
-			} else
+			} else {
 				pipe->split_sc_frame = -1;
+			}
 
 			usbc_hcsplt.s.spltena = 1;
 			usbc_hcsplt.s.hubaddr = pipe->hub_device_addr;
@@ -1723,9 +1724,9 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 		 */
 		packets_to_transfer =
 			DIV_ROUND_UP(bytes_to_transfer, pipe->max_packet);
-		if (packets_to_transfer == 0)
+		if (packets_to_transfer == 0) {
 			packets_to_transfer = 1;
-		else if ((packets_to_transfer > 1) &&
+		} else if ((packets_to_transfer > 1) &&
 				(usb->init_flags &
 				 CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
 			/*

commit c9d19612e828749d170b224dbdace542089db83e
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Wed Feb 17 00:22:12 2016 +0200

    staging: octeon-usb: delete redundant blank lines
    
    Delete redundant blank lines.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index eaf6ded40990..91fce2cd75a5 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -569,7 +569,6 @@ static inline uint32_t cvmx_usb_read_csr32(struct cvmx_usb_state *usb,
 	return result;
 }
 
-
 /**
  * Write a USB 32bit CSR. It performs the necessary address
  * swizzle for 32bit CSRs and logs the value in a readable format
@@ -602,7 +601,6 @@ static inline int cvmx_usb_pipe_needs_split(struct cvmx_usb_state *usb,
 	       usb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_HIGH;
 }
 
-
 /**
  * Trivial utility function to return the correct PID for a pipe
  *
@@ -1002,7 +1000,6 @@ static void cvmx_usb_reset_port(struct cvmx_usb_state *usb)
 						  CVMX_USBCX_HPRT(usb->index));
 }
 
-
 /**
  * Disable a USB port. After this call the USB port will not
  * generate data transfers and will not generate events.
@@ -1021,7 +1018,6 @@ static int cvmx_usb_disable(struct cvmx_usb_state *usb)
 	return 0;
 }
 
-
 /**
  * Get the current state of the USB port. Use this call to
  * determine if the usb port has anything connected, is enabled,
@@ -1166,7 +1162,6 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 	return pipe;
 }
 
-
 /**
  * Poll the RX FIFOs and remove data as needed. This function is only used
  * in non DMA mode. It is very important that this function be called quickly
@@ -1213,7 +1208,6 @@ static void cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
 	CVMX_SYNCW;
 }
 
-
 /**
  * Fill the TX hardware fifo with data out of the software
  * fifos
@@ -1275,7 +1269,6 @@ static int cvmx_usb_fill_tx_hw(struct cvmx_usb_state *usb,
 	return fifo->head != fifo->tail;
 }
 
-
 /**
  * Check the hardware FIFOs and fill them as needed
  *
@@ -1312,7 +1305,6 @@ static void cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
 	}
 }
 
-
 /**
  * Fill the TX FIFO with an outgoing packet
  *
@@ -1515,7 +1507,6 @@ static void cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 			     usbc_hctsiz.u32);
 }
 
-
 /**
  * Start a channel to perform the pipe's head transaction
  *
@@ -1858,7 +1849,6 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 		cvmx_usb_fill_tx_fifo(usb, channel);
 }
 
-
 /**
  * Find a pipe that is ready to be scheduled to hardware.
  * @usb:	 USB device state populated by cvmx_usb_initialize().
@@ -1892,7 +1882,6 @@ static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(
 	return NULL;
 }
 
-
 /**
  * Called whenever a pipe might need to be scheduled to the
  * hardware.
@@ -2134,7 +2123,6 @@ static void cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 	kfree(transaction);
 }
 
-
 /**
  * Submit a usb transaction to a pipe. Called for all types
  * of transactions.
@@ -2209,7 +2197,6 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_transaction(
 	return transaction;
 }
 
-
 /**
  * Call to submit a USB Bulk transfer to a pipe.
  *
@@ -2234,7 +2221,6 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_bulk(
 					   urb);
 }
 
-
 /**
  * Call to submit a USB Interrupt transfer to a pipe.
  *
@@ -2260,7 +2246,6 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_interrupt(
 					   urb);
 }
 
-
 /**
  * Call to submit a USB Control transfer to a pipe.
  *
@@ -2292,7 +2277,6 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_control(
 					   urb);
 }
 
-
 /**
  * Call to submit a USB Isochronous transfer to a pipe.
  *
@@ -2320,7 +2304,6 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_isochronous(
 					   packets, urb);
 }
 
-
 /**
  * Cancel one outstanding request in a pipe. Canceling a request
  * can fail if the transaction has already completed before cancel
@@ -2370,7 +2353,6 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 	return 0;
 }
 
-
 /**
  * Cancel all outstanding requests in a pipe. Logically all this
  * does is call cvmx_usb_cancel() in a loop.
@@ -2395,7 +2377,6 @@ static int cvmx_usb_cancel_all(struct cvmx_usb_state *usb,
 	return 0;
 }
 
-
 /**
  * Close a pipe created with cvmx_usb_open_pipe().
  *
@@ -2437,7 +2418,6 @@ static int cvmx_usb_get_frame_number(struct cvmx_usb_state *usb)
 	return frame_number;
 }
 
-
 /**
  * Poll a channel for status
  *
@@ -3616,7 +3596,6 @@ static int octeon_usb_probe(struct platform_device *pdev)
 		dev_err(dev, "Illegal USBN \"clock-frequency\" %u\n",
 				clock_rate);
 		return -ENXIO;
-
 	}
 
 	i = of_property_read_string(usbn_node,

commit bb778553d491b65310b83c55274a2f09912d47a1
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Feb 14 02:47:28 2016 +0200

    staging: octeon-usb: support official bindings
    
    Support official DT bindings alongside with the deprecated ones.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 7844e2036060..eaf6ded40990 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3594,9 +3594,12 @@ static int octeon_usb_probe(struct platform_device *pdev)
 	usbn_node = dev->of_node->parent;
 
 	i = of_property_read_u32(usbn_node,
-				 "refclk-frequency", &clock_rate);
+				 "clock-frequency", &clock_rate);
+	if (i)
+		i = of_property_read_u32(usbn_node,
+					 "refclk-frequency", &clock_rate);
 	if (i) {
-		dev_err(dev, "No USBN \"refclk-frequency\"\n");
+		dev_err(dev, "No USBN \"clock-frequency\"\n");
 		return -ENXIO;
 	}
 	switch (clock_rate) {
@@ -3610,14 +3613,17 @@ static int octeon_usb_probe(struct platform_device *pdev)
 		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ;
 		break;
 	default:
-		dev_err(dev, "Illebal USBN \"refclk-frequency\" %u\n",
+		dev_err(dev, "Illegal USBN \"clock-frequency\" %u\n",
 				clock_rate);
 		return -ENXIO;
 
 	}
 
 	i = of_property_read_string(usbn_node,
-				    "refclk-type", &clock_type);
+				    "cavium,refclk-type", &clock_type);
+	if (i)
+		i = of_property_read_string(usbn_node,
+					    "refclk-type", &clock_type);
 
 	if (!i && strcmp("crystal", clock_type) == 0)
 		is_crystal_clock = true;

commit 1d5047c981f2e5a0fe6003c98b9c742c349d75a3
Author: Janani Ravichandran <janani.rvchndrn@gmail.com>
Date:   Thu Feb 11 16:33:15 2016 -0500

    staging: octeon: Remove unneeded parentheses in assignment
    
    Remove parentheses around the right hand side of assignments as they are
    not needed. Semantic patch used:
    
    @@
    expression a, b, c;
    @@
    
    (
      a = (b == c)
    |
      a =
    - (
      b
    - )
    )
    
    Signed-off-by: Janani Ravichandran <janani.rvchndrn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 16d45879d0c4..7844e2036060 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1048,7 +1048,7 @@ static struct cvmx_usb_port_status cvmx_usb_get_status(
 	result.port_speed = usbc_hprt.s.prtspd;
 	result.connected = usbc_hprt.s.prtconnsts;
 	result.connect_change =
-		(result.connected != usb->port_status.connected);
+		result.connected != usb->port_status.connected;
 
 	return result;
 }

commit edb0d9d4a3fe65cb08dab750b4ad6c2ae5d65d50
Author: Saatvik Arya <aryasaatvik@gmail.com>
Date:   Sun Jan 3 22:42:40 2016 +0530

    drivers: staging: octeon-usb: octeon-hcd.c: fixed coding style related warnings
    
    fixed coding style warnings related to comment blocks
    
    Signed-off-by: Saatvik Arya <aryasaatvik@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 6f2871784ba5..16d45879d0c4 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2006,7 +2006,8 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 	urb->hcpriv = NULL;
 
 	/* For Isochronous transactions we need to update the URB packet status
-	   list from data in our private copy */
+	 * list from data in our private copy
+	 */
 	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
 		int i;
 		/*

commit 73eee567cbdc3e2f70843a1090786ceb0391061e
Author: Cristina Moraru <cristina.moraru09@gmail.com>
Date:   Wed Oct 21 20:00:50 2015 +0300

    staging: octeon-usb: Replace kmalloc with kmalloc_array
    
    Replace kmalloc with specialized function kmalloc_array
    when the size is a multiplication of:
            number_of_elements * size_of_element
    
    Signed-off-by: Cristina Moraru <cristina.moraru09@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 61940284311c..6f2871784ba5 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3216,9 +3216,9 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		 * Allocate a structure to use for our private list of
 		 * isochronous packets.
 		 */
-		iso_packet = kmalloc(urb->number_of_packets *
-				     sizeof(struct cvmx_usb_iso_packet),
-				     GFP_ATOMIC);
+		iso_packet = kmalloc_array(urb->number_of_packets,
+					   sizeof(struct cvmx_usb_iso_packet),
+					   GFP_ATOMIC);
 		if (iso_packet) {
 			int i;
 			/* Fill the list with the data from the URB */

commit 1972308bf580ad092c315ad21700946320ab54f7
Author: Luis de Bethencourt <luis@debethencourt.com>
Date:   Thu Sep 3 13:13:51 2015 +0200

    staging: octeon-usb: Fix module autoload for OF platform driver
    
    This platform driver has a OF device ID table but the OF module
    alias information is not created so module autoloading won't work.
    
    Signed-off-by: Luis de Bethencourt <luis@debethencourt.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 9bd73ea5a1fa..61940284311c 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3743,6 +3743,7 @@ static const struct of_device_id octeon_usb_match[] = {
 	},
 	{},
 };
+MODULE_DEVICE_TABLE(of, octeon_usb_match);
 
 static struct platform_driver octeon_usb_driver = {
 	.driver = {

commit 69e98df78271a71b688706dccf2ad4544d63a274
Author: Carlos E. Garcia <carlos@cgarcia.org>
Date:   Fri Apr 24 09:40:42 2015 -0400

    Staging: fixed multiple spelling errors.
    
    Fixed multiple spelling errors.
    
    Signed-off-by: Carlos E. Garcia <carlos@cgarcia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index cdb0981be2e9..9bd73ea5a1fa 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1239,7 +1239,7 @@ static int cvmx_usb_fill_tx_hw(struct cvmx_usb_state *usb,
 							usb->index) ^ 4;
 		int words = available;
 
-		/* Limit the amount of data to waht the SW fifo has */
+		/* Limit the amount of data to what the SW fifo has */
 		if (fifo->entry[i].size <= available) {
 			words = fifo->entry[i].size;
 			fifo->tail++;
@@ -1849,7 +1849,7 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 		transaction->xfersize = usbc_hctsiz.s.xfersize;
 		transaction->pktcnt = usbc_hctsiz.s.pktcnt;
 	}
-	/* Remeber when we start a split transaction */
+	/* Remember when we start a split transaction */
 	if (cvmx_usb_pipe_needs_split(usb, pipe))
 		usb->active_split = transaction;
 	USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),

commit b97c3c1a0b538a61fb1cab057738ccb64ae51e4d
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Apr 23 16:06:52 2015 +0200

    staging: octeon-usb: fix unaligned isochronous transfers
    
    Make sure to copy the whole transfer buffer when releasing the temporary
    buffer used for unaligned isochronous transfers as the data is not
    necessarily contiguous in that case.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 9e5476e352b4..cdb0981be2e9 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -499,15 +499,21 @@ static int octeon_alloc_temp_buffer(struct urb *urb, gfp_t mem_flags)
 static void octeon_free_temp_buffer(struct urb *urb)
 {
 	struct octeon_temp_buffer *temp;
+	size_t length;
 
 	if (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))
 		return;
 
 	temp = container_of(urb->transfer_buffer, struct octeon_temp_buffer,
 			    data);
-	if (usb_urb_dir_in(urb))
-		memcpy(temp->orig_buffer, urb->transfer_buffer,
-		       urb->actual_length);
+	if (usb_urb_dir_in(urb)) {
+		if (usb_pipeisoc(urb->pipe))
+			length = urb->transfer_buffer_length;
+		else
+			length = urb->actual_length;
+
+		memcpy(temp->orig_buffer, urb->transfer_buffer, length);
+	}
 	urb->transfer_buffer = temp->orig_buffer;
 	urb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;
 	kfree(temp);

commit 203d77621405345c1f3ffc4c1db3f7ff89571b58
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sat Mar 28 21:24:34 2015 +0200

    staging: octeon-usb: make CVMX_WAIT_FOR_FIELD32 to take condition expression
    
    Make CVMX_WAIT_FOR_FIELD32 to take full condition expression.
    This should make the usage simpler, and the macro more readable.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 3e89265d10d8..9e5476e352b4 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -393,8 +393,8 @@ struct octeon_hcd {
 	struct cvmx_usb_state usb;
 };
 
-/* This macro spins on a field waiting for it to reach a value */
-#define CVMX_WAIT_FOR_FIELD32(address, _union, field, op, value, timeout_usec)\
+/* This macro spins on a register waiting for it to reach a condition. */
+#define CVMX_WAIT_FOR_FIELD32(address, _union, cond, timeout_usec)	    \
 	({int result;							    \
 	do {								    \
 		uint64_t done = cvmx_get_cycle() + (uint64_t)timeout_usec * \
@@ -403,7 +403,8 @@ struct octeon_hcd {
 									    \
 		while (1) {						    \
 			c.u32 = cvmx_usb_read_csr32(usb, address);	    \
-			if (c.s.field op (value)) {			    \
+									    \
+			if (cond) {					    \
 				result = 0;				    \
 				break;					    \
 			} else if (cvmx_get_cycle() > done) {		    \
@@ -652,11 +653,11 @@ static void cvmx_fifo_setup(struct cvmx_usb_state *usb)
 	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
 			cvmx_usbcx_grstctl, txfflsh, 1);
 	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			      cvmx_usbcx_grstctl, txfflsh, ==, 0, 100);
+			      cvmx_usbcx_grstctl, c.s.txfflsh == 0, 100);
 	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
 			cvmx_usbcx_grstctl, rxfflsh, 1);
 	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			      cvmx_usbcx_grstctl, rxfflsh, ==, 0, 100);
+			      cvmx_usbcx_grstctl, c.s.rxfflsh == 0, 100);
 }
 
 /**

commit 6068e81879c81f83b1e3dcaa02746b20be2af0c0
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sat Mar 28 21:24:33 2015 +0200

    staging: octeon-usb: assume union type for FIELD32 macros
    
    Assume union type for FIELD32 macros to simplify usage.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 731259703deb..3e89265d10d8 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -394,12 +394,13 @@ struct octeon_hcd {
 };
 
 /* This macro spins on a field waiting for it to reach a value */
-#define CVMX_WAIT_FOR_FIELD32(address, type, field, op, value, timeout_usec)\
+#define CVMX_WAIT_FOR_FIELD32(address, _union, field, op, value, timeout_usec)\
 	({int result;							    \
 	do {								    \
 		uint64_t done = cvmx_get_cycle() + (uint64_t)timeout_usec * \
 			octeon_get_clock_rate() / 1000000;		    \
-		type c;							    \
+		union _union c;						    \
+									    \
 		while (1) {						    \
 			c.u32 = cvmx_usb_read_csr32(usb, address);	    \
 			if (c.s.field op (value)) {			    \
@@ -418,9 +419,10 @@ struct octeon_hcd {
  * This macro logically sets a single field in a CSR. It does the sequence
  * read, modify, and write
  */
-#define USB_SET_FIELD32(address, type, field, value)		\
+#define USB_SET_FIELD32(address, _union, field, value)		\
 	do {							\
-		type c;						\
+		union _union c;					\
+								\
 		c.u32 = cvmx_usb_read_csr32(usb, address);	\
 		c.s.field = value;				\
 		cvmx_usb_write_csr32(usb, address, c.u32);	\
@@ -621,9 +623,8 @@ static void cvmx_fifo_setup(struct cvmx_usb_state *usb)
 	 * Program the USBC_GRXFSIZ register to select the size of the receive
 	 * FIFO (25%).
 	 */
-	USB_SET_FIELD32(CVMX_USBCX_GRXFSIZ(usb->index),
-			union cvmx_usbcx_grxfsiz, rxfdep,
-			usbcx_ghwcfg3.s.dfifodepth / 4);
+	USB_SET_FIELD32(CVMX_USBCX_GRXFSIZ(usb->index), cvmx_usbcx_grxfsiz,
+			rxfdep, usbcx_ghwcfg3.s.dfifodepth / 4);
 
 	/*
 	 * Program the USBC_GNPTXFSIZ register to select the size and the start
@@ -647,17 +648,15 @@ static void cvmx_fifo_setup(struct cvmx_usb_state *usb)
 
 	/* Flush all FIFOs */
 	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			union cvmx_usbcx_grstctl, txfnum, 0x10);
+			cvmx_usbcx_grstctl, txfnum, 0x10);
 	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			union cvmx_usbcx_grstctl, txfflsh, 1);
+			cvmx_usbcx_grstctl, txfflsh, 1);
 	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			      union cvmx_usbcx_grstctl,
-			      txfflsh, ==, 0, 100);
+			      cvmx_usbcx_grstctl, txfflsh, ==, 0, 100);
 	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			union cvmx_usbcx_grstctl, rxfflsh, 1);
+			cvmx_usbcx_grstctl, rxfflsh, 1);
 	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			      union cvmx_usbcx_grstctl,
-			      rxfflsh, ==, 0, 100);
+			      cvmx_usbcx_grstctl, rxfflsh, ==, 0, 100);
 }
 
 /**
@@ -926,9 +925,9 @@ static int cvmx_usb_initialize(struct device *dev,
 	 *    USBC_GINTMSK[PRTINT] = 1
 	 */
 	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-			union cvmx_usbcx_gintmsk, prtintmsk, 1);
+			cvmx_usbcx_gintmsk, prtintmsk, 1);
 	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-			union cvmx_usbcx_gintmsk, disconnintmsk, 1);
+			cvmx_usbcx_gintmsk, disconnintmsk, 1);
 
 	/*
 	 * 2. Program the USBC_HCFG register to select full-speed host
@@ -975,7 +974,7 @@ static void cvmx_usb_reset_port(struct cvmx_usb_state *usb)
 						  CVMX_USBCX_HPRT(usb->index));
 
 	/* Program the port reset bit to start the reset process */
-	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt,
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,
 			prtrst, 1);
 
 	/*
@@ -985,7 +984,7 @@ static void cvmx_usb_reset_port(struct cvmx_usb_state *usb)
 	mdelay(50);
 
 	/* Program the port reset bit to 0, USBC_HPRT[PRTRST] = 0 */
-	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt,
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,
 			prtrst, 0);
 
 	/*
@@ -1010,7 +1009,7 @@ static void cvmx_usb_reset_port(struct cvmx_usb_state *usb)
 static int cvmx_usb_disable(struct cvmx_usb_state *usb)
 {
 	/* Disable the port */
-	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt,
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,
 			prtena, 1);
 	return 0;
 }
@@ -1285,12 +1284,10 @@ static void cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
 		if (cvmx_usb_fill_tx_hw(usb, &usb->periodic,
 					tx_status.s.ptxfspcavail))
 			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-					union cvmx_usbcx_gintmsk,
-					ptxfempmsk, 1);
+					cvmx_usbcx_gintmsk, ptxfempmsk, 1);
 		else
 			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-					union cvmx_usbcx_gintmsk,
-					ptxfempmsk, 0);
+					cvmx_usbcx_gintmsk, ptxfempmsk, 0);
 	}
 
 	if (usb->nonperiodic.head != usb->nonperiodic.tail) {
@@ -1301,12 +1298,10 @@ static void cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
 		if (cvmx_usb_fill_tx_hw(usb, &usb->nonperiodic,
 					tx_status.s.nptxfspcavail))
 			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-					union cvmx_usbcx_gintmsk,
-					nptxfempmsk, 1);
+					cvmx_usbcx_gintmsk, nptxfempmsk, 1);
 		else
 			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-					union cvmx_usbcx_gintmsk,
-					nptxfempmsk, 0);
+					cvmx_usbcx_gintmsk, nptxfempmsk, 0);
 	}
 }
 
@@ -1401,7 +1396,7 @@ static void cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 		bytes_to_transfer = sizeof(*header);
 		/* All Control operations start with a setup going OUT */
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-				union cvmx_usbcx_hccharx, epdir,
+				cvmx_usbcx_hccharx, epdir,
 				CVMX_USB_DIRECTION_OUT);
 		/*
 		 * Setup send the control header instead of the buffer data. The
@@ -1416,11 +1411,11 @@ static void cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 		bytes_to_transfer = 0;
 		/* All Control operations start with a setup going OUT */
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-				union cvmx_usbcx_hccharx, epdir,
+				cvmx_usbcx_hccharx, epdir,
 				CVMX_USB_DIRECTION_OUT);
 
 		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
-				union cvmx_usbcx_hcspltx, compsplt, 1);
+				cvmx_usbcx_hcspltx, compsplt, 1);
 		break;
 	case CVMX_USB_STAGE_DATA:
 		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
@@ -1431,7 +1426,7 @@ static void cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 				bytes_to_transfer = pipe->max_packet;
 		}
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-				union cvmx_usbcx_hccharx, epdir,
+				cvmx_usbcx_hccharx, epdir,
 				((header->bRequestType & USB_DIR_IN) ?
 					CVMX_USB_DIRECTION_IN :
 					CVMX_USB_DIRECTION_OUT));
@@ -1441,18 +1436,18 @@ static void cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 		if (!(header->bRequestType & USB_DIR_IN))
 			bytes_to_transfer = 0;
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-				union cvmx_usbcx_hccharx, epdir,
+				cvmx_usbcx_hccharx, epdir,
 				((header->bRequestType & USB_DIR_IN) ?
 					CVMX_USB_DIRECTION_IN :
 					CVMX_USB_DIRECTION_OUT));
 		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
-				union cvmx_usbcx_hcspltx, compsplt, 1);
+				cvmx_usbcx_hcspltx, compsplt, 1);
 		break;
 	case CVMX_USB_STAGE_STATUS:
 		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
 		bytes_to_transfer = 0;
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-				union cvmx_usbcx_hccharx, epdir,
+				cvmx_usbcx_hccharx, epdir,
 				((header->bRequestType & USB_DIR_IN) ?
 					CVMX_USB_DIRECTION_OUT :
 					CVMX_USB_DIRECTION_IN));
@@ -1461,12 +1456,12 @@ static void cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
 		bytes_to_transfer = 0;
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-				union cvmx_usbcx_hccharx, epdir,
+				cvmx_usbcx_hccharx, epdir,
 				((header->bRequestType & USB_DIR_IN) ?
 					CVMX_USB_DIRECTION_OUT :
 					CVMX_USB_DIRECTION_IN));
 		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
-				union cvmx_usbcx_hcspltx, compsplt, 1);
+				cvmx_usbcx_hcspltx, compsplt, 1);
 		break;
 	}
 
@@ -1830,14 +1825,12 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 					USB_SET_FIELD32(
 						CVMX_USBCX_HCTSIZX(channel,
 								   usb->index),
-						union cvmx_usbcx_hctsizx,
-						pid, 0);
+						cvmx_usbcx_hctsizx, pid, 0);
 				else /* Need MDATA */
 					USB_SET_FIELD32(
 						CVMX_USBCX_HCTSIZX(channel,
 								   usb->index),
-						union cvmx_usbcx_hctsizx,
-						pid, 3);
+						cvmx_usbcx_hctsizx, pid, 3);
 			}
 		}
 		break;
@@ -1853,7 +1846,7 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 	if (cvmx_usb_pipe_needs_split(usb, pipe))
 		usb->active_split = transaction;
 	USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
-			union cvmx_usbcx_hccharx, chena, 1);
+			cvmx_usbcx_hccharx, chena, 1);
 	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
 		cvmx_usb_fill_tx_fifo(usb, channel);
 }
@@ -1983,7 +1976,7 @@ static void cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 		}
 	}
 	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-			union cvmx_usbcx_gintmsk, sofmsk, need_sof);
+			cvmx_usbcx_gintmsk, sofmsk, need_sof);
 }
 
 static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
@@ -3527,7 +3520,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			 */
 			spin_lock_irqsave(&priv->lock, flags);
 			USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index),
-					union cvmx_usbcx_hprt, prtpwr, 1);
+					cvmx_usbcx_hprt, prtpwr, 1);
 			spin_unlock_irqrestore(&priv->lock, flags);
 			return 0;
 		case USB_PORT_FEAT_RESET:

commit 9a02e8d211d54d2e8f6a3b22cff72f2a4b2933e1
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sat Mar 28 21:24:32 2015 +0200

    staging: octeon-usb: octeon_usb_probe: delete unused variable
    
    "flags" is not used, delete it.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index ca8be66b65ab..731259703deb 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3581,7 +3581,6 @@ static int octeon_usb_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct octeon_hcd *priv;
 	struct usb_hcd *hcd;
-	unsigned long flags;
 	u32 clock_rate = 48000000;
 	bool is_crystal_clock = false;
 	const char *clock_type;

commit a3d3390d1ee4a7e30cc48402c434eca82c16cb38
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sat Mar 28 21:24:31 2015 +0200

    staging: octeon-usb: make cvmx_fifo_setup void
    
    Make cvmx_fifo_setup void, it does not return any value.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index feaaafc30976..ca8be66b65ab 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -608,7 +608,7 @@ static inline int cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)
 	return 0; /* Data0 */
 }
 
-static int cvmx_fifo_setup(struct cvmx_usb_state *usb)
+static void cvmx_fifo_setup(struct cvmx_usb_state *usb)
 {
 	union cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;
 	union cvmx_usbcx_gnptxfsiz npsiz;

commit edc16d8d481e4c73f9d70d648463d4b25d2c662b
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:38:02 2015 +0200

    stating: octeon-usb: cvmx_usb_initialize(): eliminate extra indentation
    
    Eliminate extra indentation by putting all the code into the same block.
    Also delete a bogus comment.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index d71ae297c36f..feaaafc30976 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -705,9 +705,15 @@ static int cvmx_usb_shutdown(struct cvmx_usb_state *usb)
 static int cvmx_usb_initialize(struct device *dev,
 			       struct cvmx_usb_state *usb)
 {
+	int channel;
+	int divisor;
 	int retries = 0;
+	union cvmx_usbcx_hcfg usbcx_hcfg;
 	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
 	union cvmx_usbcx_gintsts usbc_gintsts;
+	union cvmx_usbcx_gahbcfg usbcx_gahbcfg;
+	union cvmx_usbcx_gintmsk usbcx_gintmsk;
+	union cvmx_usbcx_gusbcfg usbcx_gusbcfg;
 	union cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;
 
 retry:
@@ -775,15 +781,14 @@ static int cvmx_usb_initialize(struct device *dev,
 	 *     setting USBN0/1_CLK_CTL[ENABLE] = 1. Divide the core clock down
 	 *     such that USB is as close as possible to 125Mhz
 	 */
-	{
-		int divisor = DIV_ROUND_UP(octeon_get_clock_rate(), 125000000);
-		/* Lower than 4 doesn't seem to work properly */
-		if (divisor < 4)
-			divisor = 4;
-		usbn_clk_ctl.s.divide = divisor;
-		usbn_clk_ctl.s.divide2 = 0;
-	}
+	divisor = DIV_ROUND_UP(octeon_get_clock_rate(), 125000000);
+	/* Lower than 4 doesn't seem to work properly */
+	if (divisor < 4)
+		divisor = 4;
+	usbn_clk_ctl.s.divide = divisor;
+	usbn_clk_ctl.s.divide2 = 0;
 	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+
 	/* 2d. Write USBN0/1_CLK_CTL[HCLK_RST] = 1 */
 	usbn_clk_ctl.s.hclk_rst = 1;
 	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
@@ -862,18 +867,16 @@ static int cvmx_usb_initialize(struct device *dev,
 	 *    USBC_GAHBCFG[PTXFEMPLVL]
 	 *    Global interrupt mask, USBC_GAHBCFG[GLBLINTRMSK] = 1
 	 */
-	{
-		union cvmx_usbcx_gahbcfg usbcx_gahbcfg;
-		usbcx_gahbcfg.u32 = 0;
-		usbcx_gahbcfg.s.dmaen = !(usb->init_flags &
-					  CVMX_USB_INITIALIZE_FLAGS_NO_DMA);
-		usbcx_gahbcfg.s.hbstlen = 0;
-		usbcx_gahbcfg.s.nptxfemplvl = 1;
-		usbcx_gahbcfg.s.ptxfemplvl = 1;
-		usbcx_gahbcfg.s.glblintrmsk = 1;
-		cvmx_usb_write_csr32(usb, CVMX_USBCX_GAHBCFG(usb->index),
-				     usbcx_gahbcfg.u32);
-	}
+	usbcx_gahbcfg.u32 = 0;
+	usbcx_gahbcfg.s.dmaen = !(usb->init_flags &
+				  CVMX_USB_INITIALIZE_FLAGS_NO_DMA);
+	usbcx_gahbcfg.s.hbstlen = 0;
+	usbcx_gahbcfg.s.nptxfemplvl = 1;
+	usbcx_gahbcfg.s.ptxfemplvl = 1;
+	usbcx_gahbcfg.s.glblintrmsk = 1;
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_GAHBCFG(usb->index),
+			     usbcx_gahbcfg.u32);
+
 	/*
 	 * 3. Program the following fields in USBC_GUSBCFG register.
 	 *    HS/FS timeout calibration, USBC_GUSBCFG[TOUTCAL] = 0
@@ -881,79 +884,60 @@ static int cvmx_usb_initialize(struct device *dev,
 	 *    USB turnaround time, USBC_GUSBCFG[USBTRDTIM] = 0x5
 	 *    PHY low-power clock select, USBC_GUSBCFG[PHYLPWRCLKSEL] = 0
 	 */
-	{
-		union cvmx_usbcx_gusbcfg usbcx_gusbcfg;
-
-		usbcx_gusbcfg.u32 = cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_GUSBCFG(usb->index));
-		usbcx_gusbcfg.s.toutcal = 0;
-		usbcx_gusbcfg.s.ddrsel = 0;
-		usbcx_gusbcfg.s.usbtrdtim = 0x5;
-		usbcx_gusbcfg.s.phylpwrclksel = 0;
-		cvmx_usb_write_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index),
-				     usbcx_gusbcfg.u32);
-	}
+	usbcx_gusbcfg.u32 = cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_GUSBCFG(usb->index));
+	usbcx_gusbcfg.s.toutcal = 0;
+	usbcx_gusbcfg.s.ddrsel = 0;
+	usbcx_gusbcfg.s.usbtrdtim = 0x5;
+	usbcx_gusbcfg.s.phylpwrclksel = 0;
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index),
+			     usbcx_gusbcfg.u32);
+
 	/*
 	 * 4. The software must unmask the following bits in the USBC_GINTMSK
 	 *    register.
 	 *    OTG interrupt mask, USBC_GINTMSK[OTGINTMSK] = 1
 	 *    Mode mismatch interrupt mask, USBC_GINTMSK[MODEMISMSK] = 1
 	 */
-	{
-		union cvmx_usbcx_gintmsk usbcx_gintmsk;
-		int channel;
-
-		usbcx_gintmsk.u32 = cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_GINTMSK(usb->index));
-		usbcx_gintmsk.s.otgintmsk = 1;
-		usbcx_gintmsk.s.modemismsk = 1;
-		usbcx_gintmsk.s.hchintmsk = 1;
-		usbcx_gintmsk.s.sofmsk = 0;
-		/* We need RX FIFO interrupts if we don't have DMA */
-		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
-			usbcx_gintmsk.s.rxflvlmsk = 1;
-		cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTMSK(usb->index),
-				     usbcx_gintmsk.u32);
+	usbcx_gintmsk.u32 = cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_GINTMSK(usb->index));
+	usbcx_gintmsk.s.otgintmsk = 1;
+	usbcx_gintmsk.s.modemismsk = 1;
+	usbcx_gintmsk.s.hchintmsk = 1;
+	usbcx_gintmsk.s.sofmsk = 0;
+	/* We need RX FIFO interrupts if we don't have DMA */
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+		usbcx_gintmsk.s.rxflvlmsk = 1;
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTMSK(usb->index),
+			     usbcx_gintmsk.u32);
 
-		/*
-		 * Disable all channel interrupts. We'll enable them per channel
-		 * later.
-		 */
-		for (channel = 0; channel < 8; channel++)
-			cvmx_usb_write_csr32(usb,
-				CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
-	}
+	/*
+	 * Disable all channel interrupts. We'll enable them per channel later.
+	 */
+	for (channel = 0; channel < 8; channel++)
+		cvmx_usb_write_csr32(usb,
+				     CVMX_USBCX_HCINTMSKX(channel, usb->index),
+				     0);
 
-	{
-		/*
-		 * Host Port Initialization
-		 *
-		 * 1. Program the host-port interrupt-mask field to unmask,
-		 *    USBC_GINTMSK[PRTINT] = 1
-		 */
-		USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-				union cvmx_usbcx_gintmsk, prtintmsk, 1);
-		USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
-				union cvmx_usbcx_gintmsk, disconnintmsk, 1);
-		/*
-		 * 2. Program the USBC_HCFG register to select full-speed host
-		 *    or high-speed host.
-		 */
-		{
-			union cvmx_usbcx_hcfg usbcx_hcfg;
-
-			usbcx_hcfg.u32 = cvmx_usb_read_csr32(usb,
-					CVMX_USBCX_HCFG(usb->index));
-			usbcx_hcfg.s.fslssupp = 0;
-			usbcx_hcfg.s.fslspclksel = 0;
-			cvmx_usb_write_csr32(usb, CVMX_USBCX_HCFG(usb->index),
-					     usbcx_hcfg.u32);
-		}
+	/*
+	 * Host Port Initialization
+	 *
+	 * 1. Program the host-port interrupt-mask field to unmask,
+	 *    USBC_GINTMSK[PRTINT] = 1
+	 */
+	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+			union cvmx_usbcx_gintmsk, prtintmsk, 1);
+	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+			union cvmx_usbcx_gintmsk, disconnintmsk, 1);
 
-		/*
-		 * Steps 4-15 from the manual are done later in the port enable
-		 */
-	}
+	/*
+	 * 2. Program the USBC_HCFG register to select full-speed host
+	 *    or high-speed host.
+	 */
+	usbcx_hcfg.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HCFG(usb->index));
+	usbcx_hcfg.s.fslssupp = 0;
+	usbcx_hcfg.s.fslspclksel = 0;
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_HCFG(usb->index), usbcx_hcfg.u32);
 
 	cvmx_fifo_setup(usb);
 

commit 6ad9c95b3a595a2ec516dfcbc677043ea5ac9a76
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:38:01 2015 +0200

    staging: octeon-usb: try to recover from failed hardware reset
    
    On some hardware the USB fails to initialize to sane state after
    cold boot. We can detect this based on some unexpected interrupt bits,
    and recover by re-initializing.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 27acab217d21..d71ae297c36f 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -697,15 +697,20 @@ static int cvmx_usb_shutdown(struct cvmx_usb_state *usb)
  * other access to the Octeon USB port is made. The port starts
  * off in the disabled state.
  *
+ * @dev:	 Pointer to struct device for logging purposes.
  * @usb:	 Pointer to struct cvmx_usb_state.
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_initialize(struct cvmx_usb_state *usb)
+static int cvmx_usb_initialize(struct device *dev,
+			       struct cvmx_usb_state *usb)
 {
+	int retries = 0;
 	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
+	union cvmx_usbcx_gintsts usbc_gintsts;
 	union cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;
 
+retry:
 	/*
 	 * Power On Reset and PHY Initialization
 	 *
@@ -952,7 +957,26 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb)
 
 	cvmx_fifo_setup(usb);
 
-	return 0;
+	/*
+	 * If the controller is getting port events right after the reset, it
+	 * means the initialization failed. Try resetting the controller again
+	 * in such case. This is seen to happen after cold boot on DSR-1000N.
+	 */
+	usbc_gintsts.u32 = cvmx_usb_read_csr32(usb,
+					       CVMX_USBCX_GINTSTS(usb->index));
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index),
+			     usbc_gintsts.u32);
+	dev_dbg(dev, "gintsts after reset: 0x%x\n", (int)usbc_gintsts.u32);
+	if (!usbc_gintsts.s.disconnint && !usbc_gintsts.s.prtint)
+		return 0;
+	if (retries++ >= 5)
+		return -EAGAIN;
+	dev_info(dev, "controller reset failed (gintsts=0x%x) - retrying\n",
+		 (int)usbc_gintsts.u32);
+	msleep(50);
+	cvmx_usb_shutdown(usb);
+	msleep(50);
+	goto retry;
 }
 
 /**
@@ -3690,7 +3714,7 @@ static int octeon_usb_probe(struct platform_device *pdev)
 		priv->usb.idle_hardware_channels = 0xff;
 	}
 
-	status = cvmx_usb_initialize(&priv->usb);
+	status = cvmx_usb_initialize(dev, &priv->usb);
 	if (status) {
 		dev_dbg(dev, "USB initialization failed with %d\n", status);
 		kfree(hcd);

commit f3b8edc0f366bd7049eafa11d0c0187f039c0528
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:38:00 2015 +0200

    staging: octeon-usb: fail and warn if DMA counters are wrong
    
    Fail and WARN if DMA counters are wrong.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 84640454ba71..27acab217d21 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2617,6 +2617,17 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		(pipe->transfer_dir == CVMX_USB_DIRECTION_OUT))
 		pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
 
+	if (unlikely(WARN_ON_ONCE(bytes_this_transfer < 0))) {
+		/*
+		 * In some rare cases the DMA engine seems to get stuck and
+		 * keeps substracting same byte count over and over again. In
+		 * such case we just need to fail every transaction.
+		 */
+		cvmx_usb_perform_complete(usb, pipe, transaction,
+					  CVMX_USB_COMPLETE_ERROR);
+		return 0;
+	}
+
 	if (usbc_hcint.s.stall) {
 		/*
 		 * STALL as a response means this transaction cannot be

commit eb04114f37eb434b5bc18293274420d2a664adc2
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:59 2015 +0200

    staging: octeon-usb: move cvmx_usb_shutdown()
    
    Move cvmx_usb_shutdown() to allow its use from some other functions.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 7aa28dee0e98..84640454ba71 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -660,6 +660,38 @@ static int cvmx_fifo_setup(struct cvmx_usb_state *usb)
 			      rxfflsh, ==, 0, 100);
 }
 
+/**
+ * Shutdown a USB port after a call to cvmx_usb_initialize().
+ * The port should be disabled with all pipes closed when this
+ * function is called.
+ *
+ * @usb: USB device state populated by cvmx_usb_initialize().
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_shutdown(struct cvmx_usb_state *usb)
+{
+	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
+
+	/* Make sure all pipes are closed */
+	if (!list_empty(&usb->idle_pipes) ||
+	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_ISOCHRONOUS]) ||
+	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_INTERRUPT]) ||
+	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_CONTROL]) ||
+	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_BULK]))
+		return -EBUSY;
+
+	/* Disable the clocks and put them in power on reset */
+	usbn_clk_ctl.u64 = cvmx_read64_uint64(CVMX_USBNX_CLK_CTL(usb->index));
+	usbn_clk_ctl.s.enable = 1;
+	usbn_clk_ctl.s.por = 1;
+	usbn_clk_ctl.s.hclk_rst = 1;
+	usbn_clk_ctl.s.prst = 0;
+	usbn_clk_ctl.s.hrst = 0;
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
+	return 0;
+}
+
 /**
  * Initialize a USB port for use. This must be called before any
  * other access to the Octeon USB port is made. The port starts
@@ -923,40 +955,6 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb)
 	return 0;
 }
 
-
-/**
- * Shutdown a USB port after a call to cvmx_usb_initialize().
- * The port should be disabled with all pipes closed when this
- * function is called.
- *
- * @usb: USB device state populated by cvmx_usb_initialize().
- *
- * Returns: 0 or a negative error code.
- */
-static int cvmx_usb_shutdown(struct cvmx_usb_state *usb)
-{
-	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
-
-	/* Make sure all pipes are closed */
-	if (!list_empty(&usb->idle_pipes) ||
-	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_ISOCHRONOUS]) ||
-	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_INTERRUPT]) ||
-	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_CONTROL]) ||
-	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_BULK]))
-		return -EBUSY;
-
-	/* Disable the clocks and put them in power on reset */
-	usbn_clk_ctl.u64 = cvmx_read64_uint64(CVMX_USBNX_CLK_CTL(usb->index));
-	usbn_clk_ctl.s.enable = 1;
-	usbn_clk_ctl.s.por = 1;
-	usbn_clk_ctl.s.hclk_rst = 1;
-	usbn_clk_ctl.s.prst = 0;
-	usbn_clk_ctl.s.hrst = 0;
-	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
-	return 0;
-}
-
-
 /**
  * Reset a USB port. After this call succeeds, the USB port is
  * online and servicing requests.

commit b0c8c72ba35b34a1fbbc9abe2a023fb27b40d916
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:58 2015 +0200

    staging: octeon-usb: rewrite port reset
    
    Don't disable port before resetting. Also perform reset unconditionally
    when requested.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 98debd7876b9..7aa28dee0e98 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -958,29 +958,16 @@ static int cvmx_usb_shutdown(struct cvmx_usb_state *usb)
 
 
 /**
- * Enable a USB port. After this call succeeds, the USB port is
+ * Reset a USB port. After this call succeeds, the USB port is
  * online and servicing requests.
  *
  * @usb: USB device state populated by cvmx_usb_initialize().
- *
- * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_enable(struct cvmx_usb_state *usb)
+static void cvmx_usb_reset_port(struct cvmx_usb_state *usb)
 {
 	usb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,
 						  CVMX_USBCX_HPRT(usb->index));
 
-	/*
-	 * If the port is already enabled the just return. We don't need to do
-	 * anything
-	 */
-	if (usb->usbcx_hprt.s.prtena)
-		return 0;
-
-	/* If there is nothing plugged into the port then fail immediately */
-	if (!usb->usbcx_hprt.s.prtconnsts)
-		return -ETIMEDOUT;
-
 	/* Program the port reset bit to start the reset process */
 	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt,
 			prtrst, 1);
@@ -995,19 +982,12 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt,
 			prtrst, 0);
 
-	/* Wait for the USBC_HPRT[PRTENA]. */
-	if (CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_HPRT(usb->index),
-				union cvmx_usbcx_hprt, prtena, ==, 1, 100000))
-		return -ETIMEDOUT;
-
 	/*
 	 * Read the port speed field to get the enumerated speed,
 	 * USBC_HPRT[PRTSPD].
 	 */
 	usb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,
 						  CVMX_USBCX_HPRT(usb->index));
-
-	return 0;
 }
 
 
@@ -3536,9 +3516,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		case USB_PORT_FEAT_RESET:
 			dev_dbg(dev, " RESET\n");
 			spin_lock_irqsave(&priv->lock, flags);
-			cvmx_usb_disable(&priv->usb);
-			if (cvmx_usb_enable(&priv->usb))
-				dev_dbg(dev, "Failed to enable the port\n");
+			cvmx_usb_reset_port(&priv->usb);
 			spin_unlock_irqrestore(&priv->lock, flags);
 			return 0;
 		case USB_PORT_FEAT_INDICATOR:

commit 164814bb6e21dfd27952ddcbe65709ed7aa83d4a
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:57 2015 +0200

    staging: octeon-usb: move fifo setup to controller reset from port reset
    
    Move FIFO setup to controller reset from port reset.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 4a65af5bb31a..98debd7876b9 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -918,6 +918,8 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb)
 		 */
 	}
 
+	cvmx_fifo_setup(usb);
+
 	return 0;
 }
 
@@ -1005,8 +1007,6 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 	usb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,
 						  CVMX_USBCX_HPRT(usb->index));
 
-	cvmx_fifo_setup(usb);
-
 	return 0;
 }
 

commit 2263251fbb3f7e79b8c2dafdf45614522ddb43f4
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:56 2015 +0200

    staging: octeon-usb: move fifo setup into a separate routine
    
    Move FIFO setup into a separate routine.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 30a96ff869e4..4a65af5bb31a 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -608,6 +608,58 @@ static inline int cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)
 	return 0; /* Data0 */
 }
 
+static int cvmx_fifo_setup(struct cvmx_usb_state *usb)
+{
+	union cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;
+	union cvmx_usbcx_gnptxfsiz npsiz;
+	union cvmx_usbcx_hptxfsiz psiz;
+
+	usbcx_ghwcfg3.u32 = cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_GHWCFG3(usb->index));
+
+	/*
+	 * Program the USBC_GRXFSIZ register to select the size of the receive
+	 * FIFO (25%).
+	 */
+	USB_SET_FIELD32(CVMX_USBCX_GRXFSIZ(usb->index),
+			union cvmx_usbcx_grxfsiz, rxfdep,
+			usbcx_ghwcfg3.s.dfifodepth / 4);
+
+	/*
+	 * Program the USBC_GNPTXFSIZ register to select the size and the start
+	 * address of the non-periodic transmit FIFO for nonperiodic
+	 * transactions (50%).
+	 */
+	npsiz.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index));
+	npsiz.s.nptxfdep = usbcx_ghwcfg3.s.dfifodepth / 2;
+	npsiz.s.nptxfstaddr = usbcx_ghwcfg3.s.dfifodepth / 4;
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index), npsiz.u32);
+
+	/*
+	 * Program the USBC_HPTXFSIZ register to select the size and start
+	 * address of the periodic transmit FIFO for periodic transactions
+	 * (25%).
+	 */
+	psiz.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index));
+	psiz.s.ptxfsize = usbcx_ghwcfg3.s.dfifodepth / 4;
+	psiz.s.ptxfstaddr = 3 * usbcx_ghwcfg3.s.dfifodepth / 4;
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index), psiz.u32);
+
+	/* Flush all FIFOs */
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			union cvmx_usbcx_grstctl, txfnum, 0x10);
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			union cvmx_usbcx_grstctl, txfflsh, 1);
+	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			      union cvmx_usbcx_grstctl,
+			      txfflsh, ==, 0, 100);
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			union cvmx_usbcx_grstctl, rxfflsh, 1);
+	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			      union cvmx_usbcx_grstctl,
+			      rxfflsh, ==, 0, 100);
+}
+
 /**
  * Initialize a USB port for use. This must be called before any
  * other access to the Octeon USB port is made. The port starts
@@ -913,8 +965,6 @@ static int cvmx_usb_shutdown(struct cvmx_usb_state *usb)
  */
 static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 {
-	union cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;
-
 	usb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,
 						  CVMX_USBCX_HPRT(usb->index));
 
@@ -954,59 +1004,8 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 	 */
 	usb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,
 						  CVMX_USBCX_HPRT(usb->index));
-	usbcx_ghwcfg3.u32 = cvmx_usb_read_csr32(usb,
-						CVMX_USBCX_GHWCFG3(usb->index));
 
-	/*
-	 * 13. Program the USBC_GRXFSIZ register to select the size of the
-	 *     receive FIFO (25%).
-	 */
-	USB_SET_FIELD32(CVMX_USBCX_GRXFSIZ(usb->index),
-			union cvmx_usbcx_grxfsiz, rxfdep,
-			usbcx_ghwcfg3.s.dfifodepth / 4);
-	/*
-	 * 14. Program the USBC_GNPTXFSIZ register to select the size and the
-	 *     start address of the non- periodic transmit FIFO for nonperiodic
-	 *     transactions (50%).
-	 */
-	{
-		union cvmx_usbcx_gnptxfsiz siz;
-
-		siz.u32 = cvmx_usb_read_csr32(usb,
-					      CVMX_USBCX_GNPTXFSIZ(usb->index));
-		siz.s.nptxfdep = usbcx_ghwcfg3.s.dfifodepth / 2;
-		siz.s.nptxfstaddr = usbcx_ghwcfg3.s.dfifodepth / 4;
-		cvmx_usb_write_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index),
-				     siz.u32);
-	}
-	/*
-	 * 15. Program the USBC_HPTXFSIZ register to select the size and start
-	 *     address of the periodic transmit FIFO for periodic transactions
-	 *     (25%).
-	 */
-	{
-		union cvmx_usbcx_hptxfsiz siz;
-
-		siz.u32 = cvmx_usb_read_csr32(usb,
-					      CVMX_USBCX_HPTXFSIZ(usb->index));
-		siz.s.ptxfsize = usbcx_ghwcfg3.s.dfifodepth / 4;
-		siz.s.ptxfstaddr = 3 * usbcx_ghwcfg3.s.dfifodepth / 4;
-		cvmx_usb_write_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index),
-				     siz.u32);
-	}
-	/* Flush all FIFOs */
-	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			union cvmx_usbcx_grstctl, txfnum, 0x10);
-	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			union cvmx_usbcx_grstctl, txfflsh, 1);
-	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			      union cvmx_usbcx_grstctl,
-			      txfflsh, ==, 0, 100);
-	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			union cvmx_usbcx_grstctl, rxfflsh, 1);
-	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
-			      union cvmx_usbcx_grstctl,
-			      rxfflsh, ==, 0, 100);
+	cvmx_fifo_setup(usb);
 
 	return 0;
 }

commit 0ed64a4c8f5d53aaa6b20e7424b127be7392f700
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:55 2015 +0200

    staging: octeon-usb: use USB stack to turn on power
    
    Use USB stack to turn on the power bit. It will also do
    the necessary delays.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 1f501ff34a62..30a96ff869e4 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -860,12 +860,6 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb)
 			cvmx_usb_write_csr32(usb, CVMX_USBCX_HCFG(usb->index),
 					     usbcx_hcfg.u32);
 		}
-		/*
-		 * 3. Program the port power bit to drive VBUS on the USB,
-		 *    USBC_HPRT[PRTPWR] = 1
-		 */
-		USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index),
-				union cvmx_usbcx_hprt, prtpwr, 1);
 
 		/*
 		 * Steps 4-15 from the manual are done later in the port enable
@@ -3354,6 +3348,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	struct device *dev = hcd->self.controller;
 	struct cvmx_usb_port_status usb_port_status;
+	struct cvmx_usb_state *usb = &priv->usb;
 	int port_status;
 	struct usb_hub_descriptor *desc;
 	unsigned long flags;
@@ -3531,7 +3526,14 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			return -EINVAL;
 		case USB_PORT_FEAT_POWER:
 			dev_dbg(dev, " POWER\n");
-			return -EINVAL;
+			/*
+			 * Program the port power bit to drive VBUS on the USB.
+			 */
+			spin_lock_irqsave(&priv->lock, flags);
+			USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index),
+					union cvmx_usbcx_hprt, prtpwr, 1);
+			spin_unlock_irqrestore(&priv->lock, flags);
+			return 0;
 		case USB_PORT_FEAT_RESET:
 			dev_dbg(dev, " RESET\n");
 			spin_lock_irqsave(&priv->lock, flags);
@@ -3709,9 +3711,6 @@ static int octeon_usb_probe(struct platform_device *pdev)
 		return -1;
 	}
 
-	/* This delay is needed for CN3010, but I don't know why... */
-	mdelay(10);
-
 	status = usb_add_hcd(hcd, irq, 0);
 	if (status) {
 		dev_dbg(dev, "USB add HCD failed with %d\n", status);

commit c8eedbd107cc73d6dfb5f8df2307c43cf27b0107
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:54 2015 +0200

    staging: octeon-usb: don't poll interrupts early
    
    Don't poll interrupts before we have registered the HCD.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 8a185ff7e932..1f501ff34a62 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3712,10 +3712,6 @@ static int octeon_usb_probe(struct platform_device *pdev)
 	/* This delay is needed for CN3010, but I don't know why... */
 	mdelay(10);
 
-	spin_lock_irqsave(&priv->lock, flags);
-	cvmx_usb_poll(&priv->usb);
-	spin_unlock_irqrestore(&priv->lock, flags);
-
 	status = usb_add_hcd(hcd, irq, 0);
 	if (status) {
 		dev_dbg(dev, "USB add HCD failed with %d\n", status);

commit b5e79e6ea6d21c342a94dda9f5d91a3e8d882e56
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:53 2015 +0200

    staging: octeon-usb: refactor usbn block init
    
    Move one-time state data structure initialization out of
    cvmx_usb_initialize().
    
    This enables to re-initialize USBN HW block without messing
    up data structures.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 40e22e4bc75a..8a185ff7e932 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -613,31 +613,14 @@ static inline int cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)
  * other access to the Octeon USB port is made. The port starts
  * off in the disabled state.
  *
- * @usb:	 Pointer to an empty struct cvmx_usb_state
- *		 that will be populated by the initialize call.
- *		 This structure is then passed to all other USB
- *		 functions.
- * @usb_port_number:
- *		 Which Octeon USB port to initialize.
+ * @usb:	 Pointer to struct cvmx_usb_state.
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
-			       int usb_port_number,
-			       enum cvmx_usb_initialize_flags flags)
+static int cvmx_usb_initialize(struct cvmx_usb_state *usb)
 {
 	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
 	union cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;
-	int i;
-
-	memset(usb, 0, sizeof(*usb));
-	usb->init_flags = flags;
-
-	/* Initialize the USB state structure */
-	usb->index = usb_port_number;
-	INIT_LIST_HEAD(&usb->idle_pipes);
-	for (i = 0; i < ARRAY_SIZE(usb->active_pipes); i++)
-		INIT_LIST_HEAD(&usb->active_pipes[i]);
 
 	/*
 	 * Power On Reset and PHY Initialization
@@ -672,7 +655,8 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 			/* From CN52XX manual */
 			usbn_clk_ctl.s.p_rtype = 1;
 
-		switch (flags & CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK) {
+		switch (usb->init_flags &
+			CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK) {
 		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ:
 			usbn_clk_ctl.s.p_c_sel = 0;
 			break;
@@ -791,20 +775,9 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	 */
 	{
 		union cvmx_usbcx_gahbcfg usbcx_gahbcfg;
-		/* Due to an errata, CN31XX doesn't support DMA */
-		if (OCTEON_IS_MODEL(OCTEON_CN31XX))
-			usb->init_flags |= CVMX_USB_INITIALIZE_FLAGS_NO_DMA;
 		usbcx_gahbcfg.u32 = 0;
 		usbcx_gahbcfg.s.dmaen = !(usb->init_flags &
 					  CVMX_USB_INITIALIZE_FLAGS_NO_DMA);
-		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
-			/* Only use one channel with non DMA */
-			usb->idle_hardware_channels = 0x1;
-		else if (OCTEON_IS_MODEL(OCTEON_CN5XXX))
-			/* CN5XXX have an errata with channel 3 */
-			usb->idle_hardware_channels = 0xf7;
-		else
-			usb->idle_hardware_channels = 0xff;
 		usbcx_gahbcfg.s.hbstlen = 0;
 		usbcx_gahbcfg.s.nptxfemplvl = 1;
 		usbcx_gahbcfg.s.ptxfemplvl = 1;
@@ -3709,7 +3682,27 @@ static int octeon_usb_probe(struct platform_device *pdev)
 
 	spin_lock_init(&priv->lock);
 
-	status = cvmx_usb_initialize(&priv->usb, usb_num, initialize_flags);
+	priv->usb.init_flags = initialize_flags;
+
+	/* Initialize the USB state structure */
+	priv->usb.index = usb_num;
+	INIT_LIST_HEAD(&priv->usb.idle_pipes);
+	for (i = 0; i < ARRAY_SIZE(priv->usb.active_pipes); i++)
+		INIT_LIST_HEAD(&priv->usb.active_pipes[i]);
+
+	/* Due to an errata, CN31XX doesn't support DMA */
+	if (OCTEON_IS_MODEL(OCTEON_CN31XX)) {
+		priv->usb.init_flags |= CVMX_USB_INITIALIZE_FLAGS_NO_DMA;
+		/* Only use one channel with non DMA */
+		priv->usb.idle_hardware_channels = 0x1;
+	} else if (OCTEON_IS_MODEL(OCTEON_CN5XXX)) {
+		/* CN5XXX have an errata with channel 3 */
+		priv->usb.idle_hardware_channels = 0xf7;
+	} else {
+		priv->usb.idle_hardware_channels = 0xff;
+	}
+
+	status = cvmx_usb_initialize(&priv->usb);
 	if (status) {
 		dev_dbg(dev, "USB initialization failed with %d\n", status);
 		kfree(hcd);

commit 532edc93e23e656094ede793c92207a2c237740e
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:52 2015 +0200

    staging: octeon-usb: never retry after xacterr
    
    Never retry after xacterr. The DMA engine cannot handle that properly
    and may result in wrong transfer count and hang.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index a8c467ff4204..40e22e4bc75a 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2685,40 +2685,12 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					  CVMX_USB_COMPLETE_STALL);
 	} else if (usbc_hcint.s.xacterr) {
 		/*
-		 * We know at least one packet worked if we get a ACK or NAK.
-		 * Reset the retry counter
+		 * XactErr as a response means the device signaled
+		 * something wrong with the transfer. For example, PID
+		 * toggle errors cause these.
 		 */
-		if (usbc_hcint.s.nak || usbc_hcint.s.ack)
-			transaction->retries = 0;
-		transaction->retries++;
-		if (transaction->retries > MAX_RETRIES) {
-			/*
-			 * XactErr as a response means the device signaled
-			 * something wrong with the transfer. For example, PID
-			 * toggle errors cause these
-			 */
-			cvmx_usb_perform_complete(usb, pipe, transaction,
-						  CVMX_USB_COMPLETE_XACTERR);
-		} else {
-			/*
-			 * If this was a split then clear our split in progress
-			 * marker
-			 */
-			if (usb->active_split == transaction)
-				usb->active_split = NULL;
-			/*
-			 * Rewind to the beginning of the transaction by anding
-			 * off the split complete bit
-			 */
-			transaction->stage &= ~1;
-			pipe->split_sc_frame = -1;
-			pipe->next_tx_frame += pipe->interval;
-			if (pipe->next_tx_frame < usb->frame_number)
-				pipe->next_tx_frame =
-					usb->frame_number + pipe->interval -
-					(usb->frame_number -
-					 pipe->next_tx_frame) % pipe->interval;
-		}
+		cvmx_usb_perform_complete(usb, pipe, transaction,
+					  CVMX_USB_COMPLETE_XACTERR);
 	} else if (usbc_hcint.s.bblerr) {
 		/* Babble Error (BblErr) */
 		cvmx_usb_perform_complete(usb, pipe, transaction,

commit d712648a22851bef1a830274a3b5793178d3493d
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:51 2015 +0200

    staging: octeon-usb: program DMA engine based on transfer direction
    
    Program DMA engine based on transfer direction. We are only transferring
    to one direction at a time.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 1ec70eb490d1..a8c467ff4204 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1636,8 +1636,9 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 				     usbc_haintmsk.u32);
 	}
 
-	/* Setup the locations the DMA engines use  */
+	/* Setup the location the DMA engine uses. */
 	{
+		uint64_t reg;
 		uint64_t dma_address = transaction->buffer +
 					transaction->actual_bytes;
 
@@ -1646,12 +1647,11 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 					transaction->iso_packets[0].offset +
 					transaction->actual_bytes;
 
-		cvmx_write64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +
-					channel * 8,
-				    dma_address);
-		cvmx_write64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index) +
-					channel * 8,
-				    dma_address);
+		if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT)
+			reg = CVMX_USBNX_DMA0_OUTB_CHN0(usb->index);
+		else
+			reg = CVMX_USBNX_DMA0_INB_CHN0(usb->index);
+		cvmx_write64_uint64(reg + channel * 8, dma_address);
 	}
 
 	/* Setup both the size of the transfer and the SPLIT characteristics */

commit 31170da59e0ffc90b94c4a6bbfecb657b2c5e3ad
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:49 2015 +0200

    staging: octeon-usb: delete redundant field from octeon_temp_buffer
    
    Since we are not moving/realigning the original pointer returned
    by kmalloc, we don't need to store the value in a separate field.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index d0f346cf8e89..1ec70eb490d1 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -432,7 +432,6 @@ struct octeon_hcd {
 
 /**
  * struct octeon_temp_buffer - a bounce buffer for USB transfers
- * @temp_buffer: the newly allocated temporary buffer (including meta-data)
  * @orig_buffer: the original buffer passed by the USB stack
  * @data:	 the newly allocated temporary buffer (excluding meta-data)
  *
@@ -441,7 +440,6 @@ struct octeon_hcd {
  * represents it.
  */
 struct octeon_temp_buffer {
-	void *temp_buffer;
 	void *orig_buffer;
 	u8 data[0];
 };
@@ -479,7 +477,6 @@ static int octeon_alloc_temp_buffer(struct urb *urb, gfp_t mem_flags)
 	if (!temp)
 		return -ENOMEM;
 
-	temp->temp_buffer = temp;
 	temp->orig_buffer = urb->transfer_buffer;
 	if (usb_urb_dir_out(urb))
 		memcpy(temp->data, urb->transfer_buffer,
@@ -510,7 +507,7 @@ static void octeon_free_temp_buffer(struct urb *urb)
 		       urb->actual_length);
 	urb->transfer_buffer = temp->orig_buffer;
 	urb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;
-	kfree(temp->temp_buffer);
+	kfree(temp);
 }
 
 /**

commit 3f9697b714b291d81a289fe6f1f7818ac910bccb
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:48 2015 +0200

    staging: octeon-usb: remove useless prefix from pipe flags
    
    Remove useless prefix from pipe flags and adjust comments.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 2994a464bd36..d0f346cf8e89 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -214,15 +214,14 @@ enum cvmx_usb_initialize_flags {
 /**
  * enum cvmx_usb_pipe_flags - internal flags for a pipe.
  *
- * @__CVMX_USB_PIPE_FLAGS_SCHEDULED: Used internally to determine if a pipe is
- *				     actively using hardware. Do not use.
- * @__CVMX_USB_PIPE_FLAGS_NEED_PING: Used internally to determine if a high
- *				     speed pipe is in the ping state. Do not
- *				     use.
+ * @CVMX_USB_PIPE_FLAGS_SCHEDULED: Used internally to determine if a pipe is
+ *				   actively using hardware.
+ * @CVMX_USB_PIPE_FLAGS_NEED_PING: Used internally to determine if a high speed
+ *				   pipe is in the ping state.
  */
 enum cvmx_usb_pipe_flags {
-	__CVMX_USB_PIPE_FLAGS_SCHEDULED	= 1 << 17,
-	__CVMX_USB_PIPE_FLAGS_NEED_PING	= 1 << 18,
+	CVMX_USB_PIPE_FLAGS_SCHEDULED	= 1 << 17,
+	CVMX_USB_PIPE_FLAGS_NEED_PING	= 1 << 18,
 };
 
 /* Maximum number of times to retry failed transactions */
@@ -1173,7 +1172,7 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 	if ((device_speed == CVMX_USB_SPEED_HIGH) &&
 		(transfer_dir == CVMX_USB_DIRECTION_OUT) &&
 		(transfer_type == CVMX_USB_TRANSFER_BULK))
-		pipe->flags |= __CVMX_USB_PIPE_FLAGS_NEED_PING;
+		pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
 	pipe->device_addr = device_addr;
 	pipe->endpoint_num = endpoint_num;
 	pipe->device_speed = device_speed;
@@ -1586,7 +1585,7 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 	/* Attach the channel to the pipe */
 	usb->pipe_for_channel[channel] = pipe;
 	pipe->channel = channel;
-	pipe->flags |= __CVMX_USB_PIPE_FLAGS_SCHEDULED;
+	pipe->flags |= CVMX_USB_PIPE_FLAGS_SCHEDULED;
 
 	/* Mark this channel as in use */
 	usb->idle_hardware_channels &= ~(1<<channel);
@@ -1814,7 +1813,7 @@ static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
 		/*
 		 * High speed pipes may need a hardware ping before they start
 		 */
-		if (pipe->flags & __CVMX_USB_PIPE_FLAGS_NEED_PING)
+		if (pipe->flags & CVMX_USB_PIPE_FLAGS_NEED_PING)
 			usbc_hctsiz.s.dopng = 1;
 
 		cvmx_usb_write_csr32(usb,
@@ -1931,7 +1930,7 @@ static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(
 		struct cvmx_usb_transaction *t =
 			list_first_entry(&pipe->transactions, typeof(*t),
 					 node);
-		if (!(pipe->flags & __CVMX_USB_PIPE_FLAGS_SCHEDULED) && t &&
+		if (!(pipe->flags & CVMX_USB_PIPE_FLAGS_SCHEDULED) && t &&
 			(pipe->next_tx_frame <= current_frame) &&
 			((pipe->split_sc_frame == -1) ||
 			 ((((int)current_frame - (int)pipe->split_sc_frame)
@@ -2394,11 +2393,11 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 	 * treat it special
 	 */
 	if (list_first_entry(&pipe->transactions, typeof(*transaction), node) ==
-	    transaction && (pipe->flags & __CVMX_USB_PIPE_FLAGS_SCHEDULED)) {
+	    transaction && (pipe->flags & CVMX_USB_PIPE_FLAGS_SCHEDULED)) {
 		union cvmx_usbcx_hccharx usbc_hcchar;
 
 		usb->pipe_for_channel[pipe->channel] = NULL;
-		pipe->flags &= ~__CVMX_USB_PIPE_FLAGS_SCHEDULED;
+		pipe->flags &= ~CVMX_USB_PIPE_FLAGS_SCHEDULED;
 
 		CVMX_SYNCW;
 
@@ -2592,7 +2591,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	 * function will figure out which pipe needs to go
 	 */
 	usb->pipe_for_channel[channel] = NULL;
-	pipe->flags &= ~__CVMX_USB_PIPE_FLAGS_SCHEDULED;
+	pipe->flags &= ~CVMX_USB_PIPE_FLAGS_SCHEDULED;
 
 	/*
 	 * Read the channel config info so we can figure out how much data
@@ -2675,7 +2674,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	if ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&
 		(pipe->transfer_type == CVMX_USB_TRANSFER_BULK) &&
 		(pipe->transfer_dir == CVMX_USB_DIRECTION_OUT))
-		pipe->flags |= __CVMX_USB_PIPE_FLAGS_NEED_PING;
+		pipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;
 
 	if (usbc_hcint.s.stall) {
 		/*
@@ -2778,7 +2777,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		 * Since we got an ACK, we know we don't need to do a ping on
 		 * this pipe
 		 */
-		pipe->flags &= ~__CVMX_USB_PIPE_FLAGS_NEED_PING;
+		pipe->flags &= ~CVMX_USB_PIPE_FLAGS_NEED_PING;
 
 		switch (transaction->type) {
 		case CVMX_USB_TRANSFER_CONTROL:
@@ -2911,7 +2910,7 @@ static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				     CVMX_USB_DIRECTION_OUT) &&
 				    (usbc_hcint.s.nak))
 					pipe->flags |=
-						__CVMX_USB_PIPE_FLAGS_NEED_PING;
+						CVMX_USB_PIPE_FLAGS_NEED_PING;
 				if (!buffer_space_left ||
 					(bytes_in_last_packet <
 					 pipe->max_packet)) {

commit 68d435dd54ecfe7cb34d57204ed3ea4691fb83ea
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:47 2015 +0200

    staging: octeon-usb: remove useless prefix from internal routines
    
    Original CVMX code used "__" to distinguis internal USB functions
    from public ones. But in Linux all cvmx_usb routines are internal
    to this driver, so such separation is useless.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 239606555db7..2994a464bd36 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -402,7 +402,7 @@ struct octeon_hcd {
 			octeon_get_clock_rate() / 1000000;		    \
 		type c;							    \
 		while (1) {						    \
-			c.u32 = __cvmx_usb_read_csr32(usb, address);	    \
+			c.u32 = cvmx_usb_read_csr32(usb, address);	    \
 			if (c.s.field op (value)) {			    \
 				result = 0;				    \
 				break;					    \
@@ -422,9 +422,9 @@ struct octeon_hcd {
 #define USB_SET_FIELD32(address, type, field, value)		\
 	do {							\
 		type c;						\
-		c.u32 = __cvmx_usb_read_csr32(usb, address);	\
+		c.u32 = cvmx_usb_read_csr32(usb, address);	\
 		c.s.field = value;				\
-		__cvmx_usb_write_csr32(usb, address, c.u32);	\
+		cvmx_usb_write_csr32(usb, address, c.u32);	\
 	} while (0)
 
 /* Returns the IO address to push/pop stuff data from the FIFOs */
@@ -557,8 +557,8 @@ static void octeon_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
  *
  * Returns: Result of the read
  */
-static inline uint32_t __cvmx_usb_read_csr32(struct cvmx_usb_state *usb,
-					     uint64_t address)
+static inline uint32_t cvmx_usb_read_csr32(struct cvmx_usb_state *usb,
+					   uint64_t address)
 {
 	uint32_t result = cvmx_read64_uint32(address ^ 4);
 	return result;
@@ -574,8 +574,8 @@ static inline uint32_t __cvmx_usb_read_csr32(struct cvmx_usb_state *usb,
  * @address: 64bit address to write
  * @value:   Value to write
  */
-static inline void __cvmx_usb_write_csr32(struct cvmx_usb_state *usb,
-					  uint64_t address, uint32_t value)
+static inline void cvmx_usb_write_csr32(struct cvmx_usb_state *usb,
+					uint64_t address, uint32_t value)
 {
 	cvmx_write64_uint32(address ^ 4, value);
 	cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
@@ -590,8 +590,8 @@ static inline void __cvmx_usb_write_csr32(struct cvmx_usb_state *usb,
  *
  * Returns: Non zero if we need to do split transactions
  */
-static inline int __cvmx_usb_pipe_needs_split(struct cvmx_usb_state *usb,
-					      struct cvmx_usb_pipe *pipe)
+static inline int cvmx_usb_pipe_needs_split(struct cvmx_usb_state *usb,
+					    struct cvmx_usb_pipe *pipe)
 {
 	return pipe->device_speed != CVMX_USB_SPEED_HIGH &&
 	       usb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_HIGH;
@@ -605,7 +605,7 @@ static inline int __cvmx_usb_pipe_needs_split(struct cvmx_usb_state *usb,
  *
  * Returns: PID for pipe
  */
-static inline int __cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)
+static inline int cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)
 {
 	if (pipe->pid_toggle)
 		return 2; /* Data1 */
@@ -813,8 +813,8 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		usbcx_gahbcfg.s.nptxfemplvl = 1;
 		usbcx_gahbcfg.s.ptxfemplvl = 1;
 		usbcx_gahbcfg.s.glblintrmsk = 1;
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GAHBCFG(usb->index),
-				       usbcx_gahbcfg.u32);
+		cvmx_usb_write_csr32(usb, CVMX_USBCX_GAHBCFG(usb->index),
+				     usbcx_gahbcfg.u32);
 	}
 	/*
 	 * 3. Program the following fields in USBC_GUSBCFG register.
@@ -826,14 +826,14 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	{
 		union cvmx_usbcx_gusbcfg usbcx_gusbcfg;
 
-		usbcx_gusbcfg.u32 = __cvmx_usb_read_csr32(usb,
+		usbcx_gusbcfg.u32 = cvmx_usb_read_csr32(usb,
 				CVMX_USBCX_GUSBCFG(usb->index));
 		usbcx_gusbcfg.s.toutcal = 0;
 		usbcx_gusbcfg.s.ddrsel = 0;
 		usbcx_gusbcfg.s.usbtrdtim = 0x5;
 		usbcx_gusbcfg.s.phylpwrclksel = 0;
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index),
-				       usbcx_gusbcfg.u32);
+		cvmx_usb_write_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index),
+				     usbcx_gusbcfg.u32);
 	}
 	/*
 	 * 4. The software must unmask the following bits in the USBC_GINTMSK
@@ -845,7 +845,7 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		union cvmx_usbcx_gintmsk usbcx_gintmsk;
 		int channel;
 
-		usbcx_gintmsk.u32 = __cvmx_usb_read_csr32(usb,
+		usbcx_gintmsk.u32 = cvmx_usb_read_csr32(usb,
 				CVMX_USBCX_GINTMSK(usb->index));
 		usbcx_gintmsk.s.otgintmsk = 1;
 		usbcx_gintmsk.s.modemismsk = 1;
@@ -854,15 +854,15 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		/* We need RX FIFO interrupts if we don't have DMA */
 		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
 			usbcx_gintmsk.s.rxflvlmsk = 1;
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTMSK(usb->index),
-				       usbcx_gintmsk.u32);
+		cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTMSK(usb->index),
+				     usbcx_gintmsk.u32);
 
 		/*
 		 * Disable all channel interrupts. We'll enable them per channel
 		 * later.
 		 */
 		for (channel = 0; channel < 8; channel++)
-			__cvmx_usb_write_csr32(usb,
+			cvmx_usb_write_csr32(usb,
 				CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
 	}
 
@@ -884,13 +884,12 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		{
 			union cvmx_usbcx_hcfg usbcx_hcfg;
 
-			usbcx_hcfg.u32 = __cvmx_usb_read_csr32(usb,
+			usbcx_hcfg.u32 = cvmx_usb_read_csr32(usb,
 					CVMX_USBCX_HCFG(usb->index));
 			usbcx_hcfg.s.fslssupp = 0;
 			usbcx_hcfg.s.fslspclksel = 0;
-			__cvmx_usb_write_csr32(usb,
-					CVMX_USBCX_HCFG(usb->index),
-					usbcx_hcfg.u32);
+			cvmx_usb_write_csr32(usb, CVMX_USBCX_HCFG(usb->index),
+					     usbcx_hcfg.u32);
 		}
 		/*
 		 * 3. Program the port power bit to drive VBUS on the USB,
@@ -953,8 +952,8 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 {
 	union cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;
 
-	usb->usbcx_hprt.u32 = __cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_HPRT(usb->index));
+	usb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,
+						  CVMX_USBCX_HPRT(usb->index));
 
 	/*
 	 * If the port is already enabled the just return. We don't need to do
@@ -990,10 +989,10 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 	 * Read the port speed field to get the enumerated speed,
 	 * USBC_HPRT[PRTSPD].
 	 */
-	usb->usbcx_hprt.u32 = __cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_HPRT(usb->index));
-	usbcx_ghwcfg3.u32 = __cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_GHWCFG3(usb->index));
+	usb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,
+						  CVMX_USBCX_HPRT(usb->index));
+	usbcx_ghwcfg3.u32 = cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_GHWCFG3(usb->index));
 
 	/*
 	 * 13. Program the USBC_GRXFSIZ register to select the size of the
@@ -1010,12 +1009,12 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 	{
 		union cvmx_usbcx_gnptxfsiz siz;
 
-		siz.u32 = __cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_GNPTXFSIZ(usb->index));
+		siz.u32 = cvmx_usb_read_csr32(usb,
+					      CVMX_USBCX_GNPTXFSIZ(usb->index));
 		siz.s.nptxfdep = usbcx_ghwcfg3.s.dfifodepth / 2;
 		siz.s.nptxfstaddr = usbcx_ghwcfg3.s.dfifodepth / 4;
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index),
-				       siz.u32);
+		cvmx_usb_write_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index),
+				     siz.u32);
 	}
 	/*
 	 * 15. Program the USBC_HPTXFSIZ register to select the size and start
@@ -1025,12 +1024,12 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 	{
 		union cvmx_usbcx_hptxfsiz siz;
 
-		siz.u32 = __cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_HPTXFSIZ(usb->index));
+		siz.u32 = cvmx_usb_read_csr32(usb,
+					      CVMX_USBCX_HPTXFSIZ(usb->index));
 		siz.s.ptxfsize = usbcx_ghwcfg3.s.dfifodepth / 4;
 		siz.s.ptxfstaddr = 3 * usbcx_ghwcfg3.s.dfifodepth / 4;
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index),
-				       siz.u32);
+		cvmx_usb_write_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index),
+				     siz.u32);
 	}
 	/* Flush all FIFOs */
 	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
@@ -1088,8 +1087,7 @@ static struct cvmx_usb_port_status cvmx_usb_get_status(
 
 	memset(&result, 0, sizeof(result));
 
-	usbc_hprt.u32 = __cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_HPRT(usb->index));
+	usbc_hprt.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
 	result.port_enabled = usbc_hprt.s.prtena;
 	result.port_over_current = usbc_hprt.s.prtovrcurract;
 	result.port_powered = usbc_hprt.s.prtpwr;
@@ -1190,7 +1188,7 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 	 */
 	if (!interval)
 		interval = 1;
-	if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+	if (cvmx_usb_pipe_needs_split(usb, pipe)) {
 		pipe->interval = interval*8;
 		/* Force start splits to be schedule on uFrame 0 */
 		pipe->next_tx_frame = ((usb->frame_number+7)&~7) +
@@ -1222,7 +1220,7 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
  *
  * @usb:	USB device state populated by cvmx_usb_initialize().
  */
-static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
+static void cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
 {
 	union cvmx_usbcx_grxstsph rx_status;
 	int channel;
@@ -1230,8 +1228,8 @@ static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
 	uint64_t address;
 	uint32_t *ptr;
 
-	rx_status.u32 = __cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_GRXSTSPH(usb->index));
+	rx_status.u32 = cvmx_usb_read_csr32(usb,
+					    CVMX_USBCX_GRXSTSPH(usb->index));
 	/* Only read data if IN data is there */
 	if (rx_status.s.pktsts != 2)
 		return;
@@ -1254,8 +1252,8 @@ static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
 
 	/* Loop writing the FIFO data for this packet into memory */
 	while (bytes > 0) {
-		*ptr++ = __cvmx_usb_read_csr32(usb,
-				USB_FIFO_ADDRESS(channel, usb->index));
+		*ptr++ = cvmx_usb_read_csr32(usb,
+					USB_FIFO_ADDRESS(channel, usb->index));
 		bytes -= 4;
 	}
 	CVMX_SYNCW;
@@ -1273,8 +1271,8 @@ static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
  * Returns: Non zero if the hardware fifo was too small and needs
  *	    to be serviced again.
  */
-static int __cvmx_usb_fill_tx_hw(struct cvmx_usb_state *usb,
-				 struct cvmx_usb_tx_fifo *fifo, int available)
+static int cvmx_usb_fill_tx_hw(struct cvmx_usb_state *usb,
+			       struct cvmx_usb_tx_fifo *fifo, int available)
 {
 	/*
 	 * We're done either when there isn't anymore space or the software FIFO
@@ -1329,15 +1327,15 @@ static int __cvmx_usb_fill_tx_hw(struct cvmx_usb_state *usb,
  *
  * @usb:	USB device state populated by cvmx_usb_initialize().
  */
-static void __cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
+static void cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
 {
 	if (usb->periodic.head != usb->periodic.tail) {
 		union cvmx_usbcx_hptxsts tx_status;
 
-		tx_status.u32 = __cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_HPTXSTS(usb->index));
-		if (__cvmx_usb_fill_tx_hw(usb, &usb->periodic,
-					  tx_status.s.ptxfspcavail))
+		tx_status.u32 = cvmx_usb_read_csr32(usb,
+					CVMX_USBCX_HPTXSTS(usb->index));
+		if (cvmx_usb_fill_tx_hw(usb, &usb->periodic,
+					tx_status.s.ptxfspcavail))
 			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
 					union cvmx_usbcx_gintmsk,
 					ptxfempmsk, 1);
@@ -1350,10 +1348,10 @@ static void __cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
 	if (usb->nonperiodic.head != usb->nonperiodic.tail) {
 		union cvmx_usbcx_gnptxsts tx_status;
 
-		tx_status.u32 = __cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_GNPTXSTS(usb->index));
-		if (__cvmx_usb_fill_tx_hw(usb, &usb->nonperiodic,
-					  tx_status.s.nptxfspcavail))
+		tx_status.u32 = cvmx_usb_read_csr32(usb,
+					CVMX_USBCX_GNPTXSTS(usb->index));
+		if (cvmx_usb_fill_tx_hw(usb, &usb->nonperiodic,
+					tx_status.s.nptxfspcavail))
 			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
 					union cvmx_usbcx_gintmsk,
 					nptxfempmsk, 1);
@@ -1371,7 +1369,7 @@ static void __cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
  * @usb:	  USB device state populated by cvmx_usb_initialize().
  * @channel:	  Channel number to get packet from
  */
-static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
+static void cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
 {
 	union cvmx_usbcx_hccharx hcchar;
 	union cvmx_usbcx_hcspltx usbc_hcsplt;
@@ -1379,14 +1377,14 @@ static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
 	struct cvmx_usb_tx_fifo *fifo;
 
 	/* We only need to fill data on outbound channels */
-	hcchar.u32 = __cvmx_usb_read_csr32(usb,
+	hcchar.u32 = cvmx_usb_read_csr32(usb,
 			CVMX_USBCX_HCCHARX(channel, usb->index));
 	if (hcchar.s.epdir != CVMX_USB_DIRECTION_OUT)
 		return;
 
 	/* OUT Splits only have data on the start and not the complete */
-	usbc_hcsplt.u32 = __cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_HCSPLTX(channel, usb->index));
+	usbc_hcsplt.u32 = cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCSPLTX(channel, usb->index));
 	if (usbc_hcsplt.s.spltena && usbc_hcsplt.s.compsplt)
 		return;
 
@@ -1394,8 +1392,8 @@ static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
 	 * Find out how many bytes we need to fill and convert it into 32bit
 	 * words.
 	 */
-	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_HCTSIZX(channel, usb->index));
+	usbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCTSIZX(channel, usb->index));
 	if (!usbc_hctsiz.s.xfersize)
 		return;
 
@@ -1414,21 +1412,20 @@ static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
 	if (fifo->head > MAX_CHANNELS)
 		fifo->head = 0;
 
-	__cvmx_usb_poll_tx_fifo(usb);
+	cvmx_usb_poll_tx_fifo(usb);
 }
 
 /**
  * Perform channel specific setup for Control transactions. All
- * the generic stuff will already have been done in
- * __cvmx_usb_start_channel()
+ * the generic stuff will already have been done in cvmx_usb_start_channel().
  *
  * @usb:	  USB device state populated by cvmx_usb_initialize().
  * @channel:	  Channel to setup
  * @pipe:	  Pipe for control transaction
  */
-static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
-					     int channel,
-					     struct cvmx_usb_pipe *pipe)
+static void cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
+					   int channel,
+					   struct cvmx_usb_pipe *pipe)
 {
 	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
 	struct usb_hcd *hcd = octeon_to_hcd(priv);
@@ -1443,8 +1440,8 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 	int packets_to_transfer;
 	union cvmx_usbcx_hctsizx usbc_hctsiz;
 
-	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_HCTSIZX(channel, usb->index));
+	usbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCTSIZX(channel, usb->index));
 
 	switch (transaction->stage) {
 	case CVMX_USB_STAGE_NON_CONTROL:
@@ -1478,8 +1475,8 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 				union cvmx_usbcx_hcspltx, compsplt, 1);
 		break;
 	case CVMX_USB_STAGE_DATA:
-		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
-		if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
+		if (cvmx_usb_pipe_needs_split(usb, pipe)) {
 			if (header->bRequestType & USB_DIR_IN)
 				bytes_to_transfer = 0;
 			else if (bytes_to_transfer > pipe->max_packet)
@@ -1492,7 +1489,7 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 					CVMX_USB_DIRECTION_OUT));
 		break;
 	case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
-		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
 		if (!(header->bRequestType & USB_DIR_IN))
 			bytes_to_transfer = 0;
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
@@ -1504,7 +1501,7 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 				union cvmx_usbcx_hcspltx, compsplt, 1);
 		break;
 	case CVMX_USB_STAGE_STATUS:
-		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
 		bytes_to_transfer = 0;
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
 				union cvmx_usbcx_hccharx, epdir,
@@ -1513,7 +1510,7 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 					CVMX_USB_DIRECTION_IN));
 		break;
 	case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
-		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
 		bytes_to_transfer = 0;
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
 				union cvmx_usbcx_hccharx, epdir,
@@ -1564,8 +1561,8 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 	usbc_hctsiz.s.xfersize = bytes_to_transfer;
 	usbc_hctsiz.s.pktcnt = packets_to_transfer;
 
-	__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index),
-			       usbc_hctsiz.u32);
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index),
+			     usbc_hctsiz.u32);
 }
 
 
@@ -1576,9 +1573,8 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
  * @channel:	  Channel to setup
  * @pipe:	  Pipe to start
  */
-static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
-				     int channel,
-				     struct cvmx_usb_pipe *pipe)
+static void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,
+				   struct cvmx_usb_pipe *pipe)
 {
 	struct cvmx_usb_transaction *transaction =
 		list_first_entry(&pipe->transactions, typeof(*transaction),
@@ -1602,12 +1598,12 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		union cvmx_usbcx_haintmsk usbc_haintmsk;
 
 		/* Clear all channel status bits */
-		usbc_hcint.u32 = __cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_HCINTX(channel, usb->index));
+		usbc_hcint.u32 = cvmx_usb_read_csr32(usb,
+					CVMX_USBCX_HCINTX(channel, usb->index));
 
-		__cvmx_usb_write_csr32(usb,
-				       CVMX_USBCX_HCINTX(channel, usb->index),
-				       usbc_hcint.u32);
+		cvmx_usb_write_csr32(usb,
+				     CVMX_USBCX_HCINTX(channel, usb->index),
+				     usbc_hcint.u32);
 
 		usbc_hcintmsk.u32 = 0;
 		usbc_hcintmsk.s.chhltdmsk = 1;
@@ -1620,7 +1616,7 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 			usbc_hcintmsk.s.frmovrunmsk = 1;
 			usbc_hcintmsk.s.bblerrmsk = 1;
 			usbc_hcintmsk.s.xacterrmsk = 1;
-			if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+			if (cvmx_usb_pipe_needs_split(usb, pipe)) {
 				/*
 				 * Splits don't generate xfercompl, so we need
 				 * ACK and NYET.
@@ -1632,17 +1628,16 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 			usbc_hcintmsk.s.stallmsk = 1;
 			usbc_hcintmsk.s.xfercomplmsk = 1;
 		}
-		__cvmx_usb_write_csr32(usb,
+		cvmx_usb_write_csr32(usb,
 				CVMX_USBCX_HCINTMSKX(channel, usb->index),
 				usbc_hcintmsk.u32);
 
 		/* Enable the channel interrupt to propagate */
-		usbc_haintmsk.u32 = __cvmx_usb_read_csr32(usb,
+		usbc_haintmsk.u32 = cvmx_usb_read_csr32(usb,
 					CVMX_USBCX_HAINTMSK(usb->index));
 		usbc_haintmsk.s.haintmsk |= 1<<channel;
-		__cvmx_usb_write_csr32(usb,
-					CVMX_USBCX_HAINTMSK(usb->index),
-					usbc_haintmsk.u32);
+		cvmx_usb_write_csr32(usb, CVMX_USBCX_HAINTMSK(usb->index),
+				     usbc_haintmsk.u32);
 	}
 
 	/* Setup the locations the DMA engines use  */
@@ -1684,7 +1679,7 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		 * We need to do split transactions when we are talking to non
 		 * high speed devices that are behind a high speed hub
 		 */
-		if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+		if (cvmx_usb_pipe_needs_split(usb, pipe)) {
 			/*
 			 * On the start split phase (stage is even) record the
 			 * frame number we will need to send the split complete.
@@ -1815,18 +1810,19 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		usbc_hctsiz.s.pktcnt = packets_to_transfer;
 
 		/* Update the DATA0/DATA1 toggle */
-		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		usbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);
 		/*
 		 * High speed pipes may need a hardware ping before they start
 		 */
 		if (pipe->flags & __CVMX_USB_PIPE_FLAGS_NEED_PING)
 			usbc_hctsiz.s.dopng = 1;
 
-		__cvmx_usb_write_csr32(usb,
-				       CVMX_USBCX_HCSPLTX(channel, usb->index),
-				       usbc_hcsplt.u32);
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel,
-					usb->index), usbc_hctsiz.u32);
+		cvmx_usb_write_csr32(usb,
+				     CVMX_USBCX_HCSPLTX(channel, usb->index),
+				     usbc_hcsplt.u32);
+		cvmx_usb_write_csr32(usb,
+				     CVMX_USBCX_HCTSIZX(channel, usb->index),
+				     usbc_hctsiz.u32);
 	}
 
 	/* Setup the Host Channel Characteristics Register */
@@ -1845,7 +1841,7 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		 * immediate retries of failure. These retries happen too
 		 * quickly, so we disable these entirely for splits
 		 */
-		if (__cvmx_usb_pipe_needs_split(usb, pipe))
+		if (cvmx_usb_pipe_needs_split(usb, pipe))
 			usbc_hcchar.s.ec = 1;
 		else if (pipe->multi_count < 1)
 			usbc_hcchar.s.ec = 1;
@@ -1862,21 +1858,21 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		usbc_hcchar.s.epdir = pipe->transfer_dir;
 		usbc_hcchar.s.epnum = pipe->endpoint_num;
 		usbc_hcchar.s.mps = pipe->max_packet;
-		__cvmx_usb_write_csr32(usb,
-				       CVMX_USBCX_HCCHARX(channel, usb->index),
-				       usbc_hcchar.u32);
+		cvmx_usb_write_csr32(usb,
+				     CVMX_USBCX_HCCHARX(channel, usb->index),
+				     usbc_hcchar.u32);
 	}
 
 	/* Do transaction type specific fixups as needed */
 	switch (transaction->type) {
 	case CVMX_USB_TRANSFER_CONTROL:
-		__cvmx_usb_start_channel_control(usb, channel, pipe);
+		cvmx_usb_start_channel_control(usb, channel, pipe);
 		break;
 	case CVMX_USB_TRANSFER_BULK:
 	case CVMX_USB_TRANSFER_INTERRUPT:
 		break;
 	case CVMX_USB_TRANSFER_ISOCHRONOUS:
-		if (!__cvmx_usb_pipe_needs_split(usb, pipe)) {
+		if (!cvmx_usb_pipe_needs_split(usb, pipe)) {
 			/*
 			 * ISO transactions require different PIDs depending on
 			 * direction and how many packets are needed
@@ -1900,18 +1896,18 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 	}
 	{
 		union cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 =
-			__cvmx_usb_read_csr32(usb,
+			cvmx_usb_read_csr32(usb,
 				CVMX_USBCX_HCTSIZX(channel, usb->index))};
 		transaction->xfersize = usbc_hctsiz.s.xfersize;
 		transaction->pktcnt = usbc_hctsiz.s.pktcnt;
 	}
 	/* Remeber when we start a split transaction */
-	if (__cvmx_usb_pipe_needs_split(usb, pipe))
+	if (cvmx_usb_pipe_needs_split(usb, pipe))
 		usb->active_split = transaction;
 	USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
 			union cvmx_usbcx_hccharx, chena, 1);
 	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
-		__cvmx_usb_fill_tx_fifo(usb, channel);
+		cvmx_usb_fill_tx_fifo(usb, channel);
 }
 
 
@@ -1924,7 +1920,7 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
  *
  * Returns: Pipe or NULL if none are ready
  */
-static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(
+static struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(
 		struct cvmx_usb_state *usb,
 		struct list_head *list,
 		uint64_t current_frame)
@@ -1956,7 +1952,7 @@ static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(
  * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @is_sof:	 True if this schedule was called on a SOF interrupt.
  */
-static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
+static void cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 {
 	int channel;
 	struct cvmx_usb_pipe *pipe;
@@ -1969,12 +1965,12 @@ static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 		 * at the end of a frame and cause an overrun.
 		 */
 		union cvmx_usbcx_hfnum hfnum = {
-			.u32 = __cvmx_usb_read_csr32(usb,
+			.u32 = cvmx_usb_read_csr32(usb,
 						CVMX_USBCX_HFNUM(usb->index))
 		};
 
 		union cvmx_usbcx_hfir hfir = {
-			.u32 = __cvmx_usb_read_csr32(usb,
+			.u32 = cvmx_usb_read_csr32(usb,
 						CVMX_USBCX_HFIR(usb->index))
 		};
 
@@ -1996,23 +1992,23 @@ static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 			 * way we are sure that the periodic data is sent in the
 			 * beginning of the frame
 			 */
-			pipe = __cvmx_usb_find_ready_pipe(usb,
+			pipe = cvmx_usb_find_ready_pipe(usb,
 					usb->active_pipes +
 					CVMX_USB_TRANSFER_ISOCHRONOUS,
 					usb->frame_number);
 			if (likely(!pipe))
-				pipe = __cvmx_usb_find_ready_pipe(usb,
+				pipe = cvmx_usb_find_ready_pipe(usb,
 						usb->active_pipes +
 						CVMX_USB_TRANSFER_INTERRUPT,
 						usb->frame_number);
 		}
 		if (likely(!pipe)) {
-			pipe = __cvmx_usb_find_ready_pipe(usb,
+			pipe = cvmx_usb_find_ready_pipe(usb,
 					usb->active_pipes +
 					CVMX_USB_TRANSFER_CONTROL,
 					usb->frame_number);
 			if (likely(!pipe))
-				pipe = __cvmx_usb_find_ready_pipe(usb,
+				pipe = cvmx_usb_find_ready_pipe(usb,
 						usb->active_pipes +
 						CVMX_USB_TRANSFER_BULK,
 						usb->frame_number);
@@ -2020,7 +2016,7 @@ static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 		if (!pipe)
 			break;
 
-		__cvmx_usb_start_channel(usb, channel, pipe);
+		cvmx_usb_start_channel(usb, channel, pipe);
 	}
 
 done:
@@ -2143,11 +2139,10 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
  * @complete_code:
  *		 Completion code
  */
-static void __cvmx_usb_perform_complete(
-				struct cvmx_usb_state *usb,
-				struct cvmx_usb_pipe *pipe,
-				struct cvmx_usb_transaction *transaction,
-				enum cvmx_usb_complete complete_code)
+static void cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
+				      struct cvmx_usb_pipe *pipe,
+				      struct cvmx_usb_transaction *transaction,
+				      enum cvmx_usb_complete complete_code)
 {
 	/* If this was a split then clear our split in progress marker */
 	if (usb->active_split == transaction)
@@ -2213,7 +2208,7 @@ static void __cvmx_usb_perform_complete(
  *
  * Returns: Transaction or NULL on failure.
  */
-static struct cvmx_usb_transaction *__cvmx_usb_submit_transaction(
+static struct cvmx_usb_transaction *cvmx_usb_submit_transaction(
 				struct cvmx_usb_state *usb,
 				struct cvmx_usb_pipe *pipe,
 				enum cvmx_usb_transfer type,
@@ -2259,7 +2254,7 @@ static struct cvmx_usb_transaction *__cvmx_usb_submit_transaction(
 		 * We may need to schedule the pipe if this was the head of the
 		 * pipe.
 		 */
-		__cvmx_usb_schedule(usb, 0);
+		cvmx_usb_schedule(usb, 0);
 	}
 
 	return transaction;
@@ -2280,14 +2275,14 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_bulk(
 						struct cvmx_usb_pipe *pipe,
 						struct urb *urb)
 {
-	return __cvmx_usb_submit_transaction(usb, pipe, CVMX_USB_TRANSFER_BULK,
-					     urb->transfer_dma,
-					     urb->transfer_buffer_length,
-					     0, /* control_header */
-					     0, /* iso_start_frame */
-					     0, /* iso_number_packets */
-					     NULL, /* iso_packets */
-					     urb);
+	return cvmx_usb_submit_transaction(usb, pipe, CVMX_USB_TRANSFER_BULK,
+					   urb->transfer_dma,
+					   urb->transfer_buffer_length,
+					   0, /* control_header */
+					   0, /* iso_start_frame */
+					   0, /* iso_number_packets */
+					   NULL, /* iso_packets */
+					   urb);
 }
 
 
@@ -2305,15 +2300,15 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_interrupt(
 						struct cvmx_usb_pipe *pipe,
 						struct urb *urb)
 {
-	return __cvmx_usb_submit_transaction(usb, pipe,
-					     CVMX_USB_TRANSFER_INTERRUPT,
-					     urb->transfer_dma,
-					     urb->transfer_buffer_length,
-					     0, /* control_header */
-					     0, /* iso_start_frame */
-					     0, /* iso_number_packets */
-					     NULL, /* iso_packets */
-					     urb);
+	return cvmx_usb_submit_transaction(usb, pipe,
+					   CVMX_USB_TRANSFER_INTERRUPT,
+					   urb->transfer_dma,
+					   urb->transfer_buffer_length,
+					   0, /* control_header */
+					   0, /* iso_start_frame */
+					   0, /* iso_number_packets */
+					   NULL, /* iso_packets */
+					   urb);
 }
 
 
@@ -2338,14 +2333,14 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_control(
 	if ((header->bRequestType & USB_DIR_IN) == 0)
 		buffer_length = le16_to_cpu(header->wLength);
 
-	return __cvmx_usb_submit_transaction(usb, pipe,
-					     CVMX_USB_TRANSFER_CONTROL,
-					     urb->transfer_dma, buffer_length,
-					     control_header,
-					     0, /* iso_start_frame */
-					     0, /* iso_number_packets */
-					     NULL, /* iso_packets */
-					     urb);
+	return cvmx_usb_submit_transaction(usb, pipe,
+					   CVMX_USB_TRANSFER_CONTROL,
+					   urb->transfer_dma, buffer_length,
+					   control_header,
+					   0, /* iso_start_frame */
+					   0, /* iso_number_packets */
+					   NULL, /* iso_packets */
+					   urb);
 }
 
 
@@ -2366,14 +2361,14 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_isochronous(
 	struct cvmx_usb_iso_packet *packets;
 
 	packets = (struct cvmx_usb_iso_packet *) urb->setup_packet;
-	return __cvmx_usb_submit_transaction(usb, pipe,
-					     CVMX_USB_TRANSFER_ISOCHRONOUS,
-					     urb->transfer_dma,
-					     urb->transfer_buffer_length,
-					     0, /* control_header */
-					     urb->start_frame,
-					     urb->number_of_packets,
-					     packets, urb);
+	return cvmx_usb_submit_transaction(usb, pipe,
+					   CVMX_USB_TRANSFER_ISOCHRONOUS,
+					   urb->transfer_dma,
+					   urb->transfer_buffer_length,
+					   0, /* control_header */
+					   urb->start_frame,
+					   urb->number_of_packets,
+					   packets, urb);
 }
 
 
@@ -2407,7 +2402,7 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 
 		CVMX_SYNCW;
 
-		usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb,
+		usbc_hcchar.u32 = cvmx_usb_read_csr32(usb,
 				CVMX_USBCX_HCCHARX(pipe->channel, usb->index));
 		/*
 		 * If the channel isn't enabled then the transaction already
@@ -2415,14 +2410,14 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 		 */
 		if (usbc_hcchar.s.chena) {
 			usbc_hcchar.s.chdis = 1;
-			__cvmx_usb_write_csr32(usb,
+			cvmx_usb_write_csr32(usb,
 					CVMX_USBCX_HCCHARX(pipe->channel,
 						usb->index),
 					usbc_hcchar.u32);
 		}
 	}
-	__cvmx_usb_perform_complete(usb, pipe, transaction,
-				    CVMX_USB_COMPLETE_CANCEL);
+	cvmx_usb_perform_complete(usb, pipe, transaction,
+				  CVMX_USB_COMPLETE_CANCEL);
 	return 0;
 }
 
@@ -2487,8 +2482,7 @@ static int cvmx_usb_get_frame_number(struct cvmx_usb_state *usb)
 	int frame_number;
 	union cvmx_usbcx_hfnum usbc_hfnum;
 
-	usbc_hfnum.u32 = __cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_HFNUM(usb->index));
+	usbc_hfnum.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
 	frame_number = usbc_hfnum.s.frnum;
 
 	return frame_number;
@@ -2503,7 +2497,7 @@ static int cvmx_usb_get_frame_number(struct cvmx_usb_state *usb)
  *
  * Returns: Zero on success
  */
-static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
+static int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 {
 	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
 	struct usb_hcd *hcd = octeon_to_hcd(priv);
@@ -2519,11 +2513,11 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	int buffer_space_left;
 
 	/* Read the interrupt status bits for the channel */
-	usbc_hcint.u32 = __cvmx_usb_read_csr32(usb,
-			CVMX_USBCX_HCINTX(channel, usb->index));
+	usbc_hcint.u32 = cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCINTX(channel, usb->index));
 
 	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
-		usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb,
+		usbc_hcchar.u32 = cvmx_usb_read_csr32(usb,
 				CVMX_USBCX_HCCHARX(channel, usb->index));
 
 		if (usbc_hcchar.s.chena && usbc_hcchar.s.chdis) {
@@ -2532,7 +2526,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * interrupt IN transfers to get stuck until we do a
 			 * write of HCCHARX without changing things
 			 */
-			__cvmx_usb_write_csr32(usb,
+			cvmx_usb_write_csr32(usb,
 					CVMX_USBCX_HCCHARX(channel,
 							   usb->index),
 					usbc_hcchar.u32);
@@ -2549,12 +2543,12 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				/* Disable all interrupts except CHHLTD */
 				hcintmsk.u32 = 0;
 				hcintmsk.s.chhltdmsk = 1;
-				__cvmx_usb_write_csr32(usb,
+				cvmx_usb_write_csr32(usb,
 						CVMX_USBCX_HCINTMSKX(channel,
 							usb->index),
 						hcintmsk.u32);
 				usbc_hcchar.s.chdis = 1;
-				__cvmx_usb_write_csr32(usb,
+				cvmx_usb_write_csr32(usb,
 						CVMX_USBCX_HCCHARX(channel,
 							usb->index),
 						usbc_hcchar.u32);
@@ -2580,9 +2574,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	}
 
 	/* Disable the channel interrupts now that it is done */
-	__cvmx_usb_write_csr32(usb,
-				CVMX_USBCX_HCINTMSKX(channel, usb->index),
-				0);
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
 	usb->idle_hardware_channels |= (1<<channel);
 
 	/* Make sure this channel is tied to a valid pipe */
@@ -2606,9 +2598,9 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	 * Read the channel config info so we can figure out how much data
 	 * transferred
 	 */
-	usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb,
+	usbc_hcchar.u32 = cvmx_usb_read_csr32(usb,
 			CVMX_USBCX_HCCHARX(channel, usb->index));
-	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb,
+	usbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,
 			CVMX_USBCX_HCTSIZX(channel, usb->index));
 
 	/*
@@ -2693,8 +2685,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		 * the actual bytes transferred
 		 */
 		pipe->pid_toggle = 0;
-		__cvmx_usb_perform_complete(usb, pipe, transaction,
-					    CVMX_USB_COMPLETE_STALL);
+		cvmx_usb_perform_complete(usb, pipe, transaction,
+					  CVMX_USB_COMPLETE_STALL);
 	} else if (usbc_hcint.s.xacterr) {
 		/*
 		 * We know at least one packet worked if we get a ACK or NAK.
@@ -2709,8 +2701,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * something wrong with the transfer. For example, PID
 			 * toggle errors cause these
 			 */
-			__cvmx_usb_perform_complete(usb, pipe, transaction,
-						    CVMX_USB_COMPLETE_XACTERR);
+			cvmx_usb_perform_complete(usb, pipe, transaction,
+						  CVMX_USB_COMPLETE_XACTERR);
 		} else {
 			/*
 			 * If this was a split then clear our split in progress
@@ -2733,12 +2725,12 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		}
 	} else if (usbc_hcint.s.bblerr) {
 		/* Babble Error (BblErr) */
-		__cvmx_usb_perform_complete(usb, pipe, transaction,
-					    CVMX_USB_COMPLETE_BABBLEERR);
+		cvmx_usb_perform_complete(usb, pipe, transaction,
+					  CVMX_USB_COMPLETE_BABBLEERR);
 	} else if (usbc_hcint.s.datatglerr) {
 		/* Data toggle error */
-		__cvmx_usb_perform_complete(usb, pipe, transaction,
-					    CVMX_USB_COMPLETE_DATATGLERR);
+		cvmx_usb_perform_complete(usb, pipe, transaction,
+					  CVMX_USB_COMPLETE_DATATGLERR);
 	} else if (usbc_hcint.s.nyet) {
 		/*
 		 * NYET as a response is only allowed in three cases: as a
@@ -2746,7 +2738,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		 * as a response to a bulk out. The ping case is handled by
 		 * hardware, so we only have splits and bulk out
 		 */
-		if (!__cvmx_usb_pipe_needs_split(usb, pipe)) {
+		if (!cvmx_usb_pipe_needs_split(usb, pipe)) {
 			transaction->retries = 0;
 			/*
 			 * If there is more data to go then we need to try
@@ -2754,7 +2746,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 */
 			if ((buffer_space_left == 0) ||
 				(bytes_in_last_packet < pipe->max_packet))
-				__cvmx_usb_perform_complete(usb, pipe,
+				cvmx_usb_perform_complete(usb, pipe,
 						transaction,
 						CVMX_USB_COMPLETE_SUCCESS);
 		} else {
@@ -2794,12 +2786,12 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			case CVMX_USB_STAGE_NON_CONTROL:
 			case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
 				/* This should be impossible */
-				__cvmx_usb_perform_complete(usb, pipe,
+				cvmx_usb_perform_complete(usb, pipe,
 					transaction, CVMX_USB_COMPLETE_ERROR);
 				break;
 			case CVMX_USB_STAGE_SETUP:
 				pipe->pid_toggle = 1;
-				if (__cvmx_usb_pipe_needs_split(usb, pipe))
+				if (cvmx_usb_pipe_needs_split(usb, pipe))
 					transaction->stage =
 						CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE;
 				else {
@@ -2826,7 +2818,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				}
 				break;
 			case CVMX_USB_STAGE_DATA:
-				if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+				if (cvmx_usb_pipe_needs_split(usb, pipe)) {
 					transaction->stage =
 						CVMX_USB_STAGE_DATA_SPLIT_COMPLETE;
 					/*
@@ -2864,16 +2856,16 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				}
 				break;
 			case CVMX_USB_STAGE_STATUS:
-				if (__cvmx_usb_pipe_needs_split(usb, pipe))
+				if (cvmx_usb_pipe_needs_split(usb, pipe))
 					transaction->stage =
 						CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;
 				else
-					__cvmx_usb_perform_complete(usb, pipe,
+					cvmx_usb_perform_complete(usb, pipe,
 						transaction,
 						CVMX_USB_COMPLETE_SUCCESS);
 				break;
 			case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
-				__cvmx_usb_perform_complete(usb, pipe,
+				cvmx_usb_perform_complete(usb, pipe,
 						transaction,
 						CVMX_USB_COMPLETE_SUCCESS);
 				break;
@@ -2887,7 +2879,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * For splits we need to continue the transfer if more
 			 * data is needed
 			 */
-			if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+			if (cvmx_usb_pipe_needs_split(usb, pipe)) {
 				if (transaction->stage ==
 						CVMX_USB_STAGE_NON_CONTROL)
 					transaction->stage =
@@ -2903,7 +2895,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 							CVMX_USB_TRANSFER_INTERRUPT)
 							pipe->next_tx_frame +=
 								pipe->interval;
-							__cvmx_usb_perform_complete(
+							cvmx_usb_perform_complete(
 								usb,
 								pipe,
 								transaction,
@@ -2927,15 +2919,14 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 						CVMX_USB_TRANSFER_INTERRUPT)
 						pipe->next_tx_frame +=
 							pipe->interval;
-					__cvmx_usb_perform_complete(usb,
-						pipe,
+					cvmx_usb_perform_complete(usb, pipe,
 						transaction,
 						CVMX_USB_COMPLETE_SUCCESS);
 				}
 			}
 			break;
 		case CVMX_USB_TRANSFER_ISOCHRONOUS:
-			if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+			if (cvmx_usb_pipe_needs_split(usb, pipe)) {
 				/*
 				 * ISOCHRONOUS OUT splits don't require a
 				 * complete split stage. Instead they use a
@@ -2956,10 +2947,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 						(bytes_this_transfer < 188)) {
 						pipe->next_tx_frame +=
 							pipe->interval;
-						__cvmx_usb_perform_complete(
-							usb,
-							pipe,
-							transaction,
+						cvmx_usb_perform_complete(usb,
+							pipe, transaction,
 							CVMX_USB_COMPLETE_SUCCESS);
 					}
 				} else {
@@ -2976,7 +2965,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 							 pipe->max_packet)) {
 							pipe->next_tx_frame +=
 								pipe->interval;
-							__cvmx_usb_perform_complete(
+							cvmx_usb_perform_complete(
 								usb,
 								pipe,
 								transaction,
@@ -2988,8 +2977,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				}
 			} else {
 				pipe->next_tx_frame += pipe->interval;
-				__cvmx_usb_perform_complete(usb,
-						pipe,
+				cvmx_usb_perform_complete(usb, pipe,
 						transaction,
 						CVMX_USB_COMPLETE_SUCCESS);
 			}
@@ -3027,7 +3015,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * We get channel halted interrupts with no result bits
 			 * sets when the cable is unplugged
 			 */
-			__cvmx_usb_perform_complete(usb, pipe, transaction,
+			cvmx_usb_perform_complete(usb, pipe, transaction,
 					CVMX_USB_COMPLETE_ERROR);
 		}
 	}
@@ -3061,21 +3049,19 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 	prefetch_range(usb, sizeof(*usb));
 
 	/* Update the frame counter */
-	usbc_hfnum.u32 = __cvmx_usb_read_csr32(usb,
-						CVMX_USBCX_HFNUM(usb->index));
+	usbc_hfnum.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
 	if ((usb->frame_number&0x3fff) > usbc_hfnum.s.frnum)
 		usb->frame_number += 0x4000;
 	usb->frame_number &= ~0x3fffull;
 	usb->frame_number |= usbc_hfnum.s.frnum;
 
 	/* Read the pending interrupts */
-	usbc_gintsts.u32 = __cvmx_usb_read_csr32(usb,
-						CVMX_USBCX_GINTSTS(usb->index));
+	usbc_gintsts.u32 = cvmx_usb_read_csr32(usb,
+					       CVMX_USBCX_GINTSTS(usb->index));
 
 	/* Clear the interrupts now that we know about them */
-	__cvmx_usb_write_csr32(usb,
-				CVMX_USBCX_GINTSTS(usb->index),
-				usbc_gintsts.u32);
+	cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index),
+			     usbc_gintsts.u32);
 
 	if (usbc_gintsts.s.rxflvl) {
 		/*
@@ -3086,12 +3072,12 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 		 * In DMA mode this is handled by hardware
 		 */
 		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
-			__cvmx_usb_poll_rx_fifo(usb);
+			cvmx_usb_poll_rx_fifo(usb);
 	}
 	if (usbc_gintsts.s.ptxfemp || usbc_gintsts.s.nptxfemp) {
 		/* Fill the Tx FIFOs when not in DMA mode */
 		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
-			__cvmx_usb_poll_tx_fifo(usb);
+			cvmx_usb_poll_tx_fifo(usb);
 	}
 	if (usbc_gintsts.s.disconnint || usbc_gintsts.s.prtint) {
 		union cvmx_usbcx_hprt usbc_hprt;
@@ -3111,11 +3097,11 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 		 */
 		octeon_usb_port_callback(usb);
 		/* Clear the port change bits */
-		usbc_hprt.u32 = __cvmx_usb_read_csr32(usb,
-				CVMX_USBCX_HPRT(usb->index));
+		usbc_hprt.u32 = cvmx_usb_read_csr32(usb,
+					CVMX_USBCX_HPRT(usb->index));
 		usbc_hprt.s.prtena = 0;
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HPRT(usb->index),
-				       usbc_hprt.u32);
+		cvmx_usb_write_csr32(usb, CVMX_USBCX_HPRT(usb->index),
+				     usbc_hprt.u32);
 	}
 	if (usbc_gintsts.s.hchint) {
 		/*
@@ -3132,18 +3118,18 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 		 */
 		union cvmx_usbcx_haint usbc_haint;
 
-		usbc_haint.u32 = __cvmx_usb_read_csr32(usb,
+		usbc_haint.u32 = cvmx_usb_read_csr32(usb,
 					CVMX_USBCX_HAINT(usb->index));
 		while (usbc_haint.u32) {
 			int channel;
 
 			channel = __fls(usbc_haint.u32);
-			__cvmx_usb_poll_channel(usb, channel);
+			cvmx_usb_poll_channel(usb, channel);
 			usbc_haint.u32 ^= 1<<channel;
 		}
 	}
 
-	__cvmx_usb_schedule(usb, usbc_gintsts.s.sof);
+	cvmx_usb_schedule(usb, usbc_gintsts.s.sof);
 
 	return 0;
 }

commit c4bdbdd916036effd90b18165819879b01c1fed8
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:46 2015 +0200

    staging: octeon-usb: eliminate 64-bit register access wrappers
    
    Eliminate 64-bit register access wrappers. Since we don't implement
    register-level debugging outputs, these are useless.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 169bc099f14c..239606555db7 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -581,38 +581,6 @@ static inline void __cvmx_usb_write_csr32(struct cvmx_usb_state *usb,
 	cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
 }
 
-
-/**
- * Read a USB 64bit CSR. It logs the value in a readable format if
- * debugging is on.
- *
- * @usb:     USB block this access is for
- * @address: 64bit address to read
- *
- * Returns: Result of the read
- */
-static inline uint64_t __cvmx_usb_read_csr64(struct cvmx_usb_state *usb,
-					     uint64_t address)
-{
-	uint64_t result = cvmx_read64_uint64(address);
-	return result;
-}
-
-
-/**
- * Write a USB 64bit CSR. It logs the value in a readable format
- * if debugging is on.
- *
- * @usb:     USB block this access is for
- * @address: 64bit address to write
- * @value:   Value to write
- */
-static inline void __cvmx_usb_write_csr64(struct cvmx_usb_state *usb,
-					  uint64_t address, uint64_t value)
-{
-	cvmx_write64_uint64(address, value);
-}
-
 /**
  * Return non zero if this pipe connects to a non HIGH speed
  * device through a high speed hub.
@@ -683,8 +651,7 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	 * 2a. Write USBN0/1_CLK_CTL[POR] = 1 and
 	 *     USBN0/1_CLK_CTL[HRST,PRST,HCLK_RST] = 0
 	 */
-	usbn_clk_ctl.u64 =
-		__cvmx_usb_read_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index));
+	usbn_clk_ctl.u64 = cvmx_read64_uint64(CVMX_USBNX_CLK_CTL(usb->index));
 	usbn_clk_ctl.s.por = 1;
 	usbn_clk_ctl.s.hrst = 0;
 	usbn_clk_ctl.s.prst = 0;
@@ -747,12 +714,10 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		usbn_clk_ctl.s.divide = divisor;
 		usbn_clk_ctl.s.divide2 = 0;
 	}
-	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
-			       usbn_clk_ctl.u64);
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
 	/* 2d. Write USBN0/1_CLK_CTL[HCLK_RST] = 1 */
 	usbn_clk_ctl.s.hclk_rst = 1;
-	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
-			       usbn_clk_ctl.u64);
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
 	/* 2e.  Wait 64 core-clock cycles for HCLK to stabilize */
 	cvmx_wait(64);
 	/*
@@ -761,8 +726,7 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	 *    USBN_CLK_CTL[POR] = 0
 	 */
 	usbn_clk_ctl.s.por = 0;
-	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
-			       usbn_clk_ctl.u64);
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
 	/* 4. Wait 1 ms for PHY clock to start */
 	mdelay(1);
 	/*
@@ -770,11 +734,11 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	 *    USBP control and status register:
 	 *    USBN_USBP_CTL_STATUS[ATE_RESET] = 1
 	 */
-	usbn_usbp_ctl_status.u64 = __cvmx_usb_read_csr64(usb,
-			CVMX_USBNX_USBP_CTL_STATUS(usb->index));
+	usbn_usbp_ctl_status.u64 =
+		cvmx_read64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index));
 	usbn_usbp_ctl_status.s.ate_reset = 1;
-	__cvmx_usb_write_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index),
-			       usbn_usbp_ctl_status.u64);
+	cvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),
+			    usbn_usbp_ctl_status.u64);
 	/* 6. Wait 10 cycles */
 	cvmx_wait(10);
 	/*
@@ -782,23 +746,22 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	 *    USBN_USBP_CTL_STATUS[ATE_RESET] = 0
 	 */
 	usbn_usbp_ctl_status.s.ate_reset = 0;
-	__cvmx_usb_write_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index),
-			       usbn_usbp_ctl_status.u64);
+	cvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),
+			    usbn_usbp_ctl_status.u64);
 	/*
 	 * 8. Program the PHY reset field in the USBN clock-control register:
 	 *    USBN_CLK_CTL[PRST] = 1
 	 */
 	usbn_clk_ctl.s.prst = 1;
-	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
-			       usbn_clk_ctl.u64);
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
 	/*
 	 * 9. Program the USBP control and status register to select host or
 	 *    device mode. USBN_USBP_CTL_STATUS[HST_MODE] = 0 for host, = 1 for
 	 *    device
 	 */
 	usbn_usbp_ctl_status.s.hst_mode = 0;
-	__cvmx_usb_write_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index),
-			       usbn_usbp_ctl_status.u64);
+	cvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),
+			    usbn_usbp_ctl_status.u64);
 	/* 10. Wait 1 us */
 	udelay(1);
 	/*
@@ -806,12 +769,10 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	 *     USBN_CLK_CTL[HRST] = 1
 	 */
 	usbn_clk_ctl.s.hrst = 1;
-	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
-			       usbn_clk_ctl.u64);
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
 	/* 12. Proceed to USB core initialization */
 	usbn_clk_ctl.s.enable = 1;
-	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
-			       usbn_clk_ctl.u64);
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
 	udelay(1);
 
 	/*
@@ -969,15 +930,13 @@ static int cvmx_usb_shutdown(struct cvmx_usb_state *usb)
 		return -EBUSY;
 
 	/* Disable the clocks and put them in power on reset */
-	usbn_clk_ctl.u64 = __cvmx_usb_read_csr64(usb,
-			CVMX_USBNX_CLK_CTL(usb->index));
+	usbn_clk_ctl.u64 = cvmx_read64_uint64(CVMX_USBNX_CLK_CTL(usb->index));
 	usbn_clk_ctl.s.enable = 1;
 	usbn_clk_ctl.s.por = 1;
 	usbn_clk_ctl.s.hclk_rst = 1;
 	usbn_clk_ctl.s.prst = 0;
 	usbn_clk_ctl.s.hrst = 0;
-	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
-			       usbn_clk_ctl.u64);
+	cvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);
 	return 0;
 }
 
@@ -1286,13 +1245,12 @@ static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
 		return;
 
 	/* Get where the DMA engine would have written this data */
-	address = __cvmx_usb_read_csr64(usb,
-			CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel*8);
+	address = cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index) +
+				     channel * 8);
 
 	ptr = cvmx_phys_to_ptr(address);
-	__cvmx_usb_write_csr64(usb,
-			       CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel*8,
-			       address + bytes);
+	cvmx_write64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel * 8,
+			    address + bytes);
 
 	/* Loop writing the FIFO data for this packet into memory */
 	while (bytes > 0) {
@@ -1448,8 +1406,9 @@ static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
 		fifo = &usb->nonperiodic;
 
 	fifo->entry[fifo->head].channel = channel;
-	fifo->entry[fifo->head].address = __cvmx_usb_read_csr64(usb,
-			CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8);
+	fifo->entry[fifo->head].address =
+		cvmx_read64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +
+				   channel * 8);
 	fifo->entry[fifo->head].size = (usbc_hctsiz.s.xfersize+3)>>2;
 	fifo->head++;
 	if (fifo->head > MAX_CHANNELS)
@@ -1503,9 +1462,9 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 		 * Setup send the control header instead of the buffer data. The
 		 * buffer data will be used in the next stage
 		 */
-		__cvmx_usb_write_csr64(usb,
-			CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8,
-			transaction->control_header);
+		cvmx_write64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +
+					channel * 8,
+				    transaction->control_header);
 		break;
 	case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
 		usbc_hctsiz.s.pid = 3; /* Setup */
@@ -1696,13 +1655,12 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 					transaction->iso_packets[0].offset +
 					transaction->actual_bytes;
 
-		__cvmx_usb_write_csr64(usb,
-			CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8,
-			dma_address);
-
-		__cvmx_usb_write_csr64(usb,
-			CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel*8,
-			dma_address);
+		cvmx_write64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +
+					channel * 8,
+				    dma_address);
+		cvmx_write64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index) +
+					channel * 8,
+				    dma_address);
 	}
 
 	/* Setup both the size of the transfer and the SPLIT characteristics */

commit 607078fcb1614b505a4904ab51a2eb2ebf6b9d7b
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Mar 22 17:37:45 2015 +0200

    staging: octeon-usb: remove internal function parameter sanity checks
    
    Remove some function parameter sanity checks from internal functions
    where we can rely them being called with sane parameters.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 959123279ce8..169bc099f14c 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -231,15 +231,6 @@ enum cvmx_usb_pipe_flags {
 /* Maximum number of hardware channels supported by the USB block */
 #define MAX_CHANNELS		8
 
-/* The highest valid USB device address */
-#define MAX_USB_ADDRESS		127
-
-/* The highest valid USB endpoint number */
-#define MAX_USB_ENDPOINT	15
-
-/* The highest valid port number on a hub */
-#define MAX_USB_HUB_PORT	15
-
 /*
  * The low level hardware can transfer a maximum of this number of bytes in each
  * transfer. The field is 19 bits wide
@@ -675,10 +666,6 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	union cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;
 	int i;
 
-	/* At first allow 0-1 for the usb port number */
-	if ((usb_port_number < 0) || (usb_port_number > 1))
-		return -EINVAL;
-
 	memset(usb, 0, sizeof(*usb));
 	usb->init_flags = flags;
 
@@ -1223,34 +1210,6 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 {
 	struct cvmx_usb_pipe *pipe;
 
-	if (unlikely((device_addr < 0) || (device_addr > MAX_USB_ADDRESS)))
-		return NULL;
-	if (unlikely((endpoint_num < 0) || (endpoint_num > MAX_USB_ENDPOINT)))
-		return NULL;
-	if (unlikely(device_speed > CVMX_USB_SPEED_LOW))
-		return NULL;
-	if (unlikely((max_packet <= 0) || (max_packet > 1024)))
-		return NULL;
-	if (unlikely(transfer_type > CVMX_USB_TRANSFER_INTERRUPT))
-		return NULL;
-	if (unlikely((transfer_dir != CVMX_USB_DIRECTION_OUT) &&
-		(transfer_dir != CVMX_USB_DIRECTION_IN)))
-		return NULL;
-	if (unlikely(interval < 0))
-		return NULL;
-	if (unlikely((transfer_type == CVMX_USB_TRANSFER_CONTROL) && interval))
-		return NULL;
-	if (unlikely(multi_count < 0))
-		return NULL;
-	if (unlikely((device_speed != CVMX_USB_SPEED_HIGH) &&
-		(multi_count != 0)))
-		return NULL;
-	if (unlikely((hub_device_addr < 0) ||
-		(hub_device_addr > MAX_USB_ADDRESS)))
-		return NULL;
-	if (unlikely((hub_port < 0) || (hub_port > MAX_USB_HUB_PORT)))
-		return NULL;
-
 	pipe = kzalloc(sizeof(*pipe), GFP_ATOMIC);
 	if (!pipe)
 		return NULL;

commit 877945759df5ff6e7fb434cb5b6cddb606c2f66f
Author: Fabian Frederick <fabf@skynet.be>
Date:   Mon Mar 16 20:59:08 2015 +0100

    Staging: octeon: constify of_device_id array
    
    of_device_id is always used as const.
    (See driver.of_match_table and open firmware functions)
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 1daeb3125a1f..959123279ce8 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3885,7 +3885,7 @@ static int octeon_usb_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static struct of_device_id octeon_usb_match[] = {
+static const struct of_device_id octeon_usb_match[] = {
 	{
 		.compatible = "cavium,octeon-5750-usbc",
 	},

commit 1cf3273dfbd7918fd43e0c70c65795a89f8e88d7
Author: Gustavo A. R. Silva <silvagustavosilva@gmail.com>
Date:   Sun Jan 11 15:50:37 2015 -0600

    Staging: octeon-usb: Fixed a typo
    
    Fixed a typo in octeon-hcd.c file
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 6b8b108c4e6d..1daeb3125a1f 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2687,7 +2687,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 
 	/*
 	 * Read the channel config info so we can figure out how much data
-	 * transfered
+	 * transferred
 	 */
 	usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb,
 			CVMX_USBCX_HCCHARX(channel, usb->index));

commit dab363f938a53ddaee60bfecc1aebdbb3d3af5f0
Merge: a68db9cb858d 17d2c6439be6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 15 18:06:13 2014 -0800

    Merge tag 'staging-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging driver updates from Greg KH:
     "Here's the big staging tree pull request for 3.19-rc1.
    
      We continued to delete more lines than were added, always a good
      thing, but not at a huge rate this release, only about 70k lines
      removed overall mostly from removing the horrid bcm driver.
    
      Lots of normal staging driver cleanups and fixes all over the place,
      well over a thousand of them, the shortlog shows all the horrid
      details.
    
      The "contentious" thing here is the movement of the Android binder
      code out of staging into the "real" part of the kernel.  This is code
      that has been stable for a few years now and is working as-is in the
      tens of millions of devices with no issues.  Yes, the code is horrid,
      and the userspace api leaves a lot to be desired, but it's not going
      to change due to legacy issues that we have no control over.  Because
      so many devices and companies rely on this, and the code is stable,
      might as well promote it out of staging.
    
      This was all discussed at the Linux Plumbers conference, and everyone
      participating agreed that this was the best way forward.
    
      There is work happening to replace the binder code with something new
      that is happening right now, but I don't expect to see the results of
      that work for another year at the earliest.  If that ever happens, and
      Android switches over to it, I'll gladly remove this version.
    
      As for maintainers, I'll be glad to maintain this code, I've been
      doing it for the past few years with no problems.  I'll send a
      MAINTAINERS entry for it before 3.19-final is out, still need to talk
      to the Google developers about if they are willing to help with it or
      not, last I checked they were, which was good.
    
      All of these patches have been in linux-next for a while with no
      reported issues"
    
    * tag 'staging-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (1382 commits)
      Staging: slicoss: Fix long line issues in slicoss.c
      staging: rtl8712: remove unnecessary else after return
      staging: comedi: change some printk calls to pr_err
      staging: rtl8723au: hal: Removed the extra semicolon
      lustre: Deletion of unnecessary checks before three function calls
      staging: lustre: fix sparse warnings: static function declaration
      staging: lustre: fixed sparse warnings related to static declarations
      staging: unisys: remove duplicate header
      staging: unisys: remove unneeded structure
      staging: ft1000 : replace __attribute ((__packed__) with __packed
      drivers: staging: rtl8192e: Include "asm/unaligned.h" instead of "access_ok.h" in "rtl819x_BAProc.c"
      Drivers:staging:rtl8192e: Fixed checkpatch warning
      Drivers:staging:clocking-wizard: Added a newline
      staging: clocking-wizard: check for a valid clk_name pointer
      staging: rtl8723au: Hal_InitPGData() avoid unnecessary typecasts
      staging: rtl8723au: _DisableAnalog(): Avoid zero-init variables unnecessarily
      staging: rtl8723au: Remove unnecessary wrapper _ResetDigitalProcedure1()
      staging: rtl8723au: _ResetDigitalProcedure1_92C() reduce code obfuscation
      staging: rtl8723au: Remove unnecessary wrapper _DisableRFAFEAndResetBB()
      staging: rtl8723au: _DisableRFAFEAndResetBB8192C(): Reduce code obfuscation
      ...

commit ba0b8e420a7c9527d3f3a7276d48885e9e975fa7
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Nov 7 23:43:34 2014 +0200

    staging: octeon-usb: eliminate cvmx_dprintf() usage
    
    Eliminate cvmx_dprintf() usage and use dev_err() instead.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 57ae66b8fd7b..fbca966ba72e 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1512,6 +1512,9 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 					     int channel,
 					     struct cvmx_usb_pipe *pipe)
 {
+	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
+	struct usb_hcd *hcd = octeon_to_hcd(priv);
+	struct device *dev = hcd->self.controller;
 	struct cvmx_usb_transaction *transaction =
 		list_first_entry(&pipe->transactions, typeof(*transaction),
 				 node);
@@ -1528,7 +1531,7 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 	switch (transaction->stage) {
 	case CVMX_USB_STAGE_NON_CONTROL:
 	case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
-		cvmx_dprintf("%s: ERROR - Non control stage\n", __func__);
+		dev_err(dev, "%s: ERROR - Non control stage\n", __func__);
 		break;
 	case CVMX_USB_STAGE_SETUP:
 		usbc_hctsiz.s.pid = 3; /* Setup */
@@ -2585,6 +2588,9 @@ static int cvmx_usb_get_frame_number(struct cvmx_usb_state *usb)
  */
 static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 {
+	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
+	struct usb_hcd *hcd = octeon_to_hcd(priv);
+	struct device *dev = hcd->self.controller;
 	union cvmx_usbcx_hcintx usbc_hcint;
 	union cvmx_usbcx_hctsizx usbc_hctsiz;
 	union cvmx_usbcx_hccharx usbc_hcchar;
@@ -2642,8 +2648,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				 * Channel halt isn't needed.
 				 */
 			} else {
-				cvmx_dprintf("USB%d: Channel %d interrupt without halt\n",
-						usb->index, channel);
+				dev_err(dev, "USB%d: Channel %d interrupt without halt\n",
+					usb->index, channel);
 				return 0;
 			}
 		}

commit 2e6ac45c4af7dfc2225985bdc5ec0514f6d8d29b
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Fri Nov 7 23:43:33 2014 +0200

    staging: octeon-usb: move helper functions
    
    Move helper functions to make them visible to all functions.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 4337a2fe282e..57ae66b8fd7b 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -456,6 +456,16 @@ struct octeon_temp_buffer {
 	u8 data[0];
 };
 
+static inline struct octeon_hcd *cvmx_usb_to_octeon(struct cvmx_usb_state *p)
+{
+	return container_of(p, struct octeon_hcd, usb);
+}
+
+static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
+{
+	return container_of((void *)p, struct usb_hcd, hcd_priv);
+}
+
 /**
  * octeon_alloc_temp_buffer - allocate a temporary buffer for USB transfer
  *                            (if needed)
@@ -2112,16 +2122,6 @@ static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 			union cvmx_usbcx_gintmsk, sofmsk, need_sof);
 }
 
-static inline struct octeon_hcd *cvmx_usb_to_octeon(struct cvmx_usb_state *p)
-{
-	return container_of(p, struct octeon_hcd, usb);
-}
-
-static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
-{
-	return container_of((void *)p, struct usb_hcd, hcd_priv);
-}
-
 static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 					     enum cvmx_usb_complete status,
 					     struct cvmx_usb_pipe *pipe,

commit a4d9e08f81eb5bd8a6c253de775cc0171a4556cd
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:41 2014 +0200

    staging: octeon-usb: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 5f9db4cbb381..2f8eaf768bf3 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3882,7 +3882,6 @@ static struct of_device_id octeon_usb_match[] = {
 static struct platform_driver octeon_usb_driver = {
 	.driver = {
 		.name       = "OcteonUSB",
-		.owner		= THIS_MODULE,
 		.of_match_table = octeon_usb_match,
 	},
 	.probe      = octeon_usb_probe,

commit 9109fcff29c67ccdd541fa2bcd1cd58a1134ddf9
Author: Aleh Suprunovich <br@ahlamon.org>
Date:   Tue Oct 7 14:52:52 2014 +0300

    staging: octeon-usb: fix checkpatch.pl warnings
    
    fixed several 'line over 80 characters' in places where it can be done
    without changing/refactoring code
    
    Signed-off-by: Aleh Suprunovich <br@ahlamon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 7ac64efc6520..4337a2fe282e 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1327,7 +1327,8 @@ static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
 
 	/* Loop writing the FIFO data for this packet into memory */
 	while (bytes > 0) {
-		*ptr++ = __cvmx_usb_read_csr32(usb, USB_FIFO_ADDRESS(channel, usb->index));
+		*ptr++ = __cvmx_usb_read_csr32(usb,
+				USB_FIFO_ADDRESS(channel, usb->index));
 		bytes -= 4;
 	}
 	CVMX_SYNCW;
@@ -1478,7 +1479,8 @@ static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
 		fifo = &usb->nonperiodic;
 
 	fifo->entry[fifo->head].channel = channel;
-	fifo->entry[fifo->head].address = __cvmx_usb_read_csr64(usb, CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8);
+	fifo->entry[fifo->head].address = __cvmx_usb_read_csr64(usb,
+			CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8);
 	fifo->entry[fifo->head].size = (usbc_hctsiz.s.xfersize+3)>>2;
 	fifo->head++;
 	if (fifo->head > MAX_CHANNELS)
@@ -1699,7 +1701,9 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 			usbc_hcintmsk.s.stallmsk = 1;
 			usbc_hcintmsk.s.xfercomplmsk = 1;
 		}
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), usbc_hcintmsk.u32);
+		__cvmx_usb_write_csr32(usb,
+				CVMX_USBCX_HCINTMSKX(channel, usb->index),
+				usbc_hcintmsk.u32);
 
 		/* Enable the channel interrupt to propagate */
 		usbc_haintmsk.u32 = __cvmx_usb_read_csr32(usb,
@@ -2879,9 +2883,11 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					struct usb_ctrlrequest *header =
 						cvmx_phys_to_ptr(transaction->control_header);
 					if (header->wLength)
-						transaction->stage = CVMX_USB_STAGE_DATA;
+						transaction->stage =
+							CVMX_USB_STAGE_DATA;
 					else
-						transaction->stage = CVMX_USB_STAGE_STATUS;
+						transaction->stage =
+							CVMX_USB_STAGE_STATUS;
 				}
 				break;
 			case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
@@ -2889,9 +2895,11 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					struct usb_ctrlrequest *header =
 						cvmx_phys_to_ptr(transaction->control_header);
 					if (header->wLength)
-						transaction->stage = CVMX_USB_STAGE_DATA;
+						transaction->stage =
+							CVMX_USB_STAGE_DATA;
 					else
-						transaction->stage = CVMX_USB_STAGE_STATUS;
+						transaction->stage =
+							CVMX_USB_STAGE_STATUS;
 				}
 				break;
 			case CVMX_USB_STAGE_DATA:
@@ -3013,7 +3021,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				 * is complete, the pipe sleeps until the next
 				 * schedule interval
 				 */
-				if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {
+				if (pipe->transfer_dir ==
+					CVMX_USB_DIRECTION_OUT) {
 					/*
 					 * If no space left or this wasn't a max
 					 * size packet then this transfer is

commit dea7503ac4c53edfd0d25d6a1c8b360b3db700d7
Author: Tapasweni Pathak <tapaswenipathak@gmail.com>
Date:   Wed Oct 8 22:56:57 2014 +0530

    staging: octeon-usb: use DIV_ROUND_UP
    
    The kernel.h macro DIV_ROUND_UP performs the computation (((n) + (d) - 1) /
    (d)) but is perhaps more readable.
    
    Coccinelle script used :
    
    // <smpl>
    @haskernel@
    @@
    @depends on haskernel@
    expression n,d;
    @@
    (
    - (n + d - 1) / d
    + DIV_ROUND_UP(n,d)
    |
    - (n + (d - 1)) / d
    + DIV_ROUND_UP(n,d)
    )
    @depends on haskernel@
    expression n,d;
    @@
    - DIV_ROUND_UP((n),d)
    + DIV_ROUND_UP(n,d)
    @depends on haskernel@
    expression n,d;
    @@
    - DIV_ROUND_UP(n,(d))
    + DIV_ROUND_UP(n,d)
    // </smpl>
    
    Signed-off-by: Tapasweni Pathak <tapaswenipathak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 6ddde6af7e3a..7ac64efc6520 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -743,7 +743,7 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	 *     such that USB is as close as possible to 125Mhz
 	 */
 	{
-		int divisor = (octeon_get_clock_rate()+125000000-1)/125000000;
+		int divisor = DIV_ROUND_UP(octeon_get_clock_rate(), 125000000);
 		/* Lower than 4 doesn't seem to work properly */
 		if (divisor < 4)
 			divisor = 4;
@@ -1606,8 +1606,8 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 	 * Calculate the number of packets to transfer. If the length is zero
 	 * we still need to transfer one packet
 	 */
-	packets_to_transfer = (bytes_to_transfer + pipe->max_packet - 1) /
-		pipe->max_packet;
+	packets_to_transfer = DIV_ROUND_UP(bytes_to_transfer,
+					   pipe->max_packet);
 	if (packets_to_transfer == 0)
 		packets_to_transfer = 1;
 	else if ((packets_to_transfer > 1) &&
@@ -1852,8 +1852,7 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		 * zero we still need to transfer one packet
 		 */
 		packets_to_transfer =
-			(bytes_to_transfer + pipe->max_packet - 1) /
-			pipe->max_packet;
+			DIV_ROUND_UP(bytes_to_transfer, pipe->max_packet);
 		if (packets_to_transfer == 0)
 			packets_to_transfer = 1;
 		else if ((packets_to_transfer > 1) &&

commit c9a114e70ab0da81797da84e5bc8737e4e82ad91
Author: Sarah Khan <sarahjmi07@gmail.com>
Date:   Tue Oct 7 06:33:54 2014 +0530

    staging: octeon-usb: Removed unnessecary else after return
    
    WARNING: else is generally not useful after return or break
    checkpatch.pl warning in octeon-hcd.c
    
    Signed-off-by: Sarah Khan <sarahjmi07@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 5f9db4cbb381..6ddde6af7e3a 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -640,8 +640,7 @@ static inline int __cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)
 {
 	if (pipe->pid_toggle)
 		return 2; /* Data1 */
-	else
-		return 0; /* Data0 */
+	return 0; /* Data0 */
 }
 
 /**

commit 15ef0cc12482204b968794b25f9e2805509c686b
Author: Nitin Kuppelur <nitinkuppelur@gmail.com>
Date:   Wed Sep 10 03:36:24 2014 +0200

    Staging: octeon-hcd: removed dummy label
    
    This is a patch to the octeon-hcd.c file that fixes
    removes dummy label i.e. label followed by return of
    void function
    
    Signed-off-by: Nitin Kuppelur <nitinkuppelur@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 8a80982c233d..5f9db4cbb381 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2253,7 +2253,7 @@ static void __cvmx_usb_perform_complete(
 			/* Increment to the next location in our packet array */
 			transaction->iso_packets++;
 			transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
-			goto done;
+			return;
 		}
 	}
 
@@ -2266,8 +2266,6 @@ static void __cvmx_usb_perform_complete(
 					 transaction->actual_bytes,
 					 transaction->urb);
 	kfree(transaction);
-done:
-	return;
 }
 
 

commit 9f87b447204cb1cbc6c838f97ff2e365689c15f4
Author: Nitin Kuppelur <nitinkuppelur@gmail.com>
Date:   Mon Sep 8 21:28:30 2014 +0200

    Staging: octeon-hcd: removed unwanted return from void
    
    This is a patch to the octeon-hcd.c file that fixes
    checkpatch.pl warning by removing return statement from
    void functions.
    
    Signed-off-by: Nitin Kuppelur <nitinkuppelur@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 3a5feb4ff182..8a80982c233d 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1332,8 +1332,6 @@ static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
 		bytes -= 4;
 	}
 	CVMX_SYNCW;
-
-	return;
 }
 
 
@@ -1437,8 +1435,6 @@ static void __cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
 					union cvmx_usbcx_gintmsk,
 					nptxfempmsk, 0);
 	}
-
-	return;
 }
 
 
@@ -1490,8 +1486,6 @@ static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
 		fifo->head = 0;
 
 	__cvmx_usb_poll_tx_fifo(usb);
-
-	return;
 }
 
 /**
@@ -1640,7 +1634,6 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 
 	__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index),
 			       usbc_hctsiz.u32);
-	return;
 }
 
 
@@ -1987,7 +1980,6 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 			union cvmx_usbcx_hccharx, chena, 1);
 	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
 		__cvmx_usb_fill_tx_fifo(usb, channel);
-	return;
 }
 
 
@@ -2116,7 +2108,6 @@ static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 	}
 	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
 			union cvmx_usbcx_gintmsk, sofmsk, need_sof);
-	return;
 }
 
 static inline struct octeon_hcd *cvmx_usb_to_octeon(struct cvmx_usb_state *p)

commit 96ee2cc81f278d6c0767f466c11658f5beb5d7c5
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Aug 31 23:43:51 2014 +0300

    staging: octeon-usb: use USB_DIR_IN
    
    Replace a magic value with #defined macro.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index f478f591e40c..3a5feb4ff182 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1554,24 +1554,24 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 	case CVMX_USB_STAGE_DATA:
 		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
 		if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
-			if (header->bRequestType & 0x80)
+			if (header->bRequestType & USB_DIR_IN)
 				bytes_to_transfer = 0;
 			else if (bytes_to_transfer > pipe->max_packet)
 				bytes_to_transfer = pipe->max_packet;
 		}
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
 				union cvmx_usbcx_hccharx, epdir,
-				((header->bRequestType & 0x80) ?
+				((header->bRequestType & USB_DIR_IN) ?
 					CVMX_USB_DIRECTION_IN :
 					CVMX_USB_DIRECTION_OUT));
 		break;
 	case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
 		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
-		if (!(header->bRequestType & 0x80))
+		if (!(header->bRequestType & USB_DIR_IN))
 			bytes_to_transfer = 0;
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
 				union cvmx_usbcx_hccharx, epdir,
-				((header->bRequestType & 0x80) ?
+				((header->bRequestType & USB_DIR_IN) ?
 					CVMX_USB_DIRECTION_IN :
 					CVMX_USB_DIRECTION_OUT));
 		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
@@ -1582,7 +1582,7 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 		bytes_to_transfer = 0;
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
 				union cvmx_usbcx_hccharx, epdir,
-				((header->bRequestType & 0x80) ?
+				((header->bRequestType & USB_DIR_IN) ?
 					CVMX_USB_DIRECTION_OUT :
 					CVMX_USB_DIRECTION_IN));
 		break;
@@ -1591,7 +1591,7 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 		bytes_to_transfer = 0;
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
 				union cvmx_usbcx_hccharx, epdir,
-				((header->bRequestType & 0x80) ?
+				((header->bRequestType & USB_DIR_IN) ?
 					CVMX_USB_DIRECTION_OUT :
 					CVMX_USB_DIRECTION_IN));
 		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
@@ -2424,7 +2424,7 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_control(
 	uint64_t control_header = urb->setup_dma;
 	struct usb_ctrlrequest *header = cvmx_phys_to_ptr(control_header);
 
-	if ((header->bRequestType & 0x80) == 0)
+	if ((header->bRequestType & USB_DIR_IN) == 0)
 		buffer_length = le16_to_cpu(header->wLength);
 
 	return __cvmx_usb_submit_transaction(usb, pipe,

commit e301dfb208ac25db6c133079de7ae5d99cf48b5f
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Aug 31 23:43:50 2014 +0300

    staging: octeon-usb: use generic control packet header
    
    Use generic control packet header structure definition.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 095cc146eefc..f478f591e40c 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -169,27 +169,6 @@ struct cvmx_usb_port_status {
 	uint32_t connect_change		: 1;
 };
 
-/**
- * union cvmx_usb_control_header - the structure of a Control packet header
- *
- * @s.request_type:	Bit 7 tells the direction: 1=IN, 0=OUT
- * @s.request		The standard usb request to make
- * @s.value		Value parameter for the request in little endian format
- * @s.index		Index for the request in little endian format
- * @s.length		Length of the data associated with this request in
- *			little endian format
- */
-union cvmx_usb_control_header {
-	uint64_t u64;
-	struct {
-		uint64_t request_type   : 8;
-		uint64_t request        : 8;
-		uint64_t value          : 16;
-		uint64_t index          : 16;
-		uint64_t length         : 16;
-	} s;
-};
-
 /**
  * struct cvmx_usb_iso_packet - descriptor for Isochronous packets
  *
@@ -1531,7 +1510,7 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 	struct cvmx_usb_transaction *transaction =
 		list_first_entry(&pipe->transactions, typeof(*transaction),
 				 node);
-	union cvmx_usb_control_header *header =
+	struct usb_ctrlrequest *header =
 		cvmx_phys_to_ptr(transaction->control_header);
 	int bytes_to_transfer = transaction->buffer_length -
 		transaction->actual_bytes;
@@ -1575,24 +1554,24 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 	case CVMX_USB_STAGE_DATA:
 		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
 		if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
-			if (header->s.request_type & 0x80)
+			if (header->bRequestType & 0x80)
 				bytes_to_transfer = 0;
 			else if (bytes_to_transfer > pipe->max_packet)
 				bytes_to_transfer = pipe->max_packet;
 		}
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
 				union cvmx_usbcx_hccharx, epdir,
-				((header->s.request_type & 0x80) ?
+				((header->bRequestType & 0x80) ?
 					CVMX_USB_DIRECTION_IN :
 					CVMX_USB_DIRECTION_OUT));
 		break;
 	case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
 		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
-		if (!(header->s.request_type & 0x80))
+		if (!(header->bRequestType & 0x80))
 			bytes_to_transfer = 0;
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
 				union cvmx_usbcx_hccharx, epdir,
-				((header->s.request_type & 0x80) ?
+				((header->bRequestType & 0x80) ?
 					CVMX_USB_DIRECTION_IN :
 					CVMX_USB_DIRECTION_OUT));
 		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
@@ -1603,7 +1582,7 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 		bytes_to_transfer = 0;
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
 				union cvmx_usbcx_hccharx, epdir,
-				((header->s.request_type & 0x80) ?
+				((header->bRequestType & 0x80) ?
 					CVMX_USB_DIRECTION_OUT :
 					CVMX_USB_DIRECTION_IN));
 		break;
@@ -1612,7 +1591,7 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 		bytes_to_transfer = 0;
 		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
 				union cvmx_usbcx_hccharx, epdir,
-				((header->s.request_type & 0x80) ?
+				((header->bRequestType & 0x80) ?
 					CVMX_USB_DIRECTION_OUT :
 					CVMX_USB_DIRECTION_IN));
 		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
@@ -2443,11 +2422,10 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_control(
 {
 	int buffer_length = urb->transfer_buffer_length;
 	uint64_t control_header = urb->setup_dma;
-	union cvmx_usb_control_header *header =
-		cvmx_phys_to_ptr(control_header);
+	struct usb_ctrlrequest *header = cvmx_phys_to_ptr(control_header);
 
-	if ((header->s.request_type & 0x80) == 0)
-		buffer_length = le16_to_cpu(header->s.length);
+	if ((header->bRequestType & 0x80) == 0)
+		buffer_length = le16_to_cpu(header->wLength);
 
 	return __cvmx_usb_submit_transaction(usb, pipe,
 					     CVMX_USB_TRANSFER_CONTROL,
@@ -2911,9 +2889,9 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					transaction->stage =
 						CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE;
 				else {
-					union cvmx_usb_control_header *header =
+					struct usb_ctrlrequest *header =
 						cvmx_phys_to_ptr(transaction->control_header);
-					if (header->s.length)
+					if (header->wLength)
 						transaction->stage = CVMX_USB_STAGE_DATA;
 					else
 						transaction->stage = CVMX_USB_STAGE_STATUS;
@@ -2921,9 +2899,9 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				break;
 			case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
 				{
-					union cvmx_usb_control_header *header =
+					struct usb_ctrlrequest *header =
 						cvmx_phys_to_ptr(transaction->control_header);
-					if (header->s.length)
+					if (header->wLength)
 						transaction->stage = CVMX_USB_STAGE_DATA;
 					else
 						transaction->stage = CVMX_USB_STAGE_STATUS;

commit e5873388e2fe04aca439a44ae00ccfeb8536fc37
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Jun 29 22:52:56 2014 +0300

    staging: octeon-usb: fix endianness bug
    
    wHubCharacteristics gets wrong value on big-endian CPUs.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index a65b708b804a..095cc146eefc 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3628,7 +3628,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		desc->bDescLength = 9;
 		desc->bDescriptorType = 0x29;
 		desc->bNbrPorts = 1;
-		desc->wHubCharacteristics = 0x08;
+		desc->wHubCharacteristics = cpu_to_le16(0x08);
 		desc->bPwrOn2PwrGood = 1;
 		desc->bHubContrCurrent = 0;
 		desc->u.hs.DeviceRemovable[0] = 0;

commit 8dcf4ecea91582ec9c816d91f06475ba92a65ed7
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Jun 29 22:52:55 2014 +0300

    staging: octeon-usb: return transferred bytes only on success
    
    Return transferred bytes only when transfer was successful.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 59cf921f1b59..a65b708b804a 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2162,7 +2162,11 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 	struct usb_hcd *hcd = octeon_to_hcd(priv);
 	struct device *dev = hcd->self.controller;
 
-	urb->actual_length = bytes_transferred;
+	if (likely(status == CVMX_USB_COMPLETE_SUCCESS))
+		urb->actual_length = bytes_transferred;
+	else
+		urb->actual_length = 0;
+
 	urb->hcpriv = NULL;
 
 	/* For Isochronous transactions we need to update the URB packet status

commit d8c39d3f20049473a6d489deb82b5219f2a21316
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Jun 29 22:52:54 2014 +0300

    staging: octeon-usb: don't retry on data toggle error
    
    On data toggle error, we don't know if and how many bytes were
    successfully transferred by DMA. We should just fail the transaction
    instead of trying a retry.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index ab237c5b61b5..59cf921f1b59 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2840,8 +2840,9 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		__cvmx_usb_perform_complete(usb, pipe, transaction,
 					    CVMX_USB_COMPLETE_BABBLEERR);
 	} else if (usbc_hcint.s.datatglerr) {
-		/* We'll retry the exact same transaction again */
-		transaction->retries++;
+		/* Data toggle error */
+		__cvmx_usb_perform_complete(usb, pipe, transaction,
+					    CVMX_USB_COMPLETE_DATATGLERR);
 	} else if (usbc_hcint.s.nyet) {
 		/*
 		 * NYET as a response is only allowed in three cases: as a

commit e5b90898d6360d8904ba439cafa308b073f27a83
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Jun 29 22:52:53 2014 +0300

    staging: octeon-usb: use usb_hcd_link_urb_to_ep()
    
    The driver did not use link_urb_to_ep() / unlink_urb_from_ep(). This
    caused odd behaviour in some error recovery situations, all requests
    would start to fail after the first failure.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index fca4d3407eb6..ab237c5b61b5 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2230,6 +2230,7 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 		urb->status = -EPROTO;
 		break;
 	}
+	usb_hcd_unlink_urb_from_ep(octeon_to_hcd(priv), urb);
 	spin_unlock(&priv->lock);
 	usb_hcd_giveback_urb(octeon_to_hcd(priv), urb, urb->status);
 	spin_lock(&priv->lock);
@@ -3291,10 +3292,17 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	unsigned long flags;
 	struct cvmx_usb_iso_packet *iso_packet;
 	struct usb_host_endpoint *ep = urb->ep;
+	int rc;
 
 	urb->status = 0;
 	spin_lock_irqsave(&priv->lock, flags);
 
+	rc = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (rc) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return rc;
+	}
+
 	if (!ep->hcpriv) {
 		enum cvmx_usb_transfer transfer_type;
 		enum cvmx_usb_speed speed;
@@ -3370,6 +3378,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 					   >> 11) & 0x3,
 					  split_device, split_port);
 		if (!pipe) {
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
 			spin_unlock_irqrestore(&priv->lock, flags);
 			dev_dbg(dev, "Failed to create pipe\n");
 			return -ENOMEM;
@@ -3440,6 +3449,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		break;
 	}
 	if (!transaction) {
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
 		spin_unlock_irqrestore(&priv->lock, flags);
 		dev_dbg(dev, "Failed to submit\n");
 		return -ENOMEM;
@@ -3455,18 +3465,24 @@ static int octeon_usb_urb_dequeue(struct usb_hcd *hcd,
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	unsigned long flags;
+	int rc;
 
 	if (!urb->dev)
 		return -EINVAL;
 
 	spin_lock_irqsave(&priv->lock, flags);
 
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto out;
+
 	urb->status = status;
 	cvmx_usb_cancel(&priv->usb, urb->ep->hcpriv, urb->hcpriv);
 
+out:
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	return 0;
+	return rc;
 }
 
 static void octeon_usb_endpoint_disable(struct usb_hcd *hcd,

commit cdd15d892582a2d11418cce04c13cb806a8a94f0
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Jun 29 22:52:52 2014 +0300

    staging: octeon-usb: drop dequeue tasklet
    
    Cancel requests synchronously instead of using the dequeue tasklet.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index c4c731f60529..fca4d3407eb6 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -422,8 +422,6 @@ struct cvmx_usb_state {
 struct octeon_hcd {
 	spinlock_t lock;
 	struct cvmx_usb_state usb;
-	struct tasklet_struct dequeue_tasklet;
-	struct list_head dequeue_list;
 };
 
 /* This macro spins on a field waiting for it to reach a value */
@@ -2167,15 +2165,6 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 	urb->actual_length = bytes_transferred;
 	urb->hcpriv = NULL;
 
-	if (!list_empty(&urb->urb_list))
-		/*
-		 * It is on the dequeue_list, but we are going to call
-		 * usb_hcd_giveback_urb(), so we must clear it from
-		 * the list.  We got to it before the
-		 * octeon_usb_urb_dequeue_work() tasklet did.
-		 */
-		list_del_init(&urb->urb_list);
-
 	/* For Isochronous transactions we need to update the URB packet status
 	   list from data in our private copy */
 	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
@@ -3304,7 +3293,6 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	struct usb_host_endpoint *ep = urb->ep;
 
 	urb->status = 0;
-	INIT_LIST_HEAD(&urb->urb_list);	/* not enqueued on dequeue_list */
 	spin_lock_irqsave(&priv->lock, flags);
 
 	if (!ep->hcpriv) {
@@ -3461,23 +3449,6 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	return 0;
 }
 
-static void octeon_usb_urb_dequeue_work(unsigned long arg)
-{
-	struct urb *urb;
-	struct urb *next;
-	unsigned long flags;
-	struct octeon_hcd *priv = (struct octeon_hcd *)arg;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	list_for_each_entry_safe(urb, next, &priv->dequeue_list, urb_list) {
-		list_del_init(&urb->urb_list);
-		cvmx_usb_cancel(&priv->usb, urb->ep->hcpriv, urb->hcpriv);
-	}
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-}
-
 static int octeon_usb_urb_dequeue(struct usb_hcd *hcd,
 				  struct urb *urb,
 				  int status)
@@ -3491,12 +3462,10 @@ static int octeon_usb_urb_dequeue(struct usb_hcd *hcd,
 	spin_lock_irqsave(&priv->lock, flags);
 
 	urb->status = status;
-	list_add_tail(&urb->urb_list, &priv->dequeue_list);
+	cvmx_usb_cancel(&priv->usb, urb->ep->hcpriv, urb->hcpriv);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	tasklet_schedule(&priv->dequeue_tasklet);
-
 	return 0;
 }
 
@@ -3868,10 +3837,6 @@ static int octeon_usb_probe(struct platform_device *pdev)
 
 	spin_lock_init(&priv->lock);
 
-	tasklet_init(&priv->dequeue_tasklet, octeon_usb_urb_dequeue_work,
-		     (unsigned long)priv);
-	INIT_LIST_HEAD(&priv->dequeue_list);
-
 	status = cvmx_usb_initialize(&priv->usb, usb_num, initialize_flags);
 	if (status) {
 		dev_dbg(dev, "USB initialization failed with %d\n", status);
@@ -3908,7 +3873,6 @@ static int octeon_usb_remove(struct platform_device *pdev)
 	unsigned long flags;
 
 	usb_remove_hcd(hcd);
-	tasklet_kill(&priv->dequeue_tasklet);
 	spin_lock_irqsave(&priv->lock, flags);
 	status = cvmx_usb_shutdown(&priv->usb);
 	spin_unlock_irqrestore(&priv->lock, flags);

commit f8628a47ba502ec2ec795dc0134f052f45ce2cd4
Author: Joe Perches <joe@perches.com>
Date:   Fri May 23 22:13:20 2014 -0700

    staging: Convert __FUNCTION__ to __func__
    
    Use the normal mechanism for emitting a function name.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 27f1f276eba4..c4c731f60529 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1546,7 +1546,7 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 	switch (transaction->stage) {
 	case CVMX_USB_STAGE_NON_CONTROL:
 	case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
-		cvmx_dprintf("%s: ERROR - Non control stage\n", __FUNCTION__);
+		cvmx_dprintf("%s: ERROR - Non control stage\n", __func__);
 		break;
 	case CVMX_USB_STAGE_SETUP:
 		usbc_hctsiz.s.pid = 3; /* Setup */

commit e725cef3e55ad58f7f37917cc6f7b57b86a4b9bf
Author: Paul Davies C <pauldaviesc@gmail.com>
Date:   Sun May 11 18:41:33 2014 +0530

    staging: octeon-usb: Fix lines with more than 80 chars in octeon-hcd.c
    
    Some lines with more than 80 characters are converted in to multiple lines.
    
    Signed-off-by: Paul Davies C <pauldaviesc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index c1abf4d6d586..27f1f276eba4 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -460,7 +460,8 @@ struct octeon_hcd {
 	} while (0)
 
 /* Returns the IO address to push/pop stuff data from the FIFOs */
-#define USB_FIFO_ADDRESS(channel, usb_index) (CVMX_USBCX_GOTGCTL(usb_index) + ((channel)+1)*0x1000)
+#define USB_FIFO_ADDRESS(channel, usb_index) \
+	(CVMX_USBCX_GOTGCTL(usb_index) + ((channel)+1)*0x1000)
 
 /**
  * struct octeon_temp_buffer - a bounce buffer for USB transfers
@@ -1288,7 +1289,8 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 	if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
 		pipe->interval = interval*8;
 		/* Force start splits to be schedule on uFrame 0 */
-		pipe->next_tx_frame = ((usb->frame_number+7)&~7) + pipe->interval;
+		pipe->next_tx_frame = ((usb->frame_number+7)&~7) +
+					pipe->interval;
 	} else {
 		pipe->interval = interval;
 		pipe->next_tx_frame = usb->frame_number + pipe->interval;
@@ -1339,9 +1341,13 @@ static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
 		return;
 
 	/* Get where the DMA engine would have written this data */
-	address = __cvmx_usb_read_csr64(usb, CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel*8);
+	address = __cvmx_usb_read_csr64(usb,
+			CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel*8);
+
 	ptr = cvmx_phys_to_ptr(address);
-	__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel*8, address + bytes);
+	__cvmx_usb_write_csr64(usb,
+			       CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel*8,
+			       address + bytes);
 
 	/* Loop writing the FIFO data for this packet into memory */
 	while (bytes > 0) {
@@ -1546,19 +1552,27 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 		usbc_hctsiz.s.pid = 3; /* Setup */
 		bytes_to_transfer = sizeof(*header);
 		/* All Control operations start with a setup going OUT */
-		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, epdir, CVMX_USB_DIRECTION_OUT);
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				union cvmx_usbcx_hccharx, epdir,
+				CVMX_USB_DIRECTION_OUT);
 		/*
 		 * Setup send the control header instead of the buffer data. The
 		 * buffer data will be used in the next stage
 		 */
-		__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8, transaction->control_header);
+		__cvmx_usb_write_csr64(usb,
+			CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8,
+			transaction->control_header);
 		break;
 	case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
 		usbc_hctsiz.s.pid = 3; /* Setup */
 		bytes_to_transfer = 0;
 		/* All Control operations start with a setup going OUT */
-		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, epdir, CVMX_USB_DIRECTION_OUT);
-		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index), union cvmx_usbcx_hcspltx, compsplt, 1);
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				union cvmx_usbcx_hccharx, epdir,
+				CVMX_USB_DIRECTION_OUT);
+
+		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
+				union cvmx_usbcx_hcspltx, compsplt, 1);
 		break;
 	case CVMX_USB_STAGE_DATA:
 		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
@@ -1688,6 +1702,7 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		/* Clear all channel status bits */
 		usbc_hcint.u32 = __cvmx_usb_read_csr32(usb,
 				CVMX_USBCX_HCINTX(channel, usb->index));
+
 		__cvmx_usb_write_csr32(usb,
 				       CVMX_USBCX_HCINTX(channel, usb->index),
 				       usbc_hcint.u32);
@@ -1718,19 +1733,31 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), usbc_hcintmsk.u32);
 
 		/* Enable the channel interrupt to propagate */
-		usbc_haintmsk.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HAINTMSK(usb->index));
+		usbc_haintmsk.u32 = __cvmx_usb_read_csr32(usb,
+					CVMX_USBCX_HAINTMSK(usb->index));
 		usbc_haintmsk.s.haintmsk |= 1<<channel;
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HAINTMSK(usb->index), usbc_haintmsk.u32);
+		__cvmx_usb_write_csr32(usb,
+					CVMX_USBCX_HAINTMSK(usb->index),
+					usbc_haintmsk.u32);
 	}
 
 	/* Setup the locations the DMA engines use  */
 	{
-		uint64_t dma_address = transaction->buffer + transaction->actual_bytes;
+		uint64_t dma_address = transaction->buffer +
+					transaction->actual_bytes;
 
 		if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
-			dma_address = transaction->buffer + transaction->iso_packets[0].offset + transaction->actual_bytes;
-		__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8, dma_address);
-		__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel*8, dma_address);
+			dma_address = transaction->buffer +
+					transaction->iso_packets[0].offset +
+					transaction->actual_bytes;
+
+		__cvmx_usb_write_csr64(usb,
+			CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8,
+			dma_address);
+
+		__cvmx_usb_write_csr64(usb,
+			CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel*8,
+			dma_address);
 	}
 
 	/* Setup both the size of the transfer and the SPLIT characteristics */
@@ -2040,8 +2067,15 @@ static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 		 * Without DMA we need to be careful to not schedule something
 		 * at the end of a frame and cause an overrun.
 		 */
-		union cvmx_usbcx_hfnum hfnum = {.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index))};
-		union cvmx_usbcx_hfir hfir = {.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFIR(usb->index))};
+		union cvmx_usbcx_hfnum hfnum = {
+			.u32 = __cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_HFNUM(usb->index))
+		};
+
+		union cvmx_usbcx_hfir hfir = {
+			.u32 = __cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_HFIR(usb->index))
+		};
 
 		if (hfnum.s.frrem < hfir.s.frint/4)
 			goto done;
@@ -2660,7 +2694,9 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	}
 
 	/* Disable the channel interrupts now that it is done */
-	__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
+	__cvmx_usb_write_csr32(usb,
+				CVMX_USBCX_HCINTMSKX(channel, usb->index),
+				0);
 	usb->idle_hardware_channels |= (1<<channel);
 
 	/* Make sure this channel is tied to a valid pipe */
@@ -3026,7 +3062,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					 */
 					if (!buffer_space_left ||
 						(bytes_this_transfer < 188)) {
-						pipe->next_tx_frame += pipe->interval;
+						pipe->next_tx_frame +=
+							pipe->interval;
 						__cvmx_usb_perform_complete(
 							usb,
 							pipe,
@@ -3132,17 +3169,21 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 	prefetch_range(usb, sizeof(*usb));
 
 	/* Update the frame counter */
-	usbc_hfnum.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
+	usbc_hfnum.u32 = __cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_HFNUM(usb->index));
 	if ((usb->frame_number&0x3fff) > usbc_hfnum.s.frnum)
 		usb->frame_number += 0x4000;
 	usb->frame_number &= ~0x3fffull;
 	usb->frame_number |= usbc_hfnum.s.frnum;
 
 	/* Read the pending interrupts */
-	usbc_gintsts.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GINTSTS(usb->index));
+	usbc_gintsts.u32 = __cvmx_usb_read_csr32(usb,
+						CVMX_USBCX_GINTSTS(usb->index));
 
 	/* Clear the interrupts now that we know about them */
-	__cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index), usbc_gintsts.u32);
+	__cvmx_usb_write_csr32(usb,
+				CVMX_USBCX_GINTSTS(usb->index),
+				usbc_gintsts.u32);
 
 	if (usbc_gintsts.s.rxflvl) {
 		/*
@@ -3199,7 +3240,8 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 		 */
 		union cvmx_usbcx_haint usbc_haint;
 
-		usbc_haint.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HAINT(usb->index));
+		usbc_haint.u32 = __cvmx_usb_read_csr32(usb,
+					CVMX_USBCX_HAINT(usb->index));
 		while (usbc_haint.u32) {
 			int channel;
 
@@ -3492,7 +3534,8 @@ static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
 	return buf[0] != 0;
 }
 
-static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex, char *buf, u16 wLength)
+static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
+				u16 wIndex, char *buf, u16 wLength)
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	struct device *dev = hcd->self.controller;

commit f510643522471410ee8acf42d86d38d2bec4b268
Author: Paul Davies C <pauldaviesc@gmail.com>
Date:   Sun May 11 18:41:32 2014 +0530

    staging: octeon-usb: Add blank line after all declarations in octeon-hcd.c
    
    Add blank lines after each declarations in drivers/staging/octeon-usb/octeon-hcd.c.
    
    Signed-off-by: Paul Davies C <pauldaviesc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 98a493a73498..c1abf4d6d586 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -890,6 +890,7 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	 */
 	{
 		union cvmx_usbcx_gusbcfg usbcx_gusbcfg;
+
 		usbcx_gusbcfg.u32 = __cvmx_usb_read_csr32(usb,
 				CVMX_USBCX_GUSBCFG(usb->index));
 		usbcx_gusbcfg.s.toutcal = 0;
@@ -947,6 +948,7 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		 */
 		{
 			union cvmx_usbcx_hcfg usbcx_hcfg;
+
 			usbcx_hcfg.u32 = __cvmx_usb_read_csr32(usb,
 					CVMX_USBCX_HCFG(usb->index));
 			usbcx_hcfg.s.fslssupp = 0;
@@ -1074,6 +1076,7 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 	 */
 	{
 		union cvmx_usbcx_gnptxfsiz siz;
+
 		siz.u32 = __cvmx_usb_read_csr32(usb,
 				CVMX_USBCX_GNPTXFSIZ(usb->index));
 		siz.s.nptxfdep = usbcx_ghwcfg3.s.dfifodepth / 2;
@@ -1088,6 +1091,7 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 	 */
 	{
 		union cvmx_usbcx_hptxfsiz siz;
+
 		siz.u32 = __cvmx_usb_read_csr32(usb,
 				CVMX_USBCX_HPTXFSIZ(usb->index));
 		siz.s.ptxfsize = usbcx_ghwcfg3.s.dfifodepth / 4;
@@ -1217,8 +1221,8 @@ static struct cvmx_usb_port_status cvmx_usb_get_status(
  * Returns: A non-NULL value is a pipe. NULL means an error.
  */
 static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
-						int device_addr, int
-						endpoint_num,
+						int device_addr,
+						int endpoint_num,
 						enum cvmx_usb_speed
 							device_speed,
 						int max_packet,
@@ -1421,6 +1425,7 @@ static void __cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
 {
 	if (usb->periodic.head != usb->periodic.tail) {
 		union cvmx_usbcx_hptxsts tx_status;
+
 		tx_status.u32 = __cvmx_usb_read_csr32(usb,
 				CVMX_USBCX_HPTXSTS(usb->index));
 		if (__cvmx_usb_fill_tx_hw(usb, &usb->periodic,
@@ -1436,6 +1441,7 @@ static void __cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
 
 	if (usb->nonperiodic.head != usb->nonperiodic.tail) {
 		union cvmx_usbcx_gnptxsts tx_status;
+
 		tx_status.u32 = __cvmx_usb_read_csr32(usb,
 				CVMX_USBCX_GNPTXSTS(usb->index));
 		if (__cvmx_usb_fill_tx_hw(usb, &usb->nonperiodic,
@@ -1720,6 +1726,7 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 	/* Setup the locations the DMA engines use  */
 	{
 		uint64_t dma_address = transaction->buffer + transaction->actual_bytes;
+
 		if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
 			dma_address = transaction->buffer + transaction->iso_packets[0].offset + transaction->actual_bytes;
 		__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8, dma_address);
@@ -2035,6 +2042,7 @@ static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 		 */
 		union cvmx_usbcx_hfnum hfnum = {.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index))};
 		union cvmx_usbcx_hfir hfir = {.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFIR(usb->index))};
+
 		if (hfnum.s.frrem < hfir.s.frint/4)
 			goto done;
 	}
@@ -2519,6 +2527,7 @@ static int cvmx_usb_cancel_all(struct cvmx_usb_state *usb,
 	/* Simply loop through and attempt to cancel each transaction */
 	list_for_each_entry_safe(transaction, next, &pipe->transactions, node) {
 		int result = cvmx_usb_cancel(usb, pipe, transaction);
+
 		if (unlikely(result != 0))
 			return result;
 	}
@@ -3079,6 +3088,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				pipe->interval;
 	} else {
 		struct cvmx_usb_port_status port;
+
 		port = cvmx_usb_get_status(usb);
 		if (port.port_enabled) {
 			/* We'll retry the exact same transaction again */
@@ -3188,6 +3198,7 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 		 * to clear this bit.
 		 */
 		union cvmx_usbcx_haint usbc_haint;
+
 		usbc_haint.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HAINT(usb->index));
 		while (usbc_haint.u32) {
 			int channel;
@@ -3259,6 +3270,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		enum cvmx_usb_speed speed;
 		int split_device = 0;
 		int split_port = 0;
+
 		switch (usb_pipetype(urb->pipe)) {
 		case PIPE_ISOCHRONOUS:
 			transfer_type = CVMX_USB_TRANSFER_ISOCHRONOUS;
@@ -3295,6 +3307,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 			 * tree.
 			 */
 			struct usb_device *dev = urb->dev;
+
 			while (dev->parent) {
 				/*
 				 * If our parent is high speed then he'll
@@ -3454,6 +3467,7 @@ static void octeon_usb_endpoint_disable(struct usb_hcd *hcd,
 		struct octeon_hcd *priv = hcd_to_octeon(hcd);
 		struct cvmx_usb_pipe *pipe = ep->hcpriv;
 		unsigned long flags;
+
 		spin_lock_irqsave(&priv->lock, flags);
 		cvmx_usb_cancel_all(&priv->usb, pipe);
 		if (cvmx_usb_close_pipe(&priv->usb, pipe))
@@ -3770,6 +3784,7 @@ static int octeon_usb_probe(struct platform_device *pdev)
 	if (irq < 0) {
 		/* Defective device tree, but we know how to fix it. */
 		irq_hw_number_t hwirq = usb_num ? (1 << 6) + 17 : 56;
+
 		irq = irq_create_mapping(NULL, hwirq);
 	}
 

commit 20f6b82992a2500cfc93f41ab0a62105a1440b7d
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun May 11 14:15:20 2014 +0300

    staging: octeon-usb: use generic prefetch
    
    Use generic prefetch.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index b0c5f51f990e..98a493a73498 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -47,6 +47,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/prefetch.h>
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/usb.h>
@@ -245,9 +246,6 @@ enum cvmx_usb_pipe_flags {
 	__CVMX_USB_PIPE_FLAGS_NEED_PING	= 1 << 18,
 };
 
-/* Normal prefetch that use the pref instruction. */
-#define CVMX_PREFETCH(address, offset) asm volatile ("pref %[type], %[off](%[rbase])" : : [rbase] "d" (address), [off] "I" (offset), [type] "n" (0))
-
 /* Maximum number of times to retry failed transactions */
 #define MAX_RETRIES		3
 
@@ -2008,7 +2006,7 @@ static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(
 			 ((((int)current_frame - (int)pipe->split_sc_frame)
 			   & 0x7f) < 0x40)) &&
 			(!usb->active_split || (usb->active_split == t))) {
-			CVMX_PREFETCH(t, 0);
+			prefetch(t);
 			return pipe;
 		}
 	}
@@ -2658,13 +2656,13 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 
 	/* Make sure this channel is tied to a valid pipe */
 	pipe = usb->pipe_for_channel[channel];
-	CVMX_PREFETCH(pipe, 0);
+	prefetch(pipe);
 	if (!pipe)
 		return 0;
 	transaction = list_first_entry(&pipe->transactions,
 				       typeof(*transaction),
 				       node);
-	CVMX_PREFETCH(transaction, 0);
+	prefetch(transaction);
 
 	/*
 	 * Disconnect this pipe from the HW channel. Later the schedule
@@ -3121,11 +3119,7 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 	union cvmx_usbcx_hfnum usbc_hfnum;
 	union cvmx_usbcx_gintsts usbc_gintsts;
 
-	CVMX_PREFETCH(usb, 0);
-	CVMX_PREFETCH(usb, 1*128);
-	CVMX_PREFETCH(usb, 2*128);
-	CVMX_PREFETCH(usb, 3*128);
-	CVMX_PREFETCH(usb, 4*128);
+	prefetch_range(usb, sizeof(*usb));
 
 	/* Update the frame counter */
 	usbc_hfnum.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));

commit a4570140b3f80d0dfc71fdcad00b9768db0b8b04
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun May 11 14:15:19 2014 +0300

    staging: octeon-usb: delete redudant prefetches
    
    cvmx_usb_pipe fits into a cache-line so additional prefetches are not
    really helping anything.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 2d15001b3061..b0c5f51f990e 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2008,7 +2008,6 @@ static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(
 			 ((((int)current_frame - (int)pipe->split_sc_frame)
 			   & 0x7f) < 0x40)) &&
 			(!usb->active_split || (usb->active_split == t))) {
-			CVMX_PREFETCH(pipe, 128);
 			CVMX_PREFETCH(t, 0);
 			return pipe;
 		}
@@ -2660,7 +2659,6 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	/* Make sure this channel is tied to a valid pipe */
 	pipe = usb->pipe_for_channel[channel];
 	CVMX_PREFETCH(pipe, 0);
-	CVMX_PREFETCH(pipe, 128);
 	if (!pipe)
 		return 0;
 	transaction = list_first_entry(&pipe->transactions,

commit 8522851e3bc1b2198ec0e7eb48694ae326dc6840
Author: Paul McQuade <paulmcquad@gmail.com>
Date:   Tue Apr 8 16:32:48 2014 +0100

    Staging:Octeon-usb:octeon-hcd.c return value
    
    return value instead of function.
    
    Signed-off-by: Paul McQuade <paulmcquad@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 8b8ce7293c52..2d15001b3061 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3483,7 +3483,7 @@ static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
 	buf[0] = 0;
 	buf[0] = port_status.connect_change << 1;
 
-	return (buf[0] != 0);
+	return buf[0] != 0;
 }
 
 static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex, char *buf, u16 wLength)

commit 120ee599b5bf4273992ef9c6ac2a316cc3630969
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Mar 20 00:52:08 2014 +0200

    staging: octeon-usb: prevent memory corruption
    
    octeon-hcd will crash the kernel when SLOB is used. This usually happens
    after the 18-byte control transfer when a device descriptor is read.
    The DMA engine is always transfering full 32-bit words and if the
    transfer is shorter, some random garbage appears after the buffer.
    The problem is not visible with SLUB since it rounds up the allocations
    to word boundary, and the extra bytes will go undetected.
    
    Fix by providing quirk functions for DMA map/unmap that allocate a bigger
    temporary buffer when necessary. Tested by booting EdgeRouter Lite
    to USB stick root file system with SLAB, SLOB and SLUB kernels.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=72121
    Reported-by: Sergey Popov <pinkbyte@gentoo.org>
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 55380b349f95..8b8ce7293c52 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -464,6 +464,112 @@ struct octeon_hcd {
 /* Returns the IO address to push/pop stuff data from the FIFOs */
 #define USB_FIFO_ADDRESS(channel, usb_index) (CVMX_USBCX_GOTGCTL(usb_index) + ((channel)+1)*0x1000)
 
+/**
+ * struct octeon_temp_buffer - a bounce buffer for USB transfers
+ * @temp_buffer: the newly allocated temporary buffer (including meta-data)
+ * @orig_buffer: the original buffer passed by the USB stack
+ * @data:	 the newly allocated temporary buffer (excluding meta-data)
+ *
+ * Both the DMA engine and FIFO mode will always transfer full 32-bit words. If
+ * the buffer is too short, we need to allocate a temporary one, and this struct
+ * represents it.
+ */
+struct octeon_temp_buffer {
+	void *temp_buffer;
+	void *orig_buffer;
+	u8 data[0];
+};
+
+/**
+ * octeon_alloc_temp_buffer - allocate a temporary buffer for USB transfer
+ *                            (if needed)
+ * @urb:	URB.
+ * @mem_flags:	Memory allocation flags.
+ *
+ * This function allocates a temporary bounce buffer whenever it's needed
+ * due to HW limitations.
+ */
+static int octeon_alloc_temp_buffer(struct urb *urb, gfp_t mem_flags)
+{
+	struct octeon_temp_buffer *temp;
+
+	if (urb->num_sgs || urb->sg ||
+	    (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP) ||
+	    !(urb->transfer_buffer_length % sizeof(u32)))
+		return 0;
+
+	temp = kmalloc(ALIGN(urb->transfer_buffer_length, sizeof(u32)) +
+		       sizeof(*temp), mem_flags);
+	if (!temp)
+		return -ENOMEM;
+
+	temp->temp_buffer = temp;
+	temp->orig_buffer = urb->transfer_buffer;
+	if (usb_urb_dir_out(urb))
+		memcpy(temp->data, urb->transfer_buffer,
+		       urb->transfer_buffer_length);
+	urb->transfer_buffer = temp->data;
+	urb->transfer_flags |= URB_ALIGNED_TEMP_BUFFER;
+
+	return 0;
+}
+
+/**
+ * octeon_free_temp_buffer - free a temporary buffer used by USB transfers.
+ * @urb: URB.
+ *
+ * Frees a buffer allocated by octeon_alloc_temp_buffer().
+ */
+static void octeon_free_temp_buffer(struct urb *urb)
+{
+	struct octeon_temp_buffer *temp;
+
+	if (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))
+		return;
+
+	temp = container_of(urb->transfer_buffer, struct octeon_temp_buffer,
+			    data);
+	if (usb_urb_dir_in(urb))
+		memcpy(temp->orig_buffer, urb->transfer_buffer,
+		       urb->actual_length);
+	urb->transfer_buffer = temp->orig_buffer;
+	urb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;
+	kfree(temp->temp_buffer);
+}
+
+/**
+ * octeon_map_urb_for_dma - Octeon-specific map_urb_for_dma().
+ * @hcd:	USB HCD structure.
+ * @urb:	URB.
+ * @mem_flags:	Memory allocation flags.
+ */
+static int octeon_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
+				  gfp_t mem_flags)
+{
+	int ret;
+
+	ret = octeon_alloc_temp_buffer(urb, mem_flags);
+	if (ret)
+		return ret;
+
+	ret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);
+	if (ret)
+		octeon_free_temp_buffer(urb);
+
+	return ret;
+}
+
+/**
+ * octeon_unmap_urb_for_dma - Octeon-specific unmap_urb_for_dma()
+ * @hcd:	USB HCD structure.
+ * @urb:	URB.
+ */
+static void octeon_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
+{
+	usb_hcd_unmap_urb_for_dma(hcd, urb);
+	octeon_free_temp_buffer(urb);
+}
+
 /**
  * Read a USB 32bit CSR. It performs the necessary address swizzle
  * for 32bit CSRs and logs the value in a readable format if
@@ -3601,6 +3707,8 @@ static const struct hc_driver octeon_hc_driver = {
 	.get_frame_number	= octeon_usb_get_frame_number,
 	.hub_status_data	= octeon_usb_hub_status_data,
 	.hub_control		= octeon_usb_hub_control,
+	.map_urb_for_dma	= octeon_map_urb_for_dma,
+	.unmap_urb_for_dma	= octeon_unmap_urb_for_dma,
 };
 
 static int octeon_usb_probe(struct platform_device *pdev)

commit b49f11335d82bd7bca488644cfc846df935abd54
Author: Raluca Oncioiu <raluca.oncioiu91@gmail.com>
Date:   Sat Mar 8 00:44:12 2014 +0200

    Staging: octeon-usb: Remove unnecessary brackets
    
    Remove brackets from single line branches of if statements.
    Break long lines.
    
    Signed-off-by: Raluca Oncioiu <raluca.oncioiu91@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index ee38e08c07d0..55380b349f95 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -925,12 +925,12 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 		return 0;
 
 	/* If there is nothing plugged into the port then fail immediately */
-	if (!usb->usbcx_hprt.s.prtconnsts) {
+	if (!usb->usbcx_hprt.s.prtconnsts)
 		return -ETIMEDOUT;
-	}
 
 	/* Program the port reset bit to start the reset process */
-	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtrst, 1);
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt,
+			prtrst, 1);
 
 	/*
 	 * Wait at least 50ms (high speed), or 10ms (full speed) for the reset

commit 1da69aa92b165bb06b6cd26d11d044c66bfa1c30
Author: Raluca Oncioiu <raluca.oncioiu91@gmail.com>
Date:   Sat Mar 8 00:32:05 2014 +0200

    Staging: octeon-usb: Break up long lines
    
    Break up long lines.
    
    Signed-off-by: Raluca Oncioiu <raluca.oncioiu91@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 5a001d9b4252..ee38e08c07d0 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -605,7 +605,8 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	 * 2a. Write USBN0/1_CLK_CTL[POR] = 1 and
 	 *     USBN0/1_CLK_CTL[HRST,PRST,HCLK_RST] = 0
 	 */
-	usbn_clk_ctl.u64 = __cvmx_usb_read_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index));
+	usbn_clk_ctl.u64 =
+		__cvmx_usb_read_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index));
 	usbn_clk_ctl.s.por = 1;
 	usbn_clk_ctl.s.hrst = 0;
 	usbn_clk_ctl.s.prst = 0;
@@ -691,7 +692,8 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	 *    USBP control and status register:
 	 *    USBN_USBP_CTL_STATUS[ATE_RESET] = 1
 	 */
-	usbn_usbp_ctl_status.u64 = __cvmx_usb_read_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index));
+	usbn_usbp_ctl_status.u64 = __cvmx_usb_read_csr64(usb,
+			CVMX_USBNX_USBP_CTL_STATUS(usb->index));
 	usbn_usbp_ctl_status.s.ate_reset = 1;
 	__cvmx_usb_write_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index),
 			       usbn_usbp_ctl_status.u64);
@@ -758,7 +760,8 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		if (OCTEON_IS_MODEL(OCTEON_CN31XX))
 			usb->init_flags |= CVMX_USB_INITIALIZE_FLAGS_NO_DMA;
 		usbcx_gahbcfg.u32 = 0;
-		usbcx_gahbcfg.s.dmaen = !(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA);
+		usbcx_gahbcfg.s.dmaen = !(usb->init_flags &
+					  CVMX_USB_INITIALIZE_FLAGS_NO_DMA);
 		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
 			/* Only use one channel with non DMA */
 			usb->idle_hardware_channels = 0x1;
@@ -783,7 +786,8 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	 */
 	{
 		union cvmx_usbcx_gusbcfg usbcx_gusbcfg;
-		usbcx_gusbcfg.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index));
+		usbcx_gusbcfg.u32 = __cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_GUSBCFG(usb->index));
 		usbcx_gusbcfg.s.toutcal = 0;
 		usbcx_gusbcfg.s.ddrsel = 0;
 		usbcx_gusbcfg.s.usbtrdtim = 0x5;
@@ -801,7 +805,8 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		union cvmx_usbcx_gintmsk usbcx_gintmsk;
 		int channel;
 
-		usbcx_gintmsk.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GINTMSK(usb->index));
+		usbcx_gintmsk.u32 = __cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_GINTMSK(usb->index));
 		usbcx_gintmsk.s.otgintmsk = 1;
 		usbcx_gintmsk.s.modemismsk = 1;
 		usbcx_gintmsk.s.hchintmsk = 1;
@@ -817,7 +822,8 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		 * later.
 		 */
 		for (channel = 0; channel < 8; channel++)
-			__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
+			__cvmx_usb_write_csr32(usb,
+				CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
 	}
 
 	{
@@ -827,26 +833,30 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		 * 1. Program the host-port interrupt-mask field to unmask,
 		 *    USBC_GINTMSK[PRTINT] = 1
 		 */
-		USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk,
-				prtintmsk, 1);
-		USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk,
-				disconnintmsk, 1);
+		USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+				union cvmx_usbcx_gintmsk, prtintmsk, 1);
+		USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+				union cvmx_usbcx_gintmsk, disconnintmsk, 1);
 		/*
 		 * 2. Program the USBC_HCFG register to select full-speed host
 		 *    or high-speed host.
 		 */
 		{
 			union cvmx_usbcx_hcfg usbcx_hcfg;
-			usbcx_hcfg.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCFG(usb->index));
+			usbcx_hcfg.u32 = __cvmx_usb_read_csr32(usb,
+					CVMX_USBCX_HCFG(usb->index));
 			usbcx_hcfg.s.fslssupp = 0;
 			usbcx_hcfg.s.fslspclksel = 0;
-			__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCFG(usb->index), usbcx_hcfg.u32);
+			__cvmx_usb_write_csr32(usb,
+					CVMX_USBCX_HCFG(usb->index),
+					usbcx_hcfg.u32);
 		}
 		/*
 		 * 3. Program the port power bit to drive VBUS on the USB,
 		 *    USBC_HPRT[PRTPWR] = 1
 		 */
-		USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtpwr, 1);
+		USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index),
+				union cvmx_usbcx_hprt, prtpwr, 1);
 
 		/*
 		 * Steps 4-15 from the manual are done later in the port enable
@@ -879,7 +889,8 @@ static int cvmx_usb_shutdown(struct cvmx_usb_state *usb)
 		return -EBUSY;
 
 	/* Disable the clocks and put them in power on reset */
-	usbn_clk_ctl.u64 = __cvmx_usb_read_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index));
+	usbn_clk_ctl.u64 = __cvmx_usb_read_csr64(usb,
+			CVMX_USBNX_CLK_CTL(usb->index));
 	usbn_clk_ctl.s.enable = 1;
 	usbn_clk_ctl.s.por = 1;
 	usbn_clk_ctl.s.hclk_rst = 1;
@@ -903,7 +914,8 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 {
 	union cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;
 
-	usb->usbcx_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+	usb->usbcx_hprt.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HPRT(usb->index));
 
 	/*
 	 * If the port is already enabled the just return. We don't need to do
@@ -927,26 +939,30 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 	mdelay(50);
 
 	/* Program the port reset bit to 0, USBC_HPRT[PRTRST] = 0 */
-	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtrst, 0);
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt,
+			prtrst, 0);
 
 	/* Wait for the USBC_HPRT[PRTENA]. */
-	if (CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt,
-				  prtena, ==, 1, 100000))
+	if (CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_HPRT(usb->index),
+				union cvmx_usbcx_hprt, prtena, ==, 1, 100000))
 		return -ETIMEDOUT;
 
 	/*
 	 * Read the port speed field to get the enumerated speed,
 	 * USBC_HPRT[PRTSPD].
 	 */
-	usb->usbcx_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
-	usbcx_ghwcfg3.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GHWCFG3(usb->index));
+	usb->usbcx_hprt.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HPRT(usb->index));
+	usbcx_ghwcfg3.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_GHWCFG3(usb->index));
 
 	/*
 	 * 13. Program the USBC_GRXFSIZ register to select the size of the
 	 *     receive FIFO (25%).
 	 */
-	USB_SET_FIELD32(CVMX_USBCX_GRXFSIZ(usb->index), union cvmx_usbcx_grxfsiz,
-			rxfdep, usbcx_ghwcfg3.s.dfifodepth / 4);
+	USB_SET_FIELD32(CVMX_USBCX_GRXFSIZ(usb->index),
+			union cvmx_usbcx_grxfsiz, rxfdep,
+			usbcx_ghwcfg3.s.dfifodepth / 4);
 	/*
 	 * 14. Program the USBC_GNPTXFSIZ register to select the size and the
 	 *     start address of the non- periodic transmit FIFO for nonperiodic
@@ -954,10 +970,12 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 	 */
 	{
 		union cvmx_usbcx_gnptxfsiz siz;
-		siz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index));
+		siz.u32 = __cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_GNPTXFSIZ(usb->index));
 		siz.s.nptxfdep = usbcx_ghwcfg3.s.dfifodepth / 2;
 		siz.s.nptxfstaddr = usbcx_ghwcfg3.s.dfifodepth / 4;
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index), siz.u32);
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index),
+				       siz.u32);
 	}
 	/*
 	 * 15. Program the USBC_HPTXFSIZ register to select the size and start
@@ -966,18 +984,25 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 	 */
 	{
 		union cvmx_usbcx_hptxfsiz siz;
-		siz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index));
+		siz.u32 = __cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HPTXFSIZ(usb->index));
 		siz.s.ptxfsize = usbcx_ghwcfg3.s.dfifodepth / 4;
 		siz.s.ptxfstaddr = 3 * usbcx_ghwcfg3.s.dfifodepth / 4;
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index), siz.u32);
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index),
+				       siz.u32);
 	}
 	/* Flush all FIFOs */
-	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl, txfnum, 0x10);
-	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl, txfflsh, 1);
-	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl,
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			union cvmx_usbcx_grstctl, txfnum, 0x10);
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			union cvmx_usbcx_grstctl, txfflsh, 1);
+	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			      union cvmx_usbcx_grstctl,
 			      txfflsh, ==, 0, 100);
-	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl, rxfflsh, 1);
-	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl,
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			union cvmx_usbcx_grstctl, rxfflsh, 1);
+	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),
+			      union cvmx_usbcx_grstctl,
 			      rxfflsh, ==, 0, 100);
 
 	return 0;
@@ -997,7 +1022,8 @@ static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 static int cvmx_usb_disable(struct cvmx_usb_state *usb)
 {
 	/* Disable the port */
-	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtena, 1);
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt,
+			prtena, 1);
 	return 0;
 }
 
@@ -1013,20 +1039,23 @@ static int cvmx_usb_disable(struct cvmx_usb_state *usb)
  *
  * Returns: Port status information
  */
-static struct cvmx_usb_port_status cvmx_usb_get_status(struct cvmx_usb_state *usb)
+static struct cvmx_usb_port_status cvmx_usb_get_status(
+		struct cvmx_usb_state *usb)
 {
 	union cvmx_usbcx_hprt usbc_hprt;
 	struct cvmx_usb_port_status result;
 
 	memset(&result, 0, sizeof(result));
 
-	usbc_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+	usbc_hprt.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HPRT(usb->index));
 	result.port_enabled = usbc_hprt.s.prtena;
 	result.port_over_current = usbc_hprt.s.prtovrcurract;
 	result.port_powered = usbc_hprt.s.prtpwr;
 	result.port_speed = usbc_hprt.s.prtspd;
 	result.connected = usbc_hprt.s.prtconnsts;
-	result.connect_change = (result.connected != usb->port_status.connected);
+	result.connect_change =
+		(result.connected != usb->port_status.connected);
 
 	return result;
 }
@@ -1121,7 +1150,8 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 	if (unlikely((device_speed != CVMX_USB_SPEED_HIGH) &&
 		(multi_count != 0)))
 		return NULL;
-	if (unlikely((hub_device_addr < 0) || (hub_device_addr > MAX_USB_ADDRESS)))
+	if (unlikely((hub_device_addr < 0) ||
+		(hub_device_addr > MAX_USB_ADDRESS)))
 		return NULL;
 	if (unlikely((hub_port < 0) || (hub_port > MAX_USB_HUB_PORT)))
 		return NULL;
@@ -1186,7 +1216,8 @@ static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
 	uint64_t address;
 	uint32_t *ptr;
 
-	rx_status.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GRXSTSPH(usb->index));
+	rx_status.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_GRXSTSPH(usb->index));
 	/* Only read data if IN data is there */
 	if (rx_status.s.pktsts != 2)
 		return;
@@ -1236,7 +1267,8 @@ static int __cvmx_usb_fill_tx_hw(struct cvmx_usb_state *usb,
 	while (available && (fifo->head != fifo->tail)) {
 		int i = fifo->tail;
 		const uint32_t *ptr = cvmx_phys_to_ptr(fifo->entry[i].address);
-		uint64_t csr_address = USB_FIFO_ADDRESS(fifo->entry[i].channel, usb->index) ^ 4;
+		uint64_t csr_address = USB_FIFO_ADDRESS(fifo->entry[i].channel,
+							usb->index) ^ 4;
 		int words = available;
 
 		/* Limit the amount of data to waht the SW fifo has */
@@ -1260,7 +1292,8 @@ static int __cvmx_usb_fill_tx_hw(struct cvmx_usb_state *usb,
 			cvmx_write64_uint32(csr_address, *ptr++);
 			cvmx_write64_uint32(csr_address, *ptr++);
 			cvmx_write64_uint32(csr_address, *ptr++);
-			cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
+			cvmx_read64_uint64(
+					CVMX_USBNX_DMA0_INB_CHN0(usb->index));
 			words -= 3;
 		}
 		cvmx_write64_uint32(csr_address, *ptr++);
@@ -1284,20 +1317,32 @@ static void __cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
 {
 	if (usb->periodic.head != usb->periodic.tail) {
 		union cvmx_usbcx_hptxsts tx_status;
-		tx_status.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPTXSTS(usb->index));
-		if (__cvmx_usb_fill_tx_hw(usb, &usb->periodic, tx_status.s.ptxfspcavail))
-			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, ptxfempmsk, 1);
+		tx_status.u32 = __cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HPTXSTS(usb->index));
+		if (__cvmx_usb_fill_tx_hw(usb, &usb->periodic,
+					  tx_status.s.ptxfspcavail))
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+					union cvmx_usbcx_gintmsk,
+					ptxfempmsk, 1);
 		else
-			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, ptxfempmsk, 0);
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+					union cvmx_usbcx_gintmsk,
+					ptxfempmsk, 0);
 	}
 
 	if (usb->nonperiodic.head != usb->nonperiodic.tail) {
 		union cvmx_usbcx_gnptxsts tx_status;
-		tx_status.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GNPTXSTS(usb->index));
-		if (__cvmx_usb_fill_tx_hw(usb, &usb->nonperiodic, tx_status.s.nptxfspcavail))
-			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, nptxfempmsk, 1);
+		tx_status.u32 = __cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_GNPTXSTS(usb->index));
+		if (__cvmx_usb_fill_tx_hw(usb, &usb->nonperiodic,
+					  tx_status.s.nptxfspcavail))
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+					union cvmx_usbcx_gintmsk,
+					nptxfempmsk, 1);
 		else
-			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, nptxfempmsk, 0);
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+					union cvmx_usbcx_gintmsk,
+					nptxfempmsk, 0);
 	}
 
 	return;
@@ -1318,12 +1363,14 @@ static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
 	struct cvmx_usb_tx_fifo *fifo;
 
 	/* We only need to fill data on outbound channels */
-	hcchar.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index));
+	hcchar.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HCCHARX(channel, usb->index));
 	if (hcchar.s.epdir != CVMX_USB_DIRECTION_OUT)
 		return;
 
 	/* OUT Splits only have data on the start and not the complete */
-	usbc_hcsplt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCSPLTX(channel, usb->index));
+	usbc_hcsplt.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HCSPLTX(channel, usb->index));
 	if (usbc_hcsplt.s.spltena && usbc_hcsplt.s.compsplt)
 		return;
 
@@ -1331,7 +1378,8 @@ static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
 	 * Find out how many bytes we need to fill and convert it into 32bit
 	 * words.
 	 */
-	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index));
+	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HCTSIZX(channel, usb->index));
 	if (!usbc_hctsiz.s.xfersize)
 		return;
 
@@ -1371,11 +1419,13 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 				 node);
 	union cvmx_usb_control_header *header =
 		cvmx_phys_to_ptr(transaction->control_header);
-	int bytes_to_transfer = transaction->buffer_length - transaction->actual_bytes;
+	int bytes_to_transfer = transaction->buffer_length -
+		transaction->actual_bytes;
 	int packets_to_transfer;
 	union cvmx_usbcx_hctsizx usbc_hctsiz;
 
-	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index));
+	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HCTSIZX(channel, usb->index));
 
 	switch (transaction->stage) {
 	case CVMX_USB_STAGE_NON_CONTROL:
@@ -1423,12 +1473,14 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 				((header->s.request_type & 0x80) ?
 					CVMX_USB_DIRECTION_IN :
 					CVMX_USB_DIRECTION_OUT));
-		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index), union cvmx_usbcx_hcspltx, compsplt, 1);
+		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
+				union cvmx_usbcx_hcspltx, compsplt, 1);
 		break;
 	case CVMX_USB_STAGE_STATUS:
 		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
 		bytes_to_transfer = 0;
-		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, epdir,
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				union cvmx_usbcx_hccharx, epdir,
 				((header->s.request_type & 0x80) ?
 					CVMX_USB_DIRECTION_OUT :
 					CVMX_USB_DIRECTION_IN));
@@ -1436,11 +1488,13 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 	case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
 		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
 		bytes_to_transfer = 0;
-		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, epdir,
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				union cvmx_usbcx_hccharx, epdir,
 				((header->s.request_type & 0x80) ?
 					CVMX_USB_DIRECTION_OUT :
 					CVMX_USB_DIRECTION_IN));
-		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index), union cvmx_usbcx_hcspltx, compsplt, 1);
+		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),
+				union cvmx_usbcx_hcspltx, compsplt, 1);
 		break;
 	}
 
@@ -1458,10 +1512,12 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 	 * Calculate the number of packets to transfer. If the length is zero
 	 * we still need to transfer one packet
 	 */
-	packets_to_transfer = (bytes_to_transfer + pipe->max_packet - 1) / pipe->max_packet;
+	packets_to_transfer = (bytes_to_transfer + pipe->max_packet - 1) /
+		pipe->max_packet;
 	if (packets_to_transfer == 0)
 		packets_to_transfer = 1;
-	else if ((packets_to_transfer > 1) && (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
+	else if ((packets_to_transfer > 1) &&
+			(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
 		/*
 		 * Limit to one packet when not using DMA. Channels must be
 		 * restarted between every packet for IN transactions, so there
@@ -1481,7 +1537,8 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 	usbc_hctsiz.s.xfersize = bytes_to_transfer;
 	usbc_hctsiz.s.pktcnt = packets_to_transfer;
 
-	__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index), usbc_hctsiz.u32);
+	__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index),
+			       usbc_hctsiz.u32);
 	return;
 }
 
@@ -1519,8 +1576,11 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		union cvmx_usbcx_haintmsk usbc_haintmsk;
 
 		/* Clear all channel status bits */
-		usbc_hcint.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCINTX(channel, usb->index));
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTX(channel, usb->index), usbc_hcint.u32);
+		usbc_hcint.u32 = __cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCINTX(channel, usb->index));
+		__cvmx_usb_write_csr32(usb,
+				       CVMX_USBCX_HCINTX(channel, usb->index),
+				       usbc_hcint.u32);
 
 		usbc_hcintmsk.u32 = 0;
 		usbc_hcintmsk.s.chhltdmsk = 1;
@@ -1567,14 +1627,17 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		union cvmx_usbcx_hcspltx usbc_hcsplt = {.u32 = 0};
 		union cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 = 0};
 		int packets_to_transfer;
-		int bytes_to_transfer = transaction->buffer_length - transaction->actual_bytes;
+		int bytes_to_transfer = transaction->buffer_length -
+			transaction->actual_bytes;
 
 		/*
 		 * ISOCHRONOUS transactions store each individual transfer size
 		 * in the packet structure, not the global buffer_length
 		 */
 		if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
-			bytes_to_transfer = transaction->iso_packets[0].length - transaction->actual_bytes;
+			bytes_to_transfer =
+				transaction->iso_packets[0].length -
+				transaction->actual_bytes;
 
 		/*
 		 * We need to do split transactions when we are talking to non
@@ -1589,16 +1652,19 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 			 */
 			if ((transaction->stage&1) == 0) {
 				if (transaction->type == CVMX_USB_TRANSFER_BULK)
-					pipe->split_sc_frame = (usb->frame_number + 1) & 0x7f;
+					pipe->split_sc_frame =
+						(usb->frame_number + 1) & 0x7f;
 				else
-					pipe->split_sc_frame = (usb->frame_number + 2) & 0x7f;
+					pipe->split_sc_frame =
+						(usb->frame_number + 2) & 0x7f;
 			} else
 				pipe->split_sc_frame = -1;
 
 			usbc_hcsplt.s.spltena = 1;
 			usbc_hcsplt.s.hubaddr = pipe->hub_device_addr;
 			usbc_hcsplt.s.prtaddr = pipe->hub_port;
-			usbc_hcsplt.s.compsplt = (transaction->stage == CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE);
+			usbc_hcsplt.s.compsplt = (transaction->stage ==
+				CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE);
 
 			/*
 			 * SPLIT transactions can only ever transmit one data
@@ -1614,8 +1680,10 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 			 * begin/middle/end of the data or all
 			 */
 			if (!usbc_hcsplt.s.compsplt &&
-				(pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) &&
-				(pipe->transfer_type == CVMX_USB_TRANSFER_ISOCHRONOUS)) {
+				(pipe->transfer_dir ==
+				 CVMX_USB_DIRECTION_OUT) &&
+				(pipe->transfer_type ==
+				 CVMX_USB_TRANSFER_ISOCHRONOUS)) {
 				/*
 				 * Clear the split complete frame number as
 				 * there isn't going to be a split complete
@@ -1667,7 +1735,8 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 			 * Round MAX_TRANSFER_BYTES to a multiple of out packet
 			 * size
 			 */
-			bytes_to_transfer = MAX_TRANSFER_BYTES / pipe->max_packet;
+			bytes_to_transfer = MAX_TRANSFER_BYTES /
+				pipe->max_packet;
 			bytes_to_transfer *= pipe->max_packet;
 		}
 
@@ -1675,10 +1744,14 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		 * Calculate the number of packets to transfer. If the length is
 		 * zero we still need to transfer one packet
 		 */
-		packets_to_transfer = (bytes_to_transfer + pipe->max_packet - 1) / pipe->max_packet;
+		packets_to_transfer =
+			(bytes_to_transfer + pipe->max_packet - 1) /
+			pipe->max_packet;
 		if (packets_to_transfer == 0)
 			packets_to_transfer = 1;
-		else if ((packets_to_transfer > 1) && (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
+		else if ((packets_to_transfer > 1) &&
+				(usb->init_flags &
+				 CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
 			/*
 			 * Limit to one packet when not using DMA. Channels must
 			 * be restarted between every packet for IN
@@ -1686,14 +1759,16 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 			 * packets in a row
 			 */
 			packets_to_transfer = 1;
-			bytes_to_transfer = packets_to_transfer * pipe->max_packet;
+			bytes_to_transfer = packets_to_transfer *
+				pipe->max_packet;
 		} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {
 			/*
 			 * Limit the number of packet and data transferred to
 			 * what the hardware can handle
 			 */
 			packets_to_transfer = MAX_TRANSFER_PACKETS;
-			bytes_to_transfer = packets_to_transfer * pipe->max_packet;
+			bytes_to_transfer = packets_to_transfer *
+				pipe->max_packet;
 		}
 
 		usbc_hctsiz.s.xfersize = bytes_to_transfer;
@@ -1707,8 +1782,11 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		if (pipe->flags & __CVMX_USB_PIPE_FLAGS_NEED_PING)
 			usbc_hctsiz.s.dopng = 1;
 
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCSPLTX(channel, usb->index), usbc_hcsplt.u32);
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index), usbc_hctsiz.u32);
+		__cvmx_usb_write_csr32(usb,
+				       CVMX_USBCX_HCSPLTX(channel, usb->index),
+				       usbc_hcsplt.u32);
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel,
+					usb->index), usbc_hctsiz.u32);
 	}
 
 	/* Setup the Host Channel Characteristics Register */
@@ -1739,11 +1817,14 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 		/* Set the rest of the endpoint specific settings */
 		usbc_hcchar.s.devaddr = pipe->device_addr;
 		usbc_hcchar.s.eptype = transaction->type;
-		usbc_hcchar.s.lspddev = (pipe->device_speed == CVMX_USB_SPEED_LOW);
+		usbc_hcchar.s.lspddev =
+			(pipe->device_speed == CVMX_USB_SPEED_LOW);
 		usbc_hcchar.s.epdir = pipe->transfer_dir;
 		usbc_hcchar.s.epnum = pipe->endpoint_num;
 		usbc_hcchar.s.mps = pipe->max_packet;
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index), usbc_hcchar.u32);
+		__cvmx_usb_write_csr32(usb,
+				       CVMX_USBCX_HCCHARX(channel, usb->index),
+				       usbc_hcchar.u32);
 	}
 
 	/* Do transaction type specific fixups as needed */
@@ -1762,22 +1843,33 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 			 */
 			if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {
 				if (pipe->multi_count < 2) /* Need DATA0 */
-					USB_SET_FIELD32(CVMX_USBCX_HCTSIZX(channel, usb->index), union cvmx_usbcx_hctsizx, pid, 0);
+					USB_SET_FIELD32(
+						CVMX_USBCX_HCTSIZX(channel,
+								   usb->index),
+						union cvmx_usbcx_hctsizx,
+						pid, 0);
 				else /* Need MDATA */
-					USB_SET_FIELD32(CVMX_USBCX_HCTSIZX(channel, usb->index), union cvmx_usbcx_hctsizx, pid, 3);
+					USB_SET_FIELD32(
+						CVMX_USBCX_HCTSIZX(channel,
+								   usb->index),
+						union cvmx_usbcx_hctsizx,
+						pid, 3);
 			}
 		}
 		break;
 	}
 	{
-		union cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index))};
+		union cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 =
+			__cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCTSIZX(channel, usb->index))};
 		transaction->xfersize = usbc_hctsiz.s.xfersize;
 		transaction->pktcnt = usbc_hctsiz.s.pktcnt;
 	}
 	/* Remeber when we start a split transaction */
 	if (__cvmx_usb_pipe_needs_split(usb, pipe))
 		usb->active_split = transaction;
-	USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, chena, 1);
+	USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+			union cvmx_usbcx_hccharx, chena, 1);
 	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
 		__cvmx_usb_fill_tx_fifo(usb, channel);
 	return;
@@ -1793,16 +1885,22 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
  *
  * Returns: Pipe or NULL if none are ready
  */
-static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(struct cvmx_usb_state *usb, struct list_head *list, uint64_t current_frame)
+static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(
+		struct cvmx_usb_state *usb,
+		struct list_head *list,
+		uint64_t current_frame)
 {
 	struct cvmx_usb_pipe *pipe;
 
 	list_for_each_entry(pipe, list, node) {
 		struct cvmx_usb_transaction *t =
-			list_first_entry(&pipe->transactions, typeof(*t), node);
+			list_first_entry(&pipe->transactions, typeof(*t),
+					 node);
 		if (!(pipe->flags & __CVMX_USB_PIPE_FLAGS_SCHEDULED) && t &&
 			(pipe->next_tx_frame <= current_frame) &&
-			((pipe->split_sc_frame == -1) || ((((int)current_frame - (int)pipe->split_sc_frame) & 0x7f) < 0x40)) &&
+			((pipe->split_sc_frame == -1) ||
+			 ((((int)current_frame - (int)pipe->split_sc_frame)
+			   & 0x7f) < 0x40)) &&
 			(!usb->active_split || (usb->active_split == t))) {
 			CVMX_PREFETCH(pipe, 128);
 			CVMX_PREFETCH(t, 0);
@@ -1852,14 +1950,26 @@ static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 			 * way we are sure that the periodic data is sent in the
 			 * beginning of the frame
 			 */
-			pipe = __cvmx_usb_find_ready_pipe(usb, usb->active_pipes + CVMX_USB_TRANSFER_ISOCHRONOUS, usb->frame_number);
+			pipe = __cvmx_usb_find_ready_pipe(usb,
+					usb->active_pipes +
+					CVMX_USB_TRANSFER_ISOCHRONOUS,
+					usb->frame_number);
 			if (likely(!pipe))
-				pipe = __cvmx_usb_find_ready_pipe(usb, usb->active_pipes + CVMX_USB_TRANSFER_INTERRUPT, usb->frame_number);
+				pipe = __cvmx_usb_find_ready_pipe(usb,
+						usb->active_pipes +
+						CVMX_USB_TRANSFER_INTERRUPT,
+						usb->frame_number);
 		}
 		if (likely(!pipe)) {
-			pipe = __cvmx_usb_find_ready_pipe(usb, usb->active_pipes + CVMX_USB_TRANSFER_CONTROL, usb->frame_number);
+			pipe = __cvmx_usb_find_ready_pipe(usb,
+					usb->active_pipes +
+					CVMX_USB_TRANSFER_CONTROL,
+					usb->frame_number);
 			if (likely(!pipe))
-				pipe = __cvmx_usb_find_ready_pipe(usb, usb->active_pipes + CVMX_USB_TRANSFER_BULK, usb->frame_number);
+				pipe = __cvmx_usb_find_ready_pipe(usb,
+						usb->active_pipes +
+						CVMX_USB_TRANSFER_BULK,
+						usb->frame_number);
 		}
 		if (!pipe)
 			break;
@@ -1873,7 +1983,8 @@ static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 	 * future that might need to be scheduled
 	 */
 	need_sof = 0;
-	for (ttype = CVMX_USB_TRANSFER_CONTROL; ttype <= CVMX_USB_TRANSFER_INTERRUPT; ttype++) {
+	for (ttype = CVMX_USB_TRANSFER_CONTROL;
+			ttype <= CVMX_USB_TRANSFER_INTERRUPT; ttype++) {
 		list_for_each_entry(pipe, &usb->active_pipes[ttype], node) {
 			if (pipe->next_tx_frame > usb->frame_number) {
 				need_sof = 1;
@@ -1881,7 +1992,8 @@ static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 			}
 		}
 	}
-	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, sofmsk, need_sof);
+	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),
+			union cvmx_usbcx_gintmsk, sofmsk, need_sof);
 	return;
 }
 
@@ -1932,10 +2044,13 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 		/* Recalculate the transfer size by adding up each packet */
 		urb->actual_length = 0;
 		for (i = 0; i < urb->number_of_packets; i++) {
-			if (iso_packet[i].status == CVMX_USB_COMPLETE_SUCCESS) {
+			if (iso_packet[i].status ==
+					CVMX_USB_COMPLETE_SUCCESS) {
 				urb->iso_frame_desc[i].status = 0;
-				urb->iso_frame_desc[i].actual_length = iso_packet[i].length;
-				urb->actual_length += urb->iso_frame_desc[i].actual_length;
+				urb->iso_frame_desc[i].actual_length =
+					iso_packet[i].length;
+				urb->actual_length +=
+					urb->iso_frame_desc[i].actual_length;
 			} else {
 				dev_dbg(dev, "ISOCHRONOUS packet=%d of %d status=%d pipe=%p transaction=%p size=%d\n",
 					i, urb->number_of_packets,
@@ -1997,10 +2112,11 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
  * @complete_code:
  *		 Completion code
  */
-static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
-					struct cvmx_usb_pipe *pipe,
-					struct cvmx_usb_transaction *transaction,
-					enum cvmx_usb_complete complete_code)
+static void __cvmx_usb_perform_complete(
+				struct cvmx_usb_state *usb,
+				struct cvmx_usb_pipe *pipe,
+				struct cvmx_usb_transaction *transaction,
+				enum cvmx_usb_complete complete_code)
 {
 	/* If this was a split then clear our split in progress marker */
 	if (usb->active_split == transaction)
@@ -2019,7 +2135,8 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 		 * If there are more ISOs pending and we succeeded, schedule the
 		 * next one
 		 */
-		if ((transaction->iso_number_packets > 1) && (complete_code == CVMX_USB_COMPLETE_SUCCESS)) {
+		if ((transaction->iso_number_packets > 1) &&
+			(complete_code == CVMX_USB_COMPLETE_SUCCESS)) {
 			/* No bytes transferred for this packet as of yet */
 			transaction->actual_bytes = 0;
 			/* One less ISO waiting to transfer */
@@ -2067,16 +2184,17 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
  *
  * Returns: Transaction or NULL on failure.
  */
-static struct cvmx_usb_transaction *__cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
-								  struct cvmx_usb_pipe *pipe,
-								  enum cvmx_usb_transfer type,
-								  uint64_t buffer,
-								  int buffer_length,
-								  uint64_t control_header,
-								  int iso_start_frame,
-								  int iso_number_packets,
-								  struct cvmx_usb_iso_packet *iso_packets,
-								  struct urb *urb)
+static struct cvmx_usb_transaction *__cvmx_usb_submit_transaction(
+				struct cvmx_usb_state *usb,
+				struct cvmx_usb_pipe *pipe,
+				enum cvmx_usb_transfer type,
+				uint64_t buffer,
+				int buffer_length,
+				uint64_t control_header,
+				int iso_start_frame,
+				int iso_number_packets,
+				struct cvmx_usb_iso_packet *iso_packets,
+				struct urb *urb)
 {
 	struct cvmx_usb_transaction *transaction;
 
@@ -2128,9 +2246,10 @@ static struct cvmx_usb_transaction *__cvmx_usb_submit_transaction(struct cvmx_us
  *
  * Returns: A submitted transaction or NULL on failure.
  */
-static struct cvmx_usb_transaction *cvmx_usb_submit_bulk(struct cvmx_usb_state *usb,
-							 struct cvmx_usb_pipe *pipe,
-							 struct urb *urb)
+static struct cvmx_usb_transaction *cvmx_usb_submit_bulk(
+						struct cvmx_usb_state *usb,
+						struct cvmx_usb_pipe *pipe,
+						struct urb *urb)
 {
 	return __cvmx_usb_submit_transaction(usb, pipe, CVMX_USB_TRANSFER_BULK,
 					     urb->transfer_dma,
@@ -2152,9 +2271,10 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_bulk(struct cvmx_usb_state *
  *
  * Returns: A submitted transaction or NULL on failure.
  */
-static struct cvmx_usb_transaction *cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
-							      struct cvmx_usb_pipe *pipe,
-							      struct urb *urb)
+static struct cvmx_usb_transaction *cvmx_usb_submit_interrupt(
+						struct cvmx_usb_state *usb,
+						struct cvmx_usb_pipe *pipe,
+						struct urb *urb)
 {
 	return __cvmx_usb_submit_transaction(usb, pipe,
 					     CVMX_USB_TRANSFER_INTERRUPT,
@@ -2177,9 +2297,10 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_interrupt(struct cvmx_usb_st
  *
  * Returns: A submitted transaction or NULL on failure.
  */
-static struct cvmx_usb_transaction *cvmx_usb_submit_control(struct cvmx_usb_state *usb,
-							    struct cvmx_usb_pipe *pipe,
-							    struct urb *urb)
+static struct cvmx_usb_transaction *cvmx_usb_submit_control(
+						struct cvmx_usb_state *usb,
+						struct cvmx_usb_pipe *pipe,
+						struct urb *urb)
 {
 	int buffer_length = urb->transfer_buffer_length;
 	uint64_t control_header = urb->setup_dma;
@@ -2209,9 +2330,10 @@ static struct cvmx_usb_transaction *cvmx_usb_submit_control(struct cvmx_usb_stat
  *
  * Returns: A submitted transaction or NULL on failure.
  */
-static struct cvmx_usb_transaction *cvmx_usb_submit_isochronous(struct cvmx_usb_state *usb,
-								struct cvmx_usb_pipe *pipe,
-								struct urb *urb)
+static struct cvmx_usb_transaction *cvmx_usb_submit_isochronous(
+						struct cvmx_usb_state *usb,
+						struct cvmx_usb_pipe *pipe,
+						struct urb *urb)
 {
 	struct cvmx_usb_iso_packet *packets;
 
@@ -2257,17 +2379,22 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 
 		CVMX_SYNCW;
 
-		usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCCHARX(pipe->channel, usb->index));
+		usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCCHARX(pipe->channel, usb->index));
 		/*
 		 * If the channel isn't enabled then the transaction already
 		 * completed.
 		 */
 		if (usbc_hcchar.s.chena) {
 			usbc_hcchar.s.chdis = 1;
-			__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCCHARX(pipe->channel, usb->index), usbc_hcchar.u32);
+			__cvmx_usb_write_csr32(usb,
+					CVMX_USBCX_HCCHARX(pipe->channel,
+						usb->index),
+					usbc_hcchar.u32);
 		}
 	}
-	__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_CANCEL);
+	__cvmx_usb_perform_complete(usb, pipe, transaction,
+				    CVMX_USB_COMPLETE_CANCEL);
 	return 0;
 }
 
@@ -2331,7 +2458,8 @@ static int cvmx_usb_get_frame_number(struct cvmx_usb_state *usb)
 	int frame_number;
 	union cvmx_usbcx_hfnum usbc_hfnum;
 
-	usbc_hfnum.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
+	usbc_hfnum.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HFNUM(usb->index));
 	frame_number = usbc_hfnum.s.frnum;
 
 	return frame_number;
@@ -2359,10 +2487,12 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	int buffer_space_left;
 
 	/* Read the interrupt status bits for the channel */
-	usbc_hcint.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCINTX(channel, usb->index));
+	usbc_hcint.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HCINTX(channel, usb->index));
 
 	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
-		usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index));
+		usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HCCHARX(channel, usb->index));
 
 		if (usbc_hcchar.s.chena && usbc_hcchar.s.chdis) {
 			/*
@@ -2370,7 +2500,10 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * interrupt IN transfers to get stuck until we do a
 			 * write of HCCHARX without changing things
 			 */
-			__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index), usbc_hcchar.u32);
+			__cvmx_usb_write_csr32(usb,
+					CVMX_USBCX_HCCHARX(channel,
+							   usb->index),
+					usbc_hcchar.u32);
 			return 0;
 		}
 
@@ -2384,9 +2517,15 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				/* Disable all interrupts except CHHLTD */
 				hcintmsk.u32 = 0;
 				hcintmsk.s.chhltdmsk = 1;
-				__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), hcintmsk.u32);
+				__cvmx_usb_write_csr32(usb,
+						CVMX_USBCX_HCINTMSKX(channel,
+							usb->index),
+						hcintmsk.u32);
 				usbc_hcchar.s.chdis = 1;
-				__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index), usbc_hcchar.u32);
+				__cvmx_usb_write_csr32(usb,
+						CVMX_USBCX_HCCHARX(channel,
+							usb->index),
+						usbc_hcchar.u32);
 				return 0;
 			} else if (usbc_hcint.s.xfercompl) {
 				/*
@@ -2394,7 +2533,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				 * Channel halt isn't needed.
 				 */
 			} else {
-				cvmx_dprintf("USB%d: Channel %d interrupt without halt\n", usb->index, channel);
+				cvmx_dprintf("USB%d: Channel %d interrupt without halt\n",
+						usb->index, channel);
 				return 0;
 			}
 		}
@@ -2417,7 +2557,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	CVMX_PREFETCH(pipe, 128);
 	if (!pipe)
 		return 0;
-	transaction = list_first_entry(&pipe->transactions, typeof(*transaction),
+	transaction = list_first_entry(&pipe->transactions,
+				       typeof(*transaction),
 				       node);
 	CVMX_PREFETCH(transaction, 0);
 
@@ -2432,8 +2573,10 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	 * Read the channel config info so we can figure out how much data
 	 * transfered
 	 */
-	usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index));
-	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index));
+	usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HCCHARX(channel, usb->index));
+	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb,
+			CVMX_USBCX_HCTSIZX(channel, usb->index));
 
 	/*
 	 * Calculating the number of bytes successfully transferred is dependent
@@ -2447,7 +2590,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		 * the current value of xfersize from its starting value and we
 		 * know how many bytes were written to the buffer
 		 */
-		bytes_this_transfer = transaction->xfersize - usbc_hctsiz.s.xfersize;
+		bytes_this_transfer = transaction->xfersize -
+			usbc_hctsiz.s.xfersize;
 	} else {
 		/*
 		 * OUT transaction don't decrement xfersize. Instead pktcnt is
@@ -2465,7 +2609,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	}
 	/* Figure out how many bytes were in the last packet of the transfer */
 	if (packets_processed)
-		bytes_in_last_packet = bytes_this_transfer - (packets_processed-1) * usbc_hcchar.s.mps;
+		bytes_in_last_packet = bytes_this_transfer -
+			(packets_processed - 1) * usbc_hcchar.s.mps;
 	else
 		bytes_in_last_packet = bytes_this_transfer;
 
@@ -2485,9 +2630,11 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	 */
 	transaction->actual_bytes += bytes_this_transfer;
 	if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
-		buffer_space_left = transaction->iso_packets[0].length - transaction->actual_bytes;
+		buffer_space_left = transaction->iso_packets[0].length -
+			transaction->actual_bytes;
 	else
-		buffer_space_left = transaction->buffer_length - transaction->actual_bytes;
+		buffer_space_left = transaction->buffer_length -
+			transaction->actual_bytes;
 
 	/*
 	 * We need to remember the PID toggle state for the next transaction.
@@ -2513,7 +2660,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		 * the actual bytes transferred
 		 */
 		pipe->pid_toggle = 0;
-		__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_STALL);
+		__cvmx_usb_perform_complete(usb, pipe, transaction,
+					    CVMX_USB_COMPLETE_STALL);
 	} else if (usbc_hcint.s.xacterr) {
 		/*
 		 * We know at least one packet worked if we get a ACK or NAK.
@@ -2528,7 +2676,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * something wrong with the transfer. For example, PID
 			 * toggle errors cause these
 			 */
-			__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_XACTERR);
+			__cvmx_usb_perform_complete(usb, pipe, transaction,
+						    CVMX_USB_COMPLETE_XACTERR);
 		} else {
 			/*
 			 * If this was a split then clear our split in progress
@@ -2544,12 +2693,15 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			pipe->split_sc_frame = -1;
 			pipe->next_tx_frame += pipe->interval;
 			if (pipe->next_tx_frame < usb->frame_number)
-				pipe->next_tx_frame = usb->frame_number + pipe->interval -
-						      (usb->frame_number - pipe->next_tx_frame) % pipe->interval;
+				pipe->next_tx_frame =
+					usb->frame_number + pipe->interval -
+					(usb->frame_number -
+					 pipe->next_tx_frame) % pipe->interval;
 		}
 	} else if (usbc_hcint.s.bblerr) {
 		/* Babble Error (BblErr) */
-		__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_BABBLEERR);
+		__cvmx_usb_perform_complete(usb, pipe, transaction,
+					    CVMX_USB_COMPLETE_BABBLEERR);
 	} else if (usbc_hcint.s.datatglerr) {
 		/* We'll retry the exact same transaction again */
 		transaction->retries++;
@@ -2566,8 +2718,11 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * If there is more data to go then we need to try
 			 * again. Otherwise this transaction is complete
 			 */
-			if ((buffer_space_left == 0) || (bytes_in_last_packet < pipe->max_packet))
-				__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+			if ((buffer_space_left == 0) ||
+				(bytes_in_last_packet < pipe->max_packet))
+				__cvmx_usb_perform_complete(usb, pipe,
+						transaction,
+						CVMX_USB_COMPLETE_SUCCESS);
 		} else {
 			/*
 			 * Split transactions retry the split complete 4 times
@@ -2605,12 +2760,14 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			case CVMX_USB_STAGE_NON_CONTROL:
 			case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
 				/* This should be impossible */
-				__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_ERROR);
+				__cvmx_usb_perform_complete(usb, pipe,
+					transaction, CVMX_USB_COMPLETE_ERROR);
 				break;
 			case CVMX_USB_STAGE_SETUP:
 				pipe->pid_toggle = 1;
 				if (__cvmx_usb_pipe_needs_split(usb, pipe))
-					transaction->stage = CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE;
+					transaction->stage =
+						CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE;
 				else {
 					union cvmx_usb_control_header *header =
 						cvmx_phys_to_ptr(transaction->control_header);
@@ -2632,7 +2789,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 				break;
 			case CVMX_USB_STAGE_DATA:
 				if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
-					transaction->stage = CVMX_USB_STAGE_DATA_SPLIT_COMPLETE;
+					transaction->stage =
+						CVMX_USB_STAGE_DATA_SPLIT_COMPLETE;
 					/*
 					 * For setup OUT data that are splits,
 					 * the hardware doesn't appear to count
@@ -2641,31 +2799,45 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					 */
 					if (!usbc_hcchar.s.epdir) {
 						if (buffer_space_left < pipe->max_packet)
-							transaction->actual_bytes += buffer_space_left;
+							transaction->actual_bytes +=
+								buffer_space_left;
 						else
-							transaction->actual_bytes += pipe->max_packet;
+							transaction->actual_bytes +=
+								pipe->max_packet;
 					}
-				} else if ((buffer_space_left == 0) || (bytes_in_last_packet < pipe->max_packet)) {
+				} else if ((buffer_space_left == 0) ||
+						(bytes_in_last_packet <
+						 pipe->max_packet)) {
 					pipe->pid_toggle = 1;
-					transaction->stage = CVMX_USB_STAGE_STATUS;
+					transaction->stage =
+						CVMX_USB_STAGE_STATUS;
 				}
 				break;
 			case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
-				if ((buffer_space_left == 0) || (bytes_in_last_packet < pipe->max_packet)) {
+				if ((buffer_space_left == 0) ||
+						(bytes_in_last_packet <
+						 pipe->max_packet)) {
 					pipe->pid_toggle = 1;
-					transaction->stage = CVMX_USB_STAGE_STATUS;
+					transaction->stage =
+						CVMX_USB_STAGE_STATUS;
 				} else {
-					transaction->stage = CVMX_USB_STAGE_DATA;
+					transaction->stage =
+						CVMX_USB_STAGE_DATA;
 				}
 				break;
 			case CVMX_USB_STAGE_STATUS:
 				if (__cvmx_usb_pipe_needs_split(usb, pipe))
-					transaction->stage = CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;
+					transaction->stage =
+						CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;
 				else
-					__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+					__cvmx_usb_perform_complete(usb, pipe,
+						transaction,
+						CVMX_USB_COMPLETE_SUCCESS);
 				break;
 			case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
-				__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+				__cvmx_usb_perform_complete(usb, pipe,
+						transaction,
+						CVMX_USB_COMPLETE_SUCCESS);
 				break;
 			}
 			break;
@@ -2678,27 +2850,49 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * data is needed
 			 */
 			if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
-				if (transaction->stage == CVMX_USB_STAGE_NON_CONTROL)
-					transaction->stage = CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
+				if (transaction->stage ==
+						CVMX_USB_STAGE_NON_CONTROL)
+					transaction->stage =
+						CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
 				else {
-					if (buffer_space_left && (bytes_in_last_packet == pipe->max_packet))
-						transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+					if (buffer_space_left &&
+						(bytes_in_last_packet ==
+						 pipe->max_packet))
+						transaction->stage =
+							CVMX_USB_STAGE_NON_CONTROL;
 					else {
-						if (transaction->type == CVMX_USB_TRANSFER_INTERRUPT)
-							pipe->next_tx_frame += pipe->interval;
-							__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+						if (transaction->type ==
+							CVMX_USB_TRANSFER_INTERRUPT)
+							pipe->next_tx_frame +=
+								pipe->interval;
+							__cvmx_usb_perform_complete(
+								usb,
+								pipe,
+								transaction,
+								CVMX_USB_COMPLETE_SUCCESS);
 					}
 				}
 			} else {
-				if ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&
-				    (pipe->transfer_type == CVMX_USB_TRANSFER_BULK) &&
-				    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) &&
+				if ((pipe->device_speed ==
+					CVMX_USB_SPEED_HIGH) &&
+				    (pipe->transfer_type ==
+				     CVMX_USB_TRANSFER_BULK) &&
+				    (pipe->transfer_dir ==
+				     CVMX_USB_DIRECTION_OUT) &&
 				    (usbc_hcint.s.nak))
-					pipe->flags |= __CVMX_USB_PIPE_FLAGS_NEED_PING;
-				if (!buffer_space_left || (bytes_in_last_packet < pipe->max_packet)) {
-					if (transaction->type == CVMX_USB_TRANSFER_INTERRUPT)
-						pipe->next_tx_frame += pipe->interval;
-					__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+					pipe->flags |=
+						__CVMX_USB_PIPE_FLAGS_NEED_PING;
+				if (!buffer_space_left ||
+					(bytes_in_last_packet <
+					 pipe->max_packet)) {
+					if (transaction->type ==
+						CVMX_USB_TRANSFER_INTERRUPT)
+						pipe->next_tx_frame +=
+							pipe->interval;
+					__cvmx_usb_perform_complete(usb,
+						pipe,
+						transaction,
+						CVMX_USB_COMPLETE_SUCCESS);
 				}
 			}
 			break;
@@ -2719,28 +2913,45 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 					 * complete. Otherwise start it again to
 					 * send the next 188 bytes
 					 */
-					if (!buffer_space_left || (bytes_this_transfer < 188)) {
+					if (!buffer_space_left ||
+						(bytes_this_transfer < 188)) {
 						pipe->next_tx_frame += pipe->interval;
-						__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+						__cvmx_usb_perform_complete(
+							usb,
+							pipe,
+							transaction,
+							CVMX_USB_COMPLETE_SUCCESS);
 					}
 				} else {
-					if (transaction->stage == CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE) {
+					if (transaction->stage ==
+						CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE) {
 						/*
 						 * We are in the incoming data
 						 * phase. Keep getting data
 						 * until we run out of space or
 						 * get a small packet
 						 */
-						if ((buffer_space_left == 0) || (bytes_in_last_packet < pipe->max_packet)) {
-							pipe->next_tx_frame += pipe->interval;
-							__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+						if ((buffer_space_left == 0) ||
+							(bytes_in_last_packet <
+							 pipe->max_packet)) {
+							pipe->next_tx_frame +=
+								pipe->interval;
+							__cvmx_usb_perform_complete(
+								usb,
+								pipe,
+								transaction,
+								CVMX_USB_COMPLETE_SUCCESS);
 						}
 					} else
-						transaction->stage = CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
+						transaction->stage =
+							CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
 				}
 			} else {
 				pipe->next_tx_frame += pipe->interval;
-				__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+				__cvmx_usb_perform_complete(usb,
+						pipe,
+						transaction,
+						CVMX_USB_COMPLETE_SUCCESS);
 			}
 			break;
 		}
@@ -2760,8 +2971,10 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 		transaction->stage &= ~1;
 		pipe->next_tx_frame += pipe->interval;
 		if (pipe->next_tx_frame < usb->frame_number)
-			pipe->next_tx_frame = usb->frame_number + pipe->interval -
-				(usb->frame_number - pipe->next_tx_frame) % pipe->interval;
+			pipe->next_tx_frame = usb->frame_number +
+				pipe->interval -
+				(usb->frame_number - pipe->next_tx_frame) %
+				pipe->interval;
 	} else {
 		struct cvmx_usb_port_status port;
 		port = cvmx_usb_get_status(usb);
@@ -2773,7 +2986,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 			 * We get channel halted interrupts with no result bits
 			 * sets when the cable is unplugged
 			 */
-			__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_ERROR);
+			__cvmx_usb_perform_complete(usb, pipe, transaction,
+					CVMX_USB_COMPLETE_ERROR);
 		}
 	}
 	return 0;
@@ -2856,9 +3070,11 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 		 */
 		octeon_usb_port_callback(usb);
 		/* Clear the port change bits */
-		usbc_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+		usbc_hprt.u32 = __cvmx_usb_read_csr32(usb,
+				CVMX_USBCX_HPRT(usb->index));
 		usbc_hprt.s.prtena = 0;
-		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HPRT(usb->index), usbc_hprt.u32);
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HPRT(usb->index),
+				       usbc_hprt.u32);
 	}
 	if (usbc_gintsts.s.hchint) {
 		/*
@@ -3002,13 +3218,15 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		}
 		pipe = cvmx_usb_open_pipe(&priv->usb, usb_pipedevice(urb->pipe),
 					  usb_pipeendpoint(urb->pipe), speed,
-					  le16_to_cpu(ep->desc.wMaxPacketSize) & 0x7ff,
+					  le16_to_cpu(ep->desc.wMaxPacketSize)
+					  & 0x7ff,
 					  transfer_type,
 					  usb_pipein(urb->pipe) ?
 						CVMX_USB_DIRECTION_IN :
 						CVMX_USB_DIRECTION_OUT,
 					  urb->interval,
-					  (le16_to_cpu(ep->desc.wMaxPacketSize) >> 11) & 0x3,
+					  (le16_to_cpu(ep->desc.wMaxPacketSize)
+					   >> 11) & 0x3,
 					  split_device, split_port);
 		if (!pipe) {
 			spin_unlock_irqrestore(&priv->lock, flags);
@@ -3023,7 +3241,8 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	switch (usb_pipetype(urb->pipe)) {
 	case PIPE_ISOCHRONOUS:
 		dev_dbg(dev, "Submit isochronous to %d.%d\n",
-			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+			usb_pipedevice(urb->pipe),
+			usb_pipeendpoint(urb->pipe));
 		/*
 		 * Allocate a structure to use for our private list of
 		 * isochronous packets.
@@ -3035,9 +3254,12 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 			int i;
 			/* Fill the list with the data from the URB */
 			for (i = 0; i < urb->number_of_packets; i++) {
-				iso_packet[i].offset = urb->iso_frame_desc[i].offset;
-				iso_packet[i].length = urb->iso_frame_desc[i].length;
-				iso_packet[i].status = CVMX_USB_COMPLETE_ERROR;
+				iso_packet[i].offset =
+					urb->iso_frame_desc[i].offset;
+				iso_packet[i].length =
+					urb->iso_frame_desc[i].length;
+				iso_packet[i].status =
+					CVMX_USB_COMPLETE_ERROR;
 			}
 			/*
 			 * Store a pointer to the list in the URB setup_packet
@@ -3059,17 +3281,20 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		break;
 	case PIPE_INTERRUPT:
 		dev_dbg(dev, "Submit interrupt to %d.%d\n",
-			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+			usb_pipedevice(urb->pipe),
+			usb_pipeendpoint(urb->pipe));
 		transaction = cvmx_usb_submit_interrupt(&priv->usb, pipe, urb);
 		break;
 	case PIPE_CONTROL:
 		dev_dbg(dev, "Submit control to %d.%d\n",
-			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+			usb_pipedevice(urb->pipe),
+			usb_pipeendpoint(urb->pipe));
 		transaction = cvmx_usb_submit_control(&priv->usb, pipe, urb);
 		break;
 	case PIPE_BULK:
 		dev_dbg(dev, "Submit bulk to %d.%d\n",
-			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+			usb_pipedevice(urb->pipe),
+			usb_pipeendpoint(urb->pipe));
 		transaction = cvmx_usb_submit_bulk(&priv->usb, pipe, urb);
 		break;
 	}
@@ -3100,7 +3325,9 @@ static void octeon_usb_urb_dequeue_work(unsigned long arg)
 	spin_unlock_irqrestore(&priv->lock, flags);
 }
 
-static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+static int octeon_usb_urb_dequeue(struct usb_hcd *hcd,
+				  struct urb *urb,
+				  int status)
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	unsigned long flags;
@@ -3120,7 +3347,8 @@ static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int stat
 	return 0;
 }
 
-static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
+static void octeon_usb_endpoint_disable(struct usb_hcd *hcd,
+					struct usb_host_endpoint *ep)
 {
 	struct device *dev = hcd->self.controller;
 
@@ -3203,7 +3431,8 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			dev_dbg(dev, " C_CONNECTION\n");
 			/* Clears drivers internal connect status change flag */
 			spin_lock_irqsave(&priv->lock, flags);
-			priv->usb.port_status = cvmx_usb_get_status(&priv->usb);
+			priv->usb.port_status =
+				cvmx_usb_get_status(&priv->usb);
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_RESET:
@@ -3212,7 +3441,8 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			 * Clears the driver's internal Port Reset Change flag.
 			 */
 			spin_lock_irqsave(&priv->lock, flags);
-			priv->usb.port_status = cvmx_usb_get_status(&priv->usb);
+			priv->usb.port_status =
+				cvmx_usb_get_status(&priv->usb);
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_ENABLE:
@@ -3222,7 +3452,8 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			 * Change flag.
 			 */
 			spin_lock_irqsave(&priv->lock, flags);
-			priv->usb.port_status = cvmx_usb_get_status(&priv->usb);
+			priv->usb.port_status =
+				cvmx_usb_get_status(&priv->usb);
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
@@ -3237,7 +3468,8 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			dev_dbg(dev, " C_OVER_CURRENT\n");
 			/* Clears the driver's overcurrent Change flag */
 			spin_lock_irqsave(&priv->lock, flags);
-			priv->usb.port_status = cvmx_usb_get_status(&priv->usb);
+			priv->usb.port_status =
+				cvmx_usb_get_status(&priv->usb);
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		default:
@@ -3411,7 +3643,8 @@ static int octeon_usb_probe(struct platform_device *pdev)
 		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ;
 		break;
 	default:
-		dev_err(dev, "Illebal USBN \"refclk-frequency\" %u\n", clock_rate);
+		dev_err(dev, "Illebal USBN \"refclk-frequency\" %u\n",
+				clock_rate);
 		return -ENXIO;
 
 	}
@@ -3477,7 +3710,8 @@ static int octeon_usb_probe(struct platform_device *pdev)
 
 	spin_lock_init(&priv->lock);
 
-	tasklet_init(&priv->dequeue_tasklet, octeon_usb_urb_dequeue_work, (unsigned long)priv);
+	tasklet_init(&priv->dequeue_tasklet, octeon_usb_urb_dequeue_work,
+		     (unsigned long)priv);
 	INIT_LIST_HEAD(&priv->dequeue_list);
 
 	status = cvmx_usb_initialize(&priv->usb, usb_num, initialize_flags);

commit b91619c284e53fec09d502f29c1ad7ee4766e664
Author: David Daney <david.daney@cavium.com>
Date:   Mon Feb 3 19:39:01 2014 +0200

    staging: octeon-usb: Probe via device tree populated platform device.
    
    Extract clocking parameters from the device tree, and remove now dead
    code and types.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Tested-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 47e0a91238a1..5a001d9b4252 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -275,13 +275,6 @@ enum cvmx_usb_pipe_flags {
  */
 #define MAX_TRANSFER_PACKETS	((1<<10)-1)
 
-enum {
-	USB_CLOCK_TYPE_REF_12,
-	USB_CLOCK_TYPE_REF_24,
-	USB_CLOCK_TYPE_REF_48,
-	USB_CLOCK_TYPE_CRYSTAL_12,
-};
-
 /**
  * Logical transactions may take numerous low level
  * transactions, especially when splits are concerned. This
@@ -471,19 +464,6 @@ struct octeon_hcd {
 /* Returns the IO address to push/pop stuff data from the FIFOs */
 #define USB_FIFO_ADDRESS(channel, usb_index) (CVMX_USBCX_GOTGCTL(usb_index) + ((channel)+1)*0x1000)
 
-static int octeon_usb_get_clock_type(void)
-{
-	switch (cvmx_sysinfo_get()->board_type) {
-	case CVMX_BOARD_TYPE_BBGW_REF:
-	case CVMX_BOARD_TYPE_LANAI2_A:
-	case CVMX_BOARD_TYPE_LANAI2_U:
-	case CVMX_BOARD_TYPE_LANAI2_G:
-	case CVMX_BOARD_TYPE_UBNT_E100:
-		return USB_CLOCK_TYPE_CRYSTAL_12;
-	}
-	return USB_CLOCK_TYPE_REF_48;
-}
-
 /**
  * Read a USB 32bit CSR. It performs the necessary address swizzle
  * for 32bit CSRs and logs the value in a readable format if
@@ -582,37 +562,6 @@ static inline int __cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)
 		return 0; /* Data0 */
 }
 
-
-/**
- * Return the number of USB ports supported by this Octeon
- * chip. If the chip doesn't support USB, or is not supported
- * by this API, a zero will be returned. Most Octeon chips
- * support one usb port, but some support two ports.
- * cvmx_usb_initialize() must be called on independent
- * struct cvmx_usb_state.
- *
- * Returns: Number of port, zero if usb isn't supported
- */
-static int cvmx_usb_get_num_ports(void)
-{
-	int arch_ports = 0;
-
-	if (OCTEON_IS_MODEL(OCTEON_CN56XX))
-		arch_ports = 1;
-	else if (OCTEON_IS_MODEL(OCTEON_CN52XX))
-		arch_ports = 2;
-	else if (OCTEON_IS_MODEL(OCTEON_CN50XX))
-		arch_ports = 1;
-	else if (OCTEON_IS_MODEL(OCTEON_CN31XX))
-		arch_ports = 1;
-	else if (OCTEON_IS_MODEL(OCTEON_CN30XX))
-		arch_ports = 1;
-	else
-		arch_ports = 0;
-
-	return arch_ports;
-}
-
 /**
  * Initialize a USB port for use. This must be called before any
  * other access to the Octeon USB port is made. The port starts
@@ -628,41 +577,16 @@ static int cvmx_usb_get_num_ports(void)
  * Returns: 0 or a negative error code.
  */
 static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
-			       int usb_port_number)
+			       int usb_port_number,
+			       enum cvmx_usb_initialize_flags flags)
 {
 	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
 	union cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;
-	enum cvmx_usb_initialize_flags flags = 0;
 	int i;
 
 	/* At first allow 0-1 for the usb port number */
 	if ((usb_port_number < 0) || (usb_port_number > 1))
 		return -EINVAL;
-	/* For all chips except 52XX there is only one port */
-	if (!OCTEON_IS_MODEL(OCTEON_CN52XX) && (usb_port_number > 0))
-		return -EINVAL;
-	/* Try to determine clock type automatically */
-	if (octeon_usb_get_clock_type() == USB_CLOCK_TYPE_CRYSTAL_12) {
-		/* Only 12 MHZ crystals are supported */
-		flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI;
-	} else {
-		flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND;
-
-		switch (octeon_usb_get_clock_type()) {
-		case USB_CLOCK_TYPE_REF_12:
-			flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ;
-			break;
-		case USB_CLOCK_TYPE_REF_24:
-			flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ;
-			break;
-		case USB_CLOCK_TYPE_REF_48:
-			flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ;
-			break;
-		default:
-			return -EINVAL;
-			break;
-		}
-	}
 
 	memset(usb, 0, sizeof(*usb));
 	usb->init_flags = flags;
@@ -3431,7 +3355,6 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 	return 0;
 }
 
-
 static const struct hc_driver octeon_hc_driver = {
 	.description		= "Octeon USB",
 	.product_desc		= "Octeon Host Controller",
@@ -3448,15 +3371,74 @@ static const struct hc_driver octeon_hc_driver = {
 	.hub_control		= octeon_usb_hub_control,
 };
 
-
-static int octeon_usb_driver_probe(struct device *dev)
+static int octeon_usb_probe(struct platform_device *pdev)
 {
 	int status;
-	int usb_num = to_platform_device(dev)->id;
-	int irq = platform_get_irq(to_platform_device(dev), 0);
+	int initialize_flags;
+	int usb_num;
+	struct resource *res_mem;
+	struct device_node *usbn_node;
+	int irq = platform_get_irq(pdev, 0);
+	struct device *dev = &pdev->dev;
 	struct octeon_hcd *priv;
 	struct usb_hcd *hcd;
 	unsigned long flags;
+	u32 clock_rate = 48000000;
+	bool is_crystal_clock = false;
+	const char *clock_type;
+	int i;
+
+	if (dev->of_node == NULL) {
+		dev_err(dev, "Error: empty of_node\n");
+		return -ENXIO;
+	}
+	usbn_node = dev->of_node->parent;
+
+	i = of_property_read_u32(usbn_node,
+				 "refclk-frequency", &clock_rate);
+	if (i) {
+		dev_err(dev, "No USBN \"refclk-frequency\"\n");
+		return -ENXIO;
+	}
+	switch (clock_rate) {
+	case 12000000:
+		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ;
+		break;
+	case 24000000:
+		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ;
+		break;
+	case 48000000:
+		initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ;
+		break;
+	default:
+		dev_err(dev, "Illebal USBN \"refclk-frequency\" %u\n", clock_rate);
+		return -ENXIO;
+
+	}
+
+	i = of_property_read_string(usbn_node,
+				    "refclk-type", &clock_type);
+
+	if (!i && strcmp("crystal", clock_type) == 0)
+		is_crystal_clock = true;
+
+	if (is_crystal_clock)
+		initialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI;
+	else
+		initialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND;
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res_mem == NULL) {
+		dev_err(dev, "found no memory resource\n");
+		return -ENXIO;
+	}
+	usb_num = (res_mem->start >> 44) & 1;
+
+	if (irq < 0) {
+		/* Defective device tree, but we know how to fix it. */
+		irq_hw_number_t hwirq = usb_num ? (1 << 6) + 17 : 56;
+		irq = irq_create_mapping(NULL, hwirq);
+	}
 
 	/*
 	 * Set the DMA mask to 64bits so we get buffers already translated for
@@ -3465,6 +3447,26 @@ static int octeon_usb_driver_probe(struct device *dev)
 	dev->coherent_dma_mask = ~0;
 	dev->dma_mask = &dev->coherent_dma_mask;
 
+	/*
+	 * Only cn52XX and cn56XX have DWC_OTG USB hardware and the
+	 * IOB priority registers.  Under heavy network load USB
+	 * hardware can be starved by the IOB causing a crash.  Give
+	 * it a priority boost if it has been waiting more than 400
+	 * cycles to avoid this situation.
+	 *
+	 * Testing indicates that a cnt_val of 8192 is not sufficient,
+	 * but no failures are seen with 4096.  We choose a value of
+	 * 400 to give a safety factor of 10.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX)) {
+		union cvmx_iob_n2c_l2c_pri_cnt pri_cnt;
+
+		pri_cnt.u64 = 0;
+		pri_cnt.s.cnt_enb = 1;
+		pri_cnt.s.cnt_val = 400;
+		cvmx_write_csr(CVMX_IOB_N2C_L2C_PRI_CNT, pri_cnt.u64);
+	}
+
 	hcd = usb_create_hcd(&octeon_hc_driver, dev, dev_name(dev));
 	if (!hcd) {
 		dev_dbg(dev, "Failed to allocate memory for HCD\n");
@@ -3478,7 +3480,7 @@ static int octeon_usb_driver_probe(struct device *dev)
 	tasklet_init(&priv->dequeue_tasklet, octeon_usb_urb_dequeue_work, (unsigned long)priv);
 	INIT_LIST_HEAD(&priv->dequeue_list);
 
-	status = cvmx_usb_initialize(&priv->usb, usb_num);
+	status = cvmx_usb_initialize(&priv->usb, usb_num, initialize_flags);
 	if (status) {
 		dev_dbg(dev, "USB initialization failed with %d\n", status);
 		kfree(hcd);
@@ -3492,7 +3494,7 @@ static int octeon_usb_driver_probe(struct device *dev)
 	cvmx_usb_poll(&priv->usb);
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	status = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	status = usb_add_hcd(hcd, irq, 0);
 	if (status) {
 		dev_dbg(dev, "USB add HCD failed with %d\n", status);
 		kfree(hcd);
@@ -3500,14 +3502,15 @@ static int octeon_usb_driver_probe(struct device *dev)
 	}
 	device_wakeup_enable(hcd->self.controller);
 
-	dev_dbg(dev, "Registered HCD for port %d on irq %d\n", usb_num, irq);
+	dev_info(dev, "Registered HCD for port %d on irq %d\n", usb_num, irq);
 
 	return 0;
 }
 
-static int octeon_usb_driver_remove(struct device *dev)
+static int octeon_usb_remove(struct platform_device *pdev)
 {
 	int status;
+	struct device *dev = &pdev->dev;
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	unsigned long flags;
@@ -3525,85 +3528,41 @@ static int octeon_usb_driver_remove(struct device *dev)
 	return 0;
 }
 
-static struct device_driver octeon_usb_driver = {
-	.name	= "OcteonUSB",
-	.bus	= &platform_bus_type,
-	.probe	= octeon_usb_driver_probe,
-	.remove	= octeon_usb_driver_remove,
+static struct of_device_id octeon_usb_match[] = {
+	{
+		.compatible = "cavium,octeon-5750-usbc",
+	},
+	{},
 };
 
+static struct platform_driver octeon_usb_driver = {
+	.driver = {
+		.name       = "OcteonUSB",
+		.owner		= THIS_MODULE,
+		.of_match_table = octeon_usb_match,
+	},
+	.probe      = octeon_usb_probe,
+	.remove     = octeon_usb_remove,
+};
 
-#define MAX_USB_PORTS   10
-static struct platform_device *pdev_glob[MAX_USB_PORTS];
-static int octeon_usb_registered;
-static int __init octeon_usb_module_init(void)
+static int __init octeon_usb_driver_init(void)
 {
-	int num_devices = cvmx_usb_get_num_ports();
-	int device;
-
-	if (usb_disabled() || num_devices == 0)
-		return -ENODEV;
-
-	if (driver_register(&octeon_usb_driver))
-		return -ENOMEM;
-
-	octeon_usb_registered = 1;
-
-	/*
-	 * Only cn52XX and cn56XX have DWC_OTG USB hardware and the
-	 * IOB priority registers.  Under heavy network load USB
-	 * hardware can be starved by the IOB causing a crash.  Give
-	 * it a priority boost if it has been waiting more than 400
-	 * cycles to avoid this situation.
-	 *
-	 * Testing indicates that a cnt_val of 8192 is not sufficient,
-	 * but no failures are seen with 4096.  We choose a value of
-	 * 400 to give a safety factor of 10.
-	 */
-	if (OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX)) {
-		union cvmx_iob_n2c_l2c_pri_cnt pri_cnt;
-
-		pri_cnt.u64 = 0;
-		pri_cnt.s.cnt_enb = 1;
-		pri_cnt.s.cnt_val = 400;
-		cvmx_write_csr(CVMX_IOB_N2C_L2C_PRI_CNT, pri_cnt.u64);
-	}
-
-	for (device = 0; device < num_devices; device++) {
-		struct resource irq_resource;
-		struct platform_device *pdev;
-		memset(&irq_resource, 0, sizeof(irq_resource));
-		irq_resource.start = (device == 0) ? OCTEON_IRQ_USB0 : OCTEON_IRQ_USB1;
-		irq_resource.end = irq_resource.start;
-		irq_resource.flags = IORESOURCE_IRQ;
-		pdev = platform_device_register_simple((char *)octeon_usb_driver.  name, device, &irq_resource, 1);
-		if (IS_ERR(pdev)) {
-			driver_unregister(&octeon_usb_driver);
-			octeon_usb_registered = 0;
-			return PTR_ERR(pdev);
-		}
-		if (device < MAX_USB_PORTS)
-			pdev_glob[device] = pdev;
+	if (usb_disabled())
+		return 0;
 
-	}
-	return 0;
+	return platform_driver_register(&octeon_usb_driver);
 }
+module_init(octeon_usb_driver_init);
 
-static void __exit octeon_usb_module_cleanup(void)
+static void __exit octeon_usb_driver_exit(void)
 {
-	int i;
+	if (usb_disabled())
+		return;
 
-	for (i = 0; i < MAX_USB_PORTS; i++)
-		if (pdev_glob[i]) {
-			platform_device_unregister(pdev_glob[i]);
-			pdev_glob[i] = NULL;
-		}
-	if (octeon_usb_registered)
-		driver_unregister(&octeon_usb_driver);
+	platform_driver_unregister(&octeon_usb_driver);
 }
+module_exit(octeon_usb_driver_exit);
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Cavium Networks <support@caviumnetworks.com>");
-MODULE_DESCRIPTION("Cavium Networks Octeon USB Host driver.");
-module_init(octeon_usb_module_init);
-module_exit(octeon_usb_module_cleanup);
+MODULE_AUTHOR("Cavium, Inc. <support@cavium.com>");
+MODULE_DESCRIPTION("Cavium Inc. OCTEON USB Host driver.");

commit 3c9740a117d40a74412775b5d3fe2b88a7635a0e
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Nov 5 10:46:02 2013 +0800

    usb: hcd: move controller wakeup setting initialization to individual driver
    
    Individual controller driver has different requirement for wakeup
    setting, so move it from core to itself. In order to align with
    current etting the default wakeup setting is enabled (except for
    chipidea host).
    
    Pass compile test with below commands:
            make O=outout/all allmodconfig
            make -j$CPU_NUM O=outout/all drivers/usb
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index d118952c0a74..47e0a91238a1 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3498,6 +3498,7 @@ static int octeon_usb_driver_probe(struct device *dev)
 		kfree(hcd);
 		return -1;
 	}
+	device_wakeup_enable(hcd->self.controller);
 
 	dev_dbg(dev, "Registered HCD for port %d on irq %d\n", usb_num, irq);
 

commit 5669601d928b1d0af5935dafa340b7446c2f150c
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Oct 10 23:25:36 2013 +0300

    staging: octeon-usb: use list.h for transactions
    
    Use list.h helpers for transactions.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 36e4ee46cb44..d118952c0a74 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -306,8 +306,7 @@ enum cvmx_usb_stage {
  *				 regardless of type. These are linked together
  *				 to form a list of pending requests for a pipe.
  *
- * @prev:		Transaction before this one in the pipe.
- * @next:		Transaction after this one in the pipe.
+ * @node:		List node for transactions in the pipe.
  * @type:		Type of transaction, duplicated of the pipe.
  * @flags:		State flags for this transaction.
  * @buffer:		User's physical buffer address to read/write.
@@ -323,8 +322,7 @@ enum cvmx_usb_stage {
  * @urb:		URB.
  */
 struct cvmx_usb_transaction {
-	struct cvmx_usb_transaction *prev;
-	struct cvmx_usb_transaction *next;
+	struct list_head node;
 	enum cvmx_usb_transfer type;
 	uint64_t buffer;
 	int buffer_length;
@@ -347,8 +345,7 @@ struct cvmx_usb_transaction {
  *
  * @node:		List node for pipe list
  * @next:		Pipe after this one in the list
- * @head:		The first pending transaction
- * @tail:		The last pending transaction
+ * @transactions:	List of pending transactions
  * @interval:		For periodic pipes, the interval between packets in
  *			frames
  * @next_tx_frame:	The next frame this pipe is allowed to transmit on
@@ -370,8 +367,7 @@ struct cvmx_usb_transaction {
  */
 struct cvmx_usb_pipe {
 	struct list_head node;
-	struct cvmx_usb_transaction *head;
-	struct cvmx_usb_transaction *tail;
+	struct list_head transactions;
 	uint64_t interval;
 	uint64_t next_tx_frame;
 	enum cvmx_usb_pipe_flags flags;
@@ -1219,6 +1215,8 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 	pipe->max_packet = max_packet;
 	pipe->transfer_type = transfer_type;
 	pipe->transfer_dir = transfer_dir;
+	INIT_LIST_HEAD(&pipe->transactions);
+
 	/*
 	 * All pipes use interval to rate limit NAK processing. Force an
 	 * interval if one wasn't supplied
@@ -1444,7 +1442,9 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 					     int channel,
 					     struct cvmx_usb_pipe *pipe)
 {
-	struct cvmx_usb_transaction *transaction = pipe->head;
+	struct cvmx_usb_transaction *transaction =
+		list_first_entry(&pipe->transactions, typeof(*transaction),
+				 node);
 	union cvmx_usb_control_header *header =
 		cvmx_phys_to_ptr(transaction->control_header);
 	int bytes_to_transfer = transaction->buffer_length - transaction->actual_bytes;
@@ -1573,7 +1573,9 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 				     int channel,
 				     struct cvmx_usb_pipe *pipe)
 {
-	struct cvmx_usb_transaction *transaction = pipe->head;
+	struct cvmx_usb_transaction *transaction =
+		list_first_entry(&pipe->transactions, typeof(*transaction),
+				 node);
 
 	/* Make sure all writes to the DMA region get flushed */
 	CVMX_SYNCW;
@@ -1872,12 +1874,14 @@ static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(struct cvmx_usb_state *u
 	struct cvmx_usb_pipe *pipe;
 
 	list_for_each_entry(pipe, list, node) {
-		if (!(pipe->flags & __CVMX_USB_PIPE_FLAGS_SCHEDULED) && pipe->head &&
+		struct cvmx_usb_transaction *t =
+			list_first_entry(&pipe->transactions, typeof(*t), node);
+		if (!(pipe->flags & __CVMX_USB_PIPE_FLAGS_SCHEDULED) && t &&
 			(pipe->next_tx_frame <= current_frame) &&
 			((pipe->split_sc_frame == -1) || ((((int)current_frame - (int)pipe->split_sc_frame) & 0x7f) < 0x40)) &&
-			(!usb->active_split || (usb->active_split == pipe->head))) {
+			(!usb->active_split || (usb->active_split == t))) {
 			CVMX_PREFETCH(pipe, 128);
-			CVMX_PREFETCH(pipe->head, 0);
+			CVMX_PREFETCH(t, 0);
 			return pipe;
 		}
 	}
@@ -2104,15 +2108,8 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 	}
 
 	/* Remove the transaction from the pipe list */
-	if (transaction->next)
-		transaction->next->prev = transaction->prev;
-	else
-		pipe->tail = transaction->prev;
-	if (transaction->prev)
-		transaction->prev->next = transaction->next;
-	else
-		pipe->head = transaction->next;
-	if (!pipe->head)
+	list_del(&transaction->node);
+	if (list_empty(&pipe->transactions))
 		list_move_tail(&pipe->node, &usb->idle_pipes);
 	octeon_usb_urb_complete_callback(usb, complete_code, pipe,
 					 transaction,
@@ -2180,24 +2177,19 @@ static struct cvmx_usb_transaction *__cvmx_usb_submit_transaction(struct cvmx_us
 	else
 		transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
 
-	transaction->next = NULL;
-	if (pipe->tail) {
-		transaction->prev = pipe->tail;
-		transaction->prev->next = transaction;
+	if (!list_empty(&pipe->transactions)) {
+		list_add_tail(&transaction->node, &pipe->transactions);
 	} else {
-		if (pipe->next_tx_frame < usb->frame_number)
-			pipe->next_tx_frame = usb->frame_number + pipe->interval -
-				(usb->frame_number - pipe->next_tx_frame) % pipe->interval;
-		transaction->prev = NULL;
-		pipe->head = transaction;
+		list_add_tail(&transaction->node, &pipe->transactions);
 		list_move_tail(&pipe->node,
 			       &usb->active_pipes[pipe->transfer_type]);
-	}
-	pipe->tail = transaction;
 
-	/* We may need to schedule the pipe if this was the head of the pipe */
-	if (!transaction->prev)
+		/*
+		 * We may need to schedule the pipe if this was the head of the
+		 * pipe.
+		 */
 		__cvmx_usb_schedule(usb, 0);
+	}
 
 	return transaction;
 }
@@ -2332,8 +2324,8 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 	 * If the transaction is the HEAD of the queue and scheduled. We need to
 	 * treat it special
 	 */
-	if ((pipe->head == transaction) &&
-		(pipe->flags & __CVMX_USB_PIPE_FLAGS_SCHEDULED)) {
+	if (list_first_entry(&pipe->transactions, typeof(*transaction), node) ==
+	    transaction && (pipe->flags & __CVMX_USB_PIPE_FLAGS_SCHEDULED)) {
 		union cvmx_usbcx_hccharx usbc_hcchar;
 
 		usb->pipe_for_channel[pipe->channel] = NULL;
@@ -2368,9 +2360,11 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 static int cvmx_usb_cancel_all(struct cvmx_usb_state *usb,
 			       struct cvmx_usb_pipe *pipe)
 {
+	struct cvmx_usb_transaction *transaction, *next;
+
 	/* Simply loop through and attempt to cancel each transaction */
-	while (pipe->head) {
-		int result = cvmx_usb_cancel(usb, pipe, pipe->head);
+	list_for_each_entry_safe(transaction, next, &pipe->transactions, node) {
+		int result = cvmx_usb_cancel(usb, pipe, transaction);
 		if (unlikely(result != 0))
 			return result;
 	}
@@ -2391,7 +2385,7 @@ static int cvmx_usb_close_pipe(struct cvmx_usb_state *usb,
 			       struct cvmx_usb_pipe *pipe)
 {
 	/* Fail if the pipe has pending transactions */
-	if (unlikely(pipe->head))
+	if (!list_empty(&pipe->transactions))
 		return -EBUSY;
 
 	list_del(&pipe->node);
@@ -2499,7 +2493,8 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	CVMX_PREFETCH(pipe, 128);
 	if (!pipe)
 		return 0;
-	transaction = pipe->head;
+	transaction = list_first_entry(&pipe->transactions, typeof(*transaction),
+				       node);
 	CVMX_PREFETCH(transaction, 0);
 
 	/*

commit 4a23ee1bd7869c09364916b1ce33804d319a347f
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Oct 10 23:25:35 2013 +0300

    staging: octeon-usb: use list.h for pipes
    
    Use list.h helpers for pipes.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 8e0fcbd173f2..36e4ee46cb44 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -345,7 +345,7 @@ struct cvmx_usb_transaction {
  *			  and some USB device. It contains a list of pending
  *			  request to the device.
  *
- * @prev:		Pipe before this one in the list
+ * @node:		List node for pipe list
  * @next:		Pipe after this one in the list
  * @head:		The first pending transaction
  * @tail:		The last pending transaction
@@ -369,8 +369,7 @@ struct cvmx_usb_transaction {
  *			complete should be sent on
  */
 struct cvmx_usb_pipe {
-	struct cvmx_usb_pipe *prev;
-	struct cvmx_usb_pipe *next;
+	struct list_head node;
 	struct cvmx_usb_transaction *head;
 	struct cvmx_usb_transaction *tail;
 	uint64_t interval;
@@ -390,17 +389,6 @@ struct cvmx_usb_pipe {
 	int8_t split_sc_frame;
 };
 
-/**
- * struct cvmx_usb_pipe_list
- *
- * @head: Head of the list, or NULL if empty.
- * @tail: Tail if the list, or NULL if empty.
- */
-struct cvmx_usb_pipe_list {
-	struct cvmx_usb_pipe *head;
-	struct cvmx_usb_pipe *tail;
-};
-
 struct cvmx_usb_tx_fifo {
 	struct {
 		int channel;
@@ -436,8 +424,8 @@ struct cvmx_usb_state {
 	struct cvmx_usb_pipe *pipe_for_channel[MAX_CHANNELS];
 	int indent;
 	struct cvmx_usb_port_status port_status;
-	struct cvmx_usb_pipe_list idle_pipes;
-	struct cvmx_usb_pipe_list active_pipes[4];
+	struct list_head idle_pipes;
+	struct list_head active_pipes[4];
 	uint64_t frame_number;
 	struct cvmx_usb_transaction *active_split;
 	struct cvmx_usb_tx_fifo periodic;
@@ -629,50 +617,6 @@ static int cvmx_usb_get_num_ports(void)
 	return arch_ports;
 }
 
-/**
- * Add a pipe to the tail of a list
- * @list:   List to add pipe to
- * @pipe:   Pipe to add
- */
-static inline void __cvmx_usb_append_pipe(struct cvmx_usb_pipe_list *list, struct cvmx_usb_pipe *pipe)
-{
-	pipe->next = NULL;
-	pipe->prev = list->tail;
-	if (list->tail)
-		list->tail->next = pipe;
-	else
-		list->head = pipe;
-	list->tail = pipe;
-}
-
-
-/**
- * Remove a pipe from a list
- * @list:   List to remove pipe from
- * @pipe:   Pipe to remove
- */
-static inline void __cvmx_usb_remove_pipe(struct cvmx_usb_pipe_list *list, struct cvmx_usb_pipe *pipe)
-{
-	if (list->head == pipe) {
-		list->head = pipe->next;
-		pipe->next = NULL;
-		if (list->head)
-			list->head->prev = NULL;
-		else
-			list->tail = NULL;
-	} else if (list->tail == pipe) {
-		list->tail = pipe->prev;
-		list->tail->next = NULL;
-		pipe->prev = NULL;
-	} else {
-		pipe->prev->next = pipe->next;
-		pipe->next->prev = pipe->prev;
-		pipe->prev = NULL;
-		pipe->next = NULL;
-	}
-}
-
-
 /**
  * Initialize a USB port for use. This must be called before any
  * other access to the Octeon USB port is made. The port starts
@@ -693,6 +637,7 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
 	union cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;
 	enum cvmx_usb_initialize_flags flags = 0;
+	int i;
 
 	/* At first allow 0-1 for the usb port number */
 	if ((usb_port_number < 0) || (usb_port_number > 1))
@@ -728,6 +673,9 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 
 	/* Initialize the USB state structure */
 	usb->index = usb_port_number;
+	INIT_LIST_HEAD(&usb->idle_pipes);
+	for (i = 0; i < ARRAY_SIZE(usb->active_pipes); i++)
+		INIT_LIST_HEAD(&usb->active_pipes[i]);
 
 	/*
 	 * Power On Reset and PHY Initialization
@@ -1003,11 +951,11 @@ static int cvmx_usb_shutdown(struct cvmx_usb_state *usb)
 	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
 
 	/* Make sure all pipes are closed */
-	if (usb->idle_pipes.head ||
-		usb->active_pipes[CVMX_USB_TRANSFER_ISOCHRONOUS].head ||
-		usb->active_pipes[CVMX_USB_TRANSFER_INTERRUPT].head ||
-		usb->active_pipes[CVMX_USB_TRANSFER_CONTROL].head ||
-		usb->active_pipes[CVMX_USB_TRANSFER_BULK].head)
+	if (!list_empty(&usb->idle_pipes) ||
+	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_ISOCHRONOUS]) ||
+	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_INTERRUPT]) ||
+	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_CONTROL]) ||
+	    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_BULK]))
 		return -EBUSY;
 
 	/* Disable the clocks and put them in power on reset */
@@ -1290,7 +1238,7 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 	pipe->hub_port = hub_port;
 	pipe->pid_toggle = 0;
 	pipe->split_sc_frame = -1;
-	__cvmx_usb_append_pipe(&usb->idle_pipes, pipe);
+	list_add_tail(&pipe->node, &usb->idle_pipes);
 
 	/*
 	 * We don't need to tell the hardware about this pipe yet since
@@ -1919,10 +1867,11 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
  *
  * Returns: Pipe or NULL if none are ready
  */
-static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(struct cvmx_usb_state *usb, struct cvmx_usb_pipe_list *list, uint64_t current_frame)
+static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(struct cvmx_usb_state *usb, struct list_head *list, uint64_t current_frame)
 {
-	struct cvmx_usb_pipe *pipe = list->head;
-	while (pipe) {
+	struct cvmx_usb_pipe *pipe;
+
+	list_for_each_entry(pipe, list, node) {
 		if (!(pipe->flags & __CVMX_USB_PIPE_FLAGS_SCHEDULED) && pipe->head &&
 			(pipe->next_tx_frame <= current_frame) &&
 			((pipe->split_sc_frame == -1) || ((((int)current_frame - (int)pipe->split_sc_frame) & 0x7f) < 0x40)) &&
@@ -1931,7 +1880,6 @@ static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(struct cvmx_usb_state *u
 			CVMX_PREFETCH(pipe->head, 0);
 			return pipe;
 		}
-		pipe = pipe->next;
 	}
 	return NULL;
 }
@@ -1998,13 +1946,11 @@ static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 	 */
 	need_sof = 0;
 	for (ttype = CVMX_USB_TRANSFER_CONTROL; ttype <= CVMX_USB_TRANSFER_INTERRUPT; ttype++) {
-		pipe = usb->active_pipes[ttype].head;
-		while (pipe) {
+		list_for_each_entry(pipe, &usb->active_pipes[ttype], node) {
 			if (pipe->next_tx_frame > usb->frame_number) {
 				need_sof = 1;
 				break;
 			}
-			pipe = pipe->next;
 		}
 	}
 	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, sofmsk, need_sof);
@@ -2166,11 +2112,8 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 		transaction->prev->next = transaction->next;
 	else
 		pipe->head = transaction->next;
-	if (!pipe->head) {
-		__cvmx_usb_remove_pipe(usb->active_pipes + pipe->transfer_type, pipe);
-		__cvmx_usb_append_pipe(&usb->idle_pipes, pipe);
-
-	}
+	if (!pipe->head)
+		list_move_tail(&pipe->node, &usb->idle_pipes);
 	octeon_usb_urb_complete_callback(usb, complete_code, pipe,
 					 transaction,
 					 transaction->actual_bytes,
@@ -2247,8 +2190,8 @@ static struct cvmx_usb_transaction *__cvmx_usb_submit_transaction(struct cvmx_us
 				(usb->frame_number - pipe->next_tx_frame) % pipe->interval;
 		transaction->prev = NULL;
 		pipe->head = transaction;
-		__cvmx_usb_remove_pipe(&usb->idle_pipes, pipe);
-		__cvmx_usb_append_pipe(usb->active_pipes + pipe->transfer_type, pipe);
+		list_move_tail(&pipe->node,
+			       &usb->active_pipes[pipe->transfer_type]);
 	}
 	pipe->tail = transaction;
 
@@ -2451,7 +2394,7 @@ static int cvmx_usb_close_pipe(struct cvmx_usb_state *usb,
 	if (unlikely(pipe->head))
 		return -EBUSY;
 
-	__cvmx_usb_remove_pipe(&usb->idle_pipes, pipe);
+	list_del(&pipe->node);
 	kfree(pipe);
 
 	return 0;

commit f011fefa8a25980bce5f83f49d6524b3910d64aa
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Oct 10 23:25:34 2013 +0300

    staging: octeon-usb: use list_for_each_entry_safe()
    
    Use list_for_each_entry_safe() when deleting all list items.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 632190aa2ee4..8e0fcbd173f2 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3223,13 +3223,14 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 
 static void octeon_usb_urb_dequeue_work(unsigned long arg)
 {
+	struct urb *urb;
+	struct urb *next;
 	unsigned long flags;
 	struct octeon_hcd *priv = (struct octeon_hcd *)arg;
 
 	spin_lock_irqsave(&priv->lock, flags);
 
-	while (!list_empty(&priv->dequeue_list)) {
-		struct urb *urb = container_of(priv->dequeue_list.next, struct urb, urb_list);
+	list_for_each_entry_safe(urb, next, &priv->dequeue_list, urb_list) {
 		list_del_init(&urb->urb_list);
 		cvmx_usb_cancel(&priv->usb, urb->ep->hcpriv, urb->hcpriv);
 	}

commit 244544a1850a47b89f5dca4bb4d20f6800767f4e
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Oct 10 23:25:33 2013 +0300

    staging: octeon-usb: use list_del_init()
    
    Replace list_del() + INIT_LIST_HEAD() with list_del_init().
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 6e72bf0e22e5..632190aa2ee4 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2036,17 +2036,14 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 	urb->actual_length = bytes_transferred;
 	urb->hcpriv = NULL;
 
-	if (!list_empty(&urb->urb_list)) {
+	if (!list_empty(&urb->urb_list))
 		/*
 		 * It is on the dequeue_list, but we are going to call
 		 * usb_hcd_giveback_urb(), so we must clear it from
 		 * the list.  We got to it before the
 		 * octeon_usb_urb_dequeue_work() tasklet did.
 		 */
-		list_del(&urb->urb_list);
-		/* No longer on the dequeue_list. */
-		INIT_LIST_HEAD(&urb->urb_list);
-	}
+		list_del_init(&urb->urb_list);
 
 	/* For Isochronous transactions we need to update the URB packet status
 	   list from data in our private copy */
@@ -3233,9 +3230,7 @@ static void octeon_usb_urb_dequeue_work(unsigned long arg)
 
 	while (!list_empty(&priv->dequeue_list)) {
 		struct urb *urb = container_of(priv->dequeue_list.next, struct urb, urb_list);
-		list_del(&urb->urb_list);
-		/* not enqueued on dequeue_list */
-		INIT_LIST_HEAD(&urb->urb_list);
+		list_del_init(&urb->urb_list);
 		cvmx_usb_cancel(&priv->usb, urb->ep->hcpriv, urb->hcpriv);
 	}
 

commit d2695a8a3de7247a4a034a6bb1ad332261db47d7
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Oct 10 23:25:32 2013 +0300

    staging: octeon-usb: use dynamic allocation for pipes
    
    Use dynamic memory allocation for pipes.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 65b3d4cb61ad..6e72bf0e22e5 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -234,8 +234,6 @@ enum cvmx_usb_initialize_flags {
 /**
  * enum cvmx_usb_pipe_flags - internal flags for a pipe.
  *
- * @__CVMX_USB_PIPE_FLAGS_OPEN:	     Used internally to determine if a pipe is
- *				     open. Do not use.
  * @__CVMX_USB_PIPE_FLAGS_SCHEDULED: Used internally to determine if a pipe is
  *				     actively using hardware. Do not use.
  * @__CVMX_USB_PIPE_FLAGS_NEED_PING: Used internally to determine if a high
@@ -243,7 +241,6 @@ enum cvmx_usb_initialize_flags {
  *				     use.
  */
 enum cvmx_usb_pipe_flags {
-	__CVMX_USB_PIPE_FLAGS_OPEN	= 1 << 16,
 	__CVMX_USB_PIPE_FLAGS_SCHEDULED	= 1 << 17,
 	__CVMX_USB_PIPE_FLAGS_NEED_PING	= 1 << 18,
 };
@@ -254,9 +251,6 @@ enum cvmx_usb_pipe_flags {
 /* Maximum number of times to retry failed transactions */
 #define MAX_RETRIES		3
 
-/* Maximum number of pipes that can be open at once */
-#define MAX_PIPES		32
-
 /* Maximum number of hardware channels supported by the USB block */
 #define MAX_CHANNELS		8
 
@@ -429,7 +423,6 @@ struct cvmx_usb_tx_fifo {
  * pipe:		   Storage for pipes.
  * indent:		   Used by debug output to indent functions.
  * port_status:		   Last port status used for change notification.
- * free_pipes:		   List of all pipes that are currently closed.
  * idle_pipes:		   List of open pipes that have no transactions.
  * active_pipes:	   Active pipes indexed by transfer type.
  * frame_number:	   Increments every SOF interrupt for time keeping.
@@ -441,10 +434,8 @@ struct cvmx_usb_state {
 	int idle_hardware_channels;
 	union cvmx_usbcx_hprt usbcx_hprt;
 	struct cvmx_usb_pipe *pipe_for_channel[MAX_CHANNELS];
-	struct cvmx_usb_pipe pipe[MAX_PIPES];
 	int indent;
 	struct cvmx_usb_port_status port_status;
-	struct cvmx_usb_pipe_list free_pipes;
 	struct cvmx_usb_pipe_list idle_pipes;
 	struct cvmx_usb_pipe_list active_pipes[4];
 	uint64_t frame_number;
@@ -736,13 +727,7 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 	usb->init_flags = flags;
 
 	/* Initialize the USB state structure */
-	{
-		int i;
-		usb->index = usb_port_number;
-
-		for (i = 0; i < MAX_PIPES; i++)
-			__cvmx_usb_append_pipe(&usb->free_pipes, usb->pipe + i);
-	}
+	usb->index = usb_port_number;
 
 	/*
 	 * Power On Reset and PHY Initialization
@@ -1273,12 +1258,9 @@ static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 	if (unlikely((hub_port < 0) || (hub_port > MAX_USB_HUB_PORT)))
 		return NULL;
 
-	/* Find a free pipe */
-	pipe = usb->free_pipes.head;
+	pipe = kzalloc(sizeof(*pipe), GFP_ATOMIC);
 	if (!pipe)
 		return NULL;
-	__cvmx_usb_remove_pipe(&usb->free_pipes, pipe);
-	pipe->flags = __CVMX_USB_PIPE_FLAGS_OPEN;
 	if ((device_speed == CVMX_USB_SPEED_HIGH) &&
 		(transfer_dir == CVMX_USB_DIRECTION_OUT) &&
 		(transfer_type == CVMX_USB_TRANSFER_BULK))
@@ -2237,9 +2219,6 @@ static struct cvmx_usb_transaction *__cvmx_usb_submit_transaction(struct cvmx_us
 {
 	struct cvmx_usb_transaction *transaction;
 
-	/* Fail if the pipe isn't open */
-	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
-		return NULL;
 	if (unlikely(pipe->transfer_type != type))
 		return NULL;
 
@@ -2409,10 +2388,6 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 			   struct cvmx_usb_pipe *pipe,
 			   struct cvmx_usb_transaction *transaction)
 {
-	/* Fail if the pipe isn't open */
-	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
-		return -EINVAL;
-
 	/*
 	 * If the transaction is the HEAD of the queue and scheduled. We need to
 	 * treat it special
@@ -2453,10 +2428,6 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 static int cvmx_usb_cancel_all(struct cvmx_usb_state *usb,
 			       struct cvmx_usb_pipe *pipe)
 {
-	/* Fail if the pipe isn't open */
-	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
-		return -EINVAL;
-
 	/* Simply loop through and attempt to cancel each transaction */
 	while (pipe->head) {
 		int result = cvmx_usb_cancel(usb, pipe, pipe->head);
@@ -2479,17 +2450,12 @@ static int cvmx_usb_cancel_all(struct cvmx_usb_state *usb,
 static int cvmx_usb_close_pipe(struct cvmx_usb_state *usb,
 			       struct cvmx_usb_pipe *pipe)
 {
-	/* Fail if the pipe isn't open */
-	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
-		return -EINVAL;
-
 	/* Fail if the pipe has pending transactions */
 	if (unlikely(pipe->head))
 		return -EBUSY;
 
-	pipe->flags = 0;
 	__cvmx_usb_remove_pipe(&usb->idle_pipes, pipe);
-	__cvmx_usb_append_pipe(&usb->free_pipes, pipe);
+	kfree(pipe);
 
 	return 0;
 }

commit a2dfef06e68321d4b2cc4a6671b318193f2a049f
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Oct 10 23:25:31 2013 +0300

    staging: octeon-usb: use dynamic allocation for transactions
    
    Use dynamic memory allocation for transactions.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index da96461855ea..65b3d4cb61ad 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -257,9 +257,6 @@ enum cvmx_usb_pipe_flags {
 /* Maximum number of pipes that can be open at once */
 #define MAX_PIPES		32
 
-/* Maximum number of outstanding transactions across all pipes */
-#define MAX_TRANSACTIONS	256
-
 /* Maximum number of hardware channels supported by the USB block */
 #define MAX_CHANNELS		8
 
@@ -284,10 +281,6 @@ enum cvmx_usb_pipe_flags {
  */
 #define MAX_TRANSFER_PACKETS	((1<<10)-1)
 
-enum cvmx_usb_transaction_flags {
-	__CVMX_USB_TRANSACTION_FLAGS_IN_USE = 1<<16,
-};
-
 enum {
 	USB_CLOCK_TYPE_REF_12,
 	USB_CLOCK_TYPE_REF_24,
@@ -339,7 +332,6 @@ struct cvmx_usb_transaction {
 	struct cvmx_usb_transaction *prev;
 	struct cvmx_usb_transaction *next;
 	enum cvmx_usb_transfer type;
-	enum cvmx_usb_transaction_flags flags;
 	uint64_t buffer;
 	int buffer_length;
 	uint64_t control_header;
@@ -434,10 +426,7 @@ struct cvmx_usb_tx_fifo {
  * usbcx_hprt:		   Stored port status so we don't need to read a CSR to
  *			   determine splits.
  * pipe_for_channel:	   Map channels to pipes.
- * free_transaction_head:  List of free transactions head.
- * free_transaction_tail:  List of free transactions tail.
  * pipe:		   Storage for pipes.
- * transaction:		   Storage for transactions.
  * indent:		   Used by debug output to indent functions.
  * port_status:		   Last port status used for change notification.
  * free_pipes:		   List of all pipes that are currently closed.
@@ -452,10 +441,7 @@ struct cvmx_usb_state {
 	int idle_hardware_channels;
 	union cvmx_usbcx_hprt usbcx_hprt;
 	struct cvmx_usb_pipe *pipe_for_channel[MAX_CHANNELS];
-	struct cvmx_usb_transaction *free_transaction_head;
-	struct cvmx_usb_transaction *free_transaction_tail;
 	struct cvmx_usb_pipe pipe[MAX_PIPES];
-	struct cvmx_usb_transaction transaction[MAX_TRANSACTIONS];
 	int indent;
 	struct cvmx_usb_port_status port_status;
 	struct cvmx_usb_pipe_list free_pipes;
@@ -652,54 +638,6 @@ static int cvmx_usb_get_num_ports(void)
 	return arch_ports;
 }
 
-
-/**
- * Allocate a usb transaction for use
- *
- * @usb:	 USB device state populated by
- *		 cvmx_usb_initialize().
- *
- * Returns: Transaction or NULL
- */
-static inline struct cvmx_usb_transaction *__cvmx_usb_alloc_transaction(struct cvmx_usb_state *usb)
-{
-	struct cvmx_usb_transaction *t;
-	t = usb->free_transaction_head;
-	if (t) {
-		usb->free_transaction_head = t->next;
-		if (!usb->free_transaction_head)
-			usb->free_transaction_tail = NULL;
-	}
-	if (t) {
-		memset(t, 0, sizeof(*t));
-		t->flags = __CVMX_USB_TRANSACTION_FLAGS_IN_USE;
-	}
-	return t;
-}
-
-
-/**
- * Free a usb transaction
- *
- * @usb:	 USB device state populated by
- *		 cvmx_usb_initialize().
- * @transaction:
- *		 Transaction to free
- */
-static inline void __cvmx_usb_free_transaction(struct cvmx_usb_state *usb,
-					       struct cvmx_usb_transaction *transaction)
-{
-	transaction->flags = 0;
-	transaction->prev = NULL;
-	transaction->next = NULL;
-	if (usb->free_transaction_tail)
-		usb->free_transaction_tail->next = transaction;
-	else
-		usb->free_transaction_head = transaction;
-	usb->free_transaction_tail = transaction;
-}
-
-
 /**
  * Add a pipe to the tail of a list
  * @list:   List to add pipe to
@@ -802,11 +740,6 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		int i;
 		usb->index = usb_port_number;
 
-		/* Initialize the transaction double linked list */
-		usb->free_transaction_head = NULL;
-		usb->free_transaction_tail = NULL;
-		for (i = 0; i < MAX_TRANSACTIONS; i++)
-			__cvmx_usb_free_transaction(usb, usb->transaction + i);
 		for (i = 0; i < MAX_PIPES; i++)
 			__cvmx_usb_append_pipe(&usb->free_pipes, usb->pipe + i);
 	}
@@ -2263,7 +2196,7 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 					 transaction,
 					 transaction->actual_bytes,
 					 transaction->urb);
-	__cvmx_usb_free_transaction(usb, transaction);
+	kfree(transaction);
 done:
 	return;
 }
@@ -2310,7 +2243,7 @@ static struct cvmx_usb_transaction *__cvmx_usb_submit_transaction(struct cvmx_us
 	if (unlikely(pipe->transfer_type != type))
 		return NULL;
 
-	transaction = __cvmx_usb_alloc_transaction(usb);
+	transaction = kzalloc(sizeof(*transaction), GFP_ATOMIC);
 	if (unlikely(!transaction))
 		return NULL;
 
@@ -2480,10 +2413,6 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
 		return -EINVAL;
 
-	/* Fail if this transaction already completed */
-	if (unlikely((transaction->flags & __CVMX_USB_TRANSACTION_FLAGS_IN_USE) == 0))
-		return -EINVAL;
-
 	/*
 	 * If the transaction is the HEAD of the queue and scheduled. We need to
 	 * treat it special

commit f121910396a7a1c123efcf9c6a6971c6c75ec377
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Oct 10 23:25:30 2013 +0300

    staging: octeon-usb: use a single .h file
    
    Merge USBC and USBN register definitions into a single header
    file. Although all HW definitions are purely internal to the driver,
    it's better to keep them separate due to the large size of the file.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 2226c7d6066e..da96461855ea 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -66,8 +66,7 @@
 #include <asm/octeon/cvmx-sysinfo.h>
 #include <asm/octeon/cvmx-helper-board.h>
 
-#include "cvmx-usbcx-defs.h"
-#include "cvmx-usbnx-defs.h"
+#include "octeon-hcd.h"
 
 /**
  * enum cvmx_usb_speed - the possible USB device speeds

commit 7d7bc26b1d80acadf6eacb312b06f8f4005b2173
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Oct 10 23:25:29 2013 +0300

    staging: octeon-usb: CN3xxx: program p_xenbn and p_rclk through p_rtype
    
    Do the clock setup through p_rtype on all OCTEONs. This enables to get
    rid of duplicated register definitions.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index a5c4622fcf03..2226c7d6066e 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -836,13 +836,11 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		 * source at USB_XO. USB_XI should be tied to GND.
 		 * Most Octeon evaluation boards require this setting
 		 */
-		if (OCTEON_IS_MODEL(OCTEON_CN3XXX)) {
-			/* From CN31XX,CN30XX manual */
-			usbn_clk_ctl.cn31xx.p_rclk  = 1;
-			usbn_clk_ctl.cn31xx.p_xenbn = 0;
-		} else if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN50XX))
-			/* From CN56XX,CN50XX manual */
-			usbn_clk_ctl.s.p_rtype = 2;
+		if (OCTEON_IS_MODEL(OCTEON_CN3XXX) ||
+		    OCTEON_IS_MODEL(OCTEON_CN56XX) ||
+		    OCTEON_IS_MODEL(OCTEON_CN50XX))
+			/* From CN56XX,CN50XX,CN31XX,CN30XX manuals */
+			usbn_clk_ctl.s.p_rtype = 2; /* p_rclk=1 & p_xenbn=0 */
 		else
 			/* From CN52XX manual */
 			usbn_clk_ctl.s.p_rtype = 1;
@@ -863,15 +861,11 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 		 * The USB port uses a 12MHz crystal as clock source
 		 * at USB_XO and USB_XI
 		 */
-		if (OCTEON_IS_MODEL(OCTEON_CN3XXX)) {
+		if (OCTEON_IS_MODEL(OCTEON_CN3XXX))
 			/* From CN31XX,CN30XX manual */
-			usbn_clk_ctl.cn31xx.p_rclk  = 1;
-			usbn_clk_ctl.cn31xx.p_xenbn = 1;
-		} else if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN50XX))
-			/* From CN56XX,CN50XX manual */
-			usbn_clk_ctl.s.p_rtype = 0;
+			usbn_clk_ctl.s.p_rtype = 3; /* p_rclk=1 & p_xenbn=1 */
 		else
-			/* From CN52XX manual */
+			/* From CN56XX,CN52XX,CN50XX manuals. */
 			usbn_clk_ctl.s.p_rtype = 0;
 
 		usbn_clk_ctl.s.p_c_sel = 0;

commit 34b70b9e05ba64c71331622b0263964364d5a351
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Oct 10 23:25:28 2013 +0300

    staging: octeon-usb: delete cvmx_usbnx_clk_ctl_cn50xx
    
    Add the missing bits to common clk ctl definition, and we can delete
    duplicated definitions.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 1859c050b918..a5c4622fcf03 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -842,10 +842,10 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 			usbn_clk_ctl.cn31xx.p_xenbn = 0;
 		} else if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN50XX))
 			/* From CN56XX,CN50XX manual */
-			usbn_clk_ctl.cn56xx.p_rtype = 2;
+			usbn_clk_ctl.s.p_rtype = 2;
 		else
 			/* From CN52XX manual */
-			usbn_clk_ctl.cn52xx.p_rtype = 1;
+			usbn_clk_ctl.s.p_rtype = 1;
 
 		switch (flags & CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK) {
 		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ:
@@ -869,10 +869,10 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 			usbn_clk_ctl.cn31xx.p_xenbn = 1;
 		} else if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN50XX))
 			/* From CN56XX,CN50XX manual */
-			usbn_clk_ctl.cn56xx.p_rtype = 0;
+			usbn_clk_ctl.s.p_rtype = 0;
 		else
 			/* From CN52XX manual */
-			usbn_clk_ctl.cn52xx.p_rtype = 0;
+			usbn_clk_ctl.s.p_rtype = 0;
 
 		usbn_clk_ctl.s.p_c_sel = 0;
 	}

commit aa87afe20710dfa71937f945a93e2bfa26a2f1df
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:37 2013 +0300

    staging: octeon-usb: refactor __cvmx_usb_pipe_needs_split
    
    Split a long line and remove redundant parenthesis.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 368c7f78e8cb..1859c050b918 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -602,7 +602,8 @@ static inline void __cvmx_usb_write_csr64(struct cvmx_usb_state *usb,
 static inline int __cvmx_usb_pipe_needs_split(struct cvmx_usb_state *usb,
 					      struct cvmx_usb_pipe *pipe)
 {
-	return ((pipe->device_speed != CVMX_USB_SPEED_HIGH) && (usb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_HIGH));
+	return pipe->device_speed != CVMX_USB_SPEED_HIGH &&
+	       usb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_HIGH;
 }
 
 

commit 3e1674c0937143d0818c81fc37e9499edf1d6f66
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:36 2013 +0300

    staging: octeon-usb: eliminate submit_handle
    
    Eliminate submit_handle, use a direct reference instead.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index b07425c890ac..368c7f78e8cb 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1251,22 +1251,6 @@ static struct cvmx_usb_port_status cvmx_usb_get_status(struct cvmx_usb_state *us
 	return result;
 }
 
-/**
- * Convert a USB transaction into a handle
- *
- * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @transaction:
- *		 Transaction to get handle for
- *
- * Returns: Handle
- */
-static inline int __cvmx_usb_get_submit_handle(struct cvmx_usb_state *usb,
-					       struct cvmx_usb_transaction *transaction)
-{
-	return ((unsigned long)transaction - (unsigned long)usb->transaction) /
-			sizeof(*transaction);
-}
-
 /**
  * Open a virtual pipe between the host and a USB device. A pipe
  * must be opened before data can be transferred between a device
@@ -2131,7 +2115,8 @@ static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
 static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 					     enum cvmx_usb_complete status,
 					     struct cvmx_usb_pipe *pipe,
-					     int submit_handle,
+					     struct cvmx_usb_transaction
+						*transaction,
 					     int bytes_transferred,
 					     struct urb *urb)
 {
@@ -2172,10 +2157,10 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 				urb->iso_frame_desc[i].actual_length = iso_packet[i].length;
 				urb->actual_length += urb->iso_frame_desc[i].actual_length;
 			} else {
-				dev_dbg(dev, "ISOCHRONOUS packet=%d of %d status=%d pipe=%p submit=%d size=%d\n",
+				dev_dbg(dev, "ISOCHRONOUS packet=%d of %d status=%d pipe=%p transaction=%p size=%d\n",
 					i, urb->number_of_packets,
 					iso_packet[i].status, pipe,
-					submit_handle, iso_packet[i].length);
+					transaction, iso_packet[i].length);
 				urb->iso_frame_desc[i].status = -EREMOTEIO;
 			}
 		}
@@ -2193,26 +2178,26 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 			urb->status = -ENOENT;
 		break;
 	case CVMX_USB_COMPLETE_STALL:
-		dev_dbg(dev, "status=stall pipe=%p submit=%d size=%d\n",
-			pipe, submit_handle, bytes_transferred);
+		dev_dbg(dev, "status=stall pipe=%p transaction=%p size=%d\n",
+			pipe, transaction, bytes_transferred);
 		urb->status = -EPIPE;
 		break;
 	case CVMX_USB_COMPLETE_BABBLEERR:
-		dev_dbg(dev, "status=babble pipe=%p submit=%d size=%d\n",
-			pipe, submit_handle, bytes_transferred);
+		dev_dbg(dev, "status=babble pipe=%p transaction=%p size=%d\n",
+			pipe, transaction, bytes_transferred);
 		urb->status = -EPIPE;
 		break;
 	case CVMX_USB_COMPLETE_SHORT:
-		dev_dbg(dev, "status=short pipe=%p submit=%d size=%d\n",
-			pipe, submit_handle, bytes_transferred);
+		dev_dbg(dev, "status=short pipe=%p transaction=%p size=%d\n",
+			pipe, transaction, bytes_transferred);
 		urb->status = -EREMOTEIO;
 		break;
 	case CVMX_USB_COMPLETE_ERROR:
 	case CVMX_USB_COMPLETE_XACTERR:
 	case CVMX_USB_COMPLETE_DATATGLERR:
 	case CVMX_USB_COMPLETE_FRAMEERR:
-		dev_dbg(dev, "status=%d pipe=%p submit=%d size=%d\n",
-			status, pipe, submit_handle, bytes_transferred);
+		dev_dbg(dev, "status=%d pipe=%p transaction=%p size=%d\n",
+			status, pipe, transaction, bytes_transferred);
 		urb->status = -EPROTO;
 		break;
 	}
@@ -2237,8 +2222,6 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 					struct cvmx_usb_transaction *transaction,
 					enum cvmx_usb_complete complete_code)
 {
-	int submit_handle;
-
 	/* If this was a split then clear our split in progress marker */
 	if (usb->active_split == transaction)
 		usb->active_split = NULL;
@@ -2282,9 +2265,8 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 		__cvmx_usb_append_pipe(&usb->idle_pipes, pipe);
 
 	}
-	submit_handle = __cvmx_usb_get_submit_handle(usb, transaction);
 	octeon_usb_urb_complete_callback(usb, complete_code, pipe,
-					 submit_handle,
+					 transaction,
 					 transaction->actual_bytes,
 					 transaction->urb);
 	__cvmx_usb_free_transaction(usb, transaction);
@@ -2313,32 +2295,30 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
  *		    A description of each ISO packet
  * @urb:	    URB for the callback
  *
- * Returns: Submit handle or negative on failure. Matches the result
- *	    in the external API.
+ * Returns: Transaction or NULL on failure.
  */
-static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
-					 struct cvmx_usb_pipe *pipe,
-					 enum cvmx_usb_transfer type,
-					 uint64_t buffer,
-					 int buffer_length,
-					 uint64_t control_header,
-					 int iso_start_frame,
-					 int iso_number_packets,
-					 struct cvmx_usb_iso_packet *iso_packets,
-					 struct urb *urb)
+static struct cvmx_usb_transaction *__cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
+								  struct cvmx_usb_pipe *pipe,
+								  enum cvmx_usb_transfer type,
+								  uint64_t buffer,
+								  int buffer_length,
+								  uint64_t control_header,
+								  int iso_start_frame,
+								  int iso_number_packets,
+								  struct cvmx_usb_iso_packet *iso_packets,
+								  struct urb *urb)
 {
-	int submit_handle;
 	struct cvmx_usb_transaction *transaction;
 
 	/* Fail if the pipe isn't open */
 	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
-		return -EINVAL;
+		return NULL;
 	if (unlikely(pipe->transfer_type != type))
-		return -EINVAL;
+		return NULL;
 
 	transaction = __cvmx_usb_alloc_transaction(usb);
 	if (unlikely(!transaction))
-		return -ENOMEM;
+		return NULL;
 
 	transaction->type = type;
 	transaction->buffer = buffer;
@@ -2369,13 +2349,11 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
 	}
 	pipe->tail = transaction;
 
-	submit_handle = __cvmx_usb_get_submit_handle(usb, transaction);
-
 	/* We may need to schedule the pipe if this was the head of the pipe */
 	if (!transaction->prev)
 		__cvmx_usb_schedule(usb, 0);
 
-	return submit_handle;
+	return transaction;
 }
 
 
@@ -2386,25 +2364,20 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
  * @pipe:	    Handle to the pipe for the transfer.
  * @urb:	    URB.
  *
- * Returns: A submitted transaction handle or negative on
- *	    failure. Negative values are error codes.
+ * Returns: A submitted transaction or NULL on failure.
  */
-static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb,
-				struct cvmx_usb_pipe *pipe,
-				struct urb *urb)
+static struct cvmx_usb_transaction *cvmx_usb_submit_bulk(struct cvmx_usb_state *usb,
+							 struct cvmx_usb_pipe *pipe,
+							 struct urb *urb)
 {
-	int submit_handle;
-
-	submit_handle = __cvmx_usb_submit_transaction(usb, pipe,
-						      CVMX_USB_TRANSFER_BULK,
-						      urb->transfer_dma,
-						      urb->transfer_buffer_length,
-						      0, /* control_header */
-						      0, /* iso_start_frame */
-						      0, /* iso_number_packets */
-						      NULL, /* iso_packets */
-						      urb);
-	return submit_handle;
+	return __cvmx_usb_submit_transaction(usb, pipe, CVMX_USB_TRANSFER_BULK,
+					     urb->transfer_dma,
+					     urb->transfer_buffer_length,
+					     0, /* control_header */
+					     0, /* iso_start_frame */
+					     0, /* iso_number_packets */
+					     NULL, /* iso_packets */
+					     urb);
 }
 
 
@@ -2415,25 +2388,21 @@ static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb,
  * @pipe:	    Handle to the pipe for the transfer.
  * @urb:	    URB returned when the callback is called.
  *
- * Returns: A submitted transaction handle or negative on
- *	    failure. Negative values are error codes.
+ * Returns: A submitted transaction or NULL on failure.
  */
-static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
-				     struct cvmx_usb_pipe *pipe,
-				     struct urb *urb)
+static struct cvmx_usb_transaction *cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
+							      struct cvmx_usb_pipe *pipe,
+							      struct urb *urb)
 {
-	int submit_handle;
-
-	submit_handle = __cvmx_usb_submit_transaction(usb, pipe,
-						      CVMX_USB_TRANSFER_INTERRUPT,
-						      urb->transfer_dma,
-						      urb->transfer_buffer_length,
-						      0, /* control_header */
-						      0, /* iso_start_frame */
-						      0, /* iso_number_packets */
-						      NULL, /* iso_packets */
-						      urb);
-	return submit_handle;
+	return __cvmx_usb_submit_transaction(usb, pipe,
+					     CVMX_USB_TRANSFER_INTERRUPT,
+					     urb->transfer_dma,
+					     urb->transfer_buffer_length,
+					     0, /* control_header */
+					     0, /* iso_start_frame */
+					     0, /* iso_number_packets */
+					     NULL, /* iso_packets */
+					     urb);
 }
 
 
@@ -2444,14 +2413,12 @@ static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
  * @pipe:	    Handle to the pipe for the transfer.
  * @urb:	    URB.
  *
- * Returns: A submitted transaction handle or negative on
- *	    failure. Negative values are error codes.
+ * Returns: A submitted transaction or NULL on failure.
  */
-static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
-				   struct cvmx_usb_pipe *pipe,
-				   struct urb *urb)
+static struct cvmx_usb_transaction *cvmx_usb_submit_control(struct cvmx_usb_state *usb,
+							    struct cvmx_usb_pipe *pipe,
+							    struct urb *urb)
 {
-	int submit_handle;
 	int buffer_length = urb->transfer_buffer_length;
 	uint64_t control_header = urb->setup_dma;
 	union cvmx_usb_control_header *header =
@@ -2460,16 +2427,14 @@ static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
 	if ((header->s.request_type & 0x80) == 0)
 		buffer_length = le16_to_cpu(header->s.length);
 
-	submit_handle = __cvmx_usb_submit_transaction(usb, pipe,
-						      CVMX_USB_TRANSFER_CONTROL,
-						      urb->transfer_dma,
-						      buffer_length,
-						      control_header,
-						      0, /* iso_start_frame */
-						      0, /* iso_number_packets */
-						      NULL, /* iso_packets */
-						      urb);
-	return submit_handle;
+	return __cvmx_usb_submit_transaction(usb, pipe,
+					     CVMX_USB_TRANSFER_CONTROL,
+					     urb->transfer_dma, buffer_length,
+					     control_header,
+					     0, /* iso_start_frame */
+					     0, /* iso_number_packets */
+					     NULL, /* iso_packets */
+					     urb);
 }
 
 
@@ -2480,27 +2445,23 @@ static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
  * @pipe:	    Handle to the pipe for the transfer.
  * @urb:	    URB returned when the callback is called.
  *
- * Returns: A submitted transaction handle or negative on
- *	    failure. Negative values are error codes.
+ * Returns: A submitted transaction or NULL on failure.
  */
-static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *usb,
-				       struct cvmx_usb_pipe *pipe,
-				       struct urb *urb)
+static struct cvmx_usb_transaction *cvmx_usb_submit_isochronous(struct cvmx_usb_state *usb,
+								struct cvmx_usb_pipe *pipe,
+								struct urb *urb)
 {
-	int submit_handle;
 	struct cvmx_usb_iso_packet *packets;
 
 	packets = (struct cvmx_usb_iso_packet *) urb->setup_packet;
-	submit_handle = __cvmx_usb_submit_transaction(usb, pipe,
-						      CVMX_USB_TRANSFER_ISOCHRONOUS,
-						      urb->transfer_dma,
-						      urb->transfer_buffer_length,
-						      0, /* control_header */
-						      urb->start_frame,
-						      urb->number_of_packets,
-						      packets,
-						      urb);
-	return submit_handle;
+	return __cvmx_usb_submit_transaction(usb, pipe,
+					     CVMX_USB_TRANSFER_ISOCHRONOUS,
+					     urb->transfer_dma,
+					     urb->transfer_buffer_length,
+					     0, /* control_header */
+					     urb->start_frame,
+					     urb->number_of_packets,
+					     packets, urb);
 }
 
 
@@ -2513,27 +2474,18 @@ static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *usb,
  *
  * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @pipe:	 Pipe to cancel requests in.
- * @submit_handle:
- *		 Handle to transaction to cancel, returned by the submit
- *		 function.
+ * @transaction: Transaction to cancel, returned by the submit function.
  *
  * Returns: 0 or a negative error code.
  */
 static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
 			   struct cvmx_usb_pipe *pipe,
-			   int submit_handle)
+			   struct cvmx_usb_transaction *transaction)
 {
-	struct cvmx_usb_transaction *transaction;
-
-	if (unlikely((submit_handle < 0) || (submit_handle >= MAX_TRANSACTIONS)))
-		return -EINVAL;
-
 	/* Fail if the pipe isn't open */
 	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
 		return -EINVAL;
 
-	transaction = usb->transaction + submit_handle;
-
 	/* Fail if this transaction already completed */
 	if (unlikely((transaction->flags & __CVMX_USB_TRANSACTION_FLAGS_IN_USE) == 0))
 		return -EINVAL;
@@ -2584,8 +2536,7 @@ static int cvmx_usb_cancel_all(struct cvmx_usb_state *usb,
 
 	/* Simply loop through and attempt to cancel each transaction */
 	while (pipe->head) {
-		int result = cvmx_usb_cancel(usb, pipe,
-			__cvmx_usb_get_submit_handle(usb, pipe->head));
+		int result = cvmx_usb_cancel(usb, pipe, pipe->head);
 		if (unlikely(result != 0))
 			return result;
 	}
@@ -3231,7 +3182,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	struct device *dev = hcd->self.controller;
-	int submit_handle = -1;
+	struct cvmx_usb_transaction *transaction = NULL;
 	struct cvmx_usb_pipe *pipe;
 	unsigned long flags;
 	struct cvmx_usb_iso_packet *iso_packet;
@@ -3346,13 +3297,13 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 			 * this saves us a bunch of logic.
 			 */
 			urb->setup_packet = (char *)iso_packet;
-			submit_handle = cvmx_usb_submit_isochronous(&priv->usb,
-								    pipe, urb);
+			transaction = cvmx_usb_submit_isochronous(&priv->usb,
+								  pipe, urb);
 			/*
 			 * If submit failed we need to free our private packet
 			 * list.
 			 */
-			if (submit_handle < 0) {
+			if (!transaction) {
 				urb->setup_packet = NULL;
 				kfree(iso_packet);
 			}
@@ -3361,26 +3312,25 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	case PIPE_INTERRUPT:
 		dev_dbg(dev, "Submit interrupt to %d.%d\n",
 			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
-		submit_handle = cvmx_usb_submit_interrupt(&priv->usb, pipe,
-							  urb);
+		transaction = cvmx_usb_submit_interrupt(&priv->usb, pipe, urb);
 		break;
 	case PIPE_CONTROL:
 		dev_dbg(dev, "Submit control to %d.%d\n",
 			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
-		submit_handle = cvmx_usb_submit_control(&priv->usb, pipe, urb);
+		transaction = cvmx_usb_submit_control(&priv->usb, pipe, urb);
 		break;
 	case PIPE_BULK:
 		dev_dbg(dev, "Submit bulk to %d.%d\n",
 			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
-		submit_handle = cvmx_usb_submit_bulk(&priv->usb, pipe, urb);
+		transaction = cvmx_usb_submit_bulk(&priv->usb, pipe, urb);
 		break;
 	}
-	if (submit_handle < 0) {
+	if (!transaction) {
 		spin_unlock_irqrestore(&priv->lock, flags);
 		dev_dbg(dev, "Failed to submit\n");
 		return -ENOMEM;
 	}
-	urb->hcpriv = (void *)(long)submit_handle;
+	urb->hcpriv = transaction;
 	spin_unlock_irqrestore(&priv->lock, flags);
 	return 0;
 }
@@ -3393,13 +3343,11 @@ static void octeon_usb_urb_dequeue_work(unsigned long arg)
 	spin_lock_irqsave(&priv->lock, flags);
 
 	while (!list_empty(&priv->dequeue_list)) {
-		int submit_handle;
 		struct urb *urb = container_of(priv->dequeue_list.next, struct urb, urb_list);
 		list_del(&urb->urb_list);
 		/* not enqueued on dequeue_list */
 		INIT_LIST_HEAD(&urb->urb_list);
-		submit_handle = (long)urb->hcpriv;
-		cvmx_usb_cancel(&priv->usb, urb->ep->hcpriv, submit_handle);
+		cvmx_usb_cancel(&priv->usb, urb->ep->hcpriv, urb->hcpriv);
 	}
 
 	spin_unlock_irqrestore(&priv->lock, flags);

commit 60f815078f8e2040546c3a4c5c9eb62b07f417cb
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:35 2013 +0300

    staging: octeon-usb: eliminate pipe_handle
    
    Eliminate pipe_handle, use a direct reference instead.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index afaf991b22d7..b07425c890ac 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1267,22 +1267,6 @@ static inline int __cvmx_usb_get_submit_handle(struct cvmx_usb_state *usb,
 			sizeof(*transaction);
 }
 
-
-/**
- * Convert a USB pipe into a handle
- *
- * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @pipe:	 Pipe to get handle for
- *
- * Returns: Handle
- */
-static inline int __cvmx_usb_get_pipe_handle(struct cvmx_usb_state *usb,
-					     struct cvmx_usb_pipe *pipe)
-{
-	return ((unsigned long)pipe - (unsigned long)usb->pipe) / sizeof(*pipe);
-}
-
-
 /**
  * Open a virtual pipe between the host and a USB device. A pipe
  * must be opened before data can be transferred between a device
@@ -1333,50 +1317,55 @@ static inline int __cvmx_usb_get_pipe_handle(struct cvmx_usb_state *usb,
  *		     this is only used for full/low speed
  *		     devices behind a high speed hub.
  *
- * Returns: A non negative value is a pipe handle. Negative
- *	    values are error codes.
+ * Returns: A non-NULL value is a pipe. NULL means an error.
  */
-static int cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
-			      int device_addr, int endpoint_num,
-			      enum cvmx_usb_speed device_speed, int max_packet,
-			      enum cvmx_usb_transfer transfer_type,
-			      enum cvmx_usb_direction transfer_dir,
-			      int interval, int multi_count,
-			      int hub_device_addr, int hub_port)
+static struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
+						int device_addr, int
+						endpoint_num,
+						enum cvmx_usb_speed
+							device_speed,
+						int max_packet,
+						enum cvmx_usb_transfer
+							transfer_type,
+						enum cvmx_usb_direction
+							transfer_dir,
+						int interval, int multi_count,
+						int hub_device_addr,
+						int hub_port)
 {
 	struct cvmx_usb_pipe *pipe;
 
 	if (unlikely((device_addr < 0) || (device_addr > MAX_USB_ADDRESS)))
-		return -EINVAL;
+		return NULL;
 	if (unlikely((endpoint_num < 0) || (endpoint_num > MAX_USB_ENDPOINT)))
-		return -EINVAL;
+		return NULL;
 	if (unlikely(device_speed > CVMX_USB_SPEED_LOW))
-		return -EINVAL;
+		return NULL;
 	if (unlikely((max_packet <= 0) || (max_packet > 1024)))
-		return -EINVAL;
+		return NULL;
 	if (unlikely(transfer_type > CVMX_USB_TRANSFER_INTERRUPT))
-		return -EINVAL;
+		return NULL;
 	if (unlikely((transfer_dir != CVMX_USB_DIRECTION_OUT) &&
 		(transfer_dir != CVMX_USB_DIRECTION_IN)))
-		return -EINVAL;
+		return NULL;
 	if (unlikely(interval < 0))
-		return -EINVAL;
+		return NULL;
 	if (unlikely((transfer_type == CVMX_USB_TRANSFER_CONTROL) && interval))
-		return -EINVAL;
+		return NULL;
 	if (unlikely(multi_count < 0))
-		return -EINVAL;
+		return NULL;
 	if (unlikely((device_speed != CVMX_USB_SPEED_HIGH) &&
 		(multi_count != 0)))
-		return -EINVAL;
+		return NULL;
 	if (unlikely((hub_device_addr < 0) || (hub_device_addr > MAX_USB_ADDRESS)))
-		return -EINVAL;
+		return NULL;
 	if (unlikely((hub_port < 0) || (hub_port > MAX_USB_HUB_PORT)))
-		return -EINVAL;
+		return NULL;
 
 	/* Find a free pipe */
 	pipe = usb->free_pipes.head;
 	if (!pipe)
-		return -ENOMEM;
+		return NULL;
 	__cvmx_usb_remove_pipe(&usb->free_pipes, pipe);
 	pipe->flags = __CVMX_USB_PIPE_FLAGS_OPEN;
 	if ((device_speed == CVMX_USB_SPEED_HIGH) &&
@@ -1415,7 +1404,7 @@ static int cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 	 * it doesn't have any submitted requests
 	 */
 
-	return __cvmx_usb_get_pipe_handle(usb, pipe);
+	return pipe;
 }
 
 
@@ -2141,7 +2130,7 @@ static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
 
 static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 					     enum cvmx_usb_complete status,
-					     int pipe_handle,
+					     struct cvmx_usb_pipe *pipe,
 					     int submit_handle,
 					     int bytes_transferred,
 					     struct urb *urb)
@@ -2183,9 +2172,9 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 				urb->iso_frame_desc[i].actual_length = iso_packet[i].length;
 				urb->actual_length += urb->iso_frame_desc[i].actual_length;
 			} else {
-				dev_dbg(dev, "ISOCHRONOUS packet=%d of %d status=%d pipe=%d submit=%d size=%d\n",
+				dev_dbg(dev, "ISOCHRONOUS packet=%d of %d status=%d pipe=%p submit=%d size=%d\n",
 					i, urb->number_of_packets,
-					iso_packet[i].status, pipe_handle,
+					iso_packet[i].status, pipe,
 					submit_handle, iso_packet[i].length);
 				urb->iso_frame_desc[i].status = -EREMOTEIO;
 			}
@@ -2204,26 +2193,26 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 			urb->status = -ENOENT;
 		break;
 	case CVMX_USB_COMPLETE_STALL:
-		dev_dbg(dev, "status=stall pipe=%d submit=%d size=%d\n",
-			pipe_handle, submit_handle, bytes_transferred);
+		dev_dbg(dev, "status=stall pipe=%p submit=%d size=%d\n",
+			pipe, submit_handle, bytes_transferred);
 		urb->status = -EPIPE;
 		break;
 	case CVMX_USB_COMPLETE_BABBLEERR:
-		dev_dbg(dev, "status=babble pipe=%d submit=%d size=%d\n",
-			pipe_handle, submit_handle, bytes_transferred);
+		dev_dbg(dev, "status=babble pipe=%p submit=%d size=%d\n",
+			pipe, submit_handle, bytes_transferred);
 		urb->status = -EPIPE;
 		break;
 	case CVMX_USB_COMPLETE_SHORT:
-		dev_dbg(dev, "status=short pipe=%d submit=%d size=%d\n",
-			pipe_handle, submit_handle, bytes_transferred);
+		dev_dbg(dev, "status=short pipe=%p submit=%d size=%d\n",
+			pipe, submit_handle, bytes_transferred);
 		urb->status = -EREMOTEIO;
 		break;
 	case CVMX_USB_COMPLETE_ERROR:
 	case CVMX_USB_COMPLETE_XACTERR:
 	case CVMX_USB_COMPLETE_DATATGLERR:
 	case CVMX_USB_COMPLETE_FRAMEERR:
-		dev_dbg(dev, "status=%d pipe=%d submit=%d size=%d\n",
-			status, pipe_handle, submit_handle, bytes_transferred);
+		dev_dbg(dev, "status=%d pipe=%p submit=%d size=%d\n",
+			status, pipe, submit_handle, bytes_transferred);
 		urb->status = -EPROTO;
 		break;
 	}
@@ -2248,7 +2237,6 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 					struct cvmx_usb_transaction *transaction,
 					enum cvmx_usb_complete complete_code)
 {
-	int pipe_handle;
 	int submit_handle;
 
 	/* If this was a split then clear our split in progress marker */
@@ -2294,9 +2282,8 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 		__cvmx_usb_append_pipe(&usb->idle_pipes, pipe);
 
 	}
-	pipe_handle = __cvmx_usb_get_pipe_handle(usb, pipe);
 	submit_handle = __cvmx_usb_get_submit_handle(usb, transaction);
-	octeon_usb_urb_complete_callback(usb, complete_code, pipe_handle,
+	octeon_usb_urb_complete_callback(usb, complete_code, pipe,
 					 submit_handle,
 					 transaction->actual_bytes,
 					 transaction->urb);
@@ -2311,8 +2298,7 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
  * of transactions.
  *
  * @usb:
- * @pipe_handle:
- *		    Which pipe to submit to. Will be validated in this function.
+ * @pipe:	    Which pipe to submit to.
  * @type:	    Transaction type
  * @buffer:	    User buffer for the transaction
  * @buffer_length:
@@ -2331,7 +2317,7 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
  *	    in the external API.
  */
 static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
-					 int pipe_handle,
+					 struct cvmx_usb_pipe *pipe,
 					 enum cvmx_usb_transfer type,
 					 uint64_t buffer,
 					 int buffer_length,
@@ -2343,10 +2329,7 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
 {
 	int submit_handle;
 	struct cvmx_usb_transaction *transaction;
-	struct cvmx_usb_pipe *pipe = usb->pipe + pipe_handle;
 
-	if (unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
-		return -EINVAL;
 	/* Fail if the pipe isn't open */
 	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
 		return -EINVAL;
@@ -2400,19 +2383,19 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
  * Call to submit a USB Bulk transfer to a pipe.
  *
  * @usb:	    USB device state populated by cvmx_usb_initialize().
- * @pipe_handle:
- *		    Handle to the pipe for the transfer.
+ * @pipe:	    Handle to the pipe for the transfer.
  * @urb:	    URB.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
-static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb, int pipe_handle,
+static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb,
+				struct cvmx_usb_pipe *pipe,
 				struct urb *urb)
 {
 	int submit_handle;
 
-	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle,
+	submit_handle = __cvmx_usb_submit_transaction(usb, pipe,
 						      CVMX_USB_TRANSFER_BULK,
 						      urb->transfer_dma,
 						      urb->transfer_buffer_length,
@@ -2429,19 +2412,19 @@ static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb, int pipe_handle,
  * Call to submit a USB Interrupt transfer to a pipe.
  *
  * @usb:	    USB device state populated by cvmx_usb_initialize().
- * @pipe_handle:
- *		    Handle to the pipe for the transfer.
+ * @pipe:	    Handle to the pipe for the transfer.
  * @urb:	    URB returned when the callback is called.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
 static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
-				     int pipe_handle, struct urb *urb)
+				     struct cvmx_usb_pipe *pipe,
+				     struct urb *urb)
 {
 	int submit_handle;
 
-	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle,
+	submit_handle = __cvmx_usb_submit_transaction(usb, pipe,
 						      CVMX_USB_TRANSFER_INTERRUPT,
 						      urb->transfer_dma,
 						      urb->transfer_buffer_length,
@@ -2458,14 +2441,14 @@ static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
  * Call to submit a USB Control transfer to a pipe.
  *
  * @usb:	    USB device state populated by cvmx_usb_initialize().
- * @pipe_handle:
- *		    Handle to the pipe for the transfer.
+ * @pipe:	    Handle to the pipe for the transfer.
  * @urb:	    URB.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
-static int cvmx_usb_submit_control(struct cvmx_usb_state *usb, int pipe_handle,
+static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
+				   struct cvmx_usb_pipe *pipe,
 				   struct urb *urb)
 {
 	int submit_handle;
@@ -2474,11 +2457,10 @@ static int cvmx_usb_submit_control(struct cvmx_usb_state *usb, int pipe_handle,
 	union cvmx_usb_control_header *header =
 		cvmx_phys_to_ptr(control_header);
 
-	/* Pipe handle checking is done later in a common place */
 	if ((header->s.request_type & 0x80) == 0)
 		buffer_length = le16_to_cpu(header->s.length);
 
-	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle,
+	submit_handle = __cvmx_usb_submit_transaction(usb, pipe,
 						      CVMX_USB_TRANSFER_CONTROL,
 						      urb->transfer_dma,
 						      buffer_length,
@@ -2495,21 +2477,21 @@ static int cvmx_usb_submit_control(struct cvmx_usb_state *usb, int pipe_handle,
  * Call to submit a USB Isochronous transfer to a pipe.
  *
  * @usb:	    USB device state populated by cvmx_usb_initialize().
- * @pipe_handle:
- *		    Handle to the pipe for the transfer.
+ * @pipe:	    Handle to the pipe for the transfer.
  * @urb:	    URB returned when the callback is called.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
 static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *usb,
-				       int pipe_handle, struct urb *urb)
+				       struct cvmx_usb_pipe *pipe,
+				       struct urb *urb)
 {
 	int submit_handle;
 	struct cvmx_usb_iso_packet *packets;
 
 	packets = (struct cvmx_usb_iso_packet *) urb->setup_packet;
-	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle,
+	submit_handle = __cvmx_usb_submit_transaction(usb, pipe,
 						      CVMX_USB_TRANSFER_ISOCHRONOUS,
 						      urb->transfer_dma,
 						      urb->transfer_buffer_length,
@@ -2530,22 +2512,19 @@ static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *usb,
  * associated callback.
  *
  * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @pipe_handle:
- *		 Pipe handle to cancel requests in.
+ * @pipe:	 Pipe to cancel requests in.
  * @submit_handle:
  *		 Handle to transaction to cancel, returned by the submit
  *		 function.
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_cancel(struct cvmx_usb_state *usb, int pipe_handle,
+static int cvmx_usb_cancel(struct cvmx_usb_state *usb,
+			   struct cvmx_usb_pipe *pipe,
 			   int submit_handle)
 {
 	struct cvmx_usb_transaction *transaction;
-	struct cvmx_usb_pipe *pipe = usb->pipe + pipe_handle;
 
-	if (unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
-		return -EINVAL;
 	if (unlikely((submit_handle < 0) || (submit_handle >= MAX_TRANSACTIONS)))
 		return -EINVAL;
 
@@ -2592,25 +2571,20 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *usb, int pipe_handle,
  * does is call cvmx_usb_cancel() in a loop.
  *
  * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @pipe_handle:
- *		 Pipe handle to cancel requests in.
+ * @pipe:	 Pipe to cancel requests in.
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_cancel_all(struct cvmx_usb_state *usb, int pipe_handle)
+static int cvmx_usb_cancel_all(struct cvmx_usb_state *usb,
+			       struct cvmx_usb_pipe *pipe)
 {
-	struct cvmx_usb_pipe *pipe = usb->pipe + pipe_handle;
-
-	if (unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
-		return -EINVAL;
-
 	/* Fail if the pipe isn't open */
 	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
 		return -EINVAL;
 
 	/* Simply loop through and attempt to cancel each transaction */
 	while (pipe->head) {
-		int result = cvmx_usb_cancel(usb, pipe_handle,
+		int result = cvmx_usb_cancel(usb, pipe,
 			__cvmx_usb_get_submit_handle(usb, pipe->head));
 		if (unlikely(result != 0))
 			return result;
@@ -2623,19 +2597,14 @@ static int cvmx_usb_cancel_all(struct cvmx_usb_state *usb, int pipe_handle)
  * Close a pipe created with cvmx_usb_open_pipe().
  *
  * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @pipe_handle:
- *		 Pipe handle to close.
+ * @pipe:	 Pipe to close.
  *
  * Returns: 0 or a negative error code. EBUSY is returned if the pipe has
  *	    outstanding transfers.
  */
-static int cvmx_usb_close_pipe(struct cvmx_usb_state *usb, int pipe_handle)
+static int cvmx_usb_close_pipe(struct cvmx_usb_state *usb,
+			       struct cvmx_usb_pipe *pipe)
 {
-	struct cvmx_usb_pipe *pipe = usb->pipe + pipe_handle;
-
-	if (unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
-		return -EINVAL;
-
 	/* Fail if the pipe isn't open */
 	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
 		return -EINVAL;
@@ -3263,7 +3232,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	struct device *dev = hcd->self.controller;
 	int submit_handle = -1;
-	int pipe_handle;
+	struct cvmx_usb_pipe *pipe;
 	unsigned long flags;
 	struct cvmx_usb_iso_packet *iso_packet;
 	struct usb_host_endpoint *ep = urb->ep;
@@ -3332,25 +3301,24 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 				dev = dev->parent;
 			}
 		}
-		pipe_handle = cvmx_usb_open_pipe(&priv->usb,
-						 usb_pipedevice(urb->pipe),
-						 usb_pipeendpoint(urb->pipe),
-						 speed,
-						 le16_to_cpu(ep->desc.wMaxPacketSize) & 0x7ff,
-						 transfer_type,
-						 usb_pipein(urb->pipe) ? CVMX_USB_DIRECTION_IN : CVMX_USB_DIRECTION_OUT,
-						 urb->interval,
-						 (le16_to_cpu(ep->desc.wMaxPacketSize) >> 11) & 0x3,
-						 split_device,
-						 split_port);
-		if (pipe_handle < 0) {
+		pipe = cvmx_usb_open_pipe(&priv->usb, usb_pipedevice(urb->pipe),
+					  usb_pipeendpoint(urb->pipe), speed,
+					  le16_to_cpu(ep->desc.wMaxPacketSize) & 0x7ff,
+					  transfer_type,
+					  usb_pipein(urb->pipe) ?
+						CVMX_USB_DIRECTION_IN :
+						CVMX_USB_DIRECTION_OUT,
+					  urb->interval,
+					  (le16_to_cpu(ep->desc.wMaxPacketSize) >> 11) & 0x3,
+					  split_device, split_port);
+		if (!pipe) {
 			spin_unlock_irqrestore(&priv->lock, flags);
 			dev_dbg(dev, "Failed to create pipe\n");
 			return -ENOMEM;
 		}
-		ep->hcpriv = (void *)(long)pipe_handle;
+		ep->hcpriv = pipe;
 	} else {
-		pipe_handle = (long)ep->hcpriv;
+		pipe = ep->hcpriv;
 	}
 
 	switch (usb_pipetype(urb->pipe)) {
@@ -3379,8 +3347,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 			 */
 			urb->setup_packet = (char *)iso_packet;
 			submit_handle = cvmx_usb_submit_isochronous(&priv->usb,
-								    pipe_handle,
-								    urb);
+								    pipe, urb);
 			/*
 			 * If submit failed we need to free our private packet
 			 * list.
@@ -3394,20 +3361,18 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	case PIPE_INTERRUPT:
 		dev_dbg(dev, "Submit interrupt to %d.%d\n",
 			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
-		submit_handle = cvmx_usb_submit_interrupt(&priv->usb,
-							  pipe_handle, urb);
+		submit_handle = cvmx_usb_submit_interrupt(&priv->usb, pipe,
+							  urb);
 		break;
 	case PIPE_CONTROL:
 		dev_dbg(dev, "Submit control to %d.%d\n",
 			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
-		submit_handle = cvmx_usb_submit_control(&priv->usb, pipe_handle,
-							urb);
+		submit_handle = cvmx_usb_submit_control(&priv->usb, pipe, urb);
 		break;
 	case PIPE_BULK:
 		dev_dbg(dev, "Submit bulk to %d.%d\n",
 			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
-		submit_handle = cvmx_usb_submit_bulk(&priv->usb, pipe_handle,
-						     urb);
+		submit_handle = cvmx_usb_submit_bulk(&priv->usb, pipe, urb);
 		break;
 	}
 	if (submit_handle < 0) {
@@ -3428,15 +3393,13 @@ static void octeon_usb_urb_dequeue_work(unsigned long arg)
 	spin_lock_irqsave(&priv->lock, flags);
 
 	while (!list_empty(&priv->dequeue_list)) {
-		int pipe_handle;
 		int submit_handle;
 		struct urb *urb = container_of(priv->dequeue_list.next, struct urb, urb_list);
 		list_del(&urb->urb_list);
 		/* not enqueued on dequeue_list */
 		INIT_LIST_HEAD(&urb->urb_list);
-		pipe_handle = (long)urb->ep->hcpriv;
 		submit_handle = (long)urb->hcpriv;
-		cvmx_usb_cancel(&priv->usb, pipe_handle, submit_handle);
+		cvmx_usb_cancel(&priv->usb, urb->ep->hcpriv, submit_handle);
 	}
 
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -3468,12 +3431,12 @@ static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_end
 
 	if (ep->hcpriv) {
 		struct octeon_hcd *priv = hcd_to_octeon(hcd);
-		int pipe_handle = (long)ep->hcpriv;
+		struct cvmx_usb_pipe *pipe = ep->hcpriv;
 		unsigned long flags;
 		spin_lock_irqsave(&priv->lock, flags);
-		cvmx_usb_cancel_all(&priv->usb, pipe_handle);
-		if (cvmx_usb_close_pipe(&priv->usb, pipe_handle))
-			dev_dbg(dev, "Closing pipe %d failed\n", pipe_handle);
+		cvmx_usb_cancel_all(&priv->usb, pipe);
+		if (cvmx_usb_close_pipe(&priv->usb, pipe))
+			dev_dbg(dev, "Closing pipe %p failed\n", pipe);
 		spin_unlock_irqrestore(&priv->lock, flags);
 		ep->hcpriv = NULL;
 	}

commit be44063df5b1eb1d10066c9d88c514d49411748b
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:34 2013 +0300

    staging: octeon-usb: clean up hcpriv usage
    
    Use ep->hcpriv for pipe handle and urb->hcpriv for submit handle,
    instead of packing both into the same field.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 0a448aead872..afaf991b22d7 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -3348,9 +3348,9 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 			dev_dbg(dev, "Failed to create pipe\n");
 			return -ENOMEM;
 		}
-		ep->hcpriv = (void *)(0x10000L + pipe_handle);
+		ep->hcpriv = (void *)(long)pipe_handle;
 	} else {
-		pipe_handle = 0xffff & (long)ep->hcpriv;
+		pipe_handle = (long)ep->hcpriv;
 	}
 
 	switch (usb_pipetype(urb->pipe)) {
@@ -3415,7 +3415,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		dev_dbg(dev, "Failed to submit\n");
 		return -ENOMEM;
 	}
-	urb->hcpriv = (void *)(long)(((submit_handle & 0xffff) << 16) | pipe_handle);
+	urb->hcpriv = (void *)(long)submit_handle;
 	spin_unlock_irqrestore(&priv->lock, flags);
 	return 0;
 }
@@ -3434,8 +3434,8 @@ static void octeon_usb_urb_dequeue_work(unsigned long arg)
 		list_del(&urb->urb_list);
 		/* not enqueued on dequeue_list */
 		INIT_LIST_HEAD(&urb->urb_list);
-		pipe_handle = 0xffff & (long)urb->hcpriv;
-		submit_handle = ((long)urb->hcpriv) >> 16;
+		pipe_handle = (long)urb->ep->hcpriv;
+		submit_handle = (long)urb->hcpriv;
 		cvmx_usb_cancel(&priv->usb, pipe_handle, submit_handle);
 	}
 
@@ -3468,7 +3468,7 @@ static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_end
 
 	if (ep->hcpriv) {
 		struct octeon_hcd *priv = hcd_to_octeon(hcd);
-		int pipe_handle = 0xffff & (long)ep->hcpriv;
+		int pipe_handle = (long)ep->hcpriv;
 		unsigned long flags;
 		spin_lock_irqsave(&priv->lock, flags);
 		cvmx_usb_cancel_all(&priv->usb, pipe_handle);

commit e16b5e3f14365c29f84e2fa5ab4780e58a6736f1
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:33 2013 +0300

    staging: octeon-usb: cvmx_usb_submit_control: get params from urb
    
    Get the transfer parameters from urb.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 14062a0e8ebb..0a448aead872 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2497,57 +2497,25 @@ static int cvmx_usb_submit_control(struct cvmx_usb_state *usb, int pipe_handle,
  * @usb:	    USB device state populated by cvmx_usb_initialize().
  * @pipe_handle:
  *		    Handle to the pipe for the transfer.
- * @start_frame:
- *		    Number of frames into the future to schedule
- *		    this transaction.
- * @number_packets:
- *		    Number of sequential packets to transfer.
- *		    "packets" is a pointer to an array of this
- *		    many packet structures.
- * @packets:	    Description of each transfer packet as
- *		    defined by struct cvmx_usb_iso_packet. The array
- *		    pointed to here must stay valid until the
- *		    complete callback is called.
- * @buffer:	    Physical address of the data buffer in
- *		    memory. Note that this is NOT A POINTER, but
- *		    the full 64bit physical address of the
- *		    buffer. This may be zero if buffer_length is
- *		    zero.
- * @buffer_length:
- *		    Length of buffer in bytes.
  * @urb:	    URB returned when the callback is called.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
 static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *usb,
-				       int pipe_handle, int start_frame,
-				       int number_packets, struct
-				       cvmx_usb_iso_packet packets[],
-				       uint64_t buffer, int buffer_length,
-				       struct urb *urb)
+				       int pipe_handle, struct urb *urb)
 {
 	int submit_handle;
+	struct cvmx_usb_iso_packet *packets;
 
-	/* Pipe handle checking is done later in a common place */
-	if (unlikely(start_frame < 0))
-		return -EINVAL;
-	if (unlikely(number_packets < 1))
-		return -EINVAL;
-	if (unlikely(!packets))
-		return -EINVAL;
-	if (unlikely(!buffer))
-		return -EINVAL;
-	if (unlikely(buffer_length < 0))
-		return -EINVAL;
-
+	packets = (struct cvmx_usb_iso_packet *) urb->setup_packet;
 	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle,
 						      CVMX_USB_TRANSFER_ISOCHRONOUS,
-						      buffer,
-						      buffer_length,
+						      urb->transfer_dma,
+						      urb->transfer_buffer_length,
 						      0, /* control_header */
-						      start_frame,
-						      number_packets,
+						      urb->start_frame,
+						      urb->number_of_packets,
 						      packets,
 						      urb);
 	return submit_handle;
@@ -3410,13 +3378,9 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 			 * this saves us a bunch of logic.
 			 */
 			urb->setup_packet = (char *)iso_packet;
-			submit_handle = cvmx_usb_submit_isochronous(&priv->usb, pipe_handle,
-							urb->start_frame,
-							urb->number_of_packets,
-							iso_packet,
-							urb->transfer_dma,
-							urb->transfer_buffer_length,
-							urb);
+			submit_handle = cvmx_usb_submit_isochronous(&priv->usb,
+								    pipe_handle,
+								    urb);
 			/*
 			 * If submit failed we need to free our private packet
 			 * list.

commit 9fdbb6964b80eb1bb385a8ef3cbbbff0d1c91193
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:32 2013 +0300

    staging: octeon-usb: cvmx_usb_submit_interrupt: get params from urb
    
    Get the transfer parameters from urb.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 27f73db9f964..14062a0e8ebb 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2431,34 +2431,20 @@ static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb, int pipe_handle,
  * @usb:	    USB device state populated by cvmx_usb_initialize().
  * @pipe_handle:
  *		    Handle to the pipe for the transfer.
- * @buffer:	    Physical address of the data buffer in
- *		    memory. Note that this is NOT A POINTER, but
- *		    the full 64bit physical address of the
- *		    buffer. This may be zero if buffer_length is
- *		    zero.
- * @buffer_length:
- *		    Length of buffer in bytes.
  * @urb:	    URB returned when the callback is called.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
 static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
-				     int pipe_handle, uint64_t buffer,
-				     int buffer_length, struct urb *urb)
+				     int pipe_handle, struct urb *urb)
 {
 	int submit_handle;
 
-	/* Pipe handle checking is done later in a common place */
-	if (unlikely(!buffer))
-		return -EINVAL;
-	if (unlikely(buffer_length < 0))
-		return -EINVAL;
-
 	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle,
 						      CVMX_USB_TRANSFER_INTERRUPT,
-						      buffer,
-						      buffer_length,
+						      urb->transfer_dma,
+						      urb->transfer_buffer_length,
 						      0, /* control_header */
 						      0, /* iso_start_frame */
 						      0, /* iso_number_packets */
@@ -3444,10 +3430,8 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	case PIPE_INTERRUPT:
 		dev_dbg(dev, "Submit interrupt to %d.%d\n",
 			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
-		submit_handle = cvmx_usb_submit_interrupt(&priv->usb, pipe_handle,
-					      urb->transfer_dma,
-					      urb->transfer_buffer_length,
-					      urb);
+		submit_handle = cvmx_usb_submit_interrupt(&priv->usb,
+							  pipe_handle, urb);
 		break;
 	case PIPE_CONTROL:
 		dev_dbg(dev, "Submit control to %d.%d\n",

commit 2ae09e872197f5f5ce3976c4c2c98bd7352746d0
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:31 2013 +0300

    staging: octeon-usb: cvmx_usb_submit_control: get params from urb
    
    Get the transfer parameters from urb.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 255503938a1a..27f73db9f964 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2474,45 +2474,27 @@ static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
  * @usb:	    USB device state populated by cvmx_usb_initialize().
  * @pipe_handle:
  *		    Handle to the pipe for the transfer.
- * @control_header:
- *		    USB 8 byte control header physical address.
- *		    Note that this is NOT A POINTER, but the
- *		    full 64bit physical address of the buffer.
- * @buffer:	    Physical address of the data buffer in
- *		    memory. Note that this is NOT A POINTER, but
- *		    the full 64bit physical address of the
- *		    buffer. This may be zero if buffer_length is
- *		    zero.
- * @buffer_length:
- *		    Length of buffer in bytes.
- * @urb:	    URB returned when the callback is called.
+ * @urb:	    URB.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
-static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
-				   int pipe_handle, uint64_t control_header,
-				   uint64_t buffer, int buffer_length,
+static int cvmx_usb_submit_control(struct cvmx_usb_state *usb, int pipe_handle,
 				   struct urb *urb)
 {
 	int submit_handle;
+	int buffer_length = urb->transfer_buffer_length;
+	uint64_t control_header = urb->setup_dma;
 	union cvmx_usb_control_header *header =
 		cvmx_phys_to_ptr(control_header);
 
 	/* Pipe handle checking is done later in a common place */
-	if (unlikely(!control_header))
-		return -EINVAL;
-	/* Some drivers send a buffer with a zero length. God only knows why */
-	if (unlikely(buffer && (buffer_length < 0)))
-		return -EINVAL;
-	if (unlikely(!buffer && (buffer_length != 0)))
-		return -EINVAL;
 	if ((header->s.request_type & 0x80) == 0)
 		buffer_length = le16_to_cpu(header->s.length);
 
 	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle,
 						      CVMX_USB_TRANSFER_CONTROL,
-						      buffer,
+						      urb->transfer_dma,
 						      buffer_length,
 						      control_header,
 						      0, /* iso_start_frame */
@@ -3471,10 +3453,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		dev_dbg(dev, "Submit control to %d.%d\n",
 			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
 		submit_handle = cvmx_usb_submit_control(&priv->usb, pipe_handle,
-					    urb->setup_dma,
-					    urb->transfer_dma,
-					    urb->transfer_buffer_length,
-					    urb);
+							urb);
 		break;
 	case PIPE_BULK:
 		dev_dbg(dev, "Submit bulk to %d.%d\n",

commit 9ccca707183f2b425842db6624dd7ba6c7484762
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:30 2013 +0300

    staging: octeon-usb: cvmx_usb_submit_bulk: get params from urb
    
    Get the transfer parameters from urb.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 9ae8c1d4e980..255503938a1a 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -2402,34 +2402,20 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
  * @usb:	    USB device state populated by cvmx_usb_initialize().
  * @pipe_handle:
  *		    Handle to the pipe for the transfer.
- * @buffer:	    Physical address of the data buffer in
- *		    memory. Note that this is NOT A POINTER, but
- *		    the full 64bit physical address of the
- *		    buffer. This may be zero if buffer_length is
- *		    zero.
- * @buffer_length:
- *		    Length of buffer in bytes.
- * @urb:	    URB returned when the callback is called.
+ * @urb:	    URB.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
 static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb, int pipe_handle,
-				uint64_t buffer, int buffer_length,
 				struct urb *urb)
 {
 	int submit_handle;
 
-	/* Pipe handle checking is done later in a common place */
-	if (unlikely(!buffer))
-		return -EINVAL;
-	if (unlikely(buffer_length < 0))
-		return -EINVAL;
-
 	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle,
 						      CVMX_USB_TRANSFER_BULK,
-						      buffer,
-						      buffer_length,
+						      urb->transfer_dma,
+						      urb->transfer_buffer_length,
 						      0, /* control_header */
 						      0, /* iso_start_frame */
 						      0, /* iso_number_packets */
@@ -3494,9 +3480,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		dev_dbg(dev, "Submit bulk to %d.%d\n",
 			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
 		submit_handle = cvmx_usb_submit_bulk(&priv->usb, pipe_handle,
-					 urb->transfer_dma,
-					 urb->transfer_buffer_length,
-					 urb);
+						     urb);
 		break;
 	}
 	if (submit_handle < 0) {

commit 0cce1004c10d7ecf46a94773aca930529d5b72b3
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:29 2013 +0300

    staging: octeon-usb: replace generic transfer callback data with urb
    
    URB is always passed, so we can use strong typing here.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 25d6e3ce84ca..9ae8c1d4e980 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -334,7 +334,7 @@ enum cvmx_usb_stage {
  * @iso_packets:	For ISO transactions, the sub packets in the request.
  * @actual_bytes:	Actual bytes transfer for this transaction.
  * @stage:		For control transactions, the current stage.
- * @callback_data:	User's data.
+ * @urb:		URB.
  */
 struct cvmx_usb_transaction {
 	struct cvmx_usb_transaction *prev;
@@ -352,7 +352,7 @@ struct cvmx_usb_transaction {
 	int retries;
 	int actual_bytes;
 	enum cvmx_usb_stage stage;
-	void *callback_data;
+	struct urb *urb;
 };
 
 /**
@@ -2144,12 +2144,11 @@ static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 					     int pipe_handle,
 					     int submit_handle,
 					     int bytes_transferred,
-					     void *user_data)
+					     struct urb *urb)
 {
 	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
 	struct usb_hcd *hcd = octeon_to_hcd(priv);
 	struct device *dev = hcd->self.controller;
-	struct urb *urb = user_data;
 
 	urb->actual_length = bytes_transferred;
 	urb->hcpriv = NULL;
@@ -2300,7 +2299,7 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 	octeon_usb_urb_complete_callback(usb, complete_code, pipe_handle,
 					 submit_handle,
 					 transaction->actual_bytes,
-					 transaction->callback_data);
+					 transaction->urb);
 	__cvmx_usb_free_transaction(usb, transaction);
 done:
 	return;
@@ -2326,7 +2325,7 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
  *		    For ISO, the number of packet in the transaction.
  * @iso_packets:
  *		    A description of each ISO packet
- * @user_data:	    User's data for the callback
+ * @urb:	    URB for the callback
  *
  * Returns: Submit handle or negative on failure. Matches the result
  *	    in the external API.
@@ -2340,7 +2339,7 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
 					 int iso_start_frame,
 					 int iso_number_packets,
 					 struct cvmx_usb_iso_packet *iso_packets,
-					 void *user_data)
+					 struct urb *urb)
 {
 	int submit_handle;
 	struct cvmx_usb_transaction *transaction;
@@ -2366,7 +2365,7 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
 	transaction->iso_start_frame = iso_start_frame;
 	transaction->iso_number_packets = iso_number_packets;
 	transaction->iso_packets = iso_packets;
-	transaction->callback_data = user_data;
+	transaction->urb = urb;
 	if (transaction->type == CVMX_USB_TRANSFER_CONTROL)
 		transaction->stage = CVMX_USB_STAGE_SETUP;
 	else
@@ -2410,15 +2409,14 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
  *		    zero.
  * @buffer_length:
  *		    Length of buffer in bytes.
- * @user_data:	    User supplied data returned when the
- *		    callback is called.
+ * @urb:	    URB returned when the callback is called.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
 static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb, int pipe_handle,
 				uint64_t buffer, int buffer_length,
-				void *user_data)
+				struct urb *urb)
 {
 	int submit_handle;
 
@@ -2436,7 +2434,7 @@ static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb, int pipe_handle,
 						      0, /* iso_start_frame */
 						      0, /* iso_number_packets */
 						      NULL, /* iso_packets */
-						      user_data);
+						      urb);
 	return submit_handle;
 }
 
@@ -2454,15 +2452,14 @@ static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb, int pipe_handle,
  *		    zero.
  * @buffer_length:
  *		    Length of buffer in bytes.
- * @user_data:	    User supplied data returned when the
- *		    callback is called.
+ * @urb:	    URB returned when the callback is called.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
 static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
 				     int pipe_handle, uint64_t buffer,
-				     int buffer_length, void *user_data)
+				     int buffer_length, struct urb *urb)
 {
 	int submit_handle;
 
@@ -2480,7 +2477,7 @@ static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
 						      0, /* iso_start_frame */
 						      0, /* iso_number_packets */
 						      NULL, /* iso_packets */
-						      user_data);
+						      urb);
 	return submit_handle;
 }
 
@@ -2502,8 +2499,7 @@ static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
  *		    zero.
  * @buffer_length:
  *		    Length of buffer in bytes.
- * @user_data:	    User supplied data returned when the
- *		    callback is called.
+ * @urb:	    URB returned when the callback is called.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
@@ -2511,7 +2507,7 @@ static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
 static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
 				   int pipe_handle, uint64_t control_header,
 				   uint64_t buffer, int buffer_length,
-				   void *user_data)
+				   struct urb *urb)
 {
 	int submit_handle;
 	union cvmx_usb_control_header *header =
@@ -2536,7 +2532,7 @@ static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
 						      0, /* iso_start_frame */
 						      0, /* iso_number_packets */
 						      NULL, /* iso_packets */
-						      user_data);
+						      urb);
 	return submit_handle;
 }
 
@@ -2565,8 +2561,7 @@ static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
  *		    zero.
  * @buffer_length:
  *		    Length of buffer in bytes.
- * @user_data:	    User supplied data returned when the
- *		    callback is called.
+ * @urb:	    URB returned when the callback is called.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
@@ -2576,7 +2571,7 @@ static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *usb,
 				       int number_packets, struct
 				       cvmx_usb_iso_packet packets[],
 				       uint64_t buffer, int buffer_length,
-				       void *user_data)
+				       struct urb *urb)
 {
 	int submit_handle;
 
@@ -2600,7 +2595,7 @@ static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *usb,
 						      start_frame,
 						      number_packets,
 						      packets,
-						      user_data);
+						      urb);
 	return submit_handle;
 }
 

commit 75ee5124871070fc4085de7ad94565cfa423960b
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:28 2013 +0300

    staging: octeon-usb: call transfer completion callback directly
    
    The callback is always the same, we can just call it directly.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 47d0585537c2..25d6e3ce84ca 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -204,48 +204,6 @@ struct cvmx_usb_iso_packet {
 	enum cvmx_usb_complete status;
 };
 
-/**
- * enum cvmx_usb_callback - possible callback reasons for the USB API
- *
- * @CVMX_USB_CALLBACK_TRANSFER_COMPLETE: A callback of this type is called when
- *					 a submitted transfer completes. The
- *					 completion callback will be called even
- *					 if the transfer fails or is canceled.
- *					 The status parameter will contain
- *					 details of why he callback was called.
- * @__CVMX_USB_CALLBACK_END:		 Do not use. Used internally for array
- *					 bounds.
- */
-enum cvmx_usb_callback {
-	CVMX_USB_CALLBACK_TRANSFER_COMPLETE,
-	__CVMX_USB_CALLBACK_END
-};
-
-struct cvmx_usb_state;
-
-/**
- * USB callback functions are always of the following type.
- * The parameters are as follows:
- *      - usb = USB device state populated by cvmx_usb_initialize().
- *      - reason = The enum cvmx_usb_callback used to register
- *        the callback.
- *      - status = The enum cvmx_usb_complete representing the
- *        status code of a transaction.
- *      - pipe_handle = The Pipe that caused this callback, or
- *        -1 if this callback wasn't associated with a pipe.
- *      - submit_handle = Transfer submit handle causing this
- *        callback, or -1 if this callback wasn't associated
- *        with a transfer.
- *      - Actual number of bytes transfer.
- *      - user_data = The user pointer supplied to the
- *        function cvmx_usb_submit().
- */
-typedef void (*cvmx_usb_callback_func_t)(struct cvmx_usb_state *usb,
-                                         enum cvmx_usb_callback reason,
-                                         enum cvmx_usb_complete status,
-                                         int pipe_handle, int submit_handle,
-                                         int bytes_transferred, void *user_data);
-
 /**
  * enum cvmx_usb_initialize_flags - flags used by the initialization function
  *
@@ -376,7 +334,6 @@ enum cvmx_usb_stage {
  * @iso_packets:	For ISO transactions, the sub packets in the request.
  * @actual_bytes:	Actual bytes transfer for this transaction.
  * @stage:		For control transactions, the current stage.
- * @callback:		User's callback function when complete.
  * @callback_data:	User's data.
  */
 struct cvmx_usb_transaction {
@@ -395,7 +352,6 @@ struct cvmx_usb_transaction {
 	int retries;
 	int actual_bytes;
 	enum cvmx_usb_stage stage;
-	cvmx_usb_callback_func_t callback;
 	void *callback_data;
 };
 
@@ -2173,51 +2129,110 @@ static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 	return;
 }
 
+static inline struct octeon_hcd *cvmx_usb_to_octeon(struct cvmx_usb_state *p)
+{
+	return container_of(p, struct octeon_hcd, usb);
+}
 
-/**
- * Call a user's callback for a specific reason.
- *
- * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @pipe:	 Pipe the callback is for or NULL
- * @transaction:
- *		 Transaction the callback is for or NULL
- * @reason:	 Reason this callback is being called
- * @complete_code:
- *		 Completion code for the transaction, if any
- */
-static void __cvmx_usb_perform_callback(struct cvmx_usb_state *usb,
-					struct cvmx_usb_pipe *pipe,
-					struct cvmx_usb_transaction *transaction,
-					enum cvmx_usb_callback reason,
-					enum cvmx_usb_complete complete_code)
+static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
 {
-	cvmx_usb_callback_func_t callback = NULL;
-	void *user_data;
-	int submit_handle = -1;
-	int pipe_handle = -1;
-	int bytes_transferred = 0;
-
-	if (pipe)
-		pipe_handle = __cvmx_usb_get_pipe_handle(usb, pipe);
-
-	if (transaction) {
-		submit_handle = __cvmx_usb_get_submit_handle(usb, transaction);
-		bytes_transferred = transaction->actual_bytes;
-		/* Transactions are allowed to override the default callback */
-		if ((reason == CVMX_USB_CALLBACK_TRANSFER_COMPLETE) && transaction->callback) {
-			callback = transaction->callback;
-			user_data = transaction->callback_data;
-		}
+	return container_of((void *)p, struct usb_hcd, hcd_priv);
+}
+
+static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
+					     enum cvmx_usb_complete status,
+					     int pipe_handle,
+					     int submit_handle,
+					     int bytes_transferred,
+					     void *user_data)
+{
+	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
+	struct usb_hcd *hcd = octeon_to_hcd(priv);
+	struct device *dev = hcd->self.controller;
+	struct urb *urb = user_data;
+
+	urb->actual_length = bytes_transferred;
+	urb->hcpriv = NULL;
+
+	if (!list_empty(&urb->urb_list)) {
+		/*
+		 * It is on the dequeue_list, but we are going to call
+		 * usb_hcd_giveback_urb(), so we must clear it from
+		 * the list.  We got to it before the
+		 * octeon_usb_urb_dequeue_work() tasklet did.
+		 */
+		list_del(&urb->urb_list);
+		/* No longer on the dequeue_list. */
+		INIT_LIST_HEAD(&urb->urb_list);
 	}
 
-	if (!callback)
-		return;
+	/* For Isochronous transactions we need to update the URB packet status
+	   list from data in our private copy */
+	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
+		int i;
+		/*
+		 * The pointer to the private list is stored in the setup_packet
+		 * field.
+		 */
+		struct cvmx_usb_iso_packet *iso_packet =
+			(struct cvmx_usb_iso_packet *) urb->setup_packet;
+		/* Recalculate the transfer size by adding up each packet */
+		urb->actual_length = 0;
+		for (i = 0; i < urb->number_of_packets; i++) {
+			if (iso_packet[i].status == CVMX_USB_COMPLETE_SUCCESS) {
+				urb->iso_frame_desc[i].status = 0;
+				urb->iso_frame_desc[i].actual_length = iso_packet[i].length;
+				urb->actual_length += urb->iso_frame_desc[i].actual_length;
+			} else {
+				dev_dbg(dev, "ISOCHRONOUS packet=%d of %d status=%d pipe=%d submit=%d size=%d\n",
+					i, urb->number_of_packets,
+					iso_packet[i].status, pipe_handle,
+					submit_handle, iso_packet[i].length);
+				urb->iso_frame_desc[i].status = -EREMOTEIO;
+			}
+		}
+		/* Free the private list now that we don't need it anymore */
+		kfree(iso_packet);
+		urb->setup_packet = NULL;
+	}
 
-	callback(usb, reason, complete_code, pipe_handle, submit_handle,
-		 bytes_transferred, user_data);
+	switch (status) {
+	case CVMX_USB_COMPLETE_SUCCESS:
+		urb->status = 0;
+		break;
+	case CVMX_USB_COMPLETE_CANCEL:
+		if (urb->status == 0)
+			urb->status = -ENOENT;
+		break;
+	case CVMX_USB_COMPLETE_STALL:
+		dev_dbg(dev, "status=stall pipe=%d submit=%d size=%d\n",
+			pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EPIPE;
+		break;
+	case CVMX_USB_COMPLETE_BABBLEERR:
+		dev_dbg(dev, "status=babble pipe=%d submit=%d size=%d\n",
+			pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EPIPE;
+		break;
+	case CVMX_USB_COMPLETE_SHORT:
+		dev_dbg(dev, "status=short pipe=%d submit=%d size=%d\n",
+			pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EREMOTEIO;
+		break;
+	case CVMX_USB_COMPLETE_ERROR:
+	case CVMX_USB_COMPLETE_XACTERR:
+	case CVMX_USB_COMPLETE_DATATGLERR:
+	case CVMX_USB_COMPLETE_FRAMEERR:
+		dev_dbg(dev, "status=%d pipe=%d submit=%d size=%d\n",
+			status, pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EPROTO;
+		break;
+	}
+	spin_unlock(&priv->lock);
+	usb_hcd_giveback_urb(octeon_to_hcd(priv), urb, urb->status);
+	spin_lock(&priv->lock);
 }
 
-
 /**
  * Signal the completion of a transaction and free it. The
  * transaction will be removed from the pipe transaction list.
@@ -2234,6 +2249,9 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 					struct cvmx_usb_transaction *transaction,
 					enum cvmx_usb_complete complete_code)
 {
+	int pipe_handle;
+	int submit_handle;
+
 	/* If this was a split then clear our split in progress marker */
 	if (usb->active_split == transaction)
 		usb->active_split = NULL;
@@ -2277,9 +2295,12 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 		__cvmx_usb_append_pipe(&usb->idle_pipes, pipe);
 
 	}
-	__cvmx_usb_perform_callback(usb, pipe, transaction,
-				    CVMX_USB_CALLBACK_TRANSFER_COMPLETE,
-				    complete_code);
+	pipe_handle = __cvmx_usb_get_pipe_handle(usb, pipe);
+	submit_handle = __cvmx_usb_get_submit_handle(usb, transaction);
+	octeon_usb_urb_complete_callback(usb, complete_code, pipe_handle,
+					 submit_handle,
+					 transaction->actual_bytes,
+					 transaction->callback_data);
 	__cvmx_usb_free_transaction(usb, transaction);
 done:
 	return;
@@ -2305,7 +2326,6 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
  *		    For ISO, the number of packet in the transaction.
  * @iso_packets:
  *		    A description of each ISO packet
- * @callback:	    User callback to call when the transaction completes
  * @user_data:	    User's data for the callback
  *
  * Returns: Submit handle or negative on failure. Matches the result
@@ -2320,7 +2340,6 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
 					 int iso_start_frame,
 					 int iso_number_packets,
 					 struct cvmx_usb_iso_packet *iso_packets,
-					 cvmx_usb_callback_func_t callback,
 					 void *user_data)
 {
 	int submit_handle;
@@ -2347,7 +2366,6 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
 	transaction->iso_start_frame = iso_start_frame;
 	transaction->iso_number_packets = iso_number_packets;
 	transaction->iso_packets = iso_packets;
-	transaction->callback = callback;
 	transaction->callback_data = user_data;
 	if (transaction->type == CVMX_USB_TRANSFER_CONTROL)
 		transaction->stage = CVMX_USB_STAGE_SETUP;
@@ -2392,23 +2410,14 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
  *		    zero.
  * @buffer_length:
  *		    Length of buffer in bytes.
- * @callback:	    Function to call when this transaction
- *		    completes. If the return value of this
- *		    function isn't an error, then this function
- *		    is guaranteed to be called when the
- *		    transaction completes. If this parameter is
- *		    NULL, then there is no way to know when a transaction
- *		    completes.
  * @user_data:	    User supplied data returned when the
- *		    callback is called. This is only used if
- *		    callback in not NULL.
+ *		    callback is called.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
 static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb, int pipe_handle,
 				uint64_t buffer, int buffer_length,
-				cvmx_usb_callback_func_t callback,
 				void *user_data)
 {
 	int submit_handle;
@@ -2427,7 +2436,6 @@ static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb, int pipe_handle,
 						      0, /* iso_start_frame */
 						      0, /* iso_number_packets */
 						      NULL, /* iso_packets */
-						      callback,
 						      user_data);
 	return submit_handle;
 }
@@ -2446,25 +2454,15 @@ static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb, int pipe_handle,
  *		    zero.
  * @buffer_length:
  *		    Length of buffer in bytes.
- * @callback:	    Function to call when this transaction
- *		    completes. If the return value of this
- *		    function isn't an error, then this function
- *		    is guaranteed to be called when the
- *		    transaction completes. If this parameter is
- *		    NULL, then there is no way to know when a transaction
- *		    completes.
  * @user_data:	    User supplied data returned when the
- *		    callback is called. This is only used if
- *		    callback in not NULL.
+ *		    callback is called.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
 static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
 				     int pipe_handle, uint64_t buffer,
-				     int buffer_length,
-				     cvmx_usb_callback_func_t callback,
-				     void *user_data)
+				     int buffer_length, void *user_data)
 {
 	int submit_handle;
 
@@ -2482,7 +2480,6 @@ static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
 						      0, /* iso_start_frame */
 						      0, /* iso_number_packets */
 						      NULL, /* iso_packets */
-						      callback,
 						      user_data);
 	return submit_handle;
 }
@@ -2505,16 +2502,8 @@ static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
  *		    zero.
  * @buffer_length:
  *		    Length of buffer in bytes.
- * @callback:	    Function to call when this transaction
- *		    completes. If the return value of this
- *		    function isn't an error, then this function
- *		    is guaranteed to be called when the
- *		    transaction completes. If this parameter is
- *		    NULL, then there is no way to know when a transaction
- *		    completes.
  * @user_data:	    User supplied data returned when the
- *		    callback is called. This is only used if
- *		    callback in not NULL.
+ *		    callback is called.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
@@ -2522,7 +2511,6 @@ static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
 static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
 				   int pipe_handle, uint64_t control_header,
 				   uint64_t buffer, int buffer_length,
-				   cvmx_usb_callback_func_t callback,
 				   void *user_data)
 {
 	int submit_handle;
@@ -2548,7 +2536,6 @@ static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
 						      0, /* iso_start_frame */
 						      0, /* iso_number_packets */
 						      NULL, /* iso_packets */
-						      callback,
 						      user_data);
 	return submit_handle;
 }
@@ -2578,16 +2565,8 @@ static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
  *		    zero.
  * @buffer_length:
  *		    Length of buffer in bytes.
- * @callback:	    Function to call when this transaction
- *		    completes. If the return value of this
- *		    function isn't an error, then this function
- *		    is guaranteed to be called when the
- *		    transaction completes. If this parameter is
- *		    NULL, then there is no way to know when a transaction
- *		    completes.
  * @user_data:	    User supplied data returned when the
- *		    callback is called. This is only used if
- *		    callback in not NULL.
+ *		    callback is called.
  *
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
@@ -2597,7 +2576,6 @@ static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *usb,
 				       int number_packets, struct
 				       cvmx_usb_iso_packet packets[],
 				       uint64_t buffer, int buffer_length,
-				       cvmx_usb_callback_func_t callback,
 				       void *user_data)
 {
 	int submit_handle;
@@ -2622,7 +2600,6 @@ static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *usb,
 						      start_frame,
 						      number_packets,
 						      packets,
-						      callback,
 						      user_data);
 	return submit_handle;
 }
@@ -3217,16 +3194,6 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	return 0;
 }
 
-static inline struct octeon_hcd *cvmx_usb_to_octeon(struct cvmx_usb_state *p)
-{
-	return container_of(p, struct octeon_hcd, usb);
-}
-
-static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
-{
-	return container_of((void *)p, struct usb_hcd, hcd_priv);
-}
-
 static void octeon_usb_port_callback(struct cvmx_usb_state *usb)
 {
 	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
@@ -3372,101 +3339,6 @@ static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
 	return cvmx_usb_get_frame_number(&priv->usb);
 }
 
-static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
-					     enum cvmx_usb_callback reason,
-					     enum cvmx_usb_complete status,
-					     int pipe_handle,
-					     int submit_handle,
-					     int bytes_transferred,
-					     void *user_data)
-{
-	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
-	struct usb_hcd *hcd = octeon_to_hcd(priv);
-	struct device *dev = hcd->self.controller;
-	struct urb *urb = user_data;
-
-	urb->actual_length = bytes_transferred;
-	urb->hcpriv = NULL;
-
-	if (!list_empty(&urb->urb_list)) {
-		/*
-		 * It is on the dequeue_list, but we are going to call
-		 * usb_hcd_giveback_urb(), so we must clear it from
-		 * the list.  We got to it before the
-		 * octeon_usb_urb_dequeue_work() tasklet did.
-		 */
-		list_del(&urb->urb_list);
-		/* No longer on the dequeue_list. */
-		INIT_LIST_HEAD(&urb->urb_list);
-	}
-
-	/* For Isochronous transactions we need to update the URB packet status
-	   list from data in our private copy */
-	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
-		int i;
-		/*
-		 * The pointer to the private list is stored in the setup_packet
-		 * field.
-		 */
-		struct cvmx_usb_iso_packet *iso_packet =
-			(struct cvmx_usb_iso_packet *) urb->setup_packet;
-		/* Recalculate the transfer size by adding up each packet */
-		urb->actual_length = 0;
-		for (i = 0; i < urb->number_of_packets; i++) {
-			if (iso_packet[i].status == CVMX_USB_COMPLETE_SUCCESS) {
-				urb->iso_frame_desc[i].status = 0;
-				urb->iso_frame_desc[i].actual_length = iso_packet[i].length;
-				urb->actual_length += urb->iso_frame_desc[i].actual_length;
-			} else {
-				dev_dbg(dev, "ISOCHRONOUS packet=%d of %d status=%d pipe=%d submit=%d size=%d\n",
-					i, urb->number_of_packets,
-					iso_packet[i].status, pipe_handle,
-					submit_handle, iso_packet[i].length);
-				urb->iso_frame_desc[i].status = -EREMOTEIO;
-			}
-		}
-		/* Free the private list now that we don't need it anymore */
-		kfree(iso_packet);
-		urb->setup_packet = NULL;
-	}
-
-	switch (status) {
-	case CVMX_USB_COMPLETE_SUCCESS:
-		urb->status = 0;
-		break;
-	case CVMX_USB_COMPLETE_CANCEL:
-		if (urb->status == 0)
-			urb->status = -ENOENT;
-		break;
-	case CVMX_USB_COMPLETE_STALL:
-		dev_dbg(dev, "status=stall pipe=%d submit=%d size=%d\n",
-			pipe_handle, submit_handle, bytes_transferred);
-		urb->status = -EPIPE;
-		break;
-	case CVMX_USB_COMPLETE_BABBLEERR:
-		dev_dbg(dev, "status=babble pipe=%d submit=%d size=%d\n",
-			pipe_handle, submit_handle, bytes_transferred);
-		urb->status = -EPIPE;
-		break;
-	case CVMX_USB_COMPLETE_SHORT:
-		dev_dbg(dev, "status=short pipe=%d submit=%d size=%d\n",
-			pipe_handle, submit_handle, bytes_transferred);
-		urb->status = -EREMOTEIO;
-		break;
-	case CVMX_USB_COMPLETE_ERROR:
-	case CVMX_USB_COMPLETE_XACTERR:
-	case CVMX_USB_COMPLETE_DATATGLERR:
-	case CVMX_USB_COMPLETE_FRAMEERR:
-		dev_dbg(dev, "status=%d pipe=%d submit=%d size=%d\n",
-			status, pipe_handle, submit_handle, bytes_transferred);
-		urb->status = -EPROTO;
-		break;
-	}
-	spin_unlock(&priv->lock);
-	usb_hcd_giveback_urb(octeon_to_hcd(priv), urb, urb->status);
-	spin_lock(&priv->lock);
-}
-
 static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 				  struct urb *urb,
 				  gfp_t mem_flags)
@@ -3595,7 +3467,6 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 							iso_packet,
 							urb->transfer_dma,
 							urb->transfer_buffer_length,
-							octeon_usb_urb_complete_callback,
 							urb);
 			/*
 			 * If submit failed we need to free our private packet
@@ -3613,7 +3484,6 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		submit_handle = cvmx_usb_submit_interrupt(&priv->usb, pipe_handle,
 					      urb->transfer_dma,
 					      urb->transfer_buffer_length,
-					      octeon_usb_urb_complete_callback,
 					      urb);
 		break;
 	case PIPE_CONTROL:
@@ -3623,7 +3493,6 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 					    urb->setup_dma,
 					    urb->transfer_dma,
 					    urb->transfer_buffer_length,
-					    octeon_usb_urb_complete_callback,
 					    urb);
 		break;
 	case PIPE_BULK:
@@ -3632,7 +3501,6 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		submit_handle = cvmx_usb_submit_bulk(&priv->usb, pipe_handle,
 					 urb->transfer_dma,
 					 urb->transfer_buffer_length,
-					 octeon_usb_urb_complete_callback,
 					 urb);
 		break;
 	}

commit 393e2146869c215470d6e78e946395f3331c3fd7
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:27 2013 +0300

    staging: octeon-usb: call port change callback directly
    
    Call port change callback directly.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 06133ed14d22..47d0585537c2 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -213,18 +213,11 @@ struct cvmx_usb_iso_packet {
  *					 if the transfer fails or is canceled.
  *					 The status parameter will contain
  *					 details of why he callback was called.
- * @CVMX_USB_CALLBACK_PORT_CHANGED:	 The status of the port changed. For
- *					 example, someone may have plugged a
- *					 device in. The status parameter
- *					 contains CVMX_USB_COMPLETE_SUCCESS. Use
- *					 cvmx_usb_get_status() to get the new
- *					 port status.
  * @__CVMX_USB_CALLBACK_END:		 Do not use. Used internally for array
  *					 bounds.
  */
 enum cvmx_usb_callback {
 	CVMX_USB_CALLBACK_TRANSFER_COMPLETE,
-	CVMX_USB_CALLBACK_PORT_CHANGED,
 	__CVMX_USB_CALLBACK_END
 };
 
@@ -245,8 +238,8 @@ struct cvmx_usb_state;
  *        with a transfer.
  *      - Actual number of bytes transfer.
  *      - user_data = The user pointer supplied to the
- *        function cvmx_usb_submit() or
- *        cvmx_usb_register_callback() */
+ *        function cvmx_usb_submit().
+ */
 typedef void (*cvmx_usb_callback_func_t)(struct cvmx_usb_state *usb,
                                          enum cvmx_usb_callback reason,
                                          enum cvmx_usb_complete status,
@@ -490,8 +483,6 @@ struct cvmx_usb_tx_fifo {
  * free_transaction_tail:  List of free transactions tail.
  * pipe:		   Storage for pipes.
  * transaction:		   Storage for transactions.
- * callback:		   User global callbacks.
- * callback_data:	   User data for each callback.
  * indent:		   Used by debug output to indent functions.
  * port_status:		   Last port status used for change notification.
  * free_pipes:		   List of all pipes that are currently closed.
@@ -510,8 +501,6 @@ struct cvmx_usb_state {
 	struct cvmx_usb_transaction *free_transaction_tail;
 	struct cvmx_usb_pipe pipe[MAX_PIPES];
 	struct cvmx_usb_transaction transaction[MAX_TRANSACTIONS];
-	cvmx_usb_callback_func_t callback[__CVMX_USB_CALLBACK_END];
-	void *callback_data[__CVMX_USB_CALLBACK_END];
 	int indent;
 	struct cvmx_usb_port_status port_status;
 	struct cvmx_usb_pipe_list free_pipes;
@@ -2202,8 +2191,8 @@ static void __cvmx_usb_perform_callback(struct cvmx_usb_state *usb,
 					enum cvmx_usb_callback reason,
 					enum cvmx_usb_complete complete_code)
 {
-	cvmx_usb_callback_func_t callback = usb->callback[reason];
-	void *user_data = usb->callback_data[reason];
+	cvmx_usb_callback_func_t callback = NULL;
+	void *user_data;
 	int submit_handle = -1;
 	int pipe_handle = -1;
 	int bytes_transferred = 0;
@@ -2408,10 +2397,8 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
  *		    function isn't an error, then this function
  *		    is guaranteed to be called when the
  *		    transaction completes. If this parameter is
- *		    NULL, then the generic callback registered
- *		    through cvmx_usb_register_callback is
- *		    called. If both are NULL, then there is no
- *		    way to know when a transaction completes.
+ *		    NULL, then there is no way to know when a transaction
+ *		    completes.
  * @user_data:	    User supplied data returned when the
  *		    callback is called. This is only used if
  *		    callback in not NULL.
@@ -2464,10 +2451,8 @@ static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb, int pipe_handle,
  *		    function isn't an error, then this function
  *		    is guaranteed to be called when the
  *		    transaction completes. If this parameter is
- *		    NULL, then the generic callback registered
- *		    through cvmx_usb_register_callback is
- *		    called. If both are NULL, then there is no
- *		    way to know when a transaction completes.
+ *		    NULL, then there is no way to know when a transaction
+ *		    completes.
  * @user_data:	    User supplied data returned when the
  *		    callback is called. This is only used if
  *		    callback in not NULL.
@@ -2525,10 +2510,8 @@ static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
  *		    function isn't an error, then this function
  *		    is guaranteed to be called when the
  *		    transaction completes. If this parameter is
- *		    NULL, then the generic callback registered
- *		    through cvmx_usb_register_callback is
- *		    called. If both are NULL, then there is no
- *		    way to know when a transaction completes.
+ *		    NULL, then there is no way to know when a transaction
+ *		    completes.
  * @user_data:	    User supplied data returned when the
  *		    callback is called. This is only used if
  *		    callback in not NULL.
@@ -2600,10 +2583,8 @@ static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
  *		    function isn't an error, then this function
  *		    is guaranteed to be called when the
  *		    transaction completes. If this parameter is
- *		    NULL, then the generic callback registered
- *		    through cvmx_usb_register_callback is
- *		    called. If both are NULL, then there is no
- *		    way to know when a transaction completes.
+ *		    NULL, then there is no way to know when a transaction
+ *		    completes.
  * @user_data:	    User supplied data returned when the
  *		    callback is called. This is only used if
  *		    callback in not NULL.
@@ -2776,34 +2757,6 @@ static int cvmx_usb_close_pipe(struct cvmx_usb_state *usb, int pipe_handle)
 	return 0;
 }
 
-
-/**
- * Register a function to be called when various USB events occur.
- *
- * @usb:       USB device state populated by cvmx_usb_initialize().
- * @reason:    Which event to register for.
- * @callback:  Function to call when the event occurs.
- * @user_data: User data parameter to the function.
- *
- * Returns: 0 or a negative error code.
- */
-static int cvmx_usb_register_callback(struct cvmx_usb_state *usb,
-				      enum cvmx_usb_callback reason,
-				      cvmx_usb_callback_func_t callback,
-				      void *user_data)
-{
-	if (unlikely(reason >= __CVMX_USB_CALLBACK_END))
-		return -EINVAL;
-	if (unlikely(!callback))
-		return -EINVAL;
-
-	usb->callback[reason] = callback;
-	usb->callback_data[reason] = user_data;
-
-	return 0;
-}
-
-
 /**
  * Get the current USB protocol level frame number. The frame
  * number is always in the range of 0-0x7ff.
@@ -3264,6 +3217,24 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 	return 0;
 }
 
+static inline struct octeon_hcd *cvmx_usb_to_octeon(struct cvmx_usb_state *p)
+{
+	return container_of(p, struct octeon_hcd, usb);
+}
+
+static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
+{
+	return container_of((void *)p, struct usb_hcd, hcd_priv);
+}
+
+static void octeon_usb_port_callback(struct cvmx_usb_state *usb)
+{
+	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
+
+	spin_unlock(&priv->lock);
+	usb_hcd_poll_rh_status(octeon_to_hcd(priv));
+	spin_lock(&priv->lock);
+}
 
 /**
  * Poll the USB block for status and call all needed callback
@@ -3331,9 +3302,7 @@ static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 		 *
 		 * Call the user's port callback
 		 */
-		__cvmx_usb_perform_callback(usb, NULL, NULL,
-					    CVMX_USB_CALLBACK_PORT_CHANGED,
-					    CVMX_USB_COMPLETE_SUCCESS);
+		octeon_usb_port_callback(usb);
 		/* Clear the port change bits */
 		usbc_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
 		usbc_hprt.s.prtena = 0;
@@ -3374,16 +3343,6 @@ static inline struct octeon_hcd *hcd_to_octeon(struct usb_hcd *hcd)
 	return (struct octeon_hcd *)(hcd->hcd_priv);
 }
 
-static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
-{
-	return container_of((void *)p, struct usb_hcd, hcd_priv);
-}
-
-static inline struct octeon_hcd *cvmx_usb_to_octeon(struct cvmx_usb_state *p)
-{
-	return container_of(p, struct octeon_hcd, usb);
-}
-
 static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
@@ -3395,43 +3354,14 @@ static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
 	return IRQ_HANDLED;
 }
 
-static void octeon_usb_port_callback(struct cvmx_usb_state *usb,
-				     enum cvmx_usb_callback reason,
-				     enum cvmx_usb_complete status,
-				     int pipe_handle,
-				     int submit_handle,
-				     int bytes_transferred,
-				     void *user_data)
-{
-	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
-
-	spin_unlock(&priv->lock);
-	usb_hcd_poll_rh_status(octeon_to_hcd(priv));
-	spin_lock(&priv->lock);
-}
-
 static int octeon_usb_start(struct usb_hcd *hcd)
 {
-	struct octeon_hcd *priv = hcd_to_octeon(hcd);
-	unsigned long flags;
-
 	hcd->state = HC_STATE_RUNNING;
-	spin_lock_irqsave(&priv->lock, flags);
-	cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
-				   octeon_usb_port_callback, NULL);
-	spin_unlock_irqrestore(&priv->lock, flags);
 	return 0;
 }
 
 static void octeon_usb_stop(struct usb_hcd *hcd)
 {
-	struct octeon_hcd *priv = hcd_to_octeon(hcd);
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->lock, flags);
-	cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
-				   NULL, NULL);
-	spin_unlock_irqrestore(&priv->lock, flags);
 	hcd->state = HC_STATE_HALT;
 }
 

commit 29a202fa7694f07e30530d4500e1873a3133acdc
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:26 2013 +0300

    staging: octeon-usb: inline cvmx_usb_set_status
    
    Inline a trivial function.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index fa23889cc9a5..06133ed14d22 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -1282,9 +1282,7 @@ static int cvmx_usb_disable(struct cvmx_usb_state *usb)
  * determine if the usb port has anything connected, is enabled,
  * or has some sort of error condition. The return value of this
  * call has "changed" bits to signal of the value of some fields
- * have changed between calls. These "changed" fields are based
- * on the last call to cvmx_usb_set_status(). In order to clear
- * them, you must update the status through cvmx_usb_set_status().
+ * have changed between calls.
  *
  * @usb: USB device state populated by cvmx_usb_initialize().
  *
@@ -1308,26 +1306,6 @@ static struct cvmx_usb_port_status cvmx_usb_get_status(struct cvmx_usb_state *us
 	return result;
 }
 
-
-/**
- * Set the current state of the USB port. The status is used as
- * a reference for the "changed" bits returned by
- * cvmx_usb_get_status(). Other than serving as a reference, the
- * status passed to this function is not used. No fields can be
- * changed through this call.
- *
- * @usb:	 USB device state populated by cvmx_usb_initialize().
- * @port_status:
- *		 Port status to set, most like returned by cvmx_usb_get_status()
- */
-static void cvmx_usb_set_status(struct cvmx_usb_state *usb,
-				struct cvmx_usb_port_status port_status)
-{
-	usb->port_status = port_status;
-	return;
-}
-
-
 /**
  * Convert a USB transaction into a handle
  *
@@ -3863,7 +3841,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			dev_dbg(dev, " C_CONNECTION\n");
 			/* Clears drivers internal connect status change flag */
 			spin_lock_irqsave(&priv->lock, flags);
-			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			priv->usb.port_status = cvmx_usb_get_status(&priv->usb);
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_RESET:
@@ -3872,7 +3850,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			 * Clears the driver's internal Port Reset Change flag.
 			 */
 			spin_lock_irqsave(&priv->lock, flags);
-			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			priv->usb.port_status = cvmx_usb_get_status(&priv->usb);
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_ENABLE:
@@ -3882,7 +3860,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			 * Change flag.
 			 */
 			spin_lock_irqsave(&priv->lock, flags);
-			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			priv->usb.port_status = cvmx_usb_get_status(&priv->usb);
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
@@ -3897,7 +3875,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			dev_dbg(dev, " C_OVER_CURRENT\n");
 			/* Clears the driver's overcurrent Change flag */
 			spin_lock_irqsave(&priv->lock, flags);
-			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			priv->usb.port_status = cvmx_usb_get_status(&priv->usb);
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		default:

commit cb61c600987c61ae54edf5dee269987411bdff4b
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:25 2013 +0300

    staging: octeon-usb: eliminate cvmx_usb_internal_state
    
    Eliminate cvmx_usb_internal_state, just use cvmx_usb_state everywhere.
    This also enables to allocate only the needed amount of data for the
    USB internal state, instead of always allocating 64 KB.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 478a903f2bce..fa23889cc9a5 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -228,20 +228,12 @@ enum cvmx_usb_callback {
 	__CVMX_USB_CALLBACK_END
 };
 
-/**
- * USB state internal data. The contents of this structure
- * may change in future SDKs. No data in it should be referenced
- * by user's of this API.
- */
-struct cvmx_usb_state {
-	char data[65536];
-};
+struct cvmx_usb_state;
 
 /**
  * USB callback functions are always of the following type.
  * The parameters are as follows:
- *      - state = USB device state populated by
- *        cvmx_usb_initialize().
+ *      - usb = USB device state populated by cvmx_usb_initialize().
  *      - reason = The enum cvmx_usb_callback used to register
  *        the callback.
  *      - status = The enum cvmx_usb_complete representing the
@@ -255,7 +247,7 @@ struct cvmx_usb_state {
  *      - user_data = The user pointer supplied to the
  *        function cvmx_usb_submit() or
  *        cvmx_usb_register_callback() */
-typedef void (*cvmx_usb_callback_func_t)(struct cvmx_usb_state *state,
+typedef void (*cvmx_usb_callback_func_t)(struct cvmx_usb_state *usb,
                                          enum cvmx_usb_callback reason,
                                          enum cvmx_usb_complete status,
                                          int pipe_handle, int submit_handle,
@@ -486,7 +478,7 @@ struct cvmx_usb_tx_fifo {
 };
 
 /**
- * struct cvmx_usb_internal_state - the state of the USB block
+ * struct cvmx_usb_state - the state of the USB block
  *
  * init_flags:		   Flags passed to initialize.
  * index:		   Which USB block this is for.
@@ -508,7 +500,7 @@ struct cvmx_usb_tx_fifo {
  * frame_number:	   Increments every SOF interrupt for time keeping.
  * active_split:	   Points to the current active split, or NULL.
  */
-struct cvmx_usb_internal_state {
+struct cvmx_usb_state {
 	int init_flags;
 	int index;
 	int idle_hardware_channels;
@@ -597,7 +589,7 @@ static int octeon_usb_get_clock_type(void)
  *
  * Returns: Result of the read
  */
-static inline uint32_t __cvmx_usb_read_csr32(struct cvmx_usb_internal_state *usb,
+static inline uint32_t __cvmx_usb_read_csr32(struct cvmx_usb_state *usb,
 					     uint64_t address)
 {
 	uint32_t result = cvmx_read64_uint32(address ^ 4);
@@ -614,7 +606,7 @@ static inline uint32_t __cvmx_usb_read_csr32(struct cvmx_usb_internal_state *usb
  * @address: 64bit address to write
  * @value:   Value to write
  */
-static inline void __cvmx_usb_write_csr32(struct cvmx_usb_internal_state *usb,
+static inline void __cvmx_usb_write_csr32(struct cvmx_usb_state *usb,
 					  uint64_t address, uint32_t value)
 {
 	cvmx_write64_uint32(address ^ 4, value);
@@ -631,7 +623,7 @@ static inline void __cvmx_usb_write_csr32(struct cvmx_usb_internal_state *usb,
  *
  * Returns: Result of the read
  */
-static inline uint64_t __cvmx_usb_read_csr64(struct cvmx_usb_internal_state *usb,
+static inline uint64_t __cvmx_usb_read_csr64(struct cvmx_usb_state *usb,
 					     uint64_t address)
 {
 	uint64_t result = cvmx_read64_uint64(address);
@@ -647,7 +639,7 @@ static inline uint64_t __cvmx_usb_read_csr64(struct cvmx_usb_internal_state *usb
  * @address: 64bit address to write
  * @value:   Value to write
  */
-static inline void __cvmx_usb_write_csr64(struct cvmx_usb_internal_state *usb,
+static inline void __cvmx_usb_write_csr64(struct cvmx_usb_state *usb,
 					  uint64_t address, uint64_t value)
 {
 	cvmx_write64_uint64(address, value);
@@ -662,7 +654,8 @@ static inline void __cvmx_usb_write_csr64(struct cvmx_usb_internal_state *usb,
  *
  * Returns: Non zero if we need to do split transactions
  */
-static inline int __cvmx_usb_pipe_needs_split(struct cvmx_usb_internal_state *usb, struct cvmx_usb_pipe *pipe)
+static inline int __cvmx_usb_pipe_needs_split(struct cvmx_usb_state *usb,
+					      struct cvmx_usb_pipe *pipe)
 {
 	return ((pipe->device_speed != CVMX_USB_SPEED_HIGH) && (usb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_HIGH));
 }
@@ -723,7 +716,7 @@ static int cvmx_usb_get_num_ports(void)
  *
  * Returns: Transaction or NULL
  */
-static inline struct cvmx_usb_transaction *__cvmx_usb_alloc_transaction(struct cvmx_usb_internal_state *usb)
+static inline struct cvmx_usb_transaction *__cvmx_usb_alloc_transaction(struct cvmx_usb_state *usb)
 {
 	struct cvmx_usb_transaction *t;
 	t = usb->free_transaction_head;
@@ -748,7 +741,7 @@ static inline struct cvmx_usb_transaction *__cvmx_usb_alloc_transaction(struct c
  * @transaction:
  *		 Transaction to free
  */
-static inline void __cvmx_usb_free_transaction(struct cvmx_usb_internal_state *usb,
+static inline void __cvmx_usb_free_transaction(struct cvmx_usb_state *usb,
 					       struct cvmx_usb_transaction *transaction)
 {
 	transaction->flags = 0;
@@ -811,7 +804,7 @@ static inline void __cvmx_usb_remove_pipe(struct cvmx_usb_pipe_list *list, struc
  * other access to the Octeon USB port is made. The port starts
  * off in the disabled state.
  *
- * @state:	 Pointer to an empty struct cvmx_usb_state
+ * @usb:	 Pointer to an empty struct cvmx_usb_state
  *		 that will be populated by the initialize call.
  *		 This structure is then passed to all other USB
  *		 functions.
@@ -820,17 +813,13 @@ static inline void __cvmx_usb_remove_pipe(struct cvmx_usb_pipe_list *list, struc
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_initialize(struct cvmx_usb_state *state,
+static int cvmx_usb_initialize(struct cvmx_usb_state *usb,
 			       int usb_port_number)
 {
 	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
 	union cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 	enum cvmx_usb_initialize_flags flags = 0;
 
-	/* Make sure that state is large enough to store the internal state */
-	if (sizeof(*state) < sizeof(*usb))
-		return -EINVAL;
 	/* At first allow 0-1 for the usb port number */
 	if ((usb_port_number < 0) || (usb_port_number > 1))
 		return -EINVAL;
@@ -1148,15 +1137,13 @@ static int cvmx_usb_initialize(struct cvmx_usb_state *state,
  * The port should be disabled with all pipes closed when this
  * function is called.
  *
- * @state: USB device state populated by
- *	   cvmx_usb_initialize().
+ * @usb: USB device state populated by cvmx_usb_initialize().
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_shutdown(struct cvmx_usb_state *state)
+static int cvmx_usb_shutdown(struct cvmx_usb_state *usb)
 {
 	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 
 	/* Make sure all pipes are closed */
 	if (usb->idle_pipes.head ||
@@ -1183,15 +1170,13 @@ static int cvmx_usb_shutdown(struct cvmx_usb_state *state)
  * Enable a USB port. After this call succeeds, the USB port is
  * online and servicing requests.
  *
- * @state: USB device state populated by
- *	   cvmx_usb_initialize().
+ * @usb: USB device state populated by cvmx_usb_initialize().
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_enable(struct cvmx_usb_state *state)
+static int cvmx_usb_enable(struct cvmx_usb_state *usb)
 {
 	union cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 
 	usb->usbcx_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
 
@@ -1280,15 +1265,12 @@ static int cvmx_usb_enable(struct cvmx_usb_state *state)
  * Transactions in process will fail and call their
  * associated callbacks.
  *
- * @state: USB device state populated by
- *	   cvmx_usb_initialize().
+ * @usb: USB device state populated by cvmx_usb_initialize().
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_disable(struct cvmx_usb_state *state)
+static int cvmx_usb_disable(struct cvmx_usb_state *usb)
 {
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
-
 	/* Disable the port */
 	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtena, 1);
 	return 0;
@@ -1304,16 +1286,14 @@ static int cvmx_usb_disable(struct cvmx_usb_state *state)
  * on the last call to cvmx_usb_set_status(). In order to clear
  * them, you must update the status through cvmx_usb_set_status().
  *
- * @state: USB device state populated by
- *	   cvmx_usb_initialize().
+ * @usb: USB device state populated by cvmx_usb_initialize().
  *
  * Returns: Port status information
  */
-static struct cvmx_usb_port_status cvmx_usb_get_status(struct cvmx_usb_state *state)
+static struct cvmx_usb_port_status cvmx_usb_get_status(struct cvmx_usb_state *usb)
 {
 	union cvmx_usbcx_hprt usbc_hprt;
 	struct cvmx_usb_port_status result;
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 
 	memset(&result, 0, sizeof(result));
 
@@ -1336,15 +1316,13 @@ static struct cvmx_usb_port_status cvmx_usb_get_status(struct cvmx_usb_state *st
  * status passed to this function is not used. No fields can be
  * changed through this call.
  *
- * @state:	 USB device state populated by
- *		 cvmx_usb_initialize().
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @port_status:
  *		 Port status to set, most like returned by cvmx_usb_get_status()
  */
-static void cvmx_usb_set_status(struct cvmx_usb_state *state,
+static void cvmx_usb_set_status(struct cvmx_usb_state *usb,
 				struct cvmx_usb_port_status port_status)
 {
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 	usb->port_status = port_status;
 	return;
 }
@@ -1353,14 +1331,13 @@ static void cvmx_usb_set_status(struct cvmx_usb_state *state,
 /**
  * Convert a USB transaction into a handle
  *
- * @usb:	 USB device state populated by
- *		 cvmx_usb_initialize().
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @transaction:
  *		 Transaction to get handle for
  *
  * Returns: Handle
  */
-static inline int __cvmx_usb_get_submit_handle(struct cvmx_usb_internal_state *usb,
+static inline int __cvmx_usb_get_submit_handle(struct cvmx_usb_state *usb,
 					       struct cvmx_usb_transaction *transaction)
 {
 	return ((unsigned long)transaction - (unsigned long)usb->transaction) /
@@ -1371,13 +1348,12 @@ static inline int __cvmx_usb_get_submit_handle(struct cvmx_usb_internal_state *u
 /**
  * Convert a USB pipe into a handle
  *
- * @usb:	 USB device state populated by
- *		 cvmx_usb_initialize().
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @pipe:	 Pipe to get handle for
  *
  * Returns: Handle
  */
-static inline int __cvmx_usb_get_pipe_handle(struct cvmx_usb_internal_state *usb,
+static inline int __cvmx_usb_get_pipe_handle(struct cvmx_usb_state *usb,
 					     struct cvmx_usb_pipe *pipe)
 {
 	return ((unsigned long)pipe - (unsigned long)usb->pipe) / sizeof(*pipe);
@@ -1389,8 +1365,7 @@ static inline int __cvmx_usb_get_pipe_handle(struct cvmx_usb_internal_state *usb
  * must be opened before data can be transferred between a device
  * and Octeon.
  *
- * @state:	     USB device state populated by
- *		     cvmx_usb_initialize().
+ * @usb:	     USB device state populated by cvmx_usb_initialize().
  * @device_addr:
  *		     USB device address to open the pipe to
  *		     (0-127).
@@ -1438,7 +1413,7 @@ static inline int __cvmx_usb_get_pipe_handle(struct cvmx_usb_internal_state *usb
  * Returns: A non negative value is a pipe handle. Negative
  *	    values are error codes.
  */
-static int cvmx_usb_open_pipe(struct cvmx_usb_state *state,
+static int cvmx_usb_open_pipe(struct cvmx_usb_state *usb,
 			      int device_addr, int endpoint_num,
 			      enum cvmx_usb_speed device_speed, int max_packet,
 			      enum cvmx_usb_transfer transfer_type,
@@ -1447,7 +1422,6 @@ static int cvmx_usb_open_pipe(struct cvmx_usb_state *state,
 			      int hub_device_addr, int hub_port)
 {
 	struct cvmx_usb_pipe *pipe;
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 
 	if (unlikely((device_addr < 0) || (device_addr > MAX_USB_ADDRESS)))
 		return -EINVAL;
@@ -1527,10 +1501,9 @@ static int cvmx_usb_open_pipe(struct cvmx_usb_state *state,
  * in non DMA mode. It is very important that this function be called quickly
  * enough to prevent FIFO overflow.
  *
- * @usb:	USB device state populated by
- *		cvmx_usb_initialize().
+ * @usb:	USB device state populated by cvmx_usb_initialize().
  */
-static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_internal_state *usb)
+static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)
 {
 	union cvmx_usbcx_grxstsph rx_status;
 	int channel;
@@ -1571,15 +1544,15 @@ static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_internal_state *usb)
  * Fill the TX hardware fifo with data out of the software
  * fifos
  *
- * @usb:	    USB device state populated by
- *		    cvmx_usb_initialize().
+ * @usb:	    USB device state populated by cvmx_usb_initialize().
  * @fifo:	    Software fifo to use
  * @available:	    Amount of space in the hardware fifo
  *
  * Returns: Non zero if the hardware fifo was too small and needs
  *	    to be serviced again.
  */
-static int __cvmx_usb_fill_tx_hw(struct cvmx_usb_internal_state *usb, struct cvmx_usb_tx_fifo *fifo, int available)
+static int __cvmx_usb_fill_tx_hw(struct cvmx_usb_state *usb,
+				 struct cvmx_usb_tx_fifo *fifo, int available)
 {
 	/*
 	 * We're done either when there isn't anymore space or the software FIFO
@@ -1630,10 +1603,9 @@ static int __cvmx_usb_fill_tx_hw(struct cvmx_usb_internal_state *usb, struct cvm
 /**
  * Check the hardware FIFOs and fill them as needed
  *
- * @usb:	USB device state populated by
- *		cvmx_usb_initialize().
+ * @usb:	USB device state populated by cvmx_usb_initialize().
  */
-static void __cvmx_usb_poll_tx_fifo(struct cvmx_usb_internal_state *usb)
+static void __cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)
 {
 	if (usb->periodic.head != usb->periodic.tail) {
 		union cvmx_usbcx_hptxsts tx_status;
@@ -1660,11 +1632,10 @@ static void __cvmx_usb_poll_tx_fifo(struct cvmx_usb_internal_state *usb)
 /**
  * Fill the TX FIFO with an outgoing packet
  *
- * @usb:	  USB device state populated by
- *		  cvmx_usb_initialize().
+ * @usb:	  USB device state populated by cvmx_usb_initialize().
  * @channel:	  Channel number to get packet from
  */
-static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_internal_state *usb, int channel)
+static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)
 {
 	union cvmx_usbcx_hccharx hcchar;
 	union cvmx_usbcx_hcspltx usbc_hcsplt;
@@ -1712,12 +1683,11 @@ static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_internal_state *usb, int cha
  * the generic stuff will already have been done in
  * __cvmx_usb_start_channel()
  *
- * @usb:	  USB device state populated by
- *		  cvmx_usb_initialize().
+ * @usb:	  USB device state populated by cvmx_usb_initialize().
  * @channel:	  Channel to setup
  * @pipe:	  Pipe for control transaction
  */
-static void __cvmx_usb_start_channel_control(struct cvmx_usb_internal_state *usb,
+static void __cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,
 					     int channel,
 					     struct cvmx_usb_pipe *pipe)
 {
@@ -1842,12 +1812,11 @@ static void __cvmx_usb_start_channel_control(struct cvmx_usb_internal_state *usb
 /**
  * Start a channel to perform the pipe's head transaction
  *
- * @usb:	  USB device state populated by
- *		  cvmx_usb_initialize().
+ * @usb:	  USB device state populated by cvmx_usb_initialize().
  * @channel:	  Channel to setup
  * @pipe:	  Pipe to start
  */
-static void __cvmx_usb_start_channel(struct cvmx_usb_internal_state *usb,
+static void __cvmx_usb_start_channel(struct cvmx_usb_state *usb,
 				     int channel,
 				     struct cvmx_usb_pipe *pipe)
 {
@@ -2138,15 +2107,14 @@ static void __cvmx_usb_start_channel(struct cvmx_usb_internal_state *usb,
 
 /**
  * Find a pipe that is ready to be scheduled to hardware.
- * @usb:	 USB device state populated by
- *		 cvmx_usb_initialize().
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @list:	 Pipe list to search
  * @current_frame:
  *		 Frame counter to use as a time reference.
  *
  * Returns: Pipe or NULL if none are ready
  */
-static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(struct cvmx_usb_internal_state *usb, struct cvmx_usb_pipe_list *list, uint64_t current_frame)
+static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(struct cvmx_usb_state *usb, struct cvmx_usb_pipe_list *list, uint64_t current_frame)
 {
 	struct cvmx_usb_pipe *pipe = list->head;
 	while (pipe) {
@@ -2168,11 +2136,10 @@ static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(struct cvmx_usb_internal
  * Called whenever a pipe might need to be scheduled to the
  * hardware.
  *
- * @usb:	 USB device state populated by
- *		 cvmx_usb_initialize().
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @is_sof:	 True if this schedule was called on a SOF interrupt.
  */
-static void __cvmx_usb_schedule(struct cvmx_usb_internal_state *usb, int is_sof)
+static void __cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)
 {
 	int channel;
 	struct cvmx_usb_pipe *pipe;
@@ -2243,8 +2210,7 @@ static void __cvmx_usb_schedule(struct cvmx_usb_internal_state *usb, int is_sof)
 /**
  * Call a user's callback for a specific reason.
  *
- * @usb:	 USB device state populated by
- *		 cvmx_usb_initialize().
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @pipe:	 Pipe the callback is for or NULL
  * @transaction:
  *		 Transaction the callback is for or NULL
@@ -2252,7 +2218,7 @@ static void __cvmx_usb_schedule(struct cvmx_usb_internal_state *usb, int is_sof)
  * @complete_code:
  *		 Completion code for the transaction, if any
  */
-static void __cvmx_usb_perform_callback(struct cvmx_usb_internal_state *usb,
+static void __cvmx_usb_perform_callback(struct cvmx_usb_state *usb,
 					struct cvmx_usb_pipe *pipe,
 					struct cvmx_usb_transaction *transaction,
 					enum cvmx_usb_callback reason,
@@ -2280,7 +2246,7 @@ static void __cvmx_usb_perform_callback(struct cvmx_usb_internal_state *usb,
 	if (!callback)
 		return;
 
-	callback((struct cvmx_usb_state *)usb, reason, complete_code, pipe_handle, submit_handle,
+	callback(usb, reason, complete_code, pipe_handle, submit_handle,
 		 bytes_transferred, user_data);
 }
 
@@ -2289,15 +2255,14 @@ static void __cvmx_usb_perform_callback(struct cvmx_usb_internal_state *usb,
  * Signal the completion of a transaction and free it. The
  * transaction will be removed from the pipe transaction list.
  *
- * @usb:	 USB device state populated by
- *		 cvmx_usb_initialize().
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @pipe:	 Pipe the transaction is on
  * @transaction:
  *		 Transaction that completed
  * @complete_code:
  *		 Completion code
  */
-static void __cvmx_usb_perform_complete(struct cvmx_usb_internal_state *usb,
+static void __cvmx_usb_perform_complete(struct cvmx_usb_state *usb,
 					struct cvmx_usb_pipe *pipe,
 					struct cvmx_usb_transaction *transaction,
 					enum cvmx_usb_complete complete_code)
@@ -2379,7 +2344,7 @@ static void __cvmx_usb_perform_complete(struct cvmx_usb_internal_state *usb,
  * Returns: Submit handle or negative on failure. Matches the result
  *	    in the external API.
  */
-static int __cvmx_usb_submit_transaction(struct cvmx_usb_internal_state *usb,
+static int __cvmx_usb_submit_transaction(struct cvmx_usb_state *usb,
 					 int pipe_handle,
 					 enum cvmx_usb_transfer type,
 					 uint64_t buffer,
@@ -2450,8 +2415,7 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_internal_state *usb,
 /**
  * Call to submit a USB Bulk transfer to a pipe.
  *
- * @state:	    USB device state populated by
- *		    cvmx_usb_initialize().
+ * @usb:	    USB device state populated by cvmx_usb_initialize().
  * @pipe_handle:
  *		    Handle to the pipe for the transfer.
  * @buffer:	    Physical address of the data buffer in
@@ -2477,13 +2441,12 @@ static int __cvmx_usb_submit_transaction(struct cvmx_usb_internal_state *usb,
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
-static int cvmx_usb_submit_bulk(struct cvmx_usb_state *state, int pipe_handle,
+static int cvmx_usb_submit_bulk(struct cvmx_usb_state *usb, int pipe_handle,
 				uint64_t buffer, int buffer_length,
 				cvmx_usb_callback_func_t callback,
 				void *user_data)
 {
 	int submit_handle;
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 
 	/* Pipe handle checking is done later in a common place */
 	if (unlikely(!buffer))
@@ -2508,8 +2471,7 @@ static int cvmx_usb_submit_bulk(struct cvmx_usb_state *state, int pipe_handle,
 /**
  * Call to submit a USB Interrupt transfer to a pipe.
  *
- * @state:	    USB device state populated by
- *		    cvmx_usb_initialize().
+ * @usb:	    USB device state populated by cvmx_usb_initialize().
  * @pipe_handle:
  *		    Handle to the pipe for the transfer.
  * @buffer:	    Physical address of the data buffer in
@@ -2535,14 +2497,13 @@ static int cvmx_usb_submit_bulk(struct cvmx_usb_state *state, int pipe_handle,
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
-static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *state,
+static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *usb,
 				     int pipe_handle, uint64_t buffer,
 				     int buffer_length,
 				     cvmx_usb_callback_func_t callback,
 				     void *user_data)
 {
 	int submit_handle;
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 
 	/* Pipe handle checking is done later in a common place */
 	if (unlikely(!buffer))
@@ -2567,8 +2528,7 @@ static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *state,
 /**
  * Call to submit a USB Control transfer to a pipe.
  *
- * @state:	    USB device state populated by
- *		    cvmx_usb_initialize().
+ * @usb:	    USB device state populated by cvmx_usb_initialize().
  * @pipe_handle:
  *		    Handle to the pipe for the transfer.
  * @control_header:
@@ -2598,14 +2558,13 @@ static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *state,
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
-static int cvmx_usb_submit_control(struct cvmx_usb_state *state,
+static int cvmx_usb_submit_control(struct cvmx_usb_state *usb,
 				   int pipe_handle, uint64_t control_header,
 				   uint64_t buffer, int buffer_length,
 				   cvmx_usb_callback_func_t callback,
 				   void *user_data)
 {
 	int submit_handle;
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 	union cvmx_usb_control_header *header =
 		cvmx_phys_to_ptr(control_header);
 
@@ -2637,8 +2596,7 @@ static int cvmx_usb_submit_control(struct cvmx_usb_state *state,
 /**
  * Call to submit a USB Isochronous transfer to a pipe.
  *
- * @state:	    USB device state populated by
- *		    cvmx_usb_initialize().
+ * @usb:	    USB device state populated by cvmx_usb_initialize().
  * @pipe_handle:
  *		    Handle to the pipe for the transfer.
  * @start_frame:
@@ -2675,7 +2633,7 @@ static int cvmx_usb_submit_control(struct cvmx_usb_state *state,
  * Returns: A submitted transaction handle or negative on
  *	    failure. Negative values are error codes.
  */
-static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *state,
+static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *usb,
 				       int pipe_handle, int start_frame,
 				       int number_packets, struct
 				       cvmx_usb_iso_packet packets[],
@@ -2684,7 +2642,6 @@ static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *state,
 				       void *user_data)
 {
 	int submit_handle;
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 
 	/* Pipe handle checking is done later in a common place */
 	if (unlikely(start_frame < 0))
@@ -2719,8 +2676,7 @@ static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *state,
  * a frame or two for the cvmx_usb_poll() function to call the
  * associated callback.
  *
- * @state:	 USB device state populated by
- *		 cvmx_usb_initialize().
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @pipe_handle:
  *		 Pipe handle to cancel requests in.
  * @submit_handle:
@@ -2729,11 +2685,10 @@ static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *state,
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_cancel(struct cvmx_usb_state *state, int pipe_handle,
+static int cvmx_usb_cancel(struct cvmx_usb_state *usb, int pipe_handle,
 			   int submit_handle)
 {
 	struct cvmx_usb_transaction *transaction;
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 	struct cvmx_usb_pipe *pipe = usb->pipe + pipe_handle;
 
 	if (unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
@@ -2783,16 +2738,14 @@ static int cvmx_usb_cancel(struct cvmx_usb_state *state, int pipe_handle,
  * Cancel all outstanding requests in a pipe. Logically all this
  * does is call cvmx_usb_cancel() in a loop.
  *
- * @state:	 USB device state populated by
- *		 cvmx_usb_initialize().
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @pipe_handle:
  *		 Pipe handle to cancel requests in.
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_cancel_all(struct cvmx_usb_state *state, int pipe_handle)
+static int cvmx_usb_cancel_all(struct cvmx_usb_state *usb, int pipe_handle)
 {
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 	struct cvmx_usb_pipe *pipe = usb->pipe + pipe_handle;
 
 	if (unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
@@ -2804,7 +2757,7 @@ static int cvmx_usb_cancel_all(struct cvmx_usb_state *state, int pipe_handle)
 
 	/* Simply loop through and attempt to cancel each transaction */
 	while (pipe->head) {
-		int result = cvmx_usb_cancel(state, pipe_handle,
+		int result = cvmx_usb_cancel(usb, pipe_handle,
 			__cvmx_usb_get_submit_handle(usb, pipe->head));
 		if (unlikely(result != 0))
 			return result;
@@ -2816,17 +2769,15 @@ static int cvmx_usb_cancel_all(struct cvmx_usb_state *state, int pipe_handle)
 /**
  * Close a pipe created with cvmx_usb_open_pipe().
  *
- * @state:	 USB device state populated by
- *		 cvmx_usb_initialize().
+ * @usb:	 USB device state populated by cvmx_usb_initialize().
  * @pipe_handle:
  *		 Pipe handle to close.
  *
  * Returns: 0 or a negative error code. EBUSY is returned if the pipe has
  *	    outstanding transfers.
  */
-static int cvmx_usb_close_pipe(struct cvmx_usb_state *state, int pipe_handle)
+static int cvmx_usb_close_pipe(struct cvmx_usb_state *usb, int pipe_handle)
 {
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 	struct cvmx_usb_pipe *pipe = usb->pipe + pipe_handle;
 
 	if (unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
@@ -2851,21 +2802,18 @@ static int cvmx_usb_close_pipe(struct cvmx_usb_state *state, int pipe_handle)
 /**
  * Register a function to be called when various USB events occur.
  *
- * @state:     USB device state populated by
- *	       cvmx_usb_initialize().
+ * @usb:       USB device state populated by cvmx_usb_initialize().
  * @reason:    Which event to register for.
  * @callback:  Function to call when the event occurs.
  * @user_data: User data parameter to the function.
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_register_callback(struct cvmx_usb_state *state,
+static int cvmx_usb_register_callback(struct cvmx_usb_state *usb,
 				      enum cvmx_usb_callback reason,
 				      cvmx_usb_callback_func_t callback,
 				      void *user_data)
 {
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
-
 	if (unlikely(reason >= __CVMX_USB_CALLBACK_END))
 		return -EINVAL;
 	if (unlikely(!callback))
@@ -2882,15 +2830,13 @@ static int cvmx_usb_register_callback(struct cvmx_usb_state *state,
  * Get the current USB protocol level frame number. The frame
  * number is always in the range of 0-0x7ff.
  *
- * @state: USB device state populated by
- *	   cvmx_usb_initialize().
+ * @usb: USB device state populated by cvmx_usb_initialize().
  *
  * Returns: USB frame number
  */
-static int cvmx_usb_get_frame_number(struct cvmx_usb_state *state)
+static int cvmx_usb_get_frame_number(struct cvmx_usb_state *usb)
 {
 	int frame_number;
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 	union cvmx_usbcx_hfnum usbc_hfnum;
 
 	usbc_hfnum.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
@@ -2908,7 +2854,7 @@ static int cvmx_usb_get_frame_number(struct cvmx_usb_state *state)
  *
  * Returns: Zero on success
  */
-static int __cvmx_usb_poll_channel(struct cvmx_usb_internal_state *usb, int channel)
+static int __cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)
 {
 	union cvmx_usbcx_hcintx usbc_hcint;
 	union cvmx_usbcx_hctsizx usbc_hctsiz;
@@ -3325,7 +3271,7 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_internal_state *usb, int chan
 				(usb->frame_number - pipe->next_tx_frame) % pipe->interval;
 	} else {
 		struct cvmx_usb_port_status port;
-		port = cvmx_usb_get_status((struct cvmx_usb_state *)usb);
+		port = cvmx_usb_get_status(usb);
 		if (port.port_enabled) {
 			/* We'll retry the exact same transaction again */
 			transaction->retries++;
@@ -3347,16 +3293,14 @@ static int __cvmx_usb_poll_channel(struct cvmx_usb_internal_state *usb, int chan
  * handler for the USB controller. It can also be called
  * periodically in a loop for non-interrupt based operation.
  *
- * @state:	USB device state populated by
- *		cvmx_usb_initialize().
+ * @usb: USB device state populated by cvmx_usb_initialize().
  *
  * Returns: 0 or a negative error code.
  */
-static int cvmx_usb_poll(struct cvmx_usb_state *state)
+static int cvmx_usb_poll(struct cvmx_usb_state *usb)
 {
 	union cvmx_usbcx_hfnum usbc_hfnum;
 	union cvmx_usbcx_gintsts usbc_gintsts;
-	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
 
 	CVMX_PREFETCH(usb, 0);
 	CVMX_PREFETCH(usb, 1*128);

commit 6570b4a991d6eff5290321d26b16c9954482e264
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Oct 6 22:22:24 2013 +0300

    staging: octeon-usb: merge cvmx-usb into octeon-hcd
    
    cvmx-usb module provided Cavium "OS abstraction layer" for USB
    functionality. To make this driver a proper Linux driver, we need to
    refactor this layer out. By making all the code internal to the HCD
    driver makes this task easier.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 764a8df0a16e..478a903f2bce 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -4,6 +4,44 @@
  * for more details.
  *
  * Copyright (C) 2008 Cavium Networks
+ *
+ * Some parts of the code were originally released under BSD license:
+ *
+ * Copyright (c) 2003-2010 Cavium Networks (support@cavium.com). All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *
+ *   * Neither the name of Cavium Networks nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export
+ * control laws, including the U.S. Export Administration Act and its associated
+ * regulations, and may be subject to export or import regulations in other
+ * countries.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION
+ * OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -17,13 +55,482 @@
 #include <linux/delay.h>
 
 #include <asm/octeon/cvmx.h>
-#include "cvmx-usb.h"
 #include <asm/octeon/cvmx-iob-defs.h>
 
 #include <linux/usb/hcd.h>
 
 #include <linux/err.h>
 
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-sysinfo.h>
+#include <asm/octeon/cvmx-helper-board.h>
+
+#include "cvmx-usbcx-defs.h"
+#include "cvmx-usbnx-defs.h"
+
+/**
+ * enum cvmx_usb_speed - the possible USB device speeds
+ *
+ * @CVMX_USB_SPEED_HIGH: Device is operation at 480Mbps
+ * @CVMX_USB_SPEED_FULL: Device is operation at 12Mbps
+ * @CVMX_USB_SPEED_LOW:  Device is operation at 1.5Mbps
+ */
+enum cvmx_usb_speed {
+	CVMX_USB_SPEED_HIGH = 0,
+	CVMX_USB_SPEED_FULL = 1,
+	CVMX_USB_SPEED_LOW = 2,
+};
+
+/**
+ * enum cvmx_usb_transfer - the possible USB transfer types
+ *
+ * @CVMX_USB_TRANSFER_CONTROL:	   USB transfer type control for hub and status
+ *				   transfers
+ * @CVMX_USB_TRANSFER_ISOCHRONOUS: USB transfer type isochronous for low
+ *				   priority periodic transfers
+ * @CVMX_USB_TRANSFER_BULK:	   USB transfer type bulk for large low priority
+ *				   transfers
+ * @CVMX_USB_TRANSFER_INTERRUPT:   USB transfer type interrupt for high priority
+ *				   periodic transfers
+ */
+enum cvmx_usb_transfer {
+	CVMX_USB_TRANSFER_CONTROL = 0,
+	CVMX_USB_TRANSFER_ISOCHRONOUS = 1,
+	CVMX_USB_TRANSFER_BULK = 2,
+	CVMX_USB_TRANSFER_INTERRUPT = 3,
+};
+
+/**
+ * enum cvmx_usb_direction - the transfer directions
+ *
+ * @CVMX_USB_DIRECTION_OUT: Data is transferring from Octeon to the device/host
+ * @CVMX_USB_DIRECTION_IN:  Data is transferring from the device/host to Octeon
+ */
+enum cvmx_usb_direction {
+	CVMX_USB_DIRECTION_OUT,
+	CVMX_USB_DIRECTION_IN,
+};
+
+/**
+ * enum cvmx_usb_complete - possible callback function status codes
+ *
+ * @CVMX_USB_COMPLETE_SUCCESS:	  The transaction / operation finished without
+ *				  any errors
+ * @CVMX_USB_COMPLETE_SHORT:	  FIXME: This is currently not implemented
+ * @CVMX_USB_COMPLETE_CANCEL:	  The transaction was canceled while in flight
+ *				  by a user call to cvmx_usb_cancel
+ * @CVMX_USB_COMPLETE_ERROR:	  The transaction aborted with an unexpected
+ *				  error status
+ * @CVMX_USB_COMPLETE_STALL:	  The transaction received a USB STALL response
+ *				  from the device
+ * @CVMX_USB_COMPLETE_XACTERR:	  The transaction failed with an error from the
+ *				  device even after a number of retries
+ * @CVMX_USB_COMPLETE_DATATGLERR: The transaction failed with a data toggle
+ *				  error even after a number of retries
+ * @CVMX_USB_COMPLETE_BABBLEERR:  The transaction failed with a babble error
+ * @CVMX_USB_COMPLETE_FRAMEERR:	  The transaction failed with a frame error
+ *				  even after a number of retries
+ */
+enum cvmx_usb_complete {
+	CVMX_USB_COMPLETE_SUCCESS,
+	CVMX_USB_COMPLETE_SHORT,
+	CVMX_USB_COMPLETE_CANCEL,
+	CVMX_USB_COMPLETE_ERROR,
+	CVMX_USB_COMPLETE_STALL,
+	CVMX_USB_COMPLETE_XACTERR,
+	CVMX_USB_COMPLETE_DATATGLERR,
+	CVMX_USB_COMPLETE_BABBLEERR,
+	CVMX_USB_COMPLETE_FRAMEERR,
+};
+
+/**
+ * struct cvmx_usb_port_status - the USB port status information
+ *
+ * @port_enabled:	1 = Usb port is enabled, 0 = disabled
+ * @port_over_current:	1 = Over current detected, 0 = Over current not
+ *			detected. Octeon doesn't support over current detection.
+ * @port_powered:	1 = Port power is being supplied to the device, 0 =
+ *			power is off. Octeon doesn't support turning port power
+ *			off.
+ * @port_speed:		Current port speed.
+ * @connected:		1 = A device is connected to the port, 0 = No device is
+ *			connected.
+ * @connect_change:	1 = Device connected state changed since the last set
+ *			status call.
+ */
+struct cvmx_usb_port_status {
+	uint32_t reserved		: 25;
+	uint32_t port_enabled		: 1;
+	uint32_t port_over_current	: 1;
+	uint32_t port_powered		: 1;
+	enum cvmx_usb_speed port_speed	: 2;
+	uint32_t connected		: 1;
+	uint32_t connect_change		: 1;
+};
+
+/**
+ * union cvmx_usb_control_header - the structure of a Control packet header
+ *
+ * @s.request_type:	Bit 7 tells the direction: 1=IN, 0=OUT
+ * @s.request		The standard usb request to make
+ * @s.value		Value parameter for the request in little endian format
+ * @s.index		Index for the request in little endian format
+ * @s.length		Length of the data associated with this request in
+ *			little endian format
+ */
+union cvmx_usb_control_header {
+	uint64_t u64;
+	struct {
+		uint64_t request_type   : 8;
+		uint64_t request        : 8;
+		uint64_t value          : 16;
+		uint64_t index          : 16;
+		uint64_t length         : 16;
+	} s;
+};
+
+/**
+ * struct cvmx_usb_iso_packet - descriptor for Isochronous packets
+ *
+ * @offset:	This is the offset in bytes into the main buffer where this data
+ *		is stored.
+ * @length:	This is the length in bytes of the data.
+ * @status:	This is the status of this individual packet transfer.
+ */
+struct cvmx_usb_iso_packet {
+	int offset;
+	int length;
+	enum cvmx_usb_complete status;
+};
+
+/**
+ * enum cvmx_usb_callback - possible callback reasons for the USB API
+ *
+ * @CVMX_USB_CALLBACK_TRANSFER_COMPLETE: A callback of this type is called when
+ *					 a submitted transfer completes. The
+ *					 completion callback will be called even
+ *					 if the transfer fails or is canceled.
+ *					 The status parameter will contain
+ *					 details of why he callback was called.
+ * @CVMX_USB_CALLBACK_PORT_CHANGED:	 The status of the port changed. For
+ *					 example, someone may have plugged a
+ *					 device in. The status parameter
+ *					 contains CVMX_USB_COMPLETE_SUCCESS. Use
+ *					 cvmx_usb_get_status() to get the new
+ *					 port status.
+ * @__CVMX_USB_CALLBACK_END:		 Do not use. Used internally for array
+ *					 bounds.
+ */
+enum cvmx_usb_callback {
+	CVMX_USB_CALLBACK_TRANSFER_COMPLETE,
+	CVMX_USB_CALLBACK_PORT_CHANGED,
+	__CVMX_USB_CALLBACK_END
+};
+
+/**
+ * USB state internal data. The contents of this structure
+ * may change in future SDKs. No data in it should be referenced
+ * by user's of this API.
+ */
+struct cvmx_usb_state {
+	char data[65536];
+};
+
+/**
+ * USB callback functions are always of the following type.
+ * The parameters are as follows:
+ *      - state = USB device state populated by
+ *        cvmx_usb_initialize().
+ *      - reason = The enum cvmx_usb_callback used to register
+ *        the callback.
+ *      - status = The enum cvmx_usb_complete representing the
+ *        status code of a transaction.
+ *      - pipe_handle = The Pipe that caused this callback, or
+ *        -1 if this callback wasn't associated with a pipe.
+ *      - submit_handle = Transfer submit handle causing this
+ *        callback, or -1 if this callback wasn't associated
+ *        with a transfer.
+ *      - Actual number of bytes transfer.
+ *      - user_data = The user pointer supplied to the
+ *        function cvmx_usb_submit() or
+ *        cvmx_usb_register_callback() */
+typedef void (*cvmx_usb_callback_func_t)(struct cvmx_usb_state *state,
+                                         enum cvmx_usb_callback reason,
+                                         enum cvmx_usb_complete status,
+                                         int pipe_handle, int submit_handle,
+                                         int bytes_transferred, void *user_data);
+
+/**
+ * enum cvmx_usb_initialize_flags - flags used by the initialization function
+ *
+ * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI:    The USB port uses a 12MHz crystal
+ *					      as clock source at USB_XO and
+ *					      USB_XI.
+ * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND:   The USB port uses 12/24/48MHz 2.5V
+ *					      board clock source at USB_XO.
+ *					      USB_XI should be tied to GND.
+ * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK: Mask for clock speed field
+ * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ:    Speed of reference clock or
+ *					      crystal
+ * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ:    Speed of reference clock
+ * @CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ:    Speed of reference clock
+ * @CVMX_USB_INITIALIZE_FLAGS_NO_DMA:	      Disable DMA and used polled IO for
+ *					      data transfer use for the USB
+ */
+enum cvmx_usb_initialize_flags {
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI		= 1 << 0,
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND		= 1 << 1,
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK	= 3 << 3,
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ		= 1 << 3,
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ		= 2 << 3,
+	CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ		= 3 << 3,
+	/* Bits 3-4 used to encode the clock frequency */
+	CVMX_USB_INITIALIZE_FLAGS_NO_DMA		= 1 << 5,
+};
+
+/**
+ * enum cvmx_usb_pipe_flags - internal flags for a pipe.
+ *
+ * @__CVMX_USB_PIPE_FLAGS_OPEN:	     Used internally to determine if a pipe is
+ *				     open. Do not use.
+ * @__CVMX_USB_PIPE_FLAGS_SCHEDULED: Used internally to determine if a pipe is
+ *				     actively using hardware. Do not use.
+ * @__CVMX_USB_PIPE_FLAGS_NEED_PING: Used internally to determine if a high
+ *				     speed pipe is in the ping state. Do not
+ *				     use.
+ */
+enum cvmx_usb_pipe_flags {
+	__CVMX_USB_PIPE_FLAGS_OPEN	= 1 << 16,
+	__CVMX_USB_PIPE_FLAGS_SCHEDULED	= 1 << 17,
+	__CVMX_USB_PIPE_FLAGS_NEED_PING	= 1 << 18,
+};
+
+/* Normal prefetch that use the pref instruction. */
+#define CVMX_PREFETCH(address, offset) asm volatile ("pref %[type], %[off](%[rbase])" : : [rbase] "d" (address), [off] "I" (offset), [type] "n" (0))
+
+/* Maximum number of times to retry failed transactions */
+#define MAX_RETRIES		3
+
+/* Maximum number of pipes that can be open at once */
+#define MAX_PIPES		32
+
+/* Maximum number of outstanding transactions across all pipes */
+#define MAX_TRANSACTIONS	256
+
+/* Maximum number of hardware channels supported by the USB block */
+#define MAX_CHANNELS		8
+
+/* The highest valid USB device address */
+#define MAX_USB_ADDRESS		127
+
+/* The highest valid USB endpoint number */
+#define MAX_USB_ENDPOINT	15
+
+/* The highest valid port number on a hub */
+#define MAX_USB_HUB_PORT	15
+
+/*
+ * The low level hardware can transfer a maximum of this number of bytes in each
+ * transfer. The field is 19 bits wide
+ */
+#define MAX_TRANSFER_BYTES	((1<<19)-1)
+
+/*
+ * The low level hardware can transfer a maximum of this number of packets in
+ * each transfer. The field is 10 bits wide
+ */
+#define MAX_TRANSFER_PACKETS	((1<<10)-1)
+
+enum cvmx_usb_transaction_flags {
+	__CVMX_USB_TRANSACTION_FLAGS_IN_USE = 1<<16,
+};
+
+enum {
+	USB_CLOCK_TYPE_REF_12,
+	USB_CLOCK_TYPE_REF_24,
+	USB_CLOCK_TYPE_REF_48,
+	USB_CLOCK_TYPE_CRYSTAL_12,
+};
+
+/**
+ * Logical transactions may take numerous low level
+ * transactions, especially when splits are concerned. This
+ * enum represents all of the possible stages a transaction can
+ * be in. Note that split completes are always even. This is so
+ * the NAK handler can backup to the previous low level
+ * transaction with a simple clearing of bit 0.
+ */
+enum cvmx_usb_stage {
+	CVMX_USB_STAGE_NON_CONTROL,
+	CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE,
+	CVMX_USB_STAGE_SETUP,
+	CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE,
+	CVMX_USB_STAGE_DATA,
+	CVMX_USB_STAGE_DATA_SPLIT_COMPLETE,
+	CVMX_USB_STAGE_STATUS,
+	CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE,
+};
+
+/**
+ * struct cvmx_usb_transaction - describes each pending USB transaction
+ *				 regardless of type. These are linked together
+ *				 to form a list of pending requests for a pipe.
+ *
+ * @prev:		Transaction before this one in the pipe.
+ * @next:		Transaction after this one in the pipe.
+ * @type:		Type of transaction, duplicated of the pipe.
+ * @flags:		State flags for this transaction.
+ * @buffer:		User's physical buffer address to read/write.
+ * @buffer_length:	Size of the user's buffer in bytes.
+ * @control_header:	For control transactions, physical address of the 8
+ *			byte standard header.
+ * @iso_start_frame:	For ISO transactions, the starting frame number.
+ * @iso_number_packets:	For ISO transactions, the number of packets in the
+ *			request.
+ * @iso_packets:	For ISO transactions, the sub packets in the request.
+ * @actual_bytes:	Actual bytes transfer for this transaction.
+ * @stage:		For control transactions, the current stage.
+ * @callback:		User's callback function when complete.
+ * @callback_data:	User's data.
+ */
+struct cvmx_usb_transaction {
+	struct cvmx_usb_transaction *prev;
+	struct cvmx_usb_transaction *next;
+	enum cvmx_usb_transfer type;
+	enum cvmx_usb_transaction_flags flags;
+	uint64_t buffer;
+	int buffer_length;
+	uint64_t control_header;
+	int iso_start_frame;
+	int iso_number_packets;
+	struct cvmx_usb_iso_packet *iso_packets;
+	int xfersize;
+	int pktcnt;
+	int retries;
+	int actual_bytes;
+	enum cvmx_usb_stage stage;
+	cvmx_usb_callback_func_t callback;
+	void *callback_data;
+};
+
+/**
+ * struct cvmx_usb_pipe - a pipe represents a virtual connection between Octeon
+ *			  and some USB device. It contains a list of pending
+ *			  request to the device.
+ *
+ * @prev:		Pipe before this one in the list
+ * @next:		Pipe after this one in the list
+ * @head:		The first pending transaction
+ * @tail:		The last pending transaction
+ * @interval:		For periodic pipes, the interval between packets in
+ *			frames
+ * @next_tx_frame:	The next frame this pipe is allowed to transmit on
+ * @flags:		State flags for this pipe
+ * @device_speed:	Speed of device connected to this pipe
+ * @transfer_type:	Type of transaction supported by this pipe
+ * @transfer_dir:	IN or OUT. Ignored for Control
+ * @multi_count:	Max packet in a row for the device
+ * @max_packet:		The device's maximum packet size in bytes
+ * @device_addr:	USB device address at other end of pipe
+ * @endpoint_num:	USB endpoint number at other end of pipe
+ * @hub_device_addr:	Hub address this device is connected to
+ * @hub_port:		Hub port this device is connected to
+ * @pid_toggle:		This toggles between 0/1 on every packet send to track
+ *			the data pid needed
+ * @channel:		Hardware DMA channel for this pipe
+ * @split_sc_frame:	The low order bits of the frame number the split
+ *			complete should be sent on
+ */
+struct cvmx_usb_pipe {
+	struct cvmx_usb_pipe *prev;
+	struct cvmx_usb_pipe *next;
+	struct cvmx_usb_transaction *head;
+	struct cvmx_usb_transaction *tail;
+	uint64_t interval;
+	uint64_t next_tx_frame;
+	enum cvmx_usb_pipe_flags flags;
+	enum cvmx_usb_speed device_speed;
+	enum cvmx_usb_transfer transfer_type;
+	enum cvmx_usb_direction transfer_dir;
+	int multi_count;
+	uint16_t max_packet;
+	uint8_t device_addr;
+	uint8_t endpoint_num;
+	uint8_t hub_device_addr;
+	uint8_t hub_port;
+	uint8_t pid_toggle;
+	uint8_t channel;
+	int8_t split_sc_frame;
+};
+
+/**
+ * struct cvmx_usb_pipe_list
+ *
+ * @head: Head of the list, or NULL if empty.
+ * @tail: Tail if the list, or NULL if empty.
+ */
+struct cvmx_usb_pipe_list {
+	struct cvmx_usb_pipe *head;
+	struct cvmx_usb_pipe *tail;
+};
+
+struct cvmx_usb_tx_fifo {
+	struct {
+		int channel;
+		int size;
+		uint64_t address;
+	} entry[MAX_CHANNELS+1];
+	int head;
+	int tail;
+};
+
+/**
+ * struct cvmx_usb_internal_state - the state of the USB block
+ *
+ * init_flags:		   Flags passed to initialize.
+ * index:		   Which USB block this is for.
+ * idle_hardware_channels: Bit set for every idle hardware channel.
+ * usbcx_hprt:		   Stored port status so we don't need to read a CSR to
+ *			   determine splits.
+ * pipe_for_channel:	   Map channels to pipes.
+ * free_transaction_head:  List of free transactions head.
+ * free_transaction_tail:  List of free transactions tail.
+ * pipe:		   Storage for pipes.
+ * transaction:		   Storage for transactions.
+ * callback:		   User global callbacks.
+ * callback_data:	   User data for each callback.
+ * indent:		   Used by debug output to indent functions.
+ * port_status:		   Last port status used for change notification.
+ * free_pipes:		   List of all pipes that are currently closed.
+ * idle_pipes:		   List of open pipes that have no transactions.
+ * active_pipes:	   Active pipes indexed by transfer type.
+ * frame_number:	   Increments every SOF interrupt for time keeping.
+ * active_split:	   Points to the current active split, or NULL.
+ */
+struct cvmx_usb_internal_state {
+	int init_flags;
+	int index;
+	int idle_hardware_channels;
+	union cvmx_usbcx_hprt usbcx_hprt;
+	struct cvmx_usb_pipe *pipe_for_channel[MAX_CHANNELS];
+	struct cvmx_usb_transaction *free_transaction_head;
+	struct cvmx_usb_transaction *free_transaction_tail;
+	struct cvmx_usb_pipe pipe[MAX_PIPES];
+	struct cvmx_usb_transaction transaction[MAX_TRANSACTIONS];
+	cvmx_usb_callback_func_t callback[__CVMX_USB_CALLBACK_END];
+	void *callback_data[__CVMX_USB_CALLBACK_END];
+	int indent;
+	struct cvmx_usb_port_status port_status;
+	struct cvmx_usb_pipe_list free_pipes;
+	struct cvmx_usb_pipe_list idle_pipes;
+	struct cvmx_usb_pipe_list active_pipes[4];
+	uint64_t frame_number;
+	struct cvmx_usb_transaction *active_split;
+	struct cvmx_usb_tx_fifo periodic;
+	struct cvmx_usb_tx_fifo nonperiodic;
+};
+
 struct octeon_hcd {
 	spinlock_t lock;
 	struct cvmx_usb_state usb;
@@ -31,6 +538,2914 @@ struct octeon_hcd {
 	struct list_head dequeue_list;
 };
 
+/* This macro spins on a field waiting for it to reach a value */
+#define CVMX_WAIT_FOR_FIELD32(address, type, field, op, value, timeout_usec)\
+	({int result;							    \
+	do {								    \
+		uint64_t done = cvmx_get_cycle() + (uint64_t)timeout_usec * \
+			octeon_get_clock_rate() / 1000000;		    \
+		type c;							    \
+		while (1) {						    \
+			c.u32 = __cvmx_usb_read_csr32(usb, address);	    \
+			if (c.s.field op (value)) {			    \
+				result = 0;				    \
+				break;					    \
+			} else if (cvmx_get_cycle() > done) {		    \
+				result = -1;				    \
+				break;					    \
+			} else						    \
+				cvmx_wait(100);				    \
+		}							    \
+	} while (0);							    \
+	result; })
+
+/*
+ * This macro logically sets a single field in a CSR. It does the sequence
+ * read, modify, and write
+ */
+#define USB_SET_FIELD32(address, type, field, value)		\
+	do {							\
+		type c;						\
+		c.u32 = __cvmx_usb_read_csr32(usb, address);	\
+		c.s.field = value;				\
+		__cvmx_usb_write_csr32(usb, address, c.u32);	\
+	} while (0)
+
+/* Returns the IO address to push/pop stuff data from the FIFOs */
+#define USB_FIFO_ADDRESS(channel, usb_index) (CVMX_USBCX_GOTGCTL(usb_index) + ((channel)+1)*0x1000)
+
+static int octeon_usb_get_clock_type(void)
+{
+	switch (cvmx_sysinfo_get()->board_type) {
+	case CVMX_BOARD_TYPE_BBGW_REF:
+	case CVMX_BOARD_TYPE_LANAI2_A:
+	case CVMX_BOARD_TYPE_LANAI2_U:
+	case CVMX_BOARD_TYPE_LANAI2_G:
+	case CVMX_BOARD_TYPE_UBNT_E100:
+		return USB_CLOCK_TYPE_CRYSTAL_12;
+	}
+	return USB_CLOCK_TYPE_REF_48;
+}
+
+/**
+ * Read a USB 32bit CSR. It performs the necessary address swizzle
+ * for 32bit CSRs and logs the value in a readable format if
+ * debugging is on.
+ *
+ * @usb:     USB block this access is for
+ * @address: 64bit address to read
+ *
+ * Returns: Result of the read
+ */
+static inline uint32_t __cvmx_usb_read_csr32(struct cvmx_usb_internal_state *usb,
+					     uint64_t address)
+{
+	uint32_t result = cvmx_read64_uint32(address ^ 4);
+	return result;
+}
+
+
+/**
+ * Write a USB 32bit CSR. It performs the necessary address
+ * swizzle for 32bit CSRs and logs the value in a readable format
+ * if debugging is on.
+ *
+ * @usb:     USB block this access is for
+ * @address: 64bit address to write
+ * @value:   Value to write
+ */
+static inline void __cvmx_usb_write_csr32(struct cvmx_usb_internal_state *usb,
+					  uint64_t address, uint32_t value)
+{
+	cvmx_write64_uint32(address ^ 4, value);
+	cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
+}
+
+
+/**
+ * Read a USB 64bit CSR. It logs the value in a readable format if
+ * debugging is on.
+ *
+ * @usb:     USB block this access is for
+ * @address: 64bit address to read
+ *
+ * Returns: Result of the read
+ */
+static inline uint64_t __cvmx_usb_read_csr64(struct cvmx_usb_internal_state *usb,
+					     uint64_t address)
+{
+	uint64_t result = cvmx_read64_uint64(address);
+	return result;
+}
+
+
+/**
+ * Write a USB 64bit CSR. It logs the value in a readable format
+ * if debugging is on.
+ *
+ * @usb:     USB block this access is for
+ * @address: 64bit address to write
+ * @value:   Value to write
+ */
+static inline void __cvmx_usb_write_csr64(struct cvmx_usb_internal_state *usb,
+					  uint64_t address, uint64_t value)
+{
+	cvmx_write64_uint64(address, value);
+}
+
+/**
+ * Return non zero if this pipe connects to a non HIGH speed
+ * device through a high speed hub.
+ *
+ * @usb:    USB block this access is for
+ * @pipe:   Pipe to check
+ *
+ * Returns: Non zero if we need to do split transactions
+ */
+static inline int __cvmx_usb_pipe_needs_split(struct cvmx_usb_internal_state *usb, struct cvmx_usb_pipe *pipe)
+{
+	return ((pipe->device_speed != CVMX_USB_SPEED_HIGH) && (usb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_HIGH));
+}
+
+
+/**
+ * Trivial utility function to return the correct PID for a pipe
+ *
+ * @pipe:   pipe to check
+ *
+ * Returns: PID for pipe
+ */
+static inline int __cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)
+{
+	if (pipe->pid_toggle)
+		return 2; /* Data1 */
+	else
+		return 0; /* Data0 */
+}
+
+
+/**
+ * Return the number of USB ports supported by this Octeon
+ * chip. If the chip doesn't support USB, or is not supported
+ * by this API, a zero will be returned. Most Octeon chips
+ * support one usb port, but some support two ports.
+ * cvmx_usb_initialize() must be called on independent
+ * struct cvmx_usb_state.
+ *
+ * Returns: Number of port, zero if usb isn't supported
+ */
+static int cvmx_usb_get_num_ports(void)
+{
+	int arch_ports = 0;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN56XX))
+		arch_ports = 1;
+	else if (OCTEON_IS_MODEL(OCTEON_CN52XX))
+		arch_ports = 2;
+	else if (OCTEON_IS_MODEL(OCTEON_CN50XX))
+		arch_ports = 1;
+	else if (OCTEON_IS_MODEL(OCTEON_CN31XX))
+		arch_ports = 1;
+	else if (OCTEON_IS_MODEL(OCTEON_CN30XX))
+		arch_ports = 1;
+	else
+		arch_ports = 0;
+
+	return arch_ports;
+}
+
+
+/**
+ * Allocate a usb transaction for use
+ *
+ * @usb:	 USB device state populated by
+ *		 cvmx_usb_initialize().
+ *
+ * Returns: Transaction or NULL
+ */
+static inline struct cvmx_usb_transaction *__cvmx_usb_alloc_transaction(struct cvmx_usb_internal_state *usb)
+{
+	struct cvmx_usb_transaction *t;
+	t = usb->free_transaction_head;
+	if (t) {
+		usb->free_transaction_head = t->next;
+		if (!usb->free_transaction_head)
+			usb->free_transaction_tail = NULL;
+	}
+	if (t) {
+		memset(t, 0, sizeof(*t));
+		t->flags = __CVMX_USB_TRANSACTION_FLAGS_IN_USE;
+	}
+	return t;
+}
+
+
+/**
+ * Free a usb transaction
+ *
+ * @usb:	 USB device state populated by
+ *		 cvmx_usb_initialize().
+ * @transaction:
+ *		 Transaction to free
+ */
+static inline void __cvmx_usb_free_transaction(struct cvmx_usb_internal_state *usb,
+					       struct cvmx_usb_transaction *transaction)
+{
+	transaction->flags = 0;
+	transaction->prev = NULL;
+	transaction->next = NULL;
+	if (usb->free_transaction_tail)
+		usb->free_transaction_tail->next = transaction;
+	else
+		usb->free_transaction_head = transaction;
+	usb->free_transaction_tail = transaction;
+}
+
+
+/**
+ * Add a pipe to the tail of a list
+ * @list:   List to add pipe to
+ * @pipe:   Pipe to add
+ */
+static inline void __cvmx_usb_append_pipe(struct cvmx_usb_pipe_list *list, struct cvmx_usb_pipe *pipe)
+{
+	pipe->next = NULL;
+	pipe->prev = list->tail;
+	if (list->tail)
+		list->tail->next = pipe;
+	else
+		list->head = pipe;
+	list->tail = pipe;
+}
+
+
+/**
+ * Remove a pipe from a list
+ * @list:   List to remove pipe from
+ * @pipe:   Pipe to remove
+ */
+static inline void __cvmx_usb_remove_pipe(struct cvmx_usb_pipe_list *list, struct cvmx_usb_pipe *pipe)
+{
+	if (list->head == pipe) {
+		list->head = pipe->next;
+		pipe->next = NULL;
+		if (list->head)
+			list->head->prev = NULL;
+		else
+			list->tail = NULL;
+	} else if (list->tail == pipe) {
+		list->tail = pipe->prev;
+		list->tail->next = NULL;
+		pipe->prev = NULL;
+	} else {
+		pipe->prev->next = pipe->next;
+		pipe->next->prev = pipe->prev;
+		pipe->prev = NULL;
+		pipe->next = NULL;
+	}
+}
+
+
+/**
+ * Initialize a USB port for use. This must be called before any
+ * other access to the Octeon USB port is made. The port starts
+ * off in the disabled state.
+ *
+ * @state:	 Pointer to an empty struct cvmx_usb_state
+ *		 that will be populated by the initialize call.
+ *		 This structure is then passed to all other USB
+ *		 functions.
+ * @usb_port_number:
+ *		 Which Octeon USB port to initialize.
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_initialize(struct cvmx_usb_state *state,
+			       int usb_port_number)
+{
+	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
+	union cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+	enum cvmx_usb_initialize_flags flags = 0;
+
+	/* Make sure that state is large enough to store the internal state */
+	if (sizeof(*state) < sizeof(*usb))
+		return -EINVAL;
+	/* At first allow 0-1 for the usb port number */
+	if ((usb_port_number < 0) || (usb_port_number > 1))
+		return -EINVAL;
+	/* For all chips except 52XX there is only one port */
+	if (!OCTEON_IS_MODEL(OCTEON_CN52XX) && (usb_port_number > 0))
+		return -EINVAL;
+	/* Try to determine clock type automatically */
+	if (octeon_usb_get_clock_type() == USB_CLOCK_TYPE_CRYSTAL_12) {
+		/* Only 12 MHZ crystals are supported */
+		flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI;
+	} else {
+		flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND;
+
+		switch (octeon_usb_get_clock_type()) {
+		case USB_CLOCK_TYPE_REF_12:
+			flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ;
+			break;
+		case USB_CLOCK_TYPE_REF_24:
+			flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ;
+			break;
+		case USB_CLOCK_TYPE_REF_48:
+			flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ;
+			break;
+		default:
+			return -EINVAL;
+			break;
+		}
+	}
+
+	memset(usb, 0, sizeof(*usb));
+	usb->init_flags = flags;
+
+	/* Initialize the USB state structure */
+	{
+		int i;
+		usb->index = usb_port_number;
+
+		/* Initialize the transaction double linked list */
+		usb->free_transaction_head = NULL;
+		usb->free_transaction_tail = NULL;
+		for (i = 0; i < MAX_TRANSACTIONS; i++)
+			__cvmx_usb_free_transaction(usb, usb->transaction + i);
+		for (i = 0; i < MAX_PIPES; i++)
+			__cvmx_usb_append_pipe(&usb->free_pipes, usb->pipe + i);
+	}
+
+	/*
+	 * Power On Reset and PHY Initialization
+	 *
+	 * 1. Wait for DCOK to assert (nothing to do)
+	 *
+	 * 2a. Write USBN0/1_CLK_CTL[POR] = 1 and
+	 *     USBN0/1_CLK_CTL[HRST,PRST,HCLK_RST] = 0
+	 */
+	usbn_clk_ctl.u64 = __cvmx_usb_read_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index));
+	usbn_clk_ctl.s.por = 1;
+	usbn_clk_ctl.s.hrst = 0;
+	usbn_clk_ctl.s.prst = 0;
+	usbn_clk_ctl.s.hclk_rst = 0;
+	usbn_clk_ctl.s.enable = 0;
+	/*
+	 * 2b. Select the USB reference clock/crystal parameters by writing
+	 *     appropriate values to USBN0/1_CLK_CTL[P_C_SEL, P_RTYPE, P_COM_ON]
+	 */
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND) {
+		/*
+		 * The USB port uses 12/24/48MHz 2.5V board clock
+		 * source at USB_XO. USB_XI should be tied to GND.
+		 * Most Octeon evaluation boards require this setting
+		 */
+		if (OCTEON_IS_MODEL(OCTEON_CN3XXX)) {
+			/* From CN31XX,CN30XX manual */
+			usbn_clk_ctl.cn31xx.p_rclk  = 1;
+			usbn_clk_ctl.cn31xx.p_xenbn = 0;
+		} else if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN50XX))
+			/* From CN56XX,CN50XX manual */
+			usbn_clk_ctl.cn56xx.p_rtype = 2;
+		else
+			/* From CN52XX manual */
+			usbn_clk_ctl.cn52xx.p_rtype = 1;
+
+		switch (flags & CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK) {
+		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ:
+			usbn_clk_ctl.s.p_c_sel = 0;
+			break;
+		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ:
+			usbn_clk_ctl.s.p_c_sel = 1;
+			break;
+		case CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ:
+			usbn_clk_ctl.s.p_c_sel = 2;
+			break;
+		}
+	} else {
+		/*
+		 * The USB port uses a 12MHz crystal as clock source
+		 * at USB_XO and USB_XI
+		 */
+		if (OCTEON_IS_MODEL(OCTEON_CN3XXX)) {
+			/* From CN31XX,CN30XX manual */
+			usbn_clk_ctl.cn31xx.p_rclk  = 1;
+			usbn_clk_ctl.cn31xx.p_xenbn = 1;
+		} else if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN50XX))
+			/* From CN56XX,CN50XX manual */
+			usbn_clk_ctl.cn56xx.p_rtype = 0;
+		else
+			/* From CN52XX manual */
+			usbn_clk_ctl.cn52xx.p_rtype = 0;
+
+		usbn_clk_ctl.s.p_c_sel = 0;
+	}
+	/*
+	 * 2c. Select the HCLK via writing USBN0/1_CLK_CTL[DIVIDE, DIVIDE2] and
+	 *     setting USBN0/1_CLK_CTL[ENABLE] = 1. Divide the core clock down
+	 *     such that USB is as close as possible to 125Mhz
+	 */
+	{
+		int divisor = (octeon_get_clock_rate()+125000000-1)/125000000;
+		/* Lower than 4 doesn't seem to work properly */
+		if (divisor < 4)
+			divisor = 4;
+		usbn_clk_ctl.s.divide = divisor;
+		usbn_clk_ctl.s.divide2 = 0;
+	}
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
+			       usbn_clk_ctl.u64);
+	/* 2d. Write USBN0/1_CLK_CTL[HCLK_RST] = 1 */
+	usbn_clk_ctl.s.hclk_rst = 1;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
+			       usbn_clk_ctl.u64);
+	/* 2e.  Wait 64 core-clock cycles for HCLK to stabilize */
+	cvmx_wait(64);
+	/*
+	 * 3. Program the power-on reset field in the USBN clock-control
+	 *    register:
+	 *    USBN_CLK_CTL[POR] = 0
+	 */
+	usbn_clk_ctl.s.por = 0;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
+			       usbn_clk_ctl.u64);
+	/* 4. Wait 1 ms for PHY clock to start */
+	mdelay(1);
+	/*
+	 * 5. Program the Reset input from automatic test equipment field in the
+	 *    USBP control and status register:
+	 *    USBN_USBP_CTL_STATUS[ATE_RESET] = 1
+	 */
+	usbn_usbp_ctl_status.u64 = __cvmx_usb_read_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index));
+	usbn_usbp_ctl_status.s.ate_reset = 1;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index),
+			       usbn_usbp_ctl_status.u64);
+	/* 6. Wait 10 cycles */
+	cvmx_wait(10);
+	/*
+	 * 7. Clear ATE_RESET field in the USBN clock-control register:
+	 *    USBN_USBP_CTL_STATUS[ATE_RESET] = 0
+	 */
+	usbn_usbp_ctl_status.s.ate_reset = 0;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index),
+			       usbn_usbp_ctl_status.u64);
+	/*
+	 * 8. Program the PHY reset field in the USBN clock-control register:
+	 *    USBN_CLK_CTL[PRST] = 1
+	 */
+	usbn_clk_ctl.s.prst = 1;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
+			       usbn_clk_ctl.u64);
+	/*
+	 * 9. Program the USBP control and status register to select host or
+	 *    device mode. USBN_USBP_CTL_STATUS[HST_MODE] = 0 for host, = 1 for
+	 *    device
+	 */
+	usbn_usbp_ctl_status.s.hst_mode = 0;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_USBP_CTL_STATUS(usb->index),
+			       usbn_usbp_ctl_status.u64);
+	/* 10. Wait 1 us */
+	udelay(1);
+	/*
+	 * 11. Program the hreset_n field in the USBN clock-control register:
+	 *     USBN_CLK_CTL[HRST] = 1
+	 */
+	usbn_clk_ctl.s.hrst = 1;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
+			       usbn_clk_ctl.u64);
+	/* 12. Proceed to USB core initialization */
+	usbn_clk_ctl.s.enable = 1;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
+			       usbn_clk_ctl.u64);
+	udelay(1);
+
+	/*
+	 * USB Core Initialization
+	 *
+	 * 1. Read USBC_GHWCFG1, USBC_GHWCFG2, USBC_GHWCFG3, USBC_GHWCFG4 to
+	 *    determine USB core configuration parameters.
+	 *
+	 *    Nothing needed
+	 *
+	 * 2. Program the following fields in the global AHB configuration
+	 *    register (USBC_GAHBCFG)
+	 *    DMA mode, USBC_GAHBCFG[DMAEn]: 1 = DMA mode, 0 = slave mode
+	 *    Burst length, USBC_GAHBCFG[HBSTLEN] = 0
+	 *    Nonperiodic TxFIFO empty level (slave mode only),
+	 *    USBC_GAHBCFG[NPTXFEMPLVL]
+	 *    Periodic TxFIFO empty level (slave mode only),
+	 *    USBC_GAHBCFG[PTXFEMPLVL]
+	 *    Global interrupt mask, USBC_GAHBCFG[GLBLINTRMSK] = 1
+	 */
+	{
+		union cvmx_usbcx_gahbcfg usbcx_gahbcfg;
+		/* Due to an errata, CN31XX doesn't support DMA */
+		if (OCTEON_IS_MODEL(OCTEON_CN31XX))
+			usb->init_flags |= CVMX_USB_INITIALIZE_FLAGS_NO_DMA;
+		usbcx_gahbcfg.u32 = 0;
+		usbcx_gahbcfg.s.dmaen = !(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA);
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+			/* Only use one channel with non DMA */
+			usb->idle_hardware_channels = 0x1;
+		else if (OCTEON_IS_MODEL(OCTEON_CN5XXX))
+			/* CN5XXX have an errata with channel 3 */
+			usb->idle_hardware_channels = 0xf7;
+		else
+			usb->idle_hardware_channels = 0xff;
+		usbcx_gahbcfg.s.hbstlen = 0;
+		usbcx_gahbcfg.s.nptxfemplvl = 1;
+		usbcx_gahbcfg.s.ptxfemplvl = 1;
+		usbcx_gahbcfg.s.glblintrmsk = 1;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GAHBCFG(usb->index),
+				       usbcx_gahbcfg.u32);
+	}
+	/*
+	 * 3. Program the following fields in USBC_GUSBCFG register.
+	 *    HS/FS timeout calibration, USBC_GUSBCFG[TOUTCAL] = 0
+	 *    ULPI DDR select, USBC_GUSBCFG[DDRSEL] = 0
+	 *    USB turnaround time, USBC_GUSBCFG[USBTRDTIM] = 0x5
+	 *    PHY low-power clock select, USBC_GUSBCFG[PHYLPWRCLKSEL] = 0
+	 */
+	{
+		union cvmx_usbcx_gusbcfg usbcx_gusbcfg;
+		usbcx_gusbcfg.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index));
+		usbcx_gusbcfg.s.toutcal = 0;
+		usbcx_gusbcfg.s.ddrsel = 0;
+		usbcx_gusbcfg.s.usbtrdtim = 0x5;
+		usbcx_gusbcfg.s.phylpwrclksel = 0;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index),
+				       usbcx_gusbcfg.u32);
+	}
+	/*
+	 * 4. The software must unmask the following bits in the USBC_GINTMSK
+	 *    register.
+	 *    OTG interrupt mask, USBC_GINTMSK[OTGINTMSK] = 1
+	 *    Mode mismatch interrupt mask, USBC_GINTMSK[MODEMISMSK] = 1
+	 */
+	{
+		union cvmx_usbcx_gintmsk usbcx_gintmsk;
+		int channel;
+
+		usbcx_gintmsk.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GINTMSK(usb->index));
+		usbcx_gintmsk.s.otgintmsk = 1;
+		usbcx_gintmsk.s.modemismsk = 1;
+		usbcx_gintmsk.s.hchintmsk = 1;
+		usbcx_gintmsk.s.sofmsk = 0;
+		/* We need RX FIFO interrupts if we don't have DMA */
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+			usbcx_gintmsk.s.rxflvlmsk = 1;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTMSK(usb->index),
+				       usbcx_gintmsk.u32);
+
+		/*
+		 * Disable all channel interrupts. We'll enable them per channel
+		 * later.
+		 */
+		for (channel = 0; channel < 8; channel++)
+			__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
+	}
+
+	{
+		/*
+		 * Host Port Initialization
+		 *
+		 * 1. Program the host-port interrupt-mask field to unmask,
+		 *    USBC_GINTMSK[PRTINT] = 1
+		 */
+		USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk,
+				prtintmsk, 1);
+		USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk,
+				disconnintmsk, 1);
+		/*
+		 * 2. Program the USBC_HCFG register to select full-speed host
+		 *    or high-speed host.
+		 */
+		{
+			union cvmx_usbcx_hcfg usbcx_hcfg;
+			usbcx_hcfg.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCFG(usb->index));
+			usbcx_hcfg.s.fslssupp = 0;
+			usbcx_hcfg.s.fslspclksel = 0;
+			__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCFG(usb->index), usbcx_hcfg.u32);
+		}
+		/*
+		 * 3. Program the port power bit to drive VBUS on the USB,
+		 *    USBC_HPRT[PRTPWR] = 1
+		 */
+		USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtpwr, 1);
+
+		/*
+		 * Steps 4-15 from the manual are done later in the port enable
+		 */
+	}
+
+	return 0;
+}
+
+
+/**
+ * Shutdown a USB port after a call to cvmx_usb_initialize().
+ * The port should be disabled with all pipes closed when this
+ * function is called.
+ *
+ * @state: USB device state populated by
+ *	   cvmx_usb_initialize().
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_shutdown(struct cvmx_usb_state *state)
+{
+	union cvmx_usbnx_clk_ctl usbn_clk_ctl;
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+
+	/* Make sure all pipes are closed */
+	if (usb->idle_pipes.head ||
+		usb->active_pipes[CVMX_USB_TRANSFER_ISOCHRONOUS].head ||
+		usb->active_pipes[CVMX_USB_TRANSFER_INTERRUPT].head ||
+		usb->active_pipes[CVMX_USB_TRANSFER_CONTROL].head ||
+		usb->active_pipes[CVMX_USB_TRANSFER_BULK].head)
+		return -EBUSY;
+
+	/* Disable the clocks and put them in power on reset */
+	usbn_clk_ctl.u64 = __cvmx_usb_read_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index));
+	usbn_clk_ctl.s.enable = 1;
+	usbn_clk_ctl.s.por = 1;
+	usbn_clk_ctl.s.hclk_rst = 1;
+	usbn_clk_ctl.s.prst = 0;
+	usbn_clk_ctl.s.hrst = 0;
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
+			       usbn_clk_ctl.u64);
+	return 0;
+}
+
+
+/**
+ * Enable a USB port. After this call succeeds, the USB port is
+ * online and servicing requests.
+ *
+ * @state: USB device state populated by
+ *	   cvmx_usb_initialize().
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_enable(struct cvmx_usb_state *state)
+{
+	union cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+
+	usb->usbcx_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+
+	/*
+	 * If the port is already enabled the just return. We don't need to do
+	 * anything
+	 */
+	if (usb->usbcx_hprt.s.prtena)
+		return 0;
+
+	/* If there is nothing plugged into the port then fail immediately */
+	if (!usb->usbcx_hprt.s.prtconnsts) {
+		return -ETIMEDOUT;
+	}
+
+	/* Program the port reset bit to start the reset process */
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtrst, 1);
+
+	/*
+	 * Wait at least 50ms (high speed), or 10ms (full speed) for the reset
+	 * process to complete.
+	 */
+	mdelay(50);
+
+	/* Program the port reset bit to 0, USBC_HPRT[PRTRST] = 0 */
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtrst, 0);
+
+	/* Wait for the USBC_HPRT[PRTENA]. */
+	if (CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt,
+				  prtena, ==, 1, 100000))
+		return -ETIMEDOUT;
+
+	/*
+	 * Read the port speed field to get the enumerated speed,
+	 * USBC_HPRT[PRTSPD].
+	 */
+	usb->usbcx_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+	usbcx_ghwcfg3.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GHWCFG3(usb->index));
+
+	/*
+	 * 13. Program the USBC_GRXFSIZ register to select the size of the
+	 *     receive FIFO (25%).
+	 */
+	USB_SET_FIELD32(CVMX_USBCX_GRXFSIZ(usb->index), union cvmx_usbcx_grxfsiz,
+			rxfdep, usbcx_ghwcfg3.s.dfifodepth / 4);
+	/*
+	 * 14. Program the USBC_GNPTXFSIZ register to select the size and the
+	 *     start address of the non- periodic transmit FIFO for nonperiodic
+	 *     transactions (50%).
+	 */
+	{
+		union cvmx_usbcx_gnptxfsiz siz;
+		siz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index));
+		siz.s.nptxfdep = usbcx_ghwcfg3.s.dfifodepth / 2;
+		siz.s.nptxfstaddr = usbcx_ghwcfg3.s.dfifodepth / 4;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index), siz.u32);
+	}
+	/*
+	 * 15. Program the USBC_HPTXFSIZ register to select the size and start
+	 *     address of the periodic transmit FIFO for periodic transactions
+	 *     (25%).
+	 */
+	{
+		union cvmx_usbcx_hptxfsiz siz;
+		siz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index));
+		siz.s.ptxfsize = usbcx_ghwcfg3.s.dfifodepth / 4;
+		siz.s.ptxfstaddr = 3 * usbcx_ghwcfg3.s.dfifodepth / 4;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index), siz.u32);
+	}
+	/* Flush all FIFOs */
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl, txfnum, 0x10);
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl, txfflsh, 1);
+	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl,
+			      txfflsh, ==, 0, 100);
+	USB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl, rxfflsh, 1);
+	CVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index), union cvmx_usbcx_grstctl,
+			      rxfflsh, ==, 0, 100);
+
+	return 0;
+}
+
+
+/**
+ * Disable a USB port. After this call the USB port will not
+ * generate data transfers and will not generate events.
+ * Transactions in process will fail and call their
+ * associated callbacks.
+ *
+ * @state: USB device state populated by
+ *	   cvmx_usb_initialize().
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_disable(struct cvmx_usb_state *state)
+{
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+
+	/* Disable the port */
+	USB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), union cvmx_usbcx_hprt, prtena, 1);
+	return 0;
+}
+
+
+/**
+ * Get the current state of the USB port. Use this call to
+ * determine if the usb port has anything connected, is enabled,
+ * or has some sort of error condition. The return value of this
+ * call has "changed" bits to signal of the value of some fields
+ * have changed between calls. These "changed" fields are based
+ * on the last call to cvmx_usb_set_status(). In order to clear
+ * them, you must update the status through cvmx_usb_set_status().
+ *
+ * @state: USB device state populated by
+ *	   cvmx_usb_initialize().
+ *
+ * Returns: Port status information
+ */
+static struct cvmx_usb_port_status cvmx_usb_get_status(struct cvmx_usb_state *state)
+{
+	union cvmx_usbcx_hprt usbc_hprt;
+	struct cvmx_usb_port_status result;
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+
+	memset(&result, 0, sizeof(result));
+
+	usbc_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+	result.port_enabled = usbc_hprt.s.prtena;
+	result.port_over_current = usbc_hprt.s.prtovrcurract;
+	result.port_powered = usbc_hprt.s.prtpwr;
+	result.port_speed = usbc_hprt.s.prtspd;
+	result.connected = usbc_hprt.s.prtconnsts;
+	result.connect_change = (result.connected != usb->port_status.connected);
+
+	return result;
+}
+
+
+/**
+ * Set the current state of the USB port. The status is used as
+ * a reference for the "changed" bits returned by
+ * cvmx_usb_get_status(). Other than serving as a reference, the
+ * status passed to this function is not used. No fields can be
+ * changed through this call.
+ *
+ * @state:	 USB device state populated by
+ *		 cvmx_usb_initialize().
+ * @port_status:
+ *		 Port status to set, most like returned by cvmx_usb_get_status()
+ */
+static void cvmx_usb_set_status(struct cvmx_usb_state *state,
+				struct cvmx_usb_port_status port_status)
+{
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+	usb->port_status = port_status;
+	return;
+}
+
+
+/**
+ * Convert a USB transaction into a handle
+ *
+ * @usb:	 USB device state populated by
+ *		 cvmx_usb_initialize().
+ * @transaction:
+ *		 Transaction to get handle for
+ *
+ * Returns: Handle
+ */
+static inline int __cvmx_usb_get_submit_handle(struct cvmx_usb_internal_state *usb,
+					       struct cvmx_usb_transaction *transaction)
+{
+	return ((unsigned long)transaction - (unsigned long)usb->transaction) /
+			sizeof(*transaction);
+}
+
+
+/**
+ * Convert a USB pipe into a handle
+ *
+ * @usb:	 USB device state populated by
+ *		 cvmx_usb_initialize().
+ * @pipe:	 Pipe to get handle for
+ *
+ * Returns: Handle
+ */
+static inline int __cvmx_usb_get_pipe_handle(struct cvmx_usb_internal_state *usb,
+					     struct cvmx_usb_pipe *pipe)
+{
+	return ((unsigned long)pipe - (unsigned long)usb->pipe) / sizeof(*pipe);
+}
+
+
+/**
+ * Open a virtual pipe between the host and a USB device. A pipe
+ * must be opened before data can be transferred between a device
+ * and Octeon.
+ *
+ * @state:	     USB device state populated by
+ *		     cvmx_usb_initialize().
+ * @device_addr:
+ *		     USB device address to open the pipe to
+ *		     (0-127).
+ * @endpoint_num:
+ *		     USB endpoint number to open the pipe to
+ *		     (0-15).
+ * @device_speed:
+ *		     The speed of the device the pipe is going
+ *		     to. This must match the device's speed,
+ *		     which may be different than the port speed.
+ * @max_packet:	     The maximum packet length the device can
+ *		     transmit/receive (low speed=0-8, full
+ *		     speed=0-1023, high speed=0-1024). This value
+ *		     comes from the standard endpoint descriptor
+ *		     field wMaxPacketSize bits <10:0>.
+ * @transfer_type:
+ *		     The type of transfer this pipe is for.
+ * @transfer_dir:
+ *		     The direction the pipe is in. This is not
+ *		     used for control pipes.
+ * @interval:	     For ISOCHRONOUS and INTERRUPT transfers,
+ *		     this is how often the transfer is scheduled
+ *		     for. All other transfers should specify
+ *		     zero. The units are in frames (8000/sec at
+ *		     high speed, 1000/sec for full speed).
+ * @multi_count:
+ *		     For high speed devices, this is the maximum
+ *		     allowed number of packet per microframe.
+ *		     Specify zero for non high speed devices. This
+ *		     value comes from the standard endpoint descriptor
+ *		     field wMaxPacketSize bits <12:11>.
+ * @hub_device_addr:
+ *		     Hub device address this device is connected
+ *		     to. Devices connected directly to Octeon
+ *		     use zero. This is only used when the device
+ *		     is full/low speed behind a high speed hub.
+ *		     The address will be of the high speed hub,
+ *		     not and full speed hubs after it.
+ * @hub_port:	     Which port on the hub the device is
+ *		     connected. Use zero for devices connected
+ *		     directly to Octeon. Like hub_device_addr,
+ *		     this is only used for full/low speed
+ *		     devices behind a high speed hub.
+ *
+ * Returns: A non negative value is a pipe handle. Negative
+ *	    values are error codes.
+ */
+static int cvmx_usb_open_pipe(struct cvmx_usb_state *state,
+			      int device_addr, int endpoint_num,
+			      enum cvmx_usb_speed device_speed, int max_packet,
+			      enum cvmx_usb_transfer transfer_type,
+			      enum cvmx_usb_direction transfer_dir,
+			      int interval, int multi_count,
+			      int hub_device_addr, int hub_port)
+{
+	struct cvmx_usb_pipe *pipe;
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+
+	if (unlikely((device_addr < 0) || (device_addr > MAX_USB_ADDRESS)))
+		return -EINVAL;
+	if (unlikely((endpoint_num < 0) || (endpoint_num > MAX_USB_ENDPOINT)))
+		return -EINVAL;
+	if (unlikely(device_speed > CVMX_USB_SPEED_LOW))
+		return -EINVAL;
+	if (unlikely((max_packet <= 0) || (max_packet > 1024)))
+		return -EINVAL;
+	if (unlikely(transfer_type > CVMX_USB_TRANSFER_INTERRUPT))
+		return -EINVAL;
+	if (unlikely((transfer_dir != CVMX_USB_DIRECTION_OUT) &&
+		(transfer_dir != CVMX_USB_DIRECTION_IN)))
+		return -EINVAL;
+	if (unlikely(interval < 0))
+		return -EINVAL;
+	if (unlikely((transfer_type == CVMX_USB_TRANSFER_CONTROL) && interval))
+		return -EINVAL;
+	if (unlikely(multi_count < 0))
+		return -EINVAL;
+	if (unlikely((device_speed != CVMX_USB_SPEED_HIGH) &&
+		(multi_count != 0)))
+		return -EINVAL;
+	if (unlikely((hub_device_addr < 0) || (hub_device_addr > MAX_USB_ADDRESS)))
+		return -EINVAL;
+	if (unlikely((hub_port < 0) || (hub_port > MAX_USB_HUB_PORT)))
+		return -EINVAL;
+
+	/* Find a free pipe */
+	pipe = usb->free_pipes.head;
+	if (!pipe)
+		return -ENOMEM;
+	__cvmx_usb_remove_pipe(&usb->free_pipes, pipe);
+	pipe->flags = __CVMX_USB_PIPE_FLAGS_OPEN;
+	if ((device_speed == CVMX_USB_SPEED_HIGH) &&
+		(transfer_dir == CVMX_USB_DIRECTION_OUT) &&
+		(transfer_type == CVMX_USB_TRANSFER_BULK))
+		pipe->flags |= __CVMX_USB_PIPE_FLAGS_NEED_PING;
+	pipe->device_addr = device_addr;
+	pipe->endpoint_num = endpoint_num;
+	pipe->device_speed = device_speed;
+	pipe->max_packet = max_packet;
+	pipe->transfer_type = transfer_type;
+	pipe->transfer_dir = transfer_dir;
+	/*
+	 * All pipes use interval to rate limit NAK processing. Force an
+	 * interval if one wasn't supplied
+	 */
+	if (!interval)
+		interval = 1;
+	if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+		pipe->interval = interval*8;
+		/* Force start splits to be schedule on uFrame 0 */
+		pipe->next_tx_frame = ((usb->frame_number+7)&~7) + pipe->interval;
+	} else {
+		pipe->interval = interval;
+		pipe->next_tx_frame = usb->frame_number + pipe->interval;
+	}
+	pipe->multi_count = multi_count;
+	pipe->hub_device_addr = hub_device_addr;
+	pipe->hub_port = hub_port;
+	pipe->pid_toggle = 0;
+	pipe->split_sc_frame = -1;
+	__cvmx_usb_append_pipe(&usb->idle_pipes, pipe);
+
+	/*
+	 * We don't need to tell the hardware about this pipe yet since
+	 * it doesn't have any submitted requests
+	 */
+
+	return __cvmx_usb_get_pipe_handle(usb, pipe);
+}
+
+
+/**
+ * Poll the RX FIFOs and remove data as needed. This function is only used
+ * in non DMA mode. It is very important that this function be called quickly
+ * enough to prevent FIFO overflow.
+ *
+ * @usb:	USB device state populated by
+ *		cvmx_usb_initialize().
+ */
+static void __cvmx_usb_poll_rx_fifo(struct cvmx_usb_internal_state *usb)
+{
+	union cvmx_usbcx_grxstsph rx_status;
+	int channel;
+	int bytes;
+	uint64_t address;
+	uint32_t *ptr;
+
+	rx_status.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GRXSTSPH(usb->index));
+	/* Only read data if IN data is there */
+	if (rx_status.s.pktsts != 2)
+		return;
+	/* Check if no data is available */
+	if (!rx_status.s.bcnt)
+		return;
+
+	channel = rx_status.s.chnum;
+	bytes = rx_status.s.bcnt;
+	if (!bytes)
+		return;
+
+	/* Get where the DMA engine would have written this data */
+	address = __cvmx_usb_read_csr64(usb, CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel*8);
+	ptr = cvmx_phys_to_ptr(address);
+	__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel*8, address + bytes);
+
+	/* Loop writing the FIFO data for this packet into memory */
+	while (bytes > 0) {
+		*ptr++ = __cvmx_usb_read_csr32(usb, USB_FIFO_ADDRESS(channel, usb->index));
+		bytes -= 4;
+	}
+	CVMX_SYNCW;
+
+	return;
+}
+
+
+/**
+ * Fill the TX hardware fifo with data out of the software
+ * fifos
+ *
+ * @usb:	    USB device state populated by
+ *		    cvmx_usb_initialize().
+ * @fifo:	    Software fifo to use
+ * @available:	    Amount of space in the hardware fifo
+ *
+ * Returns: Non zero if the hardware fifo was too small and needs
+ *	    to be serviced again.
+ */
+static int __cvmx_usb_fill_tx_hw(struct cvmx_usb_internal_state *usb, struct cvmx_usb_tx_fifo *fifo, int available)
+{
+	/*
+	 * We're done either when there isn't anymore space or the software FIFO
+	 * is empty
+	 */
+	while (available && (fifo->head != fifo->tail)) {
+		int i = fifo->tail;
+		const uint32_t *ptr = cvmx_phys_to_ptr(fifo->entry[i].address);
+		uint64_t csr_address = USB_FIFO_ADDRESS(fifo->entry[i].channel, usb->index) ^ 4;
+		int words = available;
+
+		/* Limit the amount of data to waht the SW fifo has */
+		if (fifo->entry[i].size <= available) {
+			words = fifo->entry[i].size;
+			fifo->tail++;
+			if (fifo->tail > MAX_CHANNELS)
+				fifo->tail = 0;
+		}
+
+		/* Update the next locations and counts */
+		available -= words;
+		fifo->entry[i].address += words * 4;
+		fifo->entry[i].size -= words;
+
+		/*
+		 * Write the HW fifo data. The read every three writes is due
+		 * to an errata on CN3XXX chips
+		 */
+		while (words > 3) {
+			cvmx_write64_uint32(csr_address, *ptr++);
+			cvmx_write64_uint32(csr_address, *ptr++);
+			cvmx_write64_uint32(csr_address, *ptr++);
+			cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
+			words -= 3;
+		}
+		cvmx_write64_uint32(csr_address, *ptr++);
+		if (--words) {
+			cvmx_write64_uint32(csr_address, *ptr++);
+			if (--words)
+				cvmx_write64_uint32(csr_address, *ptr++);
+		}
+		cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));
+	}
+	return fifo->head != fifo->tail;
+}
+
+
+/**
+ * Check the hardware FIFOs and fill them as needed
+ *
+ * @usb:	USB device state populated by
+ *		cvmx_usb_initialize().
+ */
+static void __cvmx_usb_poll_tx_fifo(struct cvmx_usb_internal_state *usb)
+{
+	if (usb->periodic.head != usb->periodic.tail) {
+		union cvmx_usbcx_hptxsts tx_status;
+		tx_status.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPTXSTS(usb->index));
+		if (__cvmx_usb_fill_tx_hw(usb, &usb->periodic, tx_status.s.ptxfspcavail))
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, ptxfempmsk, 1);
+		else
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, ptxfempmsk, 0);
+	}
+
+	if (usb->nonperiodic.head != usb->nonperiodic.tail) {
+		union cvmx_usbcx_gnptxsts tx_status;
+		tx_status.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GNPTXSTS(usb->index));
+		if (__cvmx_usb_fill_tx_hw(usb, &usb->nonperiodic, tx_status.s.nptxfspcavail))
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, nptxfempmsk, 1);
+		else
+			USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, nptxfempmsk, 0);
+	}
+
+	return;
+}
+
+
+/**
+ * Fill the TX FIFO with an outgoing packet
+ *
+ * @usb:	  USB device state populated by
+ *		  cvmx_usb_initialize().
+ * @channel:	  Channel number to get packet from
+ */
+static void __cvmx_usb_fill_tx_fifo(struct cvmx_usb_internal_state *usb, int channel)
+{
+	union cvmx_usbcx_hccharx hcchar;
+	union cvmx_usbcx_hcspltx usbc_hcsplt;
+	union cvmx_usbcx_hctsizx usbc_hctsiz;
+	struct cvmx_usb_tx_fifo *fifo;
+
+	/* We only need to fill data on outbound channels */
+	hcchar.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index));
+	if (hcchar.s.epdir != CVMX_USB_DIRECTION_OUT)
+		return;
+
+	/* OUT Splits only have data on the start and not the complete */
+	usbc_hcsplt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCSPLTX(channel, usb->index));
+	if (usbc_hcsplt.s.spltena && usbc_hcsplt.s.compsplt)
+		return;
+
+	/*
+	 * Find out how many bytes we need to fill and convert it into 32bit
+	 * words.
+	 */
+	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index));
+	if (!usbc_hctsiz.s.xfersize)
+		return;
+
+	if ((hcchar.s.eptype == CVMX_USB_TRANSFER_INTERRUPT) ||
+		(hcchar.s.eptype == CVMX_USB_TRANSFER_ISOCHRONOUS))
+		fifo = &usb->periodic;
+	else
+		fifo = &usb->nonperiodic;
+
+	fifo->entry[fifo->head].channel = channel;
+	fifo->entry[fifo->head].address = __cvmx_usb_read_csr64(usb, CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8);
+	fifo->entry[fifo->head].size = (usbc_hctsiz.s.xfersize+3)>>2;
+	fifo->head++;
+	if (fifo->head > MAX_CHANNELS)
+		fifo->head = 0;
+
+	__cvmx_usb_poll_tx_fifo(usb);
+
+	return;
+}
+
+/**
+ * Perform channel specific setup for Control transactions. All
+ * the generic stuff will already have been done in
+ * __cvmx_usb_start_channel()
+ *
+ * @usb:	  USB device state populated by
+ *		  cvmx_usb_initialize().
+ * @channel:	  Channel to setup
+ * @pipe:	  Pipe for control transaction
+ */
+static void __cvmx_usb_start_channel_control(struct cvmx_usb_internal_state *usb,
+					     int channel,
+					     struct cvmx_usb_pipe *pipe)
+{
+	struct cvmx_usb_transaction *transaction = pipe->head;
+	union cvmx_usb_control_header *header =
+		cvmx_phys_to_ptr(transaction->control_header);
+	int bytes_to_transfer = transaction->buffer_length - transaction->actual_bytes;
+	int packets_to_transfer;
+	union cvmx_usbcx_hctsizx usbc_hctsiz;
+
+	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index));
+
+	switch (transaction->stage) {
+	case CVMX_USB_STAGE_NON_CONTROL:
+	case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
+		cvmx_dprintf("%s: ERROR - Non control stage\n", __FUNCTION__);
+		break;
+	case CVMX_USB_STAGE_SETUP:
+		usbc_hctsiz.s.pid = 3; /* Setup */
+		bytes_to_transfer = sizeof(*header);
+		/* All Control operations start with a setup going OUT */
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, epdir, CVMX_USB_DIRECTION_OUT);
+		/*
+		 * Setup send the control header instead of the buffer data. The
+		 * buffer data will be used in the next stage
+		 */
+		__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8, transaction->control_header);
+		break;
+	case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
+		usbc_hctsiz.s.pid = 3; /* Setup */
+		bytes_to_transfer = 0;
+		/* All Control operations start with a setup going OUT */
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, epdir, CVMX_USB_DIRECTION_OUT);
+		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index), union cvmx_usbcx_hcspltx, compsplt, 1);
+		break;
+	case CVMX_USB_STAGE_DATA:
+		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+			if (header->s.request_type & 0x80)
+				bytes_to_transfer = 0;
+			else if (bytes_to_transfer > pipe->max_packet)
+				bytes_to_transfer = pipe->max_packet;
+		}
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				union cvmx_usbcx_hccharx, epdir,
+				((header->s.request_type & 0x80) ?
+					CVMX_USB_DIRECTION_IN :
+					CVMX_USB_DIRECTION_OUT));
+		break;
+	case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
+		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		if (!(header->s.request_type & 0x80))
+			bytes_to_transfer = 0;
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),
+				union cvmx_usbcx_hccharx, epdir,
+				((header->s.request_type & 0x80) ?
+					CVMX_USB_DIRECTION_IN :
+					CVMX_USB_DIRECTION_OUT));
+		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index), union cvmx_usbcx_hcspltx, compsplt, 1);
+		break;
+	case CVMX_USB_STAGE_STATUS:
+		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		bytes_to_transfer = 0;
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, epdir,
+				((header->s.request_type & 0x80) ?
+					CVMX_USB_DIRECTION_OUT :
+					CVMX_USB_DIRECTION_IN));
+		break;
+	case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
+		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		bytes_to_transfer = 0;
+		USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, epdir,
+				((header->s.request_type & 0x80) ?
+					CVMX_USB_DIRECTION_OUT :
+					CVMX_USB_DIRECTION_IN));
+		USB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index), union cvmx_usbcx_hcspltx, compsplt, 1);
+		break;
+	}
+
+	/*
+	 * Make sure the transfer never exceeds the byte limit of the hardware.
+	 * Further bytes will be sent as continued transactions
+	 */
+	if (bytes_to_transfer > MAX_TRANSFER_BYTES) {
+		/* Round MAX_TRANSFER_BYTES to a multiple of out packet size */
+		bytes_to_transfer = MAX_TRANSFER_BYTES / pipe->max_packet;
+		bytes_to_transfer *= pipe->max_packet;
+	}
+
+	/*
+	 * Calculate the number of packets to transfer. If the length is zero
+	 * we still need to transfer one packet
+	 */
+	packets_to_transfer = (bytes_to_transfer + pipe->max_packet - 1) / pipe->max_packet;
+	if (packets_to_transfer == 0)
+		packets_to_transfer = 1;
+	else if ((packets_to_transfer > 1) && (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
+		/*
+		 * Limit to one packet when not using DMA. Channels must be
+		 * restarted between every packet for IN transactions, so there
+		 * is no reason to do multiple packets in a row
+		 */
+		packets_to_transfer = 1;
+		bytes_to_transfer = packets_to_transfer * pipe->max_packet;
+	} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {
+		/*
+		 * Limit the number of packet and data transferred to what the
+		 * hardware can handle
+		 */
+		packets_to_transfer = MAX_TRANSFER_PACKETS;
+		bytes_to_transfer = packets_to_transfer * pipe->max_packet;
+	}
+
+	usbc_hctsiz.s.xfersize = bytes_to_transfer;
+	usbc_hctsiz.s.pktcnt = packets_to_transfer;
+
+	__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index), usbc_hctsiz.u32);
+	return;
+}
+
+
+/**
+ * Start a channel to perform the pipe's head transaction
+ *
+ * @usb:	  USB device state populated by
+ *		  cvmx_usb_initialize().
+ * @channel:	  Channel to setup
+ * @pipe:	  Pipe to start
+ */
+static void __cvmx_usb_start_channel(struct cvmx_usb_internal_state *usb,
+				     int channel,
+				     struct cvmx_usb_pipe *pipe)
+{
+	struct cvmx_usb_transaction *transaction = pipe->head;
+
+	/* Make sure all writes to the DMA region get flushed */
+	CVMX_SYNCW;
+
+	/* Attach the channel to the pipe */
+	usb->pipe_for_channel[channel] = pipe;
+	pipe->channel = channel;
+	pipe->flags |= __CVMX_USB_PIPE_FLAGS_SCHEDULED;
+
+	/* Mark this channel as in use */
+	usb->idle_hardware_channels &= ~(1<<channel);
+
+	/* Enable the channel interrupt bits */
+	{
+		union cvmx_usbcx_hcintx usbc_hcint;
+		union cvmx_usbcx_hcintmskx usbc_hcintmsk;
+		union cvmx_usbcx_haintmsk usbc_haintmsk;
+
+		/* Clear all channel status bits */
+		usbc_hcint.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCINTX(channel, usb->index));
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTX(channel, usb->index), usbc_hcint.u32);
+
+		usbc_hcintmsk.u32 = 0;
+		usbc_hcintmsk.s.chhltdmsk = 1;
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
+			/*
+			 * Channels need these extra interrupts when we aren't
+			 * in DMA mode.
+			 */
+			usbc_hcintmsk.s.datatglerrmsk = 1;
+			usbc_hcintmsk.s.frmovrunmsk = 1;
+			usbc_hcintmsk.s.bblerrmsk = 1;
+			usbc_hcintmsk.s.xacterrmsk = 1;
+			if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+				/*
+				 * Splits don't generate xfercompl, so we need
+				 * ACK and NYET.
+				 */
+				usbc_hcintmsk.s.nyetmsk = 1;
+				usbc_hcintmsk.s.ackmsk = 1;
+			}
+			usbc_hcintmsk.s.nakmsk = 1;
+			usbc_hcintmsk.s.stallmsk = 1;
+			usbc_hcintmsk.s.xfercomplmsk = 1;
+		}
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), usbc_hcintmsk.u32);
+
+		/* Enable the channel interrupt to propagate */
+		usbc_haintmsk.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HAINTMSK(usb->index));
+		usbc_haintmsk.s.haintmsk |= 1<<channel;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HAINTMSK(usb->index), usbc_haintmsk.u32);
+	}
+
+	/* Setup the locations the DMA engines use  */
+	{
+		uint64_t dma_address = transaction->buffer + transaction->actual_bytes;
+		if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
+			dma_address = transaction->buffer + transaction->iso_packets[0].offset + transaction->actual_bytes;
+		__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) + channel*8, dma_address);
+		__cvmx_usb_write_csr64(usb, CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel*8, dma_address);
+	}
+
+	/* Setup both the size of the transfer and the SPLIT characteristics */
+	{
+		union cvmx_usbcx_hcspltx usbc_hcsplt = {.u32 = 0};
+		union cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 = 0};
+		int packets_to_transfer;
+		int bytes_to_transfer = transaction->buffer_length - transaction->actual_bytes;
+
+		/*
+		 * ISOCHRONOUS transactions store each individual transfer size
+		 * in the packet structure, not the global buffer_length
+		 */
+		if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
+			bytes_to_transfer = transaction->iso_packets[0].length - transaction->actual_bytes;
+
+		/*
+		 * We need to do split transactions when we are talking to non
+		 * high speed devices that are behind a high speed hub
+		 */
+		if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+			/*
+			 * On the start split phase (stage is even) record the
+			 * frame number we will need to send the split complete.
+			 * We only store the lower two bits since the time ahead
+			 * can only be two frames
+			 */
+			if ((transaction->stage&1) == 0) {
+				if (transaction->type == CVMX_USB_TRANSFER_BULK)
+					pipe->split_sc_frame = (usb->frame_number + 1) & 0x7f;
+				else
+					pipe->split_sc_frame = (usb->frame_number + 2) & 0x7f;
+			} else
+				pipe->split_sc_frame = -1;
+
+			usbc_hcsplt.s.spltena = 1;
+			usbc_hcsplt.s.hubaddr = pipe->hub_device_addr;
+			usbc_hcsplt.s.prtaddr = pipe->hub_port;
+			usbc_hcsplt.s.compsplt = (transaction->stage == CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE);
+
+			/*
+			 * SPLIT transactions can only ever transmit one data
+			 * packet so limit the transfer size to the max packet
+			 * size
+			 */
+			if (bytes_to_transfer > pipe->max_packet)
+				bytes_to_transfer = pipe->max_packet;
+
+			/*
+			 * ISOCHRONOUS OUT splits are unique in that they limit
+			 * data transfers to 188 byte chunks representing the
+			 * begin/middle/end of the data or all
+			 */
+			if (!usbc_hcsplt.s.compsplt &&
+				(pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) &&
+				(pipe->transfer_type == CVMX_USB_TRANSFER_ISOCHRONOUS)) {
+				/*
+				 * Clear the split complete frame number as
+				 * there isn't going to be a split complete
+				 */
+				pipe->split_sc_frame = -1;
+				/*
+				 * See if we've started this transfer and sent
+				 * data
+				 */
+				if (transaction->actual_bytes == 0) {
+					/*
+					 * Nothing sent yet, this is either a
+					 * begin or the entire payload
+					 */
+					if (bytes_to_transfer <= 188)
+						/* Entire payload in one go */
+						usbc_hcsplt.s.xactpos = 3;
+					else
+						/* First part of payload */
+						usbc_hcsplt.s.xactpos = 2;
+				} else {
+					/*
+					 * Continuing the previous data, we must
+					 * either be in the middle or at the end
+					 */
+					if (bytes_to_transfer <= 188)
+						/* End of payload */
+						usbc_hcsplt.s.xactpos = 1;
+					else
+						/* Middle of payload */
+						usbc_hcsplt.s.xactpos = 0;
+				}
+				/*
+				 * Again, the transfer size is limited to 188
+				 * bytes
+				 */
+				if (bytes_to_transfer > 188)
+					bytes_to_transfer = 188;
+			}
+		}
+
+		/*
+		 * Make sure the transfer never exceeds the byte limit of the
+		 * hardware. Further bytes will be sent as continued
+		 * transactions
+		 */
+		if (bytes_to_transfer > MAX_TRANSFER_BYTES) {
+			/*
+			 * Round MAX_TRANSFER_BYTES to a multiple of out packet
+			 * size
+			 */
+			bytes_to_transfer = MAX_TRANSFER_BYTES / pipe->max_packet;
+			bytes_to_transfer *= pipe->max_packet;
+		}
+
+		/*
+		 * Calculate the number of packets to transfer. If the length is
+		 * zero we still need to transfer one packet
+		 */
+		packets_to_transfer = (bytes_to_transfer + pipe->max_packet - 1) / pipe->max_packet;
+		if (packets_to_transfer == 0)
+			packets_to_transfer = 1;
+		else if ((packets_to_transfer > 1) && (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {
+			/*
+			 * Limit to one packet when not using DMA. Channels must
+			 * be restarted between every packet for IN
+			 * transactions, so there is no reason to do multiple
+			 * packets in a row
+			 */
+			packets_to_transfer = 1;
+			bytes_to_transfer = packets_to_transfer * pipe->max_packet;
+		} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {
+			/*
+			 * Limit the number of packet and data transferred to
+			 * what the hardware can handle
+			 */
+			packets_to_transfer = MAX_TRANSFER_PACKETS;
+			bytes_to_transfer = packets_to_transfer * pipe->max_packet;
+		}
+
+		usbc_hctsiz.s.xfersize = bytes_to_transfer;
+		usbc_hctsiz.s.pktcnt = packets_to_transfer;
+
+		/* Update the DATA0/DATA1 toggle */
+		usbc_hctsiz.s.pid = __cvmx_usb_get_data_pid(pipe);
+		/*
+		 * High speed pipes may need a hardware ping before they start
+		 */
+		if (pipe->flags & __CVMX_USB_PIPE_FLAGS_NEED_PING)
+			usbc_hctsiz.s.dopng = 1;
+
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCSPLTX(channel, usb->index), usbc_hcsplt.u32);
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index), usbc_hctsiz.u32);
+	}
+
+	/* Setup the Host Channel Characteristics Register */
+	{
+		union cvmx_usbcx_hccharx usbc_hcchar = {.u32 = 0};
+
+		/*
+		 * Set the startframe odd/even properly. This is only used for
+		 * periodic
+		 */
+		usbc_hcchar.s.oddfrm = usb->frame_number&1;
+
+		/*
+		 * Set the number of back to back packets allowed by this
+		 * endpoint. Split transactions interpret "ec" as the number of
+		 * immediate retries of failure. These retries happen too
+		 * quickly, so we disable these entirely for splits
+		 */
+		if (__cvmx_usb_pipe_needs_split(usb, pipe))
+			usbc_hcchar.s.ec = 1;
+		else if (pipe->multi_count < 1)
+			usbc_hcchar.s.ec = 1;
+		else if (pipe->multi_count > 3)
+			usbc_hcchar.s.ec = 3;
+		else
+			usbc_hcchar.s.ec = pipe->multi_count;
+
+		/* Set the rest of the endpoint specific settings */
+		usbc_hcchar.s.devaddr = pipe->device_addr;
+		usbc_hcchar.s.eptype = transaction->type;
+		usbc_hcchar.s.lspddev = (pipe->device_speed == CVMX_USB_SPEED_LOW);
+		usbc_hcchar.s.epdir = pipe->transfer_dir;
+		usbc_hcchar.s.epnum = pipe->endpoint_num;
+		usbc_hcchar.s.mps = pipe->max_packet;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index), usbc_hcchar.u32);
+	}
+
+	/* Do transaction type specific fixups as needed */
+	switch (transaction->type) {
+	case CVMX_USB_TRANSFER_CONTROL:
+		__cvmx_usb_start_channel_control(usb, channel, pipe);
+		break;
+	case CVMX_USB_TRANSFER_BULK:
+	case CVMX_USB_TRANSFER_INTERRUPT:
+		break;
+	case CVMX_USB_TRANSFER_ISOCHRONOUS:
+		if (!__cvmx_usb_pipe_needs_split(usb, pipe)) {
+			/*
+			 * ISO transactions require different PIDs depending on
+			 * direction and how many packets are needed
+			 */
+			if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {
+				if (pipe->multi_count < 2) /* Need DATA0 */
+					USB_SET_FIELD32(CVMX_USBCX_HCTSIZX(channel, usb->index), union cvmx_usbcx_hctsizx, pid, 0);
+				else /* Need MDATA */
+					USB_SET_FIELD32(CVMX_USBCX_HCTSIZX(channel, usb->index), union cvmx_usbcx_hctsizx, pid, 3);
+			}
+		}
+		break;
+	}
+	{
+		union cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index))};
+		transaction->xfersize = usbc_hctsiz.s.xfersize;
+		transaction->pktcnt = usbc_hctsiz.s.pktcnt;
+	}
+	/* Remeber when we start a split transaction */
+	if (__cvmx_usb_pipe_needs_split(usb, pipe))
+		usb->active_split = transaction;
+	USB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index), union cvmx_usbcx_hccharx, chena, 1);
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+		__cvmx_usb_fill_tx_fifo(usb, channel);
+	return;
+}
+
+
+/**
+ * Find a pipe that is ready to be scheduled to hardware.
+ * @usb:	 USB device state populated by
+ *		 cvmx_usb_initialize().
+ * @list:	 Pipe list to search
+ * @current_frame:
+ *		 Frame counter to use as a time reference.
+ *
+ * Returns: Pipe or NULL if none are ready
+ */
+static struct cvmx_usb_pipe *__cvmx_usb_find_ready_pipe(struct cvmx_usb_internal_state *usb, struct cvmx_usb_pipe_list *list, uint64_t current_frame)
+{
+	struct cvmx_usb_pipe *pipe = list->head;
+	while (pipe) {
+		if (!(pipe->flags & __CVMX_USB_PIPE_FLAGS_SCHEDULED) && pipe->head &&
+			(pipe->next_tx_frame <= current_frame) &&
+			((pipe->split_sc_frame == -1) || ((((int)current_frame - (int)pipe->split_sc_frame) & 0x7f) < 0x40)) &&
+			(!usb->active_split || (usb->active_split == pipe->head))) {
+			CVMX_PREFETCH(pipe, 128);
+			CVMX_PREFETCH(pipe->head, 0);
+			return pipe;
+		}
+		pipe = pipe->next;
+	}
+	return NULL;
+}
+
+
+/**
+ * Called whenever a pipe might need to be scheduled to the
+ * hardware.
+ *
+ * @usb:	 USB device state populated by
+ *		 cvmx_usb_initialize().
+ * @is_sof:	 True if this schedule was called on a SOF interrupt.
+ */
+static void __cvmx_usb_schedule(struct cvmx_usb_internal_state *usb, int is_sof)
+{
+	int channel;
+	struct cvmx_usb_pipe *pipe;
+	int need_sof;
+	enum cvmx_usb_transfer ttype;
+
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
+		/*
+		 * Without DMA we need to be careful to not schedule something
+		 * at the end of a frame and cause an overrun.
+		 */
+		union cvmx_usbcx_hfnum hfnum = {.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index))};
+		union cvmx_usbcx_hfir hfir = {.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFIR(usb->index))};
+		if (hfnum.s.frrem < hfir.s.frint/4)
+			goto done;
+	}
+
+	while (usb->idle_hardware_channels) {
+		/* Find an idle channel */
+		channel = __fls(usb->idle_hardware_channels);
+		if (unlikely(channel > 7))
+			break;
+
+		/* Find a pipe needing service */
+		pipe = NULL;
+		if (is_sof) {
+			/*
+			 * Only process periodic pipes on SOF interrupts. This
+			 * way we are sure that the periodic data is sent in the
+			 * beginning of the frame
+			 */
+			pipe = __cvmx_usb_find_ready_pipe(usb, usb->active_pipes + CVMX_USB_TRANSFER_ISOCHRONOUS, usb->frame_number);
+			if (likely(!pipe))
+				pipe = __cvmx_usb_find_ready_pipe(usb, usb->active_pipes + CVMX_USB_TRANSFER_INTERRUPT, usb->frame_number);
+		}
+		if (likely(!pipe)) {
+			pipe = __cvmx_usb_find_ready_pipe(usb, usb->active_pipes + CVMX_USB_TRANSFER_CONTROL, usb->frame_number);
+			if (likely(!pipe))
+				pipe = __cvmx_usb_find_ready_pipe(usb, usb->active_pipes + CVMX_USB_TRANSFER_BULK, usb->frame_number);
+		}
+		if (!pipe)
+			break;
+
+		__cvmx_usb_start_channel(usb, channel, pipe);
+	}
+
+done:
+	/*
+	 * Only enable SOF interrupts when we have transactions pending in the
+	 * future that might need to be scheduled
+	 */
+	need_sof = 0;
+	for (ttype = CVMX_USB_TRANSFER_CONTROL; ttype <= CVMX_USB_TRANSFER_INTERRUPT; ttype++) {
+		pipe = usb->active_pipes[ttype].head;
+		while (pipe) {
+			if (pipe->next_tx_frame > usb->frame_number) {
+				need_sof = 1;
+				break;
+			}
+			pipe = pipe->next;
+		}
+	}
+	USB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index), union cvmx_usbcx_gintmsk, sofmsk, need_sof);
+	return;
+}
+
+
+/**
+ * Call a user's callback for a specific reason.
+ *
+ * @usb:	 USB device state populated by
+ *		 cvmx_usb_initialize().
+ * @pipe:	 Pipe the callback is for or NULL
+ * @transaction:
+ *		 Transaction the callback is for or NULL
+ * @reason:	 Reason this callback is being called
+ * @complete_code:
+ *		 Completion code for the transaction, if any
+ */
+static void __cvmx_usb_perform_callback(struct cvmx_usb_internal_state *usb,
+					struct cvmx_usb_pipe *pipe,
+					struct cvmx_usb_transaction *transaction,
+					enum cvmx_usb_callback reason,
+					enum cvmx_usb_complete complete_code)
+{
+	cvmx_usb_callback_func_t callback = usb->callback[reason];
+	void *user_data = usb->callback_data[reason];
+	int submit_handle = -1;
+	int pipe_handle = -1;
+	int bytes_transferred = 0;
+
+	if (pipe)
+		pipe_handle = __cvmx_usb_get_pipe_handle(usb, pipe);
+
+	if (transaction) {
+		submit_handle = __cvmx_usb_get_submit_handle(usb, transaction);
+		bytes_transferred = transaction->actual_bytes;
+		/* Transactions are allowed to override the default callback */
+		if ((reason == CVMX_USB_CALLBACK_TRANSFER_COMPLETE) && transaction->callback) {
+			callback = transaction->callback;
+			user_data = transaction->callback_data;
+		}
+	}
+
+	if (!callback)
+		return;
+
+	callback((struct cvmx_usb_state *)usb, reason, complete_code, pipe_handle, submit_handle,
+		 bytes_transferred, user_data);
+}
+
+
+/**
+ * Signal the completion of a transaction and free it. The
+ * transaction will be removed from the pipe transaction list.
+ *
+ * @usb:	 USB device state populated by
+ *		 cvmx_usb_initialize().
+ * @pipe:	 Pipe the transaction is on
+ * @transaction:
+ *		 Transaction that completed
+ * @complete_code:
+ *		 Completion code
+ */
+static void __cvmx_usb_perform_complete(struct cvmx_usb_internal_state *usb,
+					struct cvmx_usb_pipe *pipe,
+					struct cvmx_usb_transaction *transaction,
+					enum cvmx_usb_complete complete_code)
+{
+	/* If this was a split then clear our split in progress marker */
+	if (usb->active_split == transaction)
+		usb->active_split = NULL;
+
+	/*
+	 * Isochronous transactions need extra processing as they might not be
+	 * done after a single data transfer
+	 */
+	if (unlikely(transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)) {
+		/* Update the number of bytes transferred in this ISO packet */
+		transaction->iso_packets[0].length = transaction->actual_bytes;
+		transaction->iso_packets[0].status = complete_code;
+
+		/*
+		 * If there are more ISOs pending and we succeeded, schedule the
+		 * next one
+		 */
+		if ((transaction->iso_number_packets > 1) && (complete_code == CVMX_USB_COMPLETE_SUCCESS)) {
+			/* No bytes transferred for this packet as of yet */
+			transaction->actual_bytes = 0;
+			/* One less ISO waiting to transfer */
+			transaction->iso_number_packets--;
+			/* Increment to the next location in our packet array */
+			transaction->iso_packets++;
+			transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+			goto done;
+		}
+	}
+
+	/* Remove the transaction from the pipe list */
+	if (transaction->next)
+		transaction->next->prev = transaction->prev;
+	else
+		pipe->tail = transaction->prev;
+	if (transaction->prev)
+		transaction->prev->next = transaction->next;
+	else
+		pipe->head = transaction->next;
+	if (!pipe->head) {
+		__cvmx_usb_remove_pipe(usb->active_pipes + pipe->transfer_type, pipe);
+		__cvmx_usb_append_pipe(&usb->idle_pipes, pipe);
+
+	}
+	__cvmx_usb_perform_callback(usb, pipe, transaction,
+				    CVMX_USB_CALLBACK_TRANSFER_COMPLETE,
+				    complete_code);
+	__cvmx_usb_free_transaction(usb, transaction);
+done:
+	return;
+}
+
+
+/**
+ * Submit a usb transaction to a pipe. Called for all types
+ * of transactions.
+ *
+ * @usb:
+ * @pipe_handle:
+ *		    Which pipe to submit to. Will be validated in this function.
+ * @type:	    Transaction type
+ * @buffer:	    User buffer for the transaction
+ * @buffer_length:
+ *		    User buffer's length in bytes
+ * @control_header:
+ *		    For control transactions, the 8 byte standard header
+ * @iso_start_frame:
+ *		    For ISO transactions, the start frame
+ * @iso_number_packets:
+ *		    For ISO, the number of packet in the transaction.
+ * @iso_packets:
+ *		    A description of each ISO packet
+ * @callback:	    User callback to call when the transaction completes
+ * @user_data:	    User's data for the callback
+ *
+ * Returns: Submit handle or negative on failure. Matches the result
+ *	    in the external API.
+ */
+static int __cvmx_usb_submit_transaction(struct cvmx_usb_internal_state *usb,
+					 int pipe_handle,
+					 enum cvmx_usb_transfer type,
+					 uint64_t buffer,
+					 int buffer_length,
+					 uint64_t control_header,
+					 int iso_start_frame,
+					 int iso_number_packets,
+					 struct cvmx_usb_iso_packet *iso_packets,
+					 cvmx_usb_callback_func_t callback,
+					 void *user_data)
+{
+	int submit_handle;
+	struct cvmx_usb_transaction *transaction;
+	struct cvmx_usb_pipe *pipe = usb->pipe + pipe_handle;
+
+	if (unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
+		return -EINVAL;
+	/* Fail if the pipe isn't open */
+	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
+		return -EINVAL;
+	if (unlikely(pipe->transfer_type != type))
+		return -EINVAL;
+
+	transaction = __cvmx_usb_alloc_transaction(usb);
+	if (unlikely(!transaction))
+		return -ENOMEM;
+
+	transaction->type = type;
+	transaction->buffer = buffer;
+	transaction->buffer_length = buffer_length;
+	transaction->control_header = control_header;
+	/* FIXME: This is not used, implement it. */
+	transaction->iso_start_frame = iso_start_frame;
+	transaction->iso_number_packets = iso_number_packets;
+	transaction->iso_packets = iso_packets;
+	transaction->callback = callback;
+	transaction->callback_data = user_data;
+	if (transaction->type == CVMX_USB_TRANSFER_CONTROL)
+		transaction->stage = CVMX_USB_STAGE_SETUP;
+	else
+		transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+
+	transaction->next = NULL;
+	if (pipe->tail) {
+		transaction->prev = pipe->tail;
+		transaction->prev->next = transaction;
+	} else {
+		if (pipe->next_tx_frame < usb->frame_number)
+			pipe->next_tx_frame = usb->frame_number + pipe->interval -
+				(usb->frame_number - pipe->next_tx_frame) % pipe->interval;
+		transaction->prev = NULL;
+		pipe->head = transaction;
+		__cvmx_usb_remove_pipe(&usb->idle_pipes, pipe);
+		__cvmx_usb_append_pipe(usb->active_pipes + pipe->transfer_type, pipe);
+	}
+	pipe->tail = transaction;
+
+	submit_handle = __cvmx_usb_get_submit_handle(usb, transaction);
+
+	/* We may need to schedule the pipe if this was the head of the pipe */
+	if (!transaction->prev)
+		__cvmx_usb_schedule(usb, 0);
+
+	return submit_handle;
+}
+
+
+/**
+ * Call to submit a USB Bulk transfer to a pipe.
+ *
+ * @state:	    USB device state populated by
+ *		    cvmx_usb_initialize().
+ * @pipe_handle:
+ *		    Handle to the pipe for the transfer.
+ * @buffer:	    Physical address of the data buffer in
+ *		    memory. Note that this is NOT A POINTER, but
+ *		    the full 64bit physical address of the
+ *		    buffer. This may be zero if buffer_length is
+ *		    zero.
+ * @buffer_length:
+ *		    Length of buffer in bytes.
+ * @callback:	    Function to call when this transaction
+ *		    completes. If the return value of this
+ *		    function isn't an error, then this function
+ *		    is guaranteed to be called when the
+ *		    transaction completes. If this parameter is
+ *		    NULL, then the generic callback registered
+ *		    through cvmx_usb_register_callback is
+ *		    called. If both are NULL, then there is no
+ *		    way to know when a transaction completes.
+ * @user_data:	    User supplied data returned when the
+ *		    callback is called. This is only used if
+ *		    callback in not NULL.
+ *
+ * Returns: A submitted transaction handle or negative on
+ *	    failure. Negative values are error codes.
+ */
+static int cvmx_usb_submit_bulk(struct cvmx_usb_state *state, int pipe_handle,
+				uint64_t buffer, int buffer_length,
+				cvmx_usb_callback_func_t callback,
+				void *user_data)
+{
+	int submit_handle;
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+
+	/* Pipe handle checking is done later in a common place */
+	if (unlikely(!buffer))
+		return -EINVAL;
+	if (unlikely(buffer_length < 0))
+		return -EINVAL;
+
+	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle,
+						      CVMX_USB_TRANSFER_BULK,
+						      buffer,
+						      buffer_length,
+						      0, /* control_header */
+						      0, /* iso_start_frame */
+						      0, /* iso_number_packets */
+						      NULL, /* iso_packets */
+						      callback,
+						      user_data);
+	return submit_handle;
+}
+
+
+/**
+ * Call to submit a USB Interrupt transfer to a pipe.
+ *
+ * @state:	    USB device state populated by
+ *		    cvmx_usb_initialize().
+ * @pipe_handle:
+ *		    Handle to the pipe for the transfer.
+ * @buffer:	    Physical address of the data buffer in
+ *		    memory. Note that this is NOT A POINTER, but
+ *		    the full 64bit physical address of the
+ *		    buffer. This may be zero if buffer_length is
+ *		    zero.
+ * @buffer_length:
+ *		    Length of buffer in bytes.
+ * @callback:	    Function to call when this transaction
+ *		    completes. If the return value of this
+ *		    function isn't an error, then this function
+ *		    is guaranteed to be called when the
+ *		    transaction completes. If this parameter is
+ *		    NULL, then the generic callback registered
+ *		    through cvmx_usb_register_callback is
+ *		    called. If both are NULL, then there is no
+ *		    way to know when a transaction completes.
+ * @user_data:	    User supplied data returned when the
+ *		    callback is called. This is only used if
+ *		    callback in not NULL.
+ *
+ * Returns: A submitted transaction handle or negative on
+ *	    failure. Negative values are error codes.
+ */
+static int cvmx_usb_submit_interrupt(struct cvmx_usb_state *state,
+				     int pipe_handle, uint64_t buffer,
+				     int buffer_length,
+				     cvmx_usb_callback_func_t callback,
+				     void *user_data)
+{
+	int submit_handle;
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+
+	/* Pipe handle checking is done later in a common place */
+	if (unlikely(!buffer))
+		return -EINVAL;
+	if (unlikely(buffer_length < 0))
+		return -EINVAL;
+
+	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle,
+						      CVMX_USB_TRANSFER_INTERRUPT,
+						      buffer,
+						      buffer_length,
+						      0, /* control_header */
+						      0, /* iso_start_frame */
+						      0, /* iso_number_packets */
+						      NULL, /* iso_packets */
+						      callback,
+						      user_data);
+	return submit_handle;
+}
+
+
+/**
+ * Call to submit a USB Control transfer to a pipe.
+ *
+ * @state:	    USB device state populated by
+ *		    cvmx_usb_initialize().
+ * @pipe_handle:
+ *		    Handle to the pipe for the transfer.
+ * @control_header:
+ *		    USB 8 byte control header physical address.
+ *		    Note that this is NOT A POINTER, but the
+ *		    full 64bit physical address of the buffer.
+ * @buffer:	    Physical address of the data buffer in
+ *		    memory. Note that this is NOT A POINTER, but
+ *		    the full 64bit physical address of the
+ *		    buffer. This may be zero if buffer_length is
+ *		    zero.
+ * @buffer_length:
+ *		    Length of buffer in bytes.
+ * @callback:	    Function to call when this transaction
+ *		    completes. If the return value of this
+ *		    function isn't an error, then this function
+ *		    is guaranteed to be called when the
+ *		    transaction completes. If this parameter is
+ *		    NULL, then the generic callback registered
+ *		    through cvmx_usb_register_callback is
+ *		    called. If both are NULL, then there is no
+ *		    way to know when a transaction completes.
+ * @user_data:	    User supplied data returned when the
+ *		    callback is called. This is only used if
+ *		    callback in not NULL.
+ *
+ * Returns: A submitted transaction handle or negative on
+ *	    failure. Negative values are error codes.
+ */
+static int cvmx_usb_submit_control(struct cvmx_usb_state *state,
+				   int pipe_handle, uint64_t control_header,
+				   uint64_t buffer, int buffer_length,
+				   cvmx_usb_callback_func_t callback,
+				   void *user_data)
+{
+	int submit_handle;
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+	union cvmx_usb_control_header *header =
+		cvmx_phys_to_ptr(control_header);
+
+	/* Pipe handle checking is done later in a common place */
+	if (unlikely(!control_header))
+		return -EINVAL;
+	/* Some drivers send a buffer with a zero length. God only knows why */
+	if (unlikely(buffer && (buffer_length < 0)))
+		return -EINVAL;
+	if (unlikely(!buffer && (buffer_length != 0)))
+		return -EINVAL;
+	if ((header->s.request_type & 0x80) == 0)
+		buffer_length = le16_to_cpu(header->s.length);
+
+	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle,
+						      CVMX_USB_TRANSFER_CONTROL,
+						      buffer,
+						      buffer_length,
+						      control_header,
+						      0, /* iso_start_frame */
+						      0, /* iso_number_packets */
+						      NULL, /* iso_packets */
+						      callback,
+						      user_data);
+	return submit_handle;
+}
+
+
+/**
+ * Call to submit a USB Isochronous transfer to a pipe.
+ *
+ * @state:	    USB device state populated by
+ *		    cvmx_usb_initialize().
+ * @pipe_handle:
+ *		    Handle to the pipe for the transfer.
+ * @start_frame:
+ *		    Number of frames into the future to schedule
+ *		    this transaction.
+ * @number_packets:
+ *		    Number of sequential packets to transfer.
+ *		    "packets" is a pointer to an array of this
+ *		    many packet structures.
+ * @packets:	    Description of each transfer packet as
+ *		    defined by struct cvmx_usb_iso_packet. The array
+ *		    pointed to here must stay valid until the
+ *		    complete callback is called.
+ * @buffer:	    Physical address of the data buffer in
+ *		    memory. Note that this is NOT A POINTER, but
+ *		    the full 64bit physical address of the
+ *		    buffer. This may be zero if buffer_length is
+ *		    zero.
+ * @buffer_length:
+ *		    Length of buffer in bytes.
+ * @callback:	    Function to call when this transaction
+ *		    completes. If the return value of this
+ *		    function isn't an error, then this function
+ *		    is guaranteed to be called when the
+ *		    transaction completes. If this parameter is
+ *		    NULL, then the generic callback registered
+ *		    through cvmx_usb_register_callback is
+ *		    called. If both are NULL, then there is no
+ *		    way to know when a transaction completes.
+ * @user_data:	    User supplied data returned when the
+ *		    callback is called. This is only used if
+ *		    callback in not NULL.
+ *
+ * Returns: A submitted transaction handle or negative on
+ *	    failure. Negative values are error codes.
+ */
+static int cvmx_usb_submit_isochronous(struct cvmx_usb_state *state,
+				       int pipe_handle, int start_frame,
+				       int number_packets, struct
+				       cvmx_usb_iso_packet packets[],
+				       uint64_t buffer, int buffer_length,
+				       cvmx_usb_callback_func_t callback,
+				       void *user_data)
+{
+	int submit_handle;
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+
+	/* Pipe handle checking is done later in a common place */
+	if (unlikely(start_frame < 0))
+		return -EINVAL;
+	if (unlikely(number_packets < 1))
+		return -EINVAL;
+	if (unlikely(!packets))
+		return -EINVAL;
+	if (unlikely(!buffer))
+		return -EINVAL;
+	if (unlikely(buffer_length < 0))
+		return -EINVAL;
+
+	submit_handle = __cvmx_usb_submit_transaction(usb, pipe_handle,
+						      CVMX_USB_TRANSFER_ISOCHRONOUS,
+						      buffer,
+						      buffer_length,
+						      0, /* control_header */
+						      start_frame,
+						      number_packets,
+						      packets,
+						      callback,
+						      user_data);
+	return submit_handle;
+}
+
+
+/**
+ * Cancel one outstanding request in a pipe. Canceling a request
+ * can fail if the transaction has already completed before cancel
+ * is called. Even after a successful cancel call, it may take
+ * a frame or two for the cvmx_usb_poll() function to call the
+ * associated callback.
+ *
+ * @state:	 USB device state populated by
+ *		 cvmx_usb_initialize().
+ * @pipe_handle:
+ *		 Pipe handle to cancel requests in.
+ * @submit_handle:
+ *		 Handle to transaction to cancel, returned by the submit
+ *		 function.
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_cancel(struct cvmx_usb_state *state, int pipe_handle,
+			   int submit_handle)
+{
+	struct cvmx_usb_transaction *transaction;
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+	struct cvmx_usb_pipe *pipe = usb->pipe + pipe_handle;
+
+	if (unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
+		return -EINVAL;
+	if (unlikely((submit_handle < 0) || (submit_handle >= MAX_TRANSACTIONS)))
+		return -EINVAL;
+
+	/* Fail if the pipe isn't open */
+	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
+		return -EINVAL;
+
+	transaction = usb->transaction + submit_handle;
+
+	/* Fail if this transaction already completed */
+	if (unlikely((transaction->flags & __CVMX_USB_TRANSACTION_FLAGS_IN_USE) == 0))
+		return -EINVAL;
+
+	/*
+	 * If the transaction is the HEAD of the queue and scheduled. We need to
+	 * treat it special
+	 */
+	if ((pipe->head == transaction) &&
+		(pipe->flags & __CVMX_USB_PIPE_FLAGS_SCHEDULED)) {
+		union cvmx_usbcx_hccharx usbc_hcchar;
+
+		usb->pipe_for_channel[pipe->channel] = NULL;
+		pipe->flags &= ~__CVMX_USB_PIPE_FLAGS_SCHEDULED;
+
+		CVMX_SYNCW;
+
+		usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCCHARX(pipe->channel, usb->index));
+		/*
+		 * If the channel isn't enabled then the transaction already
+		 * completed.
+		 */
+		if (usbc_hcchar.s.chena) {
+			usbc_hcchar.s.chdis = 1;
+			__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCCHARX(pipe->channel, usb->index), usbc_hcchar.u32);
+		}
+	}
+	__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_CANCEL);
+	return 0;
+}
+
+
+/**
+ * Cancel all outstanding requests in a pipe. Logically all this
+ * does is call cvmx_usb_cancel() in a loop.
+ *
+ * @state:	 USB device state populated by
+ *		 cvmx_usb_initialize().
+ * @pipe_handle:
+ *		 Pipe handle to cancel requests in.
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_cancel_all(struct cvmx_usb_state *state, int pipe_handle)
+{
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+	struct cvmx_usb_pipe *pipe = usb->pipe + pipe_handle;
+
+	if (unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
+		return -EINVAL;
+
+	/* Fail if the pipe isn't open */
+	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
+		return -EINVAL;
+
+	/* Simply loop through and attempt to cancel each transaction */
+	while (pipe->head) {
+		int result = cvmx_usb_cancel(state, pipe_handle,
+			__cvmx_usb_get_submit_handle(usb, pipe->head));
+		if (unlikely(result != 0))
+			return result;
+	}
+	return 0;
+}
+
+
+/**
+ * Close a pipe created with cvmx_usb_open_pipe().
+ *
+ * @state:	 USB device state populated by
+ *		 cvmx_usb_initialize().
+ * @pipe_handle:
+ *		 Pipe handle to close.
+ *
+ * Returns: 0 or a negative error code. EBUSY is returned if the pipe has
+ *	    outstanding transfers.
+ */
+static int cvmx_usb_close_pipe(struct cvmx_usb_state *state, int pipe_handle)
+{
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+	struct cvmx_usb_pipe *pipe = usb->pipe + pipe_handle;
+
+	if (unlikely((pipe_handle < 0) || (pipe_handle >= MAX_PIPES)))
+		return -EINVAL;
+
+	/* Fail if the pipe isn't open */
+	if (unlikely((pipe->flags & __CVMX_USB_PIPE_FLAGS_OPEN) == 0))
+		return -EINVAL;
+
+	/* Fail if the pipe has pending transactions */
+	if (unlikely(pipe->head))
+		return -EBUSY;
+
+	pipe->flags = 0;
+	__cvmx_usb_remove_pipe(&usb->idle_pipes, pipe);
+	__cvmx_usb_append_pipe(&usb->free_pipes, pipe);
+
+	return 0;
+}
+
+
+/**
+ * Register a function to be called when various USB events occur.
+ *
+ * @state:     USB device state populated by
+ *	       cvmx_usb_initialize().
+ * @reason:    Which event to register for.
+ * @callback:  Function to call when the event occurs.
+ * @user_data: User data parameter to the function.
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_register_callback(struct cvmx_usb_state *state,
+				      enum cvmx_usb_callback reason,
+				      cvmx_usb_callback_func_t callback,
+				      void *user_data)
+{
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+
+	if (unlikely(reason >= __CVMX_USB_CALLBACK_END))
+		return -EINVAL;
+	if (unlikely(!callback))
+		return -EINVAL;
+
+	usb->callback[reason] = callback;
+	usb->callback_data[reason] = user_data;
+
+	return 0;
+}
+
+
+/**
+ * Get the current USB protocol level frame number. The frame
+ * number is always in the range of 0-0x7ff.
+ *
+ * @state: USB device state populated by
+ *	   cvmx_usb_initialize().
+ *
+ * Returns: USB frame number
+ */
+static int cvmx_usb_get_frame_number(struct cvmx_usb_state *state)
+{
+	int frame_number;
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+	union cvmx_usbcx_hfnum usbc_hfnum;
+
+	usbc_hfnum.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
+	frame_number = usbc_hfnum.s.frnum;
+
+	return frame_number;
+}
+
+
+/**
+ * Poll a channel for status
+ *
+ * @usb:     USB device
+ * @channel: Channel to poll
+ *
+ * Returns: Zero on success
+ */
+static int __cvmx_usb_poll_channel(struct cvmx_usb_internal_state *usb, int channel)
+{
+	union cvmx_usbcx_hcintx usbc_hcint;
+	union cvmx_usbcx_hctsizx usbc_hctsiz;
+	union cvmx_usbcx_hccharx usbc_hcchar;
+	struct cvmx_usb_pipe *pipe;
+	struct cvmx_usb_transaction *transaction;
+	int bytes_this_transfer;
+	int bytes_in_last_packet;
+	int packets_processed;
+	int buffer_space_left;
+
+	/* Read the interrupt status bits for the channel */
+	usbc_hcint.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCINTX(channel, usb->index));
+
+	if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {
+		usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index));
+
+		if (usbc_hcchar.s.chena && usbc_hcchar.s.chdis) {
+			/*
+			 * There seems to be a bug in CN31XX which can cause
+			 * interrupt IN transfers to get stuck until we do a
+			 * write of HCCHARX without changing things
+			 */
+			__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index), usbc_hcchar.u32);
+			return 0;
+		}
+
+		/*
+		 * In non DMA mode the channels don't halt themselves. We need
+		 * to manually disable channels that are left running
+		 */
+		if (!usbc_hcint.s.chhltd) {
+			if (usbc_hcchar.s.chena) {
+				union cvmx_usbcx_hcintmskx hcintmsk;
+				/* Disable all interrupts except CHHLTD */
+				hcintmsk.u32 = 0;
+				hcintmsk.s.chhltdmsk = 1;
+				__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), hcintmsk.u32);
+				usbc_hcchar.s.chdis = 1;
+				__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index), usbc_hcchar.u32);
+				return 0;
+			} else if (usbc_hcint.s.xfercompl) {
+				/*
+				 * Successful IN/OUT with transfer complete.
+				 * Channel halt isn't needed.
+				 */
+			} else {
+				cvmx_dprintf("USB%d: Channel %d interrupt without halt\n", usb->index, channel);
+				return 0;
+			}
+		}
+	} else {
+		/*
+		 * There is are no interrupts that we need to process when the
+		 * channel is still running
+		 */
+		if (!usbc_hcint.s.chhltd)
+			return 0;
+	}
+
+	/* Disable the channel interrupts now that it is done */
+	__cvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);
+	usb->idle_hardware_channels |= (1<<channel);
+
+	/* Make sure this channel is tied to a valid pipe */
+	pipe = usb->pipe_for_channel[channel];
+	CVMX_PREFETCH(pipe, 0);
+	CVMX_PREFETCH(pipe, 128);
+	if (!pipe)
+		return 0;
+	transaction = pipe->head;
+	CVMX_PREFETCH(transaction, 0);
+
+	/*
+	 * Disconnect this pipe from the HW channel. Later the schedule
+	 * function will figure out which pipe needs to go
+	 */
+	usb->pipe_for_channel[channel] = NULL;
+	pipe->flags &= ~__CVMX_USB_PIPE_FLAGS_SCHEDULED;
+
+	/*
+	 * Read the channel config info so we can figure out how much data
+	 * transfered
+	 */
+	usbc_hcchar.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCCHARX(channel, usb->index));
+	usbc_hctsiz.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index));
+
+	/*
+	 * Calculating the number of bytes successfully transferred is dependent
+	 * on the transfer direction
+	 */
+	packets_processed = transaction->pktcnt - usbc_hctsiz.s.pktcnt;
+	if (usbc_hcchar.s.epdir) {
+		/*
+		 * IN transactions are easy. For every byte received the
+		 * hardware decrements xfersize. All we need to do is subtract
+		 * the current value of xfersize from its starting value and we
+		 * know how many bytes were written to the buffer
+		 */
+		bytes_this_transfer = transaction->xfersize - usbc_hctsiz.s.xfersize;
+	} else {
+		/*
+		 * OUT transaction don't decrement xfersize. Instead pktcnt is
+		 * decremented on every successful packet send. The hardware
+		 * does this when it receives an ACK, or NYET. If it doesn't
+		 * receive one of these responses pktcnt doesn't change
+		 */
+		bytes_this_transfer = packets_processed * usbc_hcchar.s.mps;
+		/*
+		 * The last packet may not be a full transfer if we didn't have
+		 * enough data
+		 */
+		if (bytes_this_transfer > transaction->xfersize)
+			bytes_this_transfer = transaction->xfersize;
+	}
+	/* Figure out how many bytes were in the last packet of the transfer */
+	if (packets_processed)
+		bytes_in_last_packet = bytes_this_transfer - (packets_processed-1) * usbc_hcchar.s.mps;
+	else
+		bytes_in_last_packet = bytes_this_transfer;
+
+	/*
+	 * As a special case, setup transactions output the setup header, not
+	 * the user's data. For this reason we don't count setup data as bytes
+	 * transferred
+	 */
+	if ((transaction->stage == CVMX_USB_STAGE_SETUP) ||
+		(transaction->stage == CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE))
+		bytes_this_transfer = 0;
+
+	/*
+	 * Add the bytes transferred to the running total. It is important that
+	 * bytes_this_transfer doesn't count any data that needs to be
+	 * retransmitted
+	 */
+	transaction->actual_bytes += bytes_this_transfer;
+	if (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)
+		buffer_space_left = transaction->iso_packets[0].length - transaction->actual_bytes;
+	else
+		buffer_space_left = transaction->buffer_length - transaction->actual_bytes;
+
+	/*
+	 * We need to remember the PID toggle state for the next transaction.
+	 * The hardware already updated it for the next transaction
+	 */
+	pipe->pid_toggle = !(usbc_hctsiz.s.pid == 0);
+
+	/*
+	 * For high speed bulk out, assume the next transaction will need to do
+	 * a ping before proceeding. If this isn't true the ACK processing below
+	 * will clear this flag
+	 */
+	if ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&
+		(pipe->transfer_type == CVMX_USB_TRANSFER_BULK) &&
+		(pipe->transfer_dir == CVMX_USB_DIRECTION_OUT))
+		pipe->flags |= __CVMX_USB_PIPE_FLAGS_NEED_PING;
+
+	if (usbc_hcint.s.stall) {
+		/*
+		 * STALL as a response means this transaction cannot be
+		 * completed because the device can't process transactions. Tell
+		 * the user. Any data that was transferred will be counted on
+		 * the actual bytes transferred
+		 */
+		pipe->pid_toggle = 0;
+		__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_STALL);
+	} else if (usbc_hcint.s.xacterr) {
+		/*
+		 * We know at least one packet worked if we get a ACK or NAK.
+		 * Reset the retry counter
+		 */
+		if (usbc_hcint.s.nak || usbc_hcint.s.ack)
+			transaction->retries = 0;
+		transaction->retries++;
+		if (transaction->retries > MAX_RETRIES) {
+			/*
+			 * XactErr as a response means the device signaled
+			 * something wrong with the transfer. For example, PID
+			 * toggle errors cause these
+			 */
+			__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_XACTERR);
+		} else {
+			/*
+			 * If this was a split then clear our split in progress
+			 * marker
+			 */
+			if (usb->active_split == transaction)
+				usb->active_split = NULL;
+			/*
+			 * Rewind to the beginning of the transaction by anding
+			 * off the split complete bit
+			 */
+			transaction->stage &= ~1;
+			pipe->split_sc_frame = -1;
+			pipe->next_tx_frame += pipe->interval;
+			if (pipe->next_tx_frame < usb->frame_number)
+				pipe->next_tx_frame = usb->frame_number + pipe->interval -
+						      (usb->frame_number - pipe->next_tx_frame) % pipe->interval;
+		}
+	} else if (usbc_hcint.s.bblerr) {
+		/* Babble Error (BblErr) */
+		__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_BABBLEERR);
+	} else if (usbc_hcint.s.datatglerr) {
+		/* We'll retry the exact same transaction again */
+		transaction->retries++;
+	} else if (usbc_hcint.s.nyet) {
+		/*
+		 * NYET as a response is only allowed in three cases: as a
+		 * response to a ping, as a response to a split transaction, and
+		 * as a response to a bulk out. The ping case is handled by
+		 * hardware, so we only have splits and bulk out
+		 */
+		if (!__cvmx_usb_pipe_needs_split(usb, pipe)) {
+			transaction->retries = 0;
+			/*
+			 * If there is more data to go then we need to try
+			 * again. Otherwise this transaction is complete
+			 */
+			if ((buffer_space_left == 0) || (bytes_in_last_packet < pipe->max_packet))
+				__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+		} else {
+			/*
+			 * Split transactions retry the split complete 4 times
+			 * then rewind to the start split and do the entire
+			 * transactions again
+			 */
+			transaction->retries++;
+			if ((transaction->retries & 0x3) == 0) {
+				/*
+				 * Rewind to the beginning of the transaction by
+				 * anding off the split complete bit
+				 */
+				transaction->stage &= ~1;
+				pipe->split_sc_frame = -1;
+			}
+		}
+	} else if (usbc_hcint.s.ack) {
+		transaction->retries = 0;
+		/*
+		 * The ACK bit can only be checked after the other error bits.
+		 * This is because a multi packet transfer may succeed in a
+		 * number of packets and then get a different response on the
+		 * last packet. In this case both ACK and the last response bit
+		 * will be set. If none of the other response bits is set, then
+		 * the last packet must have been an ACK
+		 *
+		 * Since we got an ACK, we know we don't need to do a ping on
+		 * this pipe
+		 */
+		pipe->flags &= ~__CVMX_USB_PIPE_FLAGS_NEED_PING;
+
+		switch (transaction->type) {
+		case CVMX_USB_TRANSFER_CONTROL:
+			switch (transaction->stage) {
+			case CVMX_USB_STAGE_NON_CONTROL:
+			case CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:
+				/* This should be impossible */
+				__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_ERROR);
+				break;
+			case CVMX_USB_STAGE_SETUP:
+				pipe->pid_toggle = 1;
+				if (__cvmx_usb_pipe_needs_split(usb, pipe))
+					transaction->stage = CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE;
+				else {
+					union cvmx_usb_control_header *header =
+						cvmx_phys_to_ptr(transaction->control_header);
+					if (header->s.length)
+						transaction->stage = CVMX_USB_STAGE_DATA;
+					else
+						transaction->stage = CVMX_USB_STAGE_STATUS;
+				}
+				break;
+			case CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:
+				{
+					union cvmx_usb_control_header *header =
+						cvmx_phys_to_ptr(transaction->control_header);
+					if (header->s.length)
+						transaction->stage = CVMX_USB_STAGE_DATA;
+					else
+						transaction->stage = CVMX_USB_STAGE_STATUS;
+				}
+				break;
+			case CVMX_USB_STAGE_DATA:
+				if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+					transaction->stage = CVMX_USB_STAGE_DATA_SPLIT_COMPLETE;
+					/*
+					 * For setup OUT data that are splits,
+					 * the hardware doesn't appear to count
+					 * transferred data. Here we manually
+					 * update the data transferred
+					 */
+					if (!usbc_hcchar.s.epdir) {
+						if (buffer_space_left < pipe->max_packet)
+							transaction->actual_bytes += buffer_space_left;
+						else
+							transaction->actual_bytes += pipe->max_packet;
+					}
+				} else if ((buffer_space_left == 0) || (bytes_in_last_packet < pipe->max_packet)) {
+					pipe->pid_toggle = 1;
+					transaction->stage = CVMX_USB_STAGE_STATUS;
+				}
+				break;
+			case CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:
+				if ((buffer_space_left == 0) || (bytes_in_last_packet < pipe->max_packet)) {
+					pipe->pid_toggle = 1;
+					transaction->stage = CVMX_USB_STAGE_STATUS;
+				} else {
+					transaction->stage = CVMX_USB_STAGE_DATA;
+				}
+				break;
+			case CVMX_USB_STAGE_STATUS:
+				if (__cvmx_usb_pipe_needs_split(usb, pipe))
+					transaction->stage = CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;
+				else
+					__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+				break;
+			case CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:
+				__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+				break;
+			}
+			break;
+		case CVMX_USB_TRANSFER_BULK:
+		case CVMX_USB_TRANSFER_INTERRUPT:
+			/*
+			 * The only time a bulk transfer isn't complete when it
+			 * finishes with an ACK is during a split transaction.
+			 * For splits we need to continue the transfer if more
+			 * data is needed
+			 */
+			if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+				if (transaction->stage == CVMX_USB_STAGE_NON_CONTROL)
+					transaction->stage = CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
+				else {
+					if (buffer_space_left && (bytes_in_last_packet == pipe->max_packet))
+						transaction->stage = CVMX_USB_STAGE_NON_CONTROL;
+					else {
+						if (transaction->type == CVMX_USB_TRANSFER_INTERRUPT)
+							pipe->next_tx_frame += pipe->interval;
+							__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+					}
+				}
+			} else {
+				if ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&
+				    (pipe->transfer_type == CVMX_USB_TRANSFER_BULK) &&
+				    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) &&
+				    (usbc_hcint.s.nak))
+					pipe->flags |= __CVMX_USB_PIPE_FLAGS_NEED_PING;
+				if (!buffer_space_left || (bytes_in_last_packet < pipe->max_packet)) {
+					if (transaction->type == CVMX_USB_TRANSFER_INTERRUPT)
+						pipe->next_tx_frame += pipe->interval;
+					__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+				}
+			}
+			break;
+		case CVMX_USB_TRANSFER_ISOCHRONOUS:
+			if (__cvmx_usb_pipe_needs_split(usb, pipe)) {
+				/*
+				 * ISOCHRONOUS OUT splits don't require a
+				 * complete split stage. Instead they use a
+				 * sequence of begin OUT splits to transfer the
+				 * data 188 bytes at a time. Once the transfer
+				 * is complete, the pipe sleeps until the next
+				 * schedule interval
+				 */
+				if (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {
+					/*
+					 * If no space left or this wasn't a max
+					 * size packet then this transfer is
+					 * complete. Otherwise start it again to
+					 * send the next 188 bytes
+					 */
+					if (!buffer_space_left || (bytes_this_transfer < 188)) {
+						pipe->next_tx_frame += pipe->interval;
+						__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+					}
+				} else {
+					if (transaction->stage == CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE) {
+						/*
+						 * We are in the incoming data
+						 * phase. Keep getting data
+						 * until we run out of space or
+						 * get a small packet
+						 */
+						if ((buffer_space_left == 0) || (bytes_in_last_packet < pipe->max_packet)) {
+							pipe->next_tx_frame += pipe->interval;
+							__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+						}
+					} else
+						transaction->stage = CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;
+				}
+			} else {
+				pipe->next_tx_frame += pipe->interval;
+				__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_SUCCESS);
+			}
+			break;
+		}
+	} else if (usbc_hcint.s.nak) {
+		/*
+		 * If this was a split then clear our split in progress marker.
+		 */
+		if (usb->active_split == transaction)
+			usb->active_split = NULL;
+		/*
+		 * NAK as a response means the device couldn't accept the
+		 * transaction, but it should be retried in the future. Rewind
+		 * to the beginning of the transaction by anding off the split
+		 * complete bit. Retry in the next interval
+		 */
+		transaction->retries = 0;
+		transaction->stage &= ~1;
+		pipe->next_tx_frame += pipe->interval;
+		if (pipe->next_tx_frame < usb->frame_number)
+			pipe->next_tx_frame = usb->frame_number + pipe->interval -
+				(usb->frame_number - pipe->next_tx_frame) % pipe->interval;
+	} else {
+		struct cvmx_usb_port_status port;
+		port = cvmx_usb_get_status((struct cvmx_usb_state *)usb);
+		if (port.port_enabled) {
+			/* We'll retry the exact same transaction again */
+			transaction->retries++;
+		} else {
+			/*
+			 * We get channel halted interrupts with no result bits
+			 * sets when the cable is unplugged
+			 */
+			__cvmx_usb_perform_complete(usb, pipe, transaction, CVMX_USB_COMPLETE_ERROR);
+		}
+	}
+	return 0;
+}
+
+
+/**
+ * Poll the USB block for status and call all needed callback
+ * handlers. This function is meant to be called in the interrupt
+ * handler for the USB controller. It can also be called
+ * periodically in a loop for non-interrupt based operation.
+ *
+ * @state:	USB device state populated by
+ *		cvmx_usb_initialize().
+ *
+ * Returns: 0 or a negative error code.
+ */
+static int cvmx_usb_poll(struct cvmx_usb_state *state)
+{
+	union cvmx_usbcx_hfnum usbc_hfnum;
+	union cvmx_usbcx_gintsts usbc_gintsts;
+	struct cvmx_usb_internal_state *usb = (struct cvmx_usb_internal_state *)state;
+
+	CVMX_PREFETCH(usb, 0);
+	CVMX_PREFETCH(usb, 1*128);
+	CVMX_PREFETCH(usb, 2*128);
+	CVMX_PREFETCH(usb, 3*128);
+	CVMX_PREFETCH(usb, 4*128);
+
+	/* Update the frame counter */
+	usbc_hfnum.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));
+	if ((usb->frame_number&0x3fff) > usbc_hfnum.s.frnum)
+		usb->frame_number += 0x4000;
+	usb->frame_number &= ~0x3fffull;
+	usb->frame_number |= usbc_hfnum.s.frnum;
+
+	/* Read the pending interrupts */
+	usbc_gintsts.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_GINTSTS(usb->index));
+
+	/* Clear the interrupts now that we know about them */
+	__cvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index), usbc_gintsts.u32);
+
+	if (usbc_gintsts.s.rxflvl) {
+		/*
+		 * RxFIFO Non-Empty (RxFLvl)
+		 * Indicates that there is at least one packet pending to be
+		 * read from the RxFIFO.
+		 *
+		 * In DMA mode this is handled by hardware
+		 */
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+			__cvmx_usb_poll_rx_fifo(usb);
+	}
+	if (usbc_gintsts.s.ptxfemp || usbc_gintsts.s.nptxfemp) {
+		/* Fill the Tx FIFOs when not in DMA mode */
+		if (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)
+			__cvmx_usb_poll_tx_fifo(usb);
+	}
+	if (usbc_gintsts.s.disconnint || usbc_gintsts.s.prtint) {
+		union cvmx_usbcx_hprt usbc_hprt;
+		/*
+		 * Disconnect Detected Interrupt (DisconnInt)
+		 * Asserted when a device disconnect is detected.
+		 *
+		 * Host Port Interrupt (PrtInt)
+		 * The core sets this bit to indicate a change in port status of
+		 * one of the O2P USB core ports in Host mode. The application
+		 * must read the Host Port Control and Status (HPRT) register to
+		 * determine the exact event that caused this interrupt. The
+		 * application must clear the appropriate status bit in the Host
+		 * Port Control and Status register to clear this bit.
+		 *
+		 * Call the user's port callback
+		 */
+		__cvmx_usb_perform_callback(usb, NULL, NULL,
+					    CVMX_USB_CALLBACK_PORT_CHANGED,
+					    CVMX_USB_COMPLETE_SUCCESS);
+		/* Clear the port change bits */
+		usbc_hprt.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));
+		usbc_hprt.s.prtena = 0;
+		__cvmx_usb_write_csr32(usb, CVMX_USBCX_HPRT(usb->index), usbc_hprt.u32);
+	}
+	if (usbc_gintsts.s.hchint) {
+		/*
+		 * Host Channels Interrupt (HChInt)
+		 * The core sets this bit to indicate that an interrupt is
+		 * pending on one of the channels of the core (in Host mode).
+		 * The application must read the Host All Channels Interrupt
+		 * (HAINT) register to determine the exact number of the channel
+		 * on which the interrupt occurred, and then read the
+		 * corresponding Host Channel-n Interrupt (HCINTn) register to
+		 * determine the exact cause of the interrupt. The application
+		 * must clear the appropriate status bit in the HCINTn register
+		 * to clear this bit.
+		 */
+		union cvmx_usbcx_haint usbc_haint;
+		usbc_haint.u32 = __cvmx_usb_read_csr32(usb, CVMX_USBCX_HAINT(usb->index));
+		while (usbc_haint.u32) {
+			int channel;
+
+			channel = __fls(usbc_haint.u32);
+			__cvmx_usb_poll_channel(usb, channel);
+			usbc_haint.u32 ^= 1<<channel;
+		}
+	}
+
+	__cvmx_usb_schedule(usb, usbc_gintsts.s.sof);
+
+	return 0;
+}
+
 /* convert between an HCD pointer and the corresponding struct octeon_hcd */
 static inline struct octeon_hcd *hcd_to_octeon(struct usb_hcd *hcd)
 {

commit e43de55ce23918920ec9c0f95fc07904469fdb46
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Oct 1 23:43:12 2013 +0300

    staging: octeon-usb: delete redundant flags from cvmx_usb_open_pipe()
    
    Delete redudant flags parameter.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index f238d1bc4332..764a8df0a16e 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -277,7 +277,6 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 			}
 		}
 		pipe_handle = cvmx_usb_open_pipe(&priv->usb,
-						 0,
 						 usb_pipedevice(urb->pipe),
 						 usb_pipeendpoint(urb->pipe),
 						 speed,

commit 5dc0316c1bcc1f0db1bf42bfbe242401f954c932
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Oct 1 23:43:10 2013 +0300

    staging: octeon-usb: delete cvmx_usb_isochronous_flags
    
    Delete unused flags.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 9b9cc1f6be78..f238d1bc4332 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -325,7 +325,6 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 			urb->setup_packet = (char *)iso_packet;
 			submit_handle = cvmx_usb_submit_isochronous(&priv->usb, pipe_handle,
 							urb->start_frame,
-							0 /* flags */ ,
 							urb->number_of_packets,
 							iso_packet,
 							urb->transfer_dma,

commit 9be317e69e088ffe78aea5bd3dafa3f7b4feb77b
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Oct 1 23:43:09 2013 +0300

    staging: octeon-usb: delete redundant flags from cvmx_usb_initialize()
    
    The function will always figure out the used clock internally, so delete
    a redudant parameter and the flag.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 5dbbd14ec615..9b9cc1f6be78 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -705,7 +705,7 @@ static int octeon_usb_driver_probe(struct device *dev)
 	tasklet_init(&priv->dequeue_tasklet, octeon_usb_urb_dequeue_work, (unsigned long)priv);
 	INIT_LIST_HEAD(&priv->dequeue_list);
 
-	status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO);
+	status = cvmx_usb_initialize(&priv->usb, usb_num);
 	if (status) {
 		dev_dbg(dev, "USB initialization failed with %d\n", status);
 		kfree(hcd);

commit a24ed35a19bd97e2803ad4fcc39732734d62fd93
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Jul 30 23:43:05 2013 +0300

    staging: octeon-usb: cvmx_usb_state_t -> struct cvmx_usb_state
    
    Replace cvmx_usb_state_t with struct cvmx_usb_state.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 319f2e15662a..5dbbd14ec615 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -26,7 +26,7 @@
 
 struct octeon_hcd {
 	spinlock_t lock;
-	cvmx_usb_state_t usb;
+	struct cvmx_usb_state usb;
 	struct tasklet_struct dequeue_tasklet;
 	struct list_head dequeue_list;
 };
@@ -42,7 +42,7 @@ static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
 	return container_of((void *)p, struct usb_hcd, hcd_priv);
 }
 
-static inline struct octeon_hcd *cvmx_usb_to_octeon(cvmx_usb_state_t *p)
+static inline struct octeon_hcd *cvmx_usb_to_octeon(struct cvmx_usb_state *p)
 {
 	return container_of(p, struct octeon_hcd, usb);
 }
@@ -58,7 +58,7 @@ static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
 	return IRQ_HANDLED;
 }
 
-static void octeon_usb_port_callback(cvmx_usb_state_t *usb,
+static void octeon_usb_port_callback(struct cvmx_usb_state *usb,
 				     enum cvmx_usb_callback reason,
 				     enum cvmx_usb_complete status,
 				     int pipe_handle,
@@ -105,7 +105,7 @@ static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
 	return cvmx_usb_get_frame_number(&priv->usb);
 }
 
-static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
+static void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,
 					     enum cvmx_usb_callback reason,
 					     enum cvmx_usb_complete status,
 					     int pipe_handle,

commit 6e0e1b006993e0a4e2d39421d7adbe1ad92b7cbf
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Jul 30 23:43:04 2013 +0300

    staging: octeon-usb: cvmx_usb_iso_packet_t -> struct cvmx_usb_iso_packet
    
    Replace cvmx_usb_iso_packet_t with struct cvmx_usb_iso_packet.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 8a41d092b08b..319f2e15662a 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -141,7 +141,8 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 		 * The pointer to the private list is stored in the setup_packet
 		 * field.
 		 */
-		cvmx_usb_iso_packet_t *iso_packet = (cvmx_usb_iso_packet_t *) urb->setup_packet;
+		struct cvmx_usb_iso_packet *iso_packet =
+			(struct cvmx_usb_iso_packet *) urb->setup_packet;
 		/* Recalculate the transfer size by adding up each packet */
 		urb->actual_length = 0;
 		for (i = 0; i < urb->number_of_packets; i++) {
@@ -208,7 +209,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	int submit_handle = -1;
 	int pipe_handle;
 	unsigned long flags;
-	cvmx_usb_iso_packet_t *iso_packet;
+	struct cvmx_usb_iso_packet *iso_packet;
 	struct usb_host_endpoint *ep = urb->ep;
 
 	urb->status = 0;
@@ -305,7 +306,9 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		 * Allocate a structure to use for our private list of
 		 * isochronous packets.
 		 */
-		iso_packet = kmalloc(urb->number_of_packets * sizeof(cvmx_usb_iso_packet_t), GFP_ATOMIC);
+		iso_packet = kmalloc(urb->number_of_packets *
+				     sizeof(struct cvmx_usb_iso_packet),
+				     GFP_ATOMIC);
 		if (iso_packet) {
 			int i;
 			/* Fill the list with the data from the URB */

commit 51a19621ccb10191915220de8d2ec69bcb9862ac
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Jul 30 23:43:03 2013 +0300

    staging: octeon-usb: cvmx_usb_port_status_t -> struct cvmx_usb_port_status
    
    Replace cvmx_usb_port_status_t with struct cvmx_usb_port_status.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 5137da74c2b2..8a41d092b08b 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -440,7 +440,7 @@ static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_end
 static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
-	cvmx_usb_port_status_t port_status;
+	struct cvmx_usb_port_status port_status;
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->lock, flags);
@@ -456,7 +456,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	struct device *dev = hcd->self.controller;
-	cvmx_usb_port_status_t usb_port_status;
+	struct cvmx_usb_port_status usb_port_status;
 	int port_status;
 	struct usb_hub_descriptor *desc;
 	unsigned long flags;

commit e53b624ae56919b6b5c3e65543667293f3dedf99
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Jul 30 23:42:57 2013 +0300

    staging: octeon-usb: cvmx_usb_callback_t -> enum cvmx_usb_callback
    
    Replace cvmx_usb_callback_t with enum cvmx_usb_callback.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index b3c287394e07..5137da74c2b2 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -59,7 +59,7 @@ static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
 }
 
 static void octeon_usb_port_callback(cvmx_usb_state_t *usb,
-				     cvmx_usb_callback_t reason,
+				     enum cvmx_usb_callback reason,
 				     enum cvmx_usb_complete status,
 				     int pipe_handle,
 				     int submit_handle,
@@ -106,7 +106,7 @@ static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
 }
 
 static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
-					     cvmx_usb_callback_t reason,
+					     enum cvmx_usb_callback reason,
 					     enum cvmx_usb_complete status,
 					     int pipe_handle,
 					     int submit_handle,

commit 1c1bdf2764c7e5d983b20548a2913c0e4df07a3c
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Jul 30 23:42:56 2013 +0300

    staging: octeon-usb: cvmx_usb_complete_t -> enum cvmx_usb_complete
    
    Replace cvmx_usb_complete_t with enum cvmx_usb_complete.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 6ab78ed57e80..b3c287394e07 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -60,7 +60,7 @@ static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
 
 static void octeon_usb_port_callback(cvmx_usb_state_t *usb,
 				     cvmx_usb_callback_t reason,
-				     cvmx_usb_complete_t status,
+				     enum cvmx_usb_complete status,
 				     int pipe_handle,
 				     int submit_handle,
 				     int bytes_transferred,
@@ -107,7 +107,7 @@ static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
 
 static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 					     cvmx_usb_callback_t reason,
-					     cvmx_usb_complete_t status,
+					     enum cvmx_usb_complete status,
 					     int pipe_handle,
 					     int submit_handle,
 					     int bytes_transferred,

commit 394d4e080f31cd59ccfd1ab8983dcf79c8f7e774
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Jul 30 23:42:54 2013 +0300

    staging: octeon-usb: cvmx_usb_transfer_t -> enum cvmx_usb_transfer
    
    Replace cvmx_usb_transfer_t with enum cvmx_usb_transfer.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index f32d8fc60200..6ab78ed57e80 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -216,7 +216,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	spin_lock_irqsave(&priv->lock, flags);
 
 	if (!ep->hcpriv) {
-		cvmx_usb_transfer_t transfer_type;
+		enum cvmx_usb_transfer transfer_type;
 		enum cvmx_usb_speed speed;
 		int split_device = 0;
 		int split_port = 0;

commit 4918072eb0fa3d430613c11b4cb287e6c3bf1879
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Jul 30 23:42:53 2013 +0300

    staging: octeon-usb: cvmx_usb_speed_t -> enum cvmx_usb_speed
    
    Replace cvmx_usb_speed_t with enum cvmx_usb_speed.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index d156b603ae65..f32d8fc60200 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -217,7 +217,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 
 	if (!ep->hcpriv) {
 		cvmx_usb_transfer_t transfer_type;
-		cvmx_usb_speed_t speed;
+		enum cvmx_usb_speed speed;
 		int split_device = 0;
 		int split_port = 0;
 		switch (usb_pipetype(urb->pipe)) {

commit d935217df1b69c7695f442c758854c1ae17b1ae8
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Jun 18 02:36:20 2013 +0300

    staging: octeon-usb: octeon-hcd: eliminate printk()s
    
    Replace one printk() with dev_dbg(), and delete the other.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index fb9c082f39e7..d156b603ae65 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -723,7 +723,7 @@ static int octeon_usb_driver_probe(struct device *dev)
 		return -1;
 	}
 
-	printk("OcteonUSB: Registered HCD for port %d on irq %d\n", usb_num, irq);
+	dev_dbg(dev, "Registered HCD for port %d on irq %d\n", usb_num, irq);
 
 	return 0;
 }
@@ -771,7 +771,6 @@ static int __init octeon_usb_module_init(void)
 		return -ENOMEM;
 
 	octeon_usb_registered = 1;
-	printk("OcteonUSB: Detected %d ports\n", num_devices);
 
 	/*
 	 * Only cn52XX and cn56XX have DWC_OTG USB hardware and the

commit 334715f31b8b8c3bcde18de16d3cf5bd2df0c0a8
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Jun 18 02:36:18 2013 +0300

    staging: octeon-usb: octeon-hcd: delete commented-out code
    
    Delete commented-out code.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 50c602e325eb..fb9c082f39e7 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -702,7 +702,6 @@ static int octeon_usb_driver_probe(struct device *dev)
 	tasklet_init(&priv->dequeue_tasklet, octeon_usb_urb_dequeue_work, (unsigned long)priv);
 	INIT_LIST_HEAD(&priv->dequeue_list);
 
-	//status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS | CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS);
 	status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO);
 	if (status) {
 		dev_dbg(dev, "USB initialization failed with %d\n", status);

commit 87e7e57acd90deaa1d45bb2855c0fb5401e10fc8
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Jun 18 02:36:19 2013 +0300

    staging: octeon-usb: octeon-hcd: reformat long comments
    
    Fix some comments to fit into 80 colums.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index accd0c594307..50c602e325eb 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -137,7 +137,10 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 	   list from data in our private copy */
 	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
 		int i;
-		/* The pointer to the private list is stored in the setup_packet field */
+		/*
+		 * The pointer to the private list is stored in the setup_packet
+		 * field.
+		 */
 		cvmx_usb_iso_packet_t *iso_packet = (cvmx_usb_iso_packet_t *) urb->setup_packet;
 		/* Recalculate the transfer size by adding up each packet */
 		urb->actual_length = 0;
@@ -242,22 +245,33 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 			speed = CVMX_USB_SPEED_HIGH;
 			break;
 		}
-		/* For slow devices on high speed ports we need to find the hub that
-		   does the speed translation so we know where to send the split
-		   transactions */
+		/*
+		 * For slow devices on high speed ports we need to find the hub
+		 * that does the speed translation so we know where to send the
+		 * split transactions.
+		 */
 		if (speed != CVMX_USB_SPEED_HIGH) {
-			/* Start at this device and work our way up the usb tree */
+			/*
+			 * Start at this device and work our way up the usb
+			 * tree.
+			 */
 			struct usb_device *dev = urb->dev;
 			while (dev->parent) {
-				/* If our parent is high speed then he'll receive the splits */
+				/*
+				 * If our parent is high speed then he'll
+				 * receive the splits.
+				 */
 				if (dev->parent->speed == USB_SPEED_HIGH) {
 					split_device = dev->parent->devnum;
 					split_port = dev->portnum;
 					break;
 				}
-				/* Move up the tree one level. If we make it all the way up the
-				   tree, then the port must not be in high speed mode and we
-				   don't need a split */
+				/*
+				 * Move up the tree one level. If we make it all
+				 * the way up the tree, then the port must not
+				 * be in high speed mode and we don't need a
+				 * split.
+				 */
 				dev = dev->parent;
 			}
 		}
@@ -287,8 +301,10 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	case PIPE_ISOCHRONOUS:
 		dev_dbg(dev, "Submit isochronous to %d.%d\n",
 			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
-		/* Allocate a structure to use for our private list of isochronous
-		   packets */
+		/*
+		 * Allocate a structure to use for our private list of
+		 * isochronous packets.
+		 */
 		iso_packet = kmalloc(urb->number_of_packets * sizeof(cvmx_usb_iso_packet_t), GFP_ATOMIC);
 		if (iso_packet) {
 			int i;
@@ -298,9 +314,11 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 				iso_packet[i].length = urb->iso_frame_desc[i].length;
 				iso_packet[i].status = CVMX_USB_COMPLETE_ERROR;
 			}
-			/* Store a pointer to the list in uthe URB setup_pakcet field.
-			   We know this currently isn't being used and this saves us
-			   a bunch of logic */
+			/*
+			 * Store a pointer to the list in the URB setup_packet
+			 * field. We know this currently isn't being used and
+			 * this saves us a bunch of logic.
+			 */
 			urb->setup_packet = (char *)iso_packet;
 			submit_handle = cvmx_usb_submit_isochronous(&priv->usb, pipe_handle,
 							urb->start_frame,
@@ -311,7 +329,10 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 							urb->transfer_buffer_length,
 							octeon_usb_urb_complete_callback,
 							urb);
-			/* If submit failed we need to free our private packet list */
+			/*
+			 * If submit failed we need to free our private packet
+			 * list.
+			 */
 			if (submit_handle < 0) {
 				urb->setup_packet = NULL;
 				kfree(iso_packet);
@@ -487,23 +508,30 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			break;
 		case USB_PORT_FEAT_C_RESET:
 			dev_dbg(dev, " C_RESET\n");
-			/* Clears the driver's internal Port Reset Change flag */
+			/*
+			 * Clears the driver's internal Port Reset Change flag.
+			 */
 			spin_lock_irqsave(&priv->lock, flags);
 			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_ENABLE:
 			dev_dbg(dev, " C_ENABLE\n");
-			/* Clears the driver's internal Port Enable/Disable Change flag */
+			/*
+			 * Clears the driver's internal Port Enable/Disable
+			 * Change flag.
+			 */
 			spin_lock_irqsave(&priv->lock, flags);
 			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			dev_dbg(dev, " C_SUSPEND\n");
-			/* Clears the driver's internal Port Suspend Change flag,
-			   which is set when resume signaling on the host port is
-			   complete */
+			/*
+			 * Clears the driver's internal Port Suspend Change
+			 * flag, which is set when resume signaling on the host
+			 * port is complete.
+			 */
 			break;
 		case USB_PORT_FEAT_C_OVER_CURRENT:
 			dev_dbg(dev, " C_OVER_CURRENT\n");
@@ -654,8 +682,10 @@ static int octeon_usb_driver_probe(struct device *dev)
 	struct usb_hcd *hcd;
 	unsigned long flags;
 
-	/* Set the DMA mask to 64bits so we get buffers already translated for
-	   DMA */
+	/*
+	 * Set the DMA mask to 64bits so we get buffers already translated for
+	 * DMA.
+	 */
 	dev->coherent_dma_mask = ~0;
 	dev->dma_mask = &dev->coherent_dma_mask;
 

commit 71e06db3b953b8cc57dec097bdc08b7ed4852277
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Jun 18 02:36:17 2013 +0300

    staging: octeon-usb: octeon-hcd: use dev_dbg
    
    Replace DEBUG macros with dev_dbg. Some less useful are completely
    deleted.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index da222071d17e..accd0c594307 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -24,16 +24,6 @@
 
 #include <linux/err.h>
 
-//#define DEBUG_CALL(format, ...)         printk(format, ##__VA_ARGS__)
-#define DEBUG_CALL(format, ...)         do {} while (0)
-//#define DEBUG_SUBMIT(format, ...)       printk(format, ##__VA_ARGS__)
-#define DEBUG_SUBMIT(format, ...)       do {} while (0)
-//#define DEBUG_ROOT_HUB(format, ...)     printk(format, ##__VA_ARGS__)
-#define DEBUG_ROOT_HUB(format, ...)     do {} while (0)
-//#define DEBUG_ERROR(format, ...)        printk(format, ##__VA_ARGS__)
-#define DEBUG_ERROR(format, ...)        do {} while (0)
-#define DEBUG_FATAL(format, ...)        printk(format, ##__VA_ARGS__)
-
 struct octeon_hcd {
 	spinlock_t lock;
 	cvmx_usb_state_t usb;
@@ -61,7 +51,7 @@ static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	unsigned long flags;
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
 	spin_lock_irqsave(&priv->lock, flags);
 	cvmx_usb_poll(&priv->usb);
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -77,7 +67,7 @@ static void octeon_usb_port_callback(cvmx_usb_state_t *usb,
 				     void *user_data)
 {
 	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
 	spin_unlock(&priv->lock);
 	usb_hcd_poll_rh_status(octeon_to_hcd(priv));
 	spin_lock(&priv->lock);
@@ -87,7 +77,7 @@ static int octeon_usb_start(struct usb_hcd *hcd)
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	unsigned long flags;
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
 	hcd->state = HC_STATE_RUNNING;
 	spin_lock_irqsave(&priv->lock, flags);
 	cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
@@ -100,7 +90,7 @@ static void octeon_usb_stop(struct usb_hcd *hcd)
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	unsigned long flags;
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
 	spin_lock_irqsave(&priv->lock, flags);
 	cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
 				   NULL, NULL);
@@ -111,7 +101,7 @@ static void octeon_usb_stop(struct usb_hcd *hcd)
 static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
 	return cvmx_usb_get_frame_number(&priv->usb);
 }
 
@@ -124,8 +114,10 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 					     void *user_data)
 {
 	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
+	struct usb_hcd *hcd = octeon_to_hcd(priv);
+	struct device *dev = hcd->self.controller;
 	struct urb *urb = user_data;
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
 	urb->actual_length = bytes_transferred;
 	urb->hcpriv = NULL;
 
@@ -155,10 +147,10 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 				urb->iso_frame_desc[i].actual_length = iso_packet[i].length;
 				urb->actual_length += urb->iso_frame_desc[i].actual_length;
 			} else {
-				DEBUG_ERROR("%s: ISOCHRONOUS packet=%d of %d status=%d pipe=%d submit=%d size=%d\n",
-				     __FUNCTION__, i, urb->number_of_packets,
-				     iso_packet[i].status, pipe_handle,
-				     submit_handle, iso_packet[i].length);
+				dev_dbg(dev, "ISOCHRONOUS packet=%d of %d status=%d pipe=%d submit=%d size=%d\n",
+					i, urb->number_of_packets,
+					iso_packet[i].status, pipe_handle,
+					submit_handle, iso_packet[i].length);
 				urb->iso_frame_desc[i].status = -EREMOTEIO;
 			}
 		}
@@ -176,22 +168,26 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 			urb->status = -ENOENT;
 		break;
 	case CVMX_USB_COMPLETE_STALL:
-		DEBUG_ERROR("%s: status=stall pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
+		dev_dbg(dev, "status=stall pipe=%d submit=%d size=%d\n",
+			pipe_handle, submit_handle, bytes_transferred);
 		urb->status = -EPIPE;
 		break;
 	case CVMX_USB_COMPLETE_BABBLEERR:
-		DEBUG_ERROR("%s: status=babble pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
+		dev_dbg(dev, "status=babble pipe=%d submit=%d size=%d\n",
+			pipe_handle, submit_handle, bytes_transferred);
 		urb->status = -EPIPE;
 		break;
 	case CVMX_USB_COMPLETE_SHORT:
-		DEBUG_ERROR("%s: status=short pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
+		dev_dbg(dev, "status=short pipe=%d submit=%d size=%d\n",
+			pipe_handle, submit_handle, bytes_transferred);
 		urb->status = -EREMOTEIO;
 		break;
 	case CVMX_USB_COMPLETE_ERROR:
 	case CVMX_USB_COMPLETE_XACTERR:
 	case CVMX_USB_COMPLETE_DATATGLERR:
 	case CVMX_USB_COMPLETE_FRAMEERR:
-		DEBUG_ERROR("%s: status=%d pipe=%d submit=%d size=%d\n", __FUNCTION__, status, pipe_handle, submit_handle, bytes_transferred);
+		dev_dbg(dev, "status=%d pipe=%d submit=%d size=%d\n",
+			status, pipe_handle, submit_handle, bytes_transferred);
 		urb->status = -EPROTO;
 		break;
 	}
@@ -205,14 +201,13 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 				  gfp_t mem_flags)
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	struct device *dev = hcd->self.controller;
 	int submit_handle = -1;
 	int pipe_handle;
 	unsigned long flags;
 	cvmx_usb_iso_packet_t *iso_packet;
 	struct usb_host_endpoint *ep = urb->ep;
 
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-
 	urb->status = 0;
 	INIT_LIST_HEAD(&urb->urb_list);	/* not enqueued on dequeue_list */
 	spin_lock_irqsave(&priv->lock, flags);
@@ -280,7 +275,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 						 split_port);
 		if (pipe_handle < 0) {
 			spin_unlock_irqrestore(&priv->lock, flags);
-			DEBUG_ERROR("OcteonUSB: %s failed to create pipe\n", __FUNCTION__);
+			dev_dbg(dev, "Failed to create pipe\n");
 			return -ENOMEM;
 		}
 		ep->hcpriv = (void *)(0x10000L + pipe_handle);
@@ -290,7 +285,8 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 
 	switch (usb_pipetype(urb->pipe)) {
 	case PIPE_ISOCHRONOUS:
-		DEBUG_SUBMIT("OcteonUSB: %s submit isochronous to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		dev_dbg(dev, "Submit isochronous to %d.%d\n",
+			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
 		/* Allocate a structure to use for our private list of isochronous
 		   packets */
 		iso_packet = kmalloc(urb->number_of_packets * sizeof(cvmx_usb_iso_packet_t), GFP_ATOMIC);
@@ -323,7 +319,8 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 		}
 		break;
 	case PIPE_INTERRUPT:
-		DEBUG_SUBMIT("OcteonUSB: %s submit interrupt to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		dev_dbg(dev, "Submit interrupt to %d.%d\n",
+			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
 		submit_handle = cvmx_usb_submit_interrupt(&priv->usb, pipe_handle,
 					      urb->transfer_dma,
 					      urb->transfer_buffer_length,
@@ -331,7 +328,8 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 					      urb);
 		break;
 	case PIPE_CONTROL:
-		DEBUG_SUBMIT("OcteonUSB: %s submit control to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		dev_dbg(dev, "Submit control to %d.%d\n",
+			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
 		submit_handle = cvmx_usb_submit_control(&priv->usb, pipe_handle,
 					    urb->setup_dma,
 					    urb->transfer_dma,
@@ -340,7 +338,8 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 					    urb);
 		break;
 	case PIPE_BULK:
-		DEBUG_SUBMIT("OcteonUSB: %s submit bulk to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		dev_dbg(dev, "Submit bulk to %d.%d\n",
+			usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
 		submit_handle = cvmx_usb_submit_bulk(&priv->usb, pipe_handle,
 					 urb->transfer_dma,
 					 urb->transfer_buffer_length,
@@ -350,7 +349,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	}
 	if (submit_handle < 0) {
 		spin_unlock_irqrestore(&priv->lock, flags);
-		DEBUG_ERROR("OcteonUSB: %s failed to submit\n", __FUNCTION__);
+		dev_dbg(dev, "Failed to submit\n");
 		return -ENOMEM;
 	}
 	urb->hcpriv = (void *)(long)(((submit_handle & 0xffff) << 16) | pipe_handle);
@@ -385,8 +384,6 @@ static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int stat
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	unsigned long flags;
 
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-
 	if (!urb->dev)
 		return -EINVAL;
 
@@ -404,7 +401,8 @@ static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int stat
 
 static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 {
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	struct device *dev = hcd->self.controller;
+
 	if (ep->hcpriv) {
 		struct octeon_hcd *priv = hcd_to_octeon(hcd);
 		int pipe_handle = 0xffff & (long)ep->hcpriv;
@@ -412,7 +410,7 @@ static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_end
 		spin_lock_irqsave(&priv->lock, flags);
 		cvmx_usb_cancel_all(&priv->usb, pipe_handle);
 		if (cvmx_usb_close_pipe(&priv->usb, pipe_handle))
-			DEBUG_ERROR("OcteonUSB: Closing pipe %d failed\n", pipe_handle);
+			dev_dbg(dev, "Closing pipe %d failed\n", pipe_handle);
 		spin_unlock_irqrestore(&priv->lock, flags);
 		ep->hcpriv = NULL;
 	}
@@ -424,8 +422,6 @@ static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
 	cvmx_usb_port_status_t port_status;
 	unsigned long flags;
 
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-
 	spin_lock_irqsave(&priv->lock, flags);
 	port_status = cvmx_usb_get_status(&priv->usb);
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -438,6 +434,7 @@ static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
 static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex, char *buf, u16 wLength)
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	struct device *dev = hcd->self.controller;
 	cvmx_usb_port_status_t usb_port_status;
 	int port_status;
 	struct usb_hub_descriptor *desc;
@@ -445,7 +442,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 
 	switch (typeReq) {
 	case ClearHubFeature:
-		DEBUG_ROOT_HUB("OcteonUSB: ClearHubFeature\n");
+		dev_dbg(dev, "ClearHubFeature\n");
 		switch (wValue) {
 		case C_HUB_LOCAL_POWER:
 		case C_HUB_OVER_CURRENT:
@@ -456,73 +453,72 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		}
 		break;
 	case ClearPortFeature:
-		DEBUG_ROOT_HUB("OcteonUSB: ClearPortFeature");
+		dev_dbg(dev, "ClearPortFeature\n");
 		if (wIndex != 1) {
-			DEBUG_ROOT_HUB(" INVALID\n");
+			dev_dbg(dev, " INVALID\n");
 			return -EINVAL;
 		}
 
 		switch (wValue) {
 		case USB_PORT_FEAT_ENABLE:
-			DEBUG_ROOT_HUB(" ENABLE");
+			dev_dbg(dev, " ENABLE\n");
 			spin_lock_irqsave(&priv->lock, flags);
 			cvmx_usb_disable(&priv->usb);
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		case USB_PORT_FEAT_SUSPEND:
-			DEBUG_ROOT_HUB(" SUSPEND");
+			dev_dbg(dev, " SUSPEND\n");
 			/* Not supported on Octeon */
 			break;
 		case USB_PORT_FEAT_POWER:
-			DEBUG_ROOT_HUB(" POWER");
+			dev_dbg(dev, " POWER\n");
 			/* Not supported on Octeon */
 			break;
 		case USB_PORT_FEAT_INDICATOR:
-			DEBUG_ROOT_HUB(" INDICATOR");
+			dev_dbg(dev, " INDICATOR\n");
 			/* Port inidicator not supported */
 			break;
 		case USB_PORT_FEAT_C_CONNECTION:
-			DEBUG_ROOT_HUB(" C_CONNECTION");
+			dev_dbg(dev, " C_CONNECTION\n");
 			/* Clears drivers internal connect status change flag */
 			spin_lock_irqsave(&priv->lock, flags);
 			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_RESET:
-			DEBUG_ROOT_HUB(" C_RESET");
+			dev_dbg(dev, " C_RESET\n");
 			/* Clears the driver's internal Port Reset Change flag */
 			spin_lock_irqsave(&priv->lock, flags);
 			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_ENABLE:
-			DEBUG_ROOT_HUB(" C_ENABLE");
+			dev_dbg(dev, " C_ENABLE\n");
 			/* Clears the driver's internal Port Enable/Disable Change flag */
 			spin_lock_irqsave(&priv->lock, flags);
 			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
-			DEBUG_ROOT_HUB(" C_SUSPEND");
+			dev_dbg(dev, " C_SUSPEND\n");
 			/* Clears the driver's internal Port Suspend Change flag,
 			   which is set when resume signaling on the host port is
 			   complete */
 			break;
 		case USB_PORT_FEAT_C_OVER_CURRENT:
-			DEBUG_ROOT_HUB(" C_OVER_CURRENT");
+			dev_dbg(dev, " C_OVER_CURRENT\n");
 			/* Clears the driver's overcurrent Change flag */
 			spin_lock_irqsave(&priv->lock, flags);
 			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
 			spin_unlock_irqrestore(&priv->lock, flags);
 			break;
 		default:
-			DEBUG_ROOT_HUB(" UNKNOWN\n");
+			dev_dbg(dev, " UNKNOWN\n");
 			return -EINVAL;
 		}
-		DEBUG_ROOT_HUB("\n");
 		break;
 	case GetHubDescriptor:
-		DEBUG_ROOT_HUB("OcteonUSB: GetHubDescriptor\n");
+		dev_dbg(dev, "GetHubDescriptor\n");
 		desc = (struct usb_hub_descriptor *)buf;
 		desc->bDescLength = 9;
 		desc->bDescriptorType = 0x29;
@@ -534,13 +530,13 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		desc->u.hs.DeviceRemovable[1] = 0xff;
 		break;
 	case GetHubStatus:
-		DEBUG_ROOT_HUB("OcteonUSB: GetHubStatus\n");
+		dev_dbg(dev, "GetHubStatus\n");
 		*(__le32 *) buf = 0;
 		break;
 	case GetPortStatus:
-		DEBUG_ROOT_HUB("OcteonUSB: GetPortStatus");
+		dev_dbg(dev, "GetPortStatus\n");
 		if (wIndex != 1) {
-			DEBUG_ROOT_HUB(" INVALID\n");
+			dev_dbg(dev, " INVALID\n");
 			return -EINVAL;
 		}
 
@@ -551,82 +547,81 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 
 		if (usb_port_status.connect_change) {
 			port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
-			DEBUG_ROOT_HUB(" C_CONNECTION");
+			dev_dbg(dev, " C_CONNECTION\n");
 		}
 
 		if (usb_port_status.port_enabled) {
 			port_status |= (1 << USB_PORT_FEAT_C_ENABLE);
-			DEBUG_ROOT_HUB(" C_ENABLE");
+			dev_dbg(dev, " C_ENABLE\n");
 		}
 
 		if (usb_port_status.connected) {
 			port_status |= (1 << USB_PORT_FEAT_CONNECTION);
-			DEBUG_ROOT_HUB(" CONNECTION");
+			dev_dbg(dev, " CONNECTION\n");
 		}
 
 		if (usb_port_status.port_enabled) {
 			port_status |= (1 << USB_PORT_FEAT_ENABLE);
-			DEBUG_ROOT_HUB(" ENABLE");
+			dev_dbg(dev, " ENABLE\n");
 		}
 
 		if (usb_port_status.port_over_current) {
 			port_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);
-			DEBUG_ROOT_HUB(" OVER_CURRENT");
+			dev_dbg(dev, " OVER_CURRENT\n");
 		}
 
 		if (usb_port_status.port_powered) {
 			port_status |= (1 << USB_PORT_FEAT_POWER);
-			DEBUG_ROOT_HUB(" POWER");
+			dev_dbg(dev, " POWER\n");
 		}
 
 		if (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH) {
 			port_status |= USB_PORT_STAT_HIGH_SPEED;
-			DEBUG_ROOT_HUB(" HIGHSPEED");
+			dev_dbg(dev, " HIGHSPEED\n");
 		} else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW) {
 			port_status |= (1 << USB_PORT_FEAT_LOWSPEED);
-			DEBUG_ROOT_HUB(" LOWSPEED");
+			dev_dbg(dev, " LOWSPEED\n");
 		}
 
 		*((__le32 *) buf) = cpu_to_le32(port_status);
-		DEBUG_ROOT_HUB("\n");
 		break;
 	case SetHubFeature:
-		DEBUG_ROOT_HUB("OcteonUSB: SetHubFeature\n");
+		dev_dbg(dev, "SetHubFeature\n");
 		/* No HUB features supported */
 		break;
 	case SetPortFeature:
-		DEBUG_ROOT_HUB("OcteonUSB: SetPortFeature");
+		dev_dbg(dev, "SetPortFeature\n");
 		if (wIndex != 1) {
-			DEBUG_ROOT_HUB(" INVALID\n");
+			dev_dbg(dev, " INVALID\n");
 			return -EINVAL;
 		}
 
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
-			DEBUG_ROOT_HUB(" SUSPEND\n");
+			dev_dbg(dev, " SUSPEND\n");
 			return -EINVAL;
 		case USB_PORT_FEAT_POWER:
-			DEBUG_ROOT_HUB(" POWER\n");
+			dev_dbg(dev, " POWER\n");
 			return -EINVAL;
 		case USB_PORT_FEAT_RESET:
-			DEBUG_ROOT_HUB(" RESET\n");
+			dev_dbg(dev, " RESET\n");
 			spin_lock_irqsave(&priv->lock, flags);
 			cvmx_usb_disable(&priv->usb);
 			if (cvmx_usb_enable(&priv->usb))
-				DEBUG_ERROR("Failed to enable the port\n");
+				dev_dbg(dev, "Failed to enable the port\n");
 			spin_unlock_irqrestore(&priv->lock, flags);
 			return 0;
 		case USB_PORT_FEAT_INDICATOR:
-			DEBUG_ROOT_HUB(" INDICATOR\n");
+			dev_dbg(dev, " INDICATOR\n");
 			/* Not supported */
 			break;
 		default:
-			DEBUG_ROOT_HUB(" UNKNOWN\n");
+			dev_dbg(dev, " UNKNOWN\n");
 			return -EINVAL;
 		}
 		break;
 	default:
-		DEBUG_ROOT_HUB("OcteonUSB: Unknown root hub request\n");
+		dev_dbg(dev, "Unknown root hub request\n");
 		return -EINVAL;
 	}
 	return 0;
@@ -659,8 +654,6 @@ static int octeon_usb_driver_probe(struct device *dev)
 	struct usb_hcd *hcd;
 	unsigned long flags;
 
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-
 	/* Set the DMA mask to 64bits so we get buffers already translated for
 	   DMA */
 	dev->coherent_dma_mask = ~0;
@@ -668,7 +661,7 @@ static int octeon_usb_driver_probe(struct device *dev)
 
 	hcd = usb_create_hcd(&octeon_hc_driver, dev, dev_name(dev));
 	if (!hcd) {
-		DEBUG_FATAL("OcteonUSB: Failed to allocate memory for HCD\n");
+		dev_dbg(dev, "Failed to allocate memory for HCD\n");
 		return -1;
 	}
 	hcd->uses_new_polling = 1;
@@ -682,7 +675,7 @@ static int octeon_usb_driver_probe(struct device *dev)
 	//status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS | CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS);
 	status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO);
 	if (status) {
-		DEBUG_FATAL("OcteonUSB: USB initialization failed with %d\n", status);
+		dev_dbg(dev, "USB initialization failed with %d\n", status);
 		kfree(hcd);
 		return -1;
 	}
@@ -696,7 +689,7 @@ static int octeon_usb_driver_probe(struct device *dev)
 
 	status = usb_add_hcd(hcd, irq, IRQF_SHARED);
 	if (status) {
-		DEBUG_FATAL("OcteonUSB: USB add HCD failed with %d\n", status);
+		dev_dbg(dev, "USB add HCD failed with %d\n", status);
 		kfree(hcd);
 		return -1;
 	}
@@ -713,15 +706,13 @@ static int octeon_usb_driver_remove(struct device *dev)
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	unsigned long flags;
 
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-
 	usb_remove_hcd(hcd);
 	tasklet_kill(&priv->dequeue_tasklet);
 	spin_lock_irqsave(&priv->lock, flags);
 	status = cvmx_usb_shutdown(&priv->usb);
 	spin_unlock_irqrestore(&priv->lock, flags);
 	if (status)
-		DEBUG_FATAL("OcteonUSB: USB shutdown failed with %d\n", status);
+		dev_dbg(dev, "USB shutdown failed with %d\n", status);
 
 	kfree(hcd);
 
@@ -747,10 +738,9 @@ static int __init octeon_usb_module_init(void)
 	if (usb_disabled() || num_devices == 0)
 		return -ENODEV;
 
-	if (driver_register(&octeon_usb_driver)) {
-		DEBUG_FATAL("OcteonUSB: Failed to register driver\n");
+	if (driver_register(&octeon_usb_driver))
 		return -ENOMEM;
-	}
+
 	octeon_usb_registered = 1;
 	printk("OcteonUSB: Detected %d ports\n", num_devices);
 
@@ -783,7 +773,6 @@ static int __init octeon_usb_module_init(void)
 		irq_resource.flags = IORESOURCE_IRQ;
 		pdev = platform_device_register_simple((char *)octeon_usb_driver.  name, device, &irq_resource, 1);
 		if (IS_ERR(pdev)) {
-			DEBUG_FATAL("OcteonUSB: Failed to allocate platform device for USB%d\n", device);
 			driver_unregister(&octeon_usb_driver);
 			octeon_usb_registered = 0;
 			return PTR_ERR(pdev);
@@ -798,7 +787,7 @@ static int __init octeon_usb_module_init(void)
 static void __exit octeon_usb_module_cleanup(void)
 {
 	int i;
-	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
 	for (i = 0; i < MAX_USB_PORTS; i++)
 		if (pdev_glob[i]) {
 			platform_device_unregister(pdev_glob[i]);

commit f5ed3a3870f01853b24b0002c392ef604f2e8585
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Jun 13 01:00:38 2013 +0300

    staging: octeon-usb: octeon-hcd: make internal variable static
    
    Make an internal variable static.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 29f628803cf4..da222071d17e 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -737,7 +737,7 @@ static struct device_driver octeon_usb_driver = {
 
 
 #define MAX_USB_PORTS   10
-struct platform_device *pdev_glob[MAX_USB_PORTS];
+static struct platform_device *pdev_glob[MAX_USB_PORTS];
 static int octeon_usb_registered;
 static int __init octeon_usb_module_init(void)
 {

commit 2a81d2b01f0c83f270ca163174f431b548481a17
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Jun 13 01:00:35 2013 +0300

    staging: octeon-usb: octeon-hcd: fix some includes
    
    Avoid including from "asm/".
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index f4e2ca5e8720..29f628803cf4 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -13,8 +13,8 @@
 #include <linux/platform_device.h>
 #include <linux/usb.h>
 
-#include <asm/time.h>
-#include <asm/delay.h>
+#include <linux/time.h>
+#include <linux/delay.h>
 
 #include <asm/octeon/cvmx.h>
 #include "cvmx-usb.h"

commit c7609eac88d26856c6e9299902da2475597f6867
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Jun 13 01:00:33 2013 +0300

    staging: octeon-usb: octeon-hcd: add missing braces
    
    One else branch was missing braces.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 05c86ff8563e..f4e2ca5e8720 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -284,9 +284,9 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 			return -ENOMEM;
 		}
 		ep->hcpriv = (void *)(0x10000L + pipe_handle);
-	}
-	else
+	} else {
 		pipe_handle = 0xffff & (long)ep->hcpriv;
+	}
 
 	switch (usb_pipetype(urb->pipe)) {
 	case PIPE_ISOCHRONOUS:

commit 771378bb05c16d5aa9d7913b4947068795852055
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Thu Jun 13 01:00:31 2013 +0300

    staging: octeon-usb: octeon-hcd: use tabs for code indent
    
    Replace spaces with tabs where possible.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 08de25f94754..05c86ff8563e 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -35,10 +35,10 @@
 #define DEBUG_FATAL(format, ...)        printk(format, ##__VA_ARGS__)
 
 struct octeon_hcd {
-    spinlock_t lock;
-    cvmx_usb_state_t usb;
-    struct tasklet_struct dequeue_tasklet;
-    struct list_head dequeue_list;
+	spinlock_t lock;
+	cvmx_usb_state_t usb;
+	struct tasklet_struct dequeue_tasklet;
+	struct list_head dequeue_list;
 };
 
 /* convert between an HCD pointer and the corresponding struct octeon_hcd */
@@ -59,75 +59,75 @@ static inline struct octeon_hcd *cvmx_usb_to_octeon(cvmx_usb_state_t *p)
 
 static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
 {
-    struct octeon_hcd *priv = hcd_to_octeon(hcd);
-    unsigned long flags;
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-    spin_lock_irqsave(&priv->lock, flags);
-    cvmx_usb_poll(&priv->usb);
-    spin_unlock_irqrestore(&priv->lock, flags);
-    return IRQ_HANDLED;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	unsigned long flags;
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	spin_lock_irqsave(&priv->lock, flags);
+	cvmx_usb_poll(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return IRQ_HANDLED;
 }
 
 static void octeon_usb_port_callback(cvmx_usb_state_t *usb,
-                                     cvmx_usb_callback_t reason,
-                                     cvmx_usb_complete_t status,
-                                     int pipe_handle,
-                                     int submit_handle,
-                                     int bytes_transferred,
-                                     void *user_data)
+				     cvmx_usb_callback_t reason,
+				     cvmx_usb_complete_t status,
+				     int pipe_handle,
+				     int submit_handle,
+				     int bytes_transferred,
+				     void *user_data)
 {
-    struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-    spin_unlock(&priv->lock);
-    usb_hcd_poll_rh_status(octeon_to_hcd(priv));
-    spin_lock(&priv->lock);
+	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	spin_unlock(&priv->lock);
+	usb_hcd_poll_rh_status(octeon_to_hcd(priv));
+	spin_lock(&priv->lock);
 }
 
 static int octeon_usb_start(struct usb_hcd *hcd)
 {
-    struct octeon_hcd *priv = hcd_to_octeon(hcd);
-    unsigned long flags;
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-    hcd->state = HC_STATE_RUNNING;
-    spin_lock_irqsave(&priv->lock, flags);
-    cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
-                               octeon_usb_port_callback, NULL);
-    spin_unlock_irqrestore(&priv->lock, flags);
-    return 0;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	unsigned long flags;
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	hcd->state = HC_STATE_RUNNING;
+	spin_lock_irqsave(&priv->lock, flags);
+	cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
+				   octeon_usb_port_callback, NULL);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return 0;
 }
 
 static void octeon_usb_stop(struct usb_hcd *hcd)
 {
-    struct octeon_hcd *priv = hcd_to_octeon(hcd);
-    unsigned long flags;
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-    spin_lock_irqsave(&priv->lock, flags);
-    cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
-                               NULL, NULL);
-    spin_unlock_irqrestore(&priv->lock, flags);
-    hcd->state = HC_STATE_HALT;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	unsigned long flags;
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	spin_lock_irqsave(&priv->lock, flags);
+	cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
+				   NULL, NULL);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	hcd->state = HC_STATE_HALT;
 }
 
 static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
 {
-    struct octeon_hcd *priv = hcd_to_octeon(hcd);
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-    return cvmx_usb_get_frame_number(&priv->usb);
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	return cvmx_usb_get_frame_number(&priv->usb);
 }
 
 static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
-                                             cvmx_usb_callback_t reason,
-                                             cvmx_usb_complete_t status,
-                                             int pipe_handle,
-                                             int submit_handle,
-                                             int bytes_transferred,
-                                             void *user_data)
+					     cvmx_usb_callback_t reason,
+					     cvmx_usb_complete_t status,
+					     int pipe_handle,
+					     int submit_handle,
+					     int bytes_transferred,
+					     void *user_data)
 {
-    struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
-    struct urb *urb = user_data;
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-    urb->actual_length = bytes_transferred;
-    urb->hcpriv = NULL;
+	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
+	struct urb *urb = user_data;
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	urb->actual_length = bytes_transferred;
+	urb->hcpriv = NULL;
 
 	if (!list_empty(&urb->urb_list)) {
 		/*
@@ -141,598 +141,598 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 		INIT_LIST_HEAD(&urb->urb_list);
 	}
 
-    /* For Isochronous transactions we need to update the URB packet status
-        list from data in our private copy */
-    if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
-        int i;
-        /* The pointer to the private list is stored in the setup_packet field */
-        cvmx_usb_iso_packet_t *iso_packet = (cvmx_usb_iso_packet_t *)urb->setup_packet;
-        /* Recalculate the transfer size by adding up each packet */
-        urb->actual_length = 0;
-        for (i=0; i<urb->number_of_packets; i++) {
-            if (iso_packet[i].status == CVMX_USB_COMPLETE_SUCCESS) {
-                urb->iso_frame_desc[i].status = 0;
-                urb->iso_frame_desc[i].actual_length = iso_packet[i].length;
-                urb->actual_length += urb->iso_frame_desc[i].actual_length;
-            } else {
-                DEBUG_ERROR("%s: ISOCHRONOUS packet=%d of %d status=%d pipe=%d submit=%d size=%d\n",
-                            __FUNCTION__, i, urb->number_of_packets,
-                            iso_packet[i].status, pipe_handle,
-                            submit_handle, iso_packet[i].length);
-                urb->iso_frame_desc[i].status = -EREMOTEIO;
-            }
-        }
-        /* Free the private list now that we don't need it anymore */
-        kfree(iso_packet);
-        urb->setup_packet = NULL;
-    }
-
-    switch (status) {
-        case CVMX_USB_COMPLETE_SUCCESS:
-            urb->status = 0;
-            break;
-        case CVMX_USB_COMPLETE_CANCEL:
-            if (urb->status == 0)
-                urb->status = -ENOENT;
-            break;
-        case CVMX_USB_COMPLETE_STALL:
-            DEBUG_ERROR("%s: status=stall pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
-            urb->status = -EPIPE;
-            break;
-        case CVMX_USB_COMPLETE_BABBLEERR:
-            DEBUG_ERROR("%s: status=babble pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
-            urb->status = -EPIPE;
-            break;
-        case CVMX_USB_COMPLETE_SHORT:
-            DEBUG_ERROR("%s: status=short pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
-            urb->status = -EREMOTEIO;
-            break;
-        case CVMX_USB_COMPLETE_ERROR:
-        case CVMX_USB_COMPLETE_XACTERR:
-        case CVMX_USB_COMPLETE_DATATGLERR:
-        case CVMX_USB_COMPLETE_FRAMEERR:
-            DEBUG_ERROR("%s: status=%d pipe=%d submit=%d size=%d\n", __FUNCTION__, status, pipe_handle, submit_handle, bytes_transferred);
-            urb->status = -EPROTO;
-            break;
-    }
-    spin_unlock(&priv->lock);
-    usb_hcd_giveback_urb(octeon_to_hcd(priv), urb, urb->status);
-    spin_lock(&priv->lock);
+	/* For Isochronous transactions we need to update the URB packet status
+	   list from data in our private copy */
+	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
+		int i;
+		/* The pointer to the private list is stored in the setup_packet field */
+		cvmx_usb_iso_packet_t *iso_packet = (cvmx_usb_iso_packet_t *) urb->setup_packet;
+		/* Recalculate the transfer size by adding up each packet */
+		urb->actual_length = 0;
+		for (i = 0; i < urb->number_of_packets; i++) {
+			if (iso_packet[i].status == CVMX_USB_COMPLETE_SUCCESS) {
+				urb->iso_frame_desc[i].status = 0;
+				urb->iso_frame_desc[i].actual_length = iso_packet[i].length;
+				urb->actual_length += urb->iso_frame_desc[i].actual_length;
+			} else {
+				DEBUG_ERROR("%s: ISOCHRONOUS packet=%d of %d status=%d pipe=%d submit=%d size=%d\n",
+				     __FUNCTION__, i, urb->number_of_packets,
+				     iso_packet[i].status, pipe_handle,
+				     submit_handle, iso_packet[i].length);
+				urb->iso_frame_desc[i].status = -EREMOTEIO;
+			}
+		}
+		/* Free the private list now that we don't need it anymore */
+		kfree(iso_packet);
+		urb->setup_packet = NULL;
+	}
+
+	switch (status) {
+	case CVMX_USB_COMPLETE_SUCCESS:
+		urb->status = 0;
+		break;
+	case CVMX_USB_COMPLETE_CANCEL:
+		if (urb->status == 0)
+			urb->status = -ENOENT;
+		break;
+	case CVMX_USB_COMPLETE_STALL:
+		DEBUG_ERROR("%s: status=stall pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EPIPE;
+		break;
+	case CVMX_USB_COMPLETE_BABBLEERR:
+		DEBUG_ERROR("%s: status=babble pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EPIPE;
+		break;
+	case CVMX_USB_COMPLETE_SHORT:
+		DEBUG_ERROR("%s: status=short pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EREMOTEIO;
+		break;
+	case CVMX_USB_COMPLETE_ERROR:
+	case CVMX_USB_COMPLETE_XACTERR:
+	case CVMX_USB_COMPLETE_DATATGLERR:
+	case CVMX_USB_COMPLETE_FRAMEERR:
+		DEBUG_ERROR("%s: status=%d pipe=%d submit=%d size=%d\n", __FUNCTION__, status, pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EPROTO;
+		break;
+	}
+	spin_unlock(&priv->lock);
+	usb_hcd_giveback_urb(octeon_to_hcd(priv), urb, urb->status);
+	spin_lock(&priv->lock);
 }
 
 static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
-                                  struct urb *urb,
-                                  gfp_t mem_flags)
+				  struct urb *urb,
+				  gfp_t mem_flags)
 {
-    struct octeon_hcd *priv = hcd_to_octeon(hcd);
-    int submit_handle = -1;
-    int pipe_handle;
-    unsigned long flags;
-    cvmx_usb_iso_packet_t *iso_packet;
-    struct usb_host_endpoint *ep = urb->ep;
-
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-
-    urb->status = 0;
-    INIT_LIST_HEAD(&urb->urb_list); /* not enqueued on dequeue_list */
-    spin_lock_irqsave(&priv->lock, flags);
-
-    if (!ep->hcpriv) {
-        cvmx_usb_transfer_t transfer_type;
-        cvmx_usb_speed_t speed;
-        int split_device = 0;
-        int split_port = 0;
-        switch (usb_pipetype(urb->pipe)) {
-            case PIPE_ISOCHRONOUS:
-                transfer_type = CVMX_USB_TRANSFER_ISOCHRONOUS;
-                break;
-            case PIPE_INTERRUPT:
-                transfer_type = CVMX_USB_TRANSFER_INTERRUPT;
-                break;
-            case PIPE_CONTROL:
-                transfer_type = CVMX_USB_TRANSFER_CONTROL;
-                break;
-            default:
-                transfer_type = CVMX_USB_TRANSFER_BULK;
-                break;
-        }
-        switch (urb->dev->speed) {
-            case USB_SPEED_LOW:
-                speed = CVMX_USB_SPEED_LOW;
-                break;
-            case USB_SPEED_FULL:
-                speed = CVMX_USB_SPEED_FULL;
-                break;
-            default:
-                speed = CVMX_USB_SPEED_HIGH;
-                break;
-        }
-        /* For slow devices on high speed ports we need to find the hub that
-            does the speed translation so we know where to send the split
-            transactions */
-        if (speed != CVMX_USB_SPEED_HIGH) {
-            /* Start at this device and work our way up the usb tree */
-            struct usb_device *dev = urb->dev;
-            while (dev->parent) {
-                /* If our parent is high speed then he'll receive the splits */
-                if (dev->parent->speed == USB_SPEED_HIGH) {
-                    split_device = dev->parent->devnum;
-                    split_port = dev->portnum;
-                    break;
-                }
-                /* Move up the tree one level. If we make it all the way up the
-                    tree, then the port must not be in high speed mode and we
-                    don't need a split */
-                dev = dev->parent;
-            }
-        }
-        pipe_handle = cvmx_usb_open_pipe(&priv->usb,
-                                         0,
-                                         usb_pipedevice(urb->pipe),
-                                         usb_pipeendpoint(urb->pipe),
-                                         speed,
-                                         le16_to_cpu(ep->desc.wMaxPacketSize) & 0x7ff,
-                                         transfer_type,
-                                         usb_pipein(urb->pipe) ? CVMX_USB_DIRECTION_IN : CVMX_USB_DIRECTION_OUT,
-                                         urb->interval,
-                                         (le16_to_cpu(ep->desc.wMaxPacketSize)>>11) & 0x3,
-                                         split_device,
-                                         split_port);
-        if (pipe_handle < 0) {
-            spin_unlock_irqrestore(&priv->lock, flags);
-            DEBUG_ERROR("OcteonUSB: %s failed to create pipe\n", __FUNCTION__);
-            return -ENOMEM;
-        }
-        ep->hcpriv = (void*)(0x10000L + pipe_handle);
-    }
-    else
-        pipe_handle = 0xffff & (long)ep->hcpriv;
-
-    switch (usb_pipetype(urb->pipe)) {
-        case PIPE_ISOCHRONOUS:
-            DEBUG_SUBMIT("OcteonUSB: %s submit isochronous to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
-            /* Allocate a structure to use for our private list of isochronous
-                packets */
-            iso_packet = kmalloc(urb->number_of_packets * sizeof(cvmx_usb_iso_packet_t), GFP_ATOMIC);
-            if (iso_packet) {
-                int i;
-                /* Fill the list with the data from the URB */
-                for (i=0; i<urb->number_of_packets; i++) {
-                    iso_packet[i].offset = urb->iso_frame_desc[i].offset;
-                    iso_packet[i].length = urb->iso_frame_desc[i].length;
-                    iso_packet[i].status = CVMX_USB_COMPLETE_ERROR;
-                }
-                /* Store a pointer to the list in uthe URB setup_pakcet field.
-                    We know this currently isn't being used and this saves us
-                    a bunch of logic */
-                urb->setup_packet = (char*)iso_packet;
-                submit_handle = cvmx_usb_submit_isochronous(&priv->usb, pipe_handle,
-                                                            urb->start_frame,
-                                                            0 /* flags */,
-                                                            urb->number_of_packets,
-                                                            iso_packet,
-                                                            urb->transfer_dma,
-                                                            urb->transfer_buffer_length,
-                                                            octeon_usb_urb_complete_callback,
-                                                            urb);
-                /* If submit failed we need to free our private packet list */
-                if (submit_handle < 0) {
-                    urb->setup_packet = NULL;
-                    kfree(iso_packet);
-                }
-            }
-            break;
-        case PIPE_INTERRUPT:
-            DEBUG_SUBMIT("OcteonUSB: %s submit interrupt to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
-            submit_handle = cvmx_usb_submit_interrupt(&priv->usb, pipe_handle,
-                                                      urb->transfer_dma,
-                                                      urb->transfer_buffer_length,
-                                                      octeon_usb_urb_complete_callback,
-                                                      urb);
-            break;
-        case PIPE_CONTROL:
-            DEBUG_SUBMIT("OcteonUSB: %s submit control to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
-            submit_handle = cvmx_usb_submit_control(&priv->usb, pipe_handle,
-                                                    urb->setup_dma,
-                                                    urb->transfer_dma,
-                                                    urb->transfer_buffer_length,
-                                                    octeon_usb_urb_complete_callback,
-                                                    urb);
-            break;
-        case PIPE_BULK:
-            DEBUG_SUBMIT("OcteonUSB: %s submit bulk to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
-            submit_handle = cvmx_usb_submit_bulk(&priv->usb, pipe_handle,
-                                                 urb->transfer_dma,
-                                                 urb->transfer_buffer_length,
-                                                 octeon_usb_urb_complete_callback,
-                                                 urb);
-            break;
-    }
-    if (submit_handle < 0) {
-        spin_unlock_irqrestore(&priv->lock, flags);
-        DEBUG_ERROR("OcteonUSB: %s failed to submit\n", __FUNCTION__);
-        return -ENOMEM;
-    }
-    urb->hcpriv = (void*)(long)(((submit_handle & 0xffff) << 16) | pipe_handle);
-    spin_unlock_irqrestore(&priv->lock, flags);
-    return 0;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	int submit_handle = -1;
+	int pipe_handle;
+	unsigned long flags;
+	cvmx_usb_iso_packet_t *iso_packet;
+	struct usb_host_endpoint *ep = urb->ep;
+
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
+	urb->status = 0;
+	INIT_LIST_HEAD(&urb->urb_list);	/* not enqueued on dequeue_list */
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (!ep->hcpriv) {
+		cvmx_usb_transfer_t transfer_type;
+		cvmx_usb_speed_t speed;
+		int split_device = 0;
+		int split_port = 0;
+		switch (usb_pipetype(urb->pipe)) {
+		case PIPE_ISOCHRONOUS:
+			transfer_type = CVMX_USB_TRANSFER_ISOCHRONOUS;
+			break;
+		case PIPE_INTERRUPT:
+			transfer_type = CVMX_USB_TRANSFER_INTERRUPT;
+			break;
+		case PIPE_CONTROL:
+			transfer_type = CVMX_USB_TRANSFER_CONTROL;
+			break;
+		default:
+			transfer_type = CVMX_USB_TRANSFER_BULK;
+			break;
+		}
+		switch (urb->dev->speed) {
+		case USB_SPEED_LOW:
+			speed = CVMX_USB_SPEED_LOW;
+			break;
+		case USB_SPEED_FULL:
+			speed = CVMX_USB_SPEED_FULL;
+			break;
+		default:
+			speed = CVMX_USB_SPEED_HIGH;
+			break;
+		}
+		/* For slow devices on high speed ports we need to find the hub that
+		   does the speed translation so we know where to send the split
+		   transactions */
+		if (speed != CVMX_USB_SPEED_HIGH) {
+			/* Start at this device and work our way up the usb tree */
+			struct usb_device *dev = urb->dev;
+			while (dev->parent) {
+				/* If our parent is high speed then he'll receive the splits */
+				if (dev->parent->speed == USB_SPEED_HIGH) {
+					split_device = dev->parent->devnum;
+					split_port = dev->portnum;
+					break;
+				}
+				/* Move up the tree one level. If we make it all the way up the
+				   tree, then the port must not be in high speed mode and we
+				   don't need a split */
+				dev = dev->parent;
+			}
+		}
+		pipe_handle = cvmx_usb_open_pipe(&priv->usb,
+						 0,
+						 usb_pipedevice(urb->pipe),
+						 usb_pipeendpoint(urb->pipe),
+						 speed,
+						 le16_to_cpu(ep->desc.wMaxPacketSize) & 0x7ff,
+						 transfer_type,
+						 usb_pipein(urb->pipe) ? CVMX_USB_DIRECTION_IN : CVMX_USB_DIRECTION_OUT,
+						 urb->interval,
+						 (le16_to_cpu(ep->desc.wMaxPacketSize) >> 11) & 0x3,
+						 split_device,
+						 split_port);
+		if (pipe_handle < 0) {
+			spin_unlock_irqrestore(&priv->lock, flags);
+			DEBUG_ERROR("OcteonUSB: %s failed to create pipe\n", __FUNCTION__);
+			return -ENOMEM;
+		}
+		ep->hcpriv = (void *)(0x10000L + pipe_handle);
+	}
+	else
+		pipe_handle = 0xffff & (long)ep->hcpriv;
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_ISOCHRONOUS:
+		DEBUG_SUBMIT("OcteonUSB: %s submit isochronous to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		/* Allocate a structure to use for our private list of isochronous
+		   packets */
+		iso_packet = kmalloc(urb->number_of_packets * sizeof(cvmx_usb_iso_packet_t), GFP_ATOMIC);
+		if (iso_packet) {
+			int i;
+			/* Fill the list with the data from the URB */
+			for (i = 0; i < urb->number_of_packets; i++) {
+				iso_packet[i].offset = urb->iso_frame_desc[i].offset;
+				iso_packet[i].length = urb->iso_frame_desc[i].length;
+				iso_packet[i].status = CVMX_USB_COMPLETE_ERROR;
+			}
+			/* Store a pointer to the list in uthe URB setup_pakcet field.
+			   We know this currently isn't being used and this saves us
+			   a bunch of logic */
+			urb->setup_packet = (char *)iso_packet;
+			submit_handle = cvmx_usb_submit_isochronous(&priv->usb, pipe_handle,
+							urb->start_frame,
+							0 /* flags */ ,
+							urb->number_of_packets,
+							iso_packet,
+							urb->transfer_dma,
+							urb->transfer_buffer_length,
+							octeon_usb_urb_complete_callback,
+							urb);
+			/* If submit failed we need to free our private packet list */
+			if (submit_handle < 0) {
+				urb->setup_packet = NULL;
+				kfree(iso_packet);
+			}
+		}
+		break;
+	case PIPE_INTERRUPT:
+		DEBUG_SUBMIT("OcteonUSB: %s submit interrupt to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		submit_handle = cvmx_usb_submit_interrupt(&priv->usb, pipe_handle,
+					      urb->transfer_dma,
+					      urb->transfer_buffer_length,
+					      octeon_usb_urb_complete_callback,
+					      urb);
+		break;
+	case PIPE_CONTROL:
+		DEBUG_SUBMIT("OcteonUSB: %s submit control to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		submit_handle = cvmx_usb_submit_control(&priv->usb, pipe_handle,
+					    urb->setup_dma,
+					    urb->transfer_dma,
+					    urb->transfer_buffer_length,
+					    octeon_usb_urb_complete_callback,
+					    urb);
+		break;
+	case PIPE_BULK:
+		DEBUG_SUBMIT("OcteonUSB: %s submit bulk to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		submit_handle = cvmx_usb_submit_bulk(&priv->usb, pipe_handle,
+					 urb->transfer_dma,
+					 urb->transfer_buffer_length,
+					 octeon_usb_urb_complete_callback,
+					 urb);
+		break;
+	}
+	if (submit_handle < 0) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		DEBUG_ERROR("OcteonUSB: %s failed to submit\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+	urb->hcpriv = (void *)(long)(((submit_handle & 0xffff) << 16) | pipe_handle);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return 0;
 }
 
 static void octeon_usb_urb_dequeue_work(unsigned long arg)
 {
-    unsigned long flags;
-    struct octeon_hcd *priv = (struct octeon_hcd *)arg;
-
-    spin_lock_irqsave(&priv->lock, flags);
-
-    while (!list_empty(&priv->dequeue_list)) {
-        int pipe_handle;
-        int submit_handle;
-        struct urb *urb = container_of(priv->dequeue_list.next, struct urb, urb_list);
-        list_del(&urb->urb_list);
-        /* not enqueued on dequeue_list */
-        INIT_LIST_HEAD(&urb->urb_list);
-        pipe_handle = 0xffff & (long)urb->hcpriv;
-        submit_handle = ((long)urb->hcpriv) >> 16;
-        cvmx_usb_cancel(&priv->usb, pipe_handle, submit_handle);
-    }
-
-    spin_unlock_irqrestore(&priv->lock, flags);
+	unsigned long flags;
+	struct octeon_hcd *priv = (struct octeon_hcd *)arg;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	while (!list_empty(&priv->dequeue_list)) {
+		int pipe_handle;
+		int submit_handle;
+		struct urb *urb = container_of(priv->dequeue_list.next, struct urb, urb_list);
+		list_del(&urb->urb_list);
+		/* not enqueued on dequeue_list */
+		INIT_LIST_HEAD(&urb->urb_list);
+		pipe_handle = 0xffff & (long)urb->hcpriv;
+		submit_handle = ((long)urb->hcpriv) >> 16;
+		cvmx_usb_cancel(&priv->usb, pipe_handle, submit_handle);
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
 }
 
 static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
-    struct octeon_hcd *priv = hcd_to_octeon(hcd);
-    unsigned long flags;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	unsigned long flags;
 
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
 
-    if (!urb->dev)
-        return -EINVAL;
+	if (!urb->dev)
+		return -EINVAL;
 
-    spin_lock_irqsave(&priv->lock, flags);
+	spin_lock_irqsave(&priv->lock, flags);
 
-    urb->status = status;
-    list_add_tail(&urb->urb_list, &priv->dequeue_list);
+	urb->status = status;
+	list_add_tail(&urb->urb_list, &priv->dequeue_list);
 
-    spin_unlock_irqrestore(&priv->lock, flags);
+	spin_unlock_irqrestore(&priv->lock, flags);
 
-    tasklet_schedule(&priv->dequeue_tasklet);
+	tasklet_schedule(&priv->dequeue_tasklet);
 
-    return 0;
+	return 0;
 }
 
 static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 {
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-    if (ep->hcpriv) {
-        struct octeon_hcd *priv = hcd_to_octeon(hcd);
-        int pipe_handle = 0xffff & (long)ep->hcpriv;
-        unsigned long flags;
-        spin_lock_irqsave(&priv->lock, flags);
-        cvmx_usb_cancel_all(&priv->usb, pipe_handle);
-        if (cvmx_usb_close_pipe(&priv->usb, pipe_handle))
-            DEBUG_ERROR("OcteonUSB: Closing pipe %d failed\n", pipe_handle);
-        spin_unlock_irqrestore(&priv->lock, flags);
-        ep->hcpriv = NULL;
-    }
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	if (ep->hcpriv) {
+		struct octeon_hcd *priv = hcd_to_octeon(hcd);
+		int pipe_handle = 0xffff & (long)ep->hcpriv;
+		unsigned long flags;
+		spin_lock_irqsave(&priv->lock, flags);
+		cvmx_usb_cancel_all(&priv->usb, pipe_handle);
+		if (cvmx_usb_close_pipe(&priv->usb, pipe_handle))
+			DEBUG_ERROR("OcteonUSB: Closing pipe %d failed\n", pipe_handle);
+		spin_unlock_irqrestore(&priv->lock, flags);
+		ep->hcpriv = NULL;
+	}
 }
 
 static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
 {
-    struct octeon_hcd *priv = hcd_to_octeon(hcd);
-    cvmx_usb_port_status_t port_status;
-    unsigned long flags;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	cvmx_usb_port_status_t port_status;
+	unsigned long flags;
 
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
 
-    spin_lock_irqsave(&priv->lock, flags);
-    port_status = cvmx_usb_get_status(&priv->usb);
-    spin_unlock_irqrestore(&priv->lock, flags);
-    buf[0] = 0;
-    buf[0] = port_status.connect_change << 1;
+	spin_lock_irqsave(&priv->lock, flags);
+	port_status = cvmx_usb_get_status(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	buf[0] = 0;
+	buf[0] = port_status.connect_change << 1;
 
-    return(buf[0] != 0);
+	return (buf[0] != 0);
 }
 
 static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex, char *buf, u16 wLength)
 {
-    struct octeon_hcd *priv = hcd_to_octeon(hcd);
-    cvmx_usb_port_status_t usb_port_status;
-    int port_status;
-    struct usb_hub_descriptor *desc;
-    unsigned long flags;
-
-    switch (typeReq) {
-        case ClearHubFeature:
-            DEBUG_ROOT_HUB("OcteonUSB: ClearHubFeature\n");
-            switch (wValue) {
-                case C_HUB_LOCAL_POWER:
-                case C_HUB_OVER_CURRENT:
-                    /* Nothing required here */
-                    break;
-                default:
-                    return -EINVAL;
-            }
-            break;
-        case ClearPortFeature:
-            DEBUG_ROOT_HUB("OcteonUSB: ClearPortFeature");
-            if (wIndex != 1) {
-                DEBUG_ROOT_HUB(" INVALID\n");
-                return -EINVAL;
-            }
-
-            switch (wValue) {
-                case USB_PORT_FEAT_ENABLE:
-                    DEBUG_ROOT_HUB(" ENABLE");
-                    spin_lock_irqsave(&priv->lock, flags);
-                    cvmx_usb_disable(&priv->usb);
-                    spin_unlock_irqrestore(&priv->lock, flags);
-                    break;
-                case USB_PORT_FEAT_SUSPEND:
-                    DEBUG_ROOT_HUB(" SUSPEND");
-                    /* Not supported on Octeon */
-                    break;
-                case USB_PORT_FEAT_POWER:
-                    DEBUG_ROOT_HUB(" POWER");
-                    /* Not supported on Octeon */
-                    break;
-                case USB_PORT_FEAT_INDICATOR:
-                    DEBUG_ROOT_HUB(" INDICATOR");
-                    /* Port inidicator not supported */
-                    break;
-                case USB_PORT_FEAT_C_CONNECTION:
-                    DEBUG_ROOT_HUB(" C_CONNECTION");
-                    /* Clears drivers internal connect status change flag */
-                    spin_lock_irqsave(&priv->lock, flags);
-                    cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
-                    spin_unlock_irqrestore(&priv->lock, flags);
-                    break;
-                case USB_PORT_FEAT_C_RESET:
-                    DEBUG_ROOT_HUB(" C_RESET");
-                    /* Clears the driver's internal Port Reset Change flag */
-                    spin_lock_irqsave(&priv->lock, flags);
-                    cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
-                    spin_unlock_irqrestore(&priv->lock, flags);
-                    break;
-                case USB_PORT_FEAT_C_ENABLE:
-                    DEBUG_ROOT_HUB(" C_ENABLE");
-                    /* Clears the driver's internal Port Enable/Disable Change flag */
-                    spin_lock_irqsave(&priv->lock, flags);
-                    cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
-                    spin_unlock_irqrestore(&priv->lock, flags);
-                    break;
-                case USB_PORT_FEAT_C_SUSPEND:
-                    DEBUG_ROOT_HUB(" C_SUSPEND");
-                    /* Clears the driver's internal Port Suspend Change flag,
-                        which is set when resume signaling on the host port is
-                        complete */
-                    break;
-                case USB_PORT_FEAT_C_OVER_CURRENT:
-                    DEBUG_ROOT_HUB(" C_OVER_CURRENT");
-                    /* Clears the driver's overcurrent Change flag */
-                    spin_lock_irqsave(&priv->lock, flags);
-                    cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
-                    spin_unlock_irqrestore(&priv->lock, flags);
-                    break;
-                default:
-                    DEBUG_ROOT_HUB(" UNKNOWN\n");
-                    return -EINVAL;
-            }
-            DEBUG_ROOT_HUB("\n");
-            break;
-        case GetHubDescriptor:
-            DEBUG_ROOT_HUB("OcteonUSB: GetHubDescriptor\n");
-            desc = (struct usb_hub_descriptor *)buf;
-            desc->bDescLength = 9;
-            desc->bDescriptorType = 0x29;
-            desc->bNbrPorts = 1;
-            desc->wHubCharacteristics = 0x08;
-            desc->bPwrOn2PwrGood = 1;
-            desc->bHubContrCurrent = 0;
-            desc->u.hs.DeviceRemovable[0] = 0;
-            desc->u.hs.DeviceRemovable[1] = 0xff;
-            break;
-        case GetHubStatus:
-            DEBUG_ROOT_HUB("OcteonUSB: GetHubStatus\n");
-            *(__le32 *)buf = 0;
-            break;
-        case GetPortStatus:
-            DEBUG_ROOT_HUB("OcteonUSB: GetPortStatus");
-            if (wIndex != 1) {
-                DEBUG_ROOT_HUB(" INVALID\n");
-                return -EINVAL;
-            }
-
-            spin_lock_irqsave(&priv->lock, flags);
-            usb_port_status = cvmx_usb_get_status(&priv->usb);
-            spin_unlock_irqrestore(&priv->lock, flags);
-            port_status = 0;
-
-            if (usb_port_status.connect_change) {
-                port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
-                DEBUG_ROOT_HUB(" C_CONNECTION");
-            }
-
-            if (usb_port_status.port_enabled) {
-                port_status |= (1 << USB_PORT_FEAT_C_ENABLE);
-                DEBUG_ROOT_HUB(" C_ENABLE");
-            }
-
-            if (usb_port_status.connected) {
-                port_status |= (1 << USB_PORT_FEAT_CONNECTION);
-                DEBUG_ROOT_HUB(" CONNECTION");
-            }
-
-            if (usb_port_status.port_enabled) {
-                port_status |= (1 << USB_PORT_FEAT_ENABLE);
-                DEBUG_ROOT_HUB(" ENABLE");
-            }
-
-            if (usb_port_status.port_over_current) {
-                port_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);
-                DEBUG_ROOT_HUB(" OVER_CURRENT");
-            }
-
-            if (usb_port_status.port_powered) {
-                port_status |= (1 << USB_PORT_FEAT_POWER);
-                DEBUG_ROOT_HUB(" POWER");
-            }
-
-            if (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH) {
-		port_status |= USB_PORT_STAT_HIGH_SPEED;
-                DEBUG_ROOT_HUB(" HIGHSPEED");
-            } else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW) {
-                port_status |= (1 << USB_PORT_FEAT_LOWSPEED);
-                DEBUG_ROOT_HUB(" LOWSPEED");
-            }
-
-            *((__le32 *)buf) = cpu_to_le32(port_status);
-            DEBUG_ROOT_HUB("\n");
-            break;
-        case SetHubFeature:
-            DEBUG_ROOT_HUB("OcteonUSB: SetHubFeature\n");
-            /* No HUB features supported */
-            break;
-        case SetPortFeature:
-            DEBUG_ROOT_HUB("OcteonUSB: SetPortFeature");
-            if (wIndex != 1) {
-                DEBUG_ROOT_HUB(" INVALID\n");
-                return -EINVAL;
-            }
-
-            switch (wValue) {
-                case USB_PORT_FEAT_SUSPEND:
-                    DEBUG_ROOT_HUB(" SUSPEND\n");
-                    return -EINVAL;
-                case USB_PORT_FEAT_POWER:
-                    DEBUG_ROOT_HUB(" POWER\n");
-                    return -EINVAL;
-                case USB_PORT_FEAT_RESET:
-                    DEBUG_ROOT_HUB(" RESET\n");
-                    spin_lock_irqsave(&priv->lock, flags);
-                    cvmx_usb_disable(&priv->usb);
-                    if (cvmx_usb_enable(&priv->usb))
-                        DEBUG_ERROR("Failed to enable the port\n");
-                    spin_unlock_irqrestore(&priv->lock, flags);
-                    return 0;
-                case USB_PORT_FEAT_INDICATOR:
-                    DEBUG_ROOT_HUB(" INDICATOR\n");
-                    /* Not supported */
-                    break;
-                default:
-                    DEBUG_ROOT_HUB(" UNKNOWN\n");
-                    return -EINVAL;
-            }
-            break;
-        default:
-            DEBUG_ROOT_HUB("OcteonUSB: Unknown root hub request\n");
-            return -EINVAL;
-    }
-    return 0;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	cvmx_usb_port_status_t usb_port_status;
+	int port_status;
+	struct usb_hub_descriptor *desc;
+	unsigned long flags;
+
+	switch (typeReq) {
+	case ClearHubFeature:
+		DEBUG_ROOT_HUB("OcteonUSB: ClearHubFeature\n");
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* Nothing required here */
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case ClearPortFeature:
+		DEBUG_ROOT_HUB("OcteonUSB: ClearPortFeature");
+		if (wIndex != 1) {
+			DEBUG_ROOT_HUB(" INVALID\n");
+			return -EINVAL;
+		}
+
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			DEBUG_ROOT_HUB(" ENABLE");
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_disable(&priv->usb);
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			DEBUG_ROOT_HUB(" SUSPEND");
+			/* Not supported on Octeon */
+			break;
+		case USB_PORT_FEAT_POWER:
+			DEBUG_ROOT_HUB(" POWER");
+			/* Not supported on Octeon */
+			break;
+		case USB_PORT_FEAT_INDICATOR:
+			DEBUG_ROOT_HUB(" INDICATOR");
+			/* Port inidicator not supported */
+			break;
+		case USB_PORT_FEAT_C_CONNECTION:
+			DEBUG_ROOT_HUB(" C_CONNECTION");
+			/* Clears drivers internal connect status change flag */
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		case USB_PORT_FEAT_C_RESET:
+			DEBUG_ROOT_HUB(" C_RESET");
+			/* Clears the driver's internal Port Reset Change flag */
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+			DEBUG_ROOT_HUB(" C_ENABLE");
+			/* Clears the driver's internal Port Enable/Disable Change flag */
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		case USB_PORT_FEAT_C_SUSPEND:
+			DEBUG_ROOT_HUB(" C_SUSPEND");
+			/* Clears the driver's internal Port Suspend Change flag,
+			   which is set when resume signaling on the host port is
+			   complete */
+			break;
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+			DEBUG_ROOT_HUB(" C_OVER_CURRENT");
+			/* Clears the driver's overcurrent Change flag */
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		default:
+			DEBUG_ROOT_HUB(" UNKNOWN\n");
+			return -EINVAL;
+		}
+		DEBUG_ROOT_HUB("\n");
+		break;
+	case GetHubDescriptor:
+		DEBUG_ROOT_HUB("OcteonUSB: GetHubDescriptor\n");
+		desc = (struct usb_hub_descriptor *)buf;
+		desc->bDescLength = 9;
+		desc->bDescriptorType = 0x29;
+		desc->bNbrPorts = 1;
+		desc->wHubCharacteristics = 0x08;
+		desc->bPwrOn2PwrGood = 1;
+		desc->bHubContrCurrent = 0;
+		desc->u.hs.DeviceRemovable[0] = 0;
+		desc->u.hs.DeviceRemovable[1] = 0xff;
+		break;
+	case GetHubStatus:
+		DEBUG_ROOT_HUB("OcteonUSB: GetHubStatus\n");
+		*(__le32 *) buf = 0;
+		break;
+	case GetPortStatus:
+		DEBUG_ROOT_HUB("OcteonUSB: GetPortStatus");
+		if (wIndex != 1) {
+			DEBUG_ROOT_HUB(" INVALID\n");
+			return -EINVAL;
+		}
+
+		spin_lock_irqsave(&priv->lock, flags);
+		usb_port_status = cvmx_usb_get_status(&priv->usb);
+		spin_unlock_irqrestore(&priv->lock, flags);
+		port_status = 0;
+
+		if (usb_port_status.connect_change) {
+			port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
+			DEBUG_ROOT_HUB(" C_CONNECTION");
+		}
+
+		if (usb_port_status.port_enabled) {
+			port_status |= (1 << USB_PORT_FEAT_C_ENABLE);
+			DEBUG_ROOT_HUB(" C_ENABLE");
+		}
+
+		if (usb_port_status.connected) {
+			port_status |= (1 << USB_PORT_FEAT_CONNECTION);
+			DEBUG_ROOT_HUB(" CONNECTION");
+		}
+
+		if (usb_port_status.port_enabled) {
+			port_status |= (1 << USB_PORT_FEAT_ENABLE);
+			DEBUG_ROOT_HUB(" ENABLE");
+		}
+
+		if (usb_port_status.port_over_current) {
+			port_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);
+			DEBUG_ROOT_HUB(" OVER_CURRENT");
+		}
+
+		if (usb_port_status.port_powered) {
+			port_status |= (1 << USB_PORT_FEAT_POWER);
+			DEBUG_ROOT_HUB(" POWER");
+		}
+
+		if (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH) {
+			port_status |= USB_PORT_STAT_HIGH_SPEED;
+			DEBUG_ROOT_HUB(" HIGHSPEED");
+		} else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW) {
+			port_status |= (1 << USB_PORT_FEAT_LOWSPEED);
+			DEBUG_ROOT_HUB(" LOWSPEED");
+		}
+
+		*((__le32 *) buf) = cpu_to_le32(port_status);
+		DEBUG_ROOT_HUB("\n");
+		break;
+	case SetHubFeature:
+		DEBUG_ROOT_HUB("OcteonUSB: SetHubFeature\n");
+		/* No HUB features supported */
+		break;
+	case SetPortFeature:
+		DEBUG_ROOT_HUB("OcteonUSB: SetPortFeature");
+		if (wIndex != 1) {
+			DEBUG_ROOT_HUB(" INVALID\n");
+			return -EINVAL;
+		}
+
+		switch (wValue) {
+		case USB_PORT_FEAT_SUSPEND:
+			DEBUG_ROOT_HUB(" SUSPEND\n");
+			return -EINVAL;
+		case USB_PORT_FEAT_POWER:
+			DEBUG_ROOT_HUB(" POWER\n");
+			return -EINVAL;
+		case USB_PORT_FEAT_RESET:
+			DEBUG_ROOT_HUB(" RESET\n");
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_disable(&priv->usb);
+			if (cvmx_usb_enable(&priv->usb))
+				DEBUG_ERROR("Failed to enable the port\n");
+			spin_unlock_irqrestore(&priv->lock, flags);
+			return 0;
+		case USB_PORT_FEAT_INDICATOR:
+			DEBUG_ROOT_HUB(" INDICATOR\n");
+			/* Not supported */
+			break;
+		default:
+			DEBUG_ROOT_HUB(" UNKNOWN\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		DEBUG_ROOT_HUB("OcteonUSB: Unknown root hub request\n");
+		return -EINVAL;
+	}
+	return 0;
 }
 
 
 static const struct hc_driver octeon_hc_driver = {
-    .description =      "Octeon USB",
-    .product_desc =     "Octeon Host Controller",
-    .hcd_priv_size =    sizeof(struct octeon_hcd),
-    .irq =              octeon_usb_irq,
-    .flags =            HCD_MEMORY | HCD_USB2,
-    .start =            octeon_usb_start,
-    .stop =             octeon_usb_stop,
-    .urb_enqueue =      octeon_usb_urb_enqueue,
-    .urb_dequeue =      octeon_usb_urb_dequeue,
-    .endpoint_disable = octeon_usb_endpoint_disable,
-    .get_frame_number = octeon_usb_get_frame_number,
-    .hub_status_data =  octeon_usb_hub_status_data,
-    .hub_control =      octeon_usb_hub_control,
+	.description		= "Octeon USB",
+	.product_desc		= "Octeon Host Controller",
+	.hcd_priv_size		= sizeof(struct octeon_hcd),
+	.irq			= octeon_usb_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+	.start			= octeon_usb_start,
+	.stop			= octeon_usb_stop,
+	.urb_enqueue		= octeon_usb_urb_enqueue,
+	.urb_dequeue		= octeon_usb_urb_dequeue,
+	.endpoint_disable	= octeon_usb_endpoint_disable,
+	.get_frame_number	= octeon_usb_get_frame_number,
+	.hub_status_data	= octeon_usb_hub_status_data,
+	.hub_control		= octeon_usb_hub_control,
 };
 
 
 static int octeon_usb_driver_probe(struct device *dev)
 {
-    int status;
-    int usb_num = to_platform_device(dev)->id;
-    int irq = platform_get_irq(to_platform_device(dev), 0);
-    struct octeon_hcd *priv;
-    struct usb_hcd *hcd;
-    unsigned long flags;
-
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-
-    /* Set the DMA mask to 64bits so we get buffers already translated for
-        DMA */
-    dev->coherent_dma_mask = ~0;
-    dev->dma_mask = &dev->coherent_dma_mask;
-
-    hcd = usb_create_hcd(&octeon_hc_driver, dev, dev_name(dev));
-    if (!hcd) {
-        DEBUG_FATAL("OcteonUSB: Failed to allocate memory for HCD\n");
-        return -1;
-    }
-    hcd->uses_new_polling = 1;
-    priv = (struct octeon_hcd *)hcd->hcd_priv;
-
-    spin_lock_init(&priv->lock);
-
-    tasklet_init(&priv->dequeue_tasklet, octeon_usb_urb_dequeue_work, (unsigned long)priv);
-    INIT_LIST_HEAD(&priv->dequeue_list);
-
-    //status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS | CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS);
-    status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO);
-    if (status) {
-        DEBUG_FATAL("OcteonUSB: USB initialization failed with %d\n", status);
-        kfree(hcd);
-        return -1;
-    }
-
-    /* This delay is needed for CN3010, but I don't know why... */
-    mdelay(10);
-
-    spin_lock_irqsave(&priv->lock, flags);
-    cvmx_usb_poll(&priv->usb);
-    spin_unlock_irqrestore(&priv->lock, flags);
-
-    status = usb_add_hcd(hcd, irq, IRQF_SHARED);
-    if (status) {
-        DEBUG_FATAL("OcteonUSB: USB add HCD failed with %d\n", status);
-        kfree(hcd);
-        return -1;
-    }
-
-    printk("OcteonUSB: Registered HCD for port %d on irq %d\n", usb_num, irq);
-
-    return 0;
+	int status;
+	int usb_num = to_platform_device(dev)->id;
+	int irq = platform_get_irq(to_platform_device(dev), 0);
+	struct octeon_hcd *priv;
+	struct usb_hcd *hcd;
+	unsigned long flags;
+
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
+	/* Set the DMA mask to 64bits so we get buffers already translated for
+	   DMA */
+	dev->coherent_dma_mask = ~0;
+	dev->dma_mask = &dev->coherent_dma_mask;
+
+	hcd = usb_create_hcd(&octeon_hc_driver, dev, dev_name(dev));
+	if (!hcd) {
+		DEBUG_FATAL("OcteonUSB: Failed to allocate memory for HCD\n");
+		return -1;
+	}
+	hcd->uses_new_polling = 1;
+	priv = (struct octeon_hcd *)hcd->hcd_priv;
+
+	spin_lock_init(&priv->lock);
+
+	tasklet_init(&priv->dequeue_tasklet, octeon_usb_urb_dequeue_work, (unsigned long)priv);
+	INIT_LIST_HEAD(&priv->dequeue_list);
+
+	//status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS | CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS);
+	status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO);
+	if (status) {
+		DEBUG_FATAL("OcteonUSB: USB initialization failed with %d\n", status);
+		kfree(hcd);
+		return -1;
+	}
+
+	/* This delay is needed for CN3010, but I don't know why... */
+	mdelay(10);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	cvmx_usb_poll(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	status = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (status) {
+		DEBUG_FATAL("OcteonUSB: USB add HCD failed with %d\n", status);
+		kfree(hcd);
+		return -1;
+	}
+
+	printk("OcteonUSB: Registered HCD for port %d on irq %d\n", usb_num, irq);
+
+	return 0;
 }
 
 static int octeon_usb_driver_remove(struct device *dev)
 {
-    int status;
-    struct usb_hcd *hcd = dev_get_drvdata(dev);
-    struct octeon_hcd *priv = hcd_to_octeon(hcd);
-    unsigned long flags;
+	int status;
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
+	unsigned long flags;
 
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
 
-    usb_remove_hcd(hcd);
-    tasklet_kill(&priv->dequeue_tasklet);
-    spin_lock_irqsave(&priv->lock, flags);
-    status = cvmx_usb_shutdown(&priv->usb);
-    spin_unlock_irqrestore(&priv->lock, flags);
-    if (status)
-        DEBUG_FATAL("OcteonUSB: USB shutdown failed with %d\n", status);
+	usb_remove_hcd(hcd);
+	tasklet_kill(&priv->dequeue_tasklet);
+	spin_lock_irqsave(&priv->lock, flags);
+	status = cvmx_usb_shutdown(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	if (status)
+		DEBUG_FATAL("OcteonUSB: USB shutdown failed with %d\n", status);
 
-    kfree(hcd);
+	kfree(hcd);
 
-    return 0;
+	return 0;
 }
 
 static struct device_driver octeon_usb_driver = {
-    .name       = "OcteonUSB",
-    .bus        = &platform_bus_type,
-    .probe      = octeon_usb_driver_probe,
-    .remove     = octeon_usb_driver_remove,
+	.name	= "OcteonUSB",
+	.bus	= &platform_bus_type,
+	.probe	= octeon_usb_driver_probe,
+	.remove	= octeon_usb_driver_remove,
 };
 
 
@@ -741,18 +741,18 @@ struct platform_device *pdev_glob[MAX_USB_PORTS];
 static int octeon_usb_registered;
 static int __init octeon_usb_module_init(void)
 {
-    int num_devices = cvmx_usb_get_num_ports();
-    int device;
+	int num_devices = cvmx_usb_get_num_ports();
+	int device;
 
-    if (usb_disabled() || num_devices == 0)
-	return -ENODEV;
+	if (usb_disabled() || num_devices == 0)
+		return -ENODEV;
 
-    if (driver_register(&octeon_usb_driver)) {
-        DEBUG_FATAL("OcteonUSB: Failed to register driver\n");
-        return -ENOMEM;
-    }
-    octeon_usb_registered = 1;
-    printk("OcteonUSB: Detected %d ports\n", num_devices);
+	if (driver_register(&octeon_usb_driver)) {
+		DEBUG_FATAL("OcteonUSB: Failed to register driver\n");
+		return -ENOMEM;
+	}
+	octeon_usb_registered = 1;
+	printk("OcteonUSB: Detected %d ports\n", num_devices);
 
 	/*
 	 * Only cn52XX and cn56XX have DWC_OTG USB hardware and the
@@ -774,36 +774,36 @@ static int __init octeon_usb_module_init(void)
 		cvmx_write_csr(CVMX_IOB_N2C_L2C_PRI_CNT, pri_cnt.u64);
 	}
 
-    for (device = 0; device < num_devices; device++) {
-        struct resource irq_resource;
-        struct platform_device *pdev;
-        memset(&irq_resource, 0, sizeof(irq_resource));
-        irq_resource.start = (device==0) ? OCTEON_IRQ_USB0 : OCTEON_IRQ_USB1;
-        irq_resource.end = irq_resource.start;
-        irq_resource.flags = IORESOURCE_IRQ;
-        pdev = platform_device_register_simple((char*)octeon_usb_driver.name, device, &irq_resource, 1);
-        if (IS_ERR(pdev)) {
-            DEBUG_FATAL("OcteonUSB: Failed to allocate platform device for USB%d\n", device);
-		driver_unregister(&octeon_usb_driver);
-		octeon_usb_registered = 0;
-            return PTR_ERR(pdev);
-        }
-        if (device < MAX_USB_PORTS)
-            pdev_glob[device] = pdev;
-
-    }
-    return 0;
+	for (device = 0; device < num_devices; device++) {
+		struct resource irq_resource;
+		struct platform_device *pdev;
+		memset(&irq_resource, 0, sizeof(irq_resource));
+		irq_resource.start = (device == 0) ? OCTEON_IRQ_USB0 : OCTEON_IRQ_USB1;
+		irq_resource.end = irq_resource.start;
+		irq_resource.flags = IORESOURCE_IRQ;
+		pdev = platform_device_register_simple((char *)octeon_usb_driver.  name, device, &irq_resource, 1);
+		if (IS_ERR(pdev)) {
+			DEBUG_FATAL("OcteonUSB: Failed to allocate platform device for USB%d\n", device);
+			driver_unregister(&octeon_usb_driver);
+			octeon_usb_registered = 0;
+			return PTR_ERR(pdev);
+		}
+		if (device < MAX_USB_PORTS)
+			pdev_glob[device] = pdev;
+
+	}
+	return 0;
 }
 
 static void __exit octeon_usb_module_cleanup(void)
 {
-    int i;
-    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-    for (i = 0; i <MAX_USB_PORTS; i++)
-        if (pdev_glob[i]) {
-            platform_device_unregister(pdev_glob[i]);
-            pdev_glob[i] = NULL;
-        }
+	int i;
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	for (i = 0; i < MAX_USB_PORTS; i++)
+		if (pdev_glob[i]) {
+			platform_device_unregister(pdev_glob[i]);
+			pdev_glob[i] = NULL;
+		}
 	if (octeon_usb_registered)
 		driver_unregister(&octeon_usb_driver);
 }

commit 57f9c1d862070a431d42541f0d183f6edadd4354
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Wed Jun 5 18:06:46 2013 +0800

    staging: octeon-usb: remove duplicated include from octeon-hcd.c
    
    Remove duplicated include.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index fa72d59e3aa0..08de25f94754 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -11,7 +11,6 @@
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
-#include <linux/platform_device.h>
 #include <linux/usb.h>
 
 #include <asm/time.h>

commit 5e15430eaf0168d32df6d0dcacabdbab0448fb67
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Tue Jun 4 02:46:21 2013 +0530

    staging: octeon-usb: call device_unregister when platform_device_register_simple fails
    
    device_register is called before platform_device_register_simple gets called.
    unregister and reset the octeon_usb_registered variable
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: David Daney <ddaney.cavm@gmail.com>
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index f3a096be2aba..fa72d59e3aa0 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -785,6 +785,8 @@ static int __init octeon_usb_module_init(void)
         pdev = platform_device_register_simple((char*)octeon_usb_driver.name, device, &irq_resource, 1);
         if (IS_ERR(pdev)) {
             DEBUG_FATAL("OcteonUSB: Failed to allocate platform device for USB%d\n", device);
+		driver_unregister(&octeon_usb_driver);
+		octeon_usb_registered = 0;
             return PTR_ERR(pdev);
         }
         if (device < MAX_USB_PORTS)

commit 55fa328aecb1daf9134278b0eb660502627bf60e
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Tue Jun 4 02:46:20 2013 +0530

    staging: octeon-usb: check return value of platform_device_register_simple
    
    the return value is a pointer having an error set. we have to check for
    IS_ERR and return PTR_ERR when appropriate
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: David Daney <ddaney.cavm@gmail.com>
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index 987e6a90cbbc..f3a096be2aba 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -23,6 +23,8 @@
 
 #include <linux/usb/hcd.h>
 
+#include <linux/err.h>
+
 //#define DEBUG_CALL(format, ...)         printk(format, ##__VA_ARGS__)
 #define DEBUG_CALL(format, ...)         do {} while (0)
 //#define DEBUG_SUBMIT(format, ...)       printk(format, ##__VA_ARGS__)
@@ -781,9 +783,9 @@ static int __init octeon_usb_module_init(void)
         irq_resource.end = irq_resource.start;
         irq_resource.flags = IORESOURCE_IRQ;
         pdev = platform_device_register_simple((char*)octeon_usb_driver.name, device, &irq_resource, 1);
-        if (!pdev) {
+        if (IS_ERR(pdev)) {
             DEBUG_FATAL("OcteonUSB: Failed to allocate platform device for USB%d\n", device);
-            return -ENOMEM;
+            return PTR_ERR(pdev);
         }
         if (device < MAX_USB_PORTS)
             pdev_glob[device] = pdev;

commit 3fa98f34b8e39bbadb8bc723c0773b73b262663c
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Tue Jun 4 02:46:19 2013 +0530

    staging: octeon-usb: fix more checkpatch errors/warns
    
    place the opening brace right after the if, else, else if, switch
    statements.
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: David Daney <ddaney.cavm@gmail.com>
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
index b78bd19babda..987e6a90cbbc 100644
--- a/drivers/staging/octeon-usb/octeon-hcd.c
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -142,23 +142,18 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 
     /* For Isochronous transactions we need to update the URB packet status
         list from data in our private copy */
-    if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)
-    {
+    if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
         int i;
         /* The pointer to the private list is stored in the setup_packet field */
         cvmx_usb_iso_packet_t *iso_packet = (cvmx_usb_iso_packet_t *)urb->setup_packet;
         /* Recalculate the transfer size by adding up each packet */
         urb->actual_length = 0;
-        for (i=0; i<urb->number_of_packets; i++)
-        {
-            if (iso_packet[i].status == CVMX_USB_COMPLETE_SUCCESS)
-            {
+        for (i=0; i<urb->number_of_packets; i++) {
+            if (iso_packet[i].status == CVMX_USB_COMPLETE_SUCCESS) {
                 urb->iso_frame_desc[i].status = 0;
                 urb->iso_frame_desc[i].actual_length = iso_packet[i].length;
                 urb->actual_length += urb->iso_frame_desc[i].actual_length;
-            }
-            else
-            {
+            } else {
                 DEBUG_ERROR("%s: ISOCHRONOUS packet=%d of %d status=%d pipe=%d submit=%d size=%d\n",
                             __FUNCTION__, i, urb->number_of_packets,
                             iso_packet[i].status, pipe_handle,
@@ -171,8 +166,7 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
         urb->setup_packet = NULL;
     }
 
-    switch (status)
-    {
+    switch (status) {
         case CVMX_USB_COMPLETE_SUCCESS:
             urb->status = 0;
             break;
@@ -222,14 +216,12 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
     INIT_LIST_HEAD(&urb->urb_list); /* not enqueued on dequeue_list */
     spin_lock_irqsave(&priv->lock, flags);
 
-    if (!ep->hcpriv)
-    {
+    if (!ep->hcpriv) {
         cvmx_usb_transfer_t transfer_type;
         cvmx_usb_speed_t speed;
         int split_device = 0;
         int split_port = 0;
-        switch (usb_pipetype(urb->pipe))
-        {
+        switch (usb_pipetype(urb->pipe)) {
             case PIPE_ISOCHRONOUS:
                 transfer_type = CVMX_USB_TRANSFER_ISOCHRONOUS;
                 break;
@@ -243,8 +235,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
                 transfer_type = CVMX_USB_TRANSFER_BULK;
                 break;
         }
-        switch (urb->dev->speed)
-        {
+        switch (urb->dev->speed) {
             case USB_SPEED_LOW:
                 speed = CVMX_USB_SPEED_LOW;
                 break;
@@ -258,15 +249,12 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
         /* For slow devices on high speed ports we need to find the hub that
             does the speed translation so we know where to send the split
             transactions */
-        if (speed != CVMX_USB_SPEED_HIGH)
-        {
+        if (speed != CVMX_USB_SPEED_HIGH) {
             /* Start at this device and work our way up the usb tree */
             struct usb_device *dev = urb->dev;
-            while (dev->parent)
-            {
+            while (dev->parent) {
                 /* If our parent is high speed then he'll receive the splits */
-                if (dev->parent->speed == USB_SPEED_HIGH)
-                {
+                if (dev->parent->speed == USB_SPEED_HIGH) {
                     split_device = dev->parent->devnum;
                     split_port = dev->portnum;
                     break;
@@ -289,8 +277,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
                                          (le16_to_cpu(ep->desc.wMaxPacketSize)>>11) & 0x3,
                                          split_device,
                                          split_port);
-        if (pipe_handle < 0)
-        {
+        if (pipe_handle < 0) {
             spin_unlock_irqrestore(&priv->lock, flags);
             DEBUG_ERROR("OcteonUSB: %s failed to create pipe\n", __FUNCTION__);
             return -ENOMEM;
@@ -300,19 +287,16 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
     else
         pipe_handle = 0xffff & (long)ep->hcpriv;
 
-    switch (usb_pipetype(urb->pipe))
-    {
+    switch (usb_pipetype(urb->pipe)) {
         case PIPE_ISOCHRONOUS:
             DEBUG_SUBMIT("OcteonUSB: %s submit isochronous to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
             /* Allocate a structure to use for our private list of isochronous
                 packets */
             iso_packet = kmalloc(urb->number_of_packets * sizeof(cvmx_usb_iso_packet_t), GFP_ATOMIC);
-            if (iso_packet)
-            {
+            if (iso_packet) {
                 int i;
                 /* Fill the list with the data from the URB */
-                for (i=0; i<urb->number_of_packets; i++)
-                {
+                for (i=0; i<urb->number_of_packets; i++) {
                     iso_packet[i].offset = urb->iso_frame_desc[i].offset;
                     iso_packet[i].length = urb->iso_frame_desc[i].length;
                     iso_packet[i].status = CVMX_USB_COMPLETE_ERROR;
@@ -331,8 +315,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
                                                             octeon_usb_urb_complete_callback,
                                                             urb);
                 /* If submit failed we need to free our private packet list */
-                if (submit_handle < 0)
-                {
+                if (submit_handle < 0) {
                     urb->setup_packet = NULL;
                     kfree(iso_packet);
                 }
@@ -364,8 +347,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
                                                  urb);
             break;
     }
-    if (submit_handle < 0)
-    {
+    if (submit_handle < 0) {
         spin_unlock_irqrestore(&priv->lock, flags);
         DEBUG_ERROR("OcteonUSB: %s failed to submit\n", __FUNCTION__);
         return -ENOMEM;
@@ -422,8 +404,7 @@ static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int stat
 static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 {
     DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-    if (ep->hcpriv)
-    {
+    if (ep->hcpriv) {
         struct octeon_hcd *priv = hcd_to_octeon(hcd);
         int pipe_handle = 0xffff & (long)ep->hcpriv;
         unsigned long flags;
@@ -461,12 +442,10 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
     struct usb_hub_descriptor *desc;
     unsigned long flags;
 
-    switch (typeReq)
-    {
+    switch (typeReq) {
         case ClearHubFeature:
             DEBUG_ROOT_HUB("OcteonUSB: ClearHubFeature\n");
-            switch (wValue)
-            {
+            switch (wValue) {
                 case C_HUB_LOCAL_POWER:
                 case C_HUB_OVER_CURRENT:
                     /* Nothing required here */
@@ -477,14 +456,12 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
             break;
         case ClearPortFeature:
             DEBUG_ROOT_HUB("OcteonUSB: ClearPortFeature");
-            if (wIndex != 1)
-            {
+            if (wIndex != 1) {
                 DEBUG_ROOT_HUB(" INVALID\n");
                 return -EINVAL;
             }
 
-            switch (wValue)
-            {
+            switch (wValue) {
                 case USB_PORT_FEAT_ENABLE:
                     DEBUG_ROOT_HUB(" ENABLE");
                     spin_lock_irqsave(&priv->lock, flags);
@@ -561,8 +538,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
             break;
         case GetPortStatus:
             DEBUG_ROOT_HUB("OcteonUSB: GetPortStatus");
-            if (wIndex != 1)
-            {
+            if (wIndex != 1) {
                 DEBUG_ROOT_HUB(" INVALID\n");
                 return -EINVAL;
             }
@@ -572,49 +548,40 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
             spin_unlock_irqrestore(&priv->lock, flags);
             port_status = 0;
 
-            if (usb_port_status.connect_change)
-            {
+            if (usb_port_status.connect_change) {
                 port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
                 DEBUG_ROOT_HUB(" C_CONNECTION");
             }
 
-            if (usb_port_status.port_enabled)
-            {
+            if (usb_port_status.port_enabled) {
                 port_status |= (1 << USB_PORT_FEAT_C_ENABLE);
                 DEBUG_ROOT_HUB(" C_ENABLE");
             }
 
-            if (usb_port_status.connected)
-            {
+            if (usb_port_status.connected) {
                 port_status |= (1 << USB_PORT_FEAT_CONNECTION);
                 DEBUG_ROOT_HUB(" CONNECTION");
             }
 
-            if (usb_port_status.port_enabled)
-            {
+            if (usb_port_status.port_enabled) {
                 port_status |= (1 << USB_PORT_FEAT_ENABLE);
                 DEBUG_ROOT_HUB(" ENABLE");
             }
 
-            if (usb_port_status.port_over_current)
-            {
+            if (usb_port_status.port_over_current) {
                 port_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);
                 DEBUG_ROOT_HUB(" OVER_CURRENT");
             }
 
-            if (usb_port_status.port_powered)
-            {
+            if (usb_port_status.port_powered) {
                 port_status |= (1 << USB_PORT_FEAT_POWER);
                 DEBUG_ROOT_HUB(" POWER");
             }
 
-            if (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH)
-            {
+            if (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH) {
 		port_status |= USB_PORT_STAT_HIGH_SPEED;
                 DEBUG_ROOT_HUB(" HIGHSPEED");
-            }
-            else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW)
-            {
+            } else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW) {
                 port_status |= (1 << USB_PORT_FEAT_LOWSPEED);
                 DEBUG_ROOT_HUB(" LOWSPEED");
             }
@@ -628,14 +595,12 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
             break;
         case SetPortFeature:
             DEBUG_ROOT_HUB("OcteonUSB: SetPortFeature");
-            if (wIndex != 1)
-            {
+            if (wIndex != 1) {
                 DEBUG_ROOT_HUB(" INVALID\n");
                 return -EINVAL;
             }
 
-            switch (wValue)
-            {
+            switch (wValue) {
                 case USB_PORT_FEAT_SUSPEND:
                     DEBUG_ROOT_HUB(" SUSPEND\n");
                     return -EINVAL;
@@ -701,8 +666,7 @@ static int octeon_usb_driver_probe(struct device *dev)
     dev->dma_mask = &dev->coherent_dma_mask;
 
     hcd = usb_create_hcd(&octeon_hc_driver, dev, dev_name(dev));
-    if (!hcd)
-    {
+    if (!hcd) {
         DEBUG_FATAL("OcteonUSB: Failed to allocate memory for HCD\n");
         return -1;
     }
@@ -716,8 +680,7 @@ static int octeon_usb_driver_probe(struct device *dev)
 
     //status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS | CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS);
     status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO);
-    if (status)
-    {
+    if (status) {
         DEBUG_FATAL("OcteonUSB: USB initialization failed with %d\n", status);
         kfree(hcd);
         return -1;
@@ -731,8 +694,7 @@ static int octeon_usb_driver_probe(struct device *dev)
     spin_unlock_irqrestore(&priv->lock, flags);
 
     status = usb_add_hcd(hcd, irq, IRQF_SHARED);
-    if (status)
-    {
+    if (status) {
         DEBUG_FATAL("OcteonUSB: USB add HCD failed with %d\n", status);
         kfree(hcd);
         return -1;
@@ -784,8 +746,7 @@ static int __init octeon_usb_module_init(void)
     if (usb_disabled() || num_devices == 0)
 	return -ENODEV;
 
-    if (driver_register(&octeon_usb_driver))
-    {
+    if (driver_register(&octeon_usb_driver)) {
         DEBUG_FATAL("OcteonUSB: Failed to register driver\n");
         return -ENOMEM;
     }
@@ -812,8 +773,7 @@ static int __init octeon_usb_module_init(void)
 		cvmx_write_csr(CVMX_IOB_N2C_L2C_PRI_CNT, pri_cnt.u64);
 	}
 
-    for (device = 0; device < num_devices; device++)
-    {
+    for (device = 0; device < num_devices; device++) {
         struct resource irq_resource;
         struct platform_device *pdev;
         memset(&irq_resource, 0, sizeof(irq_resource));
@@ -821,8 +781,7 @@ static int __init octeon_usb_module_init(void)
         irq_resource.end = irq_resource.start;
         irq_resource.flags = IORESOURCE_IRQ;
         pdev = platform_device_register_simple((char*)octeon_usb_driver.name, device, &irq_resource, 1);
-        if (!pdev)
-        {
+        if (!pdev) {
             DEBUG_FATAL("OcteonUSB: Failed to allocate platform device for USB%d\n", device);
             return -ENOMEM;
         }
@@ -838,8 +797,7 @@ static void __exit octeon_usb_module_cleanup(void)
     int i;
     DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
     for (i = 0; i <MAX_USB_PORTS; i++)
-        if (pdev_glob[i])
-        {
+        if (pdev_glob[i]) {
             platform_device_unregister(pdev_glob[i]);
             pdev_glob[i] = NULL;
         }

commit b164935b38d64557a32892e7aa45e213e9d11ea8
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sat Jun 1 21:42:58 2013 +0300

    staging: MIPS: add Octeon USB HCD support
    
    Add support for Octeon USB HCD. Tested on EdgeRouter Lite with USB
    mass storage.
    
    The driver has been extracted from GPL sources of EdgeRouter Lite firmware
    (based on Linux 2.6.32.13). Some minor fixes and cleanups have been done
    to make it work with 3.10-rc3.
    
    $ uname -a
    Linux (none) 3.10.0-rc3-edge-00005-g86cb5bc #41 SMP PREEMPT Sat Jun 1 20:41:46 EEST 2013 mips64 GNU/Linux
    $ modprobe octeon-usb
    [   37.971683] octeon_usb: module is from the staging directory, the quality is unknown, you have been warned.
    [   37.983649] OcteonUSB: Detected 1 ports
    [   37.999360] OcteonUSB OcteonUSB.0: Octeon Host Controller
    [   38.004847] OcteonUSB OcteonUSB.0: new USB bus registered, assigned bus number 1
    [   38.012332] OcteonUSB OcteonUSB.0: irq 122, io mem 0x00000000
    [   38.019970] hub 1-0:1.0: USB hub found
    [   38.023851] hub 1-0:1.0: 1 port detected
    [   38.028101] OcteonUSB: Registered HCD for port 0 on irq 122
    [   38.391443] usb 1-1: new high-speed USB device number 2 using OcteonUSB
    [   38.586922] usb-storage 1-1:1.0: USB Mass Storage device detected
    [   38.597375] scsi0 : usb-storage 1-1:1.0
    [   39.604111] scsi 0:0:0:0: Direct-Access              USB DISK 2.0     PMAP PQ: 0 ANSI: 4
    [   39.619113] sd 0:0:0:0: [sda] 7579008 512-byte logical blocks: (3.88 GB/3.61 GiB)
    [   39.630696] sd 0:0:0:0: [sda] Write Protect is off
    [   39.635945] sd 0:0:0:0: [sda] No Caching mode page present
    [   39.641464] sd 0:0:0:0: [sda] Assuming drive cache: write through
    [   39.651341] sd 0:0:0:0: [sda] No Caching mode page present
    [   39.656917] sd 0:0:0:0: [sda] Assuming drive cache: write through
    [   39.664296]  sda: sda1 sda2
    [   39.675574] sd 0:0:0:0: [sda] No Caching mode page present
    [   39.681093] sd 0:0:0:0: [sda] Assuming drive cache: write through
    [   39.687223] sd 0:0:0:0: [sda] Attached SCSI removable disk
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: David Daney <ddaney.cavm@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/octeon-usb/octeon-hcd.c b/drivers/staging/octeon-usb/octeon-hcd.c
new file mode 100644
index 000000000000..b78bd19babda
--- /dev/null
+++ b/drivers/staging/octeon-usb/octeon-hcd.c
@@ -0,0 +1,854 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2008 Cavium Networks
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/platform_device.h>
+#include <linux/usb.h>
+
+#include <asm/time.h>
+#include <asm/delay.h>
+
+#include <asm/octeon/cvmx.h>
+#include "cvmx-usb.h"
+#include <asm/octeon/cvmx-iob-defs.h>
+
+#include <linux/usb/hcd.h>
+
+//#define DEBUG_CALL(format, ...)         printk(format, ##__VA_ARGS__)
+#define DEBUG_CALL(format, ...)         do {} while (0)
+//#define DEBUG_SUBMIT(format, ...)       printk(format, ##__VA_ARGS__)
+#define DEBUG_SUBMIT(format, ...)       do {} while (0)
+//#define DEBUG_ROOT_HUB(format, ...)     printk(format, ##__VA_ARGS__)
+#define DEBUG_ROOT_HUB(format, ...)     do {} while (0)
+//#define DEBUG_ERROR(format, ...)        printk(format, ##__VA_ARGS__)
+#define DEBUG_ERROR(format, ...)        do {} while (0)
+#define DEBUG_FATAL(format, ...)        printk(format, ##__VA_ARGS__)
+
+struct octeon_hcd {
+    spinlock_t lock;
+    cvmx_usb_state_t usb;
+    struct tasklet_struct dequeue_tasklet;
+    struct list_head dequeue_list;
+};
+
+/* convert between an HCD pointer and the corresponding struct octeon_hcd */
+static inline struct octeon_hcd *hcd_to_octeon(struct usb_hcd *hcd)
+{
+	return (struct octeon_hcd *)(hcd->hcd_priv);
+}
+
+static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
+{
+	return container_of((void *)p, struct usb_hcd, hcd_priv);
+}
+
+static inline struct octeon_hcd *cvmx_usb_to_octeon(cvmx_usb_state_t *p)
+{
+	return container_of(p, struct octeon_hcd, usb);
+}
+
+static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
+{
+    struct octeon_hcd *priv = hcd_to_octeon(hcd);
+    unsigned long flags;
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+    spin_lock_irqsave(&priv->lock, flags);
+    cvmx_usb_poll(&priv->usb);
+    spin_unlock_irqrestore(&priv->lock, flags);
+    return IRQ_HANDLED;
+}
+
+static void octeon_usb_port_callback(cvmx_usb_state_t *usb,
+                                     cvmx_usb_callback_t reason,
+                                     cvmx_usb_complete_t status,
+                                     int pipe_handle,
+                                     int submit_handle,
+                                     int bytes_transferred,
+                                     void *user_data)
+{
+    struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+    spin_unlock(&priv->lock);
+    usb_hcd_poll_rh_status(octeon_to_hcd(priv));
+    spin_lock(&priv->lock);
+}
+
+static int octeon_usb_start(struct usb_hcd *hcd)
+{
+    struct octeon_hcd *priv = hcd_to_octeon(hcd);
+    unsigned long flags;
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+    hcd->state = HC_STATE_RUNNING;
+    spin_lock_irqsave(&priv->lock, flags);
+    cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
+                               octeon_usb_port_callback, NULL);
+    spin_unlock_irqrestore(&priv->lock, flags);
+    return 0;
+}
+
+static void octeon_usb_stop(struct usb_hcd *hcd)
+{
+    struct octeon_hcd *priv = hcd_to_octeon(hcd);
+    unsigned long flags;
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+    spin_lock_irqsave(&priv->lock, flags);
+    cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
+                               NULL, NULL);
+    spin_unlock_irqrestore(&priv->lock, flags);
+    hcd->state = HC_STATE_HALT;
+}
+
+static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
+{
+    struct octeon_hcd *priv = hcd_to_octeon(hcd);
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+    return cvmx_usb_get_frame_number(&priv->usb);
+}
+
+static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
+                                             cvmx_usb_callback_t reason,
+                                             cvmx_usb_complete_t status,
+                                             int pipe_handle,
+                                             int submit_handle,
+                                             int bytes_transferred,
+                                             void *user_data)
+{
+    struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
+    struct urb *urb = user_data;
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+    urb->actual_length = bytes_transferred;
+    urb->hcpriv = NULL;
+
+	if (!list_empty(&urb->urb_list)) {
+		/*
+		 * It is on the dequeue_list, but we are going to call
+		 * usb_hcd_giveback_urb(), so we must clear it from
+		 * the list.  We got to it before the
+		 * octeon_usb_urb_dequeue_work() tasklet did.
+		 */
+		list_del(&urb->urb_list);
+		/* No longer on the dequeue_list. */
+		INIT_LIST_HEAD(&urb->urb_list);
+	}
+
+    /* For Isochronous transactions we need to update the URB packet status
+        list from data in our private copy */
+    if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)
+    {
+        int i;
+        /* The pointer to the private list is stored in the setup_packet field */
+        cvmx_usb_iso_packet_t *iso_packet = (cvmx_usb_iso_packet_t *)urb->setup_packet;
+        /* Recalculate the transfer size by adding up each packet */
+        urb->actual_length = 0;
+        for (i=0; i<urb->number_of_packets; i++)
+        {
+            if (iso_packet[i].status == CVMX_USB_COMPLETE_SUCCESS)
+            {
+                urb->iso_frame_desc[i].status = 0;
+                urb->iso_frame_desc[i].actual_length = iso_packet[i].length;
+                urb->actual_length += urb->iso_frame_desc[i].actual_length;
+            }
+            else
+            {
+                DEBUG_ERROR("%s: ISOCHRONOUS packet=%d of %d status=%d pipe=%d submit=%d size=%d\n",
+                            __FUNCTION__, i, urb->number_of_packets,
+                            iso_packet[i].status, pipe_handle,
+                            submit_handle, iso_packet[i].length);
+                urb->iso_frame_desc[i].status = -EREMOTEIO;
+            }
+        }
+        /* Free the private list now that we don't need it anymore */
+        kfree(iso_packet);
+        urb->setup_packet = NULL;
+    }
+
+    switch (status)
+    {
+        case CVMX_USB_COMPLETE_SUCCESS:
+            urb->status = 0;
+            break;
+        case CVMX_USB_COMPLETE_CANCEL:
+            if (urb->status == 0)
+                urb->status = -ENOENT;
+            break;
+        case CVMX_USB_COMPLETE_STALL:
+            DEBUG_ERROR("%s: status=stall pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
+            urb->status = -EPIPE;
+            break;
+        case CVMX_USB_COMPLETE_BABBLEERR:
+            DEBUG_ERROR("%s: status=babble pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
+            urb->status = -EPIPE;
+            break;
+        case CVMX_USB_COMPLETE_SHORT:
+            DEBUG_ERROR("%s: status=short pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
+            urb->status = -EREMOTEIO;
+            break;
+        case CVMX_USB_COMPLETE_ERROR:
+        case CVMX_USB_COMPLETE_XACTERR:
+        case CVMX_USB_COMPLETE_DATATGLERR:
+        case CVMX_USB_COMPLETE_FRAMEERR:
+            DEBUG_ERROR("%s: status=%d pipe=%d submit=%d size=%d\n", __FUNCTION__, status, pipe_handle, submit_handle, bytes_transferred);
+            urb->status = -EPROTO;
+            break;
+    }
+    spin_unlock(&priv->lock);
+    usb_hcd_giveback_urb(octeon_to_hcd(priv), urb, urb->status);
+    spin_lock(&priv->lock);
+}
+
+static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
+                                  struct urb *urb,
+                                  gfp_t mem_flags)
+{
+    struct octeon_hcd *priv = hcd_to_octeon(hcd);
+    int submit_handle = -1;
+    int pipe_handle;
+    unsigned long flags;
+    cvmx_usb_iso_packet_t *iso_packet;
+    struct usb_host_endpoint *ep = urb->ep;
+
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
+    urb->status = 0;
+    INIT_LIST_HEAD(&urb->urb_list); /* not enqueued on dequeue_list */
+    spin_lock_irqsave(&priv->lock, flags);
+
+    if (!ep->hcpriv)
+    {
+        cvmx_usb_transfer_t transfer_type;
+        cvmx_usb_speed_t speed;
+        int split_device = 0;
+        int split_port = 0;
+        switch (usb_pipetype(urb->pipe))
+        {
+            case PIPE_ISOCHRONOUS:
+                transfer_type = CVMX_USB_TRANSFER_ISOCHRONOUS;
+                break;
+            case PIPE_INTERRUPT:
+                transfer_type = CVMX_USB_TRANSFER_INTERRUPT;
+                break;
+            case PIPE_CONTROL:
+                transfer_type = CVMX_USB_TRANSFER_CONTROL;
+                break;
+            default:
+                transfer_type = CVMX_USB_TRANSFER_BULK;
+                break;
+        }
+        switch (urb->dev->speed)
+        {
+            case USB_SPEED_LOW:
+                speed = CVMX_USB_SPEED_LOW;
+                break;
+            case USB_SPEED_FULL:
+                speed = CVMX_USB_SPEED_FULL;
+                break;
+            default:
+                speed = CVMX_USB_SPEED_HIGH;
+                break;
+        }
+        /* For slow devices on high speed ports we need to find the hub that
+            does the speed translation so we know where to send the split
+            transactions */
+        if (speed != CVMX_USB_SPEED_HIGH)
+        {
+            /* Start at this device and work our way up the usb tree */
+            struct usb_device *dev = urb->dev;
+            while (dev->parent)
+            {
+                /* If our parent is high speed then he'll receive the splits */
+                if (dev->parent->speed == USB_SPEED_HIGH)
+                {
+                    split_device = dev->parent->devnum;
+                    split_port = dev->portnum;
+                    break;
+                }
+                /* Move up the tree one level. If we make it all the way up the
+                    tree, then the port must not be in high speed mode and we
+                    don't need a split */
+                dev = dev->parent;
+            }
+        }
+        pipe_handle = cvmx_usb_open_pipe(&priv->usb,
+                                         0,
+                                         usb_pipedevice(urb->pipe),
+                                         usb_pipeendpoint(urb->pipe),
+                                         speed,
+                                         le16_to_cpu(ep->desc.wMaxPacketSize) & 0x7ff,
+                                         transfer_type,
+                                         usb_pipein(urb->pipe) ? CVMX_USB_DIRECTION_IN : CVMX_USB_DIRECTION_OUT,
+                                         urb->interval,
+                                         (le16_to_cpu(ep->desc.wMaxPacketSize)>>11) & 0x3,
+                                         split_device,
+                                         split_port);
+        if (pipe_handle < 0)
+        {
+            spin_unlock_irqrestore(&priv->lock, flags);
+            DEBUG_ERROR("OcteonUSB: %s failed to create pipe\n", __FUNCTION__);
+            return -ENOMEM;
+        }
+        ep->hcpriv = (void*)(0x10000L + pipe_handle);
+    }
+    else
+        pipe_handle = 0xffff & (long)ep->hcpriv;
+
+    switch (usb_pipetype(urb->pipe))
+    {
+        case PIPE_ISOCHRONOUS:
+            DEBUG_SUBMIT("OcteonUSB: %s submit isochronous to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+            /* Allocate a structure to use for our private list of isochronous
+                packets */
+            iso_packet = kmalloc(urb->number_of_packets * sizeof(cvmx_usb_iso_packet_t), GFP_ATOMIC);
+            if (iso_packet)
+            {
+                int i;
+                /* Fill the list with the data from the URB */
+                for (i=0; i<urb->number_of_packets; i++)
+                {
+                    iso_packet[i].offset = urb->iso_frame_desc[i].offset;
+                    iso_packet[i].length = urb->iso_frame_desc[i].length;
+                    iso_packet[i].status = CVMX_USB_COMPLETE_ERROR;
+                }
+                /* Store a pointer to the list in uthe URB setup_pakcet field.
+                    We know this currently isn't being used and this saves us
+                    a bunch of logic */
+                urb->setup_packet = (char*)iso_packet;
+                submit_handle = cvmx_usb_submit_isochronous(&priv->usb, pipe_handle,
+                                                            urb->start_frame,
+                                                            0 /* flags */,
+                                                            urb->number_of_packets,
+                                                            iso_packet,
+                                                            urb->transfer_dma,
+                                                            urb->transfer_buffer_length,
+                                                            octeon_usb_urb_complete_callback,
+                                                            urb);
+                /* If submit failed we need to free our private packet list */
+                if (submit_handle < 0)
+                {
+                    urb->setup_packet = NULL;
+                    kfree(iso_packet);
+                }
+            }
+            break;
+        case PIPE_INTERRUPT:
+            DEBUG_SUBMIT("OcteonUSB: %s submit interrupt to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+            submit_handle = cvmx_usb_submit_interrupt(&priv->usb, pipe_handle,
+                                                      urb->transfer_dma,
+                                                      urb->transfer_buffer_length,
+                                                      octeon_usb_urb_complete_callback,
+                                                      urb);
+            break;
+        case PIPE_CONTROL:
+            DEBUG_SUBMIT("OcteonUSB: %s submit control to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+            submit_handle = cvmx_usb_submit_control(&priv->usb, pipe_handle,
+                                                    urb->setup_dma,
+                                                    urb->transfer_dma,
+                                                    urb->transfer_buffer_length,
+                                                    octeon_usb_urb_complete_callback,
+                                                    urb);
+            break;
+        case PIPE_BULK:
+            DEBUG_SUBMIT("OcteonUSB: %s submit bulk to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+            submit_handle = cvmx_usb_submit_bulk(&priv->usb, pipe_handle,
+                                                 urb->transfer_dma,
+                                                 urb->transfer_buffer_length,
+                                                 octeon_usb_urb_complete_callback,
+                                                 urb);
+            break;
+    }
+    if (submit_handle < 0)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        DEBUG_ERROR("OcteonUSB: %s failed to submit\n", __FUNCTION__);
+        return -ENOMEM;
+    }
+    urb->hcpriv = (void*)(long)(((submit_handle & 0xffff) << 16) | pipe_handle);
+    spin_unlock_irqrestore(&priv->lock, flags);
+    return 0;
+}
+
+static void octeon_usb_urb_dequeue_work(unsigned long arg)
+{
+    unsigned long flags;
+    struct octeon_hcd *priv = (struct octeon_hcd *)arg;
+
+    spin_lock_irqsave(&priv->lock, flags);
+
+    while (!list_empty(&priv->dequeue_list)) {
+        int pipe_handle;
+        int submit_handle;
+        struct urb *urb = container_of(priv->dequeue_list.next, struct urb, urb_list);
+        list_del(&urb->urb_list);
+        /* not enqueued on dequeue_list */
+        INIT_LIST_HEAD(&urb->urb_list);
+        pipe_handle = 0xffff & (long)urb->hcpriv;
+        submit_handle = ((long)urb->hcpriv) >> 16;
+        cvmx_usb_cancel(&priv->usb, pipe_handle, submit_handle);
+    }
+
+    spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+{
+    struct octeon_hcd *priv = hcd_to_octeon(hcd);
+    unsigned long flags;
+
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
+    if (!urb->dev)
+        return -EINVAL;
+
+    spin_lock_irqsave(&priv->lock, flags);
+
+    urb->status = status;
+    list_add_tail(&urb->urb_list, &priv->dequeue_list);
+
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    tasklet_schedule(&priv->dequeue_tasklet);
+
+    return 0;
+}
+
+static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
+{
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+    if (ep->hcpriv)
+    {
+        struct octeon_hcd *priv = hcd_to_octeon(hcd);
+        int pipe_handle = 0xffff & (long)ep->hcpriv;
+        unsigned long flags;
+        spin_lock_irqsave(&priv->lock, flags);
+        cvmx_usb_cancel_all(&priv->usb, pipe_handle);
+        if (cvmx_usb_close_pipe(&priv->usb, pipe_handle))
+            DEBUG_ERROR("OcteonUSB: Closing pipe %d failed\n", pipe_handle);
+        spin_unlock_irqrestore(&priv->lock, flags);
+        ep->hcpriv = NULL;
+    }
+}
+
+static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+    struct octeon_hcd *priv = hcd_to_octeon(hcd);
+    cvmx_usb_port_status_t port_status;
+    unsigned long flags;
+
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
+    spin_lock_irqsave(&priv->lock, flags);
+    port_status = cvmx_usb_get_status(&priv->usb);
+    spin_unlock_irqrestore(&priv->lock, flags);
+    buf[0] = 0;
+    buf[0] = port_status.connect_change << 1;
+
+    return(buf[0] != 0);
+}
+
+static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex, char *buf, u16 wLength)
+{
+    struct octeon_hcd *priv = hcd_to_octeon(hcd);
+    cvmx_usb_port_status_t usb_port_status;
+    int port_status;
+    struct usb_hub_descriptor *desc;
+    unsigned long flags;
+
+    switch (typeReq)
+    {
+        case ClearHubFeature:
+            DEBUG_ROOT_HUB("OcteonUSB: ClearHubFeature\n");
+            switch (wValue)
+            {
+                case C_HUB_LOCAL_POWER:
+                case C_HUB_OVER_CURRENT:
+                    /* Nothing required here */
+                    break;
+                default:
+                    return -EINVAL;
+            }
+            break;
+        case ClearPortFeature:
+            DEBUG_ROOT_HUB("OcteonUSB: ClearPortFeature");
+            if (wIndex != 1)
+            {
+                DEBUG_ROOT_HUB(" INVALID\n");
+                return -EINVAL;
+            }
+
+            switch (wValue)
+            {
+                case USB_PORT_FEAT_ENABLE:
+                    DEBUG_ROOT_HUB(" ENABLE");
+                    spin_lock_irqsave(&priv->lock, flags);
+                    cvmx_usb_disable(&priv->usb);
+                    spin_unlock_irqrestore(&priv->lock, flags);
+                    break;
+                case USB_PORT_FEAT_SUSPEND:
+                    DEBUG_ROOT_HUB(" SUSPEND");
+                    /* Not supported on Octeon */
+                    break;
+                case USB_PORT_FEAT_POWER:
+                    DEBUG_ROOT_HUB(" POWER");
+                    /* Not supported on Octeon */
+                    break;
+                case USB_PORT_FEAT_INDICATOR:
+                    DEBUG_ROOT_HUB(" INDICATOR");
+                    /* Port inidicator not supported */
+                    break;
+                case USB_PORT_FEAT_C_CONNECTION:
+                    DEBUG_ROOT_HUB(" C_CONNECTION");
+                    /* Clears drivers internal connect status change flag */
+                    spin_lock_irqsave(&priv->lock, flags);
+                    cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+                    spin_unlock_irqrestore(&priv->lock, flags);
+                    break;
+                case USB_PORT_FEAT_C_RESET:
+                    DEBUG_ROOT_HUB(" C_RESET");
+                    /* Clears the driver's internal Port Reset Change flag */
+                    spin_lock_irqsave(&priv->lock, flags);
+                    cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+                    spin_unlock_irqrestore(&priv->lock, flags);
+                    break;
+                case USB_PORT_FEAT_C_ENABLE:
+                    DEBUG_ROOT_HUB(" C_ENABLE");
+                    /* Clears the driver's internal Port Enable/Disable Change flag */
+                    spin_lock_irqsave(&priv->lock, flags);
+                    cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+                    spin_unlock_irqrestore(&priv->lock, flags);
+                    break;
+                case USB_PORT_FEAT_C_SUSPEND:
+                    DEBUG_ROOT_HUB(" C_SUSPEND");
+                    /* Clears the driver's internal Port Suspend Change flag,
+                        which is set when resume signaling on the host port is
+                        complete */
+                    break;
+                case USB_PORT_FEAT_C_OVER_CURRENT:
+                    DEBUG_ROOT_HUB(" C_OVER_CURRENT");
+                    /* Clears the driver's overcurrent Change flag */
+                    spin_lock_irqsave(&priv->lock, flags);
+                    cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+                    spin_unlock_irqrestore(&priv->lock, flags);
+                    break;
+                default:
+                    DEBUG_ROOT_HUB(" UNKNOWN\n");
+                    return -EINVAL;
+            }
+            DEBUG_ROOT_HUB("\n");
+            break;
+        case GetHubDescriptor:
+            DEBUG_ROOT_HUB("OcteonUSB: GetHubDescriptor\n");
+            desc = (struct usb_hub_descriptor *)buf;
+            desc->bDescLength = 9;
+            desc->bDescriptorType = 0x29;
+            desc->bNbrPorts = 1;
+            desc->wHubCharacteristics = 0x08;
+            desc->bPwrOn2PwrGood = 1;
+            desc->bHubContrCurrent = 0;
+            desc->u.hs.DeviceRemovable[0] = 0;
+            desc->u.hs.DeviceRemovable[1] = 0xff;
+            break;
+        case GetHubStatus:
+            DEBUG_ROOT_HUB("OcteonUSB: GetHubStatus\n");
+            *(__le32 *)buf = 0;
+            break;
+        case GetPortStatus:
+            DEBUG_ROOT_HUB("OcteonUSB: GetPortStatus");
+            if (wIndex != 1)
+            {
+                DEBUG_ROOT_HUB(" INVALID\n");
+                return -EINVAL;
+            }
+
+            spin_lock_irqsave(&priv->lock, flags);
+            usb_port_status = cvmx_usb_get_status(&priv->usb);
+            spin_unlock_irqrestore(&priv->lock, flags);
+            port_status = 0;
+
+            if (usb_port_status.connect_change)
+            {
+                port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
+                DEBUG_ROOT_HUB(" C_CONNECTION");
+            }
+
+            if (usb_port_status.port_enabled)
+            {
+                port_status |= (1 << USB_PORT_FEAT_C_ENABLE);
+                DEBUG_ROOT_HUB(" C_ENABLE");
+            }
+
+            if (usb_port_status.connected)
+            {
+                port_status |= (1 << USB_PORT_FEAT_CONNECTION);
+                DEBUG_ROOT_HUB(" CONNECTION");
+            }
+
+            if (usb_port_status.port_enabled)
+            {
+                port_status |= (1 << USB_PORT_FEAT_ENABLE);
+                DEBUG_ROOT_HUB(" ENABLE");
+            }
+
+            if (usb_port_status.port_over_current)
+            {
+                port_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);
+                DEBUG_ROOT_HUB(" OVER_CURRENT");
+            }
+
+            if (usb_port_status.port_powered)
+            {
+                port_status |= (1 << USB_PORT_FEAT_POWER);
+                DEBUG_ROOT_HUB(" POWER");
+            }
+
+            if (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH)
+            {
+		port_status |= USB_PORT_STAT_HIGH_SPEED;
+                DEBUG_ROOT_HUB(" HIGHSPEED");
+            }
+            else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW)
+            {
+                port_status |= (1 << USB_PORT_FEAT_LOWSPEED);
+                DEBUG_ROOT_HUB(" LOWSPEED");
+            }
+
+            *((__le32 *)buf) = cpu_to_le32(port_status);
+            DEBUG_ROOT_HUB("\n");
+            break;
+        case SetHubFeature:
+            DEBUG_ROOT_HUB("OcteonUSB: SetHubFeature\n");
+            /* No HUB features supported */
+            break;
+        case SetPortFeature:
+            DEBUG_ROOT_HUB("OcteonUSB: SetPortFeature");
+            if (wIndex != 1)
+            {
+                DEBUG_ROOT_HUB(" INVALID\n");
+                return -EINVAL;
+            }
+
+            switch (wValue)
+            {
+                case USB_PORT_FEAT_SUSPEND:
+                    DEBUG_ROOT_HUB(" SUSPEND\n");
+                    return -EINVAL;
+                case USB_PORT_FEAT_POWER:
+                    DEBUG_ROOT_HUB(" POWER\n");
+                    return -EINVAL;
+                case USB_PORT_FEAT_RESET:
+                    DEBUG_ROOT_HUB(" RESET\n");
+                    spin_lock_irqsave(&priv->lock, flags);
+                    cvmx_usb_disable(&priv->usb);
+                    if (cvmx_usb_enable(&priv->usb))
+                        DEBUG_ERROR("Failed to enable the port\n");
+                    spin_unlock_irqrestore(&priv->lock, flags);
+                    return 0;
+                case USB_PORT_FEAT_INDICATOR:
+                    DEBUG_ROOT_HUB(" INDICATOR\n");
+                    /* Not supported */
+                    break;
+                default:
+                    DEBUG_ROOT_HUB(" UNKNOWN\n");
+                    return -EINVAL;
+            }
+            break;
+        default:
+            DEBUG_ROOT_HUB("OcteonUSB: Unknown root hub request\n");
+            return -EINVAL;
+    }
+    return 0;
+}
+
+
+static const struct hc_driver octeon_hc_driver = {
+    .description =      "Octeon USB",
+    .product_desc =     "Octeon Host Controller",
+    .hcd_priv_size =    sizeof(struct octeon_hcd),
+    .irq =              octeon_usb_irq,
+    .flags =            HCD_MEMORY | HCD_USB2,
+    .start =            octeon_usb_start,
+    .stop =             octeon_usb_stop,
+    .urb_enqueue =      octeon_usb_urb_enqueue,
+    .urb_dequeue =      octeon_usb_urb_dequeue,
+    .endpoint_disable = octeon_usb_endpoint_disable,
+    .get_frame_number = octeon_usb_get_frame_number,
+    .hub_status_data =  octeon_usb_hub_status_data,
+    .hub_control =      octeon_usb_hub_control,
+};
+
+
+static int octeon_usb_driver_probe(struct device *dev)
+{
+    int status;
+    int usb_num = to_platform_device(dev)->id;
+    int irq = platform_get_irq(to_platform_device(dev), 0);
+    struct octeon_hcd *priv;
+    struct usb_hcd *hcd;
+    unsigned long flags;
+
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
+    /* Set the DMA mask to 64bits so we get buffers already translated for
+        DMA */
+    dev->coherent_dma_mask = ~0;
+    dev->dma_mask = &dev->coherent_dma_mask;
+
+    hcd = usb_create_hcd(&octeon_hc_driver, dev, dev_name(dev));
+    if (!hcd)
+    {
+        DEBUG_FATAL("OcteonUSB: Failed to allocate memory for HCD\n");
+        return -1;
+    }
+    hcd->uses_new_polling = 1;
+    priv = (struct octeon_hcd *)hcd->hcd_priv;
+
+    spin_lock_init(&priv->lock);
+
+    tasklet_init(&priv->dequeue_tasklet, octeon_usb_urb_dequeue_work, (unsigned long)priv);
+    INIT_LIST_HEAD(&priv->dequeue_list);
+
+    //status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS | CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS);
+    status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO);
+    if (status)
+    {
+        DEBUG_FATAL("OcteonUSB: USB initialization failed with %d\n", status);
+        kfree(hcd);
+        return -1;
+    }
+
+    /* This delay is needed for CN3010, but I don't know why... */
+    mdelay(10);
+
+    spin_lock_irqsave(&priv->lock, flags);
+    cvmx_usb_poll(&priv->usb);
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    status = usb_add_hcd(hcd, irq, IRQF_SHARED);
+    if (status)
+    {
+        DEBUG_FATAL("OcteonUSB: USB add HCD failed with %d\n", status);
+        kfree(hcd);
+        return -1;
+    }
+
+    printk("OcteonUSB: Registered HCD for port %d on irq %d\n", usb_num, irq);
+
+    return 0;
+}
+
+static int octeon_usb_driver_remove(struct device *dev)
+{
+    int status;
+    struct usb_hcd *hcd = dev_get_drvdata(dev);
+    struct octeon_hcd *priv = hcd_to_octeon(hcd);
+    unsigned long flags;
+
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
+    usb_remove_hcd(hcd);
+    tasklet_kill(&priv->dequeue_tasklet);
+    spin_lock_irqsave(&priv->lock, flags);
+    status = cvmx_usb_shutdown(&priv->usb);
+    spin_unlock_irqrestore(&priv->lock, flags);
+    if (status)
+        DEBUG_FATAL("OcteonUSB: USB shutdown failed with %d\n", status);
+
+    kfree(hcd);
+
+    return 0;
+}
+
+static struct device_driver octeon_usb_driver = {
+    .name       = "OcteonUSB",
+    .bus        = &platform_bus_type,
+    .probe      = octeon_usb_driver_probe,
+    .remove     = octeon_usb_driver_remove,
+};
+
+
+#define MAX_USB_PORTS   10
+struct platform_device *pdev_glob[MAX_USB_PORTS];
+static int octeon_usb_registered;
+static int __init octeon_usb_module_init(void)
+{
+    int num_devices = cvmx_usb_get_num_ports();
+    int device;
+
+    if (usb_disabled() || num_devices == 0)
+	return -ENODEV;
+
+    if (driver_register(&octeon_usb_driver))
+    {
+        DEBUG_FATAL("OcteonUSB: Failed to register driver\n");
+        return -ENOMEM;
+    }
+    octeon_usb_registered = 1;
+    printk("OcteonUSB: Detected %d ports\n", num_devices);
+
+	/*
+	 * Only cn52XX and cn56XX have DWC_OTG USB hardware and the
+	 * IOB priority registers.  Under heavy network load USB
+	 * hardware can be starved by the IOB causing a crash.  Give
+	 * it a priority boost if it has been waiting more than 400
+	 * cycles to avoid this situation.
+	 *
+	 * Testing indicates that a cnt_val of 8192 is not sufficient,
+	 * but no failures are seen with 4096.  We choose a value of
+	 * 400 to give a safety factor of 10.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX)) {
+		union cvmx_iob_n2c_l2c_pri_cnt pri_cnt;
+
+		pri_cnt.u64 = 0;
+		pri_cnt.s.cnt_enb = 1;
+		pri_cnt.s.cnt_val = 400;
+		cvmx_write_csr(CVMX_IOB_N2C_L2C_PRI_CNT, pri_cnt.u64);
+	}
+
+    for (device = 0; device < num_devices; device++)
+    {
+        struct resource irq_resource;
+        struct platform_device *pdev;
+        memset(&irq_resource, 0, sizeof(irq_resource));
+        irq_resource.start = (device==0) ? OCTEON_IRQ_USB0 : OCTEON_IRQ_USB1;
+        irq_resource.end = irq_resource.start;
+        irq_resource.flags = IORESOURCE_IRQ;
+        pdev = platform_device_register_simple((char*)octeon_usb_driver.name, device, &irq_resource, 1);
+        if (!pdev)
+        {
+            DEBUG_FATAL("OcteonUSB: Failed to allocate platform device for USB%d\n", device);
+            return -ENOMEM;
+        }
+        if (device < MAX_USB_PORTS)
+            pdev_glob[device] = pdev;
+
+    }
+    return 0;
+}
+
+static void __exit octeon_usb_module_cleanup(void)
+{
+    int i;
+    DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+    for (i = 0; i <MAX_USB_PORTS; i++)
+        if (pdev_glob[i])
+        {
+            platform_device_unregister(pdev_glob[i]);
+            pdev_glob[i] = NULL;
+        }
+	if (octeon_usb_registered)
+		driver_unregister(&octeon_usb_driver);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium Networks <support@caviumnetworks.com>");
+MODULE_DESCRIPTION("Cavium Networks Octeon USB Host driver.");
+module_init(octeon_usb_module_init);
+module_exit(octeon_usb_module_cleanup);
