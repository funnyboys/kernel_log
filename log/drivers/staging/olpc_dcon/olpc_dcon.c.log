commit e40219d5e4b2177bfd4d885e7b64e3b236af40ac
Author: Jerry Lin <wahahab11@gmail.com>
Date:   Fri Sep 6 09:06:14 2019 +0800

    staging: olpc_dcon: allow simultaneous XO-1 and XO-1.5 support
    
    This patch remove model related configuration.
    Since the module can decide which platform data to use itself base on
    current running olpc board.
    
    Also change module dependency from (GPIO_CS5535 || GPIO_CS5535=n)
    to (GPIO_CS5535 || ACPI) because original one does not make any sense
    and module only doing real work when GPIO_CS5535 or ACPI is setted.
    
    Remove kernel configurations:
    - FB_OLPC_DCON_1
    - FB_OLPC_DCON_1_5
    
    Signed-off-by: Jerry Lin <wahahab11@gmail.com>
    Link: https://lore.kernel.org/r/20190906010613.GA562@compute1
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index a254238be181..a0d6d90f4cc8 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -790,15 +790,11 @@ static struct i2c_driver dcon_driver = {
 
 static int __init olpc_dcon_init(void)
 {
-#ifdef CONFIG_FB_OLPC_DCON_1_5
 	/* XO-1.5 */
 	if (olpc_board_at_least(olpc_board(0xd0)))
 		pdata = &dcon_pdata_xo_1_5;
-#endif
-#ifdef CONFIG_FB_OLPC_DCON_1
-	if (!pdata)
+	else
 		pdata = &dcon_pdata_xo_1;
-#endif
 
 	return i2c_add_driver(&dcon_driver);
 }

commit 9ef373923756b96680853d5b93578986dd07169a
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue May 28 11:02:45 2019 +0200

    staging/olpc: lock_fb_info can't fail
    
    Simply because olpc never unregisters the damn thing. It also
    registers the framebuffer directly by poking around in fbdev
    core internals, so it's all around rather broken.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jens Frederich <jfrederich@gmail.com>
    Cc: Daniel Drake <dsd@laptop.org>
    Cc: Jon Nettleton <jon.nettleton@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190528090304.9388-15-daniel.vetter@ffwll.ch

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 6b714f740ac3..a254238be181 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -250,11 +250,7 @@ static bool dcon_blank_fb(struct dcon_priv *dcon, bool blank)
 	int err;
 
 	console_lock();
-	if (!lock_fb_info(dcon->fbinfo)) {
-		console_unlock();
-		dev_err(&dcon->client->dev, "unable to lock framebuffer\n");
-		return false;
-	}
+	lock_fb_info(dcon->fbinfo);
 
 	dcon->ignore_fb_events = true;
 	err = fb_blank(dcon->fbinfo,

commit c28b6699acf85fb195aa93dcfdd648ce14e6c738
Author: Arkadiusz Lis <areklis909@gmail.com>
Date:   Wed Aug 8 17:42:29 2018 +0200

    Staging: One Laptop Per Child: fix SPDX-License-Identifier issue
    
    Add SPDX-License-Identifier to the source files.
    Remove redundant, old license.
    
    Signed-off-by: Arkadiusz Lis <areklis909@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 2744c9f0920e..6b714f740ac3 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Mainly by David Woodhouse, somewhat modified by Jordan Crouse
  *
@@ -5,10 +6,6 @@
  * Copyright © 2006-2007  Advanced Micro Devices, Inc.
  * Copyright © 2009       VIA Technology, Inc.
  * Copyright (c) 2010-2011  Andres Salomon <dilinger@queued.net>
- *
- * This program is free software.  You can redistribute it and/or
- * modify it under the terms of version 2 of the GNU General Public
- * License as published by the Free Software Foundation.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit 848d9eabcaebf21bf645efd26e8a8fa6d8e1fd62
Author: Zebulon McCorkle <zebmccorkle@zeb.fun>
Date:   Tue Nov 21 14:51:15 2017 -0600

    staging: olpc_dcon: Line up parentheses in func calls and defs
    
    Line up arguments to opening parentheses and ensure lines stay under 80
    columns, since checkpatch.pl was complaining about incorrect indentation
    in function calls and definitions.
    
    Signed-off-by: Zebulon McCorkle <zebmccorkle@zeb.fun>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 82bffd911435..2744c9f0920e 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -393,7 +393,8 @@ static void dcon_set_source_sync(struct dcon_priv *dcon, int arg)
 }
 
 static ssize_t dcon_mode_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
+			      struct device_attribute *attr,
+			      char *buf)
 {
 	struct dcon_priv *dcon = dev_get_drvdata(dev);
 
@@ -401,7 +402,8 @@ static ssize_t dcon_mode_show(struct device *dev,
 }
 
 static ssize_t dcon_sleep_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
+			       struct device_attribute *attr,
+			       char *buf)
 {
 	struct dcon_priv *dcon = dev_get_drvdata(dev);
 
@@ -409,7 +411,8 @@ static ssize_t dcon_sleep_show(struct device *dev,
 }
 
 static ssize_t dcon_freeze_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
+				struct device_attribute *attr,
+				char *buf)
 {
 	struct dcon_priv *dcon = dev_get_drvdata(dev);
 
@@ -417,7 +420,8 @@ static ssize_t dcon_freeze_show(struct device *dev,
 }
 
 static ssize_t dcon_mono_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
+			      struct device_attribute *attr,
+			      char *buf)
 {
 	struct dcon_priv *dcon = dev_get_drvdata(dev);
 
@@ -425,13 +429,15 @@ static ssize_t dcon_mono_show(struct device *dev,
 }
 
 static ssize_t dcon_resumeline_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
+				    struct device_attribute *attr,
+				    char *buf)
 {
 	return sprintf(buf, "%d\n", resumeline);
 }
 
 static ssize_t dcon_mono_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
 {
 	unsigned long enable_mono;
 	int rc;
@@ -446,7 +452,8 @@ static ssize_t dcon_mono_store(struct device *dev,
 }
 
 static ssize_t dcon_freeze_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
 {
 	struct dcon_priv *dcon = dev_get_drvdata(dev);
 	unsigned long output;
@@ -474,7 +481,8 @@ static ssize_t dcon_freeze_store(struct device *dev,
 }
 
 static ssize_t dcon_resumeline_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
 {
 	unsigned short rl;
 	int rc;
@@ -490,7 +498,8 @@ static ssize_t dcon_resumeline_store(struct device *dev,
 }
 
 static ssize_t dcon_sleep_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
+				struct device_attribute *attr,
+				const char *buf, size_t count)
 {
 	unsigned long output;
 	int ret;
@@ -641,7 +650,8 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	/* Add the backlight device for the DCON */
 	dcon_bl_props.brightness = dcon->bl_val;
 	dcon->bl_dev = backlight_device_register("dcon-bl", &dcon_device->dev,
-		dcon, &dcon_bl_ops, &dcon_bl_props);
+						 dcon, &dcon_bl_ops,
+						 &dcon_bl_props);
 	if (IS_ERR(dcon->bl_dev)) {
 		dev_err(&client->dev, "cannot register backlight dev (%ld)\n",
 			PTR_ERR(dcon->bl_dev));

commit 19e60c42caeb29b4584dc46e873955059859ba84
Author: Shurong Zhang <zhang_shurong@foxmail.com>
Date:   Thu Aug 24 23:33:10 2017 +0800

    staging: olpc_dcon: remove pointless debug printk in dcon_freeze_store()
    
    This printk doesn't really add anything worthwhile.
    
    Signed-off-by: Shurong Zhang <zhang_shurong@foxmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index f7f3a780ec10..82bffd911435 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -456,8 +456,6 @@ static ssize_t dcon_freeze_store(struct device *dev,
 	if (ret)
 		return ret;
 
-	pr_info("dcon_freeze_store: %lu\n", output);
-
 	switch (output) {
 	case 0:
 		dcon_set_source(dcon, DCON_SOURCE_CPU);

commit 0c8f4650eaef96794fe5d581e73968ad3050323f
Author: Dhananjay Balan <mail@dbalan.in>
Date:   Mon Apr 24 15:15:53 2017 +0200

    staging: olpc_dcon: style fixes
    
     removes hardcoded function name and uses __func__ to print info.
    
    Signed-off-by: Dhananjay Balan <mail@dbalan.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 684815c98789..f7f3a780ec10 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -290,7 +290,7 @@ static void dcon_source_switch(struct work_struct *work)
 
 	switch (source) {
 	case DCON_SOURCE_CPU:
-		pr_info("dcon_source_switch to CPU\n");
+		pr_info("%s to CPU\n", __func__);
 		/* Enable the scanline interrupt bit */
 		if (dcon_write(dcon, DCON_REG_MODE,
 			       dcon->disp_mode | MODE_SCAN_INT))
@@ -330,7 +330,7 @@ static void dcon_source_switch(struct work_struct *work)
 	{
 		ktime_t delta_t;
 
-		pr_info("dcon_source_switch to DCON\n");
+		pr_info("%s to DCON\n", __func__);
 
 		/* Clear DCONLOAD - this implies that the DCON is in control */
 		pdata->set_dconload(0);

commit 8862ce68a8e0a38a0ad93fadb1ae50e35e740e71
Author: Emmanuil Chatzipetru <chatzi.emanuel@gmail.com>
Date:   Sun Jan 8 14:37:06 2017 +0100

    staging: olpc_dcon: olpc_dcon: Fix spaces between operator and variables.
    
    This issue is caught by checkpatch.pl and is related to the following
    warning:
            - CHECK: spaces preferred around that '/' (ctx:VxV)
    
    Signed-off-by: Emmanuil Chatzipetru <chatzi.emanuel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index dcf89326580c..684815c98789 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -336,7 +336,7 @@ static void dcon_source_switch(struct work_struct *work)
 		pdata->set_dconload(0);
 		dcon->load_time = ktime_get();
 
-		wait_event_timeout(dcon->waitq, dcon->switched, HZ/2);
+		wait_event_timeout(dcon->waitq, dcon->switched, HZ / 2);
 
 		if (!dcon->switched) {
 			pr_err("Timeout entering DCON mode; expect a screen glitch.\n");

commit 5f6791ec5a0498a2ae562e410b91a2dc8b885962
Author: Emmanuil Chatzipetru <chatzi.emanuel@gmail.com>
Date:   Sun Jan 8 14:37:04 2017 +0100

    staging: olpc_dcon: olpc_dcon: Fix open parenthesis alignment.
    
    This issue is caught by checkpatch.pl and is related to the following
    warning:
            - CHECK: Alignment should match open parenthesis
    
    Signed-off-by: Emmanuil Chatzipetru <chatzi.emanuel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index f45b2ef05f48..dcf89326580c 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -81,7 +81,7 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 
 	if (ver < 0xdc02) {
 		dev_err(&dcon->client->dev,
-				"DCON v1 is unsupported, giving up..\n");
+			"DCON v1 is unsupported, giving up..\n");
 		rc = -ENODEV;
 		goto err;
 	}
@@ -90,7 +90,7 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 	dcon_write(dcon, 0x3a, 0xc040);
 	dcon_write(dcon, DCON_REG_MEM_OPT_A, 0x0000);  /* clear option bits */
 	dcon_write(dcon, DCON_REG_MEM_OPT_A,
-				MEM_DLL_CLOCK_DELAY | MEM_POWER_DOWN);
+		   MEM_DLL_CLOCK_DELAY | MEM_POWER_DOWN);
 	dcon_write(dcon, DCON_REG_MEM_OPT_B, MEM_SOFT_RESET);
 
 	/* Colour swizzle, AA, no passthrough, backlight */
@@ -261,14 +261,14 @@ static bool dcon_blank_fb(struct dcon_priv *dcon, bool blank)
 
 	dcon->ignore_fb_events = true;
 	err = fb_blank(dcon->fbinfo,
-			blank ? FB_BLANK_POWERDOWN : FB_BLANK_UNBLANK);
+		       blank ? FB_BLANK_POWERDOWN : FB_BLANK_UNBLANK);
 	dcon->ignore_fb_events = false;
 	unlock_fb_info(dcon->fbinfo);
 	console_unlock();
 
 	if (err) {
 		dev_err(&dcon->client->dev, "couldn't %sblank framebuffer\n",
-				blank ? "" : "un");
+			blank ? "" : "un");
 		return false;
 	}
 	return true;
@@ -293,7 +293,7 @@ static void dcon_source_switch(struct work_struct *work)
 		pr_info("dcon_source_switch to CPU\n");
 		/* Enable the scanline interrupt bit */
 		if (dcon_write(dcon, DCON_REG_MODE,
-				dcon->disp_mode | MODE_SCAN_INT))
+			       dcon->disp_mode | MODE_SCAN_INT))
 			pr_err("couldn't enable scanline interrupt!\n");
 		else
 			/* Wait up to one second for the scanline interrupt */
@@ -646,7 +646,7 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		dcon, &dcon_bl_ops, &dcon_bl_props);
 	if (IS_ERR(dcon->bl_dev)) {
 		dev_err(&client->dev, "cannot register backlight dev (%ld)\n",
-				PTR_ERR(dcon->bl_dev));
+			PTR_ERR(dcon->bl_dev));
 		dcon->bl_dev = NULL;
 	}
 

commit 53c43c5ca13328ac8f415aa2251791b441a12b51
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Apr 4 13:52:35 2016 -0700

    Revert "Staging: olpc_dcon: Remove obsolete driver"
    
    This reverts commit 82ef33af9dd30075adbd9f3dd161b606b8ba88ac.  It turns
    out these machines are still out there, and the original patch broke
    them.  So revert it, adding back the driver, so people's machines still
    work properly.
    
    Reported-by: James Cameron <quozl@laptop.org>
    Cc: Shraddha Barke <shraddha.6596@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
new file mode 100644
index 000000000000..f45b2ef05f48
--- /dev/null
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -0,0 +1,813 @@
+/*
+ * Mainly by David Woodhouse, somewhat modified by Jordan Crouse
+ *
+ * Copyright © 2006-2007  Red Hat, Inc.
+ * Copyright © 2006-2007  Advanced Micro Devices, Inc.
+ * Copyright © 2009       VIA Technology, Inc.
+ * Copyright (c) 2010-2011  Andres Salomon <dilinger@queued.net>
+ *
+ * This program is free software.  You can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/backlight.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/ctype.h>
+#include <linux/reboot.h>
+#include <linux/olpc-ec.h>
+#include <asm/tsc.h>
+#include <asm/olpc.h>
+
+#include "olpc_dcon.h"
+
+/* Module definitions */
+
+static ushort resumeline = 898;
+module_param(resumeline, ushort, 0444);
+
+static struct dcon_platform_data *pdata;
+
+/* I2C structures */
+
+/* Platform devices */
+static struct platform_device *dcon_device;
+
+static unsigned short normal_i2c[] = { 0x0d, I2C_CLIENT_END };
+
+static s32 dcon_write(struct dcon_priv *dcon, u8 reg, u16 val)
+{
+	return i2c_smbus_write_word_data(dcon->client, reg, val);
+}
+
+static s32 dcon_read(struct dcon_priv *dcon, u8 reg)
+{
+	return i2c_smbus_read_word_data(dcon->client, reg);
+}
+
+/* ===== API functions - these are called by a variety of users ==== */
+
+static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
+{
+	u16 ver;
+	int rc = 0;
+
+	ver = dcon_read(dcon, DCON_REG_ID);
+	if ((ver >> 8) != 0xDC) {
+		pr_err("DCON ID not 0xDCxx: 0x%04x instead.\n", ver);
+		rc = -ENXIO;
+		goto err;
+	}
+
+	if (is_init) {
+		pr_info("Discovered DCON version %x\n", ver & 0xFF);
+		rc = pdata->init(dcon);
+		if (rc != 0) {
+			pr_err("Unable to init.\n");
+			goto err;
+		}
+	}
+
+	if (ver < 0xdc02) {
+		dev_err(&dcon->client->dev,
+				"DCON v1 is unsupported, giving up..\n");
+		rc = -ENODEV;
+		goto err;
+	}
+
+	/* SDRAM setup/hold time */
+	dcon_write(dcon, 0x3a, 0xc040);
+	dcon_write(dcon, DCON_REG_MEM_OPT_A, 0x0000);  /* clear option bits */
+	dcon_write(dcon, DCON_REG_MEM_OPT_A,
+				MEM_DLL_CLOCK_DELAY | MEM_POWER_DOWN);
+	dcon_write(dcon, DCON_REG_MEM_OPT_B, MEM_SOFT_RESET);
+
+	/* Colour swizzle, AA, no passthrough, backlight */
+	if (is_init) {
+		dcon->disp_mode = MODE_PASSTHRU | MODE_BL_ENABLE |
+				MODE_CSWIZZLE | MODE_COL_AA;
+	}
+	dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
+
+	/* Set the scanline to interrupt on during resume */
+	dcon_write(dcon, DCON_REG_SCAN_INT, resumeline);
+
+err:
+	return rc;
+}
+
+/*
+ * The smbus doesn't always come back due to what is believed to be
+ * hardware (power rail) bugs.  For older models where this is known to
+ * occur, our solution is to attempt to wait for the bus to stabilize;
+ * if it doesn't happen, cut power to the dcon, repower it, and wait
+ * for the bus to stabilize.  Rinse, repeat until we have a working
+ * smbus.  For newer models, we simply BUG(); we want to know if this
+ * still happens despite the power fixes that have been made!
+ */
+static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
+{
+	unsigned long timeout;
+	u8 pm;
+	int x;
+
+power_up:
+	if (is_powered_down) {
+		pm = 1;
+		x = olpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);
+		if (x) {
+			pr_warn("unable to force dcon to power up: %d!\n", x);
+			return x;
+		}
+		usleep_range(10000, 11000);  /* we'll be conservative */
+	}
+
+	pdata->bus_stabilize_wiggle();
+
+	for (x = -1, timeout = 50; timeout && x < 0; timeout--) {
+		usleep_range(1000, 1100);
+		x = dcon_read(dcon, DCON_REG_ID);
+	}
+	if (x < 0) {
+		pr_err("unable to stabilize dcon's smbus, reasserting power and praying.\n");
+		BUG_ON(olpc_board_at_least(olpc_board(0xc2)));
+		pm = 0;
+		olpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);
+		msleep(100);
+		is_powered_down = 1;
+		goto power_up;	/* argh, stupid hardware.. */
+	}
+
+	if (is_powered_down)
+		return dcon_hw_init(dcon, 0);
+	return 0;
+}
+
+static void dcon_set_backlight(struct dcon_priv *dcon, u8 level)
+{
+	dcon->bl_val = level;
+	dcon_write(dcon, DCON_REG_BRIGHT, dcon->bl_val);
+
+	/* Purposely turn off the backlight when we go to level 0 */
+	if (dcon->bl_val == 0) {
+		dcon->disp_mode &= ~MODE_BL_ENABLE;
+		dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
+	} else if (!(dcon->disp_mode & MODE_BL_ENABLE)) {
+		dcon->disp_mode |= MODE_BL_ENABLE;
+		dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
+	}
+}
+
+/* Set the output type to either color or mono */
+static int dcon_set_mono_mode(struct dcon_priv *dcon, bool enable_mono)
+{
+	if (dcon->mono == enable_mono)
+		return 0;
+
+	dcon->mono = enable_mono;
+
+	if (enable_mono) {
+		dcon->disp_mode &= ~(MODE_CSWIZZLE | MODE_COL_AA);
+		dcon->disp_mode |= MODE_MONO_LUMA;
+	} else {
+		dcon->disp_mode &= ~(MODE_MONO_LUMA);
+		dcon->disp_mode |= MODE_CSWIZZLE | MODE_COL_AA;
+	}
+
+	dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
+	return 0;
+}
+
+/* For now, this will be really stupid - we need to address how
+ * DCONLOAD works in a sleep and account for it accordingly
+ */
+
+static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
+{
+	int x;
+
+	/* Turn off the backlight and put the DCON to sleep */
+
+	if (dcon->asleep == sleep)
+		return;
+
+	if (!olpc_board_at_least(olpc_board(0xc2)))
+		return;
+
+	if (sleep) {
+		u8 pm = 0;
+
+		x = olpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);
+		if (x)
+			pr_warn("unable to force dcon to power down: %d!\n", x);
+		else
+			dcon->asleep = sleep;
+	} else {
+		/* Only re-enable the backlight if the backlight value is set */
+		if (dcon->bl_val != 0)
+			dcon->disp_mode |= MODE_BL_ENABLE;
+		x = dcon_bus_stabilize(dcon, 1);
+		if (x)
+			pr_warn("unable to reinit dcon hardware: %d!\n", x);
+		else
+			dcon->asleep = sleep;
+
+		/* Restore backlight */
+		dcon_set_backlight(dcon, dcon->bl_val);
+	}
+
+	/* We should turn off some stuff in the framebuffer - but what? */
+}
+
+/* the DCON seems to get confused if we change DCONLOAD too
+ * frequently -- i.e., approximately faster than frame time.
+ * normally we don't change it this fast, so in general we won't
+ * delay here.
+ */
+static void dcon_load_holdoff(struct dcon_priv *dcon)
+{
+	ktime_t delta_t, now;
+
+	while (1) {
+		now = ktime_get();
+		delta_t = ktime_sub(now, dcon->load_time);
+		if (ktime_to_ns(delta_t) > NSEC_PER_MSEC * 20)
+			break;
+		mdelay(4);
+	}
+}
+
+static bool dcon_blank_fb(struct dcon_priv *dcon, bool blank)
+{
+	int err;
+
+	console_lock();
+	if (!lock_fb_info(dcon->fbinfo)) {
+		console_unlock();
+		dev_err(&dcon->client->dev, "unable to lock framebuffer\n");
+		return false;
+	}
+
+	dcon->ignore_fb_events = true;
+	err = fb_blank(dcon->fbinfo,
+			blank ? FB_BLANK_POWERDOWN : FB_BLANK_UNBLANK);
+	dcon->ignore_fb_events = false;
+	unlock_fb_info(dcon->fbinfo);
+	console_unlock();
+
+	if (err) {
+		dev_err(&dcon->client->dev, "couldn't %sblank framebuffer\n",
+				blank ? "" : "un");
+		return false;
+	}
+	return true;
+}
+
+/* Set the source of the display (CPU or DCON) */
+static void dcon_source_switch(struct work_struct *work)
+{
+	struct dcon_priv *dcon = container_of(work, struct dcon_priv,
+			switch_source);
+	int source = dcon->pending_src;
+
+	if (dcon->curr_src == source)
+		return;
+
+	dcon_load_holdoff(dcon);
+
+	dcon->switched = false;
+
+	switch (source) {
+	case DCON_SOURCE_CPU:
+		pr_info("dcon_source_switch to CPU\n");
+		/* Enable the scanline interrupt bit */
+		if (dcon_write(dcon, DCON_REG_MODE,
+				dcon->disp_mode | MODE_SCAN_INT))
+			pr_err("couldn't enable scanline interrupt!\n");
+		else
+			/* Wait up to one second for the scanline interrupt */
+			wait_event_timeout(dcon->waitq, dcon->switched, HZ);
+
+		if (!dcon->switched)
+			pr_err("Timeout entering CPU mode; expect a screen glitch.\n");
+
+		/* Turn off the scanline interrupt */
+		if (dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode))
+			pr_err("couldn't disable scanline interrupt!\n");
+
+		/*
+		 * Ideally we'd like to disable interrupts here so that the
+		 * fb unblanking and DCON turn on happen at a known time value;
+		 * however, we can't do that right now with fb_blank
+		 * messing with semaphores.
+		 *
+		 * For now, we just hope..
+		 */
+		if (!dcon_blank_fb(dcon, false)) {
+			pr_err("Failed to enter CPU mode\n");
+			dcon->pending_src = DCON_SOURCE_DCON;
+			return;
+		}
+
+		/* And turn off the DCON */
+		pdata->set_dconload(1);
+		dcon->load_time = ktime_get();
+
+		pr_info("The CPU has control\n");
+		break;
+	case DCON_SOURCE_DCON:
+	{
+		ktime_t delta_t;
+
+		pr_info("dcon_source_switch to DCON\n");
+
+		/* Clear DCONLOAD - this implies that the DCON is in control */
+		pdata->set_dconload(0);
+		dcon->load_time = ktime_get();
+
+		wait_event_timeout(dcon->waitq, dcon->switched, HZ/2);
+
+		if (!dcon->switched) {
+			pr_err("Timeout entering DCON mode; expect a screen glitch.\n");
+		} else {
+			/* sometimes the DCON doesn't follow its own rules,
+			 * and doesn't wait for two vsync pulses before
+			 * ack'ing the frame load with an IRQ.  the result
+			 * is that the display shows the *previously*
+			 * loaded frame.  we can detect this by looking at
+			 * the time between asserting DCONLOAD and the IRQ --
+			 * if it's less than 20msec, then the DCON couldn't
+			 * have seen two VSYNC pulses.  in that case we
+			 * deassert and reassert, and hope for the best.
+			 * see http://dev.laptop.org/ticket/9664
+			 */
+			delta_t = ktime_sub(dcon->irq_time, dcon->load_time);
+			if (dcon->switched && ktime_to_ns(delta_t)
+			    < NSEC_PER_MSEC * 20) {
+				pr_err("missed loading, retrying\n");
+				pdata->set_dconload(1);
+				mdelay(41);
+				pdata->set_dconload(0);
+				dcon->load_time = ktime_get();
+				mdelay(41);
+			}
+		}
+
+		dcon_blank_fb(dcon, true);
+		pr_info("The DCON has control\n");
+		break;
+	}
+	default:
+		BUG();
+	}
+
+	dcon->curr_src = source;
+}
+
+static void dcon_set_source(struct dcon_priv *dcon, int arg)
+{
+	if (dcon->pending_src == arg)
+		return;
+
+	dcon->pending_src = arg;
+
+	if (dcon->curr_src != arg)
+		schedule_work(&dcon->switch_source);
+}
+
+static void dcon_set_source_sync(struct dcon_priv *dcon, int arg)
+{
+	dcon_set_source(dcon, arg);
+	flush_scheduled_work();
+}
+
+static ssize_t dcon_mode_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct dcon_priv *dcon = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%4.4X\n", dcon->disp_mode);
+}
+
+static ssize_t dcon_sleep_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct dcon_priv *dcon = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", dcon->asleep);
+}
+
+static ssize_t dcon_freeze_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct dcon_priv *dcon = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", dcon->curr_src == DCON_SOURCE_DCON ? 1 : 0);
+}
+
+static ssize_t dcon_mono_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct dcon_priv *dcon = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", dcon->mono);
+}
+
+static ssize_t dcon_resumeline_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", resumeline);
+}
+
+static ssize_t dcon_mono_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long enable_mono;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &enable_mono);
+	if (rc)
+		return rc;
+
+	dcon_set_mono_mode(dev_get_drvdata(dev), enable_mono ? true : false);
+
+	return count;
+}
+
+static ssize_t dcon_freeze_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct dcon_priv *dcon = dev_get_drvdata(dev);
+	unsigned long output;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &output);
+	if (ret)
+		return ret;
+
+	pr_info("dcon_freeze_store: %lu\n", output);
+
+	switch (output) {
+	case 0:
+		dcon_set_source(dcon, DCON_SOURCE_CPU);
+		break;
+	case 1:
+		dcon_set_source_sync(dcon, DCON_SOURCE_DCON);
+		break;
+	case 2:  /* normally unused */
+		dcon_set_source(dcon, DCON_SOURCE_DCON);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static ssize_t dcon_resumeline_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned short rl;
+	int rc;
+
+	rc = kstrtou16(buf, 10, &rl);
+	if (rc)
+		return rc;
+
+	resumeline = rl;
+	dcon_write(dev_get_drvdata(dev), DCON_REG_SCAN_INT, resumeline);
+
+	return count;
+}
+
+static ssize_t dcon_sleep_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long output;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &output);
+	if (ret)
+		return ret;
+
+	dcon_sleep(dev_get_drvdata(dev), output ? true : false);
+	return count;
+}
+
+static struct device_attribute dcon_device_files[] = {
+	__ATTR(mode, 0444, dcon_mode_show, NULL),
+	__ATTR(sleep, 0644, dcon_sleep_show, dcon_sleep_store),
+	__ATTR(freeze, 0644, dcon_freeze_show, dcon_freeze_store),
+	__ATTR(monochrome, 0644, dcon_mono_show, dcon_mono_store),
+	__ATTR(resumeline, 0644, dcon_resumeline_show, dcon_resumeline_store),
+};
+
+static int dcon_bl_update(struct backlight_device *dev)
+{
+	struct dcon_priv *dcon = bl_get_data(dev);
+	u8 level = dev->props.brightness & 0x0F;
+
+	if (dev->props.power != FB_BLANK_UNBLANK)
+		level = 0;
+
+	if (level != dcon->bl_val)
+		dcon_set_backlight(dcon, level);
+
+	/* power down the DCON when the screen is blanked */
+	if (!dcon->ignore_fb_events)
+		dcon_sleep(dcon, !!(dev->props.state & BL_CORE_FBBLANK));
+
+	return 0;
+}
+
+static int dcon_bl_get(struct backlight_device *dev)
+{
+	struct dcon_priv *dcon = bl_get_data(dev);
+
+	return dcon->bl_val;
+}
+
+static const struct backlight_ops dcon_bl_ops = {
+	.update_status = dcon_bl_update,
+	.get_brightness = dcon_bl_get,
+};
+
+static struct backlight_properties dcon_bl_props = {
+	.max_brightness = 15,
+	.type = BACKLIGHT_RAW,
+	.power = FB_BLANK_UNBLANK,
+};
+
+static int dcon_reboot_notify(struct notifier_block *nb,
+			      unsigned long foo, void *bar)
+{
+	struct dcon_priv *dcon = container_of(nb, struct dcon_priv, reboot_nb);
+
+	if (!dcon || !dcon->client)
+		return NOTIFY_DONE;
+
+	/* Turn off the DCON. Entirely. */
+	dcon_write(dcon, DCON_REG_MODE, 0x39);
+	dcon_write(dcon, DCON_REG_MODE, 0x32);
+	return NOTIFY_DONE;
+}
+
+static int unfreeze_on_panic(struct notifier_block *nb,
+			     unsigned long e, void *p)
+{
+	pdata->set_dconload(1);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block dcon_panic_nb = {
+	.notifier_call = unfreeze_on_panic,
+};
+
+static int dcon_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	strlcpy(info->type, "olpc_dcon", I2C_NAME_SIZE);
+
+	return 0;
+}
+
+static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct dcon_priv *dcon;
+	int rc, i, j;
+
+	if (!pdata)
+		return -ENXIO;
+
+	dcon = kzalloc(sizeof(*dcon), GFP_KERNEL);
+	if (!dcon)
+		return -ENOMEM;
+
+	dcon->client = client;
+	init_waitqueue_head(&dcon->waitq);
+	INIT_WORK(&dcon->switch_source, dcon_source_switch);
+	dcon->reboot_nb.notifier_call = dcon_reboot_notify;
+	dcon->reboot_nb.priority = -1;
+
+	i2c_set_clientdata(client, dcon);
+
+	if (num_registered_fb < 1) {
+		dev_err(&client->dev, "DCON driver requires a registered fb\n");
+		rc = -EIO;
+		goto einit;
+	}
+	dcon->fbinfo = registered_fb[0];
+
+	rc = dcon_hw_init(dcon, 1);
+	if (rc)
+		goto einit;
+
+	/* Add the DCON device */
+
+	dcon_device = platform_device_alloc("dcon", -1);
+
+	if (!dcon_device) {
+		pr_err("Unable to create the DCON device\n");
+		rc = -ENOMEM;
+		goto eirq;
+	}
+	rc = platform_device_add(dcon_device);
+	platform_set_drvdata(dcon_device, dcon);
+
+	if (rc) {
+		pr_err("Unable to add the DCON device\n");
+		goto edev;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(dcon_device_files); i++) {
+		rc = device_create_file(&dcon_device->dev,
+					&dcon_device_files[i]);
+		if (rc) {
+			dev_err(&dcon_device->dev, "Cannot create sysfs file\n");
+			goto ecreate;
+		}
+	}
+
+	dcon->bl_val = dcon_read(dcon, DCON_REG_BRIGHT) & 0x0F;
+
+	/* Add the backlight device for the DCON */
+	dcon_bl_props.brightness = dcon->bl_val;
+	dcon->bl_dev = backlight_device_register("dcon-bl", &dcon_device->dev,
+		dcon, &dcon_bl_ops, &dcon_bl_props);
+	if (IS_ERR(dcon->bl_dev)) {
+		dev_err(&client->dev, "cannot register backlight dev (%ld)\n",
+				PTR_ERR(dcon->bl_dev));
+		dcon->bl_dev = NULL;
+	}
+
+	register_reboot_notifier(&dcon->reboot_nb);
+	atomic_notifier_chain_register(&panic_notifier_list, &dcon_panic_nb);
+
+	return 0;
+
+ ecreate:
+	for (j = 0; j < i; j++)
+		device_remove_file(&dcon_device->dev, &dcon_device_files[j]);
+ edev:
+	platform_device_unregister(dcon_device);
+	dcon_device = NULL;
+ eirq:
+	free_irq(DCON_IRQ, dcon);
+ einit:
+	kfree(dcon);
+	return rc;
+}
+
+static int dcon_remove(struct i2c_client *client)
+{
+	struct dcon_priv *dcon = i2c_get_clientdata(client);
+
+	unregister_reboot_notifier(&dcon->reboot_nb);
+	atomic_notifier_chain_unregister(&panic_notifier_list, &dcon_panic_nb);
+
+	free_irq(DCON_IRQ, dcon);
+
+	backlight_device_unregister(dcon->bl_dev);
+
+	if (dcon_device)
+		platform_device_unregister(dcon_device);
+	cancel_work_sync(&dcon->switch_source);
+
+	kfree(dcon);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int dcon_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct dcon_priv *dcon = i2c_get_clientdata(client);
+
+	if (!dcon->asleep) {
+		/* Set up the DCON to have the source */
+		dcon_set_source_sync(dcon, DCON_SOURCE_DCON);
+	}
+
+	return 0;
+}
+
+static int dcon_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct dcon_priv *dcon = i2c_get_clientdata(client);
+
+	if (!dcon->asleep) {
+		dcon_bus_stabilize(dcon, 0);
+		dcon_set_source(dcon, DCON_SOURCE_CPU);
+	}
+
+	return 0;
+}
+
+#else
+
+#define dcon_suspend NULL
+#define dcon_resume NULL
+
+#endif /* CONFIG_PM */
+
+irqreturn_t dcon_interrupt(int irq, void *id)
+{
+	struct dcon_priv *dcon = id;
+	u8 status;
+
+	if (pdata->read_status(&status))
+		return IRQ_NONE;
+
+	switch (status & 3) {
+	case 3:
+		pr_debug("DCONLOAD_MISSED interrupt\n");
+		break;
+
+	case 2:	/* switch to DCON mode */
+	case 1: /* switch to CPU mode */
+		dcon->switched = true;
+		dcon->irq_time = ktime_get();
+		wake_up(&dcon->waitq);
+		break;
+
+	case 0:
+		/* workaround resume case:  the DCON (on 1.5) doesn't
+		 * ever assert status 0x01 when switching to CPU mode
+		 * during resume.  this is because DCONLOAD is de-asserted
+		 * _immediately_ upon exiting S3, so the actual release
+		 * of the DCON happened long before this point.
+		 * see http://dev.laptop.org/ticket/9869
+		 */
+		if (dcon->curr_src != dcon->pending_src && !dcon->switched) {
+			dcon->switched = true;
+			dcon->irq_time = ktime_get();
+			wake_up(&dcon->waitq);
+			pr_debug("switching w/ status 0/0\n");
+		} else {
+			pr_debug("scanline interrupt w/CPU\n");
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static const struct dev_pm_ops dcon_pm_ops = {
+	.suspend = dcon_suspend,
+	.resume = dcon_resume,
+};
+
+static const struct i2c_device_id dcon_idtable[] = {
+	{ "olpc_dcon",  0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, dcon_idtable);
+
+static struct i2c_driver dcon_driver = {
+	.driver = {
+		.name	= "olpc_dcon",
+		.pm = &dcon_pm_ops,
+	},
+	.class = I2C_CLASS_DDC | I2C_CLASS_HWMON,
+	.id_table = dcon_idtable,
+	.probe = dcon_probe,
+	.remove = dcon_remove,
+	.detect = dcon_detect,
+	.address_list = normal_i2c,
+};
+
+static int __init olpc_dcon_init(void)
+{
+#ifdef CONFIG_FB_OLPC_DCON_1_5
+	/* XO-1.5 */
+	if (olpc_board_at_least(olpc_board(0xd0)))
+		pdata = &dcon_pdata_xo_1_5;
+#endif
+#ifdef CONFIG_FB_OLPC_DCON_1
+	if (!pdata)
+		pdata = &dcon_pdata_xo_1;
+#endif
+
+	return i2c_add_driver(&dcon_driver);
+}
+
+static void __exit olpc_dcon_exit(void)
+{
+	i2c_del_driver(&dcon_driver);
+}
+
+module_init(olpc_dcon_init);
+module_exit(olpc_dcon_exit);
+
+MODULE_LICENSE("GPL");

commit 82ef33af9dd30075adbd9f3dd161b606b8ba88ac
Author: Shraddha Barke <shraddha.6596@gmail.com>
Date:   Sat Dec 26 16:44:34 2015 +0530

    Staging: olpc_dcon: Remove obsolete driver
    
    Remove support for One Laptop Per Child organization since it is dead.
    http://www.olpcnews.com/about_olpc_news/goodbye_one_laptop_per_child.html
    
    Signed-off-by: Shraddha Barke <shraddha.6596@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
deleted file mode 100644
index f45b2ef05f48..000000000000
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ /dev/null
@@ -1,813 +0,0 @@
-/*
- * Mainly by David Woodhouse, somewhat modified by Jordan Crouse
- *
- * Copyright © 2006-2007  Red Hat, Inc.
- * Copyright © 2006-2007  Advanced Micro Devices, Inc.
- * Copyright © 2009       VIA Technology, Inc.
- * Copyright (c) 2010-2011  Andres Salomon <dilinger@queued.net>
- *
- * This program is free software.  You can redistribute it and/or
- * modify it under the terms of version 2 of the GNU General Public
- * License as published by the Free Software Foundation.
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/kernel.h>
-#include <linux/fb.h>
-#include <linux/console.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/delay.h>
-#include <linux/module.h>
-#include <linux/backlight.h>
-#include <linux/device.h>
-#include <linux/uaccess.h>
-#include <linux/ctype.h>
-#include <linux/reboot.h>
-#include <linux/olpc-ec.h>
-#include <asm/tsc.h>
-#include <asm/olpc.h>
-
-#include "olpc_dcon.h"
-
-/* Module definitions */
-
-static ushort resumeline = 898;
-module_param(resumeline, ushort, 0444);
-
-static struct dcon_platform_data *pdata;
-
-/* I2C structures */
-
-/* Platform devices */
-static struct platform_device *dcon_device;
-
-static unsigned short normal_i2c[] = { 0x0d, I2C_CLIENT_END };
-
-static s32 dcon_write(struct dcon_priv *dcon, u8 reg, u16 val)
-{
-	return i2c_smbus_write_word_data(dcon->client, reg, val);
-}
-
-static s32 dcon_read(struct dcon_priv *dcon, u8 reg)
-{
-	return i2c_smbus_read_word_data(dcon->client, reg);
-}
-
-/* ===== API functions - these are called by a variety of users ==== */
-
-static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
-{
-	u16 ver;
-	int rc = 0;
-
-	ver = dcon_read(dcon, DCON_REG_ID);
-	if ((ver >> 8) != 0xDC) {
-		pr_err("DCON ID not 0xDCxx: 0x%04x instead.\n", ver);
-		rc = -ENXIO;
-		goto err;
-	}
-
-	if (is_init) {
-		pr_info("Discovered DCON version %x\n", ver & 0xFF);
-		rc = pdata->init(dcon);
-		if (rc != 0) {
-			pr_err("Unable to init.\n");
-			goto err;
-		}
-	}
-
-	if (ver < 0xdc02) {
-		dev_err(&dcon->client->dev,
-				"DCON v1 is unsupported, giving up..\n");
-		rc = -ENODEV;
-		goto err;
-	}
-
-	/* SDRAM setup/hold time */
-	dcon_write(dcon, 0x3a, 0xc040);
-	dcon_write(dcon, DCON_REG_MEM_OPT_A, 0x0000);  /* clear option bits */
-	dcon_write(dcon, DCON_REG_MEM_OPT_A,
-				MEM_DLL_CLOCK_DELAY | MEM_POWER_DOWN);
-	dcon_write(dcon, DCON_REG_MEM_OPT_B, MEM_SOFT_RESET);
-
-	/* Colour swizzle, AA, no passthrough, backlight */
-	if (is_init) {
-		dcon->disp_mode = MODE_PASSTHRU | MODE_BL_ENABLE |
-				MODE_CSWIZZLE | MODE_COL_AA;
-	}
-	dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
-
-	/* Set the scanline to interrupt on during resume */
-	dcon_write(dcon, DCON_REG_SCAN_INT, resumeline);
-
-err:
-	return rc;
-}
-
-/*
- * The smbus doesn't always come back due to what is believed to be
- * hardware (power rail) bugs.  For older models where this is known to
- * occur, our solution is to attempt to wait for the bus to stabilize;
- * if it doesn't happen, cut power to the dcon, repower it, and wait
- * for the bus to stabilize.  Rinse, repeat until we have a working
- * smbus.  For newer models, we simply BUG(); we want to know if this
- * still happens despite the power fixes that have been made!
- */
-static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
-{
-	unsigned long timeout;
-	u8 pm;
-	int x;
-
-power_up:
-	if (is_powered_down) {
-		pm = 1;
-		x = olpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);
-		if (x) {
-			pr_warn("unable to force dcon to power up: %d!\n", x);
-			return x;
-		}
-		usleep_range(10000, 11000);  /* we'll be conservative */
-	}
-
-	pdata->bus_stabilize_wiggle();
-
-	for (x = -1, timeout = 50; timeout && x < 0; timeout--) {
-		usleep_range(1000, 1100);
-		x = dcon_read(dcon, DCON_REG_ID);
-	}
-	if (x < 0) {
-		pr_err("unable to stabilize dcon's smbus, reasserting power and praying.\n");
-		BUG_ON(olpc_board_at_least(olpc_board(0xc2)));
-		pm = 0;
-		olpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);
-		msleep(100);
-		is_powered_down = 1;
-		goto power_up;	/* argh, stupid hardware.. */
-	}
-
-	if (is_powered_down)
-		return dcon_hw_init(dcon, 0);
-	return 0;
-}
-
-static void dcon_set_backlight(struct dcon_priv *dcon, u8 level)
-{
-	dcon->bl_val = level;
-	dcon_write(dcon, DCON_REG_BRIGHT, dcon->bl_val);
-
-	/* Purposely turn off the backlight when we go to level 0 */
-	if (dcon->bl_val == 0) {
-		dcon->disp_mode &= ~MODE_BL_ENABLE;
-		dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
-	} else if (!(dcon->disp_mode & MODE_BL_ENABLE)) {
-		dcon->disp_mode |= MODE_BL_ENABLE;
-		dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
-	}
-}
-
-/* Set the output type to either color or mono */
-static int dcon_set_mono_mode(struct dcon_priv *dcon, bool enable_mono)
-{
-	if (dcon->mono == enable_mono)
-		return 0;
-
-	dcon->mono = enable_mono;
-
-	if (enable_mono) {
-		dcon->disp_mode &= ~(MODE_CSWIZZLE | MODE_COL_AA);
-		dcon->disp_mode |= MODE_MONO_LUMA;
-	} else {
-		dcon->disp_mode &= ~(MODE_MONO_LUMA);
-		dcon->disp_mode |= MODE_CSWIZZLE | MODE_COL_AA;
-	}
-
-	dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
-	return 0;
-}
-
-/* For now, this will be really stupid - we need to address how
- * DCONLOAD works in a sleep and account for it accordingly
- */
-
-static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
-{
-	int x;
-
-	/* Turn off the backlight and put the DCON to sleep */
-
-	if (dcon->asleep == sleep)
-		return;
-
-	if (!olpc_board_at_least(olpc_board(0xc2)))
-		return;
-
-	if (sleep) {
-		u8 pm = 0;
-
-		x = olpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);
-		if (x)
-			pr_warn("unable to force dcon to power down: %d!\n", x);
-		else
-			dcon->asleep = sleep;
-	} else {
-		/* Only re-enable the backlight if the backlight value is set */
-		if (dcon->bl_val != 0)
-			dcon->disp_mode |= MODE_BL_ENABLE;
-		x = dcon_bus_stabilize(dcon, 1);
-		if (x)
-			pr_warn("unable to reinit dcon hardware: %d!\n", x);
-		else
-			dcon->asleep = sleep;
-
-		/* Restore backlight */
-		dcon_set_backlight(dcon, dcon->bl_val);
-	}
-
-	/* We should turn off some stuff in the framebuffer - but what? */
-}
-
-/* the DCON seems to get confused if we change DCONLOAD too
- * frequently -- i.e., approximately faster than frame time.
- * normally we don't change it this fast, so in general we won't
- * delay here.
- */
-static void dcon_load_holdoff(struct dcon_priv *dcon)
-{
-	ktime_t delta_t, now;
-
-	while (1) {
-		now = ktime_get();
-		delta_t = ktime_sub(now, dcon->load_time);
-		if (ktime_to_ns(delta_t) > NSEC_PER_MSEC * 20)
-			break;
-		mdelay(4);
-	}
-}
-
-static bool dcon_blank_fb(struct dcon_priv *dcon, bool blank)
-{
-	int err;
-
-	console_lock();
-	if (!lock_fb_info(dcon->fbinfo)) {
-		console_unlock();
-		dev_err(&dcon->client->dev, "unable to lock framebuffer\n");
-		return false;
-	}
-
-	dcon->ignore_fb_events = true;
-	err = fb_blank(dcon->fbinfo,
-			blank ? FB_BLANK_POWERDOWN : FB_BLANK_UNBLANK);
-	dcon->ignore_fb_events = false;
-	unlock_fb_info(dcon->fbinfo);
-	console_unlock();
-
-	if (err) {
-		dev_err(&dcon->client->dev, "couldn't %sblank framebuffer\n",
-				blank ? "" : "un");
-		return false;
-	}
-	return true;
-}
-
-/* Set the source of the display (CPU or DCON) */
-static void dcon_source_switch(struct work_struct *work)
-{
-	struct dcon_priv *dcon = container_of(work, struct dcon_priv,
-			switch_source);
-	int source = dcon->pending_src;
-
-	if (dcon->curr_src == source)
-		return;
-
-	dcon_load_holdoff(dcon);
-
-	dcon->switched = false;
-
-	switch (source) {
-	case DCON_SOURCE_CPU:
-		pr_info("dcon_source_switch to CPU\n");
-		/* Enable the scanline interrupt bit */
-		if (dcon_write(dcon, DCON_REG_MODE,
-				dcon->disp_mode | MODE_SCAN_INT))
-			pr_err("couldn't enable scanline interrupt!\n");
-		else
-			/* Wait up to one second for the scanline interrupt */
-			wait_event_timeout(dcon->waitq, dcon->switched, HZ);
-
-		if (!dcon->switched)
-			pr_err("Timeout entering CPU mode; expect a screen glitch.\n");
-
-		/* Turn off the scanline interrupt */
-		if (dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode))
-			pr_err("couldn't disable scanline interrupt!\n");
-
-		/*
-		 * Ideally we'd like to disable interrupts here so that the
-		 * fb unblanking and DCON turn on happen at a known time value;
-		 * however, we can't do that right now with fb_blank
-		 * messing with semaphores.
-		 *
-		 * For now, we just hope..
-		 */
-		if (!dcon_blank_fb(dcon, false)) {
-			pr_err("Failed to enter CPU mode\n");
-			dcon->pending_src = DCON_SOURCE_DCON;
-			return;
-		}
-
-		/* And turn off the DCON */
-		pdata->set_dconload(1);
-		dcon->load_time = ktime_get();
-
-		pr_info("The CPU has control\n");
-		break;
-	case DCON_SOURCE_DCON:
-	{
-		ktime_t delta_t;
-
-		pr_info("dcon_source_switch to DCON\n");
-
-		/* Clear DCONLOAD - this implies that the DCON is in control */
-		pdata->set_dconload(0);
-		dcon->load_time = ktime_get();
-
-		wait_event_timeout(dcon->waitq, dcon->switched, HZ/2);
-
-		if (!dcon->switched) {
-			pr_err("Timeout entering DCON mode; expect a screen glitch.\n");
-		} else {
-			/* sometimes the DCON doesn't follow its own rules,
-			 * and doesn't wait for two vsync pulses before
-			 * ack'ing the frame load with an IRQ.  the result
-			 * is that the display shows the *previously*
-			 * loaded frame.  we can detect this by looking at
-			 * the time between asserting DCONLOAD and the IRQ --
-			 * if it's less than 20msec, then the DCON couldn't
-			 * have seen two VSYNC pulses.  in that case we
-			 * deassert and reassert, and hope for the best.
-			 * see http://dev.laptop.org/ticket/9664
-			 */
-			delta_t = ktime_sub(dcon->irq_time, dcon->load_time);
-			if (dcon->switched && ktime_to_ns(delta_t)
-			    < NSEC_PER_MSEC * 20) {
-				pr_err("missed loading, retrying\n");
-				pdata->set_dconload(1);
-				mdelay(41);
-				pdata->set_dconload(0);
-				dcon->load_time = ktime_get();
-				mdelay(41);
-			}
-		}
-
-		dcon_blank_fb(dcon, true);
-		pr_info("The DCON has control\n");
-		break;
-	}
-	default:
-		BUG();
-	}
-
-	dcon->curr_src = source;
-}
-
-static void dcon_set_source(struct dcon_priv *dcon, int arg)
-{
-	if (dcon->pending_src == arg)
-		return;
-
-	dcon->pending_src = arg;
-
-	if (dcon->curr_src != arg)
-		schedule_work(&dcon->switch_source);
-}
-
-static void dcon_set_source_sync(struct dcon_priv *dcon, int arg)
-{
-	dcon_set_source(dcon, arg);
-	flush_scheduled_work();
-}
-
-static ssize_t dcon_mode_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct dcon_priv *dcon = dev_get_drvdata(dev);
-
-	return sprintf(buf, "%4.4X\n", dcon->disp_mode);
-}
-
-static ssize_t dcon_sleep_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct dcon_priv *dcon = dev_get_drvdata(dev);
-
-	return sprintf(buf, "%d\n", dcon->asleep);
-}
-
-static ssize_t dcon_freeze_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct dcon_priv *dcon = dev_get_drvdata(dev);
-
-	return sprintf(buf, "%d\n", dcon->curr_src == DCON_SOURCE_DCON ? 1 : 0);
-}
-
-static ssize_t dcon_mono_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct dcon_priv *dcon = dev_get_drvdata(dev);
-
-	return sprintf(buf, "%d\n", dcon->mono);
-}
-
-static ssize_t dcon_resumeline_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%d\n", resumeline);
-}
-
-static ssize_t dcon_mono_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned long enable_mono;
-	int rc;
-
-	rc = kstrtoul(buf, 10, &enable_mono);
-	if (rc)
-		return rc;
-
-	dcon_set_mono_mode(dev_get_drvdata(dev), enable_mono ? true : false);
-
-	return count;
-}
-
-static ssize_t dcon_freeze_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct dcon_priv *dcon = dev_get_drvdata(dev);
-	unsigned long output;
-	int ret;
-
-	ret = kstrtoul(buf, 10, &output);
-	if (ret)
-		return ret;
-
-	pr_info("dcon_freeze_store: %lu\n", output);
-
-	switch (output) {
-	case 0:
-		dcon_set_source(dcon, DCON_SOURCE_CPU);
-		break;
-	case 1:
-		dcon_set_source_sync(dcon, DCON_SOURCE_DCON);
-		break;
-	case 2:  /* normally unused */
-		dcon_set_source(dcon, DCON_SOURCE_DCON);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return count;
-}
-
-static ssize_t dcon_resumeline_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned short rl;
-	int rc;
-
-	rc = kstrtou16(buf, 10, &rl);
-	if (rc)
-		return rc;
-
-	resumeline = rl;
-	dcon_write(dev_get_drvdata(dev), DCON_REG_SCAN_INT, resumeline);
-
-	return count;
-}
-
-static ssize_t dcon_sleep_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned long output;
-	int ret;
-
-	ret = kstrtoul(buf, 10, &output);
-	if (ret)
-		return ret;
-
-	dcon_sleep(dev_get_drvdata(dev), output ? true : false);
-	return count;
-}
-
-static struct device_attribute dcon_device_files[] = {
-	__ATTR(mode, 0444, dcon_mode_show, NULL),
-	__ATTR(sleep, 0644, dcon_sleep_show, dcon_sleep_store),
-	__ATTR(freeze, 0644, dcon_freeze_show, dcon_freeze_store),
-	__ATTR(monochrome, 0644, dcon_mono_show, dcon_mono_store),
-	__ATTR(resumeline, 0644, dcon_resumeline_show, dcon_resumeline_store),
-};
-
-static int dcon_bl_update(struct backlight_device *dev)
-{
-	struct dcon_priv *dcon = bl_get_data(dev);
-	u8 level = dev->props.brightness & 0x0F;
-
-	if (dev->props.power != FB_BLANK_UNBLANK)
-		level = 0;
-
-	if (level != dcon->bl_val)
-		dcon_set_backlight(dcon, level);
-
-	/* power down the DCON when the screen is blanked */
-	if (!dcon->ignore_fb_events)
-		dcon_sleep(dcon, !!(dev->props.state & BL_CORE_FBBLANK));
-
-	return 0;
-}
-
-static int dcon_bl_get(struct backlight_device *dev)
-{
-	struct dcon_priv *dcon = bl_get_data(dev);
-
-	return dcon->bl_val;
-}
-
-static const struct backlight_ops dcon_bl_ops = {
-	.update_status = dcon_bl_update,
-	.get_brightness = dcon_bl_get,
-};
-
-static struct backlight_properties dcon_bl_props = {
-	.max_brightness = 15,
-	.type = BACKLIGHT_RAW,
-	.power = FB_BLANK_UNBLANK,
-};
-
-static int dcon_reboot_notify(struct notifier_block *nb,
-			      unsigned long foo, void *bar)
-{
-	struct dcon_priv *dcon = container_of(nb, struct dcon_priv, reboot_nb);
-
-	if (!dcon || !dcon->client)
-		return NOTIFY_DONE;
-
-	/* Turn off the DCON. Entirely. */
-	dcon_write(dcon, DCON_REG_MODE, 0x39);
-	dcon_write(dcon, DCON_REG_MODE, 0x32);
-	return NOTIFY_DONE;
-}
-
-static int unfreeze_on_panic(struct notifier_block *nb,
-			     unsigned long e, void *p)
-{
-	pdata->set_dconload(1);
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block dcon_panic_nb = {
-	.notifier_call = unfreeze_on_panic,
-};
-
-static int dcon_detect(struct i2c_client *client, struct i2c_board_info *info)
-{
-	strlcpy(info->type, "olpc_dcon", I2C_NAME_SIZE);
-
-	return 0;
-}
-
-static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	struct dcon_priv *dcon;
-	int rc, i, j;
-
-	if (!pdata)
-		return -ENXIO;
-
-	dcon = kzalloc(sizeof(*dcon), GFP_KERNEL);
-	if (!dcon)
-		return -ENOMEM;
-
-	dcon->client = client;
-	init_waitqueue_head(&dcon->waitq);
-	INIT_WORK(&dcon->switch_source, dcon_source_switch);
-	dcon->reboot_nb.notifier_call = dcon_reboot_notify;
-	dcon->reboot_nb.priority = -1;
-
-	i2c_set_clientdata(client, dcon);
-
-	if (num_registered_fb < 1) {
-		dev_err(&client->dev, "DCON driver requires a registered fb\n");
-		rc = -EIO;
-		goto einit;
-	}
-	dcon->fbinfo = registered_fb[0];
-
-	rc = dcon_hw_init(dcon, 1);
-	if (rc)
-		goto einit;
-
-	/* Add the DCON device */
-
-	dcon_device = platform_device_alloc("dcon", -1);
-
-	if (!dcon_device) {
-		pr_err("Unable to create the DCON device\n");
-		rc = -ENOMEM;
-		goto eirq;
-	}
-	rc = platform_device_add(dcon_device);
-	platform_set_drvdata(dcon_device, dcon);
-
-	if (rc) {
-		pr_err("Unable to add the DCON device\n");
-		goto edev;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(dcon_device_files); i++) {
-		rc = device_create_file(&dcon_device->dev,
-					&dcon_device_files[i]);
-		if (rc) {
-			dev_err(&dcon_device->dev, "Cannot create sysfs file\n");
-			goto ecreate;
-		}
-	}
-
-	dcon->bl_val = dcon_read(dcon, DCON_REG_BRIGHT) & 0x0F;
-
-	/* Add the backlight device for the DCON */
-	dcon_bl_props.brightness = dcon->bl_val;
-	dcon->bl_dev = backlight_device_register("dcon-bl", &dcon_device->dev,
-		dcon, &dcon_bl_ops, &dcon_bl_props);
-	if (IS_ERR(dcon->bl_dev)) {
-		dev_err(&client->dev, "cannot register backlight dev (%ld)\n",
-				PTR_ERR(dcon->bl_dev));
-		dcon->bl_dev = NULL;
-	}
-
-	register_reboot_notifier(&dcon->reboot_nb);
-	atomic_notifier_chain_register(&panic_notifier_list, &dcon_panic_nb);
-
-	return 0;
-
- ecreate:
-	for (j = 0; j < i; j++)
-		device_remove_file(&dcon_device->dev, &dcon_device_files[j]);
- edev:
-	platform_device_unregister(dcon_device);
-	dcon_device = NULL;
- eirq:
-	free_irq(DCON_IRQ, dcon);
- einit:
-	kfree(dcon);
-	return rc;
-}
-
-static int dcon_remove(struct i2c_client *client)
-{
-	struct dcon_priv *dcon = i2c_get_clientdata(client);
-
-	unregister_reboot_notifier(&dcon->reboot_nb);
-	atomic_notifier_chain_unregister(&panic_notifier_list, &dcon_panic_nb);
-
-	free_irq(DCON_IRQ, dcon);
-
-	backlight_device_unregister(dcon->bl_dev);
-
-	if (dcon_device)
-		platform_device_unregister(dcon_device);
-	cancel_work_sync(&dcon->switch_source);
-
-	kfree(dcon);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int dcon_suspend(struct device *dev)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct dcon_priv *dcon = i2c_get_clientdata(client);
-
-	if (!dcon->asleep) {
-		/* Set up the DCON to have the source */
-		dcon_set_source_sync(dcon, DCON_SOURCE_DCON);
-	}
-
-	return 0;
-}
-
-static int dcon_resume(struct device *dev)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct dcon_priv *dcon = i2c_get_clientdata(client);
-
-	if (!dcon->asleep) {
-		dcon_bus_stabilize(dcon, 0);
-		dcon_set_source(dcon, DCON_SOURCE_CPU);
-	}
-
-	return 0;
-}
-
-#else
-
-#define dcon_suspend NULL
-#define dcon_resume NULL
-
-#endif /* CONFIG_PM */
-
-irqreturn_t dcon_interrupt(int irq, void *id)
-{
-	struct dcon_priv *dcon = id;
-	u8 status;
-
-	if (pdata->read_status(&status))
-		return IRQ_NONE;
-
-	switch (status & 3) {
-	case 3:
-		pr_debug("DCONLOAD_MISSED interrupt\n");
-		break;
-
-	case 2:	/* switch to DCON mode */
-	case 1: /* switch to CPU mode */
-		dcon->switched = true;
-		dcon->irq_time = ktime_get();
-		wake_up(&dcon->waitq);
-		break;
-
-	case 0:
-		/* workaround resume case:  the DCON (on 1.5) doesn't
-		 * ever assert status 0x01 when switching to CPU mode
-		 * during resume.  this is because DCONLOAD is de-asserted
-		 * _immediately_ upon exiting S3, so the actual release
-		 * of the DCON happened long before this point.
-		 * see http://dev.laptop.org/ticket/9869
-		 */
-		if (dcon->curr_src != dcon->pending_src && !dcon->switched) {
-			dcon->switched = true;
-			dcon->irq_time = ktime_get();
-			wake_up(&dcon->waitq);
-			pr_debug("switching w/ status 0/0\n");
-		} else {
-			pr_debug("scanline interrupt w/CPU\n");
-		}
-	}
-
-	return IRQ_HANDLED;
-}
-
-static const struct dev_pm_ops dcon_pm_ops = {
-	.suspend = dcon_suspend,
-	.resume = dcon_resume,
-};
-
-static const struct i2c_device_id dcon_idtable[] = {
-	{ "olpc_dcon",  0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, dcon_idtable);
-
-static struct i2c_driver dcon_driver = {
-	.driver = {
-		.name	= "olpc_dcon",
-		.pm = &dcon_pm_ops,
-	},
-	.class = I2C_CLASS_DDC | I2C_CLASS_HWMON,
-	.id_table = dcon_idtable,
-	.probe = dcon_probe,
-	.remove = dcon_remove,
-	.detect = dcon_detect,
-	.address_list = normal_i2c,
-};
-
-static int __init olpc_dcon_init(void)
-{
-#ifdef CONFIG_FB_OLPC_DCON_1_5
-	/* XO-1.5 */
-	if (olpc_board_at_least(olpc_board(0xd0)))
-		pdata = &dcon_pdata_xo_1_5;
-#endif
-#ifdef CONFIG_FB_OLPC_DCON_1
-	if (!pdata)
-		pdata = &dcon_pdata_xo_1;
-#endif
-
-	return i2c_add_driver(&dcon_driver);
-}
-
-static void __exit olpc_dcon_exit(void)
-{
-	i2c_del_driver(&dcon_driver);
-}
-
-module_init(olpc_dcon_init);
-module_exit(olpc_dcon_exit);
-
-MODULE_LICENSE("GPL");

commit 5e6731c88b2dc2dd484f5b4177df9f3f95c3f6c9
Author: Aybuke Ozdemir <aybuke.147@gmail.com>
Date:   Fri Oct 16 21:51:45 2015 +0300

    Staging: olpc_dcon: Remove NULL comparison
    
    Problem found using checkpatch.pl
    CHECK: Comparison to NULL could be written "(!)dcon_device"
    
    Signed-off-by: Aybuke Ozdemir <aybuke.147@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 2c34f61e1b39..f45b2ef05f48 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -616,7 +616,7 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 
 	dcon_device = platform_device_alloc("dcon", -1);
 
-	if (dcon_device == NULL) {
+	if (!dcon_device) {
 		pr_err("Unable to create the DCON device\n");
 		rc = -ENOMEM;
 		goto eirq;
@@ -679,7 +679,7 @@ static int dcon_remove(struct i2c_client *client)
 
 	backlight_device_unregister(dcon->bl_dev);
 
-	if (dcon_device != NULL)
+	if (dcon_device)
 		platform_device_unregister(dcon_device);
 	cancel_work_sync(&dcon->switch_source);
 

commit bdf4b8811f02067dc332f635b59f600a869da1a0
Author: Aybuke Ozdemir <aybuke.147@gmail.com>
Date:   Fri Oct 16 21:51:44 2015 +0300

    Staging: olpc_dcon: Use preferred kernel type
    
    This patch "uint16_t" type instead of "u16" type was used.
    checkpatch.pl issue.
    
    Signed-off-by: Aybuke Ozdemir <aybuke.147@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index d0f86d313aaf..2c34f61e1b39 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -60,7 +60,7 @@ static s32 dcon_read(struct dcon_priv *dcon, u8 reg)
 
 static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 {
-	uint16_t ver;
+	u16 ver;
 	int rc = 0;
 
 	ver = dcon_read(dcon, DCON_REG_ID);

commit 26fc5d01d12323fb9ca231032d47cef4e4cb6bd6
Author: Aybuke Ozdemir <aybuke.147@gmail.com>
Date:   Fri Oct 16 21:51:43 2015 +0300

    Staging: olpc_dcon: Remove multiple blank lines
    
    Remove multiple blank lines. Problem found using checkpatch.pl
    CHECK: Please don't use multiple blank lines.
    
    Signed-off-by: Aybuke Ozdemir <aybuke.147@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 3f424d14c334..d0f86d313aaf 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -100,7 +100,6 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 	}
 	dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
 
-
 	/* Set the scanline to interrupt on during resume */
 	dcon_write(dcon, DCON_REG_SCAN_INT, resumeline);
 
@@ -723,7 +722,6 @@ static int dcon_resume(struct device *dev)
 
 #endif /* CONFIG_PM */
 
-
 irqreturn_t dcon_interrupt(int irq, void *id)
 {
 	struct dcon_priv *dcon = id;

commit cea07e523c218ba45b9448ff78e18357880a2548
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Sat Oct 10 17:21:42 2015 +0200

    Staging: olpc_dcon: Remove braces
    
    Braces in single statement blocks are not needed.
    
    Found by checkpatch.pl
    
    Signed-off-by: Ksenija Stanojevic<ksenija.stanojevic@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 9038e0b3f113..3f424d14c334 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -243,9 +243,8 @@ static void dcon_load_holdoff(struct dcon_priv *dcon)
 	while (1) {
 		now = ktime_get();
 		delta_t = ktime_sub(now, dcon->load_time);
-		if (ktime_to_ns(delta_t) > NSEC_PER_MSEC * 20) {
+		if (ktime_to_ns(delta_t) > NSEC_PER_MSEC * 20)
 			break;
-		}
 		mdelay(4);
 	}
 }

commit 851f7c0e62dc564bf99e295b3c498d3d96a73b4a
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Fri Oct 2 19:24:05 2015 +0200

    Staging: olpc_dcon: Replace timespec with ktime_t
    
    Struct timespec will overflow in year 2038, here it will not cause an
    overflow because it is used with timespec_sub, but still has to be
    removed as part of y2038 changes. Replace it with ktime_t. Also use
    monotonic instead of real-time by replacing functions getnstimeofday
    with ktime_get.
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index d115f5c0e341..9038e0b3f113 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -238,13 +238,12 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
  */
 static void dcon_load_holdoff(struct dcon_priv *dcon)
 {
-	struct timespec delta_t, now;
+	ktime_t delta_t, now;
 
 	while (1) {
-		getnstimeofday(&now);
-		delta_t = timespec_sub(now, dcon->load_time);
-		if (delta_t.tv_sec != 0 ||
-			delta_t.tv_nsec > NSEC_PER_MSEC * 20) {
+		now = ktime_get();
+		delta_t = ktime_sub(now, dcon->load_time);
+		if (ktime_to_ns(delta_t) > NSEC_PER_MSEC * 20) {
 			break;
 		}
 		mdelay(4);
@@ -325,19 +324,19 @@ static void dcon_source_switch(struct work_struct *work)
 
 		/* And turn off the DCON */
 		pdata->set_dconload(1);
-		getnstimeofday(&dcon->load_time);
+		dcon->load_time = ktime_get();
 
 		pr_info("The CPU has control\n");
 		break;
 	case DCON_SOURCE_DCON:
 	{
-		struct timespec delta_t;
+		ktime_t delta_t;
 
 		pr_info("dcon_source_switch to DCON\n");
 
 		/* Clear DCONLOAD - this implies that the DCON is in control */
 		pdata->set_dconload(0);
-		getnstimeofday(&dcon->load_time);
+		dcon->load_time = ktime_get();
 
 		wait_event_timeout(dcon->waitq, dcon->switched, HZ/2);
 
@@ -355,14 +354,14 @@ static void dcon_source_switch(struct work_struct *work)
 			 * deassert and reassert, and hope for the best.
 			 * see http://dev.laptop.org/ticket/9664
 			 */
-			delta_t = timespec_sub(dcon->irq_time, dcon->load_time);
-			if (dcon->switched && delta_t.tv_sec == 0 &&
-					delta_t.tv_nsec < NSEC_PER_MSEC * 20) {
+			delta_t = ktime_sub(dcon->irq_time, dcon->load_time);
+			if (dcon->switched && ktime_to_ns(delta_t)
+			    < NSEC_PER_MSEC * 20) {
 				pr_err("missed loading, retrying\n");
 				pdata->set_dconload(1);
 				mdelay(41);
 				pdata->set_dconload(0);
-				getnstimeofday(&dcon->load_time);
+				dcon->load_time = ktime_get();
 				mdelay(41);
 			}
 		}
@@ -742,7 +741,7 @@ irqreturn_t dcon_interrupt(int irq, void *id)
 	case 2:	/* switch to DCON mode */
 	case 1: /* switch to CPU mode */
 		dcon->switched = true;
-		getnstimeofday(&dcon->irq_time);
+		dcon->irq_time = ktime_get();
 		wake_up(&dcon->waitq);
 		break;
 
@@ -756,7 +755,7 @@ irqreturn_t dcon_interrupt(int irq, void *id)
 		 */
 		if (dcon->curr_src != dcon->pending_src && !dcon->switched) {
 			dcon->switched = true;
-			getnstimeofday(&dcon->irq_time);
+			dcon->irq_time = ktime_get();
 			wake_up(&dcon->waitq);
 			pr_debug("switching w/ status 0/0\n");
 		} else {

commit a227437e860d3b7d5584a14b60953992b0634f7f
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Mon Mar 30 12:59:49 2015 +0200

    staging/olpc: drop pci dependencies
    
    This file does not use any pci APIs, drop
    pci header includes.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index bc7e664cc8a7..d115f5c0e341 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -18,8 +18,6 @@
 #include <linux/console.h>
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
-#include <linux/pci.h>
-#include <linux/pci_ids.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <linux/module.h>

commit 4e8e87162e839286fbce2d68e8341a1e53066630
Author: Murilo Opsfelder Araujo <mopsfelder@gmail.com>
Date:   Thu Jan 15 23:55:00 2015 -0200

    staging: olpc_dcon: fix sparse symbol not declared warning
    
    This patch gets rid of the following sparse warning:
    
    drivers/staging/olpc_dcon/olpc_dcon.c:787:19: warning: symbol 'dcon_driver' was not declared. Should it be static?
    
    Signed-off-by: Murilo Opsfelder Araujo <mopsfelder@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 6a9a8815477c..bc7e664cc8a7 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -780,7 +780,7 @@ static const struct i2c_device_id dcon_idtable[] = {
 };
 MODULE_DEVICE_TABLE(i2c, dcon_idtable);
 
-struct i2c_driver dcon_driver = {
+static struct i2c_driver dcon_driver = {
 	.driver = {
 		.name	= "olpc_dcon",
 		.pm = &dcon_pm_ops,

commit 16ceb7283987d8d7cad260bacf49f4197c625504
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Mon Nov 24 22:58:48 2014 +0100

    staging: olpc_dcon: Deletion of a check before backlight_device_unregister()
    
    The backlight_device_unregister() function tests whether its argument is NULL
    and then returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index eb83b28b8cd1..6a9a8815477c 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -682,8 +682,7 @@ static int dcon_remove(struct i2c_client *client)
 
 	free_irq(DCON_IRQ, dcon);
 
-	if (dcon->bl_dev)
-		backlight_device_unregister(dcon->bl_dev);
+	backlight_device_unregister(dcon->bl_dev);
 
 	if (dcon_device != NULL)
 		platform_device_unregister(dcon_device);

commit 7949f30a36550b9feeedff10bb4b156b372c6e53
Author: Nicolas Joseph <nicolas.joseph@homecomputing.fr>
Date:   Fri May 23 21:45:08 2014 +0200

    staging/olpc_dcon: fix checkpatch warnings
    
    WARNING: Missing a blank line after declarations
    
    Signed-off-by: Nicolas Joseph <nicolas.joseph@homecomputing.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 26b4ec56fd30..eb83b28b8cd1 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -210,6 +210,7 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
 
 	if (sleep) {
 		u8 pm = 0;
+
 		x = olpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);
 		if (x)
 			pr_warn("unable to force dcon to power down: %d!\n", x);
@@ -240,6 +241,7 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
 static void dcon_load_holdoff(struct dcon_priv *dcon)
 {
 	struct timespec delta_t, now;
+
 	while (1) {
 		getnstimeofday(&now);
 		delta_t = timespec_sub(now, dcon->load_time);
@@ -399,14 +401,15 @@ static ssize_t dcon_mode_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
 	struct dcon_priv *dcon = dev_get_drvdata(dev);
+
 	return sprintf(buf, "%4.4X\n", dcon->disp_mode);
 }
 
 static ssize_t dcon_sleep_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-
 	struct dcon_priv *dcon = dev_get_drvdata(dev);
+
 	return sprintf(buf, "%d\n", dcon->asleep);
 }
 
@@ -414,6 +417,7 @@ static ssize_t dcon_freeze_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
 	struct dcon_priv *dcon = dev_get_drvdata(dev);
+
 	return sprintf(buf, "%d\n", dcon->curr_src == DCON_SOURCE_DCON ? 1 : 0);
 }
 
@@ -421,6 +425,7 @@ static ssize_t dcon_mono_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
 	struct dcon_priv *dcon = dev_get_drvdata(dev);
+
 	return sprintf(buf, "%d\n", dcon->mono);
 }
 
@@ -534,6 +539,7 @@ static int dcon_bl_update(struct backlight_device *dev)
 static int dcon_bl_get(struct backlight_device *dev)
 {
 	struct dcon_priv *dcon = bl_get_data(dev);
+
 	return dcon->bl_val;
 }
 

commit fc0524b0986f994693f06a00c8de1c0469fd7086
Author: Gu Zheng <guz.fnst@cn.fujitsu.com>
Date:   Thu Oct 31 18:33:01 2013 +0800

    staging/olpc_docn: reorder the lock sequence to avoid potential dead lock
    
    The lock sequence of dcon_blank_fb(fb_info->lock ---> console_lock) is against
    with the one of console_callback(console_lock ---> fb_info->lock), it'll
    lead to a potential dead lock, so reorder the lock sequence of dcon_blank_fb
    to avoid the potential dead lock.
    
    Signed-off-by: Gu Zheng <guz.fnst@cn.fujitsu.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 92b02891704d..26b4ec56fd30 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -255,17 +255,19 @@ static bool dcon_blank_fb(struct dcon_priv *dcon, bool blank)
 {
 	int err;
 
+	console_lock();
 	if (!lock_fb_info(dcon->fbinfo)) {
+		console_unlock();
 		dev_err(&dcon->client->dev, "unable to lock framebuffer\n");
 		return false;
 	}
-	console_lock();
+
 	dcon->ignore_fb_events = true;
 	err = fb_blank(dcon->fbinfo,
 			blank ? FB_BLANK_POWERDOWN : FB_BLANK_UNBLANK);
 	dcon->ignore_fb_events = false;
-	console_unlock();
 	unlock_fb_info(dcon->fbinfo);
+	console_unlock();
 
 	if (err) {
 		dev_err(&dcon->client->dev, "couldn't %sblank framebuffer\n",

commit 14ab3daaea04da644f96ad66902013fb72b99406
Author: Xie XiuQi <xiexiuqi@huawei.com>
Date:   Thu Sep 19 15:04:57 2013 -0700

    staging: olpc_dcon: remove unnecessary work pending test
    
    Remove unnecessary work pending test before calling schedule_work().
    It has been tested in queue_work_on() already. No functional changed.
    
    Signed-off-by: Xie XiuQi <xiexiuqi@huawei.com>
    Cc: Jens Frederich <jfrederich@gmail.com>
    Cc: Daniel Drake <dsd@laptop.org>
    Cc: Jon Nettleton <jon.nettleton@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 198595e8d742..92b02891704d 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -383,7 +383,7 @@ static void dcon_set_source(struct dcon_priv *dcon, int arg)
 
 	dcon->pending_src = arg;
 
-	if ((dcon->curr_src != arg) && !work_pending(&dcon->switch_source))
+	if (dcon->curr_src != arg)
 		schedule_work(&dcon->switch_source);
 }
 

commit 24b7ed475e2b71eba68ee9714b29c712f8dc41f6
Author: Jens Frederich <jfrederich@gmail.com>
Date:   Thu Aug 15 21:40:01 2013 +0200

    Staging: olpc_dcon: more big endian conformity
    
    Using an int which is casted to unsigned char as inbuf is messy.
    The code won't work on big endian systems.  The patch should fix
    this.
    
    Signed-off-by: Jens Frederich <jfrederich@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 5ca4fa4fd246..198595e8d742 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -122,12 +122,13 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 {
 	unsigned long timeout;
+	u8 pm;
 	int x;
 
 power_up:
 	if (is_powered_down) {
-		x = 1;
-		x = olpc_ec_cmd(EC_DCON_POWER_MODE, (u8 *)&x, 1, NULL, 0);
+		pm = 1;
+		x = olpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);
 		if (x) {
 			pr_warn("unable to force dcon to power up: %d!\n", x);
 			return x;
@@ -144,8 +145,8 @@ static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 	if (x < 0) {
 		pr_err("unable to stabilize dcon's smbus, reasserting power and praying.\n");
 		BUG_ON(olpc_board_at_least(olpc_board(0xc2)));
-		x = 0;
-		olpc_ec_cmd(EC_DCON_POWER_MODE, (u8 *)&x, 1, NULL, 0);
+		pm = 0;
+		olpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);
 		msleep(100);
 		is_powered_down = 1;
 		goto power_up;	/* argh, stupid hardware.. */
@@ -208,8 +209,8 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
 		return;
 
 	if (sleep) {
-		x = 0;
-		x = olpc_ec_cmd(EC_DCON_POWER_MODE, (u8 *)&x, 1, NULL, 0);
+		u8 pm = 0;
+		x = olpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);
 		if (x)
 			pr_warn("unable to force dcon to power down: %d!\n", x);
 		else

commit 98d4f93c79b002f85480320fe63fefaa31d58b6c
Author: Jens Frederich <jfrederich@gmail.com>
Date:   Thu Aug 15 21:34:55 2013 +0200

    Staging: olpc_dcon: replace some magic numbers
    
    This patch replace some magic numbers. I believe it makes
    the driver more readable.
    
    The magic number 0x26 is the XO system embedded controller
    (EC) command 'DCON power enable/disable'.
    
    Number 0x41, and 0x42 are special memory controller settings
    register.  The 0x41 initialize bit sequence 0x101 means:
    enable memory power down function and special SDRAM clock
    delay for synchronize SDRAM output and clock signal.
    
    The 0x42 initialize squence 0x101 is wrong.  According to
    the specification Bit 8 is reserved, thus not in use.
    I removed it.
    
    Signed-off-by: Jens Frederich <jfrederich@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 7c460f2c0d23..5ca4fa4fd246 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -90,9 +90,10 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 
 	/* SDRAM setup/hold time */
 	dcon_write(dcon, 0x3a, 0xc040);
-	dcon_write(dcon, 0x41, 0x0000);
-	dcon_write(dcon, 0x41, 0x0101);
-	dcon_write(dcon, 0x42, 0x0101);
+	dcon_write(dcon, DCON_REG_MEM_OPT_A, 0x0000);  /* clear option bits */
+	dcon_write(dcon, DCON_REG_MEM_OPT_A,
+				MEM_DLL_CLOCK_DELAY | MEM_POWER_DOWN);
+	dcon_write(dcon, DCON_REG_MEM_OPT_B, MEM_SOFT_RESET);
 
 	/* Colour swizzle, AA, no passthrough, backlight */
 	if (is_init) {
@@ -126,7 +127,7 @@ static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 power_up:
 	if (is_powered_down) {
 		x = 1;
-		x = olpc_ec_cmd(0x26, (unsigned char *)&x, 1, NULL, 0);
+		x = olpc_ec_cmd(EC_DCON_POWER_MODE, (u8 *)&x, 1, NULL, 0);
 		if (x) {
 			pr_warn("unable to force dcon to power up: %d!\n", x);
 			return x;
@@ -144,7 +145,7 @@ static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 		pr_err("unable to stabilize dcon's smbus, reasserting power and praying.\n");
 		BUG_ON(olpc_board_at_least(olpc_board(0xc2)));
 		x = 0;
-		olpc_ec_cmd(0x26, (unsigned char *)&x, 1, NULL, 0);
+		olpc_ec_cmd(EC_DCON_POWER_MODE, (u8 *)&x, 1, NULL, 0);
 		msleep(100);
 		is_powered_down = 1;
 		goto power_up;	/* argh, stupid hardware.. */
@@ -208,7 +209,7 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
 
 	if (sleep) {
 		x = 0;
-		x = olpc_ec_cmd(0x26, (unsigned char *)&x, 1, NULL, 0);
+		x = olpc_ec_cmd(EC_DCON_POWER_MODE, (u8 *)&x, 1, NULL, 0);
 		if (x)
 			pr_warn("unable to force dcon to power down: %d!\n", x);
 		else

commit 5607ce90d727d2aaad93bd72551b97067141d68a
Author: Jens Frederich <jfrederich@gmail.com>
Date:   Thu Jul 25 22:06:32 2013 +0200

    Staging: olpc_dcon: change to msleep to usleep_range
    
    The resolution of msleep is related to HZ, so with HZ set to
    100 any msleep of less then 10ms will become ~10ms. This is
    not what we want. Use usleep_range to get more control of
    what is happening here.
    
    Signed-off-by: Jens Frederich <jfrederich@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 193e1c68bb45..7c460f2c0d23 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -131,13 +131,13 @@ static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 			pr_warn("unable to force dcon to power up: %d!\n", x);
 			return x;
 		}
-		msleep(10); /* we'll be conservative */
+		usleep_range(10000, 11000);  /* we'll be conservative */
 	}
 
 	pdata->bus_stabilize_wiggle();
 
 	for (x = -1, timeout = 50; timeout && x < 0; timeout--) {
-		msleep(1);
+		usleep_range(1000, 1100);
 		x = dcon_read(dcon, DCON_REG_ID);
 	}
 	if (x < 0) {

commit 2cc5939d761b8c8c6de16814bad4126e4a173d11
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Sat Mar 16 14:38:39 2013 -0400

    staging: olpc_dcon: return NOTIFY_DONE instead of the 0.
    
    return a valid macro instead of 0 (as #define NOTIFY_DONE 0)
    in the reboot callback
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 54ed6f69e3d4..193e1c68bb45 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -550,12 +550,12 @@ static int dcon_reboot_notify(struct notifier_block *nb,
 	struct dcon_priv *dcon = container_of(nb, struct dcon_priv, reboot_nb);
 
 	if (!dcon || !dcon->client)
-		return 0;
+		return NOTIFY_DONE;
 
 	/* Turn off the DCON. Entirely. */
 	dcon_write(dcon, DCON_REG_MODE, 0x39);
 	dcon_write(dcon, DCON_REG_MODE, 0x32);
-	return 0;
+	return NOTIFY_DONE;
 }
 
 static int unfreeze_on_panic(struct notifier_block *nb,

commit c8ddc220177c9b0aa3207f872ef3401c16da9d6d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:32 2012 -0500

    staging: olpc_dcon: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 3fe209ca38cb..54ed6f69e3d4 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -779,7 +779,7 @@ struct i2c_driver dcon_driver = {
 	.class = I2C_CLASS_DDC | I2C_CLASS_HWMON,
 	.id_table = dcon_idtable,
 	.probe = dcon_probe,
-	.remove = __devexit_p(dcon_remove),
+	.remove = dcon_remove,
 	.detect = dcon_detect,
 	.address_list = normal_i2c,
 };

commit 3e5e624bfda39417cc76e716a350a318049dbd39
Author: Andres Salomon <dilinger@queued.net>
Date:   Mon Oct 1 14:46:21 2012 -0700

    staging/olpc_dcon: use s/r hooks from device_driver->pm
    
    ..instead of the i2c_driver hooks.  This should silence the following
    runtime warnings:
    
    [   17.820321] i2c-core: driver [olpc_dcon] using legacy suspend method
    [   17.846082] i2c-core: driver [olpc_dcon] using legacy resume method
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 2b0bbaccbd3a..3fe209ca38cb 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -685,8 +685,9 @@ static int dcon_remove(struct i2c_client *client)
 }
 
 #ifdef CONFIG_PM
-static int dcon_suspend(struct i2c_client *client, pm_message_t state)
+static int dcon_suspend(struct device *dev)
 {
+	struct i2c_client *client = to_i2c_client(dev);
 	struct dcon_priv *dcon = i2c_get_clientdata(client);
 
 	if (!dcon->asleep) {
@@ -697,8 +698,9 @@ static int dcon_suspend(struct i2c_client *client, pm_message_t state)
 	return 0;
 }
 
-static int dcon_resume(struct i2c_client *client)
+static int dcon_resume(struct device *dev)
 {
+	struct i2c_client *client = to_i2c_client(dev);
 	struct dcon_priv *dcon = i2c_get_clientdata(client);
 
 	if (!dcon->asleep) {
@@ -709,7 +711,12 @@ static int dcon_resume(struct i2c_client *client)
 	return 0;
 }
 
-#endif
+#else
+
+#define dcon_suspend NULL
+#define dcon_resume NULL
+
+#endif /* CONFIG_PM */
 
 
 irqreturn_t dcon_interrupt(int irq, void *id)
@@ -753,16 +760,21 @@ irqreturn_t dcon_interrupt(int irq, void *id)
 	return IRQ_HANDLED;
 }
 
+static const struct dev_pm_ops dcon_pm_ops = {
+	.suspend = dcon_suspend,
+	.resume = dcon_resume,
+};
+
 static const struct i2c_device_id dcon_idtable[] = {
 	{ "olpc_dcon",  0 },
 	{ }
 };
-
 MODULE_DEVICE_TABLE(i2c, dcon_idtable);
 
 struct i2c_driver dcon_driver = {
 	.driver = {
 		.name	= "olpc_dcon",
+		.pm = &dcon_pm_ops,
 	},
 	.class = I2C_CLASS_DDC | I2C_CLASS_HWMON,
 	.id_table = dcon_idtable,
@@ -770,10 +782,6 @@ struct i2c_driver dcon_driver = {
 	.remove = __devexit_p(dcon_remove),
 	.detect = dcon_detect,
 	.address_list = normal_i2c,
-#ifdef CONFIG_PM
-	.suspend = dcon_suspend,
-	.resume = dcon_resume,
-#endif
 };
 
 static int __init olpc_dcon_init(void)

commit 20b27c61b714537a4cd6d93679e9d8a5947f1769
Author: Andres Salomon <dilinger@queued.net>
Date:   Mon Oct 1 14:46:01 2012 -0700

    staging/olpc_dcon: drop fb_notifier code
    
    Previously we registered a notifier block to inform us of any framebuffer
    device changes; if the screen was blanked or unblanked, we'd put the DCON
    to sleep or wake it up.
    
    Turns out that the backlight code registers a notifier block as well
    and calls the update_status hook, so we can just use that to put the DCON
    to sleep.  For those status updates where the blanking isn't changed,
    dcon_sleep will do nothing.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 38f988b7f16d..2b0bbaccbd3a 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -520,6 +520,10 @@ static int dcon_bl_update(struct backlight_device *dev)
 	if (level != dcon->bl_val)
 		dcon_set_backlight(dcon, level);
 
+	/* power down the DCON when the screen is blanked */
+	if (!dcon->ignore_fb_events)
+		dcon_sleep(dcon, !!(dev->props.state & BL_CORE_FBBLANK));
+
 	return 0;
 }
 
@@ -565,24 +569,6 @@ static struct notifier_block dcon_panic_nb = {
 	.notifier_call = unfreeze_on_panic,
 };
 
-/*
- * When the framebuffer sleeps due to external sources (e.g. user idle), power
- * down the DCON as well.  Power it back up when the fb comes back to life.
- */
-static int dcon_fb_notifier(struct notifier_block *self,
-				unsigned long event, void *data)
-{
-	struct fb_event *evdata = data;
-	struct dcon_priv *dcon = container_of(self, struct dcon_priv,
-			fbevent_nb);
-	int *blank = (int *)evdata->data;
-	if (((event != FB_EVENT_BLANK) && (event != FB_EVENT_CONBLANK)) ||
-			dcon->ignore_fb_events)
-		return 0;
-	dcon_sleep(dcon, *blank ? true : false);
-	return 0;
-}
-
 static int dcon_detect(struct i2c_client *client, struct i2c_board_info *info)
 {
 	strlcpy(info->type, "olpc_dcon", I2C_NAME_SIZE);
@@ -607,7 +593,6 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	INIT_WORK(&dcon->switch_source, dcon_source_switch);
 	dcon->reboot_nb.notifier_call = dcon_reboot_notify;
 	dcon->reboot_nb.priority = -1;
-	dcon->fbevent_nb.notifier_call = dcon_fb_notifier;
 
 	i2c_set_clientdata(client, dcon);
 
@@ -662,7 +647,6 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 
 	register_reboot_notifier(&dcon->reboot_nb);
 	atomic_notifier_chain_register(&panic_notifier_list, &dcon_panic_nb);
-	fb_register_client(&dcon->fbevent_nb);
 
 	return 0;
 
@@ -683,7 +667,6 @@ static int dcon_remove(struct i2c_client *client)
 {
 	struct dcon_priv *dcon = i2c_get_clientdata(client);
 
-	fb_unregister_client(&dcon->fbevent_nb);
 	unregister_reboot_notifier(&dcon->reboot_nb);
 	atomic_notifier_chain_unregister(&panic_notifier_list, &dcon_panic_nb);
 

commit c40f20da3b3f0738ced45533c743217e00090062
Author: Andres Salomon <dilinger@queued.net>
Date:   Mon Oct 1 14:45:50 2012 -0700

    staging/olpc_dcon: move wait queue into dcon_priv struct
    
    Another global variable (dcon_wait_queue) moved into the dcon_priv struct.
    In the process, replace an instance of a manually implemented
    wait_event_timeout.  This code came from Jordan's original gxfb_dcon.c
    driver waaaay back in 2006; well past time for a replacement.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 7dcd0603318e..38f988b7f16d 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -46,8 +46,6 @@ static struct dcon_platform_data *pdata;
 /* Platform devices */
 static struct platform_device *dcon_device;
 
-static DECLARE_WAIT_QUEUE_HEAD(dcon_wait_queue);
-
 static unsigned short normal_i2c[] = { 0x0d, I2C_CLIENT_END };
 
 static s32 dcon_write(struct dcon_priv *dcon, u8 reg, u16 val)
@@ -280,7 +278,6 @@ static void dcon_source_switch(struct work_struct *work)
 {
 	struct dcon_priv *dcon = container_of(work, struct dcon_priv,
 			switch_source);
-	DECLARE_WAITQUEUE(wait, current);
 	int source = dcon->pending_src;
 
 	if (dcon->curr_src == source)
@@ -297,11 +294,9 @@ static void dcon_source_switch(struct work_struct *work)
 		if (dcon_write(dcon, DCON_REG_MODE,
 				dcon->disp_mode | MODE_SCAN_INT))
 			pr_err("couldn't enable scanline interrupt!\n");
-		else {
+		else
 			/* Wait up to one second for the scanline interrupt */
-			wait_event_timeout(dcon_wait_queue,
-					   dcon->switched == true, HZ);
-		}
+			wait_event_timeout(dcon->waitq, dcon->switched, HZ);
 
 		if (!dcon->switched)
 			pr_err("Timeout entering CPU mode; expect a screen glitch.\n");
@@ -332,21 +327,15 @@ static void dcon_source_switch(struct work_struct *work)
 		break;
 	case DCON_SOURCE_DCON:
 	{
-		int t;
 		struct timespec delta_t;
 
 		pr_info("dcon_source_switch to DCON\n");
 
-		add_wait_queue(&dcon_wait_queue, &wait);
-		set_current_state(TASK_UNINTERRUPTIBLE);
-
 		/* Clear DCONLOAD - this implies that the DCON is in control */
 		pdata->set_dconload(0);
 		getnstimeofday(&dcon->load_time);
 
-		t = schedule_timeout(HZ/2);
-		remove_wait_queue(&dcon_wait_queue, &wait);
-		set_current_state(TASK_RUNNING);
+		wait_event_timeout(dcon->waitq, dcon->switched, HZ/2);
 
 		if (!dcon->switched) {
 			pr_err("Timeout entering DCON mode; expect a screen glitch.\n");
@@ -614,6 +603,7 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		return -ENOMEM;
 
 	dcon->client = client;
+	init_waitqueue_head(&dcon->waitq);
 	INIT_WORK(&dcon->switch_source, dcon_source_switch);
 	dcon->reboot_nb.notifier_call = dcon_reboot_notify;
 	dcon->reboot_nb.priority = -1;
@@ -756,7 +746,7 @@ irqreturn_t dcon_interrupt(int irq, void *id)
 	case 1: /* switch to CPU mode */
 		dcon->switched = true;
 		getnstimeofday(&dcon->irq_time);
-		wake_up(&dcon_wait_queue);
+		wake_up(&dcon->waitq);
 		break;
 
 	case 0:
@@ -770,7 +760,7 @@ irqreturn_t dcon_interrupt(int irq, void *id)
 		if (dcon->curr_src != dcon->pending_src && !dcon->switched) {
 			dcon->switched = true;
 			getnstimeofday(&dcon->irq_time);
-			wake_up(&dcon_wait_queue);
+			wake_up(&dcon->waitq);
 			pr_debug("switching w/ status 0/0\n");
 		} else {
 			pr_debug("scanline interrupt w/CPU\n");

commit 802562807af61fc8b6f830725e127bf53e0a7f1c
Author: Andres Salomon <dilinger@queued.net>
Date:   Mon Oct 1 14:45:37 2012 -0700

    staging/olpc_dcon: drop useaa module arg
    
    The 'useaa' module parameter was a workaround for a buggy DCON prototype
    not supporting the optional anti-aliasing mode properly.  There's no
    reason to disable it any more, so drop the option.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index d49c32a95690..7dcd0603318e 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -39,10 +39,6 @@
 static ushort resumeline = 898;
 module_param(resumeline, ushort, 0444);
 
-/* Default off since it doesn't work on DCON ASIC in B-test OLPC board */
-static int useaa = 1;
-module_param(useaa, int, 0444);
-
 static struct dcon_platform_data *pdata;
 
 /* I2C structures */
@@ -103,9 +99,7 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 	/* Colour swizzle, AA, no passthrough, backlight */
 	if (is_init) {
 		dcon->disp_mode = MODE_PASSTHRU | MODE_BL_ENABLE |
-				MODE_CSWIZZLE;
-		if (useaa)
-			dcon->disp_mode |= MODE_COL_AA;
+				MODE_CSWIZZLE | MODE_COL_AA;
 	}
 	dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
 
@@ -191,9 +185,7 @@ static int dcon_set_mono_mode(struct dcon_priv *dcon, bool enable_mono)
 		dcon->disp_mode |= MODE_MONO_LUMA;
 	} else {
 		dcon->disp_mode &= ~(MODE_MONO_LUMA);
-		dcon->disp_mode |= MODE_CSWIZZLE;
-		if (useaa)
-			dcon->disp_mode |= MODE_COL_AA;
+		dcon->disp_mode |= MODE_CSWIZZLE | MODE_COL_AA;
 	}
 
 	dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);

commit ac9bbd085f5d22a2f01a03cb79abe740412bdae1
Author: Toshiaki Yamane <yamanetoshi@gmail.com>
Date:   Fri Aug 17 14:37:21 2012 +0900

    staging/olpc_dcon: fix checkpatch warnings
    
    The below checkpatch warnings was fixed,
    
    -  WARNING: Prefer pr_debug(... to printk(KERN_DEBUG, ...
    -  WARNING: Prefer pr_warn(... to printk(KERN_WARNING, ...
    -  WARNING: Prefer pr_info(... to printk(KERN_INFO, ...
    -  WARNING: Prefer pr_err(... to printk(KERN_ERR, ...
    
    And added pr_fmt.
    
    Signed-off-by: Toshiaki Yamane <yamanetoshi@gmail.com>
    Acked-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 2c4bd746715a..d49c32a95690 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -11,6 +11,7 @@
  * License as published by the Free Software Foundation.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/kernel.h>
 #include <linux/fb.h>
@@ -72,18 +73,16 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 
 	ver = dcon_read(dcon, DCON_REG_ID);
 	if ((ver >> 8) != 0xDC) {
-		printk(KERN_ERR "olpc-dcon:  DCON ID not 0xDCxx: 0x%04x instead.\n",
-			ver);
+		pr_err("DCON ID not 0xDCxx: 0x%04x instead.\n", ver);
 		rc = -ENXIO;
 		goto err;
 	}
 
 	if (is_init) {
-		printk(KERN_INFO "olpc-dcon:  Discovered DCON version %x\n",
-				ver & 0xFF);
+		pr_info("Discovered DCON version %x\n", ver & 0xFF);
 		rc = pdata->init(dcon);
 		if (rc != 0) {
-			printk(KERN_ERR "olpc-dcon:  Unable to init.\n");
+			pr_err("Unable to init.\n");
 			goto err;
 		}
 	}
@@ -137,8 +136,7 @@ static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 		x = 1;
 		x = olpc_ec_cmd(0x26, (unsigned char *)&x, 1, NULL, 0);
 		if (x) {
-			printk(KERN_WARNING "olpc-dcon:  unable to force dcon to power up: %d!\n",
-				x);
+			pr_warn("unable to force dcon to power up: %d!\n", x);
 			return x;
 		}
 		msleep(10); /* we'll be conservative */
@@ -151,7 +149,7 @@ static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 		x = dcon_read(dcon, DCON_REG_ID);
 	}
 	if (x < 0) {
-		printk(KERN_ERR "olpc-dcon:  unable to stabilize dcon's smbus, reasserting power and praying.\n");
+		pr_err("unable to stabilize dcon's smbus, reasserting power and praying.\n");
 		BUG_ON(olpc_board_at_least(olpc_board(0xc2)));
 		x = 0;
 		olpc_ec_cmd(0x26, (unsigned char *)&x, 1, NULL, 0);
@@ -222,8 +220,7 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
 		x = 0;
 		x = olpc_ec_cmd(0x26, (unsigned char *)&x, 1, NULL, 0);
 		if (x)
-			printk(KERN_WARNING "olpc-dcon:  unable to force dcon to power down: %d!\n",
-				x);
+			pr_warn("unable to force dcon to power down: %d!\n", x);
 		else
 			dcon->asleep = sleep;
 	} else {
@@ -232,8 +229,7 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
 			dcon->disp_mode |= MODE_BL_ENABLE;
 		x = dcon_bus_stabilize(dcon, 1);
 		if (x)
-			printk(KERN_WARNING "olpc-dcon:  unable to reinit dcon hardware: %d!\n",
-				x);
+			pr_warn("unable to reinit dcon hardware: %d!\n", x);
 		else
 			dcon->asleep = sleep;
 
@@ -304,12 +300,11 @@ static void dcon_source_switch(struct work_struct *work)
 
 	switch (source) {
 	case DCON_SOURCE_CPU:
-		printk(KERN_INFO "dcon_source_switch to CPU\n");
+		pr_info("dcon_source_switch to CPU\n");
 		/* Enable the scanline interrupt bit */
 		if (dcon_write(dcon, DCON_REG_MODE,
 				dcon->disp_mode | MODE_SCAN_INT))
-			printk(KERN_ERR
-			       "olpc-dcon:  couldn't enable scanline interrupt!\n");
+			pr_err("couldn't enable scanline interrupt!\n");
 		else {
 			/* Wait up to one second for the scanline interrupt */
 			wait_event_timeout(dcon_wait_queue,
@@ -317,11 +312,11 @@ static void dcon_source_switch(struct work_struct *work)
 		}
 
 		if (!dcon->switched)
-			printk(KERN_ERR "olpc-dcon:  Timeout entering CPU mode; expect a screen glitch.\n");
+			pr_err("Timeout entering CPU mode; expect a screen glitch.\n");
 
 		/* Turn off the scanline interrupt */
 		if (dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode))
-			printk(KERN_ERR "olpc-dcon:  couldn't disable scanline interrupt!\n");
+			pr_err("couldn't disable scanline interrupt!\n");
 
 		/*
 		 * Ideally we'd like to disable interrupts here so that the
@@ -332,7 +327,7 @@ static void dcon_source_switch(struct work_struct *work)
 		 * For now, we just hope..
 		 */
 		if (!dcon_blank_fb(dcon, false)) {
-			printk(KERN_ERR "olpc-dcon:  Failed to enter CPU mode\n");
+			pr_err("Failed to enter CPU mode\n");
 			dcon->pending_src = DCON_SOURCE_DCON;
 			return;
 		}
@@ -341,14 +336,14 @@ static void dcon_source_switch(struct work_struct *work)
 		pdata->set_dconload(1);
 		getnstimeofday(&dcon->load_time);
 
-		printk(KERN_INFO "olpc-dcon: The CPU has control\n");
+		pr_info("The CPU has control\n");
 		break;
 	case DCON_SOURCE_DCON:
 	{
 		int t;
 		struct timespec delta_t;
 
-		printk(KERN_INFO "dcon_source_switch to DCON\n");
+		pr_info("dcon_source_switch to DCON\n");
 
 		add_wait_queue(&dcon_wait_queue, &wait);
 		set_current_state(TASK_UNINTERRUPTIBLE);
@@ -362,7 +357,7 @@ static void dcon_source_switch(struct work_struct *work)
 		set_current_state(TASK_RUNNING);
 
 		if (!dcon->switched) {
-			printk(KERN_ERR "olpc-dcon: Timeout entering DCON mode; expect a screen glitch.\n");
+			pr_err("Timeout entering DCON mode; expect a screen glitch.\n");
 		} else {
 			/* sometimes the DCON doesn't follow its own rules,
 			 * and doesn't wait for two vsync pulses before
@@ -378,7 +373,7 @@ static void dcon_source_switch(struct work_struct *work)
 			delta_t = timespec_sub(dcon->irq_time, dcon->load_time);
 			if (dcon->switched && delta_t.tv_sec == 0 &&
 					delta_t.tv_nsec < NSEC_PER_MSEC * 20) {
-				printk(KERN_ERR "olpc-dcon: missed loading, retrying\n");
+				pr_err("missed loading, retrying\n");
 				pdata->set_dconload(1);
 				mdelay(41);
 				pdata->set_dconload(0);
@@ -388,7 +383,7 @@ static void dcon_source_switch(struct work_struct *work)
 		}
 
 		dcon_blank_fb(dcon, true);
-		printk(KERN_INFO "olpc-dcon: The DCON has control\n");
+		pr_info("The DCON has control\n");
 		break;
 	}
 	default:
@@ -476,7 +471,7 @@ static ssize_t dcon_freeze_store(struct device *dev,
 	if (ret)
 		return ret;
 
-	printk(KERN_INFO "dcon_freeze_store: %lu\n", output);
+	pr_info("dcon_freeze_store: %lu\n", output);
 
 	switch (output) {
 	case 0:
@@ -650,7 +645,7 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	dcon_device = platform_device_alloc("dcon", -1);
 
 	if (dcon_device == NULL) {
-		printk(KERN_ERR "dcon:  Unable to create the DCON device\n");
+		pr_err("Unable to create the DCON device\n");
 		rc = -ENOMEM;
 		goto eirq;
 	}
@@ -658,7 +653,7 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	platform_set_drvdata(dcon_device, dcon);
 
 	if (rc) {
-		printk(KERN_ERR "dcon:  Unable to add the DCON device\n");
+		pr_err("Unable to add the DCON device\n");
 		goto edev;
 	}
 
@@ -762,7 +757,7 @@ irqreturn_t dcon_interrupt(int irq, void *id)
 
 	switch (status & 3) {
 	case 3:
-		printk(KERN_DEBUG "olpc-dcon: DCONLOAD_MISSED interrupt\n");
+		pr_debug("DCONLOAD_MISSED interrupt\n");
 		break;
 
 	case 2:	/* switch to DCON mode */
@@ -784,9 +779,9 @@ irqreturn_t dcon_interrupt(int irq, void *id)
 			dcon->switched = true;
 			getnstimeofday(&dcon->irq_time);
 			wake_up(&dcon_wait_queue);
-			printk(KERN_DEBUG "olpc-dcon: switching w/ status 0/0\n");
+			pr_debug("switching w/ status 0/0\n");
 		} else {
-			printk(KERN_DEBUG "olpc-dcon: scanline interrupt w/CPU\n");
+			pr_debug("scanline interrupt w/CPU\n");
 		}
 	}
 

commit 3bf9428f220911795edde453a95f9509945004e5
Author: Andres Salomon <dilinger@queued.net>
Date:   Wed Jul 11 01:16:29 2012 -0700

    drivers: OLPC: update various drivers to include olpc-ec.h
    
    Switch over to using olpc-ec.h in multiple steps, so as not to break builds.
    This covers every driver that calls olpc_ec_cmd().
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Acked-by: Paul Fox <pgf@laptop.org>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 992275c0d87c..2c4bd746715a 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -27,6 +27,7 @@
 #include <linux/uaccess.h>
 #include <linux/ctype.h>
 #include <linux/reboot.h>
+#include <linux/olpc-ec.h>
 #include <asm/tsc.h>
 #include <asm/olpc.h>
 

commit c25626871c082432ae265594d4b336ccbeec4120
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Sat Apr 21 20:33:15 2012 +0200

    staging: olpc_dcon.c: Remove a few spaces between casts and variables
    
    Just a trivial style cleanup.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Acked-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 7fe6eb6fc386..992275c0d87c 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -134,7 +134,7 @@ static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 power_up:
 	if (is_powered_down) {
 		x = 1;
-		x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);
+		x = olpc_ec_cmd(0x26, (unsigned char *)&x, 1, NULL, 0);
 		if (x) {
 			printk(KERN_WARNING "olpc-dcon:  unable to force dcon to power up: %d!\n",
 				x);
@@ -153,7 +153,7 @@ static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 		printk(KERN_ERR "olpc-dcon:  unable to stabilize dcon's smbus, reasserting power and praying.\n");
 		BUG_ON(olpc_board_at_least(olpc_board(0xc2)));
 		x = 0;
-		olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);
+		olpc_ec_cmd(0x26, (unsigned char *)&x, 1, NULL, 0);
 		msleep(100);
 		is_powered_down = 1;
 		goto power_up;	/* argh, stupid hardware.. */
@@ -219,7 +219,7 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
 
 	if (sleep) {
 		x = 0;
-		x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);
+		x = olpc_ec_cmd(0x26, (unsigned char *)&x, 1, NULL, 0);
 		if (x)
 			printk(KERN_WARNING "olpc-dcon:  unable to force dcon to power down: %d!\n",
 				x);
@@ -598,7 +598,7 @@ static int dcon_fb_notifier(struct notifier_block *self,
 	struct fb_event *evdata = data;
 	struct dcon_priv *dcon = container_of(self, struct dcon_priv,
 			fbevent_nb);
-	int *blank = (int *) evdata->data;
+	int *blank = (int *)evdata->data;
 	if (((event != FB_EVENT_BLANK) && (event != FB_EVENT_CONBLANK)) ||
 			dcon->ignore_fb_events)
 		return 0;

commit 5d2130862b1fbea27fb21b4d4be62f787f5d2898
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Sat Apr 21 20:33:07 2012 +0200

    staging: olpc_dcon.c: Add missing level to a printk()
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Acked-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 862dbb5a1563..7fe6eb6fc386 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -303,7 +303,7 @@ static void dcon_source_switch(struct work_struct *work)
 
 	switch (source) {
 	case DCON_SOURCE_CPU:
-		printk("dcon_source_switch to CPU\n");
+		printk(KERN_INFO "dcon_source_switch to CPU\n");
 		/* Enable the scanline interrupt bit */
 		if (dcon_write(dcon, DCON_REG_MODE,
 				dcon->disp_mode | MODE_SCAN_INT))

commit 332a81961303dccac8bd3cb5c68aff1b3a6daeb6
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Sat Apr 21 20:32:52 2012 +0200

    staging: olpc_dcon.c: strings printed with printk() put on a single line
    
    Quoted strings that were broken over multiple lines are put on a
    single line for easier grep'ability.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Acked-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 3d9199320d86..862dbb5a1563 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -71,8 +71,8 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 
 	ver = dcon_read(dcon, DCON_REG_ID);
 	if ((ver >> 8) != 0xDC) {
-		printk(KERN_ERR "olpc-dcon:  DCON ID not 0xDCxx: 0x%04x "
-				"instead.\n", ver);
+		printk(KERN_ERR "olpc-dcon:  DCON ID not 0xDCxx: 0x%04x instead.\n",
+			ver);
 		rc = -ENXIO;
 		goto err;
 	}
@@ -136,8 +136,8 @@ static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 		x = 1;
 		x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);
 		if (x) {
-			printk(KERN_WARNING "olpc-dcon:  unable to force dcon "
-					"to power up: %d!\n", x);
+			printk(KERN_WARNING "olpc-dcon:  unable to force dcon to power up: %d!\n",
+				x);
 			return x;
 		}
 		msleep(10); /* we'll be conservative */
@@ -150,8 +150,7 @@ static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 		x = dcon_read(dcon, DCON_REG_ID);
 	}
 	if (x < 0) {
-		printk(KERN_ERR "olpc-dcon:  unable to stabilize dcon's "
-				"smbus, reasserting power and praying.\n");
+		printk(KERN_ERR "olpc-dcon:  unable to stabilize dcon's smbus, reasserting power and praying.\n");
 		BUG_ON(olpc_board_at_least(olpc_board(0xc2)));
 		x = 0;
 		olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);
@@ -222,8 +221,8 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
 		x = 0;
 		x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);
 		if (x)
-			printk(KERN_WARNING "olpc-dcon:  unable to force dcon "
-					"to power down: %d!\n", x);
+			printk(KERN_WARNING "olpc-dcon:  unable to force dcon to power down: %d!\n",
+				x);
 		else
 			dcon->asleep = sleep;
 	} else {
@@ -232,8 +231,8 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
 			dcon->disp_mode |= MODE_BL_ENABLE;
 		x = dcon_bus_stabilize(dcon, 1);
 		if (x)
-			printk(KERN_WARNING "olpc-dcon:  unable to reinit dcon"
-					" hardware: %d!\n", x);
+			printk(KERN_WARNING "olpc-dcon:  unable to reinit dcon hardware: %d!\n",
+				x);
 		else
 			dcon->asleep = sleep;
 

commit c542341dff7cd818015247d290aa0971888a7b08
Author: Valentin Rothberg <valentinrothberg@googlemail.com>
Date:   Mon Dec 5 11:02:35 2011 +0100

    Staging: olpc_dcon.c: obsolete use of strict_stroul
    
    As Dan mentioned, dcon_write() will only write u16 values. The
    appropriate parts have been changed. As a result of module_param()
    not accepting u16 as a valid data type, ushort is used.
    
    Signed-off-by: Valentin Rothberg <valentinrothberg@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 72b7ff108200..3d9199320d86 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -34,8 +34,8 @@
 
 /* Module definitions */
 
-static int resumeline = 898;
-module_param(resumeline, int, 0444);
+static ushort resumeline = 898;
+module_param(resumeline, ushort, 0444);
 
 /* Default off since it doesn't work on DCON ASIC in B-test OLPC board */
 static int useaa = 1;
@@ -498,10 +498,10 @@ static ssize_t dcon_freeze_store(struct device *dev,
 static ssize_t dcon_resumeline_store(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
-	unsigned long rl;
+	unsigned short rl;
 	int rc;
 
-	rc = strict_strtoul(buf, 10, &rl);
+	rc = kstrtou16(buf, 10, &rl);
 	if (rc)
 		return rc;
 

commit 88e09a5e30a2b768480ab52628043e7d30a0e079
Author: Valentin Rothberg <valentinrothberg@googlemail.com>
Date:   Sun Dec 4 12:17:32 2011 +0100

    Staging: olpc_dcon.c: obsolete use of strict_strtoul
    
    As noted by the checkpatch script, strict_strtoul is obsolete. Unsigned
    longs are used, so it seems good to take kstrtoul.
    
    Signed-off-by: Valentin Rothberg <valentinrothberg@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index c379bba4c178..72b7ff108200 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -456,7 +456,7 @@ static ssize_t dcon_mono_store(struct device *dev,
 	unsigned long enable_mono;
 	int rc;
 
-	rc = strict_strtoul(buf, 10, &enable_mono);
+	rc = kstrtoul(buf, 10, &enable_mono);
 	if (rc)
 		return rc;
 
@@ -472,7 +472,7 @@ static ssize_t dcon_freeze_store(struct device *dev,
 	unsigned long output;
 	int ret;
 
-	ret = strict_strtoul(buf, 10, &output);
+	ret = kstrtoul(buf, 10, &output);
 	if (ret)
 		return ret;
 
@@ -517,7 +517,7 @@ static ssize_t dcon_sleep_store(struct device *dev,
 	unsigned long output;
 	int ret;
 
-	ret = strict_strtoul(buf, 10, &output);
+	ret = kstrtoul(buf, 10, &output);
 	if (ret)
 		return ret;
 

commit 91762057f439bb0adb33ca857b6022fda4b1fd69
Author: Xi Wang <xi.wang@gmail.com>
Date:   Fri Dec 2 16:28:43 2011 -0500

    staging: olpc_dcon: ->read_status() API change
    
    Change ->read_status() by separating the error handling and the
    status bits.  This also fixes a signedness bug in dcon_interrupt()
    that would break the error handling.
    
    Signed-off-by: Xi Wang <xi.wang@gmail.com>
    Acked-by: Andres Salomon <dilinger@queued.net>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index af24ddfb58c9..c379bba4c178 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -755,9 +755,9 @@ static int dcon_resume(struct i2c_client *client)
 irqreturn_t dcon_interrupt(int irq, void *id)
 {
 	struct dcon_priv *dcon = id;
-	int status = pdata->read_status();
+	u8 status;
 
-	if (status == -1)
+	if (pdata->read_status(&status))
 		return IRQ_NONE;
 
 	switch (status & 3) {

commit 99c978529a40132a6f7a5f136b4362b56fc88d8c
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 3 15:49:50 2011 -0400

    staging: Add module.h to drivers/staging users
    
    Lots of people expect module.h to just "be there" without
    any #include effort.  But we are crushing that.  So fix those
    files in staging relying on implicit module.h presence.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index d3cd68e9045e..af24ddfb58c9 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -21,6 +21,7 @@
 #include <linux/pci_ids.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
+#include <linux/module.h>
 #include <linux/backlight.h>
 #include <linux/device.h>
 #include <linux/uaccess.h>

commit 42b565df8567751dfdca85b57de6219ddfee49f8
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Thu Aug 25 12:53:30 2011 +0200

    staging/olpc_dcon: Remove obsolete cleanup for clientdata
    
    A few new i2c-drivers came into the kernel which clear the clientdata-pointer
    on exit or error. This is obsolete meanwhile, the core will do it.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Andres Salomon <dilinger@queued.net>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Marek Belisko <marek.belisko@open-nandra.com>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 87268059eb45..d3cd68e9045e 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -697,7 +697,6 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
  eirq:
 	free_irq(DCON_IRQ, dcon);
  einit:
-	i2c_set_clientdata(client, NULL);
 	kfree(dcon);
 	return rc;
 }
@@ -706,8 +705,6 @@ static int dcon_remove(struct i2c_client *client)
 {
 	struct dcon_priv *dcon = i2c_get_clientdata(client);
 
-	i2c_set_clientdata(client, NULL);
-
 	fb_unregister_client(&dcon->fbevent_nb);
 	unregister_reboot_notifier(&dcon->reboot_nb);
 	atomic_notifier_chain_unregister(&panic_notifier_list, &dcon_panic_nb);

commit 0b7a41ebb1bbee4be49e53497dc98e5517f2a2a8
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Jul 21 20:38:01 2011 -0700

    staging: olpc_dcon: replace remaining calls to i2c_smbus_read/write
    
    Use dcon_read and dcon_write; shorter, and understands the dcon_priv
    struct.  This transition was started long ago.  This converts the
    last few i2c_smbus_* callers.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index ae18cd455fd9..87268059eb45 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -65,11 +65,10 @@ static s32 dcon_read(struct dcon_priv *dcon, u8 reg)
 
 static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 {
-	struct i2c_client *client = dcon->client;
 	uint16_t ver;
 	int rc = 0;
 
-	ver = i2c_smbus_read_word_data(client, DCON_REG_ID);
+	ver = dcon_read(dcon, DCON_REG_ID);
 	if ((ver >> 8) != 0xDC) {
 		printk(KERN_ERR "olpc-dcon:  DCON ID not 0xDCxx: 0x%04x "
 				"instead.\n", ver);
@@ -95,10 +94,10 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 	}
 
 	/* SDRAM setup/hold time */
-	i2c_smbus_write_word_data(client, 0x3a, 0xc040);
-	i2c_smbus_write_word_data(client, 0x41, 0x0000);
-	i2c_smbus_write_word_data(client, 0x41, 0x0101);
-	i2c_smbus_write_word_data(client, 0x42, 0x0101);
+	dcon_write(dcon, 0x3a, 0xc040);
+	dcon_write(dcon, 0x41, 0x0000);
+	dcon_write(dcon, 0x41, 0x0101);
+	dcon_write(dcon, 0x42, 0x0101);
 
 	/* Colour swizzle, AA, no passthrough, backlight */
 	if (is_init) {
@@ -107,11 +106,11 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 		if (useaa)
 			dcon->disp_mode |= MODE_COL_AA;
 	}
-	i2c_smbus_write_word_data(client, DCON_REG_MODE, dcon->disp_mode);
+	dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
 
 
 	/* Set the scanline to interrupt on during resume */
-	i2c_smbus_write_word_data(client, DCON_REG_SCAN_INT, resumeline);
+	dcon_write(dcon, DCON_REG_SCAN_INT, resumeline);
 
 err:
 	return rc;

commit 1b995ac22b53c6176e61a38558c8a8d16be24b69
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Jul 21 20:37:55 2011 -0700

    staging: olpc_dcon: drop support for DCON v1
    
    The v1 DCONs only existed for XO-1 prototypes (and even then, very very
    early prototypes).  Drop support for v1 DCON.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index cf4b45440f67..ae18cd455fd9 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -88,29 +88,18 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 	}
 
 	if (ver < 0xdc02) {
-		/* Initialize the DCON registers */
-
-		/* Start with work-arounds for DCON ASIC */
-		i2c_smbus_write_word_data(client, 0x4b, 0x00cc);
-		i2c_smbus_write_word_data(client, 0x4b, 0x00cc);
-		i2c_smbus_write_word_data(client, 0x4b, 0x00cc);
-		i2c_smbus_write_word_data(client, 0x0b, 0x007a);
-		i2c_smbus_write_word_data(client, 0x36, 0x025c);
-		i2c_smbus_write_word_data(client, 0x37, 0x025e);
-
-		/* Initialise SDRAM */
-
-		i2c_smbus_write_word_data(client, 0x3b, 0x002b);
-		i2c_smbus_write_word_data(client, 0x41, 0x0101);
-		i2c_smbus_write_word_data(client, 0x42, 0x0101);
-	} else {
-		/* SDRAM setup/hold time */
-		i2c_smbus_write_word_data(client, 0x3a, 0xc040);
-		i2c_smbus_write_word_data(client, 0x41, 0x0000);
-		i2c_smbus_write_word_data(client, 0x41, 0x0101);
-		i2c_smbus_write_word_data(client, 0x42, 0x0101);
+		dev_err(&dcon->client->dev,
+				"DCON v1 is unsupported, giving up..\n");
+		rc = -ENODEV;
+		goto err;
 	}
 
+	/* SDRAM setup/hold time */
+	i2c_smbus_write_word_data(client, 0x3a, 0xc040);
+	i2c_smbus_write_word_data(client, 0x41, 0x0000);
+	i2c_smbus_write_word_data(client, 0x41, 0x0101);
+	i2c_smbus_write_word_data(client, 0x42, 0x0101);
+
 	/* Colour swizzle, AA, no passthrough, backlight */
 	if (is_init) {
 		dcon->disp_mode = MODE_PASSTHRU | MODE_BL_ENABLE |

commit 24e2617050d9ceb2cd8200982249529c81c5f310
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Jul 21 20:37:43 2011 -0700

    staging: olpc_dcon: remove noinit module variable
    
    This came from Jordan's original 2007 gxfb_dcon commit.  I've never
    seen or heard of it actually being used.  Presumably it was once
    useful for skipping hardware initialization when reloading the module
    over and over during driver development..
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 750fe5045efa..cf4b45440f67 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -36,9 +36,6 @@
 static int resumeline = 898;
 module_param(resumeline, int, 0444);
 
-static int noinit;
-module_param(noinit, int, 0444);
-
 /* Default off since it doesn't work on DCON ASIC in B-test OLPC board */
 static int useaa = 1;
 module_param(useaa, int, 0444);
@@ -90,7 +87,7 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 		}
 	}
 
-	if (ver < 0xdc02 && !noinit) {
+	if (ver < 0xdc02) {
 		/* Initialize the DCON registers */
 
 		/* Start with work-arounds for DCON ASIC */
@@ -106,7 +103,7 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 		i2c_smbus_write_word_data(client, 0x3b, 0x002b);
 		i2c_smbus_write_word_data(client, 0x41, 0x0101);
 		i2c_smbus_write_word_data(client, 0x42, 0x0101);
-	} else if (!noinit) {
+	} else {
 		/* SDRAM setup/hold time */
 		i2c_smbus_write_word_data(client, 0x3a, 0xc040);
 		i2c_smbus_write_word_data(client, 0x41, 0x0000);

commit bb7ca747f8d6243b3943c5b133048652020f4a50
Author: Matthew Garrett <mjg@redhat.com>
Date:   Tue Mar 22 16:30:21 2011 -0700

    backlight: add backlight type
    
    There may be multiple ways of controlling the backlight on a given
    machine.  Allow drivers to expose the type of interface they are
    providing, making it possible for userspace to make appropriate policy
    decisions.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index b90c2cf3e247..750fe5045efa 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -574,6 +574,7 @@ static const struct backlight_ops dcon_bl_ops = {
 
 static struct backlight_properties dcon_bl_props = {
 	.max_brightness = 15,
+	.type = BACKLIGHT_RAW,
 	.power = FB_BLANK_UNBLANK,
 };
 

commit c59eef17f1cc21a984cf077ad45a8355781881b6
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Feb 10 17:56:27 2011 -0800

    staging: olpc_dcon: clean up backlight handling
    
     - Move bl_val and bl_dev into dcon_priv struct....
     - The only time we ever read the backlight val from the dcon is
       at probe time.  Rather than calling dcon_get_backlight for that, just
       read from the register.
     - Drop dcon_get_backlight; it's just returning dcon->bl_val.
     - Rename dcon_set_backlight_hw to dcon_set_backlight, and drop the
       old dcon_set_backlight function.  Move contents of old dcon_set_backlight
       function into dconbl_set.
     - Shuffle backlight_ops callbacks around to be closer to struct, and
       rename them.
     - Make use of new backlight_properties arg to backlight_device_register,
       drop old code that set this manually.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 07abdfa4ad48..b90c2cf3e247 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -50,9 +50,6 @@ static struct dcon_platform_data *pdata;
 /* Platform devices */
 static struct platform_device *dcon_device;
 
-/* Backlight device */
-static struct backlight_device *dcon_bl_dev;
-
 static DECLARE_WAIT_QUEUE_HEAD(dcon_wait_queue);
 
 static unsigned short normal_i2c[] = { 0x0d, I2C_CLIENT_END };
@@ -67,9 +64,6 @@ static s32 dcon_read(struct dcon_priv *dcon, u8 reg)
 	return i2c_smbus_read_word_data(dcon->client, reg);
 }
 
-/* The current backlight value - this saves us some smbus traffic */
-static int bl_val = -1;
-
 /* ===== API functions - these are called by a variety of users ==== */
 
 static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
@@ -185,25 +179,13 @@ static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 	return 0;
 }
 
-static int dcon_get_backlight(struct dcon_priv *dcon)
+static void dcon_set_backlight(struct dcon_priv *dcon, u8 level)
 {
-	if (!dcon || !dcon->client)
-		return 0;
-
-	if (bl_val == -1)
-		bl_val = dcon_read(dcon, DCON_REG_BRIGHT) & 0x0F;
-
-	return bl_val;
-}
-
-
-static void dcon_set_backlight_hw(struct dcon_priv *dcon, int level)
-{
-	bl_val = level & 0x0F;
-	dcon_write(dcon, DCON_REG_BRIGHT, bl_val);
+	dcon->bl_val = level;
+	dcon_write(dcon, DCON_REG_BRIGHT, dcon->bl_val);
 
 	/* Purposely turn off the backlight when we go to level 0 */
-	if (bl_val == 0) {
+	if (dcon->bl_val == 0) {
 		dcon->disp_mode &= ~MODE_BL_ENABLE;
 		dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
 	} else if (!(dcon->disp_mode & MODE_BL_ENABLE)) {
@@ -212,17 +194,6 @@ static void dcon_set_backlight_hw(struct dcon_priv *dcon, int level)
 	}
 }
 
-static void dcon_set_backlight(struct dcon_priv *dcon, int level)
-{
-	if (!dcon || !dcon->client)
-		return;
-
-	if (bl_val == (level & 0x0F))
-		return;
-
-	dcon_set_backlight_hw(dcon, level);
-}
-
 /* Set the output type to either color or mono */
 static int dcon_set_mono_mode(struct dcon_priv *dcon, bool enable_mono)
 {
@@ -271,7 +242,7 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
 			dcon->asleep = sleep;
 	} else {
 		/* Only re-enable the backlight if the backlight value is set */
-		if (bl_val != 0)
+		if (dcon->bl_val != 0)
 			dcon->disp_mode |= MODE_BL_ENABLE;
 		x = dcon_bus_stabilize(dcon, 1);
 		if (x)
@@ -281,7 +252,7 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
 			dcon->asleep = sleep;
 
 		/* Restore backlight */
-		dcon_set_backlight_hw(dcon, bl_val);
+		dcon_set_backlight(dcon, dcon->bl_val);
 	}
 
 	/* We should turn off some stuff in the framebuffer - but what? */
@@ -458,24 +429,6 @@ static void dcon_set_source_sync(struct dcon_priv *dcon, int arg)
 	flush_scheduled_work();
 }
 
-static int dconbl_set(struct backlight_device *dev)
-{
-	struct dcon_priv *dcon = bl_get_data(dev);
-	int level = dev->props.brightness;
-
-	if (dev->props.power != FB_BLANK_UNBLANK)
-		level = 0;
-
-	dcon_set_backlight(dcon, level);
-	return 0;
-}
-
-static int dconbl_get(struct backlight_device *dev)
-{
-	struct dcon_priv *dcon = bl_get_data(dev);
-	return dcon_get_backlight(dcon);
-}
-
 static ssize_t dcon_mode_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
@@ -594,11 +547,35 @@ static struct device_attribute dcon_device_files[] = {
 	__ATTR(resumeline, 0644, dcon_resumeline_show, dcon_resumeline_store),
 };
 
+static int dcon_bl_update(struct backlight_device *dev)
+{
+	struct dcon_priv *dcon = bl_get_data(dev);
+	u8 level = dev->props.brightness & 0x0F;
+
+	if (dev->props.power != FB_BLANK_UNBLANK)
+		level = 0;
+
+	if (level != dcon->bl_val)
+		dcon_set_backlight(dcon, level);
+
+	return 0;
+}
+
+static int dcon_bl_get(struct backlight_device *dev)
+{
+	struct dcon_priv *dcon = bl_get_data(dev);
+	return dcon->bl_val;
+}
+
 static const struct backlight_ops dcon_bl_ops = {
-	.get_brightness = dconbl_get,
-	.update_status = dconbl_set
+	.update_status = dcon_bl_update,
+	.get_brightness = dcon_bl_get,
 };
 
+static struct backlight_properties dcon_bl_props = {
+	.max_brightness = 15,
+	.power = FB_BLANK_UNBLANK,
+};
 
 static int dcon_reboot_notify(struct notifier_block *nb,
 			      unsigned long foo, void *bar)
@@ -707,20 +684,16 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		}
 	}
 
-	/* Add the backlight device for the DCON */
-	dcon_bl_dev = backlight_device_register("dcon-bl", &dcon_device->dev,
-		dcon, &dcon_bl_ops, NULL);
-
-	if (IS_ERR(dcon_bl_dev)) {
-		printk(KERN_ERR "Cannot register the backlight device (%ld)\n",
-		       PTR_ERR(dcon_bl_dev));
-		dcon_bl_dev = NULL;
-	} else {
-		dcon_bl_dev->props.max_brightness = 15;
-		dcon_bl_dev->props.power = FB_BLANK_UNBLANK;
-		dcon_bl_dev->props.brightness = dcon_get_backlight(dcon);
+	dcon->bl_val = dcon_read(dcon, DCON_REG_BRIGHT) & 0x0F;
 
-		backlight_update_status(dcon_bl_dev);
+	/* Add the backlight device for the DCON */
+	dcon_bl_props.brightness = dcon->bl_val;
+	dcon->bl_dev = backlight_device_register("dcon-bl", &dcon_device->dev,
+		dcon, &dcon_bl_ops, &dcon_bl_props);
+	if (IS_ERR(dcon->bl_dev)) {
+		dev_err(&client->dev, "cannot register backlight dev (%ld)\n",
+				PTR_ERR(dcon->bl_dev));
+		dcon->bl_dev = NULL;
 	}
 
 	register_reboot_notifier(&dcon->reboot_nb);
@@ -755,8 +728,8 @@ static int dcon_remove(struct i2c_client *client)
 
 	free_irq(DCON_IRQ, dcon);
 
-	if (dcon_bl_dev != NULL)
-		backlight_device_unregister(dcon_bl_dev);
+	if (dcon->bl_dev)
+		backlight_device_unregister(dcon->bl_dev);
 
 	if (dcon_device != NULL)
 		platform_device_unregister(dcon_device);

commit 309ef2a25e8d3d5962bb0824c58ea39c12c166ef
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Feb 10 17:54:58 2011 -0800

    staging: olpc_dcon: move more global variables into dcon_priv
    
    Global variables dcon_switched, dcon_irq_time, and dcon_load_time can all be moved
    into the dcon_priv struct now that dcon_interrupt has access to dcon_priv.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index cdd8718a7f99..07abdfa4ad48 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -53,11 +53,6 @@ static struct platform_device *dcon_device;
 /* Backlight device */
 static struct backlight_device *dcon_bl_dev;
 
-/* Variables used during switches */
-static int dcon_switched;
-static struct timespec dcon_irq_time;
-static struct timespec dcon_load_time;
-
 static DECLARE_WAIT_QUEUE_HEAD(dcon_wait_queue);
 
 static unsigned short normal_i2c[] = { 0x0d, I2C_CLIENT_END };
@@ -297,12 +292,12 @@ static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
  * normally we don't change it this fast, so in general we won't
  * delay here.
  */
-void dcon_load_holdoff(void)
+static void dcon_load_holdoff(struct dcon_priv *dcon)
 {
 	struct timespec delta_t, now;
 	while (1) {
 		getnstimeofday(&now);
-		delta_t = timespec_sub(now, dcon_load_time);
+		delta_t = timespec_sub(now, dcon->load_time);
 		if (delta_t.tv_sec != 0 ||
 			delta_t.tv_nsec > NSEC_PER_MSEC * 20) {
 			break;
@@ -346,9 +341,9 @@ static void dcon_source_switch(struct work_struct *work)
 	if (dcon->curr_src == source)
 		return;
 
-	dcon_load_holdoff();
+	dcon_load_holdoff(dcon);
 
-	dcon_switched = 0;
+	dcon->switched = false;
 
 	switch (source) {
 	case DCON_SOURCE_CPU:
@@ -361,10 +356,10 @@ static void dcon_source_switch(struct work_struct *work)
 		else {
 			/* Wait up to one second for the scanline interrupt */
 			wait_event_timeout(dcon_wait_queue,
-					   dcon_switched == 1, HZ);
+					   dcon->switched == true, HZ);
 		}
 
-		if (!dcon_switched)
+		if (!dcon->switched)
 			printk(KERN_ERR "olpc-dcon:  Timeout entering CPU mode; expect a screen glitch.\n");
 
 		/* Turn off the scanline interrupt */
@@ -387,7 +382,7 @@ static void dcon_source_switch(struct work_struct *work)
 
 		/* And turn off the DCON */
 		pdata->set_dconload(1);
-		getnstimeofday(&dcon_load_time);
+		getnstimeofday(&dcon->load_time);
 
 		printk(KERN_INFO "olpc-dcon: The CPU has control\n");
 		break;
@@ -403,13 +398,13 @@ static void dcon_source_switch(struct work_struct *work)
 
 		/* Clear DCONLOAD - this implies that the DCON is in control */
 		pdata->set_dconload(0);
-		getnstimeofday(&dcon_load_time);
+		getnstimeofday(&dcon->load_time);
 
 		t = schedule_timeout(HZ/2);
 		remove_wait_queue(&dcon_wait_queue, &wait);
 		set_current_state(TASK_RUNNING);
 
-		if (!dcon_switched) {
+		if (!dcon->switched) {
 			printk(KERN_ERR "olpc-dcon: Timeout entering DCON mode; expect a screen glitch.\n");
 		} else {
 			/* sometimes the DCON doesn't follow its own rules,
@@ -423,14 +418,14 @@ static void dcon_source_switch(struct work_struct *work)
 			 * deassert and reassert, and hope for the best.
 			 * see http://dev.laptop.org/ticket/9664
 			 */
-			delta_t = timespec_sub(dcon_irq_time, dcon_load_time);
-			if (dcon_switched && delta_t.tv_sec == 0 &&
+			delta_t = timespec_sub(dcon->irq_time, dcon->load_time);
+			if (dcon->switched && delta_t.tv_sec == 0 &&
 					delta_t.tv_nsec < NSEC_PER_MSEC * 20) {
 				printk(KERN_ERR "olpc-dcon: missed loading, retrying\n");
 				pdata->set_dconload(1);
 				mdelay(41);
 				pdata->set_dconload(0);
-				getnstimeofday(&dcon_load_time);
+				getnstimeofday(&dcon->load_time);
 				mdelay(41);
 			}
 		}
@@ -815,8 +810,8 @@ irqreturn_t dcon_interrupt(int irq, void *id)
 
 	case 2:	/* switch to DCON mode */
 	case 1: /* switch to CPU mode */
-		dcon_switched = 1;
-		getnstimeofday(&dcon_irq_time);
+		dcon->switched = true;
+		getnstimeofday(&dcon->irq_time);
 		wake_up(&dcon_wait_queue);
 		break;
 
@@ -828,9 +823,9 @@ irqreturn_t dcon_interrupt(int irq, void *id)
 		 * of the DCON happened long before this point.
 		 * see http://dev.laptop.org/ticket/9869
 		 */
-		if (dcon->curr_src != dcon->pending_src && !dcon_switched) {
-			dcon_switched = 1;
-			getnstimeofday(&dcon_irq_time);
+		if (dcon->curr_src != dcon->pending_src && !dcon->switched) {
+			dcon->switched = true;
+			getnstimeofday(&dcon->irq_time);
 			wake_up(&dcon_wait_queue);
 			printk(KERN_DEBUG "olpc-dcon: switching w/ status 0/0\n");
 		} else {

commit bbe963f1b98c90980e33086d726f0963e286d1b4
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Feb 10 17:54:24 2011 -0800

    staging: olpc_dcon: move more variables into dcon_priv
    
    This moves dcon_source and dcon_pending into the dcon_priv struct.
    
    Because these variables are used by the IRQ handler (which is
    registered in the model-specific callbacks), we end up needing
    to move dcon_priv into olpc_dcon.h.  This also changes the IRQ
    registration to use the dcon_priv pointer as dev_id, instead of
    dcon_driver.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 96b6fd26791b..cdd8718a7f99 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -23,7 +23,6 @@
 #include <linux/delay.h>
 #include <linux/backlight.h>
 #include <linux/device.h>
-#include <linux/notifier.h>
 #include <linux/uaccess.h>
 #include <linux/ctype.h>
 #include <linux/reboot.h>
@@ -46,24 +45,6 @@ module_param(useaa, int, 0444);
 
 static struct dcon_platform_data *pdata;
 
-struct dcon_priv {
-	struct i2c_client *client;
-	struct fb_info *fbinfo;
-
-	struct work_struct switch_source;
-	struct notifier_block reboot_nb;
-	struct notifier_block fbevent_nb;
-
-	/* Shadow register for the DCON_REG_MODE register */
-	u8 disp_mode;
-
-	/* Current output type; true == mono, false == color */
-	bool mono;
-	bool asleep;
-	/* This get set while controlling fb blank state from the driver */
-	bool ignore_fb_events;
-};
-
 /* I2C structures */
 
 /* Platform devices */
@@ -72,12 +53,6 @@ static struct platform_device *dcon_device;
 /* Backlight device */
 static struct backlight_device *dcon_bl_dev;
 
-/* Current source, initialized at probe time */
-int dcon_source;
-
-/* Desired source */
-int dcon_pending;
-
 /* Variables used during switches */
 static int dcon_switched;
 static struct timespec dcon_irq_time;
@@ -119,7 +94,7 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 	if (is_init) {
 		printk(KERN_INFO "olpc-dcon:  Discovered DCON version %x\n",
 				ver & 0xFF);
-		rc = pdata->init();
+		rc = pdata->init(dcon);
 		if (rc != 0) {
 			printk(KERN_ERR "olpc-dcon:  Unable to init.\n");
 			goto err;
@@ -366,9 +341,9 @@ static void dcon_source_switch(struct work_struct *work)
 	struct dcon_priv *dcon = container_of(work, struct dcon_priv,
 			switch_source);
 	DECLARE_WAITQUEUE(wait, current);
-	int source = dcon_pending;
+	int source = dcon->pending_src;
 
-	if (dcon_source == source)
+	if (dcon->curr_src == source)
 		return;
 
 	dcon_load_holdoff();
@@ -406,7 +381,7 @@ static void dcon_source_switch(struct work_struct *work)
 		 */
 		if (!dcon_blank_fb(dcon, false)) {
 			printk(KERN_ERR "olpc-dcon:  Failed to enter CPU mode\n");
-			dcon_pending = DCON_SOURCE_DCON;
+			dcon->pending_src = DCON_SOURCE_DCON;
 			return;
 		}
 
@@ -468,17 +443,17 @@ static void dcon_source_switch(struct work_struct *work)
 		BUG();
 	}
 
-	dcon_source = source;
+	dcon->curr_src = source;
 }
 
 static void dcon_set_source(struct dcon_priv *dcon, int arg)
 {
-	if (dcon_pending == arg)
+	if (dcon->pending_src == arg)
 		return;
 
-	dcon_pending = arg;
+	dcon->pending_src = arg;
 
-	if ((dcon_source != arg) && !work_pending(&dcon->switch_source))
+	if ((dcon->curr_src != arg) && !work_pending(&dcon->switch_source))
 		schedule_work(&dcon->switch_source);
 }
 
@@ -524,7 +499,8 @@ static ssize_t dcon_sleep_show(struct device *dev,
 static ssize_t dcon_freeze_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%d\n", dcon_source == DCON_SOURCE_DCON ? 1 : 0);
+	struct dcon_priv *dcon = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", dcon->curr_src == DCON_SOURCE_DCON ? 1 : 0);
 }
 
 static ssize_t dcon_mono_show(struct device *dev,
@@ -765,7 +741,7 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	platform_device_unregister(dcon_device);
 	dcon_device = NULL;
  eirq:
-	free_irq(DCON_IRQ, &dcon_driver);
+	free_irq(DCON_IRQ, dcon);
  einit:
 	i2c_set_clientdata(client, NULL);
 	kfree(dcon);
@@ -782,7 +758,7 @@ static int dcon_remove(struct i2c_client *client)
 	unregister_reboot_notifier(&dcon->reboot_nb);
 	atomic_notifier_chain_unregister(&panic_notifier_list, &dcon_panic_nb);
 
-	free_irq(DCON_IRQ, &dcon_driver);
+	free_irq(DCON_IRQ, dcon);
 
 	if (dcon_bl_dev != NULL)
 		backlight_device_unregister(dcon_bl_dev);
@@ -826,6 +802,7 @@ static int dcon_resume(struct i2c_client *client)
 
 irqreturn_t dcon_interrupt(int irq, void *id)
 {
+	struct dcon_priv *dcon = id;
 	int status = pdata->read_status();
 
 	if (status == -1)
@@ -851,7 +828,7 @@ irqreturn_t dcon_interrupt(int irq, void *id)
 		 * of the DCON happened long before this point.
 		 * see http://dev.laptop.org/ticket/9869
 		 */
-		if (dcon_source != dcon_pending && !dcon_switched) {
+		if (dcon->curr_src != dcon->pending_src && !dcon_switched) {
 			dcon_switched = 1;
 			getnstimeofday(&dcon_irq_time);
 			wake_up(&dcon_wait_queue);

commit 097cd83a4c312e1ae0d9c14526f846666cab4f3a
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Feb 10 17:53:24 2011 -0800

    staging: olpc_dcon: add config options for XO_1 and XO_1_5, drop hardcoded XO-1 stuff
    
    This adds CONFIG_FB_OLPC_DCON_1 and CONFIG_FB_OLPC_DCON_1_5 options for
    allowing selection of XO-1 and/or XO-1.5 DCON support.  In the process,
    it also forces the xo_1.c and xo_1_5.c files to build as separate units,
    correctly selects between XO-1 and XO-1.5 at runtime, and adds some
    hacks to allow xo_1_5.c to build.
    
    This isn't the cleanest patch, but it'll get better as more global
    variables are dropped.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 52b7b306a575..96b6fd26791b 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -4,7 +4,7 @@
  * Copyright © 2006-2007  Red Hat, Inc.
  * Copyright © 2006-2007  Advanced Micro Devices, Inc.
  * Copyright © 2009       VIA Technology, Inc.
- * Copyright (c) 2010  Andres Salomon <dilinger@queued.net>
+ * Copyright (c) 2010-2011  Andres Salomon <dilinger@queued.net>
  *
  * This program is free software.  You can redistribute it and/or
  * modify it under the terms of version 2 of the GNU General Public
@@ -44,13 +44,6 @@ module_param(noinit, int, 0444);
 static int useaa = 1;
 module_param(useaa, int, 0444);
 
-struct dcon_platform_data {
-	int (*init)(void);
-	void (*bus_stabilize_wiggle)(void);
-	void (*set_dconload)(int);
-	u8 (*read_status)(void);
-};
-
 static struct dcon_platform_data *pdata;
 
 struct dcon_priv {
@@ -73,8 +66,6 @@ struct dcon_priv {
 
 /* I2C structures */
 
-static struct i2c_driver dcon_driver;
-
 /* Platform devices */
 static struct platform_device *dcon_device;
 
@@ -82,10 +73,10 @@ static struct platform_device *dcon_device;
 static struct backlight_device *dcon_bl_dev;
 
 /* Current source, initialized at probe time */
-static int dcon_source;
+int dcon_source;
 
 /* Desired source */
-static int dcon_pending;
+int dcon_pending;
 
 /* Variables used during switches */
 static int dcon_switched;
@@ -693,6 +684,9 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	struct dcon_priv *dcon;
 	int rc, i, j;
 
+	if (!pdata)
+		return -ENXIO;
+
 	dcon = kzalloc(sizeof(*dcon), GFP_KERNEL);
 	if (!dcon)
 		return -ENOMEM;
@@ -830,7 +824,7 @@ static int dcon_resume(struct i2c_client *client)
 #endif
 
 
-static irqreturn_t dcon_interrupt(int irq, void *id)
+irqreturn_t dcon_interrupt(int irq, void *id)
 {
 	int status = pdata->read_status();
 
@@ -877,7 +871,7 @@ static const struct i2c_device_id dcon_idtable[] = {
 
 MODULE_DEVICE_TABLE(i2c, dcon_idtable);
 
-static struct i2c_driver dcon_driver = {
+struct i2c_driver dcon_driver = {
 	.driver = {
 		.name	= "olpc_dcon",
 	},
@@ -893,11 +887,17 @@ static struct i2c_driver dcon_driver = {
 #endif
 };
 
-#include "olpc_dcon_xo_1.c"
-
 static int __init olpc_dcon_init(void)
 {
-	pdata = &dcon_pdata_xo_1;
+#ifdef CONFIG_FB_OLPC_DCON_1_5
+	/* XO-1.5 */
+	if (olpc_board_at_least(olpc_board(0xd0)))
+		pdata = &dcon_pdata_xo_1_5;
+#endif
+#ifdef CONFIG_FB_OLPC_DCON_1
+	if (!pdata)
+		pdata = &dcon_pdata_xo_1;
+#endif
 
 	return i2c_add_driver(&dcon_driver);
 }

commit 31a3da4146c120e87b8d42d033760fe49704a233
Author: Marek Belisko <marek.belisko@open-nandra.com>
Date:   Thu Feb 10 17:49:24 2011 -0800

    staging: olpc_dcon: Remove _strtoul() function.
    
    olpc_dcon driver use self invented _strtoul  function
    which make similar check like strict_strtoul just extend
    for space checking at last string place. Normally access
    to sys file looks echo 1024 > /sys/... so space could be considered
    as error character and we could simplify code using just strict_strtoul
    function instead self invented.
    
    Signed-off-by: Marek Belisko <marek.belisko@open-nandra.com>
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index d3c280052d16..52b7b306a575 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -549,48 +549,33 @@ static ssize_t dcon_resumeline_show(struct device *dev,
 	return sprintf(buf, "%d\n", resumeline);
 }
 
-static int _strtoul(const char *buf, int len, unsigned int *val)
-{
-
-	char *endp;
-	unsigned int output = simple_strtoul(buf, &endp, 0);
-	int size = endp - buf;
-
-	if (*endp && isspace(*endp))
-		size++;
-
-	if (size != len)
-		return -EINVAL;
-
-	*val = output;
-	return 0;
-}
-
 static ssize_t dcon_mono_store(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
-	int enable_mono;
-	int rc = -EINVAL;
+	unsigned long enable_mono;
+	int rc;
 
-	if (_strtoul(buf, count, &enable_mono))
-		return -EINVAL;
+	rc = strict_strtoul(buf, 10, &enable_mono);
+	if (rc)
+		return rc;
 
 	dcon_set_mono_mode(dev_get_drvdata(dev), enable_mono ? true : false);
-	rc = count;
 
-	return rc;
+	return count;
 }
 
 static ssize_t dcon_freeze_store(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct dcon_priv *dcon = dev_get_drvdata(dev);
-	int output;
+	unsigned long output;
+	int ret;
 
-	if (_strtoul(buf, count, &output))
-		return -EINVAL;
+	ret = strict_strtoul(buf, 10, &output);
+	if (ret)
+		return ret;
 
-	printk(KERN_INFO "dcon_freeze_store: %d\n", output);
+	printk(KERN_INFO "dcon_freeze_store: %lu\n", output);
 
 	switch (output) {
 	case 0:
@@ -612,26 +597,28 @@ static ssize_t dcon_freeze_store(struct device *dev,
 static ssize_t dcon_resumeline_store(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
-	int rl;
-	int rc = -EINVAL;
+	unsigned long rl;
+	int rc;
 
-	if (_strtoul(buf, count, &rl))
+	rc = strict_strtoul(buf, 10, &rl);
+	if (rc)
 		return rc;
 
 	resumeline = rl;
 	dcon_write(dev_get_drvdata(dev), DCON_REG_SCAN_INT, resumeline);
-	rc = count;
 
-	return rc;
+	return count;
 }
 
 static ssize_t dcon_sleep_store(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
-	int output;
+	unsigned long output;
+	int ret;
 
-	if (_strtoul(buf, count, &output))
-		return -EINVAL;
+	ret = strict_strtoul(buf, 10, &output);
+	if (ret)
+		return ret;
 
 	dcon_sleep(dev_get_drvdata(dev), output ? true : false);
 	return count;

commit 45bfe97276856b866dd73fdadb65fb928c0c9bc1
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Feb 10 17:48:38 2011 -0800

    staging: olpc_dcon: move fb stuff info dcon_priv, and clean up fb handling
    
     - move fbinfo and ignore_fb_events into dcon_priv
     - add calls to {un,}lock_fb_info before calling fb_blank
     - fail to load the driver if there are no registered framebuffers
    
    That last one fixes a potential oops, where if the dcon driver loads
    without a framebuffer registered, fb_blank will end up being passed a
    NULL (and will attempt to dereference it).
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 710d88094d48..d3c280052d16 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -55,6 +55,7 @@ static struct dcon_platform_data *pdata;
 
 struct dcon_priv {
 	struct i2c_client *client;
+	struct fb_info *fbinfo;
 
 	struct work_struct switch_source;
 	struct notifier_block reboot_nb;
@@ -66,6 +67,8 @@ struct dcon_priv {
 	/* Current output type; true == mono, false == color */
 	bool mono;
 	bool asleep;
+	/* This get set while controlling fb blank state from the driver */
+	bool ignore_fb_events;
 };
 
 /* I2C structures */
@@ -78,11 +81,6 @@ static struct platform_device *dcon_device;
 /* Backlight device */
 static struct backlight_device *dcon_bl_dev;
 
-static struct fb_info *fbinfo;
-
-/* set this to 1 while controlling fb blank state from this driver */
-static int ignore_fb_events = 0;
-
 /* Current source, initialized at probe time */
 static int dcon_source;
 
@@ -346,8 +344,32 @@ void dcon_load_holdoff(void)
 		mdelay(4);
 	}
 }
-/* Set the source of the display (CPU or DCON) */
 
+static bool dcon_blank_fb(struct dcon_priv *dcon, bool blank)
+{
+	int err;
+
+	if (!lock_fb_info(dcon->fbinfo)) {
+		dev_err(&dcon->client->dev, "unable to lock framebuffer\n");
+		return false;
+	}
+	console_lock();
+	dcon->ignore_fb_events = true;
+	err = fb_blank(dcon->fbinfo,
+			blank ? FB_BLANK_POWERDOWN : FB_BLANK_UNBLANK);
+	dcon->ignore_fb_events = false;
+	console_unlock();
+	unlock_fb_info(dcon->fbinfo);
+
+	if (err) {
+		dev_err(&dcon->client->dev, "couldn't %sblank framebuffer\n",
+				blank ? "" : "un");
+		return false;
+	}
+	return true;
+}
+
+/* Set the source of the display (CPU or DCON) */
 static void dcon_source_switch(struct work_struct *work)
 {
 	struct dcon_priv *dcon = container_of(work, struct dcon_priv,
@@ -391,17 +413,11 @@ static void dcon_source_switch(struct work_struct *work)
 		 *
 		 * For now, we just hope..
 		 */
-		console_lock();
-		ignore_fb_events = 1;
-		if (fb_blank(fbinfo, FB_BLANK_UNBLANK)) {
-			ignore_fb_events = 0;
-			console_unlock();
+		if (!dcon_blank_fb(dcon, false)) {
 			printk(KERN_ERR "olpc-dcon:  Failed to enter CPU mode\n");
 			dcon_pending = DCON_SOURCE_DCON;
 			return;
 		}
-		ignore_fb_events = 0;
-		console_unlock();
 
 		/* And turn off the DCON */
 		pdata->set_dconload(1);
@@ -453,13 +469,7 @@ static void dcon_source_switch(struct work_struct *work)
 			}
 		}
 
-		console_lock();
-		ignore_fb_events = 1;
-		if (fb_blank(fbinfo, FB_BLANK_POWERDOWN))
-			printk(KERN_ERR "olpc-dcon:  couldn't blank fb!\n");
-		ignore_fb_events = 0;
-		console_unlock();
-
+		dcon_blank_fb(dcon, true);
 		printk(KERN_INFO "olpc-dcon: The DCON has control\n");
 		break;
 	}
@@ -678,7 +688,7 @@ static int dcon_fb_notifier(struct notifier_block *self,
 			fbevent_nb);
 	int *blank = (int *) evdata->data;
 	if (((event != FB_EVENT_BLANK) && (event != FB_EVENT_CONBLANK)) ||
-			ignore_fb_events)
+			dcon->ignore_fb_events)
 		return 0;
 	dcon_sleep(dcon, *blank ? true : false);
 	return 0;
@@ -708,8 +718,12 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 
 	i2c_set_clientdata(client, dcon);
 
-	if (num_registered_fb >= 1)
-		fbinfo = registered_fb[0];
+	if (num_registered_fb < 1) {
+		dev_err(&client->dev, "DCON driver requires a registered fb\n");
+		rc = -EIO;
+		goto einit;
+	}
+	dcon->fbinfo = registered_fb[0];
 
 	rc = dcon_hw_init(dcon, 1);
 	if (rc)

commit feaa98b2a5e452d95624d3f217cf1aab9cd25db0
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Feb 10 17:47:16 2011 -0800

    staging: olpc_dcon: move fb event notifier block into dcon_priv struct
    
    This also fixes a think-o where I was pulling the dcon struct
    out of thin air in the fb event callback.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index cc121105e8c5..710d88094d48 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -58,6 +58,7 @@ struct dcon_priv {
 
 	struct work_struct switch_source;
 	struct notifier_block reboot_nb;
+	struct notifier_block fbevent_nb;
 
 	/* Shadow register for the DCON_REG_MODE register */
 	u8 disp_mode;
@@ -669,13 +670,12 @@ static struct notifier_block dcon_panic_nb = {
  * When the framebuffer sleeps due to external sources (e.g. user idle), power
  * down the DCON as well.  Power it back up when the fb comes back to life.
  */
-static int fb_notifier_callback(struct notifier_block *self,
+static int dcon_fb_notifier(struct notifier_block *self,
 				unsigned long event, void *data)
 {
 	struct fb_event *evdata = data;
-	struct backlight_device *bl = container_of(self,
-			struct backlight_device, fb_notif);
-	struct dcon_priv *dcon = bl_get_data(bl);
+	struct dcon_priv *dcon = container_of(self, struct dcon_priv,
+			fbevent_nb);
 	int *blank = (int *) evdata->data;
 	if (((event != FB_EVENT_BLANK) && (event != FB_EVENT_CONBLANK)) ||
 			ignore_fb_events)
@@ -684,10 +684,6 @@ static int fb_notifier_callback(struct notifier_block *self,
 	return 0;
 }
 
-static struct notifier_block fb_nb = {
-	.notifier_call = fb_notifier_callback,
-};
-
 static int dcon_detect(struct i2c_client *client, struct i2c_board_info *info)
 {
 	strlcpy(info->type, "olpc_dcon", I2C_NAME_SIZE);
@@ -708,6 +704,7 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	INIT_WORK(&dcon->switch_source, dcon_source_switch);
 	dcon->reboot_nb.notifier_call = dcon_reboot_notify;
 	dcon->reboot_nb.priority = -1;
+	dcon->fbevent_nb.notifier_call = dcon_fb_notifier;
 
 	i2c_set_clientdata(client, dcon);
 
@@ -762,7 +759,7 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 
 	register_reboot_notifier(&dcon->reboot_nb);
 	atomic_notifier_chain_register(&panic_notifier_list, &dcon_panic_nb);
-	fb_register_client(&fb_nb);
+	fb_register_client(&dcon->fbevent_nb);
 
 	return 0;
 
@@ -786,7 +783,7 @@ static int dcon_remove(struct i2c_client *client)
 
 	i2c_set_clientdata(client, NULL);
 
-	fb_unregister_client(&fb_nb);
+	fb_unregister_client(&dcon->fbevent_nb);
 	unregister_reboot_notifier(&dcon->reboot_nb);
 	atomic_notifier_chain_unregister(&panic_notifier_list, &dcon_panic_nb);
 

commit 9ed62423033d167765a2c6385064acbeeadb2b14
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Feb 10 17:46:07 2011 -0800

    staging: olpc_dcon: don't specify single bits for bool fields
    
    Just use a regular 'bool foo', rather than 'bool foo:1'.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index eec10e78faba..cc121105e8c5 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -63,8 +63,8 @@ struct dcon_priv {
 	u8 disp_mode;
 
 	/* Current output type; true == mono, false == color */
-	bool mono:1;
-	bool asleep:1;
+	bool mono;
+	bool asleep;
 };
 
 /* I2C structures */
@@ -516,7 +516,7 @@ static ssize_t dcon_sleep_show(struct device *dev,
 {
 
 	struct dcon_priv *dcon = dev_get_drvdata(dev);
-	return sprintf(buf, "%d\n", dcon->asleep ? 1 : 0);
+	return sprintf(buf, "%d\n", dcon->asleep);
 }
 
 static ssize_t dcon_freeze_show(struct device *dev,
@@ -529,7 +529,7 @@ static ssize_t dcon_mono_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
 	struct dcon_priv *dcon = dev_get_drvdata(dev);
-	return sprintf(buf, "%d\n", dcon->mono ? 1 : 0);
+	return sprintf(buf, "%d\n", dcon->mono);
 }
 
 static ssize_t dcon_resumeline_show(struct device *dev,
@@ -564,7 +564,7 @@ static ssize_t dcon_mono_store(struct device *dev,
 	if (_strtoul(buf, count, &enable_mono))
 		return -EINVAL;
 
-	dcon_set_mono_mode(dev_get_drvdata(dev), enable_mono ? 1 : 0);
+	dcon_set_mono_mode(dev_get_drvdata(dev), enable_mono ? true : false);
 	rc = count;
 
 	return rc;

commit 56463de05a56b80b43d21a442cf2a6e0037762e8
Author: Andres Salomon <dilinger@queued.net>
Date:   Sun Feb 6 15:28:53 2011 -0800

    staging: olpc_dcon: actually return the value of i2c_add_driver
    
    It's nice to actually check for errors. :)
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 5d85d779952d..eec10e78faba 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -872,7 +872,7 @@ static irqreturn_t dcon_interrupt(int irq, void *id)
 	return IRQ_HANDLED;
 }
 
-static struct i2c_device_id dcon_idtable[] = {
+static const struct i2c_device_id dcon_idtable[] = {
 	{ "olpc_dcon",  0 },
 	{ }
 };
@@ -901,8 +901,7 @@ static int __init olpc_dcon_init(void)
 {
 	pdata = &dcon_pdata_xo_1;
 
-	i2c_add_driver(&dcon_driver);
-	return 0;
+	return i2c_add_driver(&dcon_driver);
 }
 
 static void __exit olpc_dcon_exit(void)

commit bada46e5ab10b09b0f86e8b8ede009e759a16adf
Author: Andres Salomon <dilinger@queued.net>
Date:   Sun Feb 6 15:28:46 2011 -0800

    staging: olpc_dcon: move more variables into dcon_priv
    
    Global variables for display mode and the current sleep state
    can go into dcon_priv as well.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index a81e325f1102..5d85d779952d 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -59,8 +59,12 @@ struct dcon_priv {
 	struct work_struct switch_source;
 	struct notifier_block reboot_nb;
 
+	/* Shadow register for the DCON_REG_MODE register */
+	u8 disp_mode;
+
 	/* Current output type; true == mono, false == color */
 	bool mono:1;
+	bool asleep:1;
 };
 
 /* I2C structures */
@@ -84,12 +88,6 @@ static int dcon_source;
 /* Desired source */
 static int dcon_pending;
 
-/* Current sleep status (not yet implemented) */
-static int dcon_sleep_val = DCON_ACTIVE;
-
-/* Shadow register for the DCON_REG_MODE register */
-static unsigned short dcon_disp_mode;
-
 /* Variables used during switches */
 static int dcon_switched;
 static struct timespec dcon_irq_time;
@@ -164,11 +162,12 @@ static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 
 	/* Colour swizzle, AA, no passthrough, backlight */
 	if (is_init) {
-		dcon_disp_mode = MODE_PASSTHRU | MODE_BL_ENABLE | MODE_CSWIZZLE;
+		dcon->disp_mode = MODE_PASSTHRU | MODE_BL_ENABLE |
+				MODE_CSWIZZLE;
 		if (useaa)
-			dcon_disp_mode |= MODE_COL_AA;
+			dcon->disp_mode |= MODE_COL_AA;
 	}
-	i2c_smbus_write_word_data(client, DCON_REG_MODE, dcon_disp_mode);
+	i2c_smbus_write_word_data(client, DCON_REG_MODE, dcon->disp_mode);
 
 
 	/* Set the scanline to interrupt on during resume */
@@ -245,11 +244,11 @@ static void dcon_set_backlight_hw(struct dcon_priv *dcon, int level)
 
 	/* Purposely turn off the backlight when we go to level 0 */
 	if (bl_val == 0) {
-		dcon_disp_mode &= ~MODE_BL_ENABLE;
-		dcon_write(dcon, DCON_REG_MODE, dcon_disp_mode);
-	} else if (!(dcon_disp_mode & MODE_BL_ENABLE)) {
-		dcon_disp_mode |= MODE_BL_ENABLE;
-		dcon_write(dcon, DCON_REG_MODE, dcon_disp_mode);
+		dcon->disp_mode &= ~MODE_BL_ENABLE;
+		dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
+	} else if (!(dcon->disp_mode & MODE_BL_ENABLE)) {
+		dcon->disp_mode |= MODE_BL_ENABLE;
+		dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
 	}
 }
 
@@ -273,16 +272,16 @@ static int dcon_set_mono_mode(struct dcon_priv *dcon, bool enable_mono)
 	dcon->mono = enable_mono;
 
 	if (enable_mono) {
-		dcon_disp_mode &= ~(MODE_CSWIZZLE | MODE_COL_AA);
-		dcon_disp_mode |= MODE_MONO_LUMA;
+		dcon->disp_mode &= ~(MODE_CSWIZZLE | MODE_COL_AA);
+		dcon->disp_mode |= MODE_MONO_LUMA;
 	} else {
-		dcon_disp_mode &= ~(MODE_MONO_LUMA);
-		dcon_disp_mode |= MODE_CSWIZZLE;
+		dcon->disp_mode &= ~(MODE_MONO_LUMA);
+		dcon->disp_mode |= MODE_CSWIZZLE;
 		if (useaa)
-			dcon_disp_mode |= MODE_COL_AA;
+			dcon->disp_mode |= MODE_COL_AA;
 	}
 
-	dcon_write(dcon, DCON_REG_MODE, dcon_disp_mode);
+	dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);
 	return 0;
 }
 
@@ -290,36 +289,36 @@ static int dcon_set_mono_mode(struct dcon_priv *dcon, bool enable_mono)
  * DCONLOAD works in a sleep and account for it accordingly
  */
 
-static void dcon_sleep(struct dcon_priv *dcon, int state)
+static void dcon_sleep(struct dcon_priv *dcon, bool sleep)
 {
 	int x;
 
 	/* Turn off the backlight and put the DCON to sleep */
 
-	if (state == dcon_sleep_val)
+	if (dcon->asleep == sleep)
 		return;
 
 	if (!olpc_board_at_least(olpc_board(0xc2)))
 		return;
 
-	if (state == DCON_SLEEP) {
+	if (sleep) {
 		x = 0;
 		x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);
 		if (x)
 			printk(KERN_WARNING "olpc-dcon:  unable to force dcon "
 					"to power down: %d!\n", x);
 		else
-			dcon_sleep_val = state;
+			dcon->asleep = sleep;
 	} else {
 		/* Only re-enable the backlight if the backlight value is set */
 		if (bl_val != 0)
-			dcon_disp_mode |= MODE_BL_ENABLE;
+			dcon->disp_mode |= MODE_BL_ENABLE;
 		x = dcon_bus_stabilize(dcon, 1);
 		if (x)
 			printk(KERN_WARNING "olpc-dcon:  unable to reinit dcon"
 					" hardware: %d!\n", x);
 		else
-			dcon_sleep_val = state;
+			dcon->asleep = sleep;
 
 		/* Restore backlight */
 		dcon_set_backlight_hw(dcon, bl_val);
@@ -367,7 +366,7 @@ static void dcon_source_switch(struct work_struct *work)
 		printk("dcon_source_switch to CPU\n");
 		/* Enable the scanline interrupt bit */
 		if (dcon_write(dcon, DCON_REG_MODE,
-				dcon_disp_mode | MODE_SCAN_INT))
+				dcon->disp_mode | MODE_SCAN_INT))
 			printk(KERN_ERR
 			       "olpc-dcon:  couldn't enable scanline interrupt!\n");
 		else {
@@ -380,7 +379,7 @@ static void dcon_source_switch(struct work_struct *work)
 			printk(KERN_ERR "olpc-dcon:  Timeout entering CPU mode; expect a screen glitch.\n");
 
 		/* Turn off the scanline interrupt */
-		if (dcon_write(dcon, DCON_REG_MODE, dcon_disp_mode))
+		if (dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode))
 			printk(KERN_ERR "olpc-dcon:  couldn't disable scanline interrupt!\n");
 
 		/*
@@ -508,14 +507,16 @@ static int dconbl_get(struct backlight_device *dev)
 static ssize_t dcon_mode_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%4.4X\n", dcon_disp_mode);
+	struct dcon_priv *dcon = dev_get_drvdata(dev);
+	return sprintf(buf, "%4.4X\n", dcon->disp_mode);
 }
 
 static ssize_t dcon_sleep_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
 
-	return sprintf(buf, "%d\n", dcon_sleep_val);
+	struct dcon_priv *dcon = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", dcon->asleep ? 1 : 0);
 }
 
 static ssize_t dcon_freeze_show(struct device *dev,
@@ -621,7 +622,7 @@ static ssize_t dcon_sleep_store(struct device *dev,
 	if (_strtoul(buf, count, &output))
 		return -EINVAL;
 
-	dcon_sleep(dev_get_drvdata(dev), output ? DCON_SLEEP : DCON_ACTIVE);
+	dcon_sleep(dev_get_drvdata(dev), output ? true : false);
 	return count;
 }
 
@@ -679,7 +680,7 @@ static int fb_notifier_callback(struct notifier_block *self,
 	if (((event != FB_EVENT_BLANK) && (event != FB_EVENT_CONBLANK)) ||
 			ignore_fb_events)
 		return 0;
-	dcon_sleep(dcon, (*blank) ? DCON_SLEEP : DCON_ACTIVE);
+	dcon_sleep(dcon, *blank ? true : false);
 	return 0;
 }
 
@@ -808,7 +809,7 @@ static int dcon_suspend(struct i2c_client *client, pm_message_t state)
 {
 	struct dcon_priv *dcon = i2c_get_clientdata(client);
 
-	if (dcon_sleep_val == DCON_ACTIVE) {
+	if (!dcon->asleep) {
 		/* Set up the DCON to have the source */
 		dcon_set_source_sync(dcon, DCON_SOURCE_DCON);
 	}
@@ -820,7 +821,7 @@ static int dcon_resume(struct i2c_client *client)
 {
 	struct dcon_priv *dcon = i2c_get_clientdata(client);
 
-	if (dcon_sleep_val == DCON_ACTIVE) {
+	if (!dcon->asleep) {
 		dcon_bus_stabilize(dcon, 0);
 		dcon_set_source(dcon, DCON_SOURCE_CPU);
 	}

commit bb4103544e455e11d9a4379326406a60429b9888
Author: Andres Salomon <dilinger@queued.net>
Date:   Sun Feb 6 15:28:39 2011 -0800

    staging: olpc_dcon: change sysfs 'output' toggle to be clearer...
    
    ..and store it in dcon_priv.  This renames it to 'monochrome',
    which I think is much clearer.  Previously, "echo 1 > output"
    toggled mono mode, while "echo 0 > output" enabled color.
    "Echo 1 > monochrome" makes more sense to me.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index f43c4ec95f91..a81e325f1102 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -58,6 +58,9 @@ struct dcon_priv {
 
 	struct work_struct switch_source;
 	struct notifier_block reboot_nb;
+
+	/* Current output type; true == mono, false == color */
+	bool mono:1;
 };
 
 /* I2C structures */
@@ -81,9 +84,6 @@ static int dcon_source;
 /* Desired source */
 static int dcon_pending;
 
-/* Current output type */
-static int dcon_output = DCON_OUTPUT_COLOR;
-
 /* Current sleep status (not yet implemented) */
 static int dcon_sleep_val = DCON_ACTIVE;
 
@@ -265,15 +265,14 @@ static void dcon_set_backlight(struct dcon_priv *dcon, int level)
 }
 
 /* Set the output type to either color or mono */
-
-static int dcon_set_output(struct dcon_priv *dcon, int arg)
+static int dcon_set_mono_mode(struct dcon_priv *dcon, bool enable_mono)
 {
-	if (dcon_output == arg)
+	if (dcon->mono == enable_mono)
 		return 0;
 
-	dcon_output = arg;
+	dcon->mono = enable_mono;
 
-	if (arg == DCON_OUTPUT_MONO) {
+	if (enable_mono) {
 		dcon_disp_mode &= ~(MODE_CSWIZZLE | MODE_COL_AA);
 		dcon_disp_mode |= MODE_MONO_LUMA;
 	} else {
@@ -525,10 +524,11 @@ static ssize_t dcon_freeze_show(struct device *dev,
 	return sprintf(buf, "%d\n", dcon_source == DCON_SOURCE_DCON ? 1 : 0);
 }
 
-static ssize_t dcon_output_show(struct device *dev,
+static ssize_t dcon_mono_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%d\n", dcon_output);
+	struct dcon_priv *dcon = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", dcon->mono ? 1 : 0);
 }
 
 static ssize_t dcon_resumeline_show(struct device *dev,
@@ -554,19 +554,17 @@ static int _strtoul(const char *buf, int len, unsigned int *val)
 	return 0;
 }
 
-static ssize_t dcon_output_store(struct device *dev,
+static ssize_t dcon_mono_store(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
-	int output;
+	int enable_mono;
 	int rc = -EINVAL;
 
-	if (_strtoul(buf, count, &output))
+	if (_strtoul(buf, count, &enable_mono))
 		return -EINVAL;
 
-	if (output == DCON_OUTPUT_COLOR || output == DCON_OUTPUT_MONO) {
-		dcon_set_output(dev_get_drvdata(dev), output);
-		rc = count;
-	}
+	dcon_set_mono_mode(dev_get_drvdata(dev), enable_mono ? 1 : 0);
+	rc = count;
 
 	return rc;
 }
@@ -631,7 +629,7 @@ static struct device_attribute dcon_device_files[] = {
 	__ATTR(mode, 0444, dcon_mode_show, NULL),
 	__ATTR(sleep, 0644, dcon_sleep_show, dcon_sleep_store),
 	__ATTR(freeze, 0644, dcon_freeze_show, dcon_freeze_store),
-	__ATTR(output, 0644, dcon_output_show, dcon_output_store),
+	__ATTR(monochrome, 0644, dcon_mono_show, dcon_mono_store),
 	__ATTR(resumeline, 0644, dcon_resumeline_show, dcon_resumeline_store),
 };
 

commit 8d2d3dd1b4589299ec17b15130fbadfc69996df4
Author: Andres Salomon <dilinger@queued.net>
Date:   Sun Feb 6 15:28:30 2011 -0800

    staging: olpc_dcon: get rid of global i2c_client, create a dcon_priv struct
    
    Rather than using the global i2c_client variable, create a dcon_priv
    struct, store in the drvdata portion of the dev, and pass that around.
    
    In order to access dcon struct from various callbacks, include
    the reboot notifier and source switching work struct in the dcon struct.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index d6ad5d7a1457..f43c4ec95f91 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -53,10 +53,16 @@ struct dcon_platform_data {
 
 static struct dcon_platform_data *pdata;
 
+struct dcon_priv {
+	struct i2c_client *client;
+
+	struct work_struct switch_source;
+	struct notifier_block reboot_nb;
+};
+
 /* I2C structures */
 
 static struct i2c_driver dcon_driver;
-static struct i2c_client *dcon_client;
 
 /* Platform devices */
 static struct platform_device *dcon_device;
@@ -93,16 +99,24 @@ static DECLARE_WAIT_QUEUE_HEAD(dcon_wait_queue);
 
 static unsigned short normal_i2c[] = { 0x0d, I2C_CLIENT_END };
 
-#define dcon_write(reg, val) i2c_smbus_write_word_data(dcon_client, reg, val)
-#define dcon_read(reg) i2c_smbus_read_word_data(dcon_client, reg)
+static s32 dcon_write(struct dcon_priv *dcon, u8 reg, u16 val)
+{
+	return i2c_smbus_write_word_data(dcon->client, reg, val);
+}
+
+static s32 dcon_read(struct dcon_priv *dcon, u8 reg)
+{
+	return i2c_smbus_read_word_data(dcon->client, reg);
+}
 
 /* The current backlight value - this saves us some smbus traffic */
 static int bl_val = -1;
 
 /* ===== API functions - these are called by a variety of users ==== */
 
-static int dcon_hw_init(struct i2c_client *client, int is_init)
+static int dcon_hw_init(struct dcon_priv *dcon, int is_init)
 {
+	struct i2c_client *client = dcon->client;
 	uint16_t ver;
 	int rc = 0;
 
@@ -173,7 +187,7 @@ static int dcon_hw_init(struct i2c_client *client, int is_init)
  * smbus.  For newer models, we simply BUG(); we want to know if this
  * still happens despite the power fixes that have been made!
  */
-static int dcon_bus_stabilize(struct i2c_client *client, int is_powered_down)
+static int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)
 {
 	unsigned long timeout;
 	int x;
@@ -194,7 +208,7 @@ static int dcon_bus_stabilize(struct i2c_client *client, int is_powered_down)
 
 	for (x = -1, timeout = 50; timeout && x < 0; timeout--) {
 		msleep(1);
-		x = dcon_read(DCON_REG_ID);
+		x = dcon_read(dcon, DCON_REG_ID);
 	}
 	if (x < 0) {
 		printk(KERN_ERR "olpc-dcon:  unable to stabilize dcon's "
@@ -208,51 +222,51 @@ static int dcon_bus_stabilize(struct i2c_client *client, int is_powered_down)
 	}
 
 	if (is_powered_down)
-		return dcon_hw_init(client, 0);
+		return dcon_hw_init(dcon, 0);
 	return 0;
 }
 
-static int dcon_get_backlight(void)
+static int dcon_get_backlight(struct dcon_priv *dcon)
 {
-	if (dcon_client == NULL)
+	if (!dcon || !dcon->client)
 		return 0;
 
 	if (bl_val == -1)
-		bl_val = dcon_read(DCON_REG_BRIGHT) & 0x0F;
+		bl_val = dcon_read(dcon, DCON_REG_BRIGHT) & 0x0F;
 
 	return bl_val;
 }
 
 
-static void dcon_set_backlight_hw(int level)
+static void dcon_set_backlight_hw(struct dcon_priv *dcon, int level)
 {
 	bl_val = level & 0x0F;
-	dcon_write(DCON_REG_BRIGHT, bl_val);
+	dcon_write(dcon, DCON_REG_BRIGHT, bl_val);
 
 	/* Purposely turn off the backlight when we go to level 0 */
 	if (bl_val == 0) {
 		dcon_disp_mode &= ~MODE_BL_ENABLE;
-		dcon_write(DCON_REG_MODE, dcon_disp_mode);
+		dcon_write(dcon, DCON_REG_MODE, dcon_disp_mode);
 	} else if (!(dcon_disp_mode & MODE_BL_ENABLE)) {
 		dcon_disp_mode |= MODE_BL_ENABLE;
-		dcon_write(DCON_REG_MODE, dcon_disp_mode);
+		dcon_write(dcon, DCON_REG_MODE, dcon_disp_mode);
 	}
 }
 
-static void dcon_set_backlight(int level)
+static void dcon_set_backlight(struct dcon_priv *dcon, int level)
 {
-	if (dcon_client == NULL)
+	if (!dcon || !dcon->client)
 		return;
 
 	if (bl_val == (level & 0x0F))
 		return;
 
-	dcon_set_backlight_hw(level);
+	dcon_set_backlight_hw(dcon, level);
 }
 
 /* Set the output type to either color or mono */
 
-static int dcon_set_output(int arg)
+static int dcon_set_output(struct dcon_priv *dcon, int arg)
 {
 	if (dcon_output == arg)
 		return 0;
@@ -269,7 +283,7 @@ static int dcon_set_output(int arg)
 			dcon_disp_mode |= MODE_COL_AA;
 	}
 
-	dcon_write(DCON_REG_MODE, dcon_disp_mode);
+	dcon_write(dcon, DCON_REG_MODE, dcon_disp_mode);
 	return 0;
 }
 
@@ -277,7 +291,7 @@ static int dcon_set_output(int arg)
  * DCONLOAD works in a sleep and account for it accordingly
  */
 
-static void dcon_sleep(int state)
+static void dcon_sleep(struct dcon_priv *dcon, int state)
 {
 	int x;
 
@@ -301,7 +315,7 @@ static void dcon_sleep(int state)
 		/* Only re-enable the backlight if the backlight value is set */
 		if (bl_val != 0)
 			dcon_disp_mode |= MODE_BL_ENABLE;
-		x = dcon_bus_stabilize(dcon_client, 1);
+		x = dcon_bus_stabilize(dcon, 1);
 		if (x)
 			printk(KERN_WARNING "olpc-dcon:  unable to reinit dcon"
 					" hardware: %d!\n", x);
@@ -309,7 +323,7 @@ static void dcon_sleep(int state)
 			dcon_sleep_val = state;
 
 		/* Restore backlight */
-		dcon_set_backlight_hw(bl_val);
+		dcon_set_backlight_hw(dcon, bl_val);
 	}
 
 	/* We should turn off some stuff in the framebuffer - but what? */
@@ -337,6 +351,8 @@ void dcon_load_holdoff(void)
 
 static void dcon_source_switch(struct work_struct *work)
 {
+	struct dcon_priv *dcon = container_of(work, struct dcon_priv,
+			switch_source);
 	DECLARE_WAITQUEUE(wait, current);
 	int source = dcon_pending;
 
@@ -351,7 +367,8 @@ static void dcon_source_switch(struct work_struct *work)
 	case DCON_SOURCE_CPU:
 		printk("dcon_source_switch to CPU\n");
 		/* Enable the scanline interrupt bit */
-		if (dcon_write(DCON_REG_MODE, dcon_disp_mode | MODE_SCAN_INT))
+		if (dcon_write(dcon, DCON_REG_MODE,
+				dcon_disp_mode | MODE_SCAN_INT))
 			printk(KERN_ERR
 			       "olpc-dcon:  couldn't enable scanline interrupt!\n");
 		else {
@@ -364,7 +381,7 @@ static void dcon_source_switch(struct work_struct *work)
 			printk(KERN_ERR "olpc-dcon:  Timeout entering CPU mode; expect a screen glitch.\n");
 
 		/* Turn off the scanline interrupt */
-		if (dcon_write(DCON_REG_MODE, dcon_disp_mode))
+		if (dcon_write(dcon, DCON_REG_MODE, dcon_disp_mode))
 			printk(KERN_ERR "olpc-dcon:  couldn't disable scanline interrupt!\n");
 
 		/*
@@ -454,40 +471,39 @@ static void dcon_source_switch(struct work_struct *work)
 	dcon_source = source;
 }
 
-static DECLARE_WORK(dcon_work, dcon_source_switch);
-
-static void dcon_set_source(int arg)
+static void dcon_set_source(struct dcon_priv *dcon, int arg)
 {
 	if (dcon_pending == arg)
 		return;
 
 	dcon_pending = arg;
 
-	if ((dcon_source != arg) && !work_pending(&dcon_work))
-		schedule_work(&dcon_work);
+	if ((dcon_source != arg) && !work_pending(&dcon->switch_source))
+		schedule_work(&dcon->switch_source);
 }
 
-static void dcon_set_source_sync(int arg)
+static void dcon_set_source_sync(struct dcon_priv *dcon, int arg)
 {
-	dcon_set_source(arg);
+	dcon_set_source(dcon, arg);
 	flush_scheduled_work();
 }
 
 static int dconbl_set(struct backlight_device *dev)
 {
-
+	struct dcon_priv *dcon = bl_get_data(dev);
 	int level = dev->props.brightness;
 
 	if (dev->props.power != FB_BLANK_UNBLANK)
 		level = 0;
 
-	dcon_set_backlight(level);
+	dcon_set_backlight(dcon, level);
 	return 0;
 }
 
 static int dconbl_get(struct backlight_device *dev)
 {
-	return dcon_get_backlight();
+	struct dcon_priv *dcon = bl_get_data(dev);
+	return dcon_get_backlight(dcon);
 }
 
 static ssize_t dcon_mode_show(struct device *dev,
@@ -548,7 +564,7 @@ static ssize_t dcon_output_store(struct device *dev,
 		return -EINVAL;
 
 	if (output == DCON_OUTPUT_COLOR || output == DCON_OUTPUT_MONO) {
-		dcon_set_output(output);
+		dcon_set_output(dev_get_drvdata(dev), output);
 		rc = count;
 	}
 
@@ -558,6 +574,7 @@ static ssize_t dcon_output_store(struct device *dev,
 static ssize_t dcon_freeze_store(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
+	struct dcon_priv *dcon = dev_get_drvdata(dev);
 	int output;
 
 	if (_strtoul(buf, count, &output))
@@ -567,13 +584,13 @@ static ssize_t dcon_freeze_store(struct device *dev,
 
 	switch (output) {
 	case 0:
-		dcon_set_source(DCON_SOURCE_CPU);
+		dcon_set_source(dcon, DCON_SOURCE_CPU);
 		break;
 	case 1:
-		dcon_set_source_sync(DCON_SOURCE_DCON);
+		dcon_set_source_sync(dcon, DCON_SOURCE_DCON);
 		break;
 	case 2:  /* normally unused */
-		dcon_set_source(DCON_SOURCE_DCON);
+		dcon_set_source(dcon, DCON_SOURCE_DCON);
 		break;
 	default:
 		return -EINVAL;
@@ -592,7 +609,7 @@ static ssize_t dcon_resumeline_store(struct device *dev,
 		return rc;
 
 	resumeline = rl;
-	dcon_write(DCON_REG_SCAN_INT, resumeline);
+	dcon_write(dev_get_drvdata(dev), DCON_REG_SCAN_INT, resumeline);
 	rc = count;
 
 	return rc;
@@ -606,7 +623,7 @@ static ssize_t dcon_sleep_store(struct device *dev,
 	if (_strtoul(buf, count, &output))
 		return -EINVAL;
 
-	dcon_sleep(output ? DCON_SLEEP : DCON_ACTIVE);
+	dcon_sleep(dev_get_drvdata(dev), output ? DCON_SLEEP : DCON_ACTIVE);
 	return count;
 }
 
@@ -627,20 +644,17 @@ static const struct backlight_ops dcon_bl_ops = {
 static int dcon_reboot_notify(struct notifier_block *nb,
 			      unsigned long foo, void *bar)
 {
-	if (dcon_client == NULL)
+	struct dcon_priv *dcon = container_of(nb, struct dcon_priv, reboot_nb);
+
+	if (!dcon || !dcon->client)
 		return 0;
 
 	/* Turn off the DCON. Entirely. */
-	dcon_write(DCON_REG_MODE, 0x39);
-	dcon_write(DCON_REG_MODE, 0x32);
+	dcon_write(dcon, DCON_REG_MODE, 0x39);
+	dcon_write(dcon, DCON_REG_MODE, 0x32);
 	return 0;
 }
 
-static struct notifier_block dcon_nb = {
-	.notifier_call = dcon_reboot_notify,
-	.priority = -1,
-};
-
 static int unfreeze_on_panic(struct notifier_block *nb,
 			     unsigned long e, void *p)
 {
@@ -660,11 +674,14 @@ static int fb_notifier_callback(struct notifier_block *self,
 				unsigned long event, void *data)
 {
 	struct fb_event *evdata = data;
+	struct backlight_device *bl = container_of(self,
+			struct backlight_device, fb_notif);
+	struct dcon_priv *dcon = bl_get_data(bl);
 	int *blank = (int *) evdata->data;
 	if (((event != FB_EVENT_BLANK) && (event != FB_EVENT_CONBLANK)) ||
 			ignore_fb_events)
 		return 0;
-	dcon_sleep((*blank) ? DCON_SLEEP : DCON_ACTIVE);
+	dcon_sleep(dcon, (*blank) ? DCON_SLEEP : DCON_ACTIVE);
 	return 0;
 }
 
@@ -681,12 +698,24 @@ static int dcon_detect(struct i2c_client *client, struct i2c_board_info *info)
 
 static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
+	struct dcon_priv *dcon;
 	int rc, i, j;
 
+	dcon = kzalloc(sizeof(*dcon), GFP_KERNEL);
+	if (!dcon)
+		return -ENOMEM;
+
+	dcon->client = client;
+	INIT_WORK(&dcon->switch_source, dcon_source_switch);
+	dcon->reboot_nb.notifier_call = dcon_reboot_notify;
+	dcon->reboot_nb.priority = -1;
+
+	i2c_set_clientdata(client, dcon);
+
 	if (num_registered_fb >= 1)
 		fbinfo = registered_fb[0];
 
-	rc = dcon_hw_init(client, 1);
+	rc = dcon_hw_init(dcon, 1);
 	if (rc)
 		goto einit;
 
@@ -699,9 +728,8 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		rc = -ENOMEM;
 		goto eirq;
 	}
-	/* Place holder...*/
-	i2c_set_clientdata(client, dcon_device);
 	rc = platform_device_add(dcon_device);
+	platform_set_drvdata(dcon_device, dcon);
 
 	if (rc) {
 		printk(KERN_ERR "dcon:  Unable to add the DCON device\n");
@@ -718,11 +746,8 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	}
 
 	/* Add the backlight device for the DCON */
-
-	dcon_client = client;
-
 	dcon_bl_dev = backlight_device_register("dcon-bl", &dcon_device->dev,
-		NULL, &dcon_bl_ops, NULL);
+		dcon, &dcon_bl_ops, NULL);
 
 	if (IS_ERR(dcon_bl_dev)) {
 		printk(KERN_ERR "Cannot register the backlight device (%ld)\n",
@@ -731,12 +756,12 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	} else {
 		dcon_bl_dev->props.max_brightness = 15;
 		dcon_bl_dev->props.power = FB_BLANK_UNBLANK;
-		dcon_bl_dev->props.brightness = dcon_get_backlight();
+		dcon_bl_dev->props.brightness = dcon_get_backlight(dcon);
 
 		backlight_update_status(dcon_bl_dev);
 	}
 
-	register_reboot_notifier(&dcon_nb);
+	register_reboot_notifier(&dcon->reboot_nb);
 	atomic_notifier_chain_register(&panic_notifier_list, &dcon_panic_nb);
 	fb_register_client(&fb_nb);
 
@@ -751,15 +776,19 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
  eirq:
 	free_irq(DCON_IRQ, &dcon_driver);
  einit:
+	i2c_set_clientdata(client, NULL);
+	kfree(dcon);
 	return rc;
 }
 
 static int dcon_remove(struct i2c_client *client)
 {
-	dcon_client = NULL;
+	struct dcon_priv *dcon = i2c_get_clientdata(client);
+
+	i2c_set_clientdata(client, NULL);
 
 	fb_unregister_client(&fb_nb);
-	unregister_reboot_notifier(&dcon_nb);
+	unregister_reboot_notifier(&dcon->reboot_nb);
 	atomic_notifier_chain_unregister(&panic_notifier_list, &dcon_panic_nb);
 
 	free_irq(DCON_IRQ, &dcon_driver);
@@ -769,7 +798,9 @@ static int dcon_remove(struct i2c_client *client)
 
 	if (dcon_device != NULL)
 		platform_device_unregister(dcon_device);
-	cancel_work_sync(&dcon_work);
+	cancel_work_sync(&dcon->switch_source);
+
+	kfree(dcon);
 
 	return 0;
 }
@@ -777,9 +808,11 @@ static int dcon_remove(struct i2c_client *client)
 #ifdef CONFIG_PM
 static int dcon_suspend(struct i2c_client *client, pm_message_t state)
 {
+	struct dcon_priv *dcon = i2c_get_clientdata(client);
+
 	if (dcon_sleep_val == DCON_ACTIVE) {
 		/* Set up the DCON to have the source */
-		dcon_set_source_sync(DCON_SOURCE_DCON);
+		dcon_set_source_sync(dcon, DCON_SOURCE_DCON);
 	}
 
 	return 0;
@@ -787,9 +820,11 @@ static int dcon_suspend(struct i2c_client *client, pm_message_t state)
 
 static int dcon_resume(struct i2c_client *client)
 {
+	struct dcon_priv *dcon = i2c_get_clientdata(client);
+
 	if (dcon_sleep_val == DCON_ACTIVE) {
-		dcon_bus_stabilize(client, 0);
-		dcon_set_source(DCON_SOURCE_CPU);
+		dcon_bus_stabilize(dcon, 0);
+		dcon_set_source(dcon, DCON_SOURCE_CPU);
 	}
 
 	return 0;

commit fe2d5b43807ebb38e0e8c7b269ff08fcd4011726
Author: Andres Salomon <dilinger@queued.net>
Date:   Sun Feb 6 14:38:16 2011 -0800

    staging: olpc_dcon: revert strtoul change
    
    On Fri, 4 Feb 2011 15:44:43 -0800
    
    From: Andres Salomon <dilinger@queued.net>
    
    The s/simple_strtoul/strict_strtoul/ from commit e107e6eb added a build
    warning, as well as an oops.  This reverts that change.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index b19cd349f933..d6ad5d7a1457 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -525,7 +525,7 @@ static int _strtoul(const char *buf, int len, unsigned int *val)
 {
 
 	char *endp;
-	unsigned int output = strict_strtoul(buf, &endp, 0);
+	unsigned int output = simple_strtoul(buf, &endp, 0);
 	int size = endp - buf;
 
 	if (*endp && isspace(*endp))

commit e107e6ebdda9b56be21951a7c58c2fa90d6e685b
Author: Marek Belisko <marek.belisko@open-nandra.com>
Date:   Thu Feb 3 16:22:52 2011 +0100

    staging: olpc_dcon: checkpatch.pl fixes for olpc_dcon.c file.
    
    Signed-off-by: Marek Belisko <marek.belisko@open-nandra.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 7221bb886857..b19cd349f933 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -24,7 +24,7 @@
 #include <linux/backlight.h>
 #include <linux/device.h>
 #include <linux/notifier.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/ctype.h>
 #include <linux/reboot.h>
 #include <asm/tsc.h>
@@ -87,14 +87,14 @@ static unsigned short dcon_disp_mode;
 /* Variables used during switches */
 static int dcon_switched;
 static struct timespec dcon_irq_time;
-static struct timespec dcon_load_time; 
+static struct timespec dcon_load_time;
 
 static DECLARE_WAIT_QUEUE_HEAD(dcon_wait_queue);
 
 static unsigned short normal_i2c[] = { 0x0d, I2C_CLIENT_END };
 
-#define dcon_write(reg,val) i2c_smbus_write_word_data(dcon_client,reg,val)
-#define dcon_read(reg) i2c_smbus_read_word_data(dcon_client,reg)
+#define dcon_write(reg, val) i2c_smbus_write_word_data(dcon_client, reg, val)
+#define dcon_read(reg) i2c_smbus_read_word_data(dcon_client, reg)
 
 /* The current backlight value - this saves us some smbus traffic */
 static int bl_val = -1;
@@ -117,7 +117,8 @@ static int dcon_hw_init(struct i2c_client *client, int is_init)
 	if (is_init) {
 		printk(KERN_INFO "olpc-dcon:  Discovered DCON version %x\n",
 				ver & 0xFF);
-		if ((rc = pdata->init()) != 0) {
+		rc = pdata->init();
+		if (rc != 0) {
 			printk(KERN_ERR "olpc-dcon:  Unable to init.\n");
 			goto err;
 		}
@@ -133,14 +134,13 @@ static int dcon_hw_init(struct i2c_client *client, int is_init)
 		i2c_smbus_write_word_data(client, 0x0b, 0x007a);
 		i2c_smbus_write_word_data(client, 0x36, 0x025c);
 		i2c_smbus_write_word_data(client, 0x37, 0x025e);
-		
+
 		/* Initialise SDRAM */
 
 		i2c_smbus_write_word_data(client, 0x3b, 0x002b);
 		i2c_smbus_write_word_data(client, 0x41, 0x0101);
 		i2c_smbus_write_word_data(client, 0x42, 0x0101);
-	}
-	else if (!noinit) {
+	} else if (!noinit) {
 		/* SDRAM setup/hold time */
 		i2c_smbus_write_word_data(client, 0x3a, 0xc040);
 		i2c_smbus_write_word_data(client, 0x41, 0x0000);
@@ -181,14 +181,15 @@ static int dcon_bus_stabilize(struct i2c_client *client, int is_powered_down)
 power_up:
 	if (is_powered_down) {
 		x = 1;
-		if ((x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0))) {
+		x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);
+		if (x) {
 			printk(KERN_WARNING "olpc-dcon:  unable to force dcon "
 					"to power up: %d!\n", x);
 			return x;
 		}
 		msleep(10); /* we'll be conservative */
 	}
-	
+
 	pdata->bus_stabilize_wiggle();
 
 	for (x = -1, timeout = 50; timeout && x < 0; timeout--) {
@@ -261,8 +262,7 @@ static int dcon_set_output(int arg)
 	if (arg == DCON_OUTPUT_MONO) {
 		dcon_disp_mode &= ~(MODE_CSWIZZLE | MODE_COL_AA);
 		dcon_disp_mode |= MODE_MONO_LUMA;
-	}
-	else {
+	} else {
 		dcon_disp_mode &= ~(MODE_MONO_LUMA);
 		dcon_disp_mode |= MODE_CSWIZZLE;
 		if (useaa)
@@ -291,18 +291,18 @@ static void dcon_sleep(int state)
 
 	if (state == DCON_SLEEP) {
 		x = 0;
-		if ((x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0)))
+		x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);
+		if (x)
 			printk(KERN_WARNING "olpc-dcon:  unable to force dcon "
 					"to power down: %d!\n", x);
 		else
 			dcon_sleep_val = state;
-	}
-	else {
+	} else {
 		/* Only re-enable the backlight if the backlight value is set */
 		if (bl_val != 0)
 			dcon_disp_mode |= MODE_BL_ENABLE;
-
-		if ((x=dcon_bus_stabilize(dcon_client, 1)))
+		x = dcon_bus_stabilize(dcon_client, 1);
+		if (x)
 			printk(KERN_WARNING "olpc-dcon:  unable to reinit dcon"
 					" hardware: %d!\n", x);
 		else
@@ -316,14 +316,14 @@ static void dcon_sleep(int state)
 }
 
 /* the DCON seems to get confused if we change DCONLOAD too
- * frequently -- i.e., approximately faster than frame time. 
+ * frequently -- i.e., approximately faster than frame time.
  * normally we don't change it this fast, so in general we won't
  * delay here.
  */
 void dcon_load_holdoff(void)
 {
 	struct timespec delta_t, now;
-	while(1) {
+	while (1) {
 		getnstimeofday(&now);
 		delta_t = timespec_sub(now, dcon_load_time);
 		if (delta_t.tv_sec != 0 ||
@@ -352,10 +352,12 @@ static void dcon_source_switch(struct work_struct *work)
 		printk("dcon_source_switch to CPU\n");
 		/* Enable the scanline interrupt bit */
 		if (dcon_write(DCON_REG_MODE, dcon_disp_mode | MODE_SCAN_INT))
-			printk(KERN_ERR "olpc-dcon:  couldn't enable scanline interrupt!\n");
+			printk(KERN_ERR
+			       "olpc-dcon:  couldn't enable scanline interrupt!\n");
 		else {
 			/* Wait up to one second for the scanline interrupt */
-			wait_event_timeout(dcon_wait_queue, dcon_switched == 1, HZ);
+			wait_event_timeout(dcon_wait_queue,
+					   dcon_switched == 1, HZ);
 		}
 
 		if (!dcon_switched)
@@ -396,7 +398,7 @@ static void dcon_source_switch(struct work_struct *work)
 		int t;
 		struct timespec delta_t;
 
-		printk("dcon_source_switch to DCON\n");
+		printk(KERN_INFO "dcon_source_switch to DCON\n");
 
 		add_wait_queue(&dcon_wait_queue, &wait);
 		set_current_state(TASK_UNINTERRUPTIBLE);
@@ -420,7 +422,7 @@ static void dcon_source_switch(struct work_struct *work)
 			 * the time between asserting DCONLOAD and the IRQ --
 			 * if it's less than 20msec, then the DCON couldn't
 			 * have seen two VSYNC pulses.  in that case we
-			 * deassert and reassert, and hope for the best. 
+			 * deassert and reassert, and hope for the best.
 			 * see http://dev.laptop.org/ticket/9664
 			 */
 			delta_t = timespec_sub(dcon_irq_time, dcon_load_time);
@@ -471,7 +473,8 @@ static void dcon_set_source_sync(int arg)
 	flush_scheduled_work();
 }
 
-static int dconbl_set(struct backlight_device *dev) {
+static int dconbl_set(struct backlight_device *dev)
+{
 
 	int level = dev->props.brightness;
 
@@ -482,7 +485,8 @@ static int dconbl_set(struct backlight_device *dev) {
 	return 0;
 }
 
-static int dconbl_get(struct backlight_device *dev) {
+static int dconbl_get(struct backlight_device *dev)
+{
 	return dcon_get_backlight();
 }
 
@@ -521,7 +525,7 @@ static int _strtoul(const char *buf, int len, unsigned int *val)
 {
 
 	char *endp;
-	unsigned int output = simple_strtoul(buf, &endp, 0);
+	unsigned int output = strict_strtoul(buf, &endp, 0);
 	int size = endp - buf;
 
 	if (*endp && isspace(*endp))
@@ -559,7 +563,7 @@ static ssize_t dcon_freeze_store(struct device *dev,
 	if (_strtoul(buf, count, &output))
 		return -EINVAL;
 
-	printk("dcon_freeze_store: %d\n", output);
+	printk(KERN_INFO "dcon_freeze_store: %d\n", output);
 
 	switch (output) {
 	case 0:
@@ -568,7 +572,7 @@ static ssize_t dcon_freeze_store(struct device *dev,
 	case 1:
 		dcon_set_source_sync(DCON_SOURCE_DCON);
 		break;
-	case 2:  // normally unused
+	case 2:  /* normally unused */
 		dcon_set_source(DCON_SOURCE_DCON);
 		break;
 	default:
@@ -620,7 +624,8 @@ static const struct backlight_ops dcon_bl_ops = {
 };
 
 
-static int dcon_reboot_notify(struct notifier_block *nb, unsigned long foo, void *bar)
+static int dcon_reboot_notify(struct notifier_block *nb,
+			      unsigned long foo, void *bar)
 {
 	if (dcon_client == NULL)
 		return 0;
@@ -636,7 +641,8 @@ static struct notifier_block dcon_nb = {
 	.priority = -1,
 };
 
-static int unfreeze_on_panic(struct notifier_block *nb, unsigned long e, void *p)
+static int unfreeze_on_panic(struct notifier_block *nb,
+			     unsigned long e, void *p)
 {
 	pdata->set_dconload(1);
 	return NOTIFY_DONE;
@@ -650,7 +656,8 @@ static struct notifier_block dcon_panic_nb = {
  * When the framebuffer sleeps due to external sources (e.g. user idle), power
  * down the DCON as well.  Power it back up when the fb comes back to life.
  */
-static int fb_notifier_callback(struct notifier_block *self, unsigned long event, void *data)
+static int fb_notifier_callback(struct notifier_block *self,
+				unsigned long event, void *data)
 {
 	struct fb_event *evdata = data;
 	int *blank = (int *) evdata->data;
@@ -688,19 +695,20 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	dcon_device = platform_device_alloc("dcon", -1);
 
 	if (dcon_device == NULL) {
-		printk("dcon:  Unable to create the DCON device\n");
+		printk(KERN_ERR "dcon:  Unable to create the DCON device\n");
 		rc = -ENOMEM;
 		goto eirq;
 	}
 	/* Place holder...*/
 	i2c_set_clientdata(client, dcon_device);
+	rc = platform_device_add(dcon_device);
 
-	if ((rc = platform_device_add(dcon_device))) {
-		printk("dcon:  Unable to add the DCON device\n");
+	if (rc) {
+		printk(KERN_ERR "dcon:  Unable to add the DCON device\n");
 		goto edev;
 	}
 
-	for(i = 0; i < ARRAY_SIZE(dcon_device_files); i++) {
+	for (i = 0; i < ARRAY_SIZE(dcon_device_files); i++) {
 		rc = device_create_file(&dcon_device->dev,
 					&dcon_device_files[i]);
 		if (rc) {
@@ -717,10 +725,10 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		NULL, &dcon_bl_ops, NULL);
 
 	if (IS_ERR(dcon_bl_dev)) {
-		printk("Could not register the backlight device for the DCON (%ld)\n", PTR_ERR(dcon_bl_dev));
+		printk(KERN_ERR "Cannot register the backlight device (%ld)\n",
+		       PTR_ERR(dcon_bl_dev));
 		dcon_bl_dev = NULL;
-	}
-	else {
+	} else {
 		dcon_bl_dev->props.max_brightness = 15;
 		dcon_bl_dev->props.power = FB_BLANK_UNBLANK;
 		dcon_bl_dev->props.brightness = dcon_get_backlight();

commit a90dcd4f7dfc3e664e7d08790a8b39d052e21a2e
Author: Marek Belisko <marek.belisko@open-nandra.com>
Date:   Thu Feb 3 14:22:08 2011 +0100

    staging: oplc_dcon: Fix compilation warning.
    
    Fix compilation warning:
    drivers/staging/olpc_dcon/olpc_dcon.c: In function ‘dcon_probe’:
    drivers/staging/olpc_dcon/olpc_dcon.c:704:21: warning: ignoring
    return value of ‘device_create_file’, declared with attribute warn_unused_result
    
    and add cleaning of created files when creation of one failed.
    
    Signed-off-by: Marek Belisko <marek.belisko@open-nandra.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 56a283d1a74d..7221bb886857 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -674,7 +674,7 @@ static int dcon_detect(struct i2c_client *client, struct i2c_board_info *info)
 
 static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
-	int rc, i;
+	int rc, i, j;
 
 	if (num_registered_fb >= 1)
 		fbinfo = registered_fb[0];
@@ -700,8 +700,14 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		goto edev;
 	}
 
-	for(i = 0; i < ARRAY_SIZE(dcon_device_files); i++)
-		device_create_file(&dcon_device->dev, &dcon_device_files[i]);
+	for(i = 0; i < ARRAY_SIZE(dcon_device_files); i++) {
+		rc = device_create_file(&dcon_device->dev,
+					&dcon_device_files[i]);
+		if (rc) {
+			dev_err(&dcon_device->dev, "Cannot create sysfs file\n");
+			goto ecreate;
+		}
+	}
 
 	/* Add the backlight device for the DCON */
 
@@ -728,6 +734,9 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 
 	return 0;
 
+ ecreate:
+	for (j = 0; j < i; j++)
+		device_remove_file(&dcon_device->dev, &dcon_device_files[j]);
  edev:
 	platform_device_unregister(dcon_device);
 	dcon_device = NULL;

commit ac751efa6a0d70f2c9daef5c7e3a92270f5c2dff
Author: Torben Hohn <torbenh@gmx.de>
Date:   Tue Jan 25 15:07:35 2011 -0800

    console: rename acquire/release_console_sem() to console_lock/unlock()
    
    The -rt patches change the console_semaphore to console_mutex.  As a
    result, a quite large chunk of the patches changes all
    acquire/release_console_sem() to acquire/release_console_mutex()
    
    This commit makes things use more neutral function names which dont make
    implications about the underlying lock.
    
    The only real change is the return value of console_trylock which is
    inverted from try_acquire_console_sem()
    
    This patch also paves the way to switching console_sem from a semaphore to
    a mutex.
    
    [akpm@linux-foundation.org: coding-style fixes]
    [akpm@linux-foundation.org: make console_trylock return 1 on success, per Geert]
    Signed-off-by: Torben Hohn <torbenh@gmx.de>
    Cc: Thomas Gleixner <tglx@tglx.de>
    Cc: Greg KH <gregkh@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 9f26dc9408bb..56a283d1a74d 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -373,17 +373,17 @@ static void dcon_source_switch(struct work_struct *work)
 		 *
 		 * For now, we just hope..
 		 */
-		acquire_console_sem();
+		console_lock();
 		ignore_fb_events = 1;
 		if (fb_blank(fbinfo, FB_BLANK_UNBLANK)) {
 			ignore_fb_events = 0;
-			release_console_sem();
+			console_unlock();
 			printk(KERN_ERR "olpc-dcon:  Failed to enter CPU mode\n");
 			dcon_pending = DCON_SOURCE_DCON;
 			return;
 		}
 		ignore_fb_events = 0;
-		release_console_sem();
+		console_unlock();
 
 		/* And turn off the DCON */
 		pdata->set_dconload(1);
@@ -435,12 +435,12 @@ static void dcon_source_switch(struct work_struct *work)
 			}
 		}
 
-		acquire_console_sem();
+		console_lock();
 		ignore_fb_events = 1;
 		if (fb_blank(fbinfo, FB_BLANK_POWERDOWN))
 			printk(KERN_ERR "olpc-dcon:  couldn't blank fb!\n");
 		ignore_fb_events = 0;
-		release_console_sem();
+		console_unlock();
 
 		printk(KERN_INFO "olpc-dcon: The DCON has control\n");
 		break;

commit 008d23e4852d78bb2618f2035f8b2110b6a6b968
Merge: 8f685fbda43d bfc672dcf323
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 13 10:05:56 2011 -0800

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (43 commits)
      Documentation/trace/events.txt: Remove obsolete sched_signal_send.
      writeback: fix global_dirty_limits comment runtime -> real-time
      ppc: fix comment typo singal -> signal
      drivers: fix comment typo diable -> disable.
      m68k: fix comment typo diable -> disable.
      wireless: comment typo fix diable -> disable.
      media: comment typo fix diable -> disable.
      remove doc for obsolete dynamic-printk kernel-parameter
      remove extraneous 'is' from Documentation/iostats.txt
      Fix spelling milisec -> ms in snd_ps3 module parameter description
      Fix spelling mistakes in comments
      Revert conflicting V4L changes
      i7core_edac: fix typos in comments
      mm/rmap.c: fix comment
      sound, ca0106: Fix assignment to 'channel'.
      hrtimer: fix a typo in comment
      init/Kconfig: fix typo
      anon_inodes: fix wrong function name in comment
      fix comment typos concerning "consistent"
      poll: fix a typo in comment
      ...
    
    Fix up trivial conflicts in:
     - drivers/net/wireless/iwlwifi/iwl-core.c (moved to iwl-legacy.c)
     - fs/ext4/ext4.h
    
    Also fix missed 'diabled' typo in drivers/net/bnx2x/bnx2x.h while at it.

commit 7637c9259f7b6dd841471ccf1120d484b7364f99
Author: Andres Salomon <dilinger@queued.net>
Date:   Wed Jan 12 17:00:11 2011 -0800

    drivers/staging/olpc_dcon: convert to new cs5535 gpio API
    
    Drop the old geode_gpio crud, as well as the raw outl() calls; instead,
    use the Linux GPIO API where possible, and the cs5535_gpio API in other
    places.
    
    Note that we don't actually clean up the driver properly yet (once loaded,
    it always remains loaded).  That'll come later..
    
    This patch is necessary for building the driver.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 4ca45ec7fd84..da040c12fbf9 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -27,7 +27,6 @@
 #include <asm/uaccess.h>
 #include <linux/ctype.h>
 #include <linux/reboot.h>
-#include <linux/gpio.h>
 #include <asm/tsc.h>
 #include <asm/olpc.h>
 
@@ -49,7 +48,7 @@ struct dcon_platform_data {
 	int (*init)(void);
 	void (*bus_stabilize_wiggle)(void);
 	void (*set_dconload)(int);
-	int (*read_status)(void);
+	u8 (*read_status)(void);
 };
 
 static struct dcon_platform_data *pdata;

commit 4b7bd364700d9ac8372eff48832062b936d0793b
Merge: c0d8768af260 90a8a73c06cc
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Dec 22 18:57:02 2010 +0100

    Merge branch 'master' into for-next
    
    Conflicts:
            MAINTAINERS
            arch/arm/mach-omap2/pm24xx.c
            drivers/scsi/bfa/bfa_fcpim.c
    
    Needed to update to apply fixes for which the old branch was too
    outdated.

commit acc2472ed33fc5e72482cc3b3b846077d97c2f8b
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Tue Nov 16 14:14:02 2010 +0100

    backlight: constify backlight_ops
    
    backlight_device_register has been expecting a const "ops" argument, and using
    it as such, since 9905a43b2d563e6f89e4c63c4278ada03f2ebb14. Let's make the
    remaining backlight_ops instances const.
    
    Inspired by hunks of the grsecurity patch, updated for newer kernels.
    
    Signed-off-by: Lionel Debroux <lionel_debroux@yahoo.fr>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 75aa7a36307d..d40ff41774be 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -616,7 +616,7 @@ static struct device_attribute dcon_device_files[] = {
 	__ATTR(resumeline, 0644, dcon_resumeline_show, dcon_resumeline_store),
 };
 
-static struct backlight_ops dcon_bl_ops = {
+static const struct backlight_ops dcon_bl_ops = {
 	.get_brightness = dconbl_get,
 	.update_status = dconbl_set
 };

commit f3dc65dafa651bca6606ac0b41ead1be50d05652
Author: Jean Delvare <khali@linux-fr.org>
Date:   Mon Nov 15 22:40:38 2010 +0100

    i2c: Drivers shouldn't include <linux/i2c-id.h>
    
    Drivers don't need to include <linux/i2c-id.h>, especially not when
    they don't use anything that header file provides.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: Michael Hunold <michael@mihu.de>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index f286a4c56f66..4ca45ec7fd84 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -17,7 +17,6 @@
 #include <linux/console.h>
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
-#include <linux/i2c-id.h>
 #include <linux/pci.h>
 #include <linux/pci_ids.h>
 #include <linux/interrupt.h>

commit dc6641be0ea8819ef095fdcefc2b695611999a21
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Mon Nov 15 22:40:38 2010 +0100

    i2c: Remove obsolete cleanup for clientdata
    
    A few new i2c-drivers came into the kernel which clear the clientdata-pointer
    on exit. This is obsolete meanwhile, so fix it and hope the word will spread.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Acked-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 75aa7a36307d..f286a4c56f66 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -733,7 +733,6 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
  edev:
 	platform_device_unregister(dcon_device);
 	dcon_device = NULL;
-	i2c_set_clientdata(client, NULL);
  eirq:
 	free_irq(DCON_IRQ, &dcon_driver);
  einit:
@@ -757,8 +756,6 @@ static int dcon_remove(struct i2c_client *client)
 		platform_device_unregister(dcon_device);
 	cancel_work_sync(&dcon_work);
 
-	i2c_set_clientdata(client, NULL);
-
 	return 0;
 }
 

commit 95699fb7c34e230061b6c2997bd7590801c0b5fe
Author: Andres Salomon <dilinger@queued.net>
Date:   Sat Sep 25 19:06:30 2010 -0700

    staging: olpc_dcon: drop old VT switch code, watch for CONBLANK event
    
    Eons ago, in a galaxy far far away, Jordan committed code to work around
    the fact that X might have put the DCON to sleep and then crashed (in that
    galaxy, X crashed a lot; crazy, right?)
    
    This code was based on a custom API.  These days, we have code which watches
    for FB unblanks, and should perform the same function.. Therefore, the older
    code can be dropped.  We should probably be watching for CONBLANK events to,
    so allow those to turn the DCON back on.
    
    Dropping the old code is necessary for building the driver.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 287085f32bf0..75aa7a36307d 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -19,7 +19,6 @@
 #include <linux/platform_device.h>
 #include <linux/i2c-id.h>
 #include <linux/pci.h>
-#include <linux/vt_kern.h>
 #include <linux/pci_ids.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
@@ -634,25 +633,11 @@ static int dcon_reboot_notify(struct notifier_block *nb, unsigned long foo, void
 	return 0;
 }
 
-static int dcon_conswitch_notify(struct notifier_block *nb,
-				 unsigned long mode, void *dummy)
-{
-	if (mode == CONSOLE_EVENT_SWITCH_TEXT)
-		dcon_sleep(DCON_ACTIVE);
-
-	return 0;
-}
-
 static struct notifier_block dcon_nb = {
 	.notifier_call = dcon_reboot_notify,
 	.priority = -1,
 };
 
-static struct notifier_block dcon_console_nb = {
-	.notifier_call = dcon_conswitch_notify,
-	.priority = -1,
-};
-
 static int unfreeze_on_panic(struct notifier_block *nb, unsigned long e, void *p)
 {
 	pdata->set_dconload(1);
@@ -663,13 +648,16 @@ static struct notifier_block dcon_panic_nb = {
 	.notifier_call = unfreeze_on_panic,
 };
 
-/* when framebuffer sleeps due to external source (e.g. user idle), power down
- * the DCON. also power up when the framebuffer comes back to life. */
+/*
+ * When the framebuffer sleeps due to external sources (e.g. user idle), power
+ * down the DCON as well.  Power it back up when the fb comes back to life.
+ */
 static int fb_notifier_callback(struct notifier_block *self, unsigned long event, void *data)
 {
 	struct fb_event *evdata = data;
 	int *blank = (int *) evdata->data;
-	if (event != FB_EVENT_BLANK || ignore_fb_events)
+	if (((event != FB_EVENT_BLANK) && (event != FB_EVENT_CONBLANK)) ||
+			ignore_fb_events)
 		return 0;
 	dcon_sleep((*blank) ? DCON_SLEEP : DCON_ACTIVE);
 	return 0;
@@ -737,7 +725,6 @@ static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	}
 
 	register_reboot_notifier(&dcon_nb);
-	console_event_register(&dcon_console_nb);
 	atomic_notifier_chain_register(&panic_notifier_list, &dcon_panic_nb);
 	fb_register_client(&fb_nb);
 
@@ -759,7 +746,6 @@ static int dcon_remove(struct i2c_client *client)
 
 	fb_unregister_client(&fb_nb);
 	unregister_reboot_notifier(&dcon_nb);
-	console_event_unregister(&dcon_console_nb);
 	atomic_notifier_chain_unregister(&panic_notifier_list, &dcon_panic_nb);
 
 	free_irq(DCON_IRQ, &dcon_driver);

commit 233aa49b8c1cb9276ca4316c61e324f697a19ce2
Author: Andres Salomon <dilinger@queued.net>
Date:   Fri Sep 24 23:50:16 2010 -0700

    staging: olpc_dcon: remove outdated backlight comment
    
    This comment about killing power to the backlight is ancient, and incorrect
    (the code that follows actually does the opposite of what the comment says).
    This was due to hardware changes; the comment was for the original OLPC GX2
    boards, but when the OLPC LX boards came out, the code was updated for that
    hardware.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 808273db773c..287085f32bf0 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -214,12 +214,6 @@ static int dcon_bus_stabilize(struct i2c_client *client, int is_powered_down)
 	return 0;
 }
 
-
-/* Backlight notes - turning off the backlight enable bit in the DCON
- * doesn't save us any power over just pushing the BL to zero, so we
- * don't use that bit in this code.
- */
-
 static int dcon_get_backlight(void)
 {
 	if (dcon_client == NULL)

commit 5f0753b8a908dd641144b314d7028af880f376a6
Author: Andres Salomon <dilinger@queued.net>
Date:   Fri Sep 24 19:14:38 2010 -0700

    staging: olpc_dcon: drop XO-1.5 support for now
    
    The vx855 stuff isn't upstream yet; for now, drop support for XO-1.5.
    This will come back once the 1.5 code is in place (and will be in a form
    that allows both 1.0 and 1.5 support to be compiled in at the same time),
    but for now just remove it.  This is necessary to get the driver building.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 02a4502961dd..808273db773c 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -869,21 +869,11 @@ static struct i2c_driver dcon_driver = {
 #endif
 };
 
-#if defined(CONFIG_OLPC_XO_1)
 #include "olpc_dcon_xo_1.c"
-#elif defined(CONFIG_OLPC_XO_1_5)
-#include "olpc_dcon_xo_1_5.c"
-#else
-#error "Trying to build OLPC DCON driver but kernel not configured for XO"
-#endif
 
 static int __init olpc_dcon_init(void)
 {
-#ifdef CONFIG_OLPC_XO_1
 	pdata = &dcon_pdata_xo_1;
-#else
-	pdata = &dcon_pdata_xo_1_5;
-#endif
 
 	i2c_add_driver(&dcon_driver);
 	return 0;

commit 316604bef6874bbd2a946fb39a7555b068c44c08
Author: Andres Salomon <dilinger@queued.net>
Date:   Fri Sep 24 19:14:09 2010 -0700

    staging: olpc_dcon: switch back to using olpc_board(0xXX)
    
    ...Rather than macros that don't exist.  Necessary for building the
    driver.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
index 688cf0f69524..02a4502961dd 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -201,7 +201,7 @@ static int dcon_bus_stabilize(struct i2c_client *client, int is_powered_down)
 	if (x < 0) {
 		printk(KERN_ERR "olpc-dcon:  unable to stabilize dcon's "
 				"smbus, reasserting power and praying.\n");
-		BUG_ON(olpc_board_at_least(olpc_board(BOARD_XO_1_C2)));
+		BUG_ON(olpc_board_at_least(olpc_board(0xc2)));
 		x = 0;
 		olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);
 		msleep(100);
@@ -295,7 +295,7 @@ static void dcon_sleep(int state)
 	if (state == dcon_sleep_val)
 		return;
 
-	if (!olpc_board_at_least(olpc_board(BOARD_XO_1_C2)))
+	if (!olpc_board_at_least(olpc_board(0xc2)))
 		return;
 
 	if (state == DCON_SLEEP) {

commit eecb3e4e5d9d83ebe1bef222a707eb7618498b67
Author: Andres Salomon <dilinger@queued.net>
Date:   Fri Sep 24 19:13:42 2010 -0700

    staging: olpc_dcon: add OLPC display controller (DCON) support
    
    This adds DCON support for the OLPC XO.  The DCON is found in XO-1 and
    XO-1.5 hardware.  The XO-1 has a CS5536 southbridge, while the XO-1.5
    has a Via chipset; the GPIO magic that's necessary to communicate with
    the DCON chip is unfortunately different across both platforms.  This
    driver supports both.
    
    This driver is in bad state atm, so I'm requesting its inclusion into
    staging so it can be cleaned up while staying in the kernel tree.
    
    Original driver by Dave Woodhouse, and modified extensively by
    Jordan Crouse, myself, Deepak Saxena, Paul Fox, Daniel Drake, and
    probably others that I've missed.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/olpc_dcon/olpc_dcon.c b/drivers/staging/olpc_dcon/olpc_dcon.c
new file mode 100644
index 000000000000..688cf0f69524
--- /dev/null
+++ b/drivers/staging/olpc_dcon/olpc_dcon.c
@@ -0,0 +1,900 @@
+/*
+ * Mainly by David Woodhouse, somewhat modified by Jordan Crouse
+ *
+ * Copyright © 2006-2007  Red Hat, Inc.
+ * Copyright © 2006-2007  Advanced Micro Devices, Inc.
+ * Copyright © 2009       VIA Technology, Inc.
+ * Copyright (c) 2010  Andres Salomon <dilinger@queued.net>
+ *
+ * This program is free software.  You can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/i2c-id.h>
+#include <linux/pci.h>
+#include <linux/vt_kern.h>
+#include <linux/pci_ids.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/backlight.h>
+#include <linux/device.h>
+#include <linux/notifier.h>
+#include <asm/uaccess.h>
+#include <linux/ctype.h>
+#include <linux/reboot.h>
+#include <linux/gpio.h>
+#include <asm/tsc.h>
+#include <asm/olpc.h>
+
+#include "olpc_dcon.h"
+
+/* Module definitions */
+
+static int resumeline = 898;
+module_param(resumeline, int, 0444);
+
+static int noinit;
+module_param(noinit, int, 0444);
+
+/* Default off since it doesn't work on DCON ASIC in B-test OLPC board */
+static int useaa = 1;
+module_param(useaa, int, 0444);
+
+struct dcon_platform_data {
+	int (*init)(void);
+	void (*bus_stabilize_wiggle)(void);
+	void (*set_dconload)(int);
+	int (*read_status)(void);
+};
+
+static struct dcon_platform_data *pdata;
+
+/* I2C structures */
+
+static struct i2c_driver dcon_driver;
+static struct i2c_client *dcon_client;
+
+/* Platform devices */
+static struct platform_device *dcon_device;
+
+/* Backlight device */
+static struct backlight_device *dcon_bl_dev;
+
+static struct fb_info *fbinfo;
+
+/* set this to 1 while controlling fb blank state from this driver */
+static int ignore_fb_events = 0;
+
+/* Current source, initialized at probe time */
+static int dcon_source;
+
+/* Desired source */
+static int dcon_pending;
+
+/* Current output type */
+static int dcon_output = DCON_OUTPUT_COLOR;
+
+/* Current sleep status (not yet implemented) */
+static int dcon_sleep_val = DCON_ACTIVE;
+
+/* Shadow register for the DCON_REG_MODE register */
+static unsigned short dcon_disp_mode;
+
+/* Variables used during switches */
+static int dcon_switched;
+static struct timespec dcon_irq_time;
+static struct timespec dcon_load_time; 
+
+static DECLARE_WAIT_QUEUE_HEAD(dcon_wait_queue);
+
+static unsigned short normal_i2c[] = { 0x0d, I2C_CLIENT_END };
+
+#define dcon_write(reg,val) i2c_smbus_write_word_data(dcon_client,reg,val)
+#define dcon_read(reg) i2c_smbus_read_word_data(dcon_client,reg)
+
+/* The current backlight value - this saves us some smbus traffic */
+static int bl_val = -1;
+
+/* ===== API functions - these are called by a variety of users ==== */
+
+static int dcon_hw_init(struct i2c_client *client, int is_init)
+{
+	uint16_t ver;
+	int rc = 0;
+
+	ver = i2c_smbus_read_word_data(client, DCON_REG_ID);
+	if ((ver >> 8) != 0xDC) {
+		printk(KERN_ERR "olpc-dcon:  DCON ID not 0xDCxx: 0x%04x "
+				"instead.\n", ver);
+		rc = -ENXIO;
+		goto err;
+	}
+
+	if (is_init) {
+		printk(KERN_INFO "olpc-dcon:  Discovered DCON version %x\n",
+				ver & 0xFF);
+		if ((rc = pdata->init()) != 0) {
+			printk(KERN_ERR "olpc-dcon:  Unable to init.\n");
+			goto err;
+		}
+	}
+
+	if (ver < 0xdc02 && !noinit) {
+		/* Initialize the DCON registers */
+
+		/* Start with work-arounds for DCON ASIC */
+		i2c_smbus_write_word_data(client, 0x4b, 0x00cc);
+		i2c_smbus_write_word_data(client, 0x4b, 0x00cc);
+		i2c_smbus_write_word_data(client, 0x4b, 0x00cc);
+		i2c_smbus_write_word_data(client, 0x0b, 0x007a);
+		i2c_smbus_write_word_data(client, 0x36, 0x025c);
+		i2c_smbus_write_word_data(client, 0x37, 0x025e);
+		
+		/* Initialise SDRAM */
+
+		i2c_smbus_write_word_data(client, 0x3b, 0x002b);
+		i2c_smbus_write_word_data(client, 0x41, 0x0101);
+		i2c_smbus_write_word_data(client, 0x42, 0x0101);
+	}
+	else if (!noinit) {
+		/* SDRAM setup/hold time */
+		i2c_smbus_write_word_data(client, 0x3a, 0xc040);
+		i2c_smbus_write_word_data(client, 0x41, 0x0000);
+		i2c_smbus_write_word_data(client, 0x41, 0x0101);
+		i2c_smbus_write_word_data(client, 0x42, 0x0101);
+	}
+
+	/* Colour swizzle, AA, no passthrough, backlight */
+	if (is_init) {
+		dcon_disp_mode = MODE_PASSTHRU | MODE_BL_ENABLE | MODE_CSWIZZLE;
+		if (useaa)
+			dcon_disp_mode |= MODE_COL_AA;
+	}
+	i2c_smbus_write_word_data(client, DCON_REG_MODE, dcon_disp_mode);
+
+
+	/* Set the scanline to interrupt on during resume */
+	i2c_smbus_write_word_data(client, DCON_REG_SCAN_INT, resumeline);
+
+err:
+	return rc;
+}
+
+/*
+ * The smbus doesn't always come back due to what is believed to be
+ * hardware (power rail) bugs.  For older models where this is known to
+ * occur, our solution is to attempt to wait for the bus to stabilize;
+ * if it doesn't happen, cut power to the dcon, repower it, and wait
+ * for the bus to stabilize.  Rinse, repeat until we have a working
+ * smbus.  For newer models, we simply BUG(); we want to know if this
+ * still happens despite the power fixes that have been made!
+ */
+static int dcon_bus_stabilize(struct i2c_client *client, int is_powered_down)
+{
+	unsigned long timeout;
+	int x;
+
+power_up:
+	if (is_powered_down) {
+		x = 1;
+		if ((x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0))) {
+			printk(KERN_WARNING "olpc-dcon:  unable to force dcon "
+					"to power up: %d!\n", x);
+			return x;
+		}
+		msleep(10); /* we'll be conservative */
+	}
+	
+	pdata->bus_stabilize_wiggle();
+
+	for (x = -1, timeout = 50; timeout && x < 0; timeout--) {
+		msleep(1);
+		x = dcon_read(DCON_REG_ID);
+	}
+	if (x < 0) {
+		printk(KERN_ERR "olpc-dcon:  unable to stabilize dcon's "
+				"smbus, reasserting power and praying.\n");
+		BUG_ON(olpc_board_at_least(olpc_board(BOARD_XO_1_C2)));
+		x = 0;
+		olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);
+		msleep(100);
+		is_powered_down = 1;
+		goto power_up;	/* argh, stupid hardware.. */
+	}
+
+	if (is_powered_down)
+		return dcon_hw_init(client, 0);
+	return 0;
+}
+
+
+/* Backlight notes - turning off the backlight enable bit in the DCON
+ * doesn't save us any power over just pushing the BL to zero, so we
+ * don't use that bit in this code.
+ */
+
+static int dcon_get_backlight(void)
+{
+	if (dcon_client == NULL)
+		return 0;
+
+	if (bl_val == -1)
+		bl_val = dcon_read(DCON_REG_BRIGHT) & 0x0F;
+
+	return bl_val;
+}
+
+
+static void dcon_set_backlight_hw(int level)
+{
+	bl_val = level & 0x0F;
+	dcon_write(DCON_REG_BRIGHT, bl_val);
+
+	/* Purposely turn off the backlight when we go to level 0 */
+	if (bl_val == 0) {
+		dcon_disp_mode &= ~MODE_BL_ENABLE;
+		dcon_write(DCON_REG_MODE, dcon_disp_mode);
+	} else if (!(dcon_disp_mode & MODE_BL_ENABLE)) {
+		dcon_disp_mode |= MODE_BL_ENABLE;
+		dcon_write(DCON_REG_MODE, dcon_disp_mode);
+	}
+}
+
+static void dcon_set_backlight(int level)
+{
+	if (dcon_client == NULL)
+		return;
+
+	if (bl_val == (level & 0x0F))
+		return;
+
+	dcon_set_backlight_hw(level);
+}
+
+/* Set the output type to either color or mono */
+
+static int dcon_set_output(int arg)
+{
+	if (dcon_output == arg)
+		return 0;
+
+	dcon_output = arg;
+
+	if (arg == DCON_OUTPUT_MONO) {
+		dcon_disp_mode &= ~(MODE_CSWIZZLE | MODE_COL_AA);
+		dcon_disp_mode |= MODE_MONO_LUMA;
+	}
+	else {
+		dcon_disp_mode &= ~(MODE_MONO_LUMA);
+		dcon_disp_mode |= MODE_CSWIZZLE;
+		if (useaa)
+			dcon_disp_mode |= MODE_COL_AA;
+	}
+
+	dcon_write(DCON_REG_MODE, dcon_disp_mode);
+	return 0;
+}
+
+/* For now, this will be really stupid - we need to address how
+ * DCONLOAD works in a sleep and account for it accordingly
+ */
+
+static void dcon_sleep(int state)
+{
+	int x;
+
+	/* Turn off the backlight and put the DCON to sleep */
+
+	if (state == dcon_sleep_val)
+		return;
+
+	if (!olpc_board_at_least(olpc_board(BOARD_XO_1_C2)))
+		return;
+
+	if (state == DCON_SLEEP) {
+		x = 0;
+		if ((x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0)))
+			printk(KERN_WARNING "olpc-dcon:  unable to force dcon "
+					"to power down: %d!\n", x);
+		else
+			dcon_sleep_val = state;
+	}
+	else {
+		/* Only re-enable the backlight if the backlight value is set */
+		if (bl_val != 0)
+			dcon_disp_mode |= MODE_BL_ENABLE;
+
+		if ((x=dcon_bus_stabilize(dcon_client, 1)))
+			printk(KERN_WARNING "olpc-dcon:  unable to reinit dcon"
+					" hardware: %d!\n", x);
+		else
+			dcon_sleep_val = state;
+
+		/* Restore backlight */
+		dcon_set_backlight_hw(bl_val);
+	}
+
+	/* We should turn off some stuff in the framebuffer - but what? */
+}
+
+/* the DCON seems to get confused if we change DCONLOAD too
+ * frequently -- i.e., approximately faster than frame time. 
+ * normally we don't change it this fast, so in general we won't
+ * delay here.
+ */
+void dcon_load_holdoff(void)
+{
+	struct timespec delta_t, now;
+	while(1) {
+		getnstimeofday(&now);
+		delta_t = timespec_sub(now, dcon_load_time);
+		if (delta_t.tv_sec != 0 ||
+			delta_t.tv_nsec > NSEC_PER_MSEC * 20) {
+			break;
+		}
+		mdelay(4);
+	}
+}
+/* Set the source of the display (CPU or DCON) */
+
+static void dcon_source_switch(struct work_struct *work)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int source = dcon_pending;
+
+	if (dcon_source == source)
+		return;
+
+	dcon_load_holdoff();
+
+	dcon_switched = 0;
+
+	switch (source) {
+	case DCON_SOURCE_CPU:
+		printk("dcon_source_switch to CPU\n");
+		/* Enable the scanline interrupt bit */
+		if (dcon_write(DCON_REG_MODE, dcon_disp_mode | MODE_SCAN_INT))
+			printk(KERN_ERR "olpc-dcon:  couldn't enable scanline interrupt!\n");
+		else {
+			/* Wait up to one second for the scanline interrupt */
+			wait_event_timeout(dcon_wait_queue, dcon_switched == 1, HZ);
+		}
+
+		if (!dcon_switched)
+			printk(KERN_ERR "olpc-dcon:  Timeout entering CPU mode; expect a screen glitch.\n");
+
+		/* Turn off the scanline interrupt */
+		if (dcon_write(DCON_REG_MODE, dcon_disp_mode))
+			printk(KERN_ERR "olpc-dcon:  couldn't disable scanline interrupt!\n");
+
+		/*
+		 * Ideally we'd like to disable interrupts here so that the
+		 * fb unblanking and DCON turn on happen at a known time value;
+		 * however, we can't do that right now with fb_blank
+		 * messing with semaphores.
+		 *
+		 * For now, we just hope..
+		 */
+		acquire_console_sem();
+		ignore_fb_events = 1;
+		if (fb_blank(fbinfo, FB_BLANK_UNBLANK)) {
+			ignore_fb_events = 0;
+			release_console_sem();
+			printk(KERN_ERR "olpc-dcon:  Failed to enter CPU mode\n");
+			dcon_pending = DCON_SOURCE_DCON;
+			return;
+		}
+		ignore_fb_events = 0;
+		release_console_sem();
+
+		/* And turn off the DCON */
+		pdata->set_dconload(1);
+		getnstimeofday(&dcon_load_time);
+
+		printk(KERN_INFO "olpc-dcon: The CPU has control\n");
+		break;
+	case DCON_SOURCE_DCON:
+	{
+		int t;
+		struct timespec delta_t;
+
+		printk("dcon_source_switch to DCON\n");
+
+		add_wait_queue(&dcon_wait_queue, &wait);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+
+		/* Clear DCONLOAD - this implies that the DCON is in control */
+		pdata->set_dconload(0);
+		getnstimeofday(&dcon_load_time);
+
+		t = schedule_timeout(HZ/2);
+		remove_wait_queue(&dcon_wait_queue, &wait);
+		set_current_state(TASK_RUNNING);
+
+		if (!dcon_switched) {
+			printk(KERN_ERR "olpc-dcon: Timeout entering DCON mode; expect a screen glitch.\n");
+		} else {
+			/* sometimes the DCON doesn't follow its own rules,
+			 * and doesn't wait for two vsync pulses before
+			 * ack'ing the frame load with an IRQ.  the result
+			 * is that the display shows the *previously*
+			 * loaded frame.  we can detect this by looking at
+			 * the time between asserting DCONLOAD and the IRQ --
+			 * if it's less than 20msec, then the DCON couldn't
+			 * have seen two VSYNC pulses.  in that case we
+			 * deassert and reassert, and hope for the best. 
+			 * see http://dev.laptop.org/ticket/9664
+			 */
+			delta_t = timespec_sub(dcon_irq_time, dcon_load_time);
+			if (dcon_switched && delta_t.tv_sec == 0 &&
+					delta_t.tv_nsec < NSEC_PER_MSEC * 20) {
+				printk(KERN_ERR "olpc-dcon: missed loading, retrying\n");
+				pdata->set_dconload(1);
+				mdelay(41);
+				pdata->set_dconload(0);
+				getnstimeofday(&dcon_load_time);
+				mdelay(41);
+			}
+		}
+
+		acquire_console_sem();
+		ignore_fb_events = 1;
+		if (fb_blank(fbinfo, FB_BLANK_POWERDOWN))
+			printk(KERN_ERR "olpc-dcon:  couldn't blank fb!\n");
+		ignore_fb_events = 0;
+		release_console_sem();
+
+		printk(KERN_INFO "olpc-dcon: The DCON has control\n");
+		break;
+	}
+	default:
+		BUG();
+	}
+
+	dcon_source = source;
+}
+
+static DECLARE_WORK(dcon_work, dcon_source_switch);
+
+static void dcon_set_source(int arg)
+{
+	if (dcon_pending == arg)
+		return;
+
+	dcon_pending = arg;
+
+	if ((dcon_source != arg) && !work_pending(&dcon_work))
+		schedule_work(&dcon_work);
+}
+
+static void dcon_set_source_sync(int arg)
+{
+	dcon_set_source(arg);
+	flush_scheduled_work();
+}
+
+static int dconbl_set(struct backlight_device *dev) {
+
+	int level = dev->props.brightness;
+
+	if (dev->props.power != FB_BLANK_UNBLANK)
+		level = 0;
+
+	dcon_set_backlight(level);
+	return 0;
+}
+
+static int dconbl_get(struct backlight_device *dev) {
+	return dcon_get_backlight();
+}
+
+static ssize_t dcon_mode_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%4.4X\n", dcon_disp_mode);
+}
+
+static ssize_t dcon_sleep_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+
+	return sprintf(buf, "%d\n", dcon_sleep_val);
+}
+
+static ssize_t dcon_freeze_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", dcon_source == DCON_SOURCE_DCON ? 1 : 0);
+}
+
+static ssize_t dcon_output_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", dcon_output);
+}
+
+static ssize_t dcon_resumeline_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", resumeline);
+}
+
+static int _strtoul(const char *buf, int len, unsigned int *val)
+{
+
+	char *endp;
+	unsigned int output = simple_strtoul(buf, &endp, 0);
+	int size = endp - buf;
+
+	if (*endp && isspace(*endp))
+		size++;
+
+	if (size != len)
+		return -EINVAL;
+
+	*val = output;
+	return 0;
+}
+
+static ssize_t dcon_output_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int output;
+	int rc = -EINVAL;
+
+	if (_strtoul(buf, count, &output))
+		return -EINVAL;
+
+	if (output == DCON_OUTPUT_COLOR || output == DCON_OUTPUT_MONO) {
+		dcon_set_output(output);
+		rc = count;
+	}
+
+	return rc;
+}
+
+static ssize_t dcon_freeze_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int output;
+
+	if (_strtoul(buf, count, &output))
+		return -EINVAL;
+
+	printk("dcon_freeze_store: %d\n", output);
+
+	switch (output) {
+	case 0:
+		dcon_set_source(DCON_SOURCE_CPU);
+		break;
+	case 1:
+		dcon_set_source_sync(DCON_SOURCE_DCON);
+		break;
+	case 2:  // normally unused
+		dcon_set_source(DCON_SOURCE_DCON);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static ssize_t dcon_resumeline_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rl;
+	int rc = -EINVAL;
+
+	if (_strtoul(buf, count, &rl))
+		return rc;
+
+	resumeline = rl;
+	dcon_write(DCON_REG_SCAN_INT, resumeline);
+	rc = count;
+
+	return rc;
+}
+
+static ssize_t dcon_sleep_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int output;
+
+	if (_strtoul(buf, count, &output))
+		return -EINVAL;
+
+	dcon_sleep(output ? DCON_SLEEP : DCON_ACTIVE);
+	return count;
+}
+
+static struct device_attribute dcon_device_files[] = {
+	__ATTR(mode, 0444, dcon_mode_show, NULL),
+	__ATTR(sleep, 0644, dcon_sleep_show, dcon_sleep_store),
+	__ATTR(freeze, 0644, dcon_freeze_show, dcon_freeze_store),
+	__ATTR(output, 0644, dcon_output_show, dcon_output_store),
+	__ATTR(resumeline, 0644, dcon_resumeline_show, dcon_resumeline_store),
+};
+
+static struct backlight_ops dcon_bl_ops = {
+	.get_brightness = dconbl_get,
+	.update_status = dconbl_set
+};
+
+
+static int dcon_reboot_notify(struct notifier_block *nb, unsigned long foo, void *bar)
+{
+	if (dcon_client == NULL)
+		return 0;
+
+	/* Turn off the DCON. Entirely. */
+	dcon_write(DCON_REG_MODE, 0x39);
+	dcon_write(DCON_REG_MODE, 0x32);
+	return 0;
+}
+
+static int dcon_conswitch_notify(struct notifier_block *nb,
+				 unsigned long mode, void *dummy)
+{
+	if (mode == CONSOLE_EVENT_SWITCH_TEXT)
+		dcon_sleep(DCON_ACTIVE);
+
+	return 0;
+}
+
+static struct notifier_block dcon_nb = {
+	.notifier_call = dcon_reboot_notify,
+	.priority = -1,
+};
+
+static struct notifier_block dcon_console_nb = {
+	.notifier_call = dcon_conswitch_notify,
+	.priority = -1,
+};
+
+static int unfreeze_on_panic(struct notifier_block *nb, unsigned long e, void *p)
+{
+	pdata->set_dconload(1);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block dcon_panic_nb = {
+	.notifier_call = unfreeze_on_panic,
+};
+
+/* when framebuffer sleeps due to external source (e.g. user idle), power down
+ * the DCON. also power up when the framebuffer comes back to life. */
+static int fb_notifier_callback(struct notifier_block *self, unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank = (int *) evdata->data;
+	if (event != FB_EVENT_BLANK || ignore_fb_events)
+		return 0;
+	dcon_sleep((*blank) ? DCON_SLEEP : DCON_ACTIVE);
+	return 0;
+}
+
+static struct notifier_block fb_nb = {
+	.notifier_call = fb_notifier_callback,
+};
+
+static int dcon_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	strlcpy(info->type, "olpc_dcon", I2C_NAME_SIZE);
+
+	return 0;
+}
+
+static int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int rc, i;
+
+	if (num_registered_fb >= 1)
+		fbinfo = registered_fb[0];
+
+	rc = dcon_hw_init(client, 1);
+	if (rc)
+		goto einit;
+
+	/* Add the DCON device */
+
+	dcon_device = platform_device_alloc("dcon", -1);
+
+	if (dcon_device == NULL) {
+		printk("dcon:  Unable to create the DCON device\n");
+		rc = -ENOMEM;
+		goto eirq;
+	}
+	/* Place holder...*/
+	i2c_set_clientdata(client, dcon_device);
+
+	if ((rc = platform_device_add(dcon_device))) {
+		printk("dcon:  Unable to add the DCON device\n");
+		goto edev;
+	}
+
+	for(i = 0; i < ARRAY_SIZE(dcon_device_files); i++)
+		device_create_file(&dcon_device->dev, &dcon_device_files[i]);
+
+	/* Add the backlight device for the DCON */
+
+	dcon_client = client;
+
+	dcon_bl_dev = backlight_device_register("dcon-bl", &dcon_device->dev,
+		NULL, &dcon_bl_ops, NULL);
+
+	if (IS_ERR(dcon_bl_dev)) {
+		printk("Could not register the backlight device for the DCON (%ld)\n", PTR_ERR(dcon_bl_dev));
+		dcon_bl_dev = NULL;
+	}
+	else {
+		dcon_bl_dev->props.max_brightness = 15;
+		dcon_bl_dev->props.power = FB_BLANK_UNBLANK;
+		dcon_bl_dev->props.brightness = dcon_get_backlight();
+
+		backlight_update_status(dcon_bl_dev);
+	}
+
+	register_reboot_notifier(&dcon_nb);
+	console_event_register(&dcon_console_nb);
+	atomic_notifier_chain_register(&panic_notifier_list, &dcon_panic_nb);
+	fb_register_client(&fb_nb);
+
+	return 0;
+
+ edev:
+	platform_device_unregister(dcon_device);
+	dcon_device = NULL;
+	i2c_set_clientdata(client, NULL);
+ eirq:
+	free_irq(DCON_IRQ, &dcon_driver);
+ einit:
+	return rc;
+}
+
+static int dcon_remove(struct i2c_client *client)
+{
+	dcon_client = NULL;
+
+	fb_unregister_client(&fb_nb);
+	unregister_reboot_notifier(&dcon_nb);
+	console_event_unregister(&dcon_console_nb);
+	atomic_notifier_chain_unregister(&panic_notifier_list, &dcon_panic_nb);
+
+	free_irq(DCON_IRQ, &dcon_driver);
+
+	if (dcon_bl_dev != NULL)
+		backlight_device_unregister(dcon_bl_dev);
+
+	if (dcon_device != NULL)
+		platform_device_unregister(dcon_device);
+	cancel_work_sync(&dcon_work);
+
+	i2c_set_clientdata(client, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int dcon_suspend(struct i2c_client *client, pm_message_t state)
+{
+	if (dcon_sleep_val == DCON_ACTIVE) {
+		/* Set up the DCON to have the source */
+		dcon_set_source_sync(DCON_SOURCE_DCON);
+	}
+
+	return 0;
+}
+
+static int dcon_resume(struct i2c_client *client)
+{
+	if (dcon_sleep_val == DCON_ACTIVE) {
+		dcon_bus_stabilize(client, 0);
+		dcon_set_source(DCON_SOURCE_CPU);
+	}
+
+	return 0;
+}
+
+#endif
+
+
+static irqreturn_t dcon_interrupt(int irq, void *id)
+{
+	int status = pdata->read_status();
+
+	if (status == -1)
+		return IRQ_NONE;
+
+	switch (status & 3) {
+	case 3:
+		printk(KERN_DEBUG "olpc-dcon: DCONLOAD_MISSED interrupt\n");
+		break;
+
+	case 2:	/* switch to DCON mode */
+	case 1: /* switch to CPU mode */
+		dcon_switched = 1;
+		getnstimeofday(&dcon_irq_time);
+		wake_up(&dcon_wait_queue);
+		break;
+
+	case 0:
+		/* workaround resume case:  the DCON (on 1.5) doesn't
+		 * ever assert status 0x01 when switching to CPU mode
+		 * during resume.  this is because DCONLOAD is de-asserted
+		 * _immediately_ upon exiting S3, so the actual release
+		 * of the DCON happened long before this point.
+		 * see http://dev.laptop.org/ticket/9869
+		 */
+		if (dcon_source != dcon_pending && !dcon_switched) {
+			dcon_switched = 1;
+			getnstimeofday(&dcon_irq_time);
+			wake_up(&dcon_wait_queue);
+			printk(KERN_DEBUG "olpc-dcon: switching w/ status 0/0\n");
+		} else {
+			printk(KERN_DEBUG "olpc-dcon: scanline interrupt w/CPU\n");
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct i2c_device_id dcon_idtable[] = {
+	{ "olpc_dcon",  0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, dcon_idtable);
+
+static struct i2c_driver dcon_driver = {
+	.driver = {
+		.name	= "olpc_dcon",
+	},
+	.class = I2C_CLASS_DDC | I2C_CLASS_HWMON,
+	.id_table = dcon_idtable,
+	.probe = dcon_probe,
+	.remove = __devexit_p(dcon_remove),
+	.detect = dcon_detect,
+	.address_list = normal_i2c,
+#ifdef CONFIG_PM
+	.suspend = dcon_suspend,
+	.resume = dcon_resume,
+#endif
+};
+
+#if defined(CONFIG_OLPC_XO_1)
+#include "olpc_dcon_xo_1.c"
+#elif defined(CONFIG_OLPC_XO_1_5)
+#include "olpc_dcon_xo_1_5.c"
+#else
+#error "Trying to build OLPC DCON driver but kernel not configured for XO"
+#endif
+
+static int __init olpc_dcon_init(void)
+{
+#ifdef CONFIG_OLPC_XO_1
+	pdata = &dcon_pdata_xo_1;
+#else
+	pdata = &dcon_pdata_xo_1_5;
+#endif
+
+	i2c_add_driver(&dcon_driver);
+	return 0;
+}
+
+static void __exit olpc_dcon_exit(void)
+{
+	i2c_del_driver(&dcon_driver);
+}
+
+module_init(olpc_dcon_init);
+module_exit(olpc_dcon_exit);
+
+MODULE_LICENSE("GPL");
