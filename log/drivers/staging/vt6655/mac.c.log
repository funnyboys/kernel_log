commit d8b2f7cfe4d40e771376bfa4e399f26fa9ef49e4
Author: Madhumitha Prabakaran <madhumithabiw@gmail.com>
Date:   Thu Mar 7 15:11:29 2019 -0600

    staging: vt6655: Remove unused function prototype and definition
    
    Remove the MACbIsRegBitsOn function, as it is never called in kernel tree.
    
    Signed-off-by: Madhumitha Prabakaran <madhumithabiw@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 40a8f1ce837c..f5ae7f1f5689 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -12,7 +12,6 @@
  * Date: May 21, 1996
  *
  * Functions:
- *      MACbIsRegBitsOn - Test if All test Bits On
  *      MACbIsRegBitsOff - Test if All test Bits Off
  *      MACbIsIntDisable - Test if MAC interrupt disable
  *      MACvSetShortRetryLimit - Set 802.11 Short Retry limit
@@ -42,29 +41,6 @@
 #include "tmacro.h"
 #include "mac.h"
 
-/*
- * Description:
- *      Test if all test bits on
- *
- * Parameters:
- *  In:
- *      io_base    - Base Address for MAC
- *      byRegOfs    - Offset of MAC Register
- *      byTestBits  - Test bits
- *  Out:
- *      none
- *
- * Return Value: true if all test bits On; otherwise false
- *
- */
-bool MACbIsRegBitsOn(struct vnt_private *priv, unsigned char byRegOfs,
-		     unsigned char byTestBits)
-{
-	void __iomem *io_base = priv->PortOffset;
-
-	return (ioread8(io_base + byRegOfs) & byTestBits) == byTestBits;
-}
-
 /*
  * Description:
  *      Test if all test bits off

commit d67a81ff854625be7f8e4cf61f05a8dc86344bbb
Author: Madhumitha Prabakaran <madhumithabiw@gmail.com>
Date:   Tue Mar 5 16:48:25 2019 -0600

    staging: vt6655: Remove unnecessary blank line
    
    Fix the check issue provided by checkpatch.pl
    CHECK: Blank lines aren't necessary before a close brace '}'
    
    Signed-off-by: Madhumitha Prabakaran <madhumithabiw@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 4750863c1bb7..40a8f1ce837c 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -593,7 +593,6 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 curr_desc_addr)
 	iowrite32(curr_desc_addr, io_base + MAC_REG_RXDMAPTR1);
 	if (org_dma_ctl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL1);
-
 }
 
 /*

commit dbc9f36cf7bc6d431c63c4785ad3c4bc0f306588
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 21:07:56 2017 +0100

    staging: vt6655: Remove redundant license text
    
    Now that the SPDX tag is in all vt6655 files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 350e36b9a20e..4750863c1bb7 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -3,16 +3,6 @@
  * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  * All rights reserved.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * File: mac.c
  *
  * Purpose:  MAC routines

commit d7c43082fc0d178a29a7ea1dcc9729abd38c7cf8
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 21:07:53 2017 +0100

    staging: vt6655: add SPDX identifiers to all vt6655 driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the vt6655 driver files with the correct SPDX license identifier
    based on the license text in the file itself.  The SPDX identifier is a
    legally binding shorthand, which can be used instead of the full boiler
    plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Forest Bond <forest@alittletooquiet.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index f7550b215f72..350e36b9a20e 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  * All rights reserved.

commit 6f6752648a868135222cb77286bca02fc8730268
Author: Simo Koskinen <koskisoft@gmail.com>
Date:   Mon Jul 17 14:59:05 2017 +0200

    Staging: vt6655: Fixing coding style warnings
    
    Removes following warnings found by checkpatch.pl script:
    
    WARNING: Prefer using '"%s...", __func__' to using 'xxx',
    this function's name, in a string
    
    Signed-off-by: Simo Koskinen <koskisoft@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 4aaa99bafcda..f7550b215f72 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -809,7 +809,7 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 	if (byLocalID <= 1)
 		return;
 
-	pr_debug("MACvSetKeyEntry\n");
+	pr_debug("%s\n", __func__);
 	offset = MISCFIFO_KEYETRY0;
 	offset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 

commit bee80f2926342acc3bca4efa90b26a892fe28ef0
Author: Varsha Rao <rvarsha016@gmail.com>
Date:   Fri Oct 14 00:17:22 2016 +0530

    staging: vt6655: Adding space around '+'
    
    This patch fixes the checkpatch issue by adding space around the
    operator '+'.
    
    Signed-off-by: Varsha Rao <rvarsha016@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 359b3c3960f8..4aaa99bafcda 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -315,7 +315,7 @@ bool MACbSoftwareReset(struct vnt_private *priv)
  */
 bool MACbSafeSoftwareReset(struct vnt_private *priv)
 {
-	unsigned char abyTmpRegData[MAC_MAX_CONTEXT_SIZE_PAGE0+MAC_MAX_CONTEXT_SIZE_PAGE1];
+	unsigned char abyTmpRegData[MAC_MAX_CONTEXT_SIZE_PAGE0 + MAC_MAX_CONTEXT_SIZE_PAGE1];
 	bool bRetVal;
 
 	/* PATCH....

commit 21971f3e0e558db280c9b01d461364e8442d0ef9
Author: Varsha Rao <rvarsha016@gmail.com>
Date:   Tue Oct 11 19:05:46 2016 +0530

    staging: vt6655: Removes the FSF mailing address.
    
    This patch fixes the checkpatch issue by removing the Free Software
    Foundation's mailing address from the sample GPL notice. Because the FSF
    has changed address in the past, and may change again. Linux already
    includes a copy of the GPL.
    
    Signed-off-by: Varsha Rao <rvarsha016@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index d3f4eb2d02af..359b3c3960f8 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -12,11 +12,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *
  * File: mac.c
  *
  * Purpose:  MAC routines

commit 3d30311c0e4d834c94e6a27d6242a942d6a76b85
Author: Varsha Rao <rvarsha016@gmail.com>
Date:   Sun Oct 9 16:43:56 2016 +0530

    staging: vt6655: Removes unnecessary blank lines.
    
    This patch fixes the checkpatch issue of
    multiple blank lines, by removing them.
    
    Signed-off-by: Varsha Rao <rvarsha016@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 8e13f7f41415..d3f4eb2d02af 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -147,7 +147,6 @@ void MACvSetShortRetryLimit(struct vnt_private *priv,
 	iowrite8(byRetryLimit, io_base + MAC_REG_SRT);
 }
 
-
 /*
  * Description:
  *      Set 802.11 Long Retry Limit

commit 5150d01ea99230576060e864f7a6f15e29b8dc4d
Author: Kathryn Hampton <kh353dev@gmail.com>
Date:   Tue Mar 15 18:16:24 2016 -0700

    staging: vt6655: fix style violations for lines over 80 characters
    
    This patch addresses line length errors reported by checkpatch.pl that
    could be fixed with simple line breaks.
    
    Signed-off-by: Kathryn Hampton <kh353dev@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 45196c6e9e12..8e13f7f41415 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -47,7 +47,8 @@
  *
  * Revision History:
  *      08-22-2003 Kyle Hsu     :  Porting MAC functions from sim53
- *      09-03-2003 Bryan YC Fan :  Add MACvClearBusSusInd()& MACvEnableBusSusEn()
+ *      09-03-2003 Bryan YC Fan :  Add MACvClearBusSusInd()&
+ *				   MACvEnableBusSusEn()
  *      09-18-2003 Jerry Chen   :  Add MACvSetKeyEntry & MACvDisableKeyEntry
  *
  */
@@ -138,7 +139,8 @@ bool MACbIsIntDisable(struct vnt_private *priv)
  * Return Value: none
  *
  */
-void MACvSetShortRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit)
+void MACvSetShortRetryLimit(struct vnt_private *priv,
+			    unsigned char byRetryLimit)
 {
 	void __iomem *io_base = priv->PortOffset;
 	/* set SRT */
@@ -160,7 +162,8 @@ void MACvSetShortRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit
  * Return Value: none
  *
  */
-void MACvSetLongRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit)
+void MACvSetLongRetryLimit(struct vnt_private *priv,
+			   unsigned char byRetryLimit)
 {
 	void __iomem *io_base = priv->PortOffset;
 	/* set LRT */
@@ -304,7 +307,8 @@ bool MACbSoftwareReset(struct vnt_private *priv)
 
 /*
  * Description:
- *      save some important register's value, then do reset, then restore register's value
+ *      save some important register's value, then do reset, then restore
+ *	register's value
  *
  * Parameters:
  *  In:
@@ -738,7 +742,8 @@ void MACvTimer0MicroSDelay(struct vnt_private *priv, unsigned int uDelay)
  * Return Value: none
  *
  */
-void MACvOneShotTimer1MicroSec(struct vnt_private *priv, unsigned int uDelayTime)
+void MACvOneShotTimer1MicroSec(struct vnt_private *priv,
+			       unsigned int uDelayTime)
 {
 	void __iomem *io_base = priv->PortOffset;
 

commit efa21f9d0ddd140e73830b051a0fb45893c2d7ae
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:12 2016 +0000

    staging: vt6655: mac.c replace dwData with data.
    
    Removing camel case and type prefix.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index e762c331327f..45196c6e9e12 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -748,14 +748,14 @@ void MACvOneShotTimer1MicroSec(struct vnt_private *priv, unsigned int uDelayTime
 }
 
 void MACvSetMISCFifo(struct vnt_private *priv, unsigned short offset,
-		     u32 dwData)
+		     u32 data)
 {
 	void __iomem *io_base = priv->PortOffset;
 
 	if (offset > 273)
 		return;
 	iowrite16(offset, io_base + MAC_REG_MISCFFNDEX);
-	iowrite32(dwData, io_base + MAC_REG_MISCFFDATA);
+	iowrite32(data, io_base + MAC_REG_MISCFFDATA);
 	iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
 }
 
@@ -804,7 +804,7 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short offset;
-	u32 dwData;
+	u32 data;
 	int     ii;
 
 	if (byLocalID <= 1)
@@ -814,30 +814,30 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 	offset = MISCFIFO_KEYETRY0;
 	offset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 
-	dwData = 0;
-	dwData |= wKeyCtl;
-	dwData <<= 16;
-	dwData |= MAKEWORD(*(pbyAddr+4), *(pbyAddr+5));
+	data = 0;
+	data |= wKeyCtl;
+	data <<= 16;
+	data |= MAKEWORD(*(pbyAddr + 4), *(pbyAddr + 5));
 	pr_debug("1. offset: %d, Data: %X, KeyCtl:%X\n",
-		 offset, dwData, wKeyCtl);
+		 offset, data, wKeyCtl);
 
 	iowrite16(offset, io_base + MAC_REG_MISCFFNDEX);
-	iowrite32(dwData, io_base + MAC_REG_MISCFFDATA);
+	iowrite32(data, io_base + MAC_REG_MISCFFDATA);
 	iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
 	offset++;
 
-	dwData = 0;
-	dwData |= *(pbyAddr+3);
-	dwData <<= 8;
-	dwData |= *(pbyAddr+2);
-	dwData <<= 8;
-	dwData |= *(pbyAddr+1);
-	dwData <<= 8;
-	dwData |= *(pbyAddr+0);
-	pr_debug("2. offset: %d, Data: %X\n", offset, dwData);
+	data = 0;
+	data |= *(pbyAddr + 3);
+	data <<= 8;
+	data |= *(pbyAddr + 2);
+	data <<= 8;
+	data |= *(pbyAddr + 1);
+	data <<= 8;
+	data |= *pbyAddr;
+	pr_debug("2. offset: %d, Data: %X\n", offset, data);
 
 	iowrite16(offset, io_base + MAC_REG_MISCFFNDEX);
-	iowrite32(dwData, io_base + MAC_REG_MISCFFDATA);
+	iowrite32(data, io_base + MAC_REG_MISCFFDATA);
 	iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
 	offset++;
 

commit 0e7997c18fcce692c994c45dcf9e6f3db2fdad17
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:11 2016 +0000

    staging: vt6655: mac.c replace wOffset with offset.
    
    Removing camel case and type prefix.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 87bec1c36f79..e762c331327f 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -747,14 +747,14 @@ void MACvOneShotTimer1MicroSec(struct vnt_private *priv, unsigned int uDelayTime
 	iowrite8((TMCTL_TMD | TMCTL_TE), io_base + MAC_REG_TMCTL1);
 }
 
-void MACvSetMISCFifo(struct vnt_private *priv, unsigned short wOffset,
+void MACvSetMISCFifo(struct vnt_private *priv, unsigned short offset,
 		     u32 dwData)
 {
 	void __iomem *io_base = priv->PortOffset;
 
-	if (wOffset > 273)
+	if (offset > 273)
 		return;
-	iowrite16(wOffset, io_base + MAC_REG_MISCFFNDEX);
+	iowrite16(offset, io_base + MAC_REG_MISCFFNDEX);
 	iowrite32(dwData, io_base + MAC_REG_MISCFFDATA);
 	iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
 }
@@ -803,7 +803,7 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 		     unsigned char byLocalID)
 {
 	void __iomem *io_base = priv->PortOffset;
-	unsigned short wOffset;
+	unsigned short offset;
 	u32 dwData;
 	int     ii;
 
@@ -811,20 +811,20 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 		return;
 
 	pr_debug("MACvSetKeyEntry\n");
-	wOffset = MISCFIFO_KEYETRY0;
-	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
+	offset = MISCFIFO_KEYETRY0;
+	offset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 
 	dwData = 0;
 	dwData |= wKeyCtl;
 	dwData <<= 16;
 	dwData |= MAKEWORD(*(pbyAddr+4), *(pbyAddr+5));
-	pr_debug("1. wOffset: %d, Data: %X, KeyCtl:%X\n",
-		 wOffset, dwData, wKeyCtl);
+	pr_debug("1. offset: %d, Data: %X, KeyCtl:%X\n",
+		 offset, dwData, wKeyCtl);
 
-	iowrite16(wOffset, io_base + MAC_REG_MISCFFNDEX);
+	iowrite16(offset, io_base + MAC_REG_MISCFFNDEX);
 	iowrite32(dwData, io_base + MAC_REG_MISCFFDATA);
 	iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
-	wOffset++;
+	offset++;
 
 	dwData = 0;
 	dwData |= *(pbyAddr+3);
@@ -834,19 +834,19 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 	dwData |= *(pbyAddr+1);
 	dwData <<= 8;
 	dwData |= *(pbyAddr+0);
-	pr_debug("2. wOffset: %d, Data: %X\n", wOffset, dwData);
+	pr_debug("2. offset: %d, Data: %X\n", offset, dwData);
 
-	iowrite16(wOffset, io_base + MAC_REG_MISCFFNDEX);
+	iowrite16(offset, io_base + MAC_REG_MISCFFNDEX);
 	iowrite32(dwData, io_base + MAC_REG_MISCFFDATA);
 	iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
-	wOffset++;
+	offset++;
 
-	wOffset += (uKeyIdx * 4);
+	offset += (uKeyIdx * 4);
 	for (ii = 0; ii < 4; ii++) {
 		/* always push 128 bits */
-		pr_debug("3.(%d) wOffset: %d, Data: %X\n",
-			 ii, wOffset+ii, *pdwKey);
-		iowrite16(wOffset + ii, io_base + MAC_REG_MISCFFNDEX);
+		pr_debug("3.(%d) offset: %d, Data: %X\n",
+			 ii, offset + ii, *pdwKey);
+		iowrite16(offset + ii, io_base + MAC_REG_MISCFFNDEX);
 		iowrite32(*pdwKey++, io_base + MAC_REG_MISCFFDATA);
 		iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
 	}
@@ -869,12 +869,12 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 void MACvDisableKeyEntry(struct vnt_private *priv, unsigned int uEntryIdx)
 {
 	void __iomem *io_base = priv->PortOffset;
-	unsigned short wOffset;
+	unsigned short offset;
 
-	wOffset = MISCFIFO_KEYETRY0;
-	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
+	offset = MISCFIFO_KEYETRY0;
+	offset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 
-	iowrite16(wOffset, io_base + MAC_REG_MISCFFNDEX);
+	iowrite16(offset, io_base + MAC_REG_MISCFFNDEX);
 	iowrite32(0, io_base + MAC_REG_MISCFFDATA);
 	iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
 }

commit ebc9bd832f5e7ec42bfafb31d29eb24ed3c2f47c
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:10 2016 +0000

    staging: vt6655: mac.c replace byOrgDMACtl with org_dma_ctl
    
    Removing camel case and type prefix.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index d44026b76e21..87bec1c36f79 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -556,10 +556,10 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, u32 curr_desc_addr)
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
-	unsigned char byOrgDMACtl;
+	unsigned char org_dma_ctl;
 
-	byOrgDMACtl = ioread8(io_base + MAC_REG_RXDMACTL0);
-	if (byOrgDMACtl & DMACTL_RUN)
+	org_dma_ctl = ioread8(io_base + MAC_REG_RXDMACTL0);
+	if (org_dma_ctl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL0 + 2);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
@@ -568,7 +568,7 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, u32 curr_desc_addr)
 	}
 
 	iowrite32(curr_desc_addr, io_base + MAC_REG_RXDMAPTR0);
-	if (byOrgDMACtl & DMACTL_RUN)
+	if (org_dma_ctl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL0);
 }
 
@@ -590,10 +590,10 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 curr_desc_addr)
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
-	unsigned char byOrgDMACtl;
+	unsigned char org_dma_ctl;
 
-	byOrgDMACtl = ioread8(io_base + MAC_REG_RXDMACTL1);
-	if (byOrgDMACtl & DMACTL_RUN)
+	org_dma_ctl = ioread8(io_base + MAC_REG_RXDMACTL1);
+	if (org_dma_ctl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL1 + 2);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
@@ -602,7 +602,7 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 curr_desc_addr)
 	}
 
 	iowrite32(curr_desc_addr, io_base + MAC_REG_RXDMAPTR1);
-	if (byOrgDMACtl & DMACTL_RUN)
+	if (org_dma_ctl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL1);
 
 }
@@ -626,10 +626,10 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
-	unsigned char byOrgDMACtl;
+	unsigned char org_dma_ctl;
 
-	byOrgDMACtl = ioread8(io_base + MAC_REG_TXDMACTL0);
-	if (byOrgDMACtl & DMACTL_RUN)
+	org_dma_ctl = ioread8(io_base + MAC_REG_TXDMACTL0);
+	if (org_dma_ctl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_TXDMACTL0 + 2);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
@@ -638,7 +638,7 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
 	}
 
 	iowrite32(curr_desc_addr, io_base + MAC_REG_TXDMAPTR0);
-	if (byOrgDMACtl & DMACTL_RUN)
+	if (org_dma_ctl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_TXDMACTL0);
 }
 
@@ -662,10 +662,10 @@ void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
-	unsigned char byOrgDMACtl;
+	unsigned char org_dma_ctl;
 
-	byOrgDMACtl = ioread8(io_base + MAC_REG_AC0DMACTL);
-	if (byOrgDMACtl & DMACTL_RUN)
+	org_dma_ctl = ioread8(io_base + MAC_REG_AC0DMACTL);
+	if (org_dma_ctl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_AC0DMACTL + 2);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
@@ -675,7 +675,7 @@ void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
 	if (ww == W_MAX_TIMEOUT)
 		pr_debug(" DBG_PORT80(0x26)\n");
 	iowrite32(curr_desc_addr, io_base + MAC_REG_AC0DMAPTR);
-	if (byOrgDMACtl & DMACTL_RUN)
+	if (org_dma_ctl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_AC0DMACTL);
 }
 

commit 28029472aa1e18fd5c5777379eb28c8f7b837381
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:09 2016 +0000

    staging: vt6655: mac Replace dwCurrDescAddr with curr_desc_addr.
    
    Removing camel case and type prefix.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index a1be62d56fba..d44026b76e21 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -545,14 +545,14 @@ void MACvInitialize(struct vnt_private *priv)
  * Parameters:
  *  In:
  *      io_base        - Base Address for MAC
- *      dwCurrDescAddr  - Descriptor Address
+ *      curr_desc_addr  - Descriptor Address
  *  Out:
  *      none
  *
  * Return Value: none
  *
  */
-void MACvSetCurrRx0DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
+void MACvSetCurrRx0DescAddr(struct vnt_private *priv, u32 curr_desc_addr)
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
@@ -567,7 +567,7 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
 			break;
 	}
 
-	iowrite32(dwCurrDescAddr, io_base + MAC_REG_RXDMAPTR0);
+	iowrite32(curr_desc_addr, io_base + MAC_REG_RXDMAPTR0);
 	if (byOrgDMACtl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL0);
 }
@@ -579,14 +579,14 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
  * Parameters:
  *  In:
  *      io_base        - Base Address for MAC
- *      dwCurrDescAddr  - Descriptor Address
+ *      curr_desc_addr  - Descriptor Address
  *  Out:
  *      none
  *
  * Return Value: none
  *
  */
-void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
+void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 curr_desc_addr)
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
@@ -601,7 +601,7 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
 			break;
 	}
 
-	iowrite32(dwCurrDescAddr, io_base + MAC_REG_RXDMAPTR1);
+	iowrite32(curr_desc_addr, io_base + MAC_REG_RXDMAPTR1);
 	if (byOrgDMACtl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL1);
 
@@ -614,7 +614,7 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
  * Parameters:
  *  In:
  *      io_base        - Base Address for MAC
- *      dwCurrDescAddr  - Descriptor Address
+ *      curr_desc_addr  - Descriptor Address
  *  Out:
  *      none
  *
@@ -622,7 +622,7 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
  *
  */
 void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
-			      u32 dwCurrDescAddr)
+			      u32 curr_desc_addr)
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
@@ -637,7 +637,7 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
 			break;
 	}
 
-	iowrite32(dwCurrDescAddr, io_base + MAC_REG_TXDMAPTR0);
+	iowrite32(curr_desc_addr, io_base + MAC_REG_TXDMAPTR0);
 	if (byOrgDMACtl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_TXDMACTL0);
 }
@@ -649,7 +649,7 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
  * Parameters:
  *  In:
  *      io_base        - Base Address for MAC
- *      dwCurrDescAddr  - Descriptor Address
+ *      curr_desc_addr  - Descriptor Address
  *  Out:
  *      none
  *
@@ -658,7 +658,7 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
  */
 /* TxDMA1 = AC0DMA */
 void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
-			      u32 dwCurrDescAddr)
+			      u32 curr_desc_addr)
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
@@ -674,18 +674,18 @@ void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
 	}
 	if (ww == W_MAX_TIMEOUT)
 		pr_debug(" DBG_PORT80(0x26)\n");
-	iowrite32(dwCurrDescAddr, io_base + MAC_REG_AC0DMAPTR);
+	iowrite32(curr_desc_addr, io_base + MAC_REG_AC0DMAPTR);
 	if (byOrgDMACtl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_AC0DMACTL);
 }
 
 void MACvSetCurrTXDescAddr(int iTxType, struct vnt_private *priv,
-			   u32 dwCurrDescAddr)
+			   u32 curr_desc_addr)
 {
 	if (iTxType == TYPE_AC0DMA)
-		MACvSetCurrAC0DescAddrEx(priv, dwCurrDescAddr);
+		MACvSetCurrAC0DescAddrEx(priv, curr_desc_addr);
 	else if (iTxType == TYPE_TXDMA0)
-		MACvSetCurrTx0DescAddrEx(priv, dwCurrDescAddr);
+		MACvSetCurrTx0DescAddrEx(priv, curr_desc_addr);
 }
 
 /*

commit 17c4c51e0360e72dc752768927cd13a00c06e421
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:08 2016 +0000

    staging: vt6655: mac.c replace VNSvInPortB with ioread8
    
    Removing the macro from functions.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index ece2bf076521..a1be62d56fba 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -558,7 +558,7 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
 	unsigned short ww;
 	unsigned char byOrgDMACtl;
 
-	VNSvInPortB(io_base + MAC_REG_RXDMACTL0, &byOrgDMACtl);
+	byOrgDMACtl = ioread8(io_base + MAC_REG_RXDMACTL0);
 	if (byOrgDMACtl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL0 + 2);
 
@@ -592,7 +592,7 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
 	unsigned short ww;
 	unsigned char byOrgDMACtl;
 
-	VNSvInPortB(io_base + MAC_REG_RXDMACTL1, &byOrgDMACtl);
+	byOrgDMACtl = ioread8(io_base + MAC_REG_RXDMACTL1);
 	if (byOrgDMACtl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL1 + 2);
 
@@ -628,7 +628,7 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
 	unsigned short ww;
 	unsigned char byOrgDMACtl;
 
-	VNSvInPortB(io_base + MAC_REG_TXDMACTL0, &byOrgDMACtl);
+	byOrgDMACtl = ioread8(io_base + MAC_REG_TXDMACTL0);
 	if (byOrgDMACtl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_TXDMACTL0 + 2);
 
@@ -664,7 +664,7 @@ void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
 	unsigned short ww;
 	unsigned char byOrgDMACtl;
 
-	VNSvInPortB(io_base + MAC_REG_AC0DMACTL, &byOrgDMACtl);
+	byOrgDMACtl = ioread8(io_base + MAC_REG_AC0DMACTL);
 	if (byOrgDMACtl & DMACTL_RUN)
 		iowrite8(DMACTL_RUN, io_base + MAC_REG_AC0DMACTL + 2);
 
@@ -713,7 +713,7 @@ void MACvTimer0MicroSDelay(struct vnt_private *priv, unsigned int uDelay)
 	iowrite8((TMCTL_TMD | TMCTL_TE), io_base + MAC_REG_TMCTL0);
 	for (ii = 0; ii < 66; ii++) {  /* assume max PCI clock is 66Mhz */
 		for (uu = 0; uu < uDelay; uu++) {
-			VNSvInPortB(io_base + MAC_REG_TMCTL0, &byValue);
+			byValue = ioread8(io_base + MAC_REG_TMCTL0);
 			if ((byValue == 0) ||
 			    (byValue & TMCTL_TSUSP)) {
 				iowrite8(0, io_base + MAC_REG_TMCTL0);

commit 58fe2702c430e2db1210075ed890b5abb15e90f3
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:07 2016 +0000

    staging: vt6655: MACvSetLoopbackMode replace byOrgValue with ioread8
    
    Removing VNSvInPortB and nesting inside iowrite8.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 6499709bc865..ece2bf076521 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -184,14 +184,11 @@ void MACvSetLongRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit)
 void MACvSetLoopbackMode(struct vnt_private *priv, unsigned char byLoopbackMode)
 {
 	void __iomem *io_base = priv->PortOffset;
-	unsigned char byOrgValue;
 
 	byLoopbackMode <<= 6;
 	/* set TCR */
-	VNSvInPortB(io_base + MAC_REG_TEST, &byOrgValue);
-	byOrgValue = byOrgValue & 0x3F;
-	byOrgValue = byOrgValue | byLoopbackMode;
-	iowrite8(byOrgValue, io_base + MAC_REG_TEST);
+	iowrite8((ioread8(io_base + MAC_REG_TEST) & 0x3f) | byLoopbackMode,
+		 io_base + MAC_REG_TEST);
 }
 
 /*

commit e206939f99a1ed1625bcce32f6eb53c296576eff
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:06 2016 +0000

    staging: vt6655: MACbPSWakeup replace VNSvInPortB byOrgValue with ioread8
    
    removing byOrgValue variable.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index a1be5a7fd7ea..6499709bc865 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -765,7 +765,6 @@ void MACvSetMISCFifo(struct vnt_private *priv, unsigned short wOffset,
 bool MACbPSWakeup(struct vnt_private *priv)
 {
 	void __iomem *io_base = priv->PortOffset;
-	unsigned char byOrgValue;
 	unsigned int ww;
 	/* Read PSCTL */
 	if (MACbIsRegBitsOff(priv, MAC_REG_PSCTL, PSCTL_PS))
@@ -776,8 +775,7 @@ bool MACbPSWakeup(struct vnt_private *priv)
 
 	/* Check if SyncFlushOK */
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(io_base + MAC_REG_PSCTL, &byOrgValue);
-		if (byOrgValue & PSCTL_WAKEDONE)
+		if (ioread8(io_base + MAC_REG_PSCTL) & PSCTL_WAKEDONE)
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {

commit 3b8eb64c1b26f89de69b93907e6ada6e71e18df4
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:05 2016 +0000

    staging: vt6655: mac.c replace VNSvOutPortB with iowrite8
    
    removing macro from functions
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 43e5f66c45de..a1be5a7fd7ea 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -142,7 +142,7 @@ void MACvSetShortRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit
 {
 	void __iomem *io_base = priv->PortOffset;
 	/* set SRT */
-	VNSvOutPortB(io_base + MAC_REG_SRT, byRetryLimit);
+	iowrite8(byRetryLimit, io_base + MAC_REG_SRT);
 }
 
 
@@ -164,7 +164,7 @@ void MACvSetLongRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit)
 {
 	void __iomem *io_base = priv->PortOffset;
 	/* set LRT */
-	VNSvOutPortB(io_base + MAC_REG_LRT, byRetryLimit);
+	iowrite8(byRetryLimit, io_base + MAC_REG_LRT);
 }
 
 /*
@@ -191,7 +191,7 @@ void MACvSetLoopbackMode(struct vnt_private *priv, unsigned char byLoopbackMode)
 	VNSvInPortB(io_base + MAC_REG_TEST, &byOrgValue);
 	byOrgValue = byOrgValue & 0x3F;
 	byOrgValue = byOrgValue | byLoopbackMode;
-	VNSvOutPortB(io_base + MAC_REG_TEST, byOrgValue);
+	iowrite8(byOrgValue, io_base + MAC_REG_TEST);
 }
 
 /*
@@ -256,7 +256,7 @@ void MACvRestoreContext(struct vnt_private *priv, unsigned char *cxt_buf)
 	memcpy_toio(io_base + MAC_REG_LRT, cxt_buf + MAC_REG_LRT,
 		    MAC_REG_PAGE1SEL - MAC_REG_LRT);
 
-	VNSvOutPortB(io_base + MAC_REG_CFG, *(cxt_buf + MAC_REG_CFG));
+	iowrite8(*(cxt_buf + MAC_REG_CFG), io_base + MAC_REG_CFG);
 
 	/* restore PS Config. */
 	memcpy_toio(io_base + MAC_REG_PSCFG, cxt_buf + MAC_REG_PSCFG,
@@ -294,7 +294,7 @@ bool MACbSoftwareReset(struct vnt_private *priv)
 	unsigned short ww;
 
 	/* turn on HOSTCR_SOFTRST, just write 0x01 to reset */
-	VNSvOutPortB(io_base + MAC_REG_HOSTCR, 0x01);
+	iowrite8(0x01, io_base + MAC_REG_HOSTCR);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		if (!(ioread8(io_base + MAC_REG_HOSTCR) & HOSTCR_SOFTRST))
@@ -529,16 +529,16 @@ void MACvInitialize(struct vnt_private *priv)
 	/* clear sticky bits */
 	MACvClearStckDS(io_base);
 	/* disable force PME-enable */
-	VNSvOutPortB(io_base + MAC_REG_PMC1, PME_OVR);
+	iowrite8(PME_OVR, io_base + MAC_REG_PMC1);
 	/* only 3253 A */
 
 	/* do reset */
 	MACbSoftwareReset(priv);
 
 	/* reset TSF counter */
-	VNSvOutPortB(io_base + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
+	iowrite8(TFTCTL_TSFCNTRST, io_base + MAC_REG_TFTCTL);
 	/* enable TSF counter */
-	VNSvOutPortB(io_base + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
+	iowrite8(TFTCTL_TSFCNTREN, io_base + MAC_REG_TFTCTL);
 }
 
 /*
@@ -563,7 +563,7 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
 
 	VNSvInPortB(io_base + MAC_REG_RXDMACTL0, &byOrgDMACtl);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(io_base + MAC_REG_RXDMACTL0+2, DMACTL_RUN);
+		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL0 + 2);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		if (!(ioread8(io_base + MAC_REG_RXDMACTL0) & DMACTL_RUN))
@@ -572,7 +572,7 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
 
 	iowrite32(dwCurrDescAddr, io_base + MAC_REG_RXDMAPTR0);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(io_base + MAC_REG_RXDMACTL0, DMACTL_RUN);
+		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL0);
 }
 
 /*
@@ -597,7 +597,7 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
 
 	VNSvInPortB(io_base + MAC_REG_RXDMACTL1, &byOrgDMACtl);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(io_base + MAC_REG_RXDMACTL1+2, DMACTL_RUN);
+		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL1 + 2);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		if (!(ioread8(io_base + MAC_REG_RXDMACTL1) & DMACTL_RUN))
@@ -606,7 +606,7 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
 
 	iowrite32(dwCurrDescAddr, io_base + MAC_REG_RXDMAPTR1);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(io_base + MAC_REG_RXDMACTL1, DMACTL_RUN);
+		iowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL1);
 
 }
 
@@ -633,7 +633,7 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
 
 	VNSvInPortB(io_base + MAC_REG_TXDMACTL0, &byOrgDMACtl);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(io_base + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
+		iowrite8(DMACTL_RUN, io_base + MAC_REG_TXDMACTL0 + 2);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		if (!(ioread8(io_base + MAC_REG_TXDMACTL0) & DMACTL_RUN))
@@ -642,7 +642,7 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
 
 	iowrite32(dwCurrDescAddr, io_base + MAC_REG_TXDMAPTR0);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(io_base + MAC_REG_TXDMACTL0, DMACTL_RUN);
+		iowrite8(DMACTL_RUN, io_base + MAC_REG_TXDMACTL0);
 }
 
 /*
@@ -669,7 +669,7 @@ void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
 
 	VNSvInPortB(io_base + MAC_REG_AC0DMACTL, &byOrgDMACtl);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(io_base + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
+		iowrite8(DMACTL_RUN, io_base + MAC_REG_AC0DMACTL + 2);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		if (!(ioread8(io_base + MAC_REG_AC0DMACTL) & DMACTL_RUN))
@@ -679,7 +679,7 @@ void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
 		pr_debug(" DBG_PORT80(0x26)\n");
 	iowrite32(dwCurrDescAddr, io_base + MAC_REG_AC0DMAPTR);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(io_base + MAC_REG_AC0DMACTL, DMACTL_RUN);
+		iowrite8(DMACTL_RUN, io_base + MAC_REG_AC0DMACTL);
 }
 
 void MACvSetCurrTXDescAddr(int iTxType, struct vnt_private *priv,
@@ -711,20 +711,20 @@ void MACvTimer0MicroSDelay(struct vnt_private *priv, unsigned int uDelay)
 	unsigned char byValue;
 	unsigned int uu, ii;
 
-	VNSvOutPortB(io_base + MAC_REG_TMCTL0, 0);
+	iowrite8(0, io_base + MAC_REG_TMCTL0);
 	iowrite32(uDelay, io_base + MAC_REG_TMDATA0);
-	VNSvOutPortB(io_base + MAC_REG_TMCTL0, (TMCTL_TMD | TMCTL_TE));
+	iowrite8((TMCTL_TMD | TMCTL_TE), io_base + MAC_REG_TMCTL0);
 	for (ii = 0; ii < 66; ii++) {  /* assume max PCI clock is 66Mhz */
 		for (uu = 0; uu < uDelay; uu++) {
 			VNSvInPortB(io_base + MAC_REG_TMCTL0, &byValue);
 			if ((byValue == 0) ||
 			    (byValue & TMCTL_TSUSP)) {
-				VNSvOutPortB(io_base + MAC_REG_TMCTL0, 0);
+				iowrite8(0, io_base + MAC_REG_TMCTL0);
 				return;
 			}
 		}
 	}
-	VNSvOutPortB(io_base + MAC_REG_TMCTL0, 0);
+	iowrite8(0, io_base + MAC_REG_TMCTL0);
 }
 
 /*
@@ -745,9 +745,9 @@ void MACvOneShotTimer1MicroSec(struct vnt_private *priv, unsigned int uDelayTime
 {
 	void __iomem *io_base = priv->PortOffset;
 
-	VNSvOutPortB(io_base + MAC_REG_TMCTL1, 0);
+	iowrite8(0, io_base + MAC_REG_TMCTL1);
 	iowrite32(uDelayTime, io_base + MAC_REG_TMDATA1);
-	VNSvOutPortB(io_base + MAC_REG_TMCTL1, (TMCTL_TMD | TMCTL_TE));
+	iowrite8((TMCTL_TMD | TMCTL_TE), io_base + MAC_REG_TMCTL1);
 }
 
 void MACvSetMISCFifo(struct vnt_private *priv, unsigned short wOffset,

commit 54a14e62f406197644384d7d68910997ce2fe203
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:04 2016 +0000

    staging: vt6655: mac.c replace VNSvOutPortW with iowrite16
    
    removig macro from functions.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index a9ddb9540582..43e5f66c45de 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -757,9 +757,9 @@ void MACvSetMISCFifo(struct vnt_private *priv, unsigned short wOffset,
 
 	if (wOffset > 273)
 		return;
-	VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset);
+	iowrite16(wOffset, io_base + MAC_REG_MISCFFNDEX);
 	iowrite32(dwData, io_base + MAC_REG_MISCFFDATA);
-	VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
 }
 
 bool MACbPSWakeup(struct vnt_private *priv)
@@ -826,9 +826,9 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 	pr_debug("1. wOffset: %d, Data: %X, KeyCtl:%X\n",
 		 wOffset, dwData, wKeyCtl);
 
-	VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset);
+	iowrite16(wOffset, io_base + MAC_REG_MISCFFNDEX);
 	iowrite32(dwData, io_base + MAC_REG_MISCFFDATA);
-	VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
 	wOffset++;
 
 	dwData = 0;
@@ -841,9 +841,9 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 	dwData |= *(pbyAddr+0);
 	pr_debug("2. wOffset: %d, Data: %X\n", wOffset, dwData);
 
-	VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset);
+	iowrite16(wOffset, io_base + MAC_REG_MISCFFNDEX);
 	iowrite32(dwData, io_base + MAC_REG_MISCFFDATA);
-	VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
 	wOffset++;
 
 	wOffset += (uKeyIdx * 4);
@@ -851,9 +851,9 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 		/* always push 128 bits */
 		pr_debug("3.(%d) wOffset: %d, Data: %X\n",
 			 ii, wOffset+ii, *pdwKey);
-		VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset+ii);
+		iowrite16(wOffset + ii, io_base + MAC_REG_MISCFFNDEX);
 		iowrite32(*pdwKey++, io_base + MAC_REG_MISCFFDATA);
-		VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+		iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
 	}
 }
 
@@ -879,7 +879,7 @@ void MACvDisableKeyEntry(struct vnt_private *priv, unsigned int uEntryIdx)
 	wOffset = MISCFIFO_KEYETRY0;
 	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 
-	VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset);
+	iowrite16(wOffset, io_base + MAC_REG_MISCFFNDEX);
 	iowrite32(0, io_base + MAC_REG_MISCFFDATA);
-	VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	iowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);
 }

commit e2ad8e23ae259202a51c8762ef2c52fdbbd27196
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:03 2016 +0000

    staging: vt6655: mac.c replace VNSvOutPortD with iowrite32.
    
    Removing the macro from functions.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index c2723c15dd2f..a9ddb9540582 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -263,18 +263,16 @@ void MACvRestoreContext(struct vnt_private *priv, unsigned char *cxt_buf)
 		    MAC_REG_BBREGCTL - MAC_REG_PSCFG);
 
 	/* restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR */
-	VNSvOutPortD(io_base + MAC_REG_TXDMAPTR0,
-		     *(u32 *)(cxt_buf + MAC_REG_TXDMAPTR0));
-	VNSvOutPortD(io_base + MAC_REG_AC0DMAPTR,
-		     *(u32 *)(cxt_buf + MAC_REG_AC0DMAPTR));
-	VNSvOutPortD(io_base + MAC_REG_BCNDMAPTR,
-		     *(u32 *)(cxt_buf + MAC_REG_BCNDMAPTR));
-
-	VNSvOutPortD(io_base + MAC_REG_RXDMAPTR0,
-		     *(u32 *)(cxt_buf + MAC_REG_RXDMAPTR0));
-
-	VNSvOutPortD(io_base + MAC_REG_RXDMAPTR1,
-		     *(u32 *)(cxt_buf + MAC_REG_RXDMAPTR1));
+	iowrite32(*(u32 *)(cxt_buf + MAC_REG_TXDMAPTR0),
+		  io_base + MAC_REG_TXDMAPTR0);
+	iowrite32(*(u32 *)(cxt_buf + MAC_REG_AC0DMAPTR),
+		  io_base + MAC_REG_AC0DMAPTR);
+	iowrite32(*(u32 *)(cxt_buf + MAC_REG_BCNDMAPTR),
+		  io_base + MAC_REG_BCNDMAPTR);
+	iowrite32(*(u32 *)(cxt_buf + MAC_REG_RXDMAPTR0),
+		  io_base + MAC_REG_RXDMAPTR0);
+	iowrite32(*(u32 *)(cxt_buf + MAC_REG_RXDMAPTR1),
+		  io_base + MAC_REG_RXDMAPTR1);
 }
 
 /*
@@ -360,8 +358,8 @@ bool MACbSafeRxOff(struct vnt_private *priv)
 	/* turn off wow temp for turn off Rx safely */
 
 	/* Clear RX DMA0,1 */
-	VNSvOutPortD(io_base + MAC_REG_RXDMACTL0, DMACTL_CLRRUN);
-	VNSvOutPortD(io_base + MAC_REG_RXDMACTL1, DMACTL_CLRRUN);
+	iowrite32(DMACTL_CLRRUN, io_base + MAC_REG_RXDMACTL0);
+	iowrite32(DMACTL_CLRRUN, io_base + MAC_REG_RXDMACTL1);
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		if (!(ioread32(io_base + MAC_REG_RXDMACTL0) & DMACTL_RUN))
 			break;
@@ -413,9 +411,9 @@ bool MACbSafeTxOff(struct vnt_private *priv)
 
 	/* Clear TX DMA */
 	/* Tx0 */
-	VNSvOutPortD(io_base + MAC_REG_TXDMACTL0, DMACTL_CLRRUN);
+	iowrite32(DMACTL_CLRRUN, io_base + MAC_REG_TXDMACTL0);
 	/* AC0 */
-	VNSvOutPortD(io_base + MAC_REG_AC0DMACTL, DMACTL_CLRRUN);
+	iowrite32(DMACTL_CLRRUN, io_base + MAC_REG_AC0DMACTL);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		if (!(ioread32(io_base + MAC_REG_TXDMACTL0) & DMACTL_RUN))
@@ -572,7 +570,7 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
 			break;
 	}
 
-	VNSvOutPortD(io_base + MAC_REG_RXDMAPTR0, dwCurrDescAddr);
+	iowrite32(dwCurrDescAddr, io_base + MAC_REG_RXDMAPTR0);
 	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(io_base + MAC_REG_RXDMACTL0, DMACTL_RUN);
 }
@@ -606,7 +604,7 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
 			break;
 	}
 
-	VNSvOutPortD(io_base + MAC_REG_RXDMAPTR1, dwCurrDescAddr);
+	iowrite32(dwCurrDescAddr, io_base + MAC_REG_RXDMAPTR1);
 	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(io_base + MAC_REG_RXDMACTL1, DMACTL_RUN);
 
@@ -642,7 +640,7 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
 			break;
 	}
 
-	VNSvOutPortD(io_base + MAC_REG_TXDMAPTR0, dwCurrDescAddr);
+	iowrite32(dwCurrDescAddr, io_base + MAC_REG_TXDMAPTR0);
 	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(io_base + MAC_REG_TXDMACTL0, DMACTL_RUN);
 }
@@ -679,7 +677,7 @@ void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
 	}
 	if (ww == W_MAX_TIMEOUT)
 		pr_debug(" DBG_PORT80(0x26)\n");
-	VNSvOutPortD(io_base + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
+	iowrite32(dwCurrDescAddr, io_base + MAC_REG_AC0DMAPTR);
 	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(io_base + MAC_REG_AC0DMACTL, DMACTL_RUN);
 }
@@ -714,7 +712,7 @@ void MACvTimer0MicroSDelay(struct vnt_private *priv, unsigned int uDelay)
 	unsigned int uu, ii;
 
 	VNSvOutPortB(io_base + MAC_REG_TMCTL0, 0);
-	VNSvOutPortD(io_base + MAC_REG_TMDATA0, uDelay);
+	iowrite32(uDelay, io_base + MAC_REG_TMDATA0);
 	VNSvOutPortB(io_base + MAC_REG_TMCTL0, (TMCTL_TMD | TMCTL_TE));
 	for (ii = 0; ii < 66; ii++) {  /* assume max PCI clock is 66Mhz */
 		for (uu = 0; uu < uDelay; uu++) {
@@ -748,7 +746,7 @@ void MACvOneShotTimer1MicroSec(struct vnt_private *priv, unsigned int uDelayTime
 	void __iomem *io_base = priv->PortOffset;
 
 	VNSvOutPortB(io_base + MAC_REG_TMCTL1, 0);
-	VNSvOutPortD(io_base + MAC_REG_TMDATA1, uDelayTime);
+	iowrite32(uDelayTime, io_base + MAC_REG_TMDATA1);
 	VNSvOutPortB(io_base + MAC_REG_TMCTL1, (TMCTL_TMD | TMCTL_TE));
 }
 
@@ -760,7 +758,7 @@ void MACvSetMISCFifo(struct vnt_private *priv, unsigned short wOffset,
 	if (wOffset > 273)
 		return;
 	VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset);
-	VNSvOutPortD(io_base + MAC_REG_MISCFFDATA, dwData);
+	iowrite32(dwData, io_base + MAC_REG_MISCFFDATA);
 	VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 }
 
@@ -829,7 +827,7 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 		 wOffset, dwData, wKeyCtl);
 
 	VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset);
-	VNSvOutPortD(io_base + MAC_REG_MISCFFDATA, dwData);
+	iowrite32(dwData, io_base + MAC_REG_MISCFFDATA);
 	VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 	wOffset++;
 
@@ -844,7 +842,7 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 	pr_debug("2. wOffset: %d, Data: %X\n", wOffset, dwData);
 
 	VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset);
-	VNSvOutPortD(io_base + MAC_REG_MISCFFDATA, dwData);
+	iowrite32(dwData, io_base + MAC_REG_MISCFFDATA);
 	VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 	wOffset++;
 
@@ -854,7 +852,7 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 		pr_debug("3.(%d) wOffset: %d, Data: %X\n",
 			 ii, wOffset+ii, *pdwKey);
 		VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset+ii);
-		VNSvOutPortD(io_base + MAC_REG_MISCFFDATA, *pdwKey++);
+		iowrite32(*pdwKey++, io_base + MAC_REG_MISCFFDATA);
 		VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 	}
 }
@@ -882,6 +880,6 @@ void MACvDisableKeyEntry(struct vnt_private *priv, unsigned int uEntryIdx)
 	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 
 	VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset);
-	VNSvOutPortD(io_base + MAC_REG_MISCFFDATA, 0);
+	iowrite32(0, io_base + MAC_REG_MISCFFDATA);
 	VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 }

commit e984c758ec88f9c36a3f49311a842e4abc0d726b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:02 2016 +0000

    staging: vt6655: mac.c/h resize all unsigned long to u32
    
    All addressing is limited to 32 bits match this to all
    functions and port out functions.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 02e3e42a1cb7..c2723c15dd2f 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -264,17 +264,17 @@ void MACvRestoreContext(struct vnt_private *priv, unsigned char *cxt_buf)
 
 	/* restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR */
 	VNSvOutPortD(io_base + MAC_REG_TXDMAPTR0,
-		     *(unsigned long *)(cxt_buf + MAC_REG_TXDMAPTR0));
+		     *(u32 *)(cxt_buf + MAC_REG_TXDMAPTR0));
 	VNSvOutPortD(io_base + MAC_REG_AC0DMAPTR,
-		     *(unsigned long *)(cxt_buf + MAC_REG_AC0DMAPTR));
+		     *(u32 *)(cxt_buf + MAC_REG_AC0DMAPTR));
 	VNSvOutPortD(io_base + MAC_REG_BCNDMAPTR,
-		     *(unsigned long *)(cxt_buf + MAC_REG_BCNDMAPTR));
+		     *(u32 *)(cxt_buf + MAC_REG_BCNDMAPTR));
 
 	VNSvOutPortD(io_base + MAC_REG_RXDMAPTR0,
-		     *(unsigned long *)(cxt_buf + MAC_REG_RXDMAPTR0));
+		     *(u32 *)(cxt_buf + MAC_REG_RXDMAPTR0));
 
 	VNSvOutPortD(io_base + MAC_REG_RXDMAPTR1,
-		     *(unsigned long *)(cxt_buf + MAC_REG_RXDMAPTR1));
+		     *(u32 *)(cxt_buf + MAC_REG_RXDMAPTR1));
 }
 
 /*
@@ -557,7 +557,7 @@ void MACvInitialize(struct vnt_private *priv)
  * Return Value: none
  *
  */
-void MACvSetCurrRx0DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAddr)
+void MACvSetCurrRx0DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
@@ -591,7 +591,7 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAd
  * Return Value: none
  *
  */
-void MACvSetCurrRx1DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAddr)
+void MACvSetCurrRx1DescAddr(struct vnt_private *priv, u32 dwCurrDescAddr)
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
@@ -627,7 +627,7 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAd
  *
  */
 void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
-			      unsigned long dwCurrDescAddr)
+			      u32 dwCurrDescAddr)
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
@@ -663,7 +663,7 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
  */
 /* TxDMA1 = AC0DMA */
 void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
-			      unsigned long dwCurrDescAddr)
+			      u32 dwCurrDescAddr)
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
@@ -685,7 +685,7 @@ void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
 }
 
 void MACvSetCurrTXDescAddr(int iTxType, struct vnt_private *priv,
-			   unsigned long dwCurrDescAddr)
+			   u32 dwCurrDescAddr)
 {
 	if (iTxType == TYPE_AC0DMA)
 		MACvSetCurrAC0DescAddrEx(priv, dwCurrDescAddr);
@@ -753,7 +753,7 @@ void MACvOneShotTimer1MicroSec(struct vnt_private *priv, unsigned int uDelayTime
 }
 
 void MACvSetMISCFifo(struct vnt_private *priv, unsigned short wOffset,
-		     unsigned long dwData)
+		     u32 dwData)
 {
 	void __iomem *io_base = priv->PortOffset;
 

commit 4633195295008e565b8142f3e73376b8116dac49
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:01 2016 +0000

    staging: vt6655: MACvRestoreContext replace for loops with memcpy_toio.
    
    Removing the need for variable ii.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 9c4dabda0f44..02e3e42a1cb7 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -240,29 +240,27 @@ void MACvSaveContext(struct vnt_private *priv, unsigned char *cxt_buf)
 void MACvRestoreContext(struct vnt_private *priv, unsigned char *cxt_buf)
 {
 	void __iomem *io_base = priv->PortOffset;
-	int         ii;
 
 	MACvSelectPage1(io_base);
 	/* restore page1 */
-	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++)
-		VNSvOutPortB((io_base + ii),
-			     *(cxt_buf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
+	memcpy_toio(io_base, cxt_buf + MAC_MAX_CONTEXT_SIZE_PAGE0,
+		    MAC_MAX_CONTEXT_SIZE_PAGE1);
 
 	MACvSelectPage0(io_base);
 
 	/* restore RCR,TCR,IMR... */
-	for (ii = MAC_REG_RCR; ii < MAC_REG_ISR; ii++)
-		VNSvOutPortB(io_base + ii, *(cxt_buf + ii));
+	memcpy_toio(io_base + MAC_REG_RCR, cxt_buf + MAC_REG_RCR,
+		    MAC_REG_ISR - MAC_REG_RCR);
 
 	/* restore MAC Config. */
-	for (ii = MAC_REG_LRT; ii < MAC_REG_PAGE1SEL; ii++)
-		VNSvOutPortB(io_base + ii, *(cxt_buf + ii));
+	memcpy_toio(io_base + MAC_REG_LRT, cxt_buf + MAC_REG_LRT,
+		    MAC_REG_PAGE1SEL - MAC_REG_LRT);
 
 	VNSvOutPortB(io_base + MAC_REG_CFG, *(cxt_buf + MAC_REG_CFG));
 
 	/* restore PS Config. */
-	for (ii = MAC_REG_PSCFG; ii < MAC_REG_BBREGCTL; ii++)
-		VNSvOutPortB(io_base + ii, *(cxt_buf + ii));
+	memcpy_toio(io_base + MAC_REG_PSCFG, cxt_buf + MAC_REG_PSCFG,
+		    MAC_REG_BBREGCTL - MAC_REG_PSCFG);
 
 	/* restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR */
 	VNSvOutPortD(io_base + MAC_REG_TXDMAPTR0,

commit 70715017442e68ddb100b7b07ac9cb092e57a8e9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 6 12:57:00 2016 +0000

    staging: vt6655: mac.c rename pbyCxtBuf to cxt_buf
    
    Removing camel case and type prefix.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 66ae99137408..9c4dabda0f44 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -202,22 +202,22 @@ void MACvSetLoopbackMode(struct vnt_private *priv, unsigned char byLoopbackMode)
  *  In:
  *      io_base    - Base Address for MAC
  *  Out:
- *      pbyCxtBuf   - Context buffer
+ *      cxt_buf   - Context buffer
  *
  * Return Value: none
  *
  */
-void MACvSaveContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
+void MACvSaveContext(struct vnt_private *priv, unsigned char *cxt_buf)
 {
 	void __iomem *io_base = priv->PortOffset;
 
 	/* read page0 register */
-	memcpy_fromio(pbyCxtBuf, io_base, MAC_MAX_CONTEXT_SIZE_PAGE0);
+	memcpy_fromio(cxt_buf, io_base, MAC_MAX_CONTEXT_SIZE_PAGE0);
 
 	MACvSelectPage1(io_base);
 
 	/* read page1 register */
-	memcpy_fromio(pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0, io_base,
+	memcpy_fromio(cxt_buf + MAC_MAX_CONTEXT_SIZE_PAGE0, io_base,
 		      MAC_MAX_CONTEXT_SIZE_PAGE1);
 
 	MACvSelectPage0(io_base);
@@ -230,14 +230,14 @@ void MACvSaveContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
  * Parameters:
  *  In:
  *      io_base    - Base Address for MAC
- *      pbyCxtBuf   - Context buffer
+ *      cxt_buf   - Context buffer
  *  Out:
  *      none
  *
  * Return Value: none
  *
  */
-void MACvRestoreContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
+void MACvRestoreContext(struct vnt_private *priv, unsigned char *cxt_buf)
 {
 	void __iomem *io_base = priv->PortOffset;
 	int         ii;
@@ -246,37 +246,37 @@ void MACvRestoreContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
 	/* restore page1 */
 	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++)
 		VNSvOutPortB((io_base + ii),
-			     *(pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
+			     *(cxt_buf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
 
 	MACvSelectPage0(io_base);
 
 	/* restore RCR,TCR,IMR... */
 	for (ii = MAC_REG_RCR; ii < MAC_REG_ISR; ii++)
-		VNSvOutPortB(io_base + ii, *(pbyCxtBuf + ii));
+		VNSvOutPortB(io_base + ii, *(cxt_buf + ii));
 
 	/* restore MAC Config. */
 	for (ii = MAC_REG_LRT; ii < MAC_REG_PAGE1SEL; ii++)
-		VNSvOutPortB(io_base + ii, *(pbyCxtBuf + ii));
+		VNSvOutPortB(io_base + ii, *(cxt_buf + ii));
 
-	VNSvOutPortB(io_base + MAC_REG_CFG, *(pbyCxtBuf + MAC_REG_CFG));
+	VNSvOutPortB(io_base + MAC_REG_CFG, *(cxt_buf + MAC_REG_CFG));
 
 	/* restore PS Config. */
 	for (ii = MAC_REG_PSCFG; ii < MAC_REG_BBREGCTL; ii++)
-		VNSvOutPortB(io_base + ii, *(pbyCxtBuf + ii));
+		VNSvOutPortB(io_base + ii, *(cxt_buf + ii));
 
 	/* restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR */
 	VNSvOutPortD(io_base + MAC_REG_TXDMAPTR0,
-		     *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0));
+		     *(unsigned long *)(cxt_buf + MAC_REG_TXDMAPTR0));
 	VNSvOutPortD(io_base + MAC_REG_AC0DMAPTR,
-		     *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR));
+		     *(unsigned long *)(cxt_buf + MAC_REG_AC0DMAPTR));
 	VNSvOutPortD(io_base + MAC_REG_BCNDMAPTR,
-		     *(unsigned long *)(pbyCxtBuf + MAC_REG_BCNDMAPTR));
+		     *(unsigned long *)(cxt_buf + MAC_REG_BCNDMAPTR));
 
 	VNSvOutPortD(io_base + MAC_REG_RXDMAPTR0,
-		     *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0));
+		     *(unsigned long *)(cxt_buf + MAC_REG_RXDMAPTR0));
 
 	VNSvOutPortD(io_base + MAC_REG_RXDMAPTR1,
-		     *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1));
+		     *(unsigned long *)(cxt_buf + MAC_REG_RXDMAPTR1));
 }
 
 /*

commit 7e5120e949dac3ce436714ad686dff60ee75fc68
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Feb 28 19:02:57 2016 +0000

    staging: vt6655: MACvSaveContext use memcpy_fromio to read context.
    
    Use memcpy_fromio to store data removing the need for local count.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index c93592213310..66ae99137408 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -210,18 +210,15 @@ void MACvSetLoopbackMode(struct vnt_private *priv, unsigned char byLoopbackMode)
 void MACvSaveContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
 {
 	void __iomem *io_base = priv->PortOffset;
-	int         ii;
 
 	/* read page0 register */
-	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE0; ii++)
-		VNSvInPortB((io_base + ii), (pbyCxtBuf + ii));
+	memcpy_fromio(pbyCxtBuf, io_base, MAC_MAX_CONTEXT_SIZE_PAGE0);
 
 	MACvSelectPage1(io_base);
 
 	/* read page1 register */
-	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++)
-		VNSvInPortB((io_base + ii),
-			    (pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
+	memcpy_fromio(pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0, io_base,
+		      MAC_MAX_CONTEXT_SIZE_PAGE1);
 
 	MACvSelectPage0(io_base);
 }

commit e52ab0ecb2ba7f6e3ec121a595cd4eba6e854d13
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Feb 28 19:02:56 2016 +0000

    staging: vt6655: replace VNSvInPortD dwData reads with ioread32
    
    Removing dwData variable altogether.
    
    The reads are always 32 bit insize.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 893fc5228a4f..c93592213310 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -117,10 +117,8 @@ bool MACbIsRegBitsOff(struct vnt_private *priv, unsigned char byRegOfs,
 bool MACbIsIntDisable(struct vnt_private *priv)
 {
 	void __iomem *io_base = priv->PortOffset;
-	unsigned long dwData;
 
-	VNSvInPortD(io_base + MAC_REG_IMR, &dwData);
-	if (dwData != 0)
+	if (ioread32(io_base + MAC_REG_IMR))
 		return false;
 
 	return true;
@@ -363,7 +361,6 @@ bool MACbSafeRxOff(struct vnt_private *priv)
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
-	unsigned long dwData;
 
 	/* turn off wow temp for turn off Rx safely */
 
@@ -371,8 +368,7 @@ bool MACbSafeRxOff(struct vnt_private *priv)
 	VNSvOutPortD(io_base + MAC_REG_RXDMACTL0, DMACTL_CLRRUN);
 	VNSvOutPortD(io_base + MAC_REG_RXDMACTL1, DMACTL_CLRRUN);
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortD(io_base + MAC_REG_RXDMACTL0, &dwData);
-		if (!(dwData & DMACTL_RUN))
+		if (!(ioread32(io_base + MAC_REG_RXDMACTL0) & DMACTL_RUN))
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
@@ -380,8 +376,7 @@ bool MACbSafeRxOff(struct vnt_private *priv)
 		return false;
 	}
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortD(io_base + MAC_REG_RXDMACTL1, &dwData);
-		if (!(dwData & DMACTL_RUN))
+		if (!(ioread32(io_base + MAC_REG_RXDMACTL1) & DMACTL_RUN))
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
@@ -420,7 +415,6 @@ bool MACbSafeTxOff(struct vnt_private *priv)
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
-	unsigned long dwData;
 
 	/* Clear TX DMA */
 	/* Tx0 */
@@ -429,8 +423,7 @@ bool MACbSafeTxOff(struct vnt_private *priv)
 	VNSvOutPortD(io_base + MAC_REG_AC0DMACTL, DMACTL_CLRRUN);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortD(io_base + MAC_REG_TXDMACTL0, &dwData);
-		if (!(dwData & DMACTL_RUN))
+		if (!(ioread32(io_base + MAC_REG_TXDMACTL0) & DMACTL_RUN))
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
@@ -438,8 +431,7 @@ bool MACbSafeTxOff(struct vnt_private *priv)
 		return false;
 	}
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortD(io_base + MAC_REG_AC0DMACTL, &dwData);
-		if (!(dwData & DMACTL_RUN))
+		if (!(ioread32(io_base + MAC_REG_AC0DMACTL) & DMACTL_RUN))
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {

commit f205e8d129b172ae8ab33bb19abf2a7e6984f200
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Feb 28 19:02:55 2016 +0000

    staging: vt6655: mac.c Replace VNSvInPortB byData reads with ioread8.
    
    Removing byData variable altogether.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 5a4fc3be73a9..893fc5228a4f 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -74,10 +74,8 @@ bool MACbIsRegBitsOn(struct vnt_private *priv, unsigned char byRegOfs,
 		     unsigned char byTestBits)
 {
 	void __iomem *io_base = priv->PortOffset;
-	unsigned char byData;
 
-	VNSvInPortB(io_base + byRegOfs, &byData);
-	return (byData & byTestBits) == byTestBits;
+	return (ioread8(io_base + byRegOfs) & byTestBits) == byTestBits;
 }
 
 /*
@@ -99,10 +97,8 @@ bool MACbIsRegBitsOff(struct vnt_private *priv, unsigned char byRegOfs,
 		      unsigned char byTestBits)
 {
 	void __iomem *io_base = priv->PortOffset;
-	unsigned char byData;
 
-	VNSvInPortB(io_base + byRegOfs, &byData);
-	return !(byData & byTestBits);
+	return !(ioread8(io_base + byRegOfs) & byTestBits);
 }
 
 /*
@@ -304,15 +300,13 @@ void MACvRestoreContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
 bool MACbSoftwareReset(struct vnt_private *priv)
 {
 	void __iomem *io_base = priv->PortOffset;
-	unsigned char byData;
 	unsigned short ww;
 
 	/* turn on HOSTCR_SOFTRST, just write 0x01 to reset */
 	VNSvOutPortB(io_base + MAC_REG_HOSTCR, 0x01);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(io_base + MAC_REG_HOSTCR, &byData);
-		if (!(byData & HOSTCR_SOFTRST))
+		if (!(ioread8(io_base + MAC_REG_HOSTCR) & HOSTCR_SOFTRST))
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT)
@@ -370,7 +364,6 @@ bool MACbSafeRxOff(struct vnt_private *priv)
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
 	unsigned long dwData;
-	unsigned char byData;
 
 	/* turn off wow temp for turn off Rx safely */
 
@@ -400,8 +393,7 @@ bool MACbSafeRxOff(struct vnt_private *priv)
 	MACvRegBitsOff(io_base, MAC_REG_HOSTCR, HOSTCR_RXON);
 	/* W_MAX_TIMEOUT is the timeout period */
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(io_base + MAC_REG_HOSTCR, &byData);
-		if (!(byData & HOSTCR_RXONST))
+		if (!(ioread8(io_base + MAC_REG_HOSTCR) & HOSTCR_RXONST))
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
@@ -429,7 +421,6 @@ bool MACbSafeTxOff(struct vnt_private *priv)
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
 	unsigned long dwData;
-	unsigned char byData;
 
 	/* Clear TX DMA */
 	/* Tx0 */
@@ -461,8 +452,7 @@ bool MACbSafeTxOff(struct vnt_private *priv)
 
 	/* W_MAX_TIMEOUT is the timeout period */
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(io_base + MAC_REG_HOSTCR, &byData);
-		if (!(byData & HOSTCR_TXONST))
+		if (!(ioread8(io_base + MAC_REG_HOSTCR) & HOSTCR_TXONST))
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
@@ -584,7 +574,6 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAd
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
-	unsigned char byData;
 	unsigned char byOrgDMACtl;
 
 	VNSvInPortB(io_base + MAC_REG_RXDMACTL0, &byOrgDMACtl);
@@ -592,8 +581,7 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAd
 		VNSvOutPortB(io_base + MAC_REG_RXDMACTL0+2, DMACTL_RUN);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(io_base + MAC_REG_RXDMACTL0, &byData);
-		if (!(byData & DMACTL_RUN))
+		if (!(ioread8(io_base + MAC_REG_RXDMACTL0) & DMACTL_RUN))
 			break;
 	}
 
@@ -620,7 +608,6 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAd
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
-	unsigned char byData;
 	unsigned char byOrgDMACtl;
 
 	VNSvInPortB(io_base + MAC_REG_RXDMACTL1, &byOrgDMACtl);
@@ -628,8 +615,7 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAd
 		VNSvOutPortB(io_base + MAC_REG_RXDMACTL1+2, DMACTL_RUN);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(io_base + MAC_REG_RXDMACTL1, &byData);
-		if (!(byData & DMACTL_RUN))
+		if (!(ioread8(io_base + MAC_REG_RXDMACTL1) & DMACTL_RUN))
 			break;
 	}
 
@@ -658,7 +644,6 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
-	unsigned char byData;
 	unsigned char byOrgDMACtl;
 
 	VNSvInPortB(io_base + MAC_REG_TXDMACTL0, &byOrgDMACtl);
@@ -666,8 +651,7 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
 		VNSvOutPortB(io_base + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(io_base + MAC_REG_TXDMACTL0, &byData);
-		if (!(byData & DMACTL_RUN))
+		if (!(ioread8(io_base + MAC_REG_TXDMACTL0) & DMACTL_RUN))
 			break;
 	}
 
@@ -696,7 +680,6 @@ void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
 {
 	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
-	unsigned char byData;
 	unsigned char byOrgDMACtl;
 
 	VNSvInPortB(io_base + MAC_REG_AC0DMACTL, &byOrgDMACtl);
@@ -704,8 +687,7 @@ void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
 		VNSvOutPortB(io_base + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(io_base + MAC_REG_AC0DMACTL, &byData);
-		if (!(byData & DMACTL_RUN))
+		if (!(ioread8(io_base + MAC_REG_AC0DMACTL) & DMACTL_RUN))
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT)

commit c2d845de8fcf2df676761963fd46b1ecb1783772
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Feb 28 19:02:54 2016 +0000

    staging: vt6655: mac.c rename dwIoBase to io_base
    
    Removing camel case.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 79e42d075cde..5a4fc3be73a9 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -61,7 +61,7 @@
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *      byRegOfs    - Offset of MAC Register
  *      byTestBits  - Test bits
  *  Out:
@@ -73,10 +73,10 @@
 bool MACbIsRegBitsOn(struct vnt_private *priv, unsigned char byRegOfs,
 		     unsigned char byTestBits)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned char byData;
 
-	VNSvInPortB(dwIoBase + byRegOfs, &byData);
+	VNSvInPortB(io_base + byRegOfs, &byData);
 	return (byData & byTestBits) == byTestBits;
 }
 
@@ -86,7 +86,7 @@ bool MACbIsRegBitsOn(struct vnt_private *priv, unsigned char byRegOfs,
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *      byRegOfs    - Offset of MAC Register
  *      byTestBits  - Test bits
  *  Out:
@@ -98,10 +98,10 @@ bool MACbIsRegBitsOn(struct vnt_private *priv, unsigned char byRegOfs,
 bool MACbIsRegBitsOff(struct vnt_private *priv, unsigned char byRegOfs,
 		      unsigned char byTestBits)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned char byData;
 
-	VNSvInPortB(dwIoBase + byRegOfs, &byData);
+	VNSvInPortB(io_base + byRegOfs, &byData);
 	return !(byData & byTestBits);
 }
 
@@ -111,7 +111,7 @@ bool MACbIsRegBitsOff(struct vnt_private *priv, unsigned char byRegOfs,
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *  Out:
  *      none
  *
@@ -120,10 +120,10 @@ bool MACbIsRegBitsOff(struct vnt_private *priv, unsigned char byRegOfs,
  */
 bool MACbIsIntDisable(struct vnt_private *priv)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned long dwData;
 
-	VNSvInPortD(dwIoBase + MAC_REG_IMR, &dwData);
+	VNSvInPortD(io_base + MAC_REG_IMR, &dwData);
 	if (dwData != 0)
 		return false;
 
@@ -136,7 +136,7 @@ bool MACbIsIntDisable(struct vnt_private *priv)
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *      byRetryLimit- Retry Limit
  *  Out:
  *      none
@@ -146,9 +146,9 @@ bool MACbIsIntDisable(struct vnt_private *priv)
  */
 void MACvSetShortRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	/* set SRT */
-	VNSvOutPortB(dwIoBase + MAC_REG_SRT, byRetryLimit);
+	VNSvOutPortB(io_base + MAC_REG_SRT, byRetryLimit);
 }
 
 
@@ -158,7 +158,7 @@ void MACvSetShortRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *      byRetryLimit- Retry Limit
  *  Out:
  *      none
@@ -168,9 +168,9 @@ void MACvSetShortRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit
  */
 void MACvSetLongRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	/* set LRT */
-	VNSvOutPortB(dwIoBase + MAC_REG_LRT, byRetryLimit);
+	VNSvOutPortB(io_base + MAC_REG_LRT, byRetryLimit);
 }
 
 /*
@@ -179,7 +179,7 @@ void MACvSetLongRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit)
  *
  * Parameters:
  *  In:
- *      dwIoBase        - Base Address for MAC
+ *      io_base        - Base Address for MAC
  *      byLoopbackMode  - Loopback Mode
  *  Out:
  *      none
@@ -189,15 +189,15 @@ void MACvSetLongRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit)
  */
 void MACvSetLoopbackMode(struct vnt_private *priv, unsigned char byLoopbackMode)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned char byOrgValue;
 
 	byLoopbackMode <<= 6;
 	/* set TCR */
-	VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
+	VNSvInPortB(io_base + MAC_REG_TEST, &byOrgValue);
 	byOrgValue = byOrgValue & 0x3F;
 	byOrgValue = byOrgValue | byLoopbackMode;
-	VNSvOutPortB(dwIoBase + MAC_REG_TEST, byOrgValue);
+	VNSvOutPortB(io_base + MAC_REG_TEST, byOrgValue);
 }
 
 /*
@@ -206,7 +206,7 @@ void MACvSetLoopbackMode(struct vnt_private *priv, unsigned char byLoopbackMode)
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *  Out:
  *      pbyCxtBuf   - Context buffer
  *
@@ -215,21 +215,21 @@ void MACvSetLoopbackMode(struct vnt_private *priv, unsigned char byLoopbackMode)
  */
 void MACvSaveContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	int         ii;
 
 	/* read page0 register */
 	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE0; ii++)
-		VNSvInPortB((dwIoBase + ii), (pbyCxtBuf + ii));
+		VNSvInPortB((io_base + ii), (pbyCxtBuf + ii));
 
-	MACvSelectPage1(dwIoBase);
+	MACvSelectPage1(io_base);
 
 	/* read page1 register */
 	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++)
-		VNSvInPortB((dwIoBase + ii),
+		VNSvInPortB((io_base + ii),
 			    (pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
 
-	MACvSelectPage0(dwIoBase);
+	MACvSelectPage0(io_base);
 }
 
 /*
@@ -238,7 +238,7 @@ void MACvSaveContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *      pbyCxtBuf   - Context buffer
  *  Out:
  *      none
@@ -248,43 +248,43 @@ void MACvSaveContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
  */
 void MACvRestoreContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	int         ii;
 
-	MACvSelectPage1(dwIoBase);
+	MACvSelectPage1(io_base);
 	/* restore page1 */
 	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++)
-		VNSvOutPortB((dwIoBase + ii),
+		VNSvOutPortB((io_base + ii),
 			     *(pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
 
-	MACvSelectPage0(dwIoBase);
+	MACvSelectPage0(io_base);
 
 	/* restore RCR,TCR,IMR... */
 	for (ii = MAC_REG_RCR; ii < MAC_REG_ISR; ii++)
-		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
+		VNSvOutPortB(io_base + ii, *(pbyCxtBuf + ii));
 
 	/* restore MAC Config. */
 	for (ii = MAC_REG_LRT; ii < MAC_REG_PAGE1SEL; ii++)
-		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
+		VNSvOutPortB(io_base + ii, *(pbyCxtBuf + ii));
 
-	VNSvOutPortB(dwIoBase + MAC_REG_CFG, *(pbyCxtBuf + MAC_REG_CFG));
+	VNSvOutPortB(io_base + MAC_REG_CFG, *(pbyCxtBuf + MAC_REG_CFG));
 
 	/* restore PS Config. */
 	for (ii = MAC_REG_PSCFG; ii < MAC_REG_BBREGCTL; ii++)
-		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
+		VNSvOutPortB(io_base + ii, *(pbyCxtBuf + ii));
 
 	/* restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR */
-	VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0,
+	VNSvOutPortD(io_base + MAC_REG_TXDMAPTR0,
 		     *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0));
-	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR,
+	VNSvOutPortD(io_base + MAC_REG_AC0DMAPTR,
 		     *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR));
-	VNSvOutPortD(dwIoBase + MAC_REG_BCNDMAPTR,
+	VNSvOutPortD(io_base + MAC_REG_BCNDMAPTR,
 		     *(unsigned long *)(pbyCxtBuf + MAC_REG_BCNDMAPTR));
 
-	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0,
+	VNSvOutPortD(io_base + MAC_REG_RXDMAPTR0,
 		     *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0));
 
-	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1,
+	VNSvOutPortD(io_base + MAC_REG_RXDMAPTR1,
 		     *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1));
 }
 
@@ -294,7 +294,7 @@ void MACvRestoreContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *  Out:
  *      none
  *
@@ -303,15 +303,15 @@ void MACvRestoreContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
  */
 bool MACbSoftwareReset(struct vnt_private *priv)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned char byData;
 	unsigned short ww;
 
 	/* turn on HOSTCR_SOFTRST, just write 0x01 to reset */
-	VNSvOutPortB(dwIoBase + MAC_REG_HOSTCR, 0x01);
+	VNSvOutPortB(io_base + MAC_REG_HOSTCR, 0x01);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
+		VNSvInPortB(io_base + MAC_REG_HOSTCR, &byData);
 		if (!(byData & HOSTCR_SOFTRST))
 			break;
 	}
@@ -326,7 +326,7 @@ bool MACbSoftwareReset(struct vnt_private *priv)
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *  Out:
  *      none
  *
@@ -358,7 +358,7 @@ bool MACbSafeSoftwareReset(struct vnt_private *priv)
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *  Out:
  *      none
  *
@@ -367,7 +367,7 @@ bool MACbSafeSoftwareReset(struct vnt_private *priv)
  */
 bool MACbSafeRxOff(struct vnt_private *priv)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
 	unsigned long dwData;
 	unsigned char byData;
@@ -375,10 +375,10 @@ bool MACbSafeRxOff(struct vnt_private *priv)
 	/* turn off wow temp for turn off Rx safely */
 
 	/* Clear RX DMA0,1 */
-	VNSvOutPortD(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_CLRRUN);
-	VNSvOutPortD(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_CLRRUN);
+	VNSvOutPortD(io_base + MAC_REG_RXDMACTL0, DMACTL_CLRRUN);
+	VNSvOutPortD(io_base + MAC_REG_RXDMACTL1, DMACTL_CLRRUN);
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL0, &dwData);
+		VNSvInPortD(io_base + MAC_REG_RXDMACTL0, &dwData);
 		if (!(dwData & DMACTL_RUN))
 			break;
 	}
@@ -387,7 +387,7 @@ bool MACbSafeRxOff(struct vnt_private *priv)
 		return false;
 	}
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL1, &dwData);
+		VNSvInPortD(io_base + MAC_REG_RXDMACTL1, &dwData);
 		if (!(dwData & DMACTL_RUN))
 			break;
 	}
@@ -397,10 +397,10 @@ bool MACbSafeRxOff(struct vnt_private *priv)
 	}
 
 	/* try to safe shutdown RX */
-	MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_RXON);
+	MACvRegBitsOff(io_base, MAC_REG_HOSTCR, HOSTCR_RXON);
 	/* W_MAX_TIMEOUT is the timeout period */
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
+		VNSvInPortB(io_base + MAC_REG_HOSTCR, &byData);
 		if (!(byData & HOSTCR_RXONST))
 			break;
 	}
@@ -417,7 +417,7 @@ bool MACbSafeRxOff(struct vnt_private *priv)
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *  Out:
  *      none
  *
@@ -426,19 +426,19 @@ bool MACbSafeRxOff(struct vnt_private *priv)
  */
 bool MACbSafeTxOff(struct vnt_private *priv)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
 	unsigned long dwData;
 	unsigned char byData;
 
 	/* Clear TX DMA */
 	/* Tx0 */
-	VNSvOutPortD(dwIoBase + MAC_REG_TXDMACTL0, DMACTL_CLRRUN);
+	VNSvOutPortD(io_base + MAC_REG_TXDMACTL0, DMACTL_CLRRUN);
 	/* AC0 */
-	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_CLRRUN);
+	VNSvOutPortD(io_base + MAC_REG_AC0DMACTL, DMACTL_CLRRUN);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortD(dwIoBase + MAC_REG_TXDMACTL0, &dwData);
+		VNSvInPortD(io_base + MAC_REG_TXDMACTL0, &dwData);
 		if (!(dwData & DMACTL_RUN))
 			break;
 	}
@@ -447,7 +447,7 @@ bool MACbSafeTxOff(struct vnt_private *priv)
 		return false;
 	}
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortD(dwIoBase + MAC_REG_AC0DMACTL, &dwData);
+		VNSvInPortD(io_base + MAC_REG_AC0DMACTL, &dwData);
 		if (!(dwData & DMACTL_RUN))
 			break;
 	}
@@ -457,11 +457,11 @@ bool MACbSafeTxOff(struct vnt_private *priv)
 	}
 
 	/* try to safe shutdown TX */
-	MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_TXON);
+	MACvRegBitsOff(io_base, MAC_REG_HOSTCR, HOSTCR_TXON);
 
 	/* W_MAX_TIMEOUT is the timeout period */
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
+		VNSvInPortB(io_base + MAC_REG_HOSTCR, &byData);
 		if (!(byData & HOSTCR_TXONST))
 			break;
 	}
@@ -478,7 +478,7 @@ bool MACbSafeTxOff(struct vnt_private *priv)
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *  Out:
  *      none
  *
@@ -487,9 +487,9 @@ bool MACbSafeTxOff(struct vnt_private *priv)
  */
 bool MACbSafeStop(struct vnt_private *priv)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 
-	MACvRegBitsOff(dwIoBase, MAC_REG_TCR, TCR_AUTOBCNTX);
+	MACvRegBitsOff(io_base, MAC_REG_TCR, TCR_AUTOBCNTX);
 
 	if (!MACbSafeRxOff(priv)) {
 		pr_debug(" MACbSafeRxOff == false)\n");
@@ -502,7 +502,7 @@ bool MACbSafeStop(struct vnt_private *priv)
 		return false;
 	}
 
-	MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_MACEN);
+	MACvRegBitsOff(io_base, MAC_REG_HOSTCR, HOSTCR_MACEN);
 
 	return true;
 }
@@ -513,7 +513,7 @@ bool MACbSafeStop(struct vnt_private *priv)
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *  Out:
  *      none
  *
@@ -522,9 +522,9 @@ bool MACbSafeStop(struct vnt_private *priv)
  */
 bool MACbShutdown(struct vnt_private *priv)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	/* disable MAC IMR */
-	MACvIntDisable(dwIoBase);
+	MACvIntDisable(io_base);
 	MACvSetLoopbackMode(priv, MAC_LB_INTERNAL);
 	/* stop the adapter */
 	if (!MACbSafeStop(priv)) {
@@ -541,7 +541,7 @@ bool MACbShutdown(struct vnt_private *priv)
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *  Out:
  *      none
  *
@@ -550,20 +550,20 @@ bool MACbShutdown(struct vnt_private *priv)
  */
 void MACvInitialize(struct vnt_private *priv)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	/* clear sticky bits */
-	MACvClearStckDS(dwIoBase);
+	MACvClearStckDS(io_base);
 	/* disable force PME-enable */
-	VNSvOutPortB(dwIoBase + MAC_REG_PMC1, PME_OVR);
+	VNSvOutPortB(io_base + MAC_REG_PMC1, PME_OVR);
 	/* only 3253 A */
 
 	/* do reset */
 	MACbSoftwareReset(priv);
 
 	/* reset TSF counter */
-	VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
+	VNSvOutPortB(io_base + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
 	/* enable TSF counter */
-	VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
+	VNSvOutPortB(io_base + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
 }
 
 /*
@@ -572,7 +572,7 @@ void MACvInitialize(struct vnt_private *priv)
  *
  * Parameters:
  *  In:
- *      dwIoBase        - Base Address for MAC
+ *      io_base        - Base Address for MAC
  *      dwCurrDescAddr  - Descriptor Address
  *  Out:
  *      none
@@ -582,24 +582,24 @@ void MACvInitialize(struct vnt_private *priv)
  */
 void MACvSetCurrRx0DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAddr)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
 	unsigned char byData;
 	unsigned char byOrgDMACtl;
 
-	VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byOrgDMACtl);
+	VNSvInPortB(io_base + MAC_REG_RXDMACTL0, &byOrgDMACtl);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0+2, DMACTL_RUN);
+		VNSvOutPortB(io_base + MAC_REG_RXDMACTL0+2, DMACTL_RUN);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byData);
+		VNSvInPortB(io_base + MAC_REG_RXDMACTL0, &byData);
 		if (!(byData & DMACTL_RUN))
 			break;
 	}
 
-	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, dwCurrDescAddr);
+	VNSvOutPortD(io_base + MAC_REG_RXDMAPTR0, dwCurrDescAddr);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_RUN);
+		VNSvOutPortB(io_base + MAC_REG_RXDMACTL0, DMACTL_RUN);
 }
 
 /*
@@ -608,7 +608,7 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAd
  *
  * Parameters:
  *  In:
- *      dwIoBase        - Base Address for MAC
+ *      io_base        - Base Address for MAC
  *      dwCurrDescAddr  - Descriptor Address
  *  Out:
  *      none
@@ -618,24 +618,24 @@ void MACvSetCurrRx0DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAd
  */
 void MACvSetCurrRx1DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAddr)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
 	unsigned char byData;
 	unsigned char byOrgDMACtl;
 
-	VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byOrgDMACtl);
+	VNSvInPortB(io_base + MAC_REG_RXDMACTL1, &byOrgDMACtl);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1+2, DMACTL_RUN);
+		VNSvOutPortB(io_base + MAC_REG_RXDMACTL1+2, DMACTL_RUN);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byData);
+		VNSvInPortB(io_base + MAC_REG_RXDMACTL1, &byData);
 		if (!(byData & DMACTL_RUN))
 			break;
 	}
 
-	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, dwCurrDescAddr);
+	VNSvOutPortD(io_base + MAC_REG_RXDMAPTR1, dwCurrDescAddr);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_RUN);
+		VNSvOutPortB(io_base + MAC_REG_RXDMACTL1, DMACTL_RUN);
 
 }
 
@@ -645,7 +645,7 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAd
  *
  * Parameters:
  *  In:
- *      dwIoBase        - Base Address for MAC
+ *      io_base        - Base Address for MAC
  *      dwCurrDescAddr  - Descriptor Address
  *  Out:
  *      none
@@ -656,24 +656,24 @@ void MACvSetCurrRx1DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAd
 void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
 			      unsigned long dwCurrDescAddr)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
 	unsigned char byData;
 	unsigned char byOrgDMACtl;
 
-	VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byOrgDMACtl);
+	VNSvInPortB(io_base + MAC_REG_TXDMACTL0, &byOrgDMACtl);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
+		VNSvOutPortB(io_base + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
+		VNSvInPortB(io_base + MAC_REG_TXDMACTL0, &byData);
 		if (!(byData & DMACTL_RUN))
 			break;
 	}
 
-	VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, dwCurrDescAddr);
+	VNSvOutPortD(io_base + MAC_REG_TXDMAPTR0, dwCurrDescAddr);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0, DMACTL_RUN);
+		VNSvOutPortB(io_base + MAC_REG_TXDMACTL0, DMACTL_RUN);
 }
 
 /*
@@ -682,7 +682,7 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
  *
  * Parameters:
  *  In:
- *      dwIoBase        - Base Address for MAC
+ *      io_base        - Base Address for MAC
  *      dwCurrDescAddr  - Descriptor Address
  *  Out:
  *      none
@@ -694,25 +694,25 @@ void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
 void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
 			      unsigned long dwCurrDescAddr)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned short ww;
 	unsigned char byData;
 	unsigned char byOrgDMACtl;
 
-	VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byOrgDMACtl);
+	VNSvInPortB(io_base + MAC_REG_AC0DMACTL, &byOrgDMACtl);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
+		VNSvOutPortB(io_base + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
+		VNSvInPortB(io_base + MAC_REG_AC0DMACTL, &byData);
 		if (!(byData & DMACTL_RUN))
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT)
 		pr_debug(" DBG_PORT80(0x26)\n");
-	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
+	VNSvOutPortD(io_base + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
 	if (byOrgDMACtl & DMACTL_RUN)
-		VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_RUN);
+		VNSvOutPortB(io_base + MAC_REG_AC0DMACTL, DMACTL_RUN);
 }
 
 void MACvSetCurrTXDescAddr(int iTxType, struct vnt_private *priv,
@@ -730,7 +730,7 @@ void MACvSetCurrTXDescAddr(int iTxType, struct vnt_private *priv,
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *      uDelay      - Delay time (timer resolution is 4 us)
  *  Out:
  *      none
@@ -740,24 +740,24 @@ void MACvSetCurrTXDescAddr(int iTxType, struct vnt_private *priv,
  */
 void MACvTimer0MicroSDelay(struct vnt_private *priv, unsigned int uDelay)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned char byValue;
 	unsigned int uu, ii;
 
-	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
-	VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelay);
-	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, (TMCTL_TMD | TMCTL_TE));
+	VNSvOutPortB(io_base + MAC_REG_TMCTL0, 0);
+	VNSvOutPortD(io_base + MAC_REG_TMDATA0, uDelay);
+	VNSvOutPortB(io_base + MAC_REG_TMCTL0, (TMCTL_TMD | TMCTL_TE));
 	for (ii = 0; ii < 66; ii++) {  /* assume max PCI clock is 66Mhz */
 		for (uu = 0; uu < uDelay; uu++) {
-			VNSvInPortB(dwIoBase + MAC_REG_TMCTL0, &byValue);
+			VNSvInPortB(io_base + MAC_REG_TMCTL0, &byValue);
 			if ((byValue == 0) ||
 			    (byValue & TMCTL_TSUSP)) {
-				VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
+				VNSvOutPortB(io_base + MAC_REG_TMCTL0, 0);
 				return;
 			}
 		}
 	}
-	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
+	VNSvOutPortB(io_base + MAC_REG_TMCTL0, 0);
 }
 
 /*
@@ -766,7 +766,7 @@ void MACvTimer0MicroSDelay(struct vnt_private *priv, unsigned int uDelay)
  *
  * Parameters:
  *  In:
- *      dwIoBase    - Base Address for MAC
+ *      io_base    - Base Address for MAC
  *      uDelay      - Delay time
  *  Out:
  *      none
@@ -776,28 +776,28 @@ void MACvTimer0MicroSDelay(struct vnt_private *priv, unsigned int uDelay)
  */
 void MACvOneShotTimer1MicroSec(struct vnt_private *priv, unsigned int uDelayTime)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 
-	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, 0);
-	VNSvOutPortD(dwIoBase + MAC_REG_TMDATA1, uDelayTime);
-	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, (TMCTL_TMD | TMCTL_TE));
+	VNSvOutPortB(io_base + MAC_REG_TMCTL1, 0);
+	VNSvOutPortD(io_base + MAC_REG_TMDATA1, uDelayTime);
+	VNSvOutPortB(io_base + MAC_REG_TMCTL1, (TMCTL_TMD | TMCTL_TE));
 }
 
 void MACvSetMISCFifo(struct vnt_private *priv, unsigned short wOffset,
 		     unsigned long dwData)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 
 	if (wOffset > 273)
 		return;
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset);
+	VNSvOutPortD(io_base + MAC_REG_MISCFFDATA, dwData);
+	VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 }
 
 bool MACbPSWakeup(struct vnt_private *priv)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned char byOrgValue;
 	unsigned int ww;
 	/* Read PSCTL */
@@ -805,11 +805,11 @@ bool MACbPSWakeup(struct vnt_private *priv)
 		return true;
 
 	/* Disable PS */
-	MACvRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PSEN);
+	MACvRegBitsOff(io_base, MAC_REG_PSCTL, PSCTL_PSEN);
 
 	/* Check if SyncFlushOK */
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(dwIoBase + MAC_REG_PSCTL, &byOrgValue);
+		VNSvInPortB(io_base + MAC_REG_PSCTL, &byOrgValue);
 		if (byOrgValue & PSCTL_WAKEDONE)
 			break;
 	}
@@ -826,7 +826,7 @@ bool MACbPSWakeup(struct vnt_private *priv)
  *
  * Parameters:
  *  In:
- *      dwIoBase        - Base Address for MAC
+ *      io_base        - Base Address for MAC
  *
  *  Out:
  *      none
@@ -840,7 +840,7 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 		     unsigned char *pbyAddr, u32 *pdwKey,
 		     unsigned char byLocalID)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned short wOffset;
 	u32 dwData;
 	int     ii;
@@ -859,9 +859,9 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 	pr_debug("1. wOffset: %d, Data: %X, KeyCtl:%X\n",
 		 wOffset, dwData, wKeyCtl);
 
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset);
+	VNSvOutPortD(io_base + MAC_REG_MISCFFDATA, dwData);
+	VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 	wOffset++;
 
 	dwData = 0;
@@ -874,9 +874,9 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 	dwData |= *(pbyAddr+0);
 	pr_debug("2. wOffset: %d, Data: %X\n", wOffset, dwData);
 
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset);
+	VNSvOutPortD(io_base + MAC_REG_MISCFFDATA, dwData);
+	VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 	wOffset++;
 
 	wOffset += (uKeyIdx * 4);
@@ -884,9 +884,9 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 		/* always push 128 bits */
 		pr_debug("3.(%d) wOffset: %d, Data: %X\n",
 			 ii, wOffset+ii, *pdwKey);
-		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
-		VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
-		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+		VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset+ii);
+		VNSvOutPortD(io_base + MAC_REG_MISCFFDATA, *pdwKey++);
+		VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 	}
 }
 
@@ -896,7 +896,7 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
  *
  * Parameters:
  *  In:
- *      dwIoBase        - Base Address for MAC
+ *      io_base        - Base Address for MAC
  *
  *  Out:
  *      none
@@ -906,13 +906,13 @@ void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
  */
 void MACvDisableKeyEntry(struct vnt_private *priv, unsigned int uEntryIdx)
 {
-	void __iomem *dwIoBase = priv->PortOffset;
+	void __iomem *io_base = priv->PortOffset;
 	unsigned short wOffset;
 
 	wOffset = MISCFIFO_KEYETRY0;
 	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, 0);
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	VNSvOutPortW(io_base + MAC_REG_MISCFFNDEX, wOffset);
+	VNSvOutPortD(io_base + MAC_REG_MISCFFDATA, 0);
+	VNSvOutPortW(io_base + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 }

commit e1c484db0329dec3859ca898afcbba6dec967e5c
Author: Janani Ravichandran <janani.rvchndrn@gmail.com>
Date:   Mon Feb 15 00:15:12 2016 -0500

    staging: vt6655: Add missing blank line after declaration
    
    Add missing blank line after declaration of variables. Issue found by
    checkpatch.
    
    Signed-off-by: Janani Ravichandran <janani.rvchndrn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index e74782aa6475..79e42d075cde 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -488,6 +488,7 @@ bool MACbSafeTxOff(struct vnt_private *priv)
 bool MACbSafeStop(struct vnt_private *priv)
 {
 	void __iomem *dwIoBase = priv->PortOffset;
+
 	MACvRegBitsOff(dwIoBase, MAC_REG_TCR, TCR_AUTOBCNTX);
 
 	if (!MACbSafeRxOff(priv)) {

commit f9f853af84c9205ba9dbc461da0f11da1f4abb53
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Nov 22 09:07:22 2015 +0000

    staging: vt6655: mac.c replace void __iomem * with struct vnt_private
    
    Moving void __iomem down one level in the following functions
    MACbIsRegBitsOn
    MACbIsRegBitsOff
    MACbIsIntDisable
    MACvSetShortRetryLimit
    MACvSetLongRetryLimit
    MACvGetLongRetryLimit
    MACvSetLoopbackMode
    MACvSaveContext
    MACvRestoreContext
    MACbSoftwareReset
    MACbSafeSoftwareReset
    MACbSafeRxOff
    MACbSafeTxOff
    MACbSafeStop
    MACbShutdown
    MACvInitialize
    MACvSetCurrRx0DescAddr
    MACvSetCurrRx1DescAddr
    MACvSetCurrTXDescAddr
    MACvSetCurrTx0DescAddrEx
    MACvSetCurrAC0DescAddrEx
    MACvSetCurrSyncDescAddrEx
    MACvSetCurrATIMDescAddrEx
    MACvTimer0MicroSDelay
    MACvOneShotTimer1MicroSec
    MACvSetMISCFifo
    MACbPSWakeup
    MACvSetKeyEntry
    MACvDisableKeyEntry
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 688c3be168d1..e74782aa6475 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -70,9 +70,10 @@
  * Return Value: true if all test bits On; otherwise false
  *
  */
-bool MACbIsRegBitsOn(void __iomem *dwIoBase, unsigned char byRegOfs,
+bool MACbIsRegBitsOn(struct vnt_private *priv, unsigned char byRegOfs,
 		     unsigned char byTestBits)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned char byData;
 
 	VNSvInPortB(dwIoBase + byRegOfs, &byData);
@@ -94,9 +95,10 @@ bool MACbIsRegBitsOn(void __iomem *dwIoBase, unsigned char byRegOfs,
  * Return Value: true if all test bits Off; otherwise false
  *
  */
-bool MACbIsRegBitsOff(void __iomem *dwIoBase, unsigned char byRegOfs,
+bool MACbIsRegBitsOff(struct vnt_private *priv, unsigned char byRegOfs,
 		      unsigned char byTestBits)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned char byData;
 
 	VNSvInPortB(dwIoBase + byRegOfs, &byData);
@@ -116,8 +118,9 @@ bool MACbIsRegBitsOff(void __iomem *dwIoBase, unsigned char byRegOfs,
  * Return Value: true if interrupt is disable; otherwise false
  *
  */
-bool MACbIsIntDisable(void __iomem *dwIoBase)
+bool MACbIsIntDisable(struct vnt_private *priv)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned long dwData;
 
 	VNSvInPortD(dwIoBase + MAC_REG_IMR, &dwData);
@@ -141,8 +144,9 @@ bool MACbIsIntDisable(void __iomem *dwIoBase)
  * Return Value: none
  *
  */
-void MACvSetShortRetryLimit(void __iomem *dwIoBase, unsigned char byRetryLimit)
+void MACvSetShortRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	/* set SRT */
 	VNSvOutPortB(dwIoBase + MAC_REG_SRT, byRetryLimit);
 }
@@ -162,8 +166,9 @@ void MACvSetShortRetryLimit(void __iomem *dwIoBase, unsigned char byRetryLimit)
  * Return Value: none
  *
  */
-void MACvSetLongRetryLimit(void __iomem *dwIoBase, unsigned char byRetryLimit)
+void MACvSetLongRetryLimit(struct vnt_private *priv, unsigned char byRetryLimit)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	/* set LRT */
 	VNSvOutPortB(dwIoBase + MAC_REG_LRT, byRetryLimit);
 }
@@ -182,8 +187,9 @@ void MACvSetLongRetryLimit(void __iomem *dwIoBase, unsigned char byRetryLimit)
  * Return Value: none
  *
  */
-void MACvSetLoopbackMode(void __iomem *dwIoBase, unsigned char byLoopbackMode)
+void MACvSetLoopbackMode(struct vnt_private *priv, unsigned char byLoopbackMode)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned char byOrgValue;
 
 	byLoopbackMode <<= 6;
@@ -207,8 +213,9 @@ void MACvSetLoopbackMode(void __iomem *dwIoBase, unsigned char byLoopbackMode)
  * Return Value: none
  *
  */
-void MACvSaveContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
+void MACvSaveContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	int         ii;
 
 	/* read page0 register */
@@ -239,8 +246,9 @@ void MACvSaveContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: none
  *
  */
-void MACvRestoreContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
+void MACvRestoreContext(struct vnt_private *priv, unsigned char *pbyCxtBuf)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	int         ii;
 
 	MACvSelectPage1(dwIoBase);
@@ -293,8 +301,9 @@ void MACvRestoreContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: true if Reset Success; otherwise false
  *
  */
-bool MACbSoftwareReset(void __iomem *dwIoBase)
+bool MACbSoftwareReset(struct vnt_private *priv)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned char byData;
 	unsigned short ww;
 
@@ -324,7 +333,7 @@ bool MACbSoftwareReset(void __iomem *dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbSafeSoftwareReset(void __iomem *dwIoBase)
+bool MACbSafeSoftwareReset(struct vnt_private *priv)
 {
 	unsigned char abyTmpRegData[MAC_MAX_CONTEXT_SIZE_PAGE0+MAC_MAX_CONTEXT_SIZE_PAGE1];
 	bool bRetVal;
@@ -334,11 +343,11 @@ bool MACbSafeSoftwareReset(void __iomem *dwIoBase)
 	 * reset, then restore register's value
 	 */
 	/* save MAC context */
-	MACvSaveContext(dwIoBase, abyTmpRegData);
+	MACvSaveContext(priv, abyTmpRegData);
 	/* do reset */
-	bRetVal = MACbSoftwareReset(dwIoBase);
+	bRetVal = MACbSoftwareReset(priv);
 	/* restore MAC context, except CR0 */
-	MACvRestoreContext(dwIoBase, abyTmpRegData);
+	MACvRestoreContext(priv, abyTmpRegData);
 
 	return bRetVal;
 }
@@ -356,8 +365,9 @@ bool MACbSafeSoftwareReset(void __iomem *dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbSafeRxOff(void __iomem *dwIoBase)
+bool MACbSafeRxOff(struct vnt_private *priv)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned short ww;
 	unsigned long dwData;
 	unsigned char byData;
@@ -414,8 +424,9 @@ bool MACbSafeRxOff(void __iomem *dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbSafeTxOff(void __iomem *dwIoBase)
+bool MACbSafeTxOff(struct vnt_private *priv)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned short ww;
 	unsigned long dwData;
 	unsigned char byData;
@@ -474,18 +485,19 @@ bool MACbSafeTxOff(void __iomem *dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbSafeStop(void __iomem *dwIoBase)
+bool MACbSafeStop(struct vnt_private *priv)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	MACvRegBitsOff(dwIoBase, MAC_REG_TCR, TCR_AUTOBCNTX);
 
-	if (!MACbSafeRxOff(dwIoBase)) {
+	if (!MACbSafeRxOff(priv)) {
 		pr_debug(" MACbSafeRxOff == false)\n");
-		MACbSafeSoftwareReset(dwIoBase);
+		MACbSafeSoftwareReset(priv);
 		return false;
 	}
-	if (!MACbSafeTxOff(dwIoBase)) {
+	if (!MACbSafeTxOff(priv)) {
 		pr_debug(" MACbSafeTxOff == false)\n");
-		MACbSafeSoftwareReset(dwIoBase);
+		MACbSafeSoftwareReset(priv);
 		return false;
 	}
 
@@ -507,17 +519,18 @@ bool MACbSafeStop(void __iomem *dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbShutdown(void __iomem *dwIoBase)
+bool MACbShutdown(struct vnt_private *priv)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	/* disable MAC IMR */
 	MACvIntDisable(dwIoBase);
-	MACvSetLoopbackMode(dwIoBase, MAC_LB_INTERNAL);
+	MACvSetLoopbackMode(priv, MAC_LB_INTERNAL);
 	/* stop the adapter */
-	if (!MACbSafeStop(dwIoBase)) {
-		MACvSetLoopbackMode(dwIoBase, MAC_LB_NONE);
+	if (!MACbSafeStop(priv)) {
+		MACvSetLoopbackMode(priv, MAC_LB_NONE);
 		return false;
 	}
-	MACvSetLoopbackMode(dwIoBase, MAC_LB_NONE);
+	MACvSetLoopbackMode(priv, MAC_LB_NONE);
 	return true;
 }
 
@@ -534,8 +547,9 @@ bool MACbShutdown(void __iomem *dwIoBase)
  * Return Value: none
  *
  */
-void MACvInitialize(void __iomem *dwIoBase)
+void MACvInitialize(struct vnt_private *priv)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	/* clear sticky bits */
 	MACvClearStckDS(dwIoBase);
 	/* disable force PME-enable */
@@ -543,7 +557,7 @@ void MACvInitialize(void __iomem *dwIoBase)
 	/* only 3253 A */
 
 	/* do reset */
-	MACbSoftwareReset(dwIoBase);
+	MACbSoftwareReset(priv);
 
 	/* reset TSF counter */
 	VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
@@ -565,8 +579,9 @@ void MACvInitialize(void __iomem *dwIoBase)
  * Return Value: none
  *
  */
-void MACvSetCurrRx0DescAddr(void __iomem *dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrRx0DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAddr)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned short ww;
 	unsigned char byData;
 	unsigned char byOrgDMACtl;
@@ -600,8 +615,9 @@ void MACvSetCurrRx0DescAddr(void __iomem *dwIoBase, unsigned long dwCurrDescAddr
  * Return Value: none
  *
  */
-void MACvSetCurrRx1DescAddr(void __iomem *dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrRx1DescAddr(struct vnt_private *priv, unsigned long dwCurrDescAddr)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned short ww;
 	unsigned char byData;
 	unsigned char byOrgDMACtl;
@@ -636,9 +652,10 @@ void MACvSetCurrRx1DescAddr(void __iomem *dwIoBase, unsigned long dwCurrDescAddr
  * Return Value: none
  *
  */
-void MACvSetCurrTx0DescAddrEx(void __iomem *dwIoBase,
+void MACvSetCurrTx0DescAddrEx(struct vnt_private *priv,
 			      unsigned long dwCurrDescAddr)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned short ww;
 	unsigned char byData;
 	unsigned char byOrgDMACtl;
@@ -673,9 +690,10 @@ void MACvSetCurrTx0DescAddrEx(void __iomem *dwIoBase,
  *
  */
 /* TxDMA1 = AC0DMA */
-void MACvSetCurrAC0DescAddrEx(void __iomem *dwIoBase,
+void MACvSetCurrAC0DescAddrEx(struct vnt_private *priv,
 			      unsigned long dwCurrDescAddr)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned short ww;
 	unsigned char byData;
 	unsigned char byOrgDMACtl;
@@ -696,13 +714,13 @@ void MACvSetCurrAC0DescAddrEx(void __iomem *dwIoBase,
 		VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_RUN);
 }
 
-void MACvSetCurrTXDescAddr(int iTxType, void __iomem *dwIoBase,
+void MACvSetCurrTXDescAddr(int iTxType, struct vnt_private *priv,
 			   unsigned long dwCurrDescAddr)
 {
 	if (iTxType == TYPE_AC0DMA)
-		MACvSetCurrAC0DescAddrEx(dwIoBase, dwCurrDescAddr);
+		MACvSetCurrAC0DescAddrEx(priv, dwCurrDescAddr);
 	else if (iTxType == TYPE_TXDMA0)
-		MACvSetCurrTx0DescAddrEx(dwIoBase, dwCurrDescAddr);
+		MACvSetCurrTx0DescAddrEx(priv, dwCurrDescAddr);
 }
 
 /*
@@ -719,8 +737,9 @@ void MACvSetCurrTXDescAddr(int iTxType, void __iomem *dwIoBase,
  * Return Value: none
  *
  */
-void MACvTimer0MicroSDelay(void __iomem *dwIoBase, unsigned int uDelay)
+void MACvTimer0MicroSDelay(struct vnt_private *priv, unsigned int uDelay)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned char byValue;
 	unsigned int uu, ii;
 
@@ -754,16 +773,20 @@ void MACvTimer0MicroSDelay(void __iomem *dwIoBase, unsigned int uDelay)
  * Return Value: none
  *
  */
-void MACvOneShotTimer1MicroSec(void __iomem *dwIoBase, unsigned int uDelayTime)
+void MACvOneShotTimer1MicroSec(struct vnt_private *priv, unsigned int uDelayTime)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
+
 	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, 0);
 	VNSvOutPortD(dwIoBase + MAC_REG_TMDATA1, uDelayTime);
 	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, (TMCTL_TMD | TMCTL_TE));
 }
 
-void MACvSetMISCFifo(void __iomem *dwIoBase, unsigned short wOffset,
+void MACvSetMISCFifo(struct vnt_private *priv, unsigned short wOffset,
 		     unsigned long dwData)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
+
 	if (wOffset > 273)
 		return;
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
@@ -771,12 +794,13 @@ void MACvSetMISCFifo(void __iomem *dwIoBase, unsigned short wOffset,
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 }
 
-bool MACbPSWakeup(void __iomem *dwIoBase)
+bool MACbPSWakeup(struct vnt_private *priv)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned char byOrgValue;
 	unsigned int ww;
 	/* Read PSCTL */
-	if (MACbIsRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PS))
+	if (MACbIsRegBitsOff(priv, MAC_REG_PSCTL, PSCTL_PS))
 		return true;
 
 	/* Disable PS */
@@ -810,11 +834,12 @@ bool MACbPSWakeup(void __iomem *dwIoBase)
  *
  */
 
-void MACvSetKeyEntry(void __iomem *dwIoBase, unsigned short wKeyCtl,
+void MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,
 		     unsigned int uEntryIdx, unsigned int uKeyIdx,
 		     unsigned char *pbyAddr, u32 *pdwKey,
 		     unsigned char byLocalID)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned short wOffset;
 	u32 dwData;
 	int     ii;
@@ -878,8 +903,9 @@ void MACvSetKeyEntry(void __iomem *dwIoBase, unsigned short wKeyCtl,
  * Return Value: none
  *
  */
-void MACvDisableKeyEntry(void __iomem *dwIoBase, unsigned int uEntryIdx)
+void MACvDisableKeyEntry(struct vnt_private *priv, unsigned int uEntryIdx)
 {
+	void __iomem *dwIoBase = priv->PortOffset;
 	unsigned short wOffset;
 
 	wOffset = MISCFIFO_KEYETRY0;

commit 4188e5862f40cb64256127b1ef7acfcc17e5467f
Author: Shivani Bhardwaj <shivanib134@gmail.com>
Date:   Mon Oct 12 23:14:15 2015 +0530

    Staging: vt6655: mac: Remove extra braces
    
    Remove braces from an if block as it comprises of a single statement.
    Fix checkpatch warning: braces {} are not necessary for single statement
    blocks
    
    Signed-off-by: Shivani Bhardwaj <shivanib134@gmail.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 3dfd333475c0..688c3be168d1 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -689,9 +689,8 @@ void MACvSetCurrAC0DescAddrEx(void __iomem *dwIoBase,
 		if (!(byData & DMACTL_RUN))
 			break;
 	}
-	if (ww == W_MAX_TIMEOUT) {
+	if (ww == W_MAX_TIMEOUT)
 		pr_debug(" DBG_PORT80(0x26)\n");
-	}
 	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
 	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_RUN);

commit fd43585b6405a0b7c6e5ad3c1bcbb32cf186a5a9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jul 22 19:16:34 2015 +0100

    staging: vt6655: remove unused DBG_PORT80 and VIAWET_DEBUG
    
    VIAWET_DEBUG is never defined so DBG_PORT80 is empty and never used.
    
    Remove both macros.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 65dd49cda333..3dfd333475c0 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -373,7 +373,6 @@ bool MACbSafeRxOff(void __iomem *dwIoBase)
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
-		DBG_PORT80(0x10);
 		pr_debug(" DBG_PORT80(0x10)\n");
 		return false;
 	}
@@ -383,7 +382,6 @@ bool MACbSafeRxOff(void __iomem *dwIoBase)
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
-		DBG_PORT80(0x11);
 		pr_debug(" DBG_PORT80(0x11)\n");
 		return false;
 	}
@@ -397,7 +395,6 @@ bool MACbSafeRxOff(void __iomem *dwIoBase)
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
-		DBG_PORT80(0x12);
 		pr_debug(" DBG_PORT80(0x12)\n");
 		return false;
 	}
@@ -435,7 +432,6 @@ bool MACbSafeTxOff(void __iomem *dwIoBase)
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
-		DBG_PORT80(0x20);
 		pr_debug(" DBG_PORT80(0x20)\n");
 		return false;
 	}
@@ -445,7 +441,6 @@ bool MACbSafeTxOff(void __iomem *dwIoBase)
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
-		DBG_PORT80(0x21);
 		pr_debug(" DBG_PORT80(0x21)\n");
 		return false;
 	}
@@ -460,7 +455,6 @@ bool MACbSafeTxOff(void __iomem *dwIoBase)
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
-		DBG_PORT80(0x24);
 		pr_debug(" DBG_PORT80(0x24)\n");
 		return false;
 	}
@@ -485,13 +479,11 @@ bool MACbSafeStop(void __iomem *dwIoBase)
 	MACvRegBitsOff(dwIoBase, MAC_REG_TCR, TCR_AUTOBCNTX);
 
 	if (!MACbSafeRxOff(dwIoBase)) {
-		DBG_PORT80(0xA1);
 		pr_debug(" MACbSafeRxOff == false)\n");
 		MACbSafeSoftwareReset(dwIoBase);
 		return false;
 	}
 	if (!MACbSafeTxOff(dwIoBase)) {
-		DBG_PORT80(0xA2);
 		pr_debug(" MACbSafeTxOff == false)\n");
 		MACbSafeSoftwareReset(dwIoBase);
 		return false;
@@ -589,9 +581,6 @@ void MACvSetCurrRx0DescAddr(void __iomem *dwIoBase, unsigned long dwCurrDescAddr
 			break;
 	}
 
-	if (ww == W_MAX_TIMEOUT)
-		DBG_PORT80(0x13);
-
 	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, dwCurrDescAddr);
 	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_RUN);
@@ -626,8 +615,6 @@ void MACvSetCurrRx1DescAddr(void __iomem *dwIoBase, unsigned long dwCurrDescAddr
 		if (!(byData & DMACTL_RUN))
 			break;
 	}
-	if (ww == W_MAX_TIMEOUT)
-		DBG_PORT80(0x14);
 
 	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, dwCurrDescAddr);
 	if (byOrgDMACtl & DMACTL_RUN)
@@ -665,8 +652,6 @@ void MACvSetCurrTx0DescAddrEx(void __iomem *dwIoBase,
 		if (!(byData & DMACTL_RUN))
 			break;
 	}
-	if (ww == W_MAX_TIMEOUT)
-		DBG_PORT80(0x25);
 
 	VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, dwCurrDescAddr);
 	if (byOrgDMACtl & DMACTL_RUN)
@@ -705,7 +690,6 @@ void MACvSetCurrAC0DescAddrEx(void __iomem *dwIoBase,
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
-		DBG_PORT80(0x26);
 		pr_debug(" DBG_PORT80(0x26)\n");
 	}
 	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
@@ -806,7 +790,6 @@ bool MACbPSWakeup(void __iomem *dwIoBase)
 			break;
 	}
 	if (ww == W_MAX_TIMEOUT) {
-		DBG_PORT80(0x36);
 		pr_debug(" DBG_PORT80(0x33)\n");
 		return false;
 	}

commit 217ed3abf1510747590aaa5da93217e559fd8e19
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jul 22 19:16:33 2015 +0100

    staging: vt6655: Remove ununsed macro ASSERT
    
    VIAWET_DEBUG is not defined so macro is empty.
    
    Remove the macro.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index aed530f022b8..65dd49cda333 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -186,7 +186,6 @@ void MACvSetLoopbackMode(void __iomem *dwIoBase, unsigned char byLoopbackMode)
 {
 	unsigned char byOrgValue;
 
-	ASSERT(byLoopbackMode < 3);
 	byLoopbackMode <<= 6;
 	/* set TCR */
 	VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);

commit d4855fe18e2d80ed87736fb8326e1bbd19c02dbb
Author: Guillaume Brogi <gui-gui@netcourrier.com>
Date:   Sun Apr 26 14:40:23 2015 +0200

    staging: vt6655: Checkpatch fix: lines longer than 80 columns
    
    This patch fixes lines longer than 80 columns in mac.c.
    5 lines longer than 80 columns remain for the sake of readability.
    
    Signed-off-by: Guillaume Brogi <gui-gui@netcourrier.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 8048b3263360..aed530f022b8 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -70,7 +70,8 @@
  * Return Value: true if all test bits On; otherwise false
  *
  */
-bool MACbIsRegBitsOn(void __iomem *dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
+bool MACbIsRegBitsOn(void __iomem *dwIoBase, unsigned char byRegOfs,
+		     unsigned char byTestBits)
 {
 	unsigned char byData;
 
@@ -93,7 +94,8 @@ bool MACbIsRegBitsOn(void __iomem *dwIoBase, unsigned char byRegOfs, unsigned ch
  * Return Value: true if all test bits Off; otherwise false
  *
  */
-bool MACbIsRegBitsOff(void __iomem *dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
+bool MACbIsRegBitsOff(void __iomem *dwIoBase, unsigned char byRegOfs,
+		      unsigned char byTestBits)
 {
 	unsigned char byData;
 
@@ -218,7 +220,8 @@ void MACvSaveContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
 
 	/* read page1 register */
 	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++)
-		VNSvInPortB((dwIoBase + ii), (pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
+		VNSvInPortB((dwIoBase + ii),
+			    (pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
 
 	MACvSelectPage0(dwIoBase);
 }
@@ -244,7 +247,8 @@ void MACvRestoreContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
 	MACvSelectPage1(dwIoBase);
 	/* restore page1 */
 	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++)
-		VNSvOutPortB((dwIoBase + ii), *(pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
+		VNSvOutPortB((dwIoBase + ii),
+			     *(pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
 
 	MACvSelectPage0(dwIoBase);
 
@@ -263,13 +267,18 @@ void MACvRestoreContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
 		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
 
 	/* restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR */
-	VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0));
-	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR));
-	VNSvOutPortD(dwIoBase + MAC_REG_BCNDMAPTR, *(unsigned long *)(pbyCxtBuf + MAC_REG_BCNDMAPTR));
-
-	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0));
-
-	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1));
+	VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0,
+		     *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0));
+	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR,
+		     *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR));
+	VNSvOutPortD(dwIoBase + MAC_REG_BCNDMAPTR,
+		     *(unsigned long *)(pbyCxtBuf + MAC_REG_BCNDMAPTR));
+
+	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0,
+		     *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0));
+
+	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1,
+		     *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1));
 }
 
 /*
@@ -641,7 +650,8 @@ void MACvSetCurrRx1DescAddr(void __iomem *dwIoBase, unsigned long dwCurrDescAddr
  * Return Value: none
  *
  */
-void MACvSetCurrTx0DescAddrEx(void __iomem *dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrTx0DescAddrEx(void __iomem *dwIoBase,
+			      unsigned long dwCurrDescAddr)
 {
 	unsigned short ww;
 	unsigned char byData;
@@ -679,7 +689,8 @@ void MACvSetCurrTx0DescAddrEx(void __iomem *dwIoBase, unsigned long dwCurrDescAd
  *
  */
 /* TxDMA1 = AC0DMA */
-void MACvSetCurrAC0DescAddrEx(void __iomem *dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrAC0DescAddrEx(void __iomem *dwIoBase,
+			      unsigned long dwCurrDescAddr)
 {
 	unsigned short ww;
 	unsigned char byData;
@@ -703,7 +714,8 @@ void MACvSetCurrAC0DescAddrEx(void __iomem *dwIoBase, unsigned long dwCurrDescAd
 		VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_RUN);
 }
 
-void MACvSetCurrTXDescAddr(int iTxType, void __iomem *dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrTXDescAddr(int iTxType, void __iomem *dwIoBase,
+			   unsigned long dwCurrDescAddr)
 {
 	if (iTxType == TYPE_AC0DMA)
 		MACvSetCurrAC0DescAddrEx(dwIoBase, dwCurrDescAddr);
@@ -767,7 +779,8 @@ void MACvOneShotTimer1MicroSec(void __iomem *dwIoBase, unsigned int uDelayTime)
 	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, (TMCTL_TMD | TMCTL_TE));
 }
 
-void MACvSetMISCFifo(void __iomem *dwIoBase, unsigned short wOffset, unsigned long dwData)
+void MACvSetMISCFifo(void __iomem *dwIoBase, unsigned short wOffset,
+		     unsigned long dwData)
 {
 	if (wOffset > 273)
 		return;
@@ -816,8 +829,10 @@ bool MACbPSWakeup(void __iomem *dwIoBase)
  *
  */
 
-void MACvSetKeyEntry(void __iomem *dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx,
-		     unsigned int uKeyIdx, unsigned char *pbyAddr, u32 *pdwKey, unsigned char byLocalID)
+void MACvSetKeyEntry(void __iomem *dwIoBase, unsigned short wKeyCtl,
+		     unsigned int uEntryIdx, unsigned int uKeyIdx,
+		     unsigned char *pbyAddr, u32 *pdwKey,
+		     unsigned char byLocalID)
 {
 	unsigned short wOffset;
 	u32 dwData;

commit 9ab81fb7a968c81d16fa00584487d7f1e7211887
Author: Matteo Semenzato <mattew8898@gmail.com>
Date:   Sat Feb 28 15:28:15 2015 +0100

    Staging: vt6655: fix C99 comments
    
    This patch fixes the following warning:
    do not use C99 // comments
    
    Signed-off-by: Matteo Semenzato <mattew8898@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 3653a2bd1e36..8048b3263360 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -141,7 +141,7 @@ bool MACbIsIntDisable(void __iomem *dwIoBase)
  */
 void MACvSetShortRetryLimit(void __iomem *dwIoBase, unsigned char byRetryLimit)
 {
-	// set SRT
+	/* set SRT */
 	VNSvOutPortB(dwIoBase + MAC_REG_SRT, byRetryLimit);
 }
 
@@ -162,7 +162,7 @@ void MACvSetShortRetryLimit(void __iomem *dwIoBase, unsigned char byRetryLimit)
  */
 void MACvSetLongRetryLimit(void __iomem *dwIoBase, unsigned char byRetryLimit)
 {
-	// set LRT
+	/* set LRT */
 	VNSvOutPortB(dwIoBase + MAC_REG_LRT, byRetryLimit);
 }
 
@@ -186,7 +186,7 @@ void MACvSetLoopbackMode(void __iomem *dwIoBase, unsigned char byLoopbackMode)
 
 	ASSERT(byLoopbackMode < 3);
 	byLoopbackMode <<= 6;
-	// set TCR
+	/* set TCR */
 	VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
 	byOrgValue = byOrgValue & 0x3F;
 	byOrgValue = byOrgValue | byLoopbackMode;
@@ -210,13 +210,13 @@ void MACvSaveContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
 {
 	int         ii;
 
-	// read page0 register
+	/* read page0 register */
 	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE0; ii++)
 		VNSvInPortB((dwIoBase + ii), (pbyCxtBuf + ii));
 
 	MACvSelectPage1(dwIoBase);
 
-	// read page1 register
+	/* read page1 register */
 	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++)
 		VNSvInPortB((dwIoBase + ii), (pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
 
@@ -242,27 +242,27 @@ void MACvRestoreContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
 	int         ii;
 
 	MACvSelectPage1(dwIoBase);
-	// restore page1
+	/* restore page1 */
 	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++)
 		VNSvOutPortB((dwIoBase + ii), *(pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
 
 	MACvSelectPage0(dwIoBase);
 
-	// restore RCR,TCR,IMR...
+	/* restore RCR,TCR,IMR... */
 	for (ii = MAC_REG_RCR; ii < MAC_REG_ISR; ii++)
 		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
 
-	// restore MAC Config.
+	/* restore MAC Config. */
 	for (ii = MAC_REG_LRT; ii < MAC_REG_PAGE1SEL; ii++)
 		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
 
 	VNSvOutPortB(dwIoBase + MAC_REG_CFG, *(pbyCxtBuf + MAC_REG_CFG));
 
-	// restore PS Config.
+	/* restore PS Config. */
 	for (ii = MAC_REG_PSCFG; ii < MAC_REG_BBREGCTL; ii++)
 		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
 
-	// restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
+	/* restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR */
 	VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0));
 	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR));
 	VNSvOutPortD(dwIoBase + MAC_REG_BCNDMAPTR, *(unsigned long *)(pbyCxtBuf + MAC_REG_BCNDMAPTR));
@@ -290,7 +290,7 @@ bool MACbSoftwareReset(void __iomem *dwIoBase)
 	unsigned char byData;
 	unsigned short ww;
 
-	// turn on HOSTCR_SOFTRST, just write 0x01 to reset
+	/* turn on HOSTCR_SOFTRST, just write 0x01 to reset */
 	VNSvOutPortB(dwIoBase + MAC_REG_HOSTCR, 0x01);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
@@ -321,15 +321,15 @@ bool MACbSafeSoftwareReset(void __iomem *dwIoBase)
 	unsigned char abyTmpRegData[MAC_MAX_CONTEXT_SIZE_PAGE0+MAC_MAX_CONTEXT_SIZE_PAGE1];
 	bool bRetVal;
 
-	// PATCH....
-	// save some important register's value, then do
-	// reset, then restore register's value
-
-	// save MAC context
+	/* PATCH....
+	 * save some important register's value, then do
+	 * reset, then restore register's value
+	 */
+	/* save MAC context */
 	MACvSaveContext(dwIoBase, abyTmpRegData);
-	// do reset
+	/* do reset */
 	bRetVal = MACbSoftwareReset(dwIoBase);
-	// restore MAC context, except CR0
+	/* restore MAC context, except CR0 */
 	MACvRestoreContext(dwIoBase, abyTmpRegData);
 
 	return bRetVal;
@@ -354,9 +354,9 @@ bool MACbSafeRxOff(void __iomem *dwIoBase)
 	unsigned long dwData;
 	unsigned char byData;
 
-	// turn off wow temp for turn off Rx safely
+	/* turn off wow temp for turn off Rx safely */
 
-	// Clear RX DMA0,1
+	/* Clear RX DMA0,1 */
 	VNSvOutPortD(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_CLRRUN);
 	VNSvOutPortD(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_CLRRUN);
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
@@ -380,9 +380,9 @@ bool MACbSafeRxOff(void __iomem *dwIoBase)
 		return false;
 	}
 
-	// try to safe shutdown RX
+	/* try to safe shutdown RX */
 	MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_RXON);
-	// W_MAX_TIMEOUT is the timeout period
+	/* W_MAX_TIMEOUT is the timeout period */
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
 		if (!(byData & HOSTCR_RXONST))
@@ -415,10 +415,10 @@ bool MACbSafeTxOff(void __iomem *dwIoBase)
 	unsigned long dwData;
 	unsigned char byData;
 
-	// Clear TX DMA
-	//Tx0
+	/* Clear TX DMA */
+	/* Tx0 */
 	VNSvOutPortD(dwIoBase + MAC_REG_TXDMACTL0, DMACTL_CLRRUN);
-	//AC0
+	/* AC0 */
 	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_CLRRUN);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
@@ -442,10 +442,10 @@ bool MACbSafeTxOff(void __iomem *dwIoBase)
 		return false;
 	}
 
-	// try to safe shutdown TX
+	/* try to safe shutdown TX */
 	MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_TXON);
 
-	// W_MAX_TIMEOUT is the timeout period
+	/* W_MAX_TIMEOUT is the timeout period */
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
 		if (!(byData & HOSTCR_TXONST))
@@ -509,10 +509,10 @@ bool MACbSafeStop(void __iomem *dwIoBase)
  */
 bool MACbShutdown(void __iomem *dwIoBase)
 {
-	// disable MAC IMR
+	/* disable MAC IMR */
 	MACvIntDisable(dwIoBase);
 	MACvSetLoopbackMode(dwIoBase, MAC_LB_INTERNAL);
-	// stop the adapter
+	/* stop the adapter */
 	if (!MACbSafeStop(dwIoBase)) {
 		MACvSetLoopbackMode(dwIoBase, MAC_LB_NONE);
 		return false;
@@ -536,18 +536,18 @@ bool MACbShutdown(void __iomem *dwIoBase)
  */
 void MACvInitialize(void __iomem *dwIoBase)
 {
-	// clear sticky bits
+	/* clear sticky bits */
 	MACvClearStckDS(dwIoBase);
-	// disable force PME-enable
+	/* disable force PME-enable */
 	VNSvOutPortB(dwIoBase + MAC_REG_PMC1, PME_OVR);
-	// only 3253 A
+	/* only 3253 A */
 
-	// do reset
+	/* do reset */
 	MACbSoftwareReset(dwIoBase);
 
-	// reset TSF counter
+	/* reset TSF counter */
 	VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
-	// enable TSF counter
+	/* enable TSF counter */
 	VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
 }
 
@@ -678,7 +678,7 @@ void MACvSetCurrTx0DescAddrEx(void __iomem *dwIoBase, unsigned long dwCurrDescAd
  * Return Value: none
  *
  */
-//TxDMA1 = AC0DMA
+/* TxDMA1 = AC0DMA */
 void MACvSetCurrAC0DescAddrEx(void __iomem *dwIoBase, unsigned long dwCurrDescAddr)
 {
 	unsigned short ww;
@@ -733,7 +733,7 @@ void MACvTimer0MicroSDelay(void __iomem *dwIoBase, unsigned int uDelay)
 	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
 	VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelay);
 	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, (TMCTL_TMD | TMCTL_TE));
-	for (ii = 0; ii < 66; ii++) {  // assume max PCI clock is 66Mhz
+	for (ii = 0; ii < 66; ii++) {  /* assume max PCI clock is 66Mhz */
 		for (uu = 0; uu < uDelay; uu++) {
 			VNSvInPortB(dwIoBase + MAC_REG_TMCTL0, &byValue);
 			if ((byValue == 0) ||
@@ -780,14 +780,14 @@ bool MACbPSWakeup(void __iomem *dwIoBase)
 {
 	unsigned char byOrgValue;
 	unsigned int ww;
-	// Read PSCTL
+	/* Read PSCTL */
 	if (MACbIsRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PS))
 		return true;
 
-	// Disable PS
+	/* Disable PS */
 	MACvRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PSEN);
 
-	// Check if SyncFlushOK
+	/* Check if SyncFlushOK */
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		VNSvInPortB(dwIoBase + MAC_REG_PSCTL, &byOrgValue);
 		if (byOrgValue & PSCTL_WAKEDONE)
@@ -859,7 +859,7 @@ void MACvSetKeyEntry(void __iomem *dwIoBase, unsigned short wKeyCtl, unsigned in
 
 	wOffset += (uKeyIdx * 4);
 	for (ii = 0; ii < 4; ii++) {
-		// always push 128 bits
+		/* always push 128 bits */
 		pr_debug("3.(%d) wOffset: %d, Data: %X\n",
 			 ii, wOffset+ii, *pdwKey);
 		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);

commit 75b4d52bae59aba0e4cd28bd88a42680d270ea6b
Author: Heba Aamer <heba93aamer@gmail.com>
Date:   Mon Jan 19 12:16:30 2015 +0200

    staging: vt6655: fix space prohibited before that ','
    
    This patch fixes the following checkpatch.pl error:
    fix space prohibited before that ','
    
    Signed-off-by: Heba Aamer <heba93aamer@gmail.com>
    Reviewed-by: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 63c9c7e8b9b7..3653a2bd1e36 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -789,7 +789,7 @@ bool MACbPSWakeup(void __iomem *dwIoBase)
 
 	// Check if SyncFlushOK
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(dwIoBase + MAC_REG_PSCTL , &byOrgValue);
+		VNSvInPortB(dwIoBase + MAC_REG_PSCTL, &byOrgValue);
 		if (byOrgValue & PSCTL_WAKEDONE)
 			break;
 	}

commit b1797dfda6ed418a519e5460b8bf111651307656
Author: Gustavo A. R. Silva <silvagustavosilva@gmail.com>
Date:   Sun Jan 11 16:18:00 2015 -0600

    Staging: vt6655: Fixed a typo
    
    Fixed a typo in mac.c file.
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 09a91d164113..63c9c7e8b9b7 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -337,7 +337,7 @@ bool MACbSafeSoftwareReset(void __iomem *dwIoBase)
 
 /*
  * Description:
- *      Trun Off MAC Rx
+ *      Turn Off MAC Rx
  *
  * Parameters:
  *  In:
@@ -398,7 +398,7 @@ bool MACbSafeRxOff(void __iomem *dwIoBase)
 
 /*
  * Description:
- *      Trun Off MAC Tx
+ *      Turn Off MAC Tx
  *
  * Parameters:
  *  In:

commit 99ae87e7554e9bb0e34930eaebef6a5e775314bd
Author: Fred Chou <fred.chou.nd@gmail.com>
Date:   Wed Dec 10 13:50:16 2014 +0800

    staging: vt6655: remove unused function in mac.c
    
    Removed the unused function MACvGetShortRetryLimit, which also
    fixed the following sparse warning:
    drivers/staging/vt6655/mac.c:162:6: warning:
    symbol 'MACvGetShortRetryLimit' was not declared. Should it be static?
    
    Signed-off-by: Fred Chou <fred.chou.nd@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 8f0d652fea7c..09a91d164113 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -30,7 +30,6 @@
  *      MACbIsRegBitsOff - Test if All test Bits Off
  *      MACbIsIntDisable - Test if MAC interrupt disable
  *      MACvSetShortRetryLimit - Set 802.11 Short Retry limit
- *      MACvGetShortRetryLimit - Get 802.11 Short Retry limit
  *      MACvSetLongRetryLimit - Set 802.11 Long Retry limit
  *      MACvSetLoopbackMode - Set MAC Loopback Mode
  *      MACvSaveContext - Save Context of MAC Registers
@@ -146,24 +145,6 @@ void MACvSetShortRetryLimit(void __iomem *dwIoBase, unsigned char byRetryLimit)
 	VNSvOutPortB(dwIoBase + MAC_REG_SRT, byRetryLimit);
 }
 
-/*
- * Description:
- *      Get 802.11 Short Retry Limit
- *
- * Parameters:
- *  In:
- *      dwIoBase        - Base Address for MAC
- *  Out:
- *      pbyRetryLimit   - Retry Limit Get
- *
- * Return Value: none
- *
- */
-void MACvGetShortRetryLimit(void __iomem *dwIoBase, unsigned char *pbyRetryLimit)
-{
-	// get SRT
-	VNSvInPortB(dwIoBase + MAC_REG_SRT, pbyRetryLimit);
-}
 
 /*
  * Description:

commit da4f18ed3b4bf9ff204391a7895b26095426ddd1
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Nov 29 00:01:58 2014 +0000

    staging: vt6655: remove duplicate MACvSetPacketFilter
    
    Packet filtering is already done in vnt_configure.
    
    A call to MACvSetPacketFilter is not necessary in MACvInitialize as
    this will be done by vnt_configure when interface is up.
    
    Also remove macros associated with this function.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index af966065a243..8f0d652fea7c 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -33,7 +33,6 @@
  *      MACvGetShortRetryLimit - Get 802.11 Short Retry limit
  *      MACvSetLongRetryLimit - Set 802.11 Long Retry limit
  *      MACvSetLoopbackMode - Set MAC Loopback Mode
- *      MACvSetPacketFilter - Set MAC Address Filter
  *      MACvSaveContext - Save Context of MAC Registers
  *      MACvRestoreContext - Restore Context of MAC Registers
  *      MACbSoftwareReset - Software Reset MAC
@@ -213,66 +212,6 @@ void MACvSetLoopbackMode(void __iomem *dwIoBase, unsigned char byLoopbackMode)
 	VNSvOutPortB(dwIoBase + MAC_REG_TEST, byOrgValue);
 }
 
-/*
- * Description:
- *      Set MAC Address filter
- *
- * Parameters:
- *  In:
- *      dwIoBase        - Base Address for MAC
- *      wFilterType     - Filter Type
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-void MACvSetPacketFilter(void __iomem *dwIoBase, unsigned short wFilterType)
-{
-	unsigned char byOldRCR;
-	unsigned char byNewRCR = 0;
-
-	// if only in DIRECTED mode, multicast-address will set to zero,
-	// but if other mode exist (e.g. PROMISCUOUS), multicast-address
-	// will be open
-	if (wFilterType & PKT_TYPE_DIRECTED) {
-		// set multicast address to accept none
-		MACvSelectPage1(dwIoBase);
-		VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0L);
-		VNSvOutPortD(dwIoBase + MAC_REG_MAR0 + sizeof(unsigned long), 0L);
-		MACvSelectPage0(dwIoBase);
-	}
-
-	if (wFilterType & (PKT_TYPE_PROMISCUOUS | PKT_TYPE_ALL_MULTICAST)) {
-		// set multicast address to accept all
-		MACvSelectPage1(dwIoBase);
-		VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0xFFFFFFFFL);
-		VNSvOutPortD(dwIoBase + MAC_REG_MAR0 + sizeof(unsigned long), 0xFFFFFFFFL);
-		MACvSelectPage0(dwIoBase);
-	}
-
-	if (wFilterType & PKT_TYPE_PROMISCUOUS) {
-		byNewRCR |= (RCR_RXALLTYPE | RCR_UNICAST | RCR_MULTICAST | RCR_BROADCAST);
-
-		byNewRCR &= ~RCR_BSSID;
-	}
-
-	if (wFilterType & (PKT_TYPE_ALL_MULTICAST | PKT_TYPE_MULTICAST))
-		byNewRCR |= RCR_MULTICAST;
-
-	if (wFilterType & PKT_TYPE_BROADCAST)
-		byNewRCR |= RCR_BROADCAST;
-
-	if (wFilterType & PKT_TYPE_ERROR_CRC)
-		byNewRCR |= RCR_ERRCRC;
-
-	VNSvInPortB(dwIoBase + MAC_REG_RCR,  &byOldRCR);
-	if (byNewRCR != byOldRCR) {
-		// Modify the Receive Command Register
-		VNSvOutPortB(dwIoBase + MAC_REG_RCR, byNewRCR);
-	}
-}
-
 /*
  * Description:
  *      Save MAC registers to context buffer
@@ -629,11 +568,6 @@ void MACvInitialize(void __iomem *dwIoBase)
 	VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
 	// enable TSF counter
 	VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
-
-	// set packet filter
-	// receive directed and broadcast address
-
-	MACvSetPacketFilter(dwIoBase, PKT_TYPE_DIRECTED | PKT_TYPE_BROADCAST);
 }
 
 /*

commit 87299d4c06f09ceb1fe866fe44c0c51d0d3f069e
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Nov 5 21:08:51 2014 +0000

    staging: vt6655: mac.c and mac.h remove dead functions.
    
    MACvReadAllRegs
    MACbyReadMultiAddr
    MACvWriteMultiAddr
    MACvSetMultiAddrByHash
    MACvResetMultiAddrByHash
    MACvSetRxThreshold
    MACvGetRxThreshold
    MACvSetTxThreshold
    MACvGetTxThreshold
    MACvSetDmaLength
    MACvGetDmaLength
    MACvGetLongRetryLimit
    MACbIsInLoopbackMode
    MACbCompareContext
    MACvOneShotTimer0MicroSec
    MACbTxDMAOff
    MACvClearBusSusInd
    MACvEnableBusSusEn
    MACbFlushSYNCFifo
    MACvSetDefaultKeyEntry
    MACvEnableDefaultKey
    MACvDisableDefaultKey
    MACvSetDefaultTKIPKeyEntry
    MACvSetDefaultKeyCtl
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 2ea74a185789..af966065a243 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -26,30 +26,16 @@
  * Date: May 21, 1996
  *
  * Functions:
- *      MACvReadAllRegs - Read All MAC Registers to buffer
  *      MACbIsRegBitsOn - Test if All test Bits On
  *      MACbIsRegBitsOff - Test if All test Bits Off
  *      MACbIsIntDisable - Test if MAC interrupt disable
- *      MACbyReadMultiAddr - Read Multicast Address Mask Pattern
- *      MACvWriteMultiAddr - Write Multicast Address Mask Pattern
- *      MACvSetMultiAddrByHash - Set Multicast Address Mask by Hash value
- *      MACvResetMultiAddrByHash - Clear Multicast Address Mask by Hash value
- *      MACvSetRxThreshold - Set Rx Threshold value
- *      MACvGetRxThreshold - Get Rx Threshold value
- *      MACvSetTxThreshold - Set Tx Threshold value
- *      MACvGetTxThreshold - Get Tx Threshold value
- *      MACvSetDmaLength - Set Dma Length value
- *      MACvGetDmaLength - Get Dma Length value
  *      MACvSetShortRetryLimit - Set 802.11 Short Retry limit
  *      MACvGetShortRetryLimit - Get 802.11 Short Retry limit
  *      MACvSetLongRetryLimit - Set 802.11 Long Retry limit
- *      MACvGetLongRetryLimit - Get 802.11 Long Retry limit
  *      MACvSetLoopbackMode - Set MAC Loopback Mode
- *      MACbIsInLoopbackMode - Test if MAC in Loopback mode
  *      MACvSetPacketFilter - Set MAC Address Filter
  *      MACvSaveContext - Save Context of MAC Registers
  *      MACvRestoreContext - Restore Context of MAC Registers
- *      MACbCompareContext - Compare if values of MAC Registers same as Context
  *      MACbSoftwareReset - Software Reset MAC
  *      MACbSafeRxOff - Turn Off MAC Rx
  *      MACbSafeTxOff - Turn Off MAC Tx
@@ -71,40 +57,6 @@
 #include "tmacro.h"
 #include "mac.h"
 
-/*
- * Description:
- *      Read All MAC Registers to buffer
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *  Out:
- *      pbyMacRegs  - buffer to read
- *
- * Return Value: none
- *
- */
-void MACvReadAllRegs(void __iomem *dwIoBase, unsigned char *pbyMacRegs)
-{
-	int ii;
-
-	// read page0 register
-	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE0; ii++) {
-		VNSvInPortB(dwIoBase + ii, pbyMacRegs);
-		pbyMacRegs++;
-	}
-
-	MACvSelectPage1(dwIoBase);
-
-	// read page1 register
-	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++) {
-		VNSvInPortB(dwIoBase + ii, pbyMacRegs);
-		pbyMacRegs++;
-	}
-
-	MACvSelectPage0(dwIoBase);
-}
-
 /*
  * Description:
  *      Test if all test bits on
@@ -175,252 +127,6 @@ bool MACbIsIntDisable(void __iomem *dwIoBase)
 	return true;
 }
 
-/*
- * Description:
- *      Read MAC Multicast Address Mask
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *      uByteidx    - Index of Mask
- *  Out:
- *      none
- *
- * Return Value: Mask Value read
- *
- */
-unsigned char MACbyReadMultiAddr(void __iomem *dwIoBase, unsigned int uByteIdx)
-{
-	unsigned char byData;
-
-	MACvSelectPage1(dwIoBase);
-	VNSvInPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, &byData);
-	MACvSelectPage0(dwIoBase);
-	return byData;
-}
-
-/*
- * Description:
- *      Write MAC Multicast Address Mask
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *      uByteidx    - Index of Mask
- *      byData      - Mask Value to write
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-void MACvWriteMultiAddr(void __iomem *dwIoBase, unsigned int uByteIdx, unsigned char byData)
-{
-	MACvSelectPage1(dwIoBase);
-	VNSvOutPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, byData);
-	MACvSelectPage0(dwIoBase);
-}
-
-/*
- * Description:
- *      Set this hash index into multicast address register bit
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *      byHashIdx   - Hash index to set
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-void MACvSetMultiAddrByHash(void __iomem *dwIoBase, unsigned char byHashIdx)
-{
-	unsigned int uByteIdx;
-	unsigned char byBitMask;
-	unsigned char byOrgValue;
-
-	// calculate byte position
-	uByteIdx = byHashIdx / 8;
-	ASSERT(uByteIdx < 8);
-	// calculate bit position
-	byBitMask = 1;
-	byBitMask <<= (byHashIdx % 8);
-	// turn on the bit
-	byOrgValue = MACbyReadMultiAddr(dwIoBase, uByteIdx);
-	MACvWriteMultiAddr(dwIoBase, uByteIdx, (unsigned char)(byOrgValue | byBitMask));
-}
-
-/*
- * Description:
- *      Reset this hash index into multicast address register bit
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *      byHashIdx   - Hash index to clear
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-void MACvResetMultiAddrByHash(void __iomem *dwIoBase, unsigned char byHashIdx)
-{
-	unsigned int uByteIdx;
-	unsigned char byBitMask;
-	unsigned char byOrgValue;
-
-	// calculate byte position
-	uByteIdx = byHashIdx / 8;
-	ASSERT(uByteIdx < 8);
-	// calculate bit position
-	byBitMask = 1;
-	byBitMask <<= (byHashIdx % 8);
-	// turn off the bit
-	byOrgValue = MACbyReadMultiAddr(dwIoBase, uByteIdx);
-	MACvWriteMultiAddr(dwIoBase, uByteIdx, (unsigned char)(byOrgValue & (~byBitMask)));
-}
-
-/*
- * Description:
- *      Set Rx Threshold
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *      byThreshold - Threshold Value
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-void MACvSetRxThreshold(void __iomem *dwIoBase, unsigned char byThreshold)
-{
-	unsigned char byOrgValue;
-
-	ASSERT(byThreshold < 4);
-
-	// set FCR0
-	VNSvInPortB(dwIoBase + MAC_REG_FCR0, &byOrgValue);
-	byOrgValue = (byOrgValue & 0xCF) | (byThreshold << 4);
-	VNSvOutPortB(dwIoBase + MAC_REG_FCR0, byOrgValue);
-}
-
-/*
- * Description:
- *      Get Rx Threshold
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *  Out:
- *      pbyThreshold- Threshold Value Get
- *
- * Return Value: none
- *
- */
-void MACvGetRxThreshold(void __iomem *dwIoBase, unsigned char *pbyThreshold)
-{
-	// get FCR0
-	VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
-	*pbyThreshold = (*pbyThreshold >> 4) & 0x03;
-}
-
-/*
- * Description:
- *      Set Tx Threshold
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *      byThreshold - Threshold Value
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-void MACvSetTxThreshold(void __iomem *dwIoBase, unsigned char byThreshold)
-{
-	unsigned char byOrgValue;
-
-	ASSERT(byThreshold < 4);
-
-	// set FCR0
-	VNSvInPortB(dwIoBase + MAC_REG_FCR0, &byOrgValue);
-	byOrgValue = (byOrgValue & 0xF3) | (byThreshold << 2);
-	VNSvOutPortB(dwIoBase + MAC_REG_FCR0, byOrgValue);
-}
-
-/*
- * Description:
- *      Get Tx Threshold
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *  Out:
- *      pbyThreshold- Threshold Value Get
- *
- * Return Value: none
- *
- */
-void MACvGetTxThreshold(void __iomem *dwIoBase, unsigned char *pbyThreshold)
-{
-	// get FCR0
-	VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
-	*pbyThreshold = (*pbyThreshold >> 2) & 0x03;
-}
-
-/*
- * Description:
- *      Set Dma Length
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *      byDmaLength - Dma Length Value
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-void MACvSetDmaLength(void __iomem *dwIoBase, unsigned char byDmaLength)
-{
-	unsigned char byOrgValue;
-
-	ASSERT(byDmaLength < 4);
-
-	// set FCR0
-	VNSvInPortB(dwIoBase + MAC_REG_FCR0, &byOrgValue);
-	byOrgValue = (byOrgValue & 0xFC) | byDmaLength;
-	VNSvOutPortB(dwIoBase + MAC_REG_FCR0, byOrgValue);
-}
-
-/*
- * Description:
- *      Get Dma Length
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *  Out:
- *      pbyDmaLength- Dma Length Value Get
- *
- * Return Value: none
- *
- */
-void MACvGetDmaLength(void __iomem *dwIoBase, unsigned char *pbyDmaLength)
-{
-	// get FCR0
-	VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyDmaLength);
-	*pbyDmaLength &= 0x03;
-}
-
 /*
  * Description:
  *      Set 802.11 Short Retry Limit
@@ -480,25 +186,6 @@ void MACvSetLongRetryLimit(void __iomem *dwIoBase, unsigned char byRetryLimit)
 	VNSvOutPortB(dwIoBase + MAC_REG_LRT, byRetryLimit);
 }
 
-/*
- * Description:
- *      Get 802.11 Long Retry Limit
- *
- * Parameters:
- *  In:
- *      dwIoBase        - Base Address for MAC
- *  Out:
- *      pbyRetryLimit   - Retry Limit Get
- *
- * Return Value: none
- *
- */
-void MACvGetLongRetryLimit(void __iomem *dwIoBase, unsigned char *pbyRetryLimit)
-{
-	// get LRT
-	VNSvInPortB(dwIoBase + MAC_REG_LRT, pbyRetryLimit);
-}
-
 /*
  * Description:
  *      Set MAC Loopback mode
@@ -526,29 +213,6 @@ void MACvSetLoopbackMode(void __iomem *dwIoBase, unsigned char byLoopbackMode)
 	VNSvOutPortB(dwIoBase + MAC_REG_TEST, byOrgValue);
 }
 
-/*
- * Description:
- *      Test if MAC in Loopback mode
- *
- * Parameters:
- *  In:
- *      dwIoBase        - Base Address for MAC
- *  Out:
- *      none
- *
- * Return Value: true if in Loopback mode; otherwise false
- *
- */
-bool MACbIsInLoopbackMode(void __iomem *dwIoBase)
-{
-	unsigned char byOrgValue;
-
-	VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
-	if (byOrgValue & (TEST_LBINT | TEST_LBEXT))
-		return true;
-	return false;
-}
-
 /*
  * Description:
  *      Set MAC Address filter
@@ -688,47 +352,6 @@ void MACvRestoreContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
 	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1));
 }
 
-/*
- * Description:
- *      Compare if MAC registers same as context buffer
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *      pbyCxtBuf   - Context buffer
- *  Out:
- *      none
- *
- * Return Value: true if all values are the same; otherwise false
- *
- */
-bool MACbCompareContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
-{
-	unsigned long dwData;
-
-	// compare MAC context to determine if this is a power lost init,
-	// return true for power remaining init, return false for power lost init
-
-	// compare CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
-	VNSvInPortD(dwIoBase + MAC_REG_TXDMAPTR0, &dwData);
-	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0))
-		return false;
-
-	VNSvInPortD(dwIoBase + MAC_REG_AC0DMAPTR, &dwData);
-	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR))
-		return false;
-
-	VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR0, &dwData);
-	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0))
-		return false;
-
-	VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR1, &dwData);
-	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1))
-		return false;
-
-	return true;
-}
-
 /*
  * Description:
  *      Software Reset MAC
@@ -1208,27 +831,6 @@ void MACvTimer0MicroSDelay(void __iomem *dwIoBase, unsigned int uDelay)
 	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
 }
 
-/*
- * Description:
- *      Micro Second One shot timer via MAC
- *
- * Parameters:
- *  In:
- *      dwIoBase    - Base Address for MAC
- *      uDelay      - Delay time
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-void MACvOneShotTimer0MicroSec(void __iomem *dwIoBase, unsigned int uDelayTime)
-{
-	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
-	VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelayTime);
-	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, (TMCTL_TMD | TMCTL_TE));
-}
-
 /*
  * Description:
  *      Micro Second One shot timer via MAC
@@ -1259,102 +861,6 @@ void MACvSetMISCFifo(void __iomem *dwIoBase, unsigned short wOffset, unsigned lo
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 }
 
-bool MACbTxDMAOff(void __iomem *dwIoBase, unsigned int idx)
-{
-	unsigned char byData;
-	unsigned int ww = 0;
-
-	if (idx == TYPE_TXDMA0) {
-		VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
-		for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-			VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
-			if (!(byData & DMACTL_RUN))
-				break;
-		}
-	} else if (idx == TYPE_AC0DMA) {
-		VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
-		for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-			VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
-			if (!(byData & DMACTL_RUN))
-				break;
-		}
-	}
-	if (ww == W_MAX_TIMEOUT) {
-		DBG_PORT80(0x29);
-		pr_debug(" DBG_PORT80(0x29)\n");
-		return false;
-	}
-	return true;
-}
-
-void MACvClearBusSusInd(void __iomem *dwIoBase)
-{
-	unsigned long dwOrgValue;
-	unsigned int ww;
-	// check if BcnSusInd enabled
-	VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
-	if (!(dwOrgValue & EnCFG_BcnSusInd))
-		return;
-	//Set BcnSusClr
-	dwOrgValue = dwOrgValue | EnCFG_BcnSusClr;
-	VNSvOutPortD(dwIoBase + MAC_REG_ENCFG, dwOrgValue);
-	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
-		if (!(dwOrgValue & EnCFG_BcnSusInd))
-			break;
-	}
-	if (ww == W_MAX_TIMEOUT) {
-		DBG_PORT80(0x33);
-		pr_debug(" DBG_PORT80(0x33)\n");
-	}
-}
-
-void MACvEnableBusSusEn(void __iomem *dwIoBase)
-{
-	unsigned char byOrgValue;
-	unsigned long dwOrgValue;
-	unsigned int ww;
-	// check if BcnSusInd enabled
-	VNSvInPortB(dwIoBase + MAC_REG_CFG , &byOrgValue);
-
-	//Set BcnSusEn
-	byOrgValue = byOrgValue | CFG_BCNSUSEN;
-	VNSvOutPortB(dwIoBase + MAC_REG_ENCFG, byOrgValue);
-	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
-		if (dwOrgValue & EnCFG_BcnSusInd)
-			break;
-	}
-	if (ww == W_MAX_TIMEOUT) {
-		DBG_PORT80(0x34);
-		pr_debug(" DBG_PORT80(0x34)\n");
-	}
-}
-
-bool MACbFlushSYNCFifo(void __iomem *dwIoBase)
-{
-	unsigned char byOrgValue;
-	unsigned int ww;
-	// Read MACCR
-	VNSvInPortB(dwIoBase + MAC_REG_MACCR , &byOrgValue);
-
-	// Set SYNCFLUSH
-	byOrgValue = byOrgValue | MACCR_SYNCFLUSH;
-	VNSvOutPortB(dwIoBase + MAC_REG_MACCR, byOrgValue);
-
-	// Check if SyncFlushOK
-	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-		VNSvInPortB(dwIoBase + MAC_REG_MACCR , &byOrgValue);
-		if (byOrgValue & MACCR_SYNCFLUSHOK)
-			break;
-	}
-	if (ww == W_MAX_TIMEOUT) {
-		DBG_PORT80(0x35);
-		pr_debug(" DBG_PORT80(0x33)\n");
-	}
-	return true;
-}
-
 bool MACbPSWakeup(void __iomem *dwIoBase)
 {
 	unsigned char byOrgValue;
@@ -1472,211 +978,3 @@ void MACvDisableKeyEntry(void __iomem *dwIoBase, unsigned int uEntryIdx)
 	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, 0);
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 }
-
-/*
- * Description:
- *      Set the default Key (KeyEntry[10]) by MISCFIFO
- *
- * Parameters:
- *  In:
- *      dwIoBase        - Base Address for MAC
- *
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-
-void MACvSetDefaultKeyEntry(void __iomem *dwIoBase, unsigned int uKeyLen,
-			    unsigned int uKeyIdx, unsigned long *pdwKey, unsigned char byLocalID)
-{
-	unsigned short wOffset;
-	unsigned long dwData;
-	int     ii;
-
-	if (byLocalID <= 1)
-		return;
-
-	pr_debug("MACvSetDefaultKeyEntry\n");
-	wOffset = MISCFIFO_KEYETRY0;
-	wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
-
-	wOffset++;
-	wOffset++;
-	wOffset += (uKeyIdx * 4);
-	// always push 128 bits
-	for (ii = 0; ii < 3; ii++) {
-		pr_debug("(%d) wOffset: %d, Data: %lX\n",
-			 ii, wOffset+ii, *pdwKey);
-		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
-		VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
-		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-	}
-	dwData = *pdwKey;
-	if (uKeyLen == WLAN_KEY_LEN_WEP40)
-		dwData |= 0x80000000;
-
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+3);
-	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-	pr_debug("End. wOffset: %d, Data: %lX\n", wOffset+3, dwData);
-}
-
-/*
- * Description:
- *      Enable default Key (KeyEntry[10]) by MISCFIFO
- *
- * Parameters:
- *  In:
- *      dwIoBase        - Base Address for MAC
- *
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-/*
-  void MACvEnableDefaultKey(void __iomem *dwIoBase, unsigned char byLocalID)
-  {
-  unsigned short wOffset;
-  unsigned long dwData;
-
-  if (byLocalID <= 1)
-  return;
-
-  wOffset = MISCFIFO_KEYETRY0;
-  wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
-
-  dwData = 0xC0440000;
-  VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-  VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-  VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-  pr_debug("MACvEnableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
-
-  }
-*/
-
-/*
- * Description:
- *      Disable default Key (KeyEntry[10]) by MISCFIFO
- *
- * Parameters:
- *  In:
- *      dwIoBase        - Base Address for MAC
- *
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-void MACvDisableDefaultKey(void __iomem *dwIoBase)
-{
-	unsigned short wOffset;
-	unsigned long dwData;
-
-	wOffset = MISCFIFO_KEYETRY0;
-	wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
-
-	dwData = 0x0;
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-	pr_debug("MACvDisableDefaultKey: wOffset: %d, Data: %lX\n",
-		 wOffset, dwData);
-}
-
-/*
- * Description:
- *      Set the default TKIP Group Key (KeyEntry[10]) by MISCFIFO
- *
- * Parameters:
- *  In:
- *      dwIoBase        - Base Address for MAC
- *
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-void MACvSetDefaultTKIPKeyEntry(void __iomem *dwIoBase, unsigned int uKeyLen,
-				unsigned int uKeyIdx, unsigned long *pdwKey, unsigned char byLocalID)
-{
-	unsigned short wOffset;
-	unsigned long dwData;
-	int     ii;
-
-	if (byLocalID <= 1)
-		return;
-
-	pr_debug("MACvSetDefaultTKIPKeyEntry\n");
-	wOffset = MISCFIFO_KEYETRY0;
-	// Kyle test : change offset from 10 -> 0
-	wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
-
-	dwData = 0xC0660000;
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-	wOffset++;
-
-	dwData = 0;
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-	wOffset++;
-
-	wOffset += (uKeyIdx * 4);
-	pr_debug("1. wOffset: %d, Data: %lX, idx:%d\n",
-		 wOffset, *pdwKey, uKeyIdx);
-	// always push 128 bits
-	for (ii = 0; ii < 4; ii++) {
-		pr_debug("2.(%d) wOffset: %d, Data: %lX\n",
-			 ii, wOffset+ii, *pdwKey);
-		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
-		VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
-		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-	}
-}
-
-/*
- * Description:
- *      Set the Key Control by MISCFIFO
- *
- * Parameters:
- *  In:
- *      dwIoBase        - Base Address for MAC
- *
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-
-void MACvSetDefaultKeyCtl(void __iomem *dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx, unsigned char byLocalID)
-{
-	unsigned short wOffset;
-	unsigned long dwData;
-
-	if (byLocalID <= 1)
-		return;
-
-	pr_debug("MACvSetKeyEntry\n");
-	wOffset = MISCFIFO_KEYETRY0;
-	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
-
-	dwData = 0;
-	dwData |= wKeyCtl;
-	dwData <<= 16;
-	dwData |= 0xffff;
-	pr_debug("1. wOffset: %d, Data: %lX, KeyCtl:%X\n",
-		 wOffset, dwData, wKeyCtl);
-
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-}

commit 6b5db44ecd4e1e85e18f65cba99fcf53dac85314
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Nov 5 21:08:50 2014 +0000

    staging: vt6655: mac.c/h remove member type comments
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 122a6a3f6003..2ea74a185789 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -71,16 +71,6 @@
 #include "tmacro.h"
 #include "mac.h"
 
-/*---------------------  Static Classes  ----------------------------*/
-
-/*---------------------  Static Variables  --------------------------*/
-
-/*---------------------  Static Functions  --------------------------*/
-
-/*---------------------  Export Variables  --------------------------*/
-
-/*---------------------  Export Functions  --------------------------*/
-
 /*
  * Description:
  *      Read All MAC Registers to buffer

commit 5116d9fcf182536df69e2958b39a590e27ccedd2
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Nov 5 21:08:49 2014 +0000

    staging: vt6655: mac remove dead variable TxRate_iwconfig
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 955dbfebe170..122a6a3f6003 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -71,7 +71,6 @@
 #include "tmacro.h"
 #include "mac.h"
 
-unsigned short TxRate_iwconfig;//2008-5-8 <add> by chester
 /*---------------------  Static Classes  ----------------------------*/
 
 /*---------------------  Static Variables  --------------------------*/

commit d54435d3fb278e90f65f6033adbee89b23113229
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:54 2014 +0000

    staging: vt6655: dead code remove tether.h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index a347f3963934..955dbfebe170 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -69,7 +69,6 @@
  */
 
 #include "tmacro.h"
-#include "tether.h"
 #include "mac.h"
 
 unsigned short TxRate_iwconfig;//2008-5-8 <add> by chester

commit b0a08a8a73ce698e5d8d0b724a1e88aa1c2becff
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:44:01 2014 +0000

    staging: vt6655: MACvSetDefaultKeyEntry replace WLAN_WEP104_KEYLEN
    
    with WLAN_KEY_LEN_WEP40
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index e3b0b7f7ca85..a347f3963934 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -1526,7 +1526,7 @@ void MACvSetDefaultKeyEntry(void __iomem *dwIoBase, unsigned int uKeyLen,
 		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 	}
 	dwData = *pdwKey;
-	if (uKeyLen == WLAN_WEP104_KEYLEN)
+	if (uKeyLen == WLAN_KEY_LEN_WEP40)
 		dwData |= 0x80000000;
 
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+3);

commit 48caf5a060491edb2e1793539dad72e70c54c869
Author: Joe Perches <joe@perches.com>
Date:   Sun Aug 17 09:17:04 2014 -0700

    staging: vt6655: Convert DBG_PRT to pr_<level>
    
    DBG_PRT uses are unnecessarily complex.
    
    Convert DBG_PRT msglevel to pr_<level>.
    This changes the KERN_<level> type of several uses.
    It also enables dynamic_debug for the pr_debug conversions.
    
    This patch can be a prelude to converting these pr_<level>
    uses to dev_<level> as appropriate.
    
    Other changes:
    
    Realign arguments of these conversions.
    Remove now unused static int msglevel declarations.
    Remove now unused DBG_PRT #define.
    
    Compile tested only.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 9bbc873de702..e3b0b7f7ca85 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -73,8 +73,6 @@
 #include "mac.h"
 
 unsigned short TxRate_iwconfig;//2008-5-8 <add> by chester
-/*---------------------  Static Definitions -------------------------*/
-static int msglevel = MSG_LEVEL_INFO;
 /*---------------------  Static Classes  ----------------------------*/
 
 /*---------------------  Static Variables  --------------------------*/
@@ -837,7 +835,7 @@ bool MACbSafeRxOff(void __iomem *dwIoBase)
 	}
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x10);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x10)\n");
+		pr_debug(" DBG_PORT80(0x10)\n");
 		return false;
 	}
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
@@ -847,7 +845,7 @@ bool MACbSafeRxOff(void __iomem *dwIoBase)
 	}
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x11);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x11)\n");
+		pr_debug(" DBG_PORT80(0x11)\n");
 		return false;
 	}
 
@@ -861,7 +859,7 @@ bool MACbSafeRxOff(void __iomem *dwIoBase)
 	}
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x12);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x12)\n");
+		pr_debug(" DBG_PORT80(0x12)\n");
 		return false;
 	}
 	return true;
@@ -899,7 +897,7 @@ bool MACbSafeTxOff(void __iomem *dwIoBase)
 	}
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x20);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x20)\n");
+		pr_debug(" DBG_PORT80(0x20)\n");
 		return false;
 	}
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
@@ -909,7 +907,7 @@ bool MACbSafeTxOff(void __iomem *dwIoBase)
 	}
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x21);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x21)\n");
+		pr_debug(" DBG_PORT80(0x21)\n");
 		return false;
 	}
 
@@ -924,7 +922,7 @@ bool MACbSafeTxOff(void __iomem *dwIoBase)
 	}
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x24);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x24)\n");
+		pr_debug(" DBG_PORT80(0x24)\n");
 		return false;
 	}
 	return true;
@@ -949,13 +947,13 @@ bool MACbSafeStop(void __iomem *dwIoBase)
 
 	if (!MACbSafeRxOff(dwIoBase)) {
 		DBG_PORT80(0xA1);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " MACbSafeRxOff == false)\n");
+		pr_debug(" MACbSafeRxOff == false)\n");
 		MACbSafeSoftwareReset(dwIoBase);
 		return false;
 	}
 	if (!MACbSafeTxOff(dwIoBase)) {
 		DBG_PORT80(0xA2);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " MACbSafeTxOff == false)\n");
+		pr_debug(" MACbSafeTxOff == false)\n");
 		MACbSafeSoftwareReset(dwIoBase);
 		return false;
 	}
@@ -1172,7 +1170,7 @@ void MACvSetCurrAC0DescAddrEx(void __iomem *dwIoBase, unsigned long dwCurrDescAd
 	}
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x26);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x26)\n");
+		pr_debug(" DBG_PORT80(0x26)\n");
 	}
 	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
 	if (byOrgDMACtl & DMACTL_RUN)
@@ -1295,7 +1293,7 @@ bool MACbTxDMAOff(void __iomem *dwIoBase, unsigned int idx)
 	}
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x29);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x29)\n");
+		pr_debug(" DBG_PORT80(0x29)\n");
 		return false;
 	}
 	return true;
@@ -1319,7 +1317,7 @@ void MACvClearBusSusInd(void __iomem *dwIoBase)
 	}
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x33);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x33)\n");
+		pr_debug(" DBG_PORT80(0x33)\n");
 	}
 }
 
@@ -1341,7 +1339,7 @@ void MACvEnableBusSusEn(void __iomem *dwIoBase)
 	}
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x34);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x34)\n");
+		pr_debug(" DBG_PORT80(0x34)\n");
 	}
 }
 
@@ -1364,7 +1362,7 @@ bool MACbFlushSYNCFifo(void __iomem *dwIoBase)
 	}
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x35);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x33)\n");
+		pr_debug(" DBG_PORT80(0x33)\n");
 	}
 	return true;
 }
@@ -1388,7 +1386,7 @@ bool MACbPSWakeup(void __iomem *dwIoBase)
 	}
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x36);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x33)\n");
+		pr_debug(" DBG_PORT80(0x33)\n");
 		return false;
 	}
 	return true;
@@ -1419,7 +1417,7 @@ void MACvSetKeyEntry(void __iomem *dwIoBase, unsigned short wKeyCtl, unsigned in
 	if (byLocalID <= 1)
 		return;
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvSetKeyEntry\n");
+	pr_debug("MACvSetKeyEntry\n");
 	wOffset = MISCFIFO_KEYETRY0;
 	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 
@@ -1427,7 +1425,8 @@ void MACvSetKeyEntry(void __iomem *dwIoBase, unsigned short wKeyCtl, unsigned in
 	dwData |= wKeyCtl;
 	dwData <<= 16;
 	dwData |= MAKEWORD(*(pbyAddr+4), *(pbyAddr+5));
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "1. wOffset: %d, Data: %X, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
+	pr_debug("1. wOffset: %d, Data: %X, KeyCtl:%X\n",
+		 wOffset, dwData, wKeyCtl);
 
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
 	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
@@ -1442,7 +1441,7 @@ void MACvSetKeyEntry(void __iomem *dwIoBase, unsigned short wKeyCtl, unsigned in
 	dwData |= *(pbyAddr+1);
 	dwData <<= 8;
 	dwData |= *(pbyAddr+0);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "2. wOffset: %d, Data: %X\n", wOffset, dwData);
+	pr_debug("2. wOffset: %d, Data: %X\n", wOffset, dwData);
 
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
 	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
@@ -1452,7 +1451,8 @@ void MACvSetKeyEntry(void __iomem *dwIoBase, unsigned short wKeyCtl, unsigned in
 	wOffset += (uKeyIdx * 4);
 	for (ii = 0; ii < 4; ii++) {
 		// always push 128 bits
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "3.(%d) wOffset: %d, Data: %X\n", ii, wOffset+ii, *pdwKey);
+		pr_debug("3.(%d) wOffset: %d, Data: %X\n",
+			 ii, wOffset+ii, *pdwKey);
 		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
 		VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
 		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
@@ -1510,7 +1510,7 @@ void MACvSetDefaultKeyEntry(void __iomem *dwIoBase, unsigned int uKeyLen,
 	if (byLocalID <= 1)
 		return;
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvSetDefaultKeyEntry\n");
+	pr_debug("MACvSetDefaultKeyEntry\n");
 	wOffset = MISCFIFO_KEYETRY0;
 	wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
 
@@ -1519,7 +1519,8 @@ void MACvSetDefaultKeyEntry(void __iomem *dwIoBase, unsigned int uKeyLen,
 	wOffset += (uKeyIdx * 4);
 	// always push 128 bits
 	for (ii = 0; ii < 3; ii++) {
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
+		pr_debug("(%d) wOffset: %d, Data: %lX\n",
+			 ii, wOffset+ii, *pdwKey);
 		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
 		VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
 		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
@@ -1531,7 +1532,7 @@ void MACvSetDefaultKeyEntry(void __iomem *dwIoBase, unsigned int uKeyLen,
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+3);
 	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "End. wOffset: %d, Data: %lX\n", wOffset+3, dwData);
+	pr_debug("End. wOffset: %d, Data: %lX\n", wOffset+3, dwData);
 }
 
 /*
@@ -1564,7 +1565,7 @@ void MACvSetDefaultKeyEntry(void __iomem *dwIoBase, unsigned int uKeyLen,
   VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
   VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
   VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-  DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvEnableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
+  pr_debug("MACvEnableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
 
   }
 */
@@ -1595,7 +1596,8 @@ void MACvDisableDefaultKey(void __iomem *dwIoBase)
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
 	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvDisableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
+	pr_debug("MACvDisableDefaultKey: wOffset: %d, Data: %lX\n",
+		 wOffset, dwData);
 }
 
 /*
@@ -1622,7 +1624,7 @@ void MACvSetDefaultTKIPKeyEntry(void __iomem *dwIoBase, unsigned int uKeyLen,
 	if (byLocalID <= 1)
 		return;
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvSetDefaultTKIPKeyEntry\n");
+	pr_debug("MACvSetDefaultTKIPKeyEntry\n");
 	wOffset = MISCFIFO_KEYETRY0;
 	// Kyle test : change offset from 10 -> 0
 	wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
@@ -1640,10 +1642,12 @@ void MACvSetDefaultTKIPKeyEntry(void __iomem *dwIoBase, unsigned int uKeyLen,
 	wOffset++;
 
 	wOffset += (uKeyIdx * 4);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "1. wOffset: %d, Data: %lX, idx:%d\n", wOffset, *pdwKey, uKeyIdx);
+	pr_debug("1. wOffset: %d, Data: %lX, idx:%d\n",
+		 wOffset, *pdwKey, uKeyIdx);
 	// always push 128 bits
 	for (ii = 0; ii < 4; ii++) {
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "2.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
+		pr_debug("2.(%d) wOffset: %d, Data: %lX\n",
+			 ii, wOffset+ii, *pdwKey);
 		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
 		VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
 		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
@@ -1673,7 +1677,7 @@ void MACvSetDefaultKeyCtl(void __iomem *dwIoBase, unsigned short wKeyCtl, unsign
 	if (byLocalID <= 1)
 		return;
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvSetKeyEntry\n");
+	pr_debug("MACvSetKeyEntry\n");
 	wOffset = MISCFIFO_KEYETRY0;
 	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 
@@ -1681,7 +1685,8 @@ void MACvSetDefaultKeyCtl(void __iomem *dwIoBase, unsigned short wKeyCtl, unsign
 	dwData |= wKeyCtl;
 	dwData <<= 16;
 	dwData |= 0xffff;
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
+	pr_debug("1. wOffset: %d, Data: %lX, KeyCtl:%X\n",
+		 wOffset, dwData, wKeyCtl);
 
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
 	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);

commit 1683440595ea33cc019fb8524b04319cf82bc6ac
Author: Guillaume Clement <gclement@baobob.org>
Date:   Tue Jul 22 22:08:26 2014 +0200

    staging: vt6655: change type of PortOffset to void __iomem *
    
    PortOffset was an unsigned long, but used as an pointer to io
    memory. Sometimes it was not properly cast before use, which caused
    many warning by sparse.
    
    By updating its type to void __iomem *, and reflecting the changes
    where it is needed, this removes most of those warnings.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index af6876a01ee8..9bbc873de702 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -98,7 +98,7 @@ static int msglevel = MSG_LEVEL_INFO;
  * Return Value: none
  *
  */
-void MACvReadAllRegs(unsigned long dwIoBase, unsigned char *pbyMacRegs)
+void MACvReadAllRegs(void __iomem *dwIoBase, unsigned char *pbyMacRegs)
 {
 	int ii;
 
@@ -134,7 +134,7 @@ void MACvReadAllRegs(unsigned long dwIoBase, unsigned char *pbyMacRegs)
  * Return Value: true if all test bits On; otherwise false
  *
  */
-bool MACbIsRegBitsOn(unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
+bool MACbIsRegBitsOn(void __iomem *dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
 {
 	unsigned char byData;
 
@@ -157,7 +157,7 @@ bool MACbIsRegBitsOn(unsigned long dwIoBase, unsigned char byRegOfs, unsigned ch
  * Return Value: true if all test bits Off; otherwise false
  *
  */
-bool MACbIsRegBitsOff(unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
+bool MACbIsRegBitsOff(void __iomem *dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
 {
 	unsigned char byData;
 
@@ -178,7 +178,7 @@ bool MACbIsRegBitsOff(unsigned long dwIoBase, unsigned char byRegOfs, unsigned c
  * Return Value: true if interrupt is disable; otherwise false
  *
  */
-bool MACbIsIntDisable(unsigned long dwIoBase)
+bool MACbIsIntDisable(void __iomem *dwIoBase)
 {
 	unsigned long dwData;
 
@@ -203,7 +203,7 @@ bool MACbIsIntDisable(unsigned long dwIoBase)
  * Return Value: Mask Value read
  *
  */
-unsigned char MACbyReadMultiAddr(unsigned long dwIoBase, unsigned int uByteIdx)
+unsigned char MACbyReadMultiAddr(void __iomem *dwIoBase, unsigned int uByteIdx)
 {
 	unsigned char byData;
 
@@ -228,7 +228,7 @@ unsigned char MACbyReadMultiAddr(unsigned long dwIoBase, unsigned int uByteIdx)
  * Return Value: none
  *
  */
-void MACvWriteMultiAddr(unsigned long dwIoBase, unsigned int uByteIdx, unsigned char byData)
+void MACvWriteMultiAddr(void __iomem *dwIoBase, unsigned int uByteIdx, unsigned char byData)
 {
 	MACvSelectPage1(dwIoBase);
 	VNSvOutPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, byData);
@@ -249,7 +249,7 @@ void MACvWriteMultiAddr(unsigned long dwIoBase, unsigned int uByteIdx, unsigned
  * Return Value: none
  *
  */
-void MACvSetMultiAddrByHash(unsigned long dwIoBase, unsigned char byHashIdx)
+void MACvSetMultiAddrByHash(void __iomem *dwIoBase, unsigned char byHashIdx)
 {
 	unsigned int uByteIdx;
 	unsigned char byBitMask;
@@ -280,7 +280,7 @@ void MACvSetMultiAddrByHash(unsigned long dwIoBase, unsigned char byHashIdx)
  * Return Value: none
  *
  */
-void MACvResetMultiAddrByHash(unsigned long dwIoBase, unsigned char byHashIdx)
+void MACvResetMultiAddrByHash(void __iomem *dwIoBase, unsigned char byHashIdx)
 {
 	unsigned int uByteIdx;
 	unsigned char byBitMask;
@@ -311,7 +311,7 @@ void MACvResetMultiAddrByHash(unsigned long dwIoBase, unsigned char byHashIdx)
  * Return Value: none
  *
  */
-void MACvSetRxThreshold(unsigned long dwIoBase, unsigned char byThreshold)
+void MACvSetRxThreshold(void __iomem *dwIoBase, unsigned char byThreshold)
 {
 	unsigned char byOrgValue;
 
@@ -336,7 +336,7 @@ void MACvSetRxThreshold(unsigned long dwIoBase, unsigned char byThreshold)
  * Return Value: none
  *
  */
-void MACvGetRxThreshold(unsigned long dwIoBase, unsigned char *pbyThreshold)
+void MACvGetRxThreshold(void __iomem *dwIoBase, unsigned char *pbyThreshold)
 {
 	// get FCR0
 	VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
@@ -357,7 +357,7 @@ void MACvGetRxThreshold(unsigned long dwIoBase, unsigned char *pbyThreshold)
  * Return Value: none
  *
  */
-void MACvSetTxThreshold(unsigned long dwIoBase, unsigned char byThreshold)
+void MACvSetTxThreshold(void __iomem *dwIoBase, unsigned char byThreshold)
 {
 	unsigned char byOrgValue;
 
@@ -382,7 +382,7 @@ void MACvSetTxThreshold(unsigned long dwIoBase, unsigned char byThreshold)
  * Return Value: none
  *
  */
-void MACvGetTxThreshold(unsigned long dwIoBase, unsigned char *pbyThreshold)
+void MACvGetTxThreshold(void __iomem *dwIoBase, unsigned char *pbyThreshold)
 {
 	// get FCR0
 	VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
@@ -403,7 +403,7 @@ void MACvGetTxThreshold(unsigned long dwIoBase, unsigned char *pbyThreshold)
  * Return Value: none
  *
  */
-void MACvSetDmaLength(unsigned long dwIoBase, unsigned char byDmaLength)
+void MACvSetDmaLength(void __iomem *dwIoBase, unsigned char byDmaLength)
 {
 	unsigned char byOrgValue;
 
@@ -428,7 +428,7 @@ void MACvSetDmaLength(unsigned long dwIoBase, unsigned char byDmaLength)
  * Return Value: none
  *
  */
-void MACvGetDmaLength(unsigned long dwIoBase, unsigned char *pbyDmaLength)
+void MACvGetDmaLength(void __iomem *dwIoBase, unsigned char *pbyDmaLength)
 {
 	// get FCR0
 	VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyDmaLength);
@@ -449,7 +449,7 @@ void MACvGetDmaLength(unsigned long dwIoBase, unsigned char *pbyDmaLength)
  * Return Value: none
  *
  */
-void MACvSetShortRetryLimit(unsigned long dwIoBase, unsigned char byRetryLimit)
+void MACvSetShortRetryLimit(void __iomem *dwIoBase, unsigned char byRetryLimit)
 {
 	// set SRT
 	VNSvOutPortB(dwIoBase + MAC_REG_SRT, byRetryLimit);
@@ -468,7 +468,7 @@ void MACvSetShortRetryLimit(unsigned long dwIoBase, unsigned char byRetryLimit)
  * Return Value: none
  *
  */
-void MACvGetShortRetryLimit(unsigned long dwIoBase, unsigned char *pbyRetryLimit)
+void MACvGetShortRetryLimit(void __iomem *dwIoBase, unsigned char *pbyRetryLimit)
 {
 	// get SRT
 	VNSvInPortB(dwIoBase + MAC_REG_SRT, pbyRetryLimit);
@@ -488,7 +488,7 @@ void MACvGetShortRetryLimit(unsigned long dwIoBase, unsigned char *pbyRetryLimit
  * Return Value: none
  *
  */
-void MACvSetLongRetryLimit(unsigned long dwIoBase, unsigned char byRetryLimit)
+void MACvSetLongRetryLimit(void __iomem *dwIoBase, unsigned char byRetryLimit)
 {
 	// set LRT
 	VNSvOutPortB(dwIoBase + MAC_REG_LRT, byRetryLimit);
@@ -507,7 +507,7 @@ void MACvSetLongRetryLimit(unsigned long dwIoBase, unsigned char byRetryLimit)
  * Return Value: none
  *
  */
-void MACvGetLongRetryLimit(unsigned long dwIoBase, unsigned char *pbyRetryLimit)
+void MACvGetLongRetryLimit(void __iomem *dwIoBase, unsigned char *pbyRetryLimit)
 {
 	// get LRT
 	VNSvInPortB(dwIoBase + MAC_REG_LRT, pbyRetryLimit);
@@ -527,7 +527,7 @@ void MACvGetLongRetryLimit(unsigned long dwIoBase, unsigned char *pbyRetryLimit)
  * Return Value: none
  *
  */
-void MACvSetLoopbackMode(unsigned long dwIoBase, unsigned char byLoopbackMode)
+void MACvSetLoopbackMode(void __iomem *dwIoBase, unsigned char byLoopbackMode)
 {
 	unsigned char byOrgValue;
 
@@ -553,7 +553,7 @@ void MACvSetLoopbackMode(unsigned long dwIoBase, unsigned char byLoopbackMode)
  * Return Value: true if in Loopback mode; otherwise false
  *
  */
-bool MACbIsInLoopbackMode(unsigned long dwIoBase)
+bool MACbIsInLoopbackMode(void __iomem *dwIoBase)
 {
 	unsigned char byOrgValue;
 
@@ -577,7 +577,7 @@ bool MACbIsInLoopbackMode(unsigned long dwIoBase)
  * Return Value: none
  *
  */
-void MACvSetPacketFilter(unsigned long dwIoBase, unsigned short wFilterType)
+void MACvSetPacketFilter(void __iomem *dwIoBase, unsigned short wFilterType)
 {
 	unsigned char byOldRCR;
 	unsigned char byNewRCR = 0;
@@ -636,7 +636,7 @@ void MACvSetPacketFilter(unsigned long dwIoBase, unsigned short wFilterType)
  * Return Value: none
  *
  */
-void MACvSaveContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
+void MACvSaveContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
 {
 	int         ii;
 
@@ -667,7 +667,7 @@ void MACvSaveContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: none
  *
  */
-void MACvRestoreContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
+void MACvRestoreContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
 {
 	int         ii;
 
@@ -716,7 +716,7 @@ void MACvRestoreContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: true if all values are the same; otherwise false
  *
  */
-bool MACbCompareContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
+bool MACbCompareContext(void __iomem *dwIoBase, unsigned char *pbyCxtBuf)
 {
 	unsigned long dwData;
 
@@ -756,7 +756,7 @@ bool MACbCompareContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: true if Reset Success; otherwise false
  *
  */
-bool MACbSoftwareReset(unsigned long dwIoBase)
+bool MACbSoftwareReset(void __iomem *dwIoBase)
 {
 	unsigned char byData;
 	unsigned short ww;
@@ -787,7 +787,7 @@ bool MACbSoftwareReset(unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbSafeSoftwareReset(unsigned long dwIoBase)
+bool MACbSafeSoftwareReset(void __iomem *dwIoBase)
 {
 	unsigned char abyTmpRegData[MAC_MAX_CONTEXT_SIZE_PAGE0+MAC_MAX_CONTEXT_SIZE_PAGE1];
 	bool bRetVal;
@@ -819,7 +819,7 @@ bool MACbSafeSoftwareReset(unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbSafeRxOff(unsigned long dwIoBase)
+bool MACbSafeRxOff(void __iomem *dwIoBase)
 {
 	unsigned short ww;
 	unsigned long dwData;
@@ -880,7 +880,7 @@ bool MACbSafeRxOff(unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbSafeTxOff(unsigned long dwIoBase)
+bool MACbSafeTxOff(void __iomem *dwIoBase)
 {
 	unsigned short ww;
 	unsigned long dwData;
@@ -943,7 +943,7 @@ bool MACbSafeTxOff(unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbSafeStop(unsigned long dwIoBase)
+bool MACbSafeStop(void __iomem *dwIoBase)
 {
 	MACvRegBitsOff(dwIoBase, MAC_REG_TCR, TCR_AUTOBCNTX);
 
@@ -978,7 +978,7 @@ bool MACbSafeStop(unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbShutdown(unsigned long dwIoBase)
+bool MACbShutdown(void __iomem *dwIoBase)
 {
 	// disable MAC IMR
 	MACvIntDisable(dwIoBase);
@@ -1005,7 +1005,7 @@ bool MACbShutdown(unsigned long dwIoBase)
  * Return Value: none
  *
  */
-void MACvInitialize(unsigned long dwIoBase)
+void MACvInitialize(void __iomem *dwIoBase)
 {
 	// clear sticky bits
 	MACvClearStckDS(dwIoBase);
@@ -1041,7 +1041,7 @@ void MACvInitialize(unsigned long dwIoBase)
  * Return Value: none
  *
  */
-void MACvSetCurrRx0DescAddr(unsigned long dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrRx0DescAddr(void __iomem *dwIoBase, unsigned long dwCurrDescAddr)
 {
 	unsigned short ww;
 	unsigned char byData;
@@ -1079,7 +1079,7 @@ void MACvSetCurrRx0DescAddr(unsigned long dwIoBase, unsigned long dwCurrDescAddr
  * Return Value: none
  *
  */
-void MACvSetCurrRx1DescAddr(unsigned long dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrRx1DescAddr(void __iomem *dwIoBase, unsigned long dwCurrDescAddr)
 {
 	unsigned short ww;
 	unsigned char byData;
@@ -1117,7 +1117,7 @@ void MACvSetCurrRx1DescAddr(unsigned long dwIoBase, unsigned long dwCurrDescAddr
  * Return Value: none
  *
  */
-void MACvSetCurrTx0DescAddrEx(unsigned long dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrTx0DescAddrEx(void __iomem *dwIoBase, unsigned long dwCurrDescAddr)
 {
 	unsigned short ww;
 	unsigned char byData;
@@ -1155,7 +1155,7 @@ void MACvSetCurrTx0DescAddrEx(unsigned long dwIoBase, unsigned long dwCurrDescAd
  *
  */
 //TxDMA1 = AC0DMA
-void MACvSetCurrAC0DescAddrEx(unsigned long dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrAC0DescAddrEx(void __iomem *dwIoBase, unsigned long dwCurrDescAddr)
 {
 	unsigned short ww;
 	unsigned char byData;
@@ -1179,7 +1179,7 @@ void MACvSetCurrAC0DescAddrEx(unsigned long dwIoBase, unsigned long dwCurrDescAd
 		VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_RUN);
 }
 
-void MACvSetCurrTXDescAddr(int iTxType, unsigned long dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrTXDescAddr(int iTxType, void __iomem *dwIoBase, unsigned long dwCurrDescAddr)
 {
 	if (iTxType == TYPE_AC0DMA)
 		MACvSetCurrAC0DescAddrEx(dwIoBase, dwCurrDescAddr);
@@ -1201,7 +1201,7 @@ void MACvSetCurrTXDescAddr(int iTxType, unsigned long dwIoBase, unsigned long dw
  * Return Value: none
  *
  */
-void MACvTimer0MicroSDelay(unsigned long dwIoBase, unsigned int uDelay)
+void MACvTimer0MicroSDelay(void __iomem *dwIoBase, unsigned int uDelay)
 {
 	unsigned char byValue;
 	unsigned int uu, ii;
@@ -1236,7 +1236,7 @@ void MACvTimer0MicroSDelay(unsigned long dwIoBase, unsigned int uDelay)
  * Return Value: none
  *
  */
-void MACvOneShotTimer0MicroSec(unsigned long dwIoBase, unsigned int uDelayTime)
+void MACvOneShotTimer0MicroSec(void __iomem *dwIoBase, unsigned int uDelayTime)
 {
 	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
 	VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelayTime);
@@ -1257,14 +1257,14 @@ void MACvOneShotTimer0MicroSec(unsigned long dwIoBase, unsigned int uDelayTime)
  * Return Value: none
  *
  */
-void MACvOneShotTimer1MicroSec(unsigned long dwIoBase, unsigned int uDelayTime)
+void MACvOneShotTimer1MicroSec(void __iomem *dwIoBase, unsigned int uDelayTime)
 {
 	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, 0);
 	VNSvOutPortD(dwIoBase + MAC_REG_TMDATA1, uDelayTime);
 	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, (TMCTL_TMD | TMCTL_TE));
 }
 
-void MACvSetMISCFifo(unsigned long dwIoBase, unsigned short wOffset, unsigned long dwData)
+void MACvSetMISCFifo(void __iomem *dwIoBase, unsigned short wOffset, unsigned long dwData)
 {
 	if (wOffset > 273)
 		return;
@@ -1273,7 +1273,7 @@ void MACvSetMISCFifo(unsigned long dwIoBase, unsigned short wOffset, unsigned lo
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 }
 
-bool MACbTxDMAOff(unsigned long dwIoBase, unsigned int idx)
+bool MACbTxDMAOff(void __iomem *dwIoBase, unsigned int idx)
 {
 	unsigned char byData;
 	unsigned int ww = 0;
@@ -1301,7 +1301,7 @@ bool MACbTxDMAOff(unsigned long dwIoBase, unsigned int idx)
 	return true;
 }
 
-void MACvClearBusSusInd(unsigned long dwIoBase)
+void MACvClearBusSusInd(void __iomem *dwIoBase)
 {
 	unsigned long dwOrgValue;
 	unsigned int ww;
@@ -1323,7 +1323,7 @@ void MACvClearBusSusInd(unsigned long dwIoBase)
 	}
 }
 
-void MACvEnableBusSusEn(unsigned long dwIoBase)
+void MACvEnableBusSusEn(void __iomem *dwIoBase)
 {
 	unsigned char byOrgValue;
 	unsigned long dwOrgValue;
@@ -1345,7 +1345,7 @@ void MACvEnableBusSusEn(unsigned long dwIoBase)
 	}
 }
 
-bool MACbFlushSYNCFifo(unsigned long dwIoBase)
+bool MACbFlushSYNCFifo(void __iomem *dwIoBase)
 {
 	unsigned char byOrgValue;
 	unsigned int ww;
@@ -1369,7 +1369,7 @@ bool MACbFlushSYNCFifo(unsigned long dwIoBase)
 	return true;
 }
 
-bool MACbPSWakeup(unsigned long dwIoBase)
+bool MACbPSWakeup(void __iomem *dwIoBase)
 {
 	unsigned char byOrgValue;
 	unsigned int ww;
@@ -1409,7 +1409,7 @@ bool MACbPSWakeup(unsigned long dwIoBase)
  *
  */
 
-void MACvSetKeyEntry(unsigned long dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx,
+void MACvSetKeyEntry(void __iomem *dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx,
 		     unsigned int uKeyIdx, unsigned char *pbyAddr, u32 *pdwKey, unsigned char byLocalID)
 {
 	unsigned short wOffset;
@@ -1473,7 +1473,7 @@ void MACvSetKeyEntry(unsigned long dwIoBase, unsigned short wKeyCtl, unsigned in
  * Return Value: none
  *
  */
-void MACvDisableKeyEntry(unsigned long dwIoBase, unsigned int uEntryIdx)
+void MACvDisableKeyEntry(void __iomem *dwIoBase, unsigned int uEntryIdx)
 {
 	unsigned short wOffset;
 
@@ -1500,7 +1500,7 @@ void MACvDisableKeyEntry(unsigned long dwIoBase, unsigned int uEntryIdx)
  *
  */
 
-void MACvSetDefaultKeyEntry(unsigned long dwIoBase, unsigned int uKeyLen,
+void MACvSetDefaultKeyEntry(void __iomem *dwIoBase, unsigned int uKeyLen,
 			    unsigned int uKeyIdx, unsigned long *pdwKey, unsigned char byLocalID)
 {
 	unsigned short wOffset;
@@ -1549,7 +1549,7 @@ void MACvSetDefaultKeyEntry(unsigned long dwIoBase, unsigned int uKeyLen,
  *
  */
 /*
-  void MACvEnableDefaultKey(unsigned long dwIoBase, unsigned char byLocalID)
+  void MACvEnableDefaultKey(void __iomem *dwIoBase, unsigned char byLocalID)
   {
   unsigned short wOffset;
   unsigned long dwData;
@@ -1583,7 +1583,7 @@ void MACvSetDefaultKeyEntry(unsigned long dwIoBase, unsigned int uKeyLen,
  * Return Value: none
  *
  */
-void MACvDisableDefaultKey(unsigned long dwIoBase)
+void MACvDisableDefaultKey(void __iomem *dwIoBase)
 {
 	unsigned short wOffset;
 	unsigned long dwData;
@@ -1612,7 +1612,7 @@ void MACvDisableDefaultKey(unsigned long dwIoBase)
  * Return Value: none
  *
  */
-void MACvSetDefaultTKIPKeyEntry(unsigned long dwIoBase, unsigned int uKeyLen,
+void MACvSetDefaultTKIPKeyEntry(void __iomem *dwIoBase, unsigned int uKeyLen,
 				unsigned int uKeyIdx, unsigned long *pdwKey, unsigned char byLocalID)
 {
 	unsigned short wOffset;
@@ -1665,7 +1665,7 @@ void MACvSetDefaultTKIPKeyEntry(unsigned long dwIoBase, unsigned int uKeyLen,
  *
  */
 
-void MACvSetDefaultKeyCtl(unsigned long dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx, unsigned char byLocalID)
+void MACvSetDefaultKeyCtl(void __iomem *dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx, unsigned char byLocalID)
 {
 	unsigned short wOffset;
 	unsigned long dwData;

commit bc5cf6563576bb36baa7e93417b9a2e29999a5c6
Author: Guido Martínez <guido@vanguardiasur.com.ar>
Date:   Sat Apr 19 16:45:00 2014 -0300

    staging: vt6655: fix checkpatch bracing issues
    
    This patchs fixes tons of warnings such as:
    
      WARNING: braces {} are not necessary for single statement blocks
      #354: FILE: drivers/staging/vt6655/wmgr.c:354:
      +       for (ii = 0; ii < WLAN_BSSID_LEN; ii++) {
      +               pMgmt->abyDesireBSSID[ii] = 0xFF;
      +       }
    
    Please note: this patch only fixes bracing issues (and there is still a
    lot to do); so if you run checkpatch it _will_ throw a lot of errors.
    Use --test-only=braces
    
    Signed-off-by: Guido Martínez <guido@vanguardiasur.com.ar>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index db53e1a57bca..af6876a01ee8 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -641,16 +641,14 @@ void MACvSaveContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 	int         ii;
 
 	// read page0 register
-	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE0; ii++) {
+	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE0; ii++)
 		VNSvInPortB((dwIoBase + ii), (pbyCxtBuf + ii));
-	}
 
 	MACvSelectPage1(dwIoBase);
 
 	// read page1 register
-	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++) {
+	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++)
 		VNSvInPortB((dwIoBase + ii), (pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
-	}
 
 	MACvSelectPage0(dwIoBase);
 }
@@ -675,25 +673,24 @@ void MACvRestoreContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 
 	MACvSelectPage1(dwIoBase);
 	// restore page1
-	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++) {
+	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++)
 		VNSvOutPortB((dwIoBase + ii), *(pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
-	}
+
 	MACvSelectPage0(dwIoBase);
 
 	// restore RCR,TCR,IMR...
-	for (ii = MAC_REG_RCR; ii < MAC_REG_ISR; ii++) {
+	for (ii = MAC_REG_RCR; ii < MAC_REG_ISR; ii++)
 		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
-	}
+
 	// restore MAC Config.
-	for (ii = MAC_REG_LRT; ii < MAC_REG_PAGE1SEL; ii++) {
+	for (ii = MAC_REG_LRT; ii < MAC_REG_PAGE1SEL; ii++)
 		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
-	}
+
 	VNSvOutPortB(dwIoBase + MAC_REG_CFG, *(pbyCxtBuf + MAC_REG_CFG));
 
 	// restore PS Config.
-	for (ii = MAC_REG_PSCFG; ii < MAC_REG_BBREGCTL; ii++) {
+	for (ii = MAC_REG_PSCFG; ii < MAC_REG_BBREGCTL; ii++)
 		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
-	}
 
 	// restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
 	VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0));
@@ -728,24 +725,20 @@ bool MACbCompareContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 
 	// compare CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
 	VNSvInPortD(dwIoBase + MAC_REG_TXDMAPTR0, &dwData);
-	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0)) {
+	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0))
 		return false;
-	}
 
 	VNSvInPortD(dwIoBase + MAC_REG_AC0DMAPTR, &dwData);
-	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR)) {
+	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR))
 		return false;
-	}
 
 	VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR0, &dwData);
-	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0)) {
+	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0))
 		return false;
-	}
 
 	VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR1, &dwData);
-	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1)) {
+	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1))
 		return false;
-	}
 
 	return true;
 }
@@ -1055,21 +1048,21 @@ void MACvSetCurrRx0DescAddr(unsigned long dwIoBase, unsigned long dwCurrDescAddr
 	unsigned char byOrgDMACtl;
 
 	VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byOrgDMACtl);
-	if (byOrgDMACtl & DMACTL_RUN) {
+	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0+2, DMACTL_RUN);
-	}
+
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byData);
 		if (!(byData & DMACTL_RUN))
 			break;
 	}
-	if (ww == W_MAX_TIMEOUT) {
+
+	if (ww == W_MAX_TIMEOUT)
 		DBG_PORT80(0x13);
-	}
+
 	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, dwCurrDescAddr);
-	if (byOrgDMACtl & DMACTL_RUN) {
+	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_RUN);
-	}
 }
 
 /*
@@ -1093,21 +1086,21 @@ void MACvSetCurrRx1DescAddr(unsigned long dwIoBase, unsigned long dwCurrDescAddr
 	unsigned char byOrgDMACtl;
 
 	VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byOrgDMACtl);
-	if (byOrgDMACtl & DMACTL_RUN) {
+	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1+2, DMACTL_RUN);
-	}
+
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byData);
 		if (!(byData & DMACTL_RUN))
 			break;
 	}
-	if (ww == W_MAX_TIMEOUT) {
+	if (ww == W_MAX_TIMEOUT)
 		DBG_PORT80(0x14);
-	}
+
 	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, dwCurrDescAddr);
-	if (byOrgDMACtl & DMACTL_RUN) {
+	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_RUN);
-	}
+
 }
 
 /*
@@ -1131,21 +1124,20 @@ void MACvSetCurrTx0DescAddrEx(unsigned long dwIoBase, unsigned long dwCurrDescAd
 	unsigned char byOrgDMACtl;
 
 	VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byOrgDMACtl);
-	if (byOrgDMACtl & DMACTL_RUN) {
+	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
-	}
+
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
 		if (!(byData & DMACTL_RUN))
 			break;
 	}
-	if (ww == W_MAX_TIMEOUT) {
+	if (ww == W_MAX_TIMEOUT)
 		DBG_PORT80(0x25);
-	}
+
 	VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, dwCurrDescAddr);
-	if (byOrgDMACtl & DMACTL_RUN) {
+	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0, DMACTL_RUN);
-	}
 }
 
 /*
@@ -1170,9 +1162,9 @@ void MACvSetCurrAC0DescAddrEx(unsigned long dwIoBase, unsigned long dwCurrDescAd
 	unsigned char byOrgDMACtl;
 
 	VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byOrgDMACtl);
-	if (byOrgDMACtl & DMACTL_RUN) {
+	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
-	}
+
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
 		if (!(byData & DMACTL_RUN))
@@ -1183,18 +1175,16 @@ void MACvSetCurrAC0DescAddrEx(unsigned long dwIoBase, unsigned long dwCurrDescAd
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x26)\n");
 	}
 	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
-	if (byOrgDMACtl & DMACTL_RUN) {
+	if (byOrgDMACtl & DMACTL_RUN)
 		VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_RUN);
-	}
 }
 
 void MACvSetCurrTXDescAddr(int iTxType, unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
-	if (iTxType == TYPE_AC0DMA) {
+	if (iTxType == TYPE_AC0DMA)
 		MACvSetCurrAC0DescAddrEx(dwIoBase, dwCurrDescAddr);
-	} else if (iTxType == TYPE_TXDMA0) {
+	else if (iTxType == TYPE_TXDMA0)
 		MACvSetCurrTx0DescAddrEx(dwIoBase, dwCurrDescAddr);
-	}
 }
 
 /*
@@ -1384,9 +1374,9 @@ bool MACbPSWakeup(unsigned long dwIoBase)
 	unsigned char byOrgValue;
 	unsigned int ww;
 	// Read PSCTL
-	if (MACbIsRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PS)) {
+	if (MACbIsRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PS))
 		return true;
-	}
+
 	// Disable PS
 	MACvRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PSEN);
 
@@ -1535,9 +1525,9 @@ void MACvSetDefaultKeyEntry(unsigned long dwIoBase, unsigned int uKeyLen,
 		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 	}
 	dwData = *pdwKey;
-	if (uKeyLen == WLAN_WEP104_KEYLEN) {
+	if (uKeyLen == WLAN_WEP104_KEYLEN)
 		dwData |= 0x80000000;
-	}
+
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+3);
 	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);

commit 4e8a7e5fc29697f881f5c358f84df52914908703
Author: Guido Martínez <guido@vanguardiasur.com.ar>
Date:   Sat Apr 19 16:44:59 2014 -0300

    staging: vt6655: remove dead code
    
    Remove dead code in many places on this driver.
    
    Signed-off-by: Guido Martínez <guido@vanguardiasur.com.ar>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 0ec079fa0398..db53e1a57bca 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -74,7 +74,6 @@
 
 unsigned short TxRate_iwconfig;//2008-5-8 <add> by chester
 /*---------------------  Static Definitions -------------------------*/
-//static int          msglevel                =MSG_LEVEL_DEBUG;
 static int msglevel = MSG_LEVEL_INFO;
 /*---------------------  Static Classes  ----------------------------*/
 
@@ -770,7 +769,6 @@ bool MACbSoftwareReset(unsigned long dwIoBase)
 	unsigned short ww;
 
 	// turn on HOSTCR_SOFTRST, just write 0x01 to reset
-	//MACvRegBitsOn(dwIoBase, MAC_REG_HOSTCR, HOSTCR_SOFTRST);
 	VNSvOutPortB(dwIoBase + MAC_REG_HOSTCR, 0x01);
 
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
@@ -809,7 +807,6 @@ bool MACbSafeSoftwareReset(unsigned long dwIoBase)
 	MACvSaveContext(dwIoBase, abyTmpRegData);
 	// do reset
 	bRetVal = MACbSoftwareReset(dwIoBase);
-	//BBvSoftwareReset(pDevice->PortOffset);
 	// restore MAC context, except CR0
 	MACvRestoreContext(dwIoBase, abyTmpRegData);
 
@@ -1022,11 +1019,6 @@ void MACvInitialize(unsigned long dwIoBase)
 	// disable force PME-enable
 	VNSvOutPortB(dwIoBase + MAC_REG_PMC1, PME_OVR);
 	// only 3253 A
-	/*
-	  MACvPwrEvntDisable(dwIoBase);
-	  // clear power status
-	  VNSvOutPortW(dwIoBase + MAC_REG_WAKEUPSR0, 0x0F0F);
-	*/
 
 	// do reset
 	MACbSoftwareReset(dwIoBase);

commit 4dbc77c098eee0270b501f92aeb33a0745e00b06
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Mar 6 22:44:22 2014 +0000

    staging: vt6655: 64 bit fixes: MACvSetKeyEntry correct sizeof long,
    
    Use u32 to correct the pointer of pdwKey and the size of dwData.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 21bd8a1126d7..0ec079fa0398 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -1428,10 +1428,10 @@ bool MACbPSWakeup(unsigned long dwIoBase)
  */
 
 void MACvSetKeyEntry(unsigned long dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx,
-		     unsigned int uKeyIdx, unsigned char *pbyAddr, unsigned long *pdwKey, unsigned char byLocalID)
+		     unsigned int uKeyIdx, unsigned char *pbyAddr, u32 *pdwKey, unsigned char byLocalID)
 {
 	unsigned short wOffset;
-	unsigned long dwData;
+	u32 dwData;
 	int     ii;
 
 	if (byLocalID <= 1)
@@ -1445,7 +1445,7 @@ void MACvSetKeyEntry(unsigned long dwIoBase, unsigned short wKeyCtl, unsigned in
 	dwData |= wKeyCtl;
 	dwData <<= 16;
 	dwData |= MAKEWORD(*(pbyAddr+4), *(pbyAddr+5));
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "1. wOffset: %d, Data: %X, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
 
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
 	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
@@ -1460,7 +1460,7 @@ void MACvSetKeyEntry(unsigned long dwIoBase, unsigned short wKeyCtl, unsigned in
 	dwData |= *(pbyAddr+1);
 	dwData <<= 8;
 	dwData |= *(pbyAddr+0);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "2. wOffset: %d, Data: %lX\n", wOffset, dwData);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "2. wOffset: %d, Data: %X\n", wOffset, dwData);
 
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
 	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
@@ -1470,7 +1470,7 @@ void MACvSetKeyEntry(unsigned long dwIoBase, unsigned short wKeyCtl, unsigned in
 	wOffset += (uKeyIdx * 4);
 	for (ii = 0; ii < 4; ii++) {
 		// always push 128 bits
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "3.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "3.(%d) wOffset: %d, Data: %X\n", ii, wOffset+ii, *pdwKey);
 		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
 		VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
 		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);

commit 1208f14a37fde2669b86bf1b1cd1122ad2ba3579
Author: Teodora Baluta <teobaluta@gmail.com>
Date:   Sun Nov 10 17:12:42 2013 +0200

    staging: vt6655: delete explicit comparison to bool
    
    This patch fixes the following type of coccinelle detected warnings for
    driver vt6655:
    
    WARNING: Comparison to bool
    
    Signed-off-by: Teodora Baluta <teobaluta@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 001d15c0fa40..21bd8a1126d7 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -957,13 +957,13 @@ bool MACbSafeStop(unsigned long dwIoBase)
 {
 	MACvRegBitsOff(dwIoBase, MAC_REG_TCR, TCR_AUTOBCNTX);
 
-	if (MACbSafeRxOff(dwIoBase) == false) {
+	if (!MACbSafeRxOff(dwIoBase)) {
 		DBG_PORT80(0xA1);
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " MACbSafeRxOff == false)\n");
 		MACbSafeSoftwareReset(dwIoBase);
 		return false;
 	}
-	if (MACbSafeTxOff(dwIoBase) == false) {
+	if (!MACbSafeTxOff(dwIoBase)) {
 		DBG_PORT80(0xA2);
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " MACbSafeTxOff == false)\n");
 		MACbSafeSoftwareReset(dwIoBase);

commit 96d69e201bbdb05c363e899138f9f42bc8ad8f88
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 20:55:41 2013 -0700

    staging: vt6655: Remove unnecessary blank lines
    
    Remove a bunch of useless vertical whitespace.
    
    Convert 3 or more consecutive newlines to 2.
    Remove blank lines after open brace and before close brace.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 32bc2345e7ae..001d15c0fa40 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -86,10 +86,6 @@ static int msglevel = MSG_LEVEL_INFO;
 
 /*---------------------  Export Functions  --------------------------*/
 
-
-
-
-
 /*
  * Description:
  *      Read All MAC Registers to buffer
@@ -122,7 +118,6 @@ void MACvReadAllRegs(unsigned long dwIoBase, unsigned char *pbyMacRegs)
 	}
 
 	MACvSelectPage0(dwIoBase);
-
 }
 
 /*
@@ -608,7 +603,6 @@ void MACvSetPacketFilter(unsigned long dwIoBase, unsigned short wFilterType)
 	}
 
 	if (wFilterType & PKT_TYPE_PROMISCUOUS) {
-
 		byNewRCR |= (RCR_RXALLTYPE | RCR_UNICAST | RCR_MULTICAST | RCR_BROADCAST);
 
 		byNewRCR &= ~RCR_BSSID;
@@ -707,11 +701,9 @@ void MACvRestoreContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR));
 	VNSvOutPortD(dwIoBase + MAC_REG_BCNDMAPTR, *(unsigned long *)(pbyCxtBuf + MAC_REG_BCNDMAPTR));
 
-
 	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0));
 
 	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1));
-
 }
 
 /*
@@ -756,7 +748,6 @@ bool MACbCompareContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 		return false;
 	}
 
-
 	return true;
 }
 
@@ -790,7 +781,6 @@ bool MACbSoftwareReset(unsigned long dwIoBase)
 	if (ww == W_MAX_TIMEOUT)
 		return false;
 	return true;
-
 }
 
 /*
@@ -912,7 +902,6 @@ bool MACbSafeTxOff(unsigned long dwIoBase)
 	//AC0
 	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_CLRRUN);
 
-
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		VNSvInPortD(dwIoBase + MAC_REG_TXDMACTL0, &dwData);
 		if (!(dwData & DMACTL_RUN))
@@ -1047,12 +1036,10 @@ void MACvInitialize(unsigned long dwIoBase)
 	// enable TSF counter
 	VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
 
-
 	// set packet filter
 	// receive directed and broadcast address
 
 	MACvSetPacketFilter(dwIoBase, PKT_TYPE_DIRECTED | PKT_TYPE_BROADCAST);
-
 }
 
 /*
@@ -1209,8 +1196,6 @@ void MACvSetCurrAC0DescAddrEx(unsigned long dwIoBase, unsigned long dwCurrDescAd
 	}
 }
 
-
-
 void MACvSetCurrTXDescAddr(int iTxType, unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
 	if (iTxType == TYPE_AC0DMA) {
@@ -1253,7 +1238,6 @@ void MACvTimer0MicroSDelay(unsigned long dwIoBase, unsigned int uDelay)
 		}
 	}
 	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
-
 }
 
 /*
@@ -1298,7 +1282,6 @@ void MACvOneShotTimer1MicroSec(unsigned long dwIoBase, unsigned int uDelayTime)
 	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, (TMCTL_TMD | TMCTL_TE));
 }
 
-
 void MACvSetMISCFifo(unsigned long dwIoBase, unsigned short wOffset, unsigned long dwData)
 {
 	if (wOffset > 273)
@@ -1308,7 +1291,6 @@ void MACvSetMISCFifo(unsigned long dwIoBase, unsigned short wOffset, unsigned lo
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 }
 
-
 bool MACbTxDMAOff(unsigned long dwIoBase, unsigned int idx)
 {
 	unsigned char byData;
@@ -1455,7 +1437,6 @@ void MACvSetKeyEntry(unsigned long dwIoBase, unsigned short wKeyCtl, unsigned in
 	if (byLocalID <= 1)
 		return;
 
-
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvSetKeyEntry\n");
 	wOffset = MISCFIFO_KEYETRY0;
 	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
@@ -1496,8 +1477,6 @@ void MACvSetKeyEntry(unsigned long dwIoBase, unsigned short wKeyCtl, unsigned in
 	}
 }
 
-
-
 /*
  * Description:
  *      Disable the Key Entry by MISCFIFO
@@ -1524,7 +1503,6 @@ void MACvDisableKeyEntry(unsigned long dwIoBase, unsigned int uEntryIdx)
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 }
 
-
 /*
  * Description:
  *      Set the default Key (KeyEntry[10]) by MISCFIFO
@@ -1572,10 +1550,8 @@ void MACvSetDefaultKeyEntry(unsigned long dwIoBase, unsigned int uKeyLen,
 	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "End. wOffset: %d, Data: %lX\n", wOffset+3, dwData);
-
 }
 
-
 /*
  * Description:
  *      Enable default Key (KeyEntry[10]) by MISCFIFO
@@ -1596,7 +1572,6 @@ void MACvSetDefaultKeyEntry(unsigned long dwIoBase, unsigned int uKeyLen,
   unsigned short wOffset;
   unsigned long dwData;
 
-
   if (byLocalID <= 1)
   return;
 
@@ -1631,7 +1606,6 @@ void MACvDisableDefaultKey(unsigned long dwIoBase)
 	unsigned short wOffset;
 	unsigned long dwData;
 
-
 	wOffset = MISCFIFO_KEYETRY0;
 	wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
 
@@ -1666,7 +1640,6 @@ void MACvSetDefaultTKIPKeyEntry(unsigned long dwIoBase, unsigned int uKeyLen,
 	if (byLocalID <= 1)
 		return;
 
-
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvSetDefaultTKIPKeyEntry\n");
 	wOffset = MISCFIFO_KEYETRY0;
 	// Kyle test : change offset from 10 -> 0
@@ -1693,11 +1666,8 @@ void MACvSetDefaultTKIPKeyEntry(unsigned long dwIoBase, unsigned int uKeyLen,
 		VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
 		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 	}
-
 }
 
-
-
 /*
  * Description:
  *      Set the Key Control by MISCFIFO
@@ -1721,7 +1691,6 @@ void MACvSetDefaultKeyCtl(unsigned long dwIoBase, unsigned short wKeyCtl, unsign
 	if (byLocalID <= 1)
 		return;
 
-
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvSetKeyEntry\n");
 	wOffset = MISCFIFO_KEYETRY0;
 	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
@@ -1735,6 +1704,4 @@ void MACvSetDefaultKeyCtl(unsigned long dwIoBase, unsigned short wKeyCtl, unsign
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
 	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
 	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-
 }
-

commit a7307538805f8a30c25b6f5b9566ab21d8ab7515
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 20:55:39 2013 -0700

    staging: vt6655: Remove commented out if()s
    
    Commented out code is just noise.  Remove them.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 7dd7cc3496d1..32bc2345e7ae 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -1042,16 +1042,6 @@ void MACvInitialize(unsigned long dwIoBase)
 	// do reset
 	MACbSoftwareReset(dwIoBase);
 
-	// issue AUTOLD in EECSR to reload eeprom
-	//MACvRegBitsOn(dwIoBase, MAC_REG_I2MCSR, I2MCSR_AUTOLD);
-	// wait until EEPROM loading complete
-	//while (true) {
-	//    u8 u8Data;
-	//    VNSvInPortB(dwIoBase + MAC_REG_I2MCSR, &u8Data);
-	//    if (!(u8Data & I2MCSR_AUTOLD))
-	//        break;
-	//}
-
 	// reset TSF counter
 	VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
 	// enable TSF counter

commit a4ef27ad02e0bfd165e81d6a4f3771ace42ebe41
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 20:55:38 2013 -0700

    staging: vt6655: Remove unnecessary parentheses from returns
    
    Returns aren't functions, remove the parentheses to be
    more kernel style like.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 33e89f0319d6..7dd7cc3496d1 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -858,7 +858,7 @@ bool MACbSafeRxOff(unsigned long dwIoBase)
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x10);
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x10)\n");
-		return(false);
+		return false;
 	}
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL1, &dwData);
@@ -868,7 +868,7 @@ bool MACbSafeRxOff(unsigned long dwIoBase)
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x11);
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x11)\n");
-		return(false);
+		return false;
 	}
 
 	// try to safe shutdown RX
@@ -882,7 +882,7 @@ bool MACbSafeRxOff(unsigned long dwIoBase)
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x12);
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x12)\n");
-		return(false);
+		return false;
 	}
 	return true;
 }
@@ -921,7 +921,7 @@ bool MACbSafeTxOff(unsigned long dwIoBase)
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x20);
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x20)\n");
-		return(false);
+		return false;
 	}
 	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
 		VNSvInPortD(dwIoBase + MAC_REG_AC0DMACTL, &dwData);
@@ -931,7 +931,7 @@ bool MACbSafeTxOff(unsigned long dwIoBase)
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x21);
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x21)\n");
-		return(false);
+		return false;
 	}
 
 	// try to safe shutdown TX
@@ -946,7 +946,7 @@ bool MACbSafeTxOff(unsigned long dwIoBase)
 	if (ww == W_MAX_TIMEOUT) {
 		DBG_PORT80(0x24);
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x24)\n");
-		return(false);
+		return false;
 	}
 	return true;
 }

commit c3504bfd11f084636a7a6a1dfce318c6ce8ddbcc
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 10:44:55 2013 -0700

    staging:vt6655:mac: Whitespace cleanups
    
    Neatening only.
    git diff -w shows no differences.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 30c261579412..33e89f0319d6 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -75,7 +75,7 @@
 unsigned short TxRate_iwconfig;//2008-5-8 <add> by chester
 /*---------------------  Static Definitions -------------------------*/
 //static int          msglevel                =MSG_LEVEL_DEBUG;
-static int          msglevel                =MSG_LEVEL_INFO;
+static int msglevel = MSG_LEVEL_INFO;
 /*---------------------  Static Classes  ----------------------------*/
 
 /*---------------------  Static Variables  --------------------------*/
@@ -103,25 +103,25 @@ static int          msglevel                =MSG_LEVEL_INFO;
  * Return Value: none
  *
  */
-void MACvReadAllRegs (unsigned long dwIoBase, unsigned char *pbyMacRegs)
+void MACvReadAllRegs(unsigned long dwIoBase, unsigned char *pbyMacRegs)
 {
-    int ii;
+	int ii;
 
-    // read page0 register
-    for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE0; ii++) {
-        VNSvInPortB(dwIoBase + ii, pbyMacRegs);
-        pbyMacRegs++;
-    }
+	// read page0 register
+	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE0; ii++) {
+		VNSvInPortB(dwIoBase + ii, pbyMacRegs);
+		pbyMacRegs++;
+	}
 
-    MACvSelectPage1(dwIoBase);
+	MACvSelectPage1(dwIoBase);
 
-    // read page1 register
-    for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++) {
-        VNSvInPortB(dwIoBase + ii, pbyMacRegs);
-        pbyMacRegs++;
-    }
+	// read page1 register
+	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++) {
+		VNSvInPortB(dwIoBase + ii, pbyMacRegs);
+		pbyMacRegs++;
+	}
 
-    MACvSelectPage0(dwIoBase);
+	MACvSelectPage0(dwIoBase);
 
 }
 
@@ -140,12 +140,12 @@ void MACvReadAllRegs (unsigned long dwIoBase, unsigned char *pbyMacRegs)
  * Return Value: true if all test bits On; otherwise false
  *
  */
-bool MACbIsRegBitsOn (unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
+bool MACbIsRegBitsOn(unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
 {
-    unsigned char byData;
+	unsigned char byData;
 
-    VNSvInPortB(dwIoBase + byRegOfs, &byData);
-    return (byData & byTestBits) == byTestBits;
+	VNSvInPortB(dwIoBase + byRegOfs, &byData);
+	return (byData & byTestBits) == byTestBits;
 }
 
 /*
@@ -163,12 +163,12 @@ bool MACbIsRegBitsOn (unsigned long dwIoBase, unsigned char byRegOfs, unsigned c
  * Return Value: true if all test bits Off; otherwise false
  *
  */
-bool MACbIsRegBitsOff (unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
+bool MACbIsRegBitsOff(unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
 {
-    unsigned char byData;
+	unsigned char byData;
 
-    VNSvInPortB(dwIoBase + byRegOfs, &byData);
-    return !(byData & byTestBits);
+	VNSvInPortB(dwIoBase + byRegOfs, &byData);
+	return !(byData & byTestBits);
 }
 
 /*
@@ -184,15 +184,15 @@ bool MACbIsRegBitsOff (unsigned long dwIoBase, unsigned char byRegOfs, unsigned
  * Return Value: true if interrupt is disable; otherwise false
  *
  */
-bool MACbIsIntDisable (unsigned long dwIoBase)
+bool MACbIsIntDisable(unsigned long dwIoBase)
 {
-    unsigned long dwData;
+	unsigned long dwData;
 
-    VNSvInPortD(dwIoBase + MAC_REG_IMR, &dwData);
-    if (dwData != 0)
-        return false;
+	VNSvInPortD(dwIoBase + MAC_REG_IMR, &dwData);
+	if (dwData != 0)
+		return false;
 
-    return true;
+	return true;
 }
 
 /*
@@ -209,14 +209,14 @@ bool MACbIsIntDisable (unsigned long dwIoBase)
  * Return Value: Mask Value read
  *
  */
-unsigned char MACbyReadMultiAddr (unsigned long dwIoBase, unsigned int uByteIdx)
+unsigned char MACbyReadMultiAddr(unsigned long dwIoBase, unsigned int uByteIdx)
 {
-    unsigned char byData;
+	unsigned char byData;
 
-    MACvSelectPage1(dwIoBase);
-    VNSvInPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, &byData);
-    MACvSelectPage0(dwIoBase);
-    return byData;
+	MACvSelectPage1(dwIoBase);
+	VNSvInPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, &byData);
+	MACvSelectPage0(dwIoBase);
+	return byData;
 }
 
 /*
@@ -234,11 +234,11 @@ unsigned char MACbyReadMultiAddr (unsigned long dwIoBase, unsigned int uByteIdx)
  * Return Value: none
  *
  */
-void MACvWriteMultiAddr (unsigned long dwIoBase, unsigned int uByteIdx, unsigned char byData)
+void MACvWriteMultiAddr(unsigned long dwIoBase, unsigned int uByteIdx, unsigned char byData)
 {
-    MACvSelectPage1(dwIoBase);
-    VNSvOutPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, byData);
-    MACvSelectPage0(dwIoBase);
+	MACvSelectPage1(dwIoBase);
+	VNSvOutPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, byData);
+	MACvSelectPage0(dwIoBase);
 }
 
 /*
@@ -255,21 +255,21 @@ void MACvWriteMultiAddr (unsigned long dwIoBase, unsigned int uByteIdx, unsigned
  * Return Value: none
  *
  */
-void MACvSetMultiAddrByHash (unsigned long dwIoBase, unsigned char byHashIdx)
+void MACvSetMultiAddrByHash(unsigned long dwIoBase, unsigned char byHashIdx)
 {
-    unsigned int uByteIdx;
-    unsigned char byBitMask;
-    unsigned char byOrgValue;
-
-    // calculate byte position
-    uByteIdx = byHashIdx / 8;
-    ASSERT(uByteIdx < 8);
-    // calculate bit position
-    byBitMask = 1;
-    byBitMask <<= (byHashIdx % 8);
-    // turn on the bit
-    byOrgValue = MACbyReadMultiAddr(dwIoBase, uByteIdx);
-    MACvWriteMultiAddr(dwIoBase, uByteIdx, (unsigned char)(byOrgValue | byBitMask));
+	unsigned int uByteIdx;
+	unsigned char byBitMask;
+	unsigned char byOrgValue;
+
+	// calculate byte position
+	uByteIdx = byHashIdx / 8;
+	ASSERT(uByteIdx < 8);
+	// calculate bit position
+	byBitMask = 1;
+	byBitMask <<= (byHashIdx % 8);
+	// turn on the bit
+	byOrgValue = MACbyReadMultiAddr(dwIoBase, uByteIdx);
+	MACvWriteMultiAddr(dwIoBase, uByteIdx, (unsigned char)(byOrgValue | byBitMask));
 }
 
 /*
@@ -286,21 +286,21 @@ void MACvSetMultiAddrByHash (unsigned long dwIoBase, unsigned char byHashIdx)
  * Return Value: none
  *
  */
-void MACvResetMultiAddrByHash (unsigned long dwIoBase, unsigned char byHashIdx)
+void MACvResetMultiAddrByHash(unsigned long dwIoBase, unsigned char byHashIdx)
 {
-    unsigned int uByteIdx;
-    unsigned char byBitMask;
-    unsigned char byOrgValue;
-
-    // calculate byte position
-    uByteIdx = byHashIdx / 8;
-    ASSERT(uByteIdx < 8);
-    // calculate bit position
-    byBitMask = 1;
-    byBitMask <<= (byHashIdx % 8);
-    // turn off the bit
-    byOrgValue = MACbyReadMultiAddr(dwIoBase, uByteIdx);
-    MACvWriteMultiAddr(dwIoBase, uByteIdx, (unsigned char)(byOrgValue & (~byBitMask)));
+	unsigned int uByteIdx;
+	unsigned char byBitMask;
+	unsigned char byOrgValue;
+
+	// calculate byte position
+	uByteIdx = byHashIdx / 8;
+	ASSERT(uByteIdx < 8);
+	// calculate bit position
+	byBitMask = 1;
+	byBitMask <<= (byHashIdx % 8);
+	// turn off the bit
+	byOrgValue = MACbyReadMultiAddr(dwIoBase, uByteIdx);
+	MACvWriteMultiAddr(dwIoBase, uByteIdx, (unsigned char)(byOrgValue & (~byBitMask)));
 }
 
 /*
@@ -317,16 +317,16 @@ void MACvResetMultiAddrByHash (unsigned long dwIoBase, unsigned char byHashIdx)
  * Return Value: none
  *
  */
-void MACvSetRxThreshold (unsigned long dwIoBase, unsigned char byThreshold)
+void MACvSetRxThreshold(unsigned long dwIoBase, unsigned char byThreshold)
 {
-    unsigned char byOrgValue;
+	unsigned char byOrgValue;
 
-    ASSERT(byThreshold < 4);
+	ASSERT(byThreshold < 4);
 
-    // set FCR0
-    VNSvInPortB(dwIoBase + MAC_REG_FCR0, &byOrgValue);
-    byOrgValue = (byOrgValue & 0xCF) | (byThreshold << 4);
-    VNSvOutPortB(dwIoBase + MAC_REG_FCR0, byOrgValue);
+	// set FCR0
+	VNSvInPortB(dwIoBase + MAC_REG_FCR0, &byOrgValue);
+	byOrgValue = (byOrgValue & 0xCF) | (byThreshold << 4);
+	VNSvOutPortB(dwIoBase + MAC_REG_FCR0, byOrgValue);
 }
 
 /*
@@ -342,11 +342,11 @@ void MACvSetRxThreshold (unsigned long dwIoBase, unsigned char byThreshold)
  * Return Value: none
  *
  */
-void MACvGetRxThreshold (unsigned long dwIoBase, unsigned char *pbyThreshold)
+void MACvGetRxThreshold(unsigned long dwIoBase, unsigned char *pbyThreshold)
 {
-    // get FCR0
-    VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
-    *pbyThreshold = (*pbyThreshold >> 4) & 0x03;
+	// get FCR0
+	VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
+	*pbyThreshold = (*pbyThreshold >> 4) & 0x03;
 }
 
 /*
@@ -363,16 +363,16 @@ void MACvGetRxThreshold (unsigned long dwIoBase, unsigned char *pbyThreshold)
  * Return Value: none
  *
  */
-void MACvSetTxThreshold (unsigned long dwIoBase, unsigned char byThreshold)
+void MACvSetTxThreshold(unsigned long dwIoBase, unsigned char byThreshold)
 {
-    unsigned char byOrgValue;
+	unsigned char byOrgValue;
 
-    ASSERT(byThreshold < 4);
+	ASSERT(byThreshold < 4);
 
-    // set FCR0
-    VNSvInPortB(dwIoBase + MAC_REG_FCR0, &byOrgValue);
-    byOrgValue = (byOrgValue & 0xF3) | (byThreshold << 2);
-    VNSvOutPortB(dwIoBase + MAC_REG_FCR0, byOrgValue);
+	// set FCR0
+	VNSvInPortB(dwIoBase + MAC_REG_FCR0, &byOrgValue);
+	byOrgValue = (byOrgValue & 0xF3) | (byThreshold << 2);
+	VNSvOutPortB(dwIoBase + MAC_REG_FCR0, byOrgValue);
 }
 
 /*
@@ -388,11 +388,11 @@ void MACvSetTxThreshold (unsigned long dwIoBase, unsigned char byThreshold)
  * Return Value: none
  *
  */
-void MACvGetTxThreshold (unsigned long dwIoBase, unsigned char *pbyThreshold)
+void MACvGetTxThreshold(unsigned long dwIoBase, unsigned char *pbyThreshold)
 {
-    // get FCR0
-    VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
-    *pbyThreshold = (*pbyThreshold >> 2) & 0x03;
+	// get FCR0
+	VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
+	*pbyThreshold = (*pbyThreshold >> 2) & 0x03;
 }
 
 /*
@@ -409,16 +409,16 @@ void MACvGetTxThreshold (unsigned long dwIoBase, unsigned char *pbyThreshold)
  * Return Value: none
  *
  */
-void MACvSetDmaLength (unsigned long dwIoBase, unsigned char byDmaLength)
+void MACvSetDmaLength(unsigned long dwIoBase, unsigned char byDmaLength)
 {
-    unsigned char byOrgValue;
+	unsigned char byOrgValue;
 
-    ASSERT(byDmaLength < 4);
+	ASSERT(byDmaLength < 4);
 
-    // set FCR0
-    VNSvInPortB(dwIoBase + MAC_REG_FCR0, &byOrgValue);
-    byOrgValue = (byOrgValue & 0xFC) | byDmaLength;
-    VNSvOutPortB(dwIoBase + MAC_REG_FCR0, byOrgValue);
+	// set FCR0
+	VNSvInPortB(dwIoBase + MAC_REG_FCR0, &byOrgValue);
+	byOrgValue = (byOrgValue & 0xFC) | byDmaLength;
+	VNSvOutPortB(dwIoBase + MAC_REG_FCR0, byOrgValue);
 }
 
 /*
@@ -434,11 +434,11 @@ void MACvSetDmaLength (unsigned long dwIoBase, unsigned char byDmaLength)
  * Return Value: none
  *
  */
-void MACvGetDmaLength (unsigned long dwIoBase, unsigned char *pbyDmaLength)
+void MACvGetDmaLength(unsigned long dwIoBase, unsigned char *pbyDmaLength)
 {
-    // get FCR0
-    VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyDmaLength);
-    *pbyDmaLength &= 0x03;
+	// get FCR0
+	VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyDmaLength);
+	*pbyDmaLength &= 0x03;
 }
 
 /*
@@ -455,10 +455,10 @@ void MACvGetDmaLength (unsigned long dwIoBase, unsigned char *pbyDmaLength)
  * Return Value: none
  *
  */
-void MACvSetShortRetryLimit (unsigned long dwIoBase, unsigned char byRetryLimit)
+void MACvSetShortRetryLimit(unsigned long dwIoBase, unsigned char byRetryLimit)
 {
-    // set SRT
-    VNSvOutPortB(dwIoBase + MAC_REG_SRT, byRetryLimit);
+	// set SRT
+	VNSvOutPortB(dwIoBase + MAC_REG_SRT, byRetryLimit);
 }
 
 /*
@@ -474,10 +474,10 @@ void MACvSetShortRetryLimit (unsigned long dwIoBase, unsigned char byRetryLimit)
  * Return Value: none
  *
  */
-void MACvGetShortRetryLimit (unsigned long dwIoBase, unsigned char *pbyRetryLimit)
+void MACvGetShortRetryLimit(unsigned long dwIoBase, unsigned char *pbyRetryLimit)
 {
-    // get SRT
-    VNSvInPortB(dwIoBase + MAC_REG_SRT, pbyRetryLimit);
+	// get SRT
+	VNSvInPortB(dwIoBase + MAC_REG_SRT, pbyRetryLimit);
 }
 
 /*
@@ -494,10 +494,10 @@ void MACvGetShortRetryLimit (unsigned long dwIoBase, unsigned char *pbyRetryLimi
  * Return Value: none
  *
  */
-void MACvSetLongRetryLimit (unsigned long dwIoBase, unsigned char byRetryLimit)
+void MACvSetLongRetryLimit(unsigned long dwIoBase, unsigned char byRetryLimit)
 {
-    // set LRT
-    VNSvOutPortB(dwIoBase + MAC_REG_LRT, byRetryLimit);
+	// set LRT
+	VNSvOutPortB(dwIoBase + MAC_REG_LRT, byRetryLimit);
 }
 
 /*
@@ -513,10 +513,10 @@ void MACvSetLongRetryLimit (unsigned long dwIoBase, unsigned char byRetryLimit)
  * Return Value: none
  *
  */
-void MACvGetLongRetryLimit (unsigned long dwIoBase, unsigned char *pbyRetryLimit)
+void MACvGetLongRetryLimit(unsigned long dwIoBase, unsigned char *pbyRetryLimit)
 {
-    // get LRT
-    VNSvInPortB(dwIoBase + MAC_REG_LRT, pbyRetryLimit);
+	// get LRT
+	VNSvInPortB(dwIoBase + MAC_REG_LRT, pbyRetryLimit);
 }
 
 /*
@@ -533,17 +533,17 @@ void MACvGetLongRetryLimit (unsigned long dwIoBase, unsigned char *pbyRetryLimit
  * Return Value: none
  *
  */
-void MACvSetLoopbackMode (unsigned long dwIoBase, unsigned char byLoopbackMode)
+void MACvSetLoopbackMode(unsigned long dwIoBase, unsigned char byLoopbackMode)
 {
-    unsigned char byOrgValue;
-
-    ASSERT(byLoopbackMode < 3);
-    byLoopbackMode <<= 6;
-    // set TCR
-    VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
-    byOrgValue = byOrgValue & 0x3F;
-    byOrgValue = byOrgValue | byLoopbackMode;
-    VNSvOutPortB(dwIoBase + MAC_REG_TEST, byOrgValue);
+	unsigned char byOrgValue;
+
+	ASSERT(byLoopbackMode < 3);
+	byLoopbackMode <<= 6;
+	// set TCR
+	VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
+	byOrgValue = byOrgValue & 0x3F;
+	byOrgValue = byOrgValue | byLoopbackMode;
+	VNSvOutPortB(dwIoBase + MAC_REG_TEST, byOrgValue);
 }
 
 /*
@@ -559,14 +559,14 @@ void MACvSetLoopbackMode (unsigned long dwIoBase, unsigned char byLoopbackMode)
  * Return Value: true if in Loopback mode; otherwise false
  *
  */
-bool MACbIsInLoopbackMode (unsigned long dwIoBase)
+bool MACbIsInLoopbackMode(unsigned long dwIoBase)
 {
-    unsigned char byOrgValue;
+	unsigned char byOrgValue;
 
-    VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
-    if (byOrgValue & (TEST_LBINT | TEST_LBEXT))
-        return true;
-    return false;
+	VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
+	if (byOrgValue & (TEST_LBINT | TEST_LBEXT))
+		return true;
+	return false;
 }
 
 /*
@@ -583,51 +583,51 @@ bool MACbIsInLoopbackMode (unsigned long dwIoBase)
  * Return Value: none
  *
  */
-void MACvSetPacketFilter (unsigned long dwIoBase, unsigned short wFilterType)
+void MACvSetPacketFilter(unsigned long dwIoBase, unsigned short wFilterType)
 {
-    unsigned char byOldRCR;
-    unsigned char byNewRCR = 0;
-
-    // if only in DIRECTED mode, multicast-address will set to zero,
-    // but if other mode exist (e.g. PROMISCUOUS), multicast-address
-    // will be open
-    if (wFilterType & PKT_TYPE_DIRECTED) {
-        // set multicast address to accept none
-        MACvSelectPage1(dwIoBase);
-        VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0L);
-        VNSvOutPortD(dwIoBase + MAC_REG_MAR0 + sizeof(unsigned long), 0L);
-        MACvSelectPage0(dwIoBase);
-    }
-
-    if (wFilterType & (PKT_TYPE_PROMISCUOUS | PKT_TYPE_ALL_MULTICAST)) {
-        // set multicast address to accept all
-        MACvSelectPage1(dwIoBase);
-        VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0xFFFFFFFFL);
-        VNSvOutPortD(dwIoBase + MAC_REG_MAR0 + sizeof(unsigned long), 0xFFFFFFFFL);
-        MACvSelectPage0(dwIoBase);
-    }
-
-    if (wFilterType & PKT_TYPE_PROMISCUOUS) {
-
-        byNewRCR |= (RCR_RXALLTYPE | RCR_UNICAST | RCR_MULTICAST | RCR_BROADCAST);
-
-        byNewRCR &= ~RCR_BSSID;
-    }
-
-    if (wFilterType & (PKT_TYPE_ALL_MULTICAST | PKT_TYPE_MULTICAST))
-        byNewRCR |= RCR_MULTICAST;
-
-    if (wFilterType & PKT_TYPE_BROADCAST)
-        byNewRCR |= RCR_BROADCAST;
-
-    if (wFilterType & PKT_TYPE_ERROR_CRC)
-        byNewRCR |= RCR_ERRCRC;
-
-    VNSvInPortB(dwIoBase + MAC_REG_RCR,  &byOldRCR);
-    if (byNewRCR != byOldRCR) {
-        // Modify the Receive Command Register
-        VNSvOutPortB(dwIoBase + MAC_REG_RCR, byNewRCR);
-    }
+	unsigned char byOldRCR;
+	unsigned char byNewRCR = 0;
+
+	// if only in DIRECTED mode, multicast-address will set to zero,
+	// but if other mode exist (e.g. PROMISCUOUS), multicast-address
+	// will be open
+	if (wFilterType & PKT_TYPE_DIRECTED) {
+		// set multicast address to accept none
+		MACvSelectPage1(dwIoBase);
+		VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0L);
+		VNSvOutPortD(dwIoBase + MAC_REG_MAR0 + sizeof(unsigned long), 0L);
+		MACvSelectPage0(dwIoBase);
+	}
+
+	if (wFilterType & (PKT_TYPE_PROMISCUOUS | PKT_TYPE_ALL_MULTICAST)) {
+		// set multicast address to accept all
+		MACvSelectPage1(dwIoBase);
+		VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0xFFFFFFFFL);
+		VNSvOutPortD(dwIoBase + MAC_REG_MAR0 + sizeof(unsigned long), 0xFFFFFFFFL);
+		MACvSelectPage0(dwIoBase);
+	}
+
+	if (wFilterType & PKT_TYPE_PROMISCUOUS) {
+
+		byNewRCR |= (RCR_RXALLTYPE | RCR_UNICAST | RCR_MULTICAST | RCR_BROADCAST);
+
+		byNewRCR &= ~RCR_BSSID;
+	}
+
+	if (wFilterType & (PKT_TYPE_ALL_MULTICAST | PKT_TYPE_MULTICAST))
+		byNewRCR |= RCR_MULTICAST;
+
+	if (wFilterType & PKT_TYPE_BROADCAST)
+		byNewRCR |= RCR_BROADCAST;
+
+	if (wFilterType & PKT_TYPE_ERROR_CRC)
+		byNewRCR |= RCR_ERRCRC;
+
+	VNSvInPortB(dwIoBase + MAC_REG_RCR,  &byOldRCR);
+	if (byNewRCR != byOldRCR) {
+		// Modify the Receive Command Register
+		VNSvOutPortB(dwIoBase + MAC_REG_RCR, byNewRCR);
+	}
 }
 
 /*
@@ -643,23 +643,23 @@ void MACvSetPacketFilter (unsigned long dwIoBase, unsigned short wFilterType)
  * Return Value: none
  *
  */
-void MACvSaveContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
+void MACvSaveContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 {
-    int         ii;
+	int         ii;
 
-    // read page0 register
-    for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE0; ii++) {
-        VNSvInPortB((dwIoBase + ii), (pbyCxtBuf + ii));
-    }
+	// read page0 register
+	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE0; ii++) {
+		VNSvInPortB((dwIoBase + ii), (pbyCxtBuf + ii));
+	}
 
-    MACvSelectPage1(dwIoBase);
+	MACvSelectPage1(dwIoBase);
 
-    // read page1 register
-    for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++) {
-        VNSvInPortB((dwIoBase + ii), (pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
-    }
+	// read page1 register
+	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++) {
+		VNSvInPortB((dwIoBase + ii), (pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
+	}
 
-    MACvSelectPage0(dwIoBase);
+	MACvSelectPage0(dwIoBase);
 }
 
 /*
@@ -676,41 +676,41 @@ void MACvSaveContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: none
  *
  */
-void MACvRestoreContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
+void MACvRestoreContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 {
-    int         ii;
+	int         ii;
 
-    MACvSelectPage1(dwIoBase);
-    // restore page1
-    for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++) {
-        VNSvOutPortB((dwIoBase + ii), *(pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
-    }
-    MACvSelectPage0(dwIoBase);
+	MACvSelectPage1(dwIoBase);
+	// restore page1
+	for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++) {
+		VNSvOutPortB((dwIoBase + ii), *(pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
+	}
+	MACvSelectPage0(dwIoBase);
 
-    // restore RCR,TCR,IMR...
-    for (ii = MAC_REG_RCR; ii < MAC_REG_ISR; ii++) {
-        VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
-    }
-    // restore MAC Config.
-    for (ii = MAC_REG_LRT; ii < MAC_REG_PAGE1SEL; ii++) {
-        VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
-    }
-    VNSvOutPortB(dwIoBase + MAC_REG_CFG, *(pbyCxtBuf + MAC_REG_CFG));
+	// restore RCR,TCR,IMR...
+	for (ii = MAC_REG_RCR; ii < MAC_REG_ISR; ii++) {
+		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
+	}
+	// restore MAC Config.
+	for (ii = MAC_REG_LRT; ii < MAC_REG_PAGE1SEL; ii++) {
+		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
+	}
+	VNSvOutPortB(dwIoBase + MAC_REG_CFG, *(pbyCxtBuf + MAC_REG_CFG));
 
-    // restore PS Config.
-    for (ii = MAC_REG_PSCFG; ii < MAC_REG_BBREGCTL; ii++) {
-        VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
-    }
+	// restore PS Config.
+	for (ii = MAC_REG_PSCFG; ii < MAC_REG_BBREGCTL; ii++) {
+		VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
+	}
 
-    // restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
-    VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0));
-    VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR));
-    VNSvOutPortD(dwIoBase + MAC_REG_BCNDMAPTR, *(unsigned long *)(pbyCxtBuf + MAC_REG_BCNDMAPTR));
+	// restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
+	VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0));
+	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR));
+	VNSvOutPortD(dwIoBase + MAC_REG_BCNDMAPTR, *(unsigned long *)(pbyCxtBuf + MAC_REG_BCNDMAPTR));
 
 
-    VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0));
+	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0));
 
-    VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1));
+	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1));
 
 }
 
@@ -728,36 +728,36 @@ void MACvRestoreContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: true if all values are the same; otherwise false
  *
  */
-bool MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
+bool MACbCompareContext(unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 {
-    unsigned long dwData;
+	unsigned long dwData;
 
-    // compare MAC context to determine if this is a power lost init,
-    // return true for power remaining init, return false for power lost init
+	// compare MAC context to determine if this is a power lost init,
+	// return true for power remaining init, return false for power lost init
 
-    // compare CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
-    VNSvInPortD(dwIoBase + MAC_REG_TXDMAPTR0, &dwData);
-    if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0)) {
-        return false;
-    }
+	// compare CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
+	VNSvInPortD(dwIoBase + MAC_REG_TXDMAPTR0, &dwData);
+	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0)) {
+		return false;
+	}
 
-    VNSvInPortD(dwIoBase + MAC_REG_AC0DMAPTR, &dwData);
-    if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR)) {
-        return false;
-    }
+	VNSvInPortD(dwIoBase + MAC_REG_AC0DMAPTR, &dwData);
+	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR)) {
+		return false;
+	}
 
-    VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR0, &dwData);
-    if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0)) {
-        return false;
-    }
+	VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR0, &dwData);
+	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0)) {
+		return false;
+	}
 
-    VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR1, &dwData);
-    if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1)) {
-        return false;
-    }
+	VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR1, &dwData);
+	if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1)) {
+		return false;
+	}
 
 
-    return true;
+	return true;
 }
 
 /*
@@ -773,23 +773,23 @@ bool MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: true if Reset Success; otherwise false
  *
  */
-bool MACbSoftwareReset (unsigned long dwIoBase)
+bool MACbSoftwareReset(unsigned long dwIoBase)
 {
-    unsigned char byData;
-    unsigned short ww;
-
-    // turn on HOSTCR_SOFTRST, just write 0x01 to reset
-    //MACvRegBitsOn(dwIoBase, MAC_REG_HOSTCR, HOSTCR_SOFTRST);
-    VNSvOutPortB(dwIoBase+ MAC_REG_HOSTCR, 0x01);
-
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
-        if ( !(byData & HOSTCR_SOFTRST))
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT)
-        return false;
-    return true;
+	unsigned char byData;
+	unsigned short ww;
+
+	// turn on HOSTCR_SOFTRST, just write 0x01 to reset
+	//MACvRegBitsOn(dwIoBase, MAC_REG_HOSTCR, HOSTCR_SOFTRST);
+	VNSvOutPortB(dwIoBase + MAC_REG_HOSTCR, 0x01);
+
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
+		if (!(byData & HOSTCR_SOFTRST))
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT)
+		return false;
+	return true;
 
 }
 
@@ -806,24 +806,24 @@ bool MACbSoftwareReset (unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbSafeSoftwareReset (unsigned long dwIoBase)
+bool MACbSafeSoftwareReset(unsigned long dwIoBase)
 {
-    unsigned char abyTmpRegData[MAC_MAX_CONTEXT_SIZE_PAGE0+MAC_MAX_CONTEXT_SIZE_PAGE1];
-    bool bRetVal;
-
-    // PATCH....
-    // save some important register's value, then do
-    // reset, then restore register's value
-
-    // save MAC context
-    MACvSaveContext(dwIoBase, abyTmpRegData);
-    // do reset
-    bRetVal = MACbSoftwareReset(dwIoBase);
-    //BBvSoftwareReset(pDevice->PortOffset);
-    // restore MAC context, except CR0
-    MACvRestoreContext(dwIoBase, abyTmpRegData);
-
-    return bRetVal;
+	unsigned char abyTmpRegData[MAC_MAX_CONTEXT_SIZE_PAGE0+MAC_MAX_CONTEXT_SIZE_PAGE1];
+	bool bRetVal;
+
+	// PATCH....
+	// save some important register's value, then do
+	// reset, then restore register's value
+
+	// save MAC context
+	MACvSaveContext(dwIoBase, abyTmpRegData);
+	// do reset
+	bRetVal = MACbSoftwareReset(dwIoBase);
+	//BBvSoftwareReset(pDevice->PortOffset);
+	// restore MAC context, except CR0
+	MACvRestoreContext(dwIoBase, abyTmpRegData);
+
+	return bRetVal;
 }
 
 /*
@@ -839,52 +839,52 @@ bool MACbSafeSoftwareReset (unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbSafeRxOff (unsigned long dwIoBase)
+bool MACbSafeRxOff(unsigned long dwIoBase)
 {
-    unsigned short ww;
-    unsigned long dwData;
-    unsigned char byData;
-
-    // turn off wow temp for turn off Rx safely
-
-    // Clear RX DMA0,1
-    VNSvOutPortD(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_CLRRUN);
-    VNSvOutPortD(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_CLRRUN);
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL0, &dwData);
-        if (!(dwData & DMACTL_RUN))
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x10);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x10)\n");
-        return(false);
-    }
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL1, &dwData);
-        if ( !(dwData & DMACTL_RUN))
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x11);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x11)\n");
-        return(false);
-    }
-
-    // try to safe shutdown RX
-    MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_RXON);
-    // W_MAX_TIMEOUT is the timeout period
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
-        if ( !(byData & HOSTCR_RXONST))
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x12);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x12)\n");
-        return(false);
-    }
-    return true;
+	unsigned short ww;
+	unsigned long dwData;
+	unsigned char byData;
+
+	// turn off wow temp for turn off Rx safely
+
+	// Clear RX DMA0,1
+	VNSvOutPortD(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_CLRRUN);
+	VNSvOutPortD(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_CLRRUN);
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL0, &dwData);
+		if (!(dwData & DMACTL_RUN))
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x10);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x10)\n");
+		return(false);
+	}
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL1, &dwData);
+		if (!(dwData & DMACTL_RUN))
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x11);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x11)\n");
+		return(false);
+	}
+
+	// try to safe shutdown RX
+	MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_RXON);
+	// W_MAX_TIMEOUT is the timeout period
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
+		if (!(byData & HOSTCR_RXONST))
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x12);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x12)\n");
+		return(false);
+	}
+	return true;
 }
 
 /*
@@ -900,55 +900,55 @@ bool MACbSafeRxOff (unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbSafeTxOff (unsigned long dwIoBase)
+bool MACbSafeTxOff(unsigned long dwIoBase)
 {
-    unsigned short ww;
-    unsigned long dwData;
-    unsigned char byData;
-
-    // Clear TX DMA
-    //Tx0
-    VNSvOutPortD(dwIoBase + MAC_REG_TXDMACTL0, DMACTL_CLRRUN);
-    //AC0
-    VNSvOutPortD(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_CLRRUN);
-
-
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortD(dwIoBase + MAC_REG_TXDMACTL0, &dwData);
-        if ( !(dwData & DMACTL_RUN))
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x20);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x20)\n");
-        return(false);
-    }
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortD(dwIoBase + MAC_REG_AC0DMACTL, &dwData);
-        if ( !(dwData & DMACTL_RUN))
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x21);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x21)\n");
-        return(false);
-    }
-
-    // try to safe shutdown TX
-    MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_TXON);
-
-    // W_MAX_TIMEOUT is the timeout period
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
-        if ( !(byData & HOSTCR_TXONST))
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x24);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x24)\n");
-        return(false);
-    }
-    return true;
+	unsigned short ww;
+	unsigned long dwData;
+	unsigned char byData;
+
+	// Clear TX DMA
+	//Tx0
+	VNSvOutPortD(dwIoBase + MAC_REG_TXDMACTL0, DMACTL_CLRRUN);
+	//AC0
+	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_CLRRUN);
+
+
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortD(dwIoBase + MAC_REG_TXDMACTL0, &dwData);
+		if (!(dwData & DMACTL_RUN))
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x20);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x20)\n");
+		return(false);
+	}
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortD(dwIoBase + MAC_REG_AC0DMACTL, &dwData);
+		if (!(dwData & DMACTL_RUN))
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x21);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x21)\n");
+		return(false);
+	}
+
+	// try to safe shutdown TX
+	MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_TXON);
+
+	// W_MAX_TIMEOUT is the timeout period
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
+		if (!(byData & HOSTCR_TXONST))
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x24);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x24)\n");
+		return(false);
+	}
+	return true;
 }
 
 /*
@@ -964,26 +964,26 @@ bool MACbSafeTxOff (unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbSafeStop (unsigned long dwIoBase)
+bool MACbSafeStop(unsigned long dwIoBase)
 {
-    MACvRegBitsOff(dwIoBase, MAC_REG_TCR, TCR_AUTOBCNTX);
-
-    if (MACbSafeRxOff(dwIoBase) == false) {
-        DBG_PORT80(0xA1);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" MACbSafeRxOff == false)\n");
-        MACbSafeSoftwareReset(dwIoBase);
-        return false;
-    }
-    if (MACbSafeTxOff(dwIoBase) == false) {
-        DBG_PORT80(0xA2);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" MACbSafeTxOff == false)\n");
-        MACbSafeSoftwareReset(dwIoBase);
-        return false;
-    }
-
-    MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_MACEN);
-
-    return true;
+	MACvRegBitsOff(dwIoBase, MAC_REG_TCR, TCR_AUTOBCNTX);
+
+	if (MACbSafeRxOff(dwIoBase) == false) {
+		DBG_PORT80(0xA1);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " MACbSafeRxOff == false)\n");
+		MACbSafeSoftwareReset(dwIoBase);
+		return false;
+	}
+	if (MACbSafeTxOff(dwIoBase) == false) {
+		DBG_PORT80(0xA2);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " MACbSafeTxOff == false)\n");
+		MACbSafeSoftwareReset(dwIoBase);
+		return false;
+	}
+
+	MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_MACEN);
+
+	return true;
 }
 
 /*
@@ -999,18 +999,18 @@ bool MACbSafeStop (unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-bool MACbShutdown (unsigned long dwIoBase)
+bool MACbShutdown(unsigned long dwIoBase)
 {
-    // disable MAC IMR
-    MACvIntDisable(dwIoBase);
-    MACvSetLoopbackMode(dwIoBase, MAC_LB_INTERNAL);
-    // stop the adapter
-    if (!MACbSafeStop(dwIoBase)) {
-        MACvSetLoopbackMode(dwIoBase, MAC_LB_NONE);
-        return false;
-    }
-    MACvSetLoopbackMode(dwIoBase, MAC_LB_NONE);
-    return true;
+	// disable MAC IMR
+	MACvIntDisable(dwIoBase);
+	MACvSetLoopbackMode(dwIoBase, MAC_LB_INTERNAL);
+	// stop the adapter
+	if (!MACbSafeStop(dwIoBase)) {
+		MACvSetLoopbackMode(dwIoBase, MAC_LB_NONE);
+		return false;
+	}
+	MACvSetLoopbackMode(dwIoBase, MAC_LB_NONE);
+	return true;
 }
 
 /*
@@ -1026,42 +1026,42 @@ bool MACbShutdown (unsigned long dwIoBase)
  * Return Value: none
  *
  */
-void MACvInitialize (unsigned long dwIoBase)
+void MACvInitialize(unsigned long dwIoBase)
 {
-    // clear sticky bits
-    MACvClearStckDS(dwIoBase);
-    // disable force PME-enable
-    VNSvOutPortB(dwIoBase + MAC_REG_PMC1, PME_OVR);
-    // only 3253 A
-    /*
-    MACvPwrEvntDisable(dwIoBase);
-    // clear power status
-    VNSvOutPortW(dwIoBase + MAC_REG_WAKEUPSR0, 0x0F0F);
-    */
-
-    // do reset
-    MACbSoftwareReset(dwIoBase);
-
-    // issue AUTOLD in EECSR to reload eeprom
-    //MACvRegBitsOn(dwIoBase, MAC_REG_I2MCSR, I2MCSR_AUTOLD);
-    // wait until EEPROM loading complete
-    //while (true) {
-    //    u8 u8Data;
-    //    VNSvInPortB(dwIoBase + MAC_REG_I2MCSR, &u8Data);
-    //    if ( !(u8Data & I2MCSR_AUTOLD))
-    //        break;
-    //}
-
-    // reset TSF counter
-    VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
-    // enable TSF counter
-    VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
-
-
-    // set packet filter
-    // receive directed and broadcast address
-
-    MACvSetPacketFilter(dwIoBase, PKT_TYPE_DIRECTED | PKT_TYPE_BROADCAST);
+	// clear sticky bits
+	MACvClearStckDS(dwIoBase);
+	// disable force PME-enable
+	VNSvOutPortB(dwIoBase + MAC_REG_PMC1, PME_OVR);
+	// only 3253 A
+	/*
+	  MACvPwrEvntDisable(dwIoBase);
+	  // clear power status
+	  VNSvOutPortW(dwIoBase + MAC_REG_WAKEUPSR0, 0x0F0F);
+	*/
+
+	// do reset
+	MACbSoftwareReset(dwIoBase);
+
+	// issue AUTOLD in EECSR to reload eeprom
+	//MACvRegBitsOn(dwIoBase, MAC_REG_I2MCSR, I2MCSR_AUTOLD);
+	// wait until EEPROM loading complete
+	//while (true) {
+	//    u8 u8Data;
+	//    VNSvInPortB(dwIoBase + MAC_REG_I2MCSR, &u8Data);
+	//    if (!(u8Data & I2MCSR_AUTOLD))
+	//        break;
+	//}
+
+	// reset TSF counter
+	VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
+	// enable TSF counter
+	VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
+
+
+	// set packet filter
+	// receive directed and broadcast address
+
+	MACvSetPacketFilter(dwIoBase, PKT_TYPE_DIRECTED | PKT_TYPE_BROADCAST);
 
 }
 
@@ -1079,28 +1079,28 @@ void MACvInitialize (unsigned long dwIoBase)
  * Return Value: none
  *
  */
-void MACvSetCurrRx0DescAddr (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrRx0DescAddr(unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
-unsigned short ww;
-unsigned char byData;
-unsigned char byOrgDMACtl;
-
-    VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byOrgDMACtl);
-    if (byOrgDMACtl & DMACTL_RUN) {
-        VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0+2, DMACTL_RUN);
-    }
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byData);
-        if ( !(byData & DMACTL_RUN))
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x13);
-    }
-    VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, dwCurrDescAddr);
-    if (byOrgDMACtl & DMACTL_RUN) {
-        VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_RUN);
-    }
+	unsigned short ww;
+	unsigned char byData;
+	unsigned char byOrgDMACtl;
+
+	VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byOrgDMACtl);
+	if (byOrgDMACtl & DMACTL_RUN) {
+		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0+2, DMACTL_RUN);
+	}
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byData);
+		if (!(byData & DMACTL_RUN))
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x13);
+	}
+	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, dwCurrDescAddr);
+	if (byOrgDMACtl & DMACTL_RUN) {
+		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_RUN);
+	}
 }
 
 /*
@@ -1117,28 +1117,28 @@ unsigned char byOrgDMACtl;
  * Return Value: none
  *
  */
-void MACvSetCurrRx1DescAddr (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrRx1DescAddr(unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
-unsigned short ww;
-unsigned char byData;
-unsigned char byOrgDMACtl;
-
-    VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byOrgDMACtl);
-    if (byOrgDMACtl & DMACTL_RUN) {
-        VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1+2, DMACTL_RUN);
-    }
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byData);
-        if ( !(byData & DMACTL_RUN))
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x14);
-    }
-    VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, dwCurrDescAddr);
-    if (byOrgDMACtl & DMACTL_RUN) {
-        VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_RUN);
-    }
+	unsigned short ww;
+	unsigned char byData;
+	unsigned char byOrgDMACtl;
+
+	VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byOrgDMACtl);
+	if (byOrgDMACtl & DMACTL_RUN) {
+		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1+2, DMACTL_RUN);
+	}
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byData);
+		if (!(byData & DMACTL_RUN))
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x14);
+	}
+	VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, dwCurrDescAddr);
+	if (byOrgDMACtl & DMACTL_RUN) {
+		VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_RUN);
+	}
 }
 
 /*
@@ -1155,28 +1155,28 @@ unsigned char byOrgDMACtl;
  * Return Value: none
  *
  */
-void MACvSetCurrTx0DescAddrEx (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrTx0DescAddrEx(unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
-unsigned short ww;
-unsigned char byData;
-unsigned char byOrgDMACtl;
-
-    VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byOrgDMACtl);
-    if (byOrgDMACtl & DMACTL_RUN) {
-        VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
-    }
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
-        if ( !(byData & DMACTL_RUN))
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x25);
-    }
-    VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, dwCurrDescAddr);
-    if (byOrgDMACtl & DMACTL_RUN) {
-        VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0, DMACTL_RUN);
-    }
+	unsigned short ww;
+	unsigned char byData;
+	unsigned char byOrgDMACtl;
+
+	VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byOrgDMACtl);
+	if (byOrgDMACtl & DMACTL_RUN) {
+		VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
+	}
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
+		if (!(byData & DMACTL_RUN))
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x25);
+	}
+	VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, dwCurrDescAddr);
+	if (byOrgDMACtl & DMACTL_RUN) {
+		VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0, DMACTL_RUN);
+	}
 }
 
 /*
@@ -1193,41 +1193,41 @@ unsigned char byOrgDMACtl;
  * Return Value: none
  *
  */
- //TxDMA1 = AC0DMA
-void MACvSetCurrAC0DescAddrEx (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
+//TxDMA1 = AC0DMA
+void MACvSetCurrAC0DescAddrEx(unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
-unsigned short ww;
-unsigned char byData;
-unsigned char byOrgDMACtl;
-
-    VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byOrgDMACtl);
-    if (byOrgDMACtl & DMACTL_RUN) {
-        VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
-    }
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
-        if (!(byData & DMACTL_RUN))
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x26);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x26)\n");
-    }
-    VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
-    if (byOrgDMACtl & DMACTL_RUN) {
-        VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_RUN);
-    }
+	unsigned short ww;
+	unsigned char byData;
+	unsigned char byOrgDMACtl;
+
+	VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byOrgDMACtl);
+	if (byOrgDMACtl & DMACTL_RUN) {
+		VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
+	}
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
+		if (!(byData & DMACTL_RUN))
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x26);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x26)\n");
+	}
+	VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
+	if (byOrgDMACtl & DMACTL_RUN) {
+		VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_RUN);
+	}
 }
 
 
 
-void MACvSetCurrTXDescAddr (int iTxType, unsigned long dwIoBase, unsigned long dwCurrDescAddr)
+void MACvSetCurrTXDescAddr(int iTxType, unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
-    if(iTxType == TYPE_AC0DMA){
-        MACvSetCurrAC0DescAddrEx(dwIoBase, dwCurrDescAddr);
-    }else if(iTxType == TYPE_TXDMA0){
-        MACvSetCurrTx0DescAddrEx(dwIoBase, dwCurrDescAddr);
-    }
+	if (iTxType == TYPE_AC0DMA) {
+		MACvSetCurrAC0DescAddrEx(dwIoBase, dwCurrDescAddr);
+	} else if (iTxType == TYPE_TXDMA0) {
+		MACvSetCurrTx0DescAddrEx(dwIoBase, dwCurrDescAddr);
+	}
 }
 
 /*
@@ -1244,25 +1244,25 @@ void MACvSetCurrTXDescAddr (int iTxType, unsigned long dwIoBase, unsigned long d
  * Return Value: none
  *
  */
-void MACvTimer0MicroSDelay (unsigned long dwIoBase, unsigned int uDelay)
+void MACvTimer0MicroSDelay(unsigned long dwIoBase, unsigned int uDelay)
 {
-unsigned char byValue;
-unsigned int uu,ii;
-
-    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
-    VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelay);
-    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, (TMCTL_TMD | TMCTL_TE));
-    for(ii=0;ii<66;ii++) {  // assume max PCI clock is 66Mhz
-        for (uu = 0; uu < uDelay; uu++) {
-            VNSvInPortB(dwIoBase + MAC_REG_TMCTL0, &byValue);
-            if ((byValue == 0) ||
-                (byValue & TMCTL_TSUSP)) {
-                VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
-                return;
-            }
-        }
-    }
-    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
+	unsigned char byValue;
+	unsigned int uu, ii;
+
+	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
+	VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelay);
+	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, (TMCTL_TMD | TMCTL_TE));
+	for (ii = 0; ii < 66; ii++) {  // assume max PCI clock is 66Mhz
+		for (uu = 0; uu < uDelay; uu++) {
+			VNSvInPortB(dwIoBase + MAC_REG_TMCTL0, &byValue);
+			if ((byValue == 0) ||
+			    (byValue & TMCTL_TSUSP)) {
+				VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
+				return;
+			}
+		}
+	}
+	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
 
 }
 
@@ -1280,11 +1280,11 @@ unsigned int uu,ii;
  * Return Value: none
  *
  */
-void MACvOneShotTimer0MicroSec (unsigned long dwIoBase, unsigned int uDelayTime)
+void MACvOneShotTimer0MicroSec(unsigned long dwIoBase, unsigned int uDelayTime)
 {
-    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
-    VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelayTime);
-    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, (TMCTL_TMD | TMCTL_TE));
+	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
+	VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelayTime);
+	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, (TMCTL_TMD | TMCTL_TE));
 }
 
 /*
@@ -1301,143 +1301,143 @@ void MACvOneShotTimer0MicroSec (unsigned long dwIoBase, unsigned int uDelayTime)
  * Return Value: none
  *
  */
-void MACvOneShotTimer1MicroSec (unsigned long dwIoBase, unsigned int uDelayTime)
+void MACvOneShotTimer1MicroSec(unsigned long dwIoBase, unsigned int uDelayTime)
 {
-    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, 0);
-    VNSvOutPortD(dwIoBase + MAC_REG_TMDATA1, uDelayTime);
-    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, (TMCTL_TMD | TMCTL_TE));
+	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, 0);
+	VNSvOutPortD(dwIoBase + MAC_REG_TMDATA1, uDelayTime);
+	VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, (TMCTL_TMD | TMCTL_TE));
 }
 
 
-void MACvSetMISCFifo (unsigned long dwIoBase, unsigned short wOffset, unsigned long dwData)
+void MACvSetMISCFifo(unsigned long dwIoBase, unsigned short wOffset, unsigned long dwData)
 {
-    if (wOffset > 273)
-        return;
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	if (wOffset > 273)
+		return;
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 }
 
 
-bool MACbTxDMAOff (unsigned long dwIoBase, unsigned int idx)
+bool MACbTxDMAOff(unsigned long dwIoBase, unsigned int idx)
 {
-unsigned char byData;
-unsigned int ww = 0;
-
-    if (idx == TYPE_TXDMA0) {
-        VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
-        for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-            VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
-            if ( !(byData & DMACTL_RUN))
-                break;
-        }
-    } else if (idx == TYPE_AC0DMA) {
-        VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
-        for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-            VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
-            if ( !(byData & DMACTL_RUN))
-                break;
-        }
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x29);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x29)\n");
-        return false;
-    }
-    return true;
+	unsigned char byData;
+	unsigned int ww = 0;
+
+	if (idx == TYPE_TXDMA0) {
+		VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
+		for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+			VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
+			if (!(byData & DMACTL_RUN))
+				break;
+		}
+	} else if (idx == TYPE_AC0DMA) {
+		VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
+		for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+			VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
+			if (!(byData & DMACTL_RUN))
+				break;
+		}
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x29);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x29)\n");
+		return false;
+	}
+	return true;
 }
 
-void MACvClearBusSusInd (unsigned long dwIoBase)
+void MACvClearBusSusInd(unsigned long dwIoBase)
 {
-    unsigned long dwOrgValue;
-    unsigned int ww;
-    // check if BcnSusInd enabled
-    VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
-    if( !(dwOrgValue & EnCFG_BcnSusInd))
-        return;
-    //Set BcnSusClr
-    dwOrgValue = dwOrgValue | EnCFG_BcnSusClr;
-    VNSvOutPortD(dwIoBase + MAC_REG_ENCFG, dwOrgValue);
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
-        if( !(dwOrgValue & EnCFG_BcnSusInd))
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x33);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
-    }
+	unsigned long dwOrgValue;
+	unsigned int ww;
+	// check if BcnSusInd enabled
+	VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
+	if (!(dwOrgValue & EnCFG_BcnSusInd))
+		return;
+	//Set BcnSusClr
+	dwOrgValue = dwOrgValue | EnCFG_BcnSusClr;
+	VNSvOutPortD(dwIoBase + MAC_REG_ENCFG, dwOrgValue);
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
+		if (!(dwOrgValue & EnCFG_BcnSusInd))
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x33);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x33)\n");
+	}
 }
 
-void MACvEnableBusSusEn (unsigned long dwIoBase)
+void MACvEnableBusSusEn(unsigned long dwIoBase)
 {
-    unsigned char byOrgValue;
-    unsigned long dwOrgValue;
-    unsigned int ww;
-    // check if BcnSusInd enabled
-    VNSvInPortB(dwIoBase + MAC_REG_CFG , &byOrgValue);
-
-    //Set BcnSusEn
-    byOrgValue = byOrgValue | CFG_BCNSUSEN;
-    VNSvOutPortB(dwIoBase + MAC_REG_ENCFG, byOrgValue);
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
-        if(dwOrgValue & EnCFG_BcnSusInd)
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x34);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x34)\n");
-    }
+	unsigned char byOrgValue;
+	unsigned long dwOrgValue;
+	unsigned int ww;
+	// check if BcnSusInd enabled
+	VNSvInPortB(dwIoBase + MAC_REG_CFG , &byOrgValue);
+
+	//Set BcnSusEn
+	byOrgValue = byOrgValue | CFG_BCNSUSEN;
+	VNSvOutPortB(dwIoBase + MAC_REG_ENCFG, byOrgValue);
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
+		if (dwOrgValue & EnCFG_BcnSusInd)
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x34);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x34)\n");
+	}
 }
 
-bool MACbFlushSYNCFifo (unsigned long dwIoBase)
+bool MACbFlushSYNCFifo(unsigned long dwIoBase)
 {
-    unsigned char byOrgValue;
-    unsigned int ww;
-    // Read MACCR
-    VNSvInPortB(dwIoBase + MAC_REG_MACCR , &byOrgValue);
-
-    // Set SYNCFLUSH
-    byOrgValue = byOrgValue | MACCR_SYNCFLUSH;
-    VNSvOutPortB(dwIoBase + MAC_REG_MACCR, byOrgValue);
-
-    // Check if SyncFlushOK
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortB(dwIoBase + MAC_REG_MACCR , &byOrgValue);
-        if(byOrgValue & MACCR_SYNCFLUSHOK)
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x35);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
-    }
-    return true;
+	unsigned char byOrgValue;
+	unsigned int ww;
+	// Read MACCR
+	VNSvInPortB(dwIoBase + MAC_REG_MACCR , &byOrgValue);
+
+	// Set SYNCFLUSH
+	byOrgValue = byOrgValue | MACCR_SYNCFLUSH;
+	VNSvOutPortB(dwIoBase + MAC_REG_MACCR, byOrgValue);
+
+	// Check if SyncFlushOK
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortB(dwIoBase + MAC_REG_MACCR , &byOrgValue);
+		if (byOrgValue & MACCR_SYNCFLUSHOK)
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x35);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x33)\n");
+	}
+	return true;
 }
 
-bool MACbPSWakeup (unsigned long dwIoBase)
+bool MACbPSWakeup(unsigned long dwIoBase)
 {
-    unsigned char byOrgValue;
-    unsigned int ww;
-    // Read PSCTL
-    if (MACbIsRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PS)) {
-        return true;
-    }
-    // Disable PS
-    MACvRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PSEN);
-
-    // Check if SyncFlushOK
-    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
-        VNSvInPortB(dwIoBase + MAC_REG_PSCTL , &byOrgValue);
-        if(byOrgValue & PSCTL_WAKEDONE)
-            break;
-    }
-    if (ww == W_MAX_TIMEOUT) {
-        DBG_PORT80(0x36);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
-        return false;
-    }
-    return true;
+	unsigned char byOrgValue;
+	unsigned int ww;
+	// Read PSCTL
+	if (MACbIsRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PS)) {
+		return true;
+	}
+	// Disable PS
+	MACvRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PSEN);
+
+	// Check if SyncFlushOK
+	for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+		VNSvInPortB(dwIoBase + MAC_REG_PSCTL , &byOrgValue);
+		if (byOrgValue & PSCTL_WAKEDONE)
+			break;
+	}
+	if (ww == W_MAX_TIMEOUT) {
+		DBG_PORT80(0x36);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " DBG_PORT80(0x33)\n");
+		return false;
+	}
+	return true;
 }
 
 /*
@@ -1455,55 +1455,55 @@ bool MACbPSWakeup (unsigned long dwIoBase)
  *
  */
 
-void MACvSetKeyEntry (unsigned long dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx,
-		unsigned int uKeyIdx, unsigned char *pbyAddr, unsigned long *pdwKey, unsigned char byLocalID)
+void MACvSetKeyEntry(unsigned long dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx,
+		     unsigned int uKeyIdx, unsigned char *pbyAddr, unsigned long *pdwKey, unsigned char byLocalID)
 {
-unsigned short wOffset;
-unsigned long dwData;
-int     ii;
-
-    if (byLocalID <= 1)
-        return;
-
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetKeyEntry\n");
-    wOffset = MISCFIFO_KEYETRY0;
-    wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
-
-    dwData = 0;
-    dwData |= wKeyCtl;
-    dwData <<= 16;
-    dwData |= MAKEWORD(*(pbyAddr+4), *(pbyAddr+5));
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
-
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    wOffset++;
-
-    dwData = 0;
-    dwData |= *(pbyAddr+3);
-    dwData <<= 8;
-    dwData |= *(pbyAddr+2);
-    dwData <<= 8;
-    dwData |= *(pbyAddr+1);
-    dwData <<= 8;
-    dwData |= *(pbyAddr+0);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"2. wOffset: %d, Data: %lX\n", wOffset, dwData);
-
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    wOffset++;
-
-    wOffset += (uKeyIdx * 4);
-    for (ii=0;ii<4;ii++) {
-        // always push 128 bits
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"3.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
-        VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
-        VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
-        VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    }
+	unsigned short wOffset;
+	unsigned long dwData;
+	int     ii;
+
+	if (byLocalID <= 1)
+		return;
+
+
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvSetKeyEntry\n");
+	wOffset = MISCFIFO_KEYETRY0;
+	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
+
+	dwData = 0;
+	dwData |= wKeyCtl;
+	dwData <<= 16;
+	dwData |= MAKEWORD(*(pbyAddr+4), *(pbyAddr+5));
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
+
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	wOffset++;
+
+	dwData = 0;
+	dwData |= *(pbyAddr+3);
+	dwData <<= 8;
+	dwData |= *(pbyAddr+2);
+	dwData <<= 8;
+	dwData |= *(pbyAddr+1);
+	dwData <<= 8;
+	dwData |= *(pbyAddr+0);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "2. wOffset: %d, Data: %lX\n", wOffset, dwData);
+
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	wOffset++;
+
+	wOffset += (uKeyIdx * 4);
+	for (ii = 0; ii < 4; ii++) {
+		// always push 128 bits
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "3.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
+		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
+		VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
+		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	}
 }
 
 
@@ -1522,16 +1522,16 @@ int     ii;
  * Return Value: none
  *
  */
-void MACvDisableKeyEntry (unsigned long dwIoBase, unsigned int uEntryIdx)
+void MACvDisableKeyEntry(unsigned long dwIoBase, unsigned int uEntryIdx)
 {
-unsigned short wOffset;
+	unsigned short wOffset;
 
-    wOffset = MISCFIFO_KEYETRY0;
-    wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
+	wOffset = MISCFIFO_KEYETRY0;
+	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, 0);
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, 0);
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 }
 
 
@@ -1550,38 +1550,38 @@ unsigned short wOffset;
  *
  */
 
-void MACvSetDefaultKeyEntry (unsigned long dwIoBase, unsigned int uKeyLen,
-		unsigned int uKeyIdx, unsigned long *pdwKey, unsigned char byLocalID)
+void MACvSetDefaultKeyEntry(unsigned long dwIoBase, unsigned int uKeyLen,
+			    unsigned int uKeyIdx, unsigned long *pdwKey, unsigned char byLocalID)
 {
-unsigned short wOffset;
-unsigned long dwData;
-int     ii;
-
-    if (byLocalID <= 1)
-        return;
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetDefaultKeyEntry\n");
-    wOffset = MISCFIFO_KEYETRY0;
-    wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
-
-    wOffset++;
-    wOffset++;
-    wOffset += (uKeyIdx * 4);
-    // always push 128 bits
-    for (ii=0; ii<3; ii++) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
-        VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
-        VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
-        VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    }
-    dwData = *pdwKey;
-    if (uKeyLen == WLAN_WEP104_KEYLEN) {
-        dwData |= 0x80000000;
-    }
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+3);
-    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"End. wOffset: %d, Data: %lX\n", wOffset+3, dwData);
+	unsigned short wOffset;
+	unsigned long dwData;
+	int     ii;
+
+	if (byLocalID <= 1)
+		return;
+
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvSetDefaultKeyEntry\n");
+	wOffset = MISCFIFO_KEYETRY0;
+	wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
+
+	wOffset++;
+	wOffset++;
+	wOffset += (uKeyIdx * 4);
+	// always push 128 bits
+	for (ii = 0; ii < 3; ii++) {
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
+		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
+		VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
+		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	}
+	dwData = *pdwKey;
+	if (uKeyLen == WLAN_WEP104_KEYLEN) {
+		dwData |= 0x80000000;
+	}
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+3);
+	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "End. wOffset: %d, Data: %lX\n", wOffset+3, dwData);
 
 }
 
@@ -1601,25 +1601,25 @@ int     ii;
  *
  */
 /*
-void MACvEnableDefaultKey (unsigned long dwIoBase, unsigned char byLocalID)
-{
-unsigned short wOffset;
-unsigned long dwData;
+  void MACvEnableDefaultKey(unsigned long dwIoBase, unsigned char byLocalID)
+  {
+  unsigned short wOffset;
+  unsigned long dwData;
 
 
-    if (byLocalID <= 1)
-        return;
+  if (byLocalID <= 1)
+  return;
 
-    wOffset = MISCFIFO_KEYETRY0;
-    wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
+  wOffset = MISCFIFO_KEYETRY0;
+  wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
 
-    dwData = 0xC0440000;
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvEnableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
+  dwData = 0xC0440000;
+  VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+  VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+  VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+  DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvEnableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
 
-}
+  }
 */
 
 /*
@@ -1636,20 +1636,20 @@ unsigned long dwData;
  * Return Value: none
  *
  */
-void MACvDisableDefaultKey (unsigned long dwIoBase)
+void MACvDisableDefaultKey(unsigned long dwIoBase)
 {
-unsigned short wOffset;
-unsigned long dwData;
+	unsigned short wOffset;
+	unsigned long dwData;
 
 
-    wOffset = MISCFIFO_KEYETRY0;
-    wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
+	wOffset = MISCFIFO_KEYETRY0;
+	wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
 
-    dwData = 0x0;
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvDisableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
+	dwData = 0x0;
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvDisableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
 }
 
 /*
@@ -1666,43 +1666,43 @@ unsigned long dwData;
  * Return Value: none
  *
  */
-void MACvSetDefaultTKIPKeyEntry (unsigned long dwIoBase, unsigned int uKeyLen,
-		unsigned int uKeyIdx, unsigned long *pdwKey, unsigned char byLocalID)
+void MACvSetDefaultTKIPKeyEntry(unsigned long dwIoBase, unsigned int uKeyLen,
+				unsigned int uKeyIdx, unsigned long *pdwKey, unsigned char byLocalID)
 {
-unsigned short wOffset;
-unsigned long dwData;
-int     ii;
-
-    if (byLocalID <= 1)
-        return;
-
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetDefaultTKIPKeyEntry\n");
-    wOffset = MISCFIFO_KEYETRY0;
-    // Kyle test : change offset from 10 -> 0
-    wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
-
-    dwData = 0xC0660000;
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    wOffset++;
-
-    dwData = 0;
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    wOffset++;
-
-    wOffset += (uKeyIdx * 4);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, idx:%d\n", wOffset, *pdwKey, uKeyIdx);
-    // always push 128 bits
-    for (ii=0; ii<4; ii++) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"2.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
-        VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
-        VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
-        VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    }
+	unsigned short wOffset;
+	unsigned long dwData;
+	int     ii;
+
+	if (byLocalID <= 1)
+		return;
+
+
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvSetDefaultTKIPKeyEntry\n");
+	wOffset = MISCFIFO_KEYETRY0;
+	// Kyle test : change offset from 10 -> 0
+	wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
+
+	dwData = 0xC0660000;
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	wOffset++;
+
+	dwData = 0;
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	wOffset++;
+
+	wOffset += (uKeyIdx * 4);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "1. wOffset: %d, Data: %lX, idx:%d\n", wOffset, *pdwKey, uKeyIdx);
+	// always push 128 bits
+	for (ii = 0; ii < 4; ii++) {
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "2.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
+		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
+		VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
+		VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	}
 
 }
 
@@ -1723,28 +1723,28 @@ int     ii;
  *
  */
 
-void MACvSetDefaultKeyCtl (unsigned long dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx, unsigned char byLocalID)
+void MACvSetDefaultKeyCtl(unsigned long dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx, unsigned char byLocalID)
 {
-unsigned short wOffset;
-unsigned long dwData;
+	unsigned short wOffset;
+	unsigned long dwData;
 
-    if (byLocalID <= 1)
-        return;
+	if (byLocalID <= 1)
+		return;
 
 
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetKeyEntry\n");
-    wOffset = MISCFIFO_KEYETRY0;
-    wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MACvSetKeyEntry\n");
+	wOffset = MISCFIFO_KEYETRY0;
+	wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 
-    dwData = 0;
-    dwData |= wKeyCtl;
-    dwData <<= 16;
-    dwData |= 0xffff;
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
+	dwData = 0;
+	dwData |= wKeyCtl;
+	dwData <<= 16;
+	dwData |= 0xffff;
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
 
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
-    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
-    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+	VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+	VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
 
 }
 

commit 789d1aef176e720fce4a8a5a9ab07f093ddb9086
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Aug 20 08:43:13 2012 -0700

    staging: "vt6655" Fix typos in comments.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index f8d1651341f8..30c261579412 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -56,9 +56,9 @@
  *      MACbSafeStop - Stop MAC function
  *      MACbShutdown - Shut down MAC
  *      MACvInitialize - Initialize MAC
- *      MACvSetCurrRxDescAddr - Set Rx Descriptos Address
- *      MACvSetCurrTx0DescAddr - Set Tx0 Descriptos Address
- *      MACvSetCurrTx1DescAddr - Set Tx1 Descriptos Address
+ *      MACvSetCurrRxDescAddr - Set Rx Descriptors Address
+ *      MACvSetCurrTx0DescAddr - Set Tx0 Descriptors Address
+ *      MACvSetCurrTx1DescAddr - Set Tx1 Descriptors Address
  *      MACvTimer0MicroSDelay - Micro Second Delay Loop by MAC
  *
  * Revision History:
@@ -1498,7 +1498,7 @@ int     ii;
 
     wOffset += (uKeyIdx * 4);
     for (ii=0;ii<4;ii++) {
-        // alway push 128 bits
+        // always push 128 bits
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"3.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
         VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
         VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
@@ -1567,7 +1567,7 @@ int     ii;
     wOffset++;
     wOffset++;
     wOffset += (uKeyIdx * 4);
-    // alway push 128 bits
+    // always push 128 bits
     for (ii=0; ii<3; ii++) {
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
         VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
@@ -1696,7 +1696,7 @@ int     ii;
 
     wOffset += (uKeyIdx * 4);
     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, idx:%d\n", wOffset, *pdwKey, uKeyIdx);
-    // alway push 128 bits
+    // always push 128 bits
     for (ii=0; ii<4; ii++) {
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"2.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
         VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);

commit 7b6a001313a9b11a1f0985de05fff514db41d72d
Author: Charles Clément <caratorn@gmail.com>
Date:   Sun Aug 1 17:15:50 2010 +0200

    Staging: vt6655: replace BOOL with in kernel bool
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index afeccd2449ef..f8d1651341f8 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -140,7 +140,7 @@ void MACvReadAllRegs (unsigned long dwIoBase, unsigned char *pbyMacRegs)
  * Return Value: true if all test bits On; otherwise false
  *
  */
-BOOL MACbIsRegBitsOn (unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
+bool MACbIsRegBitsOn (unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
 {
     unsigned char byData;
 
@@ -163,7 +163,7 @@ BOOL MACbIsRegBitsOn (unsigned long dwIoBase, unsigned char byRegOfs, unsigned c
  * Return Value: true if all test bits Off; otherwise false
  *
  */
-BOOL MACbIsRegBitsOff (unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
+bool MACbIsRegBitsOff (unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
 {
     unsigned char byData;
 
@@ -184,7 +184,7 @@ BOOL MACbIsRegBitsOff (unsigned long dwIoBase, unsigned char byRegOfs, unsigned
  * Return Value: true if interrupt is disable; otherwise false
  *
  */
-BOOL MACbIsIntDisable (unsigned long dwIoBase)
+bool MACbIsIntDisable (unsigned long dwIoBase)
 {
     unsigned long dwData;
 
@@ -559,7 +559,7 @@ void MACvSetLoopbackMode (unsigned long dwIoBase, unsigned char byLoopbackMode)
  * Return Value: true if in Loopback mode; otherwise false
  *
  */
-BOOL MACbIsInLoopbackMode (unsigned long dwIoBase)
+bool MACbIsInLoopbackMode (unsigned long dwIoBase)
 {
     unsigned char byOrgValue;
 
@@ -728,7 +728,7 @@ void MACvRestoreContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: true if all values are the same; otherwise false
  *
  */
-BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
+bool MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 {
     unsigned long dwData;
 
@@ -773,7 +773,7 @@ BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: true if Reset Success; otherwise false
  *
  */
-BOOL MACbSoftwareReset (unsigned long dwIoBase)
+bool MACbSoftwareReset (unsigned long dwIoBase)
 {
     unsigned char byData;
     unsigned short ww;
@@ -806,10 +806,10 @@ BOOL MACbSoftwareReset (unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-BOOL MACbSafeSoftwareReset (unsigned long dwIoBase)
+bool MACbSafeSoftwareReset (unsigned long dwIoBase)
 {
     unsigned char abyTmpRegData[MAC_MAX_CONTEXT_SIZE_PAGE0+MAC_MAX_CONTEXT_SIZE_PAGE1];
-    BOOL    bRetVal;
+    bool bRetVal;
 
     // PATCH....
     // save some important register's value, then do
@@ -839,7 +839,7 @@ BOOL MACbSafeSoftwareReset (unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-BOOL MACbSafeRxOff (unsigned long dwIoBase)
+bool MACbSafeRxOff (unsigned long dwIoBase)
 {
     unsigned short ww;
     unsigned long dwData;
@@ -900,7 +900,7 @@ BOOL MACbSafeRxOff (unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-BOOL MACbSafeTxOff (unsigned long dwIoBase)
+bool MACbSafeTxOff (unsigned long dwIoBase)
 {
     unsigned short ww;
     unsigned long dwData;
@@ -964,7 +964,7 @@ BOOL MACbSafeTxOff (unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-BOOL MACbSafeStop (unsigned long dwIoBase)
+bool MACbSafeStop (unsigned long dwIoBase)
 {
     MACvRegBitsOff(dwIoBase, MAC_REG_TCR, TCR_AUTOBCNTX);
 
@@ -999,7 +999,7 @@ BOOL MACbSafeStop (unsigned long dwIoBase)
  * Return Value: true if success; otherwise false
  *
  */
-BOOL MACbShutdown (unsigned long dwIoBase)
+bool MACbShutdown (unsigned long dwIoBase)
 {
     // disable MAC IMR
     MACvIntDisable(dwIoBase);
@@ -1319,7 +1319,7 @@ void MACvSetMISCFifo (unsigned long dwIoBase, unsigned short wOffset, unsigned l
 }
 
 
-BOOL MACbTxDMAOff (unsigned long dwIoBase, unsigned int idx)
+bool MACbTxDMAOff (unsigned long dwIoBase, unsigned int idx)
 {
 unsigned char byData;
 unsigned int ww = 0;
@@ -1391,7 +1391,7 @@ void MACvEnableBusSusEn (unsigned long dwIoBase)
     }
 }
 
-BOOL MACbFlushSYNCFifo (unsigned long dwIoBase)
+bool MACbFlushSYNCFifo (unsigned long dwIoBase)
 {
     unsigned char byOrgValue;
     unsigned int ww;
@@ -1415,7 +1415,7 @@ BOOL MACbFlushSYNCFifo (unsigned long dwIoBase)
     return true;
 }
 
-BOOL MACbPSWakeup (unsigned long dwIoBase)
+bool MACbPSWakeup (unsigned long dwIoBase)
 {
     unsigned char byOrgValue;
     unsigned int ww;

commit 5a5a2a6ad4aa2467bcc34fa50e85c2afc90bab05
Author: Charles Clément <caratorn@gmail.com>
Date:   Sun Aug 1 17:15:49 2010 +0200

    Staging: vt6655: replace FALSE with in kernel false
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 4f46f488f793..afeccd2449ef 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -137,7 +137,7 @@ void MACvReadAllRegs (unsigned long dwIoBase, unsigned char *pbyMacRegs)
  *  Out:
  *      none
  *
- * Return Value: true if all test bits On; otherwise FALSE
+ * Return Value: true if all test bits On; otherwise false
  *
  */
 BOOL MACbIsRegBitsOn (unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
@@ -160,7 +160,7 @@ BOOL MACbIsRegBitsOn (unsigned long dwIoBase, unsigned char byRegOfs, unsigned c
  *  Out:
  *      none
  *
- * Return Value: true if all test bits Off; otherwise FALSE
+ * Return Value: true if all test bits Off; otherwise false
  *
  */
 BOOL MACbIsRegBitsOff (unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
@@ -181,7 +181,7 @@ BOOL MACbIsRegBitsOff (unsigned long dwIoBase, unsigned char byRegOfs, unsigned
  *  Out:
  *      none
  *
- * Return Value: true if interrupt is disable; otherwise FALSE
+ * Return Value: true if interrupt is disable; otherwise false
  *
  */
 BOOL MACbIsIntDisable (unsigned long dwIoBase)
@@ -190,7 +190,7 @@ BOOL MACbIsIntDisable (unsigned long dwIoBase)
 
     VNSvInPortD(dwIoBase + MAC_REG_IMR, &dwData);
     if (dwData != 0)
-        return FALSE;
+        return false;
 
     return true;
 }
@@ -556,7 +556,7 @@ void MACvSetLoopbackMode (unsigned long dwIoBase, unsigned char byLoopbackMode)
  *  Out:
  *      none
  *
- * Return Value: true if in Loopback mode; otherwise FALSE
+ * Return Value: true if in Loopback mode; otherwise false
  *
  */
 BOOL MACbIsInLoopbackMode (unsigned long dwIoBase)
@@ -566,7 +566,7 @@ BOOL MACbIsInLoopbackMode (unsigned long dwIoBase)
     VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
     if (byOrgValue & (TEST_LBINT | TEST_LBEXT))
         return true;
-    return FALSE;
+    return false;
 }
 
 /*
@@ -725,7 +725,7 @@ void MACvRestoreContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  *  Out:
  *      none
  *
- * Return Value: true if all values are the same; otherwise FALSE
+ * Return Value: true if all values are the same; otherwise false
  *
  */
 BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
@@ -733,27 +733,27 @@ BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
     unsigned long dwData;
 
     // compare MAC context to determine if this is a power lost init,
-    // return true for power remaining init, return FALSE for power lost init
+    // return true for power remaining init, return false for power lost init
 
     // compare CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
     VNSvInPortD(dwIoBase + MAC_REG_TXDMAPTR0, &dwData);
     if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0)) {
-        return FALSE;
+        return false;
     }
 
     VNSvInPortD(dwIoBase + MAC_REG_AC0DMAPTR, &dwData);
     if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR)) {
-        return FALSE;
+        return false;
     }
 
     VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR0, &dwData);
     if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0)) {
-        return FALSE;
+        return false;
     }
 
     VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR1, &dwData);
     if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1)) {
-        return FALSE;
+        return false;
     }
 
 
@@ -770,7 +770,7 @@ BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  *  Out:
  *      none
  *
- * Return Value: true if Reset Success; otherwise FALSE
+ * Return Value: true if Reset Success; otherwise false
  *
  */
 BOOL MACbSoftwareReset (unsigned long dwIoBase)
@@ -788,7 +788,7 @@ BOOL MACbSoftwareReset (unsigned long dwIoBase)
             break;
     }
     if (ww == W_MAX_TIMEOUT)
-        return FALSE;
+        return false;
     return true;
 
 }
@@ -803,7 +803,7 @@ BOOL MACbSoftwareReset (unsigned long dwIoBase)
  *  Out:
  *      none
  *
- * Return Value: true if success; otherwise FALSE
+ * Return Value: true if success; otherwise false
  *
  */
 BOOL MACbSafeSoftwareReset (unsigned long dwIoBase)
@@ -836,7 +836,7 @@ BOOL MACbSafeSoftwareReset (unsigned long dwIoBase)
  *  Out:
  *      none
  *
- * Return Value: true if success; otherwise FALSE
+ * Return Value: true if success; otherwise false
  *
  */
 BOOL MACbSafeRxOff (unsigned long dwIoBase)
@@ -858,7 +858,7 @@ BOOL MACbSafeRxOff (unsigned long dwIoBase)
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x10);
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x10)\n");
-        return(FALSE);
+        return(false);
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL1, &dwData);
@@ -868,7 +868,7 @@ BOOL MACbSafeRxOff (unsigned long dwIoBase)
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x11);
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x11)\n");
-        return(FALSE);
+        return(false);
     }
 
     // try to safe shutdown RX
@@ -882,7 +882,7 @@ BOOL MACbSafeRxOff (unsigned long dwIoBase)
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x12);
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x12)\n");
-        return(FALSE);
+        return(false);
     }
     return true;
 }
@@ -897,7 +897,7 @@ BOOL MACbSafeRxOff (unsigned long dwIoBase)
  *  Out:
  *      none
  *
- * Return Value: true if success; otherwise FALSE
+ * Return Value: true if success; otherwise false
  *
  */
 BOOL MACbSafeTxOff (unsigned long dwIoBase)
@@ -921,7 +921,7 @@ BOOL MACbSafeTxOff (unsigned long dwIoBase)
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x20);
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x20)\n");
-        return(FALSE);
+        return(false);
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_AC0DMACTL, &dwData);
@@ -931,7 +931,7 @@ BOOL MACbSafeTxOff (unsigned long dwIoBase)
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x21);
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x21)\n");
-        return(FALSE);
+        return(false);
     }
 
     // try to safe shutdown TX
@@ -946,7 +946,7 @@ BOOL MACbSafeTxOff (unsigned long dwIoBase)
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x24);
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x24)\n");
-        return(FALSE);
+        return(false);
     }
     return true;
 }
@@ -961,24 +961,24 @@ BOOL MACbSafeTxOff (unsigned long dwIoBase)
  *  Out:
  *      none
  *
- * Return Value: true if success; otherwise FALSE
+ * Return Value: true if success; otherwise false
  *
  */
 BOOL MACbSafeStop (unsigned long dwIoBase)
 {
     MACvRegBitsOff(dwIoBase, MAC_REG_TCR, TCR_AUTOBCNTX);
 
-    if (MACbSafeRxOff(dwIoBase) == FALSE) {
+    if (MACbSafeRxOff(dwIoBase) == false) {
         DBG_PORT80(0xA1);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" MACbSafeRxOff == FALSE)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" MACbSafeRxOff == false)\n");
         MACbSafeSoftwareReset(dwIoBase);
-        return FALSE;
+        return false;
     }
-    if (MACbSafeTxOff(dwIoBase) == FALSE) {
+    if (MACbSafeTxOff(dwIoBase) == false) {
         DBG_PORT80(0xA2);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" MACbSafeTxOff == FALSE)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" MACbSafeTxOff == false)\n");
         MACbSafeSoftwareReset(dwIoBase);
-        return FALSE;
+        return false;
     }
 
     MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_MACEN);
@@ -996,7 +996,7 @@ BOOL MACbSafeStop (unsigned long dwIoBase)
  *  Out:
  *      none
  *
- * Return Value: true if success; otherwise FALSE
+ * Return Value: true if success; otherwise false
  *
  */
 BOOL MACbShutdown (unsigned long dwIoBase)
@@ -1007,7 +1007,7 @@ BOOL MACbShutdown (unsigned long dwIoBase)
     // stop the adapter
     if (!MACbSafeStop(dwIoBase)) {
         MACvSetLoopbackMode(dwIoBase, MAC_LB_NONE);
-        return FALSE;
+        return false;
     }
     MACvSetLoopbackMode(dwIoBase, MAC_LB_NONE);
     return true;
@@ -1342,7 +1342,7 @@ unsigned int ww = 0;
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x29);
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x29)\n");
-        return FALSE;
+        return false;
     }
     return true;
 }
@@ -1435,7 +1435,7 @@ BOOL MACbPSWakeup (unsigned long dwIoBase)
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x36);
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
-        return FALSE;
+        return false;
     }
     return true;
 }

commit 1b12068a804711ae2f4fd2876d5706542c1d7ad9
Author: Charles Clément <caratorn@gmail.com>
Date:   Sun Aug 1 17:15:48 2010 +0200

    Staging: vt6655: replace TRUE with in kernel true
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 48bfbf834bf3..4f46f488f793 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -137,7 +137,7 @@ void MACvReadAllRegs (unsigned long dwIoBase, unsigned char *pbyMacRegs)
  *  Out:
  *      none
  *
- * Return Value: TRUE if all test bits On; otherwise FALSE
+ * Return Value: true if all test bits On; otherwise FALSE
  *
  */
 BOOL MACbIsRegBitsOn (unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
@@ -160,7 +160,7 @@ BOOL MACbIsRegBitsOn (unsigned long dwIoBase, unsigned char byRegOfs, unsigned c
  *  Out:
  *      none
  *
- * Return Value: TRUE if all test bits Off; otherwise FALSE
+ * Return Value: true if all test bits Off; otherwise FALSE
  *
  */
 BOOL MACbIsRegBitsOff (unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
@@ -181,7 +181,7 @@ BOOL MACbIsRegBitsOff (unsigned long dwIoBase, unsigned char byRegOfs, unsigned
  *  Out:
  *      none
  *
- * Return Value: TRUE if interrupt is disable; otherwise FALSE
+ * Return Value: true if interrupt is disable; otherwise FALSE
  *
  */
 BOOL MACbIsIntDisable (unsigned long dwIoBase)
@@ -192,7 +192,7 @@ BOOL MACbIsIntDisable (unsigned long dwIoBase)
     if (dwData != 0)
         return FALSE;
 
-    return TRUE;
+    return true;
 }
 
 /*
@@ -556,7 +556,7 @@ void MACvSetLoopbackMode (unsigned long dwIoBase, unsigned char byLoopbackMode)
  *  Out:
  *      none
  *
- * Return Value: TRUE if in Loopback mode; otherwise FALSE
+ * Return Value: true if in Loopback mode; otherwise FALSE
  *
  */
 BOOL MACbIsInLoopbackMode (unsigned long dwIoBase)
@@ -565,7 +565,7 @@ BOOL MACbIsInLoopbackMode (unsigned long dwIoBase)
 
     VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
     if (byOrgValue & (TEST_LBINT | TEST_LBEXT))
-        return TRUE;
+        return true;
     return FALSE;
 }
 
@@ -725,7 +725,7 @@ void MACvRestoreContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  *  Out:
  *      none
  *
- * Return Value: TRUE if all values are the same; otherwise FALSE
+ * Return Value: true if all values are the same; otherwise FALSE
  *
  */
 BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
@@ -733,7 +733,7 @@ BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
     unsigned long dwData;
 
     // compare MAC context to determine if this is a power lost init,
-    // return TRUE for power remaining init, return FALSE for power lost init
+    // return true for power remaining init, return FALSE for power lost init
 
     // compare CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
     VNSvInPortD(dwIoBase + MAC_REG_TXDMAPTR0, &dwData);
@@ -757,7 +757,7 @@ BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
     }
 
 
-    return TRUE;
+    return true;
 }
 
 /*
@@ -770,7 +770,7 @@ BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  *  Out:
  *      none
  *
- * Return Value: TRUE if Reset Success; otherwise FALSE
+ * Return Value: true if Reset Success; otherwise FALSE
  *
  */
 BOOL MACbSoftwareReset (unsigned long dwIoBase)
@@ -789,7 +789,7 @@ BOOL MACbSoftwareReset (unsigned long dwIoBase)
     }
     if (ww == W_MAX_TIMEOUT)
         return FALSE;
-    return TRUE;
+    return true;
 
 }
 
@@ -803,7 +803,7 @@ BOOL MACbSoftwareReset (unsigned long dwIoBase)
  *  Out:
  *      none
  *
- * Return Value: TRUE if success; otherwise FALSE
+ * Return Value: true if success; otherwise FALSE
  *
  */
 BOOL MACbSafeSoftwareReset (unsigned long dwIoBase)
@@ -836,7 +836,7 @@ BOOL MACbSafeSoftwareReset (unsigned long dwIoBase)
  *  Out:
  *      none
  *
- * Return Value: TRUE if success; otherwise FALSE
+ * Return Value: true if success; otherwise FALSE
  *
  */
 BOOL MACbSafeRxOff (unsigned long dwIoBase)
@@ -884,7 +884,7 @@ BOOL MACbSafeRxOff (unsigned long dwIoBase)
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x12)\n");
         return(FALSE);
     }
-    return TRUE;
+    return true;
 }
 
 /*
@@ -897,7 +897,7 @@ BOOL MACbSafeRxOff (unsigned long dwIoBase)
  *  Out:
  *      none
  *
- * Return Value: TRUE if success; otherwise FALSE
+ * Return Value: true if success; otherwise FALSE
  *
  */
 BOOL MACbSafeTxOff (unsigned long dwIoBase)
@@ -948,7 +948,7 @@ BOOL MACbSafeTxOff (unsigned long dwIoBase)
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x24)\n");
         return(FALSE);
     }
-    return TRUE;
+    return true;
 }
 
 /*
@@ -961,7 +961,7 @@ BOOL MACbSafeTxOff (unsigned long dwIoBase)
  *  Out:
  *      none
  *
- * Return Value: TRUE if success; otherwise FALSE
+ * Return Value: true if success; otherwise FALSE
  *
  */
 BOOL MACbSafeStop (unsigned long dwIoBase)
@@ -983,7 +983,7 @@ BOOL MACbSafeStop (unsigned long dwIoBase)
 
     MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_MACEN);
 
-    return TRUE;
+    return true;
 }
 
 /*
@@ -996,7 +996,7 @@ BOOL MACbSafeStop (unsigned long dwIoBase)
  *  Out:
  *      none
  *
- * Return Value: TRUE if success; otherwise FALSE
+ * Return Value: true if success; otherwise FALSE
  *
  */
 BOOL MACbShutdown (unsigned long dwIoBase)
@@ -1010,7 +1010,7 @@ BOOL MACbShutdown (unsigned long dwIoBase)
         return FALSE;
     }
     MACvSetLoopbackMode(dwIoBase, MAC_LB_NONE);
-    return TRUE;
+    return true;
 }
 
 /*
@@ -1045,7 +1045,7 @@ void MACvInitialize (unsigned long dwIoBase)
     // issue AUTOLD in EECSR to reload eeprom
     //MACvRegBitsOn(dwIoBase, MAC_REG_I2MCSR, I2MCSR_AUTOLD);
     // wait until EEPROM loading complete
-    //while (TRUE) {
+    //while (true) {
     //    u8 u8Data;
     //    VNSvInPortB(dwIoBase + MAC_REG_I2MCSR, &u8Data);
     //    if ( !(u8Data & I2MCSR_AUTOLD))
@@ -1344,7 +1344,7 @@ unsigned int ww = 0;
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x29)\n");
         return FALSE;
     }
-    return TRUE;
+    return true;
 }
 
 void MACvClearBusSusInd (unsigned long dwIoBase)
@@ -1412,7 +1412,7 @@ BOOL MACbFlushSYNCFifo (unsigned long dwIoBase)
         DBG_PORT80(0x35);
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
     }
-    return TRUE;
+    return true;
 }
 
 BOOL MACbPSWakeup (unsigned long dwIoBase)
@@ -1421,7 +1421,7 @@ BOOL MACbPSWakeup (unsigned long dwIoBase)
     unsigned int ww;
     // Read PSCTL
     if (MACbIsRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PS)) {
-        return TRUE;
+        return true;
     }
     // Disable PS
     MACvRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PSEN);
@@ -1437,7 +1437,7 @@ BOOL MACbPSWakeup (unsigned long dwIoBase)
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
         return FALSE;
     }
-    return TRUE;
+    return true;
 }
 
 /*

commit 3fc9b584c28095fe0d46cfb8bddafdf93947042e
Author: Charles Clément <caratorn@gmail.com>
Date:   Thu Jun 24 11:02:27 2010 -0700

    Staging: vt6655: remove BYTE typedef
    
    Replace all occurrences with unsigned char type.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 1232bfe6d666..48bfbf834bf3 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -140,9 +140,9 @@ void MACvReadAllRegs (unsigned long dwIoBase, unsigned char *pbyMacRegs)
  * Return Value: TRUE if all test bits On; otherwise FALSE
  *
  */
-BOOL MACbIsRegBitsOn (unsigned long dwIoBase, BYTE byRegOfs, BYTE byTestBits)
+BOOL MACbIsRegBitsOn (unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
 {
-    BYTE byData;
+    unsigned char byData;
 
     VNSvInPortB(dwIoBase + byRegOfs, &byData);
     return (byData & byTestBits) == byTestBits;
@@ -163,9 +163,9 @@ BOOL MACbIsRegBitsOn (unsigned long dwIoBase, BYTE byRegOfs, BYTE byTestBits)
  * Return Value: TRUE if all test bits Off; otherwise FALSE
  *
  */
-BOOL MACbIsRegBitsOff (unsigned long dwIoBase, BYTE byRegOfs, BYTE byTestBits)
+BOOL MACbIsRegBitsOff (unsigned long dwIoBase, unsigned char byRegOfs, unsigned char byTestBits)
 {
-    BYTE byData;
+    unsigned char byData;
 
     VNSvInPortB(dwIoBase + byRegOfs, &byData);
     return !(byData & byTestBits);
@@ -209,9 +209,9 @@ BOOL MACbIsIntDisable (unsigned long dwIoBase)
  * Return Value: Mask Value read
  *
  */
-BYTE MACbyReadMultiAddr (unsigned long dwIoBase, unsigned int uByteIdx)
+unsigned char MACbyReadMultiAddr (unsigned long dwIoBase, unsigned int uByteIdx)
 {
-    BYTE byData;
+    unsigned char byData;
 
     MACvSelectPage1(dwIoBase);
     VNSvInPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, &byData);
@@ -234,7 +234,7 @@ BYTE MACbyReadMultiAddr (unsigned long dwIoBase, unsigned int uByteIdx)
  * Return Value: none
  *
  */
-void MACvWriteMultiAddr (unsigned long dwIoBase, unsigned int uByteIdx, BYTE byData)
+void MACvWriteMultiAddr (unsigned long dwIoBase, unsigned int uByteIdx, unsigned char byData)
 {
     MACvSelectPage1(dwIoBase);
     VNSvOutPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, byData);
@@ -255,11 +255,11 @@ void MACvWriteMultiAddr (unsigned long dwIoBase, unsigned int uByteIdx, BYTE byD
  * Return Value: none
  *
  */
-void MACvSetMultiAddrByHash (unsigned long dwIoBase, BYTE byHashIdx)
+void MACvSetMultiAddrByHash (unsigned long dwIoBase, unsigned char byHashIdx)
 {
     unsigned int uByteIdx;
-    BYTE byBitMask;
-    BYTE byOrgValue;
+    unsigned char byBitMask;
+    unsigned char byOrgValue;
 
     // calculate byte position
     uByteIdx = byHashIdx / 8;
@@ -269,7 +269,7 @@ void MACvSetMultiAddrByHash (unsigned long dwIoBase, BYTE byHashIdx)
     byBitMask <<= (byHashIdx % 8);
     // turn on the bit
     byOrgValue = MACbyReadMultiAddr(dwIoBase, uByteIdx);
-    MACvWriteMultiAddr(dwIoBase, uByteIdx, (BYTE)(byOrgValue | byBitMask));
+    MACvWriteMultiAddr(dwIoBase, uByteIdx, (unsigned char)(byOrgValue | byBitMask));
 }
 
 /*
@@ -286,11 +286,11 @@ void MACvSetMultiAddrByHash (unsigned long dwIoBase, BYTE byHashIdx)
  * Return Value: none
  *
  */
-void MACvResetMultiAddrByHash (unsigned long dwIoBase, BYTE byHashIdx)
+void MACvResetMultiAddrByHash (unsigned long dwIoBase, unsigned char byHashIdx)
 {
     unsigned int uByteIdx;
-    BYTE byBitMask;
-    BYTE byOrgValue;
+    unsigned char byBitMask;
+    unsigned char byOrgValue;
 
     // calculate byte position
     uByteIdx = byHashIdx / 8;
@@ -300,7 +300,7 @@ void MACvResetMultiAddrByHash (unsigned long dwIoBase, BYTE byHashIdx)
     byBitMask <<= (byHashIdx % 8);
     // turn off the bit
     byOrgValue = MACbyReadMultiAddr(dwIoBase, uByteIdx);
-    MACvWriteMultiAddr(dwIoBase, uByteIdx, (BYTE)(byOrgValue & (~byBitMask)));
+    MACvWriteMultiAddr(dwIoBase, uByteIdx, (unsigned char)(byOrgValue & (~byBitMask)));
 }
 
 /*
@@ -317,9 +317,9 @@ void MACvResetMultiAddrByHash (unsigned long dwIoBase, BYTE byHashIdx)
  * Return Value: none
  *
  */
-void MACvSetRxThreshold (unsigned long dwIoBase, BYTE byThreshold)
+void MACvSetRxThreshold (unsigned long dwIoBase, unsigned char byThreshold)
 {
-    BYTE byOrgValue;
+    unsigned char byOrgValue;
 
     ASSERT(byThreshold < 4);
 
@@ -363,9 +363,9 @@ void MACvGetRxThreshold (unsigned long dwIoBase, unsigned char *pbyThreshold)
  * Return Value: none
  *
  */
-void MACvSetTxThreshold (unsigned long dwIoBase, BYTE byThreshold)
+void MACvSetTxThreshold (unsigned long dwIoBase, unsigned char byThreshold)
 {
-    BYTE byOrgValue;
+    unsigned char byOrgValue;
 
     ASSERT(byThreshold < 4);
 
@@ -409,9 +409,9 @@ void MACvGetTxThreshold (unsigned long dwIoBase, unsigned char *pbyThreshold)
  * Return Value: none
  *
  */
-void MACvSetDmaLength (unsigned long dwIoBase, BYTE byDmaLength)
+void MACvSetDmaLength (unsigned long dwIoBase, unsigned char byDmaLength)
 {
-    BYTE byOrgValue;
+    unsigned char byOrgValue;
 
     ASSERT(byDmaLength < 4);
 
@@ -455,7 +455,7 @@ void MACvGetDmaLength (unsigned long dwIoBase, unsigned char *pbyDmaLength)
  * Return Value: none
  *
  */
-void MACvSetShortRetryLimit (unsigned long dwIoBase, BYTE byRetryLimit)
+void MACvSetShortRetryLimit (unsigned long dwIoBase, unsigned char byRetryLimit)
 {
     // set SRT
     VNSvOutPortB(dwIoBase + MAC_REG_SRT, byRetryLimit);
@@ -494,7 +494,7 @@ void MACvGetShortRetryLimit (unsigned long dwIoBase, unsigned char *pbyRetryLimi
  * Return Value: none
  *
  */
-void MACvSetLongRetryLimit (unsigned long dwIoBase, BYTE byRetryLimit)
+void MACvSetLongRetryLimit (unsigned long dwIoBase, unsigned char byRetryLimit)
 {
     // set LRT
     VNSvOutPortB(dwIoBase + MAC_REG_LRT, byRetryLimit);
@@ -533,9 +533,9 @@ void MACvGetLongRetryLimit (unsigned long dwIoBase, unsigned char *pbyRetryLimit
  * Return Value: none
  *
  */
-void MACvSetLoopbackMode (unsigned long dwIoBase, BYTE byLoopbackMode)
+void MACvSetLoopbackMode (unsigned long dwIoBase, unsigned char byLoopbackMode)
 {
-    BYTE byOrgValue;
+    unsigned char byOrgValue;
 
     ASSERT(byLoopbackMode < 3);
     byLoopbackMode <<= 6;
@@ -561,7 +561,7 @@ void MACvSetLoopbackMode (unsigned long dwIoBase, BYTE byLoopbackMode)
  */
 BOOL MACbIsInLoopbackMode (unsigned long dwIoBase)
 {
-    BYTE byOrgValue;
+    unsigned char byOrgValue;
 
     VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
     if (byOrgValue & (TEST_LBINT | TEST_LBEXT))
@@ -585,8 +585,8 @@ BOOL MACbIsInLoopbackMode (unsigned long dwIoBase)
  */
 void MACvSetPacketFilter (unsigned long dwIoBase, unsigned short wFilterType)
 {
-    BYTE    byOldRCR;
-    BYTE    byNewRCR = 0;
+    unsigned char byOldRCR;
+    unsigned char byNewRCR = 0;
 
     // if only in DIRECTED mode, multicast-address will set to zero,
     // but if other mode exist (e.g. PROMISCUOUS), multicast-address
@@ -775,7 +775,7 @@ BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  */
 BOOL MACbSoftwareReset (unsigned long dwIoBase)
 {
-    BYTE    byData;
+    unsigned char byData;
     unsigned short ww;
 
     // turn on HOSTCR_SOFTRST, just write 0x01 to reset
@@ -808,7 +808,7 @@ BOOL MACbSoftwareReset (unsigned long dwIoBase)
  */
 BOOL MACbSafeSoftwareReset (unsigned long dwIoBase)
 {
-    BYTE    abyTmpRegData[MAC_MAX_CONTEXT_SIZE_PAGE0+MAC_MAX_CONTEXT_SIZE_PAGE1];
+    unsigned char abyTmpRegData[MAC_MAX_CONTEXT_SIZE_PAGE0+MAC_MAX_CONTEXT_SIZE_PAGE1];
     BOOL    bRetVal;
 
     // PATCH....
@@ -843,7 +843,7 @@ BOOL MACbSafeRxOff (unsigned long dwIoBase)
 {
     unsigned short ww;
     unsigned long dwData;
-    BYTE    byData;
+    unsigned char byData;
 
     // turn off wow temp for turn off Rx safely
 
@@ -904,7 +904,7 @@ BOOL MACbSafeTxOff (unsigned long dwIoBase)
 {
     unsigned short ww;
     unsigned long dwData;
-    BYTE    byData;
+    unsigned char byData;
 
     // Clear TX DMA
     //Tx0
@@ -1082,8 +1082,8 @@ void MACvInitialize (unsigned long dwIoBase)
 void MACvSetCurrRx0DescAddr (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
 unsigned short ww;
-BYTE    byData;
-BYTE    byOrgDMACtl;
+unsigned char byData;
+unsigned char byOrgDMACtl;
 
     VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byOrgDMACtl);
     if (byOrgDMACtl & DMACTL_RUN) {
@@ -1120,8 +1120,8 @@ BYTE    byOrgDMACtl;
 void MACvSetCurrRx1DescAddr (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
 unsigned short ww;
-BYTE    byData;
-BYTE    byOrgDMACtl;
+unsigned char byData;
+unsigned char byOrgDMACtl;
 
     VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byOrgDMACtl);
     if (byOrgDMACtl & DMACTL_RUN) {
@@ -1158,8 +1158,8 @@ BYTE    byOrgDMACtl;
 void MACvSetCurrTx0DescAddrEx (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
 unsigned short ww;
-BYTE    byData;
-BYTE    byOrgDMACtl;
+unsigned char byData;
+unsigned char byOrgDMACtl;
 
     VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byOrgDMACtl);
     if (byOrgDMACtl & DMACTL_RUN) {
@@ -1197,8 +1197,8 @@ BYTE    byOrgDMACtl;
 void MACvSetCurrAC0DescAddrEx (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
 unsigned short ww;
-BYTE    byData;
-BYTE    byOrgDMACtl;
+unsigned char byData;
+unsigned char byOrgDMACtl;
 
     VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byOrgDMACtl);
     if (byOrgDMACtl & DMACTL_RUN) {
@@ -1246,7 +1246,7 @@ void MACvSetCurrTXDescAddr (int iTxType, unsigned long dwIoBase, unsigned long d
  */
 void MACvTimer0MicroSDelay (unsigned long dwIoBase, unsigned int uDelay)
 {
-BYTE byValue;
+unsigned char byValue;
 unsigned int uu,ii;
 
     VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
@@ -1321,7 +1321,7 @@ void MACvSetMISCFifo (unsigned long dwIoBase, unsigned short wOffset, unsigned l
 
 BOOL MACbTxDMAOff (unsigned long dwIoBase, unsigned int idx)
 {
-BYTE byData;
+unsigned char byData;
 unsigned int ww = 0;
 
     if (idx == TYPE_TXDMA0) {
@@ -1371,7 +1371,7 @@ void MACvClearBusSusInd (unsigned long dwIoBase)
 
 void MACvEnableBusSusEn (unsigned long dwIoBase)
 {
-    BYTE  byOrgValue;
+    unsigned char byOrgValue;
     unsigned long dwOrgValue;
     unsigned int ww;
     // check if BcnSusInd enabled
@@ -1393,7 +1393,7 @@ void MACvEnableBusSusEn (unsigned long dwIoBase)
 
 BOOL MACbFlushSYNCFifo (unsigned long dwIoBase)
 {
-    BYTE  byOrgValue;
+    unsigned char byOrgValue;
     unsigned int ww;
     // Read MACCR
     VNSvInPortB(dwIoBase + MAC_REG_MACCR , &byOrgValue);
@@ -1417,7 +1417,7 @@ BOOL MACbFlushSYNCFifo (unsigned long dwIoBase)
 
 BOOL MACbPSWakeup (unsigned long dwIoBase)
 {
-    BYTE  byOrgValue;
+    unsigned char byOrgValue;
     unsigned int ww;
     // Read PSCTL
     if (MACbIsRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PS)) {
@@ -1456,7 +1456,7 @@ BOOL MACbPSWakeup (unsigned long dwIoBase)
  */
 
 void MACvSetKeyEntry (unsigned long dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx,
-		unsigned int uKeyIdx, unsigned char *pbyAddr, unsigned long *pdwKey, BYTE byLocalID)
+		unsigned int uKeyIdx, unsigned char *pbyAddr, unsigned long *pdwKey, unsigned char byLocalID)
 {
 unsigned short wOffset;
 unsigned long dwData;
@@ -1551,7 +1551,7 @@ unsigned short wOffset;
  */
 
 void MACvSetDefaultKeyEntry (unsigned long dwIoBase, unsigned int uKeyLen,
-		unsigned int uKeyIdx, unsigned long *pdwKey, BYTE byLocalID)
+		unsigned int uKeyIdx, unsigned long *pdwKey, unsigned char byLocalID)
 {
 unsigned short wOffset;
 unsigned long dwData;
@@ -1601,7 +1601,7 @@ int     ii;
  *
  */
 /*
-void MACvEnableDefaultKey (unsigned long dwIoBase, BYTE byLocalID)
+void MACvEnableDefaultKey (unsigned long dwIoBase, unsigned char byLocalID)
 {
 unsigned short wOffset;
 unsigned long dwData;
@@ -1667,7 +1667,7 @@ unsigned long dwData;
  *
  */
 void MACvSetDefaultTKIPKeyEntry (unsigned long dwIoBase, unsigned int uKeyLen,
-		unsigned int uKeyIdx, unsigned long *pdwKey, BYTE byLocalID)
+		unsigned int uKeyIdx, unsigned long *pdwKey, unsigned char byLocalID)
 {
 unsigned short wOffset;
 unsigned long dwData;
@@ -1723,7 +1723,7 @@ int     ii;
  *
  */
 
-void MACvSetDefaultKeyCtl (unsigned long dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx, BYTE byLocalID)
+void MACvSetDefaultKeyCtl (unsigned long dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx, unsigned char byLocalID)
 {
 unsigned short wOffset;
 unsigned long dwData;

commit 2986db5fd31e312206d3ebfa4786aac04bdbe486
Author: Charles Clément <caratorn@gmail.com>
Date:   Thu Jun 24 11:02:26 2010 -0700

    Staging: vt6655: remove WORD typedef
    
    Replace all occurrences with unsigned short type.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 4971a03e74b1..1232bfe6d666 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -72,7 +72,7 @@
 #include "tether.h"
 #include "mac.h"
 
-WORD TxRate_iwconfig;//2008-5-8 <add> by chester
+unsigned short TxRate_iwconfig;//2008-5-8 <add> by chester
 /*---------------------  Static Definitions -------------------------*/
 //static int          msglevel                =MSG_LEVEL_DEBUG;
 static int          msglevel                =MSG_LEVEL_INFO;
@@ -583,7 +583,7 @@ BOOL MACbIsInLoopbackMode (unsigned long dwIoBase)
  * Return Value: none
  *
  */
-void MACvSetPacketFilter (unsigned long dwIoBase, WORD wFilterType)
+void MACvSetPacketFilter (unsigned long dwIoBase, unsigned short wFilterType)
 {
     BYTE    byOldRCR;
     BYTE    byNewRCR = 0;
@@ -776,7 +776,7 @@ BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 BOOL MACbSoftwareReset (unsigned long dwIoBase)
 {
     BYTE    byData;
-    WORD    ww;
+    unsigned short ww;
 
     // turn on HOSTCR_SOFTRST, just write 0x01 to reset
     //MACvRegBitsOn(dwIoBase, MAC_REG_HOSTCR, HOSTCR_SOFTRST);
@@ -841,7 +841,7 @@ BOOL MACbSafeSoftwareReset (unsigned long dwIoBase)
  */
 BOOL MACbSafeRxOff (unsigned long dwIoBase)
 {
-    WORD    ww;
+    unsigned short ww;
     unsigned long dwData;
     BYTE    byData;
 
@@ -902,7 +902,7 @@ BOOL MACbSafeRxOff (unsigned long dwIoBase)
  */
 BOOL MACbSafeTxOff (unsigned long dwIoBase)
 {
-    WORD    ww;
+    unsigned short ww;
     unsigned long dwData;
     BYTE    byData;
 
@@ -1081,7 +1081,7 @@ void MACvInitialize (unsigned long dwIoBase)
  */
 void MACvSetCurrRx0DescAddr (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
-WORD    ww;
+unsigned short ww;
 BYTE    byData;
 BYTE    byOrgDMACtl;
 
@@ -1119,7 +1119,7 @@ BYTE    byOrgDMACtl;
  */
 void MACvSetCurrRx1DescAddr (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
-WORD    ww;
+unsigned short ww;
 BYTE    byData;
 BYTE    byOrgDMACtl;
 
@@ -1157,7 +1157,7 @@ BYTE    byOrgDMACtl;
  */
 void MACvSetCurrTx0DescAddrEx (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
-WORD    ww;
+unsigned short ww;
 BYTE    byData;
 BYTE    byOrgDMACtl;
 
@@ -1196,7 +1196,7 @@ BYTE    byOrgDMACtl;
  //TxDMA1 = AC0DMA
 void MACvSetCurrAC0DescAddrEx (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
-WORD    ww;
+unsigned short ww;
 BYTE    byData;
 BYTE    byOrgDMACtl;
 
@@ -1309,7 +1309,7 @@ void MACvOneShotTimer1MicroSec (unsigned long dwIoBase, unsigned int uDelayTime)
 }
 
 
-void MACvSetMISCFifo (unsigned long dwIoBase, WORD wOffset, unsigned long dwData)
+void MACvSetMISCFifo (unsigned long dwIoBase, unsigned short wOffset, unsigned long dwData)
 {
     if (wOffset > 273)
         return;
@@ -1455,10 +1455,10 @@ BOOL MACbPSWakeup (unsigned long dwIoBase)
  *
  */
 
-void MACvSetKeyEntry (unsigned long dwIoBase, WORD wKeyCtl, unsigned int uEntryIdx,
+void MACvSetKeyEntry (unsigned long dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx,
 		unsigned int uKeyIdx, unsigned char *pbyAddr, unsigned long *pdwKey, BYTE byLocalID)
 {
-WORD    wOffset;
+unsigned short wOffset;
 unsigned long dwData;
 int     ii;
 
@@ -1524,7 +1524,7 @@ int     ii;
  */
 void MACvDisableKeyEntry (unsigned long dwIoBase, unsigned int uEntryIdx)
 {
-WORD    wOffset;
+unsigned short wOffset;
 
     wOffset = MISCFIFO_KEYETRY0;
     wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
@@ -1553,7 +1553,7 @@ WORD    wOffset;
 void MACvSetDefaultKeyEntry (unsigned long dwIoBase, unsigned int uKeyLen,
 		unsigned int uKeyIdx, unsigned long *pdwKey, BYTE byLocalID)
 {
-WORD    wOffset;
+unsigned short wOffset;
 unsigned long dwData;
 int     ii;
 
@@ -1603,7 +1603,7 @@ int     ii;
 /*
 void MACvEnableDefaultKey (unsigned long dwIoBase, BYTE byLocalID)
 {
-WORD    wOffset;
+unsigned short wOffset;
 unsigned long dwData;
 
 
@@ -1638,7 +1638,7 @@ unsigned long dwData;
  */
 void MACvDisableDefaultKey (unsigned long dwIoBase)
 {
-WORD    wOffset;
+unsigned short wOffset;
 unsigned long dwData;
 
 
@@ -1669,7 +1669,7 @@ unsigned long dwData;
 void MACvSetDefaultTKIPKeyEntry (unsigned long dwIoBase, unsigned int uKeyLen,
 		unsigned int uKeyIdx, unsigned long *pdwKey, BYTE byLocalID)
 {
-WORD    wOffset;
+unsigned short wOffset;
 unsigned long dwData;
 int     ii;
 
@@ -1723,9 +1723,9 @@ int     ii;
  *
  */
 
-void MACvSetDefaultKeyCtl (unsigned long dwIoBase, WORD wKeyCtl, unsigned int uEntryIdx, BYTE byLocalID)
+void MACvSetDefaultKeyCtl (unsigned long dwIoBase, unsigned short wKeyCtl, unsigned int uEntryIdx, BYTE byLocalID)
 {
-WORD    wOffset;
+unsigned short wOffset;
 unsigned long dwData;
 
     if (byLocalID <= 1)

commit 0f4c60d61e9c10a0733eacd650c101189bdf75cd
Author: Charles Clément <caratorn@gmail.com>
Date:   Thu Jun 24 11:02:25 2010 -0700

    Staging: vt6655: remove DWORD typedef
    
    Replace all occurrences with unsigned long type, except for pointer fields that
    should be u32 in packed structures and 8-byte-aligned 8 byte long structure
    QWORD.
    
    Thanks to Jiri Slaby for pointing out that simply replacing by unsigned long is
    wrong on x86-64 arch.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 02616892bda5..4971a03e74b1 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -186,7 +186,7 @@ BOOL MACbIsRegBitsOff (unsigned long dwIoBase, BYTE byRegOfs, BYTE byTestBits)
  */
 BOOL MACbIsIntDisable (unsigned long dwIoBase)
 {
-    DWORD dwData;
+    unsigned long dwData;
 
     VNSvInPortD(dwIoBase + MAC_REG_IMR, &dwData);
     if (dwData != 0)
@@ -595,7 +595,7 @@ void MACvSetPacketFilter (unsigned long dwIoBase, WORD wFilterType)
         // set multicast address to accept none
         MACvSelectPage1(dwIoBase);
         VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0L);
-        VNSvOutPortD(dwIoBase + MAC_REG_MAR0 + sizeof(DWORD), 0L);
+        VNSvOutPortD(dwIoBase + MAC_REG_MAR0 + sizeof(unsigned long), 0L);
         MACvSelectPage0(dwIoBase);
     }
 
@@ -603,7 +603,7 @@ void MACvSetPacketFilter (unsigned long dwIoBase, WORD wFilterType)
         // set multicast address to accept all
         MACvSelectPage1(dwIoBase);
         VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0xFFFFFFFFL);
-        VNSvOutPortD(dwIoBase + MAC_REG_MAR0 + sizeof(DWORD), 0xFFFFFFFFL);
+        VNSvOutPortD(dwIoBase + MAC_REG_MAR0 + sizeof(unsigned long), 0xFFFFFFFFL);
         MACvSelectPage0(dwIoBase);
     }
 
@@ -730,7 +730,7 @@ void MACvRestoreContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
  */
 BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 {
-    DWORD       dwData;
+    unsigned long dwData;
 
     // compare MAC context to determine if this is a power lost init,
     // return TRUE for power remaining init, return FALSE for power lost init
@@ -842,7 +842,7 @@ BOOL MACbSafeSoftwareReset (unsigned long dwIoBase)
 BOOL MACbSafeRxOff (unsigned long dwIoBase)
 {
     WORD    ww;
-    DWORD   dwData;
+    unsigned long dwData;
     BYTE    byData;
 
     // turn off wow temp for turn off Rx safely
@@ -903,7 +903,7 @@ BOOL MACbSafeRxOff (unsigned long dwIoBase)
 BOOL MACbSafeTxOff (unsigned long dwIoBase)
 {
     WORD    ww;
-    DWORD   dwData;
+    unsigned long dwData;
     BYTE    byData;
 
     // Clear TX DMA
@@ -1079,7 +1079,7 @@ void MACvInitialize (unsigned long dwIoBase)
  * Return Value: none
  *
  */
-void MACvSetCurrRx0DescAddr (unsigned long dwIoBase, DWORD dwCurrDescAddr)
+void MACvSetCurrRx0DescAddr (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
 WORD    ww;
 BYTE    byData;
@@ -1117,7 +1117,7 @@ BYTE    byOrgDMACtl;
  * Return Value: none
  *
  */
-void MACvSetCurrRx1DescAddr (unsigned long dwIoBase, DWORD dwCurrDescAddr)
+void MACvSetCurrRx1DescAddr (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
 WORD    ww;
 BYTE    byData;
@@ -1155,7 +1155,7 @@ BYTE    byOrgDMACtl;
  * Return Value: none
  *
  */
-void MACvSetCurrTx0DescAddrEx (unsigned long dwIoBase, DWORD dwCurrDescAddr)
+void MACvSetCurrTx0DescAddrEx (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
 WORD    ww;
 BYTE    byData;
@@ -1194,7 +1194,7 @@ BYTE    byOrgDMACtl;
  *
  */
  //TxDMA1 = AC0DMA
-void MACvSetCurrAC0DescAddrEx (unsigned long dwIoBase, DWORD dwCurrDescAddr)
+void MACvSetCurrAC0DescAddrEx (unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
 WORD    ww;
 BYTE    byData;
@@ -1221,7 +1221,7 @@ BYTE    byOrgDMACtl;
 
 
 
-void MACvSetCurrTXDescAddr (int iTxType, unsigned long dwIoBase, DWORD dwCurrDescAddr)
+void MACvSetCurrTXDescAddr (int iTxType, unsigned long dwIoBase, unsigned long dwCurrDescAddr)
 {
     if(iTxType == TYPE_AC0DMA){
         MACvSetCurrAC0DescAddrEx(dwIoBase, dwCurrDescAddr);
@@ -1309,7 +1309,7 @@ void MACvOneShotTimer1MicroSec (unsigned long dwIoBase, unsigned int uDelayTime)
 }
 
 
-void MACvSetMISCFifo (unsigned long dwIoBase, WORD wOffset, DWORD dwData)
+void MACvSetMISCFifo (unsigned long dwIoBase, WORD wOffset, unsigned long dwData)
 {
     if (wOffset > 273)
         return;
@@ -1349,7 +1349,7 @@ unsigned int ww = 0;
 
 void MACvClearBusSusInd (unsigned long dwIoBase)
 {
-    DWORD dwOrgValue;
+    unsigned long dwOrgValue;
     unsigned int ww;
     // check if BcnSusInd enabled
     VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
@@ -1372,7 +1372,7 @@ void MACvClearBusSusInd (unsigned long dwIoBase)
 void MACvEnableBusSusEn (unsigned long dwIoBase)
 {
     BYTE  byOrgValue;
-    DWORD dwOrgValue;
+    unsigned long dwOrgValue;
     unsigned int ww;
     // check if BcnSusInd enabled
     VNSvInPortB(dwIoBase + MAC_REG_CFG , &byOrgValue);
@@ -1459,7 +1459,7 @@ void MACvSetKeyEntry (unsigned long dwIoBase, WORD wKeyCtl, unsigned int uEntryI
 		unsigned int uKeyIdx, unsigned char *pbyAddr, unsigned long *pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
-DWORD   dwData;
+unsigned long dwData;
 int     ii;
 
     if (byLocalID <= 1)
@@ -1554,7 +1554,7 @@ void MACvSetDefaultKeyEntry (unsigned long dwIoBase, unsigned int uKeyLen,
 		unsigned int uKeyIdx, unsigned long *pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
-DWORD   dwData;
+unsigned long dwData;
 int     ii;
 
     if (byLocalID <= 1)
@@ -1604,7 +1604,7 @@ int     ii;
 void MACvEnableDefaultKey (unsigned long dwIoBase, BYTE byLocalID)
 {
 WORD    wOffset;
-DWORD   dwData;
+unsigned long dwData;
 
 
     if (byLocalID <= 1)
@@ -1639,7 +1639,7 @@ DWORD   dwData;
 void MACvDisableDefaultKey (unsigned long dwIoBase)
 {
 WORD    wOffset;
-DWORD   dwData;
+unsigned long dwData;
 
 
     wOffset = MISCFIFO_KEYETRY0;
@@ -1670,7 +1670,7 @@ void MACvSetDefaultTKIPKeyEntry (unsigned long dwIoBase, unsigned int uKeyLen,
 		unsigned int uKeyIdx, unsigned long *pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
-DWORD   dwData;
+unsigned long dwData;
 int     ii;
 
     if (byLocalID <= 1)
@@ -1726,7 +1726,7 @@ int     ii;
 void MACvSetDefaultKeyCtl (unsigned long dwIoBase, WORD wKeyCtl, unsigned int uEntryIdx, BYTE byLocalID)
 {
 WORD    wOffset;
-DWORD   dwData;
+unsigned long dwData;
 
     if (byLocalID <= 1)
         return;

commit 412b2d08b93165303d698267d1eeac19e14e67a4
Author: Charles Clément <caratorn@gmail.com>
Date:   Tue Jun 22 08:54:42 2010 -0700

    Staging: vt6655: remove DWORD_PTR pointer typedef
    
    Use unsigned long instead.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 9ec1248bbf98..02616892bda5 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -103,7 +103,7 @@ static int          msglevel                =MSG_LEVEL_INFO;
  * Return Value: none
  *
  */
-void MACvReadAllRegs (DWORD_PTR dwIoBase, unsigned char *pbyMacRegs)
+void MACvReadAllRegs (unsigned long dwIoBase, unsigned char *pbyMacRegs)
 {
     int ii;
 
@@ -140,7 +140,7 @@ void MACvReadAllRegs (DWORD_PTR dwIoBase, unsigned char *pbyMacRegs)
  * Return Value: TRUE if all test bits On; otherwise FALSE
  *
  */
-BOOL MACbIsRegBitsOn (DWORD_PTR dwIoBase, BYTE byRegOfs, BYTE byTestBits)
+BOOL MACbIsRegBitsOn (unsigned long dwIoBase, BYTE byRegOfs, BYTE byTestBits)
 {
     BYTE byData;
 
@@ -163,7 +163,7 @@ BOOL MACbIsRegBitsOn (DWORD_PTR dwIoBase, BYTE byRegOfs, BYTE byTestBits)
  * Return Value: TRUE if all test bits Off; otherwise FALSE
  *
  */
-BOOL MACbIsRegBitsOff (DWORD_PTR dwIoBase, BYTE byRegOfs, BYTE byTestBits)
+BOOL MACbIsRegBitsOff (unsigned long dwIoBase, BYTE byRegOfs, BYTE byTestBits)
 {
     BYTE byData;
 
@@ -184,7 +184,7 @@ BOOL MACbIsRegBitsOff (DWORD_PTR dwIoBase, BYTE byRegOfs, BYTE byTestBits)
  * Return Value: TRUE if interrupt is disable; otherwise FALSE
  *
  */
-BOOL MACbIsIntDisable (DWORD_PTR dwIoBase)
+BOOL MACbIsIntDisable (unsigned long dwIoBase)
 {
     DWORD dwData;
 
@@ -209,7 +209,7 @@ BOOL MACbIsIntDisable (DWORD_PTR dwIoBase)
  * Return Value: Mask Value read
  *
  */
-BYTE MACbyReadMultiAddr (DWORD_PTR dwIoBase, unsigned int uByteIdx)
+BYTE MACbyReadMultiAddr (unsigned long dwIoBase, unsigned int uByteIdx)
 {
     BYTE byData;
 
@@ -234,7 +234,7 @@ BYTE MACbyReadMultiAddr (DWORD_PTR dwIoBase, unsigned int uByteIdx)
  * Return Value: none
  *
  */
-void MACvWriteMultiAddr (DWORD_PTR dwIoBase, unsigned int uByteIdx, BYTE byData)
+void MACvWriteMultiAddr (unsigned long dwIoBase, unsigned int uByteIdx, BYTE byData)
 {
     MACvSelectPage1(dwIoBase);
     VNSvOutPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, byData);
@@ -255,7 +255,7 @@ void MACvWriteMultiAddr (DWORD_PTR dwIoBase, unsigned int uByteIdx, BYTE byData)
  * Return Value: none
  *
  */
-void MACvSetMultiAddrByHash (DWORD_PTR dwIoBase, BYTE byHashIdx)
+void MACvSetMultiAddrByHash (unsigned long dwIoBase, BYTE byHashIdx)
 {
     unsigned int uByteIdx;
     BYTE byBitMask;
@@ -286,7 +286,7 @@ void MACvSetMultiAddrByHash (DWORD_PTR dwIoBase, BYTE byHashIdx)
  * Return Value: none
  *
  */
-void MACvResetMultiAddrByHash (DWORD_PTR dwIoBase, BYTE byHashIdx)
+void MACvResetMultiAddrByHash (unsigned long dwIoBase, BYTE byHashIdx)
 {
     unsigned int uByteIdx;
     BYTE byBitMask;
@@ -317,7 +317,7 @@ void MACvResetMultiAddrByHash (DWORD_PTR dwIoBase, BYTE byHashIdx)
  * Return Value: none
  *
  */
-void MACvSetRxThreshold (DWORD_PTR dwIoBase, BYTE byThreshold)
+void MACvSetRxThreshold (unsigned long dwIoBase, BYTE byThreshold)
 {
     BYTE byOrgValue;
 
@@ -342,7 +342,7 @@ void MACvSetRxThreshold (DWORD_PTR dwIoBase, BYTE byThreshold)
  * Return Value: none
  *
  */
-void MACvGetRxThreshold (DWORD_PTR dwIoBase, unsigned char *pbyThreshold)
+void MACvGetRxThreshold (unsigned long dwIoBase, unsigned char *pbyThreshold)
 {
     // get FCR0
     VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
@@ -363,7 +363,7 @@ void MACvGetRxThreshold (DWORD_PTR dwIoBase, unsigned char *pbyThreshold)
  * Return Value: none
  *
  */
-void MACvSetTxThreshold (DWORD_PTR dwIoBase, BYTE byThreshold)
+void MACvSetTxThreshold (unsigned long dwIoBase, BYTE byThreshold)
 {
     BYTE byOrgValue;
 
@@ -388,7 +388,7 @@ void MACvSetTxThreshold (DWORD_PTR dwIoBase, BYTE byThreshold)
  * Return Value: none
  *
  */
-void MACvGetTxThreshold (DWORD_PTR dwIoBase, unsigned char *pbyThreshold)
+void MACvGetTxThreshold (unsigned long dwIoBase, unsigned char *pbyThreshold)
 {
     // get FCR0
     VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
@@ -409,7 +409,7 @@ void MACvGetTxThreshold (DWORD_PTR dwIoBase, unsigned char *pbyThreshold)
  * Return Value: none
  *
  */
-void MACvSetDmaLength (DWORD_PTR dwIoBase, BYTE byDmaLength)
+void MACvSetDmaLength (unsigned long dwIoBase, BYTE byDmaLength)
 {
     BYTE byOrgValue;
 
@@ -434,7 +434,7 @@ void MACvSetDmaLength (DWORD_PTR dwIoBase, BYTE byDmaLength)
  * Return Value: none
  *
  */
-void MACvGetDmaLength (DWORD_PTR dwIoBase, unsigned char *pbyDmaLength)
+void MACvGetDmaLength (unsigned long dwIoBase, unsigned char *pbyDmaLength)
 {
     // get FCR0
     VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyDmaLength);
@@ -455,7 +455,7 @@ void MACvGetDmaLength (DWORD_PTR dwIoBase, unsigned char *pbyDmaLength)
  * Return Value: none
  *
  */
-void MACvSetShortRetryLimit (DWORD_PTR dwIoBase, BYTE byRetryLimit)
+void MACvSetShortRetryLimit (unsigned long dwIoBase, BYTE byRetryLimit)
 {
     // set SRT
     VNSvOutPortB(dwIoBase + MAC_REG_SRT, byRetryLimit);
@@ -474,7 +474,7 @@ void MACvSetShortRetryLimit (DWORD_PTR dwIoBase, BYTE byRetryLimit)
  * Return Value: none
  *
  */
-void MACvGetShortRetryLimit (DWORD_PTR dwIoBase, unsigned char *pbyRetryLimit)
+void MACvGetShortRetryLimit (unsigned long dwIoBase, unsigned char *pbyRetryLimit)
 {
     // get SRT
     VNSvInPortB(dwIoBase + MAC_REG_SRT, pbyRetryLimit);
@@ -494,7 +494,7 @@ void MACvGetShortRetryLimit (DWORD_PTR dwIoBase, unsigned char *pbyRetryLimit)
  * Return Value: none
  *
  */
-void MACvSetLongRetryLimit (DWORD_PTR dwIoBase, BYTE byRetryLimit)
+void MACvSetLongRetryLimit (unsigned long dwIoBase, BYTE byRetryLimit)
 {
     // set LRT
     VNSvOutPortB(dwIoBase + MAC_REG_LRT, byRetryLimit);
@@ -513,7 +513,7 @@ void MACvSetLongRetryLimit (DWORD_PTR dwIoBase, BYTE byRetryLimit)
  * Return Value: none
  *
  */
-void MACvGetLongRetryLimit (DWORD_PTR dwIoBase, unsigned char *pbyRetryLimit)
+void MACvGetLongRetryLimit (unsigned long dwIoBase, unsigned char *pbyRetryLimit)
 {
     // get LRT
     VNSvInPortB(dwIoBase + MAC_REG_LRT, pbyRetryLimit);
@@ -533,7 +533,7 @@ void MACvGetLongRetryLimit (DWORD_PTR dwIoBase, unsigned char *pbyRetryLimit)
  * Return Value: none
  *
  */
-void MACvSetLoopbackMode (DWORD_PTR dwIoBase, BYTE byLoopbackMode)
+void MACvSetLoopbackMode (unsigned long dwIoBase, BYTE byLoopbackMode)
 {
     BYTE byOrgValue;
 
@@ -559,7 +559,7 @@ void MACvSetLoopbackMode (DWORD_PTR dwIoBase, BYTE byLoopbackMode)
  * Return Value: TRUE if in Loopback mode; otherwise FALSE
  *
  */
-BOOL MACbIsInLoopbackMode (DWORD_PTR dwIoBase)
+BOOL MACbIsInLoopbackMode (unsigned long dwIoBase)
 {
     BYTE byOrgValue;
 
@@ -583,7 +583,7 @@ BOOL MACbIsInLoopbackMode (DWORD_PTR dwIoBase)
  * Return Value: none
  *
  */
-void MACvSetPacketFilter (DWORD_PTR dwIoBase, WORD wFilterType)
+void MACvSetPacketFilter (unsigned long dwIoBase, WORD wFilterType)
 {
     BYTE    byOldRCR;
     BYTE    byNewRCR = 0;
@@ -643,7 +643,7 @@ void MACvSetPacketFilter (DWORD_PTR dwIoBase, WORD wFilterType)
  * Return Value: none
  *
  */
-void MACvSaveContext (DWORD_PTR dwIoBase, unsigned char *pbyCxtBuf)
+void MACvSaveContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 {
     int         ii;
 
@@ -676,7 +676,7 @@ void MACvSaveContext (DWORD_PTR dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: none
  *
  */
-void MACvRestoreContext (DWORD_PTR dwIoBase, unsigned char *pbyCxtBuf)
+void MACvRestoreContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 {
     int         ii;
 
@@ -728,7 +728,7 @@ void MACvRestoreContext (DWORD_PTR dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: TRUE if all values are the same; otherwise FALSE
  *
  */
-BOOL MACbCompareContext (DWORD_PTR dwIoBase, unsigned char *pbyCxtBuf)
+BOOL MACbCompareContext (unsigned long dwIoBase, unsigned char *pbyCxtBuf)
 {
     DWORD       dwData;
 
@@ -773,7 +773,7 @@ BOOL MACbCompareContext (DWORD_PTR dwIoBase, unsigned char *pbyCxtBuf)
  * Return Value: TRUE if Reset Success; otherwise FALSE
  *
  */
-BOOL MACbSoftwareReset (DWORD_PTR dwIoBase)
+BOOL MACbSoftwareReset (unsigned long dwIoBase)
 {
     BYTE    byData;
     WORD    ww;
@@ -806,7 +806,7 @@ BOOL MACbSoftwareReset (DWORD_PTR dwIoBase)
  * Return Value: TRUE if success; otherwise FALSE
  *
  */
-BOOL MACbSafeSoftwareReset (DWORD_PTR dwIoBase)
+BOOL MACbSafeSoftwareReset (unsigned long dwIoBase)
 {
     BYTE    abyTmpRegData[MAC_MAX_CONTEXT_SIZE_PAGE0+MAC_MAX_CONTEXT_SIZE_PAGE1];
     BOOL    bRetVal;
@@ -839,7 +839,7 @@ BOOL MACbSafeSoftwareReset (DWORD_PTR dwIoBase)
  * Return Value: TRUE if success; otherwise FALSE
  *
  */
-BOOL MACbSafeRxOff (DWORD_PTR dwIoBase)
+BOOL MACbSafeRxOff (unsigned long dwIoBase)
 {
     WORD    ww;
     DWORD   dwData;
@@ -900,7 +900,7 @@ BOOL MACbSafeRxOff (DWORD_PTR dwIoBase)
  * Return Value: TRUE if success; otherwise FALSE
  *
  */
-BOOL MACbSafeTxOff (DWORD_PTR dwIoBase)
+BOOL MACbSafeTxOff (unsigned long dwIoBase)
 {
     WORD    ww;
     DWORD   dwData;
@@ -964,7 +964,7 @@ BOOL MACbSafeTxOff (DWORD_PTR dwIoBase)
  * Return Value: TRUE if success; otherwise FALSE
  *
  */
-BOOL MACbSafeStop (DWORD_PTR dwIoBase)
+BOOL MACbSafeStop (unsigned long dwIoBase)
 {
     MACvRegBitsOff(dwIoBase, MAC_REG_TCR, TCR_AUTOBCNTX);
 
@@ -999,7 +999,7 @@ BOOL MACbSafeStop (DWORD_PTR dwIoBase)
  * Return Value: TRUE if success; otherwise FALSE
  *
  */
-BOOL MACbShutdown (DWORD_PTR dwIoBase)
+BOOL MACbShutdown (unsigned long dwIoBase)
 {
     // disable MAC IMR
     MACvIntDisable(dwIoBase);
@@ -1026,7 +1026,7 @@ BOOL MACbShutdown (DWORD_PTR dwIoBase)
  * Return Value: none
  *
  */
-void MACvInitialize (DWORD_PTR dwIoBase)
+void MACvInitialize (unsigned long dwIoBase)
 {
     // clear sticky bits
     MACvClearStckDS(dwIoBase);
@@ -1079,7 +1079,7 @@ void MACvInitialize (DWORD_PTR dwIoBase)
  * Return Value: none
  *
  */
-void MACvSetCurrRx0DescAddr (DWORD_PTR dwIoBase, DWORD dwCurrDescAddr)
+void MACvSetCurrRx0DescAddr (unsigned long dwIoBase, DWORD dwCurrDescAddr)
 {
 WORD    ww;
 BYTE    byData;
@@ -1117,7 +1117,7 @@ BYTE    byOrgDMACtl;
  * Return Value: none
  *
  */
-void MACvSetCurrRx1DescAddr (DWORD_PTR dwIoBase, DWORD dwCurrDescAddr)
+void MACvSetCurrRx1DescAddr (unsigned long dwIoBase, DWORD dwCurrDescAddr)
 {
 WORD    ww;
 BYTE    byData;
@@ -1155,7 +1155,7 @@ BYTE    byOrgDMACtl;
  * Return Value: none
  *
  */
-void MACvSetCurrTx0DescAddrEx (DWORD_PTR dwIoBase, DWORD dwCurrDescAddr)
+void MACvSetCurrTx0DescAddrEx (unsigned long dwIoBase, DWORD dwCurrDescAddr)
 {
 WORD    ww;
 BYTE    byData;
@@ -1194,7 +1194,7 @@ BYTE    byOrgDMACtl;
  *
  */
  //TxDMA1 = AC0DMA
-void MACvSetCurrAC0DescAddrEx (DWORD_PTR dwIoBase, DWORD dwCurrDescAddr)
+void MACvSetCurrAC0DescAddrEx (unsigned long dwIoBase, DWORD dwCurrDescAddr)
 {
 WORD    ww;
 BYTE    byData;
@@ -1221,7 +1221,7 @@ BYTE    byOrgDMACtl;
 
 
 
-void MACvSetCurrTXDescAddr (int iTxType, DWORD_PTR dwIoBase, DWORD dwCurrDescAddr)
+void MACvSetCurrTXDescAddr (int iTxType, unsigned long dwIoBase, DWORD dwCurrDescAddr)
 {
     if(iTxType == TYPE_AC0DMA){
         MACvSetCurrAC0DescAddrEx(dwIoBase, dwCurrDescAddr);
@@ -1244,7 +1244,7 @@ void MACvSetCurrTXDescAddr (int iTxType, DWORD_PTR dwIoBase, DWORD dwCurrDescAdd
  * Return Value: none
  *
  */
-void MACvTimer0MicroSDelay (DWORD_PTR dwIoBase, unsigned int uDelay)
+void MACvTimer0MicroSDelay (unsigned long dwIoBase, unsigned int uDelay)
 {
 BYTE byValue;
 unsigned int uu,ii;
@@ -1280,7 +1280,7 @@ unsigned int uu,ii;
  * Return Value: none
  *
  */
-void MACvOneShotTimer0MicroSec (DWORD_PTR dwIoBase, unsigned int uDelayTime)
+void MACvOneShotTimer0MicroSec (unsigned long dwIoBase, unsigned int uDelayTime)
 {
     VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
     VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelayTime);
@@ -1301,7 +1301,7 @@ void MACvOneShotTimer0MicroSec (DWORD_PTR dwIoBase, unsigned int uDelayTime)
  * Return Value: none
  *
  */
-void MACvOneShotTimer1MicroSec (DWORD_PTR dwIoBase, unsigned int uDelayTime)
+void MACvOneShotTimer1MicroSec (unsigned long dwIoBase, unsigned int uDelayTime)
 {
     VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, 0);
     VNSvOutPortD(dwIoBase + MAC_REG_TMDATA1, uDelayTime);
@@ -1309,7 +1309,7 @@ void MACvOneShotTimer1MicroSec (DWORD_PTR dwIoBase, unsigned int uDelayTime)
 }
 
 
-void MACvSetMISCFifo (DWORD_PTR dwIoBase, WORD wOffset, DWORD dwData)
+void MACvSetMISCFifo (unsigned long dwIoBase, WORD wOffset, DWORD dwData)
 {
     if (wOffset > 273)
         return;
@@ -1319,7 +1319,7 @@ void MACvSetMISCFifo (DWORD_PTR dwIoBase, WORD wOffset, DWORD dwData)
 }
 
 
-BOOL MACbTxDMAOff (DWORD_PTR dwIoBase, unsigned int idx)
+BOOL MACbTxDMAOff (unsigned long dwIoBase, unsigned int idx)
 {
 BYTE byData;
 unsigned int ww = 0;
@@ -1347,7 +1347,7 @@ unsigned int ww = 0;
     return TRUE;
 }
 
-void MACvClearBusSusInd (DWORD_PTR dwIoBase)
+void MACvClearBusSusInd (unsigned long dwIoBase)
 {
     DWORD dwOrgValue;
     unsigned int ww;
@@ -1369,7 +1369,7 @@ void MACvClearBusSusInd (DWORD_PTR dwIoBase)
     }
 }
 
-void MACvEnableBusSusEn (DWORD_PTR dwIoBase)
+void MACvEnableBusSusEn (unsigned long dwIoBase)
 {
     BYTE  byOrgValue;
     DWORD dwOrgValue;
@@ -1391,7 +1391,7 @@ void MACvEnableBusSusEn (DWORD_PTR dwIoBase)
     }
 }
 
-BOOL MACbFlushSYNCFifo (DWORD_PTR dwIoBase)
+BOOL MACbFlushSYNCFifo (unsigned long dwIoBase)
 {
     BYTE  byOrgValue;
     unsigned int ww;
@@ -1415,7 +1415,7 @@ BOOL MACbFlushSYNCFifo (DWORD_PTR dwIoBase)
     return TRUE;
 }
 
-BOOL MACbPSWakeup (DWORD_PTR dwIoBase)
+BOOL MACbPSWakeup (unsigned long dwIoBase)
 {
     BYTE  byOrgValue;
     unsigned int ww;
@@ -1455,7 +1455,7 @@ BOOL MACbPSWakeup (DWORD_PTR dwIoBase)
  *
  */
 
-void MACvSetKeyEntry (DWORD_PTR dwIoBase, WORD wKeyCtl, unsigned int uEntryIdx,
+void MACvSetKeyEntry (unsigned long dwIoBase, WORD wKeyCtl, unsigned int uEntryIdx,
 		unsigned int uKeyIdx, unsigned char *pbyAddr, unsigned long *pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
@@ -1522,7 +1522,7 @@ int     ii;
  * Return Value: none
  *
  */
-void MACvDisableKeyEntry (DWORD_PTR dwIoBase, unsigned int uEntryIdx)
+void MACvDisableKeyEntry (unsigned long dwIoBase, unsigned int uEntryIdx)
 {
 WORD    wOffset;
 
@@ -1550,7 +1550,7 @@ WORD    wOffset;
  *
  */
 
-void MACvSetDefaultKeyEntry (DWORD_PTR dwIoBase, unsigned int uKeyLen,
+void MACvSetDefaultKeyEntry (unsigned long dwIoBase, unsigned int uKeyLen,
 		unsigned int uKeyIdx, unsigned long *pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
@@ -1601,7 +1601,7 @@ int     ii;
  *
  */
 /*
-void MACvEnableDefaultKey (DWORD_PTR dwIoBase, BYTE byLocalID)
+void MACvEnableDefaultKey (unsigned long dwIoBase, BYTE byLocalID)
 {
 WORD    wOffset;
 DWORD   dwData;
@@ -1636,7 +1636,7 @@ DWORD   dwData;
  * Return Value: none
  *
  */
-void MACvDisableDefaultKey (DWORD_PTR dwIoBase)
+void MACvDisableDefaultKey (unsigned long dwIoBase)
 {
 WORD    wOffset;
 DWORD   dwData;
@@ -1666,7 +1666,7 @@ DWORD   dwData;
  * Return Value: none
  *
  */
-void MACvSetDefaultTKIPKeyEntry (DWORD_PTR dwIoBase, unsigned int uKeyLen,
+void MACvSetDefaultTKIPKeyEntry (unsigned long dwIoBase, unsigned int uKeyLen,
 		unsigned int uKeyIdx, unsigned long *pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
@@ -1723,7 +1723,7 @@ int     ii;
  *
  */
 
-void MACvSetDefaultKeyCtl (DWORD_PTR dwIoBase, WORD wKeyCtl, unsigned int uEntryIdx, BYTE byLocalID)
+void MACvSetDefaultKeyCtl (unsigned long dwIoBase, WORD wKeyCtl, unsigned int uEntryIdx, BYTE byLocalID)
 {
 WORD    wOffset;
 DWORD   dwData;

commit 9d828c458f77043ddd9626ee0cfa688dda99c0eb
Author: Charles Clément <caratorn@gmail.com>
Date:   Sat Jun 5 15:13:49 2010 -0700

    Staging: vt6655: remove PDWORD typedef
    
    Use unsigned long * instead.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 9d54b421f770..9ec1248bbf98 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -703,14 +703,14 @@ void MACvRestoreContext (DWORD_PTR dwIoBase, unsigned char *pbyCxtBuf)
     }
 
     // restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
-    VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, *(PDWORD)(pbyCxtBuf + MAC_REG_TXDMAPTR0));
-    VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, *(PDWORD)(pbyCxtBuf + MAC_REG_AC0DMAPTR));
-    VNSvOutPortD(dwIoBase + MAC_REG_BCNDMAPTR, *(PDWORD)(pbyCxtBuf + MAC_REG_BCNDMAPTR));
+    VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0));
+    VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR));
+    VNSvOutPortD(dwIoBase + MAC_REG_BCNDMAPTR, *(unsigned long *)(pbyCxtBuf + MAC_REG_BCNDMAPTR));
 
 
-    VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, *(PDWORD)(pbyCxtBuf + MAC_REG_RXDMAPTR0));
+    VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0));
 
-    VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, *(PDWORD)(pbyCxtBuf + MAC_REG_RXDMAPTR1));
+    VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1));
 
 }
 
@@ -737,22 +737,22 @@ BOOL MACbCompareContext (DWORD_PTR dwIoBase, unsigned char *pbyCxtBuf)
 
     // compare CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
     VNSvInPortD(dwIoBase + MAC_REG_TXDMAPTR0, &dwData);
-    if (dwData != *(PDWORD)(pbyCxtBuf + MAC_REG_TXDMAPTR0)) {
+    if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_TXDMAPTR0)) {
         return FALSE;
     }
 
     VNSvInPortD(dwIoBase + MAC_REG_AC0DMAPTR, &dwData);
-    if (dwData != *(PDWORD)(pbyCxtBuf + MAC_REG_AC0DMAPTR)) {
+    if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_AC0DMAPTR)) {
         return FALSE;
     }
 
     VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR0, &dwData);
-    if (dwData != *(PDWORD)(pbyCxtBuf + MAC_REG_RXDMAPTR0)) {
+    if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR0)) {
         return FALSE;
     }
 
     VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR1, &dwData);
-    if (dwData != *(PDWORD)(pbyCxtBuf + MAC_REG_RXDMAPTR1)) {
+    if (dwData != *(unsigned long *)(pbyCxtBuf + MAC_REG_RXDMAPTR1)) {
         return FALSE;
     }
 
@@ -1456,7 +1456,7 @@ BOOL MACbPSWakeup (DWORD_PTR dwIoBase)
  */
 
 void MACvSetKeyEntry (DWORD_PTR dwIoBase, WORD wKeyCtl, unsigned int uEntryIdx,
-		unsigned int uKeyIdx, unsigned char *pbyAddr, PDWORD pdwKey, BYTE byLocalID)
+		unsigned int uKeyIdx, unsigned char *pbyAddr, unsigned long *pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
 DWORD   dwData;
@@ -1551,7 +1551,7 @@ WORD    wOffset;
  */
 
 void MACvSetDefaultKeyEntry (DWORD_PTR dwIoBase, unsigned int uKeyLen,
-		unsigned int uKeyIdx, PDWORD pdwKey, BYTE byLocalID)
+		unsigned int uKeyIdx, unsigned long *pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
 DWORD   dwData;
@@ -1667,7 +1667,7 @@ DWORD   dwData;
  *
  */
 void MACvSetDefaultTKIPKeyEntry (DWORD_PTR dwIoBase, unsigned int uKeyLen,
-		unsigned int uKeyIdx, PDWORD pdwKey, BYTE byLocalID)
+		unsigned int uKeyIdx, unsigned long *pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
 DWORD   dwData;

commit 2989e96f17f2dcbd73aee37856899c2885df0686
Author: Charles Clément <caratorn@gmail.com>
Date:   Sat Jun 5 15:13:47 2010 -0700

    Staging: vt6655: remove PBYTE typedef
    
    Use unsigned char * instead.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index f4acb2f3213f..9d54b421f770 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -103,7 +103,7 @@ static int          msglevel                =MSG_LEVEL_INFO;
  * Return Value: none
  *
  */
-void MACvReadAllRegs (DWORD_PTR dwIoBase, PBYTE pbyMacRegs)
+void MACvReadAllRegs (DWORD_PTR dwIoBase, unsigned char *pbyMacRegs)
 {
     int ii;
 
@@ -342,7 +342,7 @@ void MACvSetRxThreshold (DWORD_PTR dwIoBase, BYTE byThreshold)
  * Return Value: none
  *
  */
-void MACvGetRxThreshold (DWORD_PTR dwIoBase, PBYTE pbyThreshold)
+void MACvGetRxThreshold (DWORD_PTR dwIoBase, unsigned char *pbyThreshold)
 {
     // get FCR0
     VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
@@ -388,7 +388,7 @@ void MACvSetTxThreshold (DWORD_PTR dwIoBase, BYTE byThreshold)
  * Return Value: none
  *
  */
-void MACvGetTxThreshold (DWORD_PTR dwIoBase, PBYTE pbyThreshold)
+void MACvGetTxThreshold (DWORD_PTR dwIoBase, unsigned char *pbyThreshold)
 {
     // get FCR0
     VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
@@ -434,7 +434,7 @@ void MACvSetDmaLength (DWORD_PTR dwIoBase, BYTE byDmaLength)
  * Return Value: none
  *
  */
-void MACvGetDmaLength (DWORD_PTR dwIoBase, PBYTE pbyDmaLength)
+void MACvGetDmaLength (DWORD_PTR dwIoBase, unsigned char *pbyDmaLength)
 {
     // get FCR0
     VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyDmaLength);
@@ -474,7 +474,7 @@ void MACvSetShortRetryLimit (DWORD_PTR dwIoBase, BYTE byRetryLimit)
  * Return Value: none
  *
  */
-void MACvGetShortRetryLimit (DWORD_PTR dwIoBase, PBYTE pbyRetryLimit)
+void MACvGetShortRetryLimit (DWORD_PTR dwIoBase, unsigned char *pbyRetryLimit)
 {
     // get SRT
     VNSvInPortB(dwIoBase + MAC_REG_SRT, pbyRetryLimit);
@@ -513,7 +513,7 @@ void MACvSetLongRetryLimit (DWORD_PTR dwIoBase, BYTE byRetryLimit)
  * Return Value: none
  *
  */
-void MACvGetLongRetryLimit (DWORD_PTR dwIoBase, PBYTE pbyRetryLimit)
+void MACvGetLongRetryLimit (DWORD_PTR dwIoBase, unsigned char *pbyRetryLimit)
 {
     // get LRT
     VNSvInPortB(dwIoBase + MAC_REG_LRT, pbyRetryLimit);
@@ -643,7 +643,7 @@ void MACvSetPacketFilter (DWORD_PTR dwIoBase, WORD wFilterType)
  * Return Value: none
  *
  */
-void MACvSaveContext (DWORD_PTR dwIoBase, PBYTE pbyCxtBuf)
+void MACvSaveContext (DWORD_PTR dwIoBase, unsigned char *pbyCxtBuf)
 {
     int         ii;
 
@@ -676,7 +676,7 @@ void MACvSaveContext (DWORD_PTR dwIoBase, PBYTE pbyCxtBuf)
  * Return Value: none
  *
  */
-void MACvRestoreContext (DWORD_PTR dwIoBase, PBYTE pbyCxtBuf)
+void MACvRestoreContext (DWORD_PTR dwIoBase, unsigned char *pbyCxtBuf)
 {
     int         ii;
 
@@ -728,7 +728,7 @@ void MACvRestoreContext (DWORD_PTR dwIoBase, PBYTE pbyCxtBuf)
  * Return Value: TRUE if all values are the same; otherwise FALSE
  *
  */
-BOOL MACbCompareContext (DWORD_PTR dwIoBase, PBYTE pbyCxtBuf)
+BOOL MACbCompareContext (DWORD_PTR dwIoBase, unsigned char *pbyCxtBuf)
 {
     DWORD       dwData;
 
@@ -1456,7 +1456,7 @@ BOOL MACbPSWakeup (DWORD_PTR dwIoBase)
  */
 
 void MACvSetKeyEntry (DWORD_PTR dwIoBase, WORD wKeyCtl, unsigned int uEntryIdx,
-		unsigned int uKeyIdx, PBYTE pbyAddr, PDWORD pdwKey, BYTE byLocalID)
+		unsigned int uKeyIdx, unsigned char *pbyAddr, PDWORD pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
 DWORD   dwData;

commit b6e95cd52a81079abc1def7867e27bf541953089
Author: Charles Clément <caratorn@gmail.com>
Date:   Wed Jun 2 09:52:01 2010 -0700

    Staging: vt6655: remove custom UINT typedef
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index eae881c5a9f9..f4acb2f3213f 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -209,7 +209,7 @@ BOOL MACbIsIntDisable (DWORD_PTR dwIoBase)
  * Return Value: Mask Value read
  *
  */
-BYTE MACbyReadMultiAddr (DWORD_PTR dwIoBase, UINT uByteIdx)
+BYTE MACbyReadMultiAddr (DWORD_PTR dwIoBase, unsigned int uByteIdx)
 {
     BYTE byData;
 
@@ -234,7 +234,7 @@ BYTE MACbyReadMultiAddr (DWORD_PTR dwIoBase, UINT uByteIdx)
  * Return Value: none
  *
  */
-void MACvWriteMultiAddr (DWORD_PTR dwIoBase, UINT uByteIdx, BYTE byData)
+void MACvWriteMultiAddr (DWORD_PTR dwIoBase, unsigned int uByteIdx, BYTE byData)
 {
     MACvSelectPage1(dwIoBase);
     VNSvOutPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, byData);
@@ -257,7 +257,7 @@ void MACvWriteMultiAddr (DWORD_PTR dwIoBase, UINT uByteIdx, BYTE byData)
  */
 void MACvSetMultiAddrByHash (DWORD_PTR dwIoBase, BYTE byHashIdx)
 {
-    UINT uByteIdx;
+    unsigned int uByteIdx;
     BYTE byBitMask;
     BYTE byOrgValue;
 
@@ -288,7 +288,7 @@ void MACvSetMultiAddrByHash (DWORD_PTR dwIoBase, BYTE byHashIdx)
  */
 void MACvResetMultiAddrByHash (DWORD_PTR dwIoBase, BYTE byHashIdx)
 {
-    UINT uByteIdx;
+    unsigned int uByteIdx;
     BYTE byBitMask;
     BYTE byOrgValue;
 
@@ -1244,10 +1244,10 @@ void MACvSetCurrTXDescAddr (int iTxType, DWORD_PTR dwIoBase, DWORD dwCurrDescAdd
  * Return Value: none
  *
  */
-void MACvTimer0MicroSDelay (DWORD_PTR dwIoBase, UINT uDelay)
+void MACvTimer0MicroSDelay (DWORD_PTR dwIoBase, unsigned int uDelay)
 {
 BYTE byValue;
-UINT uu,ii;
+unsigned int uu,ii;
 
     VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
     VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelay);
@@ -1280,7 +1280,7 @@ UINT uu,ii;
  * Return Value: none
  *
  */
-void MACvOneShotTimer0MicroSec (DWORD_PTR dwIoBase, UINT uDelayTime)
+void MACvOneShotTimer0MicroSec (DWORD_PTR dwIoBase, unsigned int uDelayTime)
 {
     VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
     VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelayTime);
@@ -1301,7 +1301,7 @@ void MACvOneShotTimer0MicroSec (DWORD_PTR dwIoBase, UINT uDelayTime)
  * Return Value: none
  *
  */
-void MACvOneShotTimer1MicroSec (DWORD_PTR dwIoBase, UINT uDelayTime)
+void MACvOneShotTimer1MicroSec (DWORD_PTR dwIoBase, unsigned int uDelayTime)
 {
     VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, 0);
     VNSvOutPortD(dwIoBase + MAC_REG_TMDATA1, uDelayTime);
@@ -1319,10 +1319,10 @@ void MACvSetMISCFifo (DWORD_PTR dwIoBase, WORD wOffset, DWORD dwData)
 }
 
 
-BOOL MACbTxDMAOff (DWORD_PTR dwIoBase, UINT idx)
+BOOL MACbTxDMAOff (DWORD_PTR dwIoBase, unsigned int idx)
 {
 BYTE byData;
-UINT ww = 0;
+unsigned int ww = 0;
 
     if (idx == TYPE_TXDMA0) {
         VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
@@ -1350,7 +1350,7 @@ UINT ww = 0;
 void MACvClearBusSusInd (DWORD_PTR dwIoBase)
 {
     DWORD dwOrgValue;
-    UINT ww;
+    unsigned int ww;
     // check if BcnSusInd enabled
     VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
     if( !(dwOrgValue & EnCFG_BcnSusInd))
@@ -1373,7 +1373,7 @@ void MACvEnableBusSusEn (DWORD_PTR dwIoBase)
 {
     BYTE  byOrgValue;
     DWORD dwOrgValue;
-    UINT ww;
+    unsigned int ww;
     // check if BcnSusInd enabled
     VNSvInPortB(dwIoBase + MAC_REG_CFG , &byOrgValue);
 
@@ -1394,7 +1394,7 @@ void MACvEnableBusSusEn (DWORD_PTR dwIoBase)
 BOOL MACbFlushSYNCFifo (DWORD_PTR dwIoBase)
 {
     BYTE  byOrgValue;
-    UINT ww;
+    unsigned int ww;
     // Read MACCR
     VNSvInPortB(dwIoBase + MAC_REG_MACCR , &byOrgValue);
 
@@ -1418,7 +1418,7 @@ BOOL MACbFlushSYNCFifo (DWORD_PTR dwIoBase)
 BOOL MACbPSWakeup (DWORD_PTR dwIoBase)
 {
     BYTE  byOrgValue;
-    UINT ww;
+    unsigned int ww;
     // Read PSCTL
     if (MACbIsRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PS)) {
         return TRUE;
@@ -1455,7 +1455,8 @@ BOOL MACbPSWakeup (DWORD_PTR dwIoBase)
  *
  */
 
-void MACvSetKeyEntry (DWORD_PTR dwIoBase, WORD wKeyCtl, UINT uEntryIdx, UINT uKeyIdx, PBYTE pbyAddr, PDWORD pdwKey, BYTE byLocalID)
+void MACvSetKeyEntry (DWORD_PTR dwIoBase, WORD wKeyCtl, unsigned int uEntryIdx,
+		unsigned int uKeyIdx, PBYTE pbyAddr, PDWORD pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
 DWORD   dwData;
@@ -1521,7 +1522,7 @@ int     ii;
  * Return Value: none
  *
  */
-void MACvDisableKeyEntry (DWORD_PTR dwIoBase, UINT uEntryIdx)
+void MACvDisableKeyEntry (DWORD_PTR dwIoBase, unsigned int uEntryIdx)
 {
 WORD    wOffset;
 
@@ -1549,7 +1550,8 @@ WORD    wOffset;
  *
  */
 
-void MACvSetDefaultKeyEntry (DWORD_PTR dwIoBase, UINT uKeyLen, UINT uKeyIdx, PDWORD pdwKey, BYTE byLocalID)
+void MACvSetDefaultKeyEntry (DWORD_PTR dwIoBase, unsigned int uKeyLen,
+		unsigned int uKeyIdx, PDWORD pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
 DWORD   dwData;
@@ -1664,7 +1666,8 @@ DWORD   dwData;
  * Return Value: none
  *
  */
-void MACvSetDefaultTKIPKeyEntry (DWORD_PTR dwIoBase, UINT uKeyLen, UINT uKeyIdx, PDWORD pdwKey, BYTE byLocalID)
+void MACvSetDefaultTKIPKeyEntry (DWORD_PTR dwIoBase, unsigned int uKeyLen,
+		unsigned int uKeyIdx, PDWORD pdwKey, BYTE byLocalID)
 {
 WORD    wOffset;
 DWORD   dwData;
@@ -1720,7 +1723,7 @@ int     ii;
  *
  */
 
-void MACvSetDefaultKeyCtl (DWORD_PTR dwIoBase, WORD wKeyCtl, UINT uEntryIdx, BYTE byLocalID)
+void MACvSetDefaultKeyCtl (DWORD_PTR dwIoBase, WORD wKeyCtl, unsigned int uEntryIdx, BYTE byLocalID)
 {
 WORD    wOffset;
 DWORD   dwData;

commit 737c3d708c845ab39bfeb1b656e51e84d5771035
Author: Charles Clément <caratorn@gmail.com>
Date:   Fri May 28 12:34:19 2010 -0700

    Staging: vt6655: remove U8 custom macro
    
    Remove custom macro for unsigned 8-bit integers.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index f1ef7da75c2b..eae881c5a9f9 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -1046,7 +1046,7 @@ void MACvInitialize (DWORD_PTR dwIoBase)
     //MACvRegBitsOn(dwIoBase, MAC_REG_I2MCSR, I2MCSR_AUTOLD);
     // wait until EEPROM loading complete
     //while (TRUE) {
-    //    U8 u8Data;
+    //    u8 u8Data;
     //    VNSvInPortB(dwIoBase + MAC_REG_I2MCSR, &u8Data);
     //    if ( !(u8Data & I2MCSR_AUTOLD))
     //        break;

commit 6b35b7b3798b652a57fbce480f350aac851431c4
Author: Charles Clément <caratorn@gmail.com>
Date:   Fri May 7 12:30:19 2010 -0700

    Staging: vt6655: remove VOID definition and use
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index cdd7cd5e4095..f1ef7da75c2b 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -103,7 +103,7 @@ static int          msglevel                =MSG_LEVEL_INFO;
  * Return Value: none
  *
  */
-VOID MACvReadAllRegs (DWORD_PTR dwIoBase, PBYTE pbyMacRegs)
+void MACvReadAllRegs (DWORD_PTR dwIoBase, PBYTE pbyMacRegs)
 {
     int ii;
 
@@ -234,7 +234,7 @@ BYTE MACbyReadMultiAddr (DWORD_PTR dwIoBase, UINT uByteIdx)
  * Return Value: none
  *
  */
-VOID MACvWriteMultiAddr (DWORD_PTR dwIoBase, UINT uByteIdx, BYTE byData)
+void MACvWriteMultiAddr (DWORD_PTR dwIoBase, UINT uByteIdx, BYTE byData)
 {
     MACvSelectPage1(dwIoBase);
     VNSvOutPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, byData);
@@ -676,7 +676,7 @@ void MACvSaveContext (DWORD_PTR dwIoBase, PBYTE pbyCxtBuf)
  * Return Value: none
  *
  */
-VOID MACvRestoreContext (DWORD_PTR dwIoBase, PBYTE pbyCxtBuf)
+void MACvRestoreContext (DWORD_PTR dwIoBase, PBYTE pbyCxtBuf)
 {
     int         ii;
 
@@ -1244,7 +1244,7 @@ void MACvSetCurrTXDescAddr (int iTxType, DWORD_PTR dwIoBase, DWORD dwCurrDescAdd
  * Return Value: none
  *
  */
-VOID MACvTimer0MicroSDelay (DWORD_PTR dwIoBase, UINT uDelay)
+void MACvTimer0MicroSDelay (DWORD_PTR dwIoBase, UINT uDelay)
 {
 BYTE byValue;
 UINT uu,ii;

commit 256a816b6b78bf29fba0c0f1bbcf998953429422
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:16 2009 -0700

    Staging: vt665x: remove tbit.h part 2
    
    Remove use of tbit macros adn remove header file.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 889866c13c75..cdd7cd5e4095 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -69,7 +69,6 @@
  */
 
 #include "tmacro.h"
-#include "tbit.h"
 #include "tether.h"
 #include "mac.h"
 
@@ -146,7 +145,7 @@ BOOL MACbIsRegBitsOn (DWORD_PTR dwIoBase, BYTE byRegOfs, BYTE byTestBits)
     BYTE byData;
 
     VNSvInPortB(dwIoBase + byRegOfs, &byData);
-    return BITbIsAllBitsOn(byData, byTestBits);
+    return (byData & byTestBits) == byTestBits;
 }
 
 /*
@@ -169,7 +168,7 @@ BOOL MACbIsRegBitsOff (DWORD_PTR dwIoBase, BYTE byRegOfs, BYTE byTestBits)
     BYTE byData;
 
     VNSvInPortB(dwIoBase + byRegOfs, &byData);
-    return BITbIsAllBitsOff(byData, byTestBits);
+    return !(byData & byTestBits);
 }
 
 /*
@@ -565,7 +564,7 @@ BOOL MACbIsInLoopbackMode (DWORD_PTR dwIoBase)
     BYTE byOrgValue;
 
     VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
-    if (BITbIsAnyBitsOn(byOrgValue, (TEST_LBINT | TEST_LBEXT)))
+    if (byOrgValue & (TEST_LBINT | TEST_LBEXT))
         return TRUE;
     return FALSE;
 }
@@ -592,7 +591,7 @@ void MACvSetPacketFilter (DWORD_PTR dwIoBase, WORD wFilterType)
     // if only in DIRECTED mode, multicast-address will set to zero,
     // but if other mode exist (e.g. PROMISCUOUS), multicast-address
     // will be open
-    if (BITbIsBitOn(wFilterType, PKT_TYPE_DIRECTED)) {
+    if (wFilterType & PKT_TYPE_DIRECTED) {
         // set multicast address to accept none
         MACvSelectPage1(dwIoBase);
         VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0L);
@@ -600,7 +599,7 @@ void MACvSetPacketFilter (DWORD_PTR dwIoBase, WORD wFilterType)
         MACvSelectPage0(dwIoBase);
     }
 
-    if (BITbIsAnyBitsOn(wFilterType, PKT_TYPE_PROMISCUOUS | PKT_TYPE_ALL_MULTICAST)) {
+    if (wFilterType & (PKT_TYPE_PROMISCUOUS | PKT_TYPE_ALL_MULTICAST)) {
         // set multicast address to accept all
         MACvSelectPage1(dwIoBase);
         VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0xFFFFFFFFL);
@@ -608,20 +607,20 @@ void MACvSetPacketFilter (DWORD_PTR dwIoBase, WORD wFilterType)
         MACvSelectPage0(dwIoBase);
     }
 
-    if (BITbIsBitOn(wFilterType, PKT_TYPE_PROMISCUOUS)) {
+    if (wFilterType & PKT_TYPE_PROMISCUOUS) {
 
         byNewRCR |= (RCR_RXALLTYPE | RCR_UNICAST | RCR_MULTICAST | RCR_BROADCAST);
 
         byNewRCR &= ~RCR_BSSID;
     }
 
-    if (BITbIsAnyBitsOn(wFilterType, (PKT_TYPE_ALL_MULTICAST | PKT_TYPE_MULTICAST)))
+    if (wFilterType & (PKT_TYPE_ALL_MULTICAST | PKT_TYPE_MULTICAST))
         byNewRCR |= RCR_MULTICAST;
 
-    if (BITbIsBitOn(wFilterType, PKT_TYPE_BROADCAST))
+    if (wFilterType & PKT_TYPE_BROADCAST)
         byNewRCR |= RCR_BROADCAST;
 
-    if (BITbIsBitOn(wFilterType, PKT_TYPE_ERROR_CRC))
+    if (wFilterType & PKT_TYPE_ERROR_CRC)
         byNewRCR |= RCR_ERRCRC;
 
     VNSvInPortB(dwIoBase + MAC_REG_RCR,  &byOldRCR);
@@ -785,7 +784,7 @@ BOOL MACbSoftwareReset (DWORD_PTR dwIoBase)
 
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
-        if (BITbIsBitOff(byData, HOSTCR_SOFTRST))
+        if ( !(byData & HOSTCR_SOFTRST))
             break;
     }
     if (ww == W_MAX_TIMEOUT)
@@ -853,7 +852,7 @@ BOOL MACbSafeRxOff (DWORD_PTR dwIoBase)
     VNSvOutPortD(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_CLRRUN);
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL0, &dwData);
-        if (BITbIsAllBitsOff(dwData, DMACTL_RUN))
+        if (!(dwData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -863,7 +862,7 @@ BOOL MACbSafeRxOff (DWORD_PTR dwIoBase)
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL1, &dwData);
-        if (BITbIsAllBitsOff(dwData, DMACTL_RUN))
+        if ( !(dwData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -877,7 +876,7 @@ BOOL MACbSafeRxOff (DWORD_PTR dwIoBase)
     // W_MAX_TIMEOUT is the timeout period
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
-        if (BITbIsAllBitsOff(byData, HOSTCR_RXONST))
+        if ( !(byData & HOSTCR_RXONST))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -916,7 +915,7 @@ BOOL MACbSafeTxOff (DWORD_PTR dwIoBase)
 
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_TXDMACTL0, &dwData);
-        if (BITbIsAllBitsOff(dwData, DMACTL_RUN))
+        if ( !(dwData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -926,7 +925,7 @@ BOOL MACbSafeTxOff (DWORD_PTR dwIoBase)
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_AC0DMACTL, &dwData);
-        if (BITbIsAllBitsOff(dwData, DMACTL_RUN))
+        if ( !(dwData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -941,7 +940,7 @@ BOOL MACbSafeTxOff (DWORD_PTR dwIoBase)
     // W_MAX_TIMEOUT is the timeout period
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
-        if (BITbIsAllBitsOff(byData, HOSTCR_TXONST))
+        if ( !(byData & HOSTCR_TXONST))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -1049,7 +1048,7 @@ void MACvInitialize (DWORD_PTR dwIoBase)
     //while (TRUE) {
     //    U8 u8Data;
     //    VNSvInPortB(dwIoBase + MAC_REG_I2MCSR, &u8Data);
-    //    if (BITbIsBitOff(u8Data, I2MCSR_AUTOLD))
+    //    if ( !(u8Data & I2MCSR_AUTOLD))
     //        break;
     //}
 
@@ -1087,19 +1086,19 @@ BYTE    byData;
 BYTE    byOrgDMACtl;
 
     VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byOrgDMACtl);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0+2, DMACTL_RUN);
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byData);
-        if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+        if ( !(byData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x13);
     }
     VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, dwCurrDescAddr);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_RUN);
     }
 }
@@ -1125,19 +1124,19 @@ BYTE    byData;
 BYTE    byOrgDMACtl;
 
     VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byOrgDMACtl);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1+2, DMACTL_RUN);
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byData);
-        if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+        if ( !(byData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x14);
     }
     VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, dwCurrDescAddr);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_RUN);
     }
 }
@@ -1163,19 +1162,19 @@ BYTE    byData;
 BYTE    byOrgDMACtl;
 
     VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byOrgDMACtl);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
-        if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+        if ( !(byData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x25);
     }
     VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, dwCurrDescAddr);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0, DMACTL_RUN);
     }
 }
@@ -1202,12 +1201,12 @@ BYTE    byData;
 BYTE    byOrgDMACtl;
 
     VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byOrgDMACtl);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
-        if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+        if (!(byData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -1215,7 +1214,7 @@ BYTE    byOrgDMACtl;
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x26)\n");
     }
     VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_RUN);
     }
 }
@@ -1257,7 +1256,7 @@ UINT uu,ii;
         for (uu = 0; uu < uDelay; uu++) {
             VNSvInPortB(dwIoBase + MAC_REG_TMCTL0, &byValue);
             if ((byValue == 0) ||
-                (BITbIsAllBitsOn(byValue, TMCTL_TSUSP))) {
+                (byValue & TMCTL_TSUSP)) {
                 VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
                 return;
             }
@@ -1329,14 +1328,14 @@ UINT ww = 0;
         VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
         for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
             VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
-            if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+            if ( !(byData & DMACTL_RUN))
                 break;
         }
     } else if (idx == TYPE_AC0DMA) {
         VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
         for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
             VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
-            if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+            if ( !(byData & DMACTL_RUN))
                 break;
         }
     }
@@ -1354,14 +1353,14 @@ void MACvClearBusSusInd (DWORD_PTR dwIoBase)
     UINT ww;
     // check if BcnSusInd enabled
     VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
-    if(BITbIsBitOff(dwOrgValue, EnCFG_BcnSusInd))
+    if( !(dwOrgValue & EnCFG_BcnSusInd))
         return;
     //Set BcnSusClr
     dwOrgValue = dwOrgValue | EnCFG_BcnSusClr;
     VNSvOutPortD(dwIoBase + MAC_REG_ENCFG, dwOrgValue);
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
-        if(BITbIsBitOff(dwOrgValue, EnCFG_BcnSusInd))
+        if( !(dwOrgValue & EnCFG_BcnSusInd))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -1383,7 +1382,7 @@ void MACvEnableBusSusEn (DWORD_PTR dwIoBase)
     VNSvOutPortB(dwIoBase + MAC_REG_ENCFG, byOrgValue);
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
-        if(BITbIsBitOn(dwOrgValue, EnCFG_BcnSusInd))
+        if(dwOrgValue & EnCFG_BcnSusInd)
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -1406,7 +1405,7 @@ BOOL MACbFlushSYNCFifo (DWORD_PTR dwIoBase)
     // Check if SyncFlushOK
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_MACCR , &byOrgValue);
-        if(BITbIsBitOn(byOrgValue, MACCR_SYNCFLUSHOK))
+        if(byOrgValue & MACCR_SYNCFLUSHOK)
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -1430,7 +1429,7 @@ BOOL MACbPSWakeup (DWORD_PTR dwIoBase)
     // Check if SyncFlushOK
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_PSCTL , &byOrgValue);
-        if(BITbIsBitOn(byOrgValue, PSCTL_WAKEDONE))
+        if(byOrgValue & PSCTL_WAKEDONE)
             break;
     }
     if (ww == W_MAX_TIMEOUT) {

commit a7ad322a46663755718a214a9a34e5cfe64d07f7
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:09 2009 -0700

    Staging: vt665x: Clean up include files, Part 2
    
    Remove cplusplus lines from include files
    Remove needless ifdefs on includes to conform with C
    conventions.  Remove misc commented code/includes
    Update TODO
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 29b0d0ac724a..889866c13c75 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -68,21 +68,10 @@
  *
  */
 
-
-
-#if !defined(__TMACRO_H__)
 #include "tmacro.h"
-#endif
-#if !defined(__TBIT_H__)
 #include "tbit.h"
-#endif
-#if !defined(__TETHER_H__)
 #include "tether.h"
-#endif
-#if !defined(__MAC_H__)
 #include "mac.h"
-#endif
-
 
 WORD TxRate_iwconfig;//2008-5-8 <add> by chester
 /*---------------------  Static Definitions -------------------------*/

commit 612822f5dd1638de442cf50eb9da54632fba0e66
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:03 2009 -0700

    Staging: vt665x: Text janitor in prep for driver merge, part 2
    
    Text only changes to remove textual differences between the vt6655
    and vt6656 trees in prep for driver merge.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index da997541b212..29b0d0ac724a 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -16,6 +16,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
+ *
  * File: mac.c
  *
  * Purpose:  MAC routines
@@ -67,6 +68,8 @@
  *
  */
 
+
+
 #if !defined(__TMACRO_H__)
 #include "tmacro.h"
 #endif
@@ -95,6 +98,10 @@ static int          msglevel                =MSG_LEVEL_INFO;
 
 /*---------------------  Export Functions  --------------------------*/
 
+
+
+
+
 /*
  * Description:
  *      Read All MAC Registers to buffer

commit 7e809a9b10ab5ee985e23dea537e0236f026d1ca
Author: Jim Lieb <lieb@canonical.com>
Date:   Thu Jul 30 10:27:21 2009 -0700

    Staging: vt6655 textual cleanup in prep for driver merge
    
    The vt6655 and vt6656 drivers are from a common origin but
    have drifted apart with minor textual differences.  There
    are two changes:
    
      s/DEVICE_PRT/DBG_PRT/g
    
    and
    
      s/byPktTyp/byPktType/g
    
    This significantly reduces the differences between the two file sets
    in preparation to merging the common code.  A few whitespace and text bits were
    also adjusted.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Cc: Forest Bond <forest@alittletooquiet.net>
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
index 0283ed3bedd4..da997541b212 100644
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -862,7 +862,7 @@ BOOL MACbSafeRxOff (DWORD_PTR dwIoBase)
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x10);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x10)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x10)\n");
         return(FALSE);
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
@@ -872,7 +872,7 @@ BOOL MACbSafeRxOff (DWORD_PTR dwIoBase)
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x11);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x11)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x11)\n");
         return(FALSE);
     }
 
@@ -886,7 +886,7 @@ BOOL MACbSafeRxOff (DWORD_PTR dwIoBase)
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x12);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x12)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x12)\n");
         return(FALSE);
     }
     return TRUE;
@@ -925,7 +925,7 @@ BOOL MACbSafeTxOff (DWORD_PTR dwIoBase)
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x20);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x20)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x20)\n");
         return(FALSE);
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
@@ -935,7 +935,7 @@ BOOL MACbSafeTxOff (DWORD_PTR dwIoBase)
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x21);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x21)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x21)\n");
         return(FALSE);
     }
 
@@ -950,7 +950,7 @@ BOOL MACbSafeTxOff (DWORD_PTR dwIoBase)
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x24);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x24)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x24)\n");
         return(FALSE);
     }
     return TRUE;
@@ -975,13 +975,13 @@ BOOL MACbSafeStop (DWORD_PTR dwIoBase)
 
     if (MACbSafeRxOff(dwIoBase) == FALSE) {
         DBG_PORT80(0xA1);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" MACbSafeRxOff == FALSE)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" MACbSafeRxOff == FALSE)\n");
         MACbSafeSoftwareReset(dwIoBase);
         return FALSE;
     }
     if (MACbSafeTxOff(dwIoBase) == FALSE) {
         DBG_PORT80(0xA2);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" MACbSafeTxOff == FALSE)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" MACbSafeTxOff == FALSE)\n");
         MACbSafeSoftwareReset(dwIoBase);
         return FALSE;
     }
@@ -1216,7 +1216,7 @@ BYTE    byOrgDMACtl;
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x26);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x26)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x26)\n");
     }
     VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
     if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
@@ -1346,7 +1346,7 @@ UINT ww = 0;
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x29);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x29)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x29)\n");
         return FALSE;
     }
     return TRUE;
@@ -1370,7 +1370,7 @@ void MACvClearBusSusInd (DWORD_PTR dwIoBase)
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x33);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
     }
 }
 
@@ -1392,7 +1392,7 @@ void MACvEnableBusSusEn (DWORD_PTR dwIoBase)
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x34);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x34)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x34)\n");
     }
 }
 
@@ -1415,7 +1415,7 @@ BOOL MACbFlushSYNCFifo (DWORD_PTR dwIoBase)
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x35);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
     }
     return TRUE;
 }
@@ -1439,7 +1439,7 @@ BOOL MACbPSWakeup (DWORD_PTR dwIoBase)
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x36);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
         return FALSE;
     }
     return TRUE;
@@ -1470,7 +1470,7 @@ int     ii;
         return;
 
 
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetKeyEntry\n");
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetKeyEntry\n");
     wOffset = MISCFIFO_KEYETRY0;
     wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 
@@ -1478,7 +1478,7 @@ int     ii;
     dwData |= wKeyCtl;
     dwData <<= 16;
     dwData |= MAKEWORD(*(pbyAddr+4), *(pbyAddr+5));
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
 
     VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
     VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
@@ -1493,7 +1493,7 @@ int     ii;
     dwData |= *(pbyAddr+1);
     dwData <<= 8;
     dwData |= *(pbyAddr+0);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"2. wOffset: %d, Data: %lX\n", wOffset, dwData);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"2. wOffset: %d, Data: %lX\n", wOffset, dwData);
 
     VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
     VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
@@ -1503,7 +1503,7 @@ int     ii;
     wOffset += (uKeyIdx * 4);
     for (ii=0;ii<4;ii++) {
         // alway push 128 bits
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"3.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"3.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
         VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
         VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
         VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
@@ -1563,7 +1563,7 @@ int     ii;
     if (byLocalID <= 1)
         return;
 
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetDefaultKeyEntry\n");
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetDefaultKeyEntry\n");
     wOffset = MISCFIFO_KEYETRY0;
     wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
 
@@ -1572,7 +1572,7 @@ int     ii;
     wOffset += (uKeyIdx * 4);
     // alway push 128 bits
     for (ii=0; ii<3; ii++) {
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
         VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
         VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
         VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
@@ -1584,7 +1584,7 @@ int     ii;
     VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+3);
     VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
     VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"End. wOffset: %d, Data: %lX\n", wOffset+3, dwData);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"End. wOffset: %d, Data: %lX\n", wOffset+3, dwData);
 
 }
 
@@ -1620,7 +1620,7 @@ DWORD   dwData;
     VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
     VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
     VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvEnableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvEnableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
 
 }
 */
@@ -1652,7 +1652,7 @@ DWORD   dwData;
     VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
     VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
     VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvDisableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvDisableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
 }
 
 /*
@@ -1679,7 +1679,7 @@ int     ii;
         return;
 
 
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetDefaultTKIPKeyEntry\n");
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetDefaultTKIPKeyEntry\n");
     wOffset = MISCFIFO_KEYETRY0;
     // Kyle test : change offset from 10 -> 0
     wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
@@ -1697,10 +1697,10 @@ int     ii;
     wOffset++;
 
     wOffset += (uKeyIdx * 4);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, idx:%d\n", wOffset, *pdwKey, uKeyIdx);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, idx:%d\n", wOffset, *pdwKey, uKeyIdx);
     // alway push 128 bits
     for (ii=0; ii<4; ii++) {
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"2.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"2.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
         VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
         VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
         VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
@@ -1734,7 +1734,7 @@ DWORD   dwData;
         return;
 
 
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetKeyEntry\n");
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetKeyEntry\n");
     wOffset = MISCFIFO_KEYETRY0;
     wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
 
@@ -1742,7 +1742,7 @@ DWORD   dwData;
     dwData |= wKeyCtl;
     dwData <<= 16;
     dwData |= 0xffff;
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
 
     VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
     VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);

commit 5449c685a4b39534f18869a93896370224463715
Author: Forest Bond <forest@alittletooquiet.net>
Date:   Sat Apr 25 10:30:44 2009 -0400

    Staging: Add pristine upstream vt6655 driver sources
    
    Add pristine upstream vt6655 driver sources to drivers/staging/vt6655.  These
    files were literally copied from the driver directory in the upstream source
    archive, available here:
    
      http://www.viaarena.com/Driver/vt6655_linux_src_v1.19.12_x86.zip
    
    Signed-off-by: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/mac.c b/drivers/staging/vt6655/mac.c
new file mode 100644
index 000000000000..0283ed3bedd4
--- /dev/null
+++ b/drivers/staging/vt6655/mac.c
@@ -0,0 +1,1752 @@
+/*
+ * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * File: mac.c
+ *
+ * Purpose:  MAC routines
+ *
+ * Author: Tevin Chen
+ *
+ * Date: May 21, 1996
+ *
+ * Functions:
+ *      MACvReadAllRegs - Read All MAC Registers to buffer
+ *      MACbIsRegBitsOn - Test if All test Bits On
+ *      MACbIsRegBitsOff - Test if All test Bits Off
+ *      MACbIsIntDisable - Test if MAC interrupt disable
+ *      MACbyReadMultiAddr - Read Multicast Address Mask Pattern
+ *      MACvWriteMultiAddr - Write Multicast Address Mask Pattern
+ *      MACvSetMultiAddrByHash - Set Multicast Address Mask by Hash value
+ *      MACvResetMultiAddrByHash - Clear Multicast Address Mask by Hash value
+ *      MACvSetRxThreshold - Set Rx Threshold value
+ *      MACvGetRxThreshold - Get Rx Threshold value
+ *      MACvSetTxThreshold - Set Tx Threshold value
+ *      MACvGetTxThreshold - Get Tx Threshold value
+ *      MACvSetDmaLength - Set Dma Length value
+ *      MACvGetDmaLength - Get Dma Length value
+ *      MACvSetShortRetryLimit - Set 802.11 Short Retry limit
+ *      MACvGetShortRetryLimit - Get 802.11 Short Retry limit
+ *      MACvSetLongRetryLimit - Set 802.11 Long Retry limit
+ *      MACvGetLongRetryLimit - Get 802.11 Long Retry limit
+ *      MACvSetLoopbackMode - Set MAC Loopback Mode
+ *      MACbIsInLoopbackMode - Test if MAC in Loopback mode
+ *      MACvSetPacketFilter - Set MAC Address Filter
+ *      MACvSaveContext - Save Context of MAC Registers
+ *      MACvRestoreContext - Restore Context of MAC Registers
+ *      MACbCompareContext - Compare if values of MAC Registers same as Context
+ *      MACbSoftwareReset - Software Reset MAC
+ *      MACbSafeRxOff - Turn Off MAC Rx
+ *      MACbSafeTxOff - Turn Off MAC Tx
+ *      MACbSafeStop - Stop MAC function
+ *      MACbShutdown - Shut down MAC
+ *      MACvInitialize - Initialize MAC
+ *      MACvSetCurrRxDescAddr - Set Rx Descriptos Address
+ *      MACvSetCurrTx0DescAddr - Set Tx0 Descriptos Address
+ *      MACvSetCurrTx1DescAddr - Set Tx1 Descriptos Address
+ *      MACvTimer0MicroSDelay - Micro Second Delay Loop by MAC
+ *
+ * Revision History:
+ *      08-22-2003 Kyle Hsu     :  Porting MAC functions from sim53
+ *      09-03-2003 Bryan YC Fan :  Add MACvClearBusSusInd()& MACvEnableBusSusEn()
+ *      09-18-2003 Jerry Chen   :  Add MACvSetKeyEntry & MACvDisableKeyEntry
+ *
+ */
+
+#if !defined(__TMACRO_H__)
+#include "tmacro.h"
+#endif
+#if !defined(__TBIT_H__)
+#include "tbit.h"
+#endif
+#if !defined(__TETHER_H__)
+#include "tether.h"
+#endif
+#if !defined(__MAC_H__)
+#include "mac.h"
+#endif
+
+
+WORD TxRate_iwconfig;//2008-5-8 <add> by chester
+/*---------------------  Static Definitions -------------------------*/
+//static int          msglevel                =MSG_LEVEL_DEBUG;
+static int          msglevel                =MSG_LEVEL_INFO;
+/*---------------------  Static Classes  ----------------------------*/
+
+/*---------------------  Static Variables  --------------------------*/
+
+/*---------------------  Static Functions  --------------------------*/
+
+/*---------------------  Export Variables  --------------------------*/
+
+/*---------------------  Export Functions  --------------------------*/
+
+/*
+ * Description:
+ *      Read All MAC Registers to buffer
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      pbyMacRegs  - buffer to read
+ *
+ * Return Value: none
+ *
+ */
+VOID MACvReadAllRegs (DWORD_PTR dwIoBase, PBYTE pbyMacRegs)
+{
+    int ii;
+
+    // read page0 register
+    for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE0; ii++) {
+        VNSvInPortB(dwIoBase + ii, pbyMacRegs);
+        pbyMacRegs++;
+    }
+
+    MACvSelectPage1(dwIoBase);
+
+    // read page1 register
+    for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++) {
+        VNSvInPortB(dwIoBase + ii, pbyMacRegs);
+        pbyMacRegs++;
+    }
+
+    MACvSelectPage0(dwIoBase);
+
+}
+
+/*
+ * Description:
+ *      Test if all test bits on
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      byRegOfs    - Offset of MAC Register
+ *      byTestBits  - Test bits
+ *  Out:
+ *      none
+ *
+ * Return Value: TRUE if all test bits On; otherwise FALSE
+ *
+ */
+BOOL MACbIsRegBitsOn (DWORD_PTR dwIoBase, BYTE byRegOfs, BYTE byTestBits)
+{
+    BYTE byData;
+
+    VNSvInPortB(dwIoBase + byRegOfs, &byData);
+    return BITbIsAllBitsOn(byData, byTestBits);
+}
+
+/*
+ * Description:
+ *      Test if all test bits off
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      byRegOfs    - Offset of MAC Register
+ *      byTestBits  - Test bits
+ *  Out:
+ *      none
+ *
+ * Return Value: TRUE if all test bits Off; otherwise FALSE
+ *
+ */
+BOOL MACbIsRegBitsOff (DWORD_PTR dwIoBase, BYTE byRegOfs, BYTE byTestBits)
+{
+    BYTE byData;
+
+    VNSvInPortB(dwIoBase + byRegOfs, &byData);
+    return BITbIsAllBitsOff(byData, byTestBits);
+}
+
+/*
+ * Description:
+ *      Test if MAC interrupt disable
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      none
+ *
+ * Return Value: TRUE if interrupt is disable; otherwise FALSE
+ *
+ */
+BOOL MACbIsIntDisable (DWORD_PTR dwIoBase)
+{
+    DWORD dwData;
+
+    VNSvInPortD(dwIoBase + MAC_REG_IMR, &dwData);
+    if (dwData != 0)
+        return FALSE;
+
+    return TRUE;
+}
+
+/*
+ * Description:
+ *      Read MAC Multicast Address Mask
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      uByteidx    - Index of Mask
+ *  Out:
+ *      none
+ *
+ * Return Value: Mask Value read
+ *
+ */
+BYTE MACbyReadMultiAddr (DWORD_PTR dwIoBase, UINT uByteIdx)
+{
+    BYTE byData;
+
+    MACvSelectPage1(dwIoBase);
+    VNSvInPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, &byData);
+    MACvSelectPage0(dwIoBase);
+    return byData;
+}
+
+/*
+ * Description:
+ *      Write MAC Multicast Address Mask
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      uByteidx    - Index of Mask
+ *      byData      - Mask Value to write
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+VOID MACvWriteMultiAddr (DWORD_PTR dwIoBase, UINT uByteIdx, BYTE byData)
+{
+    MACvSelectPage1(dwIoBase);
+    VNSvOutPortB(dwIoBase + MAC_REG_MAR0 + uByteIdx, byData);
+    MACvSelectPage0(dwIoBase);
+}
+
+/*
+ * Description:
+ *      Set this hash index into multicast address register bit
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      byHashIdx   - Hash index to set
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvSetMultiAddrByHash (DWORD_PTR dwIoBase, BYTE byHashIdx)
+{
+    UINT uByteIdx;
+    BYTE byBitMask;
+    BYTE byOrgValue;
+
+    // calculate byte position
+    uByteIdx = byHashIdx / 8;
+    ASSERT(uByteIdx < 8);
+    // calculate bit position
+    byBitMask = 1;
+    byBitMask <<= (byHashIdx % 8);
+    // turn on the bit
+    byOrgValue = MACbyReadMultiAddr(dwIoBase, uByteIdx);
+    MACvWriteMultiAddr(dwIoBase, uByteIdx, (BYTE)(byOrgValue | byBitMask));
+}
+
+/*
+ * Description:
+ *      Reset this hash index into multicast address register bit
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      byHashIdx   - Hash index to clear
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvResetMultiAddrByHash (DWORD_PTR dwIoBase, BYTE byHashIdx)
+{
+    UINT uByteIdx;
+    BYTE byBitMask;
+    BYTE byOrgValue;
+
+    // calculate byte position
+    uByteIdx = byHashIdx / 8;
+    ASSERT(uByteIdx < 8);
+    // calculate bit position
+    byBitMask = 1;
+    byBitMask <<= (byHashIdx % 8);
+    // turn off the bit
+    byOrgValue = MACbyReadMultiAddr(dwIoBase, uByteIdx);
+    MACvWriteMultiAddr(dwIoBase, uByteIdx, (BYTE)(byOrgValue & (~byBitMask)));
+}
+
+/*
+ * Description:
+ *      Set Rx Threshold
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      byThreshold - Threshold Value
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvSetRxThreshold (DWORD_PTR dwIoBase, BYTE byThreshold)
+{
+    BYTE byOrgValue;
+
+    ASSERT(byThreshold < 4);
+
+    // set FCR0
+    VNSvInPortB(dwIoBase + MAC_REG_FCR0, &byOrgValue);
+    byOrgValue = (byOrgValue & 0xCF) | (byThreshold << 4);
+    VNSvOutPortB(dwIoBase + MAC_REG_FCR0, byOrgValue);
+}
+
+/*
+ * Description:
+ *      Get Rx Threshold
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      pbyThreshold- Threshold Value Get
+ *
+ * Return Value: none
+ *
+ */
+void MACvGetRxThreshold (DWORD_PTR dwIoBase, PBYTE pbyThreshold)
+{
+    // get FCR0
+    VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
+    *pbyThreshold = (*pbyThreshold >> 4) & 0x03;
+}
+
+/*
+ * Description:
+ *      Set Tx Threshold
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      byThreshold - Threshold Value
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvSetTxThreshold (DWORD_PTR dwIoBase, BYTE byThreshold)
+{
+    BYTE byOrgValue;
+
+    ASSERT(byThreshold < 4);
+
+    // set FCR0
+    VNSvInPortB(dwIoBase + MAC_REG_FCR0, &byOrgValue);
+    byOrgValue = (byOrgValue & 0xF3) | (byThreshold << 2);
+    VNSvOutPortB(dwIoBase + MAC_REG_FCR0, byOrgValue);
+}
+
+/*
+ * Description:
+ *      Get Tx Threshold
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      pbyThreshold- Threshold Value Get
+ *
+ * Return Value: none
+ *
+ */
+void MACvGetTxThreshold (DWORD_PTR dwIoBase, PBYTE pbyThreshold)
+{
+    // get FCR0
+    VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyThreshold);
+    *pbyThreshold = (*pbyThreshold >> 2) & 0x03;
+}
+
+/*
+ * Description:
+ *      Set Dma Length
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      byDmaLength - Dma Length Value
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvSetDmaLength (DWORD_PTR dwIoBase, BYTE byDmaLength)
+{
+    BYTE byOrgValue;
+
+    ASSERT(byDmaLength < 4);
+
+    // set FCR0
+    VNSvInPortB(dwIoBase + MAC_REG_FCR0, &byOrgValue);
+    byOrgValue = (byOrgValue & 0xFC) | byDmaLength;
+    VNSvOutPortB(dwIoBase + MAC_REG_FCR0, byOrgValue);
+}
+
+/*
+ * Description:
+ *      Get Dma Length
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      pbyDmaLength- Dma Length Value Get
+ *
+ * Return Value: none
+ *
+ */
+void MACvGetDmaLength (DWORD_PTR dwIoBase, PBYTE pbyDmaLength)
+{
+    // get FCR0
+    VNSvInPortB(dwIoBase + MAC_REG_FCR0, pbyDmaLength);
+    *pbyDmaLength &= 0x03;
+}
+
+/*
+ * Description:
+ *      Set 802.11 Short Retry Limit
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      byRetryLimit- Retry Limit
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvSetShortRetryLimit (DWORD_PTR dwIoBase, BYTE byRetryLimit)
+{
+    // set SRT
+    VNSvOutPortB(dwIoBase + MAC_REG_SRT, byRetryLimit);
+}
+
+/*
+ * Description:
+ *      Get 802.11 Short Retry Limit
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *  Out:
+ *      pbyRetryLimit   - Retry Limit Get
+ *
+ * Return Value: none
+ *
+ */
+void MACvGetShortRetryLimit (DWORD_PTR dwIoBase, PBYTE pbyRetryLimit)
+{
+    // get SRT
+    VNSvInPortB(dwIoBase + MAC_REG_SRT, pbyRetryLimit);
+}
+
+/*
+ * Description:
+ *      Set 802.11 Long Retry Limit
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      byRetryLimit- Retry Limit
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvSetLongRetryLimit (DWORD_PTR dwIoBase, BYTE byRetryLimit)
+{
+    // set LRT
+    VNSvOutPortB(dwIoBase + MAC_REG_LRT, byRetryLimit);
+}
+
+/*
+ * Description:
+ *      Get 802.11 Long Retry Limit
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *  Out:
+ *      pbyRetryLimit   - Retry Limit Get
+ *
+ * Return Value: none
+ *
+ */
+void MACvGetLongRetryLimit (DWORD_PTR dwIoBase, PBYTE pbyRetryLimit)
+{
+    // get LRT
+    VNSvInPortB(dwIoBase + MAC_REG_LRT, pbyRetryLimit);
+}
+
+/*
+ * Description:
+ *      Set MAC Loopback mode
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *      byLoopbackMode  - Loopback Mode
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvSetLoopbackMode (DWORD_PTR dwIoBase, BYTE byLoopbackMode)
+{
+    BYTE byOrgValue;
+
+    ASSERT(byLoopbackMode < 3);
+    byLoopbackMode <<= 6;
+    // set TCR
+    VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
+    byOrgValue = byOrgValue & 0x3F;
+    byOrgValue = byOrgValue | byLoopbackMode;
+    VNSvOutPortB(dwIoBase + MAC_REG_TEST, byOrgValue);
+}
+
+/*
+ * Description:
+ *      Test if MAC in Loopback mode
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *  Out:
+ *      none
+ *
+ * Return Value: TRUE if in Loopback mode; otherwise FALSE
+ *
+ */
+BOOL MACbIsInLoopbackMode (DWORD_PTR dwIoBase)
+{
+    BYTE byOrgValue;
+
+    VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
+    if (BITbIsAnyBitsOn(byOrgValue, (TEST_LBINT | TEST_LBEXT)))
+        return TRUE;
+    return FALSE;
+}
+
+/*
+ * Description:
+ *      Set MAC Address filter
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *      wFilterType     - Filter Type
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvSetPacketFilter (DWORD_PTR dwIoBase, WORD wFilterType)
+{
+    BYTE    byOldRCR;
+    BYTE    byNewRCR = 0;
+
+    // if only in DIRECTED mode, multicast-address will set to zero,
+    // but if other mode exist (e.g. PROMISCUOUS), multicast-address
+    // will be open
+    if (BITbIsBitOn(wFilterType, PKT_TYPE_DIRECTED)) {
+        // set multicast address to accept none
+        MACvSelectPage1(dwIoBase);
+        VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0L);
+        VNSvOutPortD(dwIoBase + MAC_REG_MAR0 + sizeof(DWORD), 0L);
+        MACvSelectPage0(dwIoBase);
+    }
+
+    if (BITbIsAnyBitsOn(wFilterType, PKT_TYPE_PROMISCUOUS | PKT_TYPE_ALL_MULTICAST)) {
+        // set multicast address to accept all
+        MACvSelectPage1(dwIoBase);
+        VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0xFFFFFFFFL);
+        VNSvOutPortD(dwIoBase + MAC_REG_MAR0 + sizeof(DWORD), 0xFFFFFFFFL);
+        MACvSelectPage0(dwIoBase);
+    }
+
+    if (BITbIsBitOn(wFilterType, PKT_TYPE_PROMISCUOUS)) {
+
+        byNewRCR |= (RCR_RXALLTYPE | RCR_UNICAST | RCR_MULTICAST | RCR_BROADCAST);
+
+        byNewRCR &= ~RCR_BSSID;
+    }
+
+    if (BITbIsAnyBitsOn(wFilterType, (PKT_TYPE_ALL_MULTICAST | PKT_TYPE_MULTICAST)))
+        byNewRCR |= RCR_MULTICAST;
+
+    if (BITbIsBitOn(wFilterType, PKT_TYPE_BROADCAST))
+        byNewRCR |= RCR_BROADCAST;
+
+    if (BITbIsBitOn(wFilterType, PKT_TYPE_ERROR_CRC))
+        byNewRCR |= RCR_ERRCRC;
+
+    VNSvInPortB(dwIoBase + MAC_REG_RCR,  &byOldRCR);
+    if (byNewRCR != byOldRCR) {
+        // Modify the Receive Command Register
+        VNSvOutPortB(dwIoBase + MAC_REG_RCR, byNewRCR);
+    }
+}
+
+/*
+ * Description:
+ *      Save MAC registers to context buffer
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      pbyCxtBuf   - Context buffer
+ *
+ * Return Value: none
+ *
+ */
+void MACvSaveContext (DWORD_PTR dwIoBase, PBYTE pbyCxtBuf)
+{
+    int         ii;
+
+    // read page0 register
+    for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE0; ii++) {
+        VNSvInPortB((dwIoBase + ii), (pbyCxtBuf + ii));
+    }
+
+    MACvSelectPage1(dwIoBase);
+
+    // read page1 register
+    for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++) {
+        VNSvInPortB((dwIoBase + ii), (pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
+    }
+
+    MACvSelectPage0(dwIoBase);
+}
+
+/*
+ * Description:
+ *      Restore MAC registers from context buffer
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      pbyCxtBuf   - Context buffer
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+VOID MACvRestoreContext (DWORD_PTR dwIoBase, PBYTE pbyCxtBuf)
+{
+    int         ii;
+
+    MACvSelectPage1(dwIoBase);
+    // restore page1
+    for (ii = 0; ii < MAC_MAX_CONTEXT_SIZE_PAGE1; ii++) {
+        VNSvOutPortB((dwIoBase + ii), *(pbyCxtBuf + MAC_MAX_CONTEXT_SIZE_PAGE0 + ii));
+    }
+    MACvSelectPage0(dwIoBase);
+
+    // restore RCR,TCR,IMR...
+    for (ii = MAC_REG_RCR; ii < MAC_REG_ISR; ii++) {
+        VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
+    }
+    // restore MAC Config.
+    for (ii = MAC_REG_LRT; ii < MAC_REG_PAGE1SEL; ii++) {
+        VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
+    }
+    VNSvOutPortB(dwIoBase + MAC_REG_CFG, *(pbyCxtBuf + MAC_REG_CFG));
+
+    // restore PS Config.
+    for (ii = MAC_REG_PSCFG; ii < MAC_REG_BBREGCTL; ii++) {
+        VNSvOutPortB(dwIoBase + ii, *(pbyCxtBuf + ii));
+    }
+
+    // restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
+    VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, *(PDWORD)(pbyCxtBuf + MAC_REG_TXDMAPTR0));
+    VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, *(PDWORD)(pbyCxtBuf + MAC_REG_AC0DMAPTR));
+    VNSvOutPortD(dwIoBase + MAC_REG_BCNDMAPTR, *(PDWORD)(pbyCxtBuf + MAC_REG_BCNDMAPTR));
+
+
+    VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, *(PDWORD)(pbyCxtBuf + MAC_REG_RXDMAPTR0));
+
+    VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, *(PDWORD)(pbyCxtBuf + MAC_REG_RXDMAPTR1));
+
+}
+
+/*
+ * Description:
+ *      Compare if MAC registers same as context buffer
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      pbyCxtBuf   - Context buffer
+ *  Out:
+ *      none
+ *
+ * Return Value: TRUE if all values are the same; otherwise FALSE
+ *
+ */
+BOOL MACbCompareContext (DWORD_PTR dwIoBase, PBYTE pbyCxtBuf)
+{
+    DWORD       dwData;
+
+    // compare MAC context to determine if this is a power lost init,
+    // return TRUE for power remaining init, return FALSE for power lost init
+
+    // compare CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR
+    VNSvInPortD(dwIoBase + MAC_REG_TXDMAPTR0, &dwData);
+    if (dwData != *(PDWORD)(pbyCxtBuf + MAC_REG_TXDMAPTR0)) {
+        return FALSE;
+    }
+
+    VNSvInPortD(dwIoBase + MAC_REG_AC0DMAPTR, &dwData);
+    if (dwData != *(PDWORD)(pbyCxtBuf + MAC_REG_AC0DMAPTR)) {
+        return FALSE;
+    }
+
+    VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR0, &dwData);
+    if (dwData != *(PDWORD)(pbyCxtBuf + MAC_REG_RXDMAPTR0)) {
+        return FALSE;
+    }
+
+    VNSvInPortD(dwIoBase + MAC_REG_RXDMAPTR1, &dwData);
+    if (dwData != *(PDWORD)(pbyCxtBuf + MAC_REG_RXDMAPTR1)) {
+        return FALSE;
+    }
+
+
+    return TRUE;
+}
+
+/*
+ * Description:
+ *      Software Reset MAC
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      none
+ *
+ * Return Value: TRUE if Reset Success; otherwise FALSE
+ *
+ */
+BOOL MACbSoftwareReset (DWORD_PTR dwIoBase)
+{
+    BYTE    byData;
+    WORD    ww;
+
+    // turn on HOSTCR_SOFTRST, just write 0x01 to reset
+    //MACvRegBitsOn(dwIoBase, MAC_REG_HOSTCR, HOSTCR_SOFTRST);
+    VNSvOutPortB(dwIoBase+ MAC_REG_HOSTCR, 0x01);
+
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
+        if (BITbIsBitOff(byData, HOSTCR_SOFTRST))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT)
+        return FALSE;
+    return TRUE;
+
+}
+
+/*
+ * Description:
+ *      save some important register's value, then do reset, then restore register's value
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      none
+ *
+ * Return Value: TRUE if success; otherwise FALSE
+ *
+ */
+BOOL MACbSafeSoftwareReset (DWORD_PTR dwIoBase)
+{
+    BYTE    abyTmpRegData[MAC_MAX_CONTEXT_SIZE_PAGE0+MAC_MAX_CONTEXT_SIZE_PAGE1];
+    BOOL    bRetVal;
+
+    // PATCH....
+    // save some important register's value, then do
+    // reset, then restore register's value
+
+    // save MAC context
+    MACvSaveContext(dwIoBase, abyTmpRegData);
+    // do reset
+    bRetVal = MACbSoftwareReset(dwIoBase);
+    //BBvSoftwareReset(pDevice->PortOffset);
+    // restore MAC context, except CR0
+    MACvRestoreContext(dwIoBase, abyTmpRegData);
+
+    return bRetVal;
+}
+
+/*
+ * Description:
+ *      Trun Off MAC Rx
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      none
+ *
+ * Return Value: TRUE if success; otherwise FALSE
+ *
+ */
+BOOL MACbSafeRxOff (DWORD_PTR dwIoBase)
+{
+    WORD    ww;
+    DWORD   dwData;
+    BYTE    byData;
+
+    // turn off wow temp for turn off Rx safely
+
+    // Clear RX DMA0,1
+    VNSvOutPortD(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_CLRRUN);
+    VNSvOutPortD(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_CLRRUN);
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL0, &dwData);
+        if (BITbIsAllBitsOff(dwData, DMACTL_RUN))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x10);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x10)\n");
+        return(FALSE);
+    }
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL1, &dwData);
+        if (BITbIsAllBitsOff(dwData, DMACTL_RUN))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x11);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x11)\n");
+        return(FALSE);
+    }
+
+    // try to safe shutdown RX
+    MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_RXON);
+    // W_MAX_TIMEOUT is the timeout period
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
+        if (BITbIsAllBitsOff(byData, HOSTCR_RXONST))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x12);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x12)\n");
+        return(FALSE);
+    }
+    return TRUE;
+}
+
+/*
+ * Description:
+ *      Trun Off MAC Tx
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      none
+ *
+ * Return Value: TRUE if success; otherwise FALSE
+ *
+ */
+BOOL MACbSafeTxOff (DWORD_PTR dwIoBase)
+{
+    WORD    ww;
+    DWORD   dwData;
+    BYTE    byData;
+
+    // Clear TX DMA
+    //Tx0
+    VNSvOutPortD(dwIoBase + MAC_REG_TXDMACTL0, DMACTL_CLRRUN);
+    //AC0
+    VNSvOutPortD(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_CLRRUN);
+
+
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortD(dwIoBase + MAC_REG_TXDMACTL0, &dwData);
+        if (BITbIsAllBitsOff(dwData, DMACTL_RUN))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x20);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x20)\n");
+        return(FALSE);
+    }
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortD(dwIoBase + MAC_REG_AC0DMACTL, &dwData);
+        if (BITbIsAllBitsOff(dwData, DMACTL_RUN))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x21);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x21)\n");
+        return(FALSE);
+    }
+
+    // try to safe shutdown TX
+    MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_TXON);
+
+    // W_MAX_TIMEOUT is the timeout period
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
+        if (BITbIsAllBitsOff(byData, HOSTCR_TXONST))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x24);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x24)\n");
+        return(FALSE);
+    }
+    return TRUE;
+}
+
+/*
+ * Description:
+ *      Stop MAC function
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      none
+ *
+ * Return Value: TRUE if success; otherwise FALSE
+ *
+ */
+BOOL MACbSafeStop (DWORD_PTR dwIoBase)
+{
+    MACvRegBitsOff(dwIoBase, MAC_REG_TCR, TCR_AUTOBCNTX);
+
+    if (MACbSafeRxOff(dwIoBase) == FALSE) {
+        DBG_PORT80(0xA1);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" MACbSafeRxOff == FALSE)\n");
+        MACbSafeSoftwareReset(dwIoBase);
+        return FALSE;
+    }
+    if (MACbSafeTxOff(dwIoBase) == FALSE) {
+        DBG_PORT80(0xA2);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" MACbSafeTxOff == FALSE)\n");
+        MACbSafeSoftwareReset(dwIoBase);
+        return FALSE;
+    }
+
+    MACvRegBitsOff(dwIoBase, MAC_REG_HOSTCR, HOSTCR_MACEN);
+
+    return TRUE;
+}
+
+/*
+ * Description:
+ *      Shut Down MAC
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      none
+ *
+ * Return Value: TRUE if success; otherwise FALSE
+ *
+ */
+BOOL MACbShutdown (DWORD_PTR dwIoBase)
+{
+    // disable MAC IMR
+    MACvIntDisable(dwIoBase);
+    MACvSetLoopbackMode(dwIoBase, MAC_LB_INTERNAL);
+    // stop the adapter
+    if (!MACbSafeStop(dwIoBase)) {
+        MACvSetLoopbackMode(dwIoBase, MAC_LB_NONE);
+        return FALSE;
+    }
+    MACvSetLoopbackMode(dwIoBase, MAC_LB_NONE);
+    return TRUE;
+}
+
+/*
+ * Description:
+ *      Initialize MAC
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvInitialize (DWORD_PTR dwIoBase)
+{
+    // clear sticky bits
+    MACvClearStckDS(dwIoBase);
+    // disable force PME-enable
+    VNSvOutPortB(dwIoBase + MAC_REG_PMC1, PME_OVR);
+    // only 3253 A
+    /*
+    MACvPwrEvntDisable(dwIoBase);
+    // clear power status
+    VNSvOutPortW(dwIoBase + MAC_REG_WAKEUPSR0, 0x0F0F);
+    */
+
+    // do reset
+    MACbSoftwareReset(dwIoBase);
+
+    // issue AUTOLD in EECSR to reload eeprom
+    //MACvRegBitsOn(dwIoBase, MAC_REG_I2MCSR, I2MCSR_AUTOLD);
+    // wait until EEPROM loading complete
+    //while (TRUE) {
+    //    U8 u8Data;
+    //    VNSvInPortB(dwIoBase + MAC_REG_I2MCSR, &u8Data);
+    //    if (BITbIsBitOff(u8Data, I2MCSR_AUTOLD))
+    //        break;
+    //}
+
+    // reset TSF counter
+    VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
+    // enable TSF counter
+    VNSvOutPortB(dwIoBase + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
+
+
+    // set packet filter
+    // receive directed and broadcast address
+
+    MACvSetPacketFilter(dwIoBase, PKT_TYPE_DIRECTED | PKT_TYPE_BROADCAST);
+
+}
+
+/*
+ * Description:
+ *      Set the chip with current rx descriptor address
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *      dwCurrDescAddr  - Descriptor Address
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvSetCurrRx0DescAddr (DWORD_PTR dwIoBase, DWORD dwCurrDescAddr)
+{
+WORD    ww;
+BYTE    byData;
+BYTE    byOrgDMACtl;
+
+    VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byOrgDMACtl);
+    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+        VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0+2, DMACTL_RUN);
+    }
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byData);
+        if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x13);
+    }
+    VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, dwCurrDescAddr);
+    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+        VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_RUN);
+    }
+}
+
+/*
+ * Description:
+ *      Set the chip with current rx descriptor address
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *      dwCurrDescAddr  - Descriptor Address
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvSetCurrRx1DescAddr (DWORD_PTR dwIoBase, DWORD dwCurrDescAddr)
+{
+WORD    ww;
+BYTE    byData;
+BYTE    byOrgDMACtl;
+
+    VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byOrgDMACtl);
+    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+        VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1+2, DMACTL_RUN);
+    }
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byData);
+        if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x14);
+    }
+    VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, dwCurrDescAddr);
+    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+        VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_RUN);
+    }
+}
+
+/*
+ * Description:
+ *      Set the chip with current tx0 descriptor address
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *      dwCurrDescAddr  - Descriptor Address
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvSetCurrTx0DescAddrEx (DWORD_PTR dwIoBase, DWORD dwCurrDescAddr)
+{
+WORD    ww;
+BYTE    byData;
+BYTE    byOrgDMACtl;
+
+    VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byOrgDMACtl);
+    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+        VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
+    }
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
+        if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x25);
+    }
+    VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, dwCurrDescAddr);
+    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+        VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0, DMACTL_RUN);
+    }
+}
+
+/*
+ * Description:
+ *      Set the chip with current AC0 descriptor address
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *      dwCurrDescAddr  - Descriptor Address
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+ //TxDMA1 = AC0DMA
+void MACvSetCurrAC0DescAddrEx (DWORD_PTR dwIoBase, DWORD dwCurrDescAddr)
+{
+WORD    ww;
+BYTE    byData;
+BYTE    byOrgDMACtl;
+
+    VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byOrgDMACtl);
+    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+        VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
+    }
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
+        if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x26);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x26)\n");
+    }
+    VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
+    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+        VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_RUN);
+    }
+}
+
+
+
+void MACvSetCurrTXDescAddr (int iTxType, DWORD_PTR dwIoBase, DWORD dwCurrDescAddr)
+{
+    if(iTxType == TYPE_AC0DMA){
+        MACvSetCurrAC0DescAddrEx(dwIoBase, dwCurrDescAddr);
+    }else if(iTxType == TYPE_TXDMA0){
+        MACvSetCurrTx0DescAddrEx(dwIoBase, dwCurrDescAddr);
+    }
+}
+
+/*
+ * Description:
+ *      Micro Second Delay via MAC
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      uDelay      - Delay time (timer resolution is 4 us)
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+VOID MACvTimer0MicroSDelay (DWORD_PTR dwIoBase, UINT uDelay)
+{
+BYTE byValue;
+UINT uu,ii;
+
+    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
+    VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelay);
+    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, (TMCTL_TMD | TMCTL_TE));
+    for(ii=0;ii<66;ii++) {  // assume max PCI clock is 66Mhz
+        for (uu = 0; uu < uDelay; uu++) {
+            VNSvInPortB(dwIoBase + MAC_REG_TMCTL0, &byValue);
+            if ((byValue == 0) ||
+                (BITbIsAllBitsOn(byValue, TMCTL_TSUSP))) {
+                VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
+                return;
+            }
+        }
+    }
+    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
+
+}
+
+/*
+ * Description:
+ *      Micro Second One shot timer via MAC
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      uDelay      - Delay time
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvOneShotTimer0MicroSec (DWORD_PTR dwIoBase, UINT uDelayTime)
+{
+    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
+    VNSvOutPortD(dwIoBase + MAC_REG_TMDATA0, uDelayTime);
+    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, (TMCTL_TMD | TMCTL_TE));
+}
+
+/*
+ * Description:
+ *      Micro Second One shot timer via MAC
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase    - Base Address for MAC
+ *      uDelay      - Delay time
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvOneShotTimer1MicroSec (DWORD_PTR dwIoBase, UINT uDelayTime)
+{
+    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, 0);
+    VNSvOutPortD(dwIoBase + MAC_REG_TMDATA1, uDelayTime);
+    VNSvOutPortB(dwIoBase + MAC_REG_TMCTL1, (TMCTL_TMD | TMCTL_TE));
+}
+
+
+void MACvSetMISCFifo (DWORD_PTR dwIoBase, WORD wOffset, DWORD dwData)
+{
+    if (wOffset > 273)
+        return;
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+}
+
+
+BOOL MACbTxDMAOff (DWORD_PTR dwIoBase, UINT idx)
+{
+BYTE byData;
+UINT ww = 0;
+
+    if (idx == TYPE_TXDMA0) {
+        VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
+        for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+            VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
+            if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+                break;
+        }
+    } else if (idx == TYPE_AC0DMA) {
+        VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
+        for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+            VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
+            if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+                break;
+        }
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x29);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x29)\n");
+        return FALSE;
+    }
+    return TRUE;
+}
+
+void MACvClearBusSusInd (DWORD_PTR dwIoBase)
+{
+    DWORD dwOrgValue;
+    UINT ww;
+    // check if BcnSusInd enabled
+    VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
+    if(BITbIsBitOff(dwOrgValue, EnCFG_BcnSusInd))
+        return;
+    //Set BcnSusClr
+    dwOrgValue = dwOrgValue | EnCFG_BcnSusClr;
+    VNSvOutPortD(dwIoBase + MAC_REG_ENCFG, dwOrgValue);
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
+        if(BITbIsBitOff(dwOrgValue, EnCFG_BcnSusInd))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x33);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
+    }
+}
+
+void MACvEnableBusSusEn (DWORD_PTR dwIoBase)
+{
+    BYTE  byOrgValue;
+    DWORD dwOrgValue;
+    UINT ww;
+    // check if BcnSusInd enabled
+    VNSvInPortB(dwIoBase + MAC_REG_CFG , &byOrgValue);
+
+    //Set BcnSusEn
+    byOrgValue = byOrgValue | CFG_BCNSUSEN;
+    VNSvOutPortB(dwIoBase + MAC_REG_ENCFG, byOrgValue);
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
+        if(BITbIsBitOn(dwOrgValue, EnCFG_BcnSusInd))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x34);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x34)\n");
+    }
+}
+
+BOOL MACbFlushSYNCFifo (DWORD_PTR dwIoBase)
+{
+    BYTE  byOrgValue;
+    UINT ww;
+    // Read MACCR
+    VNSvInPortB(dwIoBase + MAC_REG_MACCR , &byOrgValue);
+
+    // Set SYNCFLUSH
+    byOrgValue = byOrgValue | MACCR_SYNCFLUSH;
+    VNSvOutPortB(dwIoBase + MAC_REG_MACCR, byOrgValue);
+
+    // Check if SyncFlushOK
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortB(dwIoBase + MAC_REG_MACCR , &byOrgValue);
+        if(BITbIsBitOn(byOrgValue, MACCR_SYNCFLUSHOK))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x35);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
+    }
+    return TRUE;
+}
+
+BOOL MACbPSWakeup (DWORD_PTR dwIoBase)
+{
+    BYTE  byOrgValue;
+    UINT ww;
+    // Read PSCTL
+    if (MACbIsRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PS)) {
+        return TRUE;
+    }
+    // Disable PS
+    MACvRegBitsOff(dwIoBase, MAC_REG_PSCTL, PSCTL_PSEN);
+
+    // Check if SyncFlushOK
+    for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
+        VNSvInPortB(dwIoBase + MAC_REG_PSCTL , &byOrgValue);
+        if(BITbIsBitOn(byOrgValue, PSCTL_WAKEDONE))
+            break;
+    }
+    if (ww == W_MAX_TIMEOUT) {
+        DBG_PORT80(0x36);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x33)\n");
+        return FALSE;
+    }
+    return TRUE;
+}
+
+/*
+ * Description:
+ *      Set the Key by MISCFIFO
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+
+void MACvSetKeyEntry (DWORD_PTR dwIoBase, WORD wKeyCtl, UINT uEntryIdx, UINT uKeyIdx, PBYTE pbyAddr, PDWORD pdwKey, BYTE byLocalID)
+{
+WORD    wOffset;
+DWORD   dwData;
+int     ii;
+
+    if (byLocalID <= 1)
+        return;
+
+
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetKeyEntry\n");
+    wOffset = MISCFIFO_KEYETRY0;
+    wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
+
+    dwData = 0;
+    dwData |= wKeyCtl;
+    dwData <<= 16;
+    dwData |= MAKEWORD(*(pbyAddr+4), *(pbyAddr+5));
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
+
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+    wOffset++;
+
+    dwData = 0;
+    dwData |= *(pbyAddr+3);
+    dwData <<= 8;
+    dwData |= *(pbyAddr+2);
+    dwData <<= 8;
+    dwData |= *(pbyAddr+1);
+    dwData <<= 8;
+    dwData |= *(pbyAddr+0);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"2. wOffset: %d, Data: %lX\n", wOffset, dwData);
+
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+    wOffset++;
+
+    wOffset += (uKeyIdx * 4);
+    for (ii=0;ii<4;ii++) {
+        // alway push 128 bits
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"3.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
+        VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
+        VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
+        VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+    }
+}
+
+
+
+/*
+ * Description:
+ *      Disable the Key Entry by MISCFIFO
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvDisableKeyEntry (DWORD_PTR dwIoBase, UINT uEntryIdx)
+{
+WORD    wOffset;
+
+    wOffset = MISCFIFO_KEYETRY0;
+    wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
+
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, 0);
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+}
+
+
+/*
+ * Description:
+ *      Set the default Key (KeyEntry[10]) by MISCFIFO
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+
+void MACvSetDefaultKeyEntry (DWORD_PTR dwIoBase, UINT uKeyLen, UINT uKeyIdx, PDWORD pdwKey, BYTE byLocalID)
+{
+WORD    wOffset;
+DWORD   dwData;
+int     ii;
+
+    if (byLocalID <= 1)
+        return;
+
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetDefaultKeyEntry\n");
+    wOffset = MISCFIFO_KEYETRY0;
+    wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
+
+    wOffset++;
+    wOffset++;
+    wOffset += (uKeyIdx * 4);
+    // alway push 128 bits
+    for (ii=0; ii<3; ii++) {
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
+        VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
+        VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
+        VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+    }
+    dwData = *pdwKey;
+    if (uKeyLen == WLAN_WEP104_KEYLEN) {
+        dwData |= 0x80000000;
+    }
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+3);
+    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"End. wOffset: %d, Data: %lX\n", wOffset+3, dwData);
+
+}
+
+
+/*
+ * Description:
+ *      Enable default Key (KeyEntry[10]) by MISCFIFO
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+/*
+void MACvEnableDefaultKey (DWORD_PTR dwIoBase, BYTE byLocalID)
+{
+WORD    wOffset;
+DWORD   dwData;
+
+
+    if (byLocalID <= 1)
+        return;
+
+    wOffset = MISCFIFO_KEYETRY0;
+    wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
+
+    dwData = 0xC0440000;
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvEnableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
+
+}
+*/
+
+/*
+ * Description:
+ *      Disable default Key (KeyEntry[10]) by MISCFIFO
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvDisableDefaultKey (DWORD_PTR dwIoBase)
+{
+WORD    wOffset;
+DWORD   dwData;
+
+
+    wOffset = MISCFIFO_KEYETRY0;
+    wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
+
+    dwData = 0x0;
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvDisableDefaultKey: wOffset: %d, Data: %lX\n", wOffset, dwData);
+}
+
+/*
+ * Description:
+ *      Set the default TKIP Group Key (KeyEntry[10]) by MISCFIFO
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+void MACvSetDefaultTKIPKeyEntry (DWORD_PTR dwIoBase, UINT uKeyLen, UINT uKeyIdx, PDWORD pdwKey, BYTE byLocalID)
+{
+WORD    wOffset;
+DWORD   dwData;
+int     ii;
+
+    if (byLocalID <= 1)
+        return;
+
+
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetDefaultTKIPKeyEntry\n");
+    wOffset = MISCFIFO_KEYETRY0;
+    // Kyle test : change offset from 10 -> 0
+    wOffset += (10 * MISCFIFO_KEYENTRYSIZE);
+
+    dwData = 0xC0660000;
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+    wOffset++;
+
+    dwData = 0;
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+    wOffset++;
+
+    wOffset += (uKeyIdx * 4);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, idx:%d\n", wOffset, *pdwKey, uKeyIdx);
+    // alway push 128 bits
+    for (ii=0; ii<4; ii++) {
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"2.(%d) wOffset: %d, Data: %lX\n", ii, wOffset+ii, *pdwKey);
+        VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset+ii);
+        VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, *pdwKey++);
+        VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+    }
+
+}
+
+
+
+/*
+ * Description:
+ *      Set the Key Control by MISCFIFO
+ *
+ * Parameters:
+ *  In:
+ *      dwIoBase        - Base Address for MAC
+ *
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+
+void MACvSetDefaultKeyCtl (DWORD_PTR dwIoBase, WORD wKeyCtl, UINT uEntryIdx, BYTE byLocalID)
+{
+WORD    wOffset;
+DWORD   dwData;
+
+    if (byLocalID <= 1)
+        return;
+
+
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MACvSetKeyEntry\n");
+    wOffset = MISCFIFO_KEYETRY0;
+    wOffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);
+
+    dwData = 0;
+    dwData |= wKeyCtl;
+    dwData <<= 16;
+    dwData |= 0xffff;
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData, wKeyCtl);
+
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFNDEX, wOffset);
+    VNSvOutPortD(dwIoBase + MAC_REG_MISCFFDATA, dwData);
+    VNSvOutPortW(dwIoBase + MAC_REG_MISCFFCTL, MISCFFCTL_WRITE);
+
+}
+
