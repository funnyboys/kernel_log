commit 3abbab51321f51bdb1c64f2296644110c7a61f62
Author: Matej Dujava <mdujava@kocurkovo.cz>
Date:   Wed May 13 21:15:50 2020 +0200

    staging: vt6656: vt6655: removing unused macros definition Makefiles
    
    This patch is removing definition of CFLAGS in Makefile of vt6656 and
    vt6655, as those are defining macros that are not used. This will remove
    undef of one macro from vt6655/device_main.c, as it is only undef and it is
    not used anywhere else, so it is safe to remove it.
    
    Macros are removed from vt665x/Makefile and vt6655/device_main.c.
    
    Signed-off-by: Matej Dujava <mdujava@kocurkovo.cz>
    Link: https://lore.kernel.org/r/1589397351-24655-2-git-send-email-mdujava@kocurkovo.cz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 5889023d19c4..41cbec4134b0 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -32,7 +32,6 @@
  *
  * Revision History:
  */
-#undef __NO_VERSION__
 
 #include <linux/file.h>
 #include "device.h"

commit af93096eef047dab93698e56c4a971624a1263d7
Author: Briana Oursler <briana.oursler@gmail.com>
Date:   Fri Apr 3 10:18:05 2020 -0700

    Staging: vt6655: Replace camel case variable names.
    
    Replace camel case variable names with snake case in baseband.h and its
    dependencies.
    
    Signed-off-by: Briana Oursler <briana.oursler@gmail.com>
    Reviewed-by: Stefano Brivio <sbrivio@redhat.com>
    Link: https://lore.kernel.org/r/20200403171805.466600-1-briana.oursler@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 5c86cc60eb5c..5889023d19c4 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -21,14 +21,14 @@
  *   device_alloc_rx_buf - rx buffer pre-allocated function
  *   device_free_rx_buf - free rx buffer function
  *   device_free_tx_buf - free tx buffer function
- *   device_init_rd0_ring- initial rd dma0 ring
- *   device_init_rd1_ring- initial rd dma1 ring
- *   device_init_td0_ring- initial tx dma0 ring buffer
- *   device_init_td1_ring- initial tx dma1 ring buffer
- *   device_init_registers- initial MAC & BBP & RF internal registers.
- *   device_init_rings- initial tx/rx ring buffer
- *   device_free_rings- free all allocated ring buffer
- *   device_tx_srv- tx interrupt service function
+ *   device_init_rd0_ring - initial rd dma0 ring
+ *   device_init_rd1_ring - initial rd dma1 ring
+ *   device_init_td0_ring - initial tx dma0 ring buffer
+ *   device_init_td1_ring - initial tx dma1 ring buffer
+ *   device_init_registers - initial MAC & BBP & RF internal registers.
+ *   device_init_rings - initial tx/rx ring buffer
+ *   device_free_rings - free all allocated ring buffer
+ *   device_tx_srv - tx interrupt service function
  *
  * Revision History:
  */
@@ -202,7 +202,7 @@ static void device_init_registers(struct vnt_private *priv)
 	unsigned char byOFDMPwrdBm = 0;
 
 	MACbShutdown(priv);
-	BBvSoftwareReset(priv);
+	bb_software_reset(priv);
 
 	/* Do MACbSoftwareReset in MACvInitialize */
 	MACbSoftwareReset(priv);
@@ -279,8 +279,8 @@ static void device_init_registers(struct vnt_private *priv)
 	}
 
 	/* Set initial antenna mode */
-	BBvSetTxAntennaMode(priv, priv->byTxAntennaMode);
-	BBvSetRxAntennaMode(priv, priv->byRxAntennaMode);
+	bb_set_tx_antenna_mode(priv, priv->byTxAntennaMode);
+	bb_set_rx_antenna_mode(priv, priv->byRxAntennaMode);
 
 	/* zonetype initial */
 	priv->byOriginalZonetype = priv->abyEEPROM[EEP_OFS_ZONETYPE];
@@ -357,16 +357,16 @@ static void device_init_registers(struct vnt_private *priv)
 	VNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
 
 	/* initialize BBP registers */
-	BBbVT3253Init(priv);
+	bb_vt3253_init(priv);
 
 	if (priv->bUpdateBBVGA) {
 		priv->byBBVGACurrent = priv->abyBBVGA[0];
 		priv->byBBVGANew = priv->byBBVGACurrent;
-		BBvSetVGAGainOffset(priv, priv->abyBBVGA[0]);
+		bb_set_vga_gain_offset(priv, priv->abyBBVGA[0]);
 	}
 
-	BBvSetRxAntennaMode(priv, priv->byRxAntennaMode);
-	BBvSetTxAntennaMode(priv, priv->byTxAntennaMode);
+	bb_set_rx_antenna_mode(priv, priv->byRxAntennaMode);
+	bb_set_tx_antenna_mode(priv, priv->byTxAntennaMode);
 
 	/* Set BB and packet type at the same time. */
 	/* Set Short Slot Time, xIFS, and RSPINF. */
@@ -1001,7 +1001,7 @@ static void vnt_check_bb_vga(struct vnt_private *priv)
 
 	if (priv->uBBVGADiffCount == 1) {
 		/* first VGA diff gain */
-		BBvSetVGAGainOffset(priv, priv->byBBVGANew);
+		bb_set_vga_gain_offset(priv, priv->byBBVGANew);
 
 		dev_dbg(&priv->pcid->dev,
 			"First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
@@ -1017,7 +1017,7 @@ static void vnt_check_bb_vga(struct vnt_private *priv)
 			priv->byBBVGACurrent,
 			(int)priv->uBBVGADiffCount);
 
-		BBvSetVGAGainOffset(priv, priv->byBBVGANew);
+		bb_set_vga_gain_offset(priv, priv->byBBVGANew);
 	}
 }
 
@@ -1445,7 +1445,7 @@ static void vnt_bss_info_changed(struct ieee80211_hw *hw,
 			priv->bShortSlotTime = false;
 
 		CARDbSetPhyParameter(priv, priv->byBBType);
-		BBvSetVGAGainOffset(priv, priv->abyBBVGA[0]);
+		bb_set_vga_gain_offset(priv, priv->abyBBVGA[0]);
 	}
 
 	if (changed & BSS_CHANGED_TXPOWER)

commit 73d854226af4d8e9422bcd13359e036dca560e99
Author: Briana Oursler <briana.oursler@gmail.com>
Date:   Tue Mar 24 11:38:12 2020 -0700

    staging: vt6655: Break up function call with long line.
    
    Update matches style found elsewhere in file.
    Issue found by checkpatch: line over 80 characters.
    
    Signed-off-by: Briana Oursler <briana.oursler@gmail.com>
    Link: https://lore.kernel.org/r/20200324183812.79411-1-briana.oursler@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0442f71494b2..5c86cc60eb5c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -443,7 +443,10 @@ static bool device_init_rings(struct vnt_private *priv)
 
 	/*allocate all RD/TD rings a single pool*/
 	vir_pool = dma_alloc_coherent(&priv->pcid->dev,
-				      priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) + priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) + priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) + priv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),
+				      priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) +
+				      priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) +
+				      priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) +
+				      priv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),
 				      &priv->pool_dma, GFP_ATOMIC);
 	if (!vir_pool) {
 		dev_err(&priv->pcid->dev, "allocate desc dma memory failed\n");

commit a1182cda0c78518d4c391d2b46c3661d88034701
Author: Simon Fong <simon.fongnt@yahoo.com>
Date:   Tue Jan 28 22:14:26 2020 +0800

    Staging: vt6655: device_main: cleanup long line
    
    cleanup a long line coding style warning.
    
    Signed-off-by: Simon Fong <simon.fongnt@yahoo.com>
    Link: https://lore.kernel.org/r/20200128141426.12230-1-simon.fongnt@yahoo.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f69fc687d4c3..0442f71494b2 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -133,7 +133,8 @@ static int device_init_td1_ring(struct vnt_private *priv);
 static int  device_rx_srv(struct vnt_private *priv, unsigned int idx);
 static int  device_tx_srv(struct vnt_private *priv, unsigned int idx);
 static bool device_alloc_rx_buf(struct vnt_private *, struct vnt_rx_desc *);
-static void device_free_rx_buf(struct vnt_private *priv, struct vnt_rx_desc *rd);
+static void device_free_rx_buf(struct vnt_private *priv,
+			       struct vnt_rx_desc *rd);
 static void device_init_registers(struct vnt_private *priv);
 static void device_free_tx_buf(struct vnt_private *, struct vnt_tx_desc *);
 static void device_free_td0_ring(struct vnt_private *priv);

commit 3bce4750c97d25befd3a7be4de14d58ecd79d420
Author: Frank A. Cancio Bello <frank@generalsoftwareinc.com>
Date:   Fri Nov 1 23:25:22 2019 +0000

    staging: vt6655: Fix long lines
    
    Lines longer than 80 characters should be avoided because they are ugly
    and harder to read. Fix a few of long lines to comply with the preferred
    coding style for the linux kernel. Issues found by checkpatch.
    
    Suggested-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Frank A. Cancio Bello <frank@generalsoftwareinc.com>
    Link: https://lore.kernel.org/r/588c73f275b22f55323797706e5ceae44d7aa160.1572649242.git.frank@generalsoftwareinc.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index be3883f10520..f69fc687d4c3 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -295,7 +295,8 @@ static void device_init_registers(struct vnt_private *priv)
 	/* Get Desire Power Value */
 	priv->byCurPwr = 0xFF;
 	priv->byCCKPwr = SROMbyReadEmbedded(priv->PortOffset, EEP_OFS_PWR_CCK);
-	priv->byOFDMPwrG = SROMbyReadEmbedded(priv->PortOffset, EEP_OFS_PWR_OFDMG);
+	priv->byOFDMPwrG = SROMbyReadEmbedded(priv->PortOffset,
+					      EEP_OFS_PWR_OFDMG);
 
 	/* Load power Table */
 	for (ii = 0; ii < CB_MAX_CHANNEL_24G; ii++) {
@@ -660,7 +661,8 @@ static int device_init_td0_ring(struct vnt_private *priv)
 		desc->td_info->buf_dma = priv->tx_bufs_dma0 + i * PKT_BUF_SZ;
 
 		desc->next = &(priv->apTD0Rings[(i + 1) % priv->opts.tx_descs[0]]);
-		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
+		desc->next_desc = cpu_to_le32(curr +
+					      sizeof(struct vnt_tx_desc));
 	}
 
 	if (i > 0)

commit ebacc1a7654f37b95545daf4ec282518eeabbfe4
Author: Frank A. Cancio Bello <frank@generalsoftwareinc.com>
Date:   Fri Nov 1 23:22:46 2019 +0000

    staging: vt6655: Fix the spacing around operators
    
    Add space around operators to comply in that way with the preferred
    coding style for the linux kernel. Issue found by checkpatch.
    
    Suggested-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Frank A. Cancio Bello <frank@generalsoftwareinc.com>
    Link: https://lore.kernel.org/r/0f77b97e88c28c503caf25fafb84729509969ec3.1572649242.git.frank@generalsoftwareinc.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 2b93bea1f574..be3883f10520 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -659,12 +659,12 @@ static int device_init_td0_ring(struct vnt_private *priv)
 		desc->td_info->buf = priv->tx0_bufs + i * PKT_BUF_SZ;
 		desc->td_info->buf_dma = priv->tx_bufs_dma0 + i * PKT_BUF_SZ;
 
-		desc->next = &(priv->apTD0Rings[(i+1) % priv->opts.tx_descs[0]]);
+		desc->next = &(priv->apTD0Rings[(i + 1) % priv->opts.tx_descs[0]]);
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
 
 	if (i > 0)
-		priv->apTD0Rings[i-1].next_desc = cpu_to_le32(priv->td0_pool_dma);
+		priv->apTD0Rings[i - 1].next_desc = cpu_to_le32(priv->td0_pool_dma);
 	priv->apTailTD[0] = priv->apCurrTD[0] = &priv->apTD0Rings[0];
 
 	return 0;
@@ -704,7 +704,7 @@ static int device_init_td1_ring(struct vnt_private *priv)
 	}
 
 	if (i > 0)
-		priv->apTD1Rings[i-1].next_desc = cpu_to_le32(priv->td1_pool_dma);
+		priv->apTD1Rings[i - 1].next_desc = cpu_to_le32(priv->td1_pool_dma);
 	priv->apTailTD[1] = priv->apCurrTD[1] = &priv->apTD1Rings[0];
 
 	return 0;

commit 8b3f9afcca18787c82ba1b1ffc49c9aaee851c21
Author: Frank A. Cancio Bello <frank@generalsoftwareinc.com>
Date:   Fri Nov 1 23:21:54 2019 +0000

    staging: vt6655: Fix parameter alignment issues
    
    Fix alignment to match open parenthesis and comply in that way with the
    preferred coding style for the linux kernel. Issue found by checkpatch.
    
    Suggested-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Frank A. Cancio Bello <frank@generalsoftwareinc.com>
    Link: https://lore.kernel.org/r/df2a5f511870bd96abb9b111de83f3a1f1d82d70.1572649242.git.frank@generalsoftwareinc.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 082302944c37..2b93bea1f574 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -373,7 +373,7 @@ static void device_init_registers(struct vnt_private *priv)
 	priv->bRadioOff = false;
 
 	priv->byRadioCtl = SROMbyReadEmbedded(priv->PortOffset,
-						 EEP_OFS_RADIOCTL);
+					      EEP_OFS_RADIOCTL);
 	priv->bHWRadioOff = false;
 
 	if (priv->byRadioCtl & EEP_RADIOCTL_ENABLE) {

commit 80b15db5e1e9c3300de299b2d43d1aafb593e6ac
Author: Navid Emamdoost <navid.emamdoost@gmail.com>
Date:   Fri Oct 4 15:03:15 2019 -0500

    staging: vt6655: Fix memory leak in vt6655_probe
    
    In vt6655_probe, if vnt_init() fails the cleanup code needs to be called
    like other error handling cases. The call to device_free_info() is
    added.
    
    Fixes: 67013f2c0e58 ("staging: vt6655: mac80211 conversion add main mac80211 functions")
    Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20191004200319.22394-1-navid.emamdoost@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c6bb4aaf9bd0..082302944c37 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1748,8 +1748,10 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 	priv->hw->max_signal = 100;
 
-	if (vnt_init(priv))
+	if (vnt_init(priv)) {
+		device_free_info(priv);
 		return -ENODEV;
+	}
 
 	device_print_info(priv);
 	pci_set_drvdata(pcid, priv);

commit cc26358f89c3e493b54766b1ca56cfc6b14db78a
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Mar 27 18:45:26 2019 +0000

    staging: vt6655: Remove vif check from vnt_interrupt
    
    A check for vif is made in vnt_interrupt_work.
    
    There is a small chance of leaving interrupt disabled while vif
    is NULL and the work hasn't been scheduled.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    CC: stable@vger.kernel.org # v4.2+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 83f1a1cf9182..c6bb4aaf9bd0 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1137,8 +1137,7 @@ static irqreturn_t vnt_interrupt(int irq,  void *arg)
 {
 	struct vnt_private *priv = arg;
 
-	if (priv->vif)
-		schedule_work(&priv->interrupt_work);
+	schedule_work(&priv->interrupt_work);
 
 	MACvIntDisable(priv->PortOffset);
 

commit 3b9c2f2e0e99bb67c96abcb659b3465efe3bee1f
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Mar 24 18:53:49 2019 +0000

    staging: vt6655: Fix interrupt race condition on device start up.
    
    It appears on some slower systems that the driver can find its way
    out of the workqueue while the interrupt is disabled by continuous polling
    by it.
    
    Move MACvIntEnable to vnt_interrupt_work so that it is always enabled
    on all routes out of vnt_interrupt_process.
    
    Move MACvIntDisable so that the device doesn't keep polling the system
    while the workqueue is being processed.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    CC: stable@vger.kernel.org # v4.2+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index b370985b58a1..83f1a1cf9182 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1033,8 +1033,6 @@ static void vnt_interrupt_process(struct vnt_private *priv)
 		return;
 	}
 
-	MACvIntDisable(priv->PortOffset);
-
 	spin_lock_irqsave(&priv->lock, flags);
 
 	/* Read low level stats */
@@ -1122,8 +1120,6 @@ static void vnt_interrupt_process(struct vnt_private *priv)
 	}
 
 	spin_unlock_irqrestore(&priv->lock, flags);
-
-	MACvIntEnable(priv->PortOffset, IMR_MASK_VALUE);
 }
 
 static void vnt_interrupt_work(struct work_struct *work)
@@ -1133,6 +1129,8 @@ static void vnt_interrupt_work(struct work_struct *work)
 
 	if (priv->vif)
 		vnt_interrupt_process(priv);
+
+	MACvIntEnable(priv->PortOffset, IMR_MASK_VALUE);
 }
 
 static irqreturn_t vnt_interrupt(int irq,  void *arg)
@@ -1142,6 +1140,8 @@ static irqreturn_t vnt_interrupt(int irq,  void *arg)
 	if (priv->vif)
 		schedule_work(&priv->interrupt_work);
 
+	MACvIntDisable(priv->PortOffset);
+
 	return IRQ_HANDLED;
 }
 

commit 73ad3e241dfafa13d1a78f245faba39e8b927c8b
Author: Madhumitha Prabakaran <madhumithabiw@gmail.com>
Date:   Tue Feb 26 11:03:26 2019 -0600

    Staging: vt6655: Alignment should match open parenthesis
    
    Fix the check to improve readibility
    CHECK: Alignment should match open parenthesis
    
    Signed-off-by: Madhumitha Prabakaran <madhumithabiw@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4f08917320b2..b370985b58a1 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -805,7 +805,7 @@ static bool device_alloc_rx_buf(struct vnt_private *priv,
 }
 
 static void device_free_rx_buf(struct vnt_private *priv,
-				struct vnt_rx_desc *rd)
+			       struct vnt_rx_desc *rd)
 {
 	struct vnt_rd_info *rd_info = rd->rd_info;
 

commit 00bdd001b07d87e7cbde66a4196ad628c166a272
Author: Madhumitha Prabakaran <madhumithabiw@gmail.com>
Date:   Mon Feb 25 14:13:32 2019 -0600

    Staging: vt6655: Alignment should match open parenthesis
    
    Fix the check to improve readibility.
    CHECK: Alignment should match open parenthesis
    
    Signed-off-by: Madhumitha Prabakaran <madhumithabiw@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c9097e7367d8..4f08917320b2 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -810,7 +810,7 @@ static void device_free_rx_buf(struct vnt_private *priv,
 	struct vnt_rd_info *rd_info = rd->rd_info;
 
 	dma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,
-			priv->rx_buf_sz, DMA_FROM_DEVICE);
+			 priv->rx_buf_sz, DMA_FROM_DEVICE);
 	dev_kfree_skb(rd_info->skb);
 }
 

commit 750afb08ca71310fcf0c4e2cb1565c63b8235b60
Author: Luis Chamberlain <mcgrof@kernel.org>
Date:   Fri Jan 4 09:23:09 2019 +0100

    cross-tree: phase out dma_zalloc_coherent()
    
    We already need to zero out memory for dma_alloc_coherent(), as such
    using dma_zalloc_coherent() is superflous. Phase it out.
    
    This change was generated with the following Coccinelle SmPL patch:
    
    @ replace_dma_zalloc_coherent @
    expression dev, size, data, handle, flags;
    @@
    
    -dma_zalloc_coherent(dev, size, handle, flags)
    +dma_alloc_coherent(dev, size, handle, flags)
    
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Luis Chamberlain <mcgrof@kernel.org>
    [hch: re-ran the script on the latest tree]
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1ab0e8562d40..c9097e7367d8 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -440,12 +440,9 @@ static bool device_init_rings(struct vnt_private *priv)
 	void *vir_pool;
 
 	/*allocate all RD/TD rings a single pool*/
-	vir_pool = dma_zalloc_coherent(&priv->pcid->dev,
-				       priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) +
-				       priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) +
-				       priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) +
-				       priv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),
-				       &priv->pool_dma, GFP_ATOMIC);
+	vir_pool = dma_alloc_coherent(&priv->pcid->dev,
+				      priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) + priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) + priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) + priv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),
+				      &priv->pool_dma, GFP_ATOMIC);
 	if (!vir_pool) {
 		dev_err(&priv->pcid->dev, "allocate desc dma memory failed\n");
 		return false;
@@ -459,13 +456,9 @@ static bool device_init_rings(struct vnt_private *priv)
 	priv->rd1_pool_dma = priv->rd0_pool_dma +
 		priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc);
 
-	priv->tx0_bufs = dma_zalloc_coherent(&priv->pcid->dev,
-					     priv->opts.tx_descs[0] * PKT_BUF_SZ +
-					     priv->opts.tx_descs[1] * PKT_BUF_SZ +
-					     CB_BEACON_BUF_SIZE +
-					     CB_MAX_BUF_SIZE,
-					     &priv->tx_bufs_dma0,
-					     GFP_ATOMIC);
+	priv->tx0_bufs = dma_alloc_coherent(&priv->pcid->dev,
+					    priv->opts.tx_descs[0] * PKT_BUF_SZ + priv->opts.tx_descs[1] * PKT_BUF_SZ + CB_BEACON_BUF_SIZE + CB_MAX_BUF_SIZE,
+					    &priv->tx_bufs_dma0, GFP_ATOMIC);
 	if (!priv->tx0_bufs) {
 		dev_err(&priv->pcid->dev, "allocate buf dma memory failed\n");
 

commit 1dc751a5b51d730a98b528672f91d7a38aca5123
Author: Ji-Hun Kim <ji_hun.kim@samsung.com>
Date:   Thu Apr 5 16:09:20 2018 +0900

    staging: vt6655: add handling memory leak on vnt_start()
    
    There was no code for handling memory leaks of device_init_rings() and
    request_irq(). It needs to free allocated memory in the device_init_rings()
    , when request_irq() would be failed. Add freeing sequences of irq and
    device init rings.
    
    Signed-off-by: Ji-Hun Kim <ji_hun.kim@samsung.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 700c03c52f70..1ab0e8562d40 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1237,13 +1237,13 @@ static int vnt_start(struct ieee80211_hw *hw)
 			  IRQF_SHARED, "vt6655", priv);
 	if (ret) {
 		dev_dbg(&priv->pcid->dev, "failed to start irq\n");
-		return ret;
+		goto err_free_rings;
 	}
 
 	dev_dbg(&priv->pcid->dev, "call device init rd0 ring\n");
 	ret = device_init_rd0_ring(priv);
 	if (ret)
-		return ret;
+		goto err_free_irq;
 	ret = device_init_rd1_ring(priv);
 	if (ret)
 		goto err_free_rd0_ring;
@@ -1269,6 +1269,10 @@ static int vnt_start(struct ieee80211_hw *hw)
 	device_free_rd1_ring(priv);
 err_free_rd0_ring:
 	device_free_rd0_ring(priv);
+err_free_irq:
+	free_irq(priv->pcid->irq, priv);
+err_free_rings:
+	device_free_rings(priv);
 	return ret;
 }
 

commit 5341ee0adb17d12a96dc5344e0d267cd12b52135
Author: Ji-Hun Kim <ji_hun.kim@samsung.com>
Date:   Thu Apr 5 16:09:19 2018 +0900

    staging: vt6655: check for memory allocation failures
    
    There are no null pointer checking on rd_info and td_info values which
    are allocated by kzalloc. It has potential null pointer dereferencing
    issues. Implement error handling code on device_init_rd*, device_init_td*
    and vnt_start for the allocation failures.
    
    Signed-off-by: Ji-Hun Kim <ji_hun.kim@samsung.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index fbc4bc68144c..700c03c52f70 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -19,6 +19,7 @@
  *   device_print_info - print out resource
  *   device_rx_srv - rx service function
  *   device_alloc_rx_buf - rx buffer pre-allocated function
+ *   device_free_rx_buf - free rx buffer function
  *   device_free_tx_buf - free tx buffer function
  *   device_init_rd0_ring- initial rd dma0 ring
  *   device_init_rd1_ring- initial rd dma1 ring
@@ -124,14 +125,15 @@ static int  vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent);
 static void device_free_info(struct vnt_private *priv);
 static void device_print_info(struct vnt_private *priv);
 
-static void device_init_rd0_ring(struct vnt_private *priv);
-static void device_init_rd1_ring(struct vnt_private *priv);
-static void device_init_td0_ring(struct vnt_private *priv);
-static void device_init_td1_ring(struct vnt_private *priv);
+static int device_init_rd0_ring(struct vnt_private *priv);
+static int device_init_rd1_ring(struct vnt_private *priv);
+static int device_init_td0_ring(struct vnt_private *priv);
+static int device_init_td1_ring(struct vnt_private *priv);
 
 static int  device_rx_srv(struct vnt_private *priv, unsigned int idx);
 static int  device_tx_srv(struct vnt_private *priv, unsigned int idx);
 static bool device_alloc_rx_buf(struct vnt_private *, struct vnt_rx_desc *);
+static void device_free_rx_buf(struct vnt_private *priv, struct vnt_rx_desc *rd);
 static void device_init_registers(struct vnt_private *priv);
 static void device_free_tx_buf(struct vnt_private *, struct vnt_tx_desc *);
 static void device_free_td0_ring(struct vnt_private *priv);
@@ -528,20 +530,28 @@ static void device_free_rings(struct vnt_private *priv)
 				  priv->tx0_bufs, priv->tx_bufs_dma0);
 }
 
-static void device_init_rd0_ring(struct vnt_private *priv)
+static int device_init_rd0_ring(struct vnt_private *priv)
 {
 	int i;
 	dma_addr_t      curr = priv->rd0_pool_dma;
 	struct vnt_rx_desc *desc;
+	int ret;
 
 	/* Init the RD0 ring entries */
 	for (i = 0; i < priv->opts.rx_descs0;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
 		desc = &priv->aRD0Ring[i];
 		desc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_KERNEL);
+		if (!desc->rd_info) {
+			ret = -ENOMEM;
+			goto err_free_desc;
+		}
 
-		if (!device_alloc_rx_buf(priv, desc))
+		if (!device_alloc_rx_buf(priv, desc)) {
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
+			ret = -ENOMEM;
+			goto err_free_rd;
+		}
 
 		desc->next = &priv->aRD0Ring[(i + 1) % priv->opts.rx_descs0];
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
@@ -550,22 +560,44 @@ static void device_init_rd0_ring(struct vnt_private *priv)
 	if (i > 0)
 		priv->aRD0Ring[i-1].next_desc = cpu_to_le32(priv->rd0_pool_dma);
 	priv->pCurrRD[0] = &priv->aRD0Ring[0];
+
+	return 0;
+
+err_free_rd:
+	kfree(desc->rd_info);
+
+err_free_desc:
+	while (--i) {
+		desc = &priv->aRD0Ring[i];
+		device_free_rx_buf(priv, desc);
+		kfree(desc->rd_info);
+	}
+
+	return ret;
 }
 
-static void device_init_rd1_ring(struct vnt_private *priv)
+static int device_init_rd1_ring(struct vnt_private *priv)
 {
 	int i;
 	dma_addr_t      curr = priv->rd1_pool_dma;
 	struct vnt_rx_desc *desc;
+	int ret;
 
 	/* Init the RD1 ring entries */
 	for (i = 0; i < priv->opts.rx_descs1;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
 		desc = &priv->aRD1Ring[i];
 		desc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_KERNEL);
+		if (!desc->rd_info) {
+			ret = -ENOMEM;
+			goto err_free_desc;
+		}
 
-		if (!device_alloc_rx_buf(priv, desc))
+		if (!device_alloc_rx_buf(priv, desc)) {
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
+			ret = -ENOMEM;
+			goto err_free_rd;
+		}
 
 		desc->next = &priv->aRD1Ring[(i+1) % priv->opts.rx_descs1];
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
@@ -574,6 +606,20 @@ static void device_init_rd1_ring(struct vnt_private *priv)
 	if (i > 0)
 		priv->aRD1Ring[i-1].next_desc = cpu_to_le32(priv->rd1_pool_dma);
 	priv->pCurrRD[1] = &priv->aRD1Ring[0];
+
+	return 0;
+
+err_free_rd:
+	kfree(desc->rd_info);
+
+err_free_desc:
+	while (--i) {
+		desc = &priv->aRD1Ring[i];
+		device_free_rx_buf(priv, desc);
+		kfree(desc->rd_info);
+	}
+
+	return ret;
 }
 
 static void device_free_rd0_ring(struct vnt_private *priv)
@@ -582,13 +628,8 @@ static void device_free_rd0_ring(struct vnt_private *priv)
 
 	for (i = 0; i < priv->opts.rx_descs0; i++) {
 		struct vnt_rx_desc *desc = &priv->aRD0Ring[i];
-		struct vnt_rd_info *rd_info = desc->rd_info;
-
-		dma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,
-				 priv->rx_buf_sz, DMA_FROM_DEVICE);
-
-		dev_kfree_skb(rd_info->skb);
 
+		device_free_rx_buf(priv, desc);
 		kfree(desc->rd_info);
 	}
 }
@@ -599,28 +640,28 @@ static void device_free_rd1_ring(struct vnt_private *priv)
 
 	for (i = 0; i < priv->opts.rx_descs1; i++) {
 		struct vnt_rx_desc *desc = &priv->aRD1Ring[i];
-		struct vnt_rd_info *rd_info = desc->rd_info;
-
-		dma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,
-				 priv->rx_buf_sz, DMA_FROM_DEVICE);
-
-		dev_kfree_skb(rd_info->skb);
 
+		device_free_rx_buf(priv, desc);
 		kfree(desc->rd_info);
 	}
 }
 
-static void device_init_td0_ring(struct vnt_private *priv)
+static int device_init_td0_ring(struct vnt_private *priv)
 {
 	int i;
 	dma_addr_t  curr;
 	struct vnt_tx_desc *desc;
+	int ret;
 
 	curr = priv->td0_pool_dma;
 	for (i = 0; i < priv->opts.tx_descs[0];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
 		desc = &priv->apTD0Rings[i];
 		desc->td_info = kzalloc(sizeof(*desc->td_info), GFP_KERNEL);
+		if (!desc->td_info) {
+			ret = -ENOMEM;
+			goto err_free_desc;
+		}
 
 		desc->td_info->buf = priv->tx0_bufs + i * PKT_BUF_SZ;
 		desc->td_info->buf_dma = priv->tx_bufs_dma0 + i * PKT_BUF_SZ;
@@ -632,13 +673,24 @@ static void device_init_td0_ring(struct vnt_private *priv)
 	if (i > 0)
 		priv->apTD0Rings[i-1].next_desc = cpu_to_le32(priv->td0_pool_dma);
 	priv->apTailTD[0] = priv->apCurrTD[0] = &priv->apTD0Rings[0];
+
+	return 0;
+
+err_free_desc:
+	while (--i) {
+		desc = &priv->apTD0Rings[i];
+		kfree(desc->td_info);
+	}
+
+	return ret;
 }
 
-static void device_init_td1_ring(struct vnt_private *priv)
+static int device_init_td1_ring(struct vnt_private *priv)
 {
 	int i;
 	dma_addr_t  curr;
 	struct vnt_tx_desc *desc;
+	int ret;
 
 	/* Init the TD ring entries */
 	curr = priv->td1_pool_dma;
@@ -646,6 +698,10 @@ static void device_init_td1_ring(struct vnt_private *priv)
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
 		desc = &priv->apTD1Rings[i];
 		desc->td_info = kzalloc(sizeof(*desc->td_info), GFP_KERNEL);
+		if (!desc->td_info) {
+			ret = -ENOMEM;
+			goto err_free_desc;
+		}
 
 		desc->td_info->buf = priv->tx1_bufs + i * PKT_BUF_SZ;
 		desc->td_info->buf_dma = priv->tx_bufs_dma1 + i * PKT_BUF_SZ;
@@ -657,6 +713,16 @@ static void device_init_td1_ring(struct vnt_private *priv)
 	if (i > 0)
 		priv->apTD1Rings[i-1].next_desc = cpu_to_le32(priv->td1_pool_dma);
 	priv->apTailTD[1] = priv->apCurrTD[1] = &priv->apTD1Rings[0];
+
+	return 0;
+
+err_free_desc:
+	while (--i) {
+		desc = &priv->apTD1Rings[i];
+		kfree(desc->td_info);
+	}
+
+	return ret;
 }
 
 static void device_free_td0_ring(struct vnt_private *priv)
@@ -745,6 +811,16 @@ static bool device_alloc_rx_buf(struct vnt_private *priv,
 	return true;
 }
 
+static void device_free_rx_buf(struct vnt_private *priv,
+				struct vnt_rx_desc *rd)
+{
+	struct vnt_rd_info *rd_info = rd->rd_info;
+
+	dma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,
+			priv->rx_buf_sz, DMA_FROM_DEVICE);
+	dev_kfree_skb(rd_info->skb);
+}
+
 static const u8 fallback_rate0[5][5] = {
 	{RATE_18M, RATE_18M, RATE_12M, RATE_12M, RATE_12M},
 	{RATE_24M, RATE_24M, RATE_18M, RATE_12M, RATE_12M},
@@ -1165,10 +1241,18 @@ static int vnt_start(struct ieee80211_hw *hw)
 	}
 
 	dev_dbg(&priv->pcid->dev, "call device init rd0 ring\n");
-	device_init_rd0_ring(priv);
-	device_init_rd1_ring(priv);
-	device_init_td0_ring(priv);
-	device_init_td1_ring(priv);
+	ret = device_init_rd0_ring(priv);
+	if (ret)
+		return ret;
+	ret = device_init_rd1_ring(priv);
+	if (ret)
+		goto err_free_rd0_ring;
+	ret = device_init_td0_ring(priv);
+	if (ret)
+		goto err_free_rd1_ring;
+	ret = device_init_td1_ring(priv);
+	if (ret)
+		goto err_free_td0_ring;
 
 	device_init_registers(priv);
 
@@ -1178,6 +1262,14 @@ static int vnt_start(struct ieee80211_hw *hw)
 	ieee80211_wake_queues(hw);
 
 	return 0;
+
+err_free_td0_ring:
+	device_free_td0_ring(priv);
+err_free_rd1_ring:
+	device_free_rd1_ring(priv);
+err_free_rd0_ring:
+	device_free_rd0_ring(priv);
+	return ret;
 }
 
 static void vnt_stop(struct ieee80211_hw *hw)

commit 6089735a5f749950c22e96ab90e1341674a015f0
Author: Santha Meena Ramamoorthy <santhameena13@gmail.com>
Date:   Fri Mar 2 06:05:52 2018 -0800

    staging: vt6655: remove unnecessary parentheses
    
    Remove unnecessary parentheses around variables to conform to the Linux
    kernel coding style. Issue found using checkpatch.
    
    Signed-off-by: Santha Meena Ramamoorthy <santhameena13@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0dc902022a91..fbc4bc68144c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -543,7 +543,7 @@ static void device_init_rd0_ring(struct vnt_private *priv)
 		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
 
-		desc->next = &(priv->aRD0Ring[(i + 1) % priv->opts.rx_descs0]);
+		desc->next = &priv->aRD0Ring[(i + 1) % priv->opts.rx_descs0];
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 
@@ -567,7 +567,7 @@ static void device_init_rd1_ring(struct vnt_private *priv)
 		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
 
-		desc->next = &(priv->aRD1Ring[(i+1) % priv->opts.rx_descs1]);
+		desc->next = &priv->aRD1Ring[(i+1) % priv->opts.rx_descs1];
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 
@@ -581,7 +581,7 @@ static void device_free_rd0_ring(struct vnt_private *priv)
 	int i;
 
 	for (i = 0; i < priv->opts.rx_descs0; i++) {
-		struct vnt_rx_desc *desc = &(priv->aRD0Ring[i]);
+		struct vnt_rx_desc *desc = &priv->aRD0Ring[i];
 		struct vnt_rd_info *rd_info = desc->rd_info;
 
 		dma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,

commit 88a527c4981847838273703df010eb8aca5ee023
Author: Jia-Ju Bai <baijiaju1990@gmail.com>
Date:   Mon Dec 18 17:07:54 2017 +0800

    staging: vt6655: Use GFP_KERNEL in kzalloc
    
    Four kzalloc functions are called with GFP_ATOMIC.
    But according to driver call graph, they are not in atomic context,
    namely no spinlock is held nor in an interrupt handler.
    
    All these "GFP_ATOMIC"s are unnecessary,
    and replace with with "GFP_KERNEL"s.
    
    Signed-off-by: Jia-Ju Bai <baijiaju1990@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 676a0882cdd4..0dc902022a91 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -538,7 +538,7 @@ static void device_init_rd0_ring(struct vnt_private *priv)
 	for (i = 0; i < priv->opts.rx_descs0;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
 		desc = &priv->aRD0Ring[i];
-		desc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_ATOMIC);
+		desc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_KERNEL);
 
 		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
@@ -562,7 +562,7 @@ static void device_init_rd1_ring(struct vnt_private *priv)
 	for (i = 0; i < priv->opts.rx_descs1;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
 		desc = &priv->aRD1Ring[i];
-		desc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_ATOMIC);
+		desc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_KERNEL);
 
 		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
@@ -620,7 +620,7 @@ static void device_init_td0_ring(struct vnt_private *priv)
 	for (i = 0; i < priv->opts.tx_descs[0];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
 		desc = &priv->apTD0Rings[i];
-		desc->td_info = kzalloc(sizeof(*desc->td_info), GFP_ATOMIC);
+		desc->td_info = kzalloc(sizeof(*desc->td_info), GFP_KERNEL);
 
 		desc->td_info->buf = priv->tx0_bufs + i * PKT_BUF_SZ;
 		desc->td_info->buf_dma = priv->tx_bufs_dma0 + i * PKT_BUF_SZ;
@@ -645,7 +645,7 @@ static void device_init_td1_ring(struct vnt_private *priv)
 	for (i = 0; i < priv->opts.tx_descs[1];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
 		desc = &priv->apTD1Rings[i];
-		desc->td_info = kzalloc(sizeof(*desc->td_info), GFP_ATOMIC);
+		desc->td_info = kzalloc(sizeof(*desc->td_info), GFP_KERNEL);
 
 		desc->td_info->buf = priv->tx1_bufs + i * PKT_BUF_SZ;
 		desc->td_info->buf_dma = priv->tx_bufs_dma1 + i * PKT_BUF_SZ;

commit dbc9f36cf7bc6d431c63c4785ad3c4bc0f306588
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 21:07:56 2017 +0100

    staging: vt6655: Remove redundant license text
    
    Now that the SPDX tag is in all vt6655 files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 6f8f19b54562..676a0882cdd4 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3,16 +3,6 @@
  * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  * All rights reserved.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * File: device_main.c
  *
  * Purpose: driver entry for initial, open, close, tx and rx.

commit d7c43082fc0d178a29a7ea1dcc9729abd38c7cf8
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 21:07:53 2017 +0100

    staging: vt6655: add SPDX identifiers to all vt6655 driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the vt6655 driver files with the correct SPDX license identifier
    based on the license text in the file itself.  The SPDX identifier is a
    legally binding shorthand, which can be used instead of the full boiler
    plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Forest Bond <forest@alittletooquiet.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1123b4f1e1d6..6f8f19b54562 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  * All rights reserved.

commit 42c8eb3f6e15367981b274cb79ee4657e2c6949d
Author: Jia-Ju Bai <baijiaju1990@163.com>
Date:   Mon Oct 9 16:45:55 2017 +0800

    vt6655: Fix a possible sleep-in-atomic bug in vt6655_suspend
    
    The driver may sleep under a spinlock, and the function call path is:
    vt6655_suspend (acquire the spinlock)
      pci_set_power_state
        __pci_start_power_transition (drivers/pci/pci.c)
          msleep --> may sleep
    
    To fix it, pci_set_power_state is called without having a spinlock.
    
    This bug is found by my static analysis tool and my code review.
    
    Signed-off-by: Jia-Ju Bai <baijiaju1990@163.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 9fcf2e223f71..1123b4f1e1d6 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1693,10 +1693,11 @@ static int vt6655_suspend(struct pci_dev *pcid, pm_message_t state)
 	MACbShutdown(priv);
 
 	pci_disable_device(pcid);
-	pci_set_power_state(pcid, pci_choose_state(pcid, state));
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
+	pci_set_power_state(pcid, pci_choose_state(pcid, state));
+
 	return 0;
 }
 

commit 7959c3314cc333cac9e0b9becddd968cd4a48188
Author: Marko Stankovic <dartnorris@gmail.com>
Date:   Wed May 24 00:25:24 2017 +0200

    staging: vt6655: align function parameters to open parenthesis
    
    Alignment styles are used interchangeably, align parameters to open
    parenthesis and fix issues reported by checkpatch.pl
    
    Signed-off-by: Marko Stankovic <dartnorris@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 78804eaec608..9fcf2e223f71 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1310,8 +1310,8 @@ static int vnt_config(struct ieee80211_hw *hw, u32 changed)
 }
 
 static void vnt_bss_info_changed(struct ieee80211_hw *hw,
-		struct ieee80211_vif *vif, struct ieee80211_bss_conf *conf,
-		u32 changed)
+				 struct ieee80211_vif *vif,
+				 struct ieee80211_bss_conf *conf, u32 changed)
 {
 	struct vnt_private *priv = hw->priv;
 
@@ -1401,7 +1401,7 @@ static void vnt_bss_info_changed(struct ieee80211_hw *hw,
 }
 
 static u64 vnt_prepare_multicast(struct ieee80211_hw *hw,
-	struct netdev_hw_addr_list *mc_list)
+				 struct netdev_hw_addr_list *mc_list)
 {
 	struct vnt_private *priv = hw->priv;
 	struct netdev_hw_addr *ha;
@@ -1420,7 +1420,8 @@ static u64 vnt_prepare_multicast(struct ieee80211_hw *hw,
 }
 
 static void vnt_configure(struct ieee80211_hw *hw,
-	unsigned int changed_flags, unsigned int *total_flags, u64 multicast)
+			  unsigned int changed_flags,
+			  unsigned int *total_flags, u64 multicast)
 {
 	struct vnt_private *priv = hw->priv;
 	u8 rx_mode = 0;
@@ -1481,8 +1482,8 @@ static void vnt_configure(struct ieee80211_hw *hw,
 }
 
 static int vnt_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
-	struct ieee80211_vif *vif, struct ieee80211_sta *sta,
-		struct ieee80211_key_conf *key)
+		       struct ieee80211_vif *vif, struct ieee80211_sta *sta,
+		       struct ieee80211_key_conf *key)
 {
 	struct vnt_private *priv = hw->priv;
 

commit 5c60befe6df8ec85282728677f4445f5e2aab3ee
Author: Marko Stankovic <dartnorris@gmail.com>
Date:   Tue May 23 01:19:44 2017 +0200

    staging: vt6655: remove unnecessary blank lines
    
    Fix unnecessary blank lines issues reported by checkpatch.pl
    
    Signed-off-by: Marko Stankovic <dartnorris@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1c652f0ff3ba..78804eaec608 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1018,7 +1018,6 @@ static void vnt_interrupt_process(struct vnt_private *priv)
 			}
 
 			/* TODO: adhoc PS mode */
-
 		}
 
 		if (isr & ISR_BNTX) {
@@ -1702,7 +1701,6 @@ static int vt6655_suspend(struct pci_dev *pcid, pm_message_t state)
 
 static int vt6655_resume(struct pci_dev *pcid)
 {
-
 	pci_set_power_state(pcid, PCI_D0);
 	pci_enable_wake(pcid, PCI_D0, 0);
 	pci_restore_state(pcid);

commit 3621014af3847d95947a5baa528e53c2322ef934
Author: Marko Stankovic <dartnorris@gmail.com>
Date:   Tue May 23 01:19:43 2017 +0200

    staging: vt6655: replace NULL comparison with '!' operator
    
    Fix comparison to NULL issues reported by checkpatch.pl
    
    Signed-off-by: Marko Stankovic <dartnorris@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index da0f71191009..1c652f0ff3ba 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -157,7 +157,7 @@ static void vt6655_remove(struct pci_dev *pcid)
 {
 	struct vnt_private *priv = pci_get_drvdata(pcid);
 
-	if (priv == NULL)
+	if (!priv)
 		return;
 	device_free_info(priv);
 }
@@ -453,7 +453,7 @@ static bool device_init_rings(struct vnt_private *priv)
 				       priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) +
 				       priv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),
 				       &priv->pool_dma, GFP_ATOMIC);
-	if (vir_pool == NULL) {
+	if (!vir_pool) {
 		dev_err(&priv->pcid->dev, "allocate desc dma memory failed\n");
 		return false;
 	}

commit e5851dc05bbd669d04d660b505791b0f32b2e275
Author: PrasannaKumar Muralidharan <prasannatsmkumar@gmail.com>
Date:   Sat Dec 3 11:25:51 2016 +0530

    staging: vt6655: Add spaces around +
    
    Add spaces around + for better readability of the code.
    
    Signed-off-by: PrasannaKumar Muralidharan <prasannatsmkumar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index a6f7a4f0dcd5..da0f71191009 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -310,7 +310,7 @@ static void device_init_registers(struct vnt_private *priv)
 			SROMbyReadEmbedded(priv->PortOffset,
 					   (unsigned char)(ii + EEP_OFS_CCK_PWR_TBL));
 		if (priv->abyCCKPwrTbl[ii + 1] == 0)
-			priv->abyCCKPwrTbl[ii+1] = priv->byCCKPwr;
+			priv->abyCCKPwrTbl[ii + 1] = priv->byCCKPwr;
 
 		priv->abyOFDMPwrTbl[ii + 1] =
 			SROMbyReadEmbedded(priv->PortOffset,
@@ -552,7 +552,7 @@ static void device_init_rd0_ring(struct vnt_private *priv)
 		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
 
-		desc->next = &(priv->aRD0Ring[(i+1) % priv->opts.rx_descs0]);
+		desc->next = &(priv->aRD0Ring[(i + 1) % priv->opts.rx_descs0]);
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 

commit 21971f3e0e558db280c9b01d461364e8442d0ef9
Author: Varsha Rao <rvarsha016@gmail.com>
Date:   Tue Oct 11 19:05:46 2016 +0530

    staging: vt6655: Removes the FSF mailing address.
    
    This patch fixes the checkpatch issue by removing the Free Software
    Foundation's mailing address from the sample GPL notice. Because the FSF
    has changed address in the past, and may change again. Linux already
    includes a copy of the GPL.
    
    Signed-off-by: Varsha Rao <rvarsha016@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 9b2ec257b9f3..a6f7a4f0dcd5 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -12,10 +12,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
  * File: device_main.c
  *
  * Purpose: driver entry for initial, open, close, tx and rx.

commit 3d30311c0e4d834c94e6a27d6242a942d6a76b85
Author: Varsha Rao <rvarsha016@gmail.com>
Date:   Sun Oct 9 16:43:56 2016 +0530

    staging: vt6655: Removes unnecessary blank lines.
    
    This patch fixes the checkpatch issue of
    multiple blank lines, by removing them.
    
    Signed-off-by: Varsha Rao <rvarsha016@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f109eeac358d..9b2ec257b9f3 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1272,7 +1272,6 @@ static void vnt_remove_interface(struct ieee80211_hw *hw,
 	priv->op_mode = NL80211_IFTYPE_UNSPECIFIED;
 }
 
-
 static int vnt_config(struct ieee80211_hw *hw, u32 changed)
 {
 	struct vnt_private *priv = hw->priv;

commit 7cfae24953fa79c69f1bf4edbf44546648de55ba
Author: Namrata A Shettar <namrataashettar@gmail.com>
Date:   Sun Sep 18 14:34:51 2016 +0530

    staging: vt6655: device_main: Replace NULL comparison with !x
    
    Replace NULL comparison to resolve checkpatch issue.
    - x == NULL => !x
    
    Signed-off-by: Namrata A Shettar <namrataashettar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index aea4179dd2d4..f109eeac358d 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -477,7 +477,7 @@ static bool device_init_rings(struct vnt_private *priv)
 					     CB_MAX_BUF_SIZE,
 					     &priv->tx_bufs_dma0,
 					     GFP_ATOMIC);
-	if (priv->tx0_bufs == NULL) {
+	if (!priv->tx0_bufs) {
 		dev_err(&priv->pcid->dev, "allocate buf dma memory failed\n");
 
 		dma_free_coherent(&priv->pcid->dev,

commit 8f4166d888cb41b112ea38ceb037ba2f4f156c5b
Author: Namrata A Shettar <namrataashettar@gmail.com>
Date:   Sun Sep 18 14:35:13 2016 +0530

    staging: vt6655: device_main: Replace explicit NULL comparison
    
    Replace NULL comparison to resolve checkpatch issue.
    - x == NULL => !x
    
    Signed-off-by: Namrata A Shettar <namrataashettar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ed12b5c7fe43..aea4179dd2d4 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -735,7 +735,7 @@ static bool device_alloc_rx_buf(struct vnt_private *priv,
 	struct vnt_rd_info *rd_info = rd->rd_info;
 
 	rd_info->skb = dev_alloc_skb((int)priv->rx_buf_sz);
-	if (rd_info->skb == NULL)
+	if (!rd_info->skb)
 		return false;
 
 	rd_info->skb_dma =

commit 9877f9de5046309dd96af18585dbcfac4f4ab440
Author: Anson Jacob <ansonjacob.aj@gmail.com>
Date:   Fri Jul 8 21:27:05 2016 -0400

    staging: vt6655: Fix checkpatch warning
    
    Fix warning by checkpatch.pl
    Add * for block comments on subsequent lines
    
    Signed-off-by: Anson Jacob <ansonjacob.aj@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 494164045a0f..ed12b5c7fe43 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -113,10 +113,10 @@ DEVICE_PARAM(ShortRetryLimit, "Short frame retry limits");
 DEVICE_PARAM(LongRetryLimit, "long frame retry limits");
 
 /* BasebandType[] baseband type selected
-   0: indicate 802.11a type
-   1: indicate 802.11b type
-   2: indicate 802.11g type
-*/
+ * 0: indicate 802.11a type
+ * 1: indicate 802.11b type
+ * 2: indicate 802.11g type
+ */
 #define BBP_TYPE_MIN     0
 #define BBP_TYPE_MAX     2
 #define BBP_TYPE_DEF     2

commit 57fbcce37be7c1d2622b56587c10ade00e96afa3
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Apr 12 15:56:15 2016 +0200

    cfg80211: remove enum ieee80211_band
    
    This enum is already perfectly aliased to enum nl80211_band, and
    the only reason for it is that we get IEEE80211_NUM_BANDS out of
    it. There's no really good reason to not declare the number of
    bands in nl80211 though, so do that and remove the cfg80211 one.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c3eea07ca97e..494164045a0f 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -812,7 +812,7 @@ static int vnt_int_report_rate(struct vnt_private *priv,
 		else if (fb_option & FIFOCTL_AUTO_FB_1)
 			tx_rate = fallback_rate1[tx_rate][retry];
 
-		if (info->band == IEEE80211_BAND_5GHZ)
+		if (info->band == NL80211_BAND_5GHZ)
 			idx = tx_rate - RATE_6M;
 		else
 			idx = tx_rate;
@@ -1290,7 +1290,7 @@ static int vnt_config(struct ieee80211_hw *hw, u32 changed)
 	    (conf->flags & IEEE80211_CONF_OFFCHANNEL)) {
 		set_channel(priv, conf->chandef.chan);
 
-		if (conf->chandef.chan->band == IEEE80211_BAND_5GHZ)
+		if (conf->chandef.chan->band == NL80211_BAND_5GHZ)
 			bb_type = BB_TYPE_11A;
 		else
 			bb_type = BB_TYPE_11G;

commit 50aefc19c7696973ea6d2cea3c2620b1217a6756
Author: Sandhya Bankar <bankarsandhya512@gmail.com>
Date:   Sun Mar 6 12:43:27 2016 +0530

    Staging: vt6655: Remove & from function name.
    
    Remove & from function name,when function name passed as an argument to another function.
    Function name is used as pointer without &.
    
    Signed-off-by: Sandhya Bankar <bankarsandhya512@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 8a1ed62e2f57..c3eea07ca97e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1171,7 +1171,7 @@ static int vnt_start(struct ieee80211_hw *hw)
 	if (!device_init_rings(priv))
 		return -ENOMEM;
 
-	ret = request_irq(priv->pcid->irq, &vnt_interrupt,
+	ret = request_irq(priv->pcid->irq, vnt_interrupt,
 			  IRQF_SHARED, "vt6655", priv);
 	if (ret) {
 		dev_dbg(&priv->pcid->dev, "failed to start irq\n");

commit 2fbf6d61664ba04d4c7872cbb46720e49264cf3a
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Thu Feb 11 21:34:40 2016 +0300

    Staging: vt6655: Add check dma_mapping_error
    
    This patch checks for dma_mapping_error() after using dma_map_single.
    If the dma map fails we release skb buff allocated by dev_alloc_skb() to
    avoid possible causes of resource leak.
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ad0fb84e5096..8a1ed62e2f57 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -742,6 +742,11 @@ static bool device_alloc_rx_buf(struct vnt_private *priv,
 		dma_map_single(&priv->pcid->dev,
 			       skb_put(rd_info->skb, skb_tailroom(rd_info->skb)),
 			       priv->rx_buf_sz, DMA_FROM_DEVICE);
+	if (dma_mapping_error(&priv->pcid->dev, rd_info->skb_dma)) {
+		dev_kfree_skb(rd_info->skb);
+		rd_info->skb = NULL;
+		return false;
+	}
 
 	*((unsigned int *)&rd->rd0) = 0; /* FIX cast */
 

commit f9f853af84c9205ba9dbc461da0f11da1f4abb53
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Nov 22 09:07:22 2015 +0000

    staging: vt6655: mac.c replace void __iomem * with struct vnt_private
    
    Moving void __iomem down one level in the following functions
    MACbIsRegBitsOn
    MACbIsRegBitsOff
    MACbIsIntDisable
    MACvSetShortRetryLimit
    MACvSetLongRetryLimit
    MACvGetLongRetryLimit
    MACvSetLoopbackMode
    MACvSaveContext
    MACvRestoreContext
    MACbSoftwareReset
    MACbSafeSoftwareReset
    MACbSafeRxOff
    MACbSafeTxOff
    MACbSafeStop
    MACbShutdown
    MACvInitialize
    MACvSetCurrRx0DescAddr
    MACvSetCurrRx1DescAddr
    MACvSetCurrTXDescAddr
    MACvSetCurrTx0DescAddrEx
    MACvSetCurrAC0DescAddrEx
    MACvSetCurrSyncDescAddrEx
    MACvSetCurrATIMDescAddrEx
    MACvTimer0MicroSDelay
    MACvOneShotTimer1MicroSec
    MACvSetMISCFifo
    MACbPSWakeup
    MACvSetKeyEntry
    MACvDisableKeyEntry
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index fefbf826c622..ad0fb84e5096 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -211,11 +211,11 @@ static void device_init_registers(struct vnt_private *priv)
 	unsigned char byCCKPwrdBm = 0;
 	unsigned char byOFDMPwrdBm = 0;
 
-	MACbShutdown(priv->PortOffset);
+	MACbShutdown(priv);
 	BBvSoftwareReset(priv);
 
 	/* Do MACbSoftwareReset in MACvInitialize */
-	MACbSoftwareReset(priv->PortOffset);
+	MACbSoftwareReset(priv);
 
 	priv->bAES = false;
 
@@ -229,7 +229,7 @@ static void device_init_registers(struct vnt_private *priv)
 	priv->byTopCCKBasicRate = RATE_1M;
 
 	/* init MAC */
-	MACvInitialize(priv->PortOffset);
+	MACvInitialize(priv);
 
 	/* Get Local ID */
 	VNSvInPortB(priv->PortOffset + MAC_REG_LOCALID, &priv->byLocalID);
@@ -357,8 +357,8 @@ static void device_init_registers(struct vnt_private *priv)
 			  MAC_REG_CFG, (CFG_TKIPOPT | CFG_NOTXTIMEOUT));
 
 	/* set performance parameter by registry */
-	MACvSetShortRetryLimit(priv->PortOffset, priv->byShortRetryLimit);
-	MACvSetLongRetryLimit(priv->PortOffset, priv->byLongRetryLimit);
+	MACvSetShortRetryLimit(priv, priv->byShortRetryLimit);
+	MACvSetLongRetryLimit(priv, priv->byLongRetryLimit);
 
 	/* reset TSF counter */
 	VNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
@@ -884,7 +884,7 @@ static void device_error(struct vnt_private *priv, unsigned short status)
 	if (status & ISR_FETALERR) {
 		dev_err(&priv->pcid->dev, "Hardware fatal error\n");
 
-		MACbShutdown(priv->PortOffset);
+		MACbShutdown(priv);
 		return;
 	}
 }
@@ -1012,7 +1012,7 @@ static void vnt_interrupt_process(struct vnt_private *priv)
 			if ((priv->op_mode == NL80211_IFTYPE_AP ||
 			    priv->op_mode == NL80211_IFTYPE_ADHOC) &&
 			    priv->vif->bss_conf.enable_beacon) {
-				MACvOneShotTimer1MicroSec(priv->PortOffset,
+				MACvOneShotTimer1MicroSec(priv,
 							  (priv->vif->bss_conf.beacon_int - MAKE_BEACON_RESERVED) << 10);
 			}
 
@@ -1197,8 +1197,8 @@ static void vnt_stop(struct ieee80211_hw *hw)
 
 	cancel_work_sync(&priv->interrupt_work);
 
-	MACbShutdown(priv->PortOffset);
-	MACbSoftwareReset(priv->PortOffset);
+	MACbShutdown(priv);
+	MACbSoftwareReset(priv);
 	CARDbRadioPowerOff(priv);
 
 	device_free_td0_ring(priv);
@@ -1636,13 +1636,13 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	INIT_WORK(&priv->interrupt_work, vnt_interrupt_work);
 
 	/* do reset */
-	if (!MACbSoftwareReset(priv->PortOffset)) {
+	if (!MACbSoftwareReset(priv)) {
 		dev_err(&pcid->dev, ": Failed to access MAC hardware..\n");
 		device_free_info(priv);
 		return -ENODEV;
 	}
 	/* initial to reload eeprom */
-	MACvInitialize(priv->PortOffset);
+	MACvInitialize(priv);
 	MACvReadEtherAddress(priv->PortOffset, priv->abyCurrentNetAddr);
 
 	/* Get RFType */
@@ -1690,7 +1690,7 @@ static int vt6655_suspend(struct pci_dev *pcid, pm_message_t state)
 
 	pci_save_state(pcid);
 
-	MACbShutdown(priv->PortOffset);
+	MACbShutdown(priv);
 
 	pci_disable_device(pcid);
 	pci_set_power_state(pcid, pci_choose_state(pcid, state));

commit bc667b99ccb7392c33b9fd46360356b11755979c
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Oct 17 11:33:01 2015 +0100

    staging: vt6655: rename pOpts and sOpts to opts.
    
    bring pointers and members into line.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index d305d7ab466f..fefbf826c622 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -168,25 +168,25 @@ static void vt6655_remove(struct pci_dev *pcid)
 
 static void device_get_options(struct vnt_private *priv)
 {
-	struct vnt_options *pOpts = &priv->sOpts;
+	struct vnt_options *opts = &priv->opts;
 
-	pOpts->rx_descs0 = RX_DESC_DEF0;
-	pOpts->rx_descs1 = RX_DESC_DEF1;
-	pOpts->tx_descs[0] = TX_DESC_DEF0;
-	pOpts->tx_descs[1] = TX_DESC_DEF1;
-	pOpts->int_works = INT_WORKS_DEF;
+	opts->rx_descs0 = RX_DESC_DEF0;
+	opts->rx_descs1 = RX_DESC_DEF1;
+	opts->tx_descs[0] = TX_DESC_DEF0;
+	opts->tx_descs[1] = TX_DESC_DEF1;
+	opts->int_works = INT_WORKS_DEF;
 
-	pOpts->short_retry = SHORT_RETRY_DEF;
-	pOpts->long_retry = LONG_RETRY_DEF;
-	pOpts->bbp_type = BBP_TYPE_DEF;
+	opts->short_retry = SHORT_RETRY_DEF;
+	opts->long_retry = LONG_RETRY_DEF;
+	opts->bbp_type = BBP_TYPE_DEF;
 }
 
 static void
 device_set_options(struct vnt_private *priv)
 {
-	priv->byShortRetryLimit = priv->sOpts.short_retry;
-	priv->byLongRetryLimit = priv->sOpts.long_retry;
-	priv->byBBType = priv->sOpts.bbp_type;
+	priv->byShortRetryLimit = priv->opts.short_retry;
+	priv->byLongRetryLimit = priv->opts.long_retry;
+	priv->byBBType = priv->opts.bbp_type;
 	priv->byPacketType = priv->byBBType;
 	priv->byAutoFBCtrl = AUTO_FB_0;
 	priv->bUpdateBBVGA = true;
@@ -452,10 +452,10 @@ static bool device_init_rings(struct vnt_private *priv)
 
 	/*allocate all RD/TD rings a single pool*/
 	vir_pool = dma_zalloc_coherent(&priv->pcid->dev,
-				       priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc) +
-				       priv->sOpts.rx_descs1 * sizeof(struct vnt_rx_desc) +
-				       priv->sOpts.tx_descs[0] * sizeof(struct vnt_tx_desc) +
-				       priv->sOpts.tx_descs[1] * sizeof(struct vnt_tx_desc),
+				       priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) +
+				       priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) +
+				       priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) +
+				       priv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),
 				       &priv->pool_dma, GFP_ATOMIC);
 	if (vir_pool == NULL) {
 		dev_err(&priv->pcid->dev, "allocate desc dma memory failed\n");
@@ -464,15 +464,15 @@ static bool device_init_rings(struct vnt_private *priv)
 
 	priv->aRD0Ring = vir_pool;
 	priv->aRD1Ring = vir_pool +
-		priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc);
+		priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc);
 
 	priv->rd0_pool_dma = priv->pool_dma;
 	priv->rd1_pool_dma = priv->rd0_pool_dma +
-		priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc);
+		priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc);
 
 	priv->tx0_bufs = dma_zalloc_coherent(&priv->pcid->dev,
-					     priv->sOpts.tx_descs[0] * PKT_BUF_SZ +
-					     priv->sOpts.tx_descs[1] * PKT_BUF_SZ +
+					     priv->opts.tx_descs[0] * PKT_BUF_SZ +
+					     priv->opts.tx_descs[1] * PKT_BUF_SZ +
 					     CB_BEACON_BUF_SIZE +
 					     CB_MAX_BUF_SIZE,
 					     &priv->tx_bufs_dma0,
@@ -481,44 +481,44 @@ static bool device_init_rings(struct vnt_private *priv)
 		dev_err(&priv->pcid->dev, "allocate buf dma memory failed\n");
 
 		dma_free_coherent(&priv->pcid->dev,
-				  priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc) +
-				  priv->sOpts.rx_descs1 * sizeof(struct vnt_rx_desc) +
-				  priv->sOpts.tx_descs[0] * sizeof(struct vnt_tx_desc) +
-				  priv->sOpts.tx_descs[1] * sizeof(struct vnt_tx_desc),
+				  priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) +
+				  priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) +
+				  priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) +
+				  priv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),
 				  vir_pool, priv->pool_dma);
 		return false;
 	}
 
 	priv->td0_pool_dma = priv->rd1_pool_dma +
-		priv->sOpts.rx_descs1 * sizeof(struct vnt_rx_desc);
+		priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc);
 
 	priv->td1_pool_dma = priv->td0_pool_dma +
-		priv->sOpts.tx_descs[0] * sizeof(struct vnt_tx_desc);
+		priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc);
 
 	/* vir_pool: pvoid type */
 	priv->apTD0Rings = vir_pool
-		+ priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc)
-		+ priv->sOpts.rx_descs1 * sizeof(struct vnt_rx_desc);
+		+ priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc)
+		+ priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc);
 
 	priv->apTD1Rings = vir_pool
-		+ priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc)
-		+ priv->sOpts.rx_descs1 * sizeof(struct vnt_rx_desc)
-		+ priv->sOpts.tx_descs[0] * sizeof(struct vnt_tx_desc);
+		+ priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc)
+		+ priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc)
+		+ priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc);
 
 	priv->tx1_bufs = priv->tx0_bufs +
-		priv->sOpts.tx_descs[0] * PKT_BUF_SZ;
+		priv->opts.tx_descs[0] * PKT_BUF_SZ;
 
 	priv->tx_beacon_bufs = priv->tx1_bufs +
-		priv->sOpts.tx_descs[1] * PKT_BUF_SZ;
+		priv->opts.tx_descs[1] * PKT_BUF_SZ;
 
 	priv->pbyTmpBuff = priv->tx_beacon_bufs +
 		CB_BEACON_BUF_SIZE;
 
 	priv->tx_bufs_dma1 = priv->tx_bufs_dma0 +
-		priv->sOpts.tx_descs[0] * PKT_BUF_SZ;
+		priv->opts.tx_descs[0] * PKT_BUF_SZ;
 
 	priv->tx_beacon_dma = priv->tx_bufs_dma1 +
-		priv->sOpts.tx_descs[1] * PKT_BUF_SZ;
+		priv->opts.tx_descs[1] * PKT_BUF_SZ;
 
 	return true;
 }
@@ -526,16 +526,16 @@ static bool device_init_rings(struct vnt_private *priv)
 static void device_free_rings(struct vnt_private *priv)
 {
 	dma_free_coherent(&priv->pcid->dev,
-			  priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc) +
-			  priv->sOpts.rx_descs1 * sizeof(struct vnt_rx_desc) +
-			  priv->sOpts.tx_descs[0] * sizeof(struct vnt_tx_desc) +
-			  priv->sOpts.tx_descs[1] * sizeof(struct vnt_tx_desc),
+			  priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) +
+			  priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) +
+			  priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) +
+			  priv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),
 			  priv->aRD0Ring, priv->pool_dma);
 
 	if (priv->tx0_bufs)
 		dma_free_coherent(&priv->pcid->dev,
-				  priv->sOpts.tx_descs[0] * PKT_BUF_SZ +
-				  priv->sOpts.tx_descs[1] * PKT_BUF_SZ +
+				  priv->opts.tx_descs[0] * PKT_BUF_SZ +
+				  priv->opts.tx_descs[1] * PKT_BUF_SZ +
 				  CB_BEACON_BUF_SIZE +
 				  CB_MAX_BUF_SIZE,
 				  priv->tx0_bufs, priv->tx_bufs_dma0);
@@ -548,7 +548,7 @@ static void device_init_rd0_ring(struct vnt_private *priv)
 	struct vnt_rx_desc *desc;
 
 	/* Init the RD0 ring entries */
-	for (i = 0; i < priv->sOpts.rx_descs0;
+	for (i = 0; i < priv->opts.rx_descs0;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
 		desc = &priv->aRD0Ring[i];
 		desc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_ATOMIC);
@@ -556,7 +556,7 @@ static void device_init_rd0_ring(struct vnt_private *priv)
 		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
 
-		desc->next = &(priv->aRD0Ring[(i+1) % priv->sOpts.rx_descs0]);
+		desc->next = &(priv->aRD0Ring[(i+1) % priv->opts.rx_descs0]);
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 
@@ -572,7 +572,7 @@ static void device_init_rd1_ring(struct vnt_private *priv)
 	struct vnt_rx_desc *desc;
 
 	/* Init the RD1 ring entries */
-	for (i = 0; i < priv->sOpts.rx_descs1;
+	for (i = 0; i < priv->opts.rx_descs1;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
 		desc = &priv->aRD1Ring[i];
 		desc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_ATOMIC);
@@ -580,7 +580,7 @@ static void device_init_rd1_ring(struct vnt_private *priv)
 		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
 
-		desc->next = &(priv->aRD1Ring[(i+1) % priv->sOpts.rx_descs1]);
+		desc->next = &(priv->aRD1Ring[(i+1) % priv->opts.rx_descs1]);
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 
@@ -593,7 +593,7 @@ static void device_free_rd0_ring(struct vnt_private *priv)
 {
 	int i;
 
-	for (i = 0; i < priv->sOpts.rx_descs0; i++) {
+	for (i = 0; i < priv->opts.rx_descs0; i++) {
 		struct vnt_rx_desc *desc = &(priv->aRD0Ring[i]);
 		struct vnt_rd_info *rd_info = desc->rd_info;
 
@@ -610,7 +610,7 @@ static void device_free_rd1_ring(struct vnt_private *priv)
 {
 	int i;
 
-	for (i = 0; i < priv->sOpts.rx_descs1; i++) {
+	for (i = 0; i < priv->opts.rx_descs1; i++) {
 		struct vnt_rx_desc *desc = &priv->aRD1Ring[i];
 		struct vnt_rd_info *rd_info = desc->rd_info;
 
@@ -630,7 +630,7 @@ static void device_init_td0_ring(struct vnt_private *priv)
 	struct vnt_tx_desc *desc;
 
 	curr = priv->td0_pool_dma;
-	for (i = 0; i < priv->sOpts.tx_descs[0];
+	for (i = 0; i < priv->opts.tx_descs[0];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
 		desc = &priv->apTD0Rings[i];
 		desc->td_info = kzalloc(sizeof(*desc->td_info), GFP_ATOMIC);
@@ -638,7 +638,7 @@ static void device_init_td0_ring(struct vnt_private *priv)
 		desc->td_info->buf = priv->tx0_bufs + i * PKT_BUF_SZ;
 		desc->td_info->buf_dma = priv->tx_bufs_dma0 + i * PKT_BUF_SZ;
 
-		desc->next = &(priv->apTD0Rings[(i+1) % priv->sOpts.tx_descs[0]]);
+		desc->next = &(priv->apTD0Rings[(i+1) % priv->opts.tx_descs[0]]);
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
 
@@ -655,7 +655,7 @@ static void device_init_td1_ring(struct vnt_private *priv)
 
 	/* Init the TD ring entries */
 	curr = priv->td1_pool_dma;
-	for (i = 0; i < priv->sOpts.tx_descs[1];
+	for (i = 0; i < priv->opts.tx_descs[1];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
 		desc = &priv->apTD1Rings[i];
 		desc->td_info = kzalloc(sizeof(*desc->td_info), GFP_ATOMIC);
@@ -663,7 +663,7 @@ static void device_init_td1_ring(struct vnt_private *priv)
 		desc->td_info->buf = priv->tx1_bufs + i * PKT_BUF_SZ;
 		desc->td_info->buf_dma = priv->tx_bufs_dma1 + i * PKT_BUF_SZ;
 
-		desc->next = &(priv->apTD1Rings[(i + 1) % priv->sOpts.tx_descs[1]]);
+		desc->next = &(priv->apTD1Rings[(i + 1) % priv->opts.tx_descs[1]]);
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
 
@@ -676,7 +676,7 @@ static void device_free_td0_ring(struct vnt_private *priv)
 {
 	int i;
 
-	for (i = 0; i < priv->sOpts.tx_descs[0]; i++) {
+	for (i = 0; i < priv->opts.tx_descs[0]; i++) {
 		struct vnt_tx_desc *desc = &priv->apTD0Rings[i];
 		struct vnt_td_info *td_info = desc->td_info;
 
@@ -689,7 +689,7 @@ static void device_free_td1_ring(struct vnt_private *priv)
 {
 	int i;
 
-	for (i = 0; i < priv->sOpts.tx_descs[1]; i++) {
+	for (i = 0; i < priv->opts.tx_descs[1]; i++) {
 		struct vnt_tx_desc *desc = &priv->apTD1Rings[i];
 		struct vnt_td_info *td_info = desc->td_info;
 
@@ -1057,7 +1057,7 @@ static void vnt_interrupt_process(struct vnt_private *priv)
 		MACvReceive0(priv->PortOffset);
 		MACvReceive1(priv->PortOffset);
 
-		if (max_count > priv->sOpts.int_works)
+		if (max_count > priv->opts.int_works)
 			break;
 	}
 

commit 068b998835168b5107d1e62a346f52b9f44ed10b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Oct 17 11:33:00 2015 +0100

    staging: vt6655: remove static inline alloc_td_info.
    
    Since this only contains one function and used only twice remove
    inline altogether.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index aa8f750ebf80..d305d7ab466f 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -633,7 +633,7 @@ static void device_init_td0_ring(struct vnt_private *priv)
 	for (i = 0; i < priv->sOpts.tx_descs[0];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
 		desc = &priv->apTD0Rings[i];
-		desc->td_info = alloc_td_info();
+		desc->td_info = kzalloc(sizeof(*desc->td_info), GFP_ATOMIC);
 
 		desc->td_info->buf = priv->tx0_bufs + i * PKT_BUF_SZ;
 		desc->td_info->buf_dma = priv->tx_bufs_dma0 + i * PKT_BUF_SZ;
@@ -658,7 +658,7 @@ static void device_init_td1_ring(struct vnt_private *priv)
 	for (i = 0; i < priv->sOpts.tx_descs[1];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
 		desc = &priv->apTD1Rings[i];
-		desc->td_info = alloc_td_info();
+		desc->td_info = kzalloc(sizeof(*desc->td_info), GFP_ATOMIC);
 
 		desc->td_info->buf = priv->tx1_bufs + i * PKT_BUF_SZ;
 		desc->td_info->buf_dma = priv->tx_bufs_dma1 + i * PKT_BUF_SZ;

commit e06cf9aba8dadb92b1ec12a757d0a824c022176f
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Oct 17 11:32:59 2015 +0100

    staging: vt6655: remove static inline alloc_rd_info.
    
    Since this only contains one function and only used twice
    remove inline altogether.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 8bca3fcf09be..aa8f750ebf80 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -551,7 +551,7 @@ static void device_init_rd0_ring(struct vnt_private *priv)
 	for (i = 0; i < priv->sOpts.rx_descs0;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
 		desc = &priv->aRD0Ring[i];
-		desc->rd_info = alloc_rd_info();
+		desc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_ATOMIC);
 
 		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
@@ -575,7 +575,7 @@ static void device_init_rd1_ring(struct vnt_private *priv)
 	for (i = 0; i < priv->sOpts.rx_descs1;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
 		desc = &priv->aRD1Ring[i];
-		desc->rd_info = alloc_rd_info();
+		desc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_ATOMIC);
 
 		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");

commit bed02d93a1e3d6880982f9429aa75334afd29851
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Oct 17 11:32:58 2015 +0100

    staging: vt6655: replace typedef struct __device_opt
    
    with struct vnt_options and members
    rx_descs0 for nRxDescs0
    rx_descs1 for nRxDescs1
    tx_descs for nTxDescs
    int_works
    short_retry
    long_retry
    bbp_type
    flags
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0ed82a644d15..8bca3fcf09be 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -168,12 +168,12 @@ static void vt6655_remove(struct pci_dev *pcid)
 
 static void device_get_options(struct vnt_private *priv)
 {
-	POPTIONS pOpts = &priv->sOpts;
+	struct vnt_options *pOpts = &priv->sOpts;
 
-	pOpts->nRxDescs0 = RX_DESC_DEF0;
-	pOpts->nRxDescs1 = RX_DESC_DEF1;
-	pOpts->nTxDescs[0] = TX_DESC_DEF0;
-	pOpts->nTxDescs[1] = TX_DESC_DEF1;
+	pOpts->rx_descs0 = RX_DESC_DEF0;
+	pOpts->rx_descs1 = RX_DESC_DEF1;
+	pOpts->tx_descs[0] = TX_DESC_DEF0;
+	pOpts->tx_descs[1] = TX_DESC_DEF1;
 	pOpts->int_works = INT_WORKS_DEF;
 
 	pOpts->short_retry = SHORT_RETRY_DEF;
@@ -452,10 +452,10 @@ static bool device_init_rings(struct vnt_private *priv)
 
 	/*allocate all RD/TD rings a single pool*/
 	vir_pool = dma_zalloc_coherent(&priv->pcid->dev,
-				       priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc) +
-				       priv->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc) +
-				       priv->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
-				       priv->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc),
+				       priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc) +
+				       priv->sOpts.rx_descs1 * sizeof(struct vnt_rx_desc) +
+				       priv->sOpts.tx_descs[0] * sizeof(struct vnt_tx_desc) +
+				       priv->sOpts.tx_descs[1] * sizeof(struct vnt_tx_desc),
 				       &priv->pool_dma, GFP_ATOMIC);
 	if (vir_pool == NULL) {
 		dev_err(&priv->pcid->dev, "allocate desc dma memory failed\n");
@@ -464,15 +464,15 @@ static bool device_init_rings(struct vnt_private *priv)
 
 	priv->aRD0Ring = vir_pool;
 	priv->aRD1Ring = vir_pool +
-		priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc);
+		priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc);
 
 	priv->rd0_pool_dma = priv->pool_dma;
 	priv->rd1_pool_dma = priv->rd0_pool_dma +
-		priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc);
+		priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc);
 
 	priv->tx0_bufs = dma_zalloc_coherent(&priv->pcid->dev,
-					     priv->sOpts.nTxDescs[0] * PKT_BUF_SZ +
-					     priv->sOpts.nTxDescs[1] * PKT_BUF_SZ +
+					     priv->sOpts.tx_descs[0] * PKT_BUF_SZ +
+					     priv->sOpts.tx_descs[1] * PKT_BUF_SZ +
 					     CB_BEACON_BUF_SIZE +
 					     CB_MAX_BUF_SIZE,
 					     &priv->tx_bufs_dma0,
@@ -481,44 +481,44 @@ static bool device_init_rings(struct vnt_private *priv)
 		dev_err(&priv->pcid->dev, "allocate buf dma memory failed\n");
 
 		dma_free_coherent(&priv->pcid->dev,
-				  priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc) +
-				  priv->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc) +
-				  priv->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
-				  priv->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc),
+				  priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc) +
+				  priv->sOpts.rx_descs1 * sizeof(struct vnt_rx_desc) +
+				  priv->sOpts.tx_descs[0] * sizeof(struct vnt_tx_desc) +
+				  priv->sOpts.tx_descs[1] * sizeof(struct vnt_tx_desc),
 				  vir_pool, priv->pool_dma);
 		return false;
 	}
 
 	priv->td0_pool_dma = priv->rd1_pool_dma +
-		priv->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc);
+		priv->sOpts.rx_descs1 * sizeof(struct vnt_rx_desc);
 
 	priv->td1_pool_dma = priv->td0_pool_dma +
-		priv->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc);
+		priv->sOpts.tx_descs[0] * sizeof(struct vnt_tx_desc);
 
 	/* vir_pool: pvoid type */
 	priv->apTD0Rings = vir_pool
-		+ priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc)
-		+ priv->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc);
+		+ priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc)
+		+ priv->sOpts.rx_descs1 * sizeof(struct vnt_rx_desc);
 
 	priv->apTD1Rings = vir_pool
-		+ priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc)
-		+ priv->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc)
-		+ priv->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc);
+		+ priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc)
+		+ priv->sOpts.rx_descs1 * sizeof(struct vnt_rx_desc)
+		+ priv->sOpts.tx_descs[0] * sizeof(struct vnt_tx_desc);
 
 	priv->tx1_bufs = priv->tx0_bufs +
-		priv->sOpts.nTxDescs[0] * PKT_BUF_SZ;
+		priv->sOpts.tx_descs[0] * PKT_BUF_SZ;
 
 	priv->tx_beacon_bufs = priv->tx1_bufs +
-		priv->sOpts.nTxDescs[1] * PKT_BUF_SZ;
+		priv->sOpts.tx_descs[1] * PKT_BUF_SZ;
 
 	priv->pbyTmpBuff = priv->tx_beacon_bufs +
 		CB_BEACON_BUF_SIZE;
 
 	priv->tx_bufs_dma1 = priv->tx_bufs_dma0 +
-		priv->sOpts.nTxDescs[0] * PKT_BUF_SZ;
+		priv->sOpts.tx_descs[0] * PKT_BUF_SZ;
 
 	priv->tx_beacon_dma = priv->tx_bufs_dma1 +
-		priv->sOpts.nTxDescs[1] * PKT_BUF_SZ;
+		priv->sOpts.tx_descs[1] * PKT_BUF_SZ;
 
 	return true;
 }
@@ -526,16 +526,16 @@ static bool device_init_rings(struct vnt_private *priv)
 static void device_free_rings(struct vnt_private *priv)
 {
 	dma_free_coherent(&priv->pcid->dev,
-			  priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc) +
-			  priv->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc) +
-			  priv->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
-			  priv->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc),
+			  priv->sOpts.rx_descs0 * sizeof(struct vnt_rx_desc) +
+			  priv->sOpts.rx_descs1 * sizeof(struct vnt_rx_desc) +
+			  priv->sOpts.tx_descs[0] * sizeof(struct vnt_tx_desc) +
+			  priv->sOpts.tx_descs[1] * sizeof(struct vnt_tx_desc),
 			  priv->aRD0Ring, priv->pool_dma);
 
 	if (priv->tx0_bufs)
 		dma_free_coherent(&priv->pcid->dev,
-				  priv->sOpts.nTxDescs[0] * PKT_BUF_SZ +
-				  priv->sOpts.nTxDescs[1] * PKT_BUF_SZ +
+				  priv->sOpts.tx_descs[0] * PKT_BUF_SZ +
+				  priv->sOpts.tx_descs[1] * PKT_BUF_SZ +
 				  CB_BEACON_BUF_SIZE +
 				  CB_MAX_BUF_SIZE,
 				  priv->tx0_bufs, priv->tx_bufs_dma0);
@@ -548,7 +548,7 @@ static void device_init_rd0_ring(struct vnt_private *priv)
 	struct vnt_rx_desc *desc;
 
 	/* Init the RD0 ring entries */
-	for (i = 0; i < priv->sOpts.nRxDescs0;
+	for (i = 0; i < priv->sOpts.rx_descs0;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
 		desc = &priv->aRD0Ring[i];
 		desc->rd_info = alloc_rd_info();
@@ -556,7 +556,7 @@ static void device_init_rd0_ring(struct vnt_private *priv)
 		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
 
-		desc->next = &(priv->aRD0Ring[(i+1) % priv->sOpts.nRxDescs0]);
+		desc->next = &(priv->aRD0Ring[(i+1) % priv->sOpts.rx_descs0]);
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 
@@ -572,7 +572,7 @@ static void device_init_rd1_ring(struct vnt_private *priv)
 	struct vnt_rx_desc *desc;
 
 	/* Init the RD1 ring entries */
-	for (i = 0; i < priv->sOpts.nRxDescs1;
+	for (i = 0; i < priv->sOpts.rx_descs1;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
 		desc = &priv->aRD1Ring[i];
 		desc->rd_info = alloc_rd_info();
@@ -580,7 +580,7 @@ static void device_init_rd1_ring(struct vnt_private *priv)
 		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
 
-		desc->next = &(priv->aRD1Ring[(i+1) % priv->sOpts.nRxDescs1]);
+		desc->next = &(priv->aRD1Ring[(i+1) % priv->sOpts.rx_descs1]);
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 
@@ -593,7 +593,7 @@ static void device_free_rd0_ring(struct vnt_private *priv)
 {
 	int i;
 
-	for (i = 0; i < priv->sOpts.nRxDescs0; i++) {
+	for (i = 0; i < priv->sOpts.rx_descs0; i++) {
 		struct vnt_rx_desc *desc = &(priv->aRD0Ring[i]);
 		struct vnt_rd_info *rd_info = desc->rd_info;
 
@@ -610,7 +610,7 @@ static void device_free_rd1_ring(struct vnt_private *priv)
 {
 	int i;
 
-	for (i = 0; i < priv->sOpts.nRxDescs1; i++) {
+	for (i = 0; i < priv->sOpts.rx_descs1; i++) {
 		struct vnt_rx_desc *desc = &priv->aRD1Ring[i];
 		struct vnt_rd_info *rd_info = desc->rd_info;
 
@@ -630,7 +630,7 @@ static void device_init_td0_ring(struct vnt_private *priv)
 	struct vnt_tx_desc *desc;
 
 	curr = priv->td0_pool_dma;
-	for (i = 0; i < priv->sOpts.nTxDescs[0];
+	for (i = 0; i < priv->sOpts.tx_descs[0];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
 		desc = &priv->apTD0Rings[i];
 		desc->td_info = alloc_td_info();
@@ -638,7 +638,7 @@ static void device_init_td0_ring(struct vnt_private *priv)
 		desc->td_info->buf = priv->tx0_bufs + i * PKT_BUF_SZ;
 		desc->td_info->buf_dma = priv->tx_bufs_dma0 + i * PKT_BUF_SZ;
 
-		desc->next = &(priv->apTD0Rings[(i+1) % priv->sOpts.nTxDescs[0]]);
+		desc->next = &(priv->apTD0Rings[(i+1) % priv->sOpts.tx_descs[0]]);
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
 
@@ -655,7 +655,7 @@ static void device_init_td1_ring(struct vnt_private *priv)
 
 	/* Init the TD ring entries */
 	curr = priv->td1_pool_dma;
-	for (i = 0; i < priv->sOpts.nTxDescs[1];
+	for (i = 0; i < priv->sOpts.tx_descs[1];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
 		desc = &priv->apTD1Rings[i];
 		desc->td_info = alloc_td_info();
@@ -663,7 +663,7 @@ static void device_init_td1_ring(struct vnt_private *priv)
 		desc->td_info->buf = priv->tx1_bufs + i * PKT_BUF_SZ;
 		desc->td_info->buf_dma = priv->tx_bufs_dma1 + i * PKT_BUF_SZ;
 
-		desc->next = &(priv->apTD1Rings[(i + 1) % priv->sOpts.nTxDescs[1]]);
+		desc->next = &(priv->apTD1Rings[(i + 1) % priv->sOpts.tx_descs[1]]);
 		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
 
@@ -676,7 +676,7 @@ static void device_free_td0_ring(struct vnt_private *priv)
 {
 	int i;
 
-	for (i = 0; i < priv->sOpts.nTxDescs[0]; i++) {
+	for (i = 0; i < priv->sOpts.tx_descs[0]; i++) {
 		struct vnt_tx_desc *desc = &priv->apTD0Rings[i];
 		struct vnt_td_info *td_info = desc->td_info;
 
@@ -689,7 +689,7 @@ static void device_free_td1_ring(struct vnt_private *priv)
 {
 	int i;
 
-	for (i = 0; i < priv->sOpts.nTxDescs[1]; i++) {
+	for (i = 0; i < priv->sOpts.tx_descs[1]; i++) {
 		struct vnt_tx_desc *desc = &priv->apTD1Rings[i];
 		struct vnt_td_info *td_info = desc->td_info;
 

commit 0924a89b0b06ce569c7f536984d64bf6cd2cb4d4
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Oct 17 11:32:54 2015 +0100

    staging: vt6655: device_main Replace uIdx with idx.
    
    Removing camel case.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 673ca47e1889..0ed82a644d15 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -142,8 +142,8 @@ static void device_init_rd1_ring(struct vnt_private *priv);
 static void device_init_td0_ring(struct vnt_private *priv);
 static void device_init_td1_ring(struct vnt_private *priv);
 
-static int  device_rx_srv(struct vnt_private *priv, unsigned int uIdx);
-static int  device_tx_srv(struct vnt_private *priv, unsigned int uIdx);
+static int  device_rx_srv(struct vnt_private *priv, unsigned int idx);
+static int  device_tx_srv(struct vnt_private *priv, unsigned int idx);
 static bool device_alloc_rx_buf(struct vnt_private *, struct vnt_rx_desc *);
 static void device_init_registers(struct vnt_private *priv);
 static void device_free_tx_buf(struct vnt_private *, struct vnt_tx_desc *);
@@ -700,12 +700,12 @@ static void device_free_td1_ring(struct vnt_private *priv)
 
 /*-----------------------------------------------------------------*/
 
-static int device_rx_srv(struct vnt_private *priv, unsigned int uIdx)
+static int device_rx_srv(struct vnt_private *priv, unsigned int idx)
 {
 	struct vnt_rx_desc *rd;
 	int works = 0;
 
-	for (rd = priv->pCurrRD[uIdx];
+	for (rd = priv->pCurrRD[idx];
 	     rd->rd0.owner == OWNED_BY_HOST;
 	     rd = rd->next) {
 		if (works++ > 15)
@@ -724,7 +724,7 @@ static int device_rx_srv(struct vnt_private *priv, unsigned int uIdx)
 		rd->rd0.owner = OWNED_BY_NIC;
 	}
 
-	priv->pCurrRD[uIdx] = rd;
+	priv->pCurrRD[idx] = rd;
 
 	return works;
 }
@@ -829,14 +829,14 @@ static int vnt_int_report_rate(struct vnt_private *priv,
 	return 0;
 }
 
-static int device_tx_srv(struct vnt_private *priv, unsigned int uIdx)
+static int device_tx_srv(struct vnt_private *priv, unsigned int idx)
 {
 	struct vnt_tx_desc *desc;
 	int                      works = 0;
 	unsigned char byTsr0;
 	unsigned char byTsr1;
 
-	for (desc = priv->apTailTD[uIdx]; priv->iTDUsed[uIdx] > 0; desc = desc->next) {
+	for (desc = priv->apTailTD[idx]; priv->iTDUsed[idx] > 0; desc = desc->next) {
 		if (desc->td0.owner == OWNED_BY_NIC)
 			break;
 		if (works++ > 15)
@@ -851,30 +851,30 @@ static int device_tx_srv(struct vnt_private *priv, unsigned int uIdx)
 				if (!(byTsr1 & TSR1_TERR)) {
 					if (byTsr0 != 0) {
 						pr_debug(" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X]\n",
-							 (int)uIdx, byTsr1,
+							 (int)idx, byTsr1,
 							 byTsr0);
 					}
 				} else {
 					pr_debug(" Tx[%d] dropped & tsr1[%02X] tsr0[%02X]\n",
-						 (int)uIdx, byTsr1, byTsr0);
+						 (int)idx, byTsr1, byTsr0);
 				}
 			}
 
 			if (byTsr1 & TSR1_TERR) {
 				if ((desc->td_info->flags & TD_FLAGS_PRIV_SKB) != 0) {
 					pr_debug(" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X]\n",
-						 (int)uIdx, byTsr1, byTsr0);
+						 (int)idx, byTsr1, byTsr0);
 				}
 			}
 
 			vnt_int_report_rate(priv, desc->td_info, byTsr0, byTsr1);
 
 			device_free_tx_buf(priv, desc);
-			priv->iTDUsed[uIdx]--;
+			priv->iTDUsed[idx]--;
 		}
 	}
 
-	priv->apTailTD[uIdx] = desc;
+	priv->apTailTD[idx] = desc;
 
 	return works;
 }

commit 9f31b6955932f9ec2dbf1a1e1827e18ce7239943
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Oct 3 20:30:27 2015 +0100

    staging: vt6655: device_tx_srv rename pTD
    
    Following the convention elsewhere for vnt_tx_desc rename
    desc.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ff329bde19c2..673ca47e1889 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -831,23 +831,23 @@ static int vnt_int_report_rate(struct vnt_private *priv,
 
 static int device_tx_srv(struct vnt_private *priv, unsigned int uIdx)
 {
-	struct vnt_tx_desc *pTD;
+	struct vnt_tx_desc *desc;
 	int                      works = 0;
 	unsigned char byTsr0;
 	unsigned char byTsr1;
 
-	for (pTD = priv->apTailTD[uIdx]; priv->iTDUsed[uIdx] > 0; pTD = pTD->next) {
-		if (pTD->td0.owner == OWNED_BY_NIC)
+	for (desc = priv->apTailTD[uIdx]; priv->iTDUsed[uIdx] > 0; desc = desc->next) {
+		if (desc->td0.owner == OWNED_BY_NIC)
 			break;
 		if (works++ > 15)
 			break;
 
-		byTsr0 = pTD->td0.tsr0;
-		byTsr1 = pTD->td0.tsr1;
+		byTsr0 = desc->td0.tsr0;
+		byTsr1 = desc->td0.tsr1;
 
 		/* Only the status of first TD in the chain is correct */
-		if (pTD->td1.tcr & TCR_STP) {
-			if ((pTD->td_info->flags & TD_FLAGS_NETIF_SKB) != 0) {
+		if (desc->td1.tcr & TCR_STP) {
+			if ((desc->td_info->flags & TD_FLAGS_NETIF_SKB) != 0) {
 				if (!(byTsr1 & TSR1_TERR)) {
 					if (byTsr0 != 0) {
 						pr_debug(" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X]\n",
@@ -861,20 +861,20 @@ static int device_tx_srv(struct vnt_private *priv, unsigned int uIdx)
 			}
 
 			if (byTsr1 & TSR1_TERR) {
-				if ((pTD->td_info->flags & TD_FLAGS_PRIV_SKB) != 0) {
+				if ((desc->td_info->flags & TD_FLAGS_PRIV_SKB) != 0) {
 					pr_debug(" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X]\n",
 						 (int)uIdx, byTsr1, byTsr0);
 				}
 			}
 
-			vnt_int_report_rate(priv, pTD->td_info, byTsr0, byTsr1);
+			vnt_int_report_rate(priv, desc->td_info, byTsr0, byTsr1);
 
-			device_free_tx_buf(priv, pTD);
+			device_free_tx_buf(priv, desc);
 			priv->iTDUsed[uIdx]--;
 		}
 	}
 
-	priv->apTailTD[uIdx] = pTD;
+	priv->apTailTD[uIdx] = desc;
 
 	return works;
 }

commit 12f2ee356ef6658d7311e051a4a481b553155185
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Oct 3 20:30:26 2015 +0100

    staging: vt6655: device_main replace pTDInfo with td_info.
    
    Removing camel case.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 7e76176adbfe..ff329bde19c2 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -678,9 +678,9 @@ static void device_free_td0_ring(struct vnt_private *priv)
 
 	for (i = 0; i < priv->sOpts.nTxDescs[0]; i++) {
 		struct vnt_tx_desc *desc = &priv->apTD0Rings[i];
-		struct vnt_td_info *pTDInfo = desc->td_info;
+		struct vnt_td_info *td_info = desc->td_info;
 
-		dev_kfree_skb(pTDInfo->skb);
+		dev_kfree_skb(td_info->skb);
 		kfree(desc->td_info);
 	}
 }
@@ -691,9 +691,9 @@ static void device_free_td1_ring(struct vnt_private *priv)
 
 	for (i = 0; i < priv->sOpts.nTxDescs[1]; i++) {
 		struct vnt_tx_desc *desc = &priv->apTD1Rings[i];
-		struct vnt_td_info *pTDInfo = desc->td_info;
+		struct vnt_td_info *td_info = desc->td_info;
 
-		dev_kfree_skb(pTDInfo->skb);
+		dev_kfree_skb(td_info->skb);
 		kfree(desc->td_info);
 	}
 }
@@ -892,14 +892,14 @@ static void device_error(struct vnt_private *priv, unsigned short status)
 static void device_free_tx_buf(struct vnt_private *priv,
 			       struct vnt_tx_desc *desc)
 {
-	struct vnt_td_info *pTDInfo = desc->td_info;
-	struct sk_buff *skb = pTDInfo->skb;
+	struct vnt_td_info *td_info = desc->td_info;
+	struct sk_buff *skb = td_info->skb;
 
 	if (skb)
 		ieee80211_tx_status_irqsafe(priv->hw, skb);
 
-	pTDInfo->skb = NULL;
-	pTDInfo->flags = 0;
+	td_info->skb = NULL;
+	td_info->flags = 0;
 }
 
 static void vnt_check_bb_vga(struct vnt_private *priv)

commit 480fc5b8f6b55173bd26f016118cab0416e96d5d
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Oct 3 20:30:25 2015 +0100

    staging: vt6655: device_main replace pRD with rd.
    
    Removing camel case.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index b33037985ee9..7e76176adbfe 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -702,37 +702,37 @@ static void device_free_td1_ring(struct vnt_private *priv)
 
 static int device_rx_srv(struct vnt_private *priv, unsigned int uIdx)
 {
-	struct vnt_rx_desc *pRD;
+	struct vnt_rx_desc *rd;
 	int works = 0;
 
-	for (pRD = priv->pCurrRD[uIdx];
-	     pRD->rd0.owner == OWNED_BY_HOST;
-	     pRD = pRD->next) {
+	for (rd = priv->pCurrRD[uIdx];
+	     rd->rd0.owner == OWNED_BY_HOST;
+	     rd = rd->next) {
 		if (works++ > 15)
 			break;
 
-		if (!pRD->rd_info->skb)
+		if (!rd->rd_info->skb)
 			break;
 
-		if (vnt_receive_frame(priv, pRD)) {
-			if (!device_alloc_rx_buf(priv, pRD)) {
+		if (vnt_receive_frame(priv, rd)) {
+			if (!device_alloc_rx_buf(priv, rd)) {
 				dev_err(&priv->pcid->dev,
 					"can not allocate rx buf\n");
 				break;
 			}
 		}
-		pRD->rd0.owner = OWNED_BY_NIC;
+		rd->rd0.owner = OWNED_BY_NIC;
 	}
 
-	priv->pCurrRD[uIdx] = pRD;
+	priv->pCurrRD[uIdx] = rd;
 
 	return works;
 }
 
 static bool device_alloc_rx_buf(struct vnt_private *priv,
-				struct vnt_rx_desc *pRD)
+				struct vnt_rx_desc *rd)
 {
-	struct vnt_rd_info *rd_info = pRD->rd_info;
+	struct vnt_rd_info *rd_info = rd->rd_info;
 
 	rd_info->skb = dev_alloc_skb((int)priv->rx_buf_sz);
 	if (rd_info->skb == NULL)
@@ -743,12 +743,12 @@ static bool device_alloc_rx_buf(struct vnt_private *priv,
 			       skb_put(rd_info->skb, skb_tailroom(rd_info->skb)),
 			       priv->rx_buf_sz, DMA_FROM_DEVICE);
 
-	*((unsigned int *)&pRD->rd0) = 0; /* FIX cast */
+	*((unsigned int *)&rd->rd0) = 0; /* FIX cast */
 
-	pRD->rd0.res_count = cpu_to_le16(priv->rx_buf_sz);
-	pRD->rd0.owner = OWNED_BY_NIC;
-	pRD->rd1.req_count = cpu_to_le16(priv->rx_buf_sz);
-	pRD->buff_addr = cpu_to_le32(rd_info->skb_dma);
+	rd->rd0.res_count = cpu_to_le16(priv->rx_buf_sz);
+	rd->rd0.owner = OWNED_BY_NIC;
+	rd->rd1.req_count = cpu_to_le16(priv->rx_buf_sz);
+	rd->buff_addr = cpu_to_le32(rd_info->skb_dma);
 
 	return true;
 }

commit 5e011b433639a5485480a8abc9f5b70a049057cb
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Oct 3 20:30:24 2015 +0100

    staging: vt6655: device_alloc_rx_buf replace pRDInfo with rd_info.
    
    Removing camel case.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 41c08b3ac80f..b33037985ee9 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -732,15 +732,15 @@ static int device_rx_srv(struct vnt_private *priv, unsigned int uIdx)
 static bool device_alloc_rx_buf(struct vnt_private *priv,
 				struct vnt_rx_desc *pRD)
 {
-	struct vnt_rd_info *pRDInfo = pRD->rd_info;
+	struct vnt_rd_info *rd_info = pRD->rd_info;
 
-	pRDInfo->skb = dev_alloc_skb((int)priv->rx_buf_sz);
-	if (pRDInfo->skb == NULL)
+	rd_info->skb = dev_alloc_skb((int)priv->rx_buf_sz);
+	if (rd_info->skb == NULL)
 		return false;
 
-	pRDInfo->skb_dma =
+	rd_info->skb_dma =
 		dma_map_single(&priv->pcid->dev,
-			       skb_put(pRDInfo->skb, skb_tailroom(pRDInfo->skb)),
+			       skb_put(rd_info->skb, skb_tailroom(rd_info->skb)),
 			       priv->rx_buf_sz, DMA_FROM_DEVICE);
 
 	*((unsigned int *)&pRD->rd0) = 0; /* FIX cast */
@@ -748,7 +748,7 @@ static bool device_alloc_rx_buf(struct vnt_private *priv,
 	pRD->rd0.res_count = cpu_to_le16(priv->rx_buf_sz);
 	pRD->rd0.owner = OWNED_BY_NIC;
 	pRD->rd1.req_count = cpu_to_le16(priv->rx_buf_sz);
-	pRD->buff_addr = cpu_to_le32(pRDInfo->skb_dma);
+	pRD->buff_addr = cpu_to_le32(rd_info->skb_dma);
 
 	return true;
 }

commit 5e76c8f4aa4dc952baf62cbaa33785d93cbc10f8
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Oct 3 20:30:23 2015 +0100

    staging: vt6655: device_main.c replace pDesc with desc.
    
    Removing camel case.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 603f18987e45..41c08b3ac80f 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -545,19 +545,19 @@ static void device_init_rd0_ring(struct vnt_private *priv)
 {
 	int i;
 	dma_addr_t      curr = priv->rd0_pool_dma;
-	struct vnt_rx_desc *pDesc;
+	struct vnt_rx_desc *desc;
 
 	/* Init the RD0 ring entries */
 	for (i = 0; i < priv->sOpts.nRxDescs0;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
-		pDesc = &(priv->aRD0Ring[i]);
-		pDesc->rd_info = alloc_rd_info();
+		desc = &priv->aRD0Ring[i];
+		desc->rd_info = alloc_rd_info();
 
-		if (!device_alloc_rx_buf(priv, pDesc))
+		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
 
-		pDesc->next = &(priv->aRD0Ring[(i+1) % priv->sOpts.nRxDescs0]);
-		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
+		desc->next = &(priv->aRD0Ring[(i+1) % priv->sOpts.nRxDescs0]);
+		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 
 	if (i > 0)
@@ -569,19 +569,19 @@ static void device_init_rd1_ring(struct vnt_private *priv)
 {
 	int i;
 	dma_addr_t      curr = priv->rd1_pool_dma;
-	struct vnt_rx_desc *pDesc;
+	struct vnt_rx_desc *desc;
 
 	/* Init the RD1 ring entries */
 	for (i = 0; i < priv->sOpts.nRxDescs1;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
-		pDesc = &(priv->aRD1Ring[i]);
-		pDesc->rd_info = alloc_rd_info();
+		desc = &priv->aRD1Ring[i];
+		desc->rd_info = alloc_rd_info();
 
-		if (!device_alloc_rx_buf(priv, pDesc))
+		if (!device_alloc_rx_buf(priv, desc))
 			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
 
-		pDesc->next = &(priv->aRD1Ring[(i+1) % priv->sOpts.nRxDescs1]);
-		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
+		desc->next = &(priv->aRD1Ring[(i+1) % priv->sOpts.nRxDescs1]);
+		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 
 	if (i > 0)
@@ -594,15 +594,15 @@ static void device_free_rd0_ring(struct vnt_private *priv)
 	int i;
 
 	for (i = 0; i < priv->sOpts.nRxDescs0; i++) {
-		struct vnt_rx_desc *pDesc = &(priv->aRD0Ring[i]);
-		struct vnt_rd_info *rd_info = pDesc->rd_info;
+		struct vnt_rx_desc *desc = &(priv->aRD0Ring[i]);
+		struct vnt_rd_info *rd_info = desc->rd_info;
 
 		dma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,
 				 priv->rx_buf_sz, DMA_FROM_DEVICE);
 
 		dev_kfree_skb(rd_info->skb);
 
-		kfree(pDesc->rd_info);
+		kfree(desc->rd_info);
 	}
 }
 
@@ -611,15 +611,15 @@ static void device_free_rd1_ring(struct vnt_private *priv)
 	int i;
 
 	for (i = 0; i < priv->sOpts.nRxDescs1; i++) {
-		struct vnt_rx_desc *pDesc = &(priv->aRD1Ring[i]);
-		struct vnt_rd_info *rd_info = pDesc->rd_info;
+		struct vnt_rx_desc *desc = &priv->aRD1Ring[i];
+		struct vnt_rd_info *rd_info = desc->rd_info;
 
 		dma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,
 				 priv->rx_buf_sz, DMA_FROM_DEVICE);
 
 		dev_kfree_skb(rd_info->skb);
 
-		kfree(pDesc->rd_info);
+		kfree(desc->rd_info);
 	}
 }
 
@@ -627,19 +627,19 @@ static void device_init_td0_ring(struct vnt_private *priv)
 {
 	int i;
 	dma_addr_t  curr;
-	struct vnt_tx_desc *pDesc;
+	struct vnt_tx_desc *desc;
 
 	curr = priv->td0_pool_dma;
 	for (i = 0; i < priv->sOpts.nTxDescs[0];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
-		pDesc = &(priv->apTD0Rings[i]);
-		pDesc->td_info = alloc_td_info();
+		desc = &priv->apTD0Rings[i];
+		desc->td_info = alloc_td_info();
 
-		pDesc->td_info->buf = priv->tx0_bufs + i * PKT_BUF_SZ;
-		pDesc->td_info->buf_dma = priv->tx_bufs_dma0 + i * PKT_BUF_SZ;
+		desc->td_info->buf = priv->tx0_bufs + i * PKT_BUF_SZ;
+		desc->td_info->buf_dma = priv->tx_bufs_dma0 + i * PKT_BUF_SZ;
 
-		pDesc->next = &(priv->apTD0Rings[(i+1) % priv->sOpts.nTxDescs[0]]);
-		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
+		desc->next = &(priv->apTD0Rings[(i+1) % priv->sOpts.nTxDescs[0]]);
+		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
 
 	if (i > 0)
@@ -651,20 +651,20 @@ static void device_init_td1_ring(struct vnt_private *priv)
 {
 	int i;
 	dma_addr_t  curr;
-	struct vnt_tx_desc *pDesc;
+	struct vnt_tx_desc *desc;
 
 	/* Init the TD ring entries */
 	curr = priv->td1_pool_dma;
 	for (i = 0; i < priv->sOpts.nTxDescs[1];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
-		pDesc = &(priv->apTD1Rings[i]);
-		pDesc->td_info = alloc_td_info();
+		desc = &priv->apTD1Rings[i];
+		desc->td_info = alloc_td_info();
 
-		pDesc->td_info->buf = priv->tx1_bufs + i * PKT_BUF_SZ;
-		pDesc->td_info->buf_dma = priv->tx_bufs_dma1 + i * PKT_BUF_SZ;
+		desc->td_info->buf = priv->tx1_bufs + i * PKT_BUF_SZ;
+		desc->td_info->buf_dma = priv->tx_bufs_dma1 + i * PKT_BUF_SZ;
 
-		pDesc->next = &(priv->apTD1Rings[(i + 1) % priv->sOpts.nTxDescs[1]]);
-		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
+		desc->next = &(priv->apTD1Rings[(i + 1) % priv->sOpts.nTxDescs[1]]);
+		desc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
 
 	if (i > 0)
@@ -677,11 +677,11 @@ static void device_free_td0_ring(struct vnt_private *priv)
 	int i;
 
 	for (i = 0; i < priv->sOpts.nTxDescs[0]; i++) {
-		struct vnt_tx_desc *pDesc = &priv->apTD0Rings[i];
-		struct vnt_td_info *pTDInfo = pDesc->td_info;
+		struct vnt_tx_desc *desc = &priv->apTD0Rings[i];
+		struct vnt_td_info *pTDInfo = desc->td_info;
 
 		dev_kfree_skb(pTDInfo->skb);
-		kfree(pDesc->td_info);
+		kfree(desc->td_info);
 	}
 }
 
@@ -690,11 +690,11 @@ static void device_free_td1_ring(struct vnt_private *priv)
 	int i;
 
 	for (i = 0; i < priv->sOpts.nTxDescs[1]; i++) {
-		struct vnt_tx_desc *pDesc = &priv->apTD1Rings[i];
-		struct vnt_td_info *pTDInfo = pDesc->td_info;
+		struct vnt_tx_desc *desc = &priv->apTD1Rings[i];
+		struct vnt_td_info *pTDInfo = desc->td_info;
 
 		dev_kfree_skb(pTDInfo->skb);
-		kfree(pDesc->td_info);
+		kfree(desc->td_info);
 	}
 }
 
@@ -890,9 +890,9 @@ static void device_error(struct vnt_private *priv, unsigned short status)
 }
 
 static void device_free_tx_buf(struct vnt_private *priv,
-			       struct vnt_tx_desc *pDesc)
+			       struct vnt_tx_desc *desc)
 {
-	struct vnt_td_info *pTDInfo = pDesc->td_info;
+	struct vnt_td_info *pTDInfo = desc->td_info;
 	struct sk_buff *skb = pTDInfo->skb;
 
 	if (skb)

commit 78e0e85376ab41d86f4bb8bc8d498b495c1dde8b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Oct 3 20:30:22 2015 +0100

    staging: vt6655: device_main replace pDevice with priv.
    
    Removing camel case.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 07ebdea7aa34..603f18987e45 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -134,24 +134,24 @@ static const struct pci_device_id vt6655_pci_id_table[] = {
 /*---------------------  Static Functions  --------------------------*/
 
 static int  vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent);
-static void device_free_info(struct vnt_private *pDevice);
-static void device_print_info(struct vnt_private *pDevice);
+static void device_free_info(struct vnt_private *priv);
+static void device_print_info(struct vnt_private *priv);
 
-static void device_init_rd0_ring(struct vnt_private *pDevice);
-static void device_init_rd1_ring(struct vnt_private *pDevice);
-static void device_init_td0_ring(struct vnt_private *pDevice);
-static void device_init_td1_ring(struct vnt_private *pDevice);
+static void device_init_rd0_ring(struct vnt_private *priv);
+static void device_init_rd1_ring(struct vnt_private *priv);
+static void device_init_td0_ring(struct vnt_private *priv);
+static void device_init_td1_ring(struct vnt_private *priv);
 
-static int  device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx);
-static int  device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx);
+static int  device_rx_srv(struct vnt_private *priv, unsigned int uIdx);
+static int  device_tx_srv(struct vnt_private *priv, unsigned int uIdx);
 static bool device_alloc_rx_buf(struct vnt_private *, struct vnt_rx_desc *);
-static void device_init_registers(struct vnt_private *pDevice);
+static void device_init_registers(struct vnt_private *priv);
 static void device_free_tx_buf(struct vnt_private *, struct vnt_tx_desc *);
-static void device_free_td0_ring(struct vnt_private *pDevice);
-static void device_free_td1_ring(struct vnt_private *pDevice);
-static void device_free_rd0_ring(struct vnt_private *pDevice);
-static void device_free_rd1_ring(struct vnt_private *pDevice);
-static void device_free_rings(struct vnt_private *pDevice);
+static void device_free_td0_ring(struct vnt_private *priv);
+static void device_free_td1_ring(struct vnt_private *priv);
+static void device_free_rd0_ring(struct vnt_private *priv);
+static void device_free_rd1_ring(struct vnt_private *priv);
+static void device_free_rings(struct vnt_private *priv);
 
 /*---------------------  Export Variables  --------------------------*/
 
@@ -159,16 +159,16 @@ static void device_free_rings(struct vnt_private *pDevice);
 
 static void vt6655_remove(struct pci_dev *pcid)
 {
-	struct vnt_private *pDevice = pci_get_drvdata(pcid);
+	struct vnt_private *priv = pci_get_drvdata(pcid);
 
-	if (pDevice == NULL)
+	if (priv == NULL)
 		return;
-	device_free_info(pDevice);
+	device_free_info(priv);
 }
 
-static void device_get_options(struct vnt_private *pDevice)
+static void device_get_options(struct vnt_private *priv)
 {
-	POPTIONS pOpts = &(pDevice->sOpts);
+	POPTIONS pOpts = &priv->sOpts;
 
 	pOpts->nRxDescs0 = RX_DESC_DEF0;
 	pOpts->nRxDescs1 = RX_DESC_DEF1;
@@ -182,28 +182,28 @@ static void device_get_options(struct vnt_private *pDevice)
 }
 
 static void
-device_set_options(struct vnt_private *pDevice)
+device_set_options(struct vnt_private *priv)
 {
-	pDevice->byShortRetryLimit = pDevice->sOpts.short_retry;
-	pDevice->byLongRetryLimit = pDevice->sOpts.long_retry;
-	pDevice->byBBType = pDevice->sOpts.bbp_type;
-	pDevice->byPacketType = pDevice->byBBType;
-	pDevice->byAutoFBCtrl = AUTO_FB_0;
-	pDevice->bUpdateBBVGA = true;
-	pDevice->byPreambleType = 0;
-
-	pr_debug(" byShortRetryLimit= %d\n", (int)pDevice->byShortRetryLimit);
-	pr_debug(" byLongRetryLimit= %d\n", (int)pDevice->byLongRetryLimit);
-	pr_debug(" byPreambleType= %d\n", (int)pDevice->byPreambleType);
-	pr_debug(" byShortPreamble= %d\n", (int)pDevice->byShortPreamble);
-	pr_debug(" byBBType= %d\n", (int)pDevice->byBBType);
+	priv->byShortRetryLimit = priv->sOpts.short_retry;
+	priv->byLongRetryLimit = priv->sOpts.long_retry;
+	priv->byBBType = priv->sOpts.bbp_type;
+	priv->byPacketType = priv->byBBType;
+	priv->byAutoFBCtrl = AUTO_FB_0;
+	priv->bUpdateBBVGA = true;
+	priv->byPreambleType = 0;
+
+	pr_debug(" byShortRetryLimit= %d\n", (int)priv->byShortRetryLimit);
+	pr_debug(" byLongRetryLimit= %d\n", (int)priv->byLongRetryLimit);
+	pr_debug(" byPreambleType= %d\n", (int)priv->byPreambleType);
+	pr_debug(" byShortPreamble= %d\n", (int)priv->byShortPreamble);
+	pr_debug(" byBBType= %d\n", (int)priv->byBBType);
 }
 
 /*
  * Initialisation of MAC & BBP registers
  */
 
-static void device_init_registers(struct vnt_private *pDevice)
+static void device_init_registers(struct vnt_private *priv)
 {
 	unsigned long flags;
 	unsigned int ii;
@@ -211,45 +211,45 @@ static void device_init_registers(struct vnt_private *pDevice)
 	unsigned char byCCKPwrdBm = 0;
 	unsigned char byOFDMPwrdBm = 0;
 
-	MACbShutdown(pDevice->PortOffset);
-	BBvSoftwareReset(pDevice);
+	MACbShutdown(priv->PortOffset);
+	BBvSoftwareReset(priv);
 
 	/* Do MACbSoftwareReset in MACvInitialize */
-	MACbSoftwareReset(pDevice->PortOffset);
+	MACbSoftwareReset(priv->PortOffset);
 
-	pDevice->bAES = false;
+	priv->bAES = false;
 
 	/* Only used in 11g type, sync with ERP IE */
-	pDevice->bProtectMode = false;
+	priv->bProtectMode = false;
 
-	pDevice->bNonERPPresent = false;
-	pDevice->bBarkerPreambleMd = false;
-	pDevice->wCurrentRate = RATE_1M;
-	pDevice->byTopOFDMBasicRate = RATE_24M;
-	pDevice->byTopCCKBasicRate = RATE_1M;
+	priv->bNonERPPresent = false;
+	priv->bBarkerPreambleMd = false;
+	priv->wCurrentRate = RATE_1M;
+	priv->byTopOFDMBasicRate = RATE_24M;
+	priv->byTopCCKBasicRate = RATE_1M;
 
 	/* init MAC */
-	MACvInitialize(pDevice->PortOffset);
+	MACvInitialize(priv->PortOffset);
 
 	/* Get Local ID */
-	VNSvInPortB(pDevice->PortOffset + MAC_REG_LOCALID, &pDevice->byLocalID);
+	VNSvInPortB(priv->PortOffset + MAC_REG_LOCALID, &priv->byLocalID);
 
-	spin_lock_irqsave(&pDevice->lock, flags);
+	spin_lock_irqsave(&priv->lock, flags);
 
-	SROMvReadAllContents(pDevice->PortOffset, pDevice->abyEEPROM);
+	SROMvReadAllContents(priv->PortOffset, priv->abyEEPROM);
 
-	spin_unlock_irqrestore(&pDevice->lock, flags);
+	spin_unlock_irqrestore(&priv->lock, flags);
 
 	/* Get Channel range */
-	pDevice->byMinChannel = 1;
-	pDevice->byMaxChannel = CB_MAX_CHANNEL;
+	priv->byMinChannel = 1;
+	priv->byMaxChannel = CB_MAX_CHANNEL;
 
 	/* Get Antena */
-	byValue = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
+	byValue = SROMbyReadEmbedded(priv->PortOffset, EEP_OFS_ANTENNA);
 	if (byValue & EEP_ANTINV)
-		pDevice->bTxRxAntInv = true;
+		priv->bTxRxAntInv = true;
 	else
-		pDevice->bTxRxAntInv = false;
+		priv->bTxRxAntInv = false;
 
 	byValue &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
 	/* if not set default is All */
@@ -257,352 +257,348 @@ static void device_init_registers(struct vnt_private *pDevice)
 		byValue = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
 
 	if (byValue == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {
-		pDevice->byAntennaCount = 2;
-		pDevice->byTxAntennaMode = ANT_B;
-		pDevice->dwTxAntennaSel = 1;
-		pDevice->dwRxAntennaSel = 1;
+		priv->byAntennaCount = 2;
+		priv->byTxAntennaMode = ANT_B;
+		priv->dwTxAntennaSel = 1;
+		priv->dwRxAntennaSel = 1;
 
-		if (pDevice->bTxRxAntInv)
-			pDevice->byRxAntennaMode = ANT_A;
+		if (priv->bTxRxAntInv)
+			priv->byRxAntennaMode = ANT_A;
 		else
-			pDevice->byRxAntennaMode = ANT_B;
+			priv->byRxAntennaMode = ANT_B;
 	} else  {
-		pDevice->byAntennaCount = 1;
-		pDevice->dwTxAntennaSel = 0;
-		pDevice->dwRxAntennaSel = 0;
+		priv->byAntennaCount = 1;
+		priv->dwTxAntennaSel = 0;
+		priv->dwRxAntennaSel = 0;
 
 		if (byValue & EEP_ANTENNA_AUX) {
-			pDevice->byTxAntennaMode = ANT_A;
+			priv->byTxAntennaMode = ANT_A;
 
-			if (pDevice->bTxRxAntInv)
-				pDevice->byRxAntennaMode = ANT_B;
+			if (priv->bTxRxAntInv)
+				priv->byRxAntennaMode = ANT_B;
 			else
-				pDevice->byRxAntennaMode = ANT_A;
+				priv->byRxAntennaMode = ANT_A;
 		} else {
-			pDevice->byTxAntennaMode = ANT_B;
+			priv->byTxAntennaMode = ANT_B;
 
-			if (pDevice->bTxRxAntInv)
-				pDevice->byRxAntennaMode = ANT_A;
+			if (priv->bTxRxAntInv)
+				priv->byRxAntennaMode = ANT_A;
 			else
-				pDevice->byRxAntennaMode = ANT_B;
+				priv->byRxAntennaMode = ANT_B;
 		}
 	}
 
 	/* Set initial antenna mode */
-	BBvSetTxAntennaMode(pDevice, pDevice->byTxAntennaMode);
-	BBvSetRxAntennaMode(pDevice, pDevice->byRxAntennaMode);
+	BBvSetTxAntennaMode(priv, priv->byTxAntennaMode);
+	BBvSetRxAntennaMode(priv, priv->byRxAntennaMode);
 
 	/* zonetype initial */
-	pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
+	priv->byOriginalZonetype = priv->abyEEPROM[EEP_OFS_ZONETYPE];
 
-	if (!pDevice->bZoneRegExist)
-		pDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
+	if (!priv->bZoneRegExist)
+		priv->byZoneType = priv->abyEEPROM[EEP_OFS_ZONETYPE];
 
-	pr_debug("pDevice->byZoneType = %x\n", pDevice->byZoneType);
+	pr_debug("priv->byZoneType = %x\n", priv->byZoneType);
 
 	/* Init RF module */
-	RFbInit(pDevice);
+	RFbInit(priv);
 
 	/* Get Desire Power Value */
-	pDevice->byCurPwr = 0xFF;
-	pDevice->byCCKPwr = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_CCK);
-	pDevice->byOFDMPwrG = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_OFDMG);
+	priv->byCurPwr = 0xFF;
+	priv->byCCKPwr = SROMbyReadEmbedded(priv->PortOffset, EEP_OFS_PWR_CCK);
+	priv->byOFDMPwrG = SROMbyReadEmbedded(priv->PortOffset, EEP_OFS_PWR_OFDMG);
 
 	/* Load power Table */
 	for (ii = 0; ii < CB_MAX_CHANNEL_24G; ii++) {
-		pDevice->abyCCKPwrTbl[ii + 1] =
-			SROMbyReadEmbedded(pDevice->PortOffset,
+		priv->abyCCKPwrTbl[ii + 1] =
+			SROMbyReadEmbedded(priv->PortOffset,
 					   (unsigned char)(ii + EEP_OFS_CCK_PWR_TBL));
-		if (pDevice->abyCCKPwrTbl[ii + 1] == 0)
-			pDevice->abyCCKPwrTbl[ii+1] = pDevice->byCCKPwr;
+		if (priv->abyCCKPwrTbl[ii + 1] == 0)
+			priv->abyCCKPwrTbl[ii+1] = priv->byCCKPwr;
 
-		pDevice->abyOFDMPwrTbl[ii + 1] =
-			SROMbyReadEmbedded(pDevice->PortOffset,
+		priv->abyOFDMPwrTbl[ii + 1] =
+			SROMbyReadEmbedded(priv->PortOffset,
 					   (unsigned char)(ii + EEP_OFS_OFDM_PWR_TBL));
-		if (pDevice->abyOFDMPwrTbl[ii + 1] == 0)
-			pDevice->abyOFDMPwrTbl[ii + 1] = pDevice->byOFDMPwrG;
+		if (priv->abyOFDMPwrTbl[ii + 1] == 0)
+			priv->abyOFDMPwrTbl[ii + 1] = priv->byOFDMPwrG;
 
-		pDevice->abyCCKDefaultPwr[ii + 1] = byCCKPwrdBm;
-		pDevice->abyOFDMDefaultPwr[ii + 1] = byOFDMPwrdBm;
+		priv->abyCCKDefaultPwr[ii + 1] = byCCKPwrdBm;
+		priv->abyOFDMDefaultPwr[ii + 1] = byOFDMPwrdBm;
 	}
 
 	/* recover 12,13 ,14channel for EUROPE by 11 channel */
 	for (ii = 11; ii < 14; ii++) {
-		pDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];
-		pDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];
+		priv->abyCCKPwrTbl[ii] = priv->abyCCKPwrTbl[10];
+		priv->abyOFDMPwrTbl[ii] = priv->abyOFDMPwrTbl[10];
 	}
 
 	/* Load OFDM A Power Table */
 	for (ii = 0; ii < CB_MAX_CHANNEL_5G; ii++) {
-		pDevice->abyOFDMPwrTbl[ii + CB_MAX_CHANNEL_24G + 1] =
-			SROMbyReadEmbedded(pDevice->PortOffset,
+		priv->abyOFDMPwrTbl[ii + CB_MAX_CHANNEL_24G + 1] =
+			SROMbyReadEmbedded(priv->PortOffset,
 					   (unsigned char)(ii + EEP_OFS_OFDMA_PWR_TBL));
 
-		pDevice->abyOFDMDefaultPwr[ii + CB_MAX_CHANNEL_24G + 1] =
-			SROMbyReadEmbedded(pDevice->PortOffset,
+		priv->abyOFDMDefaultPwr[ii + CB_MAX_CHANNEL_24G + 1] =
+			SROMbyReadEmbedded(priv->PortOffset,
 					   (unsigned char)(ii + EEP_OFS_OFDMA_PWR_dBm));
 	}
 
-	if (pDevice->byLocalID > REV_ID_VT3253_B1) {
-		MACvSelectPage1(pDevice->PortOffset);
+	if (priv->byLocalID > REV_ID_VT3253_B1) {
+		MACvSelectPage1(priv->PortOffset);
 
-		VNSvOutPortB(pDevice->PortOffset + MAC_REG_MSRCTL + 1,
+		VNSvOutPortB(priv->PortOffset + MAC_REG_MSRCTL + 1,
 			     (MSRCTL1_TXPWR | MSRCTL1_CSAPAREN));
 
-		MACvSelectPage0(pDevice->PortOffset);
+		MACvSelectPage0(priv->PortOffset);
 	}
 
 	/* use relative tx timeout and 802.11i D4 */
-	MACvWordRegBitsOn(pDevice->PortOffset,
+	MACvWordRegBitsOn(priv->PortOffset,
 			  MAC_REG_CFG, (CFG_TKIPOPT | CFG_NOTXTIMEOUT));
 
 	/* set performance parameter by registry */
-	MACvSetShortRetryLimit(pDevice->PortOffset, pDevice->byShortRetryLimit);
-	MACvSetLongRetryLimit(pDevice->PortOffset, pDevice->byLongRetryLimit);
+	MACvSetShortRetryLimit(priv->PortOffset, priv->byShortRetryLimit);
+	MACvSetLongRetryLimit(priv->PortOffset, priv->byLongRetryLimit);
 
 	/* reset TSF counter */
-	VNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
+	VNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
 	/* enable TSF counter */
-	VNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
+	VNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
 
 	/* initialize BBP registers */
-	BBbVT3253Init(pDevice);
+	BBbVT3253Init(priv);
 
-	if (pDevice->bUpdateBBVGA) {
-		pDevice->byBBVGACurrent = pDevice->abyBBVGA[0];
-		pDevice->byBBVGANew = pDevice->byBBVGACurrent;
-		BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
+	if (priv->bUpdateBBVGA) {
+		priv->byBBVGACurrent = priv->abyBBVGA[0];
+		priv->byBBVGANew = priv->byBBVGACurrent;
+		BBvSetVGAGainOffset(priv, priv->abyBBVGA[0]);
 	}
 
-	BBvSetRxAntennaMode(pDevice, pDevice->byRxAntennaMode);
-	BBvSetTxAntennaMode(pDevice, pDevice->byTxAntennaMode);
+	BBvSetRxAntennaMode(priv, priv->byRxAntennaMode);
+	BBvSetTxAntennaMode(priv, priv->byTxAntennaMode);
 
 	/* Set BB and packet type at the same time. */
 	/* Set Short Slot Time, xIFS, and RSPINF. */
-	pDevice->wCurrentRate = RATE_54M;
+	priv->wCurrentRate = RATE_54M;
 
-	pDevice->bRadioOff = false;
+	priv->bRadioOff = false;
 
-	pDevice->byRadioCtl = SROMbyReadEmbedded(pDevice->PortOffset,
+	priv->byRadioCtl = SROMbyReadEmbedded(priv->PortOffset,
 						 EEP_OFS_RADIOCTL);
-	pDevice->bHWRadioOff = false;
+	priv->bHWRadioOff = false;
 
-	if (pDevice->byRadioCtl & EEP_RADIOCTL_ENABLE) {
+	if (priv->byRadioCtl & EEP_RADIOCTL_ENABLE) {
 		/* Get GPIO */
-		MACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);
+		MACvGPIOIn(priv->PortOffset, &priv->byGPIO);
 
-		if (((pDevice->byGPIO & GPIO0_DATA) &&
-		     !(pDevice->byRadioCtl & EEP_RADIOCTL_INV)) ||
-		     (!(pDevice->byGPIO & GPIO0_DATA) &&
-		     (pDevice->byRadioCtl & EEP_RADIOCTL_INV)))
-			pDevice->bHWRadioOff = true;
+		if (((priv->byGPIO & GPIO0_DATA) &&
+		     !(priv->byRadioCtl & EEP_RADIOCTL_INV)) ||
+		     (!(priv->byGPIO & GPIO0_DATA) &&
+		     (priv->byRadioCtl & EEP_RADIOCTL_INV)))
+			priv->bHWRadioOff = true;
 	}
 
-	if (pDevice->bHWRadioOff || pDevice->bRadioControlOff)
-		CARDbRadioPowerOff(pDevice);
+	if (priv->bHWRadioOff || priv->bRadioControlOff)
+		CARDbRadioPowerOff(priv);
 
 	/* get Permanent network address */
-	SROMvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
-	pr_debug("Network address = %pM\n", pDevice->abyCurrentNetAddr);
+	SROMvReadEtherAddress(priv->PortOffset, priv->abyCurrentNetAddr);
+	pr_debug("Network address = %pM\n", priv->abyCurrentNetAddr);
 
 	/* reset Tx pointer */
-	CARDvSafeResetRx(pDevice);
+	CARDvSafeResetRx(priv);
 	/* reset Rx pointer */
-	CARDvSafeResetTx(pDevice);
+	CARDvSafeResetTx(priv);
 
-	if (pDevice->byLocalID <= REV_ID_VT3253_A1)
-		MACvRegBitsOn(pDevice->PortOffset, MAC_REG_RCR, RCR_WPAERR);
+	if (priv->byLocalID <= REV_ID_VT3253_A1)
+		MACvRegBitsOn(priv->PortOffset, MAC_REG_RCR, RCR_WPAERR);
 
 	/* Turn On Rx DMA */
-	MACvReceive0(pDevice->PortOffset);
-	MACvReceive1(pDevice->PortOffset);
+	MACvReceive0(priv->PortOffset);
+	MACvReceive1(priv->PortOffset);
 
 	/* start the adapter */
-	MACvStart(pDevice->PortOffset);
+	MACvStart(priv->PortOffset);
 }
 
-static void device_print_info(struct vnt_private *pDevice)
+static void device_print_info(struct vnt_private *priv)
 {
-	dev_info(&pDevice->pcid->dev, "MAC=%pM IO=0x%lx Mem=0x%lx IRQ=%d\n",
-		 pDevice->abyCurrentNetAddr, (unsigned long)pDevice->ioaddr,
-		 (unsigned long)pDevice->PortOffset, pDevice->pcid->irq);
+	dev_info(&priv->pcid->dev, "MAC=%pM IO=0x%lx Mem=0x%lx IRQ=%d\n",
+		 priv->abyCurrentNetAddr, (unsigned long)priv->ioaddr,
+		 (unsigned long)priv->PortOffset, priv->pcid->irq);
 }
 
-static void device_free_info(struct vnt_private *pDevice)
+static void device_free_info(struct vnt_private *priv)
 {
-	if (!pDevice)
+	if (!priv)
 		return;
 
-	if (pDevice->mac_hw)
-		ieee80211_unregister_hw(pDevice->hw);
+	if (priv->mac_hw)
+		ieee80211_unregister_hw(priv->hw);
 
-	if (pDevice->PortOffset)
-		iounmap(pDevice->PortOffset);
+	if (priv->PortOffset)
+		iounmap(priv->PortOffset);
 
-	if (pDevice->pcid)
-		pci_release_regions(pDevice->pcid);
+	if (priv->pcid)
+		pci_release_regions(priv->pcid);
 
-	if (pDevice->hw)
-		ieee80211_free_hw(pDevice->hw);
+	if (priv->hw)
+		ieee80211_free_hw(priv->hw);
 }
 
-static bool device_init_rings(struct vnt_private *pDevice)
+static bool device_init_rings(struct vnt_private *priv)
 {
 	void *vir_pool;
 
 	/*allocate all RD/TD rings a single pool*/
-	vir_pool = dma_zalloc_coherent(&pDevice->pcid->dev,
-					 pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc) +
-					 pDevice->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc) +
-					 pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
-					 pDevice->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc),
-					 &pDevice->pool_dma, GFP_ATOMIC);
+	vir_pool = dma_zalloc_coherent(&priv->pcid->dev,
+				       priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc) +
+				       priv->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc) +
+				       priv->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
+				       priv->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc),
+				       &priv->pool_dma, GFP_ATOMIC);
 	if (vir_pool == NULL) {
-		dev_err(&pDevice->pcid->dev, "allocate desc dma memory failed\n");
+		dev_err(&priv->pcid->dev, "allocate desc dma memory failed\n");
 		return false;
 	}
 
-	pDevice->aRD0Ring = vir_pool;
-	pDevice->aRD1Ring = vir_pool +
-		pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc);
-
-	pDevice->rd0_pool_dma = pDevice->pool_dma;
-	pDevice->rd1_pool_dma = pDevice->rd0_pool_dma +
-		pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc);
-
-	pDevice->tx0_bufs = dma_zalloc_coherent(&pDevice->pcid->dev,
-						  pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
-						  pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
-						  CB_BEACON_BUF_SIZE +
-						  CB_MAX_BUF_SIZE,
-						  &pDevice->tx_bufs_dma0,
-						  GFP_ATOMIC);
-	if (pDevice->tx0_bufs == NULL) {
-		dev_err(&pDevice->pcid->dev, "allocate buf dma memory failed\n");
-
-		dma_free_coherent(&pDevice->pcid->dev,
-				    pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc) +
-				    pDevice->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc) +
-				    pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
-				    pDevice->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc),
-				    vir_pool, pDevice->pool_dma
-			);
+	priv->aRD0Ring = vir_pool;
+	priv->aRD1Ring = vir_pool +
+		priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc);
+
+	priv->rd0_pool_dma = priv->pool_dma;
+	priv->rd1_pool_dma = priv->rd0_pool_dma +
+		priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc);
+
+	priv->tx0_bufs = dma_zalloc_coherent(&priv->pcid->dev,
+					     priv->sOpts.nTxDescs[0] * PKT_BUF_SZ +
+					     priv->sOpts.nTxDescs[1] * PKT_BUF_SZ +
+					     CB_BEACON_BUF_SIZE +
+					     CB_MAX_BUF_SIZE,
+					     &priv->tx_bufs_dma0,
+					     GFP_ATOMIC);
+	if (priv->tx0_bufs == NULL) {
+		dev_err(&priv->pcid->dev, "allocate buf dma memory failed\n");
+
+		dma_free_coherent(&priv->pcid->dev,
+				  priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc) +
+				  priv->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc) +
+				  priv->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
+				  priv->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc),
+				  vir_pool, priv->pool_dma);
 		return false;
 	}
 
-	pDevice->td0_pool_dma = pDevice->rd1_pool_dma +
-		pDevice->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc);
+	priv->td0_pool_dma = priv->rd1_pool_dma +
+		priv->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc);
 
-	pDevice->td1_pool_dma = pDevice->td0_pool_dma +
-		pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc);
+	priv->td1_pool_dma = priv->td0_pool_dma +
+		priv->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc);
 
 	/* vir_pool: pvoid type */
-	pDevice->apTD0Rings = vir_pool
-		+ pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc)
-		+ pDevice->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc);
+	priv->apTD0Rings = vir_pool
+		+ priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc)
+		+ priv->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc);
 
-	pDevice->apTD1Rings = vir_pool
-		+ pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc)
-		+ pDevice->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc)
-		+ pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc);
+	priv->apTD1Rings = vir_pool
+		+ priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc)
+		+ priv->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc)
+		+ priv->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc);
 
-	pDevice->tx1_bufs = pDevice->tx0_bufs +
-		pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;
+	priv->tx1_bufs = priv->tx0_bufs +
+		priv->sOpts.nTxDescs[0] * PKT_BUF_SZ;
 
-	pDevice->tx_beacon_bufs = pDevice->tx1_bufs +
-		pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;
+	priv->tx_beacon_bufs = priv->tx1_bufs +
+		priv->sOpts.nTxDescs[1] * PKT_BUF_SZ;
 
-	pDevice->pbyTmpBuff = pDevice->tx_beacon_bufs +
+	priv->pbyTmpBuff = priv->tx_beacon_bufs +
 		CB_BEACON_BUF_SIZE;
 
-	pDevice->tx_bufs_dma1 = pDevice->tx_bufs_dma0 +
-		pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;
+	priv->tx_bufs_dma1 = priv->tx_bufs_dma0 +
+		priv->sOpts.nTxDescs[0] * PKT_BUF_SZ;
 
-	pDevice->tx_beacon_dma = pDevice->tx_bufs_dma1 +
-		pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;
+	priv->tx_beacon_dma = priv->tx_bufs_dma1 +
+		priv->sOpts.nTxDescs[1] * PKT_BUF_SZ;
 
 	return true;
 }
 
-static void device_free_rings(struct vnt_private *pDevice)
+static void device_free_rings(struct vnt_private *priv)
 {
-	dma_free_coherent(&pDevice->pcid->dev,
-			    pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc) +
-			    pDevice->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc) +
-			    pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
-			    pDevice->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc)
-			    ,
-			    pDevice->aRD0Ring, pDevice->pool_dma
-		);
-
-	if (pDevice->tx0_bufs)
-		dma_free_coherent(&pDevice->pcid->dev,
-				    pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
-				    pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
-				    CB_BEACON_BUF_SIZE +
-				    CB_MAX_BUF_SIZE,
-				    pDevice->tx0_bufs, pDevice->tx_bufs_dma0
-			);
+	dma_free_coherent(&priv->pcid->dev,
+			  priv->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc) +
+			  priv->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc) +
+			  priv->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
+			  priv->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc),
+			  priv->aRD0Ring, priv->pool_dma);
+
+	if (priv->tx0_bufs)
+		dma_free_coherent(&priv->pcid->dev,
+				  priv->sOpts.nTxDescs[0] * PKT_BUF_SZ +
+				  priv->sOpts.nTxDescs[1] * PKT_BUF_SZ +
+				  CB_BEACON_BUF_SIZE +
+				  CB_MAX_BUF_SIZE,
+				  priv->tx0_bufs, priv->tx_bufs_dma0);
 }
 
-static void device_init_rd0_ring(struct vnt_private *pDevice)
+static void device_init_rd0_ring(struct vnt_private *priv)
 {
 	int i;
-	dma_addr_t      curr = pDevice->rd0_pool_dma;
+	dma_addr_t      curr = priv->rd0_pool_dma;
 	struct vnt_rx_desc *pDesc;
 
 	/* Init the RD0 ring entries */
-	for (i = 0; i < pDevice->sOpts.nRxDescs0;
+	for (i = 0; i < priv->sOpts.nRxDescs0;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
-		pDesc = &(pDevice->aRD0Ring[i]);
+		pDesc = &(priv->aRD0Ring[i]);
 		pDesc->rd_info = alloc_rd_info();
 
-		if (!device_alloc_rx_buf(pDevice, pDesc))
-			dev_err(&pDevice->pcid->dev, "can not alloc rx bufs\n");
+		if (!device_alloc_rx_buf(priv, pDesc))
+			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
 
-		pDesc->next = &(pDevice->aRD0Ring[(i+1) % pDevice->sOpts.nRxDescs0]);
+		pDesc->next = &(priv->aRD0Ring[(i+1) % priv->sOpts.nRxDescs0]);
 		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 
 	if (i > 0)
-		pDevice->aRD0Ring[i-1].next_desc = cpu_to_le32(pDevice->rd0_pool_dma);
-	pDevice->pCurrRD[0] = &(pDevice->aRD0Ring[0]);
+		priv->aRD0Ring[i-1].next_desc = cpu_to_le32(priv->rd0_pool_dma);
+	priv->pCurrRD[0] = &priv->aRD0Ring[0];
 }
 
-static void device_init_rd1_ring(struct vnt_private *pDevice)
+static void device_init_rd1_ring(struct vnt_private *priv)
 {
 	int i;
-	dma_addr_t      curr = pDevice->rd1_pool_dma;
+	dma_addr_t      curr = priv->rd1_pool_dma;
 	struct vnt_rx_desc *pDesc;
 
 	/* Init the RD1 ring entries */
-	for (i = 0; i < pDevice->sOpts.nRxDescs1;
+	for (i = 0; i < priv->sOpts.nRxDescs1;
 	     i ++, curr += sizeof(struct vnt_rx_desc)) {
-		pDesc = &(pDevice->aRD1Ring[i]);
+		pDesc = &(priv->aRD1Ring[i]);
 		pDesc->rd_info = alloc_rd_info();
 
-		if (!device_alloc_rx_buf(pDevice, pDesc))
-			dev_err(&pDevice->pcid->dev, "can not alloc rx bufs\n");
+		if (!device_alloc_rx_buf(priv, pDesc))
+			dev_err(&priv->pcid->dev, "can not alloc rx bufs\n");
 
-		pDesc->next = &(pDevice->aRD1Ring[(i+1) % pDevice->sOpts.nRxDescs1]);
+		pDesc->next = &(priv->aRD1Ring[(i+1) % priv->sOpts.nRxDescs1]);
 		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 
 	if (i > 0)
-		pDevice->aRD1Ring[i-1].next_desc = cpu_to_le32(pDevice->rd1_pool_dma);
-	pDevice->pCurrRD[1] = &(pDevice->aRD1Ring[0]);
+		priv->aRD1Ring[i-1].next_desc = cpu_to_le32(priv->rd1_pool_dma);
+	priv->pCurrRD[1] = &priv->aRD1Ring[0];
 }
 
-static void device_free_rd0_ring(struct vnt_private *pDevice)
+static void device_free_rd0_ring(struct vnt_private *priv)
 {
 	int i;
 
-	for (i = 0; i < pDevice->sOpts.nRxDescs0; i++) {
-		struct vnt_rx_desc *pDesc = &(pDevice->aRD0Ring[i]);
+	for (i = 0; i < priv->sOpts.nRxDescs0; i++) {
+		struct vnt_rx_desc *pDesc = &(priv->aRD0Ring[i]);
 		struct vnt_rd_info *rd_info = pDesc->rd_info;
 
-		dma_unmap_single(&pDevice->pcid->dev, rd_info->skb_dma,
-				 pDevice->rx_buf_sz, DMA_FROM_DEVICE);
+		dma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,
+				 priv->rx_buf_sz, DMA_FROM_DEVICE);
 
 		dev_kfree_skb(rd_info->skb);
 
@@ -610,16 +606,16 @@ static void device_free_rd0_ring(struct vnt_private *pDevice)
 	}
 }
 
-static void device_free_rd1_ring(struct vnt_private *pDevice)
+static void device_free_rd1_ring(struct vnt_private *priv)
 {
 	int i;
 
-	for (i = 0; i < pDevice->sOpts.nRxDescs1; i++) {
-		struct vnt_rx_desc *pDesc = &(pDevice->aRD1Ring[i]);
+	for (i = 0; i < priv->sOpts.nRxDescs1; i++) {
+		struct vnt_rx_desc *pDesc = &(priv->aRD1Ring[i]);
 		struct vnt_rd_info *rd_info = pDesc->rd_info;
 
-		dma_unmap_single(&pDevice->pcid->dev, rd_info->skb_dma,
-				 pDevice->rx_buf_sz, DMA_FROM_DEVICE);
+		dma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,
+				 priv->rx_buf_sz, DMA_FROM_DEVICE);
 
 		dev_kfree_skb(rd_info->skb);
 
@@ -627,61 +623,61 @@ static void device_free_rd1_ring(struct vnt_private *pDevice)
 	}
 }
 
-static void device_init_td0_ring(struct vnt_private *pDevice)
+static void device_init_td0_ring(struct vnt_private *priv)
 {
 	int i;
 	dma_addr_t  curr;
 	struct vnt_tx_desc *pDesc;
 
-	curr = pDevice->td0_pool_dma;
-	for (i = 0; i < pDevice->sOpts.nTxDescs[0];
+	curr = priv->td0_pool_dma;
+	for (i = 0; i < priv->sOpts.nTxDescs[0];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
-		pDesc = &(pDevice->apTD0Rings[i]);
+		pDesc = &(priv->apTD0Rings[i]);
 		pDesc->td_info = alloc_td_info();
 
-		pDesc->td_info->buf = pDevice->tx0_bufs + i * PKT_BUF_SZ;
-		pDesc->td_info->buf_dma = pDevice->tx_bufs_dma0 + i * PKT_BUF_SZ;
+		pDesc->td_info->buf = priv->tx0_bufs + i * PKT_BUF_SZ;
+		pDesc->td_info->buf_dma = priv->tx_bufs_dma0 + i * PKT_BUF_SZ;
 
-		pDesc->next = &(pDevice->apTD0Rings[(i+1) % pDevice->sOpts.nTxDescs[0]]);
+		pDesc->next = &(priv->apTD0Rings[(i+1) % priv->sOpts.nTxDescs[0]]);
 		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
 
 	if (i > 0)
-		pDevice->apTD0Rings[i-1].next_desc = cpu_to_le32(pDevice->td0_pool_dma);
-	pDevice->apTailTD[0] = pDevice->apCurrTD[0] = &(pDevice->apTD0Rings[0]);
+		priv->apTD0Rings[i-1].next_desc = cpu_to_le32(priv->td0_pool_dma);
+	priv->apTailTD[0] = priv->apCurrTD[0] = &priv->apTD0Rings[0];
 }
 
-static void device_init_td1_ring(struct vnt_private *pDevice)
+static void device_init_td1_ring(struct vnt_private *priv)
 {
 	int i;
 	dma_addr_t  curr;
 	struct vnt_tx_desc *pDesc;
 
 	/* Init the TD ring entries */
-	curr = pDevice->td1_pool_dma;
-	for (i = 0; i < pDevice->sOpts.nTxDescs[1];
+	curr = priv->td1_pool_dma;
+	for (i = 0; i < priv->sOpts.nTxDescs[1];
 	     i++, curr += sizeof(struct vnt_tx_desc)) {
-		pDesc = &(pDevice->apTD1Rings[i]);
+		pDesc = &(priv->apTD1Rings[i]);
 		pDesc->td_info = alloc_td_info();
 
-		pDesc->td_info->buf = pDevice->tx1_bufs + i * PKT_BUF_SZ;
-		pDesc->td_info->buf_dma = pDevice->tx_bufs_dma1 + i * PKT_BUF_SZ;
+		pDesc->td_info->buf = priv->tx1_bufs + i * PKT_BUF_SZ;
+		pDesc->td_info->buf_dma = priv->tx_bufs_dma1 + i * PKT_BUF_SZ;
 
-		pDesc->next = &(pDevice->apTD1Rings[(i + 1) % pDevice->sOpts.nTxDescs[1]]);
+		pDesc->next = &(priv->apTD1Rings[(i + 1) % priv->sOpts.nTxDescs[1]]);
 		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
 
 	if (i > 0)
-		pDevice->apTD1Rings[i-1].next_desc = cpu_to_le32(pDevice->td1_pool_dma);
-	pDevice->apTailTD[1] = pDevice->apCurrTD[1] = &(pDevice->apTD1Rings[0]);
+		priv->apTD1Rings[i-1].next_desc = cpu_to_le32(priv->td1_pool_dma);
+	priv->apTailTD[1] = priv->apCurrTD[1] = &priv->apTD1Rings[0];
 }
 
-static void device_free_td0_ring(struct vnt_private *pDevice)
+static void device_free_td0_ring(struct vnt_private *priv)
 {
 	int i;
 
-	for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++) {
-		struct vnt_tx_desc *pDesc = &pDevice->apTD0Rings[i];
+	for (i = 0; i < priv->sOpts.nTxDescs[0]; i++) {
+		struct vnt_tx_desc *pDesc = &priv->apTD0Rings[i];
 		struct vnt_td_info *pTDInfo = pDesc->td_info;
 
 		dev_kfree_skb(pTDInfo->skb);
@@ -689,12 +685,12 @@ static void device_free_td0_ring(struct vnt_private *pDevice)
 	}
 }
 
-static void device_free_td1_ring(struct vnt_private *pDevice)
+static void device_free_td1_ring(struct vnt_private *priv)
 {
 	int i;
 
-	for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++) {
-		struct vnt_tx_desc *pDesc = &pDevice->apTD1Rings[i];
+	for (i = 0; i < priv->sOpts.nTxDescs[1]; i++) {
+		struct vnt_tx_desc *pDesc = &priv->apTD1Rings[i];
 		struct vnt_td_info *pTDInfo = pDesc->td_info;
 
 		dev_kfree_skb(pTDInfo->skb);
@@ -704,12 +700,12 @@ static void device_free_td1_ring(struct vnt_private *pDevice)
 
 /*-----------------------------------------------------------------*/
 
-static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
+static int device_rx_srv(struct vnt_private *priv, unsigned int uIdx)
 {
 	struct vnt_rx_desc *pRD;
 	int works = 0;
 
-	for (pRD = pDevice->pCurrRD[uIdx];
+	for (pRD = priv->pCurrRD[uIdx];
 	     pRD->rd0.owner == OWNED_BY_HOST;
 	     pRD = pRD->next) {
 		if (works++ > 15)
@@ -718,9 +714,9 @@ static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 		if (!pRD->rd_info->skb)
 			break;
 
-		if (vnt_receive_frame(pDevice, pRD)) {
-			if (!device_alloc_rx_buf(pDevice, pRD)) {
-				dev_err(&pDevice->pcid->dev,
+		if (vnt_receive_frame(priv, pRD)) {
+			if (!device_alloc_rx_buf(priv, pRD)) {
+				dev_err(&priv->pcid->dev,
 					"can not allocate rx buf\n");
 				break;
 			}
@@ -728,30 +724,30 @@ static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 		pRD->rd0.owner = OWNED_BY_NIC;
 	}
 
-	pDevice->pCurrRD[uIdx] = pRD;
+	priv->pCurrRD[uIdx] = pRD;
 
 	return works;
 }
 
-static bool device_alloc_rx_buf(struct vnt_private *pDevice,
+static bool device_alloc_rx_buf(struct vnt_private *priv,
 				struct vnt_rx_desc *pRD)
 {
 	struct vnt_rd_info *pRDInfo = pRD->rd_info;
 
-	pRDInfo->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
+	pRDInfo->skb = dev_alloc_skb((int)priv->rx_buf_sz);
 	if (pRDInfo->skb == NULL)
 		return false;
 
 	pRDInfo->skb_dma =
-		dma_map_single(&pDevice->pcid->dev,
+		dma_map_single(&priv->pcid->dev,
 			       skb_put(pRDInfo->skb, skb_tailroom(pRDInfo->skb)),
-			       pDevice->rx_buf_sz, DMA_FROM_DEVICE);
+			       priv->rx_buf_sz, DMA_FROM_DEVICE);
 
 	*((unsigned int *)&pRD->rd0) = 0; /* FIX cast */
 
-	pRD->rd0.res_count = cpu_to_le16(pDevice->rx_buf_sz);
+	pRD->rd0.res_count = cpu_to_le16(priv->rx_buf_sz);
 	pRD->rd0.owner = OWNED_BY_NIC;
-	pRD->rd1.req_count = cpu_to_le16(pDevice->rx_buf_sz);
+	pRD->rd1.req_count = cpu_to_le16(priv->rx_buf_sz);
 	pRD->buff_addr = cpu_to_le32(pRDInfo->skb_dma);
 
 	return true;
@@ -833,14 +829,14 @@ static int vnt_int_report_rate(struct vnt_private *priv,
 	return 0;
 }
 
-static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
+static int device_tx_srv(struct vnt_private *priv, unsigned int uIdx)
 {
 	struct vnt_tx_desc *pTD;
 	int                      works = 0;
 	unsigned char byTsr0;
 	unsigned char byTsr1;
 
-	for (pTD = pDevice->apTailTD[uIdx]; pDevice->iTDUsed[uIdx] > 0; pTD = pTD->next) {
+	for (pTD = priv->apTailTD[uIdx]; priv->iTDUsed[uIdx] > 0; pTD = pTD->next) {
 		if (pTD->td0.owner == OWNED_BY_NIC)
 			break;
 		if (works++ > 15)
@@ -871,36 +867,36 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 				}
 			}
 
-			vnt_int_report_rate(pDevice, pTD->td_info, byTsr0, byTsr1);
+			vnt_int_report_rate(priv, pTD->td_info, byTsr0, byTsr1);
 
-			device_free_tx_buf(pDevice, pTD);
-			pDevice->iTDUsed[uIdx]--;
+			device_free_tx_buf(priv, pTD);
+			priv->iTDUsed[uIdx]--;
 		}
 	}
 
-	pDevice->apTailTD[uIdx] = pTD;
+	priv->apTailTD[uIdx] = pTD;
 
 	return works;
 }
 
-static void device_error(struct vnt_private *pDevice, unsigned short status)
+static void device_error(struct vnt_private *priv, unsigned short status)
 {
 	if (status & ISR_FETALERR) {
-		dev_err(&pDevice->pcid->dev, "Hardware fatal error\n");
+		dev_err(&priv->pcid->dev, "Hardware fatal error\n");
 
-		MACbShutdown(pDevice->PortOffset);
+		MACbShutdown(priv->PortOffset);
 		return;
 	}
 }
 
-static void device_free_tx_buf(struct vnt_private *pDevice,
+static void device_free_tx_buf(struct vnt_private *priv,
 			       struct vnt_tx_desc *pDesc)
 {
 	struct vnt_td_info *pTDInfo = pDesc->td_info;
 	struct sk_buff *skb = pTDInfo->skb;
 
 	if (skb)
-		ieee80211_tx_status_irqsafe(pDevice->hw, skb);
+		ieee80211_tx_status_irqsafe(priv->hw, skb);
 
 	pTDInfo->skb = NULL;
 	pTDInfo->flags = 0;

commit 113d6dc18e5e9334493a0f500c01a9e97796cd9b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Sep 27 09:17:39 2015 +0100

    staging: vt6655: don't stop TX queue unless buffer full.
    
    Presently the TX buffer stops while filling the buffer.
    
    However, this does not make use of the available buffer
    space, it also lags the speed of the TX troughtput.
    
    Only stop the queue when the buffer becomes full. The
    Interupt handler will start the queue again when a
    buffer is available.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 326bce31c9ca..07ebdea7aa34 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1105,6 +1105,7 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	if (AVAIL_TD(priv, dma_idx) < 1) {
 		spin_unlock_irqrestore(&priv->lock, flags);
+		ieee80211_stop_queues(priv->hw);
 		return -ENOMEM;
 	}
 
@@ -1156,13 +1157,8 @@ static void vnt_tx_80211(struct ieee80211_hw *hw,
 {
 	struct vnt_private *priv = hw->priv;
 
-	ieee80211_stop_queues(hw);
-
-	if (vnt_tx_packet(priv, skb)) {
+	if (vnt_tx_packet(priv, skb))
 		ieee80211_free_txskb(hw, skb);
-
-		ieee80211_wake_queues(hw);
-	}
 }
 
 static int vnt_start(struct ieee80211_hw *hw)

commit a03b8b3e18969e10d5fdc732a06b5c58c247e842
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Sep 12 19:10:38 2015 +0100

    staging: vt6655: Move code in device_get_pci_info
    
    Function always returns true and now only a few lines move
    to vt6655_probe.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index add9cdf01255..326bce31c9ca 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -29,7 +29,6 @@
  *   vt6655_probe - module initial (insmod) driver entry
  *   vt6655_remove - module remove entry
  *   device_free_info - device structure resource free function
- *   device_get_pci_info - get allocated pci io/mem resource
  *   device_print_info - print out resource
  *   device_rx_srv - rx service function
  *   device_alloc_rx_buf - rx buffer pre-allocated function
@@ -136,7 +135,6 @@ static const struct pci_device_id vt6655_pci_id_table[] = {
 
 static int  vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent);
 static void device_free_info(struct vnt_private *pDevice);
-static bool device_get_pci_info(struct vnt_private *, struct pci_dev *pcid);
 static void device_print_info(struct vnt_private *pDevice);
 
 static void device_init_rd0_ring(struct vnt_private *pDevice);
@@ -430,17 +428,6 @@ static void device_print_info(struct vnt_private *pDevice)
 		 (unsigned long)pDevice->PortOffset, pDevice->pcid->irq);
 }
 
-static bool device_get_pci_info(struct vnt_private *pDevice,
-				struct pci_dev *pcid)
-{
-	pci_set_master(pcid);
-
-	pDevice->memaddr = pci_resource_start(pcid, 0);
-	pDevice->ioaddr = pci_resource_start(pcid, 1);
-
-	return true;
-}
-
 static void device_free_info(struct vnt_private *pDevice)
 {
 	if (!pDevice)
@@ -1629,12 +1616,10 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	dev_dbg(&pcid->dev,
 		"Before get pci_info memaddr is %x\n", priv->memaddr);
 
-	if (!device_get_pci_info(priv, pcid)) {
-		dev_err(&pcid->dev, ": Failed to find PCI device.\n");
-		device_free_info(priv);
-		return -ENODEV;
-	}
+	pci_set_master(pcid);
 
+	priv->memaddr = pci_resource_start(pcid, 0);
+	priv->ioaddr = pci_resource_start(pcid, 1);
 	priv->PortOffset = ioremap(priv->memaddr & PCI_BASE_ADDRESS_MEM_MASK,
 				   256);
 	if (!priv->PortOffset) {

commit 70d66a6a753b19a3de5ab167fe8b941eac32c079
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Sep 12 19:10:37 2015 +0100

    staging: vt6655: device_get_pci_info pcid already assigned.
    
    pcid has already been assigned earlier in vt6655_probe.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index edda8360e8ba..add9cdf01255 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -438,8 +438,6 @@ static bool device_get_pci_info(struct vnt_private *pDevice,
 	pDevice->memaddr = pci_resource_start(pcid, 0);
 	pDevice->ioaddr = pci_resource_start(pcid, 1);
 
-	pDevice->pcid = pcid;
-
 	return true;
 }
 

commit 41652a21b7c11322f4efa6daa43deb7935a052f9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Sep 12 19:10:36 2015 +0100

    staging: vt6655: device_get_pci_info remove call to set master.
    
    a call to PCI_COMMAND is used to set master.
    
    However, a call to pci_set_master earlier in function which
    does the same thing.
    
    So remove the calls and variable b.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 17fa6aa30eae..edda8360e8ba 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -433,8 +433,6 @@ static void device_print_info(struct vnt_private *pDevice)
 static bool device_get_pci_info(struct vnt_private *pDevice,
 				struct pci_dev *pcid)
 {
-	u8  b;
-
 	pci_set_master(pcid);
 
 	pDevice->memaddr = pci_resource_start(pcid, 0);
@@ -442,9 +440,6 @@ static bool device_get_pci_info(struct vnt_private *pDevice,
 
 	pDevice->pcid = pcid;
 
-	pci_read_config_byte(pcid, PCI_COMMAND, &b);
-	pci_write_config_byte(pcid, PCI_COMMAND, (b|PCI_COMMAND_MASTER));
-
 	return true;
 }
 

commit 2ef1571b13859ce56bf779ddaf3b7be44eacc5d7
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Sep 12 19:10:35 2015 +0100

    staging: vt6655: device_get_pci_info remove variable cis_addr.
    
    cis_addr is never used remove its call to pci_resource_start.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1e660ccf200f..17fa6aa30eae 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -434,15 +434,12 @@ static bool device_get_pci_info(struct vnt_private *pDevice,
 				struct pci_dev *pcid)
 {
 	u8  b;
-	unsigned int cis_addr;
 
 	pci_set_master(pcid);
 
 	pDevice->memaddr = pci_resource_start(pcid, 0);
 	pDevice->ioaddr = pci_resource_start(pcid, 1);
 
-	cis_addr = pci_resource_start(pcid, 2);
-
 	pDevice->pcid = pcid;
 
 	pci_read_config_byte(pcid, PCI_COMMAND, &b);

commit 7a95f96108efc94cd79d46245a70c3b5bf9c0840
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Sep 12 19:10:34 2015 +0100

    staging: vt6655: device_get_pci_info remove unused pci_read_config_*
    
    These values are read from pci but never used.
    
    Removing variables byRevId, SubSystemID, SubVendorID and pci_cmd.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ce2df3747faa..1e660ccf200f 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -230,9 +230,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 	pDevice->byTopOFDMBasicRate = RATE_24M;
 	pDevice->byTopCCKBasicRate = RATE_1M;
 
-	/* Target to IF pin while programming to RF chip. */
-	pDevice->byRevId = 0;
-
 	/* init MAC */
 	MACvInitialize(pDevice->PortOffset);
 
@@ -436,15 +433,9 @@ static void device_print_info(struct vnt_private *pDevice)
 static bool device_get_pci_info(struct vnt_private *pDevice,
 				struct pci_dev *pcid)
 {
-	u16 pci_cmd;
 	u8  b;
 	unsigned int cis_addr;
 
-	pci_read_config_byte(pcid, PCI_REVISION_ID, &pDevice->byRevId);
-	pci_read_config_word(pcid, PCI_SUBSYSTEM_ID, &pDevice->SubSystemID);
-	pci_read_config_word(pcid, PCI_SUBSYSTEM_VENDOR_ID, &pDevice->SubVendorID);
-	pci_read_config_word(pcid, PCI_COMMAND, (u16 *)&(pci_cmd));
-
 	pci_set_master(pcid);
 
 	pDevice->memaddr = pci_resource_start(pcid, 0);

commit f31798266f23edf85d32b38f7b2a755684d399ef
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Sep 12 19:10:33 2015 +0100

    staging: vt6655: remove and move vt6655_init_info
    
    move code to vt6655_probe.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 03cc52e3c0d3..ce2df3747faa 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -28,7 +28,6 @@
  *
  *   vt6655_probe - module initial (insmod) driver entry
  *   vt6655_remove - module remove entry
- *   vt6655_init_info - device structure resource allocation function
  *   device_free_info - device structure resource free function
  *   device_get_pci_info - get allocated pci io/mem resource
  *   device_print_info - print out resource
@@ -136,8 +135,6 @@ static const struct pci_device_id vt6655_pci_id_table[] = {
 /*---------------------  Static Functions  --------------------------*/
 
 static int  vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent);
-static void vt6655_init_info(struct pci_dev *pcid,
-			     struct vnt_private **ppDevice);
 static void device_free_info(struct vnt_private *pDevice);
 static bool device_get_pci_info(struct vnt_private *, struct pci_dev *pcid);
 static void device_print_info(struct vnt_private *pDevice);
@@ -436,14 +433,6 @@ static void device_print_info(struct vnt_private *pDevice)
 		 (unsigned long)pDevice->PortOffset, pDevice->pcid->irq);
 }
 
-static void vt6655_init_info(struct pci_dev *pcid,
-			     struct vnt_private **ppDevice)
-{
-	(*ppDevice)->pcid = pcid;
-
-	spin_lock_init(&((*ppDevice)->lock));
-}
-
 static bool device_get_pci_info(struct vnt_private *pDevice,
 				struct pci_dev *pcid)
 {
@@ -1643,8 +1632,9 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	}
 
 	priv = hw->priv;
+	priv->pcid = pcid;
 
-	vt6655_init_info(pcid, &priv);
+	spin_lock_init(&priv->lock);
 
 	priv->hw = hw;
 

commit e577474f3b55ef368090ec7f29543fb8b5a712be
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Sep 12 19:10:32 2015 +0100

    staging: vt6655: vt6655_init_info remove memset.
    
    vnt_private is allocated with kzalloc so is already zero.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index fcc4510f81b3..03cc52e3c0d3 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -439,8 +439,6 @@ static void device_print_info(struct vnt_private *pDevice)
 static void vt6655_init_info(struct pci_dev *pcid,
 			     struct vnt_private **ppDevice)
 {
-	memset(*ppDevice, 0, sizeof(**ppDevice));
-
 	(*ppDevice)->pcid = pcid;
 
 	spin_lock_init(&((*ppDevice)->lock));

commit 73eb8a11275ecadf7f49ffc1e67f7cef35188182
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Sep 12 19:10:31 2015 +0100

    staging: vt6655: remove unused multicast_limit.
    
    multicast_limit is assigned a vale that is never used.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4bc9ba0b4b71..fcc4510f81b3 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -442,7 +442,6 @@ static void vt6655_init_info(struct pci_dev *pcid,
 	memset(*ppDevice, 0, sizeof(**ppDevice));
 
 	(*ppDevice)->pcid = pcid;
-	(*ppDevice)->multicast_limit = 32;
 
 	spin_lock_init(&((*ppDevice)->lock));
 }

commit 319755a72226e8c433077b7839aa6064080917fc
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Sep 12 19:10:30 2015 +0100

    staging: vt6655: Remove typedef struct __chip_info_tbl
    
    Only two values that are assigned from this table.
    
    DEVICE_FLAGS_TX_ALIGN and the value of io_size which is used
    as the size of ioremap which is 256.
    
    Remove all variables, DEVICE_FLAGS_TX_ALIGN check, apply io_size value
    and chip_info_table.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 99191d979dc5..4bc9ba0b4b71 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -128,14 +128,8 @@ DEVICE_PARAM(BasebandType, "baseband type");
 /*
  * Static vars definitions
  */
-static CHIP_INFO chip_info_table[] = {
-	{ VT3253,       "VIA Networking Solomon-A/B/G Wireless LAN Adapter ",
-	  256, 1,     DEVICE_FLAGS_IP_ALIGN|DEVICE_FLAGS_TX_ALIGN },
-	{0, NULL}
-};
-
 static const struct pci_device_id vt6655_pci_id_table[] = {
-	{ PCI_VDEVICE(VIA, 0x3253), (kernel_ulong_t)chip_info_table},
+	{ PCI_VDEVICE(VIA, 0x3253) },
 	{ 0, }
 };
 
@@ -143,7 +137,7 @@ static const struct pci_device_id vt6655_pci_id_table[] = {
 
 static int  vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent);
 static void vt6655_init_info(struct pci_dev *pcid,
-			     struct vnt_private **ppDevice, PCHIP_INFO);
+			     struct vnt_private **ppDevice);
 static void device_free_info(struct vnt_private *pDevice);
 static bool device_get_pci_info(struct vnt_private *, struct pci_dev *pcid);
 static void device_print_info(struct vnt_private *pDevice);
@@ -443,15 +437,11 @@ static void device_print_info(struct vnt_private *pDevice)
 }
 
 static void vt6655_init_info(struct pci_dev *pcid,
-			     struct vnt_private **ppDevice,
-			     PCHIP_INFO pChip_info)
+			     struct vnt_private **ppDevice)
 {
 	memset(*ppDevice, 0, sizeof(**ppDevice));
 
 	(*ppDevice)->pcid = pcid;
-	(*ppDevice)->chip_id = pChip_info->chip_id;
-	(*ppDevice)->io_size = pChip_info->io_size;
-	(*ppDevice)->nTxQueues = pChip_info->nTxQueue;
 	(*ppDevice)->multicast_limit = 32;
 
 	spin_lock_init(&((*ppDevice)->lock));
@@ -695,10 +685,9 @@ static void device_init_td0_ring(struct vnt_private *pDevice)
 		pDesc = &(pDevice->apTD0Rings[i]);
 		pDesc->td_info = alloc_td_info();
 
-		if (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {
-			pDesc->td_info->buf = pDevice->tx0_bufs + (i)*PKT_BUF_SZ;
-			pDesc->td_info->buf_dma = pDevice->tx_bufs_dma0 + (i)*PKT_BUF_SZ;
-		}
+		pDesc->td_info->buf = pDevice->tx0_bufs + i * PKT_BUF_SZ;
+		pDesc->td_info->buf_dma = pDevice->tx_bufs_dma0 + i * PKT_BUF_SZ;
+
 		pDesc->next = &(pDevice->apTD0Rings[(i+1) % pDevice->sOpts.nTxDescs[0]]);
 		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
@@ -721,10 +710,9 @@ static void device_init_td1_ring(struct vnt_private *pDevice)
 		pDesc = &(pDevice->apTD1Rings[i]);
 		pDesc->td_info = alloc_td_info();
 
-		if (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {
-			pDesc->td_info->buf = pDevice->tx1_bufs + (i) * PKT_BUF_SZ;
-			pDesc->td_info->buf_dma = pDevice->tx_bufs_dma1 + (i) * PKT_BUF_SZ;
-		}
+		pDesc->td_info->buf = pDevice->tx1_bufs + i * PKT_BUF_SZ;
+		pDesc->td_info->buf_dma = pDevice->tx_bufs_dma1 + i * PKT_BUF_SZ;
+
 		pDesc->next = &(pDevice->apTD1Rings[(i + 1) % pDevice->sOpts.nTxDescs[1]]);
 		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
@@ -1640,7 +1628,6 @@ static int vnt_init(struct vnt_private *priv)
 static int
 vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 {
-	PCHIP_INFO  pChip_info = (PCHIP_INFO)ent->driver_data;
 	struct vnt_private *priv;
 	struct ieee80211_hw *hw;
 	struct wiphy *wiphy;
@@ -1660,7 +1647,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 	priv = hw->priv;
 
-	vt6655_init_info(pcid, &priv, pChip_info);
+	vt6655_init_info(pcid, &priv);
 
 	priv->hw = hw;
 
@@ -1681,7 +1668,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	}
 
 	priv->PortOffset = ioremap(priv->memaddr & PCI_BASE_ADDRESS_MEM_MASK,
-				   priv->io_size);
+				   256);
 	if (!priv->PortOffset) {
 		dev_err(&pcid->dev, ": Failed to IO remapping ..\n");
 		device_free_info(priv);
@@ -1721,11 +1708,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 	device_get_options(priv);
 	device_set_options(priv);
-	/* Mask out the options cannot be set to the chip */
-	priv->sOpts.flags &= pChip_info->flags;
-
-	/* Enable the chip specified capabilities */
-	priv->flags = priv->sOpts.flags | (pChip_info->flags & 0xff000000UL);
 
 	wiphy = priv->hw->wiphy;
 

commit e77610a94c1fe0402979f58bee6933ffe18b15e3
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Sep 12 19:10:29 2015 +0100

    staging: vt6655: remove get_chip_name and info message.
    
    This prints "VIA Networking Solomon-A/B/G Wireless LAN Adapter"
    which has already printed once in vt6655_probe.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 2584d1786001..99191d979dc5 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -168,16 +168,6 @@ static void device_free_rings(struct vnt_private *pDevice);
 
 /*---------------------  Export Functions  --------------------------*/
 
-static char *get_chip_name(int chip_id)
-{
-	int i;
-
-	for (i = 0; chip_info_table[i].name != NULL; i++)
-		if (chip_info_table[i].chip_id == chip_id)
-			break;
-	return chip_info_table[i].name;
-}
-
 static void vt6655_remove(struct pci_dev *pcid)
 {
 	struct vnt_private *pDevice = pci_get_drvdata(pcid);
@@ -447,8 +437,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 
 static void device_print_info(struct vnt_private *pDevice)
 {
-	dev_info(&pDevice->pcid->dev, "%s\n", get_chip_name(pDevice->chip_id));
-
 	dev_info(&pDevice->pcid->dev, "MAC=%pM IO=0x%lx Mem=0x%lx IRQ=%d\n",
 		 pDevice->abyCurrentNetAddr, (unsigned long)pDevice->ioaddr,
 		 (unsigned long)pDevice->PortOffset, pDevice->pcid->irq);

commit c2c77eea18f24d847fc6dbbed5d6eaf29fb8de3e
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Sep 12 19:10:28 2015 +0100

    staging: vt6655: vt6655_probe remove PCI debug info
    
    Remove unnecessary debug PCI info that can be obtained
    by lspci.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 86c24a1ab4fa..2584d1786001 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1692,52 +1692,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 		return -ENODEV;
 	}
 
-#ifdef	DEBUG
-	dev_dbg(&pcid->dev,
-		"after get pci_info memaddr is %x, io addr is %x,io_size is %d\n",
-		priv->memaddr, priv->ioaddr, priv->io_size);
-	{
-		int i;
-		u32 bar, len;
-		u32 address[] = {
-			PCI_BASE_ADDRESS_0,
-			PCI_BASE_ADDRESS_1,
-			PCI_BASE_ADDRESS_2,
-			PCI_BASE_ADDRESS_3,
-			PCI_BASE_ADDRESS_4,
-			PCI_BASE_ADDRESS_5,
-			0};
-		for (i = 0; address[i]; i++) {
-			pci_read_config_dword(pcid, address[i], &bar);
-
-			dev_dbg(&pcid->dev, "bar %d is %x\n", i, bar);
-
-			if (!bar) {
-				dev_dbg(&pcid->dev,
-					"bar %d not implemented\n", i);
-				continue;
-			}
-
-			if (bar & PCI_BASE_ADDRESS_SPACE_IO) {
-				/* This is IO */
-
-				len = bar & (PCI_BASE_ADDRESS_IO_MASK & 0xffff);
-				len = len & ~(len - 1);
-
-				dev_dbg(&pcid->dev,
-					"IO space:  len in IO %x, BAR %d\n",
-					len, i);
-			} else {
-				len = bar & 0xfffffff0;
-				len = ~len + 1;
-
-				dev_dbg(&pcid->dev,
-					"len in MEM %x, BAR %d\n", len, i);
-			}
-		}
-	}
-#endif
-
 	priv->PortOffset = ioremap(priv->memaddr & PCI_BASE_ADDRESS_MEM_MASK,
 				   priv->io_size);
 	if (!priv->PortOffset) {

commit 9cb693f6f326ddf8f9df9c2bb3302048a919b394
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Aug 15 21:57:35 2015 +0100

    staging: vt6655: replace typedef struct tagSRxDesc
    
    with struct vnt_rx_desc and all members the same.
    
    volatile is removed from pointers as this generates warning
    message.
    
    Only the first four members of vnt_rx_desc need to be volatile.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index defdcc015d12..86c24a1ab4fa 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -155,7 +155,7 @@ static void device_init_td1_ring(struct vnt_private *pDevice);
 
 static int  device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx);
 static int  device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx);
-static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pDesc);
+static bool device_alloc_rx_buf(struct vnt_private *, struct vnt_rx_desc *);
 static void device_init_registers(struct vnt_private *pDevice);
 static void device_free_tx_buf(struct vnt_private *, struct vnt_tx_desc *);
 static void device_free_td0_ring(struct vnt_private *pDevice);
@@ -520,8 +520,8 @@ static bool device_init_rings(struct vnt_private *pDevice)
 
 	/*allocate all RD/TD rings a single pool*/
 	vir_pool = dma_zalloc_coherent(&pDevice->pcid->dev,
-					 pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
-					 pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
+					 pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc) +
+					 pDevice->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc) +
 					 pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
 					 pDevice->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc),
 					 &pDevice->pool_dma, GFP_ATOMIC);
@@ -532,11 +532,11 @@ static bool device_init_rings(struct vnt_private *pDevice)
 
 	pDevice->aRD0Ring = vir_pool;
 	pDevice->aRD1Ring = vir_pool +
-		pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
+		pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc);
 
 	pDevice->rd0_pool_dma = pDevice->pool_dma;
 	pDevice->rd1_pool_dma = pDevice->rd0_pool_dma +
-		pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
+		pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc);
 
 	pDevice->tx0_bufs = dma_zalloc_coherent(&pDevice->pcid->dev,
 						  pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
@@ -549,8 +549,8 @@ static bool device_init_rings(struct vnt_private *pDevice)
 		dev_err(&pDevice->pcid->dev, "allocate buf dma memory failed\n");
 
 		dma_free_coherent(&pDevice->pcid->dev,
-				    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
-				    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
+				    pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc) +
+				    pDevice->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc) +
 				    pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
 				    pDevice->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc),
 				    vir_pool, pDevice->pool_dma
@@ -559,19 +559,19 @@ static bool device_init_rings(struct vnt_private *pDevice)
 	}
 
 	pDevice->td0_pool_dma = pDevice->rd1_pool_dma +
-		pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);
+		pDevice->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc);
 
 	pDevice->td1_pool_dma = pDevice->td0_pool_dma +
 		pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc);
 
 	/* vir_pool: pvoid type */
 	pDevice->apTD0Rings = vir_pool
-		+ pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)
-		+ pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);
+		+ pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc)
+		+ pDevice->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc);
 
 	pDevice->apTD1Rings = vir_pool
-		+ pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)
-		+ pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc)
+		+ pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc)
+		+ pDevice->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc)
 		+ pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc);
 
 	pDevice->tx1_bufs = pDevice->tx0_bufs +
@@ -595,8 +595,8 @@ static bool device_init_rings(struct vnt_private *pDevice)
 static void device_free_rings(struct vnt_private *pDevice)
 {
 	dma_free_coherent(&pDevice->pcid->dev,
-			    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
-			    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
+			    pDevice->sOpts.nRxDescs0 * sizeof(struct vnt_rx_desc) +
+			    pDevice->sOpts.nRxDescs1 * sizeof(struct vnt_rx_desc) +
 			    pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
 			    pDevice->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc)
 			    ,
@@ -617,10 +617,11 @@ static void device_init_rd0_ring(struct vnt_private *pDevice)
 {
 	int i;
 	dma_addr_t      curr = pDevice->rd0_pool_dma;
-	PSRxDesc        pDesc;
+	struct vnt_rx_desc *pDesc;
 
 	/* Init the RD0 ring entries */
-	for (i = 0; i < pDevice->sOpts.nRxDescs0; i ++, curr += sizeof(SRxDesc)) {
+	for (i = 0; i < pDevice->sOpts.nRxDescs0;
+	     i ++, curr += sizeof(struct vnt_rx_desc)) {
 		pDesc = &(pDevice->aRD0Ring[i]);
 		pDesc->rd_info = alloc_rd_info();
 
@@ -628,7 +629,7 @@ static void device_init_rd0_ring(struct vnt_private *pDevice)
 			dev_err(&pDevice->pcid->dev, "can not alloc rx bufs\n");
 
 		pDesc->next = &(pDevice->aRD0Ring[(i+1) % pDevice->sOpts.nRxDescs0]);
-		pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
+		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 
 	if (i > 0)
@@ -640,10 +641,11 @@ static void device_init_rd1_ring(struct vnt_private *pDevice)
 {
 	int i;
 	dma_addr_t      curr = pDevice->rd1_pool_dma;
-	PSRxDesc        pDesc;
+	struct vnt_rx_desc *pDesc;
 
 	/* Init the RD1 ring entries */
-	for (i = 0; i < pDevice->sOpts.nRxDescs1; i ++, curr += sizeof(SRxDesc)) {
+	for (i = 0; i < pDevice->sOpts.nRxDescs1;
+	     i ++, curr += sizeof(struct vnt_rx_desc)) {
 		pDesc = &(pDevice->aRD1Ring[i]);
 		pDesc->rd_info = alloc_rd_info();
 
@@ -651,7 +653,7 @@ static void device_init_rd1_ring(struct vnt_private *pDevice)
 			dev_err(&pDevice->pcid->dev, "can not alloc rx bufs\n");
 
 		pDesc->next = &(pDevice->aRD1Ring[(i+1) % pDevice->sOpts.nRxDescs1]);
-		pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
+		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));
 	}
 
 	if (i > 0)
@@ -664,7 +666,7 @@ static void device_free_rd0_ring(struct vnt_private *pDevice)
 	int i;
 
 	for (i = 0; i < pDevice->sOpts.nRxDescs0; i++) {
-		PSRxDesc        pDesc = &(pDevice->aRD0Ring[i]);
+		struct vnt_rx_desc *pDesc = &(pDevice->aRD0Ring[i]);
 		struct vnt_rd_info *rd_info = pDesc->rd_info;
 
 		dma_unmap_single(&pDevice->pcid->dev, rd_info->skb_dma,
@@ -681,7 +683,7 @@ static void device_free_rd1_ring(struct vnt_private *pDevice)
 	int i;
 
 	for (i = 0; i < pDevice->sOpts.nRxDescs1; i++) {
-		PSRxDesc        pDesc = &(pDevice->aRD1Ring[i]);
+		struct vnt_rx_desc *pDesc = &(pDevice->aRD1Ring[i]);
 		struct vnt_rd_info *rd_info = pDesc->rd_info;
 
 		dma_unmap_single(&pDevice->pcid->dev, rd_info->skb_dma,
@@ -774,7 +776,7 @@ static void device_free_td1_ring(struct vnt_private *pDevice)
 
 static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 {
-	PSRxDesc    pRD;
+	struct vnt_rx_desc *pRD;
 	int works = 0;
 
 	for (pRD = pDevice->pCurrRD[uIdx];
@@ -801,7 +803,8 @@ static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 	return works;
 }
 
-static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pRD)
+static bool device_alloc_rx_buf(struct vnt_private *pDevice,
+				struct vnt_rx_desc *pRD)
 {
 	struct vnt_rd_info *pRDInfo = pRD->rd_info;
 

commit 88defe2b35f1b765dbfe9a800c443c31400a4e13
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Aug 15 21:57:34 2015 +0100

    staging: vt6655: replace typedef struct tagDEVICE_RD_INFO
    
    with struct vnt_rd_info
    
    volatile is removed because it will generate a warning
    (in any case this member is not) and renaming rd_info.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 22c195757f89..defdcc015d12 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -622,7 +622,7 @@ static void device_init_rd0_ring(struct vnt_private *pDevice)
 	/* Init the RD0 ring entries */
 	for (i = 0; i < pDevice->sOpts.nRxDescs0; i ++, curr += sizeof(SRxDesc)) {
 		pDesc = &(pDevice->aRD0Ring[i]);
-		pDesc->pRDInfo = alloc_rd_info();
+		pDesc->rd_info = alloc_rd_info();
 
 		if (!device_alloc_rx_buf(pDevice, pDesc))
 			dev_err(&pDevice->pcid->dev, "can not alloc rx bufs\n");
@@ -645,7 +645,7 @@ static void device_init_rd1_ring(struct vnt_private *pDevice)
 	/* Init the RD1 ring entries */
 	for (i = 0; i < pDevice->sOpts.nRxDescs1; i ++, curr += sizeof(SRxDesc)) {
 		pDesc = &(pDevice->aRD1Ring[i]);
-		pDesc->pRDInfo = alloc_rd_info();
+		pDesc->rd_info = alloc_rd_info();
 
 		if (!device_alloc_rx_buf(pDevice, pDesc))
 			dev_err(&pDevice->pcid->dev, "can not alloc rx bufs\n");
@@ -665,14 +665,14 @@ static void device_free_rd0_ring(struct vnt_private *pDevice)
 
 	for (i = 0; i < pDevice->sOpts.nRxDescs0; i++) {
 		PSRxDesc        pDesc = &(pDevice->aRD0Ring[i]);
-		PDEVICE_RD_INFO  pRDInfo = pDesc->pRDInfo;
+		struct vnt_rd_info *rd_info = pDesc->rd_info;
 
-		dma_unmap_single(&pDevice->pcid->dev, pRDInfo->skb_dma,
+		dma_unmap_single(&pDevice->pcid->dev, rd_info->skb_dma,
 				 pDevice->rx_buf_sz, DMA_FROM_DEVICE);
 
-		dev_kfree_skb(pRDInfo->skb);
+		dev_kfree_skb(rd_info->skb);
 
-		kfree(pDesc->pRDInfo);
+		kfree(pDesc->rd_info);
 	}
 }
 
@@ -682,14 +682,14 @@ static void device_free_rd1_ring(struct vnt_private *pDevice)
 
 	for (i = 0; i < pDevice->sOpts.nRxDescs1; i++) {
 		PSRxDesc        pDesc = &(pDevice->aRD1Ring[i]);
-		PDEVICE_RD_INFO  pRDInfo = pDesc->pRDInfo;
+		struct vnt_rd_info *rd_info = pDesc->rd_info;
 
-		dma_unmap_single(&pDevice->pcid->dev, pRDInfo->skb_dma,
+		dma_unmap_single(&pDevice->pcid->dev, rd_info->skb_dma,
 				 pDevice->rx_buf_sz, DMA_FROM_DEVICE);
 
-		dev_kfree_skb(pRDInfo->skb);
+		dev_kfree_skb(rd_info->skb);
 
-		kfree(pDesc->pRDInfo);
+		kfree(pDesc->rd_info);
 	}
 }
 
@@ -783,7 +783,7 @@ static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 		if (works++ > 15)
 			break;
 
-		if (!pRD->pRDInfo->skb)
+		if (!pRD->rd_info->skb)
 			break;
 
 		if (vnt_receive_frame(pDevice, pRD)) {
@@ -803,7 +803,7 @@ static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 
 static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pRD)
 {
-	PDEVICE_RD_INFO pRDInfo = pRD->pRDInfo;
+	struct vnt_rd_info *pRDInfo = pRD->rd_info;
 
 	pRDInfo->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
 	if (pRDInfo->skb == NULL)

commit 9fc7091cc24ceae25885a3ad074689cfb029f3c0
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Aug 15 21:57:33 2015 +0100

    staging: vt6655: replace typedef struct tagRDES1
    
    with struct vnt_rdes1 and members
    wReqCount -> req_count
    wReserved -> reserved
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 37c2be2fbe4c..22c195757f89 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -818,7 +818,7 @@ static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pRD)
 
 	pRD->rd0.res_count = cpu_to_le16(pDevice->rx_buf_sz);
 	pRD->rd0.owner = OWNED_BY_NIC;
-	pRD->m_rd1RD1.wReqCount = cpu_to_le16(pDevice->rx_buf_sz);
+	pRD->rd1.req_count = cpu_to_le16(pDevice->rx_buf_sz);
 	pRD->buff_addr = cpu_to_le32(pRDInfo->skb_dma);
 
 	return true;

commit de1c1862ca8c32a811021b61ce8905d03e53a451
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Aug 15 21:57:32 2015 +0100

    staging: vt6655: replace typedef struct tagRDES0
    
    with struct vnt_rdes0 replacing members as follows
    wResCount -> res_count
    f15Reserved -> f15_reserved
    f1Owner -> owner
    
    big endian
    f8Reserved1 -> f8_reserved1
    f7Reserved -> f7_reserved
    
    Narrowing endian differences to inside structure.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0d8f123c57fe..37c2be2fbe4c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -778,7 +778,7 @@ static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 	int works = 0;
 
 	for (pRD = pDevice->pCurrRD[uIdx];
-	     pRD->m_rd0RD0.f1Owner == OWNED_BY_HOST;
+	     pRD->rd0.owner == OWNED_BY_HOST;
 	     pRD = pRD->next) {
 		if (works++ > 15)
 			break;
@@ -793,7 +793,7 @@ static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 				break;
 			}
 		}
-		pRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;
+		pRD->rd0.owner = OWNED_BY_NIC;
 	}
 
 	pDevice->pCurrRD[uIdx] = pRD;
@@ -814,10 +814,10 @@ static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pRD)
 			       skb_put(pRDInfo->skb, skb_tailroom(pRDInfo->skb)),
 			       pDevice->rx_buf_sz, DMA_FROM_DEVICE);
 
-	*((unsigned int *)&(pRD->m_rd0RD0)) = 0; /* FIX cast */
+	*((unsigned int *)&pRD->rd0) = 0; /* FIX cast */
 
-	pRD->m_rd0RD0.wResCount = cpu_to_le16(pDevice->rx_buf_sz);
-	pRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;
+	pRD->rd0.res_count = cpu_to_le16(pDevice->rx_buf_sz);
+	pRD->rd0.owner = OWNED_BY_NIC;
 	pRD->m_rd1RD1.wReqCount = cpu_to_le16(pDevice->rx_buf_sz);
 	pRD->buff_addr = cpu_to_le32(pRDInfo->skb_dma);
 

commit e235727173626edf87c63b415d0363b411da299e
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri Aug 14 22:58:51 2015 +0100

    staging: vt6655: Replace typedef struct tagSTxDesc
    
    Replace with struct vnt_tx_desc with all members the same.
    
    volatile is removed from pointers as this generates warning
    message.
    
    Only the first four members of vnt_tx_desc need to be volatile.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f3d81787c98c..0d8f123c57fe 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -157,7 +157,7 @@ static int  device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx);
 static int  device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx);
 static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pDesc);
 static void device_init_registers(struct vnt_private *pDevice);
-static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc);
+static void device_free_tx_buf(struct vnt_private *, struct vnt_tx_desc *);
 static void device_free_td0_ring(struct vnt_private *pDevice);
 static void device_free_td1_ring(struct vnt_private *pDevice);
 static void device_free_rd0_ring(struct vnt_private *pDevice);
@@ -522,8 +522,8 @@ static bool device_init_rings(struct vnt_private *pDevice)
 	vir_pool = dma_zalloc_coherent(&pDevice->pcid->dev,
 					 pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
 					 pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
-					 pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
-					 pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
+					 pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
+					 pDevice->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc),
 					 &pDevice->pool_dma, GFP_ATOMIC);
 	if (vir_pool == NULL) {
 		dev_err(&pDevice->pcid->dev, "allocate desc dma memory failed\n");
@@ -551,8 +551,8 @@ static bool device_init_rings(struct vnt_private *pDevice)
 		dma_free_coherent(&pDevice->pcid->dev,
 				    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
 				    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
-				    pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
-				    pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
+				    pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
+				    pDevice->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc),
 				    vir_pool, pDevice->pool_dma
 			);
 		return false;
@@ -562,7 +562,7 @@ static bool device_init_rings(struct vnt_private *pDevice)
 		pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);
 
 	pDevice->td1_pool_dma = pDevice->td0_pool_dma +
-		pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);
+		pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc);
 
 	/* vir_pool: pvoid type */
 	pDevice->apTD0Rings = vir_pool
@@ -572,7 +572,7 @@ static bool device_init_rings(struct vnt_private *pDevice)
 	pDevice->apTD1Rings = vir_pool
 		+ pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)
 		+ pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc)
-		+ pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);
+		+ pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc);
 
 	pDevice->tx1_bufs = pDevice->tx0_bufs +
 		pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;
@@ -597,8 +597,8 @@ static void device_free_rings(struct vnt_private *pDevice)
 	dma_free_coherent(&pDevice->pcid->dev,
 			    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
 			    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
-			    pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
-			    pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc)
+			    pDevice->sOpts.nTxDescs[0] * sizeof(struct vnt_tx_desc) +
+			    pDevice->sOpts.nTxDescs[1] * sizeof(struct vnt_tx_desc)
 			    ,
 			    pDevice->aRD0Ring, pDevice->pool_dma
 		);
@@ -697,10 +697,11 @@ static void device_init_td0_ring(struct vnt_private *pDevice)
 {
 	int i;
 	dma_addr_t  curr;
-	PSTxDesc        pDesc;
+	struct vnt_tx_desc *pDesc;
 
 	curr = pDevice->td0_pool_dma;
-	for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++, curr += sizeof(STxDesc)) {
+	for (i = 0; i < pDevice->sOpts.nTxDescs[0];
+	     i++, curr += sizeof(struct vnt_tx_desc)) {
 		pDesc = &(pDevice->apTD0Rings[i]);
 		pDesc->td_info = alloc_td_info();
 
@@ -709,7 +710,7 @@ static void device_init_td0_ring(struct vnt_private *pDevice)
 			pDesc->td_info->buf_dma = pDevice->tx_bufs_dma0 + (i)*PKT_BUF_SZ;
 		}
 		pDesc->next = &(pDevice->apTD0Rings[(i+1) % pDevice->sOpts.nTxDescs[0]]);
-		pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
+		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
 
 	if (i > 0)
@@ -721,11 +722,12 @@ static void device_init_td1_ring(struct vnt_private *pDevice)
 {
 	int i;
 	dma_addr_t  curr;
-	PSTxDesc    pDesc;
+	struct vnt_tx_desc *pDesc;
 
 	/* Init the TD ring entries */
 	curr = pDevice->td1_pool_dma;
-	for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++, curr += sizeof(STxDesc)) {
+	for (i = 0; i < pDevice->sOpts.nTxDescs[1];
+	     i++, curr += sizeof(struct vnt_tx_desc)) {
 		pDesc = &(pDevice->apTD1Rings[i]);
 		pDesc->td_info = alloc_td_info();
 
@@ -734,7 +736,7 @@ static void device_init_td1_ring(struct vnt_private *pDevice)
 			pDesc->td_info->buf_dma = pDevice->tx_bufs_dma1 + (i) * PKT_BUF_SZ;
 		}
 		pDesc->next = &(pDevice->apTD1Rings[(i + 1) % pDevice->sOpts.nTxDescs[1]]);
-		pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
+		pDesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));
 	}
 
 	if (i > 0)
@@ -747,7 +749,7 @@ static void device_free_td0_ring(struct vnt_private *pDevice)
 	int i;
 
 	for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++) {
-		PSTxDesc        pDesc = &(pDevice->apTD0Rings[i]);
+		struct vnt_tx_desc *pDesc = &pDevice->apTD0Rings[i];
 		struct vnt_td_info *pTDInfo = pDesc->td_info;
 
 		dev_kfree_skb(pTDInfo->skb);
@@ -760,7 +762,7 @@ static void device_free_td1_ring(struct vnt_private *pDevice)
 	int i;
 
 	for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++) {
-		PSTxDesc        pDesc = &(pDevice->apTD1Rings[i]);
+		struct vnt_tx_desc *pDesc = &pDevice->apTD1Rings[i];
 		struct vnt_td_info *pTDInfo = pDesc->td_info;
 
 		dev_kfree_skb(pTDInfo->skb);
@@ -900,7 +902,7 @@ static int vnt_int_report_rate(struct vnt_private *priv,
 
 static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 {
-	PSTxDesc                 pTD;
+	struct vnt_tx_desc *pTD;
 	int                      works = 0;
 	unsigned char byTsr0;
 	unsigned char byTsr1;
@@ -958,7 +960,8 @@ static void device_error(struct vnt_private *pDevice, unsigned short status)
 	}
 }
 
-static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)
+static void device_free_tx_buf(struct vnt_private *pDevice,
+			       struct vnt_tx_desc *pDesc)
 {
 	struct vnt_td_info *pTDInfo = pDesc->td_info;
 	struct sk_buff *skb = pTDInfo->skb;
@@ -1156,7 +1159,7 @@ static irqreturn_t vnt_interrupt(int irq,  void *arg)
 static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 {
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	PSTxDesc head_td;
+	struct vnt_tx_desc *head_td;
 	u32 dma_idx;
 	unsigned long flags;
 

commit 543828599afc9cdd9012e363c7393e5ed102aa2a
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri Aug 14 22:58:50 2015 +0100

    staging: vt6655: replace typedef struct tagDEVICE_TD_INFO and structure
    
    Create struct vnt_td_info with members
    mic_hdr
    skb
    buf
    buf_dma
    dwReqCount -> req_count
    byFlags -> flags
    
    In struct tagSTxDesc volatile is removed because it will generate a warning
    (in any case this member is not) and renaming td_info.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c3b7bd40dc06..f3d81787c98c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -702,11 +702,11 @@ static void device_init_td0_ring(struct vnt_private *pDevice)
 	curr = pDevice->td0_pool_dma;
 	for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++, curr += sizeof(STxDesc)) {
 		pDesc = &(pDevice->apTD0Rings[i]);
-		pDesc->pTDInfo = alloc_td_info();
+		pDesc->td_info = alloc_td_info();
 
 		if (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {
-			pDesc->pTDInfo->buf = pDevice->tx0_bufs + (i)*PKT_BUF_SZ;
-			pDesc->pTDInfo->buf_dma = pDevice->tx_bufs_dma0 + (i)*PKT_BUF_SZ;
+			pDesc->td_info->buf = pDevice->tx0_bufs + (i)*PKT_BUF_SZ;
+			pDesc->td_info->buf_dma = pDevice->tx_bufs_dma0 + (i)*PKT_BUF_SZ;
 		}
 		pDesc->next = &(pDevice->apTD0Rings[(i+1) % pDevice->sOpts.nTxDescs[0]]);
 		pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
@@ -727,11 +727,11 @@ static void device_init_td1_ring(struct vnt_private *pDevice)
 	curr = pDevice->td1_pool_dma;
 	for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++, curr += sizeof(STxDesc)) {
 		pDesc = &(pDevice->apTD1Rings[i]);
-		pDesc->pTDInfo = alloc_td_info();
+		pDesc->td_info = alloc_td_info();
 
 		if (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {
-			pDesc->pTDInfo->buf = pDevice->tx1_bufs + (i) * PKT_BUF_SZ;
-			pDesc->pTDInfo->buf_dma = pDevice->tx_bufs_dma1 + (i) * PKT_BUF_SZ;
+			pDesc->td_info->buf = pDevice->tx1_bufs + (i) * PKT_BUF_SZ;
+			pDesc->td_info->buf_dma = pDevice->tx_bufs_dma1 + (i) * PKT_BUF_SZ;
 		}
 		pDesc->next = &(pDevice->apTD1Rings[(i + 1) % pDevice->sOpts.nTxDescs[1]]);
 		pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
@@ -748,10 +748,10 @@ static void device_free_td0_ring(struct vnt_private *pDevice)
 
 	for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++) {
 		PSTxDesc        pDesc = &(pDevice->apTD0Rings[i]);
-		PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
+		struct vnt_td_info *pTDInfo = pDesc->td_info;
 
 		dev_kfree_skb(pTDInfo->skb);
-		kfree(pDesc->pTDInfo);
+		kfree(pDesc->td_info);
 	}
 }
 
@@ -761,10 +761,10 @@ static void device_free_td1_ring(struct vnt_private *pDevice)
 
 	for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++) {
 		PSTxDesc        pDesc = &(pDevice->apTD1Rings[i]);
-		PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
+		struct vnt_td_info *pTDInfo = pDesc->td_info;
 
 		dev_kfree_skb(pTDInfo->skb);
-		kfree(pDesc->pTDInfo);
+		kfree(pDesc->td_info);
 	}
 }
 
@@ -839,7 +839,7 @@ static const u8 fallback_rate1[5][5] = {
 };
 
 static int vnt_int_report_rate(struct vnt_private *priv,
-			       PDEVICE_TD_INFO context, u8 tsr0, u8 tsr1)
+			       struct vnt_td_info *context, u8 tsr0, u8 tsr1)
 {
 	struct vnt_tx_fifo_head *fifo_head;
 	struct ieee80211_tx_info *info;
@@ -916,7 +916,7 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 
 		/* Only the status of first TD in the chain is correct */
 		if (pTD->td1.tcr & TCR_STP) {
-			if ((pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0) {
+			if ((pTD->td_info->flags & TD_FLAGS_NETIF_SKB) != 0) {
 				if (!(byTsr1 & TSR1_TERR)) {
 					if (byTsr0 != 0) {
 						pr_debug(" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X]\n",
@@ -930,13 +930,13 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 			}
 
 			if (byTsr1 & TSR1_TERR) {
-				if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
+				if ((pTD->td_info->flags & TD_FLAGS_PRIV_SKB) != 0) {
 					pr_debug(" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X]\n",
 						 (int)uIdx, byTsr1, byTsr0);
 				}
 			}
 
-			vnt_int_report_rate(pDevice, pTD->pTDInfo, byTsr0, byTsr1);
+			vnt_int_report_rate(pDevice, pTD->td_info, byTsr0, byTsr1);
 
 			device_free_tx_buf(pDevice, pTD);
 			pDevice->iTDUsed[uIdx]--;
@@ -960,14 +960,14 @@ static void device_error(struct vnt_private *pDevice, unsigned short status)
 
 static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)
 {
-	PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
+	struct vnt_td_info *pTDInfo = pDesc->td_info;
 	struct sk_buff *skb = pTDInfo->skb;
 
 	if (skb)
 		ieee80211_tx_status_irqsafe(pDevice->hw, skb);
 
 	pTDInfo->skb = NULL;
-	pTDInfo->byFlags = 0;
+	pTDInfo->flags = 0;
 }
 
 static void vnt_check_bb_vga(struct vnt_private *priv)
@@ -1176,10 +1176,10 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	head_td->td1.tcr = 0;
 
-	head_td->pTDInfo->skb = skb;
+	head_td->td_info->skb = skb;
 
 	if (dma_idx == TYPE_AC0DMA)
-		head_td->pTDInfo->byFlags = TD_FLAGS_NETIF_SKB;
+		head_td->td_info->flags = TD_FLAGS_NETIF_SKB;
 
 	priv->apCurrTD[dma_idx] = head_td->next;
 
@@ -1193,16 +1193,16 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	/* Set TSR1 & ReqCount in TxDescHead */
 	head_td->td1.tcr |= (TCR_STP | TCR_EDP | EDMSDU);
-	head_td->td1.req_count = cpu_to_le16(head_td->pTDInfo->dwReqCount);
+	head_td->td1.req_count = cpu_to_le16(head_td->td_info->req_count);
 
-	head_td->buff_addr = cpu_to_le32(head_td->pTDInfo->buf_dma);
+	head_td->buff_addr = cpu_to_le32(head_td->td_info->buf_dma);
 
 	/* Poll Transmit the adapter */
 	wmb();
 	head_td->td0.owner = OWNED_BY_NIC;
 	wmb(); /* second memory barrier */
 
-	if (head_td->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)
+	if (head_td->td_info->flags & TD_FLAGS_NETIF_SKB)
 		MACvTransmitAC0(priv->PortOffset);
 	else
 		MACvTransmit0(priv->PortOffset);

commit 531a9c524a54b7d232b6bf6631c460450dd41dbf
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri Aug 14 22:58:48 2015 +0100

    staging: vt6655: struct tagDEVICE_TD_INFO resize dwReqCount.
    
    dwReqCount is no bigger than u16
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 947e8685db55..c3b7bd40dc06 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1193,7 +1193,7 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	/* Set TSR1 & ReqCount in TxDescHead */
 	head_td->td1.tcr |= (TCR_STP | TCR_EDP | EDMSDU);
-	head_td->td1.req_count = cpu_to_le16((u16)head_td->pTDInfo->dwReqCount);
+	head_td->td1.req_count = cpu_to_le16(head_td->pTDInfo->dwReqCount);
 
 	head_td->buff_addr = cpu_to_le32(head_td->pTDInfo->buf_dma);
 

commit 9cc8eac99c98000a414f916c1c58dab22c29474d
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri Aug 14 22:58:47 2015 +0100

    staging: vt6655: replaced typedef struct tagTDES1
    
    Create struct vnt_tdes1 that replaces members
    wReqCount -> req_count
    byTCR -> tcr
    byReserved -> reserved
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 842e0524a31f..947e8685db55 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -915,7 +915,7 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 		byTsr1 = pTD->td0.tsr1;
 
 		/* Only the status of first TD in the chain is correct */
-		if (pTD->m_td1TD1.byTCR & TCR_STP) {
+		if (pTD->td1.tcr & TCR_STP) {
 			if ((pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0) {
 				if (!(byTsr1 & TSR1_TERR)) {
 					if (byTsr0 != 0) {
@@ -1174,7 +1174,7 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	head_td = priv->apCurrTD[dma_idx];
 
-	head_td->m_td1TD1.byTCR = 0;
+	head_td->td1.tcr = 0;
 
 	head_td->pTDInfo->skb = skb;
 
@@ -1192,9 +1192,8 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 	priv->bPWBitOn = false;
 
 	/* Set TSR1 & ReqCount in TxDescHead */
-	head_td->m_td1TD1.byTCR |= (TCR_STP | TCR_EDP | EDMSDU);
-	head_td->m_td1TD1.wReqCount =
-			cpu_to_le16((u16)head_td->pTDInfo->dwReqCount);
+	head_td->td1.tcr |= (TCR_STP | TCR_EDP | EDMSDU);
+	head_td->td1.req_count = cpu_to_le16((u16)head_td->pTDInfo->dwReqCount);
 
 	head_td->buff_addr = cpu_to_le32(head_td->pTDInfo->buf_dma);
 

commit 5235ff6a1df6fb0883f1a9020ab36e0db1c68064
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri Aug 14 22:58:46 2015 +0100

    staging: vt6655: desc.h replace typedef struct tagTDES0
    
    create struct vnt_tdes0 replacing used members
    byTSR0 -> tsr0
    byTSR1 -> tsr1
    f1Owner -> owner
    
    Narrowing endian differences to inside structure.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index b74af8d89fe6..842e0524a31f 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -906,13 +906,13 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 	unsigned char byTsr1;
 
 	for (pTD = pDevice->apTailTD[uIdx]; pDevice->iTDUsed[uIdx] > 0; pTD = pTD->next) {
-		if (pTD->m_td0TD0.f1Owner == OWNED_BY_NIC)
+		if (pTD->td0.owner == OWNED_BY_NIC)
 			break;
 		if (works++ > 15)
 			break;
 
-		byTsr0 = pTD->m_td0TD0.byTSR0;
-		byTsr1 = pTD->m_td0TD0.byTSR1;
+		byTsr0 = pTD->td0.tsr0;
+		byTsr1 = pTD->td0.tsr1;
 
 		/* Only the status of first TD in the chain is correct */
 		if (pTD->m_td1TD1.byTCR & TCR_STP) {
@@ -1200,7 +1200,7 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	/* Poll Transmit the adapter */
 	wmb();
-	head_td->m_td0TD0.f1Owner = OWNED_BY_NIC;
+	head_td->td0.owner = OWNED_BY_NIC;
 	wmb(); /* second memory barrier */
 
 	if (head_td->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)

commit f70d6318320983a8d2fac28cfe8d22dfd5e52a73
Merge: b963e7223cb3 f7644cbfcdf0
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 10 09:07:25 2015 -0700

    Merge 4.2-rc6 into staging-next
    
    We want the IIO and staging fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1f17124006b65482d9084c01e252b59dbca8db8f
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Aug 2 12:34:46 2015 +0100

    staging: vt6655: vnt_bss_info_changed check conf->beacon_rate is not NULL
    
    conf->beacon_rate can be NULL on association. So check conf->beacon_rate
    
    BSS_CHANGED_BEACON_INFO needs to flagged in changed as the beacon_rate
    will appear later.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: <stable@vger.kernel.org> # v3.19+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index b0c8e235b982..69bdc8f29b59 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1483,8 +1483,9 @@ static void vnt_bss_info_changed(struct ieee80211_hw *hw,
 		}
 	}
 
-	if (changed & BSS_CHANGED_ASSOC && priv->op_mode != NL80211_IFTYPE_AP) {
-		if (conf->assoc) {
+	if (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_BEACON_INFO) &&
+	    priv->op_mode != NL80211_IFTYPE_AP) {
+		if (conf->assoc && conf->beacon_rate) {
 			CARDbUpdateTSF(priv, conf->beacon_rate->hw_value,
 				       conf->sync_tsf);
 

commit d5806c53fe7805ebf4934debbe21fc42f78840f4
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jul 22 19:16:45 2015 +0100

    staging: vt6655: always set 32 bit dma mask
    
    The device is limited to 32 bit address space.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c82bf48499f0..c97353bfab72 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1747,6 +1747,12 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 		return -ENODEV;
 	}
 
+	if (dma_set_mask(&pcid->dev, DMA_BIT_MASK(32))) {
+		dev_err(&pcid->dev, ": Failed to set dma 32 bit mask\n");
+		device_free_info(priv);
+		return -ENODEV;
+	}
+
 	INIT_WORK(&priv->interrupt_work, vnt_interrupt_work);
 
 	/* do reset */

commit db1ade7cee35a2d22653811c67cd4d9c60c8a4ad
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jul 22 19:16:40 2015 +0100

    staging: vt6655: remove unused tagDEVICE_RD_INFO -> curr_desc
    
    variable is assigned a value that is never used.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 7409ed2f3a95..c82bf48499f0 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -628,7 +628,6 @@ static void device_init_rd0_ring(struct vnt_private *pDevice)
 			dev_err(&pDevice->pcid->dev, "can not alloc rx bufs\n");
 
 		pDesc->next = &(pDevice->aRD0Ring[(i+1) % pDevice->sOpts.nRxDescs0]);
-		pDesc->pRDInfo->curr_desc = cpu_to_le32(curr);
 		pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
 	}
 
@@ -652,7 +651,6 @@ static void device_init_rd1_ring(struct vnt_private *pDevice)
 			dev_err(&pDevice->pcid->dev, "can not alloc rx bufs\n");
 
 		pDesc->next = &(pDevice->aRD1Ring[(i+1) % pDevice->sOpts.nRxDescs1]);
-		pDesc->pRDInfo->curr_desc = cpu_to_le32(curr);
 		pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
 	}
 

commit eae6377eb01d6b8a6cb3f1047ae35829e22e4e04
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jul 22 19:16:37 2015 +0100

    staging: vt6655: Remove unused tagDEVICE_TD_INFO curr_desc
    
    The variable is assigned a value that is never used.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 89611a70d785..7409ed2f3a95 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -711,7 +711,6 @@ static void device_init_td0_ring(struct vnt_private *pDevice)
 			pDesc->pTDInfo->buf_dma = pDevice->tx_bufs_dma0 + (i)*PKT_BUF_SZ;
 		}
 		pDesc->next = &(pDevice->apTD0Rings[(i+1) % pDevice->sOpts.nTxDescs[0]]);
-		pDesc->pTDInfo->curr_desc = cpu_to_le32(curr);
 		pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
 	}
 
@@ -737,7 +736,6 @@ static void device_init_td1_ring(struct vnt_private *pDevice)
 			pDesc->pTDInfo->buf_dma = pDevice->tx_bufs_dma1 + (i) * PKT_BUF_SZ;
 		}
 		pDesc->next = &(pDevice->apTD1Rings[(i + 1) % pDevice->sOpts.nTxDescs[1]]);
-		pDesc->pTDInfo->curr_desc = cpu_to_le32(curr);
 		pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
 	}
 

commit 06f716a57e6d7dc8f7638ea8c19a9a4cdf46ed23
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jul 22 19:16:36 2015 +0100

    staging: vt6655: remove unnecessary variable skb_dma
    
    skb_dma flips from 0 to the contents buf_dma.
    
    This is nolonger necessary so use buf_dma directly
    and remove skb_dma altogether.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 695aa25e819d..89611a70d785 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -970,7 +970,6 @@ static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)
 	if (skb)
 		ieee80211_tx_status_irqsafe(pDevice->hw, skb);
 
-	pTDInfo->skb_dma = 0;
 	pTDInfo->skb = NULL;
 	pTDInfo->byFlags = 0;
 }
@@ -1201,7 +1200,7 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 	head_td->m_td1TD1.wReqCount =
 			cpu_to_le16((u16)head_td->pTDInfo->dwReqCount);
 
-	head_td->buff_addr = cpu_to_le32(head_td->pTDInfo->skb_dma);
+	head_td->buff_addr = cpu_to_le32(head_td->pTDInfo->buf_dma);
 
 	/* Poll Transmit the adapter */
 	wmb();

commit 3a00033ee8697e2e0acf07d03dbea55c4b7236ca
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jul 22 19:16:35 2015 +0100

    staging: vt6655: dead code tx path remove dma_unmap_single
    
    When pTDInfo->skb_dma not equal to pTDInfo->buf_dma, pTDInfo->skb_dma
    equals zero.
    
    as mentioned in comment pre-allocated buf_dma can't be unmapped
    so remove dead code.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 053291a8e844..695aa25e819d 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -754,10 +754,6 @@ static void device_free_td0_ring(struct vnt_private *pDevice)
 		PSTxDesc        pDesc = &(pDevice->apTD0Rings[i]);
 		PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
 
-		if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma))
-			dma_unmap_single(&pDevice->pcid->dev, pTDInfo->skb_dma,
-					 pTDInfo->skb->len, DMA_TO_DEVICE);
-
 		dev_kfree_skb(pTDInfo->skb);
 		kfree(pDesc->pTDInfo);
 	}
@@ -771,10 +767,6 @@ static void device_free_td1_ring(struct vnt_private *pDevice)
 		PSTxDesc        pDesc = &(pDevice->apTD1Rings[i]);
 		PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
 
-		if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma))
-			dma_unmap_single(&pDevice->pcid->dev, pTDInfo->skb_dma,
-					 pTDInfo->skb->len, DMA_TO_DEVICE);
-
 		dev_kfree_skb(pTDInfo->skb);
 		kfree(pDesc->pTDInfo);
 	}
@@ -975,12 +967,6 @@ static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)
 	PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
 	struct sk_buff *skb = pTDInfo->skb;
 
-	/* pre-allocated buf_dma can't be unmapped. */
-	if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma)) {
-		dma_unmap_single(&pDevice->pcid->dev, pTDInfo->skb_dma,
-				 skb->len, DMA_TO_DEVICE);
-	}
-
 	if (skb)
 		ieee80211_tx_status_irqsafe(pDevice->hw, skb);
 

commit 217ed3abf1510747590aaa5da93217e559fd8e19
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jul 22 19:16:33 2015 +0100

    staging: vt6655: Remove ununsed macro ASSERT
    
    VIAWET_DEBUG is not defined so macro is empty.
    
    Remove the macro.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 23ad16eb1d2a..053291a8e844 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -623,7 +623,7 @@ static void device_init_rd0_ring(struct vnt_private *pDevice)
 	for (i = 0; i < pDevice->sOpts.nRxDescs0; i ++, curr += sizeof(SRxDesc)) {
 		pDesc = &(pDevice->aRD0Ring[i]);
 		pDesc->pRDInfo = alloc_rd_info();
-		ASSERT(pDesc->pRDInfo);
+
 		if (!device_alloc_rx_buf(pDevice, pDesc))
 			dev_err(&pDevice->pcid->dev, "can not alloc rx bufs\n");
 
@@ -647,7 +647,7 @@ static void device_init_rd1_ring(struct vnt_private *pDevice)
 	for (i = 0; i < pDevice->sOpts.nRxDescs1; i ++, curr += sizeof(SRxDesc)) {
 		pDesc = &(pDevice->aRD1Ring[i]);
 		pDesc->pRDInfo = alloc_rd_info();
-		ASSERT(pDesc->pRDInfo);
+
 		if (!device_alloc_rx_buf(pDevice, pDesc))
 			dev_err(&pDevice->pcid->dev, "can not alloc rx bufs\n");
 
@@ -705,7 +705,7 @@ static void device_init_td0_ring(struct vnt_private *pDevice)
 	for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++, curr += sizeof(STxDesc)) {
 		pDesc = &(pDevice->apTD0Rings[i]);
 		pDesc->pTDInfo = alloc_td_info();
-		ASSERT(pDesc->pTDInfo);
+
 		if (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {
 			pDesc->pTDInfo->buf = pDevice->tx0_bufs + (i)*PKT_BUF_SZ;
 			pDesc->pTDInfo->buf_dma = pDevice->tx_bufs_dma0 + (i)*PKT_BUF_SZ;
@@ -731,7 +731,7 @@ static void device_init_td1_ring(struct vnt_private *pDevice)
 	for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++, curr += sizeof(STxDesc)) {
 		pDesc = &(pDevice->apTD1Rings[i]);
 		pDesc->pTDInfo = alloc_td_info();
-		ASSERT(pDesc->pTDInfo);
+
 		if (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {
 			pDesc->pTDInfo->buf = pDevice->tx1_bufs + (i) * PKT_BUF_SZ;
 			pDesc->pTDInfo->buf_dma = pDevice->tx_bufs_dma1 + (i) * PKT_BUF_SZ;
@@ -818,7 +818,6 @@ static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pRD)
 	pRDInfo->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
 	if (pRDInfo->skb == NULL)
 		return false;
-	ASSERT(pRDInfo->skb);
 
 	pRDInfo->skb_dma =
 		dma_map_single(&pDevice->pcid->dev,

commit ed15e8880fc3d8d52bc02a02521054bfcb26264a
Merge: b8d1f261fe7e 52721d9d3334
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 20 13:21:28 2015 -0700

    Merge 4.2-rc3 into staging-next
    
    We need the staging fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4d4d138a3e2c2a85df9fa048b341612c235c1027
Author: Maninder Singh <maninder1.s@samsung.com>
Date:   Wed Jul 15 08:52:51 2015 +0530

    staging:vt6655: remove checks around dev_kfree_skb
    
    dev_kfree_skb checks for NULL pointer itself,
    Thus no need of explicit NULL check.
    
    Signed-off-by: Maninder Singh <maninder1.s@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4f55d5e9a9c5..f7d70427d050 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -758,9 +758,7 @@ static void device_free_td0_ring(struct vnt_private *pDevice)
 			dma_unmap_single(&pDevice->pcid->dev, pTDInfo->skb_dma,
 					 pTDInfo->skb->len, DMA_TO_DEVICE);
 
-		if (pTDInfo->skb)
-			dev_kfree_skb(pTDInfo->skb);
-
+		dev_kfree_skb(pTDInfo->skb);
 		kfree(pDesc->pTDInfo);
 	}
 }
@@ -777,9 +775,7 @@ static void device_free_td1_ring(struct vnt_private *pDevice)
 			dma_unmap_single(&pDevice->pcid->dev, pTDInfo->skb_dma,
 					 pTDInfo->skb->len, DMA_TO_DEVICE);
 
-		if (pTDInfo->skb)
-			dev_kfree_skb(pTDInfo->skb);
-
+		dev_kfree_skb(pTDInfo->skb);
 		kfree(pDesc->pTDInfo);
 	}
 }

commit 8e8e9198920ddfa920191069ae02eba75d39e653
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Jul 9 17:01:24 2015 +0100

    staging: vt6655: check ieee80211_bss_conf bssid not NULL
    
    Sometimes bssid can go null on failed association.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: <stable@vger.kernel.org> # v3.19+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ed040fbb7df8..b0c8e235b982 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1418,7 +1418,7 @@ static void vnt_bss_info_changed(struct ieee80211_hw *hw,
 
 	priv->current_aid = conf->aid;
 
-	if (changed & BSS_CHANGED_BSSID) {
+	if (changed & BSS_CHANGED_BSSID && conf->bssid) {
 		unsigned long flags;
 
 		spin_lock_irqsave(&priv->lock, flags);

commit eda01f6161e0f0d156f7fd24080d3a788ebbb911
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Jul 9 17:01:25 2015 +0100

    staging: vt6655: Fix missing power saving support
    
    Add IEEE80211_HW_SUPPORTS_PS to ieee80211_hw flags
    enabling this feature.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0176456d15e2..4f55d5e9a9c5 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1808,6 +1808,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	ieee80211_hw_set(priv->hw, SIGNAL_DBM);
 	ieee80211_hw_set(priv->hw, RX_INCLUDES_FCS);
 	ieee80211_hw_set(priv->hw, REPORTS_TX_ACK_STATUS);
+	ieee80211_hw_set(priv->hw, SUPPORTS_PS);
 
 	priv->hw->max_signal = 100;
 

commit 4fdae0d9fee32c1cbffffb1a246fcc10ed5b1085
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jun 21 11:05:54 2015 +0100

    staging: vt6655: vnt_tx_packet don't wakeup from power saving.
    
    mac80211 changes the wake state before attempting to tx data
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ed040fbb7df8..0176456d15e2 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1211,9 +1211,6 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	vnt_generate_fifo_header(priv, dma_idx, head_td, skb);
 
-	if (MACbIsRegBitsOn(priv->PortOffset, MAC_REG_PSCTL, PSCTL_PS))
-		MACbPSWakeup(priv->PortOffset);
-
 	spin_lock_irqsave(&priv->lock, flags);
 
 	priv->bPWBitOn = false;

commit 23908db413eccd77084b09c9b0a4451dfb0524c0
Merge: 8d7804a2f03d 53a20e9e378e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 26 15:46:08 2015 -0700

    Merge tag 'staging-4.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging driver updates from Greg KH:
     "Here's the big, really big, staging tree patches for 4.2-rc1.
    
      Loads of stuff in here, almost all just coding style fixes / churn,
      and a few new drivers as well, one of which I just disabled from the
      build a few minutes ago due to way too many build warnings.
    
      Other than the one "disable this driver" patch, all of these have been
      in linux-next for quite a while with no reported issues"
    
    * tag 'staging-4.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (1163 commits)
      staging: wilc1000: disable driver due to build warnings
      Staging: rts5208: fix CHANGE_LINK_STATE value
      Staging: sm750fb: ddk750_swi2c.c: Insert spaces before parenthesis
      Staging: sm750fb: ddk750_swi2c.c: Place braces on correct lines
      Staging: sm750fb: ddk750_swi2c.c: Insert spaces around operators
      Staging: sm750fb: ddk750_swi2c.c: Replace spaces with tabs
      Staging: sm750fb: ddk750_swi2c.h: Shorten lines to under 80 characters
      Staging: sm750fb: ddk750_swi2c.h: Replace spaces with tabs
      Staging: sm750fb: modedb.h: Shorten lines to under 80 characters
      Staging: sm750fb: modedb.h: Replace spaces with tabs
      staging: comedi: addi_apci_3120: rename 'this_board' variables
      staging: comedi: addi_apci_1516: rename 'this_board' variables
      staging: comedi: ni_atmio: cleanup ni_getboardtype()
      staging: comedi: vmk80xx: sanity check context used to get the boardinfo
      staging: comedi: vmk80xx: rename 'boardinfo' variables
      staging: comedi: dt3000: rename 'this_board' variables
      staging: comedi: adv_pci_dio: rename 'this_board' variables
      staging: comedi: cb_pcidas64: rename 'thisboard' variables
      staging: comedi: cb_pcidas: rename 'thisboard' variables
      staging: comedi: me4000: rename 'thisboard' variables
      ...

commit e75e8cacba0ea26571f6ce5145c6d0a235161454
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Tue Jun 16 23:43:12 2015 +0100

    staging: vt6655: use module_pci_driver helper
    
    Remove  vt6655_init_module and vt6655_cleanup_module and replace
    module_pci_driver
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c393b737ce6c..0bfc9390bbb5 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1878,19 +1878,4 @@ static struct pci_driver device_driver = {
 #endif
 };
 
-static int __init vt6655_init_module(void)
-{
-	int ret;
-
-	ret = pci_register_driver(&device_driver);
-
-	return ret;
-}
-
-static void __exit vt6655_cleanup_module(void)
-{
-	pci_unregister_driver(&device_driver);
-}
-
-module_init(vt6655_init_module);
-module_exit(vt6655_cleanup_module);
+module_pci_driver(device_driver);

commit b51c88171ee9c8e9fac8a99b64fd0a056a8fcb85
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Tue Jun 16 23:43:11 2015 +0100

    staging: vt6655: remove suspend struct notifier_block.
    
    The only thing this does is vt6655_suspend which is already been called
    upon suspend.
    
    Remove function device_notify_reboot and structure device_notifier.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 8dbde24eb154..c393b737ce6c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -148,15 +148,6 @@ static void device_free_info(struct vnt_private *pDevice);
 static bool device_get_pci_info(struct vnt_private *, struct pci_dev *pcid);
 static void device_print_info(struct vnt_private *pDevice);
 
-#ifdef CONFIG_PM
-static int device_notify_reboot(struct notifier_block *, unsigned long event, void *ptr);
-static struct notifier_block device_notifier = {
-	.notifier_call = device_notify_reboot,
-	.next = NULL,
-	.priority = 0,
-};
-#endif
-
 static void device_init_rd0_ring(struct vnt_private *pDevice);
 static void device_init_rd1_ring(struct vnt_private *pDevice);
 static void device_init_td0_ring(struct vnt_private *pDevice);
@@ -1892,42 +1883,14 @@ static int __init vt6655_init_module(void)
 	int ret;
 
 	ret = pci_register_driver(&device_driver);
-#ifdef CONFIG_PM
-	if (ret >= 0)
-		register_reboot_notifier(&device_notifier);
-#endif
 
 	return ret;
 }
 
 static void __exit vt6655_cleanup_module(void)
 {
-#ifdef CONFIG_PM
-	unregister_reboot_notifier(&device_notifier);
-#endif
 	pci_unregister_driver(&device_driver);
 }
 
 module_init(vt6655_init_module);
 module_exit(vt6655_cleanup_module);
-
-#ifdef CONFIG_PM
-static int
-device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
-{
-	struct pci_dev *pdev = NULL;
-
-	switch (event) {
-	case SYS_DOWN:
-	case SYS_HALT:
-	case SYS_POWER_OFF:
-		for_each_pci_dev(pdev) {
-			if (pci_dev_driver(pdev) == &device_driver) {
-				if (pci_get_drvdata(pdev))
-					vt6655_suspend(pdev, PMSG_HIBERNATE);
-			}
-		}
-	}
-	return NOTIFY_DONE;
-}
-#endif

commit 30686bf7f5b3c30831761e188a6e3cb33580fa48
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Jun 2 21:39:54 2015 +0200

    mac80211: convert HW flags to unsigned long bitmap
    
    As we're running out of hardware capability flags pretty quickly,
    convert them to use the regular test_bit() style unsigned long
    bitmaps.
    
    This introduces a number of helper functions/macros to set and to
    test the bits, along with new debugfs code.
    
    The occurrences of an explicit __clear_bit() are intentional, the
    drivers were never supposed to change their supported bits on the
    fly. We should investigate changing this to be a per-frame flag.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ecd7c0f82481..458bc340aece 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1793,10 +1793,10 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
 		BIT(NL80211_IFTYPE_ADHOC) | BIT(NL80211_IFTYPE_AP);
 
-	priv->hw->flags = IEEE80211_HW_RX_INCLUDES_FCS |
-		IEEE80211_HW_REPORTS_TX_ACK_STATUS |
-		IEEE80211_HW_SIGNAL_DBM |
-		IEEE80211_HW_TIMING_BEACON_ONLY;
+	ieee80211_hw_set(priv->hw, TIMING_BEACON_ONLY);
+	ieee80211_hw_set(priv->hw, SIGNAL_DBM);
+	ieee80211_hw_set(priv->hw, RX_INCLUDES_FCS);
+	ieee80211_hw_set(priv->hw, REPORTS_TX_ACK_STATUS);
 
 	priv->hw->max_signal = 100;
 

commit b5eeed8cb6097c8ea660b6598d36fdbb94065a22
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun May 31 10:35:28 2015 +0100

    staging: vt6655: device_rx_srv check sk_buff is NULL
    
    There is a small chance that pRD->pRDInfo->skb could go NULL
    while the interrupt is processing.
    
    Put NULL check on loop to break out.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index aec3ccec2231..8dbde24eb154 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -805,6 +805,10 @@ static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 	     pRD = pRD->next) {
 		if (works++ > 15)
 			break;
+
+		if (!pRD->pRDInfo->skb)
+			break;
+
 		if (vnt_receive_frame(pDevice, pRD)) {
 			if (!device_alloc_rx_buf(pDevice, pRD)) {
 				dev_err(&pDevice->pcid->dev,

commit 41b9e5e5164da54c4dd77492d2e3909c38de4fc9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun May 31 10:35:27 2015 +0100

    staging: vt6655: replace and resize dwIsr
    
    dwIsr is not used outside vnt_interrupt_process and should
    be u32.
    
    Move to function and resize to u32.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 575ba87af75f..aec3ccec2231 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1056,15 +1056,16 @@ static void vnt_interrupt_process(struct vnt_private *priv)
 	struct ieee80211_low_level_stats *low_stats = &priv->low_stats;
 	int             max_count = 0;
 	u32 mib_counter;
+	u32 isr;
 	unsigned long flags;
 
-	MACvReadISR(priv->PortOffset, &priv->dwIsr);
+	MACvReadISR(priv->PortOffset, &isr);
 
-	if (priv->dwIsr == 0)
+	if (isr == 0)
 		return;
 
-	if (priv->dwIsr == 0xffffffff) {
-		pr_debug("dwIsr = 0xffff\n");
+	if (isr == 0xffffffff) {
+		pr_debug("isr = 0xffff\n");
 		return;
 	}
 
@@ -1086,18 +1087,18 @@ static void vnt_interrupt_process(struct vnt_private *priv)
 	 * than RD/TD write back
 	 * update ISR counter
 	 */
-	while (priv->dwIsr && priv->vif) {
-		MACvWriteISR(priv->PortOffset, priv->dwIsr);
+	while (isr && priv->vif) {
+		MACvWriteISR(priv->PortOffset, isr);
 
-		if (priv->dwIsr & ISR_FETALERR) {
+		if (isr & ISR_FETALERR) {
 			pr_debug(" ISR_FETALERR\n");
 			VNSvOutPortB(priv->PortOffset + MAC_REG_SOFTPWRCTL, 0);
 			VNSvOutPortW(priv->PortOffset +
 				     MAC_REG_SOFTPWRCTL, SOFTPWRCTL_SWPECTI);
-			device_error(priv, priv->dwIsr);
+			device_error(priv, isr);
 		}
 
-		if (priv->dwIsr & ISR_TBTT) {
+		if (isr & ISR_TBTT) {
 			if (priv->op_mode != NL80211_IFTYPE_ADHOC)
 				vnt_check_bb_vga(priv);
 
@@ -1116,7 +1117,7 @@ static void vnt_interrupt_process(struct vnt_private *priv)
 
 		}
 
-		if (priv->dwIsr & ISR_BNTX) {
+		if (isr & ISR_BNTX) {
 			if (priv->op_mode == NL80211_IFTYPE_ADHOC) {
 				priv->bIsBeaconBufReadySet = false;
 				priv->cbBeaconBufReadySetCnt = 0;
@@ -1125,19 +1126,19 @@ static void vnt_interrupt_process(struct vnt_private *priv)
 			priv->bBeaconSent = true;
 		}
 
-		if (priv->dwIsr & ISR_RXDMA0)
+		if (isr & ISR_RXDMA0)
 			max_count += device_rx_srv(priv, TYPE_RXDMA0);
 
-		if (priv->dwIsr & ISR_RXDMA1)
+		if (isr & ISR_RXDMA1)
 			max_count += device_rx_srv(priv, TYPE_RXDMA1);
 
-		if (priv->dwIsr & ISR_TXDMA0)
+		if (isr & ISR_TXDMA0)
 			max_count += device_tx_srv(priv, TYPE_TXDMA0);
 
-		if (priv->dwIsr & ISR_AC0DMA)
+		if (isr & ISR_AC0DMA)
 			max_count += device_tx_srv(priv, TYPE_AC0DMA);
 
-		if (priv->dwIsr & ISR_SOFTTIMER1) {
+		if (isr & ISR_SOFTTIMER1) {
 			if (priv->vif->bss_conf.enable_beacon)
 				vnt_beacon_make(priv, priv->vif);
 		}
@@ -1148,7 +1149,7 @@ static void vnt_interrupt_process(struct vnt_private *priv)
 		    ieee80211_queue_stopped(priv->hw, 0))
 			ieee80211_wake_queues(priv->hw);
 
-		MACvReadISR(priv->PortOffset, &priv->dwIsr);
+		MACvReadISR(priv->PortOffset, &isr);
 
 		MACvReceive0(priv->PortOffset);
 		MACvReceive1(priv->PortOffset);

commit 2995dfe68a0df4e6b4d27b02a600e9a928ce8175
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun May 31 10:35:26 2015 +0100

    staging: vt6655: vnt_interrupt_process remove camel case.
    
    pDevice -> priv
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 2262a61ccbfd..575ba87af75f 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1051,29 +1051,29 @@ static void vnt_check_bb_vga(struct vnt_private *priv)
 	}
 }
 
-static void vnt_interrupt_process(struct vnt_private *pDevice)
+static void vnt_interrupt_process(struct vnt_private *priv)
 {
-	struct ieee80211_low_level_stats *low_stats = &pDevice->low_stats;
+	struct ieee80211_low_level_stats *low_stats = &priv->low_stats;
 	int             max_count = 0;
 	u32 mib_counter;
 	unsigned long flags;
 
-	MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
+	MACvReadISR(priv->PortOffset, &priv->dwIsr);
 
-	if (pDevice->dwIsr == 0)
+	if (priv->dwIsr == 0)
 		return;
 
-	if (pDevice->dwIsr == 0xffffffff) {
+	if (priv->dwIsr == 0xffffffff) {
 		pr_debug("dwIsr = 0xffff\n");
 		return;
 	}
 
-	MACvIntDisable(pDevice->PortOffset);
+	MACvIntDisable(priv->PortOffset);
 
-	spin_lock_irqsave(&pDevice->lock, flags);
+	spin_lock_irqsave(&priv->lock, flags);
 
 	/* Read low level stats */
-	MACvReadMIBCounter(pDevice->PortOffset, &mib_counter);
+	MACvReadMIBCounter(priv->PortOffset, &mib_counter);
 
 	low_stats->dot11RTSSuccessCount += mib_counter & 0xff;
 	low_stats->dot11RTSFailureCount += (mib_counter >> 8) & 0xff;
@@ -1086,79 +1086,80 @@ static void vnt_interrupt_process(struct vnt_private *pDevice)
 	 * than RD/TD write back
 	 * update ISR counter
 	 */
-	while (pDevice->dwIsr && pDevice->vif) {
-		MACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);
+	while (priv->dwIsr && priv->vif) {
+		MACvWriteISR(priv->PortOffset, priv->dwIsr);
 
-		if (pDevice->dwIsr & ISR_FETALERR) {
+		if (priv->dwIsr & ISR_FETALERR) {
 			pr_debug(" ISR_FETALERR\n");
-			VNSvOutPortB(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, 0);
-			VNSvOutPortW(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, SOFTPWRCTL_SWPECTI);
-			device_error(pDevice, pDevice->dwIsr);
+			VNSvOutPortB(priv->PortOffset + MAC_REG_SOFTPWRCTL, 0);
+			VNSvOutPortW(priv->PortOffset +
+				     MAC_REG_SOFTPWRCTL, SOFTPWRCTL_SWPECTI);
+			device_error(priv, priv->dwIsr);
 		}
 
-		if (pDevice->dwIsr & ISR_TBTT) {
-			if (pDevice->op_mode != NL80211_IFTYPE_ADHOC)
-				vnt_check_bb_vga(pDevice);
+		if (priv->dwIsr & ISR_TBTT) {
+			if (priv->op_mode != NL80211_IFTYPE_ADHOC)
+				vnt_check_bb_vga(priv);
 
-			pDevice->bBeaconSent = false;
-			if (pDevice->bEnablePSMode)
-				PSbIsNextTBTTWakeUp((void *)pDevice);
+			priv->bBeaconSent = false;
+			if (priv->bEnablePSMode)
+				PSbIsNextTBTTWakeUp((void *)priv);
 
-			if ((pDevice->op_mode == NL80211_IFTYPE_AP ||
-			    pDevice->op_mode == NL80211_IFTYPE_ADHOC) &&
-			    pDevice->vif->bss_conf.enable_beacon) {
-				MACvOneShotTimer1MicroSec(pDevice->PortOffset,
-							  (pDevice->vif->bss_conf.beacon_int - MAKE_BEACON_RESERVED) << 10);
+			if ((priv->op_mode == NL80211_IFTYPE_AP ||
+			    priv->op_mode == NL80211_IFTYPE_ADHOC) &&
+			    priv->vif->bss_conf.enable_beacon) {
+				MACvOneShotTimer1MicroSec(priv->PortOffset,
+							  (priv->vif->bss_conf.beacon_int - MAKE_BEACON_RESERVED) << 10);
 			}
 
 			/* TODO: adhoc PS mode */
 
 		}
 
-		if (pDevice->dwIsr & ISR_BNTX) {
-			if (pDevice->op_mode == NL80211_IFTYPE_ADHOC) {
-				pDevice->bIsBeaconBufReadySet = false;
-				pDevice->cbBeaconBufReadySetCnt = 0;
+		if (priv->dwIsr & ISR_BNTX) {
+			if (priv->op_mode == NL80211_IFTYPE_ADHOC) {
+				priv->bIsBeaconBufReadySet = false;
+				priv->cbBeaconBufReadySetCnt = 0;
 			}
 
-			pDevice->bBeaconSent = true;
+			priv->bBeaconSent = true;
 		}
 
-		if (pDevice->dwIsr & ISR_RXDMA0)
-			max_count += device_rx_srv(pDevice, TYPE_RXDMA0);
+		if (priv->dwIsr & ISR_RXDMA0)
+			max_count += device_rx_srv(priv, TYPE_RXDMA0);
 
-		if (pDevice->dwIsr & ISR_RXDMA1)
-			max_count += device_rx_srv(pDevice, TYPE_RXDMA1);
+		if (priv->dwIsr & ISR_RXDMA1)
+			max_count += device_rx_srv(priv, TYPE_RXDMA1);
 
-		if (pDevice->dwIsr & ISR_TXDMA0)
-			max_count += device_tx_srv(pDevice, TYPE_TXDMA0);
+		if (priv->dwIsr & ISR_TXDMA0)
+			max_count += device_tx_srv(priv, TYPE_TXDMA0);
 
-		if (pDevice->dwIsr & ISR_AC0DMA)
-			max_count += device_tx_srv(pDevice, TYPE_AC0DMA);
+		if (priv->dwIsr & ISR_AC0DMA)
+			max_count += device_tx_srv(priv, TYPE_AC0DMA);
 
-		if (pDevice->dwIsr & ISR_SOFTTIMER1) {
-			if (pDevice->vif->bss_conf.enable_beacon)
-				vnt_beacon_make(pDevice, pDevice->vif);
+		if (priv->dwIsr & ISR_SOFTTIMER1) {
+			if (priv->vif->bss_conf.enable_beacon)
+				vnt_beacon_make(priv, priv->vif);
 		}
 
 		/* If both buffers available wake the queue */
-		if (AVAIL_TD(pDevice, TYPE_TXDMA0) &&
-		    AVAIL_TD(pDevice, TYPE_AC0DMA) &&
-		    ieee80211_queue_stopped(pDevice->hw, 0))
-			ieee80211_wake_queues(pDevice->hw);
+		if (AVAIL_TD(priv, TYPE_TXDMA0) &&
+		    AVAIL_TD(priv, TYPE_AC0DMA) &&
+		    ieee80211_queue_stopped(priv->hw, 0))
+			ieee80211_wake_queues(priv->hw);
 
-		MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
+		MACvReadISR(priv->PortOffset, &priv->dwIsr);
 
-		MACvReceive0(pDevice->PortOffset);
-		MACvReceive1(pDevice->PortOffset);
+		MACvReceive0(priv->PortOffset);
+		MACvReceive1(priv->PortOffset);
 
-		if (max_count > pDevice->sOpts.int_works)
+		if (max_count > priv->sOpts.int_works)
 			break;
 	}
 
-	spin_unlock_irqrestore(&pDevice->lock, flags);
+	spin_unlock_irqrestore(&priv->lock, flags);
 
-	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
+	MACvIntEnable(priv->PortOffset, IMR_MASK_VALUE);
 }
 
 static void vnt_interrupt_work(struct work_struct *work)

commit f33d8d63fc8e2e2f98abe78db85ace6d28209e3e
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun May 31 10:35:25 2015 +0100

    staging: vt6655: vnt_interrupt_process remove page 0 select
    
    Page 1 is fully proctected by lock there is no need
    to check for it. Page 0 is selected at other times.
    
    Remove byOrgPageSel and its calls from function.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index d5f090f8fa28..2262a61ccbfd 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1056,7 +1056,6 @@ static void vnt_interrupt_process(struct vnt_private *pDevice)
 	struct ieee80211_low_level_stats *low_stats = &pDevice->low_stats;
 	int             max_count = 0;
 	u32 mib_counter;
-	unsigned char byOrgPageSel = 0;
 	unsigned long flags;
 
 	MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
@@ -1073,13 +1072,6 @@ static void vnt_interrupt_process(struct vnt_private *pDevice)
 
 	spin_lock_irqsave(&pDevice->lock, flags);
 
-	/* Make sure current page is 0 */
-	VNSvInPortB(pDevice->PortOffset + MAC_REG_PAGE1SEL, &byOrgPageSel);
-	if (byOrgPageSel == 1)
-		MACvSelectPage0(pDevice->PortOffset);
-	else
-		byOrgPageSel = 0;
-
 	/* Read low level stats */
 	MACvReadMIBCounter(pDevice->PortOffset, &mib_counter);
 
@@ -1164,9 +1156,6 @@ static void vnt_interrupt_process(struct vnt_private *pDevice)
 			break;
 	}
 
-	if (byOrgPageSel == 1)
-		MACvSelectPage1(pDevice->PortOffset);
-
 	spin_unlock_irqrestore(&pDevice->lock, flags);
 
 	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);

commit ff1ce1a81e6eec82c224e33d3d23ab3f0002547e
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun May 31 10:35:24 2015 +0100

    staging: vt6655: use workqueue for interrupt handling
    
    Introduce vnt_interrupt to handle interrupt and use workqueue
    to queue and queue on vif.
    
    Convert device_intr to void call vnt_interrupt_process
    from vnt_interrupt_work providing vif is valid.
    
    This removes troublesome heavy code from the interupt handler and
    allows to remove atomic from other areas of driver.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 31f4ec7b8f47..d5f090f8fa28 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -32,7 +32,6 @@
  *   device_free_info - device structure resource free function
  *   device_get_pci_info - get allocated pci io/mem resource
  *   device_print_info - print out resource
- *   device_intr - interrupt handle function
  *   device_rx_srv - rx service function
  *   device_alloc_rx_buf - rx buffer pre-allocated function
  *   device_free_tx_buf - free tx buffer function
@@ -148,7 +147,6 @@ static void vt6655_init_info(struct pci_dev *pcid,
 static void device_free_info(struct vnt_private *pDevice);
 static bool device_get_pci_info(struct vnt_private *, struct pci_dev *pcid);
 static void device_print_info(struct vnt_private *pDevice);
-static  irqreturn_t  device_intr(int irq,  void *dev_instance);
 
 #ifdef CONFIG_PM
 static int device_notify_reboot(struct notifier_block *, unsigned long event, void *ptr);
@@ -1053,27 +1051,24 @@ static void vnt_check_bb_vga(struct vnt_private *priv)
 	}
 }
 
-static  irqreturn_t  device_intr(int irq,  void *dev_instance)
+static void vnt_interrupt_process(struct vnt_private *pDevice)
 {
-	struct vnt_private *pDevice = dev_instance;
 	struct ieee80211_low_level_stats *low_stats = &pDevice->low_stats;
 	int             max_count = 0;
 	u32 mib_counter;
 	unsigned char byOrgPageSel = 0;
-	int             handled = 0;
 	unsigned long flags;
 
 	MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
 
 	if (pDevice->dwIsr == 0)
-		return IRQ_RETVAL(handled);
+		return;
 
 	if (pDevice->dwIsr == 0xffffffff) {
 		pr_debug("dwIsr = 0xffff\n");
-		return IRQ_RETVAL(handled);
+		return;
 	}
 
-	handled = 1;
 	MACvIntDisable(pDevice->PortOffset);
 
 	spin_lock_irqsave(&pDevice->lock, flags);
@@ -1175,8 +1170,25 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 	spin_unlock_irqrestore(&pDevice->lock, flags);
 
 	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
+}
+
+static void vnt_interrupt_work(struct work_struct *work)
+{
+	struct vnt_private *priv =
+		container_of(work, struct vnt_private, interrupt_work);
+
+	if (priv->vif)
+		vnt_interrupt_process(priv);
+}
+
+static irqreturn_t vnt_interrupt(int irq,  void *arg)
+{
+	struct vnt_private *priv = arg;
 
-	return IRQ_RETVAL(handled);
+	if (priv->vif)
+		schedule_work(&priv->interrupt_work);
+
+	return IRQ_HANDLED;
 }
 
 static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
@@ -1268,7 +1280,7 @@ static int vnt_start(struct ieee80211_hw *hw)
 	if (!device_init_rings(priv))
 		return -ENOMEM;
 
-	ret = request_irq(priv->pcid->irq, &device_intr,
+	ret = request_irq(priv->pcid->irq, &vnt_interrupt,
 			  IRQF_SHARED, "vt6655", priv);
 	if (ret) {
 		dev_dbg(&priv->pcid->dev, "failed to start irq\n");
@@ -1297,6 +1309,8 @@ static void vnt_stop(struct ieee80211_hw *hw)
 
 	ieee80211_stop_queues(hw);
 
+	cancel_work_sync(&priv->interrupt_work);
+
 	MACbShutdown(priv->PortOffset);
 	MACbSoftwareReset(priv->PortOffset);
 	CARDbRadioPowerOff(priv);
@@ -1783,6 +1797,8 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 		return -ENODEV;
 	}
 
+	INIT_WORK(&priv->interrupt_work, vnt_interrupt_work);
+
 	/* do reset */
 	if (!MACbSoftwareReset(priv->PortOffset)) {
 		dev_err(&pcid->dev, ": Failed to access MAC hardware..\n");

commit 7e4786d1ab5835e7a132dfe1d0589ffe1a575bc9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun May 31 10:35:22 2015 +0100

    staging: vt6655: Remove call to STAvUpdateIsrStatCounter.
    
    This function does not provide any data to users.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c27f5ef7f0a2..31f4ec7b8f47 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1100,7 +1100,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 	 * update ISR counter
 	 */
 	while (pDevice->dwIsr && pDevice->vif) {
-		STAvUpdateIsrStatCounter(&pDevice->scStatistic, pDevice->dwIsr);
 		MACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);
 
 		if (pDevice->dwIsr & ISR_FETALERR) {

commit 700f6c02582ee43b09ea2ae9d619d652ca87a219
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun May 31 10:35:20 2015 +0100

    staging: vt6655: implement ieee80211_low_level_stats
    
    Collect low level stats from mib counter for mac80211 call.
    
    Replacing the unused function STAvUpdate802_11Counter.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 8f96cc93820a..c27f5ef7f0a2 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1056,8 +1056,9 @@ static void vnt_check_bb_vga(struct vnt_private *priv)
 static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 {
 	struct vnt_private *pDevice = dev_instance;
+	struct ieee80211_low_level_stats *low_stats = &pDevice->low_stats;
 	int             max_count = 0;
-	unsigned long dwMIBCounter = 0;
+	u32 mib_counter;
 	unsigned char byOrgPageSel = 0;
 	int             handled = 0;
 	unsigned long flags;
@@ -1084,14 +1085,20 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 	else
 		byOrgPageSel = 0;
 
-	MACvReadMIBCounter(pDevice->PortOffset, &dwMIBCounter);
+	/* Read low level stats */
+	MACvReadMIBCounter(pDevice->PortOffset, &mib_counter);
+
+	low_stats->dot11RTSSuccessCount += mib_counter & 0xff;
+	low_stats->dot11RTSFailureCount += (mib_counter >> 8) & 0xff;
+	low_stats->dot11ACKFailureCount += (mib_counter >> 16) & 0xff;
+	low_stats->dot11FCSErrorCount += (mib_counter >> 24) & 0xff;
+
 	/*
 	 * TBD....
 	 * Must do this after doing rx/tx, cause ISR bit is slow
 	 * than RD/TD write back
 	 * update ISR counter
 	 */
-	STAvUpdate802_11Counter(&pDevice->s802_11Counter, &pDevice->scStatistic, dwMIBCounter);
 	while (pDevice->dwIsr && pDevice->vif) {
 		STAvUpdateIsrStatCounter(&pDevice->scStatistic, pDevice->dwIsr);
 		MACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);
@@ -1604,6 +1611,16 @@ static int vnt_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
 	return 0;
 }
 
+static int vnt_get_stats(struct ieee80211_hw *hw,
+			 struct ieee80211_low_level_stats *stats)
+{
+	struct vnt_private *priv = hw->priv;
+
+	memcpy(stats, &priv->low_stats, sizeof(*stats));
+
+	return 0;
+}
+
 static u64 vnt_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	struct vnt_private *priv = hw->priv;
@@ -1641,6 +1658,7 @@ static const struct ieee80211_ops vnt_mac_ops = {
 	.prepare_multicast	= vnt_prepare_multicast,
 	.configure_filter	= vnt_configure,
 	.set_key		= vnt_set_key,
+	.get_stats		= vnt_get_stats,
 	.get_tsf		= vnt_get_tsf,
 	.set_tsf		= vnt_set_tsf,
 	.reset_tsf		= vnt_reset_tsf,

commit 36583eb54d46c36a447afd6c379839f292397429
Merge: fa7912be9671 cf539cbd8a81
Author: David S. Miller <davem@davemloft.net>
Date:   Sat May 23 01:22:35 2015 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/ethernet/cadence/macb.c
            drivers/net/phy/phy.c
            include/linux/skbuff.h
            net/ipv4/tcp.c
            net/switchdev/switchdev.c
    
    Switchdev was a case of RTNH_H_{EXTERNAL --> OFFLOAD}
    renaming overlapping with net-next changes of various
    sorts.
    
    phy.c was a case of two changes, one adding a local
    variable to a function whilst the second was removing
    one.
    
    tcp.c overlapped a deadlock fix with the addition of new tcp_info
    statistic values.
    
    macb.c involved the addition of two zyncq device entries.
    
    skbuff.h involved adding back ipv4_daddr to nf_bridge_info
    whilst net-next changes put two other existing members of
    that struct into a union.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 936a0cd52aa5d024c583e36e2f21bf6ec2e527e4
Merge: 36bf51acc89d e26081808eda
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 18 13:52:44 2015 -0700

    Merge 4.1-rc4 into staging-next
    
    We want the fixes in here for testing and merge issues.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 664a5c1d1e33cd89cb7883e8c74638cc482b5da7
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Tue Apr 21 22:33:02 2015 +0100

    staging: vt6655: lock MACvWriteBSSIDAddress.
    
    This function selects page 1 and cause intermittent problems on
    interrupt handler.
    
    lock call with spin_lock_irqsave.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: <stable@vger.kernel.org> # v3.19+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index b3860477eceb..0343ae386f03 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1417,9 +1417,16 @@ static void vnt_bss_info_changed(struct ieee80211_hw *hw,
 
 	priv->current_aid = conf->aid;
 
-	if (changed & BSS_CHANGED_BSSID)
+	if (changed & BSS_CHANGED_BSSID) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&priv->lock, flags);
+
 		MACvWriteBSSIDAddress(priv->PortOffset, (u8 *)conf->bssid);
 
+		spin_unlock_irqrestore(&priv->lock, flags);
+	}
+
 	if (changed & BSS_CHANGED_BASIC_RATES) {
 		priv->basic_rates = conf->basic_rates;
 

commit 032ed34a84263cdb396e4318fed6a92ed50add26
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Tue Apr 21 22:33:01 2015 +0100

    staging: vt6655: CARDbUpdateTSF bss timestamp correct tsf counter value.
    
    The TSF counter is not set correctly.
    
    Use sync_tsf for last beacon value and get tsf local value.
    
    Remove qwLocalTSF variable and call CARDbGetCurrentTSF.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 930bbbebc102..b3860477eceb 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1478,7 +1478,7 @@ static void vnt_bss_info_changed(struct ieee80211_hw *hw,
 	if (changed & BSS_CHANGED_ASSOC && priv->op_mode != NL80211_IFTYPE_AP) {
 		if (conf->assoc) {
 			CARDbUpdateTSF(priv, conf->beacon_rate->hw_value,
-				       conf->sync_device_ts, conf->sync_tsf);
+				       conf->sync_tsf);
 
 			CARDbSetBeaconPeriod(priv, conf->beacon_int);
 

commit d65d2b25d2761153390df8026cca1a528d9b6c5a
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Tue Apr 21 22:33:00 2015 +0100

    staging: vt6655: vnt_tx_packet Correct TX order of OWNED_BY_NIC
    
    The state of m_td0TD0.f1Owner should change after the buff_addr
    has been filled otherwise the device grabs the buffer too early.
    
    m_td0TD0.f1Owner is protected by memory barriers on both sides
    of change.
    
    iTDUsed is best incremented after MACvTransmit.
    
    It appears that f1Owner actually polls to do the memory transfer.
    
    A back port patch will be needed for v3.19
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: <stable@vger.kernel.org> # v4.0+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c81776363d8e..930bbbebc102 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1206,14 +1206,6 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 	if (dma_idx == TYPE_AC0DMA)
 		head_td->pTDInfo->byFlags = TD_FLAGS_NETIF_SKB;
 
-	priv->iTDUsed[dma_idx]++;
-
-	/* Take ownership */
-	wmb();
-	head_td->m_td0TD0.f1Owner = OWNED_BY_NIC;
-
-	/* get Next */
-	wmb();
 	priv->apCurrTD[dma_idx] = head_td->next;
 
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -1234,11 +1226,18 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	head_td->buff_addr = cpu_to_le32(head_td->pTDInfo->skb_dma);
 
+	/* Poll Transmit the adapter */
+	wmb();
+	head_td->m_td0TD0.f1Owner = OWNED_BY_NIC;
+	wmb(); /* second memory barrier */
+
 	if (head_td->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)
 		MACvTransmitAC0(priv->PortOffset);
 	else
 		MACvTransmit0(priv->PortOffset);
 
+	priv->iTDUsed[dma_idx]++;
+
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	return 0;

commit ad3fee9b17b90b8f1ac94b615111b2f14dd90adb
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Apr 11 20:29:41 2015 +0100

    staging: vt6655: Fix 80211 control and management status reporting.
    
    Currently only TD_FLAGS_NETIF_SKB are reported back to mac80211.
    
    Move vnt_int_report_rate to report all frame types.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: <stable@vger.kernel.org> # v3.19+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 6d3df9514088..c81776363d8e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -941,9 +941,6 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 		/* Only the status of first TD in the chain is correct */
 		if (pTD->m_td1TD1.byTCR & TCR_STP) {
 			if ((pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0) {
-
-				vnt_int_report_rate(pDevice, pTD->pTDInfo, byTsr0, byTsr1);
-
 				if (!(byTsr1 & TSR1_TERR)) {
 					if (byTsr0 != 0) {
 						pr_debug(" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X]\n",
@@ -962,6 +959,9 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 						 (int)uIdx, byTsr1, byTsr0);
 				}
 			}
+
+			vnt_int_report_rate(pDevice, pTD->pTDInfo, byTsr0, byTsr1);
+
 			device_free_tx_buf(pDevice, pTD);
 			pDevice->iTDUsed[uIdx]--;
 		}

commit 6e44dc4be009eef60a1744e4a4b830131f6b9a8e
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Apr 9 20:53:44 2015 +0100

    staging: vt6655: implement IEEE80211_TX_STAT_NOACK_TRANSMITTED
    
    Make use of this macro for non ack frames.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: <stable@vger.kernel.org> # v4.0
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 7cd548428a8f..6d3df9514088 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -912,7 +912,11 @@ static int vnt_int_report_rate(struct vnt_private *priv,
 
 	if (!(tsr1 & TSR1_TERR)) {
 		info->status.rates[0].idx = idx;
-		info->flags |= IEEE80211_TX_STAT_ACK;
+
+		if (info->flags & IEEE80211_TX_CTL_NO_ACK)
+			info->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;
+		else
+			info->flags |= IEEE80211_TX_STAT_ACK;
 	}
 
 	return 0;

commit 3fa0917beb29d886550fcf61a6378563d1ce9684
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Apr 9 20:53:43 2015 +0100

    staging: vt6655: device_free_tx_buf use only ieee80211_tx_status_irqsafe
    
    TD_FLAGS_NETIF_SKB is only for data.
    
    Fixes issue of ack frames not being reported.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: <stable@vger.kernel.org> # v3.19+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4bb4f8ee4132..7cd548428a8f 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -989,10 +989,8 @@ static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)
 				 skb->len, DMA_TO_DEVICE);
 	}
 
-	if (pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)
+	if (skb)
 		ieee80211_tx_status_irqsafe(pDevice->hw, skb);
-	else
-		dev_kfree_skb_irq(skb);
 
 	pTDInfo->skb_dma = 0;
 	pTDInfo->skb = NULL;

commit 32b249b0f54fb304c5f90be00ebcb9c1a32d415c
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Apr 6 21:19:48 2015 +0100

    staging: vt6655: device_intr check for vif on while loop
    
    vif should never be or go null while in loop.
    
    Fixes race condition where interrupts are late and when
    interface is not present.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4bb4f8ee4132..5b3de43bde99 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1090,7 +1090,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 	 * update ISR counter
 	 */
 	STAvUpdate802_11Counter(&pDevice->s802_11Counter, &pDevice->scStatistic, dwMIBCounter);
-	while (pDevice->dwIsr != 0) {
+	while (pDevice->dwIsr && pDevice->vif) {
 		STAvUpdateIsrStatCounter(&pDevice->scStatistic, pDevice->dwIsr);
 		MACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);
 
@@ -1102,8 +1102,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 		}
 
 		if (pDevice->dwIsr & ISR_TBTT) {
-			if (pDevice->vif &&
-			    pDevice->op_mode != NL80211_IFTYPE_ADHOC)
+			if (pDevice->op_mode != NL80211_IFTYPE_ADHOC)
 				vnt_check_bb_vga(pDevice);
 
 			pDevice->bBeaconSent = false;
@@ -1143,19 +1142,15 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 			max_count += device_tx_srv(pDevice, TYPE_AC0DMA);
 
 		if (pDevice->dwIsr & ISR_SOFTTIMER1) {
-			if (pDevice->vif) {
-				if (pDevice->vif->bss_conf.enable_beacon)
-					vnt_beacon_make(pDevice, pDevice->vif);
-			}
+			if (pDevice->vif->bss_conf.enable_beacon)
+				vnt_beacon_make(pDevice, pDevice->vif);
 		}
 
 		/* If both buffers available wake the queue */
-		if (pDevice->vif) {
-			if (AVAIL_TD(pDevice, TYPE_TXDMA0) &&
-			    AVAIL_TD(pDevice, TYPE_AC0DMA) &&
-			    ieee80211_queue_stopped(pDevice->hw, 0))
-				ieee80211_wake_queues(pDevice->hw);
-		}
+		if (AVAIL_TD(pDevice, TYPE_TXDMA0) &&
+		    AVAIL_TD(pDevice, TYPE_AC0DMA) &&
+		    ieee80211_queue_stopped(pDevice->hw, 0))
+			ieee80211_wake_queues(pDevice->hw);
 
 		MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
 

commit df1404650ccbfeb76a84f301f22316be0d00a864
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Apr 22 14:40:58 2015 +0200

    mac80211: remove support for IFF_PROMISC
    
    This support is essentially useless as typically networks are encrypted,
    frames will be filtered by hardware, and rate scaling will be done with
    the intended recipient in mind. For real monitoring of the network, the
    monitor mode support should be used instead.
    
    Removing it removes a lot of corner cases.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4bb4f8ee4132..6b2f813afb52 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1516,21 +1516,12 @@ static void vnt_configure(struct ieee80211_hw *hw,
 	struct vnt_private *priv = hw->priv;
 	u8 rx_mode = 0;
 
-	*total_flags &= FIF_ALLMULTI | FIF_OTHER_BSS | FIF_PROMISC_IN_BSS |
-		FIF_BCN_PRBRESP_PROMISC;
+	*total_flags &= FIF_ALLMULTI | FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC;
 
 	VNSvInPortB(priv->PortOffset + MAC_REG_RCR, &rx_mode);
 
 	dev_dbg(&priv->pcid->dev, "rx mode in = %x\n", rx_mode);
 
-	if (changed_flags & FIF_PROMISC_IN_BSS) {
-		/* unconditionally log net taps */
-		if (*total_flags & FIF_PROMISC_IN_BSS)
-			rx_mode |= RCR_UNICAST;
-		else
-			rx_mode &= ~RCR_UNICAST;
-	}
-
 	if (changed_flags & FIF_ALLMULTI) {
 		if (*total_flags & FIF_ALLMULTI) {
 			unsigned long flags;

commit 807dc0668e7af56a49cf360c2d12f9b04083ac47
Merge: 5e790610bc19 bc465aa9d045
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Mar 23 21:36:48 2015 +0100

    Merge 4.0-rc5 into staging-testing
    
    We want the staging tree fixes that are upstream here as well to prevent
    merge conflicts from people trying to clean up code.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a1c6dcda80f6dbb3e9b78809235695e8828994f9
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Thu Mar 19 14:18:56 2015 +0100

    staging: vt6655: remove deprecated use of pci api
    
    Replace occurences of the pci api by appropriate call to the dma api.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    )
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0204ea520385..e12caa8fbeb3 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -540,12 +540,12 @@ static bool device_init_rings(struct vnt_private *pDevice)
 	void *vir_pool;
 
 	/*allocate all RD/TD rings a single pool*/
-	vir_pool = pci_zalloc_consistent(pDevice->pcid,
+	vir_pool = dma_zalloc_coherent(&pDevice->pcid->dev,
 					 pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
 					 pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
 					 pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
 					 pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
-					 &pDevice->pool_dma);
+					 &pDevice->pool_dma, GFP_ATOMIC);
 	if (vir_pool == NULL) {
 		dev_err(&pDevice->pcid->dev, "allocate desc dma memory failed\n");
 		return false;
@@ -559,16 +559,17 @@ static bool device_init_rings(struct vnt_private *pDevice)
 	pDevice->rd1_pool_dma = pDevice->rd0_pool_dma +
 		pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
 
-	pDevice->tx0_bufs = pci_zalloc_consistent(pDevice->pcid,
+	pDevice->tx0_bufs = dma_zalloc_coherent(&pDevice->pcid->dev,
 						  pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
 						  pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
 						  CB_BEACON_BUF_SIZE +
 						  CB_MAX_BUF_SIZE,
-						  &pDevice->tx_bufs_dma0);
+						  &pDevice->tx_bufs_dma0,
+						  GFP_ATOMIC);
 	if (pDevice->tx0_bufs == NULL) {
 		dev_err(&pDevice->pcid->dev, "allocate buf dma memory failed\n");
 
-		pci_free_consistent(pDevice->pcid,
+		dma_free_coherent(&pDevice->pcid->dev,
 				    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
 				    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
 				    pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
@@ -614,7 +615,7 @@ static bool device_init_rings(struct vnt_private *pDevice)
 
 static void device_free_rings(struct vnt_private *pDevice)
 {
-	pci_free_consistent(pDevice->pcid,
+	dma_free_coherent(&pDevice->pcid->dev,
 			    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
 			    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
 			    pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
@@ -624,7 +625,7 @@ static void device_free_rings(struct vnt_private *pDevice)
 		);
 
 	if (pDevice->tx0_bufs)
-		pci_free_consistent(pDevice->pcid,
+		dma_free_coherent(&pDevice->pcid->dev,
 				    pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
 				    pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
 				    CB_BEACON_BUF_SIZE +
@@ -689,8 +690,8 @@ static void device_free_rd0_ring(struct vnt_private *pDevice)
 		PSRxDesc        pDesc = &(pDevice->aRD0Ring[i]);
 		PDEVICE_RD_INFO  pRDInfo = pDesc->pRDInfo;
 
-		pci_unmap_single(pDevice->pcid, pRDInfo->skb_dma,
-				 pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
+		dma_unmap_single(&pDevice->pcid->dev, pRDInfo->skb_dma,
+				 pDevice->rx_buf_sz, DMA_FROM_DEVICE);
 
 		dev_kfree_skb(pRDInfo->skb);
 
@@ -706,8 +707,8 @@ static void device_free_rd1_ring(struct vnt_private *pDevice)
 		PSRxDesc        pDesc = &(pDevice->aRD1Ring[i]);
 		PDEVICE_RD_INFO  pRDInfo = pDesc->pRDInfo;
 
-		pci_unmap_single(pDevice->pcid, pRDInfo->skb_dma,
-				 pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
+		dma_unmap_single(&pDevice->pcid->dev, pRDInfo->skb_dma,
+				 pDevice->rx_buf_sz, DMA_FROM_DEVICE);
 
 		dev_kfree_skb(pRDInfo->skb);
 
@@ -775,8 +776,8 @@ static void device_free_td0_ring(struct vnt_private *pDevice)
 		PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
 
 		if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma))
-			pci_unmap_single(pDevice->pcid, pTDInfo->skb_dma,
-					 pTDInfo->skb->len, PCI_DMA_TODEVICE);
+			dma_unmap_single(&pDevice->pcid->dev, pTDInfo->skb_dma,
+					 pTDInfo->skb->len, DMA_TO_DEVICE);
 
 		if (pTDInfo->skb)
 			dev_kfree_skb(pTDInfo->skb);
@@ -794,8 +795,8 @@ static void device_free_td1_ring(struct vnt_private *pDevice)
 		PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
 
 		if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma))
-			pci_unmap_single(pDevice->pcid, pTDInfo->skb_dma,
-					 pTDInfo->skb->len, PCI_DMA_TODEVICE);
+			dma_unmap_single(&pDevice->pcid->dev, pTDInfo->skb_dma,
+					 pTDInfo->skb->len, DMA_TO_DEVICE);
 
 		if (pTDInfo->skb)
 			dev_kfree_skb(pTDInfo->skb);
@@ -841,9 +842,9 @@ static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pRD)
 	ASSERT(pRDInfo->skb);
 
 	pRDInfo->skb_dma =
-		pci_map_single(pDevice->pcid,
+		dma_map_single(&pDevice->pcid->dev,
 			       skb_put(pRDInfo->skb, skb_tailroom(pRDInfo->skb)),
-			       pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
+			       pDevice->rx_buf_sz, DMA_FROM_DEVICE);
 
 	*((unsigned int *)&(pRD->m_rd0RD0)) = 0; /* FIX cast */
 
@@ -994,8 +995,8 @@ static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)
 
 	/* pre-allocated buf_dma can't be unmapped. */
 	if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma)) {
-		pci_unmap_single(pDevice->pcid, pTDInfo->skb_dma, skb->len,
-				 PCI_DMA_TODEVICE);
+		dma_unmap_single(&pDevice->pcid->dev, pTDInfo->skb_dma,
+				 skb->len, DMA_TO_DEVICE);
 	}
 
 	if (pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)

commit 1f51d5801859e0b382dcc8f06875811d63ec8953
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Mar 7 17:04:55 2015 +0000

    vt6655: Fix late setting of byRFType.
    
    byRFType is not set prior to registration of mac80211 causing
    unpredictable operation after channel scans.
    
    With byRFType unset all channels are enabled this causes tx power
    to be set to values not present its eeprom.
    
    Move setting of this variable to vt6655_probe.
    
    byRFType must have a mask set. byRevId not used by driver and
    is removed.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: <stable@vger.kernel.org> # v3.19+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f5c5872b587e..03b2a90b9ac0 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -330,16 +330,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 	/* zonetype initial */
 	pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
 
-	/* Get RFType */
-	pDevice->byRFType = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RFTYPE);
-
-	/* force change RevID for VT3253 emu */
-	if ((pDevice->byRFType & RF_EMU) != 0)
-			pDevice->byRevId = 0x80;
-
-	pDevice->byRFType &= RF_MASK;
-	pr_debug("pDevice->byRFType = %x\n", pDevice->byRFType);
-
 	if (!pDevice->bZoneRegExist)
 		pDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
 
@@ -1780,6 +1770,12 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	MACvInitialize(priv->PortOffset);
 	MACvReadEtherAddress(priv->PortOffset, priv->abyCurrentNetAddr);
 
+	/* Get RFType */
+	priv->byRFType = SROMbyReadEmbedded(priv->PortOffset, EEP_OFS_RFTYPE);
+	priv->byRFType &= RF_MASK;
+
+	dev_dbg(&pcid->dev, "RF Type = %x\n", priv->byRFType);
+
 	device_get_options(priv);
 	device_set_options(priv);
 	/* Mask out the options cannot be set to the chip */

commit c312530589ed9524fc7cc921105dc9b67ea32d6a
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Feb 9 19:11:33 2015 +0000

    staging: vt6655: vnt_tx_packet fix dma_idx selection.
    
    There is still a problem that dma_idx is causing packets to
    go onto the wrong tx path.
    
    Protect dma_idx fully with the present first lock and
    use pTDInfo->byFlags TD_FLAGS_NETIF_SKB to set MACvTransmit.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4324282afe49..f5c5872b587e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1187,12 +1187,14 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 {
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 	PSTxDesc head_td;
-	u32 dma_idx = TYPE_AC0DMA;
+	u32 dma_idx;
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->lock, flags);
 
-	if (!ieee80211_is_data(hdr->frame_control))
+	if (ieee80211_is_data(hdr->frame_control))
+		dma_idx = TYPE_AC0DMA;
+	else
 		dma_idx = TYPE_TXDMA0;
 
 	if (AVAIL_TD(priv, dma_idx) < 1) {
@@ -1206,6 +1208,9 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	head_td->pTDInfo->skb = skb;
 
+	if (dma_idx == TYPE_AC0DMA)
+		head_td->pTDInfo->byFlags = TD_FLAGS_NETIF_SKB;
+
 	priv->iTDUsed[dma_idx]++;
 
 	/* Take ownership */
@@ -1234,13 +1239,10 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	head_td->buff_addr = cpu_to_le32(head_td->pTDInfo->skb_dma);
 
-	if (dma_idx == TYPE_AC0DMA) {
-		head_td->pTDInfo->byFlags = TD_FLAGS_NETIF_SKB;
-
+	if (head_td->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)
 		MACvTransmitAC0(priv->PortOffset);
-	} else {
+	else
 		MACvTransmit0(priv->PortOffset);
-	}
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 

commit bb72dd53d7e5b8a13f5a2bbc1a3f0111fdc6450d
Author: Alex W Slater <alex.slater.dev@gmail.com>
Date:   Thu Feb 26 20:09:26 2015 +0000

    staging: vt6655: Cleanup C99 comments
    
    Fix checkpatch.pl errors:
    
    "ERROR: do not use C99 // comments"
    
    Signed-off-by: Alex W Slater <alex.slater.dev@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4324282afe49..0204ea520385 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -64,9 +64,9 @@
 #include <linux/slab.h>
 
 /*---------------------  Static Definitions -------------------------*/
-//
-// Define module options
-//
+/*
+ * Define module options
+ */
 MODULE_AUTHOR("VIA Networking Technologies, Inc., <lyndonchen@vntek.com.tw>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("VIA Networking Solomon-A/B/G Wireless LAN Adapter Driver");
@@ -126,9 +126,9 @@ DEVICE_PARAM(LongRetryLimit, "long frame retry limits");
 
 DEVICE_PARAM(BasebandType, "baseband type");
 
-//
-// Static vars definitions
-//
+/*
+ * Static vars definitions
+ */
 static CHIP_INFO chip_info_table[] = {
 	{ VT3253,       "VIA Networking Solomon-A/B/G Wireless LAN Adapter ",
 	  256, 1,     DEVICE_FLAGS_IP_ALIGN|DEVICE_FLAGS_TX_ALIGN },
@@ -231,9 +231,9 @@ device_set_options(struct vnt_private *pDevice)
 	pr_debug(" byBBType= %d\n", (int)pDevice->byBBType);
 }
 
-//
-// Initialisation of MAC & BBP registers
-//
+/*
+ * Initialisation of MAC & BBP registers
+ */
 
 static void device_init_registers(struct vnt_private *pDevice)
 {
@@ -584,7 +584,7 @@ static bool device_init_rings(struct vnt_private *pDevice)
 	pDevice->td1_pool_dma = pDevice->td0_pool_dma +
 		pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);
 
-	// vir_pool: pvoid type
+	/* vir_pool: pvoid type */
 	pDevice->apTD0Rings = vir_pool
 		+ pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)
 		+ pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);
@@ -943,7 +943,7 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 		byTsr0 = pTD->m_td0TD0.byTSR0;
 		byTsr1 = pTD->m_td0TD0.byTSR1;
 
-		//Only the status of first TD in the chain is correct
+		/* Only the status of first TD in the chain is correct */
 		if (pTD->m_td1TD1.byTCR & TCR_STP) {
 			if ((pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0) {
 
@@ -992,7 +992,7 @@ static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)
 	PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
 	struct sk_buff *skb = pTDInfo->skb;
 
-	// pre-allocated buf_dma can't be unmapped.
+	/* pre-allocated buf_dma can't be unmapped. */
 	if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma)) {
 		pci_unmap_single(pDevice->pcid, pTDInfo->skb_dma, skb->len,
 				 PCI_DMA_TODEVICE);
@@ -1084,7 +1084,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 
 	spin_lock_irqsave(&pDevice->lock, flags);
 
-	//Make sure current page is 0
+	/* Make sure current page is 0 */
 	VNSvInPortB(pDevice->PortOffset + MAC_REG_PAGE1SEL, &byOrgPageSel);
 	if (byOrgPageSel == 1)
 		MACvSelectPage0(pDevice->PortOffset);
@@ -1092,10 +1092,12 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 		byOrgPageSel = 0;
 
 	MACvReadMIBCounter(pDevice->PortOffset, &dwMIBCounter);
-	// TBD....
-	// Must do this after doing rx/tx, cause ISR bit is slow
-	// than RD/TD write back
-	// update ISR counter
+	/*
+	 * TBD....
+	 * Must do this after doing rx/tx, cause ISR bit is slow
+	 * than RD/TD write back
+	 * update ISR counter
+	 */
 	STAvUpdate802_11Counter(&pDevice->s802_11Counter, &pDevice->scStatistic, dwMIBCounter);
 	while (pDevice->dwIsr != 0) {
 		STAvUpdateIsrStatCounter(&pDevice->scStatistic, pDevice->dwIsr);

commit d17f4c8a42256dae6aa598bdbc00eff8b38cc949
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Feb 1 11:59:40 2015 +0000

    staging: vt6655: Fix TD_FLAGS_NETIF_SKB only on TYPE_AC0DMA
    
    Allow only TD_FLAGS_NETIF_SKB on ring buffer TYPE_AC0DMA for data
    only transfers for correct reporting of tx rates.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 870cafd62ded..4324282afe49 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1234,12 +1234,13 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	head_td->buff_addr = cpu_to_le32(head_td->pTDInfo->skb_dma);
 
-	head_td->pTDInfo->byFlags = TD_FLAGS_NETIF_SKB;
+	if (dma_idx == TYPE_AC0DMA) {
+		head_td->pTDInfo->byFlags = TD_FLAGS_NETIF_SKB;
 
-	if (dma_idx == TYPE_AC0DMA)
 		MACvTransmitAC0(priv->PortOffset);
-	else
+	} else {
 		MACvTransmit0(priv->PortOffset);
+	}
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 

commit 64e4fd51421ffe750ea483f32370f60ca8435657
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Feb 1 11:59:39 2015 +0000

    staging: vt6655: parse bb vga code out of device_intr.
    
    Reordering the code and reversing the priv->byBBVGANew verses
    priv->byBBVGACurrent check and using dev_dbg for pr_debug.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 9a801440d602..870cafd62ded 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1008,6 +1008,58 @@ static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)
 	pTDInfo->byFlags = 0;
 }
 
+static void vnt_check_bb_vga(struct vnt_private *priv)
+{
+	long dbm;
+	int i;
+
+	if (!priv->bUpdateBBVGA)
+		return;
+
+	if (priv->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL)
+		return;
+
+	if (!(priv->vif->bss_conf.assoc && priv->uCurrRSSI))
+		return;
+
+	RFvRSSITodBm(priv, (u8)priv->uCurrRSSI, &dbm);
+
+	for (i = 0; i < BB_VGA_LEVEL; i++) {
+		if (dbm < priv->ldBmThreshold[i]) {
+			priv->byBBVGANew = priv->abyBBVGA[i];
+			break;
+		}
+	}
+
+	if (priv->byBBVGANew == priv->byBBVGACurrent) {
+		priv->uBBVGADiffCount = 1;
+		return;
+	}
+
+	priv->uBBVGADiffCount++;
+
+	if (priv->uBBVGADiffCount == 1) {
+		/* first VGA diff gain */
+		BBvSetVGAGainOffset(priv, priv->byBBVGANew);
+
+		dev_dbg(&priv->pcid->dev,
+			"First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
+			(int)dbm, priv->byBBVGANew,
+			priv->byBBVGACurrent,
+			(int)priv->uBBVGADiffCount);
+	}
+
+	if (priv->uBBVGADiffCount >= BB_VGA_CHANGE_THRESHOLD) {
+		dev_dbg(&priv->pcid->dev,
+			"RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
+			(int)dbm, priv->byBBVGANew,
+			priv->byBBVGACurrent,
+			(int)priv->uBBVGADiffCount);
+
+		BBvSetVGAGainOffset(priv, priv->byBBVGANew);
+	}
+}
+
 static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 {
 	struct vnt_private *pDevice = dev_instance;
@@ -1015,7 +1067,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 	unsigned long dwMIBCounter = 0;
 	unsigned char byOrgPageSel = 0;
 	int             handled = 0;
-	int             ii = 0;
 	unsigned long flags;
 
 	MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
@@ -1059,44 +1110,8 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 
 		if (pDevice->dwIsr & ISR_TBTT) {
 			if (pDevice->vif &&
-			    pDevice->op_mode != NL80211_IFTYPE_ADHOC) {
-				if (pDevice->bUpdateBBVGA &&
-				    !(pDevice->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL) &&
-				    pDevice->vif->bss_conf.assoc &&
-				    pDevice->uCurrRSSI) {
-					long            ldBm;
-
-					RFvRSSITodBm(pDevice, (unsigned char) pDevice->uCurrRSSI, &ldBm);
-					for (ii = 0; ii < BB_VGA_LEVEL; ii++) {
-						if (ldBm < pDevice->ldBmThreshold[ii]) {
-							pDevice->byBBVGANew = pDevice->abyBBVGA[ii];
-							break;
-						}
-					}
-					if (pDevice->byBBVGANew != pDevice->byBBVGACurrent) {
-						pDevice->uBBVGADiffCount++;
-						if (pDevice->uBBVGADiffCount == 1) {
-							// first VGA diff gain
-							BBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);
-							pr_debug("First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
-								 (int)ldBm,
-								 pDevice->byBBVGANew,
-								 pDevice->byBBVGACurrent,
-								 (int)pDevice->uBBVGADiffCount);
-						}
-						if (pDevice->uBBVGADiffCount >= BB_VGA_CHANGE_THRESHOLD) {
-							pr_debug("RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
-								 (int)ldBm,
-								 pDevice->byBBVGANew,
-								 pDevice->byBBVGACurrent,
-								 (int)pDevice->uBBVGADiffCount);
-							BBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);
-						}
-					} else {
-						pDevice->uBBVGADiffCount = 1;
-					}
-				}
-			}
+			    pDevice->op_mode != NL80211_IFTYPE_ADHOC)
+				vnt_check_bb_vga(pDevice);
 
 			pDevice->bBeaconSent = false;
 			if (pDevice->bEnablePSMode)

commit 187e2a81805f4b7ba1acf118aed8937a718d894c
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Feb 1 11:59:38 2015 +0000

    staging: vt6655: move setting of PSTxDesc->buff_addr to vnt_tx_packet
    
    Keep setting of this part of the structure with the others.
    
    Only pTDInfo needs carried in the buffer structure.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 58559fae7cf1..9a801440d602 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1217,6 +1217,8 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 	head_td->m_td1TD1.wReqCount =
 			cpu_to_le16((u16)head_td->pTDInfo->dwReqCount);
 
+	head_td->buff_addr = cpu_to_le32(head_td->pTDInfo->skb_dma);
+
 	head_td->pTDInfo->byFlags = TD_FLAGS_NETIF_SKB;
 
 	if (dma_idx == TYPE_AC0DMA)

commit 918185f6662379f570e29c86c0229d8036ef4fa7
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Jan 19 18:24:13 2015 +0000

    staging: vt6655: device_init_registers alway set initial antenna mode
    
    BBvSetTxAntennaMode and BBvSetRxAntennaMode need to be set correcty
    on start up
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0408e912dee4..58559fae7cf1 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -323,6 +323,10 @@ static void device_init_registers(struct vnt_private *pDevice)
 		}
 	}
 
+	/* Set initial antenna mode */
+	BBvSetTxAntennaMode(pDevice, pDevice->byTxAntennaMode);
+	BBvSetRxAntennaMode(pDevice, pDevice->byRxAntennaMode);
+
 	/* zonetype initial */
 	pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
 

commit e6f534bc2fbda029ddc43d816151893454224e52
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Jan 19 18:24:12 2015 +0000

    staging: vt6655: remove antenna diversity functions
    
    The vendor had disabled these functions in their last version.
    
    On test this can be troublesome, so remove this from the driver along
    with its macros and timers.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 05be34b62f74..0408e912dee4 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -126,10 +126,6 @@ DEVICE_PARAM(LongRetryLimit, "long frame retry limits");
 
 DEVICE_PARAM(BasebandType, "baseband type");
 
-#define DIVERSITY_ANT_DEF     0
-
-DEVICE_PARAM(bDiversityANTEnable, "ANT diversity mode");
-
 //
 // Static vars definitions
 //
@@ -152,7 +148,6 @@ static void vt6655_init_info(struct pci_dev *pcid,
 static void device_free_info(struct vnt_private *pDevice);
 static bool device_get_pci_info(struct vnt_private *, struct pci_dev *pcid);
 static void device_print_info(struct vnt_private *pDevice);
-static void device_init_diversity_timer(struct vnt_private *pDevice);
 static  irqreturn_t  device_intr(int irq,  void *dev_instance);
 
 #ifdef CONFIG_PM
@@ -216,7 +211,6 @@ static void device_get_options(struct vnt_private *pDevice)
 	pOpts->short_retry = SHORT_RETRY_DEF;
 	pOpts->long_retry = LONG_RETRY_DEF;
 	pOpts->bbp_type = BBP_TYPE_DEF;
-	pOpts->flags |= DEVICE_FLAGS_DiversityANT;
 }
 
 static void
@@ -224,7 +218,6 @@ device_set_options(struct vnt_private *pDevice)
 {
 	pDevice->byShortRetryLimit = pDevice->sOpts.short_retry;
 	pDevice->byLongRetryLimit = pDevice->sOpts.long_retry;
-	pDevice->bDiversityRegCtlON = (pDevice->sOpts.flags & DEVICE_FLAGS_DiversityANT) ? 1 : 0;
 	pDevice->byBBType = pDevice->sOpts.bbp_type;
 	pDevice->byPacketType = pDevice->byBBType;
 	pDevice->byAutoFBCtrl = AUTO_FB_0;
@@ -236,8 +229,6 @@ device_set_options(struct vnt_private *pDevice)
 	pr_debug(" byPreambleType= %d\n", (int)pDevice->byPreambleType);
 	pr_debug(" byShortPreamble= %d\n", (int)pDevice->byShortPreamble);
 	pr_debug(" byBBType= %d\n", (int)pDevice->byBBType);
-	pr_debug(" pDevice->bDiversityRegCtlON= %d\n",
-		 (int)pDevice->bDiversityRegCtlON);
 }
 
 //
@@ -249,7 +240,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 	unsigned long flags;
 	unsigned int ii;
 	unsigned char byValue;
-	unsigned char byValue1;
 	unsigned char byCCKPwrdBm = 0;
 	unsigned char byOFDMPwrdBm = 0;
 
@@ -301,13 +291,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 	if (byValue == 0)
 		byValue = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
 
-	pDevice->ulDiversityNValue = 100*260;
-	pDevice->ulDiversityMValue = 100*16;
-	pDevice->byTMax = 1;
-	pDevice->byTMax2 = 4;
-	pDevice->ulSQ3TH = 0;
-	pDevice->byTMax3 = 64;
-
 	if (byValue == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {
 		pDevice->byAntennaCount = 2;
 		pDevice->byTxAntennaMode = ANT_B;
@@ -318,16 +301,7 @@ static void device_init_registers(struct vnt_private *pDevice)
 			pDevice->byRxAntennaMode = ANT_A;
 		else
 			pDevice->byRxAntennaMode = ANT_B;
-
-		byValue1 = SROMbyReadEmbedded(pDevice->PortOffset,
-					      EEP_OFS_ANTENNA);
-
-		if ((byValue1 & 0x08) == 0)
-			pDevice->bDiversityEnable = false;
-		else
-			pDevice->bDiversityEnable = true;
 	} else  {
-		pDevice->bDiversityEnable = false;
 		pDevice->byAntennaCount = 1;
 		pDevice->dwTxAntennaSel = 0;
 		pDevice->dwRxAntennaSel = 0;
@@ -349,11 +323,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 		}
 	}
 
-	pr_debug("bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",
-		 pDevice->bDiversityEnable, (int)pDevice->ulDiversityNValue,
-		 (int)pDevice->ulDiversityMValue, pDevice->byTMax,
-		 pDevice->byTMax2);
-
 	/* zonetype initial */
 	pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
 
@@ -493,24 +462,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 	MACvStart(pDevice->PortOffset);
 }
 
-static void device_init_diversity_timer(struct vnt_private *pDevice)
-{
-	init_timer(&pDevice->TimerSQ3Tmax1);
-	pDevice->TimerSQ3Tmax1.data = (unsigned long) pDevice;
-	pDevice->TimerSQ3Tmax1.function = TimerSQ3CallBack;
-	pDevice->TimerSQ3Tmax1.expires = RUN_AT(HZ);
-
-	init_timer(&pDevice->TimerSQ3Tmax2);
-	pDevice->TimerSQ3Tmax2.data = (unsigned long) pDevice;
-	pDevice->TimerSQ3Tmax2.function = TimerSQ3CallBack;
-	pDevice->TimerSQ3Tmax2.expires = RUN_AT(HZ);
-
-	init_timer(&pDevice->TimerSQ3Tmax3);
-	pDevice->TimerSQ3Tmax3.data = (unsigned long) pDevice;
-	pDevice->TimerSQ3Tmax3.function = TimerState1CallBack;
-	pDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);
-}
-
 static void device_print_info(struct vnt_private *pDevice)
 {
 	dev_info(&pDevice->pcid->dev, "%s\n", get_chip_name(pDevice->chip_id));
@@ -1348,8 +1299,6 @@ static int vnt_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
 	switch (vif->type) {
 	case NL80211_IFTYPE_STATION:
-		if (priv->bDiversityRegCtlON)
-			device_init_diversity_timer(priv);
 		break;
 	case NL80211_IFTYPE_ADHOC:
 		MACvRegBitsOff(priv->PortOffset, MAC_REG_RCR, RCR_UNICAST);
@@ -1379,11 +1328,6 @@ static void vnt_remove_interface(struct ieee80211_hw *hw,
 
 	switch (vif->type) {
 	case NL80211_IFTYPE_STATION:
-		if (priv->bDiversityRegCtlON) {
-			del_timer(&priv->TimerSQ3Tmax1);
-			del_timer(&priv->TimerSQ3Tmax2);
-			del_timer(&priv->TimerSQ3Tmax3);
-		}
 		break;
 	case NL80211_IFTYPE_ADHOC:
 		MACvRegBitsOff(priv->PortOffset, MAC_REG_TCR, TCR_AUTOBCNTX);

commit d7a4cfa8c18c5622da0bf87661963e13cc3de9b0
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Jan 19 18:24:10 2015 +0000

    staging: vt6655: set_channel replace parameter with ieee80211_channel
    
    replacing uConnectionChannel for hw_value as set in vnt_init_bands.
    
    This allows other signaling of ieee80211_channel to move deeper into
    driver.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index e5ed9e6a2e66..05be34b62f74 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1420,7 +1420,7 @@ static int vnt_config(struct ieee80211_hw *hw, u32 changed)
 
 	if ((changed & IEEE80211_CONF_CHANGE_CHANNEL) ||
 	    (conf->flags & IEEE80211_CONF_OFFCHANNEL)) {
-		set_channel(priv, conf->chandef.chan->hw_value);
+		set_channel(priv, conf->chandef.chan);
 
 		if (conf->chandef.chan->band == IEEE80211_BAND_5GHZ)
 			bb_type = BB_TYPE_11A;

commit 2a0a7b3dfa888bf578486e352efd7eb5ce4aed87
Author: Ahmad Hassan <ahmad.hassan612@gmail.com>
Date:   Mon Jan 19 13:13:58 2015 -0900

    staging: vt6655: fix space prohibted before that ','
    
    This patch fixes the following checkpatch.pl error:
    fix space prohibited before that ','
    
    Signed-off-by: Ahmad Hassan <ahmad.hassan612@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c755ec22e440..e5ed9e6a2e66 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1090,7 +1090,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 	// Must do this after doing rx/tx, cause ISR bit is slow
 	// than RD/TD write back
 	// update ISR counter
-	STAvUpdate802_11Counter(&pDevice->s802_11Counter, &pDevice->scStatistic , dwMIBCounter);
+	STAvUpdate802_11Counter(&pDevice->s802_11Counter, &pDevice->scStatistic, dwMIBCounter);
 	while (pDevice->dwIsr != 0) {
 		STAvUpdateIsrStatCounter(&pDevice->scStatistic, pDevice->dwIsr);
 		MACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);

commit 484c60e206b03fe19129dc6ec4582142293cd876
Merge: 06d30f020857 ec6f34e5b552
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 19 10:59:48 2015 +0800

    Merge 3.19-rc5 into staging-next
    
    We want the staging fixes in this branch as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b5745290af06a621aaddfd636bab4f08432d0492
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Dec 21 12:56:34 2014 +0000

    staging: vt6655: vnt_tx_packet Fix corrupted tx packets.
    
    Move PSTxDesc->m_td1TD1 to inside spin locks.
    
    if m_td1TD1.byTCR has TCR_EDP and TCR_STP are set, the interrupt handler will
    try and complete the buffer before it is completed. Usually on the tail
    of a burst of tx packets.
    
    This results in a partially completed packet being transmitted or worse
    sitll dead lock when skb is freed by the interrupt handler.
    
    Set head_td->m_td1TD1.byTCR to 0 in first lock of vnt_tx_packet to stop
    interrupt handler completing the buffer. Move Set TSR1 & ReqCount in
    s_cbFillTxBufHead to the second lock.
    
    cbReqCount is carried to the second lock in pTDInfo->dwReqCount without
    the padding removed.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ce616f98b8cb..cd1a277d853b 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1232,7 +1232,7 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	head_td = priv->apCurrTD[dma_idx];
 
-	head_td->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
+	head_td->m_td1TD1.byTCR = 0;
 
 	head_td->pTDInfo->skb = skb;
 
@@ -1257,6 +1257,11 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	priv->bPWBitOn = false;
 
+	/* Set TSR1 & ReqCount in TxDescHead */
+	head_td->m_td1TD1.byTCR |= (TCR_STP | TCR_EDP | EDMSDU);
+	head_td->m_td1TD1.wReqCount =
+			cpu_to_le16((u16)head_td->pTDInfo->dwReqCount);
+
 	head_td->pTDInfo->byFlags = TD_FLAGS_NETIF_SKB;
 
 	if (dma_idx == TYPE_AC0DMA)

commit 84c00afef41a2172b7290f3d75e082e6dd609a58
Author: Mike Krinkin <krinkin.m.u@gmail.com>
Date:   Sun Dec 21 16:56:47 2014 +0300

    staging: vt6655: fix sparse warnings: incorrect argument type
    
    this patch fixes following sparse warnings:
    
    drivers/staging/vt6655/device_main.c:1503:25: warning: incorrect type in argument 1 (different address spaces)
    drivers/staging/vt6655/device_main.c:1503:25:    expected void [noderef] <asn:2>*<noident>
    drivers/staging/vt6655/device_main.c:1503:25:    got struct vnt_private *
    drivers/staging/vt6655/device_main.c:1503:25: warning: incorrect type in argument 2 (different address spaces)
    drivers/staging/vt6655/device_main.c:1503:25:    expected void [noderef] <asn:2>*<noident>
    drivers/staging/vt6655/device_main.c:1503:25:    got struct vnt_private *
    drivers/staging/vt6655/device_main.c:1505:25: warning: incorrect type in argument 1 (different address spaces)
    drivers/staging/vt6655/device_main.c:1505:25:    expected void [noderef] <asn:2>*<noident>
    drivers/staging/vt6655/device_main.c:1505:25:    got struct vnt_private *
    drivers/staging/vt6655/device_main.c:1505:25: warning: incorrect type in argument 2 (different address spaces)
    drivers/staging/vt6655/device_main.c:1505:25:    expected void [noderef] <asn:2>*<noident>
    drivers/staging/vt6655/device_main.c:1505:25:    got struct vnt_private *
    
    Signed-off-by: Mike Krinkin <krinkin.m.u@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 83e4162c0094..ce616f98b8cb 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1500,9 +1500,11 @@ static void vnt_bss_info_changed(struct ieee80211_hw *hw,
 		if (conf->enable_beacon) {
 			vnt_beacon_enable(priv, vif, conf);
 
-			MACvRegBitsOn(priv, MAC_REG_TCR, TCR_AUTOBCNTX);
+			MACvRegBitsOn(priv->PortOffset, MAC_REG_TCR,
+				      TCR_AUTOBCNTX);
 		} else {
-			MACvRegBitsOff(priv, MAC_REG_TCR, TCR_AUTOBCNTX);
+			MACvRegBitsOff(priv->PortOffset, MAC_REG_TCR,
+				       TCR_AUTOBCNTX);
 		}
 	}
 

commit 95775d12219285d6e0116acb6267864582cd01ef
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jan 11 10:26:12 2015 +0000

    staging: vt6655: [BUG] Protect MACvSelectPage1 with lock.
    
    The device must not flip to page 1 while in interrupt lock causing
    loss of connection or dead lock.
    
    Protect from changes to page by adding lock where user can
    change the page in CARDvSetRSPINF, vnt_configure and set_channel
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index a3f5cd84259a..f5cc78e8254c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1565,6 +1565,10 @@ static void vnt_configure(struct ieee80211_hw *hw,
 
 	if (changed_flags & FIF_ALLMULTI) {
 		if (*total_flags & FIF_ALLMULTI) {
+			unsigned long flags;
+
+			spin_lock_irqsave(&priv->lock, flags);
+
 			if (priv->mc_list_count > 2) {
 				MACvSelectPage1(priv->PortOffset);
 
@@ -1586,6 +1590,8 @@ static void vnt_configure(struct ieee80211_hw *hw,
 				MACvSelectPage0(priv->PortOffset);
 			}
 
+			spin_unlock_irqrestore(&priv->lock, flags);
+
 			rx_mode |= RCR_MULTICAST | RCR_BROADCAST;
 		} else {
 			rx_mode &= ~(RCR_MULTICAST | RCR_BROADCAST);

commit b7c9cd450baed139ed07c997071ec5b3164ee1c4
Author: Sren Brinkmann <soeren.brinkmann@gmail.com>
Date:   Thu Dec 4 20:33:41 2014 -0800

    staging: vt6655: Declare vnt_init() static
    
    Fix sparse warning:
      drivers/staging/vt6655/device_main.c:1672:5: warning: symbol 'vnt_init' was not declared. Should it be static?
    
    Signed-off-by: Sren Brinkmann <soeren.brinkmann@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 83e4162c0094..a3f5cd84259a 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1669,7 +1669,7 @@ static const struct ieee80211_ops vnt_mac_ops = {
 	.reset_tsf		= vnt_reset_tsf,
 };
 
-int vnt_init(struct vnt_private *priv)
+static int vnt_init(struct vnt_private *priv)
 {
 	SET_IEEE80211_PERM_ADDR(priv->hw, priv->abyCurrentNetAddr);
 

commit 738487ffc53d9f3e9a2564551fc877f9d377d11f
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Nov 12 21:11:09 2014 +0000

    staging: vt6655: card.c move __iomem into functions.
    
    Removing dereferencing from callers
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 13923326a34a..83e4162c0094 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1513,8 +1513,7 @@ static void vnt_bss_info_changed(struct ieee80211_hw *hw,
 
 			CARDbSetBeaconPeriod(priv, conf->beacon_int);
 
-			CARDvSetFirstNextTBTT(priv->PortOffset,
-					      conf->beacon_int);
+			CARDvSetFirstNextTBTT(priv, conf->beacon_int);
 		} else {
 			VNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL,
 				     TFTCTL_TSFCNTRST);
@@ -1633,7 +1632,7 @@ static u64 vnt_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	struct vnt_private *priv = hw->priv;
 	u64 tsf;
 
-	CARDbGetCurrentTSF(priv->PortOffset, &tsf);
+	CARDbGetCurrentTSF(priv, &tsf);
 
 	return tsf;
 }
@@ -1643,7 +1642,7 @@ static void vnt_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 {
 	struct vnt_private *priv = hw->priv;
 
-	CARDvUpdateNextTBTT(priv->PortOffset, tsf, vif->bss_conf.beacon_int);
+	CARDvUpdateNextTBTT(priv, tsf, vif->bss_conf.beacon_int);
 }
 
 static void vnt_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)

commit 6d35b1fcaa403aedc37e0ff17baf8c4f2ae07ed8
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Nov 12 21:11:08 2014 +0000

    staging: vt6655: card Remove function vUpdateIFS
    
    vUpdateIFS does the same operations of CARDbSetPhyParameter there
    is not need to call this function.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 2e3178429437..13923326a34a 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1485,7 +1485,6 @@ static void vnt_bss_info_changed(struct ieee80211_hw *hw,
 		else
 			priv->bShortSlotTime = false;
 
-		vUpdateIFS(priv);
 		CARDbSetPhyParameter(priv, priv->byBBType);
 		BBvSetVGAGainOffset(priv, priv->abyBBVGA[0]);
 	}

commit bf8918de79b98f647bb2927b5935de09ed091b12
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri Nov 7 19:06:08 2014 +0000

    staging: vt6655: change typedef enum _VIA_PKT_TYPE to macro
    
    Replacing for u8 type and removing cast for byBBType.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 22a55f4a9962..2e3178429437 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -226,7 +226,7 @@ device_set_options(struct vnt_private *pDevice)
 	pDevice->byLongRetryLimit = pDevice->sOpts.long_retry;
 	pDevice->bDiversityRegCtlON = (pDevice->sOpts.flags & DEVICE_FLAGS_DiversityANT) ? 1 : 0;
 	pDevice->byBBType = pDevice->sOpts.bbp_type;
-	pDevice->byPacketType = (VIA_PKT_TYPE)pDevice->byBBType;
+	pDevice->byPacketType = pDevice->byBBType;
 	pDevice->byAutoFBCtrl = AUTO_FB_0;
 	pDevice->bUpdateBBVGA = true;
 	pDevice->byPreambleType = 0;

commit bfb6c8637640cd6d2fb3f06d056769654c2f7e86
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri Nov 7 19:06:06 2014 +0000

    staging: vt6655: CARDbSetPhyParameter remove unused parameters
    
    wCapInfo
    byERPField,
    *pvSupportRateIEs
    *pvExtSupportRateIEs
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 397f13f10c1a..22a55f4a9962 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1425,8 +1425,7 @@ static int vnt_config(struct ieee80211_hw *hw, u32 changed)
 		if (priv->byBBType != bb_type) {
 			priv->byBBType = bb_type;
 
-			CARDbSetPhyParameter(priv,
-					     priv->byBBType, 0, 0, NULL, NULL);
+			CARDbSetPhyParameter(priv, priv->byBBType);
 		}
 	}
 
@@ -1487,7 +1486,7 @@ static void vnt_bss_info_changed(struct ieee80211_hw *hw,
 			priv->bShortSlotTime = false;
 
 		vUpdateIFS(priv);
-		CARDbSetPhyParameter(priv, priv->byBBType, 0, 0, NULL, NULL);
+		CARDbSetPhyParameter(priv, priv->byBBType);
 		BBvSetVGAGainOffset(priv, priv->abyBBVGA[0]);
 	}
 

commit a5f0eef38b574248119353667eeee69559b9c291
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Nov 6 20:02:01 2014 +0000

    staging: vt6655: baseband replace __iomem where caller is priv dereferenced.
    
    Replace with stucture vnt_private *priv
    
    in functions
    BBvSoftwareReset
    BBvSetTxAntennaMode
    BBvSetRxAntennaMode
    BBvSetDeepSleep
    BBvExitDeepSleep
    
    __iomem *dwIoBase will be moved into BBbWriteEmbedded and BBbReadEmbedded
    later.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 5fc6022badb2..397f13f10c1a 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -254,7 +254,7 @@ static void device_init_registers(struct vnt_private *pDevice)
 	unsigned char byOFDMPwrdBm = 0;
 
 	MACbShutdown(pDevice->PortOffset);
-	BBvSoftwareReset(pDevice->PortOffset);
+	BBvSoftwareReset(pDevice);
 
 	/* Do MACbSoftwareReset in MACvInitialize */
 	MACbSoftwareReset(pDevice->PortOffset);
@@ -446,8 +446,8 @@ static void device_init_registers(struct vnt_private *pDevice)
 		BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
 	}
 
-	BBvSetRxAntennaMode(pDevice->PortOffset, pDevice->byRxAntennaMode);
-	BBvSetTxAntennaMode(pDevice->PortOffset, pDevice->byTxAntennaMode);
+	BBvSetRxAntennaMode(pDevice, pDevice->byRxAntennaMode);
+	BBvSetTxAntennaMode(pDevice, pDevice->byTxAntennaMode);
 
 	/* Set BB and packet type at the same time. */
 	/* Set Short Slot Time, xIFS, and RSPINF. */

commit 54fbb2da8d4cef4f57d0cf70b84471dd61a7af5f
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Tue Nov 4 14:49:46 2014 +0000

    staging: vt6655: change tx wake queue
    
    Wake queue in the dwIsr loop of device_intr instead of device_tx_srv.
    
    This fixes an issue when ISR_TXDMA0 or ISR_AC0DMA does not occur
    device_tx_srv is not called and the queue gets stuck in stopped
    condition.
    
    On test if the queue is stuck another MACvTransmitAC0 or MACvTransmit0
    in vnt_tx_packet will clear it.
    
    Check on vif that both buffers are available and the queue is stopped.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 00eb89a27925..5fc6022badb2 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1014,10 +1014,6 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 			}
 			device_free_tx_buf(pDevice, pTD);
 			pDevice->iTDUsed[uIdx]--;
-
-			/* Make sure queue is available */
-			if (AVAIL_TD(pDevice, uIdx))
-				ieee80211_wake_queues(pDevice->hw);
 		}
 	}
 
@@ -1190,6 +1186,14 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 			}
 		}
 
+		/* If both buffers available wake the queue */
+		if (pDevice->vif) {
+			if (AVAIL_TD(pDevice, TYPE_TXDMA0) &&
+			    AVAIL_TD(pDevice, TYPE_AC0DMA) &&
+			    ieee80211_queue_stopped(pDevice->hw, 0))
+				ieee80211_wake_queues(pDevice->hw);
+		}
+
 		MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
 
 		MACvReceive0(pDevice->PortOffset);

commit 2ee1ad7b3289d64f98da883adc68d4bf4599937b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Nov 5 21:08:57 2014 +0000

    staging: vt6655: device_set_options remove dead variables
    
    uConnectionRate
    wRTSThreshold
    byOpMode
    b11hEnable
    uChannel
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4744cf382914..00eb89a27925 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -231,16 +231,11 @@ device_set_options(struct vnt_private *pDevice)
 	pDevice->bUpdateBBVGA = true;
 	pDevice->byPreambleType = 0;
 
-	pr_debug(" uChannel= %d\n", (int)pDevice->uChannel);
-	pr_debug(" byOpMode= %d\n", (int)pDevice->byOpMode);
-	pr_debug(" wRTSThreshold= %d\n", (int)pDevice->wRTSThreshold);
 	pr_debug(" byShortRetryLimit= %d\n", (int)pDevice->byShortRetryLimit);
 	pr_debug(" byLongRetryLimit= %d\n", (int)pDevice->byLongRetryLimit);
 	pr_debug(" byPreambleType= %d\n", (int)pDevice->byPreambleType);
 	pr_debug(" byShortPreamble= %d\n", (int)pDevice->byShortPreamble);
-	pr_debug(" uConnectionRate= %d\n", (int)pDevice->uConnectionRate);
 	pr_debug(" byBBType= %d\n", (int)pDevice->byBBType);
-	pr_debug(" pDevice->b11hEnable= %d\n", (int)pDevice->b11hEnable);
 	pr_debug(" pDevice->bDiversityRegCtlON= %d\n",
 		 (int)pDevice->bDiversityRegCtlON);
 }

commit bfa4b0febd598546ace2082efbd119531eb09ecf
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Nov 5 21:08:55 2014 +0000

    staging: vt6655: device_init_registers remove uConnectionRate
    
    The device starts up with a default rate of 54M
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index adcd6c804c25..4744cf382914 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -456,10 +456,7 @@ static void device_init_registers(struct vnt_private *pDevice)
 
 	/* Set BB and packet type at the same time. */
 	/* Set Short Slot Time, xIFS, and RSPINF. */
-	if (pDevice->uConnectionRate == RATE_AUTO)
-		pDevice->wCurrentRate = RATE_54M;
-	else
-		pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
+	pDevice->wCurrentRate = RATE_54M;
 
 	pDevice->bRadioOff = false;
 

commit ac875c17a12141fb2845be3112b6905dd41862fa
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Nov 5 21:08:54 2014 +0000

    staging: vt6655: device_set_options remove unused ethernet addresses
    
    Removing these variables
    abyBroadcastAddr
    abySNAP_RFC1042
    abySNAP_Bridgetunnel
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index e3b2d8fb1f6f..adcd6c804c25 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -222,14 +222,6 @@ static void device_get_options(struct vnt_private *pDevice)
 static void
 device_set_options(struct vnt_private *pDevice)
 {
-	unsigned char abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-	unsigned char abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
-	unsigned char abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
-
-	ether_addr_copy(pDevice->abyBroadcastAddr, abyBroadcastAddr);
-	ether_addr_copy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042);
-	ether_addr_copy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel);
-
 	pDevice->byShortRetryLimit = pDevice->sOpts.short_retry;
 	pDevice->byLongRetryLimit = pDevice->sOpts.long_retry;
 	pDevice->bDiversityRegCtlON = (pDevice->sOpts.flags & DEVICE_FLAGS_DiversityANT) ? 1 : 0;

commit 1b8e512b41d6620627d3bafeeb68d64d294c357f
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Nov 5 21:08:53 2014 +0000

    staging: vt6655: device_get_options remove unused device parameters
    
    IP_byte_align
    Channel
    PreambleType
    RTSThreshold
    ConnectionRate
    OPMode
    b80211hEnable
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 6a6c15dd91ba..e3b2d8fb1f6f 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -93,85 +93,16 @@ DEVICE_PARAM(TxDescriptors0, "Number of transmit descriptors0");
 #define TX_DESC_DEF1     64
 DEVICE_PARAM(TxDescriptors1, "Number of transmit descriptors1");
 
-#define IP_ALIG_DEF     0
-/* IP_byte_align[] is used for IP header unsigned long byte aligned
-   0: indicate the IP header won't be unsigned long byte aligned.(Default) .
-   1: indicate the IP header will be unsigned long byte aligned.
-   In some environment, the IP header should be unsigned long byte aligned,
-   or the packet will be droped when we receive it. (eg: IPVS)
-*/
-DEVICE_PARAM(IP_byte_align, "Enable IP header dword aligned");
-
 #define INT_WORKS_DEF   20
 #define INT_WORKS_MIN   10
 #define INT_WORKS_MAX   64
 
 DEVICE_PARAM(int_works, "Number of packets per interrupt services");
 
-#define CHANNEL_MIN     1
-#define CHANNEL_MAX     14
-#define CHANNEL_DEF     6
-
-DEVICE_PARAM(Channel, "Channel number");
-
-/* PreambleType[] is the preamble length used for transmit.
-   0: indicate allows long preamble type
-   1: indicate allows short preamble type
-*/
-
-#define PREAMBLE_TYPE_DEF     1
-
-DEVICE_PARAM(PreambleType, "Preamble Type");
-
-#define RTS_THRESH_MIN     512
-#define RTS_THRESH_MAX     2347
 #define RTS_THRESH_DEF     2347
 
-DEVICE_PARAM(RTSThreshold, "RTS threshold");
-
 #define FRAG_THRESH_DEF     2346
 
-#define DATA_RATE_MIN     0
-#define DATA_RATE_MAX     13
-#define DATA_RATE_DEF     13
-/* datarate[] index
-   0: indicate 1 Mbps   0x02
-   1: indicate 2 Mbps   0x04
-   2: indicate 5.5 Mbps 0x0B
-   3: indicate 11 Mbps  0x16
-   4: indicate 6 Mbps   0x0c
-   5: indicate 9 Mbps   0x12
-   6: indicate 12 Mbps  0x18
-   7: indicate 18 Mbps  0x24
-   8: indicate 24 Mbps  0x30
-   9: indicate 36 Mbps  0x48
-   10: indicate 48 Mbps  0x60
-   11: indicate 54 Mbps  0x6c
-   12: indicate 72 Mbps  0x90
-   13: indicate auto rate
-*/
-
-DEVICE_PARAM(ConnectionRate, "Connection data rate");
-
-#define OP_MODE_DEF     0
-
-DEVICE_PARAM(OPMode, "Infrastruct, adhoc, AP mode ");
-
-/* OpMode[] is used for transmit.
-   0: indicate infrastruct mode used
-   1: indicate adhoc mode used
-   2: indicate AP mode used
-*/
-
-/* PSMode[]
-   0: indicate disable power saving mode
-   1: indicate enable power saving mode
-*/
-
-#define PS_MODE_DEF     0
-
-DEVICE_PARAM(PSMode, "Power saving mode");
-
 #define SHORT_RETRY_MIN     0
 #define SHORT_RETRY_MAX     31
 #define SHORT_RETRY_DEF     8
@@ -195,20 +126,6 @@ DEVICE_PARAM(LongRetryLimit, "long frame retry limits");
 
 DEVICE_PARAM(BasebandType, "baseband type");
 
-/* 80211hEnable[]
-   0: indicate disable 802.11h
-   1: indicate enable 802.11h
-*/
-
-#define X80211h_MODE_DEF     0
-
-DEVICE_PARAM(b80211hEnable, "802.11h mode");
-
-/* 80211hEnable[]
-   0: indicate disable 802.11h
-   1: indicate enable 802.11h
-*/
-
 #define DIVERSITY_ANT_DEF     0
 
 DEVICE_PARAM(bDiversityANTEnable, "ANT diversity mode");
@@ -294,18 +211,11 @@ static void device_get_options(struct vnt_private *pDevice)
 	pOpts->nRxDescs1 = RX_DESC_DEF1;
 	pOpts->nTxDescs[0] = TX_DESC_DEF0;
 	pOpts->nTxDescs[1] = TX_DESC_DEF1;
-	pOpts->flags |= DEVICE_FLAGS_IP_ALIGN;
 	pOpts->int_works = INT_WORKS_DEF;
-	pOpts->rts_thresh = RTS_THRESH_DEF;
-	pOpts->data_rate = DATA_RATE_DEF;
-	pOpts->channel_num = CHANNEL_DEF;
 
-	pOpts->flags |= DEVICE_FLAGS_PREAMBLE_TYPE;
-	pOpts->flags |= DEVICE_FLAGS_OP_MODE;
 	pOpts->short_retry = SHORT_RETRY_DEF;
 	pOpts->long_retry = LONG_RETRY_DEF;
 	pOpts->bbp_type = BBP_TYPE_DEF;
-	pOpts->flags |= DEVICE_FLAGS_80211h_MODE;
 	pOpts->flags |= DEVICE_FLAGS_DiversityANT;
 }
 
@@ -320,23 +230,13 @@ device_set_options(struct vnt_private *pDevice)
 	ether_addr_copy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042);
 	ether_addr_copy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel);
 
-	pDevice->uChannel = pDevice->sOpts.channel_num;
-	pDevice->wRTSThreshold = pDevice->sOpts.rts_thresh;
 	pDevice->byShortRetryLimit = pDevice->sOpts.short_retry;
 	pDevice->byLongRetryLimit = pDevice->sOpts.long_retry;
-	pDevice->wMaxTransmitMSDULifetime = DEFAULT_MSDU_LIFETIME;
-	pDevice->byShortPreamble = (pDevice->sOpts.flags & DEVICE_FLAGS_PREAMBLE_TYPE) ? 1 : 0;
-	pDevice->byOpMode = (pDevice->sOpts.flags & DEVICE_FLAGS_OP_MODE) ? 1 : 0;
-	pDevice->b11hEnable = (pDevice->sOpts.flags & DEVICE_FLAGS_80211h_MODE) ? 1 : 0;
 	pDevice->bDiversityRegCtlON = (pDevice->sOpts.flags & DEVICE_FLAGS_DiversityANT) ? 1 : 0;
-	pDevice->uConnectionRate = pDevice->sOpts.data_rate;
-	if (pDevice->uConnectionRate < RATE_AUTO)
-		pDevice->bFixRate = true;
 	pDevice->byBBType = pDevice->sOpts.bbp_type;
 	pDevice->byPacketType = (VIA_PKT_TYPE)pDevice->byBBType;
 	pDevice->byAutoFBCtrl = AUTO_FB_0;
 	pDevice->bUpdateBBVGA = true;
-	pDevice->byFOETuning = 0;
 	pDevice->byPreambleType = 0;
 
 	pr_debug(" uChannel= %d\n", (int)pDevice->uChannel);

commit b1c41336570f952e0b30eaa56728996d5ac50457
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Nov 5 21:08:52 2014 +0000

    staging: vt6655: remove fragmentation from driver
    
    fragmentation is now handled by mac80211.
    
    Remove functions
    device_alloc_frag_buf
    device_init_defrag_cb
    device_free_frag_buf
    
    Removing
    typedef struct tagSDeFragControlBlock
    frag_thresh
    sRxDFCB
    cbDFCB;
    cbFreeDFCB;
    uCurrentDFCBIdx;
    
    macros
    FRAG_THRESH_MIN
    FRAG_THRESH_MAX
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f0b336bb393d..6a6c15dd91ba 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -35,16 +35,13 @@
  *   device_intr - interrupt handle function
  *   device_rx_srv - rx service function
  *   device_alloc_rx_buf - rx buffer pre-allocated function
- *   device_alloc_frag_buf - rx fragement pre-allocated function
  *   device_free_tx_buf - free tx buffer function
- *   device_free_frag_buf- free de-fragement buffer
  *   device_init_rd0_ring- initial rd dma0 ring
  *   device_init_rd1_ring- initial rd dma1 ring
  *   device_init_td0_ring- initial tx dma0 ring buffer
  *   device_init_td1_ring- initial tx dma1 ring buffer
  *   device_init_registers- initial MAC & BBP & RF internal registers.
  *   device_init_rings- initial tx/rx ring buffer
- *   device_init_defrag_cb- initial & allocate de-fragement buffer.
  *   device_free_rings- free all allocated ring buffer
  *   device_tx_srv- tx interrupt service function
  *
@@ -132,12 +129,8 @@ DEVICE_PARAM(PreambleType, "Preamble Type");
 
 DEVICE_PARAM(RTSThreshold, "RTS threshold");
 
-#define FRAG_THRESH_MIN     256
-#define FRAG_THRESH_MAX     2346
 #define FRAG_THRESH_DEF     2346
 
-DEVICE_PARAM(FragThreshold, "Fragmentation threshold");
-
 #define DATA_RATE_MIN     0
 #define DATA_RATE_MAX     13
 #define DATA_RATE_DEF     13
@@ -256,7 +249,6 @@ static struct notifier_block device_notifier = {
 
 static void device_init_rd0_ring(struct vnt_private *pDevice);
 static void device_init_rd1_ring(struct vnt_private *pDevice);
-static void device_init_defrag_cb(struct vnt_private *pDevice);
 static void device_init_td0_ring(struct vnt_private *pDevice);
 static void device_init_td1_ring(struct vnt_private *pDevice);
 
@@ -270,7 +262,6 @@ static void device_free_td1_ring(struct vnt_private *pDevice);
 static void device_free_rd0_ring(struct vnt_private *pDevice);
 static void device_free_rd1_ring(struct vnt_private *pDevice);
 static void device_free_rings(struct vnt_private *pDevice);
-static void device_free_frag_buf(struct vnt_private *pDevice);
 
 /*---------------------  Export Variables  --------------------------*/
 
@@ -306,7 +297,6 @@ static void device_get_options(struct vnt_private *pDevice)
 	pOpts->flags |= DEVICE_FLAGS_IP_ALIGN;
 	pOpts->int_works = INT_WORKS_DEF;
 	pOpts->rts_thresh = RTS_THRESH_DEF;
-	pOpts->frag_thresh = FRAG_THRESH_DEF;
 	pOpts->data_rate = DATA_RATE_DEF;
 	pOpts->channel_num = CHANNEL_DEF;
 
@@ -332,7 +322,6 @@ device_set_options(struct vnt_private *pDevice)
 
 	pDevice->uChannel = pDevice->sOpts.channel_num;
 	pDevice->wRTSThreshold = pDevice->sOpts.rts_thresh;
-	pDevice->wFragmentationThreshold = pDevice->sOpts.frag_thresh;
 	pDevice->byShortRetryLimit = pDevice->sOpts.short_retry;
 	pDevice->byLongRetryLimit = pDevice->sOpts.long_retry;
 	pDevice->wMaxTransmitMSDULifetime = DEFAULT_MSDU_LIFETIME;
@@ -853,21 +842,6 @@ static void device_init_rd1_ring(struct vnt_private *pDevice)
 	pDevice->pCurrRD[1] = &(pDevice->aRD1Ring[0]);
 }
 
-static void device_init_defrag_cb(struct vnt_private *pDevice)
-{
-	int i;
-	PSDeFragControlBlock pDeF;
-
-	/* Init the fragment ctl entries */
-	for (i = 0; i < CB_MAX_RX_FRAG; i++) {
-		pDeF = &(pDevice->sRxDFCB[i]);
-		if (!device_alloc_frag_buf(pDevice, pDeF))
-			dev_err(&pDevice->pcid->dev, "can not alloc frag bufs\n");
-	}
-	pDevice->cbDFCB = CB_MAX_RX_FRAG;
-	pDevice->cbFreeDFCB = pDevice->cbDFCB;
-}
-
 static void device_free_rd0_ring(struct vnt_private *pDevice)
 {
 	int i;
@@ -902,20 +876,6 @@ static void device_free_rd1_ring(struct vnt_private *pDevice)
 	}
 }
 
-static void device_free_frag_buf(struct vnt_private *pDevice)
-{
-	PSDeFragControlBlock pDeF;
-	int i;
-
-	for (i = 0; i < CB_MAX_RX_FRAG; i++) {
-		pDeF = &(pDevice->sRxDFCB[i]);
-
-		if (pDeF->skb)
-			dev_kfree_skb(pDeF->skb);
-
-	}
-}
-
 static void device_init_td0_ring(struct vnt_private *pDevice)
 {
 	int i;
@@ -1056,17 +1016,6 @@ static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pRD)
 	return true;
 }
 
-bool device_alloc_frag_buf(struct vnt_private *pDevice,
-			   PSDeFragControlBlock pDeF)
-{
-	pDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-	if (pDeF->skb == NULL)
-		return false;
-	ASSERT(pDeF->skb);
-
-	return true;
-}
-
 static const u8 fallback_rate0[5][5] = {
 	{RATE_18M, RATE_18M, RATE_12M, RATE_12M, RATE_12M},
 	{RATE_24M, RATE_24M, RATE_18M, RATE_12M, RATE_12M},
@@ -1466,7 +1415,6 @@ static int vnt_start(struct ieee80211_hw *hw)
 	dev_dbg(&priv->pcid->dev, "call device init rd0 ring\n");
 	device_init_rd0_ring(priv);
 	device_init_rd1_ring(priv);
-	device_init_defrag_cb(priv);
 	device_init_td0_ring(priv);
 	device_init_td1_ring(priv);
 
@@ -1494,7 +1442,6 @@ static void vnt_stop(struct ieee80211_hw *hw)
 	device_free_td1_ring(priv);
 	device_free_rd0_ring(priv);
 	device_free_rd1_ring(priv);
-	device_free_frag_buf(priv);
 	device_free_rings(priv);
 
 	free_irq(priv->pcid->irq, priv);

commit 33785983ca3364bafc1c1ec805560ff83c9fdb0c
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:56:05 2014 +0000

    staging: vt6655: dead code remove wmgr.h
    
    on removal needs to be replaced by card.h in device.h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 5c91c2ff1491..f0b336bb393d 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -58,7 +58,6 @@
 #include "channel.h"
 #include "baseband.h"
 #include "mac.h"
-#include "wmgr.h"
 #include "power.h"
 #include "rxtx.h"
 #include "dpc.h"

commit e11cdc39f381e541fbdc2eccf2c4fce910a4f2bb
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:56:02 2014 +0000

    staging: vt6655: remove typedef void *TimerFunction
    
    Covert functions TimerSQ3CallBack and TimerState1CallBack to
    the correct type for struct timer_list.function to remove
    the cast altogether.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 7892f861521e..5c91c2ff1491 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -625,17 +625,17 @@ static void device_init_diversity_timer(struct vnt_private *pDevice)
 {
 	init_timer(&pDevice->TimerSQ3Tmax1);
 	pDevice->TimerSQ3Tmax1.data = (unsigned long) pDevice;
-	pDevice->TimerSQ3Tmax1.function = (TimerFunction)TimerSQ3CallBack;
+	pDevice->TimerSQ3Tmax1.function = TimerSQ3CallBack;
 	pDevice->TimerSQ3Tmax1.expires = RUN_AT(HZ);
 
 	init_timer(&pDevice->TimerSQ3Tmax2);
 	pDevice->TimerSQ3Tmax2.data = (unsigned long) pDevice;
-	pDevice->TimerSQ3Tmax2.function = (TimerFunction)TimerSQ3CallBack;
+	pDevice->TimerSQ3Tmax2.function = TimerSQ3CallBack;
 	pDevice->TimerSQ3Tmax2.expires = RUN_AT(HZ);
 
 	init_timer(&pDevice->TimerSQ3Tmax3);
 	pDevice->TimerSQ3Tmax3.data = (unsigned long) pDevice;
-	pDevice->TimerSQ3Tmax3.function = (TimerFunction)TimerState1CallBack;
+	pDevice->TimerSQ3Tmax3.function = TimerState1CallBack;
 	pDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);
 }
 

commit 651a39cad5f3009e8aa80e3132ac34a9474ebf74
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:57 2014 +0000

    staging: vt6655: dead code remove iocmd.h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index d5ab7c4b6891..7892f861521e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -60,7 +60,6 @@
 #include "mac.h"
 #include "wmgr.h"
 #include "power.h"
-#include "iocmd.h"
 #include "rxtx.h"
 #include "dpc.h"
 #include "rf.h"

commit 47a2a3cb758f6b44b0a6ce2a379f44b18666c125
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:56 2014 +0000

    staging: vt6655: dead code remove iowpa.h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 2327369ba790..d5ab7c4b6891 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -64,7 +64,6 @@
 #include "rxtx.h"
 #include "dpc.h"
 #include "rf.h"
-#include "iowpa.h"
 #include <linux/delay.h>
 #include <linux/kthread.h>
 #include <linux/slab.h>

commit d54435d3fb278e90f65f6033adbee89b23113229
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:54 2014 +0000

    staging: vt6655: dead code remove tether.h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index dfaec046ef51..2327369ba790 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -58,7 +58,6 @@
 #include "channel.h"
 #include "baseband.h"
 #include "mac.h"
-#include "tether.h"
 #include "wmgr.h"
 #include "power.h"
 #include "iocmd.h"

commit d853ce22915ce8ac33695cea2f02ea38a9d38bc7
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:53 2014 +0000

    staging: vt6655: dead code remove bssdb.h header
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 80bbe1dda05b..dfaec046ef51 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -63,7 +63,6 @@
 #include "power.h"
 #include "iocmd.h"
 #include "rxtx.h"
-#include "bssdb.h"
 #include "dpc.h"
 #include "rf.h"
 #include "iowpa.h"

commit 37cc22b1c4a542181db7b827136bcf63118d1346
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:52 2014 +0000

    staging: vt6655: dead remove wcmd.h and typedefs
    
    CMD_STATE
    CMD_CODE
    CMD_ITEM
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index d8fd44c88206..80bbe1dda05b 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -61,7 +61,6 @@
 #include "tether.h"
 #include "wmgr.h"
 #include "power.h"
-#include "wcmd.h"
 #include "iocmd.h"
 #include "rxtx.h"
 #include "bssdb.h"

commit 8ec94797eb3aba4346fbc1c1f3181e8b6f9f21f9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:49 2014 +0000

    staging: vt6655: dead code remove vntwifi.h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1111d1eda359..d8fd44c88206 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -344,7 +344,6 @@ device_set_options(struct vnt_private *pDevice)
 	pDevice->wMaxTransmitMSDULifetime = DEFAULT_MSDU_LIFETIME;
 	pDevice->byShortPreamble = (pDevice->sOpts.flags & DEVICE_FLAGS_PREAMBLE_TYPE) ? 1 : 0;
 	pDevice->byOpMode = (pDevice->sOpts.flags & DEVICE_FLAGS_OP_MODE) ? 1 : 0;
-	pDevice->ePSMode = (pDevice->sOpts.flags & DEVICE_FLAGS_PS_MODE) ? 1 : 0;
 	pDevice->b11hEnable = (pDevice->sOpts.flags & DEVICE_FLAGS_80211h_MODE) ? 1 : 0;
 	pDevice->bDiversityRegCtlON = (pDevice->sOpts.flags & DEVICE_FLAGS_DiversityANT) ? 1 : 0;
 	pDevice->uConnectionRate = pDevice->sOpts.data_rate;
@@ -359,7 +358,6 @@ device_set_options(struct vnt_private *pDevice)
 
 	pr_debug(" uChannel= %d\n", (int)pDevice->uChannel);
 	pr_debug(" byOpMode= %d\n", (int)pDevice->byOpMode);
-	pr_debug(" ePSMode= %d\n", (int)pDevice->ePSMode);
 	pr_debug(" wRTSThreshold= %d\n", (int)pDevice->wRTSThreshold);
 	pr_debug(" byShortRetryLimit= %d\n", (int)pDevice->byShortRetryLimit);
 	pr_debug(" byLongRetryLimit= %d\n", (int)pDevice->byLongRetryLimit);

commit b4ba0cb10f5db831f0e7b9bb090411d53e1a9579
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:46 2014 +0000

    staging: vt6655: dead code remove wctl.c/h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 2c2f42fe10af..1111d1eda359 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -60,7 +60,6 @@
 #include "mac.h"
 #include "tether.h"
 #include "wmgr.h"
-#include "wctl.h"
 #include "power.h"
 #include "wcmd.h"
 #include "iocmd.h"

commit 5e6fc9d7e4f9573a3b110fff8eb3e82553e0c0b0
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:44 2014 +0000

    staging: vt6655: dead code remove tcrc.c/h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 18dad0cb69a0..2c2f42fe10af 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -64,7 +64,6 @@
 #include "power.h"
 #include "wcmd.h"
 #include "iocmd.h"
-#include "tcrc.h"
 #include "rxtx.h"
 #include "bssdb.h"
 #include "dpc.h"

commit c49802bfb6f3aadc64360994e6500bd2e2f080b6
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:36 2014 +0000

    staging: vt6655: deadcode remove wroute.c/h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 848c258119a6..18dad0cb69a0 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -66,7 +66,6 @@
 #include "iocmd.h"
 #include "tcrc.h"
 #include "rxtx.h"
-#include "wroute.h"
 #include "bssdb.h"
 #include "dpc.h"
 #include "rf.h"

commit f3de0df9b01a45d0d95bb1e43750d895ef8d79db
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:33 2014 +0000

    staging: vt6655: dead code datarate.c/h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 991a276f1ecf..848c258119a6 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -69,7 +69,6 @@
 #include "wroute.h"
 #include "bssdb.h"
 #include "dpc.h"
-#include "datarate.h"
 #include "rf.h"
 #include "iowpa.h"
 #include <linux/delay.h>

commit 2759e2172de880c9aa6b2cd68abdca0f769a6b53
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:25 2014 +0000

    staging: vt6655: dead code remove wpactl.c/h
    
    All these functions are now dead.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 3a90401ab7aa..991a276f1ecf 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -68,7 +68,6 @@
 #include "rxtx.h"
 #include "wroute.h"
 #include "bssdb.h"
-#include "wpactl.h"
 #include "dpc.h"
 #include "datarate.h"
 #include "rf.h"

commit ee1464902c25e22c15d7eda41f00a8a40acc7ec9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:24 2014 +0000

    staging: vt6655: dead code remove legacy hostap.c/h
    
    hoatap is now supported by mac80211 in nl80211 mode
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 5b54cabdc863..3a90401ab7aa 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -68,7 +68,6 @@
 #include "rxtx.h"
 #include "wroute.h"
 #include "bssdb.h"
-#include "hostap.h"
 #include "wpactl.h"
 #include "dpc.h"
 #include "datarate.h"

commit ae1927eb348908ea92eb9ce8c452e053a4830adf
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:23 2014 +0000

    staging: vt6655: dead code remove ioctl.c/h
    
    The driver nolonger supports these io functions
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 51b20f3d8e1b..5b54cabdc863 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -70,7 +70,6 @@
 #include "bssdb.h"
 #include "hostap.h"
 #include "wpactl.h"
-#include "ioctl.h"
 #include "dpc.h"
 #include "datarate.h"
 #include "rf.h"

commit 0d24c97093f304fdca68af48e38e91d5ad01daf0
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:22 2014 +0000

    staging: vt6655: dead code remove iwctl.c/h
    
    The iw handler and functions are nolonger required.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 870016ae9905..51b20f3d8e1b 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -71,7 +71,6 @@
 #include "hostap.h"
 #include "wpactl.h"
 #include "ioctl.h"
-#include "iwctl.h"
 #include "dpc.h"
 #include "datarate.h"
 #include "rf.h"

commit 7af1ead431ec82b64de511fa28ac54b3cc5b66ca
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:21 2014 +0000

    staging: vt6655: dead code remove net device code
    
    All functions are dead and nolonger of use.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 12fa63c73f01..870016ae9905 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -32,20 +32,12 @@
  *   device_free_info - device structure resource free function
  *   device_get_pci_info - get allocated pci io/mem resource
  *   device_print_info - print out resource
- *   device_open - allocate dma/descripter resource & initial mac/bbp function
- *   device_xmit - asynchrous data tx function
  *   device_intr - interrupt handle function
- *   device_set_multi - set mac filter
- *   device_ioctl - ioctl entry
- *   device_close - shutdown mac/bbp & free dma/descripter resource
  *   device_rx_srv - rx service function
- *   device_receive_frame - rx data function
  *   device_alloc_rx_buf - rx buffer pre-allocated function
  *   device_alloc_frag_buf - rx fragement pre-allocated function
  *   device_free_tx_buf - free tx buffer function
  *   device_free_frag_buf- free de-fragement buffer
- *   device_dma0_tx_80211- tx 802.11 frame via dma0
- *   device_dma0_xmit- tx PS bufferred frame via dma0
  *   device_init_rd0_ring- initial rd dma0 ring
  *   device_init_rd1_ring- initial rd dma1 ring
  *   device_init_td0_ring- initial tx dma0 ring buffer
@@ -265,12 +257,7 @@ static void device_free_info(struct vnt_private *pDevice);
 static bool device_get_pci_info(struct vnt_private *, struct pci_dev *pcid);
 static void device_print_info(struct vnt_private *pDevice);
 static void device_init_diversity_timer(struct vnt_private *pDevice);
-static int  device_open(struct net_device *dev);
-static int  device_xmit(struct sk_buff *skb, struct net_device *dev);
 static  irqreturn_t  device_intr(int irq,  void *dev_instance);
-static void device_set_multi(struct net_device *dev);
-static int  device_close(struct net_device *dev);
-static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 
 #ifdef CONFIG_PM
 static int device_notify_reboot(struct notifier_block *, unsigned long event, void *ptr);
@@ -287,11 +274,6 @@ static void device_init_defrag_cb(struct vnt_private *pDevice);
 static void device_init_td0_ring(struct vnt_private *pDevice);
 static void device_init_td1_ring(struct vnt_private *pDevice);
 
-static int  device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev);
-//2008-0714<Add>by Mike Liu
-static bool device_release_WPADEV(struct vnt_private *pDevice);
-
-static int  ethtool_ioctl(struct net_device *dev, void __user *useraddr);
 static int  device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx);
 static int  device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx);
 static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pDesc);
@@ -672,45 +654,6 @@ static void device_init_diversity_timer(struct vnt_private *pDevice)
 	pDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);
 }
 
-static bool device_release_WPADEV(struct vnt_private *pDevice)
-{
-	viawget_wpa_header *wpahdr;
-	int ii = 0;
-
-	//send device close to wpa_supplicnat layer
-	if (pDevice->bWPADEVUp) {
-		wpahdr = (viawget_wpa_header *)pDevice->skb->data;
-		wpahdr->type = VIAWGET_DEVICECLOSE_MSG;
-		wpahdr->resp_ie_len = 0;
-		wpahdr->req_ie_len = 0;
-		skb_put(pDevice->skb, sizeof(viawget_wpa_header));
-		pDevice->skb->dev = pDevice->wpadev;
-		skb_reset_mac_header(pDevice->skb);
-		pDevice->skb->pkt_type = PACKET_HOST;
-		pDevice->skb->protocol = htons(ETH_P_802_2);
-		memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
-		netif_rx(pDevice->skb);
-		pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-
-		while (pDevice->bWPADEVUp) {
-			set_current_state(TASK_UNINTERRUPTIBLE);
-			schedule_timeout(HZ / 20);          //wait 50ms
-			ii++;
-			if (ii > 20)
-				break;
-		}
-	}
-	return true;
-}
-
-static const struct net_device_ops device_netdev_ops = {
-	.ndo_open               = device_open,
-	.ndo_stop               = device_close,
-	.ndo_do_ioctl           = device_ioctl,
-	.ndo_start_xmit         = device_xmit,
-	.ndo_set_rx_mode	= device_set_multi,
-};
-
 static void device_print_info(struct vnt_private *pDevice)
 {
 	dev_info(&pDevice->pcid->dev, "%s\n", get_chip_name(pDevice->chip_id));
@@ -1297,653 +1240,6 @@ static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)
 	pTDInfo->byFlags = 0;
 }
 
-static int  device_open(struct net_device *dev)
-{
-	struct vnt_private *pDevice = netdev_priv(dev);
-	int i;
-
-	pDevice->rx_buf_sz = PKT_BUF_SZ;
-	if (!device_init_rings(pDevice))
-		return -ENOMEM;
-
-//2008-5-13 <add> by chester
-	i = request_irq(pDevice->pcid->irq, &device_intr, IRQF_SHARED, dev->name, dev);
-	if (i)
-		return i;
-
-#ifdef WPA_SM_Transtatus
-	pDevice->fWPA_Authened = false;
-#endif
-	pr_debug("call device init rd0 ring\n");
-	device_init_rd0_ring(pDevice);
-	device_init_rd1_ring(pDevice);
-	device_init_defrag_cb(pDevice);
-	device_init_td0_ring(pDevice);
-	device_init_td1_ring(pDevice);
-
-	if (pDevice->bDiversityRegCtlON)
-		device_init_diversity_timer(pDevice);
-
-	vMgrObjectInit(pDevice);
-	vMgrTimerInit(pDevice);
-
-	pr_debug("call device_init_registers\n");
-	device_init_registers(pDevice);
-
-	MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
-	ether_addr_copy(pDevice->pMgmt->abyMACAddr, pDevice->abyCurrentNetAddr);
-	device_set_multi(pDevice->dev);
-
-	// Init for Key Management
-	KeyvInitTable(&pDevice->sKey, pDevice->PortOffset);
-	add_timer(&(pDevice->pMgmt->sTimerSecondCallback));
-
-#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-	pDevice->bwextcount = 0;
-	pDevice->bWPASuppWextEnabled = false;
-#endif
-	pDevice->byReAssocCount = 0;
-	pDevice->bWPADEVUp = false;
-	// Patch: if WEP key already set by iwconfig but device not yet open
-	if (pDevice->bEncryptionEnable && pDevice->bTransmitKey) {
-		KeybSetDefaultKey(&(pDevice->sKey),
-				  (unsigned long)(pDevice->byKeyIndex | (1 << 31)),
-				  pDevice->uKeyLength,
-				  NULL,
-				  pDevice->abyKey,
-				  KEY_CTL_WEP,
-				  pDevice->PortOffset,
-				  pDevice->byLocalID
-			);
-		pDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;
-	}
-
-	pr_debug("call MACvIntEnable\n");
-	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
-
-	if (pDevice->pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-		bScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);
-	} else {
-		bScheduleCommand((void *)pDevice, WLAN_CMD_BSSID_SCAN, NULL);
-		bScheduleCommand((void *)pDevice, WLAN_CMD_SSID, NULL);
-	}
-	pDevice->flags |= DEVICE_FLAGS_OPENED;
-
-	pr_debug("device_open success..\n");
-	return 0;
-}
-
-static int  device_close(struct net_device *dev)
-{
-	struct vnt_private *pDevice = netdev_priv(dev);
-	PSMgmtObject     pMgmt = pDevice->pMgmt;
-//2007-1121-02<Add>by EinsnLiu
-	if (pDevice->bLinkPass) {
-		bScheduleCommand((void *)pDevice, WLAN_CMD_DISASSOCIATE, NULL);
-		mdelay(30);
-	}
-
-	del_timer(&pDevice->sTimerTxData);
-	del_timer(&pDevice->sTimerCommand);
-	del_timer(&pMgmt->sTimerSecondCallback);
-	if (pDevice->bDiversityRegCtlON) {
-		del_timer(&pDevice->TimerSQ3Tmax1);
-		del_timer(&pDevice->TimerSQ3Tmax2);
-		del_timer(&pDevice->TimerSQ3Tmax3);
-	}
-
-	netif_stop_queue(dev);
-	pDevice->bCmdRunning = false;
-	MACbShutdown(pDevice->PortOffset);
-	MACbSoftwareReset(pDevice->PortOffset);
-	CARDbRadioPowerOff(pDevice);
-
-	pDevice->bLinkPass = false;
-	memset(pMgmt->abyCurrBSSID, 0, 6);
-	pMgmt->eCurrState = WMAC_STATE_IDLE;
-	device_free_td0_ring(pDevice);
-	device_free_td1_ring(pDevice);
-	device_free_rd0_ring(pDevice);
-	device_free_rd1_ring(pDevice);
-	device_free_frag_buf(pDevice);
-	device_free_rings(pDevice);
-	BSSvClearNodeDBTable(pDevice, 0);
-	free_irq(dev->irq, dev);
-	pDevice->flags &= (~DEVICE_FLAGS_OPENED);
-	//2008-0714-01<Add>by chester
-	device_release_WPADEV(pDevice);
-
-	pr_debug("device_close..\n");
-	return 0;
-}
-
-static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev)
-{
-	struct vnt_private *pDevice = netdev_priv(dev);
-	unsigned char *pbMPDU;
-	unsigned int cbMPDULen = 0;
-
-	pr_debug("device_dma0_tx_80211\n");
-	spin_lock_irq(&pDevice->lock);
-
-	if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
-		pr_debug("device_dma0_tx_80211, td0 <=0\n");
-		dev_kfree_skb_irq(skb);
-		spin_unlock_irq(&pDevice->lock);
-		return 0;
-	}
-
-	if (pDevice->bStopTx0Pkt) {
-		dev_kfree_skb_irq(skb);
-		spin_unlock_irq(&pDevice->lock);
-		return 0;
-	}
-
-	cbMPDULen = skb->len;
-	pbMPDU = skb->data;
-
-	vDMA0_tx_80211(pDevice, skb, pbMPDU, cbMPDULen);
-
-	spin_unlock_irq(&pDevice->lock);
-
-	return 0;
-}
-
-bool device_dma0_xmit(struct vnt_private *pDevice,
-		      struct sk_buff *skb, unsigned int uNodeIndex)
-{
-	PSMgmtObject    pMgmt = pDevice->pMgmt;
-	PSTxDesc        pHeadTD, pLastTD;
-	unsigned int cbFrameBodySize;
-	unsigned int uMACfragNum;
-	unsigned char byPktType;
-	bool bNeedEncryption = false;
-	PSKeyItem       pTransmitKey = NULL;
-	unsigned int cbHeaderSize;
-	unsigned int ii;
-	SKeyItem        STempKey;
-
-	if (pDevice->bStopTx0Pkt) {
-		dev_kfree_skb_irq(skb);
-		return false;
-	}
-
-	if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
-		dev_kfree_skb_irq(skb);
-		pr_debug("device_dma0_xmit, td0 <=0\n");
-		return false;
-	}
-
-	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-		if (pDevice->uAssocCount == 0) {
-			dev_kfree_skb_irq(skb);
-			pr_debug("device_dma0_xmit, assocCount = 0\n");
-			return false;
-		}
-	}
-
-	pHeadTD = pDevice->apCurrTD[TYPE_TXDMA0];
-
-	pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
-
-	memcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)(skb->data), ETH_HLEN);
-	cbFrameBodySize = skb->len - ETH_HLEN;
-
-	// 802.1H
-	if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN)
-		cbFrameBodySize += 8;
-
-	uMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);
-
-	if (uMACfragNum > AVAIL_TD(pDevice, TYPE_TXDMA0)) {
-		dev_kfree_skb_irq(skb);
-		return false;
-	}
-	byPktType = (unsigned char)pDevice->byPacketType;
-
-	if (pDevice->bFixRate) {
-		if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
-			if (pDevice->uConnectionRate >= RATE_11M)
-				pDevice->wCurrentRate = RATE_11M;
-			else
-				pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
-		} else {
-			if (pDevice->uConnectionRate >= RATE_54M)
-				pDevice->wCurrentRate = RATE_54M;
-			else
-				pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
-		}
-	} else {
-		pDevice->wCurrentRate = pDevice->pMgmt->sNodeDBTable[uNodeIndex].wTxDataRate;
-	}
-
-	//preamble type
-	if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble)
-		pDevice->byPreambleType = pDevice->byShortPreamble;
-	else
-		pDevice->byPreambleType = PREAMBLE_LONG;
-
-	pr_debug("dma0: pDevice->wCurrentRate = %d\n", pDevice->wCurrentRate);
-
-	if (pDevice->wCurrentRate <= RATE_11M) {
-		byPktType = PK_TYPE_11B;
-	} else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
-		byPktType = PK_TYPE_11A;
-	} else {
-		if (pDevice->bProtectMode)
-			byPktType = PK_TYPE_11GB;
-		else
-			byPktType = PK_TYPE_11GA;
-	}
-
-	if (pDevice->bEncryptionEnable)
-		bNeedEncryption = true;
-
-	if (pDevice->bEnableHostWEP) {
-		pTransmitKey = &STempKey;
-		pTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;
-		pTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;
-		pTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;
-		pTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;
-		pTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;
-		memcpy(pTransmitKey->abyKey,
-		       &pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],
-		       pTransmitKey->uKeyLength
-			);
-	}
-	vGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,
-			    cbFrameBodySize, TYPE_TXDMA0, pHeadTD,
-			    &pDevice->sTxEthHeader, (unsigned char *)skb->data, pTransmitKey, uNodeIndex,
-			    &uMACfragNum,
-			    &cbHeaderSize
-		);
-
-	if (MACbIsRegBitsOn(pDevice->PortOffset, MAC_REG_PSCTL, PSCTL_PS)) {
-		// Disable PS
-		MACbPSWakeup(pDevice->PortOffset);
-	}
-
-	pDevice->bPWBitOn = false;
-
-	pLastTD = pHeadTD;
-	for (ii = 0; ii < uMACfragNum; ii++) {
-		// Poll Transmit the adapter
-		wmb();
-		pHeadTD->m_td0TD0.f1Owner = OWNED_BY_NIC;
-		wmb();
-		if (ii == (uMACfragNum - 1))
-			pLastTD = pHeadTD;
-		pHeadTD = pHeadTD->next;
-	}
-
-	// Save the information needed by the tx interrupt handler
-	// to complete the Send request
-	pLastTD->pTDInfo->skb = skb;
-	pLastTD->pTDInfo->byFlags = 0;
-	pLastTD->pTDInfo->byFlags |= TD_FLAGS_NETIF_SKB;
-
-	pDevice->apCurrTD[TYPE_TXDMA0] = pHeadTD;
-
-	MACvTransmit0(pDevice->PortOffset);
-
-	return true;
-}
-
-//TYPE_AC0DMA data tx
-static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
-	struct vnt_private *pDevice = netdev_priv(dev);
-	PSMgmtObject    pMgmt = pDevice->pMgmt;
-	PSTxDesc        pHeadTD, pLastTD;
-	unsigned int uNodeIndex = 0;
-	unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
-	unsigned short wAID;
-	unsigned int uMACfragNum = 1;
-	unsigned int cbFrameBodySize;
-	unsigned char byPktType;
-	unsigned int cbHeaderSize;
-	bool bNeedEncryption = false;
-	PSKeyItem       pTransmitKey = NULL;
-	SKeyItem        STempKey;
-	unsigned int ii;
-	bool bTKIP_UseGTK = false;
-	bool bNeedDeAuth = false;
-	unsigned char *pbyBSSID;
-	bool bNodeExist = false;
-
-	spin_lock_irq(&pDevice->lock);
-	if (!pDevice->bLinkPass) {
-		dev_kfree_skb_irq(skb);
-		spin_unlock_irq(&pDevice->lock);
-		return 0;
-	}
-
-	if (pDevice->bStopDataPkt) {
-		dev_kfree_skb_irq(skb);
-		spin_unlock_irq(&pDevice->lock);
-		return 0;
-	}
-
-	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-		if (pDevice->uAssocCount == 0) {
-			dev_kfree_skb_irq(skb);
-			spin_unlock_irq(&pDevice->lock);
-			return 0;
-		}
-		if (is_multicast_ether_addr((unsigned char *)(skb->data))) {
-			uNodeIndex = 0;
-			bNodeExist = true;
-			if (pMgmt->sNodeDBTable[0].bPSEnable) {
-				skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skb);
-				pMgmt->sNodeDBTable[0].wEnQueueCnt++;
-				// set tx map
-				pMgmt->abyPSTxMap[0] |= byMask[0];
-				spin_unlock_irq(&pDevice->lock);
-				return 0;
-			}
-		} else {
-			if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data), &uNodeIndex)) {
-				if (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {
-					skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);
-					pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;
-					// set tx map
-					wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
-					pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
-					pr_debug("Set:pMgmt->abyPSTxMap[%d]= %d\n",
-						 (wAID >> 3),
-						 pMgmt->abyPSTxMap[wAID >> 3]);
-					spin_unlock_irq(&pDevice->lock);
-					return 0;
-				}
-
-				if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble)
-					pDevice->byPreambleType = pDevice->byShortPreamble;
-				else
-					pDevice->byPreambleType = PREAMBLE_LONG;
-
-				bNodeExist = true;
-
-			}
-		}
-
-		if (!bNodeExist) {
-			pr_debug("Unknown STA not found in node DB\n");
-			dev_kfree_skb_irq(skb);
-			spin_unlock_irq(&pDevice->lock);
-			return 0;
-		}
-	}
-
-	pHeadTD = pDevice->apCurrTD[TYPE_AC0DMA];
-
-	pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
-
-	memcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)(skb->data), ETH_HLEN);
-	cbFrameBodySize = skb->len - ETH_HLEN;
-	// 802.1H
-	if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN)
-		cbFrameBodySize += 8;
-
-	if (pDevice->bEncryptionEnable) {
-		bNeedEncryption = true;
-		// get Transmit key
-		do {
-			if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
-			    (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
-				pbyBSSID = pDevice->abyBSSID;
-				// get pairwise key
-				if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == false) {
-					// get group key
-					if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == true) {
-						bTKIP_UseGTK = true;
-						pr_debug("Get GTK\n");
-						break;
-					}
-				} else {
-					pr_debug("Get PTK\n");
-					break;
-				}
-			} else if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
-				pbyBSSID = pDevice->sTxEthHeader.abyDstAddr;  //TO_DS = 0 and FROM_DS = 0 --> 802.11 MAC Address1
-				pr_debug("IBSS Serach Key:\n");
-				for (ii = 0; ii < 6; ii++)
-					pr_debug("%x\n", *(pbyBSSID+ii));
-				pr_debug("\n");
-
-				// get pairwise key
-				if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == true)
-					break;
-			}
-			// get group key
-			pbyBSSID = pDevice->abyBroadcastAddr;
-			if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == false) {
-				pTransmitKey = NULL;
-				if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)
-					pr_debug("IBSS and KEY is NULL. [%d]\n",
-						 pDevice->pMgmt->eCurrMode);
-				else
-					pr_debug("NOT IBSS and KEY is NULL. [%d]\n",
-						 pDevice->pMgmt->eCurrMode);
-			} else {
-				bTKIP_UseGTK = true;
-				pr_debug("Get GTK\n");
-			}
-		} while (false);
-	}
-
-	if (pDevice->bEnableHostWEP) {
-		pr_debug("acdma0: STA index %d\n", uNodeIndex);
-		if (pDevice->bEncryptionEnable) {
-			pTransmitKey = &STempKey;
-			pTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;
-			pTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;
-			pTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;
-			pTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;
-			pTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;
-			memcpy(pTransmitKey->abyKey,
-			       &pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],
-			       pTransmitKey->uKeyLength
-				);
-		}
-	}
-
-	uMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);
-
-	if (uMACfragNum > AVAIL_TD(pDevice, TYPE_AC0DMA)) {
-		pr_debug("uMACfragNum > AVAIL_TD(TYPE_AC0DMA) = %d\n",
-			 uMACfragNum);
-		dev_kfree_skb_irq(skb);
-		spin_unlock_irq(&pDevice->lock);
-		return 0;
-	}
-
-	if (pTransmitKey != NULL) {
-		if ((pTransmitKey->byCipherSuite == KEY_CTL_WEP) &&
-		    (pTransmitKey->uKeyLength == WLAN_WEP232_KEYLEN)) {
-			uMACfragNum = 1; //WEP256 doesn't support fragment
-		}
-	}
-
-	byPktType = (unsigned char)pDevice->byPacketType;
-
-	if (pDevice->bFixRate) {
-		if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
-			if (pDevice->uConnectionRate >= RATE_11M)
-				pDevice->wCurrentRate = RATE_11M;
-			else
-				pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
-		} else {
-			if ((pDevice->eCurrentPHYType == PHY_TYPE_11A) &&
-			    (pDevice->uConnectionRate <= RATE_6M)) {
-				pDevice->wCurrentRate = RATE_6M;
-			} else {
-				if (pDevice->uConnectionRate >= RATE_54M)
-					pDevice->wCurrentRate = RATE_54M;
-				else
-					pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
-
-			}
-		}
-		pDevice->byACKRate = (unsigned char) pDevice->wCurrentRate;
-		pDevice->byTopCCKBasicRate = RATE_1M;
-		pDevice->byTopOFDMBasicRate = RATE_6M;
-	} else {
-		//auto rate
-		if (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {
-			if (pDevice->eCurrentPHYType != PHY_TYPE_11A) {
-				pDevice->wCurrentRate = RATE_1M;
-				pDevice->byACKRate = RATE_1M;
-				pDevice->byTopCCKBasicRate = RATE_1M;
-				pDevice->byTopOFDMBasicRate = RATE_6M;
-			} else {
-				pDevice->wCurrentRate = RATE_6M;
-				pDevice->byACKRate = RATE_6M;
-				pDevice->byTopCCKBasicRate = RATE_1M;
-				pDevice->byTopOFDMBasicRate = RATE_6M;
-			}
-		} else {
-			VNTWIFIvGetTxRate(pDevice->pMgmt,
-					  pDevice->sTxEthHeader.abyDstAddr,
-					  &(pDevice->wCurrentRate),
-					  &(pDevice->byACKRate),
-					  &(pDevice->byTopCCKBasicRate),
-					  &(pDevice->byTopOFDMBasicRate));
-
-		}
-	}
-
-
-	if (pDevice->wCurrentRate <= RATE_11M) {
-		byPktType = PK_TYPE_11B;
-	} else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
-		byPktType = PK_TYPE_11A;
-	} else {
-		if (pDevice->bProtectMode)
-			byPktType = PK_TYPE_11GB;
-		else
-			byPktType = PK_TYPE_11GA;
-	}
-
-	if (bNeedEncryption) {
-		pr_debug("ntohs Pkt Type=%04x\n",
-			 ntohs(pDevice->sTxEthHeader.wType));
-		if ((pDevice->sTxEthHeader.wType) == TYPE_PKT_802_1x) {
-			bNeedEncryption = false;
-			pr_debug("Pkt Type=%04x\n",
-				 (pDevice->sTxEthHeader.wType));
-			if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
-				if (pTransmitKey == NULL) {
-					pr_debug("Don't Find TX KEY\n");
-				} else {
-					if (bTKIP_UseGTK) {
-						pr_debug("error: KEY is GTK!!~~\n");
-					} else {
-						pr_debug("Find PTK [%lX]\n",
-							 pTransmitKey->dwKeyIndex);
-						bNeedEncryption = true;
-					}
-				}
-			}
-
-			if (pDevice->byCntMeasure == 2) {
-				bNeedDeAuth = true;
-				pDevice->s802_11Counter.TKIPCounterMeasuresInvoked++;
-			}
-
-			if (pDevice->bEnableHostWEP) {
-				if ((uNodeIndex != 0) &&
-				    (pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex & PAIRWISE_KEY)) {
-					pr_debug("Find PTK [%lX]\n",
-						 pTransmitKey->dwKeyIndex);
-					bNeedEncryption = true;
-				}
-			}
-		} else {
-			if (pTransmitKey == NULL) {
-				pr_debug("return no tx key\n");
-				dev_kfree_skb_irq(skb);
-				spin_unlock_irq(&pDevice->lock);
-				return 0;
-			}
-		}
-	}
-
-	vGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,
-			    cbFrameBodySize, TYPE_AC0DMA, pHeadTD,
-			    &pDevice->sTxEthHeader, (unsigned char *)skb->data, pTransmitKey, uNodeIndex,
-			    &uMACfragNum,
-			    &cbHeaderSize
-		);
-
-	if (MACbIsRegBitsOn(pDevice->PortOffset, MAC_REG_PSCTL, PSCTL_PS)) {
-		// Disable PS
-		MACbPSWakeup(pDevice->PortOffset);
-	}
-	pDevice->bPWBitOn = false;
-
-	pLastTD = pHeadTD;
-	for (ii = 0; ii < uMACfragNum; ii++) {
-		// Poll Transmit the adapter
-		wmb();
-		pHeadTD->m_td0TD0.f1Owner = OWNED_BY_NIC;
-		wmb();
-		if (ii == uMACfragNum - 1)
-			pLastTD = pHeadTD;
-		pHeadTD = pHeadTD->next;
-	}
-
-	// Save the information needed by the tx interrupt handler
-	// to complete the Send request
-	pLastTD->pTDInfo->skb = skb;
-	pLastTD->pTDInfo->byFlags = 0;
-	pLastTD->pTDInfo->byFlags |= TD_FLAGS_NETIF_SKB;
-	pDevice->nTxDataTimeCout = 0; //2008-8-21 chester <add> for send null packet
-
-	if (AVAIL_TD(pDevice, TYPE_AC0DMA) <= 1)
-		netif_stop_queue(dev);
-
-	pDevice->apCurrTD[TYPE_AC0DMA] = pHeadTD;
-
-	if (pDevice->bFixRate)
-		pr_debug("FixRate:Rate is %d,TxPower is %d\n", pDevice->wCurrentRate, pDevice->byCurPwr);
-
-	{
-		unsigned char Protocol_Version;    //802.1x Authentication
-		unsigned char Packet_Type;           //802.1x Authentication
-		unsigned char Descriptor_type;
-		unsigned short Key_info;
-		bool bTxeapol_key = false;
-
-		Protocol_Version = skb->data[ETH_HLEN];
-		Packet_Type = skb->data[ETH_HLEN+1];
-		Descriptor_type = skb->data[ETH_HLEN+1+1+2];
-		Key_info = (skb->data[ETH_HLEN+1+1+2+1] << 8)|(skb->data[ETH_HLEN+1+1+2+2]);
-		if (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {
-			if (((Protocol_Version == 1) || (Protocol_Version == 2)) &&
-			    (Packet_Type == 3)) {  //802.1x OR eapol-key challenge frame transfer
-				bTxeapol_key = true;
-				if ((Descriptor_type == 254) || (Descriptor_type == 2)) {       //WPA or RSN
-					if (!(Key_info & BIT3) &&   //group-key challenge
-					    (Key_info & BIT8) && (Key_info & BIT9)) {    //send 2/2 key
-						pDevice->fWPA_Authened = true;
-						if (Descriptor_type == 254)
-							pr_debug("WPA ");
-						else
-							pr_debug("WPA2 ");
-						pr_debug("Authentication completed!!\n");
-					}
-				}
-			}
-		}
-	}
-
-	MACvTransmitAC0(pDevice->PortOffset);
-
-	dev->trans_start = jiffies;
-
-	spin_unlock_irq(&pDevice->lock);
-	return 0;
-}
-
 static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 {
 	struct vnt_private *pDevice = dev_instance;
@@ -2096,477 +1392,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 	return IRQ_RETVAL(handled);
 }
 
-static void device_set_multi(struct net_device *dev) {
-	struct vnt_private *pDevice = netdev_priv(dev);
-	PSMgmtObject     pMgmt = pDevice->pMgmt;
-	u32              mc_filter[2];
-	struct netdev_hw_addr *ha;
-
-	VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
-
-	if (dev->flags & IFF_PROMISC) {         /* Set promiscuous. */
-		pr_notice("%s: Promiscuous mode enabled\n", dev->name);
-		/* Unconditionally log net taps. */
-		pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);
-	} else if ((netdev_mc_count(dev) > pDevice->multicast_limit)
-		 ||  (dev->flags & IFF_ALLMULTI)) {
-		MACvSelectPage1(pDevice->PortOffset);
-		VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, 0xffffffff);
-		VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0 + 4, 0xffffffff);
-		MACvSelectPage0(pDevice->PortOffset);
-		pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-	} else {
-		memset(mc_filter, 0, sizeof(mc_filter));
-		netdev_for_each_mc_addr(ha, dev) {
-			int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
-
-			mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
-		}
-		MACvSelectPage1(pDevice->PortOffset);
-		VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, mc_filter[0]);
-		VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0 + 4, mc_filter[1]);
-		MACvSelectPage0(pDevice->PortOffset);
-		pDevice->byRxMode &= ~(RCR_UNICAST);
-		pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-	}
-
-	if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-		// If AP mode, don't enable RCR_UNICAST. Since hw only compare addr1 with local mac.
-		pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-		pDevice->byRxMode &= ~(RCR_UNICAST);
-	}
-
-	VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byRxMode);
-	pr_debug("pDevice->byRxMode = %x\n", pDevice->byRxMode);
-}
-
-static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
-	struct vnt_private *pDevice = netdev_priv(dev);
-	struct iwreq *wrq = (struct iwreq *)rq;
-	int rc = 0;
-	PSMgmtObject pMgmt = pDevice->pMgmt;
-	PSCmdRequest pReq;
-
-	if (pMgmt == NULL) {
-		rc = -EFAULT;
-		return rc;
-	}
-
-	switch (cmd) {
-	case SIOCGIWNAME:
-		rc = iwctl_giwname(dev, NULL, (char *)&(wrq->u.name), NULL);
-		break;
-
-	case SIOCGIWNWID:     //0x8b03  support
-		rc = -EOPNOTSUPP;
-		break;
-
-		// Set frequency/channel
-	case SIOCSIWFREQ:
-		rc = iwctl_siwfreq(dev, NULL, &(wrq->u.freq), NULL);
-		break;
-
-		// Get frequency/channel
-	case SIOCGIWFREQ:
-		rc = iwctl_giwfreq(dev, NULL, &(wrq->u.freq), NULL);
-		break;
-
-		// Set desired network name (ESSID)
-	case SIOCSIWESSID:
-
-	{
-		char essid[IW_ESSID_MAX_SIZE+1];
-
-		if (wrq->u.essid.length > IW_ESSID_MAX_SIZE) {
-			rc = -E2BIG;
-			break;
-		}
-		if (copy_from_user(essid, wrq->u.essid.pointer,
-				   wrq->u.essid.length)) {
-			rc = -EFAULT;
-			break;
-		}
-		rc = iwctl_siwessid(dev, NULL,
-				    &(wrq->u.essid), essid);
-	}
-	break;
-
-	// Get current network name (ESSID)
-	case SIOCGIWESSID:
-
-	{
-		char essid[IW_ESSID_MAX_SIZE+1];
-
-		if (wrq->u.essid.pointer)
-			rc = iwctl_giwessid(dev, NULL,
-					    &(wrq->u.essid), essid);
-		if (copy_to_user(wrq->u.essid.pointer,
-				 essid,
-				 wrq->u.essid.length))
-			rc = -EFAULT;
-	}
-	break;
-
-	case SIOCSIWAP:
-
-		rc = iwctl_siwap(dev, NULL, &(wrq->u.ap_addr), NULL);
-		break;
-
-		// Get current Access Point (BSSID)
-	case SIOCGIWAP:
-		rc = iwctl_giwap(dev, NULL, &(wrq->u.ap_addr), NULL);
-		break;
-
-		// Set desired station name
-	case SIOCSIWNICKN:
-		pr_debug(" SIOCSIWNICKN\n");
-		rc = -EOPNOTSUPP;
-		break;
-
-		// Get current station name
-	case SIOCGIWNICKN:
-		pr_debug(" SIOCGIWNICKN\n");
-		rc = -EOPNOTSUPP;
-		break;
-
-		// Set the desired bit-rate
-	case SIOCSIWRATE:
-		rc = iwctl_siwrate(dev, NULL, &(wrq->u.bitrate), NULL);
-		break;
-
-		// Get the current bit-rate
-	case SIOCGIWRATE:
-
-		rc = iwctl_giwrate(dev, NULL, &(wrq->u.bitrate), NULL);
-		break;
-
-		// Set the desired RTS threshold
-	case SIOCSIWRTS:
-
-		rc = iwctl_siwrts(dev, NULL, &(wrq->u.rts), NULL);
-		break;
-
-		// Get the current RTS threshold
-	case SIOCGIWRTS:
-
-		rc = iwctl_giwrts(dev, NULL, &(wrq->u.rts), NULL);
-		break;
-
-		// Set the desired fragmentation threshold
-	case SIOCSIWFRAG:
-
-		rc = iwctl_siwfrag(dev, NULL, &(wrq->u.frag), NULL);
-		break;
-
-		// Get the current fragmentation threshold
-	case SIOCGIWFRAG:
-
-		rc = iwctl_giwfrag(dev, NULL, &(wrq->u.frag), NULL);
-		break;
-
-		// Set mode of operation
-	case SIOCSIWMODE:
-		rc = iwctl_siwmode(dev, NULL, &(wrq->u.mode), NULL);
-		break;
-
-		// Get mode of operation
-	case SIOCGIWMODE:
-		rc = iwctl_giwmode(dev, NULL, &(wrq->u.mode), NULL);
-		break;
-
-		// Set WEP keys and mode
-	case SIOCSIWENCODE: {
-		char abyKey[WLAN_WEP232_KEYLEN];
-
-		if (wrq->u.encoding.pointer) {
-			if (wrq->u.encoding.length > WLAN_WEP232_KEYLEN) {
-				rc = -E2BIG;
-				break;
-			}
-			memset(abyKey, 0, WLAN_WEP232_KEYLEN);
-			if (copy_from_user(abyKey,
-					   wrq->u.encoding.pointer,
-					   wrq->u.encoding.length)) {
-				rc = -EFAULT;
-				break;
-			}
-		} else if (wrq->u.encoding.length != 0) {
-			rc = -EINVAL;
-			break;
-		}
-		rc = iwctl_siwencode(dev, NULL, &(wrq->u.encoding), abyKey);
-	}
-	break;
-
-	// Get the WEP keys and mode
-	case SIOCGIWENCODE:
-
-		if (!capable(CAP_NET_ADMIN)) {
-			rc = -EPERM;
-			break;
-		}
-		{
-			char abyKey[WLAN_WEP232_KEYLEN];
-
-			rc = iwctl_giwencode(dev, NULL, &(wrq->u.encoding), abyKey);
-			if (rc != 0)
-				break;
-			if (wrq->u.encoding.pointer) {
-				if (copy_to_user(wrq->u.encoding.pointer,
-						 abyKey,
-						 wrq->u.encoding.length))
-					rc = -EFAULT;
-			}
-		}
-		break;
-
-		// Get the current Tx-Power
-	case SIOCGIWTXPOW:
-		pr_debug(" SIOCGIWTXPOW\n");
-		rc = -EOPNOTSUPP;
-		break;
-
-	case SIOCSIWTXPOW:
-		pr_debug(" SIOCSIWTXPOW\n");
-		rc = -EOPNOTSUPP;
-		break;
-
-	case SIOCSIWRETRY:
-
-		rc = iwctl_siwretry(dev, NULL, &(wrq->u.retry), NULL);
-		break;
-
-	case SIOCGIWRETRY:
-
-		rc = iwctl_giwretry(dev, NULL, &(wrq->u.retry), NULL);
-		break;
-
-		// Get range of parameters
-	case SIOCGIWRANGE:
-
-	{
-		struct iw_range range;
-
-		rc = iwctl_giwrange(dev, NULL, &(wrq->u.data), (char *)&range);
-		if (copy_to_user(wrq->u.data.pointer, &range, sizeof(struct iw_range)))
-			rc = -EFAULT;
-	}
-
-	break;
-
-	case SIOCGIWPOWER:
-
-		rc = iwctl_giwpower(dev, NULL, &(wrq->u.power), NULL);
-		break;
-
-	case SIOCSIWPOWER:
-
-		rc = iwctl_siwpower(dev, NULL, &(wrq->u.power), NULL);
-		break;
-
-	case SIOCGIWSENS:
-
-		rc = iwctl_giwsens(dev, NULL, &(wrq->u.sens), NULL);
-		break;
-
-	case SIOCSIWSENS:
-		pr_debug(" SIOCSIWSENS\n");
-		rc = -EOPNOTSUPP;
-		break;
-
-	case SIOCGIWAPLIST: {
-		char buffer[IW_MAX_AP * (sizeof(struct sockaddr) + sizeof(struct iw_quality))];
-
-		if (wrq->u.data.pointer) {
-			rc = iwctl_giwaplist(dev, NULL, &(wrq->u.data), buffer);
-			if (rc == 0) {
-				if (copy_to_user(wrq->u.data.pointer,
-						 buffer,
-						 (wrq->u.data.length * (sizeof(struct sockaddr) +  sizeof(struct iw_quality)))
-					    ))
-					rc = -EFAULT;
-			}
-		}
-	}
-	break;
-
-#ifdef WIRELESS_SPY
-	// Set the spy list
-	case SIOCSIWSPY:
-
-		pr_debug(" SIOCSIWSPY\n");
-		rc = -EOPNOTSUPP;
-		break;
-
-		// Get the spy list
-	case SIOCGIWSPY:
-
-		pr_debug(" SIOCGIWSPY\n");
-		rc = -EOPNOTSUPP;
-		break;
-
-#endif // WIRELESS_SPY
-
-	case SIOCGIWPRIV:
-		pr_debug(" SIOCGIWPRIV\n");
-		rc = -EOPNOTSUPP;
-		break;
-
-//2008-0409-07, <Add> by Einsn Liu
-#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-	case SIOCSIWAUTH:
-		pr_debug(" SIOCSIWAUTH\n");
-		rc = iwctl_siwauth(dev, NULL, &(wrq->u.param), NULL);
-		break;
-
-	case SIOCGIWAUTH:
-		pr_debug(" SIOCGIWAUTH\n");
-		rc = iwctl_giwauth(dev, NULL, &(wrq->u.param), NULL);
-		break;
-
-	case SIOCSIWGENIE:
-		pr_debug(" SIOCSIWGENIE\n");
-		rc = iwctl_siwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
-		break;
-
-	case SIOCGIWGENIE:
-		pr_debug(" SIOCGIWGENIE\n");
-		rc = iwctl_giwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
-		break;
-
-	case SIOCSIWENCODEEXT: {
-		char extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];
-
-		pr_debug(" SIOCSIWENCODEEXT\n");
-		if (wrq->u.encoding.pointer) {
-			memset(extra, 0, sizeof(struct iw_encode_ext)+MAX_KEY_LEN + 1);
-			if (wrq->u.encoding.length > (sizeof(struct iw_encode_ext) + MAX_KEY_LEN)) {
-				rc = -E2BIG;
-				break;
-			}
-			if (copy_from_user(extra, wrq->u.encoding.pointer, wrq->u.encoding.length)) {
-				rc = -EFAULT;
-				break;
-			}
-		} else if (wrq->u.encoding.length != 0) {
-			rc = -EINVAL;
-			break;
-		}
-		rc = iwctl_siwencodeext(dev, NULL, &(wrq->u.encoding), extra);
-	}
-	break;
-
-	case SIOCGIWENCODEEXT:
-		pr_debug(" SIOCGIWENCODEEXT\n");
-		rc = iwctl_giwencodeext(dev, NULL, &(wrq->u.encoding), NULL);
-		break;
-
-	case SIOCSIWMLME:
-		pr_debug(" SIOCSIWMLME\n");
-		rc = iwctl_siwmlme(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
-		break;
-
-#endif // #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-//End Add -- //2008-0409-07, <Add> by Einsn Liu
-
-	case IOCTL_CMD_TEST:
-
-		if (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {
-			rc = -EFAULT;
-			break;
-		}
-		rc = 0;
-		pReq = (PSCmdRequest)rq;
-		pReq->wResult = MAGIC_CODE;
-		break;
-
-	case IOCTL_CMD_SET:
-
-		if (!(pDevice->flags & DEVICE_FLAGS_OPENED) &&
-		    (((PSCmdRequest)rq)->wCmdCode != WLAN_CMD_SET_WPA))	{
-				rc = -EFAULT;
-				break;
-			}
-			rc = 0;
-
-		if (test_and_set_bit(0, (void *)&(pMgmt->uCmdBusy)))
-			return -EBUSY;
-
-		rc = private_ioctl(pDevice, rq);
-		clear_bit(0, (void *)&(pMgmt->uCmdBusy));
-		break;
-
-	case IOCTL_CMD_HOSTAPD:
-
-		rc = vt6655_hostap_ioctl(pDevice, &wrq->u.data);
-		break;
-
-	case IOCTL_CMD_WPA:
-
-		rc = wpa_ioctl(pDevice, &wrq->u.data);
-		break;
-
-	case SIOCETHTOOL:
-		return ethtool_ioctl(dev, rq->ifr_data);
-		// All other calls are currently unsupported
-
-	default:
-		rc = -EOPNOTSUPP;
-		pr_debug("Ioctl command not support..%x\n", cmd);
-
-	}
-
-	if (pDevice->bCommit) {
-		if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-			netif_stop_queue(pDevice->dev);
-			spin_lock_irq(&pDevice->lock);
-			bScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);
-			spin_unlock_irq(&pDevice->lock);
-		} else {
-			pr_debug("Commit the settings\n");
-			spin_lock_irq(&pDevice->lock);
-			pDevice->bLinkPass = false;
-			memset(pMgmt->abyCurrBSSID, 0, 6);
-			pMgmt->eCurrState = WMAC_STATE_IDLE;
-			netif_stop_queue(pDevice->dev);
-#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-			pMgmt->eScanType = WMAC_SCAN_ACTIVE;
-			if (!pDevice->bWPASuppWextEnabled)
-#endif
-				bScheduleCommand((void *)pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);
-			bScheduleCommand((void *)pDevice, WLAN_CMD_SSID, NULL);
-			spin_unlock_irq(&pDevice->lock);
-		}
-		pDevice->bCommit = false;
-	}
-
-	return rc;
-}
-
-static int ethtool_ioctl(struct net_device *dev, void __user *useraddr)
-{
-	u32 ethcmd;
-
-	if (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))
-		return -EFAULT;
-
-	switch (ethcmd) {
-	case ETHTOOL_GDRVINFO: {
-		struct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};
-
-		strncpy(info.driver, DEVICE_NAME, sizeof(info.driver)-1);
-		strncpy(info.version, DEVICE_VERSION, sizeof(info.version)-1);
-		if (copy_to_user(useraddr, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-
-	}
-
-	return -EOPNOTSUPP;
-}
-
 static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 {
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
@@ -3165,7 +1990,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 	/* Enable the chip specified capabilities */
 	priv->flags = priv->sOpts.flags | (pChip_info->flags & 0xff000000UL);
-	priv->tx_80211 = device_dma0_tx_80211;
 
 	wiphy = priv->hw->wiphy;
 

commit f4cf678fd783b7ed6c423b3ac8c1c6faded95986
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:19 2014 +0000

    staging: vt6655: deadcode remove zone file operations and vntconfiguration.dat
    
    These are now all handled by mac80211.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 07d2101613d8..12fa63c73f01 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -303,8 +303,6 @@ static void device_free_rd0_ring(struct vnt_private *pDevice);
 static void device_free_rd1_ring(struct vnt_private *pDevice);
 static void device_free_rings(struct vnt_private *pDevice);
 static void device_free_frag_buf(struct vnt_private *pDevice);
-static int Config_FileGetParameter(unsigned char *string,
-				   unsigned char *dest, unsigned char *source);
 
 /*---------------------  Export Variables  --------------------------*/
 
@@ -412,7 +410,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 	unsigned char byValue1;
 	unsigned char byCCKPwrdBm = 0;
 	unsigned char byOFDMPwrdBm = 0;
-	int zonetype = 0;
 
 	MACbShutdown(pDevice->PortOffset);
 	BBvSoftwareReset(pDevice->PortOffset);
@@ -517,41 +514,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 
 	/* zonetype initial */
 	pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
-	zonetype = Config_FileOperation(pDevice, false, NULL);
-
-	if (zonetype >= 0) {
-		if ((zonetype == 0) &&
-		    (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x00)) {
-			/* for USA */
-			pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0;
-			pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0B;
-
-			pr_debug("Init Zone Type :USA\n");
-		} else if ((zonetype == 1) &&
-			 (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x01)) {
-			/* for Japan */
-			pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x01;
-			pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
-		} else if ((zonetype == 2) &&
-			  (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x02)) {
-			/* for Europe */
-			pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x02;
-			pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
-
-			pr_debug("Init Zone Type :Europe\n");
-		} else {
-			if (zonetype != pDevice->abyEEPROM[EEP_OFS_ZONETYPE])
-				pr_debug("zonetype in file[%02x] mismatch with in EEPROM[%02x]\n",
-					 zonetype,
-					 pDevice->abyEEPROM[EEP_OFS_ZONETYPE]);
-			else
-				pr_debug("Read Zonetype file success,use default zonetype setting[%02x]\n",
-					 zonetype);
-		}
-	} else {
-		pr_debug("Read Zonetype file fail,use default zonetype setting[%02x]\n",
-			 SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ZONETYPE));
-	}
 
 	/* Get RFType */
 	pDevice->byRFType = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RFTYPE);
@@ -595,14 +557,9 @@ static void device_init_registers(struct vnt_private *pDevice)
 	}
 
 	/* recover 12,13 ,14channel for EUROPE by 11 channel */
-	if (((pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Japan) ||
-	     (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Europe)) &&
-	    (pDevice->byOriginalZonetype == ZoneType_USA)) {
-		for (ii = 11; ii < 14; ii++) {
-			pDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];
-			pDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];
-
-		}
+	for (ii = 11; ii < 14; ii++) {
+		pDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];
+		pDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];
 	}
 
 	/* Load OFDM A Power Table */
@@ -2139,70 +2096,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 	return IRQ_RETVAL(handled);
 }
 
-//2008-8-4 <add> by chester
-static int Config_FileGetParameter(unsigned char *string,
-				   unsigned char *dest, unsigned char *source)
-{
-	unsigned char buf1[100];
-	int source_len = strlen(source);
-
-	memset(buf1, 0, 100);
-	strcat(buf1, string);
-	strcat(buf1, "=");
-	source += strlen(buf1);
-
-	memcpy(dest, source, source_len - strlen(buf1));
-	return true;
-}
-
-int Config_FileOperation(struct vnt_private *pDevice,
-			 bool fwrite, unsigned char *Parameter)
-{
-	unsigned char *buffer = kmalloc(1024, GFP_KERNEL);
-	unsigned char tmpbuffer[20];
-	struct file *file;
-	int result = 0;
-
-	if (!buffer) {
-		pr_err("allocate mem for file fail?\n");
-		return -1;
-	}
-	file = filp_open(CONFIG_PATH, O_RDONLY, 0);
-	if (IS_ERR(file)) {
-		kfree(buffer);
-		pr_err("Config_FileOperation:open file fail?\n");
-		return -1;
-	}
-
-	if (kernel_read(file, 0, buffer, 1024) < 0) {
-		pr_err("read file error?\n");
-		result = -1;
-		goto error1;
-	}
-
-	if (Config_FileGetParameter("ZONETYPE", tmpbuffer, buffer) != true) {
-		pr_err("get parameter error?\n");
-		result = -1;
-		goto error1;
-	}
-
-	if (memcmp(tmpbuffer, "USA", 3) == 0) {
-		result = ZoneType_USA;
-	} else if (memcmp(tmpbuffer, "JAPAN", 5) == 0) {
-		result = ZoneType_Japan;
-	} else if (memcmp(tmpbuffer, "EUROPE", 5) == 0) {
-		result = ZoneType_Europe;
-	} else {
-		result = -1;
-		pr_err("Unknown Zonetype[%s]?\n", tmpbuffer);
-	}
-
-error1:
-	kfree(buffer);
-	fput(file);
-	return result;
-}
-
 static void device_set_multi(struct net_device *dev) {
 	struct vnt_private *pDevice = netdev_priv(dev);
 	PSMgmtObject     pMgmt = pDevice->pMgmt;

commit c7b14ea09632cb92658d7b1f758de2abd71c00f3
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:44:09 2014 +0000

    staging: vt6655: reset tsf on dissociation
    
    Ensuring that tsf counter does not run while idle.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 968ea9aa0efb..07d2101613d8 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2980,6 +2980,11 @@ static void vnt_bss_info_changed(struct ieee80211_hw *hw,
 
 			CARDvSetFirstNextTBTT(priv->PortOffset,
 					      conf->beacon_int);
+		} else {
+			VNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL,
+				     TFTCTL_TSFCNTRST);
+			VNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL,
+				     TFTCTL_TSFCNTREN);
 		}
 	}
 }

commit d855802b8d45cf36622a640b71b58437cfee41d0
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:44:08 2014 +0000

    staging: vt6655: don't update bUpdateBBVGA when off channel
    
    Check flag conf IEEE80211_CONF_OFFCHANNEL so that RSSI doesn't swing wildly
    on scanning.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c5eca1075d3a..968ea9aa0efb 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2040,6 +2040,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 			if (pDevice->vif &&
 			    pDevice->op_mode != NL80211_IFTYPE_ADHOC) {
 				if (pDevice->bUpdateBBVGA &&
+				    !(pDevice->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL) &&
 				    pDevice->vif->bss_conf.assoc &&
 				    pDevice->uCurrRSSI) {
 					long            ldBm;

commit 10d6f1b743961b191ff6347d3a5b5f8801a638fe
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:44:04 2014 +0000

    staging: vt6655: device_init_registers replace spin lock
    
    Use spin_lock_irqsave and spin_unlock_irqrestore.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index d7dd002f8daf..c5eca1075d3a 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -406,6 +406,7 @@ device_set_options(struct vnt_private *pDevice)
 
 static void device_init_registers(struct vnt_private *pDevice)
 {
+	unsigned long flags;
 	unsigned int ii;
 	unsigned char byValue;
 	unsigned char byValue1;
@@ -439,11 +440,11 @@ static void device_init_registers(struct vnt_private *pDevice)
 	/* Get Local ID */
 	VNSvInPortB(pDevice->PortOffset + MAC_REG_LOCALID, &pDevice->byLocalID);
 
-	spin_lock_irq(&pDevice->lock);
+	spin_lock_irqsave(&pDevice->lock, flags);
 
 	SROMvReadAllContents(pDevice->PortOffset, pDevice->abyEEPROM);
 
-	spin_unlock_irq(&pDevice->lock);
+	spin_unlock_irqrestore(&pDevice->lock, flags);
 
 	/* Get Channel range */
 	pDevice->byMinChannel = 1;

commit b4bdf94d7dfb0146241185abafb26c3920cb7b33
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:43:59 2014 +0000

    staging: vt6655: vt6655_probe remove management pointers
    
    All these pointers are now dead.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0bd2ca8b49b5..d7dd002f8daf 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3266,8 +3266,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	/* Enable the chip specified capabilities */
 	priv->flags = priv->sOpts.flags | (pChip_info->flags & 0xff000000UL);
 	priv->tx_80211 = device_dma0_tx_80211;
-	priv->sMgmtObj.pAdapter = (void *)priv;
-	priv->pMgmt = &(priv->sMgmtObj);
 
 	wiphy = priv->hw->wiphy;
 

commit 7e5d88d89b22baa3fa69b0f92e1780d1a9e865d6
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:43:58 2014 +0000

    staging: vt6655: mac80211 conversion: device_error remove legacy functions
    
    Remove netif_stop_queue, bCmdRunning and timer functions
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 451b608ca1f1..0bd2ca8b49b5 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1313,10 +1313,6 @@ static void device_error(struct vnt_private *pDevice, unsigned short status)
 	if (status & ISR_FETALERR) {
 		dev_err(&pDevice->pcid->dev, "Hardware fatal error\n");
 
-		netif_stop_queue(pDevice->dev);
-		del_timer(&pDevice->sTimerCommand);
-		del_timer(&(pDevice->pMgmt->sTimerSecondCallback));
-		pDevice->bCmdRunning = false;
 		MACbShutdown(pDevice->PortOffset);
 		return;
 	}

commit 14e5300631fa504058315cc74da66ce18ed41e11
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:43:55 2014 +0000

    staging: vt6655: mac80211 conversion: device_free_info
    
    Remove net device code and add mac80211 unregister code.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 77d81b339158..451b608ca1f1 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -806,31 +806,20 @@ static bool device_get_pci_info(struct vnt_private *pDevice,
 
 static void device_free_info(struct vnt_private *pDevice)
 {
-	struct net_device *dev = pDevice->dev;
-
-	ASSERT(pDevice);
-//2008-0714-01<Add>by chester
-	device_release_WPADEV(pDevice);
-
-//2008-07-21-01<Add>by MikeLiu
-//unregister wpadev
-	if (wpa_set_wpadev(pDevice, 0) != 0)
-		pr_err("unregister wpadev fail?\n");
+	if (!pDevice)
+		return;
 
-#ifdef HOSTAP
-	if (dev)
-		vt6655_hostap_set_hostapd(pDevice, 0, 0);
-#endif
-	if (dev)
-		unregister_netdev(dev);
+	if (pDevice->mac_hw)
+		ieee80211_unregister_hw(pDevice->hw);
 
 	if (pDevice->PortOffset)
 		iounmap(pDevice->PortOffset);
 
 	if (pDevice->pcid)
 		pci_release_regions(pDevice->pcid);
-	if (dev)
-		free_netdev(dev);
+
+	if (pDevice->hw)
+		ieee80211_free_hw(pDevice->hw);
 }
 
 static bool device_init_rings(struct vnt_private *pDevice)

commit 1d6d3c1a62012653df86979658db3b86ef94b63b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:43:54 2014 +0000

    staging: vt6655: mac80211 conversion: device_init_registers remove legacy code
    
    Remove pMgmt, byCurrentCh, VNTWIFIbConfigPhyMode, eEncryptionStatus and netif_stop_queue.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index a888c268042d..77d81b339158 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -412,7 +412,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 	unsigned char byCCKPwrdBm = 0;
 	unsigned char byOFDMPwrdBm = 0;
 	int zonetype = 0;
-	PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
 
 	MACbShutdown(pDevice->PortOffset);
 	BBvSoftwareReset(pDevice->PortOffset);
@@ -616,8 +615,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 					   (unsigned char)(ii + EEP_OFS_OFDMA_PWR_dBm));
 	}
 
-	init_channel_table((void *)pDevice);
-
 	if (pDevice->byLocalID > REV_ID_VT3253_B1) {
 		MACvSelectPage1(pDevice->PortOffset);
 
@@ -652,8 +649,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 	BBvSetRxAntennaMode(pDevice->PortOffset, pDevice->byRxAntennaMode);
 	BBvSetTxAntennaMode(pDevice->PortOffset, pDevice->byTxAntennaMode);
 
-	pDevice->byCurrentCh = 0;
-
 	/* Set BB and packet type at the same time. */
 	/* Set Short Slot Time, xIFS, and RSPINF. */
 	if (pDevice->uConnectionRate == RATE_AUTO)
@@ -661,10 +656,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 	else
 		pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
 
-	/* default G Mode */
-	VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_11G);
-	VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_AUTO);
-
 	pDevice->bRadioOff = false;
 
 	pDevice->byRadioCtl = SROMbyReadEmbedded(pDevice->PortOffset,
@@ -685,8 +676,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 	if (pDevice->bHWRadioOff || pDevice->bRadioControlOff)
 		CARDbRadioPowerOff(pDevice);
 
-	pMgmt->eScanType = WMAC_SCAN_PASSIVE;
-
 	/* get Permanent network address */
 	SROMvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
 	pr_debug("Network address = %pM\n", pDevice->abyCurrentNetAddr);
@@ -699,16 +688,12 @@ static void device_init_registers(struct vnt_private *pDevice)
 	if (pDevice->byLocalID <= REV_ID_VT3253_A1)
 		MACvRegBitsOn(pDevice->PortOffset, MAC_REG_RCR, RCR_WPAERR);
 
-	pDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;
-
 	/* Turn On Rx DMA */
 	MACvReceive0(pDevice->PortOffset);
 	MACvReceive1(pDevice->PortOffset);
 
 	/* start the adapter */
 	MACvStart(pDevice->PortOffset);
-
-	netif_stop_queue(pDevice->dev);
 }
 
 static void device_init_diversity_timer(struct vnt_private *pDevice)

commit 59918beada362e47de3b7a7467573ab001528077
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:43:48 2014 +0000

    staging: vt6655: mac80211 conversion: device_tx_srv tx and add report rates
    
    vnt_int_report_rate reports backs tx rate and is replacment for STAvUpdateTDStatCounter
    and BSSvUpdateNodeTxCounter.
    
    Replacing existing code.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 69c98c2989c4..a888c268042d 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1208,19 +1208,84 @@ bool device_alloc_frag_buf(struct vnt_private *pDevice,
 	return true;
 }
 
+static const u8 fallback_rate0[5][5] = {
+	{RATE_18M, RATE_18M, RATE_12M, RATE_12M, RATE_12M},
+	{RATE_24M, RATE_24M, RATE_18M, RATE_12M, RATE_12M},
+	{RATE_36M, RATE_36M, RATE_24M, RATE_18M, RATE_18M},
+	{RATE_48M, RATE_48M, RATE_36M, RATE_24M, RATE_24M},
+	{RATE_54M, RATE_54M, RATE_48M, RATE_36M, RATE_36M}
+};
+
+static const u8 fallback_rate1[5][5] = {
+	{RATE_18M, RATE_18M, RATE_12M, RATE_6M, RATE_6M},
+	{RATE_24M, RATE_24M, RATE_18M, RATE_6M, RATE_6M},
+	{RATE_36M, RATE_36M, RATE_24M, RATE_12M, RATE_12M},
+	{RATE_48M, RATE_48M, RATE_24M, RATE_12M, RATE_12M},
+	{RATE_54M, RATE_54M, RATE_36M, RATE_18M, RATE_18M}
+};
+
+static int vnt_int_report_rate(struct vnt_private *priv,
+			       PDEVICE_TD_INFO context, u8 tsr0, u8 tsr1)
+{
+	struct vnt_tx_fifo_head *fifo_head;
+	struct ieee80211_tx_info *info;
+	struct ieee80211_rate *rate;
+	u16 fb_option;
+	u8 tx_retry = (tsr0 & TSR0_NCR);
+	s8 idx;
+
+	if (!context)
+		return -ENOMEM;
+
+	if (!context->skb)
+		return -EINVAL;
+
+	fifo_head = (struct vnt_tx_fifo_head *)context->buf;
+	fb_option = (le16_to_cpu(fifo_head->fifo_ctl) &
+			(FIFOCTL_AUTO_FB_0 | FIFOCTL_AUTO_FB_1));
+
+	info = IEEE80211_SKB_CB(context->skb);
+	idx = info->control.rates[0].idx;
+
+	if (fb_option && !(tsr1 & TSR1_TERR)) {
+		u8 tx_rate;
+		u8 retry = tx_retry;
+
+		rate = ieee80211_get_tx_rate(priv->hw, info);
+		tx_rate = rate->hw_value - RATE_18M;
+
+		if (retry > 4)
+			retry = 4;
+
+		if (fb_option & FIFOCTL_AUTO_FB_0)
+			tx_rate = fallback_rate0[tx_rate][retry];
+		else if (fb_option & FIFOCTL_AUTO_FB_1)
+			tx_rate = fallback_rate1[tx_rate][retry];
+
+		if (info->band == IEEE80211_BAND_5GHZ)
+			idx = tx_rate - RATE_6M;
+		else
+			idx = tx_rate;
+	}
+
+	ieee80211_tx_info_clear_status(info);
+
+	info->status.rates[0].count = tx_retry;
+
+	if (!(tsr1 & TSR1_TERR)) {
+		info->status.rates[0].idx = idx;
+		info->flags |= IEEE80211_TX_STAT_ACK;
+	}
+
+	return 0;
+}
+
 static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 {
 	PSTxDesc                 pTD;
-	bool bFull = false;
 	int                      works = 0;
 	unsigned char byTsr0;
 	unsigned char byTsr1;
-	unsigned int	uFrameSize, uFIFOHeaderSize;
-	PSTxBufHead              pTxBufHead;
-	struct net_device_stats *pStats = &pDevice->dev->stats;
-	struct sk_buff *skb;
-	unsigned int	uNodeIndex;
-	PSMgmtObject             pMgmt = pDevice->pMgmt;
 
 	for (pTD = pDevice->apTailTD[uIdx]; pDevice->iTDUsed[uIdx] > 0; pTD = pTD->next) {
 		if (pTD->m_td0TD0.f1Owner == OWNED_BY_NIC)
@@ -1234,22 +1299,8 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 		//Only the status of first TD in the chain is correct
 		if (pTD->m_td1TD1.byTCR & TCR_STP) {
 			if ((pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0) {
-				uFIFOHeaderSize = pTD->pTDInfo->dwHeaderLength;
-				uFrameSize = pTD->pTDInfo->dwReqCount - uFIFOHeaderSize;
-				pTxBufHead = (PSTxBufHead) (pTD->pTDInfo->buf);
-				// Update the statistics based on the Transmit status
-				// now, we DONT check TSR0_CDH
-
-				STAvUpdateTDStatCounter(&pDevice->scStatistic,
-							byTsr0, byTsr1,
-							(unsigned char *)(pTD->pTDInfo->buf + uFIFOHeaderSize),
-							uFrameSize, uIdx);
-
-				BSSvUpdateNodeTxCounter(pDevice,
-							byTsr0, byTsr1,
-							(unsigned char *)(pTD->pTDInfo->buf),
-							uFIFOHeaderSize
-					);
+
+				vnt_int_report_rate(pDevice, pTD->pTDInfo, byTsr0, byTsr1);
 
 				if (!(byTsr1 & TSR1_TERR)) {
 					if (byTsr0 != 0) {
@@ -1257,28 +1308,9 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 							 (int)uIdx, byTsr1,
 							 byTsr0);
 					}
-					if ((pTxBufHead->wFragCtl & FRAGCTL_ENDFRAG) != FRAGCTL_NONFRAG)
-						pDevice->s802_11Counter.TransmittedFragmentCount++;
-
-					pStats->tx_packets++;
-					pStats->tx_bytes += pTD->pTDInfo->skb->len;
 				} else {
 					pr_debug(" Tx[%d] dropped & tsr1[%02X] tsr0[%02X]\n",
 						 (int)uIdx, byTsr1, byTsr0);
-					pStats->tx_errors++;
-					pStats->tx_dropped++;
-				}
-			}
-
-			if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
-				if (pDevice->bEnableHostapd) {
-					pr_debug("tx call back netif..\n");
-					skb = pTD->pTDInfo->skb;
-					skb->dev = pDevice->apdev;
-					skb_reset_mac_header(skb);
-					skb->pkt_type = PACKET_OTHERHOST;
-					memset(skb->cb, 0, sizeof(skb->cb));
-					netif_rx(skb);
 				}
 			}
 
@@ -1287,47 +1319,14 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 					pr_debug(" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X]\n",
 						 (int)uIdx, byTsr1, byTsr0);
 				}
-
-
-				if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) &&
-				    (pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)) {
-					unsigned short wAID;
-					unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
-
-					skb = pTD->pTDInfo->skb;
-					if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data), &uNodeIndex)) {
-						if (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {
-							skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);
-							pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;
-							// set tx map
-							wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
-							pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
-							pTD->pTDInfo->byFlags &= ~(TD_FLAGS_NETIF_SKB);
-							pr_debug("tx_srv:tx fail re-queue sta index= %d, QueCnt= %d\n",
-								 (int)uNodeIndex,
-								 pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt);
-							pStats->tx_errors--;
-							pStats->tx_dropped--;
-						}
-					}
-				}
 			}
 			device_free_tx_buf(pDevice, pTD);
 			pDevice->iTDUsed[uIdx]--;
-		}
-	}
-
-	if (uIdx == TYPE_AC0DMA) {
-		// RESERV_AC0DMA reserved for relay
 
-		if (AVAIL_TD(pDevice, uIdx) < RESERV_AC0DMA) {
-			bFull = true;
-			pr_debug(" AC0DMA is Full = %d\n",
-				 pDevice->iTDUsed[uIdx]);
+			/* Make sure queue is available */
+			if (AVAIL_TD(pDevice, uIdx))
+				ieee80211_wake_queues(pDevice->hw);
 		}
-		if (netif_queue_stopped(pDevice->dev) && !bFull)
-			netif_wake_queue(pDevice->dev);
-
 	}
 
 	pDevice->apTailTD[uIdx] = pTD;
@@ -1360,7 +1359,9 @@ static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)
 				 PCI_DMA_TODEVICE);
 	}
 
-	if ((pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0)
+	if (pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)
+		ieee80211_tx_status_irqsafe(pDevice->hw, skb);
+	else
 		dev_kfree_skb_irq(skb);
 
 	pTDInfo->skb_dma = 0;
@@ -2065,8 +2066,11 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 		}
 
 		if (pDevice->dwIsr & ISR_TBTT) {
-			if (pDevice->op_mode != NL80211_IFTYPE_ADHOC) {
-				if ((pDevice->bUpdateBBVGA) && pDevice->bLinkPass && (pDevice->uCurrRSSI != 0)) {
+			if (pDevice->vif &&
+			    pDevice->op_mode != NL80211_IFTYPE_ADHOC) {
+				if (pDevice->bUpdateBBVGA &&
+				    pDevice->vif->bss_conf.assoc &&
+				    pDevice->uCurrRSSI) {
 					long            ldBm;
 
 					RFvRSSITodBm(pDevice, (unsigned char) pDevice->uCurrRSSI, &ldBm);

commit e70abceb05a36665c3378619217c35acffb14ca4
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:43:47 2014 +0000

    staging: vt6655: mac80211 conversion: changes to device_intr
    
    Remove net device code.
    
    Remove current measure code and function s_vCompleteCurrentMeasure
    and switch code which are now handled by mac80211
    
    Change beaconing to mac80211.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 5ece18401ed4..69c98c2989c4 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -400,45 +400,6 @@ device_set_options(struct vnt_private *pDevice)
 		 (int)pDevice->bDiversityRegCtlON);
 }
 
-static void s_vCompleteCurrentMeasure(struct vnt_private *pDevice,
-				      unsigned char byResult)
-{
-	unsigned int ii;
-	unsigned long dwDuration = 0;
-	unsigned char byRPI0 = 0;
-
-	for (ii = 1; ii < 8; ii++) {
-		pDevice->dwRPIs[ii] *= 255;
-		dwDuration |= *((unsigned short *)(pDevice->pCurrMeasureEID->sReq.abyDuration));
-		dwDuration <<= 10;
-		pDevice->dwRPIs[ii] /= dwDuration;
-		pDevice->abyRPIs[ii] = (unsigned char)pDevice->dwRPIs[ii];
-		byRPI0 += pDevice->abyRPIs[ii];
-	}
-	pDevice->abyRPIs[0] = (0xFF - byRPI0);
-
-	if (pDevice->uNumOfMeasureEIDs == 0) {
-		VNTWIFIbMeasureReport(pDevice->pMgmt,
-				      true,
-				      pDevice->pCurrMeasureEID,
-				      byResult,
-				      pDevice->byBasicMap,
-				      pDevice->byCCAFraction,
-				      pDevice->abyRPIs
-			);
-	} else {
-		VNTWIFIbMeasureReport(pDevice->pMgmt,
-				      false,
-				      pDevice->pCurrMeasureEID,
-				      byResult,
-				      pDevice->byBasicMap,
-				      pDevice->byCCAFraction,
-				      pDevice->abyRPIs
-			);
-		CARDbStartMeasure(pDevice, pDevice->pCurrMeasureEID++, pDevice->uNumOfMeasureEIDs);
-	}
-}
-
 //
 // Initialisation of MAC & BBP registers
 //
@@ -2056,14 +2017,11 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 
 static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 {
-	struct net_device *dev = dev_instance;
-	struct vnt_private *pDevice = netdev_priv(dev);
+	struct vnt_private *pDevice = dev_instance;
 	int             max_count = 0;
 	unsigned long dwMIBCounter = 0;
-	PSMgmtObject    pMgmt = pDevice->pMgmt;
 	unsigned char byOrgPageSel = 0;
 	int             handled = 0;
-	unsigned char byData = 0;
 	int             ii = 0;
 	unsigned long flags;
 
@@ -2106,94 +2064,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 			device_error(pDevice, pDevice->dwIsr);
 		}
 
-		if (pDevice->byLocalID > REV_ID_VT3253_B1) {
-			if (pDevice->dwIsr & ISR_MEASURESTART) {
-				// 802.11h measure start
-				pDevice->byOrgChannel = pDevice->byCurrentCh;
-				VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byOrgRCR));
-				VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, (RCR_RXALLTYPE | RCR_UNICAST | RCR_BROADCAST | RCR_MULTICAST | RCR_WPAERR));
-				MACvSelectPage1(pDevice->PortOffset);
-				VNSvInPortD(pDevice->PortOffset + MAC_REG_MAR0, &(pDevice->dwOrgMAR0));
-				VNSvInPortD(pDevice->PortOffset + MAC_REG_MAR4, &(pDevice->dwOrgMAR4));
-				MACvSelectPage0(pDevice->PortOffset);
-				//xxxx
-				if (set_channel(pDevice, pDevice->pCurrMeasureEID->sReq.byChannel)) {
-					pDevice->bMeasureInProgress = true;
-					MACvSelectPage1(pDevice->PortOffset);
-					MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_READY);
-					MACvSelectPage0(pDevice->PortOffset);
-					pDevice->byBasicMap = 0;
-					pDevice->byCCAFraction = 0;
-					for (ii = 0; ii < 8; ii++)
-						pDevice->dwRPIs[ii] = 0;
-
-				} else {
-					// can not measure because set channel fail
-					// clear measure control
-					MACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);
-					s_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_INCAPABLE);
-					MACvSelectPage1(pDevice->PortOffset);
-					MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
-					MACvSelectPage0(pDevice->PortOffset);
-				}
-			}
-			if (pDevice->dwIsr & ISR_MEASUREEND) {
-				// 802.11h measure end
-				pDevice->bMeasureInProgress = false;
-				VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byOrgRCR);
-				MACvSelectPage1(pDevice->PortOffset);
-				VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, pDevice->dwOrgMAR0);
-				VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR4, pDevice->dwOrgMAR4);
-				VNSvInPortB(pDevice->PortOffset + MAC_REG_MSRBBSTS, &byData);
-				pDevice->byBasicMap |= (byData >> 4);
-				VNSvInPortB(pDevice->PortOffset + MAC_REG_CCAFRACTION, &pDevice->byCCAFraction);
-				VNSvInPortB(pDevice->PortOffset + MAC_REG_MSRCTL, &byData);
-				// clear measure control
-				MACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);
-				MACvSelectPage0(pDevice->PortOffset);
-				set_channel(pDevice, pDevice->byOrgChannel);
-				MACvSelectPage1(pDevice->PortOffset);
-				MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
-				MACvSelectPage0(pDevice->PortOffset);
-				if (byData & MSRCTL_FINISH) {
-					// measure success
-					s_vCompleteCurrentMeasure(pDevice, 0);
-				} else {
-					// can not measure because not ready before end of measure time
-					s_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_LATE);
-				}
-			}
-			if (pDevice->dwIsr & ISR_QUIETSTART) {
-				do {
-					;
-				} while (!CARDbStartQuiet(pDevice));
-			}
-		}
-
 		if (pDevice->dwIsr & ISR_TBTT) {
-			if (pDevice->bEnableFirstQuiet) {
-				pDevice->byQuietStartCount--;
-				if (pDevice->byQuietStartCount == 0) {
-					pDevice->bEnableFirstQuiet = false;
-					MACvSelectPage1(pDevice->PortOffset);
-					MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, (MSRCTL_QUIETTXCHK | MSRCTL_QUIETEN));
-					MACvSelectPage0(pDevice->PortOffset);
-				}
-			}
-			if (pDevice->bChannelSwitch &&
-			    (pDevice->op_mode == NL80211_IFTYPE_STATION)) {
-				pDevice->byChannelSwitchCount--;
-				if (pDevice->byChannelSwitchCount == 0) {
-					pDevice->bChannelSwitch = false;
-					set_channel(pDevice, pDevice->byNewChannel);
-					VNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);
-					MACvSelectPage1(pDevice->PortOffset);
-					MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
-					MACvSelectPage0(pDevice->PortOffset);
-					CARDbStartTxPacket(pDevice, PKT_TYPE_802_11_ALL);
-
-				}
-			}
 			if (pDevice->op_mode != NL80211_IFTYPE_ADHOC) {
 				if ((pDevice->bUpdateBBVGA) && pDevice->bLinkPass && (pDevice->uCurrRSSI != 0)) {
 					long            ldBm;
@@ -2234,10 +2105,11 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 			if (pDevice->bEnablePSMode)
 				PSbIsNextTBTTWakeUp((void *)pDevice);
 
-			if ((pDevice->op_mode == NL80211_IFTYPE_AP) ||
-			    (pDevice->op_mode == NL80211_IFTYPE_ADHOC)) {
+			if ((pDevice->op_mode == NL80211_IFTYPE_AP ||
+			    pDevice->op_mode == NL80211_IFTYPE_ADHOC) &&
+			    pDevice->vif->bss_conf.enable_beacon) {
 				MACvOneShotTimer1MicroSec(pDevice->PortOffset,
-							  (pMgmt->wIBSSBeaconPeriod - MAKE_BEACON_RESERVED) << 10);
+							  (pDevice->vif->bss_conf.beacon_int - MAKE_BEACON_RESERVED) << 10);
 			}
 
 			/* TODO: adhoc PS mode */
@@ -2250,34 +2122,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 				pDevice->cbBeaconBufReadySetCnt = 0;
 			}
 
-			if (pDevice->op_mode == NL80211_IFTYPE_AP) {
-				if (pMgmt->byDTIMCount > 0) {
-					pMgmt->byDTIMCount--;
-					pMgmt->sNodeDBTable[0].bRxPSPoll = false;
-				} else {
-					if (pMgmt->byDTIMCount == 0) {
-						// check if mutltcast tx bufferring
-						pMgmt->byDTIMCount = pMgmt->byDTIMPeriod - 1;
-						pMgmt->sNodeDBTable[0].bRxPSPoll = true;
-						bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-					}
-				}
-			}
 			pDevice->bBeaconSent = true;
-
-			if (pDevice->bChannelSwitch) {
-				pDevice->byChannelSwitchCount--;
-				if (pDevice->byChannelSwitchCount == 0) {
-					pDevice->bChannelSwitch = false;
-					set_channel(pDevice, pDevice->byNewChannel);
-					VNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);
-					MACvSelectPage1(pDevice->PortOffset);
-					MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
-					MACvSelectPage0(pDevice->PortOffset);
-					CARDbStartTxPacket(pDevice, PKT_TYPE_802_11_ALL);
-				}
-			}
-
 		}
 
 		if (pDevice->dwIsr & ISR_RXDMA0)
@@ -2293,14 +2138,10 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 			max_count += device_tx_srv(pDevice, TYPE_AC0DMA);
 
 		if (pDevice->dwIsr & ISR_SOFTTIMER1) {
-			if (pDevice->op_mode == NL80211_IFTYPE_AP) {
-				if (pDevice->bShortSlotTime)
-					pMgmt->wCurrCapInfo |= WLAN_SET_CAP_INFO_SHORTSLOTTIME(1);
-				else
-					pMgmt->wCurrCapInfo &= ~(WLAN_SET_CAP_INFO_SHORTSLOTTIME(1));
+			if (pDevice->vif) {
+				if (pDevice->vif->bss_conf.enable_beacon)
+					vnt_beacon_make(pDevice, pDevice->vif);
 			}
-			bMgrPrepareBeaconToSend(pDevice, pMgmt);
-			pDevice->byCntMeasure = 0;
 		}
 
 		MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);

commit bc5d431c9b11f39c81dea25748e18014f3e210f4
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:43:46 2014 +0000

    staging: vt6655: mac80211 conversion: device_print_info remove netdevice.
    
    use dev_info for device name and pcid->irq for irq number.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index b0f94a804ceb..5ece18401ed4 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -809,12 +809,11 @@ static const struct net_device_ops device_netdev_ops = {
 
 static void device_print_info(struct vnt_private *pDevice)
 {
-	struct net_device *dev = pDevice->dev;
+	dev_info(&pDevice->pcid->dev, "%s\n", get_chip_name(pDevice->chip_id));
 
-	pr_info("%s: %s\n", dev->name, get_chip_name(pDevice->chip_id));
-	pr_info("%s: MAC=%pM IO=0x%lx Mem=0x%lx IRQ=%d\n",
-		dev->name, dev->dev_addr, (unsigned long)pDevice->ioaddr,
-		(unsigned long)pDevice->PortOffset, pDevice->dev->irq);
+	dev_info(&pDevice->pcid->dev, "MAC=%pM IO=0x%lx Mem=0x%lx IRQ=%d\n",
+		 pDevice->abyCurrentNetAddr, (unsigned long)pDevice->ioaddr,
+		 (unsigned long)pDevice->PortOffset, pDevice->pcid->irq);
 }
 
 static void vt6655_init_info(struct pci_dev *pcid,

commit 000fe0f53433a4dea2738c3cb34e19d2ef952092
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:43:45 2014 +0000

    staging: vt6655: mac80211 conversion replace suspend resume functions
    
    add vt6655_suspend and vt6655_resume
    
    remove viawget_suspend and viawget_resume.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 054841b0663a..b0f94a804ceb 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -274,8 +274,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 
 #ifdef CONFIG_PM
 static int device_notify_reboot(struct notifier_block *, unsigned long event, void *ptr);
-static int viawget_suspend(struct pci_dev *pcid, pm_message_t state);
-static int viawget_resume(struct pci_dev *pcid);
 static struct notifier_block device_notifier = {
 	.notifier_call = device_notify_reboot,
 	.next = NULL,
@@ -3482,6 +3480,37 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 /*------------------------------------------------------------------*/
 
+#ifdef CONFIG_PM
+static int vt6655_suspend(struct pci_dev *pcid, pm_message_t state)
+{
+	struct vnt_private *priv = pci_get_drvdata(pcid);
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	pci_save_state(pcid);
+
+	MACbShutdown(priv->PortOffset);
+
+	pci_disable_device(pcid);
+	pci_set_power_state(pcid, pci_choose_state(pcid, state));
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+
+static int vt6655_resume(struct pci_dev *pcid)
+{
+
+	pci_set_power_state(pcid, PCI_D0);
+	pci_enable_wake(pcid, PCI_D0, 0);
+	pci_restore_state(pcid);
+
+	return 0;
+}
+#endif
+
 MODULE_DEVICE_TABLE(pci, vt6655_pci_id_table);
 
 static struct pci_driver device_driver = {
@@ -3490,8 +3519,8 @@ static struct pci_driver device_driver = {
 	.probe = vt6655_probe,
 	.remove = vt6655_remove,
 #ifdef CONFIG_PM
-	.suspend = viawget_suspend,
-	.resume = viawget_resume,
+	.suspend = vt6655_suspend,
+	.resume = vt6655_resume,
 #endif
 };
 
@@ -3532,75 +3561,10 @@ device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
 		for_each_pci_dev(pdev) {
 			if (pci_dev_driver(pdev) == &device_driver) {
 				if (pci_get_drvdata(pdev))
-					viawget_suspend(pdev, PMSG_HIBERNATE);
+					vt6655_suspend(pdev, PMSG_HIBERNATE);
 			}
 		}
 	}
 	return NOTIFY_DONE;
 }
-
-static int
-viawget_suspend(struct pci_dev *pcid, pm_message_t state)
-{
-	int power_status;   // to silence the compiler
-
-	struct vnt_private *pDevice = pci_get_drvdata(pcid);
-	PSMgmtObject  pMgmt = pDevice->pMgmt;
-
-	netif_stop_queue(pDevice->dev);
-	spin_lock_irq(&pDevice->lock);
-	pci_save_state(pcid);
-	del_timer(&pDevice->sTimerCommand);
-	del_timer(&pMgmt->sTimerSecondCallback);
-	pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
-	pDevice->uCmdDequeueIdx = 0;
-	pDevice->uCmdEnqueueIdx = 0;
-	pDevice->bCmdRunning = false;
-	MACbShutdown(pDevice->PortOffset);
-	MACvSaveContext(pDevice->PortOffset, pDevice->abyMacContext);
-	pDevice->bLinkPass = false;
-	memset(pMgmt->abyCurrBSSID, 0, 6);
-	pMgmt->eCurrState = WMAC_STATE_IDLE;
-	pci_disable_device(pcid);
-	power_status = pci_set_power_state(pcid, pci_choose_state(pcid, state));
-	spin_unlock_irq(&pDevice->lock);
-	return 0;
-}
-
-static int
-viawget_resume(struct pci_dev *pcid)
-{
-	struct vnt_private *pDevice = pci_get_drvdata(pcid);
-	PSMgmtObject  pMgmt = pDevice->pMgmt;
-	int power_status;   // to silence the compiler
-
-	power_status = pci_set_power_state(pcid, PCI_D0);
-	power_status = pci_enable_wake(pcid, PCI_D0, 0);
-	pci_restore_state(pcid);
-	if (netif_running(pDevice->dev)) {
-		spin_lock_irq(&pDevice->lock);
-		MACvRestoreContext(pDevice->PortOffset, pDevice->abyMacContext);
-		device_init_registers(pDevice);
-		if (pMgmt->sNodeDBTable[0].bActive) { // Assoc with BSS
-			pMgmt->sNodeDBTable[0].bActive = false;
-			pDevice->bLinkPass = false;
-			if (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
-				// In Adhoc, BSS state set back to started.
-				pMgmt->eCurrState = WMAC_STATE_STARTED;
-			} else {
-				pMgmt->eCurrMode = WMAC_MODE_STANDBY;
-				pMgmt->eCurrState = WMAC_STATE_IDLE;
-			}
-		}
-		init_timer(&pMgmt->sTimerSecondCallback);
-		init_timer(&pDevice->sTimerCommand);
-		MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
-		BSSvClearBSSList((void *)pDevice, pDevice->bLinkPass);
-		bScheduleCommand((void *)pDevice, WLAN_CMD_BSSID_SCAN, NULL);
-		bScheduleCommand((void *)pDevice, WLAN_CMD_SSID, NULL);
-		spin_unlock_irq(&pDevice->lock);
-	}
-	return 0;
-}
-
 #endif

commit 3d75b9e235e4cd99cbf44e3d5084c6066299e53d
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:43:44 2014 +0000

    staging: vt6655: mac80211 conversion add channel bands
    
    Add rates and channels according to rf type for vnt_init_bands which is a
    mac80211 replacement for init_channel_table.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 23d934400783..054841b0663a 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3320,6 +3320,8 @@ int vnt_init(struct vnt_private *priv)
 {
 	SET_IEEE80211_PERM_ADDR(priv->hw, priv->abyCurrentNetAddr);
 
+	vnt_init_bands(priv);
+
 	if (ieee80211_register_hw(priv->hw))
 		return -ENODEV;
 

commit 67013f2c0e5811a4fd60c51e3233e1f027d1c1e0
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:43:43 2014 +0000

    staging: vt6655: mac80211 conversion add main mac80211 functions
    
    Replace existing vt6655_probe with one converted to mac80211
    with the following operations
    
    vnt_tx_80211
    vnt_start
    vnt_stop
    vnt_add_interface
    vnt_remove_interface
    vnt_config
    vnt_bss_info_changed
    vnt_prepare_multicast
    vnt_configure
    vnt_set_key
    vnt_get_tsf
    vnt_set_tsf
    vnt_reset_tsf
    
    The following variables are also added.
    basic_rates
    mc_list_count
    mac_hw
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 84a35d7d01e8..23d934400783 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -809,142 +809,6 @@ static const struct net_device_ops device_netdev_ops = {
 	.ndo_set_rx_mode	= device_set_multi,
 };
 
-static int
-vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
-{
-	static bool bFirst = true;
-	struct net_device *dev = NULL;
-	PCHIP_INFO  pChip_info = (PCHIP_INFO)ent->driver_data;
-	struct vnt_private *pDevice;
-	int         rc;
-
-	dev = alloc_etherdev(sizeof(*pDevice));
-
-	pDevice = netdev_priv(dev);
-
-	if (dev == NULL) {
-		pr_err(DEVICE_NAME ": allocate net device failed\n");
-		return -ENOMEM;
-	}
-
-	// Chain it all together
-	SET_NETDEV_DEV(dev, &pcid->dev);
-
-	if (bFirst) {
-		pr_notice("%s Ver. %s\n", DEVICE_FULL_DRV_NAM, DEVICE_VERSION);
-		pr_notice("Copyright (c) 2003 VIA Networking Technologies, Inc.\n");
-		bFirst = false;
-	}
-
-	vt6655_init_info(pcid, &pDevice, pChip_info);
-	pDevice->dev = dev;
-
-	if (pci_enable_device(pcid)) {
-		device_free_info(pDevice);
-		return -ENODEV;
-	}
-	dev->irq = pcid->irq;
-
-#ifdef	DEBUG
-	pr_debug("Before get pci_info memaddr is %x\n", pDevice->memaddr);
-#endif
-	if (!device_get_pci_info(pDevice, pcid)) {
-		pr_err(DEVICE_NAME ": Failed to find PCI device.\n");
-		device_free_info(pDevice);
-		return -ENODEV;
-	}
-
-#ifdef	DEBUG
-
-	pr_debug("after get pci_info memaddr is %x, io addr is %x,io_size is %d\n", pDevice->memaddr, pDevice->ioaddr, pDevice->io_size);
-	{
-		int i;
-		u32 bar, len;
-		u32 address[] = {
-			PCI_BASE_ADDRESS_0,
-			PCI_BASE_ADDRESS_1,
-			PCI_BASE_ADDRESS_2,
-			PCI_BASE_ADDRESS_3,
-			PCI_BASE_ADDRESS_4,
-			PCI_BASE_ADDRESS_5,
-			0};
-		for (i = 0; address[i]; i++) {
-			pci_read_config_dword(pcid, address[i], &bar);
-			pr_debug("bar %d is %x\n", i, bar);
-			if (!bar) {
-				pr_debug("bar %d not implemented\n", i);
-				continue;
-			}
-			if (bar & PCI_BASE_ADDRESS_SPACE_IO) {
-				/* This is IO */
-
-				len = bar & (PCI_BASE_ADDRESS_IO_MASK & 0xFFFF);
-				len = len & ~(len - 1);
-
-				pr_debug("IO space:  len in IO %x, BAR %d\n", len, i);
-			} else {
-				len = bar & 0xFFFFFFF0;
-				len = ~len + 1;
-
-				pr_debug("len in MEM %x, BAR %d\n", len, i);
-			}
-		}
-	}
-#endif
-
-	pDevice->PortOffset = ioremap(pDevice->memaddr & PCI_BASE_ADDRESS_MEM_MASK, pDevice->io_size);
-
-	if (pDevice->PortOffset == NULL) {
-		pr_err(DEVICE_NAME ": Failed to IO remapping ..\n");
-		device_free_info(pDevice);
-		return -ENODEV;
-	}
-
-	rc = pci_request_regions(pcid, DEVICE_NAME);
-	if (rc) {
-		pr_err(DEVICE_NAME ": Failed to find PCI device\n");
-		device_free_info(pDevice);
-		return -ENODEV;
-	}
-
-	dev->base_addr = pDevice->ioaddr;
-	// do reset
-	if (!MACbSoftwareReset(pDevice->PortOffset)) {
-		pr_err(DEVICE_NAME ": Failed to access MAC hardware..\n");
-		device_free_info(pDevice);
-		return -ENODEV;
-	}
-	// initial to reload eeprom
-	MACvInitialize(pDevice->PortOffset);
-	MACvReadEtherAddress(pDevice->PortOffset, dev->dev_addr);
-
-	device_get_options(pDevice);
-	device_set_options(pDevice);
-	//Mask out the options cannot be set to the chip
-	pDevice->sOpts.flags &= pChip_info->flags;
-
-	//Enable the chip specified capabilities
-	pDevice->flags = pDevice->sOpts.flags | (pChip_info->flags & 0xFF000000UL);
-	pDevice->tx_80211 = device_dma0_tx_80211;
-	pDevice->sMgmtObj.pAdapter = (void *)pDevice;
-	pDevice->pMgmt = &(pDevice->sMgmtObj);
-
-	dev->irq                = pcid->irq;
-	dev->netdev_ops         = &device_netdev_ops;
-
-	dev->wireless_handlers = &iwctl_handler_def;
-
-	rc = register_netdev(dev);
-	if (rc) {
-		pr_err(DEVICE_NAME " Failed to register netdev\n");
-		device_free_info(pDevice);
-		return -ENODEV;
-	}
-	device_print_info(pDevice);
-	pci_set_drvdata(pcid, pDevice);
-	return 0;
-}
-
 static void device_print_info(struct vnt_private *pDevice)
 {
 	struct net_device *dev = pDevice->dev;
@@ -2996,6 +2860,624 @@ static int ethtool_ioctl(struct net_device *dev, void __user *useraddr)
 	return -EOPNOTSUPP;
 }
 
+static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	PSTxDesc head_td;
+	u32 dma_idx = TYPE_AC0DMA;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (!ieee80211_is_data(hdr->frame_control))
+		dma_idx = TYPE_TXDMA0;
+
+	if (AVAIL_TD(priv, dma_idx) < 1) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return -ENOMEM;
+	}
+
+	head_td = priv->apCurrTD[dma_idx];
+
+	head_td->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
+
+	head_td->pTDInfo->skb = skb;
+
+	priv->iTDUsed[dma_idx]++;
+
+	/* Take ownership */
+	wmb();
+	head_td->m_td0TD0.f1Owner = OWNED_BY_NIC;
+
+	/* get Next */
+	wmb();
+	priv->apCurrTD[dma_idx] = head_td->next;
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	vnt_generate_fifo_header(priv, dma_idx, head_td, skb);
+
+	if (MACbIsRegBitsOn(priv->PortOffset, MAC_REG_PSCTL, PSCTL_PS))
+		MACbPSWakeup(priv->PortOffset);
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	priv->bPWBitOn = false;
+
+	head_td->pTDInfo->byFlags = TD_FLAGS_NETIF_SKB;
+
+	if (dma_idx == TYPE_AC0DMA)
+		MACvTransmitAC0(priv->PortOffset);
+	else
+		MACvTransmit0(priv->PortOffset);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+
+static void vnt_tx_80211(struct ieee80211_hw *hw,
+			 struct ieee80211_tx_control *control,
+			 struct sk_buff *skb)
+{
+	struct vnt_private *priv = hw->priv;
+
+	ieee80211_stop_queues(hw);
+
+	if (vnt_tx_packet(priv, skb)) {
+		ieee80211_free_txskb(hw, skb);
+
+		ieee80211_wake_queues(hw);
+	}
+}
+
+static int vnt_start(struct ieee80211_hw *hw)
+{
+	struct vnt_private *priv = hw->priv;
+	int ret;
+
+	priv->rx_buf_sz = PKT_BUF_SZ;
+	if (!device_init_rings(priv))
+		return -ENOMEM;
+
+	ret = request_irq(priv->pcid->irq, &device_intr,
+			  IRQF_SHARED, "vt6655", priv);
+	if (ret) {
+		dev_dbg(&priv->pcid->dev, "failed to start irq\n");
+		return ret;
+	}
+
+	dev_dbg(&priv->pcid->dev, "call device init rd0 ring\n");
+	device_init_rd0_ring(priv);
+	device_init_rd1_ring(priv);
+	device_init_defrag_cb(priv);
+	device_init_td0_ring(priv);
+	device_init_td1_ring(priv);
+
+	device_init_registers(priv);
+
+	dev_dbg(&priv->pcid->dev, "call MACvIntEnable\n");
+	MACvIntEnable(priv->PortOffset, IMR_MASK_VALUE);
+
+	ieee80211_wake_queues(hw);
+
+	return 0;
+}
+
+static void vnt_stop(struct ieee80211_hw *hw)
+{
+	struct vnt_private *priv = hw->priv;
+
+	ieee80211_stop_queues(hw);
+
+	MACbShutdown(priv->PortOffset);
+	MACbSoftwareReset(priv->PortOffset);
+	CARDbRadioPowerOff(priv);
+
+	device_free_td0_ring(priv);
+	device_free_td1_ring(priv);
+	device_free_rd0_ring(priv);
+	device_free_rd1_ring(priv);
+	device_free_frag_buf(priv);
+	device_free_rings(priv);
+
+	free_irq(priv->pcid->irq, priv);
+}
+
+static int vnt_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct vnt_private *priv = hw->priv;
+
+	priv->vif = vif;
+
+	switch (vif->type) {
+	case NL80211_IFTYPE_STATION:
+		if (priv->bDiversityRegCtlON)
+			device_init_diversity_timer(priv);
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		MACvRegBitsOff(priv->PortOffset, MAC_REG_RCR, RCR_UNICAST);
+
+		MACvRegBitsOn(priv->PortOffset, MAC_REG_HOSTCR, HOSTCR_ADHOC);
+
+		break;
+	case NL80211_IFTYPE_AP:
+		MACvRegBitsOff(priv->PortOffset, MAC_REG_RCR, RCR_UNICAST);
+
+		MACvRegBitsOn(priv->PortOffset, MAC_REG_HOSTCR, HOSTCR_AP);
+
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	priv->op_mode = vif->type;
+
+	return 0;
+}
+
+static void vnt_remove_interface(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif)
+{
+	struct vnt_private *priv = hw->priv;
+
+	switch (vif->type) {
+	case NL80211_IFTYPE_STATION:
+		if (priv->bDiversityRegCtlON) {
+			del_timer(&priv->TimerSQ3Tmax1);
+			del_timer(&priv->TimerSQ3Tmax2);
+			del_timer(&priv->TimerSQ3Tmax3);
+		}
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		MACvRegBitsOff(priv->PortOffset, MAC_REG_TCR, TCR_AUTOBCNTX);
+		MACvRegBitsOff(priv->PortOffset,
+			       MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
+		MACvRegBitsOff(priv->PortOffset, MAC_REG_HOSTCR, HOSTCR_ADHOC);
+		break;
+	case NL80211_IFTYPE_AP:
+		MACvRegBitsOff(priv->PortOffset, MAC_REG_TCR, TCR_AUTOBCNTX);
+		MACvRegBitsOff(priv->PortOffset,
+			       MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
+		MACvRegBitsOff(priv->PortOffset, MAC_REG_HOSTCR, HOSTCR_AP);
+		break;
+	default:
+		break;
+	}
+
+	priv->op_mode = NL80211_IFTYPE_UNSPECIFIED;
+}
+
+
+static int vnt_config(struct ieee80211_hw *hw, u32 changed)
+{
+	struct vnt_private *priv = hw->priv;
+	struct ieee80211_conf *conf = &hw->conf;
+	u8 bb_type;
+
+	if (changed & IEEE80211_CONF_CHANGE_PS) {
+		if (conf->flags & IEEE80211_CONF_PS)
+			PSvEnablePowerSaving(priv, conf->listen_interval);
+		else
+			PSvDisablePowerSaving(priv);
+	}
+
+	if ((changed & IEEE80211_CONF_CHANGE_CHANNEL) ||
+	    (conf->flags & IEEE80211_CONF_OFFCHANNEL)) {
+		set_channel(priv, conf->chandef.chan->hw_value);
+
+		if (conf->chandef.chan->band == IEEE80211_BAND_5GHZ)
+			bb_type = BB_TYPE_11A;
+		else
+			bb_type = BB_TYPE_11G;
+
+		if (priv->byBBType != bb_type) {
+			priv->byBBType = bb_type;
+
+			CARDbSetPhyParameter(priv,
+					     priv->byBBType, 0, 0, NULL, NULL);
+		}
+	}
+
+	if (changed & IEEE80211_CONF_CHANGE_POWER) {
+		if (priv->byBBType == BB_TYPE_11B)
+			priv->wCurrentRate = RATE_1M;
+		else
+			priv->wCurrentRate = RATE_54M;
+
+		RFbSetPower(priv, priv->wCurrentRate,
+			    conf->chandef.chan->hw_value);
+	}
+
+	return 0;
+}
+
+static void vnt_bss_info_changed(struct ieee80211_hw *hw,
+		struct ieee80211_vif *vif, struct ieee80211_bss_conf *conf,
+		u32 changed)
+{
+	struct vnt_private *priv = hw->priv;
+
+	priv->current_aid = conf->aid;
+
+	if (changed & BSS_CHANGED_BSSID)
+		MACvWriteBSSIDAddress(priv->PortOffset, (u8 *)conf->bssid);
+
+	if (changed & BSS_CHANGED_BASIC_RATES) {
+		priv->basic_rates = conf->basic_rates;
+
+		CARDvUpdateBasicTopRate(priv);
+
+		dev_dbg(&priv->pcid->dev,
+			"basic rates %x\n", conf->basic_rates);
+	}
+
+	if (changed & BSS_CHANGED_ERP_PREAMBLE) {
+		if (conf->use_short_preamble) {
+			MACvEnableBarkerPreambleMd(priv->PortOffset);
+			priv->byPreambleType = true;
+		} else {
+			MACvDisableBarkerPreambleMd(priv->PortOffset);
+			priv->byPreambleType = false;
+		}
+	}
+
+	if (changed & BSS_CHANGED_ERP_CTS_PROT) {
+		if (conf->use_cts_prot)
+			MACvEnableProtectMD(priv->PortOffset);
+		else
+			MACvDisableProtectMD(priv->PortOffset);
+	}
+
+	if (changed & BSS_CHANGED_ERP_SLOT) {
+		if (conf->use_short_slot)
+			priv->bShortSlotTime = true;
+		else
+			priv->bShortSlotTime = false;
+
+		vUpdateIFS(priv);
+		CARDbSetPhyParameter(priv, priv->byBBType, 0, 0, NULL, NULL);
+		BBvSetVGAGainOffset(priv, priv->abyBBVGA[0]);
+	}
+
+	if (changed & BSS_CHANGED_TXPOWER)
+		RFbSetPower(priv, priv->wCurrentRate,
+			    conf->chandef.chan->hw_value);
+
+	if (changed & BSS_CHANGED_BEACON_ENABLED) {
+		dev_dbg(&priv->pcid->dev,
+			"Beacon enable %d\n", conf->enable_beacon);
+
+		if (conf->enable_beacon) {
+			vnt_beacon_enable(priv, vif, conf);
+
+			MACvRegBitsOn(priv, MAC_REG_TCR, TCR_AUTOBCNTX);
+		} else {
+			MACvRegBitsOff(priv, MAC_REG_TCR, TCR_AUTOBCNTX);
+		}
+	}
+
+	if (changed & BSS_CHANGED_ASSOC && priv->op_mode != NL80211_IFTYPE_AP) {
+		if (conf->assoc) {
+			CARDbUpdateTSF(priv, conf->beacon_rate->hw_value,
+				       conf->sync_device_ts, conf->sync_tsf);
+
+			CARDbSetBeaconPeriod(priv, conf->beacon_int);
+
+			CARDvSetFirstNextTBTT(priv->PortOffset,
+					      conf->beacon_int);
+		}
+	}
+}
+
+static u64 vnt_prepare_multicast(struct ieee80211_hw *hw,
+	struct netdev_hw_addr_list *mc_list)
+{
+	struct vnt_private *priv = hw->priv;
+	struct netdev_hw_addr *ha;
+	u64 mc_filter = 0;
+	u32 bit_nr = 0;
+
+	netdev_hw_addr_list_for_each(ha, mc_list) {
+		bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
+
+		mc_filter |= 1ULL << (bit_nr & 0x3f);
+	}
+
+	priv->mc_list_count = mc_list->count;
+
+	return mc_filter;
+}
+
+static void vnt_configure(struct ieee80211_hw *hw,
+	unsigned int changed_flags, unsigned int *total_flags, u64 multicast)
+{
+	struct vnt_private *priv = hw->priv;
+	u8 rx_mode = 0;
+
+	*total_flags &= FIF_ALLMULTI | FIF_OTHER_BSS | FIF_PROMISC_IN_BSS |
+		FIF_BCN_PRBRESP_PROMISC;
+
+	VNSvInPortB(priv->PortOffset + MAC_REG_RCR, &rx_mode);
+
+	dev_dbg(&priv->pcid->dev, "rx mode in = %x\n", rx_mode);
+
+	if (changed_flags & FIF_PROMISC_IN_BSS) {
+		/* unconditionally log net taps */
+		if (*total_flags & FIF_PROMISC_IN_BSS)
+			rx_mode |= RCR_UNICAST;
+		else
+			rx_mode &= ~RCR_UNICAST;
+	}
+
+	if (changed_flags & FIF_ALLMULTI) {
+		if (*total_flags & FIF_ALLMULTI) {
+			if (priv->mc_list_count > 2) {
+				MACvSelectPage1(priv->PortOffset);
+
+				VNSvOutPortD(priv->PortOffset +
+					     MAC_REG_MAR0, 0xffffffff);
+				VNSvOutPortD(priv->PortOffset +
+					    MAC_REG_MAR0 + 4, 0xffffffff);
+
+				MACvSelectPage0(priv->PortOffset);
+			} else {
+				MACvSelectPage1(priv->PortOffset);
+
+				VNSvOutPortD(priv->PortOffset +
+					     MAC_REG_MAR0, (u32)multicast);
+				VNSvOutPortD(priv->PortOffset +
+					     MAC_REG_MAR0 + 4,
+					     (u32)(multicast >> 32));
+
+				MACvSelectPage0(priv->PortOffset);
+			}
+
+			rx_mode |= RCR_MULTICAST | RCR_BROADCAST;
+		} else {
+			rx_mode &= ~(RCR_MULTICAST | RCR_BROADCAST);
+		}
+	}
+
+	if (changed_flags & (FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC)) {
+		rx_mode |= RCR_MULTICAST | RCR_BROADCAST;
+
+		if (*total_flags & (FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC))
+			rx_mode &= ~RCR_BSSID;
+		else
+			rx_mode |= RCR_BSSID;
+	}
+
+	VNSvOutPortB(priv->PortOffset + MAC_REG_RCR, rx_mode);
+
+	dev_dbg(&priv->pcid->dev, "rx mode out= %x\n", rx_mode);
+}
+
+static int vnt_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
+	struct ieee80211_vif *vif, struct ieee80211_sta *sta,
+		struct ieee80211_key_conf *key)
+{
+	struct vnt_private *priv = hw->priv;
+
+	switch (cmd) {
+	case SET_KEY:
+		if (vnt_set_keys(hw, sta, vif, key))
+			return -EOPNOTSUPP;
+		break;
+	case DISABLE_KEY:
+		if (test_bit(key->hw_key_idx, &priv->key_entry_inuse))
+			clear_bit(key->hw_key_idx, &priv->key_entry_inuse);
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static u64 vnt_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct vnt_private *priv = hw->priv;
+	u64 tsf;
+
+	CARDbGetCurrentTSF(priv->PortOffset, &tsf);
+
+	return tsf;
+}
+
+static void vnt_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			u64 tsf)
+{
+	struct vnt_private *priv = hw->priv;
+
+	CARDvUpdateNextTBTT(priv->PortOffset, tsf, vif->bss_conf.beacon_int);
+}
+
+static void vnt_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct vnt_private *priv = hw->priv;
+
+	/* reset TSF counter */
+	VNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
+}
+
+static const struct ieee80211_ops vnt_mac_ops = {
+	.tx			= vnt_tx_80211,
+	.start			= vnt_start,
+	.stop			= vnt_stop,
+	.add_interface		= vnt_add_interface,
+	.remove_interface	= vnt_remove_interface,
+	.config			= vnt_config,
+	.bss_info_changed	= vnt_bss_info_changed,
+	.prepare_multicast	= vnt_prepare_multicast,
+	.configure_filter	= vnt_configure,
+	.set_key		= vnt_set_key,
+	.get_tsf		= vnt_get_tsf,
+	.set_tsf		= vnt_set_tsf,
+	.reset_tsf		= vnt_reset_tsf,
+};
+
+int vnt_init(struct vnt_private *priv)
+{
+	SET_IEEE80211_PERM_ADDR(priv->hw, priv->abyCurrentNetAddr);
+
+	if (ieee80211_register_hw(priv->hw))
+		return -ENODEV;
+
+	priv->mac_hw = true;
+
+	CARDbRadioPowerOff(priv);
+
+	return 0;
+}
+
+static int
+vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
+{
+	PCHIP_INFO  pChip_info = (PCHIP_INFO)ent->driver_data;
+	struct vnt_private *priv;
+	struct ieee80211_hw *hw;
+	struct wiphy *wiphy;
+	int         rc;
+
+	dev_notice(&pcid->dev,
+		   "%s Ver. %s\n", DEVICE_FULL_DRV_NAM, DEVICE_VERSION);
+
+	dev_notice(&pcid->dev,
+		   "Copyright (c) 2003 VIA Networking Technologies, Inc.\n");
+
+	hw = ieee80211_alloc_hw(sizeof(*priv), &vnt_mac_ops);
+	if (!hw) {
+		dev_err(&pcid->dev, "could not register ieee80211_hw\n");
+		return -ENOMEM;
+	}
+
+	priv = hw->priv;
+
+	vt6655_init_info(pcid, &priv, pChip_info);
+
+	priv->hw = hw;
+
+	SET_IEEE80211_DEV(priv->hw, &pcid->dev);
+
+	if (pci_enable_device(pcid)) {
+		device_free_info(priv);
+		return -ENODEV;
+	}
+
+	dev_dbg(&pcid->dev,
+		"Before get pci_info memaddr is %x\n", priv->memaddr);
+
+	if (!device_get_pci_info(priv, pcid)) {
+		dev_err(&pcid->dev, ": Failed to find PCI device.\n");
+		device_free_info(priv);
+		return -ENODEV;
+	}
+
+#ifdef	DEBUG
+	dev_dbg(&pcid->dev,
+		"after get pci_info memaddr is %x, io addr is %x,io_size is %d\n",
+		priv->memaddr, priv->ioaddr, priv->io_size);
+	{
+		int i;
+		u32 bar, len;
+		u32 address[] = {
+			PCI_BASE_ADDRESS_0,
+			PCI_BASE_ADDRESS_1,
+			PCI_BASE_ADDRESS_2,
+			PCI_BASE_ADDRESS_3,
+			PCI_BASE_ADDRESS_4,
+			PCI_BASE_ADDRESS_5,
+			0};
+		for (i = 0; address[i]; i++) {
+			pci_read_config_dword(pcid, address[i], &bar);
+
+			dev_dbg(&pcid->dev, "bar %d is %x\n", i, bar);
+
+			if (!bar) {
+				dev_dbg(&pcid->dev,
+					"bar %d not implemented\n", i);
+				continue;
+			}
+
+			if (bar & PCI_BASE_ADDRESS_SPACE_IO) {
+				/* This is IO */
+
+				len = bar & (PCI_BASE_ADDRESS_IO_MASK & 0xffff);
+				len = len & ~(len - 1);
+
+				dev_dbg(&pcid->dev,
+					"IO space:  len in IO %x, BAR %d\n",
+					len, i);
+			} else {
+				len = bar & 0xfffffff0;
+				len = ~len + 1;
+
+				dev_dbg(&pcid->dev,
+					"len in MEM %x, BAR %d\n", len, i);
+			}
+		}
+	}
+#endif
+
+	priv->PortOffset = ioremap(priv->memaddr & PCI_BASE_ADDRESS_MEM_MASK,
+				   priv->io_size);
+	if (!priv->PortOffset) {
+		dev_err(&pcid->dev, ": Failed to IO remapping ..\n");
+		device_free_info(priv);
+		return -ENODEV;
+	}
+
+	rc = pci_request_regions(pcid, DEVICE_NAME);
+	if (rc) {
+		dev_err(&pcid->dev, ": Failed to find PCI device\n");
+		device_free_info(priv);
+		return -ENODEV;
+	}
+
+	/* do reset */
+	if (!MACbSoftwareReset(priv->PortOffset)) {
+		dev_err(&pcid->dev, ": Failed to access MAC hardware..\n");
+		device_free_info(priv);
+		return -ENODEV;
+	}
+	/* initial to reload eeprom */
+	MACvInitialize(priv->PortOffset);
+	MACvReadEtherAddress(priv->PortOffset, priv->abyCurrentNetAddr);
+
+	device_get_options(priv);
+	device_set_options(priv);
+	/* Mask out the options cannot be set to the chip */
+	priv->sOpts.flags &= pChip_info->flags;
+
+	/* Enable the chip specified capabilities */
+	priv->flags = priv->sOpts.flags | (pChip_info->flags & 0xff000000UL);
+	priv->tx_80211 = device_dma0_tx_80211;
+	priv->sMgmtObj.pAdapter = (void *)priv;
+	priv->pMgmt = &(priv->sMgmtObj);
+
+	wiphy = priv->hw->wiphy;
+
+	wiphy->frag_threshold = FRAG_THRESH_DEF;
+	wiphy->rts_threshold = RTS_THRESH_DEF;
+	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+		BIT(NL80211_IFTYPE_ADHOC) | BIT(NL80211_IFTYPE_AP);
+
+	priv->hw->flags = IEEE80211_HW_RX_INCLUDES_FCS |
+		IEEE80211_HW_REPORTS_TX_ACK_STATUS |
+		IEEE80211_HW_SIGNAL_DBM |
+		IEEE80211_HW_TIMING_BEACON_ONLY;
+
+	priv->hw->max_signal = 100;
+
+	if (vnt_init(priv))
+		return -ENODEV;
+
+	device_print_info(priv);
+	pci_set_drvdata(pcid, priv);
+
+	return 0;
+}
+
 /*------------------------------------------------------------------*/
 
 MODULE_DEVICE_TABLE(pci, vt6655_pci_id_table);

commit 33b1c8c13fb8c9c3c5320345258a4d33806262f4
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:43:36 2014 +0000

    staging: vt6655: mac80211 conversion: add new rx functions
    
    vnt_receive_frame which replaces device_receive_frame
    
    and vnt_rx_data which handles mac80211 rx data
    
    structures ieee80211_hw, ieee80211_vif and variable rx_rate are added
    in structure vnt_private
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ef848e2f0585..84a35d7d01e8 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1336,7 +1336,7 @@ static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 	     pRD = pRD->next) {
 		if (works++ > 15)
 			break;
-		if (device_receive_frame(pDevice, pRD)) {
+		if (vnt_receive_frame(pDevice, pRD)) {
 			if (!device_alloc_rx_buf(pDevice, pRD)) {
 				dev_err(&pDevice->pcid->dev,
 					"can not allocate rx buf\n");
@@ -1344,7 +1344,6 @@ static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 			}
 		}
 		pRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;
-		pDevice->dev->last_rx = jiffies;
 	}
 
 	pDevice->pCurrRD[uIdx] = pRD;
@@ -1360,9 +1359,12 @@ static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pRD)
 	if (pRDInfo->skb == NULL)
 		return false;
 	ASSERT(pRDInfo->skb);
-	pRDInfo->skb->dev = pDevice->dev;
-	pRDInfo->skb_dma = pci_map_single(pDevice->pcid, skb_tail_pointer(pRDInfo->skb),
-					  pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
+
+	pRDInfo->skb_dma =
+		pci_map_single(pDevice->pcid,
+			       skb_put(pRDInfo->skb, skb_tailroom(pRDInfo->skb)),
+			       pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
+
 	*((unsigned int *)&(pRD->m_rd0RD0)) = 0; /* FIX cast */
 
 	pRD->m_rd0RD0.wResCount = cpu_to_le16(pDevice->rx_buf_sz);
@@ -1380,7 +1382,6 @@ bool device_alloc_frag_buf(struct vnt_private *pDevice,
 	if (pDeF->skb == NULL)
 		return false;
 	ASSERT(pDeF->skb);
-	pDeF->skb->dev = pDevice->dev;
 
 	return true;
 }

commit c42645a2c54ffd82817e7a11fa05fffde08463a3
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Tue Oct 21 17:00:24 2014 +0200

    staging: vt6655: Remove redundant cast
    
    Both sides have type const struct iw_handler_def*, so the cast is
    unnecessary and confusing.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c8f262f58c7b..ef848e2f0585 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -932,7 +932,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	dev->irq                = pcid->irq;
 	dev->netdev_ops         = &device_netdev_ops;
 
-	dev->wireless_handlers = (struct iw_handler_def *)&iwctl_handler_def;
+	dev->wireless_handlers = &iwctl_handler_def;
 
 	rc = register_netdev(dev);
 	if (rc) {

commit 4a2bc3bdfffcb31e7ba4d47358c0193d4fc259dc
Author: Vladimir A. Nazarenko <naszar@ya.ru>
Date:   Fri Oct 10 12:27:01 2014 +1100

    staging: vt6655: delete SndEvt_ToAPI code
    
    It's never enabled, so we can safely remove it.
    
    Signed-off-by: Vladimir A. Nazarenko <naszar@ya.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 6a77f0df1a63..c8f262f58c7b 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2911,14 +2911,8 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 
 	case IOCTL_CMD_SET:
 
-#ifdef SndEvt_ToAPI
-		if ((((PSCmdRequest)rq)->wCmdCode != WLAN_CMD_SET_EVT) &&
-		    !(pDevice->flags & DEVICE_FLAGS_OPENED))
-#else
-			if (!(pDevice->flags & DEVICE_FLAGS_OPENED) &&
-			    (((PSCmdRequest)rq)->wCmdCode != WLAN_CMD_SET_WPA))
-#endif
-			{
+		if (!(pDevice->flags & DEVICE_FLAGS_OPENED) &&
+		    (((PSCmdRequest)rq)->wCmdCode != WLAN_CMD_SET_WPA))	{
 				rc = -EFAULT;
 				break;
 			}

commit 402eede3c0b29949cb9c46fcbc2d476c5d266d76
Author: Vladimir A. Nazarenko <naszar@ya.ru>
Date:   Thu Oct 9 16:33:33 2014 +1100

    staging: vt6655: remove useless #if 1
    
    There is code encapsulated in #if 1, let's remove it.
    
    Signed-off-by: Vladimir A. Nazarenko <naszar@ya.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ff8bd7a5db87..6a77f0df1a63 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -854,8 +854,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 		return -ENODEV;
 	}
 
-#if 1
-
 #ifdef	DEBUG
 
 	pr_debug("after get pci_info memaddr is %x, io addr is %x,io_size is %d\n", pDevice->memaddr, pDevice->ioaddr, pDevice->io_size);
@@ -892,8 +890,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 			}
 		}
 	}
-#endif
-
 #endif
 
 	pDevice->PortOffset = ioremap(pDevice->memaddr & PCI_BASE_ADDRESS_MEM_MASK, pDevice->io_size);

commit 5ba1b07a6eae38886b7e27d662da2786d0613386
Author: Vladimir A. Nazarenko <naszar@ya.ru>
Date:   Thu Oct 9 15:38:23 2014 +1100

    staging: vt6655: remove global variable wpa_Result
    
    This variable unused, so remove it.
    
    Signed-off-by: Vladimir A. Nazarenko <naszar@ya.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ed5e71237007..ff8bd7a5db87 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1553,9 +1553,6 @@ static int  device_open(struct net_device *dev)
 {
 	struct vnt_private *pDevice = netdev_priv(dev);
 	int i;
-#ifdef WPA_SM_Transtatus
-	extern SWPAResult wpa_Result;
-#endif
 
 	pDevice->rx_buf_sz = PKT_BUF_SZ;
 	if (!device_init_rings(pDevice))
@@ -1567,11 +1564,6 @@ static int  device_open(struct net_device *dev)
 		return i;
 
 #ifdef WPA_SM_Transtatus
-	memset(wpa_Result.ifname, 0, sizeof(wpa_Result.ifname));
-	wpa_Result.proto = 0;
-	wpa_Result.key_mgmt = 0;
-	wpa_Result.eap_type = 0;
-	wpa_Result.authenticated = false;
 	pDevice->fWPA_Authened = false;
 #endif
 	pr_debug("call device init rd0 ring\n");

commit 25ef419dc92a16d64380d85655b4381a2fb22dfb
Author: Dilek Uzulmez <dilekuzulmez@gmail.com>
Date:   Thu Oct 9 22:46:32 2014 +0300

    staging: vt6655: Use ether_addr_copy function
    
    This patch fixes the following checkpatch.pl warnings:
    WARNING: "Prefer ether_addr_copy() over memcpy() if the Ethernet
    addresses are __aligned(2)" in file device_main.c
    Pahole shows that the addresses are aligned
    
    Signed-off-by: Dilek Uzulmez <dilekuzulmez@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 3eb8e5c5366e..ed5e71237007 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1591,7 +1591,7 @@ static int  device_open(struct net_device *dev)
 	device_init_registers(pDevice);
 
 	MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
-	memcpy(pDevice->pMgmt->abyMACAddr, pDevice->abyCurrentNetAddr, ETH_ALEN);
+	ether_addr_copy(pDevice->pMgmt->abyMACAddr, pDevice->abyCurrentNetAddr);
 	device_set_multi(pDevice->dev);
 
 	// Init for Key Management

commit c5e1150178abe6fc3d967953dc74694e51b07ff3
Author: Dilek Uzulmez <dilekuzulmez@gmail.com>
Date:   Wed Oct 8 18:25:31 2014 +0300

    staging: vt6655: Use ether_addr_copy function
    
    This patch fixes the following checkpatch.pl warnings:
    WARNING: "Prefer ether_addr_copy() over memcpy() if the Ethernet
    addresses are __aligned(2)" in file device_main.c
    Pahole shows that the addresses are aligned
    
    Signed-off-by: Dilek Uzulmez <dilekuzulmez@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1e1664ec1663..3eb8e5c5366e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -362,9 +362,9 @@ device_set_options(struct vnt_private *pDevice)
 	unsigned char abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
 	unsigned char abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
 
-	memcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);
-	memcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);
-	memcpy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel, ETH_ALEN);
+	ether_addr_copy(pDevice->abyBroadcastAddr, abyBroadcastAddr);
+	ether_addr_copy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042);
+	ether_addr_copy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel);
 
 	pDevice->uChannel = pDevice->sOpts.channel_num;
 	pDevice->wRTSThreshold = pDevice->sOpts.rts_thresh;

commit 61d566a5a3b6ee9aed5c89463af4342a26f295dc
Author: Tapasweni Pathak <tapaswenipathak@gmail.com>
Date:   Wed Oct 8 20:41:48 2014 +0530

    staging: vt6655: Remove unnecessary cast for argument of kfree
    
    This patch removes all occurrences of unnecessary cast on the
    argument to kfree, all over in rtl8712.
    
    There is no need of the cast on the argument to kfree.
    
    Greped to find occurrences.
    
    Signed-off-by: Tapasweni Pathak <tapaswenipathak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 8baeb8c4f4f1..1e1664ec1663 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1204,7 +1204,7 @@ static void device_free_rd0_ring(struct vnt_private *pDevice)
 
 		dev_kfree_skb(pRDInfo->skb);
 
-		kfree((void *)pDesc->pRDInfo);
+		kfree(pDesc->pRDInfo);
 	}
 }
 
@@ -1221,7 +1221,7 @@ static void device_free_rd1_ring(struct vnt_private *pDevice)
 
 		dev_kfree_skb(pRDInfo->skb);
 
-		kfree((void *)pDesc->pRDInfo);
+		kfree(pDesc->pRDInfo);
 	}
 }
 
@@ -1305,7 +1305,7 @@ static void device_free_td0_ring(struct vnt_private *pDevice)
 		if (pTDInfo->skb)
 			dev_kfree_skb(pTDInfo->skb);
 
-		kfree((void *)pDesc->pTDInfo);
+		kfree(pDesc->pTDInfo);
 	}
 }
 
@@ -1324,7 +1324,7 @@ static void device_free_td1_ring(struct vnt_private *pDevice)
 		if (pTDInfo->skb)
 			dev_kfree_skb(pTDInfo->skb);
 
-		kfree((void *)pDesc->pTDInfo);
+		kfree(pDesc->pTDInfo);
 	}
 }
 

commit b7f0790d73f189ef1584656644ca53663fa96c22
Author: Melike Yurtoglu <aysemelikeyurtoglu@gmail.com>
Date:   Mon Oct 6 16:21:46 2014 +0300

    staging: vt6655: Fixed else after return or break warning.
    
    This patch fixes multiple instances of checkpatch.pl
    WARNING : else is not generally useful after a break or return in
    device_main.c
    
    Signed-off-by: Melike Yurtoglu <aysemelikeyurtoglu@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 54e16f40d8ed..8baeb8c4f4f1 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2915,9 +2915,8 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		if (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {
 			rc = -EFAULT;
 			break;
-		} else {
-			rc = 0;
 		}
+		rc = 0;
 		pReq = (PSCmdRequest)rq;
 		pReq->wResult = MAGIC_CODE;
 		break;
@@ -2934,9 +2933,8 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 			{
 				rc = -EFAULT;
 				break;
-			} else {
-				rc = 0;
 			}
+			rc = 0;
 
 		if (test_and_set_bit(0, (void *)&(pMgmt->uCmdBusy)))
 			return -EBUSY;

commit a793b2d817dffce9f16af694fcce327bdefedbed
Author: Gulsah Kose <gulsah.1004@gmail.com>
Date:   Sun Sep 28 19:42:37 2014 +0300

    staging: vt6655: Type conversion was made.
    
    This patch fixes this sparse warning:
    drivers/staging/vt6655/device_main.c:385:40: warning: mixing different enum types
    drivers/staging/vt6655/device_main.c:385:40:     int enum _VIA_BB_TYPE versus
    drivers/staging/vt6655/device_main.c:385:40:     int enum _VIA_PKT_TYPE
    
    Signed-off-by: Gulsah Kose <gulsah.1004@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1dff9d4672b5..54e16f40d8ed 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -381,7 +381,7 @@ device_set_options(struct vnt_private *pDevice)
 	if (pDevice->uConnectionRate < RATE_AUTO)
 		pDevice->bFixRate = true;
 	pDevice->byBBType = pDevice->sOpts.bbp_type;
-	pDevice->byPacketType = pDevice->byBBType;
+	pDevice->byPacketType = (VIA_PKT_TYPE)pDevice->byBBType;
 	pDevice->byAutoFBCtrl = AUTO_FB_0;
 	pDevice->bUpdateBBVGA = true;
 	pDevice->byFOETuning = 0;

commit 9e23c1b8c3cab8fa69fa05a9c14113d74026eaf0
Author: Aybuke Ozdemir <aybuke.147@gmail.com>
Date:   Thu Sep 25 01:49:36 2014 +0300

    Staging: vt6655: Add require space before that '('
    
    This patch fixes checkpatch.pl error in file device_main.c
    ERROR: space required before the open parenthesis '('
    
    Signed-off-by: Aybuke Ozdemir <aybuke.147@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ebcf63e1fb1e..1dff9d4672b5 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2521,9 +2521,9 @@ int Config_FileOperation(struct vnt_private *pDevice,
 
 	if (memcmp(tmpbuffer, "USA", 3) == 0) {
 		result = ZoneType_USA;
-	} else if(memcmp(tmpbuffer, "JAPAN", 5) == 0) {
+	} else if (memcmp(tmpbuffer, "JAPAN", 5) == 0) {
 		result = ZoneType_Japan;
-	} else if(memcmp(tmpbuffer, "EUROPE", 5) == 0) {
+	} else if (memcmp(tmpbuffer, "EUROPE", 5) == 0) {
 		result = ZoneType_Europe;
 	} else {
 		result = -1;

commit 6e61b441ceb5462d7fe14eb1697a61cb645dc871
Author: Aybuke Ozdemir <aybuke.147@gmail.com>
Date:   Thu Sep 25 01:36:44 2014 +0300

    Staging: vt6655: Add require space after that ','
    
    This patch fixes checkpatch.pl error in file device_main.c
    ERROR: space required after that ';' (ctx:VxV)
    
    Signed-off-by: Aybuke Ozdemir <aybuke.147@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 76d5454c68ea..ebcf63e1fb1e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2513,7 +2513,7 @@ int Config_FileOperation(struct vnt_private *pDevice,
 		goto error1;
 	}
 
-	if (Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer)!=true) {
+	if (Config_FileGetParameter("ZONETYPE", tmpbuffer, buffer) != true) {
 		pr_err("get parameter error?\n");
 		result = -1;
 		goto error1;

commit 46fa0ec0fa4d396e94ac9a8d3e01e6da1f35efdd
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Sep 22 21:27:47 2014 +0100

    staging: vt6655: device_get_options remove unused variable devname
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1a1440f65724..76d5454c68ea 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -331,8 +331,7 @@ static void vt6655_remove(struct pci_dev *pcid)
 	device_free_info(pDevice);
 }
 
-static void device_get_options(struct vnt_private *pDevice,
-			       char *devname)
+static void device_get_options(struct vnt_private *pDevice)
 {
 	POPTIONS pOpts = &(pDevice->sOpts);
 
@@ -923,7 +922,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	MACvInitialize(pDevice->PortOffset);
 	MACvReadEtherAddress(pDevice->PortOffset, dev->dev_addr);
 
-	device_get_options(pDevice, dev->name);
+	device_get_options(pDevice);
 	device_set_options(pDevice);
 	//Mask out the options cannot be set to the chip
 	pDevice->sOpts.flags &= pChip_info->flags;

commit 42f709eff132e82f5375b4daae208953035768b2
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Sep 22 21:27:46 2014 +0100

    staging: vt6655: pr_err remove string to net device name
    
    Just print driver name with dev_err removing the string formatting.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index aaeb3711f1da..1a1440f65724 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1043,8 +1043,7 @@ static bool device_init_rings(struct vnt_private *pDevice)
 					 pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
 					 &pDevice->pool_dma);
 	if (vir_pool == NULL) {
-		pr_err("%s : allocate desc dma memory failed\n",
-		       pDevice->dev->name);
+		dev_err(&pDevice->pcid->dev, "allocate desc dma memory failed\n");
 		return false;
 	}
 
@@ -1063,8 +1062,8 @@ static bool device_init_rings(struct vnt_private *pDevice)
 						  CB_MAX_BUF_SIZE,
 						  &pDevice->tx_bufs_dma0);
 	if (pDevice->tx0_bufs == NULL) {
-		pr_err("%s: allocate buf dma memory failed\n",
-		       pDevice->dev->name);
+		dev_err(&pDevice->pcid->dev, "allocate buf dma memory failed\n");
+
 		pci_free_consistent(pDevice->pcid,
 				    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
 				    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
@@ -1141,10 +1140,9 @@ static void device_init_rd0_ring(struct vnt_private *pDevice)
 		pDesc = &(pDevice->aRD0Ring[i]);
 		pDesc->pRDInfo = alloc_rd_info();
 		ASSERT(pDesc->pRDInfo);
-		if (!device_alloc_rx_buf(pDevice, pDesc)) {
-			pr_err("%s: can not alloc rx bufs\n",
-			       pDevice->dev->name);
-		}
+		if (!device_alloc_rx_buf(pDevice, pDesc))
+			dev_err(&pDevice->pcid->dev, "can not alloc rx bufs\n");
+
 		pDesc->next = &(pDevice->aRD0Ring[(i+1) % pDevice->sOpts.nRxDescs0]);
 		pDesc->pRDInfo->curr_desc = cpu_to_le32(curr);
 		pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
@@ -1166,10 +1164,9 @@ static void device_init_rd1_ring(struct vnt_private *pDevice)
 		pDesc = &(pDevice->aRD1Ring[i]);
 		pDesc->pRDInfo = alloc_rd_info();
 		ASSERT(pDesc->pRDInfo);
-		if (!device_alloc_rx_buf(pDevice, pDesc)) {
-			pr_err("%s: can not alloc rx bufs\n",
-			       pDevice->dev->name);
-		}
+		if (!device_alloc_rx_buf(pDevice, pDesc))
+			dev_err(&pDevice->pcid->dev, "can not alloc rx bufs\n");
+
 		pDesc->next = &(pDevice->aRD1Ring[(i+1) % pDevice->sOpts.nRxDescs1]);
 		pDesc->pRDInfo->curr_desc = cpu_to_le32(curr);
 		pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
@@ -1188,10 +1185,8 @@ static void device_init_defrag_cb(struct vnt_private *pDevice)
 	/* Init the fragment ctl entries */
 	for (i = 0; i < CB_MAX_RX_FRAG; i++) {
 		pDeF = &(pDevice->sRxDFCB[i]);
-		if (!device_alloc_frag_buf(pDevice, pDeF)) {
-			pr_err("%s: can not alloc frag bufs\n",
-			       pDevice->dev->name);
-		}
+		if (!device_alloc_frag_buf(pDevice, pDeF))
+			dev_err(&pDevice->pcid->dev, "can not alloc frag bufs\n");
 	}
 	pDevice->cbDFCB = CB_MAX_RX_FRAG;
 	pDevice->cbFreeDFCB = pDevice->cbDFCB;
@@ -1348,8 +1343,8 @@ static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 			break;
 		if (device_receive_frame(pDevice, pRD)) {
 			if (!device_alloc_rx_buf(pDevice, pRD)) {
-				pr_err("%s: can not allocate rx buf\n",
-				       pDevice->dev->name);
+				dev_err(&pDevice->pcid->dev,
+					"can not allocate rx buf\n");
 				break;
 			}
 		}
@@ -1525,7 +1520,8 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 static void device_error(struct vnt_private *pDevice, unsigned short status)
 {
 	if (status & ISR_FETALERR) {
-		pr_err("%s: Hardware fatal error\n", pDevice->dev->name);
+		dev_err(&pDevice->pcid->dev, "Hardware fatal error\n");
+
 		netif_stop_queue(pDevice->dev);
 		del_timer(&pDevice->sTimerCommand);
 		del_timer(&(pDevice->pMgmt->sTimerSecondCallback));

commit 22981e0e5ab3aedfb46698ed7c12c7b944781bd3
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Sep 10 09:34:50 2014 +0200

    staging: vt6655: Use net_device_stats from struct net_device
    
    Instead of using an own copy of struct net_device_stats in struct
    vnt_private, use stats from struct net_device. Also remove the thus
    unnecessary device_get_stats(), as it would now just return
    netdev->stats, which is the default in dev_get_stats().
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 7e7d9affbc12..aaeb3711f1da 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -264,7 +264,6 @@ static void vt6655_init_info(struct pci_dev *pcid,
 static void device_free_info(struct vnt_private *pDevice);
 static bool device_get_pci_info(struct vnt_private *, struct pci_dev *pcid);
 static void device_print_info(struct vnt_private *pDevice);
-static struct net_device_stats *device_get_stats(struct net_device *dev);
 static void device_init_diversity_timer(struct vnt_private *pDevice);
 static int  device_open(struct net_device *dev);
 static int  device_xmit(struct sk_buff *skb, struct net_device *dev);
@@ -807,7 +806,6 @@ static const struct net_device_ops device_netdev_ops = {
 	.ndo_open               = device_open,
 	.ndo_stop               = device_close,
 	.ndo_do_ioctl           = device_ioctl,
-	.ndo_get_stats          = device_get_stats,
 	.ndo_start_xmit         = device_xmit,
 	.ndo_set_rx_mode	= device_set_multi,
 };
@@ -1406,7 +1404,7 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 	unsigned char byTsr1;
 	unsigned int	uFrameSize, uFIFOHeaderSize;
 	PSTxBufHead              pTxBufHead;
-	struct net_device_stats *pStats = &pDevice->stats;
+	struct net_device_stats *pStats = &pDevice->dev->stats;
 	struct sk_buff *skb;
 	unsigned int	uNodeIndex;
 	PSMgmtObject             pMgmt = pDevice->pMgmt;
@@ -2587,13 +2585,6 @@ static void device_set_multi(struct net_device *dev) {
 	pr_debug("pDevice->byRxMode = %x\n", pDevice->byRxMode);
 }
 
-static struct net_device_stats *device_get_stats(struct net_device *dev)
-{
-	struct vnt_private *pDevice = netdev_priv(dev);
-
-	return &pDevice->stats;
-}
-
 static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct vnt_private *pDevice = netdev_priv(dev);

commit c72f65cccab03dc9524a3d7fa385f31d5b6ae377
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Sep 4 23:08:36 2014 +0100

    staging: vt6655: device_free_info() warn: variable dereferenced before check
    
    pDevice is never NULL when this function is called remove the check.
    
    This fixes smatch warning
    drivers/staging/vt6655/device_main.c:1023 device_free_info() warn: variable dereferenced
    before check 'pDevice' (see line 1021)
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: kbuild@01.org
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f33795faa09b..7e7d9affbc12 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1008,9 +1008,6 @@ static void device_free_info(struct vnt_private *pDevice)
 {
 	struct net_device *dev = pDevice->dev;
 
-	if (!pDevice)
-		return;
-
 	ASSERT(pDevice);
 //2008-0714-01<Add>by chester
 	device_release_WPADEV(pDevice);

commit a9873673484b5aa4346111d021c83a2f11d62eb5
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Aug 30 22:25:49 2014 +0100

    staging: vt6655: Replace typedef enum _CARD_OP_MODE eOPMode with enum nl80211_iftype op_mode.
    
    Using the nl80211 header.
    
    Using enum changes
    OP_MODE_ADHOC -> NL80211_IFTYPE_ADHOC
    OP_MODE_AP ->  NL80211_IFTYPE_AP
    OP_MODE_INFRASTRUCTURE -> NL80211_IFTYPE_STATION
    OP_MODE_UNKNOWN -> NL80211_IFTYPE_UNSPECIFIED
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 047370274c00..f33795faa09b 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2341,7 +2341,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 				}
 			}
 			if (pDevice->bChannelSwitch &&
-			    (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE)) {
+			    (pDevice->op_mode == NL80211_IFTYPE_STATION)) {
 				pDevice->byChannelSwitchCount--;
 				if (pDevice->byChannelSwitchCount == 0) {
 					pDevice->bChannelSwitch = false;
@@ -2354,7 +2354,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 
 				}
 			}
-			if (pDevice->eOPMode != OP_MODE_ADHOC) {
+			if (pDevice->op_mode != NL80211_IFTYPE_ADHOC) {
 				if ((pDevice->bUpdateBBVGA) && pDevice->bLinkPass && (pDevice->uCurrRSSI != 0)) {
 					long            ldBm;
 
@@ -2394,8 +2394,8 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 			if (pDevice->bEnablePSMode)
 				PSbIsNextTBTTWakeUp((void *)pDevice);
 
-			if ((pDevice->eOPMode == OP_MODE_AP) ||
-			    (pDevice->eOPMode == OP_MODE_ADHOC)) {
+			if ((pDevice->op_mode == NL80211_IFTYPE_AP) ||
+			    (pDevice->op_mode == NL80211_IFTYPE_ADHOC)) {
 				MACvOneShotTimer1MicroSec(pDevice->PortOffset,
 							  (pMgmt->wIBSSBeaconPeriod - MAKE_BEACON_RESERVED) << 10);
 			}
@@ -2405,12 +2405,12 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 		}
 
 		if (pDevice->dwIsr & ISR_BNTX) {
-			if (pDevice->eOPMode == OP_MODE_ADHOC) {
+			if (pDevice->op_mode == NL80211_IFTYPE_ADHOC) {
 				pDevice->bIsBeaconBufReadySet = false;
 				pDevice->cbBeaconBufReadySetCnt = 0;
 			}
 
-			if (pDevice->eOPMode == OP_MODE_AP) {
+			if (pDevice->op_mode == NL80211_IFTYPE_AP) {
 				if (pMgmt->byDTIMCount > 0) {
 					pMgmt->byDTIMCount--;
 					pMgmt->sNodeDBTable[0].bRxPSPoll = false;
@@ -2453,7 +2453,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 			max_count += device_tx_srv(pDevice, TYPE_AC0DMA);
 
 		if (pDevice->dwIsr & ISR_SOFTTIMER1) {
-			if (pDevice->eOPMode == OP_MODE_AP) {
+			if (pDevice->op_mode == NL80211_IFTYPE_AP) {
 				if (pDevice->bShortSlotTime)
 					pMgmt->wCurrCapInfo |= WLAN_SET_CAP_INFO_SHORTSLOTTIME(1);
 				else

commit 93320258989eb1f60b62e6d50fb509e51088aec7
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Aug 30 22:25:47 2014 +0100

    stgaing: vt6655: remove unused variable wCTSDuration
    
    wCTSDuration is always set to 0.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 34a70b04a109..047370274c00 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -387,7 +387,6 @@ device_set_options(struct vnt_private *pDevice)
 	pDevice->byAutoFBCtrl = AUTO_FB_0;
 	pDevice->bUpdateBBVGA = true;
 	pDevice->byFOETuning = 0;
-	pDevice->wCTSDuration = 0;
 	pDevice->byPreambleType = 0;
 
 	pr_debug(" uChannel= %d\n", (int)pDevice->uChannel);

commit 43e79c0fb3cafef9bb5c9f048aad4ff2249c9741
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Aug 21 21:40:50 2014 +0100

    staging: vt6655: dead code remove device_nics variable
    
    The module can not load more than once.
    
    Remove device_nics, MAX_UINTS and OPTION_DEFAULT
    
    Remove dead index variable from device_get_options
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ffbe64fce16c..34a70b04a109 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -245,9 +245,6 @@ DEVICE_PARAM(bDiversityANTEnable, "ANT diversity mode");
 //
 // Static vars definitions
 //
-
-static int          device_nics             = 0;
-
 static CHIP_INFO chip_info_table[] = {
 	{ VT3253,       "VIA Networking Solomon-A/B/G Wireless LAN Adapter ",
 	  256, 1,     DEVICE_FLAGS_IP_ALIGN|DEVICE_FLAGS_TX_ALIGN },
@@ -336,7 +333,7 @@ static void vt6655_remove(struct pci_dev *pcid)
 }
 
 static void device_get_options(struct vnt_private *pDevice,
-			       int index, char *devname)
+			       char *devname)
 {
 	POPTIONS pOpts = &(pDevice->sOpts);
 
@@ -825,11 +822,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	struct vnt_private *pDevice;
 	int         rc;
 
-	if (device_nics++ >= MAX_UINTS) {
-		pr_notice(DEVICE_NAME ": already found %d NICs\n", device_nics);
-		return -ENODEV;
-	}
-
 	dev = alloc_etherdev(sizeof(*pDevice));
 
 	pDevice = netdev_priv(dev);
@@ -934,7 +926,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	MACvInitialize(pDevice->PortOffset);
 	MACvReadEtherAddress(pDevice->PortOffset, dev->dev_addr);
 
-	device_get_options(pDevice, device_nics-1, dev->name);
+	device_get_options(pDevice, dev->name);
 	device_set_options(pDevice);
 	//Mask out the options cannot be set to the chip
 	pDevice->sOpts.flags &= pChip_info->flags;

commit 33cfce64e73524225df2a7f90b74efafd1a4178a
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Aug 21 21:40:49 2014 +0100

    staging: vt6655: remove multiple instances of netdevice.
    
    netdevice can only be created once.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index a441a5c800eb..ffbe64fce16c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -247,7 +247,6 @@ DEVICE_PARAM(bDiversityANTEnable, "ANT diversity mode");
 //
 
 static int          device_nics             = 0;
-static struct net_device *root_device_dev = NULL;
 
 static CHIP_INFO chip_info_table[] = {
 	{ VT3253,       "VIA Networking Solomon-A/B/G Wireless LAN Adapter ",
@@ -851,8 +850,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 	vt6655_init_info(pcid, &pDevice, pChip_info);
 	pDevice->dev = dev;
-	pDevice->next_module = root_device_dev;
-	root_device_dev = dev;
 
 	if (pci_enable_device(pcid)) {
 		device_free_info(pDevice);

commit 70afb8e5037a97d7294955531395b65e225c98e1
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Aug 21 21:40:48 2014 +0100

    staging: vt6655: remove multiple instances of driver loading.
    
    The driver can only load once from the instance provided
    by pci_dev.
    
    struct vnt_private next, prev and pDevice_Infos are removed.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1a94d4fded4e..a441a5c800eb 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -247,7 +247,6 @@ DEVICE_PARAM(bDiversityANTEnable, "ANT diversity mode");
 //
 
 static int          device_nics             = 0;
-static struct vnt_private *pDevice_Infos = NULL;
 static struct net_device *root_device_dev = NULL;
 
 static CHIP_INFO chip_info_table[] = {
@@ -979,19 +978,8 @@ static void vt6655_init_info(struct pci_dev *pcid,
 			     struct vnt_private **ppDevice,
 			     PCHIP_INFO pChip_info)
 {
-	struct vnt_private *p;
-
 	memset(*ppDevice, 0, sizeof(**ppDevice));
 
-	if (pDevice_Infos == NULL) {
-		pDevice_Infos = *ppDevice;
-	} else {
-		for (p = pDevice_Infos; p->next != NULL; p = p->next)
-			do {} while (0);
-		p->next = *ppDevice;
-		(*ppDevice)->prev = p;
-	}
-
 	(*ppDevice)->pcid = pcid;
 	(*ppDevice)->chip_id = pChip_info->chip_id;
 	(*ppDevice)->io_size = pChip_info->io_size;
@@ -1030,9 +1018,11 @@ static bool device_get_pci_info(struct vnt_private *pDevice,
 
 static void device_free_info(struct vnt_private *pDevice)
 {
-	struct vnt_private *ptr;
 	struct net_device *dev = pDevice->dev;
 
+	if (!pDevice)
+		return;
+
 	ASSERT(pDevice);
 //2008-0714-01<Add>by chester
 	device_release_WPADEV(pDevice);
@@ -1042,21 +1032,6 @@ static void device_free_info(struct vnt_private *pDevice)
 	if (wpa_set_wpadev(pDevice, 0) != 0)
 		pr_err("unregister wpadev fail?\n");
 
-	if (pDevice_Infos == NULL)
-		return;
-
-	for (ptr = pDevice_Infos; ptr && (ptr != pDevice); ptr = ptr->next)
-		do {} while (0);
-
-	if (ptr == pDevice) {
-		if (ptr == pDevice_Infos)
-			pDevice_Infos = ptr->next;
-		else
-			ptr->prev->next = ptr->next;
-	} else {
-		pr_err("info struct not found\n");
-		return;
-	}
 #ifdef HOSTAP
 	if (dev)
 		vt6655_hostap_set_hostapd(pDevice, 0, 0);

commit 5154b0d0e26545c52350f42b1a4c1e6dc0c4360f
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Aug 20 22:30:26 2014 +0100

    staging: vt6655: device.h dead code remove bCCK
    
    bCCK is always set to true, the only place it is used is in
    BBvCalculateParameter which nots the value to false.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 3a2fd29cc5b9..1a94d4fded4e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -469,8 +469,6 @@ static void device_init_registers(struct vnt_private *pDevice)
 	/* Do MACbSoftwareReset in MACvInitialize */
 	MACbSoftwareReset(pDevice->PortOffset);
 
-	/* force CCK */
-	pDevice->bCCK = true;
 	pDevice->bAES = false;
 
 	/* Only used in 11g type, sync with ERP IE */

commit 97fe1ad03c951c3b3526fab5a5f8765500c72d8b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Aug 17 20:42:26 2014 +0100

    staging: vt6655: main_usb.c remove undefined PLICE_DEBUG code.
    
    PLICE_DEBUG is not defined in any header for this file.
    
    Remove code, references and directives.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 95460d445623..3a2fd29cc5b9 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -389,10 +389,7 @@ device_set_options(struct vnt_private *pDevice)
 		pDevice->bFixRate = true;
 	pDevice->byBBType = pDevice->sOpts.bbp_type;
 	pDevice->byPacketType = pDevice->byBBType;
-
-//PLICE_DEBUG->
 	pDevice->byAutoFBCtrl = AUTO_FB_0;
-//PLICE_DEBUG<-
 	pDevice->bUpdateBBVGA = true;
 	pDevice->byFOETuning = 0;
 	pDevice->wCTSDuration = 0;
@@ -933,15 +930,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	}
 
 	dev->base_addr = pDevice->ioaddr;
-#ifdef	PLICE_DEBUG
-	unsigned char value;
-
-	VNSvInPortB(pDevice->PortOffset+0x4F, &value);
-	pr_debug("Before write: value is %x\n", value);
-	VNSvOutPortB(pDevice->PortOffset, value);
-	VNSvInPortB(pDevice->PortOffset+0x4F, &value);
-	pr_debug("After write: value is %x\n", value);
-#endif
 	// do reset
 	if (!MACbSoftwareReset(pDevice->PortOffset)) {
 		pr_err(DEVICE_NAME ": Failed to access MAC hardware..\n");
@@ -1021,14 +1009,6 @@ static bool device_get_pci_info(struct vnt_private *pDevice,
 	u16 pci_cmd;
 	u8  b;
 	unsigned int cis_addr;
-#ifdef	PLICE_DEBUG
-	unsigned char pci_config[256];
-	unsigned char value = 0x00;
-	int		ii, j;
-	u16	max_lat = 0x0000;
-
-	memset(pci_config, 0x00, 256);
-#endif
 
 	pci_read_config_byte(pcid, PCI_REVISION_ID, &pDevice->byRevId);
 	pci_read_config_word(pcid, PCI_SUBSYSTEM_ID, &pDevice->SubSystemID);
@@ -1047,20 +1027,6 @@ static bool device_get_pci_info(struct vnt_private *pDevice,
 	pci_read_config_byte(pcid, PCI_COMMAND, &b);
 	pci_write_config_byte(pcid, PCI_COMMAND, (b|PCI_COMMAND_MASTER));
 
-#ifdef	PLICE_DEBUG
-	for (ii = 0; ii < 0xFF; ii++) {
-		pci_read_config_byte(pcid, ii, &value);
-		pci_config[ii] = value;
-	}
-	for (ii = 0, j = 1; ii < 0x100; ii++, j++) {
-		if (j % 16 == 0) {
-			pr_debug("%x:", pci_config[ii]);
-			pr_debug("\n");
-		} else {
-			pr_debug("%x:", pci_config[ii]);
-		}
-	}
-#endif
 	return true;
 }
 
@@ -1720,8 +1686,6 @@ static int  device_close(struct net_device *dev)
 {
 	struct vnt_private *pDevice = netdev_priv(dev);
 	PSMgmtObject     pMgmt = pDevice->pMgmt;
-	//PLICE_DEBUG->
-//PLICE_DEBUG<-
 //2007-1121-02<Add>by EinsnLiu
 	if (pDevice->bLinkPass) {
 		bScheduleCommand((void *)pDevice, WLAN_CMD_DISASSOCIATE, NULL);
@@ -2111,10 +2075,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	byPktType = (unsigned char)pDevice->byPacketType;
 
 	if (pDevice->bFixRate) {
-#ifdef	PLICE_DEBUG
-		pr_debug("Fix Rate: PhyType is %d,ConnectionRate is %d\n", pDevice->eCurrentPHYType, pDevice->uConnectionRate);
-#endif
-
 		if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
 			if (pDevice->uConnectionRate >= RATE_11M)
 				pDevice->wCurrentRate = RATE_11M;

commit b39d60c1dea7389e3dcd1580f59b6717fa6b0159
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Aug 17 20:42:25 2014 +0100

    staging: vt6655: Use ether_crc in kernel.
    
    ether_crc is already in kernel remove local code and
    include linux/crc32.h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index a44233c2dd29..95460d445623 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2561,23 +2561,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 	return IRQ_RETVAL(handled);
 }
 
-static unsigned const ethernet_polynomial = 0x04c11db7U;
-static inline u32 ether_crc(int length, unsigned char *data)
-{
-	int crc = -1;
-
-	while (--length >= 0) {
-		unsigned char current_octet = *data++;
-		int bit;
-
-		for (bit = 0; bit < 8; bit++, current_octet >>= 1) {
-			crc = (crc << 1) ^
-				((crc < 0) ^ (current_octet & 1) ? ethernet_polynomial : 0);
-		}
-	}
-	return crc;
-}
-
 //2008-8-4 <add> by chester
 static int Config_FileGetParameter(unsigned char *string,
 				   unsigned char *dest, unsigned char *source)

commit 48caf5a060491edb2e1793539dad72e70c54c869
Author: Joe Perches <joe@perches.com>
Date:   Sun Aug 17 09:17:04 2014 -0700

    staging: vt6655: Convert DBG_PRT to pr_<level>
    
    DBG_PRT uses are unnecessarily complex.
    
    Convert DBG_PRT msglevel to pr_<level>.
    This changes the KERN_<level> type of several uses.
    It also enables dynamic_debug for the pr_debug conversions.
    
    This patch can be a prelude to converting these pr_<level>
    uses to dev_<level> as appropriate.
    
    Other changes:
    
    Realign arguments of these conversions.
    Remove now unused static int msglevel declarations.
    Remove now unused DBG_PRT #define.
    
    Compile tested only.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index beab35d8a4cb..a44233c2dd29 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -89,8 +89,6 @@
 #include <linux/slab.h>
 
 /*---------------------  Static Definitions -------------------------*/
-static int          msglevel                =   MSG_LEVEL_INFO;
-
 //
 // Define module options
 //
@@ -400,18 +398,19 @@ device_set_options(struct vnt_private *pDevice)
 	pDevice->wCTSDuration = 0;
 	pDevice->byPreambleType = 0;
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " uChannel= %d\n", (int)pDevice->uChannel);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byOpMode= %d\n", (int)pDevice->byOpMode);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " ePSMode= %d\n", (int)pDevice->ePSMode);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " wRTSThreshold= %d\n", (int)pDevice->wRTSThreshold);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byShortRetryLimit= %d\n", (int)pDevice->byShortRetryLimit);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byLongRetryLimit= %d\n", (int)pDevice->byLongRetryLimit);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byPreambleType= %d\n", (int)pDevice->byPreambleType);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byShortPreamble= %d\n", (int)pDevice->byShortPreamble);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " uConnectionRate= %d\n", (int)pDevice->uConnectionRate);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byBBType= %d\n", (int)pDevice->byBBType);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " pDevice->b11hEnable= %d\n", (int)pDevice->b11hEnable);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " pDevice->bDiversityRegCtlON= %d\n", (int)pDevice->bDiversityRegCtlON);
+	pr_debug(" uChannel= %d\n", (int)pDevice->uChannel);
+	pr_debug(" byOpMode= %d\n", (int)pDevice->byOpMode);
+	pr_debug(" ePSMode= %d\n", (int)pDevice->ePSMode);
+	pr_debug(" wRTSThreshold= %d\n", (int)pDevice->wRTSThreshold);
+	pr_debug(" byShortRetryLimit= %d\n", (int)pDevice->byShortRetryLimit);
+	pr_debug(" byLongRetryLimit= %d\n", (int)pDevice->byLongRetryLimit);
+	pr_debug(" byPreambleType= %d\n", (int)pDevice->byPreambleType);
+	pr_debug(" byShortPreamble= %d\n", (int)pDevice->byShortPreamble);
+	pr_debug(" uConnectionRate= %d\n", (int)pDevice->uConnectionRate);
+	pr_debug(" byBBType= %d\n", (int)pDevice->byBBType);
+	pr_debug(" pDevice->b11hEnable= %d\n", (int)pDevice->b11hEnable);
+	pr_debug(" pDevice->bDiversityRegCtlON= %d\n",
+		 (int)pDevice->bDiversityRegCtlON);
 }
 
 static void s_vCompleteCurrentMeasure(struct vnt_private *pDevice,
@@ -565,10 +564,10 @@ static void device_init_registers(struct vnt_private *pDevice)
 		}
 	}
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO
-		"bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",
-		pDevice->bDiversityEnable, (int)pDevice->ulDiversityNValue,
-		(int)pDevice->ulDiversityMValue, pDevice->byTMax, pDevice->byTMax2);
+	pr_debug("bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",
+		 pDevice->bDiversityEnable, (int)pDevice->ulDiversityNValue,
+		 (int)pDevice->ulDiversityMValue, pDevice->byTMax,
+		 pDevice->byTMax2);
 
 	/* zonetype initial */
 	pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
@@ -581,7 +580,7 @@ static void device_init_registers(struct vnt_private *pDevice)
 			pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0;
 			pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0B;
 
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Init Zone Type :USA\n");
+			pr_debug("Init Zone Type :USA\n");
 		} else if ((zonetype == 1) &&
 			 (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x01)) {
 			/* for Japan */
@@ -593,7 +592,7 @@ static void device_init_registers(struct vnt_private *pDevice)
 			pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x02;
 			pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
 
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Init Zone Type :Europe\n");
+			pr_debug("Init Zone Type :Europe\n");
 		} else {
 			if (zonetype != pDevice->abyEEPROM[EEP_OFS_ZONETYPE])
 				pr_debug("zonetype in file[%02x] mismatch with in EEPROM[%02x]\n",
@@ -616,12 +615,12 @@ static void device_init_registers(struct vnt_private *pDevice)
 			pDevice->byRevId = 0x80;
 
 	pDevice->byRFType &= RF_MASK;
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRFType = %x\n", pDevice->byRFType);
+	pr_debug("pDevice->byRFType = %x\n", pDevice->byRFType);
 
 	if (!pDevice->bZoneRegExist)
 		pDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byZoneType = %x\n", pDevice->byZoneType);
+	pr_debug("pDevice->byZoneType = %x\n", pDevice->byZoneType);
 
 	/* Init RF module */
 	RFbInit(pDevice);
@@ -744,8 +743,7 @@ static void device_init_registers(struct vnt_private *pDevice)
 
 	/* get Permanent network address */
 	SROMvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Network address = %pM\n",
-		pDevice->abyCurrentNetAddr);
+	pr_debug("Network address = %pM\n", pDevice->abyCurrentNetAddr);
 
 	/* reset Tx pointer */
 	CARDvSafeResetRx(pDevice);
@@ -985,12 +983,10 @@ static void device_print_info(struct vnt_private *pDevice)
 {
 	struct net_device *dev = pDevice->dev;
 
-	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: %s\n", dev->name, get_chip_name(pDevice->chip_id));
-	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: MAC=%pM", dev->name, dev->dev_addr);
-
-	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IO=0x%lx Mem=0x%lx ",
-		(unsigned long)pDevice->ioaddr, (unsigned long)pDevice->PortOffset);
-	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IRQ=%d\n", pDevice->dev->irq);
+	pr_info("%s: %s\n", dev->name, get_chip_name(pDevice->chip_id));
+	pr_info("%s: MAC=%pM IO=0x%lx Mem=0x%lx IRQ=%d\n",
+		dev->name, dev->dev_addr, (unsigned long)pDevice->ioaddr,
+		(unsigned long)pDevice->PortOffset, pDevice->dev->irq);
 }
 
 static void vt6655_init_info(struct pci_dev *pcid,
@@ -1094,7 +1090,7 @@ static void device_free_info(struct vnt_private *pDevice)
 		else
 			ptr->prev->next = ptr->next;
 	} else {
-		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "info struct not found\n");
+		pr_err("info struct not found\n");
 		return;
 	}
 #ifdef HOSTAP
@@ -1125,7 +1121,8 @@ static bool device_init_rings(struct vnt_private *pDevice)
 					 pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
 					 &pDevice->pool_dma);
 	if (vir_pool == NULL) {
-		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s : allocate desc dma memory failed\n", pDevice->dev->name);
+		pr_err("%s : allocate desc dma memory failed\n",
+		       pDevice->dev->name);
 		return false;
 	}
 
@@ -1144,7 +1141,8 @@ static bool device_init_rings(struct vnt_private *pDevice)
 						  CB_MAX_BUF_SIZE,
 						  &pDevice->tx_bufs_dma0);
 	if (pDevice->tx0_bufs == NULL) {
-		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: allocate buf dma memory failed\n", pDevice->dev->name);
+		pr_err("%s: allocate buf dma memory failed\n",
+		       pDevice->dev->name);
 		pci_free_consistent(pDevice->pcid,
 				    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
 				    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
@@ -1222,8 +1220,8 @@ static void device_init_rd0_ring(struct vnt_private *pDevice)
 		pDesc->pRDInfo = alloc_rd_info();
 		ASSERT(pDesc->pRDInfo);
 		if (!device_alloc_rx_buf(pDevice, pDesc)) {
-			DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc rx bufs\n",
-				pDevice->dev->name);
+			pr_err("%s: can not alloc rx bufs\n",
+			       pDevice->dev->name);
 		}
 		pDesc->next = &(pDevice->aRD0Ring[(i+1) % pDevice->sOpts.nRxDescs0]);
 		pDesc->pRDInfo->curr_desc = cpu_to_le32(curr);
@@ -1247,8 +1245,8 @@ static void device_init_rd1_ring(struct vnt_private *pDevice)
 		pDesc->pRDInfo = alloc_rd_info();
 		ASSERT(pDesc->pRDInfo);
 		if (!device_alloc_rx_buf(pDevice, pDesc)) {
-			DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc rx bufs\n",
-				pDevice->dev->name);
+			pr_err("%s: can not alloc rx bufs\n",
+			       pDevice->dev->name);
 		}
 		pDesc->next = &(pDevice->aRD1Ring[(i+1) % pDevice->sOpts.nRxDescs1]);
 		pDesc->pRDInfo->curr_desc = cpu_to_le32(curr);
@@ -1269,8 +1267,8 @@ static void device_init_defrag_cb(struct vnt_private *pDevice)
 	for (i = 0; i < CB_MAX_RX_FRAG; i++) {
 		pDeF = &(pDevice->sRxDFCB[i]);
 		if (!device_alloc_frag_buf(pDevice, pDeF)) {
-			DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc frag bufs\n",
-				pDevice->dev->name);
+			pr_err("%s: can not alloc frag bufs\n",
+			       pDevice->dev->name);
 		}
 	}
 	pDevice->cbDFCB = CB_MAX_RX_FRAG;
@@ -1428,8 +1426,8 @@ static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 			break;
 		if (device_receive_frame(pDevice, pRD)) {
 			if (!device_alloc_rx_buf(pDevice, pRD)) {
-				DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
-					"%s: can not allocate rx buf\n", pDevice->dev->name);
+				pr_err("%s: can not allocate rx buf\n",
+				       pDevice->dev->name);
 				break;
 			}
 		}
@@ -1520,8 +1518,9 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 
 				if (!(byTsr1 & TSR1_TERR)) {
 					if (byTsr0 != 0) {
-						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X].\n",
-							(int)uIdx, byTsr1, byTsr0);
+						pr_debug(" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X]\n",
+							 (int)uIdx, byTsr1,
+							 byTsr0);
 					}
 					if ((pTxBufHead->wFragCtl & FRAGCTL_ENDFRAG) != FRAGCTL_NONFRAG)
 						pDevice->s802_11Counter.TransmittedFragmentCount++;
@@ -1529,8 +1528,8 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 					pStats->tx_packets++;
 					pStats->tx_bytes += pTD->pTDInfo->skb->len;
 				} else {
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Tx[%d] dropped & tsr1[%02X] tsr0[%02X].\n",
-						(int)uIdx, byTsr1, byTsr0);
+					pr_debug(" Tx[%d] dropped & tsr1[%02X] tsr0[%02X]\n",
+						 (int)uIdx, byTsr1, byTsr0);
 					pStats->tx_errors++;
 					pStats->tx_dropped++;
 				}
@@ -1538,7 +1537,7 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 
 			if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
 				if (pDevice->bEnableHostapd) {
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx call back netif..\n");
+					pr_debug("tx call back netif..\n");
 					skb = pTD->pTDInfo->skb;
 					skb->dev = pDevice->apdev;
 					skb_reset_mac_header(skb);
@@ -1550,8 +1549,8 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 
 			if (byTsr1 & TSR1_TERR) {
 				if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
-						(int)uIdx, byTsr1, byTsr0);
+					pr_debug(" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X]\n",
+						 (int)uIdx, byTsr1, byTsr0);
 				}
 
 
@@ -1569,8 +1568,9 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 							wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
 							pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
 							pTD->pTDInfo->byFlags &= ~(TD_FLAGS_NETIF_SKB);
-							DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx_srv:tx fail re-queue sta index= %d, QueCnt= %d\n"
-								, (int)uNodeIndex, pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt);
+							pr_debug("tx_srv:tx fail re-queue sta index= %d, QueCnt= %d\n",
+								 (int)uNodeIndex,
+								 pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt);
 							pStats->tx_errors--;
 							pStats->tx_dropped--;
 						}
@@ -1587,7 +1587,8 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 
 		if (AVAIL_TD(pDevice, uIdx) < RESERV_AC0DMA) {
 			bFull = true;
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " AC0DMA is Full = %d\n", pDevice->iTDUsed[uIdx]);
+			pr_debug(" AC0DMA is Full = %d\n",
+				 pDevice->iTDUsed[uIdx]);
 		}
 		if (netif_queue_stopped(pDevice->dev) && !bFull)
 			netif_wake_queue(pDevice->dev);
@@ -1602,9 +1603,7 @@ static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 static void device_error(struct vnt_private *pDevice, unsigned short status)
 {
 	if (status & ISR_FETALERR) {
-		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
-			"%s: Hardware fatal error.\n",
-			pDevice->dev->name);
+		pr_err("%s: Hardware fatal error\n", pDevice->dev->name);
 		netif_stop_queue(pDevice->dev);
 		del_timer(&pDevice->sTimerCommand);
 		del_timer(&(pDevice->pMgmt->sTimerSecondCallback));
@@ -1658,7 +1657,7 @@ static int  device_open(struct net_device *dev)
 	wpa_Result.authenticated = false;
 	pDevice->fWPA_Authened = false;
 #endif
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device init rd0 ring\n");
+	pr_debug("call device init rd0 ring\n");
 	device_init_rd0_ring(pDevice);
 	device_init_rd1_ring(pDevice);
 	device_init_defrag_cb(pDevice);
@@ -1671,7 +1670,7 @@ static int  device_open(struct net_device *dev)
 	vMgrObjectInit(pDevice);
 	vMgrTimerInit(pDevice);
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
+	pr_debug("call device_init_registers\n");
 	device_init_registers(pDevice);
 
 	MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
@@ -1702,7 +1701,7 @@ static int  device_open(struct net_device *dev)
 		pDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;
 	}
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call MACvIntEnable\n");
+	pr_debug("call MACvIntEnable\n");
 	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
 
 	if (pDevice->pMgmt->eConfigMode == WMAC_CONFIG_AP) {
@@ -1713,7 +1712,7 @@ static int  device_open(struct net_device *dev)
 	}
 	pDevice->flags |= DEVICE_FLAGS_OPENED;
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success..\n");
+	pr_debug("device_open success..\n");
 	return 0;
 }
 
@@ -1759,7 +1758,7 @@ static int  device_close(struct net_device *dev)
 	//2008-0714-01<Add>by chester
 	device_release_WPADEV(pDevice);
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close..\n");
+	pr_debug("device_close..\n");
 	return 0;
 }
 
@@ -1769,11 +1768,11 @@ static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev)
 	unsigned char *pbMPDU;
 	unsigned int cbMPDULen = 0;
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211\n");
+	pr_debug("device_dma0_tx_80211\n");
 	spin_lock_irq(&pDevice->lock);
 
 	if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211, td0 <=0\n");
+		pr_debug("device_dma0_tx_80211, td0 <=0\n");
 		dev_kfree_skb_irq(skb);
 		spin_unlock_irq(&pDevice->lock);
 		return 0;
@@ -1816,14 +1815,14 @@ bool device_dma0_xmit(struct vnt_private *pDevice,
 
 	if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
 		dev_kfree_skb_irq(skb);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, td0 <=0\n");
+		pr_debug("device_dma0_xmit, td0 <=0\n");
 		return false;
 	}
 
 	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
 		if (pDevice->uAssocCount == 0) {
 			dev_kfree_skb_irq(skb);
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, assocCount = 0\n");
+			pr_debug("device_dma0_xmit, assocCount = 0\n");
 			return false;
 		}
 	}
@@ -1869,7 +1868,7 @@ bool device_dma0_xmit(struct vnt_private *pDevice,
 	else
 		pDevice->byPreambleType = PREAMBLE_LONG;
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dma0: pDevice->wCurrentRate = %d\n", pDevice->wCurrentRate);
+	pr_debug("dma0: pDevice->wCurrentRate = %d\n", pDevice->wCurrentRate);
 
 	if (pDevice->wCurrentRate <= RATE_11M) {
 		byPktType = PK_TYPE_11B;
@@ -1994,8 +1993,9 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 					// set tx map
 					wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
 					pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Set:pMgmt->abyPSTxMap[%d]= %d\n",
-						(wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);
+					pr_debug("Set:pMgmt->abyPSTxMap[%d]= %d\n",
+						 (wAID >> 3),
+						 pMgmt->abyPSTxMap[wAID >> 3]);
 					spin_unlock_irq(&pDevice->lock);
 					return 0;
 				}
@@ -2011,7 +2011,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 		}
 
 		if (!bNodeExist) {
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "Unknown STA not found in node DB\n");
+			pr_debug("Unknown STA not found in node DB\n");
 			dev_kfree_skb_irq(skb);
 			spin_unlock_irq(&pDevice->lock);
 			return 0;
@@ -2040,19 +2040,19 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 					// get group key
 					if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == true) {
 						bTKIP_UseGTK = true;
-						DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "Get GTK.\n");
+						pr_debug("Get GTK\n");
 						break;
 					}
 				} else {
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "Get PTK.\n");
+					pr_debug("Get PTK\n");
 					break;
 				}
 			} else if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
 				pbyBSSID = pDevice->sTxEthHeader.abyDstAddr;  //TO_DS = 0 and FROM_DS = 0 --> 802.11 MAC Address1
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "IBSS Serach Key:\n");
+				pr_debug("IBSS Serach Key:\n");
 				for (ii = 0; ii < 6; ii++)
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "%x\n", *(pbyBSSID+ii));
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "\n");
+					pr_debug("%x\n", *(pbyBSSID+ii));
+				pr_debug("\n");
 
 				// get pairwise key
 				if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == true)
@@ -2063,18 +2063,20 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 			if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == false) {
 				pTransmitKey = NULL;
 				if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
+					pr_debug("IBSS and KEY is NULL. [%d]\n",
+						 pDevice->pMgmt->eCurrMode);
 				else
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "NOT IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
+					pr_debug("NOT IBSS and KEY is NULL. [%d]\n",
+						 pDevice->pMgmt->eCurrMode);
 			} else {
 				bTKIP_UseGTK = true;
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "Get GTK.\n");
+				pr_debug("Get GTK\n");
 			}
 		} while (false);
 	}
 
 	if (pDevice->bEnableHostWEP) {
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "acdma0: STA index %d\n", uNodeIndex);
+		pr_debug("acdma0: STA index %d\n", uNodeIndex);
 		if (pDevice->bEncryptionEnable) {
 			pTransmitKey = &STempKey;
 			pTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;
@@ -2092,7 +2094,8 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	uMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);
 
 	if (uMACfragNum > AVAIL_TD(pDevice, TYPE_AC0DMA)) {
-		DBG_PRT(MSG_LEVEL_ERR, KERN_DEBUG "uMACfragNum > AVAIL_TD(TYPE_AC0DMA) = %d\n", uMACfragNum);
+		pr_debug("uMACfragNum > AVAIL_TD(TYPE_AC0DMA) = %d\n",
+			 uMACfragNum);
 		dev_kfree_skb_irq(skb);
 		spin_unlock_irq(&pDevice->lock);
 		return 0;
@@ -2170,18 +2173,21 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	}
 
 	if (bNeedEncryption) {
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ntohs Pkt Type=%04x\n", ntohs(pDevice->sTxEthHeader.wType));
+		pr_debug("ntohs Pkt Type=%04x\n",
+			 ntohs(pDevice->sTxEthHeader.wType));
 		if ((pDevice->sTxEthHeader.wType) == TYPE_PKT_802_1x) {
 			bNeedEncryption = false;
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Pkt Type=%04x\n", (pDevice->sTxEthHeader.wType));
+			pr_debug("Pkt Type=%04x\n",
+				 (pDevice->sTxEthHeader.wType));
 			if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
 				if (pTransmitKey == NULL) {
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Don't Find TX KEY\n");
+					pr_debug("Don't Find TX KEY\n");
 				} else {
 					if (bTKIP_UseGTK) {
-						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "error: KEY is GTK!!~~\n");
+						pr_debug("error: KEY is GTK!!~~\n");
 					} else {
-						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
+						pr_debug("Find PTK [%lX]\n",
+							 pTransmitKey->dwKeyIndex);
 						bNeedEncryption = true;
 					}
 				}
@@ -2195,13 +2201,14 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 			if (pDevice->bEnableHostWEP) {
 				if ((uNodeIndex != 0) &&
 				    (pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex & PAIRWISE_KEY)) {
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
+					pr_debug("Find PTK [%lX]\n",
+						 pTransmitKey->dwKeyIndex);
 					bNeedEncryption = true;
 				}
 			}
 		} else {
 			if (pTransmitKey == NULL) {
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "return no tx key\n");
+				pr_debug("return no tx key\n");
 				dev_kfree_skb_irq(skb);
 				spin_unlock_irq(&pDevice->lock);
 				return 0;
@@ -2305,7 +2312,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 		return IRQ_RETVAL(handled);
 
 	if (pDevice->dwIsr == 0xffffffff) {
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwIsr = 0xffff\n");
+		pr_debug("dwIsr = 0xffff\n");
 		return IRQ_RETVAL(handled);
 	}
 
@@ -2332,7 +2339,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 		MACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);
 
 		if (pDevice->dwIsr & ISR_FETALERR) {
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " ISR_FETALERR\n");
+			pr_debug(" ISR_FETALERR\n");
 			VNSvOutPortB(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, 0);
 			VNSvOutPortW(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, SOFTPWRCTL_SWPECTI);
 			device_error(pDevice, pDevice->dwIsr);
@@ -2442,12 +2449,18 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 						if (pDevice->uBBVGADiffCount == 1) {
 							// first VGA diff gain
 							BBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);
-							DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
-								(int)ldBm, pDevice->byBBVGANew, pDevice->byBBVGACurrent, (int)pDevice->uBBVGADiffCount);
+							pr_debug("First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
+								 (int)ldBm,
+								 pDevice->byBBVGANew,
+								 pDevice->byBBVGACurrent,
+								 (int)pDevice->uBBVGADiffCount);
 						}
 						if (pDevice->uBBVGADiffCount >= BB_VGA_CHANGE_THRESHOLD) {
-							DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
-								(int)ldBm, pDevice->byBBVGANew, pDevice->byBBVGACurrent, (int)pDevice->uBBVGADiffCount);
+							pr_debug("RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
+								 (int)ldBm,
+								 pDevice->byBBVGANew,
+								 pDevice->byBBVGACurrent,
+								 (int)pDevice->uBBVGADiffCount);
 							BBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);
 						}
 					} else {
@@ -2638,7 +2651,7 @@ static void device_set_multi(struct net_device *dev) {
 	VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
 
 	if (dev->flags & IFF_PROMISC) {         /* Set promiscuous. */
-		DBG_PRT(MSG_LEVEL_ERR, KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
+		pr_notice("%s: Promiscuous mode enabled\n", dev->name);
 		/* Unconditionally log net taps. */
 		pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);
 	} else if ((netdev_mc_count(dev) > pDevice->multicast_limit)
@@ -2670,7 +2683,7 @@ static void device_set_multi(struct net_device *dev) {
 	}
 
 	VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byRxMode);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode = %x\n", pDevice->byRxMode);
+	pr_debug("pDevice->byRxMode = %x\n", pDevice->byRxMode);
 }
 
 static struct net_device_stats *device_get_stats(struct net_device *dev)
@@ -2760,13 +2773,13 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 
 		// Set desired station name
 	case SIOCSIWNICKN:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN\n");
+		pr_debug(" SIOCSIWNICKN\n");
 		rc = -EOPNOTSUPP;
 		break;
 
 		// Get current station name
 	case SIOCGIWNICKN:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWNICKN\n");
+		pr_debug(" SIOCGIWNICKN\n");
 		rc = -EOPNOTSUPP;
 		break;
 
@@ -2863,12 +2876,12 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 
 		// Get the current Tx-Power
 	case SIOCGIWTXPOW:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW\n");
+		pr_debug(" SIOCGIWTXPOW\n");
 		rc = -EOPNOTSUPP;
 		break;
 
 	case SIOCSIWTXPOW:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWTXPOW\n");
+		pr_debug(" SIOCSIWTXPOW\n");
 		rc = -EOPNOTSUPP;
 		break;
 
@@ -2911,7 +2924,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		break;
 
 	case SIOCSIWSENS:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSENS\n");
+		pr_debug(" SIOCSIWSENS\n");
 		rc = -EOPNOTSUPP;
 		break;
 
@@ -2935,50 +2948,50 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	// Set the spy list
 	case SIOCSIWSPY:
 
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY\n");
+		pr_debug(" SIOCSIWSPY\n");
 		rc = -EOPNOTSUPP;
 		break;
 
 		// Get the spy list
 	case SIOCGIWSPY:
 
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWSPY\n");
+		pr_debug(" SIOCGIWSPY\n");
 		rc = -EOPNOTSUPP;
 		break;
 
 #endif // WIRELESS_SPY
 
 	case SIOCGIWPRIV:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV\n");
+		pr_debug(" SIOCGIWPRIV\n");
 		rc = -EOPNOTSUPP;
 		break;
 
 //2008-0409-07, <Add> by Einsn Liu
 #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 	case SIOCSIWAUTH:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAUTH\n");
+		pr_debug(" SIOCSIWAUTH\n");
 		rc = iwctl_siwauth(dev, NULL, &(wrq->u.param), NULL);
 		break;
 
 	case SIOCGIWAUTH:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWAUTH\n");
+		pr_debug(" SIOCGIWAUTH\n");
 		rc = iwctl_giwauth(dev, NULL, &(wrq->u.param), NULL);
 		break;
 
 	case SIOCSIWGENIE:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWGENIE\n");
+		pr_debug(" SIOCSIWGENIE\n");
 		rc = iwctl_siwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
 		break;
 
 	case SIOCGIWGENIE:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWGENIE\n");
+		pr_debug(" SIOCGIWGENIE\n");
 		rc = iwctl_giwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
 		break;
 
 	case SIOCSIWENCODEEXT: {
 		char extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];
 
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT\n");
+		pr_debug(" SIOCSIWENCODEEXT\n");
 		if (wrq->u.encoding.pointer) {
 			memset(extra, 0, sizeof(struct iw_encode_ext)+MAX_KEY_LEN + 1);
 			if (wrq->u.encoding.length > (sizeof(struct iw_encode_ext) + MAX_KEY_LEN)) {
@@ -2998,12 +3011,12 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	break;
 
 	case SIOCGIWENCODEEXT:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWENCODEEXT\n");
+		pr_debug(" SIOCGIWENCODEEXT\n");
 		rc = iwctl_giwencodeext(dev, NULL, &(wrq->u.encoding), NULL);
 		break;
 
 	case SIOCSIWMLME:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWMLME\n");
+		pr_debug(" SIOCSIWMLME\n");
 		rc = iwctl_siwmlme(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
 		break;
 
@@ -3061,7 +3074,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 
 	default:
 		rc = -EOPNOTSUPP;
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Ioctl command not support..%x\n", cmd);
+		pr_debug("Ioctl command not support..%x\n", cmd);
 
 	}
 
@@ -3072,7 +3085,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 			bScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);
 			spin_unlock_irq(&pDevice->lock);
 		} else {
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Commit the settings\n");
+			pr_debug("Commit the settings\n");
 			spin_lock_irq(&pDevice->lock);
 			pDevice->bLinkPass = false;
 			memset(pMgmt->abyCurrBSSID, 0, 6);

commit 1bd6375760ef13baeee404276b95034c691f2ed8
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Aug 10 15:47:02 2014 +0100

    staging: vt6655: device_main Replace DEVICE_INFO with size of pointer
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4f7509fc17c4..beab35d8a4cb 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -839,7 +839,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 		return -ENODEV;
 	}
 
-	dev = alloc_etherdev(sizeof(DEVICE_INFO));
+	dev = alloc_etherdev(sizeof(*pDevice));
 
 	pDevice = netdev_priv(dev);
 
@@ -999,7 +999,7 @@ static void vt6655_init_info(struct pci_dev *pcid,
 {
 	struct vnt_private *p;
 
-	memset(*ppDevice, 0, sizeof(DEVICE_INFO));
+	memset(*ppDevice, 0, sizeof(**ppDevice));
 
 	if (pDevice_Infos == NULL) {
 		pDevice_Infos = *ppDevice;

commit 3f8597f4e4b39b0505b3891f64d4c3be78d86717
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Aug 10 15:46:55 2014 +0100

    staging: vt6655: device.h use change __device_info to vnt_private
    
    Coverting all functions to struct vnt_private in device.h and device_main.c
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 3896eb325961..4f7509fc17c4 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -249,7 +249,7 @@ DEVICE_PARAM(bDiversityANTEnable, "ANT diversity mode");
 //
 
 static int          device_nics             = 0;
-static PSDevice     pDevice_Infos           = NULL;
+static struct vnt_private *pDevice_Infos = NULL;
 static struct net_device *root_device_dev = NULL;
 
 static CHIP_INFO chip_info_table[] = {
@@ -266,12 +266,13 @@ static const struct pci_device_id vt6655_pci_id_table[] = {
 /*---------------------  Static Functions  --------------------------*/
 
 static int  vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent);
-static void vt6655_init_info(struct pci_dev *pcid, PSDevice *ppDevice, PCHIP_INFO);
-static void device_free_info(PSDevice pDevice);
-static bool device_get_pci_info(PSDevice, struct pci_dev *pcid);
-static void device_print_info(PSDevice pDevice);
+static void vt6655_init_info(struct pci_dev *pcid,
+			     struct vnt_private **ppDevice, PCHIP_INFO);
+static void device_free_info(struct vnt_private *pDevice);
+static bool device_get_pci_info(struct vnt_private *, struct pci_dev *pcid);
+static void device_print_info(struct vnt_private *pDevice);
 static struct net_device_stats *device_get_stats(struct net_device *dev);
-static void device_init_diversity_timer(PSDevice pDevice);
+static void device_init_diversity_timer(struct vnt_private *pDevice);
 static int  device_open(struct net_device *dev);
 static int  device_xmit(struct sk_buff *skb, struct net_device *dev);
 static  irqreturn_t  device_intr(int irq,  void *dev_instance);
@@ -290,28 +291,28 @@ static struct notifier_block device_notifier = {
 };
 #endif
 
-static void device_init_rd0_ring(PSDevice pDevice);
-static void device_init_rd1_ring(PSDevice pDevice);
-static void device_init_defrag_cb(PSDevice pDevice);
-static void device_init_td0_ring(PSDevice pDevice);
-static void device_init_td1_ring(PSDevice pDevice);
+static void device_init_rd0_ring(struct vnt_private *pDevice);
+static void device_init_rd1_ring(struct vnt_private *pDevice);
+static void device_init_defrag_cb(struct vnt_private *pDevice);
+static void device_init_td0_ring(struct vnt_private *pDevice);
+static void device_init_td1_ring(struct vnt_private *pDevice);
 
 static int  device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev);
 //2008-0714<Add>by Mike Liu
-static bool device_release_WPADEV(PSDevice pDevice);
+static bool device_release_WPADEV(struct vnt_private *pDevice);
 
 static int  ethtool_ioctl(struct net_device *dev, void __user *useraddr);
-static int  device_rx_srv(PSDevice pDevice, unsigned int uIdx);
-static int  device_tx_srv(PSDevice pDevice, unsigned int uIdx);
-static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pDesc);
-static void device_init_registers(PSDevice pDevice);
-static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc);
-static void device_free_td0_ring(PSDevice pDevice);
-static void device_free_td1_ring(PSDevice pDevice);
-static void device_free_rd0_ring(PSDevice pDevice);
-static void device_free_rd1_ring(PSDevice pDevice);
-static void device_free_rings(PSDevice pDevice);
-static void device_free_frag_buf(PSDevice pDevice);
+static int  device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx);
+static int  device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx);
+static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pDesc);
+static void device_init_registers(struct vnt_private *pDevice);
+static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc);
+static void device_free_td0_ring(struct vnt_private *pDevice);
+static void device_free_td1_ring(struct vnt_private *pDevice);
+static void device_free_rd0_ring(struct vnt_private *pDevice);
+static void device_free_rd1_ring(struct vnt_private *pDevice);
+static void device_free_rings(struct vnt_private *pDevice);
+static void device_free_frag_buf(struct vnt_private *pDevice);
 static int Config_FileGetParameter(unsigned char *string,
 				   unsigned char *dest, unsigned char *source);
 
@@ -331,14 +332,15 @@ static char *get_chip_name(int chip_id)
 
 static void vt6655_remove(struct pci_dev *pcid)
 {
-	PSDevice pDevice = pci_get_drvdata(pcid);
+	struct vnt_private *pDevice = pci_get_drvdata(pcid);
 
 	if (pDevice == NULL)
 		return;
 	device_free_info(pDevice);
 }
 
-static void device_get_options(PSDevice pDevice, int index, char *devname)
+static void device_get_options(struct vnt_private *pDevice,
+			       int index, char *devname)
 {
 	POPTIONS pOpts = &(pDevice->sOpts);
 
@@ -363,7 +365,8 @@ static void device_get_options(PSDevice pDevice, int index, char *devname)
 }
 
 static void
-device_set_options(PSDevice pDevice) {
+device_set_options(struct vnt_private *pDevice)
+{
 	unsigned char abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 	unsigned char abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
 	unsigned char abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
@@ -411,7 +414,8 @@ device_set_options(PSDevice pDevice) {
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " pDevice->bDiversityRegCtlON= %d\n", (int)pDevice->bDiversityRegCtlON);
 }
 
-static void s_vCompleteCurrentMeasure(PSDevice pDevice, unsigned char byResult)
+static void s_vCompleteCurrentMeasure(struct vnt_private *pDevice,
+				      unsigned char byResult)
 {
 	unsigned int ii;
 	unsigned long dwDuration = 0;
@@ -453,7 +457,7 @@ static void s_vCompleteCurrentMeasure(PSDevice pDevice, unsigned char byResult)
 // Initialisation of MAC & BBP registers
 //
 
-static void device_init_registers(PSDevice pDevice)
+static void device_init_registers(struct vnt_private *pDevice)
 {
 	unsigned int ii;
 	unsigned char byValue;
@@ -763,7 +767,7 @@ static void device_init_registers(PSDevice pDevice)
 	netif_stop_queue(pDevice->dev);
 }
 
-static void device_init_diversity_timer(PSDevice pDevice)
+static void device_init_diversity_timer(struct vnt_private *pDevice)
 {
 	init_timer(&pDevice->TimerSQ3Tmax1);
 	pDevice->TimerSQ3Tmax1.data = (unsigned long) pDevice;
@@ -781,7 +785,7 @@ static void device_init_diversity_timer(PSDevice pDevice)
 	pDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);
 }
 
-static bool device_release_WPADEV(PSDevice pDevice)
+static bool device_release_WPADEV(struct vnt_private *pDevice)
 {
 	viawget_wpa_header *wpahdr;
 	int ii = 0;
@@ -827,7 +831,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	static bool bFirst = true;
 	struct net_device *dev = NULL;
 	PCHIP_INFO  pChip_info = (PCHIP_INFO)ent->driver_data;
-	PSDevice    pDevice;
+	struct vnt_private *pDevice;
 	int         rc;
 
 	if (device_nics++ >= MAX_UINTS) {
@@ -837,7 +841,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 	dev = alloc_etherdev(sizeof(DEVICE_INFO));
 
-	pDevice = (PSDevice) netdev_priv(dev);
+	pDevice = netdev_priv(dev);
 
 	if (dev == NULL) {
 		pr_err(DEVICE_NAME ": allocate net device failed\n");
@@ -977,7 +981,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	return 0;
 }
 
-static void device_print_info(PSDevice pDevice)
+static void device_print_info(struct vnt_private *pDevice)
 {
 	struct net_device *dev = pDevice->dev;
 
@@ -989,9 +993,11 @@ static void device_print_info(PSDevice pDevice)
 	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IRQ=%d\n", pDevice->dev->irq);
 }
 
-static void vt6655_init_info(struct pci_dev *pcid, PSDevice *ppDevice,
-			     PCHIP_INFO pChip_info) {
-	PSDevice p;
+static void vt6655_init_info(struct pci_dev *pcid,
+			     struct vnt_private **ppDevice,
+			     PCHIP_INFO pChip_info)
+{
+	struct vnt_private *p;
 
 	memset(*ppDevice, 0, sizeof(DEVICE_INFO));
 
@@ -1013,7 +1019,8 @@ static void vt6655_init_info(struct pci_dev *pcid, PSDevice *ppDevice,
 	spin_lock_init(&((*ppDevice)->lock));
 }
 
-static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid)
+static bool device_get_pci_info(struct vnt_private *pDevice,
+				struct pci_dev *pcid)
 {
 	u16 pci_cmd;
 	u8  b;
@@ -1061,9 +1068,9 @@ static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid)
 	return true;
 }
 
-static void device_free_info(PSDevice pDevice)
+static void device_free_info(struct vnt_private *pDevice)
 {
-	PSDevice         ptr;
+	struct vnt_private *ptr;
 	struct net_device *dev = pDevice->dev;
 
 	ASSERT(pDevice);
@@ -1106,7 +1113,7 @@ static void device_free_info(PSDevice pDevice)
 		free_netdev(dev);
 }
 
-static bool device_init_rings(PSDevice pDevice)
+static bool device_init_rings(struct vnt_private *pDevice)
 {
 	void *vir_pool;
 
@@ -1182,7 +1189,7 @@ static bool device_init_rings(PSDevice pDevice)
 	return true;
 }
 
-static void device_free_rings(PSDevice pDevice)
+static void device_free_rings(struct vnt_private *pDevice)
 {
 	pci_free_consistent(pDevice->pcid,
 			    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
@@ -1203,7 +1210,7 @@ static void device_free_rings(PSDevice pDevice)
 			);
 }
 
-static void device_init_rd0_ring(PSDevice pDevice)
+static void device_init_rd0_ring(struct vnt_private *pDevice)
 {
 	int i;
 	dma_addr_t      curr = pDevice->rd0_pool_dma;
@@ -1228,7 +1235,7 @@ static void device_init_rd0_ring(PSDevice pDevice)
 	pDevice->pCurrRD[0] = &(pDevice->aRD0Ring[0]);
 }
 
-static void device_init_rd1_ring(PSDevice pDevice)
+static void device_init_rd1_ring(struct vnt_private *pDevice)
 {
 	int i;
 	dma_addr_t      curr = pDevice->rd1_pool_dma;
@@ -1253,7 +1260,7 @@ static void device_init_rd1_ring(PSDevice pDevice)
 	pDevice->pCurrRD[1] = &(pDevice->aRD1Ring[0]);
 }
 
-static void device_init_defrag_cb(PSDevice pDevice)
+static void device_init_defrag_cb(struct vnt_private *pDevice)
 {
 	int i;
 	PSDeFragControlBlock pDeF;
@@ -1270,7 +1277,7 @@ static void device_init_defrag_cb(PSDevice pDevice)
 	pDevice->cbFreeDFCB = pDevice->cbDFCB;
 }
 
-static void device_free_rd0_ring(PSDevice pDevice)
+static void device_free_rd0_ring(struct vnt_private *pDevice)
 {
 	int i;
 
@@ -1287,7 +1294,7 @@ static void device_free_rd0_ring(PSDevice pDevice)
 	}
 }
 
-static void device_free_rd1_ring(PSDevice pDevice)
+static void device_free_rd1_ring(struct vnt_private *pDevice)
 {
 	int i;
 
@@ -1304,7 +1311,7 @@ static void device_free_rd1_ring(PSDevice pDevice)
 	}
 }
 
-static void device_free_frag_buf(PSDevice pDevice)
+static void device_free_frag_buf(struct vnt_private *pDevice)
 {
 	PSDeFragControlBlock pDeF;
 	int i;
@@ -1318,7 +1325,7 @@ static void device_free_frag_buf(PSDevice pDevice)
 	}
 }
 
-static void device_init_td0_ring(PSDevice pDevice)
+static void device_init_td0_ring(struct vnt_private *pDevice)
 {
 	int i;
 	dma_addr_t  curr;
@@ -1343,7 +1350,7 @@ static void device_init_td0_ring(PSDevice pDevice)
 	pDevice->apTailTD[0] = pDevice->apCurrTD[0] = &(pDevice->apTD0Rings[0]);
 }
 
-static void device_init_td1_ring(PSDevice pDevice)
+static void device_init_td1_ring(struct vnt_private *pDevice)
 {
 	int i;
 	dma_addr_t  curr;
@@ -1369,7 +1376,7 @@ static void device_init_td1_ring(PSDevice pDevice)
 	pDevice->apTailTD[1] = pDevice->apCurrTD[1] = &(pDevice->apTD1Rings[0]);
 }
 
-static void device_free_td0_ring(PSDevice pDevice)
+static void device_free_td0_ring(struct vnt_private *pDevice)
 {
 	int i;
 
@@ -1388,7 +1395,7 @@ static void device_free_td0_ring(PSDevice pDevice)
 	}
 }
 
-static void device_free_td1_ring(PSDevice pDevice)
+static void device_free_td1_ring(struct vnt_private *pDevice)
 {
 	int i;
 
@@ -1409,7 +1416,7 @@ static void device_free_td1_ring(PSDevice pDevice)
 
 /*-----------------------------------------------------------------*/
 
-static int device_rx_srv(PSDevice pDevice, unsigned int uIdx)
+static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 {
 	PSRxDesc    pRD;
 	int works = 0;
@@ -1435,7 +1442,7 @@ static int device_rx_srv(PSDevice pDevice, unsigned int uIdx)
 	return works;
 }
 
-static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD)
+static bool device_alloc_rx_buf(struct vnt_private *pDevice, PSRxDesc pRD)
 {
 	PDEVICE_RD_INFO pRDInfo = pRD->pRDInfo;
 
@@ -1456,7 +1463,8 @@ static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD)
 	return true;
 }
 
-bool device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF)
+bool device_alloc_frag_buf(struct vnt_private *pDevice,
+			   PSDeFragControlBlock pDeF)
 {
 	pDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
 	if (pDeF->skb == NULL)
@@ -1467,7 +1475,7 @@ bool device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF)
 	return true;
 }
 
-static int device_tx_srv(PSDevice pDevice, unsigned int uIdx)
+static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)
 {
 	PSTxDesc                 pTD;
 	bool bFull = false;
@@ -1591,7 +1599,7 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx)
 	return works;
 }
 
-static void device_error(PSDevice pDevice, unsigned short status)
+static void device_error(struct vnt_private *pDevice, unsigned short status)
 {
 	if (status & ISR_FETALERR) {
 		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
@@ -1606,7 +1614,7 @@ static void device_error(PSDevice pDevice, unsigned short status)
 	}
 }
 
-static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc)
+static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)
 {
 	PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
 	struct sk_buff *skb = pTDInfo->skb;
@@ -1627,7 +1635,7 @@ static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc)
 
 static int  device_open(struct net_device *dev)
 {
-	PSDevice pDevice = (PSDevice)netdev_priv(dev);
+	struct vnt_private *pDevice = netdev_priv(dev);
 	int i;
 #ifdef WPA_SM_Transtatus
 	extern SWPAResult wpa_Result;
@@ -1711,7 +1719,7 @@ static int  device_open(struct net_device *dev)
 
 static int  device_close(struct net_device *dev)
 {
-	PSDevice  pDevice = (PSDevice)netdev_priv(dev);
+	struct vnt_private *pDevice = netdev_priv(dev);
 	PSMgmtObject     pMgmt = pDevice->pMgmt;
 	//PLICE_DEBUG->
 //PLICE_DEBUG<-
@@ -1757,7 +1765,7 @@ static int  device_close(struct net_device *dev)
 
 static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev)
 {
-	PSDevice pDevice = netdev_priv(dev);
+	struct vnt_private *pDevice = netdev_priv(dev);
 	unsigned char *pbMPDU;
 	unsigned int cbMPDULen = 0;
 
@@ -1787,7 +1795,8 @@ static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev)
 	return 0;
 }
 
-bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeIndex)
+bool device_dma0_xmit(struct vnt_private *pDevice,
+		      struct sk_buff *skb, unsigned int uNodeIndex)
 {
 	PSMgmtObject    pMgmt = pDevice->pMgmt;
 	PSTxDesc        pHeadTD, pLastTD;
@@ -1927,10 +1936,8 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 }
 
 //TYPE_AC0DMA data tx
-static int  device_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	PSDevice pDevice = netdev_priv(dev);
-
+static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
+	struct vnt_private *pDevice = netdev_priv(dev);
 	PSMgmtObject    pMgmt = pDevice->pMgmt;
 	PSTxDesc        pHeadTD, pLastTD;
 	unsigned int uNodeIndex = 0;
@@ -2282,8 +2289,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev)
 static  irqreturn_t  device_intr(int irq,  void *dev_instance)
 {
 	struct net_device *dev = dev_instance;
-	PSDevice     pDevice = (PSDevice)netdev_priv(dev);
-
+	struct vnt_private *pDevice = netdev_priv(dev);
 	int             max_count = 0;
 	unsigned long dwMIBCounter = 0;
 	PSMgmtObject    pMgmt = pDevice->pMgmt;
@@ -2575,7 +2581,8 @@ static int Config_FileGetParameter(unsigned char *string,
 	return true;
 }
 
-int Config_FileOperation(PSDevice pDevice, bool fwrite, unsigned char *Parameter)
+int Config_FileOperation(struct vnt_private *pDevice,
+			 bool fwrite, unsigned char *Parameter)
 {
 	unsigned char *buffer = kmalloc(1024, GFP_KERNEL);
 	unsigned char tmpbuffer[20];
@@ -2622,10 +2629,8 @@ int Config_FileOperation(PSDevice pDevice, bool fwrite, unsigned char *Parameter
 	return result;
 }
 
-static void device_set_multi(struct net_device *dev)
-{
-	PSDevice         pDevice = (PSDevice)netdev_priv(dev);
-
+static void device_set_multi(struct net_device *dev) {
+	struct vnt_private *pDevice = netdev_priv(dev);
 	PSMgmtObject     pMgmt = pDevice->pMgmt;
 	u32              mc_filter[2];
 	struct netdev_hw_addr *ha;
@@ -2670,15 +2675,14 @@ static void device_set_multi(struct net_device *dev)
 
 static struct net_device_stats *device_get_stats(struct net_device *dev)
 {
-	PSDevice pDevice = (PSDevice)netdev_priv(dev);
+	struct vnt_private *pDevice = netdev_priv(dev);
 
 	return &pDevice->stats;
 }
 
 static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
-	PSDevice	        pDevice = (PSDevice)netdev_priv(dev);
-
+	struct vnt_private *pDevice = netdev_priv(dev);
 	struct iwreq *wrq = (struct iwreq *)rq;
 	int rc = 0;
 	PSMgmtObject pMgmt = pDevice->pMgmt;
@@ -3175,7 +3179,7 @@ viawget_suspend(struct pci_dev *pcid, pm_message_t state)
 {
 	int power_status;   // to silence the compiler
 
-	PSDevice pDevice = pci_get_drvdata(pcid);
+	struct vnt_private *pDevice = pci_get_drvdata(pcid);
 	PSMgmtObject  pMgmt = pDevice->pMgmt;
 
 	netif_stop_queue(pDevice->dev);
@@ -3201,7 +3205,7 @@ viawget_suspend(struct pci_dev *pcid, pm_message_t state)
 static int
 viawget_resume(struct pci_dev *pcid)
 {
-	PSDevice  pDevice = pci_get_drvdata(pcid);
+	struct vnt_private *pDevice = pci_get_drvdata(pcid);
 	PSMgmtObject  pMgmt = pDevice->pMgmt;
 	int power_status;   // to silence the compiler
 

commit f2af99ee5bca2eccc2d61bfee0ad82c84af18f8f
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Aug 10 12:21:56 2014 +0100

    staging: vt6655: Remove TxInSleep macro
    
    TxInSleep is always enabled remove the macro and any
    else code.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0b583a37f5b3..3896eb325961 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1720,9 +1720,8 @@ static int  device_close(struct net_device *dev)
 		bScheduleCommand((void *)pDevice, WLAN_CMD_DISASSOCIATE, NULL);
 		mdelay(30);
 	}
-#ifdef TxInSleep
+
 	del_timer(&pDevice->sTimerTxData);
-#endif
 	del_timer(&pDevice->sTimerCommand);
 	del_timer(&pMgmt->sTimerSecondCallback);
 	if (pDevice->bDiversityRegCtlON) {
@@ -2232,9 +2231,8 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev)
 	pLastTD->pTDInfo->skb = skb;
 	pLastTD->pTDInfo->byFlags = 0;
 	pLastTD->pTDInfo->byFlags |= TD_FLAGS_NETIF_SKB;
-#ifdef TxInSleep
 	pDevice->nTxDataTimeCout = 0; //2008-8-21 chester <add> for send null packet
-#endif
+
 	if (AVAIL_TD(pDevice, TYPE_AC0DMA) <= 1)
 		netif_stop_queue(dev);
 

commit 8b983be54bb5c4ff133e3aa45fe50669089d0a68
Author: Joe Perches <joe@perches.com>
Date:   Fri Aug 8 14:24:48 2014 -0700

    staging: use pci_zalloc_consistent
    
    Remove the now unnecessary memset too.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Lior Dotan <liodot@gmail.com>
    Cc: Christopher Harrer <charrer@alacritech.com>
    Cc: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c78d06eff7ea..0b583a37f5b3 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1111,25 +1111,17 @@ static bool device_init_rings(PSDevice pDevice)
 	void *vir_pool;
 
 	/*allocate all RD/TD rings a single pool*/
-	vir_pool = pci_alloc_consistent(pDevice->pcid,
-					pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
-					pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
-					pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
-					pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
-					&pDevice->pool_dma);
-
+	vir_pool = pci_zalloc_consistent(pDevice->pcid,
+					 pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
+					 pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
+					 pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
+					 pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
+					 &pDevice->pool_dma);
 	if (vir_pool == NULL) {
 		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s : allocate desc dma memory failed\n", pDevice->dev->name);
 		return false;
 	}
 
-	memset(vir_pool, 0,
-	       pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
-	       pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
-	       pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
-	       pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc)
-		);
-
 	pDevice->aRD0Ring = vir_pool;
 	pDevice->aRD1Ring = vir_pool +
 		pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
@@ -1138,13 +1130,12 @@ static bool device_init_rings(PSDevice pDevice)
 	pDevice->rd1_pool_dma = pDevice->rd0_pool_dma +
 		pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
 
-	pDevice->tx0_bufs = pci_alloc_consistent(pDevice->pcid,
-						 pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
-						 pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
-						 CB_BEACON_BUF_SIZE +
-						 CB_MAX_BUF_SIZE,
-						 &pDevice->tx_bufs_dma0);
-
+	pDevice->tx0_bufs = pci_zalloc_consistent(pDevice->pcid,
+						  pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
+						  pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
+						  CB_BEACON_BUF_SIZE +
+						  CB_MAX_BUF_SIZE,
+						  &pDevice->tx_bufs_dma0);
 	if (pDevice->tx0_bufs == NULL) {
 		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: allocate buf dma memory failed\n", pDevice->dev->name);
 		pci_free_consistent(pDevice->pcid,
@@ -1157,13 +1148,6 @@ static bool device_init_rings(PSDevice pDevice)
 		return false;
 	}
 
-	memset(pDevice->tx0_bufs, 0,
-	       pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
-	       pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
-	       CB_BEACON_BUF_SIZE +
-	       CB_MAX_BUF_SIZE
-		);
-
 	pDevice->td0_pool_dma = pDevice->rd1_pool_dma +
 		pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);
 

commit 53ee983378ff23e8f3ff95ecf99dea7c6c221900
Merge: 29b88e23a921 b9aaea39f65e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 4 18:36:12 2014 -0700

    Merge tag 'staging-3.17-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging driver updates from Greg KH:
     "Here's the big pull request for the staging driver tree for 3.17-rc1.
    
      Lots of things in here, over 2000 patches, but the best part is this:
       1480 files changed, 39070 insertions(+), 254659 deletions(-)
    
      Thanks to the great work of Kristina Martenko, 14 different staging
      drivers have been removed from the tree as they were obsolete and no
      one was willing to work on cleaning them up.  Other than the driver
      removals, loads of cleanups are in here (comedi, lustre, etc.) as well
      as the usual IIO driver updates and additions.
    
      All of this has been in the linux-next tree for a while"
    
    * tag 'staging-3.17-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (2199 commits)
      staging: comedi: addi_apci_1564: remove diagnostic interrupt support code
      staging: comedi: addi_apci_1564: add subdevice to check diagnostic status
      staging: wlan-ng: coding style problem fix
      staging: wlan-ng: fixing coding style problems
      staging: comedi: ii_pci20kc: request and ioremap memory
      staging: lustre: bitwise vs logical typo
      staging: dgnc: Remove unneeded dgnc_trace.c and dgnc_trace.h
      staging: dgnc: rephrase comment
      staging: comedi: ni_tio: remove some dead code
      staging: rtl8723au: Fix static symbol sparse warning
      staging: rtl8723au: usb_dvobj_init(): Remove unused variable 'pdev_desc'
      staging: rtl8723au: Do not duplicate kernel provided USB macros
      staging: rtl8723au: Remove never set struct pwrctrl_priv.bHWPowerdown
      staging: rtl8723au: Remove two never set variables
      staging: rtl8723au: RSSI_test is never set
      staging:r8190: coding style: Fixed checkpatch reported Error
      staging:r8180: coding style: Fixed too long lines
      staging:r8180: coding style: Fixed commenting style
      staging: lustre: ptlrpc: lproc_ptlrpc.c - fix dereferenceing user space buffer
      staging: lustre: ldlm: ldlm_resource.c - fix dereferenceing user space buffer
      ...

commit 3500a1da81c25f03e4eed159a38e96d280eba6e9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Jul 28 23:26:26 2014 +0100

    staging: vt6655: clean up the tail of function device_init_registers
    
    Aligning the code.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0ecc99bf8ab4..3f72c34ecddd 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -736,30 +736,31 @@ static void device_init_registers(PSDevice pDevice)
 	if (pDevice->bHWRadioOff || pDevice->bRadioControlOff)
 		CARDbRadioPowerOff(pDevice);
 
-pMgmt->eScanType = WMAC_SCAN_PASSIVE;
-// get Permanent network address
-SROMvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
-DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Network address = %pM\n",
-	pDevice->abyCurrentNetAddr);
+	pMgmt->eScanType = WMAC_SCAN_PASSIVE;
 
-// reset Tx pointer
-CARDvSafeResetRx(pDevice);
-// reset Rx pointer
-CARDvSafeResetTx(pDevice);
+	/* get Permanent network address */
+	SROMvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Network address = %pM\n",
+		pDevice->abyCurrentNetAddr);
 
-if (pDevice->byLocalID <= REV_ID_VT3253_A1)
-	MACvRegBitsOn(pDevice->PortOffset, MAC_REG_RCR, RCR_WPAERR);
+	/* reset Tx pointer */
+	CARDvSafeResetRx(pDevice);
+	/* reset Rx pointer */
+	CARDvSafeResetTx(pDevice);
 
-pDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;
+	if (pDevice->byLocalID <= REV_ID_VT3253_A1)
+		MACvRegBitsOn(pDevice->PortOffset, MAC_REG_RCR, RCR_WPAERR);
 
-// Turn On Rx DMA
-MACvReceive0(pDevice->PortOffset);
-MACvReceive1(pDevice->PortOffset);
+	pDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;
 
-// start the adapter
-MACvStart(pDevice->PortOffset);
+	/* Turn On Rx DMA */
+	MACvReceive0(pDevice->PortOffset);
+	MACvReceive1(pDevice->PortOffset);
 
-netif_stop_queue(pDevice->dev);
+	/* start the adapter */
+	MACvStart(pDevice->PortOffset);
+
+	netif_stop_queue(pDevice->dev);
 }
 
 static void device_init_diversity_timer(PSDevice pDevice)

commit 9f34de35d57c75b769c8ee48ab88ef8bdb7d1bd4
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Jul 28 23:26:25 2014 +0100

    staging: vt6655: remove typedef enum __device_init_type
    
    The value is either DEVICE_INIT_COLD or DEVICE_INIT_DXPL making no
    difference to code.
    
    Remove typedef and remove if statement in device_init_registers
    pulling the code in.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 926c0d99f549..0ecc99bf8ab4 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -304,7 +304,7 @@ static int  ethtool_ioctl(struct net_device *dev, void __user *useraddr);
 static int  device_rx_srv(PSDevice pDevice, unsigned int uIdx);
 static int  device_tx_srv(PSDevice pDevice, unsigned int uIdx);
 static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pDesc);
-static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType);
+static void device_init_registers(PSDevice pDevice);
 static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc);
 static void device_free_td0_ring(PSDevice pDevice);
 static void device_free_td1_ring(PSDevice pDevice);
@@ -453,7 +453,7 @@ static void s_vCompleteCurrentMeasure(PSDevice pDevice, unsigned char byResult)
 // Initialisation of MAC & BBP registers
 //
 
-static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
+static void device_init_registers(PSDevice pDevice)
 {
 	unsigned int ii;
 	unsigned char byValue;
@@ -466,239 +466,276 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 	MACbShutdown(pDevice->PortOffset);
 	BBvSoftwareReset(pDevice->PortOffset);
 
-	if ((InitType == DEVICE_INIT_COLD) ||
-	    (InitType == DEVICE_INIT_DXPL)) {
-		// Do MACbSoftwareReset in MACvInitialize
-		MACbSoftwareReset(pDevice->PortOffset);
-		// force CCK
-		pDevice->bCCK = true;
-		pDevice->bAES = false;
-		pDevice->bProtectMode = false;      //Only used in 11g type, sync with ERP IE
-		pDevice->bNonERPPresent = false;
-		pDevice->bBarkerPreambleMd = false;
-		pDevice->wCurrentRate = RATE_1M;
-		pDevice->byTopOFDMBasicRate = RATE_24M;
-		pDevice->byTopCCKBasicRate = RATE_1M;
+	/* Do MACbSoftwareReset in MACvInitialize */
+	MACbSoftwareReset(pDevice->PortOffset);
 
-		pDevice->byRevId = 0;                   //Target to IF pin while programming to RF chip.
+	/* force CCK */
+	pDevice->bCCK = true;
+	pDevice->bAES = false;
 
-		// init MAC
-		MACvInitialize(pDevice->PortOffset);
+	/* Only used in 11g type, sync with ERP IE */
+	pDevice->bProtectMode = false;
 
-		// Get Local ID
-		VNSvInPortB(pDevice->PortOffset + MAC_REG_LOCALID, &(pDevice->byLocalID));
+	pDevice->bNonERPPresent = false;
+	pDevice->bBarkerPreambleMd = false;
+	pDevice->wCurrentRate = RATE_1M;
+	pDevice->byTopOFDMBasicRate = RATE_24M;
+	pDevice->byTopCCKBasicRate = RATE_1M;
 
-		spin_lock_irq(&pDevice->lock);
-		SROMvReadAllContents(pDevice->PortOffset, pDevice->abyEEPROM);
+	/* Target to IF pin while programming to RF chip. */
+	pDevice->byRevId = 0;
 
-		spin_unlock_irq(&pDevice->lock);
+	/* init MAC */
+	MACvInitialize(pDevice->PortOffset);
+
+	/* Get Local ID */
+	VNSvInPortB(pDevice->PortOffset + MAC_REG_LOCALID, &pDevice->byLocalID);
+
+	spin_lock_irq(&pDevice->lock);
 
-		// Get Channel range
+	SROMvReadAllContents(pDevice->PortOffset, pDevice->abyEEPROM);
 
-		pDevice->byMinChannel = 1;
-		pDevice->byMaxChannel = CB_MAX_CHANNEL;
+	spin_unlock_irq(&pDevice->lock);
+
+	/* Get Channel range */
+	pDevice->byMinChannel = 1;
+	pDevice->byMaxChannel = CB_MAX_CHANNEL;
 
-		// Get Antena
-		byValue = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
-		if (byValue & EEP_ANTINV)
-			pDevice->bTxRxAntInv = true;
+	/* Get Antena */
+	byValue = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
+	if (byValue & EEP_ANTINV)
+		pDevice->bTxRxAntInv = true;
+	else
+		pDevice->bTxRxAntInv = false;
+
+	byValue &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
+	/* if not set default is All */
+	if (byValue == 0)
+		byValue = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
+
+	pDevice->ulDiversityNValue = 100*260;
+	pDevice->ulDiversityMValue = 100*16;
+	pDevice->byTMax = 1;
+	pDevice->byTMax2 = 4;
+	pDevice->ulSQ3TH = 0;
+	pDevice->byTMax3 = 64;
+
+	if (byValue == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {
+		pDevice->byAntennaCount = 2;
+		pDevice->byTxAntennaMode = ANT_B;
+		pDevice->dwTxAntennaSel = 1;
+		pDevice->dwRxAntennaSel = 1;
+
+		if (pDevice->bTxRxAntInv)
+			pDevice->byRxAntennaMode = ANT_A;
 		else
-			pDevice->bTxRxAntInv = false;
+			pDevice->byRxAntennaMode = ANT_B;
+
+		byValue1 = SROMbyReadEmbedded(pDevice->PortOffset,
+					      EEP_OFS_ANTENNA);
 
-		byValue &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
-		if (byValue == 0) // if not set default is All
-			byValue = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
+		if ((byValue1 & 0x08) == 0)
+			pDevice->bDiversityEnable = false;
+		else
+			pDevice->bDiversityEnable = true;
+	} else  {
+		pDevice->bDiversityEnable = false;
+		pDevice->byAntennaCount = 1;
+		pDevice->dwTxAntennaSel = 0;
+		pDevice->dwRxAntennaSel = 0;
 
-		pDevice->ulDiversityNValue = 100*260;
-		pDevice->ulDiversityMValue = 100*16;
-		pDevice->byTMax = 1;
-		pDevice->byTMax2 = 4;
-		pDevice->ulSQ3TH = 0;
-		pDevice->byTMax3 = 64;
+		if (byValue & EEP_ANTENNA_AUX) {
+			pDevice->byTxAntennaMode = ANT_A;
 
-		if (byValue == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {
-			pDevice->byAntennaCount = 2;
+			if (pDevice->bTxRxAntInv)
+				pDevice->byRxAntennaMode = ANT_B;
+			else
+				pDevice->byRxAntennaMode = ANT_A;
+		} else {
 			pDevice->byTxAntennaMode = ANT_B;
-			pDevice->dwTxAntennaSel = 1;
-			pDevice->dwRxAntennaSel = 1;
+
 			if (pDevice->bTxRxAntInv)
 				pDevice->byRxAntennaMode = ANT_A;
 			else
 				pDevice->byRxAntennaMode = ANT_B;
-			// chester for antenna
-			byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
-			if ((byValue1 & 0x08) == 0)
-				pDevice->bDiversityEnable = false;
-			else
-				pDevice->bDiversityEnable = true;
-		} else  {
-			pDevice->bDiversityEnable = false;
-			pDevice->byAntennaCount = 1;
-			pDevice->dwTxAntennaSel = 0;
-			pDevice->dwRxAntennaSel = 0;
-			if (byValue & EEP_ANTENNA_AUX) {
-				pDevice->byTxAntennaMode = ANT_A;
-				if (pDevice->bTxRxAntInv)
-					pDevice->byRxAntennaMode = ANT_B;
-				else
-					pDevice->byRxAntennaMode = ANT_A;
-			} else {
-				pDevice->byTxAntennaMode = ANT_B;
-				if (pDevice->bTxRxAntInv)
-					pDevice->byRxAntennaMode = ANT_A;
-				else
-					pDevice->byRxAntennaMode = ANT_B;
-			}
 		}
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",
-			pDevice->bDiversityEnable, (int)pDevice->ulDiversityNValue, (int)pDevice->ulDiversityMValue, pDevice->byTMax, pDevice->byTMax2);
-
-//2008-8-4 <add> by chester
-//zonetype initial
-		pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
-		zonetype = Config_FileOperation(pDevice, false, NULL);
-		if (zonetype >= 0) {         //read zonetype file ok!
-			if ((zonetype == 0) &&
-			    (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x00)) {          //for USA
-				pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0;
-				pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0B;
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Init Zone Type :USA\n");
-			} else if ((zonetype == 1) &&
-				 (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x01)) {   //for Japan
-				pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x01;
-				pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
-			} else if ((zonetype == 2) &&
-				 (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x02)) {   //for Europe
-				pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x02;
-				pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Init Zone Type :Europe\n");
-			}
+	}
 
-			else {
-				if (zonetype != pDevice->abyEEPROM[EEP_OFS_ZONETYPE])
-					pr_debug("zonetype in file[%02x] mismatch with in EEPROM[%02x]\n", zonetype, pDevice->abyEEPROM[EEP_OFS_ZONETYPE]);
-				else
-					pr_debug("Read Zonetype file success,use default zonetype setting[%02x]\n", zonetype);
-			}
-		} else
-			pr_debug("Read Zonetype file fail,use default zonetype setting[%02x]\n", SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ZONETYPE));
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO
+		"bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",
+		pDevice->bDiversityEnable, (int)pDevice->ulDiversityNValue,
+		(int)pDevice->ulDiversityMValue, pDevice->byTMax, pDevice->byTMax2);
+
+	/* zonetype initial */
+	pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
+	zonetype = Config_FileOperation(pDevice, false, NULL);
+
+	if (zonetype >= 0) {
+		if ((zonetype == 0) &&
+		    (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x00)) {
+			/* for USA */
+			pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0;
+			pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0B;
+
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Init Zone Type :USA\n");
+		} else if ((zonetype == 1) &&
+			 (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x01)) {
+			/* for Japan */
+			pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x01;
+			pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
+		} else if ((zonetype == 2) &&
+			  (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x02)) {
+			/* for Europe */
+			pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x02;
+			pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
+
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Init Zone Type :Europe\n");
+		} else {
+			if (zonetype != pDevice->abyEEPROM[EEP_OFS_ZONETYPE])
+				pr_debug("zonetype in file[%02x] mismatch with in EEPROM[%02x]\n",
+					 zonetype,
+					 pDevice->abyEEPROM[EEP_OFS_ZONETYPE]);
+			else
+				pr_debug("Read Zonetype file success,use default zonetype setting[%02x]\n",
+					 zonetype);
+		}
+	} else {
+		pr_debug("Read Zonetype file fail,use default zonetype setting[%02x]\n",
+			 SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ZONETYPE));
+	}
 
-		// Get RFType
-		pDevice->byRFType = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RFTYPE);
+	/* Get RFType */
+	pDevice->byRFType = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RFTYPE);
 
-		if ((pDevice->byRFType & RF_EMU) != 0) {
-			// force change RevID for VT3253 emu
+	/* force change RevID for VT3253 emu */
+	if ((pDevice->byRFType & RF_EMU) != 0)
 			pDevice->byRevId = 0x80;
-		}
 
-		pDevice->byRFType &= RF_MASK;
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRFType = %x\n", pDevice->byRFType);
+	pDevice->byRFType &= RF_MASK;
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRFType = %x\n", pDevice->byRFType);
 
-		if (!pDevice->bZoneRegExist)
-			pDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
+	if (!pDevice->bZoneRegExist)
+		pDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
 
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byZoneType = %x\n", pDevice->byZoneType);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byZoneType = %x\n", pDevice->byZoneType);
 
-		//Init RF module
-		RFbInit(pDevice);
+	/* Init RF module */
+	RFbInit(pDevice);
 
-		//Get Desire Power Value
-		pDevice->byCurPwr = 0xFF;
-		pDevice->byCCKPwr = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_CCK);
-		pDevice->byOFDMPwrG = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_OFDMG);
+	/* Get Desire Power Value */
+	pDevice->byCurPwr = 0xFF;
+	pDevice->byCCKPwr = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_CCK);
+	pDevice->byOFDMPwrG = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_OFDMG);
 
-		// Load power Table
+	/* Load power Table */
+	for (ii = 0; ii < CB_MAX_CHANNEL_24G; ii++) {
+		pDevice->abyCCKPwrTbl[ii + 1] =
+			SROMbyReadEmbedded(pDevice->PortOffset,
+					   (unsigned char)(ii + EEP_OFS_CCK_PWR_TBL));
+		if (pDevice->abyCCKPwrTbl[ii + 1] == 0)
+			pDevice->abyCCKPwrTbl[ii+1] = pDevice->byCCKPwr;
 
-		for (ii = 0; ii < CB_MAX_CHANNEL_24G; ii++) {
-			pDevice->abyCCKPwrTbl[ii + 1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_CCK_PWR_TBL));
-			if (pDevice->abyCCKPwrTbl[ii + 1] == 0)
-				pDevice->abyCCKPwrTbl[ii+1] = pDevice->byCCKPwr;
+		pDevice->abyOFDMPwrTbl[ii + 1] =
+			SROMbyReadEmbedded(pDevice->PortOffset,
+					   (unsigned char)(ii + EEP_OFS_OFDM_PWR_TBL));
+		if (pDevice->abyOFDMPwrTbl[ii + 1] == 0)
+			pDevice->abyOFDMPwrTbl[ii + 1] = pDevice->byOFDMPwrG;
 
-			pDevice->abyOFDMPwrTbl[ii + 1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDM_PWR_TBL));
-			if (pDevice->abyOFDMPwrTbl[ii + 1] == 0)
-				pDevice->abyOFDMPwrTbl[ii + 1] = pDevice->byOFDMPwrG;
+		pDevice->abyCCKDefaultPwr[ii + 1] = byCCKPwrdBm;
+		pDevice->abyOFDMDefaultPwr[ii + 1] = byOFDMPwrdBm;
+	}
 
-			pDevice->abyCCKDefaultPwr[ii + 1] = byCCKPwrdBm;
-			pDevice->abyOFDMDefaultPwr[ii + 1] = byOFDMPwrdBm;
-		}
-		//2008-8-4 <add> by chester
-		//recover 12,13 ,14channel for EUROPE by 11 channel
-		if (((pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Japan) ||
-		     (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Europe)) &&
-		    (pDevice->byOriginalZonetype == ZoneType_USA)) {
-			for (ii = 11; ii < 14; ii++) {
-				pDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];
-				pDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];
+	/* recover 12,13 ,14channel for EUROPE by 11 channel */
+	if (((pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Japan) ||
+	     (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Europe)) &&
+	    (pDevice->byOriginalZonetype == ZoneType_USA)) {
+		for (ii = 11; ii < 14; ii++) {
+			pDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];
+			pDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];
 
-			}
 		}
+	}
 
-		// Load OFDM A Power Table
-		for (ii = 0; ii < CB_MAX_CHANNEL_5G; ii++) { //RobertYu:20041224, bug using CB_MAX_CHANNEL
-			pDevice->abyOFDMPwrTbl[ii + CB_MAX_CHANNEL_24G + 1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDMA_PWR_TBL));
-			pDevice->abyOFDMDefaultPwr[ii + CB_MAX_CHANNEL_24G + 1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDMA_PWR_dBm));
-		}
-		init_channel_table((void *)pDevice);
+	/* Load OFDM A Power Table */
+	for (ii = 0; ii < CB_MAX_CHANNEL_5G; ii++) {
+		pDevice->abyOFDMPwrTbl[ii + CB_MAX_CHANNEL_24G + 1] =
+			SROMbyReadEmbedded(pDevice->PortOffset,
+					   (unsigned char)(ii + EEP_OFS_OFDMA_PWR_TBL));
 
-		if (pDevice->byLocalID > REV_ID_VT3253_B1) {
-			MACvSelectPage1(pDevice->PortOffset);
-			VNSvOutPortB(pDevice->PortOffset + MAC_REG_MSRCTL + 1, (MSRCTL1_TXPWR | MSRCTL1_CSAPAREN));
-			MACvSelectPage0(pDevice->PortOffset);
-		}
+		pDevice->abyOFDMDefaultPwr[ii + CB_MAX_CHANNEL_24G + 1] =
+			SROMbyReadEmbedded(pDevice->PortOffset,
+					   (unsigned char)(ii + EEP_OFS_OFDMA_PWR_dBm));
+	}
+
+	init_channel_table((void *)pDevice);
+
+	if (pDevice->byLocalID > REV_ID_VT3253_B1) {
+		MACvSelectPage1(pDevice->PortOffset);
 
-		// use relative tx timeout and 802.11i D4
-		MACvWordRegBitsOn(pDevice->PortOffset, MAC_REG_CFG, (CFG_TKIPOPT | CFG_NOTXTIMEOUT));
+		VNSvOutPortB(pDevice->PortOffset + MAC_REG_MSRCTL + 1,
+			     (MSRCTL1_TXPWR | MSRCTL1_CSAPAREN));
 
-		// set performance parameter by registry
-		MACvSetShortRetryLimit(pDevice->PortOffset, pDevice->byShortRetryLimit);
-		MACvSetLongRetryLimit(pDevice->PortOffset, pDevice->byLongRetryLimit);
+		MACvSelectPage0(pDevice->PortOffset);
+	}
 
-		// reset TSF counter
-		VNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
-		// enable TSF counter
-		VNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
+	/* use relative tx timeout and 802.11i D4 */
+	MACvWordRegBitsOn(pDevice->PortOffset,
+			  MAC_REG_CFG, (CFG_TKIPOPT | CFG_NOTXTIMEOUT));
 
-		// initialize BBP registers
-		BBbVT3253Init(pDevice);
+	/* set performance parameter by registry */
+	MACvSetShortRetryLimit(pDevice->PortOffset, pDevice->byShortRetryLimit);
+	MACvSetLongRetryLimit(pDevice->PortOffset, pDevice->byLongRetryLimit);
 
-		if (pDevice->bUpdateBBVGA) {
-			pDevice->byBBVGACurrent = pDevice->abyBBVGA[0];
-			pDevice->byBBVGANew = pDevice->byBBVGACurrent;
-			BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
-		}
-		BBvSetRxAntennaMode(pDevice->PortOffset, pDevice->byRxAntennaMode);
-		BBvSetTxAntennaMode(pDevice->PortOffset, pDevice->byTxAntennaMode);
+	/* reset TSF counter */
+	VNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
+	/* enable TSF counter */
+	VNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
 
-		pDevice->byCurrentCh = 0;
+	/* initialize BBP registers */
+	BBbVT3253Init(pDevice);
 
-		// Set BB and packet type at the same time.
-		// Set Short Slot Time, xIFS, and RSPINF.
-		if (pDevice->uConnectionRate == RATE_AUTO)
-			pDevice->wCurrentRate = RATE_54M;
-		else
-			pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
+	if (pDevice->bUpdateBBVGA) {
+		pDevice->byBBVGACurrent = pDevice->abyBBVGA[0];
+		pDevice->byBBVGANew = pDevice->byBBVGACurrent;
+		BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
+	}
+
+	BBvSetRxAntennaMode(pDevice->PortOffset, pDevice->byRxAntennaMode);
+	BBvSetTxAntennaMode(pDevice->PortOffset, pDevice->byTxAntennaMode);
+
+	pDevice->byCurrentCh = 0;
 
-		// default G Mode
-		VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_11G);
-		VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_AUTO);
+	/* Set BB and packet type at the same time. */
+	/* Set Short Slot Time, xIFS, and RSPINF. */
+	if (pDevice->uConnectionRate == RATE_AUTO)
+		pDevice->wCurrentRate = RATE_54M;
+	else
+		pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
+
+	/* default G Mode */
+	VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_11G);
+	VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_AUTO);
 
-		pDevice->bRadioOff = false;
+	pDevice->bRadioOff = false;
 
-		pDevice->byRadioCtl = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RADIOCTL);
-		pDevice->bHWRadioOff = false;
+	pDevice->byRadioCtl = SROMbyReadEmbedded(pDevice->PortOffset,
+						 EEP_OFS_RADIOCTL);
+	pDevice->bHWRadioOff = false;
 
-		if (pDevice->byRadioCtl & EEP_RADIOCTL_ENABLE) {
-			// Get GPIO
-			MACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);
-//2008-4-14 <add> by chester for led issue
-		if (((pDevice->byGPIO & GPIO0_DATA) && !(pDevice->byRadioCtl & EEP_RADIOCTL_INV)) ||
-		    (!(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV))) {
+	if (pDevice->byRadioCtl & EEP_RADIOCTL_ENABLE) {
+		/* Get GPIO */
+		MACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);
+
+		if (((pDevice->byGPIO & GPIO0_DATA) &&
+		     !(pDevice->byRadioCtl & EEP_RADIOCTL_INV)) ||
+		     (!(pDevice->byGPIO & GPIO0_DATA) &&
+		     (pDevice->byRadioCtl & EEP_RADIOCTL_INV)))
 			pDevice->bHWRadioOff = true;
-		}
 	}
+
 	if (pDevice->bHWRadioOff || pDevice->bRadioControlOff)
 		CARDbRadioPowerOff(pDevice);
-}
+
 pMgmt->eScanType = WMAC_SCAN_PASSIVE;
 // get Permanent network address
 SROMvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
@@ -1642,7 +1679,8 @@ static int  device_open(struct net_device *dev)
 	vMgrTimerInit(pDevice);
 
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
-	device_init_registers(pDevice, DEVICE_INIT_COLD);
+	device_init_registers(pDevice);
+
 	MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
 	memcpy(pDevice->pMgmt->abyMACAddr, pDevice->abyCurrentNetAddr, ETH_ALEN);
 	device_set_multi(pDevice->dev);
@@ -3187,7 +3225,7 @@ viawget_resume(struct pci_dev *pcid)
 	if (netif_running(pDevice->dev)) {
 		spin_lock_irq(&pDevice->lock);
 		MACvRestoreContext(pDevice->PortOffset, pDevice->abyMacContext);
-		device_init_registers(pDevice, DEVICE_INIT_DXPL);
+		device_init_registers(pDevice);
 		if (pMgmt->sNodeDBTable[0].bActive) { // Assoc with BSS
 			pMgmt->sNodeDBTable[0].bActive = false;
 			pDevice->bLinkPass = false;

commit fbf515b81569585c8f404bc12fbcc59e44fdcd85
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Jul 28 21:43:30 2014 +0100

    staging: vt6655: dead code remove undefined macro IO_MAP
    
    This device is always memory mapped
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index e8584fd565c5..926c0d99f549 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -902,10 +902,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	VNSvInPortB(pDevice->PortOffset+0x4F, &value);
 	pr_debug("After write: value is %x\n", value);
 #endif
-
-#ifdef IO_MAP
-	pDevice->PortOffset = pDevice->ioaddr;
-#endif
 	// do reset
 	if (!MACbSoftwareReset(pDevice->PortOffset)) {
 		pr_err(DEVICE_NAME ": Failed to access MAC hardware..\n");
@@ -949,14 +945,10 @@ static void device_print_info(PSDevice pDevice)
 
 	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: %s\n", dev->name, get_chip_name(pDevice->chip_id));
 	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: MAC=%pM", dev->name, dev->dev_addr);
-#ifdef IO_MAP
-	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IO=0x%lx  ", (unsigned long)pDevice->ioaddr);
-	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IRQ=%d\n", pDevice->dev->irq);
-#else
+
 	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IO=0x%lx Mem=0x%lx ",
 		(unsigned long)pDevice->ioaddr, (unsigned long)pDevice->PortOffset);
 	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IRQ=%d\n", pDevice->dev->irq);
-#endif
 }
 
 static void vt6655_init_info(struct pci_dev *pcid, PSDevice *ppDevice,

commit 33c1576ea1feb1817600aad4299537e92b90ebb5
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Jul 28 21:43:29 2014 +0100

    staging: vt6655: dead code remove undefined macro FOR_LED_ON_NOTEBOOK code.
    
    Removing all variables associated with the code.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index fe6de98856ae..e8584fd565c5 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -691,19 +691,6 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 			// Get GPIO
 			MACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);
 //2008-4-14 <add> by chester for led issue
-#ifdef FOR_LED_ON_NOTEBOOK
-			if (pDevice->byGPIO & GPIO0_DATA)
-				pDevice->bHWRadioOff = true;
-
-			if (!(pDevice->byGPIO & GPIO0_DATA))
-				pDevice->bHWRadioOff = false;
-		}
-
-		if (pDevice->bRadioControlOff)
-			CARDbRadioPowerOff(pDevice);
-		else
-			CARDbRadioPowerOn(pDevice);
-#else
 		if (((pDevice->byGPIO & GPIO0_DATA) && !(pDevice->byRadioCtl & EEP_RADIOCTL_INV)) ||
 		    (!(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV))) {
 			pDevice->bHWRadioOff = true;
@@ -711,8 +698,6 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 	}
 	if (pDevice->bHWRadioOff || pDevice->bRadioControlOff)
 		CARDbRadioPowerOff(pDevice);
-
-#endif
 }
 pMgmt->eScanType = WMAC_SCAN_PASSIVE;
 // get Permanent network address

commit 9a802f2edc5bfc3d19ccb094182e60fdd36ee6ec
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Jul 28 21:43:28 2014 +0100

    staging: vt6655: deadcode remove undefined macro THREAD code.
    
    Removing _RxManagementQueue, InitRxManagementQueue, MlmeThread, mlme_kill,
    EnQueue and DeQueue.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c43fc79eb4c6..fe6de98856ae 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -98,10 +98,6 @@ MODULE_AUTHOR("VIA Networking Technologies, Inc., <lyndonchen@vntek.com.tw>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("VIA Networking Solomon-A/B/G Wireless LAN Adapter Driver");
 
-#ifdef	THREAD
-static int mlme_kill;
-#endif
-
 #define DEVICE_PARAM(N, D)
 
 #define RX_DESC_MIN0     16
@@ -1630,41 +1626,6 @@ static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc)
 	pTDInfo->byFlags = 0;
 }
 
-//PLICE_DEBUG ->
-void	InitRxManagementQueue(PSDevice  pDevice)
-{
-	pDevice->rxManeQueue.packet_num = 0;
-	pDevice->rxManeQueue.head = pDevice->rxManeQueue.tail = 0;
-}
-//PLICE_DEBUG<-
-
-//PLICE_DEBUG ->
-#ifdef	THREAD
-static int MlmeThread(
-	void *Context)
-{
-	PSDevice	pDevice =  (PSDevice) Context;
-	PSRxMgmtPacket			pRxMgmtPacket;
-
-	while (1) {
-		spin_lock_irq(&pDevice->lock);
-		while (pDevice->rxManeQueue.packet_num != 0) {
-			pRxMgmtPacket = DeQueue(pDevice);
-			vMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);
-		}
-		spin_unlock_irq(&pDevice->lock);
-		if (mlme_kill == 0)
-			break;
-
-		schedule();
-		if (mlme_kill == 0)
-			break;
-	}
-
-	return 0;
-}
-#endif
-
 static int  device_open(struct net_device *dev)
 {
 	PSDevice pDevice = (PSDevice)netdev_priv(dev);
@@ -1703,19 +1664,6 @@ static int  device_open(struct net_device *dev)
 	vMgrObjectInit(pDevice);
 	vMgrTimerInit(pDevice);
 
-//PLICE_DEBUG->
-#ifdef	THREAD
-	InitRxManagementQueue(pDevice);
-	mlme_kill = 0;
-	mlme_task = kthread_run(MlmeThread, (void *)pDevice, "MLME");
-	if (IS_ERR(mlme_task)) {
-		pr_err("thread create fail\n");
-		return -1;
-	}
-
-	mlme_kill = 1;
-#endif
-
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
 	device_init_registers(pDevice, DEVICE_INIT_COLD);
 	MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
@@ -1766,9 +1714,6 @@ static int  device_close(struct net_device *dev)
 	PSDevice  pDevice = (PSDevice)netdev_priv(dev);
 	PSMgmtObject     pMgmt = pDevice->pMgmt;
 	//PLICE_DEBUG->
-#ifdef	THREAD
-	mlme_kill = 0;
-#endif
 //PLICE_DEBUG<-
 //2007-1121-02<Add>by EinsnLiu
 	if (pDevice->bLinkPass) {

commit 795d644c0a91089182a3fede73bd88404819e61b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Jul 28 21:43:27 2014 +0100

    staging: vt6655: remove undefined TASK_LET code
    
    Removing all code within and function MngWorkItem.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1e1d3b451653..c43fc79eb4c6 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1704,9 +1704,6 @@ static int  device_open(struct net_device *dev)
 	vMgrTimerInit(pDevice);
 
 //PLICE_DEBUG->
-#ifdef	TASK_LET
-	tasklet_init(&pDevice->RxMngWorkItem, (void *)MngWorkItem, (unsigned long)pDevice);
-#endif
 #ifdef	THREAD
 	InitRxManagementQueue(pDevice);
 	mlme_kill = 0;
@@ -1789,9 +1786,6 @@ static int  device_close(struct net_device *dev)
 		del_timer(&pDevice->TimerSQ3Tmax3);
 	}
 
-#ifdef	TASK_LET
-	tasklet_kill(&pDevice->RxMngWorkItem);
-#endif
 	netif_stop_queue(dev);
 	pDevice->bCmdRunning = false;
 	MACbShutdown(pDevice->PortOffset);

commit 70ae543b3260a1cb53b30320d650effa575fa174
Author: Guillaume Clement <gclement@baobob.org>
Date:   Fri Jul 25 01:06:28 2014 +0200

    staging: vt6655: Remove NULL pointer sparse warning
    
    We were using 0 instead of NULL to initialize a pointer, which caused
    a sparse warning.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4413e4a286c0..1e1d3b451653 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1626,7 +1626,7 @@ static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc)
 		dev_kfree_skb_irq(skb);
 
 	pTDInfo->skb_dma = 0;
-	pTDInfo->skb = 0;
+	pTDInfo->skb = NULL;
 	pTDInfo->byFlags = 0;
 }
 

commit fa13849f58dcecbb14ce9f40a15b8c9b26df004d
Author: Guillaume Clement <gclement@baobob.org>
Date:   Fri Jul 25 01:06:24 2014 +0200

    staging: vt6655: add missing whitespace
    
    Some whitespace were missing, causing checkpatch warnings and altering
    readability.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index a50d747f326e..4413e4a286c0 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2635,12 +2635,12 @@ static int Config_FileGetParameter(unsigned char *string,
 	return true;
 }
 
-int Config_FileOperation(PSDevice pDevice,bool fwrite,unsigned char *Parameter)
+int Config_FileOperation(PSDevice pDevice, bool fwrite, unsigned char *Parameter)
 {
 	unsigned char *buffer = kmalloc(1024, GFP_KERNEL);
 	unsigned char tmpbuffer[20];
 	struct file *file;
-	int result=0;
+	int result = 0;
 
 	if (!buffer) {
 		pr_err("allocate mem for file fail?\n");
@@ -2665,11 +2665,11 @@ int Config_FileOperation(PSDevice pDevice,bool fwrite,unsigned char *Parameter)
 		goto error1;
 	}
 
-	if (memcmp(tmpbuffer,"USA",3)==0) {
+	if (memcmp(tmpbuffer, "USA", 3) == 0) {
 		result = ZoneType_USA;
-	} else if(memcmp(tmpbuffer,"JAPAN",5)==0) {
+	} else if(memcmp(tmpbuffer, "JAPAN", 5) == 0) {
 		result = ZoneType_Japan;
-	} else if(memcmp(tmpbuffer,"EUROPE",5)==0) {
+	} else if(memcmp(tmpbuffer, "EUROPE", 5) == 0) {
 		result = ZoneType_Europe;
 	} else {
 		result = -1;

commit a1613423cd1da7f5f6fc0e45da5411a0adcac3c5
Author: Guillaume Clement <gclement@baobob.org>
Date:   Fri Jul 25 01:06:22 2014 +0200

    staging: vt6655: break single line if statements
    
    This fixes the "trailing statements should be on next line" checkpatch
    warning.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 12b58efa4c7c..a50d747f326e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -388,7 +388,8 @@ device_set_options(PSDevice pDevice) {
 	pDevice->b11hEnable = (pDevice->sOpts.flags & DEVICE_FLAGS_80211h_MODE) ? 1 : 0;
 	pDevice->bDiversityRegCtlON = (pDevice->sOpts.flags & DEVICE_FLAGS_DiversityANT) ? 1 : 0;
 	pDevice->uConnectionRate = pDevice->sOpts.data_rate;
-	if (pDevice->uConnectionRate < RATE_AUTO) pDevice->bFixRate = true;
+	if (pDevice->uConnectionRate < RATE_AUTO)
+		pDevice->bFixRate = true;
 	pDevice->byBBType = pDevice->sOpts.bbp_type;
 	pDevice->byPacketType = pDevice->byBBType;
 
@@ -2905,7 +2906,8 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 			char abyKey[WLAN_WEP232_KEYLEN];
 
 			rc = iwctl_giwencode(dev, NULL, &(wrq->u.encoding), abyKey);
-			if (rc != 0) break;
+			if (rc != 0)
+				break;
 			if (wrq->u.encoding.pointer) {
 				if (copy_to_user(wrq->u.encoding.pointer,
 						 abyKey,

commit 941ead9adf195395d75eabb0cec15311bf5c5959
Author: Guillaume Clement <gclement@baobob.org>
Date:   Fri Jul 25 01:06:21 2014 +0200

    staging: vt6655: Use pr_* functions instead of printk
    
    Lots of printk are used in vt6655, replace them with the pr_*
    equivalent.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 02c6fa9f1589..12b58efa4c7c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -579,12 +579,12 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 
 			else {
 				if (zonetype != pDevice->abyEEPROM[EEP_OFS_ZONETYPE])
-					printk("zonetype in file[%02x] mismatch with in EEPROM[%02x]\n", zonetype, pDevice->abyEEPROM[EEP_OFS_ZONETYPE]);
+					pr_debug("zonetype in file[%02x] mismatch with in EEPROM[%02x]\n", zonetype, pDevice->abyEEPROM[EEP_OFS_ZONETYPE]);
 				else
-					printk("Read Zonetype file success,use default zonetype setting[%02x]\n", zonetype);
+					pr_debug("Read Zonetype file success,use default zonetype setting[%02x]\n", zonetype);
 			}
 		} else
-			printk("Read Zonetype file fail,use default zonetype setting[%02x]\n", SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ZONETYPE));
+			pr_debug("Read Zonetype file fail,use default zonetype setting[%02x]\n", SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ZONETYPE));
 
 		// Get RFType
 		pDevice->byRFType = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RFTYPE);
@@ -809,8 +809,9 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	PCHIP_INFO  pChip_info = (PCHIP_INFO)ent->driver_data;
 	PSDevice    pDevice;
 	int         rc;
+
 	if (device_nics++ >= MAX_UINTS) {
-		printk(KERN_NOTICE DEVICE_NAME ": already found %d NICs\n", device_nics);
+		pr_notice(DEVICE_NAME ": already found %d NICs\n", device_nics);
 		return -ENODEV;
 	}
 
@@ -819,7 +820,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	pDevice = (PSDevice) netdev_priv(dev);
 
 	if (dev == NULL) {
-		printk(KERN_ERR DEVICE_NAME ": allocate net device failed\n");
+		pr_err(DEVICE_NAME ": allocate net device failed\n");
 		return -ENOMEM;
 	}
 
@@ -827,8 +828,8 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	SET_NETDEV_DEV(dev, &pcid->dev);
 
 	if (bFirst) {
-		printk(KERN_NOTICE "%s Ver. %s\n", DEVICE_FULL_DRV_NAM, DEVICE_VERSION);
-		printk(KERN_NOTICE "Copyright (c) 2003 VIA Networking Technologies, Inc.\n");
+		pr_notice("%s Ver. %s\n", DEVICE_FULL_DRV_NAM, DEVICE_VERSION);
+		pr_notice("Copyright (c) 2003 VIA Networking Technologies, Inc.\n");
 		bFirst = false;
 	}
 
@@ -844,10 +845,10 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	dev->irq = pcid->irq;
 
 #ifdef	DEBUG
-	printk("Before get pci_info memaddr is %x\n", pDevice->memaddr);
+	pr_debug("Before get pci_info memaddr is %x\n", pDevice->memaddr);
 #endif
 	if (!device_get_pci_info(pDevice, pcid)) {
-		printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device.\n");
+		pr_err(DEVICE_NAME ": Failed to find PCI device.\n");
 		device_free_info(pDevice);
 		return -ENODEV;
 	}
@@ -856,7 +857,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 #ifdef	DEBUG
 
-	printk("after get pci_info memaddr is %x, io addr is %x,io_size is %d\n", pDevice->memaddr, pDevice->ioaddr, pDevice->io_size);
+	pr_debug("after get pci_info memaddr is %x, io addr is %x,io_size is %d\n", pDevice->memaddr, pDevice->ioaddr, pDevice->io_size);
 	{
 		int i;
 		u32 bar, len;
@@ -870,9 +871,9 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 			0};
 		for (i = 0; address[i]; i++) {
 			pci_read_config_dword(pcid, address[i], &bar);
-			printk("bar %d is %x\n", i, bar);
+			pr_debug("bar %d is %x\n", i, bar);
 			if (!bar) {
-				printk("bar %d not implemented\n", i);
+				pr_debug("bar %d not implemented\n", i);
 				continue;
 			}
 			if (bar & PCI_BASE_ADDRESS_SPACE_IO) {
@@ -881,12 +882,12 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 				len = bar & (PCI_BASE_ADDRESS_IO_MASK & 0xFFFF);
 				len = len & ~(len - 1);
 
-				printk("IO space:  len in IO %x, BAR %d\n", len, i);
+				pr_debug("IO space:  len in IO %x, BAR %d\n", len, i);
 			} else {
 				len = bar & 0xFFFFFFF0;
 				len = ~len + 1;
 
-				printk("len in MEM %x, BAR %d\n", len, i);
+				pr_debug("len in MEM %x, BAR %d\n", len, i);
 			}
 		}
 	}
@@ -897,14 +898,14 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	pDevice->PortOffset = ioremap(pDevice->memaddr & PCI_BASE_ADDRESS_MEM_MASK, pDevice->io_size);
 
 	if (pDevice->PortOffset == NULL) {
-		printk(KERN_ERR DEVICE_NAME ": Failed to IO remapping ..\n");
+		pr_err(DEVICE_NAME ": Failed to IO remapping ..\n");
 		device_free_info(pDevice);
 		return -ENODEV;
 	}
 
 	rc = pci_request_regions(pcid, DEVICE_NAME);
 	if (rc) {
-		printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device\n");
+		pr_err(DEVICE_NAME ": Failed to find PCI device\n");
 		device_free_info(pDevice);
 		return -ENODEV;
 	}
@@ -914,10 +915,10 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	unsigned char value;
 
 	VNSvInPortB(pDevice->PortOffset+0x4F, &value);
-	printk("Before write: value is %x\n", value);
+	pr_debug("Before write: value is %x\n", value);
 	VNSvOutPortB(pDevice->PortOffset, value);
 	VNSvInPortB(pDevice->PortOffset+0x4F, &value);
-	printk("After write: value is %x\n", value);
+	pr_debug("After write: value is %x\n", value);
 #endif
 
 #ifdef IO_MAP
@@ -925,7 +926,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 #endif
 	// do reset
 	if (!MACbSoftwareReset(pDevice->PortOffset)) {
-		printk(KERN_ERR DEVICE_NAME ": Failed to access MAC hardware..\n");
+		pr_err(DEVICE_NAME ": Failed to access MAC hardware..\n");
 		device_free_info(pDevice);
 		return -ENODEV;
 	}
@@ -951,7 +952,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 	rc = register_netdev(dev);
 	if (rc) {
-		printk(KERN_ERR DEVICE_NAME " Failed to register netdev\n");
+		pr_err(DEVICE_NAME " Failed to register netdev\n");
 		device_free_info(pDevice);
 		return -ENODEV;
 	}
@@ -1038,10 +1039,10 @@ static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid)
 	}
 	for (ii = 0, j = 1; ii < 0x100; ii++, j++) {
 		if (j % 16 == 0) {
-			printk("%x:", pci_config[ii]);
-			printk("\n");
+			pr_debug("%x:", pci_config[ii]);
+			pr_debug("\n");
 		} else {
-			printk("%x:", pci_config[ii]);
+			pr_debug("%x:", pci_config[ii]);
 		}
 	}
 #endif
@@ -1060,7 +1061,7 @@ static void device_free_info(PSDevice pDevice)
 //2008-07-21-01<Add>by MikeLiu
 //unregister wpadev
 	if (wpa_set_wpadev(pDevice, 0) != 0)
-		printk("unregister wpadev fail?\n");
+		pr_err("unregister wpadev fail?\n");
 
 	if (pDevice_Infos == NULL)
 		return;
@@ -1710,7 +1711,7 @@ static int  device_open(struct net_device *dev)
 	mlme_kill = 0;
 	mlme_task = kthread_run(MlmeThread, (void *)pDevice, "MLME");
 	if (IS_ERR(mlme_task)) {
-		printk("thread create fail\n");
+		pr_err("thread create fail\n");
 		return -1;
 	}
 
@@ -2162,7 +2163,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	if (pDevice->bFixRate) {
 #ifdef	PLICE_DEBUG
-		printk("Fix Rate: PhyType is %d,ConnectionRate is %d\n", pDevice->eCurrentPHYType, pDevice->uConnectionRate);
+		pr_debug("Fix Rate: PhyType is %d,ConnectionRate is %d\n", pDevice->eCurrentPHYType, pDevice->uConnectionRate);
 #endif
 
 		if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
@@ -2300,7 +2301,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev)
 	pDevice->apCurrTD[TYPE_AC0DMA] = pHeadTD;
 
 	if (pDevice->bFixRate)
-		printk("FixRate:Rate is %d,TxPower is %d\n", pDevice->wCurrentRate, pDevice->byCurPwr);
+		pr_debug("FixRate:Rate is %d,TxPower is %d\n", pDevice->wCurrentRate, pDevice->byCurPwr);
 
 	{
 		unsigned char Protocol_Version;    //802.1x Authentication
@@ -2322,10 +2323,10 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev)
 					    (Key_info & BIT8) && (Key_info & BIT9)) {    //send 2/2 key
 						pDevice->fWPA_Authened = true;
 						if (Descriptor_type == 254)
-							printk("WPA ");
+							pr_debug("WPA ");
 						else
-							printk("WPA2 ");
-						printk("Authentication completed!!\n");
+							pr_debug("WPA2 ");
+						pr_debug("Authentication completed!!\n");
 					}
 				}
 			}
@@ -2641,24 +2642,24 @@ int Config_FileOperation(PSDevice pDevice,bool fwrite,unsigned char *Parameter)
 	int result=0;
 
 	if (!buffer) {
-		printk("allocate mem for file fail?\n");
+		pr_err("allocate mem for file fail?\n");
 		return -1;
 	}
 	file = filp_open(CONFIG_PATH, O_RDONLY, 0);
 	if (IS_ERR(file)) {
 		kfree(buffer);
-		printk("Config_FileOperation:open file fail?\n");
+		pr_err("Config_FileOperation:open file fail?\n");
 		return -1;
 	}
 
 	if (kernel_read(file, 0, buffer, 1024) < 0) {
-		printk("read file error?\n");
+		pr_err("read file error?\n");
 		result = -1;
 		goto error1;
 	}
 
 	if (Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer)!=true) {
-		printk("get parameter error?\n");
+		pr_err("get parameter error?\n");
 		result = -1;
 		goto error1;
 	}
@@ -2671,7 +2672,7 @@ int Config_FileOperation(PSDevice pDevice,bool fwrite,unsigned char *Parameter)
 		result = ZoneType_Europe;
 	} else {
 		result = -1;
-		printk("Unknown Zonetype[%s]?\n",tmpbuffer);
+		pr_err("Unknown Zonetype[%s]?\n", tmpbuffer);
 	}
 
 error1:

commit 84b50762077e914348cc830d7b72bd2ee1030ced
Author: Guillaume Clement <gclement@baobob.org>
Date:   Fri Jul 25 01:06:18 2014 +0200

    staging: vt6655: fix function braces not on the proper line
    
    Function braces should be on a separate line. Reported by checkpatch.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index d72c42249c7c..02c6fa9f1589 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -743,7 +743,8 @@ MACvStart(pDevice->PortOffset);
 netif_stop_queue(pDevice->dev);
 }
 
-static void device_init_diversity_timer(PSDevice pDevice) {
+static void device_init_diversity_timer(PSDevice pDevice)
+{
 	init_timer(&pDevice->TimerSQ3Tmax1);
 	pDevice->TimerSQ3Tmax1.data = (unsigned long) pDevice;
 	pDevice->TimerSQ3Tmax1.function = (TimerFunction)TimerSQ3CallBack;
@@ -999,7 +1000,8 @@ static void vt6655_init_info(struct pci_dev *pcid, PSDevice *ppDevice,
 	spin_lock_init(&((*ppDevice)->lock));
 }
 
-static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid) {
+static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid)
+{
 	u16 pci_cmd;
 	u8  b;
 	unsigned int cis_addr;
@@ -1046,7 +1048,8 @@ static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid) {
 	return true;
 }
 
-static void device_free_info(PSDevice pDevice) {
+static void device_free_info(PSDevice pDevice)
+{
 	PSDevice         ptr;
 	struct net_device *dev = pDevice->dev;
 
@@ -1090,7 +1093,8 @@ static void device_free_info(PSDevice pDevice) {
 		free_netdev(dev);
 }
 
-static bool device_init_rings(PSDevice pDevice) {
+static bool device_init_rings(PSDevice pDevice)
+{
 	void *vir_pool;
 
 	/*allocate all RD/TD rings a single pool*/
@@ -1181,7 +1185,8 @@ static bool device_init_rings(PSDevice pDevice) {
 	return true;
 }
 
-static void device_free_rings(PSDevice pDevice) {
+static void device_free_rings(PSDevice pDevice)
+{
 	pci_free_consistent(pDevice->pcid,
 			    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
 			    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
@@ -1201,7 +1206,8 @@ static void device_free_rings(PSDevice pDevice) {
 			);
 }
 
-static void device_init_rd0_ring(PSDevice pDevice) {
+static void device_init_rd0_ring(PSDevice pDevice)
+{
 	int i;
 	dma_addr_t      curr = pDevice->rd0_pool_dma;
 	PSRxDesc        pDesc;
@@ -1225,7 +1231,8 @@ static void device_init_rd0_ring(PSDevice pDevice) {
 	pDevice->pCurrRD[0] = &(pDevice->aRD0Ring[0]);
 }
 
-static void device_init_rd1_ring(PSDevice pDevice) {
+static void device_init_rd1_ring(PSDevice pDevice)
+{
 	int i;
 	dma_addr_t      curr = pDevice->rd1_pool_dma;
 	PSRxDesc        pDesc;
@@ -1249,7 +1256,8 @@ static void device_init_rd1_ring(PSDevice pDevice) {
 	pDevice->pCurrRD[1] = &(pDevice->aRD1Ring[0]);
 }
 
-static void device_init_defrag_cb(PSDevice pDevice) {
+static void device_init_defrag_cb(PSDevice pDevice)
+{
 	int i;
 	PSDeFragControlBlock pDeF;
 
@@ -1265,7 +1273,8 @@ static void device_init_defrag_cb(PSDevice pDevice) {
 	pDevice->cbFreeDFCB = pDevice->cbDFCB;
 }
 
-static void device_free_rd0_ring(PSDevice pDevice) {
+static void device_free_rd0_ring(PSDevice pDevice)
+{
 	int i;
 
 	for (i = 0; i < pDevice->sOpts.nRxDescs0; i++) {
@@ -1281,7 +1290,8 @@ static void device_free_rd0_ring(PSDevice pDevice) {
 	}
 }
 
-static void device_free_rd1_ring(PSDevice pDevice) {
+static void device_free_rd1_ring(PSDevice pDevice)
+{
 	int i;
 
 	for (i = 0; i < pDevice->sOpts.nRxDescs1; i++) {
@@ -1297,7 +1307,8 @@ static void device_free_rd1_ring(PSDevice pDevice) {
 	}
 }
 
-static void device_free_frag_buf(PSDevice pDevice) {
+static void device_free_frag_buf(PSDevice pDevice)
+{
 	PSDeFragControlBlock pDeF;
 	int i;
 
@@ -1310,7 +1321,8 @@ static void device_free_frag_buf(PSDevice pDevice) {
 	}
 }
 
-static void device_init_td0_ring(PSDevice pDevice) {
+static void device_init_td0_ring(PSDevice pDevice)
+{
 	int i;
 	dma_addr_t  curr;
 	PSTxDesc        pDesc;
@@ -1334,7 +1346,8 @@ static void device_init_td0_ring(PSDevice pDevice) {
 	pDevice->apTailTD[0] = pDevice->apCurrTD[0] = &(pDevice->apTD0Rings[0]);
 }
 
-static void device_init_td1_ring(PSDevice pDevice) {
+static void device_init_td1_ring(PSDevice pDevice)
+{
 	int i;
 	dma_addr_t  curr;
 	PSTxDesc    pDesc;
@@ -1359,7 +1372,8 @@ static void device_init_td1_ring(PSDevice pDevice) {
 	pDevice->apTailTD[1] = pDevice->apCurrTD[1] = &(pDevice->apTD1Rings[0]);
 }
 
-static void device_free_td0_ring(PSDevice pDevice) {
+static void device_free_td0_ring(PSDevice pDevice)
+{
 	int i;
 
 	for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++) {
@@ -1377,7 +1391,8 @@ static void device_free_td0_ring(PSDevice pDevice) {
 	}
 }
 
-static void device_free_td1_ring(PSDevice pDevice) {
+static void device_free_td1_ring(PSDevice pDevice)
+{
 	int i;
 
 	for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++) {
@@ -1397,7 +1412,8 @@ static void device_free_td1_ring(PSDevice pDevice) {
 
 /*-----------------------------------------------------------------*/
 
-static int device_rx_srv(PSDevice pDevice, unsigned int uIdx) {
+static int device_rx_srv(PSDevice pDevice, unsigned int uIdx)
+{
 	PSRxDesc    pRD;
 	int works = 0;
 
@@ -1422,7 +1438,8 @@ static int device_rx_srv(PSDevice pDevice, unsigned int uIdx) {
 	return works;
 }
 
-static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
+static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD)
+{
 	PDEVICE_RD_INFO pRDInfo = pRD->pRDInfo;
 
 	pRDInfo->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
@@ -1442,7 +1459,8 @@ static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
 	return true;
 }
 
-bool device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
+bool device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF)
+{
 	pDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
 	if (pDeF->skb == NULL)
 		return false;
@@ -1452,7 +1470,8 @@ bool device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
 	return true;
 }
 
-static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
+static int device_tx_srv(PSDevice pDevice, unsigned int uIdx)
+{
 	PSTxDesc                 pTD;
 	bool bFull = false;
 	int                      works = 0;
@@ -1575,7 +1594,8 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 	return works;
 }
 
-static void device_error(PSDevice pDevice, unsigned short status) {
+static void device_error(PSDevice pDevice, unsigned short status)
+{
 	if (status & ISR_FETALERR) {
 		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
 			"%s: Hardware fatal error.\n",
@@ -1589,7 +1609,8 @@ static void device_error(PSDevice pDevice, unsigned short status) {
 	}
 }
 
-static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc) {
+static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc)
+{
 	PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
 	struct sk_buff *skb = pTDInfo->skb;
 
@@ -1642,7 +1663,8 @@ static int MlmeThread(
 }
 #endif
 
-static int  device_open(struct net_device *dev) {
+static int  device_open(struct net_device *dev)
+{
 	PSDevice pDevice = (PSDevice)netdev_priv(dev);
 	int i;
 #ifdef WPA_SM_Transtatus
@@ -1740,7 +1762,8 @@ static int  device_open(struct net_device *dev) {
 	return 0;
 }
 
-static int  device_close(struct net_device *dev) {
+static int  device_close(struct net_device *dev)
+{
 	PSDevice  pDevice = (PSDevice)netdev_priv(dev);
 	PSMgmtObject     pMgmt = pDevice->pMgmt;
 	//PLICE_DEBUG->
@@ -1792,7 +1815,8 @@ static int  device_close(struct net_device *dev) {
 	return 0;
 }
 
-static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
+static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev)
+{
 	PSDevice pDevice = netdev_priv(dev);
 	unsigned char *pbMPDU;
 	unsigned int cbMPDULen = 0;
@@ -1823,7 +1847,8 @@ static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
 	return 0;
 }
 
-bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeIndex) {
+bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeIndex)
+{
 	PSMgmtObject    pMgmt = pDevice->pMgmt;
 	PSTxDesc        pHeadTD, pLastTD;
 	unsigned int cbFrameBodySize;
@@ -1962,7 +1987,8 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 }
 
 //TYPE_AC0DMA data tx
-static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
+static int  device_xmit(struct sk_buff *skb, struct net_device *dev)
+{
 	PSDevice pDevice = netdev_priv(dev);
 
 	PSMgmtObject    pMgmt = pDevice->pMgmt;
@@ -2314,7 +2340,8 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	return 0;
 }
 
-static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
+static  irqreturn_t  device_intr(int irq,  void *dev_instance)
+{
 	struct net_device *dev = dev_instance;
 	PSDevice     pDevice = (PSDevice)netdev_priv(dev);
 
@@ -2653,7 +2680,8 @@ int Config_FileOperation(PSDevice pDevice,bool fwrite,unsigned char *Parameter)
 	return result;
 }
 
-static void device_set_multi(struct net_device *dev) {
+static void device_set_multi(struct net_device *dev)
+{
 	PSDevice         pDevice = (PSDevice)netdev_priv(dev);
 
 	PSMgmtObject     pMgmt = pDevice->pMgmt;
@@ -2698,13 +2726,15 @@ static void device_set_multi(struct net_device *dev) {
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode = %x\n", pDevice->byRxMode);
 }
 
-static struct net_device_stats *device_get_stats(struct net_device *dev) {
+static struct net_device_stats *device_get_stats(struct net_device *dev)
+{
 	PSDevice pDevice = (PSDevice)netdev_priv(dev);
 
 	return &pDevice->stats;
 }
 
-static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
+static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
 	PSDevice	        pDevice = (PSDevice)netdev_priv(dev);
 
 	struct iwreq *wrq = (struct iwreq *)rq;

commit bfd7a2819051fc0ab401609aedbe65df46ed1259
Author: Guillaume Clement <gclement@baobob.org>
Date:   Fri Jul 25 01:06:17 2014 +0200

    staging: vt6655: Remove spaces before quoted newlines
    
    This fixes several spaces added just before a newline in debug
    strings, reported by checkpatch.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 56fdb4652175..d72c42249c7c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -818,7 +818,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	pDevice = (PSDevice) netdev_priv(dev);
 
 	if (dev == NULL) {
-		printk(KERN_ERR DEVICE_NAME ": allocate net device failed \n");
+		printk(KERN_ERR DEVICE_NAME ": allocate net device failed\n");
 		return -ENOMEM;
 	}
 
@@ -967,11 +967,11 @@ static void device_print_info(PSDevice pDevice)
 	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: MAC=%pM", dev->name, dev->dev_addr);
 #ifdef IO_MAP
 	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IO=0x%lx  ", (unsigned long)pDevice->ioaddr);
-	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IRQ=%d \n", pDevice->dev->irq);
+	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IRQ=%d\n", pDevice->dev->irq);
 #else
 	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IO=0x%lx Mem=0x%lx ",
 		(unsigned long)pDevice->ioaddr, (unsigned long)pDevice->PortOffset);
-	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IRQ=%d \n", pDevice->dev->irq);
+	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IRQ=%d\n", pDevice->dev->irq);
 #endif
 }
 
@@ -1514,7 +1514,7 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 
 			if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
 				if (pDevice->bEnableHostapd) {
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx call back netif.. \n");
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx call back netif..\n");
 					skb = pTD->pTDInfo->skb;
 					skb->dev = pDevice->apdev;
 					skb_reset_mac_header(skb);
@@ -1736,7 +1736,7 @@ static int  device_open(struct net_device *dev) {
 	}
 	pDevice->flags |= DEVICE_FLAGS_OPENED;
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success.. \n");
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success..\n");
 	return 0;
 }
 
@@ -1788,7 +1788,7 @@ static int  device_close(struct net_device *dev) {
 	//2008-0714-01<Add>by chester
 	device_release_WPADEV(pDevice);
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close.. \n");
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close..\n");
 	return 0;
 }
 
@@ -1895,7 +1895,7 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 	else
 		pDevice->byPreambleType = PREAMBLE_LONG;
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dma0: pDevice->wCurrentRate = %d\n", pDevice->wCurrentRate);
 
 	if (pDevice->wCurrentRate <= RATE_11M) {
 		byPktType = PK_TYPE_11B;
@@ -2038,7 +2038,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 		}
 
 		if (!bNodeExist) {
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "Unknown STA not found in node DB \n");
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "Unknown STA not found in node DB\n");
 			dev_kfree_skb_irq(skb);
 			spin_unlock_irq(&pDevice->lock);
 			return 0;
@@ -2076,9 +2076,9 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 				}
 			} else if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
 				pbyBSSID = pDevice->sTxEthHeader.abyDstAddr;  //TO_DS = 0 and FROM_DS = 0 --> 802.11 MAC Address1
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "IBSS Serach Key: \n");
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "IBSS Serach Key:\n");
 				for (ii = 0; ii < 6; ii++)
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "%x \n", *(pbyBSSID+ii));
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "%x\n", *(pbyBSSID+ii));
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "\n");
 
 				// get pairwise key
@@ -2358,7 +2358,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 		MACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);
 
 		if (pDevice->dwIsr & ISR_FETALERR) {
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " ISR_FETALERR \n");
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " ISR_FETALERR\n");
 			VNSvOutPortB(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, 0);
 			VNSvOutPortW(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, SOFTPWRCTL_SWPECTI);
 			device_error(pDevice, pDevice->dwIsr);
@@ -2784,13 +2784,13 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 		// Set desired station name
 	case SIOCSIWNICKN:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN\n");
 		rc = -EOPNOTSUPP;
 		break;
 
 		// Get current station name
 	case SIOCGIWNICKN:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWNICKN \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWNICKN\n");
 		rc = -EOPNOTSUPP;
 		break;
 
@@ -2886,12 +2886,12 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 		// Get the current Tx-Power
 	case SIOCGIWTXPOW:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW\n");
 		rc = -EOPNOTSUPP;
 		break;
 
 	case SIOCSIWTXPOW:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWTXPOW \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWTXPOW\n");
 		rc = -EOPNOTSUPP;
 		break;
 
@@ -2934,7 +2934,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		break;
 
 	case SIOCSIWSENS:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSENS \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSENS\n");
 		rc = -EOPNOTSUPP;
 		break;
 
@@ -2958,49 +2958,50 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	// Set the spy list
 	case SIOCSIWSPY:
 
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY\n");
 		rc = -EOPNOTSUPP;
 		break;
 
 		// Get the spy list
 	case SIOCGIWSPY:
 
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWSPY \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWSPY\n");
 		rc = -EOPNOTSUPP;
 		break;
 
 #endif // WIRELESS_SPY
 
 	case SIOCGIWPRIV:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV\n");
 		rc = -EOPNOTSUPP;
 		break;
 
 //2008-0409-07, <Add> by Einsn Liu
 #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 	case SIOCSIWAUTH:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAUTH \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAUTH\n");
 		rc = iwctl_siwauth(dev, NULL, &(wrq->u.param), NULL);
 		break;
 
 	case SIOCGIWAUTH:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWAUTH \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWAUTH\n");
 		rc = iwctl_giwauth(dev, NULL, &(wrq->u.param), NULL);
 		break;
 
 	case SIOCSIWGENIE:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWGENIE \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWGENIE\n");
 		rc = iwctl_siwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
 		break;
 
 	case SIOCGIWGENIE:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWGENIE \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWGENIE\n");
 		rc = iwctl_giwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
 		break;
 
 	case SIOCSIWENCODEEXT: {
 		char extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT \n");
+
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT\n");
 		if (wrq->u.encoding.pointer) {
 			memset(extra, 0, sizeof(struct iw_encode_ext)+MAX_KEY_LEN + 1);
 			if (wrq->u.encoding.length > (sizeof(struct iw_encode_ext) + MAX_KEY_LEN)) {
@@ -3020,12 +3021,12 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	break;
 
 	case SIOCGIWENCODEEXT:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWENCODEEXT \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWENCODEEXT\n");
 		rc = iwctl_giwencodeext(dev, NULL, &(wrq->u.encoding), NULL);
 		break;
 
 	case SIOCSIWMLME:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWMLME \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWMLME\n");
 		rc = iwctl_siwmlme(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
 		break;
 

commit 6b7112719fd48c29f35333ef152a5a450f01dc83
Author: Guillaume Clement <gclement@baobob.org>
Date:   Fri Jul 25 01:06:16 2014 +0200

    staging: vt6655: Add missing blank lines after declarations
    
    This patch fixes the missing blank lines after declarations in vt6655
    reported by checkpatch.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0f120e6841d6..56fdb4652175 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -326,6 +326,7 @@ static int Config_FileGetParameter(unsigned char *string,
 static char *get_chip_name(int chip_id)
 {
 	int i;
+
 	for (i = 0; chip_info_table[i].name != NULL; i++)
 		if (chip_info_table[i].chip_id == chip_id)
 			break;
@@ -464,6 +465,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 	unsigned char byOFDMPwrdBm = 0;
 	int zonetype = 0;
 	PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
+
 	MACbShutdown(pDevice->PortOffset);
 	BBvSoftwareReset(pDevice->PortOffset);
 
@@ -1006,6 +1008,7 @@ static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid) {
 	unsigned char value = 0x00;
 	int		ii, j;
 	u16	max_lat = 0x0000;
+
 	memset(pci_config, 0x00, 256);
 #endif
 
@@ -1358,6 +1361,7 @@ static void device_init_td1_ring(PSDevice pDevice) {
 
 static void device_free_td0_ring(PSDevice pDevice) {
 	int i;
+
 	for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++) {
 		PSTxDesc        pDesc = &(pDevice->apTD0Rings[i]);
 		PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
@@ -2278,6 +2282,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 		unsigned char Descriptor_type;
 		unsigned short Key_info;
 		bool bTxeapol_key = false;
+
 		Protocol_Version = skb->data[ETH_HLEN];
 		Packet_Type = skb->data[ETH_HLEN+1];
 		Descriptor_type = skb->data[ETH_HLEN+1+1+2];
@@ -2576,6 +2581,7 @@ static inline u32 ether_crc(int length, unsigned char *data)
 	while (--length >= 0) {
 		unsigned char current_octet = *data++;
 		int bit;
+
 		for (bit = 0; bit < 8; bit++, current_octet >>= 1) {
 			crc = (crc << 1) ^
 				((crc < 0) ^ (current_octet & 1) ? ethernet_polynomial : 0);
@@ -2671,6 +2677,7 @@ static void device_set_multi(struct net_device *dev) {
 		memset(mc_filter, 0, sizeof(mc_filter));
 		netdev_for_each_mc_addr(ha, dev) {
 			int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
+
 			mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
 		}
 		MACvSelectPage1(pDevice->PortOffset);
@@ -2734,6 +2741,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 	{
 		char essid[IW_ESSID_MAX_SIZE+1];
+
 		if (wrq->u.essid.length > IW_ESSID_MAX_SIZE) {
 			rc = -E2BIG;
 			break;
@@ -2753,6 +2761,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 	{
 		char essid[IW_ESSID_MAX_SIZE+1];
+
 		if (wrq->u.essid.pointer)
 			rc = iwctl_giwessid(dev, NULL,
 					    &(wrq->u.essid), essid);
@@ -3115,6 +3124,7 @@ static int ethtool_ioctl(struct net_device *dev, void __user *useraddr)
 	switch (ethcmd) {
 	case ETHTOOL_GDRVINFO: {
 		struct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};
+
 		strncpy(info.driver, DEVICE_NAME, sizeof(info.driver)-1);
 		strncpy(info.version, DEVICE_VERSION, sizeof(info.version)-1);
 		if (copy_to_user(useraddr, &info, sizeof(info)))
@@ -3171,6 +3181,7 @@ static int
 device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
 {
 	struct pci_dev *pdev = NULL;
+
 	switch (event) {
 	case SYS_DOWN:
 	case SYS_HALT:

commit fe802546ce748b5af933157e181f1d653ac5ec9c
Author: Guillaume Clement <gclement@baobob.org>
Date:   Fri Jul 25 01:06:15 2014 +0200

    staging: vt6655: remove useless return statements
    
    Many return statements in void function were present at the end of
    functions, with no effect. They now are removed.
    
    This fixes a bunch of checkpatch warnings.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 5eeb19edc633..0f120e6841d6 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -756,8 +756,6 @@ static void device_init_diversity_timer(PSDevice pDevice) {
 	pDevice->TimerSQ3Tmax3.data = (unsigned long) pDevice;
 	pDevice->TimerSQ3Tmax3.function = (TimerFunction)TimerState1CallBack;
 	pDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);
-
-	return;
 }
 
 static bool device_release_WPADEV(PSDevice pDevice)

commit 6cff1f6ad4c615319c1a146b2aa0af1043c5e9f5
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jul 23 21:35:11 2014 +0100

    staging: vt6655: Fix Warning on boot handle_irq_event_percpu.
    
    WARNING: CPU: 0 PID: 929 at /home/apw/COD/linux/kernel/irq/handle.c:147 handle_irq_event_percpu+0x1d1/0x1e0()
    irq 17 handler device_intr+0x0/0xa80 [vt6655_stage] enabled interrupts
    
    Using spin_lock_irqsave appears to fix this.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1d3908d044d0..5a5fd937a442 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2318,6 +2318,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 	int             handled = 0;
 	unsigned char byData = 0;
 	int             ii = 0;
+	unsigned long flags;
 
 	MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
 
@@ -2331,7 +2332,8 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 
 	handled = 1;
 	MACvIntDisable(pDevice->PortOffset);
-	spin_lock_irq(&pDevice->lock);
+
+	spin_lock_irqsave(&pDevice->lock, flags);
 
 	//Make sure current page is 0
 	VNSvInPortB(pDevice->PortOffset + MAC_REG_PAGE1SEL, &byOrgPageSel);
@@ -2560,7 +2562,8 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 	if (byOrgPageSel == 1)
 		MACvSelectPage1(pDevice->PortOffset);
 
-	spin_unlock_irq(&pDevice->lock);
+	spin_unlock_irqrestore(&pDevice->lock, flags);
+
 	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
 
 	return IRQ_RETVAL(handled);

commit 8e3bec324e59aeedbef749ba2a3a2c00db1c75cf
Author: Guillaume Clement <gclement@baobob.org>
Date:   Tue Jul 22 22:08:30 2014 +0200

    staging: vt6655: Fix unused function warning
    
    Sparse reports that MimeThread is not used. Actually, it can be used
    if THREAD is defined. By enclosing the MimeThread function into the
    same #ifdef as the caller of MimeThread, this fixes the sparse
    warnings.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 52f10cacb425..5eeb19edc633 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -98,7 +98,9 @@ MODULE_AUTHOR("VIA Networking Technologies, Inc., <lyndonchen@vntek.com.tw>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("VIA Networking Solomon-A/B/G Wireless LAN Adapter Driver");
 
+#ifdef	THREAD
 static int mlme_kill;
+#endif
 
 #define DEVICE_PARAM(N, D)
 
@@ -1612,7 +1614,8 @@ void	InitRxManagementQueue(PSDevice  pDevice)
 //PLICE_DEBUG<-
 
 //PLICE_DEBUG ->
-int MlmeThread(
+#ifdef	THREAD
+static int MlmeThread(
 	void *Context)
 {
 	PSDevice	pDevice =  (PSDevice) Context;
@@ -1635,6 +1638,7 @@ int MlmeThread(
 
 	return 0;
 }
+#endif
 
 static int  device_open(struct net_device *dev) {
 	PSDevice pDevice = (PSDevice)netdev_priv(dev);

commit 9e4c5c2837a4bf059590ad75fa3fe0c2af93e65a
Author: Guillaume Clement <gclement@baobob.org>
Date:   Tue Jul 22 22:08:28 2014 +0200

    staging: vt6655: statify some variables
    
    Some variables are used only in the context of their .c file, which
    gives warnings with sparse.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 29ac1e96669f..52f10cacb425 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -260,7 +260,7 @@ static CHIP_INFO chip_info_table[] = {
 	{0, NULL}
 };
 
-const struct pci_device_id vt6655_pci_id_table[] = {
+static const struct pci_device_id vt6655_pci_id_table[] = {
 	{ PCI_VDEVICE(VIA, 0x3253), (kernel_ulong_t)chip_info_table},
 	{ 0, }
 };
@@ -285,7 +285,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static int device_notify_reboot(struct notifier_block *, unsigned long event, void *ptr);
 static int viawget_suspend(struct pci_dev *pcid, pm_message_t state);
 static int viawget_resume(struct pci_dev *pcid);
-struct notifier_block device_notifier = {
+static struct notifier_block device_notifier = {
 	.notifier_call = device_notify_reboot,
 	.next = NULL,
 	.priority = 0,

commit 1683440595ea33cc019fb8524b04319cf82bc6ac
Author: Guillaume Clement <gclement@baobob.org>
Date:   Tue Jul 22 22:08:26 2014 +0200

    staging: vt6655: change type of PortOffset to void __iomem *
    
    PortOffset was an unsigned long, but used as an pointer to io
    memory. Sometimes it was not properly cast before use, which caused
    many warning by sparse.
    
    By updating its type to void __iomem *, and reflecting the changes
    where it is needed, this removes most of those warnings.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 23273863696b..29ac1e96669f 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -891,9 +891,9 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 #endif
 
-	pDevice->PortOffset = (unsigned long)ioremap(pDevice->memaddr & PCI_BASE_ADDRESS_MEM_MASK, pDevice->io_size);
+	pDevice->PortOffset = ioremap(pDevice->memaddr & PCI_BASE_ADDRESS_MEM_MASK, pDevice->io_size);
 
-	if (pDevice->PortOffset == 0) {
+	if (pDevice->PortOffset == NULL) {
 		printk(KERN_ERR DEVICE_NAME ": Failed to IO remapping ..\n");
 		device_free_info(pDevice);
 		return -ENODEV;
@@ -1079,7 +1079,7 @@ static void device_free_info(PSDevice pDevice) {
 		unregister_netdev(dev);
 
 	if (pDevice->PortOffset)
-		iounmap((void *)pDevice->PortOffset);
+		iounmap(pDevice->PortOffset);
 
 	if (pDevice->pcid)
 		pci_release_regions(pDevice->pcid);

commit ebc43d093b38262f1fc51018a50892ce3a144852
Author: James A Shackleford <shack@linux.com>
Date:   Sat May 31 20:09:05 2014 -0400

    staging: vt6655: fix sparse warning "cast removes address space of expression"
    
    Add missing __user macro to second parameter of ethtool_ioctl().
    This removes the need for the offending (void *) cast of the user space pointer
    rq->ifr_data.
    
    Signed-off-by: James A Shackleford <shack@linux.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1d3908d044d0..23273863696b 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -302,7 +302,7 @@ static int  device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev);
 //2008-0714<Add>by Mike Liu
 static bool device_release_WPADEV(PSDevice pDevice);
 
-static int  ethtool_ioctl(struct net_device *dev, void *useraddr);
+static int  ethtool_ioctl(struct net_device *dev, void __user *useraddr);
 static int  device_rx_srv(PSDevice pDevice, unsigned int uIdx);
 static int  device_tx_srv(PSDevice pDevice, unsigned int uIdx);
 static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pDesc);
@@ -3067,7 +3067,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		break;
 
 	case SIOCETHTOOL:
-		return ethtool_ioctl(dev, (void *)rq->ifr_data);
+		return ethtool_ioctl(dev, rq->ifr_data);
 		// All other calls are currently unsupported
 
 	default:
@@ -3103,7 +3103,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	return rc;
 }
 
-static int ethtool_ioctl(struct net_device *dev, void *useraddr)
+static int ethtool_ioctl(struct net_device *dev, void __user *useraddr)
 {
 	u32 ethcmd;
 

commit bc5cf6563576bb36baa7e93417b9a2e29999a5c6
Author: Guido Martnez <guido@vanguardiasur.com.ar>
Date:   Sat Apr 19 16:45:00 2014 -0300

    staging: vt6655: fix checkpatch bracing issues
    
    This patchs fixes tons of warnings such as:
    
      WARNING: braces {} are not necessary for single statement blocks
      #354: FILE: drivers/staging/vt6655/wmgr.c:354:
      +       for (ii = 0; ii < WLAN_BSSID_LEN; ii++) {
      +               pMgmt->abyDesireBSSID[ii] = 0xFF;
      +       }
    
    Please note: this patch only fixes bracing issues (and there is still a
    lot to do); so if you run checkpatch it _will_ throw a lot of errors.
    Use --test-only=braces
    
    Signed-off-by: Guido Martnez <guido@vanguardiasur.com.ar>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 024d84082d76..1d3908d044d0 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -593,9 +593,9 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 		pDevice->byRFType &= RF_MASK;
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRFType = %x\n", pDevice->byRFType);
 
-		if (!pDevice->bZoneRegExist) {
+		if (!pDevice->bZoneRegExist)
 			pDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
-		}
+
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byZoneType = %x\n", pDevice->byZoneType);
 
 		//Init RF module
@@ -610,13 +610,13 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 
 		for (ii = 0; ii < CB_MAX_CHANNEL_24G; ii++) {
 			pDevice->abyCCKPwrTbl[ii + 1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_CCK_PWR_TBL));
-			if (pDevice->abyCCKPwrTbl[ii + 1] == 0) {
+			if (pDevice->abyCCKPwrTbl[ii + 1] == 0)
 				pDevice->abyCCKPwrTbl[ii+1] = pDevice->byCCKPwr;
-			}
+
 			pDevice->abyOFDMPwrTbl[ii + 1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDM_PWR_TBL));
-			if (pDevice->abyOFDMPwrTbl[ii + 1] == 0) {
+			if (pDevice->abyOFDMPwrTbl[ii + 1] == 0)
 				pDevice->abyOFDMPwrTbl[ii + 1] = pDevice->byOFDMPwrG;
-			}
+
 			pDevice->abyCCKDefaultPwr[ii + 1] = byCCKPwrdBm;
 			pDevice->abyOFDMDefaultPwr[ii + 1] = byOFDMPwrdBm;
 		}
@@ -672,11 +672,10 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 
 		// Set BB and packet type at the same time.
 		// Set Short Slot Time, xIFS, and RSPINF.
-		if (pDevice->uConnectionRate == RATE_AUTO) {
+		if (pDevice->uConnectionRate == RATE_AUTO)
 			pDevice->wCurrentRate = RATE_54M;
-		} else {
+		else
 			pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
-		}
 
 		// default G Mode
 		VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_11G);
@@ -692,22 +691,25 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 			MACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);
 //2008-4-14 <add> by chester for led issue
 #ifdef FOR_LED_ON_NOTEBOOK
-			if (pDevice->byGPIO & GPIO0_DATA) { pDevice->bHWRadioOff = true; }
-			if (!(pDevice->byGPIO & GPIO0_DATA)) { pDevice->bHWRadioOff = false; }
+			if (pDevice->byGPIO & GPIO0_DATA)
+				pDevice->bHWRadioOff = true;
 
+			if (!(pDevice->byGPIO & GPIO0_DATA))
+				pDevice->bHWRadioOff = false;
 		}
-		if (pDevice->bRadioControlOff) {
+
+		if (pDevice->bRadioControlOff)
 			CARDbRadioPowerOff(pDevice);
-		} else  CARDbRadioPowerOn(pDevice);
+		else
+			CARDbRadioPowerOn(pDevice);
 #else
 		if (((pDevice->byGPIO & GPIO0_DATA) && !(pDevice->byRadioCtl & EEP_RADIOCTL_INV)) ||
 		    (!(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV))) {
 			pDevice->bHWRadioOff = true;
 		}
 	}
-	if (pDevice->bHWRadioOff || pDevice->bRadioControlOff) {
+	if (pDevice->bHWRadioOff || pDevice->bRadioControlOff)
 		CARDbRadioPowerOff(pDevice);
-	}
 
 #endif
 }
@@ -722,9 +724,8 @@ CARDvSafeResetRx(pDevice);
 // reset Rx pointer
 CARDvSafeResetTx(pDevice);
 
-if (pDevice->byLocalID <= REV_ID_VT3253_A1) {
+if (pDevice->byLocalID <= REV_ID_VT3253_A1)
 	MACvRegBitsOn(pDevice->PortOffset, MAC_REG_RCR, RCR_WPAERR);
-}
 
 pDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;
 
@@ -1494,9 +1495,9 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X].\n",
 							(int)uIdx, byTsr1, byTsr0);
 					}
-					if ((pTxBufHead->wFragCtl & FRAGCTL_ENDFRAG) != FRAGCTL_NONFRAG) {
+					if ((pTxBufHead->wFragCtl & FRAGCTL_ENDFRAG) != FRAGCTL_NONFRAG)
 						pDevice->s802_11Counter.TransmittedFragmentCount++;
-					}
+
 					pStats->tx_packets++;
 					pStats->tx_bytes += pTD->pTDInfo->skb->len;
 				} else {
@@ -1560,9 +1561,9 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 			bFull = true;
 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " AC0DMA is Full = %d\n", pDevice->iTDUsed[uIdx]);
 		}
-		if (netif_queue_stopped(pDevice->dev) && !bFull) {
+		if (netif_queue_stopped(pDevice->dev) && !bFull)
 			netif_wake_queue(pDevice->dev);
-		}
+
 	}
 
 	pDevice->apTailTD[uIdx] = pTD;
@@ -1643,9 +1644,9 @@ static int  device_open(struct net_device *dev) {
 #endif
 
 	pDevice->rx_buf_sz = PKT_BUF_SZ;
-	if (!device_init_rings(pDevice)) {
+	if (!device_init_rings(pDevice))
 		return -ENOMEM;
-	}
+
 //2008-5-13 <add> by chester
 	i = request_irq(pDevice->pcid->irq, &device_intr, IRQF_SHARED, dev->name, dev);
 	if (i)
@@ -1666,9 +1667,9 @@ static int  device_open(struct net_device *dev) {
 	device_init_td0_ring(pDevice);
 	device_init_td1_ring(pDevice);
 
-	if (pDevice->bDiversityRegCtlON) {
+	if (pDevice->bDiversityRegCtlON)
 		device_init_diversity_timer(pDevice);
-	}
+
 	vMgrObjectInit(pDevice);
 	vMgrTimerInit(pDevice);
 
@@ -1855,9 +1856,9 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 	cbFrameBodySize = skb->len - ETH_HLEN;
 
 	// 802.1H
-	if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN) {
+	if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN)
 		cbFrameBodySize += 8;
-	}
+
 	uMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);
 
 	if (uMACfragNum > AVAIL_TD(pDevice, TYPE_TXDMA0)) {
@@ -1868,11 +1869,10 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 
 	if (pDevice->bFixRate) {
 		if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
-			if (pDevice->uConnectionRate >= RATE_11M) {
+			if (pDevice->uConnectionRate >= RATE_11M)
 				pDevice->wCurrentRate = RATE_11M;
-			} else {
+			else
 				pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
-			}
 		} else {
 			if (pDevice->uConnectionRate >= RATE_54M)
 				pDevice->wCurrentRate = RATE_54M;
@@ -1884,11 +1884,10 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 	}
 
 	//preamble type
-	if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {
+	if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble)
 		pDevice->byPreambleType = pDevice->byShortPreamble;
-	} else {
+	else
 		pDevice->byPreambleType = PREAMBLE_LONG;
-	}
 
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
 
@@ -1897,11 +1896,10 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 	} else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
 		byPktType = PK_TYPE_11A;
 	} else {
-		if (pDevice->bProtectMode) {
+		if (pDevice->bProtectMode)
 			byPktType = PK_TYPE_11GB;
-		} else {
+		else
 			byPktType = PK_TYPE_11GA;
-		}
 	}
 
 	if (pDevice->bEncryptionEnable)
@@ -2023,12 +2021,11 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 					return 0;
 				}
 
-				if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {
+				if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble)
 					pDevice->byPreambleType = pDevice->byShortPreamble;
-
-				} else {
+				else
 					pDevice->byPreambleType = PREAMBLE_LONG;
-				}
+
 				bNodeExist = true;
 
 			}
@@ -2049,9 +2046,8 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	memcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)(skb->data), ETH_HLEN);
 	cbFrameBodySize = skb->len - ETH_HLEN;
 	// 802.1H
-	if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN) {
+	if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN)
 		cbFrameBodySize += 8;
-	}
 
 	if (pDevice->bEncryptionEnable) {
 		bNeedEncryption = true;
@@ -2087,9 +2083,9 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 			pbyBSSID = pDevice->abyBroadcastAddr;
 			if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == false) {
 				pTransmitKey = NULL;
-				if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
+				if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)
 					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
-				} else
+				else
 					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "NOT IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
 			} else {
 				bTKIP_UseGTK = true;
@@ -2138,11 +2134,10 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 #endif
 
 		if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
-			if (pDevice->uConnectionRate >= RATE_11M) {
+			if (pDevice->uConnectionRate >= RATE_11M)
 				pDevice->wCurrentRate = RATE_11M;
-			} else {
+			else
 				pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
-			}
 		} else {
 			if ((pDevice->eCurrentPHYType == PHY_TYPE_11A) &&
 			    (pDevice->uConnectionRate <= RATE_6M)) {
@@ -2189,11 +2184,10 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	} else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
 		byPktType = PK_TYPE_11A;
 	} else {
-		if (pDevice->bProtectMode) {
+		if (pDevice->bProtectMode)
 			byPktType = PK_TYPE_11GB;
-		} else {
+		else
 			byPktType = PK_TYPE_11GA;
-		}
 	}
 
 	if (bNeedEncryption) {
@@ -2268,15 +2262,13 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 #ifdef TxInSleep
 	pDevice->nTxDataTimeCout = 0; //2008-8-21 chester <add> for send null packet
 #endif
-	if (AVAIL_TD(pDevice, TYPE_AC0DMA) <= 1) {
+	if (AVAIL_TD(pDevice, TYPE_AC0DMA) <= 1)
 		netif_stop_queue(dev);
-	}
 
 	pDevice->apCurrTD[TYPE_AC0DMA] = pHeadTD;
 
-	if (pDevice->bFixRate) {
+	if (pDevice->bFixRate)
 		printk("FixRate:Rate is %d,TxPower is %d\n", pDevice->wCurrentRate, pDevice->byCurPwr);
-	}
 
 	{
 		unsigned char Protocol_Version;    //802.1x Authentication
@@ -2343,9 +2335,9 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 
 	//Make sure current page is 0
 	VNSvInPortB(pDevice->PortOffset + MAC_REG_PAGE1SEL, &byOrgPageSel);
-	if (byOrgPageSel == 1) {
+	if (byOrgPageSel == 1)
 		MACvSelectPage0(pDevice->PortOffset);
-	} else
+	else
 		byOrgPageSel = 0;
 
 	MACvReadMIBCounter(pDevice->PortOffset, &dwMIBCounter);
@@ -2383,9 +2375,9 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 					MACvSelectPage0(pDevice->PortOffset);
 					pDevice->byBasicMap = 0;
 					pDevice->byCCAFraction = 0;
-					for (ii = 0; ii < 8; ii++) {
+					for (ii = 0; ii < 8; ii++)
 						pDevice->dwRPIs[ii] = 0;
-					}
+
 				} else {
 					// can not measure because set channel fail
 					// clear measure control
@@ -2484,9 +2476,8 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 			}
 
 			pDevice->bBeaconSent = false;
-			if (pDevice->bEnablePSMode) {
+			if (pDevice->bEnablePSMode)
 				PSbIsNextTBTTWakeUp((void *)pDevice);
-			}
 
 			if ((pDevice->eOPMode == OP_MODE_AP) ||
 			    (pDevice->eOPMode == OP_MODE_ADHOC)) {
@@ -2534,18 +2525,18 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 
 		}
 
-		if (pDevice->dwIsr & ISR_RXDMA0) {
+		if (pDevice->dwIsr & ISR_RXDMA0)
 			max_count += device_rx_srv(pDevice, TYPE_RXDMA0);
-		}
-		if (pDevice->dwIsr & ISR_RXDMA1) {
+
+		if (pDevice->dwIsr & ISR_RXDMA1)
 			max_count += device_rx_srv(pDevice, TYPE_RXDMA1);
-		}
-		if (pDevice->dwIsr & ISR_TXDMA0) {
+
+		if (pDevice->dwIsr & ISR_TXDMA0)
 			max_count += device_tx_srv(pDevice, TYPE_TXDMA0);
-		}
-		if (pDevice->dwIsr & ISR_AC0DMA) {
+
+		if (pDevice->dwIsr & ISR_AC0DMA)
 			max_count += device_tx_srv(pDevice, TYPE_AC0DMA);
-		}
+
 		if (pDevice->dwIsr & ISR_SOFTTIMER1) {
 			if (pDevice->eOPMode == OP_MODE_AP) {
 				if (pDevice->bShortSlotTime)
@@ -2566,9 +2557,8 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 			break;
 	}
 
-	if (byOrgPageSel == 1) {
+	if (byOrgPageSel == 1)
 		MACvSelectPage1(pDevice->PortOffset);
-	}
 
 	spin_unlock_irq(&pDevice->lock);
 	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
@@ -3059,9 +3049,9 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 				rc = 0;
 			}
 
-		if (test_and_set_bit(0, (void *)&(pMgmt->uCmdBusy))) {
+		if (test_and_set_bit(0, (void *)&(pMgmt->uCmdBusy)))
 			return -EBUSY;
-		}
+
 		rc = private_ioctl(pDevice, rq);
 		clear_bit(0, (void *)&(pMgmt->uCmdBusy));
 		break;

commit 4e8a7e5fc29697f881f5c358f84df52914908703
Author: Guido Martnez <guido@vanguardiasur.com.ar>
Date:   Sat Apr 19 16:44:59 2014 -0300

    staging: vt6655: remove dead code
    
    Remove dead code in many places on this driver.
    
    Signed-off-by: Guido Martnez <guido@vanguardiasur.com.ar>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index a952df1bf9d6..024d84082d76 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -89,7 +89,6 @@
 #include <linux/slab.h>
 
 /*---------------------  Static Definitions -------------------------*/
-//static int          msglevel                =MSG_LEVEL_DEBUG;
 static int          msglevel                =   MSG_LEVEL_INFO;
 
 //
@@ -100,14 +99,8 @@ MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("VIA Networking Solomon-A/B/G Wireless LAN Adapter Driver");
 
 static int mlme_kill;
-//static  struct task_struct * mlme_task;
 
 #define DEVICE_PARAM(N, D)
-/*
-  static const int N[MAX_UINTS]=OPTION_DEFAULT;\
-  MODULE_PARM(N, "1-" __MODULE_STRING(MAX_UINTS) "i");\
-  MODULE_PARM_DESC(N, D);
-*/
 
 #define RX_DESC_MIN0     16
 #define RX_DESC_MAX0     128
@@ -346,38 +339,6 @@ static void vt6655_remove(struct pci_dev *pcid)
 	device_free_info(pDevice);
 }
 
-/*
-  static void
-  device_set_int_opt(int *opt, int val, int min, int max, int def,char* name,char* devname) {
-  if (val==-1)
-  *opt=def;
-  else if (val<min || val>max) {
-  DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: the value of parameter %s is invalid, the valid range is (%d-%d)\n" ,
-  devname,name, min,max);
-  *opt=def;
-  } else {
-  DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: set value of parameter %s to %d\n",
-  devname, name, val);
-  *opt=val;
-  }
-  }
-
-  static void
-  device_set_bool_opt(unsigned int *opt, int val,bool def,u32 flag, char* name,char* devname) {
-  (*opt)&=(~flag);
-  if (val==-1)
-  *opt|=(def ? flag : 0);
-  else if (val<0 || val>1) {
-  DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE
-  "%s: the value of parameter %s is invalid, the valid range is (0-1)\n",devname,name);
-  *opt|=(def ? flag : 0);
-  } else {
-  DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: set parameter %s to %s\n",
-  devname,name , val ? "true" : "false");
-  *opt|=(val ? flag : 0);
-  }
-  }
-*/
 static void device_get_options(PSDevice pDevice, int index, char *devname)
 {
 	POPTIONS pOpts = &(pDevice->sOpts);
@@ -395,7 +356,6 @@ static void device_get_options(PSDevice pDevice, int index, char *devname)
 
 	pOpts->flags |= DEVICE_FLAGS_PREAMBLE_TYPE;
 	pOpts->flags |= DEVICE_FLAGS_OP_MODE;
-	//pOpts->flags|=DEVICE_FLAGS_PS_MODE;
 	pOpts->short_retry = SHORT_RETRY_DEF;
 	pOpts->long_retry = LONG_RETRY_DEF;
 	pOpts->bbp_type = BBP_TYPE_DEF;
@@ -431,7 +391,6 @@ device_set_options(PSDevice pDevice) {
 
 //PLICE_DEBUG->
 	pDevice->byAutoFBCtrl = AUTO_FB_0;
-	//pDevice->byAutoFBCtrl = AUTO_FB_1;
 //PLICE_DEBUG<-
 	pDevice->bUpdateBBVGA = true;
 	pDevice->byFOETuning = 0;
@@ -549,12 +508,12 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 		if (byValue == 0) // if not set default is All
 			byValue = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
 
-		pDevice->ulDiversityNValue = 100*260;//100*SROMbyReadEmbedded(pDevice->PortOffset, 0x51);
-		pDevice->ulDiversityMValue = 100*16;//SROMbyReadEmbedded(pDevice->PortOffset, 0x52);
-		pDevice->byTMax = 1;//SROMbyReadEmbedded(pDevice->PortOffset, 0x53);
-		pDevice->byTMax2 = 4;//SROMbyReadEmbedded(pDevice->PortOffset, 0x54);
-		pDevice->ulSQ3TH = 0;//(unsigned long) SROMbyReadEmbedded(pDevice->PortOffset, 0x55);
-		pDevice->byTMax3 = 64;//SROMbyReadEmbedded(pDevice->PortOffset, 0x56);
+		pDevice->ulDiversityNValue = 100*260;
+		pDevice->ulDiversityMValue = 100*16;
+		pDevice->byTMax = 1;
+		pDevice->byTMax2 = 4;
+		pDevice->ulSQ3TH = 0;
+		pDevice->byTMax3 = 64;
 
 		if (byValue == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {
 			pDevice->byAntennaCount = 2;
@@ -568,7 +527,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 			// chester for antenna
 			byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
 			if ((byValue1 & 0x08) == 0)
-				pDevice->bDiversityEnable = false;//SROMbyReadEmbedded(pDevice->PortOffset, 0x50);
+				pDevice->bDiversityEnable = false;
 			else
 				pDevice->bDiversityEnable = true;
 		} else  {
@@ -593,7 +552,6 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",
 			pDevice->bDiversityEnable, (int)pDevice->ulDiversityNValue, (int)pDevice->ulDiversityMValue, pDevice->byTMax, pDevice->byTMax2);
 
-//#ifdef ZoneType_DefaultSetting
 //2008-8-4 <add> by chester
 //zonetype initial
 		pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
@@ -647,9 +605,6 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 		pDevice->byCurPwr = 0xFF;
 		pDevice->byCCKPwr = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_CCK);
 		pDevice->byOFDMPwrG = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_OFDMG);
-		//byCCKPwrdBm = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_CCK_PWR_dBm);
-
-		//byOFDMPwrdBm = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_OFDM_PWR_dBm);
 
 		// Load power Table
 
@@ -715,7 +670,6 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 
 		pDevice->byCurrentCh = 0;
 
-		//pDevice->NetworkType = Ndis802_11Automode;
 		// Set BB and packet type at the same time.
 		// Set Short Slot Time, xIFS, and RSPINF.
 		if (pDevice->uConnectionRate == RATE_AUTO) {
@@ -807,7 +761,7 @@ static bool device_release_WPADEV(PSDevice pDevice)
 {
 	viawget_wpa_header *wpahdr;
 	int ii = 0;
-	// wait_queue_head_t	Set_wait;
+
 	//send device close to wpa_supplicnat layer
 	if (pDevice->bWPADEVUp) {
 		wpahdr = (viawget_wpa_header *)pDevice->skb->data;
@@ -823,9 +777,6 @@ static bool device_release_WPADEV(PSDevice pDevice)
 		netif_rx(pDevice->skb);
 		pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
 
-		//wait release WPADEV
-		//    init_waitqueue_head(&Set_wait);
-		//    wait_event_timeout(Set_wait, ((pDevice->wpadev==NULL)&&(pDevice->skb == NULL)),5*HZ);    //1s wait
 		while (pDevice->bWPADEVUp) {
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			schedule_timeout(HZ / 20);          //wait 50ms
@@ -869,7 +820,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	}
 
 	// Chain it all together
-	// SET_MODULE_OWNER(dev);
 	SET_NETDEV_DEV(dev, &pcid->dev);
 
 	if (bFirst) {
@@ -902,7 +852,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 #ifdef	DEBUG
 
-	//pci_read_config_byte(pcid, PCI_BASE_ADDRESS_0, &pDevice->byRevId);
 	printk("after get pci_info memaddr is %x, io addr is %x,io_size is %d\n", pDevice->memaddr, pDevice->ioaddr, pDevice->io_size);
 	{
 		int i;
@@ -916,7 +865,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 			PCI_BASE_ADDRESS_5,
 			0};
 		for (i = 0; address[i]; i++) {
-			//pci_write_config_dword(pcid,address[i], 0xFFFFFFFF);
 			pci_read_config_dword(pcid, address[i], &bar);
 			printk("bar %d is %x\n", i, bar);
 			if (!bar) {
@@ -942,11 +890,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 #endif
 
-#ifdef	DEBUG
-	//return  0;
-#endif
 	pDevice->PortOffset = (unsigned long)ioremap(pDevice->memaddr & PCI_BASE_ADDRESS_MEM_MASK, pDevice->io_size);
-	//pDevice->PortOffset = (unsigned long)ioremap(pDevice->ioaddr & PCI_BASE_ADDRESS_IO_MASK, pDevice->io_size);
 
 	if (pDevice->PortOffset == 0) {
 		printk(KERN_ERR DEVICE_NAME ": Failed to IO remapping ..\n");
@@ -967,7 +911,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 	VNSvInPortB(pDevice->PortOffset+0x4F, &value);
 	printk("Before write: value is %x\n", value);
-	//VNSvInPortB(pDevice->PortOffset+0x3F, 0x00);
 	VNSvOutPortB(pDevice->PortOffset, value);
 	VNSvInPortB(pDevice->PortOffset+0x4F, &value);
 	printk("After write: value is %x\n", value);
@@ -1075,11 +1018,6 @@ static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid) {
 	pDevice->memaddr = pci_resource_start(pcid, 0);
 	pDevice->ioaddr = pci_resource_start(pcid, 1);
 
-#ifdef	DEBUG
-//	pDevice->ioaddr = pci_resource_start(pcid, 0);
-//	pDevice->memaddr = pci_resource_start(pcid,1);
-#endif
-
 	cis_addr = pci_resource_start(pcid, 2);
 
 	pDevice->pcid = pcid;
@@ -1088,13 +1026,6 @@ static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid) {
 	pci_write_config_byte(pcid, PCI_COMMAND, (b|PCI_COMMAND_MASTER));
 
 #ifdef	PLICE_DEBUG
-	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
-	//for (ii=0;ii<0xFF;ii++)
-	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
-	//max_lat  = 0x20;
-	//pci_write_config_word(pcid,PCI_MAX_LAT,max_lat);
-	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
-
 	for (ii = 0; ii < 0xFF; ii++) {
 		pci_read_config_byte(pcid, ii, &value);
 		pci_config[ii] = value;
@@ -1468,7 +1399,6 @@ static int device_rx_srv(PSDevice pDevice, unsigned int uIdx) {
 	for (pRD = pDevice->pCurrRD[uIdx];
 	     pRD->m_rd0RD0.f1Owner == OWNED_BY_HOST;
 	     pRD = pRD->next) {
-//        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->pCurrRD = %x, works = %d\n", pRD, works);
 		if (works++ > 15)
 			break;
 		if (device_receive_frame(pDevice, pRD)) {
@@ -1584,7 +1514,6 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 					skb->dev = pDevice->apdev;
 					skb_reset_mac_header(skb);
 					skb->pkt_type = PACKET_OTHERHOST;
-					//skb->protocol = htons(ETH_P_802_2);
 					memset(skb->cb, 0, sizeof(skb->cb));
 					netif_rx(skb);
 				}
@@ -1596,8 +1525,6 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 						(int)uIdx, byTsr1, byTsr0);
 				}
 
-//                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
-//                          (int)uIdx, byTsr1, byTsr0);
 
 				if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) &&
 				    (pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)) {
@@ -1689,33 +1616,22 @@ int MlmeThread(
 {
 	PSDevice	pDevice =  (PSDevice) Context;
 	PSRxMgmtPacket			pRxMgmtPacket;
-	// int i;
-	//complete(&pDevice->notify);
 
-	//i = 0;
-#if 1
 	while (1) {
-		//down(&pDevice->mlme_semaphore);
-		// pRxMgmtPacket =  DeQueue(pDevice);
-#if 1
 		spin_lock_irq(&pDevice->lock);
 		while (pDevice->rxManeQueue.packet_num != 0) {
 			pRxMgmtPacket = DeQueue(pDevice);
-			//pDevice;
-			//DequeueManageObject(pDevice->FirstRecvMngList, pDevice->LastRecvMngList);
 			vMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);
 		}
 		spin_unlock_irq(&pDevice->lock);
 		if (mlme_kill == 0)
 			break;
-		//udelay(200);
-#endif
+
 		schedule();
 		if (mlme_kill == 0)
 			break;
 	}
 
-#endif
 	return 0;
 }
 
@@ -1749,7 +1665,6 @@ static int  device_open(struct net_device *dev) {
 	device_init_defrag_cb(pDevice);
 	device_init_td0_ring(pDevice);
 	device_init_td1_ring(pDevice);
-//    VNTWIFIvSet11h(pDevice->pMgmt, pDevice->b11hEnable);
 
 	if (pDevice->bDiversityRegCtlON) {
 		device_init_diversity_timer(pDevice);
@@ -1773,8 +1688,6 @@ static int  device_open(struct net_device *dev) {
 	mlme_kill = 1;
 #endif
 
-	//wait_for_completion(&pDevice->notify);
-
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
 	device_init_registers(pDevice, DEVICE_INIT_COLD);
 	MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
@@ -1786,12 +1699,6 @@ static int  device_open(struct net_device *dev) {
 	add_timer(&(pDevice->pMgmt->sTimerSecondCallback));
 
 #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-	/*
-	  pDevice->bwextstep0 = false;
-	  pDevice->bwextstep1 = false;
-	  pDevice->bwextstep2 = false;
-	  pDevice->bwextstep3 = false;
-	*/
 	pDevice->bwextcount = 0;
 	pDevice->bWPASuppWextEnabled = false;
 #endif
@@ -1873,9 +1780,7 @@ static int  device_close(struct net_device *dev) {
 	pDevice->flags &= (~DEVICE_FLAGS_OPENED);
 	//2008-0714-01<Add>by chester
 	device_release_WPADEV(pDevice);
-//PLICE_DEBUG->
-	//tasklet_kill(&pDevice->RxMngWorkItem);
-//PLICE_DEBUG<-
+
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close.. \n");
 	return 0;
 }
@@ -1922,7 +1827,6 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 	unsigned int cbHeaderSize;
 	unsigned int ii;
 	SKeyItem        STempKey;
-//    unsigned char byKeyIndex = 0;
 
 	if (pDevice->bStopTx0Pkt) {
 		dev_kfree_skb_irq(skb);
@@ -2279,7 +2183,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 		}
 	}
 
-//    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
 
 	if (pDevice->wCurrentRate <= RATE_11M) {
 		byPktType = PK_TYPE_11B;
@@ -2293,10 +2196,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 		}
 	}
 
-//#ifdef	PLICE_DEBUG
-//	printk("FIX RATE:CurrentRate is %d");
-//#endif
-
 	if (bNeedEncryption) {
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ntohs Pkt Type=%04x\n", ntohs(pDevice->sTxEthHeader.wType));
 		if ((pDevice->sTxEthHeader.wType) == TYPE_PKT_802_1x) {
@@ -2374,12 +2273,10 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	}
 
 	pDevice->apCurrTD[TYPE_AC0DMA] = pHeadTD;
-//#ifdef	PLICE_DEBUG
+
 	if (pDevice->bFixRate) {
 		printk("FixRate:Rate is %d,TxPower is %d\n", pDevice->wCurrentRate, pDevice->byCurPwr);
-	} else {
 	}
-//#endif
 
 	{
 		unsigned char Protocol_Version;    //802.1x Authentication
@@ -2411,7 +2308,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	}
 
 	MACvTransmitAC0(pDevice->PortOffset);
-//    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0:pDevice->apCurrTD= %p\n", pHeadTD);
 
 	dev->trans_start = jiffies;
 
@@ -2430,7 +2326,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 	int             handled = 0;
 	unsigned char byData = 0;
 	int             ii = 0;
-//    unsigned char byRSSI;
 
 	MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
 
@@ -2441,17 +2336,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwIsr = 0xffff\n");
 		return IRQ_RETVAL(handled);
 	}
-	/*
-	// 2008-05-21 <mark> by Richardtai, we can't read RSSI here, because no packet bound with RSSI
-
-	if ((pDevice->dwIsr & ISR_RXDMA0) &&
-	(pDevice->byLocalID != REV_ID_VT3253_B0) &&
-	(pDevice->bBSSIDFilter == true)) {
-	// update RSSI
-	//BBbReadEmbedded(pDevice->PortOffset, 0x3E, &byRSSI);
-	//pDevice->uCurrRSSI = byRSSI;
-	}
-	*/
 
 	handled = 1;
 	MACvIntDisable(pDevice->PortOffset);
@@ -2492,7 +2376,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 				VNSvInPortD(pDevice->PortOffset + MAC_REG_MAR4, &(pDevice->dwOrgMAR4));
 				MACvSelectPage0(pDevice->PortOffset);
 				//xxxx
-				// WCMDbFlushCommandQueue(pDevice->pMgmt, true);
 				if (set_channel(pDevice, pDevice->pCurrMeasureEID->sReq.byChannel)) {
 					pDevice->bMeasureInProgress = true;
 					MACvSelectPage1(pDevice->PortOffset);
@@ -2505,7 +2388,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 					}
 				} else {
 					// can not measure because set channel fail
-					// WCMDbResetCommandQueue(pDevice->pMgmt);
 					// clear measure control
 					MACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);
 					s_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_INCAPABLE);
@@ -2529,7 +2411,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 				MACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);
 				MACvSelectPage0(pDevice->PortOffset);
 				set_channel(pDevice, pDevice->byOrgChannel);
-				// WCMDbResetCommandQueue(pDevice->pMgmt);
 				MACvSelectPage1(pDevice->PortOffset);
 				MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
 				MACvSelectPage0(pDevice->PortOffset);
@@ -2572,9 +2453,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 
 				}
 			}
-			if (pDevice->eOPMode == OP_MODE_ADHOC) {
-				//pDevice->bBeaconSent = false;
-			} else {
+			if (pDevice->eOPMode != OP_MODE_ADHOC) {
 				if ((pDevice->bUpdateBBVGA) && pDevice->bLinkPass && (pDevice->uCurrRSSI != 0)) {
 					long            ldBm;
 
@@ -2615,9 +2494,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 							  (pMgmt->wIBSSBeaconPeriod - MAKE_BEACON_RESERVED) << 10);
 			}
 
-			if (pDevice->eOPMode == OP_MODE_ADHOC && pDevice->pMgmt->wCurrATIMWindow > 0) {
-				// todo adhoc PS mode
-			}
+			/* TODO: adhoc PS mode */
 
 		}
 
@@ -2651,7 +2528,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 					MACvSelectPage1(pDevice->PortOffset);
 					MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
 					MACvSelectPage0(pDevice->PortOffset);
-					//VNTWIFIbSendBeacon(pDevice->pMgmt);
 					CARDbStartTxPacket(pDevice, PKT_TYPE_802_11_ALL);
 				}
 			}
@@ -2670,8 +2546,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 		if (pDevice->dwIsr & ISR_AC0DMA) {
 			max_count += device_tx_srv(pDevice, TYPE_AC0DMA);
 		}
-		if (pDevice->dwIsr & ISR_SOFTTIMER) {
-		}
 		if (pDevice->dwIsr & ISR_SOFTTIMER1) {
 			if (pDevice->eOPMode == OP_MODE_AP) {
 				if (pDevice->bShortSlotTime)
@@ -3099,16 +2973,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	case SIOCGIWPRIV:
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV \n");
 		rc = -EOPNOTSUPP;
-/*
-  if (wrq->u.data.pointer) {
-  wrq->u.data.length = sizeof(iwctl_private_args) / sizeof(iwctl_private_args[0]);
-
-  if (copy_to_user(wrq->u.data.pointer,
-  (u_char *) iwctl_private_args,
-  sizeof(iwctl_private_args)))
-  rc = -EFAULT;
-  }
-*/
 		break;
 
 //2008-0409-07, <Add> by Einsn Liu
@@ -3290,8 +3154,6 @@ static int __init vt6655_init_module(void)
 {
 	int ret;
 
-//    ret=pci_module_init(&device_driver);
-	//ret = pcie_port_service_register(&device_driver);
 	ret = pci_register_driver(&device_driver);
 #ifdef CONFIG_PM
 	if (ret >= 0)

commit 41e043fcfa2236bb2c4a8335eb09f4c8cee224b3
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 3 08:26:00 2013 +0900

    staging: remove DEFINE_PCI_DEVICE_TABLE macro
    
    Don't use DEFINE_PCI_DEVICE_TABLE macro, because this macro
    is not preferred.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 68cbaee29775..a952df1bf9d6 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -267,7 +267,7 @@ static CHIP_INFO chip_info_table[] = {
 	{0, NULL}
 };
 
-DEFINE_PCI_DEVICE_TABLE(vt6655_pci_id_table) = {
+const struct pci_device_id vt6655_pci_id_table[] = {
 	{ PCI_VDEVICE(VIA, 0x3253), (kernel_ulong_t)chip_info_table},
 	{ 0, }
 };

commit 1208f14a37fde2669b86bf1b1cd1122ad2ba3579
Author: Teodora Baluta <teobaluta@gmail.com>
Date:   Sun Nov 10 17:12:42 2013 +0200

    staging: vt6655: delete explicit comparison to bool
    
    This patch fixes the following type of coccinelle detected warnings for
    driver vt6655:
    
    WARNING: Comparison to bool
    
    Signed-off-by: Teodora Baluta <teobaluta@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index e93fdc88d844..68cbaee29775 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -561,7 +561,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 			pDevice->byTxAntennaMode = ANT_B;
 			pDevice->dwTxAntennaSel = 1;
 			pDevice->dwRxAntennaSel = 1;
-			if (pDevice->bTxRxAntInv == true)
+			if (pDevice->bTxRxAntInv)
 				pDevice->byRxAntennaMode = ANT_A;
 			else
 				pDevice->byRxAntennaMode = ANT_B;
@@ -578,13 +578,13 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 			pDevice->dwRxAntennaSel = 0;
 			if (byValue & EEP_ANTENNA_AUX) {
 				pDevice->byTxAntennaMode = ANT_A;
-				if (pDevice->bTxRxAntInv == true)
+				if (pDevice->bTxRxAntInv)
 					pDevice->byRxAntennaMode = ANT_B;
 				else
 					pDevice->byRxAntennaMode = ANT_A;
 			} else {
 				pDevice->byTxAntennaMode = ANT_B;
-				if (pDevice->bTxRxAntInv == true)
+				if (pDevice->bTxRxAntInv)
 					pDevice->byRxAntennaMode = ANT_A;
 				else
 					pDevice->byRxAntennaMode = ANT_B;
@@ -635,7 +635,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 		pDevice->byRFType &= RF_MASK;
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRFType = %x\n", pDevice->byRFType);
 
-		if (pDevice->bZoneRegExist == false) {
+		if (!pDevice->bZoneRegExist) {
 			pDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
 		}
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byZoneType = %x\n", pDevice->byZoneType);
@@ -742,7 +742,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 			if (!(pDevice->byGPIO & GPIO0_DATA)) { pDevice->bHWRadioOff = false; }
 
 		}
-		if ((pDevice->bRadioControlOff == true)) {
+		if (pDevice->bRadioControlOff) {
 			CARDbRadioPowerOff(pDevice);
 		} else  CARDbRadioPowerOn(pDevice);
 #else
@@ -751,7 +751,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 			pDevice->bHWRadioOff = true;
 		}
 	}
-	if ((pDevice->bHWRadioOff == true) || (pDevice->bRadioControlOff == true)) {
+	if (pDevice->bHWRadioOff || pDevice->bRadioControlOff) {
 		CARDbRadioPowerOff(pDevice);
 	}
 
@@ -809,7 +809,7 @@ static bool device_release_WPADEV(PSDevice pDevice)
 	int ii = 0;
 	// wait_queue_head_t	Set_wait;
 	//send device close to wpa_supplicnat layer
-	if (pDevice->bWPADEVUp == true) {
+	if (pDevice->bWPADEVUp) {
 		wpahdr = (viawget_wpa_header *)pDevice->skb->data;
 		wpahdr->type = VIAWGET_DEVICECLOSE_MSG;
 		wpahdr->resp_ie_len = 0;
@@ -826,7 +826,7 @@ static bool device_release_WPADEV(PSDevice pDevice)
 		//wait release WPADEV
 		//    init_waitqueue_head(&Set_wait);
 		//    wait_event_timeout(Set_wait, ((pDevice->wpadev==NULL)&&(pDevice->skb == NULL)),5*HZ);    //1s wait
-		while ((pDevice->bWPADEVUp == true)) {
+		while (pDevice->bWPADEVUp) {
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			schedule_timeout(HZ / 20);          //wait 50ms
 			ii++;
@@ -892,7 +892,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 #ifdef	DEBUG
 	printk("Before get pci_info memaddr is %x\n", pDevice->memaddr);
 #endif
-	if (device_get_pci_info(pDevice, pcid) == false) {
+	if (!device_get_pci_info(pDevice, pcid)) {
 		printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device.\n");
 		device_free_info(pDevice);
 		return -ENODEV;
@@ -1633,7 +1633,7 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 			bFull = true;
 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " AC0DMA is Full = %d\n", pDevice->iTDUsed[uIdx]);
 		}
-		if (netif_queue_stopped(pDevice->dev) && (bFull == false)) {
+		if (netif_queue_stopped(pDevice->dev) && !bFull) {
 			netif_wake_queue(pDevice->dev);
 		}
 	}
@@ -1798,7 +1798,7 @@ static int  device_open(struct net_device *dev) {
 	pDevice->byReAssocCount = 0;
 	pDevice->bWPADEVUp = false;
 	// Patch: if WEP key already set by iwconfig but device not yet open
-	if ((pDevice->bEncryptionEnable == true) && (pDevice->bTransmitKey == true)) {
+	if (pDevice->bEncryptionEnable && pDevice->bTransmitKey) {
 		KeybSetDefaultKey(&(pDevice->sKey),
 				  (unsigned long)(pDevice->byKeyIndex | (1 << 31)),
 				  pDevice->uKeyLength,
@@ -1895,7 +1895,7 @@ static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
 		return 0;
 	}
 
-	if (pDevice->bStopTx0Pkt == true) {
+	if (pDevice->bStopTx0Pkt) {
 		dev_kfree_skb_irq(skb);
 		spin_unlock_irq(&pDevice->lock);
 		return 0;
@@ -1924,7 +1924,7 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 	SKeyItem        STempKey;
 //    unsigned char byKeyIndex = 0;
 
-	if (pDevice->bStopTx0Pkt == true) {
+	if (pDevice->bStopTx0Pkt) {
 		dev_kfree_skb_irq(skb);
 		return false;
 	}
@@ -1993,14 +1993,14 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 	} else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
 		byPktType = PK_TYPE_11A;
 	} else {
-		if (pDevice->bProtectMode == true) {
+		if (pDevice->bProtectMode) {
 			byPktType = PK_TYPE_11GB;
 		} else {
 			byPktType = PK_TYPE_11GA;
 		}
 	}
 
-	if (pDevice->bEncryptionEnable == true)
+	if (pDevice->bEncryptionEnable)
 		bNeedEncryption = true;
 
 	if (pDevice->bEnableHostWEP) {
@@ -2076,7 +2076,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	bool bNodeExist = false;
 
 	spin_lock_irq(&pDevice->lock);
-	if (pDevice->bLinkPass == false) {
+	if (!pDevice->bLinkPass) {
 		dev_kfree_skb_irq(skb);
 		spin_unlock_irq(&pDevice->lock);
 		return 0;
@@ -2130,7 +2130,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 			}
 		}
 
-		if (bNodeExist == false) {
+		if (!bNodeExist) {
 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "Unknown STA not found in node DB \n");
 			dev_kfree_skb_irq(skb);
 			spin_unlock_irq(&pDevice->lock);
@@ -2149,7 +2149,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 		cbFrameBodySize += 8;
 	}
 
-	if (pDevice->bEncryptionEnable == true) {
+	if (pDevice->bEncryptionEnable) {
 		bNeedEncryption = true;
 		// get Transmit key
 		do {
@@ -2196,7 +2196,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 
 	if (pDevice->bEnableHostWEP) {
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "acdma0: STA index %d\n", uNodeIndex);
-		if (pDevice->bEncryptionEnable == true) {
+		if (pDevice->bEncryptionEnable) {
 			pTransmitKey = &STempKey;
 			pTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;
 			pTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;
@@ -2286,7 +2286,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	} else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
 		byPktType = PK_TYPE_11A;
 	} else {
-		if (pDevice->bProtectMode == true) {
+		if (pDevice->bProtectMode) {
 			byPktType = PK_TYPE_11GB;
 		} else {
 			byPktType = PK_TYPE_11GA;
@@ -2297,7 +2297,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 //	printk("FIX RATE:CurrentRate is %d");
 //#endif
 
-	if (bNeedEncryption == true) {
+	if (bNeedEncryption) {
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ntohs Pkt Type=%04x\n", ntohs(pDevice->sTxEthHeader.wType));
 		if ((pDevice->sTxEthHeader.wType) == TYPE_PKT_802_1x) {
 			bNeedEncryption = false;
@@ -2306,7 +2306,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 				if (pTransmitKey == NULL) {
 					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Don't Find TX KEY\n");
 				} else {
-					if (bTKIP_UseGTK == true) {
+					if (bTKIP_UseGTK) {
 						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "error: KEY is GTK!!~~\n");
 					} else {
 						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
@@ -2493,7 +2493,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 				MACvSelectPage0(pDevice->PortOffset);
 				//xxxx
 				// WCMDbFlushCommandQueue(pDevice->pMgmt, true);
-				if (set_channel(pDevice, pDevice->pCurrMeasureEID->sReq.byChannel) == true) {
+				if (set_channel(pDevice, pDevice->pCurrMeasureEID->sReq.byChannel)) {
 					pDevice->bMeasureInProgress = true;
 					MACvSelectPage1(pDevice->PortOffset);
 					MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_READY);
@@ -2544,12 +2544,12 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 			if (pDevice->dwIsr & ISR_QUIETSTART) {
 				do {
 					;
-				} while (CARDbStartQuiet(pDevice) == false);
+				} while (!CARDbStartQuiet(pDevice));
 			}
 		}
 
 		if (pDevice->dwIsr & ISR_TBTT) {
-			if (pDevice->bEnableFirstQuiet == true) {
+			if (pDevice->bEnableFirstQuiet) {
 				pDevice->byQuietStartCount--;
 				if (pDevice->byQuietStartCount == 0) {
 					pDevice->bEnableFirstQuiet = false;
@@ -2558,7 +2558,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 					MACvSelectPage0(pDevice->PortOffset);
 				}
 			}
-			if ((pDevice->bChannelSwitch == true) &&
+			if (pDevice->bChannelSwitch &&
 			    (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE)) {
 				pDevice->byChannelSwitchCount--;
 				if (pDevice->byChannelSwitchCount == 0) {
@@ -2575,7 +2575,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 			if (pDevice->eOPMode == OP_MODE_ADHOC) {
 				//pDevice->bBeaconSent = false;
 			} else {
-				if ((pDevice->bUpdateBBVGA) && (pDevice->bLinkPass == true) && (pDevice->uCurrRSSI != 0)) {
+				if ((pDevice->bUpdateBBVGA) && pDevice->bLinkPass && (pDevice->uCurrRSSI != 0)) {
 					long            ldBm;
 
 					RFvRSSITodBm(pDevice, (unsigned char) pDevice->uCurrRSSI, &ldBm);
@@ -2642,7 +2642,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 			}
 			pDevice->bBeaconSent = true;
 
-			if (pDevice->bChannelSwitch == true) {
+			if (pDevice->bChannelSwitch) {
 				pDevice->byChannelSwitchCount--;
 				if (pDevice->byChannelSwitchCount == 0) {
 					pDevice->bChannelSwitch = false;
@@ -3237,7 +3237,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 			netif_stop_queue(pDevice->dev);
 #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 			pMgmt->eScanType = WMAC_SCAN_ACTIVE;
-			if (pDevice->bWPASuppWextEnabled != true)
+			if (!pDevice->bWPASuppWextEnabled)
 #endif
 				bScheduleCommand((void *)pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);
 			bScheduleCommand((void *)pDevice, WLAN_CMD_SSID, NULL);
@@ -3373,7 +3373,7 @@ viawget_resume(struct pci_dev *pcid)
 		spin_lock_irq(&pDevice->lock);
 		MACvRestoreContext(pDevice->PortOffset, pDevice->abyMacContext);
 		device_init_registers(pDevice, DEVICE_INIT_DXPL);
-		if (pMgmt->sNodeDBTable[0].bActive == true) { // Assoc with BSS
+		if (pMgmt->sNodeDBTable[0].bActive) { // Assoc with BSS
 			pMgmt->sNodeDBTable[0].bActive = false;
 			pDevice->bLinkPass = false;
 			if (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {

commit 27e811075b694ea28d8f167b6763785002a4ec40
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Fri Sep 20 15:41:38 2013 +0530

    staging: vt6655: Remove redundant pci_set_drvdata
    
    Driver core sets driver data to NULL upon failure or remove.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 7f36a7103c3e..e93fdc88d844 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1153,10 +1153,6 @@ static void device_free_info(PSDevice pDevice) {
 		pci_release_regions(pDevice->pcid);
 	if (dev)
 		free_netdev(dev);
-
-	if (pDevice->pcid) {
-		pci_set_drvdata(pDevice->pcid, NULL);
-	}
 }
 
 static bool device_init_rings(PSDevice pDevice) {

commit 6496c045292b7afe74b5306c123186976f032125
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu Jun 27 20:57:23 2013 +0800

    vt6655/trivial: replace numeric with standard PM state macros
    
    Use standard PM state macros PCI_Dx instead of numeric 0/1/2..
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Cc: Forest Bond <forest@alittletooquiet.net>
    Cc: Jiri Kosina <trivial@kernel.org>
    Cc: Devendra Naga <devendra.aaru@gmail.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Marcos Paulo de Souza <marcos.souza.org@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 08b250f01dae..7f36a7103c3e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3370,8 +3370,8 @@ viawget_resume(struct pci_dev *pcid)
 	PSMgmtObject  pMgmt = pDevice->pMgmt;
 	int power_status;   // to silence the compiler
 
-	power_status = pci_set_power_state(pcid, 0);
-	power_status = pci_enable_wake(pcid, 0, 0);
+	power_status = pci_set_power_state(pcid, PCI_D0);
+	power_status = pci_enable_wake(pcid, PCI_D0, 0);
 	pci_restore_state(pcid);
 	if (netif_running(pDevice->dev)) {
 		spin_lock_irq(&pDevice->lock);

commit 20b4fb485227404329e41ad15588afad3df23050
Merge: b9394d8a657c ac3e3c5b1164
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 1 17:51:54 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull VFS updates from Al Viro,
    
    Misc cleanups all over the place, mainly wrt /proc interfaces (switch
    create_proc_entry to proc_create(), get rid of the deprecated
    create_proc_read_entry() in favor of using proc_create_data() and
    seq_file etc).
    
    7kloc removed.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (204 commits)
      don't bother with deferred freeing of fdtables
      proc: Move non-public stuff from linux/proc_fs.h to fs/proc/internal.h
      proc: Make the PROC_I() and PDE() macros internal to procfs
      proc: Supply a function to remove a proc entry by PDE
      take cgroup_open() and cpuset_open() to fs/proc/base.c
      ppc: Clean up scanlog
      ppc: Clean up rtas_flash driver somewhat
      hostap: proc: Use remove_proc_subtree()
      drm: proc: Use remove_proc_subtree()
      drm: proc: Use minor->index to label things, not PDE->name
      drm: Constify drm_proc_list[]
      zoran: Don't print proc_dir_entry data in debug
      reiserfs: Don't access the proc_dir_entry in r_open(), r_start() r_show()
      proc: Supply an accessor for getting the data from a PDE's parent
      airo: Use remove_proc_subtree()
      rtl8192u: Don't need to save device proc dir PDE
      rtl8187se: Use a dir under /proc/net/r8180/
      proc: Add proc_mkdir_data()
      proc: Move some bits from linux/proc_fs.h to linux/{of.h,signal.h,tty.h}
      proc: Move PDE_NET() to fs/proc/proc_net.c
      ...

commit f805442e130c6eeb6c25bc5c3b3cefc27ab6dcec
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 6 18:11:22 2013 -0400

    vt6655: slightly clean reading config file
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 453c83d7fe8c..a89ab9bf38e4 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -60,6 +60,7 @@
  */
 #undef __NO_VERSION__
 
+#include <linux/file.h>
 #include "device.h"
 #include "card.h"
 #include "channel.h"
@@ -2946,87 +2947,51 @@ static int Config_FileGetParameter(unsigned char *string,
  return true;
 }
 
-int Config_FileOperation(PSDevice pDevice,bool fwrite,unsigned char *Parameter) {
-    unsigned char *config_path = CONFIG_PATH;
-    unsigned char *buffer = NULL;
-    unsigned char tmpbuffer[20];
-    struct file   *filp=NULL;
-    mm_segment_t old_fs = get_fs();
-    //int oldfsuid=0,oldfsgid=0;
-    int result=0;
-
-    set_fs (KERNEL_DS);
-
-    /* Can't do this anymore, so we rely on correct filesystem permissions:
-    //Make sure a caller can read or write power as root
-    oldfsuid=current->cred->fsuid;
-    oldfsgid=current->cred->fsgid;
-    current->cred->fsuid = 0;
-    current->cred->fsgid = 0;
-    */
-
-    //open file
-      filp = filp_open(config_path, O_RDWR, 0);
-        if (IS_ERR(filp)) {
-	     printk("Config_FileOperation:open file fail?\n");
-	     result=-1;
-             goto error2;
-	  }
+int Config_FileOperation(PSDevice pDevice,bool fwrite,unsigned char *Parameter)
+{
+	unsigned char *buffer = kmalloc(1024, GFP_KERNEL);
+	unsigned char tmpbuffer[20];
+	struct file *file;
+	int result=0;
 
-     if(!(filp->f_op) || !(filp->f_op->read) ||!(filp->f_op->write)) {
-           printk("file %s cann't readable or writable?\n",config_path);
-	  result = -1;
-	  goto error1;
-     	}
-
-buffer = kmalloc(1024, GFP_KERNEL);
-if(buffer==NULL) {
-  printk("allocate mem for file fail?\n");
-  result = -1;
-  goto error1;
-}
+	if (!buffer) {
+		printk("allocate mem for file fail?\n");
+		return -1;
+	}
+	file = filp_open(CONFIG_PATH, O_RDONLY, 0);
+	if (IS_ERR(file)) {
+		kfree(buffer);
+		printk("Config_FileOperation:open file fail?\n");
+		return -1;
+	}
 
-if(filp->f_op->read(filp, buffer, 1024, &filp->f_pos)<0) {
- printk("read file error?\n");
- result = -1;
- goto error1;
-}
+	if (kernel_read(file, 0, buffer, 1024) < 0) {
+		printk("read file error?\n");
+		result = -1;
+		goto error1;
+	}
 
-if(Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer)!=true) {
-  printk("get parameter error?\n");
-  result = -1;
-  goto error1;
-}
+	if (Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer)!=true) {
+		printk("get parameter error?\n");
+		result = -1;
+		goto error1;
+	}
 
-if(memcmp(tmpbuffer,"USA",3)==0) {
-  result=ZoneType_USA;
-}
-else if(memcmp(tmpbuffer,"JAPAN",5)==0) {
-  result=ZoneType_Japan;
-}
-else if(memcmp(tmpbuffer,"EUROPE",5)==0) {
- result=ZoneType_Europe;
-}
-else {
-  result = -1;
-  printk("Unknown Zonetype[%s]?\n",tmpbuffer);
-}
+	if (memcmp(tmpbuffer,"USA",3)==0) {
+		result = ZoneType_USA;
+	} else if(memcmp(tmpbuffer,"JAPAN",5)==0) {
+		result = ZoneType_Japan;
+	} else if(memcmp(tmpbuffer,"EUROPE",5)==0) {
+		result = ZoneType_Europe;
+	} else {
+		result = -1;
+		printk("Unknown Zonetype[%s]?\n",tmpbuffer);
+	}
 
 error1:
-  kfree(buffer);
-
-  if(filp_close(filp,NULL))
-       printk("Config_FileOperation:close file fail\n");
-
-error2:
-  set_fs (old_fs);
-
-  /*
-  current->cred->fsuid=oldfsuid;
-  current->cred->fsgid=oldfsgid;
-  */
-
-  return result;
+	kfree(buffer);
+	fput(file);
+	return result;
 }
 
 

commit 96d69e201bbdb05c363e899138f9f42bc8ad8f88
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 20:55:41 2013 -0700

    staging: vt6655: Remove unnecessary blank lines
    
    Remove a bunch of useless vertical whitespace.
    
    Convert 3 or more consecutive newlines to 2.
    Remove blank lines after open brace and before close brace.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 143d050a5dfb..be4f6c2ca3ff 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -128,7 +128,6 @@ DEVICE_PARAM(TxDescriptors0, "Number of transmit descriptors0");
 #define TX_DESC_DEF1     64
 DEVICE_PARAM(TxDescriptors1, "Number of transmit descriptors1");
 
-
 #define IP_ALIG_DEF     0
 /* IP_byte_align[] is used for IP header unsigned long byte aligned
    0: indicate the IP header won't be unsigned long byte aligned.(Default) .
@@ -138,7 +137,6 @@ DEVICE_PARAM(TxDescriptors1, "Number of transmit descriptors1");
 */
 DEVICE_PARAM(IP_byte_align, "Enable IP header dword aligned");
 
-
 #define INT_WORKS_DEF   20
 #define INT_WORKS_MIN   10
 #define INT_WORKS_MAX   64
@@ -151,7 +149,6 @@ DEVICE_PARAM(int_works, "Number of packets per interrupt services");
 
 DEVICE_PARAM(Channel, "Channel number");
 
-
 /* PreambleType[] is the preamble length used for transmit.
    0: indicate allows long preamble type
    1: indicate allows short preamble type
@@ -161,21 +158,18 @@ DEVICE_PARAM(Channel, "Channel number");
 
 DEVICE_PARAM(PreambleType, "Preamble Type");
 
-
 #define RTS_THRESH_MIN     512
 #define RTS_THRESH_MAX     2347
 #define RTS_THRESH_DEF     2347
 
 DEVICE_PARAM(RTSThreshold, "RTS threshold");
 
-
 #define FRAG_THRESH_MIN     256
 #define FRAG_THRESH_MAX     2346
 #define FRAG_THRESH_DEF     2346
 
 DEVICE_PARAM(FragThreshold, "Fragmentation threshold");
 
-
 #define DATA_RATE_MIN     0
 #define DATA_RATE_MAX     13
 #define DATA_RATE_DEF     13
@@ -208,7 +202,6 @@ DEVICE_PARAM(OPMode, "Infrastruct, adhoc, AP mode ");
    2: indicate AP mode used
 */
 
-
 /* PSMode[]
    0: indicate disable power saving mode
    1: indicate enable power saving mode
@@ -218,22 +211,18 @@ DEVICE_PARAM(OPMode, "Infrastruct, adhoc, AP mode ");
 
 DEVICE_PARAM(PSMode, "Power saving mode");
 
-
 #define SHORT_RETRY_MIN     0
 #define SHORT_RETRY_MAX     31
 #define SHORT_RETRY_DEF     8
 
-
 DEVICE_PARAM(ShortRetryLimit, "Short frame retry limits");
 
 #define LONG_RETRY_MIN     0
 #define LONG_RETRY_MAX     15
 #define LONG_RETRY_DEF     4
 
-
 DEVICE_PARAM(LongRetryLimit, "long frame retry limits");
 
-
 /* BasebandType[] baseband type selected
    0: indicate 802.11a type
    1: indicate 802.11b type
@@ -245,8 +234,6 @@ DEVICE_PARAM(LongRetryLimit, "long frame retry limits");
 
 DEVICE_PARAM(BasebandType, "baseband type");
 
-
-
 /* 80211hEnable[]
    0: indicate disable 802.11h
    1: indicate enable 802.11h
@@ -265,12 +252,10 @@ DEVICE_PARAM(b80211hEnable, "802.11h mode");
 
 DEVICE_PARAM(bDiversityANTEnable, "ANT diversity mode");
 
-
 //
 // Static vars definitions
 //
 
-
 static int          device_nics             = 0;
 static PSDevice     pDevice_Infos           = NULL;
 static struct net_device *root_device_dev = NULL;
@@ -288,7 +273,6 @@ DEFINE_PCI_DEVICE_TABLE(vt6655_pci_id_table) = {
 
 /*---------------------  Static Functions  --------------------------*/
 
-
 static int  vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent);
 static void vt6655_init_info(struct pci_dev *pcid, PSDevice *ppDevice, PCHIP_INFO);
 static void device_free_info(PSDevice pDevice);
@@ -314,7 +298,6 @@ struct notifier_block device_notifier = {
 };
 #endif
 
-
 static void device_init_rd0_ring(PSDevice pDevice);
 static void device_init_rd1_ring(PSDevice pDevice);
 static void device_init_defrag_cb(PSDevice pDevice);
@@ -340,13 +323,10 @@ static void device_free_frag_buf(PSDevice pDevice);
 static int Config_FileGetParameter(unsigned char *string,
 				   unsigned char *dest, unsigned char *source);
 
-
 /*---------------------  Export Variables  --------------------------*/
 
 /*---------------------  Export Functions  --------------------------*/
 
-
-
 static char *get_chip_name(int chip_id)
 {
 	int i;
@@ -363,7 +343,6 @@ static void vt6655_remove(struct pci_dev *pcid)
 	if (pDevice == NULL)
 		return;
 	device_free_info(pDevice);
-
 }
 
 /*
@@ -425,12 +404,10 @@ static void device_get_options(PSDevice pDevice, int index, char *devname)
 
 static void
 device_set_options(PSDevice pDevice) {
-
 	unsigned char abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 	unsigned char abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
 	unsigned char abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
 
-
 	memcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);
 	memcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);
 	memcpy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel, ETH_ALEN);
@@ -460,7 +437,6 @@ device_set_options(PSDevice pDevice) {
 	pDevice->wCTSDuration = 0;
 	pDevice->byPreambleType = 0;
 
-
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " uChannel= %d\n", (int)pDevice->uChannel);
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byOpMode= %d\n", (int)pDevice->byOpMode);
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " ePSMode= %d\n", (int)pDevice->ePSMode);
@@ -511,11 +487,8 @@ static void s_vCompleteCurrentMeasure(PSDevice pDevice, unsigned char byResult)
 			);
 		CARDbStartMeasure(pDevice, pDevice->pCurrMeasureEID++, pDevice->uNumOfMeasureEIDs);
 	}
-
 }
 
-
-
 //
 // Initialisation of MAC & BBP registers
 //
@@ -679,7 +652,6 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 
 		// Load power Table
 
-
 		for (ii = 0; ii < CB_MAX_CHANNEL_24G; ii++) {
 			pDevice->abyCCKPwrTbl[ii + 1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_CCK_PWR_TBL));
 			if (pDevice->abyCCKPwrTbl[ii + 1] == 0) {
@@ -704,7 +676,6 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 			}
 		}
 
-
 		// Load OFDM A Power Table
 		for (ii = 0; ii < CB_MAX_CHANNEL_5G; ii++) { //RobertYu:20041224, bug using CB_MAX_CHANNEL
 			pDevice->abyOFDMPwrTbl[ii + CB_MAX_CHANNEL_24G + 1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDMA_PWR_TBL));
@@ -712,14 +683,12 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 		}
 		init_channel_table((void *)pDevice);
 
-
 		if (pDevice->byLocalID > REV_ID_VT3253_B1) {
 			MACvSelectPage1(pDevice->PortOffset);
 			VNSvOutPortB(pDevice->PortOffset + MAC_REG_MSRCTL + 1, (MSRCTL1_TXPWR | MSRCTL1_CSAPAREN));
 			MACvSelectPage0(pDevice->PortOffset);
 		}
 
-
 		// use relative tx timeout and 802.11i D4
 		MACvWordRegBitsOn(pDevice->PortOffset, MAC_REG_CFG, (CFG_TKIPOPT | CFG_NOTXTIMEOUT));
 
@@ -812,14 +781,9 @@ MACvReceive1(pDevice->PortOffset);
 MACvStart(pDevice->PortOffset);
 
 netif_stop_queue(pDevice->dev);
-
-
 }
 
-
-
 static void device_init_diversity_timer(PSDevice pDevice) {
-
 	init_timer(&pDevice->TimerSQ3Tmax1);
 	pDevice->TimerSQ3Tmax1.data = (unsigned long) pDevice;
 	pDevice->TimerSQ3Tmax1.function = (TimerFunction)TimerSQ3CallBack;
@@ -838,7 +802,6 @@ static void device_init_diversity_timer(PSDevice pDevice) {
 	return;
 }
 
-
 static bool device_release_WPADEV(PSDevice pDevice)
 {
 	viawget_wpa_header *wpahdr;
@@ -895,7 +858,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 		return -ENODEV;
 	}
 
-
 	dev = alloc_etherdev(sizeof(DEVICE_INFO));
 
 	pDevice = (PSDevice) netdev_priv(dev);
@@ -977,7 +939,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	}
 #endif
 
-
 #endif
 
 #ifdef	DEBUG
@@ -992,9 +953,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 		return -ENODEV;
 	}
 
-
-
-
 	rc = pci_request_regions(pcid, DEVICE_NAME);
 	if (rc) {
 		printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device\n");
@@ -1014,8 +972,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	printk("After write: value is %x\n", value);
 #endif
 
-
-
 #ifdef IO_MAP
 	pDevice->PortOffset = pDevice->ioaddr;
 #endif
@@ -1054,7 +1010,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	device_print_info(pDevice);
 	pci_set_drvdata(pcid, pDevice);
 	return 0;
-
 }
 
 static void device_print_info(PSDevice pDevice)
@@ -1071,12 +1026,10 @@ static void device_print_info(PSDevice pDevice)
 		(unsigned long)pDevice->ioaddr, (unsigned long)pDevice->PortOffset);
 	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IRQ=%d \n", pDevice->dev->irq);
 #endif
-
 }
 
 static void vt6655_init_info(struct pci_dev *pcid, PSDevice *ppDevice,
 			     PCHIP_INFO pChip_info) {
-
 	PSDevice p;
 
 	memset(*ppDevice, 0, sizeof(DEVICE_INFO));
@@ -1100,7 +1053,6 @@ static void vt6655_init_info(struct pci_dev *pcid, PSDevice *ppDevice,
 }
 
 static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid) {
-
 	u16 pci_cmd;
 	u8  b;
 	unsigned int cis_addr;
@@ -1209,7 +1161,6 @@ static void device_free_info(PSDevice pDevice) {
 static bool device_init_rings(PSDevice pDevice) {
 	void *vir_pool;
 
-
 	/*allocate all RD/TD rings a single pool*/
 	vir_pool = pci_alloc_consistent(pDevice->pcid,
 					pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
@@ -1234,7 +1185,6 @@ static bool device_init_rings(PSDevice pDevice) {
 	pDevice->aRD1Ring = vir_pool +
 		pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
 
-
 	pDevice->rd0_pool_dma = pDevice->pool_dma;
 	pDevice->rd1_pool_dma = pDevice->rd0_pool_dma +
 		pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
@@ -1271,7 +1221,6 @@ static bool device_init_rings(PSDevice pDevice) {
 	pDevice->td1_pool_dma = pDevice->td0_pool_dma +
 		pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);
 
-
 	// vir_pool: pvoid type
 	pDevice->apTD0Rings = vir_pool
 		+ pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)
@@ -1282,11 +1231,9 @@ static bool device_init_rings(PSDevice pDevice) {
 		+ pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc)
 		+ pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);
 
-
 	pDevice->tx1_bufs = pDevice->tx0_bufs +
 		pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;
 
-
 	pDevice->tx_beacon_bufs = pDevice->tx1_bufs +
 		pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;
 
@@ -1296,16 +1243,13 @@ static bool device_init_rings(PSDevice pDevice) {
 	pDevice->tx_bufs_dma1 = pDevice->tx_bufs_dma0 +
 		pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;
 
-
 	pDevice->tx_beacon_dma = pDevice->tx_bufs_dma1 +
 		pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;
 
-
 	return true;
 }
 
 static void device_free_rings(PSDevice pDevice) {
-
 	pci_free_consistent(pDevice->pcid,
 			    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
 			    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
@@ -1349,7 +1293,6 @@ static void device_init_rd0_ring(PSDevice pDevice) {
 	pDevice->pCurrRD[0] = &(pDevice->aRD0Ring[0]);
 }
 
-
 static void device_init_rd1_ring(PSDevice pDevice) {
 	int i;
 	dma_addr_t      curr = pDevice->rd1_pool_dma;
@@ -1374,7 +1317,6 @@ static void device_init_rd1_ring(PSDevice pDevice) {
 	pDevice->pCurrRD[1] = &(pDevice->aRD1Ring[0]);
 }
 
-
 static void device_init_defrag_cb(PSDevice pDevice) {
 	int i;
 	PSDeFragControlBlock pDeF;
@@ -1391,9 +1333,6 @@ static void device_init_defrag_cb(PSDevice pDevice) {
 	pDevice->cbFreeDFCB = pDevice->cbDFCB;
 }
 
-
-
-
 static void device_free_rd0_ring(PSDevice pDevice) {
 	int i;
 
@@ -1408,13 +1347,11 @@ static void device_free_rd0_ring(PSDevice pDevice) {
 
 		kfree((void *)pDesc->pRDInfo);
 	}
-
 }
 
 static void device_free_rd1_ring(PSDevice pDevice) {
 	int i;
 
-
 	for (i = 0; i < pDevice->sOpts.nRxDescs1; i++) {
 		PSRxDesc        pDesc = &(pDevice->aRD1Ring[i]);
 		PDEVICE_RD_INFO  pRDInfo = pDesc->pRDInfo;
@@ -1426,7 +1363,6 @@ static void device_free_rd1_ring(PSDevice pDevice) {
 
 		kfree((void *)pDesc->pRDInfo);
 	}
-
 }
 
 static void device_free_frag_buf(PSDevice pDevice) {
@@ -1434,14 +1370,12 @@ static void device_free_frag_buf(PSDevice pDevice) {
 	int i;
 
 	for (i = 0; i < CB_MAX_RX_FRAG; i++) {
-
 		pDeF = &(pDevice->sRxDFCB[i]);
 
 		if (pDeF->skb)
 			dev_kfree_skb(pDeF->skb);
 
 	}
-
 }
 
 static void device_init_td0_ring(PSDevice pDevice) {
@@ -1466,7 +1400,6 @@ static void device_init_td0_ring(PSDevice pDevice) {
 	if (i > 0)
 		pDevice->apTD0Rings[i-1].next_desc = cpu_to_le32(pDevice->td0_pool_dma);
 	pDevice->apTailTD[0] = pDevice->apCurrTD[0] = &(pDevice->apTD0Rings[0]);
-
 }
 
 static void device_init_td1_ring(PSDevice pDevice) {
@@ -1494,8 +1427,6 @@ static void device_init_td1_ring(PSDevice pDevice) {
 	pDevice->apTailTD[1] = pDevice->apCurrTD[1] = &(pDevice->apTD1Rings[0]);
 }
 
-
-
 static void device_free_td0_ring(PSDevice pDevice) {
 	int i;
 	for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++) {
@@ -1529,18 +1460,14 @@ static void device_free_td1_ring(PSDevice pDevice) {
 
 		kfree((void *)pDesc->pTDInfo);
 	}
-
 }
 
-
-
 /*-----------------------------------------------------------------*/
 
 static int device_rx_srv(PSDevice pDevice, unsigned int uIdx) {
 	PSRxDesc    pRD;
 	int works = 0;
 
-
 	for (pRD = pDevice->pCurrRD[uIdx];
 	     pRD->m_rd0RD0.f1Owner == OWNED_BY_HOST;
 	     pRD = pRD->next) {
@@ -1563,12 +1490,9 @@ static int device_rx_srv(PSDevice pDevice, unsigned int uIdx) {
 	return works;
 }
 
-
 static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
-
 	PDEVICE_RD_INFO pRDInfo = pRD->pRDInfo;
 
-
 	pRDInfo->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
 	if (pRDInfo->skb == NULL)
 		return false;
@@ -1586,10 +1510,7 @@ static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
 	return true;
 }
 
-
-
 bool device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
-
 	pDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
 	if (pDeF->skb == NULL)
 		return false;
@@ -1599,8 +1520,6 @@ bool device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
 	return true;
 }
 
-
-
 static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 	PSTxDesc                 pTD;
 	bool bFull = false;
@@ -1614,9 +1533,7 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 	unsigned int	uNodeIndex;
 	PSMgmtObject             pMgmt = pDevice->pMgmt;
 
-
 	for (pTD = pDevice->apTailTD[uIdx]; pDevice->iTDUsed[uIdx] > 0; pTD = pTD->next) {
-
 		if (pTD->m_td0TD0.f1Owner == OWNED_BY_NIC)
 			break;
 		if (works++ > 15)
@@ -1627,7 +1544,6 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 
 		//Only the status of first TD in the chain is correct
 		if (pTD->m_td1TD1.byTCR & TCR_STP) {
-
 			if ((pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0) {
 				uFIFOHeaderSize = pTD->pTDInfo->dwHeaderLength;
 				uFrameSize = pTD->pTDInfo->dwReqCount - uFIFOHeaderSize;
@@ -1640,7 +1556,6 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 							(unsigned char *)(pTD->pTDInfo->buf + uFIFOHeaderSize),
 							uFrameSize, uIdx);
 
-
 				BSSvUpdateNodeTxCounter(pDevice,
 							byTsr0, byTsr1,
 							(unsigned char *)(pTD->pTDInfo->buf),
@@ -1714,7 +1629,6 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 		}
 	}
 
-
 	if (uIdx == TYPE_AC0DMA) {
 		// RESERV_AC0DMA reserved for relay
 
@@ -1727,15 +1641,12 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 		}
 	}
 
-
 	pDevice->apTailTD[uIdx] = pTD;
 
 	return works;
 }
 
-
 static void device_error(PSDevice pDevice, unsigned short status) {
-
 	if (status & ISR_FETALERR) {
 		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
 			"%s: Hardware fatal error.\n",
@@ -1747,7 +1658,6 @@ static void device_error(PSDevice pDevice, unsigned short status) {
 		MACbShutdown(pDevice->PortOffset);
 		return;
 	}
-
 }
 
 static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc) {
@@ -1768,8 +1678,6 @@ static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc) {
 	pTDInfo->byFlags = 0;
 }
 
-
-
 //PLICE_DEBUG ->
 void	InitRxManagementQueue(PSDevice  pDevice)
 {
@@ -1778,10 +1686,6 @@ void	InitRxManagementQueue(PSDevice  pDevice)
 }
 //PLICE_DEBUG<-
 
-
-
-
-
 //PLICE_DEBUG ->
 int MlmeThread(
 	void *Context)
@@ -1794,7 +1698,6 @@ int MlmeThread(
 	//i = 0;
 #if 1
 	while (1) {
-
 		//down(&pDevice->mlme_semaphore);
 		// pRxMgmtPacket =  DeQueue(pDevice);
 #if 1
@@ -1817,11 +1720,8 @@ int MlmeThread(
 
 #endif
 	return 0;
-
 }
 
-
-
 static int  device_open(struct net_device *dev) {
 	PSDevice pDevice = (PSDevice)netdev_priv(dev);
 	int i;
@@ -1854,7 +1754,6 @@ static int  device_open(struct net_device *dev) {
 	device_init_td1_ring(pDevice);
 //    VNTWIFIvSet11h(pDevice->pMgmt, pDevice->b11hEnable);
 
-
 	if (pDevice->bDiversityRegCtlON) {
 		device_init_diversity_timer(pDevice);
 	}
@@ -1877,13 +1776,8 @@ static int  device_open(struct net_device *dev) {
 	mlme_kill = 1;
 #endif
 
-
-
 	//wait_for_completion(&pDevice->notify);
 
-
-
-
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
 	device_init_registers(pDevice, DEVICE_INIT_COLD);
 	MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
@@ -1935,7 +1829,6 @@ static int  device_open(struct net_device *dev) {
 	return 0;
 }
 
-
 static int  device_close(struct net_device *dev) {
 	PSDevice  pDevice = (PSDevice)netdev_priv(dev);
 	PSMgmtObject     pMgmt = pDevice->pMgmt;
@@ -1990,14 +1883,11 @@ static int  device_close(struct net_device *dev) {
 	return 0;
 }
 
-
-
 static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
 	PSDevice pDevice = netdev_priv(dev);
 	unsigned char *pbMPDU;
 	unsigned int cbMPDULen = 0;
 
-
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211\n");
 	spin_lock_irq(&pDevice->lock);
 
@@ -2022,11 +1912,8 @@ static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
 	spin_unlock_irq(&pDevice->lock);
 
 	return 0;
-
 }
 
-
-
 bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeIndex) {
 	PSMgmtObject    pMgmt = pDevice->pMgmt;
 	PSTxDesc        pHeadTD, pLastTD;
@@ -2040,7 +1927,6 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 	SKeyItem        STempKey;
 //    unsigned char byKeyIndex = 0;
 
-
 	if (pDevice->bStopTx0Pkt == true) {
 		dev_kfree_skb_irq(skb);
 		return false;
@@ -2079,7 +1965,6 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 	}
 	byPktType = (unsigned char)pDevice->byPacketType;
 
-
 	if (pDevice->bFixRate) {
 		if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
 			if (pDevice->uConnectionRate >= RATE_11M) {
@@ -2106,7 +1991,6 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
 
-
 	if (pDevice->wCurrentRate <= RATE_11M) {
 		byPktType = PK_TYPE_11B;
 	} else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
@@ -2169,7 +2053,6 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 
 	MACvTransmit0(pDevice->PortOffset);
 
-
 	return true;
 }
 
@@ -2195,8 +2078,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	unsigned char *pbyBSSID;
 	bool bNodeExist = false;
 
-
-
 	spin_lock_irq(&pDevice->lock);
 	if (pDevice->bLinkPass == false) {
 		dev_kfree_skb_irq(skb);
@@ -2210,7 +2091,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 		return 0;
 	}
 
-
 	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
 		if (pDevice->uAssocCount == 0) {
 			dev_kfree_skb_irq(skb);
@@ -2265,7 +2145,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 
 	pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
 
-
 	memcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)(skb->data), ETH_HLEN);
 	cbFrameBodySize = skb->len - ETH_HLEN;
 	// 802.1H
@@ -2273,7 +2152,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 		cbFrameBodySize += 8;
 	}
 
-
 	if (pDevice->bEncryptionEnable == true) {
 		bNeedEncryption = true;
 		// get Transmit key
@@ -2294,7 +2172,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 					break;
 				}
 			} else if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
-
 				pbyBSSID = pDevice->sTxEthHeader.abyDstAddr;  //TO_DS = 0 and FROM_DS = 0 --> 802.11 MAC Address1
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "IBSS Serach Key: \n");
 				for (ii = 0; ii < 6; ii++)
@@ -2402,7 +2279,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 					  &(pDevice->byTopCCKBasicRate),
 					  &(pDevice->byTopOFDMBasicRate));
 
-
 		}
 	}
 
@@ -2464,7 +2340,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 		}
 	}
 
-
 	vGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,
 			    cbFrameBodySize, TYPE_AC0DMA, pHeadTD,
 			    &pDevice->sTxEthHeader, (unsigned char *)skb->data, pTransmitKey, uNodeIndex,
@@ -2545,7 +2420,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 
 	spin_unlock_irq(&pDevice->lock);
 	return 0;
-
 }
 
 static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
@@ -2561,7 +2435,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 	int             ii = 0;
 //    unsigned char byRSSI;
 
-
 	MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
 
 	if (pDevice->dwIsr == 0)
@@ -2601,7 +2474,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 	// update ISR counter
 	STAvUpdate802_11Counter(&pDevice->s802_11Counter, &pDevice->scStatistic , dwMIBCounter);
 	while (pDevice->dwIsr != 0) {
-
 		STAvUpdateIsrStatCounter(&pDevice->scStatistic, pDevice->dwIsr);
 		MACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);
 
@@ -2613,7 +2485,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 		}
 
 		if (pDevice->byLocalID > REV_ID_VT3253_B1) {
-
 			if (pDevice->dwIsr & ISR_MEASURESTART) {
 				// 802.11h measure start
 				pDevice->byOrgChannel = pDevice->byCurrentCh;
@@ -2743,7 +2614,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 
 			if ((pDevice->eOPMode == OP_MODE_AP) ||
 			    (pDevice->eOPMode == OP_MODE_ADHOC)) {
-
 				MACvOneShotTimer1MicroSec(pDevice->PortOffset,
 							  (pMgmt->wIBSSBeaconPeriod - MAKE_BEACON_RESERVED) << 10);
 			}
@@ -2755,7 +2625,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 		}
 
 		if (pDevice->dwIsr & ISR_BNTX) {
-
 			if (pDevice->eOPMode == OP_MODE_ADHOC) {
 				pDevice->bIsBeaconBufReadySet = false;
 				pDevice->cbBeaconBufReadySetCnt = 0;
@@ -2805,7 +2674,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 			max_count += device_tx_srv(pDevice, TYPE_AC0DMA);
 		}
 		if (pDevice->dwIsr & ISR_SOFTTIMER) {
-
 		}
 		if (pDevice->dwIsr & ISR_SOFTTIMER1) {
 			if (pDevice->eOPMode == OP_MODE_AP) {
@@ -2837,7 +2705,6 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 	return IRQ_RETVAL(handled);
 }
 
-
 static unsigned const ethernet_polynomial = 0x04c11db7U;
 static inline u32 ether_crc(int length, unsigned char *data)
 {
@@ -2950,8 +2817,6 @@ int Config_FileOperation(PSDevice pDevice, bool fwrite, unsigned char *Parameter
 	return result;
 }
 
-
-
 static void device_set_multi(struct net_device *dev) {
 	PSDevice         pDevice = (PSDevice)netdev_priv(dev);
 
@@ -2959,7 +2824,6 @@ static void device_set_multi(struct net_device *dev) {
 	u32              mc_filter[2];
 	struct netdev_hw_addr *ha;
 
-
 	VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
 
 	if (dev->flags & IFF_PROMISC) {         /* Set promiscuous. */
@@ -2997,15 +2861,12 @@ static void device_set_multi(struct net_device *dev) {
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode = %x\n", pDevice->byRxMode);
 }
 
-
 static struct net_device_stats *device_get_stats(struct net_device *dev) {
 	PSDevice pDevice = (PSDevice)netdev_priv(dev);
 
 	return &pDevice->stats;
 }
 
-
-
 static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	PSDevice	        pDevice = (PSDevice)netdev_priv(dev);
 
@@ -3014,14 +2875,12 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	PSMgmtObject pMgmt = pDevice->pMgmt;
 	PSCmdRequest pReq;
 
-
 	if (pMgmt == NULL) {
 		rc = -EFAULT;
 		return rc;
 	}
 
 	switch (cmd) {
-
 	case SIOCGIWNAME:
 		rc = iwctl_giwname(dev, NULL, (char *)&(wrq->u.name), NULL);
 		break;
@@ -3059,7 +2918,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	}
 	break;
 
-
 	// Get current network name (ESSID)
 	case SIOCGIWESSID:
 
@@ -3080,13 +2938,11 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		rc = iwctl_siwap(dev, NULL, &(wrq->u.ap_addr), NULL);
 		break;
 
-
 		// Get current Access Point (BSSID)
 	case SIOCGIWAP:
 		rc = iwctl_giwap(dev, NULL, &(wrq->u.ap_addr), NULL);
 		break;
 
-
 		// Set desired station name
 	case SIOCSIWNICKN:
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN \n");
@@ -3149,8 +3005,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		char abyKey[WLAN_WEP232_KEYLEN];
 
 		if (wrq->u.encoding.pointer) {
-
-
 			if (wrq->u.encoding.length > WLAN_WEP232_KEYLEN) {
 				rc = -E2BIG;
 				break;
@@ -3230,13 +3084,11 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		rc = iwctl_giwpower(dev, NULL, &(wrq->u.power), NULL);
 		break;
 
-
 	case SIOCSIWPOWER:
 
 		rc = iwctl_siwpower(dev, NULL, &(wrq->u.power), NULL);
 		break;
 
-
 	case SIOCGIWSENS:
 
 		rc = iwctl_giwsens(dev, NULL, &(wrq->u.sens), NULL);
@@ -3263,7 +3115,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	}
 	break;
 
-
 #ifdef WIRELESS_SPY
 	// Set the spy list
 	case SIOCSIWSPY:
@@ -3296,7 +3147,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 */
 		break;
 
-
 //2008-0409-07, <Add> by Einsn Liu
 #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 	case SIOCSIWAUTH:
@@ -3390,7 +3240,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 	case IOCTL_CMD_HOSTAPD:
 
-
 		rc = vt6655_hostap_ioctl(pDevice, &wrq->u.data);
 		break;
 
@@ -3407,7 +3256,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		rc = -EOPNOTSUPP;
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Ioctl command not support..%x\n", cmd);
 
-
 	}
 
 	if (pDevice->bCommit) {
@@ -3437,7 +3285,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	return rc;
 }
 
-
 static int ethtool_ioctl(struct net_device *dev, void *useraddr)
 {
 	u32 ethcmd;
@@ -3479,7 +3326,6 @@ static int __init vt6655_init_module(void)
 {
 	int ret;
 
-
 //    ret=pci_module_init(&device_driver);
 	//ret = pcie_port_service_register(&device_driver);
 	ret = pci_register_driver(&device_driver);
@@ -3493,19 +3339,15 @@ static int __init vt6655_init_module(void)
 
 static void __exit vt6655_cleanup_module(void)
 {
-
-
 #ifdef CONFIG_PM
 	unregister_reboot_notifier(&device_notifier);
 #endif
 	pci_unregister_driver(&device_driver);
-
 }
 
 module_init(vt6655_init_module);
 module_exit(vt6655_cleanup_module);
 
-
 #ifdef CONFIG_PM
 static int
 device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
@@ -3560,7 +3402,6 @@ viawget_resume(struct pci_dev *pcid)
 	PSMgmtObject  pMgmt = pDevice->pMgmt;
 	int power_status;   // to silence the compiler
 
-
 	power_status = pci_set_power_state(pcid, 0);
 	power_status = pci_enable_wake(pcid, 0, 0);
 	pci_restore_state(pcid);
@@ -3591,7 +3432,3 @@ viawget_resume(struct pci_dev *pcid)
 }
 
 #endif
-
-
-
-

commit a7307538805f8a30c25b6f5b9566ab21d8ab7515
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 20:55:39 2013 -0700

    staging: vt6655: Remove commented out if()s
    
    Commented out code is just noise.  Remove them.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index b6fb8407be94..143d050a5dfb 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -593,7 +593,6 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 				pDevice->byRxAntennaMode = ANT_B;
 			// chester for antenna
 			byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
-			//  if (pDevice->bDiversityRegCtlON)
 			if ((byValue1 & 0x08) == 0)
 				pDevice->bDiversityEnable = false;//SROMbyReadEmbedded(pDevice->PortOffset, 0x50);
 			else
@@ -1885,8 +1884,6 @@ static int  device_open(struct net_device *dev) {
 
 
 
-	// if ((SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RADIOCTL)&0x06)==0x04)
-	//    return -ENOMEM;
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
 	device_init_registers(pDevice, DEVICE_INIT_COLD);
 	MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
@@ -2468,12 +2465,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	}
 
 
-#ifdef	PLICE_DEBUG
-	//if (skb->len == 98)
-	//{
-	//	printk("ping:len is %d\n");
-	//}
-#endif
 	vGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,
 			    cbFrameBodySize, TYPE_AC0DMA, pHeadTD,
 			    &pDevice->sTxEthHeader, (unsigned char *)skb->data, pTransmitKey, uNodeIndex,

commit 5e0cc8a231be82b0ec44cdf2a406b1a97dd3c971
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 20:55:37 2013 -0700

    staging: vt6655: Convert to kernel brace style
    
    Move braces around to be more kernel like.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index dcc639f44690..b6fb8407be94 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -631,28 +631,24 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 				pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0;
 				pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0B;
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Init Zone Type :USA\n");
-			}
-			else if ((zonetype == 1) &&
+			} else if ((zonetype == 1) &&
 				 (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x01)) {   //for Japan
 				pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x01;
 				pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
-			}
-			else if ((zonetype == 2) &&
+			} else if ((zonetype == 2) &&
 				 (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x02)) {   //for Europe
 				pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x02;
 				pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Init Zone Type :Europe\n");
 			}
 
-			else
-			{
+			else {
 				if (zonetype != pDevice->abyEEPROM[EEP_OFS_ZONETYPE])
 					printk("zonetype in file[%02x] mismatch with in EEPROM[%02x]\n", zonetype, pDevice->abyEEPROM[EEP_OFS_ZONETYPE]);
 				else
 					printk("Read Zonetype file success,use default zonetype setting[%02x]\n", zonetype);
 			}
-		}
-		else
+		} else
 			printk("Read Zonetype file fail,use default zonetype setting[%02x]\n", SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ZONETYPE));
 
 		// Get RFType
@@ -779,8 +775,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 		}
 		if ((pDevice->bRadioControlOff == true)) {
 			CARDbRadioPowerOff(pDevice);
-		}
-		else  CARDbRadioPowerOn(pDevice);
+		} else  CARDbRadioPowerOn(pDevice);
 #else
 		if (((pDevice->byGPIO & GPIO0_DATA) && !(pDevice->byRadioCtl & EEP_RADIOCTL_INV)) ||
 		    (!(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV))) {
@@ -958,13 +953,11 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 			PCI_BASE_ADDRESS_4,
 			PCI_BASE_ADDRESS_5,
 			0};
-		for (i = 0; address[i]; i++)
-		{
+		for (i = 0; address[i]; i++) {
 			//pci_write_config_dword(pcid,address[i], 0xFFFFFFFF);
 			pci_read_config_dword(pcid, address[i], &bar);
 			printk("bar %d is %x\n", i, bar);
-			if (!bar)
-			{
+			if (!bar) {
 				printk("bar %d not implemented\n", i);
 				continue;
 			}
@@ -975,9 +968,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 				len = len & ~(len - 1);
 
 				printk("IO space:  len in IO %x, BAR %d\n", len, i);
-			}
-			else
-			{
+			} else {
 				len = bar & 0xFFFFFFF0;
 				len = ~len + 1;
 
@@ -1056,8 +1047,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 	dev->wireless_handlers = (struct iw_handler_def *)&iwctl_handler_def;
 
 	rc = register_netdev(dev);
-	if (rc)
-	{
+	if (rc) {
 		printk(KERN_ERR DEVICE_NAME " Failed to register netdev\n");
 		device_free_info(pDevice);
 		return -ENODEV;
@@ -1094,8 +1084,7 @@ static void vt6655_init_info(struct pci_dev *pcid, PSDevice *ppDevice,
 
 	if (pDevice_Infos == NULL) {
 		pDevice_Infos = *ppDevice;
-	}
-	else {
+	} else {
 		for (p = pDevice_Infos; p->next != NULL; p = p->next)
 			do {} while (0);
 		p->next = *ppDevice;
@@ -1154,20 +1143,15 @@ static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid) {
 	//pci_write_config_word(pcid,PCI_MAX_LAT,max_lat);
 	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
 
-	for (ii = 0; ii < 0xFF; ii++)
-	{
+	for (ii = 0; ii < 0xFF; ii++) {
 		pci_read_config_byte(pcid, ii, &value);
 		pci_config[ii] = value;
 	}
-	for (ii = 0, j = 1; ii < 0x100; ii++, j++)
-	{
-		if (j % 16 == 0)
-		{
+	for (ii = 0, j = 1; ii < 0x100; ii++, j++) {
+		if (j % 16 == 0) {
 			printk("%x:", pci_config[ii]);
 			printk("\n");
-		}
-		else
-		{
+		} else {
 			printk("%x:", pci_config[ii]);
 		}
 	}
@@ -1199,8 +1183,7 @@ static void device_free_info(PSDevice pDevice) {
 			pDevice_Infos = ptr->next;
 		else
 			ptr->prev->next = ptr->next;
-	}
-	else {
+	} else {
 		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "info struct not found\n");
 		return;
 	}
@@ -1675,8 +1658,7 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 					}
 					pStats->tx_packets++;
 					pStats->tx_bytes += pTD->pTDInfo->skb->len;
-				}
-				else {
+				} else {
 					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Tx[%d] dropped & tsr1[%02X] tsr0[%02X].\n",
 						(int)uIdx, byTsr1, byTsr0);
 					pStats->tx_errors++;
@@ -1812,15 +1794,13 @@ int MlmeThread(
 
 	//i = 0;
 #if 1
-	while (1)
-	{
+	while (1) {
 
 		//down(&pDevice->mlme_semaphore);
 		// pRxMgmtPacket =  DeQueue(pDevice);
 #if 1
 		spin_lock_irq(&pDevice->lock);
-		while (pDevice->rxManeQueue.packet_num != 0)
-		{
+		while (pDevice->rxManeQueue.packet_num != 0) {
 			pRxMgmtPacket = DeQueue(pDevice);
 			//pDevice;
 			//DequeueManageObject(pDevice->FirstRecvMngList, pDevice->LastRecvMngList);
@@ -1948,8 +1928,7 @@ static int  device_open(struct net_device *dev) {
 
 	if (pDevice->pMgmt->eConfigMode == WMAC_CONFIG_AP) {
 		bScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);
-	}
-	else {
+	} else {
 		bScheduleCommand((void *)pDevice, WLAN_CMD_BSSID_SCAN, NULL);
 		bScheduleCommand((void *)pDevice, WLAN_CMD_SSID, NULL);
 	}
@@ -2117,16 +2096,14 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 			else
 				pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
 		}
-	}
-	else {
+	} else {
 		pDevice->wCurrentRate = pDevice->pMgmt->sNodeDBTable[uNodeIndex].wTxDataRate;
 	}
 
 	//preamble type
 	if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {
 		pDevice->byPreambleType = pDevice->byShortPreamble;
-	}
-	else {
+	} else {
 		pDevice->byPreambleType = PREAMBLE_LONG;
 	}
 
@@ -2337,8 +2314,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 				pTransmitKey = NULL;
 				if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
 					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
-				}
-				else
+				} else
 					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "NOT IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
 			} else {
 				bTKIP_UseGTK = true;
@@ -2407,8 +2383,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 		pDevice->byACKRate = (unsigned char) pDevice->wCurrentRate;
 		pDevice->byTopCCKBasicRate = RATE_1M;
 		pDevice->byTopOFDMBasicRate = RATE_6M;
-	}
-	else {
+	} else {
 		//auto rate
 		if (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {
 			if (pDevice->eCurrentPHYType != PHY_TYPE_11A) {
@@ -2422,8 +2397,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 				pDevice->byTopCCKBasicRate = RATE_1M;
 				pDevice->byTopOFDMBasicRate = RATE_6M;
 			}
-		}
-		else {
+		} else {
 			VNTWIFIvGetTxRate(pDevice->pMgmt,
 					  pDevice->sTxEthHeader.abyDstAddr,
 					  &(pDevice->wCurrentRate),
@@ -2461,12 +2435,10 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 			if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
 				if (pTransmitKey == NULL) {
 					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Don't Find TX KEY\n");
-				}
-				else {
+				} else {
 					if (bTKIP_UseGTK == true) {
 						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "error: KEY is GTK!!~~\n");
-					}
-					else {
+					} else {
 						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
 						bNeedEncryption = true;
 					}
@@ -2485,8 +2457,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 					bNeedEncryption = true;
 				}
 			}
-		}
-		else {
+		} else {
 			if (pTransmitKey == NULL) {
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "return no tx key\n");
 				dev_kfree_skb_irq(skb);
@@ -2541,12 +2512,9 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 
 	pDevice->apCurrTD[TYPE_AC0DMA] = pHeadTD;
 //#ifdef	PLICE_DEBUG
-	if (pDevice->bFixRate)
-	{
+	if (pDevice->bFixRate) {
 		printk("FixRate:Rate is %d,TxPower is %d\n", pDevice->wCurrentRate, pDevice->byCurPwr);
-	}
-	else
-	{
+	} else {
 	}
 //#endif
 
@@ -2632,8 +2600,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 	VNSvInPortB(pDevice->PortOffset + MAC_REG_PAGE1SEL, &byOrgPageSel);
 	if (byOrgPageSel == 1) {
 		MACvSelectPage0(pDevice->PortOffset);
-	}
-	else
+	} else
 		byOrgPageSel = 0;
 
 	MACvReadMIBCounter(pDevice->PortOffset, &dwMIBCounter);
@@ -2807,8 +2774,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 				if (pMgmt->byDTIMCount > 0) {
 					pMgmt->byDTIMCount--;
 					pMgmt->sNodeDBTable[0].bRxPSPoll = false;
-				}
-				else {
+				} else {
 					if (pMgmt->byDTIMCount == 0) {
 						// check if mutltcast tx bufferring
 						pMgmt->byDTIMCount = pMgmt->byDTIMPeriod - 1;
@@ -2967,14 +2933,11 @@ int Config_FileOperation(PSDevice pDevice, bool fwrite, unsigned char *Parameter
 
 	if (memcmp(tmpbuffer, "USA", 3) == 0) {
 		result = ZoneType_USA;
-	}
-	else if (memcmp(tmpbuffer, "JAPAN", 5) == 0) {
+	} else if (memcmp(tmpbuffer, "JAPAN", 5) == 0) {
 		result = ZoneType_Japan;
-	}
-	else if (memcmp(tmpbuffer, "EUROPE", 5) == 0) {
+	} else if (memcmp(tmpbuffer, "EUROPE", 5) == 0) {
 		result = ZoneType_Europe;
-	}
-	else {
+	} else {
 		result = -1;
 		printk("Unknown Zonetype[%s]?\n", tmpbuffer);
 	}
@@ -3012,16 +2975,14 @@ static void device_set_multi(struct net_device *dev) {
 		DBG_PRT(MSG_LEVEL_ERR, KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
 		/* Unconditionally log net taps. */
 		pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);
-	}
-	else if ((netdev_mc_count(dev) > pDevice->multicast_limit)
+	} else if ((netdev_mc_count(dev) > pDevice->multicast_limit)
 		 ||  (dev->flags & IFF_ALLMULTI)) {
 		MACvSelectPage1(pDevice->PortOffset);
 		VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, 0xffffffff);
 		VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0 + 4, 0xffffffff);
 		MACvSelectPage0(pDevice->PortOffset);
 		pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-	}
-	else {
+	} else {
 		memset(mc_filter, 0, sizeof(mc_filter));
 		netdev_for_each_mc_addr(ha, dev) {
 			int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
@@ -3193,8 +3154,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		break;
 
 		// Set WEP keys and mode
-	case SIOCSIWENCODE:
-	{
+	case SIOCSIWENCODE: {
 		char abyKey[WLAN_WEP232_KEYLEN];
 
 		if (wrq->u.encoding.pointer) {
@@ -3296,8 +3256,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		rc = -EOPNOTSUPP;
 		break;
 
-	case SIOCGIWAPLIST:
-	{
+	case SIOCGIWAPLIST: {
 		char buffer[IW_MAX_AP * (sizeof(struct sockaddr) + sizeof(struct iw_quality))];
 
 		if (wrq->u.data.pointer) {
@@ -3369,8 +3328,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		rc = iwctl_giwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
 		break;
 
-	case SIOCSIWENCODEEXT:
-	{
+	case SIOCSIWENCODEEXT: {
 		char extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT \n");
 		if (wrq->u.encoding.pointer) {
@@ -3467,8 +3425,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 			spin_lock_irq(&pDevice->lock);
 			bScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);
 			spin_unlock_irq(&pDevice->lock);
-		}
-		else {
+		} else {
 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Commit the settings\n");
 			spin_lock_irq(&pDevice->lock);
 			pDevice->bLinkPass = false;
@@ -3626,8 +3583,7 @@ viawget_resume(struct pci_dev *pcid)
 			if (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
 				// In Adhoc, BSS state set back to started.
 				pMgmt->eCurrState = WMAC_STATE_STARTED;
-			}
-			else {
+			} else {
 				pMgmt->eCurrMode = WMAC_MODE_STANDBY;
 				pMgmt->eCurrState = WMAC_STATE_IDLE;
 			}

commit f2046f93db0918f99875853772142143590ba0c6
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 20:55:36 2013 -0700

    staging: vt6655: Remove commented out printks
    
    These are just noise in the code so remove them.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 10d675e9e084..dcc639f44690 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -570,16 +570,11 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 			pDevice->bTxRxAntInv = true;
 		else
 			pDevice->bTxRxAntInv = false;
-#ifdef	PLICE_DEBUG
-		//printk("init_register:TxRxAntInv is %d,byValue is %d\n",pDevice->bTxRxAntInv,byValue);
-#endif
 
 		byValue &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
 		if (byValue == 0) // if not set default is All
 			byValue = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
-#ifdef	PLICE_DEBUG
-		//printk("init_register:byValue is %d\n",byValue);
-#endif
+
 		pDevice->ulDiversityNValue = 100*260;//100*SROMbyReadEmbedded(pDevice->PortOffset, 0x51);
 		pDevice->ulDiversityMValue = 100*16;//SROMbyReadEmbedded(pDevice->PortOffset, 0x52);
 		pDevice->byTMax = 1;//SROMbyReadEmbedded(pDevice->PortOffset, 0x53);
@@ -603,9 +598,6 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 				pDevice->bDiversityEnable = false;//SROMbyReadEmbedded(pDevice->PortOffset, 0x50);
 			else
 				pDevice->bDiversityEnable = true;
-#ifdef	PLICE_DEBUG
-			//printk("aux |main antenna: RxAntennaMode is %d\n",pDevice->byRxAntennaMode);
-#endif
 		} else  {
 			pDevice->bDiversityEnable = false;
 			pDevice->byAntennaCount = 1;
@@ -625,9 +617,6 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 					pDevice->byRxAntennaMode = ANT_B;
 			}
 		}
-#ifdef	PLICE_DEBUG
-		//printk("init registers: TxAntennaMode is %d\n",pDevice->byTxAntennaMode);
-#endif
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",
 			pDevice->bDiversityEnable, (int)pDevice->ulDiversityNValue, (int)pDevice->ulDiversityMValue, pDevice->byTMax, pDevice->byTMax2);
 
@@ -692,7 +681,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 		//byCCKPwrdBm = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_CCK_PWR_dBm);
 
 		//byOFDMPwrdBm = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_OFDM_PWR_dBm);
-//printk("CCKPwrdBm is 0x%x,byOFDMPwrdBm is 0x%x\n",byCCKPwrdBm,byOFDMPwrdBm);
+
 		// Load power Table
 
 
@@ -756,9 +745,6 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 			pDevice->byBBVGANew = pDevice->byBBVGACurrent;
 			BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
 		}
-#ifdef	PLICE_DEBUG
-		//printk("init registers:RxAntennaMode is %x,TxAntennaMode is %x\n",pDevice->byRxAntennaMode,pDevice->byTxAntennaMode);
-#endif
 		BBvSetRxAntennaMode(pDevice->PortOffset, pDevice->byRxAntennaMode);
 		BBvSetTxAntennaMode(pDevice->PortOffset, pDevice->byTxAntennaMode);
 
@@ -1162,13 +1148,11 @@ static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid) {
 
 #ifdef	PLICE_DEBUG
 	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
-	//printk("max lat is %x,SubSystemID is %x\n",max_lat,pDevice->SubSystemID);
 	//for (ii=0;ii<0xFF;ii++)
 	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
 	//max_lat  = 0x20;
 	//pci_write_config_word(pcid,PCI_MAX_LAT,max_lat);
 	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
-	//printk("max lat is %x\n",max_lat);
 
 	for (ii = 0; ii < 0xFF; ii++)
 	{
@@ -1604,9 +1588,6 @@ static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
 
 
 	pRDInfo->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-#ifdef	PLICE_DEBUG
-	//printk("device_alloc_rx_buf:skb is %x\n",pRDInfo->skb);
-#endif
 	if (pRDInfo->skb == NULL)
 		return false;
 	ASSERT(pRDInfo->skb);
@@ -1828,15 +1809,12 @@ int MlmeThread(
 	PSRxMgmtPacket			pRxMgmtPacket;
 	// int i;
 	//complete(&pDevice->notify);
-//printk("Enter MngWorkItem,Queue packet num is %d\n",pDevice->rxManeQueue.packet_num);
 
-	//printk("Enter MlmeThread,packet _num is %d\n",pDevice->rxManeQueue.packet_num);
 	//i = 0;
 #if 1
 	while (1)
 	{
 
-		//printk("DDDD\n");
 		//down(&pDevice->mlme_semaphore);
 		// pRxMgmtPacket =  DeQueue(pDevice);
 #if 1
@@ -1847,20 +1825,15 @@ int MlmeThread(
 			//pDevice;
 			//DequeueManageObject(pDevice->FirstRecvMngList, pDevice->LastRecvMngList);
 			vMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);
-			//printk("packet_num is %d\n",pDevice->rxManeQueue.packet_num);
-
 		}
 		spin_unlock_irq(&pDevice->lock);
 		if (mlme_kill == 0)
 			break;
 		//udelay(200);
 #endif
-		//printk("Before schedule thread jiffies is %x\n",jiffies);
 		schedule();
-		//printk("after schedule thread jiffies is %x\n",jiffies);
 		if (mlme_kill == 0)
 			break;
-		//printk("i is %d\n",i);
 	}
 
 #endif
@@ -1885,7 +1858,7 @@ static int  device_open(struct net_device *dev) {
 	i = request_irq(pDevice->pcid->irq, &device_intr, IRQF_SHARED, dev->name, dev);
 	if (i)
 		return i;
-	//printk("DEBUG1\n");
+
 #ifdef WPA_SM_Transtatus
 	memset(wpa_Result.ifname, 0, sizeof(wpa_Result.ifname));
 	wpa_Result.proto = 0;
@@ -1927,8 +1900,6 @@ static int  device_open(struct net_device *dev) {
 
 
 
-	//printk("thread id is %d\n",pDevice->MLMEThr_pid);
-	//printk("Create thread time is %x\n",jiffies);
 	//wait_for_completion(&pDevice->notify);
 
 
@@ -1972,9 +1943,6 @@ static int  device_open(struct net_device *dev) {
 		pDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;
 	}
 
-//printk("DEBUG2\n");
-
-
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call MACvIntEnable\n");
 	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
 
@@ -2579,7 +2547,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 	}
 	else
 	{
-		//printk("Auto Rate:Rate is %d,TxPower is %d\n",pDevice->wCurrentRate,pDevice->byCurPwr);
 	}
 //#endif
 

commit 915006cddc7979263a0fe1c6cb1369962bfe68f5
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 10:44:47 2013 -0700

    staging:vt6655:device_main: Whitespace cleanups
    
    Neatening only.
    git diff -w shows no differences.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 453c83d7fe8c..10d675e9e084 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -98,52 +98,52 @@ MODULE_AUTHOR("VIA Networking Technologies, Inc., <lyndonchen@vntek.com.tw>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("VIA Networking Solomon-A/B/G Wireless LAN Adapter Driver");
 
-	static int mlme_kill;
-	//static  struct task_struct * mlme_task;
+static int mlme_kill;
+//static  struct task_struct * mlme_task;
 
-#define DEVICE_PARAM(N,D)
+#define DEVICE_PARAM(N, D)
 /*
-        static const int N[MAX_UINTS]=OPTION_DEFAULT;\
-        MODULE_PARM(N, "1-" __MODULE_STRING(MAX_UINTS) "i");\
-        MODULE_PARM_DESC(N, D);
+  static const int N[MAX_UINTS]=OPTION_DEFAULT;\
+  MODULE_PARM(N, "1-" __MODULE_STRING(MAX_UINTS) "i");\
+  MODULE_PARM_DESC(N, D);
 */
 
 #define RX_DESC_MIN0     16
 #define RX_DESC_MAX0     128
 #define RX_DESC_DEF0     32
-DEVICE_PARAM(RxDescriptors0,"Number of receive descriptors0");
+DEVICE_PARAM(RxDescriptors0, "Number of receive descriptors0");
 
 #define RX_DESC_MIN1     16
 #define RX_DESC_MAX1     128
 #define RX_DESC_DEF1     32
-DEVICE_PARAM(RxDescriptors1,"Number of receive descriptors1");
+DEVICE_PARAM(RxDescriptors1, "Number of receive descriptors1");
 
 #define TX_DESC_MIN0     16
 #define TX_DESC_MAX0     128
 #define TX_DESC_DEF0     32
-DEVICE_PARAM(TxDescriptors0,"Number of transmit descriptors0");
+DEVICE_PARAM(TxDescriptors0, "Number of transmit descriptors0");
 
 #define TX_DESC_MIN1     16
 #define TX_DESC_MAX1     128
 #define TX_DESC_DEF1     64
-DEVICE_PARAM(TxDescriptors1,"Number of transmit descriptors1");
+DEVICE_PARAM(TxDescriptors1, "Number of transmit descriptors1");
 
 
 #define IP_ALIG_DEF     0
 /* IP_byte_align[] is used for IP header unsigned long byte aligned
    0: indicate the IP header won't be unsigned long byte aligned.(Default) .
    1: indicate the IP header will be unsigned long byte aligned.
-      In some environment, the IP header should be unsigned long byte aligned,
-      or the packet will be droped when we receive it. (eg: IPVS)
+   In some environment, the IP header should be unsigned long byte aligned,
+   or the packet will be droped when we receive it. (eg: IPVS)
 */
-DEVICE_PARAM(IP_byte_align,"Enable IP header dword aligned");
+DEVICE_PARAM(IP_byte_align, "Enable IP header dword aligned");
 
 
 #define INT_WORKS_DEF   20
 #define INT_WORKS_MIN   10
 #define INT_WORKS_MAX   64
 
-DEVICE_PARAM(int_works,"Number of packets per interrupt services");
+DEVICE_PARAM(int_works, "Number of packets per interrupt services");
 
 #define CHANNEL_MIN     1
 #define CHANNEL_MAX     14
@@ -190,10 +190,10 @@ DEVICE_PARAM(FragThreshold, "Fragmentation threshold");
    7: indicate 18 Mbps  0x24
    8: indicate 24 Mbps  0x30
    9: indicate 36 Mbps  0x48
-  10: indicate 48 Mbps  0x60
-  11: indicate 54 Mbps  0x6c
-  12: indicate 72 Mbps  0x90
-  13: indicate auto rate
+   10: indicate 48 Mbps  0x60
+   11: indicate 54 Mbps  0x6c
+   12: indicate 72 Mbps  0x90
+   13: indicate auto rate
 */
 
 DEVICE_PARAM(ConnectionRate, "Connection data rate");
@@ -271,14 +271,14 @@ DEVICE_PARAM(bDiversityANTEnable, "ANT diversity mode");
 //
 
 
-static int          device_nics             =0;
-static PSDevice     pDevice_Infos           =NULL;
+static int          device_nics             = 0;
+static PSDevice     pDevice_Infos           = NULL;
 static struct net_device *root_device_dev = NULL;
 
-static CHIP_INFO chip_info_table[]= {
-    { VT3253,       "VIA Networking Solomon-A/B/G Wireless LAN Adapter ",
-        256, 1,     DEVICE_FLAGS_IP_ALIGN|DEVICE_FLAGS_TX_ALIGN },
-    {0,NULL}
+static CHIP_INFO chip_info_table[] = {
+	{ VT3253,       "VIA Networking Solomon-A/B/G Wireless LAN Adapter ",
+	  256, 1,     DEVICE_FLAGS_IP_ALIGN|DEVICE_FLAGS_TX_ALIGN },
+	{0, NULL}
 };
 
 DEFINE_PCI_DEVICE_TABLE(vt6655_pci_id_table) = {
@@ -290,15 +290,15 @@ DEFINE_PCI_DEVICE_TABLE(vt6655_pci_id_table) = {
 
 
 static int  vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent);
-static void vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice, PCHIP_INFO);
+static void vt6655_init_info(struct pci_dev *pcid, PSDevice *ppDevice, PCHIP_INFO);
 static void device_free_info(PSDevice pDevice);
-static bool device_get_pci_info(PSDevice, struct pci_dev* pcid);
+static bool device_get_pci_info(PSDevice, struct pci_dev *pcid);
 static void device_print_info(PSDevice pDevice);
 static struct net_device_stats *device_get_stats(struct net_device *dev);
 static void device_init_diversity_timer(PSDevice pDevice);
 static int  device_open(struct net_device *dev);
 static int  device_xmit(struct sk_buff *skb, struct net_device *dev);
-static  irqreturn_t  device_intr(int irq,  void*dev_instance);
+static  irqreturn_t  device_intr(int irq,  void *dev_instance);
 static void device_set_multi(struct net_device *dev);
 static int  device_close(struct net_device *dev);
 static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
@@ -338,7 +338,7 @@ static void device_free_rd1_ring(PSDevice pDevice);
 static void device_free_rings(PSDevice pDevice);
 static void device_free_frag_buf(PSDevice pDevice);
 static int Config_FileGetParameter(unsigned char *string,
-		unsigned char *dest, unsigned char *source);
+				   unsigned char *dest, unsigned char *source);
 
 
 /*---------------------  Export Variables  --------------------------*/
@@ -347,7 +347,7 @@ static int Config_FileGetParameter(unsigned char *string,
 
 
 
-static char* get_chip_name(int chip_id)
+static char *get_chip_name(int chip_id)
 {
 	int i;
 	for (i = 0; chip_info_table[i].name != NULL; i++)
@@ -367,38 +367,38 @@ static void vt6655_remove(struct pci_dev *pcid)
 }
 
 /*
-static void
-device_set_int_opt(int *opt, int val, int min, int max, int def,char* name,char* devname) {
-    if (val==-1)
-        *opt=def;
-    else if (val<min || val>max) {
-        DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: the value of parameter %s is invalid, the valid range is (%d-%d)\n" ,
-            devname,name, min,max);
-        *opt=def;
-    } else {
-        DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: set value of parameter %s to %d\n",
-            devname, name, val);
-        *opt=val;
-    }
-}
+  static void
+  device_set_int_opt(int *opt, int val, int min, int max, int def,char* name,char* devname) {
+  if (val==-1)
+  *opt=def;
+  else if (val<min || val>max) {
+  DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: the value of parameter %s is invalid, the valid range is (%d-%d)\n" ,
+  devname,name, min,max);
+  *opt=def;
+  } else {
+  DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: set value of parameter %s to %d\n",
+  devname, name, val);
+  *opt=val;
+  }
+  }
 
-static void
-device_set_bool_opt(unsigned int *opt, int val,bool def,u32 flag, char* name,char* devname) {
-    (*opt)&=(~flag);
-    if (val==-1)
-        *opt|=(def ? flag : 0);
-    else if (val<0 || val>1) {
-        DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE
-            "%s: the value of parameter %s is invalid, the valid range is (0-1)\n",devname,name);
-        *opt|=(def ? flag : 0);
-    } else {
-        DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: set parameter %s to %s\n",
-            devname,name , val ? "true" : "false");
-        *opt|=(val ? flag : 0);
-    }
-}
+  static void
+  device_set_bool_opt(unsigned int *opt, int val,bool def,u32 flag, char* name,char* devname) {
+  (*opt)&=(~flag);
+  if (val==-1)
+  *opt|=(def ? flag : 0);
+  else if (val<0 || val>1) {
+  DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE
+  "%s: the value of parameter %s is invalid, the valid range is (0-1)\n",devname,name);
+  *opt|=(def ? flag : 0);
+  } else {
+  DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: set parameter %s to %s\n",
+  devname,name , val ? "true" : "false");
+  *opt|=(val ? flag : 0);
+  }
+  }
 */
-static void device_get_options(PSDevice pDevice, int index, char* devname)
+static void device_get_options(PSDevice pDevice, int index, char *devname)
 {
 	POPTIONS pOpts = &(pDevice->sOpts);
 
@@ -426,91 +426,91 @@ static void device_get_options(PSDevice pDevice, int index, char* devname)
 static void
 device_set_options(PSDevice pDevice) {
 
-    unsigned char abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-    unsigned char abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
-    unsigned char abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
-
-
-    memcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);
-    memcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);
-    memcpy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel, ETH_ALEN);
-
-    pDevice->uChannel = pDevice->sOpts.channel_num;
-    pDevice->wRTSThreshold = pDevice->sOpts.rts_thresh;
-    pDevice->wFragmentationThreshold = pDevice->sOpts.frag_thresh;
-    pDevice->byShortRetryLimit = pDevice->sOpts.short_retry;
-    pDevice->byLongRetryLimit = pDevice->sOpts.long_retry;
-    pDevice->wMaxTransmitMSDULifetime = DEFAULT_MSDU_LIFETIME;
-    pDevice->byShortPreamble = (pDevice->sOpts.flags & DEVICE_FLAGS_PREAMBLE_TYPE) ? 1 : 0;
-    pDevice->byOpMode = (pDevice->sOpts.flags & DEVICE_FLAGS_OP_MODE) ? 1 : 0;
-    pDevice->ePSMode = (pDevice->sOpts.flags & DEVICE_FLAGS_PS_MODE) ? 1 : 0;
-    pDevice->b11hEnable = (pDevice->sOpts.flags & DEVICE_FLAGS_80211h_MODE) ? 1 : 0;
-    pDevice->bDiversityRegCtlON = (pDevice->sOpts.flags & DEVICE_FLAGS_DiversityANT) ? 1 : 0;
-    pDevice->uConnectionRate = pDevice->sOpts.data_rate;
-    if (pDevice->uConnectionRate < RATE_AUTO) pDevice->bFixRate = true;
-    pDevice->byBBType = pDevice->sOpts.bbp_type;
-    pDevice->byPacketType = pDevice->byBBType;
+	unsigned char abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	unsigned char abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
+	unsigned char abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
+
+
+	memcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);
+	memcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);
+	memcpy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel, ETH_ALEN);
+
+	pDevice->uChannel = pDevice->sOpts.channel_num;
+	pDevice->wRTSThreshold = pDevice->sOpts.rts_thresh;
+	pDevice->wFragmentationThreshold = pDevice->sOpts.frag_thresh;
+	pDevice->byShortRetryLimit = pDevice->sOpts.short_retry;
+	pDevice->byLongRetryLimit = pDevice->sOpts.long_retry;
+	pDevice->wMaxTransmitMSDULifetime = DEFAULT_MSDU_LIFETIME;
+	pDevice->byShortPreamble = (pDevice->sOpts.flags & DEVICE_FLAGS_PREAMBLE_TYPE) ? 1 : 0;
+	pDevice->byOpMode = (pDevice->sOpts.flags & DEVICE_FLAGS_OP_MODE) ? 1 : 0;
+	pDevice->ePSMode = (pDevice->sOpts.flags & DEVICE_FLAGS_PS_MODE) ? 1 : 0;
+	pDevice->b11hEnable = (pDevice->sOpts.flags & DEVICE_FLAGS_80211h_MODE) ? 1 : 0;
+	pDevice->bDiversityRegCtlON = (pDevice->sOpts.flags & DEVICE_FLAGS_DiversityANT) ? 1 : 0;
+	pDevice->uConnectionRate = pDevice->sOpts.data_rate;
+	if (pDevice->uConnectionRate < RATE_AUTO) pDevice->bFixRate = true;
+	pDevice->byBBType = pDevice->sOpts.bbp_type;
+	pDevice->byPacketType = pDevice->byBBType;
 
 //PLICE_DEBUG->
 	pDevice->byAutoFBCtrl = AUTO_FB_0;
 	//pDevice->byAutoFBCtrl = AUTO_FB_1;
 //PLICE_DEBUG<-
-pDevice->bUpdateBBVGA = true;
-    pDevice->byFOETuning = 0;
-    pDevice->wCTSDuration = 0;
-    pDevice->byPreambleType = 0;
-
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uChannel= %d\n",(int)pDevice->uChannel);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byOpMode= %d\n",(int)pDevice->byOpMode);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" ePSMode= %d\n",(int)pDevice->ePSMode);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" wRTSThreshold= %d\n",(int)pDevice->wRTSThreshold);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortRetryLimit= %d\n",(int)pDevice->byShortRetryLimit);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byLongRetryLimit= %d\n",(int)pDevice->byLongRetryLimit);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byPreambleType= %d\n",(int)pDevice->byPreambleType);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortPreamble= %d\n",(int)pDevice->byShortPreamble);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uConnectionRate= %d\n",(int)pDevice->uConnectionRate);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byBBType= %d\n",(int)pDevice->byBBType);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->b11hEnable= %d\n",(int)pDevice->b11hEnable);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->bDiversityRegCtlON= %d\n",(int)pDevice->bDiversityRegCtlON);
+	pDevice->bUpdateBBVGA = true;
+	pDevice->byFOETuning = 0;
+	pDevice->wCTSDuration = 0;
+	pDevice->byPreambleType = 0;
+
+
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " uChannel= %d\n", (int)pDevice->uChannel);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byOpMode= %d\n", (int)pDevice->byOpMode);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " ePSMode= %d\n", (int)pDevice->ePSMode);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " wRTSThreshold= %d\n", (int)pDevice->wRTSThreshold);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byShortRetryLimit= %d\n", (int)pDevice->byShortRetryLimit);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byLongRetryLimit= %d\n", (int)pDevice->byLongRetryLimit);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byPreambleType= %d\n", (int)pDevice->byPreambleType);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byShortPreamble= %d\n", (int)pDevice->byShortPreamble);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " uConnectionRate= %d\n", (int)pDevice->uConnectionRate);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " byBBType= %d\n", (int)pDevice->byBBType);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " pDevice->b11hEnable= %d\n", (int)pDevice->b11hEnable);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " pDevice->bDiversityRegCtlON= %d\n", (int)pDevice->bDiversityRegCtlON);
 }
 
-static void s_vCompleteCurrentMeasure (PSDevice pDevice, unsigned char byResult)
+static void s_vCompleteCurrentMeasure(PSDevice pDevice, unsigned char byResult)
 {
-    unsigned int ii;
-    unsigned long dwDuration = 0;
-    unsigned char byRPI0 = 0;
-
-    for(ii=1;ii<8;ii++) {
-        pDevice->dwRPIs[ii] *= 255;
-        dwDuration |= *((unsigned short *) (pDevice->pCurrMeasureEID->sReq.abyDuration));
-        dwDuration <<= 10;
-        pDevice->dwRPIs[ii] /= dwDuration;
-        pDevice->abyRPIs[ii] = (unsigned char) pDevice->dwRPIs[ii];
-        byRPI0 += pDevice->abyRPIs[ii];
-    }
-    pDevice->abyRPIs[0] = (0xFF - byRPI0);
-
-     if (pDevice->uNumOfMeasureEIDs == 0) {
-        VNTWIFIbMeasureReport(  pDevice->pMgmt,
-                                true,
-                                pDevice->pCurrMeasureEID,
-                                byResult,
-                                pDevice->byBasicMap,
-                                pDevice->byCCAFraction,
-                                pDevice->abyRPIs
-                                );
-    } else {
-        VNTWIFIbMeasureReport(  pDevice->pMgmt,
-                                false,
-                                pDevice->pCurrMeasureEID,
-                                byResult,
-                                pDevice->byBasicMap,
-                                pDevice->byCCAFraction,
-                                pDevice->abyRPIs
-                                );
-        CARDbStartMeasure (pDevice, pDevice->pCurrMeasureEID++, pDevice->uNumOfMeasureEIDs);
-    }
+	unsigned int ii;
+	unsigned long dwDuration = 0;
+	unsigned char byRPI0 = 0;
+
+	for (ii = 1; ii < 8; ii++) {
+		pDevice->dwRPIs[ii] *= 255;
+		dwDuration |= *((unsigned short *)(pDevice->pCurrMeasureEID->sReq.abyDuration));
+		dwDuration <<= 10;
+		pDevice->dwRPIs[ii] /= dwDuration;
+		pDevice->abyRPIs[ii] = (unsigned char)pDevice->dwRPIs[ii];
+		byRPI0 += pDevice->abyRPIs[ii];
+	}
+	pDevice->abyRPIs[0] = (0xFF - byRPI0);
+
+	if (pDevice->uNumOfMeasureEIDs == 0) {
+		VNTWIFIbMeasureReport(pDevice->pMgmt,
+				      true,
+				      pDevice->pCurrMeasureEID,
+				      byResult,
+				      pDevice->byBasicMap,
+				      pDevice->byCCAFraction,
+				      pDevice->abyRPIs
+			);
+	} else {
+		VNTWIFIbMeasureReport(pDevice->pMgmt,
+				      false,
+				      pDevice->pCurrMeasureEID,
+				      byResult,
+				      pDevice->byBasicMap,
+				      pDevice->byCCAFraction,
+				      pDevice->abyRPIs
+			);
+		CARDbStartMeasure(pDevice, pDevice->pCurrMeasureEID++, pDevice->uNumOfMeasureEIDs);
+	}
 
 }
 
@@ -522,316 +522,316 @@ static void s_vCompleteCurrentMeasure (PSDevice pDevice, unsigned char byResult)
 
 static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 {
-    unsigned int ii;
-    unsigned char byValue;
-    unsigned char byValue1;
-    unsigned char byCCKPwrdBm = 0;
-    unsigned char byOFDMPwrdBm = 0;
-    int zonetype=0;
-     PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
-    MACbShutdown(pDevice->PortOffset);
-    BBvSoftwareReset(pDevice->PortOffset);
-
-    if ((InitType == DEVICE_INIT_COLD) ||
-        (InitType == DEVICE_INIT_DXPL)) {
-        // Do MACbSoftwareReset in MACvInitialize
-        MACbSoftwareReset(pDevice->PortOffset);
-        // force CCK
-        pDevice->bCCK = true;
-        pDevice->bAES = false;
-        pDevice->bProtectMode = false;      //Only used in 11g type, sync with ERP IE
-        pDevice->bNonERPPresent = false;
-        pDevice->bBarkerPreambleMd = false;
-        pDevice->wCurrentRate = RATE_1M;
-        pDevice->byTopOFDMBasicRate = RATE_24M;
-        pDevice->byTopCCKBasicRate = RATE_1M;
-
-        pDevice->byRevId = 0;                   //Target to IF pin while programming to RF chip.
-
-        // init MAC
-        MACvInitialize(pDevice->PortOffset);
-
-        // Get Local ID
-        VNSvInPortB(pDevice->PortOffset + MAC_REG_LOCALID, &(pDevice->byLocalID));
-
-           spin_lock_irq(&pDevice->lock);
-	 SROMvReadAllContents(pDevice->PortOffset,pDevice->abyEEPROM);
-
-           spin_unlock_irq(&pDevice->lock);
-
-        // Get Channel range
-
-        pDevice->byMinChannel = 1;
-        pDevice->byMaxChannel = CB_MAX_CHANNEL;
-
-        // Get Antena
-        byValue = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
-        if (byValue & EEP_ANTINV)
-            pDevice->bTxRxAntInv = true;
-        else
-            pDevice->bTxRxAntInv = false;
+	unsigned int ii;
+	unsigned char byValue;
+	unsigned char byValue1;
+	unsigned char byCCKPwrdBm = 0;
+	unsigned char byOFDMPwrdBm = 0;
+	int zonetype = 0;
+	PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
+	MACbShutdown(pDevice->PortOffset);
+	BBvSoftwareReset(pDevice->PortOffset);
+
+	if ((InitType == DEVICE_INIT_COLD) ||
+	    (InitType == DEVICE_INIT_DXPL)) {
+		// Do MACbSoftwareReset in MACvInitialize
+		MACbSoftwareReset(pDevice->PortOffset);
+		// force CCK
+		pDevice->bCCK = true;
+		pDevice->bAES = false;
+		pDevice->bProtectMode = false;      //Only used in 11g type, sync with ERP IE
+		pDevice->bNonERPPresent = false;
+		pDevice->bBarkerPreambleMd = false;
+		pDevice->wCurrentRate = RATE_1M;
+		pDevice->byTopOFDMBasicRate = RATE_24M;
+		pDevice->byTopCCKBasicRate = RATE_1M;
+
+		pDevice->byRevId = 0;                   //Target to IF pin while programming to RF chip.
+
+		// init MAC
+		MACvInitialize(pDevice->PortOffset);
+
+		// Get Local ID
+		VNSvInPortB(pDevice->PortOffset + MAC_REG_LOCALID, &(pDevice->byLocalID));
+
+		spin_lock_irq(&pDevice->lock);
+		SROMvReadAllContents(pDevice->PortOffset, pDevice->abyEEPROM);
+
+		spin_unlock_irq(&pDevice->lock);
+
+		// Get Channel range
+
+		pDevice->byMinChannel = 1;
+		pDevice->byMaxChannel = CB_MAX_CHANNEL;
+
+		// Get Antena
+		byValue = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
+		if (byValue & EEP_ANTINV)
+			pDevice->bTxRxAntInv = true;
+		else
+			pDevice->bTxRxAntInv = false;
 #ifdef	PLICE_DEBUG
-	//printk("init_register:TxRxAntInv is %d,byValue is %d\n",pDevice->bTxRxAntInv,byValue);
+		//printk("init_register:TxRxAntInv is %d,byValue is %d\n",pDevice->bTxRxAntInv,byValue);
 #endif
 
-        byValue &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
-        if (byValue == 0) // if not set default is All
-            byValue = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
+		byValue &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
+		if (byValue == 0) // if not set default is All
+			byValue = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
 #ifdef	PLICE_DEBUG
-	//printk("init_register:byValue is %d\n",byValue);
+		//printk("init_register:byValue is %d\n",byValue);
 #endif
-        pDevice->ulDiversityNValue = 100*260;//100*SROMbyReadEmbedded(pDevice->PortOffset, 0x51);
-        pDevice->ulDiversityMValue = 100*16;//SROMbyReadEmbedded(pDevice->PortOffset, 0x52);
-        pDevice->byTMax = 1;//SROMbyReadEmbedded(pDevice->PortOffset, 0x53);
-        pDevice->byTMax2 = 4;//SROMbyReadEmbedded(pDevice->PortOffset, 0x54);
-        pDevice->ulSQ3TH = 0;//(unsigned long) SROMbyReadEmbedded(pDevice->PortOffset, 0x55);
-        pDevice->byTMax3 = 64;//SROMbyReadEmbedded(pDevice->PortOffset, 0x56);
-
-        if (byValue == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {
-            pDevice->byAntennaCount = 2;
-            pDevice->byTxAntennaMode = ANT_B;
-            pDevice->dwTxAntennaSel = 1;
-            pDevice->dwRxAntennaSel = 1;
-            if (pDevice->bTxRxAntInv == true)
-                pDevice->byRxAntennaMode = ANT_A;
-            else
-                pDevice->byRxAntennaMode = ANT_B;
-                // chester for antenna
-byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
-          //  if (pDevice->bDiversityRegCtlON)
-          if((byValue1&0x08)==0)
-                pDevice->bDiversityEnable = false;//SROMbyReadEmbedded(pDevice->PortOffset, 0x50);
-            else
-                pDevice->bDiversityEnable = true;
+		pDevice->ulDiversityNValue = 100*260;//100*SROMbyReadEmbedded(pDevice->PortOffset, 0x51);
+		pDevice->ulDiversityMValue = 100*16;//SROMbyReadEmbedded(pDevice->PortOffset, 0x52);
+		pDevice->byTMax = 1;//SROMbyReadEmbedded(pDevice->PortOffset, 0x53);
+		pDevice->byTMax2 = 4;//SROMbyReadEmbedded(pDevice->PortOffset, 0x54);
+		pDevice->ulSQ3TH = 0;//(unsigned long) SROMbyReadEmbedded(pDevice->PortOffset, 0x55);
+		pDevice->byTMax3 = 64;//SROMbyReadEmbedded(pDevice->PortOffset, 0x56);
+
+		if (byValue == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {
+			pDevice->byAntennaCount = 2;
+			pDevice->byTxAntennaMode = ANT_B;
+			pDevice->dwTxAntennaSel = 1;
+			pDevice->dwRxAntennaSel = 1;
+			if (pDevice->bTxRxAntInv == true)
+				pDevice->byRxAntennaMode = ANT_A;
+			else
+				pDevice->byRxAntennaMode = ANT_B;
+			// chester for antenna
+			byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
+			//  if (pDevice->bDiversityRegCtlON)
+			if ((byValue1 & 0x08) == 0)
+				pDevice->bDiversityEnable = false;//SROMbyReadEmbedded(pDevice->PortOffset, 0x50);
+			else
+				pDevice->bDiversityEnable = true;
 #ifdef	PLICE_DEBUG
-		//printk("aux |main antenna: RxAntennaMode is %d\n",pDevice->byRxAntennaMode);
+			//printk("aux |main antenna: RxAntennaMode is %d\n",pDevice->byRxAntennaMode);
 #endif
-	} else  {
-            pDevice->bDiversityEnable = false;
-            pDevice->byAntennaCount = 1;
-            pDevice->dwTxAntennaSel = 0;
-            pDevice->dwRxAntennaSel = 0;
-            if (byValue & EEP_ANTENNA_AUX) {
-                pDevice->byTxAntennaMode = ANT_A;
-                if (pDevice->bTxRxAntInv == true)
-                    pDevice->byRxAntennaMode = ANT_B;
-                else
-                    pDevice->byRxAntennaMode = ANT_A;
-            } else {
-                pDevice->byTxAntennaMode = ANT_B;
-                if (pDevice->bTxRxAntInv == true)
-                    pDevice->byRxAntennaMode = ANT_A;
-                else
-                    pDevice->byRxAntennaMode = ANT_B;
-            }
-        }
+		} else  {
+			pDevice->bDiversityEnable = false;
+			pDevice->byAntennaCount = 1;
+			pDevice->dwTxAntennaSel = 0;
+			pDevice->dwRxAntennaSel = 0;
+			if (byValue & EEP_ANTENNA_AUX) {
+				pDevice->byTxAntennaMode = ANT_A;
+				if (pDevice->bTxRxAntInv == true)
+					pDevice->byRxAntennaMode = ANT_B;
+				else
+					pDevice->byRxAntennaMode = ANT_A;
+			} else {
+				pDevice->byTxAntennaMode = ANT_B;
+				if (pDevice->bTxRxAntInv == true)
+					pDevice->byRxAntennaMode = ANT_A;
+				else
+					pDevice->byRxAntennaMode = ANT_B;
+			}
+		}
 #ifdef	PLICE_DEBUG
-	//printk("init registers: TxAntennaMode is %d\n",pDevice->byTxAntennaMode);
+		//printk("init registers: TxAntennaMode is %d\n",pDevice->byTxAntennaMode);
 #endif
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",
-            pDevice->bDiversityEnable,(int)pDevice->ulDiversityNValue,(int)pDevice->ulDiversityMValue,pDevice->byTMax,pDevice->byTMax2);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",
+			pDevice->bDiversityEnable, (int)pDevice->ulDiversityNValue, (int)pDevice->ulDiversityMValue, pDevice->byTMax, pDevice->byTMax2);
 
 //#ifdef ZoneType_DefaultSetting
 //2008-8-4 <add> by chester
 //zonetype initial
- pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
- zonetype = Config_FileOperation(pDevice,false,NULL);
- if (zonetype >= 0) {         //read zonetype file ok!
-  if ((zonetype == 0)&&
-        (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] !=0x00)){          //for USA
-    pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0;
-    pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0B;
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Init Zone Type :USA\n");
-  }
- else if((zonetype == 1)&&
- 	     (pDevice->abyEEPROM[EEP_OFS_ZONETYPE]!=0x01)){   //for Japan
-    pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x01;
-    pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
-  }
- else if((zonetype == 2)&&
- 	     (pDevice->abyEEPROM[EEP_OFS_ZONETYPE]!=0x02)){   //for Europe
-    pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x02;
-    pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Init Zone Type :Europe\n");
-  }
+		pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
+		zonetype = Config_FileOperation(pDevice, false, NULL);
+		if (zonetype >= 0) {         //read zonetype file ok!
+			if ((zonetype == 0) &&
+			    (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x00)) {          //for USA
+				pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0;
+				pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0B;
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Init Zone Type :USA\n");
+			}
+			else if ((zonetype == 1) &&
+				 (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x01)) {   //for Japan
+				pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x01;
+				pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
+			}
+			else if ((zonetype == 2) &&
+				 (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] != 0x02)) {   //for Europe
+				pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x02;
+				pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Init Zone Type :Europe\n");
+			}
 
-else
-{
-   if(zonetype!=pDevice->abyEEPROM[EEP_OFS_ZONETYPE])
-      printk("zonetype in file[%02x] mismatch with in EEPROM[%02x]\n",zonetype,pDevice->abyEEPROM[EEP_OFS_ZONETYPE]);
-   else
-      printk("Read Zonetype file success,use default zonetype setting[%02x]\n",zonetype);
- }
- 	}
-  else
-    printk("Read Zonetype file fail,use default zonetype setting[%02x]\n",SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ZONETYPE));
-
-        // Get RFType
-        pDevice->byRFType = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RFTYPE);
-
-        if ((pDevice->byRFType & RF_EMU) != 0) {
-            // force change RevID for VT3253 emu
-            pDevice->byRevId = 0x80;
-        }
-
-        pDevice->byRFType &= RF_MASK;
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRFType = %x\n", pDevice->byRFType);
-
-        if (pDevice->bZoneRegExist == false) {
-            pDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
-        }
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byZoneType = %x\n", pDevice->byZoneType);
-
-        //Init RF module
-        RFbInit(pDevice);
-
-        //Get Desire Power Value
-        pDevice->byCurPwr = 0xFF;
-        pDevice->byCCKPwr = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_CCK);
-        pDevice->byOFDMPwrG = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_OFDMG);
-        //byCCKPwrdBm = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_CCK_PWR_dBm);
-
-	//byOFDMPwrdBm = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_OFDM_PWR_dBm);
+			else
+			{
+				if (zonetype != pDevice->abyEEPROM[EEP_OFS_ZONETYPE])
+					printk("zonetype in file[%02x] mismatch with in EEPROM[%02x]\n", zonetype, pDevice->abyEEPROM[EEP_OFS_ZONETYPE]);
+				else
+					printk("Read Zonetype file success,use default zonetype setting[%02x]\n", zonetype);
+			}
+		}
+		else
+			printk("Read Zonetype file fail,use default zonetype setting[%02x]\n", SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ZONETYPE));
+
+		// Get RFType
+		pDevice->byRFType = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RFTYPE);
+
+		if ((pDevice->byRFType & RF_EMU) != 0) {
+			// force change RevID for VT3253 emu
+			pDevice->byRevId = 0x80;
+		}
+
+		pDevice->byRFType &= RF_MASK;
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRFType = %x\n", pDevice->byRFType);
+
+		if (pDevice->bZoneRegExist == false) {
+			pDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
+		}
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byZoneType = %x\n", pDevice->byZoneType);
+
+		//Init RF module
+		RFbInit(pDevice);
+
+		//Get Desire Power Value
+		pDevice->byCurPwr = 0xFF;
+		pDevice->byCCKPwr = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_CCK);
+		pDevice->byOFDMPwrG = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_OFDMG);
+		//byCCKPwrdBm = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_CCK_PWR_dBm);
+
+		//byOFDMPwrdBm = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_OFDM_PWR_dBm);
 //printk("CCKPwrdBm is 0x%x,byOFDMPwrdBm is 0x%x\n",byCCKPwrdBm,byOFDMPwrdBm);
 		// Load power Table
 
 
-        for (ii=0;ii<CB_MAX_CHANNEL_24G;ii++) {
-            pDevice->abyCCKPwrTbl[ii+1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_CCK_PWR_TBL));
-            if (pDevice->abyCCKPwrTbl[ii+1] == 0) {
-                pDevice->abyCCKPwrTbl[ii+1] = pDevice->byCCKPwr;
-            }
-            pDevice->abyOFDMPwrTbl[ii+1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDM_PWR_TBL));
-            if (pDevice->abyOFDMPwrTbl[ii+1] == 0) {
-                pDevice->abyOFDMPwrTbl[ii+1] = pDevice->byOFDMPwrG;
-            }
-            pDevice->abyCCKDefaultPwr[ii+1] = byCCKPwrdBm;
-            pDevice->abyOFDMDefaultPwr[ii+1] = byOFDMPwrdBm;
-        }
+		for (ii = 0; ii < CB_MAX_CHANNEL_24G; ii++) {
+			pDevice->abyCCKPwrTbl[ii + 1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_CCK_PWR_TBL));
+			if (pDevice->abyCCKPwrTbl[ii + 1] == 0) {
+				pDevice->abyCCKPwrTbl[ii+1] = pDevice->byCCKPwr;
+			}
+			pDevice->abyOFDMPwrTbl[ii + 1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDM_PWR_TBL));
+			if (pDevice->abyOFDMPwrTbl[ii + 1] == 0) {
+				pDevice->abyOFDMPwrTbl[ii + 1] = pDevice->byOFDMPwrG;
+			}
+			pDevice->abyCCKDefaultPwr[ii + 1] = byCCKPwrdBm;
+			pDevice->abyOFDMDefaultPwr[ii + 1] = byOFDMPwrdBm;
+		}
 		//2008-8-4 <add> by chester
-	  //recover 12,13 ,14channel for EUROPE by 11 channel
-          if(((pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Japan) ||
-	        (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Europe))&&
-	     (pDevice->byOriginalZonetype == ZoneType_USA)) {
-	    for(ii=11;ii<14;ii++) {
-                pDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];
-	       pDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];
+		//recover 12,13 ,14channel for EUROPE by 11 channel
+		if (((pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Japan) ||
+		     (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Europe)) &&
+		    (pDevice->byOriginalZonetype == ZoneType_USA)) {
+			for (ii = 11; ii < 14; ii++) {
+				pDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];
+				pDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];
 
-	    }
-	  }
+			}
+		}
 
 
-        // Load OFDM A Power Table
-        for (ii=0;ii<CB_MAX_CHANNEL_5G;ii++) { //RobertYu:20041224, bug using CB_MAX_CHANNEL
-            pDevice->abyOFDMPwrTbl[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDMA_PWR_TBL));
-            pDevice->abyOFDMDefaultPwr[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDMA_PWR_dBm));
-        }
-        init_channel_table((void *)pDevice);
+		// Load OFDM A Power Table
+		for (ii = 0; ii < CB_MAX_CHANNEL_5G; ii++) { //RobertYu:20041224, bug using CB_MAX_CHANNEL
+			pDevice->abyOFDMPwrTbl[ii + CB_MAX_CHANNEL_24G + 1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDMA_PWR_TBL));
+			pDevice->abyOFDMDefaultPwr[ii + CB_MAX_CHANNEL_24G + 1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDMA_PWR_dBm));
+		}
+		init_channel_table((void *)pDevice);
 
 
-        if (pDevice->byLocalID > REV_ID_VT3253_B1) {
-            MACvSelectPage1(pDevice->PortOffset);
-            VNSvOutPortB(pDevice->PortOffset + MAC_REG_MSRCTL + 1, (MSRCTL1_TXPWR | MSRCTL1_CSAPAREN));
-            MACvSelectPage0(pDevice->PortOffset);
-        }
+		if (pDevice->byLocalID > REV_ID_VT3253_B1) {
+			MACvSelectPage1(pDevice->PortOffset);
+			VNSvOutPortB(pDevice->PortOffset + MAC_REG_MSRCTL + 1, (MSRCTL1_TXPWR | MSRCTL1_CSAPAREN));
+			MACvSelectPage0(pDevice->PortOffset);
+		}
 
 
-         // use relative tx timeout and 802.11i D4
-        MACvWordRegBitsOn(pDevice->PortOffset, MAC_REG_CFG, (CFG_TKIPOPT | CFG_NOTXTIMEOUT));
+		// use relative tx timeout and 802.11i D4
+		MACvWordRegBitsOn(pDevice->PortOffset, MAC_REG_CFG, (CFG_TKIPOPT | CFG_NOTXTIMEOUT));
 
-        // set performance parameter by registry
-        MACvSetShortRetryLimit(pDevice->PortOffset, pDevice->byShortRetryLimit);
-        MACvSetLongRetryLimit(pDevice->PortOffset, pDevice->byLongRetryLimit);
+		// set performance parameter by registry
+		MACvSetShortRetryLimit(pDevice->PortOffset, pDevice->byShortRetryLimit);
+		MACvSetLongRetryLimit(pDevice->PortOffset, pDevice->byLongRetryLimit);
 
-        // reset TSF counter
-        VNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
-        // enable TSF counter
-        VNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
+		// reset TSF counter
+		VNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
+		// enable TSF counter
+		VNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
 
-        // initialize BBP registers
-        BBbVT3253Init(pDevice);
+		// initialize BBP registers
+		BBbVT3253Init(pDevice);
 
-        if (pDevice->bUpdateBBVGA) {
-            pDevice->byBBVGACurrent = pDevice->abyBBVGA[0];
-            pDevice->byBBVGANew = pDevice->byBBVGACurrent;
-            BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
-        }
+		if (pDevice->bUpdateBBVGA) {
+			pDevice->byBBVGACurrent = pDevice->abyBBVGA[0];
+			pDevice->byBBVGANew = pDevice->byBBVGACurrent;
+			BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
+		}
 #ifdef	PLICE_DEBUG
-	//printk("init registers:RxAntennaMode is %x,TxAntennaMode is %x\n",pDevice->byRxAntennaMode,pDevice->byTxAntennaMode);
+		//printk("init registers:RxAntennaMode is %x,TxAntennaMode is %x\n",pDevice->byRxAntennaMode,pDevice->byTxAntennaMode);
 #endif
-        BBvSetRxAntennaMode(pDevice->PortOffset, pDevice->byRxAntennaMode);
-        BBvSetTxAntennaMode(pDevice->PortOffset, pDevice->byTxAntennaMode);
+		BBvSetRxAntennaMode(pDevice->PortOffset, pDevice->byRxAntennaMode);
+		BBvSetTxAntennaMode(pDevice->PortOffset, pDevice->byTxAntennaMode);
 
-        pDevice->byCurrentCh = 0;
+		pDevice->byCurrentCh = 0;
 
-        //pDevice->NetworkType = Ndis802_11Automode;
-        // Set BB and packet type at the same time.
-        // Set Short Slot Time, xIFS, and RSPINF.
-        if (pDevice->uConnectionRate == RATE_AUTO) {
-            pDevice->wCurrentRate = RATE_54M;
-        } else {
-            pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
-        }
+		//pDevice->NetworkType = Ndis802_11Automode;
+		// Set BB and packet type at the same time.
+		// Set Short Slot Time, xIFS, and RSPINF.
+		if (pDevice->uConnectionRate == RATE_AUTO) {
+			pDevice->wCurrentRate = RATE_54M;
+		} else {
+			pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
+		}
 
-        // default G Mode
-        VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_11G);
-        VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_AUTO);
+		// default G Mode
+		VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_11G);
+		VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_AUTO);
 
-        pDevice->bRadioOff = false;
+		pDevice->bRadioOff = false;
 
-        pDevice->byRadioCtl = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RADIOCTL);
-        pDevice->bHWRadioOff = false;
+		pDevice->byRadioCtl = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RADIOCTL);
+		pDevice->bHWRadioOff = false;
 
-        if (pDevice->byRadioCtl & EEP_RADIOCTL_ENABLE) {
-            // Get GPIO
-            MACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);
+		if (pDevice->byRadioCtl & EEP_RADIOCTL_ENABLE) {
+			// Get GPIO
+			MACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);
 //2008-4-14 <add> by chester for led issue
- #ifdef FOR_LED_ON_NOTEBOOK
-if (pDevice->byGPIO & GPIO0_DATA){pDevice->bHWRadioOff = true;}
-if ( !(pDevice->byGPIO & GPIO0_DATA)){pDevice->bHWRadioOff = false;}
-
-            }
-        if ( (pDevice->bRadioControlOff == true)) {
-            CARDbRadioPowerOff(pDevice);
-        }
-else  CARDbRadioPowerOn(pDevice);
+#ifdef FOR_LED_ON_NOTEBOOK
+			if (pDevice->byGPIO & GPIO0_DATA) { pDevice->bHWRadioOff = true; }
+			if (!(pDevice->byGPIO & GPIO0_DATA)) { pDevice->bHWRadioOff = false; }
+
+		}
+		if ((pDevice->bRadioControlOff == true)) {
+			CARDbRadioPowerOff(pDevice);
+		}
+		else  CARDbRadioPowerOn(pDevice);
 #else
-            if (((pDevice->byGPIO & GPIO0_DATA) && !(pDevice->byRadioCtl & EEP_RADIOCTL_INV)) ||
-                ( !(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV))) {
-                pDevice->bHWRadioOff = true;
-            }
-        }
-        if ((pDevice->bHWRadioOff == true) || (pDevice->bRadioControlOff == true)) {
-            CARDbRadioPowerOff(pDevice);
-        }
+		if (((pDevice->byGPIO & GPIO0_DATA) && !(pDevice->byRadioCtl & EEP_RADIOCTL_INV)) ||
+		    (!(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV))) {
+			pDevice->bHWRadioOff = true;
+		}
+	}
+	if ((pDevice->bHWRadioOff == true) || (pDevice->bRadioControlOff == true)) {
+		CARDbRadioPowerOff(pDevice);
+	}
 
 #endif
-    }
-            pMgmt->eScanType = WMAC_SCAN_PASSIVE;
-    // get Permanent network address
-    SROMvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Network address = %pM\n",
-		pDevice->abyCurrentNetAddr);
-
-    // reset Tx pointer
-    CARDvSafeResetRx(pDevice);
-    // reset Rx pointer
-    CARDvSafeResetTx(pDevice);
-
-    if (pDevice->byLocalID <= REV_ID_VT3253_A1) {
-        MACvRegBitsOn(pDevice->PortOffset, MAC_REG_RCR, RCR_WPAERR);
-    }
+}
+pMgmt->eScanType = WMAC_SCAN_PASSIVE;
+// get Permanent network address
+SROMvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
+DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Network address = %pM\n",
+	pDevice->abyCurrentNetAddr);
+
+// reset Tx pointer
+CARDvSafeResetRx(pDevice);
+// reset Rx pointer
+CARDvSafeResetTx(pDevice);
+
+if (pDevice->byLocalID <= REV_ID_VT3253_A1) {
+	MACvRegBitsOn(pDevice->PortOffset, MAC_REG_RCR, RCR_WPAERR);
+}
 
-    pDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;
+pDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;
 
-    // Turn On Rx DMA
-    MACvReceive0(pDevice->PortOffset);
-    MACvReceive1(pDevice->PortOffset);
+// Turn On Rx DMA
+MACvReceive0(pDevice->PortOffset);
+MACvReceive1(pDevice->PortOffset);
 
-    // start the adapter
-    MACvStart(pDevice->PortOffset);
+// start the adapter
+MACvStart(pDevice->PortOffset);
 
-    netif_stop_queue(pDevice->dev);
+netif_stop_queue(pDevice->dev);
 
 
 }
@@ -840,57 +840,57 @@ else  CARDbRadioPowerOn(pDevice);
 
 static void device_init_diversity_timer(PSDevice pDevice) {
 
-    init_timer(&pDevice->TimerSQ3Tmax1);
-    pDevice->TimerSQ3Tmax1.data = (unsigned long) pDevice;
-    pDevice->TimerSQ3Tmax1.function = (TimerFunction)TimerSQ3CallBack;
-    pDevice->TimerSQ3Tmax1.expires = RUN_AT(HZ);
+	init_timer(&pDevice->TimerSQ3Tmax1);
+	pDevice->TimerSQ3Tmax1.data = (unsigned long) pDevice;
+	pDevice->TimerSQ3Tmax1.function = (TimerFunction)TimerSQ3CallBack;
+	pDevice->TimerSQ3Tmax1.expires = RUN_AT(HZ);
 
-    init_timer(&pDevice->TimerSQ3Tmax2);
-    pDevice->TimerSQ3Tmax2.data = (unsigned long) pDevice;
-    pDevice->TimerSQ3Tmax2.function = (TimerFunction)TimerSQ3CallBack;
-    pDevice->TimerSQ3Tmax2.expires = RUN_AT(HZ);
+	init_timer(&pDevice->TimerSQ3Tmax2);
+	pDevice->TimerSQ3Tmax2.data = (unsigned long) pDevice;
+	pDevice->TimerSQ3Tmax2.function = (TimerFunction)TimerSQ3CallBack;
+	pDevice->TimerSQ3Tmax2.expires = RUN_AT(HZ);
 
-    init_timer(&pDevice->TimerSQ3Tmax3);
-    pDevice->TimerSQ3Tmax3.data = (unsigned long) pDevice;
-    pDevice->TimerSQ3Tmax3.function = (TimerFunction)TimerState1CallBack;
-    pDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);
+	init_timer(&pDevice->TimerSQ3Tmax3);
+	pDevice->TimerSQ3Tmax3.data = (unsigned long) pDevice;
+	pDevice->TimerSQ3Tmax3.function = (TimerFunction)TimerState1CallBack;
+	pDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);
 
-    return;
+	return;
 }
 
 
 static bool device_release_WPADEV(PSDevice pDevice)
 {
-  viawget_wpa_header *wpahdr;
-  int ii=0;
- // wait_queue_head_t	Set_wait;
-  //send device close to wpa_supplicnat layer
-    if (pDevice->bWPADEVUp==true) {
-                 wpahdr = (viawget_wpa_header *)pDevice->skb->data;
-                 wpahdr->type = VIAWGET_DEVICECLOSE_MSG;
-                 wpahdr->resp_ie_len = 0;
-                 wpahdr->req_ie_len = 0;
-                 skb_put(pDevice->skb, sizeof(viawget_wpa_header));
-                 pDevice->skb->dev = pDevice->wpadev;
-		 skb_reset_mac_header(pDevice->skb);
-                 pDevice->skb->pkt_type = PACKET_HOST;
-                 pDevice->skb->protocol = htons(ETH_P_802_2);
-                 memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
-                 netif_rx(pDevice->skb);
-                 pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-
- //wait release WPADEV
-              //    init_waitqueue_head(&Set_wait);
-              //    wait_event_timeout(Set_wait, ((pDevice->wpadev==NULL)&&(pDevice->skb == NULL)),5*HZ);    //1s wait
-              while((pDevice->bWPADEVUp==true)) {
-	        set_current_state(TASK_UNINTERRUPTIBLE);
-                 schedule_timeout (HZ/20);          //wait 50ms
-                 ii++;
-	        if(ii>20)
-		  break;
-              }
-           }
-    return true;
+	viawget_wpa_header *wpahdr;
+	int ii = 0;
+	// wait_queue_head_t	Set_wait;
+	//send device close to wpa_supplicnat layer
+	if (pDevice->bWPADEVUp == true) {
+		wpahdr = (viawget_wpa_header *)pDevice->skb->data;
+		wpahdr->type = VIAWGET_DEVICECLOSE_MSG;
+		wpahdr->resp_ie_len = 0;
+		wpahdr->req_ie_len = 0;
+		skb_put(pDevice->skb, sizeof(viawget_wpa_header));
+		pDevice->skb->dev = pDevice->wpadev;
+		skb_reset_mac_header(pDevice->skb);
+		pDevice->skb->pkt_type = PACKET_HOST;
+		pDevice->skb->protocol = htons(ETH_P_802_2);
+		memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
+		netif_rx(pDevice->skb);
+		pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
+
+		//wait release WPADEV
+		//    init_waitqueue_head(&Set_wait);
+		//    wait_event_timeout(Set_wait, ((pDevice->wpadev==NULL)&&(pDevice->skb == NULL)),5*HZ);    //1s wait
+		while ((pDevice->bWPADEVUp == true)) {
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(HZ / 20);          //wait 50ms
+			ii++;
+			if (ii > 20)
+				break;
+		}
+	}
+	return true;
 }
 
 static const struct net_device_ops device_netdev_ops = {
@@ -905,90 +905,90 @@ static const struct net_device_ops device_netdev_ops = {
 static int
 vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 {
-    static bool bFirst = true;
-    struct net_device*  dev = NULL;
-    PCHIP_INFO  pChip_info = (PCHIP_INFO)ent->driver_data;
-    PSDevice    pDevice;
-    int         rc;
-    if (device_nics ++>= MAX_UINTS) {
-        printk(KERN_NOTICE DEVICE_NAME ": already found %d NICs\n", device_nics);
-        return -ENODEV;
-    }
-
-
-    dev = alloc_etherdev(sizeof(DEVICE_INFO));
-
-    pDevice = (PSDevice) netdev_priv(dev);
-
-    if (dev == NULL) {
-        printk(KERN_ERR DEVICE_NAME ": allocate net device failed \n");
-        return -ENOMEM;
-    }
-
-    // Chain it all together
-   // SET_MODULE_OWNER(dev);
-    SET_NETDEV_DEV(dev, &pcid->dev);
-
-    if (bFirst) {
-        printk(KERN_NOTICE "%s Ver. %s\n",DEVICE_FULL_DRV_NAM, DEVICE_VERSION);
-        printk(KERN_NOTICE "Copyright (c) 2003 VIA Networking Technologies, Inc.\n");
-        bFirst=false;
-    }
-
-    vt6655_init_info(pcid, &pDevice, pChip_info);
-    pDevice->dev = dev;
-    pDevice->next_module = root_device_dev;
-    root_device_dev = dev;
-
-    if (pci_enable_device(pcid)) {
-        device_free_info(pDevice);
-        return -ENODEV;
-    }
-    dev->irq = pcid->irq;
+	static bool bFirst = true;
+	struct net_device *dev = NULL;
+	PCHIP_INFO  pChip_info = (PCHIP_INFO)ent->driver_data;
+	PSDevice    pDevice;
+	int         rc;
+	if (device_nics++ >= MAX_UINTS) {
+		printk(KERN_NOTICE DEVICE_NAME ": already found %d NICs\n", device_nics);
+		return -ENODEV;
+	}
+
+
+	dev = alloc_etherdev(sizeof(DEVICE_INFO));
+
+	pDevice = (PSDevice) netdev_priv(dev);
+
+	if (dev == NULL) {
+		printk(KERN_ERR DEVICE_NAME ": allocate net device failed \n");
+		return -ENOMEM;
+	}
+
+	// Chain it all together
+	// SET_MODULE_OWNER(dev);
+	SET_NETDEV_DEV(dev, &pcid->dev);
+
+	if (bFirst) {
+		printk(KERN_NOTICE "%s Ver. %s\n", DEVICE_FULL_DRV_NAM, DEVICE_VERSION);
+		printk(KERN_NOTICE "Copyright (c) 2003 VIA Networking Technologies, Inc.\n");
+		bFirst = false;
+	}
+
+	vt6655_init_info(pcid, &pDevice, pChip_info);
+	pDevice->dev = dev;
+	pDevice->next_module = root_device_dev;
+	root_device_dev = dev;
+
+	if (pci_enable_device(pcid)) {
+		device_free_info(pDevice);
+		return -ENODEV;
+	}
+	dev->irq = pcid->irq;
 
 #ifdef	DEBUG
-	printk("Before get pci_info memaddr is %x\n",pDevice->memaddr);
+	printk("Before get pci_info memaddr is %x\n", pDevice->memaddr);
 #endif
-    if (device_get_pci_info(pDevice,pcid) == false) {
-        printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device.\n");
-        device_free_info(pDevice);
-        return -ENODEV;
-    }
+	if (device_get_pci_info(pDevice, pcid) == false) {
+		printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device.\n");
+		device_free_info(pDevice);
+		return -ENODEV;
+	}
 
 #if 1
 
 #ifdef	DEBUG
 
 	//pci_read_config_byte(pcid, PCI_BASE_ADDRESS_0, &pDevice->byRevId);
-	printk("after get pci_info memaddr is %x, io addr is %x,io_size is %d\n",pDevice->memaddr,pDevice->ioaddr,pDevice->io_size);
+	printk("after get pci_info memaddr is %x, io addr is %x,io_size is %d\n", pDevice->memaddr, pDevice->ioaddr, pDevice->io_size);
 	{
 		int i;
-		u32			bar,len;
+		u32 bar, len;
 		u32 address[] = {
-		PCI_BASE_ADDRESS_0,
-		PCI_BASE_ADDRESS_1,
-		PCI_BASE_ADDRESS_2,
-		PCI_BASE_ADDRESS_3,
-		PCI_BASE_ADDRESS_4,
-		PCI_BASE_ADDRESS_5,
-		0};
-		for (i=0;address[i];i++)
+			PCI_BASE_ADDRESS_0,
+			PCI_BASE_ADDRESS_1,
+			PCI_BASE_ADDRESS_2,
+			PCI_BASE_ADDRESS_3,
+			PCI_BASE_ADDRESS_4,
+			PCI_BASE_ADDRESS_5,
+			0};
+		for (i = 0; address[i]; i++)
 		{
 			//pci_write_config_dword(pcid,address[i], 0xFFFFFFFF);
 			pci_read_config_dword(pcid, address[i], &bar);
-			printk("bar %d is %x\n",i,bar);
+			printk("bar %d is %x\n", i, bar);
 			if (!bar)
 			{
-				printk("bar %d not implemented\n",i);
+				printk("bar %d not implemented\n", i);
 				continue;
 			}
 			if (bar & PCI_BASE_ADDRESS_SPACE_IO) {
-			/* This is IO */
+				/* This is IO */
 
-			len = bar & (PCI_BASE_ADDRESS_IO_MASK & 0xFFFF);
-			len = len & ~(len - 1);
+				len = bar & (PCI_BASE_ADDRESS_IO_MASK & 0xFFFF);
+				len = len & ~(len - 1);
 
-			printk("IO space:  len in IO %x, BAR %d\n", len, i);
+				printk("IO space:  len in IO %x, BAR %d\n", len, i);
 			}
 			else
 			{
@@ -1005,163 +1005,163 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 #endif
 
 #ifdef	DEBUG
-	//return  0  ;
+	//return  0;
 #endif
-    pDevice->PortOffset = (unsigned long)ioremap(pDevice->memaddr & PCI_BASE_ADDRESS_MEM_MASK, pDevice->io_size);
+	pDevice->PortOffset = (unsigned long)ioremap(pDevice->memaddr & PCI_BASE_ADDRESS_MEM_MASK, pDevice->io_size);
 	//pDevice->PortOffset = (unsigned long)ioremap(pDevice->ioaddr & PCI_BASE_ADDRESS_IO_MASK, pDevice->io_size);
 
-	if(pDevice->PortOffset == 0) {
-       printk(KERN_ERR DEVICE_NAME ": Failed to IO remapping ..\n");
-       device_free_info(pDevice);
-        return -ENODEV;
-    }
+	if (pDevice->PortOffset == 0) {
+		printk(KERN_ERR DEVICE_NAME ": Failed to IO remapping ..\n");
+		device_free_info(pDevice);
+		return -ENODEV;
+	}
 
 
 
 
-    rc = pci_request_regions(pcid, DEVICE_NAME);
-    if (rc) {
-        printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device\n");
-        device_free_info(pDevice);
-        return -ENODEV;
-    }
+	rc = pci_request_regions(pcid, DEVICE_NAME);
+	if (rc) {
+		printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device\n");
+		device_free_info(pDevice);
+		return -ENODEV;
+	}
 
-    dev->base_addr = pDevice->ioaddr;
+	dev->base_addr = pDevice->ioaddr;
 #ifdef	PLICE_DEBUG
-	unsigned char 	value;
+	unsigned char value;
 
 	VNSvInPortB(pDevice->PortOffset+0x4F, &value);
-	printk("Before write: value is %x\n",value);
+	printk("Before write: value is %x\n", value);
 	//VNSvInPortB(pDevice->PortOffset+0x3F, 0x00);
-	VNSvOutPortB(pDevice->PortOffset,value);
+	VNSvOutPortB(pDevice->PortOffset, value);
 	VNSvInPortB(pDevice->PortOffset+0x4F, &value);
-	printk("After write: value is %x\n",value);
+	printk("After write: value is %x\n", value);
 #endif
 
 
 
 #ifdef IO_MAP
-    pDevice->PortOffset = pDevice->ioaddr;
+	pDevice->PortOffset = pDevice->ioaddr;
 #endif
-    // do reset
-    if (!MACbSoftwareReset(pDevice->PortOffset)) {
-        printk(KERN_ERR DEVICE_NAME ": Failed to access MAC hardware..\n");
-        device_free_info(pDevice);
-        return -ENODEV;
-    }
-    // initial to reload eeprom
-    MACvInitialize(pDevice->PortOffset);
-    MACvReadEtherAddress(pDevice->PortOffset, dev->dev_addr);
-
-    device_get_options(pDevice, device_nics-1, dev->name);
-    device_set_options(pDevice);
-    //Mask out the options cannot be set to the chip
-    pDevice->sOpts.flags &= pChip_info->flags;
-
-    //Enable the chip specified capabilities
-    pDevice->flags = pDevice->sOpts.flags | (pChip_info->flags & 0xFF000000UL);
-    pDevice->tx_80211 = device_dma0_tx_80211;
-    pDevice->sMgmtObj.pAdapter = (void *)pDevice;
-    pDevice->pMgmt = &(pDevice->sMgmtObj);
-
-    dev->irq                = pcid->irq;
-    dev->netdev_ops         = &device_netdev_ops;
+	// do reset
+	if (!MACbSoftwareReset(pDevice->PortOffset)) {
+		printk(KERN_ERR DEVICE_NAME ": Failed to access MAC hardware..\n");
+		device_free_info(pDevice);
+		return -ENODEV;
+	}
+	// initial to reload eeprom
+	MACvInitialize(pDevice->PortOffset);
+	MACvReadEtherAddress(pDevice->PortOffset, dev->dev_addr);
+
+	device_get_options(pDevice, device_nics-1, dev->name);
+	device_set_options(pDevice);
+	//Mask out the options cannot be set to the chip
+	pDevice->sOpts.flags &= pChip_info->flags;
+
+	//Enable the chip specified capabilities
+	pDevice->flags = pDevice->sOpts.flags | (pChip_info->flags & 0xFF000000UL);
+	pDevice->tx_80211 = device_dma0_tx_80211;
+	pDevice->sMgmtObj.pAdapter = (void *)pDevice;
+	pDevice->pMgmt = &(pDevice->sMgmtObj);
+
+	dev->irq                = pcid->irq;
+	dev->netdev_ops         = &device_netdev_ops;
 
 	dev->wireless_handlers = (struct iw_handler_def *)&iwctl_handler_def;
 
-    rc = register_netdev(dev);
-    if (rc)
-    {
-        printk(KERN_ERR DEVICE_NAME " Failed to register netdev\n");
-        device_free_info(pDevice);
-        return -ENODEV;
-    }
-    device_print_info(pDevice);
-    pci_set_drvdata(pcid, pDevice);
-    return 0;
+	rc = register_netdev(dev);
+	if (rc)
+	{
+		printk(KERN_ERR DEVICE_NAME " Failed to register netdev\n");
+		device_free_info(pDevice);
+		return -ENODEV;
+	}
+	device_print_info(pDevice);
+	pci_set_drvdata(pcid, pDevice);
+	return 0;
 
 }
 
 static void device_print_info(PSDevice pDevice)
 {
-    struct net_device* dev=pDevice->dev;
+	struct net_device *dev = pDevice->dev;
 
-    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: %s\n",dev->name, get_chip_name(pDevice->chip_id));
-    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: MAC=%pM", dev->name, dev->dev_addr);
+	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: %s\n", dev->name, get_chip_name(pDevice->chip_id));
+	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: MAC=%pM", dev->name, dev->dev_addr);
 #ifdef IO_MAP
-    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx  ",(unsigned long) pDevice->ioaddr);
-    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);
+	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IO=0x%lx  ", (unsigned long)pDevice->ioaddr);
+	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IRQ=%d \n", pDevice->dev->irq);
 #else
-    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx Mem=0x%lx ",
-		    (unsigned long) pDevice->ioaddr,(unsigned long) pDevice->PortOffset);
-    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);
+	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IO=0x%lx Mem=0x%lx ",
+		(unsigned long)pDevice->ioaddr, (unsigned long)pDevice->PortOffset);
+	DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " IRQ=%d \n", pDevice->dev->irq);
 #endif
 
 }
 
-static void vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
-    PCHIP_INFO pChip_info) {
+static void vt6655_init_info(struct pci_dev *pcid, PSDevice *ppDevice,
+			     PCHIP_INFO pChip_info) {
 
-    PSDevice p;
+	PSDevice p;
 
-    memset(*ppDevice,0,sizeof(DEVICE_INFO));
+	memset(*ppDevice, 0, sizeof(DEVICE_INFO));
 
-    if (pDevice_Infos == NULL) {
-        pDevice_Infos =*ppDevice;
-    }
-    else {
-        for (p=pDevice_Infos;p->next!=NULL;p=p->next)
-            do {} while (0);
-        p->next = *ppDevice;
-        (*ppDevice)->prev = p;
-    }
+	if (pDevice_Infos == NULL) {
+		pDevice_Infos = *ppDevice;
+	}
+	else {
+		for (p = pDevice_Infos; p->next != NULL; p = p->next)
+			do {} while (0);
+		p->next = *ppDevice;
+		(*ppDevice)->prev = p;
+	}
 
-    (*ppDevice)->pcid = pcid;
-    (*ppDevice)->chip_id = pChip_info->chip_id;
-    (*ppDevice)->io_size = pChip_info->io_size;
-    (*ppDevice)->nTxQueues = pChip_info->nTxQueue;
-    (*ppDevice)->multicast_limit =32;
+	(*ppDevice)->pcid = pcid;
+	(*ppDevice)->chip_id = pChip_info->chip_id;
+	(*ppDevice)->io_size = pChip_info->io_size;
+	(*ppDevice)->nTxQueues = pChip_info->nTxQueue;
+	(*ppDevice)->multicast_limit = 32;
 
-    spin_lock_init(&((*ppDevice)->lock));
+	spin_lock_init(&((*ppDevice)->lock));
 }
 
-static bool device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {
+static bool device_get_pci_info(PSDevice pDevice, struct pci_dev *pcid) {
 
-    u16 pci_cmd;
-    u8  b;
-    unsigned int cis_addr;
+	u16 pci_cmd;
+	u8  b;
+	unsigned int cis_addr;
 #ifdef	PLICE_DEBUG
 	unsigned char pci_config[256];
-	unsigned char 	value =0x00;
-	int		ii,j;
-	u16	max_lat=0x0000;
-	memset(pci_config,0x00,256);
+	unsigned char value = 0x00;
+	int		ii, j;
+	u16	max_lat = 0x0000;
+	memset(pci_config, 0x00, 256);
 #endif
 
-    pci_read_config_byte(pcid, PCI_REVISION_ID, &pDevice->byRevId);
-    pci_read_config_word(pcid, PCI_SUBSYSTEM_ID,&pDevice->SubSystemID);
-    pci_read_config_word(pcid, PCI_SUBSYSTEM_VENDOR_ID, &pDevice->SubVendorID);
-    pci_read_config_word(pcid, PCI_COMMAND, (u16 *) & (pci_cmd));
+	pci_read_config_byte(pcid, PCI_REVISION_ID, &pDevice->byRevId);
+	pci_read_config_word(pcid, PCI_SUBSYSTEM_ID, &pDevice->SubSystemID);
+	pci_read_config_word(pcid, PCI_SUBSYSTEM_VENDOR_ID, &pDevice->SubVendorID);
+	pci_read_config_word(pcid, PCI_COMMAND, (u16 *)&(pci_cmd));
 
-    pci_set_master(pcid);
+	pci_set_master(pcid);
 
-    pDevice->memaddr = pci_resource_start(pcid,0);
-    pDevice->ioaddr = pci_resource_start(pcid,1);
+	pDevice->memaddr = pci_resource_start(pcid, 0);
+	pDevice->ioaddr = pci_resource_start(pcid, 1);
 
 #ifdef	DEBUG
 //	pDevice->ioaddr = pci_resource_start(pcid, 0);
 //	pDevice->memaddr = pci_resource_start(pcid,1);
 #endif
 
-    cis_addr = pci_resource_start(pcid,2);
+	cis_addr = pci_resource_start(pcid, 2);
 
-    pDevice->pcid = pcid;
+	pDevice->pcid = pcid;
 
-    pci_read_config_byte(pcid, PCI_COMMAND, &b);
-    pci_write_config_byte(pcid, PCI_COMMAND, (b|PCI_COMMAND_MASTER));
+	pci_read_config_byte(pcid, PCI_COMMAND, &b);
+	pci_write_config_byte(pcid, PCI_COMMAND, (b|PCI_COMMAND_MASTER));
 
 #ifdef	PLICE_DEBUG
-   	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
+	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
 	//printk("max lat is %x,SubSystemID is %x\n",max_lat,pDevice->SubSystemID);
 	//for (ii=0;ii<0xFF;ii++)
 	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
@@ -1170,399 +1170,399 @@ static bool device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {
 	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
 	//printk("max lat is %x\n",max_lat);
 
-	for (ii=0;ii<0xFF;ii++)
+	for (ii = 0; ii < 0xFF; ii++)
 	{
-		pci_read_config_byte(pcid,ii,&value);
+		pci_read_config_byte(pcid, ii, &value);
 		pci_config[ii] = value;
 	}
-	for (ii=0,j=1;ii<0x100;ii++,j++)
+	for (ii = 0, j = 1; ii < 0x100; ii++, j++)
 	{
-		if (j %16 == 0)
+		if (j % 16 == 0)
 		{
-			printk("%x:",pci_config[ii]);
+			printk("%x:", pci_config[ii]);
 			printk("\n");
 		}
 		else
 		{
-			printk("%x:",pci_config[ii]);
+			printk("%x:", pci_config[ii]);
 		}
 	}
 #endif
-    return true;
+	return true;
 }
 
 static void device_free_info(PSDevice pDevice) {
-    PSDevice         ptr;
-    struct net_device*  dev=pDevice->dev;
+	PSDevice         ptr;
+	struct net_device *dev = pDevice->dev;
 
-    ASSERT(pDevice);
+	ASSERT(pDevice);
 //2008-0714-01<Add>by chester
-device_release_WPADEV(pDevice);
+	device_release_WPADEV(pDevice);
 
 //2008-07-21-01<Add>by MikeLiu
 //unregister wpadev
-   if(wpa_set_wpadev(pDevice, 0)!=0)
-     printk("unregister wpadev fail?\n");
-
-    if (pDevice_Infos==NULL)
-        return;
-
-    for (ptr=pDevice_Infos;ptr && (ptr!=pDevice);ptr=ptr->next)
-            do {} while (0);
-
-    if (ptr==pDevice) {
-        if (ptr==pDevice_Infos)
-            pDevice_Infos=ptr->next;
-        else
-            ptr->prev->next=ptr->next;
-    }
-    else {
-        DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "info struct not found\n");
-        return;
-    }
+	if (wpa_set_wpadev(pDevice, 0) != 0)
+		printk("unregister wpadev fail?\n");
+
+	if (pDevice_Infos == NULL)
+		return;
+
+	for (ptr = pDevice_Infos; ptr && (ptr != pDevice); ptr = ptr->next)
+		do {} while (0);
+
+	if (ptr == pDevice) {
+		if (ptr == pDevice_Infos)
+			pDevice_Infos = ptr->next;
+		else
+			ptr->prev->next = ptr->next;
+	}
+	else {
+		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "info struct not found\n");
+		return;
+	}
 #ifdef HOSTAP
-    if (dev)
-        vt6655_hostap_set_hostapd(pDevice, 0, 0);
+	if (dev)
+		vt6655_hostap_set_hostapd(pDevice, 0, 0);
 #endif
-    if (dev)
-        unregister_netdev(dev);
+	if (dev)
+		unregister_netdev(dev);
 
-    if (pDevice->PortOffset)
-        iounmap((void *)pDevice->PortOffset);
+	if (pDevice->PortOffset)
+		iounmap((void *)pDevice->PortOffset);
 
-    if (pDevice->pcid)
-        pci_release_regions(pDevice->pcid);
-    if (dev)
-        free_netdev(dev);
+	if (pDevice->pcid)
+		pci_release_regions(pDevice->pcid);
+	if (dev)
+		free_netdev(dev);
 
-    if (pDevice->pcid) {
-        pci_set_drvdata(pDevice->pcid,NULL);
-    }
+	if (pDevice->pcid) {
+		pci_set_drvdata(pDevice->pcid, NULL);
+	}
 }
 
 static bool device_init_rings(PSDevice pDevice) {
-    void*   vir_pool;
-
-
-    /*allocate all RD/TD rings a single pool*/
-    vir_pool = pci_alloc_consistent(pDevice->pcid,
-                    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
-                    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
-                    pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
-                    pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
-                    &pDevice->pool_dma);
+	void *vir_pool;
 
-    if (vir_pool == NULL) {
-        DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : allocate desc dma memory failed\n", pDevice->dev->name);
-        return false;
-    }
 
-    memset(vir_pool, 0,
-            pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
-            pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
-            pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
-            pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc)
-          );
+	/*allocate all RD/TD rings a single pool*/
+	vir_pool = pci_alloc_consistent(pDevice->pcid,
+					pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
+					pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
+					pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
+					pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
+					&pDevice->pool_dma);
 
-    pDevice->aRD0Ring = vir_pool;
-    pDevice->aRD1Ring = vir_pool +
-                        pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
-
-
-    pDevice->rd0_pool_dma = pDevice->pool_dma;
-    pDevice->rd1_pool_dma = pDevice->rd0_pool_dma +
-                            pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
-
-    pDevice->tx0_bufs = pci_alloc_consistent(pDevice->pcid,
-                    pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
-                    pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
-                    CB_BEACON_BUF_SIZE +
-                    CB_MAX_BUF_SIZE,
-                    &pDevice->tx_bufs_dma0);
+	if (vir_pool == NULL) {
+		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s : allocate desc dma memory failed\n", pDevice->dev->name);
+		return false;
+	}
 
-    if (pDevice->tx0_bufs == NULL) {
-        DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: allocate buf dma memory failed\n", pDevice->dev->name);
-        pci_free_consistent(pDevice->pcid,
-            pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
-            pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
-            pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
-            pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
-            vir_pool, pDevice->pool_dma
-            );
-        return false;
-    }
+	memset(vir_pool, 0,
+	       pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
+	       pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
+	       pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
+	       pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc)
+		);
+
+	pDevice->aRD0Ring = vir_pool;
+	pDevice->aRD1Ring = vir_pool +
+		pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
+
+
+	pDevice->rd0_pool_dma = pDevice->pool_dma;
+	pDevice->rd1_pool_dma = pDevice->rd0_pool_dma +
+		pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
+
+	pDevice->tx0_bufs = pci_alloc_consistent(pDevice->pcid,
+						 pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
+						 pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
+						 CB_BEACON_BUF_SIZE +
+						 CB_MAX_BUF_SIZE,
+						 &pDevice->tx_bufs_dma0);
+
+	if (pDevice->tx0_bufs == NULL) {
+		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: allocate buf dma memory failed\n", pDevice->dev->name);
+		pci_free_consistent(pDevice->pcid,
+				    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
+				    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
+				    pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
+				    pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
+				    vir_pool, pDevice->pool_dma
+			);
+		return false;
+	}
 
-    memset(pDevice->tx0_bufs, 0,
-           pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
-           pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
-           CB_BEACON_BUF_SIZE +
-           CB_MAX_BUF_SIZE
-          );
+	memset(pDevice->tx0_bufs, 0,
+	       pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
+	       pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
+	       CB_BEACON_BUF_SIZE +
+	       CB_MAX_BUF_SIZE
+		);
 
-    pDevice->td0_pool_dma = pDevice->rd1_pool_dma +
-            pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);
+	pDevice->td0_pool_dma = pDevice->rd1_pool_dma +
+		pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);
 
-    pDevice->td1_pool_dma = pDevice->td0_pool_dma +
-            pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);
+	pDevice->td1_pool_dma = pDevice->td0_pool_dma +
+		pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);
 
 
-    // vir_pool: pvoid type
-    pDevice->apTD0Rings = vir_pool
-                          + pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)
-                          + pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);
+	// vir_pool: pvoid type
+	pDevice->apTD0Rings = vir_pool
+		+ pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)
+		+ pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);
 
-    pDevice->apTD1Rings = vir_pool
-            + pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)
-            + pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc)
-            + pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);
+	pDevice->apTD1Rings = vir_pool
+		+ pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)
+		+ pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc)
+		+ pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);
 
 
-    pDevice->tx1_bufs = pDevice->tx0_bufs +
-            pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;
+	pDevice->tx1_bufs = pDevice->tx0_bufs +
+		pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;
 
 
-    pDevice->tx_beacon_bufs = pDevice->tx1_bufs +
-            pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;
+	pDevice->tx_beacon_bufs = pDevice->tx1_bufs +
+		pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;
 
-    pDevice->pbyTmpBuff = pDevice->tx_beacon_bufs +
-            CB_BEACON_BUF_SIZE;
+	pDevice->pbyTmpBuff = pDevice->tx_beacon_bufs +
+		CB_BEACON_BUF_SIZE;
 
-    pDevice->tx_bufs_dma1 = pDevice->tx_bufs_dma0 +
-            pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;
+	pDevice->tx_bufs_dma1 = pDevice->tx_bufs_dma0 +
+		pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;
 
 
-    pDevice->tx_beacon_dma = pDevice->tx_bufs_dma1 +
-            pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;
+	pDevice->tx_beacon_dma = pDevice->tx_bufs_dma1 +
+		pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;
 
 
-    return true;
+	return true;
 }
 
 static void device_free_rings(PSDevice pDevice) {
 
-    pci_free_consistent(pDevice->pcid,
-            pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
-            pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
-            pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
-            pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc)
-            ,
-            pDevice->aRD0Ring, pDevice->pool_dma
-        );
-
-    if (pDevice->tx0_bufs)
-        pci_free_consistent(pDevice->pcid,
-           pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
-           pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
-           CB_BEACON_BUF_SIZE +
-           CB_MAX_BUF_SIZE,
-           pDevice->tx0_bufs, pDevice->tx_bufs_dma0
-        );
+	pci_free_consistent(pDevice->pcid,
+			    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
+			    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
+			    pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
+			    pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc)
+			    ,
+			    pDevice->aRD0Ring, pDevice->pool_dma
+		);
+
+	if (pDevice->tx0_bufs)
+		pci_free_consistent(pDevice->pcid,
+				    pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
+				    pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
+				    CB_BEACON_BUF_SIZE +
+				    CB_MAX_BUF_SIZE,
+				    pDevice->tx0_bufs, pDevice->tx_bufs_dma0
+			);
 }
 
 static void device_init_rd0_ring(PSDevice pDevice) {
-    int i;
-    dma_addr_t      curr = pDevice->rd0_pool_dma;
-    PSRxDesc        pDesc;
-
-    /* Init the RD0 ring entries */
-    for (i = 0; i < pDevice->sOpts.nRxDescs0; i ++, curr += sizeof(SRxDesc)) {
-        pDesc = &(pDevice->aRD0Ring[i]);
-        pDesc->pRDInfo = alloc_rd_info();
-        ASSERT(pDesc->pRDInfo);
-        if (!device_alloc_rx_buf(pDevice, pDesc)) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc rx bufs\n",
-            pDevice->dev->name);
-        }
-        pDesc->next = &(pDevice->aRD0Ring[(i+1) % pDevice->sOpts.nRxDescs0]);
-        pDesc->pRDInfo->curr_desc = cpu_to_le32(curr);
-        pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
-    }
-
-    if (i > 0)
-        pDevice->aRD0Ring[i-1].next_desc = cpu_to_le32(pDevice->rd0_pool_dma);
-    pDevice->pCurrRD[0] = &(pDevice->aRD0Ring[0]);
+	int i;
+	dma_addr_t      curr = pDevice->rd0_pool_dma;
+	PSRxDesc        pDesc;
+
+	/* Init the RD0 ring entries */
+	for (i = 0; i < pDevice->sOpts.nRxDescs0; i ++, curr += sizeof(SRxDesc)) {
+		pDesc = &(pDevice->aRD0Ring[i]);
+		pDesc->pRDInfo = alloc_rd_info();
+		ASSERT(pDesc->pRDInfo);
+		if (!device_alloc_rx_buf(pDevice, pDesc)) {
+			DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc rx bufs\n",
+				pDevice->dev->name);
+		}
+		pDesc->next = &(pDevice->aRD0Ring[(i+1) % pDevice->sOpts.nRxDescs0]);
+		pDesc->pRDInfo->curr_desc = cpu_to_le32(curr);
+		pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
+	}
+
+	if (i > 0)
+		pDevice->aRD0Ring[i-1].next_desc = cpu_to_le32(pDevice->rd0_pool_dma);
+	pDevice->pCurrRD[0] = &(pDevice->aRD0Ring[0]);
 }
 
 
 static void device_init_rd1_ring(PSDevice pDevice) {
-    int i;
-    dma_addr_t      curr = pDevice->rd1_pool_dma;
-    PSRxDesc        pDesc;
-
-    /* Init the RD1 ring entries */
-    for (i = 0; i < pDevice->sOpts.nRxDescs1; i ++, curr += sizeof(SRxDesc)) {
-        pDesc = &(pDevice->aRD1Ring[i]);
-        pDesc->pRDInfo = alloc_rd_info();
-        ASSERT(pDesc->pRDInfo);
-        if (!device_alloc_rx_buf(pDevice, pDesc)) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc rx bufs\n",
-            pDevice->dev->name);
-        }
-        pDesc->next = &(pDevice->aRD1Ring[(i+1) % pDevice->sOpts.nRxDescs1]);
-        pDesc->pRDInfo->curr_desc = cpu_to_le32(curr);
-        pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
-    }
-
-    if (i > 0)
-        pDevice->aRD1Ring[i-1].next_desc = cpu_to_le32(pDevice->rd1_pool_dma);
-    pDevice->pCurrRD[1] = &(pDevice->aRD1Ring[0]);
+	int i;
+	dma_addr_t      curr = pDevice->rd1_pool_dma;
+	PSRxDesc        pDesc;
+
+	/* Init the RD1 ring entries */
+	for (i = 0; i < pDevice->sOpts.nRxDescs1; i ++, curr += sizeof(SRxDesc)) {
+		pDesc = &(pDevice->aRD1Ring[i]);
+		pDesc->pRDInfo = alloc_rd_info();
+		ASSERT(pDesc->pRDInfo);
+		if (!device_alloc_rx_buf(pDevice, pDesc)) {
+			DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc rx bufs\n",
+				pDevice->dev->name);
+		}
+		pDesc->next = &(pDevice->aRD1Ring[(i+1) % pDevice->sOpts.nRxDescs1]);
+		pDesc->pRDInfo->curr_desc = cpu_to_le32(curr);
+		pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
+	}
+
+	if (i > 0)
+		pDevice->aRD1Ring[i-1].next_desc = cpu_to_le32(pDevice->rd1_pool_dma);
+	pDevice->pCurrRD[1] = &(pDevice->aRD1Ring[0]);
 }
 
 
 static void device_init_defrag_cb(PSDevice pDevice) {
-    int i;
-    PSDeFragControlBlock pDeF;
-
-    /* Init the fragment ctl entries */
-    for (i = 0; i < CB_MAX_RX_FRAG; i++) {
-        pDeF = &(pDevice->sRxDFCB[i]);
-        if (!device_alloc_frag_buf(pDevice, pDeF)) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc frag bufs\n",
-                pDevice->dev->name);
-        }
-    }
-    pDevice->cbDFCB = CB_MAX_RX_FRAG;
-    pDevice->cbFreeDFCB = pDevice->cbDFCB;
+	int i;
+	PSDeFragControlBlock pDeF;
+
+	/* Init the fragment ctl entries */
+	for (i = 0; i < CB_MAX_RX_FRAG; i++) {
+		pDeF = &(pDevice->sRxDFCB[i]);
+		if (!device_alloc_frag_buf(pDevice, pDeF)) {
+			DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc frag bufs\n",
+				pDevice->dev->name);
+		}
+	}
+	pDevice->cbDFCB = CB_MAX_RX_FRAG;
+	pDevice->cbFreeDFCB = pDevice->cbDFCB;
 }
 
 
 
 
 static void device_free_rd0_ring(PSDevice pDevice) {
-    int i;
+	int i;
 
-    for (i = 0; i < pDevice->sOpts.nRxDescs0; i++) {
-        PSRxDesc        pDesc =&(pDevice->aRD0Ring[i]);
-        PDEVICE_RD_INFO  pRDInfo =pDesc->pRDInfo;
+	for (i = 0; i < pDevice->sOpts.nRxDescs0; i++) {
+		PSRxDesc        pDesc = &(pDevice->aRD0Ring[i]);
+		PDEVICE_RD_INFO  pRDInfo = pDesc->pRDInfo;
 
-        pci_unmap_single(pDevice->pcid,pRDInfo->skb_dma,
-           pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
+		pci_unmap_single(pDevice->pcid, pRDInfo->skb_dma,
+				 pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
 
-        dev_kfree_skb(pRDInfo->skb);
+		dev_kfree_skb(pRDInfo->skb);
 
-        kfree((void *)pDesc->pRDInfo);
-    }
+		kfree((void *)pDesc->pRDInfo);
+	}
 
 }
 
 static void device_free_rd1_ring(PSDevice pDevice) {
-    int i;
+	int i;
 
 
-    for (i = 0; i < pDevice->sOpts.nRxDescs1; i++) {
-        PSRxDesc        pDesc=&(pDevice->aRD1Ring[i]);
-        PDEVICE_RD_INFO  pRDInfo=pDesc->pRDInfo;
+	for (i = 0; i < pDevice->sOpts.nRxDescs1; i++) {
+		PSRxDesc        pDesc = &(pDevice->aRD1Ring[i]);
+		PDEVICE_RD_INFO  pRDInfo = pDesc->pRDInfo;
 
-        pci_unmap_single(pDevice->pcid,pRDInfo->skb_dma,
-           pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
+		pci_unmap_single(pDevice->pcid, pRDInfo->skb_dma,
+				 pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
 
-        dev_kfree_skb(pRDInfo->skb);
+		dev_kfree_skb(pRDInfo->skb);
 
-        kfree((void *)pDesc->pRDInfo);
-    }
+		kfree((void *)pDesc->pRDInfo);
+	}
 
 }
 
 static void device_free_frag_buf(PSDevice pDevice) {
-    PSDeFragControlBlock pDeF;
-    int i;
+	PSDeFragControlBlock pDeF;
+	int i;
 
-    for (i = 0; i < CB_MAX_RX_FRAG; i++) {
+	for (i = 0; i < CB_MAX_RX_FRAG; i++) {
 
-        pDeF = &(pDevice->sRxDFCB[i]);
+		pDeF = &(pDevice->sRxDFCB[i]);
 
-        if (pDeF->skb)
-            dev_kfree_skb(pDeF->skb);
+		if (pDeF->skb)
+			dev_kfree_skb(pDeF->skb);
 
-    }
+	}
 
 }
 
 static void device_init_td0_ring(PSDevice pDevice) {
-    int i;
-    dma_addr_t  curr;
-    PSTxDesc        pDesc;
-
-    curr = pDevice->td0_pool_dma;
-    for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++, curr += sizeof(STxDesc)) {
-        pDesc = &(pDevice->apTD0Rings[i]);
-        pDesc->pTDInfo = alloc_td_info();
-        ASSERT(pDesc->pTDInfo);
-        if (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {
-            pDesc->pTDInfo->buf = pDevice->tx0_bufs + (i)*PKT_BUF_SZ;
-            pDesc->pTDInfo->buf_dma = pDevice->tx_bufs_dma0 + (i)*PKT_BUF_SZ;
-        }
-        pDesc->next =&(pDevice->apTD0Rings[(i+1) % pDevice->sOpts.nTxDescs[0]]);
-        pDesc->pTDInfo->curr_desc = cpu_to_le32(curr);
-        pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
-    }
-
-    if (i > 0)
-        pDevice->apTD0Rings[i-1].next_desc = cpu_to_le32(pDevice->td0_pool_dma);
-    pDevice->apTailTD[0] = pDevice->apCurrTD[0] =&(pDevice->apTD0Rings[0]);
+	int i;
+	dma_addr_t  curr;
+	PSTxDesc        pDesc;
+
+	curr = pDevice->td0_pool_dma;
+	for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++, curr += sizeof(STxDesc)) {
+		pDesc = &(pDevice->apTD0Rings[i]);
+		pDesc->pTDInfo = alloc_td_info();
+		ASSERT(pDesc->pTDInfo);
+		if (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {
+			pDesc->pTDInfo->buf = pDevice->tx0_bufs + (i)*PKT_BUF_SZ;
+			pDesc->pTDInfo->buf_dma = pDevice->tx_bufs_dma0 + (i)*PKT_BUF_SZ;
+		}
+		pDesc->next = &(pDevice->apTD0Rings[(i+1) % pDevice->sOpts.nTxDescs[0]]);
+		pDesc->pTDInfo->curr_desc = cpu_to_le32(curr);
+		pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
+	}
+
+	if (i > 0)
+		pDevice->apTD0Rings[i-1].next_desc = cpu_to_le32(pDevice->td0_pool_dma);
+	pDevice->apTailTD[0] = pDevice->apCurrTD[0] = &(pDevice->apTD0Rings[0]);
 
 }
 
 static void device_init_td1_ring(PSDevice pDevice) {
-    int i;
-    dma_addr_t  curr;
-    PSTxDesc    pDesc;
-
-    /* Init the TD ring entries */
-    curr=pDevice->td1_pool_dma;
-    for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++, curr+=sizeof(STxDesc)) {
-        pDesc=&(pDevice->apTD1Rings[i]);
-        pDesc->pTDInfo = alloc_td_info();
-        ASSERT(pDesc->pTDInfo);
-        if (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {
-            pDesc->pTDInfo->buf=pDevice->tx1_bufs+(i)*PKT_BUF_SZ;
-            pDesc->pTDInfo->buf_dma=pDevice->tx_bufs_dma1+(i)*PKT_BUF_SZ;
-        }
-        pDesc->next=&(pDevice->apTD1Rings[(i+1) % pDevice->sOpts.nTxDescs[1]]);
-        pDesc->pTDInfo->curr_desc = cpu_to_le32(curr);
-        pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
-    }
-
-    if (i > 0)
-        pDevice->apTD1Rings[i-1].next_desc = cpu_to_le32(pDevice->td1_pool_dma);
-    pDevice->apTailTD[1] = pDevice->apCurrTD[1] = &(pDevice->apTD1Rings[0]);
+	int i;
+	dma_addr_t  curr;
+	PSTxDesc    pDesc;
+
+	/* Init the TD ring entries */
+	curr = pDevice->td1_pool_dma;
+	for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++, curr += sizeof(STxDesc)) {
+		pDesc = &(pDevice->apTD1Rings[i]);
+		pDesc->pTDInfo = alloc_td_info();
+		ASSERT(pDesc->pTDInfo);
+		if (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {
+			pDesc->pTDInfo->buf = pDevice->tx1_bufs + (i) * PKT_BUF_SZ;
+			pDesc->pTDInfo->buf_dma = pDevice->tx_bufs_dma1 + (i) * PKT_BUF_SZ;
+		}
+		pDesc->next = &(pDevice->apTD1Rings[(i + 1) % pDevice->sOpts.nTxDescs[1]]);
+		pDesc->pTDInfo->curr_desc = cpu_to_le32(curr);
+		pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
+	}
+
+	if (i > 0)
+		pDevice->apTD1Rings[i-1].next_desc = cpu_to_le32(pDevice->td1_pool_dma);
+	pDevice->apTailTD[1] = pDevice->apCurrTD[1] = &(pDevice->apTD1Rings[0]);
 }
 
 
 
 static void device_free_td0_ring(PSDevice pDevice) {
-    int i;
-    for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++) {
-        PSTxDesc        pDesc=&(pDevice->apTD0Rings[i]);
-        PDEVICE_TD_INFO  pTDInfo=pDesc->pTDInfo;
+	int i;
+	for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++) {
+		PSTxDesc        pDesc = &(pDevice->apTD0Rings[i]);
+		PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
 
-        if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma))
-            pci_unmap_single(pDevice->pcid,pTDInfo->skb_dma,
-               pTDInfo->skb->len, PCI_DMA_TODEVICE);
+		if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma))
+			pci_unmap_single(pDevice->pcid, pTDInfo->skb_dma,
+					 pTDInfo->skb->len, PCI_DMA_TODEVICE);
 
-        if (pTDInfo->skb)
-            dev_kfree_skb(pTDInfo->skb);
+		if (pTDInfo->skb)
+			dev_kfree_skb(pTDInfo->skb);
 
-        kfree((void *)pDesc->pTDInfo);
-    }
+		kfree((void *)pDesc->pTDInfo);
+	}
 }
 
 static void device_free_td1_ring(PSDevice pDevice) {
-    int i;
+	int i;
 
-    for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++) {
-        PSTxDesc        pDesc=&(pDevice->apTD1Rings[i]);
-        PDEVICE_TD_INFO  pTDInfo=pDesc->pTDInfo;
+	for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++) {
+		PSTxDesc        pDesc = &(pDevice->apTD1Rings[i]);
+		PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
 
-        if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma))
-            pci_unmap_single(pDevice->pcid, pTDInfo->skb_dma,
-               pTDInfo->skb->len, PCI_DMA_TODEVICE);
+		if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma))
+			pci_unmap_single(pDevice->pcid, pTDInfo->skb_dma,
+					 pTDInfo->skb->len, PCI_DMA_TODEVICE);
 
-        if (pTDInfo->skb)
-            dev_kfree_skb(pTDInfo->skb);
+		if (pTDInfo->skb)
+			dev_kfree_skb(pTDInfo->skb);
 
-        kfree((void *)pDesc->pTDInfo);
-    }
+		kfree((void *)pDesc->pTDInfo);
+	}
 
 }
 
@@ -1571,239 +1571,239 @@ static void device_free_td1_ring(PSDevice pDevice) {
 /*-----------------------------------------------------------------*/
 
 static int device_rx_srv(PSDevice pDevice, unsigned int uIdx) {
-    PSRxDesc    pRD;
-    int works = 0;
+	PSRxDesc    pRD;
+	int works = 0;
 
 
-    for (pRD = pDevice->pCurrRD[uIdx];
-         pRD->m_rd0RD0.f1Owner == OWNED_BY_HOST;
-         pRD = pRD->next) {
+	for (pRD = pDevice->pCurrRD[uIdx];
+	     pRD->m_rd0RD0.f1Owner == OWNED_BY_HOST;
+	     pRD = pRD->next) {
 //        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->pCurrRD = %x, works = %d\n", pRD, works);
-        if (works++>15)
-            break;
-        if (device_receive_frame(pDevice, pRD)) {
-            if (!device_alloc_rx_buf(pDevice,pRD)) {
-                    DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
-                    "%s: can not allocate rx buf\n", pDevice->dev->name);
-                    break;
-            }
-        }
-        pRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;
-        pDevice->dev->last_rx = jiffies;
-    }
-
-    pDevice->pCurrRD[uIdx]=pRD;
-
-    return works;
+		if (works++ > 15)
+			break;
+		if (device_receive_frame(pDevice, pRD)) {
+			if (!device_alloc_rx_buf(pDevice, pRD)) {
+				DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
+					"%s: can not allocate rx buf\n", pDevice->dev->name);
+				break;
+			}
+		}
+		pRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;
+		pDevice->dev->last_rx = jiffies;
+	}
+
+	pDevice->pCurrRD[uIdx] = pRD;
+
+	return works;
 }
 
 
 static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
 
-    PDEVICE_RD_INFO pRDInfo=pRD->pRDInfo;
+	PDEVICE_RD_INFO pRDInfo = pRD->pRDInfo;
 
 
-    pRDInfo->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
+	pRDInfo->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
 #ifdef	PLICE_DEBUG
 	//printk("device_alloc_rx_buf:skb is %x\n",pRDInfo->skb);
 #endif
-    if (pRDInfo->skb==NULL)
-        return false;
-    ASSERT(pRDInfo->skb);
-    pRDInfo->skb->dev = pDevice->dev;
-    pRDInfo->skb_dma = pci_map_single(pDevice->pcid, skb_tail_pointer(pRDInfo->skb),
-				      pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
-    *((unsigned int *) &(pRD->m_rd0RD0)) = 0; /* FIX cast */
-
-    pRD->m_rd0RD0.wResCount = cpu_to_le16(pDevice->rx_buf_sz);
-    pRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;
-    pRD->m_rd1RD1.wReqCount = cpu_to_le16(pDevice->rx_buf_sz);
-    pRD->buff_addr = cpu_to_le32(pRDInfo->skb_dma);
-
-    return true;
+	if (pRDInfo->skb == NULL)
+		return false;
+	ASSERT(pRDInfo->skb);
+	pRDInfo->skb->dev = pDevice->dev;
+	pRDInfo->skb_dma = pci_map_single(pDevice->pcid, skb_tail_pointer(pRDInfo->skb),
+					  pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
+	*((unsigned int *)&(pRD->m_rd0RD0)) = 0; /* FIX cast */
+
+	pRD->m_rd0RD0.wResCount = cpu_to_le16(pDevice->rx_buf_sz);
+	pRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;
+	pRD->m_rd1RD1.wReqCount = cpu_to_le16(pDevice->rx_buf_sz);
+	pRD->buff_addr = cpu_to_le32(pRDInfo->skb_dma);
+
+	return true;
 }
 
 
 
 bool device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
 
-    pDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-    if (pDeF->skb == NULL)
-        return false;
-    ASSERT(pDeF->skb);
-    pDeF->skb->dev = pDevice->dev;
+	pDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
+	if (pDeF->skb == NULL)
+		return false;
+	ASSERT(pDeF->skb);
+	pDeF->skb->dev = pDevice->dev;
 
-    return true;
+	return true;
 }
 
 
 
 static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
-    PSTxDesc                 pTD;
-    bool bFull=false;
-    int                      works = 0;
-    unsigned char byTsr0;
-    unsigned char byTsr1;
-    unsigned int	uFrameSize, uFIFOHeaderSize;
-    PSTxBufHead              pTxBufHead;
-    struct net_device_stats* pStats = &pDevice->stats;
-    struct sk_buff*          skb;
-    unsigned int	uNodeIndex;
-    PSMgmtObject             pMgmt = pDevice->pMgmt;
-
-
-    for (pTD = pDevice->apTailTD[uIdx]; pDevice->iTDUsed[uIdx] >0; pTD = pTD->next) {
-
-        if (pTD->m_td0TD0.f1Owner == OWNED_BY_NIC)
-            break;
-        if (works++>15)
-            break;
-
-        byTsr0 = pTD->m_td0TD0.byTSR0;
-        byTsr1 = pTD->m_td0TD0.byTSR1;
-
-        //Only the status of first TD in the chain is correct
-        if (pTD->m_td1TD1.byTCR & TCR_STP) {
-
-            if ((pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0) {
-                uFIFOHeaderSize = pTD->pTDInfo->dwHeaderLength;
-                uFrameSize = pTD->pTDInfo->dwReqCount - uFIFOHeaderSize;
-                pTxBufHead = (PSTxBufHead) (pTD->pTDInfo->buf);
-                // Update the statistics based on the Transmit status
-                // now, we DONT check TSR0_CDH
-
-                STAvUpdateTDStatCounter(&pDevice->scStatistic,
-                        byTsr0, byTsr1,
-                        (unsigned char *)(pTD->pTDInfo->buf + uFIFOHeaderSize),
-                        uFrameSize, uIdx);
-
-
-                BSSvUpdateNodeTxCounter(pDevice,
-                         byTsr0, byTsr1,
-                         (unsigned char *)(pTD->pTDInfo->buf),
-                         uFIFOHeaderSize
-                         );
-
-                if ( !(byTsr1 & TSR1_TERR)) {
-                    if (byTsr0 != 0) {
-                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X].\n",
-                           (int)uIdx, byTsr1, byTsr0);
-                    }
-                    if ((pTxBufHead->wFragCtl & FRAGCTL_ENDFRAG) != FRAGCTL_NONFRAG) {
-                        pDevice->s802_11Counter.TransmittedFragmentCount ++;
-                    }
-                    pStats->tx_packets++;
-                    pStats->tx_bytes += pTD->pTDInfo->skb->len;
-                }
-                else {
-                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] dropped & tsr1[%02X] tsr0[%02X].\n",
-                           (int)uIdx, byTsr1, byTsr0);
-                    pStats->tx_errors++;
-                    pStats->tx_dropped++;
-                }
-            }
-
-            if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
-                if (pDevice->bEnableHostapd) {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx call back netif.. \n");
-                    skb = pTD->pTDInfo->skb;
-	                skb->dev = pDevice->apdev;
-			skb_reset_mac_header(skb);
-	                skb->pkt_type = PACKET_OTHERHOST;
-    	            //skb->protocol = htons(ETH_P_802_2);
-	                memset(skb->cb, 0, sizeof(skb->cb));
-	                netif_rx(skb);
-	            }
-            }
-
-            if (byTsr1 & TSR1_TERR) {
-            if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
-                          (int)uIdx, byTsr1, byTsr0);
-            }
-
-//                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
+	PSTxDesc                 pTD;
+	bool bFull = false;
+	int                      works = 0;
+	unsigned char byTsr0;
+	unsigned char byTsr1;
+	unsigned int	uFrameSize, uFIFOHeaderSize;
+	PSTxBufHead              pTxBufHead;
+	struct net_device_stats *pStats = &pDevice->stats;
+	struct sk_buff *skb;
+	unsigned int	uNodeIndex;
+	PSMgmtObject             pMgmt = pDevice->pMgmt;
+
+
+	for (pTD = pDevice->apTailTD[uIdx]; pDevice->iTDUsed[uIdx] > 0; pTD = pTD->next) {
+
+		if (pTD->m_td0TD0.f1Owner == OWNED_BY_NIC)
+			break;
+		if (works++ > 15)
+			break;
+
+		byTsr0 = pTD->m_td0TD0.byTSR0;
+		byTsr1 = pTD->m_td0TD0.byTSR1;
+
+		//Only the status of first TD in the chain is correct
+		if (pTD->m_td1TD1.byTCR & TCR_STP) {
+
+			if ((pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0) {
+				uFIFOHeaderSize = pTD->pTDInfo->dwHeaderLength;
+				uFrameSize = pTD->pTDInfo->dwReqCount - uFIFOHeaderSize;
+				pTxBufHead = (PSTxBufHead) (pTD->pTDInfo->buf);
+				// Update the statistics based on the Transmit status
+				// now, we DONT check TSR0_CDH
+
+				STAvUpdateTDStatCounter(&pDevice->scStatistic,
+							byTsr0, byTsr1,
+							(unsigned char *)(pTD->pTDInfo->buf + uFIFOHeaderSize),
+							uFrameSize, uIdx);
+
+
+				BSSvUpdateNodeTxCounter(pDevice,
+							byTsr0, byTsr1,
+							(unsigned char *)(pTD->pTDInfo->buf),
+							uFIFOHeaderSize
+					);
+
+				if (!(byTsr1 & TSR1_TERR)) {
+					if (byTsr0 != 0) {
+						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X].\n",
+							(int)uIdx, byTsr1, byTsr0);
+					}
+					if ((pTxBufHead->wFragCtl & FRAGCTL_ENDFRAG) != FRAGCTL_NONFRAG) {
+						pDevice->s802_11Counter.TransmittedFragmentCount++;
+					}
+					pStats->tx_packets++;
+					pStats->tx_bytes += pTD->pTDInfo->skb->len;
+				}
+				else {
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Tx[%d] dropped & tsr1[%02X] tsr0[%02X].\n",
+						(int)uIdx, byTsr1, byTsr0);
+					pStats->tx_errors++;
+					pStats->tx_dropped++;
+				}
+			}
+
+			if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
+				if (pDevice->bEnableHostapd) {
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx call back netif.. \n");
+					skb = pTD->pTDInfo->skb;
+					skb->dev = pDevice->apdev;
+					skb_reset_mac_header(skb);
+					skb->pkt_type = PACKET_OTHERHOST;
+					//skb->protocol = htons(ETH_P_802_2);
+					memset(skb->cb, 0, sizeof(skb->cb));
+					netif_rx(skb);
+				}
+			}
+
+			if (byTsr1 & TSR1_TERR) {
+				if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
+						(int)uIdx, byTsr1, byTsr0);
+				}
+
+//                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
 //                          (int)uIdx, byTsr1, byTsr0);
 
-                if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) &&
-                    (pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)) {
-                    unsigned short wAID;
-                    unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
-
-                    skb = pTD->pTDInfo->skb;
-                    if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data), &uNodeIndex)) {
-                        if (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {
-                            skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);
-                            pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;
-                            // set tx map
-                            wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
-                            pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
-                            pTD->pTDInfo->byFlags &= ~(TD_FLAGS_NETIF_SKB);
-                            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx_srv:tx fail re-queue sta index= %d, QueCnt= %d\n"
-                                    ,(int)uNodeIndex, pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt);
-                            pStats->tx_errors--;
-                            pStats->tx_dropped--;
-                        }
-                    }
-                }
-            }
-            device_free_tx_buf(pDevice,pTD);
-            pDevice->iTDUsed[uIdx]--;
-        }
-    }
-
-
-    if (uIdx == TYPE_AC0DMA) {
-        // RESERV_AC0DMA reserved for relay
-
-        if (AVAIL_TD(pDevice, uIdx) < RESERV_AC0DMA) {
-            bFull = true;
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " AC0DMA is Full = %d\n", pDevice->iTDUsed[uIdx]);
-        }
-        if (netif_queue_stopped(pDevice->dev) && (bFull==false)){
-            netif_wake_queue(pDevice->dev);
-        }
-    }
-
-
-    pDevice->apTailTD[uIdx] = pTD;
-
-    return works;
+				if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) &&
+				    (pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)) {
+					unsigned short wAID;
+					unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
+
+					skb = pTD->pTDInfo->skb;
+					if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data), &uNodeIndex)) {
+						if (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {
+							skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);
+							pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;
+							// set tx map
+							wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
+							pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
+							pTD->pTDInfo->byFlags &= ~(TD_FLAGS_NETIF_SKB);
+							DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx_srv:tx fail re-queue sta index= %d, QueCnt= %d\n"
+								, (int)uNodeIndex, pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt);
+							pStats->tx_errors--;
+							pStats->tx_dropped--;
+						}
+					}
+				}
+			}
+			device_free_tx_buf(pDevice, pTD);
+			pDevice->iTDUsed[uIdx]--;
+		}
+	}
+
+
+	if (uIdx == TYPE_AC0DMA) {
+		// RESERV_AC0DMA reserved for relay
+
+		if (AVAIL_TD(pDevice, uIdx) < RESERV_AC0DMA) {
+			bFull = true;
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " AC0DMA is Full = %d\n", pDevice->iTDUsed[uIdx]);
+		}
+		if (netif_queue_stopped(pDevice->dev) && (bFull == false)) {
+			netif_wake_queue(pDevice->dev);
+		}
+	}
+
+
+	pDevice->apTailTD[uIdx] = pTD;
+
+	return works;
 }
 
 
 static void device_error(PSDevice pDevice, unsigned short status) {
 
-    if (status & ISR_FETALERR) {
-        DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
-            "%s: Hardware fatal error.\n",
-            pDevice->dev->name);
-        netif_stop_queue(pDevice->dev);
-        del_timer(&pDevice->sTimerCommand);
-        del_timer(&(pDevice->pMgmt->sTimerSecondCallback));
-        pDevice->bCmdRunning = false;
-        MACbShutdown(pDevice->PortOffset);
-        return;
-    }
+	if (status & ISR_FETALERR) {
+		DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
+			"%s: Hardware fatal error.\n",
+			pDevice->dev->name);
+		netif_stop_queue(pDevice->dev);
+		del_timer(&pDevice->sTimerCommand);
+		del_timer(&(pDevice->pMgmt->sTimerSecondCallback));
+		pDevice->bCmdRunning = false;
+		MACbShutdown(pDevice->PortOffset);
+		return;
+	}
 
 }
 
 static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc) {
-    PDEVICE_TD_INFO  pTDInfo=pDesc->pTDInfo;
-    struct sk_buff* skb=pTDInfo->skb;
+	PDEVICE_TD_INFO  pTDInfo = pDesc->pTDInfo;
+	struct sk_buff *skb = pTDInfo->skb;
 
-    // pre-allocated buf_dma can't be unmapped.
-    if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma)) {
-        pci_unmap_single(pDevice->pcid,pTDInfo->skb_dma,skb->len,
-              PCI_DMA_TODEVICE);
-    }
+	// pre-allocated buf_dma can't be unmapped.
+	if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma)) {
+		pci_unmap_single(pDevice->pcid, pTDInfo->skb_dma, skb->len,
+				 PCI_DMA_TODEVICE);
+	}
 
-    if ((pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0)
-        dev_kfree_skb_irq(skb);
+	if ((pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0)
+		dev_kfree_skb_irq(skb);
 
-    pTDInfo->skb_dma = 0;
-    pTDInfo->skb = 0;
-    pTDInfo->byFlags = 0;
+	pTDInfo->skb_dma = 0;
+	pTDInfo->skb = 0;
+	pTDInfo->byFlags = 0;
 }
 
 
@@ -1822,11 +1822,11 @@ void	InitRxManagementQueue(PSDevice  pDevice)
 
 //PLICE_DEBUG ->
 int MlmeThread(
-     void * Context)
+	void *Context)
 {
 	PSDevice	pDevice =  (PSDevice) Context;
 	PSRxMgmtPacket			pRxMgmtPacket;
-	// int i ;
+	// int i;
 	//complete(&pDevice->notify);
 //printk("Enter MngWorkItem,Queue packet num is %d\n",pDevice->rxManeQueue.packet_num);
 
@@ -1836,31 +1836,31 @@ int MlmeThread(
 	while (1)
 	{
 
-	//printk("DDDD\n");
-	//down(&pDevice->mlme_semaphore);
-        // pRxMgmtPacket =  DeQueue(pDevice);
+		//printk("DDDD\n");
+		//down(&pDevice->mlme_semaphore);
+		// pRxMgmtPacket =  DeQueue(pDevice);
 #if 1
 		spin_lock_irq(&pDevice->lock);
-		 while(pDevice->rxManeQueue.packet_num != 0)
-	 	{
-			 pRxMgmtPacket =  DeQueue(pDevice);
-        			//pDevice;
-        			//DequeueManageObject(pDevice->FirstRecvMngList, pDevice->LastRecvMngList);
+		while (pDevice->rxManeQueue.packet_num != 0)
+		{
+			pRxMgmtPacket = DeQueue(pDevice);
+			//pDevice;
+			//DequeueManageObject(pDevice->FirstRecvMngList, pDevice->LastRecvMngList);
 			vMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);
 			//printk("packet_num is %d\n",pDevice->rxManeQueue.packet_num);
 
-		 }
+		}
 		spin_unlock_irq(&pDevice->lock);
 		if (mlme_kill == 0)
-		break;
+			break;
 		//udelay(200);
 #endif
-	//printk("Before schedule thread jiffies is %x\n",jiffies);
-	schedule();
-	//printk("after schedule thread jiffies is %x\n",jiffies);
-	if (mlme_kill == 0)
-		break;
-	//printk("i is %d\n",i);
+		//printk("Before schedule thread jiffies is %x\n",jiffies);
+		schedule();
+		//printk("after schedule thread jiffies is %x\n",jiffies);
+		if (mlme_kill == 0)
+			break;
+		//printk("i is %d\n",i);
 	}
 
 #endif
@@ -1871,52 +1871,52 @@ int MlmeThread(
 
 
 static int  device_open(struct net_device *dev) {
-    PSDevice    pDevice=(PSDevice) netdev_priv(dev);
-    int i;
+	PSDevice pDevice = (PSDevice)netdev_priv(dev);
+	int i;
 #ifdef WPA_SM_Transtatus
-    extern SWPAResult wpa_Result;
+	extern SWPAResult wpa_Result;
 #endif
 
-    pDevice->rx_buf_sz = PKT_BUF_SZ;
-    if (!device_init_rings(pDevice)) {
-        return -ENOMEM;
-    }
+	pDevice->rx_buf_sz = PKT_BUF_SZ;
+	if (!device_init_rings(pDevice)) {
+		return -ENOMEM;
+	}
 //2008-5-13 <add> by chester
-    i=request_irq(pDevice->pcid->irq, &device_intr, IRQF_SHARED, dev->name, dev);
-    if (i)
-        return i;
+	i = request_irq(pDevice->pcid->irq, &device_intr, IRQF_SHARED, dev->name, dev);
+	if (i)
+		return i;
 	//printk("DEBUG1\n");
 #ifdef WPA_SM_Transtatus
-     memset(wpa_Result.ifname,0,sizeof(wpa_Result.ifname));
-     wpa_Result.proto = 0;
-     wpa_Result.key_mgmt = 0;
-     wpa_Result.eap_type = 0;
-     wpa_Result.authenticated = false;
-     pDevice->fWPA_Authened = false;
+	memset(wpa_Result.ifname, 0, sizeof(wpa_Result.ifname));
+	wpa_Result.proto = 0;
+	wpa_Result.key_mgmt = 0;
+	wpa_Result.eap_type = 0;
+	wpa_Result.authenticated = false;
+	pDevice->fWPA_Authened = false;
 #endif
-DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device init rd0 ring\n");
-device_init_rd0_ring(pDevice);
-    device_init_rd1_ring(pDevice);
-    device_init_defrag_cb(pDevice);
-    device_init_td0_ring(pDevice);
-    device_init_td1_ring(pDevice);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device init rd0 ring\n");
+	device_init_rd0_ring(pDevice);
+	device_init_rd1_ring(pDevice);
+	device_init_defrag_cb(pDevice);
+	device_init_td0_ring(pDevice);
+	device_init_td1_ring(pDevice);
 //    VNTWIFIvSet11h(pDevice->pMgmt, pDevice->b11hEnable);
 
 
-    if (pDevice->bDiversityRegCtlON) {
-        device_init_diversity_timer(pDevice);
-    }
-    vMgrObjectInit(pDevice);
-    vMgrTimerInit(pDevice);
+	if (pDevice->bDiversityRegCtlON) {
+		device_init_diversity_timer(pDevice);
+	}
+	vMgrObjectInit(pDevice);
+	vMgrTimerInit(pDevice);
 
 //PLICE_DEBUG->
 #ifdef	TASK_LET
-	tasklet_init (&pDevice->RxMngWorkItem,(void *)MngWorkItem,(unsigned long )pDevice);
+	tasklet_init(&pDevice->RxMngWorkItem, (void *)MngWorkItem, (unsigned long)pDevice);
 #endif
 #ifdef	THREAD
 	InitRxManagementQueue(pDevice);
 	mlme_kill = 0;
-	mlme_task = kthread_run(MlmeThread,(void *) pDevice, "MLME");
+	mlme_task = kthread_run(MlmeThread, (void *)pDevice, "MLME");
 	if (IS_ERR(mlme_task)) {
 		printk("thread create fail\n");
 		return -1;
@@ -1934,1155 +1934,1155 @@ device_init_rd0_ring(pDevice);
 
 
 
-  // if (( SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RADIOCTL)&0x06)==0x04)
-    //    return -ENOMEM;
-DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
+	// if ((SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RADIOCTL)&0x06)==0x04)
+	//    return -ENOMEM;
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
 	device_init_registers(pDevice, DEVICE_INIT_COLD);
-    MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
-    memcpy(pDevice->pMgmt->abyMACAddr, pDevice->abyCurrentNetAddr, ETH_ALEN);
-    device_set_multi(pDevice->dev);
+	MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
+	memcpy(pDevice->pMgmt->abyMACAddr, pDevice->abyCurrentNetAddr, ETH_ALEN);
+	device_set_multi(pDevice->dev);
 
-    // Init for Key Management
-    KeyvInitTable(&pDevice->sKey, pDevice->PortOffset);
-    add_timer(&(pDevice->pMgmt->sTimerSecondCallback));
+	// Init for Key Management
+	KeyvInitTable(&pDevice->sKey, pDevice->PortOffset);
+	add_timer(&(pDevice->pMgmt->sTimerSecondCallback));
 
-	#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 	/*
-     pDevice->bwextstep0 = false;
-     pDevice->bwextstep1 = false;
-     pDevice->bwextstep2 = false;
-     pDevice->bwextstep3 = false;
-     */
-       pDevice->bwextcount=0;
-     pDevice->bWPASuppWextEnabled = false;
+	  pDevice->bwextstep0 = false;
+	  pDevice->bwextstep1 = false;
+	  pDevice->bwextstep2 = false;
+	  pDevice->bwextstep3 = false;
+	*/
+	pDevice->bwextcount = 0;
+	pDevice->bWPASuppWextEnabled = false;
 #endif
-    pDevice->byReAssocCount = 0;
-   pDevice->bWPADEVUp = false;
-    // Patch: if WEP key already set by iwconfig but device not yet open
-    if ((pDevice->bEncryptionEnable == true) && (pDevice->bTransmitKey == true)) {
-        KeybSetDefaultKey(&(pDevice->sKey),
-                            (unsigned long)(pDevice->byKeyIndex | (1 << 31)),
-                            pDevice->uKeyLength,
-                            NULL,
-                            pDevice->abyKey,
-                            KEY_CTL_WEP,
-                            pDevice->PortOffset,
-                            pDevice->byLocalID
-                          );
-         pDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;
-    }
+	pDevice->byReAssocCount = 0;
+	pDevice->bWPADEVUp = false;
+	// Patch: if WEP key already set by iwconfig but device not yet open
+	if ((pDevice->bEncryptionEnable == true) && (pDevice->bTransmitKey == true)) {
+		KeybSetDefaultKey(&(pDevice->sKey),
+				  (unsigned long)(pDevice->byKeyIndex | (1 << 31)),
+				  pDevice->uKeyLength,
+				  NULL,
+				  pDevice->abyKey,
+				  KEY_CTL_WEP,
+				  pDevice->PortOffset,
+				  pDevice->byLocalID
+			);
+		pDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;
+	}
 
 //printk("DEBUG2\n");
 
 
-DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call MACvIntEnable\n");
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call MACvIntEnable\n");
 	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
 
-    if (pDevice->pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-        bScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);
+	if (pDevice->pMgmt->eConfigMode == WMAC_CONFIG_AP) {
+		bScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);
 	}
 	else {
-        bScheduleCommand((void *)pDevice, WLAN_CMD_BSSID_SCAN, NULL);
-        bScheduleCommand((void *)pDevice, WLAN_CMD_SSID, NULL);
-    }
-    pDevice->flags |=DEVICE_FLAGS_OPENED;
+		bScheduleCommand((void *)pDevice, WLAN_CMD_BSSID_SCAN, NULL);
+		bScheduleCommand((void *)pDevice, WLAN_CMD_SSID, NULL);
+	}
+	pDevice->flags |= DEVICE_FLAGS_OPENED;
 
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success.. \n");
-    return 0;
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success.. \n");
+	return 0;
 }
 
 
 static int  device_close(struct net_device *dev) {
-    PSDevice  pDevice=(PSDevice) netdev_priv(dev);
-    PSMgmtObject     pMgmt = pDevice->pMgmt;
- //PLICE_DEBUG->
+	PSDevice  pDevice = (PSDevice)netdev_priv(dev);
+	PSMgmtObject     pMgmt = pDevice->pMgmt;
+	//PLICE_DEBUG->
 #ifdef	THREAD
 	mlme_kill = 0;
 #endif
 //PLICE_DEBUG<-
 //2007-1121-02<Add>by EinsnLiu
-    if (pDevice->bLinkPass) {
-	bScheduleCommand((void *)pDevice, WLAN_CMD_DISASSOCIATE, NULL);
-        mdelay(30);
-    }
+	if (pDevice->bLinkPass) {
+		bScheduleCommand((void *)pDevice, WLAN_CMD_DISASSOCIATE, NULL);
+		mdelay(30);
+	}
 #ifdef TxInSleep
-    del_timer(&pDevice->sTimerTxData);
+	del_timer(&pDevice->sTimerTxData);
 #endif
-    del_timer(&pDevice->sTimerCommand);
-    del_timer(&pMgmt->sTimerSecondCallback);
-    if (pDevice->bDiversityRegCtlON) {
-        del_timer(&pDevice->TimerSQ3Tmax1);
-        del_timer(&pDevice->TimerSQ3Tmax2);
-        del_timer(&pDevice->TimerSQ3Tmax3);
-    }
+	del_timer(&pDevice->sTimerCommand);
+	del_timer(&pMgmt->sTimerSecondCallback);
+	if (pDevice->bDiversityRegCtlON) {
+		del_timer(&pDevice->TimerSQ3Tmax1);
+		del_timer(&pDevice->TimerSQ3Tmax2);
+		del_timer(&pDevice->TimerSQ3Tmax3);
+	}
 
 #ifdef	TASK_LET
 	tasklet_kill(&pDevice->RxMngWorkItem);
 #endif
-     netif_stop_queue(dev);
-    pDevice->bCmdRunning = false;
-    MACbShutdown(pDevice->PortOffset);
-    MACbSoftwareReset(pDevice->PortOffset);
-    CARDbRadioPowerOff(pDevice);
-
-    pDevice->bLinkPass = false;
-    memset(pMgmt->abyCurrBSSID, 0, 6);
-    pMgmt->eCurrState = WMAC_STATE_IDLE;
-    device_free_td0_ring(pDevice);
-    device_free_td1_ring(pDevice);
-    device_free_rd0_ring(pDevice);
-    device_free_rd1_ring(pDevice);
-    device_free_frag_buf(pDevice);
-    device_free_rings(pDevice);
-    BSSvClearNodeDBTable(pDevice, 0);
-    free_irq(dev->irq, dev);
-    pDevice->flags &=(~DEVICE_FLAGS_OPENED);
+	netif_stop_queue(dev);
+	pDevice->bCmdRunning = false;
+	MACbShutdown(pDevice->PortOffset);
+	MACbSoftwareReset(pDevice->PortOffset);
+	CARDbRadioPowerOff(pDevice);
+
+	pDevice->bLinkPass = false;
+	memset(pMgmt->abyCurrBSSID, 0, 6);
+	pMgmt->eCurrState = WMAC_STATE_IDLE;
+	device_free_td0_ring(pDevice);
+	device_free_td1_ring(pDevice);
+	device_free_rd0_ring(pDevice);
+	device_free_rd1_ring(pDevice);
+	device_free_frag_buf(pDevice);
+	device_free_rings(pDevice);
+	BSSvClearNodeDBTable(pDevice, 0);
+	free_irq(dev->irq, dev);
+	pDevice->flags &= (~DEVICE_FLAGS_OPENED);
 	//2008-0714-01<Add>by chester
-device_release_WPADEV(pDevice);
+	device_release_WPADEV(pDevice);
 //PLICE_DEBUG->
 	//tasklet_kill(&pDevice->RxMngWorkItem);
 //PLICE_DEBUG<-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close.. \n");
-    return 0;
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close.. \n");
+	return 0;
 }
 
 
 
 static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
-    PSDevice        pDevice=netdev_priv(dev);
-    unsigned char *pbMPDU;
-    unsigned int cbMPDULen = 0;
+	PSDevice pDevice = netdev_priv(dev);
+	unsigned char *pbMPDU;
+	unsigned int cbMPDULen = 0;
 
 
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211\n");
-    spin_lock_irq(&pDevice->lock);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211\n");
+	spin_lock_irq(&pDevice->lock);
 
-    if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211, td0 <=0\n");
-        dev_kfree_skb_irq(skb);
-        spin_unlock_irq(&pDevice->lock);
-        return 0;
-    }
+	if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211, td0 <=0\n");
+		dev_kfree_skb_irq(skb);
+		spin_unlock_irq(&pDevice->lock);
+		return 0;
+	}
 
-    if (pDevice->bStopTx0Pkt == true) {
-        dev_kfree_skb_irq(skb);
-        spin_unlock_irq(&pDevice->lock);
-        return 0;
-    }
+	if (pDevice->bStopTx0Pkt == true) {
+		dev_kfree_skb_irq(skb);
+		spin_unlock_irq(&pDevice->lock);
+		return 0;
+	}
 
-    cbMPDULen = skb->len;
-    pbMPDU = skb->data;
+	cbMPDULen = skb->len;
+	pbMPDU = skb->data;
 
-    vDMA0_tx_80211(pDevice, skb, pbMPDU, cbMPDULen);
+	vDMA0_tx_80211(pDevice, skb, pbMPDU, cbMPDULen);
 
-    spin_unlock_irq(&pDevice->lock);
+	spin_unlock_irq(&pDevice->lock);
 
-    return 0;
+	return 0;
 
 }
 
 
 
 bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeIndex) {
-    PSMgmtObject    pMgmt = pDevice->pMgmt;
-    PSTxDesc        pHeadTD, pLastTD;
-    unsigned int cbFrameBodySize;
-    unsigned int uMACfragNum;
-    unsigned char byPktType;
-    bool bNeedEncryption = false;
-    PSKeyItem       pTransmitKey = NULL;
-    unsigned int cbHeaderSize;
-    unsigned int ii;
-    SKeyItem        STempKey;
+	PSMgmtObject    pMgmt = pDevice->pMgmt;
+	PSTxDesc        pHeadTD, pLastTD;
+	unsigned int cbFrameBodySize;
+	unsigned int uMACfragNum;
+	unsigned char byPktType;
+	bool bNeedEncryption = false;
+	PSKeyItem       pTransmitKey = NULL;
+	unsigned int cbHeaderSize;
+	unsigned int ii;
+	SKeyItem        STempKey;
 //    unsigned char byKeyIndex = 0;
 
 
-    if (pDevice->bStopTx0Pkt == true) {
-        dev_kfree_skb_irq(skb);
-        return false;
-    }
-
-    if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
-        dev_kfree_skb_irq(skb);
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, td0 <=0\n");
-        return false;
-    }
-
-    if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-        if (pDevice->uAssocCount == 0) {
-            dev_kfree_skb_irq(skb);
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, assocCount = 0\n");
-            return false;
-        }
-    }
-
-    pHeadTD = pDevice->apCurrTD[TYPE_TXDMA0];
-
-    pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
-
-    memcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)(skb->data), ETH_HLEN);
-    cbFrameBodySize = skb->len - ETH_HLEN;
-
-    // 802.1H
-    if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN) {
-        cbFrameBodySize += 8;
-    }
-    uMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);
-
-    if ( uMACfragNum > AVAIL_TD(pDevice, TYPE_TXDMA0)) {
-        dev_kfree_skb_irq(skb);
-        return false;
-    }
-    byPktType = (unsigned char)pDevice->byPacketType;
-
-
-    if (pDevice->bFixRate) {
-        if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
-            if (pDevice->uConnectionRate >= RATE_11M) {
-                pDevice->wCurrentRate = RATE_11M;
-            } else {
-                pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
-            }
-        } else {
-            if (pDevice->uConnectionRate >= RATE_54M)
-                pDevice->wCurrentRate = RATE_54M;
-            else
-                pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
-        }
-    }
-    else {
-        pDevice->wCurrentRate = pDevice->pMgmt->sNodeDBTable[uNodeIndex].wTxDataRate;
-    }
-
-    //preamble type
-    if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {
-        pDevice->byPreambleType = pDevice->byShortPreamble;
-    }
-    else {
-        pDevice->byPreambleType = PREAMBLE_LONG;
-    }
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
-
-
-    if (pDevice->wCurrentRate <= RATE_11M) {
-        byPktType = PK_TYPE_11B;
-    } else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
-        byPktType = PK_TYPE_11A;
-    } else {
-        if (pDevice->bProtectMode == true) {
-            byPktType = PK_TYPE_11GB;
-        } else {
-            byPktType = PK_TYPE_11GA;
-        }
-    }
-
-    if (pDevice->bEncryptionEnable == true)
-        bNeedEncryption = true;
-
-    if (pDevice->bEnableHostWEP) {
-        pTransmitKey = &STempKey;
-        pTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;
-        pTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;
-        pTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;
-        pTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;
-        pTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;
-        memcpy(pTransmitKey->abyKey,
-            &pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],
-            pTransmitKey->uKeyLength
-            );
-    }
-    vGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,
-                        cbFrameBodySize, TYPE_TXDMA0, pHeadTD,
-                        &pDevice->sTxEthHeader, (unsigned char *)skb->data, pTransmitKey, uNodeIndex,
-                        &uMACfragNum,
-                        &cbHeaderSize
-                        );
-
-    if (MACbIsRegBitsOn(pDevice->PortOffset, MAC_REG_PSCTL, PSCTL_PS)) {
-        // Disable PS
-        MACbPSWakeup(pDevice->PortOffset);
-    }
-
-    pDevice->bPWBitOn = false;
-
-    pLastTD = pHeadTD;
-    for (ii = 0; ii < uMACfragNum; ii++) {
-        // Poll Transmit the adapter
-        wmb();
-        pHeadTD->m_td0TD0.f1Owner=OWNED_BY_NIC;
-        wmb();
-        if (ii == (uMACfragNum - 1))
-            pLastTD = pHeadTD;
-        pHeadTD = pHeadTD->next;
-    }
-
-    // Save the information needed by the tx interrupt handler
-    // to complete the Send request
-    pLastTD->pTDInfo->skb = skb;
-    pLastTD->pTDInfo->byFlags = 0;
-    pLastTD->pTDInfo->byFlags |= TD_FLAGS_NETIF_SKB;
-
-    pDevice->apCurrTD[TYPE_TXDMA0] = pHeadTD;
-
-    MACvTransmit0(pDevice->PortOffset);
-
-
-    return true;
-}
+	if (pDevice->bStopTx0Pkt == true) {
+		dev_kfree_skb_irq(skb);
+		return false;
+	}
 
-//TYPE_AC0DMA data tx
-static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
-    PSDevice pDevice=netdev_priv(dev);
-
-    PSMgmtObject    pMgmt = pDevice->pMgmt;
-    PSTxDesc        pHeadTD, pLastTD;
-    unsigned int uNodeIndex = 0;
-    unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
-    unsigned short wAID;
-    unsigned int uMACfragNum = 1;
-    unsigned int cbFrameBodySize;
-    unsigned char byPktType;
-    unsigned int cbHeaderSize;
-    bool bNeedEncryption = false;
-    PSKeyItem       pTransmitKey = NULL;
-    SKeyItem        STempKey;
-    unsigned int ii;
-    bool bTKIP_UseGTK = false;
-    bool bNeedDeAuth = false;
-    unsigned char *pbyBSSID;
-    bool bNodeExist = false;
-
-
-
-    spin_lock_irq(&pDevice->lock);
-    if (pDevice->bLinkPass == false) {
-        dev_kfree_skb_irq(skb);
-        spin_unlock_irq(&pDevice->lock);
-        return 0;
-    }
-
-    if (pDevice->bStopDataPkt) {
-        dev_kfree_skb_irq(skb);
-        spin_unlock_irq(&pDevice->lock);
-        return 0;
-    }
-
-
-    if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-        if (pDevice->uAssocCount == 0) {
-            dev_kfree_skb_irq(skb);
-            spin_unlock_irq(&pDevice->lock);
-            return 0;
-        }
-        if (is_multicast_ether_addr((unsigned char *)(skb->data))) {
-            uNodeIndex = 0;
-            bNodeExist = true;
-            if (pMgmt->sNodeDBTable[0].bPSEnable) {
-                skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skb);
-                pMgmt->sNodeDBTable[0].wEnQueueCnt++;
-                // set tx map
-                pMgmt->abyPSTxMap[0] |= byMask[0];
-                spin_unlock_irq(&pDevice->lock);
-                return 0;
-            }
-}else {
-            if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data), &uNodeIndex)) {
-                if (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {
-                    skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);
-                    pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;
-                    // set tx map
-                    wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
-                    pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Set:pMgmt->abyPSTxMap[%d]= %d\n",
-                             (wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);
-                    spin_unlock_irq(&pDevice->lock);
-                    return 0;
-                }
-
-                if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {
-                    pDevice->byPreambleType = pDevice->byShortPreamble;
-
-                }else {
-                    pDevice->byPreambleType = PREAMBLE_LONG;
-                }
-                bNodeExist = true;
-
-            }
-        }
-
-        if (bNodeExist == false) {
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Unknown STA not found in node DB \n");
-            dev_kfree_skb_irq(skb);
-            spin_unlock_irq(&pDevice->lock);
-            return 0;
-        }
-    }
-
-    pHeadTD = pDevice->apCurrTD[TYPE_AC0DMA];
-
-    pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
-
-
-    memcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)(skb->data), ETH_HLEN);
-    cbFrameBodySize = skb->len - ETH_HLEN;
-    // 802.1H
-    if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN) {
-        cbFrameBodySize += 8;
-    }
-
-
-    if (pDevice->bEncryptionEnable == true) {
-        bNeedEncryption = true;
-        // get Transmit key
-        do {
-            if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
-                (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
-                pbyBSSID = pDevice->abyBSSID;
-                // get pairwise key
-                if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == false) {
-                    // get group key
-                    if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == true) {
-                        bTKIP_UseGTK = true;
-                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");
-                        break;
-                    }
-                } else {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get PTK.\n");
-                    break;
-                }
-            }else if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
-
-                pbyBSSID = pDevice->sTxEthHeader.abyDstAddr;  //TO_DS = 0 and FROM_DS = 0 --> 802.11 MAC Address1
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS Serach Key: \n");
-                for (ii = 0; ii< 6; ii++)
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"%x \n", *(pbyBSSID+ii));
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"\n");
-
-                // get pairwise key
-                if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == true)
-                    break;
-            }
-            // get group key
-            pbyBSSID = pDevice->abyBroadcastAddr;
-            if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == false) {
-                pTransmitKey = NULL;
-                if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
-                }
-                else
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"NOT IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
-            } else {
-                bTKIP_UseGTK = true;
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");
-            }
-        } while(false);
-    }
-
-    if (pDevice->bEnableHostWEP) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"acdma0: STA index %d\n", uNodeIndex);
-        if (pDevice->bEncryptionEnable == true) {
-            pTransmitKey = &STempKey;
-            pTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;
-            pTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;
-            pTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;
-            pTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;
-            pTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;
-            memcpy(pTransmitKey->abyKey,
-                &pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],
-                pTransmitKey->uKeyLength
-                );
-         }
-    }
-
-    uMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);
-
-    if (uMACfragNum > AVAIL_TD(pDevice, TYPE_AC0DMA)) {
-        DBG_PRT(MSG_LEVEL_ERR, KERN_DEBUG "uMACfragNum > AVAIL_TD(TYPE_AC0DMA) = %d\n", uMACfragNum);
-        dev_kfree_skb_irq(skb);
-        spin_unlock_irq(&pDevice->lock);
-        return 0;
-    }
-
-    if (pTransmitKey != NULL) {
-        if ((pTransmitKey->byCipherSuite == KEY_CTL_WEP) &&
-            (pTransmitKey->uKeyLength == WLAN_WEP232_KEYLEN)) {
-            uMACfragNum = 1; //WEP256 doesn't support fragment
-        }
-    }
-
-    byPktType = (unsigned char)pDevice->byPacketType;
-
-    if (pDevice->bFixRate) {
-#ifdef	PLICE_DEBUG
-	printk("Fix Rate: PhyType is %d,ConnectionRate is %d\n",pDevice->eCurrentPHYType,pDevice->uConnectionRate);
-#endif
+	if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
+		dev_kfree_skb_irq(skb);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, td0 <=0\n");
+		return false;
+	}
 
-        if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
-            if (pDevice->uConnectionRate >= RATE_11M) {
-                pDevice->wCurrentRate = RATE_11M;
-            } else {
-                pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
-            }
-        } else {
-            if ((pDevice->eCurrentPHYType == PHY_TYPE_11A) &&
-                (pDevice->uConnectionRate <= RATE_6M)) {
-                pDevice->wCurrentRate = RATE_6M;
-            } else {
-                if (pDevice->uConnectionRate >= RATE_54M)
-                    pDevice->wCurrentRate = RATE_54M;
-                else
-                    pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
-
-            }
-        }
-        pDevice->byACKRate = (unsigned char) pDevice->wCurrentRate;
-        pDevice->byTopCCKBasicRate = RATE_1M;
-        pDevice->byTopOFDMBasicRate = RATE_6M;
-    }
-    else {
-        //auto rate
-    if (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {
-            if (pDevice->eCurrentPHYType != PHY_TYPE_11A) {
-                pDevice->wCurrentRate = RATE_1M;
-                pDevice->byACKRate = RATE_1M;
-                pDevice->byTopCCKBasicRate = RATE_1M;
-                pDevice->byTopOFDMBasicRate = RATE_6M;
-            } else {
-                pDevice->wCurrentRate = RATE_6M;
-                pDevice->byACKRate = RATE_6M;
-                pDevice->byTopCCKBasicRate = RATE_1M;
-                pDevice->byTopOFDMBasicRate = RATE_6M;
-            }
-        }
-        else {
-		VNTWIFIvGetTxRate(  pDevice->pMgmt,
-                                pDevice->sTxEthHeader.abyDstAddr,
-                                &(pDevice->wCurrentRate),
-                                &(pDevice->byACKRate),
-                                &(pDevice->byTopCCKBasicRate),
-                                &(pDevice->byTopOFDMBasicRate));
-
-
-		}
-    }
+	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+		if (pDevice->uAssocCount == 0) {
+			dev_kfree_skb_irq(skb);
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, assocCount = 0\n");
+			return false;
+		}
+	}
 
-//    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
+	pHeadTD = pDevice->apCurrTD[TYPE_TXDMA0];
 
-    if (pDevice->wCurrentRate <= RATE_11M) {
-        byPktType = PK_TYPE_11B;
-    } else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
-        byPktType = PK_TYPE_11A;
-    } else {
-        if (pDevice->bProtectMode == true) {
-            byPktType = PK_TYPE_11GB;
-        } else {
-            byPktType = PK_TYPE_11GA;
-        }
-    }
+	pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
 
-//#ifdef	PLICE_DEBUG
-//	printk("FIX RATE:CurrentRate is %d");
-//#endif
+	memcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)(skb->data), ETH_HLEN);
+	cbFrameBodySize = skb->len - ETH_HLEN;
 
-    if (bNeedEncryption == true) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ntohs Pkt Type=%04x\n", ntohs(pDevice->sTxEthHeader.wType));
-        if ((pDevice->sTxEthHeader.wType) == TYPE_PKT_802_1x) {
-            bNeedEncryption = false;
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Pkt Type=%04x\n", (pDevice->sTxEthHeader.wType));
-            if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
-                if (pTransmitKey == NULL) {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Don't Find TX KEY\n");
-                }
-                else {
-                    if (bTKIP_UseGTK == true) {
-                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"error: KEY is GTK!!~~\n");
-                    }
-                    else {
-                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
-                        bNeedEncryption = true;
-                    }
-                }
-            }
-
-            if (pDevice->byCntMeasure == 2) {
-                bNeedDeAuth = true;
-                pDevice->s802_11Counter.TKIPCounterMeasuresInvoked++;
-            }
-
-            if (pDevice->bEnableHostWEP) {
-                if ((uNodeIndex != 0) &&
-                    (pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex & PAIRWISE_KEY)) {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
-                    bNeedEncryption = true;
-                 }
-             }
-        }
-        else {
-            if (pTransmitKey == NULL) {
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"return no tx key\n");
-                dev_kfree_skb_irq(skb);
-                spin_unlock_irq(&pDevice->lock);
-                return 0;
-            }
-        }
-    }
+	// 802.1H
+	if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN) {
+		cbFrameBodySize += 8;
+	}
+	uMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);
 
+	if (uMACfragNum > AVAIL_TD(pDevice, TYPE_TXDMA0)) {
+		dev_kfree_skb_irq(skb);
+		return false;
+	}
+	byPktType = (unsigned char)pDevice->byPacketType;
 
-#ifdef	PLICE_DEBUG
-	//if (skb->len == 98)
-	//{
-	//	printk("ping:len is %d\n");
-	//}
-#endif
-    vGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,
-                        cbFrameBodySize, TYPE_AC0DMA, pHeadTD,
-                        &pDevice->sTxEthHeader, (unsigned char *)skb->data, pTransmitKey, uNodeIndex,
-                        &uMACfragNum,
-                        &cbHeaderSize
-                        );
-
-    if (MACbIsRegBitsOn(pDevice->PortOffset, MAC_REG_PSCTL, PSCTL_PS)) {
-        // Disable PS
-        MACbPSWakeup(pDevice->PortOffset);
-    }
-    pDevice->bPWBitOn = false;
-
-    pLastTD = pHeadTD;
-    for (ii = 0; ii < uMACfragNum; ii++) {
-        // Poll Transmit the adapter
-        wmb();
-        pHeadTD->m_td0TD0.f1Owner=OWNED_BY_NIC;
-        wmb();
-        if (ii == uMACfragNum - 1)
-            pLastTD = pHeadTD;
-        pHeadTD = pHeadTD->next;
-    }
-
-    // Save the information needed by the tx interrupt handler
-    // to complete the Send request
-    pLastTD->pTDInfo->skb = skb;
-    pLastTD->pTDInfo->byFlags = 0;
-    pLastTD->pTDInfo->byFlags |= TD_FLAGS_NETIF_SKB;
-#ifdef TxInSleep
-  pDevice->nTxDataTimeCout=0; //2008-8-21 chester <add> for send null packet
-  #endif
-    if (AVAIL_TD(pDevice, TYPE_AC0DMA) <= 1) {
-        netif_stop_queue(dev);
-    }
 
-    pDevice->apCurrTD[TYPE_AC0DMA] = pHeadTD;
-//#ifdef	PLICE_DEBUG
-	if (pDevice->bFixRate)
-	{
-		printk("FixRate:Rate is %d,TxPower is %d\n",pDevice->wCurrentRate,pDevice->byCurPwr);
+	if (pDevice->bFixRate) {
+		if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
+			if (pDevice->uConnectionRate >= RATE_11M) {
+				pDevice->wCurrentRate = RATE_11M;
+			} else {
+				pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
+			}
+		} else {
+			if (pDevice->uConnectionRate >= RATE_54M)
+				pDevice->wCurrentRate = RATE_54M;
+			else
+				pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
+		}
 	}
-	else
-	{
-		//printk("Auto Rate:Rate is %d,TxPower is %d\n",pDevice->wCurrentRate,pDevice->byCurPwr);
+	else {
+		pDevice->wCurrentRate = pDevice->pMgmt->sNodeDBTable[uNodeIndex].wTxDataRate;
 	}
-//#endif
-
-{
-    unsigned char Protocol_Version;    //802.1x Authentication
-    unsigned char Packet_Type;           //802.1x Authentication
-    unsigned char Descriptor_type;
-    unsigned short Key_info;
-bool bTxeapol_key = false;
-    Protocol_Version = skb->data[ETH_HLEN];
-    Packet_Type = skb->data[ETH_HLEN+1];
-    Descriptor_type = skb->data[ETH_HLEN+1+1+2];
-    Key_info = (skb->data[ETH_HLEN+1+1+2+1] << 8)|(skb->data[ETH_HLEN+1+1+2+2]);
-   if (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {
-           if(((Protocol_Version==1) ||(Protocol_Version==2)) &&
-	        (Packet_Type==3)) {  //802.1x OR eapol-key challenge frame transfer
-                        bTxeapol_key = true;
-		if((Descriptor_type==254)||(Descriptor_type==2)) {       //WPA or RSN
-                       if(!(Key_info & BIT3) &&   //group-key challenge
-			   (Key_info & BIT8) && (Key_info & BIT9)) {    //send 2/2 key
-			  pDevice->fWPA_Authened = true;
-			  if(Descriptor_type==254)
-			      printk("WPA ");
-			  else
-			      printk("WPA2 ");
-			  printk("Authentication completed!!\n");
-                        }
-		 }
-             }
-   }
-}
-
-    MACvTransmitAC0(pDevice->PortOffset);
-//    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0:pDevice->apCurrTD= %p\n", pHeadTD);
 
-    dev->trans_start = jiffies;
+	//preamble type
+	if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {
+		pDevice->byPreambleType = pDevice->byShortPreamble;
+	}
+	else {
+		pDevice->byPreambleType = PREAMBLE_LONG;
+	}
 
-    spin_unlock_irq(&pDevice->lock);
-    return 0;
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
 
-}
 
-static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
-    struct net_device* dev=dev_instance;
-    PSDevice     pDevice=(PSDevice) netdev_priv(dev);
-
-    int             max_count=0;
-    unsigned long dwMIBCounter=0;
-    PSMgmtObject    pMgmt = pDevice->pMgmt;
-    unsigned char byOrgPageSel=0;
-    int             handled = 0;
-    unsigned char byData = 0;
-    int             ii= 0;
-//    unsigned char byRSSI;
+	if (pDevice->wCurrentRate <= RATE_11M) {
+		byPktType = PK_TYPE_11B;
+	} else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
+		byPktType = PK_TYPE_11A;
+	} else {
+		if (pDevice->bProtectMode == true) {
+			byPktType = PK_TYPE_11GB;
+		} else {
+			byPktType = PK_TYPE_11GA;
+		}
+	}
 
+	if (pDevice->bEncryptionEnable == true)
+		bNeedEncryption = true;
+
+	if (pDevice->bEnableHostWEP) {
+		pTransmitKey = &STempKey;
+		pTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;
+		pTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;
+		pTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;
+		pTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;
+		pTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;
+		memcpy(pTransmitKey->abyKey,
+		       &pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],
+		       pTransmitKey->uKeyLength
+			);
+	}
+	vGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,
+			    cbFrameBodySize, TYPE_TXDMA0, pHeadTD,
+			    &pDevice->sTxEthHeader, (unsigned char *)skb->data, pTransmitKey, uNodeIndex,
+			    &uMACfragNum,
+			    &cbHeaderSize
+		);
+
+	if (MACbIsRegBitsOn(pDevice->PortOffset, MAC_REG_PSCTL, PSCTL_PS)) {
+		// Disable PS
+		MACbPSWakeup(pDevice->PortOffset);
+	}
 
-    MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
-
-    if (pDevice->dwIsr == 0)
-        return IRQ_RETVAL(handled);
-
-    if (pDevice->dwIsr == 0xffffffff) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwIsr = 0xffff\n");
-        return IRQ_RETVAL(handled);
-    }
-    /*
-      // 2008-05-21 <mark> by Richardtai, we can't read RSSI here, because no packet bound with RSSI
-
-    	if ((pDevice->dwIsr & ISR_RXDMA0) &&
-        (pDevice->byLocalID != REV_ID_VT3253_B0) &&
-        (pDevice->bBSSIDFilter == true)) {
-        // update RSSI
-        //BBbReadEmbedded(pDevice->PortOffset, 0x3E, &byRSSI);
-        //pDevice->uCurrRSSI = byRSSI;
-    }
-    */
-
-    handled = 1;
-    MACvIntDisable(pDevice->PortOffset);
-    spin_lock_irq(&pDevice->lock);
-
-    //Make sure current page is 0
-    VNSvInPortB(pDevice->PortOffset + MAC_REG_PAGE1SEL, &byOrgPageSel);
-    if (byOrgPageSel == 1) {
-        MACvSelectPage0(pDevice->PortOffset);
-    }
-    else
-        byOrgPageSel = 0;
-
-    MACvReadMIBCounter(pDevice->PortOffset, &dwMIBCounter);
-    // TBD....
-    // Must do this after doing rx/tx, cause ISR bit is slow
-    // than RD/TD write back
-    // update ISR counter
-    STAvUpdate802_11Counter(&pDevice->s802_11Counter, &pDevice->scStatistic , dwMIBCounter);
-    while (pDevice->dwIsr != 0) {
-
-        STAvUpdateIsrStatCounter(&pDevice->scStatistic, pDevice->dwIsr);
-        MACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);
-
-        if (pDevice->dwIsr & ISR_FETALERR){
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " ISR_FETALERR \n");
-            VNSvOutPortB(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, 0);
-            VNSvOutPortW(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, SOFTPWRCTL_SWPECTI);
-            device_error(pDevice, pDevice->dwIsr);
-        }
-
-        if (pDevice->byLocalID > REV_ID_VT3253_B1) {
-
-            if (pDevice->dwIsr & ISR_MEASURESTART) {
-                // 802.11h measure start
-                pDevice->byOrgChannel = pDevice->byCurrentCh;
-                VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byOrgRCR));
-                VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, (RCR_RXALLTYPE | RCR_UNICAST | RCR_BROADCAST | RCR_MULTICAST | RCR_WPAERR));
-                MACvSelectPage1(pDevice->PortOffset);
-                VNSvInPortD(pDevice->PortOffset + MAC_REG_MAR0, &(pDevice->dwOrgMAR0));
-                VNSvInPortD(pDevice->PortOffset + MAC_REG_MAR4, &(pDevice->dwOrgMAR4));
-                MACvSelectPage0(pDevice->PortOffset);
-               //xxxx
-               // WCMDbFlushCommandQueue(pDevice->pMgmt, true);
-                if (set_channel(pDevice, pDevice->pCurrMeasureEID->sReq.byChannel) == true) {
-                    pDevice->bMeasureInProgress = true;
-                    MACvSelectPage1(pDevice->PortOffset);
-                    MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_READY);
-                    MACvSelectPage0(pDevice->PortOffset);
-                    pDevice->byBasicMap = 0;
-                    pDevice->byCCAFraction = 0;
-                    for(ii=0;ii<8;ii++) {
-                        pDevice->dwRPIs[ii] = 0;
-                    }
-                } else {
-                    // can not measure because set channel fail
-                   // WCMDbResetCommandQueue(pDevice->pMgmt);
-                    // clear measure control
-                    MACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);
-                    s_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_INCAPABLE);
-                    MACvSelectPage1(pDevice->PortOffset);
-                    MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
-                    MACvSelectPage0(pDevice->PortOffset);
-                }
-            }
-            if (pDevice->dwIsr & ISR_MEASUREEND) {
-                // 802.11h measure end
-                pDevice->bMeasureInProgress = false;
-                VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byOrgRCR);
-                MACvSelectPage1(pDevice->PortOffset);
-                VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, pDevice->dwOrgMAR0);
-                VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR4, pDevice->dwOrgMAR4);
-                VNSvInPortB(pDevice->PortOffset + MAC_REG_MSRBBSTS, &byData);
-                pDevice->byBasicMap |= (byData >> 4);
-                VNSvInPortB(pDevice->PortOffset + MAC_REG_CCAFRACTION, &pDevice->byCCAFraction);
-                VNSvInPortB(pDevice->PortOffset + MAC_REG_MSRCTL, &byData);
-                // clear measure control
-                MACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);
-                MACvSelectPage0(pDevice->PortOffset);
-                set_channel(pDevice, pDevice->byOrgChannel);
-                // WCMDbResetCommandQueue(pDevice->pMgmt);
-                MACvSelectPage1(pDevice->PortOffset);
-                MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
-                MACvSelectPage0(pDevice->PortOffset);
-                if (byData & MSRCTL_FINISH) {
-                    // measure success
-                    s_vCompleteCurrentMeasure(pDevice, 0);
-                } else {
-                    // can not measure because not ready before end of measure time
-                    s_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_LATE);
-                }
-            }
-            if (pDevice->dwIsr & ISR_QUIETSTART) {
-                do {
-                    ;
-                } while (CARDbStartQuiet(pDevice) == false);
-            }
-        }
-
-        if (pDevice->dwIsr & ISR_TBTT) {
-            if (pDevice->bEnableFirstQuiet == true) {
-                pDevice->byQuietStartCount--;
-                if (pDevice->byQuietStartCount == 0) {
-                    pDevice->bEnableFirstQuiet = false;
-                    MACvSelectPage1(pDevice->PortOffset);
-                    MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, (MSRCTL_QUIETTXCHK | MSRCTL_QUIETEN));
-                    MACvSelectPage0(pDevice->PortOffset);
-                }
-            }
-            if ((pDevice->bChannelSwitch == true) &&
-                (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE)) {
-                pDevice->byChannelSwitchCount--;
-                if (pDevice->byChannelSwitchCount == 0) {
-                    pDevice->bChannelSwitch = false;
-                    set_channel(pDevice, pDevice->byNewChannel);
-                    VNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);
-                    MACvSelectPage1(pDevice->PortOffset);
-                    MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
-                    MACvSelectPage0(pDevice->PortOffset);
-                    CARDbStartTxPacket(pDevice, PKT_TYPE_802_11_ALL);
-
-                }
-            }
-            if (pDevice->eOPMode == OP_MODE_ADHOC) {
-                //pDevice->bBeaconSent = false;
-            } else {
-                if ((pDevice->bUpdateBBVGA) && (pDevice->bLinkPass == true) && (pDevice->uCurrRSSI != 0)) {
-                    long            ldBm;
-
-                    RFvRSSITodBm(pDevice, (unsigned char) pDevice->uCurrRSSI, &ldBm);
-                    for (ii=0;ii<BB_VGA_LEVEL;ii++) {
-                        if (ldBm < pDevice->ldBmThreshold[ii]) {
-                            pDevice->byBBVGANew = pDevice->abyBBVGA[ii];
-                            break;
-                        }
-                    }
-                    if (pDevice->byBBVGANew != pDevice->byBBVGACurrent) {
-                        pDevice->uBBVGADiffCount++;
-                        if (pDevice->uBBVGADiffCount == 1) {
-                            // first VGA diff gain
-                            BBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);
-                            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
-                                            (int)ldBm, pDevice->byBBVGANew, pDevice->byBBVGACurrent, (int)pDevice->uBBVGADiffCount);
-                        }
-                        if (pDevice->uBBVGADiffCount >= BB_VGA_CHANGE_THRESHOLD) {
-                            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
-                                            (int)ldBm, pDevice->byBBVGANew, pDevice->byBBVGACurrent, (int)pDevice->uBBVGADiffCount);
-                            BBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);
-                        }
-                    } else {
-                        pDevice->uBBVGADiffCount = 1;
-                    }
-                }
-            }
-
-            pDevice->bBeaconSent = false;
-            if (pDevice->bEnablePSMode) {
-                PSbIsNextTBTTWakeUp((void *)pDevice);
-            }
-
-            if ((pDevice->eOPMode == OP_MODE_AP) ||
-                (pDevice->eOPMode == OP_MODE_ADHOC)) {
-
-                MACvOneShotTimer1MicroSec(pDevice->PortOffset,
-                        (pMgmt->wIBSSBeaconPeriod - MAKE_BEACON_RESERVED) << 10);
-            }
-
-            if (pDevice->eOPMode == OP_MODE_ADHOC && pDevice->pMgmt->wCurrATIMWindow > 0) {
-                // todo adhoc PS mode
-            }
-
-        }
-
-        if (pDevice->dwIsr & ISR_BNTX) {
-
-            if (pDevice->eOPMode == OP_MODE_ADHOC) {
-                pDevice->bIsBeaconBufReadySet = false;
-                pDevice->cbBeaconBufReadySetCnt = 0;
-            }
-
-            if (pDevice->eOPMode == OP_MODE_AP) {
-                if(pMgmt->byDTIMCount > 0) {
-                   pMgmt->byDTIMCount --;
-                   pMgmt->sNodeDBTable[0].bRxPSPoll = false;
-                }
-                else {
-                    if(pMgmt->byDTIMCount == 0) {
-                        // check if mutltcast tx bufferring
-                        pMgmt->byDTIMCount = pMgmt->byDTIMPeriod - 1;
-                        pMgmt->sNodeDBTable[0].bRxPSPoll = true;
-                        bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-                    }
-                }
-            }
-            pDevice->bBeaconSent = true;
-
-            if (pDevice->bChannelSwitch == true) {
-                pDevice->byChannelSwitchCount--;
-                if (pDevice->byChannelSwitchCount == 0) {
-                    pDevice->bChannelSwitch = false;
-                    set_channel(pDevice, pDevice->byNewChannel);
-                    VNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);
-                    MACvSelectPage1(pDevice->PortOffset);
-                    MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
-                    MACvSelectPage0(pDevice->PortOffset);
-                    //VNTWIFIbSendBeacon(pDevice->pMgmt);
-                    CARDbStartTxPacket(pDevice, PKT_TYPE_802_11_ALL);
-                }
-            }
-
-        }
-
-        if (pDevice->dwIsr & ISR_RXDMA0) {
-            max_count += device_rx_srv(pDevice, TYPE_RXDMA0);
-        }
-        if (pDevice->dwIsr & ISR_RXDMA1) {
-            max_count += device_rx_srv(pDevice, TYPE_RXDMA1);
-        }
-        if (pDevice->dwIsr & ISR_TXDMA0){
-            max_count += device_tx_srv(pDevice, TYPE_TXDMA0);
-        }
-        if (pDevice->dwIsr & ISR_AC0DMA){
-            max_count += device_tx_srv(pDevice, TYPE_AC0DMA);
-        }
-        if (pDevice->dwIsr & ISR_SOFTTIMER) {
-
-        }
-        if (pDevice->dwIsr & ISR_SOFTTIMER1) {
-            if (pDevice->eOPMode == OP_MODE_AP) {
-               if (pDevice->bShortSlotTime)
-                   pMgmt->wCurrCapInfo |= WLAN_SET_CAP_INFO_SHORTSLOTTIME(1);
-               else
-                   pMgmt->wCurrCapInfo &= ~(WLAN_SET_CAP_INFO_SHORTSLOTTIME(1));
-            }
-            bMgrPrepareBeaconToSend(pDevice, pMgmt);
-            pDevice->byCntMeasure = 0;
-        }
-
-        MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
-
-        MACvReceive0(pDevice->PortOffset);
-        MACvReceive1(pDevice->PortOffset);
-
-        if (max_count>pDevice->sOpts.int_works)
-            break;
-    }
-
-    if (byOrgPageSel == 1) {
-        MACvSelectPage1(pDevice->PortOffset);
-    }
-
-    spin_unlock_irq(&pDevice->lock);
-    MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
-
-    return IRQ_RETVAL(handled);
-}
+	pDevice->bPWBitOn = false;
+
+	pLastTD = pHeadTD;
+	for (ii = 0; ii < uMACfragNum; ii++) {
+		// Poll Transmit the adapter
+		wmb();
+		pHeadTD->m_td0TD0.f1Owner = OWNED_BY_NIC;
+		wmb();
+		if (ii == (uMACfragNum - 1))
+			pLastTD = pHeadTD;
+		pHeadTD = pHeadTD->next;
+	}
 
+	// Save the information needed by the tx interrupt handler
+	// to complete the Send request
+	pLastTD->pTDInfo->skb = skb;
+	pLastTD->pTDInfo->byFlags = 0;
+	pLastTD->pTDInfo->byFlags |= TD_FLAGS_NETIF_SKB;
 
-static unsigned const ethernet_polynomial = 0x04c11db7U;
-static inline u32 ether_crc(int length, unsigned char *data)
-{
-    int crc = -1;
-
-    while(--length >= 0) {
-        unsigned char current_octet = *data++;
-        int bit;
-        for (bit = 0; bit < 8; bit++, current_octet >>= 1) {
-            crc = (crc << 1) ^
-                ((crc < 0) ^ (current_octet & 1) ? ethernet_polynomial : 0);
-        }
-    }
-    return crc;
-}
+	pDevice->apCurrTD[TYPE_TXDMA0] = pHeadTD;
 
-//2008-8-4 <add> by chester
-static int Config_FileGetParameter(unsigned char *string,
-		unsigned char *dest, unsigned char *source)
-{
-  unsigned char buf1[100];
-  int source_len = strlen(source);
+	MACvTransmit0(pDevice->PortOffset);
 
-    memset(buf1,0,100);
-    strcat(buf1, string);
-    strcat(buf1, "=");
-    source+=strlen(buf1);
 
-   memcpy(dest,source,source_len-strlen(buf1));
- return true;
+	return true;
 }
 
-int Config_FileOperation(PSDevice pDevice,bool fwrite,unsigned char *Parameter) {
-    unsigned char *config_path = CONFIG_PATH;
-    unsigned char *buffer = NULL;
-    unsigned char tmpbuffer[20];
-    struct file   *filp=NULL;
-    mm_segment_t old_fs = get_fs();
-    //int oldfsuid=0,oldfsgid=0;
-    int result=0;
-
-    set_fs (KERNEL_DS);
-
-    /* Can't do this anymore, so we rely on correct filesystem permissions:
-    //Make sure a caller can read or write power as root
-    oldfsuid=current->cred->fsuid;
-    oldfsgid=current->cred->fsgid;
-    current->cred->fsuid = 0;
-    current->cred->fsgid = 0;
-    */
-
-    //open file
-      filp = filp_open(config_path, O_RDWR, 0);
-        if (IS_ERR(filp)) {
-	     printk("Config_FileOperation:open file fail?\n");
-	     result=-1;
-             goto error2;
-	  }
-
-     if(!(filp->f_op) || !(filp->f_op->read) ||!(filp->f_op->write)) {
-           printk("file %s cann't readable or writable?\n",config_path);
-	  result = -1;
-	  goto error1;
-     	}
-
-buffer = kmalloc(1024, GFP_KERNEL);
-if(buffer==NULL) {
-  printk("allocate mem for file fail?\n");
-  result = -1;
-  goto error1;
-}
+//TYPE_AC0DMA data tx
+static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
+	PSDevice pDevice = netdev_priv(dev);
+
+	PSMgmtObject    pMgmt = pDevice->pMgmt;
+	PSTxDesc        pHeadTD, pLastTD;
+	unsigned int uNodeIndex = 0;
+	unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
+	unsigned short wAID;
+	unsigned int uMACfragNum = 1;
+	unsigned int cbFrameBodySize;
+	unsigned char byPktType;
+	unsigned int cbHeaderSize;
+	bool bNeedEncryption = false;
+	PSKeyItem       pTransmitKey = NULL;
+	SKeyItem        STempKey;
+	unsigned int ii;
+	bool bTKIP_UseGTK = false;
+	bool bNeedDeAuth = false;
+	unsigned char *pbyBSSID;
+	bool bNodeExist = false;
+
+
+
+	spin_lock_irq(&pDevice->lock);
+	if (pDevice->bLinkPass == false) {
+		dev_kfree_skb_irq(skb);
+		spin_unlock_irq(&pDevice->lock);
+		return 0;
+	}
 
-if(filp->f_op->read(filp, buffer, 1024, &filp->f_pos)<0) {
- printk("read file error?\n");
- result = -1;
- goto error1;
-}
+	if (pDevice->bStopDataPkt) {
+		dev_kfree_skb_irq(skb);
+		spin_unlock_irq(&pDevice->lock);
+		return 0;
+	}
 
-if(Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer)!=true) {
-  printk("get parameter error?\n");
-  result = -1;
-  goto error1;
-}
 
-if(memcmp(tmpbuffer,"USA",3)==0) {
-  result=ZoneType_USA;
+	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+		if (pDevice->uAssocCount == 0) {
+			dev_kfree_skb_irq(skb);
+			spin_unlock_irq(&pDevice->lock);
+			return 0;
+		}
+		if (is_multicast_ether_addr((unsigned char *)(skb->data))) {
+			uNodeIndex = 0;
+			bNodeExist = true;
+			if (pMgmt->sNodeDBTable[0].bPSEnable) {
+				skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skb);
+				pMgmt->sNodeDBTable[0].wEnQueueCnt++;
+				// set tx map
+				pMgmt->abyPSTxMap[0] |= byMask[0];
+				spin_unlock_irq(&pDevice->lock);
+				return 0;
+			}
+		} else {
+			if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data), &uNodeIndex)) {
+				if (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {
+					skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);
+					pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;
+					// set tx map
+					wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
+					pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Set:pMgmt->abyPSTxMap[%d]= %d\n",
+						(wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);
+					spin_unlock_irq(&pDevice->lock);
+					return 0;
+				}
+
+				if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {
+					pDevice->byPreambleType = pDevice->byShortPreamble;
+
+				} else {
+					pDevice->byPreambleType = PREAMBLE_LONG;
+				}
+				bNodeExist = true;
+
+			}
+		}
+
+		if (bNodeExist == false) {
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "Unknown STA not found in node DB \n");
+			dev_kfree_skb_irq(skb);
+			spin_unlock_irq(&pDevice->lock);
+			return 0;
+		}
+	}
+
+	pHeadTD = pDevice->apCurrTD[TYPE_AC0DMA];
+
+	pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
+
+
+	memcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)(skb->data), ETH_HLEN);
+	cbFrameBodySize = skb->len - ETH_HLEN;
+	// 802.1H
+	if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN) {
+		cbFrameBodySize += 8;
+	}
+
+
+	if (pDevice->bEncryptionEnable == true) {
+		bNeedEncryption = true;
+		// get Transmit key
+		do {
+			if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
+			    (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
+				pbyBSSID = pDevice->abyBSSID;
+				// get pairwise key
+				if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == false) {
+					// get group key
+					if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == true) {
+						bTKIP_UseGTK = true;
+						DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "Get GTK.\n");
+						break;
+					}
+				} else {
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "Get PTK.\n");
+					break;
+				}
+			} else if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
+
+				pbyBSSID = pDevice->sTxEthHeader.abyDstAddr;  //TO_DS = 0 and FROM_DS = 0 --> 802.11 MAC Address1
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "IBSS Serach Key: \n");
+				for (ii = 0; ii < 6; ii++)
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "%x \n", *(pbyBSSID+ii));
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "\n");
+
+				// get pairwise key
+				if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == true)
+					break;
+			}
+			// get group key
+			pbyBSSID = pDevice->abyBroadcastAddr;
+			if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == false) {
+				pTransmitKey = NULL;
+				if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
+				}
+				else
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "NOT IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
+			} else {
+				bTKIP_UseGTK = true;
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "Get GTK.\n");
+			}
+		} while (false);
+	}
+
+	if (pDevice->bEnableHostWEP) {
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "acdma0: STA index %d\n", uNodeIndex);
+		if (pDevice->bEncryptionEnable == true) {
+			pTransmitKey = &STempKey;
+			pTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;
+			pTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;
+			pTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;
+			pTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;
+			pTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;
+			memcpy(pTransmitKey->abyKey,
+			       &pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],
+			       pTransmitKey->uKeyLength
+				);
+		}
+	}
+
+	uMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);
+
+	if (uMACfragNum > AVAIL_TD(pDevice, TYPE_AC0DMA)) {
+		DBG_PRT(MSG_LEVEL_ERR, KERN_DEBUG "uMACfragNum > AVAIL_TD(TYPE_AC0DMA) = %d\n", uMACfragNum);
+		dev_kfree_skb_irq(skb);
+		spin_unlock_irq(&pDevice->lock);
+		return 0;
+	}
+
+	if (pTransmitKey != NULL) {
+		if ((pTransmitKey->byCipherSuite == KEY_CTL_WEP) &&
+		    (pTransmitKey->uKeyLength == WLAN_WEP232_KEYLEN)) {
+			uMACfragNum = 1; //WEP256 doesn't support fragment
+		}
+	}
+
+	byPktType = (unsigned char)pDevice->byPacketType;
+
+	if (pDevice->bFixRate) {
+#ifdef	PLICE_DEBUG
+		printk("Fix Rate: PhyType is %d,ConnectionRate is %d\n", pDevice->eCurrentPHYType, pDevice->uConnectionRate);
+#endif
+
+		if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
+			if (pDevice->uConnectionRate >= RATE_11M) {
+				pDevice->wCurrentRate = RATE_11M;
+			} else {
+				pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
+			}
+		} else {
+			if ((pDevice->eCurrentPHYType == PHY_TYPE_11A) &&
+			    (pDevice->uConnectionRate <= RATE_6M)) {
+				pDevice->wCurrentRate = RATE_6M;
+			} else {
+				if (pDevice->uConnectionRate >= RATE_54M)
+					pDevice->wCurrentRate = RATE_54M;
+				else
+					pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
+
+			}
+		}
+		pDevice->byACKRate = (unsigned char) pDevice->wCurrentRate;
+		pDevice->byTopCCKBasicRate = RATE_1M;
+		pDevice->byTopOFDMBasicRate = RATE_6M;
+	}
+	else {
+		//auto rate
+		if (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {
+			if (pDevice->eCurrentPHYType != PHY_TYPE_11A) {
+				pDevice->wCurrentRate = RATE_1M;
+				pDevice->byACKRate = RATE_1M;
+				pDevice->byTopCCKBasicRate = RATE_1M;
+				pDevice->byTopOFDMBasicRate = RATE_6M;
+			} else {
+				pDevice->wCurrentRate = RATE_6M;
+				pDevice->byACKRate = RATE_6M;
+				pDevice->byTopCCKBasicRate = RATE_1M;
+				pDevice->byTopOFDMBasicRate = RATE_6M;
+			}
+		}
+		else {
+			VNTWIFIvGetTxRate(pDevice->pMgmt,
+					  pDevice->sTxEthHeader.abyDstAddr,
+					  &(pDevice->wCurrentRate),
+					  &(pDevice->byACKRate),
+					  &(pDevice->byTopCCKBasicRate),
+					  &(pDevice->byTopOFDMBasicRate));
+
+
+		}
+	}
+
+//    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
+
+	if (pDevice->wCurrentRate <= RATE_11M) {
+		byPktType = PK_TYPE_11B;
+	} else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
+		byPktType = PK_TYPE_11A;
+	} else {
+		if (pDevice->bProtectMode == true) {
+			byPktType = PK_TYPE_11GB;
+		} else {
+			byPktType = PK_TYPE_11GA;
+		}
+	}
+
+//#ifdef	PLICE_DEBUG
+//	printk("FIX RATE:CurrentRate is %d");
+//#endif
+
+	if (bNeedEncryption == true) {
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ntohs Pkt Type=%04x\n", ntohs(pDevice->sTxEthHeader.wType));
+		if ((pDevice->sTxEthHeader.wType) == TYPE_PKT_802_1x) {
+			bNeedEncryption = false;
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Pkt Type=%04x\n", (pDevice->sTxEthHeader.wType));
+			if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
+				if (pTransmitKey == NULL) {
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Don't Find TX KEY\n");
+				}
+				else {
+					if (bTKIP_UseGTK == true) {
+						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "error: KEY is GTK!!~~\n");
+					}
+					else {
+						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
+						bNeedEncryption = true;
+					}
+				}
+			}
+
+			if (pDevice->byCntMeasure == 2) {
+				bNeedDeAuth = true;
+				pDevice->s802_11Counter.TKIPCounterMeasuresInvoked++;
+			}
+
+			if (pDevice->bEnableHostWEP) {
+				if ((uNodeIndex != 0) &&
+				    (pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex & PAIRWISE_KEY)) {
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
+					bNeedEncryption = true;
+				}
+			}
+		}
+		else {
+			if (pTransmitKey == NULL) {
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "return no tx key\n");
+				dev_kfree_skb_irq(skb);
+				spin_unlock_irq(&pDevice->lock);
+				return 0;
+			}
+		}
+	}
+
+
+#ifdef	PLICE_DEBUG
+	//if (skb->len == 98)
+	//{
+	//	printk("ping:len is %d\n");
+	//}
+#endif
+	vGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,
+			    cbFrameBodySize, TYPE_AC0DMA, pHeadTD,
+			    &pDevice->sTxEthHeader, (unsigned char *)skb->data, pTransmitKey, uNodeIndex,
+			    &uMACfragNum,
+			    &cbHeaderSize
+		);
+
+	if (MACbIsRegBitsOn(pDevice->PortOffset, MAC_REG_PSCTL, PSCTL_PS)) {
+		// Disable PS
+		MACbPSWakeup(pDevice->PortOffset);
+	}
+	pDevice->bPWBitOn = false;
+
+	pLastTD = pHeadTD;
+	for (ii = 0; ii < uMACfragNum; ii++) {
+		// Poll Transmit the adapter
+		wmb();
+		pHeadTD->m_td0TD0.f1Owner = OWNED_BY_NIC;
+		wmb();
+		if (ii == uMACfragNum - 1)
+			pLastTD = pHeadTD;
+		pHeadTD = pHeadTD->next;
+	}
+
+	// Save the information needed by the tx interrupt handler
+	// to complete the Send request
+	pLastTD->pTDInfo->skb = skb;
+	pLastTD->pTDInfo->byFlags = 0;
+	pLastTD->pTDInfo->byFlags |= TD_FLAGS_NETIF_SKB;
+#ifdef TxInSleep
+	pDevice->nTxDataTimeCout = 0; //2008-8-21 chester <add> for send null packet
+#endif
+	if (AVAIL_TD(pDevice, TYPE_AC0DMA) <= 1) {
+		netif_stop_queue(dev);
+	}
+
+	pDevice->apCurrTD[TYPE_AC0DMA] = pHeadTD;
+//#ifdef	PLICE_DEBUG
+	if (pDevice->bFixRate)
+	{
+		printk("FixRate:Rate is %d,TxPower is %d\n", pDevice->wCurrentRate, pDevice->byCurPwr);
+	}
+	else
+	{
+		//printk("Auto Rate:Rate is %d,TxPower is %d\n",pDevice->wCurrentRate,pDevice->byCurPwr);
+	}
+//#endif
+
+	{
+		unsigned char Protocol_Version;    //802.1x Authentication
+		unsigned char Packet_Type;           //802.1x Authentication
+		unsigned char Descriptor_type;
+		unsigned short Key_info;
+		bool bTxeapol_key = false;
+		Protocol_Version = skb->data[ETH_HLEN];
+		Packet_Type = skb->data[ETH_HLEN+1];
+		Descriptor_type = skb->data[ETH_HLEN+1+1+2];
+		Key_info = (skb->data[ETH_HLEN+1+1+2+1] << 8)|(skb->data[ETH_HLEN+1+1+2+2]);
+		if (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {
+			if (((Protocol_Version == 1) || (Protocol_Version == 2)) &&
+			    (Packet_Type == 3)) {  //802.1x OR eapol-key challenge frame transfer
+				bTxeapol_key = true;
+				if ((Descriptor_type == 254) || (Descriptor_type == 2)) {       //WPA or RSN
+					if (!(Key_info & BIT3) &&   //group-key challenge
+					    (Key_info & BIT8) && (Key_info & BIT9)) {    //send 2/2 key
+						pDevice->fWPA_Authened = true;
+						if (Descriptor_type == 254)
+							printk("WPA ");
+						else
+							printk("WPA2 ");
+						printk("Authentication completed!!\n");
+					}
+				}
+			}
+		}
+	}
+
+	MACvTransmitAC0(pDevice->PortOffset);
+//    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0:pDevice->apCurrTD= %p\n", pHeadTD);
+
+	dev->trans_start = jiffies;
+
+	spin_unlock_irq(&pDevice->lock);
+	return 0;
+
 }
-else if(memcmp(tmpbuffer,"JAPAN",5)==0) {
-  result=ZoneType_Japan;
+
+static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
+	struct net_device *dev = dev_instance;
+	PSDevice     pDevice = (PSDevice)netdev_priv(dev);
+
+	int             max_count = 0;
+	unsigned long dwMIBCounter = 0;
+	PSMgmtObject    pMgmt = pDevice->pMgmt;
+	unsigned char byOrgPageSel = 0;
+	int             handled = 0;
+	unsigned char byData = 0;
+	int             ii = 0;
+//    unsigned char byRSSI;
+
+
+	MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
+
+	if (pDevice->dwIsr == 0)
+		return IRQ_RETVAL(handled);
+
+	if (pDevice->dwIsr == 0xffffffff) {
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwIsr = 0xffff\n");
+		return IRQ_RETVAL(handled);
+	}
+	/*
+	// 2008-05-21 <mark> by Richardtai, we can't read RSSI here, because no packet bound with RSSI
+
+	if ((pDevice->dwIsr & ISR_RXDMA0) &&
+	(pDevice->byLocalID != REV_ID_VT3253_B0) &&
+	(pDevice->bBSSIDFilter == true)) {
+	// update RSSI
+	//BBbReadEmbedded(pDevice->PortOffset, 0x3E, &byRSSI);
+	//pDevice->uCurrRSSI = byRSSI;
+	}
+	*/
+
+	handled = 1;
+	MACvIntDisable(pDevice->PortOffset);
+	spin_lock_irq(&pDevice->lock);
+
+	//Make sure current page is 0
+	VNSvInPortB(pDevice->PortOffset + MAC_REG_PAGE1SEL, &byOrgPageSel);
+	if (byOrgPageSel == 1) {
+		MACvSelectPage0(pDevice->PortOffset);
+	}
+	else
+		byOrgPageSel = 0;
+
+	MACvReadMIBCounter(pDevice->PortOffset, &dwMIBCounter);
+	// TBD....
+	// Must do this after doing rx/tx, cause ISR bit is slow
+	// than RD/TD write back
+	// update ISR counter
+	STAvUpdate802_11Counter(&pDevice->s802_11Counter, &pDevice->scStatistic , dwMIBCounter);
+	while (pDevice->dwIsr != 0) {
+
+		STAvUpdateIsrStatCounter(&pDevice->scStatistic, pDevice->dwIsr);
+		MACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);
+
+		if (pDevice->dwIsr & ISR_FETALERR) {
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " ISR_FETALERR \n");
+			VNSvOutPortB(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, 0);
+			VNSvOutPortW(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, SOFTPWRCTL_SWPECTI);
+			device_error(pDevice, pDevice->dwIsr);
+		}
+
+		if (pDevice->byLocalID > REV_ID_VT3253_B1) {
+
+			if (pDevice->dwIsr & ISR_MEASURESTART) {
+				// 802.11h measure start
+				pDevice->byOrgChannel = pDevice->byCurrentCh;
+				VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byOrgRCR));
+				VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, (RCR_RXALLTYPE | RCR_UNICAST | RCR_BROADCAST | RCR_MULTICAST | RCR_WPAERR));
+				MACvSelectPage1(pDevice->PortOffset);
+				VNSvInPortD(pDevice->PortOffset + MAC_REG_MAR0, &(pDevice->dwOrgMAR0));
+				VNSvInPortD(pDevice->PortOffset + MAC_REG_MAR4, &(pDevice->dwOrgMAR4));
+				MACvSelectPage0(pDevice->PortOffset);
+				//xxxx
+				// WCMDbFlushCommandQueue(pDevice->pMgmt, true);
+				if (set_channel(pDevice, pDevice->pCurrMeasureEID->sReq.byChannel) == true) {
+					pDevice->bMeasureInProgress = true;
+					MACvSelectPage1(pDevice->PortOffset);
+					MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_READY);
+					MACvSelectPage0(pDevice->PortOffset);
+					pDevice->byBasicMap = 0;
+					pDevice->byCCAFraction = 0;
+					for (ii = 0; ii < 8; ii++) {
+						pDevice->dwRPIs[ii] = 0;
+					}
+				} else {
+					// can not measure because set channel fail
+					// WCMDbResetCommandQueue(pDevice->pMgmt);
+					// clear measure control
+					MACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);
+					s_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_INCAPABLE);
+					MACvSelectPage1(pDevice->PortOffset);
+					MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
+					MACvSelectPage0(pDevice->PortOffset);
+				}
+			}
+			if (pDevice->dwIsr & ISR_MEASUREEND) {
+				// 802.11h measure end
+				pDevice->bMeasureInProgress = false;
+				VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byOrgRCR);
+				MACvSelectPage1(pDevice->PortOffset);
+				VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, pDevice->dwOrgMAR0);
+				VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR4, pDevice->dwOrgMAR4);
+				VNSvInPortB(pDevice->PortOffset + MAC_REG_MSRBBSTS, &byData);
+				pDevice->byBasicMap |= (byData >> 4);
+				VNSvInPortB(pDevice->PortOffset + MAC_REG_CCAFRACTION, &pDevice->byCCAFraction);
+				VNSvInPortB(pDevice->PortOffset + MAC_REG_MSRCTL, &byData);
+				// clear measure control
+				MACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);
+				MACvSelectPage0(pDevice->PortOffset);
+				set_channel(pDevice, pDevice->byOrgChannel);
+				// WCMDbResetCommandQueue(pDevice->pMgmt);
+				MACvSelectPage1(pDevice->PortOffset);
+				MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
+				MACvSelectPage0(pDevice->PortOffset);
+				if (byData & MSRCTL_FINISH) {
+					// measure success
+					s_vCompleteCurrentMeasure(pDevice, 0);
+				} else {
+					// can not measure because not ready before end of measure time
+					s_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_LATE);
+				}
+			}
+			if (pDevice->dwIsr & ISR_QUIETSTART) {
+				do {
+					;
+				} while (CARDbStartQuiet(pDevice) == false);
+			}
+		}
+
+		if (pDevice->dwIsr & ISR_TBTT) {
+			if (pDevice->bEnableFirstQuiet == true) {
+				pDevice->byQuietStartCount--;
+				if (pDevice->byQuietStartCount == 0) {
+					pDevice->bEnableFirstQuiet = false;
+					MACvSelectPage1(pDevice->PortOffset);
+					MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, (MSRCTL_QUIETTXCHK | MSRCTL_QUIETEN));
+					MACvSelectPage0(pDevice->PortOffset);
+				}
+			}
+			if ((pDevice->bChannelSwitch == true) &&
+			    (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE)) {
+				pDevice->byChannelSwitchCount--;
+				if (pDevice->byChannelSwitchCount == 0) {
+					pDevice->bChannelSwitch = false;
+					set_channel(pDevice, pDevice->byNewChannel);
+					VNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);
+					MACvSelectPage1(pDevice->PortOffset);
+					MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
+					MACvSelectPage0(pDevice->PortOffset);
+					CARDbStartTxPacket(pDevice, PKT_TYPE_802_11_ALL);
+
+				}
+			}
+			if (pDevice->eOPMode == OP_MODE_ADHOC) {
+				//pDevice->bBeaconSent = false;
+			} else {
+				if ((pDevice->bUpdateBBVGA) && (pDevice->bLinkPass == true) && (pDevice->uCurrRSSI != 0)) {
+					long            ldBm;
+
+					RFvRSSITodBm(pDevice, (unsigned char) pDevice->uCurrRSSI, &ldBm);
+					for (ii = 0; ii < BB_VGA_LEVEL; ii++) {
+						if (ldBm < pDevice->ldBmThreshold[ii]) {
+							pDevice->byBBVGANew = pDevice->abyBBVGA[ii];
+							break;
+						}
+					}
+					if (pDevice->byBBVGANew != pDevice->byBBVGACurrent) {
+						pDevice->uBBVGADiffCount++;
+						if (pDevice->uBBVGADiffCount == 1) {
+							// first VGA diff gain
+							BBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);
+							DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
+								(int)ldBm, pDevice->byBBVGANew, pDevice->byBBVGACurrent, (int)pDevice->uBBVGADiffCount);
+						}
+						if (pDevice->uBBVGADiffCount >= BB_VGA_CHANGE_THRESHOLD) {
+							DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
+								(int)ldBm, pDevice->byBBVGANew, pDevice->byBBVGACurrent, (int)pDevice->uBBVGADiffCount);
+							BBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);
+						}
+					} else {
+						pDevice->uBBVGADiffCount = 1;
+					}
+				}
+			}
+
+			pDevice->bBeaconSent = false;
+			if (pDevice->bEnablePSMode) {
+				PSbIsNextTBTTWakeUp((void *)pDevice);
+			}
+
+			if ((pDevice->eOPMode == OP_MODE_AP) ||
+			    (pDevice->eOPMode == OP_MODE_ADHOC)) {
+
+				MACvOneShotTimer1MicroSec(pDevice->PortOffset,
+							  (pMgmt->wIBSSBeaconPeriod - MAKE_BEACON_RESERVED) << 10);
+			}
+
+			if (pDevice->eOPMode == OP_MODE_ADHOC && pDevice->pMgmt->wCurrATIMWindow > 0) {
+				// todo adhoc PS mode
+			}
+
+		}
+
+		if (pDevice->dwIsr & ISR_BNTX) {
+
+			if (pDevice->eOPMode == OP_MODE_ADHOC) {
+				pDevice->bIsBeaconBufReadySet = false;
+				pDevice->cbBeaconBufReadySetCnt = 0;
+			}
+
+			if (pDevice->eOPMode == OP_MODE_AP) {
+				if (pMgmt->byDTIMCount > 0) {
+					pMgmt->byDTIMCount--;
+					pMgmt->sNodeDBTable[0].bRxPSPoll = false;
+				}
+				else {
+					if (pMgmt->byDTIMCount == 0) {
+						// check if mutltcast tx bufferring
+						pMgmt->byDTIMCount = pMgmt->byDTIMPeriod - 1;
+						pMgmt->sNodeDBTable[0].bRxPSPoll = true;
+						bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
+					}
+				}
+			}
+			pDevice->bBeaconSent = true;
+
+			if (pDevice->bChannelSwitch == true) {
+				pDevice->byChannelSwitchCount--;
+				if (pDevice->byChannelSwitchCount == 0) {
+					pDevice->bChannelSwitch = false;
+					set_channel(pDevice, pDevice->byNewChannel);
+					VNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);
+					MACvSelectPage1(pDevice->PortOffset);
+					MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
+					MACvSelectPage0(pDevice->PortOffset);
+					//VNTWIFIbSendBeacon(pDevice->pMgmt);
+					CARDbStartTxPacket(pDevice, PKT_TYPE_802_11_ALL);
+				}
+			}
+
+		}
+
+		if (pDevice->dwIsr & ISR_RXDMA0) {
+			max_count += device_rx_srv(pDevice, TYPE_RXDMA0);
+		}
+		if (pDevice->dwIsr & ISR_RXDMA1) {
+			max_count += device_rx_srv(pDevice, TYPE_RXDMA1);
+		}
+		if (pDevice->dwIsr & ISR_TXDMA0) {
+			max_count += device_tx_srv(pDevice, TYPE_TXDMA0);
+		}
+		if (pDevice->dwIsr & ISR_AC0DMA) {
+			max_count += device_tx_srv(pDevice, TYPE_AC0DMA);
+		}
+		if (pDevice->dwIsr & ISR_SOFTTIMER) {
+
+		}
+		if (pDevice->dwIsr & ISR_SOFTTIMER1) {
+			if (pDevice->eOPMode == OP_MODE_AP) {
+				if (pDevice->bShortSlotTime)
+					pMgmt->wCurrCapInfo |= WLAN_SET_CAP_INFO_SHORTSLOTTIME(1);
+				else
+					pMgmt->wCurrCapInfo &= ~(WLAN_SET_CAP_INFO_SHORTSLOTTIME(1));
+			}
+			bMgrPrepareBeaconToSend(pDevice, pMgmt);
+			pDevice->byCntMeasure = 0;
+		}
+
+		MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
+
+		MACvReceive0(pDevice->PortOffset);
+		MACvReceive1(pDevice->PortOffset);
+
+		if (max_count > pDevice->sOpts.int_works)
+			break;
+	}
+
+	if (byOrgPageSel == 1) {
+		MACvSelectPage1(pDevice->PortOffset);
+	}
+
+	spin_unlock_irq(&pDevice->lock);
+	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
+
+	return IRQ_RETVAL(handled);
 }
-else if(memcmp(tmpbuffer,"EUROPE",5)==0) {
- result=ZoneType_Europe;
+
+
+static unsigned const ethernet_polynomial = 0x04c11db7U;
+static inline u32 ether_crc(int length, unsigned char *data)
+{
+	int crc = -1;
+
+	while (--length >= 0) {
+		unsigned char current_octet = *data++;
+		int bit;
+		for (bit = 0; bit < 8; bit++, current_octet >>= 1) {
+			crc = (crc << 1) ^
+				((crc < 0) ^ (current_octet & 1) ? ethernet_polynomial : 0);
+		}
+	}
+	return crc;
 }
-else {
-  result = -1;
-  printk("Unknown Zonetype[%s]?\n",tmpbuffer);
+
+//2008-8-4 <add> by chester
+static int Config_FileGetParameter(unsigned char *string,
+				   unsigned char *dest, unsigned char *source)
+{
+	unsigned char buf1[100];
+	int source_len = strlen(source);
+
+	memset(buf1, 0, 100);
+	strcat(buf1, string);
+	strcat(buf1, "=");
+	source += strlen(buf1);
+
+	memcpy(dest, source, source_len - strlen(buf1));
+	return true;
 }
 
+int Config_FileOperation(PSDevice pDevice, bool fwrite, unsigned char *Parameter) {
+	unsigned char *config_path = CONFIG_PATH;
+	unsigned char *buffer = NULL;
+	unsigned char tmpbuffer[20];
+	struct file   *filp = NULL;
+	mm_segment_t old_fs = get_fs();
+	//int oldfsuid=0,oldfsgid=0;
+	int result = 0;
+
+	set_fs(KERNEL_DS);
+
+	/* Can't do this anymore, so we rely on correct filesystem permissions:
+	//Make sure a caller can read or write power as root
+	oldfsuid=current->cred->fsuid;
+	oldfsgid=current->cred->fsgid;
+	current->cred->fsuid = 0;
+	current->cred->fsgid = 0;
+	*/
+
+	//open file
+	filp = filp_open(config_path, O_RDWR, 0);
+	if (IS_ERR(filp)) {
+		printk("Config_FileOperation:open file fail?\n");
+		result = -1;
+		goto error2;
+	}
+
+	if (!(filp->f_op) || !(filp->f_op->read) || !(filp->f_op->write)) {
+		printk("file %s cann't readable or writable?\n", config_path);
+		result = -1;
+		goto error1;
+	}
+
+	buffer = kmalloc(1024, GFP_KERNEL);
+	if (buffer == NULL) {
+		printk("allocate mem for file fail?\n");
+		result = -1;
+		goto error1;
+	}
+
+	if (filp->f_op->read(filp, buffer, 1024, &filp->f_pos) < 0) {
+		printk("read file error?\n");
+		result = -1;
+		goto error1;
+	}
+
+	if (Config_FileGetParameter("ZONETYPE", tmpbuffer, buffer) != true) {
+		printk("get parameter error?\n");
+		result = -1;
+		goto error1;
+	}
+
+	if (memcmp(tmpbuffer, "USA", 3) == 0) {
+		result = ZoneType_USA;
+	}
+	else if (memcmp(tmpbuffer, "JAPAN", 5) == 0) {
+		result = ZoneType_Japan;
+	}
+	else if (memcmp(tmpbuffer, "EUROPE", 5) == 0) {
+		result = ZoneType_Europe;
+	}
+	else {
+		result = -1;
+		printk("Unknown Zonetype[%s]?\n", tmpbuffer);
+	}
+
 error1:
-  kfree(buffer);
+	kfree(buffer);
 
-  if(filp_close(filp,NULL))
-       printk("Config_FileOperation:close file fail\n");
+	if (filp_close(filp, NULL))
+		printk("Config_FileOperation:close file fail\n");
 
 error2:
-  set_fs (old_fs);
+	set_fs(old_fs);
 
-  /*
-  current->cred->fsuid=oldfsuid;
-  current->cred->fsgid=oldfsgid;
-  */
+	/*
+	  current->cred->fsuid=oldfsuid;
+	  current->cred->fsgid=oldfsgid;
+	*/
 
-  return result;
+	return result;
 }
 
 
 
 static void device_set_multi(struct net_device *dev) {
-    PSDevice         pDevice = (PSDevice) netdev_priv(dev);
-
-    PSMgmtObject     pMgmt = pDevice->pMgmt;
-    u32              mc_filter[2];
-    struct netdev_hw_addr *ha;
-
-
-    VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
-
-    if (dev->flags & IFF_PROMISC) {         /* Set promiscuous. */
-        DBG_PRT(MSG_LEVEL_ERR,KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
-        /* Unconditionally log net taps. */
-        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);
-    }
-    else if ((netdev_mc_count(dev) > pDevice->multicast_limit)
-        ||  (dev->flags & IFF_ALLMULTI)) {
-        MACvSelectPage1(pDevice->PortOffset);
-        VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, 0xffffffff);
-        VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0 + 4, 0xffffffff);
-        MACvSelectPage0(pDevice->PortOffset);
-        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-    }
-    else {
-        memset(mc_filter, 0, sizeof(mc_filter));
-	netdev_for_each_mc_addr(ha, dev) {
-            int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
-            mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
-        }
-        MACvSelectPage1(pDevice->PortOffset);
-        VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, mc_filter[0]);
-        VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0 + 4, mc_filter[1]);
-        MACvSelectPage0(pDevice->PortOffset);
-        pDevice->byRxMode &= ~(RCR_UNICAST);
-        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-    }
-
-    if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-        // If AP mode, don't enable RCR_UNICAST. Since hw only compare addr1 with local mac.
-        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-        pDevice->byRxMode &= ~(RCR_UNICAST);
-    }
-
-    VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byRxMode);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode = %x\n", pDevice->byRxMode );
+	PSDevice         pDevice = (PSDevice)netdev_priv(dev);
+
+	PSMgmtObject     pMgmt = pDevice->pMgmt;
+	u32              mc_filter[2];
+	struct netdev_hw_addr *ha;
+
+
+	VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
+
+	if (dev->flags & IFF_PROMISC) {         /* Set promiscuous. */
+		DBG_PRT(MSG_LEVEL_ERR, KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
+		/* Unconditionally log net taps. */
+		pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);
+	}
+	else if ((netdev_mc_count(dev) > pDevice->multicast_limit)
+		 ||  (dev->flags & IFF_ALLMULTI)) {
+		MACvSelectPage1(pDevice->PortOffset);
+		VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, 0xffffffff);
+		VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0 + 4, 0xffffffff);
+		MACvSelectPage0(pDevice->PortOffset);
+		pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
+	}
+	else {
+		memset(mc_filter, 0, sizeof(mc_filter));
+		netdev_for_each_mc_addr(ha, dev) {
+			int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
+		}
+		MACvSelectPage1(pDevice->PortOffset);
+		VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, mc_filter[0]);
+		VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0 + 4, mc_filter[1]);
+		MACvSelectPage0(pDevice->PortOffset);
+		pDevice->byRxMode &= ~(RCR_UNICAST);
+		pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
+	}
+
+	if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
+		// If AP mode, don't enable RCR_UNICAST. Since hw only compare addr1 with local mac.
+		pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
+		pDevice->byRxMode &= ~(RCR_UNICAST);
+	}
+
+	VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byRxMode);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode = %x\n", pDevice->byRxMode);
 }
 
 
 static struct net_device_stats *device_get_stats(struct net_device *dev) {
-    PSDevice pDevice=(PSDevice) netdev_priv(dev);
+	PSDevice pDevice = (PSDevice)netdev_priv(dev);
 
-    return &pDevice->stats;
+	return &pDevice->stats;
 }
 
 
@@ -3090,18 +3090,18 @@ static struct net_device_stats *device_get_stats(struct net_device *dev) {
 static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	PSDevice	        pDevice = (PSDevice)netdev_priv(dev);
 
-	struct iwreq *wrq = (struct iwreq *) rq;
-	int                 rc =0;
-    PSMgmtObject        pMgmt = pDevice->pMgmt;
-    PSCmdRequest        pReq;
+	struct iwreq *wrq = (struct iwreq *)rq;
+	int rc = 0;
+	PSMgmtObject pMgmt = pDevice->pMgmt;
+	PSCmdRequest pReq;
 
 
-    if (pMgmt == NULL) {
-        rc = -EFAULT;
-        return rc;
-    }
+	if (pMgmt == NULL) {
+		rc = -EFAULT;
+		return rc;
+	}
 
-    switch(cmd) {
+	switch (cmd) {
 
 	case SIOCGIWNAME:
 		rc = iwctl_giwname(dev, NULL, (char *)&(wrq->u.name), NULL);
@@ -3113,7 +3113,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 		// Set frequency/channel
 	case SIOCSIWFREQ:
-	    rc = iwctl_siwfreq(dev, NULL, &(wrq->u.freq), NULL);
+		rc = iwctl_siwfreq(dev, NULL, &(wrq->u.freq), NULL);
 		break;
 
 		// Get frequency/channel
@@ -3124,37 +3124,37 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		// Set desired network name (ESSID)
 	case SIOCSIWESSID:
 
-		{
-			char essid[IW_ESSID_MAX_SIZE+1];
-			if (wrq->u.essid.length > IW_ESSID_MAX_SIZE) {
-				rc = -E2BIG;
-				break;
-			}
-			if (copy_from_user(essid, wrq->u.essid.pointer,
-					   wrq->u.essid.length)) {
-				rc = -EFAULT;
-				break;
-			}
-			rc = iwctl_siwessid(dev, NULL,
-					    &(wrq->u.essid), essid);
+	{
+		char essid[IW_ESSID_MAX_SIZE+1];
+		if (wrq->u.essid.length > IW_ESSID_MAX_SIZE) {
+			rc = -E2BIG;
+			break;
 		}
-		break;
+		if (copy_from_user(essid, wrq->u.essid.pointer,
+				   wrq->u.essid.length)) {
+			rc = -EFAULT;
+			break;
+		}
+		rc = iwctl_siwessid(dev, NULL,
+				    &(wrq->u.essid), essid);
+	}
+	break;
 
 
-		// Get current network name (ESSID)
+	// Get current network name (ESSID)
 	case SIOCGIWESSID:
 
-		{
-			char essid[IW_ESSID_MAX_SIZE+1];
-			if (wrq->u.essid.pointer)
-				rc = iwctl_giwessid(dev, NULL,
-						    &(wrq->u.essid), essid);
-				if (copy_to_user(wrq->u.essid.pointer,
-						         essid,
-						         wrq->u.essid.length) )
-					rc = -EFAULT;
-		}
-		break;
+	{
+		char essid[IW_ESSID_MAX_SIZE+1];
+		if (wrq->u.essid.pointer)
+			rc = iwctl_giwessid(dev, NULL,
+					    &(wrq->u.essid), essid);
+		if (copy_to_user(wrq->u.essid.pointer,
+				 essid,
+				 wrq->u.essid.length))
+			rc = -EFAULT;
+	}
+	break;
 
 	case SIOCSIWAP:
 
@@ -3170,14 +3170,14 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 		// Set desired station name
 	case SIOCSIWNICKN:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN \n");
-        rc = -EOPNOTSUPP;
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN \n");
+		rc = -EOPNOTSUPP;
 		break;
 
 		// Get current station name
 	case SIOCGIWNICKN:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWNICKN \n");
-        rc = -EOPNOTSUPP;
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWNICKN \n");
+		rc = -EOPNOTSUPP;
 		break;
 
 		// Set the desired bit-rate
@@ -3185,19 +3185,19 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		rc = iwctl_siwrate(dev, NULL, &(wrq->u.bitrate), NULL);
 		break;
 
-	// Get the current bit-rate
+		// Get the current bit-rate
 	case SIOCGIWRATE:
 
 		rc = iwctl_giwrate(dev, NULL, &(wrq->u.bitrate), NULL);
 		break;
 
-	// Set the desired RTS threshold
+		// Set the desired RTS threshold
 	case SIOCSIWRTS:
 
 		rc = iwctl_siwrts(dev, NULL, &(wrq->u.rts), NULL);
 		break;
 
-	// Get the current RTS threshold
+		// Get the current RTS threshold
 	case SIOCGIWRTS:
 
 		rc = iwctl_giwrts(dev, NULL, &(wrq->u.rts), NULL);
@@ -3207,9 +3207,9 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	case SIOCSIWFRAG:
 
 		rc = iwctl_siwfrag(dev, NULL, &(wrq->u.frag), NULL);
-	    break;
+		break;
 
-	// Get the current fragmentation threshold
+		// Get the current fragmentation threshold
 	case SIOCGIWFRAG:
 
 		rc = iwctl_giwfrag(dev, NULL, &(wrq->u.frag), NULL);
@@ -3217,7 +3217,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 		// Set mode of operation
 	case SIOCSIWMODE:
-    	rc = iwctl_siwmode(dev, NULL, &(wrq->u.mode), NULL);
+		rc = iwctl_siwmode(dev, NULL, &(wrq->u.mode), NULL);
 		break;
 
 		// Get mode of operation
@@ -3227,32 +3227,32 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 		// Set WEP keys and mode
 	case SIOCSIWENCODE:
-		{
-            char abyKey[WLAN_WEP232_KEYLEN];
+	{
+		char abyKey[WLAN_WEP232_KEYLEN];
 
-			if (wrq->u.encoding.pointer) {
+		if (wrq->u.encoding.pointer) {
 
 
-				if (wrq->u.encoding.length > WLAN_WEP232_KEYLEN) {
-					rc = -E2BIG;
-					break;
-				}
-				memset(abyKey, 0, WLAN_WEP232_KEYLEN);
-				if (copy_from_user(abyKey,
-				                  wrq->u.encoding.pointer,
-				                  wrq->u.encoding.length)) {
-					rc = -EFAULT;
-					break;
-				}
-			} else if (wrq->u.encoding.length != 0) {
-				rc = -EINVAL;
+			if (wrq->u.encoding.length > WLAN_WEP232_KEYLEN) {
+				rc = -E2BIG;
+				break;
+			}
+			memset(abyKey, 0, WLAN_WEP232_KEYLEN);
+			if (copy_from_user(abyKey,
+					   wrq->u.encoding.pointer,
+					   wrq->u.encoding.length)) {
+				rc = -EFAULT;
 				break;
 			}
-			rc = iwctl_siwencode(dev, NULL, &(wrq->u.encoding), abyKey);
+		} else if (wrq->u.encoding.length != 0) {
+			rc = -EINVAL;
+			break;
 		}
-		break;
+		rc = iwctl_siwencode(dev, NULL, &(wrq->u.encoding), abyKey);
+	}
+	break;
 
-		// Get the WEP keys and mode
+	// Get the WEP keys and mode
 	case SIOCGIWENCODE:
 
 		if (!capable(CAP_NET_ADMIN)) {
@@ -3260,14 +3260,14 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 			break;
 		}
 		{
-		    char abyKey[WLAN_WEP232_KEYLEN];
+			char abyKey[WLAN_WEP232_KEYLEN];
 
-		    rc = iwctl_giwencode(dev, NULL, &(wrq->u.encoding), abyKey);
-		    if (rc != 0) break;
+			rc = iwctl_giwencode(dev, NULL, &(wrq->u.encoding), abyKey);
+			if (rc != 0) break;
 			if (wrq->u.encoding.pointer) {
 				if (copy_to_user(wrq->u.encoding.pointer,
-						        abyKey,
-						        wrq->u.encoding.length))
+						 abyKey,
+						 wrq->u.encoding.length))
 					rc = -EFAULT;
 			}
 		}
@@ -3275,13 +3275,13 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 		// Get the current Tx-Power
 	case SIOCGIWTXPOW:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
-        rc = -EOPNOTSUPP;
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
+		rc = -EOPNOTSUPP;
 		break;
 
 	case SIOCSIWTXPOW:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWTXPOW \n");
-        rc = -EOPNOTSUPP;
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWTXPOW \n");
+		rc = -EOPNOTSUPP;
 		break;
 
 	case SIOCSIWRETRY:
@@ -3297,15 +3297,15 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		// Get range of parameters
 	case SIOCGIWRANGE:
 
-		{
-			struct iw_range range;
+	{
+		struct iw_range range;
 
-			rc = iwctl_giwrange(dev, NULL, &(wrq->u.data), (char *) &range);
-			if (copy_to_user(wrq->u.data.pointer, &range, sizeof(struct iw_range)))
-				rc = -EFAULT;
-		}
+		rc = iwctl_giwrange(dev, NULL, &(wrq->u.data), (char *)&range);
+		if (copy_to_user(wrq->u.data.pointer, &range, sizeof(struct iw_range)))
+			rc = -EFAULT;
+	}
 
-		break;
+	break;
 
 	case SIOCGIWPOWER:
 
@@ -3321,67 +3321,67 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 	case SIOCGIWSENS:
 
-	    rc = iwctl_giwsens(dev, NULL, &(wrq->u.sens), NULL);
+		rc = iwctl_giwsens(dev, NULL, &(wrq->u.sens), NULL);
 		break;
 
 	case SIOCSIWSENS:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSENS \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSENS \n");
 		rc = -EOPNOTSUPP;
 		break;
 
 	case SIOCGIWAPLIST:
-	    {
-            char buffer[IW_MAX_AP * (sizeof(struct sockaddr) + sizeof(struct iw_quality))];
-
-		    if (wrq->u.data.pointer) {
-		        rc = iwctl_giwaplist(dev, NULL, &(wrq->u.data), buffer);
-		        if (rc == 0) {
-                    if (copy_to_user(wrq->u.data.pointer,
-					                buffer,
-					               (wrq->u.data.length * (sizeof(struct sockaddr) +  sizeof(struct iw_quality)))
-				        ))
-				    rc = -EFAULT;
-		        }
-            }
-        }
-		break;
+	{
+		char buffer[IW_MAX_AP * (sizeof(struct sockaddr) + sizeof(struct iw_quality))];
+
+		if (wrq->u.data.pointer) {
+			rc = iwctl_giwaplist(dev, NULL, &(wrq->u.data), buffer);
+			if (rc == 0) {
+				if (copy_to_user(wrq->u.data.pointer,
+						 buffer,
+						 (wrq->u.data.length * (sizeof(struct sockaddr) +  sizeof(struct iw_quality)))
+					    ))
+					rc = -EFAULT;
+			}
+		}
+	}
+	break;
 
 
 #ifdef WIRELESS_SPY
-		// Set the spy list
+	// Set the spy list
 	case SIOCSIWSPY:
 
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
 		rc = -EOPNOTSUPP;
 		break;
 
 		// Get the spy list
 	case SIOCGIWSPY:
 
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWSPY \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWSPY \n");
 		rc = -EOPNOTSUPP;
 		break;
 
 #endif // WIRELESS_SPY
 
 	case SIOCGIWPRIV:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV \n");
 		rc = -EOPNOTSUPP;
 /*
-		if(wrq->u.data.pointer) {
-			wrq->u.data.length = sizeof(iwctl_private_args) / sizeof( iwctl_private_args[0]);
+  if (wrq->u.data.pointer) {
+  wrq->u.data.length = sizeof(iwctl_private_args) / sizeof(iwctl_private_args[0]);
 
-			if(copy_to_user(wrq->u.data.pointer,
-					(u_char *) iwctl_private_args,
-					sizeof(iwctl_private_args)))
-				rc = -EFAULT;
-		}
+  if (copy_to_user(wrq->u.data.pointer,
+  (u_char *) iwctl_private_args,
+  sizeof(iwctl_private_args)))
+  rc = -EFAULT;
+  }
 */
 		break;
 
 
 //2008-0409-07, <Add> by Einsn Liu
-#ifdef  WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 	case SIOCSIWAUTH:
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAUTH \n");
 		rc = iwctl_siwauth(dev, NULL, &(wrq->u.param), NULL);
@@ -3403,26 +3403,26 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		break;
 
 	case SIOCSIWENCODEEXT:
-		{
-			char extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT \n");
-			if(wrq->u.encoding.pointer){
-				memset(extra, 0, sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1);
-				if(wrq->u.encoding.length > (sizeof(struct iw_encode_ext)+ MAX_KEY_LEN)){
-					rc = -E2BIG;
-					break;
-				}
-				if(copy_from_user(extra, wrq->u.encoding.pointer,wrq->u.encoding.length)){
-					rc = -EFAULT;
-					break;
-				}
-			}else if(wrq->u.encoding.length != 0){
-				rc = -EINVAL;
+	{
+		char extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT \n");
+		if (wrq->u.encoding.pointer) {
+			memset(extra, 0, sizeof(struct iw_encode_ext)+MAX_KEY_LEN + 1);
+			if (wrq->u.encoding.length > (sizeof(struct iw_encode_ext) + MAX_KEY_LEN)) {
+				rc = -E2BIG;
+				break;
+			}
+			if (copy_from_user(extra, wrq->u.encoding.pointer, wrq->u.encoding.length)) {
+				rc = -EFAULT;
 				break;
 			}
-			rc = iwctl_siwencodeext(dev, NULL, &(wrq->u.encoding), extra);
+		} else if (wrq->u.encoding.length != 0) {
+			rc = -EINVAL;
+			break;
 		}
-		break;
+		rc = iwctl_siwencodeext(dev, NULL, &(wrq->u.encoding), extra);
+	}
+	break;
 
 	case SIOCGIWENCODEEXT:
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWENCODEEXT \n");
@@ -3437,89 +3437,89 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 #endif // #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 //End Add -- //2008-0409-07, <Add> by Einsn Liu
 
-    case IOCTL_CMD_TEST:
+	case IOCTL_CMD_TEST:
 
 		if (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {
-		    rc = -EFAULT;
-		    break;
+			rc = -EFAULT;
+			break;
 		} else {
-		    rc = 0;
+			rc = 0;
 		}
-        pReq = (PSCmdRequest)rq;
-        pReq->wResult = MAGIC_CODE;
-        break;
+		pReq = (PSCmdRequest)rq;
+		pReq->wResult = MAGIC_CODE;
+		break;
 
-    case IOCTL_CMD_SET:
+	case IOCTL_CMD_SET:
 
-               #ifdef SndEvt_ToAPI
-                  if((((PSCmdRequest)rq)->wCmdCode !=WLAN_CMD_SET_EVT) &&
-		       !(pDevice->flags & DEVICE_FLAGS_OPENED))
-	      #else
-		if (!(pDevice->flags & DEVICE_FLAGS_OPENED) &&
-		       (((PSCmdRequest)rq)->wCmdCode !=WLAN_CMD_SET_WPA))
-	      #endif
-		{
-		    rc = -EFAULT;
-		    break;
-		} else {
-		    rc = 0;
-		}
+#ifdef SndEvt_ToAPI
+		if ((((PSCmdRequest)rq)->wCmdCode != WLAN_CMD_SET_EVT) &&
+		    !(pDevice->flags & DEVICE_FLAGS_OPENED))
+#else
+			if (!(pDevice->flags & DEVICE_FLAGS_OPENED) &&
+			    (((PSCmdRequest)rq)->wCmdCode != WLAN_CMD_SET_WPA))
+#endif
+			{
+				rc = -EFAULT;
+				break;
+			} else {
+				rc = 0;
+			}
 
-	    if (test_and_set_bit( 0, (void*)&(pMgmt->uCmdBusy))) {
-		    return -EBUSY;
-	    }
-        rc = private_ioctl(pDevice, rq);
-        clear_bit( 0, (void*)&(pMgmt->uCmdBusy));
-        break;
+		if (test_and_set_bit(0, (void *)&(pMgmt->uCmdBusy))) {
+			return -EBUSY;
+		}
+		rc = private_ioctl(pDevice, rq);
+		clear_bit(0, (void *)&(pMgmt->uCmdBusy));
+		break;
 
-    case IOCTL_CMD_HOSTAPD:
+	case IOCTL_CMD_HOSTAPD:
 
 
-	rc = vt6655_hostap_ioctl(pDevice, &wrq->u.data);
-        break;
+		rc = vt6655_hostap_ioctl(pDevice, &wrq->u.data);
+		break;
 
-    case IOCTL_CMD_WPA:
+	case IOCTL_CMD_WPA:
 
-	rc = wpa_ioctl(pDevice, &wrq->u.data);
-        break;
+		rc = wpa_ioctl(pDevice, &wrq->u.data);
+		break;
 
 	case SIOCETHTOOL:
-        return ethtool_ioctl(dev, (void *) rq->ifr_data);
-	// All other calls are currently unsupported
+		return ethtool_ioctl(dev, (void *)rq->ifr_data);
+		// All other calls are currently unsupported
 
 	default:
 		rc = -EOPNOTSUPP;
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Ioctl command not support..%x\n", cmd);
-
-
-    }
-
-    if (pDevice->bCommit) {
-       if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-           netif_stop_queue(pDevice->dev);
-           spin_lock_irq(&pDevice->lock);
-           bScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);
-           spin_unlock_irq(&pDevice->lock);
-       }
-       else {
-           DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Commit the settings\n");
-           spin_lock_irq(&pDevice->lock);
-           pDevice->bLinkPass = false;
-           memset(pMgmt->abyCurrBSSID, 0, 6);
-           pMgmt->eCurrState = WMAC_STATE_IDLE;
-           netif_stop_queue(pDevice->dev);
-	#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-	      pMgmt->eScanType = WMAC_SCAN_ACTIVE;
-	 if(pDevice->bWPASuppWextEnabled !=true)
-	 #endif
-           bScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);
-           bScheduleCommand((void *) pDevice, WLAN_CMD_SSID, NULL);
-           spin_unlock_irq(&pDevice->lock);
-      }
-      pDevice->bCommit = false;
-    }
-
-    return rc;
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Ioctl command not support..%x\n", cmd);
+
+
+	}
+
+	if (pDevice->bCommit) {
+		if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
+			netif_stop_queue(pDevice->dev);
+			spin_lock_irq(&pDevice->lock);
+			bScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);
+			spin_unlock_irq(&pDevice->lock);
+		}
+		else {
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Commit the settings\n");
+			spin_lock_irq(&pDevice->lock);
+			pDevice->bLinkPass = false;
+			memset(pMgmt->abyCurrBSSID, 0, 6);
+			pMgmt->eCurrState = WMAC_STATE_IDLE;
+			netif_stop_queue(pDevice->dev);
+#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+			pMgmt->eScanType = WMAC_SCAN_ACTIVE;
+			if (pDevice->bWPASuppWextEnabled != true)
+#endif
+				bScheduleCommand((void *)pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);
+			bScheduleCommand((void *)pDevice, WLAN_CMD_SSID, NULL);
+			spin_unlock_irq(&pDevice->lock);
+		}
+		pDevice->bCommit = false;
+	}
+
+	return rc;
 }
 
 
@@ -3530,7 +3530,7 @@ static int ethtool_ioctl(struct net_device *dev, void *useraddr)
 	if (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))
 		return -EFAULT;
 
-        switch (ethcmd) {
+	switch (ethcmd) {
 	case ETHTOOL_GDRVINFO: {
 		struct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};
 		strncpy(info.driver, DEVICE_NAME, sizeof(info.driver)-1);
@@ -3540,7 +3540,7 @@ static int ethtool_ioctl(struct net_device *dev, void *useraddr)
 		return 0;
 	}
 
-        }
+	}
 
 	return -EOPNOTSUPP;
 }
@@ -3562,18 +3562,18 @@ static struct pci_driver device_driver = {
 
 static int __init vt6655_init_module(void)
 {
-    int ret;
+	int ret;
 
 
 //    ret=pci_module_init(&device_driver);
 	//ret = pcie_port_service_register(&device_driver);
 	ret = pci_register_driver(&device_driver);
 #ifdef CONFIG_PM
-    if(ret >= 0)
-        register_reboot_notifier(&device_notifier);
+	if (ret >= 0)
+		register_reboot_notifier(&device_notifier);
 #endif
 
-    return ret;
+	return ret;
 }
 
 static void __exit vt6655_cleanup_module(void)
@@ -3581,9 +3581,9 @@ static void __exit vt6655_cleanup_module(void)
 
 
 #ifdef CONFIG_PM
-    unregister_reboot_notifier(&device_notifier);
+	unregister_reboot_notifier(&device_notifier);
 #endif
-    pci_unregister_driver(&device_driver);
+	pci_unregister_driver(&device_driver);
 
 }
 
@@ -3595,85 +3595,85 @@ module_exit(vt6655_cleanup_module);
 static int
 device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
 {
-    struct pci_dev *pdev = NULL;
-    switch(event) {
-    case SYS_DOWN:
-    case SYS_HALT:
-    case SYS_POWER_OFF:
-	for_each_pci_dev(pdev) {
-            if(pci_dev_driver(pdev) == &device_driver) {
-                if (pci_get_drvdata(pdev))
-                    viawget_suspend(pdev, PMSG_HIBERNATE);
-            }
-        }
-    }
-    return NOTIFY_DONE;
+	struct pci_dev *pdev = NULL;
+	switch (event) {
+	case SYS_DOWN:
+	case SYS_HALT:
+	case SYS_POWER_OFF:
+		for_each_pci_dev(pdev) {
+			if (pci_dev_driver(pdev) == &device_driver) {
+				if (pci_get_drvdata(pdev))
+					viawget_suspend(pdev, PMSG_HIBERNATE);
+			}
+		}
+	}
+	return NOTIFY_DONE;
 }
 
 static int
 viawget_suspend(struct pci_dev *pcid, pm_message_t state)
 {
-    int power_status;   // to silence the compiler
-
-    PSDevice pDevice=pci_get_drvdata(pcid);
-    PSMgmtObject  pMgmt = pDevice->pMgmt;
-
-    netif_stop_queue(pDevice->dev);
-    spin_lock_irq(&pDevice->lock);
-    pci_save_state(pcid);
-    del_timer(&pDevice->sTimerCommand);
-    del_timer(&pMgmt->sTimerSecondCallback);
-    pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
-    pDevice->uCmdDequeueIdx = 0;
-    pDevice->uCmdEnqueueIdx = 0;
-    pDevice->bCmdRunning = false;
-    MACbShutdown(pDevice->PortOffset);
-    MACvSaveContext(pDevice->PortOffset, pDevice->abyMacContext);
-    pDevice->bLinkPass = false;
-    memset(pMgmt->abyCurrBSSID, 0, 6);
-    pMgmt->eCurrState = WMAC_STATE_IDLE;
-    pci_disable_device(pcid);
-    power_status = pci_set_power_state(pcid, pci_choose_state(pcid, state));
-    spin_unlock_irq(&pDevice->lock);
-    return 0;
+	int power_status;   // to silence the compiler
+
+	PSDevice pDevice = pci_get_drvdata(pcid);
+	PSMgmtObject  pMgmt = pDevice->pMgmt;
+
+	netif_stop_queue(pDevice->dev);
+	spin_lock_irq(&pDevice->lock);
+	pci_save_state(pcid);
+	del_timer(&pDevice->sTimerCommand);
+	del_timer(&pMgmt->sTimerSecondCallback);
+	pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
+	pDevice->uCmdDequeueIdx = 0;
+	pDevice->uCmdEnqueueIdx = 0;
+	pDevice->bCmdRunning = false;
+	MACbShutdown(pDevice->PortOffset);
+	MACvSaveContext(pDevice->PortOffset, pDevice->abyMacContext);
+	pDevice->bLinkPass = false;
+	memset(pMgmt->abyCurrBSSID, 0, 6);
+	pMgmt->eCurrState = WMAC_STATE_IDLE;
+	pci_disable_device(pcid);
+	power_status = pci_set_power_state(pcid, pci_choose_state(pcid, state));
+	spin_unlock_irq(&pDevice->lock);
+	return 0;
 }
 
 static int
 viawget_resume(struct pci_dev *pcid)
 {
-    PSDevice  pDevice=pci_get_drvdata(pcid);
-    PSMgmtObject  pMgmt = pDevice->pMgmt;
-    int power_status;   // to silence the compiler
-
-
-    power_status = pci_set_power_state(pcid, 0);
-    power_status = pci_enable_wake(pcid, 0, 0);
-    pci_restore_state(pcid);
-    if (netif_running(pDevice->dev)) {
-        spin_lock_irq(&pDevice->lock);
-        MACvRestoreContext(pDevice->PortOffset, pDevice->abyMacContext);
-        device_init_registers(pDevice, DEVICE_INIT_DXPL);
-        if (pMgmt->sNodeDBTable[0].bActive == true) { // Assoc with BSS
-            pMgmt->sNodeDBTable[0].bActive = false;
-            pDevice->bLinkPass = false;
-            if(pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
-                // In Adhoc, BSS state set back to started.
-                pMgmt->eCurrState = WMAC_STATE_STARTED;
-           }
-            else {
-                pMgmt->eCurrMode = WMAC_MODE_STANDBY;
-                pMgmt->eCurrState = WMAC_STATE_IDLE;
-            }
-        }
-        init_timer(&pMgmt->sTimerSecondCallback);
-        init_timer(&pDevice->sTimerCommand);
-        MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
-        BSSvClearBSSList((void *)pDevice, pDevice->bLinkPass);
-        bScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, NULL);
-        bScheduleCommand((void *) pDevice, WLAN_CMD_SSID, NULL);
-        spin_unlock_irq(&pDevice->lock);
-    }
-    return 0;
+	PSDevice  pDevice = pci_get_drvdata(pcid);
+	PSMgmtObject  pMgmt = pDevice->pMgmt;
+	int power_status;   // to silence the compiler
+
+
+	power_status = pci_set_power_state(pcid, 0);
+	power_status = pci_enable_wake(pcid, 0, 0);
+	pci_restore_state(pcid);
+	if (netif_running(pDevice->dev)) {
+		spin_lock_irq(&pDevice->lock);
+		MACvRestoreContext(pDevice->PortOffset, pDevice->abyMacContext);
+		device_init_registers(pDevice, DEVICE_INIT_DXPL);
+		if (pMgmt->sNodeDBTable[0].bActive == true) { // Assoc with BSS
+			pMgmt->sNodeDBTable[0].bActive = false;
+			pDevice->bLinkPass = false;
+			if (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
+				// In Adhoc, BSS state set back to started.
+				pMgmt->eCurrState = WMAC_STATE_STARTED;
+			}
+			else {
+				pMgmt->eCurrMode = WMAC_MODE_STANDBY;
+				pMgmt->eCurrState = WMAC_STATE_IDLE;
+			}
+		}
+		init_timer(&pMgmt->sTimerSecondCallback);
+		init_timer(&pDevice->sTimerCommand);
+		MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
+		BSSvClearBSSList((void *)pDevice, pDevice->bLinkPass);
+		bScheduleCommand((void *)pDevice, WLAN_CMD_BSSID_SCAN, NULL);
+		bScheduleCommand((void *)pDevice, WLAN_CMD_SSID, NULL);
+		spin_unlock_irq(&pDevice->lock);
+	}
+	return 0;
 }
 
 #endif

commit f4e1b7c830f813884679dc63bed3a708d0f5653e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:53 2012 -0500

    staging: vt6655: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4e40bc9348d4..453c83d7fe8c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -356,7 +356,7 @@ static char* get_chip_name(int chip_id)
 	return chip_info_table[i].name;
 }
 
-static void __devexit vt6655_remove(struct pci_dev *pcid)
+static void vt6655_remove(struct pci_dev *pcid)
 {
 	PSDevice pDevice = pci_get_drvdata(pcid);
 

commit a1179b20ed939792635aacefcbc676d089a9ae2d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:54 2012 -0500

    staging: vt6655: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 9e3b3f2bbe53..4e40bc9348d4 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -902,7 +902,7 @@ static const struct net_device_ops device_netdev_ops = {
 	.ndo_set_rx_mode	= device_set_multi,
 };
 
-static int __devinit
+static int
 vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 {
     static bool bFirst = true;
@@ -1099,7 +1099,7 @@ static void device_print_info(PSDevice pDevice)
 
 }
 
-static void __devinit vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
+static void vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
     PCHIP_INFO pChip_info) {
 
     PSDevice p;

commit 960cf81187833ed3f19850551d46377323043876
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Fri Sep 7 00:08:06 2012 +0530

    staging: vt6655: vt6655_init_info function must be void type
    
    this is because it doesn't fail anywhere and returning a value
    from it will be completely unnecesary.
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4ee5f38bb2bf..9e3b3f2bbe53 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -290,7 +290,7 @@ DEFINE_PCI_DEVICE_TABLE(vt6655_pci_id_table) = {
 
 
 static int  vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent);
-static bool vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice, PCHIP_INFO);
+static void vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice, PCHIP_INFO);
 static void device_free_info(PSDevice pDevice);
 static bool device_get_pci_info(PSDevice, struct pci_dev* pcid);
 static void device_print_info(PSDevice pDevice);
@@ -935,9 +935,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
         bFirst=false;
     }
 
-    if (!vt6655_init_info(pcid, &pDevice, pChip_info)) {
-        return -ENOMEM;
-    }
+    vt6655_init_info(pcid, &pDevice, pChip_info);
     pDevice->dev = dev;
     pDevice->next_module = root_device_dev;
     root_device_dev = dev;
@@ -1101,7 +1099,7 @@ static void device_print_info(PSDevice pDevice)
 
 }
 
-static bool __devinit vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
+static void __devinit vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
     PCHIP_INFO pChip_info) {
 
     PSDevice p;
@@ -1125,8 +1123,6 @@ static bool __devinit vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
     (*ppDevice)->multicast_limit =32;
 
     spin_lock_init(&((*ppDevice)->lock));
-
-    return true;
 }
 
 static bool device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {

commit cfd1fc1f5f1f3a588c6d326738dcb6b9f7b820fa
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Fri Sep 7 00:08:05 2012 +0530

    staging: vt6655: return ENOMEM rather than ENODEV when alloc_etherdev fail
    
    when alloc_etherdev fails we should be returning ENOMEM, not ENODEV
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 493866acd92c..4ee5f38bb2bf 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -922,7 +922,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
     if (dev == NULL) {
         printk(KERN_ERR DEVICE_NAME ": allocate net device failed \n");
-        return -ENODEV;
+        return -ENOMEM;
     }
 
     // Chain it all together

commit 502eb5369f51539aaee6ec173165be28d916a3ca
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Fri Sep 7 00:08:04 2012 +0530

    staging: vt6655: fix coding style problem at assigning netdev_ops
    
    we are using spaces at the beginning of the line, we should use
    tabs instead
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index bb0b0cf2be9b..493866acd92c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -893,18 +893,15 @@ static bool device_release_WPADEV(PSDevice pDevice)
     return true;
 }
 
-
 static const struct net_device_ops device_netdev_ops = {
-    .ndo_open               = device_open,
-    .ndo_stop               = device_close,
-    .ndo_do_ioctl           = device_ioctl,
-    .ndo_get_stats          = device_get_stats,
-    .ndo_start_xmit         = device_xmit,
-    .ndo_set_rx_mode	    = device_set_multi,
+	.ndo_open               = device_open,
+	.ndo_stop               = device_close,
+	.ndo_do_ioctl           = device_ioctl,
+	.ndo_get_stats          = device_get_stats,
+	.ndo_start_xmit         = device_xmit,
+	.ndo_set_rx_mode	= device_set_multi,
 };
 
-
-
 static int __devinit
 vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 {

commit bf76ebd9cfd0018be820657da781201e2f74cf5d
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Fri Sep 7 00:08:03 2012 +0530

    staging: vt6655: fix coding style issues in device_get_options
    
    a) put the device_get_options functions' opening brace below
    b) replace spaces with tabs
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Acked-by: Marcos Paulo de Souza <marcos.souza.org@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index e0a9c0804261..bb0b0cf2be9b 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -398,31 +398,29 @@ device_set_bool_opt(unsigned int *opt, int val,bool def,u32 flag, char* name,cha
     }
 }
 */
-static void
-device_get_options(PSDevice pDevice, int index, char* devname) {
-
-    POPTIONS pOpts = &(pDevice->sOpts);
-  pOpts->nRxDescs0=RX_DESC_DEF0;
-  pOpts->nRxDescs1=RX_DESC_DEF1;
-  pOpts->nTxDescs[0]=TX_DESC_DEF0;
-  pOpts->nTxDescs[1]=TX_DESC_DEF1;
-pOpts->flags|=DEVICE_FLAGS_IP_ALIGN;
-  pOpts->int_works=INT_WORKS_DEF;
-  pOpts->rts_thresh=RTS_THRESH_DEF;
-  pOpts->frag_thresh=FRAG_THRESH_DEF;
-  pOpts->data_rate=DATA_RATE_DEF;
-  pOpts->channel_num=CHANNEL_DEF;
-
-pOpts->flags|=DEVICE_FLAGS_PREAMBLE_TYPE;
-pOpts->flags|=DEVICE_FLAGS_OP_MODE;
-//pOpts->flags|=DEVICE_FLAGS_PS_MODE;
-  pOpts->short_retry=SHORT_RETRY_DEF;
-  pOpts->long_retry=LONG_RETRY_DEF;
-  pOpts->bbp_type=BBP_TYPE_DEF;
-pOpts->flags|=DEVICE_FLAGS_80211h_MODE;
-pOpts->flags|=DEVICE_FLAGS_DiversityANT;
-
-
+static void device_get_options(PSDevice pDevice, int index, char* devname)
+{
+	POPTIONS pOpts = &(pDevice->sOpts);
+
+	pOpts->nRxDescs0 = RX_DESC_DEF0;
+	pOpts->nRxDescs1 = RX_DESC_DEF1;
+	pOpts->nTxDescs[0] = TX_DESC_DEF0;
+	pOpts->nTxDescs[1] = TX_DESC_DEF1;
+	pOpts->flags |= DEVICE_FLAGS_IP_ALIGN;
+	pOpts->int_works = INT_WORKS_DEF;
+	pOpts->rts_thresh = RTS_THRESH_DEF;
+	pOpts->frag_thresh = FRAG_THRESH_DEF;
+	pOpts->data_rate = DATA_RATE_DEF;
+	pOpts->channel_num = CHANNEL_DEF;
+
+	pOpts->flags |= DEVICE_FLAGS_PREAMBLE_TYPE;
+	pOpts->flags |= DEVICE_FLAGS_OP_MODE;
+	//pOpts->flags|=DEVICE_FLAGS_PS_MODE;
+	pOpts->short_retry = SHORT_RETRY_DEF;
+	pOpts->long_retry = LONG_RETRY_DEF;
+	pOpts->bbp_type = BBP_TYPE_DEF;
+	pOpts->flags |= DEVICE_FLAGS_80211h_MODE;
+	pOpts->flags |= DEVICE_FLAGS_DiversityANT;
 }
 
 static void

commit 3ac9e0fd2a7fcd4eccbb79909b421b4284ed9520
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Fri Sep 7 00:08:02 2012 +0530

    staging: vt6655: fix coding style warnings
    
    a) replace spaces with tabs
    b) put the opening brace of get_chip_name below it
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Acked-by: Marcos Paulo de Souza <marcos.souza.org@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 697617fdb57b..e0a9c0804261 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -347,21 +347,22 @@ static int Config_FileGetParameter(unsigned char *string,
 
 
 
-static char* get_chip_name(int chip_id) {
-    int i;
-    for (i=0;chip_info_table[i].name!=NULL;i++)
-        if (chip_info_table[i].chip_id==chip_id)
-            break;
-    return chip_info_table[i].name;
+static char* get_chip_name(int chip_id)
+{
+	int i;
+	for (i = 0; chip_info_table[i].name != NULL; i++)
+		if (chip_info_table[i].chip_id == chip_id)
+			break;
+	return chip_info_table[i].name;
 }
 
 static void __devexit vt6655_remove(struct pci_dev *pcid)
 {
-    PSDevice pDevice=pci_get_drvdata(pcid);
+	PSDevice pDevice = pci_get_drvdata(pcid);
 
-    if (pDevice==NULL)
-        return;
-    device_free_info(pDevice);
+	if (pDevice == NULL)
+		return;
+	device_free_info(pDevice);
 
 }
 

commit 623b2b39c9ca172364d94baad650f735f497ca89
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Aug 20 08:43:14 2012 -0700

    staging: "vt6655" Typo change *Embeded to *Embedded.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ee4fb16c9b7d..697617fdb57b 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2660,7 +2660,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
         (pDevice->byLocalID != REV_ID_VT3253_B0) &&
         (pDevice->bBSSIDFilter == true)) {
         // update RSSI
-        //BBbReadEmbeded(pDevice->PortOffset, 0x3E, &byRSSI);
+        //BBbReadEmbedded(pDevice->PortOffset, 0x3E, &byRSSI);
         //pDevice->uCurrRSSI = byRSSI;
     }
     */

commit 789d1aef176e720fce4a8a5a9ab07f093ddb9086
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Aug 20 08:43:13 2012 -0700

    staging: "vt6655" Fix typos in comments.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 89d1c22695a0..ee4fb16c9b7d 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -518,7 +518,7 @@ static void s_vCompleteCurrentMeasure (PSDevice pDevice, unsigned char byResult)
 
 
 //
-// Initialiation of MAC & BBP registers
+// Initialisation of MAC & BBP registers
 //
 
 static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
@@ -1064,7 +1064,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
     //Mask out the options cannot be set to the chip
     pDevice->sOpts.flags &= pChip_info->flags;
 
-    //Enable the chip specified capbilities
+    //Enable the chip specified capabilities
     pDevice->flags = pDevice->sOpts.flags | (pChip_info->flags & 0xFF000000UL);
     pDevice->tx_80211 = device_dma0_tx_80211;
     pDevice->sMgmtObj.pAdapter = (void *)pDevice;
@@ -1678,7 +1678,7 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
                 uFrameSize = pTD->pTDInfo->dwReqCount - uFIFOHeaderSize;
                 pTxBufHead = (PSTxBufHead) (pTD->pTDInfo->buf);
                 // Update the statistics based on the Transmit status
-                // now, we DO'NT check TSR0_CDH
+                // now, we DONT check TSR0_CDH
 
                 STAvUpdateTDStatCounter(&pDevice->scStatistic,
                         byTsr0, byTsr1,

commit 27e3b90153c52f79beede1dd5eb51db326a5d8a9
Author: Marcos Paulo de Souza <marcos.souza.org@gmail.com>
Date:   Sun Jul 8 23:51:25 2012 -0300

    staging: vt6655: Remove all commented macros
    
    These macros were reported by forgotten-macros tool
    (https://github.com/marcosps/forgotten_macros).
    
    Signed-off-by: Marcos Paulo de Souza <marcos.souza.org@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index d0fefb1eae94..89d1c22695a0 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -87,12 +87,10 @@
 #include <linux/kthread.h>
 #include <linux/slab.h>
 
-//#define	DEBUG
 /*---------------------  Static Definitions -------------------------*/
 //static int          msglevel                =MSG_LEVEL_DEBUG;
 static int          msglevel                =   MSG_LEVEL_INFO;
 
-//#define	PLICE_DEBUG
 //
 // Define module options
 //
@@ -100,10 +98,8 @@ MODULE_AUTHOR("VIA Networking Technologies, Inc., <lyndonchen@vntek.com.tw>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("VIA Networking Solomon-A/B/G Wireless LAN Adapter Driver");
 
-//PLICE_DEBUG ->
 	static int mlme_kill;
 	//static  struct task_struct * mlme_task;
-//PLICE_DEBUG <-
 
 #define DEVICE_PARAM(N,D)
 /*

commit 2478ef577c1d6b39863a51d2622e74f912d9b3f8
Author: Marcos Paulo de Souza <marcos.souza.org@gmail.com>
Date:   Sun Jul 8 23:51:21 2012 -0300

    staging: vt6655: Remove all "if 0" blocks from driver
    
    This commit removes code that will never be executed by vt6655 driver.
    
    Was the forgotten-macros tool(https://github.com/marcosps/forgotten_macros)
    who reported these blocks for us.
    
    Signed-off-by: Marcos Paulo de Souza <marcos.souza.org@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 3e8283c2dc73..d0fefb1eae94 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1086,15 +1086,6 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
         device_free_info(pDevice);
         return -ENODEV;
     }
-//2008-07-21-01<Add>by MikeLiu
-//register wpadev
-#if 0
-   if(wpa_set_wpadev(pDevice, 1)!=0) {
-     printk("Fail to Register WPADEV?\n");
-        unregister_netdev(pDevice->dev);
-        free_netdev(dev);
-   }
-#endif
     device_print_info(pDevice);
     pci_set_drvdata(pcid, pDevice);
     return 0;
@@ -1948,15 +1939,6 @@ device_init_rd0_ring(pDevice);
 
 
 
-#if 0
-	pDevice->MLMEThr_pid = kernel_thread(MlmeThread, pDevice, CLONE_VM);
-	if (pDevice->MLMEThr_pid <0 )
-	{
-		printk("unable start thread MlmeThread\n");
-		return -1;
-	}
-#endif
-
 	//printk("thread id is %d\n",pDevice->MLMEThr_pid);
 	//printk("Create thread time is %x\n",jiffies);
 	//wait_for_completion(&pDevice->notify);
@@ -2493,21 +2475,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
                                 &(pDevice->byTopCCKBasicRate),
                                 &(pDevice->byTopOFDMBasicRate));
 
-#if 0
-printk("auto rate:Rate : %d,AckRate:%d,TopCCKRate:%d,TopOFDMRate:%d\n",
-pDevice->wCurrentRate,pDevice->byACKRate,
-pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
-
-#endif
-
-#if 0
-
-	pDevice->wCurrentRate = 11;
-	pDevice->byACKRate = 8;
-	pDevice->byTopCCKBasicRate = 3;
-	pDevice->byTopOFDMBasicRate = 8;
-#endif
-
 
 		}
     }

commit 428c1fb50ec57587eb9d7e48439059cbfeb9330a
Author: Marcos Paulo de Souza <marcos.mage@gmail.com>
Date:   Mon Nov 28 19:16:37 2011 +0000

    staging:vt6656: iwctl.c: Removed unneeded function
    
    Removed the function iwctl_giwnwid, that just return a error code.
    
    Changes v1 to v2:
            Removed same functions of vt6655 and vt6656.
    
    Signed-off-by: Marcos Paulo de Souza <marcos.mage@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index d8dd7846447d..3e8283c2dc73 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3153,11 +3153,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		break;
 
 	case SIOCGIWNWID:     //0x8b03  support
-	#ifdef  WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-          rc = iwctl_giwnwid(dev, NULL, &(wrq->u.nwid), NULL);
-	#else
-        rc = -EOPNOTSUPP;
-	#endif
+		rc = -EOPNOTSUPP;
 		break;
 
 		// Set frequency/channel

commit aa77677e0a288e08073620db5d2a31df83ca4788
Merge: efb8d21b2c6d 43a3beb6da99
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 26 15:39:02 2011 +0200

    Merge branch 'staging-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    * 'staging-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (1519 commits)
      staging: et131x: Remove redundant check and return statement
      staging: et131x: Mainly whitespace changes to appease checkpatch
      staging: et131x: Remove last of the forward declarations
      staging: et131x: Remove even more forward declarations
      staging: et131x: Remove yet more forward declarations
      staging: et131x: Remove more forward declarations
      staging: et131x: Remove forward declaration of et131x_adapter_setup
      staging: et131x: Remove some forward declarations
      staging: et131x: Remove unused rx_ring.recv_packet_pool
      staging: et131x: Remove call to find pci pm capability
      staging: et131x: Remove redundant et131x_reset_recv() call
      staging: et131x: Remove unused rx_ring.recv_buffer_pool
      Staging: bcm: Fix three initialization errors in InterfaceDld.c
      Staging: bcm: Fix coding style issues in InterfaceDld.c
      staging:iio:dac: Add AD5360 driver
      staging:iio:trigger:bfin-timer: Fix compile error
      Staging: vt6655: add some range checks before memcpy()
      Staging: vt6655: whitespace fixes to iotcl.c
      Staging: vt6656: add some range checks before memcpy()
      Staging: vt6656: whitespace cleanups in ioctl.c
      ...
    
    Fix up conflicts in:
     - drivers/{Kconfig,Makefile}, drivers/staging/{Kconfig,Makefile}:
            vg driver movement
     - drivers/staging/brcm80211/brcmfmac/{dhd_linux.c,mac80211_if.c}:
            driver removal vs now stale changes
     - drivers/staging/rtl8192e/r8192E_core.c:
            driver removal vs now stale changes
     - drivers/staging/et131x/et131*:
            driver consolidation into one file, tried to do fixups

commit 30d6a2b870a2419e1e887bd3a46f33d98c61c778
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jul 26 10:35:30 2011 +0300

    staging: vt6655: simplify MAC printing by using %pM
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 3d2a9ba16b15..567df434318a 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -815,14 +815,8 @@ else  CARDbRadioPowerOn(pDevice);
             pMgmt->eScanType = WMAC_SCAN_PASSIVE;
     // get Permanent network address
     SROMvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Network address = %02x-%02x-%02x=%02x-%02x-%02x\n",
-        pDevice->abyCurrentNetAddr[0],
-        pDevice->abyCurrentNetAddr[1],
-        pDevice->abyCurrentNetAddr[2],
-        pDevice->abyCurrentNetAddr[3],
-        pDevice->abyCurrentNetAddr[4],
-        pDevice->abyCurrentNetAddr[5]);
-
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Network address = %pM\n",
+		pDevice->abyCurrentNetAddr);
 
     // reset Tx pointer
     CARDvSafeResetRx(pDevice);

commit afc4b13df143122f99a0eb10bfefb216c2806de0
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Tue Aug 16 06:29:01 2011 +0000

    net: remove use of ndo_set_multicast_list in drivers
    
    replace it by ndo_set_rx_mode
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 3d2a9ba16b15..8cb9116c44f8 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -911,7 +911,7 @@ static const struct net_device_ops device_netdev_ops = {
     .ndo_do_ioctl           = device_ioctl,
     .ndo_get_stats          = device_get_stats,
     .ndo_start_xmit         = device_xmit,
-    .ndo_set_multicast_list = device_set_multi,
+    .ndo_set_rx_mode	    = device_set_multi,
 };
 
 

commit 9fc86028fa21f8831c0fdc701732cf491da1202c
Author: Joe Perches <joe@perches.com>
Date:   Sun Apr 10 14:31:32 2011 -0700

    staging: Remove unnecessary semicolons when if (foo) {...};
    
    Done via perl script:
    
    $ cat remove_semi_if.pl
    my $match_balanced_parentheses = qr/(\((?:[^\(\)]++|(?-1))*\))/;
    my $match_balanced_braces      = qr/(\{(?:[^\{\}]++|(?-1))*\})/;
    
    foreach my $file (@ARGV) {
        my $f;
        my $text;
        my $oldtext;
    
        next if ((-d $file));
    
        open($f, '<', $file)
            or die "$P: Can't open $file for read\n";
        $oldtext = do { local($/) ; <$f> };
        close($f);
    
        next if ($oldtext eq "");
    
        $text = $oldtext;
    
        my $count = 0;
        do {
            $count = 0;
            $count += $text =~ s@\b(if\s*${match_balanced_parentheses}\s*)${match_balanced_braces}\s*;@"$1$3"@egx;
        } while ($count > 0);
    
        if ($text ne $oldtext) {
            my $newfile = $file;
    
            open($f, '>', $newfile)
                or die "$P: Can't open $newfile for write\n";
            print $f $text;
            close($f);
        }
    }
    
    $
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ad39c8727e9b..3d2a9ba16b15 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -900,7 +900,7 @@ static bool device_release_WPADEV(PSDevice pDevice)
 	        if(ii>20)
 		  break;
               }
-           };
+           }
     return true;
 }
 
@@ -1446,7 +1446,7 @@ static void device_init_defrag_cb(PSDevice pDevice) {
         if (!device_alloc_frag_buf(pDevice, pDeF)) {
             DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc frag bufs\n",
                 pDevice->dev->name);
-        };
+        }
     }
     pDevice->cbDFCB = CB_MAX_RX_FRAG;
     pDevice->cbFreeDFCB = pDevice->cbDFCB;
@@ -2104,7 +2104,7 @@ static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
         dev_kfree_skb_irq(skb);
         spin_unlock_irq(&pDevice->lock);
         return 0;
-    };
+    }
 
     cbMPDULen = skb->len;
     pbMPDU = skb->data;
@@ -2136,7 +2136,7 @@ bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
     if (pDevice->bStopTx0Pkt == true) {
         dev_kfree_skb_irq(skb);
         return false;
-    };
+    }
 
     if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
         dev_kfree_skb_irq(skb);
@@ -2865,7 +2865,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
             pDevice->bBeaconSent = false;
             if (pDevice->bEnablePSMode) {
                 PSbIsNextTBTTWakeUp((void *)pDevice);
-            };
+            }
 
             if ((pDevice->eOPMode == OP_MODE_AP) ||
                 (pDevice->eOPMode == OP_MODE_ADHOC)) {
@@ -2876,7 +2876,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 
             if (pDevice->eOPMode == OP_MODE_ADHOC && pDevice->pMgmt->wCurrATIMWindow > 0) {
                 // todo adhoc PS mode
-            };
+            }
 
         }
 
@@ -2885,7 +2885,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
             if (pDevice->eOPMode == OP_MODE_ADHOC) {
                 pDevice->bIsBeaconBufReadySet = false;
                 pDevice->cbBeaconBufReadySetCnt = 0;
-            };
+            }
 
             if (pDevice->eOPMode == OP_MODE_AP) {
                 if(pMgmt->byDTIMCount > 0) {

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index efaf19bc07b7..ad39c8727e9b 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -137,7 +137,7 @@ DEVICE_PARAM(TxDescriptors1,"Number of transmit descriptors1");
 /* IP_byte_align[] is used for IP header unsigned long byte aligned
    0: indicate the IP header won't be unsigned long byte aligned.(Default) .
    1: indicate the IP header will be unsigned long byte aligned.
-      In some enviroment, the IP header should be unsigned long byte aligned,
+      In some environment, the IP header should be unsigned long byte aligned,
       or the packet will be droped when we receive it. (eg: IPVS)
 */
 DEVICE_PARAM(IP_byte_align,"Enable IP header dword aligned");

commit 6403bb7dc1f6d77a93850935d9277a0d74783cf0
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Sun Mar 13 00:29:14 2011 -0500

    staging: vt6655: Remove NULL check before kfree
    
    This patch was generated by the following semantic patch:
    // <smpl>
    @@ expression E; @@
    - if (E != NULL) { kfree(E); }
    + kfree(E);
    
    @@ expression E; @@
    - if (E != NULL) { kfree(E); E = NULL; }
    + kfree(E);
    + E = NULL;
    // </smpl>
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 638e3916774d..efaf19bc07b7 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3064,8 +3064,7 @@ else {
 }
 
 error1:
-  if(buffer)
-  	 kfree(buffer);
+  kfree(buffer);
 
   if(filp_close(filp,NULL))
        printk("Config_FileOperation:close file fail\n");

commit 0ffa3db9946ba2534d612d70cf40fa51fd5b63a4
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Thu Feb 24 22:14:42 2011 -0800

    staging: vt6655: device_main.c remove one to many l's in the word.
    
    The patch below removes an extra "l" in the word.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4fbacf8fdf21..638e3916774d 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3032,7 +3032,7 @@ int Config_FileOperation(PSDevice pDevice,bool fwrite,unsigned char *Parameter)
 
 buffer = kmalloc(1024, GFP_KERNEL);
 if(buffer==NULL) {
-  printk("alllocate mem for file fail?\n");
+  printk("allocate mem for file fail?\n");
   result = -1;
   goto error1;
 }

commit 34381c22b0a26ef6663f5fd92574d3f45243cabf
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Mon Jan 10 23:28:06 2011 +0100

    staging/vt6655: fix sparse warning "obsolete struct initializer"
    
    This patch fixes the sparse warnings
    "obsolete struct initializer, use C99 syntax" in vt6655/device_main.c
    by converting the struct to C99 syntax
    
    KernelVersion: linux-next-20110110
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f5028d9d7d9b..4fbacf8fdf21 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -312,9 +312,9 @@ static int device_notify_reboot(struct notifier_block *, unsigned long event, vo
 static int viawget_suspend(struct pci_dev *pcid, pm_message_t state);
 static int viawget_resume(struct pci_dev *pcid);
 struct notifier_block device_notifier = {
-        notifier_call:  device_notify_reboot,
-        next:           NULL,
-        priority:       0
+	.notifier_call = device_notify_reboot,
+	.next = NULL,
+	.priority = 0,
 };
 #endif
 
@@ -3606,13 +3606,13 @@ static int ethtool_ioctl(struct net_device *dev, void *useraddr)
 MODULE_DEVICE_TABLE(pci, vt6655_pci_id_table);
 
 static struct pci_driver device_driver = {
-        name:       DEVICE_NAME,
-        id_table:   vt6655_pci_id_table,
-        probe:      vt6655_probe,
-        remove:     vt6655_remove,
+	.name = DEVICE_NAME,
+	.id_table = vt6655_pci_id_table,
+	.probe = vt6655_probe,
+	.remove = vt6655_remove,
 #ifdef CONFIG_PM
-        suspend:    viawget_suspend,
-        resume:     viawget_resume,
+	.suspend = viawget_suspend,
+	.resume = viawget_resume,
 #endif
 };
 

commit 13b631a599cddabc1cbb3a2fb862aee5ceb6e427
Author: Kulikov Vasiliy <segooon@gmail.com>
Date:   Tue Aug 3 19:44:20 2010 +0400

    staging: vt6655: do not use PCI resources before pci_enable_device()
    
    IRQ and resource[] may not have correct values until
    after PCI hotplug setup occurs at pci_enable_device() time.
    
    The semantic match that finds this problem is as follows:
    
    // <smpl>
    @@
    identifier x;
    identifier request ~= "pci_request.*|pci_resource.*";
    @@
    
    (
    * x->irq
    |
    * x->resource
    |
    * request(x, ...)
    )
     ...
    *pci_enable_device(x)
    // </smpl>
    
    Signed-off-by: Kulikov Vasiliy <segooon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4d6b66a4fd9d..f5028d9d7d9b 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -955,12 +955,13 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
     pDevice->dev = dev;
     pDevice->next_module = root_device_dev;
     root_device_dev = dev;
-    dev->irq = pcid->irq;
 
     if (pci_enable_device(pcid)) {
         device_free_info(pDevice);
         return -ENODEV;
     }
+    dev->irq = pcid->irq;
+
 #ifdef	DEBUG
 	printk("Before get pci_info memaddr is %x\n",pDevice->memaddr);
 #endif

commit 7b6a001313a9b11a1f0985de05fff514db41d72d
Author: Charles Clment <caratorn@gmail.com>
Date:   Sun Aug 1 17:15:50 2010 +0200

    Staging: vt6655: replace BOOL with in kernel bool
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 2acc3857c862..4d6b66a4fd9d 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -294,9 +294,9 @@ DEFINE_PCI_DEVICE_TABLE(vt6655_pci_id_table) = {
 
 
 static int  vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent);
-static BOOL vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice, PCHIP_INFO);
+static bool vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice, PCHIP_INFO);
 static void device_free_info(PSDevice pDevice);
-static BOOL device_get_pci_info(PSDevice, struct pci_dev* pcid);
+static bool device_get_pci_info(PSDevice, struct pci_dev* pcid);
 static void device_print_info(PSDevice pDevice);
 static struct net_device_stats *device_get_stats(struct net_device *dev);
 static void device_init_diversity_timer(PSDevice pDevice);
@@ -327,12 +327,12 @@ static void device_init_td1_ring(PSDevice pDevice);
 
 static int  device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev);
 //2008-0714<Add>by Mike Liu
-static BOOL device_release_WPADEV(PSDevice pDevice);
+static bool device_release_WPADEV(PSDevice pDevice);
 
 static int  ethtool_ioctl(struct net_device *dev, void *useraddr);
 static int  device_rx_srv(PSDevice pDevice, unsigned int uIdx);
 static int  device_tx_srv(PSDevice pDevice, unsigned int uIdx);
-static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pDesc);
+static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pDesc);
 static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType);
 static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc);
 static void device_free_td0_ring(PSDevice pDevice);
@@ -386,7 +386,7 @@ device_set_int_opt(int *opt, int val, int min, int max, int def,char* name,char*
 }
 
 static void
-device_set_bool_opt(unsigned int *opt, int val,BOOL def,u32 flag, char* name,char* devname) {
+device_set_bool_opt(unsigned int *opt, int val,bool def,u32 flag, char* name,char* devname) {
     (*opt)&=(~flag);
     if (val==-1)
         *opt|=(def ? flag : 0);
@@ -870,7 +870,7 @@ static void device_init_diversity_timer(PSDevice pDevice) {
 }
 
 
-static BOOL device_release_WPADEV(PSDevice pDevice)
+static bool device_release_WPADEV(PSDevice pDevice)
 {
   viawget_wpa_header *wpahdr;
   int ii=0;
@@ -919,7 +919,7 @@ static const struct net_device_ops device_netdev_ops = {
 static int __devinit
 vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 {
-    static BOOL bFirst = true;
+    static bool bFirst = true;
     struct net_device*  dev = NULL;
     PCHIP_INFO  pChip_info = (PCHIP_INFO)ent->driver_data;
     PSDevice    pDevice;
@@ -1123,7 +1123,7 @@ static void device_print_info(PSDevice pDevice)
 
 }
 
-static BOOL __devinit vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
+static bool __devinit vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
     PCHIP_INFO pChip_info) {
 
     PSDevice p;
@@ -1151,7 +1151,7 @@ static BOOL __devinit vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
     return true;
 }
 
-static BOOL device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {
+static bool device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {
 
     u16 pci_cmd;
     u8  b;
@@ -1266,7 +1266,7 @@ device_release_WPADEV(pDevice);
     }
 }
 
-static BOOL device_init_rings(PSDevice pDevice) {
+static bool device_init_rings(PSDevice pDevice) {
     void*   vir_pool;
 
 
@@ -1624,7 +1624,7 @@ static int device_rx_srv(PSDevice pDevice, unsigned int uIdx) {
 }
 
 
-static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
+static bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
 
     PDEVICE_RD_INFO pRDInfo=pRD->pRDInfo;
 
@@ -1651,7 +1651,7 @@ static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
 
 
 
-BOOL device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
+bool device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
 
     pDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
     if (pDeF->skb == NULL)
@@ -1666,7 +1666,7 @@ BOOL device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
 
 static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
     PSTxDesc                 pTD;
-    BOOL                     bFull=false;
+    bool bFull=false;
     int                      works = 0;
     unsigned char byTsr0;
     unsigned char byTsr1;
@@ -2118,13 +2118,13 @@ static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
 
 
 
-BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeIndex) {
+bool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeIndex) {
     PSMgmtObject    pMgmt = pDevice->pMgmt;
     PSTxDesc        pHeadTD, pLastTD;
     unsigned int cbFrameBodySize;
     unsigned int uMACfragNum;
     unsigned char byPktType;
-    BOOL            bNeedEncryption = false;
+    bool bNeedEncryption = false;
     PSKeyItem       pTransmitKey = NULL;
     unsigned int cbHeaderSize;
     unsigned int ii;
@@ -2279,14 +2279,14 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     unsigned int cbFrameBodySize;
     unsigned char byPktType;
     unsigned int cbHeaderSize;
-    BOOL            bNeedEncryption = false;
+    bool bNeedEncryption = false;
     PSKeyItem       pTransmitKey = NULL;
     SKeyItem        STempKey;
     unsigned int ii;
-    BOOL            bTKIP_UseGTK = false;
-    BOOL            bNeedDeAuth = false;
+    bool bTKIP_UseGTK = false;
+    bool bNeedDeAuth = false;
     unsigned char *pbyBSSID;
-    BOOL            bNodeExist = false;
+    bool bNodeExist = false;
 
 
 
@@ -2638,7 +2638,7 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
     unsigned char Packet_Type;           //802.1x Authentication
     unsigned char Descriptor_type;
     unsigned short Key_info;
-BOOL            bTxeapol_key = false;
+bool bTxeapol_key = false;
     Protocol_Version = skb->data[ETH_HLEN];
     Packet_Type = skb->data[ETH_HLEN+1];
     Descriptor_type = skb->data[ETH_HLEN+1+1+2];
@@ -2996,7 +2996,7 @@ static int Config_FileGetParameter(unsigned char *string,
  return true;
 }
 
-int Config_FileOperation(PSDevice pDevice,BOOL fwrite,unsigned char *Parameter) {
+int Config_FileOperation(PSDevice pDevice,bool fwrite,unsigned char *Parameter) {
     unsigned char *config_path = CONFIG_PATH;
     unsigned char *buffer = NULL;
     unsigned char tmpbuffer[20];

commit 5a5a2a6ad4aa2467bcc34fa50e85c2afc90bab05
Author: Charles Clment <caratorn@gmail.com>
Date:   Sun Aug 1 17:15:49 2010 +0200

    Staging: vt6655: replace FALSE with in kernel false
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 4f9d0a57790e..2acc3857c862 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -396,7 +396,7 @@ device_set_bool_opt(unsigned int *opt, int val,BOOL def,u32 flag, char* name,cha
         *opt|=(def ? flag : 0);
     } else {
         DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: set parameter %s to %s\n",
-            devname,name , val ? "true" : "FALSE");
+            devname,name , val ? "true" : "false");
         *opt|=(val ? flag : 0);
     }
 }
@@ -507,7 +507,7 @@ static void s_vCompleteCurrentMeasure (PSDevice pDevice, unsigned char byResult)
                                 );
     } else {
         VNTWIFIbMeasureReport(  pDevice->pMgmt,
-                                FALSE,
+                                false,
                                 pDevice->pCurrMeasureEID,
                                 byResult,
                                 pDevice->byBasicMap,
@@ -543,10 +543,10 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
         MACbSoftwareReset(pDevice->PortOffset);
         // force CCK
         pDevice->bCCK = true;
-        pDevice->bAES = FALSE;
-        pDevice->bProtectMode = FALSE;      //Only used in 11g type, sync with ERP IE
-        pDevice->bNonERPPresent = FALSE;
-        pDevice->bBarkerPreambleMd = FALSE;
+        pDevice->bAES = false;
+        pDevice->bProtectMode = false;      //Only used in 11g type, sync with ERP IE
+        pDevice->bNonERPPresent = false;
+        pDevice->bBarkerPreambleMd = false;
         pDevice->wCurrentRate = RATE_1M;
         pDevice->byTopOFDMBasicRate = RATE_24M;
         pDevice->byTopCCKBasicRate = RATE_1M;
@@ -574,7 +574,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
         if (byValue & EEP_ANTINV)
             pDevice->bTxRxAntInv = true;
         else
-            pDevice->bTxRxAntInv = FALSE;
+            pDevice->bTxRxAntInv = false;
 #ifdef	PLICE_DEBUG
 	//printk("init_register:TxRxAntInv is %d,byValue is %d\n",pDevice->bTxRxAntInv,byValue);
 #endif
@@ -605,14 +605,14 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
           //  if (pDevice->bDiversityRegCtlON)
           if((byValue1&0x08)==0)
-                pDevice->bDiversityEnable = FALSE;//SROMbyReadEmbedded(pDevice->PortOffset, 0x50);
+                pDevice->bDiversityEnable = false;//SROMbyReadEmbedded(pDevice->PortOffset, 0x50);
             else
                 pDevice->bDiversityEnable = true;
 #ifdef	PLICE_DEBUG
 		//printk("aux |main antenna: RxAntennaMode is %d\n",pDevice->byRxAntennaMode);
 #endif
 	} else  {
-            pDevice->bDiversityEnable = FALSE;
+            pDevice->bDiversityEnable = false;
             pDevice->byAntennaCount = 1;
             pDevice->dwTxAntennaSel = 0;
             pDevice->dwRxAntennaSel = 0;
@@ -640,7 +640,7 @@ byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
 //2008-8-4 <add> by chester
 //zonetype initial
  pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
- zonetype = Config_FileOperation(pDevice,FALSE,NULL);
+ zonetype = Config_FileOperation(pDevice,false,NULL);
  if (zonetype >= 0) {         //read zonetype file ok!
   if ((zonetype == 0)&&
         (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] !=0x00)){          //for USA
@@ -682,7 +682,7 @@ else
         pDevice->byRFType &= RF_MASK;
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRFType = %x\n", pDevice->byRFType);
 
-        if (pDevice->bZoneRegExist == FALSE) {
+        if (pDevice->bZoneRegExist == false) {
             pDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byZoneType = %x\n", pDevice->byZoneType);
@@ -782,10 +782,10 @@ else
         VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_11G);
         VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_AUTO);
 
-        pDevice->bRadioOff = FALSE;
+        pDevice->bRadioOff = false;
 
         pDevice->byRadioCtl = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RADIOCTL);
-        pDevice->bHWRadioOff = FALSE;
+        pDevice->bHWRadioOff = false;
 
         if (pDevice->byRadioCtl & EEP_RADIOCTL_ENABLE) {
             // Get GPIO
@@ -793,7 +793,7 @@ else
 //2008-4-14 <add> by chester for led issue
  #ifdef FOR_LED_ON_NOTEBOOK
 if (pDevice->byGPIO & GPIO0_DATA){pDevice->bHWRadioOff = true;}
-if ( !(pDevice->byGPIO & GPIO0_DATA)){pDevice->bHWRadioOff = FALSE;}
+if ( !(pDevice->byGPIO & GPIO0_DATA)){pDevice->bHWRadioOff = false;}
 
             }
         if ( (pDevice->bRadioControlOff == true)) {
@@ -946,7 +946,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
     if (bFirst) {
         printk(KERN_NOTICE "%s Ver. %s\n",DEVICE_FULL_DRV_NAM, DEVICE_VERSION);
         printk(KERN_NOTICE "Copyright (c) 2003 VIA Networking Technologies, Inc.\n");
-        bFirst=FALSE;
+        bFirst=false;
     }
 
     if (!vt6655_init_info(pcid, &pDevice, pChip_info)) {
@@ -964,7 +964,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 #ifdef	DEBUG
 	printk("Before get pci_info memaddr is %x\n",pDevice->memaddr);
 #endif
-    if (device_get_pci_info(pDevice,pcid) == FALSE) {
+    if (device_get_pci_info(pDevice,pcid) == false) {
         printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device.\n");
         device_free_info(pDevice);
         return -ENODEV;
@@ -1280,7 +1280,7 @@ static BOOL device_init_rings(PSDevice pDevice) {
 
     if (vir_pool == NULL) {
         DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : allocate desc dma memory failed\n", pDevice->dev->name);
-        return FALSE;
+        return false;
     }
 
     memset(vir_pool, 0,
@@ -1315,7 +1315,7 @@ static BOOL device_init_rings(PSDevice pDevice) {
             pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
             vir_pool, pDevice->pool_dma
             );
-        return FALSE;
+        return false;
     }
 
     memset(pDevice->tx0_bufs, 0,
@@ -1634,7 +1634,7 @@ static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
 	//printk("device_alloc_rx_buf:skb is %x\n",pRDInfo->skb);
 #endif
     if (pRDInfo->skb==NULL)
-        return FALSE;
+        return false;
     ASSERT(pRDInfo->skb);
     pRDInfo->skb->dev = pDevice->dev;
     pRDInfo->skb_dma = pci_map_single(pDevice->pcid, skb_tail_pointer(pRDInfo->skb),
@@ -1655,7 +1655,7 @@ BOOL device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
 
     pDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
     if (pDeF->skb == NULL)
-        return FALSE;
+        return false;
     ASSERT(pDeF->skb);
     pDeF->skb->dev = pDevice->dev;
 
@@ -1666,7 +1666,7 @@ BOOL device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
 
 static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
     PSTxDesc                 pTD;
-    BOOL                     bFull=FALSE;
+    BOOL                     bFull=false;
     int                      works = 0;
     unsigned char byTsr0;
     unsigned char byTsr1;
@@ -1786,7 +1786,7 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
             bFull = true;
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " AC0DMA is Full = %d\n", pDevice->iTDUsed[uIdx]);
         }
-        if (netif_queue_stopped(pDevice->dev) && (bFull==FALSE)){
+        if (netif_queue_stopped(pDevice->dev) && (bFull==false)){
             netif_wake_queue(pDevice->dev);
         }
     }
@@ -1807,7 +1807,7 @@ static void device_error(PSDevice pDevice, unsigned short status) {
         netif_stop_queue(pDevice->dev);
         del_timer(&pDevice->sTimerCommand);
         del_timer(&(pDevice->pMgmt->sTimerSecondCallback));
-        pDevice->bCmdRunning = FALSE;
+        pDevice->bCmdRunning = false;
         MACbShutdown(pDevice->PortOffset);
         return;
     }
@@ -1917,8 +1917,8 @@ static int  device_open(struct net_device *dev) {
      wpa_Result.proto = 0;
      wpa_Result.key_mgmt = 0;
      wpa_Result.eap_type = 0;
-     wpa_Result.authenticated = FALSE;
-     pDevice->fWPA_Authened = FALSE;
+     wpa_Result.authenticated = false;
+     pDevice->fWPA_Authened = false;
 #endif
 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device init rd0 ring\n");
 device_init_rd0_ring(pDevice);
@@ -1983,16 +1983,16 @@ DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
 
 	#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 	/*
-     pDevice->bwextstep0 = FALSE;
-     pDevice->bwextstep1 = FALSE;
-     pDevice->bwextstep2 = FALSE;
-     pDevice->bwextstep3 = FALSE;
+     pDevice->bwextstep0 = false;
+     pDevice->bwextstep1 = false;
+     pDevice->bwextstep2 = false;
+     pDevice->bwextstep3 = false;
      */
        pDevice->bwextcount=0;
-     pDevice->bWPASuppWextEnabled = FALSE;
+     pDevice->bWPASuppWextEnabled = false;
 #endif
     pDevice->byReAssocCount = 0;
-   pDevice->bWPADEVUp = FALSE;
+   pDevice->bWPADEVUp = false;
     // Patch: if WEP key already set by iwconfig but device not yet open
     if ((pDevice->bEncryptionEnable == true) && (pDevice->bTransmitKey == true)) {
         KeybSetDefaultKey(&(pDevice->sKey),
@@ -2055,12 +2055,12 @@ static int  device_close(struct net_device *dev) {
 	tasklet_kill(&pDevice->RxMngWorkItem);
 #endif
      netif_stop_queue(dev);
-    pDevice->bCmdRunning = FALSE;
+    pDevice->bCmdRunning = false;
     MACbShutdown(pDevice->PortOffset);
     MACbSoftwareReset(pDevice->PortOffset);
     CARDbRadioPowerOff(pDevice);
 
-    pDevice->bLinkPass = FALSE;
+    pDevice->bLinkPass = false;
     memset(pMgmt->abyCurrBSSID, 0, 6);
     pMgmt->eCurrState = WMAC_STATE_IDLE;
     device_free_td0_ring(pDevice);
@@ -2124,7 +2124,7 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
     unsigned int cbFrameBodySize;
     unsigned int uMACfragNum;
     unsigned char byPktType;
-    BOOL            bNeedEncryption = FALSE;
+    BOOL            bNeedEncryption = false;
     PSKeyItem       pTransmitKey = NULL;
     unsigned int cbHeaderSize;
     unsigned int ii;
@@ -2134,20 +2134,20 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 
     if (pDevice->bStopTx0Pkt == true) {
         dev_kfree_skb_irq(skb);
-        return FALSE;
+        return false;
     };
 
     if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
         dev_kfree_skb_irq(skb);
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, td0 <=0\n");
-        return FALSE;
+        return false;
     }
 
     if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
         if (pDevice->uAssocCount == 0) {
             dev_kfree_skb_irq(skb);
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, assocCount = 0\n");
-            return FALSE;
+            return false;
         }
     }
 
@@ -2166,7 +2166,7 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 
     if ( uMACfragNum > AVAIL_TD(pDevice, TYPE_TXDMA0)) {
         dev_kfree_skb_irq(skb);
-        return FALSE;
+        return false;
     }
     byPktType = (unsigned char)pDevice->byPacketType;
 
@@ -2239,7 +2239,7 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
         MACbPSWakeup(pDevice->PortOffset);
     }
 
-    pDevice->bPWBitOn = FALSE;
+    pDevice->bPWBitOn = false;
 
     pLastTD = pHeadTD;
     for (ii = 0; ii < uMACfragNum; ii++) {
@@ -2279,19 +2279,19 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     unsigned int cbFrameBodySize;
     unsigned char byPktType;
     unsigned int cbHeaderSize;
-    BOOL            bNeedEncryption = FALSE;
+    BOOL            bNeedEncryption = false;
     PSKeyItem       pTransmitKey = NULL;
     SKeyItem        STempKey;
     unsigned int ii;
-    BOOL            bTKIP_UseGTK = FALSE;
-    BOOL            bNeedDeAuth = FALSE;
+    BOOL            bTKIP_UseGTK = false;
+    BOOL            bNeedDeAuth = false;
     unsigned char *pbyBSSID;
-    BOOL            bNodeExist = FALSE;
+    BOOL            bNodeExist = false;
 
 
 
     spin_lock_irq(&pDevice->lock);
-    if (pDevice->bLinkPass == FALSE) {
+    if (pDevice->bLinkPass == false) {
         dev_kfree_skb_irq(skb);
         spin_unlock_irq(&pDevice->lock);
         return 0;
@@ -2346,7 +2346,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
             }
         }
 
-        if (bNodeExist == FALSE) {
+        if (bNodeExist == false) {
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Unknown STA not found in node DB \n");
             dev_kfree_skb_irq(skb);
             spin_unlock_irq(&pDevice->lock);
@@ -2375,7 +2375,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
                 (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
                 pbyBSSID = pDevice->abyBSSID;
                 // get pairwise key
-                if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == FALSE) {
+                if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == false) {
                     // get group key
                     if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == true) {
                         bTKIP_UseGTK = true;
@@ -2400,7 +2400,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
             }
             // get group key
             pbyBSSID = pDevice->abyBroadcastAddr;
-            if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == FALSE) {
+            if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == false) {
                 pTransmitKey = NULL;
                 if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
@@ -2411,7 +2411,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
                 bTKIP_UseGTK = true;
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");
             }
-        } while(FALSE);
+        } while(false);
     }
 
     if (pDevice->bEnableHostWEP) {
@@ -2538,7 +2538,7 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
     if (bNeedEncryption == true) {
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ntohs Pkt Type=%04x\n", ntohs(pDevice->sTxEthHeader.wType));
         if ((pDevice->sTxEthHeader.wType) == TYPE_PKT_802_1x) {
-            bNeedEncryption = FALSE;
+            bNeedEncryption = false;
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Pkt Type=%04x\n", (pDevice->sTxEthHeader.wType));
             if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
                 if (pTransmitKey == NULL) {
@@ -2596,7 +2596,7 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
         // Disable PS
         MACbPSWakeup(pDevice->PortOffset);
     }
-    pDevice->bPWBitOn = FALSE;
+    pDevice->bPWBitOn = false;
 
     pLastTD = pHeadTD;
     for (ii = 0; ii < uMACfragNum; ii++) {
@@ -2638,7 +2638,7 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
     unsigned char Packet_Type;           //802.1x Authentication
     unsigned char Descriptor_type;
     unsigned short Key_info;
-BOOL            bTxeapol_key = FALSE;
+BOOL            bTxeapol_key = false;
     Protocol_Version = skb->data[ETH_HLEN];
     Packet_Type = skb->data[ETH_HLEN+1];
     Descriptor_type = skb->data[ETH_HLEN+1+1+2];
@@ -2773,7 +2773,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
             }
             if (pDevice->dwIsr & ISR_MEASUREEND) {
                 // 802.11h measure end
-                pDevice->bMeasureInProgress = FALSE;
+                pDevice->bMeasureInProgress = false;
                 VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byOrgRCR);
                 MACvSelectPage1(pDevice->PortOffset);
                 VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, pDevice->dwOrgMAR0);
@@ -2801,7 +2801,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
             if (pDevice->dwIsr & ISR_QUIETSTART) {
                 do {
                     ;
-                } while (CARDbStartQuiet(pDevice) == FALSE);
+                } while (CARDbStartQuiet(pDevice) == false);
             }
         }
 
@@ -2809,7 +2809,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
             if (pDevice->bEnableFirstQuiet == true) {
                 pDevice->byQuietStartCount--;
                 if (pDevice->byQuietStartCount == 0) {
-                    pDevice->bEnableFirstQuiet = FALSE;
+                    pDevice->bEnableFirstQuiet = false;
                     MACvSelectPage1(pDevice->PortOffset);
                     MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, (MSRCTL_QUIETTXCHK | MSRCTL_QUIETEN));
                     MACvSelectPage0(pDevice->PortOffset);
@@ -2819,7 +2819,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                 (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE)) {
                 pDevice->byChannelSwitchCount--;
                 if (pDevice->byChannelSwitchCount == 0) {
-                    pDevice->bChannelSwitch = FALSE;
+                    pDevice->bChannelSwitch = false;
                     set_channel(pDevice, pDevice->byNewChannel);
                     VNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);
                     MACvSelectPage1(pDevice->PortOffset);
@@ -2830,7 +2830,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                 }
             }
             if (pDevice->eOPMode == OP_MODE_ADHOC) {
-                //pDevice->bBeaconSent = FALSE;
+                //pDevice->bBeaconSent = false;
             } else {
                 if ((pDevice->bUpdateBBVGA) && (pDevice->bLinkPass == true) && (pDevice->uCurrRSSI != 0)) {
                     long            ldBm;
@@ -2861,7 +2861,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                 }
             }
 
-            pDevice->bBeaconSent = FALSE;
+            pDevice->bBeaconSent = false;
             if (pDevice->bEnablePSMode) {
                 PSbIsNextTBTTWakeUp((void *)pDevice);
             };
@@ -2882,14 +2882,14 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
         if (pDevice->dwIsr & ISR_BNTX) {
 
             if (pDevice->eOPMode == OP_MODE_ADHOC) {
-                pDevice->bIsBeaconBufReadySet = FALSE;
+                pDevice->bIsBeaconBufReadySet = false;
                 pDevice->cbBeaconBufReadySetCnt = 0;
             };
 
             if (pDevice->eOPMode == OP_MODE_AP) {
                 if(pMgmt->byDTIMCount > 0) {
                    pMgmt->byDTIMCount --;
-                   pMgmt->sNodeDBTable[0].bRxPSPoll = FALSE;
+                   pMgmt->sNodeDBTable[0].bRxPSPoll = false;
                 }
                 else {
                     if(pMgmt->byDTIMCount == 0) {
@@ -2905,7 +2905,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
             if (pDevice->bChannelSwitch == true) {
                 pDevice->byChannelSwitchCount--;
                 if (pDevice->byChannelSwitchCount == 0) {
-                    pDevice->bChannelSwitch = FALSE;
+                    pDevice->bChannelSwitch = false;
                     set_channel(pDevice, pDevice->byNewChannel);
                     VNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);
                     MACvSelectPage1(pDevice->PortOffset);
@@ -3559,7 +3559,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
        else {
            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Commit the settings\n");
            spin_lock_irq(&pDevice->lock);
-           pDevice->bLinkPass = FALSE;
+           pDevice->bLinkPass = false;
            memset(pMgmt->abyCurrBSSID, 0, 6);
            pMgmt->eCurrState = WMAC_STATE_IDLE;
            netif_stop_queue(pDevice->dev);
@@ -3571,7 +3571,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
            bScheduleCommand((void *) pDevice, WLAN_CMD_SSID, NULL);
            spin_unlock_irq(&pDevice->lock);
       }
-      pDevice->bCommit = FALSE;
+      pDevice->bCommit = false;
     }
 
     return rc;
@@ -3681,10 +3681,10 @@ viawget_suspend(struct pci_dev *pcid, pm_message_t state)
     pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
     pDevice->uCmdDequeueIdx = 0;
     pDevice->uCmdEnqueueIdx = 0;
-    pDevice->bCmdRunning = FALSE;
+    pDevice->bCmdRunning = false;
     MACbShutdown(pDevice->PortOffset);
     MACvSaveContext(pDevice->PortOffset, pDevice->abyMacContext);
-    pDevice->bLinkPass = FALSE;
+    pDevice->bLinkPass = false;
     memset(pMgmt->abyCurrBSSID, 0, 6);
     pMgmt->eCurrState = WMAC_STATE_IDLE;
     pci_disable_device(pcid);
@@ -3709,8 +3709,8 @@ viawget_resume(struct pci_dev *pcid)
         MACvRestoreContext(pDevice->PortOffset, pDevice->abyMacContext);
         device_init_registers(pDevice, DEVICE_INIT_DXPL);
         if (pMgmt->sNodeDBTable[0].bActive == true) { // Assoc with BSS
-            pMgmt->sNodeDBTable[0].bActive = FALSE;
-            pDevice->bLinkPass = FALSE;
+            pMgmt->sNodeDBTable[0].bActive = false;
+            pDevice->bLinkPass = false;
             if(pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
                 // In Adhoc, BSS state set back to started.
                 pMgmt->eCurrState = WMAC_STATE_STARTED;

commit 1b12068a804711ae2f4fd2876d5706542c1d7ad9
Author: Charles Clment <caratorn@gmail.com>
Date:   Sun Aug 1 17:15:48 2010 +0200

    Staging: vt6655: replace TRUE with in kernel true
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index d498442f14e6..4f9d0a57790e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -396,7 +396,7 @@ device_set_bool_opt(unsigned int *opt, int val,BOOL def,u32 flag, char* name,cha
         *opt|=(def ? flag : 0);
     } else {
         DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: set parameter %s to %s\n",
-            devname,name , val ? "TRUE" : "FALSE");
+            devname,name , val ? "true" : "FALSE");
         *opt|=(val ? flag : 0);
     }
 }
@@ -452,7 +452,7 @@ device_set_options(PSDevice pDevice) {
     pDevice->b11hEnable = (pDevice->sOpts.flags & DEVICE_FLAGS_80211h_MODE) ? 1 : 0;
     pDevice->bDiversityRegCtlON = (pDevice->sOpts.flags & DEVICE_FLAGS_DiversityANT) ? 1 : 0;
     pDevice->uConnectionRate = pDevice->sOpts.data_rate;
-    if (pDevice->uConnectionRate < RATE_AUTO) pDevice->bFixRate = TRUE;
+    if (pDevice->uConnectionRate < RATE_AUTO) pDevice->bFixRate = true;
     pDevice->byBBType = pDevice->sOpts.bbp_type;
     pDevice->byPacketType = pDevice->byBBType;
 
@@ -460,7 +460,7 @@ device_set_options(PSDevice pDevice) {
 	pDevice->byAutoFBCtrl = AUTO_FB_0;
 	//pDevice->byAutoFBCtrl = AUTO_FB_1;
 //PLICE_DEBUG<-
-pDevice->bUpdateBBVGA = TRUE;
+pDevice->bUpdateBBVGA = true;
     pDevice->byFOETuning = 0;
     pDevice->wCTSDuration = 0;
     pDevice->byPreambleType = 0;
@@ -498,7 +498,7 @@ static void s_vCompleteCurrentMeasure (PSDevice pDevice, unsigned char byResult)
 
      if (pDevice->uNumOfMeasureEIDs == 0) {
         VNTWIFIbMeasureReport(  pDevice->pMgmt,
-                                TRUE,
+                                true,
                                 pDevice->pCurrMeasureEID,
                                 byResult,
                                 pDevice->byBasicMap,
@@ -542,7 +542,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
         // Do MACbSoftwareReset in MACvInitialize
         MACbSoftwareReset(pDevice->PortOffset);
         // force CCK
-        pDevice->bCCK = TRUE;
+        pDevice->bCCK = true;
         pDevice->bAES = FALSE;
         pDevice->bProtectMode = FALSE;      //Only used in 11g type, sync with ERP IE
         pDevice->bNonERPPresent = FALSE;
@@ -572,7 +572,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
         // Get Antena
         byValue = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
         if (byValue & EEP_ANTINV)
-            pDevice->bTxRxAntInv = TRUE;
+            pDevice->bTxRxAntInv = true;
         else
             pDevice->bTxRxAntInv = FALSE;
 #ifdef	PLICE_DEBUG
@@ -597,7 +597,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
             pDevice->byTxAntennaMode = ANT_B;
             pDevice->dwTxAntennaSel = 1;
             pDevice->dwRxAntennaSel = 1;
-            if (pDevice->bTxRxAntInv == TRUE)
+            if (pDevice->bTxRxAntInv == true)
                 pDevice->byRxAntennaMode = ANT_A;
             else
                 pDevice->byRxAntennaMode = ANT_B;
@@ -607,7 +607,7 @@ byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
           if((byValue1&0x08)==0)
                 pDevice->bDiversityEnable = FALSE;//SROMbyReadEmbedded(pDevice->PortOffset, 0x50);
             else
-                pDevice->bDiversityEnable = TRUE;
+                pDevice->bDiversityEnable = true;
 #ifdef	PLICE_DEBUG
 		//printk("aux |main antenna: RxAntennaMode is %d\n",pDevice->byRxAntennaMode);
 #endif
@@ -618,13 +618,13 @@ byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
             pDevice->dwRxAntennaSel = 0;
             if (byValue & EEP_ANTENNA_AUX) {
                 pDevice->byTxAntennaMode = ANT_A;
-                if (pDevice->bTxRxAntInv == TRUE)
+                if (pDevice->bTxRxAntInv == true)
                     pDevice->byRxAntennaMode = ANT_B;
                 else
                     pDevice->byRxAntennaMode = ANT_A;
             } else {
                 pDevice->byTxAntennaMode = ANT_B;
-                if (pDevice->bTxRxAntInv == TRUE)
+                if (pDevice->bTxRxAntInv == true)
                     pDevice->byRxAntennaMode = ANT_A;
                 else
                     pDevice->byRxAntennaMode = ANT_B;
@@ -792,21 +792,21 @@ else
             MACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);
 //2008-4-14 <add> by chester for led issue
  #ifdef FOR_LED_ON_NOTEBOOK
-if (pDevice->byGPIO & GPIO0_DATA){pDevice->bHWRadioOff = TRUE;}
+if (pDevice->byGPIO & GPIO0_DATA){pDevice->bHWRadioOff = true;}
 if ( !(pDevice->byGPIO & GPIO0_DATA)){pDevice->bHWRadioOff = FALSE;}
 
             }
-        if ( (pDevice->bRadioControlOff == TRUE)) {
+        if ( (pDevice->bRadioControlOff == true)) {
             CARDbRadioPowerOff(pDevice);
         }
 else  CARDbRadioPowerOn(pDevice);
 #else
             if (((pDevice->byGPIO & GPIO0_DATA) && !(pDevice->byRadioCtl & EEP_RADIOCTL_INV)) ||
                 ( !(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV))) {
-                pDevice->bHWRadioOff = TRUE;
+                pDevice->bHWRadioOff = true;
             }
         }
-        if ((pDevice->bHWRadioOff == TRUE) || (pDevice->bRadioControlOff == TRUE)) {
+        if ((pDevice->bHWRadioOff == true) || (pDevice->bRadioControlOff == true)) {
             CARDbRadioPowerOff(pDevice);
         }
 
@@ -876,7 +876,7 @@ static BOOL device_release_WPADEV(PSDevice pDevice)
   int ii=0;
  // wait_queue_head_t	Set_wait;
   //send device close to wpa_supplicnat layer
-    if (pDevice->bWPADEVUp==TRUE) {
+    if (pDevice->bWPADEVUp==true) {
                  wpahdr = (viawget_wpa_header *)pDevice->skb->data;
                  wpahdr->type = VIAWGET_DEVICECLOSE_MSG;
                  wpahdr->resp_ie_len = 0;
@@ -893,7 +893,7 @@ static BOOL device_release_WPADEV(PSDevice pDevice)
  //wait release WPADEV
               //    init_waitqueue_head(&Set_wait);
               //    wait_event_timeout(Set_wait, ((pDevice->wpadev==NULL)&&(pDevice->skb == NULL)),5*HZ);    //1s wait
-              while((pDevice->bWPADEVUp==TRUE)) {
+              while((pDevice->bWPADEVUp==true)) {
 	        set_current_state(TASK_UNINTERRUPTIBLE);
                  schedule_timeout (HZ/20);          //wait 50ms
                  ii++;
@@ -901,7 +901,7 @@ static BOOL device_release_WPADEV(PSDevice pDevice)
 		  break;
               }
            };
-    return TRUE;
+    return true;
 }
 
 
@@ -919,7 +919,7 @@ static const struct net_device_ops device_netdev_ops = {
 static int __devinit
 vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 {
-    static BOOL bFirst = TRUE;
+    static BOOL bFirst = true;
     struct net_device*  dev = NULL;
     PCHIP_INFO  pChip_info = (PCHIP_INFO)ent->driver_data;
     PSDevice    pDevice;
@@ -1148,7 +1148,7 @@ static BOOL __devinit vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
 
     spin_lock_init(&((*ppDevice)->lock));
 
-    return TRUE;
+    return true;
 }
 
 static BOOL device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {
@@ -1214,7 +1214,7 @@ static BOOL device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {
 		}
 	}
 #endif
-    return TRUE;
+    return true;
 }
 
 static void device_free_info(PSDevice pDevice) {
@@ -1361,7 +1361,7 @@ static BOOL device_init_rings(PSDevice pDevice) {
             pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;
 
 
-    return TRUE;
+    return true;
 }
 
 static void device_free_rings(PSDevice pDevice) {
@@ -1646,7 +1646,7 @@ static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
     pRD->m_rd1RD1.wReqCount = cpu_to_le16(pDevice->rx_buf_sz);
     pRD->buff_addr = cpu_to_le32(pRDInfo->skb_dma);
 
-    return TRUE;
+    return true;
 }
 
 
@@ -1659,7 +1659,7 @@ BOOL device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
     ASSERT(pDeF->skb);
     pDeF->skb->dev = pDevice->dev;
 
-    return TRUE;
+    return true;
 }
 
 
@@ -1783,7 +1783,7 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
         // RESERV_AC0DMA reserved for relay
 
         if (AVAIL_TD(pDevice, uIdx) < RESERV_AC0DMA) {
-            bFull = TRUE;
+            bFull = true;
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " AC0DMA is Full = %d\n", pDevice->iTDUsed[uIdx]);
         }
         if (netif_queue_stopped(pDevice->dev) && (bFull==FALSE)){
@@ -1994,7 +1994,7 @@ DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
     pDevice->byReAssocCount = 0;
    pDevice->bWPADEVUp = FALSE;
     // Patch: if WEP key already set by iwconfig but device not yet open
-    if ((pDevice->bEncryptionEnable == TRUE) && (pDevice->bTransmitKey == TRUE)) {
+    if ((pDevice->bEncryptionEnable == true) && (pDevice->bTransmitKey == true)) {
         KeybSetDefaultKey(&(pDevice->sKey),
                             (unsigned long)(pDevice->byKeyIndex | (1 << 31)),
                             pDevice->uKeyLength,
@@ -2099,7 +2099,7 @@ static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
         return 0;
     }
 
-    if (pDevice->bStopTx0Pkt == TRUE) {
+    if (pDevice->bStopTx0Pkt == true) {
         dev_kfree_skb_irq(skb);
         spin_unlock_irq(&pDevice->lock);
         return 0;
@@ -2132,7 +2132,7 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 //    unsigned char byKeyIndex = 0;
 
 
-    if (pDevice->bStopTx0Pkt == TRUE) {
+    if (pDevice->bStopTx0Pkt == true) {
         dev_kfree_skb_irq(skb);
         return FALSE;
     };
@@ -2205,15 +2205,15 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
     } else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
         byPktType = PK_TYPE_11A;
     } else {
-        if (pDevice->bProtectMode == TRUE) {
+        if (pDevice->bProtectMode == true) {
             byPktType = PK_TYPE_11GB;
         } else {
             byPktType = PK_TYPE_11GA;
         }
     }
 
-    if (pDevice->bEncryptionEnable == TRUE)
-        bNeedEncryption = TRUE;
+    if (pDevice->bEncryptionEnable == true)
+        bNeedEncryption = true;
 
     if (pDevice->bEnableHostWEP) {
         pTransmitKey = &STempKey;
@@ -2263,7 +2263,7 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
     MACvTransmit0(pDevice->PortOffset);
 
 
-    return TRUE;
+    return true;
 }
 
 //TYPE_AC0DMA data tx
@@ -2312,7 +2312,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
         }
         if (is_multicast_ether_addr((unsigned char *)(skb->data))) {
             uNodeIndex = 0;
-            bNodeExist = TRUE;
+            bNodeExist = true;
             if (pMgmt->sNodeDBTable[0].bPSEnable) {
                 skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skb);
                 pMgmt->sNodeDBTable[0].wEnQueueCnt++;
@@ -2341,7 +2341,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
                 }else {
                     pDevice->byPreambleType = PREAMBLE_LONG;
                 }
-                bNodeExist = TRUE;
+                bNodeExist = true;
 
             }
         }
@@ -2367,8 +2367,8 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     }
 
 
-    if (pDevice->bEncryptionEnable == TRUE) {
-        bNeedEncryption = TRUE;
+    if (pDevice->bEncryptionEnable == true) {
+        bNeedEncryption = true;
         // get Transmit key
         do {
             if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
@@ -2377,8 +2377,8 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
                 // get pairwise key
                 if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == FALSE) {
                     // get group key
-                    if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == TRUE) {
-                        bTKIP_UseGTK = TRUE;
+                    if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == true) {
+                        bTKIP_UseGTK = true;
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");
                         break;
                     }
@@ -2395,7 +2395,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"\n");
 
                 // get pairwise key
-                if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == TRUE)
+                if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == true)
                     break;
             }
             // get group key
@@ -2408,7 +2408,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
                 else
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"NOT IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
             } else {
-                bTKIP_UseGTK = TRUE;
+                bTKIP_UseGTK = true;
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");
             }
         } while(FALSE);
@@ -2416,7 +2416,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 
     if (pDevice->bEnableHostWEP) {
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"acdma0: STA index %d\n", uNodeIndex);
-        if (pDevice->bEncryptionEnable == TRUE) {
+        if (pDevice->bEncryptionEnable == true) {
             pTransmitKey = &STempKey;
             pTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;
             pTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;
@@ -2524,7 +2524,7 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
     } else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
         byPktType = PK_TYPE_11A;
     } else {
-        if (pDevice->bProtectMode == TRUE) {
+        if (pDevice->bProtectMode == true) {
             byPktType = PK_TYPE_11GB;
         } else {
             byPktType = PK_TYPE_11GA;
@@ -2535,7 +2535,7 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
 //	printk("FIX RATE:CurrentRate is %d");
 //#endif
 
-    if (bNeedEncryption == TRUE) {
+    if (bNeedEncryption == true) {
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ntohs Pkt Type=%04x\n", ntohs(pDevice->sTxEthHeader.wType));
         if ((pDevice->sTxEthHeader.wType) == TYPE_PKT_802_1x) {
             bNeedEncryption = FALSE;
@@ -2545,18 +2545,18 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Don't Find TX KEY\n");
                 }
                 else {
-                    if (bTKIP_UseGTK == TRUE) {
+                    if (bTKIP_UseGTK == true) {
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"error: KEY is GTK!!~~\n");
                     }
                     else {
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
-                        bNeedEncryption = TRUE;
+                        bNeedEncryption = true;
                     }
                 }
             }
 
             if (pDevice->byCntMeasure == 2) {
-                bNeedDeAuth = TRUE;
+                bNeedDeAuth = true;
                 pDevice->s802_11Counter.TKIPCounterMeasuresInvoked++;
             }
 
@@ -2564,7 +2564,7 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
                 if ((uNodeIndex != 0) &&
                     (pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex & PAIRWISE_KEY)) {
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
-                    bNeedEncryption = TRUE;
+                    bNeedEncryption = true;
                  }
              }
         }
@@ -2646,11 +2646,11 @@ BOOL            bTxeapol_key = FALSE;
    if (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {
            if(((Protocol_Version==1) ||(Protocol_Version==2)) &&
 	        (Packet_Type==3)) {  //802.1x OR eapol-key challenge frame transfer
-                        bTxeapol_key = TRUE;
+                        bTxeapol_key = true;
 		if((Descriptor_type==254)||(Descriptor_type==2)) {       //WPA or RSN
                        if(!(Key_info & BIT3) &&   //group-key challenge
 			   (Key_info & BIT8) && (Key_info & BIT9)) {    //send 2/2 key
-			  pDevice->fWPA_Authened = TRUE;
+			  pDevice->fWPA_Authened = true;
 			  if(Descriptor_type==254)
 			      printk("WPA ");
 			  else
@@ -2700,7 +2700,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 
     	if ((pDevice->dwIsr & ISR_RXDMA0) &&
         (pDevice->byLocalID != REV_ID_VT3253_B0) &&
-        (pDevice->bBSSIDFilter == TRUE)) {
+        (pDevice->bBSSIDFilter == true)) {
         // update RSSI
         //BBbReadEmbeded(pDevice->PortOffset, 0x3E, &byRSSI);
         //pDevice->uCurrRSSI = byRSSI;
@@ -2749,9 +2749,9 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                 VNSvInPortD(pDevice->PortOffset + MAC_REG_MAR4, &(pDevice->dwOrgMAR4));
                 MACvSelectPage0(pDevice->PortOffset);
                //xxxx
-               // WCMDbFlushCommandQueue(pDevice->pMgmt, TRUE);
-                if (set_channel(pDevice, pDevice->pCurrMeasureEID->sReq.byChannel) == TRUE) {
-                    pDevice->bMeasureInProgress = TRUE;
+               // WCMDbFlushCommandQueue(pDevice->pMgmt, true);
+                if (set_channel(pDevice, pDevice->pCurrMeasureEID->sReq.byChannel) == true) {
+                    pDevice->bMeasureInProgress = true;
                     MACvSelectPage1(pDevice->PortOffset);
                     MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_READY);
                     MACvSelectPage0(pDevice->PortOffset);
@@ -2806,7 +2806,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
         }
 
         if (pDevice->dwIsr & ISR_TBTT) {
-            if (pDevice->bEnableFirstQuiet == TRUE) {
+            if (pDevice->bEnableFirstQuiet == true) {
                 pDevice->byQuietStartCount--;
                 if (pDevice->byQuietStartCount == 0) {
                     pDevice->bEnableFirstQuiet = FALSE;
@@ -2815,7 +2815,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                     MACvSelectPage0(pDevice->PortOffset);
                 }
             }
-            if ((pDevice->bChannelSwitch == TRUE) &&
+            if ((pDevice->bChannelSwitch == true) &&
                 (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE)) {
                 pDevice->byChannelSwitchCount--;
                 if (pDevice->byChannelSwitchCount == 0) {
@@ -2832,7 +2832,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
             if (pDevice->eOPMode == OP_MODE_ADHOC) {
                 //pDevice->bBeaconSent = FALSE;
             } else {
-                if ((pDevice->bUpdateBBVGA) && (pDevice->bLinkPass == TRUE) && (pDevice->uCurrRSSI != 0)) {
+                if ((pDevice->bUpdateBBVGA) && (pDevice->bLinkPass == true) && (pDevice->uCurrRSSI != 0)) {
                     long            ldBm;
 
                     RFvRSSITodBm(pDevice, (unsigned char) pDevice->uCurrRSSI, &ldBm);
@@ -2895,14 +2895,14 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                     if(pMgmt->byDTIMCount == 0) {
                         // check if mutltcast tx bufferring
                         pMgmt->byDTIMCount = pMgmt->byDTIMPeriod - 1;
-                        pMgmt->sNodeDBTable[0].bRxPSPoll = TRUE;
+                        pMgmt->sNodeDBTable[0].bRxPSPoll = true;
                         bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
                     }
                 }
             }
-            pDevice->bBeaconSent = TRUE;
+            pDevice->bBeaconSent = true;
 
-            if (pDevice->bChannelSwitch == TRUE) {
+            if (pDevice->bChannelSwitch == true) {
                 pDevice->byChannelSwitchCount--;
                 if (pDevice->byChannelSwitchCount == 0) {
                     pDevice->bChannelSwitch = FALSE;
@@ -2993,7 +2993,7 @@ static int Config_FileGetParameter(unsigned char *string,
     source+=strlen(buf1);
 
    memcpy(dest,source,source_len-strlen(buf1));
- return TRUE;
+ return true;
 }
 
 int Config_FileOperation(PSDevice pDevice,BOOL fwrite,unsigned char *Parameter) {
@@ -3042,7 +3042,7 @@ if(filp->f_op->read(filp, buffer, 1024, &filp->f_pos)<0) {
  goto error1;
 }
 
-if(Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer)!=TRUE) {
+if(Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer)!=true) {
   printk("get parameter error?\n");
   result = -1;
   goto error1;
@@ -3565,7 +3565,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
            netif_stop_queue(pDevice->dev);
 	#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 	      pMgmt->eScanType = WMAC_SCAN_ACTIVE;
-	 if(pDevice->bWPASuppWextEnabled !=TRUE)
+	 if(pDevice->bWPASuppWextEnabled !=true)
 	 #endif
            bScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);
            bScheduleCommand((void *) pDevice, WLAN_CMD_SSID, NULL);
@@ -3708,7 +3708,7 @@ viawget_resume(struct pci_dev *pcid)
         spin_lock_irq(&pDevice->lock);
         MACvRestoreContext(pDevice->PortOffset, pDevice->abyMacContext);
         device_init_registers(pDevice, DEVICE_INIT_DXPL);
-        if (pMgmt->sNodeDBTable[0].bActive == TRUE) { // Assoc with BSS
+        if (pMgmt->sNodeDBTable[0].bActive == true) { // Assoc with BSS
             pMgmt->sNodeDBTable[0].bActive = FALSE;
             pDevice->bLinkPass = FALSE;
             if(pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {

commit 5bddefad3e960e70fdb005e48b5be75a5846c4c1
Author: Kulikov Vasiliy <segooon@gmail.com>
Date:   Sat Jul 3 20:04:43 2010 +0400

    Staging: vt6655: use for_each_pci_dev()
    
    Use for_each_pci_dev() to simplify the code.
    
    Signed-off-by: Kulikov Vasiliy <segooon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0d697d09ce36..d498442f14e6 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3655,7 +3655,7 @@ device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
     case SYS_DOWN:
     case SYS_HALT:
     case SYS_POWER_OFF:
-        while ((pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) != NULL) {
+	for_each_pci_dev(pdev) {
             if(pci_dev_driver(pdev) == &device_driver) {
                 if (pci_get_drvdata(pdev))
                     viawget_suspend(pdev, PMSG_HIBERNATE);

commit 3fc9b584c28095fe0d46cfb8bddafdf93947042e
Author: Charles Clment <caratorn@gmail.com>
Date:   Thu Jun 24 11:02:27 2010 -0700

    Staging: vt6655: remove BYTE typedef
    
    Replace all occurrences with unsigned char type.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 7dd866b326e3..0d697d09ce36 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -431,9 +431,9 @@ pOpts->flags|=DEVICE_FLAGS_DiversityANT;
 static void
 device_set_options(PSDevice pDevice) {
 
-    BYTE    abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-    BYTE    abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
-    BYTE    abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
+    unsigned char abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+    unsigned char abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
+    unsigned char abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
 
 
     memcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);
@@ -480,18 +480,18 @@ pDevice->bUpdateBBVGA = TRUE;
     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->bDiversityRegCtlON= %d\n",(int)pDevice->bDiversityRegCtlON);
 }
 
-static void s_vCompleteCurrentMeasure (PSDevice pDevice, BYTE byResult)
+static void s_vCompleteCurrentMeasure (PSDevice pDevice, unsigned char byResult)
 {
     unsigned int ii;
     unsigned long dwDuration = 0;
-    BYTE    byRPI0 = 0;
+    unsigned char byRPI0 = 0;
 
     for(ii=1;ii<8;ii++) {
         pDevice->dwRPIs[ii] *= 255;
         dwDuration |= *((unsigned short *) (pDevice->pCurrMeasureEID->sReq.abyDuration));
         dwDuration <<= 10;
         pDevice->dwRPIs[ii] /= dwDuration;
-        pDevice->abyRPIs[ii] = (BYTE) pDevice->dwRPIs[ii];
+        pDevice->abyRPIs[ii] = (unsigned char) pDevice->dwRPIs[ii];
         byRPI0 += pDevice->abyRPIs[ii];
     }
     pDevice->abyRPIs[0] = (0xFF - byRPI0);
@@ -528,10 +528,10 @@ static void s_vCompleteCurrentMeasure (PSDevice pDevice, BYTE byResult)
 static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 {
     unsigned int ii;
-    BYTE    byValue;
-	BYTE    byValue1;
-    BYTE    byCCKPwrdBm = 0;
-    BYTE    byOFDMPwrdBm = 0;
+    unsigned char byValue;
+    unsigned char byValue1;
+    unsigned char byCCKPwrdBm = 0;
+    unsigned char byOFDMPwrdBm = 0;
     int zonetype=0;
      PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
     MACbShutdown(pDevice->PortOffset);
@@ -702,11 +702,11 @@ else
 
 
         for (ii=0;ii<CB_MAX_CHANNEL_24G;ii++) {
-            pDevice->abyCCKPwrTbl[ii+1] = SROMbyReadEmbedded(pDevice->PortOffset, (BYTE)(ii + EEP_OFS_CCK_PWR_TBL));
+            pDevice->abyCCKPwrTbl[ii+1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_CCK_PWR_TBL));
             if (pDevice->abyCCKPwrTbl[ii+1] == 0) {
                 pDevice->abyCCKPwrTbl[ii+1] = pDevice->byCCKPwr;
             }
-            pDevice->abyOFDMPwrTbl[ii+1] = SROMbyReadEmbedded(pDevice->PortOffset, (BYTE)(ii + EEP_OFS_OFDM_PWR_TBL));
+            pDevice->abyOFDMPwrTbl[ii+1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDM_PWR_TBL));
             if (pDevice->abyOFDMPwrTbl[ii+1] == 0) {
                 pDevice->abyOFDMPwrTbl[ii+1] = pDevice->byOFDMPwrG;
             }
@@ -728,8 +728,8 @@ else
 
         // Load OFDM A Power Table
         for (ii=0;ii<CB_MAX_CHANNEL_5G;ii++) { //RobertYu:20041224, bug using CB_MAX_CHANNEL
-            pDevice->abyOFDMPwrTbl[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (BYTE)(ii + EEP_OFS_OFDMA_PWR_TBL));
-            pDevice->abyOFDMDefaultPwr[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (BYTE)(ii + EEP_OFS_OFDMA_PWR_dBm));
+            pDevice->abyOFDMPwrTbl[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDMA_PWR_TBL));
+            pDevice->abyOFDMDefaultPwr[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDMA_PWR_dBm));
         }
         init_channel_table((void *)pDevice);
 
@@ -1043,7 +1043,7 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 
     dev->base_addr = pDevice->ioaddr;
 #ifdef	PLICE_DEBUG
-	BYTE	value;
+	unsigned char 	value;
 
 	VNSvInPortB(pDevice->PortOffset+0x4F, &value);
 	printk("Before write: value is %x\n",value);
@@ -1157,8 +1157,8 @@ static BOOL device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {
     u8  b;
     unsigned int cis_addr;
 #ifdef	PLICE_DEBUG
-	BYTE       pci_config[256];
-	BYTE	value =0x00;
+	unsigned char pci_config[256];
+	unsigned char 	value =0x00;
 	int		ii,j;
 	u16	max_lat=0x0000;
 	memset(pci_config,0x00,256);
@@ -1668,8 +1668,8 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
     PSTxDesc                 pTD;
     BOOL                     bFull=FALSE;
     int                      works = 0;
-    BYTE                     byTsr0;
-    BYTE                     byTsr1;
+    unsigned char byTsr0;
+    unsigned char byTsr1;
     unsigned int	uFrameSize, uFIFOHeaderSize;
     PSTxBufHead              pTxBufHead;
     struct net_device_stats* pStats = &pDevice->stats;
@@ -1754,7 +1754,7 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
                 if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) &&
                     (pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)) {
                     unsigned short wAID;
-                    BYTE    byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
+                    unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
 
                     skb = pTD->pTDInfo->skb;
                     if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data), &uNodeIndex)) {
@@ -2123,13 +2123,13 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
     PSTxDesc        pHeadTD, pLastTD;
     unsigned int cbFrameBodySize;
     unsigned int uMACfragNum;
-    BYTE            byPktType;
+    unsigned char byPktType;
     BOOL            bNeedEncryption = FALSE;
     PSKeyItem       pTransmitKey = NULL;
     unsigned int cbHeaderSize;
     unsigned int ii;
     SKeyItem        STempKey;
-//    BYTE            byKeyIndex = 0;
+//    unsigned char byKeyIndex = 0;
 
 
     if (pDevice->bStopTx0Pkt == TRUE) {
@@ -2168,7 +2168,7 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
         dev_kfree_skb_irq(skb);
         return FALSE;
     }
-    byPktType = (BYTE)pDevice->byPacketType;
+    byPktType = (unsigned char)pDevice->byPacketType;
 
 
     if (pDevice->bFixRate) {
@@ -2273,11 +2273,11 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     PSMgmtObject    pMgmt = pDevice->pMgmt;
     PSTxDesc        pHeadTD, pLastTD;
     unsigned int uNodeIndex = 0;
-    BYTE            byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
+    unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
     unsigned short wAID;
     unsigned int uMACfragNum = 1;
     unsigned int cbFrameBodySize;
-    BYTE            byPktType;
+    unsigned char byPktType;
     unsigned int cbHeaderSize;
     BOOL            bNeedEncryption = FALSE;
     PSKeyItem       pTransmitKey = NULL;
@@ -2446,7 +2446,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
         }
     }
 
-    byPktType = (BYTE)pDevice->byPacketType;
+    byPktType = (unsigned char)pDevice->byPacketType;
 
     if (pDevice->bFixRate) {
 #ifdef	PLICE_DEBUG
@@ -2471,7 +2471,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 
             }
         }
-        pDevice->byACKRate = (BYTE) pDevice->wCurrentRate;
+        pDevice->byACKRate = (unsigned char) pDevice->wCurrentRate;
         pDevice->byTopCCKBasicRate = RATE_1M;
         pDevice->byTopOFDMBasicRate = RATE_6M;
     }
@@ -2634,9 +2634,9 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
 //#endif
 
 {
-    BYTE  Protocol_Version;    //802.1x Authentication
-    BYTE  Packet_Type;           //802.1x Authentication
-    BYTE  Descriptor_type;
+    unsigned char Protocol_Version;    //802.1x Authentication
+    unsigned char Packet_Type;           //802.1x Authentication
+    unsigned char Descriptor_type;
     unsigned short Key_info;
 BOOL            bTxeapol_key = FALSE;
     Protocol_Version = skb->data[ETH_HLEN];
@@ -2679,11 +2679,11 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
     int             max_count=0;
     unsigned long dwMIBCounter=0;
     PSMgmtObject    pMgmt = pDevice->pMgmt;
-    BYTE            byOrgPageSel=0;
+    unsigned char byOrgPageSel=0;
     int             handled = 0;
-    BYTE            byData = 0;
+    unsigned char byData = 0;
     int             ii= 0;
-//    BYTE            byRSSI;
+//    unsigned char byRSSI;
 
 
     MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
@@ -2835,7 +2835,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                 if ((pDevice->bUpdateBBVGA) && (pDevice->bLinkPass == TRUE) && (pDevice->uCurrRSSI != 0)) {
                     long            ldBm;
 
-                    RFvRSSITodBm(pDevice, (BYTE) pDevice->uCurrRSSI, &ldBm);
+                    RFvRSSITodBm(pDevice, (unsigned char) pDevice->uCurrRSSI, &ldBm);
                     for (ii=0;ii<BB_VGA_LEVEL;ii++) {
                         if (ldBm < pDevice->ldBmThreshold[ii]) {
                             pDevice->byBBVGANew = pDevice->abyBBVGA[ii];

commit 2986db5fd31e312206d3ebfa4786aac04bdbe486
Author: Charles Clment <caratorn@gmail.com>
Date:   Thu Jun 24 11:02:26 2010 -0700

    Staging: vt6655: remove WORD typedef
    
    Replace all occurrences with unsigned short type.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1451bdc08d36..7dd866b326e3 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -775,7 +775,7 @@ else
         if (pDevice->uConnectionRate == RATE_AUTO) {
             pDevice->wCurrentRate = RATE_54M;
         } else {
-            pDevice->wCurrentRate = (WORD)pDevice->uConnectionRate;
+            pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
         }
 
         // default G Mode
@@ -1753,7 +1753,7 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 
                 if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) &&
                     (pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)) {
-                    WORD    wAID;
+                    unsigned short wAID;
                     BYTE    byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
 
                     skb = pTD->pTDInfo->skb;
@@ -1798,7 +1798,7 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 }
 
 
-static void device_error(PSDevice pDevice, WORD status) {
+static void device_error(PSDevice pDevice, unsigned short status) {
 
     if (status & ISR_FETALERR) {
         DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
@@ -2176,13 +2176,13 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
             if (pDevice->uConnectionRate >= RATE_11M) {
                 pDevice->wCurrentRate = RATE_11M;
             } else {
-                pDevice->wCurrentRate = (WORD)pDevice->uConnectionRate;
+                pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
             }
         } else {
             if (pDevice->uConnectionRate >= RATE_54M)
                 pDevice->wCurrentRate = RATE_54M;
             else
-                pDevice->wCurrentRate = (WORD)pDevice->uConnectionRate;
+                pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
         }
     }
     else {
@@ -2274,7 +2274,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     PSTxDesc        pHeadTD, pLastTD;
     unsigned int uNodeIndex = 0;
     BYTE            byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
-    WORD            wAID;
+    unsigned short wAID;
     unsigned int uMACfragNum = 1;
     unsigned int cbFrameBodySize;
     BYTE            byPktType;
@@ -2457,7 +2457,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
             if (pDevice->uConnectionRate >= RATE_11M) {
                 pDevice->wCurrentRate = RATE_11M;
             } else {
-                pDevice->wCurrentRate = (WORD)pDevice->uConnectionRate;
+                pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
             }
         } else {
             if ((pDevice->eCurrentPHYType == PHY_TYPE_11A) &&
@@ -2467,7 +2467,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
                 if (pDevice->uConnectionRate >= RATE_54M)
                     pDevice->wCurrentRate = RATE_54M;
                 else
-                    pDevice->wCurrentRate = (WORD)pDevice->uConnectionRate;
+                    pDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;
 
             }
         }
@@ -2637,7 +2637,7 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
     BYTE  Protocol_Version;    //802.1x Authentication
     BYTE  Packet_Type;           //802.1x Authentication
     BYTE  Descriptor_type;
-    WORD Key_info;
+    unsigned short Key_info;
 BOOL            bTxeapol_key = FALSE;
     Protocol_Version = skb->data[ETH_HLEN];
     Packet_Type = skb->data[ETH_HLEN+1];

commit 0f4c60d61e9c10a0733eacd650c101189bdf75cd
Author: Charles Clment <caratorn@gmail.com>
Date:   Thu Jun 24 11:02:25 2010 -0700

    Staging: vt6655: remove DWORD typedef
    
    Replace all occurrences with unsigned long type, except for pointer fields that
    should be u32 in packed structures and 8-byte-aligned 8 byte long structure
    QWORD.
    
    Thanks to Jiri Slaby for pointing out that simply replacing by unsigned long is
    wrong on x86-64 arch.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 090cc94b2502..1451bdc08d36 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -134,10 +134,10 @@ DEVICE_PARAM(TxDescriptors1,"Number of transmit descriptors1");
 
 
 #define IP_ALIG_DEF     0
-/* IP_byte_align[] is used for IP header DWORD byte aligned
-   0: indicate the IP header won't be DWORD byte aligned.(Default) .
-   1: indicate the IP header will be DWORD byte aligned.
-      In some enviroment, the IP header should be DWORD byte aligned,
+/* IP_byte_align[] is used for IP header unsigned long byte aligned
+   0: indicate the IP header won't be unsigned long byte aligned.(Default) .
+   1: indicate the IP header will be unsigned long byte aligned.
+      In some enviroment, the IP header should be unsigned long byte aligned,
       or the packet will be droped when we receive it. (eg: IPVS)
 */
 DEVICE_PARAM(IP_byte_align,"Enable IP header dword aligned");
@@ -483,7 +483,7 @@ pDevice->bUpdateBBVGA = TRUE;
 static void s_vCompleteCurrentMeasure (PSDevice pDevice, BYTE byResult)
 {
     unsigned int ii;
-    DWORD   dwDuration = 0;
+    unsigned long dwDuration = 0;
     BYTE    byRPI0 = 0;
 
     for(ii=1;ii<8;ii++) {
@@ -1022,8 +1022,8 @@ vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 #ifdef	DEBUG
 	//return  0  ;
 #endif
-    pDevice->PortOffset = (DWORD)ioremap(pDevice->memaddr & PCI_BASE_ADDRESS_MEM_MASK, pDevice->io_size);
-	//pDevice->PortOffset = (DWORD)ioremap(pDevice->ioaddr & PCI_BASE_ADDRESS_IO_MASK, pDevice->io_size);
+    pDevice->PortOffset = (unsigned long)ioremap(pDevice->memaddr & PCI_BASE_ADDRESS_MEM_MASK, pDevice->io_size);
+	//pDevice->PortOffset = (unsigned long)ioremap(pDevice->ioaddr & PCI_BASE_ADDRESS_IO_MASK, pDevice->io_size);
 
 	if(pDevice->PortOffset == 0) {
        printk(KERN_ERR DEVICE_NAME ": Failed to IO remapping ..\n");
@@ -1996,7 +1996,7 @@ DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
     // Patch: if WEP key already set by iwconfig but device not yet open
     if ((pDevice->bEncryptionEnable == TRUE) && (pDevice->bTransmitKey == TRUE)) {
         KeybSetDefaultKey(&(pDevice->sKey),
-                            (DWORD)(pDevice->byKeyIndex | (1 << 31)),
+                            (unsigned long)(pDevice->byKeyIndex | (1 << 31)),
                             pDevice->uKeyLength,
                             NULL,
                             pDevice->abyKey,
@@ -2677,7 +2677,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
     PSDevice     pDevice=(PSDevice) netdev_priv(dev);
 
     int             max_count=0;
-    DWORD           dwMIBCounter=0;
+    unsigned long dwMIBCounter=0;
     PSMgmtObject    pMgmt = pDevice->pMgmt;
     BYTE            byOrgPageSel=0;
     int             handled = 0;

commit 79566eb2df013f0ed20e548f4be0f8afbe78f9a3
Author: Charles Clment <caratorn@gmail.com>
Date:   Mon Jun 21 10:39:51 2010 -0700

    Staging: vt6655: move channel mapping code from card.c to channel.c
    
    Move functions managing the channel mapping to a new channel.c file, as done in
    the staging VT6656 driver. The function names contained in card.c were prefixed
    with CARD followed by the first letter of the return code, remove this and use
    more coherent function names.
    
    The following functions moved and were renamed:
    
    ChannelValid                    -> is_channel_valid
    CARDbSetChannel                 -> set_channel
    CARDvInitChannelTable           -> init_channel_table
    CARDbyGetChannelMapping         -> get_channel_mapping
    CARDvSetCountryInfo             -> set_country_info
    CARDbySetSupportChannels        -> set_support_channels
    CARDbChannelGetList             -> channel_get_list
    CARDvSetCountryIE               -> set_country_IE
    CARDbGetChannelMapInfo          -> get_channel_map_info
    CARDvSetChannelMapInfo          -> set_channel_map_info
    CARDvClearChannelMapInfo        -> clear_channel_map_info
    CARDbyAutoChannelSelect         -> auto_channel_select
    CARDbyGetChannelNumber          -> get_channel_number
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index bd27a959add0..090cc94b2502 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -62,6 +62,7 @@
 
 #include "device.h"
 #include "card.h"
+#include "channel.h"
 #include "baseband.h"
 #include "mac.h"
 #include "tether.h"
@@ -730,7 +731,7 @@ else
             pDevice->abyOFDMPwrTbl[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (BYTE)(ii + EEP_OFS_OFDMA_PWR_TBL));
             pDevice->abyOFDMDefaultPwr[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (BYTE)(ii + EEP_OFS_OFDMA_PWR_dBm));
         }
-        CARDvInitChannelTable((void *)pDevice);
+        init_channel_table((void *)pDevice);
 
 
         if (pDevice->byLocalID > REV_ID_VT3253_B1) {
@@ -2749,7 +2750,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                 MACvSelectPage0(pDevice->PortOffset);
                //xxxx
                // WCMDbFlushCommandQueue(pDevice->pMgmt, TRUE);
-                if (CARDbSetChannel(pDevice, pDevice->pCurrMeasureEID->sReq.byChannel) == TRUE) {
+                if (set_channel(pDevice, pDevice->pCurrMeasureEID->sReq.byChannel) == TRUE) {
                     pDevice->bMeasureInProgress = TRUE;
                     MACvSelectPage1(pDevice->PortOffset);
                     MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_READY);
@@ -2784,7 +2785,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                 // clear measure control
                 MACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);
                 MACvSelectPage0(pDevice->PortOffset);
-                CARDbSetChannel(pDevice, pDevice->byOrgChannel);
+                set_channel(pDevice, pDevice->byOrgChannel);
                 // WCMDbResetCommandQueue(pDevice->pMgmt);
                 MACvSelectPage1(pDevice->PortOffset);
                 MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
@@ -2819,7 +2820,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                 pDevice->byChannelSwitchCount--;
                 if (pDevice->byChannelSwitchCount == 0) {
                     pDevice->bChannelSwitch = FALSE;
-                    CARDbSetChannel(pDevice, pDevice->byNewChannel);
+                    set_channel(pDevice, pDevice->byNewChannel);
                     VNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);
                     MACvSelectPage1(pDevice->PortOffset);
                     MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
@@ -2905,7 +2906,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                 pDevice->byChannelSwitchCount--;
                 if (pDevice->byChannelSwitchCount == 0) {
                     pDevice->bChannelSwitch = FALSE;
-                    CARDbSetChannel(pDevice, pDevice->byNewChannel);
+                    set_channel(pDevice, pDevice->byNewChannel);
                     VNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);
                     MACvSelectPage1(pDevice->PortOffset);
                     MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);

commit 013a468c4504738856d67118492ce7b7fff53a48
Author: Charles Clment <caratorn@gmail.com>
Date:   Tue Jun 15 10:39:24 2010 -0700

    Staging: vt6655: struct pci_driver cleanup
    
    Rename driver struct and callbacks to vt6655_* instead of device_* and add
    __devinit/__devexit directives.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f1af517b74b3..bd27a959add0 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -26,9 +26,9 @@
  *
  * Functions:
  *
- *   device_found1 - module initial (insmod) driver entry
- *   device_remove1 - module remove entry
- *   device_init_info - device structure resource allocation function
+ *   vt6655_probe - module initial (insmod) driver entry
+ *   vt6655_remove - module remove entry
+ *   vt6655_init_info - device structure resource allocation function
  *   device_free_info - device structure resource free function
  *   device_get_pci_info - get allocated pci io/mem resource
  *   device_print_info - print out resource
@@ -284,7 +284,7 @@ static CHIP_INFO chip_info_table[]= {
     {0,NULL}
 };
 
-DEFINE_PCI_DEVICE_TABLE(device_id_table) = {
+DEFINE_PCI_DEVICE_TABLE(vt6655_pci_id_table) = {
 	{ PCI_VDEVICE(VIA, 0x3253), (kernel_ulong_t)chip_info_table},
 	{ 0, }
 };
@@ -292,8 +292,8 @@ DEFINE_PCI_DEVICE_TABLE(device_id_table) = {
 /*---------------------  Static Functions  --------------------------*/
 
 
-static int  device_found1(struct pci_dev *pcid, const struct pci_device_id *ent);
-static BOOL device_init_info(struct pci_dev* pcid, PSDevice* ppDevice, PCHIP_INFO);
+static int  vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent);
+static BOOL vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice, PCHIP_INFO);
 static void device_free_info(PSDevice pDevice);
 static BOOL device_get_pci_info(PSDevice, struct pci_dev* pcid);
 static void device_print_info(PSDevice pDevice);
@@ -358,7 +358,7 @@ static char* get_chip_name(int chip_id) {
     return chip_info_table[i].name;
 }
 
-static void device_remove1(struct pci_dev *pcid)
+static void __devexit vt6655_remove(struct pci_dev *pcid)
 {
     PSDevice pDevice=pci_get_drvdata(pcid);
 
@@ -915,8 +915,8 @@ static const struct net_device_ops device_netdev_ops = {
 
 
 
-static int
-device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
+static int __devinit
+vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)
 {
     static BOOL bFirst = TRUE;
     struct net_device*  dev = NULL;
@@ -948,7 +948,7 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
         bFirst=FALSE;
     }
 
-    if (!device_init_info(pcid, &pDevice, pChip_info)) {
+    if (!vt6655_init_info(pcid, &pDevice, pChip_info)) {
         return -ENOMEM;
     }
     pDevice->dev = dev;
@@ -1122,7 +1122,7 @@ static void device_print_info(PSDevice pDevice)
 
 }
 
-static BOOL device_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
+static BOOL __devinit vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
     PCHIP_INFO pChip_info) {
 
     PSDevice p;
@@ -3601,20 +3601,20 @@ static int ethtool_ioctl(struct net_device *dev, void *useraddr)
 
 /*------------------------------------------------------------------*/
 
-MODULE_DEVICE_TABLE(pci, device_id_table);
+MODULE_DEVICE_TABLE(pci, vt6655_pci_id_table);
 
 static struct pci_driver device_driver = {
         name:       DEVICE_NAME,
-        id_table:   device_id_table,
-        probe:      device_found1,
-        remove:     device_remove1,
+        id_table:   vt6655_pci_id_table,
+        probe:      vt6655_probe,
+        remove:     vt6655_remove,
 #ifdef CONFIG_PM
         suspend:    viawget_suspend,
         resume:     viawget_resume,
 #endif
 };
 
-static int __init device_init_module(void)
+static int __init vt6655_init_module(void)
 {
     int ret;
 
@@ -3630,7 +3630,7 @@ static int __init device_init_module(void)
     return ret;
 }
 
-static void __exit device_cleanup_module(void)
+static void __exit vt6655_cleanup_module(void)
 {
 
 
@@ -3641,8 +3641,8 @@ static void __exit device_cleanup_module(void)
 
 }
 
-module_init(device_init_module);
-module_exit(device_cleanup_module);
+module_init(vt6655_init_module);
+module_exit(vt6655_cleanup_module);
 
 
 #ifdef CONFIG_PM

commit 15df6c2b922de3088203ad90347a30d31ccca67e
Author: Charles Clment <caratorn@gmail.com>
Date:   Sat Jun 5 15:13:48 2010 -0700

    Staging: vt6655: remove PWORD typedef
    
    Use unsigned short * instead.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index ecc362d3fdd9..f1af517b74b3 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -487,7 +487,7 @@ static void s_vCompleteCurrentMeasure (PSDevice pDevice, BYTE byResult)
 
     for(ii=1;ii<8;ii++) {
         pDevice->dwRPIs[ii] *= 255;
-        dwDuration |= *((PWORD) (pDevice->pCurrMeasureEID->sReq.abyDuration));
+        dwDuration |= *((unsigned short *) (pDevice->pCurrMeasureEID->sReq.abyDuration));
         dwDuration <<= 10;
         pDevice->dwRPIs[ii] /= dwDuration;
         pDevice->abyRPIs[ii] = (BYTE) pDevice->dwRPIs[ii];

commit 2989e96f17f2dcbd73aee37856899c2885df0686
Author: Charles Clment <caratorn@gmail.com>
Date:   Sat Jun 5 15:13:47 2010 -0700

    Staging: vt6655: remove PBYTE typedef
    
    Use unsigned char * instead.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index e3c2ba758b2e..ecc362d3fdd9 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1699,13 +1699,13 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
 
                 STAvUpdateTDStatCounter(&pDevice->scStatistic,
                         byTsr0, byTsr1,
-                        (PBYTE)(pTD->pTDInfo->buf + uFIFOHeaderSize),
+                        (unsigned char *)(pTD->pTDInfo->buf + uFIFOHeaderSize),
                         uFrameSize, uIdx);
 
 
                 BSSvUpdateNodeTxCounter(pDevice,
                          byTsr0, byTsr1,
-                         (PBYTE)(pTD->pTDInfo->buf),
+                         (unsigned char *)(pTD->pTDInfo->buf),
                          uFIFOHeaderSize
                          );
 
@@ -1756,7 +1756,7 @@ static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
                     BYTE    byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
 
                     skb = pTD->pTDInfo->skb;
-                    if (BSSDBbIsSTAInNodeDB(pMgmt, (PBYTE)(skb->data), &uNodeIndex)) {
+                    if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data), &uNodeIndex)) {
                         if (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {
                             skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);
                             pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;
@@ -2084,7 +2084,7 @@ device_release_WPADEV(pDevice);
 
 static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
     PSDevice        pDevice=netdev_priv(dev);
-    PBYTE           pbMPDU;
+    unsigned char *pbMPDU;
     unsigned int cbMPDULen = 0;
 
 
@@ -2154,7 +2154,7 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
 
     pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
 
-    memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(skb->data), ETH_HLEN);
+    memcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)(skb->data), ETH_HLEN);
     cbFrameBodySize = skb->len - ETH_HLEN;
 
     // 802.1H
@@ -2228,7 +2228,7 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeI
     }
     vGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,
                         cbFrameBodySize, TYPE_TXDMA0, pHeadTD,
-                        &pDevice->sTxEthHeader, (PBYTE)skb->data, pTransmitKey, uNodeIndex,
+                        &pDevice->sTxEthHeader, (unsigned char *)skb->data, pTransmitKey, uNodeIndex,
                         &uMACfragNum,
                         &cbHeaderSize
                         );
@@ -2284,7 +2284,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     unsigned int ii;
     BOOL            bTKIP_UseGTK = FALSE;
     BOOL            bNeedDeAuth = FALSE;
-    PBYTE           pbyBSSID;
+    unsigned char *pbyBSSID;
     BOOL            bNodeExist = FALSE;
 
 
@@ -2309,7 +2309,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
             spin_unlock_irq(&pDevice->lock);
             return 0;
         }
-        if (is_multicast_ether_addr((PBYTE)(skb->data))) {
+        if (is_multicast_ether_addr((unsigned char *)(skb->data))) {
             uNodeIndex = 0;
             bNodeExist = TRUE;
             if (pMgmt->sNodeDBTable[0].bPSEnable) {
@@ -2321,7 +2321,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
                 return 0;
             }
 }else {
-            if (BSSDBbIsSTAInNodeDB(pMgmt, (PBYTE)(skb->data), &uNodeIndex)) {
+            if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data), &uNodeIndex)) {
                 if (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {
                     skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);
                     pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;
@@ -2358,7 +2358,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
 
 
-    memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(skb->data), ETH_HLEN);
+    memcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)(skb->data), ETH_HLEN);
     cbFrameBodySize = skb->len - ETH_HLEN;
     // 802.1H
     if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN) {
@@ -2586,7 +2586,7 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
 #endif
     vGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,
                         cbFrameBodySize, TYPE_AC0DMA, pHeadTD,
-                        &pDevice->sTxEthHeader, (PBYTE)skb->data, pTransmitKey, uNodeIndex,
+                        &pDevice->sTxEthHeader, (unsigned char *)skb->data, pTransmitKey, uNodeIndex,
                         &uMACfragNum,
                         &cbHeaderSize
                         );

commit e3fd16d0819e3b316a4fe316e5f32032df61e9db
Author: Charles Clment <caratorn@gmail.com>
Date:   Wed Jun 2 09:52:02 2010 -0700

    Staging: vt6655: remove custom ULONG typedef
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c8ae43aba80e..e3c2ba758b2e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -588,7 +588,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
         pDevice->ulDiversityMValue = 100*16;//SROMbyReadEmbedded(pDevice->PortOffset, 0x52);
         pDevice->byTMax = 1;//SROMbyReadEmbedded(pDevice->PortOffset, 0x53);
         pDevice->byTMax2 = 4;//SROMbyReadEmbedded(pDevice->PortOffset, 0x54);
-        pDevice->ulSQ3TH = 0;//(ULONG) SROMbyReadEmbedded(pDevice->PortOffset, 0x55);
+        pDevice->ulSQ3TH = 0;//(unsigned long) SROMbyReadEmbedded(pDevice->PortOffset, 0x55);
         pDevice->byTMax3 = 64;//SROMbyReadEmbedded(pDevice->PortOffset, 0x56);
 
         if (byValue == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {
@@ -851,17 +851,17 @@ else  CARDbRadioPowerOn(pDevice);
 static void device_init_diversity_timer(PSDevice pDevice) {
 
     init_timer(&pDevice->TimerSQ3Tmax1);
-    pDevice->TimerSQ3Tmax1.data = (ULONG)pDevice;
+    pDevice->TimerSQ3Tmax1.data = (unsigned long) pDevice;
     pDevice->TimerSQ3Tmax1.function = (TimerFunction)TimerSQ3CallBack;
     pDevice->TimerSQ3Tmax1.expires = RUN_AT(HZ);
 
     init_timer(&pDevice->TimerSQ3Tmax2);
-    pDevice->TimerSQ3Tmax2.data = (ULONG)pDevice;
+    pDevice->TimerSQ3Tmax2.data = (unsigned long) pDevice;
     pDevice->TimerSQ3Tmax2.function = (TimerFunction)TimerSQ3CallBack;
     pDevice->TimerSQ3Tmax2.expires = RUN_AT(HZ);
 
     init_timer(&pDevice->TimerSQ3Tmax3);
-    pDevice->TimerSQ3Tmax3.data = (ULONG)pDevice;
+    pDevice->TimerSQ3Tmax3.data = (unsigned long) pDevice;
     pDevice->TimerSQ3Tmax3.function = (TimerFunction)TimerState1CallBack;
     pDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);
 
@@ -1112,10 +1112,11 @@ static void device_print_info(PSDevice pDevice)
     DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: %s\n",dev->name, get_chip_name(pDevice->chip_id));
     DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: MAC=%pM", dev->name, dev->dev_addr);
 #ifdef IO_MAP
-    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx  ",(ULONG) pDevice->ioaddr);
+    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx  ",(unsigned long) pDevice->ioaddr);
     DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);
 #else
-    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx Mem=0x%lx ",(ULONG) pDevice->ioaddr,(ULONG) pDevice->PortOffset);
+    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx Mem=0x%lx ",
+		    (unsigned long) pDevice->ioaddr,(unsigned long) pDevice->PortOffset);
     DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);
 #endif
 

commit b6e95cd52a81079abc1def7867e27bf541953089
Author: Charles Clment <caratorn@gmail.com>
Date:   Wed Jun 2 09:52:01 2010 -0700

    Staging: vt6655: remove custom UINT typedef
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 32d38931a5e2..c8ae43aba80e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -329,8 +329,8 @@ static int  device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev);
 static BOOL device_release_WPADEV(PSDevice pDevice);
 
 static int  ethtool_ioctl(struct net_device *dev, void *useraddr);
-static int  device_rx_srv(PSDevice pDevice, UINT uIdx);
-static int  device_tx_srv(PSDevice pDevice, UINT uIdx);
+static int  device_rx_srv(PSDevice pDevice, unsigned int uIdx);
+static int  device_tx_srv(PSDevice pDevice, unsigned int uIdx);
 static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pDesc);
 static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType);
 static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc);
@@ -481,7 +481,7 @@ pDevice->bUpdateBBVGA = TRUE;
 
 static void s_vCompleteCurrentMeasure (PSDevice pDevice, BYTE byResult)
 {
-    UINT    ii;
+    unsigned int ii;
     DWORD   dwDuration = 0;
     BYTE    byRPI0 = 0;
 
@@ -526,7 +526,7 @@ static void s_vCompleteCurrentMeasure (PSDevice pDevice, BYTE byResult)
 
 static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 {
-    UINT    ii;
+    unsigned int ii;
     BYTE    byValue;
 	BYTE    byValue1;
     BYTE    byCCKPwrdBm = 0;
@@ -1153,7 +1153,7 @@ static BOOL device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {
 
     u16 pci_cmd;
     u8  b;
-    UINT cis_addr;
+    unsigned int cis_addr;
 #ifdef	PLICE_DEBUG
 	BYTE       pci_config[256];
 	BYTE	value =0x00;
@@ -1594,7 +1594,7 @@ static void device_free_td1_ring(PSDevice pDevice) {
 
 /*-----------------------------------------------------------------*/
 
-static int device_rx_srv(PSDevice pDevice, UINT uIdx) {
+static int device_rx_srv(PSDevice pDevice, unsigned int uIdx) {
     PSRxDesc    pRD;
     int works = 0;
 
@@ -1662,17 +1662,17 @@ BOOL device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
 
 
 
-static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
+static int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {
     PSTxDesc                 pTD;
     BOOL                     bFull=FALSE;
     int                      works = 0;
     BYTE                     byTsr0;
     BYTE                     byTsr1;
-    UINT                     uFrameSize, uFIFOHeaderSize;
+    unsigned int	uFrameSize, uFIFOHeaderSize;
     PSTxBufHead              pTxBufHead;
     struct net_device_stats* pStats = &pDevice->stats;
     struct sk_buff*          skb;
-    UINT                     uNodeIndex;
+    unsigned int	uNodeIndex;
     PSMgmtObject             pMgmt = pDevice->pMgmt;
 
 
@@ -2084,7 +2084,7 @@ device_release_WPADEV(pDevice);
 static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
     PSDevice        pDevice=netdev_priv(dev);
     PBYTE           pbMPDU;
-    UINT            cbMPDULen = 0;
+    unsigned int cbMPDULen = 0;
 
 
     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211\n");
@@ -2116,16 +2116,16 @@ static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
 
 
 
-BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, UINT uNodeIndex) {
+BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeIndex) {
     PSMgmtObject    pMgmt = pDevice->pMgmt;
     PSTxDesc        pHeadTD, pLastTD;
-    UINT            cbFrameBodySize;
-    UINT            uMACfragNum;
+    unsigned int cbFrameBodySize;
+    unsigned int uMACfragNum;
     BYTE            byPktType;
     BOOL            bNeedEncryption = FALSE;
     PSKeyItem       pTransmitKey = NULL;
-    UINT            cbHeaderSize;
-    UINT            ii;
+    unsigned int cbHeaderSize;
+    unsigned int ii;
     SKeyItem        STempKey;
 //    BYTE            byKeyIndex = 0;
 
@@ -2270,17 +2270,17 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
 
     PSMgmtObject    pMgmt = pDevice->pMgmt;
     PSTxDesc        pHeadTD, pLastTD;
-    UINT            uNodeIndex = 0;
+    unsigned int uNodeIndex = 0;
     BYTE            byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
     WORD            wAID;
-    UINT            uMACfragNum = 1;
-    UINT            cbFrameBodySize;
+    unsigned int uMACfragNum = 1;
+    unsigned int cbFrameBodySize;
     BYTE            byPktType;
-    UINT            cbHeaderSize;
+    unsigned int cbHeaderSize;
     BOOL            bNeedEncryption = FALSE;
     PSKeyItem       pTransmitKey = NULL;
     SKeyItem        STempKey;
-    UINT            ii;
+    unsigned int ii;
     BOOL            bTKIP_UseGTK = FALSE;
     BOOL            bNeedDeAuth = FALSE;
     PBYTE           pbyBSSID;

commit 5c9824e124f67c2590e1dbd33045603c36168609
Author: Charles Clment <caratorn@gmail.com>
Date:   Wed Jun 2 09:51:59 2010 -0700

    Staging: vt6655: remove custom UCHAR typedef
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index a84c9199e854..32d38931a5e2 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -340,7 +340,8 @@ static void device_free_rd0_ring(PSDevice pDevice);
 static void device_free_rd1_ring(PSDevice pDevice);
 static void device_free_rings(PSDevice pDevice);
 static void device_free_frag_buf(PSDevice pDevice);
-static int Config_FileGetParameter(UCHAR *string, UCHAR *dest,UCHAR *source);
+static int Config_FileGetParameter(unsigned char *string,
+		unsigned char *dest, unsigned char *source);
 
 
 /*---------------------  Export Variables  --------------------------*/
@@ -2978,9 +2979,10 @@ static inline u32 ether_crc(int length, unsigned char *data)
 }
 
 //2008-8-4 <add> by chester
-static int Config_FileGetParameter(UCHAR *string, UCHAR *dest,UCHAR *source)
+static int Config_FileGetParameter(unsigned char *string,
+		unsigned char *dest, unsigned char *source)
 {
-  UCHAR buf1[100];
+  unsigned char buf1[100];
   int source_len = strlen(source);
 
     memset(buf1,0,100);
@@ -2993,9 +2995,9 @@ static int Config_FileGetParameter(UCHAR *string, UCHAR *dest,UCHAR *source)
 }
 
 int Config_FileOperation(PSDevice pDevice,BOOL fwrite,unsigned char *Parameter) {
-    UCHAR    *config_path=CONFIG_PATH;
-    UCHAR    *buffer=NULL;
-    UCHAR      tmpbuffer[20];
+    unsigned char *config_path = CONFIG_PATH;
+    unsigned char *buffer = NULL;
+    unsigned char tmpbuffer[20];
     struct file   *filp=NULL;
     mm_segment_t old_fs = get_fs();
     //int oldfsuid=0,oldfsgid=0;

commit b83cc2ed466f1b9938521d73fefe8b34baf265ea
Author: Charles Clment <caratorn@gmail.com>
Date:   Tue Jun 1 12:38:57 2010 -0700

    Staging: vt6655: remove custom LONG typedef
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 3c1ae3962173..a84c9199e854 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2830,7 +2830,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                 //pDevice->bBeaconSent = FALSE;
             } else {
                 if ((pDevice->bUpdateBBVGA) && (pDevice->bLinkPass == TRUE) && (pDevice->uCurrRSSI != 0)) {
-                    LONG            ldBm;
+                    long            ldBm;
 
                     RFvRSSITodBm(pDevice, (BYTE) pDevice->uCurrRSSI, &ldBm);
                     for (ii=0;ii<BB_VGA_LEVEL;ii++) {

commit 7ca3019525e6e3ba727e36dfdc07d8e8d487a5e2
Author: Charles Clment <caratorn@gmail.com>
Date:   Tue Jun 1 12:38:56 2010 -0700

    Staging: vt6655: remove custom INT typedef
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 38f93d6041f0..3c1ae3962173 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -464,18 +464,18 @@ pDevice->bUpdateBBVGA = TRUE;
     pDevice->byPreambleType = 0;
 
 
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uChannel= %d\n",(INT)pDevice->uChannel);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byOpMode= %d\n",(INT)pDevice->byOpMode);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" ePSMode= %d\n",(INT)pDevice->ePSMode);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" wRTSThreshold= %d\n",(INT)pDevice->wRTSThreshold);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortRetryLimit= %d\n",(INT)pDevice->byShortRetryLimit);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byLongRetryLimit= %d\n",(INT)pDevice->byLongRetryLimit);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byPreambleType= %d\n",(INT)pDevice->byPreambleType);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortPreamble= %d\n",(INT)pDevice->byShortPreamble);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uConnectionRate= %d\n",(INT)pDevice->uConnectionRate);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byBBType= %d\n",(INT)pDevice->byBBType);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->b11hEnable= %d\n",(INT)pDevice->b11hEnable);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->bDiversityRegCtlON= %d\n",(INT)pDevice->bDiversityRegCtlON);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uChannel= %d\n",(int)pDevice->uChannel);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byOpMode= %d\n",(int)pDevice->byOpMode);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" ePSMode= %d\n",(int)pDevice->ePSMode);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" wRTSThreshold= %d\n",(int)pDevice->wRTSThreshold);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortRetryLimit= %d\n",(int)pDevice->byShortRetryLimit);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byLongRetryLimit= %d\n",(int)pDevice->byLongRetryLimit);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byPreambleType= %d\n",(int)pDevice->byPreambleType);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortPreamble= %d\n",(int)pDevice->byShortPreamble);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uConnectionRate= %d\n",(int)pDevice->uConnectionRate);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byBBType= %d\n",(int)pDevice->byBBType);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->b11hEnable= %d\n",(int)pDevice->b11hEnable);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->bDiversityRegCtlON= %d\n",(int)pDevice->bDiversityRegCtlON);
 }
 
 static void s_vCompleteCurrentMeasure (PSDevice pDevice, BYTE byResult)
@@ -530,7 +530,7 @@ static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
 	BYTE    byValue1;
     BYTE    byCCKPwrdBm = 0;
     BYTE    byOFDMPwrdBm = 0;
-    INT zonetype=0;
+    int zonetype=0;
      PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
     MACbShutdown(pDevice->PortOffset);
     BBvSoftwareReset(pDevice->PortOffset);
@@ -1710,7 +1710,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
                 if ( !(byTsr1 & TSR1_TERR)) {
                     if (byTsr0 != 0) {
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X].\n",
-                           (INT)uIdx, byTsr1, byTsr0);
+                           (int)uIdx, byTsr1, byTsr0);
                     }
                     if ((pTxBufHead->wFragCtl & FRAGCTL_ENDFRAG) != FRAGCTL_NONFRAG) {
                         pDevice->s802_11Counter.TransmittedFragmentCount ++;
@@ -1720,7 +1720,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
                 }
                 else {
                      DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] dropped & tsr1[%02X] tsr0[%02X].\n",
-                           (INT)uIdx, byTsr1, byTsr0);
+                           (int)uIdx, byTsr1, byTsr0);
                     pStats->tx_errors++;
                     pStats->tx_dropped++;
                 }
@@ -1742,11 +1742,11 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
             if (byTsr1 & TSR1_TERR) {
             if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
-                          (INT)uIdx, byTsr1, byTsr0);
+                          (int)uIdx, byTsr1, byTsr0);
             }
 
 //                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
-//                          (INT)uIdx, byTsr1, byTsr0);
+//                          (int)uIdx, byTsr1, byTsr0);
 
                 if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) &&
                     (pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)) {
@@ -1763,7 +1763,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
                             pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
                             pTD->pTDInfo->byFlags &= ~(TD_FLAGS_NETIF_SKB);
                             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx_srv:tx fail re-queue sta index= %d, QueCnt= %d\n"
-                                    ,(INT)uNodeIndex, pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt);
+                                    ,(int)uNodeIndex, pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt);
                             pStats->tx_errors--;
                             pStats->tx_dropped--;
                         }
@@ -1844,7 +1844,7 @@ void	InitRxManagementQueue(PSDevice  pDevice)
 
 
 //PLICE_DEBUG ->
-INT MlmeThread(
+int MlmeThread(
      void * Context)
 {
 	PSDevice	pDevice =  (PSDevice) Context;

commit 902d2411298a6e0b8a473a0163aa4bf6d5c8a073
Author: Charles Clment <caratorn@gmail.com>
Date:   Fri May 28 12:34:21 2010 -0700

    Staging: vt6655: remove U32 custom macro
    
    Remove custom macro for unsigned 32-bit integers, replace by u32.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 06585c1d3c83..38f93d6041f0 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -384,7 +384,7 @@ device_set_int_opt(int *opt, int val, int min, int max, int def,char* name,char*
 }
 
 static void
-device_set_bool_opt(unsigned int *opt, int val,BOOL def,U32 flag, char* name,char* devname) {
+device_set_bool_opt(unsigned int *opt, int val,BOOL def,u32 flag, char* name,char* devname) {
     (*opt)&=(~flag);
     if (val==-1)
         *opt|=(def ? flag : 0);
@@ -976,7 +976,7 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
 	printk("after get pci_info memaddr is %x, io addr is %x,io_size is %d\n",pDevice->memaddr,pDevice->ioaddr,pDevice->io_size);
 	{
 		int i;
-		U32			bar,len;
+		u32			bar,len;
 		u32 address[] = {
 		PCI_BASE_ADDRESS_0,
 		PCI_BASE_ADDRESS_1,

commit c17ce8c21d809c62b427bf8e2d2672ebe0904fd2
Author: Charles Clment <caratorn@gmail.com>
Date:   Fri May 28 12:34:20 2010 -0700

    Staging: vt6655: remove U16 custom macro
    
    Remove custom macro for unsigned 16-bit integers.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 12d1e8b8a0ee..06585c1d3c83 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1150,14 +1150,14 @@ static BOOL device_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
 
 static BOOL device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {
 
-    U16 pci_cmd;
+    u16 pci_cmd;
     u8  b;
     UINT cis_addr;
 #ifdef	PLICE_DEBUG
 	BYTE       pci_config[256];
 	BYTE	value =0x00;
 	int		ii,j;
-	U16	max_lat=0x0000;
+	u16	max_lat=0x0000;
 	memset(pci_config,0x00,256);
 #endif
 

commit 737c3d708c845ab39bfeb1b656e51e84d5771035
Author: Charles Clment <caratorn@gmail.com>
Date:   Fri May 28 12:34:19 2010 -0700

    Staging: vt6655: remove U8 custom macro
    
    Remove custom macro for unsigned 8-bit integers.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 24b6d4507db6..12d1e8b8a0ee 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1151,7 +1151,7 @@ static BOOL device_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
 static BOOL device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {
 
     U16 pci_cmd;
-    U8  b;
+    u8  b;
     UINT cis_addr;
 #ifdef	PLICE_DEBUG
 	BYTE       pci_config[256];

commit 670ea81eadf68fa68023731e3f747fd6b0c61dd4
Author: Charles Clment <caratorn@gmail.com>
Date:   Wed May 19 11:30:51 2010 -0700

    Staging: vt6655: use is_multicast_ether_addr instead of custom macro
    
    Replace custom macro IS_MULTICAST_ADDRESS by is_multicast_ether_addr
    from <linux/etherdevice.h>.
    Remove linux/if_ether.h include as it is included in
    linux/etherdevice.h already.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index e49bb258b5c3..24b6d4507db6 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2307,7 +2307,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
             spin_unlock_irq(&pDevice->lock);
             return 0;
         }
-        if (IS_MULTICAST_ADDRESS((PBYTE)(skb->data))) {
+        if (is_multicast_ether_addr((PBYTE)(skb->data))) {
             uNodeIndex = 0;
             bNodeExist = TRUE;
             if (pMgmt->sNodeDBTable[0].bPSEnable) {

commit c8d1a126924fcbc1d61ceb830226e0c7afdcc841
Merge: d7dbf4ffee1c 107c161b7dde
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri May 21 12:48:55 2010 -0700

    Merge staging-next tree into Linus's latest version
    
    Conflicts:
            drivers/staging/arlan/arlan-main.c
            drivers/staging/comedi/drivers/cb_das16_cs.c
            drivers/staging/cx25821/cx25821-alsa.c
            drivers/staging/dt3155/dt3155_drv.c
            drivers/staging/hv/hv.c
            drivers/staging/netwave/netwave_cs.c
            drivers/staging/wavelan/wavelan.c
            drivers/staging/wavelan/wavelan_cs.c
            drivers/staging/wlags49_h2/wl_cs.c
    
    This required a bit of hand merging due to the conflicts
    that happened in the later .34-rc releases, as well as
    some staging driver changing coming in through other trees
    (v4l and pcmcia).
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 31c21b779181140e0b7eadadbd5e0f518e131488
Author: Charles Clment <caratorn@gmail.com>
Date:   Tue May 18 11:30:19 2010 -0700

    Staging: vt6655: use ETH_DATA_LEN macro instead of custom one
    
    Replace custom maximum data lenght definition MAX_DATA_LEN by
    ETH_DATA_LEN from <linux/if_ether.h>.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 25894a201b2b..3005892e807c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2156,7 +2156,7 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, UINT uNodeIndex) {
     cbFrameBodySize = skb->len - ETH_HLEN;
 
     // 802.1H
-    if (ntohs(pDevice->sTxEthHeader.wType) > MAX_DATA_LEN) {
+    if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN) {
         cbFrameBodySize += 8;
     }
     uMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);
@@ -2359,7 +2359,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(skb->data), ETH_HLEN);
     cbFrameBodySize = skb->len - ETH_HLEN;
     // 802.1H
-    if (ntohs(pDevice->sTxEthHeader.wType) > MAX_DATA_LEN) {
+    if (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN) {
         cbFrameBodySize += 8;
     }
 

commit 96fe9ee2c2dfe3268961f3873ea6098b9b9f27c2
Author: Charles Clment <caratorn@gmail.com>
Date:   Fri May 14 19:37:33 2010 -0700

    Staging: vt6655: use ETH_HLEN macro instead of custom one
    
    Replaced custom header length definition U_HEADER_LEN by ETH_HLEN
    from <linux/if_ether.h>. Also remove unused U_TYPE_LEN.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 301efc5cbe0d..25894a201b2b 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2152,8 +2152,8 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, UINT uNodeIndex) {
 
     pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
 
-    memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(skb->data), U_HEADER_LEN);
-    cbFrameBodySize = skb->len - U_HEADER_LEN;
+    memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(skb->data), ETH_HLEN);
+    cbFrameBodySize = skb->len - ETH_HLEN;
 
     // 802.1H
     if (ntohs(pDevice->sTxEthHeader.wType) > MAX_DATA_LEN) {
@@ -2356,8 +2356,8 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
 
 
-    memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(skb->data), U_HEADER_LEN);
-    cbFrameBodySize = skb->len - U_HEADER_LEN;
+    memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(skb->data), ETH_HLEN);
+    cbFrameBodySize = skb->len - ETH_HLEN;
     // 802.1H
     if (ntohs(pDevice->sTxEthHeader.wType) > MAX_DATA_LEN) {
         cbFrameBodySize += 8;
@@ -2636,10 +2636,10 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
     BYTE  Descriptor_type;
     WORD Key_info;
 BOOL            bTxeapol_key = FALSE;
-    Protocol_Version = skb->data[U_HEADER_LEN];
-    Packet_Type = skb->data[U_HEADER_LEN+1];
-    Descriptor_type = skb->data[U_HEADER_LEN+1+1+2];
-    Key_info = (skb->data[U_HEADER_LEN+1+1+2+1] << 8)|(skb->data[U_HEADER_LEN+1+1+2+2]);
+    Protocol_Version = skb->data[ETH_HLEN];
+    Packet_Type = skb->data[ETH_HLEN+1];
+    Descriptor_type = skb->data[ETH_HLEN+1+1+2];
+    Key_info = (skb->data[ETH_HLEN+1+1+2+1] << 8)|(skb->data[ETH_HLEN+1+1+2+2]);
    if (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {
            if(((Protocol_Version==1) ||(Protocol_Version==2)) &&
 	        (Packet_Type==3)) {  //802.1x OR eapol-key challenge frame transfer

commit 078b078f662a8e21d5a6fee81007b5337ab962cd
Author: Charles Clment <caratorn@gmail.com>
Date:   Fri May 14 19:37:32 2010 -0700

    Staging: vt6655: use ETH_ALEN macro instead of custom one
    
    Replaced custom ethernet address length definition U_ETHER_ADDR_LEN by
    ETH_ALEN from <linux/if_ether.h>.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index a401f2ad62c8..301efc5cbe0d 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -429,14 +429,14 @@ pOpts->flags|=DEVICE_FLAGS_DiversityANT;
 static void
 device_set_options(PSDevice pDevice) {
 
-    BYTE    abyBroadcastAddr[U_ETHER_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-    BYTE    abySNAP_RFC1042[U_ETHER_ADDR_LEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
-    BYTE    abySNAP_Bridgetunnel[U_ETHER_ADDR_LEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
+    BYTE    abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+    BYTE    abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
+    BYTE    abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
 
 
-    memcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, U_ETHER_ADDR_LEN);
-    memcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, U_ETHER_ADDR_LEN);
-    memcpy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel, U_ETHER_ADDR_LEN);
+    memcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);
+    memcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);
+    memcpy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel, ETH_ALEN);
 
     pDevice->uChannel = pDevice->sOpts.channel_num;
     pDevice->wRTSThreshold = pDevice->sOpts.rts_thresh;
@@ -1971,7 +1971,7 @@ device_init_rd0_ring(pDevice);
 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
 	device_init_registers(pDevice, DEVICE_INIT_COLD);
     MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
-    memcpy(pDevice->pMgmt->abyMACAddr, pDevice->abyCurrentNetAddr, U_ETHER_ADDR_LEN);
+    memcpy(pDevice->pMgmt->abyMACAddr, pDevice->abyCurrentNetAddr, ETH_ALEN);
     device_set_multi(pDevice->dev);
 
     // Init for Key Management

commit 3a215e0ff4184314f7f1a099354a272ddedff289
Author: Charles Clment <caratorn@gmail.com>
Date:   Wed May 12 20:54:39 2010 -0700

    Staging: vt6655: remove IN definition
    
    Remove empty IN definition used to specify input parameters.
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 454277b96eea..a401f2ad62c8 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -478,7 +478,7 @@ pDevice->bUpdateBBVGA = TRUE;
     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->bDiversityRegCtlON= %d\n",(INT)pDevice->bDiversityRegCtlON);
 }
 
-static void s_vCompleteCurrentMeasure (IN PSDevice pDevice, IN BYTE byResult)
+static void s_vCompleteCurrentMeasure (PSDevice pDevice, BYTE byResult)
 {
     UINT    ii;
     DWORD   dwDuration = 0;

commit e64354c0be3b7134c85571a525b2e37fc4a95eef
Author: Charles Clment <caratorn@gmail.com>
Date:   Wed May 12 14:14:00 2010 -0700

    Staging: vt6655: remove HANDLE definition and use
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f690fc2c35c1..454277b96eea 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -2011,11 +2011,11 @@ DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call MACvIntEnable\n");
 	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
 
     if (pDevice->pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-        bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RUN_AP, NULL);
+        bScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);
 	}
 	else {
-        bScheduleCommand((HANDLE)pDevice, WLAN_CMD_BSSID_SCAN, NULL);
-        bScheduleCommand((HANDLE)pDevice, WLAN_CMD_SSID, NULL);
+        bScheduleCommand((void *)pDevice, WLAN_CMD_BSSID_SCAN, NULL);
+        bScheduleCommand((void *)pDevice, WLAN_CMD_SSID, NULL);
     }
     pDevice->flags |=DEVICE_FLAGS_OPENED;
 
@@ -2034,7 +2034,7 @@ static int  device_close(struct net_device *dev) {
 //PLICE_DEBUG<-
 //2007-1121-02<Add>by EinsnLiu
     if (pDevice->bLinkPass) {
-	bScheduleCommand((HANDLE)pDevice, WLAN_CMD_DISASSOCIATE, NULL);
+	bScheduleCommand((void *)pDevice, WLAN_CMD_DISASSOCIATE, NULL);
         mdelay(30);
     }
 #ifdef TxInSleep
@@ -2860,7 +2860,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 
             pDevice->bBeaconSent = FALSE;
             if (pDevice->bEnablePSMode) {
-                PSbIsNextTBTTWakeUp((HANDLE)pDevice);
+                PSbIsNextTBTTWakeUp((void *)pDevice);
             };
 
             if ((pDevice->eOPMode == OP_MODE_AP) ||
@@ -2893,7 +2893,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                         // check if mutltcast tx bufferring
                         pMgmt->byDTIMCount = pMgmt->byDTIMPeriod - 1;
                         pMgmt->sNodeDBTable[0].bRxPSPoll = TRUE;
-                        bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
+                        bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
                     }
                 }
             }
@@ -3549,7 +3549,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
        if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
            netif_stop_queue(pDevice->dev);
            spin_lock_irq(&pDevice->lock);
-           bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RUN_AP, NULL);
+           bScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);
            spin_unlock_irq(&pDevice->lock);
        }
        else {
@@ -3563,8 +3563,8 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	      pMgmt->eScanType = WMAC_SCAN_ACTIVE;
 	 if(pDevice->bWPASuppWextEnabled !=TRUE)
 	 #endif
-           bScheduleCommand((HANDLE) pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);
-           bScheduleCommand((HANDLE) pDevice, WLAN_CMD_SSID, NULL);
+           bScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);
+           bScheduleCommand((void *) pDevice, WLAN_CMD_SSID, NULL);
            spin_unlock_irq(&pDevice->lock);
       }
       pDevice->bCommit = FALSE;
@@ -3719,9 +3719,9 @@ viawget_resume(struct pci_dev *pcid)
         init_timer(&pMgmt->sTimerSecondCallback);
         init_timer(&pDevice->sTimerCommand);
         MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
-        BSSvClearBSSList((HANDLE)pDevice, pDevice->bLinkPass);
-        bScheduleCommand((HANDLE) pDevice, WLAN_CMD_BSSID_SCAN, NULL);
-        bScheduleCommand((HANDLE) pDevice, WLAN_CMD_SSID, NULL);
+        BSSvClearBSSList((void *)pDevice, pDevice->bLinkPass);
+        bScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, NULL);
+        bScheduleCommand((void *) pDevice, WLAN_CMD_SSID, NULL);
         spin_unlock_irq(&pDevice->lock);
     }
     return 0;

commit 324148788bf3744d90fb6894ec5744eb0ca91b74
Author: Julia Lawall <julia@diku.dk>
Date:   Tue May 11 20:26:57 2010 +0200

    Staging: Drop memory allocation cast
    
    Drop cast on the result of kmalloc and similar functions.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    type T;
    @@
    
    - (T *)
      (\(kmalloc\|kzalloc\|kcalloc\|kmem_cache_alloc\|kmem_cache_zalloc\|
       kmem_cache_alloc_node\|kmalloc_node\|kzalloc_node\)(...))
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 7020ed41e0ca..f690fc2c35c1 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3025,7 +3025,7 @@ int Config_FileOperation(PSDevice pDevice,BOOL fwrite,unsigned char *Parameter)
 	  goto error1;
      	}
 
-buffer = (UCHAR *)kmalloc(1024, GFP_KERNEL);
+buffer = kmalloc(1024, GFP_KERNEL);
 if(buffer==NULL) {
   printk("alllocate mem for file fail?\n");
   result = -1;

commit f65515275ea3e45fdcd0fb78455f542d6fdca086
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Sun May 9 22:10:02 2010 -0500

    staging: vt6655: Fix kernel BUG on driver wpa initialization
    
    In http://bugzilla.novell.com/show_bug.cgi?id=597299, the vt6655 driver
    generates a kernel BUG on a NULL pointer dereference at NULL. This problem
    has been traced to a failure in the wpa_set_wpadev() routine. As the vt6656
    driver does not call this routine, the vt6655 code is similarly set to skip
    the call.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Tested-by: Richard Meek <osl2008@googlemail.com>
    Cc: Stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 8a63a031d00b..7020ed41e0ca 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1091,11 +1091,13 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
     }
 //2008-07-21-01<Add>by MikeLiu
 //register wpadev
+#if 0
    if(wpa_set_wpadev(pDevice, 1)!=0) {
      printk("Fail to Register WPADEV?\n");
         unregister_netdev(pDevice->dev);
         free_netdev(dev);
    }
+#endif
     device_print_info(pDevice);
     pci_set_drvdata(pcid, pDevice);
     return 0;

commit 830a619c02a53d52c86534f7d857b2e8d0ba893f
Author: Charles Clment <caratorn@gmail.com>
Date:   Fri May 7 12:30:20 2010 -0700

    Staging: vt6655: remove PVOID definition and use
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 90ebad15c3dc..8a63a031d00b 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -729,7 +729,7 @@ else
             pDevice->abyOFDMPwrTbl[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (BYTE)(ii + EEP_OFS_OFDMA_PWR_TBL));
             pDevice->abyOFDMDefaultPwr[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (BYTE)(ii + EEP_OFS_OFDMA_PWR_dBm));
         }
-        CARDvInitChannelTable((PVOID)pDevice);
+        CARDvInitChannelTable((void *)pDevice);
 
 
         if (pDevice->byLocalID > REV_ID_VT3253_B1) {
@@ -1074,7 +1074,7 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
     //Enable the chip specified capbilities
     pDevice->flags = pDevice->sOpts.flags | (pChip_info->flags & 0xFF000000UL);
     pDevice->tx_80211 = device_dma0_tx_80211;
-    pDevice->sMgmtObj.pAdapter = (PVOID)pDevice;
+    pDevice->sMgmtObj.pAdapter = (void *)pDevice;
     pDevice->pMgmt = &(pDevice->sMgmtObj);
 
     dev->irq                = pcid->irq;
@@ -1249,7 +1249,7 @@ device_release_WPADEV(pDevice);
         unregister_netdev(dev);
 
     if (pDevice->PortOffset)
-        iounmap((PVOID)pDevice->PortOffset);
+        iounmap((void *)pDevice->PortOffset);
 
     if (pDevice->pcid)
         pci_release_regions(pDevice->pcid);
@@ -1461,7 +1461,7 @@ static void device_free_rd0_ring(PSDevice pDevice) {
 
         dev_kfree_skb(pRDInfo->skb);
 
-        kfree((PVOID)pDesc->pRDInfo);
+        kfree((void *)pDesc->pRDInfo);
     }
 
 }
@@ -1479,7 +1479,7 @@ static void device_free_rd1_ring(PSDevice pDevice) {
 
         dev_kfree_skb(pRDInfo->skb);
 
-        kfree((PVOID)pDesc->pRDInfo);
+        kfree((void *)pDesc->pRDInfo);
     }
 
 }
@@ -1564,7 +1564,7 @@ static void device_free_td0_ring(PSDevice pDevice) {
         if (pTDInfo->skb)
             dev_kfree_skb(pTDInfo->skb);
 
-        kfree((PVOID)pDesc->pTDInfo);
+        kfree((void *)pDesc->pTDInfo);
     }
 }
 
@@ -1582,7 +1582,7 @@ static void device_free_td1_ring(PSDevice pDevice) {
         if (pTDInfo->skb)
             dev_kfree_skb(pTDInfo->skb);
 
-        kfree((PVOID)pDesc->pTDInfo);
+        kfree((void *)pDesc->pTDInfo);
     }
 
 }

commit 6b35b7b3798b652a57fbce480f350aac851431c4
Author: Charles Clment <caratorn@gmail.com>
Date:   Fri May 7 12:30:19 2010 -0700

    Staging: vt6655: remove VOID definition and use
    
    Signed-off-by: Charles Clment <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f1d70e133d16..90ebad15c3dc 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -478,7 +478,7 @@ pDevice->bUpdateBBVGA = TRUE;
     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->bDiversityRegCtlON= %d\n",(INT)pDevice->bDiversityRegCtlON);
 }
 
-static VOID s_vCompleteCurrentMeasure (IN PSDevice pDevice, IN BYTE byResult)
+static void s_vCompleteCurrentMeasure (IN PSDevice pDevice, IN BYTE byResult)
 {
     UINT    ii;
     DWORD   dwDuration = 0;
@@ -847,7 +847,7 @@ else  CARDbRadioPowerOn(pDevice);
 
 
 
-static VOID device_init_diversity_timer(PSDevice pDevice) {
+static void device_init_diversity_timer(PSDevice pDevice) {
 
     init_timer(&pDevice->TimerSQ3Tmax1);
     pDevice->TimerSQ3Tmax1.data = (ULONG)pDevice;
@@ -1830,7 +1830,7 @@ static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc) {
 
 
 //PLICE_DEBUG ->
-VOID	InitRxManagementQueue(PSDevice  pDevice)
+void	InitRxManagementQueue(PSDevice  pDevice)
 {
 	pDevice->rxManeQueue.packet_num = 0;
 	pDevice->rxManeQueue.head = pDevice->rxManeQueue.tail = 0;

commit ecf739e695d5aa404326100c0ba93c211e87a0fe
Author: Forest Bond <forest@alittletooquiet.net>
Date:   Sat Apr 17 11:03:47 2010 -0400

    Staging: vt6655: Rename hostap_set_hostapd, hostap_iotctl.
    
    The functions hostap_set_hostapd, hostap_iotctl clashed with functions of the
    same name with CONFIG_HOSTAP=y and/or CONFIG_VT6656=y.
    
    Signed-off-by: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 50f02ee0b112..f1d70e133d16 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1243,7 +1243,7 @@ device_release_WPADEV(pDevice);
     }
 #ifdef HOSTAP
     if (dev)
-        hostap_set_hostapd(pDevice, 0, 0);
+        vt6655_hostap_set_hostapd(pDevice, 0, 0);
 #endif
     if (dev)
         unregister_netdev(dev);
@@ -3524,7 +3524,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
     case IOCTL_CMD_HOSTAPD:
 
 
-	rc = hostap_ioctl(pDevice, &wrq->u.data);
+	rc = vt6655_hostap_ioctl(pDevice, &wrq->u.data);
         break;
 
     case IOCTL_CMD_WPA:

commit d2c6170bd1c4796ce5017de2987808a6db879483
Author: Joe Perches <joe@perches.com>
Date:   Wed Mar 24 22:17:05 2010 -0700

    Staging: vt6655: Hoist assign from if
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index fde352bc4792..50f02ee0b112 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -638,7 +638,8 @@ byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
 //2008-8-4 <add> by chester
 //zonetype initial
  pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
- if((zonetype=Config_FileOperation(pDevice,FALSE,NULL)) >= 0) {         //read zonetype file ok!
+ zonetype = Config_FileOperation(pDevice,FALSE,NULL);
+ if (zonetype >= 0) {         //read zonetype file ok!
   if ((zonetype == 0)&&
         (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] !=0x00)){          //for USA
     pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0;

commit 646755ad9156eae5d19af5fd0e1a068f1f9d064c
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Mon Mar 22 22:36:20 2010 +0100

    Staging: vt6655: CGI/CSI confusion in device_ioctl()
    
    The wrong messages were printed
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index e40a2e990f4f..fde352bc4792 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3328,7 +3328,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		break;
 
 	case SIOCSIWTXPOW:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWTXPOW \n");
         rc = -EOPNOTSUPP;
 		break;
 
@@ -3406,7 +3406,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		// Get the spy list
 	case SIOCGIWSPY:
 
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWSPY \n");
 		rc = -EOPNOTSUPP;
 		break;
 

commit 871039f02f8ec4ab2e5e9010718caa8e085786f1
Merge: e4077e018b5e 4a1032faac94
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Apr 11 14:53:53 2010 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            drivers/net/stmmac/stmmac_main.c
            drivers/net/wireless/wl12xx/wl1271_cmd.c
            drivers/net/wireless/wl12xx/wl1271_main.c
            drivers/net/wireless/wl12xx/wl1271_spi.c
            net/core/ethtool.c
            net/mac80211/scan.c

commit 22bedad3ce112d5ca1eaf043d4990fa2ed698c87
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Thu Apr 1 21:22:57 2010 +0000

    net: convert multicast list to list_head
    
    Converts the list and the core manipulating with it to be the same as uc_list.
    
    +uses two functions for adding/removing mc address (normal and "global"
     variant) instead of a function parameter.
    +removes dev_mcast.c completely.
    +exposes netdev_hw_addr_list_* macros along with __hw_addr_* functions for
     manipulation with lists on a sandbox (used in bonding and 80211 drivers)
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1d643653a7ed..b698de40a60e 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3079,7 +3079,7 @@ static void device_set_multi(struct net_device *dev) {
 
     PSMgmtObject     pMgmt = pDevice->pMgmt;
     u32              mc_filter[2];
-    struct dev_mc_list *mclist;
+    struct netdev_hw_addr *ha;
 
 
     VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
@@ -3099,8 +3099,8 @@ static void device_set_multi(struct net_device *dev) {
     }
     else {
         memset(mc_filter, 0, sizeof(mc_filter));
-	netdev_for_each_mc_addr(mclist, dev) {
-            int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+	netdev_for_each_mc_addr(ha, dev) {
+            int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
             mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
         }
         MACvSelectPage1(pDevice->PortOffset);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 1d643653a7ed..e40a2e990f4f 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -84,6 +84,7 @@
 #include "iowpa.h"
 #include <linux/delay.h>
 #include <linux/kthread.h>
+#include <linux/slab.h>
 
 //#define	DEBUG
 /*---------------------  Static Definitions -------------------------*/

commit f341dddf1dadf64be309791f83d7904245f1261d
Merge: eaa5eec73963 b02957d58a27
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Mar 4 08:39:02 2010 -0800

    Staging: merge staging patches into Linus's main branch
    
    There were a number of patches that went into Linus's
    tree already that conflicted with other changes in the
    staging branch.  This merge resolves those merge conflicts.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 00367a6d7caae9c6b077e177aeebad5b0a91ea62
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Dec 28 19:38:22 2009 -0500

    Staging: vt6655/device_main.c: use %pM to shown MAC address
    
    Trivial, use the %pM kernel extension to display the MAC address.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0db8d7b6e79c..ddf3aa04db09 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1105,10 +1105,7 @@ static void device_print_info(PSDevice pDevice)
     struct net_device* dev=pDevice->dev;
 
     DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: %s\n",dev->name, get_chip_name(pDevice->chip_id));
-    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: MAC=%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
-        dev->name,
-        dev->dev_addr[0],dev->dev_addr[1],dev->dev_addr[2],
-        dev->dev_addr[3],dev->dev_addr[4],dev->dev_addr[5]);
+    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: MAC=%pM", dev->name, dev->dev_addr);
 #ifdef IO_MAP
     DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx  ",(ULONG) pDevice->ioaddr);
     DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);

commit d59079425f6f1be0da995926b5ad1d54d9e4545d
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Thu Feb 18 05:10:14 2010 +0000

    staging: convert to use netdev_for_each_mc_addr
    
    removed needless checks in arlan-main.c and slicoss.c
    fixed bug in et131x_netdev.c to actually fill addresses in.
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 82b3a6e0b15a..0dadb765fece 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3082,8 +3082,7 @@ static void device_set_multi(struct net_device *dev) {
 
     PSMgmtObject     pMgmt = pDevice->pMgmt;
     u32              mc_filter[2];
-    int              i;
-    struct dev_mc_list  *mclist;
+    struct dev_mc_list *mclist;
 
 
     VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
@@ -3103,8 +3102,7 @@ static void device_set_multi(struct net_device *dev) {
     }
     else {
         memset(mc_filter, 0, sizeof(mc_filter));
-        for (i = 0, mclist = dev->mc_list; mclist && i < netdev_mc_count(dev);
-             i++, mclist = mclist->next) {
+	netdev_for_each_mc_addr(mclist, dev) {
             int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
             mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
         }

commit 4cd24eaf0c6ee7f0242e34ee77ec899f255e66b5
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Mon Feb 8 04:30:35 2010 +0000

    net: use netdev_mc_count and netdev_mc_empty when appropriate
    
    This patch replaces dev->mc_count in all drivers (hopefully I didn't miss
    anything). Used spatch and did small tweaks and conding style changes when
    it was suitable.
    
    Jirka
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0db8d7b6e79c..82b3a6e0b15a 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3093,7 +3093,7 @@ static void device_set_multi(struct net_device *dev) {
         /* Unconditionally log net taps. */
         pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);
     }
-    else if ((dev->mc_count > pDevice->multicast_limit)
+    else if ((netdev_mc_count(dev) > pDevice->multicast_limit)
         ||  (dev->flags & IFF_ALLMULTI)) {
         MACvSelectPage1(pDevice->PortOffset);
         VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, 0xffffffff);
@@ -3103,7 +3103,7 @@ static void device_set_multi(struct net_device *dev) {
     }
     else {
         memset(mc_filter, 0, sizeof(mc_filter));
-        for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
+        for (i = 0, mclist = dev->mc_list; mclist && i < netdev_mc_count(dev);
              i++, mclist = mclist->next) {
             int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
             mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));

commit bbc9a9916bc1cd997f3bf303e7930d5f3c804d37
Author: Andr Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:06 2009 -0200

    Staging: fix assorted typos all over the place
    
    Signed-off-by: Andr Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 53450b48eaa6..0db8d7b6e79c 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -661,7 +661,7 @@ else
    if(zonetype!=pDevice->abyEEPROM[EEP_OFS_ZONETYPE])
       printk("zonetype in file[%02x] mismatch with in EEPROM[%02x]\n",zonetype,pDevice->abyEEPROM[EEP_OFS_ZONETYPE]);
    else
-      printk("Read Zonetype file sucess,use default zonetype setting[%02x]\n",zonetype);
+      printk("Read Zonetype file success,use default zonetype setting[%02x]\n",zonetype);
  }
  	}
   else

commit 03cd7136d68b4877a9e1793d31cab38fdcb67434
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Sat Aug 8 00:35:31 2009 +0200

    Staging: vt6655: fix possible Read buffer overflow
    
    If pDevice->sOpts.nRxDescs{0,1} or nTxDescs[{0,1}] is zero, the loop ends with
    i == 0, and we write aRD{0,1}Ring[-1]. apTD{0,1}Rings[-1] respectively.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 449e47a839d9..53450b48eaa6 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1400,7 +1400,8 @@ static void device_init_rd0_ring(PSDevice pDevice) {
         pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
     }
 
-    pDevice->aRD0Ring[i-1].next_desc = cpu_to_le32(pDevice->rd0_pool_dma);
+    if (i > 0)
+        pDevice->aRD0Ring[i-1].next_desc = cpu_to_le32(pDevice->rd0_pool_dma);
     pDevice->pCurrRD[0] = &(pDevice->aRD0Ring[0]);
 }
 
@@ -1424,7 +1425,8 @@ static void device_init_rd1_ring(PSDevice pDevice) {
         pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
     }
 
-    pDevice->aRD1Ring[i-1].next_desc = cpu_to_le32(pDevice->rd1_pool_dma);
+    if (i > 0)
+        pDevice->aRD1Ring[i-1].next_desc = cpu_to_le32(pDevice->rd1_pool_dma);
     pDevice->pCurrRD[1] = &(pDevice->aRD1Ring[0]);
 }
 
@@ -1517,7 +1519,8 @@ static void device_init_td0_ring(PSDevice pDevice) {
         pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
     }
 
-    pDevice->apTD0Rings[i-1].next_desc = cpu_to_le32(pDevice->td0_pool_dma);
+    if (i > 0)
+        pDevice->apTD0Rings[i-1].next_desc = cpu_to_le32(pDevice->td0_pool_dma);
     pDevice->apTailTD[0] = pDevice->apCurrTD[0] =&(pDevice->apTD0Rings[0]);
 
 }
@@ -1542,7 +1545,8 @@ static void device_init_td1_ring(PSDevice pDevice) {
         pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
     }
 
-    pDevice->apTD1Rings[i-1].next_desc = cpu_to_le32(pDevice->td1_pool_dma);
+    if (i > 0)
+        pDevice->apTD1Rings[i-1].next_desc = cpu_to_le32(pDevice->td1_pool_dma);
     pDevice->apTailTD[1] = pDevice->apCurrTD[1] = &(pDevice->apTD1Rings[0]);
 }
 

commit 256a816b6b78bf29fba0c0f1bbcf998953429422
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:16 2009 -0700

    Staging: vt665x: remove tbit.h part 2
    
    Remove use of tbit macros adn remove header file.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 545cf42a8a77..449e47a839d9 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -62,7 +62,6 @@
 
 #include "device.h"
 #include "card.h"
-#include "tbit.h"
 #include "baseband.h"
 #include "mac.h"
 #include "tether.h"
@@ -789,8 +788,8 @@ else
             MACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);
 //2008-4-14 <add> by chester for led issue
  #ifdef FOR_LED_ON_NOTEBOOK
-if (BITbIsBitOn(pDevice->byGPIO,GPIO0_DATA)){pDevice->bHWRadioOff = TRUE;}
-if (BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA)){pDevice->bHWRadioOff = FALSE;}
+if (pDevice->byGPIO & GPIO0_DATA){pDevice->bHWRadioOff = TRUE;}
+if ( !(pDevice->byGPIO & GPIO0_DATA)){pDevice->bHWRadioOff = FALSE;}
 
             }
         if ( (pDevice->bRadioControlOff == TRUE)) {
@@ -798,8 +797,8 @@ if (BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA)){pDevice->bHWRadioOff = FALSE;}
         }
 else  CARDbRadioPowerOn(pDevice);
 #else
-            if ((BITbIsBitOn(pDevice->byGPIO,GPIO0_DATA) && BITbIsBitOff(pDevice->byRadioCtl, EEP_RADIOCTL_INV)) ||
-                (BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA) && BITbIsBitOn(pDevice->byRadioCtl, EEP_RADIOCTL_INV))) {
+            if (((pDevice->byGPIO & GPIO0_DATA) && !(pDevice->byRadioCtl & EEP_RADIOCTL_INV)) ||
+                ( !(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV))) {
                 pDevice->bHWRadioOff = TRUE;
             }
         }
@@ -1703,7 +1702,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
                          uFIFOHeaderSize
                          );
 
-                if (BITbIsBitOff(byTsr1, TSR1_TERR)) {
+                if ( !(byTsr1 & TSR1_TERR)) {
                     if (byTsr0 != 0) {
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X].\n",
                            (INT)uIdx, byTsr1, byTsr0);
@@ -1735,7 +1734,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
 	            }
             }
 
-            if (BITbIsBitOn(byTsr1, TSR1_TERR)) {
+            if (byTsr1 & TSR1_TERR) {
             if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
                           (INT)uIdx, byTsr1, byTsr0);
@@ -2691,7 +2690,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
     /*
       // 2008-05-21 <mark> by Richardtai, we can't read RSSI here, because no packet bound with RSSI
 
-    	if ((BITbIsBitOn(pDevice->dwIsr, ISR_RXDMA0)) &&
+    	if ((pDevice->dwIsr & ISR_RXDMA0) &&
         (pDevice->byLocalID != REV_ID_VT3253_B0) &&
         (pDevice->bBSSIDFilter == TRUE)) {
         // update RSSI
@@ -2732,7 +2731,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
 
         if (pDevice->byLocalID > REV_ID_VT3253_B1) {
 
-            if (BITbIsBitOn(pDevice->dwIsr, ISR_MEASURESTART)) {
+            if (pDevice->dwIsr & ISR_MEASURESTART) {
                 // 802.11h measure start
                 pDevice->byOrgChannel = pDevice->byCurrentCh;
                 VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byOrgRCR));
@@ -2764,7 +2763,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                     MACvSelectPage0(pDevice->PortOffset);
                 }
             }
-            if (BITbIsBitOn(pDevice->dwIsr, ISR_MEASUREEND)) {
+            if (pDevice->dwIsr & ISR_MEASUREEND) {
                 // 802.11h measure end
                 pDevice->bMeasureInProgress = FALSE;
                 VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byOrgRCR);
@@ -2783,7 +2782,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                 MACvSelectPage1(pDevice->PortOffset);
                 MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
                 MACvSelectPage0(pDevice->PortOffset);
-                if (BITbIsBitOn(byData, MSRCTL_FINISH)) {
+                if (byData & MSRCTL_FINISH) {
                     // measure success
                     s_vCompleteCurrentMeasure(pDevice, 0);
                 } else {
@@ -2791,7 +2790,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                     s_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_LATE);
                 }
             }
-            if (BITbIsBitOn(pDevice->dwIsr, ISR_QUIETSTART)) {
+            if (pDevice->dwIsr & ISR_QUIETSTART) {
                 do {
                     ;
                 } while (CARDbStartQuiet(pDevice) == FALSE);

commit 1e5743ca6c91cf345f72b012ae362b88db115bcc
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:12 2009 -0700

    Staging: vt665x: remove tpci.h file
    
    Convert pci register/command defs to use kernel definitions.
    Remove tpci.h.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index b8788a315c47..545cf42a8a77 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1180,17 +1180,17 @@ static BOOL device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {
 
     pDevice->pcid = pcid;
 
-    pci_read_config_byte(pcid, PCI_REG_COMMAND, &b);
-    pci_write_config_byte(pcid, PCI_REG_COMMAND, (b|COMMAND_BUSM));
+    pci_read_config_byte(pcid, PCI_COMMAND, &b);
+    pci_write_config_byte(pcid, PCI_COMMAND, (b|PCI_COMMAND_MASTER));
 
 #ifdef	PLICE_DEBUG
-   	//pci_read_config_word(pcid,PCI_REG_MAX_LAT,&max_lat);
+   	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
 	//printk("max lat is %x,SubSystemID is %x\n",max_lat,pDevice->SubSystemID);
 	//for (ii=0;ii<0xFF;ii++)
-	//pci_read_config_word(pcid,PCI_REG_MAX_LAT,&max_lat);
+	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
 	//max_lat  = 0x20;
-	//pci_write_config_word(pcid,PCI_REG_MAX_LAT,max_lat);
-	//pci_read_config_word(pcid,PCI_REG_MAX_LAT,&max_lat);
+	//pci_write_config_word(pcid,PCI_MAX_LAT,max_lat);
+	//pci_read_config_word(pcid,PCI_MAX_LAT,&max_lat);
 	//printk("max lat is %x\n",max_lat);
 
 	for (ii=0;ii<0xFF;ii++)

commit a7ad322a46663755718a214a9a34e5cfe64d07f7
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:09 2009 -0700

    Staging: vt665x: Clean up include files, Part 2
    
    Remove cplusplus lines from include files
    Remove needless ifdefs on includes to conform with C
    conventions.  Remove misc commented code/includes
    Update TODO
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f158e4c530a7..b8788a315c47 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -60,80 +60,32 @@
  */
 #undef __NO_VERSION__
 
-#if !defined(__DEVICE_H__)
 #include "device.h"
-#endif
-#if !defined(__CARD_H__)
 #include "card.h"
-#endif
-#if !defined(__TBIT_H__)
 #include "tbit.h"
-#endif
-#if !defined(__BASEBAND_H__)
 #include "baseband.h"
-#endif
-#if !defined(__MAC_H__)
 #include "mac.h"
-#endif
-#if !defined(__TETHER_H__)
 #include "tether.h"
-#endif
-#if !defined(__WMGR_H__)
 #include "wmgr.h"
-#endif
-#if !defined(__WCTL_H__)
 #include "wctl.h"
-#endif
-#if !defined(__POWER_H__)
 #include "power.h"
-#endif
-#if !defined(__WCMD_H__)
 #include "wcmd.h"
-#endif
-#if !defined(__IOCMD_H__)
 #include "iocmd.h"
-#endif
-#if !defined(__TCRC_H__)
 #include "tcrc.h"
-#endif
-#if !defined(__RXTX_H__)
 #include "rxtx.h"
-#endif
-#if !defined(__WROUTE_H__)
 #include "wroute.h"
-#endif
-#if !defined(__BSSDB_H__)
 #include "bssdb.h"
-#endif
-#if !defined(__HOSTAP_H__)
 #include "hostap.h"
-#endif
-#if !defined(__WPACTL_H__)
 #include "wpactl.h"
-#endif
-#if !defined(__IOCTL_H__)
 #include "ioctl.h"
-#endif
-#if !defined(__IWCTL_H__)
 #include "iwctl.h"
-#endif
-#if !defined(__DPC_H__)
 #include "dpc.h"
-#endif
-#if !defined(__DATARATE_H__)
 #include "datarate.h"
-#endif
-#if !defined(__RF_H__)
 #include "rf.h"
-#endif
-#if !defined(__IOWPA_H__)
 #include "iowpa.h"
-#endif
-
 #include <linux/delay.h>
 #include <linux/kthread.h>
 
-
 //#define	DEBUG
 /*---------------------  Static Definitions -------------------------*/
 //static int          msglevel                =MSG_LEVEL_DEBUG;

commit a884847a1a30be9a55d975f1e3fe8cf5f922bb79
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:07 2009 -0700

    Staging: vt665x: Typedef and macro cleanup Part 2
    
    Clean up unused typedefs and macros to remove Win32'isms and
    misc non-linux constructs.  Text edits to referencing
    source for less frequently used macros.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c41c02689fe4..f158e4c530a7 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -432,7 +432,7 @@ device_set_int_opt(int *opt, int val, int min, int max, int def,char* name,char*
 }
 
 static void
-device_set_bool_opt(PU32 opt, int val,BOOL def,U32 flag, char* name,char* devname) {
+device_set_bool_opt(unsigned int *opt, int val,BOOL def,U32 flag, char* name,char* devname) {
     (*opt)&=(~flag);
     if (val==-1)
         *opt|=(def ? flag : 0);
@@ -1680,7 +1680,7 @@ static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
     pRDInfo->skb->dev = pDevice->dev;
     pRDInfo->skb_dma = pci_map_single(pDevice->pcid, skb_tail_pointer(pRDInfo->skb),
 				      pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
-    *((PU32) &(pRD->m_rd0RD0)) = 0;
+    *((unsigned int *) &(pRD->m_rd0RD0)) = 0; /* FIX cast */
 
     pRD->m_rd0RD0.wResCount = cpu_to_le16(pDevice->rx_buf_sz);
     pRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;

commit 7e809a9b10ab5ee985e23dea537e0236f026d1ca
Author: Jim Lieb <lieb@canonical.com>
Date:   Thu Jul 30 10:27:21 2009 -0700

    Staging: vt6655 textual cleanup in prep for driver merge
    
    The vt6655 and vt6656 drivers are from a common origin but
    have drifted apart with minor textual differences.  There
    are two changes:
    
      s/DEVICE_PRT/DBG_PRT/g
    
    and
    
      s/byPktTyp/byPktType/g
    
    This significantly reduces the differences between the two file sets
    in preparation to merging the common code.  A few whitespace and text bits were
    also adjusted.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Cc: Forest Bond <forest@alittletooquiet.net>
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index fe9cc783dc78..c41c02689fe4 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -421,11 +421,11 @@ device_set_int_opt(int *opt, int val, int min, int max, int def,char* name,char*
     if (val==-1)
         *opt=def;
     else if (val<min || val>max) {
-        DEVICE_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: the value of parameter %s is invalid, the valid range is (%d-%d)\n" ,
+        DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: the value of parameter %s is invalid, the valid range is (%d-%d)\n" ,
             devname,name, min,max);
         *opt=def;
     } else {
-        DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: set value of parameter %s to %d\n",
+        DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: set value of parameter %s to %d\n",
             devname, name, val);
         *opt=val;
     }
@@ -437,11 +437,11 @@ device_set_bool_opt(PU32 opt, int val,BOOL def,U32 flag, char* name,char* devnam
     if (val==-1)
         *opt|=(def ? flag : 0);
     else if (val<0 || val>1) {
-        DEVICE_PRT(MSG_LEVEL_INFO, KERN_NOTICE
+        DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE
             "%s: the value of parameter %s is invalid, the valid range is (0-1)\n",devname,name);
         *opt|=(def ? flag : 0);
     } else {
-        DEVICE_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: set parameter %s to %s\n",
+        DBG_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: set parameter %s to %s\n",
             devname,name , val ? "TRUE" : "FALSE");
         *opt|=(val ? flag : 0);
     }
@@ -512,18 +512,18 @@ pDevice->bUpdateBBVGA = TRUE;
     pDevice->byPreambleType = 0;
 
 
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uChannel= %d\n",(INT)pDevice->uChannel);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byOpMode= %d\n",(INT)pDevice->byOpMode);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" ePSMode= %d\n",(INT)pDevice->ePSMode);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" wRTSThreshold= %d\n",(INT)pDevice->wRTSThreshold);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortRetryLimit= %d\n",(INT)pDevice->byShortRetryLimit);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byLongRetryLimit= %d\n",(INT)pDevice->byLongRetryLimit);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byPreambleType= %d\n",(INT)pDevice->byPreambleType);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortPreamble= %d\n",(INT)pDevice->byShortPreamble);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uConnectionRate= %d\n",(INT)pDevice->uConnectionRate);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byBBType= %d\n",(INT)pDevice->byBBType);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->b11hEnable= %d\n",(INT)pDevice->b11hEnable);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->bDiversityRegCtlON= %d\n",(INT)pDevice->bDiversityRegCtlON);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uChannel= %d\n",(INT)pDevice->uChannel);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byOpMode= %d\n",(INT)pDevice->byOpMode);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" ePSMode= %d\n",(INT)pDevice->ePSMode);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" wRTSThreshold= %d\n",(INT)pDevice->wRTSThreshold);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortRetryLimit= %d\n",(INT)pDevice->byShortRetryLimit);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byLongRetryLimit= %d\n",(INT)pDevice->byLongRetryLimit);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byPreambleType= %d\n",(INT)pDevice->byPreambleType);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortPreamble= %d\n",(INT)pDevice->byShortPreamble);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uConnectionRate= %d\n",(INT)pDevice->uConnectionRate);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byBBType= %d\n",(INT)pDevice->byBBType);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->b11hEnable= %d\n",(INT)pDevice->b11hEnable);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->bDiversityRegCtlON= %d\n",(INT)pDevice->bDiversityRegCtlON);
 }
 
 static VOID s_vCompleteCurrentMeasure (IN PSDevice pDevice, IN BYTE byResult)
@@ -679,7 +679,7 @@ byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
 #ifdef	PLICE_DEBUG
 	//printk("init registers: TxAntennaMode is %d\n",pDevice->byTxAntennaMode);
 #endif
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",
             pDevice->bDiversityEnable,(int)pDevice->ulDiversityNValue,(int)pDevice->ulDiversityMValue,pDevice->byTMax,pDevice->byTMax2);
 
 //#ifdef ZoneType_DefaultSetting
@@ -691,7 +691,7 @@ byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
         (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] !=0x00)){          //for USA
     pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0;
     pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0B;
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Init Zone Type :USA\n");
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Init Zone Type :USA\n");
   }
  else if((zonetype == 1)&&
  	     (pDevice->abyEEPROM[EEP_OFS_ZONETYPE]!=0x01)){   //for Japan
@@ -702,7 +702,7 @@ byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
  	     (pDevice->abyEEPROM[EEP_OFS_ZONETYPE]!=0x02)){   //for Europe
     pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x02;
     pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Init Zone Type :Europe\n");
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Init Zone Type :Europe\n");
   }
 
 else
@@ -725,12 +725,12 @@ else
         }
 
         pDevice->byRFType &= RF_MASK;
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRFType = %x\n", pDevice->byRFType);
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRFType = %x\n", pDevice->byRFType);
 
         if (pDevice->bZoneRegExist == FALSE) {
             pDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
         }
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byZoneType = %x\n", pDevice->byZoneType);
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byZoneType = %x\n", pDevice->byZoneType);
 
         //Init RF module
         RFbInit(pDevice);
@@ -860,7 +860,7 @@ else  CARDbRadioPowerOn(pDevice);
             pMgmt->eScanType = WMAC_SCAN_PASSIVE;
     // get Permanent network address
     SROMvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Network address = %02x-%02x-%02x=%02x-%02x-%02x\n",
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Network address = %02x-%02x-%02x=%02x-%02x-%02x\n",
         pDevice->abyCurrentNetAddr[0],
         pDevice->abyCurrentNetAddr[1],
         pDevice->abyCurrentNetAddr[2],
@@ -1153,17 +1153,17 @@ static void device_print_info(PSDevice pDevice)
 {
     struct net_device* dev=pDevice->dev;
 
-    DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: %s\n",dev->name, get_chip_name(pDevice->chip_id));
-    DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: MAC=%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
+    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: %s\n",dev->name, get_chip_name(pDevice->chip_id));
+    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: MAC=%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
         dev->name,
         dev->dev_addr[0],dev->dev_addr[1],dev->dev_addr[2],
         dev->dev_addr[3],dev->dev_addr[4],dev->dev_addr[5]);
 #ifdef IO_MAP
-    DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx  ",(ULONG) pDevice->ioaddr);
-    DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);
+    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx  ",(ULONG) pDevice->ioaddr);
+    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);
 #else
-    DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx Mem=0x%lx ",(ULONG) pDevice->ioaddr,(ULONG) pDevice->PortOffset);
-    DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);
+    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx Mem=0x%lx ",(ULONG) pDevice->ioaddr,(ULONG) pDevice->PortOffset);
+    DBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);
 #endif
 
 }
@@ -1288,7 +1288,7 @@ device_release_WPADEV(pDevice);
             ptr->prev->next=ptr->next;
     }
     else {
-        DEVICE_PRT(MSG_LEVEL_ERR, KERN_ERR "info struct not found\n");
+        DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "info struct not found\n");
         return;
     }
 #ifdef HOSTAP
@@ -1324,7 +1324,7 @@ static BOOL device_init_rings(PSDevice pDevice) {
                     &pDevice->pool_dma);
 
     if (vir_pool == NULL) {
-        DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : allocate desc dma memory failed\n", pDevice->dev->name);
+        DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : allocate desc dma memory failed\n", pDevice->dev->name);
         return FALSE;
     }
 
@@ -1352,7 +1352,7 @@ static BOOL device_init_rings(PSDevice pDevice) {
                     &pDevice->tx_bufs_dma0);
 
     if (pDevice->tx0_bufs == NULL) {
-        DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: allocate buf dma memory failed\n", pDevice->dev->name);
+        DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: allocate buf dma memory failed\n", pDevice->dev->name);
         pci_free_consistent(pDevice->pcid,
             pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
             pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
@@ -1441,7 +1441,7 @@ static void device_init_rd0_ring(PSDevice pDevice) {
         pDesc->pRDInfo = alloc_rd_info();
         ASSERT(pDesc->pRDInfo);
         if (!device_alloc_rx_buf(pDevice, pDesc)) {
-            DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc rx bufs\n",
+            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc rx bufs\n",
             pDevice->dev->name);
         }
         pDesc->next = &(pDevice->aRD0Ring[(i+1) % pDevice->sOpts.nRxDescs0]);
@@ -1465,7 +1465,7 @@ static void device_init_rd1_ring(PSDevice pDevice) {
         pDesc->pRDInfo = alloc_rd_info();
         ASSERT(pDesc->pRDInfo);
         if (!device_alloc_rx_buf(pDevice, pDesc)) {
-            DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc rx bufs\n",
+            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc rx bufs\n",
             pDevice->dev->name);
         }
         pDesc->next = &(pDevice->aRD1Ring[(i+1) % pDevice->sOpts.nRxDescs1]);
@@ -1486,7 +1486,7 @@ static void device_init_defrag_cb(PSDevice pDevice) {
     for (i = 0; i < CB_MAX_RX_FRAG; i++) {
         pDeF = &(pDevice->sRxDFCB[i]);
         if (!device_alloc_frag_buf(pDevice, pDeF)) {
-            DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc frag bufs\n",
+            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc frag bufs\n",
                 pDevice->dev->name);
         };
     }
@@ -1645,12 +1645,12 @@ static int device_rx_srv(PSDevice pDevice, UINT uIdx) {
     for (pRD = pDevice->pCurrRD[uIdx];
          pRD->m_rd0RD0.f1Owner == OWNED_BY_HOST;
          pRD = pRD->next) {
-//        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->pCurrRD = %x, works = %d\n", pRD, works);
+//        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->pCurrRD = %x, works = %d\n", pRD, works);
         if (works++>15)
             break;
         if (device_receive_frame(pDevice, pRD)) {
             if (!device_alloc_rx_buf(pDevice,pRD)) {
-                    DEVICE_PRT(MSG_LEVEL_ERR, KERN_ERR
+                    DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
                     "%s: can not allocate rx buf\n", pDevice->dev->name);
                     break;
             }
@@ -1753,7 +1753,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
 
                 if (BITbIsBitOff(byTsr1, TSR1_TERR)) {
                     if (byTsr0 != 0) {
-                        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X].\n",
+                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X].\n",
                            (INT)uIdx, byTsr1, byTsr0);
                     }
                     if ((pTxBufHead->wFragCtl & FRAGCTL_ENDFRAG) != FRAGCTL_NONFRAG) {
@@ -1763,7 +1763,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
                     pStats->tx_bytes += pTD->pTDInfo->skb->len;
                 }
                 else {
-                     DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] dropped & tsr1[%02X] tsr0[%02X].\n",
+                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] dropped & tsr1[%02X] tsr0[%02X].\n",
                            (INT)uIdx, byTsr1, byTsr0);
                     pStats->tx_errors++;
                     pStats->tx_dropped++;
@@ -1772,7 +1772,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
 
             if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
                 if (pDevice->bEnableHostapd) {
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx call back netif.. \n");
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx call back netif.. \n");
                     skb = pTD->pTDInfo->skb;
 	                skb->dev = pDevice->apdev;
 			skb_reset_mac_header(skb);
@@ -1785,11 +1785,11 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
 
             if (BITbIsBitOn(byTsr1, TSR1_TERR)) {
             if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
-                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
                           (INT)uIdx, byTsr1, byTsr0);
             }
 
-//                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
+//                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
 //                          (INT)uIdx, byTsr1, byTsr0);
 
                 if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) &&
@@ -1806,7 +1806,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
                             wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
                             pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
                             pTD->pTDInfo->byFlags &= ~(TD_FLAGS_NETIF_SKB);
-                            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx_srv:tx fail re-queue sta index= %d, QueCnt= %d\n"
+                            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx_srv:tx fail re-queue sta index= %d, QueCnt= %d\n"
                                     ,(INT)uNodeIndex, pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt);
                             pStats->tx_errors--;
                             pStats->tx_dropped--;
@@ -1825,7 +1825,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
 
         if (AVAIL_TD(pDevice, uIdx) < RESERV_AC0DMA) {
             bFull = TRUE;
-            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " AC0DMA is Full = %d\n", pDevice->iTDUsed[uIdx]);
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " AC0DMA is Full = %d\n", pDevice->iTDUsed[uIdx]);
         }
         if (netif_queue_stopped(pDevice->dev) && (bFull==FALSE)){
             netif_wake_queue(pDevice->dev);
@@ -1842,7 +1842,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
 static void device_error(PSDevice pDevice, WORD status) {
 
     if (status & ISR_FETALERR) {
-        DEVICE_PRT(MSG_LEVEL_ERR, KERN_ERR
+        DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
             "%s: Hardware fatal error.\n",
             pDevice->dev->name);
         netif_stop_queue(pDevice->dev);
@@ -1961,7 +1961,7 @@ static int  device_open(struct net_device *dev) {
      wpa_Result.authenticated = FALSE;
      pDevice->fWPA_Authened = FALSE;
 #endif
-DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device init rd0 ring\n");
+DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device init rd0 ring\n");
 device_init_rd0_ring(pDevice);
     device_init_rd1_ring(pDevice);
     device_init_defrag_cb(pDevice);
@@ -2012,7 +2012,7 @@ device_init_rd0_ring(pDevice);
 
   // if (( SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RADIOCTL)&0x06)==0x04)
     //    return -ENOMEM;
-DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
+DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
 	device_init_registers(pDevice, DEVICE_INIT_COLD);
     MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
     memcpy(pDevice->pMgmt->abyMACAddr, pDevice->abyCurrentNetAddr, U_ETHER_ADDR_LEN);
@@ -2051,7 +2051,7 @@ DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
 //printk("DEBUG2\n");
 
 
-DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call MACvIntEnable\n");
+DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call MACvIntEnable\n");
 	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
 
     if (pDevice->pMgmt->eConfigMode == WMAC_CONFIG_AP) {
@@ -2063,7 +2063,7 @@ DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call MACvIntEnable\n");
     }
     pDevice->flags |=DEVICE_FLAGS_OPENED;
 
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success.. \n");
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success.. \n");
     return 0;
 }
 
@@ -2118,7 +2118,7 @@ device_release_WPADEV(pDevice);
 //PLICE_DEBUG->
 	//tasklet_kill(&pDevice->RxMngWorkItem);
 //PLICE_DEBUG<-
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close.. \n");
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close.. \n");
     return 0;
 }
 
@@ -2130,11 +2130,11 @@ static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
     UINT            cbMPDULen = 0;
 
 
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211\n");
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211\n");
     spin_lock_irq(&pDevice->lock);
 
     if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211, td0 <=0\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211, td0 <=0\n");
         dev_kfree_skb_irq(skb);
         spin_unlock_irq(&pDevice->lock);
         return 0;
@@ -2164,7 +2164,7 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, UINT uNodeIndex) {
     PSTxDesc        pHeadTD, pLastTD;
     UINT            cbFrameBodySize;
     UINT            uMACfragNum;
-    BYTE            byPktTyp;
+    BYTE            byPktType;
     BOOL            bNeedEncryption = FALSE;
     PSKeyItem       pTransmitKey = NULL;
     UINT            cbHeaderSize;
@@ -2180,14 +2180,14 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, UINT uNodeIndex) {
 
     if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
         dev_kfree_skb_irq(skb);
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, td0 <=0\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, td0 <=0\n");
         return FALSE;
     }
 
     if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
         if (pDevice->uAssocCount == 0) {
             dev_kfree_skb_irq(skb);
-            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, assocCount = 0\n");
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, assocCount = 0\n");
             return FALSE;
         }
     }
@@ -2209,7 +2209,7 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, UINT uNodeIndex) {
         dev_kfree_skb_irq(skb);
         return FALSE;
     }
-    byPktTyp = (BYTE)pDevice->byPacketType;
+    byPktType = (BYTE)pDevice->byPacketType;
 
 
     if (pDevice->bFixRate) {
@@ -2238,18 +2238,18 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, UINT uNodeIndex) {
         pDevice->byPreambleType = PREAMBLE_LONG;
     }
 
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
 
 
     if (pDevice->wCurrentRate <= RATE_11M) {
-        byPktTyp = PK_TYPE_11B;
+        byPktType = PK_TYPE_11B;
     } else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
-        byPktTyp = PK_TYPE_11A;
+        byPktType = PK_TYPE_11A;
     } else {
         if (pDevice->bProtectMode == TRUE) {
-            byPktTyp = PK_TYPE_11GB;
+            byPktType = PK_TYPE_11GB;
         } else {
-            byPktTyp = PK_TYPE_11GA;
+            byPktType = PK_TYPE_11GA;
         }
     }
 
@@ -2268,7 +2268,7 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, UINT uNodeIndex) {
             pTransmitKey->uKeyLength
             );
     }
-    vGenerateFIFOHeader(pDevice, byPktTyp, pDevice->pbyTmpBuff, bNeedEncryption,
+    vGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,
                         cbFrameBodySize, TYPE_TXDMA0, pHeadTD,
                         &pDevice->sTxEthHeader, (PBYTE)skb->data, pTransmitKey, uNodeIndex,
                         &uMACfragNum,
@@ -2318,7 +2318,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     WORD            wAID;
     UINT            uMACfragNum = 1;
     UINT            cbFrameBodySize;
-    BYTE            byPktTyp;
+    BYTE            byPktType;
     UINT            cbHeaderSize;
     BOOL            bNeedEncryption = FALSE;
     PSKeyItem       pTransmitKey = NULL;
@@ -2370,7 +2370,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
                     // set tx map
                     wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
                     pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Set:pMgmt->abyPSTxMap[%d]= %d\n",
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Set:pMgmt->abyPSTxMap[%d]= %d\n",
                              (wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);
                     spin_unlock_irq(&pDevice->lock);
                     return 0;
@@ -2388,7 +2388,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
         }
 
         if (bNodeExist == FALSE) {
-            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Unknown STA not found in node DB \n");
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Unknown STA not found in node DB \n");
             dev_kfree_skb_irq(skb);
             spin_unlock_irq(&pDevice->lock);
             return 0;
@@ -2420,20 +2420,20 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
                     // get group key
                     if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == TRUE) {
                         bTKIP_UseGTK = TRUE;
-                        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");
+                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");
                         break;
                     }
                 } else {
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get PTK.\n");
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get PTK.\n");
                     break;
                 }
             }else if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
 
                 pbyBSSID = pDevice->sTxEthHeader.abyDstAddr;  //TO_DS = 0 and FROM_DS = 0 --> 802.11 MAC Address1
-                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS Serach Key: \n");
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS Serach Key: \n");
                 for (ii = 0; ii< 6; ii++)
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"%x \n", *(pbyBSSID+ii));
-                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"\n");
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"%x \n", *(pbyBSSID+ii));
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"\n");
 
                 // get pairwise key
                 if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == TRUE)
@@ -2444,19 +2444,19 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
             if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == FALSE) {
                 pTransmitKey = NULL;
                 if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
                 }
                 else
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"NOT IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"NOT IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
             } else {
                 bTKIP_UseGTK = TRUE;
-                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");
             }
         } while(FALSE);
     }
 
     if (pDevice->bEnableHostWEP) {
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"acdma0: STA index %d\n", uNodeIndex);
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"acdma0: STA index %d\n", uNodeIndex);
         if (pDevice->bEncryptionEnable == TRUE) {
             pTransmitKey = &STempKey;
             pTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;
@@ -2474,7 +2474,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     uMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);
 
     if (uMACfragNum > AVAIL_TD(pDevice, TYPE_AC0DMA)) {
-        DEVICE_PRT(MSG_LEVEL_ERR, KERN_DEBUG "uMACfragNum > AVAIL_TD(TYPE_AC0DMA) = %d\n", uMACfragNum);
+        DBG_PRT(MSG_LEVEL_ERR, KERN_DEBUG "uMACfragNum > AVAIL_TD(TYPE_AC0DMA) = %d\n", uMACfragNum);
         dev_kfree_skb_irq(skb);
         spin_unlock_irq(&pDevice->lock);
         return 0;
@@ -2487,7 +2487,7 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
         }
     }
 
-    byPktTyp = (BYTE)pDevice->byPacketType;
+    byPktType = (BYTE)pDevice->byPacketType;
 
     if (pDevice->bFixRate) {
 #ifdef	PLICE_DEBUG
@@ -2558,17 +2558,17 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
 		}
     }
 
-//    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
+//    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
 
     if (pDevice->wCurrentRate <= RATE_11M) {
-        byPktTyp = PK_TYPE_11B;
+        byPktType = PK_TYPE_11B;
     } else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
-        byPktTyp = PK_TYPE_11A;
+        byPktType = PK_TYPE_11A;
     } else {
         if (pDevice->bProtectMode == TRUE) {
-            byPktTyp = PK_TYPE_11GB;
+            byPktType = PK_TYPE_11GB;
         } else {
-            byPktTyp = PK_TYPE_11GA;
+            byPktType = PK_TYPE_11GA;
         }
     }
 
@@ -2577,20 +2577,20 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
 //#endif
 
     if (bNeedEncryption == TRUE) {
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ntohs Pkt Type=%04x\n", ntohs(pDevice->sTxEthHeader.wType));
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ntohs Pkt Type=%04x\n", ntohs(pDevice->sTxEthHeader.wType));
         if ((pDevice->sTxEthHeader.wType) == TYPE_PKT_802_1x) {
             bNeedEncryption = FALSE;
-            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Pkt Type=%04x\n", (pDevice->sTxEthHeader.wType));
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Pkt Type=%04x\n", (pDevice->sTxEthHeader.wType));
             if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
                 if (pTransmitKey == NULL) {
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Don't Find TX KEY\n");
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Don't Find TX KEY\n");
                 }
                 else {
                     if (bTKIP_UseGTK == TRUE) {
-                        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"error: KEY is GTK!!~~\n");
+                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"error: KEY is GTK!!~~\n");
                     }
                     else {
-                        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
+                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
                         bNeedEncryption = TRUE;
                     }
                 }
@@ -2604,14 +2604,14 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
             if (pDevice->bEnableHostWEP) {
                 if ((uNodeIndex != 0) &&
                     (pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex & PAIRWISE_KEY)) {
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
                     bNeedEncryption = TRUE;
                  }
              }
         }
         else {
             if (pTransmitKey == NULL) {
-                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"return no tx key\n");
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"return no tx key\n");
                 dev_kfree_skb_irq(skb);
                 spin_unlock_irq(&pDevice->lock);
                 return 0;
@@ -2626,7 +2626,7 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
 	//	printk("ping:len is %d\n");
 	//}
 #endif
-    vGenerateFIFOHeader(pDevice, byPktTyp, pDevice->pbyTmpBuff, bNeedEncryption,
+    vGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,
                         cbFrameBodySize, TYPE_AC0DMA, pHeadTD,
                         &pDevice->sTxEthHeader, (PBYTE)skb->data, pTransmitKey, uNodeIndex,
                         &uMACfragNum,
@@ -2704,7 +2704,7 @@ BOOL            bTxeapol_key = FALSE;
 }
 
     MACvTransmitAC0(pDevice->PortOffset);
-//    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0:pDevice->apCurrTD= %p\n", pHeadTD);
+//    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0:pDevice->apCurrTD= %p\n", pHeadTD);
 
     dev->trans_start = jiffies;
 
@@ -2733,7 +2733,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
         return IRQ_RETVAL(handled);
 
     if (pDevice->dwIsr == 0xffffffff) {
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwIsr = 0xffff\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwIsr = 0xffff\n");
         return IRQ_RETVAL(handled);
     }
     /*
@@ -2772,7 +2772,7 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
         MACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);
 
         if (pDevice->dwIsr & ISR_FETALERR){
-            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " ISR_FETALERR \n");
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " ISR_FETALERR \n");
             VNSvOutPortB(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, 0);
             VNSvOutPortW(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, SOFTPWRCTL_SWPECTI);
             device_error(pDevice, pDevice->dwIsr);
@@ -2888,11 +2888,11 @@ static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
                         if (pDevice->uBBVGADiffCount == 1) {
                             // first VGA diff gain
                             BBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);
-                            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
+                            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
                                             (int)ldBm, pDevice->byBBVGANew, pDevice->byBBVGACurrent, (int)pDevice->uBBVGADiffCount);
                         }
                         if (pDevice->uBBVGADiffCount >= BB_VGA_CHANGE_THRESHOLD) {
-                            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
+                            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
                                             (int)ldBm, pDevice->byBBVGANew, pDevice->byBBVGACurrent, (int)pDevice->uBBVGADiffCount);
                             BBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);
                         }
@@ -3134,7 +3134,7 @@ static void device_set_multi(struct net_device *dev) {
     VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
 
     if (dev->flags & IFF_PROMISC) {         /* Set promiscuous. */
-        DEVICE_PRT(MSG_LEVEL_ERR,KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
+        DBG_PRT(MSG_LEVEL_ERR,KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
         /* Unconditionally log net taps. */
         pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);
     }
@@ -3168,7 +3168,7 @@ static void device_set_multi(struct net_device *dev) {
     }
 
     VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byRxMode);
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode = %x\n", pDevice->byRxMode );
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode = %x\n", pDevice->byRxMode );
 }
 
 
@@ -3267,13 +3267,13 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 		// Set desired station name
 	case SIOCSIWNICKN:
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN \n");
         rc = -EOPNOTSUPP;
 		break;
 
 		// Get current station name
 	case SIOCGIWNICKN:
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWNICKN \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWNICKN \n");
         rc = -EOPNOTSUPP;
 		break;
 
@@ -3372,12 +3372,12 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 		// Get the current Tx-Power
 	case SIOCGIWTXPOW:
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
         rc = -EOPNOTSUPP;
 		break;
 
 	case SIOCSIWTXPOW:
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
         rc = -EOPNOTSUPP;
 		break;
 
@@ -3422,7 +3422,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		break;
 
 	case SIOCSIWSENS:
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSENS \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSENS \n");
 		rc = -EOPNOTSUPP;
 		break;
 
@@ -3448,21 +3448,21 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		// Set the spy list
 	case SIOCSIWSPY:
 
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
 		rc = -EOPNOTSUPP;
 		break;
 
 		// Get the spy list
 	case SIOCGIWSPY:
 
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
 		rc = -EOPNOTSUPP;
 		break;
 
 #endif // WIRELESS_SPY
 
 	case SIOCGIWPRIV:
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV \n");
 		rc = -EOPNOTSUPP;
 /*
 		if(wrq->u.data.pointer) {
@@ -3480,29 +3480,29 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 //2008-0409-07, <Add> by Einsn Liu
 #ifdef  WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 	case SIOCSIWAUTH:
-		DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAUTH \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAUTH \n");
 		rc = iwctl_siwauth(dev, NULL, &(wrq->u.param), NULL);
 		break;
 
 	case SIOCGIWAUTH:
-		DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWAUTH \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWAUTH \n");
 		rc = iwctl_giwauth(dev, NULL, &(wrq->u.param), NULL);
 		break;
 
 	case SIOCSIWGENIE:
-		DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWGENIE \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWGENIE \n");
 		rc = iwctl_siwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
 		break;
 
 	case SIOCGIWGENIE:
-		DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWGENIE \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWGENIE \n");
 		rc = iwctl_giwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
 		break;
 
 	case SIOCSIWENCODEEXT:
 		{
 			char extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];
-			DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT \n");
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT \n");
 			if(wrq->u.encoding.pointer){
 				memset(extra, 0, sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1);
 				if(wrq->u.encoding.length > (sizeof(struct iw_encode_ext)+ MAX_KEY_LEN)){
@@ -3522,12 +3522,12 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		break;
 
 	case SIOCGIWENCODEEXT:
-		DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWENCODEEXT \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWENCODEEXT \n");
 		rc = iwctl_giwencodeext(dev, NULL, &(wrq->u.encoding), NULL);
 		break;
 
 	case SIOCSIWMLME:
-		DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWMLME \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWMLME \n");
 		rc = iwctl_siwmlme(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
 		break;
 
@@ -3586,7 +3586,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
 	default:
 		rc = -EOPNOTSUPP;
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Ioctl command not support..%x\n", cmd);
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Ioctl command not support..%x\n", cmd);
 
 
     }
@@ -3599,7 +3599,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
            spin_unlock_irq(&pDevice->lock);
        }
        else {
-           DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Commit the settings\n");
+           DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Commit the settings\n");
            spin_lock_irq(&pDevice->lock);
            pDevice->bLinkPass = FALSE;
            memset(pMgmt->abyCurrBSSID, 0, 6);

commit db6cb9036b2756c50efc43127c476786ea92eae2
Author: Jim Lieb <lieb@canonical.com>
Date:   Thu Jul 23 17:20:49 2009 -0700

    Staging: vt665x: 64bit compile fixes Part 1
    
    Fix compile problems with 64bit.  These issues could cause corrupted
    address crashes.  In the process, replaced some definitions to use more
    portable kernel types.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index cb5fce2702a3..fe9cc783dc78 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -332,9 +332,9 @@ static CHIP_INFO chip_info_table[]= {
     {0,NULL}
 };
 
-static struct pci_device_id device_id_table[] __devinitdata = {
-{ 0x1106, 0x3253, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long)&chip_info_table[0]},
-{ 0, }
+DEFINE_PCI_DEVICE_TABLE(device_id_table) = {
+	{ PCI_VDEVICE(VIA, 0x3253), (kernel_ulong_t)chip_info_table},
+	{ 0, }
 };
 
 /*---------------------  Static Functions  --------------------------*/
@@ -405,7 +405,7 @@ static char* get_chip_name(int chip_id) {
     return chip_info_table[i].name;
 }
 
-static void __devexit device_remove1(struct pci_dev *pcid)
+static void device_remove1(struct pci_dev *pcid)
 {
     PSDevice pDevice=pci_get_drvdata(pcid);
 
@@ -928,7 +928,7 @@ static BOOL device_release_WPADEV(PSDevice pDevice)
                  wpahdr->req_ie_len = 0;
                  skb_put(pDevice->skb, sizeof(viawget_wpa_header));
                  pDevice->skb->dev = pDevice->wpadev;
-                 pDevice->skb->mac_header = pDevice->skb->data;
+		 skb_reset_mac_header(pDevice->skb);
                  pDevice->skb->pkt_type = PACKET_HOST;
                  pDevice->skb->protocol = htons(ETH_P_802_2);
                  memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
@@ -1678,8 +1678,8 @@ static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
         return FALSE;
     ASSERT(pRDInfo->skb);
     pRDInfo->skb->dev = pDevice->dev;
-    pRDInfo->skb_dma = pci_map_single(pDevice->pcid, pRDInfo->skb->tail, pDevice->rx_buf_sz,
-                        PCI_DMA_FROMDEVICE);
+    pRDInfo->skb_dma = pci_map_single(pDevice->pcid, skb_tail_pointer(pRDInfo->skb),
+				      pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
     *((PU32) &(pRD->m_rd0RD0)) = 0;
 
     pRD->m_rd0RD0.wResCount = cpu_to_le16(pDevice->rx_buf_sz);
@@ -1775,7 +1775,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
                     DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx call back netif.. \n");
                     skb = pTD->pTDInfo->skb;
 	                skb->dev = pDevice->apdev;
-			        skb->mac_header = skb->data;
+			skb_reset_mac_header(skb);
 	                skb->pkt_type = PACKET_OTHERHOST;
     	            //skb->protocol = htons(ETH_P_802_2);
 	                memset(skb->cb, 0, sizeof(skb->cb));
@@ -1940,6 +1940,10 @@ INT MlmeThread(
 static int  device_open(struct net_device *dev) {
     PSDevice    pDevice=(PSDevice) netdev_priv(dev);
     int i;
+#ifdef WPA_SM_Transtatus
+    extern SWPAResult wpa_Result;
+#endif
+
     pDevice->rx_buf_sz = PKT_BUF_SZ;
     if (!device_init_rings(pDevice)) {
         return -ENOMEM;
@@ -1950,7 +1954,6 @@ static int  device_open(struct net_device *dev) {
         return i;
 	//printk("DEBUG1\n");
 #ifdef WPA_SM_Transtatus
-     extern SWPAResult wpa_Result;
      memset(wpa_Result.ifname,0,sizeof(wpa_Result.ifname));
      wpa_Result.proto = 0;
      wpa_Result.key_mgmt = 0;

commit 83a27326ee616d6b6dcdd074ad088554a52f9b11
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 10 21:48:16 2009 +0200

    Staging: vt6655: remove PRIVATE_OBJ ifdefs
    
    Cc: Forest Bond <forest@alittletooquiet.net>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 88002862d69d..cb5fce2702a3 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -132,16 +132,8 @@
 
 #include <linux/delay.h>
 #include <linux/kthread.h>
-// #ifdef PRIVATE_OBJ
-//#if !defined(__DEVICE_EXP_H)
-//#include "device_exp.h"
-//#endif
-//#if !defined(__DEVICE_MODULE_H)
-//#include "device_module.h"
-//#endif
 
 
-// #endif
 //#define	DEBUG
 /*---------------------  Static Definitions -------------------------*/
 //static int          msglevel                =MSG_LEVEL_DEBUG;
@@ -151,11 +143,9 @@ static int          msglevel                =   MSG_LEVEL_INFO;
 //
 // Define module options
 //
-#ifndef PRIVATE_OBJ
 MODULE_AUTHOR("VIA Networking Technologies, Inc., <lyndonchen@vntek.com.tw>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("VIA Networking Solomon-A/B/G Wireless LAN Adapter Driver");
-#endif
 
 //PLICE_DEBUG ->
 	static int mlme_kill;
@@ -332,7 +322,6 @@ DEVICE_PARAM(bDiversityANTEnable, "ANT diversity mode");
 //
 
 
-#ifndef PRIVATE_OBJ
 static int          device_nics             =0;
 static PSDevice     pDevice_Infos           =NULL;
 static struct net_device *root_device_dev = NULL;
@@ -347,11 +336,9 @@ static struct pci_device_id device_id_table[] __devinitdata = {
 { 0x1106, 0x3253, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long)&chip_info_table[0]},
 { 0, }
 };
-#endif
 
 /*---------------------  Static Functions  --------------------------*/
 
-#ifndef PRIVATE_OBJ
 
 static int  device_found1(struct pci_dev *pcid, const struct pci_device_id *ent);
 static BOOL device_init_info(struct pci_dev* pcid, PSDevice* ppDevice, PCHIP_INFO);
@@ -378,7 +365,6 @@ struct notifier_block device_notifier = {
 };
 #endif
 
-#endif // #ifndef PRIVATE_OBJ
 
 static void device_init_rd0_ring(PSDevice pDevice);
 static void device_init_rd1_ring(PSDevice pDevice);
@@ -386,9 +372,7 @@ static void device_init_defrag_cb(PSDevice pDevice);
 static void device_init_td0_ring(PSDevice pDevice);
 static void device_init_td1_ring(PSDevice pDevice);
 
-#ifndef PRIVATE_OBJ
 static int  device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev);
-#endif
 //2008-0714<Add>by Mike Liu
 static BOOL device_release_WPADEV(PSDevice pDevice);
 
@@ -412,7 +396,6 @@ static int Config_FileGetParameter(UCHAR *string, UCHAR *dest,UCHAR *source);
 /*---------------------  Export Functions  --------------------------*/
 
 
-#ifndef PRIVATE_OBJ
 
 static char* get_chip_name(int chip_id) {
     int i;
@@ -432,7 +415,6 @@ static void __devexit device_remove1(struct pci_dev *pcid)
 
 }
 
-#endif
 /*
 static void
 device_set_int_opt(int *opt, int val, int min, int max, int def,char* name,char* devname) {
@@ -978,7 +960,6 @@ static const struct net_device_ops device_netdev_ops = {
 };
 
 
-#ifndef PRIVATE_OBJ
 
 static int
 device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
@@ -1329,7 +1310,6 @@ device_release_WPADEV(pDevice);
         pci_set_drvdata(pDevice->pcid,NULL);
     }
 }
-#endif// ifndef PRIVATE_OBJ
 
 static BOOL device_init_rings(PSDevice pDevice) {
     void*   vir_pool;
@@ -1676,11 +1656,7 @@ static int device_rx_srv(PSDevice pDevice, UINT uIdx) {
             }
         }
         pRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;
-#ifdef PRIVATE_OBJ
-        ref_set_rx_jiffies(pDevice->dev);
-#else
         pDevice->dev->last_rx = jiffies;
-#endif
     }
 
     pDevice->pCurrRD[uIdx]=pRD;
@@ -1693,15 +1669,6 @@ static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
 
     PDEVICE_RD_INFO pRDInfo=pRD->pRDInfo;
 
-#ifdef PRIVATE_OBJ
-
-    pRDInfo->skb=dev_alloc_skb(pDevice->rx_buf_sz);
-    if (pRDInfo->skb==NULL)
-        return FALSE;
-    ref_skb_remap(pDevice->dev, &(pRDInfo->ref_skb), pRDInfo->skb);
-    pRDInfo->skb_dma = pci_map_single(pDevice->pcid, pRDInfo->ref_skb.tail, pDevice->rx_buf_sz,
-                        PCI_DMA_FROMDEVICE);
-#else
 
     pRDInfo->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
 #ifdef	PLICE_DEBUG
@@ -1713,7 +1680,6 @@ static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
     pRDInfo->skb->dev = pDevice->dev;
     pRDInfo->skb_dma = pci_map_single(pDevice->pcid, pRDInfo->skb->tail, pDevice->rx_buf_sz,
                         PCI_DMA_FROMDEVICE);
-#endif
     *((PU32) &(pRD->m_rd0RD0)) = 0;
 
     pRD->m_rd0RD0.wResCount = cpu_to_le16(pDevice->rx_buf_sz);
@@ -1728,20 +1694,11 @@ static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
 
 BOOL device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
 
-#ifdef PRIVATE_OBJ
-
-    pDeF->skb=dev_alloc_skb(pDevice->rx_buf_sz);
-    if (pDeF->skb==NULL)
-        return FALSE;
-    ref_skb_remap(pDevice->dev, &(pDeF->ref_skb), pDeF->skb);
-
-#else
     pDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
     if (pDeF->skb == NULL)
         return FALSE;
     ASSERT(pDeF->skb);
     pDeF->skb->dev = pDevice->dev;
-#endif
 
     return TRUE;
 }
@@ -1760,9 +1717,6 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
     struct sk_buff*          skb;
     UINT                     uNodeIndex;
     PSMgmtObject             pMgmt = pDevice->pMgmt;
-#ifdef PRIVATE_OBJ
-    ref_sk_buff              ref_skb;
-#endif
 
 
     for (pTD = pDevice->apTailTD[uIdx]; pDevice->iTDUsed[uIdx] >0; pTD = pTD->next) {
@@ -1782,9 +1736,6 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
                 uFIFOHeaderSize = pTD->pTDInfo->dwHeaderLength;
                 uFrameSize = pTD->pTDInfo->dwReqCount - uFIFOHeaderSize;
                 pTxBufHead = (PSTxBufHead) (pTD->pTDInfo->buf);
-#ifdef PRIVATE_OBJ
-                ref_skb_remap(pDevice->dev, &ref_skb, pTD->pTDInfo->skb);
-#endif
                 // Update the statistics based on the Transmit status
                 // now, we DO'NT check TSR0_CDH
 
@@ -1809,11 +1760,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
                         pDevice->s802_11Counter.TransmittedFragmentCount ++;
                     }
                     pStats->tx_packets++;
-#ifdef PRIVATE_OBJ
-                    pStats->tx_bytes += *(ref_skb.len);
-#else
                     pStats->tx_bytes += pTD->pTDInfo->skb->len;
-#endif
                 }
                 else {
                      DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] dropped & tsr1[%02X] tsr0[%02X].\n",
@@ -1826,14 +1773,6 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
             if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
                 if (pDevice->bEnableHostapd) {
                     DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx call back netif.. \n");
-#ifdef PRIVATE_OBJ
-                    ref_skb_remap(pDevice->apdev, &(ref_skb), pTD->pTDInfo->skb);
-	                ref_skb.mac.raw = ref_skb.data;
-	                *(ref_skb.pkt_type) = PACKET_OTHERHOST;
-    	            //*(ref_skb.protocol) = htons(ETH_P_802_2);
-	                memset(ref_skb.cb, 0, sizeof(ref_skb.cb));
-	                netif_rx(ref_skb.skb);
-#else
                     skb = pTD->pTDInfo->skb;
 	                skb->dev = pDevice->apdev;
 			        skb->mac_header = skb->data;
@@ -1841,7 +1780,6 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
     	            //skb->protocol = htons(ETH_P_802_2);
 	                memset(skb->cb, 0, sizeof(skb->cb));
 	                netif_rx(skb);
-#endif
 	            }
             }
 
@@ -1998,28 +1936,18 @@ INT MlmeThread(
 }
 
 
-#ifdef PRIVATE_OBJ
-
-int __device_open(HANDLE pExDevice) {
-    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
-    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
-
-#else
 
 static int  device_open(struct net_device *dev) {
     PSDevice    pDevice=(PSDevice) netdev_priv(dev);
     int i;
-#endif
     pDevice->rx_buf_sz = PKT_BUF_SZ;
     if (!device_init_rings(pDevice)) {
         return -ENOMEM;
     }
 //2008-5-13 <add> by chester
-#ifndef PRIVATE_OBJ
     i=request_irq(pDevice->pcid->irq, &device_intr, IRQF_SHARED, dev->name, dev);
     if (i)
         return i;
-#endif
 	//printk("DEBUG1\n");
 #ifdef WPA_SM_Transtatus
      extern SWPAResult wpa_Result;
@@ -2085,11 +2013,7 @@ DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
 	device_init_registers(pDevice, DEVICE_INIT_COLD);
     MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
     memcpy(pDevice->pMgmt->abyMACAddr, pDevice->abyCurrentNetAddr, U_ETHER_ADDR_LEN);
-#ifdef PRIVATE_OBJ
-    __device_set_multi(pExDevice);
-#else
     device_set_multi(pDevice->dev);
-#endif
 
     // Init for Key Management
     KeyvInitTable(&pDevice->sKey, pDevice->PortOffset);
@@ -2141,17 +2065,8 @@ DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call MACvIntEnable\n");
 }
 
 
-#ifdef PRIVATE_OBJ
-
-int  __device_close(HANDLE pExDevice) {
-    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
-    struct net_device *dev = pDevice_info->dev;
-    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
-
-#else
 static int  device_close(struct net_device *dev) {
     PSDevice  pDevice=(PSDevice) netdev_priv(dev);
-#endif
     PSMgmtObject     pMgmt = pDevice->pMgmt;
  //PLICE_DEBUG->
 #ifdef	THREAD
@@ -2204,19 +2119,10 @@ device_release_WPADEV(pDevice);
     return 0;
 }
 
-#ifdef PRIVATE_OBJ
-
-int  __device_dma0_tx_80211(HANDLE pExDevice, struct sk_buff *skb) {
-    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
-    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
-    ref_sk_buff     ref_skb;
-
-#else
 
 
 static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
     PSDevice        pDevice=netdev_priv(dev);
-#endif
     PBYTE           pbMPDU;
     UINT            cbMPDULen = 0;
 
@@ -2237,14 +2143,8 @@ static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
         return 0;
     };
 
-#ifdef PRIVATE_OBJ
-    ref_skb_remap(pDevice->dev, &ref_skb, skb);
-    cbMPDULen = *(ref_skb.len);
-    pbMPDU = ref_skb.data;
-#else
     cbMPDULen = skb->len;
     pbMPDU = skb->data;
-#endif
 
     vDMA0_tx_80211(pDevice, skb, pbMPDU, cbMPDULen);
 
@@ -2268,9 +2168,6 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, UINT uNodeIndex) {
     UINT            ii;
     SKeyItem        STempKey;
 //    BYTE            byKeyIndex = 0;
-#ifdef PRIVATE_OBJ
-    ref_sk_buff     ref_skb;
-#endif
 
 
     if (pDevice->bStopTx0Pkt == TRUE) {
@@ -2292,21 +2189,12 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, UINT uNodeIndex) {
         }
     }
 
-#ifdef PRIVATE_OBJ
-    ref_skb_remap(pDevice->dev, &(ref_skb), skb);
-#endif
     pHeadTD = pDevice->apCurrTD[TYPE_TXDMA0];
 
     pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
 
-#ifdef PRIVATE_OBJ
-    memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(ref_skb.data), U_HEADER_LEN);
-    cbFrameBodySize = *(ref_skb.len) - U_HEADER_LEN;
-
-#else
     memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(skb->data), U_HEADER_LEN);
     cbFrameBodySize = skb->len - U_HEADER_LEN;
-#endif
 
     // 802.1H
     if (ntohs(pDevice->sTxEthHeader.wType) > MAX_DATA_LEN) {
@@ -2417,19 +2305,9 @@ BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, UINT uNodeIndex) {
 }
 
 //TYPE_AC0DMA data tx
-#ifdef PRIVATE_OBJ
-
-int  __device_xmit(HANDLE pExDevice, struct sk_buff *skb) {
-    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
-    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
-    struct net_device *dev = pDevice_info->dev;
-    ref_sk_buff     ref_skb;
-
-#else
 static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     PSDevice pDevice=netdev_priv(dev);
 
-#endif
     PSMgmtObject    pMgmt = pDevice->pMgmt;
     PSTxDesc        pHeadTD, pLastTD;
     UINT            uNodeIndex = 0;
@@ -2463,9 +2341,6 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
         return 0;
     }
 
-#ifdef PRIVATE_OBJ
-    ref_skb_remap(pDevice->dev, &ref_skb, skb);
-#endif
 
     if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
         if (pDevice->uAssocCount == 0) {
@@ -2473,19 +2348,11 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
             spin_unlock_irq(&pDevice->lock);
             return 0;
         }
-#ifdef PRIVATE_OBJ
-        if (IS_MULTICAST_ADDRESS((PBYTE)(ref_skb.data))) {
-#else
         if (IS_MULTICAST_ADDRESS((PBYTE)(skb->data))) {
-#endif
             uNodeIndex = 0;
             bNodeExist = TRUE;
             if (pMgmt->sNodeDBTable[0].bPSEnable) {
-#ifdef PRIVATE_OBJ
-                skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), ref_skb.skb);
-#else
                 skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skb);
-#endif
                 pMgmt->sNodeDBTable[0].wEnQueueCnt++;
                 // set tx map
                 pMgmt->abyPSTxMap[0] |= byMask[0];
@@ -2493,17 +2360,9 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
                 return 0;
             }
 }else {
-#ifdef PRIVATE_OBJ
-            if (BSSDBbIsSTAInNodeDB(pMgmt, (PBYTE)(ref_skb.data), &uNodeIndex)) {
-#else
             if (BSSDBbIsSTAInNodeDB(pMgmt, (PBYTE)(skb->data), &uNodeIndex)) {
-#endif
                 if (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {
-#ifdef PRIVATE_OBJ
-                    skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, ref_skb.skb);
-#else
                     skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);
-#endif
                     pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;
                     // set tx map
                     wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
@@ -2538,13 +2397,8 @@ static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
     pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
 
 
-#ifdef PRIVATE_OBJ
-    memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(ref_skb.data), U_HEADER_LEN);
-    cbFrameBodySize = *(ref_skb.len) - U_HEADER_LEN;
-#else
     memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(skb->data), U_HEADER_LEN);
     cbFrameBodySize = skb->len - U_HEADER_LEN;
-#endif
     // 802.1H
     if (ntohs(pDevice->sTxEthHeader.wType) > MAX_DATA_LEN) {
         cbFrameBodySize += 8;
@@ -2763,14 +2617,6 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
     }
 
 
-#ifdef PRIVATE_OBJ
-    vGenerateFIFOHeader(pDevice, byPktTyp, pDevice->pbyTmpBuff, bNeedEncryption,
-                        cbFrameBodySize, TYPE_AC0DMA, pHeadTD,
-                        &pDevice->sTxEthHeader, (PBYTE)ref_skb.data, pTransmitKey, uNodeIndex,
-                        &uMACfragNum,
-                        &cbHeaderSize
-                        );
-#else
 #ifdef	PLICE_DEBUG
 	//if (skb->len == 98)
 	//{
@@ -2783,7 +2629,6 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
                         &uMACfragNum,
                         &cbHeaderSize
                         );
-#endif
 
     if (MACbIsRegBitsOn(pDevice->PortOffset, MAC_REG_PSCTL, PSCTL_PS)) {
         // Disable PS
@@ -2804,11 +2649,7 @@ pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
 
     // Save the information needed by the tx interrupt handler
     // to complete the Send request
-#ifdef PRIVATE_OBJ
-    pLastTD->pTDInfo->skb = ref_skb.skb;
-#else
     pLastTD->pTDInfo->skb = skb;
-#endif
     pLastTD->pTDInfo->byFlags = 0;
     pLastTD->pTDInfo->byFlags |= TD_FLAGS_NETIF_SKB;
 #ifdef TxInSleep
@@ -2862,29 +2703,16 @@ BOOL            bTxeapol_key = FALSE;
     MACvTransmitAC0(pDevice->PortOffset);
 //    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0:pDevice->apCurrTD= %p\n", pHeadTD);
 
-#ifdef PRIVATE_OBJ
-    ref_set_tx_jiffies(pDevice->dev);
-#else
     dev->trans_start = jiffies;
-#endif
 
     spin_unlock_irq(&pDevice->lock);
     return 0;
 
 }
 
-#ifdef PRIVATE_OBJ
-
-int __device_intr(int irq, HANDLE pExDevice, struct pt_regs *regs) {
-    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
-    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
-
-
-#else
 static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
     struct net_device* dev=dev_instance;
     PSDevice     pDevice=(PSDevice) netdev_priv(dev);
-#endif
 
     int             max_count=0;
     DWORD           dwMIBCounter=0;
@@ -3290,18 +3118,9 @@ else {
 }
 
 
-#ifdef PRIVATE_OBJ
-
-void __device_set_multi(HANDLE pExDevice) {
-    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
-    ref_net_device  *dev = &(pDevice_info->ref_dev);
-    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
-
-#else
 
 static void device_set_multi(struct net_device *dev) {
     PSDevice         pDevice = (PSDevice) netdev_priv(dev);
-#endif
 
     PSMgmtObject     pMgmt = pDevice->pMgmt;
     u32              mc_filter[2];
@@ -3311,24 +3130,13 @@ static void device_set_multi(struct net_device *dev) {
 
     VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
 
-#ifdef PRIVATE_OBJ
-    if (*(dev->flags) & IFF_PROMISC) {         /* Set promiscuous. */
-        DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: Promiscuous mode enabled.\n", pDevice->dev->name);
-
-#else
     if (dev->flags & IFF_PROMISC) {         /* Set promiscuous. */
         DEVICE_PRT(MSG_LEVEL_ERR,KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
-#endif
         /* Unconditionally log net taps. */
         pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);
     }
-#ifdef PRIVATE_OBJ
-    else if ((*(dev->mc_count) > pDevice->multicast_limit)
-        ||  (*(dev->flags) & IFF_ALLMULTI)) {
-#else
     else if ((dev->mc_count > pDevice->multicast_limit)
         ||  (dev->flags & IFF_ALLMULTI)) {
-#endif
         MACvSelectPage1(pDevice->PortOffset);
         VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, 0xffffffff);
         VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0 + 4, 0xffffffff);
@@ -3337,13 +3145,8 @@ static void device_set_multi(struct net_device *dev) {
     }
     else {
         memset(mc_filter, 0, sizeof(mc_filter));
-#ifdef PRIVATE_OBJ
-        for (i = 0, mclist = dev->mc_list; mclist && i < *(dev->mc_count);
-             i++, mclist = mclist->next) {
-#else
         for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
              i++, mclist = mclist->next) {
-#endif
             int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
             mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
         }
@@ -3366,33 +3169,16 @@ static void device_set_multi(struct net_device *dev) {
 }
 
 
-#ifdef PRIVATE_OBJ
-
-struct net_device_stats *__device_get_stats(HANDLE pExDevice) {
-    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
-    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
-
-#else
 static struct net_device_stats *device_get_stats(struct net_device *dev) {
     PSDevice pDevice=(PSDevice) netdev_priv(dev);
-#endif
 
     return &pDevice->stats;
 }
 
 
-#ifdef PRIVATE_OBJ
-
-int __device_ioctl(HANDLE pExDevice, struct ifreq *rq, int cmd) {
-    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
-    struct net_device *dev = pDevice_info->dev;
-    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
-
-#else
 
 static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	PSDevice	        pDevice = (PSDevice)netdev_priv(dev);
-#endif
 
 	struct iwreq *wrq = (struct iwreq *) rq;
 	int                 rc =0;
@@ -3854,7 +3640,6 @@ static int ethtool_ioctl(struct net_device *dev, void *useraddr)
 }
 
 /*------------------------------------------------------------------*/
-#ifndef PRIVATE_OBJ
 
 MODULE_DEVICE_TABLE(pci, device_id_table);
 
@@ -3987,59 +3772,6 @@ viawget_resume(struct pci_dev *pcid)
 
 #endif
 
-#endif //#ifndef PRIVATE_OBJ
-
-#ifdef PRIVATE_OBJ
-
-
-int __device_hw_reset(HANDLE pExDevice){
-     PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
-
-     return MACbSoftwareReset(pDevice_info->port_offset);
-}
-
-
-int __device_hw_init(HANDLE pExDevice){
-    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
-    PSDevice    pDevice;
-
-    pDevice = (PSDevice)kmalloc(sizeof(DEVICE_INFO), (int)GFP_ATOMIC);
-    if (pDevice == NULL)
-        return FALSE;
-
-    memset(pDevice, 0, sizeof(DEVICE_INFO));
-    pDevice_info->pWDevice = pDevice;
-    pDevice->PortOffset = pDevice_info->port_offset;
-    pDevice->dev = pDevice_info->dev;
-    pDevice->pcid = pDevice_info->pcid;
-    pDevice->chip_id = pDevice_info->chip_id;
-    pDevice->memaddr = pDevice_info->mem_addr;
-    pDevice->ioaddr = pDevice_info->io_addr;
-    pDevice->io_size = pDevice_info->io_size;
-    pDevice->nTxQueues = pDevice_info->nTxQueues;
-    pDevice->multicast_limit = pDevice_info->multicast_limit;
-    pDevice->sMgmtObj.pAdapter = (PVOID)pDevice;
-    pDevice->pMgmt = &(pDevice->sMgmtObj);
-    MACvInitialize(pDevice->PortOffset);
-    device_get_options(pDevice, 0 , pDevice_info->dev->name);
-    device_set_options(pDevice);
-    pDevice->sOpts.flags &= pDevice_info->flags;
-    pDevice->flags = pDevice->sOpts.flags | (pDevice_info->flags & 0xFF000000UL);
-    spin_lock_init(&(pDevice->lock));
-
-    return TRUE;
-}
 
 
-void __device_read_mac(HANDLE pExDevice, PBYTE dev_addr){
-    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
-    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
-
-    MACvReadEtherAddress(pDevice->PortOffset, dev_addr);
-    return;
-}
-
-
-#endif
-
 

commit e882335bb19c0b9f96971fa6b1fe6c019280056b
Author: Alexander Beregalov <a.beregalov@gmail.com>
Date:   Sat Jul 4 23:09:32 2009 +0400

    Staging: vt665x: depend on WIRELESS_EXT
    
    Make vt665x depended on WIRELESS_EXT and remove remain ifdef's
    
    Signed-off-by: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 88460263e075..88002862d69d 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1146,9 +1146,7 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
     dev->irq                = pcid->irq;
     dev->netdev_ops         = &device_netdev_ops;
 
-#ifdef CONFIG_WIRELESS_EXT
 	dev->wireless_handlers = (struct iw_handler_def *)&iwctl_handler_def;
-#endif
 
     rc = register_netdev(dev);
     if (rc)
@@ -3396,10 +3394,8 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 	PSDevice	        pDevice = (PSDevice)netdev_priv(dev);
 #endif
 
-#ifdef WIRELESS_EXT
 	struct iwreq *wrq = (struct iwreq *) rq;
 	int                 rc =0;
-#endif
     PSMgmtObject        pMgmt = pDevice->pMgmt;
     PSCmdRequest        pReq;
 
@@ -3411,8 +3407,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 
     switch(cmd) {
 
-#ifdef WIRELESS_EXT
-
 	case SIOCGIWNAME:
 		rc = iwctl_giwname(dev, NULL, (char *)&(wrq->u.name), NULL);
 		break;
@@ -3751,8 +3745,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 #endif // #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 //End Add -- //2008-0409-07, <Add> by Einsn Liu
 
-#endif // WIRELESS_EXT
-
     case IOCTL_CMD_TEST:
 
 		if (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {

commit 4c47b34cd6c62cb4cf9fb8f873aeb99b6cc60b4d
Author: Alexander Beregalov <a.beregalov@gmail.com>
Date:   Sat Jun 20 20:07:50 2009 +0400

    Staging: vt6655: remove dependency on WIRELESS_EXT version
    
    As the driver is in mainline now we can remove such dependencies.
    WIRELESS_EXT is 22 now.
    
    Cc: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 0a11d7fd8aa2..88460263e075 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3412,7 +3412,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
     switch(cmd) {
 
 #ifdef WIRELESS_EXT
-//#if WIRELESS_EXT < 13
 
 	case SIOCGIWNAME:
 		rc = iwctl_giwname(dev, NULL, (char *)&(wrq->u.name), NULL);
@@ -3588,7 +3587,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		}
 		break;
 
-#if WIRELESS_EXT > 9
 		// Get the current Tx-Power
 	case SIOCGIWTXPOW:
         DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
@@ -3600,9 +3598,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
         rc = -EOPNOTSUPP;
 		break;
 
-#endif // WIRELESS_EXT > 9
-
-#if WIRELESS_EXT > 10
 	case SIOCSIWRETRY:
 
 		rc = iwctl_siwretry(dev, NULL, &(wrq->u.retry), NULL);
@@ -3613,8 +3608,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		rc = iwctl_giwretry(dev, NULL, &(wrq->u.retry), NULL);
 		break;
 
-#endif // WIRELESS_EXT > 10
-
 		// Get range of parameters
 	case SIOCGIWRANGE:
 
@@ -3701,7 +3694,6 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
 		break;
 
 
-//#endif // WIRELESS_EXT < 13
 //2008-0409-07, <Add> by Einsn Liu
 #ifdef  WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 	case SIOCSIWAUTH:
@@ -3799,20 +3791,12 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
     case IOCTL_CMD_HOSTAPD:
 
 
-#if WIRELESS_EXT > 8
-		rc = hostap_ioctl(pDevice, &wrq->u.data);
-#else // WIRELESS_EXT > 8
-		rc = hostap_ioctl(pDevice, (struct iw_point *) &wrq->u.data);
-#endif // WIRELESS_EXT > 8
+	rc = hostap_ioctl(pDevice, &wrq->u.data);
         break;
 
     case IOCTL_CMD_WPA:
 
-#if WIRELESS_EXT > 8
-		rc = wpa_ioctl(pDevice, &wrq->u.data);
-#else // WIRELESS_EXT > 8
-		rc = wpa_ioctl(pDevice, (struct iw_point *) &wrq->u.data);
-#endif // WIRELESS_EXT > 8
+	rc = wpa_ioctl(pDevice, &wrq->u.data);
         break;
 
 	case SIOCETHTOOL:

commit 761e95493982f3365e6ef34991a6c7ff84e33d25
Author: Alexander Beregalov <a.beregalov@gmail.com>
Date:   Sat Jun 20 19:07:40 2009 +0400

    Staging: vt6655: fix build when !CONFIG_WIRELESS_EXT
    
    Fix this build error when CONFIG_WIRELESS_EXT is not set:
    drivers/staging/vt6655/device_main.c:1153: error: 'struct net_device'
            has no member named 'wireless_handlers'
    
    Cc: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f43ca416e4a8..0a11d7fd8aa2 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1146,14 +1146,9 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
     dev->irq                = pcid->irq;
     dev->netdev_ops         = &device_netdev_ops;
 
-#ifdef WIRELESS_EXT
-//Einsn Modify for ubuntu-7.04
-//	dev->wireless_handlers->get_wireless_stats = iwctl_get_wireless_stats;
-#if WIRELESS_EXT > 12
+#ifdef CONFIG_WIRELESS_EXT
 	dev->wireless_handlers = (struct iw_handler_def *)&iwctl_handler_def;
-//	netdev->wireless_handlers = NULL;
-#endif /* WIRELESS_EXT > 12 */
-#endif /* WIRELESS_EXT */
+#endif
 
     rc = register_netdev(dev);
     if (rc)

commit f408adeb517e1b17102acd889251d5ab60c1fb88
Author: Alan Cox <alan@linux.intel.com>
Date:   Wed Jun 10 17:30:49 2009 +0100

    Staging: vt6655: compile fix
    
    At least make it compile
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index a10ed27acbc2..f43ca416e4a8 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -344,7 +344,7 @@ static CHIP_INFO chip_info_table[]= {
 };
 
 static struct pci_device_id device_id_table[] __devinitdata = {
-{ 0x1106, 0x3253, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (int)&chip_info_table[0]},
+{ 0x1106, 0x3253, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (long)&chip_info_table[0]},
 { 0, }
 };
 #endif
@@ -369,7 +369,7 @@ static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 
 #ifdef CONFIG_PM
 static int device_notify_reboot(struct notifier_block *, unsigned long event, void *ptr);
-static int viawget_suspend(struct pci_dev *pcid, u32 state);
+static int viawget_suspend(struct pci_dev *pcid, pm_message_t state);
 static int viawget_resume(struct pci_dev *pcid);
 struct notifier_block device_notifier = {
         notifier_call:  device_notify_reboot,
@@ -3941,7 +3941,7 @@ device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
         while ((pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) != NULL) {
             if(pci_dev_driver(pdev) == &device_driver) {
                 if (pci_get_drvdata(pdev))
-                    viawget_suspend(pdev, 3);
+                    viawget_suspend(pdev, PMSG_HIBERNATE);
             }
         }
     }
@@ -3949,7 +3949,7 @@ device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
 }
 
 static int
-viawget_suspend(struct pci_dev *pcid, u32 state)
+viawget_suspend(struct pci_dev *pcid, pm_message_t state)
 {
     int power_status;   // to silence the compiler
 
@@ -3971,7 +3971,7 @@ viawget_suspend(struct pci_dev *pcid, u32 state)
     memset(pMgmt->abyCurrBSSID, 0, 6);
     pMgmt->eCurrState = WMAC_STATE_IDLE;
     pci_disable_device(pcid);
-    power_status = pci_set_power_state(pcid, state);
+    power_status = pci_set_power_state(pcid, pci_choose_state(pcid, state));
     spin_unlock_irq(&pDevice->lock);
     return 0;
 }

commit 572113540886faf393fd04408c394899df98ada3
Author: Forest Bond <forest@alittletooquiet.net>
Date:   Tue Jun 2 14:44:33 2009 -0400

    Staging: vt6655: use net_device_ops for management functions
    
    vt6655: use net_device_ops for management functions
    
    Signed-off-by: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index f0e2c7351552..a10ed27acbc2 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -968,6 +968,16 @@ static BOOL device_release_WPADEV(PSDevice pDevice)
 }
 
 
+static const struct net_device_ops device_netdev_ops = {
+    .ndo_open               = device_open,
+    .ndo_stop               = device_close,
+    .ndo_do_ioctl           = device_ioctl,
+    .ndo_get_stats          = device_get_stats,
+    .ndo_start_xmit         = device_xmit,
+    .ndo_set_multicast_list = device_set_multi,
+};
+
+
 #ifndef PRIVATE_OBJ
 
 static int
@@ -1134,12 +1144,7 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
     pDevice->pMgmt = &(pDevice->sMgmtObj);
 
     dev->irq                = pcid->irq;
-    dev->open               = device_open;
-    dev->hard_start_xmit    = device_xmit;
-    dev->stop               = device_close;
-    dev->get_stats          = device_get_stats;
-    dev->set_multicast_list = device_set_multi;
-    dev->do_ioctl           = device_ioctl;
+    dev->netdev_ops         = &device_netdev_ops;
 
 #ifdef WIRELESS_EXT
 //Einsn Modify for ubuntu-7.04

commit 7bb8dc2d7eb5594ec890e822bb0517446d369698
Author: Forest Bond <forest@alittletooquiet.net>
Date:   Mon Jun 1 20:00:35 2009 -0400

    Staging: vt6655: Remove LINUX_VERSION_CODE preprocessor conditionals.
    
    vt6655: Remove LINUX_VERSION_CODE preprocessor conditionals.
    
    Signed-off-by: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index 93c626b8a0bd..f0e2c7351552 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -367,7 +367,6 @@ static void device_set_multi(struct net_device *dev);
 static int  device_close(struct net_device *dev);
 static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
 #ifdef CONFIG_PM
 static int device_notify_reboot(struct notifier_block *, unsigned long event, void *ptr);
 static int viawget_suspend(struct pci_dev *pcid, u32 state);
@@ -378,7 +377,6 @@ struct notifier_block device_notifier = {
         priority:       0
 };
 #endif
-#endif
 
 #endif // #ifndef PRIVATE_OBJ
 
@@ -948,12 +946,7 @@ static BOOL device_release_WPADEV(PSDevice pDevice)
                  wpahdr->req_ie_len = 0;
                  skb_put(pDevice->skb, sizeof(viawget_wpa_header));
                  pDevice->skb->dev = pDevice->wpadev;
-//2008-4-3 modify by Chester for wpa
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
                  pDevice->skb->mac_header = pDevice->skb->data;
-#else
-                 pDevice->skb->mac.raw = pDevice->skb->data;
-#endif
                  pDevice->skb->pkt_type = PACKET_HOST;
                  pDevice->skb->protocol = htons(ETH_P_802_2);
                  memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
@@ -984,23 +977,14 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
     struct net_device*  dev = NULL;
     PCHIP_INFO  pChip_info = (PCHIP_INFO)ent->driver_data;
     PSDevice    pDevice;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
     int         rc;
-#endif
-//#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
- //  BYTE            fake_mac[U_ETHER_ADDR_LEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x01};//fake MAC address
-//#endif
     if (device_nics ++>= MAX_UINTS) {
         printk(KERN_NOTICE DEVICE_NAME ": already found %d NICs\n", device_nics);
         return -ENODEV;
     }
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
     dev = alloc_etherdev(sizeof(DEVICE_INFO));
-#else
-    dev = init_etherdev(dev, 0);
-#endif
 
     pDevice = (PSDevice) netdev_priv(dev);
 
@@ -1009,11 +993,9 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
         return -ENODEV;
     }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
     // Chain it all together
    // SET_MODULE_OWNER(dev);
     SET_NETDEV_DEV(dev, &pcid->dev);
-#endif
 
     if (bFirst) {
         printk(KERN_NOTICE "%s Ver. %s\n",DEVICE_FULL_DRV_NAM, DEVICE_VERSION);
@@ -1106,21 +1088,12 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
     rc = pci_request_regions(pcid, DEVICE_NAME);
     if (rc) {
         printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device\n");
         device_free_info(pDevice);
         return -ENODEV;
     }
-#else
-    if (check_region(pDevice->ioaddr, pDevice->io_size)) {
-        printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device\n");
-        device_free_info(pDevice);
-        return -ENODEV;
-    }
-    request_region(pDevice->ioaddr, pDevice->io_size, DEVICE_NAME);
-#endif
 
     dev->base_addr = pDevice->ioaddr;
 #ifdef	PLICE_DEBUG
@@ -1177,10 +1150,6 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
 #endif /* WIRELESS_EXT > 12 */
 #endif /* WIRELESS_EXT */
 
- //  #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
-  //  memcpy(pDevice->dev->dev_addr, fake_mac, U_ETHER_ADDR_LEN); //use fake mac address
- //  #endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
     rc = register_netdev(dev);
     if (rc)
     {
@@ -1188,7 +1157,6 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
         device_free_info(pDevice);
         return -ENODEV;
     }
-#endif
 //2008-07-21-01<Add>by MikeLiu
 //register wpadev
    if(wpa_set_wpadev(pDevice, 1)!=0) {
@@ -1354,17 +1322,10 @@ device_release_WPADEV(pDevice);
     if (pDevice->PortOffset)
         iounmap((PVOID)pDevice->PortOffset);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
     if (pDevice->pcid)
         pci_release_regions(pDevice->pcid);
     if (dev)
         free_netdev(dev);
-#else
-    if (pDevice->ioaddr)
-        release_region(pDevice->ioaddr,pDevice->io_size);
-    if (dev)
-        kfree(dev);
-#endif
 
     if (pDevice->pcid) {
         pci_set_drvdata(pDevice->pcid,NULL);
@@ -1877,11 +1838,7 @@ static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
 #else
                     skb = pTD->pTDInfo->skb;
 	                skb->dev = pDevice->apdev;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
-			skb->mac_header = skb->data;
-#else
-			skb->mac.raw = skb->data;
-#endif
+			        skb->mac_header = skb->data;
 	                skb->pkt_type = PACKET_OTHERHOST;
     	            //skb->protocol = htons(ETH_P_802_2);
 	                memset(skb->cb, 0, sizeof(skb->cb));
@@ -2061,11 +2018,7 @@ static int  device_open(struct net_device *dev) {
     }
 //2008-5-13 <add> by chester
 #ifndef PRIVATE_OBJ
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
     i=request_irq(pDevice->pcid->irq, &device_intr, IRQF_SHARED, dev->name, dev);
-#else
-    i=request_irq(pDevice->pcid->irq, &device_intr, (unsigned long)SA_SHIRQ, dev->name, dev);
-#endif
     if (i)
         return i;
 #endif
@@ -2185,12 +2138,6 @@ DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call MACvIntEnable\n");
     }
     pDevice->flags |=DEVICE_FLAGS_OPENED;
 
-#ifndef PRIVATE_OBJ
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-    MOD_INC_USE_COUNT;
-#endif
-#endif
-
     DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success.. \n");
     return 0;
 }
@@ -2255,11 +2202,6 @@ device_release_WPADEV(pDevice);
 //PLICE_DEBUG->
 	//tasklet_kill(&pDevice->RxMngWorkItem);
 //PLICE_DEBUG<-
-#ifndef PRIVATE_OBJ
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-    MOD_DEC_USE_COUNT;
-#endif
-#endif
     DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close.. \n");
     return 0;
 }
@@ -3945,12 +3887,10 @@ static struct pci_driver device_driver = {
         id_table:   device_id_table,
         probe:      device_found1,
         remove:     device_remove1,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
 #ifdef CONFIG_PM
         suspend:    viawget_suspend,
         resume:     viawget_resume,
 #endif
-#endif
 };
 
 static int __init device_init_module(void)
@@ -3960,16 +3900,10 @@ static int __init device_init_module(void)
 
 //    ret=pci_module_init(&device_driver);
 	//ret = pcie_port_service_register(&device_driver);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
 	ret = pci_register_driver(&device_driver);
-#else
-	ret = pci_module_init(&device_driver);
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
 #ifdef CONFIG_PM
     if(ret >= 0)
         register_reboot_notifier(&device_notifier);
-#endif
 #endif
 
     return ret;
@@ -3979,10 +3913,8 @@ static void __exit device_cleanup_module(void)
 {
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
 #ifdef CONFIG_PM
     unregister_reboot_notifier(&device_notifier);
-#endif
 #endif
     pci_unregister_driver(&device_driver);
 
@@ -3992,7 +3924,6 @@ module_init(device_init_module);
 module_exit(device_cleanup_module);
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
 #ifdef CONFIG_PM
 static int
 device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
@@ -4002,11 +3933,7 @@ device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
     case SYS_DOWN:
     case SYS_HALT:
     case SYS_POWER_OFF:
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
         while ((pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) != NULL) {
-#else
-        pci_for_each_dev(pdev) {
-#endif
             if(pci_dev_driver(pdev) == &device_driver) {
                 if (pci_get_drvdata(pdev))
                     viawget_suspend(pdev, 3);
@@ -4026,11 +3953,7 @@ viawget_suspend(struct pci_dev *pcid, u32 state)
 
     netif_stop_queue(pDevice->dev);
     spin_lock_irq(&pDevice->lock);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
     pci_save_state(pcid);
-#else
-    pci_save_state(pcid, pDevice->pci_state);
-#endif
     del_timer(&pDevice->sTimerCommand);
     del_timer(&pMgmt->sTimerSecondCallback);
     pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
@@ -4058,11 +3981,7 @@ viawget_resume(struct pci_dev *pcid)
 
     power_status = pci_set_power_state(pcid, 0);
     power_status = pci_enable_wake(pcid, 0, 0);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
     pci_restore_state(pcid);
-#else
-    pci_restore_state(pcid, pDevice->pci_state);
-#endif
     if (netif_running(pDevice->dev)) {
         spin_lock_irq(&pDevice->lock);
         MACvRestoreContext(pDevice->PortOffset, pDevice->abyMacContext);
@@ -4090,7 +4009,6 @@ viawget_resume(struct pci_dev *pcid)
     return 0;
 }
 
-#endif
 #endif
 
 #endif //#ifndef PRIVATE_OBJ

commit c9d0352914e8fdaece56c8c3ea489d7214b0353e
Author: Forest Bond <forest@alittletooquiet.net>
Date:   Mon Jun 1 20:00:14 2009 -0400

    Staging: vt6655: Replace net_device->priv accesses with netdev_priv calls.
    
    vt6655: Replace net_device->priv accesses with netdev_priv calls.
    
    Signed-off-by: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index d8f7f4f7bac4..93c626b8a0bd 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -997,11 +997,13 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
 
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
-    dev = alloc_etherdev(0);
+    dev = alloc_etherdev(sizeof(DEVICE_INFO));
 #else
     dev = init_etherdev(dev, 0);
 #endif
 
+    pDevice = (PSDevice) netdev_priv(dev);
+
     if (dev == NULL) {
         printk(KERN_ERR DEVICE_NAME ": allocate net device failed \n");
         return -ENODEV;
@@ -1025,7 +1027,6 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
     pDevice->dev = dev;
     pDevice->next_module = root_device_dev;
     root_device_dev = dev;
-    dev->priv = pDevice;
     dev->irq = pcid->irq;
 
     if (pci_enable_device(pcid)) {
@@ -1194,7 +1195,6 @@ device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
      printk("Fail to Register WPADEV?\n");
         unregister_netdev(pDevice->dev);
         free_netdev(dev);
-        kfree(pDevice);
    }
     device_print_info(pDevice);
     pci_set_drvdata(pcid, pDevice);
@@ -1226,11 +1226,6 @@ static BOOL device_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
 
     PSDevice p;
 
-    *ppDevice = kmalloc(sizeof(DEVICE_INFO),GFP_ATOMIC);
-
-    if (*ppDevice == NULL)
-        return FALSE;
-
     memset(*ppDevice,0,sizeof(DEVICE_INFO));
 
     if (pDevice_Infos == NULL) {
@@ -1374,8 +1369,6 @@ device_release_WPADEV(pDevice);
     if (pDevice->pcid) {
         pci_set_drvdata(pDevice->pcid,NULL);
     }
-    kfree(pDevice);
-
 }
 #endif// ifndef PRIVATE_OBJ
 
@@ -2059,7 +2052,7 @@ int __device_open(HANDLE pExDevice) {
 #else
 
 static int  device_open(struct net_device *dev) {
-    PSDevice    pDevice=(PSDevice) dev->priv;
+    PSDevice    pDevice=(PSDevice) netdev_priv(dev);
     int i;
 #endif
     pDevice->rx_buf_sz = PKT_BUF_SZ;
@@ -2212,7 +2205,7 @@ int  __device_close(HANDLE pExDevice) {
 
 #else
 static int  device_close(struct net_device *dev) {
-    PSDevice  pDevice=(PSDevice) dev->priv;
+    PSDevice  pDevice=(PSDevice) netdev_priv(dev);
 #endif
     PSMgmtObject     pMgmt = pDevice->pMgmt;
  //PLICE_DEBUG->
@@ -2282,7 +2275,7 @@ int  __device_dma0_tx_80211(HANDLE pExDevice, struct sk_buff *skb) {
 
 
 static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
-    PSDevice        pDevice=dev->priv;
+    PSDevice        pDevice=netdev_priv(dev);
 #endif
     PBYTE           pbMPDU;
     UINT            cbMPDULen = 0;
@@ -2494,7 +2487,7 @@ int  __device_xmit(HANDLE pExDevice, struct sk_buff *skb) {
 
 #else
 static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
-    PSDevice pDevice=dev->priv;
+    PSDevice pDevice=netdev_priv(dev);
 
 #endif
     PSMgmtObject    pMgmt = pDevice->pMgmt;
@@ -2950,7 +2943,7 @@ int __device_intr(int irq, HANDLE pExDevice, struct pt_regs *regs) {
 #else
 static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
     struct net_device* dev=dev_instance;
-    PSDevice     pDevice=(PSDevice) dev->priv;
+    PSDevice     pDevice=(PSDevice) netdev_priv(dev);
 #endif
 
     int             max_count=0;
@@ -3367,7 +3360,7 @@ void __device_set_multi(HANDLE pExDevice) {
 #else
 
 static void device_set_multi(struct net_device *dev) {
-    PSDevice         pDevice = (PSDevice) dev->priv;
+    PSDevice         pDevice = (PSDevice) netdev_priv(dev);
 #endif
 
     PSMgmtObject     pMgmt = pDevice->pMgmt;
@@ -3441,7 +3434,7 @@ struct net_device_stats *__device_get_stats(HANDLE pExDevice) {
 
 #else
 static struct net_device_stats *device_get_stats(struct net_device *dev) {
-    PSDevice pDevice=(PSDevice) dev->priv;
+    PSDevice pDevice=(PSDevice) netdev_priv(dev);
 #endif
 
     return &pDevice->stats;
@@ -3458,7 +3451,7 @@ int __device_ioctl(HANDLE pExDevice, struct ifreq *rq, int cmd) {
 #else
 
 static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
-	PSDevice	        pDevice = (PSDevice)dev->priv;
+	PSDevice	        pDevice = (PSDevice)netdev_priv(dev);
 #endif
 
 #ifdef WIRELESS_EXT
@@ -4116,7 +4109,6 @@ int __device_hw_init(HANDLE pExDevice){
     PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
     PSDevice    pDevice;
 
-
     pDevice = (PSDevice)kmalloc(sizeof(DEVICE_INFO), (int)GFP_ATOMIC);
     if (pDevice == NULL)
         return FALSE;

commit 756f94e6386519696455a3b1a15f3d451bcf73c7
Author: Forest Bond <forest@alittletooquiet.net>
Date:   Sat Apr 25 10:32:25 2009 -0400

    Staging: vt6655: Drop obsolete fsuid/fsgid accesses.
    
    drivers/staging/vt6655/device_main.c: Drop obsolete fsuid/fsgid accesses.
    
    Signed-off-by: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index bade552ba737..d8f7f4f7bac4 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -3278,15 +3278,18 @@ int Config_FileOperation(PSDevice pDevice,BOOL fwrite,unsigned char *Parameter)
     UCHAR      tmpbuffer[20];
     struct file   *filp=NULL;
     mm_segment_t old_fs = get_fs();
-    int oldfsuid=0,oldfsgid=0;
+    //int oldfsuid=0,oldfsgid=0;
     int result=0;
 
     set_fs (KERNEL_DS);
-//Make sure a caller can read or write power as root
-   oldfsuid=current->fsuid;
-   oldfsgid=current->fsgid;
-    current->fsuid = 0;
-    current->fsgid = 0;
+
+    /* Can't do this anymore, so we rely on correct filesystem permissions:
+    //Make sure a caller can read or write power as root
+    oldfsuid=current->cred->fsuid;
+    oldfsgid=current->cred->fsgid;
+    current->cred->fsuid = 0;
+    current->cred->fsgid = 0;
+    */
 
     //open file
       filp = filp_open(config_path, O_RDWR, 0);
@@ -3344,8 +3347,11 @@ else {
 
 error2:
   set_fs (old_fs);
-  current->fsuid=oldfsuid;
-  current->fsgid=oldfsgid;
+
+  /*
+  current->cred->fsuid=oldfsuid;
+  current->cred->fsgid=oldfsgid;
+  */
 
   return result;
 }

commit 5449c685a4b39534f18869a93896370224463715
Author: Forest Bond <forest@alittletooquiet.net>
Date:   Sat Apr 25 10:30:44 2009 -0400

    Staging: Add pristine upstream vt6655 driver sources
    
    Add pristine upstream vt6655 driver sources to drivers/staging/vt6655.  These
    files were literally copied from the driver directory in the upstream source
    archive, available here:
    
      http://www.viaarena.com/Driver/vt6655_linux_src_v1.19.12_x86.zip
    
    Signed-off-by: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
new file mode 100644
index 000000000000..bade552ba737
--- /dev/null
+++ b/drivers/staging/vt6655/device_main.c
@@ -0,0 +1,4153 @@
+/*
+ * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * File: device_main.c
+ *
+ * Purpose: driver entry for initial, open, close, tx and rx.
+ *
+ * Author: Lyndon Chen
+ *
+ * Date: Jan 8, 2003
+ *
+ * Functions:
+ *
+ *   device_found1 - module initial (insmod) driver entry
+ *   device_remove1 - module remove entry
+ *   device_init_info - device structure resource allocation function
+ *   device_free_info - device structure resource free function
+ *   device_get_pci_info - get allocated pci io/mem resource
+ *   device_print_info - print out resource
+ *   device_open - allocate dma/descripter resource & initial mac/bbp function
+ *   device_xmit - asynchrous data tx function
+ *   device_intr - interrupt handle function
+ *   device_set_multi - set mac filter
+ *   device_ioctl - ioctl entry
+ *   device_close - shutdown mac/bbp & free dma/descripter resource
+ *   device_rx_srv - rx service function
+ *   device_receive_frame - rx data function
+ *   device_alloc_rx_buf - rx buffer pre-allocated function
+ *   device_alloc_frag_buf - rx fragement pre-allocated function
+ *   device_free_tx_buf - free tx buffer function
+ *   device_free_frag_buf- free de-fragement buffer
+ *   device_dma0_tx_80211- tx 802.11 frame via dma0
+ *   device_dma0_xmit- tx PS bufferred frame via dma0
+ *   device_init_rd0_ring- initial rd dma0 ring
+ *   device_init_rd1_ring- initial rd dma1 ring
+ *   device_init_td0_ring- initial tx dma0 ring buffer
+ *   device_init_td1_ring- initial tx dma1 ring buffer
+ *   device_init_registers- initial MAC & BBP & RF internal registers.
+ *   device_init_rings- initial tx/rx ring buffer
+ *   device_init_defrag_cb- initial & allocate de-fragement buffer.
+ *   device_free_rings- free all allocated ring buffer
+ *   device_tx_srv- tx interrupt service function
+ *
+ * Revision History:
+ */
+#undef __NO_VERSION__
+
+#if !defined(__DEVICE_H__)
+#include "device.h"
+#endif
+#if !defined(__CARD_H__)
+#include "card.h"
+#endif
+#if !defined(__TBIT_H__)
+#include "tbit.h"
+#endif
+#if !defined(__BASEBAND_H__)
+#include "baseband.h"
+#endif
+#if !defined(__MAC_H__)
+#include "mac.h"
+#endif
+#if !defined(__TETHER_H__)
+#include "tether.h"
+#endif
+#if !defined(__WMGR_H__)
+#include "wmgr.h"
+#endif
+#if !defined(__WCTL_H__)
+#include "wctl.h"
+#endif
+#if !defined(__POWER_H__)
+#include "power.h"
+#endif
+#if !defined(__WCMD_H__)
+#include "wcmd.h"
+#endif
+#if !defined(__IOCMD_H__)
+#include "iocmd.h"
+#endif
+#if !defined(__TCRC_H__)
+#include "tcrc.h"
+#endif
+#if !defined(__RXTX_H__)
+#include "rxtx.h"
+#endif
+#if !defined(__WROUTE_H__)
+#include "wroute.h"
+#endif
+#if !defined(__BSSDB_H__)
+#include "bssdb.h"
+#endif
+#if !defined(__HOSTAP_H__)
+#include "hostap.h"
+#endif
+#if !defined(__WPACTL_H__)
+#include "wpactl.h"
+#endif
+#if !defined(__IOCTL_H__)
+#include "ioctl.h"
+#endif
+#if !defined(__IWCTL_H__)
+#include "iwctl.h"
+#endif
+#if !defined(__DPC_H__)
+#include "dpc.h"
+#endif
+#if !defined(__DATARATE_H__)
+#include "datarate.h"
+#endif
+#if !defined(__RF_H__)
+#include "rf.h"
+#endif
+#if !defined(__IOWPA_H__)
+#include "iowpa.h"
+#endif
+
+#include <linux/delay.h>
+#include <linux/kthread.h>
+// #ifdef PRIVATE_OBJ
+//#if !defined(__DEVICE_EXP_H)
+//#include "device_exp.h"
+//#endif
+//#if !defined(__DEVICE_MODULE_H)
+//#include "device_module.h"
+//#endif
+
+
+// #endif
+//#define	DEBUG
+/*---------------------  Static Definitions -------------------------*/
+//static int          msglevel                =MSG_LEVEL_DEBUG;
+static int          msglevel                =   MSG_LEVEL_INFO;
+
+//#define	PLICE_DEBUG
+//
+// Define module options
+//
+#ifndef PRIVATE_OBJ
+MODULE_AUTHOR("VIA Networking Technologies, Inc., <lyndonchen@vntek.com.tw>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("VIA Networking Solomon-A/B/G Wireless LAN Adapter Driver");
+#endif
+
+//PLICE_DEBUG ->
+	static int mlme_kill;
+	//static  struct task_struct * mlme_task;
+//PLICE_DEBUG <-
+
+#define DEVICE_PARAM(N,D)
+/*
+        static const int N[MAX_UINTS]=OPTION_DEFAULT;\
+        MODULE_PARM(N, "1-" __MODULE_STRING(MAX_UINTS) "i");\
+        MODULE_PARM_DESC(N, D);
+*/
+
+#define RX_DESC_MIN0     16
+#define RX_DESC_MAX0     128
+#define RX_DESC_DEF0     32
+DEVICE_PARAM(RxDescriptors0,"Number of receive descriptors0");
+
+#define RX_DESC_MIN1     16
+#define RX_DESC_MAX1     128
+#define RX_DESC_DEF1     32
+DEVICE_PARAM(RxDescriptors1,"Number of receive descriptors1");
+
+#define TX_DESC_MIN0     16
+#define TX_DESC_MAX0     128
+#define TX_DESC_DEF0     32
+DEVICE_PARAM(TxDescriptors0,"Number of transmit descriptors0");
+
+#define TX_DESC_MIN1     16
+#define TX_DESC_MAX1     128
+#define TX_DESC_DEF1     64
+DEVICE_PARAM(TxDescriptors1,"Number of transmit descriptors1");
+
+
+#define IP_ALIG_DEF     0
+/* IP_byte_align[] is used for IP header DWORD byte aligned
+   0: indicate the IP header won't be DWORD byte aligned.(Default) .
+   1: indicate the IP header will be DWORD byte aligned.
+      In some enviroment, the IP header should be DWORD byte aligned,
+      or the packet will be droped when we receive it. (eg: IPVS)
+*/
+DEVICE_PARAM(IP_byte_align,"Enable IP header dword aligned");
+
+
+#define INT_WORKS_DEF   20
+#define INT_WORKS_MIN   10
+#define INT_WORKS_MAX   64
+
+DEVICE_PARAM(int_works,"Number of packets per interrupt services");
+
+#define CHANNEL_MIN     1
+#define CHANNEL_MAX     14
+#define CHANNEL_DEF     6
+
+DEVICE_PARAM(Channel, "Channel number");
+
+
+/* PreambleType[] is the preamble length used for transmit.
+   0: indicate allows long preamble type
+   1: indicate allows short preamble type
+*/
+
+#define PREAMBLE_TYPE_DEF     1
+
+DEVICE_PARAM(PreambleType, "Preamble Type");
+
+
+#define RTS_THRESH_MIN     512
+#define RTS_THRESH_MAX     2347
+#define RTS_THRESH_DEF     2347
+
+DEVICE_PARAM(RTSThreshold, "RTS threshold");
+
+
+#define FRAG_THRESH_MIN     256
+#define FRAG_THRESH_MAX     2346
+#define FRAG_THRESH_DEF     2346
+
+DEVICE_PARAM(FragThreshold, "Fragmentation threshold");
+
+
+#define DATA_RATE_MIN     0
+#define DATA_RATE_MAX     13
+#define DATA_RATE_DEF     13
+/* datarate[] index
+   0: indicate 1 Mbps   0x02
+   1: indicate 2 Mbps   0x04
+   2: indicate 5.5 Mbps 0x0B
+   3: indicate 11 Mbps  0x16
+   4: indicate 6 Mbps   0x0c
+   5: indicate 9 Mbps   0x12
+   6: indicate 12 Mbps  0x18
+   7: indicate 18 Mbps  0x24
+   8: indicate 24 Mbps  0x30
+   9: indicate 36 Mbps  0x48
+  10: indicate 48 Mbps  0x60
+  11: indicate 54 Mbps  0x6c
+  12: indicate 72 Mbps  0x90
+  13: indicate auto rate
+*/
+
+DEVICE_PARAM(ConnectionRate, "Connection data rate");
+
+#define OP_MODE_DEF     0
+
+DEVICE_PARAM(OPMode, "Infrastruct, adhoc, AP mode ");
+
+/* OpMode[] is used for transmit.
+   0: indicate infrastruct mode used
+   1: indicate adhoc mode used
+   2: indicate AP mode used
+*/
+
+
+/* PSMode[]
+   0: indicate disable power saving mode
+   1: indicate enable power saving mode
+*/
+
+#define PS_MODE_DEF     0
+
+DEVICE_PARAM(PSMode, "Power saving mode");
+
+
+#define SHORT_RETRY_MIN     0
+#define SHORT_RETRY_MAX     31
+#define SHORT_RETRY_DEF     8
+
+
+DEVICE_PARAM(ShortRetryLimit, "Short frame retry limits");
+
+#define LONG_RETRY_MIN     0
+#define LONG_RETRY_MAX     15
+#define LONG_RETRY_DEF     4
+
+
+DEVICE_PARAM(LongRetryLimit, "long frame retry limits");
+
+
+/* BasebandType[] baseband type selected
+   0: indicate 802.11a type
+   1: indicate 802.11b type
+   2: indicate 802.11g type
+*/
+#define BBP_TYPE_MIN     0
+#define BBP_TYPE_MAX     2
+#define BBP_TYPE_DEF     2
+
+DEVICE_PARAM(BasebandType, "baseband type");
+
+
+
+/* 80211hEnable[]
+   0: indicate disable 802.11h
+   1: indicate enable 802.11h
+*/
+
+#define X80211h_MODE_DEF     0
+
+DEVICE_PARAM(b80211hEnable, "802.11h mode");
+
+/* 80211hEnable[]
+   0: indicate disable 802.11h
+   1: indicate enable 802.11h
+*/
+
+#define DIVERSITY_ANT_DEF     0
+
+DEVICE_PARAM(bDiversityANTEnable, "ANT diversity mode");
+
+
+//
+// Static vars definitions
+//
+
+
+#ifndef PRIVATE_OBJ
+static int          device_nics             =0;
+static PSDevice     pDevice_Infos           =NULL;
+static struct net_device *root_device_dev = NULL;
+
+static CHIP_INFO chip_info_table[]= {
+    { VT3253,       "VIA Networking Solomon-A/B/G Wireless LAN Adapter ",
+        256, 1,     DEVICE_FLAGS_IP_ALIGN|DEVICE_FLAGS_TX_ALIGN },
+    {0,NULL}
+};
+
+static struct pci_device_id device_id_table[] __devinitdata = {
+{ 0x1106, 0x3253, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (int)&chip_info_table[0]},
+{ 0, }
+};
+#endif
+
+/*---------------------  Static Functions  --------------------------*/
+
+#ifndef PRIVATE_OBJ
+
+static int  device_found1(struct pci_dev *pcid, const struct pci_device_id *ent);
+static BOOL device_init_info(struct pci_dev* pcid, PSDevice* ppDevice, PCHIP_INFO);
+static void device_free_info(PSDevice pDevice);
+static BOOL device_get_pci_info(PSDevice, struct pci_dev* pcid);
+static void device_print_info(PSDevice pDevice);
+static struct net_device_stats *device_get_stats(struct net_device *dev);
+static void device_init_diversity_timer(PSDevice pDevice);
+static int  device_open(struct net_device *dev);
+static int  device_xmit(struct sk_buff *skb, struct net_device *dev);
+static  irqreturn_t  device_intr(int irq,  void*dev_instance);
+static void device_set_multi(struct net_device *dev);
+static int  device_close(struct net_device *dev);
+static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
+#ifdef CONFIG_PM
+static int device_notify_reboot(struct notifier_block *, unsigned long event, void *ptr);
+static int viawget_suspend(struct pci_dev *pcid, u32 state);
+static int viawget_resume(struct pci_dev *pcid);
+struct notifier_block device_notifier = {
+        notifier_call:  device_notify_reboot,
+        next:           NULL,
+        priority:       0
+};
+#endif
+#endif
+
+#endif // #ifndef PRIVATE_OBJ
+
+static void device_init_rd0_ring(PSDevice pDevice);
+static void device_init_rd1_ring(PSDevice pDevice);
+static void device_init_defrag_cb(PSDevice pDevice);
+static void device_init_td0_ring(PSDevice pDevice);
+static void device_init_td1_ring(PSDevice pDevice);
+
+#ifndef PRIVATE_OBJ
+static int  device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev);
+#endif
+//2008-0714<Add>by Mike Liu
+static BOOL device_release_WPADEV(PSDevice pDevice);
+
+static int  ethtool_ioctl(struct net_device *dev, void *useraddr);
+static int  device_rx_srv(PSDevice pDevice, UINT uIdx);
+static int  device_tx_srv(PSDevice pDevice, UINT uIdx);
+static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pDesc);
+static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType);
+static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc);
+static void device_free_td0_ring(PSDevice pDevice);
+static void device_free_td1_ring(PSDevice pDevice);
+static void device_free_rd0_ring(PSDevice pDevice);
+static void device_free_rd1_ring(PSDevice pDevice);
+static void device_free_rings(PSDevice pDevice);
+static void device_free_frag_buf(PSDevice pDevice);
+static int Config_FileGetParameter(UCHAR *string, UCHAR *dest,UCHAR *source);
+
+
+/*---------------------  Export Variables  --------------------------*/
+
+/*---------------------  Export Functions  --------------------------*/
+
+
+#ifndef PRIVATE_OBJ
+
+static char* get_chip_name(int chip_id) {
+    int i;
+    for (i=0;chip_info_table[i].name!=NULL;i++)
+        if (chip_info_table[i].chip_id==chip_id)
+            break;
+    return chip_info_table[i].name;
+}
+
+static void __devexit device_remove1(struct pci_dev *pcid)
+{
+    PSDevice pDevice=pci_get_drvdata(pcid);
+
+    if (pDevice==NULL)
+        return;
+    device_free_info(pDevice);
+
+}
+
+#endif
+/*
+static void
+device_set_int_opt(int *opt, int val, int min, int max, int def,char* name,char* devname) {
+    if (val==-1)
+        *opt=def;
+    else if (val<min || val>max) {
+        DEVICE_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: the value of parameter %s is invalid, the valid range is (%d-%d)\n" ,
+            devname,name, min,max);
+        *opt=def;
+    } else {
+        DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: set value of parameter %s to %d\n",
+            devname, name, val);
+        *opt=val;
+    }
+}
+
+static void
+device_set_bool_opt(PU32 opt, int val,BOOL def,U32 flag, char* name,char* devname) {
+    (*opt)&=(~flag);
+    if (val==-1)
+        *opt|=(def ? flag : 0);
+    else if (val<0 || val>1) {
+        DEVICE_PRT(MSG_LEVEL_INFO, KERN_NOTICE
+            "%s: the value of parameter %s is invalid, the valid range is (0-1)\n",devname,name);
+        *opt|=(def ? flag : 0);
+    } else {
+        DEVICE_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: set parameter %s to %s\n",
+            devname,name , val ? "TRUE" : "FALSE");
+        *opt|=(val ? flag : 0);
+    }
+}
+*/
+static void
+device_get_options(PSDevice pDevice, int index, char* devname) {
+
+    POPTIONS pOpts = &(pDevice->sOpts);
+  pOpts->nRxDescs0=RX_DESC_DEF0;
+  pOpts->nRxDescs1=RX_DESC_DEF1;
+  pOpts->nTxDescs[0]=TX_DESC_DEF0;
+  pOpts->nTxDescs[1]=TX_DESC_DEF1;
+pOpts->flags|=DEVICE_FLAGS_IP_ALIGN;
+  pOpts->int_works=INT_WORKS_DEF;
+  pOpts->rts_thresh=RTS_THRESH_DEF;
+  pOpts->frag_thresh=FRAG_THRESH_DEF;
+  pOpts->data_rate=DATA_RATE_DEF;
+  pOpts->channel_num=CHANNEL_DEF;
+
+pOpts->flags|=DEVICE_FLAGS_PREAMBLE_TYPE;
+pOpts->flags|=DEVICE_FLAGS_OP_MODE;
+//pOpts->flags|=DEVICE_FLAGS_PS_MODE;
+  pOpts->short_retry=SHORT_RETRY_DEF;
+  pOpts->long_retry=LONG_RETRY_DEF;
+  pOpts->bbp_type=BBP_TYPE_DEF;
+pOpts->flags|=DEVICE_FLAGS_80211h_MODE;
+pOpts->flags|=DEVICE_FLAGS_DiversityANT;
+
+
+}
+
+static void
+device_set_options(PSDevice pDevice) {
+
+    BYTE    abyBroadcastAddr[U_ETHER_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+    BYTE    abySNAP_RFC1042[U_ETHER_ADDR_LEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
+    BYTE    abySNAP_Bridgetunnel[U_ETHER_ADDR_LEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
+
+
+    memcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, U_ETHER_ADDR_LEN);
+    memcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, U_ETHER_ADDR_LEN);
+    memcpy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel, U_ETHER_ADDR_LEN);
+
+    pDevice->uChannel = pDevice->sOpts.channel_num;
+    pDevice->wRTSThreshold = pDevice->sOpts.rts_thresh;
+    pDevice->wFragmentationThreshold = pDevice->sOpts.frag_thresh;
+    pDevice->byShortRetryLimit = pDevice->sOpts.short_retry;
+    pDevice->byLongRetryLimit = pDevice->sOpts.long_retry;
+    pDevice->wMaxTransmitMSDULifetime = DEFAULT_MSDU_LIFETIME;
+    pDevice->byShortPreamble = (pDevice->sOpts.flags & DEVICE_FLAGS_PREAMBLE_TYPE) ? 1 : 0;
+    pDevice->byOpMode = (pDevice->sOpts.flags & DEVICE_FLAGS_OP_MODE) ? 1 : 0;
+    pDevice->ePSMode = (pDevice->sOpts.flags & DEVICE_FLAGS_PS_MODE) ? 1 : 0;
+    pDevice->b11hEnable = (pDevice->sOpts.flags & DEVICE_FLAGS_80211h_MODE) ? 1 : 0;
+    pDevice->bDiversityRegCtlON = (pDevice->sOpts.flags & DEVICE_FLAGS_DiversityANT) ? 1 : 0;
+    pDevice->uConnectionRate = pDevice->sOpts.data_rate;
+    if (pDevice->uConnectionRate < RATE_AUTO) pDevice->bFixRate = TRUE;
+    pDevice->byBBType = pDevice->sOpts.bbp_type;
+    pDevice->byPacketType = pDevice->byBBType;
+
+//PLICE_DEBUG->
+	pDevice->byAutoFBCtrl = AUTO_FB_0;
+	//pDevice->byAutoFBCtrl = AUTO_FB_1;
+//PLICE_DEBUG<-
+pDevice->bUpdateBBVGA = TRUE;
+    pDevice->byFOETuning = 0;
+    pDevice->wCTSDuration = 0;
+    pDevice->byPreambleType = 0;
+
+
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uChannel= %d\n",(INT)pDevice->uChannel);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byOpMode= %d\n",(INT)pDevice->byOpMode);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" ePSMode= %d\n",(INT)pDevice->ePSMode);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" wRTSThreshold= %d\n",(INT)pDevice->wRTSThreshold);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortRetryLimit= %d\n",(INT)pDevice->byShortRetryLimit);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byLongRetryLimit= %d\n",(INT)pDevice->byLongRetryLimit);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byPreambleType= %d\n",(INT)pDevice->byPreambleType);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortPreamble= %d\n",(INT)pDevice->byShortPreamble);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uConnectionRate= %d\n",(INT)pDevice->uConnectionRate);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byBBType= %d\n",(INT)pDevice->byBBType);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->b11hEnable= %d\n",(INT)pDevice->b11hEnable);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->bDiversityRegCtlON= %d\n",(INT)pDevice->bDiversityRegCtlON);
+}
+
+static VOID s_vCompleteCurrentMeasure (IN PSDevice pDevice, IN BYTE byResult)
+{
+    UINT    ii;
+    DWORD   dwDuration = 0;
+    BYTE    byRPI0 = 0;
+
+    for(ii=1;ii<8;ii++) {
+        pDevice->dwRPIs[ii] *= 255;
+        dwDuration |= *((PWORD) (pDevice->pCurrMeasureEID->sReq.abyDuration));
+        dwDuration <<= 10;
+        pDevice->dwRPIs[ii] /= dwDuration;
+        pDevice->abyRPIs[ii] = (BYTE) pDevice->dwRPIs[ii];
+        byRPI0 += pDevice->abyRPIs[ii];
+    }
+    pDevice->abyRPIs[0] = (0xFF - byRPI0);
+
+     if (pDevice->uNumOfMeasureEIDs == 0) {
+        VNTWIFIbMeasureReport(  pDevice->pMgmt,
+                                TRUE,
+                                pDevice->pCurrMeasureEID,
+                                byResult,
+                                pDevice->byBasicMap,
+                                pDevice->byCCAFraction,
+                                pDevice->abyRPIs
+                                );
+    } else {
+        VNTWIFIbMeasureReport(  pDevice->pMgmt,
+                                FALSE,
+                                pDevice->pCurrMeasureEID,
+                                byResult,
+                                pDevice->byBasicMap,
+                                pDevice->byCCAFraction,
+                                pDevice->abyRPIs
+                                );
+        CARDbStartMeasure (pDevice, pDevice->pCurrMeasureEID++, pDevice->uNumOfMeasureEIDs);
+    }
+
+}
+
+
+
+//
+// Initialiation of MAC & BBP registers
+//
+
+static void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
+{
+    UINT    ii;
+    BYTE    byValue;
+	BYTE    byValue1;
+    BYTE    byCCKPwrdBm = 0;
+    BYTE    byOFDMPwrdBm = 0;
+    INT zonetype=0;
+     PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
+    MACbShutdown(pDevice->PortOffset);
+    BBvSoftwareReset(pDevice->PortOffset);
+
+    if ((InitType == DEVICE_INIT_COLD) ||
+        (InitType == DEVICE_INIT_DXPL)) {
+        // Do MACbSoftwareReset in MACvInitialize
+        MACbSoftwareReset(pDevice->PortOffset);
+        // force CCK
+        pDevice->bCCK = TRUE;
+        pDevice->bAES = FALSE;
+        pDevice->bProtectMode = FALSE;      //Only used in 11g type, sync with ERP IE
+        pDevice->bNonERPPresent = FALSE;
+        pDevice->bBarkerPreambleMd = FALSE;
+        pDevice->wCurrentRate = RATE_1M;
+        pDevice->byTopOFDMBasicRate = RATE_24M;
+        pDevice->byTopCCKBasicRate = RATE_1M;
+
+        pDevice->byRevId = 0;                   //Target to IF pin while programming to RF chip.
+
+        // init MAC
+        MACvInitialize(pDevice->PortOffset);
+
+        // Get Local ID
+        VNSvInPortB(pDevice->PortOffset + MAC_REG_LOCALID, &(pDevice->byLocalID));
+
+           spin_lock_irq(&pDevice->lock);
+	 SROMvReadAllContents(pDevice->PortOffset,pDevice->abyEEPROM);
+
+           spin_unlock_irq(&pDevice->lock);
+
+        // Get Channel range
+
+        pDevice->byMinChannel = 1;
+        pDevice->byMaxChannel = CB_MAX_CHANNEL;
+
+        // Get Antena
+        byValue = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
+        if (byValue & EEP_ANTINV)
+            pDevice->bTxRxAntInv = TRUE;
+        else
+            pDevice->bTxRxAntInv = FALSE;
+#ifdef	PLICE_DEBUG
+	//printk("init_register:TxRxAntInv is %d,byValue is %d\n",pDevice->bTxRxAntInv,byValue);
+#endif
+
+        byValue &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
+        if (byValue == 0) // if not set default is All
+            byValue = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
+#ifdef	PLICE_DEBUG
+	//printk("init_register:byValue is %d\n",byValue);
+#endif
+        pDevice->ulDiversityNValue = 100*260;//100*SROMbyReadEmbedded(pDevice->PortOffset, 0x51);
+        pDevice->ulDiversityMValue = 100*16;//SROMbyReadEmbedded(pDevice->PortOffset, 0x52);
+        pDevice->byTMax = 1;//SROMbyReadEmbedded(pDevice->PortOffset, 0x53);
+        pDevice->byTMax2 = 4;//SROMbyReadEmbedded(pDevice->PortOffset, 0x54);
+        pDevice->ulSQ3TH = 0;//(ULONG) SROMbyReadEmbedded(pDevice->PortOffset, 0x55);
+        pDevice->byTMax3 = 64;//SROMbyReadEmbedded(pDevice->PortOffset, 0x56);
+
+        if (byValue == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {
+            pDevice->byAntennaCount = 2;
+            pDevice->byTxAntennaMode = ANT_B;
+            pDevice->dwTxAntennaSel = 1;
+            pDevice->dwRxAntennaSel = 1;
+            if (pDevice->bTxRxAntInv == TRUE)
+                pDevice->byRxAntennaMode = ANT_A;
+            else
+                pDevice->byRxAntennaMode = ANT_B;
+                // chester for antenna
+byValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);
+          //  if (pDevice->bDiversityRegCtlON)
+          if((byValue1&0x08)==0)
+                pDevice->bDiversityEnable = FALSE;//SROMbyReadEmbedded(pDevice->PortOffset, 0x50);
+            else
+                pDevice->bDiversityEnable = TRUE;
+#ifdef	PLICE_DEBUG
+		//printk("aux |main antenna: RxAntennaMode is %d\n",pDevice->byRxAntennaMode);
+#endif
+	} else  {
+            pDevice->bDiversityEnable = FALSE;
+            pDevice->byAntennaCount = 1;
+            pDevice->dwTxAntennaSel = 0;
+            pDevice->dwRxAntennaSel = 0;
+            if (byValue & EEP_ANTENNA_AUX) {
+                pDevice->byTxAntennaMode = ANT_A;
+                if (pDevice->bTxRxAntInv == TRUE)
+                    pDevice->byRxAntennaMode = ANT_B;
+                else
+                    pDevice->byRxAntennaMode = ANT_A;
+            } else {
+                pDevice->byTxAntennaMode = ANT_B;
+                if (pDevice->bTxRxAntInv == TRUE)
+                    pDevice->byRxAntennaMode = ANT_A;
+                else
+                    pDevice->byRxAntennaMode = ANT_B;
+            }
+        }
+#ifdef	PLICE_DEBUG
+	//printk("init registers: TxAntennaMode is %d\n",pDevice->byTxAntennaMode);
+#endif
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",
+            pDevice->bDiversityEnable,(int)pDevice->ulDiversityNValue,(int)pDevice->ulDiversityMValue,pDevice->byTMax,pDevice->byTMax2);
+
+//#ifdef ZoneType_DefaultSetting
+//2008-8-4 <add> by chester
+//zonetype initial
+ pDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
+ if((zonetype=Config_FileOperation(pDevice,FALSE,NULL)) >= 0) {         //read zonetype file ok!
+  if ((zonetype == 0)&&
+        (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] !=0x00)){          //for USA
+    pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0;
+    pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0B;
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Init Zone Type :USA\n");
+  }
+ else if((zonetype == 1)&&
+ 	     (pDevice->abyEEPROM[EEP_OFS_ZONETYPE]!=0x01)){   //for Japan
+    pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x01;
+    pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
+  }
+ else if((zonetype == 2)&&
+ 	     (pDevice->abyEEPROM[EEP_OFS_ZONETYPE]!=0x02)){   //for Europe
+    pDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x02;
+    pDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Init Zone Type :Europe\n");
+  }
+
+else
+{
+   if(zonetype!=pDevice->abyEEPROM[EEP_OFS_ZONETYPE])
+      printk("zonetype in file[%02x] mismatch with in EEPROM[%02x]\n",zonetype,pDevice->abyEEPROM[EEP_OFS_ZONETYPE]);
+   else
+      printk("Read Zonetype file sucess,use default zonetype setting[%02x]\n",zonetype);
+ }
+ 	}
+  else
+    printk("Read Zonetype file fail,use default zonetype setting[%02x]\n",SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ZONETYPE));
+
+        // Get RFType
+        pDevice->byRFType = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RFTYPE);
+
+        if ((pDevice->byRFType & RF_EMU) != 0) {
+            // force change RevID for VT3253 emu
+            pDevice->byRevId = 0x80;
+        }
+
+        pDevice->byRFType &= RF_MASK;
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRFType = %x\n", pDevice->byRFType);
+
+        if (pDevice->bZoneRegExist == FALSE) {
+            pDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];
+        }
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byZoneType = %x\n", pDevice->byZoneType);
+
+        //Init RF module
+        RFbInit(pDevice);
+
+        //Get Desire Power Value
+        pDevice->byCurPwr = 0xFF;
+        pDevice->byCCKPwr = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_CCK);
+        pDevice->byOFDMPwrG = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_OFDMG);
+        //byCCKPwrdBm = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_CCK_PWR_dBm);
+
+	//byOFDMPwrdBm = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_OFDM_PWR_dBm);
+//printk("CCKPwrdBm is 0x%x,byOFDMPwrdBm is 0x%x\n",byCCKPwrdBm,byOFDMPwrdBm);
+		// Load power Table
+
+
+        for (ii=0;ii<CB_MAX_CHANNEL_24G;ii++) {
+            pDevice->abyCCKPwrTbl[ii+1] = SROMbyReadEmbedded(pDevice->PortOffset, (BYTE)(ii + EEP_OFS_CCK_PWR_TBL));
+            if (pDevice->abyCCKPwrTbl[ii+1] == 0) {
+                pDevice->abyCCKPwrTbl[ii+1] = pDevice->byCCKPwr;
+            }
+            pDevice->abyOFDMPwrTbl[ii+1] = SROMbyReadEmbedded(pDevice->PortOffset, (BYTE)(ii + EEP_OFS_OFDM_PWR_TBL));
+            if (pDevice->abyOFDMPwrTbl[ii+1] == 0) {
+                pDevice->abyOFDMPwrTbl[ii+1] = pDevice->byOFDMPwrG;
+            }
+            pDevice->abyCCKDefaultPwr[ii+1] = byCCKPwrdBm;
+            pDevice->abyOFDMDefaultPwr[ii+1] = byOFDMPwrdBm;
+        }
+		//2008-8-4 <add> by chester
+	  //recover 12,13 ,14channel for EUROPE by 11 channel
+          if(((pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Japan) ||
+	        (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Europe))&&
+	     (pDevice->byOriginalZonetype == ZoneType_USA)) {
+	    for(ii=11;ii<14;ii++) {
+                pDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];
+	       pDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];
+
+	    }
+	  }
+
+
+        // Load OFDM A Power Table
+        for (ii=0;ii<CB_MAX_CHANNEL_5G;ii++) { //RobertYu:20041224, bug using CB_MAX_CHANNEL
+            pDevice->abyOFDMPwrTbl[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (BYTE)(ii + EEP_OFS_OFDMA_PWR_TBL));
+            pDevice->abyOFDMDefaultPwr[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (BYTE)(ii + EEP_OFS_OFDMA_PWR_dBm));
+        }
+        CARDvInitChannelTable((PVOID)pDevice);
+
+
+        if (pDevice->byLocalID > REV_ID_VT3253_B1) {
+            MACvSelectPage1(pDevice->PortOffset);
+            VNSvOutPortB(pDevice->PortOffset + MAC_REG_MSRCTL + 1, (MSRCTL1_TXPWR | MSRCTL1_CSAPAREN));
+            MACvSelectPage0(pDevice->PortOffset);
+        }
+
+
+         // use relative tx timeout and 802.11i D4
+        MACvWordRegBitsOn(pDevice->PortOffset, MAC_REG_CFG, (CFG_TKIPOPT | CFG_NOTXTIMEOUT));
+
+        // set performance parameter by registry
+        MACvSetShortRetryLimit(pDevice->PortOffset, pDevice->byShortRetryLimit);
+        MACvSetLongRetryLimit(pDevice->PortOffset, pDevice->byLongRetryLimit);
+
+        // reset TSF counter
+        VNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
+        // enable TSF counter
+        VNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
+
+        // initialize BBP registers
+        BBbVT3253Init(pDevice);
+
+        if (pDevice->bUpdateBBVGA) {
+            pDevice->byBBVGACurrent = pDevice->abyBBVGA[0];
+            pDevice->byBBVGANew = pDevice->byBBVGACurrent;
+            BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
+        }
+#ifdef	PLICE_DEBUG
+	//printk("init registers:RxAntennaMode is %x,TxAntennaMode is %x\n",pDevice->byRxAntennaMode,pDevice->byTxAntennaMode);
+#endif
+        BBvSetRxAntennaMode(pDevice->PortOffset, pDevice->byRxAntennaMode);
+        BBvSetTxAntennaMode(pDevice->PortOffset, pDevice->byTxAntennaMode);
+
+        pDevice->byCurrentCh = 0;
+
+        //pDevice->NetworkType = Ndis802_11Automode;
+        // Set BB and packet type at the same time.
+        // Set Short Slot Time, xIFS, and RSPINF.
+        if (pDevice->uConnectionRate == RATE_AUTO) {
+            pDevice->wCurrentRate = RATE_54M;
+        } else {
+            pDevice->wCurrentRate = (WORD)pDevice->uConnectionRate;
+        }
+
+        // default G Mode
+        VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_11G);
+        VNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_AUTO);
+
+        pDevice->bRadioOff = FALSE;
+
+        pDevice->byRadioCtl = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RADIOCTL);
+        pDevice->bHWRadioOff = FALSE;
+
+        if (pDevice->byRadioCtl & EEP_RADIOCTL_ENABLE) {
+            // Get GPIO
+            MACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);
+//2008-4-14 <add> by chester for led issue
+ #ifdef FOR_LED_ON_NOTEBOOK
+if (BITbIsBitOn(pDevice->byGPIO,GPIO0_DATA)){pDevice->bHWRadioOff = TRUE;}
+if (BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA)){pDevice->bHWRadioOff = FALSE;}
+
+            }
+        if ( (pDevice->bRadioControlOff == TRUE)) {
+            CARDbRadioPowerOff(pDevice);
+        }
+else  CARDbRadioPowerOn(pDevice);
+#else
+            if ((BITbIsBitOn(pDevice->byGPIO,GPIO0_DATA) && BITbIsBitOff(pDevice->byRadioCtl, EEP_RADIOCTL_INV)) ||
+                (BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA) && BITbIsBitOn(pDevice->byRadioCtl, EEP_RADIOCTL_INV))) {
+                pDevice->bHWRadioOff = TRUE;
+            }
+        }
+        if ((pDevice->bHWRadioOff == TRUE) || (pDevice->bRadioControlOff == TRUE)) {
+            CARDbRadioPowerOff(pDevice);
+        }
+
+#endif
+    }
+            pMgmt->eScanType = WMAC_SCAN_PASSIVE;
+    // get Permanent network address
+    SROMvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Network address = %02x-%02x-%02x=%02x-%02x-%02x\n",
+        pDevice->abyCurrentNetAddr[0],
+        pDevice->abyCurrentNetAddr[1],
+        pDevice->abyCurrentNetAddr[2],
+        pDevice->abyCurrentNetAddr[3],
+        pDevice->abyCurrentNetAddr[4],
+        pDevice->abyCurrentNetAddr[5]);
+
+
+    // reset Tx pointer
+    CARDvSafeResetRx(pDevice);
+    // reset Rx pointer
+    CARDvSafeResetTx(pDevice);
+
+    if (pDevice->byLocalID <= REV_ID_VT3253_A1) {
+        MACvRegBitsOn(pDevice->PortOffset, MAC_REG_RCR, RCR_WPAERR);
+    }
+
+    pDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;
+
+    // Turn On Rx DMA
+    MACvReceive0(pDevice->PortOffset);
+    MACvReceive1(pDevice->PortOffset);
+
+    // start the adapter
+    MACvStart(pDevice->PortOffset);
+
+    netif_stop_queue(pDevice->dev);
+
+
+}
+
+
+
+static VOID device_init_diversity_timer(PSDevice pDevice) {
+
+    init_timer(&pDevice->TimerSQ3Tmax1);
+    pDevice->TimerSQ3Tmax1.data = (ULONG)pDevice;
+    pDevice->TimerSQ3Tmax1.function = (TimerFunction)TimerSQ3CallBack;
+    pDevice->TimerSQ3Tmax1.expires = RUN_AT(HZ);
+
+    init_timer(&pDevice->TimerSQ3Tmax2);
+    pDevice->TimerSQ3Tmax2.data = (ULONG)pDevice;
+    pDevice->TimerSQ3Tmax2.function = (TimerFunction)TimerSQ3CallBack;
+    pDevice->TimerSQ3Tmax2.expires = RUN_AT(HZ);
+
+    init_timer(&pDevice->TimerSQ3Tmax3);
+    pDevice->TimerSQ3Tmax3.data = (ULONG)pDevice;
+    pDevice->TimerSQ3Tmax3.function = (TimerFunction)TimerState1CallBack;
+    pDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);
+
+    return;
+}
+
+
+static BOOL device_release_WPADEV(PSDevice pDevice)
+{
+  viawget_wpa_header *wpahdr;
+  int ii=0;
+ // wait_queue_head_t	Set_wait;
+  //send device close to wpa_supplicnat layer
+    if (pDevice->bWPADEVUp==TRUE) {
+                 wpahdr = (viawget_wpa_header *)pDevice->skb->data;
+                 wpahdr->type = VIAWGET_DEVICECLOSE_MSG;
+                 wpahdr->resp_ie_len = 0;
+                 wpahdr->req_ie_len = 0;
+                 skb_put(pDevice->skb, sizeof(viawget_wpa_header));
+                 pDevice->skb->dev = pDevice->wpadev;
+//2008-4-3 modify by Chester for wpa
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+                 pDevice->skb->mac_header = pDevice->skb->data;
+#else
+                 pDevice->skb->mac.raw = pDevice->skb->data;
+#endif
+                 pDevice->skb->pkt_type = PACKET_HOST;
+                 pDevice->skb->protocol = htons(ETH_P_802_2);
+                 memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
+                 netif_rx(pDevice->skb);
+                 pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
+
+ //wait release WPADEV
+              //    init_waitqueue_head(&Set_wait);
+              //    wait_event_timeout(Set_wait, ((pDevice->wpadev==NULL)&&(pDevice->skb == NULL)),5*HZ);    //1s wait
+              while((pDevice->bWPADEVUp==TRUE)) {
+	        set_current_state(TASK_UNINTERRUPTIBLE);
+                 schedule_timeout (HZ/20);          //wait 50ms
+                 ii++;
+	        if(ii>20)
+		  break;
+              }
+           };
+    return TRUE;
+}
+
+
+#ifndef PRIVATE_OBJ
+
+static int
+device_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
+{
+    static BOOL bFirst = TRUE;
+    struct net_device*  dev = NULL;
+    PCHIP_INFO  pChip_info = (PCHIP_INFO)ent->driver_data;
+    PSDevice    pDevice;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    int         rc;
+#endif
+//#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+ //  BYTE            fake_mac[U_ETHER_ADDR_LEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x01};//fake MAC address
+//#endif
+    if (device_nics ++>= MAX_UINTS) {
+        printk(KERN_NOTICE DEVICE_NAME ": already found %d NICs\n", device_nics);
+        return -ENODEV;
+    }
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    dev = alloc_etherdev(0);
+#else
+    dev = init_etherdev(dev, 0);
+#endif
+
+    if (dev == NULL) {
+        printk(KERN_ERR DEVICE_NAME ": allocate net device failed \n");
+        return -ENODEV;
+    }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    // Chain it all together
+   // SET_MODULE_OWNER(dev);
+    SET_NETDEV_DEV(dev, &pcid->dev);
+#endif
+
+    if (bFirst) {
+        printk(KERN_NOTICE "%s Ver. %s\n",DEVICE_FULL_DRV_NAM, DEVICE_VERSION);
+        printk(KERN_NOTICE "Copyright (c) 2003 VIA Networking Technologies, Inc.\n");
+        bFirst=FALSE;
+    }
+
+    if (!device_init_info(pcid, &pDevice, pChip_info)) {
+        return -ENOMEM;
+    }
+    pDevice->dev = dev;
+    pDevice->next_module = root_device_dev;
+    root_device_dev = dev;
+    dev->priv = pDevice;
+    dev->irq = pcid->irq;
+
+    if (pci_enable_device(pcid)) {
+        device_free_info(pDevice);
+        return -ENODEV;
+    }
+#ifdef	DEBUG
+	printk("Before get pci_info memaddr is %x\n",pDevice->memaddr);
+#endif
+    if (device_get_pci_info(pDevice,pcid) == FALSE) {
+        printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device.\n");
+        device_free_info(pDevice);
+        return -ENODEV;
+    }
+
+#if 1
+
+#ifdef	DEBUG
+
+	//pci_read_config_byte(pcid, PCI_BASE_ADDRESS_0, &pDevice->byRevId);
+	printk("after get pci_info memaddr is %x, io addr is %x,io_size is %d\n",pDevice->memaddr,pDevice->ioaddr,pDevice->io_size);
+	{
+		int i;
+		U32			bar,len;
+		u32 address[] = {
+		PCI_BASE_ADDRESS_0,
+		PCI_BASE_ADDRESS_1,
+		PCI_BASE_ADDRESS_2,
+		PCI_BASE_ADDRESS_3,
+		PCI_BASE_ADDRESS_4,
+		PCI_BASE_ADDRESS_5,
+		0};
+		for (i=0;address[i];i++)
+		{
+			//pci_write_config_dword(pcid,address[i], 0xFFFFFFFF);
+			pci_read_config_dword(pcid, address[i], &bar);
+			printk("bar %d is %x\n",i,bar);
+			if (!bar)
+			{
+				printk("bar %d not implemented\n",i);
+				continue;
+			}
+			if (bar & PCI_BASE_ADDRESS_SPACE_IO) {
+			/* This is IO */
+
+			len = bar & (PCI_BASE_ADDRESS_IO_MASK & 0xFFFF);
+			len = len & ~(len - 1);
+
+			printk("IO space:  len in IO %x, BAR %d\n", len, i);
+			}
+			else
+			{
+				len = bar & 0xFFFFFFF0;
+				len = ~len + 1;
+
+				printk("len in MEM %x, BAR %d\n", len, i);
+			}
+		}
+	}
+#endif
+
+
+#endif
+
+#ifdef	DEBUG
+	//return  0  ;
+#endif
+    pDevice->PortOffset = (DWORD)ioremap(pDevice->memaddr & PCI_BASE_ADDRESS_MEM_MASK, pDevice->io_size);
+	//pDevice->PortOffset = (DWORD)ioremap(pDevice->ioaddr & PCI_BASE_ADDRESS_IO_MASK, pDevice->io_size);
+
+	if(pDevice->PortOffset == 0) {
+       printk(KERN_ERR DEVICE_NAME ": Failed to IO remapping ..\n");
+       device_free_info(pDevice);
+        return -ENODEV;
+    }
+
+
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    rc = pci_request_regions(pcid, DEVICE_NAME);
+    if (rc) {
+        printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device\n");
+        device_free_info(pDevice);
+        return -ENODEV;
+    }
+#else
+    if (check_region(pDevice->ioaddr, pDevice->io_size)) {
+        printk(KERN_ERR DEVICE_NAME ": Failed to find PCI device\n");
+        device_free_info(pDevice);
+        return -ENODEV;
+    }
+    request_region(pDevice->ioaddr, pDevice->io_size, DEVICE_NAME);
+#endif
+
+    dev->base_addr = pDevice->ioaddr;
+#ifdef	PLICE_DEBUG
+	BYTE	value;
+
+	VNSvInPortB(pDevice->PortOffset+0x4F, &value);
+	printk("Before write: value is %x\n",value);
+	//VNSvInPortB(pDevice->PortOffset+0x3F, 0x00);
+	VNSvOutPortB(pDevice->PortOffset,value);
+	VNSvInPortB(pDevice->PortOffset+0x4F, &value);
+	printk("After write: value is %x\n",value);
+#endif
+
+
+
+#ifdef IO_MAP
+    pDevice->PortOffset = pDevice->ioaddr;
+#endif
+    // do reset
+    if (!MACbSoftwareReset(pDevice->PortOffset)) {
+        printk(KERN_ERR DEVICE_NAME ": Failed to access MAC hardware..\n");
+        device_free_info(pDevice);
+        return -ENODEV;
+    }
+    // initial to reload eeprom
+    MACvInitialize(pDevice->PortOffset);
+    MACvReadEtherAddress(pDevice->PortOffset, dev->dev_addr);
+
+    device_get_options(pDevice, device_nics-1, dev->name);
+    device_set_options(pDevice);
+    //Mask out the options cannot be set to the chip
+    pDevice->sOpts.flags &= pChip_info->flags;
+
+    //Enable the chip specified capbilities
+    pDevice->flags = pDevice->sOpts.flags | (pChip_info->flags & 0xFF000000UL);
+    pDevice->tx_80211 = device_dma0_tx_80211;
+    pDevice->sMgmtObj.pAdapter = (PVOID)pDevice;
+    pDevice->pMgmt = &(pDevice->sMgmtObj);
+
+    dev->irq                = pcid->irq;
+    dev->open               = device_open;
+    dev->hard_start_xmit    = device_xmit;
+    dev->stop               = device_close;
+    dev->get_stats          = device_get_stats;
+    dev->set_multicast_list = device_set_multi;
+    dev->do_ioctl           = device_ioctl;
+
+#ifdef WIRELESS_EXT
+//Einsn Modify for ubuntu-7.04
+//	dev->wireless_handlers->get_wireless_stats = iwctl_get_wireless_stats;
+#if WIRELESS_EXT > 12
+	dev->wireless_handlers = (struct iw_handler_def *)&iwctl_handler_def;
+//	netdev->wireless_handlers = NULL;
+#endif /* WIRELESS_EXT > 12 */
+#endif /* WIRELESS_EXT */
+
+ //  #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+  //  memcpy(pDevice->dev->dev_addr, fake_mac, U_ETHER_ADDR_LEN); //use fake mac address
+ //  #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    rc = register_netdev(dev);
+    if (rc)
+    {
+        printk(KERN_ERR DEVICE_NAME " Failed to register netdev\n");
+        device_free_info(pDevice);
+        return -ENODEV;
+    }
+#endif
+//2008-07-21-01<Add>by MikeLiu
+//register wpadev
+   if(wpa_set_wpadev(pDevice, 1)!=0) {
+     printk("Fail to Register WPADEV?\n");
+        unregister_netdev(pDevice->dev);
+        free_netdev(dev);
+        kfree(pDevice);
+   }
+    device_print_info(pDevice);
+    pci_set_drvdata(pcid, pDevice);
+    return 0;
+
+}
+
+static void device_print_info(PSDevice pDevice)
+{
+    struct net_device* dev=pDevice->dev;
+
+    DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: %s\n",dev->name, get_chip_name(pDevice->chip_id));
+    DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: MAC=%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
+        dev->name,
+        dev->dev_addr[0],dev->dev_addr[1],dev->dev_addr[2],
+        dev->dev_addr[3],dev->dev_addr[4],dev->dev_addr[5]);
+#ifdef IO_MAP
+    DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx  ",(ULONG) pDevice->ioaddr);
+    DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);
+#else
+    DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx Mem=0x%lx ",(ULONG) pDevice->ioaddr,(ULONG) pDevice->PortOffset);
+    DEVICE_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);
+#endif
+
+}
+
+static BOOL device_init_info(struct pci_dev* pcid, PSDevice* ppDevice,
+    PCHIP_INFO pChip_info) {
+
+    PSDevice p;
+
+    *ppDevice = kmalloc(sizeof(DEVICE_INFO),GFP_ATOMIC);
+
+    if (*ppDevice == NULL)
+        return FALSE;
+
+    memset(*ppDevice,0,sizeof(DEVICE_INFO));
+
+    if (pDevice_Infos == NULL) {
+        pDevice_Infos =*ppDevice;
+    }
+    else {
+        for (p=pDevice_Infos;p->next!=NULL;p=p->next)
+            do {} while (0);
+        p->next = *ppDevice;
+        (*ppDevice)->prev = p;
+    }
+
+    (*ppDevice)->pcid = pcid;
+    (*ppDevice)->chip_id = pChip_info->chip_id;
+    (*ppDevice)->io_size = pChip_info->io_size;
+    (*ppDevice)->nTxQueues = pChip_info->nTxQueue;
+    (*ppDevice)->multicast_limit =32;
+
+    spin_lock_init(&((*ppDevice)->lock));
+
+    return TRUE;
+}
+
+static BOOL device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {
+
+    U16 pci_cmd;
+    U8  b;
+    UINT cis_addr;
+#ifdef	PLICE_DEBUG
+	BYTE       pci_config[256];
+	BYTE	value =0x00;
+	int		ii,j;
+	U16	max_lat=0x0000;
+	memset(pci_config,0x00,256);
+#endif
+
+    pci_read_config_byte(pcid, PCI_REVISION_ID, &pDevice->byRevId);
+    pci_read_config_word(pcid, PCI_SUBSYSTEM_ID,&pDevice->SubSystemID);
+    pci_read_config_word(pcid, PCI_SUBSYSTEM_VENDOR_ID, &pDevice->SubVendorID);
+    pci_read_config_word(pcid, PCI_COMMAND, (u16 *) & (pci_cmd));
+
+    pci_set_master(pcid);
+
+    pDevice->memaddr = pci_resource_start(pcid,0);
+    pDevice->ioaddr = pci_resource_start(pcid,1);
+
+#ifdef	DEBUG
+//	pDevice->ioaddr = pci_resource_start(pcid, 0);
+//	pDevice->memaddr = pci_resource_start(pcid,1);
+#endif
+
+    cis_addr = pci_resource_start(pcid,2);
+
+    pDevice->pcid = pcid;
+
+    pci_read_config_byte(pcid, PCI_REG_COMMAND, &b);
+    pci_write_config_byte(pcid, PCI_REG_COMMAND, (b|COMMAND_BUSM));
+
+#ifdef	PLICE_DEBUG
+   	//pci_read_config_word(pcid,PCI_REG_MAX_LAT,&max_lat);
+	//printk("max lat is %x,SubSystemID is %x\n",max_lat,pDevice->SubSystemID);
+	//for (ii=0;ii<0xFF;ii++)
+	//pci_read_config_word(pcid,PCI_REG_MAX_LAT,&max_lat);
+	//max_lat  = 0x20;
+	//pci_write_config_word(pcid,PCI_REG_MAX_LAT,max_lat);
+	//pci_read_config_word(pcid,PCI_REG_MAX_LAT,&max_lat);
+	//printk("max lat is %x\n",max_lat);
+
+	for (ii=0;ii<0xFF;ii++)
+	{
+		pci_read_config_byte(pcid,ii,&value);
+		pci_config[ii] = value;
+	}
+	for (ii=0,j=1;ii<0x100;ii++,j++)
+	{
+		if (j %16 == 0)
+		{
+			printk("%x:",pci_config[ii]);
+			printk("\n");
+		}
+		else
+		{
+			printk("%x:",pci_config[ii]);
+		}
+	}
+#endif
+    return TRUE;
+}
+
+static void device_free_info(PSDevice pDevice) {
+    PSDevice         ptr;
+    struct net_device*  dev=pDevice->dev;
+
+    ASSERT(pDevice);
+//2008-0714-01<Add>by chester
+device_release_WPADEV(pDevice);
+
+//2008-07-21-01<Add>by MikeLiu
+//unregister wpadev
+   if(wpa_set_wpadev(pDevice, 0)!=0)
+     printk("unregister wpadev fail?\n");
+
+    if (pDevice_Infos==NULL)
+        return;
+
+    for (ptr=pDevice_Infos;ptr && (ptr!=pDevice);ptr=ptr->next)
+            do {} while (0);
+
+    if (ptr==pDevice) {
+        if (ptr==pDevice_Infos)
+            pDevice_Infos=ptr->next;
+        else
+            ptr->prev->next=ptr->next;
+    }
+    else {
+        DEVICE_PRT(MSG_LEVEL_ERR, KERN_ERR "info struct not found\n");
+        return;
+    }
+#ifdef HOSTAP
+    if (dev)
+        hostap_set_hostapd(pDevice, 0, 0);
+#endif
+    if (dev)
+        unregister_netdev(dev);
+
+    if (pDevice->PortOffset)
+        iounmap((PVOID)pDevice->PortOffset);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    if (pDevice->pcid)
+        pci_release_regions(pDevice->pcid);
+    if (dev)
+        free_netdev(dev);
+#else
+    if (pDevice->ioaddr)
+        release_region(pDevice->ioaddr,pDevice->io_size);
+    if (dev)
+        kfree(dev);
+#endif
+
+    if (pDevice->pcid) {
+        pci_set_drvdata(pDevice->pcid,NULL);
+    }
+    kfree(pDevice);
+
+}
+#endif// ifndef PRIVATE_OBJ
+
+static BOOL device_init_rings(PSDevice pDevice) {
+    void*   vir_pool;
+
+
+    /*allocate all RD/TD rings a single pool*/
+    vir_pool = pci_alloc_consistent(pDevice->pcid,
+                    pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
+                    pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
+                    pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
+                    pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
+                    &pDevice->pool_dma);
+
+    if (vir_pool == NULL) {
+        DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : allocate desc dma memory failed\n", pDevice->dev->name);
+        return FALSE;
+    }
+
+    memset(vir_pool, 0,
+            pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
+            pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
+            pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
+            pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc)
+          );
+
+    pDevice->aRD0Ring = vir_pool;
+    pDevice->aRD1Ring = vir_pool +
+                        pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
+
+
+    pDevice->rd0_pool_dma = pDevice->pool_dma;
+    pDevice->rd1_pool_dma = pDevice->rd0_pool_dma +
+                            pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);
+
+    pDevice->tx0_bufs = pci_alloc_consistent(pDevice->pcid,
+                    pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
+                    pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
+                    CB_BEACON_BUF_SIZE +
+                    CB_MAX_BUF_SIZE,
+                    &pDevice->tx_bufs_dma0);
+
+    if (pDevice->tx0_bufs == NULL) {
+        DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: allocate buf dma memory failed\n", pDevice->dev->name);
+        pci_free_consistent(pDevice->pcid,
+            pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
+            pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
+            pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
+            pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),
+            vir_pool, pDevice->pool_dma
+            );
+        return FALSE;
+    }
+
+    memset(pDevice->tx0_bufs, 0,
+           pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
+           pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
+           CB_BEACON_BUF_SIZE +
+           CB_MAX_BUF_SIZE
+          );
+
+    pDevice->td0_pool_dma = pDevice->rd1_pool_dma +
+            pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);
+
+    pDevice->td1_pool_dma = pDevice->td0_pool_dma +
+            pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);
+
+
+    // vir_pool: pvoid type
+    pDevice->apTD0Rings = vir_pool
+                          + pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)
+                          + pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);
+
+    pDevice->apTD1Rings = vir_pool
+            + pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)
+            + pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc)
+            + pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);
+
+
+    pDevice->tx1_bufs = pDevice->tx0_bufs +
+            pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;
+
+
+    pDevice->tx_beacon_bufs = pDevice->tx1_bufs +
+            pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;
+
+    pDevice->pbyTmpBuff = pDevice->tx_beacon_bufs +
+            CB_BEACON_BUF_SIZE;
+
+    pDevice->tx_bufs_dma1 = pDevice->tx_bufs_dma0 +
+            pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;
+
+
+    pDevice->tx_beacon_dma = pDevice->tx_bufs_dma1 +
+            pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;
+
+
+    return TRUE;
+}
+
+static void device_free_rings(PSDevice pDevice) {
+
+    pci_free_consistent(pDevice->pcid,
+            pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +
+            pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +
+            pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +
+            pDevice->sOpts.nTxDescs[1] * sizeof(STxDesc)
+            ,
+            pDevice->aRD0Ring, pDevice->pool_dma
+        );
+
+    if (pDevice->tx0_bufs)
+        pci_free_consistent(pDevice->pcid,
+           pDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +
+           pDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +
+           CB_BEACON_BUF_SIZE +
+           CB_MAX_BUF_SIZE,
+           pDevice->tx0_bufs, pDevice->tx_bufs_dma0
+        );
+}
+
+static void device_init_rd0_ring(PSDevice pDevice) {
+    int i;
+    dma_addr_t      curr = pDevice->rd0_pool_dma;
+    PSRxDesc        pDesc;
+
+    /* Init the RD0 ring entries */
+    for (i = 0; i < pDevice->sOpts.nRxDescs0; i ++, curr += sizeof(SRxDesc)) {
+        pDesc = &(pDevice->aRD0Ring[i]);
+        pDesc->pRDInfo = alloc_rd_info();
+        ASSERT(pDesc->pRDInfo);
+        if (!device_alloc_rx_buf(pDevice, pDesc)) {
+            DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc rx bufs\n",
+            pDevice->dev->name);
+        }
+        pDesc->next = &(pDevice->aRD0Ring[(i+1) % pDevice->sOpts.nRxDescs0]);
+        pDesc->pRDInfo->curr_desc = cpu_to_le32(curr);
+        pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
+    }
+
+    pDevice->aRD0Ring[i-1].next_desc = cpu_to_le32(pDevice->rd0_pool_dma);
+    pDevice->pCurrRD[0] = &(pDevice->aRD0Ring[0]);
+}
+
+
+static void device_init_rd1_ring(PSDevice pDevice) {
+    int i;
+    dma_addr_t      curr = pDevice->rd1_pool_dma;
+    PSRxDesc        pDesc;
+
+    /* Init the RD1 ring entries */
+    for (i = 0; i < pDevice->sOpts.nRxDescs1; i ++, curr += sizeof(SRxDesc)) {
+        pDesc = &(pDevice->aRD1Ring[i]);
+        pDesc->pRDInfo = alloc_rd_info();
+        ASSERT(pDesc->pRDInfo);
+        if (!device_alloc_rx_buf(pDevice, pDesc)) {
+            DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc rx bufs\n",
+            pDevice->dev->name);
+        }
+        pDesc->next = &(pDevice->aRD1Ring[(i+1) % pDevice->sOpts.nRxDescs1]);
+        pDesc->pRDInfo->curr_desc = cpu_to_le32(curr);
+        pDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));
+    }
+
+    pDevice->aRD1Ring[i-1].next_desc = cpu_to_le32(pDevice->rd1_pool_dma);
+    pDevice->pCurrRD[1] = &(pDevice->aRD1Ring[0]);
+}
+
+
+static void device_init_defrag_cb(PSDevice pDevice) {
+    int i;
+    PSDeFragControlBlock pDeF;
+
+    /* Init the fragment ctl entries */
+    for (i = 0; i < CB_MAX_RX_FRAG; i++) {
+        pDeF = &(pDevice->sRxDFCB[i]);
+        if (!device_alloc_frag_buf(pDevice, pDeF)) {
+            DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc frag bufs\n",
+                pDevice->dev->name);
+        };
+    }
+    pDevice->cbDFCB = CB_MAX_RX_FRAG;
+    pDevice->cbFreeDFCB = pDevice->cbDFCB;
+}
+
+
+
+
+static void device_free_rd0_ring(PSDevice pDevice) {
+    int i;
+
+    for (i = 0; i < pDevice->sOpts.nRxDescs0; i++) {
+        PSRxDesc        pDesc =&(pDevice->aRD0Ring[i]);
+        PDEVICE_RD_INFO  pRDInfo =pDesc->pRDInfo;
+
+        pci_unmap_single(pDevice->pcid,pRDInfo->skb_dma,
+           pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
+
+        dev_kfree_skb(pRDInfo->skb);
+
+        kfree((PVOID)pDesc->pRDInfo);
+    }
+
+}
+
+static void device_free_rd1_ring(PSDevice pDevice) {
+    int i;
+
+
+    for (i = 0; i < pDevice->sOpts.nRxDescs1; i++) {
+        PSRxDesc        pDesc=&(pDevice->aRD1Ring[i]);
+        PDEVICE_RD_INFO  pRDInfo=pDesc->pRDInfo;
+
+        pci_unmap_single(pDevice->pcid,pRDInfo->skb_dma,
+           pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
+
+        dev_kfree_skb(pRDInfo->skb);
+
+        kfree((PVOID)pDesc->pRDInfo);
+    }
+
+}
+
+static void device_free_frag_buf(PSDevice pDevice) {
+    PSDeFragControlBlock pDeF;
+    int i;
+
+    for (i = 0; i < CB_MAX_RX_FRAG; i++) {
+
+        pDeF = &(pDevice->sRxDFCB[i]);
+
+        if (pDeF->skb)
+            dev_kfree_skb(pDeF->skb);
+
+    }
+
+}
+
+static void device_init_td0_ring(PSDevice pDevice) {
+    int i;
+    dma_addr_t  curr;
+    PSTxDesc        pDesc;
+
+    curr = pDevice->td0_pool_dma;
+    for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++, curr += sizeof(STxDesc)) {
+        pDesc = &(pDevice->apTD0Rings[i]);
+        pDesc->pTDInfo = alloc_td_info();
+        ASSERT(pDesc->pTDInfo);
+        if (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {
+            pDesc->pTDInfo->buf = pDevice->tx0_bufs + (i)*PKT_BUF_SZ;
+            pDesc->pTDInfo->buf_dma = pDevice->tx_bufs_dma0 + (i)*PKT_BUF_SZ;
+        }
+        pDesc->next =&(pDevice->apTD0Rings[(i+1) % pDevice->sOpts.nTxDescs[0]]);
+        pDesc->pTDInfo->curr_desc = cpu_to_le32(curr);
+        pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
+    }
+
+    pDevice->apTD0Rings[i-1].next_desc = cpu_to_le32(pDevice->td0_pool_dma);
+    pDevice->apTailTD[0] = pDevice->apCurrTD[0] =&(pDevice->apTD0Rings[0]);
+
+}
+
+static void device_init_td1_ring(PSDevice pDevice) {
+    int i;
+    dma_addr_t  curr;
+    PSTxDesc    pDesc;
+
+    /* Init the TD ring entries */
+    curr=pDevice->td1_pool_dma;
+    for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++, curr+=sizeof(STxDesc)) {
+        pDesc=&(pDevice->apTD1Rings[i]);
+        pDesc->pTDInfo = alloc_td_info();
+        ASSERT(pDesc->pTDInfo);
+        if (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {
+            pDesc->pTDInfo->buf=pDevice->tx1_bufs+(i)*PKT_BUF_SZ;
+            pDesc->pTDInfo->buf_dma=pDevice->tx_bufs_dma1+(i)*PKT_BUF_SZ;
+        }
+        pDesc->next=&(pDevice->apTD1Rings[(i+1) % pDevice->sOpts.nTxDescs[1]]);
+        pDesc->pTDInfo->curr_desc = cpu_to_le32(curr);
+        pDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));
+    }
+
+    pDevice->apTD1Rings[i-1].next_desc = cpu_to_le32(pDevice->td1_pool_dma);
+    pDevice->apTailTD[1] = pDevice->apCurrTD[1] = &(pDevice->apTD1Rings[0]);
+}
+
+
+
+static void device_free_td0_ring(PSDevice pDevice) {
+    int i;
+    for (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++) {
+        PSTxDesc        pDesc=&(pDevice->apTD0Rings[i]);
+        PDEVICE_TD_INFO  pTDInfo=pDesc->pTDInfo;
+
+        if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma))
+            pci_unmap_single(pDevice->pcid,pTDInfo->skb_dma,
+               pTDInfo->skb->len, PCI_DMA_TODEVICE);
+
+        if (pTDInfo->skb)
+            dev_kfree_skb(pTDInfo->skb);
+
+        kfree((PVOID)pDesc->pTDInfo);
+    }
+}
+
+static void device_free_td1_ring(PSDevice pDevice) {
+    int i;
+
+    for (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++) {
+        PSTxDesc        pDesc=&(pDevice->apTD1Rings[i]);
+        PDEVICE_TD_INFO  pTDInfo=pDesc->pTDInfo;
+
+        if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma))
+            pci_unmap_single(pDevice->pcid, pTDInfo->skb_dma,
+               pTDInfo->skb->len, PCI_DMA_TODEVICE);
+
+        if (pTDInfo->skb)
+            dev_kfree_skb(pTDInfo->skb);
+
+        kfree((PVOID)pDesc->pTDInfo);
+    }
+
+}
+
+
+
+/*-----------------------------------------------------------------*/
+
+static int device_rx_srv(PSDevice pDevice, UINT uIdx) {
+    PSRxDesc    pRD;
+    int works = 0;
+
+
+    for (pRD = pDevice->pCurrRD[uIdx];
+         pRD->m_rd0RD0.f1Owner == OWNED_BY_HOST;
+         pRD = pRD->next) {
+//        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->pCurrRD = %x, works = %d\n", pRD, works);
+        if (works++>15)
+            break;
+        if (device_receive_frame(pDevice, pRD)) {
+            if (!device_alloc_rx_buf(pDevice,pRD)) {
+                    DEVICE_PRT(MSG_LEVEL_ERR, KERN_ERR
+                    "%s: can not allocate rx buf\n", pDevice->dev->name);
+                    break;
+            }
+        }
+        pRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;
+#ifdef PRIVATE_OBJ
+        ref_set_rx_jiffies(pDevice->dev);
+#else
+        pDevice->dev->last_rx = jiffies;
+#endif
+    }
+
+    pDevice->pCurrRD[uIdx]=pRD;
+
+    return works;
+}
+
+
+static BOOL device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {
+
+    PDEVICE_RD_INFO pRDInfo=pRD->pRDInfo;
+
+#ifdef PRIVATE_OBJ
+
+    pRDInfo->skb=dev_alloc_skb(pDevice->rx_buf_sz);
+    if (pRDInfo->skb==NULL)
+        return FALSE;
+    ref_skb_remap(pDevice->dev, &(pRDInfo->ref_skb), pRDInfo->skb);
+    pRDInfo->skb_dma = pci_map_single(pDevice->pcid, pRDInfo->ref_skb.tail, pDevice->rx_buf_sz,
+                        PCI_DMA_FROMDEVICE);
+#else
+
+    pRDInfo->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
+#ifdef	PLICE_DEBUG
+	//printk("device_alloc_rx_buf:skb is %x\n",pRDInfo->skb);
+#endif
+    if (pRDInfo->skb==NULL)
+        return FALSE;
+    ASSERT(pRDInfo->skb);
+    pRDInfo->skb->dev = pDevice->dev;
+    pRDInfo->skb_dma = pci_map_single(pDevice->pcid, pRDInfo->skb->tail, pDevice->rx_buf_sz,
+                        PCI_DMA_FROMDEVICE);
+#endif
+    *((PU32) &(pRD->m_rd0RD0)) = 0;
+
+    pRD->m_rd0RD0.wResCount = cpu_to_le16(pDevice->rx_buf_sz);
+    pRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;
+    pRD->m_rd1RD1.wReqCount = cpu_to_le16(pDevice->rx_buf_sz);
+    pRD->buff_addr = cpu_to_le32(pRDInfo->skb_dma);
+
+    return TRUE;
+}
+
+
+
+BOOL device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
+
+#ifdef PRIVATE_OBJ
+
+    pDeF->skb=dev_alloc_skb(pDevice->rx_buf_sz);
+    if (pDeF->skb==NULL)
+        return FALSE;
+    ref_skb_remap(pDevice->dev, &(pDeF->ref_skb), pDeF->skb);
+
+#else
+    pDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
+    if (pDeF->skb == NULL)
+        return FALSE;
+    ASSERT(pDeF->skb);
+    pDeF->skb->dev = pDevice->dev;
+#endif
+
+    return TRUE;
+}
+
+
+
+static int device_tx_srv(PSDevice pDevice, UINT uIdx) {
+    PSTxDesc                 pTD;
+    BOOL                     bFull=FALSE;
+    int                      works = 0;
+    BYTE                     byTsr0;
+    BYTE                     byTsr1;
+    UINT                     uFrameSize, uFIFOHeaderSize;
+    PSTxBufHead              pTxBufHead;
+    struct net_device_stats* pStats = &pDevice->stats;
+    struct sk_buff*          skb;
+    UINT                     uNodeIndex;
+    PSMgmtObject             pMgmt = pDevice->pMgmt;
+#ifdef PRIVATE_OBJ
+    ref_sk_buff              ref_skb;
+#endif
+
+
+    for (pTD = pDevice->apTailTD[uIdx]; pDevice->iTDUsed[uIdx] >0; pTD = pTD->next) {
+
+        if (pTD->m_td0TD0.f1Owner == OWNED_BY_NIC)
+            break;
+        if (works++>15)
+            break;
+
+        byTsr0 = pTD->m_td0TD0.byTSR0;
+        byTsr1 = pTD->m_td0TD0.byTSR1;
+
+        //Only the status of first TD in the chain is correct
+        if (pTD->m_td1TD1.byTCR & TCR_STP) {
+
+            if ((pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0) {
+                uFIFOHeaderSize = pTD->pTDInfo->dwHeaderLength;
+                uFrameSize = pTD->pTDInfo->dwReqCount - uFIFOHeaderSize;
+                pTxBufHead = (PSTxBufHead) (pTD->pTDInfo->buf);
+#ifdef PRIVATE_OBJ
+                ref_skb_remap(pDevice->dev, &ref_skb, pTD->pTDInfo->skb);
+#endif
+                // Update the statistics based on the Transmit status
+                // now, we DO'NT check TSR0_CDH
+
+                STAvUpdateTDStatCounter(&pDevice->scStatistic,
+                        byTsr0, byTsr1,
+                        (PBYTE)(pTD->pTDInfo->buf + uFIFOHeaderSize),
+                        uFrameSize, uIdx);
+
+
+                BSSvUpdateNodeTxCounter(pDevice,
+                         byTsr0, byTsr1,
+                         (PBYTE)(pTD->pTDInfo->buf),
+                         uFIFOHeaderSize
+                         );
+
+                if (BITbIsBitOff(byTsr1, TSR1_TERR)) {
+                    if (byTsr0 != 0) {
+                        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X].\n",
+                           (INT)uIdx, byTsr1, byTsr0);
+                    }
+                    if ((pTxBufHead->wFragCtl & FRAGCTL_ENDFRAG) != FRAGCTL_NONFRAG) {
+                        pDevice->s802_11Counter.TransmittedFragmentCount ++;
+                    }
+                    pStats->tx_packets++;
+#ifdef PRIVATE_OBJ
+                    pStats->tx_bytes += *(ref_skb.len);
+#else
+                    pStats->tx_bytes += pTD->pTDInfo->skb->len;
+#endif
+                }
+                else {
+                     DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] dropped & tsr1[%02X] tsr0[%02X].\n",
+                           (INT)uIdx, byTsr1, byTsr0);
+                    pStats->tx_errors++;
+                    pStats->tx_dropped++;
+                }
+            }
+
+            if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
+                if (pDevice->bEnableHostapd) {
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx call back netif.. \n");
+#ifdef PRIVATE_OBJ
+                    ref_skb_remap(pDevice->apdev, &(ref_skb), pTD->pTDInfo->skb);
+	                ref_skb.mac.raw = ref_skb.data;
+	                *(ref_skb.pkt_type) = PACKET_OTHERHOST;
+    	            //*(ref_skb.protocol) = htons(ETH_P_802_2);
+	                memset(ref_skb.cb, 0, sizeof(ref_skb.cb));
+	                netif_rx(ref_skb.skb);
+#else
+                    skb = pTD->pTDInfo->skb;
+	                skb->dev = pDevice->apdev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+			skb->mac_header = skb->data;
+#else
+			skb->mac.raw = skb->data;
+#endif
+	                skb->pkt_type = PACKET_OTHERHOST;
+    	            //skb->protocol = htons(ETH_P_802_2);
+	                memset(skb->cb, 0, sizeof(skb->cb));
+	                netif_rx(skb);
+#endif
+	            }
+            }
+
+            if (BITbIsBitOn(byTsr1, TSR1_TERR)) {
+            if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
+                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
+                          (INT)uIdx, byTsr1, byTsr0);
+            }
+
+//                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
+//                          (INT)uIdx, byTsr1, byTsr0);
+
+                if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) &&
+                    (pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)) {
+                    WORD    wAID;
+                    BYTE    byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
+
+                    skb = pTD->pTDInfo->skb;
+                    if (BSSDBbIsSTAInNodeDB(pMgmt, (PBYTE)(skb->data), &uNodeIndex)) {
+                        if (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {
+                            skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);
+                            pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;
+                            // set tx map
+                            wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
+                            pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
+                            pTD->pTDInfo->byFlags &= ~(TD_FLAGS_NETIF_SKB);
+                            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx_srv:tx fail re-queue sta index= %d, QueCnt= %d\n"
+                                    ,(INT)uNodeIndex, pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt);
+                            pStats->tx_errors--;
+                            pStats->tx_dropped--;
+                        }
+                    }
+                }
+            }
+            device_free_tx_buf(pDevice,pTD);
+            pDevice->iTDUsed[uIdx]--;
+        }
+    }
+
+
+    if (uIdx == TYPE_AC0DMA) {
+        // RESERV_AC0DMA reserved for relay
+
+        if (AVAIL_TD(pDevice, uIdx) < RESERV_AC0DMA) {
+            bFull = TRUE;
+            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " AC0DMA is Full = %d\n", pDevice->iTDUsed[uIdx]);
+        }
+        if (netif_queue_stopped(pDevice->dev) && (bFull==FALSE)){
+            netif_wake_queue(pDevice->dev);
+        }
+    }
+
+
+    pDevice->apTailTD[uIdx] = pTD;
+
+    return works;
+}
+
+
+static void device_error(PSDevice pDevice, WORD status) {
+
+    if (status & ISR_FETALERR) {
+        DEVICE_PRT(MSG_LEVEL_ERR, KERN_ERR
+            "%s: Hardware fatal error.\n",
+            pDevice->dev->name);
+        netif_stop_queue(pDevice->dev);
+        del_timer(&pDevice->sTimerCommand);
+        del_timer(&(pDevice->pMgmt->sTimerSecondCallback));
+        pDevice->bCmdRunning = FALSE;
+        MACbShutdown(pDevice->PortOffset);
+        return;
+    }
+
+}
+
+static void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc) {
+    PDEVICE_TD_INFO  pTDInfo=pDesc->pTDInfo;
+    struct sk_buff* skb=pTDInfo->skb;
+
+    // pre-allocated buf_dma can't be unmapped.
+    if (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma)) {
+        pci_unmap_single(pDevice->pcid,pTDInfo->skb_dma,skb->len,
+              PCI_DMA_TODEVICE);
+    }
+
+    if ((pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0)
+        dev_kfree_skb_irq(skb);
+
+    pTDInfo->skb_dma = 0;
+    pTDInfo->skb = 0;
+    pTDInfo->byFlags = 0;
+}
+
+
+
+//PLICE_DEBUG ->
+VOID	InitRxManagementQueue(PSDevice  pDevice)
+{
+	pDevice->rxManeQueue.packet_num = 0;
+	pDevice->rxManeQueue.head = pDevice->rxManeQueue.tail = 0;
+}
+//PLICE_DEBUG<-
+
+
+
+
+
+//PLICE_DEBUG ->
+INT MlmeThread(
+     void * Context)
+{
+	PSDevice	pDevice =  (PSDevice) Context;
+	PSRxMgmtPacket			pRxMgmtPacket;
+	// int i ;
+	//complete(&pDevice->notify);
+//printk("Enter MngWorkItem,Queue packet num is %d\n",pDevice->rxManeQueue.packet_num);
+
+	//printk("Enter MlmeThread,packet _num is %d\n",pDevice->rxManeQueue.packet_num);
+	//i = 0;
+#if 1
+	while (1)
+	{
+
+	//printk("DDDD\n");
+	//down(&pDevice->mlme_semaphore);
+        // pRxMgmtPacket =  DeQueue(pDevice);
+#if 1
+		spin_lock_irq(&pDevice->lock);
+		 while(pDevice->rxManeQueue.packet_num != 0)
+	 	{
+			 pRxMgmtPacket =  DeQueue(pDevice);
+        			//pDevice;
+        			//DequeueManageObject(pDevice->FirstRecvMngList, pDevice->LastRecvMngList);
+			vMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);
+			//printk("packet_num is %d\n",pDevice->rxManeQueue.packet_num);
+
+		 }
+		spin_unlock_irq(&pDevice->lock);
+		if (mlme_kill == 0)
+		break;
+		//udelay(200);
+#endif
+	//printk("Before schedule thread jiffies is %x\n",jiffies);
+	schedule();
+	//printk("after schedule thread jiffies is %x\n",jiffies);
+	if (mlme_kill == 0)
+		break;
+	//printk("i is %d\n",i);
+	}
+
+#endif
+	return 0;
+
+}
+
+
+#ifdef PRIVATE_OBJ
+
+int __device_open(HANDLE pExDevice) {
+    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
+    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
+
+#else
+
+static int  device_open(struct net_device *dev) {
+    PSDevice    pDevice=(PSDevice) dev->priv;
+    int i;
+#endif
+    pDevice->rx_buf_sz = PKT_BUF_SZ;
+    if (!device_init_rings(pDevice)) {
+        return -ENOMEM;
+    }
+//2008-5-13 <add> by chester
+#ifndef PRIVATE_OBJ
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+    i=request_irq(pDevice->pcid->irq, &device_intr, IRQF_SHARED, dev->name, dev);
+#else
+    i=request_irq(pDevice->pcid->irq, &device_intr, (unsigned long)SA_SHIRQ, dev->name, dev);
+#endif
+    if (i)
+        return i;
+#endif
+	//printk("DEBUG1\n");
+#ifdef WPA_SM_Transtatus
+     extern SWPAResult wpa_Result;
+     memset(wpa_Result.ifname,0,sizeof(wpa_Result.ifname));
+     wpa_Result.proto = 0;
+     wpa_Result.key_mgmt = 0;
+     wpa_Result.eap_type = 0;
+     wpa_Result.authenticated = FALSE;
+     pDevice->fWPA_Authened = FALSE;
+#endif
+DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device init rd0 ring\n");
+device_init_rd0_ring(pDevice);
+    device_init_rd1_ring(pDevice);
+    device_init_defrag_cb(pDevice);
+    device_init_td0_ring(pDevice);
+    device_init_td1_ring(pDevice);
+//    VNTWIFIvSet11h(pDevice->pMgmt, pDevice->b11hEnable);
+
+
+    if (pDevice->bDiversityRegCtlON) {
+        device_init_diversity_timer(pDevice);
+    }
+    vMgrObjectInit(pDevice);
+    vMgrTimerInit(pDevice);
+
+//PLICE_DEBUG->
+#ifdef	TASK_LET
+	tasklet_init (&pDevice->RxMngWorkItem,(void *)MngWorkItem,(unsigned long )pDevice);
+#endif
+#ifdef	THREAD
+	InitRxManagementQueue(pDevice);
+	mlme_kill = 0;
+	mlme_task = kthread_run(MlmeThread,(void *) pDevice, "MLME");
+	if (IS_ERR(mlme_task)) {
+		printk("thread create fail\n");
+		return -1;
+	}
+
+	mlme_kill = 1;
+#endif
+
+
+
+#if 0
+	pDevice->MLMEThr_pid = kernel_thread(MlmeThread, pDevice, CLONE_VM);
+	if (pDevice->MLMEThr_pid <0 )
+	{
+		printk("unable start thread MlmeThread\n");
+		return -1;
+	}
+#endif
+
+	//printk("thread id is %d\n",pDevice->MLMEThr_pid);
+	//printk("Create thread time is %x\n",jiffies);
+	//wait_for_completion(&pDevice->notify);
+
+
+
+
+  // if (( SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RADIOCTL)&0x06)==0x04)
+    //    return -ENOMEM;
+DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");
+	device_init_registers(pDevice, DEVICE_INIT_COLD);
+    MACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);
+    memcpy(pDevice->pMgmt->abyMACAddr, pDevice->abyCurrentNetAddr, U_ETHER_ADDR_LEN);
+#ifdef PRIVATE_OBJ
+    __device_set_multi(pExDevice);
+#else
+    device_set_multi(pDevice->dev);
+#endif
+
+    // Init for Key Management
+    KeyvInitTable(&pDevice->sKey, pDevice->PortOffset);
+    add_timer(&(pDevice->pMgmt->sTimerSecondCallback));
+
+	#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+	/*
+     pDevice->bwextstep0 = FALSE;
+     pDevice->bwextstep1 = FALSE;
+     pDevice->bwextstep2 = FALSE;
+     pDevice->bwextstep3 = FALSE;
+     */
+       pDevice->bwextcount=0;
+     pDevice->bWPASuppWextEnabled = FALSE;
+#endif
+    pDevice->byReAssocCount = 0;
+   pDevice->bWPADEVUp = FALSE;
+    // Patch: if WEP key already set by iwconfig but device not yet open
+    if ((pDevice->bEncryptionEnable == TRUE) && (pDevice->bTransmitKey == TRUE)) {
+        KeybSetDefaultKey(&(pDevice->sKey),
+                            (DWORD)(pDevice->byKeyIndex | (1 << 31)),
+                            pDevice->uKeyLength,
+                            NULL,
+                            pDevice->abyKey,
+                            KEY_CTL_WEP,
+                            pDevice->PortOffset,
+                            pDevice->byLocalID
+                          );
+         pDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;
+    }
+
+//printk("DEBUG2\n");
+
+
+DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call MACvIntEnable\n");
+	MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
+
+    if (pDevice->pMgmt->eConfigMode == WMAC_CONFIG_AP) {
+        bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RUN_AP, NULL);
+	}
+	else {
+        bScheduleCommand((HANDLE)pDevice, WLAN_CMD_BSSID_SCAN, NULL);
+        bScheduleCommand((HANDLE)pDevice, WLAN_CMD_SSID, NULL);
+    }
+    pDevice->flags |=DEVICE_FLAGS_OPENED;
+
+#ifndef PRIVATE_OBJ
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    MOD_INC_USE_COUNT;
+#endif
+#endif
+
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success.. \n");
+    return 0;
+}
+
+
+#ifdef PRIVATE_OBJ
+
+int  __device_close(HANDLE pExDevice) {
+    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
+    struct net_device *dev = pDevice_info->dev;
+    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
+
+#else
+static int  device_close(struct net_device *dev) {
+    PSDevice  pDevice=(PSDevice) dev->priv;
+#endif
+    PSMgmtObject     pMgmt = pDevice->pMgmt;
+ //PLICE_DEBUG->
+#ifdef	THREAD
+	mlme_kill = 0;
+#endif
+//PLICE_DEBUG<-
+//2007-1121-02<Add>by EinsnLiu
+    if (pDevice->bLinkPass) {
+	bScheduleCommand((HANDLE)pDevice, WLAN_CMD_DISASSOCIATE, NULL);
+        mdelay(30);
+    }
+#ifdef TxInSleep
+    del_timer(&pDevice->sTimerTxData);
+#endif
+    del_timer(&pDevice->sTimerCommand);
+    del_timer(&pMgmt->sTimerSecondCallback);
+    if (pDevice->bDiversityRegCtlON) {
+        del_timer(&pDevice->TimerSQ3Tmax1);
+        del_timer(&pDevice->TimerSQ3Tmax2);
+        del_timer(&pDevice->TimerSQ3Tmax3);
+    }
+
+#ifdef	TASK_LET
+	tasklet_kill(&pDevice->RxMngWorkItem);
+#endif
+     netif_stop_queue(dev);
+    pDevice->bCmdRunning = FALSE;
+    MACbShutdown(pDevice->PortOffset);
+    MACbSoftwareReset(pDevice->PortOffset);
+    CARDbRadioPowerOff(pDevice);
+
+    pDevice->bLinkPass = FALSE;
+    memset(pMgmt->abyCurrBSSID, 0, 6);
+    pMgmt->eCurrState = WMAC_STATE_IDLE;
+    device_free_td0_ring(pDevice);
+    device_free_td1_ring(pDevice);
+    device_free_rd0_ring(pDevice);
+    device_free_rd1_ring(pDevice);
+    device_free_frag_buf(pDevice);
+    device_free_rings(pDevice);
+    BSSvClearNodeDBTable(pDevice, 0);
+    free_irq(dev->irq, dev);
+    pDevice->flags &=(~DEVICE_FLAGS_OPENED);
+	//2008-0714-01<Add>by chester
+device_release_WPADEV(pDevice);
+//PLICE_DEBUG->
+	//tasklet_kill(&pDevice->RxMngWorkItem);
+//PLICE_DEBUG<-
+#ifndef PRIVATE_OBJ
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    MOD_DEC_USE_COUNT;
+#endif
+#endif
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close.. \n");
+    return 0;
+}
+
+#ifdef PRIVATE_OBJ
+
+int  __device_dma0_tx_80211(HANDLE pExDevice, struct sk_buff *skb) {
+    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
+    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
+    ref_sk_buff     ref_skb;
+
+#else
+
+
+static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {
+    PSDevice        pDevice=dev->priv;
+#endif
+    PBYTE           pbMPDU;
+    UINT            cbMPDULen = 0;
+
+
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211\n");
+    spin_lock_irq(&pDevice->lock);
+
+    if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211, td0 <=0\n");
+        dev_kfree_skb_irq(skb);
+        spin_unlock_irq(&pDevice->lock);
+        return 0;
+    }
+
+    if (pDevice->bStopTx0Pkt == TRUE) {
+        dev_kfree_skb_irq(skb);
+        spin_unlock_irq(&pDevice->lock);
+        return 0;
+    };
+
+#ifdef PRIVATE_OBJ
+    ref_skb_remap(pDevice->dev, &ref_skb, skb);
+    cbMPDULen = *(ref_skb.len);
+    pbMPDU = ref_skb.data;
+#else
+    cbMPDULen = skb->len;
+    pbMPDU = skb->data;
+#endif
+
+    vDMA0_tx_80211(pDevice, skb, pbMPDU, cbMPDULen);
+
+    spin_unlock_irq(&pDevice->lock);
+
+    return 0;
+
+}
+
+
+
+BOOL device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, UINT uNodeIndex) {
+    PSMgmtObject    pMgmt = pDevice->pMgmt;
+    PSTxDesc        pHeadTD, pLastTD;
+    UINT            cbFrameBodySize;
+    UINT            uMACfragNum;
+    BYTE            byPktTyp;
+    BOOL            bNeedEncryption = FALSE;
+    PSKeyItem       pTransmitKey = NULL;
+    UINT            cbHeaderSize;
+    UINT            ii;
+    SKeyItem        STempKey;
+//    BYTE            byKeyIndex = 0;
+#ifdef PRIVATE_OBJ
+    ref_sk_buff     ref_skb;
+#endif
+
+
+    if (pDevice->bStopTx0Pkt == TRUE) {
+        dev_kfree_skb_irq(skb);
+        return FALSE;
+    };
+
+    if (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {
+        dev_kfree_skb_irq(skb);
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, td0 <=0\n");
+        return FALSE;
+    }
+
+    if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+        if (pDevice->uAssocCount == 0) {
+            dev_kfree_skb_irq(skb);
+            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, assocCount = 0\n");
+            return FALSE;
+        }
+    }
+
+#ifdef PRIVATE_OBJ
+    ref_skb_remap(pDevice->dev, &(ref_skb), skb);
+#endif
+    pHeadTD = pDevice->apCurrTD[TYPE_TXDMA0];
+
+    pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
+
+#ifdef PRIVATE_OBJ
+    memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(ref_skb.data), U_HEADER_LEN);
+    cbFrameBodySize = *(ref_skb.len) - U_HEADER_LEN;
+
+#else
+    memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(skb->data), U_HEADER_LEN);
+    cbFrameBodySize = skb->len - U_HEADER_LEN;
+#endif
+
+    // 802.1H
+    if (ntohs(pDevice->sTxEthHeader.wType) > MAX_DATA_LEN) {
+        cbFrameBodySize += 8;
+    }
+    uMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);
+
+    if ( uMACfragNum > AVAIL_TD(pDevice, TYPE_TXDMA0)) {
+        dev_kfree_skb_irq(skb);
+        return FALSE;
+    }
+    byPktTyp = (BYTE)pDevice->byPacketType;
+
+
+    if (pDevice->bFixRate) {
+        if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
+            if (pDevice->uConnectionRate >= RATE_11M) {
+                pDevice->wCurrentRate = RATE_11M;
+            } else {
+                pDevice->wCurrentRate = (WORD)pDevice->uConnectionRate;
+            }
+        } else {
+            if (pDevice->uConnectionRate >= RATE_54M)
+                pDevice->wCurrentRate = RATE_54M;
+            else
+                pDevice->wCurrentRate = (WORD)pDevice->uConnectionRate;
+        }
+    }
+    else {
+        pDevice->wCurrentRate = pDevice->pMgmt->sNodeDBTable[uNodeIndex].wTxDataRate;
+    }
+
+    //preamble type
+    if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {
+        pDevice->byPreambleType = pDevice->byShortPreamble;
+    }
+    else {
+        pDevice->byPreambleType = PREAMBLE_LONG;
+    }
+
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
+
+
+    if (pDevice->wCurrentRate <= RATE_11M) {
+        byPktTyp = PK_TYPE_11B;
+    } else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
+        byPktTyp = PK_TYPE_11A;
+    } else {
+        if (pDevice->bProtectMode == TRUE) {
+            byPktTyp = PK_TYPE_11GB;
+        } else {
+            byPktTyp = PK_TYPE_11GA;
+        }
+    }
+
+    if (pDevice->bEncryptionEnable == TRUE)
+        bNeedEncryption = TRUE;
+
+    if (pDevice->bEnableHostWEP) {
+        pTransmitKey = &STempKey;
+        pTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;
+        pTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;
+        pTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;
+        pTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;
+        pTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;
+        memcpy(pTransmitKey->abyKey,
+            &pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],
+            pTransmitKey->uKeyLength
+            );
+    }
+    vGenerateFIFOHeader(pDevice, byPktTyp, pDevice->pbyTmpBuff, bNeedEncryption,
+                        cbFrameBodySize, TYPE_TXDMA0, pHeadTD,
+                        &pDevice->sTxEthHeader, (PBYTE)skb->data, pTransmitKey, uNodeIndex,
+                        &uMACfragNum,
+                        &cbHeaderSize
+                        );
+
+    if (MACbIsRegBitsOn(pDevice->PortOffset, MAC_REG_PSCTL, PSCTL_PS)) {
+        // Disable PS
+        MACbPSWakeup(pDevice->PortOffset);
+    }
+
+    pDevice->bPWBitOn = FALSE;
+
+    pLastTD = pHeadTD;
+    for (ii = 0; ii < uMACfragNum; ii++) {
+        // Poll Transmit the adapter
+        wmb();
+        pHeadTD->m_td0TD0.f1Owner=OWNED_BY_NIC;
+        wmb();
+        if (ii == (uMACfragNum - 1))
+            pLastTD = pHeadTD;
+        pHeadTD = pHeadTD->next;
+    }
+
+    // Save the information needed by the tx interrupt handler
+    // to complete the Send request
+    pLastTD->pTDInfo->skb = skb;
+    pLastTD->pTDInfo->byFlags = 0;
+    pLastTD->pTDInfo->byFlags |= TD_FLAGS_NETIF_SKB;
+
+    pDevice->apCurrTD[TYPE_TXDMA0] = pHeadTD;
+
+    MACvTransmit0(pDevice->PortOffset);
+
+
+    return TRUE;
+}
+
+//TYPE_AC0DMA data tx
+#ifdef PRIVATE_OBJ
+
+int  __device_xmit(HANDLE pExDevice, struct sk_buff *skb) {
+    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
+    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
+    struct net_device *dev = pDevice_info->dev;
+    ref_sk_buff     ref_skb;
+
+#else
+static int  device_xmit(struct sk_buff *skb, struct net_device *dev) {
+    PSDevice pDevice=dev->priv;
+
+#endif
+    PSMgmtObject    pMgmt = pDevice->pMgmt;
+    PSTxDesc        pHeadTD, pLastTD;
+    UINT            uNodeIndex = 0;
+    BYTE            byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
+    WORD            wAID;
+    UINT            uMACfragNum = 1;
+    UINT            cbFrameBodySize;
+    BYTE            byPktTyp;
+    UINT            cbHeaderSize;
+    BOOL            bNeedEncryption = FALSE;
+    PSKeyItem       pTransmitKey = NULL;
+    SKeyItem        STempKey;
+    UINT            ii;
+    BOOL            bTKIP_UseGTK = FALSE;
+    BOOL            bNeedDeAuth = FALSE;
+    PBYTE           pbyBSSID;
+    BOOL            bNodeExist = FALSE;
+
+
+
+    spin_lock_irq(&pDevice->lock);
+    if (pDevice->bLinkPass == FALSE) {
+        dev_kfree_skb_irq(skb);
+        spin_unlock_irq(&pDevice->lock);
+        return 0;
+    }
+
+    if (pDevice->bStopDataPkt) {
+        dev_kfree_skb_irq(skb);
+        spin_unlock_irq(&pDevice->lock);
+        return 0;
+    }
+
+#ifdef PRIVATE_OBJ
+    ref_skb_remap(pDevice->dev, &ref_skb, skb);
+#endif
+
+    if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+        if (pDevice->uAssocCount == 0) {
+            dev_kfree_skb_irq(skb);
+            spin_unlock_irq(&pDevice->lock);
+            return 0;
+        }
+#ifdef PRIVATE_OBJ
+        if (IS_MULTICAST_ADDRESS((PBYTE)(ref_skb.data))) {
+#else
+        if (IS_MULTICAST_ADDRESS((PBYTE)(skb->data))) {
+#endif
+            uNodeIndex = 0;
+            bNodeExist = TRUE;
+            if (pMgmt->sNodeDBTable[0].bPSEnable) {
+#ifdef PRIVATE_OBJ
+                skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), ref_skb.skb);
+#else
+                skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skb);
+#endif
+                pMgmt->sNodeDBTable[0].wEnQueueCnt++;
+                // set tx map
+                pMgmt->abyPSTxMap[0] |= byMask[0];
+                spin_unlock_irq(&pDevice->lock);
+                return 0;
+            }
+}else {
+#ifdef PRIVATE_OBJ
+            if (BSSDBbIsSTAInNodeDB(pMgmt, (PBYTE)(ref_skb.data), &uNodeIndex)) {
+#else
+            if (BSSDBbIsSTAInNodeDB(pMgmt, (PBYTE)(skb->data), &uNodeIndex)) {
+#endif
+                if (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {
+#ifdef PRIVATE_OBJ
+                    skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, ref_skb.skb);
+#else
+                    skb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);
+#endif
+                    pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;
+                    // set tx map
+                    wAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;
+                    pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Set:pMgmt->abyPSTxMap[%d]= %d\n",
+                             (wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);
+                    spin_unlock_irq(&pDevice->lock);
+                    return 0;
+                }
+
+                if (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {
+                    pDevice->byPreambleType = pDevice->byShortPreamble;
+
+                }else {
+                    pDevice->byPreambleType = PREAMBLE_LONG;
+                }
+                bNodeExist = TRUE;
+
+            }
+        }
+
+        if (bNodeExist == FALSE) {
+            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Unknown STA not found in node DB \n");
+            dev_kfree_skb_irq(skb);
+            spin_unlock_irq(&pDevice->lock);
+            return 0;
+        }
+    }
+
+    pHeadTD = pDevice->apCurrTD[TYPE_AC0DMA];
+
+    pHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);
+
+
+#ifdef PRIVATE_OBJ
+    memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(ref_skb.data), U_HEADER_LEN);
+    cbFrameBodySize = *(ref_skb.len) - U_HEADER_LEN;
+#else
+    memcpy(pDevice->sTxEthHeader.abyDstAddr, (PBYTE)(skb->data), U_HEADER_LEN);
+    cbFrameBodySize = skb->len - U_HEADER_LEN;
+#endif
+    // 802.1H
+    if (ntohs(pDevice->sTxEthHeader.wType) > MAX_DATA_LEN) {
+        cbFrameBodySize += 8;
+    }
+
+
+    if (pDevice->bEncryptionEnable == TRUE) {
+        bNeedEncryption = TRUE;
+        // get Transmit key
+        do {
+            if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
+                (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
+                pbyBSSID = pDevice->abyBSSID;
+                // get pairwise key
+                if (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == FALSE) {
+                    // get group key
+                    if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == TRUE) {
+                        bTKIP_UseGTK = TRUE;
+                        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");
+                        break;
+                    }
+                } else {
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get PTK.\n");
+                    break;
+                }
+            }else if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
+
+                pbyBSSID = pDevice->sTxEthHeader.abyDstAddr;  //TO_DS = 0 and FROM_DS = 0 --> 802.11 MAC Address1
+                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS Serach Key: \n");
+                for (ii = 0; ii< 6; ii++)
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"%x \n", *(pbyBSSID+ii));
+                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"\n");
+
+                // get pairwise key
+                if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == TRUE)
+                    break;
+            }
+            // get group key
+            pbyBSSID = pDevice->abyBroadcastAddr;
+            if(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == FALSE) {
+                pTransmitKey = NULL;
+                if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
+                }
+                else
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"NOT IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);
+            } else {
+                bTKIP_UseGTK = TRUE;
+                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");
+            }
+        } while(FALSE);
+    }
+
+    if (pDevice->bEnableHostWEP) {
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"acdma0: STA index %d\n", uNodeIndex);
+        if (pDevice->bEncryptionEnable == TRUE) {
+            pTransmitKey = &STempKey;
+            pTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;
+            pTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;
+            pTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;
+            pTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;
+            pTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;
+            memcpy(pTransmitKey->abyKey,
+                &pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],
+                pTransmitKey->uKeyLength
+                );
+         }
+    }
+
+    uMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);
+
+    if (uMACfragNum > AVAIL_TD(pDevice, TYPE_AC0DMA)) {
+        DEVICE_PRT(MSG_LEVEL_ERR, KERN_DEBUG "uMACfragNum > AVAIL_TD(TYPE_AC0DMA) = %d\n", uMACfragNum);
+        dev_kfree_skb_irq(skb);
+        spin_unlock_irq(&pDevice->lock);
+        return 0;
+    }
+
+    if (pTransmitKey != NULL) {
+        if ((pTransmitKey->byCipherSuite == KEY_CTL_WEP) &&
+            (pTransmitKey->uKeyLength == WLAN_WEP232_KEYLEN)) {
+            uMACfragNum = 1; //WEP256 doesn't support fragment
+        }
+    }
+
+    byPktTyp = (BYTE)pDevice->byPacketType;
+
+    if (pDevice->bFixRate) {
+#ifdef	PLICE_DEBUG
+	printk("Fix Rate: PhyType is %d,ConnectionRate is %d\n",pDevice->eCurrentPHYType,pDevice->uConnectionRate);
+#endif
+
+        if (pDevice->eCurrentPHYType == PHY_TYPE_11B) {
+            if (pDevice->uConnectionRate >= RATE_11M) {
+                pDevice->wCurrentRate = RATE_11M;
+            } else {
+                pDevice->wCurrentRate = (WORD)pDevice->uConnectionRate;
+            }
+        } else {
+            if ((pDevice->eCurrentPHYType == PHY_TYPE_11A) &&
+                (pDevice->uConnectionRate <= RATE_6M)) {
+                pDevice->wCurrentRate = RATE_6M;
+            } else {
+                if (pDevice->uConnectionRate >= RATE_54M)
+                    pDevice->wCurrentRate = RATE_54M;
+                else
+                    pDevice->wCurrentRate = (WORD)pDevice->uConnectionRate;
+
+            }
+        }
+        pDevice->byACKRate = (BYTE) pDevice->wCurrentRate;
+        pDevice->byTopCCKBasicRate = RATE_1M;
+        pDevice->byTopOFDMBasicRate = RATE_6M;
+    }
+    else {
+        //auto rate
+    if (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {
+            if (pDevice->eCurrentPHYType != PHY_TYPE_11A) {
+                pDevice->wCurrentRate = RATE_1M;
+                pDevice->byACKRate = RATE_1M;
+                pDevice->byTopCCKBasicRate = RATE_1M;
+                pDevice->byTopOFDMBasicRate = RATE_6M;
+            } else {
+                pDevice->wCurrentRate = RATE_6M;
+                pDevice->byACKRate = RATE_6M;
+                pDevice->byTopCCKBasicRate = RATE_1M;
+                pDevice->byTopOFDMBasicRate = RATE_6M;
+            }
+        }
+        else {
+		VNTWIFIvGetTxRate(  pDevice->pMgmt,
+                                pDevice->sTxEthHeader.abyDstAddr,
+                                &(pDevice->wCurrentRate),
+                                &(pDevice->byACKRate),
+                                &(pDevice->byTopCCKBasicRate),
+                                &(pDevice->byTopOFDMBasicRate));
+
+#if 0
+printk("auto rate:Rate : %d,AckRate:%d,TopCCKRate:%d,TopOFDMRate:%d\n",
+pDevice->wCurrentRate,pDevice->byACKRate,
+pDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);
+
+#endif
+
+#if 0
+
+	pDevice->wCurrentRate = 11;
+	pDevice->byACKRate = 8;
+	pDevice->byTopCCKBasicRate = 3;
+	pDevice->byTopOFDMBasicRate = 8;
+#endif
+
+
+		}
+    }
+
+//    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);
+
+    if (pDevice->wCurrentRate <= RATE_11M) {
+        byPktTyp = PK_TYPE_11B;
+    } else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {
+        byPktTyp = PK_TYPE_11A;
+    } else {
+        if (pDevice->bProtectMode == TRUE) {
+            byPktTyp = PK_TYPE_11GB;
+        } else {
+            byPktTyp = PK_TYPE_11GA;
+        }
+    }
+
+//#ifdef	PLICE_DEBUG
+//	printk("FIX RATE:CurrentRate is %d");
+//#endif
+
+    if (bNeedEncryption == TRUE) {
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ntohs Pkt Type=%04x\n", ntohs(pDevice->sTxEthHeader.wType));
+        if ((pDevice->sTxEthHeader.wType) == TYPE_PKT_802_1x) {
+            bNeedEncryption = FALSE;
+            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Pkt Type=%04x\n", (pDevice->sTxEthHeader.wType));
+            if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {
+                if (pTransmitKey == NULL) {
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Don't Find TX KEY\n");
+                }
+                else {
+                    if (bTKIP_UseGTK == TRUE) {
+                        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"error: KEY is GTK!!~~\n");
+                    }
+                    else {
+                        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
+                        bNeedEncryption = TRUE;
+                    }
+                }
+            }
+
+            if (pDevice->byCntMeasure == 2) {
+                bNeedDeAuth = TRUE;
+                pDevice->s802_11Counter.TKIPCounterMeasuresInvoked++;
+            }
+
+            if (pDevice->bEnableHostWEP) {
+                if ((uNodeIndex != 0) &&
+                    (pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex & PAIRWISE_KEY)) {
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
+                    bNeedEncryption = TRUE;
+                 }
+             }
+        }
+        else {
+            if (pTransmitKey == NULL) {
+                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"return no tx key\n");
+                dev_kfree_skb_irq(skb);
+                spin_unlock_irq(&pDevice->lock);
+                return 0;
+            }
+        }
+    }
+
+
+#ifdef PRIVATE_OBJ
+    vGenerateFIFOHeader(pDevice, byPktTyp, pDevice->pbyTmpBuff, bNeedEncryption,
+                        cbFrameBodySize, TYPE_AC0DMA, pHeadTD,
+                        &pDevice->sTxEthHeader, (PBYTE)ref_skb.data, pTransmitKey, uNodeIndex,
+                        &uMACfragNum,
+                        &cbHeaderSize
+                        );
+#else
+#ifdef	PLICE_DEBUG
+	//if (skb->len == 98)
+	//{
+	//	printk("ping:len is %d\n");
+	//}
+#endif
+    vGenerateFIFOHeader(pDevice, byPktTyp, pDevice->pbyTmpBuff, bNeedEncryption,
+                        cbFrameBodySize, TYPE_AC0DMA, pHeadTD,
+                        &pDevice->sTxEthHeader, (PBYTE)skb->data, pTransmitKey, uNodeIndex,
+                        &uMACfragNum,
+                        &cbHeaderSize
+                        );
+#endif
+
+    if (MACbIsRegBitsOn(pDevice->PortOffset, MAC_REG_PSCTL, PSCTL_PS)) {
+        // Disable PS
+        MACbPSWakeup(pDevice->PortOffset);
+    }
+    pDevice->bPWBitOn = FALSE;
+
+    pLastTD = pHeadTD;
+    for (ii = 0; ii < uMACfragNum; ii++) {
+        // Poll Transmit the adapter
+        wmb();
+        pHeadTD->m_td0TD0.f1Owner=OWNED_BY_NIC;
+        wmb();
+        if (ii == uMACfragNum - 1)
+            pLastTD = pHeadTD;
+        pHeadTD = pHeadTD->next;
+    }
+
+    // Save the information needed by the tx interrupt handler
+    // to complete the Send request
+#ifdef PRIVATE_OBJ
+    pLastTD->pTDInfo->skb = ref_skb.skb;
+#else
+    pLastTD->pTDInfo->skb = skb;
+#endif
+    pLastTD->pTDInfo->byFlags = 0;
+    pLastTD->pTDInfo->byFlags |= TD_FLAGS_NETIF_SKB;
+#ifdef TxInSleep
+  pDevice->nTxDataTimeCout=0; //2008-8-21 chester <add> for send null packet
+  #endif
+    if (AVAIL_TD(pDevice, TYPE_AC0DMA) <= 1) {
+        netif_stop_queue(dev);
+    }
+
+    pDevice->apCurrTD[TYPE_AC0DMA] = pHeadTD;
+//#ifdef	PLICE_DEBUG
+	if (pDevice->bFixRate)
+	{
+		printk("FixRate:Rate is %d,TxPower is %d\n",pDevice->wCurrentRate,pDevice->byCurPwr);
+	}
+	else
+	{
+		//printk("Auto Rate:Rate is %d,TxPower is %d\n",pDevice->wCurrentRate,pDevice->byCurPwr);
+	}
+//#endif
+
+{
+    BYTE  Protocol_Version;    //802.1x Authentication
+    BYTE  Packet_Type;           //802.1x Authentication
+    BYTE  Descriptor_type;
+    WORD Key_info;
+BOOL            bTxeapol_key = FALSE;
+    Protocol_Version = skb->data[U_HEADER_LEN];
+    Packet_Type = skb->data[U_HEADER_LEN+1];
+    Descriptor_type = skb->data[U_HEADER_LEN+1+1+2];
+    Key_info = (skb->data[U_HEADER_LEN+1+1+2+1] << 8)|(skb->data[U_HEADER_LEN+1+1+2+2]);
+   if (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {
+           if(((Protocol_Version==1) ||(Protocol_Version==2)) &&
+	        (Packet_Type==3)) {  //802.1x OR eapol-key challenge frame transfer
+                        bTxeapol_key = TRUE;
+		if((Descriptor_type==254)||(Descriptor_type==2)) {       //WPA or RSN
+                       if(!(Key_info & BIT3) &&   //group-key challenge
+			   (Key_info & BIT8) && (Key_info & BIT9)) {    //send 2/2 key
+			  pDevice->fWPA_Authened = TRUE;
+			  if(Descriptor_type==254)
+			      printk("WPA ");
+			  else
+			      printk("WPA2 ");
+			  printk("Authentication completed!!\n");
+                        }
+		 }
+             }
+   }
+}
+
+    MACvTransmitAC0(pDevice->PortOffset);
+//    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "acdma0:pDevice->apCurrTD= %p\n", pHeadTD);
+
+#ifdef PRIVATE_OBJ
+    ref_set_tx_jiffies(pDevice->dev);
+#else
+    dev->trans_start = jiffies;
+#endif
+
+    spin_unlock_irq(&pDevice->lock);
+    return 0;
+
+}
+
+#ifdef PRIVATE_OBJ
+
+int __device_intr(int irq, HANDLE pExDevice, struct pt_regs *regs) {
+    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
+    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
+
+
+#else
+static  irqreturn_t  device_intr(int irq,  void *dev_instance) {
+    struct net_device* dev=dev_instance;
+    PSDevice     pDevice=(PSDevice) dev->priv;
+#endif
+
+    int             max_count=0;
+    DWORD           dwMIBCounter=0;
+    PSMgmtObject    pMgmt = pDevice->pMgmt;
+    BYTE            byOrgPageSel=0;
+    int             handled = 0;
+    BYTE            byData = 0;
+    int             ii= 0;
+//    BYTE            byRSSI;
+
+
+    MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
+
+    if (pDevice->dwIsr == 0)
+        return IRQ_RETVAL(handled);
+
+    if (pDevice->dwIsr == 0xffffffff) {
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwIsr = 0xffff\n");
+        return IRQ_RETVAL(handled);
+    }
+    /*
+      // 2008-05-21 <mark> by Richardtai, we can't read RSSI here, because no packet bound with RSSI
+
+    	if ((BITbIsBitOn(pDevice->dwIsr, ISR_RXDMA0)) &&
+        (pDevice->byLocalID != REV_ID_VT3253_B0) &&
+        (pDevice->bBSSIDFilter == TRUE)) {
+        // update RSSI
+        //BBbReadEmbeded(pDevice->PortOffset, 0x3E, &byRSSI);
+        //pDevice->uCurrRSSI = byRSSI;
+    }
+    */
+
+    handled = 1;
+    MACvIntDisable(pDevice->PortOffset);
+    spin_lock_irq(&pDevice->lock);
+
+    //Make sure current page is 0
+    VNSvInPortB(pDevice->PortOffset + MAC_REG_PAGE1SEL, &byOrgPageSel);
+    if (byOrgPageSel == 1) {
+        MACvSelectPage0(pDevice->PortOffset);
+    }
+    else
+        byOrgPageSel = 0;
+
+    MACvReadMIBCounter(pDevice->PortOffset, &dwMIBCounter);
+    // TBD....
+    // Must do this after doing rx/tx, cause ISR bit is slow
+    // than RD/TD write back
+    // update ISR counter
+    STAvUpdate802_11Counter(&pDevice->s802_11Counter, &pDevice->scStatistic , dwMIBCounter);
+    while (pDevice->dwIsr != 0) {
+
+        STAvUpdateIsrStatCounter(&pDevice->scStatistic, pDevice->dwIsr);
+        MACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);
+
+        if (pDevice->dwIsr & ISR_FETALERR){
+            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " ISR_FETALERR \n");
+            VNSvOutPortB(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, 0);
+            VNSvOutPortW(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, SOFTPWRCTL_SWPECTI);
+            device_error(pDevice, pDevice->dwIsr);
+        }
+
+        if (pDevice->byLocalID > REV_ID_VT3253_B1) {
+
+            if (BITbIsBitOn(pDevice->dwIsr, ISR_MEASURESTART)) {
+                // 802.11h measure start
+                pDevice->byOrgChannel = pDevice->byCurrentCh;
+                VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byOrgRCR));
+                VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, (RCR_RXALLTYPE | RCR_UNICAST | RCR_BROADCAST | RCR_MULTICAST | RCR_WPAERR));
+                MACvSelectPage1(pDevice->PortOffset);
+                VNSvInPortD(pDevice->PortOffset + MAC_REG_MAR0, &(pDevice->dwOrgMAR0));
+                VNSvInPortD(pDevice->PortOffset + MAC_REG_MAR4, &(pDevice->dwOrgMAR4));
+                MACvSelectPage0(pDevice->PortOffset);
+               //xxxx
+               // WCMDbFlushCommandQueue(pDevice->pMgmt, TRUE);
+                if (CARDbSetChannel(pDevice, pDevice->pCurrMeasureEID->sReq.byChannel) == TRUE) {
+                    pDevice->bMeasureInProgress = TRUE;
+                    MACvSelectPage1(pDevice->PortOffset);
+                    MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_READY);
+                    MACvSelectPage0(pDevice->PortOffset);
+                    pDevice->byBasicMap = 0;
+                    pDevice->byCCAFraction = 0;
+                    for(ii=0;ii<8;ii++) {
+                        pDevice->dwRPIs[ii] = 0;
+                    }
+                } else {
+                    // can not measure because set channel fail
+                   // WCMDbResetCommandQueue(pDevice->pMgmt);
+                    // clear measure control
+                    MACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);
+                    s_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_INCAPABLE);
+                    MACvSelectPage1(pDevice->PortOffset);
+                    MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
+                    MACvSelectPage0(pDevice->PortOffset);
+                }
+            }
+            if (BITbIsBitOn(pDevice->dwIsr, ISR_MEASUREEND)) {
+                // 802.11h measure end
+                pDevice->bMeasureInProgress = FALSE;
+                VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byOrgRCR);
+                MACvSelectPage1(pDevice->PortOffset);
+                VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, pDevice->dwOrgMAR0);
+                VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR4, pDevice->dwOrgMAR4);
+                VNSvInPortB(pDevice->PortOffset + MAC_REG_MSRBBSTS, &byData);
+                pDevice->byBasicMap |= (byData >> 4);
+                VNSvInPortB(pDevice->PortOffset + MAC_REG_CCAFRACTION, &pDevice->byCCAFraction);
+                VNSvInPortB(pDevice->PortOffset + MAC_REG_MSRCTL, &byData);
+                // clear measure control
+                MACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);
+                MACvSelectPage0(pDevice->PortOffset);
+                CARDbSetChannel(pDevice, pDevice->byOrgChannel);
+                // WCMDbResetCommandQueue(pDevice->pMgmt);
+                MACvSelectPage1(pDevice->PortOffset);
+                MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
+                MACvSelectPage0(pDevice->PortOffset);
+                if (BITbIsBitOn(byData, MSRCTL_FINISH)) {
+                    // measure success
+                    s_vCompleteCurrentMeasure(pDevice, 0);
+                } else {
+                    // can not measure because not ready before end of measure time
+                    s_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_LATE);
+                }
+            }
+            if (BITbIsBitOn(pDevice->dwIsr, ISR_QUIETSTART)) {
+                do {
+                    ;
+                } while (CARDbStartQuiet(pDevice) == FALSE);
+            }
+        }
+
+        if (pDevice->dwIsr & ISR_TBTT) {
+            if (pDevice->bEnableFirstQuiet == TRUE) {
+                pDevice->byQuietStartCount--;
+                if (pDevice->byQuietStartCount == 0) {
+                    pDevice->bEnableFirstQuiet = FALSE;
+                    MACvSelectPage1(pDevice->PortOffset);
+                    MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, (MSRCTL_QUIETTXCHK | MSRCTL_QUIETEN));
+                    MACvSelectPage0(pDevice->PortOffset);
+                }
+            }
+            if ((pDevice->bChannelSwitch == TRUE) &&
+                (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE)) {
+                pDevice->byChannelSwitchCount--;
+                if (pDevice->byChannelSwitchCount == 0) {
+                    pDevice->bChannelSwitch = FALSE;
+                    CARDbSetChannel(pDevice, pDevice->byNewChannel);
+                    VNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);
+                    MACvSelectPage1(pDevice->PortOffset);
+                    MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
+                    MACvSelectPage0(pDevice->PortOffset);
+                    CARDbStartTxPacket(pDevice, PKT_TYPE_802_11_ALL);
+
+                }
+            }
+            if (pDevice->eOPMode == OP_MODE_ADHOC) {
+                //pDevice->bBeaconSent = FALSE;
+            } else {
+                if ((pDevice->bUpdateBBVGA) && (pDevice->bLinkPass == TRUE) && (pDevice->uCurrRSSI != 0)) {
+                    LONG            ldBm;
+
+                    RFvRSSITodBm(pDevice, (BYTE) pDevice->uCurrRSSI, &ldBm);
+                    for (ii=0;ii<BB_VGA_LEVEL;ii++) {
+                        if (ldBm < pDevice->ldBmThreshold[ii]) {
+                            pDevice->byBBVGANew = pDevice->abyBBVGA[ii];
+                            break;
+                        }
+                    }
+                    if (pDevice->byBBVGANew != pDevice->byBBVGACurrent) {
+                        pDevice->uBBVGADiffCount++;
+                        if (pDevice->uBBVGADiffCount == 1) {
+                            // first VGA diff gain
+                            BBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);
+                            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
+                                            (int)ldBm, pDevice->byBBVGANew, pDevice->byBBVGACurrent, (int)pDevice->uBBVGADiffCount);
+                        }
+                        if (pDevice->uBBVGADiffCount >= BB_VGA_CHANGE_THRESHOLD) {
+                            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",
+                                            (int)ldBm, pDevice->byBBVGANew, pDevice->byBBVGACurrent, (int)pDevice->uBBVGADiffCount);
+                            BBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);
+                        }
+                    } else {
+                        pDevice->uBBVGADiffCount = 1;
+                    }
+                }
+            }
+
+            pDevice->bBeaconSent = FALSE;
+            if (pDevice->bEnablePSMode) {
+                PSbIsNextTBTTWakeUp((HANDLE)pDevice);
+            };
+
+            if ((pDevice->eOPMode == OP_MODE_AP) ||
+                (pDevice->eOPMode == OP_MODE_ADHOC)) {
+
+                MACvOneShotTimer1MicroSec(pDevice->PortOffset,
+                        (pMgmt->wIBSSBeaconPeriod - MAKE_BEACON_RESERVED) << 10);
+            }
+
+            if (pDevice->eOPMode == OP_MODE_ADHOC && pDevice->pMgmt->wCurrATIMWindow > 0) {
+                // todo adhoc PS mode
+            };
+
+        }
+
+        if (pDevice->dwIsr & ISR_BNTX) {
+
+            if (pDevice->eOPMode == OP_MODE_ADHOC) {
+                pDevice->bIsBeaconBufReadySet = FALSE;
+                pDevice->cbBeaconBufReadySetCnt = 0;
+            };
+
+            if (pDevice->eOPMode == OP_MODE_AP) {
+                if(pMgmt->byDTIMCount > 0) {
+                   pMgmt->byDTIMCount --;
+                   pMgmt->sNodeDBTable[0].bRxPSPoll = FALSE;
+                }
+                else {
+                    if(pMgmt->byDTIMCount == 0) {
+                        // check if mutltcast tx bufferring
+                        pMgmt->byDTIMCount = pMgmt->byDTIMPeriod - 1;
+                        pMgmt->sNodeDBTable[0].bRxPSPoll = TRUE;
+                        bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
+                    }
+                }
+            }
+            pDevice->bBeaconSent = TRUE;
+
+            if (pDevice->bChannelSwitch == TRUE) {
+                pDevice->byChannelSwitchCount--;
+                if (pDevice->byChannelSwitchCount == 0) {
+                    pDevice->bChannelSwitch = FALSE;
+                    CARDbSetChannel(pDevice, pDevice->byNewChannel);
+                    VNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);
+                    MACvSelectPage1(pDevice->PortOffset);
+                    MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
+                    MACvSelectPage0(pDevice->PortOffset);
+                    //VNTWIFIbSendBeacon(pDevice->pMgmt);
+                    CARDbStartTxPacket(pDevice, PKT_TYPE_802_11_ALL);
+                }
+            }
+
+        }
+
+        if (pDevice->dwIsr & ISR_RXDMA0) {
+            max_count += device_rx_srv(pDevice, TYPE_RXDMA0);
+        }
+        if (pDevice->dwIsr & ISR_RXDMA1) {
+            max_count += device_rx_srv(pDevice, TYPE_RXDMA1);
+        }
+        if (pDevice->dwIsr & ISR_TXDMA0){
+            max_count += device_tx_srv(pDevice, TYPE_TXDMA0);
+        }
+        if (pDevice->dwIsr & ISR_AC0DMA){
+            max_count += device_tx_srv(pDevice, TYPE_AC0DMA);
+        }
+        if (pDevice->dwIsr & ISR_SOFTTIMER) {
+
+        }
+        if (pDevice->dwIsr & ISR_SOFTTIMER1) {
+            if (pDevice->eOPMode == OP_MODE_AP) {
+               if (pDevice->bShortSlotTime)
+                   pMgmt->wCurrCapInfo |= WLAN_SET_CAP_INFO_SHORTSLOTTIME(1);
+               else
+                   pMgmt->wCurrCapInfo &= ~(WLAN_SET_CAP_INFO_SHORTSLOTTIME(1));
+            }
+            bMgrPrepareBeaconToSend(pDevice, pMgmt);
+            pDevice->byCntMeasure = 0;
+        }
+
+        MACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);
+
+        MACvReceive0(pDevice->PortOffset);
+        MACvReceive1(pDevice->PortOffset);
+
+        if (max_count>pDevice->sOpts.int_works)
+            break;
+    }
+
+    if (byOrgPageSel == 1) {
+        MACvSelectPage1(pDevice->PortOffset);
+    }
+
+    spin_unlock_irq(&pDevice->lock);
+    MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
+
+    return IRQ_RETVAL(handled);
+}
+
+
+static unsigned const ethernet_polynomial = 0x04c11db7U;
+static inline u32 ether_crc(int length, unsigned char *data)
+{
+    int crc = -1;
+
+    while(--length >= 0) {
+        unsigned char current_octet = *data++;
+        int bit;
+        for (bit = 0; bit < 8; bit++, current_octet >>= 1) {
+            crc = (crc << 1) ^
+                ((crc < 0) ^ (current_octet & 1) ? ethernet_polynomial : 0);
+        }
+    }
+    return crc;
+}
+
+//2008-8-4 <add> by chester
+static int Config_FileGetParameter(UCHAR *string, UCHAR *dest,UCHAR *source)
+{
+  UCHAR buf1[100];
+  int source_len = strlen(source);
+
+    memset(buf1,0,100);
+    strcat(buf1, string);
+    strcat(buf1, "=");
+    source+=strlen(buf1);
+
+   memcpy(dest,source,source_len-strlen(buf1));
+ return TRUE;
+}
+
+int Config_FileOperation(PSDevice pDevice,BOOL fwrite,unsigned char *Parameter) {
+    UCHAR    *config_path=CONFIG_PATH;
+    UCHAR    *buffer=NULL;
+    UCHAR      tmpbuffer[20];
+    struct file   *filp=NULL;
+    mm_segment_t old_fs = get_fs();
+    int oldfsuid=0,oldfsgid=0;
+    int result=0;
+
+    set_fs (KERNEL_DS);
+//Make sure a caller can read or write power as root
+   oldfsuid=current->fsuid;
+   oldfsgid=current->fsgid;
+    current->fsuid = 0;
+    current->fsgid = 0;
+
+    //open file
+      filp = filp_open(config_path, O_RDWR, 0);
+        if (IS_ERR(filp)) {
+	     printk("Config_FileOperation:open file fail?\n");
+	     result=-1;
+             goto error2;
+	  }
+
+     if(!(filp->f_op) || !(filp->f_op->read) ||!(filp->f_op->write)) {
+           printk("file %s cann't readable or writable?\n",config_path);
+	  result = -1;
+	  goto error1;
+     	}
+
+buffer = (UCHAR *)kmalloc(1024, GFP_KERNEL);
+if(buffer==NULL) {
+  printk("alllocate mem for file fail?\n");
+  result = -1;
+  goto error1;
+}
+
+if(filp->f_op->read(filp, buffer, 1024, &filp->f_pos)<0) {
+ printk("read file error?\n");
+ result = -1;
+ goto error1;
+}
+
+if(Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer)!=TRUE) {
+  printk("get parameter error?\n");
+  result = -1;
+  goto error1;
+}
+
+if(memcmp(tmpbuffer,"USA",3)==0) {
+  result=ZoneType_USA;
+}
+else if(memcmp(tmpbuffer,"JAPAN",5)==0) {
+  result=ZoneType_Japan;
+}
+else if(memcmp(tmpbuffer,"EUROPE",5)==0) {
+ result=ZoneType_Europe;
+}
+else {
+  result = -1;
+  printk("Unknown Zonetype[%s]?\n",tmpbuffer);
+}
+
+error1:
+  if(buffer)
+  	 kfree(buffer);
+
+  if(filp_close(filp,NULL))
+       printk("Config_FileOperation:close file fail\n");
+
+error2:
+  set_fs (old_fs);
+  current->fsuid=oldfsuid;
+  current->fsgid=oldfsgid;
+
+  return result;
+}
+
+
+#ifdef PRIVATE_OBJ
+
+void __device_set_multi(HANDLE pExDevice) {
+    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
+    ref_net_device  *dev = &(pDevice_info->ref_dev);
+    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
+
+#else
+
+static void device_set_multi(struct net_device *dev) {
+    PSDevice         pDevice = (PSDevice) dev->priv;
+#endif
+
+    PSMgmtObject     pMgmt = pDevice->pMgmt;
+    u32              mc_filter[2];
+    int              i;
+    struct dev_mc_list  *mclist;
+
+
+    VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
+
+#ifdef PRIVATE_OBJ
+    if (*(dev->flags) & IFF_PROMISC) {         /* Set promiscuous. */
+        DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: Promiscuous mode enabled.\n", pDevice->dev->name);
+
+#else
+    if (dev->flags & IFF_PROMISC) {         /* Set promiscuous. */
+        DEVICE_PRT(MSG_LEVEL_ERR,KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
+#endif
+        /* Unconditionally log net taps. */
+        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);
+    }
+#ifdef PRIVATE_OBJ
+    else if ((*(dev->mc_count) > pDevice->multicast_limit)
+        ||  (*(dev->flags) & IFF_ALLMULTI)) {
+#else
+    else if ((dev->mc_count > pDevice->multicast_limit)
+        ||  (dev->flags & IFF_ALLMULTI)) {
+#endif
+        MACvSelectPage1(pDevice->PortOffset);
+        VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, 0xffffffff);
+        VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0 + 4, 0xffffffff);
+        MACvSelectPage0(pDevice->PortOffset);
+        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
+    }
+    else {
+        memset(mc_filter, 0, sizeof(mc_filter));
+#ifdef PRIVATE_OBJ
+        for (i = 0, mclist = dev->mc_list; mclist && i < *(dev->mc_count);
+             i++, mclist = mclist->next) {
+#else
+        for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
+             i++, mclist = mclist->next) {
+#endif
+            int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+            mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
+        }
+        MACvSelectPage1(pDevice->PortOffset);
+        VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, mc_filter[0]);
+        VNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0 + 4, mc_filter[1]);
+        MACvSelectPage0(pDevice->PortOffset);
+        pDevice->byRxMode &= ~(RCR_UNICAST);
+        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
+    }
+
+    if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
+        // If AP mode, don't enable RCR_UNICAST. Since hw only compare addr1 with local mac.
+        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
+        pDevice->byRxMode &= ~(RCR_UNICAST);
+    }
+
+    VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byRxMode);
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode = %x\n", pDevice->byRxMode );
+}
+
+
+#ifdef PRIVATE_OBJ
+
+struct net_device_stats *__device_get_stats(HANDLE pExDevice) {
+    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
+    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
+
+#else
+static struct net_device_stats *device_get_stats(struct net_device *dev) {
+    PSDevice pDevice=(PSDevice) dev->priv;
+#endif
+
+    return &pDevice->stats;
+}
+
+
+#ifdef PRIVATE_OBJ
+
+int __device_ioctl(HANDLE pExDevice, struct ifreq *rq, int cmd) {
+    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
+    struct net_device *dev = pDevice_info->dev;
+    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
+
+#else
+
+static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
+	PSDevice	        pDevice = (PSDevice)dev->priv;
+#endif
+
+#ifdef WIRELESS_EXT
+	struct iwreq *wrq = (struct iwreq *) rq;
+	int                 rc =0;
+#endif
+    PSMgmtObject        pMgmt = pDevice->pMgmt;
+    PSCmdRequest        pReq;
+
+
+    if (pMgmt == NULL) {
+        rc = -EFAULT;
+        return rc;
+    }
+
+    switch(cmd) {
+
+#ifdef WIRELESS_EXT
+//#if WIRELESS_EXT < 13
+
+	case SIOCGIWNAME:
+		rc = iwctl_giwname(dev, NULL, (char *)&(wrq->u.name), NULL);
+		break;
+
+	case SIOCGIWNWID:     //0x8b03  support
+	#ifdef  WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+          rc = iwctl_giwnwid(dev, NULL, &(wrq->u.nwid), NULL);
+	#else
+        rc = -EOPNOTSUPP;
+	#endif
+		break;
+
+		// Set frequency/channel
+	case SIOCSIWFREQ:
+	    rc = iwctl_siwfreq(dev, NULL, &(wrq->u.freq), NULL);
+		break;
+
+		// Get frequency/channel
+	case SIOCGIWFREQ:
+		rc = iwctl_giwfreq(dev, NULL, &(wrq->u.freq), NULL);
+		break;
+
+		// Set desired network name (ESSID)
+	case SIOCSIWESSID:
+
+		{
+			char essid[IW_ESSID_MAX_SIZE+1];
+			if (wrq->u.essid.length > IW_ESSID_MAX_SIZE) {
+				rc = -E2BIG;
+				break;
+			}
+			if (copy_from_user(essid, wrq->u.essid.pointer,
+					   wrq->u.essid.length)) {
+				rc = -EFAULT;
+				break;
+			}
+			rc = iwctl_siwessid(dev, NULL,
+					    &(wrq->u.essid), essid);
+		}
+		break;
+
+
+		// Get current network name (ESSID)
+	case SIOCGIWESSID:
+
+		{
+			char essid[IW_ESSID_MAX_SIZE+1];
+			if (wrq->u.essid.pointer)
+				rc = iwctl_giwessid(dev, NULL,
+						    &(wrq->u.essid), essid);
+				if (copy_to_user(wrq->u.essid.pointer,
+						         essid,
+						         wrq->u.essid.length) )
+					rc = -EFAULT;
+		}
+		break;
+
+	case SIOCSIWAP:
+
+		rc = iwctl_siwap(dev, NULL, &(wrq->u.ap_addr), NULL);
+		break;
+
+
+		// Get current Access Point (BSSID)
+	case SIOCGIWAP:
+		rc = iwctl_giwap(dev, NULL, &(wrq->u.ap_addr), NULL);
+		break;
+
+
+		// Set desired station name
+	case SIOCSIWNICKN:
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN \n");
+        rc = -EOPNOTSUPP;
+		break;
+
+		// Get current station name
+	case SIOCGIWNICKN:
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWNICKN \n");
+        rc = -EOPNOTSUPP;
+		break;
+
+		// Set the desired bit-rate
+	case SIOCSIWRATE:
+		rc = iwctl_siwrate(dev, NULL, &(wrq->u.bitrate), NULL);
+		break;
+
+	// Get the current bit-rate
+	case SIOCGIWRATE:
+
+		rc = iwctl_giwrate(dev, NULL, &(wrq->u.bitrate), NULL);
+		break;
+
+	// Set the desired RTS threshold
+	case SIOCSIWRTS:
+
+		rc = iwctl_siwrts(dev, NULL, &(wrq->u.rts), NULL);
+		break;
+
+	// Get the current RTS threshold
+	case SIOCGIWRTS:
+
+		rc = iwctl_giwrts(dev, NULL, &(wrq->u.rts), NULL);
+		break;
+
+		// Set the desired fragmentation threshold
+	case SIOCSIWFRAG:
+
+		rc = iwctl_siwfrag(dev, NULL, &(wrq->u.frag), NULL);
+	    break;
+
+	// Get the current fragmentation threshold
+	case SIOCGIWFRAG:
+
+		rc = iwctl_giwfrag(dev, NULL, &(wrq->u.frag), NULL);
+		break;
+
+		// Set mode of operation
+	case SIOCSIWMODE:
+    	rc = iwctl_siwmode(dev, NULL, &(wrq->u.mode), NULL);
+		break;
+
+		// Get mode of operation
+	case SIOCGIWMODE:
+		rc = iwctl_giwmode(dev, NULL, &(wrq->u.mode), NULL);
+		break;
+
+		// Set WEP keys and mode
+	case SIOCSIWENCODE:
+		{
+            char abyKey[WLAN_WEP232_KEYLEN];
+
+			if (wrq->u.encoding.pointer) {
+
+
+				if (wrq->u.encoding.length > WLAN_WEP232_KEYLEN) {
+					rc = -E2BIG;
+					break;
+				}
+				memset(abyKey, 0, WLAN_WEP232_KEYLEN);
+				if (copy_from_user(abyKey,
+				                  wrq->u.encoding.pointer,
+				                  wrq->u.encoding.length)) {
+					rc = -EFAULT;
+					break;
+				}
+			} else if (wrq->u.encoding.length != 0) {
+				rc = -EINVAL;
+				break;
+			}
+			rc = iwctl_siwencode(dev, NULL, &(wrq->u.encoding), abyKey);
+		}
+		break;
+
+		// Get the WEP keys and mode
+	case SIOCGIWENCODE:
+
+		if (!capable(CAP_NET_ADMIN)) {
+			rc = -EPERM;
+			break;
+		}
+		{
+		    char abyKey[WLAN_WEP232_KEYLEN];
+
+		    rc = iwctl_giwencode(dev, NULL, &(wrq->u.encoding), abyKey);
+		    if (rc != 0) break;
+			if (wrq->u.encoding.pointer) {
+				if (copy_to_user(wrq->u.encoding.pointer,
+						        abyKey,
+						        wrq->u.encoding.length))
+					rc = -EFAULT;
+			}
+		}
+		break;
+
+#if WIRELESS_EXT > 9
+		// Get the current Tx-Power
+	case SIOCGIWTXPOW:
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
+        rc = -EOPNOTSUPP;
+		break;
+
+	case SIOCSIWTXPOW:
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
+        rc = -EOPNOTSUPP;
+		break;
+
+#endif // WIRELESS_EXT > 9
+
+#if WIRELESS_EXT > 10
+	case SIOCSIWRETRY:
+
+		rc = iwctl_siwretry(dev, NULL, &(wrq->u.retry), NULL);
+		break;
+
+	case SIOCGIWRETRY:
+
+		rc = iwctl_giwretry(dev, NULL, &(wrq->u.retry), NULL);
+		break;
+
+#endif // WIRELESS_EXT > 10
+
+		// Get range of parameters
+	case SIOCGIWRANGE:
+
+		{
+			struct iw_range range;
+
+			rc = iwctl_giwrange(dev, NULL, &(wrq->u.data), (char *) &range);
+			if (copy_to_user(wrq->u.data.pointer, &range, sizeof(struct iw_range)))
+				rc = -EFAULT;
+		}
+
+		break;
+
+	case SIOCGIWPOWER:
+
+		rc = iwctl_giwpower(dev, NULL, &(wrq->u.power), NULL);
+		break;
+
+
+	case SIOCSIWPOWER:
+
+		rc = iwctl_siwpower(dev, NULL, &(wrq->u.power), NULL);
+		break;
+
+
+	case SIOCGIWSENS:
+
+	    rc = iwctl_giwsens(dev, NULL, &(wrq->u.sens), NULL);
+		break;
+
+	case SIOCSIWSENS:
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSENS \n");
+		rc = -EOPNOTSUPP;
+		break;
+
+	case SIOCGIWAPLIST:
+	    {
+            char buffer[IW_MAX_AP * (sizeof(struct sockaddr) + sizeof(struct iw_quality))];
+
+		    if (wrq->u.data.pointer) {
+		        rc = iwctl_giwaplist(dev, NULL, &(wrq->u.data), buffer);
+		        if (rc == 0) {
+                    if (copy_to_user(wrq->u.data.pointer,
+					                buffer,
+					               (wrq->u.data.length * (sizeof(struct sockaddr) +  sizeof(struct iw_quality)))
+				        ))
+				    rc = -EFAULT;
+		        }
+            }
+        }
+		break;
+
+
+#ifdef WIRELESS_SPY
+		// Set the spy list
+	case SIOCSIWSPY:
+
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
+		rc = -EOPNOTSUPP;
+		break;
+
+		// Get the spy list
+	case SIOCGIWSPY:
+
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
+		rc = -EOPNOTSUPP;
+		break;
+
+#endif // WIRELESS_SPY
+
+	case SIOCGIWPRIV:
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV \n");
+		rc = -EOPNOTSUPP;
+/*
+		if(wrq->u.data.pointer) {
+			wrq->u.data.length = sizeof(iwctl_private_args) / sizeof( iwctl_private_args[0]);
+
+			if(copy_to_user(wrq->u.data.pointer,
+					(u_char *) iwctl_private_args,
+					sizeof(iwctl_private_args)))
+				rc = -EFAULT;
+		}
+*/
+		break;
+
+
+//#endif // WIRELESS_EXT < 13
+//2008-0409-07, <Add> by Einsn Liu
+#ifdef  WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+	case SIOCSIWAUTH:
+		DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAUTH \n");
+		rc = iwctl_siwauth(dev, NULL, &(wrq->u.param), NULL);
+		break;
+
+	case SIOCGIWAUTH:
+		DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWAUTH \n");
+		rc = iwctl_giwauth(dev, NULL, &(wrq->u.param), NULL);
+		break;
+
+	case SIOCSIWGENIE:
+		DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWGENIE \n");
+		rc = iwctl_siwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
+		break;
+
+	case SIOCGIWGENIE:
+		DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWGENIE \n");
+		rc = iwctl_giwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
+		break;
+
+	case SIOCSIWENCODEEXT:
+		{
+			char extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];
+			DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT \n");
+			if(wrq->u.encoding.pointer){
+				memset(extra, 0, sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1);
+				if(wrq->u.encoding.length > (sizeof(struct iw_encode_ext)+ MAX_KEY_LEN)){
+					rc = -E2BIG;
+					break;
+				}
+				if(copy_from_user(extra, wrq->u.encoding.pointer,wrq->u.encoding.length)){
+					rc = -EFAULT;
+					break;
+				}
+			}else if(wrq->u.encoding.length != 0){
+				rc = -EINVAL;
+				break;
+			}
+			rc = iwctl_siwencodeext(dev, NULL, &(wrq->u.encoding), extra);
+		}
+		break;
+
+	case SIOCGIWENCODEEXT:
+		DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWENCODEEXT \n");
+		rc = iwctl_giwencodeext(dev, NULL, &(wrq->u.encoding), NULL);
+		break;
+
+	case SIOCSIWMLME:
+		DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWMLME \n");
+		rc = iwctl_siwmlme(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
+		break;
+
+#endif // #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+//End Add -- //2008-0409-07, <Add> by Einsn Liu
+
+#endif // WIRELESS_EXT
+
+    case IOCTL_CMD_TEST:
+
+		if (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {
+		    rc = -EFAULT;
+		    break;
+		} else {
+		    rc = 0;
+		}
+        pReq = (PSCmdRequest)rq;
+        pReq->wResult = MAGIC_CODE;
+        break;
+
+    case IOCTL_CMD_SET:
+
+               #ifdef SndEvt_ToAPI
+                  if((((PSCmdRequest)rq)->wCmdCode !=WLAN_CMD_SET_EVT) &&
+		       !(pDevice->flags & DEVICE_FLAGS_OPENED))
+	      #else
+		if (!(pDevice->flags & DEVICE_FLAGS_OPENED) &&
+		       (((PSCmdRequest)rq)->wCmdCode !=WLAN_CMD_SET_WPA))
+	      #endif
+		{
+		    rc = -EFAULT;
+		    break;
+		} else {
+		    rc = 0;
+		}
+
+	    if (test_and_set_bit( 0, (void*)&(pMgmt->uCmdBusy))) {
+		    return -EBUSY;
+	    }
+        rc = private_ioctl(pDevice, rq);
+        clear_bit( 0, (void*)&(pMgmt->uCmdBusy));
+        break;
+
+    case IOCTL_CMD_HOSTAPD:
+
+
+#if WIRELESS_EXT > 8
+		rc = hostap_ioctl(pDevice, &wrq->u.data);
+#else // WIRELESS_EXT > 8
+		rc = hostap_ioctl(pDevice, (struct iw_point *) &wrq->u.data);
+#endif // WIRELESS_EXT > 8
+        break;
+
+    case IOCTL_CMD_WPA:
+
+#if WIRELESS_EXT > 8
+		rc = wpa_ioctl(pDevice, &wrq->u.data);
+#else // WIRELESS_EXT > 8
+		rc = wpa_ioctl(pDevice, (struct iw_point *) &wrq->u.data);
+#endif // WIRELESS_EXT > 8
+        break;
+
+	case SIOCETHTOOL:
+        return ethtool_ioctl(dev, (void *) rq->ifr_data);
+	// All other calls are currently unsupported
+
+	default:
+		rc = -EOPNOTSUPP;
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Ioctl command not support..%x\n", cmd);
+
+
+    }
+
+    if (pDevice->bCommit) {
+       if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
+           netif_stop_queue(pDevice->dev);
+           spin_lock_irq(&pDevice->lock);
+           bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RUN_AP, NULL);
+           spin_unlock_irq(&pDevice->lock);
+       }
+       else {
+           DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Commit the settings\n");
+           spin_lock_irq(&pDevice->lock);
+           pDevice->bLinkPass = FALSE;
+           memset(pMgmt->abyCurrBSSID, 0, 6);
+           pMgmt->eCurrState = WMAC_STATE_IDLE;
+           netif_stop_queue(pDevice->dev);
+	#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+	      pMgmt->eScanType = WMAC_SCAN_ACTIVE;
+	 if(pDevice->bWPASuppWextEnabled !=TRUE)
+	 #endif
+           bScheduleCommand((HANDLE) pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);
+           bScheduleCommand((HANDLE) pDevice, WLAN_CMD_SSID, NULL);
+           spin_unlock_irq(&pDevice->lock);
+      }
+      pDevice->bCommit = FALSE;
+    }
+
+    return rc;
+}
+
+
+static int ethtool_ioctl(struct net_device *dev, void *useraddr)
+{
+	u32 ethcmd;
+
+	if (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))
+		return -EFAULT;
+
+        switch (ethcmd) {
+	case ETHTOOL_GDRVINFO: {
+		struct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};
+		strncpy(info.driver, DEVICE_NAME, sizeof(info.driver)-1);
+		strncpy(info.version, DEVICE_VERSION, sizeof(info.version)-1);
+		if (copy_to_user(useraddr, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+
+        }
+
+	return -EOPNOTSUPP;
+}
+
+/*------------------------------------------------------------------*/
+#ifndef PRIVATE_OBJ
+
+MODULE_DEVICE_TABLE(pci, device_id_table);
+
+static struct pci_driver device_driver = {
+        name:       DEVICE_NAME,
+        id_table:   device_id_table,
+        probe:      device_found1,
+        remove:     device_remove1,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
+#ifdef CONFIG_PM
+        suspend:    viawget_suspend,
+        resume:     viawget_resume,
+#endif
+#endif
+};
+
+static int __init device_init_module(void)
+{
+    int ret;
+
+
+//    ret=pci_module_init(&device_driver);
+	//ret = pcie_port_service_register(&device_driver);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+	ret = pci_register_driver(&device_driver);
+#else
+	ret = pci_module_init(&device_driver);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
+#ifdef CONFIG_PM
+    if(ret >= 0)
+        register_reboot_notifier(&device_notifier);
+#endif
+#endif
+
+    return ret;
+}
+
+static void __exit device_cleanup_module(void)
+{
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
+#ifdef CONFIG_PM
+    unregister_reboot_notifier(&device_notifier);
+#endif
+#endif
+    pci_unregister_driver(&device_driver);
+
+}
+
+module_init(device_init_module);
+module_exit(device_cleanup_module);
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
+#ifdef CONFIG_PM
+static int
+device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
+{
+    struct pci_dev *pdev = NULL;
+    switch(event) {
+    case SYS_DOWN:
+    case SYS_HALT:
+    case SYS_POWER_OFF:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        while ((pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) != NULL) {
+#else
+        pci_for_each_dev(pdev) {
+#endif
+            if(pci_dev_driver(pdev) == &device_driver) {
+                if (pci_get_drvdata(pdev))
+                    viawget_suspend(pdev, 3);
+            }
+        }
+    }
+    return NOTIFY_DONE;
+}
+
+static int
+viawget_suspend(struct pci_dev *pcid, u32 state)
+{
+    int power_status;   // to silence the compiler
+
+    PSDevice pDevice=pci_get_drvdata(pcid);
+    PSMgmtObject  pMgmt = pDevice->pMgmt;
+
+    netif_stop_queue(pDevice->dev);
+    spin_lock_irq(&pDevice->lock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
+    pci_save_state(pcid);
+#else
+    pci_save_state(pcid, pDevice->pci_state);
+#endif
+    del_timer(&pDevice->sTimerCommand);
+    del_timer(&pMgmt->sTimerSecondCallback);
+    pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
+    pDevice->uCmdDequeueIdx = 0;
+    pDevice->uCmdEnqueueIdx = 0;
+    pDevice->bCmdRunning = FALSE;
+    MACbShutdown(pDevice->PortOffset);
+    MACvSaveContext(pDevice->PortOffset, pDevice->abyMacContext);
+    pDevice->bLinkPass = FALSE;
+    memset(pMgmt->abyCurrBSSID, 0, 6);
+    pMgmt->eCurrState = WMAC_STATE_IDLE;
+    pci_disable_device(pcid);
+    power_status = pci_set_power_state(pcid, state);
+    spin_unlock_irq(&pDevice->lock);
+    return 0;
+}
+
+static int
+viawget_resume(struct pci_dev *pcid)
+{
+    PSDevice  pDevice=pci_get_drvdata(pcid);
+    PSMgmtObject  pMgmt = pDevice->pMgmt;
+    int power_status;   // to silence the compiler
+
+
+    power_status = pci_set_power_state(pcid, 0);
+    power_status = pci_enable_wake(pcid, 0, 0);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
+    pci_restore_state(pcid);
+#else
+    pci_restore_state(pcid, pDevice->pci_state);
+#endif
+    if (netif_running(pDevice->dev)) {
+        spin_lock_irq(&pDevice->lock);
+        MACvRestoreContext(pDevice->PortOffset, pDevice->abyMacContext);
+        device_init_registers(pDevice, DEVICE_INIT_DXPL);
+        if (pMgmt->sNodeDBTable[0].bActive == TRUE) { // Assoc with BSS
+            pMgmt->sNodeDBTable[0].bActive = FALSE;
+            pDevice->bLinkPass = FALSE;
+            if(pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
+                // In Adhoc, BSS state set back to started.
+                pMgmt->eCurrState = WMAC_STATE_STARTED;
+           }
+            else {
+                pMgmt->eCurrMode = WMAC_MODE_STANDBY;
+                pMgmt->eCurrState = WMAC_STATE_IDLE;
+            }
+        }
+        init_timer(&pMgmt->sTimerSecondCallback);
+        init_timer(&pDevice->sTimerCommand);
+        MACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);
+        BSSvClearBSSList((HANDLE)pDevice, pDevice->bLinkPass);
+        bScheduleCommand((HANDLE) pDevice, WLAN_CMD_BSSID_SCAN, NULL);
+        bScheduleCommand((HANDLE) pDevice, WLAN_CMD_SSID, NULL);
+        spin_unlock_irq(&pDevice->lock);
+    }
+    return 0;
+}
+
+#endif
+#endif
+
+#endif //#ifndef PRIVATE_OBJ
+
+#ifdef PRIVATE_OBJ
+
+
+int __device_hw_reset(HANDLE pExDevice){
+     PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
+
+     return MACbSoftwareReset(pDevice_info->port_offset);
+}
+
+
+int __device_hw_init(HANDLE pExDevice){
+    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
+    PSDevice    pDevice;
+
+
+    pDevice = (PSDevice)kmalloc(sizeof(DEVICE_INFO), (int)GFP_ATOMIC);
+    if (pDevice == NULL)
+        return FALSE;
+
+    memset(pDevice, 0, sizeof(DEVICE_INFO));
+    pDevice_info->pWDevice = pDevice;
+    pDevice->PortOffset = pDevice_info->port_offset;
+    pDevice->dev = pDevice_info->dev;
+    pDevice->pcid = pDevice_info->pcid;
+    pDevice->chip_id = pDevice_info->chip_id;
+    pDevice->memaddr = pDevice_info->mem_addr;
+    pDevice->ioaddr = pDevice_info->io_addr;
+    pDevice->io_size = pDevice_info->io_size;
+    pDevice->nTxQueues = pDevice_info->nTxQueues;
+    pDevice->multicast_limit = pDevice_info->multicast_limit;
+    pDevice->sMgmtObj.pAdapter = (PVOID)pDevice;
+    pDevice->pMgmt = &(pDevice->sMgmtObj);
+    MACvInitialize(pDevice->PortOffset);
+    device_get_options(pDevice, 0 , pDevice_info->dev->name);
+    device_set_options(pDevice);
+    pDevice->sOpts.flags &= pDevice_info->flags;
+    pDevice->flags = pDevice->sOpts.flags | (pDevice_info->flags & 0xFF000000UL);
+    spin_lock_init(&(pDevice->lock));
+
+    return TRUE;
+}
+
+
+void __device_read_mac(HANDLE pExDevice, PBYTE dev_addr){
+    PSDevice_info pDevice_info = (PSDevice_info)pExDevice;
+    PSDevice    pDevice = (PSDevice)(pDevice_info->pWDevice);
+
+    MACvReadEtherAddress(pDevice->PortOffset, dev_addr);
+    return;
+}
+
+
+#endif
+
+
