commit d6ff1b52b569dc12ba5be027bc6c22f4ac0f4ce1
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Jul 11 12:47:28 2018 +0100

    staging: vt6655: remove some redundant variables
    
    Variables rx_sts, sq, frame and is_pspoll are being assigned but are
    never used hence they are redundant and can be removed.
    
    Cleans up clang warnings:
    warning: variable 'sq' set but not used [-Wunused-but-set-variable]
    warning: variable 'rx_sts' set but not used [-Wunused-but-set-variable]
    warning: variable 'frame' set but not used [-Wunused-but-set-variable]
    warning: variable 'is_pspoll' set but not used [-Wunused-but-set-variable]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 088d2d9dbc21..52214a30e9b6 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -34,7 +34,7 @@ static bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,
 	__le64 *tsf_time;
 	u16 frame_size;
 	int ii, r;
-	u8 *rx_sts, *rx_rate, *sq;
+	u8 *rx_rate;
 	u8 *skb_data;
 	u8 rate_idx = 0;
 	u8 rate[MAX_RATE] = {2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108};
@@ -49,7 +49,6 @@ static bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,
 
 	skb_data = (u8 *)skb->data;
 
-	rx_sts = skb_data;
 	rx_rate = skb_data + 1;
 
 	sband = hw->wiphy->bands[hw->conf.chandef.chan->band];
@@ -74,7 +73,6 @@ static bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,
 	}
 
 	tsf_time = (__le64 *)(skb_data + bytes_received - 12);
-	sq = skb_data + bytes_received - 4;
 	new_rsr = skb_data + bytes_received - 3;
 	rssi = skb_data + bytes_received - 2;
 	rsr = skb_data + bytes_received - 1;

commit dbc9f36cf7bc6d431c63c4785ad3c4bc0f306588
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 21:07:56 2017 +0100

    staging: vt6655: Remove redundant license text
    
    Now that the SPDX tag is in all vt6655 files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 4dd164df78fa..088d2d9dbc21 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -3,16 +3,6 @@
  * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  * All rights reserved.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * File: dpc.c
  *
  * Purpose: handle dpc rx functions

commit d7c43082fc0d178a29a7ea1dcc9729abd38c7cf8
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 21:07:53 2017 +0100

    staging: vt6655: add SPDX identifiers to all vt6655 driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the vt6655 driver files with the correct SPDX license identifier
    based on the license text in the file itself.  The SPDX identifier is a
    legally binding shorthand, which can be used instead of the full boiler
    plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Forest Bond <forest@alittletooquiet.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 9b3fa779258a..4dd164df78fa 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  * All rights reserved.

commit 21971f3e0e558db280c9b01d461364e8442d0ef9
Author: Varsha Rao <rvarsha016@gmail.com>
Date:   Tue Oct 11 19:05:46 2016 +0530

    staging: vt6655: Removes the FSF mailing address.
    
    This patch fixes the checkpatch issue by removing the Free Software
    Foundation's mailing address from the sample GPL notice. Because the FSF
    has changed address in the past, and may change again. Linux already
    includes a copy of the GPL.
    
    Signed-off-by: Varsha Rao <rvarsha016@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 700032e9c477..9b3fa779258a 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -12,10 +12,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
  * File: dpc.c
  *
  * Purpose: handle dpc rx functions

commit 9cb693f6f326ddf8f9df9c2bb3302048a919b394
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Aug 15 21:57:35 2015 +0100

    staging: vt6655: replace typedef struct tagSRxDesc
    
    with struct vnt_rx_desc and all members the same.
    
    volatile is removed from pointers as this generates warning
    message.
    
    Only the first four members of vnt_rx_desc need to be volatile.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 46591859f544..700032e9c477 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -132,7 +132,7 @@ static bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,
 	return true;
 }
 
-bool vnt_receive_frame(struct vnt_private *priv, PSRxDesc curr_rd)
+bool vnt_receive_frame(struct vnt_private *priv, struct vnt_rx_desc *curr_rd)
 {
 	struct vnt_rd_info *rd_info = curr_rd->rd_info;
 	struct sk_buff *skb;

commit 88defe2b35f1b765dbfe9a800c443c31400a4e13
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Aug 15 21:57:34 2015 +0100

    staging: vt6655: replace typedef struct tagDEVICE_RD_INFO
    
    with struct vnt_rd_info
    
    volatile is removed because it will generate a warning
    (in any case this member is not) and renaming rd_info.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index ef39cbe28940..46591859f544 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -134,7 +134,7 @@ static bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,
 
 bool vnt_receive_frame(struct vnt_private *priv, PSRxDesc curr_rd)
 {
-	PDEVICE_RD_INFO rd_info = curr_rd->pRDInfo;
+	struct vnt_rd_info *rd_info = curr_rd->rd_info;
 	struct sk_buff *skb;
 	u16 frame_size;
 

commit 9fc7091cc24ceae25885a3ad074689cfb029f3c0
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Aug 15 21:57:33 2015 +0100

    staging: vt6655: replace typedef struct tagRDES1
    
    with struct vnt_rdes1 and members
    wReqCount -> req_count
    wReserved -> reserved
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index dbaaeeb94817..ef39cbe28940 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -143,7 +143,7 @@ bool vnt_receive_frame(struct vnt_private *priv, PSRxDesc curr_rd)
 	dma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,
 			 priv->rx_buf_sz, DMA_FROM_DEVICE);
 
-	frame_size = le16_to_cpu(curr_rd->m_rd1RD1.wReqCount)
+	frame_size = le16_to_cpu(curr_rd->rd1.req_count)
 			- le16_to_cpu(curr_rd->rd0.res_count);
 
 	if ((frame_size > 2364) || (frame_size < 33)) {

commit de1c1862ca8c32a811021b61ce8905d03e53a451
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Aug 15 21:57:32 2015 +0100

    staging: vt6655: replace typedef struct tagRDES0
    
    with struct vnt_rdes0 replacing members as follows
    wResCount -> res_count
    f15Reserved -> f15_reserved
    f1Owner -> owner
    
    big endian
    f8Reserved1 -> f8_reserved1
    f7Reserved -> f7_reserved
    
    Narrowing endian differences to inside structure.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index e14eed160a19..dbaaeeb94817 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -144,7 +144,7 @@ bool vnt_receive_frame(struct vnt_private *priv, PSRxDesc curr_rd)
 			 priv->rx_buf_sz, DMA_FROM_DEVICE);
 
 	frame_size = le16_to_cpu(curr_rd->m_rd1RD1.wReqCount)
-			- le16_to_cpu(curr_rd->m_rd0RD0.wResCount);
+			- le16_to_cpu(curr_rd->rd0.res_count);
 
 	if ((frame_size > 2364) || (frame_size < 33)) {
 		/* Frame Size error drop this packet.*/

commit 7135d9a76f787f089faad0e08bdef259cb019d64
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jul 22 19:16:43 2015 +0100

    staging: vt6655: Fix wReqCount to __le16
    
    Should be __le16 and do and correct endian conversion.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index b25ee962558d..e14eed160a19 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -144,7 +144,7 @@ bool vnt_receive_frame(struct vnt_private *priv, PSRxDesc curr_rd)
 			 priv->rx_buf_sz, DMA_FROM_DEVICE);
 
 	frame_size = le16_to_cpu(curr_rd->m_rd1RD1.wReqCount)
-			- cpu_to_le16(curr_rd->m_rd0RD0.wResCount);
+			- le16_to_cpu(curr_rd->m_rd0RD0.wResCount);
 
 	if ((frame_size > 2364) || (frame_size < 33)) {
 		/* Frame Size error drop this packet.*/

commit a1c6dcda80f6dbb3e9b78809235695e8828994f9
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Thu Mar 19 14:18:56 2015 +0100

    staging: vt6655: remove deprecated use of pci api
    
    Replace occurences of the pci api by appropriate call to the dma api.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    )
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 3c5b87ffdcac..b25ee962558d 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -140,8 +140,8 @@ bool vnt_receive_frame(struct vnt_private *priv, PSRxDesc curr_rd)
 
 	skb = rd_info->skb;
 
-	pci_unmap_single(priv->pcid, rd_info->skb_dma,
-			 priv->rx_buf_sz, PCI_DMA_FROMDEVICE);
+	dma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,
+			 priv->rx_buf_sz, DMA_FROM_DEVICE);
 
 	frame_size = le16_to_cpu(curr_rd->m_rd1RD1.wReqCount)
 			- cpu_to_le16(curr_rd->m_rd0RD0.wResCount);

commit 6d854127268010f98c66c9e93fd278c2d76a6562
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Feb 1 11:59:41 2015 +0000

    staging: vt6655: vnt_rx_data add track rsr and new_rsr errors
    
    If not rsr & RSR_CRCOK report RX_FLAG_FAILED_FCS_CRC
    
    If not rsr & (RSR_IVLDTYP | RSR_IVLDLEN) drop packet
    
    If not NEWRSR_DECRYPTOK on new_rsr drop packet.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 11cc09014a52..3c5b87ffdcac 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -91,6 +91,8 @@ static bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,
 	new_rsr = skb_data + bytes_received - 3;
 	rssi = skb_data + bytes_received - 2;
 	rsr = skb_data + bytes_received - 1;
+	if (*rsr & (RSR_IVLDTYP | RSR_IVLDLEN))
+		return false;
 
 	RFvRSSITodBm(priv, *rssi, &rx_dbm);
 
@@ -106,6 +108,9 @@ static bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,
 	rx_status.flag = 0;
 	rx_status.freq = hw->conf.chandef.chan->center_freq;
 
+	if (!(*rsr & RSR_CRCOK))
+		rx_status.flag |= RX_FLAG_FAILED_FCS_CRC;
+
 	hdr = (struct ieee80211_hdr *)(skb->data);
 	fc = hdr->frame_control;
 
@@ -113,7 +118,11 @@ static bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,
 
 	if (ieee80211_has_protected(fc)) {
 		if (priv->byLocalID > REV_ID_VT3253_A1)
-			rx_status.flag = RX_FLAG_DECRYPTED;
+			rx_status.flag |= RX_FLAG_DECRYPTED;
+
+		/* Drop packet */
+		if (!(*new_rsr & NEWRSR_DECRYPTOK))
+			return false;
 	}
 
 	memcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));

commit e6f534bc2fbda029ddc43d816151893454224e52
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Jan 19 18:24:12 2015 +0000

    staging: vt6655: remove antenna diversity functions
    
    The vendor had disabled these functions in their last version.
    
    On test this can be troublesome, so remove this from the driver along
    with its macros and timers.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 977683cb7391..11cc09014a52 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -116,12 +116,6 @@ static bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,
 			rx_status.flag = RX_FLAG_DECRYPTED;
 	}
 
-	if (priv->vif && priv->bDiversityEnable) {
-		if (ieee80211_is_data(fc) &&
-		    (frame_size > 50) && priv->vif->bss_conf.assoc)
-			BBvAntennaDiversity(priv, priv->rx_rate, 0);
-	}
-
 	memcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));
 
 	ieee80211_rx_irqsafe(priv->hw, skb);

commit 01b8979244ee164dd90958521ed9aecec9dafe3f
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:26 2014 +0000

    staging: vt6655: dpc.c/h remove dead functions
    
    s_byGetRateIdx
    s_vGetDASA
    s_vProcessRxMACHeader
    s_bAPModeRxCtl
    s_bAPModeRxData
    s_bHandleRxEncryption
    s_bHostWepRxEncryption
    s_vProcessRxMACHeader
    s_byGetRateIdx
    s_vGetDASA
    device_receive_frame
    s_bAPModeRxCtl
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 6842baf73ed1..977683cb7391 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -25,1302 +25,16 @@
  * Date: May 20, 2003
  *
  * Functions:
- *      device_receive_frame - Rcv 802.11 frame function
- *      s_bAPModeRxCtl- AP Rcv frame filer Ctl.
- *      s_bAPModeRxData- AP Rcv data frame handle
- *      s_bHandleRxEncryption- Rcv decrypted data via on-fly
- *      s_bHostWepRxEncryption- Rcv encrypted data via host
- *      s_byGetRateIdx- get rate index
- *      s_vGetDASA- get data offset
- *      s_vProcessRxMACHeader- Rcv 802.11 and translate to 802.3
  *
  * Revision History:
  *
  */
 
 #include "device.h"
-#include "rxtx.h"
-#include "tether.h"
-#include "card.h"
-#include "bssdb.h"
-#include "mac.h"
 #include "baseband.h"
-#include "michael.h"
-#include "tkip.h"
-#include "tcrc.h"
-#include "wctl.h"
-#include "wroute.h"
 #include "rf.h"
-#include "iowpa.h"
-#include "aes_ccmp.h"
 #include "dpc.h"
 
-/*---------------------  Static Definitions -------------------------*/
-
-/*---------------------  Static Classes  ----------------------------*/
-
-/*---------------------  Static Variables  --------------------------*/
-static const unsigned char acbyRxRate[MAX_RATE] =
-{2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108};
-
-/*---------------------  Static Functions  --------------------------*/
-
-/*---------------------  Static Definitions -------------------------*/
-
-/*---------------------  Static Functions  --------------------------*/
-
-static unsigned char s_byGetRateIdx(unsigned char byRate);
-
-static void
-s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
-	   PSEthernetHeader psEthHeader);
-
-static void
-s_vProcessRxMACHeader(struct vnt_private *pDevice, unsigned char *pbyRxBufferAddr,
-		      unsigned int cbPacketSize, bool bIsWEP, bool bExtIV,
-		      unsigned int *pcbHeadSize);
-
-static bool s_bAPModeRxCtl(
-	struct vnt_private *pDevice,
-	unsigned char *pbyFrame,
-	int      iSANodeIndex
-);
-
-static bool s_bAPModeRxData(
-	struct vnt_private *pDevice,
-	struct sk_buff *skb,
-	unsigned int FrameSize,
-	unsigned int cbHeaderOffset,
-	int      iSANodeIndex,
-	int      iDANodeIndex
-);
-
-static bool s_bHandleRxEncryption(
-	struct vnt_private *pDevice,
-	unsigned char *pbyFrame,
-	unsigned int FrameSize,
-	unsigned char *pbyRsr,
-	unsigned char *pbyNewRsr,
-	PSKeyItem   *pKeyOut,
-	bool *pbExtIV,
-	unsigned short *pwRxTSC15_0,
-	unsigned long *pdwRxTSC47_16
-);
-
-static bool s_bHostWepRxEncryption(
-
-	struct vnt_private *pDevice,
-	unsigned char *pbyFrame,
-	unsigned int FrameSize,
-	unsigned char *pbyRsr,
-	bool bOnFly,
-	PSKeyItem    pKey,
-	unsigned char *pbyNewRsr,
-	bool *pbExtIV,
-	unsigned short *pwRxTSC15_0,
-	unsigned long *pdwRxTSC47_16
-
-);
-
-/*---------------------  Export Variables  --------------------------*/
-
-/*+
- *
- * Description:
- *    Translate Rcv 802.11 header to 802.3 header with Rx buffer
- *
- * Parameters:
- *  In:
- *      pDevice
- *      dwRxBufferAddr  - Address of Rcv Buffer
- *      cbPacketSize    - Rcv Packet size
- *      bIsWEP          - If Rcv with WEP
- *  Out:
- *      pcbHeaderSize   - 802.11 header size
- *
- * Return Value: None
- *
- -*/
-static void
-s_vProcessRxMACHeader(struct vnt_private *pDevice,
-		      unsigned char *pbyRxBufferAddr,
-		      unsigned int cbPacketSize, bool bIsWEP, bool bExtIV,
-		      unsigned int *pcbHeadSize)
-{
-	unsigned char *pbyRxBuffer;
-	unsigned int cbHeaderSize = 0;
-	unsigned short *pwType;
-	PS802_11Header  pMACHeader;
-	int             ii;
-
-	pMACHeader = (PS802_11Header) (pbyRxBufferAddr + cbHeaderSize);
-
-	s_vGetDASA((unsigned char *)pMACHeader, &cbHeaderSize, &pDevice->sRxEthHeader);
-
-	if (bIsWEP) {
-		if (bExtIV) {
-			/* strip IV&ExtIV, add 8 byte */
-			cbHeaderSize += (WLAN_HDR_ADDR3_LEN + 8);
-		} else {
-			/* strip IV, add 4 byte */
-			cbHeaderSize += (WLAN_HDR_ADDR3_LEN + 4);
-		}
-	} else {
-		cbHeaderSize += WLAN_HDR_ADDR3_LEN;
-	}
-
-	pbyRxBuffer = (unsigned char *)(pbyRxBufferAddr + cbHeaderSize);
-	if (ether_addr_equal(pbyRxBuffer, pDevice->abySNAP_Bridgetunnel)) {
-		cbHeaderSize += 6;
-	} else if (ether_addr_equal(pbyRxBuffer, pDevice->abySNAP_RFC1042)) {
-		cbHeaderSize += 6;
-		pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
-		if ((*pwType != TYPE_PKT_IPX) && (*pwType != cpu_to_le16(0xF380))) {
-		} else {
-			cbHeaderSize -= 8;
-			pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
-			if (bIsWEP) {
-				if (bExtIV)
-					*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    /* 8 is IV&ExtIV */
-				else
-					*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    /* 4 is IV */
-
-			} else {
-				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
-			}
-		}
-	} else {
-		cbHeaderSize -= 2;
-		pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
-		if (bIsWEP) {
-			if (bExtIV)
-				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    /* 8 is IV&ExtIV */
-			else
-				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    /* 4 is IV */
-
-		} else {
-			*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
-		}
-	}
-
-	cbHeaderSize -= (ETH_ALEN * 2);
-	pbyRxBuffer = (unsigned char *)(pbyRxBufferAddr + cbHeaderSize);
-	for (ii = 0; ii < ETH_ALEN; ii++)
-		*pbyRxBuffer++ = pDevice->sRxEthHeader.abyDstAddr[ii];
-	for (ii = 0; ii < ETH_ALEN; ii++)
-		*pbyRxBuffer++ = pDevice->sRxEthHeader.abySrcAddr[ii];
-
-	*pcbHeadSize = cbHeaderSize;
-}
-
-static unsigned char s_byGetRateIdx(unsigned char byRate)
-{
-	unsigned char byRateIdx;
-
-	for (byRateIdx = 0; byRateIdx < MAX_RATE; byRateIdx++) {
-		if (acbyRxRate[byRateIdx % MAX_RATE] == byRate)
-			return byRateIdx;
-	}
-
-	return 0;
-}
-
-static void
-s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
-	   PSEthernetHeader psEthHeader)
-{
-	unsigned int cbHeaderSize = 0;
-	PS802_11Header  pMACHeader;
-	int             ii;
-
-	pMACHeader = (PS802_11Header) (pbyRxBufferAddr + cbHeaderSize);
-
-	if ((pMACHeader->wFrameCtl & FC_TODS) == 0) {
-		if (pMACHeader->wFrameCtl & FC_FROMDS) {
-			for (ii = 0; ii < ETH_ALEN; ii++) {
-				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
-				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr3[ii];
-			}
-		} else {
-			/* IBSS mode */
-			for (ii = 0; ii < ETH_ALEN; ii++) {
-				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
-				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
-			}
-		}
-	} else {
-		/* Is AP mode.. */
-		if (pMACHeader->wFrameCtl & FC_FROMDS) {
-			for (ii = 0; ii < ETH_ALEN; ii++) {
-				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr3[ii];
-				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr4[ii];
-				cbHeaderSize += 6;
-			}
-		} else {
-			for (ii = 0; ii < ETH_ALEN; ii++) {
-				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr3[ii];
-				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
-			}
-		}
-	}
-	*pcbHeaderSize = cbHeaderSize;
-}
-
-bool
-device_receive_frame(
-	struct vnt_private *pDevice,
-	PSRxDesc pCurrRD
-)
-{
-	PDEVICE_RD_INFO  pRDInfo = pCurrRD->pRDInfo;
-	struct net_device_stats *pStats = &pDevice->dev->stats;
-	struct sk_buff *skb;
-	PSMgmtObject    pMgmt = pDevice->pMgmt;
-	PSRxMgmtPacket  pRxPacket = &(pDevice->pMgmt->sRxPacket);
-	PS802_11Header  p802_11Header;
-	unsigned char *pbyRsr;
-	unsigned char *pbyNewRsr;
-	unsigned char *pbyRSSI;
-	__le64 *pqwTSFTime;
-	unsigned short *pwFrameSize;
-	unsigned char *pbyFrame;
-	bool bDeFragRx = false;
-	bool bIsWEP = false;
-	unsigned int cbHeaderOffset;
-	unsigned int FrameSize;
-	unsigned short wEtherType = 0;
-	int             iSANodeIndex = -1;
-	int             iDANodeIndex = -1;
-	unsigned int ii;
-	unsigned int cbIVOffset;
-	bool bExtIV = false;
-	unsigned char *pbyRxSts;
-	unsigned char *pbyRxRate;
-	unsigned char *pbySQ;
-	unsigned int cbHeaderSize;
-	PSKeyItem       pKey = NULL;
-	unsigned short wRxTSC15_0 = 0;
-	unsigned long dwRxTSC47_16 = 0;
-	SKeyItem        STempKey;
-	/* 802.11h RPI */
-	unsigned long dwDuration = 0;
-	long            ldBm = 0;
-	long            ldBmThreshold = 0;
-	PS802_11Header pMACHeader;
-	bool bRxeapol_key = false;
-
-	skb = pRDInfo->skb;
-
-	pci_unmap_single(pDevice->pcid, pRDInfo->skb_dma,
-			 pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
-
-	pwFrameSize = (unsigned short *)(skb->data + 2);
-	FrameSize = cpu_to_le16(pCurrRD->m_rd1RD1.wReqCount) - cpu_to_le16(pCurrRD->m_rd0RD0.wResCount);
-
-	/*
-	 * Max: 2312Payload + 30HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
-	 * Min (ACK): 10HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
-	 */
-	if ((FrameSize > 2364) || (FrameSize <= 32)) {
-		/* Frame Size error drop this packet. */
-		pr_debug("---------- WRONG Length 1\n");
-		return false;
-	}
-
-	pbyRxSts = (unsigned char *)(skb->data);
-	pbyRxRate = (unsigned char *)(skb->data + 1);
-	pbyRsr = (unsigned char *)(skb->data + FrameSize - 1);
-	pbyRSSI = (unsigned char *)(skb->data + FrameSize - 2);
-	pbyNewRsr = (unsigned char *)(skb->data + FrameSize - 3);
-	pbySQ = (unsigned char *)(skb->data + FrameSize - 4);
-	pqwTSFTime = (__le64 *)(skb->data + FrameSize - 12);
-	pbyFrame = (unsigned char *)(skb->data + 4);
-
-	/* get packet size */
-	FrameSize = cpu_to_le16(*pwFrameSize);
-
-	if ((FrameSize > 2346)|(FrameSize < 14)) { /*
-						    * Max: 2312Payload + 30HD +4CRC
-						    * Min: 14 bytes ACK
-						    */
-		pr_debug("---------- WRONG Length 2\n");
-		return false;
-	}
-
-	/* update receive statistic counter */
-	STAvUpdateRDStatCounter(&pDevice->scStatistic,
-				*pbyRsr,
-				*pbyNewRsr,
-				*pbyRxRate,
-				pbyFrame,
-				FrameSize);
-
-	pMACHeader = (PS802_11Header)((unsigned char *)(skb->data) + 8);
-
-	if (pDevice->bMeasureInProgress) {
-		if ((*pbyRsr & RSR_CRCOK) != 0)
-			pDevice->byBasicMap |= 0x01;
-
-		dwDuration = FrameSize << 4;
-		dwDuration /= acbyRxRate[*pbyRxRate%MAX_RATE];
-		if (*pbyRxRate <= RATE_11M) {
-			if (*pbyRxSts & 0x01) {
-				/* long preamble */
-				dwDuration += 192;
-			} else {
-				/* short preamble */
-				dwDuration += 96;
-			}
-		} else {
-			dwDuration += 16;
-		}
-		RFvRSSITodBm(pDevice, *pbyRSSI, &ldBm);
-		ldBmThreshold = -57;
-		for (ii = 7; ii > 0;) {
-			if (ldBm > ldBmThreshold)
-				break;
-
-			ldBmThreshold -= 5;
-			ii--;
-		}
-		pDevice->dwRPIs[ii] += dwDuration;
-		return false;
-	}
-
-	if (!is_multicast_ether_addr(pbyFrame)) {
-		if (WCTLbIsDuplicate(&(pDevice->sDupRxCache), (PS802_11Header)(skb->data + 4))) {
-			pDevice->s802_11Counter.FrameDuplicateCount++;
-			return false;
-		}
-	}
-
-	/* Use for TKIP MIC */
-	s_vGetDASA(skb->data+4, &cbHeaderSize, &pDevice->sRxEthHeader);
-
-	/* filter packet send from myself */
-	if (ether_addr_equal(pDevice->sRxEthHeader.abySrcAddr,
-			     pDevice->abyCurrentNetAddr))
-		return false;
-
-	if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) || (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)) {
-		if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
-			p802_11Header = (PS802_11Header)(pbyFrame);
-			/* get SA NodeIndex */
-			if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(p802_11Header->abyAddr2), &iSANodeIndex)) {
-				pMgmt->sNodeDBTable[iSANodeIndex].ulLastRxJiffer = jiffies;
-				pMgmt->sNodeDBTable[iSANodeIndex].uInActiveCount = 0;
-			}
-		}
-	}
-
-	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-		if (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex))
-			return false;
-	}
-
-	if (IS_FC_WEP(pbyFrame)) {
-		bool bRxDecryOK = false;
-
-		pr_debug("rx WEP pkt\n");
-		bIsWEP = true;
-		if ((pDevice->bEnableHostWEP) && (iSANodeIndex >= 0)) {
-			pKey = &STempKey;
-			pKey->byCipherSuite = pMgmt->sNodeDBTable[iSANodeIndex].byCipherSuite;
-			pKey->dwKeyIndex = pMgmt->sNodeDBTable[iSANodeIndex].dwKeyIndex;
-			pKey->uKeyLength = pMgmt->sNodeDBTable[iSANodeIndex].uWepKeyLength;
-			pKey->dwTSC47_16 = pMgmt->sNodeDBTable[iSANodeIndex].dwTSC47_16;
-			pKey->wTSC15_0 = pMgmt->sNodeDBTable[iSANodeIndex].wTSC15_0;
-			memcpy(pKey->abyKey,
-			       &pMgmt->sNodeDBTable[iSANodeIndex].abyWepKey[0],
-			       pKey->uKeyLength
-);
-
-			bRxDecryOK = s_bHostWepRxEncryption(pDevice,
-							    pbyFrame,
-							    FrameSize,
-							    pbyRsr,
-							    pMgmt->sNodeDBTable[iSANodeIndex].bOnFly,
-							    pKey,
-							    pbyNewRsr,
-							    &bExtIV,
-							    &wRxTSC15_0,
-							    &dwRxTSC47_16);
-		} else {
-			bRxDecryOK = s_bHandleRxEncryption(pDevice,
-							   pbyFrame,
-							   FrameSize,
-							   pbyRsr,
-							   pbyNewRsr,
-							   &pKey,
-							   &bExtIV,
-							   &wRxTSC15_0,
-							   &dwRxTSC47_16);
-		}
-
-		if (bRxDecryOK) {
-			if ((*pbyNewRsr & NEWRSR_DECRYPTOK) == 0) {
-				pr_debug("ICV Fail\n");
-				if ((pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||
-				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||
-				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||
-				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||
-				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {
-					if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP))
-						pDevice->s802_11Counter.TKIPICVErrors++;
-					else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP))
-						pDevice->s802_11Counter.CCMPDecryptErrors++;
-				}
-				return false;
-			}
-		} else {
-			pr_debug("WEP Func Fail\n");
-			return false;
-		}
-		if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP))
-			FrameSize -= 8;         /* Message Integrity Code */
-		else
-			FrameSize -= 4;         /* 4 is ICV */
-	}
-
-	/* RX OK, remove the CRC length */
-	FrameSize -= ETH_FCS_LEN;
-
-	if ((!(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI))) &&	/* unicast address */
-	    (IS_FRAGMENT_PKT((skb->data+4)))
-) {
-		/* defragment */
-		bDeFragRx = WCTLbHandleFragment(pDevice, (PS802_11Header)(skb->data+4), FrameSize, bIsWEP, bExtIV);
-		pDevice->s802_11Counter.ReceivedFragmentCount++;
-		if (bDeFragRx) {
-			/* defrag complete */
-			skb = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].skb;
-			FrameSize = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].cbFrameLength;
-
-		} else {
-			return false;
-		}
-	}
-
-/* Management & Control frame Handle */
-	if ((IS_TYPE_DATA((skb->data+4))) == false) {
-		/* Handle Control & Manage Frame */
-
-		if (IS_TYPE_MGMT((skb->data+4))) {
-			unsigned char *pbyData1;
-			unsigned char *pbyData2;
-
-			pRxPacket->p80211Header = (PUWLAN_80211HDR)(skb->data+4);
-			pRxPacket->cbMPDULen = FrameSize;
-			pRxPacket->uRSSI = *pbyRSSI;
-			pRxPacket->bySQ = *pbySQ;
-			pRxPacket->qwLocalTSF = le64_to_cpu(*pqwTSFTime);
-			if (bIsWEP) {
-				/* strip IV */
-				pbyData1 = WLAN_HDR_A3_DATA_PTR(skb->data+4);
-				pbyData2 = WLAN_HDR_A3_DATA_PTR(skb->data+4) + 4;
-				for (ii = 0; ii < (FrameSize - 4); ii++) {
-					*pbyData1 = *pbyData2;
-					pbyData1++;
-					pbyData2++;
-				}
-			}
-			pRxPacket->byRxRate = s_byGetRateIdx(*pbyRxRate);
-			pRxPacket->byRxChannel = (*pbyRxSts) >> 2;
-
-			vMgrRxManagePacket((void *)pDevice, pDevice->pMgmt, pRxPacket);
-
-			/* hostap Deamon handle 802.11 management */
-			if (pDevice->bEnableHostapd) {
-				skb->dev = pDevice->apdev;
-				skb->data += 4;
-				skb->tail += 4;
-				skb_put(skb, FrameSize);
-				skb_reset_mac_header(skb);
-				skb->pkt_type = PACKET_OTHERHOST;
-				skb->protocol = htons(ETH_P_802_2);
-				memset(skb->cb, 0, sizeof(skb->cb));
-				netif_rx(skb);
-				return true;
-			}
-		}
-
-		return false;
-	} else {
-		if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-			/* In AP mode, hw only check addr1(BSSID or RA) if equal to local MAC. */
-			if (!(*pbyRsr & RSR_BSSIDOK)) {
-				if (bDeFragRx) {
-					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-						pr_err("%s: can not alloc more frag bufs\n",
-						       pDevice->dev->name);
-					}
-				}
-				return false;
-			}
-		} else {
-			/* discard DATA packet while not associate || BSSID error */
-			if (!pDevice->bLinkPass || !(*pbyRsr & RSR_BSSIDOK)) {
-				if (bDeFragRx) {
-					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-						pr_err("%s: can not alloc more frag bufs\n",
-						       pDevice->dev->name);
-					}
-				}
-				return false;
-			}
-			{
-				unsigned char Protocol_Version;		/* 802.1x Authentication */
-				unsigned char Packet_Type;		/* 802.1x Authentication */
-
-				if (bIsWEP)
-					cbIVOffset = 8;
-				else
-					cbIVOffset = 0;
-				wEtherType = (skb->data[cbIVOffset + 8 + 24 + 6] << 8) |
-					skb->data[cbIVOffset + 8 + 24 + 6 + 1];
-				Protocol_Version = skb->data[cbIVOffset + 8 + 24 + 6 + 1 + 1];
-				Packet_Type = skb->data[cbIVOffset + 8 + 24 + 6 + 1 + 1 + 1];
-				if (wEtherType == ETH_P_PAE) {         /* Protocol Type in LLC-Header */
-					if (((Protocol_Version == 1) || (Protocol_Version == 2)) &&
-					    (Packet_Type == 3)) {  /*802.1x OR eapol-key challenge frame receive */
-						bRxeapol_key = true;
-					}
-				}
-			}
-		}
-	}
-
-/* Data frame Handle */
-
-	if (pDevice->bEnablePSMode) {
-		if (!IS_FC_MOREDATA((skb->data+4))) {
-			if (pDevice->pMgmt->bInTIMWake == true)
-				pDevice->pMgmt->bInTIMWake = false;
-		}
-	}
-
-	/* Now it only supports 802.11g Infrastructure Mode, and support rate must up to 54 Mbps */
-	if (pDevice->bDiversityEnable && (FrameSize > 50) &&
-	    (pDevice->op_mode == NL80211_IFTYPE_STATION) &&
-	    pDevice->bLinkPass) {
-		BBvAntennaDiversity(pDevice, s_byGetRateIdx(*pbyRxRate), 0);
-	}
-
-	if (pDevice->byLocalID != REV_ID_VT3253_B1)
-		pDevice->uCurrRSSI = *pbyRSSI;
-
-	pDevice->byCurrSQ = *pbySQ;
-
-	if ((*pbyRSSI != 0) &&
-	    (pMgmt->pCurrBSS != NULL)) {
-		RFvRSSITodBm(pDevice, *pbyRSSI, &ldBm);
-		/* Monitor if RSSI is too strong. */
-		pMgmt->pCurrBSS->byRSSIStatCnt++;
-		pMgmt->pCurrBSS->byRSSIStatCnt %= RSSI_STAT_COUNT;
-		pMgmt->pCurrBSS->ldBmAverage[pMgmt->pCurrBSS->byRSSIStatCnt] = ldBm;
-		for (ii = 0; ii < RSSI_STAT_COUNT; ii++)
-			if (pMgmt->pCurrBSS->ldBmAverage[ii] != 0)
-				pMgmt->pCurrBSS->ldBmMAX = max(pMgmt->pCurrBSS->ldBmAverage[ii], ldBm);
-
-	}
-
-	if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) && pDevice->bEnable8021x) {
-		unsigned char abyMacHdr[24];
-
-		/* Only 802.1x packet incoming allowed */
-		if (bIsWEP)
-			cbIVOffset = 8;
-		else
-			cbIVOffset = 0;
-		wEtherType = (skb->data[cbIVOffset + 4 + 24 + 6] << 8) |
-			skb->data[cbIVOffset + 4 + 24 + 6 + 1];
-
-		pr_debug("wEtherType = %04x\n", wEtherType);
-		if (wEtherType == ETH_P_PAE) {
-			skb->dev = pDevice->apdev;
-
-			if (bIsWEP) {
-				/* strip IV header(8) */
-				memcpy(&abyMacHdr[0], (skb->data + 4), 24);
-				memcpy((skb->data + 4 + cbIVOffset), &abyMacHdr[0], 24);
-			}
-			skb->data +=  (cbIVOffset + 4);
-			skb->tail +=  (cbIVOffset + 4);
-			skb_put(skb, FrameSize);
-			skb_reset_mac_header(skb);
-
-			skb->pkt_type = PACKET_OTHERHOST;
-			skb->protocol = htons(ETH_P_802_2);
-			memset(skb->cb, 0, sizeof(skb->cb));
-			netif_rx(skb);
-			return true;
-
-		}
-		/* check if 802.1x authorized */
-		if (!(pMgmt->sNodeDBTable[iSANodeIndex].dwFlags & WLAN_STA_AUTHORIZED))
-			return false;
-	}
-
-	if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
-		if (bIsWEP)
-			FrameSize -= 8;  /* MIC */
-	}
-
-	/* Soft MIC */
-	if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
-		if (bIsWEP) {
-			__le32 *pdwMIC_L;
-			__le32 *pdwMIC_R;
-			__le32 dwMIC_Priority;
-			__le32 dwMICKey0 = 0, dwMICKey1 = 0;
-			u32 dwLocalMIC_L = 0;
-			u32 dwLocalMIC_R = 0;
-			viawget_wpa_header *wpahdr;
-
-			if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-				dwMICKey0 = cpu_to_le32(*(u32 *)(&pKey->abyKey[24]));
-				dwMICKey1 = cpu_to_le32(*(u32 *)(&pKey->abyKey[28]));
-			} else {
-				if (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) {
-					dwMICKey0 = cpu_to_le32(*(u32 *)(&pKey->abyKey[16]));
-					dwMICKey1 = cpu_to_le32(*(u32 *)(&pKey->abyKey[20]));
-				} else if ((pKey->dwKeyIndex & BIT28) == 0) {
-					dwMICKey0 = cpu_to_le32(*(u32 *)(&pKey->abyKey[16]));
-					dwMICKey1 = cpu_to_le32(*(u32 *)(&pKey->abyKey[20]));
-				} else {
-					dwMICKey0 = cpu_to_le32(*(u32 *)(&pKey->abyKey[24]));
-					dwMICKey1 = cpu_to_le32(*(u32 *)(&pKey->abyKey[28]));
-				}
-			}
-
-			MIC_vInit(dwMICKey0, dwMICKey1);
-			MIC_vAppend((unsigned char *)&(pDevice->sRxEthHeader.abyDstAddr[0]), 12);
-			dwMIC_Priority = 0;
-			MIC_vAppend((unsigned char *)&dwMIC_Priority, 4);
-			/* 4 is Rcv buffer header, 24 is MAC Header, and 8 is IV and Ext IV. */
-			MIC_vAppend((unsigned char *)(skb->data + 4 + WLAN_HDR_ADDR3_LEN + 8),
-				    FrameSize - WLAN_HDR_ADDR3_LEN - 8);
-			MIC_vGetMIC(&dwLocalMIC_L, &dwLocalMIC_R);
-			MIC_vUnInit();
-
-			pdwMIC_L = (__le32 *)(skb->data + 4 + FrameSize);
-			pdwMIC_R = (__le32 *)(skb->data + 4 + FrameSize + 4);
-
-			if ((le32_to_cpu(*pdwMIC_L) != dwLocalMIC_L) ||
-			    (le32_to_cpu(*pdwMIC_R) != dwLocalMIC_R) ||
-			    pDevice->bRxMICFail) {
-				pr_debug("MIC comparison is fail!\n");
-				pDevice->bRxMICFail = false;
-				pDevice->s802_11Counter.TKIPLocalMICFailures++;
-				if (bDeFragRx) {
-					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-						pr_err("%s: can not alloc more frag bufs\n",
-						       pDevice->dev->name);
-					}
-				}
-#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-				/* send event to wpa_supplicant */
-				{
-					union iwreq_data wrqu;
-					struct iw_michaelmicfailure ev;
-					int keyidx = pbyFrame[cbHeaderSize+3] >> 6; /* top two-bits */
-
-					memset(&ev, 0, sizeof(ev));
-					ev.flags = keyidx & IW_MICFAILURE_KEY_ID;
-					if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
-					    (pMgmt->eCurrState == WMAC_STATE_ASSOC) &&
-					    (*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) {
-						ev.flags |= IW_MICFAILURE_PAIRWISE;
-					} else {
-						ev.flags |= IW_MICFAILURE_GROUP;
-					}
-
-					ev.src_addr.sa_family = ARPHRD_ETHER;
-					ether_addr_copy(ev.src_addr.sa_data,
-							pMACHeader->abyAddr2);
-					memset(&wrqu, 0, sizeof(wrqu));
-					wrqu.data.length = sizeof(ev);
-					wireless_send_event(pDevice->dev, IWEVMICHAELMICFAILURE, &wrqu, (char *)&ev);
-
-				}
-#endif
-
-				if ((pDevice->bWPADEVUp) && (pDevice->skb != NULL)) {
-					wpahdr = (viawget_wpa_header *)pDevice->skb->data;
-					if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
-					    (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC) &&
-					    (*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) {
-						wpahdr->type = VIAWGET_PTK_MIC_MSG;
-					} else {
-						wpahdr->type = VIAWGET_GTK_MIC_MSG;
-					}
-					wpahdr->resp_ie_len = 0;
-					wpahdr->req_ie_len = 0;
-					skb_put(pDevice->skb, sizeof(viawget_wpa_header));
-					pDevice->skb->dev = pDevice->wpadev;
-					skb_reset_mac_header(pDevice->skb);
-					pDevice->skb->pkt_type = PACKET_HOST;
-					pDevice->skb->protocol = htons(ETH_P_802_2);
-					memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
-					netif_rx(pDevice->skb);
-					pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-				}
-
-				return false;
-
-			}
-		}
-	}
-
-	/* ++++++++++ Reply Counter Check +++++++++++++ */
-	if ((pKey != NULL) && ((pKey->byCipherSuite == KEY_CTL_TKIP) ||
-			       (pKey->byCipherSuite == KEY_CTL_CCMP))) {
-		if (bIsWEP) {
-			unsigned short wLocalTSC15_0 = 0;
-			unsigned long dwLocalTSC47_16 = 0;
-			unsigned long long       RSC = 0;
-			/* endian issues */
-			RSC = *((unsigned long long *)&(pKey->KeyRSC));
-			wLocalTSC15_0 = (unsigned short)RSC;
-			dwLocalTSC47_16 = (unsigned long)(RSC>>16);
-
-			RSC = dwRxTSC47_16;
-			RSC <<= 16;
-			RSC += wRxTSC15_0;
-			pKey->KeyRSC = RSC;
-
-			if ((pDevice->sMgmtObj.eCurrMode == WMAC_MODE_ESS_STA) &&
-			    (pDevice->sMgmtObj.eCurrState == WMAC_STATE_ASSOC)) {
-				/* check RSC */
-				if ((wRxTSC15_0 < wLocalTSC15_0) &&
-				    (dwRxTSC47_16 <= dwLocalTSC47_16) &&
-				    !((dwRxTSC47_16 == 0) && (dwLocalTSC47_16 == 0xFFFFFFFF))) {
-					pr_debug("TSC is illegal~~!\n ");
-					if (pKey->byCipherSuite == KEY_CTL_TKIP)
-						pDevice->s802_11Counter.TKIPReplays++;
-					else
-						pDevice->s802_11Counter.CCMPReplays++;
-
-					if (bDeFragRx) {
-						if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-							pr_err("%s: can not alloc more frag bufs\n",
-							       pDevice->dev->name);
-						}
-					}
-					return false;
-				}
-			}
-		}
-	}
-
-	s_vProcessRxMACHeader(pDevice, (unsigned char *)(skb->data+4), FrameSize, bIsWEP, bExtIV, &cbHeaderOffset);
-	FrameSize -= cbHeaderOffset;
-	cbHeaderOffset += 4;        /* 4 is Rcv buffer header */
-
-	/* Null data, framesize = 14 */
-	if (FrameSize < 15)
-		return false;
-
-	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-		if (!s_bAPModeRxData(pDevice,
-				    skb,
-				    FrameSize,
-				    cbHeaderOffset,
-				    iSANodeIndex,
-				    iDANodeIndex
-)) {
-			if (bDeFragRx) {
-				if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-					pr_err("%s: can not alloc more frag bufs\n",
-					       pDevice->dev->name);
-				}
-			}
-			return false;
-		}
-	}
-
-	skb->data += cbHeaderOffset;
-	skb->tail += cbHeaderOffset;
-	skb_put(skb, FrameSize);
-	skb->protocol = eth_type_trans(skb, skb->dev);
-
-	/* drop frame not met IEEE 802.3 */
-
-	skb->ip_summed = CHECKSUM_NONE;
-	pStats->rx_bytes += skb->len;
-	pStats->rx_packets++;
-	netif_rx(skb);
-
-	if (bDeFragRx) {
-		if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-			pr_err("%s: can not alloc more frag bufs\n",
-			       pDevice->dev->name);
-		}
-		return false;
-	}
-
-	return true;
-}
-
-static bool s_bAPModeRxCtl(
-	struct vnt_private *pDevice,
-	unsigned char *pbyFrame,
-	int      iSANodeIndex
-)
-{
-	PS802_11Header      p802_11Header;
-	CMD_STATUS          Status;
-	PSMgmtObject        pMgmt = pDevice->pMgmt;
-
-	if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
-		p802_11Header = (PS802_11Header)(pbyFrame);
-		if (!IS_TYPE_MGMT(pbyFrame)) {
-			/* Data & PS-Poll packet, check frame class */
-			if (iSANodeIndex > 0) {
-				/* frame class 3 fliter & checking */
-				if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_AUTH) {
-					/*
-					 * send deauth notification
-					 * reason = (6) class 2 received from nonauth sta
-					 */
-					vMgrDeAuthenBeginSta(pDevice,
-							     pMgmt,
-							     (unsigned char *)(p802_11Header->abyAddr2),
-							     (WLAN_MGMT_REASON_CLASS2_NONAUTH),
-							     &Status
-);
-					pr_debug("dpc: send vMgrDeAuthenBeginSta 1\n");
-					return true;
-				}
-				if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_ASSOC) {
-					/*
-					 * send deassoc notification
-					 * reason = (7) class 3 received from nonassoc sta
-					 */
-					vMgrDisassocBeginSta(pDevice,
-							     pMgmt,
-							     (unsigned char *)(p802_11Header->abyAddr2),
-							     (WLAN_MGMT_REASON_CLASS3_NONASSOC),
-							     &Status
-);
-					pr_debug("dpc: send vMgrDisassocBeginSta 2\n");
-					return true;
-				}
-
-				if (pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable) {
-					/* delcare received ps-poll event */
-					if (IS_CTL_PSPOLL(pbyFrame)) {
-						pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
-						bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-						pr_debug("dpc: WLAN_CMD_RX_PSPOLL 1\n");
-					} else {
-						/*
-						 * check Data PS state
-						 * if PW bit off, send out all PS bufferring packets.
-						 */
-						if (!IS_FC_POWERMGT(pbyFrame)) {
-							pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
-							pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
-							bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-							pr_debug("dpc: WLAN_CMD_RX_PSPOLL 2\n");
-						}
-					}
-				} else {
-					if (IS_FC_POWERMGT(pbyFrame)) {
-						pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = true;
-						/* Once if STA in PS state, enable multicast bufferring */
-						pMgmt->sNodeDBTable[0].bPSEnable = true;
-					} else {
-						/* clear all pending PS frame. */
-						if (pMgmt->sNodeDBTable[iSANodeIndex].wEnQueueCnt > 0) {
-							pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
-							pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
-							bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-							pr_debug("dpc: WLAN_CMD_RX_PSPOLL 3\n");
-
-						}
-					}
-				}
-			} else {
-				vMgrDeAuthenBeginSta(pDevice,
-						     pMgmt,
-						     (unsigned char *)(p802_11Header->abyAddr2),
-						     (WLAN_MGMT_REASON_CLASS2_NONAUTH),
-						     &Status
-);
-				pr_debug("dpc: send vMgrDeAuthenBeginSta 3\n");
-				pr_debug("BSSID:%pM\n",
-					 p802_11Header->abyAddr3);
-				pr_debug("ADDR2:%pM\n",
-					 p802_11Header->abyAddr2);
-				pr_debug("ADDR1:%pM\n",
-					 p802_11Header->abyAddr1);
-				pr_debug("dpc: wFrameCtl= %x\n",
-					 p802_11Header->wFrameCtl);
-				VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
-				pr_debug("dpc:pDevice->byRxMode = %x\n",
-					 pDevice->byRxMode);
-				return true;
-			}
-		}
-	}
-	return false;
-}
-
-static bool s_bHandleRxEncryption(
-	struct vnt_private *pDevice,
-	unsigned char *pbyFrame,
-	unsigned int FrameSize,
-	unsigned char *pbyRsr,
-	unsigned char *pbyNewRsr,
-	PSKeyItem   *pKeyOut,
-	bool *pbExtIV,
-	unsigned short *pwRxTSC15_0,
-	unsigned long *pdwRxTSC47_16
-)
-{
-	unsigned int PayloadLen = FrameSize;
-	unsigned char *pbyIV;
-	unsigned char byKeyIdx;
-	PSKeyItem       pKey = NULL;
-	unsigned char byDecMode = KEY_CTL_WEP;
-	PSMgmtObject    pMgmt = pDevice->pMgmt;
-
-	*pwRxTSC15_0 = 0;
-	*pdwRxTSC47_16 = 0;
-
-	pbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;
-	if (WLAN_GET_FC_TODS(*(unsigned short *)pbyFrame) &&
-	    WLAN_GET_FC_FROMDS(*(unsigned short *)pbyFrame)) {
-		pbyIV += 6;             /* 6 is 802.11 address4 */
-		PayloadLen -= 6;
-	}
-	byKeyIdx = (*(pbyIV+3) & 0xc0);
-	byKeyIdx >>= 6;
-	pr_debug("\nKeyIdx: %d\n", byKeyIdx);
-
-	if ((pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||
-	    (pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||
-	    (pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||
-	    (pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||
-	    (pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {
-		if (((*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) &&
-		    (pDevice->pMgmt->byCSSPK != KEY_CTL_NONE)) {
-			/* unicast pkt use pairwise key */
-			pr_debug("unicast pkt\n");
-			if (KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, 0xFFFFFFFF, &pKey) == true) {
-				if (pDevice->pMgmt->byCSSPK == KEY_CTL_TKIP)
-					byDecMode = KEY_CTL_TKIP;
-				else if (pDevice->pMgmt->byCSSPK == KEY_CTL_CCMP)
-					byDecMode = KEY_CTL_CCMP;
-			}
-			pr_debug("unicast pkt: %d, %p\n", byDecMode, pKey);
-		} else {
-			/* use group key */
-			KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, byKeyIdx, &pKey);
-			if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
-				byDecMode = KEY_CTL_TKIP;
-			else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
-				byDecMode = KEY_CTL_CCMP;
-			pr_debug("group pkt: %d, %d, %p\n",
-				 byKeyIdx, byDecMode, pKey);
-		}
-	}
-	/* our WEP only support Default Key */
-	if (pKey == NULL) {
-		/* use default group key */
-		KeybGetKey(&(pDevice->sKey), pDevice->abyBroadcastAddr, byKeyIdx, &pKey);
-		if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
-			byDecMode = KEY_CTL_TKIP;
-		else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
-			byDecMode = KEY_CTL_CCMP;
-	}
-	*pKeyOut = pKey;
-
-	pr_debug("AES:%d %d %d\n",
-		 pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
-
-	if (pKey == NULL) {
-		pr_debug("pKey == NULL\n");
-
-		return false;
-	}
-	if (byDecMode != pKey->byCipherSuite) {
-
-		*pKeyOut = NULL;
-		return false;
-	}
-	if (byDecMode == KEY_CTL_WEP) {
-		/* handle WEP */
-		if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
-		    (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true)) {
-			/*
-			 * Software WEP
-			 * 1. 3253A
-			 * 2. WEP 256
-			 */
-
-			PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); /* 24 is 802.11 header,4 is IV, 4 is crc */
-			memcpy(pDevice->abyPRNG, pbyIV, 3);
-			memcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
-			rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
-			rc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);
-
-			if (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen))
-				*pbyNewRsr |= NEWRSR_DECRYPTOK;
-
-		}
-	} else if ((byDecMode == KEY_CTL_TKIP) ||
-		   (byDecMode == KEY_CTL_CCMP)) {
-		/* TKIP/AES */
-
-		PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); /* 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc */
-		*pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
-		pr_debug("ExtIV: %lx\n", *pdwRxTSC47_16);
-		if (byDecMode == KEY_CTL_TKIP)
-			*pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV + 2), *pbyIV));
-		else
-			*pwRxTSC15_0 = cpu_to_le16(*(unsigned short *)pbyIV);
-
-		pr_debug("TSC0_15: %x\n", *pwRxTSC15_0);
-
-		if ((byDecMode == KEY_CTL_TKIP) &&
-		    (pDevice->byLocalID <= REV_ID_VT3253_A1)) {
-			/*
-			 * Software TKIP
-			 * 1. 3253 A
-			 */
-			PS802_11Header  pMACHeader = (PS802_11Header)(pbyFrame);
-
-			TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
-			rc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);
-			rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);
-			if (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {
-				*pbyNewRsr |= NEWRSR_DECRYPTOK;
-				pr_debug("ICV OK!\n");
-			} else {
-				pr_debug("ICV FAIL!!!\n");
-				pr_debug("PayloadLen = %d\n", PayloadLen);
-			}
-		}
-	}
-
-	if ((*(pbyIV+3) & 0x20) != 0)
-		*pbExtIV = true;
-	return true;
-}
-
-static bool s_bHostWepRxEncryption(
-	struct vnt_private *pDevice,
-	unsigned char *pbyFrame,
-	unsigned int FrameSize,
-	unsigned char *pbyRsr,
-	bool bOnFly,
-	PSKeyItem    pKey,
-	unsigned char *pbyNewRsr,
-	bool *pbExtIV,
-	unsigned short *pwRxTSC15_0,
-	unsigned long *pdwRxTSC47_16
-)
-{
-	unsigned int PayloadLen = FrameSize;
-	unsigned char *pbyIV;
-	unsigned char byKeyIdx;
-	unsigned char byDecMode = KEY_CTL_WEP;
-	PS802_11Header  pMACHeader;
-
-	*pwRxTSC15_0 = 0;
-	*pdwRxTSC47_16 = 0;
-
-	pbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;
-	if (WLAN_GET_FC_TODS(*(unsigned short *)pbyFrame) &&
-	    WLAN_GET_FC_FROMDS(*(unsigned short *)pbyFrame)) {
-		pbyIV += 6;             /* 6 is 802.11 address4 */
-		PayloadLen -= 6;
-	}
-	byKeyIdx = (*(pbyIV+3) & 0xc0);
-	byKeyIdx >>= 6;
-	pr_debug("\nKeyIdx: %d\n", byKeyIdx);
-
-	if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
-		byDecMode = KEY_CTL_TKIP;
-	else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
-		byDecMode = KEY_CTL_CCMP;
-
-	pr_debug("AES:%d %d %d\n",
-		 pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
-
-	if (byDecMode != pKey->byCipherSuite)
-		return false;
-
-	if (byDecMode == KEY_CTL_WEP) {
-		/* handle WEP */
-		pr_debug("byDecMode == KEY_CTL_WEP\n");
-
-		if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
-		    (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true) ||
-		    !bOnFly) {
-			/*
-			 * Software WEP
-			 * 1. 3253A
-			 * 2. WEP 256
-			 * 3. NotOnFly
-			 */
-
-			PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); /* 24 is 802.11 header,4 is IV, 4 is crc */
-			memcpy(pDevice->abyPRNG, pbyIV, 3);
-			memcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
-			rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
-			rc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);
-
-			if (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen))
-				*pbyNewRsr |= NEWRSR_DECRYPTOK;
-
-		}
-	} else if ((byDecMode == KEY_CTL_TKIP) ||
-		   (byDecMode == KEY_CTL_CCMP)) {
-		/* TKIP/AES */
-
-		PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); /* 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc */
-		*pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
-		pr_debug("ExtIV: %lx\n", *pdwRxTSC47_16);
-
-		if (byDecMode == KEY_CTL_TKIP)
-			*pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
-		else
-			*pwRxTSC15_0 = cpu_to_le16(*(unsigned short *)pbyIV);
-
-		pr_debug("TSC0_15: %x\n", *pwRxTSC15_0);
-
-		if (byDecMode == KEY_CTL_TKIP) {
-			if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || !bOnFly) {
-				/*
-				 * Software TKIP
-				 * 1. 3253 A
-				 * 2. NotOnFly
-				 */
-				pr_debug("soft KEY_CTL_TKIP\n");
-				pMACHeader = (PS802_11Header)(pbyFrame);
-				TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
-				rc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);
-				rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);
-				if (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {
-					*pbyNewRsr |= NEWRSR_DECRYPTOK;
-					pr_debug("ICV OK!\n");
-				} else {
-					pr_debug("ICV FAIL!!!\n");
-					pr_debug("PayloadLen = %d\n",
-						 PayloadLen);
-				}
-			}
-		}
-
-		if (byDecMode == KEY_CTL_CCMP) {
-			if (!bOnFly) {
-				/*
-				 * Software CCMP
-				 * NotOnFly
-				 */
-				pr_debug("soft KEY_CTL_CCMP\n");
-				if (AESbGenCCMP(pKey->abyKey, pbyFrame, FrameSize)) {
-					*pbyNewRsr |= NEWRSR_DECRYPTOK;
-					pr_debug("CCMP MIC compare OK!\n");
-				} else {
-					pr_debug("CCMP MIC fail!\n");
-				}
-			}
-		}
-
-	}
-
-	if ((*(pbyIV+3) & 0x20) != 0)
-		*pbExtIV = true;
-	return true;
-}
-
-static bool s_bAPModeRxData(
-	struct vnt_private *pDevice,
-	struct sk_buff *skb,
-	unsigned int FrameSize,
-	unsigned int cbHeaderOffset,
-	int      iSANodeIndex,
-	int      iDANodeIndex
-)
-{
-	PSMgmtObject        pMgmt = pDevice->pMgmt;
-	bool bRelayAndForward = false;
-	bool bRelayOnly = false;
-	unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
-	unsigned short wAID;
-
-	struct sk_buff *skbcpy = NULL;
-
-	if (FrameSize > CB_MAX_BUF_SIZE)
-		return false;
-	/* check DA */
-	if (is_multicast_ether_addr((unsigned char *)(skb->data+cbHeaderOffset))) {
-		if (pMgmt->sNodeDBTable[0].bPSEnable) {
-			skbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);
-
-			/* if any node in PS mode, buffer packet until DTIM. */
-			if (skbcpy == NULL) {
-				pr_info("relay multicast no skb available\n");
-			} else {
-				skbcpy->dev = pDevice->dev;
-				skbcpy->len = FrameSize;
-				memcpy(skbcpy->data, skb->data+cbHeaderOffset, FrameSize);
-				skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skbcpy);
-
-				pMgmt->sNodeDBTable[0].wEnQueueCnt++;
-				/* set tx map */
-				pMgmt->abyPSTxMap[0] |= byMask[0];
-			}
-		} else {
-			bRelayAndForward = true;
-		}
-	} else {
-		/* check if relay */
-		if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data+cbHeaderOffset), &iDANodeIndex)) {
-			if (pMgmt->sNodeDBTable[iDANodeIndex].eNodeState >= NODE_ASSOC) {
-				if (pMgmt->sNodeDBTable[iDANodeIndex].bPSEnable) {
-					/* queue this skb until next PS tx, and then release. */
-
-					skb->data += cbHeaderOffset;
-					skb->tail += cbHeaderOffset;
-					skb_put(skb, FrameSize);
-					skb_queue_tail(&pMgmt->sNodeDBTable[iDANodeIndex].sTxPSQueue, skb);
-					pMgmt->sNodeDBTable[iDANodeIndex].wEnQueueCnt++;
-					wAID = pMgmt->sNodeDBTable[iDANodeIndex].wAID;
-					pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
-					pr_debug("relay: index= %d, pMgmt->abyPSTxMap[%d]= %d\n",
-						 iDANodeIndex, (wAID >> 3),
-						 pMgmt->abyPSTxMap[wAID >> 3]);
-					return true;
-				} else {
-					bRelayOnly = true;
-				}
-			}
-		}
-	}
-
-	if (bRelayOnly || bRelayAndForward) {
-		/* relay this packet right now */
-		if (bRelayAndForward)
-			iDANodeIndex = 0;
-
-		if ((pDevice->uAssocCount > 1) && (iDANodeIndex >= 0))
-			ROUTEbRelay(pDevice, (unsigned char *)(skb->data + cbHeaderOffset), FrameSize, (unsigned int)iDANodeIndex);
-
-		if (bRelayOnly)
-			return false;
-	}
-	/* none associate, don't forward */
-	if (pDevice->uAssocCount == 0)
-		return false;
-
-	return true;
-}
-
 static bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,
 			u16 bytes_received)
 {

commit ee1464902c25e22c15d7eda41f00a8a40acc7ec9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:55:24 2014 +0000

    staging: vt6655: dead code remove legacy hostap.c/h
    
    hoatap is now supported by mac80211 in nl80211 mode
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 11153ef0dd95..6842baf73ed1 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -50,7 +50,6 @@
 #include "tcrc.h"
 #include "wctl.h"
 #include "wroute.h"
-#include "hostap.h"
 #include "rf.h"
 #include "iowpa.h"
 #include "aes_ccmp.h"

commit f218f40d48bf0e5e1968c7ecaa44a2d1a7dc61c8
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:44:07 2014 +0000

    staging: vt6655: vnt_rx_data: uCurrRSSI should have the value of *rssi
    
    Fixes issue of byBBVGANew is wrong in device_intr
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 036bbb0f4824..11153ef0dd95 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -1382,7 +1382,7 @@ static bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,
 	RFvRSSITodBm(priv, *rssi, &rx_dbm);
 
 	priv->byBBPreEDRSSI = (u8)rx_dbm + 1;
-	priv->uCurrRSSI = priv->byBBPreEDRSSI;
+	priv->uCurrRSSI = *rssi;
 
 	skb_pull(skb, 4);
 	skb_trim(skb, frame_size);

commit 33b1c8c13fb8c9c3c5320345258a4d33806262f4
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Oct 29 17:43:36 2014 +0000

    staging: vt6655: mac80211 conversion: add new rx functions
    
    vnt_receive_frame which replaces device_receive_frame
    
    and vnt_rx_data which handles mac80211 rx data
    
    structures ieee80211_hw, ieee80211_vif and variable rx_rate are added
    in structure vnt_private
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 67cadeaf2f7d..036bbb0f4824 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -1321,3 +1321,126 @@ static bool s_bAPModeRxData(
 
 	return true;
 }
+
+static bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,
+			u16 bytes_received)
+{
+	struct ieee80211_hw *hw = priv->hw;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_rx_status rx_status = { 0 };
+	struct ieee80211_hdr *hdr;
+	__le16 fc;
+	u8 *rsr, *new_rsr, *rssi;
+	__le64 *tsf_time;
+	u16 frame_size;
+	int ii, r;
+	u8 *rx_sts, *rx_rate, *sq;
+	u8 *skb_data;
+	u8 rate_idx = 0;
+	u8 rate[MAX_RATE] = {2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108};
+	long rx_dbm;
+
+	/* [31:16]RcvByteCount ( not include 4-byte Status ) */
+	frame_size = le16_to_cpu(*((__le16 *)(skb->data + 2)));
+	if (frame_size > 2346 || frame_size < 14) {
+		dev_dbg(&priv->pcid->dev, "------- WRONG Length 1\n");
+		return false;
+	}
+
+	skb_data = (u8 *)skb->data;
+
+	rx_sts = skb_data;
+	rx_rate = skb_data + 1;
+
+	sband = hw->wiphy->bands[hw->conf.chandef.chan->band];
+
+	for (r = RATE_1M; r < MAX_RATE; r++) {
+		if (*rx_rate == rate[r])
+			break;
+	}
+
+	priv->rx_rate = r;
+
+	for (ii = 0; ii < sband->n_bitrates; ii++) {
+		if (sband->bitrates[ii].hw_value == r) {
+			rate_idx = ii;
+				break;
+		}
+	}
+
+	if (ii == sband->n_bitrates) {
+		dev_dbg(&priv->pcid->dev, "Wrong RxRate %x\n", *rx_rate);
+		return false;
+	}
+
+	tsf_time = (__le64 *)(skb_data + bytes_received - 12);
+	sq = skb_data + bytes_received - 4;
+	new_rsr = skb_data + bytes_received - 3;
+	rssi = skb_data + bytes_received - 2;
+	rsr = skb_data + bytes_received - 1;
+
+	RFvRSSITodBm(priv, *rssi, &rx_dbm);
+
+	priv->byBBPreEDRSSI = (u8)rx_dbm + 1;
+	priv->uCurrRSSI = priv->byBBPreEDRSSI;
+
+	skb_pull(skb, 4);
+	skb_trim(skb, frame_size);
+
+	rx_status.mactime = le64_to_cpu(*tsf_time);
+	rx_status.band = hw->conf.chandef.chan->band;
+	rx_status.signal = rx_dbm;
+	rx_status.flag = 0;
+	rx_status.freq = hw->conf.chandef.chan->center_freq;
+
+	hdr = (struct ieee80211_hdr *)(skb->data);
+	fc = hdr->frame_control;
+
+	rx_status.rate_idx = rate_idx;
+
+	if (ieee80211_has_protected(fc)) {
+		if (priv->byLocalID > REV_ID_VT3253_A1)
+			rx_status.flag = RX_FLAG_DECRYPTED;
+	}
+
+	if (priv->vif && priv->bDiversityEnable) {
+		if (ieee80211_is_data(fc) &&
+		    (frame_size > 50) && priv->vif->bss_conf.assoc)
+			BBvAntennaDiversity(priv, priv->rx_rate, 0);
+	}
+
+	memcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));
+
+	ieee80211_rx_irqsafe(priv->hw, skb);
+
+	return true;
+}
+
+bool vnt_receive_frame(struct vnt_private *priv, PSRxDesc curr_rd)
+{
+	PDEVICE_RD_INFO rd_info = curr_rd->pRDInfo;
+	struct sk_buff *skb;
+	u16 frame_size;
+
+	skb = rd_info->skb;
+
+	pci_unmap_single(priv->pcid, rd_info->skb_dma,
+			 priv->rx_buf_sz, PCI_DMA_FROMDEVICE);
+
+	frame_size = le16_to_cpu(curr_rd->m_rd1RD1.wReqCount)
+			- cpu_to_le16(curr_rd->m_rd0RD0.wResCount);
+
+	if ((frame_size > 2364) || (frame_size < 33)) {
+		/* Frame Size error drop this packet.*/
+		dev_dbg(&priv->pcid->dev, "Wrong frame size %d\n", frame_size);
+		dev_kfree_skb_irq(skb);
+		return true;
+	}
+
+	if (vnt_rx_data(priv, skb, frame_size))
+		return true;
+
+	dev_kfree_skb_irq(skb);
+
+	return true;
+}

commit 1d39fe040b7e8cb77e330e4fa65c2ab2c73b26b3
Author: Veronika Kabatova <veronicca114@gmail.com>
Date:   Sat Oct 25 23:06:56 2014 +0200

    staging: vt6655: dpc.c: Comment fixes
    
    Replace C99 "//" comments by "/* */", remove not
    needed comments about adding code
    
    Signed-off-by: Veronika Kabatova <veronicca114@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index eecf6f559e29..67cadeaf2f7d 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -160,10 +160,10 @@ s_vProcessRxMACHeader(struct vnt_private *pDevice,
 
 	if (bIsWEP) {
 		if (bExtIV) {
-			// strip IV&ExtIV , add 8 byte
+			/* strip IV&ExtIV, add 8 byte */
 			cbHeaderSize += (WLAN_HDR_ADDR3_LEN + 8);
 		} else {
-			// strip IV , add 4 byte
+			/* strip IV, add 4 byte */
 			cbHeaderSize += (WLAN_HDR_ADDR3_LEN + 4);
 		}
 	} else {
@@ -182,9 +182,9 @@ s_vProcessRxMACHeader(struct vnt_private *pDevice,
 			pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
 			if (bIsWEP) {
 				if (bExtIV)
-					*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    // 8 is IV&ExtIV
+					*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    /* 8 is IV&ExtIV */
 				else
-					*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    // 4 is IV
+					*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    /* 4 is IV */
 
 			} else {
 				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
@@ -195,9 +195,9 @@ s_vProcessRxMACHeader(struct vnt_private *pDevice,
 		pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
 		if (bIsWEP) {
 			if (bExtIV)
-				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    // 8 is IV&ExtIV
+				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    /* 8 is IV&ExtIV */
 			else
-				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    // 4 is IV
+				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    /* 4 is IV */
 
 		} else {
 			*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
@@ -243,14 +243,14 @@ s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
 				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr3[ii];
 			}
 		} else {
-			// IBSS mode
+			/* IBSS mode */
 			for (ii = 0; ii < ETH_ALEN; ii++) {
 				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
 				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
 			}
 		}
 	} else {
-		// Is AP mode..
+		/* Is AP mode.. */
 		if (pMACHeader->wFrameCtl & FC_FROMDS) {
 			for (ii = 0; ii < ETH_ALEN; ii++) {
 				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr3[ii];
@@ -303,7 +303,7 @@ device_receive_frame(
 	unsigned short wRxTSC15_0 = 0;
 	unsigned long dwRxTSC47_16 = 0;
 	SKeyItem        STempKey;
-	// 802.11h RPI
+	/* 802.11h RPI */
 	unsigned long dwDuration = 0;
 	long            ldBm = 0;
 	long            ldBmThreshold = 0;
@@ -318,10 +318,12 @@ device_receive_frame(
 	pwFrameSize = (unsigned short *)(skb->data + 2);
 	FrameSize = cpu_to_le16(pCurrRD->m_rd1RD1.wReqCount) - cpu_to_le16(pCurrRD->m_rd0RD0.wResCount);
 
-	// Max: 2312Payload + 30HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
-	// Min (ACK): 10HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
+	/*
+	 * Max: 2312Payload + 30HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
+	 * Min (ACK): 10HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
+	 */
 	if ((FrameSize > 2364) || (FrameSize <= 32)) {
-		// Frame Size error drop this packet.
+		/* Frame Size error drop this packet. */
 		pr_debug("---------- WRONG Length 1\n");
 		return false;
 	}
@@ -335,16 +337,18 @@ device_receive_frame(
 	pqwTSFTime = (__le64 *)(skb->data + FrameSize - 12);
 	pbyFrame = (unsigned char *)(skb->data + 4);
 
-	// get packet size
+	/* get packet size */
 	FrameSize = cpu_to_le16(*pwFrameSize);
 
-	if ((FrameSize > 2346)|(FrameSize < 14)) { // Max: 2312Payload + 30HD +4CRC
-		// Min: 14 bytes ACK
+	if ((FrameSize > 2346)|(FrameSize < 14)) { /*
+						    * Max: 2312Payload + 30HD +4CRC
+						    * Min: 14 bytes ACK
+						    */
 		pr_debug("---------- WRONG Length 2\n");
 		return false;
 	}
 
-	// update receive statistic counter
+	/* update receive statistic counter */
 	STAvUpdateRDStatCounter(&pDevice->scStatistic,
 				*pbyRsr,
 				*pbyNewRsr,
@@ -362,10 +366,10 @@ device_receive_frame(
 		dwDuration /= acbyRxRate[*pbyRxRate%MAX_RATE];
 		if (*pbyRxRate <= RATE_11M) {
 			if (*pbyRxSts & 0x01) {
-				// long preamble
+				/* long preamble */
 				dwDuration += 192;
 			} else {
-				// short preamble
+				/* short preamble */
 				dwDuration += 96;
 			}
 		} else {
@@ -391,10 +395,10 @@ device_receive_frame(
 		}
 	}
 
-	// Use for TKIP MIC
+	/* Use for TKIP MIC */
 	s_vGetDASA(skb->data+4, &cbHeaderSize, &pDevice->sRxEthHeader);
 
-	// filter packet send from myself
+	/* filter packet send from myself */
 	if (ether_addr_equal(pDevice->sRxEthHeader.abySrcAddr,
 			     pDevice->abyCurrentNetAddr))
 		return false;
@@ -402,7 +406,7 @@ device_receive_frame(
 	if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) || (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)) {
 		if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
 			p802_11Header = (PS802_11Header)(pbyFrame);
-			// get SA NodeIndex
+			/* get SA NodeIndex */
 			if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(p802_11Header->abyAddr2), &iSANodeIndex)) {
 				pMgmt->sNodeDBTable[iSANodeIndex].ulLastRxJiffer = jiffies;
 				pMgmt->sNodeDBTable[iSANodeIndex].uInActiveCount = 0;
@@ -474,25 +478,22 @@ device_receive_frame(
 			return false;
 		}
 		if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP))
-			FrameSize -= 8;         // Message Integrity Code
+			FrameSize -= 8;         /* Message Integrity Code */
 		else
-			FrameSize -= 4;         // 4 is ICV
+			FrameSize -= 4;         /* 4 is ICV */
 	}
 
-	//
-	// RX OK
-	//
-	//remove the CRC length
+	/* RX OK, remove the CRC length */
 	FrameSize -= ETH_FCS_LEN;
 
-	if ((!(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI))) && // unicast address
+	if ((!(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI))) &&	/* unicast address */
 	    (IS_FRAGMENT_PKT((skb->data+4)))
 ) {
-		// defragment
+		/* defragment */
 		bDeFragRx = WCTLbHandleFragment(pDevice, (PS802_11Header)(skb->data+4), FrameSize, bIsWEP, bExtIV);
 		pDevice->s802_11Counter.ReceivedFragmentCount++;
 		if (bDeFragRx) {
-			// defrag complete
+			/* defrag complete */
 			skb = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].skb;
 			FrameSize = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].cbFrameLength;
 
@@ -501,9 +502,9 @@ device_receive_frame(
 		}
 	}
 
-// Management & Control frame Handle
+/* Management & Control frame Handle */
 	if ((IS_TYPE_DATA((skb->data+4))) == false) {
-		// Handle Control & Manage Frame
+		/* Handle Control & Manage Frame */
 
 		if (IS_TYPE_MGMT((skb->data+4))) {
 			unsigned char *pbyData1;
@@ -515,7 +516,7 @@ device_receive_frame(
 			pRxPacket->bySQ = *pbySQ;
 			pRxPacket->qwLocalTSF = le64_to_cpu(*pqwTSFTime);
 			if (bIsWEP) {
-				// strip IV
+				/* strip IV */
 				pbyData1 = WLAN_HDR_A3_DATA_PTR(skb->data+4);
 				pbyData2 = WLAN_HDR_A3_DATA_PTR(skb->data+4) + 4;
 				for (ii = 0; ii < (FrameSize - 4); ii++) {
@@ -529,7 +530,7 @@ device_receive_frame(
 
 			vMgrRxManagePacket((void *)pDevice, pDevice->pMgmt, pRxPacket);
 
-			// hostap Deamon handle 802.11 management
+			/* hostap Deamon handle 802.11 management */
 			if (pDevice->bEnableHostapd) {
 				skb->dev = pDevice->apdev;
 				skb->data += 4;
@@ -547,7 +548,7 @@ device_receive_frame(
 		return false;
 	} else {
 		if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-			//In AP mode, hw only check addr1(BSSID or RA) if equal to local MAC.
+			/* In AP mode, hw only check addr1(BSSID or RA) if equal to local MAC. */
 			if (!(*pbyRsr & RSR_BSSIDOK)) {
 				if (bDeFragRx) {
 					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
@@ -558,7 +559,7 @@ device_receive_frame(
 				return false;
 			}
 		} else {
-			// discard DATA packet while not associate || BSSID error
+			/* discard DATA packet while not associate || BSSID error */
 			if (!pDevice->bLinkPass || !(*pbyRsr & RSR_BSSIDOK)) {
 				if (bDeFragRx) {
 					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
@@ -568,10 +569,9 @@ device_receive_frame(
 				}
 				return false;
 			}
-			//mike add:station mode check eapol-key challenge--->
 			{
-				unsigned char Protocol_Version;    //802.1x Authentication
-				unsigned char Packet_Type;           //802.1x Authentication
+				unsigned char Protocol_Version;		/* 802.1x Authentication */
+				unsigned char Packet_Type;		/* 802.1x Authentication */
 
 				if (bIsWEP)
 					cbIVOffset = 8;
@@ -581,18 +581,17 @@ device_receive_frame(
 					skb->data[cbIVOffset + 8 + 24 + 6 + 1];
 				Protocol_Version = skb->data[cbIVOffset + 8 + 24 + 6 + 1 + 1];
 				Packet_Type = skb->data[cbIVOffset + 8 + 24 + 6 + 1 + 1 + 1];
-				if (wEtherType == ETH_P_PAE) {         //Protocol Type in LLC-Header
+				if (wEtherType == ETH_P_PAE) {         /* Protocol Type in LLC-Header */
 					if (((Protocol_Version == 1) || (Protocol_Version == 2)) &&
-					    (Packet_Type == 3)) {  //802.1x OR eapol-key challenge frame receive
+					    (Packet_Type == 3)) {  /*802.1x OR eapol-key challenge frame receive */
 						bRxeapol_key = true;
 					}
 				}
 			}
-			//mike add:station mode check eapol-key challenge<---
 		}
 	}
 
-// Data frame Handle
+/* Data frame Handle */
 
 	if (pDevice->bEnablePSMode) {
 		if (!IS_FC_MOREDATA((skb->data+4))) {
@@ -601,7 +600,7 @@ device_receive_frame(
 		}
 	}
 
-	// Now it only supports 802.11g Infrastructure Mode, and support rate must up to 54 Mbps
+	/* Now it only supports 802.11g Infrastructure Mode, and support rate must up to 54 Mbps */
 	if (pDevice->bDiversityEnable && (FrameSize > 50) &&
 	    (pDevice->op_mode == NL80211_IFTYPE_STATION) &&
 	    pDevice->bLinkPass) {
@@ -616,7 +615,7 @@ device_receive_frame(
 	if ((*pbyRSSI != 0) &&
 	    (pMgmt->pCurrBSS != NULL)) {
 		RFvRSSITodBm(pDevice, *pbyRSSI, &ldBm);
-		// Monitor if RSSI is too strong.
+		/* Monitor if RSSI is too strong. */
 		pMgmt->pCurrBSS->byRSSIStatCnt++;
 		pMgmt->pCurrBSS->byRSSIStatCnt %= RSSI_STAT_COUNT;
 		pMgmt->pCurrBSS->ldBmAverage[pMgmt->pCurrBSS->byRSSIStatCnt] = ldBm;
@@ -626,12 +625,10 @@ device_receive_frame(
 
 	}
 
-	// -----------------------------------------------
-
 	if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) && pDevice->bEnable8021x) {
 		unsigned char abyMacHdr[24];
 
-		// Only 802.1x packet incoming allowed
+		/* Only 802.1x packet incoming allowed */
 		if (bIsWEP)
 			cbIVOffset = 8;
 		else
@@ -644,7 +641,7 @@ device_receive_frame(
 			skb->dev = pDevice->apdev;
 
 			if (bIsWEP) {
-				// strip IV header(8)
+				/* strip IV header(8) */
 				memcpy(&abyMacHdr[0], (skb->data + 4), 24);
 				memcpy((skb->data + 4 + cbIVOffset), &abyMacHdr[0], 24);
 			}
@@ -660,18 +657,17 @@ device_receive_frame(
 			return true;
 
 		}
-		// check if 802.1x authorized
+		/* check if 802.1x authorized */
 		if (!(pMgmt->sNodeDBTable[iSANodeIndex].dwFlags & WLAN_STA_AUTHORIZED))
 			return false;
 	}
 
 	if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
 		if (bIsWEP)
-			FrameSize -= 8;  //MIC
+			FrameSize -= 8;  /* MIC */
 	}
 
-	//--------------------------------------------------------------------------------
-	// Soft MIC
+	/* Soft MIC */
 	if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
 		if (bIsWEP) {
 			__le32 *pdwMIC_L;
@@ -702,7 +698,7 @@ device_receive_frame(
 			MIC_vAppend((unsigned char *)&(pDevice->sRxEthHeader.abyDstAddr[0]), 12);
 			dwMIC_Priority = 0;
 			MIC_vAppend((unsigned char *)&dwMIC_Priority, 4);
-			// 4 is Rcv buffer header, 24 is MAC Header, and 8 is IV and Ext IV.
+			/* 4 is Rcv buffer header, 24 is MAC Header, and 8 is IV and Ext IV. */
 			MIC_vAppend((unsigned char *)(skb->data + 4 + WLAN_HDR_ADDR3_LEN + 8),
 				    FrameSize - WLAN_HDR_ADDR3_LEN - 8);
 			MIC_vGetMIC(&dwLocalMIC_L, &dwLocalMIC_R);
@@ -723,13 +719,12 @@ device_receive_frame(
 						       pDevice->dev->name);
 					}
 				}
-				//2008-0409-07, <Add> by Einsn Liu
 #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-				//send event to wpa_supplicant
+				/* send event to wpa_supplicant */
 				{
 					union iwreq_data wrqu;
 					struct iw_michaelmicfailure ev;
-					int keyidx = pbyFrame[cbHeaderSize+3] >> 6; //top two-bits
+					int keyidx = pbyFrame[cbHeaderSize+3] >> 6; /* top two-bits */
 
 					memset(&ev, 0, sizeof(ev));
 					ev.flags = keyidx & IW_MICFAILURE_KEY_ID;
@@ -776,17 +771,16 @@ device_receive_frame(
 
 			}
 		}
-	} //---end of SOFT MIC-----------------------------------------------------------------------
-
-	// ++++++++++ Reply Counter Check +++++++++++++
+	}
 
+	/* ++++++++++ Reply Counter Check +++++++++++++ */
 	if ((pKey != NULL) && ((pKey->byCipherSuite == KEY_CTL_TKIP) ||
 			       (pKey->byCipherSuite == KEY_CTL_CCMP))) {
 		if (bIsWEP) {
 			unsigned short wLocalTSC15_0 = 0;
 			unsigned long dwLocalTSC47_16 = 0;
 			unsigned long long       RSC = 0;
-			// endian issues
+			/* endian issues */
 			RSC = *((unsigned long long *)&(pKey->KeyRSC));
 			wLocalTSC15_0 = (unsigned short)RSC;
 			dwLocalTSC47_16 = (unsigned long)(RSC>>16);
@@ -798,7 +792,7 @@ device_receive_frame(
 
 			if ((pDevice->sMgmtObj.eCurrMode == WMAC_MODE_ESS_STA) &&
 			    (pDevice->sMgmtObj.eCurrState == WMAC_STATE_ASSOC)) {
-				// check RSC
+				/* check RSC */
 				if ((wRxTSC15_0 < wLocalTSC15_0) &&
 				    (dwRxTSC47_16 <= dwLocalTSC47_16) &&
 				    !((dwRxTSC47_16 == 0) && (dwLocalTSC47_16 == 0xFFFFFFFF))) {
@@ -818,13 +812,13 @@ device_receive_frame(
 				}
 			}
 		}
-	} // ----- End of Reply Counter Check --------------------------
+	}
 
 	s_vProcessRxMACHeader(pDevice, (unsigned char *)(skb->data+4), FrameSize, bIsWEP, bExtIV, &cbHeaderOffset);
 	FrameSize -= cbHeaderOffset;
-	cbHeaderOffset += 4;        // 4 is Rcv buffer header
+	cbHeaderOffset += 4;        /* 4 is Rcv buffer header */
 
-	// Null data, framesize = 14
+	/* Null data, framesize = 14 */
 	if (FrameSize < 15)
 		return false;
 
@@ -851,7 +845,7 @@ device_receive_frame(
 	skb_put(skb, FrameSize);
 	skb->protocol = eth_type_trans(skb, skb->dev);
 
-	//drop frame not met IEEE 802.3
+	/* drop frame not met IEEE 802.3 */
 
 	skb->ip_summed = CHECKSUM_NONE;
 	pStats->rx_bytes += skb->len;
@@ -882,13 +876,14 @@ static bool s_bAPModeRxCtl(
 	if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
 		p802_11Header = (PS802_11Header)(pbyFrame);
 		if (!IS_TYPE_MGMT(pbyFrame)) {
-			// Data & PS-Poll packet
-			// check frame class
+			/* Data & PS-Poll packet, check frame class */
 			if (iSANodeIndex > 0) {
-				// frame class 3 fliter & checking
+				/* frame class 3 fliter & checking */
 				if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_AUTH) {
-					// send deauth notification
-					// reason = (6) class 2 received from nonauth sta
+					/*
+					 * send deauth notification
+					 * reason = (6) class 2 received from nonauth sta
+					 */
 					vMgrDeAuthenBeginSta(pDevice,
 							     pMgmt,
 							     (unsigned char *)(p802_11Header->abyAddr2),
@@ -899,8 +894,10 @@ static bool s_bAPModeRxCtl(
 					return true;
 				}
 				if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_ASSOC) {
-					// send deassoc notification
-					// reason = (7) class 3 received from nonassoc sta
+					/*
+					 * send deassoc notification
+					 * reason = (7) class 3 received from nonassoc sta
+					 */
 					vMgrDisassocBeginSta(pDevice,
 							     pMgmt,
 							     (unsigned char *)(p802_11Header->abyAddr2),
@@ -912,14 +909,16 @@ static bool s_bAPModeRxCtl(
 				}
 
 				if (pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable) {
-					// delcare received ps-poll event
+					/* delcare received ps-poll event */
 					if (IS_CTL_PSPOLL(pbyFrame)) {
 						pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
 						bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
 						pr_debug("dpc: WLAN_CMD_RX_PSPOLL 1\n");
 					} else {
-						// check Data PS state
-						// if PW bit off, send out all PS bufferring packets.
+						/*
+						 * check Data PS state
+						 * if PW bit off, send out all PS bufferring packets.
+						 */
 						if (!IS_FC_POWERMGT(pbyFrame)) {
 							pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
 							pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
@@ -930,10 +929,10 @@ static bool s_bAPModeRxCtl(
 				} else {
 					if (IS_FC_POWERMGT(pbyFrame)) {
 						pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = true;
-						// Once if STA in PS state, enable multicast bufferring
+						/* Once if STA in PS state, enable multicast bufferring */
 						pMgmt->sNodeDBTable[0].bPSEnable = true;
 					} else {
-						// clear all pending PS frame.
+						/* clear all pending PS frame. */
 						if (pMgmt->sNodeDBTable[iSANodeIndex].wEnQueueCnt > 0) {
 							pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
 							pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
@@ -994,7 +993,7 @@ static bool s_bHandleRxEncryption(
 	pbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;
 	if (WLAN_GET_FC_TODS(*(unsigned short *)pbyFrame) &&
 	    WLAN_GET_FC_FROMDS(*(unsigned short *)pbyFrame)) {
-		pbyIV += 6;             // 6 is 802.11 address4
+		pbyIV += 6;             /* 6 is 802.11 address4 */
 		PayloadLen -= 6;
 	}
 	byKeyIdx = (*(pbyIV+3) & 0xc0);
@@ -1008,7 +1007,7 @@ static bool s_bHandleRxEncryption(
 	    (pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {
 		if (((*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) &&
 		    (pDevice->pMgmt->byCSSPK != KEY_CTL_NONE)) {
-			// unicast pkt use pairwise key
+			/* unicast pkt use pairwise key */
 			pr_debug("unicast pkt\n");
 			if (KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, 0xFFFFFFFF, &pKey) == true) {
 				if (pDevice->pMgmt->byCSSPK == KEY_CTL_TKIP)
@@ -1018,7 +1017,7 @@ static bool s_bHandleRxEncryption(
 			}
 			pr_debug("unicast pkt: %d, %p\n", byDecMode, pKey);
 		} else {
-			// use group key
+			/* use group key */
 			KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, byKeyIdx, &pKey);
 			if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
 				byDecMode = KEY_CTL_TKIP;
@@ -1028,9 +1027,9 @@ static bool s_bHandleRxEncryption(
 				 byKeyIdx, byDecMode, pKey);
 		}
 	}
-	// our WEP only support Default Key
+	/* our WEP only support Default Key */
 	if (pKey == NULL) {
-		// use default group key
+		/* use default group key */
 		KeybGetKey(&(pDevice->sKey), pDevice->abyBroadcastAddr, byKeyIdx, &pKey);
 		if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
 			byDecMode = KEY_CTL_TKIP;
@@ -1053,14 +1052,16 @@ static bool s_bHandleRxEncryption(
 		return false;
 	}
 	if (byDecMode == KEY_CTL_WEP) {
-		// handle WEP
+		/* handle WEP */
 		if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
 		    (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true)) {
-			// Software WEP
-			// 1. 3253A
-			// 2. WEP 256
+			/*
+			 * Software WEP
+			 * 1. 3253A
+			 * 2. WEP 256
+			 */
 
-			PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); // 24 is 802.11 header,4 is IV, 4 is crc
+			PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); /* 24 is 802.11 header,4 is IV, 4 is crc */
 			memcpy(pDevice->abyPRNG, pbyIV, 3);
 			memcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
 			rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
@@ -1072,9 +1073,9 @@ static bool s_bHandleRxEncryption(
 		}
 	} else if ((byDecMode == KEY_CTL_TKIP) ||
 		   (byDecMode == KEY_CTL_CCMP)) {
-		// TKIP/AES
+		/* TKIP/AES */
 
-		PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
+		PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); /* 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc */
 		*pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
 		pr_debug("ExtIV: %lx\n", *pdwRxTSC47_16);
 		if (byDecMode == KEY_CTL_TKIP)
@@ -1086,8 +1087,10 @@ static bool s_bHandleRxEncryption(
 
 		if ((byDecMode == KEY_CTL_TKIP) &&
 		    (pDevice->byLocalID <= REV_ID_VT3253_A1)) {
-			// Software TKIP
-			// 1. 3253 A
+			/*
+			 * Software TKIP
+			 * 1. 3253 A
+			 */
 			PS802_11Header  pMACHeader = (PS802_11Header)(pbyFrame);
 
 			TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
@@ -1101,7 +1104,7 @@ static bool s_bHandleRxEncryption(
 				pr_debug("PayloadLen = %d\n", PayloadLen);
 			}
 		}
-	}// end of TKIP/AES
+	}
 
 	if ((*(pbyIV+3) & 0x20) != 0)
 		*pbExtIV = true;
@@ -1133,7 +1136,7 @@ static bool s_bHostWepRxEncryption(
 	pbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;
 	if (WLAN_GET_FC_TODS(*(unsigned short *)pbyFrame) &&
 	    WLAN_GET_FC_FROMDS(*(unsigned short *)pbyFrame)) {
-		pbyIV += 6;             // 6 is 802.11 address4
+		pbyIV += 6;             /* 6 is 802.11 address4 */
 		PayloadLen -= 6;
 	}
 	byKeyIdx = (*(pbyIV+3) & 0xc0);
@@ -1152,18 +1155,20 @@ static bool s_bHostWepRxEncryption(
 		return false;
 
 	if (byDecMode == KEY_CTL_WEP) {
-		// handle WEP
+		/* handle WEP */
 		pr_debug("byDecMode == KEY_CTL_WEP\n");
 
 		if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
 		    (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true) ||
 		    !bOnFly) {
-			// Software WEP
-			// 1. 3253A
-			// 2. WEP 256
-			// 3. NotOnFly
-
-			PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); // 24 is 802.11 header,4 is IV, 4 is crc
+			/*
+			 * Software WEP
+			 * 1. 3253A
+			 * 2. WEP 256
+			 * 3. NotOnFly
+			 */
+
+			PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); /* 24 is 802.11 header,4 is IV, 4 is crc */
 			memcpy(pDevice->abyPRNG, pbyIV, 3);
 			memcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
 			rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
@@ -1175,9 +1180,9 @@ static bool s_bHostWepRxEncryption(
 		}
 	} else if ((byDecMode == KEY_CTL_TKIP) ||
 		   (byDecMode == KEY_CTL_CCMP)) {
-		// TKIP/AES
+		/* TKIP/AES */
 
-		PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
+		PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); /* 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc */
 		*pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
 		pr_debug("ExtIV: %lx\n", *pdwRxTSC47_16);
 
@@ -1190,9 +1195,11 @@ static bool s_bHostWepRxEncryption(
 
 		if (byDecMode == KEY_CTL_TKIP) {
 			if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || !bOnFly) {
-				// Software TKIP
-				// 1. 3253 A
-				// 2. NotOnFly
+				/*
+				 * Software TKIP
+				 * 1. 3253 A
+				 * 2. NotOnFly
+				 */
 				pr_debug("soft KEY_CTL_TKIP\n");
 				pMACHeader = (PS802_11Header)(pbyFrame);
 				TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
@@ -1211,8 +1218,10 @@ static bool s_bHostWepRxEncryption(
 
 		if (byDecMode == KEY_CTL_CCMP) {
 			if (!bOnFly) {
-				// Software CCMP
-				// NotOnFly
+				/*
+				 * Software CCMP
+				 * NotOnFly
+				 */
 				pr_debug("soft KEY_CTL_CCMP\n");
 				if (AESbGenCCMP(pKey->abyKey, pbyFrame, FrameSize)) {
 					*pbyNewRsr |= NEWRSR_DECRYPTOK;
@@ -1223,7 +1232,7 @@ static bool s_bHostWepRxEncryption(
 			}
 		}
 
-	}// end of TKIP/AES
+	}
 
 	if ((*(pbyIV+3) & 0x20) != 0)
 		*pbExtIV = true;
@@ -1249,12 +1258,12 @@ static bool s_bAPModeRxData(
 
 	if (FrameSize > CB_MAX_BUF_SIZE)
 		return false;
-	// check DA
+	/* check DA */
 	if (is_multicast_ether_addr((unsigned char *)(skb->data+cbHeaderOffset))) {
 		if (pMgmt->sNodeDBTable[0].bPSEnable) {
 			skbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);
 
-			// if any node in PS mode, buffer packet until DTIM.
+			/* if any node in PS mode, buffer packet until DTIM. */
 			if (skbcpy == NULL) {
 				pr_info("relay multicast no skb available\n");
 			} else {
@@ -1264,18 +1273,18 @@ static bool s_bAPModeRxData(
 				skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skbcpy);
 
 				pMgmt->sNodeDBTable[0].wEnQueueCnt++;
-				// set tx map
+				/* set tx map */
 				pMgmt->abyPSTxMap[0] |= byMask[0];
 			}
 		} else {
 			bRelayAndForward = true;
 		}
 	} else {
-		// check if relay
+		/* check if relay */
 		if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data+cbHeaderOffset), &iDANodeIndex)) {
 			if (pMgmt->sNodeDBTable[iDANodeIndex].eNodeState >= NODE_ASSOC) {
 				if (pMgmt->sNodeDBTable[iDANodeIndex].bPSEnable) {
-					// queue this skb until next PS tx, and then release.
+					/* queue this skb until next PS tx, and then release. */
 
 					skb->data += cbHeaderOffset;
 					skb->tail += cbHeaderOffset;
@@ -1296,7 +1305,7 @@ static bool s_bAPModeRxData(
 	}
 
 	if (bRelayOnly || bRelayAndForward) {
-		// relay this packet right now
+		/* relay this packet right now */
 		if (bRelayAndForward)
 			iDANodeIndex = 0;
 
@@ -1306,7 +1315,7 @@ static bool s_bAPModeRxData(
 		if (bRelayOnly)
 			return false;
 	}
-	// none associate, don't forward
+	/* none associate, don't forward */
 	if (pDevice->uAssocCount == 0)
 		return false;
 

commit 1d06bb4e9df30162d8690a26792611a141676279
Author: Jiayi Ye <yejiayily@gmail.com>
Date:   Sat Oct 25 10:58:28 2014 +0800

    staging: remove unneeded parentheses around the right hand side of an assignment
    
    In assignments such as value = (FLASH_CMD_STATUS_REG_READ << 24);, parentheses
    are not needed. The Coccinelle semantic patch was used to find cases.
    
    @r@
    identifier x;
    expression e1, e2;
    @@
    
    - x = (e1 << e2);
    + x = e1 << e2;
    
    Signed-off-by: Jiayi Ye <yejiayily@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 344e12f1184e..eecf6f559e29 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -358,7 +358,7 @@ device_receive_frame(
 		if ((*pbyRsr & RSR_CRCOK) != 0)
 			pDevice->byBasicMap |= 0x01;
 
-		dwDuration = (FrameSize << 4);
+		dwDuration = FrameSize << 4;
 		dwDuration /= acbyRxRate[*pbyRxRate%MAX_RATE];
 		if (*pbyRxRate <= RATE_11M) {
 			if (*pbyRxSts & 0x01) {

commit 87bb326eada535ed72ca312878bb5ba69bad870b
Author: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
Date:   Sat Oct 11 02:34:07 2014 +0200

    staging: vt6655: dpc.c: replace memcpy() by ether_addr_copy() using coccinelle
    
    This patch focuses on fixing the following warning generated
    by checkpatch.pl for the file dpc.c :
    
    Prefer ether_addr_copy() over memcpy() if the Ethernet addresses
    are __aligned(2)
    
    The changes were applied using the following coccinelle rule:
    
    @@ expression e1, e2; @@
    
    - memcpy(e1, e2, ETH_ALEN);
    + ether_addr_copy(e1, e2);
    
    According to ether_addr_copy() description and functionality,
    all Ethernet addresses should align to the u16 datatype.
    
    Here is the output of pahole for the relevant datastructures:
    
    struct tagS802_11Header {
            short unsigned int         wFrameCtl;            /*     0     2 */
            short unsigned int         wDurationID;          /*     2     2 */
            unsigned char              abyAddr1[6];          /*     4     6 */
            unsigned char              abyAddr2[6];          /*    10     6 */
            unsigned char              abyAddr3[6];          /*    16     6 */
            short unsigned int         wSeqCtl;              /*    22     2 */
            unsigned char              abyAddr4[6];          /*    24     6 */
    
            /* size: 30, cachelines: 1, members: 7 */
            /* last cacheline: 30 bytes */
    };
    struct iw_michaelmicfailure {
            __u32                      flags;                /*     0     4 */
            struct sockaddr            src_addr;             /*     4    16 */
            __u8                       tsc[8];               /*    20     8 */
    
            /* size: 28, cachelines: 1, members: 3 */
            /* last cacheline: 28 bytes */
    };
    struct sockaddr {
            sa_family_t                sa_family;            /*     0     2 */
            char                       sa_data[14];          /*     2    14 */
    
            /* size: 16, cachelines: 1, members: 2 */
            /* last cacheline: 16 bytes */
    };
    
    There is one thing to note though, sa_data is a char array of size 14.
    And the number of bytes copied using memcpy() or ether_addr_copy()
    is 6.
    
    Signed-off-by: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 8515b8c80801..344e12f1184e 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -742,7 +742,8 @@ device_receive_frame(
 					}
 
 					ev.src_addr.sa_family = ARPHRD_ETHER;
-					memcpy(ev.src_addr.sa_data, pMACHeader->abyAddr2, ETH_ALEN);
+					ether_addr_copy(ev.src_addr.sa_data,
+							pMACHeader->abyAddr2);
 					memset(&wrqu, 0, sizeof(wrqu));
 					wrqu.data.length = sizeof(ev);
 					wireless_send_event(pDevice->dev, IWEVMICHAELMICFAILURE, &wrqu, (char *)&ev);

commit 22981e0e5ab3aedfb46698ed7c12c7b944781bd3
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Sep 10 09:34:50 2014 +0200

    staging: vt6655: Use net_device_stats from struct net_device
    
    Instead of using an own copy of struct net_device_stats in struct
    vnt_private, use stats from struct net_device. Also remove the thus
    unnecessary device_get_stats(), as it would now just return
    netdev->stats, which is the default in dev_get_stats().
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 6fb6cdfbf5bc..8515b8c80801 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -274,7 +274,7 @@ device_receive_frame(
 )
 {
 	PDEVICE_RD_INFO  pRDInfo = pCurrRD->pRDInfo;
-	struct net_device_stats *pStats = &pDevice->stats;
+	struct net_device_stats *pStats = &pDevice->dev->stats;
 	struct sk_buff *skb;
 	PSMgmtObject    pMgmt = pDevice->pMgmt;
 	PSRxMgmtPacket  pRxPacket = &(pDevice->pMgmt->sRxPacket);

commit a9873673484b5aa4346111d021c83a2f11d62eb5
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Aug 30 22:25:49 2014 +0100

    staging: vt6655: Replace typedef enum _CARD_OP_MODE eOPMode with enum nl80211_iftype op_mode.
    
    Using the nl80211 header.
    
    Using enum changes
    OP_MODE_ADHOC -> NL80211_IFTYPE_ADHOC
    OP_MODE_AP ->  NL80211_IFTYPE_AP
    OP_MODE_INFRASTRUCTURE -> NL80211_IFTYPE_STATION
    OP_MODE_UNKNOWN -> NL80211_IFTYPE_UNSPECIFIED
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 60eb1297ed83..6fb6cdfbf5bc 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -603,7 +603,7 @@ device_receive_frame(
 
 	// Now it only supports 802.11g Infrastructure Mode, and support rate must up to 54 Mbps
 	if (pDevice->bDiversityEnable && (FrameSize > 50) &&
-	    (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE) &&
+	    (pDevice->op_mode == NL80211_IFTYPE_STATION) &&
 	    pDevice->bLinkPass) {
 		BBvAntennaDiversity(pDevice, s_byGetRateIdx(*pbyRxRate), 0);
 	}

commit 9e9df6704c1929ffd76e73f4740a468e00c44c11
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Aug 17 20:42:29 2014 +0100

    staging: vt6655: remove remaining comments of PLICE_DEBUG
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 7589cb4805f9..60eb1297ed83 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -312,10 +312,9 @@ device_receive_frame(
 
 	skb = pRDInfo->skb;
 
-//PLICE_DEBUG->
 	pci_unmap_single(pDevice->pcid, pRDInfo->skb_dma,
 			 pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
-//PLICE_DEBUG<-
+
 	pwFrameSize = (unsigned short *)(skb->data + 2);
 	FrameSize = cpu_to_le16(pCurrRD->m_rd1RD1.wReqCount) - cpu_to_le16(pCurrRD->m_rd0RD0.wResCount);
 
@@ -344,7 +343,7 @@ device_receive_frame(
 		pr_debug("---------- WRONG Length 2\n");
 		return false;
 	}
-//PLICE_DEBUG->
+
 	// update receive statistic counter
 	STAvUpdateRDStatCounter(&pDevice->scStatistic,
 				*pbyRsr,
@@ -354,7 +353,7 @@ device_receive_frame(
 				FrameSize);
 
 	pMACHeader = (PS802_11Header)((unsigned char *)(skb->data) + 8);
-//PLICE_DEBUG<-
+
 	if (pDevice->bMeasureInProgress) {
 		if ((*pbyRsr & RSR_CRCOK) != 0)
 			pDevice->byBasicMap |= 0x01;

commit 48caf5a060491edb2e1793539dad72e70c54c869
Author: Joe Perches <joe@perches.com>
Date:   Sun Aug 17 09:17:04 2014 -0700

    staging: vt6655: Convert DBG_PRT to pr_<level>
    
    DBG_PRT uses are unnecessarily complex.
    
    Convert DBG_PRT msglevel to pr_<level>.
    This changes the KERN_<level> type of several uses.
    It also enables dynamic_debug for the pr_debug conversions.
    
    This patch can be a prelude to converting these pr_<level>
    uses to dev_<level> as appropriate.
    
    Other changes:
    
    Realign arguments of these conversions.
    Remove now unused static int msglevel declarations.
    Remove now unused DBG_PRT #define.
    
    Compile tested only.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index d26ca96d2da4..7589cb4805f9 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -61,8 +61,6 @@
 /*---------------------  Static Classes  ----------------------------*/
 
 /*---------------------  Static Variables  --------------------------*/
-static int msglevel = MSG_LEVEL_INFO;
-
 static const unsigned char acbyRxRate[MAX_RATE] =
 {2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108};
 
@@ -325,7 +323,7 @@ device_receive_frame(
 	// Min (ACK): 10HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
 	if ((FrameSize > 2364) || (FrameSize <= 32)) {
 		// Frame Size error drop this packet.
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---------- WRONG Length 1\n");
+		pr_debug("---------- WRONG Length 1\n");
 		return false;
 	}
 
@@ -343,7 +341,7 @@ device_receive_frame(
 
 	if ((FrameSize > 2346)|(FrameSize < 14)) { // Max: 2312Payload + 30HD +4CRC
 		// Min: 14 bytes ACK
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---------- WRONG Length 2\n");
+		pr_debug("---------- WRONG Length 2\n");
 		return false;
 	}
 //PLICE_DEBUG->
@@ -421,7 +419,7 @@ device_receive_frame(
 	if (IS_FC_WEP(pbyFrame)) {
 		bool bRxDecryOK = false;
 
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "rx WEP pkt\n");
+		pr_debug("rx WEP pkt\n");
 		bIsWEP = true;
 		if ((pDevice->bEnableHostWEP) && (iSANodeIndex >= 0)) {
 			pKey = &STempKey;
@@ -459,7 +457,7 @@ device_receive_frame(
 
 		if (bRxDecryOK) {
 			if ((*pbyNewRsr & NEWRSR_DECRYPTOK) == 0) {
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ICV Fail\n");
+				pr_debug("ICV Fail\n");
 				if ((pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||
 				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||
 				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||
@@ -473,7 +471,7 @@ device_receive_frame(
 				return false;
 			}
 		} else {
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "WEP Func Fail\n");
+			pr_debug("WEP Func Fail\n");
 			return false;
 		}
 		if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP))
@@ -554,8 +552,8 @@ device_receive_frame(
 			if (!(*pbyRsr & RSR_BSSIDOK)) {
 				if (bDeFragRx) {
 					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-						DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
-							pDevice->dev->name);
+						pr_err("%s: can not alloc more frag bufs\n",
+						       pDevice->dev->name);
 					}
 				}
 				return false;
@@ -565,8 +563,8 @@ device_receive_frame(
 			if (!pDevice->bLinkPass || !(*pbyRsr & RSR_BSSIDOK)) {
 				if (bDeFragRx) {
 					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-						DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
-							pDevice->dev->name);
+						pr_err("%s: can not alloc more frag bufs\n",
+						       pDevice->dev->name);
 					}
 				}
 				return false;
@@ -642,7 +640,7 @@ device_receive_frame(
 		wEtherType = (skb->data[cbIVOffset + 4 + 24 + 6] << 8) |
 			skb->data[cbIVOffset + 4 + 24 + 6 + 1];
 
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wEtherType = %04x\n", wEtherType);
+		pr_debug("wEtherType = %04x\n", wEtherType);
 		if (wEtherType == ETH_P_PAE) {
 			skb->dev = pDevice->apdev;
 
@@ -717,13 +715,13 @@ device_receive_frame(
 			if ((le32_to_cpu(*pdwMIC_L) != dwLocalMIC_L) ||
 			    (le32_to_cpu(*pdwMIC_R) != dwLocalMIC_R) ||
 			    pDevice->bRxMICFail) {
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MIC comparison is fail!\n");
+				pr_debug("MIC comparison is fail!\n");
 				pDevice->bRxMICFail = false;
 				pDevice->s802_11Counter.TKIPLocalMICFailures++;
 				if (bDeFragRx) {
 					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-						DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
-							pDevice->dev->name);
+						pr_err("%s: can not alloc more frag bufs\n",
+						       pDevice->dev->name);
 					}
 				}
 				//2008-0409-07, <Add> by Einsn Liu
@@ -804,7 +802,7 @@ device_receive_frame(
 				if ((wRxTSC15_0 < wLocalTSC15_0) &&
 				    (dwRxTSC47_16 <= dwLocalTSC47_16) &&
 				    !((dwRxTSC47_16 == 0) && (dwLocalTSC47_16 == 0xFFFFFFFF))) {
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "TSC is illegal~~!\n ");
+					pr_debug("TSC is illegal~~!\n ");
 					if (pKey->byCipherSuite == KEY_CTL_TKIP)
 						pDevice->s802_11Counter.TKIPReplays++;
 					else
@@ -812,8 +810,8 @@ device_receive_frame(
 
 					if (bDeFragRx) {
 						if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-							DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
-								pDevice->dev->name);
+							pr_err("%s: can not alloc more frag bufs\n",
+							       pDevice->dev->name);
 						}
 					}
 					return false;
@@ -840,8 +838,8 @@ device_receive_frame(
 )) {
 			if (bDeFragRx) {
 				if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-					DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
-						pDevice->dev->name);
+					pr_err("%s: can not alloc more frag bufs\n",
+					       pDevice->dev->name);
 				}
 			}
 			return false;
@@ -862,8 +860,8 @@ device_receive_frame(
 
 	if (bDeFragRx) {
 		if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-			DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
-				pDevice->dev->name);
+			pr_err("%s: can not alloc more frag bufs\n",
+			       pDevice->dev->name);
 		}
 		return false;
 	}
@@ -897,7 +895,7 @@ static bool s_bAPModeRxCtl(
 							     (WLAN_MGMT_REASON_CLASS2_NONAUTH),
 							     &Status
 );
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 1\n");
+					pr_debug("dpc: send vMgrDeAuthenBeginSta 1\n");
 					return true;
 				}
 				if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_ASSOC) {
@@ -909,7 +907,7 @@ static bool s_bAPModeRxCtl(
 							     (WLAN_MGMT_REASON_CLASS3_NONASSOC),
 							     &Status
 );
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDisassocBeginSta 2\n");
+					pr_debug("dpc: send vMgrDisassocBeginSta 2\n");
 					return true;
 				}
 
@@ -918,7 +916,7 @@ static bool s_bAPModeRxCtl(
 					if (IS_CTL_PSPOLL(pbyFrame)) {
 						pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
 						bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 1\n");
+						pr_debug("dpc: WLAN_CMD_RX_PSPOLL 1\n");
 					} else {
 						// check Data PS state
 						// if PW bit off, send out all PS bufferring packets.
@@ -926,7 +924,7 @@ static bool s_bAPModeRxCtl(
 							pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
 							pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
 							bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-							DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 2\n");
+							pr_debug("dpc: WLAN_CMD_RX_PSPOLL 2\n");
 						}
 					}
 				} else {
@@ -940,7 +938,7 @@ static bool s_bAPModeRxCtl(
 							pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
 							pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
 							bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-							DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 3\n");
+							pr_debug("dpc: WLAN_CMD_RX_PSPOLL 3\n");
 
 						}
 					}
@@ -952,16 +950,18 @@ static bool s_bAPModeRxCtl(
 						     (WLAN_MGMT_REASON_CLASS2_NONAUTH),
 						     &Status
 );
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 3\n");
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "BSSID:%pM\n",
-					p802_11Header->abyAddr3);
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR2:%pM\n",
-					p802_11Header->abyAddr2);
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR1:%pM\n",
-					p802_11Header->abyAddr1);
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: wFrameCtl= %x\n", p802_11Header->wFrameCtl);
+				pr_debug("dpc: send vMgrDeAuthenBeginSta 3\n");
+				pr_debug("BSSID:%pM\n",
+					 p802_11Header->abyAddr3);
+				pr_debug("ADDR2:%pM\n",
+					 p802_11Header->abyAddr2);
+				pr_debug("ADDR1:%pM\n",
+					 p802_11Header->abyAddr1);
+				pr_debug("dpc: wFrameCtl= %x\n",
+					 p802_11Header->wFrameCtl);
 				VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc:pDevice->byRxMode = %x\n", pDevice->byRxMode);
+				pr_debug("dpc:pDevice->byRxMode = %x\n",
+					 pDevice->byRxMode);
 				return true;
 			}
 		}
@@ -999,7 +999,7 @@ static bool s_bHandleRxEncryption(
 	}
 	byKeyIdx = (*(pbyIV+3) & 0xc0);
 	byKeyIdx >>= 6;
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "\nKeyIdx: %d\n", byKeyIdx);
+	pr_debug("\nKeyIdx: %d\n", byKeyIdx);
 
 	if ((pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||
 	    (pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||
@@ -1009,14 +1009,14 @@ static bool s_bHandleRxEncryption(
 		if (((*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) &&
 		    (pDevice->pMgmt->byCSSPK != KEY_CTL_NONE)) {
 			// unicast pkt use pairwise key
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "unicast pkt\n");
+			pr_debug("unicast pkt\n");
 			if (KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, 0xFFFFFFFF, &pKey) == true) {
 				if (pDevice->pMgmt->byCSSPK == KEY_CTL_TKIP)
 					byDecMode = KEY_CTL_TKIP;
 				else if (pDevice->pMgmt->byCSSPK == KEY_CTL_CCMP)
 					byDecMode = KEY_CTL_CCMP;
 			}
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "unicast pkt: %d, %p\n", byDecMode, pKey);
+			pr_debug("unicast pkt: %d, %p\n", byDecMode, pKey);
 		} else {
 			// use group key
 			KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, byKeyIdx, &pKey);
@@ -1024,7 +1024,8 @@ static bool s_bHandleRxEncryption(
 				byDecMode = KEY_CTL_TKIP;
 			else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
 				byDecMode = KEY_CTL_CCMP;
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "group pkt: %d, %d, %p\n", byKeyIdx, byDecMode, pKey);
+			pr_debug("group pkt: %d, %d, %p\n",
+				 byKeyIdx, byDecMode, pKey);
 		}
 	}
 	// our WEP only support Default Key
@@ -1038,10 +1039,11 @@ static bool s_bHandleRxEncryption(
 	}
 	*pKeyOut = pKey;
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
+	pr_debug("AES:%d %d %d\n",
+		 pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
 
 	if (pKey == NULL) {
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pKey == NULL\n");
+		pr_debug("pKey == NULL\n");
 
 		return false;
 	}
@@ -1074,13 +1076,13 @@ static bool s_bHandleRxEncryption(
 
 		PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
 		*pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ExtIV: %lx\n", *pdwRxTSC47_16);
+		pr_debug("ExtIV: %lx\n", *pdwRxTSC47_16);
 		if (byDecMode == KEY_CTL_TKIP)
 			*pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV + 2), *pbyIV));
 		else
 			*pwRxTSC15_0 = cpu_to_le16(*(unsigned short *)pbyIV);
 
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "TSC0_15: %x\n", *pwRxTSC15_0);
+		pr_debug("TSC0_15: %x\n", *pwRxTSC15_0);
 
 		if ((byDecMode == KEY_CTL_TKIP) &&
 		    (pDevice->byLocalID <= REV_ID_VT3253_A1)) {
@@ -1093,10 +1095,10 @@ static bool s_bHandleRxEncryption(
 			rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);
 			if (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {
 				*pbyNewRsr |= NEWRSR_DECRYPTOK;
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ICV OK!\n");
+				pr_debug("ICV OK!\n");
 			} else {
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ICV FAIL!!!\n");
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "PayloadLen = %d\n", PayloadLen);
+				pr_debug("ICV FAIL!!!\n");
+				pr_debug("PayloadLen = %d\n", PayloadLen);
 			}
 		}
 	}// end of TKIP/AES
@@ -1136,21 +1138,22 @@ static bool s_bHostWepRxEncryption(
 	}
 	byKeyIdx = (*(pbyIV+3) & 0xc0);
 	byKeyIdx >>= 6;
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "\nKeyIdx: %d\n", byKeyIdx);
+	pr_debug("\nKeyIdx: %d\n", byKeyIdx);
 
 	if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
 		byDecMode = KEY_CTL_TKIP;
 	else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
 		byDecMode = KEY_CTL_CCMP;
 
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
+	pr_debug("AES:%d %d %d\n",
+		 pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
 
 	if (byDecMode != pKey->byCipherSuite)
 		return false;
 
 	if (byDecMode == KEY_CTL_WEP) {
 		// handle WEP
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "byDecMode == KEY_CTL_WEP\n");
+		pr_debug("byDecMode == KEY_CTL_WEP\n");
 
 		if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
 		    (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true) ||
@@ -1176,31 +1179,32 @@ static bool s_bHostWepRxEncryption(
 
 		PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
 		*pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ExtIV: %lx\n", *pdwRxTSC47_16);
+		pr_debug("ExtIV: %lx\n", *pdwRxTSC47_16);
 
 		if (byDecMode == KEY_CTL_TKIP)
 			*pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
 		else
 			*pwRxTSC15_0 = cpu_to_le16(*(unsigned short *)pbyIV);
 
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "TSC0_15: %x\n", *pwRxTSC15_0);
+		pr_debug("TSC0_15: %x\n", *pwRxTSC15_0);
 
 		if (byDecMode == KEY_CTL_TKIP) {
 			if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || !bOnFly) {
 				// Software TKIP
 				// 1. 3253 A
 				// 2. NotOnFly
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "soft KEY_CTL_TKIP\n");
+				pr_debug("soft KEY_CTL_TKIP\n");
 				pMACHeader = (PS802_11Header)(pbyFrame);
 				TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
 				rc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);
 				rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);
 				if (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {
 					*pbyNewRsr |= NEWRSR_DECRYPTOK;
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ICV OK!\n");
+					pr_debug("ICV OK!\n");
 				} else {
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ICV FAIL!!!\n");
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "PayloadLen = %d\n", PayloadLen);
+					pr_debug("ICV FAIL!!!\n");
+					pr_debug("PayloadLen = %d\n",
+						 PayloadLen);
 				}
 			}
 		}
@@ -1209,12 +1213,12 @@ static bool s_bHostWepRxEncryption(
 			if (!bOnFly) {
 				// Software CCMP
 				// NotOnFly
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "soft KEY_CTL_CCMP\n");
+				pr_debug("soft KEY_CTL_CCMP\n");
 				if (AESbGenCCMP(pKey->abyKey, pbyFrame, FrameSize)) {
 					*pbyNewRsr |= NEWRSR_DECRYPTOK;
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "CCMP MIC compare OK!\n");
+					pr_debug("CCMP MIC compare OK!\n");
 				} else {
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "CCMP MIC fail!\n");
+					pr_debug("CCMP MIC fail!\n");
 				}
 			}
 		}
@@ -1252,7 +1256,7 @@ static bool s_bAPModeRxData(
 
 			// if any node in PS mode, buffer packet until DTIM.
 			if (skbcpy == NULL) {
-				DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available\n");
+				pr_info("relay multicast no skb available\n");
 			} else {
 				skbcpy->dev = pDevice->dev;
 				skbcpy->len = FrameSize;
@@ -1280,8 +1284,9 @@ static bool s_bAPModeRxData(
 					pMgmt->sNodeDBTable[iDANodeIndex].wEnQueueCnt++;
 					wAID = pMgmt->sNodeDBTable[iDANodeIndex].wAID;
 					pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "relay: index= %d, pMgmt->abyPSTxMap[%d]= %d\n",
-						iDANodeIndex, (wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);
+					pr_debug("relay: index= %d, pMgmt->abyPSTxMap[%d]= %d\n",
+						 iDANodeIndex, (wAID >> 3),
+						 pMgmt->abyPSTxMap[wAID >> 3]);
 					return true;
 				} else {
 					bRelayOnly = true;

commit cf76dc4b85447e17678d61505eb1b92743c4b67b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Aug 10 15:46:59 2014 +0100

    staging: vt6655: bssdb/datarate/dpc/power/rxtx use struct vnt_private
    
    Replacing PSDevice.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 449741989912..d26ca96d2da4 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -79,18 +79,18 @@ s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
 	   PSEthernetHeader psEthHeader);
 
 static void
-s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
+s_vProcessRxMACHeader(struct vnt_private *pDevice, unsigned char *pbyRxBufferAddr,
 		      unsigned int cbPacketSize, bool bIsWEP, bool bExtIV,
 		      unsigned int *pcbHeadSize);
 
 static bool s_bAPModeRxCtl(
-	PSDevice pDevice,
+	struct vnt_private *pDevice,
 	unsigned char *pbyFrame,
 	int      iSANodeIndex
 );
 
 static bool s_bAPModeRxData(
-	PSDevice pDevice,
+	struct vnt_private *pDevice,
 	struct sk_buff *skb,
 	unsigned int FrameSize,
 	unsigned int cbHeaderOffset,
@@ -99,7 +99,7 @@ static bool s_bAPModeRxData(
 );
 
 static bool s_bHandleRxEncryption(
-	PSDevice     pDevice,
+	struct vnt_private *pDevice,
 	unsigned char *pbyFrame,
 	unsigned int FrameSize,
 	unsigned char *pbyRsr,
@@ -112,7 +112,7 @@ static bool s_bHandleRxEncryption(
 
 static bool s_bHostWepRxEncryption(
 
-	PSDevice     pDevice,
+	struct vnt_private *pDevice,
 	unsigned char *pbyFrame,
 	unsigned int FrameSize,
 	unsigned char *pbyRsr,
@@ -145,7 +145,8 @@ static bool s_bHostWepRxEncryption(
  *
  -*/
 static void
-s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
+s_vProcessRxMACHeader(struct vnt_private *pDevice,
+		      unsigned char *pbyRxBufferAddr,
 		      unsigned int cbPacketSize, bool bIsWEP, bool bExtIV,
 		      unsigned int *pcbHeadSize)
 {
@@ -270,7 +271,7 @@ s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
 
 bool
 device_receive_frame(
-	PSDevice pDevice,
+	struct vnt_private *pDevice,
 	PSRxDesc pCurrRD
 )
 {
@@ -871,7 +872,7 @@ device_receive_frame(
 }
 
 static bool s_bAPModeRxCtl(
-	PSDevice pDevice,
+	struct vnt_private *pDevice,
 	unsigned char *pbyFrame,
 	int      iSANodeIndex
 )
@@ -969,7 +970,7 @@ static bool s_bAPModeRxCtl(
 }
 
 static bool s_bHandleRxEncryption(
-	PSDevice     pDevice,
+	struct vnt_private *pDevice,
 	unsigned char *pbyFrame,
 	unsigned int FrameSize,
 	unsigned char *pbyRsr,
@@ -1106,7 +1107,7 @@ static bool s_bHandleRxEncryption(
 }
 
 static bool s_bHostWepRxEncryption(
-	PSDevice     pDevice,
+	struct vnt_private *pDevice,
 	unsigned char *pbyFrame,
 	unsigned int FrameSize,
 	unsigned char *pbyRsr,
@@ -1226,7 +1227,7 @@ static bool s_bHostWepRxEncryption(
 }
 
 static bool s_bAPModeRxData(
-	PSDevice pDevice,
+	struct vnt_private *pDevice,
 	struct sk_buff *skb,
 	unsigned int FrameSize,
 	unsigned int cbHeaderOffset,

commit 0fc2a76eef05ee1aa82b3d9bf34eea2b50f5e1ba
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Aug 10 12:21:58 2014 +0100

    staging: vt6655: Replace and remove typedef QWORD/ DQWORD
    
    Replace the variables with u64/__le64.
    
    The endian variant is needed in some places endian correction is
    needed.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 0bcf6c7472fe..449741989912 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -283,7 +283,7 @@ device_receive_frame(
 	unsigned char *pbyRsr;
 	unsigned char *pbyNewRsr;
 	unsigned char *pbyRSSI;
-	PQWORD          pqwTSFTime;
+	__le64 *pqwTSFTime;
 	unsigned short *pwFrameSize;
 	unsigned char *pbyFrame;
 	bool bDeFragRx = false;
@@ -334,7 +334,7 @@ device_receive_frame(
 	pbyRSSI = (unsigned char *)(skb->data + FrameSize - 2);
 	pbyNewRsr = (unsigned char *)(skb->data + FrameSize - 3);
 	pbySQ = (unsigned char *)(skb->data + FrameSize - 4);
-	pqwTSFTime = (PQWORD)(skb->data + FrameSize - 12);
+	pqwTSFTime = (__le64 *)(skb->data + FrameSize - 12);
 	pbyFrame = (unsigned char *)(skb->data + 4);
 
 	// get packet size
@@ -515,8 +515,7 @@ device_receive_frame(
 			pRxPacket->cbMPDULen = FrameSize;
 			pRxPacket->uRSSI = *pbyRSSI;
 			pRxPacket->bySQ = *pbySQ;
-			HIDWORD(pRxPacket->qwLocalTSF) = cpu_to_le32(HIDWORD(*pqwTSFTime));
-			LODWORD(pRxPacket->qwLocalTSF) = cpu_to_le32(LODWORD(*pqwTSFTime));
+			pRxPacket->qwLocalTSF = le64_to_cpu(*pqwTSFTime);
 			if (bIsWEP) {
 				// strip IV
 				pbyData1 = WLAN_HDR_A3_DATA_PTR(skb->data+4);
@@ -796,7 +795,7 @@ device_receive_frame(
 			RSC = dwRxTSC47_16;
 			RSC <<= 16;
 			RSC += wRxTSC15_0;
-			memcpy(&(pKey->KeyRSC), &RSC,  sizeof(QWORD));
+			pKey->KeyRSC = RSC;
 
 			if ((pDevice->sMgmtObj.eCurrMode == WMAC_MODE_ESS_STA) &&
 			    (pDevice->sMgmtObj.eCurrState == WMAC_STATE_ASSOC)) {

commit 9a802f2edc5bfc3d19ccb094182e60fdd36ee6ec
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Jul 28 21:43:28 2014 +0100

    staging: vt6655: deadcode remove undefined macro THREAD code.
    
    Removing _RxManagementQueue, InitRxManagementQueue, MlmeThread, mlme_kill,
    EnQueue and DeQueue.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 31bb2b760498..0bcf6c7472fe 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -529,14 +529,9 @@ device_receive_frame(
 			}
 			pRxPacket->byRxRate = s_byGetRateIdx(*pbyRxRate);
 			pRxPacket->byRxChannel = (*pbyRxSts) >> 2;
-//PLICE_DEBUG->
 
-#ifdef	THREAD
-			EnQueue(pDevice, pRxPacket);
-#else
 			vMgrRxManagePacket((void *)pDevice, pDevice->pMgmt, pRxPacket);
-#endif
-//PLICE_DEBUG<-
+
 			// hostap Deamon handle 802.11 management
 			if (pDevice->bEnableHostapd) {
 				skb->dev = pDevice->apdev;

commit 795d644c0a91089182a3fede73bd88404819e61b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Jul 28 21:43:27 2014 +0100

    staging: vt6655: remove undefined TASK_LET code
    
    Removing all code within and function MngWorkItem.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index ac588cb8fb22..31bb2b760498 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -268,23 +268,6 @@ s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
 	*pcbHeaderSize = cbHeaderSize;
 }
 
-//PLICE_DEBUG ->
-
-void	MngWorkItem(void *Context)
-{
-	PSRxMgmtPacket			pRxMgmtPacket;
-	PSDevice	pDevice =  (PSDevice) Context;
-
-	spin_lock_irq(&pDevice->lock);
-	while (pDevice->rxManeQueue.packet_num != 0) {
-		pRxMgmtPacket =  DeQueue(pDevice);
-		vMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);
-	}
-	spin_unlock_irq(&pDevice->lock);
-}
-
-//PLICE_DEBUG<-
-
 bool
 device_receive_frame(
 	PSDevice pDevice,
@@ -551,15 +534,8 @@ device_receive_frame(
 #ifdef	THREAD
 			EnQueue(pDevice, pRxPacket);
 #else
-
-#ifdef	TASK_LET
-			EnQueue(pDevice, pRxPacket);
-			tasklet_schedule(&pDevice->RxMngWorkItem);
-#else
 			vMgrRxManagePacket((void *)pDevice, pDevice->pMgmt, pRxPacket);
 #endif
-
-#endif
 //PLICE_DEBUG<-
 			// hostap Deamon handle 802.11 management
 			if (pDevice->bEnableHostapd) {

commit bfd7a2819051fc0ab401609aedbe65df46ed1259
Author: Guillaume Clement <gclement@baobob.org>
Date:   Fri Jul 25 01:06:17 2014 +0200

    staging: vt6655: Remove spaces before quoted newlines
    
    This fixes several spaces added just before a newline in debug
    strings, reported by checkpatch.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 5b2ace2755d2..ac588cb8fb22 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -341,7 +341,7 @@ device_receive_frame(
 	// Min (ACK): 10HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
 	if ((FrameSize > 2364) || (FrameSize <= 32)) {
 		// Frame Size error drop this packet.
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---------- WRONG Length 1 \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---------- WRONG Length 1\n");
 		return false;
 	}
 
@@ -359,7 +359,7 @@ device_receive_frame(
 
 	if ((FrameSize > 2346)|(FrameSize < 14)) { // Max: 2312Payload + 30HD +4CRC
 		// Min: 14 bytes ACK
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---------- WRONG Length 2 \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---------- WRONG Length 2\n");
 		return false;
 	}
 //PLICE_DEBUG->
@@ -671,7 +671,7 @@ device_receive_frame(
 		wEtherType = (skb->data[cbIVOffset + 4 + 24 + 6] << 8) |
 			skb->data[cbIVOffset + 4 + 24 + 6 + 1];
 
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wEtherType = %04x \n", wEtherType);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wEtherType = %04x\n", wEtherType);
 		if (wEtherType == ETH_P_PAE) {
 			skb->dev = pDevice->apdev;
 
@@ -1179,7 +1179,8 @@ static bool s_bHostWepRxEncryption(
 
 	if (byDecMode == KEY_CTL_WEP) {
 		// handle WEP
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "byDecMode == KEY_CTL_WEP \n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "byDecMode == KEY_CTL_WEP\n");
+
 		if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
 		    (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true) ||
 		    !bOnFly) {
@@ -1218,7 +1219,7 @@ static bool s_bHostWepRxEncryption(
 				// Software TKIP
 				// 1. 3253 A
 				// 2. NotOnFly
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "soft KEY_CTL_TKIP \n");
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "soft KEY_CTL_TKIP\n");
 				pMACHeader = (PS802_11Header)(pbyFrame);
 				TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
 				rc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);
@@ -1280,7 +1281,7 @@ static bool s_bAPModeRxData(
 
 			// if any node in PS mode, buffer packet until DTIM.
 			if (skbcpy == NULL) {
-				DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");
+				DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available\n");
 			} else {
 				skbcpy->dev = pDevice->dev;
 				skbcpy->len = FrameSize;

commit 6b7112719fd48c29f35333ef152a5a450f01dc83
Author: Guillaume Clement <gclement@baobob.org>
Date:   Fri Jul 25 01:06:16 2014 +0200

    staging: vt6655: Add missing blank lines after declarations
    
    This patch fixes the missing blank lines after declarations in vt6655
    reported by checkpatch.
    
    Signed-off-by: Guillaume Clement <gclement@baobob.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 696564b44200..5b2ace2755d2 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -604,6 +604,7 @@ device_receive_frame(
 			{
 				unsigned char Protocol_Version;    //802.1x Authentication
 				unsigned char Packet_Type;           //802.1x Authentication
+
 				if (bIsWEP)
 					cbIVOffset = 8;
 				else
@@ -761,6 +762,7 @@ device_receive_frame(
 					union iwreq_data wrqu;
 					struct iw_michaelmicfailure ev;
 					int keyidx = pbyFrame[cbHeaderSize+3] >> 6; //top two-bits
+
 					memset(&ev, 0, sizeof(ev));
 					ev.flags = keyidx & IW_MICFAILURE_KEY_ID;
 					if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
@@ -1114,6 +1116,7 @@ static bool s_bHandleRxEncryption(
 			// Software TKIP
 			// 1. 3253 A
 			PS802_11Header  pMACHeader = (PS802_11Header)(pbyFrame);
+
 			TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
 			rc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);
 			rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);

commit 04d521970bd430b613a000a6b66c568d419b1ff3
Author: James A Shackleford <shack@linux.com>
Date:   Sun Jun 1 20:26:55 2014 -0400

    staging: vt6655: fix sparse warning for static declarations
    
    This patch fixes the following sparse warnings:
    
    dpc.c:65:21: warning: symbol 'acbyRxRate' was not declared. Should it be static?
    dpc.c:272:9: warning: symbol 'MngWorkItem' was not declared. Should it be static?
    dpc.c:288:1: warning: symbol 'device_receive_frame' was not declared. Should it be static?
    
    Signed-off-by: James A Shackleford <shack@linux.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 7ddaf2603ba6..696564b44200 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -54,6 +54,7 @@
 #include "rf.h"
 #include "iowpa.h"
 #include "aes_ccmp.h"
+#include "dpc.h"
 
 /*---------------------  Static Definitions -------------------------*/
 
@@ -62,7 +63,7 @@
 /*---------------------  Static Variables  --------------------------*/
 static int msglevel = MSG_LEVEL_INFO;
 
-const unsigned char acbyRxRate[MAX_RATE] =
+static const unsigned char acbyRxRate[MAX_RATE] =
 {2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108};
 
 /*---------------------  Static Functions  --------------------------*/

commit bc5cf6563576bb36baa7e93417b9a2e29999a5c6
Author: Guido Martínez <guido@vanguardiasur.com.ar>
Date:   Sat Apr 19 16:45:00 2014 -0300

    staging: vt6655: fix checkpatch bracing issues
    
    This patchs fixes tons of warnings such as:
    
      WARNING: braces {} are not necessary for single statement blocks
      #354: FILE: drivers/staging/vt6655/wmgr.c:354:
      +       for (ii = 0; ii < WLAN_BSSID_LEN; ii++) {
      +               pMgmt->abyDesireBSSID[ii] = 0xFF;
      +       }
    
    Please note: this patch only fixes bracing issues (and there is still a
    lot to do); so if you run checkpatch it _will_ throw a lot of errors.
    Use --test-only=braces
    
    Signed-off-by: Guido Martínez <guido@vanguardiasur.com.ar>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 37fa4af15927..7ddaf2603ba6 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -181,11 +181,11 @@ s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
 			cbHeaderSize -= 8;
 			pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
 			if (bIsWEP) {
-				if (bExtIV) {
+				if (bExtIV)
 					*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    // 8 is IV&ExtIV
-				} else {
+				else
 					*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    // 4 is IV
-				}
+
 			} else {
 				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
 			}
@@ -194,11 +194,11 @@ s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
 		cbHeaderSize -= 2;
 		pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
 		if (bIsWEP) {
-			if (bExtIV) {
+			if (bExtIV)
 				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    // 8 is IV&ExtIV
-			} else {
+			else
 				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    // 4 is IV
-			}
+
 		} else {
 			*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
 		}
@@ -222,6 +222,7 @@ static unsigned char s_byGetRateIdx(unsigned char byRate)
 		if (acbyRxRate[byRateIdx % MAX_RATE] == byRate)
 			return byRateIdx;
 	}
+
 	return 0;
 }
 
@@ -372,9 +373,9 @@ device_receive_frame(
 	pMACHeader = (PS802_11Header)((unsigned char *)(skb->data) + 8);
 //PLICE_DEBUG<-
 	if (pDevice->bMeasureInProgress) {
-		if ((*pbyRsr & RSR_CRCOK) != 0) {
+		if ((*pbyRsr & RSR_CRCOK) != 0)
 			pDevice->byBasicMap |= 0x01;
-		}
+
 		dwDuration = (FrameSize << 4);
 		dwDuration /= acbyRxRate[*pbyRxRate%MAX_RATE];
 		if (*pbyRxRate <= RATE_11M) {
@@ -391,9 +392,9 @@ device_receive_frame(
 		RFvRSSITodBm(pDevice, *pbyRSSI, &ldBm);
 		ldBmThreshold = -57;
 		for (ii = 7; ii > 0;) {
-			if (ldBm > ldBmThreshold) {
+			if (ldBm > ldBmThreshold)
 				break;
-			}
+
 			ldBmThreshold -= 5;
 			ii--;
 		}
@@ -428,9 +429,8 @@ device_receive_frame(
 	}
 
 	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-		if (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex)) {
+		if (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex))
 			return false;
-		}
 	}
 
 	if (IS_FC_WEP(pbyFrame)) {
@@ -480,11 +480,10 @@ device_receive_frame(
 				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||
 				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||
 				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {
-					if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
+					if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP))
 						pDevice->s802_11Counter.TKIPICVErrors++;
-					} else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP)) {
+					else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP))
 						pDevice->s802_11Counter.CCMPDecryptErrors++;
-					}
 				}
 				return false;
 			}
@@ -639,9 +638,9 @@ device_receive_frame(
 		BBvAntennaDiversity(pDevice, s_byGetRateIdx(*pbyRxRate), 0);
 	}
 
-	if (pDevice->byLocalID != REV_ID_VT3253_B1) {
+	if (pDevice->byLocalID != REV_ID_VT3253_B1)
 		pDevice->uCurrRSSI = *pbyRSSI;
-	}
+
 	pDevice->byCurrSQ = *pbySQ;
 
 	if ((*pbyRSSI != 0) &&
@@ -651,11 +650,10 @@ device_receive_frame(
 		pMgmt->pCurrBSS->byRSSIStatCnt++;
 		pMgmt->pCurrBSS->byRSSIStatCnt %= RSSI_STAT_COUNT;
 		pMgmt->pCurrBSS->ldBmAverage[pMgmt->pCurrBSS->byRSSIStatCnt] = ldBm;
-		for (ii = 0; ii < RSSI_STAT_COUNT; ii++) {
-			if (pMgmt->pCurrBSS->ldBmAverage[ii] != 0) {
+		for (ii = 0; ii < RSSI_STAT_COUNT; ii++)
+			if (pMgmt->pCurrBSS->ldBmAverage[ii] != 0)
 				pMgmt->pCurrBSS->ldBmMAX = max(pMgmt->pCurrBSS->ldBmAverage[ii], ldBm);
-			}
-		}
+
 	}
 
 	// -----------------------------------------------
@@ -698,9 +696,8 @@ device_receive_frame(
 	}
 
 	if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
-		if (bIsWEP) {
+		if (bIsWEP)
 			FrameSize -= 8;  //MIC
-		}
 	}
 
 	//--------------------------------------------------------------------------------
@@ -1093,9 +1090,9 @@ static bool s_bHandleRxEncryption(
 			rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
 			rc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);
 
-			if (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen)) {
+			if (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen))
 				*pbyNewRsr |= NEWRSR_DECRYPTOK;
-			}
+
 		}
 	} else if ((byDecMode == KEY_CTL_TKIP) ||
 		   (byDecMode == KEY_CTL_CCMP)) {
@@ -1104,11 +1101,11 @@ static bool s_bHandleRxEncryption(
 		PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
 		*pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ExtIV: %lx\n", *pdwRxTSC47_16);
-		if (byDecMode == KEY_CTL_TKIP) {
+		if (byDecMode == KEY_CTL_TKIP)
 			*pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV + 2), *pbyIV));
-		} else {
+		else
 			*pwRxTSC15_0 = cpu_to_le16(*(unsigned short *)pbyIV);
-		}
+
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "TSC0_15: %x\n", *pwRxTSC15_0);
 
 		if ((byDecMode == KEY_CTL_TKIP) &&
@@ -1193,9 +1190,9 @@ static bool s_bHostWepRxEncryption(
 			rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
 			rc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);
 
-			if (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen)) {
+			if (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen))
 				*pbyNewRsr |= NEWRSR_DECRYPTOK;
-			}
+
 		}
 	} else if ((byDecMode == KEY_CTL_TKIP) ||
 		   (byDecMode == KEY_CTL_CCMP)) {
@@ -1205,11 +1202,11 @@ static bool s_bHostWepRxEncryption(
 		*pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ExtIV: %lx\n", *pdwRxTSC47_16);
 
-		if (byDecMode == KEY_CTL_TKIP) {
+		if (byDecMode == KEY_CTL_TKIP)
 			*pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
-		} else {
+		else
 			*pwRxTSC15_0 = cpu_to_le16(*(unsigned short *)pbyIV);
-		}
+
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "TSC0_15: %x\n", *pwRxTSC15_0);
 
 		if (byDecMode == KEY_CTL_TKIP) {
@@ -1322,9 +1319,8 @@ static bool s_bAPModeRxData(
 		if (bRelayAndForward)
 			iDANodeIndex = 0;
 
-		if ((pDevice->uAssocCount > 1) && (iDANodeIndex >= 0)) {
+		if ((pDevice->uAssocCount > 1) && (iDANodeIndex >= 0))
 			ROUTEbRelay(pDevice, (unsigned char *)(skb->data + cbHeaderOffset), FrameSize, (unsigned int)iDANodeIndex);
-		}
 
 		if (bRelayOnly)
 			return false;

commit 4e8a7e5fc29697f881f5c358f84df52914908703
Author: Guido Martínez <guido@vanguardiasur.com.ar>
Date:   Sat Apr 19 16:44:59 2014 -0300

    staging: vt6655: remove dead code
    
    Remove dead code in many places on this driver.
    
    Signed-off-by: Guido Martínez <guido@vanguardiasur.com.ar>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 771bf35ae044..37fa4af15927 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -60,7 +60,6 @@
 /*---------------------  Static Classes  ----------------------------*/
 
 /*---------------------  Static Variables  --------------------------*/
-//static int          msglevel                =MSG_LEVEL_DEBUG;
 static int msglevel = MSG_LEVEL_INFO;
 
 const unsigned char acbyRxRate[MAX_RATE] =
@@ -327,15 +326,11 @@ device_receive_frame(
 	PS802_11Header pMACHeader;
 	bool bRxeapol_key = false;
 
-//    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---------- device_receive_frame---\n");
-
 	skb = pRDInfo->skb;
 
 //PLICE_DEBUG->
-#if 1
 	pci_unmap_single(pDevice->pcid, pRDInfo->skb_dma,
 			 pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
-#endif
 //PLICE_DEBUG<-
 	pwFrameSize = (unsigned short *)(skb->data + 2);
 	FrameSize = cpu_to_le16(pCurrRD->m_rd1RD1.wReqCount) - cpu_to_le16(pCurrRD->m_rd0RD0.wResCount);
@@ -366,7 +361,6 @@ device_receive_frame(
 		return false;
 	}
 //PLICE_DEBUG->
-#if 1
 	// update receive statistic counter
 	STAvUpdateRDStatCounter(&pDevice->scStatistic,
 				*pbyRsr,
@@ -375,8 +369,6 @@ device_receive_frame(
 				pbyFrame,
 				FrameSize);
 
-#endif
-
 	pMACHeader = (PS802_11Header)((unsigned char *)(skb->data) + 8);
 //PLICE_DEBUG<-
 	if (pDevice->bMeasureInProgress) {
@@ -492,8 +484,6 @@ device_receive_frame(
 						pDevice->s802_11Counter.TKIPICVErrors++;
 					} else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP)) {
 						pDevice->s802_11Counter.CCMPDecryptErrors++;
-					} else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_WEP)) {
-//                      pDevice->s802_11Counter.WEPICVErrorCount.QuadPart++;
 					}
 				}
 				return false;
@@ -557,13 +547,9 @@ device_receive_frame(
 			pRxPacket->byRxRate = s_byGetRateIdx(*pbyRxRate);
 			pRxPacket->byRxChannel = (*pbyRxSts) >> 2;
 //PLICE_DEBUG->
-//EnQueue(pDevice,pRxPacket);
 
 #ifdef	THREAD
 			EnQueue(pDevice, pRxPacket);
-
-			//up(&pDevice->mlme_semaphore);
-			//Enque (pDevice->FirstRecvMngList,pDevice->LastRecvMngList,pMgmt);
 #else
 
 #ifdef	TASK_LET
@@ -571,12 +557,10 @@ device_receive_frame(
 			tasklet_schedule(&pDevice->RxMngWorkItem);
 #else
 			vMgrRxManagePacket((void *)pDevice, pDevice->pMgmt, pRxPacket);
-			//tasklet_schedule(&pDevice->RxMngWorkItem);
 #endif
 
 #endif
 //PLICE_DEBUG<-
-			//vMgrRxManagePacket((void *)pDevice, pDevice->pMgmt, pRxPacket);
 			// hostap Deamon handle 802.11 management
 			if (pDevice->bEnableHostapd) {
 				skb->dev = pDevice->apdev;
@@ -590,9 +574,8 @@ device_receive_frame(
 				netif_rx(skb);
 				return true;
 			}
-		} else {
-			// Control Frame
 		}
+
 		return false;
 	} else {
 		if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
@@ -643,14 +626,9 @@ device_receive_frame(
 // Data frame Handle
 
 	if (pDevice->bEnablePSMode) {
-		if (IS_FC_MOREDATA((skb->data+4))) {
-			if (*pbyRsr & RSR_ADDROK) {
-				//PSbSendPSPOLL((PSDevice)pDevice);
-			}
-		} else {
-			if (pDevice->pMgmt->bInTIMWake == true) {
+		if (!IS_FC_MOREDATA((skb->data+4))) {
+			if (pDevice->pMgmt->bInTIMWake == true)
 				pDevice->pMgmt->bInTIMWake = false;
-			}
 		}
 	}
 
@@ -765,16 +743,12 @@ device_receive_frame(
 
 			pdwMIC_L = (__le32 *)(skb->data + 4 + FrameSize);
 			pdwMIC_R = (__le32 *)(skb->data + 4 + FrameSize + 4);
-			//DBG_PRN_GRP12(("RxL: %lx, RxR: %lx\n", *pdwMIC_L, *pdwMIC_R));
-			//DBG_PRN_GRP12(("LocalL: %lx, LocalR: %lx\n", dwLocalMIC_L, dwLocalMIC_R));
-			//DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwMICKey0= %lx,dwMICKey1= %lx \n", dwMICKey0, dwMICKey1);
 
 			if ((le32_to_cpu(*pdwMIC_L) != dwLocalMIC_L) ||
 			    (le32_to_cpu(*pdwMIC_R) != dwLocalMIC_R) ||
 			    pDevice->bRxMICFail) {
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MIC comparison is fail!\n");
 				pDevice->bRxMICFail = false;
-				//pDevice->s802_11Counter.TKIPLocalMICFailures.QuadPart++;
 				pDevice->s802_11Counter.TKIPLocalMICFailures++;
 				if (bDeFragRx) {
 					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
@@ -813,10 +787,8 @@ device_receive_frame(
 					if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
 					    (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC) &&
 					    (*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) {
-						//s802_11_Status.Flags = NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR;
 						wpahdr->type = VIAWGET_PTK_MIC_MSG;
 					} else {
-						//s802_11_Status.Flags = NDIS_802_11_AUTH_REQUEST_GROUP_ERROR;
 						wpahdr->type = VIAWGET_GTK_MIC_MSG;
 					}
 					wpahdr->resp_ie_len = 0;
@@ -863,10 +835,8 @@ device_receive_frame(
 				    !((dwRxTSC47_16 == 0) && (dwLocalTSC47_16 == 0xFFFFFFFF))) {
 					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "TSC is illegal~~!\n ");
 					if (pKey->byCipherSuite == KEY_CTL_TKIP)
-						//pDevice->s802_11Counter.TKIPReplays.QuadPart++;
 						pDevice->s802_11Counter.TKIPReplays++;
 					else
-						//pDevice->s802_11Counter.CCMPReplays.QuadPart++;
 						pDevice->s802_11Counter.CCMPReplays++;
 
 					if (bDeFragRx) {
@@ -881,10 +851,6 @@ device_receive_frame(
 		}
 	} // ----- End of Reply Counter Check --------------------------
 
-	if ((pKey != NULL) && (bIsWEP)) {
-//      pDevice->s802_11Counter.DecryptSuccessCount.QuadPart++;
-	}
-
 	s_vProcessRxMACHeader(pDevice, (unsigned char *)(skb->data+4), FrameSize, bIsWEP, bExtIV, &cbHeaderOffset);
 	FrameSize -= cbHeaderOffset;
 	cbHeaderOffset += 4;        // 4 is Rcv buffer header
@@ -917,22 +883,6 @@ device_receive_frame(
 	skb->protocol = eth_type_trans(skb, skb->dev);
 
 	//drop frame not met IEEE 802.3
-/*
-  if (pDevice->flags & DEVICE_FLAGS_VAL_PKT_LEN) {
-  if ((skb->protocol==htons(ETH_P_802_3)) &&
-  (skb->len!=htons(skb->mac.ethernet->h_proto))) {
-  pStats->rx_length_errors++;
-  pStats->rx_dropped++;
-  if (bDeFragRx) {
-  if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-  DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
-  pDevice->dev->name);
-  }
-  }
-  return false;
-  }
-  }
-*/
 
 	skb->ip_summed = CHECKSUM_NONE;
 	pStats->rx_bytes += skb->len;
@@ -1121,19 +1071,11 @@ static bool s_bHandleRxEncryption(
 
 	if (pKey == NULL) {
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pKey == NULL\n");
-		if (byDecMode == KEY_CTL_WEP) {
-//            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
-		} else if (pDevice->bLinkPass) {
-//            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
-		}
+
 		return false;
 	}
 	if (byDecMode != pKey->byCipherSuite) {
-		if (byDecMode == KEY_CTL_WEP) {
-//            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
-		} else if (pDevice->bLinkPass) {
-//            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
-		}
+
 		*pKeyOut = NULL;
 		return false;
 	}
@@ -1231,14 +1173,8 @@ static bool s_bHostWepRxEncryption(
 
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
 
-	if (byDecMode != pKey->byCipherSuite) {
-		if (byDecMode == KEY_CTL_WEP) {
-//            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
-		} else if (pDevice->bLinkPass) {
-//            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
-		}
+	if (byDecMode != pKey->byCipherSuite)
 		return false;
-	}
 
 	if (byDecMode == KEY_CTL_WEP) {
 		// handle WEP

commit 35a9562b02441dee7e0a822f5273f84afb2f150b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Mar 6 22:44:24 2014 +0000

    staging: vt6655: 64 bit fixes TKIP mic correct sizeof long.
    
    Correct to endian base type __le32.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 766385646c1e..771bf35ae044 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -729,27 +729,27 @@ device_receive_frame(
 	// Soft MIC
 	if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
 		if (bIsWEP) {
-			unsigned long *pdwMIC_L;
-			unsigned long *pdwMIC_R;
-			unsigned long dwMIC_Priority;
-			unsigned long dwMICKey0 = 0, dwMICKey1 = 0;
+			__le32 *pdwMIC_L;
+			__le32 *pdwMIC_R;
+			__le32 dwMIC_Priority;
+			__le32 dwMICKey0 = 0, dwMICKey1 = 0;
 			u32 dwLocalMIC_L = 0;
 			u32 dwLocalMIC_R = 0;
 			viawget_wpa_header *wpahdr;
 
 			if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-				dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[24]));
-				dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[28]));
+				dwMICKey0 = cpu_to_le32(*(u32 *)(&pKey->abyKey[24]));
+				dwMICKey1 = cpu_to_le32(*(u32 *)(&pKey->abyKey[28]));
 			} else {
 				if (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) {
-					dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[16]));
-					dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[20]));
+					dwMICKey0 = cpu_to_le32(*(u32 *)(&pKey->abyKey[16]));
+					dwMICKey1 = cpu_to_le32(*(u32 *)(&pKey->abyKey[20]));
 				} else if ((pKey->dwKeyIndex & BIT28) == 0) {
-					dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[16]));
-					dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[20]));
+					dwMICKey0 = cpu_to_le32(*(u32 *)(&pKey->abyKey[16]));
+					dwMICKey1 = cpu_to_le32(*(u32 *)(&pKey->abyKey[20]));
 				} else {
-					dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[24]));
-					dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[28]));
+					dwMICKey0 = cpu_to_le32(*(u32 *)(&pKey->abyKey[24]));
+					dwMICKey1 = cpu_to_le32(*(u32 *)(&pKey->abyKey[28]));
 				}
 			}
 
@@ -763,14 +763,14 @@ device_receive_frame(
 			MIC_vGetMIC(&dwLocalMIC_L, &dwLocalMIC_R);
 			MIC_vUnInit();
 
-			pdwMIC_L = (unsigned long *)(skb->data + 4 + FrameSize);
-			pdwMIC_R = (unsigned long *)(skb->data + 4 + FrameSize + 4);
+			pdwMIC_L = (__le32 *)(skb->data + 4 + FrameSize);
+			pdwMIC_R = (__le32 *)(skb->data + 4 + FrameSize + 4);
 			//DBG_PRN_GRP12(("RxL: %lx, RxR: %lx\n", *pdwMIC_L, *pdwMIC_R));
 			//DBG_PRN_GRP12(("LocalL: %lx, LocalR: %lx\n", dwLocalMIC_L, dwLocalMIC_R));
 			//DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwMICKey0= %lx,dwMICKey1= %lx \n", dwMICKey0, dwMICKey1);
 
-			if ((cpu_to_le32(*pdwMIC_L) != dwLocalMIC_L) ||
-			    (cpu_to_le32(*pdwMIC_R) != dwLocalMIC_R) ||
+			if ((le32_to_cpu(*pdwMIC_L) != dwLocalMIC_L) ||
+			    (le32_to_cpu(*pdwMIC_R) != dwLocalMIC_R) ||
 			    pDevice->bRxMICFail) {
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MIC comparison is fail!\n");
 				pDevice->bRxMICFail = false;

commit d0daef301d8451eaf75ece9636d2cfa6180c34de
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Mar 6 22:44:23 2014 +0000

    staging: vt6655: 64 bit fixes :TKIP mode micheal.c sizeof long.
    
    Fix MIC_vGetMIC and MIC_vInit to u32
    
    Fix calling functions to u32
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 0a29c9015419..766385646c1e 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -733,8 +733,8 @@ device_receive_frame(
 			unsigned long *pdwMIC_R;
 			unsigned long dwMIC_Priority;
 			unsigned long dwMICKey0 = 0, dwMICKey1 = 0;
-			unsigned long dwLocalMIC_L = 0;
-			unsigned long dwLocalMIC_R = 0;
+			u32 dwLocalMIC_L = 0;
+			u32 dwLocalMIC_R = 0;
 			viawget_wpa_header *wpahdr;
 
 			if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {

commit 88cc85075d1e53731e90fec8670cd9ccafcbe9aa
Author: Teodora Baluta <teobaluta@gmail.com>
Date:   Sun Nov 10 17:12:45 2013 +0200

    staging: vt6655: remove unneeded semicolon
    
    This patch deletes any unneeded semicolons in driver vt6655 as detected
    by coccinelle.
    
    Signed-off-by: Teodora Baluta <teobaluta@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index c60f3e6dc6f8..0a29c9015419 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -169,7 +169,7 @@ s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
 		}
 	} else {
 		cbHeaderSize += WLAN_HDR_ADDR3_LEN;
-	};
+	}
 
 	pbyRxBuffer = (unsigned char *)(pbyRxBufferAddr + cbHeaderSize);
 	if (ether_addr_equal(pbyRxBuffer, pDevice->abySNAP_Bridgetunnel)) {
@@ -263,7 +263,7 @@ s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
 				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
 			}
 		}
-	};
+	}
 	*pcbHeaderSize = cbHeaderSize;
 }
 
@@ -592,7 +592,7 @@ device_receive_frame(
 			}
 		} else {
 			// Control Frame
-		};
+		}
 		return false;
 	} else {
 		if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {

commit 1208f14a37fde2669b86bf1b1cd1122ad2ba3579
Author: Teodora Baluta <teobaluta@gmail.com>
Date:   Sun Nov 10 17:12:42 2013 +0200

    staging: vt6655: delete explicit comparison to bool
    
    This patch fixes the following type of coccinelle detected warnings for
    driver vt6655:
    
    WARNING: Comparison to bool
    
    Signed-off-by: Teodora Baluta <teobaluta@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 0ff51cb4a207..c60f3e6dc6f8 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -379,7 +379,7 @@ device_receive_frame(
 
 	pMACHeader = (PS802_11Header)((unsigned char *)(skb->data) + 8);
 //PLICE_DEBUG<-
-	if (pDevice->bMeasureInProgress == true) {
+	if (pDevice->bMeasureInProgress) {
 		if ((*pbyRsr & RSR_CRCOK) != 0) {
 			pDevice->byBasicMap |= 0x01;
 		}
@@ -436,7 +436,7 @@ device_receive_frame(
 	}
 
 	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-		if (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex) == true) {
+		if (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex)) {
 			return false;
 		}
 	}
@@ -608,8 +608,7 @@ device_receive_frame(
 			}
 		} else {
 			// discard DATA packet while not associate || BSSID error
-			if ((pDevice->bLinkPass == false) ||
-			    !(*pbyRsr & RSR_BSSIDOK)) {
+			if (!pDevice->bLinkPass || !(*pbyRsr & RSR_BSSIDOK)) {
 				if (bDeFragRx) {
 					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
 						DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
@@ -658,7 +657,7 @@ device_receive_frame(
 	// Now it only supports 802.11g Infrastructure Mode, and support rate must up to 54 Mbps
 	if (pDevice->bDiversityEnable && (FrameSize > 50) &&
 	    (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE) &&
-	    (pDevice->bLinkPass == true)) {
+	    pDevice->bLinkPass) {
 		BBvAntennaDiversity(pDevice, s_byGetRateIdx(*pbyRxRate), 0);
 	}
 
@@ -683,7 +682,7 @@ device_receive_frame(
 
 	// -----------------------------------------------
 
-	if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) && (pDevice->bEnable8021x == true)) {
+	if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) && pDevice->bEnable8021x) {
 		unsigned char abyMacHdr[24];
 
 		// Only 802.1x packet incoming allowed
@@ -698,7 +697,7 @@ device_receive_frame(
 		if (wEtherType == ETH_P_PAE) {
 			skb->dev = pDevice->apdev;
 
-			if (bIsWEP == true) {
+			if (bIsWEP) {
 				// strip IV header(8)
 				memcpy(&abyMacHdr[0], (skb->data + 4), 24);
 				memcpy((skb->data + 4 + cbIVOffset), &abyMacHdr[0], 24);
@@ -770,8 +769,9 @@ device_receive_frame(
 			//DBG_PRN_GRP12(("LocalL: %lx, LocalR: %lx\n", dwLocalMIC_L, dwLocalMIC_R));
 			//DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwMICKey0= %lx,dwMICKey1= %lx \n", dwMICKey0, dwMICKey1);
 
-			if ((cpu_to_le32(*pdwMIC_L) != dwLocalMIC_L) || (cpu_to_le32(*pdwMIC_R) != dwLocalMIC_R) ||
-			    (pDevice->bRxMICFail == true)) {
+			if ((cpu_to_le32(*pdwMIC_L) != dwLocalMIC_L) ||
+			    (cpu_to_le32(*pdwMIC_R) != dwLocalMIC_R) ||
+			    pDevice->bRxMICFail) {
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MIC comparison is fail!\n");
 				pDevice->bRxMICFail = false;
 				//pDevice->s802_11Counter.TKIPLocalMICFailures.QuadPart++;
@@ -894,13 +894,13 @@ device_receive_frame(
 		return false;
 
 	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-		if (s_bAPModeRxData(pDevice,
+		if (!s_bAPModeRxData(pDevice,
 				    skb,
 				    FrameSize,
 				    cbHeaderOffset,
 				    iSANodeIndex,
 				    iDANodeIndex
-) == false) {
+)) {
 			if (bDeFragRx) {
 				if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
 					DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
@@ -1123,7 +1123,7 @@ static bool s_bHandleRxEncryption(
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pKey == NULL\n");
 		if (byDecMode == KEY_CTL_WEP) {
 //            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
-		} else if (pDevice->bLinkPass == true) {
+		} else if (pDevice->bLinkPass) {
 //            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
 		}
 		return false;
@@ -1131,7 +1131,7 @@ static bool s_bHandleRxEncryption(
 	if (byDecMode != pKey->byCipherSuite) {
 		if (byDecMode == KEY_CTL_WEP) {
 //            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
-		} else if (pDevice->bLinkPass == true) {
+		} else if (pDevice->bLinkPass) {
 //            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
 		}
 		*pKeyOut = NULL;
@@ -1234,7 +1234,7 @@ static bool s_bHostWepRxEncryption(
 	if (byDecMode != pKey->byCipherSuite) {
 		if (byDecMode == KEY_CTL_WEP) {
 //            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
-		} else if (pDevice->bLinkPass == true) {
+		} else if (pDevice->bLinkPass) {
 //            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
 		}
 		return false;
@@ -1245,7 +1245,7 @@ static bool s_bHostWepRxEncryption(
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "byDecMode == KEY_CTL_WEP \n");
 		if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
 		    (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true) ||
-		    (bOnFly == false)) {
+		    !bOnFly) {
 			// Software WEP
 			// 1. 3253A
 			// 2. WEP 256
@@ -1277,7 +1277,7 @@ static bool s_bHostWepRxEncryption(
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "TSC0_15: %x\n", *pwRxTSC15_0);
 
 		if (byDecMode == KEY_CTL_TKIP) {
-			if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || (bOnFly == false)) {
+			if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || !bOnFly) {
 				// Software TKIP
 				// 1. 3253 A
 				// 2. NotOnFly
@@ -1297,7 +1297,7 @@ static bool s_bHostWepRxEncryption(
 		}
 
 		if (byDecMode == KEY_CTL_CCMP) {
-			if (bOnFly == false) {
+			if (!bOnFly) {
 				// Software CCMP
 				// NotOnFly
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "soft KEY_CTL_CCMP\n");

commit 8329419a29d15abebc3aefb57f4c6bfdbded7d89
Author: Joe Perches <joe@perches.com>
Date:   Sun Sep 1 12:15:47 2013 -0700

    Staging: Convert uses of compare_ether_addr to ether_addr_equal
    
    Preliminary to removing compare_ether_addr altogether:
    
    Use the new bool function ether_addr_equal to add
    some clarity and reduce the likelihood for misuse
    of compare_ether_addr for sorting.
    
    Additionally:
    
    Used is_zero_ether_addr, removed now unused variable
    Converted uses of &foo[0] to foo
    
    Done via cocci script: (and a little typing)
    
    $ cat compare_ether_addr.cocci
    @@
    expression a,b;
    @@
    -       !compare_ether_addr(a, b)
    +       ether_addr_equal(a, b)
    
    @@
    expression a,b;
    @@
    -       compare_ether_addr(a, b)
    +       !ether_addr_equal(a, b)
    
    @@
    expression a,b;
    @@
    -       !ether_addr_equal(a, b) == 0
    +       ether_addr_equal(a, b)
    
    @@
    expression a,b;
    @@
    -       !ether_addr_equal(a, b) != 0
    +       !ether_addr_equal(a, b)
    
    @@
    expression a,b;
    @@
    -       ether_addr_equal(a, b) == 0
    +       !ether_addr_equal(a, b)
    
    @@
    expression a,b;
    @@
    -       ether_addr_equal(a, b) != 0
    +       ether_addr_equal(a, b)
    
    @@
    expression a,b;
    @@
    -       !!ether_addr_equal(a, b)
    +       ether_addr_equal(a, b)
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index a9533f3f2529..0ff51cb4a207 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -172,9 +172,9 @@ s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
 	};
 
 	pbyRxBuffer = (unsigned char *)(pbyRxBufferAddr + cbHeaderSize);
-	if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_Bridgetunnel[0])) {
+	if (ether_addr_equal(pbyRxBuffer, pDevice->abySNAP_Bridgetunnel)) {
 		cbHeaderSize += 6;
-	} else if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_RFC1042[0])) {
+	} else if (ether_addr_equal(pbyRxBuffer, pDevice->abySNAP_RFC1042)) {
 		cbHeaderSize += 6;
 		pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
 		if ((*pwType != TYPE_PKT_IPX) && (*pwType != cpu_to_le16(0xF380))) {
@@ -420,7 +420,8 @@ device_receive_frame(
 	s_vGetDASA(skb->data+4, &cbHeaderSize, &pDevice->sRxEthHeader);
 
 	// filter packet send from myself
-	if (!compare_ether_addr((unsigned char *)&(pDevice->sRxEthHeader.abySrcAddr[0]), pDevice->abyCurrentNetAddr))
+	if (ether_addr_equal(pDevice->sRxEthHeader.abySrcAddr,
+			     pDevice->abyCurrentNetAddr))
 		return false;
 
 	if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) || (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)) {

commit 96d69e201bbdb05c363e899138f9f42bc8ad8f88
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 20:55:41 2013 -0700

    staging: vt6655: Remove unnecessary blank lines
    
    Remove a bunch of useless vertical whitespace.
    
    Convert 3 or more consecutive newlines to 2.
    Remove blank lines after open brace and before close brace.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index e078aa314d05..a9533f3f2529 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -55,8 +55,6 @@
 #include "iowpa.h"
 #include "aes_ccmp.h"
 
-
-
 /*---------------------  Static Definitions -------------------------*/
 
 /*---------------------  Static Classes  ----------------------------*/
@@ -68,7 +66,6 @@ static int msglevel = MSG_LEVEL_INFO;
 const unsigned char acbyRxRate[MAX_RATE] =
 {2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108};
 
-
 /*---------------------  Static Functions  --------------------------*/
 
 /*---------------------  Static Definitions -------------------------*/
@@ -77,7 +74,6 @@ const unsigned char acbyRxRate[MAX_RATE] =
 
 static unsigned char s_byGetRateIdx(unsigned char byRate);
 
-
 static void
 s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
 	   PSEthernetHeader psEthHeader);
@@ -93,8 +89,6 @@ static bool s_bAPModeRxCtl(
 	int      iSANodeIndex
 );
 
-
-
 static bool s_bAPModeRxData(
 	PSDevice pDevice,
 	struct sk_buff *skb,
@@ -104,7 +98,6 @@ static bool s_bAPModeRxData(
 	int      iDANodeIndex
 );
 
-
 static bool s_bHandleRxEncryption(
 	PSDevice     pDevice,
 	unsigned char *pbyFrame,
@@ -162,7 +155,6 @@ s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
 	PS802_11Header  pMACHeader;
 	int             ii;
 
-
 	pMACHeader = (PS802_11Header) (pbyRxBufferAddr + cbHeaderSize);
 
 	s_vGetDASA((unsigned char *)pMACHeader, &cbHeaderSize, &pDevice->sRxEthHeader);
@@ -223,9 +215,6 @@ s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
 	*pcbHeadSize = cbHeaderSize;
 }
 
-
-
-
 static unsigned char s_byGetRateIdx(unsigned char byRate)
 {
 	unsigned char byRateIdx;
@@ -237,7 +226,6 @@ static unsigned char s_byGetRateIdx(unsigned char byRate)
 	return 0;
 }
 
-
 static void
 s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
 	   PSEthernetHeader psEthHeader)
@@ -279,9 +267,6 @@ s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
 	*pcbHeaderSize = cbHeaderSize;
 }
 
-
-
-
 //PLICE_DEBUG ->
 
 void	MngWorkItem(void *Context)
@@ -297,18 +282,14 @@ void	MngWorkItem(void *Context)
 	spin_unlock_irq(&pDevice->lock);
 }
 
-
 //PLICE_DEBUG<-
 
-
-
 bool
 device_receive_frame(
 	PSDevice pDevice,
 	PSRxDesc pCurrRD
 )
 {
-
 	PDEVICE_RD_INFO  pRDInfo = pCurrRD->pRDInfo;
 	struct net_device_stats *pStats = &pDevice->stats;
 	struct sk_buff *skb;
@@ -350,7 +331,6 @@ device_receive_frame(
 
 	skb = pRDInfo->skb;
 
-
 //PLICE_DEBUG->
 #if 1
 	pci_unmap_single(pDevice->pcid, pRDInfo->skb_dma,
@@ -436,7 +416,6 @@ device_receive_frame(
 		}
 	}
 
-
 	// Use for TKIP MIC
 	s_vGetDASA(skb->data+4, &cbHeaderSize, &pDevice->sRxEthHeader);
 
@@ -461,7 +440,6 @@ device_receive_frame(
 		}
 	}
 
-
 	if (IS_FC_WEP(pbyFrame)) {
 		bool bRxDecryOK = false;
 
@@ -509,7 +487,6 @@ device_receive_frame(
 				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||
 				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||
 				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {
-
 					if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
 						pDevice->s802_11Counter.TKIPICVErrors++;
 					} else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP)) {
@@ -530,7 +507,6 @@ device_receive_frame(
 			FrameSize -= 4;         // 4 is ICV
 	}
 
-
 	//
 	// RX OK
 	//
@@ -553,7 +529,6 @@ device_receive_frame(
 		}
 	}
 
-
 // Management & Control frame Handle
 	if ((IS_TYPE_DATA((skb->data+4))) == false) {
 		// Handle Control & Manage Frame
@@ -665,10 +640,8 @@ device_receive_frame(
 		}
 	}
 
-
 // Data frame Handle
 
-
 	if (pDevice->bEnablePSMode) {
 		if (IS_FC_MOREDATA((skb->data+4))) {
 			if (*pbyRsr & RSR_ADDROK) {
@@ -688,7 +661,6 @@ device_receive_frame(
 		BBvAntennaDiversity(pDevice, s_byGetRateIdx(*pbyRxRate), 0);
 	}
 
-
 	if (pDevice->byLocalID != REV_ID_VT3253_B1) {
 		pDevice->uCurrRSSI = *pbyRSSI;
 	}
@@ -747,7 +719,6 @@ device_receive_frame(
 			return false;
 	}
 
-
 	if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
 		if (bIsWEP) {
 			FrameSize -= 8;  //MIC
@@ -766,7 +737,6 @@ device_receive_frame(
 			unsigned long dwLocalMIC_R = 0;
 			viawget_wpa_header *wpahdr;
 
-
 			if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
 				dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[24]));
 				dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[28]));
@@ -799,7 +769,6 @@ device_receive_frame(
 			//DBG_PRN_GRP12(("LocalL: %lx, LocalR: %lx\n", dwLocalMIC_L, dwLocalMIC_R));
 			//DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwMICKey0= %lx,dwMICKey1= %lx \n", dwMICKey0, dwMICKey1);
 
-
 			if ((cpu_to_le32(*pdwMIC_L) != dwLocalMIC_L) || (cpu_to_le32(*pdwMIC_R) != dwLocalMIC_R) ||
 			    (pDevice->bRxMICFail == true)) {
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MIC comparison is fail!\n");
@@ -838,7 +807,6 @@ device_receive_frame(
 				}
 #endif
 
-
 				if ((pDevice->bWPADEVUp) && (pDevice->skb != NULL)) {
 					wpahdr = (viawget_wpa_header *)pDevice->skb->data;
 					if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
@@ -912,13 +880,10 @@ device_receive_frame(
 		}
 	} // ----- End of Reply Counter Check --------------------------
 
-
-
 	if ((pKey != NULL) && (bIsWEP)) {
 //      pDevice->s802_11Counter.DecryptSuccessCount.QuadPart++;
 	}
 
-
 	s_vProcessRxMACHeader(pDevice, (unsigned char *)(skb->data+4), FrameSize, bIsWEP, bExtIV, &cbHeaderOffset);
 	FrameSize -= cbHeaderOffset;
 	cbHeaderOffset += 4;        // 4 is Rcv buffer header
@@ -935,7 +900,6 @@ device_receive_frame(
 				    iSANodeIndex,
 				    iDANodeIndex
 ) == false) {
-
 			if (bDeFragRx) {
 				if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
 					DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
@@ -951,7 +915,6 @@ device_receive_frame(
 	skb_put(skb, FrameSize);
 	skb->protocol = eth_type_trans(skb, skb->dev);
 
-
 	//drop frame not met IEEE 802.3
 /*
   if (pDevice->flags & DEVICE_FLAGS_VAL_PKT_LEN) {
@@ -986,7 +949,6 @@ device_receive_frame(
 	return true;
 }
 
-
 static bool s_bAPModeRxCtl(
 	PSDevice pDevice,
 	unsigned char *pbyFrame,
@@ -997,12 +959,9 @@ static bool s_bAPModeRxCtl(
 	CMD_STATUS          Status;
 	PSMgmtObject        pMgmt = pDevice->pMgmt;
 
-
 	if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
-
 		p802_11Header = (PS802_11Header)(pbyFrame);
 		if (!IS_TYPE_MGMT(pbyFrame)) {
-
 			// Data & PS-Poll packet
 			// check frame class
 			if (iSANodeIndex > 0) {
@@ -1086,7 +1045,6 @@ static bool s_bAPModeRxCtl(
 		}
 	}
 	return false;
-
 }
 
 static bool s_bHandleRxEncryption(
@@ -1108,7 +1066,6 @@ static bool s_bHandleRxEncryption(
 	unsigned char byDecMode = KEY_CTL_WEP;
 	PSMgmtObject    pMgmt = pDevice->pMgmt;
 
-
 	*pwRxTSC15_0 = 0;
 	*pdwRxTSC47_16 = 0;
 
@@ -1234,7 +1191,6 @@ static bool s_bHandleRxEncryption(
 	return true;
 }
 
-
 static bool s_bHostWepRxEncryption(
 	PSDevice     pDevice,
 	unsigned char *pbyFrame,
@@ -1254,8 +1210,6 @@ static bool s_bHostWepRxEncryption(
 	unsigned char byDecMode = KEY_CTL_WEP;
 	PS802_11Header  pMACHeader;
 
-
-
 	*pwRxTSC15_0 = 0;
 	*pdwRxTSC47_16 = 0;
 
@@ -1269,7 +1223,6 @@ static bool s_bHostWepRxEncryption(
 	byKeyIdx >>= 6;
 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "\nKeyIdx: %d\n", byKeyIdx);
 
-
 	if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
 		byDecMode = KEY_CTL_TKIP;
 	else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
@@ -1323,7 +1276,6 @@ static bool s_bHostWepRxEncryption(
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "TSC0_15: %x\n", *pwRxTSC15_0);
 
 		if (byDecMode == KEY_CTL_TKIP) {
-
 			if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || (bOnFly == false)) {
 				// Software TKIP
 				// 1. 3253 A
@@ -1364,8 +1316,6 @@ static bool s_bHostWepRxEncryption(
 	return true;
 }
 
-
-
 static bool s_bAPModeRxData(
 	PSDevice pDevice,
 	struct sk_buff *skb,
@@ -1381,7 +1331,6 @@ static bool s_bAPModeRxData(
 	unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
 	unsigned short wAID;
 
-
 	struct sk_buff *skbcpy = NULL;
 
 	if (FrameSize > CB_MAX_BUF_SIZE)
@@ -1389,7 +1338,6 @@ static bool s_bAPModeRxData(
 	// check DA
 	if (is_multicast_ether_addr((unsigned char *)(skb->data+cbHeaderOffset))) {
 		if (pMgmt->sNodeDBTable[0].bPSEnable) {
-
 			skbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);
 
 			// if any node in PS mode, buffer packet until DTIM.
@@ -1450,4 +1398,3 @@ static bool s_bAPModeRxData(
 
 	return true;
 }
-

commit a7307538805f8a30c25b6f5b9566ab21d8ab7515
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 20:55:39 2013 -0700

    staging: vt6655: Remove commented out if()s
    
    Commented out code is just noise.  Remove them.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 62a80cb2f4d9..e078aa314d05 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -815,7 +815,6 @@ device_receive_frame(
 				//2008-0409-07, <Add> by Einsn Liu
 #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 				//send event to wpa_supplicant
-				//if (pDevice->bWPADevEnable == true)
 				{
 					union iwreq_data wrqu;
 					struct iw_michaelmicfailure ev;

commit 5e0cc8a231be82b0ec44cdf2a406b1a97dd3c971
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 20:55:37 2013 -0700

    staging: vt6655: Convert to kernel brace style
    
    Move braces around to be more kernel like.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 7719edf0c081..62a80cb2f4d9 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -175,21 +175,18 @@ s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
 			// strip IV , add 4 byte
 			cbHeaderSize += (WLAN_HDR_ADDR3_LEN + 4);
 		}
-	}
-	else {
+	} else {
 		cbHeaderSize += WLAN_HDR_ADDR3_LEN;
 	};
 
 	pbyRxBuffer = (unsigned char *)(pbyRxBufferAddr + cbHeaderSize);
 	if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_Bridgetunnel[0])) {
 		cbHeaderSize += 6;
-	}
-	else if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_RFC1042[0])) {
+	} else if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_RFC1042[0])) {
 		cbHeaderSize += 6;
 		pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
 		if ((*pwType != TYPE_PKT_IPX) && (*pwType != cpu_to_le16(0xF380))) {
-		}
-		else {
+		} else {
 			cbHeaderSize -= 8;
 			pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
 			if (bIsWEP) {
@@ -198,13 +195,11 @@ s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
 				} else {
 					*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    // 4 is IV
 				}
-			}
-			else {
+			} else {
 				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
 			}
 		}
-	}
-	else {
+	} else {
 		cbHeaderSize -= 2;
 		pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
 		if (bIsWEP) {
@@ -213,8 +208,7 @@ s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
 			} else {
 				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    // 4 is IV
 			}
-		}
-		else {
+		} else {
 			*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
 		}
 	}
@@ -260,16 +254,14 @@ s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
 				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
 				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr3[ii];
 			}
-		}
-		else {
+		} else {
 			// IBSS mode
 			for (ii = 0; ii < ETH_ALEN; ii++) {
 				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
 				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
 			}
 		}
-	}
-	else {
+	} else {
 		// Is AP mode..
 		if (pMACHeader->wFrameCtl & FC_FROMDS) {
 			for (ii = 0; ii < ETH_ALEN; ii++) {
@@ -277,8 +269,7 @@ s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
 				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr4[ii];
 				cbHeaderSize += 6;
 			}
-		}
-		else {
+		} else {
 			for (ii = 0; ii < ETH_ALEN; ii++) {
 				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr3[ii];
 				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
@@ -299,8 +290,7 @@ void	MngWorkItem(void *Context)
 	PSDevice	pDevice =  (PSDevice) Context;
 
 	spin_lock_irq(&pDevice->lock);
-	while (pDevice->rxManeQueue.packet_num != 0)
-	{
+	while (pDevice->rxManeQueue.packet_num != 0) {
 		pRxMgmtPacket =  DeQueue(pDevice);
 		vMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);
 	}
@@ -558,8 +548,7 @@ device_receive_frame(
 			skb = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].skb;
 			FrameSize = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].cbFrameLength;
 
-		}
-		else {
+		} else {
 			return false;
 		}
 	}
@@ -625,13 +614,11 @@ device_receive_frame(
 				netif_rx(skb);
 				return true;
 			}
-		}
-		else {
+		} else {
 			// Control Frame
 		};
 		return false;
-	}
-	else {
+	} else {
 		if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
 			//In AP mode, hw only check addr1(BSSID or RA) if equal to local MAC.
 			if (!(*pbyRsr & RSR_BSSIDOK)) {
@@ -643,8 +630,7 @@ device_receive_frame(
 				}
 				return false;
 			}
-		}
-		else {
+		} else {
 			// discard DATA packet while not associate || BSSID error
 			if ((pDevice->bLinkPass == false) ||
 			    !(*pbyRsr & RSR_BSSIDOK)) {
@@ -688,8 +674,7 @@ device_receive_frame(
 			if (*pbyRsr & RSR_ADDROK) {
 				//PSbSendPSPOLL((PSDevice)pDevice);
 			}
-		}
-		else {
+		} else {
 			if (pDevice->pMgmt->bInTIMWake == true) {
 				pDevice->pMgmt->bInTIMWake = false;
 			}
@@ -785,8 +770,7 @@ device_receive_frame(
 			if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
 				dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[24]));
 				dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[28]));
-			}
-			else {
+			} else {
 				if (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) {
 					dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[16]));
 					dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[20]));
@@ -1055,8 +1039,7 @@ static bool s_bAPModeRxCtl(
 						pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
 						bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
 						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 1\n");
-					}
-					else {
+					} else {
 						// check Data PS state
 						// if PW bit off, send out all PS bufferring packets.
 						if (!IS_FC_POWERMGT(pbyFrame)) {
@@ -1066,14 +1049,12 @@ static bool s_bAPModeRxCtl(
 							DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 2\n");
 						}
 					}
-				}
-				else {
+				} else {
 					if (IS_FC_POWERMGT(pbyFrame)) {
 						pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = true;
 						// Once if STA in PS state, enable multicast bufferring
 						pMgmt->sNodeDBTable[0].bPSEnable = true;
-					}
-					else {
+					} else {
 						// clear all pending PS frame.
 						if (pMgmt->sNodeDBTable[iSANodeIndex].wEnQueueCnt > 0) {
 							pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
@@ -1084,8 +1065,7 @@ static bool s_bAPModeRxCtl(
 						}
 					}
 				}
-			}
-			else {
+			} else {
 				vMgrDeAuthenBeginSta(pDevice,
 						     pMgmt,
 						     (unsigned char *)(p802_11Header->abyAddr2),
@@ -1416,8 +1396,7 @@ static bool s_bAPModeRxData(
 			// if any node in PS mode, buffer packet until DTIM.
 			if (skbcpy == NULL) {
 				DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");
-			}
-			else {
+			} else {
 				skbcpy->dev = pDevice->dev;
 				skbcpy->len = FrameSize;
 				memcpy(skbcpy->data, skb->data+cbHeaderOffset, FrameSize);
@@ -1427,12 +1406,10 @@ static bool s_bAPModeRxData(
 				// set tx map
 				pMgmt->abyPSTxMap[0] |= byMask[0];
 			}
-		}
-		else {
+		} else {
 			bRelayAndForward = true;
 		}
-	}
-	else {
+	} else {
 		// check if relay
 		if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data+cbHeaderOffset), &iDANodeIndex)) {
 			if (pMgmt->sNodeDBTable[iDANodeIndex].eNodeState >= NODE_ASSOC) {
@@ -1449,8 +1426,7 @@ static bool s_bAPModeRxData(
 					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "relay: index= %d, pMgmt->abyPSTxMap[%d]= %d\n",
 						iDANodeIndex, (wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);
 					return true;
-				}
-				else {
+				} else {
 					bRelayOnly = true;
 				}
 			}

commit f2046f93db0918f99875853772142143590ba0c6
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 20:55:36 2013 -0700

    staging: vt6655: Remove commented out printks
    
    These are just noise in the code so remove them.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index f96f9c17e8fe..7719edf0c081 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -297,7 +297,7 @@ void	MngWorkItem(void *Context)
 {
 	PSRxMgmtPacket			pRxMgmtPacket;
 	PSDevice	pDevice =  (PSDevice) Context;
-	//printk("Enter MngWorkItem,Queue packet num is %d\n",pDevice->rxManeQueue.packet_num);
+
 	spin_lock_irq(&pDevice->lock);
 	while (pDevice->rxManeQueue.packet_num != 0)
 	{
@@ -320,9 +320,6 @@ device_receive_frame(
 {
 
 	PDEVICE_RD_INFO  pRDInfo = pCurrRD->pRDInfo;
-#ifdef	PLICE_DEBUG
-	//printk("device_receive_frame:pCurrRD is %x,pRDInfo is %x\n",pCurrRD,pCurrRD->pRDInfo);
-#endif
 	struct net_device_stats *pStats = &pDevice->stats;
 	struct sk_buff *skb;
 	PSMgmtObject    pMgmt = pDevice->pMgmt;
@@ -600,7 +597,6 @@ device_receive_frame(
 #ifdef	THREAD
 			EnQueue(pDevice, pRxPacket);
 
-			//printk("enque time is %x\n",jiffies);
 			//up(&pDevice->mlme_semaphore);
 			//Enque (pDevice->FirstRecvMngList,pDevice->LastRecvMngList,pMgmt);
 #else
@@ -609,7 +605,6 @@ device_receive_frame(
 			EnQueue(pDevice, pRxPacket);
 			tasklet_schedule(&pDevice->RxMngWorkItem);
 #else
-//printk("RxMan\n");
 			vMgrRxManagePacket((void *)pDevice, pDevice->pMgmt, pRxPacket);
 			//tasklet_schedule(&pDevice->RxMngWorkItem);
 #endif
@@ -705,7 +700,6 @@ device_receive_frame(
 	if (pDevice->bDiversityEnable && (FrameSize > 50) &&
 	    (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE) &&
 	    (pDevice->bLinkPass == true)) {
-		//printk("device_receive_frame: RxRate is %d\n",*pbyRxRate);
 		BBvAntennaDiversity(pDevice, s_byGetRateIdx(*pbyRxRate), 0);
 	}
 
@@ -967,13 +961,6 @@ device_receive_frame(
 			}
 			return false;
 		}
-
-//        if (pDevice->bRxMICFail == false) {
-//           for (ii =0; ii < 100; ii++)
-//                printk(" %02x", *(skb->data + ii));
-//           printk("\n");
-//	    }
-
 	}
 
 	skb->data += cbHeaderOffset;

commit 22c5291e70ba66880c6a6acffbd8200a623c4556
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 18 10:44:48 2013 -0700

    staging:vt6655:dpc: Whitespace cleanups
    
    Neatening only.
    git diff -w shows no differences.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 373e9e4fc87d..f96f9c17e8fe 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -63,7 +63,7 @@
 
 /*---------------------  Static Variables  --------------------------*/
 //static int          msglevel                =MSG_LEVEL_DEBUG;
-static int          msglevel                =MSG_LEVEL_INFO;
+static int msglevel = MSG_LEVEL_INFO;
 
 const unsigned char acbyRxRate[MAX_RATE] =
 {2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108};
@@ -80,57 +80,57 @@ static unsigned char s_byGetRateIdx(unsigned char byRate);
 
 static void
 s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
-		PSEthernetHeader psEthHeader);
+	   PSEthernetHeader psEthHeader);
 
 static void
 s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
-		unsigned int cbPacketSize, bool bIsWEP, bool bExtIV,
-		unsigned int *pcbHeadSize);
+		      unsigned int cbPacketSize, bool bIsWEP, bool bExtIV,
+		      unsigned int *pcbHeadSize);
 
 static bool s_bAPModeRxCtl(
-    PSDevice pDevice,
-    unsigned char *pbyFrame,
-    int      iSANodeIndex
-    );
+	PSDevice pDevice,
+	unsigned char *pbyFrame,
+	int      iSANodeIndex
+);
 
 
 
-static bool s_bAPModeRxData (
-    PSDevice pDevice,
-    struct sk_buff* skb,
-    unsigned int FrameSize,
-    unsigned int cbHeaderOffset,
-    int      iSANodeIndex,
-    int      iDANodeIndex
-    );
+static bool s_bAPModeRxData(
+	PSDevice pDevice,
+	struct sk_buff *skb,
+	unsigned int FrameSize,
+	unsigned int cbHeaderOffset,
+	int      iSANodeIndex,
+	int      iDANodeIndex
+);
 
 
 static bool s_bHandleRxEncryption(
-    PSDevice     pDevice,
-    unsigned char *pbyFrame,
-    unsigned int FrameSize,
-    unsigned char *pbyRsr,
-    unsigned char *pbyNewRsr,
-    PSKeyItem   *pKeyOut,
-    bool *pbExtIV,
-    unsigned short *pwRxTSC15_0,
-    unsigned long *pdwRxTSC47_16
-    );
+	PSDevice     pDevice,
+	unsigned char *pbyFrame,
+	unsigned int FrameSize,
+	unsigned char *pbyRsr,
+	unsigned char *pbyNewRsr,
+	PSKeyItem   *pKeyOut,
+	bool *pbExtIV,
+	unsigned short *pwRxTSC15_0,
+	unsigned long *pdwRxTSC47_16
+);
 
 static bool s_bHostWepRxEncryption(
 
-    PSDevice     pDevice,
-    unsigned char *pbyFrame,
-    unsigned int FrameSize,
-    unsigned char *pbyRsr,
-    bool bOnFly,
-    PSKeyItem    pKey,
-    unsigned char *pbyNewRsr,
-    bool *pbExtIV,
-    unsigned short *pwRxTSC15_0,
-    unsigned long *pdwRxTSC47_16
+	PSDevice     pDevice,
+	unsigned char *pbyFrame,
+	unsigned int FrameSize,
+	unsigned char *pbyRsr,
+	bool bOnFly,
+	PSKeyItem    pKey,
+	unsigned char *pbyNewRsr,
+	bool *pbExtIV,
+	unsigned short *pwRxTSC15_0,
+	unsigned long *pdwRxTSC47_16
 
-    );
+);
 
 /*---------------------  Export Variables  --------------------------*/
 
@@ -150,142 +150,142 @@ static bool s_bHostWepRxEncryption(
  *
  * Return Value: None
  *
--*/
+ -*/
 static void
 s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
-		unsigned int cbPacketSize, bool bIsWEP, bool bExtIV,
-		unsigned int *pcbHeadSize)
+		      unsigned int cbPacketSize, bool bIsWEP, bool bExtIV,
+		      unsigned int *pcbHeadSize)
 {
-    unsigned char *pbyRxBuffer;
-    unsigned int cbHeaderSize = 0;
-    unsigned short *pwType;
-    PS802_11Header  pMACHeader;
-    int             ii;
-
-
-    pMACHeader = (PS802_11Header) (pbyRxBufferAddr + cbHeaderSize);
-
-    s_vGetDASA((unsigned char *)pMACHeader, &cbHeaderSize, &pDevice->sRxEthHeader);
-
-    if (bIsWEP) {
-        if (bExtIV) {
-            // strip IV&ExtIV , add 8 byte
-            cbHeaderSize += (WLAN_HDR_ADDR3_LEN + 8);
-        } else {
-            // strip IV , add 4 byte
-            cbHeaderSize += (WLAN_HDR_ADDR3_LEN + 4);
-        }
-    }
-    else {
-        cbHeaderSize += WLAN_HDR_ADDR3_LEN;
-    };
-
-    pbyRxBuffer = (unsigned char *) (pbyRxBufferAddr + cbHeaderSize);
-    if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_Bridgetunnel[0])) {
-        cbHeaderSize += 6;
-    }
-    else if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_RFC1042[0])) {
-        cbHeaderSize += 6;
-        pwType = (unsigned short *) (pbyRxBufferAddr + cbHeaderSize);
-        if ((*pwType!= TYPE_PKT_IPX) && (*pwType != cpu_to_le16(0xF380))) {
-        }
-        else {
-            cbHeaderSize -= 8;
-            pwType = (unsigned short *) (pbyRxBufferAddr + cbHeaderSize);
-            if (bIsWEP) {
-                if (bExtIV) {
-                    *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    // 8 is IV&ExtIV
-                } else {
-                    *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    // 4 is IV
-                }
-            }
-            else {
-                *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
-            }
-        }
-    }
-    else {
-        cbHeaderSize -= 2;
-        pwType = (unsigned short *) (pbyRxBufferAddr + cbHeaderSize);
-        if (bIsWEP) {
-            if (bExtIV) {
-                *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    // 8 is IV&ExtIV
-            } else {
-                *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    // 4 is IV
-            }
-        }
-        else {
-            *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
-        }
-    }
-
-    cbHeaderSize -= (ETH_ALEN * 2);
-    pbyRxBuffer = (unsigned char *) (pbyRxBufferAddr + cbHeaderSize);
-    for(ii=0;ii<ETH_ALEN;ii++)
-        *pbyRxBuffer++ = pDevice->sRxEthHeader.abyDstAddr[ii];
-    for(ii=0;ii<ETH_ALEN;ii++)
-        *pbyRxBuffer++ = pDevice->sRxEthHeader.abySrcAddr[ii];
-
-    *pcbHeadSize = cbHeaderSize;
+	unsigned char *pbyRxBuffer;
+	unsigned int cbHeaderSize = 0;
+	unsigned short *pwType;
+	PS802_11Header  pMACHeader;
+	int             ii;
+
+
+	pMACHeader = (PS802_11Header) (pbyRxBufferAddr + cbHeaderSize);
+
+	s_vGetDASA((unsigned char *)pMACHeader, &cbHeaderSize, &pDevice->sRxEthHeader);
+
+	if (bIsWEP) {
+		if (bExtIV) {
+			// strip IV&ExtIV , add 8 byte
+			cbHeaderSize += (WLAN_HDR_ADDR3_LEN + 8);
+		} else {
+			// strip IV , add 4 byte
+			cbHeaderSize += (WLAN_HDR_ADDR3_LEN + 4);
+		}
+	}
+	else {
+		cbHeaderSize += WLAN_HDR_ADDR3_LEN;
+	};
+
+	pbyRxBuffer = (unsigned char *)(pbyRxBufferAddr + cbHeaderSize);
+	if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_Bridgetunnel[0])) {
+		cbHeaderSize += 6;
+	}
+	else if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_RFC1042[0])) {
+		cbHeaderSize += 6;
+		pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
+		if ((*pwType != TYPE_PKT_IPX) && (*pwType != cpu_to_le16(0xF380))) {
+		}
+		else {
+			cbHeaderSize -= 8;
+			pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
+			if (bIsWEP) {
+				if (bExtIV) {
+					*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    // 8 is IV&ExtIV
+				} else {
+					*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    // 4 is IV
+				}
+			}
+			else {
+				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
+			}
+		}
+	}
+	else {
+		cbHeaderSize -= 2;
+		pwType = (unsigned short *)(pbyRxBufferAddr + cbHeaderSize);
+		if (bIsWEP) {
+			if (bExtIV) {
+				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    // 8 is IV&ExtIV
+			} else {
+				*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    // 4 is IV
+			}
+		}
+		else {
+			*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
+		}
+	}
+
+	cbHeaderSize -= (ETH_ALEN * 2);
+	pbyRxBuffer = (unsigned char *)(pbyRxBufferAddr + cbHeaderSize);
+	for (ii = 0; ii < ETH_ALEN; ii++)
+		*pbyRxBuffer++ = pDevice->sRxEthHeader.abyDstAddr[ii];
+	for (ii = 0; ii < ETH_ALEN; ii++)
+		*pbyRxBuffer++ = pDevice->sRxEthHeader.abySrcAddr[ii];
+
+	*pcbHeadSize = cbHeaderSize;
 }
 
 
 
 
-static unsigned char s_byGetRateIdx (unsigned char byRate)
+static unsigned char s_byGetRateIdx(unsigned char byRate)
 {
-    unsigned char byRateIdx;
+	unsigned char byRateIdx;
 
-    for (byRateIdx = 0; byRateIdx <MAX_RATE ; byRateIdx++) {
-        if (acbyRxRate[byRateIdx%MAX_RATE] == byRate)
-            return byRateIdx;
-    }
-    return 0;
+	for (byRateIdx = 0; byRateIdx < MAX_RATE; byRateIdx++) {
+		if (acbyRxRate[byRateIdx % MAX_RATE] == byRate)
+			return byRateIdx;
+	}
+	return 0;
 }
 
 
 static void
 s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
-	PSEthernetHeader psEthHeader)
+	   PSEthernetHeader psEthHeader)
 {
-    unsigned int cbHeaderSize = 0;
-    PS802_11Header  pMACHeader;
-    int             ii;
-
-    pMACHeader = (PS802_11Header) (pbyRxBufferAddr + cbHeaderSize);
-
-    if ((pMACHeader->wFrameCtl & FC_TODS) == 0) {
-        if (pMACHeader->wFrameCtl & FC_FROMDS) {
-            for(ii=0;ii<ETH_ALEN;ii++) {
-                psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
-                psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr3[ii];
-            }
-        }
-        else {
-            // IBSS mode
-            for(ii=0;ii<ETH_ALEN;ii++) {
-                psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
-                psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
-            }
-        }
-    }
-    else {
-        // Is AP mode..
-        if (pMACHeader->wFrameCtl & FC_FROMDS) {
-            for(ii=0;ii<ETH_ALEN;ii++) {
-                psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr3[ii];
-                psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr4[ii];
-                cbHeaderSize += 6;
-            }
-        }
-        else {
-            for(ii=0;ii<ETH_ALEN;ii++) {
-                psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr3[ii];
-                psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
-            }
-        }
-    };
-    *pcbHeaderSize = cbHeaderSize;
+	unsigned int cbHeaderSize = 0;
+	PS802_11Header  pMACHeader;
+	int             ii;
+
+	pMACHeader = (PS802_11Header) (pbyRxBufferAddr + cbHeaderSize);
+
+	if ((pMACHeader->wFrameCtl & FC_TODS) == 0) {
+		if (pMACHeader->wFrameCtl & FC_FROMDS) {
+			for (ii = 0; ii < ETH_ALEN; ii++) {
+				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
+				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr3[ii];
+			}
+		}
+		else {
+			// IBSS mode
+			for (ii = 0; ii < ETH_ALEN; ii++) {
+				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
+				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
+			}
+		}
+	}
+	else {
+		// Is AP mode..
+		if (pMACHeader->wFrameCtl & FC_FROMDS) {
+			for (ii = 0; ii < ETH_ALEN; ii++) {
+				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr3[ii];
+				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr4[ii];
+				cbHeaderSize += 6;
+			}
+		}
+		else {
+			for (ii = 0; ii < ETH_ALEN; ii++) {
+				psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr3[ii];
+				psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
+			}
+		}
+	};
+	*pcbHeaderSize = cbHeaderSize;
 }
 
 
@@ -299,10 +299,10 @@ void	MngWorkItem(void *Context)
 	PSDevice	pDevice =  (PSDevice) Context;
 	//printk("Enter MngWorkItem,Queue packet num is %d\n",pDevice->rxManeQueue.packet_num);
 	spin_lock_irq(&pDevice->lock);
-	 while(pDevice->rxManeQueue.packet_num != 0)
-	 {
-		 pRxMgmtPacket =  DeQueue(pDevice);
-        		vMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);
+	while (pDevice->rxManeQueue.packet_num != 0)
+	{
+		pRxMgmtPacket =  DeQueue(pDevice);
+		vMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);
 	}
 	spin_unlock_irq(&pDevice->lock);
 }
@@ -313,531 +313,531 @@ void	MngWorkItem(void *Context)
 
 
 bool
-device_receive_frame (
-    PSDevice pDevice,
-    PSRxDesc pCurrRD
-    )
+device_receive_frame(
+	PSDevice pDevice,
+	PSRxDesc pCurrRD
+)
 {
 
-    PDEVICE_RD_INFO  pRDInfo = pCurrRD->pRDInfo;
+	PDEVICE_RD_INFO  pRDInfo = pCurrRD->pRDInfo;
 #ifdef	PLICE_DEBUG
 	//printk("device_receive_frame:pCurrRD is %x,pRDInfo is %x\n",pCurrRD,pCurrRD->pRDInfo);
 #endif
-    struct net_device_stats* pStats=&pDevice->stats;
-    struct sk_buff* skb;
-    PSMgmtObject    pMgmt = pDevice->pMgmt;
-    PSRxMgmtPacket  pRxPacket = &(pDevice->pMgmt->sRxPacket);
-    PS802_11Header  p802_11Header;
-    unsigned char *pbyRsr;
-    unsigned char *pbyNewRsr;
-    unsigned char *pbyRSSI;
-    PQWORD          pqwTSFTime;
-    unsigned short *pwFrameSize;
-    unsigned char *pbyFrame;
-    bool bDeFragRx = false;
-    bool bIsWEP = false;
-    unsigned int cbHeaderOffset;
-    unsigned int FrameSize;
-    unsigned short wEtherType = 0;
-    int             iSANodeIndex = -1;
-    int             iDANodeIndex = -1;
-    unsigned int ii;
-    unsigned int cbIVOffset;
-    bool bExtIV = false;
-    unsigned char *pbyRxSts;
-    unsigned char *pbyRxRate;
-    unsigned char *pbySQ;
-    unsigned int cbHeaderSize;
-    PSKeyItem       pKey = NULL;
-    unsigned short wRxTSC15_0 = 0;
-    unsigned long dwRxTSC47_16 = 0;
-    SKeyItem        STempKey;
-    // 802.11h RPI
-    unsigned long dwDuration = 0;
-    long            ldBm = 0;
-    long            ldBmThreshold = 0;
-    PS802_11Header pMACHeader;
- bool bRxeapol_key = false;
-
-//    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- device_receive_frame---\n");
-
-    skb = pRDInfo->skb;
+	struct net_device_stats *pStats = &pDevice->stats;
+	struct sk_buff *skb;
+	PSMgmtObject    pMgmt = pDevice->pMgmt;
+	PSRxMgmtPacket  pRxPacket = &(pDevice->pMgmt->sRxPacket);
+	PS802_11Header  p802_11Header;
+	unsigned char *pbyRsr;
+	unsigned char *pbyNewRsr;
+	unsigned char *pbyRSSI;
+	PQWORD          pqwTSFTime;
+	unsigned short *pwFrameSize;
+	unsigned char *pbyFrame;
+	bool bDeFragRx = false;
+	bool bIsWEP = false;
+	unsigned int cbHeaderOffset;
+	unsigned int FrameSize;
+	unsigned short wEtherType = 0;
+	int             iSANodeIndex = -1;
+	int             iDANodeIndex = -1;
+	unsigned int ii;
+	unsigned int cbIVOffset;
+	bool bExtIV = false;
+	unsigned char *pbyRxSts;
+	unsigned char *pbyRxRate;
+	unsigned char *pbySQ;
+	unsigned int cbHeaderSize;
+	PSKeyItem       pKey = NULL;
+	unsigned short wRxTSC15_0 = 0;
+	unsigned long dwRxTSC47_16 = 0;
+	SKeyItem        STempKey;
+	// 802.11h RPI
+	unsigned long dwDuration = 0;
+	long            ldBm = 0;
+	long            ldBmThreshold = 0;
+	PS802_11Header pMACHeader;
+	bool bRxeapol_key = false;
+
+//    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---------- device_receive_frame---\n");
+
+	skb = pRDInfo->skb;
 
 
 //PLICE_DEBUG->
 #if 1
 	pci_unmap_single(pDevice->pcid, pRDInfo->skb_dma,
-                     pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
+			 pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
 #endif
 //PLICE_DEBUG<-
-    pwFrameSize = (unsigned short *)(skb->data + 2);
-    FrameSize = cpu_to_le16(pCurrRD->m_rd1RD1.wReqCount) - cpu_to_le16(pCurrRD->m_rd0RD0.wResCount);
-
-    // Max: 2312Payload + 30HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
-    // Min (ACK): 10HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
-    if ((FrameSize > 2364)||(FrameSize <= 32)) {
-        // Frame Size error drop this packet.
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- WRONG Length 1 \n");
-        return false;
-    }
-
-    pbyRxSts = (unsigned char *) (skb->data);
-    pbyRxRate = (unsigned char *) (skb->data + 1);
-    pbyRsr = (unsigned char *) (skb->data + FrameSize - 1);
-    pbyRSSI = (unsigned char *) (skb->data + FrameSize - 2);
-    pbyNewRsr = (unsigned char *) (skb->data + FrameSize - 3);
-    pbySQ = (unsigned char *) (skb->data + FrameSize - 4);
-    pqwTSFTime = (PQWORD) (skb->data + FrameSize - 12);
-    pbyFrame = (unsigned char *)(skb->data + 4);
-
-    // get packet size
-    FrameSize = cpu_to_le16(*pwFrameSize);
-
-    if ((FrameSize > 2346)|(FrameSize < 14)) { // Max: 2312Payload + 30HD +4CRC
-                                               // Min: 14 bytes ACK
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- WRONG Length 2 \n");
-        return false;
-    }
+	pwFrameSize = (unsigned short *)(skb->data + 2);
+	FrameSize = cpu_to_le16(pCurrRD->m_rd1RD1.wReqCount) - cpu_to_le16(pCurrRD->m_rd0RD0.wResCount);
+
+	// Max: 2312Payload + 30HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
+	// Min (ACK): 10HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
+	if ((FrameSize > 2364) || (FrameSize <= 32)) {
+		// Frame Size error drop this packet.
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---------- WRONG Length 1 \n");
+		return false;
+	}
+
+	pbyRxSts = (unsigned char *)(skb->data);
+	pbyRxRate = (unsigned char *)(skb->data + 1);
+	pbyRsr = (unsigned char *)(skb->data + FrameSize - 1);
+	pbyRSSI = (unsigned char *)(skb->data + FrameSize - 2);
+	pbyNewRsr = (unsigned char *)(skb->data + FrameSize - 3);
+	pbySQ = (unsigned char *)(skb->data + FrameSize - 4);
+	pqwTSFTime = (PQWORD)(skb->data + FrameSize - 12);
+	pbyFrame = (unsigned char *)(skb->data + 4);
+
+	// get packet size
+	FrameSize = cpu_to_le16(*pwFrameSize);
+
+	if ((FrameSize > 2346)|(FrameSize < 14)) { // Max: 2312Payload + 30HD +4CRC
+		// Min: 14 bytes ACK
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---------- WRONG Length 2 \n");
+		return false;
+	}
 //PLICE_DEBUG->
 #if 1
 	// update receive statistic counter
-    STAvUpdateRDStatCounter(&pDevice->scStatistic,
-                            *pbyRsr,
-                            *pbyNewRsr,
-                            *pbyRxRate,
-                            pbyFrame,
-                            FrameSize);
+	STAvUpdateRDStatCounter(&pDevice->scStatistic,
+				*pbyRsr,
+				*pbyNewRsr,
+				*pbyRxRate,
+				pbyFrame,
+				FrameSize);
 
 #endif
 
-  pMACHeader=(PS802_11Header)((unsigned char *) (skb->data)+8);
+	pMACHeader = (PS802_11Header)((unsigned char *)(skb->data) + 8);
 //PLICE_DEBUG<-
 	if (pDevice->bMeasureInProgress == true) {
-        if ((*pbyRsr & RSR_CRCOK) != 0) {
-            pDevice->byBasicMap |= 0x01;
-        }
-        dwDuration = (FrameSize << 4);
-        dwDuration /= acbyRxRate[*pbyRxRate%MAX_RATE];
-        if (*pbyRxRate <= RATE_11M) {
-            if (*pbyRxSts & 0x01) {
-                // long preamble
-                dwDuration += 192;
-            } else {
-                // short preamble
-                dwDuration += 96;
-            }
-        } else {
-            dwDuration += 16;
-        }
-        RFvRSSITodBm(pDevice, *pbyRSSI, &ldBm);
-        ldBmThreshold = -57;
-        for (ii = 7; ii > 0;) {
-            if (ldBm > ldBmThreshold) {
-                break;
-            }
-            ldBmThreshold -= 5;
-            ii--;
-        }
-        pDevice->dwRPIs[ii] += dwDuration;
-        return false;
-    }
-
-    if (!is_multicast_ether_addr(pbyFrame)) {
-        if (WCTLbIsDuplicate(&(pDevice->sDupRxCache), (PS802_11Header) (skb->data + 4))) {
-            pDevice->s802_11Counter.FrameDuplicateCount++;
-            return false;
-        }
-    }
-
-
-    // Use for TKIP MIC
-    s_vGetDASA(skb->data+4, &cbHeaderSize, &pDevice->sRxEthHeader);
-
-    // filter packet send from myself
-    if (!compare_ether_addr((unsigned char *)&(pDevice->sRxEthHeader.abySrcAddr[0]), pDevice->abyCurrentNetAddr))
-        return false;
-
-    if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) || (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)) {
-        if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
-            p802_11Header = (PS802_11Header) (pbyFrame);
-            // get SA NodeIndex
-            if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(p802_11Header->abyAddr2), &iSANodeIndex)) {
-                pMgmt->sNodeDBTable[iSANodeIndex].ulLastRxJiffer = jiffies;
-                pMgmt->sNodeDBTable[iSANodeIndex].uInActiveCount = 0;
-            }
-        }
-    }
-
-    if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-        if (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex) == true) {
-            return false;
-        }
-    }
-
-
-    if (IS_FC_WEP(pbyFrame)) {
-        bool bRxDecryOK = false;
-
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"rx WEP pkt\n");
-        bIsWEP = true;
-        if ((pDevice->bEnableHostWEP) && (iSANodeIndex >= 0)) {
-            pKey = &STempKey;
-            pKey->byCipherSuite = pMgmt->sNodeDBTable[iSANodeIndex].byCipherSuite;
-            pKey->dwKeyIndex = pMgmt->sNodeDBTable[iSANodeIndex].dwKeyIndex;
-            pKey->uKeyLength = pMgmt->sNodeDBTable[iSANodeIndex].uWepKeyLength;
-            pKey->dwTSC47_16 = pMgmt->sNodeDBTable[iSANodeIndex].dwTSC47_16;
-            pKey->wTSC15_0 = pMgmt->sNodeDBTable[iSANodeIndex].wTSC15_0;
-            memcpy(pKey->abyKey,
-                &pMgmt->sNodeDBTable[iSANodeIndex].abyWepKey[0],
-                pKey->uKeyLength
-                );
-
-            bRxDecryOK = s_bHostWepRxEncryption(pDevice,
-                                                pbyFrame,
-                                                FrameSize,
-                                                pbyRsr,
-                                                pMgmt->sNodeDBTable[iSANodeIndex].bOnFly,
-                                                pKey,
-                                                pbyNewRsr,
-                                                &bExtIV,
-                                                &wRxTSC15_0,
-                                                &dwRxTSC47_16);
-        } else {
-            bRxDecryOK = s_bHandleRxEncryption(pDevice,
-                                                pbyFrame,
-                                                FrameSize,
-                                                pbyRsr,
-                                                pbyNewRsr,
-                                                &pKey,
-                                                &bExtIV,
-                                                &wRxTSC15_0,
-                                                &dwRxTSC47_16);
-        }
-
-        if (bRxDecryOK) {
-            if ((*pbyNewRsr & NEWRSR_DECRYPTOK) == 0) {
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV Fail\n");
-                if ( (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||
-                    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||
-                    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||
-                    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||
-                    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {
-
-                    if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
-                        pDevice->s802_11Counter.TKIPICVErrors++;
-                    } else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP)) {
-                        pDevice->s802_11Counter.CCMPDecryptErrors++;
-                    } else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_WEP)) {
+		if ((*pbyRsr & RSR_CRCOK) != 0) {
+			pDevice->byBasicMap |= 0x01;
+		}
+		dwDuration = (FrameSize << 4);
+		dwDuration /= acbyRxRate[*pbyRxRate%MAX_RATE];
+		if (*pbyRxRate <= RATE_11M) {
+			if (*pbyRxSts & 0x01) {
+				// long preamble
+				dwDuration += 192;
+			} else {
+				// short preamble
+				dwDuration += 96;
+			}
+		} else {
+			dwDuration += 16;
+		}
+		RFvRSSITodBm(pDevice, *pbyRSSI, &ldBm);
+		ldBmThreshold = -57;
+		for (ii = 7; ii > 0;) {
+			if (ldBm > ldBmThreshold) {
+				break;
+			}
+			ldBmThreshold -= 5;
+			ii--;
+		}
+		pDevice->dwRPIs[ii] += dwDuration;
+		return false;
+	}
+
+	if (!is_multicast_ether_addr(pbyFrame)) {
+		if (WCTLbIsDuplicate(&(pDevice->sDupRxCache), (PS802_11Header)(skb->data + 4))) {
+			pDevice->s802_11Counter.FrameDuplicateCount++;
+			return false;
+		}
+	}
+
+
+	// Use for TKIP MIC
+	s_vGetDASA(skb->data+4, &cbHeaderSize, &pDevice->sRxEthHeader);
+
+	// filter packet send from myself
+	if (!compare_ether_addr((unsigned char *)&(pDevice->sRxEthHeader.abySrcAddr[0]), pDevice->abyCurrentNetAddr))
+		return false;
+
+	if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) || (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)) {
+		if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
+			p802_11Header = (PS802_11Header)(pbyFrame);
+			// get SA NodeIndex
+			if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(p802_11Header->abyAddr2), &iSANodeIndex)) {
+				pMgmt->sNodeDBTable[iSANodeIndex].ulLastRxJiffer = jiffies;
+				pMgmt->sNodeDBTable[iSANodeIndex].uInActiveCount = 0;
+			}
+		}
+	}
+
+	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+		if (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex) == true) {
+			return false;
+		}
+	}
+
+
+	if (IS_FC_WEP(pbyFrame)) {
+		bool bRxDecryOK = false;
+
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "rx WEP pkt\n");
+		bIsWEP = true;
+		if ((pDevice->bEnableHostWEP) && (iSANodeIndex >= 0)) {
+			pKey = &STempKey;
+			pKey->byCipherSuite = pMgmt->sNodeDBTable[iSANodeIndex].byCipherSuite;
+			pKey->dwKeyIndex = pMgmt->sNodeDBTable[iSANodeIndex].dwKeyIndex;
+			pKey->uKeyLength = pMgmt->sNodeDBTable[iSANodeIndex].uWepKeyLength;
+			pKey->dwTSC47_16 = pMgmt->sNodeDBTable[iSANodeIndex].dwTSC47_16;
+			pKey->wTSC15_0 = pMgmt->sNodeDBTable[iSANodeIndex].wTSC15_0;
+			memcpy(pKey->abyKey,
+			       &pMgmt->sNodeDBTable[iSANodeIndex].abyWepKey[0],
+			       pKey->uKeyLength
+);
+
+			bRxDecryOK = s_bHostWepRxEncryption(pDevice,
+							    pbyFrame,
+							    FrameSize,
+							    pbyRsr,
+							    pMgmt->sNodeDBTable[iSANodeIndex].bOnFly,
+							    pKey,
+							    pbyNewRsr,
+							    &bExtIV,
+							    &wRxTSC15_0,
+							    &dwRxTSC47_16);
+		} else {
+			bRxDecryOK = s_bHandleRxEncryption(pDevice,
+							   pbyFrame,
+							   FrameSize,
+							   pbyRsr,
+							   pbyNewRsr,
+							   &pKey,
+							   &bExtIV,
+							   &wRxTSC15_0,
+							   &dwRxTSC47_16);
+		}
+
+		if (bRxDecryOK) {
+			if ((*pbyNewRsr & NEWRSR_DECRYPTOK) == 0) {
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ICV Fail\n");
+				if ((pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||
+				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||
+				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||
+				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||
+				    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {
+
+					if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
+						pDevice->s802_11Counter.TKIPICVErrors++;
+					} else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP)) {
+						pDevice->s802_11Counter.CCMPDecryptErrors++;
+					} else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_WEP)) {
 //                      pDevice->s802_11Counter.WEPICVErrorCount.QuadPart++;
-                    }
-                }
-                return false;
-            }
-        } else {
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"WEP Func Fail\n");
-            return false;
-        }
-        if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP))
-            FrameSize -= 8;         // Message Integrity Code
-        else
-            FrameSize -= 4;         // 4 is ICV
-    }
-
-
-    //
-    // RX OK
-    //
-    //remove the CRC length
-    FrameSize -= ETH_FCS_LEN;
-
-    if (( !(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI))) && // unicast address
-        (IS_FRAGMENT_PKT((skb->data+4)))
-        ) {
-        // defragment
-        bDeFragRx = WCTLbHandleFragment(pDevice, (PS802_11Header) (skb->data+4), FrameSize, bIsWEP, bExtIV);
-        pDevice->s802_11Counter.ReceivedFragmentCount++;
-        if (bDeFragRx) {
-            // defrag complete
-            skb = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].skb;
-            FrameSize = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].cbFrameLength;
-
-        }
-        else {
-            return false;
-        }
-    }
+					}
+				}
+				return false;
+			}
+		} else {
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "WEP Func Fail\n");
+			return false;
+		}
+		if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP))
+			FrameSize -= 8;         // Message Integrity Code
+		else
+			FrameSize -= 4;         // 4 is ICV
+	}
+
+
+	//
+	// RX OK
+	//
+	//remove the CRC length
+	FrameSize -= ETH_FCS_LEN;
+
+	if ((!(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI))) && // unicast address
+	    (IS_FRAGMENT_PKT((skb->data+4)))
+) {
+		// defragment
+		bDeFragRx = WCTLbHandleFragment(pDevice, (PS802_11Header)(skb->data+4), FrameSize, bIsWEP, bExtIV);
+		pDevice->s802_11Counter.ReceivedFragmentCount++;
+		if (bDeFragRx) {
+			// defrag complete
+			skb = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].skb;
+			FrameSize = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].cbFrameLength;
+
+		}
+		else {
+			return false;
+		}
+	}
 
 
 // Management & Control frame Handle
-    if ((IS_TYPE_DATA((skb->data+4))) == false) {
-        // Handle Control & Manage Frame
-
-        if (IS_TYPE_MGMT((skb->data+4))) {
-            unsigned char *pbyData1;
-            unsigned char *pbyData2;
-
-            pRxPacket->p80211Header = (PUWLAN_80211HDR)(skb->data+4);
-            pRxPacket->cbMPDULen = FrameSize;
-            pRxPacket->uRSSI = *pbyRSSI;
-            pRxPacket->bySQ = *pbySQ;
-            HIDWORD(pRxPacket->qwLocalTSF) = cpu_to_le32(HIDWORD(*pqwTSFTime));
-            LODWORD(pRxPacket->qwLocalTSF) = cpu_to_le32(LODWORD(*pqwTSFTime));
-            if (bIsWEP) {
-                // strip IV
-                pbyData1 = WLAN_HDR_A3_DATA_PTR(skb->data+4);
-                pbyData2 = WLAN_HDR_A3_DATA_PTR(skb->data+4) + 4;
-                for (ii = 0; ii < (FrameSize - 4); ii++) {
-                    *pbyData1 = *pbyData2;
-                     pbyData1++;
-                     pbyData2++;
-                }
-            }
-            pRxPacket->byRxRate = s_byGetRateIdx(*pbyRxRate);
-            pRxPacket->byRxChannel = (*pbyRxSts) >> 2;
+	if ((IS_TYPE_DATA((skb->data+4))) == false) {
+		// Handle Control & Manage Frame
+
+		if (IS_TYPE_MGMT((skb->data+4))) {
+			unsigned char *pbyData1;
+			unsigned char *pbyData2;
+
+			pRxPacket->p80211Header = (PUWLAN_80211HDR)(skb->data+4);
+			pRxPacket->cbMPDULen = FrameSize;
+			pRxPacket->uRSSI = *pbyRSSI;
+			pRxPacket->bySQ = *pbySQ;
+			HIDWORD(pRxPacket->qwLocalTSF) = cpu_to_le32(HIDWORD(*pqwTSFTime));
+			LODWORD(pRxPacket->qwLocalTSF) = cpu_to_le32(LODWORD(*pqwTSFTime));
+			if (bIsWEP) {
+				// strip IV
+				pbyData1 = WLAN_HDR_A3_DATA_PTR(skb->data+4);
+				pbyData2 = WLAN_HDR_A3_DATA_PTR(skb->data+4) + 4;
+				for (ii = 0; ii < (FrameSize - 4); ii++) {
+					*pbyData1 = *pbyData2;
+					pbyData1++;
+					pbyData2++;
+				}
+			}
+			pRxPacket->byRxRate = s_byGetRateIdx(*pbyRxRate);
+			pRxPacket->byRxChannel = (*pbyRxSts) >> 2;
 //PLICE_DEBUG->
 //EnQueue(pDevice,pRxPacket);
 
 #ifdef	THREAD
-		EnQueue(pDevice,pRxPacket);
+			EnQueue(pDevice, pRxPacket);
 
-		//printk("enque time is %x\n",jiffies);
-		//up(&pDevice->mlme_semaphore);
+			//printk("enque time is %x\n",jiffies);
+			//up(&pDevice->mlme_semaphore);
 			//Enque (pDevice->FirstRecvMngList,pDevice->LastRecvMngList,pMgmt);
 #else
 
 #ifdef	TASK_LET
-		EnQueue(pDevice,pRxPacket);
-		tasklet_schedule(&pDevice->RxMngWorkItem);
+			EnQueue(pDevice, pRxPacket);
+			tasklet_schedule(&pDevice->RxMngWorkItem);
 #else
 //printk("RxMan\n");
-	vMgrRxManagePacket((void *)pDevice, pDevice->pMgmt, pRxPacket);
-           //tasklet_schedule(&pDevice->RxMngWorkItem);
+			vMgrRxManagePacket((void *)pDevice, pDevice->pMgmt, pRxPacket);
+			//tasklet_schedule(&pDevice->RxMngWorkItem);
 #endif
 
 #endif
 //PLICE_DEBUG<-
 			//vMgrRxManagePacket((void *)pDevice, pDevice->pMgmt, pRxPacket);
-            // hostap Deamon handle 802.11 management
-            if (pDevice->bEnableHostapd) {
-	            skb->dev = pDevice->apdev;
-	            skb->data += 4;
-	            skb->tail += 4;
-                     skb_put(skb, FrameSize);
-		skb_reset_mac_header(skb);
-	            skb->pkt_type = PACKET_OTHERHOST;
-    	        skb->protocol = htons(ETH_P_802_2);
-	            memset(skb->cb, 0, sizeof(skb->cb));
-	            netif_rx(skb);
-                return true;
-	        }
-        }
-        else {
-            // Control Frame
-        };
-        return false;
-    }
-    else {
-        if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-            //In AP mode, hw only check addr1(BSSID or RA) if equal to local MAC.
-            if ( !(*pbyRsr & RSR_BSSIDOK)) {
-                if (bDeFragRx) {
-                    if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-                        DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
-                        pDevice->dev->name);
-                    }
-                }
-                return false;
-            }
-        }
-        else {
-            // discard DATA packet while not associate || BSSID error
-            if ((pDevice->bLinkPass == false) ||
-                !(*pbyRsr & RSR_BSSIDOK)) {
-                if (bDeFragRx) {
-                    if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-                        DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
-                        pDevice->dev->name);
-                    }
-                }
-                return false;
-            }
-   //mike add:station mode check eapol-key challenge--->
-   	  {
-   	    unsigned char Protocol_Version;    //802.1x Authentication
-	    unsigned char Packet_Type;           //802.1x Authentication
-              if (bIsWEP)
-                  cbIVOffset = 8;
-              else
-                  cbIVOffset = 0;
-              wEtherType = (skb->data[cbIVOffset + 8 + 24 + 6] << 8) |
-                          skb->data[cbIVOffset + 8 + 24 + 6 + 1];
-	      Protocol_Version = skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1];
-	      Packet_Type = skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1+1];
-	     if (wEtherType == ETH_P_PAE) {         //Protocol Type in LLC-Header
-                  if(((Protocol_Version==1) ||(Protocol_Version==2)) &&
-		     (Packet_Type==3)) {  //802.1x OR eapol-key challenge frame receive
-                        bRxeapol_key = true;
-                  }
-	      }
-   	  }
-    //mike add:station mode check eapol-key challenge<---
-        }
-    }
+			// hostap Deamon handle 802.11 management
+			if (pDevice->bEnableHostapd) {
+				skb->dev = pDevice->apdev;
+				skb->data += 4;
+				skb->tail += 4;
+				skb_put(skb, FrameSize);
+				skb_reset_mac_header(skb);
+				skb->pkt_type = PACKET_OTHERHOST;
+				skb->protocol = htons(ETH_P_802_2);
+				memset(skb->cb, 0, sizeof(skb->cb));
+				netif_rx(skb);
+				return true;
+			}
+		}
+		else {
+			// Control Frame
+		};
+		return false;
+	}
+	else {
+		if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+			//In AP mode, hw only check addr1(BSSID or RA) if equal to local MAC.
+			if (!(*pbyRsr & RSR_BSSIDOK)) {
+				if (bDeFragRx) {
+					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+						DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
+							pDevice->dev->name);
+					}
+				}
+				return false;
+			}
+		}
+		else {
+			// discard DATA packet while not associate || BSSID error
+			if ((pDevice->bLinkPass == false) ||
+			    !(*pbyRsr & RSR_BSSIDOK)) {
+				if (bDeFragRx) {
+					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+						DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
+							pDevice->dev->name);
+					}
+				}
+				return false;
+			}
+			//mike add:station mode check eapol-key challenge--->
+			{
+				unsigned char Protocol_Version;    //802.1x Authentication
+				unsigned char Packet_Type;           //802.1x Authentication
+				if (bIsWEP)
+					cbIVOffset = 8;
+				else
+					cbIVOffset = 0;
+				wEtherType = (skb->data[cbIVOffset + 8 + 24 + 6] << 8) |
+					skb->data[cbIVOffset + 8 + 24 + 6 + 1];
+				Protocol_Version = skb->data[cbIVOffset + 8 + 24 + 6 + 1 + 1];
+				Packet_Type = skb->data[cbIVOffset + 8 + 24 + 6 + 1 + 1 + 1];
+				if (wEtherType == ETH_P_PAE) {         //Protocol Type in LLC-Header
+					if (((Protocol_Version == 1) || (Protocol_Version == 2)) &&
+					    (Packet_Type == 3)) {  //802.1x OR eapol-key challenge frame receive
+						bRxeapol_key = true;
+					}
+				}
+			}
+			//mike add:station mode check eapol-key challenge<---
+		}
+	}
 
 
 // Data frame Handle
 
 
-    if (pDevice->bEnablePSMode) {
-        if (IS_FC_MOREDATA((skb->data+4))) {
-            if (*pbyRsr & RSR_ADDROK) {
-                //PSbSendPSPOLL((PSDevice)pDevice);
-            }
-        }
-        else {
-            if (pDevice->pMgmt->bInTIMWake == true) {
-                pDevice->pMgmt->bInTIMWake = false;
-            }
-        }
-    }
-
-    // Now it only supports 802.11g Infrastructure Mode, and support rate must up to 54 Mbps
-    if (pDevice->bDiversityEnable && (FrameSize>50) &&
-        (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE) &&
-        (pDevice->bLinkPass == true)) {
-	//printk("device_receive_frame: RxRate is %d\n",*pbyRxRate);
+	if (pDevice->bEnablePSMode) {
+		if (IS_FC_MOREDATA((skb->data+4))) {
+			if (*pbyRsr & RSR_ADDROK) {
+				//PSbSendPSPOLL((PSDevice)pDevice);
+			}
+		}
+		else {
+			if (pDevice->pMgmt->bInTIMWake == true) {
+				pDevice->pMgmt->bInTIMWake = false;
+			}
+		}
+	}
+
+	// Now it only supports 802.11g Infrastructure Mode, and support rate must up to 54 Mbps
+	if (pDevice->bDiversityEnable && (FrameSize > 50) &&
+	    (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE) &&
+	    (pDevice->bLinkPass == true)) {
+		//printk("device_receive_frame: RxRate is %d\n",*pbyRxRate);
 		BBvAntennaDiversity(pDevice, s_byGetRateIdx(*pbyRxRate), 0);
-    }
-
-
-    if (pDevice->byLocalID != REV_ID_VT3253_B1) {
-        pDevice->uCurrRSSI = *pbyRSSI;
-    }
-    pDevice->byCurrSQ = *pbySQ;
-
-    if ((*pbyRSSI != 0) &&
-        (pMgmt->pCurrBSS!=NULL)) {
-        RFvRSSITodBm(pDevice, *pbyRSSI, &ldBm);
-        // Monitor if RSSI is too strong.
-        pMgmt->pCurrBSS->byRSSIStatCnt++;
-        pMgmt->pCurrBSS->byRSSIStatCnt %= RSSI_STAT_COUNT;
-        pMgmt->pCurrBSS->ldBmAverage[pMgmt->pCurrBSS->byRSSIStatCnt] = ldBm;
-        for(ii=0;ii<RSSI_STAT_COUNT;ii++) {
-            if (pMgmt->pCurrBSS->ldBmAverage[ii] != 0) {
-            pMgmt->pCurrBSS->ldBmMAX = max(pMgmt->pCurrBSS->ldBmAverage[ii], ldBm);
-            }
-        }
-    }
-
-    // -----------------------------------------------
-
-    if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) && (pDevice->bEnable8021x == true)){
-        unsigned char abyMacHdr[24];
-
-        // Only 802.1x packet incoming allowed
-        if (bIsWEP)
-            cbIVOffset = 8;
-        else
-            cbIVOffset = 0;
-        wEtherType = (skb->data[cbIVOffset + 4 + 24 + 6] << 8) |
-                    skb->data[cbIVOffset + 4 + 24 + 6 + 1];
-
-	    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"wEtherType = %04x \n", wEtherType);
-        if (wEtherType == ETH_P_PAE) {
-            skb->dev = pDevice->apdev;
-
-            if (bIsWEP == true) {
-                // strip IV header(8)
-                memcpy(&abyMacHdr[0], (skb->data + 4), 24);
-                memcpy((skb->data + 4 + cbIVOffset), &abyMacHdr[0], 24);
-            }
-            skb->data +=  (cbIVOffset + 4);
-            skb->tail +=  (cbIVOffset + 4);
-            skb_put(skb, FrameSize);
-	    skb_reset_mac_header(skb);
-
-	skb->pkt_type = PACKET_OTHERHOST;
-            skb->protocol = htons(ETH_P_802_2);
-            memset(skb->cb, 0, sizeof(skb->cb));
-            netif_rx(skb);
-            return true;
+	}
 
-}
-        // check if 802.1x authorized
-        if (!(pMgmt->sNodeDBTable[iSANodeIndex].dwFlags & WLAN_STA_AUTHORIZED))
-            return false;
-    }
-
-
-    if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
-        if (bIsWEP) {
-            FrameSize -= 8;  //MIC
-        }
-    }
-
-    //--------------------------------------------------------------------------------
-    // Soft MIC
-    if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
-        if (bIsWEP) {
-            unsigned long *pdwMIC_L;
-            unsigned long *pdwMIC_R;
-            unsigned long dwMIC_Priority;
-            unsigned long dwMICKey0 = 0, dwMICKey1 = 0;
-            unsigned long dwLocalMIC_L = 0;
-            unsigned long dwLocalMIC_R = 0;
-            viawget_wpa_header *wpahdr;
-
-
-            if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-                dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[24]));
-                dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[28]));
-            }
-            else {
-                if (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) {
-                    dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[16]));
-                    dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[20]));
-                } else if ((pKey->dwKeyIndex & BIT28) == 0) {
-                    dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[16]));
-                    dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[20]));
-                } else {
-                    dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[24]));
-                    dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[28]));
-                }
-            }
-
-            MIC_vInit(dwMICKey0, dwMICKey1);
-            MIC_vAppend((unsigned char *)&(pDevice->sRxEthHeader.abyDstAddr[0]), 12);
-            dwMIC_Priority = 0;
-            MIC_vAppend((unsigned char *)&dwMIC_Priority, 4);
-            // 4 is Rcv buffer header, 24 is MAC Header, and 8 is IV and Ext IV.
-            MIC_vAppend((unsigned char *)(skb->data + 4 + WLAN_HDR_ADDR3_LEN + 8),
-                        FrameSize - WLAN_HDR_ADDR3_LEN - 8);
-            MIC_vGetMIC(&dwLocalMIC_L, &dwLocalMIC_R);
-            MIC_vUnInit();
-
-            pdwMIC_L = (unsigned long *)(skb->data + 4 + FrameSize);
-            pdwMIC_R = (unsigned long *)(skb->data + 4 + FrameSize + 4);
-            //DBG_PRN_GRP12(("RxL: %lx, RxR: %lx\n", *pdwMIC_L, *pdwMIC_R));
-            //DBG_PRN_GRP12(("LocalL: %lx, LocalR: %lx\n", dwLocalMIC_L, dwLocalMIC_R));
-            //DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"dwMICKey0= %lx,dwMICKey1= %lx \n", dwMICKey0, dwMICKey1);
-
-
-            if ((cpu_to_le32(*pdwMIC_L) != dwLocalMIC_L) || (cpu_to_le32(*pdwMIC_R) != dwLocalMIC_R) ||
-                (pDevice->bRxMICFail == true)) {
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC comparison is fail!\n");
-                pDevice->bRxMICFail = false;
-                //pDevice->s802_11Counter.TKIPLocalMICFailures.QuadPart++;
-                pDevice->s802_11Counter.TKIPLocalMICFailures++;
-                if (bDeFragRx) {
-                    if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-                        DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
-                            pDevice->dev->name);
-                    }
-                }
-               //2008-0409-07, <Add> by Einsn Liu
-       #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+
+	if (pDevice->byLocalID != REV_ID_VT3253_B1) {
+		pDevice->uCurrRSSI = *pbyRSSI;
+	}
+	pDevice->byCurrSQ = *pbySQ;
+
+	if ((*pbyRSSI != 0) &&
+	    (pMgmt->pCurrBSS != NULL)) {
+		RFvRSSITodBm(pDevice, *pbyRSSI, &ldBm);
+		// Monitor if RSSI is too strong.
+		pMgmt->pCurrBSS->byRSSIStatCnt++;
+		pMgmt->pCurrBSS->byRSSIStatCnt %= RSSI_STAT_COUNT;
+		pMgmt->pCurrBSS->ldBmAverage[pMgmt->pCurrBSS->byRSSIStatCnt] = ldBm;
+		for (ii = 0; ii < RSSI_STAT_COUNT; ii++) {
+			if (pMgmt->pCurrBSS->ldBmAverage[ii] != 0) {
+				pMgmt->pCurrBSS->ldBmMAX = max(pMgmt->pCurrBSS->ldBmAverage[ii], ldBm);
+			}
+		}
+	}
+
+	// -----------------------------------------------
+
+	if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) && (pDevice->bEnable8021x == true)) {
+		unsigned char abyMacHdr[24];
+
+		// Only 802.1x packet incoming allowed
+		if (bIsWEP)
+			cbIVOffset = 8;
+		else
+			cbIVOffset = 0;
+		wEtherType = (skb->data[cbIVOffset + 4 + 24 + 6] << 8) |
+			skb->data[cbIVOffset + 4 + 24 + 6 + 1];
+
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wEtherType = %04x \n", wEtherType);
+		if (wEtherType == ETH_P_PAE) {
+			skb->dev = pDevice->apdev;
+
+			if (bIsWEP == true) {
+				// strip IV header(8)
+				memcpy(&abyMacHdr[0], (skb->data + 4), 24);
+				memcpy((skb->data + 4 + cbIVOffset), &abyMacHdr[0], 24);
+			}
+			skb->data +=  (cbIVOffset + 4);
+			skb->tail +=  (cbIVOffset + 4);
+			skb_put(skb, FrameSize);
+			skb_reset_mac_header(skb);
+
+			skb->pkt_type = PACKET_OTHERHOST;
+			skb->protocol = htons(ETH_P_802_2);
+			memset(skb->cb, 0, sizeof(skb->cb));
+			netif_rx(skb);
+			return true;
+
+		}
+		// check if 802.1x authorized
+		if (!(pMgmt->sNodeDBTable[iSANodeIndex].dwFlags & WLAN_STA_AUTHORIZED))
+			return false;
+	}
+
+
+	if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
+		if (bIsWEP) {
+			FrameSize -= 8;  //MIC
+		}
+	}
+
+	//--------------------------------------------------------------------------------
+	// Soft MIC
+	if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
+		if (bIsWEP) {
+			unsigned long *pdwMIC_L;
+			unsigned long *pdwMIC_R;
+			unsigned long dwMIC_Priority;
+			unsigned long dwMICKey0 = 0, dwMICKey1 = 0;
+			unsigned long dwLocalMIC_L = 0;
+			unsigned long dwLocalMIC_R = 0;
+			viawget_wpa_header *wpahdr;
+
+
+			if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+				dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[24]));
+				dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[28]));
+			}
+			else {
+				if (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) {
+					dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[16]));
+					dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[20]));
+				} else if ((pKey->dwKeyIndex & BIT28) == 0) {
+					dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[16]));
+					dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[20]));
+				} else {
+					dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[24]));
+					dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[28]));
+				}
+			}
+
+			MIC_vInit(dwMICKey0, dwMICKey1);
+			MIC_vAppend((unsigned char *)&(pDevice->sRxEthHeader.abyDstAddr[0]), 12);
+			dwMIC_Priority = 0;
+			MIC_vAppend((unsigned char *)&dwMIC_Priority, 4);
+			// 4 is Rcv buffer header, 24 is MAC Header, and 8 is IV and Ext IV.
+			MIC_vAppend((unsigned char *)(skb->data + 4 + WLAN_HDR_ADDR3_LEN + 8),
+				    FrameSize - WLAN_HDR_ADDR3_LEN - 8);
+			MIC_vGetMIC(&dwLocalMIC_L, &dwLocalMIC_R);
+			MIC_vUnInit();
+
+			pdwMIC_L = (unsigned long *)(skb->data + 4 + FrameSize);
+			pdwMIC_R = (unsigned long *)(skb->data + 4 + FrameSize + 4);
+			//DBG_PRN_GRP12(("RxL: %lx, RxR: %lx\n", *pdwMIC_L, *pdwMIC_R));
+			//DBG_PRN_GRP12(("LocalL: %lx, LocalR: %lx\n", dwLocalMIC_L, dwLocalMIC_R));
+			//DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwMICKey0= %lx,dwMICKey1= %lx \n", dwMICKey0, dwMICKey1);
+
+
+			if ((cpu_to_le32(*pdwMIC_L) != dwLocalMIC_L) || (cpu_to_le32(*pdwMIC_R) != dwLocalMIC_R) ||
+			    (pDevice->bRxMICFail == true)) {
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MIC comparison is fail!\n");
+				pDevice->bRxMICFail = false;
+				//pDevice->s802_11Counter.TKIPLocalMICFailures.QuadPart++;
+				pDevice->s802_11Counter.TKIPLocalMICFailures++;
+				if (bDeFragRx) {
+					if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+						DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
+							pDevice->dev->name);
+					}
+				}
+				//2008-0409-07, <Add> by Einsn Liu
+#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 				//send event to wpa_supplicant
-				//if(pDevice->bWPADevEnable == true)
+				//if (pDevice->bWPADevEnable == true)
 				{
 					union iwreq_data wrqu;
 					struct iw_michaelmicfailure ev;
@@ -845,8 +845,8 @@ device_receive_frame (
 					memset(&ev, 0, sizeof(ev));
 					ev.flags = keyidx & IW_MICFAILURE_KEY_ID;
 					if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
-							(pMgmt->eCurrState == WMAC_STATE_ASSOC) &&
-								(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) {
+					    (pMgmt->eCurrState == WMAC_STATE_ASSOC) &&
+					    (*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) {
 						ev.flags |= IW_MICFAILURE_PAIRWISE;
 					} else {
 						ev.flags |= IW_MICFAILURE_GROUP;
@@ -859,633 +859,633 @@ device_receive_frame (
 					wireless_send_event(pDevice->dev, IWEVMICHAELMICFAILURE, &wrqu, (char *)&ev);
 
 				}
-         #endif
-
-
-                if ((pDevice->bWPADEVUp) && (pDevice->skb != NULL)) {
-                     wpahdr = (viawget_wpa_header *)pDevice->skb->data;
-                     if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
-                         (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC) &&
-                         (*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) {
-                         //s802_11_Status.Flags = NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR;
-                         wpahdr->type = VIAWGET_PTK_MIC_MSG;
-                     } else {
-                         //s802_11_Status.Flags = NDIS_802_11_AUTH_REQUEST_GROUP_ERROR;
-                         wpahdr->type = VIAWGET_GTK_MIC_MSG;
-                     }
-                     wpahdr->resp_ie_len = 0;
-                     wpahdr->req_ie_len = 0;
-                     skb_put(pDevice->skb, sizeof(viawget_wpa_header));
-                     pDevice->skb->dev = pDevice->wpadev;
-		     skb_reset_mac_header(pDevice->skb);
-                     pDevice->skb->pkt_type = PACKET_HOST;
-                     pDevice->skb->protocol = htons(ETH_P_802_2);
-                     memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
-                     netif_rx(pDevice->skb);
-                     pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-                 }
-
-                return false;
-
-            }
-        }
-    } //---end of SOFT MIC-----------------------------------------------------------------------
-
-    // ++++++++++ Reply Counter Check +++++++++++++
-
-    if ((pKey != NULL) && ((pKey->byCipherSuite == KEY_CTL_TKIP) ||
-                           (pKey->byCipherSuite == KEY_CTL_CCMP))) {
-        if (bIsWEP) {
-            unsigned short wLocalTSC15_0 = 0;
-            unsigned long dwLocalTSC47_16 = 0;
-            unsigned long long       RSC = 0;
-            // endian issues
-            RSC = *((unsigned long long *) &(pKey->KeyRSC));
-            wLocalTSC15_0 = (unsigned short) RSC;
-            dwLocalTSC47_16 = (unsigned long) (RSC>>16);
-
-            RSC = dwRxTSC47_16;
-            RSC <<= 16;
-            RSC += wRxTSC15_0;
-            memcpy(&(pKey->KeyRSC), &RSC,  sizeof(QWORD));
-
-            if ( (pDevice->sMgmtObj.eCurrMode == WMAC_MODE_ESS_STA) &&
-                 (pDevice->sMgmtObj.eCurrState == WMAC_STATE_ASSOC)) {
-                // check RSC
-                if ( (wRxTSC15_0 < wLocalTSC15_0) &&
-                     (dwRxTSC47_16 <= dwLocalTSC47_16) &&
-                     !((dwRxTSC47_16 == 0) && (dwLocalTSC47_16 == 0xFFFFFFFF))) {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC is illegal~~!\n ");
-                    if (pKey->byCipherSuite == KEY_CTL_TKIP)
-                        //pDevice->s802_11Counter.TKIPReplays.QuadPart++;
-                        pDevice->s802_11Counter.TKIPReplays++;
-                    else
-                        //pDevice->s802_11Counter.CCMPReplays.QuadPart++;
-                        pDevice->s802_11Counter.CCMPReplays++;
-
-                    if (bDeFragRx) {
-                        if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-                            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
-                                pDevice->dev->name);
-                        }
-                    }
-                    return false;
-                }
-            }
-        }
-    } // ----- End of Reply Counter Check --------------------------
-
-
-
-    if ((pKey != NULL) && (bIsWEP)) {
+#endif
+
+
+				if ((pDevice->bWPADEVUp) && (pDevice->skb != NULL)) {
+					wpahdr = (viawget_wpa_header *)pDevice->skb->data;
+					if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
+					    (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC) &&
+					    (*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) {
+						//s802_11_Status.Flags = NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR;
+						wpahdr->type = VIAWGET_PTK_MIC_MSG;
+					} else {
+						//s802_11_Status.Flags = NDIS_802_11_AUTH_REQUEST_GROUP_ERROR;
+						wpahdr->type = VIAWGET_GTK_MIC_MSG;
+					}
+					wpahdr->resp_ie_len = 0;
+					wpahdr->req_ie_len = 0;
+					skb_put(pDevice->skb, sizeof(viawget_wpa_header));
+					pDevice->skb->dev = pDevice->wpadev;
+					skb_reset_mac_header(pDevice->skb);
+					pDevice->skb->pkt_type = PACKET_HOST;
+					pDevice->skb->protocol = htons(ETH_P_802_2);
+					memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
+					netif_rx(pDevice->skb);
+					pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
+				}
+
+				return false;
+
+			}
+		}
+	} //---end of SOFT MIC-----------------------------------------------------------------------
+
+	// ++++++++++ Reply Counter Check +++++++++++++
+
+	if ((pKey != NULL) && ((pKey->byCipherSuite == KEY_CTL_TKIP) ||
+			       (pKey->byCipherSuite == KEY_CTL_CCMP))) {
+		if (bIsWEP) {
+			unsigned short wLocalTSC15_0 = 0;
+			unsigned long dwLocalTSC47_16 = 0;
+			unsigned long long       RSC = 0;
+			// endian issues
+			RSC = *((unsigned long long *)&(pKey->KeyRSC));
+			wLocalTSC15_0 = (unsigned short)RSC;
+			dwLocalTSC47_16 = (unsigned long)(RSC>>16);
+
+			RSC = dwRxTSC47_16;
+			RSC <<= 16;
+			RSC += wRxTSC15_0;
+			memcpy(&(pKey->KeyRSC), &RSC,  sizeof(QWORD));
+
+			if ((pDevice->sMgmtObj.eCurrMode == WMAC_MODE_ESS_STA) &&
+			    (pDevice->sMgmtObj.eCurrState == WMAC_STATE_ASSOC)) {
+				// check RSC
+				if ((wRxTSC15_0 < wLocalTSC15_0) &&
+				    (dwRxTSC47_16 <= dwLocalTSC47_16) &&
+				    !((dwRxTSC47_16 == 0) && (dwLocalTSC47_16 == 0xFFFFFFFF))) {
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "TSC is illegal~~!\n ");
+					if (pKey->byCipherSuite == KEY_CTL_TKIP)
+						//pDevice->s802_11Counter.TKIPReplays.QuadPart++;
+						pDevice->s802_11Counter.TKIPReplays++;
+					else
+						//pDevice->s802_11Counter.CCMPReplays.QuadPart++;
+						pDevice->s802_11Counter.CCMPReplays++;
+
+					if (bDeFragRx) {
+						if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+							DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
+								pDevice->dev->name);
+						}
+					}
+					return false;
+				}
+			}
+		}
+	} // ----- End of Reply Counter Check --------------------------
+
+
+
+	if ((pKey != NULL) && (bIsWEP)) {
 //      pDevice->s802_11Counter.DecryptSuccessCount.QuadPart++;
-    }
-
-
-    s_vProcessRxMACHeader(pDevice, (unsigned char *)(skb->data+4), FrameSize, bIsWEP, bExtIV, &cbHeaderOffset);
-    FrameSize -= cbHeaderOffset;
-    cbHeaderOffset += 4;        // 4 is Rcv buffer header
-
-    // Null data, framesize = 14
-    if (FrameSize < 15)
-        return false;
-
-    if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-        if (s_bAPModeRxData(pDevice,
-                            skb,
-                            FrameSize,
-                            cbHeaderOffset,
-                            iSANodeIndex,
-                            iDANodeIndex
-                            ) == false) {
-
-            if (bDeFragRx) {
-                if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-                    DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
-                    pDevice->dev->name);
-                }
-            }
-            return false;
-        }
-
-//        if(pDevice->bRxMICFail == false) {
+	}
+
+
+	s_vProcessRxMACHeader(pDevice, (unsigned char *)(skb->data+4), FrameSize, bIsWEP, bExtIV, &cbHeaderOffset);
+	FrameSize -= cbHeaderOffset;
+	cbHeaderOffset += 4;        // 4 is Rcv buffer header
+
+	// Null data, framesize = 14
+	if (FrameSize < 15)
+		return false;
+
+	if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+		if (s_bAPModeRxData(pDevice,
+				    skb,
+				    FrameSize,
+				    cbHeaderOffset,
+				    iSANodeIndex,
+				    iDANodeIndex
+) == false) {
+
+			if (bDeFragRx) {
+				if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+					DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
+						pDevice->dev->name);
+				}
+			}
+			return false;
+		}
+
+//        if (pDevice->bRxMICFail == false) {
 //           for (ii =0; ii < 100; ii++)
 //                printk(" %02x", *(skb->data + ii));
 //           printk("\n");
 //	    }
 
-    }
+	}
 
 	skb->data += cbHeaderOffset;
 	skb->tail += cbHeaderOffset;
-    skb_put(skb, FrameSize);
-    skb->protocol=eth_type_trans(skb, skb->dev);
+	skb_put(skb, FrameSize);
+	skb->protocol = eth_type_trans(skb, skb->dev);
 
 
 	//drop frame not met IEEE 802.3
 /*
-	if (pDevice->flags & DEVICE_FLAGS_VAL_PKT_LEN) {
-		if ((skb->protocol==htons(ETH_P_802_3)) &&
-			(skb->len!=htons(skb->mac.ethernet->h_proto))) {
-			pStats->rx_length_errors++;
-			pStats->rx_dropped++;
-            if (bDeFragRx) {
-                if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-                    DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
-                    pDevice->dev->name);
-                }
-            }
-			return false;
-		}
-	}
+  if (pDevice->flags & DEVICE_FLAGS_VAL_PKT_LEN) {
+  if ((skb->protocol==htons(ETH_P_802_3)) &&
+  (skb->len!=htons(skb->mac.ethernet->h_proto))) {
+  pStats->rx_length_errors++;
+  pStats->rx_dropped++;
+  if (bDeFragRx) {
+  if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+  DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+  pDevice->dev->name);
+  }
+  }
+  return false;
+  }
+  }
 */
 
-    skb->ip_summed=CHECKSUM_NONE;
-    pStats->rx_bytes +=skb->len;
-    pStats->rx_packets++;
-    netif_rx(skb);
+	skb->ip_summed = CHECKSUM_NONE;
+	pStats->rx_bytes += skb->len;
+	pStats->rx_packets++;
+	netif_rx(skb);
 
-    if (bDeFragRx) {
-        if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
-                pDevice->dev->name);
-        }
-        return false;
-    }
+	if (bDeFragRx) {
+		if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+			DBG_PRT(MSG_LEVEL_ERR, KERN_ERR "%s: can not alloc more frag bufs\n",
+				pDevice->dev->name);
+		}
+		return false;
+	}
 
-    return true;
+	return true;
 }
 
 
-static bool s_bAPModeRxCtl (
-    PSDevice pDevice,
-    unsigned char *pbyFrame,
-    int      iSANodeIndex
-    )
+static bool s_bAPModeRxCtl(
+	PSDevice pDevice,
+	unsigned char *pbyFrame,
+	int      iSANodeIndex
+)
 {
-    PS802_11Header      p802_11Header;
-    CMD_STATUS          Status;
-    PSMgmtObject        pMgmt = pDevice->pMgmt;
-
-
-    if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
-
-        p802_11Header = (PS802_11Header) (pbyFrame);
-        if (!IS_TYPE_MGMT(pbyFrame)) {
-
-            // Data & PS-Poll packet
-            // check frame class
-            if (iSANodeIndex > 0) {
-                // frame class 3 fliter & checking
-                if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_AUTH) {
-                    // send deauth notification
-                    // reason = (6) class 2 received from nonauth sta
-                    vMgrDeAuthenBeginSta(pDevice,
-                                         pMgmt,
-                                         (unsigned char *)(p802_11Header->abyAddr2),
-                                         (WLAN_MGMT_REASON_CLASS2_NONAUTH),
-                                         &Status
-                                         );
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 1\n");
-                    return true;
-                }
-                if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_ASSOC) {
-                    // send deassoc notification
-                    // reason = (7) class 3 received from nonassoc sta
-                    vMgrDisassocBeginSta(pDevice,
-                                         pMgmt,
-                                         (unsigned char *)(p802_11Header->abyAddr2),
-                                         (WLAN_MGMT_REASON_CLASS3_NONASSOC),
-                                         &Status
-                                         );
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDisassocBeginSta 2\n");
-                    return true;
-                }
-
-                if (pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable) {
-                    // delcare received ps-poll event
-                    if (IS_CTL_PSPOLL(pbyFrame)) {
-                        pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
-                        bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 1\n");
-                    }
-                    else {
-                        // check Data PS state
-                        // if PW bit off, send out all PS bufferring packets.
-                        if (!IS_FC_POWERMGT(pbyFrame)) {
-                            pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
-                            pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
-                            bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-                            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 2\n");
-                        }
-                    }
-                }
-                else {
-                   if (IS_FC_POWERMGT(pbyFrame)) {
-                       pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = true;
-                       // Once if STA in PS state, enable multicast bufferring
-                       pMgmt->sNodeDBTable[0].bPSEnable = true;
-                   }
-                   else {
-                      // clear all pending PS frame.
-                      if (pMgmt->sNodeDBTable[iSANodeIndex].wEnQueueCnt > 0) {
-                          pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
-                          pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
-                          bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 3\n");
-
-                      }
-                   }
-                }
-            }
-            else {
-                  vMgrDeAuthenBeginSta(pDevice,
-                                       pMgmt,
-                                       (unsigned char *)(p802_11Header->abyAddr2),
-                                       (WLAN_MGMT_REASON_CLASS2_NONAUTH),
-                                       &Status
-                                       );
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 3\n");
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "BSSID:%pM\n",
-				p802_11Header->abyAddr3);
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR2:%pM\n",
-				p802_11Header->abyAddr2);
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR1:%pM\n",
-				p802_11Header->abyAddr1);
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: wFrameCtl= %x\n", p802_11Header->wFrameCtl );
-                    VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc:pDevice->byRxMode = %x\n", pDevice->byRxMode );
-                    return true;
-            }
-        }
-    }
-    return false;
+	PS802_11Header      p802_11Header;
+	CMD_STATUS          Status;
+	PSMgmtObject        pMgmt = pDevice->pMgmt;
+
+
+	if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
+
+		p802_11Header = (PS802_11Header)(pbyFrame);
+		if (!IS_TYPE_MGMT(pbyFrame)) {
+
+			// Data & PS-Poll packet
+			// check frame class
+			if (iSANodeIndex > 0) {
+				// frame class 3 fliter & checking
+				if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_AUTH) {
+					// send deauth notification
+					// reason = (6) class 2 received from nonauth sta
+					vMgrDeAuthenBeginSta(pDevice,
+							     pMgmt,
+							     (unsigned char *)(p802_11Header->abyAddr2),
+							     (WLAN_MGMT_REASON_CLASS2_NONAUTH),
+							     &Status
+);
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 1\n");
+					return true;
+				}
+				if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_ASSOC) {
+					// send deassoc notification
+					// reason = (7) class 3 received from nonassoc sta
+					vMgrDisassocBeginSta(pDevice,
+							     pMgmt,
+							     (unsigned char *)(p802_11Header->abyAddr2),
+							     (WLAN_MGMT_REASON_CLASS3_NONASSOC),
+							     &Status
+);
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDisassocBeginSta 2\n");
+					return true;
+				}
+
+				if (pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable) {
+					// delcare received ps-poll event
+					if (IS_CTL_PSPOLL(pbyFrame)) {
+						pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
+						bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
+						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 1\n");
+					}
+					else {
+						// check Data PS state
+						// if PW bit off, send out all PS bufferring packets.
+						if (!IS_FC_POWERMGT(pbyFrame)) {
+							pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
+							pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
+							bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
+							DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 2\n");
+						}
+					}
+				}
+				else {
+					if (IS_FC_POWERMGT(pbyFrame)) {
+						pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = true;
+						// Once if STA in PS state, enable multicast bufferring
+						pMgmt->sNodeDBTable[0].bPSEnable = true;
+					}
+					else {
+						// clear all pending PS frame.
+						if (pMgmt->sNodeDBTable[iSANodeIndex].wEnQueueCnt > 0) {
+							pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
+							pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
+							bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
+							DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 3\n");
+
+						}
+					}
+				}
+			}
+			else {
+				vMgrDeAuthenBeginSta(pDevice,
+						     pMgmt,
+						     (unsigned char *)(p802_11Header->abyAddr2),
+						     (WLAN_MGMT_REASON_CLASS2_NONAUTH),
+						     &Status
+);
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 3\n");
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "BSSID:%pM\n",
+					p802_11Header->abyAddr3);
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR2:%pM\n",
+					p802_11Header->abyAddr2);
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR1:%pM\n",
+					p802_11Header->abyAddr1);
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: wFrameCtl= %x\n", p802_11Header->wFrameCtl);
+				VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc:pDevice->byRxMode = %x\n", pDevice->byRxMode);
+				return true;
+			}
+		}
+	}
+	return false;
 
 }
 
-static bool s_bHandleRxEncryption (
-    PSDevice     pDevice,
-    unsigned char *pbyFrame,
-    unsigned int FrameSize,
-    unsigned char *pbyRsr,
-    unsigned char *pbyNewRsr,
-    PSKeyItem   *pKeyOut,
-    bool *pbExtIV,
-    unsigned short *pwRxTSC15_0,
-    unsigned long *pdwRxTSC47_16
-    )
+static bool s_bHandleRxEncryption(
+	PSDevice     pDevice,
+	unsigned char *pbyFrame,
+	unsigned int FrameSize,
+	unsigned char *pbyRsr,
+	unsigned char *pbyNewRsr,
+	PSKeyItem   *pKeyOut,
+	bool *pbExtIV,
+	unsigned short *pwRxTSC15_0,
+	unsigned long *pdwRxTSC47_16
+)
 {
-    unsigned int PayloadLen = FrameSize;
-    unsigned char *pbyIV;
-    unsigned char byKeyIdx;
-    PSKeyItem       pKey = NULL;
-    unsigned char byDecMode = KEY_CTL_WEP;
-    PSMgmtObject    pMgmt = pDevice->pMgmt;
-
-
-    *pwRxTSC15_0 = 0;
-    *pdwRxTSC47_16 = 0;
-
-    pbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;
-    if ( WLAN_GET_FC_TODS(*(unsigned short *)pbyFrame) &&
-         WLAN_GET_FC_FROMDS(*(unsigned short *)pbyFrame) ) {
-         pbyIV += 6;             // 6 is 802.11 address4
-         PayloadLen -= 6;
-    }
-    byKeyIdx = (*(pbyIV+3) & 0xc0);
-    byKeyIdx >>= 6;
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"\nKeyIdx: %d\n", byKeyIdx);
-
-    if ((pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||
-        (pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||
-        (pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||
-        (pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||
-        (pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {
-        if (((*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) &&
-            (pDevice->pMgmt->byCSSPK != KEY_CTL_NONE)) {
-            // unicast pkt use pairwise key
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt\n");
-            if (KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, 0xFFFFFFFF, &pKey) == true) {
-                if (pDevice->pMgmt->byCSSPK == KEY_CTL_TKIP)
-                    byDecMode = KEY_CTL_TKIP;
-                else if (pDevice->pMgmt->byCSSPK == KEY_CTL_CCMP)
-                    byDecMode = KEY_CTL_CCMP;
-            }
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt: %d, %p\n", byDecMode, pKey);
-        } else {
-            // use group key
-            KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, byKeyIdx, &pKey);
-            if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
-                byDecMode = KEY_CTL_TKIP;
-            else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
-                byDecMode = KEY_CTL_CCMP;
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"group pkt: %d, %d, %p\n", byKeyIdx, byDecMode, pKey);
-        }
-    }
-    // our WEP only support Default Key
-    if (pKey == NULL) {
-        // use default group key
-        KeybGetKey(&(pDevice->sKey), pDevice->abyBroadcastAddr, byKeyIdx, &pKey);
-        if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
-            byDecMode = KEY_CTL_TKIP;
-        else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
-            byDecMode = KEY_CTL_CCMP;
-    }
-    *pKeyOut = pKey;
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
-
-    if (pKey == NULL) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey == NULL\n");
-        if (byDecMode == KEY_CTL_WEP) {
+	unsigned int PayloadLen = FrameSize;
+	unsigned char *pbyIV;
+	unsigned char byKeyIdx;
+	PSKeyItem       pKey = NULL;
+	unsigned char byDecMode = KEY_CTL_WEP;
+	PSMgmtObject    pMgmt = pDevice->pMgmt;
+
+
+	*pwRxTSC15_0 = 0;
+	*pdwRxTSC47_16 = 0;
+
+	pbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;
+	if (WLAN_GET_FC_TODS(*(unsigned short *)pbyFrame) &&
+	    WLAN_GET_FC_FROMDS(*(unsigned short *)pbyFrame)) {
+		pbyIV += 6;             // 6 is 802.11 address4
+		PayloadLen -= 6;
+	}
+	byKeyIdx = (*(pbyIV+3) & 0xc0);
+	byKeyIdx >>= 6;
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "\nKeyIdx: %d\n", byKeyIdx);
+
+	if ((pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||
+	    (pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||
+	    (pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||
+	    (pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||
+	    (pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {
+		if (((*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) &&
+		    (pDevice->pMgmt->byCSSPK != KEY_CTL_NONE)) {
+			// unicast pkt use pairwise key
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "unicast pkt\n");
+			if (KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, 0xFFFFFFFF, &pKey) == true) {
+				if (pDevice->pMgmt->byCSSPK == KEY_CTL_TKIP)
+					byDecMode = KEY_CTL_TKIP;
+				else if (pDevice->pMgmt->byCSSPK == KEY_CTL_CCMP)
+					byDecMode = KEY_CTL_CCMP;
+			}
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "unicast pkt: %d, %p\n", byDecMode, pKey);
+		} else {
+			// use group key
+			KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, byKeyIdx, &pKey);
+			if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
+				byDecMode = KEY_CTL_TKIP;
+			else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
+				byDecMode = KEY_CTL_CCMP;
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "group pkt: %d, %d, %p\n", byKeyIdx, byDecMode, pKey);
+		}
+	}
+	// our WEP only support Default Key
+	if (pKey == NULL) {
+		// use default group key
+		KeybGetKey(&(pDevice->sKey), pDevice->abyBroadcastAddr, byKeyIdx, &pKey);
+		if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
+			byDecMode = KEY_CTL_TKIP;
+		else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
+			byDecMode = KEY_CTL_CCMP;
+	}
+	*pKeyOut = pKey;
+
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
+
+	if (pKey == NULL) {
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pKey == NULL\n");
+		if (byDecMode == KEY_CTL_WEP) {
 //            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
-        } else if (pDevice->bLinkPass == true) {
+		} else if (pDevice->bLinkPass == true) {
 //            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
-        }
-        return false;
-    }
-    if (byDecMode != pKey->byCipherSuite) {
-        if (byDecMode == KEY_CTL_WEP) {
+		}
+		return false;
+	}
+	if (byDecMode != pKey->byCipherSuite) {
+		if (byDecMode == KEY_CTL_WEP) {
 //            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
-        } else if (pDevice->bLinkPass == true) {
+		} else if (pDevice->bLinkPass == true) {
 //            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
-        }
-        *pKeyOut = NULL;
-        return false;
-    }
-    if (byDecMode == KEY_CTL_WEP) {
-        // handle WEP
-        if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
-            (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true)) {
-            // Software WEP
-            // 1. 3253A
-            // 2. WEP 256
-
-            PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); // 24 is 802.11 header,4 is IV, 4 is crc
-            memcpy(pDevice->abyPRNG, pbyIV, 3);
-            memcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
-            rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
-            rc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);
-
-            if (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen)) {
-                *pbyNewRsr |= NEWRSR_DECRYPTOK;
-            }
-        }
-    } else if ((byDecMode == KEY_CTL_TKIP) ||
-               (byDecMode == KEY_CTL_CCMP)) {
-        // TKIP/AES
-
-        PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
-        *pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);
-        if (byDecMode == KEY_CTL_TKIP) {
-            *pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
-        } else {
-            *pwRxTSC15_0 = cpu_to_le16(*(unsigned short *)pbyIV);
-        }
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);
-
-        if ((byDecMode == KEY_CTL_TKIP) &&
-            (pDevice->byLocalID <= REV_ID_VT3253_A1)) {
-            // Software TKIP
-            // 1. 3253 A
-            PS802_11Header  pMACHeader = (PS802_11Header) (pbyFrame);
-            TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
-            rc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);
-            rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);
-            if (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {
-                *pbyNewRsr |= NEWRSR_DECRYPTOK;
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV OK!\n");
-            } else {
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV FAIL!!!\n");
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"PayloadLen = %d\n", PayloadLen);
-            }
-        }
-    }// end of TKIP/AES
-
-    if ((*(pbyIV+3) & 0x20) != 0)
-        *pbExtIV = true;
-    return true;
+		}
+		*pKeyOut = NULL;
+		return false;
+	}
+	if (byDecMode == KEY_CTL_WEP) {
+		// handle WEP
+		if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
+		    (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true)) {
+			// Software WEP
+			// 1. 3253A
+			// 2. WEP 256
+
+			PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); // 24 is 802.11 header,4 is IV, 4 is crc
+			memcpy(pDevice->abyPRNG, pbyIV, 3);
+			memcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
+			rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
+			rc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);
+
+			if (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen)) {
+				*pbyNewRsr |= NEWRSR_DECRYPTOK;
+			}
+		}
+	} else if ((byDecMode == KEY_CTL_TKIP) ||
+		   (byDecMode == KEY_CTL_CCMP)) {
+		// TKIP/AES
+
+		PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
+		*pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ExtIV: %lx\n", *pdwRxTSC47_16);
+		if (byDecMode == KEY_CTL_TKIP) {
+			*pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV + 2), *pbyIV));
+		} else {
+			*pwRxTSC15_0 = cpu_to_le16(*(unsigned short *)pbyIV);
+		}
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "TSC0_15: %x\n", *pwRxTSC15_0);
+
+		if ((byDecMode == KEY_CTL_TKIP) &&
+		    (pDevice->byLocalID <= REV_ID_VT3253_A1)) {
+			// Software TKIP
+			// 1. 3253 A
+			PS802_11Header  pMACHeader = (PS802_11Header)(pbyFrame);
+			TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
+			rc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);
+			rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);
+			if (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {
+				*pbyNewRsr |= NEWRSR_DECRYPTOK;
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ICV OK!\n");
+			} else {
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ICV FAIL!!!\n");
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "PayloadLen = %d\n", PayloadLen);
+			}
+		}
+	}// end of TKIP/AES
+
+	if ((*(pbyIV+3) & 0x20) != 0)
+		*pbExtIV = true;
+	return true;
 }
 
 
-static bool s_bHostWepRxEncryption (
-    PSDevice     pDevice,
-    unsigned char *pbyFrame,
-    unsigned int FrameSize,
-    unsigned char *pbyRsr,
-    bool bOnFly,
-    PSKeyItem    pKey,
-    unsigned char *pbyNewRsr,
-    bool *pbExtIV,
-    unsigned short *pwRxTSC15_0,
-    unsigned long *pdwRxTSC47_16
-    )
+static bool s_bHostWepRxEncryption(
+	PSDevice     pDevice,
+	unsigned char *pbyFrame,
+	unsigned int FrameSize,
+	unsigned char *pbyRsr,
+	bool bOnFly,
+	PSKeyItem    pKey,
+	unsigned char *pbyNewRsr,
+	bool *pbExtIV,
+	unsigned short *pwRxTSC15_0,
+	unsigned long *pdwRxTSC47_16
+)
 {
-    unsigned int PayloadLen = FrameSize;
-    unsigned char *pbyIV;
-    unsigned char byKeyIdx;
-    unsigned char byDecMode = KEY_CTL_WEP;
-    PS802_11Header  pMACHeader;
+	unsigned int PayloadLen = FrameSize;
+	unsigned char *pbyIV;
+	unsigned char byKeyIdx;
+	unsigned char byDecMode = KEY_CTL_WEP;
+	PS802_11Header  pMACHeader;
 
 
 
-    *pwRxTSC15_0 = 0;
-    *pdwRxTSC47_16 = 0;
+	*pwRxTSC15_0 = 0;
+	*pdwRxTSC47_16 = 0;
 
-    pbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;
-    if ( WLAN_GET_FC_TODS(*(unsigned short *)pbyFrame) &&
-         WLAN_GET_FC_FROMDS(*(unsigned short *)pbyFrame) ) {
-         pbyIV += 6;             // 6 is 802.11 address4
-         PayloadLen -= 6;
-    }
-    byKeyIdx = (*(pbyIV+3) & 0xc0);
-    byKeyIdx >>= 6;
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"\nKeyIdx: %d\n", byKeyIdx);
+	pbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;
+	if (WLAN_GET_FC_TODS(*(unsigned short *)pbyFrame) &&
+	    WLAN_GET_FC_FROMDS(*(unsigned short *)pbyFrame)) {
+		pbyIV += 6;             // 6 is 802.11 address4
+		PayloadLen -= 6;
+	}
+	byKeyIdx = (*(pbyIV+3) & 0xc0);
+	byKeyIdx >>= 6;
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "\nKeyIdx: %d\n", byKeyIdx);
 
 
-    if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
-        byDecMode = KEY_CTL_TKIP;
-    else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
-        byDecMode = KEY_CTL_CCMP;
+	if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
+		byDecMode = KEY_CTL_TKIP;
+	else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
+		byDecMode = KEY_CTL_CCMP;
 
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
+	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
 
-    if (byDecMode != pKey->byCipherSuite) {
-        if (byDecMode == KEY_CTL_WEP) {
+	if (byDecMode != pKey->byCipherSuite) {
+		if (byDecMode == KEY_CTL_WEP) {
 //            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
-        } else if (pDevice->bLinkPass == true) {
+		} else if (pDevice->bLinkPass == true) {
 //            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
-        }
-        return false;
-    }
-
-    if (byDecMode == KEY_CTL_WEP) {
-        // handle WEP
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"byDecMode == KEY_CTL_WEP \n");
-        if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
-            (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true) ||
-            (bOnFly == false)) {
-            // Software WEP
-            // 1. 3253A
-            // 2. WEP 256
-            // 3. NotOnFly
-
-            PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); // 24 is 802.11 header,4 is IV, 4 is crc
-            memcpy(pDevice->abyPRNG, pbyIV, 3);
-            memcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
-            rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
-            rc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);
-
-            if (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen)) {
-                *pbyNewRsr |= NEWRSR_DECRYPTOK;
-            }
-        }
-    } else if ((byDecMode == KEY_CTL_TKIP) ||
-               (byDecMode == KEY_CTL_CCMP)) {
-        // TKIP/AES
-
-        PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
-        *pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);
-
-        if (byDecMode == KEY_CTL_TKIP) {
-            *pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
-        } else {
-            *pwRxTSC15_0 = cpu_to_le16(*(unsigned short *)pbyIV);
-        }
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);
-
-        if (byDecMode == KEY_CTL_TKIP) {
-
-            if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || (bOnFly == false)) {
-                // Software TKIP
-                // 1. 3253 A
-                // 2. NotOnFly
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_TKIP \n");
-                pMACHeader = (PS802_11Header) (pbyFrame);
-                TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
-                rc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);
-                rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);
-                if (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {
-                    *pbyNewRsr |= NEWRSR_DECRYPTOK;
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV OK!\n");
-                } else {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV FAIL!!!\n");
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"PayloadLen = %d\n", PayloadLen);
-                }
-            }
-        }
-
-        if (byDecMode == KEY_CTL_CCMP) {
-            if (bOnFly == false) {
-                // Software CCMP
-                // NotOnFly
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_CCMP\n");
-                if (AESbGenCCMP(pKey->abyKey, pbyFrame, FrameSize)) {
-                    *pbyNewRsr |= NEWRSR_DECRYPTOK;
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CCMP MIC compare OK!\n");
-                } else {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CCMP MIC fail!\n");
-                }
-            }
-        }
-
-    }// end of TKIP/AES
-
-    if ((*(pbyIV+3) & 0x20) != 0)
-        *pbExtIV = true;
-    return true;
+		}
+		return false;
+	}
+
+	if (byDecMode == KEY_CTL_WEP) {
+		// handle WEP
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "byDecMode == KEY_CTL_WEP \n");
+		if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
+		    (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true) ||
+		    (bOnFly == false)) {
+			// Software WEP
+			// 1. 3253A
+			// 2. WEP 256
+			// 3. NotOnFly
+
+			PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); // 24 is 802.11 header,4 is IV, 4 is crc
+			memcpy(pDevice->abyPRNG, pbyIV, 3);
+			memcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
+			rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
+			rc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);
+
+			if (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen)) {
+				*pbyNewRsr |= NEWRSR_DECRYPTOK;
+			}
+		}
+	} else if ((byDecMode == KEY_CTL_TKIP) ||
+		   (byDecMode == KEY_CTL_CCMP)) {
+		// TKIP/AES
+
+		PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
+		*pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ExtIV: %lx\n", *pdwRxTSC47_16);
+
+		if (byDecMode == KEY_CTL_TKIP) {
+			*pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
+		} else {
+			*pwRxTSC15_0 = cpu_to_le16(*(unsigned short *)pbyIV);
+		}
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "TSC0_15: %x\n", *pwRxTSC15_0);
+
+		if (byDecMode == KEY_CTL_TKIP) {
+
+			if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || (bOnFly == false)) {
+				// Software TKIP
+				// 1. 3253 A
+				// 2. NotOnFly
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "soft KEY_CTL_TKIP \n");
+				pMACHeader = (PS802_11Header)(pbyFrame);
+				TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
+				rc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);
+				rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);
+				if (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {
+					*pbyNewRsr |= NEWRSR_DECRYPTOK;
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ICV OK!\n");
+				} else {
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ICV FAIL!!!\n");
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "PayloadLen = %d\n", PayloadLen);
+				}
+			}
+		}
+
+		if (byDecMode == KEY_CTL_CCMP) {
+			if (bOnFly == false) {
+				// Software CCMP
+				// NotOnFly
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "soft KEY_CTL_CCMP\n");
+				if (AESbGenCCMP(pKey->abyKey, pbyFrame, FrameSize)) {
+					*pbyNewRsr |= NEWRSR_DECRYPTOK;
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "CCMP MIC compare OK!\n");
+				} else {
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "CCMP MIC fail!\n");
+				}
+			}
+		}
+
+	}// end of TKIP/AES
+
+	if ((*(pbyIV+3) & 0x20) != 0)
+		*pbExtIV = true;
+	return true;
 }
 
 
 
-static bool s_bAPModeRxData (
-    PSDevice pDevice,
-    struct sk_buff* skb,
-    unsigned int FrameSize,
-    unsigned int cbHeaderOffset,
-    int      iSANodeIndex,
-    int      iDANodeIndex
-    )
+static bool s_bAPModeRxData(
+	PSDevice pDevice,
+	struct sk_buff *skb,
+	unsigned int FrameSize,
+	unsigned int cbHeaderOffset,
+	int      iSANodeIndex,
+	int      iDANodeIndex
+)
 {
-    PSMgmtObject        pMgmt = pDevice->pMgmt;
-    bool bRelayAndForward = false;
-    bool bRelayOnly = false;
-    unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
-    unsigned short wAID;
-
-
-    struct sk_buff* skbcpy = NULL;
-
-    if (FrameSize > CB_MAX_BUF_SIZE)
-        return false;
-    // check DA
-    if(is_multicast_ether_addr((unsigned char *)(skb->data+cbHeaderOffset))) {
-       if (pMgmt->sNodeDBTable[0].bPSEnable) {
-
-           skbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);
-
-        // if any node in PS mode, buffer packet until DTIM.
-           if (skbcpy == NULL) {
-               DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");
-           }
-           else {
-               skbcpy->dev = pDevice->dev;
-               skbcpy->len = FrameSize;
-               memcpy(skbcpy->data, skb->data+cbHeaderOffset, FrameSize);
-               skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skbcpy);
-
-               pMgmt->sNodeDBTable[0].wEnQueueCnt++;
-               // set tx map
-               pMgmt->abyPSTxMap[0] |= byMask[0];
-           }
-       }
-       else {
-           bRelayAndForward = true;
-       }
-    }
-    else {
-        // check if relay
-        if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data+cbHeaderOffset), &iDANodeIndex)) {
-            if (pMgmt->sNodeDBTable[iDANodeIndex].eNodeState >= NODE_ASSOC) {
-                if (pMgmt->sNodeDBTable[iDANodeIndex].bPSEnable) {
-                    // queue this skb until next PS tx, and then release.
-
-	                skb->data += cbHeaderOffset;
-	                skb->tail += cbHeaderOffset;
-                    skb_put(skb, FrameSize);
-                    skb_queue_tail(&pMgmt->sNodeDBTable[iDANodeIndex].sTxPSQueue, skb);
-                    pMgmt->sNodeDBTable[iDANodeIndex].wEnQueueCnt++;
-                    wAID = pMgmt->sNodeDBTable[iDANodeIndex].wAID;
-                    pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "relay: index= %d, pMgmt->abyPSTxMap[%d]= %d\n",
-                               iDANodeIndex, (wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);
-                    return true;
-                }
-                else {
-                    bRelayOnly = true;
-                }
-            }
-        }
-    }
-
-    if (bRelayOnly || bRelayAndForward) {
-        // relay this packet right now
-        if (bRelayAndForward)
-            iDANodeIndex = 0;
-
-        if ((pDevice->uAssocCount > 1) && (iDANodeIndex >= 0)) {
-            ROUTEbRelay(pDevice, (unsigned char *)(skb->data + cbHeaderOffset), FrameSize, (unsigned int)iDANodeIndex);
-        }
-
-        if (bRelayOnly)
-            return false;
-    }
-    // none associate, don't forward
-    if (pDevice->uAssocCount == 0)
-        return false;
-
-    return true;
+	PSMgmtObject        pMgmt = pDevice->pMgmt;
+	bool bRelayAndForward = false;
+	bool bRelayOnly = false;
+	unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
+	unsigned short wAID;
+
+
+	struct sk_buff *skbcpy = NULL;
+
+	if (FrameSize > CB_MAX_BUF_SIZE)
+		return false;
+	// check DA
+	if (is_multicast_ether_addr((unsigned char *)(skb->data+cbHeaderOffset))) {
+		if (pMgmt->sNodeDBTable[0].bPSEnable) {
+
+			skbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);
+
+			// if any node in PS mode, buffer packet until DTIM.
+			if (skbcpy == NULL) {
+				DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");
+			}
+			else {
+				skbcpy->dev = pDevice->dev;
+				skbcpy->len = FrameSize;
+				memcpy(skbcpy->data, skb->data+cbHeaderOffset, FrameSize);
+				skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skbcpy);
+
+				pMgmt->sNodeDBTable[0].wEnQueueCnt++;
+				// set tx map
+				pMgmt->abyPSTxMap[0] |= byMask[0];
+			}
+		}
+		else {
+			bRelayAndForward = true;
+		}
+	}
+	else {
+		// check if relay
+		if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data+cbHeaderOffset), &iDANodeIndex)) {
+			if (pMgmt->sNodeDBTable[iDANodeIndex].eNodeState >= NODE_ASSOC) {
+				if (pMgmt->sNodeDBTable[iDANodeIndex].bPSEnable) {
+					// queue this skb until next PS tx, and then release.
+
+					skb->data += cbHeaderOffset;
+					skb->tail += cbHeaderOffset;
+					skb_put(skb, FrameSize);
+					skb_queue_tail(&pMgmt->sNodeDBTable[iDANodeIndex].sTxPSQueue, skb);
+					pMgmt->sNodeDBTable[iDANodeIndex].wEnQueueCnt++;
+					wAID = pMgmt->sNodeDBTable[iDANodeIndex].wAID;
+					pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "relay: index= %d, pMgmt->abyPSTxMap[%d]= %d\n",
+						iDANodeIndex, (wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);
+					return true;
+				}
+				else {
+					bRelayOnly = true;
+				}
+			}
+		}
+	}
+
+	if (bRelayOnly || bRelayAndForward) {
+		// relay this packet right now
+		if (bRelayAndForward)
+			iDANodeIndex = 0;
+
+		if ((pDevice->uAssocCount > 1) && (iDANodeIndex >= 0)) {
+			ROUTEbRelay(pDevice, (unsigned char *)(skb->data + cbHeaderOffset), FrameSize, (unsigned int)iDANodeIndex);
+		}
+
+		if (bRelayOnly)
+			return false;
+	}
+	// none associate, don't forward
+	if (pDevice->uAssocCount == 0)
+		return false;
+
+	return true;
 }
 

commit 789d1aef176e720fce4a8a5a9ab07f093ddb9086
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Aug 20 08:43:13 2012 -0700

    staging: "vt6655" Fix typos in comments.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index e8a71ba4b92c..373e9e4fc87d 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -718,7 +718,7 @@ device_receive_frame (
     if ((*pbyRSSI != 0) &&
         (pMgmt->pCurrBSS!=NULL)) {
         RFvRSSITodBm(pDevice, *pbyRSSI, &ldBm);
-        // Moniter if RSSI is too strong.
+        // Monitor if RSSI is too strong.
         pMgmt->pCurrBSS->byRSSIStatCnt++;
         pMgmt->pCurrBSS->byRSSIStatCnt %= RSSI_STAT_COUNT;
         pMgmt->pCurrBSS->ldBmAverage[pMgmt->pCurrBSS->byRSSIStatCnt] = ldBm;

commit 27e3b90153c52f79beede1dd5eb51db326a5d8a9
Author: Marcos Paulo de Souza <marcos.souza.org@gmail.com>
Date:   Sun Jul 8 23:51:25 2012 -0300

    staging: vt6655: Remove all commented macros
    
    These macros were reported by forgotten-macros tool
    (https://github.com/marcosps/forgotten_macros).
    
    Signed-off-by: Marcos Paulo de Souza <marcos.souza.org@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index c0fab4bc8702..e8a71ba4b92c 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -55,7 +55,6 @@
 #include "iowpa.h"
 #include "aes_ccmp.h"
 
-//#define	PLICE_DEBUG
 
 
 /*---------------------  Static Definitions -------------------------*/

commit 30d6a2b870a2419e1e887bd3a46f33d98c61c778
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jul 26 10:35:30 2011 +0300

    staging: vt6655: simplify MAC printing by using %pM
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index cf0deacd9da7..c0fab4bc8702 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -1107,30 +1107,12 @@ static bool s_bAPModeRxCtl (
                                        &Status
                                        );
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 3\n");
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "BSSID:%02x-%02x-%02x=%02x-%02x-%02x \n",
-                                p802_11Header->abyAddr3[0],
-                                p802_11Header->abyAddr3[1],
-                                p802_11Header->abyAddr3[2],
-                                p802_11Header->abyAddr3[3],
-                                p802_11Header->abyAddr3[4],
-                                p802_11Header->abyAddr3[5]
-                               );
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR2:%02x-%02x-%02x=%02x-%02x-%02x \n",
-                                p802_11Header->abyAddr2[0],
-                                p802_11Header->abyAddr2[1],
-                                p802_11Header->abyAddr2[2],
-                                p802_11Header->abyAddr2[3],
-                                p802_11Header->abyAddr2[4],
-                                p802_11Header->abyAddr2[5]
-                               );
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR1:%02x-%02x-%02x=%02x-%02x-%02x \n",
-                                p802_11Header->abyAddr1[0],
-                                p802_11Header->abyAddr1[1],
-                                p802_11Header->abyAddr1[2],
-                                p802_11Header->abyAddr1[3],
-                                p802_11Header->abyAddr1[4],
-                                p802_11Header->abyAddr1[5]
-                               );
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "BSSID:%pM\n",
+				p802_11Header->abyAddr3);
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR2:%pM\n",
+				p802_11Header->abyAddr2);
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR1:%pM\n",
+				p802_11Header->abyAddr1);
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: wFrameCtl= %x\n", p802_11Header->wFrameCtl );
                     VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc:pDevice->byRxMode = %x\n", pDevice->byRxMode );

commit 9fc86028fa21f8831c0fdc701732cf491da1202c
Author: Joe Perches <joe@perches.com>
Date:   Sun Apr 10 14:31:32 2011 -0700

    staging: Remove unnecessary semicolons when if (foo) {...};
    
    Done via perl script:
    
    $ cat remove_semi_if.pl
    my $match_balanced_parentheses = qr/(\((?:[^\(\)]++|(?-1))*\))/;
    my $match_balanced_braces      = qr/(\{(?:[^\{\}]++|(?-1))*\})/;
    
    foreach my $file (@ARGV) {
        my $f;
        my $text;
        my $oldtext;
    
        next if ((-d $file));
    
        open($f, '<', $file)
            or die "$P: Can't open $file for read\n";
        $oldtext = do { local($/) ; <$f> };
        close($f);
    
        next if ($oldtext eq "");
    
        $text = $oldtext;
    
        my $count = 0;
        do {
            $count = 0;
            $count += $text =~ s@\b(if\s*${match_balanced_parentheses}\s*)${match_balanced_braces}\s*;@"$1$3"@egx;
        } while ($count > 0);
    
        if ($text ne $oldtext) {
            my $newfile = $file;
    
            open($f, '>', $newfile)
                or die "$P: Can't open $newfile for write\n";
            print $f $text;
            close($f);
        }
    }
    
    $
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 15130733693e..cf0deacd9da7 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -700,7 +700,7 @@ device_receive_frame (
                 pDevice->pMgmt->bInTIMWake = false;
             }
         }
-    };
+    }
 
     // Now it only supports 802.11g Infrastructure Mode, and support rate must up to 54 Mbps
     if (pDevice->bDiversityEnable && (FrameSize>50) &&
@@ -884,7 +884,7 @@ device_receive_frame (
                      memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
                      netif_rx(pDevice->skb);
                      pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-                 };
+                 }
 
                 return false;
 
@@ -1049,7 +1049,7 @@ static bool s_bAPModeRxCtl (
                                          );
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 1\n");
                     return true;
-                };
+                }
                 if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_ASSOC) {
                     // send deassoc notification
                     // reason = (7) class 3 received from nonassoc sta
@@ -1061,7 +1061,7 @@ static bool s_bAPModeRxCtl (
                                          );
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDisassocBeginSta 2\n");
                     return true;
-                };
+                }
 
                 if (pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable) {
                     // delcare received ps-poll event
@@ -1486,7 +1486,7 @@ static bool s_bAPModeRxData (
                     bRelayOnly = true;
                 }
             }
-        };
+        }
     }
 
     if (bRelayOnly || bRelayAndForward) {

commit 7b6a001313a9b11a1f0985de05fff514db41d72d
Author: Charles Clément <caratorn@gmail.com>
Date:   Sun Aug 1 17:15:50 2010 +0200

    Staging: vt6655: replace BOOL with in kernel bool
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 7ffd1b4d740c..15130733693e 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -85,10 +85,10 @@ s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
 
 static void
 s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
-		unsigned int cbPacketSize, BOOL bIsWEP, BOOL bExtIV,
+		unsigned int cbPacketSize, bool bIsWEP, bool bExtIV,
 		unsigned int *pcbHeadSize);
 
-static BOOL s_bAPModeRxCtl(
+static bool s_bAPModeRxCtl(
     PSDevice pDevice,
     unsigned char *pbyFrame,
     int      iSANodeIndex
@@ -96,7 +96,7 @@ static BOOL s_bAPModeRxCtl(
 
 
 
-static BOOL s_bAPModeRxData (
+static bool s_bAPModeRxData (
     PSDevice pDevice,
     struct sk_buff* skb,
     unsigned int FrameSize,
@@ -106,28 +106,28 @@ static BOOL s_bAPModeRxData (
     );
 
 
-static BOOL s_bHandleRxEncryption(
+static bool s_bHandleRxEncryption(
     PSDevice     pDevice,
     unsigned char *pbyFrame,
     unsigned int FrameSize,
     unsigned char *pbyRsr,
     unsigned char *pbyNewRsr,
     PSKeyItem   *pKeyOut,
-    int *       pbExtIV,
+    bool *pbExtIV,
     unsigned short *pwRxTSC15_0,
     unsigned long *pdwRxTSC47_16
     );
 
-static BOOL s_bHostWepRxEncryption(
+static bool s_bHostWepRxEncryption(
 
     PSDevice     pDevice,
     unsigned char *pbyFrame,
     unsigned int FrameSize,
     unsigned char *pbyRsr,
-    BOOL         bOnFly,
+    bool bOnFly,
     PSKeyItem    pKey,
     unsigned char *pbyNewRsr,
-    int *       pbExtIV,
+    bool *pbExtIV,
     unsigned short *pwRxTSC15_0,
     unsigned long *pdwRxTSC47_16
 
@@ -154,7 +154,7 @@ static BOOL s_bHostWepRxEncryption(
 -*/
 static void
 s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
-		unsigned int cbPacketSize, BOOL bIsWEP, BOOL bExtIV,
+		unsigned int cbPacketSize, bool bIsWEP, bool bExtIV,
 		unsigned int *pcbHeadSize)
 {
     unsigned char *pbyRxBuffer;
@@ -313,7 +313,7 @@ void	MngWorkItem(void *Context)
 
 
 
-BOOL
+bool
 device_receive_frame (
     PSDevice pDevice,
     PSRxDesc pCurrRD
@@ -335,8 +335,8 @@ device_receive_frame (
     PQWORD          pqwTSFTime;
     unsigned short *pwFrameSize;
     unsigned char *pbyFrame;
-    BOOL            bDeFragRx = false;
-    BOOL            bIsWEP = false;
+    bool bDeFragRx = false;
+    bool bIsWEP = false;
     unsigned int cbHeaderOffset;
     unsigned int FrameSize;
     unsigned short wEtherType = 0;
@@ -344,7 +344,7 @@ device_receive_frame (
     int             iDANodeIndex = -1;
     unsigned int ii;
     unsigned int cbIVOffset;
-    BOOL            bExtIV = false;
+    bool bExtIV = false;
     unsigned char *pbyRxSts;
     unsigned char *pbyRxRate;
     unsigned char *pbySQ;
@@ -358,7 +358,7 @@ device_receive_frame (
     long            ldBm = 0;
     long            ldBmThreshold = 0;
     PS802_11Header pMACHeader;
- BOOL            bRxeapol_key = false;
+ bool bRxeapol_key = false;
 
 //    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- device_receive_frame---\n");
 
@@ -477,7 +477,7 @@ device_receive_frame (
 
 
     if (IS_FC_WEP(pbyFrame)) {
-        BOOL     bRxDecryOK = false;
+        bool bRxDecryOK = false;
 
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"rx WEP pkt\n");
         bIsWEP = true;
@@ -1018,7 +1018,7 @@ device_receive_frame (
 }
 
 
-static BOOL s_bAPModeRxCtl (
+static bool s_bAPModeRxCtl (
     PSDevice pDevice,
     unsigned char *pbyFrame,
     int      iSANodeIndex
@@ -1142,14 +1142,14 @@ static BOOL s_bAPModeRxCtl (
 
 }
 
-static BOOL s_bHandleRxEncryption (
+static bool s_bHandleRxEncryption (
     PSDevice     pDevice,
     unsigned char *pbyFrame,
     unsigned int FrameSize,
     unsigned char *pbyRsr,
     unsigned char *pbyNewRsr,
     PSKeyItem   *pKeyOut,
-    int *       pbExtIV,
+    bool *pbExtIV,
     unsigned short *pwRxTSC15_0,
     unsigned long *pdwRxTSC47_16
     )
@@ -1288,15 +1288,15 @@ static BOOL s_bHandleRxEncryption (
 }
 
 
-static BOOL s_bHostWepRxEncryption (
+static bool s_bHostWepRxEncryption (
     PSDevice     pDevice,
     unsigned char *pbyFrame,
     unsigned int FrameSize,
     unsigned char *pbyRsr,
-    BOOL         bOnFly,
+    bool bOnFly,
     PSKeyItem    pKey,
     unsigned char *pbyNewRsr,
-    int *       pbExtIV,
+    bool *pbExtIV,
     unsigned short *pwRxTSC15_0,
     unsigned long *pdwRxTSC47_16
     )
@@ -1419,7 +1419,7 @@ static BOOL s_bHostWepRxEncryption (
 
 
 
-static BOOL s_bAPModeRxData (
+static bool s_bAPModeRxData (
     PSDevice pDevice,
     struct sk_buff* skb,
     unsigned int FrameSize,
@@ -1429,8 +1429,8 @@ static BOOL s_bAPModeRxData (
     )
 {
     PSMgmtObject        pMgmt = pDevice->pMgmt;
-    BOOL                bRelayAndForward = false;
-    BOOL                bRelayOnly = false;
+    bool bRelayAndForward = false;
+    bool bRelayOnly = false;
     unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
     unsigned short wAID;
 

commit 5a5a2a6ad4aa2467bcc34fa50e85c2afc90bab05
Author: Charles Clément <caratorn@gmail.com>
Date:   Sun Aug 1 17:15:49 2010 +0200

    Staging: vt6655: replace FALSE with in kernel false
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index c6ca3bb58a7d..7ffd1b4d740c 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -335,8 +335,8 @@ device_receive_frame (
     PQWORD          pqwTSFTime;
     unsigned short *pwFrameSize;
     unsigned char *pbyFrame;
-    BOOL            bDeFragRx = FALSE;
-    BOOL            bIsWEP = FALSE;
+    BOOL            bDeFragRx = false;
+    BOOL            bIsWEP = false;
     unsigned int cbHeaderOffset;
     unsigned int FrameSize;
     unsigned short wEtherType = 0;
@@ -344,7 +344,7 @@ device_receive_frame (
     int             iDANodeIndex = -1;
     unsigned int ii;
     unsigned int cbIVOffset;
-    BOOL            bExtIV = FALSE;
+    BOOL            bExtIV = false;
     unsigned char *pbyRxSts;
     unsigned char *pbyRxRate;
     unsigned char *pbySQ;
@@ -358,7 +358,7 @@ device_receive_frame (
     long            ldBm = 0;
     long            ldBmThreshold = 0;
     PS802_11Header pMACHeader;
- BOOL            bRxeapol_key = FALSE;
+ BOOL            bRxeapol_key = false;
 
 //    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- device_receive_frame---\n");
 
@@ -379,7 +379,7 @@ device_receive_frame (
     if ((FrameSize > 2364)||(FrameSize <= 32)) {
         // Frame Size error drop this packet.
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- WRONG Length 1 \n");
-        return FALSE;
+        return false;
     }
 
     pbyRxSts = (unsigned char *) (skb->data);
@@ -397,7 +397,7 @@ device_receive_frame (
     if ((FrameSize > 2346)|(FrameSize < 14)) { // Max: 2312Payload + 30HD +4CRC
                                                // Min: 14 bytes ACK
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- WRONG Length 2 \n");
-        return FALSE;
+        return false;
     }
 //PLICE_DEBUG->
 #if 1
@@ -440,13 +440,13 @@ device_receive_frame (
             ii--;
         }
         pDevice->dwRPIs[ii] += dwDuration;
-        return FALSE;
+        return false;
     }
 
     if (!is_multicast_ether_addr(pbyFrame)) {
         if (WCTLbIsDuplicate(&(pDevice->sDupRxCache), (PS802_11Header) (skb->data + 4))) {
             pDevice->s802_11Counter.FrameDuplicateCount++;
-            return FALSE;
+            return false;
         }
     }
 
@@ -456,7 +456,7 @@ device_receive_frame (
 
     // filter packet send from myself
     if (!compare_ether_addr((unsigned char *)&(pDevice->sRxEthHeader.abySrcAddr[0]), pDevice->abyCurrentNetAddr))
-        return FALSE;
+        return false;
 
     if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) || (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)) {
         if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
@@ -471,13 +471,13 @@ device_receive_frame (
 
     if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
         if (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex) == true) {
-            return FALSE;
+            return false;
         }
     }
 
 
     if (IS_FC_WEP(pbyFrame)) {
-        BOOL     bRxDecryOK = FALSE;
+        BOOL     bRxDecryOK = false;
 
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"rx WEP pkt\n");
         bIsWEP = true;
@@ -532,11 +532,11 @@ device_receive_frame (
 //                      pDevice->s802_11Counter.WEPICVErrorCount.QuadPart++;
                     }
                 }
-                return FALSE;
+                return false;
             }
         } else {
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"WEP Func Fail\n");
-            return FALSE;
+            return false;
         }
         if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP))
             FrameSize -= 8;         // Message Integrity Code
@@ -564,13 +564,13 @@ device_receive_frame (
 
         }
         else {
-            return FALSE;
+            return false;
         }
     }
 
 
 // Management & Control frame Handle
-    if ((IS_TYPE_DATA((skb->data+4))) == FALSE) {
+    if ((IS_TYPE_DATA((skb->data+4))) == false) {
         // Handle Control & Manage Frame
 
         if (IS_TYPE_MGMT((skb->data+4))) {
@@ -635,7 +635,7 @@ device_receive_frame (
         else {
             // Control Frame
         };
-        return FALSE;
+        return false;
     }
     else {
         if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
@@ -647,12 +647,12 @@ device_receive_frame (
                         pDevice->dev->name);
                     }
                 }
-                return FALSE;
+                return false;
             }
         }
         else {
             // discard DATA packet while not associate || BSSID error
-            if ((pDevice->bLinkPass == FALSE) ||
+            if ((pDevice->bLinkPass == false) ||
                 !(*pbyRsr & RSR_BSSIDOK)) {
                 if (bDeFragRx) {
                     if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
@@ -660,7 +660,7 @@ device_receive_frame (
                         pDevice->dev->name);
                     }
                 }
-                return FALSE;
+                return false;
             }
    //mike add:station mode check eapol-key challenge--->
    	  {
@@ -697,7 +697,7 @@ device_receive_frame (
         }
         else {
             if (pDevice->pMgmt->bInTIMWake == true) {
-                pDevice->pMgmt->bInTIMWake = FALSE;
+                pDevice->pMgmt->bInTIMWake = false;
             }
         }
     };
@@ -766,7 +766,7 @@ device_receive_frame (
 }
         // check if 802.1x authorized
         if (!(pMgmt->sNodeDBTable[iSANodeIndex].dwFlags & WLAN_STA_AUTHORIZED))
-            return FALSE;
+            return false;
     }
 
 
@@ -826,7 +826,7 @@ device_receive_frame (
             if ((cpu_to_le32(*pdwMIC_L) != dwLocalMIC_L) || (cpu_to_le32(*pdwMIC_R) != dwLocalMIC_R) ||
                 (pDevice->bRxMICFail == true)) {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC comparison is fail!\n");
-                pDevice->bRxMICFail = FALSE;
+                pDevice->bRxMICFail = false;
                 //pDevice->s802_11Counter.TKIPLocalMICFailures.QuadPart++;
                 pDevice->s802_11Counter.TKIPLocalMICFailures++;
                 if (bDeFragRx) {
@@ -886,7 +886,7 @@ device_receive_frame (
                      pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
                  };
 
-                return FALSE;
+                return false;
 
             }
         }
@@ -930,7 +930,7 @@ device_receive_frame (
                                 pDevice->dev->name);
                         }
                     }
-                    return FALSE;
+                    return false;
                 }
             }
         }
@@ -949,7 +949,7 @@ device_receive_frame (
 
     // Null data, framesize = 14
     if (FrameSize < 15)
-        return FALSE;
+        return false;
 
     if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
         if (s_bAPModeRxData(pDevice,
@@ -958,7 +958,7 @@ device_receive_frame (
                             cbHeaderOffset,
                             iSANodeIndex,
                             iDANodeIndex
-                            ) == FALSE) {
+                            ) == false) {
 
             if (bDeFragRx) {
                 if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
@@ -966,10 +966,10 @@ device_receive_frame (
                     pDevice->dev->name);
                 }
             }
-            return FALSE;
+            return false;
         }
 
-//        if(pDevice->bRxMICFail == FALSE) {
+//        if(pDevice->bRxMICFail == false) {
 //           for (ii =0; ii < 100; ii++)
 //                printk(" %02x", *(skb->data + ii));
 //           printk("\n");
@@ -996,7 +996,7 @@ device_receive_frame (
                     pDevice->dev->name);
                 }
             }
-			return FALSE;
+			return false;
 		}
 	}
 */
@@ -1011,7 +1011,7 @@ device_receive_frame (
             DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
                 pDevice->dev->name);
         }
-        return FALSE;
+        return false;
     }
 
     return true;
@@ -1074,7 +1074,7 @@ static BOOL s_bAPModeRxCtl (
                         // check Data PS state
                         // if PW bit off, send out all PS bufferring packets.
                         if (!IS_FC_POWERMGT(pbyFrame)) {
-                            pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = FALSE;
+                            pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
                             pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
                             bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
                             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 2\n");
@@ -1090,7 +1090,7 @@ static BOOL s_bAPModeRxCtl (
                    else {
                       // clear all pending PS frame.
                       if (pMgmt->sNodeDBTable[iSANodeIndex].wEnQueueCnt > 0) {
-                          pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = FALSE;
+                          pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;
                           pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
                           bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
                          DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 3\n");
@@ -1138,7 +1138,7 @@ static BOOL s_bAPModeRxCtl (
             }
         }
     }
-    return FALSE;
+    return false;
 
 }
 
@@ -1221,7 +1221,7 @@ static BOOL s_bHandleRxEncryption (
         } else if (pDevice->bLinkPass == true) {
 //            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
         }
-        return FALSE;
+        return false;
     }
     if (byDecMode != pKey->byCipherSuite) {
         if (byDecMode == KEY_CTL_WEP) {
@@ -1230,7 +1230,7 @@ static BOOL s_bHandleRxEncryption (
 //            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
         }
         *pKeyOut = NULL;
-        return FALSE;
+        return false;
     }
     if (byDecMode == KEY_CTL_WEP) {
         // handle WEP
@@ -1336,7 +1336,7 @@ static BOOL s_bHostWepRxEncryption (
         } else if (pDevice->bLinkPass == true) {
 //            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
         }
-        return FALSE;
+        return false;
     }
 
     if (byDecMode == KEY_CTL_WEP) {
@@ -1344,7 +1344,7 @@ static BOOL s_bHostWepRxEncryption (
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"byDecMode == KEY_CTL_WEP \n");
         if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
             (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true) ||
-            (bOnFly == FALSE)) {
+            (bOnFly == false)) {
             // Software WEP
             // 1. 3253A
             // 2. WEP 256
@@ -1377,7 +1377,7 @@ static BOOL s_bHostWepRxEncryption (
 
         if (byDecMode == KEY_CTL_TKIP) {
 
-            if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || (bOnFly == FALSE)) {
+            if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || (bOnFly == false)) {
                 // Software TKIP
                 // 1. 3253 A
                 // 2. NotOnFly
@@ -1397,7 +1397,7 @@ static BOOL s_bHostWepRxEncryption (
         }
 
         if (byDecMode == KEY_CTL_CCMP) {
-            if (bOnFly == FALSE) {
+            if (bOnFly == false) {
                 // Software CCMP
                 // NotOnFly
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_CCMP\n");
@@ -1429,8 +1429,8 @@ static BOOL s_bAPModeRxData (
     )
 {
     PSMgmtObject        pMgmt = pDevice->pMgmt;
-    BOOL                bRelayAndForward = FALSE;
-    BOOL                bRelayOnly = FALSE;
+    BOOL                bRelayAndForward = false;
+    BOOL                bRelayOnly = false;
     unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
     unsigned short wAID;
 
@@ -1438,7 +1438,7 @@ static BOOL s_bAPModeRxData (
     struct sk_buff* skbcpy = NULL;
 
     if (FrameSize > CB_MAX_BUF_SIZE)
-        return FALSE;
+        return false;
     // check DA
     if(is_multicast_ether_addr((unsigned char *)(skb->data+cbHeaderOffset))) {
        if (pMgmt->sNodeDBTable[0].bPSEnable) {
@@ -1499,11 +1499,11 @@ static BOOL s_bAPModeRxData (
         }
 
         if (bRelayOnly)
-            return FALSE;
+            return false;
     }
     // none associate, don't forward
     if (pDevice->uAssocCount == 0)
-        return FALSE;
+        return false;
 
     return true;
 }

commit 1b12068a804711ae2f4fd2876d5706542c1d7ad9
Author: Charles Clément <caratorn@gmail.com>
Date:   Sun Aug 1 17:15:48 2010 +0200

    Staging: vt6655: replace TRUE with in kernel true
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index c7ffdea75490..c6ca3bb58a7d 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -413,7 +413,7 @@ device_receive_frame (
 
   pMACHeader=(PS802_11Header)((unsigned char *) (skb->data)+8);
 //PLICE_DEBUG<-
-	if (pDevice->bMeasureInProgress == TRUE) {
+	if (pDevice->bMeasureInProgress == true) {
         if ((*pbyRsr & RSR_CRCOK) != 0) {
             pDevice->byBasicMap |= 0x01;
         }
@@ -470,7 +470,7 @@ device_receive_frame (
     }
 
     if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-        if (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex) == TRUE) {
+        if (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex) == true) {
             return FALSE;
         }
     }
@@ -480,7 +480,7 @@ device_receive_frame (
         BOOL     bRxDecryOK = FALSE;
 
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"rx WEP pkt\n");
-        bIsWEP = TRUE;
+        bIsWEP = true;
         if ((pDevice->bEnableHostWEP) && (iSANodeIndex >= 0)) {
             pKey = &STempKey;
             pKey->byCipherSuite = pMgmt->sNodeDBTable[iSANodeIndex].byCipherSuite;
@@ -629,7 +629,7 @@ device_receive_frame (
     	        skb->protocol = htons(ETH_P_802_2);
 	            memset(skb->cb, 0, sizeof(skb->cb));
 	            netif_rx(skb);
-                return TRUE;
+                return true;
 	        }
         }
         else {
@@ -677,7 +677,7 @@ device_receive_frame (
 	     if (wEtherType == ETH_P_PAE) {         //Protocol Type in LLC-Header
                   if(((Protocol_Version==1) ||(Protocol_Version==2)) &&
 		     (Packet_Type==3)) {  //802.1x OR eapol-key challenge frame receive
-                        bRxeapol_key = TRUE;
+                        bRxeapol_key = true;
                   }
 	      }
    	  }
@@ -696,7 +696,7 @@ device_receive_frame (
             }
         }
         else {
-            if (pDevice->pMgmt->bInTIMWake == TRUE) {
+            if (pDevice->pMgmt->bInTIMWake == true) {
                 pDevice->pMgmt->bInTIMWake = FALSE;
             }
         }
@@ -705,7 +705,7 @@ device_receive_frame (
     // Now it only supports 802.11g Infrastructure Mode, and support rate must up to 54 Mbps
     if (pDevice->bDiversityEnable && (FrameSize>50) &&
         (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE) &&
-        (pDevice->bLinkPass == TRUE)) {
+        (pDevice->bLinkPass == true)) {
 	//printk("device_receive_frame: RxRate is %d\n",*pbyRxRate);
 		BBvAntennaDiversity(pDevice, s_byGetRateIdx(*pbyRxRate), 0);
     }
@@ -732,7 +732,7 @@ device_receive_frame (
 
     // -----------------------------------------------
 
-    if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) && (pDevice->bEnable8021x == TRUE)){
+    if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) && (pDevice->bEnable8021x == true)){
         unsigned char abyMacHdr[24];
 
         // Only 802.1x packet incoming allowed
@@ -747,7 +747,7 @@ device_receive_frame (
         if (wEtherType == ETH_P_PAE) {
             skb->dev = pDevice->apdev;
 
-            if (bIsWEP == TRUE) {
+            if (bIsWEP == true) {
                 // strip IV header(8)
                 memcpy(&abyMacHdr[0], (skb->data + 4), 24);
                 memcpy((skb->data + 4 + cbIVOffset), &abyMacHdr[0], 24);
@@ -761,7 +761,7 @@ device_receive_frame (
             skb->protocol = htons(ETH_P_802_2);
             memset(skb->cb, 0, sizeof(skb->cb));
             netif_rx(skb);
-            return TRUE;
+            return true;
 
 }
         // check if 802.1x authorized
@@ -824,7 +824,7 @@ device_receive_frame (
 
 
             if ((cpu_to_le32(*pdwMIC_L) != dwLocalMIC_L) || (cpu_to_le32(*pdwMIC_R) != dwLocalMIC_R) ||
-                (pDevice->bRxMICFail == TRUE)) {
+                (pDevice->bRxMICFail == true)) {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC comparison is fail!\n");
                 pDevice->bRxMICFail = FALSE;
                 //pDevice->s802_11Counter.TKIPLocalMICFailures.QuadPart++;
@@ -838,7 +838,7 @@ device_receive_frame (
                //2008-0409-07, <Add> by Einsn Liu
        #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 				//send event to wpa_supplicant
-				//if(pDevice->bWPADevEnable == TRUE)
+				//if(pDevice->bWPADevEnable == true)
 				{
 					union iwreq_data wrqu;
 					struct iw_michaelmicfailure ev;
@@ -1014,7 +1014,7 @@ device_receive_frame (
         return FALSE;
     }
 
-    return TRUE;
+    return true;
 }
 
 
@@ -1048,7 +1048,7 @@ static BOOL s_bAPModeRxCtl (
                                          &Status
                                          );
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 1\n");
-                    return TRUE;
+                    return true;
                 };
                 if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_ASSOC) {
                     // send deassoc notification
@@ -1060,13 +1060,13 @@ static BOOL s_bAPModeRxCtl (
                                          &Status
                                          );
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDisassocBeginSta 2\n");
-                    return TRUE;
+                    return true;
                 };
 
                 if (pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable) {
                     // delcare received ps-poll event
                     if (IS_CTL_PSPOLL(pbyFrame)) {
-                        pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;
+                        pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
                         bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 1\n");
                     }
@@ -1075,7 +1075,7 @@ static BOOL s_bAPModeRxCtl (
                         // if PW bit off, send out all PS bufferring packets.
                         if (!IS_FC_POWERMGT(pbyFrame)) {
                             pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = FALSE;
-                            pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;
+                            pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
                             bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
                             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 2\n");
                         }
@@ -1083,15 +1083,15 @@ static BOOL s_bAPModeRxCtl (
                 }
                 else {
                    if (IS_FC_POWERMGT(pbyFrame)) {
-                       pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = TRUE;
+                       pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = true;
                        // Once if STA in PS state, enable multicast bufferring
-                       pMgmt->sNodeDBTable[0].bPSEnable = TRUE;
+                       pMgmt->sNodeDBTable[0].bPSEnable = true;
                    }
                    else {
                       // clear all pending PS frame.
                       if (pMgmt->sNodeDBTable[iSANodeIndex].wEnQueueCnt > 0) {
                           pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = FALSE;
-                          pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;
+                          pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;
                           bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
                          DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 3\n");
 
@@ -1134,7 +1134,7 @@ static BOOL s_bAPModeRxCtl (
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: wFrameCtl= %x\n", p802_11Header->wFrameCtl );
                     VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc:pDevice->byRxMode = %x\n", pDevice->byRxMode );
-                    return TRUE;
+                    return true;
             }
         }
     }
@@ -1184,7 +1184,7 @@ static BOOL s_bHandleRxEncryption (
             (pDevice->pMgmt->byCSSPK != KEY_CTL_NONE)) {
             // unicast pkt use pairwise key
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt\n");
-            if (KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, 0xFFFFFFFF, &pKey) == TRUE) {
+            if (KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, 0xFFFFFFFF, &pKey) == true) {
                 if (pDevice->pMgmt->byCSSPK == KEY_CTL_TKIP)
                     byDecMode = KEY_CTL_TKIP;
                 else if (pDevice->pMgmt->byCSSPK == KEY_CTL_CCMP)
@@ -1218,7 +1218,7 @@ static BOOL s_bHandleRxEncryption (
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey == NULL\n");
         if (byDecMode == KEY_CTL_WEP) {
 //            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
-        } else if (pDevice->bLinkPass == TRUE) {
+        } else if (pDevice->bLinkPass == true) {
 //            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
         }
         return FALSE;
@@ -1226,7 +1226,7 @@ static BOOL s_bHandleRxEncryption (
     if (byDecMode != pKey->byCipherSuite) {
         if (byDecMode == KEY_CTL_WEP) {
 //            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
-        } else if (pDevice->bLinkPass == TRUE) {
+        } else if (pDevice->bLinkPass == true) {
 //            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
         }
         *pKeyOut = NULL;
@@ -1235,7 +1235,7 @@ static BOOL s_bHandleRxEncryption (
     if (byDecMode == KEY_CTL_WEP) {
         // handle WEP
         if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
-            (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == TRUE)) {
+            (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true)) {
             // Software WEP
             // 1. 3253A
             // 2. WEP 256
@@ -1283,8 +1283,8 @@ static BOOL s_bHandleRxEncryption (
     }// end of TKIP/AES
 
     if ((*(pbyIV+3) & 0x20) != 0)
-        *pbExtIV = TRUE;
-    return TRUE;
+        *pbExtIV = true;
+    return true;
 }
 
 
@@ -1333,7 +1333,7 @@ static BOOL s_bHostWepRxEncryption (
     if (byDecMode != pKey->byCipherSuite) {
         if (byDecMode == KEY_CTL_WEP) {
 //            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
-        } else if (pDevice->bLinkPass == TRUE) {
+        } else if (pDevice->bLinkPass == true) {
 //            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
         }
         return FALSE;
@@ -1343,7 +1343,7 @@ static BOOL s_bHostWepRxEncryption (
         // handle WEP
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"byDecMode == KEY_CTL_WEP \n");
         if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
-            (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == TRUE) ||
+            (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true) ||
             (bOnFly == FALSE)) {
             // Software WEP
             // 1. 3253A
@@ -1413,8 +1413,8 @@ static BOOL s_bHostWepRxEncryption (
     }// end of TKIP/AES
 
     if ((*(pbyIV+3) & 0x20) != 0)
-        *pbExtIV = TRUE;
-    return TRUE;
+        *pbExtIV = true;
+    return true;
 }
 
 
@@ -1461,7 +1461,7 @@ static BOOL s_bAPModeRxData (
            }
        }
        else {
-           bRelayAndForward = TRUE;
+           bRelayAndForward = true;
        }
     }
     else {
@@ -1480,10 +1480,10 @@ static BOOL s_bAPModeRxData (
                     pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "relay: index= %d, pMgmt->abyPSTxMap[%d]= %d\n",
                                iDANodeIndex, (wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);
-                    return TRUE;
+                    return true;
                 }
                 else {
-                    bRelayOnly = TRUE;
+                    bRelayOnly = true;
                 }
             }
         };
@@ -1505,6 +1505,6 @@ static BOOL s_bAPModeRxData (
     if (pDevice->uAssocCount == 0)
         return FALSE;
 
-    return TRUE;
+    return true;
 }
 

commit 388bf2e8fe0cd499e1a440648ab0d95cd66a114f
Author: Charles Clément <caratorn@gmail.com>
Date:   Wed Jun 30 09:46:24 2010 +0200

    Staging: vt6655: simplify broadcast and multicast ethernet address test
    
    A broadcast address is also a multicast address so simplify test cases where
    possible.
    
    As suggested by Joe Perches.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 882c2f6c3413..c7ffdea75490 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -443,7 +443,7 @@ device_receive_frame (
         return FALSE;
     }
 
-    if (!is_multicast_ether_addr(pbyFrame) && !is_broadcast_ether_addr(pbyFrame)) {
+    if (!is_multicast_ether_addr(pbyFrame)) {
         if (WCTLbIsDuplicate(&(pDevice->sDupRxCache), (PS802_11Header) (skb->data + 4))) {
             pDevice->s802_11Counter.FrameDuplicateCount++;
             return FALSE;

commit fe4f34bde28f5a9f3793cced5b4029eda5b78be2
Author: Charles Clément <caratorn@gmail.com>
Date:   Fri Jun 25 10:48:53 2010 -0700

    Staging: vt6655: remove PUINT typedef
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 8b5310ad183d..882c2f6c3413 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -79,24 +79,14 @@ const unsigned char acbyRxRate[MAX_RATE] =
 static unsigned char s_byGetRateIdx(unsigned char byRate);
 
 
-static
-void
-s_vGetDASA(
-    unsigned char *pbyRxBufferAddr,
-    PUINT pcbHeaderSize,
-    PSEthernetHeader psEthHeader
-    );
+static void
+s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
+		PSEthernetHeader psEthHeader);
 
-static
-void
-s_vProcessRxMACHeader (
-    PSDevice pDevice,
-    unsigned char *pbyRxBufferAddr,
-    unsigned int cbPacketSize,
-    BOOL bIsWEP,
-    BOOL bExtIV,
-    PUINT pcbHeadSize
-    );
+static void
+s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
+		unsigned int cbPacketSize, BOOL bIsWEP, BOOL bExtIV,
+		unsigned int *pcbHeadSize);
 
 static BOOL s_bAPModeRxCtl(
     PSDevice pDevice,
@@ -162,16 +152,10 @@ static BOOL s_bHostWepRxEncryption(
  * Return Value: None
  *
 -*/
-static
-void
-s_vProcessRxMACHeader (
-    PSDevice pDevice,
-    unsigned char *pbyRxBufferAddr,
-    unsigned int cbPacketSize,
-    BOOL bIsWEP,
-    BOOL bExtIV,
-    PUINT pcbHeadSize
-    )
+static void
+s_vProcessRxMACHeader(PSDevice pDevice, unsigned char *pbyRxBufferAddr,
+		unsigned int cbPacketSize, BOOL bIsWEP, BOOL bExtIV,
+		unsigned int *pcbHeadSize)
 {
     unsigned char *pbyRxBuffer;
     unsigned int cbHeaderSize = 0;
@@ -261,13 +245,9 @@ static unsigned char s_byGetRateIdx (unsigned char byRate)
 }
 
 
-static
-void
-s_vGetDASA (
-    unsigned char *pbyRxBufferAddr,
-    PUINT pcbHeaderSize,
-    PSEthernetHeader psEthHeader
-    )
+static void
+s_vGetDASA(unsigned char *pbyRxBufferAddr, unsigned int *pcbHeaderSize,
+	PSEthernetHeader psEthHeader)
 {
     unsigned int cbHeaderSize = 0;
     PS802_11Header  pMACHeader;

commit 3fc9b584c28095fe0d46cfb8bddafdf93947042e
Author: Charles Clément <caratorn@gmail.com>
Date:   Thu Jun 24 11:02:27 2010 -0700

    Staging: vt6655: remove BYTE typedef
    
    Replace all occurrences with unsigned char type.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 91a52e6dc6d1..8b5310ad183d 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -66,7 +66,7 @@
 //static int          msglevel                =MSG_LEVEL_DEBUG;
 static int          msglevel                =MSG_LEVEL_INFO;
 
-const BYTE acbyRxRate[MAX_RATE] =
+const unsigned char acbyRxRate[MAX_RATE] =
 {2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108};
 
 
@@ -76,7 +76,7 @@ const BYTE acbyRxRate[MAX_RATE] =
 
 /*---------------------  Static Functions  --------------------------*/
 
-static BYTE s_byGetRateIdx(BYTE byRate);
+static unsigned char s_byGetRateIdx(unsigned char byRate);
 
 
 static
@@ -249,9 +249,9 @@ s_vProcessRxMACHeader (
 
 
 
-static BYTE s_byGetRateIdx (BYTE byRate)
+static unsigned char s_byGetRateIdx (unsigned char byRate)
 {
-    BYTE    byRateIdx;
+    unsigned char byRateIdx;
 
     for (byRateIdx = 0; byRateIdx <MAX_RATE ; byRateIdx++) {
         if (acbyRxRate[byRateIdx%MAX_RATE] == byRate)
@@ -684,8 +684,8 @@ device_receive_frame (
             }
    //mike add:station mode check eapol-key challenge--->
    	  {
-   	    BYTE  Protocol_Version;    //802.1x Authentication
-	    BYTE  Packet_Type;           //802.1x Authentication
+   	    unsigned char Protocol_Version;    //802.1x Authentication
+	    unsigned char Packet_Type;           //802.1x Authentication
               if (bIsWEP)
                   cbIVOffset = 8;
               else
@@ -753,7 +753,7 @@ device_receive_frame (
     // -----------------------------------------------
 
     if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) && (pDevice->bEnable8021x == TRUE)){
-        BYTE    abyMacHdr[24];
+        unsigned char abyMacHdr[24];
 
         // Only 802.1x packet incoming allowed
         if (bIsWEP)
@@ -1176,9 +1176,9 @@ static BOOL s_bHandleRxEncryption (
 {
     unsigned int PayloadLen = FrameSize;
     unsigned char *pbyIV;
-    BYTE            byKeyIdx;
+    unsigned char byKeyIdx;
     PSKeyItem       pKey = NULL;
-    BYTE            byDecMode = KEY_CTL_WEP;
+    unsigned char byDecMode = KEY_CTL_WEP;
     PSMgmtObject    pMgmt = pDevice->pMgmt;
 
 
@@ -1323,8 +1323,8 @@ static BOOL s_bHostWepRxEncryption (
 {
     unsigned int PayloadLen = FrameSize;
     unsigned char *pbyIV;
-    BYTE            byKeyIdx;
-    BYTE            byDecMode = KEY_CTL_WEP;
+    unsigned char byKeyIdx;
+    unsigned char byDecMode = KEY_CTL_WEP;
     PS802_11Header  pMACHeader;
 
 
@@ -1451,7 +1451,7 @@ static BOOL s_bAPModeRxData (
     PSMgmtObject        pMgmt = pDevice->pMgmt;
     BOOL                bRelayAndForward = FALSE;
     BOOL                bRelayOnly = FALSE;
-    BYTE                byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
+    unsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
     unsigned short wAID;
 
 

commit 2986db5fd31e312206d3ebfa4786aac04bdbe486
Author: Charles Clément <caratorn@gmail.com>
Date:   Thu Jun 24 11:02:26 2010 -0700

    Staging: vt6655: remove WORD typedef
    
    Replace all occurrences with unsigned short type.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index e994f0a9dd15..91a52e6dc6d1 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -359,7 +359,7 @@ device_receive_frame (
     BOOL            bIsWEP = FALSE;
     unsigned int cbHeaderOffset;
     unsigned int FrameSize;
-    WORD            wEtherType = 0;
+    unsigned short wEtherType = 0;
     int             iSANodeIndex = -1;
     int             iDANodeIndex = -1;
     unsigned int ii;
@@ -370,7 +370,7 @@ device_receive_frame (
     unsigned char *pbySQ;
     unsigned int cbHeaderSize;
     PSKeyItem       pKey = NULL;
-    WORD            wRxTSC15_0 = 0;
+    unsigned short wRxTSC15_0 = 0;
     unsigned long dwRxTSC47_16 = 0;
     SKeyItem        STempKey;
     // 802.11h RPI
@@ -917,12 +917,12 @@ device_receive_frame (
     if ((pKey != NULL) && ((pKey->byCipherSuite == KEY_CTL_TKIP) ||
                            (pKey->byCipherSuite == KEY_CTL_CCMP))) {
         if (bIsWEP) {
-            WORD        wLocalTSC15_0 = 0;
+            unsigned short wLocalTSC15_0 = 0;
             unsigned long dwLocalTSC47_16 = 0;
             unsigned long long       RSC = 0;
             // endian issues
             RSC = *((unsigned long long *) &(pKey->KeyRSC));
-            wLocalTSC15_0 = (WORD) RSC;
+            wLocalTSC15_0 = (unsigned short) RSC;
             dwLocalTSC47_16 = (unsigned long) (RSC>>16);
 
             RSC = dwRxTSC47_16;
@@ -1452,7 +1452,7 @@ static BOOL s_bAPModeRxData (
     BOOL                bRelayAndForward = FALSE;
     BOOL                bRelayOnly = FALSE;
     BYTE                byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
-    WORD                wAID;
+    unsigned short wAID;
 
 
     struct sk_buff* skbcpy = NULL;

commit 0f4c60d61e9c10a0733eacd650c101189bdf75cd
Author: Charles Clément <caratorn@gmail.com>
Date:   Thu Jun 24 11:02:25 2010 -0700

    Staging: vt6655: remove DWORD typedef
    
    Replace all occurrences with unsigned long type, except for pointer fields that
    should be u32 in packed structures and 8-byte-aligned 8 byte long structure
    QWORD.
    
    Thanks to Jiri Slaby for pointing out that simply replacing by unsigned long is
    wrong on x86-64 arch.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 3f3f83a83191..e994f0a9dd15 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -371,10 +371,10 @@ device_receive_frame (
     unsigned int cbHeaderSize;
     PSKeyItem       pKey = NULL;
     WORD            wRxTSC15_0 = 0;
-    DWORD           dwRxTSC47_16 = 0;
+    unsigned long dwRxTSC47_16 = 0;
     SKeyItem        STempKey;
     // 802.11h RPI
-    DWORD           dwDuration = 0;
+    unsigned long dwDuration = 0;
     long            ldBm = 0;
     long            ldBmThreshold = 0;
     PS802_11Header pMACHeader;
@@ -802,10 +802,10 @@ device_receive_frame (
         if (bIsWEP) {
             unsigned long *pdwMIC_L;
             unsigned long *pdwMIC_R;
-            DWORD           dwMIC_Priority;
-            DWORD           dwMICKey0 = 0, dwMICKey1 = 0;
-            DWORD           dwLocalMIC_L = 0;
-            DWORD           dwLocalMIC_R = 0;
+            unsigned long dwMIC_Priority;
+            unsigned long dwMICKey0 = 0, dwMICKey1 = 0;
+            unsigned long dwLocalMIC_L = 0;
+            unsigned long dwLocalMIC_R = 0;
             viawget_wpa_header *wpahdr;
 
 
@@ -918,12 +918,12 @@ device_receive_frame (
                            (pKey->byCipherSuite == KEY_CTL_CCMP))) {
         if (bIsWEP) {
             WORD        wLocalTSC15_0 = 0;
-            DWORD       dwLocalTSC47_16 = 0;
+            unsigned long dwLocalTSC47_16 = 0;
             unsigned long long       RSC = 0;
             // endian issues
             RSC = *((unsigned long long *) &(pKey->KeyRSC));
             wLocalTSC15_0 = (WORD) RSC;
-            dwLocalTSC47_16 = (DWORD) (RSC>>16);
+            dwLocalTSC47_16 = (unsigned long) (RSC>>16);
 
             RSC = dwRxTSC47_16;
             RSC <<= 16;

commit 9d828c458f77043ddd9626ee0cfa688dda99c0eb
Author: Charles Clément <caratorn@gmail.com>
Date:   Sat Jun 5 15:13:49 2010 -0700

    Staging: vt6655: remove PDWORD typedef
    
    Use unsigned long * instead.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 98bc2552fa00..3f3f83a83191 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -125,7 +125,7 @@ static BOOL s_bHandleRxEncryption(
     PSKeyItem   *pKeyOut,
     int *       pbExtIV,
     unsigned short *pwRxTSC15_0,
-    PDWORD      pdwRxTSC47_16
+    unsigned long *pdwRxTSC47_16
     );
 
 static BOOL s_bHostWepRxEncryption(
@@ -139,7 +139,7 @@ static BOOL s_bHostWepRxEncryption(
     unsigned char *pbyNewRsr,
     int *       pbExtIV,
     unsigned short *pwRxTSC15_0,
-    PDWORD      pdwRxTSC47_16
+    unsigned long *pdwRxTSC47_16
 
     );
 
@@ -800,8 +800,8 @@ device_receive_frame (
     // Soft MIC
     if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
         if (bIsWEP) {
-            PDWORD          pdwMIC_L;
-            PDWORD          pdwMIC_R;
+            unsigned long *pdwMIC_L;
+            unsigned long *pdwMIC_R;
             DWORD           dwMIC_Priority;
             DWORD           dwMICKey0 = 0, dwMICKey1 = 0;
             DWORD           dwLocalMIC_L = 0;
@@ -810,19 +810,19 @@ device_receive_frame (
 
 
             if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-                dwMICKey0 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[24]));
-                dwMICKey1 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[28]));
+                dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[24]));
+                dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[28]));
             }
             else {
                 if (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) {
-                    dwMICKey0 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[16]));
-                    dwMICKey1 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[20]));
+                    dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[16]));
+                    dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[20]));
                 } else if ((pKey->dwKeyIndex & BIT28) == 0) {
-                    dwMICKey0 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[16]));
-                    dwMICKey1 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[20]));
+                    dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[16]));
+                    dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[20]));
                 } else {
-                    dwMICKey0 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[24]));
-                    dwMICKey1 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[28]));
+                    dwMICKey0 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[24]));
+                    dwMICKey1 = cpu_to_le32(*(unsigned long *)(&pKey->abyKey[28]));
                 }
             }
 
@@ -836,8 +836,8 @@ device_receive_frame (
             MIC_vGetMIC(&dwLocalMIC_L, &dwLocalMIC_R);
             MIC_vUnInit();
 
-            pdwMIC_L = (PDWORD)(skb->data + 4 + FrameSize);
-            pdwMIC_R = (PDWORD)(skb->data + 4 + FrameSize + 4);
+            pdwMIC_L = (unsigned long *)(skb->data + 4 + FrameSize);
+            pdwMIC_R = (unsigned long *)(skb->data + 4 + FrameSize + 4);
             //DBG_PRN_GRP12(("RxL: %lx, RxR: %lx\n", *pdwMIC_L, *pdwMIC_R));
             //DBG_PRN_GRP12(("LocalL: %lx, LocalR: %lx\n", dwLocalMIC_L, dwLocalMIC_R));
             //DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"dwMICKey0= %lx,dwMICKey1= %lx \n", dwMICKey0, dwMICKey1);
@@ -1171,7 +1171,7 @@ static BOOL s_bHandleRxEncryption (
     PSKeyItem   *pKeyOut,
     int *       pbExtIV,
     unsigned short *pwRxTSC15_0,
-    PDWORD      pdwRxTSC47_16
+    unsigned long *pdwRxTSC47_16
     )
 {
     unsigned int PayloadLen = FrameSize;
@@ -1275,7 +1275,7 @@ static BOOL s_bHandleRxEncryption (
         // TKIP/AES
 
         PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
-        *pdwRxTSC47_16 = cpu_to_le32(*(PDWORD)(pbyIV + 4));
+        *pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);
         if (byDecMode == KEY_CTL_TKIP) {
             *pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
@@ -1318,7 +1318,7 @@ static BOOL s_bHostWepRxEncryption (
     unsigned char *pbyNewRsr,
     int *       pbExtIV,
     unsigned short *pwRxTSC15_0,
-    PDWORD      pdwRxTSC47_16
+    unsigned long *pdwRxTSC47_16
     )
 {
     unsigned int PayloadLen = FrameSize;
@@ -1385,7 +1385,7 @@ static BOOL s_bHostWepRxEncryption (
         // TKIP/AES
 
         PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
-        *pdwRxTSC47_16 = cpu_to_le32(*(PDWORD)(pbyIV + 4));
+        *pdwRxTSC47_16 = cpu_to_le32(*(unsigned long *)(pbyIV + 4));
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);
 
         if (byDecMode == KEY_CTL_TKIP) {

commit 15df6c2b922de3088203ad90347a30d31ccca67e
Author: Charles Clément <caratorn@gmail.com>
Date:   Sat Jun 5 15:13:48 2010 -0700

    Staging: vt6655: remove PWORD typedef
    
    Use unsigned short * instead.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 723f8466bd61..98bc2552fa00 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -124,7 +124,7 @@ static BOOL s_bHandleRxEncryption(
     unsigned char *pbyNewRsr,
     PSKeyItem   *pKeyOut,
     int *       pbExtIV,
-    PWORD       pwRxTSC15_0,
+    unsigned short *pwRxTSC15_0,
     PDWORD      pdwRxTSC47_16
     );
 
@@ -138,7 +138,7 @@ static BOOL s_bHostWepRxEncryption(
     PSKeyItem    pKey,
     unsigned char *pbyNewRsr,
     int *       pbExtIV,
-    PWORD       pwRxTSC15_0,
+    unsigned short *pwRxTSC15_0,
     PDWORD      pdwRxTSC47_16
 
     );
@@ -175,7 +175,7 @@ s_vProcessRxMACHeader (
 {
     unsigned char *pbyRxBuffer;
     unsigned int cbHeaderSize = 0;
-    PWORD           pwType;
+    unsigned short *pwType;
     PS802_11Header  pMACHeader;
     int             ii;
 
@@ -203,12 +203,12 @@ s_vProcessRxMACHeader (
     }
     else if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_RFC1042[0])) {
         cbHeaderSize += 6;
-        pwType = (PWORD) (pbyRxBufferAddr + cbHeaderSize);
+        pwType = (unsigned short *) (pbyRxBufferAddr + cbHeaderSize);
         if ((*pwType!= TYPE_PKT_IPX) && (*pwType != cpu_to_le16(0xF380))) {
         }
         else {
             cbHeaderSize -= 8;
-            pwType = (PWORD) (pbyRxBufferAddr + cbHeaderSize);
+            pwType = (unsigned short *) (pbyRxBufferAddr + cbHeaderSize);
             if (bIsWEP) {
                 if (bExtIV) {
                     *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    // 8 is IV&ExtIV
@@ -223,7 +223,7 @@ s_vProcessRxMACHeader (
     }
     else {
         cbHeaderSize -= 2;
-        pwType = (PWORD) (pbyRxBufferAddr + cbHeaderSize);
+        pwType = (unsigned short *) (pbyRxBufferAddr + cbHeaderSize);
         if (bIsWEP) {
             if (bExtIV) {
                 *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    // 8 is IV&ExtIV
@@ -353,7 +353,7 @@ device_receive_frame (
     unsigned char *pbyNewRsr;
     unsigned char *pbyRSSI;
     PQWORD          pqwTSFTime;
-    PWORD           pwFrameSize;
+    unsigned short *pwFrameSize;
     unsigned char *pbyFrame;
     BOOL            bDeFragRx = FALSE;
     BOOL            bIsWEP = FALSE;
@@ -391,7 +391,7 @@ device_receive_frame (
                      pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
 #endif
 //PLICE_DEBUG<-
-    pwFrameSize = (PWORD)(skb->data + 2);
+    pwFrameSize = (unsigned short *)(skb->data + 2);
     FrameSize = cpu_to_le16(pCurrRD->m_rd1RD1.wReqCount) - cpu_to_le16(pCurrRD->m_rd0RD0.wResCount);
 
     // Max: 2312Payload + 30HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
@@ -1170,7 +1170,7 @@ static BOOL s_bHandleRxEncryption (
     unsigned char *pbyNewRsr,
     PSKeyItem   *pKeyOut,
     int *       pbExtIV,
-    PWORD       pwRxTSC15_0,
+    unsigned short *pwRxTSC15_0,
     PDWORD      pdwRxTSC47_16
     )
 {
@@ -1186,8 +1186,8 @@ static BOOL s_bHandleRxEncryption (
     *pdwRxTSC47_16 = 0;
 
     pbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;
-    if ( WLAN_GET_FC_TODS(*(PWORD)pbyFrame) &&
-         WLAN_GET_FC_FROMDS(*(PWORD)pbyFrame) ) {
+    if ( WLAN_GET_FC_TODS(*(unsigned short *)pbyFrame) &&
+         WLAN_GET_FC_FROMDS(*(unsigned short *)pbyFrame) ) {
          pbyIV += 6;             // 6 is 802.11 address4
          PayloadLen -= 6;
     }
@@ -1280,7 +1280,7 @@ static BOOL s_bHandleRxEncryption (
         if (byDecMode == KEY_CTL_TKIP) {
             *pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
         } else {
-            *pwRxTSC15_0 = cpu_to_le16(*(PWORD)pbyIV);
+            *pwRxTSC15_0 = cpu_to_le16(*(unsigned short *)pbyIV);
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);
 
@@ -1317,7 +1317,7 @@ static BOOL s_bHostWepRxEncryption (
     PSKeyItem    pKey,
     unsigned char *pbyNewRsr,
     int *       pbExtIV,
-    PWORD       pwRxTSC15_0,
+    unsigned short *pwRxTSC15_0,
     PDWORD      pdwRxTSC47_16
     )
 {
@@ -1333,8 +1333,8 @@ static BOOL s_bHostWepRxEncryption (
     *pdwRxTSC47_16 = 0;
 
     pbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;
-    if ( WLAN_GET_FC_TODS(*(PWORD)pbyFrame) &&
-         WLAN_GET_FC_FROMDS(*(PWORD)pbyFrame) ) {
+    if ( WLAN_GET_FC_TODS(*(unsigned short *)pbyFrame) &&
+         WLAN_GET_FC_FROMDS(*(unsigned short *)pbyFrame) ) {
          pbyIV += 6;             // 6 is 802.11 address4
          PayloadLen -= 6;
     }
@@ -1391,7 +1391,7 @@ static BOOL s_bHostWepRxEncryption (
         if (byDecMode == KEY_CTL_TKIP) {
             *pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
         } else {
-            *pwRxTSC15_0 = cpu_to_le16(*(PWORD)pbyIV);
+            *pwRxTSC15_0 = cpu_to_le16(*(unsigned short *)pbyIV);
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);
 

commit 2989e96f17f2dcbd73aee37856899c2885df0686
Author: Charles Clément <caratorn@gmail.com>
Date:   Sat Jun 5 15:13:47 2010 -0700

    Staging: vt6655: remove PBYTE typedef
    
    Use unsigned char * instead.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 286461ca4e56..723f8466bd61 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -82,7 +82,7 @@ static BYTE s_byGetRateIdx(BYTE byRate);
 static
 void
 s_vGetDASA(
-    PBYTE pbyRxBufferAddr,
+    unsigned char *pbyRxBufferAddr,
     PUINT pcbHeaderSize,
     PSEthernetHeader psEthHeader
     );
@@ -91,7 +91,7 @@ static
 void
 s_vProcessRxMACHeader (
     PSDevice pDevice,
-    PBYTE pbyRxBufferAddr,
+    unsigned char *pbyRxBufferAddr,
     unsigned int cbPacketSize,
     BOOL bIsWEP,
     BOOL bExtIV,
@@ -100,7 +100,7 @@ s_vProcessRxMACHeader (
 
 static BOOL s_bAPModeRxCtl(
     PSDevice pDevice,
-    PBYTE    pbyFrame,
+    unsigned char *pbyFrame,
     int      iSANodeIndex
     );
 
@@ -118,10 +118,10 @@ static BOOL s_bAPModeRxData (
 
 static BOOL s_bHandleRxEncryption(
     PSDevice     pDevice,
-    PBYTE        pbyFrame,
+    unsigned char *pbyFrame,
     unsigned int FrameSize,
-    PBYTE        pbyRsr,
-    PBYTE       pbyNewRsr,
+    unsigned char *pbyRsr,
+    unsigned char *pbyNewRsr,
     PSKeyItem   *pKeyOut,
     int *       pbExtIV,
     PWORD       pwRxTSC15_0,
@@ -131,12 +131,12 @@ static BOOL s_bHandleRxEncryption(
 static BOOL s_bHostWepRxEncryption(
 
     PSDevice     pDevice,
-    PBYTE        pbyFrame,
+    unsigned char *pbyFrame,
     unsigned int FrameSize,
-    PBYTE        pbyRsr,
+    unsigned char *pbyRsr,
     BOOL         bOnFly,
     PSKeyItem    pKey,
-    PBYTE       pbyNewRsr,
+    unsigned char *pbyNewRsr,
     int *       pbExtIV,
     PWORD       pwRxTSC15_0,
     PDWORD      pdwRxTSC47_16
@@ -166,14 +166,14 @@ static
 void
 s_vProcessRxMACHeader (
     PSDevice pDevice,
-    PBYTE pbyRxBufferAddr,
+    unsigned char *pbyRxBufferAddr,
     unsigned int cbPacketSize,
     BOOL bIsWEP,
     BOOL bExtIV,
     PUINT pcbHeadSize
     )
 {
-    PBYTE           pbyRxBuffer;
+    unsigned char *pbyRxBuffer;
     unsigned int cbHeaderSize = 0;
     PWORD           pwType;
     PS802_11Header  pMACHeader;
@@ -182,7 +182,7 @@ s_vProcessRxMACHeader (
 
     pMACHeader = (PS802_11Header) (pbyRxBufferAddr + cbHeaderSize);
 
-    s_vGetDASA((PBYTE)pMACHeader, &cbHeaderSize, &pDevice->sRxEthHeader);
+    s_vGetDASA((unsigned char *)pMACHeader, &cbHeaderSize, &pDevice->sRxEthHeader);
 
     if (bIsWEP) {
         if (bExtIV) {
@@ -197,7 +197,7 @@ s_vProcessRxMACHeader (
         cbHeaderSize += WLAN_HDR_ADDR3_LEN;
     };
 
-    pbyRxBuffer = (PBYTE) (pbyRxBufferAddr + cbHeaderSize);
+    pbyRxBuffer = (unsigned char *) (pbyRxBufferAddr + cbHeaderSize);
     if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_Bridgetunnel[0])) {
         cbHeaderSize += 6;
     }
@@ -237,7 +237,7 @@ s_vProcessRxMACHeader (
     }
 
     cbHeaderSize -= (ETH_ALEN * 2);
-    pbyRxBuffer = (PBYTE) (pbyRxBufferAddr + cbHeaderSize);
+    pbyRxBuffer = (unsigned char *) (pbyRxBufferAddr + cbHeaderSize);
     for(ii=0;ii<ETH_ALEN;ii++)
         *pbyRxBuffer++ = pDevice->sRxEthHeader.abyDstAddr[ii];
     for(ii=0;ii<ETH_ALEN;ii++)
@@ -264,7 +264,7 @@ static BYTE s_byGetRateIdx (BYTE byRate)
 static
 void
 s_vGetDASA (
-    PBYTE pbyRxBufferAddr,
+    unsigned char *pbyRxBufferAddr,
     PUINT pcbHeaderSize,
     PSEthernetHeader psEthHeader
     )
@@ -349,12 +349,12 @@ device_receive_frame (
     PSMgmtObject    pMgmt = pDevice->pMgmt;
     PSRxMgmtPacket  pRxPacket = &(pDevice->pMgmt->sRxPacket);
     PS802_11Header  p802_11Header;
-    PBYTE           pbyRsr;
-    PBYTE           pbyNewRsr;
-    PBYTE           pbyRSSI;
+    unsigned char *pbyRsr;
+    unsigned char *pbyNewRsr;
+    unsigned char *pbyRSSI;
     PQWORD          pqwTSFTime;
     PWORD           pwFrameSize;
-    PBYTE           pbyFrame;
+    unsigned char *pbyFrame;
     BOOL            bDeFragRx = FALSE;
     BOOL            bIsWEP = FALSE;
     unsigned int cbHeaderOffset;
@@ -365,9 +365,9 @@ device_receive_frame (
     unsigned int ii;
     unsigned int cbIVOffset;
     BOOL            bExtIV = FALSE;
-    PBYTE           pbyRxSts;
-    PBYTE           pbyRxRate;
-    PBYTE           pbySQ;
+    unsigned char *pbyRxSts;
+    unsigned char *pbyRxRate;
+    unsigned char *pbySQ;
     unsigned int cbHeaderSize;
     PSKeyItem       pKey = NULL;
     WORD            wRxTSC15_0 = 0;
@@ -402,14 +402,14 @@ device_receive_frame (
         return FALSE;
     }
 
-    pbyRxSts = (PBYTE) (skb->data);
-    pbyRxRate = (PBYTE) (skb->data + 1);
-    pbyRsr = (PBYTE) (skb->data + FrameSize - 1);
-    pbyRSSI = (PBYTE) (skb->data + FrameSize - 2);
-    pbyNewRsr = (PBYTE) (skb->data + FrameSize - 3);
-    pbySQ = (PBYTE) (skb->data + FrameSize - 4);
+    pbyRxSts = (unsigned char *) (skb->data);
+    pbyRxRate = (unsigned char *) (skb->data + 1);
+    pbyRsr = (unsigned char *) (skb->data + FrameSize - 1);
+    pbyRSSI = (unsigned char *) (skb->data + FrameSize - 2);
+    pbyNewRsr = (unsigned char *) (skb->data + FrameSize - 3);
+    pbySQ = (unsigned char *) (skb->data + FrameSize - 4);
     pqwTSFTime = (PQWORD) (skb->data + FrameSize - 12);
-    pbyFrame = (PBYTE)(skb->data + 4);
+    pbyFrame = (unsigned char *)(skb->data + 4);
 
     // get packet size
     FrameSize = cpu_to_le16(*pwFrameSize);
@@ -431,7 +431,7 @@ device_receive_frame (
 
 #endif
 
-  pMACHeader=(PS802_11Header)((PBYTE) (skb->data)+8);
+  pMACHeader=(PS802_11Header)((unsigned char *) (skb->data)+8);
 //PLICE_DEBUG<-
 	if (pDevice->bMeasureInProgress == TRUE) {
         if ((*pbyRsr & RSR_CRCOK) != 0) {
@@ -475,14 +475,14 @@ device_receive_frame (
     s_vGetDASA(skb->data+4, &cbHeaderSize, &pDevice->sRxEthHeader);
 
     // filter packet send from myself
-    if (!compare_ether_addr((PBYTE)&(pDevice->sRxEthHeader.abySrcAddr[0]), pDevice->abyCurrentNetAddr))
+    if (!compare_ether_addr((unsigned char *)&(pDevice->sRxEthHeader.abySrcAddr[0]), pDevice->abyCurrentNetAddr))
         return FALSE;
 
     if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) || (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)) {
         if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
             p802_11Header = (PS802_11Header) (pbyFrame);
             // get SA NodeIndex
-            if (BSSDBbIsSTAInNodeDB(pMgmt, (PBYTE)(p802_11Header->abyAddr2), &iSANodeIndex)) {
+            if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(p802_11Header->abyAddr2), &iSANodeIndex)) {
                 pMgmt->sNodeDBTable[iSANodeIndex].ulLastRxJiffer = jiffies;
                 pMgmt->sNodeDBTable[iSANodeIndex].uInActiveCount = 0;
             }
@@ -594,8 +594,8 @@ device_receive_frame (
         // Handle Control & Manage Frame
 
         if (IS_TYPE_MGMT((skb->data+4))) {
-            PBYTE pbyData1;
-            PBYTE pbyData2;
+            unsigned char *pbyData1;
+            unsigned char *pbyData2;
 
             pRxPacket->p80211Header = (PUWLAN_80211HDR)(skb->data+4);
             pRxPacket->cbMPDULen = FrameSize;
@@ -827,11 +827,11 @@ device_receive_frame (
             }
 
             MIC_vInit(dwMICKey0, dwMICKey1);
-            MIC_vAppend((PBYTE)&(pDevice->sRxEthHeader.abyDstAddr[0]), 12);
+            MIC_vAppend((unsigned char *)&(pDevice->sRxEthHeader.abyDstAddr[0]), 12);
             dwMIC_Priority = 0;
-            MIC_vAppend((PBYTE)&dwMIC_Priority, 4);
+            MIC_vAppend((unsigned char *)&dwMIC_Priority, 4);
             // 4 is Rcv buffer header, 24 is MAC Header, and 8 is IV and Ext IV.
-            MIC_vAppend((PBYTE)(skb->data + 4 + WLAN_HDR_ADDR3_LEN + 8),
+            MIC_vAppend((unsigned char *)(skb->data + 4 + WLAN_HDR_ADDR3_LEN + 8),
                         FrameSize - WLAN_HDR_ADDR3_LEN - 8);
             MIC_vGetMIC(&dwLocalMIC_L, &dwLocalMIC_R);
             MIC_vUnInit();
@@ -963,7 +963,7 @@ device_receive_frame (
     }
 
 
-    s_vProcessRxMACHeader(pDevice, (PBYTE)(skb->data+4), FrameSize, bIsWEP, bExtIV, &cbHeaderOffset);
+    s_vProcessRxMACHeader(pDevice, (unsigned char *)(skb->data+4), FrameSize, bIsWEP, bExtIV, &cbHeaderOffset);
     FrameSize -= cbHeaderOffset;
     cbHeaderOffset += 4;        // 4 is Rcv buffer header
 
@@ -1040,7 +1040,7 @@ device_receive_frame (
 
 static BOOL s_bAPModeRxCtl (
     PSDevice pDevice,
-    PBYTE    pbyFrame,
+    unsigned char *pbyFrame,
     int      iSANodeIndex
     )
 {
@@ -1063,7 +1063,7 @@ static BOOL s_bAPModeRxCtl (
                     // reason = (6) class 2 received from nonauth sta
                     vMgrDeAuthenBeginSta(pDevice,
                                          pMgmt,
-                                         (PBYTE)(p802_11Header->abyAddr2),
+                                         (unsigned char *)(p802_11Header->abyAddr2),
                                          (WLAN_MGMT_REASON_CLASS2_NONAUTH),
                                          &Status
                                          );
@@ -1075,7 +1075,7 @@ static BOOL s_bAPModeRxCtl (
                     // reason = (7) class 3 received from nonassoc sta
                     vMgrDisassocBeginSta(pDevice,
                                          pMgmt,
-                                         (PBYTE)(p802_11Header->abyAddr2),
+                                         (unsigned char *)(p802_11Header->abyAddr2),
                                          (WLAN_MGMT_REASON_CLASS3_NONASSOC),
                                          &Status
                                          );
@@ -1122,7 +1122,7 @@ static BOOL s_bAPModeRxCtl (
             else {
                   vMgrDeAuthenBeginSta(pDevice,
                                        pMgmt,
-                                       (PBYTE)(p802_11Header->abyAddr2),
+                                       (unsigned char *)(p802_11Header->abyAddr2),
                                        (WLAN_MGMT_REASON_CLASS2_NONAUTH),
                                        &Status
                                        );
@@ -1164,10 +1164,10 @@ static BOOL s_bAPModeRxCtl (
 
 static BOOL s_bHandleRxEncryption (
     PSDevice     pDevice,
-    PBYTE        pbyFrame,
+    unsigned char *pbyFrame,
     unsigned int FrameSize,
-    PBYTE        pbyRsr,
-    PBYTE       pbyNewRsr,
+    unsigned char *pbyRsr,
+    unsigned char *pbyNewRsr,
     PSKeyItem   *pKeyOut,
     int *       pbExtIV,
     PWORD       pwRxTSC15_0,
@@ -1175,7 +1175,7 @@ static BOOL s_bHandleRxEncryption (
     )
 {
     unsigned int PayloadLen = FrameSize;
-    PBYTE           pbyIV;
+    unsigned char *pbyIV;
     BYTE            byKeyIdx;
     PSKeyItem       pKey = NULL;
     BYTE            byDecMode = KEY_CTL_WEP;
@@ -1310,19 +1310,19 @@ static BOOL s_bHandleRxEncryption (
 
 static BOOL s_bHostWepRxEncryption (
     PSDevice     pDevice,
-    PBYTE        pbyFrame,
+    unsigned char *pbyFrame,
     unsigned int FrameSize,
-    PBYTE        pbyRsr,
+    unsigned char *pbyRsr,
     BOOL         bOnFly,
     PSKeyItem    pKey,
-    PBYTE       pbyNewRsr,
+    unsigned char *pbyNewRsr,
     int *       pbExtIV,
     PWORD       pwRxTSC15_0,
     PDWORD      pdwRxTSC47_16
     )
 {
     unsigned int PayloadLen = FrameSize;
-    PBYTE           pbyIV;
+    unsigned char *pbyIV;
     BYTE            byKeyIdx;
     BYTE            byDecMode = KEY_CTL_WEP;
     PS802_11Header  pMACHeader;
@@ -1460,7 +1460,7 @@ static BOOL s_bAPModeRxData (
     if (FrameSize > CB_MAX_BUF_SIZE)
         return FALSE;
     // check DA
-    if(is_multicast_ether_addr((PBYTE)(skb->data+cbHeaderOffset))) {
+    if(is_multicast_ether_addr((unsigned char *)(skb->data+cbHeaderOffset))) {
        if (pMgmt->sNodeDBTable[0].bPSEnable) {
 
            skbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);
@@ -1486,7 +1486,7 @@ static BOOL s_bAPModeRxData (
     }
     else {
         // check if relay
-        if (BSSDBbIsSTAInNodeDB(pMgmt, (PBYTE)(skb->data+cbHeaderOffset), &iDANodeIndex)) {
+        if (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data+cbHeaderOffset), &iDANodeIndex)) {
             if (pMgmt->sNodeDBTable[iDANodeIndex].eNodeState >= NODE_ASSOC) {
                 if (pMgmt->sNodeDBTable[iDANodeIndex].bPSEnable) {
                     // queue this skb until next PS tx, and then release.
@@ -1515,7 +1515,7 @@ static BOOL s_bAPModeRxData (
             iDANodeIndex = 0;
 
         if ((pDevice->uAssocCount > 1) && (iDANodeIndex >= 0)) {
-            ROUTEbRelay(pDevice, (PBYTE)(skb->data + cbHeaderOffset), FrameSize, (unsigned int)iDANodeIndex);
+            ROUTEbRelay(pDevice, (unsigned char *)(skb->data + cbHeaderOffset), FrameSize, (unsigned int)iDANodeIndex);
         }
 
         if (bRelayOnly)

commit b2e876b6089160e5ecaed859eb1b87cd4913793e
Author: Charles Clément <caratorn@gmail.com>
Date:   Wed Jun 2 09:52:03 2010 -0700

    Staging: vt6655: remove custom ULONGLONG typedef
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 8fa87dd5c43b..286461ca4e56 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -919,9 +919,9 @@ device_receive_frame (
         if (bIsWEP) {
             WORD        wLocalTSC15_0 = 0;
             DWORD       dwLocalTSC47_16 = 0;
-            ULONGLONG       RSC = 0;
+            unsigned long long       RSC = 0;
             // endian issues
-            RSC = *((ULONGLONG *) &(pKey->KeyRSC));
+            RSC = *((unsigned long long *) &(pKey->KeyRSC));
             wLocalTSC15_0 = (WORD) RSC;
             dwLocalTSC47_16 = (DWORD) (RSC>>16);
 

commit b6e95cd52a81079abc1def7867e27bf541953089
Author: Charles Clément <caratorn@gmail.com>
Date:   Wed Jun 2 09:52:01 2010 -0700

    Staging: vt6655: remove custom UINT typedef
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index ce6ccab25e26..8fa87dd5c43b 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -92,7 +92,7 @@ void
 s_vProcessRxMACHeader (
     PSDevice pDevice,
     PBYTE pbyRxBufferAddr,
-    UINT cbPacketSize,
+    unsigned int cbPacketSize,
     BOOL bIsWEP,
     BOOL bExtIV,
     PUINT pcbHeadSize
@@ -109,8 +109,8 @@ static BOOL s_bAPModeRxCtl(
 static BOOL s_bAPModeRxData (
     PSDevice pDevice,
     struct sk_buff* skb,
-    UINT     FrameSize,
-    UINT     cbHeaderOffset,
+    unsigned int FrameSize,
+    unsigned int cbHeaderOffset,
     int      iSANodeIndex,
     int      iDANodeIndex
     );
@@ -119,7 +119,7 @@ static BOOL s_bAPModeRxData (
 static BOOL s_bHandleRxEncryption(
     PSDevice     pDevice,
     PBYTE        pbyFrame,
-    UINT         FrameSize,
+    unsigned int FrameSize,
     PBYTE        pbyRsr,
     PBYTE       pbyNewRsr,
     PSKeyItem   *pKeyOut,
@@ -132,7 +132,7 @@ static BOOL s_bHostWepRxEncryption(
 
     PSDevice     pDevice,
     PBYTE        pbyFrame,
-    UINT         FrameSize,
+    unsigned int FrameSize,
     PBYTE        pbyRsr,
     BOOL         bOnFly,
     PSKeyItem    pKey,
@@ -167,14 +167,14 @@ void
 s_vProcessRxMACHeader (
     PSDevice pDevice,
     PBYTE pbyRxBufferAddr,
-    UINT cbPacketSize,
+    unsigned int cbPacketSize,
     BOOL bIsWEP,
     BOOL bExtIV,
     PUINT pcbHeadSize
     )
 {
     PBYTE           pbyRxBuffer;
-    UINT            cbHeaderSize = 0;
+    unsigned int cbHeaderSize = 0;
     PWORD           pwType;
     PS802_11Header  pMACHeader;
     int             ii;
@@ -269,7 +269,7 @@ s_vGetDASA (
     PSEthernetHeader psEthHeader
     )
 {
-    UINT            cbHeaderSize = 0;
+    unsigned int cbHeaderSize = 0;
     PS802_11Header  pMACHeader;
     int             ii;
 
@@ -357,18 +357,18 @@ device_receive_frame (
     PBYTE           pbyFrame;
     BOOL            bDeFragRx = FALSE;
     BOOL            bIsWEP = FALSE;
-    UINT            cbHeaderOffset;
-    UINT            FrameSize;
+    unsigned int cbHeaderOffset;
+    unsigned int FrameSize;
     WORD            wEtherType = 0;
     int             iSANodeIndex = -1;
     int             iDANodeIndex = -1;
-    UINT            ii;
-    UINT            cbIVOffset;
+    unsigned int ii;
+    unsigned int cbIVOffset;
     BOOL            bExtIV = FALSE;
     PBYTE           pbyRxSts;
     PBYTE           pbyRxRate;
     PBYTE           pbySQ;
-    UINT            cbHeaderSize;
+    unsigned int cbHeaderSize;
     PSKeyItem       pKey = NULL;
     WORD            wRxTSC15_0 = 0;
     DWORD           dwRxTSC47_16 = 0;
@@ -1165,7 +1165,7 @@ static BOOL s_bAPModeRxCtl (
 static BOOL s_bHandleRxEncryption (
     PSDevice     pDevice,
     PBYTE        pbyFrame,
-    UINT         FrameSize,
+    unsigned int FrameSize,
     PBYTE        pbyRsr,
     PBYTE       pbyNewRsr,
     PSKeyItem   *pKeyOut,
@@ -1174,7 +1174,7 @@ static BOOL s_bHandleRxEncryption (
     PDWORD      pdwRxTSC47_16
     )
 {
-    UINT            PayloadLen = FrameSize;
+    unsigned int PayloadLen = FrameSize;
     PBYTE           pbyIV;
     BYTE            byKeyIdx;
     PSKeyItem       pKey = NULL;
@@ -1311,7 +1311,7 @@ static BOOL s_bHandleRxEncryption (
 static BOOL s_bHostWepRxEncryption (
     PSDevice     pDevice,
     PBYTE        pbyFrame,
-    UINT         FrameSize,
+    unsigned int FrameSize,
     PBYTE        pbyRsr,
     BOOL         bOnFly,
     PSKeyItem    pKey,
@@ -1321,7 +1321,7 @@ static BOOL s_bHostWepRxEncryption (
     PDWORD      pdwRxTSC47_16
     )
 {
-    UINT            PayloadLen = FrameSize;
+    unsigned int PayloadLen = FrameSize;
     PBYTE           pbyIV;
     BYTE            byKeyIdx;
     BYTE            byDecMode = KEY_CTL_WEP;
@@ -1442,8 +1442,8 @@ static BOOL s_bHostWepRxEncryption (
 static BOOL s_bAPModeRxData (
     PSDevice pDevice,
     struct sk_buff* skb,
-    UINT     FrameSize,
-    UINT     cbHeaderOffset,
+    unsigned int FrameSize,
+    unsigned int cbHeaderOffset,
     int      iSANodeIndex,
     int      iDANodeIndex
     )
@@ -1515,7 +1515,7 @@ static BOOL s_bAPModeRxData (
             iDANodeIndex = 0;
 
         if ((pDevice->uAssocCount > 1) && (iDANodeIndex >= 0)) {
-            ROUTEbRelay(pDevice, (PBYTE)(skb->data + cbHeaderOffset), FrameSize, (UINT)iDANodeIndex);
+            ROUTEbRelay(pDevice, (PBYTE)(skb->data + cbHeaderOffset), FrameSize, (unsigned int)iDANodeIndex);
         }
 
         if (bRelayOnly)

commit b83cc2ed466f1b9938521d73fefe8b34baf265ea
Author: Charles Clément <caratorn@gmail.com>
Date:   Tue Jun 1 12:38:57 2010 -0700

    Staging: vt6655: remove custom LONG typedef
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index e00999fb8107..ce6ccab25e26 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -375,8 +375,8 @@ device_receive_frame (
     SKeyItem        STempKey;
     // 802.11h RPI
     DWORD           dwDuration = 0;
-    LONG            ldBm = 0;
-    LONG            ldBmThreshold = 0;
+    long            ldBm = 0;
+    long            ldBmThreshold = 0;
     PS802_11Header pMACHeader;
  BOOL            bRxeapol_key = FALSE;
 

commit 7ca3019525e6e3ba727e36dfdc07d8e8d487a5e2
Author: Charles Clément <caratorn@gmail.com>
Date:   Tue Jun 1 12:38:56 2010 -0700

    Staging: vt6655: remove custom INT typedef
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 535e033427a9..e00999fb8107 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -101,7 +101,7 @@ s_vProcessRxMACHeader (
 static BOOL s_bAPModeRxCtl(
     PSDevice pDevice,
     PBYTE    pbyFrame,
-    INT      iSANodeIndex
+    int      iSANodeIndex
     );
 
 
@@ -111,8 +111,8 @@ static BOOL s_bAPModeRxData (
     struct sk_buff* skb,
     UINT     FrameSize,
     UINT     cbHeaderOffset,
-    INT      iSANodeIndex,
-    INT      iDANodeIndex
+    int      iSANodeIndex,
+    int      iDANodeIndex
     );
 
 
@@ -360,8 +360,8 @@ device_receive_frame (
     UINT            cbHeaderOffset;
     UINT            FrameSize;
     WORD            wEtherType = 0;
-    INT             iSANodeIndex = -1;
-    INT             iDANodeIndex = -1;
+    int             iSANodeIndex = -1;
+    int             iDANodeIndex = -1;
     UINT            ii;
     UINT            cbIVOffset;
     BOOL            bExtIV = FALSE;
@@ -1041,7 +1041,7 @@ device_receive_frame (
 static BOOL s_bAPModeRxCtl (
     PSDevice pDevice,
     PBYTE    pbyFrame,
-    INT      iSANodeIndex
+    int      iSANodeIndex
     )
 {
     PS802_11Header      p802_11Header;
@@ -1444,8 +1444,8 @@ static BOOL s_bAPModeRxData (
     struct sk_buff* skb,
     UINT     FrameSize,
     UINT     cbHeaderOffset,
-    INT      iSANodeIndex,
-    INT      iDANodeIndex
+    int      iSANodeIndex,
+    int      iDANodeIndex
     )
 {
     PSMgmtObject        pMgmt = pDevice->pMgmt;

commit 2ef98c606516be4efb176c3c5e339b769ca1833a
Author: Charles Clément <caratorn@gmail.com>
Date:   Wed May 19 11:30:54 2010 -0700

    Staging: vt6655: use compare_ether_addr instead of custom macro
    
    Replace custom macro IS_ETH_ADDRESS_EQUAL by compare_ether_addr from
    <linux/etherdevice.h>.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index c82fc3101fa3..535e033427a9 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -198,10 +198,10 @@ s_vProcessRxMACHeader (
     };
 
     pbyRxBuffer = (PBYTE) (pbyRxBufferAddr + cbHeaderSize);
-    if (IS_ETH_ADDRESS_EQUAL(pbyRxBuffer, &pDevice->abySNAP_Bridgetunnel[0])) {
+    if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_Bridgetunnel[0])) {
         cbHeaderSize += 6;
     }
-    else if (IS_ETH_ADDRESS_EQUAL(pbyRxBuffer, &pDevice->abySNAP_RFC1042[0])) {
+    else if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_RFC1042[0])) {
         cbHeaderSize += 6;
         pwType = (PWORD) (pbyRxBufferAddr + cbHeaderSize);
         if ((*pwType!= TYPE_PKT_IPX) && (*pwType != cpu_to_le16(0xF380))) {
@@ -475,7 +475,7 @@ device_receive_frame (
     s_vGetDASA(skb->data+4, &cbHeaderSize, &pDevice->sRxEthHeader);
 
     // filter packet send from myself
-    if (IS_ETH_ADDRESS_EQUAL((PBYTE)&(pDevice->sRxEthHeader.abySrcAddr[0]), pDevice->abyCurrentNetAddr))
+    if (!compare_ether_addr((PBYTE)&(pDevice->sRxEthHeader.abySrcAddr[0]), pDevice->abyCurrentNetAddr))
         return FALSE;
 
     if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) || (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)) {

commit ca9e12acda7ab451ab481d29911af7ee27c512cf
Author: Charles Clément <caratorn@gmail.com>
Date:   Wed May 19 11:30:52 2010 -0700

    Staging: vt6655: use is_broadcast_ether_addr instead of custom macro
    
    Replace custom macro IS_BROADCAST_ADDRESS by is_broadcast_ether_addr
    from <linux/etherdevice.h>.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index addbd4d1989d..c82fc3101fa3 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -463,7 +463,7 @@ device_receive_frame (
         return FALSE;
     }
 
-    if (!is_multicast_ether_addr(pbyFrame) && !IS_BROADCAST_ADDRESS(pbyFrame)) {
+    if (!is_multicast_ether_addr(pbyFrame) && !is_broadcast_ether_addr(pbyFrame)) {
         if (WCTLbIsDuplicate(&(pDevice->sDupRxCache), (PS802_11Header) (skb->data + 4))) {
             pDevice->s802_11Counter.FrameDuplicateCount++;
             return FALSE;

commit 670ea81eadf68fa68023731e3f747fd6b0c61dd4
Author: Charles Clément <caratorn@gmail.com>
Date:   Wed May 19 11:30:51 2010 -0700

    Staging: vt6655: use is_multicast_ether_addr instead of custom macro
    
    Replace custom macro IS_MULTICAST_ADDRESS by is_multicast_ether_addr
    from <linux/etherdevice.h>.
    Remove linux/if_ether.h include as it is included in
    linux/etherdevice.h already.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 6b758a8c1af3..addbd4d1989d 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -463,7 +463,7 @@ device_receive_frame (
         return FALSE;
     }
 
-    if (!IS_MULTICAST_ADDRESS(pbyFrame) && !IS_BROADCAST_ADDRESS(pbyFrame)) {
+    if (!is_multicast_ether_addr(pbyFrame) && !IS_BROADCAST_ADDRESS(pbyFrame)) {
         if (WCTLbIsDuplicate(&(pDevice->sDupRxCache), (PS802_11Header) (skb->data + 4))) {
             pDevice->s802_11Counter.FrameDuplicateCount++;
             return FALSE;
@@ -1460,7 +1460,7 @@ static BOOL s_bAPModeRxData (
     if (FrameSize > CB_MAX_BUF_SIZE)
         return FALSE;
     // check DA
-    if(IS_MULTICAST_ADDRESS((PBYTE)(skb->data+cbHeaderOffset))) {
+    if(is_multicast_ether_addr((PBYTE)(skb->data+cbHeaderOffset))) {
        if (pMgmt->sNodeDBTable[0].bPSEnable) {
 
            skbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);

commit 855181f51558dca10c8acc27f1f81e0809ddf057
Author: Charles Clément <caratorn@gmail.com>
Date:   Tue May 18 10:19:36 2010 -0700

    Staging: vt6655: use ETH_FCS_LEN macro instead of custom one
    
    Replace custom FCS/CRC length definition U_CRC_LEN by ETH_FCS_LEN
    from <linux/if_ether.h>.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 83040f4f6c78..6b758a8c1af3 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -569,7 +569,7 @@ device_receive_frame (
     // RX OK
     //
     //remove the CRC length
-    FrameSize -= U_CRC_LEN;
+    FrameSize -= ETH_FCS_LEN;
 
     if (( !(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI))) && // unicast address
         (IS_FRAGMENT_PKT((skb->data+4)))

commit 078b078f662a8e21d5a6fee81007b5337ab962cd
Author: Charles Clément <caratorn@gmail.com>
Date:   Fri May 14 19:37:32 2010 -0700

    Staging: vt6655: use ETH_ALEN macro instead of custom one
    
    Replaced custom ethernet address length definition U_ETHER_ADDR_LEN by
    ETH_ALEN from <linux/if_ether.h>.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 715be63f21a4..83040f4f6c78 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -236,11 +236,11 @@ s_vProcessRxMACHeader (
         }
     }
 
-    cbHeaderSize -= (U_ETHER_ADDR_LEN * 2);
+    cbHeaderSize -= (ETH_ALEN * 2);
     pbyRxBuffer = (PBYTE) (pbyRxBufferAddr + cbHeaderSize);
-    for(ii=0;ii<U_ETHER_ADDR_LEN;ii++)
+    for(ii=0;ii<ETH_ALEN;ii++)
         *pbyRxBuffer++ = pDevice->sRxEthHeader.abyDstAddr[ii];
-    for(ii=0;ii<U_ETHER_ADDR_LEN;ii++)
+    for(ii=0;ii<ETH_ALEN;ii++)
         *pbyRxBuffer++ = pDevice->sRxEthHeader.abySrcAddr[ii];
 
     *pcbHeadSize = cbHeaderSize;
@@ -277,14 +277,14 @@ s_vGetDASA (
 
     if ((pMACHeader->wFrameCtl & FC_TODS) == 0) {
         if (pMACHeader->wFrameCtl & FC_FROMDS) {
-            for(ii=0;ii<U_ETHER_ADDR_LEN;ii++) {
+            for(ii=0;ii<ETH_ALEN;ii++) {
                 psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
                 psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr3[ii];
             }
         }
         else {
             // IBSS mode
-            for(ii=0;ii<U_ETHER_ADDR_LEN;ii++) {
+            for(ii=0;ii<ETH_ALEN;ii++) {
                 psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
                 psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
             }
@@ -293,14 +293,14 @@ s_vGetDASA (
     else {
         // Is AP mode..
         if (pMACHeader->wFrameCtl & FC_FROMDS) {
-            for(ii=0;ii<U_ETHER_ADDR_LEN;ii++) {
+            for(ii=0;ii<ETH_ALEN;ii++) {
                 psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr3[ii];
                 psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr4[ii];
                 cbHeaderSize += 6;
             }
         }
         else {
-            for(ii=0;ii<U_ETHER_ADDR_LEN;ii++) {
+            for(ii=0;ii<ETH_ALEN;ii++) {
                 psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr3[ii];
                 psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
             }

commit 3cdec5540d622e6b910a1fe91f544630a8ba8099
Author: Charles Clément <caratorn@gmail.com>
Date:   Wed May 12 20:54:40 2010 -0700

    Staging: vt6655: remove OUT definition
    
    Remove empty OUT definition used to specify output parameters.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 693683924663..715be63f21a4 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -83,8 +83,8 @@ static
 void
 s_vGetDASA(
     PBYTE pbyRxBufferAddr,
-    OUT PUINT pcbHeaderSize,
-    OUT PSEthernetHeader psEthHeader
+    PUINT pcbHeaderSize,
+    PSEthernetHeader psEthHeader
     );
 
 static
@@ -95,7 +95,7 @@ s_vProcessRxMACHeader (
     UINT cbPacketSize,
     BOOL bIsWEP,
     BOOL bExtIV,
-    OUT PUINT pcbHeadSize
+    PUINT pcbHeadSize
     );
 
 static BOOL s_bAPModeRxCtl(
@@ -121,11 +121,11 @@ static BOOL s_bHandleRxEncryption(
     PBYTE        pbyFrame,
     UINT         FrameSize,
     PBYTE        pbyRsr,
-    OUT PBYTE       pbyNewRsr,
-    OUT PSKeyItem   *pKeyOut,
+    PBYTE       pbyNewRsr,
+    PSKeyItem   *pKeyOut,
     int *       pbExtIV,
-    OUT PWORD       pwRxTSC15_0,
-    OUT PDWORD      pdwRxTSC47_16
+    PWORD       pwRxTSC15_0,
+    PDWORD      pdwRxTSC47_16
     );
 
 static BOOL s_bHostWepRxEncryption(
@@ -136,10 +136,10 @@ static BOOL s_bHostWepRxEncryption(
     PBYTE        pbyRsr,
     BOOL         bOnFly,
     PSKeyItem    pKey,
-    OUT PBYTE       pbyNewRsr,
+    PBYTE       pbyNewRsr,
     int *       pbExtIV,
-    OUT PWORD       pwRxTSC15_0,
-    OUT PDWORD      pdwRxTSC47_16
+    PWORD       pwRxTSC15_0,
+    PDWORD      pdwRxTSC47_16
 
     );
 
@@ -170,7 +170,7 @@ s_vProcessRxMACHeader (
     UINT cbPacketSize,
     BOOL bIsWEP,
     BOOL bExtIV,
-    OUT PUINT pcbHeadSize
+    PUINT pcbHeadSize
     )
 {
     PBYTE           pbyRxBuffer;
@@ -265,8 +265,8 @@ static
 void
 s_vGetDASA (
     PBYTE pbyRxBufferAddr,
-    OUT PUINT pcbHeaderSize,
-    OUT PSEthernetHeader psEthHeader
+    PUINT pcbHeaderSize,
+    PSEthernetHeader psEthHeader
     )
 {
     UINT            cbHeaderSize = 0;
@@ -1167,11 +1167,11 @@ static BOOL s_bHandleRxEncryption (
     PBYTE        pbyFrame,
     UINT         FrameSize,
     PBYTE        pbyRsr,
-    OUT PBYTE       pbyNewRsr,
-    OUT PSKeyItem   *pKeyOut,
+    PBYTE       pbyNewRsr,
+    PSKeyItem   *pKeyOut,
     int *       pbExtIV,
-    OUT PWORD       pwRxTSC15_0,
-    OUT PDWORD      pdwRxTSC47_16
+    PWORD       pwRxTSC15_0,
+    PDWORD      pdwRxTSC47_16
     )
 {
     UINT            PayloadLen = FrameSize;
@@ -1315,10 +1315,10 @@ static BOOL s_bHostWepRxEncryption (
     PBYTE        pbyRsr,
     BOOL         bOnFly,
     PSKeyItem    pKey,
-    OUT PBYTE       pbyNewRsr,
+    PBYTE       pbyNewRsr,
     int *       pbExtIV,
-    OUT PWORD       pwRxTSC15_0,
-    OUT PDWORD      pdwRxTSC47_16
+    PWORD       pwRxTSC15_0,
+    PDWORD      pdwRxTSC47_16
     )
 {
     UINT            PayloadLen = FrameSize;

commit 3a215e0ff4184314f7f1a099354a272ddedff289
Author: Charles Clément <caratorn@gmail.com>
Date:   Wed May 12 20:54:39 2010 -0700

    Staging: vt6655: remove IN definition
    
    Remove empty IN definition used to specify input parameters.
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index d90104a1e6b2..693683924663 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -76,13 +76,13 @@ const BYTE acbyRxRate[MAX_RATE] =
 
 /*---------------------  Static Functions  --------------------------*/
 
-static BYTE s_byGetRateIdx(IN BYTE byRate);
+static BYTE s_byGetRateIdx(BYTE byRate);
 
 
 static
 void
 s_vGetDASA(
-    IN  PBYTE pbyRxBufferAddr,
+    PBYTE pbyRxBufferAddr,
     OUT PUINT pcbHeaderSize,
     OUT PSEthernetHeader psEthHeader
     );
@@ -90,37 +90,37 @@ s_vGetDASA(
 static
 void
 s_vProcessRxMACHeader (
-    IN  PSDevice pDevice,
-    IN  PBYTE pbyRxBufferAddr,
-    IN  UINT cbPacketSize,
-    IN  BOOL bIsWEP,
-    IN  BOOL bExtIV,
+    PSDevice pDevice,
+    PBYTE pbyRxBufferAddr,
+    UINT cbPacketSize,
+    BOOL bIsWEP,
+    BOOL bExtIV,
     OUT PUINT pcbHeadSize
     );
 
 static BOOL s_bAPModeRxCtl(
-    IN PSDevice pDevice,
-    IN PBYTE    pbyFrame,
-    IN INT      iSANodeIndex
+    PSDevice pDevice,
+    PBYTE    pbyFrame,
+    INT      iSANodeIndex
     );
 
 
 
 static BOOL s_bAPModeRxData (
-    IN PSDevice pDevice,
-    IN struct sk_buff* skb,
-    IN UINT     FrameSize,
-    IN UINT     cbHeaderOffset,
-    IN INT      iSANodeIndex,
-    IN INT      iDANodeIndex
+    PSDevice pDevice,
+    struct sk_buff* skb,
+    UINT     FrameSize,
+    UINT     cbHeaderOffset,
+    INT      iSANodeIndex,
+    INT      iDANodeIndex
     );
 
 
 static BOOL s_bHandleRxEncryption(
-    IN PSDevice     pDevice,
-    IN PBYTE        pbyFrame,
-    IN UINT         FrameSize,
-    IN PBYTE        pbyRsr,
+    PSDevice     pDevice,
+    PBYTE        pbyFrame,
+    UINT         FrameSize,
+    PBYTE        pbyRsr,
     OUT PBYTE       pbyNewRsr,
     OUT PSKeyItem   *pKeyOut,
     int *       pbExtIV,
@@ -130,12 +130,12 @@ static BOOL s_bHandleRxEncryption(
 
 static BOOL s_bHostWepRxEncryption(
 
-    IN PSDevice     pDevice,
-    IN PBYTE        pbyFrame,
-    IN UINT         FrameSize,
-    IN PBYTE        pbyRsr,
-    IN BOOL         bOnFly,
-    IN PSKeyItem    pKey,
+    PSDevice     pDevice,
+    PBYTE        pbyFrame,
+    UINT         FrameSize,
+    PBYTE        pbyRsr,
+    BOOL         bOnFly,
+    PSKeyItem    pKey,
     OUT PBYTE       pbyNewRsr,
     int *       pbExtIV,
     OUT PWORD       pwRxTSC15_0,
@@ -165,11 +165,11 @@ static BOOL s_bHostWepRxEncryption(
 static
 void
 s_vProcessRxMACHeader (
-    IN  PSDevice pDevice,
-    IN  PBYTE pbyRxBufferAddr,
-    IN  UINT cbPacketSize,
-    IN  BOOL bIsWEP,
-    IN  BOOL bExtIV,
+    PSDevice pDevice,
+    PBYTE pbyRxBufferAddr,
+    UINT cbPacketSize,
+    BOOL bIsWEP,
+    BOOL bExtIV,
     OUT PUINT pcbHeadSize
     )
 {
@@ -249,7 +249,7 @@ s_vProcessRxMACHeader (
 
 
 
-static BYTE s_byGetRateIdx (IN BYTE byRate)
+static BYTE s_byGetRateIdx (BYTE byRate)
 {
     BYTE    byRateIdx;
 
@@ -264,7 +264,7 @@ static BYTE s_byGetRateIdx (IN BYTE byRate)
 static
 void
 s_vGetDASA (
-    IN  PBYTE pbyRxBufferAddr,
+    PBYTE pbyRxBufferAddr,
     OUT PUINT pcbHeaderSize,
     OUT PSEthernetHeader psEthHeader
     )
@@ -335,8 +335,8 @@ void	MngWorkItem(void *Context)
 
 BOOL
 device_receive_frame (
-    IN  PSDevice pDevice,
-    IN  PSRxDesc pCurrRD
+    PSDevice pDevice,
+    PSRxDesc pCurrRD
     )
 {
 
@@ -1039,9 +1039,9 @@ device_receive_frame (
 
 
 static BOOL s_bAPModeRxCtl (
-    IN PSDevice pDevice,
-    IN PBYTE    pbyFrame,
-    IN INT      iSANodeIndex
+    PSDevice pDevice,
+    PBYTE    pbyFrame,
+    INT      iSANodeIndex
     )
 {
     PS802_11Header      p802_11Header;
@@ -1163,10 +1163,10 @@ static BOOL s_bAPModeRxCtl (
 }
 
 static BOOL s_bHandleRxEncryption (
-    IN PSDevice     pDevice,
-    IN PBYTE        pbyFrame,
-    IN UINT         FrameSize,
-    IN PBYTE        pbyRsr,
+    PSDevice     pDevice,
+    PBYTE        pbyFrame,
+    UINT         FrameSize,
+    PBYTE        pbyRsr,
     OUT PBYTE       pbyNewRsr,
     OUT PSKeyItem   *pKeyOut,
     int *       pbExtIV,
@@ -1309,12 +1309,12 @@ static BOOL s_bHandleRxEncryption (
 
 
 static BOOL s_bHostWepRxEncryption (
-    IN PSDevice     pDevice,
-    IN PBYTE        pbyFrame,
-    IN UINT         FrameSize,
-    IN PBYTE        pbyRsr,
-    IN BOOL         bOnFly,
-    IN PSKeyItem    pKey,
+    PSDevice     pDevice,
+    PBYTE        pbyFrame,
+    UINT         FrameSize,
+    PBYTE        pbyRsr,
+    BOOL         bOnFly,
+    PSKeyItem    pKey,
     OUT PBYTE       pbyNewRsr,
     int *       pbExtIV,
     OUT PWORD       pwRxTSC15_0,
@@ -1440,12 +1440,12 @@ static BOOL s_bHostWepRxEncryption (
 
 
 static BOOL s_bAPModeRxData (
-    IN PSDevice pDevice,
-    IN struct sk_buff* skb,
-    IN UINT     FrameSize,
-    IN UINT     cbHeaderOffset,
-    IN INT      iSANodeIndex,
-    IN INT      iDANodeIndex
+    PSDevice pDevice,
+    struct sk_buff* skb,
+    UINT     FrameSize,
+    UINT     cbHeaderOffset,
+    INT      iSANodeIndex,
+    INT      iDANodeIndex
     )
 {
     PSMgmtObject        pMgmt = pDevice->pMgmt;

commit e64354c0be3b7134c85571a525b2e37fc4a95eef
Author: Charles Clément <caratorn@gmail.com>
Date:   Wed May 12 14:14:00 2010 -0700

    Staging: vt6655: remove HANDLE definition and use
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index ab13bdfc51be..d90104a1e6b2 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -631,13 +631,13 @@ device_receive_frame (
 		tasklet_schedule(&pDevice->RxMngWorkItem);
 #else
 //printk("RxMan\n");
-	vMgrRxManagePacket((HANDLE)pDevice, pDevice->pMgmt, pRxPacket);
+	vMgrRxManagePacket((void *)pDevice, pDevice->pMgmt, pRxPacket);
            //tasklet_schedule(&pDevice->RxMngWorkItem);
 #endif
 
 #endif
 //PLICE_DEBUG<-
-			//vMgrRxManagePacket((HANDLE)pDevice, pDevice->pMgmt, pRxPacket);
+			//vMgrRxManagePacket((void *)pDevice, pDevice->pMgmt, pRxPacket);
             // hostap Deamon handle 802.11 management
             if (pDevice->bEnableHostapd) {
 	            skb->dev = pDevice->apdev;
@@ -1087,7 +1087,7 @@ static BOOL s_bAPModeRxCtl (
                     // delcare received ps-poll event
                     if (IS_CTL_PSPOLL(pbyFrame)) {
                         pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;
-                        bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
+                        bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 1\n");
                     }
                     else {
@@ -1096,7 +1096,7 @@ static BOOL s_bAPModeRxCtl (
                         if (!IS_FC_POWERMGT(pbyFrame)) {
                             pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = FALSE;
                             pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;
-                            bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
+                            bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
                             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 2\n");
                         }
                     }
@@ -1112,7 +1112,7 @@ static BOOL s_bAPModeRxCtl (
                       if (pMgmt->sNodeDBTable[iSANodeIndex].wEnQueueCnt > 0) {
                           pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = FALSE;
                           pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;
-                          bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
+                          bScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
                          DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 3\n");
 
                       }

commit 830a619c02a53d52c86534f7d857b2e8d0ba893f
Author: Charles Clément <caratorn@gmail.com>
Date:   Fri May 7 12:30:20 2010 -0700

    Staging: vt6655: remove PVOID definition and use
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 58dced747fa2..ab13bdfc51be 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -314,7 +314,7 @@ s_vGetDASA (
 
 //PLICE_DEBUG ->
 
-void	MngWorkItem(PVOID Context)
+void	MngWorkItem(void *Context)
 {
 	PSRxMgmtPacket			pRxMgmtPacket;
 	PSDevice	pDevice =  (PSDevice) Context;

commit 6b35b7b3798b652a57fbce480f350aac851431c4
Author: Charles Clément <caratorn@gmail.com>
Date:   Fri May 7 12:30:19 2010 -0700

    Staging: vt6655: remove VOID definition and use
    
    Signed-off-by: Charles Clément <caratorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 67f238c01b44..58dced747fa2 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -80,7 +80,7 @@ static BYTE s_byGetRateIdx(IN BYTE byRate);
 
 
 static
-VOID
+void
 s_vGetDASA(
     IN  PBYTE pbyRxBufferAddr,
     OUT PUINT pcbHeaderSize,
@@ -88,7 +88,7 @@ s_vGetDASA(
     );
 
 static
-VOID
+void
 s_vProcessRxMACHeader (
     IN  PSDevice pDevice,
     IN  PBYTE pbyRxBufferAddr,
@@ -163,7 +163,7 @@ static BOOL s_bHostWepRxEncryption(
  *
 -*/
 static
-VOID
+void
 s_vProcessRxMACHeader (
     IN  PSDevice pDevice,
     IN  PBYTE pbyRxBufferAddr,
@@ -262,7 +262,7 @@ static BYTE s_byGetRateIdx (IN BYTE byRate)
 
 
 static
-VOID
+void
 s_vGetDASA (
     IN  PBYTE pbyRxBufferAddr,
     OUT PUINT pcbHeaderSize,
@@ -314,7 +314,7 @@ s_vGetDASA (
 
 //PLICE_DEBUG ->
 
-VOID	MngWorkItem(PVOID Context)
+void	MngWorkItem(PVOID Context)
 {
 	PSRxMgmtPacket			pRxMgmtPacket;
 	PSDevice	pDevice =  (PSDevice) Context;

commit 256a816b6b78bf29fba0c0f1bbcf998953429422
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:16 2009 -0700

    Staging: vt665x: remove tbit.h part 2
    
    Remove use of tbit macros adn remove header file.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index fa32229ef1dd..67f238c01b44 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -50,7 +50,6 @@
 #include "tcrc.h"
 #include "wctl.h"
 #include "wroute.h"
-#include "tbit.h"
 #include "hostap.h"
 #include "rf.h"
 #include "iowpa.h"
@@ -441,7 +440,7 @@ device_receive_frame (
         dwDuration = (FrameSize << 4);
         dwDuration /= acbyRxRate[*pbyRxRate%MAX_RATE];
         if (*pbyRxRate <= RATE_11M) {
-            if (BITbIsBitOn(*pbyRxSts, 0x01)) {
+            if (*pbyRxSts & 0x01) {
                 // long preamble
                 dwDuration += 192;
             } else {
@@ -572,7 +571,7 @@ device_receive_frame (
     //remove the CRC length
     FrameSize -= U_CRC_LEN;
 
-    if ((BITbIsAllBitsOff(*pbyRsr, (RSR_ADDRBROAD | RSR_ADDRMULTI))) && // unicast address
+    if (( !(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI))) && // unicast address
         (IS_FRAGMENT_PKT((skb->data+4)))
         ) {
         // defragment
@@ -661,7 +660,7 @@ device_receive_frame (
     else {
         if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
             //In AP mode, hw only check addr1(BSSID or RA) if equal to local MAC.
-            if (BITbIsBitOff(*pbyRsr, RSR_BSSIDOK)) {
+            if ( !(*pbyRsr & RSR_BSSIDOK)) {
                 if (bDeFragRx) {
                     if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
                         DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
@@ -674,7 +673,7 @@ device_receive_frame (
         else {
             // discard DATA packet while not associate || BSSID error
             if ((pDevice->bLinkPass == FALSE) ||
-                BITbIsBitOff(*pbyRsr, RSR_BSSIDOK)) {
+                !(*pbyRsr & RSR_BSSIDOK)) {
                 if (bDeFragRx) {
                     if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
                         DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
@@ -712,7 +711,7 @@ device_receive_frame (
 
     if (pDevice->bEnablePSMode) {
         if (IS_FC_MOREDATA((skb->data+4))) {
-            if (BITbIsBitOn(*pbyRsr, RSR_ADDROK)) {
+            if (*pbyRsr & RSR_ADDROK) {
                 //PSbSendPSPOLL((PSDevice)pDevice);
             }
         }

commit 51b6d9c299f10780b3093d3748257ecc4ae7340d
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:10 2009 -0700

    Staging: vt665x: Remove umem.h Part 1
    
    Remove references to umem.h macros and refer directly to memcpy
    functions.  Delete the include file.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index aaae1e691d01..fa32229ef1dd 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -45,7 +45,6 @@
 #include "bssdb.h"
 #include "mac.h"
 #include "baseband.h"
-#include "umem.h"
 #include "michael.h"
 #include "tkip.h"
 #include "tcrc.h"
@@ -930,7 +929,7 @@ device_receive_frame (
             RSC = dwRxTSC47_16;
             RSC <<= 16;
             RSC += wRxTSC15_0;
-            MEMvCopy(&(pKey->KeyRSC), &RSC,  sizeof(QWORD));
+            memcpy(&(pKey->KeyRSC), &RSC,  sizeof(QWORD));
 
             if ( (pDevice->sMgmtObj.eCurrMode == WMAC_MODE_ESS_STA) &&
                  (pDevice->sMgmtObj.eCurrState == WMAC_STATE_ASSOC)) {
@@ -1263,8 +1262,8 @@ static BOOL s_bHandleRxEncryption (
             // 2. WEP 256
 
             PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); // 24 is 802.11 header,4 is IV, 4 is crc
-            MEMvCopy(pDevice->abyPRNG, pbyIV, 3);
-            MEMvCopy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
+            memcpy(pDevice->abyPRNG, pbyIV, 3);
+            memcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
             rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
             rc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);
 
@@ -1373,8 +1372,8 @@ static BOOL s_bHostWepRxEncryption (
             // 3. NotOnFly
 
             PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); // 24 is 802.11 header,4 is IV, 4 is crc
-            MEMvCopy(pDevice->abyPRNG, pbyIV, 3);
-            MEMvCopy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
+            memcpy(pDevice->abyPRNG, pbyIV, 3);
+            memcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
             rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
             rc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);
 

commit a7ad322a46663755718a214a9a34e5cfe64d07f7
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:09 2009 -0700

    Staging: vt665x: Clean up include files, Part 2
    
    Remove cplusplus lines from include files
    Remove needless ifdefs on includes to conform with C
    conventions.  Remove misc commented code/includes
    Update TODO
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 5810c1a921cd..aaae1e691d01 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -38,61 +38,24 @@
  *
  */
 
-
-#if !defined(__DEVICE_H__)
 #include "device.h"
-#endif
-#if !defined(__RXTX_H__)
 #include "rxtx.h"
-#endif
-#if !defined(__TETHER_H__)
 #include "tether.h"
-#endif
-#if !defined(__CARD_H__)
 #include "card.h"
-#endif
-#if !defined(__BSSDB_H__)
 #include "bssdb.h"
-#endif
-#if !defined(__MAC_H__)
 #include "mac.h"
-#endif
-#if !defined(__BASEBAND_H__)
 #include "baseband.h"
-#endif
-#if !defined(__UMEM_H__)
 #include "umem.h"
-#endif
-#if !defined(__MICHAEL_H__)
 #include "michael.h"
-#endif
-#if !defined(__TKIP_H__)
 #include "tkip.h"
-#endif
-#if !defined(__TCRC_H__)
 #include "tcrc.h"
-#endif
-#if !defined(__WCTL_H__)
 #include "wctl.h"
-#endif
-#if !defined(__WROUTE_H__)
 #include "wroute.h"
-#endif
-#if !defined(__TBIT_H__)
 #include "tbit.h"
-#endif
-#if !defined(__HOSTAP_H__)
 #include "hostap.h"
-#endif
-#if !defined(__RF_H__)
 #include "rf.h"
-#endif
-#if !defined(__IOWPA_H__)
 #include "iowpa.h"
-#endif
-#if !defined(__AES_H__)
 #include "aes_ccmp.h"
-#endif
 
 //#define	PLICE_DEBUG
 

commit a884847a1a30be9a55d975f1e3fe8cf5f922bb79
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:07 2009 -0700

    Staging: vt665x: Typedef and macro cleanup Part 2
    
    Clean up unused typedefs and macros to remove Win32'isms and
    misc non-linux constructs.  Text edits to referencing
    source for less frequently used macros.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 5ab8f943c58a..5810c1a921cd 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -162,7 +162,7 @@ static BOOL s_bHandleRxEncryption(
     IN PBYTE        pbyRsr,
     OUT PBYTE       pbyNewRsr,
     OUT PSKeyItem   *pKeyOut,
-    OUT PBOOL       pbExtIV,
+    int *       pbExtIV,
     OUT PWORD       pwRxTSC15_0,
     OUT PDWORD      pdwRxTSC47_16
     );
@@ -176,7 +176,7 @@ static BOOL s_bHostWepRxEncryption(
     IN BOOL         bOnFly,
     IN PSKeyItem    pKey,
     OUT PBYTE       pbyNewRsr,
-    OUT PBOOL       pbExtIV,
+    int *       pbExtIV,
     OUT PWORD       pwRxTSC15_0,
     OUT PDWORD      pdwRxTSC47_16
 
@@ -1208,7 +1208,7 @@ static BOOL s_bHandleRxEncryption (
     IN PBYTE        pbyRsr,
     OUT PBYTE       pbyNewRsr,
     OUT PSKeyItem   *pKeyOut,
-    OUT PBOOL       pbExtIV,
+    int *       pbExtIV,
     OUT PWORD       pwRxTSC15_0,
     OUT PDWORD      pdwRxTSC47_16
     )
@@ -1355,7 +1355,7 @@ static BOOL s_bHostWepRxEncryption (
     IN BOOL         bOnFly,
     IN PSKeyItem    pKey,
     OUT PBYTE       pbyNewRsr,
-    OUT PBOOL       pbExtIV,
+    int *       pbExtIV,
     OUT PWORD       pwRxTSC15_0,
     OUT PDWORD      pdwRxTSC47_16
     )

commit 612822f5dd1638de442cf50eb9da54632fba0e66
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:03 2009 -0700

    Staging: vt665x: Text janitor in prep for driver merge, part 2
    
    Text only changes to remove textual differences between the vt6655
    and vt6656 trees in prep for driver merge.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index f7a5a662a3b5..5ab8f943c58a 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -144,6 +144,7 @@ static BOOL s_bAPModeRxCtl(
     );
 
 
+
 static BOOL s_bAPModeRxData (
     IN PSDevice pDevice,
     IN struct sk_buff* skb,
@@ -532,6 +533,8 @@ device_receive_frame (
             return FALSE;
         }
     }
+
+
     if (IS_FC_WEP(pbyFrame)) {
         BOOL     bRxDecryOK = FALSE;
 
@@ -718,7 +721,6 @@ device_receive_frame (
                 }
                 return FALSE;
             }
-
    //mike add:station mode check eapol-key challenge--->
    	  {
    	    BYTE  Protocol_Version;    //802.1x Authentication
@@ -742,8 +744,10 @@ device_receive_frame (
         }
     }
 
+
 // Data frame Handle
 
+
     if (pDevice->bEnablePSMode) {
         if (IS_FC_MOREDATA((skb->data+4))) {
             if (BITbIsBitOn(*pbyRsr, RSR_ADDROK)) {
@@ -890,12 +894,11 @@ device_receive_frame (
                             pDevice->dev->name);
                     }
                 }
-
-//2008-0409-07, <Add> by Einsn Liu
+               //2008-0409-07, <Add> by Einsn Liu
        #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 				//send event to wpa_supplicant
 				//if(pDevice->bWPADevEnable == TRUE)
-					{
+				{
 					union iwreq_data wrqu;
 					struct iw_michaelmicfailure ev;
 					int keyidx = pbyFrame[cbHeaderSize+3] >> 6; //top two-bits
@@ -917,6 +920,8 @@ device_receive_frame (
 
 				}
          #endif
+
+
                 if ((pDevice->bWPADEVUp) && (pDevice->skb != NULL)) {
                      wpahdr = (viawget_wpa_header *)pDevice->skb->data;
                      if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
@@ -1067,6 +1072,7 @@ device_receive_frame (
         }
         return FALSE;
     }
+
     return TRUE;
 }
 
@@ -1429,6 +1435,7 @@ static BOOL s_bHostWepRxEncryption (
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);
 
         if (byDecMode == KEY_CTL_TKIP) {
+
             if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || (bOnFly == FALSE)) {
                 // Software TKIP
                 // 1. 3253 A
@@ -1471,8 +1478,6 @@ static BOOL s_bHostWepRxEncryption (
 
 
 
-
-
 static BOOL s_bAPModeRxData (
     IN PSDevice pDevice,
     IN struct sk_buff* skb,
@@ -1487,9 +1492,9 @@ static BOOL s_bAPModeRxData (
     BOOL                bRelayOnly = FALSE;
     BYTE                byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
     WORD                wAID;
-    struct sk_buff* skbcpy = NULL;
 
 
+    struct sk_buff* skbcpy = NULL;
 
     if (FrameSize > CB_MAX_BUF_SIZE)
         return FALSE;
@@ -1498,6 +1503,7 @@ static BOOL s_bAPModeRxData (
        if (pMgmt->sNodeDBTable[0].bPSEnable) {
 
            skbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);
+
         // if any node in PS mode, buffer packet until DTIM.
            if (skbcpy == NULL) {
                DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");
@@ -1507,6 +1513,7 @@ static BOOL s_bAPModeRxData (
                skbcpy->len = FrameSize;
                memcpy(skbcpy->data, skb->data+cbHeaderOffset, FrameSize);
                skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skbcpy);
+
                pMgmt->sNodeDBTable[0].wEnQueueCnt++;
                // set tx map
                pMgmt->abyPSTxMap[0] |= byMask[0];

commit 7e809a9b10ab5ee985e23dea537e0236f026d1ca
Author: Jim Lieb <lieb@canonical.com>
Date:   Thu Jul 30 10:27:21 2009 -0700

    Staging: vt6655 textual cleanup in prep for driver merge
    
    The vt6655 and vt6656 drivers are from a common origin but
    have drifted apart with minor textual differences.  There
    are two changes:
    
      s/DEVICE_PRT/DBG_PRT/g
    
    and
    
      s/byPktTyp/byPktType/g
    
    This significantly reduces the differences between the two file sets
    in preparation to merging the common code.  A few whitespace and text bits were
    also adjusted.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Cc: Forest Bond <forest@alittletooquiet.net>
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index a3abce98df0a..f7a5a662a3b5 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -418,7 +418,7 @@ device_receive_frame (
     PS802_11Header pMACHeader;
  BOOL            bRxeapol_key = FALSE;
 
-//    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- device_receive_frame---\n");
+//    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- device_receive_frame---\n");
 
     skb = pRDInfo->skb;
 
@@ -436,7 +436,7 @@ device_receive_frame (
     // Min (ACK): 10HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
     if ((FrameSize > 2364)||(FrameSize <= 32)) {
         // Frame Size error drop this packet.
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- WRONG Length 1 \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- WRONG Length 1 \n");
         return FALSE;
     }
 
@@ -454,7 +454,7 @@ device_receive_frame (
 
     if ((FrameSize > 2346)|(FrameSize < 14)) { // Max: 2312Payload + 30HD +4CRC
                                                // Min: 14 bytes ACK
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- WRONG Length 2 \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- WRONG Length 2 \n");
         return FALSE;
     }
 //PLICE_DEBUG->
@@ -535,7 +535,7 @@ device_receive_frame (
     if (IS_FC_WEP(pbyFrame)) {
         BOOL     bRxDecryOK = FALSE;
 
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"rx WEP pkt\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"rx WEP pkt\n");
         bIsWEP = TRUE;
         if ((pDevice->bEnableHostWEP) && (iSANodeIndex >= 0)) {
             pKey = &STempKey;
@@ -573,7 +573,7 @@ device_receive_frame (
 
         if (bRxDecryOK) {
             if ((*pbyNewRsr & NEWRSR_DECRYPTOK) == 0) {
-                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV Fail\n");
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV Fail\n");
                 if ( (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||
                     (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||
                     (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||
@@ -591,7 +591,7 @@ device_receive_frame (
                 return FALSE;
             }
         } else {
-            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"WEP Func Fail\n");
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"WEP Func Fail\n");
             return FALSE;
         }
         if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP))
@@ -699,7 +699,7 @@ device_receive_frame (
             if (BITbIsBitOff(*pbyRsr, RSR_BSSIDOK)) {
                 if (bDeFragRx) {
                     if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-                        DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                        DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
                         pDevice->dev->name);
                     }
                 }
@@ -712,7 +712,7 @@ device_receive_frame (
                 BITbIsBitOff(*pbyRsr, RSR_BSSIDOK)) {
                 if (bDeFragRx) {
                     if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-                        DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                        DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
                         pDevice->dev->name);
                     }
                 }
@@ -798,7 +798,7 @@ device_receive_frame (
         wEtherType = (skb->data[cbIVOffset + 4 + 24 + 6] << 8) |
                     skb->data[cbIVOffset + 4 + 24 + 6 + 1];
 
-	    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"wEtherType = %04x \n", wEtherType);
+	    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"wEtherType = %04x \n", wEtherType);
         if (wEtherType == ETH_P_PAE) {
             skb->dev = pDevice->apdev;
 
@@ -875,18 +875,18 @@ device_receive_frame (
             pdwMIC_R = (PDWORD)(skb->data + 4 + FrameSize + 4);
             //DBG_PRN_GRP12(("RxL: %lx, RxR: %lx\n", *pdwMIC_L, *pdwMIC_R));
             //DBG_PRN_GRP12(("LocalL: %lx, LocalR: %lx\n", dwLocalMIC_L, dwLocalMIC_R));
-            //DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"dwMICKey0= %lx,dwMICKey1= %lx \n", dwMICKey0, dwMICKey1);
+            //DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"dwMICKey0= %lx,dwMICKey1= %lx \n", dwMICKey0, dwMICKey1);
 
 
             if ((cpu_to_le32(*pdwMIC_L) != dwLocalMIC_L) || (cpu_to_le32(*pdwMIC_R) != dwLocalMIC_R) ||
                 (pDevice->bRxMICFail == TRUE)) {
-                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC comparison is fail!\n");
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC comparison is fail!\n");
                 pDevice->bRxMICFail = FALSE;
                 //pDevice->s802_11Counter.TKIPLocalMICFailures.QuadPart++;
                 pDevice->s802_11Counter.TKIPLocalMICFailures++;
                 if (bDeFragRx) {
                     if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-                        DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                        DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
                             pDevice->dev->name);
                     }
                 }
@@ -970,7 +970,7 @@ device_receive_frame (
                 if ( (wRxTSC15_0 < wLocalTSC15_0) &&
                      (dwRxTSC47_16 <= dwLocalTSC47_16) &&
                      !((dwRxTSC47_16 == 0) && (dwLocalTSC47_16 == 0xFFFFFFFF))) {
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC is illegal~~!\n ");
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC is illegal~~!\n ");
                     if (pKey->byCipherSuite == KEY_CTL_TKIP)
                         //pDevice->s802_11Counter.TKIPReplays.QuadPart++;
                         pDevice->s802_11Counter.TKIPReplays++;
@@ -980,7 +980,7 @@ device_receive_frame (
 
                     if (bDeFragRx) {
                         if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-                            DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
                                 pDevice->dev->name);
                         }
                     }
@@ -1016,7 +1016,7 @@ device_receive_frame (
 
             if (bDeFragRx) {
                 if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-                    DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                    DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
                     pDevice->dev->name);
                 }
             }
@@ -1046,7 +1046,7 @@ device_receive_frame (
 			pStats->rx_dropped++;
             if (bDeFragRx) {
                 if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-                    DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                    DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
                     pDevice->dev->name);
                 }
             }
@@ -1062,7 +1062,7 @@ device_receive_frame (
 
     if (bDeFragRx) {
         if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
-            DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
                 pDevice->dev->name);
         }
         return FALSE;
@@ -1100,7 +1100,7 @@ static BOOL s_bAPModeRxCtl (
                                          (WLAN_MGMT_REASON_CLASS2_NONAUTH),
                                          &Status
                                          );
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 1\n");
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 1\n");
                     return TRUE;
                 };
                 if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_ASSOC) {
@@ -1112,7 +1112,7 @@ static BOOL s_bAPModeRxCtl (
                                          (WLAN_MGMT_REASON_CLASS3_NONASSOC),
                                          &Status
                                          );
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDisassocBeginSta 2\n");
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDisassocBeginSta 2\n");
                     return TRUE;
                 };
 
@@ -1121,7 +1121,7 @@ static BOOL s_bAPModeRxCtl (
                     if (IS_CTL_PSPOLL(pbyFrame)) {
                         pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;
                         bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-                        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 1\n");
+                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 1\n");
                     }
                     else {
                         // check Data PS state
@@ -1130,7 +1130,7 @@ static BOOL s_bAPModeRxCtl (
                             pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = FALSE;
                             pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;
                             bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-                            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 2\n");
+                            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 2\n");
                         }
                     }
                 }
@@ -1146,7 +1146,7 @@ static BOOL s_bAPModeRxCtl (
                           pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = FALSE;
                           pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;
                           bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
-                         DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 3\n");
+                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 3\n");
 
                       }
                    }
@@ -1159,8 +1159,8 @@ static BOOL s_bAPModeRxCtl (
                                        (WLAN_MGMT_REASON_CLASS2_NONAUTH),
                                        &Status
                                        );
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 3\n");
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "BSSID:%02x-%02x-%02x=%02x-%02x-%02x \n",
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 3\n");
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "BSSID:%02x-%02x-%02x=%02x-%02x-%02x \n",
                                 p802_11Header->abyAddr3[0],
                                 p802_11Header->abyAddr3[1],
                                 p802_11Header->abyAddr3[2],
@@ -1168,7 +1168,7 @@ static BOOL s_bAPModeRxCtl (
                                 p802_11Header->abyAddr3[4],
                                 p802_11Header->abyAddr3[5]
                                );
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR2:%02x-%02x-%02x=%02x-%02x-%02x \n",
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR2:%02x-%02x-%02x=%02x-%02x-%02x \n",
                                 p802_11Header->abyAddr2[0],
                                 p802_11Header->abyAddr2[1],
                                 p802_11Header->abyAddr2[2],
@@ -1176,7 +1176,7 @@ static BOOL s_bAPModeRxCtl (
                                 p802_11Header->abyAddr2[4],
                                 p802_11Header->abyAddr2[5]
                                );
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR1:%02x-%02x-%02x=%02x-%02x-%02x \n",
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR1:%02x-%02x-%02x=%02x-%02x-%02x \n",
                                 p802_11Header->abyAddr1[0],
                                 p802_11Header->abyAddr1[1],
                                 p802_11Header->abyAddr1[2],
@@ -1184,9 +1184,9 @@ static BOOL s_bAPModeRxCtl (
                                 p802_11Header->abyAddr1[4],
                                 p802_11Header->abyAddr1[5]
                                );
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: wFrameCtl= %x\n", p802_11Header->wFrameCtl );
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: wFrameCtl= %x\n", p802_11Header->wFrameCtl );
                     VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc:pDevice->byRxMode = %x\n", pDevice->byRxMode );
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc:pDevice->byRxMode = %x\n", pDevice->byRxMode );
                     return TRUE;
             }
         }
@@ -1226,7 +1226,7 @@ static BOOL s_bHandleRxEncryption (
     }
     byKeyIdx = (*(pbyIV+3) & 0xc0);
     byKeyIdx >>= 6;
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"\nKeyIdx: %d\n", byKeyIdx);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"\nKeyIdx: %d\n", byKeyIdx);
 
     if ((pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||
         (pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||
@@ -1236,14 +1236,14 @@ static BOOL s_bHandleRxEncryption (
         if (((*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) &&
             (pDevice->pMgmt->byCSSPK != KEY_CTL_NONE)) {
             // unicast pkt use pairwise key
-            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt\n");
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt\n");
             if (KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, 0xFFFFFFFF, &pKey) == TRUE) {
                 if (pDevice->pMgmt->byCSSPK == KEY_CTL_TKIP)
                     byDecMode = KEY_CTL_TKIP;
                 else if (pDevice->pMgmt->byCSSPK == KEY_CTL_CCMP)
                     byDecMode = KEY_CTL_CCMP;
             }
-            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt: %d, %p\n", byDecMode, pKey);
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt: %d, %p\n", byDecMode, pKey);
         } else {
             // use group key
             KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, byKeyIdx, &pKey);
@@ -1251,7 +1251,7 @@ static BOOL s_bHandleRxEncryption (
                 byDecMode = KEY_CTL_TKIP;
             else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
                 byDecMode = KEY_CTL_CCMP;
-            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"group pkt: %d, %d, %p\n", byKeyIdx, byDecMode, pKey);
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"group pkt: %d, %d, %p\n", byKeyIdx, byDecMode, pKey);
         }
     }
     // our WEP only support Default Key
@@ -1265,10 +1265,10 @@ static BOOL s_bHandleRxEncryption (
     }
     *pKeyOut = pKey;
 
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
 
     if (pKey == NULL) {
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey == NULL\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey == NULL\n");
         if (byDecMode == KEY_CTL_WEP) {
 //            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
         } else if (pDevice->bLinkPass == TRUE) {
@@ -1309,13 +1309,13 @@ static BOOL s_bHandleRxEncryption (
 
         PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
         *pdwRxTSC47_16 = cpu_to_le32(*(PDWORD)(pbyIV + 4));
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);
         if (byDecMode == KEY_CTL_TKIP) {
             *pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
         } else {
             *pwRxTSC15_0 = cpu_to_le16(*(PWORD)pbyIV);
         }
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);
 
         if ((byDecMode == KEY_CTL_TKIP) &&
             (pDevice->byLocalID <= REV_ID_VT3253_A1)) {
@@ -1327,10 +1327,10 @@ static BOOL s_bHandleRxEncryption (
             rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);
             if (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {
                 *pbyNewRsr |= NEWRSR_DECRYPTOK;
-                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV OK!\n");
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV OK!\n");
             } else {
-                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV FAIL!!!\n");
-                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"PayloadLen = %d\n", PayloadLen);
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV FAIL!!!\n");
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"PayloadLen = %d\n", PayloadLen);
             }
         }
     }// end of TKIP/AES
@@ -1373,7 +1373,7 @@ static BOOL s_bHostWepRxEncryption (
     }
     byKeyIdx = (*(pbyIV+3) & 0xc0);
     byKeyIdx >>= 6;
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"\nKeyIdx: %d\n", byKeyIdx);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"\nKeyIdx: %d\n", byKeyIdx);
 
 
     if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
@@ -1381,7 +1381,7 @@ static BOOL s_bHostWepRxEncryption (
     else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
         byDecMode = KEY_CTL_CCMP;
 
-    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
+    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
 
     if (byDecMode != pKey->byCipherSuite) {
         if (byDecMode == KEY_CTL_WEP) {
@@ -1394,7 +1394,7 @@ static BOOL s_bHostWepRxEncryption (
 
     if (byDecMode == KEY_CTL_WEP) {
         // handle WEP
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"byDecMode == KEY_CTL_WEP \n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"byDecMode == KEY_CTL_WEP \n");
         if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
             (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == TRUE) ||
             (bOnFly == FALSE)) {
@@ -1419,31 +1419,31 @@ static BOOL s_bHostWepRxEncryption (
 
         PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
         *pdwRxTSC47_16 = cpu_to_le32(*(PDWORD)(pbyIV + 4));
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);
 
         if (byDecMode == KEY_CTL_TKIP) {
             *pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
         } else {
             *pwRxTSC15_0 = cpu_to_le16(*(PWORD)pbyIV);
         }
-        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);
 
         if (byDecMode == KEY_CTL_TKIP) {
             if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || (bOnFly == FALSE)) {
                 // Software TKIP
                 // 1. 3253 A
                 // 2. NotOnFly
-                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_TKIP \n");
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_TKIP \n");
                 pMACHeader = (PS802_11Header) (pbyFrame);
                 TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
                 rc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);
                 rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);
                 if (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {
                     *pbyNewRsr |= NEWRSR_DECRYPTOK;
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV OK!\n");
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV OK!\n");
                 } else {
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV FAIL!!!\n");
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"PayloadLen = %d\n", PayloadLen);
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV FAIL!!!\n");
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"PayloadLen = %d\n", PayloadLen);
                 }
             }
         }
@@ -1452,12 +1452,12 @@ static BOOL s_bHostWepRxEncryption (
             if (bOnFly == FALSE) {
                 // Software CCMP
                 // NotOnFly
-                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_CCMP\n");
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_CCMP\n");
                 if (AESbGenCCMP(pKey->abyKey, pbyFrame, FrameSize)) {
                     *pbyNewRsr |= NEWRSR_DECRYPTOK;
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CCMP MIC compare OK!\n");
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CCMP MIC compare OK!\n");
                 } else {
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CCMP MIC fail!\n");
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CCMP MIC fail!\n");
                 }
             }
         }
@@ -1500,7 +1500,7 @@ static BOOL s_bAPModeRxData (
            skbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);
         // if any node in PS mode, buffer packet until DTIM.
            if (skbcpy == NULL) {
-               DEVICE_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");
+               DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");
            }
            else {
                skbcpy->dev = pDevice->dev;
@@ -1530,7 +1530,7 @@ static BOOL s_bAPModeRxData (
                     pMgmt->sNodeDBTable[iDANodeIndex].wEnQueueCnt++;
                     wAID = pMgmt->sNodeDBTable[iDANodeIndex].wAID;
                     pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
-                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "relay: index= %d, pMgmt->abyPSTxMap[%d]= %d\n",
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "relay: index= %d, pMgmt->abyPSTxMap[%d]= %d\n",
                                iDANodeIndex, (wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);
                     return TRUE;
                 }

commit db6cb9036b2756c50efc43127c476786ea92eae2
Author: Jim Lieb <lieb@canonical.com>
Date:   Thu Jul 23 17:20:49 2009 -0700

    Staging: vt665x: 64bit compile fixes Part 1
    
    Fix compile problems with 64bit.  These issues could cause corrupted
    address crashes.  In the process, replaced some definitions to use more
    portable kernel types.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 11611982a990..a3abce98df0a 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -680,7 +680,7 @@ device_receive_frame (
 	            skb->data += 4;
 	            skb->tail += 4;
                      skb_put(skb, FrameSize);
-	            skb->mac_header = skb->data;
+		skb_reset_mac_header(skb);
 	            skb->pkt_type = PACKET_OTHERHOST;
     	        skb->protocol = htons(ETH_P_802_2);
 	            memset(skb->cb, 0, sizeof(skb->cb));
@@ -810,7 +810,7 @@ device_receive_frame (
             skb->data +=  (cbIVOffset + 4);
             skb->tail +=  (cbIVOffset + 4);
             skb_put(skb, FrameSize);
-           skb->mac_header = skb->data;
+	    skb_reset_mac_header(skb);
 
 	skb->pkt_type = PACKET_OTHERHOST;
             skb->protocol = htons(ETH_P_802_2);
@@ -932,7 +932,7 @@ device_receive_frame (
                      wpahdr->req_ie_len = 0;
                      skb_put(pDevice->skb, sizeof(viawget_wpa_header));
                      pDevice->skb->dev = pDevice->wpadev;
-                     pDevice->skb->mac_header = pDevice->skb->data;
+		     skb_reset_mac_header(pDevice->skb);
                      pDevice->skb->pkt_type = PACKET_HOST;
                      pDevice->skb->protocol = htons(ETH_P_802_2);
                      memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));

commit 83a27326ee616d6b6dcdd074ad088554a52f9b11
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 10 21:48:16 2009 +0200

    Staging: vt6655: remove PRIVATE_OBJ ifdefs
    
    Cc: Forest Bond <forest@alittletooquiet.net>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index acc6d82a9544..11611982a990 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -143,17 +143,6 @@ static BOOL s_bAPModeRxCtl(
     IN INT      iSANodeIndex
     );
 
-#ifdef PRIVATE_OBJ
-
-static BOOL s_bAPModeRxData (
-    IN PSDevice pDevice,
-    IN ref_sk_buff* skb,
-    IN UINT     FrameSize,
-    IN UINT     cbHeaderOffset,
-    IN INT      iSANodeIndex,
-    IN INT      iDANodeIndex
-    );
-#else
 
 static BOOL s_bAPModeRxData (
     IN PSDevice pDevice,
@@ -163,7 +152,6 @@ static BOOL s_bAPModeRxData (
     IN INT      iSANodeIndex,
     IN INT      iDANodeIndex
     );
-#endif
 
 
 static BOOL s_bHandleRxEncryption(
@@ -395,11 +383,7 @@ device_receive_frame (
 	//printk("device_receive_frame:pCurrRD is %x,pRDInfo is %x\n",pCurrRD,pCurrRD->pRDInfo);
 #endif
     struct net_device_stats* pStats=&pDevice->stats;
-#ifdef PRIVATE_OBJ
-    ref_sk_buff*    skb;
-#else
     struct sk_buff* skb;
-#endif
     PSMgmtObject    pMgmt = pDevice->pMgmt;
     PSRxMgmtPacket  pRxPacket = &(pDevice->pMgmt->sRxPacket);
     PS802_11Header  p802_11Header;
@@ -435,12 +419,8 @@ device_receive_frame (
  BOOL            bRxeapol_key = FALSE;
 
 //    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- device_receive_frame---\n");
-#ifdef PRIVATE_OBJ
-    skb = &(pRDInfo->ref_skb);
-#else
 
     skb = pRDInfo->skb;
-#endif
 
 
 //PLICE_DEBUG->
@@ -541,11 +521,7 @@ device_receive_frame (
             p802_11Header = (PS802_11Header) (pbyFrame);
             // get SA NodeIndex
             if (BSSDBbIsSTAInNodeDB(pMgmt, (PBYTE)(p802_11Header->abyAddr2), &iSANodeIndex)) {
-#ifdef PRIVATE_OBJ
-                pMgmt->sNodeDBTable[iSANodeIndex].ulLastRxJiffer = get_jiffies();
-#else
                 pMgmt->sNodeDBTable[iSANodeIndex].ulLastRxJiffer = jiffies;
-#endif
                 pMgmt->sNodeDBTable[iSANodeIndex].uInActiveCount = 0;
             }
         }
@@ -639,11 +615,7 @@ device_receive_frame (
         pDevice->s802_11Counter.ReceivedFragmentCount++;
         if (bDeFragRx) {
             // defrag complete
-#ifdef PRIVATE_OBJ
-            skb = &(pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].ref_skb);
-#else
             skb = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].skb;
-#endif
             FrameSize = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].cbFrameLength;
 
         }
@@ -705,16 +677,6 @@ device_receive_frame (
             // hostap Deamon handle 802.11 management
             if (pDevice->bEnableHostapd) {
 	            skb->dev = pDevice->apdev;
-#ifdef PRIVATE_OBJ
-                ref_skb_add_offset(skb->skb, 4);
-                ref_skb_set_dev(pDevice->apdev, skb->skb);
-                skb_put(skb->skb, FrameSize);
-	            skb->mac_header = skb->data;
-	            *(skb->pkt_type) = PACKET_OTHERHOST;
-    	        *(skb->protocol) = htons(ETH_P_802_2);
-	            memset(skb->cb, 0, sizeof(skb->cb));
-	            netif_rx(skb->skb);
-#else
 	            skb->data += 4;
 	            skb->tail += 4;
                      skb_put(skb, FrameSize);
@@ -723,7 +685,6 @@ device_receive_frame (
     	        skb->protocol = htons(ETH_P_802_2);
 	            memset(skb->cb, 0, sizeof(skb->cb));
 	            netif_rx(skb);
-#endif
                 return TRUE;
 	        }
         }
@@ -846,16 +807,6 @@ device_receive_frame (
                 memcpy(&abyMacHdr[0], (skb->data + 4), 24);
                 memcpy((skb->data + 4 + cbIVOffset), &abyMacHdr[0], 24);
             }
-#ifdef PRIVATE_OBJ
-            ref_skb_add_offset(skb->skb, (cbIVOffset + 4));
-            ref_skb_set_dev(pDevice->apdev, skb->skb);
-            skb_put(skb->skb, FrameSize);
-			skb->mac_header = skb->data;
-            *(skb->pkt_type) = PACKET_OTHERHOST;
-	        *(skb->protocol) = htons(ETH_P_802_2);
-            memset(skb->cb, 0, sizeof(skb->cb));
-            netif_rx(skb->skb);
-#else
             skb->data +=  (cbIVOffset + 4);
             skb->tail +=  (cbIVOffset + 4);
             skb_put(skb, FrameSize);
@@ -865,7 +816,6 @@ device_receive_frame (
             skb->protocol = htons(ETH_P_802_2);
             memset(skb->cb, 0, sizeof(skb->cb));
             netif_rx(skb);
-#endif
             return TRUE;
 
 }
@@ -1081,29 +1031,17 @@ device_receive_frame (
 
     }
 
-#ifdef PRIVATE_OBJ
-    ref_skb_add_offset(skb->skb, cbHeaderOffset);
-    skb_put(skb->skb, FrameSize);
-    *(skb->protocol)=eth_type_trans(skb->skb, skb->dev);
-
-#else
 	skb->data += cbHeaderOffset;
 	skb->tail += cbHeaderOffset;
     skb_put(skb, FrameSize);
     skb->protocol=eth_type_trans(skb, skb->dev);
-#endif
 
 
 	//drop frame not met IEEE 802.3
 /*
 	if (pDevice->flags & DEVICE_FLAGS_VAL_PKT_LEN) {
-#ifdef PRIVATE_OBJ
-		if ((*(skb->protocol)==htons(ETH_P_802_3)) &&
-			(*(skb->len)!=htons(skb->mac.ethernet->h_proto))) {
-#else
 		if ((skb->protocol==htons(ETH_P_802_3)) &&
 			(skb->len!=htons(skb->mac.ethernet->h_proto))) {
-#endif
 			pStats->rx_length_errors++;
 			pStats->rx_dropped++;
             if (bDeFragRx) {
@@ -1117,17 +1055,10 @@ device_receive_frame (
 	}
 */
 
-#ifdef PRIVATE_OBJ
-    *(skb->ip_summed)=CHECKSUM_NONE;
-    pStats->rx_bytes +=*(skb->len);
-    pStats->rx_packets++;
-    netif_rx(skb->skb);
-#else
     skb->ip_summed=CHECKSUM_NONE;
     pStats->rx_bytes +=skb->len;
     pStats->rx_packets++;
     netif_rx(skb);
-#endif
 
     if (bDeFragRx) {
         if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
@@ -1541,18 +1472,6 @@ static BOOL s_bHostWepRxEncryption (
 
 
 
-#ifdef PRIVATE_OBJ
-
-static BOOL s_bAPModeRxData (
-    IN PSDevice pDevice,
-    IN ref_sk_buff* skb,
-    IN UINT     FrameSize,
-    IN UINT     cbHeaderOffset,
-    IN INT      iSANodeIndex,
-    IN INT      iDANodeIndex
-    )
-
-#else
 
 static BOOL s_bAPModeRxData (
     IN PSDevice pDevice,
@@ -1562,20 +1481,13 @@ static BOOL s_bAPModeRxData (
     IN INT      iSANodeIndex,
     IN INT      iDANodeIndex
     )
-#endif
 {
     PSMgmtObject        pMgmt = pDevice->pMgmt;
     BOOL                bRelayAndForward = FALSE;
     BOOL                bRelayOnly = FALSE;
     BYTE                byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
     WORD                wAID;
-#ifdef PRIVATE_OBJ
-    struct sk_buff* tmp_skb;
-    ref_sk_buff     s_ref_skb;
-    ref_sk_buff*    skbcpy = &s_ref_skb;
-#else
     struct sk_buff* skbcpy = NULL;
-#endif
 
 
 
@@ -1585,28 +1497,16 @@ static BOOL s_bAPModeRxData (
     if(IS_MULTICAST_ADDRESS((PBYTE)(skb->data+cbHeaderOffset))) {
        if (pMgmt->sNodeDBTable[0].bPSEnable) {
 
-#ifdef PRIVATE_OBJ
-           tmp_skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-           skbcpy = &s_ref_skb;
-           ref_skb_remap(pDevice->dev, skbcpy, tmp_skb);
-#else
            skbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);
-#endif
         // if any node in PS mode, buffer packet until DTIM.
            if (skbcpy == NULL) {
                DEVICE_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");
            }
            else {
                skbcpy->dev = pDevice->dev;
-#ifdef PRIVATE_OBJ
-               *(skbcpy->len) = FrameSize;
-               memcpy(skbcpy->data, skb->data+cbHeaderOffset, FrameSize);
-               skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skbcpy->skb);
-#else
                skbcpy->len = FrameSize;
                memcpy(skbcpy->data, skb->data+cbHeaderOffset, FrameSize);
                skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skbcpy);
-#endif
                pMgmt->sNodeDBTable[0].wEnQueueCnt++;
                // set tx map
                pMgmt->abyPSTxMap[0] |= byMask[0];
@@ -1623,16 +1523,10 @@ static BOOL s_bAPModeRxData (
                 if (pMgmt->sNodeDBTable[iDANodeIndex].bPSEnable) {
                     // queue this skb until next PS tx, and then release.
 
-#ifdef PRIVATE_OBJ
-                    ref_skb_add_offset(skb->skb, cbHeaderOffset);
-                    skb_put(skb->skb, FrameSize);
-                    skb_queue_tail(&pMgmt->sNodeDBTable[iDANodeIndex].sTxPSQueue, skb->skb);
-#else
 	                skb->data += cbHeaderOffset;
 	                skb->tail += cbHeaderOffset;
                     skb_put(skb, FrameSize);
                     skb_queue_tail(&pMgmt->sNodeDBTable[iDANodeIndex].sTxPSQueue, skb);
-#endif
                     pMgmt->sNodeDBTable[iDANodeIndex].wEnQueueCnt++;
                     wAID = pMgmt->sNodeDBTable[iDANodeIndex].wAID;
                     pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];

commit 7bb8dc2d7eb5594ec890e822bb0517446d369698
Author: Forest Bond <forest@alittletooquiet.net>
Date:   Mon Jun 1 20:00:35 2009 -0400

    Staging: vt6655: Remove LINUX_VERSION_CODE preprocessor conditionals.
    
    vt6655: Remove LINUX_VERSION_CODE preprocessor conditionals.
    
    Signed-off-by: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
index 05366b9754f0..acc6d82a9544 100644
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -709,11 +709,7 @@ device_receive_frame (
                 ref_skb_add_offset(skb->skb, 4);
                 ref_skb_set_dev(pDevice->apdev, skb->skb);
                 skb_put(skb->skb, FrameSize);
-#if	LINUX_VERSION_CODE	> KERNEL_VERSION(2,6,21)
 	            skb->mac_header = skb->data;
-#else
-			skb->mac.raw = skb->data;
-#endif
 	            *(skb->pkt_type) = PACKET_OTHERHOST;
     	        *(skb->protocol) = htons(ETH_P_802_2);
 	            memset(skb->cb, 0, sizeof(skb->cb));
@@ -722,11 +718,7 @@ device_receive_frame (
 	            skb->data += 4;
 	            skb->tail += 4;
                      skb_put(skb, FrameSize);
-#if	LINUX_VERSION_CODE > KERNEL_VERSION (2,6,21)
 	            skb->mac_header = skb->data;
-#else
-		skb->mac.raw = skb->data;
-#endif
 	            skb->pkt_type = PACKET_OTHERHOST;
     	        skb->protocol = htons(ETH_P_802_2);
 	            memset(skb->cb, 0, sizeof(skb->cb));
@@ -858,11 +850,7 @@ device_receive_frame (
             ref_skb_add_offset(skb->skb, (cbIVOffset + 4));
             ref_skb_set_dev(pDevice->apdev, skb->skb);
             skb_put(skb->skb, FrameSize);
-#if	LINUX_VERSION_CODE	> KERNEL_VERSION(2,6,21)
 			skb->mac_header = skb->data;
-#else
-			skb->mac.raw = skb->data;
-#endif
             *(skb->pkt_type) = PACKET_OTHERHOST;
 	        *(skb->protocol) = htons(ETH_P_802_2);
             memset(skb->cb, 0, sizeof(skb->cb));
@@ -871,11 +859,7 @@ device_receive_frame (
             skb->data +=  (cbIVOffset + 4);
             skb->tail +=  (cbIVOffset + 4);
             skb_put(skb, FrameSize);
-#if	LINUX_VERSION_CODE	> KERNEL_VERSION(2,6,21)
            skb->mac_header = skb->data;
-#else
-	skb->mac.raw = skb->data;
-#endif
 
 	skb->pkt_type = PACKET_OTHERHOST;
             skb->protocol = htons(ETH_P_802_2);
@@ -998,12 +982,8 @@ device_receive_frame (
                      wpahdr->req_ie_len = 0;
                      skb_put(pDevice->skb, sizeof(viawget_wpa_header));
                      pDevice->skb->dev = pDevice->wpadev;
-#if	LINUX_VERSION_CODE	> KERNEL_VERSION(2,6,21)
-		pDevice->skb->mac_header = pDevice->skb->data;
-#else
-		pDevice->skb->mac.raw=pDevice->skb->data;
-#endif
-			pDevice->skb->pkt_type = PACKET_HOST;
+                     pDevice->skb->mac_header = pDevice->skb->data;
+                     pDevice->skb->pkt_type = PACKET_HOST;
                      pDevice->skb->protocol = htons(ETH_P_802_2);
                      memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
                      netif_rx(pDevice->skb);

commit 5449c685a4b39534f18869a93896370224463715
Author: Forest Bond <forest@alittletooquiet.net>
Date:   Sat Apr 25 10:30:44 2009 -0400

    Staging: Add pristine upstream vt6655 driver sources
    
    Add pristine upstream vt6655 driver sources to drivers/staging/vt6655.  These
    files were literally copied from the driver directory in the upstream source
    archive, available here:
    
      http://www.viaarena.com/Driver/vt6655_linux_src_v1.19.12_x86.zip
    
    Signed-off-by: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6655/dpc.c b/drivers/staging/vt6655/dpc.c
new file mode 100644
index 000000000000..05366b9754f0
--- /dev/null
+++ b/drivers/staging/vt6655/dpc.c
@@ -0,0 +1,1688 @@
+/*
+ * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * File: dpc.c
+ *
+ * Purpose: handle dpc rx functions
+ *
+ * Author: Lyndon Chen
+ *
+ * Date: May 20, 2003
+ *
+ * Functions:
+ *      device_receive_frame - Rcv 802.11 frame function
+ *      s_bAPModeRxCtl- AP Rcv frame filer Ctl.
+ *      s_bAPModeRxData- AP Rcv data frame handle
+ *      s_bHandleRxEncryption- Rcv decrypted data via on-fly
+ *      s_bHostWepRxEncryption- Rcv encrypted data via host
+ *      s_byGetRateIdx- get rate index
+ *      s_vGetDASA- get data offset
+ *      s_vProcessRxMACHeader- Rcv 802.11 and translate to 802.3
+ *
+ * Revision History:
+ *
+ */
+
+
+#if !defined(__DEVICE_H__)
+#include "device.h"
+#endif
+#if !defined(__RXTX_H__)
+#include "rxtx.h"
+#endif
+#if !defined(__TETHER_H__)
+#include "tether.h"
+#endif
+#if !defined(__CARD_H__)
+#include "card.h"
+#endif
+#if !defined(__BSSDB_H__)
+#include "bssdb.h"
+#endif
+#if !defined(__MAC_H__)
+#include "mac.h"
+#endif
+#if !defined(__BASEBAND_H__)
+#include "baseband.h"
+#endif
+#if !defined(__UMEM_H__)
+#include "umem.h"
+#endif
+#if !defined(__MICHAEL_H__)
+#include "michael.h"
+#endif
+#if !defined(__TKIP_H__)
+#include "tkip.h"
+#endif
+#if !defined(__TCRC_H__)
+#include "tcrc.h"
+#endif
+#if !defined(__WCTL_H__)
+#include "wctl.h"
+#endif
+#if !defined(__WROUTE_H__)
+#include "wroute.h"
+#endif
+#if !defined(__TBIT_H__)
+#include "tbit.h"
+#endif
+#if !defined(__HOSTAP_H__)
+#include "hostap.h"
+#endif
+#if !defined(__RF_H__)
+#include "rf.h"
+#endif
+#if !defined(__IOWPA_H__)
+#include "iowpa.h"
+#endif
+#if !defined(__AES_H__)
+#include "aes_ccmp.h"
+#endif
+
+//#define	PLICE_DEBUG
+
+
+/*---------------------  Static Definitions -------------------------*/
+
+/*---------------------  Static Classes  ----------------------------*/
+
+/*---------------------  Static Variables  --------------------------*/
+//static int          msglevel                =MSG_LEVEL_DEBUG;
+static int          msglevel                =MSG_LEVEL_INFO;
+
+const BYTE acbyRxRate[MAX_RATE] =
+{2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108};
+
+
+/*---------------------  Static Functions  --------------------------*/
+
+/*---------------------  Static Definitions -------------------------*/
+
+/*---------------------  Static Functions  --------------------------*/
+
+static BYTE s_byGetRateIdx(IN BYTE byRate);
+
+
+static
+VOID
+s_vGetDASA(
+    IN  PBYTE pbyRxBufferAddr,
+    OUT PUINT pcbHeaderSize,
+    OUT PSEthernetHeader psEthHeader
+    );
+
+static
+VOID
+s_vProcessRxMACHeader (
+    IN  PSDevice pDevice,
+    IN  PBYTE pbyRxBufferAddr,
+    IN  UINT cbPacketSize,
+    IN  BOOL bIsWEP,
+    IN  BOOL bExtIV,
+    OUT PUINT pcbHeadSize
+    );
+
+static BOOL s_bAPModeRxCtl(
+    IN PSDevice pDevice,
+    IN PBYTE    pbyFrame,
+    IN INT      iSANodeIndex
+    );
+
+#ifdef PRIVATE_OBJ
+
+static BOOL s_bAPModeRxData (
+    IN PSDevice pDevice,
+    IN ref_sk_buff* skb,
+    IN UINT     FrameSize,
+    IN UINT     cbHeaderOffset,
+    IN INT      iSANodeIndex,
+    IN INT      iDANodeIndex
+    );
+#else
+
+static BOOL s_bAPModeRxData (
+    IN PSDevice pDevice,
+    IN struct sk_buff* skb,
+    IN UINT     FrameSize,
+    IN UINT     cbHeaderOffset,
+    IN INT      iSANodeIndex,
+    IN INT      iDANodeIndex
+    );
+#endif
+
+
+static BOOL s_bHandleRxEncryption(
+    IN PSDevice     pDevice,
+    IN PBYTE        pbyFrame,
+    IN UINT         FrameSize,
+    IN PBYTE        pbyRsr,
+    OUT PBYTE       pbyNewRsr,
+    OUT PSKeyItem   *pKeyOut,
+    OUT PBOOL       pbExtIV,
+    OUT PWORD       pwRxTSC15_0,
+    OUT PDWORD      pdwRxTSC47_16
+    );
+
+static BOOL s_bHostWepRxEncryption(
+
+    IN PSDevice     pDevice,
+    IN PBYTE        pbyFrame,
+    IN UINT         FrameSize,
+    IN PBYTE        pbyRsr,
+    IN BOOL         bOnFly,
+    IN PSKeyItem    pKey,
+    OUT PBYTE       pbyNewRsr,
+    OUT PBOOL       pbExtIV,
+    OUT PWORD       pwRxTSC15_0,
+    OUT PDWORD      pdwRxTSC47_16
+
+    );
+
+/*---------------------  Export Variables  --------------------------*/
+
+/*+
+ *
+ * Description:
+ *    Translate Rcv 802.11 header to 802.3 header with Rx buffer
+ *
+ * Parameters:
+ *  In:
+ *      pDevice
+ *      dwRxBufferAddr  - Address of Rcv Buffer
+ *      cbPacketSize    - Rcv Packet size
+ *      bIsWEP          - If Rcv with WEP
+ *  Out:
+ *      pcbHeaderSize   - 802.11 header size
+ *
+ * Return Value: None
+ *
+-*/
+static
+VOID
+s_vProcessRxMACHeader (
+    IN  PSDevice pDevice,
+    IN  PBYTE pbyRxBufferAddr,
+    IN  UINT cbPacketSize,
+    IN  BOOL bIsWEP,
+    IN  BOOL bExtIV,
+    OUT PUINT pcbHeadSize
+    )
+{
+    PBYTE           pbyRxBuffer;
+    UINT            cbHeaderSize = 0;
+    PWORD           pwType;
+    PS802_11Header  pMACHeader;
+    int             ii;
+
+
+    pMACHeader = (PS802_11Header) (pbyRxBufferAddr + cbHeaderSize);
+
+    s_vGetDASA((PBYTE)pMACHeader, &cbHeaderSize, &pDevice->sRxEthHeader);
+
+    if (bIsWEP) {
+        if (bExtIV) {
+            // strip IV&ExtIV , add 8 byte
+            cbHeaderSize += (WLAN_HDR_ADDR3_LEN + 8);
+        } else {
+            // strip IV , add 4 byte
+            cbHeaderSize += (WLAN_HDR_ADDR3_LEN + 4);
+        }
+    }
+    else {
+        cbHeaderSize += WLAN_HDR_ADDR3_LEN;
+    };
+
+    pbyRxBuffer = (PBYTE) (pbyRxBufferAddr + cbHeaderSize);
+    if (IS_ETH_ADDRESS_EQUAL(pbyRxBuffer, &pDevice->abySNAP_Bridgetunnel[0])) {
+        cbHeaderSize += 6;
+    }
+    else if (IS_ETH_ADDRESS_EQUAL(pbyRxBuffer, &pDevice->abySNAP_RFC1042[0])) {
+        cbHeaderSize += 6;
+        pwType = (PWORD) (pbyRxBufferAddr + cbHeaderSize);
+        if ((*pwType!= TYPE_PKT_IPX) && (*pwType != cpu_to_le16(0xF380))) {
+        }
+        else {
+            cbHeaderSize -= 8;
+            pwType = (PWORD) (pbyRxBufferAddr + cbHeaderSize);
+            if (bIsWEP) {
+                if (bExtIV) {
+                    *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    // 8 is IV&ExtIV
+                } else {
+                    *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    // 4 is IV
+                }
+            }
+            else {
+                *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
+            }
+        }
+    }
+    else {
+        cbHeaderSize -= 2;
+        pwType = (PWORD) (pbyRxBufferAddr + cbHeaderSize);
+        if (bIsWEP) {
+            if (bExtIV) {
+                *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);    // 8 is IV&ExtIV
+            } else {
+                *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);    // 4 is IV
+            }
+        }
+        else {
+            *pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);
+        }
+    }
+
+    cbHeaderSize -= (U_ETHER_ADDR_LEN * 2);
+    pbyRxBuffer = (PBYTE) (pbyRxBufferAddr + cbHeaderSize);
+    for(ii=0;ii<U_ETHER_ADDR_LEN;ii++)
+        *pbyRxBuffer++ = pDevice->sRxEthHeader.abyDstAddr[ii];
+    for(ii=0;ii<U_ETHER_ADDR_LEN;ii++)
+        *pbyRxBuffer++ = pDevice->sRxEthHeader.abySrcAddr[ii];
+
+    *pcbHeadSize = cbHeaderSize;
+}
+
+
+
+
+static BYTE s_byGetRateIdx (IN BYTE byRate)
+{
+    BYTE    byRateIdx;
+
+    for (byRateIdx = 0; byRateIdx <MAX_RATE ; byRateIdx++) {
+        if (acbyRxRate[byRateIdx%MAX_RATE] == byRate)
+            return byRateIdx;
+    }
+    return 0;
+}
+
+
+static
+VOID
+s_vGetDASA (
+    IN  PBYTE pbyRxBufferAddr,
+    OUT PUINT pcbHeaderSize,
+    OUT PSEthernetHeader psEthHeader
+    )
+{
+    UINT            cbHeaderSize = 0;
+    PS802_11Header  pMACHeader;
+    int             ii;
+
+    pMACHeader = (PS802_11Header) (pbyRxBufferAddr + cbHeaderSize);
+
+    if ((pMACHeader->wFrameCtl & FC_TODS) == 0) {
+        if (pMACHeader->wFrameCtl & FC_FROMDS) {
+            for(ii=0;ii<U_ETHER_ADDR_LEN;ii++) {
+                psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
+                psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr3[ii];
+            }
+        }
+        else {
+            // IBSS mode
+            for(ii=0;ii<U_ETHER_ADDR_LEN;ii++) {
+                psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr1[ii];
+                psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
+            }
+        }
+    }
+    else {
+        // Is AP mode..
+        if (pMACHeader->wFrameCtl & FC_FROMDS) {
+            for(ii=0;ii<U_ETHER_ADDR_LEN;ii++) {
+                psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr3[ii];
+                psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr4[ii];
+                cbHeaderSize += 6;
+            }
+        }
+        else {
+            for(ii=0;ii<U_ETHER_ADDR_LEN;ii++) {
+                psEthHeader->abyDstAddr[ii] = pMACHeader->abyAddr3[ii];
+                psEthHeader->abySrcAddr[ii] = pMACHeader->abyAddr2[ii];
+            }
+        }
+    };
+    *pcbHeaderSize = cbHeaderSize;
+}
+
+
+
+
+//PLICE_DEBUG ->
+
+VOID	MngWorkItem(PVOID Context)
+{
+	PSRxMgmtPacket			pRxMgmtPacket;
+	PSDevice	pDevice =  (PSDevice) Context;
+	//printk("Enter MngWorkItem,Queue packet num is %d\n",pDevice->rxManeQueue.packet_num);
+	spin_lock_irq(&pDevice->lock);
+	 while(pDevice->rxManeQueue.packet_num != 0)
+	 {
+		 pRxMgmtPacket =  DeQueue(pDevice);
+        		vMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);
+	}
+	spin_unlock_irq(&pDevice->lock);
+}
+
+
+//PLICE_DEBUG<-
+
+
+
+BOOL
+device_receive_frame (
+    IN  PSDevice pDevice,
+    IN  PSRxDesc pCurrRD
+    )
+{
+
+    PDEVICE_RD_INFO  pRDInfo = pCurrRD->pRDInfo;
+#ifdef	PLICE_DEBUG
+	//printk("device_receive_frame:pCurrRD is %x,pRDInfo is %x\n",pCurrRD,pCurrRD->pRDInfo);
+#endif
+    struct net_device_stats* pStats=&pDevice->stats;
+#ifdef PRIVATE_OBJ
+    ref_sk_buff*    skb;
+#else
+    struct sk_buff* skb;
+#endif
+    PSMgmtObject    pMgmt = pDevice->pMgmt;
+    PSRxMgmtPacket  pRxPacket = &(pDevice->pMgmt->sRxPacket);
+    PS802_11Header  p802_11Header;
+    PBYTE           pbyRsr;
+    PBYTE           pbyNewRsr;
+    PBYTE           pbyRSSI;
+    PQWORD          pqwTSFTime;
+    PWORD           pwFrameSize;
+    PBYTE           pbyFrame;
+    BOOL            bDeFragRx = FALSE;
+    BOOL            bIsWEP = FALSE;
+    UINT            cbHeaderOffset;
+    UINT            FrameSize;
+    WORD            wEtherType = 0;
+    INT             iSANodeIndex = -1;
+    INT             iDANodeIndex = -1;
+    UINT            ii;
+    UINT            cbIVOffset;
+    BOOL            bExtIV = FALSE;
+    PBYTE           pbyRxSts;
+    PBYTE           pbyRxRate;
+    PBYTE           pbySQ;
+    UINT            cbHeaderSize;
+    PSKeyItem       pKey = NULL;
+    WORD            wRxTSC15_0 = 0;
+    DWORD           dwRxTSC47_16 = 0;
+    SKeyItem        STempKey;
+    // 802.11h RPI
+    DWORD           dwDuration = 0;
+    LONG            ldBm = 0;
+    LONG            ldBmThreshold = 0;
+    PS802_11Header pMACHeader;
+ BOOL            bRxeapol_key = FALSE;
+
+//    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- device_receive_frame---\n");
+#ifdef PRIVATE_OBJ
+    skb = &(pRDInfo->ref_skb);
+#else
+
+    skb = pRDInfo->skb;
+#endif
+
+
+//PLICE_DEBUG->
+#if 1
+	pci_unmap_single(pDevice->pcid, pRDInfo->skb_dma,
+                     pDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);
+#endif
+//PLICE_DEBUG<-
+    pwFrameSize = (PWORD)(skb->data + 2);
+    FrameSize = cpu_to_le16(pCurrRD->m_rd1RD1.wReqCount) - cpu_to_le16(pCurrRD->m_rd0RD0.wResCount);
+
+    // Max: 2312Payload + 30HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
+    // Min (ACK): 10HD +4CRC + 2Padding + 4Len + 8TSF + 4RSR
+    if ((FrameSize > 2364)||(FrameSize <= 32)) {
+        // Frame Size error drop this packet.
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- WRONG Length 1 \n");
+        return FALSE;
+    }
+
+    pbyRxSts = (PBYTE) (skb->data);
+    pbyRxRate = (PBYTE) (skb->data + 1);
+    pbyRsr = (PBYTE) (skb->data + FrameSize - 1);
+    pbyRSSI = (PBYTE) (skb->data + FrameSize - 2);
+    pbyNewRsr = (PBYTE) (skb->data + FrameSize - 3);
+    pbySQ = (PBYTE) (skb->data + FrameSize - 4);
+    pqwTSFTime = (PQWORD) (skb->data + FrameSize - 12);
+    pbyFrame = (PBYTE)(skb->data + 4);
+
+    // get packet size
+    FrameSize = cpu_to_le16(*pwFrameSize);
+
+    if ((FrameSize > 2346)|(FrameSize < 14)) { // Max: 2312Payload + 30HD +4CRC
+                                               // Min: 14 bytes ACK
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- WRONG Length 2 \n");
+        return FALSE;
+    }
+//PLICE_DEBUG->
+#if 1
+	// update receive statistic counter
+    STAvUpdateRDStatCounter(&pDevice->scStatistic,
+                            *pbyRsr,
+                            *pbyNewRsr,
+                            *pbyRxRate,
+                            pbyFrame,
+                            FrameSize);
+
+#endif
+
+  pMACHeader=(PS802_11Header)((PBYTE) (skb->data)+8);
+//PLICE_DEBUG<-
+	if (pDevice->bMeasureInProgress == TRUE) {
+        if ((*pbyRsr & RSR_CRCOK) != 0) {
+            pDevice->byBasicMap |= 0x01;
+        }
+        dwDuration = (FrameSize << 4);
+        dwDuration /= acbyRxRate[*pbyRxRate%MAX_RATE];
+        if (*pbyRxRate <= RATE_11M) {
+            if (BITbIsBitOn(*pbyRxSts, 0x01)) {
+                // long preamble
+                dwDuration += 192;
+            } else {
+                // short preamble
+                dwDuration += 96;
+            }
+        } else {
+            dwDuration += 16;
+        }
+        RFvRSSITodBm(pDevice, *pbyRSSI, &ldBm);
+        ldBmThreshold = -57;
+        for (ii = 7; ii > 0;) {
+            if (ldBm > ldBmThreshold) {
+                break;
+            }
+            ldBmThreshold -= 5;
+            ii--;
+        }
+        pDevice->dwRPIs[ii] += dwDuration;
+        return FALSE;
+    }
+
+    if (!IS_MULTICAST_ADDRESS(pbyFrame) && !IS_BROADCAST_ADDRESS(pbyFrame)) {
+        if (WCTLbIsDuplicate(&(pDevice->sDupRxCache), (PS802_11Header) (skb->data + 4))) {
+            pDevice->s802_11Counter.FrameDuplicateCount++;
+            return FALSE;
+        }
+    }
+
+
+    // Use for TKIP MIC
+    s_vGetDASA(skb->data+4, &cbHeaderSize, &pDevice->sRxEthHeader);
+
+    // filter packet send from myself
+    if (IS_ETH_ADDRESS_EQUAL((PBYTE)&(pDevice->sRxEthHeader.abySrcAddr[0]), pDevice->abyCurrentNetAddr))
+        return FALSE;
+
+    if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) || (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)) {
+        if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
+            p802_11Header = (PS802_11Header) (pbyFrame);
+            // get SA NodeIndex
+            if (BSSDBbIsSTAInNodeDB(pMgmt, (PBYTE)(p802_11Header->abyAddr2), &iSANodeIndex)) {
+#ifdef PRIVATE_OBJ
+                pMgmt->sNodeDBTable[iSANodeIndex].ulLastRxJiffer = get_jiffies();
+#else
+                pMgmt->sNodeDBTable[iSANodeIndex].ulLastRxJiffer = jiffies;
+#endif
+                pMgmt->sNodeDBTable[iSANodeIndex].uInActiveCount = 0;
+            }
+        }
+    }
+
+    if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+        if (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex) == TRUE) {
+            return FALSE;
+        }
+    }
+    if (IS_FC_WEP(pbyFrame)) {
+        BOOL     bRxDecryOK = FALSE;
+
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"rx WEP pkt\n");
+        bIsWEP = TRUE;
+        if ((pDevice->bEnableHostWEP) && (iSANodeIndex >= 0)) {
+            pKey = &STempKey;
+            pKey->byCipherSuite = pMgmt->sNodeDBTable[iSANodeIndex].byCipherSuite;
+            pKey->dwKeyIndex = pMgmt->sNodeDBTable[iSANodeIndex].dwKeyIndex;
+            pKey->uKeyLength = pMgmt->sNodeDBTable[iSANodeIndex].uWepKeyLength;
+            pKey->dwTSC47_16 = pMgmt->sNodeDBTable[iSANodeIndex].dwTSC47_16;
+            pKey->wTSC15_0 = pMgmt->sNodeDBTable[iSANodeIndex].wTSC15_0;
+            memcpy(pKey->abyKey,
+                &pMgmt->sNodeDBTable[iSANodeIndex].abyWepKey[0],
+                pKey->uKeyLength
+                );
+
+            bRxDecryOK = s_bHostWepRxEncryption(pDevice,
+                                                pbyFrame,
+                                                FrameSize,
+                                                pbyRsr,
+                                                pMgmt->sNodeDBTable[iSANodeIndex].bOnFly,
+                                                pKey,
+                                                pbyNewRsr,
+                                                &bExtIV,
+                                                &wRxTSC15_0,
+                                                &dwRxTSC47_16);
+        } else {
+            bRxDecryOK = s_bHandleRxEncryption(pDevice,
+                                                pbyFrame,
+                                                FrameSize,
+                                                pbyRsr,
+                                                pbyNewRsr,
+                                                &pKey,
+                                                &bExtIV,
+                                                &wRxTSC15_0,
+                                                &dwRxTSC47_16);
+        }
+
+        if (bRxDecryOK) {
+            if ((*pbyNewRsr & NEWRSR_DECRYPTOK) == 0) {
+                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV Fail\n");
+                if ( (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||
+                    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||
+                    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||
+                    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||
+                    (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {
+
+                    if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
+                        pDevice->s802_11Counter.TKIPICVErrors++;
+                    } else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP)) {
+                        pDevice->s802_11Counter.CCMPDecryptErrors++;
+                    } else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_WEP)) {
+//                      pDevice->s802_11Counter.WEPICVErrorCount.QuadPart++;
+                    }
+                }
+                return FALSE;
+            }
+        } else {
+            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"WEP Func Fail\n");
+            return FALSE;
+        }
+        if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP))
+            FrameSize -= 8;         // Message Integrity Code
+        else
+            FrameSize -= 4;         // 4 is ICV
+    }
+
+
+    //
+    // RX OK
+    //
+    //remove the CRC length
+    FrameSize -= U_CRC_LEN;
+
+    if ((BITbIsAllBitsOff(*pbyRsr, (RSR_ADDRBROAD | RSR_ADDRMULTI))) && // unicast address
+        (IS_FRAGMENT_PKT((skb->data+4)))
+        ) {
+        // defragment
+        bDeFragRx = WCTLbHandleFragment(pDevice, (PS802_11Header) (skb->data+4), FrameSize, bIsWEP, bExtIV);
+        pDevice->s802_11Counter.ReceivedFragmentCount++;
+        if (bDeFragRx) {
+            // defrag complete
+#ifdef PRIVATE_OBJ
+            skb = &(pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].ref_skb);
+#else
+            skb = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].skb;
+#endif
+            FrameSize = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].cbFrameLength;
+
+        }
+        else {
+            return FALSE;
+        }
+    }
+
+
+// Management & Control frame Handle
+    if ((IS_TYPE_DATA((skb->data+4))) == FALSE) {
+        // Handle Control & Manage Frame
+
+        if (IS_TYPE_MGMT((skb->data+4))) {
+            PBYTE pbyData1;
+            PBYTE pbyData2;
+
+            pRxPacket->p80211Header = (PUWLAN_80211HDR)(skb->data+4);
+            pRxPacket->cbMPDULen = FrameSize;
+            pRxPacket->uRSSI = *pbyRSSI;
+            pRxPacket->bySQ = *pbySQ;
+            HIDWORD(pRxPacket->qwLocalTSF) = cpu_to_le32(HIDWORD(*pqwTSFTime));
+            LODWORD(pRxPacket->qwLocalTSF) = cpu_to_le32(LODWORD(*pqwTSFTime));
+            if (bIsWEP) {
+                // strip IV
+                pbyData1 = WLAN_HDR_A3_DATA_PTR(skb->data+4);
+                pbyData2 = WLAN_HDR_A3_DATA_PTR(skb->data+4) + 4;
+                for (ii = 0; ii < (FrameSize - 4); ii++) {
+                    *pbyData1 = *pbyData2;
+                     pbyData1++;
+                     pbyData2++;
+                }
+            }
+            pRxPacket->byRxRate = s_byGetRateIdx(*pbyRxRate);
+            pRxPacket->byRxChannel = (*pbyRxSts) >> 2;
+//PLICE_DEBUG->
+//EnQueue(pDevice,pRxPacket);
+
+#ifdef	THREAD
+		EnQueue(pDevice,pRxPacket);
+
+		//printk("enque time is %x\n",jiffies);
+		//up(&pDevice->mlme_semaphore);
+			//Enque (pDevice->FirstRecvMngList,pDevice->LastRecvMngList,pMgmt);
+#else
+
+#ifdef	TASK_LET
+		EnQueue(pDevice,pRxPacket);
+		tasklet_schedule(&pDevice->RxMngWorkItem);
+#else
+//printk("RxMan\n");
+	vMgrRxManagePacket((HANDLE)pDevice, pDevice->pMgmt, pRxPacket);
+           //tasklet_schedule(&pDevice->RxMngWorkItem);
+#endif
+
+#endif
+//PLICE_DEBUG<-
+			//vMgrRxManagePacket((HANDLE)pDevice, pDevice->pMgmt, pRxPacket);
+            // hostap Deamon handle 802.11 management
+            if (pDevice->bEnableHostapd) {
+	            skb->dev = pDevice->apdev;
+#ifdef PRIVATE_OBJ
+                ref_skb_add_offset(skb->skb, 4);
+                ref_skb_set_dev(pDevice->apdev, skb->skb);
+                skb_put(skb->skb, FrameSize);
+#if	LINUX_VERSION_CODE	> KERNEL_VERSION(2,6,21)
+	            skb->mac_header = skb->data;
+#else
+			skb->mac.raw = skb->data;
+#endif
+	            *(skb->pkt_type) = PACKET_OTHERHOST;
+    	        *(skb->protocol) = htons(ETH_P_802_2);
+	            memset(skb->cb, 0, sizeof(skb->cb));
+	            netif_rx(skb->skb);
+#else
+	            skb->data += 4;
+	            skb->tail += 4;
+                     skb_put(skb, FrameSize);
+#if	LINUX_VERSION_CODE > KERNEL_VERSION (2,6,21)
+	            skb->mac_header = skb->data;
+#else
+		skb->mac.raw = skb->data;
+#endif
+	            skb->pkt_type = PACKET_OTHERHOST;
+    	        skb->protocol = htons(ETH_P_802_2);
+	            memset(skb->cb, 0, sizeof(skb->cb));
+	            netif_rx(skb);
+#endif
+                return TRUE;
+	        }
+        }
+        else {
+            // Control Frame
+        };
+        return FALSE;
+    }
+    else {
+        if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+            //In AP mode, hw only check addr1(BSSID or RA) if equal to local MAC.
+            if (BITbIsBitOff(*pbyRsr, RSR_BSSIDOK)) {
+                if (bDeFragRx) {
+                    if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+                        DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                        pDevice->dev->name);
+                    }
+                }
+                return FALSE;
+            }
+        }
+        else {
+            // discard DATA packet while not associate || BSSID error
+            if ((pDevice->bLinkPass == FALSE) ||
+                BITbIsBitOff(*pbyRsr, RSR_BSSIDOK)) {
+                if (bDeFragRx) {
+                    if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+                        DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                        pDevice->dev->name);
+                    }
+                }
+                return FALSE;
+            }
+
+   //mike add:station mode check eapol-key challenge--->
+   	  {
+   	    BYTE  Protocol_Version;    //802.1x Authentication
+	    BYTE  Packet_Type;           //802.1x Authentication
+              if (bIsWEP)
+                  cbIVOffset = 8;
+              else
+                  cbIVOffset = 0;
+              wEtherType = (skb->data[cbIVOffset + 8 + 24 + 6] << 8) |
+                          skb->data[cbIVOffset + 8 + 24 + 6 + 1];
+	      Protocol_Version = skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1];
+	      Packet_Type = skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1+1];
+	     if (wEtherType == ETH_P_PAE) {         //Protocol Type in LLC-Header
+                  if(((Protocol_Version==1) ||(Protocol_Version==2)) &&
+		     (Packet_Type==3)) {  //802.1x OR eapol-key challenge frame receive
+                        bRxeapol_key = TRUE;
+                  }
+	      }
+   	  }
+    //mike add:station mode check eapol-key challenge<---
+        }
+    }
+
+// Data frame Handle
+
+    if (pDevice->bEnablePSMode) {
+        if (IS_FC_MOREDATA((skb->data+4))) {
+            if (BITbIsBitOn(*pbyRsr, RSR_ADDROK)) {
+                //PSbSendPSPOLL((PSDevice)pDevice);
+            }
+        }
+        else {
+            if (pDevice->pMgmt->bInTIMWake == TRUE) {
+                pDevice->pMgmt->bInTIMWake = FALSE;
+            }
+        }
+    };
+
+    // Now it only supports 802.11g Infrastructure Mode, and support rate must up to 54 Mbps
+    if (pDevice->bDiversityEnable && (FrameSize>50) &&
+        (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE) &&
+        (pDevice->bLinkPass == TRUE)) {
+	//printk("device_receive_frame: RxRate is %d\n",*pbyRxRate);
+		BBvAntennaDiversity(pDevice, s_byGetRateIdx(*pbyRxRate), 0);
+    }
+
+
+    if (pDevice->byLocalID != REV_ID_VT3253_B1) {
+        pDevice->uCurrRSSI = *pbyRSSI;
+    }
+    pDevice->byCurrSQ = *pbySQ;
+
+    if ((*pbyRSSI != 0) &&
+        (pMgmt->pCurrBSS!=NULL)) {
+        RFvRSSITodBm(pDevice, *pbyRSSI, &ldBm);
+        // Moniter if RSSI is too strong.
+        pMgmt->pCurrBSS->byRSSIStatCnt++;
+        pMgmt->pCurrBSS->byRSSIStatCnt %= RSSI_STAT_COUNT;
+        pMgmt->pCurrBSS->ldBmAverage[pMgmt->pCurrBSS->byRSSIStatCnt] = ldBm;
+        for(ii=0;ii<RSSI_STAT_COUNT;ii++) {
+            if (pMgmt->pCurrBSS->ldBmAverage[ii] != 0) {
+            pMgmt->pCurrBSS->ldBmMAX = max(pMgmt->pCurrBSS->ldBmAverage[ii], ldBm);
+            }
+        }
+    }
+
+    // -----------------------------------------------
+
+    if ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) && (pDevice->bEnable8021x == TRUE)){
+        BYTE    abyMacHdr[24];
+
+        // Only 802.1x packet incoming allowed
+        if (bIsWEP)
+            cbIVOffset = 8;
+        else
+            cbIVOffset = 0;
+        wEtherType = (skb->data[cbIVOffset + 4 + 24 + 6] << 8) |
+                    skb->data[cbIVOffset + 4 + 24 + 6 + 1];
+
+	    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"wEtherType = %04x \n", wEtherType);
+        if (wEtherType == ETH_P_PAE) {
+            skb->dev = pDevice->apdev;
+
+            if (bIsWEP == TRUE) {
+                // strip IV header(8)
+                memcpy(&abyMacHdr[0], (skb->data + 4), 24);
+                memcpy((skb->data + 4 + cbIVOffset), &abyMacHdr[0], 24);
+            }
+#ifdef PRIVATE_OBJ
+            ref_skb_add_offset(skb->skb, (cbIVOffset + 4));
+            ref_skb_set_dev(pDevice->apdev, skb->skb);
+            skb_put(skb->skb, FrameSize);
+#if	LINUX_VERSION_CODE	> KERNEL_VERSION(2,6,21)
+			skb->mac_header = skb->data;
+#else
+			skb->mac.raw = skb->data;
+#endif
+            *(skb->pkt_type) = PACKET_OTHERHOST;
+	        *(skb->protocol) = htons(ETH_P_802_2);
+            memset(skb->cb, 0, sizeof(skb->cb));
+            netif_rx(skb->skb);
+#else
+            skb->data +=  (cbIVOffset + 4);
+            skb->tail +=  (cbIVOffset + 4);
+            skb_put(skb, FrameSize);
+#if	LINUX_VERSION_CODE	> KERNEL_VERSION(2,6,21)
+           skb->mac_header = skb->data;
+#else
+	skb->mac.raw = skb->data;
+#endif
+
+	skb->pkt_type = PACKET_OTHERHOST;
+            skb->protocol = htons(ETH_P_802_2);
+            memset(skb->cb, 0, sizeof(skb->cb));
+            netif_rx(skb);
+#endif
+            return TRUE;
+
+}
+        // check if 802.1x authorized
+        if (!(pMgmt->sNodeDBTable[iSANodeIndex].dwFlags & WLAN_STA_AUTHORIZED))
+            return FALSE;
+    }
+
+
+    if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
+        if (bIsWEP) {
+            FrameSize -= 8;  //MIC
+        }
+    }
+
+    //--------------------------------------------------------------------------------
+    // Soft MIC
+    if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {
+        if (bIsWEP) {
+            PDWORD          pdwMIC_L;
+            PDWORD          pdwMIC_R;
+            DWORD           dwMIC_Priority;
+            DWORD           dwMICKey0 = 0, dwMICKey1 = 0;
+            DWORD           dwLocalMIC_L = 0;
+            DWORD           dwLocalMIC_R = 0;
+            viawget_wpa_header *wpahdr;
+
+
+            if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+                dwMICKey0 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[24]));
+                dwMICKey1 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[28]));
+            }
+            else {
+                if (pDevice->pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) {
+                    dwMICKey0 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[16]));
+                    dwMICKey1 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[20]));
+                } else if ((pKey->dwKeyIndex & BIT28) == 0) {
+                    dwMICKey0 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[16]));
+                    dwMICKey1 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[20]));
+                } else {
+                    dwMICKey0 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[24]));
+                    dwMICKey1 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[28]));
+                }
+            }
+
+            MIC_vInit(dwMICKey0, dwMICKey1);
+            MIC_vAppend((PBYTE)&(pDevice->sRxEthHeader.abyDstAddr[0]), 12);
+            dwMIC_Priority = 0;
+            MIC_vAppend((PBYTE)&dwMIC_Priority, 4);
+            // 4 is Rcv buffer header, 24 is MAC Header, and 8 is IV and Ext IV.
+            MIC_vAppend((PBYTE)(skb->data + 4 + WLAN_HDR_ADDR3_LEN + 8),
+                        FrameSize - WLAN_HDR_ADDR3_LEN - 8);
+            MIC_vGetMIC(&dwLocalMIC_L, &dwLocalMIC_R);
+            MIC_vUnInit();
+
+            pdwMIC_L = (PDWORD)(skb->data + 4 + FrameSize);
+            pdwMIC_R = (PDWORD)(skb->data + 4 + FrameSize + 4);
+            //DBG_PRN_GRP12(("RxL: %lx, RxR: %lx\n", *pdwMIC_L, *pdwMIC_R));
+            //DBG_PRN_GRP12(("LocalL: %lx, LocalR: %lx\n", dwLocalMIC_L, dwLocalMIC_R));
+            //DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"dwMICKey0= %lx,dwMICKey1= %lx \n", dwMICKey0, dwMICKey1);
+
+
+            if ((cpu_to_le32(*pdwMIC_L) != dwLocalMIC_L) || (cpu_to_le32(*pdwMIC_R) != dwLocalMIC_R) ||
+                (pDevice->bRxMICFail == TRUE)) {
+                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC comparison is fail!\n");
+                pDevice->bRxMICFail = FALSE;
+                //pDevice->s802_11Counter.TKIPLocalMICFailures.QuadPart++;
+                pDevice->s802_11Counter.TKIPLocalMICFailures++;
+                if (bDeFragRx) {
+                    if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+                        DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                            pDevice->dev->name);
+                    }
+                }
+
+//2008-0409-07, <Add> by Einsn Liu
+       #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+				//send event to wpa_supplicant
+				//if(pDevice->bWPADevEnable == TRUE)
+					{
+					union iwreq_data wrqu;
+					struct iw_michaelmicfailure ev;
+					int keyidx = pbyFrame[cbHeaderSize+3] >> 6; //top two-bits
+					memset(&ev, 0, sizeof(ev));
+					ev.flags = keyidx & IW_MICFAILURE_KEY_ID;
+					if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
+							(pMgmt->eCurrState == WMAC_STATE_ASSOC) &&
+								(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) {
+						ev.flags |= IW_MICFAILURE_PAIRWISE;
+					} else {
+						ev.flags |= IW_MICFAILURE_GROUP;
+					}
+
+					ev.src_addr.sa_family = ARPHRD_ETHER;
+					memcpy(ev.src_addr.sa_data, pMACHeader->abyAddr2, ETH_ALEN);
+					memset(&wrqu, 0, sizeof(wrqu));
+					wrqu.data.length = sizeof(ev);
+					wireless_send_event(pDevice->dev, IWEVMICHAELMICFAILURE, &wrqu, (char *)&ev);
+
+				}
+         #endif
+                if ((pDevice->bWPADEVUp) && (pDevice->skb != NULL)) {
+                     wpahdr = (viawget_wpa_header *)pDevice->skb->data;
+                     if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
+                         (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC) &&
+                         (*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) {
+                         //s802_11_Status.Flags = NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR;
+                         wpahdr->type = VIAWGET_PTK_MIC_MSG;
+                     } else {
+                         //s802_11_Status.Flags = NDIS_802_11_AUTH_REQUEST_GROUP_ERROR;
+                         wpahdr->type = VIAWGET_GTK_MIC_MSG;
+                     }
+                     wpahdr->resp_ie_len = 0;
+                     wpahdr->req_ie_len = 0;
+                     skb_put(pDevice->skb, sizeof(viawget_wpa_header));
+                     pDevice->skb->dev = pDevice->wpadev;
+#if	LINUX_VERSION_CODE	> KERNEL_VERSION(2,6,21)
+		pDevice->skb->mac_header = pDevice->skb->data;
+#else
+		pDevice->skb->mac.raw=pDevice->skb->data;
+#endif
+			pDevice->skb->pkt_type = PACKET_HOST;
+                     pDevice->skb->protocol = htons(ETH_P_802_2);
+                     memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
+                     netif_rx(pDevice->skb);
+                     pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
+                 };
+
+                return FALSE;
+
+            }
+        }
+    } //---end of SOFT MIC-----------------------------------------------------------------------
+
+    // ++++++++++ Reply Counter Check +++++++++++++
+
+    if ((pKey != NULL) && ((pKey->byCipherSuite == KEY_CTL_TKIP) ||
+                           (pKey->byCipherSuite == KEY_CTL_CCMP))) {
+        if (bIsWEP) {
+            WORD        wLocalTSC15_0 = 0;
+            DWORD       dwLocalTSC47_16 = 0;
+            ULONGLONG       RSC = 0;
+            // endian issues
+            RSC = *((ULONGLONG *) &(pKey->KeyRSC));
+            wLocalTSC15_0 = (WORD) RSC;
+            dwLocalTSC47_16 = (DWORD) (RSC>>16);
+
+            RSC = dwRxTSC47_16;
+            RSC <<= 16;
+            RSC += wRxTSC15_0;
+            MEMvCopy(&(pKey->KeyRSC), &RSC,  sizeof(QWORD));
+
+            if ( (pDevice->sMgmtObj.eCurrMode == WMAC_MODE_ESS_STA) &&
+                 (pDevice->sMgmtObj.eCurrState == WMAC_STATE_ASSOC)) {
+                // check RSC
+                if ( (wRxTSC15_0 < wLocalTSC15_0) &&
+                     (dwRxTSC47_16 <= dwLocalTSC47_16) &&
+                     !((dwRxTSC47_16 == 0) && (dwLocalTSC47_16 == 0xFFFFFFFF))) {
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC is illegal~~!\n ");
+                    if (pKey->byCipherSuite == KEY_CTL_TKIP)
+                        //pDevice->s802_11Counter.TKIPReplays.QuadPart++;
+                        pDevice->s802_11Counter.TKIPReplays++;
+                    else
+                        //pDevice->s802_11Counter.CCMPReplays.QuadPart++;
+                        pDevice->s802_11Counter.CCMPReplays++;
+
+                    if (bDeFragRx) {
+                        if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+                            DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                                pDevice->dev->name);
+                        }
+                    }
+                    return FALSE;
+                }
+            }
+        }
+    } // ----- End of Reply Counter Check --------------------------
+
+
+
+    if ((pKey != NULL) && (bIsWEP)) {
+//      pDevice->s802_11Counter.DecryptSuccessCount.QuadPart++;
+    }
+
+
+    s_vProcessRxMACHeader(pDevice, (PBYTE)(skb->data+4), FrameSize, bIsWEP, bExtIV, &cbHeaderOffset);
+    FrameSize -= cbHeaderOffset;
+    cbHeaderOffset += 4;        // 4 is Rcv buffer header
+
+    // Null data, framesize = 14
+    if (FrameSize < 15)
+        return FALSE;
+
+    if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+        if (s_bAPModeRxData(pDevice,
+                            skb,
+                            FrameSize,
+                            cbHeaderOffset,
+                            iSANodeIndex,
+                            iDANodeIndex
+                            ) == FALSE) {
+
+            if (bDeFragRx) {
+                if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+                    DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                    pDevice->dev->name);
+                }
+            }
+            return FALSE;
+        }
+
+//        if(pDevice->bRxMICFail == FALSE) {
+//           for (ii =0; ii < 100; ii++)
+//                printk(" %02x", *(skb->data + ii));
+//           printk("\n");
+//	    }
+
+    }
+
+#ifdef PRIVATE_OBJ
+    ref_skb_add_offset(skb->skb, cbHeaderOffset);
+    skb_put(skb->skb, FrameSize);
+    *(skb->protocol)=eth_type_trans(skb->skb, skb->dev);
+
+#else
+	skb->data += cbHeaderOffset;
+	skb->tail += cbHeaderOffset;
+    skb_put(skb, FrameSize);
+    skb->protocol=eth_type_trans(skb, skb->dev);
+#endif
+
+
+	//drop frame not met IEEE 802.3
+/*
+	if (pDevice->flags & DEVICE_FLAGS_VAL_PKT_LEN) {
+#ifdef PRIVATE_OBJ
+		if ((*(skb->protocol)==htons(ETH_P_802_3)) &&
+			(*(skb->len)!=htons(skb->mac.ethernet->h_proto))) {
+#else
+		if ((skb->protocol==htons(ETH_P_802_3)) &&
+			(skb->len!=htons(skb->mac.ethernet->h_proto))) {
+#endif
+			pStats->rx_length_errors++;
+			pStats->rx_dropped++;
+            if (bDeFragRx) {
+                if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+                    DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                    pDevice->dev->name);
+                }
+            }
+			return FALSE;
+		}
+	}
+*/
+
+#ifdef PRIVATE_OBJ
+    *(skb->ip_summed)=CHECKSUM_NONE;
+    pStats->rx_bytes +=*(skb->len);
+    pStats->rx_packets++;
+    netif_rx(skb->skb);
+#else
+    skb->ip_summed=CHECKSUM_NONE;
+    pStats->rx_bytes +=skb->len;
+    pStats->rx_packets++;
+    netif_rx(skb);
+#endif
+
+    if (bDeFragRx) {
+        if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
+            DEVICE_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
+                pDevice->dev->name);
+        }
+        return FALSE;
+    }
+    return TRUE;
+}
+
+
+static BOOL s_bAPModeRxCtl (
+    IN PSDevice pDevice,
+    IN PBYTE    pbyFrame,
+    IN INT      iSANodeIndex
+    )
+{
+    PS802_11Header      p802_11Header;
+    CMD_STATUS          Status;
+    PSMgmtObject        pMgmt = pDevice->pMgmt;
+
+
+    if (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {
+
+        p802_11Header = (PS802_11Header) (pbyFrame);
+        if (!IS_TYPE_MGMT(pbyFrame)) {
+
+            // Data & PS-Poll packet
+            // check frame class
+            if (iSANodeIndex > 0) {
+                // frame class 3 fliter & checking
+                if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_AUTH) {
+                    // send deauth notification
+                    // reason = (6) class 2 received from nonauth sta
+                    vMgrDeAuthenBeginSta(pDevice,
+                                         pMgmt,
+                                         (PBYTE)(p802_11Header->abyAddr2),
+                                         (WLAN_MGMT_REASON_CLASS2_NONAUTH),
+                                         &Status
+                                         );
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 1\n");
+                    return TRUE;
+                };
+                if (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_ASSOC) {
+                    // send deassoc notification
+                    // reason = (7) class 3 received from nonassoc sta
+                    vMgrDisassocBeginSta(pDevice,
+                                         pMgmt,
+                                         (PBYTE)(p802_11Header->abyAddr2),
+                                         (WLAN_MGMT_REASON_CLASS3_NONASSOC),
+                                         &Status
+                                         );
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDisassocBeginSta 2\n");
+                    return TRUE;
+                };
+
+                if (pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable) {
+                    // delcare received ps-poll event
+                    if (IS_CTL_PSPOLL(pbyFrame)) {
+                        pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;
+                        bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
+                        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 1\n");
+                    }
+                    else {
+                        // check Data PS state
+                        // if PW bit off, send out all PS bufferring packets.
+                        if (!IS_FC_POWERMGT(pbyFrame)) {
+                            pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = FALSE;
+                            pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;
+                            bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
+                            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 2\n");
+                        }
+                    }
+                }
+                else {
+                   if (IS_FC_POWERMGT(pbyFrame)) {
+                       pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = TRUE;
+                       // Once if STA in PS state, enable multicast bufferring
+                       pMgmt->sNodeDBTable[0].bPSEnable = TRUE;
+                   }
+                   else {
+                      // clear all pending PS frame.
+                      if (pMgmt->sNodeDBTable[iSANodeIndex].wEnQueueCnt > 0) {
+                          pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = FALSE;
+                          pMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;
+                          bScheduleCommand((HANDLE)pDevice, WLAN_CMD_RX_PSPOLL, NULL);
+                         DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 3\n");
+
+                      }
+                   }
+                }
+            }
+            else {
+                  vMgrDeAuthenBeginSta(pDevice,
+                                       pMgmt,
+                                       (PBYTE)(p802_11Header->abyAddr2),
+                                       (WLAN_MGMT_REASON_CLASS2_NONAUTH),
+                                       &Status
+                                       );
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 3\n");
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "BSSID:%02x-%02x-%02x=%02x-%02x-%02x \n",
+                                p802_11Header->abyAddr3[0],
+                                p802_11Header->abyAddr3[1],
+                                p802_11Header->abyAddr3[2],
+                                p802_11Header->abyAddr3[3],
+                                p802_11Header->abyAddr3[4],
+                                p802_11Header->abyAddr3[5]
+                               );
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR2:%02x-%02x-%02x=%02x-%02x-%02x \n",
+                                p802_11Header->abyAddr2[0],
+                                p802_11Header->abyAddr2[1],
+                                p802_11Header->abyAddr2[2],
+                                p802_11Header->abyAddr2[3],
+                                p802_11Header->abyAddr2[4],
+                                p802_11Header->abyAddr2[5]
+                               );
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR1:%02x-%02x-%02x=%02x-%02x-%02x \n",
+                                p802_11Header->abyAddr1[0],
+                                p802_11Header->abyAddr1[1],
+                                p802_11Header->abyAddr1[2],
+                                p802_11Header->abyAddr1[3],
+                                p802_11Header->abyAddr1[4],
+                                p802_11Header->abyAddr1[5]
+                               );
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: wFrameCtl= %x\n", p802_11Header->wFrameCtl );
+                    VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc:pDevice->byRxMode = %x\n", pDevice->byRxMode );
+                    return TRUE;
+            }
+        }
+    }
+    return FALSE;
+
+}
+
+static BOOL s_bHandleRxEncryption (
+    IN PSDevice     pDevice,
+    IN PBYTE        pbyFrame,
+    IN UINT         FrameSize,
+    IN PBYTE        pbyRsr,
+    OUT PBYTE       pbyNewRsr,
+    OUT PSKeyItem   *pKeyOut,
+    OUT PBOOL       pbExtIV,
+    OUT PWORD       pwRxTSC15_0,
+    OUT PDWORD      pdwRxTSC47_16
+    )
+{
+    UINT            PayloadLen = FrameSize;
+    PBYTE           pbyIV;
+    BYTE            byKeyIdx;
+    PSKeyItem       pKey = NULL;
+    BYTE            byDecMode = KEY_CTL_WEP;
+    PSMgmtObject    pMgmt = pDevice->pMgmt;
+
+
+    *pwRxTSC15_0 = 0;
+    *pdwRxTSC47_16 = 0;
+
+    pbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;
+    if ( WLAN_GET_FC_TODS(*(PWORD)pbyFrame) &&
+         WLAN_GET_FC_FROMDS(*(PWORD)pbyFrame) ) {
+         pbyIV += 6;             // 6 is 802.11 address4
+         PayloadLen -= 6;
+    }
+    byKeyIdx = (*(pbyIV+3) & 0xc0);
+    byKeyIdx >>= 6;
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"\nKeyIdx: %d\n", byKeyIdx);
+
+    if ((pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||
+        (pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||
+        (pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||
+        (pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||
+        (pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {
+        if (((*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) &&
+            (pDevice->pMgmt->byCSSPK != KEY_CTL_NONE)) {
+            // unicast pkt use pairwise key
+            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt\n");
+            if (KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, 0xFFFFFFFF, &pKey) == TRUE) {
+                if (pDevice->pMgmt->byCSSPK == KEY_CTL_TKIP)
+                    byDecMode = KEY_CTL_TKIP;
+                else if (pDevice->pMgmt->byCSSPK == KEY_CTL_CCMP)
+                    byDecMode = KEY_CTL_CCMP;
+            }
+            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt: %d, %p\n", byDecMode, pKey);
+        } else {
+            // use group key
+            KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, byKeyIdx, &pKey);
+            if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
+                byDecMode = KEY_CTL_TKIP;
+            else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
+                byDecMode = KEY_CTL_CCMP;
+            DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"group pkt: %d, %d, %p\n", byKeyIdx, byDecMode, pKey);
+        }
+    }
+    // our WEP only support Default Key
+    if (pKey == NULL) {
+        // use default group key
+        KeybGetKey(&(pDevice->sKey), pDevice->abyBroadcastAddr, byKeyIdx, &pKey);
+        if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
+            byDecMode = KEY_CTL_TKIP;
+        else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
+            byDecMode = KEY_CTL_CCMP;
+    }
+    *pKeyOut = pKey;
+
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
+
+    if (pKey == NULL) {
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey == NULL\n");
+        if (byDecMode == KEY_CTL_WEP) {
+//            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
+        } else if (pDevice->bLinkPass == TRUE) {
+//            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
+        }
+        return FALSE;
+    }
+    if (byDecMode != pKey->byCipherSuite) {
+        if (byDecMode == KEY_CTL_WEP) {
+//            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
+        } else if (pDevice->bLinkPass == TRUE) {
+//            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
+        }
+        *pKeyOut = NULL;
+        return FALSE;
+    }
+    if (byDecMode == KEY_CTL_WEP) {
+        // handle WEP
+        if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
+            (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == TRUE)) {
+            // Software WEP
+            // 1. 3253A
+            // 2. WEP 256
+
+            PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); // 24 is 802.11 header,4 is IV, 4 is crc
+            MEMvCopy(pDevice->abyPRNG, pbyIV, 3);
+            MEMvCopy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
+            rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
+            rc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);
+
+            if (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen)) {
+                *pbyNewRsr |= NEWRSR_DECRYPTOK;
+            }
+        }
+    } else if ((byDecMode == KEY_CTL_TKIP) ||
+               (byDecMode == KEY_CTL_CCMP)) {
+        // TKIP/AES
+
+        PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
+        *pdwRxTSC47_16 = cpu_to_le32(*(PDWORD)(pbyIV + 4));
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);
+        if (byDecMode == KEY_CTL_TKIP) {
+            *pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
+        } else {
+            *pwRxTSC15_0 = cpu_to_le16(*(PWORD)pbyIV);
+        }
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);
+
+        if ((byDecMode == KEY_CTL_TKIP) &&
+            (pDevice->byLocalID <= REV_ID_VT3253_A1)) {
+            // Software TKIP
+            // 1. 3253 A
+            PS802_11Header  pMACHeader = (PS802_11Header) (pbyFrame);
+            TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
+            rc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);
+            rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);
+            if (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {
+                *pbyNewRsr |= NEWRSR_DECRYPTOK;
+                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV OK!\n");
+            } else {
+                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV FAIL!!!\n");
+                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"PayloadLen = %d\n", PayloadLen);
+            }
+        }
+    }// end of TKIP/AES
+
+    if ((*(pbyIV+3) & 0x20) != 0)
+        *pbExtIV = TRUE;
+    return TRUE;
+}
+
+
+static BOOL s_bHostWepRxEncryption (
+    IN PSDevice     pDevice,
+    IN PBYTE        pbyFrame,
+    IN UINT         FrameSize,
+    IN PBYTE        pbyRsr,
+    IN BOOL         bOnFly,
+    IN PSKeyItem    pKey,
+    OUT PBYTE       pbyNewRsr,
+    OUT PBOOL       pbExtIV,
+    OUT PWORD       pwRxTSC15_0,
+    OUT PDWORD      pdwRxTSC47_16
+    )
+{
+    UINT            PayloadLen = FrameSize;
+    PBYTE           pbyIV;
+    BYTE            byKeyIdx;
+    BYTE            byDecMode = KEY_CTL_WEP;
+    PS802_11Header  pMACHeader;
+
+
+
+    *pwRxTSC15_0 = 0;
+    *pdwRxTSC47_16 = 0;
+
+    pbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;
+    if ( WLAN_GET_FC_TODS(*(PWORD)pbyFrame) &&
+         WLAN_GET_FC_FROMDS(*(PWORD)pbyFrame) ) {
+         pbyIV += 6;             // 6 is 802.11 address4
+         PayloadLen -= 6;
+    }
+    byKeyIdx = (*(pbyIV+3) & 0xc0);
+    byKeyIdx >>= 6;
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"\nKeyIdx: %d\n", byKeyIdx);
+
+
+    if (pDevice->pMgmt->byCSSGK == KEY_CTL_TKIP)
+        byDecMode = KEY_CTL_TKIP;
+    else if (pDevice->pMgmt->byCSSGK == KEY_CTL_CCMP)
+        byDecMode = KEY_CTL_CCMP;
+
+    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"AES:%d %d %d\n", pDevice->pMgmt->byCSSPK, pDevice->pMgmt->byCSSGK, byDecMode);
+
+    if (byDecMode != pKey->byCipherSuite) {
+        if (byDecMode == KEY_CTL_WEP) {
+//            pDevice->s802_11Counter.WEPUndecryptableCount.QuadPart++;
+        } else if (pDevice->bLinkPass == TRUE) {
+//            pDevice->s802_11Counter.DecryptFailureCount.QuadPart++;
+        }
+        return FALSE;
+    }
+
+    if (byDecMode == KEY_CTL_WEP) {
+        // handle WEP
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"byDecMode == KEY_CTL_WEP \n");
+        if ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||
+            (((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == TRUE) ||
+            (bOnFly == FALSE)) {
+            // Software WEP
+            // 1. 3253A
+            // 2. WEP 256
+            // 3. NotOnFly
+
+            PayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4); // 24 is 802.11 header,4 is IV, 4 is crc
+            MEMvCopy(pDevice->abyPRNG, pbyIV, 3);
+            MEMvCopy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);
+            rc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);
+            rc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);
+
+            if (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen)) {
+                *pbyNewRsr |= NEWRSR_DECRYPTOK;
+            }
+        }
+    } else if ((byDecMode == KEY_CTL_TKIP) ||
+               (byDecMode == KEY_CTL_CCMP)) {
+        // TKIP/AES
+
+        PayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4); // 24 is 802.11 header, 8 is IV&ExtIV, 4 is crc
+        *pdwRxTSC47_16 = cpu_to_le32(*(PDWORD)(pbyIV + 4));
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);
+
+        if (byDecMode == KEY_CTL_TKIP) {
+            *pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));
+        } else {
+            *pwRxTSC15_0 = cpu_to_le16(*(PWORD)pbyIV);
+        }
+        DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);
+
+        if (byDecMode == KEY_CTL_TKIP) {
+            if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || (bOnFly == FALSE)) {
+                // Software TKIP
+                // 1. 3253 A
+                // 2. NotOnFly
+                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_TKIP \n");
+                pMACHeader = (PS802_11Header) (pbyFrame);
+                TKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);
+                rc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);
+                rc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);
+                if (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {
+                    *pbyNewRsr |= NEWRSR_DECRYPTOK;
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV OK!\n");
+                } else {
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV FAIL!!!\n");
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"PayloadLen = %d\n", PayloadLen);
+                }
+            }
+        }
+
+        if (byDecMode == KEY_CTL_CCMP) {
+            if (bOnFly == FALSE) {
+                // Software CCMP
+                // NotOnFly
+                DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_CCMP\n");
+                if (AESbGenCCMP(pKey->abyKey, pbyFrame, FrameSize)) {
+                    *pbyNewRsr |= NEWRSR_DECRYPTOK;
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CCMP MIC compare OK!\n");
+                } else {
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CCMP MIC fail!\n");
+                }
+            }
+        }
+
+    }// end of TKIP/AES
+
+    if ((*(pbyIV+3) & 0x20) != 0)
+        *pbExtIV = TRUE;
+    return TRUE;
+}
+
+
+
+
+#ifdef PRIVATE_OBJ
+
+static BOOL s_bAPModeRxData (
+    IN PSDevice pDevice,
+    IN ref_sk_buff* skb,
+    IN UINT     FrameSize,
+    IN UINT     cbHeaderOffset,
+    IN INT      iSANodeIndex,
+    IN INT      iDANodeIndex
+    )
+
+#else
+
+static BOOL s_bAPModeRxData (
+    IN PSDevice pDevice,
+    IN struct sk_buff* skb,
+    IN UINT     FrameSize,
+    IN UINT     cbHeaderOffset,
+    IN INT      iSANodeIndex,
+    IN INT      iDANodeIndex
+    )
+#endif
+{
+    PSMgmtObject        pMgmt = pDevice->pMgmt;
+    BOOL                bRelayAndForward = FALSE;
+    BOOL                bRelayOnly = FALSE;
+    BYTE                byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
+    WORD                wAID;
+#ifdef PRIVATE_OBJ
+    struct sk_buff* tmp_skb;
+    ref_sk_buff     s_ref_skb;
+    ref_sk_buff*    skbcpy = &s_ref_skb;
+#else
+    struct sk_buff* skbcpy = NULL;
+#endif
+
+
+
+    if (FrameSize > CB_MAX_BUF_SIZE)
+        return FALSE;
+    // check DA
+    if(IS_MULTICAST_ADDRESS((PBYTE)(skb->data+cbHeaderOffset))) {
+       if (pMgmt->sNodeDBTable[0].bPSEnable) {
+
+#ifdef PRIVATE_OBJ
+           tmp_skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
+           skbcpy = &s_ref_skb;
+           ref_skb_remap(pDevice->dev, skbcpy, tmp_skb);
+#else
+           skbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);
+#endif
+        // if any node in PS mode, buffer packet until DTIM.
+           if (skbcpy == NULL) {
+               DEVICE_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");
+           }
+           else {
+               skbcpy->dev = pDevice->dev;
+#ifdef PRIVATE_OBJ
+               *(skbcpy->len) = FrameSize;
+               memcpy(skbcpy->data, skb->data+cbHeaderOffset, FrameSize);
+               skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skbcpy->skb);
+#else
+               skbcpy->len = FrameSize;
+               memcpy(skbcpy->data, skb->data+cbHeaderOffset, FrameSize);
+               skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skbcpy);
+#endif
+               pMgmt->sNodeDBTable[0].wEnQueueCnt++;
+               // set tx map
+               pMgmt->abyPSTxMap[0] |= byMask[0];
+           }
+       }
+       else {
+           bRelayAndForward = TRUE;
+       }
+    }
+    else {
+        // check if relay
+        if (BSSDBbIsSTAInNodeDB(pMgmt, (PBYTE)(skb->data+cbHeaderOffset), &iDANodeIndex)) {
+            if (pMgmt->sNodeDBTable[iDANodeIndex].eNodeState >= NODE_ASSOC) {
+                if (pMgmt->sNodeDBTable[iDANodeIndex].bPSEnable) {
+                    // queue this skb until next PS tx, and then release.
+
+#ifdef PRIVATE_OBJ
+                    ref_skb_add_offset(skb->skb, cbHeaderOffset);
+                    skb_put(skb->skb, FrameSize);
+                    skb_queue_tail(&pMgmt->sNodeDBTable[iDANodeIndex].sTxPSQueue, skb->skb);
+#else
+	                skb->data += cbHeaderOffset;
+	                skb->tail += cbHeaderOffset;
+                    skb_put(skb, FrameSize);
+                    skb_queue_tail(&pMgmt->sNodeDBTable[iDANodeIndex].sTxPSQueue, skb);
+#endif
+                    pMgmt->sNodeDBTable[iDANodeIndex].wEnQueueCnt++;
+                    wAID = pMgmt->sNodeDBTable[iDANodeIndex].wAID;
+                    pMgmt->abyPSTxMap[wAID >> 3] |=  byMask[wAID & 7];
+                    DEVICE_PRT(MSG_LEVEL_DEBUG, KERN_INFO "relay: index= %d, pMgmt->abyPSTxMap[%d]= %d\n",
+                               iDANodeIndex, (wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);
+                    return TRUE;
+                }
+                else {
+                    bRelayOnly = TRUE;
+                }
+            }
+        };
+    }
+
+    if (bRelayOnly || bRelayAndForward) {
+        // relay this packet right now
+        if (bRelayAndForward)
+            iDANodeIndex = 0;
+
+        if ((pDevice->uAssocCount > 1) && (iDANodeIndex >= 0)) {
+            ROUTEbRelay(pDevice, (PBYTE)(skb->data + cbHeaderOffset), FrameSize, (UINT)iDANodeIndex);
+        }
+
+        if (bRelayOnly)
+            return FALSE;
+    }
+    // none associate, don't forward
+    if (pDevice->uAssocCount == 0)
+        return FALSE;
+
+    return TRUE;
+}
+
