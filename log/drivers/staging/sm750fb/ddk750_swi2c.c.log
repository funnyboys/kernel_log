commit 81e0da703fdba1ee126868bf8350592c79cdba13
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Aug 15 14:30:09 2019 +0200

    staging: sm750fb: fix odd license text
    
    There is some "confusing" license text in some of the sm750fb driver
    files.  After discussing it with the company, it turns out to have been
    a mistake and these lines can be safely removed.  The files are all to
    be licensed under the GPLv2 license.
    
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Cc: Teddy Wang <teddy.wang@siliconmotion.com>
    Cc: linux-fbdev@vger.kernel.org
    Cc: devel@driverdev.osuosl.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20190815123009.16499-1-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 5c0ac747ea2b..0ef8d4ff2ef9 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -2,9 +2,6 @@
 /*
  *         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
  *
- *  All rights are reserved. Reproduction or in part is prohibited
- *  without the written consent of the copyright owner.
- *
  *  swi2c.c --- SM750/SM718 DDK
  *  This file contains the source code for I2C using software
  *  implementation.

commit 25338628bbfca07076318459e3e92b540122fb88
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 2 12:31:51 2019 +0200

    staging: sm750fb: add proper SPDX identifier to driver
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.  Because of this, add the
    GPL-2.0 identifier to the sm750fb driver which did not have any license
    identifiers in it at all.
    
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Cc: Teddy Wang <teddy.wang@siliconmotion.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 19c5ffc72b16..5c0ac747ea2b 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
  *

commit c975045656bb7fac6c077d1f075ce67b26e5b875
Author: Matej Dujava <mdujava@kocurkovo.cz>
Date:   Tue May 16 11:20:17 2017 +0200

    staging: sm750fb: fix length of lines, function calls and declaration
    
    This patch breaks lines that are longer than 80 characters and joins
    together those, that are too short and can be placed at one.
    
    Function calls and declarations are updated to fit kernel code style.
    
    Signed-off-by: Matej Dujava <mdujava@kocurkovo.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index a4ac07cd50cb..19c5ffc72b16 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -349,8 +349,7 @@ static unsigned char sw_i2c_read_byte(unsigned char ack)
  *      -1   - Fail to initialize the i2c
  *       0   - Success
  */
-static long sm750le_i2c_init(unsigned char clk_gpio,
-			     unsigned char data_gpio)
+static long sm750le_i2c_init(unsigned char clk_gpio, unsigned char data_gpio)
 {
 	int i;
 
@@ -388,10 +387,7 @@ static long sm750le_i2c_init(unsigned char clk_gpio,
  *      -1   - Fail to initialize the i2c
  *       0   - Success
  */
-long sm750_sw_i2c_init(
-	unsigned char clk_gpio,
-	unsigned char data_gpio
-)
+long sm750_sw_i2c_init(unsigned char clk_gpio, unsigned char data_gpio)
 {
 	int i;
 
@@ -448,10 +444,7 @@ long sm750_sw_i2c_init(
  *  Return Value:
  *      Register value
  */
-unsigned char sm750_sw_i2c_read_reg(
-	unsigned char addr,
-	unsigned char reg
-)
+unsigned char sm750_sw_i2c_read_reg(unsigned char addr, unsigned char reg)
 {
 	unsigned char data;
 
@@ -488,11 +481,9 @@ unsigned char sm750_sw_i2c_read_reg(
  *          0   - Success
  *         -1   - Fail
  */
-long sm750_sw_i2c_write_reg(
-	unsigned char addr,
-	unsigned char reg,
-	unsigned char data
-)
+long sm750_sw_i2c_write_reg(unsigned char addr,
+			    unsigned char reg,
+			    unsigned char data)
 {
 	long ret = 0;
 

commit c075b6f2d357ea91e8ef01e860571e7d151f3aa3
Author: Matthieu Simon <gmatthsim@gmail.com>
Date:   Tue Feb 7 22:48:43 2017 -0800

    staging: sm750fb: Replace POKE32 and PEEK32 by inline functions
    
    POKE32 and PEEK32 have been replaced by inlined functions poke32 and
    peek32.
    Having inline functions instead of macros help to get the correct
    type-checking and avoid the possible precedence issues reported by
    checkpatch.
    
    Signed-off-by: Matthieu Simon <gmatthsim@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index b8a4e44359af..a4ac07cd50cb 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -119,23 +119,23 @@ static void sw_i2c_scl(unsigned char value)
 	unsigned long gpio_data;
 	unsigned long gpio_dir;
 
-	gpio_dir = PEEK32(sw_i2c_clk_gpio_data_dir_reg);
+	gpio_dir = peek32(sw_i2c_clk_gpio_data_dir_reg);
 	if (value) {    /* High */
 		/*
 		 * Set direction as input. This will automatically
 		 * pull the signal up.
 		 */
 		gpio_dir &= ~(1 << sw_i2c_clk_gpio);
-		POKE32(sw_i2c_clk_gpio_data_dir_reg, gpio_dir);
+		poke32(sw_i2c_clk_gpio_data_dir_reg, gpio_dir);
 	} else {        /* Low */
 		/* Set the signal down */
-		gpio_data = PEEK32(sw_i2c_clk_gpio_data_reg);
+		gpio_data = peek32(sw_i2c_clk_gpio_data_reg);
 		gpio_data &= ~(1 << sw_i2c_clk_gpio);
-		POKE32(sw_i2c_clk_gpio_data_reg, gpio_data);
+		poke32(sw_i2c_clk_gpio_data_reg, gpio_data);
 
 		/* Set direction as output */
 		gpio_dir |= (1 << sw_i2c_clk_gpio);
-		POKE32(sw_i2c_clk_gpio_data_dir_reg, gpio_dir);
+		poke32(sw_i2c_clk_gpio_data_dir_reg, gpio_dir);
 	}
 }
 
@@ -156,23 +156,23 @@ static void sw_i2c_sda(unsigned char value)
 	unsigned long gpio_data;
 	unsigned long gpio_dir;
 
-	gpio_dir = PEEK32(sw_i2c_data_gpio_data_dir_reg);
+	gpio_dir = peek32(sw_i2c_data_gpio_data_dir_reg);
 	if (value) {    /* High */
 		/*
 		 * Set direction as input. This will automatically
 		 * pull the signal up.
 		 */
 		gpio_dir &= ~(1 << sw_i2c_data_gpio);
-		POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
+		poke32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
 	} else {        /* Low */
 		/* Set the signal down */
-		gpio_data = PEEK32(sw_i2c_data_gpio_data_reg);
+		gpio_data = peek32(sw_i2c_data_gpio_data_reg);
 		gpio_data &= ~(1 << sw_i2c_data_gpio);
-		POKE32(sw_i2c_data_gpio_data_reg, gpio_data);
+		poke32(sw_i2c_data_gpio_data_reg, gpio_data);
 
 		/* Set direction as output */
 		gpio_dir |= (1 << sw_i2c_data_gpio);
-		POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
+		poke32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
 	}
 }
 
@@ -189,14 +189,14 @@ static unsigned char sw_i2c_read_sda(void)
 	unsigned long dir_mask = 1 << sw_i2c_data_gpio;
 
 	/* Make sure that the direction is input (High) */
-	gpio_dir = PEEK32(sw_i2c_data_gpio_data_dir_reg);
+	gpio_dir = peek32(sw_i2c_data_gpio_data_dir_reg);
 	if ((gpio_dir & dir_mask) != ~dir_mask) {
 		gpio_dir &= ~(1 << sw_i2c_data_gpio);
-		POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
+		poke32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
 	}
 
 	/* Now read the SDA line */
-	gpio_data = PEEK32(sw_i2c_data_gpio_data_reg);
+	gpio_data = peek32(sw_i2c_data_gpio_data_reg);
 	if (gpio_data & (1 << sw_i2c_data_gpio))
 		return 1;
 	else
@@ -422,10 +422,10 @@ long sm750_sw_i2c_init(
 	sw_i2c_data_gpio = data_gpio;
 
 	/* Enable the GPIO pins for the i2c Clock and Data (GPIO MUX) */
-	POKE32(sw_i2c_clk_gpio_mux_reg,
-	       PEEK32(sw_i2c_clk_gpio_mux_reg) & ~(1 << sw_i2c_clk_gpio));
-	POKE32(sw_i2c_data_gpio_mux_reg,
-	       PEEK32(sw_i2c_data_gpio_mux_reg) & ~(1 << sw_i2c_data_gpio));
+	poke32(sw_i2c_clk_gpio_mux_reg,
+	       peek32(sw_i2c_clk_gpio_mux_reg) & ~(1 << sw_i2c_clk_gpio));
+	poke32(sw_i2c_data_gpio_mux_reg,
+	       peek32(sw_i2c_data_gpio_mux_reg) & ~(1 << sw_i2c_data_gpio));
 
 	/* Enable GPIO power */
 	sm750_enable_gpio(1);

commit 52d0744d751d8f13511df15e776460bfb95bcf5c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 9 10:26:27 2016 +0100

    staging: sm750fb: prefix global identifiers
    
    Renaming some symbols inside this driver caused a conflict with
    an existing function, which in turn results in a link error:
    
    drivers/staging/sm750fb/sm750fb.o: In function `enable_dma':
    ddk750_hwi2c.c:(.text.enable_dma+0x0): multiple definition of `enable_dma'
    
    This adds a sm750_ prefix to each global symbol in the sm750fb
    driver that does not already have one. I manually looked for the
    symbols and then converted the driver using
    
    for i in calc_pll_value format_pll_reg set_power_mode set_current_gate    \
            enable_2d_engine enable_dma enable_gpio enable_i2c hw_set2dformat \
            hw_de_init hw_fillrect hw_copyarea hw_imageblit hw_cursor_enable  \
            hw_cursor_disable hw_cursor_setSize hw_cursor_setPos              \
            hw_cursor_setColor hw_cursor_setData hw_cursor_setData2 ;
    do
                    sed -i "s:\<$i\>:sm750_$i:" drivers/staging/sm750fb/*.[ch]
    done
    
    Fixes: 03140dabf584 ("staging: sm750fb: Replace functions CamelCase naming with underscores.")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index e2e3ca64d483..b8a4e44359af 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -428,7 +428,7 @@ long sm750_sw_i2c_init(
 	       PEEK32(sw_i2c_data_gpio_mux_reg) & ~(1 << sw_i2c_data_gpio));
 
 	/* Enable GPIO power */
-	enable_gpio(1);
+	sm750_enable_gpio(1);
 
 	/* Clear the i2c lines. */
 	for (i = 0; i < 9; i++)

commit 03140dabf584555e96440084d1ac426127bdf8c3
Author: Elise Lennion <elise.lennion@gmail.com>
Date:   Thu Oct 27 22:23:35 2016 -0200

    staging: sm750fb: Replace functions CamelCase naming with underscores.
    
    Replace CamelCase function names with underscores to comply with
    the standard kernel coding style.
    
    Signed-off-by: Elise Lennion <elise.lennion@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 7fce55df5fa6..e2e3ca64d483 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -428,7 +428,7 @@ long sm750_sw_i2c_init(
 	       PEEK32(sw_i2c_data_gpio_mux_reg) & ~(1 << sw_i2c_data_gpio));
 
 	/* Enable GPIO power */
-	enableGPIO(1);
+	enable_gpio(1);
 
 	/* Clear the i2c lines. */
 	for (i = 0; i < 9; i++)

commit f5016082f63d42f109b4c8405291e481805d4828
Author: Eric S. Stone <esstone@gmail.com>
Date:   Sat Oct 22 19:51:29 2016 -0700

    staging: sm750fb: restructure multi-line comments to follow CodingStyle
    
    Eliminates all checkpatch.pl BLOCK_COMMENT_STYLE warnings in
    sm750fb, and coincidentally eliminates some line-length (80)
    warnings.
    
    Signed-off-by: Eric S. Stone <esstone@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 78bfba0e03e8..7fce55df5fa6 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -1,21 +1,20 @@
-/*******************************************************************
-*
-*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
-*
-*  All rights are reserved. Reproduction or in part is prohibited
-*  without the written consent of the copyright owner.
-*
-*  swi2c.c --- SM750/SM718 DDK
-*  This file contains the source code for I2C using software
-*  implementation.
-*
-*******************************************************************/
+/*
+ *         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+ *
+ *  All rights are reserved. Reproduction or in part is prohibited
+ *  without the written consent of the copyright owner.
+ *
+ *  swi2c.c --- SM750/SM718 DDK
+ *  This file contains the source code for I2C using software
+ *  implementation.
+ */
+
 #include "ddk750_chip.h"
 #include "ddk750_reg.h"
 #include "ddk750_swi2c.h"
 #include "ddk750_power.h"
 
-/*******************************************************************
+/*
  * I2C Software Master Driver:
  * ===========================
  * Each i2c cycle is split into 4 sections. Each of these section marks
@@ -51,7 +50,7 @@
  *                            SCL | L |   | H |   |
  *                 ---------------+---+---+---+---+
  *
- ******************************************************************/
+ */
 
 /* GPIO pins used for this I2C. It ranges from 0 to 63. */
 static unsigned char sw_i2c_clk_gpio = DEFAULT_I2C_SCL;

commit efe9bc08bf479b1baacc63554042c5dd11fecd9e
Author: Elise Lennion <elise.lennion@gmail.com>
Date:   Tue Oct 11 19:43:07 2016 -0300

    staging: sm750fb: Merge ddk750_help.* into ddk750_chip.*.
    
    The file ddk750_help.c contained only one function declaration,
    so it was merged into ddk750_chip.c to simplify the driver.
    
    Also, ddk750_help.h was merged into ddk750_chip.h to keep consistency.
    
    With these changes a few global variables are removed and the function
    ddk750_set_mmio is rewritten, so its purpose in the code is clearer.
    
    Signed-off-by: Elise Lennion <elise.lennion@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 72a42330e7a1..78bfba0e03e8 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -10,7 +10,7 @@
 *  implementation.
 *
 *******************************************************************/
-#include "ddk750_help.h"
+#include "ddk750_chip.h"
 #include "ddk750_reg.h"
 #include "ddk750_swi2c.h"
 #include "ddk750_power.h"

commit 35e4d8ca05e87d38fb160cb35ba7c3282192a77b
Author: Elizabeth Ferdman <gnudevliz@gmail.com>
Date:   Wed Sep 28 14:33:51 2016 -0700

    staging: sm750fb: conform to block comment style
    
    Fix 2 checkpatch errors:
    -Block comments use * on subsequent lines,
    -Block comments use a trailing */ on a separate line
    to conform to block commenting style.
    
    Signed-off-by: Elizabeth Ferdman <gnudevliz@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 6c1ffa1d3b03..72a42330e7a1 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -89,12 +89,12 @@ static void sw_i2c_wait(void)
 	 * always be non-zero,which makes the while loop
 	 * never finish.
 	 * use non-ultimate for loop below is safe
-	 * */
+	 */
 
     /* Change wait algorithm to use PCI bus clock,
-       it's more reliable than counter loop ..
-       write 0x61 to 0x3ce and read from 0x3cf
-       */
+     * it's more reliable than counter loop ..
+     * write 0x61 to 0x3ce and read from 0x3cf
+     */
 	int i, tmp;
 
 	for (i = 0; i < 600; i++) {
@@ -501,8 +501,8 @@ long sm750_sw_i2c_write_reg(
 	sw_i2c_start();
 
 	/* Send the device address and read the data. All should return success
-	   in order for the writing processed to be successful
-	*/
+	 * in order for the writing processed to be successful
+	 */
 	if ((sw_i2c_write_byte(addr) != 0) ||
 	    (sw_i2c_write_byte(reg) != 0) ||
 	    (sw_i2c_write_byte(data) != 0)) {

commit 06a4f429bfa20d22c1385a35656206301ac2e672
Author: Moshe Green <mgmoshes@gmail.com>
Date:   Sun Sep 25 22:58:35 2016 +0300

    staging: sm750fb: rename getChipType to sm750_get_chip_type
    
    Rename CamelCased function getChipType to sm750_get_chip_type
    (prefex with sm750 in order to make the context of
    the function clear).
    
    This issue was found by checkpatch.pl
    
    Signed-off-by: Moshe Green <mgmoshes@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 8d644a7cba52..6c1ffa1d3b03 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -403,7 +403,7 @@ long sm750_sw_i2c_init(
 	if ((clk_gpio > 31) || (data_gpio > 31))
 		return -1;
 
-	if (getChipType() == SM750LE)
+	if (sm750_get_chip_type() == SM750LE)
 		return sm750le_i2c_init(clk_gpio, data_gpio);
 
 	/* Initialize the GPIO pin for the i2c Clock Register */

commit 1282bade3b8e34cb4a26b8444577d70c7f15e0d8
Author: Mike Rapoport <mike.rapoport@gmail.com>
Date:   Tue Sep 29 10:47:49 2015 +0300

    staging: sm750fb: remove dead code
    
    Remove the code enclosed in '#if 0'
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 37cdd5b5f19e..8d644a7cba52 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -90,20 +90,17 @@ static void sw_i2c_wait(void)
 	 * never finish.
 	 * use non-ultimate for loop below is safe
 	 * */
-#if 0
+
     /* Change wait algorithm to use PCI bus clock,
        it's more reliable than counter loop ..
        write 0x61 to 0x3ce and read from 0x3cf
        */
-	while (peekIO(0x3ce, 0x61) & 0x10);
-#else
 	int i, tmp;
 
 	for (i = 0; i < 600; i++) {
 		tmp = i;
 		tmp += i;
 	}
-#endif
 }
 
 /*

commit 9137f812e911fc8030e8b954b097e62e29691154
Author: Mike Rapoport <mike.rapoport@gmail.com>
Date:   Sat Sep 12 11:07:49 2015 +0300

    staging: sm750fb: ddk750_*i2c: shorten lines to under 80 characters
    
    Fix some checkpatch warnings about long lines
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index ddbbeffcef3a..37cdd5b5f19e 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -125,7 +125,10 @@ static void sw_i2c_scl(unsigned char value)
 
 	gpio_dir = PEEK32(sw_i2c_clk_gpio_data_dir_reg);
 	if (value) {    /* High */
-		/* Set direction as input. This will automatically pull the signal up. */
+		/*
+		 * Set direction as input. This will automatically
+		 * pull the signal up.
+		 */
 		gpio_dir &= ~(1 << sw_i2c_clk_gpio);
 		POKE32(sw_i2c_clk_gpio_data_dir_reg, gpio_dir);
 	} else {        /* Low */
@@ -159,7 +162,10 @@ static void sw_i2c_sda(unsigned char value)
 
 	gpio_dir = PEEK32(sw_i2c_data_gpio_data_dir_reg);
 	if (value) {    /* High */
-		/* Set direction as input. This will automatically pull the signal up. */
+		/*
+		 * Set direction as input. This will automatically
+		 * pull the signal up.
+		 */
 		gpio_dir &= ~(1 << sw_i2c_data_gpio);
 		POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
 	} else {        /* Low */
@@ -184,10 +190,11 @@ static unsigned char sw_i2c_read_sda(void)
 {
 	unsigned long gpio_dir;
 	unsigned long gpio_data;
+	unsigned long dir_mask = 1 << sw_i2c_data_gpio;
 
 	/* Make sure that the direction is input (High) */
 	gpio_dir = PEEK32(sw_i2c_data_gpio_data_dir_reg);
-	if ((gpio_dir & (1 << sw_i2c_data_gpio)) != (~(1 << sw_i2c_data_gpio))) {
+	if ((gpio_dir & dir_mask) != ~dir_mask) {
 		gpio_dir &= ~(1 << sw_i2c_data_gpio);
 		POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
 	}
@@ -392,7 +399,10 @@ long sm750_sw_i2c_init(
 {
 	int i;
 
-	/* Return 0 if the GPIO pins to be used is out of range. The range is only from [0..63] */
+	/*
+	 * Return 0 if the GPIO pins to be used is out of range. The
+	 * range is only from [0..63]
+	 */
 	if ((clk_gpio > 31) || (data_gpio > 31))
 		return -1;
 
@@ -417,9 +427,9 @@ long sm750_sw_i2c_init(
 
 	/* Enable the GPIO pins for the i2c Clock and Data (GPIO MUX) */
 	POKE32(sw_i2c_clk_gpio_mux_reg,
-			PEEK32(sw_i2c_clk_gpio_mux_reg) & ~(1 << sw_i2c_clk_gpio));
+	       PEEK32(sw_i2c_clk_gpio_mux_reg) & ~(1 << sw_i2c_clk_gpio));
 	POKE32(sw_i2c_data_gpio_mux_reg,
-			PEEK32(sw_i2c_data_gpio_mux_reg) & ~(1 << sw_i2c_data_gpio));
+	       PEEK32(sw_i2c_data_gpio_mux_reg) & ~(1 << sw_i2c_data_gpio));
 
 	/* Enable GPIO power */
 	enableGPIO(1);

commit 987f202a344385c461b33f13eb39050e2a39fa22
Author: Mike Rapoport <mike.rapoport@gmail.com>
Date:   Sat Sep 12 11:07:48 2015 +0300

    staging: sm750fb: ddk750_*i2c: remove multiple blank lines
    
    Fix the checkpatch warning about multiple blank lines
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 5cb1cf2182ba..ddbbeffcef3a 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -15,7 +15,6 @@
 #include "ddk750_swi2c.h"
 #include "ddk750_power.h"
 
-
 /*******************************************************************
  * I2C Software Master Driver:
  * ===========================

commit fe820044892de545b8cd8ad3ccdd864d78734b97
Author: Mike Rapoport <mike.rapoport@gmail.com>
Date:   Sat Sep 12 11:07:47 2015 +0300

    staging: sm750fb: ddk750_swi2c: further reduce CamelCase
    
    Rename remaining CamelCase variables
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 1d7e8f665e63..5cb1cf2182ba 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -98,11 +98,11 @@ static void sw_i2c_wait(void)
        */
 	while (peekIO(0x3ce, 0x61) & 0x10);
 #else
-	int i, Temp;
+	int i, tmp;
 
 	for (i = 0; i < 600; i++) {
-		Temp = i;
-		Temp += i;
+		tmp = i;
+		tmp += i;
 	}
 #endif
 }
@@ -121,23 +121,23 @@ static void sw_i2c_wait(void)
  */
 static void sw_i2c_scl(unsigned char value)
 {
-	unsigned long ulGPIOData;
-	unsigned long ulGPIODirection;
+	unsigned long gpio_data;
+	unsigned long gpio_dir;
 
-	ulGPIODirection = PEEK32(sw_i2c_clk_gpio_data_dir_reg);
+	gpio_dir = PEEK32(sw_i2c_clk_gpio_data_dir_reg);
 	if (value) {    /* High */
 		/* Set direction as input. This will automatically pull the signal up. */
-		ulGPIODirection &= ~(1 << sw_i2c_clk_gpio);
-		POKE32(sw_i2c_clk_gpio_data_dir_reg, ulGPIODirection);
+		gpio_dir &= ~(1 << sw_i2c_clk_gpio);
+		POKE32(sw_i2c_clk_gpio_data_dir_reg, gpio_dir);
 	} else {        /* Low */
 		/* Set the signal down */
-		ulGPIOData = PEEK32(sw_i2c_clk_gpio_data_reg);
-		ulGPIOData &= ~(1 << sw_i2c_clk_gpio);
-		POKE32(sw_i2c_clk_gpio_data_reg, ulGPIOData);
+		gpio_data = PEEK32(sw_i2c_clk_gpio_data_reg);
+		gpio_data &= ~(1 << sw_i2c_clk_gpio);
+		POKE32(sw_i2c_clk_gpio_data_reg, gpio_data);
 
 		/* Set direction as output */
-		ulGPIODirection |= (1 << sw_i2c_clk_gpio);
-		POKE32(sw_i2c_clk_gpio_data_dir_reg, ulGPIODirection);
+		gpio_dir |= (1 << sw_i2c_clk_gpio);
+		POKE32(sw_i2c_clk_gpio_data_dir_reg, gpio_dir);
 	}
 }
 
@@ -155,23 +155,23 @@ static void sw_i2c_scl(unsigned char value)
  */
 static void sw_i2c_sda(unsigned char value)
 {
-	unsigned long ulGPIOData;
-	unsigned long ulGPIODirection;
+	unsigned long gpio_data;
+	unsigned long gpio_dir;
 
-	ulGPIODirection = PEEK32(sw_i2c_data_gpio_data_dir_reg);
+	gpio_dir = PEEK32(sw_i2c_data_gpio_data_dir_reg);
 	if (value) {    /* High */
 		/* Set direction as input. This will automatically pull the signal up. */
-		ulGPIODirection &= ~(1 << sw_i2c_data_gpio);
-		POKE32(sw_i2c_data_gpio_data_dir_reg, ulGPIODirection);
+		gpio_dir &= ~(1 << sw_i2c_data_gpio);
+		POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
 	} else {        /* Low */
 		/* Set the signal down */
-		ulGPIOData = PEEK32(sw_i2c_data_gpio_data_reg);
-		ulGPIOData &= ~(1 << sw_i2c_data_gpio);
-		POKE32(sw_i2c_data_gpio_data_reg, ulGPIOData);
+		gpio_data = PEEK32(sw_i2c_data_gpio_data_reg);
+		gpio_data &= ~(1 << sw_i2c_data_gpio);
+		POKE32(sw_i2c_data_gpio_data_reg, gpio_data);
 
 		/* Set direction as output */
-		ulGPIODirection |= (1 << sw_i2c_data_gpio);
-		POKE32(sw_i2c_data_gpio_data_dir_reg, ulGPIODirection);
+		gpio_dir |= (1 << sw_i2c_data_gpio);
+		POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
 	}
 }
 
@@ -183,19 +183,19 @@ static void sw_i2c_sda(unsigned char value)
  */
 static unsigned char sw_i2c_read_sda(void)
 {
-	unsigned long ulGPIODirection;
-	unsigned long ulGPIOData;
+	unsigned long gpio_dir;
+	unsigned long gpio_data;
 
 	/* Make sure that the direction is input (High) */
-	ulGPIODirection = PEEK32(sw_i2c_data_gpio_data_dir_reg);
-	if ((ulGPIODirection & (1 << sw_i2c_data_gpio)) != (~(1 << sw_i2c_data_gpio))) {
-		ulGPIODirection &= ~(1 << sw_i2c_data_gpio);
-		POKE32(sw_i2c_data_gpio_data_dir_reg, ulGPIODirection);
+	gpio_dir = PEEK32(sw_i2c_data_gpio_data_dir_reg);
+	if ((gpio_dir & (1 << sw_i2c_data_gpio)) != (~(1 << sw_i2c_data_gpio))) {
+		gpio_dir &= ~(1 << sw_i2c_data_gpio);
+		POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
 	}
 
 	/* Now read the SDA line */
-	ulGPIOData = PEEK32(sw_i2c_data_gpio_data_reg);
-	if (ulGPIOData & (1 << sw_i2c_data_gpio))
+	gpio_data = PEEK32(sw_i2c_data_gpio_data_reg);
+	if (gpio_data & (1 << sw_i2c_data_gpio))
 		return 1;
 	else
 		return 0;
@@ -340,15 +340,15 @@ static unsigned char sw_i2c_read_byte(unsigned char ack)
  * This function initializes GPIO port for SW I2C communication.
  *
  * Parameters:
- *      i2cClkGPIO      - The GPIO pin to be used as i2c SCL
- *      i2cDataGPIO     - The GPIO pin to be used as i2c SDA
+ *      clk_gpio      - The GPIO pin to be used as i2c SCL
+ *      data_gpio     - The GPIO pin to be used as i2c SDA
  *
  * Return Value:
  *      -1   - Fail to initialize the i2c
  *       0   - Success
  */
-static long sm750le_i2c_init(unsigned char i2cClkGPIO,
-			      unsigned char i2cDataGPIO)
+static long sm750le_i2c_init(unsigned char clk_gpio,
+			     unsigned char data_gpio)
 {
 	int i;
 
@@ -357,14 +357,14 @@ static long sm750le_i2c_init(unsigned char i2cClkGPIO,
 	sw_i2c_clk_gpio_data_dir_reg = GPIO_DATA_DIRECTION_SM750LE;
 
 	/* Initialize the Clock GPIO Offset */
-	sw_i2c_clk_gpio = i2cClkGPIO;
+	sw_i2c_clk_gpio = clk_gpio;
 
 	/* Initialize the GPIO pin for the i2c Data Register */
 	sw_i2c_data_gpio_data_reg = GPIO_DATA_SM750LE;
 	sw_i2c_data_gpio_data_dir_reg = GPIO_DATA_DIRECTION_SM750LE;
 
 	/* Initialize the Data GPIO Offset */
-	sw_i2c_data_gpio = i2cDataGPIO;
+	sw_i2c_data_gpio = data_gpio;
 
 	/* Note that SM750LE don't have GPIO MUX and power is always on */
 
@@ -379,26 +379,26 @@ static long sm750le_i2c_init(unsigned char i2cClkGPIO,
  * This function initializes the i2c attributes and bus
  *
  * Parameters:
- *      i2cClkGPIO      - The GPIO pin to be used as i2c SCL
- *      i2cDataGPIO     - The GPIO pin to be used as i2c SDA
+ *      clk_gpio      - The GPIO pin to be used as i2c SCL
+ *      data_gpio     - The GPIO pin to be used as i2c SDA
  *
  * Return Value:
  *      -1   - Fail to initialize the i2c
  *       0   - Success
  */
 long sm750_sw_i2c_init(
-	unsigned char i2cClkGPIO,
-	unsigned char i2cDataGPIO
+	unsigned char clk_gpio,
+	unsigned char data_gpio
 )
 {
 	int i;
 
 	/* Return 0 if the GPIO pins to be used is out of range. The range is only from [0..63] */
-	if ((i2cClkGPIO > 31) || (i2cDataGPIO > 31))
+	if ((clk_gpio > 31) || (data_gpio > 31))
 		return -1;
 
 	if (getChipType() == SM750LE)
-		return sm750le_i2c_init(i2cClkGPIO, i2cDataGPIO);
+		return sm750le_i2c_init(clk_gpio, data_gpio);
 
 	/* Initialize the GPIO pin for the i2c Clock Register */
 	sw_i2c_clk_gpio_mux_reg = GPIO_MUX;
@@ -406,7 +406,7 @@ long sm750_sw_i2c_init(
 	sw_i2c_clk_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
 
 	/* Initialize the Clock GPIO Offset */
-	sw_i2c_clk_gpio = i2cClkGPIO;
+	sw_i2c_clk_gpio = clk_gpio;
 
 	/* Initialize the GPIO pin for the i2c Data Register */
 	sw_i2c_data_gpio_mux_reg = GPIO_MUX;
@@ -414,7 +414,7 @@ long sm750_sw_i2c_init(
 	sw_i2c_data_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
 
 	/* Initialize the Data GPIO Offset */
-	sw_i2c_data_gpio = i2cDataGPIO;
+	sw_i2c_data_gpio = data_gpio;
 
 	/* Enable the GPIO pins for the i2c Clock and Data (GPIO MUX) */
 	POKE32(sw_i2c_clk_gpio_mux_reg,
@@ -436,16 +436,16 @@ long sm750_sw_i2c_init(
  *  This function reads the slave device's register
  *
  *  Parameters:
- *      deviceAddress   - i2c Slave device address which register
+ *      addr   - i2c Slave device address which register
  *                        to be read from
- *      registerIndex   - Slave device's register to be read
+ *      reg    - Slave device's register to be read
  *
  *  Return Value:
  *      Register value
  */
 unsigned char sm750_sw_i2c_read_reg(
-	unsigned char deviceAddress,
-	unsigned char registerIndex
+	unsigned char addr,
+	unsigned char reg
 )
 {
 	unsigned char data;
@@ -454,14 +454,14 @@ unsigned char sm750_sw_i2c_read_reg(
 	sw_i2c_start();
 
 	/* Send the device address */
-	sw_i2c_write_byte(deviceAddress);
+	sw_i2c_write_byte(addr);
 
 	/* Send the register index */
-	sw_i2c_write_byte(registerIndex);
+	sw_i2c_write_byte(reg);
 
 	/* Get the bus again and get the data from the device read address */
 	sw_i2c_start();
-	sw_i2c_write_byte(deviceAddress + 1);
+	sw_i2c_write_byte(addr + 1);
 	data = sw_i2c_read_byte(1);
 
 	/* Stop swI2C and release the bus */
@@ -474,9 +474,9 @@ unsigned char sm750_sw_i2c_read_reg(
  *  This function writes a value to the slave device's register
  *
  *  Parameters:
- *      deviceAddress   - i2c Slave device address which register
+ *      addr            - i2c Slave device address which register
  *                        to be written
- *      registerIndex   - Slave device's register to be written
+ *      reg             - Slave device's register to be written
  *      data            - Data to be written to the register
  *
  *  Result:
@@ -484,12 +484,12 @@ unsigned char sm750_sw_i2c_read_reg(
  *         -1   - Fail
  */
 long sm750_sw_i2c_write_reg(
-	unsigned char deviceAddress,
-	unsigned char registerIndex,
+	unsigned char addr,
+	unsigned char reg,
 	unsigned char data
 )
 {
-	long returnValue = 0;
+	long ret = 0;
 
 	/* Send the Start signal */
 	sw_i2c_start();
@@ -497,14 +497,14 @@ long sm750_sw_i2c_write_reg(
 	/* Send the device address and read the data. All should return success
 	   in order for the writing processed to be successful
 	*/
-	if ((sw_i2c_write_byte(deviceAddress) != 0) ||
-	    (sw_i2c_write_byte(registerIndex) != 0) ||
+	if ((sw_i2c_write_byte(addr) != 0) ||
+	    (sw_i2c_write_byte(reg) != 0) ||
 	    (sw_i2c_write_byte(data) != 0)) {
-		returnValue = -1;
+		ret = -1;
 	}
 
 	/* Stop i2c and release the bus */
 	sw_i2c_stop();
 
-	return returnValue;
+	return ret;
 }

commit 53bc6b6e1a8d7f6a2e16ef701b7c0ecfe627c396
Author: Mike Rapoport <mike.rapoport@gmail.com>
Date:   Sat Sep 12 11:07:46 2015 +0300

    staging: sm750fb: ddk750_swi2c: rename CamelCase static variables
    
    Rename static variables defining I2C GPIO pins and their control registers from
    CamelCase.
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index faaf85823a6a..1d7e8f665e63 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -55,8 +55,8 @@
  ******************************************************************/
 
 /* GPIO pins used for this I2C. It ranges from 0 to 63. */
-static unsigned char g_i2cClockGPIO = DEFAULT_I2C_SCL;
-static unsigned char g_i2cDataGPIO = DEFAULT_I2C_SDA;
+static unsigned char sw_i2c_clk_gpio = DEFAULT_I2C_SCL;
+static unsigned char sw_i2c_data_gpio = DEFAULT_I2C_SDA;
 
 /*
  *  Below is the variable declaration for the GPIO pin register usage
@@ -70,14 +70,14 @@ static unsigned char g_i2cDataGPIO = DEFAULT_I2C_SDA;
  */
 
 /* i2c Clock GPIO Register usage */
-static unsigned long g_i2cClkGPIOMuxReg = GPIO_MUX;
-static unsigned long g_i2cClkGPIODataReg = GPIO_DATA;
-static unsigned long g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION;
+static unsigned long sw_i2c_clk_gpio_mux_reg = GPIO_MUX;
+static unsigned long sw_i2c_clk_gpio_data_reg = GPIO_DATA;
+static unsigned long sw_i2c_clk_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
 
 /* i2c Data GPIO Register usage */
-static unsigned long g_i2cDataGPIOMuxReg = GPIO_MUX;
-static unsigned long g_i2cDataGPIODataReg = GPIO_DATA;
-static unsigned long g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION;
+static unsigned long sw_i2c_data_gpio_mux_reg = GPIO_MUX;
+static unsigned long sw_i2c_data_gpio_data_reg = GPIO_DATA;
+static unsigned long sw_i2c_data_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
 
 /*
  *  This function puts a delay between command
@@ -124,20 +124,20 @@ static void sw_i2c_scl(unsigned char value)
 	unsigned long ulGPIOData;
 	unsigned long ulGPIODirection;
 
-	ulGPIODirection = PEEK32(g_i2cClkGPIODataDirReg);
+	ulGPIODirection = PEEK32(sw_i2c_clk_gpio_data_dir_reg);
 	if (value) {    /* High */
 		/* Set direction as input. This will automatically pull the signal up. */
-		ulGPIODirection &= ~(1 << g_i2cClockGPIO);
-		POKE32(g_i2cClkGPIODataDirReg, ulGPIODirection);
+		ulGPIODirection &= ~(1 << sw_i2c_clk_gpio);
+		POKE32(sw_i2c_clk_gpio_data_dir_reg, ulGPIODirection);
 	} else {        /* Low */
 		/* Set the signal down */
-		ulGPIOData = PEEK32(g_i2cClkGPIODataReg);
-		ulGPIOData &= ~(1 << g_i2cClockGPIO);
-		POKE32(g_i2cClkGPIODataReg, ulGPIOData);
+		ulGPIOData = PEEK32(sw_i2c_clk_gpio_data_reg);
+		ulGPIOData &= ~(1 << sw_i2c_clk_gpio);
+		POKE32(sw_i2c_clk_gpio_data_reg, ulGPIOData);
 
 		/* Set direction as output */
-		ulGPIODirection |= (1 << g_i2cClockGPIO);
-		POKE32(g_i2cClkGPIODataDirReg, ulGPIODirection);
+		ulGPIODirection |= (1 << sw_i2c_clk_gpio);
+		POKE32(sw_i2c_clk_gpio_data_dir_reg, ulGPIODirection);
 	}
 }
 
@@ -158,20 +158,20 @@ static void sw_i2c_sda(unsigned char value)
 	unsigned long ulGPIOData;
 	unsigned long ulGPIODirection;
 
-	ulGPIODirection = PEEK32(g_i2cDataGPIODataDirReg);
+	ulGPIODirection = PEEK32(sw_i2c_data_gpio_data_dir_reg);
 	if (value) {    /* High */
 		/* Set direction as input. This will automatically pull the signal up. */
-		ulGPIODirection &= ~(1 << g_i2cDataGPIO);
-		POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
+		ulGPIODirection &= ~(1 << sw_i2c_data_gpio);
+		POKE32(sw_i2c_data_gpio_data_dir_reg, ulGPIODirection);
 	} else {        /* Low */
 		/* Set the signal down */
-		ulGPIOData = PEEK32(g_i2cDataGPIODataReg);
-		ulGPIOData &= ~(1 << g_i2cDataGPIO);
-		POKE32(g_i2cDataGPIODataReg, ulGPIOData);
+		ulGPIOData = PEEK32(sw_i2c_data_gpio_data_reg);
+		ulGPIOData &= ~(1 << sw_i2c_data_gpio);
+		POKE32(sw_i2c_data_gpio_data_reg, ulGPIOData);
 
 		/* Set direction as output */
-		ulGPIODirection |= (1 << g_i2cDataGPIO);
-		POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
+		ulGPIODirection |= (1 << sw_i2c_data_gpio);
+		POKE32(sw_i2c_data_gpio_data_dir_reg, ulGPIODirection);
 	}
 }
 
@@ -187,15 +187,15 @@ static unsigned char sw_i2c_read_sda(void)
 	unsigned long ulGPIOData;
 
 	/* Make sure that the direction is input (High) */
-	ulGPIODirection = PEEK32(g_i2cDataGPIODataDirReg);
-	if ((ulGPIODirection & (1 << g_i2cDataGPIO)) != (~(1 << g_i2cDataGPIO))) {
-		ulGPIODirection &= ~(1 << g_i2cDataGPIO);
-		POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
+	ulGPIODirection = PEEK32(sw_i2c_data_gpio_data_dir_reg);
+	if ((ulGPIODirection & (1 << sw_i2c_data_gpio)) != (~(1 << sw_i2c_data_gpio))) {
+		ulGPIODirection &= ~(1 << sw_i2c_data_gpio);
+		POKE32(sw_i2c_data_gpio_data_dir_reg, ulGPIODirection);
 	}
 
 	/* Now read the SDA line */
-	ulGPIOData = PEEK32(g_i2cDataGPIODataReg);
-	if (ulGPIOData & (1 << g_i2cDataGPIO))
+	ulGPIOData = PEEK32(sw_i2c_data_gpio_data_reg);
+	if (ulGPIOData & (1 << sw_i2c_data_gpio))
 		return 1;
 	else
 		return 0;
@@ -353,18 +353,18 @@ static long sm750le_i2c_init(unsigned char i2cClkGPIO,
 	int i;
 
 	/* Initialize the GPIO pin for the i2c Clock Register */
-	g_i2cClkGPIODataReg = GPIO_DATA_SM750LE;
-	g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION_SM750LE;
+	sw_i2c_clk_gpio_data_reg = GPIO_DATA_SM750LE;
+	sw_i2c_clk_gpio_data_dir_reg = GPIO_DATA_DIRECTION_SM750LE;
 
 	/* Initialize the Clock GPIO Offset */
-	g_i2cClockGPIO = i2cClkGPIO;
+	sw_i2c_clk_gpio = i2cClkGPIO;
 
 	/* Initialize the GPIO pin for the i2c Data Register */
-	g_i2cDataGPIODataReg = GPIO_DATA_SM750LE;
-	g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION_SM750LE;
+	sw_i2c_data_gpio_data_reg = GPIO_DATA_SM750LE;
+	sw_i2c_data_gpio_data_dir_reg = GPIO_DATA_DIRECTION_SM750LE;
 
 	/* Initialize the Data GPIO Offset */
-	g_i2cDataGPIO = i2cDataGPIO;
+	sw_i2c_data_gpio = i2cDataGPIO;
 
 	/* Note that SM750LE don't have GPIO MUX and power is always on */
 
@@ -401,26 +401,26 @@ long sm750_sw_i2c_init(
 		return sm750le_i2c_init(i2cClkGPIO, i2cDataGPIO);
 
 	/* Initialize the GPIO pin for the i2c Clock Register */
-	g_i2cClkGPIOMuxReg = GPIO_MUX;
-	g_i2cClkGPIODataReg = GPIO_DATA;
-	g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION;
+	sw_i2c_clk_gpio_mux_reg = GPIO_MUX;
+	sw_i2c_clk_gpio_data_reg = GPIO_DATA;
+	sw_i2c_clk_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
 
 	/* Initialize the Clock GPIO Offset */
-	g_i2cClockGPIO = i2cClkGPIO;
+	sw_i2c_clk_gpio = i2cClkGPIO;
 
 	/* Initialize the GPIO pin for the i2c Data Register */
-	g_i2cDataGPIOMuxReg = GPIO_MUX;
-	g_i2cDataGPIODataReg = GPIO_DATA;
-	g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION;
+	sw_i2c_data_gpio_mux_reg = GPIO_MUX;
+	sw_i2c_data_gpio_data_reg = GPIO_DATA;
+	sw_i2c_data_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
 
 	/* Initialize the Data GPIO Offset */
-	g_i2cDataGPIO = i2cDataGPIO;
+	sw_i2c_data_gpio = i2cDataGPIO;
 
 	/* Enable the GPIO pins for the i2c Clock and Data (GPIO MUX) */
-	POKE32(g_i2cClkGPIOMuxReg,
-			PEEK32(g_i2cClkGPIOMuxReg) & ~(1 << g_i2cClockGPIO));
-	POKE32(g_i2cDataGPIOMuxReg,
-			PEEK32(g_i2cDataGPIOMuxReg) & ~(1 << g_i2cDataGPIO));
+	POKE32(sw_i2c_clk_gpio_mux_reg,
+			PEEK32(sw_i2c_clk_gpio_mux_reg) & ~(1 << sw_i2c_clk_gpio));
+	POKE32(sw_i2c_data_gpio_mux_reg,
+			PEEK32(sw_i2c_data_gpio_mux_reg) & ~(1 << sw_i2c_data_gpio));
 
 	/* Enable GPIO power */
 	enableGPIO(1);

commit 6c78f4ce60437e5292202241c317bd2a9e05d3ac
Author: Mike Rapoport <mike.rapoport@gmail.com>
Date:   Sat Sep 12 11:07:42 2015 +0300

    staging: sm750fb: ddk750_swi2c: rename CamelCase static functions
    
    Fix the checkpatch warning about CamelCase.
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 6a10ae3c142a..faaf85823a6a 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -82,7 +82,7 @@ static unsigned long g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION;
 /*
  *  This function puts a delay between command
  */
-static void swI2CWait(void)
+static void sw_i2c_wait(void)
 {
 	/* find a bug:
 	 * peekIO method works well before suspend/resume
@@ -119,7 +119,7 @@ static void swI2CWait(void)
  *      signal because the i2c will fail when other device try to drive the
  *      signal due to SM50x will drive the signal to always high.
  */
-static void swI2CSCL(unsigned char value)
+static void sw_i2c_scl(unsigned char value)
 {
 	unsigned long ulGPIOData;
 	unsigned long ulGPIODirection;
@@ -153,7 +153,7 @@ static void swI2CSCL(unsigned char value)
  *      signal because the i2c will fail when other device try to drive the
  *      signal due to SM50x will drive the signal to always high.
  */
-static void swI2CSDA(unsigned char value)
+static void sw_i2c_sda(unsigned char value)
 {
 	unsigned long ulGPIOData;
 	unsigned long ulGPIODirection;
@@ -181,7 +181,7 @@ static void swI2CSDA(unsigned char value)
  *  Return Value:
  *      The SDA data bit sent by the Slave
  */
-static unsigned char swI2CReadSDA(void)
+static unsigned char sw_i2c_read_sda(void)
 {
 	unsigned long ulGPIODirection;
 	unsigned long ulGPIOData;
@@ -204,7 +204,7 @@ static unsigned char swI2CReadSDA(void)
 /*
  *  This function sends ACK signal
  */
-static void swI2CAck(void)
+static void sw_i2c_ack(void)
 {
 	return;  /* Single byte read is ok without it. */
 }
@@ -212,23 +212,23 @@ static void swI2CAck(void)
 /*
  *  This function sends the start command to the slave device
  */
-static void swI2CStart(void)
+static void sw_i2c_start(void)
 {
 	/* Start I2C */
-	swI2CSDA(1);
-	swI2CSCL(1);
-	swI2CSDA(0);
+	sw_i2c_sda(1);
+	sw_i2c_scl(1);
+	sw_i2c_sda(0);
 }
 
 /*
  *  This function sends the stop command to the slave device
  */
-static void swI2CStop(void)
+static void sw_i2c_stop(void)
 {
 	/* Stop the I2C */
-	swI2CSCL(1);
-	swI2CSDA(0);
-	swI2CSDA(1);
+	sw_i2c_scl(1);
+	sw_i2c_sda(0);
+	sw_i2c_sda(1);
 }
 
 /*
@@ -241,7 +241,7 @@ static void swI2CStop(void)
  *       0   - Success
  *      -1   - Fail to write byte
  */
-static long swI2CWriteByte(unsigned char data)
+static long sw_i2c_write_byte(unsigned char data)
 {
 	unsigned char value = data;
 	int i;
@@ -249,47 +249,47 @@ static long swI2CWriteByte(unsigned char data)
 	/* Sending the data bit by bit */
 	for (i = 0; i < 8; i++) {
 		/* Set SCL to low */
-		swI2CSCL(0);
+		sw_i2c_scl(0);
 
 		/* Send data bit */
 		if ((value & 0x80) != 0)
-			swI2CSDA(1);
+			sw_i2c_sda(1);
 		else
-			swI2CSDA(0);
+			sw_i2c_sda(0);
 
-		swI2CWait();
+		sw_i2c_wait();
 
 		/* Toggle clk line to one */
-		swI2CSCL(1);
-		swI2CWait();
+		sw_i2c_scl(1);
+		sw_i2c_wait();
 
 		/* Shift byte to be sent */
 		value = value << 1;
 	}
 
 	/* Set the SCL Low and SDA High (prepare to get input) */
-	swI2CSCL(0);
-	swI2CSDA(1);
+	sw_i2c_scl(0);
+	sw_i2c_sda(1);
 
 	/* Set the SCL High for ack */
-	swI2CWait();
-	swI2CSCL(1);
-	swI2CWait();
+	sw_i2c_wait();
+	sw_i2c_scl(1);
+	sw_i2c_wait();
 
 	/* Read SDA, until SDA==0 */
 	for (i = 0; i < 0xff; i++) {
-		if (!swI2CReadSDA())
+		if (!sw_i2c_read_sda())
 			break;
 
-		swI2CSCL(0);
-		swI2CWait();
-		swI2CSCL(1);
-		swI2CWait();
+		sw_i2c_scl(0);
+		sw_i2c_wait();
+		sw_i2c_scl(1);
+		sw_i2c_wait();
 	}
 
 	/* Set the SCL Low and SDA High */
-	swI2CSCL(0);
-	swI2CSDA(1);
+	sw_i2c_scl(0);
+	sw_i2c_sda(1);
 
 	if (i < 0xff)
 		return 0;
@@ -307,31 +307,31 @@ static long swI2CWriteByte(unsigned char data)
  *  Return Value:
  *      One byte data read from the Slave device
  */
-static unsigned char swI2CReadByte(unsigned char ack)
+static unsigned char sw_i2c_read_byte(unsigned char ack)
 {
 	int i;
 	unsigned char data = 0;
 
 	for (i = 7; i >= 0; i--) {
 		/* Set the SCL to Low and SDA to High (Input) */
-		swI2CSCL(0);
-		swI2CSDA(1);
-		swI2CWait();
+		sw_i2c_scl(0);
+		sw_i2c_sda(1);
+		sw_i2c_wait();
 
 		/* Set the SCL High */
-		swI2CSCL(1);
-		swI2CWait();
+		sw_i2c_scl(1);
+		sw_i2c_wait();
 
 		/* Read data bits from SDA */
-		data |= (swI2CReadSDA() << i);
+		data |= (sw_i2c_read_sda() << i);
 	}
 
 	if (ack)
-		swI2CAck();
+		sw_i2c_ack();
 
 	/* Set the SCL Low and SDA High */
-	swI2CSCL(0);
-	swI2CSDA(1);
+	sw_i2c_scl(0);
+	sw_i2c_sda(1);
 
 	return data;
 }
@@ -347,7 +347,7 @@ static unsigned char swI2CReadByte(unsigned char ack)
  *      -1   - Fail to initialize the i2c
  *       0   - Success
  */
-static long swI2CInit_SM750LE(unsigned char i2cClkGPIO,
+static long sm750le_i2c_init(unsigned char i2cClkGPIO,
 			      unsigned char i2cDataGPIO)
 {
 	int i;
@@ -370,7 +370,7 @@ static long swI2CInit_SM750LE(unsigned char i2cClkGPIO,
 
 	/* Clear the i2c lines. */
 	for (i = 0; i < 9; i++)
-		swI2CStop();
+		sw_i2c_stop();
 
 	return 0;
 }
@@ -398,7 +398,7 @@ long sm750_sw_i2c_init(
 		return -1;
 
 	if (getChipType() == SM750LE)
-		return swI2CInit_SM750LE(i2cClkGPIO, i2cDataGPIO);
+		return sm750le_i2c_init(i2cClkGPIO, i2cDataGPIO);
 
 	/* Initialize the GPIO pin for the i2c Clock Register */
 	g_i2cClkGPIOMuxReg = GPIO_MUX;
@@ -427,7 +427,7 @@ long sm750_sw_i2c_init(
 
 	/* Clear the i2c lines. */
 	for (i = 0; i < 9; i++)
-		swI2CStop();
+		sw_i2c_stop();
 
 	return 0;
 }
@@ -451,21 +451,21 @@ unsigned char sm750_sw_i2c_read_reg(
 	unsigned char data;
 
 	/* Send the Start signal */
-	swI2CStart();
+	sw_i2c_start();
 
 	/* Send the device address */
-	swI2CWriteByte(deviceAddress);
+	sw_i2c_write_byte(deviceAddress);
 
 	/* Send the register index */
-	swI2CWriteByte(registerIndex);
+	sw_i2c_write_byte(registerIndex);
 
 	/* Get the bus again and get the data from the device read address */
-	swI2CStart();
-	swI2CWriteByte(deviceAddress + 1);
-	data = swI2CReadByte(1);
+	sw_i2c_start();
+	sw_i2c_write_byte(deviceAddress + 1);
+	data = sw_i2c_read_byte(1);
 
 	/* Stop swI2C and release the bus */
-	swI2CStop();
+	sw_i2c_stop();
 
 	return data;
 }
@@ -492,19 +492,19 @@ long sm750_sw_i2c_write_reg(
 	long returnValue = 0;
 
 	/* Send the Start signal */
-	swI2CStart();
+	sw_i2c_start();
 
 	/* Send the device address and read the data. All should return success
 	   in order for the writing processed to be successful
 	*/
-	if ((swI2CWriteByte(deviceAddress) != 0) ||
-	    (swI2CWriteByte(registerIndex) != 0) ||
-	    (swI2CWriteByte(data) != 0)) {
+	if ((sw_i2c_write_byte(deviceAddress) != 0) ||
+	    (sw_i2c_write_byte(registerIndex) != 0) ||
+	    (sw_i2c_write_byte(data) != 0)) {
 		returnValue = -1;
 	}
 
 	/* Stop i2c and release the bus */
-	swI2CStop();
+	sw_i2c_stop();
 
 	return returnValue;
 }

commit 01a64c4469acf6556c7e622e8874f84cb95a23bf
Author: Mike Rapoport <mike.rapoport@gmail.com>
Date:   Sat Sep 12 11:07:41 2015 +0300

    staging: sm750fb: ddk750_swi2c: staticize swI2C{SCL,SDA}
    
    swI2C{SCL,SDA} are not used outside ddk750_swi2c, make them static
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index e3f60ebe7d09..6a10ae3c142a 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -119,7 +119,7 @@ static void swI2CWait(void)
  *      signal because the i2c will fail when other device try to drive the
  *      signal due to SM50x will drive the signal to always high.
  */
-void swI2CSCL(unsigned char value)
+static void swI2CSCL(unsigned char value)
 {
 	unsigned long ulGPIOData;
 	unsigned long ulGPIODirection;
@@ -153,7 +153,7 @@ void swI2CSCL(unsigned char value)
  *      signal because the i2c will fail when other device try to drive the
  *      signal due to SM50x will drive the signal to always high.
  */
-void swI2CSDA(unsigned char value)
+static void swI2CSDA(unsigned char value)
 {
 	unsigned long ulGPIOData;
 	unsigned long ulGPIODirection;

commit d33b42048ed97dfacc031707e3aefa63da631237
Author: Mike Rapoport <mike.rapoport@gmail.com>
Date:   Sat Sep 12 11:07:40 2015 +0300

    staging: sm750fb: rename swI2CWriteReg to sm750_sw_i2c_write_reg
    
    Fix the checkpatch warning about CamelCase.
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 765edd628aff..e3f60ebe7d09 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -483,7 +483,7 @@ unsigned char sm750_sw_i2c_read_reg(
  *          0   - Success
  *         -1   - Fail
  */
-long swI2CWriteReg(
+long sm750_sw_i2c_write_reg(
 	unsigned char deviceAddress,
 	unsigned char registerIndex,
 	unsigned char data

commit 288836b69f1a3fd96d742fdf9bc4a827f8f625e5
Author: Mike Rapoport <mike.rapoport@gmail.com>
Date:   Sat Sep 12 11:07:39 2015 +0300

    staging: sm750fb: rename swI2CReadReg to sm750_sw_i2c_read_reg
    
    Fix the checkpatch warning about CamelCase.
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index ecfd300d432f..765edd628aff 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -443,7 +443,7 @@ long sm750_sw_i2c_init(
  *  Return Value:
  *      Register value
  */
-unsigned char swI2CReadReg(
+unsigned char sm750_sw_i2c_read_reg(
 	unsigned char deviceAddress,
 	unsigned char registerIndex
 )

commit f2ea7733ddd741e0803015271573fec0c529ba27
Author: Mike Rapoport <mike.rapoport@gmail.com>
Date:   Sat Sep 12 11:07:38 2015 +0300

    staging: sm750fb: rename swI2CInit to sm750_sw_i2c_init
    
    Fix the checkpatch warning about CamelCase.
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 5133bccf17bd..ecfd300d432f 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -386,7 +386,7 @@ static long swI2CInit_SM750LE(unsigned char i2cClkGPIO,
  *      -1   - Fail to initialize the i2c
  *       0   - Success
  */
-long swI2CInit(
+long sm750_sw_i2c_init(
 	unsigned char i2cClkGPIO,
 	unsigned char i2cDataGPIO
 )

commit 6bdee8bddde0ab76f458a9a05b8bcf80a7de3fb0
Author: Isaac Assegai <isaac.a.travers@gmail.com>
Date:   Thu Jun 18 21:48:55 2015 -0700

    Staging: sm750fb: ddk750_swi2c.c: Insert spaces before parenthesis
    
    Insert spaces before open parenthesis in ddk750_swi2c.c
    to rectify the following checkpatch errors:
    ERROR: space required before the open parenthesis '('
    
    Signed-off-by: Isaac Assegai <isaac.a.travers@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 2cf3514ac59a..5133bccf17bd 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -96,11 +96,11 @@ static void swI2CWait(void)
        it's more reliable than counter loop ..
        write 0x61 to 0x3ce and read from 0x3cf
        */
-	while(peekIO(0x3ce, 0x61) & 0x10);
+	while (peekIO(0x3ce, 0x61) & 0x10);
 #else
 	int i, Temp;
 
-	for(i = 0; i < 600; i++) {
+	for (i = 0; i < 600; i++) {
 		Temp = i;
 		Temp += i;
 	}
@@ -277,7 +277,7 @@ static long swI2CWriteByte(unsigned char data)
 	swI2CWait();
 
 	/* Read SDA, until SDA==0 */
-	for(i = 0; i < 0xff; i++) {
+	for (i = 0; i < 0xff; i++) {
 		if (!swI2CReadSDA())
 			break;
 
@@ -312,7 +312,7 @@ static unsigned char swI2CReadByte(unsigned char ack)
 	int i;
 	unsigned char data = 0;
 
-	for(i = 7; i >= 0; i--) {
+	for (i = 7; i >= 0; i--) {
 		/* Set the SCL to Low and SDA to High (Input) */
 		swI2CSCL(0);
 		swI2CSDA(1);
@@ -369,7 +369,7 @@ static long swI2CInit_SM750LE(unsigned char i2cClkGPIO,
 	/* Note that SM750LE don't have GPIO MUX and power is always on */
 
 	/* Clear the i2c lines. */
-	for(i = 0; i < 9; i++)
+	for (i = 0; i < 9; i++)
 		swI2CStop();
 
 	return 0;
@@ -426,7 +426,7 @@ long swI2CInit(
 	enableGPIO(1);
 
 	/* Clear the i2c lines. */
-	for(i = 0; i < 9; i++)
+	for (i = 0; i < 9; i++)
 		swI2CStop();
 
 	return 0;

commit d3f431d0ffced1db5d3567173f8984c5a5c74a1a
Author: Isaac Assegai <isaac.a.travers@gmail.com>
Date:   Thu Jun 18 21:48:54 2015 -0700

    Staging: sm750fb: ddk750_swi2c.c: Place braces on correct lines
    
    Place braces on correct lines in ddk750_swi2c.c
    to rectify the following checkpatch errors:
    ERROR: that open brace { should be on the previous line
    
    Signed-off-by: Isaac Assegai <isaac.a.travers@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index a5878353b4dc..2cf3514ac59a 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -100,8 +100,7 @@ static void swI2CWait(void)
 #else
 	int i, Temp;
 
-	for(i = 0; i < 600; i++)
-	{
+	for(i = 0; i < 600; i++) {
 		Temp = i;
 		Temp += i;
 	}
@@ -126,14 +125,11 @@ void swI2CSCL(unsigned char value)
 	unsigned long ulGPIODirection;
 
 	ulGPIODirection = PEEK32(g_i2cClkGPIODataDirReg);
-	if (value)      /* High */
-	{
+	if (value) {    /* High */
 		/* Set direction as input. This will automatically pull the signal up. */
 		ulGPIODirection &= ~(1 << g_i2cClockGPIO);
 		POKE32(g_i2cClkGPIODataDirReg, ulGPIODirection);
-	}
-	else            /* Low */
-	{
+	} else {        /* Low */
 		/* Set the signal down */
 		ulGPIOData = PEEK32(g_i2cClkGPIODataReg);
 		ulGPIOData &= ~(1 << g_i2cClockGPIO);
@@ -163,14 +159,11 @@ void swI2CSDA(unsigned char value)
 	unsigned long ulGPIODirection;
 
 	ulGPIODirection = PEEK32(g_i2cDataGPIODataDirReg);
-	if (value)      /* High */
-	{
+	if (value) {    /* High */
 		/* Set direction as input. This will automatically pull the signal up. */
 		ulGPIODirection &= ~(1 << g_i2cDataGPIO);
 		POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
-	}
-	else            /* Low */
-	{
+	} else {        /* Low */
 		/* Set the signal down */
 		ulGPIOData = PEEK32(g_i2cDataGPIODataReg);
 		ulGPIOData &= ~(1 << g_i2cDataGPIO);
@@ -195,8 +188,7 @@ static unsigned char swI2CReadSDA(void)
 
 	/* Make sure that the direction is input (High) */
 	ulGPIODirection = PEEK32(g_i2cDataGPIODataDirReg);
-	if ((ulGPIODirection & (1 << g_i2cDataGPIO)) != (~(1 << g_i2cDataGPIO)))
-	{
+	if ((ulGPIODirection & (1 << g_i2cDataGPIO)) != (~(1 << g_i2cDataGPIO))) {
 		ulGPIODirection &= ~(1 << g_i2cDataGPIO);
 		POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
 	}
@@ -255,8 +247,7 @@ static long swI2CWriteByte(unsigned char data)
 	int i;
 
 	/* Sending the data bit by bit */
-	for (i = 0; i < 8; i++)
-	{
+	for (i = 0; i < 8; i++) {
 		/* Set SCL to low */
 		swI2CSCL(0);
 
@@ -286,8 +277,7 @@ static long swI2CWriteByte(unsigned char data)
 	swI2CWait();
 
 	/* Read SDA, until SDA==0 */
-	for(i = 0; i < 0xff; i++)
-	{
+	for(i = 0; i < 0xff; i++) {
 		if (!swI2CReadSDA())
 			break;
 
@@ -322,8 +312,7 @@ static unsigned char swI2CReadByte(unsigned char ack)
 	int i;
 	unsigned char data = 0;
 
-	for(i = 7; i >= 0; i--)
-	{
+	for(i = 7; i >= 0; i--) {
 		/* Set the SCL to Low and SDA to High (Input) */
 		swI2CSCL(0);
 		swI2CSDA(1);
@@ -510,8 +499,7 @@ long swI2CWriteReg(
 	*/
 	if ((swI2CWriteByte(deviceAddress) != 0) ||
 	    (swI2CWriteByte(registerIndex) != 0) ||
-	    (swI2CWriteByte(data) != 0))
-	{
+	    (swI2CWriteByte(data) != 0)) {
 		returnValue = -1;
 	}
 

commit 6d43b0f482561ab421a91ebf59a51192d66cf8a7
Author: Isaac Assegai <isaac.a.travers@gmail.com>
Date:   Thu Jun 18 21:48:53 2015 -0700

    Staging: sm750fb: ddk750_swi2c.c: Insert spaces around operators
    
    Insert spaces around comparison operators in ddk750_swi2c.c
    to rectify the following set of checkpatch errors:
    ERROR: spaces required around that '='
    ERROR: spaces required around that '<'
    ERROR: spaces required around that '>='
    
    Signed-off-by: Isaac Assegai <isaac.a.travers@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index e2c30dfcef79..a5878353b4dc 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -100,7 +100,7 @@ static void swI2CWait(void)
 #else
 	int i, Temp;
 
-	for(i=0; i<600; i++)
+	for(i = 0; i < 600; i++)
 	{
 		Temp = i;
 		Temp += i;
@@ -255,7 +255,7 @@ static long swI2CWriteByte(unsigned char data)
 	int i;
 
 	/* Sending the data bit by bit */
-	for (i=0; i<8; i++)
+	for (i = 0; i < 8; i++)
 	{
 		/* Set SCL to low */
 		swI2CSCL(0);
@@ -286,7 +286,7 @@ static long swI2CWriteByte(unsigned char data)
 	swI2CWait();
 
 	/* Read SDA, until SDA==0 */
-	for(i=0; i<0xff; i++)
+	for(i = 0; i < 0xff; i++)
 	{
 		if (!swI2CReadSDA())
 			break;
@@ -301,7 +301,7 @@ static long swI2CWriteByte(unsigned char data)
 	swI2CSCL(0);
 	swI2CSDA(1);
 
-	if (i<0xff)
+	if (i < 0xff)
 		return 0;
 	else
 		return -1;
@@ -322,7 +322,7 @@ static unsigned char swI2CReadByte(unsigned char ack)
 	int i;
 	unsigned char data = 0;
 
-	for(i=7; i>=0; i--)
+	for(i = 7; i >= 0; i--)
 	{
 		/* Set the SCL to Low and SDA to High (Input) */
 		swI2CSCL(0);
@@ -380,7 +380,7 @@ static long swI2CInit_SM750LE(unsigned char i2cClkGPIO,
 	/* Note that SM750LE don't have GPIO MUX and power is always on */
 
 	/* Clear the i2c lines. */
-	for(i=0; i<9; i++)
+	for(i = 0; i < 9; i++)
 		swI2CStop();
 
 	return 0;
@@ -437,7 +437,7 @@ long swI2CInit(
 	enableGPIO(1);
 
 	/* Clear the i2c lines. */
-	for(i=0; i<9; i++)
+	for(i = 0; i < 9; i++)
 		swI2CStop();
 
 	return 0;

commit 7ef803a92db8a74c12a0d3c654a041eed42fa078
Author: Isaac Assegai <isaac.a.travers@gmail.com>
Date:   Thu Jun 18 21:48:52 2015 -0700

    Staging: sm750fb: ddk750_swi2c.c: Replace spaces with tabs
    
    Replace spaces with tabs in ddk750_swi2c.c to
    rectify the following checkpatch warnings:
    WARNING: please, no spaces at the start of a line
    
    Signed-off-by: Isaac Assegai <isaac.a.travers@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index fc8f5a51e43c..e2c30dfcef79 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -98,13 +98,13 @@ static void swI2CWait(void)
        */
 	while(peekIO(0x3ce, 0x61) & 0x10);
 #else
-    int i, Temp;
+	int i, Temp;
 
-    for(i=0; i<600; i++)
-    {
-        Temp = i;
-        Temp += i;
-    }
+	for(i=0; i<600; i++)
+	{
+		Temp = i;
+		Temp += i;
+	}
 #endif
 }
 
@@ -122,27 +122,27 @@ static void swI2CWait(void)
  */
 void swI2CSCL(unsigned char value)
 {
-    unsigned long ulGPIOData;
-    unsigned long ulGPIODirection;
-
-    ulGPIODirection = PEEK32(g_i2cClkGPIODataDirReg);
-    if (value)      /* High */
-    {
-        /* Set direction as input. This will automatically pull the signal up. */
-        ulGPIODirection &= ~(1 << g_i2cClockGPIO);
-        POKE32(g_i2cClkGPIODataDirReg, ulGPIODirection);
-    }
-    else            /* Low */
-    {
-        /* Set the signal down */
-        ulGPIOData = PEEK32(g_i2cClkGPIODataReg);
-        ulGPIOData &= ~(1 << g_i2cClockGPIO);
-        POKE32(g_i2cClkGPIODataReg, ulGPIOData);
-
-        /* Set direction as output */
-        ulGPIODirection |= (1 << g_i2cClockGPIO);
-        POKE32(g_i2cClkGPIODataDirReg, ulGPIODirection);
-    }
+	unsigned long ulGPIOData;
+	unsigned long ulGPIODirection;
+
+	ulGPIODirection = PEEK32(g_i2cClkGPIODataDirReg);
+	if (value)      /* High */
+	{
+		/* Set direction as input. This will automatically pull the signal up. */
+		ulGPIODirection &= ~(1 << g_i2cClockGPIO);
+		POKE32(g_i2cClkGPIODataDirReg, ulGPIODirection);
+	}
+	else            /* Low */
+	{
+		/* Set the signal down */
+		ulGPIOData = PEEK32(g_i2cClkGPIODataReg);
+		ulGPIOData &= ~(1 << g_i2cClockGPIO);
+		POKE32(g_i2cClkGPIODataReg, ulGPIOData);
+
+		/* Set direction as output */
+		ulGPIODirection |= (1 << g_i2cClockGPIO);
+		POKE32(g_i2cClkGPIODataDirReg, ulGPIODirection);
+	}
 }
 
 /*
@@ -159,27 +159,27 @@ void swI2CSCL(unsigned char value)
  */
 void swI2CSDA(unsigned char value)
 {
-    unsigned long ulGPIOData;
-    unsigned long ulGPIODirection;
-
-    ulGPIODirection = PEEK32(g_i2cDataGPIODataDirReg);
-    if (value)      /* High */
-    {
-        /* Set direction as input. This will automatically pull the signal up. */
-        ulGPIODirection &= ~(1 << g_i2cDataGPIO);
-        POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
-    }
-    else            /* Low */
-    {
-        /* Set the signal down */
-        ulGPIOData = PEEK32(g_i2cDataGPIODataReg);
-        ulGPIOData &= ~(1 << g_i2cDataGPIO);
-        POKE32(g_i2cDataGPIODataReg, ulGPIOData);
-
-        /* Set direction as output */
-        ulGPIODirection |= (1 << g_i2cDataGPIO);
-        POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
-    }
+	unsigned long ulGPIOData;
+	unsigned long ulGPIODirection;
+
+	ulGPIODirection = PEEK32(g_i2cDataGPIODataDirReg);
+	if (value)      /* High */
+	{
+		/* Set direction as input. This will automatically pull the signal up. */
+		ulGPIODirection &= ~(1 << g_i2cDataGPIO);
+		POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
+	}
+	else            /* Low */
+	{
+		/* Set the signal down */
+		ulGPIOData = PEEK32(g_i2cDataGPIODataReg);
+		ulGPIOData &= ~(1 << g_i2cDataGPIO);
+		POKE32(g_i2cDataGPIODataReg, ulGPIOData);
+
+		/* Set direction as output */
+		ulGPIODirection |= (1 << g_i2cDataGPIO);
+		POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
+	}
 }
 
 /*
@@ -190,23 +190,23 @@ void swI2CSDA(unsigned char value)
  */
 static unsigned char swI2CReadSDA(void)
 {
-    unsigned long ulGPIODirection;
-    unsigned long ulGPIOData;
-
-    /* Make sure that the direction is input (High) */
-    ulGPIODirection = PEEK32(g_i2cDataGPIODataDirReg);
-    if ((ulGPIODirection & (1 << g_i2cDataGPIO)) != (~(1 << g_i2cDataGPIO)))
-    {
-        ulGPIODirection &= ~(1 << g_i2cDataGPIO);
-        POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
-    }
-
-    /* Now read the SDA line */
-    ulGPIOData = PEEK32(g_i2cDataGPIODataReg);
-    if (ulGPIOData & (1 << g_i2cDataGPIO))
-        return 1;
-    else
-        return 0;
+	unsigned long ulGPIODirection;
+	unsigned long ulGPIOData;
+
+	/* Make sure that the direction is input (High) */
+	ulGPIODirection = PEEK32(g_i2cDataGPIODataDirReg);
+	if ((ulGPIODirection & (1 << g_i2cDataGPIO)) != (~(1 << g_i2cDataGPIO)))
+	{
+		ulGPIODirection &= ~(1 << g_i2cDataGPIO);
+		POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
+	}
+
+	/* Now read the SDA line */
+	ulGPIOData = PEEK32(g_i2cDataGPIODataReg);
+	if (ulGPIOData & (1 << g_i2cDataGPIO))
+		return 1;
+	else
+		return 0;
 }
 
 /*
@@ -214,7 +214,7 @@ static unsigned char swI2CReadSDA(void)
  */
 static void swI2CAck(void)
 {
-    return;  /* Single byte read is ok without it. */
+	return;  /* Single byte read is ok without it. */
 }
 
 /*
@@ -222,10 +222,10 @@ static void swI2CAck(void)
  */
 static void swI2CStart(void)
 {
-    /* Start I2C */
-    swI2CSDA(1);
-    swI2CSCL(1);
-    swI2CSDA(0);
+	/* Start I2C */
+	swI2CSDA(1);
+	swI2CSCL(1);
+	swI2CSDA(0);
 }
 
 /*
@@ -233,10 +233,10 @@ static void swI2CStart(void)
  */
 static void swI2CStop(void)
 {
-    /* Stop the I2C */
-    swI2CSCL(1);
-    swI2CSDA(0);
-    swI2CSDA(1);
+	/* Stop the I2C */
+	swI2CSCL(1);
+	swI2CSDA(0);
+	swI2CSDA(1);
 }
 
 /*
@@ -251,60 +251,60 @@ static void swI2CStop(void)
  */
 static long swI2CWriteByte(unsigned char data)
 {
-    unsigned char value = data;
-    int i;
-
-    /* Sending the data bit by bit */
-    for (i=0; i<8; i++)
-    {
-        /* Set SCL to low */
-        swI2CSCL(0);
-
-        /* Send data bit */
-        if ((value & 0x80) != 0)
-            swI2CSDA(1);
-        else
-            swI2CSDA(0);
-
-        swI2CWait();
-
-        /* Toggle clk line to one */
-        swI2CSCL(1);
-        swI2CWait();
-
-        /* Shift byte to be sent */
-        value = value << 1;
-    }
-
-    /* Set the SCL Low and SDA High (prepare to get input) */
-    swI2CSCL(0);
-    swI2CSDA(1);
-
-    /* Set the SCL High for ack */
-    swI2CWait();
-    swI2CSCL(1);
-    swI2CWait();
-
-    /* Read SDA, until SDA==0 */
-    for(i=0; i<0xff; i++)
-    {
-        if (!swI2CReadSDA())
-            break;
-
-        swI2CSCL(0);
-        swI2CWait();
-        swI2CSCL(1);
-        swI2CWait();
-    }
-
-    /* Set the SCL Low and SDA High */
-    swI2CSCL(0);
-    swI2CSDA(1);
-
-    if (i<0xff)
-        return 0;
-    else
-        return -1;
+	unsigned char value = data;
+	int i;
+
+	/* Sending the data bit by bit */
+	for (i=0; i<8; i++)
+	{
+		/* Set SCL to low */
+		swI2CSCL(0);
+
+		/* Send data bit */
+		if ((value & 0x80) != 0)
+			swI2CSDA(1);
+		else
+			swI2CSDA(0);
+
+		swI2CWait();
+
+		/* Toggle clk line to one */
+		swI2CSCL(1);
+		swI2CWait();
+
+		/* Shift byte to be sent */
+		value = value << 1;
+	}
+
+	/* Set the SCL Low and SDA High (prepare to get input) */
+	swI2CSCL(0);
+	swI2CSDA(1);
+
+	/* Set the SCL High for ack */
+	swI2CWait();
+	swI2CSCL(1);
+	swI2CWait();
+
+	/* Read SDA, until SDA==0 */
+	for(i=0; i<0xff; i++)
+	{
+		if (!swI2CReadSDA())
+			break;
+
+		swI2CSCL(0);
+		swI2CWait();
+		swI2CSCL(1);
+		swI2CWait();
+	}
+
+	/* Set the SCL Low and SDA High */
+	swI2CSCL(0);
+	swI2CSDA(1);
+
+	if (i<0xff)
+		return 0;
+	else
+		return -1;
 }
 
 /*
@@ -319,32 +319,32 @@ static long swI2CWriteByte(unsigned char data)
  */
 static unsigned char swI2CReadByte(unsigned char ack)
 {
-    int i;
-    unsigned char data = 0;
+	int i;
+	unsigned char data = 0;
 
-    for(i=7; i>=0; i--)
-    {
-        /* Set the SCL to Low and SDA to High (Input) */
-        swI2CSCL(0);
-        swI2CSDA(1);
-        swI2CWait();
+	for(i=7; i>=0; i--)
+	{
+		/* Set the SCL to Low and SDA to High (Input) */
+		swI2CSCL(0);
+		swI2CSDA(1);
+		swI2CWait();
 
-        /* Set the SCL High */
-        swI2CSCL(1);
-        swI2CWait();
+		/* Set the SCL High */
+		swI2CSCL(1);
+		swI2CWait();
 
-        /* Read data bits from SDA */
-        data |= (swI2CReadSDA() << i);
-    }
+		/* Read data bits from SDA */
+		data |= (swI2CReadSDA() << i);
+	}
 
-    if (ack)
-        swI2CAck();
+	if (ack)
+		swI2CAck();
 
-    /* Set the SCL Low and SDA High */
-    swI2CSCL(0);
-    swI2CSDA(1);
+	/* Set the SCL Low and SDA High */
+	swI2CSCL(0);
+	swI2CSDA(1);
 
-    return data;
+	return data;
 }
 
 /*
@@ -361,29 +361,29 @@ static unsigned char swI2CReadByte(unsigned char ack)
 static long swI2CInit_SM750LE(unsigned char i2cClkGPIO,
 			      unsigned char i2cDataGPIO)
 {
-    int i;
+	int i;
 
-    /* Initialize the GPIO pin for the i2c Clock Register */
-    g_i2cClkGPIODataReg = GPIO_DATA_SM750LE;
-    g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION_SM750LE;
+	/* Initialize the GPIO pin for the i2c Clock Register */
+	g_i2cClkGPIODataReg = GPIO_DATA_SM750LE;
+	g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION_SM750LE;
 
-    /* Initialize the Clock GPIO Offset */
-    g_i2cClockGPIO = i2cClkGPIO;
+	/* Initialize the Clock GPIO Offset */
+	g_i2cClockGPIO = i2cClkGPIO;
 
-    /* Initialize the GPIO pin for the i2c Data Register */
-    g_i2cDataGPIODataReg = GPIO_DATA_SM750LE;
-    g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION_SM750LE;
+	/* Initialize the GPIO pin for the i2c Data Register */
+	g_i2cDataGPIODataReg = GPIO_DATA_SM750LE;
+	g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION_SM750LE;
 
-    /* Initialize the Data GPIO Offset */
-    g_i2cDataGPIO = i2cDataGPIO;
+	/* Initialize the Data GPIO Offset */
+	g_i2cDataGPIO = i2cDataGPIO;
 
-    /* Note that SM750LE don't have GPIO MUX and power is always on */
+	/* Note that SM750LE don't have GPIO MUX and power is always on */
 
-    /* Clear the i2c lines. */
-    for(i=0; i<9; i++)
-        swI2CStop();
+	/* Clear the i2c lines. */
+	for(i=0; i<9; i++)
+		swI2CStop();
 
-    return 0;
+	return 0;
 }
 
 /*
@@ -398,49 +398,49 @@ static long swI2CInit_SM750LE(unsigned char i2cClkGPIO,
  *       0   - Success
  */
 long swI2CInit(
-    unsigned char i2cClkGPIO,
-    unsigned char i2cDataGPIO
+	unsigned char i2cClkGPIO,
+	unsigned char i2cDataGPIO
 )
 {
-    int i;
+	int i;
 
-    /* Return 0 if the GPIO pins to be used is out of range. The range is only from [0..63] */
-    if ((i2cClkGPIO > 31) || (i2cDataGPIO > 31))
-        return -1;
+	/* Return 0 if the GPIO pins to be used is out of range. The range is only from [0..63] */
+	if ((i2cClkGPIO > 31) || (i2cDataGPIO > 31))
+		return -1;
 
-    if (getChipType() == SM750LE)
-        return swI2CInit_SM750LE(i2cClkGPIO, i2cDataGPIO);
+	if (getChipType() == SM750LE)
+		return swI2CInit_SM750LE(i2cClkGPIO, i2cDataGPIO);
 
-    /* Initialize the GPIO pin for the i2c Clock Register */
-    g_i2cClkGPIOMuxReg = GPIO_MUX;
-    g_i2cClkGPIODataReg = GPIO_DATA;
-    g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION;
+	/* Initialize the GPIO pin for the i2c Clock Register */
+	g_i2cClkGPIOMuxReg = GPIO_MUX;
+	g_i2cClkGPIODataReg = GPIO_DATA;
+	g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION;
 
-    /* Initialize the Clock GPIO Offset */
-    g_i2cClockGPIO = i2cClkGPIO;
+	/* Initialize the Clock GPIO Offset */
+	g_i2cClockGPIO = i2cClkGPIO;
 
-    /* Initialize the GPIO pin for the i2c Data Register */
-    g_i2cDataGPIOMuxReg = GPIO_MUX;
-    g_i2cDataGPIODataReg = GPIO_DATA;
-    g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION;
+	/* Initialize the GPIO pin for the i2c Data Register */
+	g_i2cDataGPIOMuxReg = GPIO_MUX;
+	g_i2cDataGPIODataReg = GPIO_DATA;
+	g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION;
 
-    /* Initialize the Data GPIO Offset */
-    g_i2cDataGPIO = i2cDataGPIO;
+	/* Initialize the Data GPIO Offset */
+	g_i2cDataGPIO = i2cDataGPIO;
 
-    /* Enable the GPIO pins for the i2c Clock and Data (GPIO MUX) */
-    POKE32(g_i2cClkGPIOMuxReg,
-                      PEEK32(g_i2cClkGPIOMuxReg) & ~(1 << g_i2cClockGPIO));
-    POKE32(g_i2cDataGPIOMuxReg,
-                      PEEK32(g_i2cDataGPIOMuxReg) & ~(1 << g_i2cDataGPIO));
+	/* Enable the GPIO pins for the i2c Clock and Data (GPIO MUX) */
+	POKE32(g_i2cClkGPIOMuxReg,
+			PEEK32(g_i2cClkGPIOMuxReg) & ~(1 << g_i2cClockGPIO));
+	POKE32(g_i2cDataGPIOMuxReg,
+			PEEK32(g_i2cDataGPIOMuxReg) & ~(1 << g_i2cDataGPIO));
 
-    /* Enable GPIO power */
-    enableGPIO(1);
+	/* Enable GPIO power */
+	enableGPIO(1);
 
-    /* Clear the i2c lines. */
-    for(i=0; i<9; i++)
-        swI2CStop();
+	/* Clear the i2c lines. */
+	for(i=0; i<9; i++)
+		swI2CStop();
 
-    return 0;
+	return 0;
 }
 
 /*
@@ -455,30 +455,30 @@ long swI2CInit(
  *      Register value
  */
 unsigned char swI2CReadReg(
-    unsigned char deviceAddress,
-    unsigned char registerIndex
+	unsigned char deviceAddress,
+	unsigned char registerIndex
 )
 {
-    unsigned char data;
+	unsigned char data;
 
-    /* Send the Start signal */
-    swI2CStart();
+	/* Send the Start signal */
+	swI2CStart();
 
-    /* Send the device address */
-    swI2CWriteByte(deviceAddress);
+	/* Send the device address */
+	swI2CWriteByte(deviceAddress);
 
-    /* Send the register index */
-    swI2CWriteByte(registerIndex);
+	/* Send the register index */
+	swI2CWriteByte(registerIndex);
 
-    /* Get the bus again and get the data from the device read address */
-    swI2CStart();
-    swI2CWriteByte(deviceAddress + 1);
-    data = swI2CReadByte(1);
+	/* Get the bus again and get the data from the device read address */
+	swI2CStart();
+	swI2CWriteByte(deviceAddress + 1);
+	data = swI2CReadByte(1);
 
-    /* Stop swI2C and release the bus */
-    swI2CStop();
+	/* Stop swI2C and release the bus */
+	swI2CStop();
 
-    return data;
+	return data;
 }
 
 /*
@@ -495,28 +495,28 @@ unsigned char swI2CReadReg(
  *         -1   - Fail
  */
 long swI2CWriteReg(
-    unsigned char deviceAddress,
-    unsigned char registerIndex,
-    unsigned char data
+	unsigned char deviceAddress,
+	unsigned char registerIndex,
+	unsigned char data
 )
 {
-    long returnValue = 0;
+	long returnValue = 0;
 
-    /* Send the Start signal */
-    swI2CStart();
+	/* Send the Start signal */
+	swI2CStart();
 
-    /* Send the device address and read the data. All should return success
-       in order for the writing processed to be successful
-     */
-    if ((swI2CWriteByte(deviceAddress) != 0) ||
-        (swI2CWriteByte(registerIndex) != 0) ||
-        (swI2CWriteByte(data) != 0))
-    {
-        returnValue = -1;
-    }
+	/* Send the device address and read the data. All should return success
+	   in order for the writing processed to be successful
+	*/
+	if ((swI2CWriteByte(deviceAddress) != 0) ||
+	    (swI2CWriteByte(registerIndex) != 0) ||
+	    (swI2CWriteByte(data) != 0))
+	{
+		returnValue = -1;
+	}
 
-    /* Stop i2c and release the bus */
-    swI2CStop();
+	/* Stop i2c and release the bus */
+	swI2CStop();
 
-    return returnValue;
+	return returnValue;
 }

commit f31b55ac2ad8227ac005be29e5e81b743e1ec3b7
Author: Isaac Assegai <isaac.a.travers@gmail.com>
Date:   Tue Jun 2 03:14:28 2015 -0700

    Staging: sm750fb: Insert spaces after commas in two files.
    
    Insert Spaces after commas to rectify the following
    checkpatch errors in ddk750_power.c and ddk750_swi2c.c:
    ERROR: space required after that ','
    
    Signed-off-by: Isaac Assegai <isaac.a.travers@gmail.com>:
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 901b3737f1ed..fc8f5a51e43c 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -96,7 +96,7 @@ static void swI2CWait(void)
        it's more reliable than counter loop ..
        write 0x61 to 0x3ce and read from 0x3cf
        */
-	while(peekIO(0x3ce,0x61) & 0x10);
+	while(peekIO(0x3ce, 0x61) & 0x10);
 #else
     int i, Temp;
 

commit 6a9df4303b2325a7ed3c44fbf4f8878798fb2c94
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Mon Mar 16 11:51:09 2015 +0100

    staging/sm75fb: Declare static functions as such
    
    This patch fixes this sparse warning
    
    CHECK   drivers/staging/sm750fb/ddk750_swi2c.c
    drivers/staging/sm750fb/ddk750_swi2c.c:223:6: warning: symbol
      'swI2CStart' was not declared. Should it be static?
    drivers/staging/sm750fb/ddk750_swi2c.c:234:6: warning: symbol
      'swI2CStop' was not declared. Should it be static?
    drivers/staging/sm750fb/ddk750_swi2c.c:252:6: warning: symbol
      'swI2CWriteByte' was not declared. Should it be static?
    drivers/staging/sm750fb/ddk750_swi2c.c:320:15: warning: symbol
      'swI2CReadByte' was not declared. Should it be static?
    drivers/staging/sm750fb/ddk750_swi2c.c:361:6: warning: symbol
      'swI2CInit_SM750LE' was not declared. Should it be static?
    
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 8557cce2f420..901b3737f1ed 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -220,7 +220,7 @@ static void swI2CAck(void)
 /*
  *  This function sends the start command to the slave device
  */
-void swI2CStart(void)
+static void swI2CStart(void)
 {
     /* Start I2C */
     swI2CSDA(1);
@@ -231,7 +231,7 @@ void swI2CStart(void)
 /*
  *  This function sends the stop command to the slave device
  */
-void swI2CStop(void)
+static void swI2CStop(void)
 {
     /* Stop the I2C */
     swI2CSCL(1);
@@ -249,7 +249,7 @@ void swI2CStop(void)
  *       0   - Success
  *      -1   - Fail to write byte
  */
-long swI2CWriteByte(unsigned char data)
+static long swI2CWriteByte(unsigned char data)
 {
     unsigned char value = data;
     int i;
@@ -317,7 +317,7 @@ long swI2CWriteByte(unsigned char data)
  *  Return Value:
  *      One byte data read from the Slave device
  */
-unsigned char swI2CReadByte(unsigned char ack)
+static unsigned char swI2CReadByte(unsigned char ack)
 {
     int i;
     unsigned char data = 0;
@@ -358,10 +358,8 @@ unsigned char swI2CReadByte(unsigned char ack)
  *      -1   - Fail to initialize the i2c
  *       0   - Success
  */
-long swI2CInit_SM750LE(
-    unsigned char i2cClkGPIO,
-    unsigned char i2cDataGPIO
-)
+static long swI2CInit_SM750LE(unsigned char i2cClkGPIO,
+			      unsigned char i2cDataGPIO)
 {
     int i;
 

commit 6946edd07a98e74fa7eedc465dc37a615830a311
Author: Supriya Karanth <iskaranth@gmail.com>
Date:   Sat Mar 14 21:55:11 2015 +0900

    staging: sm750fb: remove parantheses from return statements
    
    found by checkpatch.pl :ERROR: return is not a function,
    parentheses are not required
    
    changes made using coccinelle script:
    
    @@
    expression e,e1;
    @@
    (
    return (e / e1);
    |
    return
    -(
    e
    -)
    ;
    )
    
    Signed-off-by: Supriya Karanth <iskaranth@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index 1249759eb347..8557cce2f420 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -304,7 +304,7 @@ long swI2CWriteByte(unsigned char data)
     if (i<0xff)
         return 0;
     else
-        return (-1);
+        return -1;
 }
 
 /*
@@ -408,10 +408,10 @@ long swI2CInit(
 
     /* Return 0 if the GPIO pins to be used is out of range. The range is only from [0..63] */
     if ((i2cClkGPIO > 31) || (i2cDataGPIO > 31))
-        return (-1);
+        return -1;
 
     if (getChipType() == SM750LE)
-        return( swI2CInit_SM750LE(i2cClkGPIO, i2cDataGPIO) );
+        return swI2CInit_SM750LE(i2cClkGPIO, i2cDataGPIO);
 
     /* Initialize the GPIO pin for the i2c Clock Register */
     g_i2cClkGPIOMuxReg = GPIO_MUX;

commit 4933b29bd4e007a0544c97ea47fa0a091c5fec53
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Tue Mar 10 22:46:52 2015 +0530

    staging: sm750fb: remove unused functions
    
    removed the functions which were not used anywhere.
    it has been build tested also confirmed with git grep that there is
    no other reference of these functions.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index cae6b9bc6472..1249759eb347 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -79,14 +79,6 @@ static unsigned long g_i2cDataGPIOMuxReg = GPIO_MUX;
 static unsigned long g_i2cDataGPIODataReg = GPIO_DATA;
 static unsigned long g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION;
 
-static unsigned char peekIO(unsigned short port,unsigned short index)
-{
-#if defined(__i386__) || defined( __x86_64__)
-		outb_p(index,port);
-		return inb_p(port+1);
-#endif
-}
-
 /*
  *  This function puts a delay between command
  */

commit c97df7c2c0692ebed4eff9abaf61a8e12cc250ed
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Tue Mar 10 14:15:36 2015 +0530

    staging: sm750fb: remove pragma optimize
    
    remove use of #pragma optimize which will usually be ignored by the
    compiler.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
index b53407bb2042..cae6b9bc6472 100644
--- a/drivers/staging/sm750fb/ddk750_swi2c.c
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -217,8 +217,6 @@ static unsigned char swI2CReadSDA(void)
         return 0;
 }
 
-#pragma optimize( "", off )
-
 /*
  *  This function sends ACK signal
  */
@@ -356,7 +354,6 @@ unsigned char swI2CReadByte(unsigned char ack)
 
     return data;
 }
-#pragma optimize( "", on )
 
 /*
  * This function initializes GPIO port for SW I2C communication.

commit 81dee67e215b23f0c98182eece122b906d35765a
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Tue Mar 3 16:21:06 2015 +0530

    staging: sm750fb: add sm750 to staging
    
    sm750 of Silicon Motion is pci-e display controller device and has
    features like dual display and 2D acceleration. This patch adds the
    driver to staging.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/sm750fb/ddk750_swi2c.c b/drivers/staging/sm750fb/ddk750_swi2c.c
new file mode 100644
index 000000000000..b53407bb2042
--- /dev/null
+++ b/drivers/staging/sm750fb/ddk750_swi2c.c
@@ -0,0 +1,535 @@
+/*******************************************************************
+*
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+*
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+*
+*  swi2c.c --- SM750/SM718 DDK
+*  This file contains the source code for I2C using software
+*  implementation.
+*
+*******************************************************************/
+#include "ddk750_help.h"
+#include "ddk750_reg.h"
+#include "ddk750_swi2c.h"
+#include "ddk750_power.h"
+
+
+/*******************************************************************
+ * I2C Software Master Driver:
+ * ===========================
+ * Each i2c cycle is split into 4 sections. Each of these section marks
+ * a point in time where the SCL or SDA may be changed.
+ *
+ * 1 Cycle == |  Section I. |  Section 2. |  Section 3. |  Section 4. |
+ *            +-------------+-------------+-------------+-------------+
+ *            | SCL set LOW |SCL no change| SCL set HIGH|SCL no change|
+ *
+ *                                          ____________ _____________
+ * SCL == XXXX _____________ ____________ /
+ *
+ * I.e. the SCL may only be changed in section 1. and section 3. while
+ * the SDA may only be changed in section 2. and section 4. The table
+ * below gives the changes for these 2 lines in the varios sections.
+ *
+ * Section changes Table:
+ * ======================
+ * blank = no change, L = set bit LOW, H = set bit HIGH
+ *
+ *                                | 1.| 2.| 3.| 4.|
+ *                 ---------------+---+---+---+---+
+ *                 Tx Start   SDA |   | H |   | L |
+ *                            SCL | L |   | H |   |
+ *                 ---------------+---+---+---+---+
+ *                 Tx Stop    SDA |   | L |   | H |
+ *                            SCL | L |   | H |   |
+ *                 ---------------+---+---+---+---+
+ *                 Tx bit H   SDA |   | H |   |   |
+ *                            SCL | L |   | H |   |
+ *                 ---------------+---+---+---+---+
+ *                 Tx bit L   SDA |   | L |   |   |
+ *                            SCL | L |   | H |   |
+ *                 ---------------+---+---+---+---+
+ *
+ ******************************************************************/
+
+/* GPIO pins used for this I2C. It ranges from 0 to 63. */
+static unsigned char g_i2cClockGPIO = DEFAULT_I2C_SCL;
+static unsigned char g_i2cDataGPIO = DEFAULT_I2C_SDA;
+
+/*
+ *  Below is the variable declaration for the GPIO pin register usage
+ *  for the i2c Clock and i2c Data.
+ *
+ *  Note:
+ *      Notice that the GPIO usage for the i2c clock and i2c Data are
+ *      separated. This is to make this code flexible enough when
+ *      two separate GPIO pins for the clock and data are located
+ *      in two different GPIO register set (worst case).
+ */
+
+/* i2c Clock GPIO Register usage */
+static unsigned long g_i2cClkGPIOMuxReg = GPIO_MUX;
+static unsigned long g_i2cClkGPIODataReg = GPIO_DATA;
+static unsigned long g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION;
+
+/* i2c Data GPIO Register usage */
+static unsigned long g_i2cDataGPIOMuxReg = GPIO_MUX;
+static unsigned long g_i2cDataGPIODataReg = GPIO_DATA;
+static unsigned long g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION;
+
+static unsigned char peekIO(unsigned short port,unsigned short index)
+{
+#if defined(__i386__) || defined( __x86_64__)
+		outb_p(index,port);
+		return inb_p(port+1);
+#endif
+}
+
+/*
+ *  This function puts a delay between command
+ */
+static void swI2CWait(void)
+{
+	/* find a bug:
+	 * peekIO method works well before suspend/resume
+	 * but after suspend, peekIO(0x3ce,0x61) & 0x10
+	 * always be non-zero,which makes the while loop
+	 * never finish.
+	 * use non-ultimate for loop below is safe
+	 * */
+#if 0
+    /* Change wait algorithm to use PCI bus clock,
+       it's more reliable than counter loop ..
+       write 0x61 to 0x3ce and read from 0x3cf
+       */
+	while(peekIO(0x3ce,0x61) & 0x10);
+#else
+    int i, Temp;
+
+    for(i=0; i<600; i++)
+    {
+        Temp = i;
+        Temp += i;
+    }
+#endif
+}
+
+/*
+ *  This function set/reset the SCL GPIO pin
+ *
+ *  Parameters:
+ *      value    - Bit value to set to the SCL or SDA (0 = low, 1 = high)
+ *
+ *  Notes:
+ *      When setting SCL to high, just set the GPIO as input where the pull up
+ *      resistor will pull the signal up. Do not use software to pull up the
+ *      signal because the i2c will fail when other device try to drive the
+ *      signal due to SM50x will drive the signal to always high.
+ */
+void swI2CSCL(unsigned char value)
+{
+    unsigned long ulGPIOData;
+    unsigned long ulGPIODirection;
+
+    ulGPIODirection = PEEK32(g_i2cClkGPIODataDirReg);
+    if (value)      /* High */
+    {
+        /* Set direction as input. This will automatically pull the signal up. */
+        ulGPIODirection &= ~(1 << g_i2cClockGPIO);
+        POKE32(g_i2cClkGPIODataDirReg, ulGPIODirection);
+    }
+    else            /* Low */
+    {
+        /* Set the signal down */
+        ulGPIOData = PEEK32(g_i2cClkGPIODataReg);
+        ulGPIOData &= ~(1 << g_i2cClockGPIO);
+        POKE32(g_i2cClkGPIODataReg, ulGPIOData);
+
+        /* Set direction as output */
+        ulGPIODirection |= (1 << g_i2cClockGPIO);
+        POKE32(g_i2cClkGPIODataDirReg, ulGPIODirection);
+    }
+}
+
+/*
+ *  This function set/reset the SDA GPIO pin
+ *
+ *  Parameters:
+ *      value    - Bit value to set to the SCL or SDA (0 = low, 1 = high)
+ *
+ *  Notes:
+ *      When setting SCL to high, just set the GPIO as input where the pull up
+ *      resistor will pull the signal up. Do not use software to pull up the
+ *      signal because the i2c will fail when other device try to drive the
+ *      signal due to SM50x will drive the signal to always high.
+ */
+void swI2CSDA(unsigned char value)
+{
+    unsigned long ulGPIOData;
+    unsigned long ulGPIODirection;
+
+    ulGPIODirection = PEEK32(g_i2cDataGPIODataDirReg);
+    if (value)      /* High */
+    {
+        /* Set direction as input. This will automatically pull the signal up. */
+        ulGPIODirection &= ~(1 << g_i2cDataGPIO);
+        POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
+    }
+    else            /* Low */
+    {
+        /* Set the signal down */
+        ulGPIOData = PEEK32(g_i2cDataGPIODataReg);
+        ulGPIOData &= ~(1 << g_i2cDataGPIO);
+        POKE32(g_i2cDataGPIODataReg, ulGPIOData);
+
+        /* Set direction as output */
+        ulGPIODirection |= (1 << g_i2cDataGPIO);
+        POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
+    }
+}
+
+/*
+ *  This function read the data from the SDA GPIO pin
+ *
+ *  Return Value:
+ *      The SDA data bit sent by the Slave
+ */
+static unsigned char swI2CReadSDA(void)
+{
+    unsigned long ulGPIODirection;
+    unsigned long ulGPIOData;
+
+    /* Make sure that the direction is input (High) */
+    ulGPIODirection = PEEK32(g_i2cDataGPIODataDirReg);
+    if ((ulGPIODirection & (1 << g_i2cDataGPIO)) != (~(1 << g_i2cDataGPIO)))
+    {
+        ulGPIODirection &= ~(1 << g_i2cDataGPIO);
+        POKE32(g_i2cDataGPIODataDirReg, ulGPIODirection);
+    }
+
+    /* Now read the SDA line */
+    ulGPIOData = PEEK32(g_i2cDataGPIODataReg);
+    if (ulGPIOData & (1 << g_i2cDataGPIO))
+        return 1;
+    else
+        return 0;
+}
+
+#pragma optimize( "", off )
+
+/*
+ *  This function sends ACK signal
+ */
+static void swI2CAck(void)
+{
+    return;  /* Single byte read is ok without it. */
+}
+
+/*
+ *  This function sends the start command to the slave device
+ */
+void swI2CStart(void)
+{
+    /* Start I2C */
+    swI2CSDA(1);
+    swI2CSCL(1);
+    swI2CSDA(0);
+}
+
+/*
+ *  This function sends the stop command to the slave device
+ */
+void swI2CStop(void)
+{
+    /* Stop the I2C */
+    swI2CSCL(1);
+    swI2CSDA(0);
+    swI2CSDA(1);
+}
+
+/*
+ *  This function writes one byte to the slave device
+ *
+ *  Parameters:
+ *      data    - Data to be write to the slave device
+ *
+ *  Return Value:
+ *       0   - Success
+ *      -1   - Fail to write byte
+ */
+long swI2CWriteByte(unsigned char data)
+{
+    unsigned char value = data;
+    int i;
+
+    /* Sending the data bit by bit */
+    for (i=0; i<8; i++)
+    {
+        /* Set SCL to low */
+        swI2CSCL(0);
+
+        /* Send data bit */
+        if ((value & 0x80) != 0)
+            swI2CSDA(1);
+        else
+            swI2CSDA(0);
+
+        swI2CWait();
+
+        /* Toggle clk line to one */
+        swI2CSCL(1);
+        swI2CWait();
+
+        /* Shift byte to be sent */
+        value = value << 1;
+    }
+
+    /* Set the SCL Low and SDA High (prepare to get input) */
+    swI2CSCL(0);
+    swI2CSDA(1);
+
+    /* Set the SCL High for ack */
+    swI2CWait();
+    swI2CSCL(1);
+    swI2CWait();
+
+    /* Read SDA, until SDA==0 */
+    for(i=0; i<0xff; i++)
+    {
+        if (!swI2CReadSDA())
+            break;
+
+        swI2CSCL(0);
+        swI2CWait();
+        swI2CSCL(1);
+        swI2CWait();
+    }
+
+    /* Set the SCL Low and SDA High */
+    swI2CSCL(0);
+    swI2CSDA(1);
+
+    if (i<0xff)
+        return 0;
+    else
+        return (-1);
+}
+
+/*
+ *  This function reads one byte from the slave device
+ *
+ *  Parameters:
+ *      ack    - Flag to indicate either to send the acknowledge
+ *            message to the slave device or not
+ *
+ *  Return Value:
+ *      One byte data read from the Slave device
+ */
+unsigned char swI2CReadByte(unsigned char ack)
+{
+    int i;
+    unsigned char data = 0;
+
+    for(i=7; i>=0; i--)
+    {
+        /* Set the SCL to Low and SDA to High (Input) */
+        swI2CSCL(0);
+        swI2CSDA(1);
+        swI2CWait();
+
+        /* Set the SCL High */
+        swI2CSCL(1);
+        swI2CWait();
+
+        /* Read data bits from SDA */
+        data |= (swI2CReadSDA() << i);
+    }
+
+    if (ack)
+        swI2CAck();
+
+    /* Set the SCL Low and SDA High */
+    swI2CSCL(0);
+    swI2CSDA(1);
+
+    return data;
+}
+#pragma optimize( "", on )
+
+/*
+ * This function initializes GPIO port for SW I2C communication.
+ *
+ * Parameters:
+ *      i2cClkGPIO      - The GPIO pin to be used as i2c SCL
+ *      i2cDataGPIO     - The GPIO pin to be used as i2c SDA
+ *
+ * Return Value:
+ *      -1   - Fail to initialize the i2c
+ *       0   - Success
+ */
+long swI2CInit_SM750LE(
+    unsigned char i2cClkGPIO,
+    unsigned char i2cDataGPIO
+)
+{
+    int i;
+
+    /* Initialize the GPIO pin for the i2c Clock Register */
+    g_i2cClkGPIODataReg = GPIO_DATA_SM750LE;
+    g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION_SM750LE;
+
+    /* Initialize the Clock GPIO Offset */
+    g_i2cClockGPIO = i2cClkGPIO;
+
+    /* Initialize the GPIO pin for the i2c Data Register */
+    g_i2cDataGPIODataReg = GPIO_DATA_SM750LE;
+    g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION_SM750LE;
+
+    /* Initialize the Data GPIO Offset */
+    g_i2cDataGPIO = i2cDataGPIO;
+
+    /* Note that SM750LE don't have GPIO MUX and power is always on */
+
+    /* Clear the i2c lines. */
+    for(i=0; i<9; i++)
+        swI2CStop();
+
+    return 0;
+}
+
+/*
+ * This function initializes the i2c attributes and bus
+ *
+ * Parameters:
+ *      i2cClkGPIO      - The GPIO pin to be used as i2c SCL
+ *      i2cDataGPIO     - The GPIO pin to be used as i2c SDA
+ *
+ * Return Value:
+ *      -1   - Fail to initialize the i2c
+ *       0   - Success
+ */
+long swI2CInit(
+    unsigned char i2cClkGPIO,
+    unsigned char i2cDataGPIO
+)
+{
+    int i;
+
+    /* Return 0 if the GPIO pins to be used is out of range. The range is only from [0..63] */
+    if ((i2cClkGPIO > 31) || (i2cDataGPIO > 31))
+        return (-1);
+
+    if (getChipType() == SM750LE)
+        return( swI2CInit_SM750LE(i2cClkGPIO, i2cDataGPIO) );
+
+    /* Initialize the GPIO pin for the i2c Clock Register */
+    g_i2cClkGPIOMuxReg = GPIO_MUX;
+    g_i2cClkGPIODataReg = GPIO_DATA;
+    g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION;
+
+    /* Initialize the Clock GPIO Offset */
+    g_i2cClockGPIO = i2cClkGPIO;
+
+    /* Initialize the GPIO pin for the i2c Data Register */
+    g_i2cDataGPIOMuxReg = GPIO_MUX;
+    g_i2cDataGPIODataReg = GPIO_DATA;
+    g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION;
+
+    /* Initialize the Data GPIO Offset */
+    g_i2cDataGPIO = i2cDataGPIO;
+
+    /* Enable the GPIO pins for the i2c Clock and Data (GPIO MUX) */
+    POKE32(g_i2cClkGPIOMuxReg,
+                      PEEK32(g_i2cClkGPIOMuxReg) & ~(1 << g_i2cClockGPIO));
+    POKE32(g_i2cDataGPIOMuxReg,
+                      PEEK32(g_i2cDataGPIOMuxReg) & ~(1 << g_i2cDataGPIO));
+
+    /* Enable GPIO power */
+    enableGPIO(1);
+
+    /* Clear the i2c lines. */
+    for(i=0; i<9; i++)
+        swI2CStop();
+
+    return 0;
+}
+
+/*
+ *  This function reads the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be read from
+ *      registerIndex   - Slave device's register to be read
+ *
+ *  Return Value:
+ *      Register value
+ */
+unsigned char swI2CReadReg(
+    unsigned char deviceAddress,
+    unsigned char registerIndex
+)
+{
+    unsigned char data;
+
+    /* Send the Start signal */
+    swI2CStart();
+
+    /* Send the device address */
+    swI2CWriteByte(deviceAddress);
+
+    /* Send the register index */
+    swI2CWriteByte(registerIndex);
+
+    /* Get the bus again and get the data from the device read address */
+    swI2CStart();
+    swI2CWriteByte(deviceAddress + 1);
+    data = swI2CReadByte(1);
+
+    /* Stop swI2C and release the bus */
+    swI2CStop();
+
+    return data;
+}
+
+/*
+ *  This function writes a value to the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be written
+ *      registerIndex   - Slave device's register to be written
+ *      data            - Data to be written to the register
+ *
+ *  Result:
+ *          0   - Success
+ *         -1   - Fail
+ */
+long swI2CWriteReg(
+    unsigned char deviceAddress,
+    unsigned char registerIndex,
+    unsigned char data
+)
+{
+    long returnValue = 0;
+
+    /* Send the Start signal */
+    swI2CStart();
+
+    /* Send the device address and read the data. All should return success
+       in order for the writing processed to be successful
+     */
+    if ((swI2CWriteByte(deviceAddress) != 0) ||
+        (swI2CWriteByte(registerIndex) != 0) ||
+        (swI2CWriteByte(data) != 0))
+    {
+        returnValue = -1;
+    }
+
+    /* Stop i2c and release the bus */
+    swI2CStop();
+
+    return returnValue;
+}
