commit 7ba31c3f2f1ee095d8126f4d3757fc3b2bc3c838
Merge: ca9b5b628398 fc157998b825
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 29 10:15:11 2020 -0800

    Merge tag 'staging-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging and IIO updates from Greg KH:
     "Here is the big staging/iio driver patches for 5.6-rc1
    
      Included in here are:
    
       - lots of new IIO drivers and updates for that subsystem
    
       - the usual huge quantity of minor cleanups for staging drivers
    
       - removal of the following staging drivers:
           - isdn/avm
           - isdn/gigaset
           - isdn/hysdn
           - octeon-usb
           - octeon ethernet
    
      Overall we deleted far more lines than we added, removing over 40k of
      old and obsolete driver code.
    
      All of these changes have been in linux-next for a while with no
      reported issues"
    
    * tag 'staging-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (353 commits)
      staging: most: usb: check for NULL device
      staging: next: configfs: fix release link
      staging: most: core: fix logging messages
      staging: most: core: remove container struct
      staging: most: remove struct device core driver
      staging: most: core: drop device reference
      staging: most: remove device from interface structure
      staging: comedi: drivers: fix spelling mistake "to" -> "too"
      staging: exfat: remove fs_func struct.
      staging: wilc1000: avoid mutex unlock without lock in wilc_wlan_handle_txq()
      staging: wilc1000: return zero on success and non-zero on function failure
      staging: axis-fifo: replace spinlock with mutex
      staging: wilc1000: remove unused code prior to throughput enhancement in SPI
      staging: wilc1000: added 'wilc_' prefix for 'struct assoc_resp' name
      staging: wilc1000: move firmware API struct's to separate header file
      staging: wilc1000: remove use of infinite loop conditions
      staging: kpc2000: rename variables with kpc namespace
      staging: vt6656: Remove memory buffer from vnt_download_firmware.
      staging: vt6656: Just check NEWRSR_DECRYPTOK for RX_FLAG_DECRYPTED.
      staging: vt6656: Use vnt_rx_tail struct for tail variables.
      ...

commit b5909c6d16fd4e3972b0cd48dedde08d55575342
Author: Jerry Lin <wahahab11@gmail.com>
Date:   Tue Jan 21 10:46:21 2020 +0800

    staging: kpc2000: rename variables with kpc namespace
    
    Some namings in kpc2000_i2c are too ambiguous that may causing
    confusion to the readers.
    
    Rename some variable, function and struct name to prefix with 'kpc_i2c'
    to eliminate confusions.
    
    Signed-off-by: Jerry Lin <wahahab11@gmail.com>
    Link: https://lore.kernel.org/r/20200121024620.GA10842@compute1
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 10b9cee9bffd..07945f540428 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -32,7 +32,7 @@
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Matt.Sickler@Daktronics.com");
 
-struct i2c_device {
+struct kpc_i2c {
 	unsigned long           smba;
 	struct i2c_adapter      adapter;
 	unsigned int            features;
@@ -131,7 +131,7 @@ struct i2c_device {
 /* Make sure the SMBus host is ready to start transmitting.
  * Return 0 if it is, -EBUSY if it is not.
  */
-static int i801_check_pre(struct i2c_device *priv)
+static int i801_check_pre(struct kpc_i2c *priv)
 {
 	int status;
 
@@ -156,7 +156,7 @@ static int i801_check_pre(struct i2c_device *priv)
 }
 
 /* Convert the status register to an error code, and clear it. */
-static int i801_check_post(struct i2c_device *priv, int status, int timeout)
+static int i801_check_post(struct kpc_i2c *priv, int status, int timeout)
 {
 	int result = 0;
 
@@ -206,7 +206,7 @@ static int i801_check_post(struct i2c_device *priv, int status, int timeout)
 	return result;
 }
 
-static int i801_transaction(struct i2c_device *priv, int xact)
+static int i801_transaction(struct kpc_i2c *priv, int xact)
 {
 	int status;
 	int result;
@@ -235,7 +235,7 @@ static int i801_transaction(struct i2c_device *priv, int xact)
 }
 
 /* wait for INTR bit as advised by Intel */
-static void i801_wait_hwpec(struct i2c_device *priv)
+static void i801_wait_hwpec(struct kpc_i2c *priv)
 {
 	int timeout = 0;
 	int status;
@@ -251,7 +251,7 @@ static void i801_wait_hwpec(struct i2c_device *priv)
 	outb_p(status, SMBHSTSTS(priv));
 }
 
-static int i801_block_transaction_by_block(struct i2c_device *priv,
+static int i801_block_transaction_by_block(struct kpc_i2c *priv,
 					   union i2c_smbus_data *data,
 					   char read_write, int hwpec)
 {
@@ -285,7 +285,7 @@ static int i801_block_transaction_by_block(struct i2c_device *priv,
 	return 0;
 }
 
-static int i801_block_transaction_byte_by_byte(struct i2c_device *priv,
+static int i801_block_transaction_byte_by_byte(struct kpc_i2c *priv,
 					       union i2c_smbus_data *data,
 					       char read_write, int command,
 					       int hwpec)
@@ -367,7 +367,7 @@ static int i801_block_transaction_byte_by_byte(struct i2c_device *priv,
 	return 0;
 }
 
-static int i801_set_block_buffer_mode(struct i2c_device *priv)
+static int i801_set_block_buffer_mode(struct kpc_i2c *priv)
 {
 	outb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_E32B, SMBAUXCTL(priv));
 	if ((inb_p(SMBAUXCTL(priv)) & SMBAUXCTL_E32B) == 0)
@@ -376,7 +376,7 @@ static int i801_set_block_buffer_mode(struct i2c_device *priv)
 }
 
 /* Block transaction function */
-static int i801_block_transaction(struct i2c_device *priv,
+static int i801_block_transaction(struct kpc_i2c *priv,
 				  union i2c_smbus_data *data, char read_write,
 				  int command, int hwpec)
 {
@@ -440,7 +440,7 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr,
 	int hwpec;
 	int block = 0;
 	int ret, xact = 0;
-	struct i2c_device *priv = i2c_get_adapdata(adap);
+	struct kpc_i2c *priv = i2c_get_adapdata(adap);
 
 	hwpec = (priv->features & FEATURE_SMBUS_PEC) &&
 		(flags & I2C_CLIENT_PEC) &&
@@ -578,7 +578,7 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr,
 
 static u32 i801_func(struct i2c_adapter *adapter)
 {
-	struct i2c_device *priv = i2c_get_adapdata(adapter);
+	struct kpc_i2c *priv = i2c_get_adapdata(adapter);
 
 	/* original settings
 	 * u32 f = I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
@@ -648,10 +648,10 @@ static const struct i2c_algorithm smbus_algorithm = {
 /********************************
  *** Part 2 - Driver Handlers ***
  ********************************/
-static int pi2c_probe(struct platform_device *pldev)
+static int kpc_i2c_probe(struct platform_device *pldev)
 {
 	int err;
-	struct i2c_device *priv;
+	struct kpc_i2c *priv;
 	struct resource *res;
 
 	priv = devm_kzalloc(&pldev->dev, sizeof(*priv), GFP_KERNEL);
@@ -700,11 +700,11 @@ static int pi2c_probe(struct platform_device *pldev)
 	return 0;
 }
 
-static int pi2c_remove(struct platform_device *pldev)
+static int kpc_i2c_remove(struct platform_device *pldev)
 {
-	struct i2c_device *lddev;
+	struct kpc_i2c *lddev;
 
-	lddev = (struct i2c_device *)platform_get_drvdata(pldev);
+	lddev = (struct kpc_i2c *)platform_get_drvdata(pldev);
 
 	i2c_del_adapter(&lddev->adapter);
 
@@ -718,12 +718,12 @@ static int pi2c_remove(struct platform_device *pldev)
 	return 0;
 }
 
-static struct platform_driver i2c_plat_driver_i = {
-	.probe      = pi2c_probe,
-	.remove     = pi2c_remove,
+static struct platform_driver kpc_i2c_driver = {
+	.probe      = kpc_i2c_probe,
+	.remove     = kpc_i2c_remove,
 	.driver     = {
 		.name   = KP_DRIVER_NAME_I2C,
 	},
 };
 
-module_platform_driver(i2c_plat_driver_i);
+module_platform_driver(kpc_i2c_driver);

commit 27f391a5d628f860e2245f59f97461cbd22433f1
Author: Felipe Cardoso Resende <felipecardoso.fcr@gmail.com>
Date:   Thu Jan 16 21:42:14 2020 -0300

    Staging: kpc2000: Remove warning: "dubious: x | !y" detected by sparse
    
    Sparse complains about "dubious: x | !y".
    
    This patch adds some macros to make it clear if a flag will be enabled or
    not so Sparse stops complaining about dubious code construct.
    
    Signed-off-by: Felipe Cardoso Resende <felipecardoso.fcr@gmail.com>
    Link: https://lore.kernel.org/r/20200117004214.GA1800@felipe-pc
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 5460bf973c9c..10b9cee9bffd 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -572,6 +572,10 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr,
 	return 0;
 }
 
+#define enable_flag(x) (x)
+#define disable_flag(x) 0
+#define enable_flag_if(x, cond) ((cond) ? (x) : 0)
+
 static u32 i801_func(struct i2c_adapter *adapter)
 {
 	struct i2c_device *priv = i2c_get_adapdata(adapter);
@@ -588,42 +592,42 @@ static u32 i801_func(struct i2c_adapter *adapter)
 	// http://lxr.free-electrons.com/source/include/uapi/linux/i2c.h#L85
 
 	u32 f =
-		I2C_FUNC_I2C                     | /* 0x00000001(I enabled this
-						    * one)
-						    */
-		!I2C_FUNC_10BIT_ADDR             |		/* 0x00000002 */
-		!I2C_FUNC_PROTOCOL_MANGLING      |		/* 0x00000004 */
-		((priv->features & FEATURE_SMBUS_PEC) ?
-			I2C_FUNC_SMBUS_PEC : 0)  |		/* 0x00000008 */
-		!I2C_FUNC_SMBUS_BLOCK_PROC_CALL  |		/* 0x00008000 */
-		I2C_FUNC_SMBUS_QUICK             |		/* 0x00010000 */
-		!I2C_FUNC_SMBUS_READ_BYTE	 |		/* 0x00020000 */
-		!I2C_FUNC_SMBUS_WRITE_BYTE       |		/* 0x00040000 */
-		!I2C_FUNC_SMBUS_READ_BYTE_DATA   |		/* 0x00080000 */
-		!I2C_FUNC_SMBUS_WRITE_BYTE_DATA  |		/* 0x00100000 */
-		!I2C_FUNC_SMBUS_READ_WORD_DATA   |		/* 0x00200000 */
-		!I2C_FUNC_SMBUS_WRITE_WORD_DATA  |		/* 0x00400000 */
-		!I2C_FUNC_SMBUS_PROC_CALL        |		/* 0x00800000 */
-		!I2C_FUNC_SMBUS_READ_BLOCK_DATA  |		/* 0x01000000 */
-		!I2C_FUNC_SMBUS_WRITE_BLOCK_DATA |		/* 0x02000000 */
-		((priv->features & FEATURE_I2C_BLOCK_READ) ?
-			I2C_FUNC_SMBUS_READ_I2C_BLOCK : 0) |	/* 0x04000000 */
-		I2C_FUNC_SMBUS_WRITE_I2C_BLOCK   |		/* 0x08000000 */
-
-		I2C_FUNC_SMBUS_BYTE              | /* _READ_BYTE  _WRITE_BYTE */
-		I2C_FUNC_SMBUS_BYTE_DATA         | /* _READ_BYTE_DATA
-						    * _WRITE_BYTE_DATA
-						    */
-		I2C_FUNC_SMBUS_WORD_DATA         | /* _READ_WORD_DATA
-						    * _WRITE_WORD_DATA
-						    */
-		I2C_FUNC_SMBUS_BLOCK_DATA        | /* _READ_BLOCK_DATA
-						    * _WRITE_BLOCK_DATA
-						    */
-		!I2C_FUNC_SMBUS_I2C_BLOCK        | /* _READ_I2C_BLOCK
-						    * _WRITE_I2C_BLOCK
-						    */
-		!I2C_FUNC_SMBUS_EMUL;              /* _QUICK  _BYTE
+		enable_flag(I2C_FUNC_I2C) | /* 0x00000001(I enabled this one) */
+		disable_flag(I2C_FUNC_10BIT_ADDR)             | /* 0x00000002 */
+		disable_flag(I2C_FUNC_PROTOCOL_MANGLING)      | /* 0x00000004 */
+		enable_flag_if(I2C_FUNC_SMBUS_PEC,
+			       priv->features & FEATURE_SMBUS_PEC) |
+								/* 0x00000008 */
+		disable_flag(I2C_FUNC_SMBUS_BLOCK_PROC_CALL)  | /* 0x00008000 */
+		enable_flag(I2C_FUNC_SMBUS_QUICK)             | /* 0x00010000 */
+		disable_flag(I2C_FUNC_SMBUS_READ_BYTE)	      |	/* 0x00020000 */
+		disable_flag(I2C_FUNC_SMBUS_WRITE_BYTE)       |	/* 0x00040000 */
+		disable_flag(I2C_FUNC_SMBUS_READ_BYTE_DATA)   |	/* 0x00080000 */
+		disable_flag(I2C_FUNC_SMBUS_WRITE_BYTE_DATA)  |	/* 0x00100000 */
+		disable_flag(I2C_FUNC_SMBUS_READ_WORD_DATA)   |	/* 0x00200000 */
+		disable_flag(I2C_FUNC_SMBUS_WRITE_WORD_DATA)  |	/* 0x00400000 */
+		disable_flag(I2C_FUNC_SMBUS_PROC_CALL)        |	/* 0x00800000 */
+		disable_flag(I2C_FUNC_SMBUS_READ_BLOCK_DATA)  |	/* 0x01000000 */
+		disable_flag(I2C_FUNC_SMBUS_WRITE_BLOCK_DATA) |	/* 0x02000000 */
+		enable_flag_if(I2C_FUNC_SMBUS_READ_I2C_BLOCK,
+			       priv->features & FEATURE_I2C_BLOCK_READ) |
+								/* 0x04000000 */
+		enable_flag(I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)   |	/* 0x08000000 */
+
+		enable_flag(I2C_FUNC_SMBUS_BYTE) | /* _READ_BYTE  _WRITE_BYTE */
+		enable_flag(I2C_FUNC_SMBUS_BYTE_DATA)  | /* _READ_BYTE_DATA
+							  * _WRITE_BYTE_DATA
+							  */
+		enable_flag(I2C_FUNC_SMBUS_WORD_DATA)  | /* _READ_WORD_DATA
+							  * _WRITE_WORD_DATA
+							  */
+		enable_flag(I2C_FUNC_SMBUS_BLOCK_DATA) | /* _READ_BLOCK_DATA
+							  * _WRITE_BLOCK_DATA
+							  */
+		disable_flag(I2C_FUNC_SMBUS_I2C_BLOCK) | /* _READ_I2C_BLOCK
+							  * _WRITE_I2C_BLOCK
+							  */
+		disable_flag(I2C_FUNC_SMBUS_EMUL); /* _QUICK  _BYTE
 						    * _BYTE_DATA  _WORD_DATA
 						    * _PROC_CALL
 						    * _WRITE_BLOCK_DATA
@@ -632,6 +636,10 @@ static u32 i801_func(struct i2c_adapter *adapter)
 	return f;
 }
 
+#undef enable_flag
+#undef disable_flag
+#undef enable_flag_if
+
 static const struct i2c_algorithm smbus_algorithm = {
 	.smbus_xfer     = i801_access,
 	.functionality  = i801_func,

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 5460bf973c9c..592099a1fca5 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -659,7 +659,7 @@ static int pi2c_probe(struct platform_device *pldev)
 	if (!res)
 		return -ENXIO;
 
-	priv->smba = (unsigned long)devm_ioremap_nocache(&pldev->dev,
+	priv->smba = (unsigned long)devm_ioremap(&pldev->dev,
 							 res->start,
 							 resource_size(res));
 	if (!priv->smba)

commit 09ef6fde7d89d08f390e6cf53cf40f9623d61616
Author: Jamal Shareef <jamal.k.shareef@gmail.com>
Date:   Mon Oct 28 13:24:04 2019 -0700

    staging: kpc2000: kpc_i2c: Remove commented code
    
    Remove some commented out code.
    
    Signed-off-by: Jamal Shareef <jamal.k.shareef@gmail.com>
    Link: https://lore.kernel.org/r/c101a2ff94b3d5dcd467407bfa083679f3bbc612.1572293975.git.jamal.k.shareef@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 0412dab68670..5460bf973c9c 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -144,7 +144,6 @@ static int i801_check_pre(struct i2c_device *priv)
 
 	status &= STATUS_FLAGS;
 	if (status) {
-		//dev_dbg(&priv->adapter.dev, "Clearing status flags (%02x)\n", status);
 		outb_p(status, SMBHSTSTS(priv));
 		status = inb_p(SMBHSTSTS(priv)) & STATUS_FLAGS;
 		if (status) {
@@ -526,7 +525,6 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr,
 	}
 
 	if (block) {
-		//ret = 0;
 		dev_dbg(&priv->adapter.dev, "  [acc] block: yes\n");
 		ret = i801_block_transaction(priv, data, read_write, size,
 					     hwpec);
@@ -682,7 +680,6 @@ static int pi2c_probe(struct platform_device *pldev)
 	/* Retry up to 3 times on lost arbitration */
 	priv->adapter.retries = 3;
 
-	//snprintf(priv->adapter.name, sizeof(priv->adapter.name), "Fake SMBus I801 adapter at %04lx", priv->smba);
 	snprintf(priv->adapter.name, sizeof(priv->adapter.name),
 		 "Fake SMBus I801 adapter");
 

commit 9535e71e7b80f6bd7e13f7206ef60203dc496b4c
Author: Jamal Shareef <jamal.k.shareef@gmail.com>
Date:   Mon Oct 28 13:24:03 2019 -0700

    staging: kpc2000: kpc_i2c: Fix lines over 80 chars
    
    Fix lines over 80 characters warnings.
    issue found by checkpatch.
    
    Signed-off-by: Jamal Shareef <jamal.k.shareef@gmail.com>
    Link: https://lore.kernel.org/r/8273ad9efccfb2c37ff1e9a25d5ccb26780567aa.1572293975.git.jamal.k.shareef@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index bc02534d8dc3..0412dab68670 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -99,7 +99,8 @@ struct i2c_device {
 #define SMBHSTSTS_INTR          0x02
 #define SMBHSTSTS_HOST_BUSY     0x01
 
-#define STATUS_FLAGS        (SMBHSTSTS_BYTE_DONE | SMBHSTSTS_FAILED | SMBHSTSTS_BUS_ERR | SMBHSTSTS_DEV_ERR | SMBHSTSTS_INTR)
+#define STATUS_FLAGS	(SMBHSTSTS_BYTE_DONE | SMBHSTSTS_FAILED | \
+			 SMBHSTSTS_BUS_ERR | SMBHSTSTS_DEV_ERR | SMBHSTSTS_INTR)
 
 /* Older devices have their ID defined in <linux/pci_ids.h> */
 #define PCI_DEVICE_ID_INTEL_COUGARPOINT_SMBUS       0x1c22
@@ -136,7 +137,8 @@ static int i801_check_pre(struct i2c_device *priv)
 
 	status = inb_p(SMBHSTSTS(priv));
 	if (status & SMBHSTSTS_HOST_BUSY) {
-		dev_err(&priv->adapter.dev, "SMBus is busy, can't use it! (status=%x)\n", status);
+		dev_err(&priv->adapter.dev,
+			"SMBus is busy, can't use it! (status=%x)\n", status);
 		return -EBUSY;
 	}
 
@@ -146,7 +148,8 @@ static int i801_check_pre(struct i2c_device *priv)
 		outb_p(status, SMBHSTSTS(priv));
 		status = inb_p(SMBHSTSTS(priv)) & STATUS_FLAGS;
 		if (status) {
-			dev_err(&priv->adapter.dev, "Failed clearing status flags (%02x)\n", status);
+			dev_err(&priv->adapter.dev,
+				"Failed clearing status flags (%02x)\n", status);
 			return -EBUSY;
 		}
 	}
@@ -162,15 +165,20 @@ static int i801_check_post(struct i2c_device *priv, int status, int timeout)
 	if (timeout) {
 		dev_err(&priv->adapter.dev, "Transaction timeout\n");
 		/* try to stop the current command */
-		dev_dbg(&priv->adapter.dev, "Terminating the current operation\n");
-		outb_p(inb_p(SMBHSTCNT(priv)) | SMBHSTCNT_KILL, SMBHSTCNT(priv));
+		dev_dbg(&priv->adapter.dev,
+			"Terminating the current operation\n");
+		outb_p(inb_p(SMBHSTCNT(priv)) | SMBHSTCNT_KILL,
+		       SMBHSTCNT(priv));
 		usleep_range(1000, 2000);
-		outb_p(inb_p(SMBHSTCNT(priv)) & (~SMBHSTCNT_KILL), SMBHSTCNT(priv));
+		outb_p(inb_p(SMBHSTCNT(priv)) & (~SMBHSTCNT_KILL),
+		       SMBHSTCNT(priv));
 
 		/* Check if it worked */
 		status = inb_p(SMBHSTSTS(priv));
-		if ((status & SMBHSTSTS_HOST_BUSY) || !(status & SMBHSTSTS_FAILED))
-			dev_err(&priv->adapter.dev, "Failed terminating the transaction\n");
+		if ((status & SMBHSTSTS_HOST_BUSY) ||
+		    !(status & SMBHSTSTS_FAILED))
+			dev_err(&priv->adapter.dev,
+				"Failed terminating the transaction\n");
 		outb_p(STATUS_FLAGS, SMBHSTSTS(priv));
 		return -ETIMEDOUT;
 	}
@@ -244,7 +252,9 @@ static void i801_wait_hwpec(struct i2c_device *priv)
 	outb_p(status, SMBHSTSTS(priv));
 }
 
-static int i801_block_transaction_by_block(struct i2c_device *priv, union i2c_smbus_data *data, char read_write, int hwpec)
+static int i801_block_transaction_by_block(struct i2c_device *priv,
+					   union i2c_smbus_data *data,
+					   char read_write, int hwpec)
 {
 	int i, len;
 	int status;
@@ -259,7 +269,8 @@ static int i801_block_transaction_by_block(struct i2c_device *priv, union i2c_sm
 			outb_p(data->block[i + 1], SMBBLKDAT(priv));
 	}
 
-	status = i801_transaction(priv, I801_BLOCK_DATA | ENABLE_INT9 | I801_PEC_EN * hwpec);
+	status = i801_transaction(priv,
+			I801_BLOCK_DATA | ENABLE_INT9 | I801_PEC_EN * hwpec);
 	if (status)
 		return status;
 
@@ -275,7 +286,10 @@ static int i801_block_transaction_by_block(struct i2c_device *priv, union i2c_sm
 	return 0;
 }
 
-static int i801_block_transaction_byte_by_byte(struct i2c_device *priv, union i2c_smbus_data *data, char read_write, int command, int hwpec)
+static int i801_block_transaction_byte_by_byte(struct i2c_device *priv,
+					       union i2c_smbus_data *data,
+					       char read_write, int command,
+					       int hwpec)
 {
 	int i, len;
 	int smbcmd;
@@ -301,7 +315,8 @@ static int i801_block_transaction_byte_by_byte(struct i2c_device *priv, union i2
 			else
 				smbcmd = I801_BLOCK_LAST;
 		} else {
-			if (command == I2C_SMBUS_I2C_BLOCK_DATA && read_write == I2C_SMBUS_READ)
+			if (command == I2C_SMBUS_I2C_BLOCK_DATA &&
+			    read_write == I2C_SMBUS_READ)
 				smbcmd = I801_I2C_BLOCK_DATA;
 			else
 				smbcmd = I801_BLOCK_DATA;
@@ -309,25 +324,33 @@ static int i801_block_transaction_byte_by_byte(struct i2c_device *priv, union i2
 		outb_p(smbcmd | ENABLE_INT9, SMBHSTCNT(priv));
 
 		if (i == 1)
-			outb_p(inb(SMBHSTCNT(priv)) | I801_START, SMBHSTCNT(priv));
+			outb_p(inb(SMBHSTCNT(priv)) | I801_START,
+			       SMBHSTCNT(priv));
 		/* We will always wait for a fraction of a second! */
 		timeout = 0;
 		do {
 			usleep_range(250, 500);
 			status = inb_p(SMBHSTSTS(priv));
-		} while ((!(status & SMBHSTSTS_BYTE_DONE)) && (timeout++ < MAX_RETRIES));
+		} while (!(status & SMBHSTSTS_BYTE_DONE) &&
+			 (timeout++ < MAX_RETRIES));
 
 		result = i801_check_post(priv, status, timeout > MAX_RETRIES);
 		if (result < 0)
 			return result;
-		if (i == 1 && read_write == I2C_SMBUS_READ && command != I2C_SMBUS_I2C_BLOCK_DATA) {
+		if (i == 1 && read_write == I2C_SMBUS_READ &&
+		    command != I2C_SMBUS_I2C_BLOCK_DATA) {
 			len = inb_p(SMBHSTDAT0(priv));
 			if (len < 1 || len > I2C_SMBUS_BLOCK_MAX) {
-				dev_err(&priv->adapter.dev, "Illegal SMBus block read size %d\n", len);
+				dev_err(&priv->adapter.dev,
+					"Illegal SMBus block read size %d\n",
+					len);
 				/* Recover */
-				while (inb_p(SMBHSTSTS(priv)) & SMBHSTSTS_HOST_BUSY)
-					outb_p(SMBHSTSTS_BYTE_DONE, SMBHSTSTS(priv));
-				outb_p(SMBHSTSTS_INTR, SMBHSTSTS(priv));
+				while (inb_p(SMBHSTSTS(priv)) &
+						SMBHSTSTS_HOST_BUSY)
+					outb_p(SMBHSTSTS_BYTE_DONE,
+					       SMBHSTSTS(priv));
+				outb_p(SMBHSTSTS_INTR,
+				       SMBHSTSTS(priv));
 				return -EPROTO;
 			}
 			data->block[0] = len;
@@ -354,7 +377,9 @@ static int i801_set_block_buffer_mode(struct i2c_device *priv)
 }
 
 /* Block transaction function */
-static int i801_block_transaction(struct i2c_device *priv, union i2c_smbus_data *data, char read_write, int command, int hwpec)
+static int i801_block_transaction(struct i2c_device *priv,
+				  union i2c_smbus_data *data, char read_write,
+				  int command, int hwpec)
 {
 	int result = 0;
 	//unsigned char hostc;
@@ -366,12 +391,14 @@ static int i801_block_transaction(struct i2c_device *priv, union i2c_smbus_data
 			//pci_read_config_byte(priv->pci_dev, SMBHSTCFG, &hostc);
 			//pci_write_config_byte(priv->pci_dev, SMBHSTCFG, hostc | SMBHSTCFG_I2C_EN);
 		} else if (!(priv->features & FEATURE_I2C_BLOCK_READ)) {
-			dev_err(&priv->adapter.dev, "I2C block read is unsupported!\n");
+			dev_err(&priv->adapter.dev,
+				"I2C block read is unsupported!\n");
 			return -EOPNOTSUPP;
 		}
 	}
 
-	if (read_write == I2C_SMBUS_WRITE || command == I2C_SMBUS_I2C_BLOCK_DATA) {
+	if (read_write == I2C_SMBUS_WRITE ||
+	    command == I2C_SMBUS_I2C_BLOCK_DATA) {
 		if (data->block[0] < 1)
 			data->block[0] = 1;
 		if (data->block[0] > I2C_SMBUS_BLOCK_MAX)
@@ -384,13 +411,21 @@ static int i801_block_transaction(struct i2c_device *priv, union i2c_smbus_data
 	 * SMBus (not I2C) block transactions, even though the datasheet
 	 * doesn't mention this limitation.
 	 */
-	if ((priv->features & FEATURE_BLOCK_BUFFER) && command != I2C_SMBUS_I2C_BLOCK_DATA && i801_set_block_buffer_mode(priv) == 0)
-		result = i801_block_transaction_by_block(priv, data, read_write, hwpec);
-	else
-		result = i801_block_transaction_byte_by_byte(priv, data, read_write, command, hwpec);
+	if ((priv->features & FEATURE_BLOCK_BUFFER) &&
+	    command != I2C_SMBUS_I2C_BLOCK_DATA &&
+	    i801_set_block_buffer_mode(priv) == 0) {
+		result = i801_block_transaction_by_block(priv, data,
+							 read_write, hwpec);
+	} else {
+		result = i801_block_transaction_byte_by_byte(priv, data,
+							     read_write,
+							     command, hwpec);
+	}
+
 	if (result == 0 && hwpec)
 		i801_wait_hwpec(priv);
-	if (command == I2C_SMBUS_I2C_BLOCK_DATA && read_write == I2C_SMBUS_WRITE) {
+	if (command == I2C_SMBUS_I2C_BLOCK_DATA &&
+	    read_write == I2C_SMBUS_WRITE) {
 		/* restore saved configuration register value */
 		//TODO: Figure out the right thing to do here...
 		//pci_write_config_byte(priv->pci_dev, SMBHSTCFG, hostc);
@@ -399,32 +434,41 @@ static int i801_block_transaction(struct i2c_device *priv, union i2c_smbus_data
 }
 
 /* Return negative errno on error. */
-static s32 i801_access(struct i2c_adapter *adap, u16 addr, unsigned short flags, char read_write, u8 command, int size, union i2c_smbus_data *data)
+static s32 i801_access(struct i2c_adapter *adap, u16 addr,
+		       unsigned short flags, char read_write, u8 command,
+		       int size, union i2c_smbus_data *data)
 {
 	int hwpec;
 	int block = 0;
 	int ret, xact = 0;
 	struct i2c_device *priv = i2c_get_adapdata(adap);
 
-	hwpec = (priv->features & FEATURE_SMBUS_PEC) && (flags & I2C_CLIENT_PEC) && size != I2C_SMBUS_QUICK && size != I2C_SMBUS_I2C_BLOCK_DATA;
+	hwpec = (priv->features & FEATURE_SMBUS_PEC) &&
+		(flags & I2C_CLIENT_PEC) &&
+		size != I2C_SMBUS_QUICK && size != I2C_SMBUS_I2C_BLOCK_DATA;
 
 	switch (size) {
 	case I2C_SMBUS_QUICK:
 		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_QUICK\n");
-		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01), SMBHSTADD(priv));
+		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01),
+		       SMBHSTADD(priv));
+
 		xact = I801_QUICK;
 		break;
 	case I2C_SMBUS_BYTE:
 		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_BYTE\n");
 
-		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01), SMBHSTADD(priv));
+		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01),
+		       SMBHSTADD(priv));
 		if (read_write == I2C_SMBUS_WRITE)
 			outb_p(command, SMBHSTCMD(priv));
 		xact = I801_BYTE;
 		break;
 	case I2C_SMBUS_BYTE_DATA:
 		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_BYTE_DATA\n");
-		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01), SMBHSTADD(priv));
+		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01),
+		       SMBHSTADD(priv));
+
 		outb_p(command, SMBHSTCMD(priv));
 		if (read_write == I2C_SMBUS_WRITE)
 			outb_p(data->byte, SMBHSTDAT0(priv));
@@ -432,7 +476,9 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr, unsigned short flags,
 		break;
 	case I2C_SMBUS_WORD_DATA:
 		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_WORD_DATA\n");
-		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01), SMBHSTADD(priv));
+		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01),
+		       SMBHSTADD(priv));
+
 		outb_p(command, SMBHSTCMD(priv));
 		if (read_write == I2C_SMBUS_WRITE) {
 			outb_p(data->word & 0xff, SMBHSTDAT0(priv));
@@ -442,7 +488,9 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr, unsigned short flags,
 		break;
 	case I2C_SMBUS_BLOCK_DATA:
 		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_BLOCK_DATA\n");
-		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01), SMBHSTADD(priv));
+		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01),
+		       SMBHSTADD(priv));
+
 		outb_p(command, SMBHSTCMD(priv));
 		block = 1;
 		break;
@@ -463,7 +511,8 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr, unsigned short flags,
 		block = 1;
 		break;
 	default:
-		dev_dbg(&priv->adapter.dev, "  [acc] Unsupported transaction %d\n", size);
+		dev_dbg(&priv->adapter.dev,
+			"  [acc] Unsupported transaction %d\n", size);
 		return -EOPNOTSUPP;
 	}
 
@@ -472,13 +521,15 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr, unsigned short flags,
 		outb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_CRC, SMBAUXCTL(priv));
 	} else {
 		dev_dbg(&priv->adapter.dev, "  [acc] hwpec: no\n");
-		outb_p(inb_p(SMBAUXCTL(priv)) & (~SMBAUXCTL_CRC), SMBAUXCTL(priv));
+		outb_p(inb_p(SMBAUXCTL(priv)) &
+				(~SMBAUXCTL_CRC), SMBAUXCTL(priv));
 	}
 
 	if (block) {
 		//ret = 0;
 		dev_dbg(&priv->adapter.dev, "  [acc] block: yes\n");
-		ret = i801_block_transaction(priv, data, read_write, size, hwpec);
+		ret = i801_block_transaction(priv, data, read_write, size,
+					     hwpec);
 	} else {
 		dev_dbg(&priv->adapter.dev, "  [acc] block: no\n");
 		ret = i801_transaction(priv, xact | ENABLE_INT9);
@@ -490,7 +541,8 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr, unsigned short flags,
 	 */
 	if (hwpec || block) {
 		dev_dbg(&priv->adapter.dev, "  [acc] hwpec || block\n");
-		outb_p(inb_p(SMBAUXCTL(priv)) & ~(SMBAUXCTL_CRC | SMBAUXCTL_E32B), SMBAUXCTL(priv));
+		outb_p(inb_p(SMBAUXCTL(priv)) & ~(SMBAUXCTL_CRC |
+					SMBAUXCTL_E32B), SMBAUXCTL(priv));
 	}
 	if (block) {
 		dev_dbg(&priv->adapter.dev, "  [acc] block\n");
@@ -501,19 +553,22 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr, unsigned short flags,
 		return ret;
 	}
 	if ((read_write == I2C_SMBUS_WRITE) || (xact == I801_QUICK)) {
-		dev_dbg(&priv->adapter.dev, "  [acc] I2C_SMBUS_WRITE || I801_QUICK  -> ret 0\n");
+		dev_dbg(&priv->adapter.dev,
+			"  [acc] I2C_SMBUS_WRITE || I801_QUICK  -> ret 0\n");
 		return 0;
 	}
 
 	switch (xact & 0x7f) {
 	case I801_BYTE:  /* Result put in SMBHSTDAT0 */
 	case I801_BYTE_DATA:
-		dev_dbg(&priv->adapter.dev, "  [acc] I801_BYTE or I801_BYTE_DATA\n");
+		dev_dbg(&priv->adapter.dev,
+			"  [acc] I801_BYTE or I801_BYTE_DATA\n");
 		data->byte = inb_p(SMBHSTDAT0(priv));
 		break;
 	case I801_WORD_DATA:
 		dev_dbg(&priv->adapter.dev, "  [acc] I801_WORD_DATA\n");
-		data->word = inb_p(SMBHSTDAT0(priv)) + (inb_p(SMBHSTDAT1(priv)) << 8);
+		data->word = inb_p(SMBHSTDAT0(priv)) +
+			     (inb_p(SMBHSTDAT1(priv)) << 8);
 		break;
 	}
 	return 0;
@@ -535,30 +590,47 @@ static u32 i801_func(struct i2c_adapter *adapter)
 	// http://lxr.free-electrons.com/source/include/uapi/linux/i2c.h#L85
 
 	u32 f =
-		I2C_FUNC_I2C                     | /* 0x00000001 (I enabled this one) */
-		!I2C_FUNC_10BIT_ADDR             | /* 0x00000002 */
-		!I2C_FUNC_PROTOCOL_MANGLING      | /* 0x00000004 */
-		((priv->features & FEATURE_SMBUS_PEC) ? I2C_FUNC_SMBUS_PEC : 0) | /* 0x00000008 */
-		!I2C_FUNC_SMBUS_BLOCK_PROC_CALL  | /* 0x00008000 */
-		I2C_FUNC_SMBUS_QUICK             | /* 0x00010000 */
-		!I2C_FUNC_SMBUS_READ_BYTE        | /* 0x00020000 */
-		!I2C_FUNC_SMBUS_WRITE_BYTE       | /* 0x00040000 */
-		!I2C_FUNC_SMBUS_READ_BYTE_DATA   | /* 0x00080000 */
-		!I2C_FUNC_SMBUS_WRITE_BYTE_DATA  | /* 0x00100000 */
-		!I2C_FUNC_SMBUS_READ_WORD_DATA   | /* 0x00200000 */
-		!I2C_FUNC_SMBUS_WRITE_WORD_DATA  | /* 0x00400000 */
-		!I2C_FUNC_SMBUS_PROC_CALL        | /* 0x00800000 */
-		!I2C_FUNC_SMBUS_READ_BLOCK_DATA  | /* 0x01000000 */
-		!I2C_FUNC_SMBUS_WRITE_BLOCK_DATA | /* 0x02000000 */
-		((priv->features & FEATURE_I2C_BLOCK_READ) ? I2C_FUNC_SMBUS_READ_I2C_BLOCK : 0) | /* 0x04000000 */
-		I2C_FUNC_SMBUS_WRITE_I2C_BLOCK   | /* 0x08000000 */
+		I2C_FUNC_I2C                     | /* 0x00000001(I enabled this
+						    * one)
+						    */
+		!I2C_FUNC_10BIT_ADDR             |		/* 0x00000002 */
+		!I2C_FUNC_PROTOCOL_MANGLING      |		/* 0x00000004 */
+		((priv->features & FEATURE_SMBUS_PEC) ?
+			I2C_FUNC_SMBUS_PEC : 0)  |		/* 0x00000008 */
+		!I2C_FUNC_SMBUS_BLOCK_PROC_CALL  |		/* 0x00008000 */
+		I2C_FUNC_SMBUS_QUICK             |		/* 0x00010000 */
+		!I2C_FUNC_SMBUS_READ_BYTE	 |		/* 0x00020000 */
+		!I2C_FUNC_SMBUS_WRITE_BYTE       |		/* 0x00040000 */
+		!I2C_FUNC_SMBUS_READ_BYTE_DATA   |		/* 0x00080000 */
+		!I2C_FUNC_SMBUS_WRITE_BYTE_DATA  |		/* 0x00100000 */
+		!I2C_FUNC_SMBUS_READ_WORD_DATA   |		/* 0x00200000 */
+		!I2C_FUNC_SMBUS_WRITE_WORD_DATA  |		/* 0x00400000 */
+		!I2C_FUNC_SMBUS_PROC_CALL        |		/* 0x00800000 */
+		!I2C_FUNC_SMBUS_READ_BLOCK_DATA  |		/* 0x01000000 */
+		!I2C_FUNC_SMBUS_WRITE_BLOCK_DATA |		/* 0x02000000 */
+		((priv->features & FEATURE_I2C_BLOCK_READ) ?
+			I2C_FUNC_SMBUS_READ_I2C_BLOCK : 0) |	/* 0x04000000 */
+		I2C_FUNC_SMBUS_WRITE_I2C_BLOCK   |		/* 0x08000000 */
 
 		I2C_FUNC_SMBUS_BYTE              | /* _READ_BYTE  _WRITE_BYTE */
-		I2C_FUNC_SMBUS_BYTE_DATA         | /* _READ_BYTE_DATA  _WRITE_BYTE_DATA */
-		I2C_FUNC_SMBUS_WORD_DATA         | /* _READ_WORD_DATA  _WRITE_WORD_DATA */
-		I2C_FUNC_SMBUS_BLOCK_DATA        | /* _READ_BLOCK_DATA  _WRITE_BLOCK_DATA */
-		!I2C_FUNC_SMBUS_I2C_BLOCK        | /* _READ_I2C_BLOCK  _WRITE_I2C_BLOCK */
-		!I2C_FUNC_SMBUS_EMUL;              /* _QUICK  _BYTE  _BYTE_DATA  _WORD_DATA  _PROC_CALL  _WRITE_BLOCK_DATA  _I2C_BLOCK _PEC */
+		I2C_FUNC_SMBUS_BYTE_DATA         | /* _READ_BYTE_DATA
+						    * _WRITE_BYTE_DATA
+						    */
+		I2C_FUNC_SMBUS_WORD_DATA         | /* _READ_WORD_DATA
+						    * _WRITE_WORD_DATA
+						    */
+		I2C_FUNC_SMBUS_BLOCK_DATA        | /* _READ_BLOCK_DATA
+						    * _WRITE_BLOCK_DATA
+						    */
+		!I2C_FUNC_SMBUS_I2C_BLOCK        | /* _READ_I2C_BLOCK
+						    * _WRITE_I2C_BLOCK
+						    */
+		!I2C_FUNC_SMBUS_EMUL;              /* _QUICK  _BYTE
+						    * _BYTE_DATA  _WORD_DATA
+						    * _PROC_CALL
+						    * _WRITE_BLOCK_DATA
+						    * _I2C_BLOCK _PEC
+						    */
 	return f;
 }
 
@@ -611,7 +683,8 @@ static int pi2c_probe(struct platform_device *pldev)
 	priv->adapter.retries = 3;
 
 	//snprintf(priv->adapter.name, sizeof(priv->adapter.name), "Fake SMBus I801 adapter at %04lx", priv->smba);
-	snprintf(priv->adapter.name, sizeof(priv->adapter.name), "Fake SMBus I801 adapter");
+	snprintf(priv->adapter.name, sizeof(priv->adapter.name),
+		 "Fake SMBus I801 adapter");
 
 	err = i2c_add_adapter(&priv->adapter);
 	if (err) {

commit 1327d35ac3c187b3c1ae650d90400f8fe5e41b94
Author: Eduardo Barretto <edusbarretto@gmail.com>
Date:   Sun Aug 18 15:35:55 2019 -0300

    staging: kpc2000: kpc2000_i2c: Fix different address spaces warnings
    
    This patch fixes the following sparse warnings:
    
    kpc2000_i2c.c:137: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:137:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:137:    got void *
    kpc2000_i2c.c:146: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:146:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:146:    got void *
    kpc2000_i2c.c:147: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:147:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:147:    got void *
    kpc2000_i2c.c:166: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:166:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:166:    got void *
    kpc2000_i2c.c:166: warning: incorrect type in argument 2
                                      (different address spaces)
    kpc2000_i2c.c:166:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:166:    got void *
    kpc2000_i2c.c:168: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:168:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:168:    got void *
    kpc2000_i2c.c:168: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:168:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:168:    got void *
    kpc2000_i2c.c:171: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:171:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:171:    got void *
    kpc2000_i2c.c:174: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:174:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:174:    got void *
    kpc2000_i2c.c:193: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:193:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:193:    got void *
    kpc2000_i2c.c:194: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:194:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:194:    got void *
    kpc2000_i2c.c:214: warning: incorrect type in argument 2
                                      (different address spaces)
    kpc2000_i2c.c:214:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:214:    got void *
    kpc2000_i2c.c:219: warning: incorrect type in argument 1
                                      (different address spaces)
    kpc2000_i2c.c:219:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:219:    got void *
    kpc2000_i2c.c:226: warning: incorrect type in argument 2
                                      (different address spaces)
    kpc2000_i2c.c:226:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:226:    got void *
    kpc2000_i2c.c:238: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:238:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:238:    got void *
    kpc2000_i2c.c:244: warning: incorrect type in argument 2
                                      (different address spaces)
    kpc2000_i2c.c:244:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:244:    got void *
    kpc2000_i2c.c:252: warning: incorrect type in argument 1
                                      (different address spaces)
    kpc2000_i2c.c:252:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:252:    got void *
    kpc2000_i2c.c:257: warning: incorrect type in argument 2
                                      (different address spaces)
    kpc2000_i2c.c:257:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:257:    got void *
    kpc2000_i2c.c:259: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:259:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:259:    got void *
    kpc2000_i2c.c:267: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:267:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:267:    got void *
    kpc2000_i2c.c:273: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:273:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:273:    got void *
    kpc2000_i2c.c:293: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:293:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:293:    got void *
    kpc2000_i2c.c:294: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:294:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:294:    got void *
    kpc2000_i2c.c:309: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:309:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:309:    got void *
    kpc2000_i2c.c:312: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:312:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:312:    got void *
    kpc2000_i2c.c:317: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:317:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:317:    got void *
    kpc2000_i2c.c:324: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:324:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:324:    got void *
    kpc2000_i2c.c:328: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:328:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:328:    got void *
    kpc2000_i2c.c:329: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:329:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:329:    got void *
    kpc2000_i2c.c:330: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:330:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:330:    got void *
    kpc2000_i2c.c:338: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:338:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:338:    got void *
    kpc2000_i2c.c:340: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:340:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:340:    got void *
    kpc2000_i2c.c:342: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:342:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:342:    got void *
    kpc2000_i2c.c:350: warning: incorrect type in argument 1
                                      (different address spaces)
    kpc2000_i2c.c:350:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:350:    got void *
    kpc2000_i2c.c:350: warning: incorrect type in argument 2
                                      (different address spaces)
    kpc2000_i2c.c:350:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:350:    got void *
    kpc2000_i2c.c:351: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:351:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:351:    got void *
    kpc2000_i2c.c:414: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:414:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:414:    got void *
    kpc2000_i2c.c:420: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:420:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:420:    got void *
    kpc2000_i2c.c:422: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:422:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:422:    got void *
    kpc2000_i2c.c:427: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:427:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:427:    got void *
    kpc2000_i2c.c:428: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:428:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:428:    got void *
    kpc2000_i2c.c:430: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:430:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:430:    got void *
    kpc2000_i2c.c:435: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:435:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:435:    got void *
    kpc2000_i2c.c:436: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:436:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:436:    got void *
    kpc2000_i2c.c:438: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:438:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:438:    got void *
    kpc2000_i2c.c:439: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:439:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:439:    got void *
    kpc2000_i2c.c:445: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:445:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:445:    got void *
    kpc2000_i2c.c:446: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:446:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:446:    got void *
    kpc2000_i2c.c:454: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:454:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:454:    got void *
    kpc2000_i2c.c:459: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:459:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:459:    got void *
    kpc2000_i2c.c:461: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:461:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:461:    got void *
    kpc2000_i2c.c:472: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:472:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:472:    got void *
    kpc2000_i2c.c:472: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:472:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:472:    got void *
    kpc2000_i2c.c:475: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:475:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:475:    got void *
    kpc2000_i2c.c:475: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:475:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:475:    got void *
    kpc2000_i2c.c:493: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:493:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:493:    got void *
    kpc2000_i2c.c:493: warning: incorrect type in argument 2
                                       (different address spaces)
    kpc2000_i2c.c:493:    expected void volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:493:    got void *
    kpc2000_i2c.c:512: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:512:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:512:    got void *
    kpc2000_i2c.c:516: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:516:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:516:    got void *
    kpc2000_i2c.c:516: warning: incorrect type in argument 1
                                       (different address spaces)
    kpc2000_i2c.c:516:    expected void const volatile [noderef] <asn:2> *addr
    kpc2000_i2c.c:516:    got void *
    
    Signed-off-by: Eduardo Barretto <edusbarretto@gmail.com>
    Link: https://lore.kernel.org/r/20190818183555.7167-1-edusbarretto@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index b108da4ac633..bc02534d8dc3 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -123,9 +123,9 @@ struct i2c_device {
 
 // FIXME!
 #undef inb_p
-#define inb_p(a) readq((void *)a)
+#define inb_p(a) readq((void __iomem *)a)
 #undef outb_p
-#define outb_p(d, a) writeq(d, (void *)a)
+#define outb_p(d, a) writeq(d, (void __iomem *)a)
 
 /* Make sure the SMBus host is ready to start transmitting.
  * Return 0 if it is, -EBUSY if it is not.

commit 268d828144d214d085b07f1bdde74aed41052f13
Author: Jean Delvare <jdelvare@suse.de>
Date:   Mon Jul 1 17:06:38 2019 +0200

    staging: kpc2000: drop useless softdep statement
    
    The i2c-dev module is for access to I2C buses from user-space.
    Kernel drivers do not care about its presence.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Cc: Matt Sickler <Matt.Sickler@daktronics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 3e08df9f205d..b108da4ac633 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -31,7 +31,6 @@
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Matt.Sickler@Daktronics.com");
-MODULE_SOFTDEP("pre: i2c-dev");
 
 struct i2c_device {
 	unsigned long           smba;

commit 03c1feff9e02ee84edd5b7e1cb26fede41a751c6
Author: Simon Sandström <simon@nikanor.nu>
Date:   Tue Jun 25 10:41:27 2019 +0200

    staging: kpc2000: add missing spaces in kpc2000_i2c.c
    
    Fixes checkpatch "CHECK: spaces preferred around that '+' (ctx:VxV)".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 69e8773c1ef8..3e08df9f205d 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -257,7 +257,7 @@ static int i801_block_transaction_by_block(struct i2c_device *priv, union i2c_sm
 		len = data->block[0];
 		outb_p(len, SMBHSTDAT0(priv));
 		for (i = 0; i < len; i++)
-			outb_p(data->block[i+1], SMBBLKDAT(priv));
+			outb_p(data->block[i + 1], SMBBLKDAT(priv));
 	}
 
 	status = i801_transaction(priv, I801_BLOCK_DATA | ENABLE_INT9 | I801_PEC_EN * hwpec);
@@ -337,8 +337,8 @@ static int i801_block_transaction_byte_by_byte(struct i2c_device *priv, union i2
 		/* Retrieve/store value in SMBBLKDAT */
 		if (read_write == I2C_SMBUS_READ)
 			data->block[i] = inb_p(SMBBLKDAT(priv));
-		if (read_write == I2C_SMBUS_WRITE && i+1 <= len)
-			outb_p(data->block[i+1], SMBBLKDAT(priv));
+		if (read_write == I2C_SMBUS_WRITE && i + 1 <= len)
+			outb_p(data->block[i + 1], SMBBLKDAT(priv));
 		/* signals SMBBLKDAT ready */
 		outb_p(SMBHSTSTS_BYTE_DONE | SMBHSTSTS_INTR, SMBHSTSTS(priv));
 	}

commit 58462a443563138907c7595200e1afc59aa90b99
Author: Hao Xu <haoxu.linuxkernel@gmail.com>
Date:   Sat Jun 8 15:27:47 2019 +0800

    staging: kpc2000: kpc2000_i2c: add space after ,
    
    add space after , for #define outb_p(d,a) writeq(d,(void *)a)
    
    Signed-off-by: Hao Xu <haoxu.linuxkernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index de3a0c8215cb..69e8773c1ef8 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -126,7 +126,7 @@ struct i2c_device {
 #undef inb_p
 #define inb_p(a) readq((void *)a)
 #undef outb_p
-#define outb_p(d,a) writeq(d,(void *)a)
+#define outb_p(d, a) writeq(d, (void *)a)
 
 /* Make sure the SMBus host is ready to start transmitting.
  * Return 0 if it is, -EBUSY if it is not.

commit 546cbac4ab54e12397252d10f4179b2528c09417
Author: Hao Xu <haoxu.linuxkernel@gmail.com>
Date:   Sat Jun 8 15:27:46 2019 +0800

    staging: kpc2000: kpc2000_i2c: void* -> void *
    
    modify void* to void * for #define inb_p(a) readq((void*)a)
    and #define outb_p(d,a) writeq(d,(void*)a)
    
    Signed-off-by: Hao Xu <haoxu.linuxkernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index a434dd0b78c4..de3a0c8215cb 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -124,9 +124,9 @@ struct i2c_device {
 
 // FIXME!
 #undef inb_p
-#define inb_p(a) readq((void*)a)
+#define inb_p(a) readq((void *)a)
 #undef outb_p
-#define outb_p(d,a) writeq(d,(void*)a)
+#define outb_p(d,a) writeq(d,(void *)a)
 
 /* Make sure the SMBus host is ready to start transmitting.
  * Return 0 if it is, -EBUSY if it is not.

commit 299672a74856fd840a3b3f207064480d5e4dc91d
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun May 26 01:18:34 2019 +0000

    staging: kpc2000: kpc_i2c: Use devm_* API to manage mapped I/O space
    
    The kpc_i2c driver does not unmap its I/O space upon error cases in the
    probe() function or upon remove(). Make the driver clean up after itself
    more maintainably by using the managed resource API.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 51e91653e183..a434dd0b78c4 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -590,7 +590,9 @@ static int pi2c_probe(struct platform_device *pldev)
 	if (!res)
 		return -ENXIO;
 
-	priv->smba = (unsigned long)ioremap_nocache(res->start, resource_size(res));
+	priv->smba = (unsigned long)devm_ioremap_nocache(&pldev->dev,
+							 res->start,
+							 resource_size(res));
 	if (!priv->smba)
 		return -ENOMEM;
 

commit e621c8a108ede08e6ff66524b4a4f756f66e5eeb
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun May 26 01:18:33 2019 +0000

    staging: kpc2000: kpc_i2c: fail probe if unable to map I/O space
    
    The kpc2000 driver does not verify whether or not mapping the I/O
    space succeeded during probe time. Make the driver verify that the
    mapping operation was successful before potentially using that area
    in the future.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 452052bf9476..51e91653e183 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -591,6 +591,8 @@ static int pi2c_probe(struct platform_device *pldev)
 		return -ENXIO;
 
 	priv->smba = (unsigned long)ioremap_nocache(res->start, resource_size(res));
+	if (!priv->smba)
+		return -ENOMEM;
 
 	platform_set_drvdata(pldev, priv);
 

commit 4ff740315aee92ec19add0193cef976e532e34dc
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun May 26 01:18:32 2019 +0000

    staging: kpc2000: kpc_i2c: fail probe if unable to get I/O resource
    
    The kpc_i2c driver attempts to map its I/O space without verifying
    whether or not the result of platform_get_resource() is NULL. Make the
    driver check that platform_get_resource did not return NULL before
    attempting to use the value returned to map an I/O space.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index e4bbb91af972..452052bf9476 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -587,6 +587,9 @@ static int pi2c_probe(struct platform_device *pldev)
 	priv->adapter.algo = &smbus_algorithm;
 
 	res = platform_get_resource(pldev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
 	priv->smba = (unsigned long)ioremap_nocache(res->start, resource_size(res));
 
 	platform_set_drvdata(pldev, priv);

commit 091971897e84b518cc8902af1c70632930b1d2da
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun May 26 01:18:31 2019 +0000

    staging: kpc2000: kpc_i2c: Use drvdata instead of platform_data
    
    The kpc_i2c driver stashes private state data in the platform_data
    member of its device structure. In general, the platform_data structure
    is used for passing data to the driver during probe() rather than as a
    storage area for runtime state data. Instead, use the drvdata member
    for all state info meant to be accessible in driver callbacks.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 1767f351a116..e4bbb91af972 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -589,7 +589,7 @@ static int pi2c_probe(struct platform_device *pldev)
 	res = platform_get_resource(pldev, IORESOURCE_MEM, 0);
 	priv->smba = (unsigned long)ioremap_nocache(res->start, resource_size(res));
 
-	pldev->dev.platform_data = priv;
+	platform_set_drvdata(pldev, priv);
 
 	priv->features |= FEATURE_IDF;
 	priv->features |= FEATURE_I2C_BLOCK_READ;
@@ -620,7 +620,7 @@ static int pi2c_remove(struct platform_device *pldev)
 {
 	struct i2c_device *lddev;
 
-	lddev = (struct i2c_device *)pldev->dev.platform_data;
+	lddev = (struct i2c_device *)platform_get_drvdata(pldev);
 
 	i2c_del_adapter(&lddev->adapter);
 

commit 73d56b83910ac7c7afcaa7d7cb3c92c9b53fee1c
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun May 26 01:18:30 2019 +0000

    staging: kpc2000: kpc_i2c: Remove unnecessary consecutive newlines
    
    The kpc2000_i2c.c file contains instances of unnecessary consecutive
    newlines which impact the readability of the file. Remove these
    unnecessary newlines.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 1d100bb7c548..1767f351a116 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -115,7 +115,6 @@ struct i2c_device {
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_SMBUS         0x8c22
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_SMBUS      0x9c22
 
-
 #define FEATURE_SMBUS_PEC       BIT(0)
 #define FEATURE_BLOCK_BUFFER    BIT(1)
 #define FEATURE_BLOCK_PROC      BIT(2)
@@ -521,8 +520,6 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr, unsigned short flags,
 	return 0;
 }
 
-
-
 static u32 i801_func(struct i2c_adapter *adapter)
 {
 	struct i2c_device *priv = i2c_get_adapdata(adapter);
@@ -571,8 +568,6 @@ static const struct i2c_algorithm smbus_algorithm = {
 	.functionality  = i801_func,
 };
 
-
-
 /********************************
  *** Part 2 - Driver Handlers ***
  ********************************/

commit c5164e568cd75b70382103b108b5bc0d74e0617c
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun May 26 01:18:29 2019 +0000

    staging: kpc2000: kpc_i2c: Use BIT macro rather than manual bit shifting
    
    The FEATURES_* symbols use bit shifting of the style (1 << k) in order
    to assign a certain meaning to the value of inividual bits being set
    in the value of a given variable. Instead, use the BIT() macro in
    order to improve readability and maintain consistency with the rest
    of the kernel.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index b2a9cda05f1b..1d100bb7c548 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -116,12 +116,12 @@ struct i2c_device {
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_SMBUS      0x9c22
 
 
-#define FEATURE_SMBUS_PEC       (1 << 0)
-#define FEATURE_BLOCK_BUFFER    (1 << 1)
-#define FEATURE_BLOCK_PROC      (1 << 2)
-#define FEATURE_I2C_BLOCK_READ  (1 << 3)
+#define FEATURE_SMBUS_PEC       BIT(0)
+#define FEATURE_BLOCK_BUFFER    BIT(1)
+#define FEATURE_BLOCK_PROC      BIT(2)
+#define FEATURE_I2C_BLOCK_READ  BIT(3)
 /* Not really a feature, but it's convenient to handle it as such */
-#define FEATURE_IDF             (1 << 15)
+#define FEATURE_IDF             BIT(15)
 
 // FIXME!
 #undef inb_p

commit 935d47e209cc5e7e93bcf789a22ddbe6fc67864d
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun May 26 01:18:28 2019 +0000

    staging: kpc2000: kpc_i2c: Remove pldev from i2c_device structure
    
    The i2c_device structure contains a member used to stash a pointer to
    a platform_device. The driver contains no cases of this member being
    used after initialization. Remove the unnecessary struct member and
    the initialization of this member in the sole instance where the
    driver creates a variable of type: struct i2c_device.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 2c272ad8eca6..b2a9cda05f1b 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -36,7 +36,6 @@ MODULE_SOFTDEP("pre: i2c-dev");
 struct i2c_device {
 	unsigned long           smba;
 	struct i2c_adapter      adapter;
-	struct platform_device *pldev;
 	unsigned int            features;
 };
 
@@ -595,7 +594,6 @@ static int pi2c_probe(struct platform_device *pldev)
 	res = platform_get_resource(pldev, IORESOURCE_MEM, 0);
 	priv->smba = (unsigned long)ioremap_nocache(res->start, resource_size(res));
 
-	priv->pldev = pldev;
 	pldev->dev.platform_data = priv;
 
 	priv->features |= FEATURE_IDF;

commit f82ce45273d4d8173243f08b943c9c371385c105
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun May 26 01:18:27 2019 +0000

    staging: kpc2000: kpc_i2c: Remove unused rw_sem
    
    In pi2c_probe, a rw_sem is initialized and stashed off in the
    i2c_device private runtime state struct. This rw_sem is never used
    after initialization. Remove the rw_sem and cleanup unneeded header
    inclusion.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index fb9a8386bcce..2c272ad8eca6 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -25,7 +25,6 @@
 #include <linux/slab.h>
 #include <linux/platform_device.h>
 #include <linux/fs.h>
-#include <linux/rwsem.h>
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include "kpc.h"
@@ -38,7 +37,6 @@ struct i2c_device {
 	unsigned long           smba;
 	struct i2c_adapter      adapter;
 	struct platform_device *pldev;
-	struct rw_semaphore     rw_sem;
 	unsigned int            features;
 };
 
@@ -606,7 +604,6 @@ static int pi2c_probe(struct platform_device *pldev)
 	priv->features |= FEATURE_BLOCK_BUFFER;
 
 	//init_MUTEX(&lddata->sem);
-	init_rwsem(&priv->rw_sem);
 
 	/* set up the sysfs linkage to our parent device */
 	priv->adapter.dev.parent = &pldev->dev;

commit 99bf7761b7cd9c529486a52df37deecf3bf0ebe5
Author: kbuild test robot <lkp@intel.com>
Date:   Thu May 23 03:58:15 2019 +0800

    staging: kpc2000: kpc_i2c: fix platform_no_drv_owner.cocci warnings
    
    drivers/staging/kpc2000/kpc2000_i2c.c:652:3-8: No need to set .owner here. The core will do it.
    
     Remove .owner field if calls are used which set it automatically
    
    Generated by: scripts/coccinelle/api/platform_no_drv_owner.cocci
    
    Fixes: 43ad38191816 ("staging: kpc2000: kpc_i2c: add static qual to local symbols in kpc_i2c.c")
    CC: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 97e738349ba2..fb9a8386bcce 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -649,7 +649,6 @@ static struct platform_driver i2c_plat_driver_i = {
 	.remove     = pi2c_remove,
 	.driver     = {
 		.name   = KP_DRIVER_NAME_I2C,
-		.owner  = THIS_MODULE,
 	},
 };
 

commit 43ad38191816a6b77cc4bd8222353320a71a1d2d
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Wed May 22 12:14:02 2019 +0000

    staging: kpc2000: kpc_i2c: add static qual to local symbols in kpc_i2c.c
    
    kpc_i2c.c declares:
      - two functions
        - pi2c_probe()
        - pi2c_remove()
      - one struct
        - i2c_plat_driver_i
    which are local to the file, yet missing the static qualifier. Add the
    static qualifier to these symbols.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index f9259c06b605..97e738349ba2 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -579,7 +579,7 @@ static const struct i2c_algorithm smbus_algorithm = {
 /********************************
  *** Part 2 - Driver Handlers ***
  ********************************/
-int pi2c_probe(struct platform_device *pldev)
+static int pi2c_probe(struct platform_device *pldev)
 {
 	int err;
 	struct i2c_device *priv;
@@ -626,7 +626,7 @@ int pi2c_probe(struct platform_device *pldev)
 	return 0;
 }
 
-int pi2c_remove(struct platform_device *pldev)
+static int pi2c_remove(struct platform_device *pldev)
 {
 	struct i2c_device *lddev;
 
@@ -644,7 +644,7 @@ int pi2c_remove(struct platform_device *pldev)
 	return 0;
 }
 
-struct platform_driver i2c_plat_driver_i = {
+static struct platform_driver i2c_plat_driver_i = {
 	.probe      = pi2c_probe,
 	.remove     = pi2c_remove,
 	.driver     = {

commit 7bd49a49b0a7f3bf845869afb126e40788eab832
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Wed May 22 12:14:01 2019 +0000

    staging: kpc2000: kpc_i2c: Remove unnecessary function tracing prints
    
    Many of the functions in kpc_i2c log debug-level messages to the
    kernel log message buffer upon invocation. This is unnecessary, as
    debugging tools like kgdb, kdb, etc. or the tracing tool ftrace
    should be able to provide this same information. Therefore, remove
    these print statements.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 5d98ed54c05c..f9259c06b605 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -139,8 +139,6 @@ static int i801_check_pre(struct i2c_device *priv)
 {
 	int status;
 
-	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
-
 	status = inb_p(SMBHSTSTS(priv));
 	if (status & SMBHSTSTS_HOST_BUSY) {
 		dev_err(&priv->adapter.dev, "SMBus is busy, can't use it! (status=%x)\n", status);
@@ -165,8 +163,6 @@ static int i801_check_post(struct i2c_device *priv, int status, int timeout)
 {
 	int result = 0;
 
-	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
-
 	/* If the SMBus is still busy, we give up */
 	if (timeout) {
 		dev_err(&priv->adapter.dev, "Transaction timeout\n");
@@ -214,8 +210,6 @@ static int i801_transaction(struct i2c_device *priv, int xact)
 	int result;
 	int timeout = 0;
 
-	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
-
 	result = i801_check_pre(priv);
 	if (result < 0)
 		return result;
@@ -244,8 +238,6 @@ static void i801_wait_hwpec(struct i2c_device *priv)
 	int timeout = 0;
 	int status;
 
-	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
-
 	do {
 		usleep_range(250, 500);
 		status = inb_p(SMBHSTSTS(priv));
@@ -262,8 +254,6 @@ static int i801_block_transaction_by_block(struct i2c_device *priv, union i2c_sm
 	int i, len;
 	int status;
 
-	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
-
 	inb_p(SMBHSTCNT(priv)); /* reset the data buffer index */
 
 	/* Use 32-byte buffer to process this transaction */
@@ -298,8 +288,6 @@ static int i801_block_transaction_byte_by_byte(struct i2c_device *priv, union i2
 	int result;
 	int timeout;
 
-	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
-
 	result = i801_check_pre(priv);
 	if (result < 0)
 		return result;
@@ -364,8 +352,6 @@ static int i801_block_transaction_byte_by_byte(struct i2c_device *priv, union i2
 
 static int i801_set_block_buffer_mode(struct i2c_device *priv)
 {
-	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
-
 	outb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_E32B, SMBAUXCTL(priv));
 	if ((inb_p(SMBAUXCTL(priv)) & SMBAUXCTL_E32B) == 0)
 		return -EIO;
@@ -378,8 +364,6 @@ static int i801_block_transaction(struct i2c_device *priv, union i2c_smbus_data
 	int result = 0;
 	//unsigned char hostc;
 
-	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
-
 	if (command == I2C_SMBUS_I2C_BLOCK_DATA) {
 		if (read_write == I2C_SMBUS_WRITE) {
 			/* set I2C_EN bit in configuration register */
@@ -427,10 +411,6 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr, unsigned short flags,
 	int ret, xact = 0;
 	struct i2c_device *priv = i2c_get_adapdata(adap);
 
-	dev_dbg(&priv->adapter.dev,
-		"%s (addr=%0d)  flags=%x  read_write=%x  command=%x  size=%x",
-		__func__, addr, flags, read_write, command, size);
-
 	hwpec = (priv->features & FEATURE_SMBUS_PEC) && (flags & I2C_CLIENT_PEC) && size != I2C_SMBUS_QUICK && size != I2C_SMBUS_I2C_BLOCK_DATA;
 
 	switch (size) {
@@ -605,9 +585,6 @@ int pi2c_probe(struct platform_device *pldev)
 	struct i2c_device *priv;
 	struct resource *res;
 
-	dev_dbg(&pldev->dev, "%s(pldev = %p '%s')\n", __func__, pldev,
-		pldev->name);
-
 	priv = devm_kzalloc(&pldev->dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
@@ -653,9 +630,6 @@ int pi2c_remove(struct platform_device *pldev)
 {
 	struct i2c_device *lddev;
 
-	dev_dbg(&pldev->dev, "%s(pldev = %p '%s')\n", __func__, pldev,
-		pldev->name);
-
 	lddev = (struct i2c_device *)pldev->dev.platform_data;
 
 	i2c_del_adapter(&lddev->adapter);

commit 32806b33fee8200b18702a93d693017c6445b2c9
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Wed May 22 12:14:00 2019 +0000

    staging: kpc2000: kpc_i2c: use <linux/io.h> instead of <asm/io.h>
    
    Rather than include asm/io.h, include linux/io.h. Issue reported
    by the script checkpatch.pl.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index a1ebc2386d70..5d98ed54c05c 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -19,7 +19,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/types.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/io-64-nonatomic-lo-hi.h>
 #include <linux/export.h>
 #include <linux/slab.h>

commit 953bb9e5d060d0848cc83143236a1ce00498aaac
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Wed May 22 12:13:59 2019 +0000

    staging: kpc2000: kpc_i2c: newline fixups to meet linux style guide
    
    The linux coding style document states:
    
      1) That braces should not be used where a single single statement
         will do. Therefore all instances of single block statements
         wrapped in braces that do not meet the qualifications of any
         of the exceptions to the rule should be fixed up.
    
      2) That the declaration of variables local to a given function
         should be immediately followed by a blank newline. Therefore,
         the single instance of this in kpc2000_i2c.c should be fixed
         up.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 40a89998726e..a1ebc2386d70 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -178,9 +178,8 @@ static int i801_check_post(struct i2c_device *priv, int status, int timeout)
 
 		/* Check if it worked */
 		status = inb_p(SMBHSTSTS(priv));
-		if ((status & SMBHSTSTS_HOST_BUSY) || !(status & SMBHSTSTS_FAILED)) {
+		if ((status & SMBHSTSTS_HOST_BUSY) || !(status & SMBHSTSTS_FAILED))
 			dev_err(&priv->adapter.dev, "Failed terminating the transaction\n");
-		}
 		outb_p(STATUS_FLAGS, SMBHSTSTS(priv));
 		return -ETIMEDOUT;
 	}
@@ -202,9 +201,8 @@ static int i801_check_post(struct i2c_device *priv, int status, int timeout)
 		/* Clear error flags */
 		outb_p(status & STATUS_FLAGS, SMBHSTSTS(priv));
 		status = inb_p(SMBHSTSTS(priv)) & STATUS_FLAGS;
-		if (status) {
+		if (status)
 			dev_warn(&priv->adapter.dev, "Failed clearing status flags at end of transaction (%02x)\n", status);
-		}
 	}
 
 	return result;
@@ -219,9 +217,8 @@ static int i801_transaction(struct i2c_device *priv, int xact)
 	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
 
 	result = i801_check_pre(priv);
-	if (result < 0) {
+	if (result < 0)
 		return result;
-	}
 	/* the current contents of SMBHSTCNT can be overwritten, since PEC,
 	 * INTREN, SMBSCMD are passed in xact
 	 */
@@ -234,9 +231,8 @@ static int i801_transaction(struct i2c_device *priv, int xact)
 	} while ((status & SMBHSTSTS_HOST_BUSY) && (timeout++ < MAX_RETRIES));
 
 	result = i801_check_post(priv, status, timeout > MAX_RETRIES);
-	if (result < 0) {
+	if (result < 0)
 		return result;
-	}
 
 	outb_p(SMBHSTSTS_INTR, SMBHSTSTS(priv));
 	return 0;
@@ -255,9 +251,8 @@ static void i801_wait_hwpec(struct i2c_device *priv)
 		status = inb_p(SMBHSTSTS(priv));
 	} while ((!(status & SMBHSTSTS_INTR)) && (timeout++ < MAX_RETRIES));
 
-	if (timeout > MAX_RETRIES) {
+	if (timeout > MAX_RETRIES)
 		dev_dbg(&priv->adapter.dev, "PEC Timeout!\n");
-	}
 
 	outb_p(status, SMBHSTSTS(priv));
 }
@@ -275,26 +270,22 @@ static int i801_block_transaction_by_block(struct i2c_device *priv, union i2c_sm
 	if (read_write == I2C_SMBUS_WRITE) {
 		len = data->block[0];
 		outb_p(len, SMBHSTDAT0(priv));
-		for (i = 0; i < len; i++) {
+		for (i = 0; i < len; i++)
 			outb_p(data->block[i+1], SMBBLKDAT(priv));
-		}
 	}
 
 	status = i801_transaction(priv, I801_BLOCK_DATA | ENABLE_INT9 | I801_PEC_EN * hwpec);
-	if (status) {
+	if (status)
 		return status;
-	}
 
 	if (read_write == I2C_SMBUS_READ) {
 		len = inb_p(SMBHSTDAT0(priv));
-		if (len < 1 || len > I2C_SMBUS_BLOCK_MAX) {
+		if (len < 1 || len > I2C_SMBUS_BLOCK_MAX)
 			return -EPROTO;
-		}
 
 		data->block[0] = len;
-		for (i = 0; i < len; i++) {
+		for (i = 0; i < len; i++)
 			data->block[i + 1] = inb_p(SMBBLKDAT(priv));
-		}
 	}
 	return 0;
 }
@@ -310,9 +301,8 @@ static int i801_block_transaction_byte_by_byte(struct i2c_device *priv, union i2
 	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
 
 	result = i801_check_pre(priv);
-	if (result < 0) {
+	if (result < 0)
 		return result;
-	}
 
 	len = data->block[0];
 
@@ -323,23 +313,20 @@ static int i801_block_transaction_byte_by_byte(struct i2c_device *priv, union i2
 
 	for (i = 1; i <= len; i++) {
 		if (i == len && read_write == I2C_SMBUS_READ) {
-			if (command == I2C_SMBUS_I2C_BLOCK_DATA) {
+			if (command == I2C_SMBUS_I2C_BLOCK_DATA)
 				smbcmd = I801_I2C_BLOCK_LAST;
-			} else {
+			else
 				smbcmd = I801_BLOCK_LAST;
-			}
 		} else {
-			if (command == I2C_SMBUS_I2C_BLOCK_DATA && read_write == I2C_SMBUS_READ) {
+			if (command == I2C_SMBUS_I2C_BLOCK_DATA && read_write == I2C_SMBUS_READ)
 				smbcmd = I801_I2C_BLOCK_DATA;
-			} else {
+			else
 				smbcmd = I801_BLOCK_DATA;
-			}
 		}
 		outb_p(smbcmd | ENABLE_INT9, SMBHSTCNT(priv));
 
-		if (i == 1) {
+		if (i == 1)
 			outb_p(inb(SMBHSTCNT(priv)) | I801_START, SMBHSTCNT(priv));
-		}
 		/* We will always wait for a fraction of a second! */
 		timeout = 0;
 		do {
@@ -348,17 +335,15 @@ static int i801_block_transaction_byte_by_byte(struct i2c_device *priv, union i2
 		} while ((!(status & SMBHSTSTS_BYTE_DONE)) && (timeout++ < MAX_RETRIES));
 
 		result = i801_check_post(priv, status, timeout > MAX_RETRIES);
-		if (result < 0) {
+		if (result < 0)
 			return result;
-		}
 		if (i == 1 && read_write == I2C_SMBUS_READ && command != I2C_SMBUS_I2C_BLOCK_DATA) {
 			len = inb_p(SMBHSTDAT0(priv));
 			if (len < 1 || len > I2C_SMBUS_BLOCK_MAX) {
 				dev_err(&priv->adapter.dev, "Illegal SMBus block read size %d\n", len);
 				/* Recover */
-				while (inb_p(SMBHSTSTS(priv)) & SMBHSTSTS_HOST_BUSY) {
+				while (inb_p(SMBHSTSTS(priv)) & SMBHSTSTS_HOST_BUSY)
 					outb_p(SMBHSTSTS_BYTE_DONE, SMBHSTSTS(priv));
-				}
 				outb_p(SMBHSTSTS_INTR, SMBHSTSTS(priv));
 				return -EPROTO;
 			}
@@ -366,12 +351,10 @@ static int i801_block_transaction_byte_by_byte(struct i2c_device *priv, union i2
 		}
 
 		/* Retrieve/store value in SMBBLKDAT */
-		if (read_write == I2C_SMBUS_READ) {
+		if (read_write == I2C_SMBUS_READ)
 			data->block[i] = inb_p(SMBBLKDAT(priv));
-		}
-		if (read_write == I2C_SMBUS_WRITE && i+1 <= len) {
+		if (read_write == I2C_SMBUS_WRITE && i+1 <= len)
 			outb_p(data->block[i+1], SMBBLKDAT(priv));
-		}
 		/* signals SMBBLKDAT ready */
 		outb_p(SMBHSTSTS_BYTE_DONE | SMBHSTSTS_INTR, SMBHSTSTS(priv));
 	}
@@ -384,9 +367,8 @@ static int i801_set_block_buffer_mode(struct i2c_device *priv)
 	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
 
 	outb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_E32B, SMBAUXCTL(priv));
-	if ((inb_p(SMBAUXCTL(priv)) & SMBAUXCTL_E32B) == 0) {
+	if ((inb_p(SMBAUXCTL(priv)) & SMBAUXCTL_E32B) == 0)
 		return -EIO;
-	}
 	return 0;
 }
 
@@ -411,12 +393,10 @@ static int i801_block_transaction(struct i2c_device *priv, union i2c_smbus_data
 	}
 
 	if (read_write == I2C_SMBUS_WRITE || command == I2C_SMBUS_I2C_BLOCK_DATA) {
-		if (data->block[0] < 1) {
+		if (data->block[0] < 1)
 			data->block[0] = 1;
-		}
-		if (data->block[0] > I2C_SMBUS_BLOCK_MAX) {
+		if (data->block[0] > I2C_SMBUS_BLOCK_MAX)
 			data->block[0] = I2C_SMBUS_BLOCK_MAX;
-		}
 	} else {
 		data->block[0] = 32;	/* max for SMBus block reads */
 	}
@@ -425,14 +405,12 @@ static int i801_block_transaction(struct i2c_device *priv, union i2c_smbus_data
 	 * SMBus (not I2C) block transactions, even though the datasheet
 	 * doesn't mention this limitation.
 	 */
-	if ((priv->features & FEATURE_BLOCK_BUFFER) && command != I2C_SMBUS_I2C_BLOCK_DATA && i801_set_block_buffer_mode(priv) == 0) {
+	if ((priv->features & FEATURE_BLOCK_BUFFER) && command != I2C_SMBUS_I2C_BLOCK_DATA && i801_set_block_buffer_mode(priv) == 0)
 		result = i801_block_transaction_by_block(priv, data, read_write, hwpec);
-	} else {
+	else
 		result = i801_block_transaction_byte_by_byte(priv, data, read_write, command, hwpec);
-	}
-	if (result == 0 && hwpec) {
+	if (result == 0 && hwpec)
 		i801_wait_hwpec(priv);
-	}
 	if (command == I2C_SMBUS_I2C_BLOCK_DATA && read_write == I2C_SMBUS_WRITE) {
 		/* restore saved configuration register value */
 		//TODO: Figure out the right thing to do here...
@@ -465,18 +443,16 @@ static s32 i801_access(struct i2c_adapter *adap, u16 addr, unsigned short flags,
 		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_BYTE\n");
 
 		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01), SMBHSTADD(priv));
-		if (read_write == I2C_SMBUS_WRITE) {
+		if (read_write == I2C_SMBUS_WRITE)
 			outb_p(command, SMBHSTCMD(priv));
-		}
 		xact = I801_BYTE;
 		break;
 	case I2C_SMBUS_BYTE_DATA:
 		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_BYTE_DATA\n");
 		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01), SMBHSTADD(priv));
 		outb_p(command, SMBHSTCMD(priv));
-		if (read_write == I2C_SMBUS_WRITE) {
+		if (read_write == I2C_SMBUS_WRITE)
 			outb_p(data->byte, SMBHSTDAT0(priv));
-		}
 		xact = I801_BYTE_DATA;
 		break;
 	case I2C_SMBUS_WORD_DATA:
@@ -633,9 +609,8 @@ int pi2c_probe(struct platform_device *pldev)
 		pldev->name);
 
 	priv = devm_kzalloc(&pldev->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
+	if (!priv)
 		return -ENOMEM;
-	}
 
 	i2c_set_adapdata(&priv->adapter, priv);
 	priv->adapter.owner = THIS_MODULE;
@@ -677,6 +652,7 @@ int pi2c_probe(struct platform_device *pldev)
 int pi2c_remove(struct platform_device *pldev)
 {
 	struct i2c_device *lddev;
+
 	dev_dbg(&pldev->dev, "%s(pldev = %p '%s')\n", __func__, pldev,
 		pldev->name);
 

commit 8576a5f543273f4bf3af8e3a5b25c918e4dca02a
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Wed May 22 12:13:58 2019 +0000

    staging: kpc2000: kpc_i2c: remove unused module param disable_features
    
    The module parameter 'disable_features' is currently unused. Therefore,
    it should be removed.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
index 42061318d2d4..40a89998726e 100644
--- a/drivers/staging/kpc2000/kpc2000_i2c.c
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -126,10 +126,6 @@ struct i2c_device {
 /* Not really a feature, but it's convenient to handle it as such */
 #define FEATURE_IDF             (1 << 15)
 
-static unsigned int disable_features;
-module_param(disable_features, uint, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(disable_features, "Disable selected driver features");
-
 // FIXME!
 #undef inb_p
 #define inb_p(a) readq((void*)a)

commit 8cac7b354a20742d515d6f649eea32e55a7086b2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 20 10:47:14 2019 +0200

    staging: kpc2000: move the i2c driver out of its subdirectory
    
    There is no need for a subdirectory for just a single .c file.  So move
    it out of kpc_i2c/ and rename it to the module name that we want the
    file to build to, saving one more linking stage.
    
    Cc: Matt Sickler <Matt.Sickler@daktronics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_i2c.c b/drivers/staging/kpc2000/kpc2000_i2c.c
new file mode 100644
index 000000000000..42061318d2d4
--- /dev/null
+++ b/drivers/staging/kpc2000/kpc2000_i2c.c
@@ -0,0 +1,710 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * KPC2000 i2c driver
+ *
+ * Adapted i2c-i801.c for use with Kadoka hardware.
+ *
+ * Copyright (C) 1998 - 2002
+ *	Frodo Looijaard <frodol@dds.nl>,
+ *	Philip Edelbrock <phil@netroedge.com>,
+ *	Mark D. Studebaker <mdsxyz123@yahoo.com>
+ * Copyright (C) 2007 - 2012
+ *	Jean Delvare <khali@linux-fr.org>
+ * Copyright (C) 2010 Intel Corporation
+ *	David Woodhouse <dwmw2@infradead.org>
+ * Copyright (C) 2014-2018 Daktronics
+ *	Matt Sickler <matt.sickler@daktronics.com>,
+ *	Jordon Hofer <jordon.hofer@daktronics.com>
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <asm/io.h>
+#include <linux/io-64-nonatomic-lo-hi.h>
+#include <linux/export.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/rwsem.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include "kpc.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Matt.Sickler@Daktronics.com");
+MODULE_SOFTDEP("pre: i2c-dev");
+
+struct i2c_device {
+	unsigned long           smba;
+	struct i2c_adapter      adapter;
+	struct platform_device *pldev;
+	struct rw_semaphore     rw_sem;
+	unsigned int            features;
+};
+
+/*****************************
+ *** Part 1 - i2c Handlers ***
+ *****************************/
+
+#define REG_SIZE 8
+
+/* I801 SMBus address offsets */
+#define SMBHSTSTS(p)    ((0  * REG_SIZE) + (p)->smba)
+#define SMBHSTCNT(p)    ((2  * REG_SIZE) + (p)->smba)
+#define SMBHSTCMD(p)    ((3  * REG_SIZE) + (p)->smba)
+#define SMBHSTADD(p)    ((4  * REG_SIZE) + (p)->smba)
+#define SMBHSTDAT0(p)   ((5  * REG_SIZE) + (p)->smba)
+#define SMBHSTDAT1(p)   ((6  * REG_SIZE) + (p)->smba)
+#define SMBBLKDAT(p)    ((7  * REG_SIZE) + (p)->smba)
+#define SMBPEC(p)       ((8  * REG_SIZE) + (p)->smba)   /* ICH3 and later */
+#define SMBAUXSTS(p)    ((12 * REG_SIZE) + (p)->smba)   /* ICH4 and later */
+#define SMBAUXCTL(p)    ((13 * REG_SIZE) + (p)->smba)   /* ICH4 and later */
+
+/* PCI Address Constants */
+#define SMBBAR      4
+#define SMBHSTCFG   0x040
+
+/* Host configuration bits for SMBHSTCFG */
+#define SMBHSTCFG_HST_EN        1
+#define SMBHSTCFG_SMB_SMI_EN    2
+#define SMBHSTCFG_I2C_EN        4
+
+/* Auxiliary control register bits, ICH4+ only */
+#define SMBAUXCTL_CRC       1
+#define SMBAUXCTL_E32B      2
+
+/* kill bit for SMBHSTCNT */
+#define SMBHSTCNT_KILL      2
+
+/* Other settings */
+#define MAX_RETRIES         400
+#define ENABLE_INT9         0       /* set to 0x01 to enable - untested */
+
+/* I801 command constants */
+#define I801_QUICK              0x00
+#define I801_BYTE               0x04
+#define I801_BYTE_DATA          0x08
+#define I801_WORD_DATA          0x0C
+#define I801_PROC_CALL          0x10    /* unimplemented */
+#define I801_BLOCK_DATA         0x14
+#define I801_I2C_BLOCK_DATA     0x18    /* ICH5 and later */
+#define I801_BLOCK_LAST         0x34
+#define I801_I2C_BLOCK_LAST     0x38    /* ICH5 and later */
+#define I801_START              0x40
+#define I801_PEC_EN             0x80    /* ICH3 and later */
+
+/* I801 Hosts Status register bits */
+#define SMBHSTSTS_BYTE_DONE     0x80
+#define SMBHSTSTS_INUSE_STS     0x40
+#define SMBHSTSTS_SMBALERT_STS  0x20
+#define SMBHSTSTS_FAILED        0x10
+#define SMBHSTSTS_BUS_ERR       0x08
+#define SMBHSTSTS_DEV_ERR       0x04
+#define SMBHSTSTS_INTR          0x02
+#define SMBHSTSTS_HOST_BUSY     0x01
+
+#define STATUS_FLAGS        (SMBHSTSTS_BYTE_DONE | SMBHSTSTS_FAILED | SMBHSTSTS_BUS_ERR | SMBHSTSTS_DEV_ERR | SMBHSTSTS_INTR)
+
+/* Older devices have their ID defined in <linux/pci_ids.h> */
+#define PCI_DEVICE_ID_INTEL_COUGARPOINT_SMBUS       0x1c22
+#define PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS          0x1d22
+/* Patsburg also has three 'Integrated Device Function' SMBus controllers */
+#define PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF0     0x1d70
+#define PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF1     0x1d71
+#define PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF2     0x1d72
+#define PCI_DEVICE_ID_INTEL_PANTHERPOINT_SMBUS      0x1e22
+#define PCI_DEVICE_ID_INTEL_DH89XXCC_SMBUS          0x2330
+#define PCI_DEVICE_ID_INTEL_5_3400_SERIES_SMBUS     0x3b30
+#define PCI_DEVICE_ID_INTEL_LYNXPOINT_SMBUS         0x8c22
+#define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_SMBUS      0x9c22
+
+
+#define FEATURE_SMBUS_PEC       (1 << 0)
+#define FEATURE_BLOCK_BUFFER    (1 << 1)
+#define FEATURE_BLOCK_PROC      (1 << 2)
+#define FEATURE_I2C_BLOCK_READ  (1 << 3)
+/* Not really a feature, but it's convenient to handle it as such */
+#define FEATURE_IDF             (1 << 15)
+
+static unsigned int disable_features;
+module_param(disable_features, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(disable_features, "Disable selected driver features");
+
+// FIXME!
+#undef inb_p
+#define inb_p(a) readq((void*)a)
+#undef outb_p
+#define outb_p(d,a) writeq(d,(void*)a)
+
+/* Make sure the SMBus host is ready to start transmitting.
+ * Return 0 if it is, -EBUSY if it is not.
+ */
+static int i801_check_pre(struct i2c_device *priv)
+{
+	int status;
+
+	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
+
+	status = inb_p(SMBHSTSTS(priv));
+	if (status & SMBHSTSTS_HOST_BUSY) {
+		dev_err(&priv->adapter.dev, "SMBus is busy, can't use it! (status=%x)\n", status);
+		return -EBUSY;
+	}
+
+	status &= STATUS_FLAGS;
+	if (status) {
+		//dev_dbg(&priv->adapter.dev, "Clearing status flags (%02x)\n", status);
+		outb_p(status, SMBHSTSTS(priv));
+		status = inb_p(SMBHSTSTS(priv)) & STATUS_FLAGS;
+		if (status) {
+			dev_err(&priv->adapter.dev, "Failed clearing status flags (%02x)\n", status);
+			return -EBUSY;
+		}
+	}
+	return 0;
+}
+
+/* Convert the status register to an error code, and clear it. */
+static int i801_check_post(struct i2c_device *priv, int status, int timeout)
+{
+	int result = 0;
+
+	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
+
+	/* If the SMBus is still busy, we give up */
+	if (timeout) {
+		dev_err(&priv->adapter.dev, "Transaction timeout\n");
+		/* try to stop the current command */
+		dev_dbg(&priv->adapter.dev, "Terminating the current operation\n");
+		outb_p(inb_p(SMBHSTCNT(priv)) | SMBHSTCNT_KILL, SMBHSTCNT(priv));
+		usleep_range(1000, 2000);
+		outb_p(inb_p(SMBHSTCNT(priv)) & (~SMBHSTCNT_KILL), SMBHSTCNT(priv));
+
+		/* Check if it worked */
+		status = inb_p(SMBHSTSTS(priv));
+		if ((status & SMBHSTSTS_HOST_BUSY) || !(status & SMBHSTSTS_FAILED)) {
+			dev_err(&priv->adapter.dev, "Failed terminating the transaction\n");
+		}
+		outb_p(STATUS_FLAGS, SMBHSTSTS(priv));
+		return -ETIMEDOUT;
+	}
+
+	if (status & SMBHSTSTS_FAILED) {
+		result = -EIO;
+		dev_err(&priv->adapter.dev, "Transaction failed\n");
+	}
+	if (status & SMBHSTSTS_DEV_ERR) {
+		result = -ENXIO;
+		dev_dbg(&priv->adapter.dev, "No response\n");
+	}
+	if (status & SMBHSTSTS_BUS_ERR) {
+		result = -EAGAIN;
+		dev_dbg(&priv->adapter.dev, "Lost arbitration\n");
+	}
+
+	if (result) {
+		/* Clear error flags */
+		outb_p(status & STATUS_FLAGS, SMBHSTSTS(priv));
+		status = inb_p(SMBHSTSTS(priv)) & STATUS_FLAGS;
+		if (status) {
+			dev_warn(&priv->adapter.dev, "Failed clearing status flags at end of transaction (%02x)\n", status);
+		}
+	}
+
+	return result;
+}
+
+static int i801_transaction(struct i2c_device *priv, int xact)
+{
+	int status;
+	int result;
+	int timeout = 0;
+
+	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
+
+	result = i801_check_pre(priv);
+	if (result < 0) {
+		return result;
+	}
+	/* the current contents of SMBHSTCNT can be overwritten, since PEC,
+	 * INTREN, SMBSCMD are passed in xact
+	 */
+	outb_p(xact | I801_START, SMBHSTCNT(priv));
+
+	/* We will always wait for a fraction of a second! */
+	do {
+		usleep_range(250, 500);
+		status = inb_p(SMBHSTSTS(priv));
+	} while ((status & SMBHSTSTS_HOST_BUSY) && (timeout++ < MAX_RETRIES));
+
+	result = i801_check_post(priv, status, timeout > MAX_RETRIES);
+	if (result < 0) {
+		return result;
+	}
+
+	outb_p(SMBHSTSTS_INTR, SMBHSTSTS(priv));
+	return 0;
+}
+
+/* wait for INTR bit as advised by Intel */
+static void i801_wait_hwpec(struct i2c_device *priv)
+{
+	int timeout = 0;
+	int status;
+
+	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
+
+	do {
+		usleep_range(250, 500);
+		status = inb_p(SMBHSTSTS(priv));
+	} while ((!(status & SMBHSTSTS_INTR)) && (timeout++ < MAX_RETRIES));
+
+	if (timeout > MAX_RETRIES) {
+		dev_dbg(&priv->adapter.dev, "PEC Timeout!\n");
+	}
+
+	outb_p(status, SMBHSTSTS(priv));
+}
+
+static int i801_block_transaction_by_block(struct i2c_device *priv, union i2c_smbus_data *data, char read_write, int hwpec)
+{
+	int i, len;
+	int status;
+
+	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
+
+	inb_p(SMBHSTCNT(priv)); /* reset the data buffer index */
+
+	/* Use 32-byte buffer to process this transaction */
+	if (read_write == I2C_SMBUS_WRITE) {
+		len = data->block[0];
+		outb_p(len, SMBHSTDAT0(priv));
+		for (i = 0; i < len; i++) {
+			outb_p(data->block[i+1], SMBBLKDAT(priv));
+		}
+	}
+
+	status = i801_transaction(priv, I801_BLOCK_DATA | ENABLE_INT9 | I801_PEC_EN * hwpec);
+	if (status) {
+		return status;
+	}
+
+	if (read_write == I2C_SMBUS_READ) {
+		len = inb_p(SMBHSTDAT0(priv));
+		if (len < 1 || len > I2C_SMBUS_BLOCK_MAX) {
+			return -EPROTO;
+		}
+
+		data->block[0] = len;
+		for (i = 0; i < len; i++) {
+			data->block[i + 1] = inb_p(SMBBLKDAT(priv));
+		}
+	}
+	return 0;
+}
+
+static int i801_block_transaction_byte_by_byte(struct i2c_device *priv, union i2c_smbus_data *data, char read_write, int command, int hwpec)
+{
+	int i, len;
+	int smbcmd;
+	int status;
+	int result;
+	int timeout;
+
+	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
+
+	result = i801_check_pre(priv);
+	if (result < 0) {
+		return result;
+	}
+
+	len = data->block[0];
+
+	if (read_write == I2C_SMBUS_WRITE) {
+		outb_p(len, SMBHSTDAT0(priv));
+		outb_p(data->block[1], SMBBLKDAT(priv));
+	}
+
+	for (i = 1; i <= len; i++) {
+		if (i == len && read_write == I2C_SMBUS_READ) {
+			if (command == I2C_SMBUS_I2C_BLOCK_DATA) {
+				smbcmd = I801_I2C_BLOCK_LAST;
+			} else {
+				smbcmd = I801_BLOCK_LAST;
+			}
+		} else {
+			if (command == I2C_SMBUS_I2C_BLOCK_DATA && read_write == I2C_SMBUS_READ) {
+				smbcmd = I801_I2C_BLOCK_DATA;
+			} else {
+				smbcmd = I801_BLOCK_DATA;
+			}
+		}
+		outb_p(smbcmd | ENABLE_INT9, SMBHSTCNT(priv));
+
+		if (i == 1) {
+			outb_p(inb(SMBHSTCNT(priv)) | I801_START, SMBHSTCNT(priv));
+		}
+		/* We will always wait for a fraction of a second! */
+		timeout = 0;
+		do {
+			usleep_range(250, 500);
+			status = inb_p(SMBHSTSTS(priv));
+		} while ((!(status & SMBHSTSTS_BYTE_DONE)) && (timeout++ < MAX_RETRIES));
+
+		result = i801_check_post(priv, status, timeout > MAX_RETRIES);
+		if (result < 0) {
+			return result;
+		}
+		if (i == 1 && read_write == I2C_SMBUS_READ && command != I2C_SMBUS_I2C_BLOCK_DATA) {
+			len = inb_p(SMBHSTDAT0(priv));
+			if (len < 1 || len > I2C_SMBUS_BLOCK_MAX) {
+				dev_err(&priv->adapter.dev, "Illegal SMBus block read size %d\n", len);
+				/* Recover */
+				while (inb_p(SMBHSTSTS(priv)) & SMBHSTSTS_HOST_BUSY) {
+					outb_p(SMBHSTSTS_BYTE_DONE, SMBHSTSTS(priv));
+				}
+				outb_p(SMBHSTSTS_INTR, SMBHSTSTS(priv));
+				return -EPROTO;
+			}
+			data->block[0] = len;
+		}
+
+		/* Retrieve/store value in SMBBLKDAT */
+		if (read_write == I2C_SMBUS_READ) {
+			data->block[i] = inb_p(SMBBLKDAT(priv));
+		}
+		if (read_write == I2C_SMBUS_WRITE && i+1 <= len) {
+			outb_p(data->block[i+1], SMBBLKDAT(priv));
+		}
+		/* signals SMBBLKDAT ready */
+		outb_p(SMBHSTSTS_BYTE_DONE | SMBHSTSTS_INTR, SMBHSTSTS(priv));
+	}
+
+	return 0;
+}
+
+static int i801_set_block_buffer_mode(struct i2c_device *priv)
+{
+	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
+
+	outb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_E32B, SMBAUXCTL(priv));
+	if ((inb_p(SMBAUXCTL(priv)) & SMBAUXCTL_E32B) == 0) {
+		return -EIO;
+	}
+	return 0;
+}
+
+/* Block transaction function */
+static int i801_block_transaction(struct i2c_device *priv, union i2c_smbus_data *data, char read_write, int command, int hwpec)
+{
+	int result = 0;
+	//unsigned char hostc;
+
+	dev_dbg(&priv->adapter.dev, "%s\n", __func__);
+
+	if (command == I2C_SMBUS_I2C_BLOCK_DATA) {
+		if (read_write == I2C_SMBUS_WRITE) {
+			/* set I2C_EN bit in configuration register */
+			//TODO: Figure out the right thing to do here...
+			//pci_read_config_byte(priv->pci_dev, SMBHSTCFG, &hostc);
+			//pci_write_config_byte(priv->pci_dev, SMBHSTCFG, hostc | SMBHSTCFG_I2C_EN);
+		} else if (!(priv->features & FEATURE_I2C_BLOCK_READ)) {
+			dev_err(&priv->adapter.dev, "I2C block read is unsupported!\n");
+			return -EOPNOTSUPP;
+		}
+	}
+
+	if (read_write == I2C_SMBUS_WRITE || command == I2C_SMBUS_I2C_BLOCK_DATA) {
+		if (data->block[0] < 1) {
+			data->block[0] = 1;
+		}
+		if (data->block[0] > I2C_SMBUS_BLOCK_MAX) {
+			data->block[0] = I2C_SMBUS_BLOCK_MAX;
+		}
+	} else {
+		data->block[0] = 32;	/* max for SMBus block reads */
+	}
+
+	/* Experience has shown that the block buffer can only be used for
+	 * SMBus (not I2C) block transactions, even though the datasheet
+	 * doesn't mention this limitation.
+	 */
+	if ((priv->features & FEATURE_BLOCK_BUFFER) && command != I2C_SMBUS_I2C_BLOCK_DATA && i801_set_block_buffer_mode(priv) == 0) {
+		result = i801_block_transaction_by_block(priv, data, read_write, hwpec);
+	} else {
+		result = i801_block_transaction_byte_by_byte(priv, data, read_write, command, hwpec);
+	}
+	if (result == 0 && hwpec) {
+		i801_wait_hwpec(priv);
+	}
+	if (command == I2C_SMBUS_I2C_BLOCK_DATA && read_write == I2C_SMBUS_WRITE) {
+		/* restore saved configuration register value */
+		//TODO: Figure out the right thing to do here...
+		//pci_write_config_byte(priv->pci_dev, SMBHSTCFG, hostc);
+	}
+	return result;
+}
+
+/* Return negative errno on error. */
+static s32 i801_access(struct i2c_adapter *adap, u16 addr, unsigned short flags, char read_write, u8 command, int size, union i2c_smbus_data *data)
+{
+	int hwpec;
+	int block = 0;
+	int ret, xact = 0;
+	struct i2c_device *priv = i2c_get_adapdata(adap);
+
+	dev_dbg(&priv->adapter.dev,
+		"%s (addr=%0d)  flags=%x  read_write=%x  command=%x  size=%x",
+		__func__, addr, flags, read_write, command, size);
+
+	hwpec = (priv->features & FEATURE_SMBUS_PEC) && (flags & I2C_CLIENT_PEC) && size != I2C_SMBUS_QUICK && size != I2C_SMBUS_I2C_BLOCK_DATA;
+
+	switch (size) {
+	case I2C_SMBUS_QUICK:
+		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_QUICK\n");
+		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01), SMBHSTADD(priv));
+		xact = I801_QUICK;
+		break;
+	case I2C_SMBUS_BYTE:
+		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_BYTE\n");
+
+		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01), SMBHSTADD(priv));
+		if (read_write == I2C_SMBUS_WRITE) {
+			outb_p(command, SMBHSTCMD(priv));
+		}
+		xact = I801_BYTE;
+		break;
+	case I2C_SMBUS_BYTE_DATA:
+		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_BYTE_DATA\n");
+		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01), SMBHSTADD(priv));
+		outb_p(command, SMBHSTCMD(priv));
+		if (read_write == I2C_SMBUS_WRITE) {
+			outb_p(data->byte, SMBHSTDAT0(priv));
+		}
+		xact = I801_BYTE_DATA;
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_WORD_DATA\n");
+		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01), SMBHSTADD(priv));
+		outb_p(command, SMBHSTCMD(priv));
+		if (read_write == I2C_SMBUS_WRITE) {
+			outb_p(data->word & 0xff, SMBHSTDAT0(priv));
+			outb_p((data->word & 0xff00) >> 8, SMBHSTDAT1(priv));
+		}
+		xact = I801_WORD_DATA;
+		break;
+	case I2C_SMBUS_BLOCK_DATA:
+		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_BLOCK_DATA\n");
+		outb_p(((addr & 0x7f) << 1) | (read_write & 0x01), SMBHSTADD(priv));
+		outb_p(command, SMBHSTCMD(priv));
+		block = 1;
+		break;
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		dev_dbg(&priv->adapter.dev, "  [acc] SMBUS_I2C_BLOCK_DATA\n");
+		/* NB: page 240 of ICH5 datasheet shows that the R/#W
+		 * bit should be cleared here, even when reading
+		 */
+		outb_p((addr & 0x7f) << 1, SMBHSTADD(priv));
+		if (read_write == I2C_SMBUS_READ) {
+			/* NB: page 240 of ICH5 datasheet also shows
+			 * that DATA1 is the cmd field when reading
+			 */
+			outb_p(command, SMBHSTDAT1(priv));
+		} else {
+			outb_p(command, SMBHSTCMD(priv));
+		}
+		block = 1;
+		break;
+	default:
+		dev_dbg(&priv->adapter.dev, "  [acc] Unsupported transaction %d\n", size);
+		return -EOPNOTSUPP;
+	}
+
+	if (hwpec) { /* enable/disable hardware PEC */
+		dev_dbg(&priv->adapter.dev, "  [acc] hwpec: yes\n");
+		outb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_CRC, SMBAUXCTL(priv));
+	} else {
+		dev_dbg(&priv->adapter.dev, "  [acc] hwpec: no\n");
+		outb_p(inb_p(SMBAUXCTL(priv)) & (~SMBAUXCTL_CRC), SMBAUXCTL(priv));
+	}
+
+	if (block) {
+		//ret = 0;
+		dev_dbg(&priv->adapter.dev, "  [acc] block: yes\n");
+		ret = i801_block_transaction(priv, data, read_write, size, hwpec);
+	} else {
+		dev_dbg(&priv->adapter.dev, "  [acc] block: no\n");
+		ret = i801_transaction(priv, xact | ENABLE_INT9);
+	}
+
+	/* Some BIOSes don't like it when PEC is enabled at reboot or resume
+	 * time, so we forcibly disable it after every transaction. Turn off
+	 * E32B for the same reason.
+	 */
+	if (hwpec || block) {
+		dev_dbg(&priv->adapter.dev, "  [acc] hwpec || block\n");
+		outb_p(inb_p(SMBAUXCTL(priv)) & ~(SMBAUXCTL_CRC | SMBAUXCTL_E32B), SMBAUXCTL(priv));
+	}
+	if (block) {
+		dev_dbg(&priv->adapter.dev, "  [acc] block\n");
+		return ret;
+	}
+	if (ret) {
+		dev_dbg(&priv->adapter.dev, "  [acc] ret %d\n", ret);
+		return ret;
+	}
+	if ((read_write == I2C_SMBUS_WRITE) || (xact == I801_QUICK)) {
+		dev_dbg(&priv->adapter.dev, "  [acc] I2C_SMBUS_WRITE || I801_QUICK  -> ret 0\n");
+		return 0;
+	}
+
+	switch (xact & 0x7f) {
+	case I801_BYTE:  /* Result put in SMBHSTDAT0 */
+	case I801_BYTE_DATA:
+		dev_dbg(&priv->adapter.dev, "  [acc] I801_BYTE or I801_BYTE_DATA\n");
+		data->byte = inb_p(SMBHSTDAT0(priv));
+		break;
+	case I801_WORD_DATA:
+		dev_dbg(&priv->adapter.dev, "  [acc] I801_WORD_DATA\n");
+		data->word = inb_p(SMBHSTDAT0(priv)) + (inb_p(SMBHSTDAT1(priv)) << 8);
+		break;
+	}
+	return 0;
+}
+
+
+
+static u32 i801_func(struct i2c_adapter *adapter)
+{
+	struct i2c_device *priv = i2c_get_adapdata(adapter);
+
+	/* original settings
+	 * u32 f = I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
+	 * I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
+	 * I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_WRITE_I2C_BLOCK |
+	 * ((priv->features & FEATURE_SMBUS_PEC) ? I2C_FUNC_SMBUS_PEC : 0) |
+	 * ((priv->features & FEATURE_I2C_BLOCK_READ) ?
+	 * I2C_FUNC_SMBUS_READ_I2C_BLOCK : 0);
+	 */
+
+	// http://lxr.free-electrons.com/source/include/uapi/linux/i2c.h#L85
+
+	u32 f =
+		I2C_FUNC_I2C                     | /* 0x00000001 (I enabled this one) */
+		!I2C_FUNC_10BIT_ADDR             | /* 0x00000002 */
+		!I2C_FUNC_PROTOCOL_MANGLING      | /* 0x00000004 */
+		((priv->features & FEATURE_SMBUS_PEC) ? I2C_FUNC_SMBUS_PEC : 0) | /* 0x00000008 */
+		!I2C_FUNC_SMBUS_BLOCK_PROC_CALL  | /* 0x00008000 */
+		I2C_FUNC_SMBUS_QUICK             | /* 0x00010000 */
+		!I2C_FUNC_SMBUS_READ_BYTE        | /* 0x00020000 */
+		!I2C_FUNC_SMBUS_WRITE_BYTE       | /* 0x00040000 */
+		!I2C_FUNC_SMBUS_READ_BYTE_DATA   | /* 0x00080000 */
+		!I2C_FUNC_SMBUS_WRITE_BYTE_DATA  | /* 0x00100000 */
+		!I2C_FUNC_SMBUS_READ_WORD_DATA   | /* 0x00200000 */
+		!I2C_FUNC_SMBUS_WRITE_WORD_DATA  | /* 0x00400000 */
+		!I2C_FUNC_SMBUS_PROC_CALL        | /* 0x00800000 */
+		!I2C_FUNC_SMBUS_READ_BLOCK_DATA  | /* 0x01000000 */
+		!I2C_FUNC_SMBUS_WRITE_BLOCK_DATA | /* 0x02000000 */
+		((priv->features & FEATURE_I2C_BLOCK_READ) ? I2C_FUNC_SMBUS_READ_I2C_BLOCK : 0) | /* 0x04000000 */
+		I2C_FUNC_SMBUS_WRITE_I2C_BLOCK   | /* 0x08000000 */
+
+		I2C_FUNC_SMBUS_BYTE              | /* _READ_BYTE  _WRITE_BYTE */
+		I2C_FUNC_SMBUS_BYTE_DATA         | /* _READ_BYTE_DATA  _WRITE_BYTE_DATA */
+		I2C_FUNC_SMBUS_WORD_DATA         | /* _READ_WORD_DATA  _WRITE_WORD_DATA */
+		I2C_FUNC_SMBUS_BLOCK_DATA        | /* _READ_BLOCK_DATA  _WRITE_BLOCK_DATA */
+		!I2C_FUNC_SMBUS_I2C_BLOCK        | /* _READ_I2C_BLOCK  _WRITE_I2C_BLOCK */
+		!I2C_FUNC_SMBUS_EMUL;              /* _QUICK  _BYTE  _BYTE_DATA  _WORD_DATA  _PROC_CALL  _WRITE_BLOCK_DATA  _I2C_BLOCK _PEC */
+	return f;
+}
+
+static const struct i2c_algorithm smbus_algorithm = {
+	.smbus_xfer     = i801_access,
+	.functionality  = i801_func,
+};
+
+
+
+/********************************
+ *** Part 2 - Driver Handlers ***
+ ********************************/
+int pi2c_probe(struct platform_device *pldev)
+{
+	int err;
+	struct i2c_device *priv;
+	struct resource *res;
+
+	dev_dbg(&pldev->dev, "%s(pldev = %p '%s')\n", __func__, pldev,
+		pldev->name);
+
+	priv = devm_kzalloc(&pldev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		return -ENOMEM;
+	}
+
+	i2c_set_adapdata(&priv->adapter, priv);
+	priv->adapter.owner = THIS_MODULE;
+	priv->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
+	priv->adapter.algo = &smbus_algorithm;
+
+	res = platform_get_resource(pldev, IORESOURCE_MEM, 0);
+	priv->smba = (unsigned long)ioremap_nocache(res->start, resource_size(res));
+
+	priv->pldev = pldev;
+	pldev->dev.platform_data = priv;
+
+	priv->features |= FEATURE_IDF;
+	priv->features |= FEATURE_I2C_BLOCK_READ;
+	priv->features |= FEATURE_SMBUS_PEC;
+	priv->features |= FEATURE_BLOCK_BUFFER;
+
+	//init_MUTEX(&lddata->sem);
+	init_rwsem(&priv->rw_sem);
+
+	/* set up the sysfs linkage to our parent device */
+	priv->adapter.dev.parent = &pldev->dev;
+
+	/* Retry up to 3 times on lost arbitration */
+	priv->adapter.retries = 3;
+
+	//snprintf(priv->adapter.name, sizeof(priv->adapter.name), "Fake SMBus I801 adapter at %04lx", priv->smba);
+	snprintf(priv->adapter.name, sizeof(priv->adapter.name), "Fake SMBus I801 adapter");
+
+	err = i2c_add_adapter(&priv->adapter);
+	if (err) {
+		dev_err(&priv->adapter.dev, "Failed to add SMBus adapter\n");
+		return err;
+	}
+
+	return 0;
+}
+
+int pi2c_remove(struct platform_device *pldev)
+{
+	struct i2c_device *lddev;
+	dev_dbg(&pldev->dev, "%s(pldev = %p '%s')\n", __func__, pldev,
+		pldev->name);
+
+	lddev = (struct i2c_device *)pldev->dev.platform_data;
+
+	i2c_del_adapter(&lddev->adapter);
+
+	//TODO: Figure out the right thing to do here...
+	//pci_write_config_byte(dev, SMBHSTCFG, priv->original_hstcfg);
+	//pci_release_region(dev, SMBBAR);
+	//pci_set_drvdata(dev, NULL);
+
+	//cdev_del(&lddev->cdev);
+
+	return 0;
+}
+
+struct platform_driver i2c_plat_driver_i = {
+	.probe      = pi2c_probe,
+	.remove     = pi2c_remove,
+	.driver     = {
+		.name   = KP_DRIVER_NAME_I2C,
+		.owner  = THIS_MODULE,
+	},
+};
+
+module_platform_driver(i2c_plat_driver_i);
