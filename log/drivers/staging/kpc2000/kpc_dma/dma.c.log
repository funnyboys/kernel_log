commit dbec450e2d522815fb16dd96aff4c244001eddf8
Author: Sam Muhammed <jane.pnx9@gmail.com>
Date:   Wed Mar 25 10:26:40 2020 -0400

    Staging: kpc2000: kpc_dma: Use the SPDK comment style.
    
    SPDK-License-Identifier comment should have this form
    // SPDX-License-Identifier: <GPL-...>
    
    Signed-off-by: Sam Muhammed <jane.pnx9@gmail.com>
    Link: https://lore.kernel.org/r/7531e3e3fa7c046e93d2caaa6fa2e76c5c53f04d.1585143581.git.jane.pnx9@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc_dma/dma.c b/drivers/staging/kpc2000/kpc_dma/dma.c
index 5ccc93ed2b61..452a3f7c835d 100644
--- a/drivers/staging/kpc2000/kpc_dma/dma.c
+++ b/drivers/staging/kpc2000/kpc_dma/dma.c
@@ -1,4 +1,4 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
+// SPDX-License-Identifier: GPL-2.0+
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/types.h>

commit b1436fe3e286fc1b04b3f4900905230b00a6b8fd
Author: Sam Muhammed <jane.pnx9@gmail.com>
Date:   Wed Mar 25 10:26:38 2020 -0400

    Staging: kpc2000: kpc_dma: Remove unnecessary braces.
    
    Remove braces of single statement blocks,
    they are not really needed.
    
    Signed-off-by: Sam Muhammed <jane.pnx9@gmail.com>
    Link: https://lore.kernel.org/r/0a3ec63321dce008fc8dd790f42ef8490135b307.1585143581.git.jane.pnx9@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc_dma/dma.c b/drivers/staging/kpc2000/kpc_dma/dma.c
index 4bfbc717bc07..5ccc93ed2b61 100644
--- a/drivers/staging/kpc2000/kpc_dma/dma.c
+++ b/drivers/staging/kpc2000/kpc_dma/dma.c
@@ -97,11 +97,10 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 	if (WARN(!(caps & ENG_CAP_PRESENT), "%s() called for DMA Engine at %p which isn't present in hardware!\n", __func__, eng))
 		return -ENXIO;
 
-	if (caps & ENG_CAP_DIRECTION) {
+	if (caps & ENG_CAP_DIRECTION)
 		eng->dir = DMA_FROM_DEVICE;
-	} else {
+	else
 		eng->dir = DMA_TO_DEVICE;
-	}
 
 	eng->desc_pool_cnt = desc_cnt;
 	eng->desc_pool = dma_pool_create("KPC DMA Descriptors", &eng->pldev->dev, sizeof(struct kpc_dma_descriptor), DMA_DESC_ALIGNMENT, 4096);

commit 0af192c755bdfe0476d3ffc99e8483644c026deb
Author: Sam Muhammed <jane.pnx9@gmail.com>
Date:   Wed Mar 25 10:26:36 2020 -0400

    Staging: kpc2000: kpc_dma: Remove comparison to NULL.
    
    Comparison to NULL been used across the driver,
    remove them and use (!var) instead.
    
    Checkpatch.pl: CHECK:
    Comparison to NULL could be written "!desc"... etc
    
    Signed-off-by: Sam Muhammed <jane.pnx9@gmail.com>
    Link: https://lore.kernel.org/r/f344afba0a8bb0413941a63678688435f04a96b4.1585143581.git.jane.pnx9@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc_dma/dma.c b/drivers/staging/kpc2000/kpc_dma/dma.c
index 51a4dd534a0d..4bfbc717bc07 100644
--- a/drivers/staging/kpc2000/kpc_dma/dma.c
+++ b/drivers/staging/kpc2000/kpc_dma/dma.c
@@ -236,7 +236,7 @@ int  count_descriptors_available(struct kpc_dma_device *eng)
 	struct kpc_dma_descriptor *cur = eng->desc_next;
 
 	while (cur != eng->desc_completed) {
-		BUG_ON(cur == NULL);
+		BUG_ON(!cur);
 		count++;
 		cur = cur->Next;
 	}

commit a50d99d40199db24e0c321457bd3da2df107dd71
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu Jul 4 08:08:10 2019 +0200

    staging: kpc2000: simplify comparison to NULL in dma.c
    
    Fixes checkpatch warning "Comparison to NULL could be written [...]".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Link: https://lore.kernel.org/r/20190704060811.10330-3-simon@nikanor.nu
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc_dma/dma.c b/drivers/staging/kpc2000/kpc_dma/dma.c
index 8092d0cf4a4a..51a4dd534a0d 100644
--- a/drivers/staging/kpc2000/kpc_dma/dma.c
+++ b/drivers/staging/kpc2000/kpc_dma/dma.c
@@ -119,7 +119,7 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 	cur = eng->desc_pool_first;
 	for (i = 1 ; i < eng->desc_pool_cnt ; i++) {
 		next = dma_pool_alloc(eng->desc_pool, GFP_KERNEL | GFP_DMA, &next_handle);
-		if (next == NULL)
+		if (!next)
 			goto done_alloc;
 
 		clear_desc(next);
@@ -245,7 +245,7 @@ int  count_descriptors_available(struct kpc_dma_device *eng)
 
 void  clear_desc(struct kpc_dma_descriptor *desc)
 {
-	if (desc == NULL)
+	if (!desc)
 		return;
 	desc->DescByteCount         = 0;
 	desc->DescStatusErrorFlags  = 0;

commit 39547bc5e81a78836acb97db3179da691986143e
Author: Simon Sandström <simon@nikanor.nu>
Date:   Mon Jun 10 10:44:30 2019 +0200

    staging: kpc2000: remove unnecessary debug prints in dma.c
    
    Debug prints that are used only to inform about function entry or exit
    can be removed as ftrace can be used to get this information.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc_dma/dma.c b/drivers/staging/kpc2000/kpc_dma/dma.c
index 059932ab5907..8092d0cf4a4a 100644
--- a/drivers/staging/kpc2000/kpc_dma/dma.c
+++ b/drivers/staging/kpc2000/kpc_dma/dma.c
@@ -92,8 +92,6 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 	unsigned int i;
 	int rv;
 
-	dev_dbg(&eng->pldev->dev, "Setting up DMA engine [%p]\n", eng);
-
 	caps = GetEngineCapabilities(eng);
 
 	if (WARN(!(caps & ENG_CAP_PRESENT), "%s() called for DMA Engine at %p which isn't present in hardware!\n", __func__, eng))
@@ -161,8 +159,6 @@ void  stop_dma_engine(struct kpc_dma_device *eng)
 {
 	unsigned long timeout;
 
-	dev_dbg(&eng->pldev->dev, "Destroying DMA engine [%p]\n", eng);
-
 	// Disable the descriptor engine
 	WriteEngineControl(eng, 0);
 

commit db013a8826aa5a21e64fd328acc26e12c850b3f1
Author: Puranjay Mohan <puranjay12@gmail.com>
Date:   Wed May 15 22:03:14 2019 +0530

    Staging: kpc2000: kpc_dma: include <linux/io.h> instead of <asm/io.h>
    
    Fix following checkpatch.pl warning by including
    <linux/io.h> instead of <asm/io.h>.
    
    WARNING: Use #include <linux/io.h> instead of <asm/io.h>
    
    Signed-off-by: Puranjay Mohan <puranjay12@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc_dma/dma.c b/drivers/staging/kpc2000/kpc_dma/dma.c
index 13687ab3e9c7..059932ab5907 100644
--- a/drivers/staging/kpc2000/kpc_dma/dma.c
+++ b/drivers/staging/kpc2000/kpc_dma/dma.c
@@ -2,7 +2,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/types.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/export.h>
 #include <linux/slab.h>
 #include <linux/platform_device.h>

commit 1c13ef4fa1817d2eb5d19f53ac02a4d7e44cefe0
Author: Vandana BN <bnvandana@gmail.com>
Date:   Mon May 13 19:13:26 2019 +0530

    Staging: kpc2000: kpc_dma: Resolve warning to use __func__ insted of funtion name reported by checkpatch.
    
    This patch resolves warnings to use __func__ insted of funtion name.
    WARNING: Prefer using '"%s...", __func__' to using 'setup_dma_engine', this function's name, in a string
    
    Signed-off-by: Vandana BN <bnvandana@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc_dma/dma.c b/drivers/staging/kpc2000/kpc_dma/dma.c
index ac842fa38c64..13687ab3e9c7 100644
--- a/drivers/staging/kpc2000/kpc_dma/dma.c
+++ b/drivers/staging/kpc2000/kpc_dma/dma.c
@@ -96,7 +96,7 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 
 	caps = GetEngineCapabilities(eng);
 
-	if (WARN(!(caps & ENG_CAP_PRESENT), "setup_dma_engine() called for DMA Engine at %p which isn't present in hardware!\n", eng))
+	if (WARN(!(caps & ENG_CAP_PRESENT), "%s() called for DMA Engine at %p which isn't present in hardware!\n", __func__, eng))
 		return -ENXIO;
 
 	if (caps & ENG_CAP_DIRECTION) {
@@ -110,7 +110,7 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 
 	eng->desc_pool_first = dma_pool_alloc(eng->desc_pool, GFP_KERNEL | GFP_DMA, &head_handle);
 	if (!eng->desc_pool_first) {
-		dev_err(&eng->pldev->dev, "setup_dma_engine: couldn't allocate desc_pool_first!\n");
+		dev_err(&eng->pldev->dev, "%s: couldn't allocate desc_pool_first!\n", __func__);
 		dma_pool_destroy(eng->desc_pool);
 		return -ENOMEM;
 	}
@@ -146,7 +146,7 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 	// Grab IRQ line
 	rv = request_irq(eng->irq, ndd_irq_handler, IRQF_SHARED, KP_DRIVER_NAME_DMA_CONTROLLER, eng);
 	if (rv) {
-		dev_err(&eng->pldev->dev, "setup_dma_engine: failed to request_irq: %d\n", rv);
+		dev_err(&eng->pldev->dev, "%s: failed to request_irq: %d\n", __func__, rv);
 		return rv;
 	}
 

commit 63c867d794e89edc22440e8d9581063eeb766bda
Author: Vandana BN <bnvandana@gmail.com>
Date:   Mon May 13 19:13:25 2019 +0530

    Staging: kpc2000: kpc_dma: Resolve warning Missing blank line after declarations & labels not to be indented.
    
    This patch resloves below warnings reported by checkpath in kpc_dma
    WARNING: Missing a blank line after declarations
    WARNING: labels should not be indented
    CHECK: Please don't use multiple blank lines
    CHECK: Please use a blank line after function/struct/union/enum
    declarations
    
    Signed-off-by: Vandana BN <bnvandana@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc_dma/dma.c b/drivers/staging/kpc2000/kpc_dma/dma.c
index 2053316009bc..ac842fa38c64 100644
--- a/drivers/staging/kpc2000/kpc_dma/dma.c
+++ b/drivers/staging/kpc2000/kpc_dma/dma.c
@@ -27,6 +27,7 @@ void  ndd_irq_worker(struct work_struct *ws)
 {
 	struct kpc_dma_descriptor *cur;
 	struct kpc_dma_device *eng = container_of(ws, struct kpc_dma_device, irq_work);
+
 	lock_engine(eng);
 
 	if (GetEngineCompletePtr(eng) == 0)
@@ -67,7 +68,6 @@ void  ndd_irq_worker(struct work_struct *ws)
 	unlock_engine(eng);
 }
 
-
 /**********  DMA Engine Init/Teardown  **********/
 void  start_dma_engine(struct kpc_dma_device *eng)
 {
@@ -91,6 +91,7 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 	dma_addr_t head_handle;
 	unsigned int i;
 	int rv;
+
 	dev_dbg(&eng->pldev->dev, "Setting up DMA engine [%p]\n", eng);
 
 	caps = GetEngineCapabilities(eng);
@@ -159,6 +160,7 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 void  stop_dma_engine(struct kpc_dma_device *eng)
 {
 	unsigned long timeout;
+
 	dev_dbg(&eng->pldev->dev, "Destroying DMA engine [%p]\n", eng);
 
 	// Disable the descriptor engine
@@ -220,6 +222,7 @@ void  destroy_dma_engine(struct kpc_dma_device *eng)
 	for (i = 0 ; i < eng->desc_pool_cnt ; i++) {
 		struct kpc_dma_descriptor *next = cur->Next;
 		dma_addr_t next_handle = cur->DescNextDescPtr;
+
 		dma_pool_free(eng->desc_pool, cur, cur_handle);
 		cur_handle = next_handle;
 		cur = next;
@@ -230,13 +233,12 @@ void  destroy_dma_engine(struct kpc_dma_device *eng)
 	free_irq(eng->irq, eng);
 }
 
-
-
 /**********  Helper Functions  **********/
 int  count_descriptors_available(struct kpc_dma_device *eng)
 {
 	u32 count = 0;
 	struct kpc_dma_descriptor *cur = eng->desc_next;
+
 	while (cur != eng->desc_completed) {
 		BUG_ON(cur == NULL);
 		count++;

commit f3092723b7edd078bdb151c73279b79ce6e44017
Author: Vandana BN <bnvandana@gmail.com>
Date:   Mon May 13 19:13:22 2019 +0530

    Staging: kpc2000: kpc_dma: Resolve checkpatch space errors around brace '{', '!' and open paranthesis '('.
    
    This patch resolves below errors reported by checkpath
    ERROR: space required before the open brace '{'
    ERROR: space prohibited after that '!' (ctx:BxW)
    ERROR: space prohibited after that open parenthesis '('
    
    Signed-off-by: Vandana BN <bnvandana@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc_dma/dma.c b/drivers/staging/kpc2000/kpc_dma/dma.c
index 488b9b81debc..2053316009bc 100644
--- a/drivers/staging/kpc2000/kpc_dma/dma.c
+++ b/drivers/staging/kpc2000/kpc_dma/dma.c
@@ -41,7 +41,7 @@ void  ndd_irq_worker(struct work_struct *ws)
 		dev_dbg(&eng->pldev->dev, "Handling completed descriptor %p (acd = %p)\n", cur, cur->acd);
 		BUG_ON(cur == eng->desc_next); // Ordering failure.
 
-		if (cur->DescControlFlags & DMA_DESC_CTL_SOP){
+		if (cur->DescControlFlags & DMA_DESC_CTL_SOP) {
 			eng->accumulated_bytes = 0;
 			eng->accumulated_flags = 0;
 		}
@@ -53,7 +53,7 @@ void  ndd_irq_worker(struct work_struct *ws)
 		if (cur->DescStatusFlags & DMA_DESC_STS_SHORT)
 			eng->accumulated_flags |= ACD_FLAG_ENG_ACCUM_SHORT;
 
-		if (cur->DescControlFlags & DMA_DESC_CTL_EOP){
+		if (cur->DescControlFlags & DMA_DESC_CTL_EOP) {
 			if (cur->acd)
 				transfer_complete_cb(cur->acd, eng->accumulated_bytes, eng->accumulated_flags | ACD_FLAG_DONE);
 		}
@@ -98,7 +98,7 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 	if (WARN(!(caps & ENG_CAP_PRESENT), "setup_dma_engine() called for DMA Engine at %p which isn't present in hardware!\n", eng))
 		return -ENXIO;
 
-	if (caps & ENG_CAP_DIRECTION){
+	if (caps & ENG_CAP_DIRECTION) {
 		eng->dir = DMA_FROM_DEVICE;
 	} else {
 		eng->dir = DMA_TO_DEVICE;
@@ -108,7 +108,7 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 	eng->desc_pool = dma_pool_create("KPC DMA Descriptors", &eng->pldev->dev, sizeof(struct kpc_dma_descriptor), DMA_DESC_ALIGNMENT, 4096);
 
 	eng->desc_pool_first = dma_pool_alloc(eng->desc_pool, GFP_KERNEL | GFP_DMA, &head_handle);
-	if (!eng->desc_pool_first){
+	if (!eng->desc_pool_first) {
 		dev_err(&eng->pldev->dev, "setup_dma_engine: couldn't allocate desc_pool_first!\n");
 		dma_pool_destroy(eng->desc_pool);
 		return -ENOMEM;
@@ -118,7 +118,7 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 	clear_desc(eng->desc_pool_first);
 
 	cur = eng->desc_pool_first;
-	for (i = 1 ; i < eng->desc_pool_cnt ; i++){
+	for (i = 1 ; i < eng->desc_pool_cnt ; i++) {
 		next = dma_pool_alloc(eng->desc_pool, GFP_KERNEL | GFP_DMA, &next_handle);
 		if (next == NULL)
 			goto done_alloc;
@@ -144,7 +144,7 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 
 	// Grab IRQ line
 	rv = request_irq(eng->irq, ndd_irq_handler, IRQF_SHARED, KP_DRIVER_NAME_DMA_CONTROLLER, eng);
-	if (rv){
+	if (rv) {
 		dev_err(&eng->pldev->dev, "setup_dma_engine: failed to request_irq: %d\n", rv);
 		return rv;
 	}
@@ -166,8 +166,8 @@ void  stop_dma_engine(struct kpc_dma_device *eng)
 
 	// Wait for descriptor engine to finish current operaion
 	timeout = jiffies + (HZ / 2);
-	while (GetEngineControl(eng) & ENG_CTL_DMA_RUNNING){
-		if (time_after(jiffies, timeout)){
+	while (GetEngineControl(eng) & ENG_CTL_DMA_RUNNING) {
+		if (time_after(jiffies, timeout)) {
 			dev_crit(&eng->pldev->dev, "DMA_RUNNING still asserted!\n");
 			break;
 		}
@@ -178,8 +178,8 @@ void  stop_dma_engine(struct kpc_dma_device *eng)
 
 	// Wait for reset request to be processed
 	timeout = jiffies + (HZ / 2);
-	while (GetEngineControl(eng) & (ENG_CTL_DMA_RUNNING | ENG_CTL_DMA_RESET_REQUEST)){
-		if (time_after(jiffies, timeout)){
+	while (GetEngineControl(eng) & (ENG_CTL_DMA_RUNNING | ENG_CTL_DMA_RESET_REQUEST)) {
+		if (time_after(jiffies, timeout)) {
 			dev_crit(&eng->pldev->dev, "ENG_CTL_DMA_RESET_REQUEST still asserted!\n");
 			break;
 		}
@@ -190,8 +190,8 @@ void  stop_dma_engine(struct kpc_dma_device *eng)
 
 	// And wait for reset to complete
 	timeout = jiffies + (HZ / 2);
-	while (GetEngineControl(eng) & ENG_CTL_DMA_RESET){
-		if (time_after(jiffies, timeout)){
+	while (GetEngineControl(eng) & ENG_CTL_DMA_RESET) {
+		if (time_after(jiffies, timeout)) {
 			dev_crit(&eng->pldev->dev, "DMA_RESET still asserted!\n");
 			break;
 		}
@@ -217,7 +217,7 @@ void  destroy_dma_engine(struct kpc_dma_device *eng)
 	cur = eng->desc_pool_first;
 	cur_handle = eng->desc_pool_first->MyDMAAddr;
 
-	for (i = 0 ; i < eng->desc_pool_cnt ; i++){
+	for (i = 0 ; i < eng->desc_pool_cnt ; i++) {
 		struct kpc_dma_descriptor *next = cur->Next;
 		dma_addr_t next_handle = cur->DescNextDescPtr;
 		dma_pool_free(eng->desc_pool, cur, cur_handle);
@@ -237,7 +237,7 @@ int  count_descriptors_available(struct kpc_dma_device *eng)
 {
 	u32 count = 0;
 	struct kpc_dma_descriptor *cur = eng->desc_next;
-	while (cur != eng->desc_completed){
+	while (cur != eng->desc_completed) {
 		BUG_ON(cur == NULL);
 		count++;
 		cur = cur->Next;

commit 20fe99222dd33e8f92e9e33c9fa231145145ce33
Author: Vandana BN <bnvandana@gmail.com>
Date:   Mon May 13 19:13:21 2019 +0530

    Staging: kpc2000: kpc_dma: Resolve space errors around pointers and function declarations reported by checkpatch.
    
    This patch resolves below errors reported by checkpatch
    ERROR: "(foo*)" should be "(foo *)"
    ERROR: "foo * bar" should be "foo *bar"
    ERROR: "foo __init  bar" should be "foo __init bar"
    ERROR: "foo __exit  bar" should be "foo __exit bar"
    
    Signed-off-by: Vandana BN <bnvandana@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc_dma/dma.c b/drivers/staging/kpc2000/kpc_dma/dma.c
index ba987307d898..488b9b81debc 100644
--- a/drivers/staging/kpc2000/kpc_dma/dma.c
+++ b/drivers/staging/kpc2000/kpc_dma/dma.c
@@ -14,7 +14,7 @@
 static
 irqreturn_t  ndd_irq_handler(int irq, void *dev_id)
 {
-	struct kpc_dma_device *ldev = (struct kpc_dma_device*)dev_id;
+	struct kpc_dma_device *ldev = (struct kpc_dma_device *)dev_id;
 
 	if ((GetEngineControl(ldev) & ENG_CTL_IRQ_ACTIVE) || (ldev->desc_completed->MyDMAAddr != GetEngineCompletePtr(ldev)))
 		schedule_work(&ldev->irq_work);
@@ -85,8 +85,8 @@ void  start_dma_engine(struct kpc_dma_device *eng)
 int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 {
 	u32 caps;
-	struct kpc_dma_descriptor * cur;
-	struct kpc_dma_descriptor * next;
+	struct kpc_dma_descriptor *cur;
+	struct kpc_dma_descriptor *next;
 	dma_addr_t next_handle;
 	dma_addr_t head_handle;
 	unsigned int i;
@@ -208,7 +208,7 @@ void  stop_dma_engine(struct kpc_dma_device *eng)
 
 void  destroy_dma_engine(struct kpc_dma_device *eng)
 {
-	struct kpc_dma_descriptor * cur;
+	struct kpc_dma_descriptor *cur;
 	dma_addr_t cur_handle;
 	unsigned int i;
 

commit 0f7aa9d2447bbfef3637e74ff0ea6a1cf92b8f3e
Author: Vandana BN <bnvandana@gmail.com>
Date:   Mon May 13 19:13:20 2019 +0530

    Staging: kpc2000: kpc_dma: Resolve trailing whitespace error reported by checkpatch
    
    Resolve trailing whitespace error from checkpatch.pl
    ERROR: trailing whitespace
    
    Signed-off-by: Vandana BN <bnvandana@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc_dma/dma.c b/drivers/staging/kpc2000/kpc_dma/dma.c
index 6959bac11388..ba987307d898 100644
--- a/drivers/staging/kpc2000/kpc_dma/dma.c
+++ b/drivers/staging/kpc2000/kpc_dma/dma.c
@@ -15,10 +15,10 @@ static
 irqreturn_t  ndd_irq_handler(int irq, void *dev_id)
 {
 	struct kpc_dma_device *ldev = (struct kpc_dma_device*)dev_id;
-	
+
 	if ((GetEngineControl(ldev) & ENG_CTL_IRQ_ACTIVE) || (ldev->desc_completed->MyDMAAddr != GetEngineCompletePtr(ldev)))
 		schedule_work(&ldev->irq_work);
-	
+
 	return IRQ_HANDLED;
 }
 
@@ -28,42 +28,42 @@ void  ndd_irq_worker(struct work_struct *ws)
 	struct kpc_dma_descriptor *cur;
 	struct kpc_dma_device *eng = container_of(ws, struct kpc_dma_device, irq_work);
 	lock_engine(eng);
-	
+
 	if (GetEngineCompletePtr(eng) == 0)
 		goto out;
-	
+
 	if (eng->desc_completed->MyDMAAddr == GetEngineCompletePtr(eng))
 		goto out;
-	
+
 	cur = eng->desc_completed;
 	do {
 		cur = cur->Next;
 		dev_dbg(&eng->pldev->dev, "Handling completed descriptor %p (acd = %p)\n", cur, cur->acd);
 		BUG_ON(cur == eng->desc_next); // Ordering failure.
-		
+
 		if (cur->DescControlFlags & DMA_DESC_CTL_SOP){
 			eng->accumulated_bytes = 0;
 			eng->accumulated_flags = 0;
 		}
-		
+
 		eng->accumulated_bytes += cur->DescByteCount;
 		if (cur->DescStatusFlags & DMA_DESC_STS_ERROR)
 			eng->accumulated_flags |= ACD_FLAG_ENG_ACCUM_ERROR;
-		
+
 		if (cur->DescStatusFlags & DMA_DESC_STS_SHORT)
 			eng->accumulated_flags |= ACD_FLAG_ENG_ACCUM_SHORT;
-		
+
 		if (cur->DescControlFlags & DMA_DESC_CTL_EOP){
 			if (cur->acd)
 				transfer_complete_cb(cur->acd, eng->accumulated_bytes, eng->accumulated_flags | ACD_FLAG_DONE);
 		}
-		
+
 		eng->desc_completed = cur;
 	} while (cur->MyDMAAddr != GetEngineCompletePtr(eng));
-	
+
  out:
 	SetClearEngineControl(eng, ENG_CTL_IRQ_ACTIVE, 0);
-	
+
 	unlock_engine(eng);
 }
 
@@ -73,12 +73,12 @@ void  start_dma_engine(struct kpc_dma_device *eng)
 {
 	eng->desc_next       = eng->desc_pool_first;
 	eng->desc_completed  = eng->desc_pool_last;
-	
+
 	// Setup the engine pointer registers
 	SetEngineNextPtr(eng, eng->desc_pool_first);
 	SetEngineSWPtr(eng, eng->desc_pool_first);
 	ClearEngineCompletePtr(eng);
-	
+
 	WriteEngineControl(eng, ENG_CTL_DMA_ENABLE | ENG_CTL_IRQ_ENABLE);
 }
 
@@ -92,67 +92,67 @@ int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
 	unsigned int i;
 	int rv;
 	dev_dbg(&eng->pldev->dev, "Setting up DMA engine [%p]\n", eng);
-	
+
 	caps = GetEngineCapabilities(eng);
-	
+
 	if (WARN(!(caps & ENG_CAP_PRESENT), "setup_dma_engine() called for DMA Engine at %p which isn't present in hardware!\n", eng))
 		return -ENXIO;
-	
+
 	if (caps & ENG_CAP_DIRECTION){
 		eng->dir = DMA_FROM_DEVICE;
 	} else {
 		eng->dir = DMA_TO_DEVICE;
 	}
-	
+
 	eng->desc_pool_cnt = desc_cnt;
 	eng->desc_pool = dma_pool_create("KPC DMA Descriptors", &eng->pldev->dev, sizeof(struct kpc_dma_descriptor), DMA_DESC_ALIGNMENT, 4096);
-	
+
 	eng->desc_pool_first = dma_pool_alloc(eng->desc_pool, GFP_KERNEL | GFP_DMA, &head_handle);
 	if (!eng->desc_pool_first){
 		dev_err(&eng->pldev->dev, "setup_dma_engine: couldn't allocate desc_pool_first!\n");
 		dma_pool_destroy(eng->desc_pool);
 		return -ENOMEM;
 	}
-	
+
 	eng->desc_pool_first->MyDMAAddr = head_handle;
 	clear_desc(eng->desc_pool_first);
-	
+
 	cur = eng->desc_pool_first;
 	for (i = 1 ; i < eng->desc_pool_cnt ; i++){
 		next = dma_pool_alloc(eng->desc_pool, GFP_KERNEL | GFP_DMA, &next_handle);
 		if (next == NULL)
 			goto done_alloc;
-		
+
 		clear_desc(next);
 		next->MyDMAAddr = next_handle;
-		
+
 		cur->DescNextDescPtr = next_handle;
 		cur->Next = next;
 		cur = next;
 	}
-	
+
  done_alloc:
 	// Link the last descriptor back to the first, so it's a circular linked list
 	cur->Next = eng->desc_pool_first;
 	cur->DescNextDescPtr = eng->desc_pool_first->MyDMAAddr;
-	
+
 	eng->desc_pool_last = cur;
 	eng->desc_completed = eng->desc_pool_last;
-	
+
 	// Setup work queue
 	INIT_WORK(&eng->irq_work, ndd_irq_worker);
-	
+
 	// Grab IRQ line
 	rv = request_irq(eng->irq, ndd_irq_handler, IRQF_SHARED, KP_DRIVER_NAME_DMA_CONTROLLER, eng);
 	if (rv){
 		dev_err(&eng->pldev->dev, "setup_dma_engine: failed to request_irq: %d\n", rv);
 		return rv;
 	}
-	
+
 	// Turn on the engine!
 	start_dma_engine(eng);
 	unlock_engine(eng);
-	
+
 	return 0;
 }
 
@@ -160,10 +160,10 @@ void  stop_dma_engine(struct kpc_dma_device *eng)
 {
 	unsigned long timeout;
 	dev_dbg(&eng->pldev->dev, "Destroying DMA engine [%p]\n", eng);
-	
+
 	// Disable the descriptor engine
 	WriteEngineControl(eng, 0);
-	
+
 	// Wait for descriptor engine to finish current operaion
 	timeout = jiffies + (HZ / 2);
 	while (GetEngineControl(eng) & ENG_CTL_DMA_RUNNING){
@@ -172,10 +172,10 @@ void  stop_dma_engine(struct kpc_dma_device *eng)
 			break;
 		}
 	}
-	
+
 	// Request a reset
 	WriteEngineControl(eng, ENG_CTL_DMA_RESET_REQUEST);
-	
+
 	// Wait for reset request to be processed
 	timeout = jiffies + (HZ / 2);
 	while (GetEngineControl(eng) & (ENG_CTL_DMA_RUNNING | ENG_CTL_DMA_RESET_REQUEST)){
@@ -184,10 +184,10 @@ void  stop_dma_engine(struct kpc_dma_device *eng)
 			break;
 		}
 	}
-	
+
 	// Request a reset
 	WriteEngineControl(eng, ENG_CTL_DMA_RESET);
-	
+
 	// And wait for reset to complete
 	timeout = jiffies + (HZ / 2);
 	while (GetEngineControl(eng) & ENG_CTL_DMA_RESET){
@@ -196,12 +196,12 @@ void  stop_dma_engine(struct kpc_dma_device *eng)
 			break;
 		}
 	}
-	
+
 	// Clear any persistent bits just to make sure there is no residue from the reset
 	SetClearEngineControl(eng, (ENG_CTL_IRQ_ACTIVE | ENG_CTL_DESC_COMPLETE | ENG_CTL_DESC_ALIGN_ERR | ENG_CTL_DESC_FETCH_ERR | ENG_CTL_SW_ABORT_ERR | ENG_CTL_DESC_CHAIN_END | ENG_CTL_DMA_WAITING_PERSIST), 0);
-	
+
 	// Reset performance counters
-	
+
 	// Completely disable the engine
 	WriteEngineControl(eng, 0);
 }
@@ -211,12 +211,12 @@ void  destroy_dma_engine(struct kpc_dma_device *eng)
 	struct kpc_dma_descriptor * cur;
 	dma_addr_t cur_handle;
 	unsigned int i;
-	
+
 	stop_dma_engine(eng);
-	
+
 	cur = eng->desc_pool_first;
 	cur_handle = eng->desc_pool_first->MyDMAAddr;
-	
+
 	for (i = 0 ; i < eng->desc_pool_cnt ; i++){
 		struct kpc_dma_descriptor *next = cur->Next;
 		dma_addr_t next_handle = cur->DescNextDescPtr;
@@ -224,9 +224,9 @@ void  destroy_dma_engine(struct kpc_dma_device *eng)
 		cur_handle = next_handle;
 		cur = next;
 	}
-	
+
 	dma_pool_destroy(eng->desc_pool);
-	
+
 	free_irq(eng->irq, eng);
 }
 

commit 7df95299b94a63ec67a6389fc02dc25019a80ee8
Author: Matt Sickler <Matt.Sickler@daktronics.com>
Date:   Mon Apr 22 22:05:58 2019 +0000

    staging: kpc2000: Add DMA driver
    
    Add Daktronics DMA driver.  I've added the SPDX license identifiers, Kconfig
    entry, and cleaned up as many of the warnings as I could.
    
    The AIO support code will be removed in a future patch.
    
    Signed-off-by: Matt Sickler <matt.sickler@daktronics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc_dma/dma.c b/drivers/staging/kpc2000/kpc_dma/dma.c
new file mode 100644
index 000000000000..6959bac11388
--- /dev/null
+++ b/drivers/staging/kpc2000/kpc_dma/dma.c
@@ -0,0 +1,264 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <asm/io.h>
+#include <linux/export.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/rwsem.h>
+#include "kpc_dma_driver.h"
+
+/**********  IRQ Handlers  **********/
+static
+irqreturn_t  ndd_irq_handler(int irq, void *dev_id)
+{
+	struct kpc_dma_device *ldev = (struct kpc_dma_device*)dev_id;
+	
+	if ((GetEngineControl(ldev) & ENG_CTL_IRQ_ACTIVE) || (ldev->desc_completed->MyDMAAddr != GetEngineCompletePtr(ldev)))
+		schedule_work(&ldev->irq_work);
+	
+	return IRQ_HANDLED;
+}
+
+static
+void  ndd_irq_worker(struct work_struct *ws)
+{
+	struct kpc_dma_descriptor *cur;
+	struct kpc_dma_device *eng = container_of(ws, struct kpc_dma_device, irq_work);
+	lock_engine(eng);
+	
+	if (GetEngineCompletePtr(eng) == 0)
+		goto out;
+	
+	if (eng->desc_completed->MyDMAAddr == GetEngineCompletePtr(eng))
+		goto out;
+	
+	cur = eng->desc_completed;
+	do {
+		cur = cur->Next;
+		dev_dbg(&eng->pldev->dev, "Handling completed descriptor %p (acd = %p)\n", cur, cur->acd);
+		BUG_ON(cur == eng->desc_next); // Ordering failure.
+		
+		if (cur->DescControlFlags & DMA_DESC_CTL_SOP){
+			eng->accumulated_bytes = 0;
+			eng->accumulated_flags = 0;
+		}
+		
+		eng->accumulated_bytes += cur->DescByteCount;
+		if (cur->DescStatusFlags & DMA_DESC_STS_ERROR)
+			eng->accumulated_flags |= ACD_FLAG_ENG_ACCUM_ERROR;
+		
+		if (cur->DescStatusFlags & DMA_DESC_STS_SHORT)
+			eng->accumulated_flags |= ACD_FLAG_ENG_ACCUM_SHORT;
+		
+		if (cur->DescControlFlags & DMA_DESC_CTL_EOP){
+			if (cur->acd)
+				transfer_complete_cb(cur->acd, eng->accumulated_bytes, eng->accumulated_flags | ACD_FLAG_DONE);
+		}
+		
+		eng->desc_completed = cur;
+	} while (cur->MyDMAAddr != GetEngineCompletePtr(eng));
+	
+ out:
+	SetClearEngineControl(eng, ENG_CTL_IRQ_ACTIVE, 0);
+	
+	unlock_engine(eng);
+}
+
+
+/**********  DMA Engine Init/Teardown  **********/
+void  start_dma_engine(struct kpc_dma_device *eng)
+{
+	eng->desc_next       = eng->desc_pool_first;
+	eng->desc_completed  = eng->desc_pool_last;
+	
+	// Setup the engine pointer registers
+	SetEngineNextPtr(eng, eng->desc_pool_first);
+	SetEngineSWPtr(eng, eng->desc_pool_first);
+	ClearEngineCompletePtr(eng);
+	
+	WriteEngineControl(eng, ENG_CTL_DMA_ENABLE | ENG_CTL_IRQ_ENABLE);
+}
+
+int  setup_dma_engine(struct kpc_dma_device *eng, u32 desc_cnt)
+{
+	u32 caps;
+	struct kpc_dma_descriptor * cur;
+	struct kpc_dma_descriptor * next;
+	dma_addr_t next_handle;
+	dma_addr_t head_handle;
+	unsigned int i;
+	int rv;
+	dev_dbg(&eng->pldev->dev, "Setting up DMA engine [%p]\n", eng);
+	
+	caps = GetEngineCapabilities(eng);
+	
+	if (WARN(!(caps & ENG_CAP_PRESENT), "setup_dma_engine() called for DMA Engine at %p which isn't present in hardware!\n", eng))
+		return -ENXIO;
+	
+	if (caps & ENG_CAP_DIRECTION){
+		eng->dir = DMA_FROM_DEVICE;
+	} else {
+		eng->dir = DMA_TO_DEVICE;
+	}
+	
+	eng->desc_pool_cnt = desc_cnt;
+	eng->desc_pool = dma_pool_create("KPC DMA Descriptors", &eng->pldev->dev, sizeof(struct kpc_dma_descriptor), DMA_DESC_ALIGNMENT, 4096);
+	
+	eng->desc_pool_first = dma_pool_alloc(eng->desc_pool, GFP_KERNEL | GFP_DMA, &head_handle);
+	if (!eng->desc_pool_first){
+		dev_err(&eng->pldev->dev, "setup_dma_engine: couldn't allocate desc_pool_first!\n");
+		dma_pool_destroy(eng->desc_pool);
+		return -ENOMEM;
+	}
+	
+	eng->desc_pool_first->MyDMAAddr = head_handle;
+	clear_desc(eng->desc_pool_first);
+	
+	cur = eng->desc_pool_first;
+	for (i = 1 ; i < eng->desc_pool_cnt ; i++){
+		next = dma_pool_alloc(eng->desc_pool, GFP_KERNEL | GFP_DMA, &next_handle);
+		if (next == NULL)
+			goto done_alloc;
+		
+		clear_desc(next);
+		next->MyDMAAddr = next_handle;
+		
+		cur->DescNextDescPtr = next_handle;
+		cur->Next = next;
+		cur = next;
+	}
+	
+ done_alloc:
+	// Link the last descriptor back to the first, so it's a circular linked list
+	cur->Next = eng->desc_pool_first;
+	cur->DescNextDescPtr = eng->desc_pool_first->MyDMAAddr;
+	
+	eng->desc_pool_last = cur;
+	eng->desc_completed = eng->desc_pool_last;
+	
+	// Setup work queue
+	INIT_WORK(&eng->irq_work, ndd_irq_worker);
+	
+	// Grab IRQ line
+	rv = request_irq(eng->irq, ndd_irq_handler, IRQF_SHARED, KP_DRIVER_NAME_DMA_CONTROLLER, eng);
+	if (rv){
+		dev_err(&eng->pldev->dev, "setup_dma_engine: failed to request_irq: %d\n", rv);
+		return rv;
+	}
+	
+	// Turn on the engine!
+	start_dma_engine(eng);
+	unlock_engine(eng);
+	
+	return 0;
+}
+
+void  stop_dma_engine(struct kpc_dma_device *eng)
+{
+	unsigned long timeout;
+	dev_dbg(&eng->pldev->dev, "Destroying DMA engine [%p]\n", eng);
+	
+	// Disable the descriptor engine
+	WriteEngineControl(eng, 0);
+	
+	// Wait for descriptor engine to finish current operaion
+	timeout = jiffies + (HZ / 2);
+	while (GetEngineControl(eng) & ENG_CTL_DMA_RUNNING){
+		if (time_after(jiffies, timeout)){
+			dev_crit(&eng->pldev->dev, "DMA_RUNNING still asserted!\n");
+			break;
+		}
+	}
+	
+	// Request a reset
+	WriteEngineControl(eng, ENG_CTL_DMA_RESET_REQUEST);
+	
+	// Wait for reset request to be processed
+	timeout = jiffies + (HZ / 2);
+	while (GetEngineControl(eng) & (ENG_CTL_DMA_RUNNING | ENG_CTL_DMA_RESET_REQUEST)){
+		if (time_after(jiffies, timeout)){
+			dev_crit(&eng->pldev->dev, "ENG_CTL_DMA_RESET_REQUEST still asserted!\n");
+			break;
+		}
+	}
+	
+	// Request a reset
+	WriteEngineControl(eng, ENG_CTL_DMA_RESET);
+	
+	// And wait for reset to complete
+	timeout = jiffies + (HZ / 2);
+	while (GetEngineControl(eng) & ENG_CTL_DMA_RESET){
+		if (time_after(jiffies, timeout)){
+			dev_crit(&eng->pldev->dev, "DMA_RESET still asserted!\n");
+			break;
+		}
+	}
+	
+	// Clear any persistent bits just to make sure there is no residue from the reset
+	SetClearEngineControl(eng, (ENG_CTL_IRQ_ACTIVE | ENG_CTL_DESC_COMPLETE | ENG_CTL_DESC_ALIGN_ERR | ENG_CTL_DESC_FETCH_ERR | ENG_CTL_SW_ABORT_ERR | ENG_CTL_DESC_CHAIN_END | ENG_CTL_DMA_WAITING_PERSIST), 0);
+	
+	// Reset performance counters
+	
+	// Completely disable the engine
+	WriteEngineControl(eng, 0);
+}
+
+void  destroy_dma_engine(struct kpc_dma_device *eng)
+{
+	struct kpc_dma_descriptor * cur;
+	dma_addr_t cur_handle;
+	unsigned int i;
+	
+	stop_dma_engine(eng);
+	
+	cur = eng->desc_pool_first;
+	cur_handle = eng->desc_pool_first->MyDMAAddr;
+	
+	for (i = 0 ; i < eng->desc_pool_cnt ; i++){
+		struct kpc_dma_descriptor *next = cur->Next;
+		dma_addr_t next_handle = cur->DescNextDescPtr;
+		dma_pool_free(eng->desc_pool, cur, cur_handle);
+		cur_handle = next_handle;
+		cur = next;
+	}
+	
+	dma_pool_destroy(eng->desc_pool);
+	
+	free_irq(eng->irq, eng);
+}
+
+
+
+/**********  Helper Functions  **********/
+int  count_descriptors_available(struct kpc_dma_device *eng)
+{
+	u32 count = 0;
+	struct kpc_dma_descriptor *cur = eng->desc_next;
+	while (cur != eng->desc_completed){
+		BUG_ON(cur == NULL);
+		count++;
+		cur = cur->Next;
+	}
+	return count;
+}
+
+void  clear_desc(struct kpc_dma_descriptor *desc)
+{
+	if (desc == NULL)
+		return;
+	desc->DescByteCount         = 0;
+	desc->DescStatusErrorFlags  = 0;
+	desc->DescStatusFlags       = 0;
+	desc->DescUserControlLS     = 0;
+	desc->DescUserControlMS     = 0;
+	desc->DescCardAddrLS        = 0;
+	desc->DescBufferByteCount   = 0;
+	desc->DescCardAddrMS        = 0;
+	desc->DescControlFlags      = 0;
+	desc->DescSystemAddrLS      = 0;
+	desc->DescSystemAddrMS      = 0;
+	desc->acd = NULL;
+}
