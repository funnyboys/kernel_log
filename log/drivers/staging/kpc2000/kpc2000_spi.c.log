commit 19a91ec87a1469189157ba3a9d327c730c372d8c
Author: Sergiu Cuciurean <sergiu.cuciurean@analog.com>
Date:   Wed Mar 4 09:37:46 2020 +0200

    staging: kpc2000: kpc2000_spi: Use new structure for SPI transfer delays
    
    In a recent change to the SPI subsystem in commit <bebcfd272df6>
    ("spi: introduce `delay` field for `spi_transfer` +
    spi_transfer_delay_exec()"), a new `delay` struct was added
    to replace the `delay_usecs`. This change replaces the current
    `delay_usecs` with `delay` for this driver.
    
    The `spi_transfer_delay_exec()` function [in the SPI framework] makes sure
    that both `delay_usecs` & `delay` are used (in this order to preserve
    backwards compatibility).
    
    Signed-off-by: Sergiu Cuciurean <sergiu.cuciurean@analog.com>
    Link: https://lore.kernel.org/r/20200304073746.19664-1-sergiu.cuciurean@analog.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 1c360daa703d..44017d523da5 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -386,8 +386,8 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 			}
 		}
 
-		if (transfer->delay_usecs)
-			udelay(transfer->delay_usecs);
+		if (transfer->delay.value)
+			ndelay(spi_delay_to_ns(&transfer->delay, transfer));
 	}
 
 	/* de-assert chip select to end the sequence */

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 8becf972af9c..1c360daa703d 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -464,7 +464,7 @@ kp_spi_probe(struct platform_device *pldev)
 		goto free_master;
 	}
 
-	kpspi->base = devm_ioremap_nocache(&pldev->dev, r->start,
+	kpspi->base = devm_ioremap(&pldev->dev, r->start,
 					   resource_size(r));
 
 	status = spi_register_master(master);

commit be1f84cf772b1598a4ed15b41e78d2967b97fbf5
Author: Chandra Annamaneni <chandra627@gmail.com>
Date:   Tue Oct 29 02:16:38 2019 -0700

    staging: KPC2000: kpc2000_spi.c: Fix style issues (Unnecessary parenthesis)
    
    Resolved: CHECK: Unnecessary parentheses around table[i]
    
    Signed-off-by: Chandra Annamaneni <chandra627@gmail.com>
    Link: https://lore.kernel.org/r/20191029091638.16101-4-chandra627@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 24de8d63f504..8becf972af9c 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -476,7 +476,7 @@ kp_spi_probe(struct platform_device *pldev)
 	/* register the slave boards */
 #define NEW_SPI_DEVICE_FROM_BOARD_INFO_TABLE(table) \
 	for (i = 0 ; i < ARRAY_SIZE(table) ; i++) { \
-		spi_new_device(master, &(table[i])); \
+		spi_new_device(master, &table[i]); \
 	}
 
 	switch ((drvdata->card_id & 0xFFFF0000) >> 16) {

commit e5f26f8548f943e7c70e6136d0ecd942a912a70e
Author: Chandra Annamaneni <chandra627@gmail.com>
Date:   Tue Oct 29 02:16:37 2019 -0700

    staging: KPC2000: kpc2000_spi.c: Fix style issues (alignment)
    
    Resolved: "CHECK: Alignment should match open parenthesis" from checkpatch
    
    Signed-off-by: Chandra Annamaneni <chandra627@gmail.com>
    Link: https://lore.kernel.org/r/20191029091638.16101-3-chandra627@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 929136cdc3e1..24de8d63f504 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -313,19 +313,19 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 		if (transfer->speed_hz > KP_SPI_CLK ||
 		    (len && !(rx_buf || tx_buf))) {
 			dev_dbg(kpspi->dev, "  transfer: %d Hz, %d %s%s, %d bpw\n",
-					transfer->speed_hz,
-					len,
-					tx_buf ? "tx" : "",
-					rx_buf ? "rx" : "",
-					transfer->bits_per_word);
+				transfer->speed_hz,
+				len,
+				tx_buf ? "tx" : "",
+				rx_buf ? "rx" : "",
+				transfer->bits_per_word);
 			dev_dbg(kpspi->dev, "  transfer -EINVAL\n");
 			return -EINVAL;
 		}
 		if (transfer->speed_hz &&
 		    transfer->speed_hz < (KP_SPI_CLK >> 15)) {
 			dev_dbg(kpspi->dev, "speed_hz %d below minimum %d Hz\n",
-					transfer->speed_hz,
-					KP_SPI_CLK >> 15);
+				transfer->speed_hz,
+				KP_SPI_CLK >> 15);
 			dev_dbg(kpspi->dev, "  speed_hz -EINVAL\n");
 			return -EINVAL;
 		}

commit c4d362420d75aff10596f876e3e66458bfdb84b5
Author: Chandra Annamaneni <chandra627@gmail.com>
Date:   Tue Oct 29 02:16:36 2019 -0700

    staging: KPC2000: kpc2000_spi.c: Fix style issues (misaligned brace)
    
    Resolved: ERROR: else should follow close brace '}'
    
    Signed-off-by: Chandra Annamaneni <chandra627@gmail.com>
    Link: https://lore.kernel.org/r/20191029091638.16101-2-chandra627@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 5712a88c8788..929136cdc3e1 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -226,8 +226,7 @@ kp_spi_txrx_pio(struct spi_device *spidev, struct spi_transfer *transfer)
 			kp_spi_write_reg(cs, KP_SPI_REG_TXDATA, val);
 			processed++;
 		}
-	}
-	else if (rx) {
+	} else if (rx) {
 		for (i = 0 ; i < c ; i++) {
 			char test = 0;
 

commit 25ec44ebdc1ab930965b266b2717a2e56249d7bb
Author: Chandra Annamaneni <chandra627@gmail.com>
Date:   Tue Oct 29 02:16:35 2019 -0700

    staging: KPC2000: kpc2000_spi.c: Fix style issues (missing blank line)
    
    Resolved: "CHECK: Please use a blank line after.." from checkpatch.pl
    
    Signed-off-by: Chandra Annamaneni <chandra627@gmail.com>
    Link: https://lore.kernel.org/r/20191029091638.16101-1-chandra627@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 6ba94b0131da..5712a88c8788 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -50,6 +50,7 @@ static struct flash_platform_data p2kr0_spi0_pdata = {
 	.nr_parts =	ARRAY_SIZE(p2kr0_spi0_parts),
 	.parts =	p2kr0_spi0_parts,
 };
+
 static struct flash_platform_data p2kr0_spi1_pdata = {
 	.name =		"SPI1",
 	.nr_parts =	ARRAY_SIZE(p2kr0_spi1_parts),

commit c0981afd8cd6e7176b4b9fe2186087695463ebde
Author: Wambui Karuga <wambui.karugax@gmail.com>
Date:   Wed Oct 9 20:07:03 2019 +0300

    staging: kpc2000: Remove unnecessary return variable
    
    Remove unnecessary variable `val` in kp_spi_read_reg() that only holds
    the return value from readq().
    Issue found by coccinelle using the script:
    
    @@
    local idexpression ret;
    expression e;
    @@
    
    -ret =
    +return
         e;
    -return ret;
    
    Signed-off-by: Wambui Karuga <wambui.karugax@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Link: https://lore.kernel.org/r/20191009170703.GA2869@wambui
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 3be33c450cab..6ba94b0131da 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -162,14 +162,12 @@ union kp_spi_ffctrl {
 kp_spi_read_reg(struct kp_spi_controller_state *cs, int idx)
 {
 	u64 __iomem *addr = cs->base;
-	u64 val;
 
 	addr += idx;
 	if ((idx == KP_SPI_REG_CONFIG) && (cs->conf_cache >= 0))
 		return cs->conf_cache;
 
-	val = readq(addr);
-	return val;
+	return readq(addr);
 }
 
 	static inline void

commit d59381d639af22da6eb49c5d851faf15feb6b462
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Thu Jul 11 22:07:26 2019 +0800

    staging: kpc2000: kpc_spi: Remove unnecessary null check before kfree
    
    A null check before a kfree is redundant, so remove it.
    This is detected by coccinelle.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Link: https://lore.kernel.org/r/20190711140726.46732-1-yuehaibing@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 35ac1d7070b3..3be33c450cab 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -412,8 +412,7 @@ kp_spi_cleanup(struct spi_device *spidev)
 {
 	struct kp_spi_controller_state *cs = spidev->controller_state;
 
-	if (cs)
-		kfree(cs);
+	kfree(cs);
 }
 
 /******************

commit 209ff937b0d4d70bb054890a8c1722cec3fc70fe
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu Jul 4 08:08:09 2019 +0200

    staging: kpc2000: simplify comparison to NULL in kpc2000_spi.c
    
    Fixes checkpatch warning "Comparison to NULL could be written [...]".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Link: https://lore.kernel.org/r/20190704060811.10330-2-simon@nikanor.nu
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 009dec2f4641..35ac1d7070b3 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -436,7 +436,7 @@ kp_spi_probe(struct platform_device *pldev)
 	}
 
 	master = spi_alloc_master(&pldev->dev, sizeof(struct kp_spi));
-	if (master == NULL) {
+	if (!master) {
 		dev_err(&pldev->dev, "%s: master allocation failed\n",
 			__func__);
 		return -ENOMEM;
@@ -460,7 +460,7 @@ kp_spi_probe(struct platform_device *pldev)
 		master->bus_num = pldev->id;
 
 	r = platform_get_resource(pldev, IORESOURCE_MEM, 0);
-	if (r == NULL) {
+	if (!r) {
 		dev_err(&pldev->dev, "%s: Unable to get platform resources\n",
 			__func__);
 		status = -ENODEV;

commit 6a2ac8d4bf91d56c6335db0fc0585b9788397a3b
Author: Simon Sandström <simon@nikanor.nu>
Date:   Mon Jul 1 11:18:19 2019 +0200

    staging: kpc2000: fix brace issues in kpc2000_spi.c
    
    Fixes issues found by checkpatch:
    
    - "WARNING: braces {} are not necessary for single statement blocks"
    - "WARNING: braces {} are not necessary for any arm of this statement"
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Link: https://lore.kernel.org/r/20190701091819.18528-1-simon@nikanor.nu
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 021cc859feed..009dec2f4641 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -165,9 +165,9 @@ kp_spi_read_reg(struct kp_spi_controller_state *cs, int idx)
 	u64 val;
 
 	addr += idx;
-	if ((idx == KP_SPI_REG_CONFIG) && (cs->conf_cache >= 0)) {
+	if ((idx == KP_SPI_REG_CONFIG) && (cs->conf_cache >= 0))
 		return cs->conf_cache;
-	}
+
 	val = readq(addr);
 	return val;
 }
@@ -192,11 +192,10 @@ kp_spi_wait_for_reg_bit(struct kp_spi_controller_state *cs, int idx,
 	timeout = jiffies + msecs_to_jiffies(1000);
 	while (!(kp_spi_read_reg(cs, idx) & bit)) {
 		if (time_after(jiffies, timeout)) {
-			if (!(kp_spi_read_reg(cs, idx) & bit)) {
+			if (!(kp_spi_read_reg(cs, idx) & bit))
 				return -ETIMEDOUT;
-			} else {
+			else
 				return 0;
-			}
 		}
 		cpu_relax();
 	}
@@ -269,9 +268,8 @@ kp_spi_setup(struct spi_device *spidev)
 	cs = spidev->controller_state;
 	if (!cs) {
 		cs = kzalloc(sizeof(*cs), GFP_KERNEL);
-		if (!cs) {
+		if (!cs)
 			return -ENOMEM;
-		}
 		cs->base = kpspi->base;
 		cs->conf_cache = -1;
 		spidev->controller_state = cs;
@@ -305,9 +303,8 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 	cs = spidev->controller_state;
 
 	/* reject invalid messages and transfers */
-	if (list_empty(&m->transfers)) {
+	if (list_empty(&m->transfers))
 		return -EINVAL;
-	}
 
 	/* validate input */
 	list_for_each_entry(transfer, &m->transfers, transfer_list) {
@@ -365,17 +362,14 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 			sc.reg = kp_spi_read_reg(cs, KP_SPI_REG_CONFIG);
 
 			/* ...direction */
-			if (transfer->tx_buf) {
+			if (transfer->tx_buf)
 				sc.bitfield.trm = KP_SPI_REG_CONFIG_TRM_TX;
-			}
-			else if (transfer->rx_buf) {
+			else if (transfer->rx_buf)
 				sc.bitfield.trm = KP_SPI_REG_CONFIG_TRM_RX;
-			}
 
 			/* ...word length */
-			if (transfer->bits_per_word) {
+			if (transfer->bits_per_word)
 				word_len = transfer->bits_per_word;
-			}
 			sc.bitfield.wl = word_len - 1;
 
 			/* ...chip select */
@@ -394,9 +388,8 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 			}
 		}
 
-		if (transfer->delay_usecs) {
+		if (transfer->delay_usecs)
 			udelay(transfer->delay_usecs);
-		}
 	}
 
 	/* de-assert chip select to end the sequence */
@@ -419,9 +412,8 @@ kp_spi_cleanup(struct spi_device *spidev)
 {
 	struct kp_spi_controller_state *cs = spidev->controller_state;
 
-	if (cs) {
+	if (cs)
 		kfree(cs);
-	}
 }
 
 /******************
@@ -464,9 +456,8 @@ kp_spi_probe(struct platform_device *pldev)
 	kpspi->dev = &pldev->dev;
 
 	master->num_chipselect = 4;
-	if (pldev->id != -1) {
+	if (pldev->id != -1)
 		master->bus_num = pldev->id;
-	}
 
 	r = platform_get_resource(pldev, IORESOURCE_MEM, 0);
 	if (r == NULL) {

commit d19b75b05178e1e1483ccd9bd38fce930a0204d2
Author: Fabian Krueger <fabian.krueger@fau.de>
Date:   Wed Jun 26 09:35:26 2019 +0200

    staging: kpc2000: remove needless 'break'
    
    The unconditioned jump will prohibit to ever reach the break-statement.
    Deleting this needless statement, the code becomes more understandable.
    
    Signed-off-by: Fabian Krueger <fabian.krueger@fau.de>
    Signed-off-by: Michael Scheiderer <michael.scheiderer@fau.de>
    Cc: <linux-kernel@i4.cs.fau.de>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 68b01e2420d8..021cc859feed 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -498,7 +498,6 @@ kp_spi_probe(struct platform_device *pldev)
 	default:
 		dev_err(&pldev->dev, "Unknown hardware, cant know what partition table to use!\n");
 		goto free_master;
-		break;
 	}
 
 	return status;

commit 39e828584b390e612958e20ca308957001fcf854
Author: Fabian Krueger <fabian.krueger@fau.de>
Date:   Wed Jun 26 09:35:25 2019 +0200

    staging: kpc2000: introduce __func__
    
    Instead of using the function name hard coded as string, using __func__
    and the '%s'-placeholder will always give the current name of the
    function. When renaming a function, the debugging-messages won't have to
    be rewritten.
    
    Signed-off-by: Fabian Krueger <fabian.krueger@fau.de>
    Signed-off-by: Michael Scheiderer <michael.scheiderer@fau.de>
    Cc: <linux-kernel@i4.cs.fau.de>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 8a6fb2bde94f..68b01e2420d8 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -439,13 +439,14 @@ kp_spi_probe(struct platform_device *pldev)
 
 	drvdata = pldev->dev.platform_data;
 	if (!drvdata) {
-		dev_err(&pldev->dev, "kp_spi_probe: platform_data is NULL!\n");
+		dev_err(&pldev->dev, "%s: platform_data is NULL\n", __func__);
 		return -ENODEV;
 	}
 
 	master = spi_alloc_master(&pldev->dev, sizeof(struct kp_spi));
 	if (master == NULL) {
-		dev_err(&pldev->dev, "kp_spi_probe: master allocation failed\n");
+		dev_err(&pldev->dev, "%s: master allocation failed\n",
+			__func__);
 		return -ENOMEM;
 	}
 
@@ -469,7 +470,8 @@ kp_spi_probe(struct platform_device *pldev)
 
 	r = platform_get_resource(pldev, IORESOURCE_MEM, 0);
 	if (r == NULL) {
-		dev_err(&pldev->dev, "kp_spi_probe: Unable to get platform resources\n");
+		dev_err(&pldev->dev, "%s: Unable to get platform resources\n",
+			__func__);
 		status = -ENODEV;
 		goto free_master;
 	}

commit 69086fb80d09bf50a649cd74f28a44f60f420a42
Author: Fabian Krueger <fabian.krueger@fau.de>
Date:   Wed Jun 26 09:35:24 2019 +0200

    staging: kpc2000: introduce 'unsigned int'
    
    Replaced 'unsigned' with it's equivalent 'unsigned int' to reduce
    confusion while reading the code.
    
    Signed-off-by: Fabian Krueger <fabian.krueger@fau.de>
    Signed-off-by: Michael Scheiderer <michael.scheiderer@fau.de>
    Cc: <linux-kernel@i4.cs.fau.de>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 7800d647db50..8a6fb2bde94f 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -313,7 +313,7 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 	list_for_each_entry(transfer, &m->transfers, transfer_list) {
 		const void *tx_buf = transfer->tx_buf;
 		void       *rx_buf = transfer->rx_buf;
-		unsigned    len = transfer->len;
+		unsigned int len = transfer->len;
 
 		if (transfer->speed_hz > KP_SPI_CLK ||
 		    (len && !(rx_buf || tx_buf))) {
@@ -359,7 +359,7 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 		/* transfer */
 		if (transfer->len) {
 			unsigned int word_len = spidev->bits_per_word;
-			unsigned count;
+			unsigned int count;
 
 			/* set up the transfer... */
 			sc.reg = kp_spi_read_reg(cs, KP_SPI_REG_CONFIG);

commit ecb87018bb76f4b9ba9081aa8fdbaa908456e652
Author: Fabian Krueger <fabian.krueger@fau.de>
Date:   Wed Jun 26 09:35:21 2019 +0200

    staging: kpc2000: introduce usage of __packed
    
    Replaced __attribute__((packed)) with __packed. Both ways of attributing
    are equivalent, but being shorter, __packed should be preferred.
    This refactoring makes the core more readable.
    
    Signed-off-by: Fabian Krueger <fabian.krueger@fau.de>
    Signed-off-by: Michael Scheiderer <michael.scheiderer@fau.de>
    Cc: <linux-kernel@i4.cs.fau.de>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 30073440189e..7800d647db50 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -114,7 +114,7 @@ struct kp_spi_controller_state {
 
 union kp_spi_config {
 	/* use this to access individual elements */
-	struct __attribute__((packed)) spi_config_bitfield {
+	struct __packed spi_config_bitfield {
 		unsigned int pha       : 1; /* spim_clk Phase      */
 		unsigned int pol       : 1; /* spim_clk Polarity   */
 		unsigned int epol      : 1; /* spim_csx Polarity   */
@@ -133,7 +133,7 @@ union kp_spi_config {
 };
 
 union kp_spi_status {
-	struct __attribute__((packed)) spi_status_bitfield {
+	struct __packed spi_status_bitfield {
 		unsigned int rx    :  1; /* Rx Status       */
 		unsigned int tx    :  1; /* Tx Status       */
 		unsigned int eo    :  1; /* End of Transfer */
@@ -148,7 +148,7 @@ union kp_spi_status {
 };
 
 union kp_spi_ffctrl {
-	struct __attribute__((packed)) spi_ffctrl_bitfield {
+	struct __packed spi_ffctrl_bitfield {
 		unsigned int ffstart :  1; /* FIFO Start */
 		unsigned int         : 31;
 	} bitfield;

commit c70c7284a058b0c1855d945027d0bb39acd21f5d
Author: Fabian Krueger <fabian.krueger@fau.de>
Date:   Wed Jun 26 09:35:20 2019 +0200

    staging: kpc2000: blank lines after declaration
    
    After the declarations in a function, there should be a blank line, so
    that the declaration part is visibly separated from the rest.
    This refactoring makes the code more readable.
    
    Signed-off-by: Fabian Krueger <fabian.krueger@fau.de>
    Signed-off-by: Michael Scheiderer <michael.scheiderer@fau.de>
    Cc: <linux-kernel@i4.cs.fau.de>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 6812d27764e2..30073440189e 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -176,6 +176,7 @@ kp_spi_read_reg(struct kp_spi_controller_state *cs, int idx)
 kp_spi_write_reg(struct kp_spi_controller_state *cs, int idx, u64 val)
 {
 	u64 __iomem *addr = cs->base;
+
 	addr += idx;
 	writeq(val, addr);
 	if (idx == KP_SPI_REG_CONFIG)
@@ -187,6 +188,7 @@ kp_spi_wait_for_reg_bit(struct kp_spi_controller_state *cs, int idx,
 			unsigned long bit)
 {
 	unsigned long timeout;
+
 	timeout = jiffies + msecs_to_jiffies(1000);
 	while (!(kp_spi_read_reg(cs, idx) & bit)) {
 		if (time_after(jiffies, timeout)) {
@@ -416,6 +418,7 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 kp_spi_cleanup(struct spi_device *spidev)
 {
 	struct kp_spi_controller_state *cs = spidev->controller_state;
+
 	if (cs) {
 		kfree(cs);
 	}
@@ -507,6 +510,7 @@ kp_spi_probe(struct platform_device *pldev)
 kp_spi_remove(struct platform_device *pldev)
 {
 	struct spi_master *master = platform_get_drvdata(pldev);
+
 	spi_unregister_master(master);
 	return 0;
 }

commit 06ed6146d6c1f647c40f24c195f8959687e3876b
Author: Fabian Krueger <fabian.krueger@fau.de>
Date:   Wed Jun 26 09:35:19 2019 +0200

    staging: kpc2000: add line breaks
    
    To fix some checkpatch-warnings some lines of this module had to be
    shortened so that they do not exceed 80 characters per line.
    This refactoring makes the code more readable.
    
    Signed-off-by: Fabian Krueger <fabian.krueger@fau.de>
    Signed-off-by: Michael Scheiderer <michael.scheiderer@fau.de>
    Cc: <linux-kernel@i4.cs.fau.de>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 98484fbb9d2e..6812d27764e2 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -36,6 +36,7 @@ static struct mtd_partition p2kr0_spi0_parts[] = {
 	{ .name = "SLOT_3",	.size = 7798784,		.offset = MTDPART_OFS_NXTBLK},
 	{ .name = "CS0_EXTRA",	.size = MTDPART_SIZ_FULL,	.offset = MTDPART_OFS_NXTBLK},
 };
+
 static struct mtd_partition p2kr0_spi1_parts[] = {
 	{ .name = "SLOT_4",	.size = 7798784,		.offset = 0,                },
 	{ .name = "SLOT_5",	.size = 7798784,		.offset = MTDPART_OFS_NXTBLK},
@@ -182,7 +183,8 @@ kp_spi_write_reg(struct kp_spi_controller_state *cs, int idx, u64 val)
 }
 
 	static int
-kp_spi_wait_for_reg_bit(struct kp_spi_controller_state *cs, int idx, unsigned long bit)
+kp_spi_wait_for_reg_bit(struct kp_spi_controller_state *cs, int idx,
+			unsigned long bit)
 {
 	unsigned long timeout;
 	timeout = jiffies + msecs_to_jiffies(1000);
@@ -207,6 +209,7 @@ kp_spi_txrx_pio(struct spi_device *spidev, struct spi_transfer *transfer)
 	unsigned int c = count;
 
 	int i;
+	int res;
 	u8 *rx       = transfer->rx_buf;
 	const u8 *tx = transfer->tx_buf;
 	int processed = 0;
@@ -215,9 +218,10 @@ kp_spi_txrx_pio(struct spi_device *spidev, struct spi_transfer *transfer)
 		for (i = 0 ; i < c ; i++) {
 			char val = *tx++;
 
-			if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_TXS) < 0) {
+			res = kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS,
+						      KP_SPI_REG_STATUS_TXS);
+			if (res < 0)
 				goto out;
-			}
 
 			kp_spi_write_reg(cs, KP_SPI_REG_TXDATA, val);
 			processed++;
@@ -228,10 +232,10 @@ kp_spi_txrx_pio(struct spi_device *spidev, struct spi_transfer *transfer)
 			char test = 0;
 
 			kp_spi_write_reg(cs, KP_SPI_REG_TXDATA, 0x00);
-
-			if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_RXS) < 0) {
+			res = kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS,
+						      KP_SPI_REG_STATUS_RXS);
+			if (res < 0)
 				goto out;
-			}
 
 			test = kp_spi_read_reg(cs, KP_SPI_REG_RXDATA);
 			*rx++ = test;
@@ -239,8 +243,10 @@ kp_spi_txrx_pio(struct spi_device *spidev, struct spi_transfer *transfer)
 		}
 	}
 
-	if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_EOT) < 0) {
-		//TODO: Figure out how to abort transaction??  This has never happened in practice though...
+	if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS,
+				    KP_SPI_REG_STATUS_EOT) < 0) {
+		//TODO: Figure out how to abort transaction??
+		//Ths has never happened in practice though...
 	}
 
 out:
@@ -307,7 +313,8 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 		void       *rx_buf = transfer->rx_buf;
 		unsigned    len = transfer->len;
 
-		if (transfer->speed_hz > KP_SPI_CLK || (len && !(rx_buf || tx_buf))) {
+		if (transfer->speed_hz > KP_SPI_CLK ||
+		    (len && !(rx_buf || tx_buf))) {
 			dev_dbg(kpspi->dev, "  transfer: %d Hz, %d %s%s, %d bpw\n",
 					transfer->speed_hz,
 					len,
@@ -317,7 +324,8 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 			dev_dbg(kpspi->dev, "  transfer -EINVAL\n");
 			return -EINVAL;
 		}
-		if (transfer->speed_hz && (transfer->speed_hz < (KP_SPI_CLK >> 15))) {
+		if (transfer->speed_hz &&
+		    transfer->speed_hz < (KP_SPI_CLK >> 15)) {
 			dev_dbg(kpspi->dev, "speed_hz %d below minimum %d Hz\n",
 					transfer->speed_hz,
 					KP_SPI_CLK >> 15);
@@ -332,14 +340,16 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 	kp_spi_write_reg(cs, KP_SPI_REG_CONFIG, sc.reg);
 
 	/* work */
-	if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_EOT) < 0) {
+	if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS,
+				    KP_SPI_REG_STATUS_EOT) < 0) {
 		dev_info(kpspi->dev, "EOT timed out\n");
 		goto out;
 	}
 
 	/* do the transfers for this message */
 	list_for_each_entry(transfer, &m->transfers, transfer_list) {
-		if (transfer->tx_buf == NULL && transfer->rx_buf == NULL && transfer->len) {
+		if (!transfer->tx_buf && !transfer->rx_buf &&
+		    transfer->len) {
 			status = -EINVAL;
 			goto error;
 		}

commit 8e590ef5b20ce7ba73ebf1a7cf27c9a431a8a8aa
Author: Simon Sandström <simon@nikanor.nu>
Date:   Tue Jun 25 10:41:28 2019 +0200

    staging: kpc2000: add missing spaces in kpc2000_spi.c
    
    Fixes checkpatch errors:
    - spaces required around that '=' (ctx:VxV)
    - space required before the open parenthesis '('
    - spaces preferred around that '-' (ctx:VxV)
    - space required before the open brace '{'
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index c3e5c1848f53..98484fbb9d2e 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -164,7 +164,7 @@ kp_spi_read_reg(struct kp_spi_controller_state *cs, int idx)
 	u64 val;
 
 	addr += idx;
-	if ((idx == KP_SPI_REG_CONFIG) && (cs->conf_cache >= 0)){
+	if ((idx == KP_SPI_REG_CONFIG) && (cs->conf_cache >= 0)) {
 		return cs->conf_cache;
 	}
 	val = readq(addr);
@@ -223,9 +223,9 @@ kp_spi_txrx_pio(struct spi_device *spidev, struct spi_transfer *transfer)
 			processed++;
 		}
 	}
-	else if(rx) {
+	else if (rx) {
 		for (i = 0 ; i < c ; i++) {
-			char test=0;
+			char test = 0;
 
 			kp_spi_write_reg(cs, KP_SPI_REG_TXDATA, 0x00);
 
@@ -261,7 +261,7 @@ kp_spi_setup(struct spi_device *spidev)
 	cs = spidev->controller_state;
 	if (!cs) {
 		cs = kzalloc(sizeof(*cs), GFP_KERNEL);
-		if(!cs) {
+		if (!cs) {
 			return -ENOMEM;
 		}
 		cs->base = kpspi->base;
@@ -364,7 +364,7 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 			if (transfer->bits_per_word) {
 				word_len = transfer->bits_per_word;
 			}
-			sc.bitfield.wl = word_len-1;
+			sc.bitfield.wl = word_len - 1;
 
 			/* ...chip select */
 			sc.bitfield.cs = spidev->chip_select;
@@ -425,7 +425,7 @@ kp_spi_probe(struct platform_device *pldev)
 	int i;
 
 	drvdata = pldev->dev.platform_data;
-	if (!drvdata){
+	if (!drvdata) {
 		dev_err(&pldev->dev, "kp_spi_probe: platform_data is NULL!\n");
 		return -ENODEV;
 	}
@@ -476,7 +476,7 @@ kp_spi_probe(struct platform_device *pldev)
 		spi_new_device(master, &(table[i])); \
 	}
 
-	switch ((drvdata->card_id & 0xFFFF0000) >> 16){
+	switch ((drvdata->card_id & 0xFFFF0000) >> 16) {
 	case PCI_DEVICE_ID_DAKTRONICS_KADOKA_P2KR0:
 		NEW_SPI_DEVICE_FROM_BOARD_INFO_TABLE(p2kr0_board_info);
 		break;

commit 991661e673f6150ebadf1236fd0013ccea082707
Author: Naoto Kobayashi <naoto.kobayashi4c@gmail.com>
Date:   Mon Jun 10 14:43:14 2019 +0900

    staging: kpc2000: remove extra white space in kpc2000_spi.c
    
    Since whitespace should not appear between asterisk and
    variable name in a declaration statement, remove it and
    fix checkpatch.pl error "foo * bar" should be "foo *bar".
    
    Signed-off-by: Naoto Kobayashi <naoto.kobayashi4c@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 28132e9e260d..c3e5c1848f53 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -496,7 +496,7 @@ kp_spi_probe(struct platform_device *pldev)
 	static int
 kp_spi_remove(struct platform_device *pldev)
 {
-	struct spi_master * master = platform_get_drvdata(pldev);
+	struct spi_master *master = platform_get_drvdata(pldev);
 	spi_unregister_master(master);
 	return 0;
 }

commit 17dcc588d42b3e24a8482c60759201f138700ec0
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Wed Jun 5 01:09:13 2019 +0000

    staging: kpc2000: kpc_spi: remove unnecessary cast in [read|write]_reg()
    
    The kpc_spi driver unnecessarily casts from a (u64 __iomem *) to a (void
    *) when invoking readq and writeq which both take a (void __iomem *) arg.
    There is no need for this cast, and it actually harms us by discarding
    the sparse cookie, __iomem. Make the driver stop performing this casting
    operation.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 4f517afc6239..28132e9e260d 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -167,7 +167,7 @@ kp_spi_read_reg(struct kp_spi_controller_state *cs, int idx)
 	if ((idx == KP_SPI_REG_CONFIG) && (cs->conf_cache >= 0)){
 		return cs->conf_cache;
 	}
-	val = readq((void*)addr);
+	val = readq(addr);
 	return val;
 }
 
@@ -176,7 +176,7 @@ kp_spi_write_reg(struct kp_spi_controller_state *cs, int idx, u64 val)
 {
 	u64 __iomem *addr = cs->base;
 	addr += idx;
-	writeq(val, (void*)addr);
+	writeq(val, addr);
 	if (idx == KP_SPI_REG_CONFIG)
 		cs->conf_cache = val;
 }

commit fbf476ea29cc7294586dcf0b89f22593458deb0d
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Wed Jun 5 01:09:12 2019 +0000

    staging: kpc2000: kpc_spi: remove unnecessary ulong repr of i/o addr
    
    The kpc_spi driver stashes off an unsigned long representation of the
    i/o mapping returned by devm_ioremap_nocache(). This is unnecessary, as
    the only use of the unsigned long repr is to eventually be re-cast to
    an (u64 __iomem *). Instead of casting the (void __iomem *) to an
    (unsigned long) then a (u64 __iomem *), just remove this intermediate
    step. As this intermediary is no longer used, also remove it from its
    structure.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 07b0327d8bef..4f517afc6239 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -103,7 +103,6 @@ static struct spi_board_info p2kr0_board_info[] = {
 struct kp_spi {
 	struct spi_master  *master;
 	u64 __iomem        *base;
-	unsigned long       phys;
 	struct device      *dev;
 };
 
@@ -462,9 +461,8 @@ kp_spi_probe(struct platform_device *pldev)
 		goto free_master;
 	}
 
-	kpspi->phys = (unsigned long)devm_ioremap_nocache(&pldev->dev, r->start,
-							  resource_size(r));
-	kpspi->base = (u64 __iomem *)kpspi->phys;
+	kpspi->base = devm_ioremap_nocache(&pldev->dev, r->start,
+					   resource_size(r));
 
 	status = spi_register_master(master);
 	if (status < 0) {

commit 77a91f4b68b09774ab4608348557efaf262a6428
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Wed Jun 5 01:09:11 2019 +0000

    staging: kpc2000: kpc_spi: remove unnecessary struct member chip_select
    
    The structure kp_spi_controller_state, defined in the kpc2000_spi
    driver, contains a member named chip_select which is never used after
    initialization. Therefore, it should be removed for simplicity's sake.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 61296335313b..07b0327d8bef 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -109,7 +109,6 @@ struct kp_spi {
 
 struct kp_spi_controller_state {
 	void __iomem   *base;
-	unsigned char   chip_select;
 	s64             conf_cache;
 };
 
@@ -267,7 +266,6 @@ kp_spi_setup(struct spi_device *spidev)
 			return -ENOMEM;
 		}
 		cs->base = kpspi->base;
-		cs->chip_select = spidev->chip_select;
 		cs->conf_cache = -1;
 		spidev->controller_state = cs;
 	}

commit dafcc4a54672875a155fb8272528820150043781
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Wed Jun 5 01:09:10 2019 +0000

    staging: kpc2000: kpc_spi: remove unnecessary struct member word_len
    
    The structure kp_spi_controller_state, defined in the kpc2000_spi
    driver, contains a member named word_len which is never used after
    initialization. Therefore, it should be removed for simplicity's sake.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 1d89cb3b861f..61296335313b 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -110,7 +110,6 @@ struct kp_spi {
 struct kp_spi_controller_state {
 	void __iomem   *base;
 	unsigned char   chip_select;
-	int             word_len;
 	s64             conf_cache;
 };
 
@@ -269,7 +268,6 @@ kp_spi_setup(struct spi_device *spidev)
 		}
 		cs->base = kpspi->base;
 		cs->chip_select = spidev->chip_select;
-		cs->word_len = spidev->bits_per_word;
 		cs->conf_cache = -1;
 		spidev->controller_state = cs;
 	}
@@ -369,7 +367,6 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 			if (transfer->bits_per_word) {
 				word_len = transfer->bits_per_word;
 			}
-			cs->word_len = word_len;
 			sc.bitfield.wl = word_len-1;
 
 			/* ...chip select */

commit d06ad04b7d8720c7793fc06d808e66ce8d3999f9
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Wed Jun 5 01:09:09 2019 +0000

    staging: kpc2000: kpc_spi: remove unnecessary struct member pin_dir
    
    The structure kpc_spi, defined in in the kpc2000_spi driver, contains
    a member named pin_dir which is never used after initialization.
    Therefore, it should be removed for simplicity's sake.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 20c396bcd904..1d89cb3b861f 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -105,7 +105,6 @@ struct kp_spi {
 	u64 __iomem        *base;
 	unsigned long       phys;
 	struct device      *dev;
-	unsigned int        pin_dir:1;
 };
 
 struct kp_spi_controller_state {
@@ -460,7 +459,6 @@ kp_spi_probe(struct platform_device *pldev)
 	if (pldev->id != -1) {
 		master->bus_num = pldev->id;
 	}
-	kpspi->pin_dir = 0;
 
 	r = platform_get_resource(pldev, IORESOURCE_MEM, 0);
 	if (r == NULL) {

commit 8b37865055fe26c33f01823b2a1bfa1b7c526152
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Wed Jun 5 01:09:08 2019 +0000

    staging: kpc2000: kpc_spi: remove unnecessary struct member phys
    
    The structure kp_spi_controller_state, defined in the kpc2000_spi
    driver, contains a member named phys which is never used after
    initialization. Therefore, it should be removed for simplicity's sake.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 32d3ec532e26..20c396bcd904 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -110,7 +110,6 @@ struct kp_spi {
 
 struct kp_spi_controller_state {
 	void __iomem   *base;
-	unsigned long   phys;
 	unsigned char   chip_select;
 	int             word_len;
 	s64             conf_cache;
@@ -270,7 +269,6 @@ kp_spi_setup(struct spi_device *spidev)
 			return -ENOMEM;
 		}
 		cs->base = kpspi->base;
-		cs->phys = kpspi->phys;
 		cs->chip_select = spidev->chip_select;
 		cs->word_len = spidev->bits_per_word;
 		cs->conf_cache = -1;

commit 677b993a574957975c95c1f01a06d695161e9832
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun Jun 2 15:58:37 2019 +0000

    staging: kpc2000: kpc_spi: use devm_* API to manage mapped I/O space
    
    The kpc_spi driver does not unmap its I/O space upon error cases in the
    probe() function or upon remove(). Make the driver clean up after itself
    more maintainably by migrating to using the managed resource API.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index b513432a26ed..32d3ec532e26 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -471,7 +471,8 @@ kp_spi_probe(struct platform_device *pldev)
 		goto free_master;
 	}
 
-	kpspi->phys = (unsigned long)ioremap_nocache(r->start, resource_size(r));
+	kpspi->phys = (unsigned long)devm_ioremap_nocache(&pldev->dev, r->start,
+							  resource_size(r));
 	kpspi->base = (u64 __iomem *)kpspi->phys;
 
 	status = spi_register_master(master);

commit 1914e9ebd362af679a4bf384e7960d47788d27e1
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun Jun 2 15:58:36 2019 +0000

    staging: kpc2000: kpc_spi: remove function kp_spi_bytes_per_word()
    
    The static function kp_spi_bytes_per_word() is defined in kpc2000_spi.c,
    but it is completely unused. As this function is unused, it can and
    should be removed.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 049b1e324031..b513432a26ed 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -162,20 +162,6 @@ union kp_spi_ffctrl {
 /***************
  * SPI Helpers *
  ***************/
-	static inline int
-kp_spi_bytes_per_word(int word_len)
-{
-	if (word_len <= 8){
-		return 1;
-	}
-	else if (word_len <= 16) {
-		return 2;
-	}
-	else { /* word_len <= 32 */
-		return 4;
-	}
-}
-
 	static inline u64
 kp_spi_read_reg(struct kp_spi_controller_state *cs, int idx)
 {

commit 66594e3f48cc868abd0955d16bb661170674bda2
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun Jun 2 15:58:35 2019 +0000

    staging: kpc2000: kpc_spi: remove fifo_depth from kp_spi struct
    
    The kp_spi structure contains a member 'fifo_depth'. This member is
    never used. Therefore, it should be removed.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 13c4651e1fac..049b1e324031 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -105,7 +105,6 @@ struct kp_spi {
 	u64 __iomem        *base;
 	unsigned long       phys;
 	struct device      *dev;
-	int                 fifo_depth;
 	unsigned int        pin_dir:1;
 };
 

commit 32ed45068c7e79947da72f7a61800bae1dd39596
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun Jun 2 15:58:34 2019 +0000

    staging: kpc2000: kpc_spi: column-align switch and subordinate cases
    
    The linux style guide prescribes that switch statements and their
    subordinate case labels should be column-aligned rather than
    double-indenting the case label. Make kpc2000_spi.c follow the desired
    style with respect to switch/case alignment.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index ef7e062bf52c..13c4651e1fac 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -502,13 +502,13 @@ kp_spi_probe(struct platform_device *pldev)
 	}
 
 	switch ((drvdata->card_id & 0xFFFF0000) >> 16){
-		case PCI_DEVICE_ID_DAKTRONICS_KADOKA_P2KR0:
-			NEW_SPI_DEVICE_FROM_BOARD_INFO_TABLE(p2kr0_board_info);
-			break;
-		default:
-			dev_err(&pldev->dev, "Unknown hardware, cant know what partition table to use!\n");
-			goto free_master;
-			break;
+	case PCI_DEVICE_ID_DAKTRONICS_KADOKA_P2KR0:
+		NEW_SPI_DEVICE_FROM_BOARD_INFO_TABLE(p2kr0_board_info);
+		break;
+	default:
+		dev_err(&pldev->dev, "Unknown hardware, cant know what partition table to use!\n");
+		goto free_master;
+		break;
 	}
 
 	return status;

commit 4d632cdbdd28aedf884f67e6cc61364ea4ded7d4
Author: Geordan Neukum <gneukum1@gmail.com>
Date:   Sun Jun 2 15:58:33 2019 +0000

    staging: kpc2000: kpc_spi: Remove unnecessary consecutive newlines
    
    The kpc2000_spi.c file contains instances of unnecessary consecutive
    newlines which negatively impact the readability of the file. Remove
    all unnecessary consecutive newlines.
    
    Signed-off-by: Geordan Neukum <gneukum1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 9a23808ffaa1..ef7e062bf52c 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -97,8 +97,6 @@ static struct spi_board_info p2kr0_board_info[] = {
 #define KP_SPI_REG_STATUS_RXFFE 0x40
 #define KP_SPI_REG_STATUS_RXFFF 0x80
 
-
-
 /******************
  * SPI Structures *
  ******************/
@@ -111,7 +109,6 @@ struct kp_spi {
 	unsigned int        pin_dir:1;
 };
 
-
 struct kp_spi_controller_state {
 	void __iomem   *base;
 	unsigned long   phys;
@@ -120,7 +117,6 @@ struct kp_spi_controller_state {
 	s64             conf_cache;
 };
 
-
 union kp_spi_config {
 	/* use this to access individual elements */
 	struct __attribute__((packed)) spi_config_bitfield {
@@ -141,8 +137,6 @@ union kp_spi_config {
 	u32 reg;
 };
 
-
-
 union kp_spi_status {
 	struct __attribute__((packed)) spi_status_bitfield {
 		unsigned int rx    :  1; /* Rx Status       */
@@ -158,8 +152,6 @@ union kp_spi_status {
 	u32 reg;
 };
 
-
-
 union kp_spi_ffctrl {
 	struct __attribute__((packed)) spi_ffctrl_bitfield {
 		unsigned int ffstart :  1; /* FIFO Start */
@@ -168,8 +160,6 @@ union kp_spi_ffctrl {
 	u32 reg;
 };
 
-
-
 /***************
  * SPI Helpers *
  ***************/
@@ -445,8 +435,6 @@ kp_spi_cleanup(struct spi_device *spidev)
 	}
 }
 
-
-
 /******************
  * Probe / Remove *
  ******************/
@@ -538,7 +526,6 @@ kp_spi_remove(struct platform_device *pldev)
 	return 0;
 }
 
-
 static struct platform_driver kp_spi_driver = {
 	.driver = {
 		.name =     KP_DRIVER_NAME_SPI,

commit 46144c1391574f0164def0ca3aa20a6361e4effb
Author: Mao Wenan <maowenan@huawei.com>
Date:   Tue May 28 16:02:14 2019 +0800

    staging: kpc2000: replace white spaces with tabs for kpc2000_spi.c
    
    There are multiple wrong formats in kpc2000_spi.c,
    is time to do clean work for it.
    
    Signed-off-by: Mao Wenan <maowenan@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 628a447642ad..9a23808ffaa1 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -113,59 +113,59 @@ struct kp_spi {
 
 
 struct kp_spi_controller_state {
-    void __iomem   *base;
-    unsigned long   phys;
-    unsigned char   chip_select;
-    int             word_len;
-    s64             conf_cache;
+	void __iomem   *base;
+	unsigned long   phys;
+	unsigned char   chip_select;
+	int             word_len;
+	s64             conf_cache;
 };
 
 
 union kp_spi_config {
-    /* use this to access individual elements */
-    struct __attribute__((packed)) spi_config_bitfield {
-        unsigned int pha       : 1; /* spim_clk Phase      */
-        unsigned int pol       : 1; /* spim_clk Polarity   */
-        unsigned int epol      : 1; /* spim_csx Polarity   */
-        unsigned int dpe       : 1; /* Transmission Enable */
-        unsigned int wl        : 5; /* Word Length         */
-        unsigned int           : 3;
-        unsigned int trm       : 2; /* TxRx Mode           */
-        unsigned int cs        : 4; /* Chip Select         */
-        unsigned int wcnt      : 7; /* Word Count          */
-        unsigned int ffen      : 1; /* FIFO Enable         */
-        unsigned int spi_en    : 1; /* SPI Enable          */
-        unsigned int           : 5;
-    } bitfield;
-    /* use this to grab the whole register */
-    u32 reg;
+	/* use this to access individual elements */
+	struct __attribute__((packed)) spi_config_bitfield {
+		unsigned int pha       : 1; /* spim_clk Phase      */
+		unsigned int pol       : 1; /* spim_clk Polarity   */
+		unsigned int epol      : 1; /* spim_csx Polarity   */
+		unsigned int dpe       : 1; /* Transmission Enable */
+		unsigned int wl        : 5; /* Word Length         */
+		unsigned int           : 3;
+		unsigned int trm       : 2; /* TxRx Mode           */
+		unsigned int cs        : 4; /* Chip Select         */
+		unsigned int wcnt      : 7; /* Word Count          */
+		unsigned int ffen      : 1; /* FIFO Enable         */
+		unsigned int spi_en    : 1; /* SPI Enable          */
+		unsigned int           : 5;
+	} bitfield;
+	/* use this to grab the whole register */
+	u32 reg;
 };
 
 
 
 union kp_spi_status {
-    struct __attribute__((packed)) spi_status_bitfield {
-        unsigned int rx    :  1; /* Rx Status       */
-        unsigned int tx    :  1; /* Tx Status       */
-        unsigned int eo    :  1; /* End of Transfer */
-        unsigned int       :  1;
-        unsigned int txffe :  1; /* Tx FIFO Empty   */
-        unsigned int txfff :  1; /* Tx FIFO Full    */
-        unsigned int rxffe :  1; /* Rx FIFO Empty   */
-        unsigned int rxfff :  1; /* Rx FIFO Full    */
-        unsigned int       : 24;
-    } bitfield;
-    u32 reg;
+	struct __attribute__((packed)) spi_status_bitfield {
+		unsigned int rx    :  1; /* Rx Status       */
+		unsigned int tx    :  1; /* Tx Status       */
+		unsigned int eo    :  1; /* End of Transfer */
+		unsigned int       :  1;
+		unsigned int txffe :  1; /* Tx FIFO Empty   */
+		unsigned int txfff :  1; /* Tx FIFO Full    */
+		unsigned int rxffe :  1; /* Rx FIFO Empty   */
+		unsigned int rxfff :  1; /* Rx FIFO Full    */
+		unsigned int       : 24;
+	} bitfield;
+	u32 reg;
 };
 
 
 
 union kp_spi_ffctrl {
-    struct __attribute__((packed)) spi_ffctrl_bitfield {
-        unsigned int ffstart :  1; /* FIFO Start */
-        unsigned int         : 31;
-    } bitfield;
-    u32 reg;
+	struct __attribute__((packed)) spi_ffctrl_bitfield {
+		unsigned int ffstart :  1; /* FIFO Start */
+		unsigned int         : 31;
+	} bitfield;
+	u32 reg;
 };
 
 
@@ -173,276 +173,276 @@ union kp_spi_ffctrl {
 /***************
  * SPI Helpers *
  ***************/
-static inline int
+	static inline int
 kp_spi_bytes_per_word(int word_len)
 {
-    if (word_len <= 8){
-        return 1;
-    }
-    else if (word_len <= 16) {
-        return 2;
-    }
-    else { /* word_len <= 32 */
-        return 4;
-    }
+	if (word_len <= 8){
+		return 1;
+	}
+	else if (word_len <= 16) {
+		return 2;
+	}
+	else { /* word_len <= 32 */
+		return 4;
+	}
 }
 
-static inline u64
+	static inline u64
 kp_spi_read_reg(struct kp_spi_controller_state *cs, int idx)
 {
-    u64 __iomem *addr = cs->base;
-    u64 val;
-
-    addr += idx;
-    if ((idx == KP_SPI_REG_CONFIG) && (cs->conf_cache >= 0)){
-        return cs->conf_cache;
-    }
-    val = readq((void*)addr);
-    return val;
+	u64 __iomem *addr = cs->base;
+	u64 val;
+
+	addr += idx;
+	if ((idx == KP_SPI_REG_CONFIG) && (cs->conf_cache >= 0)){
+		return cs->conf_cache;
+	}
+	val = readq((void*)addr);
+	return val;
 }
 
-static inline void
+	static inline void
 kp_spi_write_reg(struct kp_spi_controller_state *cs, int idx, u64 val)
 {
-    u64 __iomem *addr = cs->base;
-    addr += idx;
-    writeq(val, (void*)addr);
-    if (idx == KP_SPI_REG_CONFIG)
-        cs->conf_cache = val;
+	u64 __iomem *addr = cs->base;
+	addr += idx;
+	writeq(val, (void*)addr);
+	if (idx == KP_SPI_REG_CONFIG)
+		cs->conf_cache = val;
 }
 
-static int
+	static int
 kp_spi_wait_for_reg_bit(struct kp_spi_controller_state *cs, int idx, unsigned long bit)
 {
-    unsigned long timeout;
-    timeout = jiffies + msecs_to_jiffies(1000);
-    while (!(kp_spi_read_reg(cs, idx) & bit)) {
-        if (time_after(jiffies, timeout)) {
-            if (!(kp_spi_read_reg(cs, idx) & bit)) {
-                return -ETIMEDOUT;
-            } else {
-                return 0;
-            }
-        }
-        cpu_relax();
-    }
-    return 0;
+	unsigned long timeout;
+	timeout = jiffies + msecs_to_jiffies(1000);
+	while (!(kp_spi_read_reg(cs, idx) & bit)) {
+		if (time_after(jiffies, timeout)) {
+			if (!(kp_spi_read_reg(cs, idx) & bit)) {
+				return -ETIMEDOUT;
+			} else {
+				return 0;
+			}
+		}
+		cpu_relax();
+	}
+	return 0;
 }
 
-static unsigned
+	static unsigned
 kp_spi_txrx_pio(struct spi_device *spidev, struct spi_transfer *transfer)
 {
-    struct kp_spi_controller_state *cs = spidev->controller_state;
-    unsigned int count = transfer->len;
-    unsigned int c = count;
-    
-    int i;
-    u8 *rx       = transfer->rx_buf;
-    const u8 *tx = transfer->tx_buf;
-    int processed = 0;
-    
-    if (tx) {
-        for (i = 0 ; i < c ; i++) {
-            char val = *tx++;
-            
-            if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_TXS) < 0) {
-                goto out;
-            }
-            
-            kp_spi_write_reg(cs, KP_SPI_REG_TXDATA, val);
-            processed++;
-        }
-    }
-    else if(rx) {
-        for (i = 0 ; i < c ; i++) {
-            char test=0;
-            
-            kp_spi_write_reg(cs, KP_SPI_REG_TXDATA, 0x00);
-            
-            if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_RXS) < 0) {
-                goto out;
-            }
-            
-            test = kp_spi_read_reg(cs, KP_SPI_REG_RXDATA);
-            *rx++ = test;
-            processed++;
-        }
-    }
-    
-    if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_EOT) < 0) {
-        //TODO: Figure out how to abort transaction??  This has never happened in practice though...
-    }
-    
- out:
-    return processed;
+	struct kp_spi_controller_state *cs = spidev->controller_state;
+	unsigned int count = transfer->len;
+	unsigned int c = count;
+
+	int i;
+	u8 *rx       = transfer->rx_buf;
+	const u8 *tx = transfer->tx_buf;
+	int processed = 0;
+
+	if (tx) {
+		for (i = 0 ; i < c ; i++) {
+			char val = *tx++;
+
+			if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_TXS) < 0) {
+				goto out;
+			}
+
+			kp_spi_write_reg(cs, KP_SPI_REG_TXDATA, val);
+			processed++;
+		}
+	}
+	else if(rx) {
+		for (i = 0 ; i < c ; i++) {
+			char test=0;
+
+			kp_spi_write_reg(cs, KP_SPI_REG_TXDATA, 0x00);
+
+			if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_RXS) < 0) {
+				goto out;
+			}
+
+			test = kp_spi_read_reg(cs, KP_SPI_REG_RXDATA);
+			*rx++ = test;
+			processed++;
+		}
+	}
+
+	if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_EOT) < 0) {
+		//TODO: Figure out how to abort transaction??  This has never happened in practice though...
+	}
+
+out:
+	return processed;
 }
 
 /*****************
  * SPI Functions *
  *****************/
-static int
+	static int
 kp_spi_setup(struct spi_device *spidev)
 {
-    union kp_spi_config sc;
-    struct kp_spi *kpspi = spi_master_get_devdata(spidev->master);
-    struct kp_spi_controller_state *cs;
-    
-    /* setup controller state */
-    cs = spidev->controller_state;
-    if (!cs) {
-        cs = kzalloc(sizeof(*cs), GFP_KERNEL);
-        if(!cs) {
-            return -ENOMEM;
-        }
-        cs->base = kpspi->base;
-        cs->phys = kpspi->phys;
-        cs->chip_select = spidev->chip_select;
-        cs->word_len = spidev->bits_per_word;
-        cs->conf_cache = -1;
-        spidev->controller_state = cs;
-    }
-    
-    /* set config register */
-    sc.bitfield.wl = spidev->bits_per_word - 1;
-    sc.bitfield.cs = spidev->chip_select;
-    sc.bitfield.spi_en = 0;
-    sc.bitfield.trm = 0;
-    sc.bitfield.ffen = 0;
-    kp_spi_write_reg(spidev->controller_state, KP_SPI_REG_CONFIG, sc.reg);
-    return 0;
+	union kp_spi_config sc;
+	struct kp_spi *kpspi = spi_master_get_devdata(spidev->master);
+	struct kp_spi_controller_state *cs;
+
+	/* setup controller state */
+	cs = spidev->controller_state;
+	if (!cs) {
+		cs = kzalloc(sizeof(*cs), GFP_KERNEL);
+		if(!cs) {
+			return -ENOMEM;
+		}
+		cs->base = kpspi->base;
+		cs->phys = kpspi->phys;
+		cs->chip_select = spidev->chip_select;
+		cs->word_len = spidev->bits_per_word;
+		cs->conf_cache = -1;
+		spidev->controller_state = cs;
+	}
+
+	/* set config register */
+	sc.bitfield.wl = spidev->bits_per_word - 1;
+	sc.bitfield.cs = spidev->chip_select;
+	sc.bitfield.spi_en = 0;
+	sc.bitfield.trm = 0;
+	sc.bitfield.ffen = 0;
+	kp_spi_write_reg(spidev->controller_state, KP_SPI_REG_CONFIG, sc.reg);
+	return 0;
 }
 
-static int
+	static int
 kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
 {
-    struct kp_spi_controller_state *cs;
-    struct spi_device   *spidev;
-    struct kp_spi       *kpspi;
-    struct spi_transfer *transfer;
-    union kp_spi_config sc;
-    int status = 0;
-    
-    spidev = m->spi;
-    kpspi = spi_master_get_devdata(master);
-    m->actual_length = 0;
-    m->status = 0;
-    
-    cs = spidev->controller_state;
-    
-    /* reject invalid messages and transfers */
-    if (list_empty(&m->transfers)) {
-        return -EINVAL;
-    }
-    
-    /* validate input */
-    list_for_each_entry(transfer, &m->transfers, transfer_list) {
-        const void *tx_buf = transfer->tx_buf;
-        void       *rx_buf = transfer->rx_buf;
-        unsigned    len = transfer->len;
-        
-        if (transfer->speed_hz > KP_SPI_CLK || (len && !(rx_buf || tx_buf))) {
-            dev_dbg(kpspi->dev, "  transfer: %d Hz, %d %s%s, %d bpw\n",
-                    transfer->speed_hz,
-                    len,
-                    tx_buf ? "tx" : "",
-                    rx_buf ? "rx" : "",
-                    transfer->bits_per_word);
-            dev_dbg(kpspi->dev, "  transfer -EINVAL\n");
-            return -EINVAL;
-        }
-        if (transfer->speed_hz && (transfer->speed_hz < (KP_SPI_CLK >> 15))) {
-            dev_dbg(kpspi->dev, "speed_hz %d below minimum %d Hz\n",
-                    transfer->speed_hz,
-                    KP_SPI_CLK >> 15);
-            dev_dbg(kpspi->dev, "  speed_hz -EINVAL\n");
-            return -EINVAL;
-        }
-    }
-    
-    /* assert chip select to start the sequence*/
-    sc.reg = kp_spi_read_reg(cs, KP_SPI_REG_CONFIG);
-    sc.bitfield.spi_en = 1;
-    kp_spi_write_reg(cs, KP_SPI_REG_CONFIG, sc.reg);
-    
-    /* work */
-    if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_EOT) < 0) {
-        dev_info(kpspi->dev, "EOT timed out\n");
-        goto out;
-    }
-    
-    /* do the transfers for this message */
-    list_for_each_entry(transfer, &m->transfers, transfer_list) {
-        if (transfer->tx_buf == NULL && transfer->rx_buf == NULL && transfer->len) {
-            status = -EINVAL;
-            goto error;
-        }
-        
-        /* transfer */
-        if (transfer->len) {
-            unsigned int word_len = spidev->bits_per_word;
-            unsigned count;
-            
-            /* set up the transfer... */
-            sc.reg = kp_spi_read_reg(cs, KP_SPI_REG_CONFIG);
-            
-            /* ...direction */
-            if (transfer->tx_buf) {
-                sc.bitfield.trm = KP_SPI_REG_CONFIG_TRM_TX;
-            }
-            else if (transfer->rx_buf) {
-                sc.bitfield.trm = KP_SPI_REG_CONFIG_TRM_RX;
-            }
-            
-            /* ...word length */
-            if (transfer->bits_per_word) {
-                word_len = transfer->bits_per_word;
-            }
-            cs->word_len = word_len;
-            sc.bitfield.wl = word_len-1;
-            
-            /* ...chip select */
-            sc.bitfield.cs = spidev->chip_select;
-            
-            /* ...and write the new settings */
-            kp_spi_write_reg(cs, KP_SPI_REG_CONFIG, sc.reg);
-            
-            /* do the transfer */
-            count = kp_spi_txrx_pio(spidev, transfer);
-            m->actual_length += count;
-            
-            if (count != transfer->len) {
-                status = -EIO;
-                goto error;
-            }
-        }
-        
-        if (transfer->delay_usecs) {
-            udelay(transfer->delay_usecs);
-        }
-    }
-    
-    /* de-assert chip select to end the sequence */
-    sc.reg = kp_spi_read_reg(cs, KP_SPI_REG_CONFIG);
-    sc.bitfield.spi_en = 0;
-    kp_spi_write_reg(cs, KP_SPI_REG_CONFIG, sc.reg);
-    
- out:
-    /* done work */
-    spi_finalize_current_message(master);
-    return 0;
-
- error:
-    m->status = status;
-    return status;
+	struct kp_spi_controller_state *cs;
+	struct spi_device   *spidev;
+	struct kp_spi       *kpspi;
+	struct spi_transfer *transfer;
+	union kp_spi_config sc;
+	int status = 0;
+
+	spidev = m->spi;
+	kpspi = spi_master_get_devdata(master);
+	m->actual_length = 0;
+	m->status = 0;
+
+	cs = spidev->controller_state;
+
+	/* reject invalid messages and transfers */
+	if (list_empty(&m->transfers)) {
+		return -EINVAL;
+	}
+
+	/* validate input */
+	list_for_each_entry(transfer, &m->transfers, transfer_list) {
+		const void *tx_buf = transfer->tx_buf;
+		void       *rx_buf = transfer->rx_buf;
+		unsigned    len = transfer->len;
+
+		if (transfer->speed_hz > KP_SPI_CLK || (len && !(rx_buf || tx_buf))) {
+			dev_dbg(kpspi->dev, "  transfer: %d Hz, %d %s%s, %d bpw\n",
+					transfer->speed_hz,
+					len,
+					tx_buf ? "tx" : "",
+					rx_buf ? "rx" : "",
+					transfer->bits_per_word);
+			dev_dbg(kpspi->dev, "  transfer -EINVAL\n");
+			return -EINVAL;
+		}
+		if (transfer->speed_hz && (transfer->speed_hz < (KP_SPI_CLK >> 15))) {
+			dev_dbg(kpspi->dev, "speed_hz %d below minimum %d Hz\n",
+					transfer->speed_hz,
+					KP_SPI_CLK >> 15);
+			dev_dbg(kpspi->dev, "  speed_hz -EINVAL\n");
+			return -EINVAL;
+		}
+	}
+
+	/* assert chip select to start the sequence*/
+	sc.reg = kp_spi_read_reg(cs, KP_SPI_REG_CONFIG);
+	sc.bitfield.spi_en = 1;
+	kp_spi_write_reg(cs, KP_SPI_REG_CONFIG, sc.reg);
+
+	/* work */
+	if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_EOT) < 0) {
+		dev_info(kpspi->dev, "EOT timed out\n");
+		goto out;
+	}
+
+	/* do the transfers for this message */
+	list_for_each_entry(transfer, &m->transfers, transfer_list) {
+		if (transfer->tx_buf == NULL && transfer->rx_buf == NULL && transfer->len) {
+			status = -EINVAL;
+			goto error;
+		}
+
+		/* transfer */
+		if (transfer->len) {
+			unsigned int word_len = spidev->bits_per_word;
+			unsigned count;
+
+			/* set up the transfer... */
+			sc.reg = kp_spi_read_reg(cs, KP_SPI_REG_CONFIG);
+
+			/* ...direction */
+			if (transfer->tx_buf) {
+				sc.bitfield.trm = KP_SPI_REG_CONFIG_TRM_TX;
+			}
+			else if (transfer->rx_buf) {
+				sc.bitfield.trm = KP_SPI_REG_CONFIG_TRM_RX;
+			}
+
+			/* ...word length */
+			if (transfer->bits_per_word) {
+				word_len = transfer->bits_per_word;
+			}
+			cs->word_len = word_len;
+			sc.bitfield.wl = word_len-1;
+
+			/* ...chip select */
+			sc.bitfield.cs = spidev->chip_select;
+
+			/* ...and write the new settings */
+			kp_spi_write_reg(cs, KP_SPI_REG_CONFIG, sc.reg);
+
+			/* do the transfer */
+			count = kp_spi_txrx_pio(spidev, transfer);
+			m->actual_length += count;
+
+			if (count != transfer->len) {
+				status = -EIO;
+				goto error;
+			}
+		}
+
+		if (transfer->delay_usecs) {
+			udelay(transfer->delay_usecs);
+		}
+	}
+
+	/* de-assert chip select to end the sequence */
+	sc.reg = kp_spi_read_reg(cs, KP_SPI_REG_CONFIG);
+	sc.bitfield.spi_en = 0;
+	kp_spi_write_reg(cs, KP_SPI_REG_CONFIG, sc.reg);
+
+out:
+	/* done work */
+	spi_finalize_current_message(master);
+	return 0;
+
+error:
+	m->status = status;
+	return status;
 }
 
-static void
+	static void
 kp_spi_cleanup(struct spi_device *spidev)
 {
-    struct kp_spi_controller_state *cs = spidev->controller_state;
-    if (cs) {
-        kfree(cs);
-    }
+	struct kp_spi_controller_state *cs = spidev->controller_state;
+	if (cs) {
+		kfree(cs);
+	}
 }
 
 
@@ -450,101 +450,101 @@ kp_spi_cleanup(struct spi_device *spidev)
 /******************
  * Probe / Remove *
  ******************/
-static int
+	static int
 kp_spi_probe(struct platform_device *pldev)
 {
-    struct kpc_core_device_platdata *drvdata;
-    struct spi_master *master;
-    struct kp_spi *kpspi;
-    struct resource *r;
-    int status = 0;
-    int i;
-
-    drvdata = pldev->dev.platform_data;
-    if (!drvdata){
-        dev_err(&pldev->dev, "kp_spi_probe: platform_data is NULL!\n");
-        return -ENODEV;
-    }
-    
-    master = spi_alloc_master(&pldev->dev, sizeof(struct kp_spi));
-    if (master == NULL) {
-        dev_err(&pldev->dev, "kp_spi_probe: master allocation failed\n");
-        return -ENOMEM;
-    }
-    
-    /* set up the spi functions */
-    master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
-    master->bits_per_word_mask = (unsigned int)SPI_BPW_RANGE_MASK(4, 32);
-    master->setup = kp_spi_setup;
-    master->transfer_one_message = kp_spi_transfer_one_message;
-    master->cleanup = kp_spi_cleanup;
-    
-    platform_set_drvdata(pldev, master);
-    
-    kpspi = spi_master_get_devdata(master);
-    kpspi->master = master;
-    kpspi->dev = &pldev->dev;
-    
-    master->num_chipselect = 4;
-    if (pldev->id != -1) {
-        master->bus_num = pldev->id;
-    }
-    kpspi->pin_dir = 0;
-    
-    r = platform_get_resource(pldev, IORESOURCE_MEM, 0);
-    if (r == NULL) {
-        dev_err(&pldev->dev, "kp_spi_probe: Unable to get platform resources\n");
-        status = -ENODEV;
-        goto free_master;
-    }
-    
-    kpspi->phys = (unsigned long)ioremap_nocache(r->start, resource_size(r));
-    kpspi->base = (u64 __iomem *)kpspi->phys;
-    
-    status = spi_register_master(master);
-    if (status < 0) {
-        dev_err(&pldev->dev, "Unable to register SPI device\n");
-        goto free_master;
-    }
-    
-    /* register the slave boards */
-    #define NEW_SPI_DEVICE_FROM_BOARD_INFO_TABLE(table) \
-        for (i = 0 ; i < ARRAY_SIZE(table) ; i++) { \
-            spi_new_device(master, &(table[i])); \
-        }
-    
-    switch ((drvdata->card_id & 0xFFFF0000) >> 16){
-        case PCI_DEVICE_ID_DAKTRONICS_KADOKA_P2KR0:
-            NEW_SPI_DEVICE_FROM_BOARD_INFO_TABLE(p2kr0_board_info);
-            break;
-        default:
-            dev_err(&pldev->dev, "Unknown hardware, cant know what partition table to use!\n");
-            goto free_master;
-            break;
-    }
-    
-    return status;
-
- free_master:
-    spi_master_put(master);
-    return status;
+	struct kpc_core_device_platdata *drvdata;
+	struct spi_master *master;
+	struct kp_spi *kpspi;
+	struct resource *r;
+	int status = 0;
+	int i;
+
+	drvdata = pldev->dev.platform_data;
+	if (!drvdata){
+		dev_err(&pldev->dev, "kp_spi_probe: platform_data is NULL!\n");
+		return -ENODEV;
+	}
+
+	master = spi_alloc_master(&pldev->dev, sizeof(struct kp_spi));
+	if (master == NULL) {
+		dev_err(&pldev->dev, "kp_spi_probe: master allocation failed\n");
+		return -ENOMEM;
+	}
+
+	/* set up the spi functions */
+	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
+	master->bits_per_word_mask = (unsigned int)SPI_BPW_RANGE_MASK(4, 32);
+	master->setup = kp_spi_setup;
+	master->transfer_one_message = kp_spi_transfer_one_message;
+	master->cleanup = kp_spi_cleanup;
+
+	platform_set_drvdata(pldev, master);
+
+	kpspi = spi_master_get_devdata(master);
+	kpspi->master = master;
+	kpspi->dev = &pldev->dev;
+
+	master->num_chipselect = 4;
+	if (pldev->id != -1) {
+		master->bus_num = pldev->id;
+	}
+	kpspi->pin_dir = 0;
+
+	r = platform_get_resource(pldev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		dev_err(&pldev->dev, "kp_spi_probe: Unable to get platform resources\n");
+		status = -ENODEV;
+		goto free_master;
+	}
+
+	kpspi->phys = (unsigned long)ioremap_nocache(r->start, resource_size(r));
+	kpspi->base = (u64 __iomem *)kpspi->phys;
+
+	status = spi_register_master(master);
+	if (status < 0) {
+		dev_err(&pldev->dev, "Unable to register SPI device\n");
+		goto free_master;
+	}
+
+	/* register the slave boards */
+#define NEW_SPI_DEVICE_FROM_BOARD_INFO_TABLE(table) \
+	for (i = 0 ; i < ARRAY_SIZE(table) ; i++) { \
+		spi_new_device(master, &(table[i])); \
+	}
+
+	switch ((drvdata->card_id & 0xFFFF0000) >> 16){
+		case PCI_DEVICE_ID_DAKTRONICS_KADOKA_P2KR0:
+			NEW_SPI_DEVICE_FROM_BOARD_INFO_TABLE(p2kr0_board_info);
+			break;
+		default:
+			dev_err(&pldev->dev, "Unknown hardware, cant know what partition table to use!\n");
+			goto free_master;
+			break;
+	}
+
+	return status;
+
+free_master:
+	spi_master_put(master);
+	return status;
 }
 
-static int
+	static int
 kp_spi_remove(struct platform_device *pldev)
 {
-    struct spi_master * master = platform_get_drvdata(pldev);
-    spi_unregister_master(master);
-    return 0;
+	struct spi_master * master = platform_get_drvdata(pldev);
+	spi_unregister_master(master);
+	return 0;
 }
 
 
 static struct platform_driver kp_spi_driver = {
-    .driver = {
-        .name =     KP_DRIVER_NAME_SPI,
-    },
-    .probe =    kp_spi_probe,
-    .remove =   kp_spi_remove,
+	.driver = {
+		.name =     KP_DRIVER_NAME_SPI,
+	},
+	.probe =    kp_spi_probe,
+	.remove =   kp_spi_remove,
 };
 
 module_platform_driver(kp_spi_driver);

commit 9164f336311863d3e9f80840f4a1cce2aee293bd
Author: Mao Wenan <maowenan@huawei.com>
Date:   Tue May 28 16:02:13 2019 +0800

    staging: kpc2000: report error status to spi core
    
    There is an error condition that's not reported to
    the spi core in kp_spi_transfer_one_message().
    It should restore status value to m->status, and
    return it in error path.
    
    Signed-off-by: Mao Wenan <maowenan@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
index 075ae4fafa7d..628a447642ad 100644
--- a/drivers/staging/kpc2000/kpc2000_spi.c
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -374,7 +374,7 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
     list_for_each_entry(transfer, &m->transfers, transfer_list) {
         if (transfer->tx_buf == NULL && transfer->rx_buf == NULL && transfer->len) {
             status = -EINVAL;
-            break;
+            goto error;
         }
         
         /* transfer */
@@ -412,7 +412,7 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
             
             if (count != transfer->len) {
                 status = -EIO;
-                break;
+                goto error;
             }
         }
         
@@ -430,6 +430,10 @@ kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
     /* done work */
     spi_finalize_current_message(master);
     return 0;
+
+ error:
+    m->status = status;
+    return status;
 }
 
 static void

commit f900d81cb960097524be3705b050b60aa5959a83
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 20 10:47:13 2019 +0200

    staging: kpc2000: move the spi driver out of its subdirectory
    
    There is no need for a subdirectory for just a single .c file.  So move
    it out of kpc_spi/ and rename it to the module name that we want the
    file to build to, saving one more linking stage.
    
    Cc: Matt Sickler <Matt.Sickler@daktronics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000_spi.c b/drivers/staging/kpc2000/kpc2000_spi.c
new file mode 100644
index 000000000000..075ae4fafa7d
--- /dev/null
+++ b/drivers/staging/kpc2000/kpc2000_spi.c
@@ -0,0 +1,548 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * KP2000 SPI controller driver
+ *
+ * Copyright (C) 2014-2018 Daktronics
+ * Author: Matt Sickler <matt.sickler@daktronics.com>
+ * Very loosely based on spi-omap2-mcspi.c
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io-64-nonatomic-lo-hi.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/gcd.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/mtd/partitions.h>
+
+#include "kpc.h"
+
+static struct mtd_partition p2kr0_spi0_parts[] = {
+	{ .name = "SLOT_0",	.size = 7798784,		.offset = 0,                },
+	{ .name = "SLOT_1",	.size = 7798784,		.offset = MTDPART_OFS_NXTBLK},
+	{ .name = "SLOT_2",	.size = 7798784,		.offset = MTDPART_OFS_NXTBLK},
+	{ .name = "SLOT_3",	.size = 7798784,		.offset = MTDPART_OFS_NXTBLK},
+	{ .name = "CS0_EXTRA",	.size = MTDPART_SIZ_FULL,	.offset = MTDPART_OFS_NXTBLK},
+};
+static struct mtd_partition p2kr0_spi1_parts[] = {
+	{ .name = "SLOT_4",	.size = 7798784,		.offset = 0,                },
+	{ .name = "SLOT_5",	.size = 7798784,		.offset = MTDPART_OFS_NXTBLK},
+	{ .name = "SLOT_6",	.size = 7798784,		.offset = MTDPART_OFS_NXTBLK},
+	{ .name = "SLOT_7",	.size = 7798784,		.offset = MTDPART_OFS_NXTBLK},
+	{ .name = "CS1_EXTRA",	.size = MTDPART_SIZ_FULL,	.offset = MTDPART_OFS_NXTBLK},
+};
+
+static struct flash_platform_data p2kr0_spi0_pdata = {
+	.name =		"SPI0",
+	.nr_parts =	ARRAY_SIZE(p2kr0_spi0_parts),
+	.parts =	p2kr0_spi0_parts,
+};
+static struct flash_platform_data p2kr0_spi1_pdata = {
+	.name =		"SPI1",
+	.nr_parts =	ARRAY_SIZE(p2kr0_spi1_parts),
+	.parts =	p2kr0_spi1_parts,
+};
+
+static struct spi_board_info p2kr0_board_info[] = {
+	{
+		.modalias =		"n25q256a11",
+		.bus_num =		1,
+		.chip_select =		0,
+		.mode =			SPI_MODE_0,
+		.platform_data =	&p2kr0_spi0_pdata
+	},
+	{
+		.modalias =		"n25q256a11",
+		.bus_num =		1,
+		.chip_select =		1,
+		.mode =			SPI_MODE_0,
+		.platform_data =	&p2kr0_spi1_pdata
+	},
+};
+
+/***************
+ * SPI Defines *
+ ***************/
+#define KP_SPI_REG_CONFIG 0x0 /* 0x00 */
+#define KP_SPI_REG_STATUS 0x1 /* 0x08 */
+#define KP_SPI_REG_FFCTRL 0x2 /* 0x10 */
+#define KP_SPI_REG_TXDATA 0x3 /* 0x18 */
+#define KP_SPI_REG_RXDATA 0x4 /* 0x20 */
+
+#define KP_SPI_CLK           48000000
+#define KP_SPI_MAX_FIFODEPTH 64
+#define KP_SPI_MAX_FIFOWCNT  0xFFFF
+
+#define KP_SPI_REG_CONFIG_TRM_TXRX 0
+#define KP_SPI_REG_CONFIG_TRM_RX   1
+#define KP_SPI_REG_CONFIG_TRM_TX   2
+
+#define KP_SPI_REG_STATUS_RXS   0x01
+#define KP_SPI_REG_STATUS_TXS   0x02
+#define KP_SPI_REG_STATUS_EOT   0x04
+#define KP_SPI_REG_STATUS_TXFFE 0x10
+#define KP_SPI_REG_STATUS_TXFFF 0x20
+#define KP_SPI_REG_STATUS_RXFFE 0x40
+#define KP_SPI_REG_STATUS_RXFFF 0x80
+
+
+
+/******************
+ * SPI Structures *
+ ******************/
+struct kp_spi {
+	struct spi_master  *master;
+	u64 __iomem        *base;
+	unsigned long       phys;
+	struct device      *dev;
+	int                 fifo_depth;
+	unsigned int        pin_dir:1;
+};
+
+
+struct kp_spi_controller_state {
+    void __iomem   *base;
+    unsigned long   phys;
+    unsigned char   chip_select;
+    int             word_len;
+    s64             conf_cache;
+};
+
+
+union kp_spi_config {
+    /* use this to access individual elements */
+    struct __attribute__((packed)) spi_config_bitfield {
+        unsigned int pha       : 1; /* spim_clk Phase      */
+        unsigned int pol       : 1; /* spim_clk Polarity   */
+        unsigned int epol      : 1; /* spim_csx Polarity   */
+        unsigned int dpe       : 1; /* Transmission Enable */
+        unsigned int wl        : 5; /* Word Length         */
+        unsigned int           : 3;
+        unsigned int trm       : 2; /* TxRx Mode           */
+        unsigned int cs        : 4; /* Chip Select         */
+        unsigned int wcnt      : 7; /* Word Count          */
+        unsigned int ffen      : 1; /* FIFO Enable         */
+        unsigned int spi_en    : 1; /* SPI Enable          */
+        unsigned int           : 5;
+    } bitfield;
+    /* use this to grab the whole register */
+    u32 reg;
+};
+
+
+
+union kp_spi_status {
+    struct __attribute__((packed)) spi_status_bitfield {
+        unsigned int rx    :  1; /* Rx Status       */
+        unsigned int tx    :  1; /* Tx Status       */
+        unsigned int eo    :  1; /* End of Transfer */
+        unsigned int       :  1;
+        unsigned int txffe :  1; /* Tx FIFO Empty   */
+        unsigned int txfff :  1; /* Tx FIFO Full    */
+        unsigned int rxffe :  1; /* Rx FIFO Empty   */
+        unsigned int rxfff :  1; /* Rx FIFO Full    */
+        unsigned int       : 24;
+    } bitfield;
+    u32 reg;
+};
+
+
+
+union kp_spi_ffctrl {
+    struct __attribute__((packed)) spi_ffctrl_bitfield {
+        unsigned int ffstart :  1; /* FIFO Start */
+        unsigned int         : 31;
+    } bitfield;
+    u32 reg;
+};
+
+
+
+/***************
+ * SPI Helpers *
+ ***************/
+static inline int
+kp_spi_bytes_per_word(int word_len)
+{
+    if (word_len <= 8){
+        return 1;
+    }
+    else if (word_len <= 16) {
+        return 2;
+    }
+    else { /* word_len <= 32 */
+        return 4;
+    }
+}
+
+static inline u64
+kp_spi_read_reg(struct kp_spi_controller_state *cs, int idx)
+{
+    u64 __iomem *addr = cs->base;
+    u64 val;
+
+    addr += idx;
+    if ((idx == KP_SPI_REG_CONFIG) && (cs->conf_cache >= 0)){
+        return cs->conf_cache;
+    }
+    val = readq((void*)addr);
+    return val;
+}
+
+static inline void
+kp_spi_write_reg(struct kp_spi_controller_state *cs, int idx, u64 val)
+{
+    u64 __iomem *addr = cs->base;
+    addr += idx;
+    writeq(val, (void*)addr);
+    if (idx == KP_SPI_REG_CONFIG)
+        cs->conf_cache = val;
+}
+
+static int
+kp_spi_wait_for_reg_bit(struct kp_spi_controller_state *cs, int idx, unsigned long bit)
+{
+    unsigned long timeout;
+    timeout = jiffies + msecs_to_jiffies(1000);
+    while (!(kp_spi_read_reg(cs, idx) & bit)) {
+        if (time_after(jiffies, timeout)) {
+            if (!(kp_spi_read_reg(cs, idx) & bit)) {
+                return -ETIMEDOUT;
+            } else {
+                return 0;
+            }
+        }
+        cpu_relax();
+    }
+    return 0;
+}
+
+static unsigned
+kp_spi_txrx_pio(struct spi_device *spidev, struct spi_transfer *transfer)
+{
+    struct kp_spi_controller_state *cs = spidev->controller_state;
+    unsigned int count = transfer->len;
+    unsigned int c = count;
+    
+    int i;
+    u8 *rx       = transfer->rx_buf;
+    const u8 *tx = transfer->tx_buf;
+    int processed = 0;
+    
+    if (tx) {
+        for (i = 0 ; i < c ; i++) {
+            char val = *tx++;
+            
+            if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_TXS) < 0) {
+                goto out;
+            }
+            
+            kp_spi_write_reg(cs, KP_SPI_REG_TXDATA, val);
+            processed++;
+        }
+    }
+    else if(rx) {
+        for (i = 0 ; i < c ; i++) {
+            char test=0;
+            
+            kp_spi_write_reg(cs, KP_SPI_REG_TXDATA, 0x00);
+            
+            if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_RXS) < 0) {
+                goto out;
+            }
+            
+            test = kp_spi_read_reg(cs, KP_SPI_REG_RXDATA);
+            *rx++ = test;
+            processed++;
+        }
+    }
+    
+    if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_EOT) < 0) {
+        //TODO: Figure out how to abort transaction??  This has never happened in practice though...
+    }
+    
+ out:
+    return processed;
+}
+
+/*****************
+ * SPI Functions *
+ *****************/
+static int
+kp_spi_setup(struct spi_device *spidev)
+{
+    union kp_spi_config sc;
+    struct kp_spi *kpspi = spi_master_get_devdata(spidev->master);
+    struct kp_spi_controller_state *cs;
+    
+    /* setup controller state */
+    cs = spidev->controller_state;
+    if (!cs) {
+        cs = kzalloc(sizeof(*cs), GFP_KERNEL);
+        if(!cs) {
+            return -ENOMEM;
+        }
+        cs->base = kpspi->base;
+        cs->phys = kpspi->phys;
+        cs->chip_select = spidev->chip_select;
+        cs->word_len = spidev->bits_per_word;
+        cs->conf_cache = -1;
+        spidev->controller_state = cs;
+    }
+    
+    /* set config register */
+    sc.bitfield.wl = spidev->bits_per_word - 1;
+    sc.bitfield.cs = spidev->chip_select;
+    sc.bitfield.spi_en = 0;
+    sc.bitfield.trm = 0;
+    sc.bitfield.ffen = 0;
+    kp_spi_write_reg(spidev->controller_state, KP_SPI_REG_CONFIG, sc.reg);
+    return 0;
+}
+
+static int
+kp_spi_transfer_one_message(struct spi_master *master, struct spi_message *m)
+{
+    struct kp_spi_controller_state *cs;
+    struct spi_device   *spidev;
+    struct kp_spi       *kpspi;
+    struct spi_transfer *transfer;
+    union kp_spi_config sc;
+    int status = 0;
+    
+    spidev = m->spi;
+    kpspi = spi_master_get_devdata(master);
+    m->actual_length = 0;
+    m->status = 0;
+    
+    cs = spidev->controller_state;
+    
+    /* reject invalid messages and transfers */
+    if (list_empty(&m->transfers)) {
+        return -EINVAL;
+    }
+    
+    /* validate input */
+    list_for_each_entry(transfer, &m->transfers, transfer_list) {
+        const void *tx_buf = transfer->tx_buf;
+        void       *rx_buf = transfer->rx_buf;
+        unsigned    len = transfer->len;
+        
+        if (transfer->speed_hz > KP_SPI_CLK || (len && !(rx_buf || tx_buf))) {
+            dev_dbg(kpspi->dev, "  transfer: %d Hz, %d %s%s, %d bpw\n",
+                    transfer->speed_hz,
+                    len,
+                    tx_buf ? "tx" : "",
+                    rx_buf ? "rx" : "",
+                    transfer->bits_per_word);
+            dev_dbg(kpspi->dev, "  transfer -EINVAL\n");
+            return -EINVAL;
+        }
+        if (transfer->speed_hz && (transfer->speed_hz < (KP_SPI_CLK >> 15))) {
+            dev_dbg(kpspi->dev, "speed_hz %d below minimum %d Hz\n",
+                    transfer->speed_hz,
+                    KP_SPI_CLK >> 15);
+            dev_dbg(kpspi->dev, "  speed_hz -EINVAL\n");
+            return -EINVAL;
+        }
+    }
+    
+    /* assert chip select to start the sequence*/
+    sc.reg = kp_spi_read_reg(cs, KP_SPI_REG_CONFIG);
+    sc.bitfield.spi_en = 1;
+    kp_spi_write_reg(cs, KP_SPI_REG_CONFIG, sc.reg);
+    
+    /* work */
+    if (kp_spi_wait_for_reg_bit(cs, KP_SPI_REG_STATUS, KP_SPI_REG_STATUS_EOT) < 0) {
+        dev_info(kpspi->dev, "EOT timed out\n");
+        goto out;
+    }
+    
+    /* do the transfers for this message */
+    list_for_each_entry(transfer, &m->transfers, transfer_list) {
+        if (transfer->tx_buf == NULL && transfer->rx_buf == NULL && transfer->len) {
+            status = -EINVAL;
+            break;
+        }
+        
+        /* transfer */
+        if (transfer->len) {
+            unsigned int word_len = spidev->bits_per_word;
+            unsigned count;
+            
+            /* set up the transfer... */
+            sc.reg = kp_spi_read_reg(cs, KP_SPI_REG_CONFIG);
+            
+            /* ...direction */
+            if (transfer->tx_buf) {
+                sc.bitfield.trm = KP_SPI_REG_CONFIG_TRM_TX;
+            }
+            else if (transfer->rx_buf) {
+                sc.bitfield.trm = KP_SPI_REG_CONFIG_TRM_RX;
+            }
+            
+            /* ...word length */
+            if (transfer->bits_per_word) {
+                word_len = transfer->bits_per_word;
+            }
+            cs->word_len = word_len;
+            sc.bitfield.wl = word_len-1;
+            
+            /* ...chip select */
+            sc.bitfield.cs = spidev->chip_select;
+            
+            /* ...and write the new settings */
+            kp_spi_write_reg(cs, KP_SPI_REG_CONFIG, sc.reg);
+            
+            /* do the transfer */
+            count = kp_spi_txrx_pio(spidev, transfer);
+            m->actual_length += count;
+            
+            if (count != transfer->len) {
+                status = -EIO;
+                break;
+            }
+        }
+        
+        if (transfer->delay_usecs) {
+            udelay(transfer->delay_usecs);
+        }
+    }
+    
+    /* de-assert chip select to end the sequence */
+    sc.reg = kp_spi_read_reg(cs, KP_SPI_REG_CONFIG);
+    sc.bitfield.spi_en = 0;
+    kp_spi_write_reg(cs, KP_SPI_REG_CONFIG, sc.reg);
+    
+ out:
+    /* done work */
+    spi_finalize_current_message(master);
+    return 0;
+}
+
+static void
+kp_spi_cleanup(struct spi_device *spidev)
+{
+    struct kp_spi_controller_state *cs = spidev->controller_state;
+    if (cs) {
+        kfree(cs);
+    }
+}
+
+
+
+/******************
+ * Probe / Remove *
+ ******************/
+static int
+kp_spi_probe(struct platform_device *pldev)
+{
+    struct kpc_core_device_platdata *drvdata;
+    struct spi_master *master;
+    struct kp_spi *kpspi;
+    struct resource *r;
+    int status = 0;
+    int i;
+
+    drvdata = pldev->dev.platform_data;
+    if (!drvdata){
+        dev_err(&pldev->dev, "kp_spi_probe: platform_data is NULL!\n");
+        return -ENODEV;
+    }
+    
+    master = spi_alloc_master(&pldev->dev, sizeof(struct kp_spi));
+    if (master == NULL) {
+        dev_err(&pldev->dev, "kp_spi_probe: master allocation failed\n");
+        return -ENOMEM;
+    }
+    
+    /* set up the spi functions */
+    master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
+    master->bits_per_word_mask = (unsigned int)SPI_BPW_RANGE_MASK(4, 32);
+    master->setup = kp_spi_setup;
+    master->transfer_one_message = kp_spi_transfer_one_message;
+    master->cleanup = kp_spi_cleanup;
+    
+    platform_set_drvdata(pldev, master);
+    
+    kpspi = spi_master_get_devdata(master);
+    kpspi->master = master;
+    kpspi->dev = &pldev->dev;
+    
+    master->num_chipselect = 4;
+    if (pldev->id != -1) {
+        master->bus_num = pldev->id;
+    }
+    kpspi->pin_dir = 0;
+    
+    r = platform_get_resource(pldev, IORESOURCE_MEM, 0);
+    if (r == NULL) {
+        dev_err(&pldev->dev, "kp_spi_probe: Unable to get platform resources\n");
+        status = -ENODEV;
+        goto free_master;
+    }
+    
+    kpspi->phys = (unsigned long)ioremap_nocache(r->start, resource_size(r));
+    kpspi->base = (u64 __iomem *)kpspi->phys;
+    
+    status = spi_register_master(master);
+    if (status < 0) {
+        dev_err(&pldev->dev, "Unable to register SPI device\n");
+        goto free_master;
+    }
+    
+    /* register the slave boards */
+    #define NEW_SPI_DEVICE_FROM_BOARD_INFO_TABLE(table) \
+        for (i = 0 ; i < ARRAY_SIZE(table) ; i++) { \
+            spi_new_device(master, &(table[i])); \
+        }
+    
+    switch ((drvdata->card_id & 0xFFFF0000) >> 16){
+        case PCI_DEVICE_ID_DAKTRONICS_KADOKA_P2KR0:
+            NEW_SPI_DEVICE_FROM_BOARD_INFO_TABLE(p2kr0_board_info);
+            break;
+        default:
+            dev_err(&pldev->dev, "Unknown hardware, cant know what partition table to use!\n");
+            goto free_master;
+            break;
+    }
+    
+    return status;
+
+ free_master:
+    spi_master_put(master);
+    return status;
+}
+
+static int
+kp_spi_remove(struct platform_device *pldev)
+{
+    struct spi_master * master = platform_get_drvdata(pldev);
+    spi_unregister_master(master);
+    return 0;
+}
+
+
+static struct platform_driver kp_spi_driver = {
+    .driver = {
+        .name =     KP_DRIVER_NAME_SPI,
+    },
+    .probe =    kp_spi_probe,
+    .remove =   kp_spi_remove,
+};
+
+module_platform_driver(kp_spi_driver);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:kp_spi");
