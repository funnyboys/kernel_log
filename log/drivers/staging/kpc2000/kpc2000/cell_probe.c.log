commit f08ab0abb6990db3d93b917f6e701ba6b05d604e
Author: Harsh Jain <harshjain32@gmail.com>
Date:   Sat Aug 31 17:25:32 2019 +0530

    staging: kpc2000: Fix long constant sparse warning
    
    It fixed following warning in kpc2000 driver
    "constant XXXX is so big it is unsigned long"
    
    Signed-off-by: Harsh Jain <harshjain32@gmail.com>
    Link: https://lore.kernel.org/r/20190831115532.2398-1-harshjain32@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index c124a836db27..738122afc2ae 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -53,15 +53,15 @@ struct core_table_entry {
 static
 void  parse_core_table_entry_v0(struct core_table_entry *cte, const u64 read_val)
 {
-	cte->type                = ((read_val & 0xFFF0000000000000) >> 52);
-	cte->offset              = ((read_val & 0x00000000FFFF0000) >> 16) * 4096;
-	cte->length              = ((read_val & 0x0000FFFF00000000) >> 32) * 8;
-	cte->s2c_dma_present     = ((read_val & 0x0008000000000000) >> 51);
-	cte->s2c_dma_channel_num = ((read_val & 0x0007000000000000) >> 48);
-	cte->c2s_dma_present     = ((read_val & 0x0000000000008000) >> 15);
-	cte->c2s_dma_channel_num = ((read_val & 0x0000000000007000) >> 12);
-	cte->irq_count           = ((read_val & 0x0000000000000C00) >> 10);
-	cte->irq_base_num        = ((read_val & 0x00000000000003F8) >>  3);
+	cte->type                = ((read_val & 0xFFF0000000000000UL) >> 52);
+	cte->offset              = ((read_val & 0x00000000FFFF0000UL) >> 16) * 4096;
+	cte->length              = ((read_val & 0x0000FFFF00000000UL) >> 32) * 8;
+	cte->s2c_dma_present     = ((read_val & 0x0008000000000000UL) >> 51);
+	cte->s2c_dma_channel_num = ((read_val & 0x0007000000000000UL) >> 48);
+	cte->c2s_dma_present     = ((read_val & 0x0000000000008000UL) >> 15);
+	cte->c2s_dma_channel_num = ((read_val & 0x0000000000007000UL) >> 12);
+	cte->irq_count           = ((read_val & 0x0000000000000C00UL) >> 10);
+	cte->irq_base_num        = ((read_val & 0x00000000000003F8UL) >>  3);
 }
 
 static

commit d326d99aa00f284e4320aededb3f7c663f5b4c87
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jun 18 11:15:54 2019 +0100

    staging: kpc2000: fix integer overflow with left shifts
    
    Currently there are several left shifts that are assigned to 64 bit
    unsigned longs where a signed int 1 is being shifted, resulting in
    an integer overflow.  Fix this bit using the BIT_ULL macro to perform
    a 64 bit shift.  Also clean up an overly long statement.
    
    Addresses-Coverity: ("Unintentional integer overflow")
    Fixes: 7dc7967fc39a ("staging: kpc2000: add initial set of Daktronics drivers")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 138d16bcf6e1..c124a836db27 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -238,7 +238,7 @@ int  kp2000_check_uio_irq(struct kp2000_device *pcard, u32 irq_num)
 {
 	u64 interrupt_active   =  readq(pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE);
 	u64 interrupt_mask_inv = ~readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
-	u64 irq_check_mask = (1 << irq_num);
+	u64 irq_check_mask = BIT_ULL(irq_num);
 
 	if (interrupt_active & irq_check_mask) { // if it's active (interrupt pending)
 		if (interrupt_mask_inv & irq_check_mask) {    // and if it's not masked off
@@ -257,7 +257,9 @@ irqreturn_t  kuio_handler(int irq, struct uio_info *uioinfo)
 		return IRQ_NONE;
 
 	if (kp2000_check_uio_irq(kudev->pcard, kudev->cte.irq_base_num)) {
-		writeq((1 << kudev->cte.irq_base_num), kudev->pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE); // Clear the active flag
+		/* Clear the active flag */
+		writeq(BIT_ULL(kudev->cte.irq_base_num),
+		       kudev->pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE);
 		return IRQ_HANDLED;
 	}
 	return IRQ_NONE;
@@ -273,9 +275,9 @@ int kuio_irqcontrol(struct uio_info *uioinfo, s32 irq_on)
 	mutex_lock(&pcard->sem);
 	mask = readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
 	if (irq_on)
-		mask &= ~(1 << (kudev->cte.irq_base_num));
+		mask &= ~(BIT_ULL(kudev->cte.irq_base_num));
 	else
-		mask |= (1 << (kudev->cte.irq_base_num));
+		mask |= BIT_ULL(kudev->cte.irq_base_num);
 	writeq(mask, pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
 	mutex_unlock(&pcard->sem);
 

commit ac6ab6da5b49b63c58d2d1ef111751d272e77738
Author: Simon Sandström <simon@nikanor.nu>
Date:   Mon Jun 10 10:44:28 2019 +0200

    staging: kpc2000: remove unnecessary debug prints in cell_probe.c
    
    Debug prints that are used only to inform about function entry or exit
    can be removed as ftrace can be used to get this information.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index f731a97c6cac..138d16bcf6e1 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -344,8 +344,6 @@ static int  create_dma_engine_core(struct kp2000_device *pcard, size_t engine_re
 	struct mfd_cell  cell = { .id = engine_num };
 	struct resource  resources[2];
 
-	dev_dbg(&pcard->pdev->dev, "create_dma_core(pcard = [%p], engine_regs_offset = %zx, engine_num = %d)\n", pcard, engine_regs_offset, engine_num);
-
 	cell.platform_data = NULL;
 	cell.pdata_size = 0;
 	cell.name = KP_DRIVER_NAME_DMA_CONTROLLER;
@@ -414,9 +412,6 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
 	unsigned int highest_core_id = 0;
 	struct core_table_entry cte;
 
-	dev_dbg(&pcard->pdev->dev, "%s(pcard = %p / %d)\n", __func__, pcard,
-		pcard->card_num);
-
 	err = kp2000_setup_dma_controller(pcard);
 	if (err)
 		return err;

commit 75b785e749e9abc6c6c8f0697cfd22b87c150ecb
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu May 23 14:51:43 2019 +0200

    staging: kpc2000: remove unnecessary oom message
    
    Fixes checkpatch.pl warning "Possible unnecessary 'out of memory'
    message".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 5e65bd56d66e..f731a97c6cac 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -291,10 +291,8 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
 	dev_dbg(&pcard->pdev->dev, "Found UIO core:   type = %02d  dma = %02x / %02x  offset = 0x%x  length = 0x%x (%d regs)\n", cte.type, KPC_OLD_S2C_DMA_CH_NUM(cte), KPC_OLD_C2S_DMA_CH_NUM(cte), cte.offset, cte.length, cte.length / 8);
 
 	kudev = kzalloc(sizeof(*kudev), GFP_KERNEL);
-	if (!kudev) {
-		dev_err(&pcard->pdev->dev, "probe_core_uio: failed to kzalloc kpc_uio_device\n");
+	if (!kudev)
 		return -ENOMEM;
-	}
 
 	INIT_LIST_HEAD(&kudev->list);
 	kudev->pcard = pcard;

commit f8f31e5b76dae49a6226f6f97316cf64dbb1b375
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu May 23 14:51:42 2019 +0200

    staging: kpc2000: remove unnecessary include in cell_probe.c
    
    Fixes checkpatch.pl warning "Use #include <linux/io.h> instead of
    <asm/io.h>".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 682d61da5369..5e65bd56d66e 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -4,7 +4,6 @@
 #include <linux/types.h>
 #include <linux/export.h>
 #include <linux/slab.h>
-#include <asm/io.h>
 #include <linux/io.h>
 #include <linux/io-64-nonatomic-lo-hi.h>
 #include <linux/mfd/core.h>

commit ec09500e9cb76a278099d32596dae33a48e8ae0b
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu May 23 14:51:41 2019 +0200

    staging: kpc2000: remove unnecessary braces in cell_probe.c
    
    Fixes checkpatch.pl warnings "braces {} are not necessary for single
    statement blocks".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index caf48256aa2e..682d61da5369 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -273,11 +273,10 @@ int kuio_irqcontrol(struct uio_info *uioinfo, s32 irq_on)
 
 	mutex_lock(&pcard->sem);
 	mask = readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
-	if (irq_on) {
+	if (irq_on)
 		mask &= ~(1 << (kudev->cte.irq_base_num));
-	} else {
+	else
 		mask |= (1 << (kudev->cte.irq_base_num));
-	}
 	writeq(mask, pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
 	mutex_unlock(&pcard->sem);
 
@@ -432,12 +431,10 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
 		read_val = readq(pcard->sysinfo_regs_base + ((pcard->core_table_offset + i) * 8));
 		parse_core_table_entry(&cte, read_val, pcard->core_table_rev);
 		dbg_cte(pcard, &cte);
-		if (cte.type > highest_core_id) {
+		if (cte.type > highest_core_id)
 			highest_core_id = cte.type;
-		}
-		if (cte.type == KP_CORE_ID_INVALID) {
+		if (cte.type == KP_CORE_ID_INVALID)
 			dev_info(&pcard->pdev->dev, "Found Invalid core: %016llx\n", read_val);
-		}
 	}
 	// Then, iterate over the possible core types.
 	for (current_type_id = 1 ; current_type_id <= highest_core_id ; current_type_id++) {

commit 77290d4b7c0d78f73e6af047344f43b01c176321
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu May 23 14:51:40 2019 +0200

    staging: kpc2000: use kzalloc(sizeof(var)...) in cell_probe.c
    
    Fixes checkpatch.pl warning "Prefer kzalloc(sizeof(*kudev)...) over
    kzalloc(sizeof(struct kpc_uio_device)...)"
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index f8d19e693f21..caf48256aa2e 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -292,7 +292,7 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
 
 	dev_dbg(&pcard->pdev->dev, "Found UIO core:   type = %02d  dma = %02x / %02x  offset = 0x%x  length = 0x%x (%d regs)\n", cte.type, KPC_OLD_S2C_DMA_CH_NUM(cte), KPC_OLD_C2S_DMA_CH_NUM(cte), cte.offset, cte.length, cte.length / 8);
 
-	kudev = kzalloc(sizeof(struct kpc_uio_device), GFP_KERNEL);
+	kudev = kzalloc(sizeof(*kudev), GFP_KERNEL);
 	if (!kudev) {
 		dev_err(&pcard->pdev->dev, "probe_core_uio: failed to kzalloc kpc_uio_device\n");
 		return -ENOMEM;

commit 42143af99d2b8d880c7523a491e5e166e4cfd800
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu May 23 14:51:39 2019 +0200

    staging: kpc2000: remove extra blank lines in cell_probe.c
    
    Fixes checkpatch.pl warnings "Please don't use multiple blank lines".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 5b88504b00ec..f8d19e693f21 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -94,7 +94,6 @@ void parse_core_table_entry(struct core_table_entry *cte, const u64 read_val, co
 	}
 }
 
-
 static int probe_core_basic(unsigned int core_num, struct kp2000_device *pcard,
 			    char *name, const struct core_table_entry cte)
 {
@@ -111,7 +110,6 @@ static int probe_core_basic(unsigned int core_num, struct kp2000_device *pcard,
 
 	dev_dbg(&pcard->pdev->dev, "Found Basic core: type = %02d  dma = %02x / %02x  offset = 0x%x  length = 0x%x (%d regs)\n", cte.type, KPC_OLD_S2C_DMA_CH_NUM(cte), KPC_OLD_C2S_DMA_CH_NUM(cte), cte.offset, cte.length, cte.length / 8);
 
-
 	cell.platform_data = &core_pdata;
 	cell.pdata_size = sizeof(struct kpc_core_device_platdata);
 	cell.num_resources = 2;
@@ -137,7 +135,6 @@ static int probe_core_basic(unsigned int core_num, struct kp2000_device *pcard,
 			       NULL);                  // struct irq_domain *
 }
 
-
 struct kpc_uio_device {
 	struct list_head list;
 	struct kp2000_device *pcard;
@@ -346,7 +343,6 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
 	return 0;
 }
 
-
 static int  create_dma_engine_core(struct kp2000_device *pcard, size_t engine_regs_offset, int engine_num, int irq_num)
 {
 	struct mfd_cell  cell = { .id = engine_num };

commit 4f9d8b7e0ffd1e030350b4f8acda1d1446ead039
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu May 23 14:51:38 2019 +0200

    staging: kpc2000: fix alignment issues in cell_probe.c
    
    Fixes checkpatch.pl warnings "Alignment should match open parenthesis"
    and "Lines should not end with a '('".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 945d8e4e7ba5..5b88504b00ec 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -128,15 +128,13 @@ static int probe_core_basic(unsigned int core_num, struct kp2000_device *pcard,
 
 	cell.resources = resources;
 
-	return mfd_add_devices(
-		PCARD_TO_DEV(pcard),    // parent
-		pcard->card_num * 100,  // id
-		&cell,                  // struct mfd_cell *
-		1,                      // ndevs
-		&pcard->regs_base_resource,
-		0,                      // irq_base
-		NULL                    // struct irq_domain *
-	);
+	return mfd_add_devices(PCARD_TO_DEV(pcard),    // parent
+			       pcard->card_num * 100,  // id
+			       &cell,                  // struct mfd_cell *
+			       1,                      // ndevs
+			       &pcard->regs_base_resource,
+			       0,                      // irq_base
+			       NULL);                  // struct irq_domain *
 }
 
 
@@ -373,15 +371,13 @@ static int  create_dma_engine_core(struct kp2000_device *pcard, size_t engine_re
 
 	cell.resources = resources;
 
-	return mfd_add_devices(
-		PCARD_TO_DEV(pcard),    // parent
-		pcard->card_num * 100,  // id
-		&cell,                  // struct mfd_cell *
-		1,                      // ndevs
-		&pcard->dma_base_resource,
-		0,                      // irq_base
-		NULL                    // struct irq_domain *
-	);
+	return mfd_add_devices(PCARD_TO_DEV(pcard),    // parent
+			       pcard->card_num * 100,  // id
+			       &cell,                  // struct mfd_cell *
+			       1,                      // ndevs
+			       &pcard->dma_base_resource,
+			       0,                      // irq_base
+			       NULL);                  // struct irq_domain *
 }
 
 static int  kp2000_setup_dma_controller(struct kp2000_device *pcard)
@@ -462,7 +458,7 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
 			switch (cte.type) {
 			case KP_CORE_ID_I2C:
 				err = probe_core_basic(core_num, pcard,
-				KP_DRIVER_NAME_I2C, cte);
+						       KP_DRIVER_NAME_I2C, cte);
 				break;
 
 			case KP_CORE_ID_SPI:

commit 250b24410b8eed30a22afbc19826e3a0dece1f83
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu May 23 14:51:37 2019 +0200

    staging: kpc2000: add missing asterisk in comment
    
    Fixes checkpatch.pl error "code indent should use tabs where possible".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index b559ade04aca..945d8e4e7ba5 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -25,7 +25,7 @@
  *                                                              D                   C2S DMA Present
  *                                                               DDD                C2S DMA Channel Number    [up to 8 channels]
  *                                                                  II              IRQ Count [0 to 3 IRQs per core]
-                                                                      1111111000
+ *                                                                    1111111000
  *                                                                    IIIIIII       IRQ Base Number [up to 128 IRQs per card]
  *                                                                           ___    Spare
  *

commit 39cfdf55aadc6c05cae4286d7b685bea2102ad8c
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu May 23 14:51:36 2019 +0200

    staging: kpc2000: use __func__ in debug messages
    
    Fixes checkpatch.pl warning "Prefer using '"%s...", __func__' to using
    '<function name>', this function's name, in a string".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 95bfbe4aae4d..b559ade04aca 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -327,7 +327,8 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
 
 	kudev->dev = device_create(kpc_uio_class, &pcard->pdev->dev, MKDEV(0, 0), kudev, "%s.%d.%d.%d", kudev->uioinfo.name, pcard->card_num, cte.type, kudev->core_num);
 	if (IS_ERR(kudev->dev)) {
-		dev_err(&pcard->pdev->dev, "probe_core_uio device_create failed!\n");
+		dev_err(&pcard->pdev->dev, "%s: device_create failed!\n",
+			__func__);
 		kfree(kudev);
 		return -ENODEV;
 	}
@@ -335,7 +336,8 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
 
 	rv = uio_register_device(kudev->dev, &kudev->uioinfo);
 	if (rv) {
-		dev_err(&pcard->pdev->dev, "probe_core_uio failed uio_register_device: %d\n", rv);
+		dev_err(&pcard->pdev->dev, "%s: failed uio_register_device: %d\n",
+			__func__, rv);
 		put_device(kudev->dev);
 		kfree(kudev);
 		return rv;
@@ -410,7 +412,8 @@ static int  kp2000_setup_dma_controller(struct kp2000_device *pcard)
 	return 0;
 
 err_out:
-	dev_err(&pcard->pdev->dev, "kp2000_setup_dma_controller: failed to add a DMA Engine: %d\n", err);
+	dev_err(&pcard->pdev->dev, "%s: failed to add a DMA Engine: %d\n",
+		__func__, err);
 	return err;
 }
 
@@ -423,7 +426,8 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
 	unsigned int highest_core_id = 0;
 	struct core_table_entry cte;
 
-	dev_dbg(&pcard->pdev->dev, "kp2000_probe_cores(pcard = %p / %d)\n", pcard, pcard->card_num);
+	dev_dbg(&pcard->pdev->dev, "%s(pcard = %p / %d)\n", __func__, pcard,
+		pcard->card_num);
 
 	err = kp2000_setup_dma_controller(pcard);
 	if (err)
@@ -472,8 +476,8 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
 			}
 			if (err) {
 				dev_err(&pcard->pdev->dev,
-					"kp2000_probe_cores: failed to add core %d: %d\n",
-					i, err);
+					"%s: failed to add core %d: %d\n",
+					__func__, i, err);
 				goto error;
 			}
 			core_num++;
@@ -492,7 +496,8 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
 	cte.irq_base_num        = 0;
 	err = probe_core_uio(0, pcard, "kpc_uio", cte);
 	if (err) {
-		dev_err(&pcard->pdev->dev, "kp2000_probe_cores: failed to add board_info core: %d\n", err);
+		dev_err(&pcard->pdev->dev, "%s: failed to add board_info core: %d\n",
+			__func__, err);
 		goto error;
 	}
 

commit 9876ecaadddecc2f386d101fcfb5d02e4043e473
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu May 23 14:51:35 2019 +0200

    staging: kpc2000: add blank line after declarations
    
    Fixes checkpatch.pl warning "Missing a blank line after declarations".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index e5cddf0eeed3..95bfbe4aae4d 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -245,6 +245,7 @@ int  kp2000_check_uio_irq(struct kp2000_device *pcard, u32 irq_num)
 	u64 interrupt_active   =  readq(pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE);
 	u64 interrupt_mask_inv = ~readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
 	u64 irq_check_mask = (1 << irq_num);
+
 	if (interrupt_active & irq_check_mask) { // if it's active (interrupt pending)
 		if (interrupt_mask_inv & irq_check_mask) {    // and if it's not masked off
 			return 1;
@@ -257,6 +258,7 @@ static
 irqreturn_t  kuio_handler(int irq, struct uio_info *uioinfo)
 {
 	struct kpc_uio_device *kudev = uioinfo->priv;
+
 	if (irq != kudev->pcard->pdev->irq)
 		return IRQ_NONE;
 
@@ -506,8 +508,10 @@ void  kp2000_remove_cores(struct kp2000_device *pcard)
 {
 	struct list_head *ptr;
 	struct list_head *next;
+
 	list_for_each_safe(ptr, next, &pcard->uio_devices_list) {
 		struct kpc_uio_device *kudev = list_entry(ptr, struct kpc_uio_device, list);
+
 		uio_unregister_device(&kudev->uioinfo);
 		device_unregister(kudev->dev);
 		list_del(&kudev->list);

commit dcb76ad1f4c7b1d63988ea96d31ce561db5f63f7
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed May 22 22:58:49 2019 +0200

    staging: kpc2000: remove invalid spaces in cell_probe.c
    
    Fixes checkpatch.pl error "space prohibited before/after that
    parenthesis".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 5fa3cc28383b..e5cddf0eeed3 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -388,7 +388,7 @@ static int  kp2000_setup_dma_controller(struct kp2000_device *pcard)
 
 	// S2C Engines
 	for (i = 0 ; i < 32 ; i++) {
-		capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
+		capabilities_reg = readq(pcard->dma_bar_base + KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i));
 		if (capabilities_reg & ENGINE_CAP_PRESENT_MASK) {
 			err = create_dma_engine_core(pcard, (KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), i,  pcard->pdev->irq);
 			if (err)
@@ -397,7 +397,7 @@ static int  kp2000_setup_dma_controller(struct kp2000_device *pcard)
 	}
 	// C2S Engines
 	for (i = 0 ; i < 32 ; i++) {
-		capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
+		capabilities_reg = readq(pcard->dma_bar_base + KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i));
 		if (capabilities_reg & ENGINE_CAP_PRESENT_MASK) {
 			err = create_dma_engine_core(pcard, (KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), 32 + i,  pcard->pdev->irq);
 			if (err)

commit c2f894bc14c05dba3e5bf26a1ec11f2118eaa45c
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed May 22 22:58:48 2019 +0200

    staging: kpc2000: add space after comma in cell_probe.c
    
    Fixes checkpatch.pl error "space required after that ','".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index ee282d68e4f8..5fa3cc28383b 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -323,7 +323,7 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
 	kudev->uioinfo.mem[0].size = (cte.length + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1); // Round up to nearest PAGE_SIZE boundary
 	kudev->uioinfo.mem[0].memtype = UIO_MEM_PHYS;
 
-	kudev->dev = device_create(kpc_uio_class, &pcard->pdev->dev, MKDEV(0,0), kudev, "%s.%d.%d.%d", kudev->uioinfo.name, pcard->card_num, cte.type, kudev->core_num);
+	kudev->dev = device_create(kpc_uio_class, &pcard->pdev->dev, MKDEV(0, 0), kudev, "%s.%d.%d.%d", kudev->uioinfo.name, pcard->card_num, cte.type, kudev->core_num);
 	if (IS_ERR(kudev->dev)) {
 		dev_err(&pcard->pdev->dev, "probe_core_uio device_create failed!\n");
 		kfree(kudev);

commit c16265dd6f77641654f75119c3e9f615b817f620
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed May 22 22:58:47 2019 +0200

    staging: kpc2000: add spaces around operators in cell_probe.c
    
    Fixes checkpatch.pl warning "spaces preferred around that <op>".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 4e8ca56fe601..ee282d68e4f8 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -320,7 +320,7 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
 
 	kudev->uioinfo.mem[0].name = "uiomap";
 	kudev->uioinfo.mem[0].addr = pci_resource_start(pcard->pdev, REG_BAR) + cte.offset;
-	kudev->uioinfo.mem[0].size = (cte.length + PAGE_SIZE-1) & ~(PAGE_SIZE-1); // Round up to nearest PAGE_SIZE boundary
+	kudev->uioinfo.mem[0].size = (cte.length + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1); // Round up to nearest PAGE_SIZE boundary
 	kudev->uioinfo.mem[0].memtype = UIO_MEM_PHYS;
 
 	kudev->dev = device_create(kpc_uio_class, &pcard->pdev->dev, MKDEV(0,0), kudev, "%s.%d.%d.%d", kudev->uioinfo.name, pcard->card_num, cte.type, kudev->core_num);
@@ -399,7 +399,7 @@ static int  kp2000_setup_dma_controller(struct kp2000_device *pcard)
 	for (i = 0 ; i < 32 ; i++) {
 		capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
 		if (capabilities_reg & ENGINE_CAP_PRESENT_MASK) {
-			err = create_dma_engine_core(pcard, (KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), 32+i,  pcard->pdev->irq);
+			err = create_dma_engine_core(pcard, (KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), 32 + i,  pcard->pdev->irq);
 			if (err)
 				goto err_out;
 		}
@@ -481,7 +481,7 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
 	// Finally, instantiate a UIO device for the core_table.
 	cte.type                = 0; // CORE_ID_BOARD_INFO
 	cte.offset              = 0; // board info is always at the beginning
-	cte.length              = 512*8;
+	cte.length              = 512 * 8;
 	cte.s2c_dma_present     = false;
 	cte.s2c_dma_channel_num = 0;
 	cte.c2s_dma_present     = false;

commit d0a1a4b0e0fb6140022e5daf6f369efdec69dda1
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed May 22 22:58:46 2019 +0200

    staging: kpc2000: fix invalid linebreaks in cell_probe.c
    
    Fixes checkpatch.pl error "else should follow close brace '}'" and
    "trailing statements should be on next line".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 24979b8c0ed6..4e8ca56fe601 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -85,8 +85,12 @@ static
 void parse_core_table_entry(struct core_table_entry *cte, const u64 read_val, const u8 entry_rev)
 {
 	switch (entry_rev) {
-	case 0: parse_core_table_entry_v0(cte, read_val); break;
-	default: cte->type = 0; break;
+	case 0:
+		parse_core_table_entry_v0(cte, read_val);
+		break;
+	default:
+		cte->type = 0;
+		break;
 	}
 }
 
@@ -387,7 +391,8 @@ static int  kp2000_setup_dma_controller(struct kp2000_device *pcard)
 		capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
 		if (capabilities_reg & ENGINE_CAP_PRESENT_MASK) {
 			err = create_dma_engine_core(pcard, (KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), i,  pcard->pdev->irq);
-			if (err) goto err_out;
+			if (err)
+				goto err_out;
 		}
 	}
 	// C2S Engines
@@ -395,7 +400,8 @@ static int  kp2000_setup_dma_controller(struct kp2000_device *pcard)
 		capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
 		if (capabilities_reg & ENGINE_CAP_PRESENT_MASK) {
 			err = create_dma_engine_core(pcard, (KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), 32+i,  pcard->pdev->irq);
-			if (err) goto err_out;
+			if (err)
+				goto err_out;
 		}
 	}
 
@@ -418,7 +424,8 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
 	dev_dbg(&pcard->pdev->dev, "kp2000_probe_cores(pcard = %p / %d)\n", pcard, pcard->card_num);
 
 	err = kp2000_setup_dma_controller(pcard);
-	if (err) return err;
+	if (err)
+		return err;
 
 	INIT_LIST_HEAD(&pcard->uio_devices_list);
 

commit e55c49b892f90bb62988541bcf23ae5eae52c10a
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed May 22 22:58:45 2019 +0200

    staging: kpc2000: add space between ) and { in cell_probe.c
    
    Fixes checkpatch.pl error "space required before the open brace '{'".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index fa7f10b8c10c..24979b8c0ed6 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -241,8 +241,8 @@ int  kp2000_check_uio_irq(struct kp2000_device *pcard, u32 irq_num)
 	u64 interrupt_active   =  readq(pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE);
 	u64 interrupt_mask_inv = ~readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
 	u64 irq_check_mask = (1 << irq_num);
-	if (interrupt_active & irq_check_mask){ // if it's active (interrupt pending)
-		if (interrupt_mask_inv & irq_check_mask){    // and if it's not masked off
+	if (interrupt_active & irq_check_mask) { // if it's active (interrupt pending)
+		if (interrupt_mask_inv & irq_check_mask) {    // and if it's not masked off
 			return 1;
 		}
 	}
@@ -256,7 +256,7 @@ irqreturn_t  kuio_handler(int irq, struct uio_info *uioinfo)
 	if (irq != kudev->pcard->pdev->irq)
 		return IRQ_NONE;
 
-	if (kp2000_check_uio_irq(kudev->pcard, kudev->cte.irq_base_num)){
+	if (kp2000_check_uio_irq(kudev->pcard, kudev->cte.irq_base_num)) {
 		writeq((1 << kudev->cte.irq_base_num), kudev->pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE); // Clear the active flag
 		return IRQ_HANDLED;
 	}
@@ -272,7 +272,7 @@ int kuio_irqcontrol(struct uio_info *uioinfo, s32 irq_on)
 
 	mutex_lock(&pcard->sem);
 	mask = readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
-	if (irq_on){
+	if (irq_on) {
 		mask &= ~(1 << (kudev->cte.irq_base_num));
 	} else {
 		mask |= (1 << (kudev->cte.irq_base_num));
@@ -292,7 +292,7 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
 	dev_dbg(&pcard->pdev->dev, "Found UIO core:   type = %02d  dma = %02x / %02x  offset = 0x%x  length = 0x%x (%d regs)\n", cte.type, KPC_OLD_S2C_DMA_CH_NUM(cte), KPC_OLD_C2S_DMA_CH_NUM(cte), cte.offset, cte.length, cte.length / 8);
 
 	kudev = kzalloc(sizeof(struct kpc_uio_device), GFP_KERNEL);
-	if (!kudev){
+	if (!kudev) {
 		dev_err(&pcard->pdev->dev, "probe_core_uio: failed to kzalloc kpc_uio_device\n");
 		return -ENOMEM;
 	}
@@ -305,7 +305,7 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
 	kudev->uioinfo.priv = kudev;
 	kudev->uioinfo.name = name;
 	kudev->uioinfo.version = "0.0";
-	if (cte.irq_count > 0){
+	if (cte.irq_count > 0) {
 		kudev->uioinfo.irq_flags = IRQF_SHARED;
 		kudev->uioinfo.irq = pcard->pdev->irq;
 		kudev->uioinfo.handler = kuio_handler;
@@ -328,7 +328,7 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
 	dev_set_drvdata(kudev->dev, kudev);
 
 	rv = uio_register_device(kudev->dev, &kudev->uioinfo);
-	if (rv){
+	if (rv) {
 		dev_err(&pcard->pdev->dev, "probe_core_uio failed uio_register_device: %d\n", rv);
 		put_device(kudev->dev);
 		kfree(kudev);
@@ -383,17 +383,17 @@ static int  kp2000_setup_dma_controller(struct kp2000_device *pcard)
 	u64 capabilities_reg;
 
 	// S2C Engines
-	for (i = 0 ; i < 32 ; i++){
+	for (i = 0 ; i < 32 ; i++) {
 		capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
-		if (capabilities_reg & ENGINE_CAP_PRESENT_MASK){
+		if (capabilities_reg & ENGINE_CAP_PRESENT_MASK) {
 			err = create_dma_engine_core(pcard, (KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), i,  pcard->pdev->irq);
 			if (err) goto err_out;
 		}
 	}
 	// C2S Engines
-	for (i = 0 ; i < 32 ; i++){
+	for (i = 0 ; i < 32 ; i++) {
 		capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
-		if (capabilities_reg & ENGINE_CAP_PRESENT_MASK){
+		if (capabilities_reg & ENGINE_CAP_PRESENT_MASK) {
 			err = create_dma_engine_core(pcard, (KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), 32+i,  pcard->pdev->irq);
 			if (err) goto err_out;
 		}
@@ -423,23 +423,23 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
 	INIT_LIST_HEAD(&pcard->uio_devices_list);
 
 	// First, iterate the core table looking for the highest CORE_ID
-	for (i = 0 ; i < pcard->core_table_length ; i++){
+	for (i = 0 ; i < pcard->core_table_length ; i++) {
 		read_val = readq(pcard->sysinfo_regs_base + ((pcard->core_table_offset + i) * 8));
 		parse_core_table_entry(&cte, read_val, pcard->core_table_rev);
 		dbg_cte(pcard, &cte);
-		if (cte.type > highest_core_id){
+		if (cte.type > highest_core_id) {
 			highest_core_id = cte.type;
 		}
-		if (cte.type == KP_CORE_ID_INVALID){
+		if (cte.type == KP_CORE_ID_INVALID) {
 			dev_info(&pcard->pdev->dev, "Found Invalid core: %016llx\n", read_val);
 		}
 	}
 	// Then, iterate over the possible core types.
-	for (current_type_id = 1 ; current_type_id <= highest_core_id ; current_type_id++){
+	for (current_type_id = 1 ; current_type_id <= highest_core_id ; current_type_id++) {
 		unsigned int core_num = 0;
 		// Foreach core type, iterate the whole table and instantiate subdevices for each core.
 		// Yes, this is O(n*m) but the actual runtime is small enough that it's an acceptable tradeoff.
-		for (i = 0 ; i < pcard->core_table_length ; i++){
+		for (i = 0 ; i < pcard->core_table_length ; i++) {
 			read_val = readq(pcard->sysinfo_regs_base + ((pcard->core_table_offset + i) * 8));
 			parse_core_table_entry(&cte, read_val, pcard->core_table_rev);
 
@@ -482,7 +482,7 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
 	cte.irq_count           = 0;
 	cte.irq_base_num        = 0;
 	err = probe_core_uio(0, pcard, "kpc_uio", cte);
-	if (err){
+	if (err) {
 		dev_err(&pcard->pdev->dev, "kp2000_probe_cores: failed to add board_info core: %d\n", err);
 		goto error;
 	}
@@ -499,7 +499,7 @@ void  kp2000_remove_cores(struct kp2000_device *pcard)
 {
 	struct list_head *ptr;
 	struct list_head *next;
-	list_for_each_safe(ptr, next, &pcard->uio_devices_list){
+	list_for_each_safe(ptr, next, &pcard->uio_devices_list) {
 		struct kpc_uio_device *kudev = list_entry(ptr, struct kpc_uio_device, list);
 		uio_unregister_device(&kudev->uioinfo);
 		device_unregister(kudev->dev);

commit a924e3ac037e32bbdd56fc42fe07cf24607b9e80
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed May 22 22:58:44 2019 +0200

    staging: kpc2000: fix indent in cell_probe.c
    
    Use tabs instead of spaces for indentation.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 0181b0a8ff82..fa7f10b8c10c 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -40,45 +40,45 @@
 #define KP_CORE_ID_SPI          5
 
 struct core_table_entry {
-    u16     type;
-    u32     offset;
-    u32     length;
-    bool    s2c_dma_present;
-    u8      s2c_dma_channel_num;
-    bool    c2s_dma_present;
-    u8      c2s_dma_channel_num;
-    u8      irq_count;
-    u8      irq_base_num;
+	u16  type;
+	u32  offset;
+	u32  length;
+	bool s2c_dma_present;
+	u8   s2c_dma_channel_num;
+	bool c2s_dma_present;
+	u8   c2s_dma_channel_num;
+	u8   irq_count;
+	u8   irq_base_num;
 };
 
 static
 void  parse_core_table_entry_v0(struct core_table_entry *cte, const u64 read_val)
 {
-    cte->type                = ((read_val & 0xFFF0000000000000) >> 52);
-    cte->offset              = ((read_val & 0x00000000FFFF0000) >> 16) * 4096;
-    cte->length              = ((read_val & 0x0000FFFF00000000) >> 32) * 8;
-    cte->s2c_dma_present     = ((read_val & 0x0008000000000000) >> 51);
-    cte->s2c_dma_channel_num = ((read_val & 0x0007000000000000) >> 48);
-    cte->c2s_dma_present     = ((read_val & 0x0000000000008000) >> 15);
-    cte->c2s_dma_channel_num = ((read_val & 0x0000000000007000) >> 12);
-    cte->irq_count           = ((read_val & 0x0000000000000C00) >> 10);
-    cte->irq_base_num        = ((read_val & 0x00000000000003F8) >>  3);
+	cte->type                = ((read_val & 0xFFF0000000000000) >> 52);
+	cte->offset              = ((read_val & 0x00000000FFFF0000) >> 16) * 4096;
+	cte->length              = ((read_val & 0x0000FFFF00000000) >> 32) * 8;
+	cte->s2c_dma_present     = ((read_val & 0x0008000000000000) >> 51);
+	cte->s2c_dma_channel_num = ((read_val & 0x0007000000000000) >> 48);
+	cte->c2s_dma_present     = ((read_val & 0x0000000000008000) >> 15);
+	cte->c2s_dma_channel_num = ((read_val & 0x0000000000007000) >> 12);
+	cte->irq_count           = ((read_val & 0x0000000000000C00) >> 10);
+	cte->irq_base_num        = ((read_val & 0x00000000000003F8) >>  3);
 }
 
 static
 void dbg_cte(struct kp2000_device *pcard, struct core_table_entry *cte)
 {
-    dev_dbg(&pcard->pdev->dev, "CTE: type:%3d  offset:%3d (%3d)  length:%3d (%3d)  s2c:%d  c2s:%d  irq_count:%d  base_irq:%d\n",
-        cte->type,
-        cte->offset,
-        cte->offset / 4096,
-        cte->length,
-        cte->length / 8,
-        (cte->s2c_dma_present ? cte->s2c_dma_channel_num : -1),
-        (cte->c2s_dma_present ? cte->c2s_dma_channel_num : -1),
-        cte->irq_count,
-        cte->irq_base_num
-    );
+	dev_dbg(&pcard->pdev->dev, "CTE: type:%3d  offset:%3d (%3d)  length:%3d (%3d)  s2c:%d  c2s:%d  irq_count:%d  base_irq:%d\n",
+		cte->type,
+		cte->offset,
+		cte->offset / 4096,
+		cte->length,
+		cte->length / 8,
+		(cte->s2c_dma_present ? cte->s2c_dma_channel_num : -1),
+		(cte->c2s_dma_present ? cte->c2s_dma_channel_num : -1),
+		cte->irq_count,
+		cte->irq_base_num
+	);
 }
 
 static
@@ -94,55 +94,55 @@ void parse_core_table_entry(struct core_table_entry *cte, const u64 read_val, co
 static int probe_core_basic(unsigned int core_num, struct kp2000_device *pcard,
 			    char *name, const struct core_table_entry cte)
 {
-    struct mfd_cell  cell = { .id = core_num, .name = name };
-    struct resource  resources[2];
+	struct mfd_cell  cell = { .id = core_num, .name = name };
+	struct resource resources[2];
 
-    struct kpc_core_device_platdata  core_pdata = {
-        .card_id           = pcard->card_id,
-        .build_version     = pcard->build_version,
-        .hardware_revision = pcard->hardware_revision,
-        .ssid              = pcard->ssid,
-        .ddna              = pcard->ddna,
-    };
+	struct kpc_core_device_platdata core_pdata = {
+		.card_id           = pcard->card_id,
+		.build_version     = pcard->build_version,
+		.hardware_revision = pcard->hardware_revision,
+		.ssid              = pcard->ssid,
+		.ddna              = pcard->ddna,
+	};
 
-    dev_dbg(&pcard->pdev->dev, "Found Basic core: type = %02d  dma = %02x / %02x  offset = 0x%x  length = 0x%x (%d regs)\n", cte.type, KPC_OLD_S2C_DMA_CH_NUM(cte), KPC_OLD_C2S_DMA_CH_NUM(cte), cte.offset, cte.length, cte.length / 8);
+	dev_dbg(&pcard->pdev->dev, "Found Basic core: type = %02d  dma = %02x / %02x  offset = 0x%x  length = 0x%x (%d regs)\n", cte.type, KPC_OLD_S2C_DMA_CH_NUM(cte), KPC_OLD_C2S_DMA_CH_NUM(cte), cte.offset, cte.length, cte.length / 8);
 
 
-    cell.platform_data = &core_pdata;
-    cell.pdata_size = sizeof(struct kpc_core_device_platdata);
-    cell.num_resources = 2;
+	cell.platform_data = &core_pdata;
+	cell.pdata_size = sizeof(struct kpc_core_device_platdata);
+	cell.num_resources = 2;
 
-    memset(&resources, 0, sizeof(resources));
+	memset(&resources, 0, sizeof(resources));
 
-    resources[0].start = cte.offset;
-    resources[0].end   = cte.offset + (cte.length - 1);
-    resources[0].flags = IORESOURCE_MEM;
+	resources[0].start = cte.offset;
+	resources[0].end   = cte.offset + (cte.length - 1);
+	resources[0].flags = IORESOURCE_MEM;
 
-    resources[1].start = pcard->pdev->irq;
-    resources[1].end   = pcard->pdev->irq;
-    resources[1].flags = IORESOURCE_IRQ;
+	resources[1].start = pcard->pdev->irq;
+	resources[1].end   = pcard->pdev->irq;
+	resources[1].flags = IORESOURCE_IRQ;
 
-    cell.resources = resources;
+	cell.resources = resources;
 
-    return mfd_add_devices(
-        PCARD_TO_DEV(pcard),    // parent
-        pcard->card_num * 100,  // id
-        &cell,                  // struct mfd_cell *
-        1,                      // ndevs
-        &pcard->regs_base_resource,
-        0,                      // irq_base
-        NULL                    // struct irq_domain *
-    );
+	return mfd_add_devices(
+		PCARD_TO_DEV(pcard),    // parent
+		pcard->card_num * 100,  // id
+		&cell,                  // struct mfd_cell *
+		1,                      // ndevs
+		&pcard->regs_base_resource,
+		0,                      // irq_base
+		NULL                    // struct irq_domain *
+	);
 }
 
 
 struct kpc_uio_device {
-    struct list_head list;
-    struct kp2000_device *pcard;
-    struct device  *dev;
-    struct uio_info uioinfo;
-    struct core_table_entry cte;
-    u16 core_num;
+	struct list_head list;
+	struct kp2000_device *pcard;
+	struct device  *dev;
+	struct uio_info uioinfo;
+	struct core_table_entry cte;
+	u16 core_num;
 };
 
 static ssize_t offset_show(struct device *dev, struct device_attribute *attr,
@@ -238,273 +238,273 @@ struct attribute *kpc_uio_class_attrs[] = {
 static
 int  kp2000_check_uio_irq(struct kp2000_device *pcard, u32 irq_num)
 {
-    u64 interrupt_active   =  readq(pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE);
-    u64 interrupt_mask_inv = ~readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
-    u64 irq_check_mask = (1 << irq_num);
-    if (interrupt_active & irq_check_mask){ // if it's active (interrupt pending)
-        if (interrupt_mask_inv & irq_check_mask){    // and if it's not masked off
-            return 1;
-        }
-    }
-    return 0;
+	u64 interrupt_active   =  readq(pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE);
+	u64 interrupt_mask_inv = ~readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
+	u64 irq_check_mask = (1 << irq_num);
+	if (interrupt_active & irq_check_mask){ // if it's active (interrupt pending)
+		if (interrupt_mask_inv & irq_check_mask){    // and if it's not masked off
+			return 1;
+		}
+	}
+	return 0;
 }
 
 static
 irqreturn_t  kuio_handler(int irq, struct uio_info *uioinfo)
 {
-    struct kpc_uio_device *kudev = uioinfo->priv;
-    if (irq != kudev->pcard->pdev->irq)
-        return IRQ_NONE;
-
-    if (kp2000_check_uio_irq(kudev->pcard, kudev->cte.irq_base_num)){
-        writeq((1 << kudev->cte.irq_base_num), kudev->pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE); // Clear the active flag
-        return IRQ_HANDLED;
-    }
-    return IRQ_NONE;
+	struct kpc_uio_device *kudev = uioinfo->priv;
+	if (irq != kudev->pcard->pdev->irq)
+		return IRQ_NONE;
+
+	if (kp2000_check_uio_irq(kudev->pcard, kudev->cte.irq_base_num)){
+		writeq((1 << kudev->cte.irq_base_num), kudev->pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE); // Clear the active flag
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
 }
 
 static
 int kuio_irqcontrol(struct uio_info *uioinfo, s32 irq_on)
 {
-    struct kpc_uio_device *kudev = uioinfo->priv;
-    struct kp2000_device *pcard = kudev->pcard;
-    u64 mask;
+	struct kpc_uio_device *kudev = uioinfo->priv;
+	struct kp2000_device *pcard = kudev->pcard;
+	u64 mask;
 
 	mutex_lock(&pcard->sem);
-    mask = readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
-    if (irq_on){
-        mask &= ~(1 << (kudev->cte.irq_base_num));
-    } else {
-        mask |= (1 << (kudev->cte.irq_base_num));
-    }
-    writeq(mask, pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
+	mask = readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
+	if (irq_on){
+		mask &= ~(1 << (kudev->cte.irq_base_num));
+	} else {
+		mask |= (1 << (kudev->cte.irq_base_num));
+	}
+	writeq(mask, pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
 	mutex_unlock(&pcard->sem);
 
-    return 0;
+	return 0;
 }
 
 static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
 			  char *name, const struct core_table_entry cte)
 {
-    struct kpc_uio_device  *kudev;
-    int rv;
-
-    dev_dbg(&pcard->pdev->dev, "Found UIO core:   type = %02d  dma = %02x / %02x  offset = 0x%x  length = 0x%x (%d regs)\n", cte.type, KPC_OLD_S2C_DMA_CH_NUM(cte), KPC_OLD_C2S_DMA_CH_NUM(cte), cte.offset, cte.length, cte.length / 8);
-
-    kudev = kzalloc(sizeof(struct kpc_uio_device), GFP_KERNEL);
-    if (!kudev){
-        dev_err(&pcard->pdev->dev, "probe_core_uio: failed to kzalloc kpc_uio_device\n");
-        return -ENOMEM;
-    }
-
-    INIT_LIST_HEAD(&kudev->list);
-    kudev->pcard = pcard;
-    kudev->cte = cte;
-    kudev->core_num = core_num;
-
-    kudev->uioinfo.priv = kudev;
-    kudev->uioinfo.name = name;
-    kudev->uioinfo.version = "0.0";
-    if (cte.irq_count > 0){
-        kudev->uioinfo.irq_flags = IRQF_SHARED;
-        kudev->uioinfo.irq = pcard->pdev->irq;
-        kudev->uioinfo.handler = kuio_handler;
-        kudev->uioinfo.irqcontrol = kuio_irqcontrol;
-    } else {
-        kudev->uioinfo.irq = 0;
-    }
-
-    kudev->uioinfo.mem[0].name = "uiomap";
-    kudev->uioinfo.mem[0].addr = pci_resource_start(pcard->pdev, REG_BAR) + cte.offset;
-    kudev->uioinfo.mem[0].size = (cte.length + PAGE_SIZE-1) & ~(PAGE_SIZE-1); // Round up to nearest PAGE_SIZE boundary
-    kudev->uioinfo.mem[0].memtype = UIO_MEM_PHYS;
-
-    kudev->dev = device_create(kpc_uio_class, &pcard->pdev->dev, MKDEV(0,0), kudev, "%s.%d.%d.%d", kudev->uioinfo.name, pcard->card_num, cte.type, kudev->core_num);
-    if (IS_ERR(kudev->dev)) {
-        dev_err(&pcard->pdev->dev, "probe_core_uio device_create failed!\n");
-        kfree(kudev);
-        return -ENODEV;
-    }
-    dev_set_drvdata(kudev->dev, kudev);
-
-    rv = uio_register_device(kudev->dev, &kudev->uioinfo);
-    if (rv){
-        dev_err(&pcard->pdev->dev, "probe_core_uio failed uio_register_device: %d\n", rv);
-        put_device(kudev->dev);
-        kfree(kudev);
-        return rv;
-    }
-
-    list_add_tail(&kudev->list, &pcard->uio_devices_list);
-
-    return 0;
+	struct kpc_uio_device *kudev;
+	int rv;
+
+	dev_dbg(&pcard->pdev->dev, "Found UIO core:   type = %02d  dma = %02x / %02x  offset = 0x%x  length = 0x%x (%d regs)\n", cte.type, KPC_OLD_S2C_DMA_CH_NUM(cte), KPC_OLD_C2S_DMA_CH_NUM(cte), cte.offset, cte.length, cte.length / 8);
+
+	kudev = kzalloc(sizeof(struct kpc_uio_device), GFP_KERNEL);
+	if (!kudev){
+		dev_err(&pcard->pdev->dev, "probe_core_uio: failed to kzalloc kpc_uio_device\n");
+		return -ENOMEM;
+	}
+
+	INIT_LIST_HEAD(&kudev->list);
+	kudev->pcard = pcard;
+	kudev->cte = cte;
+	kudev->core_num = core_num;
+
+	kudev->uioinfo.priv = kudev;
+	kudev->uioinfo.name = name;
+	kudev->uioinfo.version = "0.0";
+	if (cte.irq_count > 0){
+		kudev->uioinfo.irq_flags = IRQF_SHARED;
+		kudev->uioinfo.irq = pcard->pdev->irq;
+		kudev->uioinfo.handler = kuio_handler;
+		kudev->uioinfo.irqcontrol = kuio_irqcontrol;
+	} else {
+		kudev->uioinfo.irq = 0;
+	}
+
+	kudev->uioinfo.mem[0].name = "uiomap";
+	kudev->uioinfo.mem[0].addr = pci_resource_start(pcard->pdev, REG_BAR) + cte.offset;
+	kudev->uioinfo.mem[0].size = (cte.length + PAGE_SIZE-1) & ~(PAGE_SIZE-1); // Round up to nearest PAGE_SIZE boundary
+	kudev->uioinfo.mem[0].memtype = UIO_MEM_PHYS;
+
+	kudev->dev = device_create(kpc_uio_class, &pcard->pdev->dev, MKDEV(0,0), kudev, "%s.%d.%d.%d", kudev->uioinfo.name, pcard->card_num, cte.type, kudev->core_num);
+	if (IS_ERR(kudev->dev)) {
+		dev_err(&pcard->pdev->dev, "probe_core_uio device_create failed!\n");
+		kfree(kudev);
+		return -ENODEV;
+	}
+	dev_set_drvdata(kudev->dev, kudev);
+
+	rv = uio_register_device(kudev->dev, &kudev->uioinfo);
+	if (rv){
+		dev_err(&pcard->pdev->dev, "probe_core_uio failed uio_register_device: %d\n", rv);
+		put_device(kudev->dev);
+		kfree(kudev);
+		return rv;
+	}
+
+	list_add_tail(&kudev->list, &pcard->uio_devices_list);
+
+	return 0;
 }
 
 
 static int  create_dma_engine_core(struct kp2000_device *pcard, size_t engine_regs_offset, int engine_num, int irq_num)
 {
-    struct mfd_cell  cell = { .id = engine_num };
-    struct resource  resources[2];
+	struct mfd_cell  cell = { .id = engine_num };
+	struct resource  resources[2];
 
-    dev_dbg(&pcard->pdev->dev, "create_dma_core(pcard = [%p], engine_regs_offset = %zx, engine_num = %d)\n", pcard, engine_regs_offset, engine_num);
+	dev_dbg(&pcard->pdev->dev, "create_dma_core(pcard = [%p], engine_regs_offset = %zx, engine_num = %d)\n", pcard, engine_regs_offset, engine_num);
 
-    cell.platform_data = NULL;
-    cell.pdata_size = 0;
-    cell.name = KP_DRIVER_NAME_DMA_CONTROLLER;
-    cell.num_resources = 2;
+	cell.platform_data = NULL;
+	cell.pdata_size = 0;
+	cell.name = KP_DRIVER_NAME_DMA_CONTROLLER;
+	cell.num_resources = 2;
 
-    memset(&resources, 0, sizeof(resources));
+	memset(&resources, 0, sizeof(resources));
 
-    resources[0].start = engine_regs_offset;
-    resources[0].end   = engine_regs_offset + (KPC_DMA_ENGINE_SIZE - 1);
-    resources[0].flags = IORESOURCE_MEM;
+	resources[0].start = engine_regs_offset;
+	resources[0].end   = engine_regs_offset + (KPC_DMA_ENGINE_SIZE - 1);
+	resources[0].flags = IORESOURCE_MEM;
 
-    resources[1].start = irq_num;
-    resources[1].end   = irq_num;
-    resources[1].flags = IORESOURCE_IRQ;
+	resources[1].start = irq_num;
+	resources[1].end   = irq_num;
+	resources[1].flags = IORESOURCE_IRQ;
 
-    cell.resources = resources;
+	cell.resources = resources;
 
-    return mfd_add_devices(
-        PCARD_TO_DEV(pcard),    // parent
-        pcard->card_num * 100,  // id
-        &cell,                  // struct mfd_cell *
-        1,                      // ndevs
-        &pcard->dma_base_resource,
-        0,                      // irq_base
-        NULL                    // struct irq_domain *
-    );
+	return mfd_add_devices(
+		PCARD_TO_DEV(pcard),    // parent
+		pcard->card_num * 100,  // id
+		&cell,                  // struct mfd_cell *
+		1,                      // ndevs
+		&pcard->dma_base_resource,
+		0,                      // irq_base
+		NULL                    // struct irq_domain *
+	);
 }
 
 static int  kp2000_setup_dma_controller(struct kp2000_device *pcard)
 {
-    int err;
-    unsigned int i;
-    u64 capabilities_reg;
-
-    // S2C Engines
-    for (i = 0 ; i < 32 ; i++){
-        capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
-        if (capabilities_reg & ENGINE_CAP_PRESENT_MASK){
-            err = create_dma_engine_core(pcard, (KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), i,  pcard->pdev->irq);
-            if (err) goto err_out;
-        }
-    }
-    // C2S Engines
-    for (i = 0 ; i < 32 ; i++){
-        capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
-        if (capabilities_reg & ENGINE_CAP_PRESENT_MASK){
-            err = create_dma_engine_core(pcard, (KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), 32+i,  pcard->pdev->irq);
-            if (err) goto err_out;
-        }
-    }
-
-    return 0;
+	int err;
+	unsigned int i;
+	u64 capabilities_reg;
+
+	// S2C Engines
+	for (i = 0 ; i < 32 ; i++){
+		capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
+		if (capabilities_reg & ENGINE_CAP_PRESENT_MASK){
+			err = create_dma_engine_core(pcard, (KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), i,  pcard->pdev->irq);
+			if (err) goto err_out;
+		}
+	}
+	// C2S Engines
+	for (i = 0 ; i < 32 ; i++){
+		capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
+		if (capabilities_reg & ENGINE_CAP_PRESENT_MASK){
+			err = create_dma_engine_core(pcard, (KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), 32+i,  pcard->pdev->irq);
+			if (err) goto err_out;
+		}
+	}
+
+	return 0;
 
 err_out:
-    dev_err(&pcard->pdev->dev, "kp2000_setup_dma_controller: failed to add a DMA Engine: %d\n", err);
-    return err;
+	dev_err(&pcard->pdev->dev, "kp2000_setup_dma_controller: failed to add a DMA Engine: %d\n", err);
+	return err;
 }
 
 int  kp2000_probe_cores(struct kp2000_device *pcard)
 {
-    int err = 0;
-    int i;
-    int current_type_id;
-    u64 read_val;
-    unsigned int highest_core_id = 0;
-    struct core_table_entry cte;
-
-    dev_dbg(&pcard->pdev->dev, "kp2000_probe_cores(pcard = %p / %d)\n", pcard, pcard->card_num);
-
-    err = kp2000_setup_dma_controller(pcard);
-    if (err) return err;
-
-    INIT_LIST_HEAD(&pcard->uio_devices_list);
-
-    // First, iterate the core table looking for the highest CORE_ID
-    for (i = 0 ; i < pcard->core_table_length ; i++){
-        read_val = readq(pcard->sysinfo_regs_base + ((pcard->core_table_offset + i) * 8));
-        parse_core_table_entry(&cte, read_val, pcard->core_table_rev);
-        dbg_cte(pcard, &cte);
-        if (cte.type > highest_core_id){
-            highest_core_id = cte.type;
-        }
-        if (cte.type == KP_CORE_ID_INVALID){
-            dev_info(&pcard->pdev->dev, "Found Invalid core: %016llx\n", read_val);
-        }
-    }
-    // Then, iterate over the possible core types.
-    for (current_type_id = 1 ; current_type_id <= highest_core_id ; current_type_id++){
-        unsigned int core_num = 0;
-        // Foreach core type, iterate the whole table and instantiate subdevices for each core.
-        // Yes, this is O(n*m) but the actual runtime is small enough that it's an acceptable tradeoff.
-        for (i = 0 ; i < pcard->core_table_length ; i++){
-            read_val = readq(pcard->sysinfo_regs_base + ((pcard->core_table_offset + i) * 8));
-            parse_core_table_entry(&cte, read_val, pcard->core_table_rev);
-
-            if (cte.type != current_type_id)
-                continue;
-
-            switch (cte.type) {
-            case KP_CORE_ID_I2C:
-                err = probe_core_basic(core_num, pcard,
-                                       KP_DRIVER_NAME_I2C, cte);
-                break;
-
-            case KP_CORE_ID_SPI:
-                err = probe_core_basic(core_num, pcard,
-                                       KP_DRIVER_NAME_SPI, cte);
-                break;
-
-            default:
-                err = probe_core_uio(core_num, pcard, "kpc_uio", cte);
-                break;
-            }
-            if (err) {
-                dev_err(&pcard->pdev->dev,
-                        "kp2000_probe_cores: failed to add core %d: %d\n",
-                        i, err);
-                goto error;
-            }
-            core_num++;
-        }
-    }
-
-    // Finally, instantiate a UIO device for the core_table.
-    cte.type                = 0; // CORE_ID_BOARD_INFO
-    cte.offset              = 0; // board info is always at the beginning
-    cte.length              = 512*8;
-    cte.s2c_dma_present     = false;
-    cte.s2c_dma_channel_num = 0;
-    cte.c2s_dma_present     = false;
-    cte.c2s_dma_channel_num = 0;
-    cte.irq_count           = 0;
-    cte.irq_base_num        = 0;
-    err = probe_core_uio(0, pcard, "kpc_uio", cte);
-    if (err){
-        dev_err(&pcard->pdev->dev, "kp2000_probe_cores: failed to add board_info core: %d\n", err);
-        goto error;
-    }
-
-    return 0;
+	int err = 0;
+	int i;
+	int current_type_id;
+	u64 read_val;
+	unsigned int highest_core_id = 0;
+	struct core_table_entry cte;
+
+	dev_dbg(&pcard->pdev->dev, "kp2000_probe_cores(pcard = %p / %d)\n", pcard, pcard->card_num);
+
+	err = kp2000_setup_dma_controller(pcard);
+	if (err) return err;
+
+	INIT_LIST_HEAD(&pcard->uio_devices_list);
+
+	// First, iterate the core table looking for the highest CORE_ID
+	for (i = 0 ; i < pcard->core_table_length ; i++){
+		read_val = readq(pcard->sysinfo_regs_base + ((pcard->core_table_offset + i) * 8));
+		parse_core_table_entry(&cte, read_val, pcard->core_table_rev);
+		dbg_cte(pcard, &cte);
+		if (cte.type > highest_core_id){
+			highest_core_id = cte.type;
+		}
+		if (cte.type == KP_CORE_ID_INVALID){
+			dev_info(&pcard->pdev->dev, "Found Invalid core: %016llx\n", read_val);
+		}
+	}
+	// Then, iterate over the possible core types.
+	for (current_type_id = 1 ; current_type_id <= highest_core_id ; current_type_id++){
+		unsigned int core_num = 0;
+		// Foreach core type, iterate the whole table and instantiate subdevices for each core.
+		// Yes, this is O(n*m) but the actual runtime is small enough that it's an acceptable tradeoff.
+		for (i = 0 ; i < pcard->core_table_length ; i++){
+			read_val = readq(pcard->sysinfo_regs_base + ((pcard->core_table_offset + i) * 8));
+			parse_core_table_entry(&cte, read_val, pcard->core_table_rev);
+
+			if (cte.type != current_type_id)
+				continue;
+
+			switch (cte.type) {
+			case KP_CORE_ID_I2C:
+				err = probe_core_basic(core_num, pcard,
+				KP_DRIVER_NAME_I2C, cte);
+				break;
+
+			case KP_CORE_ID_SPI:
+				err = probe_core_basic(core_num, pcard,
+						       KP_DRIVER_NAME_SPI, cte);
+				break;
+
+			default:
+				err = probe_core_uio(core_num, pcard, "kpc_uio", cte);
+				break;
+			}
+			if (err) {
+				dev_err(&pcard->pdev->dev,
+					"kp2000_probe_cores: failed to add core %d: %d\n",
+					i, err);
+				goto error;
+			}
+			core_num++;
+		}
+	}
+
+	// Finally, instantiate a UIO device for the core_table.
+	cte.type                = 0; // CORE_ID_BOARD_INFO
+	cte.offset              = 0; // board info is always at the beginning
+	cte.length              = 512*8;
+	cte.s2c_dma_present     = false;
+	cte.s2c_dma_channel_num = 0;
+	cte.c2s_dma_present     = false;
+	cte.c2s_dma_channel_num = 0;
+	cte.irq_count           = 0;
+	cte.irq_base_num        = 0;
+	err = probe_core_uio(0, pcard, "kpc_uio", cte);
+	if (err){
+		dev_err(&pcard->pdev->dev, "kp2000_probe_cores: failed to add board_info core: %d\n", err);
+		goto error;
+	}
+
+	return 0;
 
 error:
-    kp2000_remove_cores(pcard);
-    mfd_remove_devices(PCARD_TO_DEV(pcard));
-    return err;
+	kp2000_remove_cores(pcard);
+	mfd_remove_devices(PCARD_TO_DEV(pcard));
+	return err;
 }
 
 void  kp2000_remove_cores(struct kp2000_device *pcard)
 {
-    struct list_head *ptr;
-    struct list_head *next;
-    list_for_each_safe(ptr, next, &pcard->uio_devices_list){
-        struct kpc_uio_device *kudev = list_entry(ptr, struct kpc_uio_device, list);
-        uio_unregister_device(&kudev->uioinfo);
-        device_unregister(kudev->dev);
-        list_del(&kudev->list);
-        kfree(kudev);
-    }
+	struct list_head *ptr;
+	struct list_head *next;
+	list_for_each_safe(ptr, next, &pcard->uio_devices_list){
+		struct kpc_uio_device *kudev = list_entry(ptr, struct kpc_uio_device, list);
+		uio_unregister_device(&kudev->uioinfo);
+		device_unregister(kudev->dev);
+		list_del(&kudev->list);
+		kfree(kudev);
+	}
 }
 

commit e033958e74d7a86e373ba6e7a4a83b53a2693889
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Tue May 21 08:56:29 2019 +0100

    staging: kpc2000: removed two kpc_uio_class device attributes.
    
    The show functions of two attributes output nothing and they are unused.
    Removed them.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Reported-by: Matt Sickler <matt.sickler@daktronics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 3796f034312a..0181b0a8ff82 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -172,20 +172,6 @@ static ssize_t type_show(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RO(type);
 
-static ssize_t s2c_dma_ch_show(struct device *dev,
-			       struct device_attribute *attr, char *buf)
-{
-	return 0;
-}
-static DEVICE_ATTR_RO(s2c_dma_ch);
-
-static ssize_t c2s_dma_ch_show(struct device *dev,
-			       struct device_attribute *attr, char *buf)
-{
-	return 0;
-}
-static DEVICE_ATTR_RO(c2s_dma_ch);
-
 static ssize_t s2c_dma_show(struct device *dev, struct device_attribute *attr,
 			    char *buf)
 {
@@ -241,8 +227,6 @@ struct attribute *kpc_uio_class_attrs[] = {
 	&dev_attr_offset.attr,
 	&dev_attr_size.attr,
 	&dev_attr_type.attr,
-	&dev_attr_s2c_dma_ch.attr,
-	&dev_attr_c2s_dma_ch.attr,
 	&dev_attr_s2c_dma.attr,
 	&dev_attr_c2s_dma.attr,
 	&dev_attr_irq_count.attr,

commit cd88d2b11dc34b794e65d7aec64bd35086749945
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Tue May 21 08:56:28 2019 +0100

    staging: kpc2000: added separate show functions for kpc_uio_class device attributes, defined them as read-only and declared them static.
    
    Defined separate simple show functions for each attribute instead of
    having a one big one containing a chain of conditionals.
    
    Replaced scnprintf calls with sprintf since all the outputs are short
    bounded strings or single integers.
    
    All of the device attributes are read-only, so used DEVICE_ATTR_RO to
    define them.
    
    The definitions are only used to populate the kpc_uio_class_attrs
    attribute array, so declared them as static.
    
    Fixes the following sparse warnings:
    
      drivers/staging/kpc2000/kpc2000/cell_probe.c:220:1: warning: symbol 'dev_attr_offset' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/cell_probe.c:221:1: warning: symbol 'dev_attr_size' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/cell_probe.c:222:1: warning: symbol 'dev_attr_type' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/cell_probe.c:223:1: warning: symbol 'dev_attr_s2c_dma' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/cell_probe.c:224:1: warning: symbol 'dev_attr_c2s_dma' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/cell_probe.c:225:1: warning: symbol 'dev_attr_irq_count' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/cell_probe.c:226:1: warning: symbol 'dev_attr_irq_base_num' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/cell_probe.c:227:1: warning: symbol 'dev_attr_core_num' was not declared. Should it be static?
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 9289ac98c8c6..3796f034312a 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -145,55 +145,99 @@ struct kpc_uio_device {
     u16 core_num;
 };
 
-static ssize_t  show_attr(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t offset_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
 {
-    struct kpc_uio_device *kudev = dev_get_drvdata(dev);
-
-    #define ATTR_NAME_CMP(v)  (strcmp(v, attr->attr.name) == 0)
-    if ATTR_NAME_CMP("offset"){
-        return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.offset);
-    } else if ATTR_NAME_CMP("size"){
-        return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.length);
-    } else if ATTR_NAME_CMP("type"){
-        return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.type);
-    }
-    else if ATTR_NAME_CMP("s2c_dma"){
-        if (kudev->cte.s2c_dma_present){
-            return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.s2c_dma_channel_num);
-        } else {
-            return scnprintf(buf, PAGE_SIZE, "not present\n");
-        }
-    } else if ATTR_NAME_CMP("c2s_dma"){
-        if (kudev->cte.c2s_dma_present){
-            return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.c2s_dma_channel_num);
-        } else {
-            return scnprintf(buf, PAGE_SIZE, "not present\n");
-        }
-    }
-    else if ATTR_NAME_CMP("irq_count"){
-        return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.irq_count);
-    } else if ATTR_NAME_CMP("irq_base_num"){
-        return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.irq_base_num);
-    } else if ATTR_NAME_CMP("core_num"){
-        return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->core_num);
-    } else {
-        return 0;
-    }
-    #undef ATTR_NAME_CMP
+	struct kpc_uio_device *kudev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", kudev->cte.offset);
+}
+static DEVICE_ATTR_RO(offset);
+
+static ssize_t size_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct kpc_uio_device *kudev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", kudev->cte.length);
 }
+static DEVICE_ATTR_RO(size);
 
+static ssize_t type_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct kpc_uio_device *kudev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", kudev->cte.type);
+}
+static DEVICE_ATTR_RO(type);
+
+static ssize_t s2c_dma_ch_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+static DEVICE_ATTR_RO(s2c_dma_ch);
+
+static ssize_t c2s_dma_ch_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+static DEVICE_ATTR_RO(c2s_dma_ch);
+
+static ssize_t s2c_dma_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct kpc_uio_device *kudev = dev_get_drvdata(dev);
 
-DEVICE_ATTR(offset,  0444, show_attr, NULL);
-DEVICE_ATTR(size,    0444, show_attr, NULL);
-DEVICE_ATTR(type,    0444, show_attr, NULL);
-DEVICE_ATTR(s2c_dma_ch, 0444, show_attr, NULL);
-DEVICE_ATTR(c2s_dma_ch, 0444, show_attr, NULL);
-DEVICE_ATTR(s2c_dma, 0444, show_attr, NULL);
-DEVICE_ATTR(c2s_dma, 0444, show_attr, NULL);
-DEVICE_ATTR(irq_count, 0444, show_attr, NULL);
-DEVICE_ATTR(irq_base_num, 0444, show_attr, NULL);
-DEVICE_ATTR(core_num, 0444, show_attr, NULL);
-struct attribute * kpc_uio_class_attrs[] = {
+	if (!kudev->cte.s2c_dma_present)
+		return sprintf(buf, "%s", "not present\n");
+
+	return sprintf(buf, "%u\n", kudev->cte.s2c_dma_channel_num);
+}
+static DEVICE_ATTR_RO(s2c_dma);
+
+static ssize_t c2s_dma_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct kpc_uio_device *kudev = dev_get_drvdata(dev);
+
+	if (!kudev->cte.c2s_dma_present)
+		return sprintf(buf, "%s", "not present\n");
+
+	return sprintf(buf, "%u\n", kudev->cte.c2s_dma_channel_num);
+}
+static DEVICE_ATTR_RO(c2s_dma);
+
+static ssize_t irq_count_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	struct kpc_uio_device *kudev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", kudev->cte.irq_count);
+}
+static DEVICE_ATTR_RO(irq_count);
+
+static ssize_t irq_base_num_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct kpc_uio_device *kudev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", kudev->cte.irq_base_num);
+}
+static DEVICE_ATTR_RO(irq_base_num);
+
+static ssize_t core_num_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct kpc_uio_device *kudev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", kudev->core_num);
+}
+static DEVICE_ATTR_RO(core_num);
+
+struct attribute *kpc_uio_class_attrs[] = {
 	&dev_attr_offset.attr,
 	&dev_attr_size.attr,
 	&dev_attr_type.attr,
@@ -207,7 +251,6 @@ struct attribute * kpc_uio_class_attrs[] = {
 	NULL,
 };
 
-
 static
 int  kp2000_check_uio_irq(struct kp2000_device *pcard, u32 irq_num)
 {

commit 276accf2daa03d2d78dccb7017bdbbfde1e0b679
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri May 17 10:49:39 2019 +0200

    staging: kpc2000: remove lock_card/unlock_card functions
    
    We do not need an inline function to "hide" the lock, so just replace
    the few calls to these functions with the "real" mutex_lock/unlock()
    calls.
    
    Cc: Matt Sickler <Matt.Sickler@daktronics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 6a2ebdf20113..9289ac98c8c6 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -243,7 +243,7 @@ int kuio_irqcontrol(struct uio_info *uioinfo, s32 irq_on)
     struct kp2000_device *pcard = kudev->pcard;
     u64 mask;
 
-    lock_card(pcard);
+	mutex_lock(&pcard->sem);
     mask = readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
     if (irq_on){
         mask &= ~(1 << (kudev->cte.irq_base_num));
@@ -251,7 +251,7 @@ int kuio_irqcontrol(struct uio_info *uioinfo, s32 irq_on)
         mask |= (1 << (kudev->cte.irq_base_num));
     }
     writeq(mask, pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
-    unlock_card(pcard);
+	mutex_unlock(&pcard->sem);
 
     return 0;
 }

commit 2f9dcc46c626f32a484278c0fefae4ee49b5c1d5
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Thu May 16 22:38:06 2019 +0100

    staging: kpc2000: removed trailing white-space.
    
    Removed trailing white-space from four files.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index bce2bf9eee04..6a2ebdf20113 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -106,24 +106,24 @@ static int probe_core_basic(unsigned int core_num, struct kp2000_device *pcard,
     };
 
     dev_dbg(&pcard->pdev->dev, "Found Basic core: type = %02d  dma = %02x / %02x  offset = 0x%x  length = 0x%x (%d regs)\n", cte.type, KPC_OLD_S2C_DMA_CH_NUM(cte), KPC_OLD_C2S_DMA_CH_NUM(cte), cte.offset, cte.length, cte.length / 8);
-    
-    
+
+
     cell.platform_data = &core_pdata;
     cell.pdata_size = sizeof(struct kpc_core_device_platdata);
     cell.num_resources = 2;
-    
+
     memset(&resources, 0, sizeof(resources));
 
     resources[0].start = cte.offset;
     resources[0].end   = cte.offset + (cte.length - 1);
     resources[0].flags = IORESOURCE_MEM;
-    
+
     resources[1].start = pcard->pdev->irq;
     resources[1].end   = pcard->pdev->irq;
     resources[1].flags = IORESOURCE_IRQ;
-    
+
     cell.resources = resources;
-    
+
     return mfd_add_devices(
         PCARD_TO_DEV(pcard),    // parent
         pcard->card_num * 100,  // id
@@ -148,7 +148,7 @@ struct kpc_uio_device {
 static ssize_t  show_attr(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct kpc_uio_device *kudev = dev_get_drvdata(dev);
-    
+
     #define ATTR_NAME_CMP(v)  (strcmp(v, attr->attr.name) == 0)
     if ATTR_NAME_CMP("offset"){
         return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.offset);
@@ -228,7 +228,7 @@ irqreturn_t  kuio_handler(int irq, struct uio_info *uioinfo)
     struct kpc_uio_device *kudev = uioinfo->priv;
     if (irq != kudev->pcard->pdev->irq)
         return IRQ_NONE;
-    
+
     if (kp2000_check_uio_irq(kudev->pcard, kudev->cte.irq_base_num)){
         writeq((1 << kudev->cte.irq_base_num), kudev->pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE); // Clear the active flag
         return IRQ_HANDLED;
@@ -242,7 +242,7 @@ int kuio_irqcontrol(struct uio_info *uioinfo, s32 irq_on)
     struct kpc_uio_device *kudev = uioinfo->priv;
     struct kp2000_device *pcard = kudev->pcard;
     u64 mask;
-    
+
     lock_card(pcard);
     mask = readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
     if (irq_on){
@@ -252,7 +252,7 @@ int kuio_irqcontrol(struct uio_info *uioinfo, s32 irq_on)
     }
     writeq(mask, pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
     unlock_card(pcard);
-    
+
     return 0;
 }
 
@@ -263,18 +263,18 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
     int rv;
 
     dev_dbg(&pcard->pdev->dev, "Found UIO core:   type = %02d  dma = %02x / %02x  offset = 0x%x  length = 0x%x (%d regs)\n", cte.type, KPC_OLD_S2C_DMA_CH_NUM(cte), KPC_OLD_C2S_DMA_CH_NUM(cte), cte.offset, cte.length, cte.length / 8);
-    
+
     kudev = kzalloc(sizeof(struct kpc_uio_device), GFP_KERNEL);
     if (!kudev){
         dev_err(&pcard->pdev->dev, "probe_core_uio: failed to kzalloc kpc_uio_device\n");
         return -ENOMEM;
     }
-    
+
     INIT_LIST_HEAD(&kudev->list);
     kudev->pcard = pcard;
     kudev->cte = cte;
     kudev->core_num = core_num;
-    
+
     kudev->uioinfo.priv = kudev;
     kudev->uioinfo.name = name;
     kudev->uioinfo.version = "0.0";
@@ -291,7 +291,7 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
     kudev->uioinfo.mem[0].addr = pci_resource_start(pcard->pdev, REG_BAR) + cte.offset;
     kudev->uioinfo.mem[0].size = (cte.length + PAGE_SIZE-1) & ~(PAGE_SIZE-1); // Round up to nearest PAGE_SIZE boundary
     kudev->uioinfo.mem[0].memtype = UIO_MEM_PHYS;
-    
+
     kudev->dev = device_create(kpc_uio_class, &pcard->pdev->dev, MKDEV(0,0), kudev, "%s.%d.%d.%d", kudev->uioinfo.name, pcard->card_num, cte.type, kudev->core_num);
     if (IS_ERR(kudev->dev)) {
         dev_err(&pcard->pdev->dev, "probe_core_uio device_create failed!\n");
@@ -299,7 +299,7 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
         return -ENODEV;
     }
     dev_set_drvdata(kudev->dev, kudev);
-    
+
     rv = uio_register_device(kudev->dev, &kudev->uioinfo);
     if (rv){
         dev_err(&pcard->pdev->dev, "probe_core_uio failed uio_register_device: %d\n", rv);
@@ -307,9 +307,9 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
         kfree(kudev);
         return rv;
     }
-    
+
     list_add_tail(&kudev->list, &pcard->uio_devices_list);
-    
+
     return 0;
 }
 
@@ -320,24 +320,24 @@ static int  create_dma_engine_core(struct kp2000_device *pcard, size_t engine_re
     struct resource  resources[2];
 
     dev_dbg(&pcard->pdev->dev, "create_dma_core(pcard = [%p], engine_regs_offset = %zx, engine_num = %d)\n", pcard, engine_regs_offset, engine_num);
-    
+
     cell.platform_data = NULL;
     cell.pdata_size = 0;
     cell.name = KP_DRIVER_NAME_DMA_CONTROLLER;
     cell.num_resources = 2;
-    
+
     memset(&resources, 0, sizeof(resources));
 
     resources[0].start = engine_regs_offset;
     resources[0].end   = engine_regs_offset + (KPC_DMA_ENGINE_SIZE - 1);
     resources[0].flags = IORESOURCE_MEM;
-    
+
     resources[1].start = irq_num;
     resources[1].end   = irq_num;
     resources[1].flags = IORESOURCE_IRQ;
-    
+
     cell.resources = resources;
-    
+
     return mfd_add_devices(
         PCARD_TO_DEV(pcard),    // parent
         pcard->card_num * 100,  // id
@@ -354,7 +354,7 @@ static int  kp2000_setup_dma_controller(struct kp2000_device *pcard)
     int err;
     unsigned int i;
     u64 capabilities_reg;
-    
+
     // S2C Engines
     for (i = 0 ; i < 32 ; i++){
         capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
@@ -371,9 +371,9 @@ static int  kp2000_setup_dma_controller(struct kp2000_device *pcard)
             if (err) goto err_out;
         }
     }
-    
+
     return 0;
-    
+
 err_out:
     dev_err(&pcard->pdev->dev, "kp2000_setup_dma_controller: failed to add a DMA Engine: %d\n", err);
     return err;
@@ -389,12 +389,12 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
     struct core_table_entry cte;
 
     dev_dbg(&pcard->pdev->dev, "kp2000_probe_cores(pcard = %p / %d)\n", pcard, pcard->card_num);
-    
+
     err = kp2000_setup_dma_controller(pcard);
     if (err) return err;
-    
+
     INIT_LIST_HEAD(&pcard->uio_devices_list);
-    
+
     // First, iterate the core table looking for the highest CORE_ID
     for (i = 0 ; i < pcard->core_table_length ; i++){
         read_val = readq(pcard->sysinfo_regs_base + ((pcard->core_table_offset + i) * 8));
@@ -415,7 +415,7 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
         for (i = 0 ; i < pcard->core_table_length ; i++){
             read_val = readq(pcard->sysinfo_regs_base + ((pcard->core_table_offset + i) * 8));
             parse_core_table_entry(&cte, read_val, pcard->core_table_rev);
-            
+
             if (cte.type != current_type_id)
                 continue;
 
@@ -443,7 +443,7 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
             core_num++;
         }
     }
-    
+
     // Finally, instantiate a UIO device for the core_table.
     cte.type                = 0; // CORE_ID_BOARD_INFO
     cte.offset              = 0; // board info is always at the beginning
@@ -459,7 +459,7 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
         dev_err(&pcard->pdev->dev, "kp2000_probe_cores: failed to add board_info core: %d\n", err);
         goto error;
     }
-    
+
     return 0;
 
 error:

commit 70eb40836ca4a465adc7f986454fe69a2474e14e
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Wed May 15 12:14:37 2019 +0100

    staging: kpc2000: clean up after probe failure.
    
    On error, kp2000_probe_cores just returned an error without freeing
    resources which had previously been allocated.  Added the missing
    clean-up code.
    
    Updated TODO.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index e4c21291fe16..bce2bf9eee04 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -438,7 +438,7 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
                 dev_err(&pcard->pdev->dev,
                         "kp2000_probe_cores: failed to add core %d: %d\n",
                         i, err);
-                return err;
+                goto error;
             }
             core_num++;
         }
@@ -457,10 +457,15 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
     err = probe_core_uio(0, pcard, "kpc_uio", cte);
     if (err){
         dev_err(&pcard->pdev->dev, "kp2000_probe_cores: failed to add board_info core: %d\n", err);
-        return err;
+        goto error;
     }
     
     return 0;
+
+error:
+    kp2000_remove_cores(pcard);
+    mfd_remove_devices(PCARD_TO_DEV(pcard));
+    return err;
 }
 
 void  kp2000_remove_cores(struct kp2000_device *pcard)

commit abb611d2c21c0a4fa8eab35dc936c80d9a07acd8
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Wed May 15 12:14:36 2019 +0100

    staging: kpc2000: added missing clean-up to probe_core_uio.
    
    On error, probe_core_uio just returned an error without freeing
    resources which had previously been allocated.  Added the missing
    clean-up code.
    
    Updated TODO.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index b98d53c8637f..e4c21291fe16 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -295,6 +295,7 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
     kudev->dev = device_create(kpc_uio_class, &pcard->pdev->dev, MKDEV(0,0), kudev, "%s.%d.%d.%d", kudev->uioinfo.name, pcard->card_num, cte.type, kudev->core_num);
     if (IS_ERR(kudev->dev)) {
         dev_err(&pcard->pdev->dev, "probe_core_uio device_create failed!\n");
+        kfree(kudev);
         return -ENODEV;
     }
     dev_set_drvdata(kudev->dev, kudev);
@@ -302,6 +303,8 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
     rv = uio_register_device(kudev->dev, &kudev->uioinfo);
     if (rv){
         dev_err(&pcard->pdev->dev, "probe_core_uio failed uio_register_device: %d\n", rv);
+        put_device(kudev->dev);
+        kfree(kudev);
         return rv;
     }
     

commit 3809ca58c16a38eab93ac6c2eca4cb254bf6ca37
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Wed May 15 12:14:35 2019 +0100

    staging: kpc2000: added designated initializers to two structs.
    
    Fixed the following two sparse warnings by using designated
    initializers:
    
      drivers/staging/kpc2000/kpc2000/cell_probe.c:101:34: warning: Using plain integer as NULL pointer
      drivers/staging/kpc2000/kpc2000/cell_probe.c:364:34: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 30e6f176ddfa..b98d53c8637f 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -94,7 +94,7 @@ void parse_core_table_entry(struct core_table_entry *cte, const u64 read_val, co
 static int probe_core_basic(unsigned int core_num, struct kp2000_device *pcard,
 			    char *name, const struct core_table_entry cte)
 {
-    struct mfd_cell  cell = {0};
+    struct mfd_cell  cell = { .id = core_num, .name = name };
     struct resource  resources[2];
 
     struct kpc_core_device_platdata  core_pdata = {
@@ -110,8 +110,6 @@ static int probe_core_basic(unsigned int core_num, struct kp2000_device *pcard,
     
     cell.platform_data = &core_pdata;
     cell.pdata_size = sizeof(struct kpc_core_device_platdata);
-    cell.name = name;
-    cell.id = core_num;
     cell.num_resources = 2;
     
     memset(&resources, 0, sizeof(resources));
@@ -315,14 +313,13 @@ static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
 
 static int  create_dma_engine_core(struct kp2000_device *pcard, size_t engine_regs_offset, int engine_num, int irq_num)
 {
-    struct mfd_cell  cell = {0};
+    struct mfd_cell  cell = { .id = engine_num };
     struct resource  resources[2];
 
     dev_dbg(&pcard->pdev->dev, "create_dma_core(pcard = [%p], engine_regs_offset = %zx, engine_num = %d)\n", pcard, engine_regs_offset, engine_num);
     
     cell.platform_data = NULL;
     cell.pdata_size = 0;
-    cell.id = engine_num;
     cell.name = KP_DRIVER_NAME_DMA_CONTROLLER;
     cell.num_resources = 2;
     

commit dbaca02b625a8eabe2330d091d6e23f82c983cf9
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Wed May 15 12:14:34 2019 +0100

    staging: kpc2000: declare two functions as static.
    
    Two functions were not used outside the translation-unit in which they
    were defined.  Declared them static.
    
    Fixes two sparse warnings:
    
      drivers/staging/kpc2000/kpc2000/cell_probe.c:98:5: warning: symbol 'probe_core_basic' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/cell_probe.c:288:5: warning: symbol 'probe_core_uio' was not declared. Should it be static?
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index fc7038152bb4..30e6f176ddfa 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -91,7 +91,8 @@ void parse_core_table_entry(struct core_table_entry *cte, const u64 read_val, co
 }
 
 
-int  probe_core_basic(unsigned int core_num, struct kp2000_device *pcard, char *name, const struct core_table_entry cte)
+static int probe_core_basic(unsigned int core_num, struct kp2000_device *pcard,
+			    char *name, const struct core_table_entry cte)
 {
     struct mfd_cell  cell = {0};
     struct resource  resources[2];
@@ -257,7 +258,8 @@ int kuio_irqcontrol(struct uio_info *uioinfo, s32 irq_on)
     return 0;
 }
 
-int  probe_core_uio(unsigned int core_num, struct kp2000_device *pcard, char *name, const struct core_table_entry cte)
+static int probe_core_uio(unsigned int core_num, struct kp2000_device *pcard,
+			  char *name, const struct core_table_entry cte)
 {
     struct kpc_uio_device  *kudev;
     int rv;

commit d2a6eaee1d72262b08265a3d83f5048fe253401d
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Wed May 15 12:14:33 2019 +0100

    staging: kpc2000: inverted conditional in order to reduce indentation.
    
    Changed:
    
      for (...) {
        ...
        if (expr) {
          ...
        }
      }
    
    into:
    
      for (...) {
        ...
        if (!expr)
          continue;
        ...
      }
    
    in order to reduce indentation of conditional block.  Fixed indentation
    of cases blocks at the same time.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index e0dba91e7fa8..fc7038152bb4 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -414,26 +414,31 @@ int  kp2000_probe_cores(struct kp2000_device *pcard)
             read_val = readq(pcard->sysinfo_regs_base + ((pcard->core_table_offset + i) * 8));
             parse_core_table_entry(&cte, read_val, pcard->core_table_rev);
             
-            if (cte.type == current_type_id){
-                switch (cte.type){
-                    case KP_CORE_ID_I2C:
-                        err = probe_core_basic(core_num, pcard, KP_DRIVER_NAME_I2C, cte);
-                        break;
-                    
-                    case KP_CORE_ID_SPI:
-                        err = probe_core_basic(core_num, pcard, KP_DRIVER_NAME_SPI, cte);
-                        break;
-                    
-                    default:
-                        err = probe_core_uio(core_num, pcard, "kpc_uio", cte);
-                        break;
-                }
-                if (err){
-                    dev_err(&pcard->pdev->dev, "kp2000_probe_cores: failed to add core %d: %d\n", i, err);
-                    return err;
-                }
-                core_num++;
+            if (cte.type != current_type_id)
+                continue;
+
+            switch (cte.type) {
+            case KP_CORE_ID_I2C:
+                err = probe_core_basic(core_num, pcard,
+                                       KP_DRIVER_NAME_I2C, cte);
+                break;
+
+            case KP_CORE_ID_SPI:
+                err = probe_core_basic(core_num, pcard,
+                                       KP_DRIVER_NAME_SPI, cte);
+                break;
+
+            default:
+                err = probe_core_uio(core_num, pcard, "kpc_uio", cte);
+                break;
             }
+            if (err) {
+                dev_err(&pcard->pdev->dev,
+                        "kp2000_probe_cores: failed to add core %d: %d\n",
+                        i, err);
+                return err;
+            }
+            core_num++;
         }
     }
     

commit 91b6cb7216cd8bad027bc9ef88e2834786c8eeaf
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed May 1 10:48:43 2019 +0200

    staging: kpc2000: fix up build problems with readq()
    
    The 0-day system found a bunch of warnings for when readq() is not
    defined on the platform, so fix this by including the
    linux/io-64-nonatomic-lo-hi.h file which will fix up these issues.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index 13f544f3c0b9..e0dba91e7fa8 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -6,6 +6,7 @@
 #include <linux/slab.h>
 #include <asm/io.h>
 #include <linux/io.h>
+#include <linux/io-64-nonatomic-lo-hi.h>
 #include <linux/mfd/core.h>
 #include <linux/platform_device.h>
 #include <linux/ioport.h>

commit 3fcbb7d49cb7947711888a0e5905bc5cd90cab5d
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Wed Apr 24 11:57:43 2019 -0700

    staging: kpc2000: Use memset to initialize resources
    
    Clang warns:
    
    drivers/staging/kpc2000/kpc2000/cell_probe.c:96:38: warning: suggest
    braces around initialization of subobject [-Wmissing-braces]
        struct resource  resources[2] = {0};
                                         ^
                                         {}
    drivers/staging/kpc2000/kpc2000/cell_probe.c:314:38: warning: suggest
    braces around initialization of subobject [-Wmissing-braces]
        struct resource  resources[2] = {0};
                                         ^
                                         {}
    2 warnings generated.
    
    One way to fix these warnings is to add additional braces like Clang
    suggests; however, there has been a bit of push back from some
    maintainers, who just prefer memset as it is unambiguous, doesn't
    depend on a particular compiler version, and properly initializes all
    subobjects [1][2]. Do that here so there are no more warnings.
    
    [1]: https://lore.kernel.org/lkml/022e41c0-8465-dc7a-a45c-64187ecd9684@amd.com/
    [2]: https://lore.kernel.org/lkml/20181128.215241.702406654469517539.davem@davemloft.net/
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/455
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
index ad2cc0a3bfa1..13f544f3c0b9 100644
--- a/drivers/staging/kpc2000/kpc2000/cell_probe.c
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -93,8 +93,8 @@ void parse_core_table_entry(struct core_table_entry *cte, const u64 read_val, co
 int  probe_core_basic(unsigned int core_num, struct kp2000_device *pcard, char *name, const struct core_table_entry cte)
 {
     struct mfd_cell  cell = {0};
-    struct resource  resources[2] = {0};
-    
+    struct resource  resources[2];
+
     struct kpc_core_device_platdata  core_pdata = {
         .card_id           = pcard->card_id,
         .build_version     = pcard->build_version,
@@ -112,6 +112,8 @@ int  probe_core_basic(unsigned int core_num, struct kp2000_device *pcard, char *
     cell.id = core_num;
     cell.num_resources = 2;
     
+    memset(&resources, 0, sizeof(resources));
+
     resources[0].start = cte.offset;
     resources[0].end   = cte.offset + (cte.length - 1);
     resources[0].flags = IORESOURCE_MEM;
@@ -311,8 +313,8 @@ int  probe_core_uio(unsigned int core_num, struct kp2000_device *pcard, char *na
 static int  create_dma_engine_core(struct kp2000_device *pcard, size_t engine_regs_offset, int engine_num, int irq_num)
 {
     struct mfd_cell  cell = {0};
-    struct resource  resources[2] = {0};
-    
+    struct resource  resources[2];
+
     dev_dbg(&pcard->pdev->dev, "create_dma_core(pcard = [%p], engine_regs_offset = %zx, engine_num = %d)\n", pcard, engine_regs_offset, engine_num);
     
     cell.platform_data = NULL;
@@ -321,6 +323,8 @@ static int  create_dma_engine_core(struct kp2000_device *pcard, size_t engine_re
     cell.name = KP_DRIVER_NAME_DMA_CONTROLLER;
     cell.num_resources = 2;
     
+    memset(&resources, 0, sizeof(resources));
+
     resources[0].start = engine_regs_offset;
     resources[0].end   = engine_regs_offset + (KPC_DMA_ENGINE_SIZE - 1);
     resources[0].flags = IORESOURCE_MEM;

commit 7dc7967fc39af81191558f63eeaf3d2b83899b1c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Apr 19 20:42:05 2019 +0200

    staging: kpc2000: add initial set of Daktronics drivers
    
    These drivers have been outside of the kernel tree since the 2.x days,
    and it's time to bring them into the tree so they can get properly
    cleaned up.
    
    This first dump of drivers is based on a tarball Matt gave to me, minus
    an odd "dma" driver that I could not get to build at all.  I renamed a
    few files, added the proper SPDX lines to it, added Kconfig entries and
    tied it into the kernel build.  I also fixed up a number of initial
    obvious kernel build warnings, but left the odd bitfield warning that
    gcc is spitting out, as I'm not quite sure what to do about that.
    
    There's loads of low-hanging coding style cleanups in here for people to
    start attacking, as well as the more obvious logic and api cleanups as
    well.
    
    Cc: Matt Sickler <Matt.Sickler@daktronics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/cell_probe.c b/drivers/staging/kpc2000/kpc2000/cell_probe.c
new file mode 100644
index 000000000000..ad2cc0a3bfa1
--- /dev/null
+++ b/drivers/staging/kpc2000/kpc2000/cell_probe.c
@@ -0,0 +1,466 @@
+// SPDX-License-Identifier: GPL-2.0+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+#include <linux/export.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/mfd/core.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <linux/uio_driver.h>
+#include "pcie.h"
+
+/*  Core (Resource) Table Layout:
+ *      one Resource per record (8 bytes)
+ *                 6         5         4         3         2         1         0
+ *              3210987654321098765432109876543210987654321098765432109876543210
+ *              IIIIIIIIIIII                                                        Core Type    [up to 4095 types]
+ *                          D                                                       S2C DMA Present
+ *                           DDD                                                    S2C DMA Channel Number    [up to 8 channels]
+ *                              LLLLLLLLLLLLLLLL                                    Register Count (64-bit registers)    [up to 65535 registers]
+ *                                              OOOOOOOOOOOOOOOO                    Core Offset (in 4kB blocks)    [up to 65535 cores]
+ *                                                              D                   C2S DMA Present
+ *                                                               DDD                C2S DMA Channel Number    [up to 8 channels]
+ *                                                                  II              IRQ Count [0 to 3 IRQs per core]
+                                                                      1111111000
+ *                                                                    IIIIIII       IRQ Base Number [up to 128 IRQs per card]
+ *                                                                           ___    Spare
+ *
+ */
+
+#define KPC_OLD_DMA_CH_NUM(present, channel)   ((present) ? (0x8 | ((channel) & 0x7)) : 0)
+#define KPC_OLD_S2C_DMA_CH_NUM(cte)   KPC_OLD_DMA_CH_NUM(cte.s2c_dma_present, cte.s2c_dma_channel_num)
+#define KPC_OLD_C2S_DMA_CH_NUM(cte)   KPC_OLD_DMA_CH_NUM(cte.c2s_dma_present, cte.c2s_dma_channel_num)
+
+#define KP_CORE_ID_INVALID      0
+#define KP_CORE_ID_I2C          3
+#define KP_CORE_ID_SPI          5
+
+struct core_table_entry {
+    u16     type;
+    u32     offset;
+    u32     length;
+    bool    s2c_dma_present;
+    u8      s2c_dma_channel_num;
+    bool    c2s_dma_present;
+    u8      c2s_dma_channel_num;
+    u8      irq_count;
+    u8      irq_base_num;
+};
+
+static
+void  parse_core_table_entry_v0(struct core_table_entry *cte, const u64 read_val)
+{
+    cte->type                = ((read_val & 0xFFF0000000000000) >> 52);
+    cte->offset              = ((read_val & 0x00000000FFFF0000) >> 16) * 4096;
+    cte->length              = ((read_val & 0x0000FFFF00000000) >> 32) * 8;
+    cte->s2c_dma_present     = ((read_val & 0x0008000000000000) >> 51);
+    cte->s2c_dma_channel_num = ((read_val & 0x0007000000000000) >> 48);
+    cte->c2s_dma_present     = ((read_val & 0x0000000000008000) >> 15);
+    cte->c2s_dma_channel_num = ((read_val & 0x0000000000007000) >> 12);
+    cte->irq_count           = ((read_val & 0x0000000000000C00) >> 10);
+    cte->irq_base_num        = ((read_val & 0x00000000000003F8) >>  3);
+}
+
+static
+void dbg_cte(struct kp2000_device *pcard, struct core_table_entry *cte)
+{
+    dev_dbg(&pcard->pdev->dev, "CTE: type:%3d  offset:%3d (%3d)  length:%3d (%3d)  s2c:%d  c2s:%d  irq_count:%d  base_irq:%d\n",
+        cte->type,
+        cte->offset,
+        cte->offset / 4096,
+        cte->length,
+        cte->length / 8,
+        (cte->s2c_dma_present ? cte->s2c_dma_channel_num : -1),
+        (cte->c2s_dma_present ? cte->c2s_dma_channel_num : -1),
+        cte->irq_count,
+        cte->irq_base_num
+    );
+}
+
+static
+void parse_core_table_entry(struct core_table_entry *cte, const u64 read_val, const u8 entry_rev)
+{
+	switch (entry_rev) {
+	case 0: parse_core_table_entry_v0(cte, read_val); break;
+	default: cte->type = 0; break;
+	}
+}
+
+
+int  probe_core_basic(unsigned int core_num, struct kp2000_device *pcard, char *name, const struct core_table_entry cte)
+{
+    struct mfd_cell  cell = {0};
+    struct resource  resources[2] = {0};
+    
+    struct kpc_core_device_platdata  core_pdata = {
+        .card_id           = pcard->card_id,
+        .build_version     = pcard->build_version,
+        .hardware_revision = pcard->hardware_revision,
+        .ssid              = pcard->ssid,
+        .ddna              = pcard->ddna,
+    };
+
+    dev_dbg(&pcard->pdev->dev, "Found Basic core: type = %02d  dma = %02x / %02x  offset = 0x%x  length = 0x%x (%d regs)\n", cte.type, KPC_OLD_S2C_DMA_CH_NUM(cte), KPC_OLD_C2S_DMA_CH_NUM(cte), cte.offset, cte.length, cte.length / 8);
+    
+    
+    cell.platform_data = &core_pdata;
+    cell.pdata_size = sizeof(struct kpc_core_device_platdata);
+    cell.name = name;
+    cell.id = core_num;
+    cell.num_resources = 2;
+    
+    resources[0].start = cte.offset;
+    resources[0].end   = cte.offset + (cte.length - 1);
+    resources[0].flags = IORESOURCE_MEM;
+    
+    resources[1].start = pcard->pdev->irq;
+    resources[1].end   = pcard->pdev->irq;
+    resources[1].flags = IORESOURCE_IRQ;
+    
+    cell.resources = resources;
+    
+    return mfd_add_devices(
+        PCARD_TO_DEV(pcard),    // parent
+        pcard->card_num * 100,  // id
+        &cell,                  // struct mfd_cell *
+        1,                      // ndevs
+        &pcard->regs_base_resource,
+        0,                      // irq_base
+        NULL                    // struct irq_domain *
+    );
+}
+
+
+struct kpc_uio_device {
+    struct list_head list;
+    struct kp2000_device *pcard;
+    struct device  *dev;
+    struct uio_info uioinfo;
+    struct core_table_entry cte;
+    u16 core_num;
+};
+
+static ssize_t  show_attr(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct kpc_uio_device *kudev = dev_get_drvdata(dev);
+    
+    #define ATTR_NAME_CMP(v)  (strcmp(v, attr->attr.name) == 0)
+    if ATTR_NAME_CMP("offset"){
+        return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.offset);
+    } else if ATTR_NAME_CMP("size"){
+        return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.length);
+    } else if ATTR_NAME_CMP("type"){
+        return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.type);
+    }
+    else if ATTR_NAME_CMP("s2c_dma"){
+        if (kudev->cte.s2c_dma_present){
+            return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.s2c_dma_channel_num);
+        } else {
+            return scnprintf(buf, PAGE_SIZE, "not present\n");
+        }
+    } else if ATTR_NAME_CMP("c2s_dma"){
+        if (kudev->cte.c2s_dma_present){
+            return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.c2s_dma_channel_num);
+        } else {
+            return scnprintf(buf, PAGE_SIZE, "not present\n");
+        }
+    }
+    else if ATTR_NAME_CMP("irq_count"){
+        return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.irq_count);
+    } else if ATTR_NAME_CMP("irq_base_num"){
+        return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->cte.irq_base_num);
+    } else if ATTR_NAME_CMP("core_num"){
+        return scnprintf(buf, PAGE_SIZE, "%u\n", kudev->core_num);
+    } else {
+        return 0;
+    }
+    #undef ATTR_NAME_CMP
+}
+
+
+DEVICE_ATTR(offset,  0444, show_attr, NULL);
+DEVICE_ATTR(size,    0444, show_attr, NULL);
+DEVICE_ATTR(type,    0444, show_attr, NULL);
+DEVICE_ATTR(s2c_dma_ch, 0444, show_attr, NULL);
+DEVICE_ATTR(c2s_dma_ch, 0444, show_attr, NULL);
+DEVICE_ATTR(s2c_dma, 0444, show_attr, NULL);
+DEVICE_ATTR(c2s_dma, 0444, show_attr, NULL);
+DEVICE_ATTR(irq_count, 0444, show_attr, NULL);
+DEVICE_ATTR(irq_base_num, 0444, show_attr, NULL);
+DEVICE_ATTR(core_num, 0444, show_attr, NULL);
+struct attribute * kpc_uio_class_attrs[] = {
+	&dev_attr_offset.attr,
+	&dev_attr_size.attr,
+	&dev_attr_type.attr,
+	&dev_attr_s2c_dma_ch.attr,
+	&dev_attr_c2s_dma_ch.attr,
+	&dev_attr_s2c_dma.attr,
+	&dev_attr_c2s_dma.attr,
+	&dev_attr_irq_count.attr,
+	&dev_attr_irq_base_num.attr,
+	&dev_attr_core_num.attr,
+	NULL,
+};
+
+
+static
+int  kp2000_check_uio_irq(struct kp2000_device *pcard, u32 irq_num)
+{
+    u64 interrupt_active   =  readq(pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE);
+    u64 interrupt_mask_inv = ~readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
+    u64 irq_check_mask = (1 << irq_num);
+    if (interrupt_active & irq_check_mask){ // if it's active (interrupt pending)
+        if (interrupt_mask_inv & irq_check_mask){    // and if it's not masked off
+            return 1;
+        }
+    }
+    return 0;
+}
+
+static
+irqreturn_t  kuio_handler(int irq, struct uio_info *uioinfo)
+{
+    struct kpc_uio_device *kudev = uioinfo->priv;
+    if (irq != kudev->pcard->pdev->irq)
+        return IRQ_NONE;
+    
+    if (kp2000_check_uio_irq(kudev->pcard, kudev->cte.irq_base_num)){
+        writeq((1 << kudev->cte.irq_base_num), kudev->pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE); // Clear the active flag
+        return IRQ_HANDLED;
+    }
+    return IRQ_NONE;
+}
+
+static
+int kuio_irqcontrol(struct uio_info *uioinfo, s32 irq_on)
+{
+    struct kpc_uio_device *kudev = uioinfo->priv;
+    struct kp2000_device *pcard = kudev->pcard;
+    u64 mask;
+    
+    lock_card(pcard);
+    mask = readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
+    if (irq_on){
+        mask &= ~(1 << (kudev->cte.irq_base_num));
+    } else {
+        mask |= (1 << (kudev->cte.irq_base_num));
+    }
+    writeq(mask, pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
+    unlock_card(pcard);
+    
+    return 0;
+}
+
+int  probe_core_uio(unsigned int core_num, struct kp2000_device *pcard, char *name, const struct core_table_entry cte)
+{
+    struct kpc_uio_device  *kudev;
+    int rv;
+
+    dev_dbg(&pcard->pdev->dev, "Found UIO core:   type = %02d  dma = %02x / %02x  offset = 0x%x  length = 0x%x (%d regs)\n", cte.type, KPC_OLD_S2C_DMA_CH_NUM(cte), KPC_OLD_C2S_DMA_CH_NUM(cte), cte.offset, cte.length, cte.length / 8);
+    
+    kudev = kzalloc(sizeof(struct kpc_uio_device), GFP_KERNEL);
+    if (!kudev){
+        dev_err(&pcard->pdev->dev, "probe_core_uio: failed to kzalloc kpc_uio_device\n");
+        return -ENOMEM;
+    }
+    
+    INIT_LIST_HEAD(&kudev->list);
+    kudev->pcard = pcard;
+    kudev->cte = cte;
+    kudev->core_num = core_num;
+    
+    kudev->uioinfo.priv = kudev;
+    kudev->uioinfo.name = name;
+    kudev->uioinfo.version = "0.0";
+    if (cte.irq_count > 0){
+        kudev->uioinfo.irq_flags = IRQF_SHARED;
+        kudev->uioinfo.irq = pcard->pdev->irq;
+        kudev->uioinfo.handler = kuio_handler;
+        kudev->uioinfo.irqcontrol = kuio_irqcontrol;
+    } else {
+        kudev->uioinfo.irq = 0;
+    }
+
+    kudev->uioinfo.mem[0].name = "uiomap";
+    kudev->uioinfo.mem[0].addr = pci_resource_start(pcard->pdev, REG_BAR) + cte.offset;
+    kudev->uioinfo.mem[0].size = (cte.length + PAGE_SIZE-1) & ~(PAGE_SIZE-1); // Round up to nearest PAGE_SIZE boundary
+    kudev->uioinfo.mem[0].memtype = UIO_MEM_PHYS;
+    
+    kudev->dev = device_create(kpc_uio_class, &pcard->pdev->dev, MKDEV(0,0), kudev, "%s.%d.%d.%d", kudev->uioinfo.name, pcard->card_num, cte.type, kudev->core_num);
+    if (IS_ERR(kudev->dev)) {
+        dev_err(&pcard->pdev->dev, "probe_core_uio device_create failed!\n");
+        return -ENODEV;
+    }
+    dev_set_drvdata(kudev->dev, kudev);
+    
+    rv = uio_register_device(kudev->dev, &kudev->uioinfo);
+    if (rv){
+        dev_err(&pcard->pdev->dev, "probe_core_uio failed uio_register_device: %d\n", rv);
+        return rv;
+    }
+    
+    list_add_tail(&kudev->list, &pcard->uio_devices_list);
+    
+    return 0;
+}
+
+
+static int  create_dma_engine_core(struct kp2000_device *pcard, size_t engine_regs_offset, int engine_num, int irq_num)
+{
+    struct mfd_cell  cell = {0};
+    struct resource  resources[2] = {0};
+    
+    dev_dbg(&pcard->pdev->dev, "create_dma_core(pcard = [%p], engine_regs_offset = %zx, engine_num = %d)\n", pcard, engine_regs_offset, engine_num);
+    
+    cell.platform_data = NULL;
+    cell.pdata_size = 0;
+    cell.id = engine_num;
+    cell.name = KP_DRIVER_NAME_DMA_CONTROLLER;
+    cell.num_resources = 2;
+    
+    resources[0].start = engine_regs_offset;
+    resources[0].end   = engine_regs_offset + (KPC_DMA_ENGINE_SIZE - 1);
+    resources[0].flags = IORESOURCE_MEM;
+    
+    resources[1].start = irq_num;
+    resources[1].end   = irq_num;
+    resources[1].flags = IORESOURCE_IRQ;
+    
+    cell.resources = resources;
+    
+    return mfd_add_devices(
+        PCARD_TO_DEV(pcard),    // parent
+        pcard->card_num * 100,  // id
+        &cell,                  // struct mfd_cell *
+        1,                      // ndevs
+        &pcard->dma_base_resource,
+        0,                      // irq_base
+        NULL                    // struct irq_domain *
+    );
+}
+
+static int  kp2000_setup_dma_controller(struct kp2000_device *pcard)
+{
+    int err;
+    unsigned int i;
+    u64 capabilities_reg;
+    
+    // S2C Engines
+    for (i = 0 ; i < 32 ; i++){
+        capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
+        if (capabilities_reg & ENGINE_CAP_PRESENT_MASK){
+            err = create_dma_engine_core(pcard, (KPC_DMA_S2C_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), i,  pcard->pdev->irq);
+            if (err) goto err_out;
+        }
+    }
+    // C2S Engines
+    for (i = 0 ; i < 32 ; i++){
+        capabilities_reg = readq( pcard->dma_bar_base + KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i) );
+        if (capabilities_reg & ENGINE_CAP_PRESENT_MASK){
+            err = create_dma_engine_core(pcard, (KPC_DMA_C2S_BASE_OFFSET + (KPC_DMA_ENGINE_SIZE * i)), 32+i,  pcard->pdev->irq);
+            if (err) goto err_out;
+        }
+    }
+    
+    return 0;
+    
+err_out:
+    dev_err(&pcard->pdev->dev, "kp2000_setup_dma_controller: failed to add a DMA Engine: %d\n", err);
+    return err;
+}
+
+int  kp2000_probe_cores(struct kp2000_device *pcard)
+{
+    int err = 0;
+    int i;
+    int current_type_id;
+    u64 read_val;
+    unsigned int highest_core_id = 0;
+    struct core_table_entry cte;
+
+    dev_dbg(&pcard->pdev->dev, "kp2000_probe_cores(pcard = %p / %d)\n", pcard, pcard->card_num);
+    
+    err = kp2000_setup_dma_controller(pcard);
+    if (err) return err;
+    
+    INIT_LIST_HEAD(&pcard->uio_devices_list);
+    
+    // First, iterate the core table looking for the highest CORE_ID
+    for (i = 0 ; i < pcard->core_table_length ; i++){
+        read_val = readq(pcard->sysinfo_regs_base + ((pcard->core_table_offset + i) * 8));
+        parse_core_table_entry(&cte, read_val, pcard->core_table_rev);
+        dbg_cte(pcard, &cte);
+        if (cte.type > highest_core_id){
+            highest_core_id = cte.type;
+        }
+        if (cte.type == KP_CORE_ID_INVALID){
+            dev_info(&pcard->pdev->dev, "Found Invalid core: %016llx\n", read_val);
+        }
+    }
+    // Then, iterate over the possible core types.
+    for (current_type_id = 1 ; current_type_id <= highest_core_id ; current_type_id++){
+        unsigned int core_num = 0;
+        // Foreach core type, iterate the whole table and instantiate subdevices for each core.
+        // Yes, this is O(n*m) but the actual runtime is small enough that it's an acceptable tradeoff.
+        for (i = 0 ; i < pcard->core_table_length ; i++){
+            read_val = readq(pcard->sysinfo_regs_base + ((pcard->core_table_offset + i) * 8));
+            parse_core_table_entry(&cte, read_val, pcard->core_table_rev);
+            
+            if (cte.type == current_type_id){
+                switch (cte.type){
+                    case KP_CORE_ID_I2C:
+                        err = probe_core_basic(core_num, pcard, KP_DRIVER_NAME_I2C, cte);
+                        break;
+                    
+                    case KP_CORE_ID_SPI:
+                        err = probe_core_basic(core_num, pcard, KP_DRIVER_NAME_SPI, cte);
+                        break;
+                    
+                    default:
+                        err = probe_core_uio(core_num, pcard, "kpc_uio", cte);
+                        break;
+                }
+                if (err){
+                    dev_err(&pcard->pdev->dev, "kp2000_probe_cores: failed to add core %d: %d\n", i, err);
+                    return err;
+                }
+                core_num++;
+            }
+        }
+    }
+    
+    // Finally, instantiate a UIO device for the core_table.
+    cte.type                = 0; // CORE_ID_BOARD_INFO
+    cte.offset              = 0; // board info is always at the beginning
+    cte.length              = 512*8;
+    cte.s2c_dma_present     = false;
+    cte.s2c_dma_channel_num = 0;
+    cte.c2s_dma_present     = false;
+    cte.c2s_dma_channel_num = 0;
+    cte.irq_count           = 0;
+    cte.irq_base_num        = 0;
+    err = probe_core_uio(0, pcard, "kpc_uio", cte);
+    if (err){
+        dev_err(&pcard->pdev->dev, "kp2000_probe_cores: failed to add board_info core: %d\n", err);
+        return err;
+    }
+    
+    return 0;
+}
+
+void  kp2000_remove_cores(struct kp2000_device *pcard)
+{
+    struct list_head *ptr;
+    struct list_head *next;
+    list_for_each_safe(ptr, next, &pcard->uio_devices_list){
+        struct kpc_uio_device *kudev = list_entry(ptr, struct kpc_uio_device, list);
+        uio_unregister_device(&kudev->uioinfo);
+        device_unregister(kudev->dev);
+        list_del(&kudev->list);
+        kfree(kudev);
+    }
+}
+
