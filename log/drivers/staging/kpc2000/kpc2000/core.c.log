commit b17884ccf29e127b16bba6aea1438c851c9f5af1
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Wed May 6 13:47:35 2020 +0000

    staging: kpc2000: fix error return code in kp2000_pcie_probe()
    
    Fix to return a negative error code from the error handling
    case instead of 0, as done elsewhere in this function. Also
    removed var 'rv' since we can use 'err' instead.
    
    Fixes: 7dc7967fc39a ("staging: kpc2000: add initial set of Daktronics drivers")
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Cc: stable <stable@vger.kernel.org>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Link: https://lore.kernel.org/r/20200506134735.102041-1-weiyongjun1@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 7b00d7069e21..358d7b2f4ad1 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -298,7 +298,6 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 {
 	int err = 0;
 	struct kp2000_device *pcard;
-	int rv;
 	unsigned long reg_bar_phys_addr;
 	unsigned long reg_bar_phys_len;
 	unsigned long dma_bar_phys_addr;
@@ -445,11 +444,11 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	if (err < 0)
 		goto err_release_dma;
 
-	rv = request_irq(pcard->pdev->irq, kp2000_irq_handler, IRQF_SHARED,
-			 pcard->name, pcard);
-	if (rv) {
+	err = request_irq(pcard->pdev->irq, kp2000_irq_handler, IRQF_SHARED,
+			  pcard->name, pcard);
+	if (err) {
 		dev_err(&pcard->pdev->dev,
-			"%s: failed to request_irq: %d\n", __func__, rv);
+			"%s: failed to request_irq: %d\n", __func__, err);
 		goto err_disable_msi;
 	}
 

commit 72db61d7d17a475d3cc9de1a7c871d518fcd82f0
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Feb 24 13:33:25 2020 +0300

    staging: kpc2000: prevent underflow in cpld_reconfigure()
    
    This function should not allow negative values of "wr_val".  If
    negatives are allowed then capping the upper bound at 7 is
    meaningless.  Let's make it unsigned.
    
    Fixes: 7dc7967fc39a ("staging: kpc2000: add initial set of Daktronics drivers")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200224103325.hrxdnaeqsthplu42@kili.mountain
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 93cf28febdf6..7b00d7069e21 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -110,10 +110,10 @@ static ssize_t cpld_reconfigure(struct device *dev,
 				const char *buf, size_t count)
 {
 	struct kp2000_device *pcard = dev_get_drvdata(dev);
-	long wr_val;
+	unsigned long wr_val;
 	int rv;
 
-	rv = kstrtol(buf, 0, &wr_val);
+	rv = kstrtoul(buf, 0, &wr_val);
 	if (rv < 0)
 		return rv;
 	if (wr_val > 7)

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 0a23727d0dc3..93cf28febdf6 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -338,7 +338,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	reg_bar_phys_addr = pci_resource_start(pcard->pdev, REG_BAR);
 	reg_bar_phys_len = pci_resource_len(pcard->pdev, REG_BAR);
 
-	pcard->regs_bar_base = ioremap_nocache(reg_bar_phys_addr, PAGE_SIZE);
+	pcard->regs_bar_base = ioremap(reg_bar_phys_addr, PAGE_SIZE);
 	if (!pcard->regs_bar_base) {
 		dev_err(&pcard->pdev->dev,
 			"probe: REG_BAR could not remap memory to virtual space\n");
@@ -367,7 +367,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	dma_bar_phys_addr = pci_resource_start(pcard->pdev, DMA_BAR);
 	dma_bar_phys_len = pci_resource_len(pcard->pdev, DMA_BAR);
 
-	pcard->dma_bar_base = ioremap_nocache(dma_bar_phys_addr,
+	pcard->dma_bar_base = ioremap(dma_bar_phys_addr,
 					      dma_bar_phys_len);
 	if (!pcard->dma_bar_base) {
 		dev_err(&pcard->pdev->dev,

commit f08ab0abb6990db3d93b917f6e701ba6b05d604e
Author: Harsh Jain <harshjain32@gmail.com>
Date:   Sat Aug 31 17:25:32 2019 +0530

    staging: kpc2000: Fix long constant sparse warning
    
    It fixed following warning in kpc2000 driver
    "constant XXXX is so big it is unsigned long"
    
    Signed-off-by: Harsh Jain <harshjain32@gmail.com>
    Link: https://lore.kernel.org/r/20190831115532.2398-1-harshjain32@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index cb05cca687e1..0a23727d0dc3 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -205,7 +205,7 @@ static void wait_and_read_ssid(struct kp2000_device *pcard)
 	u64 read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_SSID);
 	unsigned long timeout;
 
-	if (read_val & 0x8000000000000000) {
+	if (read_val & 0x8000000000000000UL) {
 		pcard->ssid = read_val;
 		return;
 	}
@@ -213,7 +213,7 @@ static void wait_and_read_ssid(struct kp2000_device *pcard)
 	timeout = jiffies + (HZ * 2);
 	do {
 		read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_SSID);
-		if (read_val & 0x8000000000000000) {
+		if (read_val & 0x8000000000000000UL) {
 			pcard->ssid = read_val;
 			return;
 		}
@@ -241,16 +241,16 @@ static int  read_system_regs(struct kp2000_device *pcard)
 	}
 
 	read_val = readq(pcard->sysinfo_regs_base + REG_CARD_ID_AND_BUILD);
-	pcard->card_id = (read_val & 0xFFFFFFFF00000000) >> 32;
-	pcard->build_version = (read_val & 0x00000000FFFFFFFF) >> 0;
+	pcard->card_id = (read_val & 0xFFFFFFFF00000000UL) >> 32;
+	pcard->build_version = (read_val & 0x00000000FFFFFFFFUL) >> 0;
 
 	read_val = readq(pcard->sysinfo_regs_base + REG_DATE_AND_TIME_STAMPS);
-	pcard->build_datestamp = (read_val & 0xFFFFFFFF00000000) >> 32;
-	pcard->build_timestamp = (read_val & 0x00000000FFFFFFFF) >> 0;
+	pcard->build_datestamp = (read_val & 0xFFFFFFFF00000000UL) >> 32;
+	pcard->build_timestamp = (read_val & 0x00000000FFFFFFFFUL) >> 0;
 
 	read_val = readq(pcard->sysinfo_regs_base + REG_CORE_TABLE_OFFSET);
-	pcard->core_table_length = (read_val & 0xFFFFFFFF00000000) >> 32;
-	pcard->core_table_offset = (read_val & 0x00000000FFFFFFFF) >> 0;
+	pcard->core_table_length = (read_val & 0xFFFFFFFF00000000UL) >> 32;
+	pcard->core_table_offset = (read_val & 0x00000000FFFFFFFFUL) >> 0;
 
 	wait_and_read_ssid(pcard);
 
@@ -401,7 +401,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 		goto err_release_dma;
 
 	// Disable all "user" interrupts because they're not used yet.
-	writeq(0xFFFFFFFFFFFFFFFF,
+	writeq(0xFFFFFFFFFFFFFFFFUL,
 	       pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
 
 	// let the card master PCIe

commit a50185cbb383f29543a86ff238fff13ec850dbf9
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed Jun 19 08:36:07 2019 +0200

    staging: kpc2000: simplify error handling in kp2000_pcie_probe
    
    We can get rid of a few iounmaps in the middle of the function by
    re-ordering the error handling labels and adding two new labels.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 610ea549d240..cb05cca687e1 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -351,12 +351,11 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 
 	err = pci_request_region(pcard->pdev, REG_BAR, KP_DRIVER_NAME_KP2000);
 	if (err) {
-		iounmap(pcard->regs_bar_base);
 		dev_err(&pcard->pdev->dev,
 			"probe: failed to acquire PCI region (%d)\n",
 			err);
 		err = -ENODEV;
-		goto err_disable_device;
+		goto err_unmap_regs;
 	}
 
 	pcard->regs_base_resource.start = reg_bar_phys_addr;
@@ -374,7 +373,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 		dev_err(&pcard->pdev->dev,
 			"probe: DMA_BAR could not remap memory to virtual space\n");
 		err = -ENODEV;
-		goto err_unmap_regs;
+		goto err_release_regs;
 	}
 	dev_dbg(&pcard->pdev->dev,
 		"probe: DMA_BAR virt hardware address start [%p]\n",
@@ -384,11 +383,10 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 
 	err = pci_request_region(pcard->pdev, DMA_BAR, "kp2000_pcie");
 	if (err) {
-		iounmap(pcard->dma_bar_base);
 		dev_err(&pcard->pdev->dev,
 			"probe: failed to acquire PCI region (%d)\n", err);
 		err = -ENODEV;
-		goto err_unmap_regs;
+		goto err_unmap_dma;
 	}
 
 	pcard->dma_base_resource.start = dma_bar_phys_addr;
@@ -400,7 +398,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	pcard->sysinfo_regs_base = pcard->regs_bar_base;
 	err = read_system_regs(pcard);
 	if (err)
-		goto err_unmap_dma;
+		goto err_release_dma;
 
 	// Disable all "user" interrupts because they're not used yet.
 	writeq(0xFFFFFFFFFFFFFFFF,
@@ -438,14 +436,14 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	if (err) {
 		dev_err(&pcard->pdev->dev,
 			"CANNOT use DMA mask %0llx\n", DMA_BIT_MASK(64));
-		goto err_unmap_dma;
+		goto err_release_dma;
 	}
 	dev_dbg(&pcard->pdev->dev,
 		"Using DMA mask %0llx\n", dma_get_mask(PCARD_TO_DEV(pcard)));
 
 	err = pci_enable_msi(pcard->pdev);
 	if (err < 0)
-		goto err_unmap_dma;
+		goto err_release_dma;
 
 	rv = request_irq(pcard->pdev->irq, kp2000_irq_handler, IRQF_SHARED,
 			 pcard->name, pcard);
@@ -478,14 +476,14 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	free_irq(pcard->pdev->irq, pcard);
 err_disable_msi:
 	pci_disable_msi(pcard->pdev);
+err_release_dma:
+	pci_release_region(pdev, DMA_BAR);
 err_unmap_dma:
 	iounmap(pcard->dma_bar_base);
-	pci_release_region(pdev, DMA_BAR);
-	pcard->dma_bar_base = NULL;
+err_release_regs:
+	pci_release_region(pdev, REG_BAR);
 err_unmap_regs:
 	iounmap(pcard->regs_bar_base);
-	pci_release_region(pdev, REG_BAR);
-	pcard->regs_bar_base = NULL;
 err_disable_device:
 	pci_disable_device(pcard->pdev);
 err_remove_ida:

commit 0c3b9b7e19ecbebd1bce33f519e41fa5dba69eb4
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu Jun 13 15:14:51 2019 +0200

    staging: kpc2000: remove dead code in core.c
    
    Fixes checkpatch warning: "Consider removing the code enclosed by
    this #if 0 and its #endif".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 6a5999e8ff4e..610ea549d240 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -223,15 +223,9 @@ static void wait_and_read_ssid(struct kp2000_device *pcard)
 
 	dev_notice(&pcard->pdev->dev, "SSID didn't show up!\n");
 
-#if 0
-	// Timed out waiting for the SSID to show up, just use the DDNA instead?
-	read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_DDNA);
-	pcard->ssid = read_val;
-#else
 	// Timed out waiting for the SSID to show up, stick all zeros in the
 	// value
 	pcard->ssid = 0;
-#endif
 }
 
 static int  read_system_regs(struct kp2000_device *pcard)

commit eafae15fe16d472d3f0253fbc13f1a58c386a4d4
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed Jun 12 15:58:36 2019 +0200

    staging: kpc2000: remove unnecessary comments in kp2000_pcie_probe
    
    Much of the code comments in kp2000_pcie_probe just repeats the code and
    does not add any additional information. Delete them and make sure that
    comments still left in the function all use the same style.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index ee6b9be7127d..6a5999e8ff4e 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -311,18 +311,12 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	unsigned long dma_bar_phys_len;
 	u16 regval;
 
-	/*
-	 * Step 1: Allocate a struct for the pcard
-	 */
 	pcard = kzalloc(sizeof(*pcard), GFP_KERNEL);
 	if (!pcard)
 		return -ENOMEM;
 	dev_dbg(&pdev->dev, "probe: allocated struct kp2000_device @ %p\n",
 		pcard);
 
-	/*
-	 * Step 2: Initialize trivial pcard elements
-	 */
 	err = ida_simple_get(&card_num_ida, 1, INT_MAX, GFP_KERNEL);
 	if (err < 0) {
 		dev_err(&pdev->dev, "probe: failed to get card number (%d)\n",
@@ -338,9 +332,6 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	pcard->pdev = pdev;
 	pci_set_drvdata(pdev, pcard);
 
-	/*
-	 * Step 3: Enable PCI device
-	 */
 	err = pci_enable_device(pcard->pdev);
 	if (err) {
 		dev_err(&pcard->pdev->dev,
@@ -349,9 +340,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 		goto err_remove_ida;
 	}
 
-	/*
-	 * Step 4: Setup the Register BAR
-	 */
+	/* Setup the Register BAR */
 	reg_bar_phys_addr = pci_resource_start(pcard->pdev, REG_BAR);
 	reg_bar_phys_len = pci_resource_len(pcard->pdev, REG_BAR);
 
@@ -381,9 +370,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 					  reg_bar_phys_len - 1;
 	pcard->regs_base_resource.flags = IORESOURCE_MEM;
 
-	/*
-	 * Step 5: Setup the DMA BAR
-	 */
+	/* Setup the DMA BAR */
 	dma_bar_phys_addr = pci_resource_start(pcard->pdev, DMA_BAR);
 	dma_bar_phys_len = pci_resource_len(pcard->pdev, DMA_BAR);
 
@@ -415,9 +402,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 					 dma_bar_phys_len - 1;
 	pcard->dma_base_resource.flags = IORESOURCE_MEM;
 
-	/*
-	 * Step 6: System Regs
-	 */
+	/* Read System Regs */
 	pcard->sysinfo_regs_base = pcard->regs_bar_base;
 	err = read_system_regs(pcard);
 	if (err)
@@ -427,11 +412,9 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	writeq(0xFFFFFFFFFFFFFFFF,
 	       pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
 
-	/*
-	 * Step 7: Configure PCI thingies
-	 */
 	// let the card master PCIe
 	pci_set_master(pcard->pdev);
+
 	// enable IO and mem if not already done
 	pci_read_config_word(pcard->pdev, PCI_COMMAND, &regval);
 	regval |= (PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
@@ -466,9 +449,6 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	dev_dbg(&pcard->pdev->dev,
 		"Using DMA mask %0llx\n", dma_get_mask(PCARD_TO_DEV(pcard)));
 
-	/*
-	 * Step 8: Configure IRQs
-	 */
 	err = pci_enable_msi(pcard->pdev);
 	if (err < 0)
 		goto err_unmap_dma;
@@ -481,25 +461,17 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 		goto err_disable_msi;
 	}
 
-	/*
-	 * Step 9: Setup sysfs attributes
-	 */
 	err = sysfs_create_files(&pdev->dev.kobj, kp_attr_list);
 	if (err) {
 		dev_err(&pdev->dev, "Failed to add sysfs files: %d\n", err);
 		goto err_free_irq;
 	}
 
-	/*
-	 * Step 10: Probe cores
-	 */
 	err = kp2000_probe_cores(pcard);
 	if (err)
 		goto err_remove_sysfs;
 
-	/*
-	 * Step 11: Enable IRQs in HW
-	 */
+	/* Enable IRQs in HW */
 	writel(KPC_DMA_CARD_IRQ_ENABLE | KPC_DMA_CARD_USER_INTERRUPT_MODE,
 	       pcard->dma_common_regs);
 

commit fd5a82f4a6158bbd975a8858239cfd651170528b
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed Jun 12 15:58:35 2019 +0200

    staging: kpc2000: improve label names in kp2000_pcie_probe
    
    Use self-explanatory label names instead of the generic numbered ones,
    to make it easier to follow and understand the code.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 9b9b29ac90c5..ee6b9be7127d 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -327,7 +327,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	if (err < 0) {
 		dev_err(&pdev->dev, "probe: failed to get card number (%d)\n",
 			err);
-		goto out2;
+		goto err_free_pcard;
 	}
 	pcard->card_num = err;
 	scnprintf(pcard->name, 16, "kpcard%u", pcard->card_num);
@@ -346,7 +346,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 		dev_err(&pcard->pdev->dev,
 			"probe: failed to enable PCIE2000 PCIe device (%d)\n",
 			err);
-		goto out3;
+		goto err_remove_ida;
 	}
 
 	/*
@@ -360,7 +360,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 		dev_err(&pcard->pdev->dev,
 			"probe: REG_BAR could not remap memory to virtual space\n");
 		err = -ENODEV;
-		goto out4;
+		goto err_disable_device;
 	}
 	dev_dbg(&pcard->pdev->dev,
 		"probe: REG_BAR virt hardware address start [%p]\n",
@@ -373,7 +373,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 			"probe: failed to acquire PCI region (%d)\n",
 			err);
 		err = -ENODEV;
-		goto out4;
+		goto err_disable_device;
 	}
 
 	pcard->regs_base_resource.start = reg_bar_phys_addr;
@@ -393,7 +393,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 		dev_err(&pcard->pdev->dev,
 			"probe: DMA_BAR could not remap memory to virtual space\n");
 		err = -ENODEV;
-		goto out5;
+		goto err_unmap_regs;
 	}
 	dev_dbg(&pcard->pdev->dev,
 		"probe: DMA_BAR virt hardware address start [%p]\n",
@@ -407,7 +407,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 		dev_err(&pcard->pdev->dev,
 			"probe: failed to acquire PCI region (%d)\n", err);
 		err = -ENODEV;
-		goto out5;
+		goto err_unmap_regs;
 	}
 
 	pcard->dma_base_resource.start = dma_bar_phys_addr;
@@ -421,7 +421,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	pcard->sysinfo_regs_base = pcard->regs_bar_base;
 	err = read_system_regs(pcard);
 	if (err)
-		goto out6;
+		goto err_unmap_dma;
 
 	// Disable all "user" interrupts because they're not used yet.
 	writeq(0xFFFFFFFFFFFFFFFF,
@@ -461,7 +461,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	if (err) {
 		dev_err(&pcard->pdev->dev,
 			"CANNOT use DMA mask %0llx\n", DMA_BIT_MASK(64));
-		goto out7;
+		goto err_unmap_dma;
 	}
 	dev_dbg(&pcard->pdev->dev,
 		"Using DMA mask %0llx\n", dma_get_mask(PCARD_TO_DEV(pcard)));
@@ -471,14 +471,14 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	 */
 	err = pci_enable_msi(pcard->pdev);
 	if (err < 0)
-		goto out8a;
+		goto err_unmap_dma;
 
 	rv = request_irq(pcard->pdev->irq, kp2000_irq_handler, IRQF_SHARED,
 			 pcard->name, pcard);
 	if (rv) {
 		dev_err(&pcard->pdev->dev,
 			"%s: failed to request_irq: %d\n", __func__, rv);
-		goto out8b;
+		goto err_disable_msi;
 	}
 
 	/*
@@ -487,7 +487,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	err = sysfs_create_files(&pdev->dev.kobj, kp_attr_list);
 	if (err) {
 		dev_err(&pdev->dev, "Failed to add sysfs files: %d\n", err);
-		goto out9;
+		goto err_free_irq;
 	}
 
 	/*
@@ -495,7 +495,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	 */
 	err = kp2000_probe_cores(pcard);
 	if (err)
-		goto out10;
+		goto err_remove_sysfs;
 
 	/*
 	 * Step 11: Enable IRQs in HW
@@ -506,28 +506,26 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	mutex_unlock(&pcard->sem);
 	return 0;
 
-out10:
+err_remove_sysfs:
 	sysfs_remove_files(&pdev->dev.kobj, kp_attr_list);
-out9:
+err_free_irq:
 	free_irq(pcard->pdev->irq, pcard);
-out8b:
+err_disable_msi:
 	pci_disable_msi(pcard->pdev);
-out8a:
-out7:
-out6:
+err_unmap_dma:
 	iounmap(pcard->dma_bar_base);
 	pci_release_region(pdev, DMA_BAR);
 	pcard->dma_bar_base = NULL;
-out5:
+err_unmap_regs:
 	iounmap(pcard->regs_bar_base);
 	pci_release_region(pdev, REG_BAR);
 	pcard->regs_bar_base = NULL;
-out4:
+err_disable_device:
 	pci_disable_device(pcard->pdev);
-out3:
+err_remove_ida:
 	mutex_unlock(&pcard->sem);
 	ida_simple_remove(&card_num_ida, pcard->card_num);
-out2:
+err_free_pcard:
 	kfree(pcard);
 	return err;
 }

commit fef138203b9ebf401907ff0c716026429438c847
Author: Simon Sandström <simon@nikanor.nu>
Date:   Mon Jun 10 10:44:29 2019 +0200

    staging: kpc2000: remove unnecessary debug prints in core.c
    
    Debug prints that are used only to inform about function entry or exit
    can be removed as ftrace can be used to get this information.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 93e381198b45..9b9b29ac90c5 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -311,9 +311,6 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	unsigned long dma_bar_phys_len;
 	u16 regval;
 
-	dev_dbg(&pdev->dev, "%s(pdev = [%p], id = [%p])\n",
-		__func__, pdev, id);
-
 	/*
 	 * Step 1: Allocate a struct for the pcard
 	 */
@@ -506,7 +503,6 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	writel(KPC_DMA_CARD_IRQ_ENABLE | KPC_DMA_CARD_USER_INTERRUPT_MODE,
 	       pcard->dma_common_regs);
 
-	dev_dbg(&pcard->pdev->dev, "%s() complete!\n", __func__);
 	mutex_unlock(&pcard->sem);
 	return 0;
 
@@ -540,8 +536,6 @@ static void kp2000_pcie_remove(struct pci_dev *pdev)
 {
 	struct kp2000_device *pcard = pci_get_drvdata(pdev);
 
-	dev_dbg(&pdev->dev, "%s(pdev=%p)\n", __func__, pdev);
-
 	if (!pcard)
 		return;
 

commit 89a237aa84c7047cafba99f5dc81983ed0c40704
Author: Fabio Estevam <festevam@gmail.com>
Date:   Wed Jun 5 18:54:21 2019 -0300

    staging: kpc2000: Use '%llx' for printing 'long long int' type
    
    In order to print a 'long long int' type the 'llx' specifier needs to be
    used.
    
    Change it accordingly in order to fix the following build warning:
    
    drivers/staging/kpc2000/kpc2000/core.c:245:4: warning: format '%lx' expects argument of type 'long unsigned int', but argument 4 has type 'long long int' [-Wformat=]
    
    Reported-by: Build bot for Mark Brown <broonie@kernel.org>
    Signed-off-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index cd3876f1ce17..93e381198b45 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -241,7 +241,7 @@ static int  read_system_regs(struct kp2000_device *pcard)
 	read_val = readq(pcard->sysinfo_regs_base + REG_MAGIC_NUMBER);
 	if (read_val != KP2000_MAGIC_VALUE) {
 		dev_err(&pcard->pdev->dev,
-			"Invalid magic!  Got: 0x%016llx  Want: 0x%016lx\n",
+			"Invalid magic!  Got: 0x%016llx  Want: 0x%016llx\n",
 			read_val, KP2000_MAGIC_VALUE);
 		return -EILSEQ;
 	}

commit c1c7830cc717e1b45a65d626c89074737351b479
Author: Simon Sandström <simon@nikanor.nu>
Date:   Tue Jun 4 00:29:16 2019 +0200

    staging: kpc2000: fix incorrect code comment in core.c
    
    Step 11 was removed from kp2000_pcie_probe in a previous commit but the
    comment was not changed to reflect this, so do it now.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 2d8d188624f7..cd3876f1ce17 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -501,7 +501,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 		goto out10;
 
 	/*
-	 * Step 12: Enable IRQs in HW
+	 * Step 11: Enable IRQs in HW
 	 */
 	writel(KPC_DMA_CARD_IRQ_ENABLE | KPC_DMA_CARD_USER_INTERRUPT_MODE,
 	       pcard->dma_common_regs);

commit a1ceab8b925199fd30ca777215957f374d3366a5
Author: Simon Sandström <simon@nikanor.nu>
Date:   Tue Jun 4 00:29:15 2019 +0200

    staging: kpc2000: use sizeof(var) in kzalloc call
    
    Fixes checkpatch.pl warning "Prefer kzalloc(sizeof(*pcard)...) over
    kzalloc(sizeof(struct kp2000_device)...)".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 3f17566a9d03..2d8d188624f7 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -317,7 +317,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	/*
 	 * Step 1: Allocate a struct for the pcard
 	 */
-	pcard = kzalloc(sizeof(struct kp2000_device), GFP_KERNEL);
+	pcard = kzalloc(sizeof(*pcard), GFP_KERNEL);
 	if (!pcard)
 		return -ENOMEM;
 	dev_dbg(&pdev->dev, "probe: allocated struct kp2000_device @ %p\n",

commit a12cae870afc084b9d6bfb7d805a92d61392c418
Author: Simon Sandström <simon@nikanor.nu>
Date:   Tue Jun 4 00:29:14 2019 +0200

    staging: kpc2000: remove unnecessary include in core.c
    
    Fixes checkpatch.pl warning "Use #include <linux/io.h> instead of
    <asm/io.h>".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 6d4fc1f37c9f..3f17566a9d03 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -12,7 +12,6 @@
 #include <linux/cdev.h>
 #include <linux/rwsem.h>
 #include <linux/uaccess.h>
-#include <asm/io.h>
 #include <linux/io.h>
 #include <linux/mfd/core.h>
 #include <linux/platform_device.h>

commit 745cde4ef6e3e32cb13312c346626f2bc4ebf6e2
Author: Simon Sandström <simon@nikanor.nu>
Date:   Tue Jun 4 00:29:13 2019 +0200

    staging: kpc2000: use __func__ in debug messages in core.c
    
    Fixes checkpatch.pl warning "Prefer using '"%s...", __func__' to using
    '<function name>', this function's name, in a string".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index a70665a202c3..6d4fc1f37c9f 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -312,8 +312,8 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	unsigned long dma_bar_phys_len;
 	u16 regval;
 
-	dev_dbg(&pdev->dev, "kp2000_pcie_probe(pdev = [%p], id = [%p])\n",
-		pdev, id);
+	dev_dbg(&pdev->dev, "%s(pdev = [%p], id = [%p])\n",
+		__func__, pdev, id);
 
 	/*
 	 * Step 1: Allocate a struct for the pcard
@@ -481,7 +481,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 			 pcard->name, pcard);
 	if (rv) {
 		dev_err(&pcard->pdev->dev,
-			"kp2000_pcie_probe: failed to request_irq: %d\n", rv);
+			"%s: failed to request_irq: %d\n", __func__, rv);
 		goto out8b;
 	}
 
@@ -507,7 +507,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	writel(KPC_DMA_CARD_IRQ_ENABLE | KPC_DMA_CARD_USER_INTERRUPT_MODE,
 	       pcard->dma_common_regs);
 
-	dev_dbg(&pcard->pdev->dev, "kp2000_pcie_probe() complete!\n");
+	dev_dbg(&pcard->pdev->dev, "%s() complete!\n", __func__);
 	mutex_unlock(&pcard->sem);
 	return 0;
 
@@ -541,7 +541,7 @@ static void kp2000_pcie_remove(struct pci_dev *pdev)
 {
 	struct kp2000_device *pcard = pci_get_drvdata(pdev);
 
-	dev_dbg(&pdev->dev, "kp2000_pcie_remove(pdev=%p)\n", pdev);
+	dev_dbg(&pdev->dev, "%s(pdev=%p)\n", __func__, pdev);
 
 	if (!pcard)
 		return;

commit 5298be4877f39b1cd926adeed58a424996999193
Author: Simon Sandström <simon@nikanor.nu>
Date:   Tue Jun 4 00:29:12 2019 +0200

    staging: kpc2000: remove unnecessary oom message in core.c
    
    Fixes checkpatch.pl warning "Possible unnecessary 'out of memory'
    message".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index dc6940e6c320..a70665a202c3 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -319,11 +319,8 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	 * Step 1: Allocate a struct for the pcard
 	 */
 	pcard = kzalloc(sizeof(struct kp2000_device), GFP_KERNEL);
-	if (!pcard) {
-		dev_err(&pdev->dev,
-			"probe: failed to allocate private card data\n");
+	if (!pcard)
 		return -ENOMEM;
-	}
 	dev_dbg(&pdev->dev, "probe: allocated struct kp2000_device @ %p\n",
 		pcard);
 

commit 1c10f069407417ffa1c4b3f508ea1ab5425e1e7c
Author: Simon Sandström <simon@nikanor.nu>
Date:   Tue Jun 4 00:29:11 2019 +0200

    staging: kpc2000: remove unnecessary parentheses in core.c
    
    Fixes checkpatch.pl check "Unnecessary parentheses around
    pdev->dev.kobj".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 356a272c0b9c..dc6940e6c320 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -491,7 +491,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	/*
 	 * Step 9: Setup sysfs attributes
 	 */
-	err = sysfs_create_files(&(pdev->dev.kobj), kp_attr_list);
+	err = sysfs_create_files(&pdev->dev.kobj, kp_attr_list);
 	if (err) {
 		dev_err(&pdev->dev, "Failed to add sysfs files: %d\n", err);
 		goto out9;
@@ -515,7 +515,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	return 0;
 
 out10:
-	sysfs_remove_files(&(pdev->dev.kobj), kp_attr_list);
+	sysfs_remove_files(&pdev->dev.kobj, kp_attr_list);
 out9:
 	free_irq(pcard->pdev->irq, pcard);
 out8b:
@@ -552,7 +552,7 @@ static void kp2000_pcie_remove(struct pci_dev *pdev)
 	mutex_lock(&pcard->sem);
 	kp2000_remove_cores(pcard);
 	mfd_remove_devices(PCARD_TO_DEV(pcard));
-	sysfs_remove_files(&(pdev->dev.kobj), kp_attr_list);
+	sysfs_remove_files(&pdev->dev.kobj, kp_attr_list);
 	free_irq(pcard->pdev->irq, pcard);
 	pci_disable_msi(pcard->pdev);
 	if (pcard->dma_bar_base) {

commit 636928fc127549658ac6bfaae2c106d68195a063
Author: Simon Sandström <simon@nikanor.nu>
Date:   Tue Jun 4 00:29:10 2019 +0200

    staging: kpc2000: simplify comparisons to NULL in core.c
    
    Fixes checkpatch.pl warnings "Comparison to NULL could be written [...]"
    and "Comparisons should place the constant on the right side of the
    test".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 7f257c21e0cc..356a272c0b9c 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -319,7 +319,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	 * Step 1: Allocate a struct for the pcard
 	 */
 	pcard = kzalloc(sizeof(struct kp2000_device), GFP_KERNEL);
-	if (NULL == pcard) {
+	if (!pcard) {
 		dev_err(&pdev->dev,
 			"probe: failed to allocate private card data\n");
 		return -ENOMEM;
@@ -363,7 +363,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	reg_bar_phys_len = pci_resource_len(pcard->pdev, REG_BAR);
 
 	pcard->regs_bar_base = ioremap_nocache(reg_bar_phys_addr, PAGE_SIZE);
-	if (NULL == pcard->regs_bar_base) {
+	if (!pcard->regs_bar_base) {
 		dev_err(&pcard->pdev->dev,
 			"probe: REG_BAR could not remap memory to virtual space\n");
 		err = -ENODEV;
@@ -396,7 +396,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 
 	pcard->dma_bar_base = ioremap_nocache(dma_bar_phys_addr,
 					      dma_bar_phys_len);
-	if (NULL == pcard->dma_bar_base) {
+	if (!pcard->dma_bar_base) {
 		dev_err(&pcard->pdev->dev,
 			"probe: DMA_BAR could not remap memory to virtual space\n");
 		err = -ENODEV;
@@ -546,7 +546,7 @@ static void kp2000_pcie_remove(struct pci_dev *pdev)
 
 	dev_dbg(&pdev->dev, "kp2000_pcie_remove(pdev=%p)\n", pdev);
 
-	if (pcard == NULL)
+	if (!pcard)
 		return;
 
 	mutex_lock(&pcard->sem);
@@ -555,12 +555,12 @@ static void kp2000_pcie_remove(struct pci_dev *pdev)
 	sysfs_remove_files(&(pdev->dev.kobj), kp_attr_list);
 	free_irq(pcard->pdev->irq, pcard);
 	pci_disable_msi(pcard->pdev);
-	if (pcard->dma_bar_base != NULL) {
+	if (pcard->dma_bar_base) {
 		iounmap(pcard->dma_bar_base);
 		pci_release_region(pdev, DMA_BAR);
 		pcard->dma_bar_base = NULL;
 	}
-	if (pcard->regs_bar_base != NULL) {
+	if (pcard->regs_bar_base) {
 		iounmap(pcard->regs_bar_base);
 		pci_release_region(pdev, REG_BAR);
 		pcard->regs_bar_base = NULL;

commit a31f13af7da9c47ebbbc0d8d1161952bac9b09ed
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Fri May 31 11:52:31 2019 +0100

    staging: kpc2000: removed misc device.
    
    Now that all the card information is available via sysfs, the misc
    device is no longer necessary.  Removed it.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 4d6a443d7301..7f257c21e0cc 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -300,111 +300,6 @@ static irqreturn_t kp2000_irq_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int kp2000_cdev_open(struct inode *inode, struct file *filp)
-{
-	struct kp2000_device *pcard = container_of(filp->private_data, struct kp2000_device, miscdev);
-
-	dev_dbg(&pcard->pdev->dev, "kp2000_cdev_open(filp = [%p], pcard = [%p])\n", filp, pcard);
-
-	filp->private_data = pcard; /* so other methods can access it */
-
-	return 0;
-}
-
-static int kp2000_cdev_close(struct inode *inode, struct file *filp)
-{
-	struct kp2000_device *pcard = filp->private_data;
-
-	dev_dbg(&pcard->pdev->dev, "kp2000_cdev_close(filp = [%p], pcard = [%p])\n", filp, pcard);
-	return 0;
-}
-
-static ssize_t kp2000_cdev_read(struct file *filp, char __user *buf,
-				size_t count, loff_t *f_pos)
-{
-	struct kp2000_device *pcard = filp->private_data;
-	int cnt = 0;
-	int ret;
-#define BUFF_CNT  1024
-	char buff[BUFF_CNT] = {0}; //NOTE: Increase this so it is at least as large as all the scnprintfs.  And don't use unbounded strings. "%s"
-	//NOTE: also, this is a really shitty way to implement the read() call, but it will work for any size 'count'.
-
-	if (WARN(NULL == buf, "kp2000_cdev_read: buf is a NULL pointer!\n"))
-		return -EINVAL;
-
-	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Card ID                 : 0x%08x\n", pcard->card_id);
-	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Build Version           : 0x%08x\n", pcard->build_version);
-	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Build Date              : 0x%08x\n", pcard->build_datestamp);
-	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Build Time              : 0x%08x\n", pcard->build_timestamp);
-	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Core Table Offset       : 0x%08x\n", pcard->core_table_offset);
-	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Core Table Length       : 0x%08x\n", pcard->core_table_length);
-	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Hardware Revision       : 0x%08x\n", pcard->hardware_revision);
-	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "SSID                    : 0x%016llx\n", pcard->ssid);
-	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "DDNA                    : 0x%016llx\n", pcard->ddna);
-	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "IRQ Mask                : 0x%016llx\n", readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK));
-	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "IRQ Active              : 0x%016llx\n", readq(pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE));
-	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "CPLD                    : 0x%016llx\n", readq(pcard->sysinfo_regs_base + REG_CPLD_CONFIG));
-
-	if (*f_pos >= cnt)
-		return 0;
-
-	if (count > cnt)
-		count = cnt;
-
-	ret = copy_to_user(buf, buff + *f_pos, count);
-	if (ret)
-		return -EFAULT;
-	*f_pos += count;
-	return count;
-}
-
-static long kp2000_cdev_ioctl(struct file *filp, unsigned int ioctl_num,
-			      unsigned long ioctl_param)
-{
-	struct kp2000_device *pcard = filp->private_data;
-
-	dev_dbg(&pcard->pdev->dev, "kp2000_cdev_ioctl(filp = [%p], ioctl_num = 0x%08x, ioctl_param = 0x%016lx) pcard = [%p]\n", filp, ioctl_num, ioctl_param, pcard);
-
-	switch (ioctl_num){
-	case KP2000_IOCTL_GET_CPLD_REG:             return readq(pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
-	case KP2000_IOCTL_GET_PCIE_ERROR_REG:       return readq(pcard->sysinfo_regs_base + REG_PCIE_ERROR_COUNT);
-
-	case KP2000_IOCTL_GET_EVERYTHING: {
-		struct kp2000_regs regs;
-		int ret;
-
-		memset(&regs, 0, sizeof(regs));
-		regs.card_id = pcard->card_id;
-		regs.build_version = pcard->build_version;
-		regs.build_datestamp = pcard->build_datestamp;
-		regs.build_timestamp = pcard->build_timestamp;
-		regs.hw_rev = pcard->hardware_revision;
-		regs.ssid = pcard->ssid;
-		regs.ddna = pcard->ddna;
-		regs.cpld_reg = readq(pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
-
-		ret = copy_to_user((void*)ioctl_param, (void*)&regs, sizeof(regs));
-		if (ret)
-			return -EFAULT;
-
-		return sizeof(regs);
-		}
-
-	default:
-		return -ENOTTY;
-	}
-	return -ENOTTY;
-}
-
-static struct file_operations kp2000_fops = {
-	.owner =		THIS_MODULE,
-	.open =			kp2000_cdev_open,
-	.release =		kp2000_cdev_close,
-	.read =			kp2000_cdev_read,
-	.llseek =		noop_llseek,
-	.unlocked_ioctl =	kp2000_cdev_ioctl,
-};
-
 static int kp2000_pcie_probe(struct pci_dev *pdev,
 			     const struct pci_device_id *id)
 {
@@ -603,26 +498,11 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	}
 
 	/*
-	 * Step 10: Setup misc device
-	 */
-	pcard->miscdev.minor = MISC_DYNAMIC_MINOR;
-	pcard->miscdev.fops = &kp2000_fops;
-	pcard->miscdev.parent = &pcard->pdev->dev;
-	pcard->miscdev.name = pcard->name;
-
-	err = misc_register(&pcard->miscdev);
-	if (err) {
-		dev_err(&pcard->pdev->dev,
-			"kp2000_pcie_probe: misc_register failed: %d\n", err);
-		goto out10;
-	}
-
-	/*
-	 * Step 11: Probe cores
+	 * Step 10: Probe cores
 	 */
 	err = kp2000_probe_cores(pcard);
 	if (err)
-		goto out11;
+		goto out10;
 
 	/*
 	 * Step 12: Enable IRQs in HW
@@ -634,8 +514,6 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	mutex_unlock(&pcard->sem);
 	return 0;
 
-out11:
-	misc_deregister(&pcard->miscdev);
 out10:
 	sysfs_remove_files(&(pdev->dev.kobj), kp_attr_list);
 out9:
@@ -674,7 +552,6 @@ static void kp2000_pcie_remove(struct pci_dev *pdev)
 	mutex_lock(&pcard->sem);
 	kp2000_remove_cores(pcard);
 	mfd_remove_devices(PCARD_TO_DEV(pcard));
-	misc_deregister(&pcard->miscdev);
 	sysfs_remove_files(&(pdev->dev.kobj), kp_attr_list);
 	free_irq(pcard->pdev->irq, pcard);
 	pci_disable_msi(pcard->pdev);

commit eb1a5c64729d636fc1ff13939001bc49c9b67613
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Fri May 31 11:52:30 2019 +0100

    staging: kpc2000: export more device attributes via sysfs.
    
    Added more read-only device attributes in order to expose all the
    information about the hardware which is available by calling read() or
    ioct() on the misc device associated with it.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index a84cf8297917..4d6a443d7301 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -127,6 +127,58 @@ static ssize_t cpld_reconfigure(struct device *dev,
 }
 static DEVICE_ATTR(cpld_reconfigure, 0220, NULL, cpld_reconfigure);
 
+static ssize_t irq_mask_reg_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
+	u64 val;
+
+	val = readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
+	return sprintf(buf, "%016llx\n", val);
+}
+static DEVICE_ATTR_RO(irq_mask_reg);
+
+static ssize_t irq_active_reg_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
+	u64 val;
+
+	val = readq(pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE);
+	return sprintf(buf, "%016llx\n", val);
+}
+static DEVICE_ATTR_RO(irq_active_reg);
+
+static ssize_t pcie_error_count_reg_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
+	u64 val;
+
+	val = readq(pcard->sysinfo_regs_base + REG_PCIE_ERROR_COUNT);
+	return sprintf(buf, "%016llx\n", val);
+}
+static DEVICE_ATTR_RO(pcie_error_count_reg);
+
+static ssize_t core_table_offset_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%08x\n", pcard->core_table_offset);
+}
+static DEVICE_ATTR_RO(core_table_offset);
+
+static ssize_t core_table_length_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%08x\n", pcard->core_table_length);
+}
+static DEVICE_ATTR_RO(core_table_length);
+
 static const struct attribute *kp_attr_list[] = {
 	&dev_attr_ssid.attr,
 	&dev_attr_ddna.attr,
@@ -137,6 +189,11 @@ static const struct attribute *kp_attr_list[] = {
 	&dev_attr_build_time.attr,
 	&dev_attr_cpld_reg.attr,
 	&dev_attr_cpld_reconfigure.attr,
+	&dev_attr_irq_mask_reg.attr,
+	&dev_attr_irq_active_reg.attr,
+	&dev_attr_pcie_error_count_reg.attr,
+	&dev_attr_core_table_offset.attr,
+	&dev_attr_core_table_length.attr,
 	NULL,
 };
 

commit f5a4c0188cbbb4219acb7bf14d7c81a4fb0656d4
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed May 29 21:42:22 2019 +0200

    staging: kpc2000: replace bogus variable name in core.c
    
    "struct kp2000_regs temp" has nothing to do with temperatures, so
    replace it with the more proper name "regs".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 0b1724323cb7..a84cf8297917 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -313,24 +313,24 @@ static long kp2000_cdev_ioctl(struct file *filp, unsigned int ioctl_num,
 	case KP2000_IOCTL_GET_PCIE_ERROR_REG:       return readq(pcard->sysinfo_regs_base + REG_PCIE_ERROR_COUNT);
 
 	case KP2000_IOCTL_GET_EVERYTHING: {
-		struct kp2000_regs temp;
+		struct kp2000_regs regs;
 		int ret;
 
-		memset(&temp, 0, sizeof(temp));
-		temp.card_id = pcard->card_id;
-		temp.build_version = pcard->build_version;
-		temp.build_datestamp = pcard->build_datestamp;
-		temp.build_timestamp = pcard->build_timestamp;
-		temp.hw_rev = pcard->hardware_revision;
-		temp.ssid = pcard->ssid;
-		temp.ddna = pcard->ddna;
-		temp.cpld_reg = readq(pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
-
-		ret = copy_to_user((void*)ioctl_param, (void*)&temp, sizeof(temp));
+		memset(&regs, 0, sizeof(regs));
+		regs.card_id = pcard->card_id;
+		regs.build_version = pcard->build_version;
+		regs.build_datestamp = pcard->build_datestamp;
+		regs.build_timestamp = pcard->build_timestamp;
+		regs.hw_rev = pcard->hardware_revision;
+		regs.ssid = pcard->ssid;
+		regs.ddna = pcard->ddna;
+		regs.cpld_reg = readq(pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
+
+		ret = copy_to_user((void*)ioctl_param, (void*)&regs, sizeof(regs));
 		if (ret)
 			return -EFAULT;
 
-		return sizeof(temp);
+		return sizeof(regs);
 		}
 
 	default:

commit 8dd3355a229e2a14d7daa4e282b87000a0997d39
Author: Simon Sandström <simon@nikanor.nu>
Date:   Fri May 24 13:08:02 2019 +0200

    staging: kpc2000: remove extra spaces in core.c
    
    Fixes checkpatch.pl error "foo __init  bar" should be "foo __init bar"
    and "foo __exit  bar" should be "foo __exit bar".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 3da06e47a4d2..0b1724323cb7 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -655,7 +655,7 @@ static struct pci_driver kp2000_driver_inst = {
 	.remove =	kp2000_pcie_remove,
 };
 
-static int __init  kp2000_pcie_init(void)
+static int __init kp2000_pcie_init(void)
 {
 	kpc_uio_class = class_create(THIS_MODULE, "kpc_uio");
 	if (IS_ERR(kpc_uio_class))
@@ -666,7 +666,7 @@ static int __init  kp2000_pcie_init(void)
 }
 module_init(kp2000_pcie_init);
 
-static void __exit  kp2000_pcie_exit(void)
+static void __exit kp2000_pcie_exit(void)
 {
 	pci_unregister_driver(&kp2000_driver_inst);
 	class_destroy(kpc_uio_class);

commit 26c12642338b1d2cecae85e51439139ce7ff04aa
Author: Simon Sandström <simon@nikanor.nu>
Date:   Fri May 24 13:08:00 2019 +0200

    staging: kpc2000: remove extra blank line in core.c
    
    Fixes checkpatch.pl check "Please don't use multiple blank lines".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 4110032d0cbb..3da06e47a4d2 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -262,7 +262,6 @@ static int kp2000_cdev_close(struct inode *inode, struct file *filp)
 	return 0;
 }
 
-
 static ssize_t kp2000_cdev_read(struct file *filp, char __user *buf,
 				size_t count, loff_t *f_pos)
 {

commit 3df7e8a77e8cac1daea3ad0842ed3fd2105f98f0
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Tue May 21 11:35:24 2019 +0100

    staging: kpc2000: removed superfluous NULL checks from device attribute call-backs.
    
    All the attribute show call-backs check whether pcard is NULL.  However,
    pci_set_drvdata(pdev, pcard) is called before the sysfs files are
    created during probe, and pci_set_drvdata(pdev, NULL) is not called
    until after they are destroyed during remove; therefore, pcard will not
    be NULL, and we can drop the checks.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 2af4170a0d68..4110032d0cbb 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -37,9 +37,6 @@ static ssize_t ssid_show(struct device *dev, struct device_attribute *attr,
 {
 	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
-	if (!pcard)
-		return -ENXIO;
-
 	return sprintf(buf, "%016llx\n", pcard->ssid);
 }
 static DEVICE_ATTR_RO(ssid);
@@ -49,9 +46,6 @@ static ssize_t ddna_show(struct device *dev, struct device_attribute *attr,
 {
 	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
-	if (!pcard)
-		return -ENXIO;
-
 	return sprintf(buf, "%016llx\n", pcard->ddna);
 }
 static DEVICE_ATTR_RO(ddna);
@@ -61,9 +55,6 @@ static ssize_t card_id_show(struct device *dev, struct device_attribute *attr,
 {
 	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
-	if (!pcard)
-		return -ENXIO;
-
 	return sprintf(buf, "%08x\n", pcard->card_id);
 }
 static DEVICE_ATTR_RO(card_id);
@@ -73,9 +64,6 @@ static ssize_t hw_rev_show(struct device *dev, struct device_attribute *attr,
 {
 	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
-	if (!pcard)
-		return -ENXIO;
-
 	return sprintf(buf, "%08x\n", pcard->hardware_revision);
 }
 static DEVICE_ATTR_RO(hw_rev);
@@ -85,9 +73,6 @@ static ssize_t build_show(struct device *dev, struct device_attribute *attr,
 {
 	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
-	if (!pcard)
-		return -ENXIO;
-
 	return sprintf(buf, "%08x\n", pcard->build_version);
 }
 static DEVICE_ATTR_RO(build);
@@ -97,9 +82,6 @@ static ssize_t build_date_show(struct device *dev,
 {
 	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
-	if (!pcard)
-		return -ENXIO;
-
 	return sprintf(buf, "%08x\n", pcard->build_datestamp);
 }
 static DEVICE_ATTR_RO(build_date);
@@ -109,9 +91,6 @@ static ssize_t build_time_show(struct device *dev,
 {
 	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
-	if (!pcard)
-		return -ENXIO;
-
 	return sprintf(buf, "%08x\n", pcard->build_timestamp);
 }
 static DEVICE_ATTR_RO(build_time);
@@ -122,9 +101,6 @@ static ssize_t cpld_reg_show(struct device *dev, struct device_attribute *attr,
 	struct kp2000_device *pcard = dev_get_drvdata(dev);
 	u64 val;
 
-	if (!pcard)
-		return -ENXIO;
-
 	val = readq(pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
 	return sprintf(buf, "%016llx\n", val);
 }
@@ -138,9 +114,6 @@ static ssize_t cpld_reconfigure(struct device *dev,
 	long wr_val;
 	int rv;
 
-	if (!pcard)
-		return -ENXIO;
-
 	rv = kstrtol(buf, 0, &wr_val);
 	if (rv < 0)
 		return rv;

commit e416dad158f289ef2af48bf21fca53acc3935353
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Tue May 21 11:35:23 2019 +0100

    staging: kpc2000: simplified kp2000_device retrieval in device attribute call-backs.
    
    All the call-backs used the same formula to retrieve the pcard from dev:
    
      struct pci_dev *pdev = to_pci_dev(dev);
      struct kp2000_device *pcard;
    
      if (!pdev)
        return NULL;
    
      pcard = pci_get_drvdata(pdev);
    
    Since to_pci_dev is a wrapper for container_of, it will not return NULL,
    and since pci_get_drvdata just calls dev_get_drvdata on the dev member
    of pdev, this is equivalent to:
    
      struct kp2000_device *pcard = dev_get_drvdata(&(container_of(dev, struct pci_dev, dev)->dev));
    
    and we can simplify it to:
    
      struct kp2000_device *pcard = dev_get_drvdata(dev);
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 7d6b99fcd2bd..2af4170a0d68 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -32,20 +32,10 @@ static DEFINE_IDA(card_num_ida);
  * SysFS Attributes
  ******************************************************/
 
-static struct kp2000_device *get_pcard(struct device *dev)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-
-	if (!pdev)
-		return NULL;
-
-	return pci_get_drvdata(pdev);
-}
-
 static ssize_t ssid_show(struct device *dev, struct device_attribute *attr,
 			 char *buf)
 {
-	struct kp2000_device *pcard = get_pcard(dev);
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
 	if (!pcard)
 		return -ENXIO;
@@ -57,7 +47,7 @@ static DEVICE_ATTR_RO(ssid);
 static ssize_t ddna_show(struct device *dev, struct device_attribute *attr,
 			 char *buf)
 {
-	struct kp2000_device *pcard = get_pcard(dev);
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
 	if (!pcard)
 		return -ENXIO;
@@ -69,7 +59,7 @@ static DEVICE_ATTR_RO(ddna);
 static ssize_t card_id_show(struct device *dev, struct device_attribute *attr,
 			    char *buf)
 {
-	struct kp2000_device *pcard = get_pcard(dev);
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
 	if (!pcard)
 		return -ENXIO;
@@ -81,7 +71,7 @@ static DEVICE_ATTR_RO(card_id);
 static ssize_t hw_rev_show(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
-	struct kp2000_device *pcard = get_pcard(dev);
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
 	if (!pcard)
 		return -ENXIO;
@@ -93,7 +83,7 @@ static DEVICE_ATTR_RO(hw_rev);
 static ssize_t build_show(struct device *dev, struct device_attribute *attr,
 			  char *buf)
 {
-	struct kp2000_device *pcard = get_pcard(dev);
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
 	if (!pcard)
 		return -ENXIO;
@@ -105,7 +95,7 @@ static DEVICE_ATTR_RO(build);
 static ssize_t build_date_show(struct device *dev,
 			       struct device_attribute *attr, char *buf)
 {
-	struct kp2000_device *pcard = get_pcard(dev);
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
 	if (!pcard)
 		return -ENXIO;
@@ -117,7 +107,7 @@ static DEVICE_ATTR_RO(build_date);
 static ssize_t build_time_show(struct device *dev,
 			       struct device_attribute *attr, char *buf)
 {
-	struct kp2000_device *pcard = get_pcard(dev);
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
 
 	if (!pcard)
 		return -ENXIO;
@@ -129,7 +119,7 @@ static DEVICE_ATTR_RO(build_time);
 static ssize_t cpld_reg_show(struct device *dev, struct device_attribute *attr,
 			     char *buf)
 {
-	struct kp2000_device *pcard = get_pcard(dev);
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
 	u64 val;
 
 	if (!pcard)
@@ -144,7 +134,7 @@ static ssize_t cpld_reconfigure(struct device *dev,
 				struct device_attribute *attr,
 				const char *buf, size_t count)
 {
-	struct kp2000_device *pcard = get_pcard(dev);
+	struct kp2000_device *pcard = dev_get_drvdata(dev);
 	long wr_val;
 	int rv;
 

commit f731540813474de5d371d650ef00443aa7811b92
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Tue May 21 11:35:22 2019 +0100

    staging: kpc2000: use IDA to assign card numbers.
    
    Previously the next card number was assigned from a static int local
    variable.  Replaced it with an IDA.  Avoids the assignment of ever-
    increasing card-numbers by allowing them to be reused.
    
    Updated TODO.
    
    Corrected format-specifier for unsigned pcard->card_num.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 6b56ddcc03fa..7d6b99fcd2bd 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -1,5 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 #include <linux/kernel.h>
+#include <linux/idr.h>
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/pci.h>
@@ -25,6 +26,8 @@
 #include "pcie.h"
 #include "uapi.h"
 
+static DEFINE_IDA(card_num_ida);
+
 /*******************************************************
  * SysFS Attributes
  ******************************************************/
@@ -388,7 +391,6 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 {
 	int err = 0;
 	struct kp2000_device *pcard;
-	static int card_count = 1;
 	int rv;
 	unsigned long reg_bar_phys_addr;
 	unsigned long reg_bar_phys_len;
@@ -414,9 +416,14 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	/*
 	 * Step 2: Initialize trivial pcard elements
 	 */
-	pcard->card_num = card_count;
-	card_count++;
-	scnprintf(pcard->name, 16, "kpcard%d", pcard->card_num);
+	err = ida_simple_get(&card_num_ida, 1, INT_MAX, GFP_KERNEL);
+	if (err < 0) {
+		dev_err(&pdev->dev, "probe: failed to get card number (%d)\n",
+			err);
+		goto out2;
+	}
+	pcard->card_num = err;
+	scnprintf(pcard->name, 16, "kpcard%u", pcard->card_num);
 
 	mutex_init(&pcard->sem);
 	mutex_lock(&pcard->sem);
@@ -630,6 +637,8 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
 	pci_disable_device(pcard->pdev);
 out3:
 	mutex_unlock(&pcard->sem);
+	ida_simple_remove(&card_num_ida, pcard->card_num);
+out2:
 	kfree(pcard);
 	return err;
 }
@@ -663,6 +672,7 @@ static void kp2000_pcie_remove(struct pci_dev *pdev)
 	pci_disable_device(pcard->pdev);
 	pci_set_drvdata(pdev, NULL);
 	mutex_unlock(&pcard->sem);
+	ida_simple_remove(&card_num_ida, pcard->card_num);
 	kfree(pcard);
 }
 
@@ -698,6 +708,7 @@ static void __exit  kp2000_pcie_exit(void)
 {
 	pci_unregister_driver(&kp2000_driver_inst);
 	class_destroy(kpc_uio_class);
+	ida_destroy(&card_num_ida);
 }
 module_exit(kp2000_pcie_exit);
 

commit 80bcd6cc3966229f030c9903976245543208f446
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Tue May 21 11:35:21 2019 +0100

    staging: kpc2000: added separate show functions for readable kp device attributes, defined them as read-only, and declared them static.
    
    Defined separate simple show functions for each attribute instead of
    having a one big one containing a chain of conditionals.
    
    Replaced calls to scnprintf with sprintf since all the outputs are
    single integers.
    
    All the readable device attributes are read-only, so used DEVICE_ATTR_RO
    to define them.
    
    The definitions are only used to populate the kp_attr_list attribute
    array, so declared them as static.
    
    Fixes the following sparse warnings:
    
      drivers/staging/kpc2000/kpc2000/core.c:152:1: warning: symbol 'dev_attr_ssid' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/core.c:153:1: warning: symbol 'dev_attr_ddna' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/core.c:154:1: warning: symbol 'dev_attr_card_id' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/core.c:155:1: warning: symbol 'dev_attr_hw_rev' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/core.c:156:1: warning: symbol 'dev_attr_build' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/core.c:157:1: warning: symbol 'dev_attr_build_date' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/core.c:158:1: warning: symbol 'dev_attr_build_time' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/core.c:159:1: warning: symbol 'dev_attr_cpld_reg' was not declared. Should it be static?
      drivers/staging/kpc2000/kpc2000/core.c:161:1: warning: symbol 'dev_attr_cpld_reconfigure' was not declared. Should it be static?
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index e58bddec87ee..6b56ddcc03fa 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -39,7 +39,7 @@ static struct kp2000_device *get_pcard(struct device *dev)
 	return pci_get_drvdata(pdev);
 }
 
-static ssize_t show_attr(struct device *dev, struct device_attribute *attr,
+static ssize_t ssid_show(struct device *dev, struct device_attribute *attr,
 			 char *buf)
 {
 	struct kp2000_device *pcard = get_pcard(dev);
@@ -47,36 +47,84 @@ static ssize_t show_attr(struct device *dev, struct device_attribute *attr,
 	if (!pcard)
 		return -ENXIO;
 
-	if (strcmp("ssid", attr->attr.name) == 0)
-		return scnprintf(buf, PAGE_SIZE, "%016llx\n", pcard->ssid);
+	return sprintf(buf, "%016llx\n", pcard->ssid);
+}
+static DEVICE_ATTR_RO(ssid);
 
-	if (strcmp("ddna", attr->attr.name) == 0)
-		return scnprintf(buf, PAGE_SIZE, "%016llx\n", pcard->ddna);
+static ssize_t ddna_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct kp2000_device *pcard = get_pcard(dev);
 
-	if (strcmp("card_id", attr->attr.name) == 0)
-		return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->card_id);
+	if (!pcard)
+		return -ENXIO;
+
+	return sprintf(buf, "%016llx\n", pcard->ddna);
+}
+static DEVICE_ATTR_RO(ddna);
+
+static ssize_t card_id_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct kp2000_device *pcard = get_pcard(dev);
 
-	if (strcmp("hw_rev", attr->attr.name) == 0)
-		return scnprintf(buf, PAGE_SIZE, "%08x\n",
-				 pcard->hardware_revision);
+	if (!pcard)
+		return -ENXIO;
 
-	if (strcmp("build", attr->attr.name) == 0)
-		return scnprintf(buf, PAGE_SIZE, "%08x\n",
-				 pcard->build_version);
+	return sprintf(buf, "%08x\n", pcard->card_id);
+}
+static DEVICE_ATTR_RO(card_id);
 
-	if (strcmp("build_date", attr->attr.name) == 0)
-		return scnprintf(buf, PAGE_SIZE, "%08x\n",
-				 pcard->build_datestamp);
+static ssize_t hw_rev_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct kp2000_device *pcard = get_pcard(dev);
 
-	if (strcmp("build_time", attr->attr.name) == 0)
-		return scnprintf(buf, PAGE_SIZE, "%08x\n",
-				 pcard->build_timestamp);
+	if (!pcard)
+		return -ENXIO;
 
-	return -ENXIO;
+	return sprintf(buf, "%08x\n", pcard->hardware_revision);
 }
+static DEVICE_ATTR_RO(hw_rev);
 
-static ssize_t show_cpld_config_reg(struct device *dev,
-				    struct device_attribute *attr, char *buf)
+static ssize_t build_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct kp2000_device *pcard = get_pcard(dev);
+
+	if (!pcard)
+		return -ENXIO;
+
+	return sprintf(buf, "%08x\n", pcard->build_version);
+}
+static DEVICE_ATTR_RO(build);
+
+static ssize_t build_date_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct kp2000_device *pcard = get_pcard(dev);
+
+	if (!pcard)
+		return -ENXIO;
+
+	return sprintf(buf, "%08x\n", pcard->build_datestamp);
+}
+static DEVICE_ATTR_RO(build_date);
+
+static ssize_t build_time_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct kp2000_device *pcard = get_pcard(dev);
+
+	if (!pcard)
+		return -ENXIO;
+
+	return sprintf(buf, "%08x\n", pcard->build_timestamp);
+}
+static DEVICE_ATTR_RO(build_time);
+
+static ssize_t cpld_reg_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
 {
 	struct kp2000_device *pcard = get_pcard(dev);
 	u64 val;
@@ -85,8 +133,9 @@ static ssize_t show_cpld_config_reg(struct device *dev,
 		return -ENXIO;
 
 	val = readq(pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
-	return scnprintf(buf, PAGE_SIZE, "%016llx\n", val);
+	return sprintf(buf, "%016llx\n", val);
 }
+static DEVICE_ATTR_RO(cpld_reg);
 
 static ssize_t cpld_reconfigure(struct device *dev,
 				struct device_attribute *attr,
@@ -110,16 +159,7 @@ static ssize_t cpld_reconfigure(struct device *dev,
 	writeq(wr_val, pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
 	return count;
 }
-
-DEVICE_ATTR(ssid,       0444, show_attr, NULL);
-DEVICE_ATTR(ddna,       0444, show_attr, NULL);
-DEVICE_ATTR(card_id,    0444, show_attr, NULL);
-DEVICE_ATTR(hw_rev,     0444, show_attr, NULL);
-DEVICE_ATTR(build,      0444, show_attr, NULL);
-DEVICE_ATTR(build_date, 0444, show_attr, NULL);
-DEVICE_ATTR(build_time, 0444, show_attr, NULL);
-DEVICE_ATTR(cpld_reg,   0444, show_cpld_config_reg, NULL);
-DEVICE_ATTR(cpld_reconfigure,   0220, NULL, cpld_reconfigure);
+static DEVICE_ATTR(cpld_reconfigure, 0220, NULL, cpld_reconfigure);
 
 static const struct attribute *kp_attr_list[] = {
 	&dev_attr_ssid.attr,

commit a986d796395c18e607703af11e1afc1d3a8a5908
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Tue May 21 11:35:20 2019 +0100

    staging: kpc2000: added a helper to get struct kp2000_device from struct device.
    
    The attribute call-backs all use the same formula to get the pcard from
    dev:
    
      struct pci_dev *pdev = to_pci_dev(dev);
      struct kp2000_device *pcard;
    
      if (!pdev)
        return -ENXIO;
      pcard = pci_get_drvdata(pdev);
      if (!pcard)
        return -ENXIO;
    
    Added a function to reduce the duplicated code.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index f1735237cfb6..e58bddec87ee 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -29,15 +29,21 @@
  * SysFS Attributes
  ******************************************************/
 
-static ssize_t show_attr(struct device *dev, struct device_attribute *attr,
-			 char *buf)
+static struct kp2000_device *get_pcard(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
-	struct kp2000_device *pcard;
 
 	if (!pdev)
-		return -ENXIO;
-	pcard = pci_get_drvdata(pdev);
+		return NULL;
+
+	return pci_get_drvdata(pdev);
+}
+
+static ssize_t show_attr(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct kp2000_device *pcard = get_pcard(dev);
+
 	if (!pcard)
 		return -ENXIO;
 
@@ -72,14 +78,9 @@ static ssize_t show_attr(struct device *dev, struct device_attribute *attr,
 static ssize_t show_cpld_config_reg(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct kp2000_device *pcard;
+	struct kp2000_device *pcard = get_pcard(dev);
 	u64 val;
 
-	if (!pdev)
-		return -ENXIO;
-
-	pcard = pci_get_drvdata(pdev);
 	if (!pcard)
 		return -ENXIO;
 
@@ -91,14 +92,10 @@ static ssize_t cpld_reconfigure(struct device *dev,
 				struct device_attribute *attr,
 				const char *buf, size_t count)
 {
-	struct pci_dev *pdev = to_pci_dev(dev);
+	struct kp2000_device *pcard = get_pcard(dev);
 	long wr_val;
-	struct kp2000_device *pcard;
 	int rv;
 
-	if (!pdev)
-		return -ENXIO;
-	pcard = pci_get_drvdata(pdev);
 	if (!pcard)
 		return -ENXIO;
 

commit d8ac35939632f25d6b1465a921f8a4d63064e3ae
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Tue May 21 11:35:19 2019 +0100

    staging: kpc2000: improved formatting of core.c.
    
      * Indented with tabs.
      * Broke lines over 80 columns where possible.
      * Removed braces from one-statement blocks.
      * Tidied up some comments.
      * Removed multiple blank lines.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 8e6db806f260..f1735237cfb6 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -26,28 +26,51 @@
 #include "uapi.h"
 
 /*******************************************************
-  * SysFS Attributes
-  ******************************************************/
-static ssize_t  show_attr(struct device *dev, struct device_attribute *attr, char *buf)
+ * SysFS Attributes
+ ******************************************************/
+
+static ssize_t show_attr(struct device *dev, struct device_attribute *attr,
+			 char *buf)
 {
-    struct pci_dev *pdev = to_pci_dev(dev);
-    struct kp2000_device *pcard;
-
-    if (!pdev)  return -ENXIO;
-    pcard = pci_get_drvdata(pdev);
-    if (!pcard)  return -ENXIO;
-
-    if (strcmp("ssid", attr->attr.name) == 0){         return scnprintf(buf, PAGE_SIZE, "%016llx\n", pcard->ssid);  } else
-    if (strcmp("ddna", attr->attr.name) == 0){         return scnprintf(buf, PAGE_SIZE, "%016llx\n", pcard->ddna);  } else
-    if (strcmp("card_id", attr->attr.name) == 0){      return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->card_id);  } else
-    if (strcmp("hw_rev", attr->attr.name) == 0){       return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->hardware_revision);  } else
-    if (strcmp("build", attr->attr.name) == 0){        return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->build_version);  } else
-    if (strcmp("build_date", attr->attr.name) == 0){   return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->build_datestamp);  } else
-    if (strcmp("build_time", attr->attr.name) == 0){   return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->build_timestamp);  } else
-    { return -ENXIO; }
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct kp2000_device *pcard;
+
+	if (!pdev)
+		return -ENXIO;
+	pcard = pci_get_drvdata(pdev);
+	if (!pcard)
+		return -ENXIO;
+
+	if (strcmp("ssid", attr->attr.name) == 0)
+		return scnprintf(buf, PAGE_SIZE, "%016llx\n", pcard->ssid);
+
+	if (strcmp("ddna", attr->attr.name) == 0)
+		return scnprintf(buf, PAGE_SIZE, "%016llx\n", pcard->ddna);
+
+	if (strcmp("card_id", attr->attr.name) == 0)
+		return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->card_id);
+
+	if (strcmp("hw_rev", attr->attr.name) == 0)
+		return scnprintf(buf, PAGE_SIZE, "%08x\n",
+				 pcard->hardware_revision);
+
+	if (strcmp("build", attr->attr.name) == 0)
+		return scnprintf(buf, PAGE_SIZE, "%08x\n",
+				 pcard->build_version);
+
+	if (strcmp("build_date", attr->attr.name) == 0)
+		return scnprintf(buf, PAGE_SIZE, "%08x\n",
+				 pcard->build_datestamp);
+
+	if (strcmp("build_time", attr->attr.name) == 0)
+		return scnprintf(buf, PAGE_SIZE, "%08x\n",
+				 pcard->build_timestamp);
+
+	return -ENXIO;
 }
 
-static ssize_t  show_cpld_config_reg(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_cpld_config_reg(struct device *dev,
+				    struct device_attribute *attr, char *buf)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct kp2000_device *pcard;
@@ -63,27 +86,33 @@ static ssize_t  show_cpld_config_reg(struct device *dev, struct device_attribute
 	val = readq(pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
 	return scnprintf(buf, PAGE_SIZE, "%016llx\n", val);
 }
-static ssize_t cpld_reconfigure(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+
+static ssize_t cpld_reconfigure(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
 {
-    struct pci_dev *pdev = to_pci_dev(dev);
-    long wr_val;
-    struct kp2000_device *pcard;
-    int rv;
-
-    if (!pdev)  return -ENXIO;
-    pcard = pci_get_drvdata(pdev);
-    if (!pcard)  return -ENXIO;
-
-    rv = kstrtol(buf, 0, &wr_val);
-    if (rv < 0)  return rv;
-    if (wr_val > 7)  return -EINVAL;
-
-    wr_val = wr_val << 8;
-    wr_val |= 0x1; // Set the "Configure Go" bit
-    writeq(wr_val, pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
-    return count;
-}
+	struct pci_dev *pdev = to_pci_dev(dev);
+	long wr_val;
+	struct kp2000_device *pcard;
+	int rv;
+
+	if (!pdev)
+		return -ENXIO;
+	pcard = pci_get_drvdata(pdev);
+	if (!pcard)
+		return -ENXIO;
+
+	rv = kstrtol(buf, 0, &wr_val);
+	if (rv < 0)
+		return rv;
+	if (wr_val > 7)
+		return -EINVAL;
 
+	wr_val = wr_val << 8;
+	wr_val |= 0x1; // Set the "Configure Go" bit
+	writeq(wr_val, pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
+	return count;
+}
 
 DEVICE_ATTR(ssid,       0444, show_attr, NULL);
 DEVICE_ATTR(ddna,       0444, show_attr, NULL);
@@ -95,106 +124,109 @@ DEVICE_ATTR(build_time, 0444, show_attr, NULL);
 DEVICE_ATTR(cpld_reg,   0444, show_cpld_config_reg, NULL);
 DEVICE_ATTR(cpld_reconfigure,   0220, NULL, cpld_reconfigure);
 
-static const struct attribute *  kp_attr_list[] = {
-    &dev_attr_ssid.attr,
-    &dev_attr_ddna.attr,
-    &dev_attr_card_id.attr,
-    &dev_attr_hw_rev.attr,
-    &dev_attr_build.attr,
-    &dev_attr_build_date.attr,
-    &dev_attr_build_time.attr,
-    &dev_attr_cpld_reg.attr,
-    &dev_attr_cpld_reconfigure.attr,
-    NULL,
+static const struct attribute *kp_attr_list[] = {
+	&dev_attr_ssid.attr,
+	&dev_attr_ddna.attr,
+	&dev_attr_card_id.attr,
+	&dev_attr_hw_rev.attr,
+	&dev_attr_build.attr,
+	&dev_attr_build_date.attr,
+	&dev_attr_build_time.attr,
+	&dev_attr_cpld_reg.attr,
+	&dev_attr_cpld_reconfigure.attr,
+	NULL,
 };
 
-
 /*******************************************************
-  * Functions
-  ******************************************************/
+ * Functions
+ ******************************************************/
 
 static void wait_and_read_ssid(struct kp2000_device *pcard)
 {
-    u64 read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_SSID);
-    unsigned long timeout;
-
-    if (read_val & 0x8000000000000000){
-        pcard->ssid = read_val;
-        return;
-    }
-
-    timeout = jiffies + (HZ * 2);
-    do {
-        read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_SSID);
-        if (read_val & 0x8000000000000000){
-            pcard->ssid = read_val;
-            return;
-        }
-        cpu_relax();
-        //schedule();
-    } while (time_before(jiffies, timeout));
-
-    dev_notice(&pcard->pdev->dev, "SSID didn't show up!\n");
-
-    #if 0
-    // Timed out waiting for the SSID to show up, just use the DDNA instead?
-    read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_DDNA);
-    pcard->ssid = read_val;
-    #else
-    // Timed out waiting for the SSID to show up, stick all zeros in the value
-    pcard->ssid = 0;
-    #endif
+	u64 read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_SSID);
+	unsigned long timeout;
+
+	if (read_val & 0x8000000000000000) {
+		pcard->ssid = read_val;
+		return;
+	}
+
+	timeout = jiffies + (HZ * 2);
+	do {
+		read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_SSID);
+		if (read_val & 0x8000000000000000) {
+			pcard->ssid = read_val;
+			return;
+		}
+		cpu_relax();
+		//schedule();
+	} while (time_before(jiffies, timeout));
+
+	dev_notice(&pcard->pdev->dev, "SSID didn't show up!\n");
+
+#if 0
+	// Timed out waiting for the SSID to show up, just use the DDNA instead?
+	read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_DDNA);
+	pcard->ssid = read_val;
+#else
+	// Timed out waiting for the SSID to show up, stick all zeros in the
+	// value
+	pcard->ssid = 0;
+#endif
 }
 
 static int  read_system_regs(struct kp2000_device *pcard)
 {
-    u64 read_val;
-
-    read_val = readq(pcard->sysinfo_regs_base + REG_MAGIC_NUMBER);
-    if (read_val != KP2000_MAGIC_VALUE){
-        dev_err(&pcard->pdev->dev, "Invalid magic!  Got: 0x%016llx  Want: 0x%016lx\n", read_val, KP2000_MAGIC_VALUE);
-        return -EILSEQ;
-    }
-
-    read_val = readq(pcard->sysinfo_regs_base + REG_CARD_ID_AND_BUILD);
-    pcard->card_id = (read_val & 0xFFFFFFFF00000000) >> 32;
-    pcard->build_version = (read_val & 0x00000000FFFFFFFF) >> 0;
-
-    read_val = readq(pcard->sysinfo_regs_base + REG_DATE_AND_TIME_STAMPS);
-    pcard->build_datestamp = (read_val & 0xFFFFFFFF00000000) >> 32;
-    pcard->build_timestamp = (read_val & 0x00000000FFFFFFFF) >> 0;
-
-    read_val = readq(pcard->sysinfo_regs_base + REG_CORE_TABLE_OFFSET);
-    pcard->core_table_length = (read_val & 0xFFFFFFFF00000000) >> 32;
-    pcard->core_table_offset = (read_val & 0x00000000FFFFFFFF) >> 0;
-
-    wait_and_read_ssid(pcard);
-
-    read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_HW_ID);
-    pcard->core_table_rev    = (read_val & 0x0000000000000F00) >> 8;
-    pcard->hardware_revision = (read_val & 0x000000000000001F);
-
-    read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_DDNA);
-    pcard->ddna = read_val;
-
-    dev_info(&pcard->pdev->dev, "system_regs: %08x %08x %08x %08x  %02x  %d %d  %016llx  %016llx\n",
-        pcard->card_id,
-        pcard->build_version,
-        pcard->build_datestamp,
-        pcard->build_timestamp,
-        pcard->hardware_revision,
-        pcard->core_table_rev,
-        pcard->core_table_length,
-        pcard->ssid,
-        pcard->ddna
-    );
-
-    if (pcard->core_table_rev > 1){
-        dev_err(&pcard->pdev->dev, "core table entry revision is higher than we can deal with, cannot continue with this card!\n");
-        return 1;
-    }
-
-    return 0;
+	u64 read_val;
+
+	read_val = readq(pcard->sysinfo_regs_base + REG_MAGIC_NUMBER);
+	if (read_val != KP2000_MAGIC_VALUE) {
+		dev_err(&pcard->pdev->dev,
+			"Invalid magic!  Got: 0x%016llx  Want: 0x%016lx\n",
+			read_val, KP2000_MAGIC_VALUE);
+		return -EILSEQ;
+	}
+
+	read_val = readq(pcard->sysinfo_regs_base + REG_CARD_ID_AND_BUILD);
+	pcard->card_id = (read_val & 0xFFFFFFFF00000000) >> 32;
+	pcard->build_version = (read_val & 0x00000000FFFFFFFF) >> 0;
+
+	read_val = readq(pcard->sysinfo_regs_base + REG_DATE_AND_TIME_STAMPS);
+	pcard->build_datestamp = (read_val & 0xFFFFFFFF00000000) >> 32;
+	pcard->build_timestamp = (read_val & 0x00000000FFFFFFFF) >> 0;
+
+	read_val = readq(pcard->sysinfo_regs_base + REG_CORE_TABLE_OFFSET);
+	pcard->core_table_length = (read_val & 0xFFFFFFFF00000000) >> 32;
+	pcard->core_table_offset = (read_val & 0x00000000FFFFFFFF) >> 0;
+
+	wait_and_read_ssid(pcard);
+
+	read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_HW_ID);
+	pcard->core_table_rev    = (read_val & 0x0000000000000F00) >> 8;
+	pcard->hardware_revision = (read_val & 0x000000000000001F);
+
+	read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_DDNA);
+	pcard->ddna = read_val;
+
+	dev_info(&pcard->pdev->dev,
+		 "system_regs: %08x %08x %08x %08x  %02x  %d %d  %016llx  %016llx\n",
+		 pcard->card_id,
+		 pcard->build_version,
+		 pcard->build_datestamp,
+		 pcard->build_timestamp,
+		 pcard->hardware_revision,
+		 pcard->core_table_rev,
+		 pcard->core_table_length,
+		 pcard->ssid,
+		 pcard->ddna);
+
+	if (pcard->core_table_rev > 1) {
+		dev_err(&pcard->pdev->dev,
+			"core table entry revision is higher than we can deal with, cannot continue with this card!\n");
+		return 1;
+	}
+
+	return 0;
 }
 
 static irqreturn_t kp2000_irq_handler(int irq, void *dev_id)
@@ -317,241 +349,284 @@ static struct file_operations kp2000_fops = {
 static int kp2000_pcie_probe(struct pci_dev *pdev,
 			     const struct pci_device_id *id)
 {
-    int err = 0;
-    struct kp2000_device *pcard;
-    static int card_count = 1;
-    int rv;
-    unsigned long reg_bar_phys_addr;
-    unsigned long reg_bar_phys_len;
-    unsigned long dma_bar_phys_addr;
-    unsigned long dma_bar_phys_len;
-    u16 regval;
-
-    dev_dbg(&pdev->dev, "kp2000_pcie_probe(pdev = [%p], id = [%p])\n", pdev, id);
-
-    //{ Step 1: Allocate a struct for the pcard
-    pcard = kzalloc(sizeof(struct kp2000_device), GFP_KERNEL);
-    if (NULL == pcard){
-        dev_err(&pdev->dev, "probe: failed to allocate private card data\n");
-        return -ENOMEM;
-    }
-    dev_dbg(&pdev->dev, "probe: allocated struct kp2000_device @ %p\n", pcard);
-    //}
-
-    //{ Step 2: Initialize trivial pcard elements
-    pcard->card_num = card_count;
-    card_count++;
-    scnprintf(pcard->name, 16, "kpcard%d", pcard->card_num);
-
-    mutex_init(&pcard->sem);
+	int err = 0;
+	struct kp2000_device *pcard;
+	static int card_count = 1;
+	int rv;
+	unsigned long reg_bar_phys_addr;
+	unsigned long reg_bar_phys_len;
+	unsigned long dma_bar_phys_addr;
+	unsigned long dma_bar_phys_len;
+	u16 regval;
+
+	dev_dbg(&pdev->dev, "kp2000_pcie_probe(pdev = [%p], id = [%p])\n",
+		pdev, id);
+
+	/*
+	 * Step 1: Allocate a struct for the pcard
+	 */
+	pcard = kzalloc(sizeof(struct kp2000_device), GFP_KERNEL);
+	if (NULL == pcard) {
+		dev_err(&pdev->dev,
+			"probe: failed to allocate private card data\n");
+		return -ENOMEM;
+	}
+	dev_dbg(&pdev->dev, "probe: allocated struct kp2000_device @ %p\n",
+		pcard);
+
+	/*
+	 * Step 2: Initialize trivial pcard elements
+	 */
+	pcard->card_num = card_count;
+	card_count++;
+	scnprintf(pcard->name, 16, "kpcard%d", pcard->card_num);
+
+	mutex_init(&pcard->sem);
 	mutex_lock(&pcard->sem);
 
-    pcard->pdev = pdev;
-    pci_set_drvdata(pdev, pcard);
-    //}
-
-    //{ Step 3: Enable PCI device
-    err = pci_enable_device(pcard->pdev);
-    if (err){
-        dev_err(&pcard->pdev->dev, "probe: failed to enable PCIE2000 PCIe device (%d)\n", err);
-        goto out3;
-    }
-    //}
-
-    //{ Step 4: Setup the Register BAR
-    reg_bar_phys_addr = pci_resource_start(pcard->pdev, REG_BAR);
-    reg_bar_phys_len = pci_resource_len(pcard->pdev, REG_BAR);
-
-    pcard->regs_bar_base = ioremap_nocache(reg_bar_phys_addr, PAGE_SIZE);
-    if (NULL == pcard->regs_bar_base){
-        dev_err(&pcard->pdev->dev, "probe: REG_BAR could not remap memory to virtual space\n");
-        err = -ENODEV;
-        goto out4;
-    }
-    dev_dbg(&pcard->pdev->dev, "probe: REG_BAR virt hardware address start [%p]\n", pcard->regs_bar_base);
-
-    err = pci_request_region(pcard->pdev, REG_BAR, KP_DRIVER_NAME_KP2000);
-    if (err){
-        iounmap(pcard->regs_bar_base);
-        dev_err(&pcard->pdev->dev, "probe: failed to acquire PCI region (%d)\n", err);
-        err = -ENODEV;
-        goto out4;
-    }
-
-    pcard->regs_base_resource.start = reg_bar_phys_addr;
-    pcard->regs_base_resource.end   = reg_bar_phys_addr + reg_bar_phys_len - 1;
-    pcard->regs_base_resource.flags = IORESOURCE_MEM;
-    //}
-
-    //{ Step 5: Setup the DMA BAR
-    dma_bar_phys_addr = pci_resource_start(pcard->pdev, DMA_BAR);
-    dma_bar_phys_len = pci_resource_len(pcard->pdev, DMA_BAR);
-
-    pcard->dma_bar_base = ioremap_nocache(dma_bar_phys_addr, dma_bar_phys_len);
-    if (NULL == pcard->dma_bar_base){
-        dev_err(&pcard->pdev->dev, "probe: DMA_BAR could not remap memory to virtual space\n");
-        err = -ENODEV;
-        goto out5;
-    }
-    dev_dbg(&pcard->pdev->dev, "probe: DMA_BAR virt hardware address start [%p]\n", pcard->dma_bar_base);
-
-    pcard->dma_common_regs = pcard->dma_bar_base + KPC_DMA_COMMON_OFFSET;
-
-    err = pci_request_region(pcard->pdev, DMA_BAR, "kp2000_pcie");
-    if (err){
-        iounmap(pcard->dma_bar_base);
-        dev_err(&pcard->pdev->dev, "probe: failed to acquire PCI region (%d)\n", err);
-        err = -ENODEV;
-        goto out5;
-    }
-
-    pcard->dma_base_resource.start = dma_bar_phys_addr;
-    pcard->dma_base_resource.end   = dma_bar_phys_addr + dma_bar_phys_len - 1;
-    pcard->dma_base_resource.flags = IORESOURCE_MEM;
-    //}
-
-    //{ Step 6: System Regs
-    pcard->sysinfo_regs_base = pcard->regs_bar_base;
-    err = read_system_regs(pcard);
-    if (err)
-        goto out6;
-
-    // Disable all "user" interrupts because they're not used yet.
-    writeq(0xFFFFFFFFFFFFFFFF, pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
-    //}
-
-    //{ Step 7: Configure PCI thingies
-    // let the card master PCIe
-    pci_set_master(pcard->pdev);
-    // enable IO and mem if not already done
-    pci_read_config_word(pcard->pdev, PCI_COMMAND, &regval);
-    regval |= (PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
-    pci_write_config_word(pcard->pdev, PCI_COMMAND, regval);
-
-    // Clear relaxed ordering bit
-    pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_RELAX_EN, 0);
-
-    // Set Max_Payload_Size and Max_Read_Request_Size
-    regval = (0x0) << 5; // Max_Payload_Size = 128 B
-    pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_PAYLOAD, regval);
-    regval = (0x0) << 12; // Max_Read_Request_Size = 128 B
-    pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_READRQ, regval);
-
-    // Enable error reporting for: Correctable Errors, Non-Fatal Errors, Fatal Errors, Unsupported Requests
-    pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, 0, PCI_EXP_DEVCTL_CERE | PCI_EXP_DEVCTL_NFERE | PCI_EXP_DEVCTL_FERE | PCI_EXP_DEVCTL_URRE);
-
-    err = dma_set_mask(PCARD_TO_DEV(pcard), DMA_BIT_MASK(64));
-    if (err){
-        dev_err(&pcard->pdev->dev, "CANNOT use DMA mask %0llx\n", DMA_BIT_MASK(64));
-        goto out7;
-    }
-    dev_dbg(&pcard->pdev->dev, "Using DMA mask %0llx\n", dma_get_mask(PCARD_TO_DEV(pcard)));
-    //}
-
-    //{ Step 8: Configure IRQs
-    err = pci_enable_msi(pcard->pdev);
-    if (err < 0)
-        goto out8a;
-
-    rv = request_irq(pcard->pdev->irq, kp2000_irq_handler, IRQF_SHARED, pcard->name, pcard);
-    if (rv){
-        dev_err(&pcard->pdev->dev, "kp2000_pcie_probe: failed to request_irq: %d\n", rv);
-        goto out8b;
-    }
-    //}
-
-    //{ Step 9: Setup sysfs attributes
-    err = sysfs_create_files(&(pdev->dev.kobj), kp_attr_list);
-    if (err){
-        dev_err(&pdev->dev, "Failed to add sysfs files: %d\n", err);
-        goto out9;
-    }
-    //}
-
-    //{ Step 10: Setup misc device
-    pcard->miscdev.minor = MISC_DYNAMIC_MINOR;
-    pcard->miscdev.fops = &kp2000_fops;
-    pcard->miscdev.parent = &pcard->pdev->dev;
-    pcard->miscdev.name = pcard->name;
-
-    err = misc_register(&pcard->miscdev);
-    if (err){
-        dev_err(&pcard->pdev->dev, "kp2000_pcie_probe: misc_register failed: %d\n", err);
-        goto out10;
-    }
-    //}
-
-    //{ Step 11: Probe cores
-    err = kp2000_probe_cores(pcard);
-    if (err)
-        goto out11;
-    //}
-
-    //{ Step 12: Enable IRQs in HW
+	pcard->pdev = pdev;
+	pci_set_drvdata(pdev, pcard);
+
+	/*
+	 * Step 3: Enable PCI device
+	 */
+	err = pci_enable_device(pcard->pdev);
+	if (err) {
+		dev_err(&pcard->pdev->dev,
+			"probe: failed to enable PCIE2000 PCIe device (%d)\n",
+			err);
+		goto out3;
+	}
+
+	/*
+	 * Step 4: Setup the Register BAR
+	 */
+	reg_bar_phys_addr = pci_resource_start(pcard->pdev, REG_BAR);
+	reg_bar_phys_len = pci_resource_len(pcard->pdev, REG_BAR);
+
+	pcard->regs_bar_base = ioremap_nocache(reg_bar_phys_addr, PAGE_SIZE);
+	if (NULL == pcard->regs_bar_base) {
+		dev_err(&pcard->pdev->dev,
+			"probe: REG_BAR could not remap memory to virtual space\n");
+		err = -ENODEV;
+		goto out4;
+	}
+	dev_dbg(&pcard->pdev->dev,
+		"probe: REG_BAR virt hardware address start [%p]\n",
+		pcard->regs_bar_base);
+
+	err = pci_request_region(pcard->pdev, REG_BAR, KP_DRIVER_NAME_KP2000);
+	if (err) {
+		iounmap(pcard->regs_bar_base);
+		dev_err(&pcard->pdev->dev,
+			"probe: failed to acquire PCI region (%d)\n",
+			err);
+		err = -ENODEV;
+		goto out4;
+	}
+
+	pcard->regs_base_resource.start = reg_bar_phys_addr;
+	pcard->regs_base_resource.end   = reg_bar_phys_addr +
+					  reg_bar_phys_len - 1;
+	pcard->regs_base_resource.flags = IORESOURCE_MEM;
+
+	/*
+	 * Step 5: Setup the DMA BAR
+	 */
+	dma_bar_phys_addr = pci_resource_start(pcard->pdev, DMA_BAR);
+	dma_bar_phys_len = pci_resource_len(pcard->pdev, DMA_BAR);
+
+	pcard->dma_bar_base = ioremap_nocache(dma_bar_phys_addr,
+					      dma_bar_phys_len);
+	if (NULL == pcard->dma_bar_base) {
+		dev_err(&pcard->pdev->dev,
+			"probe: DMA_BAR could not remap memory to virtual space\n");
+		err = -ENODEV;
+		goto out5;
+	}
+	dev_dbg(&pcard->pdev->dev,
+		"probe: DMA_BAR virt hardware address start [%p]\n",
+		pcard->dma_bar_base);
+
+	pcard->dma_common_regs = pcard->dma_bar_base + KPC_DMA_COMMON_OFFSET;
+
+	err = pci_request_region(pcard->pdev, DMA_BAR, "kp2000_pcie");
+	if (err) {
+		iounmap(pcard->dma_bar_base);
+		dev_err(&pcard->pdev->dev,
+			"probe: failed to acquire PCI region (%d)\n", err);
+		err = -ENODEV;
+		goto out5;
+	}
+
+	pcard->dma_base_resource.start = dma_bar_phys_addr;
+	pcard->dma_base_resource.end   = dma_bar_phys_addr +
+					 dma_bar_phys_len - 1;
+	pcard->dma_base_resource.flags = IORESOURCE_MEM;
+
+	/*
+	 * Step 6: System Regs
+	 */
+	pcard->sysinfo_regs_base = pcard->regs_bar_base;
+	err = read_system_regs(pcard);
+	if (err)
+		goto out6;
+
+	// Disable all "user" interrupts because they're not used yet.
+	writeq(0xFFFFFFFFFFFFFFFF,
+	       pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
+
+	/*
+	 * Step 7: Configure PCI thingies
+	 */
+	// let the card master PCIe
+	pci_set_master(pcard->pdev);
+	// enable IO and mem if not already done
+	pci_read_config_word(pcard->pdev, PCI_COMMAND, &regval);
+	regval |= (PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
+	pci_write_config_word(pcard->pdev, PCI_COMMAND, regval);
+
+	// Clear relaxed ordering bit
+	pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL,
+					   PCI_EXP_DEVCTL_RELAX_EN, 0);
+
+	// Set Max_Payload_Size and Max_Read_Request_Size
+	regval = (0x0) << 5; // Max_Payload_Size = 128 B
+	pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL,
+					   PCI_EXP_DEVCTL_PAYLOAD, regval);
+	regval = (0x0) << 12; // Max_Read_Request_Size = 128 B
+	pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL,
+					   PCI_EXP_DEVCTL_READRQ, regval);
+
+	// Enable error reporting for: Correctable Errors, Non-Fatal Errors,
+	// Fatal Errors, Unsupported Requests
+	pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, 0,
+					   PCI_EXP_DEVCTL_CERE |
+					   PCI_EXP_DEVCTL_NFERE |
+					   PCI_EXP_DEVCTL_FERE |
+					   PCI_EXP_DEVCTL_URRE);
+
+	err = dma_set_mask(PCARD_TO_DEV(pcard), DMA_BIT_MASK(64));
+	if (err) {
+		dev_err(&pcard->pdev->dev,
+			"CANNOT use DMA mask %0llx\n", DMA_BIT_MASK(64));
+		goto out7;
+	}
+	dev_dbg(&pcard->pdev->dev,
+		"Using DMA mask %0llx\n", dma_get_mask(PCARD_TO_DEV(pcard)));
+
+	/*
+	 * Step 8: Configure IRQs
+	 */
+	err = pci_enable_msi(pcard->pdev);
+	if (err < 0)
+		goto out8a;
+
+	rv = request_irq(pcard->pdev->irq, kp2000_irq_handler, IRQF_SHARED,
+			 pcard->name, pcard);
+	if (rv) {
+		dev_err(&pcard->pdev->dev,
+			"kp2000_pcie_probe: failed to request_irq: %d\n", rv);
+		goto out8b;
+	}
+
+	/*
+	 * Step 9: Setup sysfs attributes
+	 */
+	err = sysfs_create_files(&(pdev->dev.kobj), kp_attr_list);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to add sysfs files: %d\n", err);
+		goto out9;
+	}
+
+	/*
+	 * Step 10: Setup misc device
+	 */
+	pcard->miscdev.minor = MISC_DYNAMIC_MINOR;
+	pcard->miscdev.fops = &kp2000_fops;
+	pcard->miscdev.parent = &pcard->pdev->dev;
+	pcard->miscdev.name = pcard->name;
+
+	err = misc_register(&pcard->miscdev);
+	if (err) {
+		dev_err(&pcard->pdev->dev,
+			"kp2000_pcie_probe: misc_register failed: %d\n", err);
+		goto out10;
+	}
+
+	/*
+	 * Step 11: Probe cores
+	 */
+	err = kp2000_probe_cores(pcard);
+	if (err)
+		goto out11;
+
+	/*
+	 * Step 12: Enable IRQs in HW
+	 */
 	writel(KPC_DMA_CARD_IRQ_ENABLE | KPC_DMA_CARD_USER_INTERRUPT_MODE,
 	       pcard->dma_common_regs);
-    //}
 
-    dev_dbg(&pcard->pdev->dev, "kp2000_pcie_probe() complete!\n");
+	dev_dbg(&pcard->pdev->dev, "kp2000_pcie_probe() complete!\n");
 	mutex_unlock(&pcard->sem);
-    return 0;
-
-  out11:
-    misc_deregister(&pcard->miscdev);
-  out10:
-    sysfs_remove_files(&(pdev->dev.kobj), kp_attr_list);
-  out9:
-    free_irq(pcard->pdev->irq, pcard);
-  out8b:
-    pci_disable_msi(pcard->pdev);
-  out8a:
-  out7:
-  out6:
-    iounmap(pcard->dma_bar_base);
-    pci_release_region(pdev, DMA_BAR);
-    pcard->dma_bar_base = NULL;
-  out5:
-    iounmap(pcard->regs_bar_base);
-    pci_release_region(pdev, REG_BAR);
-    pcard->regs_bar_base = NULL;
-  out4:
-    pci_disable_device(pcard->pdev);
-  out3:
+	return 0;
+
+out11:
+	misc_deregister(&pcard->miscdev);
+out10:
+	sysfs_remove_files(&(pdev->dev.kobj), kp_attr_list);
+out9:
+	free_irq(pcard->pdev->irq, pcard);
+out8b:
+	pci_disable_msi(pcard->pdev);
+out8a:
+out7:
+out6:
+	iounmap(pcard->dma_bar_base);
+	pci_release_region(pdev, DMA_BAR);
+	pcard->dma_bar_base = NULL;
+out5:
+	iounmap(pcard->regs_bar_base);
+	pci_release_region(pdev, REG_BAR);
+	pcard->regs_bar_base = NULL;
+out4:
+	pci_disable_device(pcard->pdev);
+out3:
 	mutex_unlock(&pcard->sem);
-    kfree(pcard);
-    return err;
+	kfree(pcard);
+	return err;
 }
 
-
 static void kp2000_pcie_remove(struct pci_dev *pdev)
 {
-    struct kp2000_device *pcard = pci_get_drvdata(pdev);
+	struct kp2000_device *pcard = pci_get_drvdata(pdev);
 
-    dev_dbg(&pdev->dev, "kp2000_pcie_remove(pdev=%p)\n", pdev);
+	dev_dbg(&pdev->dev, "kp2000_pcie_remove(pdev=%p)\n", pdev);
 
-    if (pcard == NULL)  return;
+	if (pcard == NULL)
+		return;
 
 	mutex_lock(&pcard->sem);
-    kp2000_remove_cores(pcard);
-    mfd_remove_devices(PCARD_TO_DEV(pcard));
-    misc_deregister(&pcard->miscdev);
-    sysfs_remove_files(&(pdev->dev.kobj), kp_attr_list);
-    free_irq(pcard->pdev->irq, pcard);
-    pci_disable_msi(pcard->pdev);
-    if (pcard->dma_bar_base != NULL){
-        iounmap(pcard->dma_bar_base);
-        pci_release_region(pdev, DMA_BAR);
-        pcard->dma_bar_base = NULL;
-    }
-    if (pcard->regs_bar_base != NULL){
-        iounmap(pcard->regs_bar_base);
-        pci_release_region(pdev, REG_BAR);
-        pcard->regs_bar_base = NULL;
-    }
-    pci_disable_device(pcard->pdev);
-    pci_set_drvdata(pdev, NULL);
+	kp2000_remove_cores(pcard);
+	mfd_remove_devices(PCARD_TO_DEV(pcard));
+	misc_deregister(&pcard->miscdev);
+	sysfs_remove_files(&(pdev->dev.kobj), kp_attr_list);
+	free_irq(pcard->pdev->irq, pcard);
+	pci_disable_msi(pcard->pdev);
+	if (pcard->dma_bar_base != NULL) {
+		iounmap(pcard->dma_bar_base);
+		pci_release_region(pdev, DMA_BAR);
+		pcard->dma_bar_base = NULL;
+	}
+	if (pcard->regs_bar_base != NULL) {
+		iounmap(pcard->regs_bar_base);
+		pci_release_region(pdev, REG_BAR);
+		pcard->regs_bar_base = NULL;
+	}
+	pci_disable_device(pcard->pdev);
+	pci_set_drvdata(pdev, NULL);
 	mutex_unlock(&pcard->sem);
-    kfree(pcard);
+	kfree(pcard);
 }
 
 struct class *kpc_uio_class;

commit 6bcd56b707d59029d9ecae40dc1bb3ba98a5c560
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 20 10:47:16 2019 +0200

    staging: kpc2000: remove SetBackEndControl() function
    
    As this is only called twice, just call writel() like a normal driver
    should :)
    
    At the same time, clean up the formatting for the irq handler, as there
    is no need to have that be incorrect, it just hurts the eyes...
    
    Cc: Matt Sickler <Matt.Sickler@daktronics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 0ab4cce73895..8e6db806f260 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -197,11 +197,15 @@ static int  read_system_regs(struct kp2000_device *pcard)
     return 0;
 }
 
-irqreturn_t  kp2000_irq_handler(int irq, void *dev_id)
+static irqreturn_t kp2000_irq_handler(int irq, void *dev_id)
 {
-    struct kp2000_device  *pcard = (struct kp2000_device*)dev_id;
-    SetBackEndControl(pcard->dma_common_regs, KPC_DMA_CARD_IRQ_ENABLE | KPC_DMA_CARD_USER_INTERRUPT_MODE | KPC_DMA_CARD_USER_INTERRUPT_ACTIVE);
-    return IRQ_HANDLED;
+	struct kp2000_device *pcard = dev_id;
+
+	writel(KPC_DMA_CARD_IRQ_ENABLE |
+	       KPC_DMA_CARD_USER_INTERRUPT_MODE |
+	       KPC_DMA_CARD_USER_INTERRUPT_ACTIVE,
+	       pcard->dma_common_regs);
+	return IRQ_HANDLED;
 }
 
 static int kp2000_cdev_open(struct inode *inode, struct file *filp)
@@ -484,7 +488,8 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
     //}
 
     //{ Step 12: Enable IRQs in HW
-    SetBackEndControl(pcard->dma_common_regs, KPC_DMA_CARD_IRQ_ENABLE | KPC_DMA_CARD_USER_INTERRUPT_MODE);
+	writel(KPC_DMA_CARD_IRQ_ENABLE | KPC_DMA_CARD_USER_INTERRUPT_MODE,
+	       pcard->dma_common_regs);
     //}
 
     dev_dbg(&pcard->pdev->dev, "kp2000_pcie_probe() complete!\n");

commit bdd4a571f862db4ae8af606d11dd1d0ce0094f57
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 20 10:47:10 2019 +0200

    staging: kpc2000: remove fileops.c file.
    
    The fileops.c file does not need to be stand-alone, so move it into the
    core.c file.  This lets us make some functions static, reducing the
    global namespace of the driver.
    
    Cc: Matt Sickler <Matt.Sickler@daktronics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index d8c44cc59ed7..0ab4cce73895 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -1,10 +1,16 @@
 // SPDX-License-Identifier: GPL-2.0+
+#include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/types.h>
 #include <linux/export.h>
 #include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/cdev.h>
+#include <linux/rwsem.h>
+#include <linux/uaccess.h>
 #include <asm/io.h>
 #include <linux/io.h>
 #include <linux/mfd/core.h>
@@ -17,7 +23,7 @@
 #include <linux/sched.h>
 #include <linux/jiffies.h>
 #include "pcie.h"
-
+#include "uapi.h"
 
 /*******************************************************
   * SysFS Attributes
@@ -198,6 +204,112 @@ irqreturn_t  kp2000_irq_handler(int irq, void *dev_id)
     return IRQ_HANDLED;
 }
 
+static int kp2000_cdev_open(struct inode *inode, struct file *filp)
+{
+	struct kp2000_device *pcard = container_of(filp->private_data, struct kp2000_device, miscdev);
+
+	dev_dbg(&pcard->pdev->dev, "kp2000_cdev_open(filp = [%p], pcard = [%p])\n", filp, pcard);
+
+	filp->private_data = pcard; /* so other methods can access it */
+
+	return 0;
+}
+
+static int kp2000_cdev_close(struct inode *inode, struct file *filp)
+{
+	struct kp2000_device *pcard = filp->private_data;
+
+	dev_dbg(&pcard->pdev->dev, "kp2000_cdev_close(filp = [%p], pcard = [%p])\n", filp, pcard);
+	return 0;
+}
+
+
+static ssize_t kp2000_cdev_read(struct file *filp, char __user *buf,
+				size_t count, loff_t *f_pos)
+{
+	struct kp2000_device *pcard = filp->private_data;
+	int cnt = 0;
+	int ret;
+#define BUFF_CNT  1024
+	char buff[BUFF_CNT] = {0}; //NOTE: Increase this so it is at least as large as all the scnprintfs.  And don't use unbounded strings. "%s"
+	//NOTE: also, this is a really shitty way to implement the read() call, but it will work for any size 'count'.
+
+	if (WARN(NULL == buf, "kp2000_cdev_read: buf is a NULL pointer!\n"))
+		return -EINVAL;
+
+	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Card ID                 : 0x%08x\n", pcard->card_id);
+	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Build Version           : 0x%08x\n", pcard->build_version);
+	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Build Date              : 0x%08x\n", pcard->build_datestamp);
+	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Build Time              : 0x%08x\n", pcard->build_timestamp);
+	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Core Table Offset       : 0x%08x\n", pcard->core_table_offset);
+	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Core Table Length       : 0x%08x\n", pcard->core_table_length);
+	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "Hardware Revision       : 0x%08x\n", pcard->hardware_revision);
+	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "SSID                    : 0x%016llx\n", pcard->ssid);
+	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "DDNA                    : 0x%016llx\n", pcard->ddna);
+	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "IRQ Mask                : 0x%016llx\n", readq(pcard->sysinfo_regs_base + REG_INTERRUPT_MASK));
+	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "IRQ Active              : 0x%016llx\n", readq(pcard->sysinfo_regs_base + REG_INTERRUPT_ACTIVE));
+	cnt += scnprintf(buff+cnt, BUFF_CNT-cnt, "CPLD                    : 0x%016llx\n", readq(pcard->sysinfo_regs_base + REG_CPLD_CONFIG));
+
+	if (*f_pos >= cnt)
+		return 0;
+
+	if (count > cnt)
+		count = cnt;
+
+	ret = copy_to_user(buf, buff + *f_pos, count);
+	if (ret)
+		return -EFAULT;
+	*f_pos += count;
+	return count;
+}
+
+static long kp2000_cdev_ioctl(struct file *filp, unsigned int ioctl_num,
+			      unsigned long ioctl_param)
+{
+	struct kp2000_device *pcard = filp->private_data;
+
+	dev_dbg(&pcard->pdev->dev, "kp2000_cdev_ioctl(filp = [%p], ioctl_num = 0x%08x, ioctl_param = 0x%016lx) pcard = [%p]\n", filp, ioctl_num, ioctl_param, pcard);
+
+	switch (ioctl_num){
+	case KP2000_IOCTL_GET_CPLD_REG:             return readq(pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
+	case KP2000_IOCTL_GET_PCIE_ERROR_REG:       return readq(pcard->sysinfo_regs_base + REG_PCIE_ERROR_COUNT);
+
+	case KP2000_IOCTL_GET_EVERYTHING: {
+		struct kp2000_regs temp;
+		int ret;
+
+		memset(&temp, 0, sizeof(temp));
+		temp.card_id = pcard->card_id;
+		temp.build_version = pcard->build_version;
+		temp.build_datestamp = pcard->build_datestamp;
+		temp.build_timestamp = pcard->build_timestamp;
+		temp.hw_rev = pcard->hardware_revision;
+		temp.ssid = pcard->ssid;
+		temp.ddna = pcard->ddna;
+		temp.cpld_reg = readq(pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
+
+		ret = copy_to_user((void*)ioctl_param, (void*)&temp, sizeof(temp));
+		if (ret)
+			return -EFAULT;
+
+		return sizeof(temp);
+		}
+
+	default:
+		return -ENOTTY;
+	}
+	return -ENOTTY;
+}
+
+static struct file_operations kp2000_fops = {
+	.owner =		THIS_MODULE,
+	.open =			kp2000_cdev_open,
+	.release =		kp2000_cdev_close,
+	.read =			kp2000_cdev_read,
+	.llseek =		noop_llseek,
+	.unlocked_ioctl =	kp2000_cdev_ioctl,
+};
+
 static int kp2000_pcie_probe(struct pci_dev *pdev,
 			     const struct pci_device_id *id)
 {

commit 276accf2daa03d2d78dccb7017bdbbfde1e0b679
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri May 17 10:49:39 2019 +0200

    staging: kpc2000: remove lock_card/unlock_card functions
    
    We do not need an inline function to "hide" the lock, so just replace
    the few calls to these functions with the "real" mutex_lock/unlock()
    calls.
    
    Cc: Matt Sickler <Matt.Sickler@daktronics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index e525dd130ce2..d8c44cc59ed7 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -228,7 +228,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
     scnprintf(pcard->name, 16, "kpcard%d", pcard->card_num);
 
     mutex_init(&pcard->sem);
-    lock_card(pcard);
+	mutex_lock(&pcard->sem);
 
     pcard->pdev = pdev;
     pci_set_drvdata(pdev, pcard);
@@ -376,7 +376,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
     //}
 
     dev_dbg(&pcard->pdev->dev, "kp2000_pcie_probe() complete!\n");
-    unlock_card(pcard);
+	mutex_unlock(&pcard->sem);
     return 0;
 
   out11:
@@ -400,7 +400,7 @@ static int kp2000_pcie_probe(struct pci_dev *pdev,
   out4:
     pci_disable_device(pcard->pdev);
   out3:
-    unlock_card(pcard);
+	mutex_unlock(&pcard->sem);
     kfree(pcard);
     return err;
 }
@@ -414,7 +414,7 @@ static void kp2000_pcie_remove(struct pci_dev *pdev)
 
     if (pcard == NULL)  return;
 
-    lock_card(pcard);
+	mutex_lock(&pcard->sem);
     kp2000_remove_cores(pcard);
     mfd_remove_devices(PCARD_TO_DEV(pcard));
     misc_deregister(&pcard->miscdev);
@@ -433,7 +433,7 @@ static void kp2000_pcie_remove(struct pci_dev *pdev)
     }
     pci_disable_device(pcard->pdev);
     pci_set_drvdata(pdev, NULL);
-    unlock_card(pcard);
+	mutex_unlock(&pcard->sem);
     kfree(pcard);
 }
 

commit 92642f385b7ea03117aff75e436a087a387fedb0
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri May 17 10:49:37 2019 +0200

    staging: kpc2000: remove kp200_module.c file
    
    The kp200_module.c does not need to be stand-alone, so move it into the
    core.c file.  This lets us make some functions static, reducing the
    global namespace of the driver.
    
    Cc: Matt Sickler <Matt.Sickler@daktronics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index eb8bac62d33d..e525dd130ce2 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -198,7 +198,8 @@ irqreturn_t  kp2000_irq_handler(int irq, void *dev_id)
     return IRQ_HANDLED;
 }
 
-int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+static int kp2000_pcie_probe(struct pci_dev *pdev,
+			     const struct pci_device_id *id)
 {
     int err = 0;
     struct kp2000_device *pcard;
@@ -405,7 +406,7 @@ int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 }
 
 
-void  kp2000_pcie_remove(struct pci_dev *pdev)
+static void kp2000_pcie_remove(struct pci_dev *pdev)
 {
     struct kp2000_device *pcard = pci_get_drvdata(pdev);
 
@@ -435,3 +436,42 @@ void  kp2000_pcie_remove(struct pci_dev *pdev)
     unlock_card(pcard);
     kfree(pcard);
 }
+
+struct class *kpc_uio_class;
+ATTRIBUTE_GROUPS(kpc_uio_class);
+
+static const struct pci_device_id kp2000_pci_device_ids[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_DAKTRONICS, PCI_DEVICE_ID_DAKTRONICS) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_DAKTRONICS, PCI_DEVICE_ID_DAKTRONICS_KADOKA_P2KR0) },
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, kp2000_pci_device_ids);
+
+static struct pci_driver kp2000_driver_inst = {
+	.name =		"kp2000_pcie",
+	.id_table =	kp2000_pci_device_ids,
+	.probe =	kp2000_pcie_probe,
+	.remove =	kp2000_pcie_remove,
+};
+
+static int __init  kp2000_pcie_init(void)
+{
+	kpc_uio_class = class_create(THIS_MODULE, "kpc_uio");
+	if (IS_ERR(kpc_uio_class))
+		return PTR_ERR(kpc_uio_class);
+
+	kpc_uio_class->dev_groups = kpc_uio_class_groups;
+	return pci_register_driver(&kp2000_driver_inst);
+}
+module_init(kp2000_pcie_init);
+
+static void __exit  kp2000_pcie_exit(void)
+{
+	pci_unregister_driver(&kp2000_driver_inst);
+	class_destroy(kpc_uio_class);
+}
+module_exit(kp2000_pcie_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Lee.Brooke@Daktronics.com, Matt.Sickler@Daktronics.com");
+MODULE_SOFTDEP("pre: uio post: kpc_nwl_dma kpc_i2c kpc_spi");

commit 2f9dcc46c626f32a484278c0fefae4ee49b5c1d5
Author: Jeremy Sowden <jeremy@azazel.net>
Date:   Thu May 16 22:38:06 2019 +0100

    staging: kpc2000: removed trailing white-space.
    
    Removed trailing white-space from four files.
    
    Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 40390cdd3c8d..eb8bac62d33d 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -30,7 +30,7 @@ static ssize_t  show_attr(struct device *dev, struct device_attribute *attr, cha
     if (!pdev)  return -ENXIO;
     pcard = pci_get_drvdata(pdev);
     if (!pcard)  return -ENXIO;
-    
+
     if (strcmp("ssid", attr->attr.name) == 0){         return scnprintf(buf, PAGE_SIZE, "%016llx\n", pcard->ssid);  } else
     if (strcmp("ddna", attr->attr.name) == 0){         return scnprintf(buf, PAGE_SIZE, "%016llx\n", pcard->ddna);  } else
     if (strcmp("card_id", attr->attr.name) == 0){      return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->card_id);  } else
@@ -67,11 +67,11 @@ static ssize_t cpld_reconfigure(struct device *dev, struct device_attribute *att
     if (!pdev)  return -ENXIO;
     pcard = pci_get_drvdata(pdev);
     if (!pcard)  return -ENXIO;
-    
+
     rv = kstrtol(buf, 0, &wr_val);
     if (rv < 0)  return rv;
     if (wr_val > 7)  return -EINVAL;
-    
+
     wr_val = wr_val << 8;
     wr_val |= 0x1; // Set the "Configure Go" bit
     writeq(wr_val, pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
@@ -111,12 +111,12 @@ static void wait_and_read_ssid(struct kp2000_device *pcard)
 {
     u64 read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_SSID);
     unsigned long timeout;
-    
+
     if (read_val & 0x8000000000000000){
         pcard->ssid = read_val;
         return;
     }
-    
+
     timeout = jiffies + (HZ * 2);
     do {
         read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_SSID);
@@ -127,9 +127,9 @@ static void wait_and_read_ssid(struct kp2000_device *pcard)
         cpu_relax();
         //schedule();
     } while (time_before(jiffies, timeout));
-    
+
     dev_notice(&pcard->pdev->dev, "SSID didn't show up!\n");
-    
+
     #if 0
     // Timed out waiting for the SSID to show up, just use the DDNA instead?
     read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_DDNA);
@@ -143,34 +143,34 @@ static void wait_and_read_ssid(struct kp2000_device *pcard)
 static int  read_system_regs(struct kp2000_device *pcard)
 {
     u64 read_val;
-    
+
     read_val = readq(pcard->sysinfo_regs_base + REG_MAGIC_NUMBER);
     if (read_val != KP2000_MAGIC_VALUE){
         dev_err(&pcard->pdev->dev, "Invalid magic!  Got: 0x%016llx  Want: 0x%016lx\n", read_val, KP2000_MAGIC_VALUE);
         return -EILSEQ;
     }
-    
+
     read_val = readq(pcard->sysinfo_regs_base + REG_CARD_ID_AND_BUILD);
     pcard->card_id = (read_val & 0xFFFFFFFF00000000) >> 32;
     pcard->build_version = (read_val & 0x00000000FFFFFFFF) >> 0;
-    
+
     read_val = readq(pcard->sysinfo_regs_base + REG_DATE_AND_TIME_STAMPS);
     pcard->build_datestamp = (read_val & 0xFFFFFFFF00000000) >> 32;
     pcard->build_timestamp = (read_val & 0x00000000FFFFFFFF) >> 0;
-    
+
     read_val = readq(pcard->sysinfo_regs_base + REG_CORE_TABLE_OFFSET);
     pcard->core_table_length = (read_val & 0xFFFFFFFF00000000) >> 32;
     pcard->core_table_offset = (read_val & 0x00000000FFFFFFFF) >> 0;
-    
+
     wait_and_read_ssid(pcard);
-    
+
     read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_HW_ID);
     pcard->core_table_rev    = (read_val & 0x0000000000000F00) >> 8;
     pcard->hardware_revision = (read_val & 0x000000000000001F);
-    
+
     read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_DDNA);
     pcard->ddna = read_val;
-    
+
     dev_info(&pcard->pdev->dev, "system_regs: %08x %08x %08x %08x  %02x  %d %d  %016llx  %016llx\n",
         pcard->card_id,
         pcard->build_version,
@@ -182,12 +182,12 @@ static int  read_system_regs(struct kp2000_device *pcard)
         pcard->ssid,
         pcard->ddna
     );
-    
+
     if (pcard->core_table_rev > 1){
         dev_err(&pcard->pdev->dev, "core table entry revision is higher than we can deal with, cannot continue with this card!\n");
         return 1;
     }
-    
+
     return 0;
 }
 
@@ -209,9 +209,9 @@ int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
     unsigned long dma_bar_phys_addr;
     unsigned long dma_bar_phys_len;
     u16 regval;
- 
+
     dev_dbg(&pdev->dev, "kp2000_pcie_probe(pdev = [%p], id = [%p])\n", pdev, id);
-    
+
     //{ Step 1: Allocate a struct for the pcard
     pcard = kzalloc(sizeof(struct kp2000_device), GFP_KERNEL);
     if (NULL == pcard){
@@ -220,19 +220,19 @@ int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
     }
     dev_dbg(&pdev->dev, "probe: allocated struct kp2000_device @ %p\n", pcard);
     //}
-    
+
     //{ Step 2: Initialize trivial pcard elements
     pcard->card_num = card_count;
     card_count++;
     scnprintf(pcard->name, 16, "kpcard%d", pcard->card_num);
-    
+
     mutex_init(&pcard->sem);
     lock_card(pcard);
-    
+
     pcard->pdev = pdev;
     pci_set_drvdata(pdev, pcard);
     //}
-    
+
     //{ Step 3: Enable PCI device
     err = pci_enable_device(pcard->pdev);
     if (err){
@@ -240,11 +240,11 @@ int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
         goto out3;
     }
     //}
-    
+
     //{ Step 4: Setup the Register BAR
     reg_bar_phys_addr = pci_resource_start(pcard->pdev, REG_BAR);
     reg_bar_phys_len = pci_resource_len(pcard->pdev, REG_BAR);
-    
+
     pcard->regs_bar_base = ioremap_nocache(reg_bar_phys_addr, PAGE_SIZE);
     if (NULL == pcard->regs_bar_base){
         dev_err(&pcard->pdev->dev, "probe: REG_BAR could not remap memory to virtual space\n");
@@ -252,7 +252,7 @@ int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
         goto out4;
     }
     dev_dbg(&pcard->pdev->dev, "probe: REG_BAR virt hardware address start [%p]\n", pcard->regs_bar_base);
-    
+
     err = pci_request_region(pcard->pdev, REG_BAR, KP_DRIVER_NAME_KP2000);
     if (err){
         iounmap(pcard->regs_bar_base);
@@ -260,16 +260,16 @@ int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
         err = -ENODEV;
         goto out4;
     }
-    
+
     pcard->regs_base_resource.start = reg_bar_phys_addr;
     pcard->regs_base_resource.end   = reg_bar_phys_addr + reg_bar_phys_len - 1;
     pcard->regs_base_resource.flags = IORESOURCE_MEM;
     //}
-    
+
     //{ Step 5: Setup the DMA BAR
     dma_bar_phys_addr = pci_resource_start(pcard->pdev, DMA_BAR);
     dma_bar_phys_len = pci_resource_len(pcard->pdev, DMA_BAR);
-    
+
     pcard->dma_bar_base = ioremap_nocache(dma_bar_phys_addr, dma_bar_phys_len);
     if (NULL == pcard->dma_bar_base){
         dev_err(&pcard->pdev->dev, "probe: DMA_BAR could not remap memory to virtual space\n");
@@ -277,9 +277,9 @@ int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
         goto out5;
     }
     dev_dbg(&pcard->pdev->dev, "probe: DMA_BAR virt hardware address start [%p]\n", pcard->dma_bar_base);
-    
+
     pcard->dma_common_regs = pcard->dma_bar_base + KPC_DMA_COMMON_OFFSET;
-    
+
     err = pci_request_region(pcard->pdev, DMA_BAR, "kp2000_pcie");
     if (err){
         iounmap(pcard->dma_bar_base);
@@ -287,22 +287,22 @@ int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
         err = -ENODEV;
         goto out5;
     }
-    
+
     pcard->dma_base_resource.start = dma_bar_phys_addr;
     pcard->dma_base_resource.end   = dma_bar_phys_addr + dma_bar_phys_len - 1;
     pcard->dma_base_resource.flags = IORESOURCE_MEM;
     //}
-    
+
     //{ Step 6: System Regs
     pcard->sysinfo_regs_base = pcard->regs_bar_base;
     err = read_system_regs(pcard);
     if (err)
         goto out6;
-    
+
     // Disable all "user" interrupts because they're not used yet.
     writeq(0xFFFFFFFFFFFFFFFF, pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
     //}
-    
+
     //{ Step 7: Configure PCI thingies
     // let the card master PCIe
     pci_set_master(pcard->pdev);
@@ -310,19 +310,19 @@ int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
     pci_read_config_word(pcard->pdev, PCI_COMMAND, &regval);
     regval |= (PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
     pci_write_config_word(pcard->pdev, PCI_COMMAND, regval);
-    
+
     // Clear relaxed ordering bit
     pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_RELAX_EN, 0);
-    
+
     // Set Max_Payload_Size and Max_Read_Request_Size
     regval = (0x0) << 5; // Max_Payload_Size = 128 B
     pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_PAYLOAD, regval);
     regval = (0x0) << 12; // Max_Read_Request_Size = 128 B
     pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_READRQ, regval);
-    
+
     // Enable error reporting for: Correctable Errors, Non-Fatal Errors, Fatal Errors, Unsupported Requests
     pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, 0, PCI_EXP_DEVCTL_CERE | PCI_EXP_DEVCTL_NFERE | PCI_EXP_DEVCTL_FERE | PCI_EXP_DEVCTL_URRE);
-    
+
     err = dma_set_mask(PCARD_TO_DEV(pcard), DMA_BIT_MASK(64));
     if (err){
         dev_err(&pcard->pdev->dev, "CANNOT use DMA mask %0llx\n", DMA_BIT_MASK(64));
@@ -330,19 +330,19 @@ int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
     }
     dev_dbg(&pcard->pdev->dev, "Using DMA mask %0llx\n", dma_get_mask(PCARD_TO_DEV(pcard)));
     //}
-    
+
     //{ Step 8: Configure IRQs
     err = pci_enable_msi(pcard->pdev);
     if (err < 0)
         goto out8a;
-    
+
     rv = request_irq(pcard->pdev->irq, kp2000_irq_handler, IRQF_SHARED, pcard->name, pcard);
     if (rv){
         dev_err(&pcard->pdev->dev, "kp2000_pcie_probe: failed to request_irq: %d\n", rv);
         goto out8b;
     }
     //}
-    
+
     //{ Step 9: Setup sysfs attributes
     err = sysfs_create_files(&(pdev->dev.kobj), kp_attr_list);
     if (err){
@@ -350,30 +350,30 @@ int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
         goto out9;
     }
     //}
-    
+
     //{ Step 10: Setup misc device
     pcard->miscdev.minor = MISC_DYNAMIC_MINOR;
     pcard->miscdev.fops = &kp2000_fops;
     pcard->miscdev.parent = &pcard->pdev->dev;
     pcard->miscdev.name = pcard->name;
-    
+
     err = misc_register(&pcard->miscdev);
     if (err){
         dev_err(&pcard->pdev->dev, "kp2000_pcie_probe: misc_register failed: %d\n", err);
         goto out10;
     }
     //}
-    
+
     //{ Step 11: Probe cores
     err = kp2000_probe_cores(pcard);
     if (err)
         goto out11;
     //}
-    
+
     //{ Step 12: Enable IRQs in HW
     SetBackEndControl(pcard->dma_common_regs, KPC_DMA_CARD_IRQ_ENABLE | KPC_DMA_CARD_USER_INTERRUPT_MODE);
     //}
-    
+
     dev_dbg(&pcard->pdev->dev, "kp2000_pcie_probe() complete!\n");
     unlock_card(pcard);
     return 0;
@@ -410,9 +410,9 @@ void  kp2000_pcie_remove(struct pci_dev *pdev)
     struct kp2000_device *pcard = pci_get_drvdata(pdev);
 
     dev_dbg(&pdev->dev, "kp2000_pcie_remove(pdev=%p)\n", pdev);
-    
+
     if (pcard == NULL)  return;
-    
+
     lock_card(pcard);
     kp2000_remove_cores(pcard);
     mfd_remove_devices(PCARD_TO_DEV(pcard));

commit 91b6cb7216cd8bad027bc9ef88e2834786c8eeaf
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed May 1 10:48:43 2019 +0200

    staging: kpc2000: fix up build problems with readq()
    
    The 0-day system found a bunch of warnings for when readq() is not
    defined on the platform, so fix this by including the
    linux/io-64-nonatomic-lo-hi.h file which will fix up these issues.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
index 35b87cdc4fb0..40390cdd3c8d 100644
--- a/drivers/staging/kpc2000/kpc2000/core.c
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -10,6 +10,7 @@
 #include <linux/mfd/core.h>
 #include <linux/platform_device.h>
 #include <linux/ioport.h>
+#include <linux/io-64-nonatomic-lo-hi.h>
 #include <linux/interrupt.h>
 #include <linux/workqueue.h>
 #include <linux/device.h>

commit 7dc7967fc39af81191558f63eeaf3d2b83899b1c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Apr 19 20:42:05 2019 +0200

    staging: kpc2000: add initial set of Daktronics drivers
    
    These drivers have been outside of the kernel tree since the 2.x days,
    and it's time to bring them into the tree so they can get properly
    cleaned up.
    
    This first dump of drivers is based on a tarball Matt gave to me, minus
    an odd "dma" driver that I could not get to build at all.  I renamed a
    few files, added the proper SPDX lines to it, added Kconfig entries and
    tied it into the kernel build.  I also fixed up a number of initial
    obvious kernel build warnings, but left the odd bitfield warning that
    gcc is spitting out, as I'm not quite sure what to do about that.
    
    There's loads of low-hanging coding style cleanups in here for people to
    start attacking, as well as the more obvious logic and api cleanups as
    well.
    
    Cc: Matt Sickler <Matt.Sickler@daktronics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/kpc2000/kpc2000/core.c b/drivers/staging/kpc2000/kpc2000/core.c
new file mode 100644
index 000000000000..35b87cdc4fb0
--- /dev/null
+++ b/drivers/staging/kpc2000/kpc2000/core.c
@@ -0,0 +1,436 @@
+// SPDX-License-Identifier: GPL-2.0+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+#include <linux/export.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/mfd/core.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/jiffies.h>
+#include "pcie.h"
+
+
+/*******************************************************
+  * SysFS Attributes
+  ******************************************************/
+static ssize_t  show_attr(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct pci_dev *pdev = to_pci_dev(dev);
+    struct kp2000_device *pcard;
+
+    if (!pdev)  return -ENXIO;
+    pcard = pci_get_drvdata(pdev);
+    if (!pcard)  return -ENXIO;
+    
+    if (strcmp("ssid", attr->attr.name) == 0){         return scnprintf(buf, PAGE_SIZE, "%016llx\n", pcard->ssid);  } else
+    if (strcmp("ddna", attr->attr.name) == 0){         return scnprintf(buf, PAGE_SIZE, "%016llx\n", pcard->ddna);  } else
+    if (strcmp("card_id", attr->attr.name) == 0){      return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->card_id);  } else
+    if (strcmp("hw_rev", attr->attr.name) == 0){       return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->hardware_revision);  } else
+    if (strcmp("build", attr->attr.name) == 0){        return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->build_version);  } else
+    if (strcmp("build_date", attr->attr.name) == 0){   return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->build_datestamp);  } else
+    if (strcmp("build_time", attr->attr.name) == 0){   return scnprintf(buf, PAGE_SIZE, "%08x\n", pcard->build_timestamp);  } else
+    { return -ENXIO; }
+}
+
+static ssize_t  show_cpld_config_reg(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct kp2000_device *pcard;
+	u64 val;
+
+	if (!pdev)
+		return -ENXIO;
+
+	pcard = pci_get_drvdata(pdev);
+	if (!pcard)
+		return -ENXIO;
+
+	val = readq(pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
+	return scnprintf(buf, PAGE_SIZE, "%016llx\n", val);
+}
+static ssize_t cpld_reconfigure(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct pci_dev *pdev = to_pci_dev(dev);
+    long wr_val;
+    struct kp2000_device *pcard;
+    int rv;
+
+    if (!pdev)  return -ENXIO;
+    pcard = pci_get_drvdata(pdev);
+    if (!pcard)  return -ENXIO;
+    
+    rv = kstrtol(buf, 0, &wr_val);
+    if (rv < 0)  return rv;
+    if (wr_val > 7)  return -EINVAL;
+    
+    wr_val = wr_val << 8;
+    wr_val |= 0x1; // Set the "Configure Go" bit
+    writeq(wr_val, pcard->sysinfo_regs_base + REG_CPLD_CONFIG);
+    return count;
+}
+
+
+DEVICE_ATTR(ssid,       0444, show_attr, NULL);
+DEVICE_ATTR(ddna,       0444, show_attr, NULL);
+DEVICE_ATTR(card_id,    0444, show_attr, NULL);
+DEVICE_ATTR(hw_rev,     0444, show_attr, NULL);
+DEVICE_ATTR(build,      0444, show_attr, NULL);
+DEVICE_ATTR(build_date, 0444, show_attr, NULL);
+DEVICE_ATTR(build_time, 0444, show_attr, NULL);
+DEVICE_ATTR(cpld_reg,   0444, show_cpld_config_reg, NULL);
+DEVICE_ATTR(cpld_reconfigure,   0220, NULL, cpld_reconfigure);
+
+static const struct attribute *  kp_attr_list[] = {
+    &dev_attr_ssid.attr,
+    &dev_attr_ddna.attr,
+    &dev_attr_card_id.attr,
+    &dev_attr_hw_rev.attr,
+    &dev_attr_build.attr,
+    &dev_attr_build_date.attr,
+    &dev_attr_build_time.attr,
+    &dev_attr_cpld_reg.attr,
+    &dev_attr_cpld_reconfigure.attr,
+    NULL,
+};
+
+
+/*******************************************************
+  * Functions
+  ******************************************************/
+
+static void wait_and_read_ssid(struct kp2000_device *pcard)
+{
+    u64 read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_SSID);
+    unsigned long timeout;
+    
+    if (read_val & 0x8000000000000000){
+        pcard->ssid = read_val;
+        return;
+    }
+    
+    timeout = jiffies + (HZ * 2);
+    do {
+        read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_SSID);
+        if (read_val & 0x8000000000000000){
+            pcard->ssid = read_val;
+            return;
+        }
+        cpu_relax();
+        //schedule();
+    } while (time_before(jiffies, timeout));
+    
+    dev_notice(&pcard->pdev->dev, "SSID didn't show up!\n");
+    
+    #if 0
+    // Timed out waiting for the SSID to show up, just use the DDNA instead?
+    read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_DDNA);
+    pcard->ssid = read_val;
+    #else
+    // Timed out waiting for the SSID to show up, stick all zeros in the value
+    pcard->ssid = 0;
+    #endif
+}
+
+static int  read_system_regs(struct kp2000_device *pcard)
+{
+    u64 read_val;
+    
+    read_val = readq(pcard->sysinfo_regs_base + REG_MAGIC_NUMBER);
+    if (read_val != KP2000_MAGIC_VALUE){
+        dev_err(&pcard->pdev->dev, "Invalid magic!  Got: 0x%016llx  Want: 0x%016lx\n", read_val, KP2000_MAGIC_VALUE);
+        return -EILSEQ;
+    }
+    
+    read_val = readq(pcard->sysinfo_regs_base + REG_CARD_ID_AND_BUILD);
+    pcard->card_id = (read_val & 0xFFFFFFFF00000000) >> 32;
+    pcard->build_version = (read_val & 0x00000000FFFFFFFF) >> 0;
+    
+    read_val = readq(pcard->sysinfo_regs_base + REG_DATE_AND_TIME_STAMPS);
+    pcard->build_datestamp = (read_val & 0xFFFFFFFF00000000) >> 32;
+    pcard->build_timestamp = (read_val & 0x00000000FFFFFFFF) >> 0;
+    
+    read_val = readq(pcard->sysinfo_regs_base + REG_CORE_TABLE_OFFSET);
+    pcard->core_table_length = (read_val & 0xFFFFFFFF00000000) >> 32;
+    pcard->core_table_offset = (read_val & 0x00000000FFFFFFFF) >> 0;
+    
+    wait_and_read_ssid(pcard);
+    
+    read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_HW_ID);
+    pcard->core_table_rev    = (read_val & 0x0000000000000F00) >> 8;
+    pcard->hardware_revision = (read_val & 0x000000000000001F);
+    
+    read_val = readq(pcard->sysinfo_regs_base + REG_FPGA_DDNA);
+    pcard->ddna = read_val;
+    
+    dev_info(&pcard->pdev->dev, "system_regs: %08x %08x %08x %08x  %02x  %d %d  %016llx  %016llx\n",
+        pcard->card_id,
+        pcard->build_version,
+        pcard->build_datestamp,
+        pcard->build_timestamp,
+        pcard->hardware_revision,
+        pcard->core_table_rev,
+        pcard->core_table_length,
+        pcard->ssid,
+        pcard->ddna
+    );
+    
+    if (pcard->core_table_rev > 1){
+        dev_err(&pcard->pdev->dev, "core table entry revision is higher than we can deal with, cannot continue with this card!\n");
+        return 1;
+    }
+    
+    return 0;
+}
+
+irqreturn_t  kp2000_irq_handler(int irq, void *dev_id)
+{
+    struct kp2000_device  *pcard = (struct kp2000_device*)dev_id;
+    SetBackEndControl(pcard->dma_common_regs, KPC_DMA_CARD_IRQ_ENABLE | KPC_DMA_CARD_USER_INTERRUPT_MODE | KPC_DMA_CARD_USER_INTERRUPT_ACTIVE);
+    return IRQ_HANDLED;
+}
+
+int  kp2000_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+    int err = 0;
+    struct kp2000_device *pcard;
+    static int card_count = 1;
+    int rv;
+    unsigned long reg_bar_phys_addr;
+    unsigned long reg_bar_phys_len;
+    unsigned long dma_bar_phys_addr;
+    unsigned long dma_bar_phys_len;
+    u16 regval;
+ 
+    dev_dbg(&pdev->dev, "kp2000_pcie_probe(pdev = [%p], id = [%p])\n", pdev, id);
+    
+    //{ Step 1: Allocate a struct for the pcard
+    pcard = kzalloc(sizeof(struct kp2000_device), GFP_KERNEL);
+    if (NULL == pcard){
+        dev_err(&pdev->dev, "probe: failed to allocate private card data\n");
+        return -ENOMEM;
+    }
+    dev_dbg(&pdev->dev, "probe: allocated struct kp2000_device @ %p\n", pcard);
+    //}
+    
+    //{ Step 2: Initialize trivial pcard elements
+    pcard->card_num = card_count;
+    card_count++;
+    scnprintf(pcard->name, 16, "kpcard%d", pcard->card_num);
+    
+    mutex_init(&pcard->sem);
+    lock_card(pcard);
+    
+    pcard->pdev = pdev;
+    pci_set_drvdata(pdev, pcard);
+    //}
+    
+    //{ Step 3: Enable PCI device
+    err = pci_enable_device(pcard->pdev);
+    if (err){
+        dev_err(&pcard->pdev->dev, "probe: failed to enable PCIE2000 PCIe device (%d)\n", err);
+        goto out3;
+    }
+    //}
+    
+    //{ Step 4: Setup the Register BAR
+    reg_bar_phys_addr = pci_resource_start(pcard->pdev, REG_BAR);
+    reg_bar_phys_len = pci_resource_len(pcard->pdev, REG_BAR);
+    
+    pcard->regs_bar_base = ioremap_nocache(reg_bar_phys_addr, PAGE_SIZE);
+    if (NULL == pcard->regs_bar_base){
+        dev_err(&pcard->pdev->dev, "probe: REG_BAR could not remap memory to virtual space\n");
+        err = -ENODEV;
+        goto out4;
+    }
+    dev_dbg(&pcard->pdev->dev, "probe: REG_BAR virt hardware address start [%p]\n", pcard->regs_bar_base);
+    
+    err = pci_request_region(pcard->pdev, REG_BAR, KP_DRIVER_NAME_KP2000);
+    if (err){
+        iounmap(pcard->regs_bar_base);
+        dev_err(&pcard->pdev->dev, "probe: failed to acquire PCI region (%d)\n", err);
+        err = -ENODEV;
+        goto out4;
+    }
+    
+    pcard->regs_base_resource.start = reg_bar_phys_addr;
+    pcard->regs_base_resource.end   = reg_bar_phys_addr + reg_bar_phys_len - 1;
+    pcard->regs_base_resource.flags = IORESOURCE_MEM;
+    //}
+    
+    //{ Step 5: Setup the DMA BAR
+    dma_bar_phys_addr = pci_resource_start(pcard->pdev, DMA_BAR);
+    dma_bar_phys_len = pci_resource_len(pcard->pdev, DMA_BAR);
+    
+    pcard->dma_bar_base = ioremap_nocache(dma_bar_phys_addr, dma_bar_phys_len);
+    if (NULL == pcard->dma_bar_base){
+        dev_err(&pcard->pdev->dev, "probe: DMA_BAR could not remap memory to virtual space\n");
+        err = -ENODEV;
+        goto out5;
+    }
+    dev_dbg(&pcard->pdev->dev, "probe: DMA_BAR virt hardware address start [%p]\n", pcard->dma_bar_base);
+    
+    pcard->dma_common_regs = pcard->dma_bar_base + KPC_DMA_COMMON_OFFSET;
+    
+    err = pci_request_region(pcard->pdev, DMA_BAR, "kp2000_pcie");
+    if (err){
+        iounmap(pcard->dma_bar_base);
+        dev_err(&pcard->pdev->dev, "probe: failed to acquire PCI region (%d)\n", err);
+        err = -ENODEV;
+        goto out5;
+    }
+    
+    pcard->dma_base_resource.start = dma_bar_phys_addr;
+    pcard->dma_base_resource.end   = dma_bar_phys_addr + dma_bar_phys_len - 1;
+    pcard->dma_base_resource.flags = IORESOURCE_MEM;
+    //}
+    
+    //{ Step 6: System Regs
+    pcard->sysinfo_regs_base = pcard->regs_bar_base;
+    err = read_system_regs(pcard);
+    if (err)
+        goto out6;
+    
+    // Disable all "user" interrupts because they're not used yet.
+    writeq(0xFFFFFFFFFFFFFFFF, pcard->sysinfo_regs_base + REG_INTERRUPT_MASK);
+    //}
+    
+    //{ Step 7: Configure PCI thingies
+    // let the card master PCIe
+    pci_set_master(pcard->pdev);
+    // enable IO and mem if not already done
+    pci_read_config_word(pcard->pdev, PCI_COMMAND, &regval);
+    regval |= (PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
+    pci_write_config_word(pcard->pdev, PCI_COMMAND, regval);
+    
+    // Clear relaxed ordering bit
+    pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_RELAX_EN, 0);
+    
+    // Set Max_Payload_Size and Max_Read_Request_Size
+    regval = (0x0) << 5; // Max_Payload_Size = 128 B
+    pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_PAYLOAD, regval);
+    regval = (0x0) << 12; // Max_Read_Request_Size = 128 B
+    pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_READRQ, regval);
+    
+    // Enable error reporting for: Correctable Errors, Non-Fatal Errors, Fatal Errors, Unsupported Requests
+    pcie_capability_clear_and_set_word(pcard->pdev, PCI_EXP_DEVCTL, 0, PCI_EXP_DEVCTL_CERE | PCI_EXP_DEVCTL_NFERE | PCI_EXP_DEVCTL_FERE | PCI_EXP_DEVCTL_URRE);
+    
+    err = dma_set_mask(PCARD_TO_DEV(pcard), DMA_BIT_MASK(64));
+    if (err){
+        dev_err(&pcard->pdev->dev, "CANNOT use DMA mask %0llx\n", DMA_BIT_MASK(64));
+        goto out7;
+    }
+    dev_dbg(&pcard->pdev->dev, "Using DMA mask %0llx\n", dma_get_mask(PCARD_TO_DEV(pcard)));
+    //}
+    
+    //{ Step 8: Configure IRQs
+    err = pci_enable_msi(pcard->pdev);
+    if (err < 0)
+        goto out8a;
+    
+    rv = request_irq(pcard->pdev->irq, kp2000_irq_handler, IRQF_SHARED, pcard->name, pcard);
+    if (rv){
+        dev_err(&pcard->pdev->dev, "kp2000_pcie_probe: failed to request_irq: %d\n", rv);
+        goto out8b;
+    }
+    //}
+    
+    //{ Step 9: Setup sysfs attributes
+    err = sysfs_create_files(&(pdev->dev.kobj), kp_attr_list);
+    if (err){
+        dev_err(&pdev->dev, "Failed to add sysfs files: %d\n", err);
+        goto out9;
+    }
+    //}
+    
+    //{ Step 10: Setup misc device
+    pcard->miscdev.minor = MISC_DYNAMIC_MINOR;
+    pcard->miscdev.fops = &kp2000_fops;
+    pcard->miscdev.parent = &pcard->pdev->dev;
+    pcard->miscdev.name = pcard->name;
+    
+    err = misc_register(&pcard->miscdev);
+    if (err){
+        dev_err(&pcard->pdev->dev, "kp2000_pcie_probe: misc_register failed: %d\n", err);
+        goto out10;
+    }
+    //}
+    
+    //{ Step 11: Probe cores
+    err = kp2000_probe_cores(pcard);
+    if (err)
+        goto out11;
+    //}
+    
+    //{ Step 12: Enable IRQs in HW
+    SetBackEndControl(pcard->dma_common_regs, KPC_DMA_CARD_IRQ_ENABLE | KPC_DMA_CARD_USER_INTERRUPT_MODE);
+    //}
+    
+    dev_dbg(&pcard->pdev->dev, "kp2000_pcie_probe() complete!\n");
+    unlock_card(pcard);
+    return 0;
+
+  out11:
+    misc_deregister(&pcard->miscdev);
+  out10:
+    sysfs_remove_files(&(pdev->dev.kobj), kp_attr_list);
+  out9:
+    free_irq(pcard->pdev->irq, pcard);
+  out8b:
+    pci_disable_msi(pcard->pdev);
+  out8a:
+  out7:
+  out6:
+    iounmap(pcard->dma_bar_base);
+    pci_release_region(pdev, DMA_BAR);
+    pcard->dma_bar_base = NULL;
+  out5:
+    iounmap(pcard->regs_bar_base);
+    pci_release_region(pdev, REG_BAR);
+    pcard->regs_bar_base = NULL;
+  out4:
+    pci_disable_device(pcard->pdev);
+  out3:
+    unlock_card(pcard);
+    kfree(pcard);
+    return err;
+}
+
+
+void  kp2000_pcie_remove(struct pci_dev *pdev)
+{
+    struct kp2000_device *pcard = pci_get_drvdata(pdev);
+
+    dev_dbg(&pdev->dev, "kp2000_pcie_remove(pdev=%p)\n", pdev);
+    
+    if (pcard == NULL)  return;
+    
+    lock_card(pcard);
+    kp2000_remove_cores(pcard);
+    mfd_remove_devices(PCARD_TO_DEV(pcard));
+    misc_deregister(&pcard->miscdev);
+    sysfs_remove_files(&(pdev->dev.kobj), kp_attr_list);
+    free_irq(pcard->pdev->irq, pcard);
+    pci_disable_msi(pcard->pdev);
+    if (pcard->dma_bar_base != NULL){
+        iounmap(pcard->dma_bar_base);
+        pci_release_region(pdev, DMA_BAR);
+        pcard->dma_bar_base = NULL;
+    }
+    if (pcard->regs_bar_base != NULL){
+        iounmap(pcard->regs_bar_base);
+        pci_release_region(pdev, REG_BAR);
+        pcard->regs_bar_base = NULL;
+    }
+    pci_disable_device(pcard->pdev);
+    pci_set_drvdata(pdev, NULL);
+    unlock_card(pcard);
+    kfree(pcard);
+}
