commit 463288b98190d55d0610aef28582480b44a58657
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Apr 6 20:31:16 2020 +0100

    staging: vt6556: vnt_rf_setpower convert to use ieee80211_channel.
    
    ieee80211_channel contains all the necessary information to change
    power according to tx mode required.
    
    vnt_rf_setpower is moved and so that vnt_rf_set_txpower the only
    caller becomes static.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Link: https://lore.kernel.org/r/9eab9af8-fde9-1dc6-fced-95c7a36ecc01@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 2c5250ca2801..0ccc87da394e 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -122,8 +122,7 @@ void vnt_run_command(struct work_struct *work)
 
 	case WLAN_CMD_SETPOWER_START:
 
-		vnt_rf_setpower(priv, priv->current_rate,
-				priv->hw->conf.chandef.chan->hw_value);
+		vnt_rf_setpower(priv, priv->hw->conf.chandef.chan);
 
 		break;
 

commit c0bcf9f3f5b661d4ace2a64a79ef661edd2a4dc8
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri Dec 20 21:15:59 2019 +0000

    staging: vt6656: set usb_set_intfdata on driver fail.
    
    intfdata will contain stale pointer when the device is detached after
    failed initialization when referenced in vt6656_disconnect
    
    Provide driver access to it here and NULL it.
    
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Link: https://lore.kernel.org/r/6de448d7-d833-ef2e-dd7b-3ef9992fee0e@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 3eb2f11a5de1..2c5250ca2801 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -99,6 +99,7 @@ void vnt_run_command(struct work_struct *work)
 		if (vnt_init(priv)) {
 			/* If fail all ends TODO retry */
 			dev_err(&priv->usb->dev, "failed to start\n");
+			usb_set_intfdata(priv->intf, NULL);
 			ieee80211_free_hw(priv->hw);
 			return;
 		}

commit dd41dab5d54f4cde127ba47ab6764731428f96ca
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 21:07:55 2017 +0100

    staging: vt6656: Remove redundant license text
    
    Now that the SPDX tag is in all vt6656 files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 45f464bcf47b..3eb2f11a5de1 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -3,17 +3,6 @@
  * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  * All rights reserved.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- *
  * File: wcmd.c
  *
  * Purpose: Handles the management command interface functions

commit 6b4c6ce892047022fd716e2afa5fb857f1bb0ee7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 21:07:52 2017 +0100

    staging: vt6656: add SPDX identifiers to all vt6656 driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the vt6656 driver files with the correct SPDX license identifier
    based on the license text in the file itself.  The SPDX identifier is a
    legally binding shorthand, which can be used instead of the full boiler
    plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Forest Bond <forest@alittletooquiet.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index b2fc17f1381b..45f464bcf47b 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  * All rights reserved.

commit dff1e0ef86cba81bf3d892036a28e8b889b7e72c
Author: Katie Dunne <kdunne@mail.ccsf.edu>
Date:   Mon Feb 20 13:53:07 2017 -0800

    staging: vt6656: remove blank lines at opening and closing braces
    
    Removes unnecessary blank lines after opening and before closing braces.
    These instances were found by checkpatch.pl.
    
    Signed-off-by: Katie Dunne <kdunne@mail.ccsf.edu>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 9f6cc2ef08dd..b2fc17f1381b 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -45,7 +45,6 @@ static void vnt_cmd_timer_wait(struct vnt_private *priv, unsigned long msecs)
 
 static int vnt_cmd_complete(struct vnt_private *priv)
 {
-
 	priv->command_state = WLAN_CMD_IDLE;
 	if (priv->free_cmd_queue == CMD_Q_SIZE) {
 		/* Command Queue Empty */
@@ -165,7 +164,6 @@ void vnt_run_command(struct work_struct *work)
 
 int vnt_schedule_command(struct vnt_private *priv, enum vnt_cmd command)
 {
-
 	if (priv->free_cmd_queue == 0)
 		return false;
 
@@ -178,7 +176,6 @@ int vnt_schedule_command(struct vnt_private *priv, enum vnt_cmd command)
 		vnt_cmd_complete(priv);
 
 	return true;
-
 }
 
 void vnt_reset_command_timer(struct vnt_private *priv)

commit 812930665872e668119412a4bdb0c08f8c373a1f
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Tue Feb 14 23:39:15 2017 +0530

    staging: vt6656: Alignment should match open parenthesis
    
    Fix checkpatch issues: "CHECK: Alignment should match open parenthesis"
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 95faaeb7432a..9f6cc2ef08dd 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -139,7 +139,7 @@ void vnt_run_command(struct work_struct *work)
 
 	case WLAN_CMD_CHANGE_ANTENNA_START:
 		dev_dbg(&priv->usb->dev, "Change from Antenna%d to",
-							priv->rx_antenna_sel);
+			priv->rx_antenna_sel);
 
 		if (priv->rx_antenna_sel == 0) {
 			priv->rx_antenna_sel = 1;

commit 06884afcf2ab18d314d94456fbf1ac3c860e99bb
Author: Parth Sane <laerdevstudios@gmail.com>
Date:   Tue Mar 22 18:25:37 2016 +0530

    staging: vt6656: Fixed multiple logical comparisions warnings
    
    Using comparison to false and true is error prone. Fixed multiple warnings as
    per checkpatch guidelines.
    
    Signed-off-by: Parth Sane <laerdevstudios@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 4846a898d39b..95faaeb7432a 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -97,7 +97,7 @@ void vnt_run_command(struct work_struct *work)
 	if (test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags))
 		return;
 
-	if (priv->cmd_running != true)
+	if (!priv->cmd_running)
 		return;
 
 	switch (priv->command_state) {
@@ -143,13 +143,13 @@ void vnt_run_command(struct work_struct *work)
 
 		if (priv->rx_antenna_sel == 0) {
 			priv->rx_antenna_sel = 1;
-			if (priv->tx_rx_ant_inv == true)
+			if (priv->tx_rx_ant_inv)
 				vnt_set_antenna_mode(priv, ANT_RXA);
 			else
 				vnt_set_antenna_mode(priv, ANT_RXB);
 		} else {
 			priv->rx_antenna_sel = 0;
-			if (priv->tx_rx_ant_inv == true)
+			if (priv->tx_rx_ant_inv)
 				vnt_set_antenna_mode(priv, ANT_RXB);
 			else
 				vnt_set_antenna_mode(priv, ANT_RXA);
@@ -174,7 +174,7 @@ int vnt_schedule_command(struct vnt_private *priv, enum vnt_cmd command)
 	ADD_ONE_WITH_WRAP_AROUND(priv->cmd_enqueue_idx, CMD_Q_SIZE);
 	priv->free_cmd_queue--;
 
-	if (priv->cmd_running == false)
+	if (!priv->cmd_running)
 		vnt_cmd_complete(priv);
 
 	return true;

commit a85994d5467a8fbcecc4ae4a42f9d4c1a0a54886
Author: Othmar Pasteka <pasteka@kabsi.at>
Date:   Mon Nov 16 23:29:44 2015 +0100

    staging: vt6656: remove address from GPL text
    
    Cleanup errors from checkpatch.pl.
    
    Signed-off-by: Othmar Pasteka <pasteka@kabsi.at>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 3cbf4791bac1..4846a898d39b 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -12,9 +12,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * File: wcmd.c
  *

commit d78551b945f9bc48f5576c0da72786f0ac4e512f
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri Jul 25 20:51:54 2014 +0100

    staging: vt6656: remove return from all void functions
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 8f6417bcaed2..3cbf4791bac1 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -164,8 +164,6 @@ void vnt_run_command(struct work_struct *work)
 	}
 
 	vnt_cmd_complete(priv);
-
-	return;
 }
 
 int vnt_schedule_command(struct vnt_private *priv, enum vnt_cmd command)

commit cbcc9a365a8a5a673f4b15bfcc4e1b18b9f69db4
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Jul 24 21:13:20 2014 +0100

    staging: vt6656: use test_bit to check flags status
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index e5330e3ce407..8f6417bcaed2 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -97,7 +97,7 @@ void vnt_run_command(struct work_struct *work)
 	struct vnt_private *priv =
 		container_of(work, struct vnt_private, run_command_work.work);
 
-	if (priv->flags & DEVICE_FLAGS_DISCONNECTED)
+	if (test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags))
 		return;
 
 	if (priv->cmd_running != true)

commit 2746321ef4779608e4c0696c41b442936959ef47
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Jul 24 21:13:16 2014 +0100

    staging: vt6656: struct vnt_private merge flag and macros
    
    merge u32 flag into unsigned long Flags
    
    Replacing fMP_DISCONNECTED with DEVICE_FLAGS_DISCONNECTED
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index e4a5e2bead70..e5330e3ce407 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -97,7 +97,7 @@ void vnt_run_command(struct work_struct *work)
 	struct vnt_private *priv =
 		container_of(work, struct vnt_private, run_command_work.work);
 
-	if (priv->Flags & fMP_DISCONNECTED)
+	if (priv->flags & DEVICE_FLAGS_DISCONNECTED)
 		return;
 
 	if (priv->cmd_running != true)

commit bab97c05510fbaa28655bd5592dc0b559e677c1c
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 20 15:33:29 2014 +0100

    staging: vt6656: dead code remove channel switch.
    
    The driver needs to do anything special for channel switch.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index a63d0fd28423..e4a5e2bead70 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -83,10 +83,6 @@ static int vnt_cmd_complete(struct vnt_private *priv)
 		priv->command_state = WLAN_CMD_CHANGE_ANTENNA_START;
 		break;
 
-	case WLAN_CMD_11H_CHSW:
-		priv->command_state = WLAN_CMD_11H_CHSW_START;
-		break;
-
 	default:
 		break;
 	}
@@ -163,10 +159,6 @@ void vnt_run_command(struct work_struct *work)
 		}
 		break;
 
-	case WLAN_CMD_11H_CHSW_START:
-		vnt_set_channel(priv, priv->hw->conf.chandef.chan->hw_value);
-		break;
-
 	default:
 		break;
 	}

commit 8b84c1da02f3de5c362a68fab1951c771192a806
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 20 15:33:19 2014 +0100

    staging: vt6656: struct vnt_private replace wCurrentRate with current_rate
    
    Removing type prefix and camel case.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 304f6d67ccae..a63d0fd28423 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -139,7 +139,7 @@ void vnt_run_command(struct work_struct *work)
 
 	case WLAN_CMD_SETPOWER_START:
 
-		vnt_rf_setpower(priv, priv->wCurrentRate,
+		vnt_rf_setpower(priv, priv->current_rate,
 				priv->hw->conf.chandef.chan->hw_value);
 
 		break;

commit 2044dbdb0b337ab7ddc36c45fc792b76913b57e8
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Jul 19 12:30:16 2014 +0100

    staging: vt6656: struct vnt_private remove camel case antenna variables
    
    Camel case changes
    bTxRxAntInv -> tx_rx_ant_inv
    dwRxAntennaSel -> rx_antenna_sel
    byRxAntennaMode -> rx_antenna_mode
    byTxAntennaMode -> tx_antenna_mode
    byRadioCtl -> radio_ctl
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index c56b7b3c90de..304f6d67ccae 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -146,17 +146,17 @@ void vnt_run_command(struct work_struct *work)
 
 	case WLAN_CMD_CHANGE_ANTENNA_START:
 		dev_dbg(&priv->usb->dev, "Change from Antenna%d to",
-							priv->dwRxAntennaSel);
+							priv->rx_antenna_sel);
 
-		if (priv->dwRxAntennaSel == 0) {
-			priv->dwRxAntennaSel = 1;
-			if (priv->bTxRxAntInv == true)
+		if (priv->rx_antenna_sel == 0) {
+			priv->rx_antenna_sel = 1;
+			if (priv->tx_rx_ant_inv == true)
 				vnt_set_antenna_mode(priv, ANT_RXA);
 			else
 				vnt_set_antenna_mode(priv, ANT_RXB);
 		} else {
-			priv->dwRxAntennaSel = 0;
-			if (priv->bTxRxAntInv == true)
+			priv->rx_antenna_sel = 0;
+			if (priv->tx_rx_ant_inv == true)
 				vnt_set_antenna_mode(priv, ANT_RXB);
 			else
 				vnt_set_antenna_mode(priv, ANT_RXA);

commit 41868bf4b56d9177cce46eb8eca3f7895f065493
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jul 16 22:21:52 2014 +0100

    staging: vt6656: rename BBvSetAntennaMode to vnt_set_antenna_mode
    
    Dropping BB
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index bf41e673e9bb..c56b7b3c90de 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -151,15 +151,15 @@ void vnt_run_command(struct work_struct *work)
 		if (priv->dwRxAntennaSel == 0) {
 			priv->dwRxAntennaSel = 1;
 			if (priv->bTxRxAntInv == true)
-				BBvSetAntennaMode(priv, ANT_RXA);
+				vnt_set_antenna_mode(priv, ANT_RXA);
 			else
-				BBvSetAntennaMode(priv, ANT_RXB);
+				vnt_set_antenna_mode(priv, ANT_RXB);
 		} else {
 			priv->dwRxAntennaSel = 0;
 			if (priv->bTxRxAntInv == true)
-				BBvSetAntennaMode(priv, ANT_RXB);
+				vnt_set_antenna_mode(priv, ANT_RXB);
 			else
-				BBvSetAntennaMode(priv, ANT_RXA);
+				vnt_set_antenna_mode(priv, ANT_RXA);
 		}
 		break;
 

commit a83a85939b27e0c7f1fbe1100af8b959133ffa7f
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 13 10:42:53 2014 +0100

    staging: vt6656: wcnd.c clean up comments
    
    Removing old functions and comments.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 3c6522848ad9..bf41e673e9bb 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -25,14 +25,9 @@
  * Date: May 8, 2003
  *
  * Functions:
- *      s_vProbeChannel - Active scan channel
- *      s_MgrMakeProbeRequest - Make ProbeRequest packet
- *      CommandTimer - Timer function to handle command
  *	vnt_cmd_complete - Command Complete function
- *      vnt_schedule_command - Push Command and wait Command Scheduler to do
- *      vCommandTimer- Command call back functions
+ *	vnt_schedule_command - Push Command and wait Command Scheduler to do
  *	vnt_cmd_timer_wait- Call back timer
- *      s_bClearBSSID_SCAN- Clear BSSID_SCAN cmd in CMD Queue
  *
  * Revision History:
  *
@@ -174,7 +169,7 @@ void vnt_run_command(struct work_struct *work)
 
 	default:
 		break;
-	} //switch
+	}
 
 	vnt_cmd_complete(priv);
 

commit 983b65fa8d32061938e589d660ec85c30e9a9dc9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 13 10:42:52 2014 +0100

    staging: vt6656: wcmd remove unneeded headers
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index bb9500fcc091..3c6522848ad9 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -40,14 +40,11 @@
 
 #include "device.h"
 #include "mac.h"
-#include "card.h"
 #include "wcmd.h"
 #include "power.h"
-#include "baseband.h"
 #include "usbpipe.h"
 #include "rxtx.h"
 #include "rf.h"
-#include "channel.h"
 
 static void vnt_cmd_timer_wait(struct vnt_private *priv, unsigned long msecs)
 {

commit 68cc161ee57ee4ea1789a45be42f4c161c577f16
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 13 10:42:51 2014 +0100

    staging: vt6656: rename vResetCommandTimer to vnt_reset_command_timer
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index b217efb1667a..bb9500fcc091 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -202,7 +202,7 @@ int vnt_schedule_command(struct vnt_private *priv, enum vnt_cmd command)
 
 }
 
-void vResetCommandTimer(struct vnt_private *priv)
+void vnt_reset_command_timer(struct vnt_private *priv)
 {
 	priv->free_cmd_queue = CMD_Q_SIZE;
 	priv->cmd_dequeue_idx = 0;

commit 57981a65fbd867fccf83b2c0d5cc8d0d835be056
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 13 10:42:50 2014 +0100

    staging: vt6656: Drop u8 pointer and rename bScheduleCommand.
    
    Rename to vnt_schedule_command removing unused u8 pointer.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 864d5e59d362..b217efb1667a 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -29,7 +29,7 @@
  *      s_MgrMakeProbeRequest - Make ProbeRequest packet
  *      CommandTimer - Timer function to handle command
  *	vnt_cmd_complete - Command Complete function
- *      bScheduleCommand - Push Command and wait Command Scheduler to do
+ *      vnt_schedule_command - Push Command and wait Command Scheduler to do
  *      vCommandTimer- Command call back functions
  *	vnt_cmd_timer_wait- Call back timer
  *      s_bClearBSSID_SCAN- Clear BSSID_SCAN cmd in CMD Queue
@@ -184,7 +184,7 @@ void vnt_run_command(struct work_struct *work)
 	return;
 }
 
-int bScheduleCommand(struct vnt_private *priv, enum vnt_cmd command, u8 *item0)
+int vnt_schedule_command(struct vnt_private *priv, enum vnt_cmd command)
 {
 
 	if (priv->free_cmd_queue == 0)

commit 592365ae4ac2872ca48334a3ce0bd77704db3d28
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 13 10:42:49 2014 +0100

    staging: vt6656: rename vRunCommand to vnt_run_command
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 87e682ddd8e4..864d5e59d362 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -104,7 +104,7 @@ static int vnt_cmd_complete(struct vnt_private *priv)
 	return true;
 }
 
-void vRunCommand(struct work_struct *work)
+void vnt_run_command(struct work_struct *work)
 {
 	struct vnt_private *priv =
 		container_of(work, struct vnt_private, run_command_work.work);

commit 2cd98cd5b83282d2317a410dd6a2e2aaf963787d
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 13 10:42:48 2014 +0100

    staging: vt6656: rename vCommandTimerWait to vnt_cmd_timer_wait
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 8c5a0e854492..87e682ddd8e4 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -31,7 +31,7 @@
  *	vnt_cmd_complete - Command Complete function
  *      bScheduleCommand - Push Command and wait Command Scheduler to do
  *      vCommandTimer- Command call back functions
- *      vCommandTimerWait- Call back timer
+ *	vnt_cmd_timer_wait- Call back timer
  *      s_bClearBSSID_SCAN- Clear BSSID_SCAN cmd in CMD Queue
  *
  * Revision History:
@@ -49,7 +49,7 @@
 #include "rf.h"
 #include "channel.h"
 
-static void vCommandTimerWait(struct vnt_private *priv, unsigned long msecs)
+static void vnt_cmd_timer_wait(struct vnt_private *priv, unsigned long msecs)
 {
 	schedule_delayed_work(&priv->run_command_work, msecs_to_jiffies(msecs));
 }
@@ -99,7 +99,7 @@ static int vnt_cmd_complete(struct vnt_private *priv)
 		break;
 	}
 
-	vCommandTimerWait(priv, 0);
+	vnt_cmd_timer_wait(priv, 0);
 
 	return true;
 }

commit 60cecd2857b26a38c3342a71489b83e61da2ed86
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 13 10:42:47 2014 +0100

    staging: vt6656: Move and rename s_bCommandComplete to vnt_cmd_complete
    
    Remove static declaration and moving for function visibility
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 37ca3de2f1e3..8c5a0e854492 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -28,7 +28,7 @@
  *      s_vProbeChannel - Active scan channel
  *      s_MgrMakeProbeRequest - Make ProbeRequest packet
  *      CommandTimer - Timer function to handle command
- *      s_bCommandComplete - Command Complete function
+ *	vnt_cmd_complete - Command Complete function
  *      bScheduleCommand - Push Command and wait Command Scheduler to do
  *      vCommandTimer- Command call back functions
  *      vCommandTimerWait- Call back timer
@@ -49,13 +49,61 @@
 #include "rf.h"
 #include "channel.h"
 
-static int s_bCommandComplete(struct vnt_private *);
-
 static void vCommandTimerWait(struct vnt_private *priv, unsigned long msecs)
 {
 	schedule_delayed_work(&priv->run_command_work, msecs_to_jiffies(msecs));
 }
 
+static int vnt_cmd_complete(struct vnt_private *priv)
+{
+
+	priv->command_state = WLAN_CMD_IDLE;
+	if (priv->free_cmd_queue == CMD_Q_SIZE) {
+		/* Command Queue Empty */
+		priv->cmd_running = false;
+		return true;
+	}
+
+	priv->command = priv->cmd_queue[priv->cmd_dequeue_idx];
+
+	ADD_ONE_WITH_WRAP_AROUND(priv->cmd_dequeue_idx, CMD_Q_SIZE);
+	priv->free_cmd_queue++;
+	priv->cmd_running = true;
+
+	switch (priv->command) {
+	case WLAN_CMD_INIT_MAC80211:
+		priv->command_state = WLAN_CMD_INIT_MAC80211_START;
+		break;
+
+	case WLAN_CMD_TBTT_WAKEUP:
+		priv->command_state = WLAN_CMD_TBTT_WAKEUP_START;
+		break;
+
+	case WLAN_CMD_BECON_SEND:
+		priv->command_state = WLAN_CMD_BECON_SEND_START;
+		break;
+
+	case WLAN_CMD_SETPOWER:
+		priv->command_state = WLAN_CMD_SETPOWER_START;
+		break;
+
+	case WLAN_CMD_CHANGE_ANTENNA:
+		priv->command_state = WLAN_CMD_CHANGE_ANTENNA_START;
+		break;
+
+	case WLAN_CMD_11H_CHSW:
+		priv->command_state = WLAN_CMD_11H_CHSW_START;
+		break;
+
+	default:
+		break;
+	}
+
+	vCommandTimerWait(priv, 0);
+
+	return true;
+}
+
 void vRunCommand(struct work_struct *work)
 {
 	struct vnt_private *priv =
@@ -131,61 +179,11 @@ void vRunCommand(struct work_struct *work)
 		break;
 	} //switch
 
-	s_bCommandComplete(priv);
+	vnt_cmd_complete(priv);
 
 	return;
 }
 
-static int s_bCommandComplete(struct vnt_private *priv)
-{
-
-	priv->command_state = WLAN_CMD_IDLE;
-	if (priv->free_cmd_queue == CMD_Q_SIZE) {
-		/* Command Queue Empty */
-		priv->cmd_running = false;
-		return true;
-	}
-
-	priv->command = priv->cmd_queue[priv->cmd_dequeue_idx];
-
-	ADD_ONE_WITH_WRAP_AROUND(priv->cmd_dequeue_idx, CMD_Q_SIZE);
-	priv->free_cmd_queue++;
-	priv->cmd_running = true;
-
-	switch (priv->command) {
-	case WLAN_CMD_INIT_MAC80211:
-		priv->command_state = WLAN_CMD_INIT_MAC80211_START;
-		break;
-
-	case WLAN_CMD_TBTT_WAKEUP:
-		priv->command_state = WLAN_CMD_TBTT_WAKEUP_START;
-		break;
-
-	case WLAN_CMD_BECON_SEND:
-		priv->command_state = WLAN_CMD_BECON_SEND_START;
-		break;
-
-	case WLAN_CMD_SETPOWER:
-		priv->command_state = WLAN_CMD_SETPOWER_START;
-		break;
-
-	case WLAN_CMD_CHANGE_ANTENNA:
-		priv->command_state = WLAN_CMD_CHANGE_ANTENNA_START;
-		break;
-
-	case WLAN_CMD_11H_CHSW:
-		priv->command_state = WLAN_CMD_11H_CHSW_START;
-		break;
-
-	default:
-		break;
-	}
-
-	vCommandTimerWait(priv, 0);
-
-	return true;
-}
-
 int bScheduleCommand(struct vnt_private *priv, enum vnt_cmd command, u8 *item0)
 {
 
@@ -198,7 +196,7 @@ int bScheduleCommand(struct vnt_private *priv, enum vnt_cmd command, u8 *item0)
 	priv->free_cmd_queue--;
 
 	if (priv->cmd_running == false)
-		s_bCommandComplete(priv);
+		vnt_cmd_complete(priv);
 
 	return true;
 

commit 33a60b87b65eb69bc31adb12ee92cf0664a2ad3b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 13 10:42:45 2014 +0100

    staging: vt6656: replace camel case from command variables
    
    camel case changes
    uCmdDequeueIdx -> cmd_dequeue_idx
    uCmdEnqueueIdx -> cmd_enqueue_idx
    cbFreeCmdQueue -> free_cmd_queue
    bCmdRunning -> cmd_running
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index fa7c7b654cbd..37ca3de2f1e3 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -64,7 +64,7 @@ void vRunCommand(struct work_struct *work)
 	if (priv->Flags & fMP_DISCONNECTED)
 		return;
 
-	if (priv->bCmdRunning != true)
+	if (priv->cmd_running != true)
 		return;
 
 	switch (priv->command_state) {
@@ -140,17 +140,17 @@ static int s_bCommandComplete(struct vnt_private *priv)
 {
 
 	priv->command_state = WLAN_CMD_IDLE;
-	if (priv->cbFreeCmdQueue == CMD_Q_SIZE) {
+	if (priv->free_cmd_queue == CMD_Q_SIZE) {
 		/* Command Queue Empty */
-		priv->bCmdRunning = false;
+		priv->cmd_running = false;
 		return true;
 	}
 
-	priv->command = priv->cmd_queue[priv->uCmdDequeueIdx];
+	priv->command = priv->cmd_queue[priv->cmd_dequeue_idx];
 
-	ADD_ONE_WITH_WRAP_AROUND(priv->uCmdDequeueIdx, CMD_Q_SIZE);
-	priv->cbFreeCmdQueue++;
-	priv->bCmdRunning = true;
+	ADD_ONE_WITH_WRAP_AROUND(priv->cmd_dequeue_idx, CMD_Q_SIZE);
+	priv->free_cmd_queue++;
+	priv->cmd_running = true;
 
 	switch (priv->command) {
 	case WLAN_CMD_INIT_MAC80211:
@@ -189,15 +189,15 @@ static int s_bCommandComplete(struct vnt_private *priv)
 int bScheduleCommand(struct vnt_private *priv, enum vnt_cmd command, u8 *item0)
 {
 
-	if (priv->cbFreeCmdQueue == 0)
+	if (priv->free_cmd_queue == 0)
 		return false;
 
-	priv->cmd_queue[priv->uCmdEnqueueIdx] = command;
+	priv->cmd_queue[priv->cmd_enqueue_idx] = command;
 
-	ADD_ONE_WITH_WRAP_AROUND(priv->uCmdEnqueueIdx, CMD_Q_SIZE);
-	priv->cbFreeCmdQueue--;
+	ADD_ONE_WITH_WRAP_AROUND(priv->cmd_enqueue_idx, CMD_Q_SIZE);
+	priv->free_cmd_queue--;
 
-	if (priv->bCmdRunning == false)
+	if (priv->cmd_running == false)
 		s_bCommandComplete(priv);
 
 	return true;
@@ -206,9 +206,9 @@ int bScheduleCommand(struct vnt_private *priv, enum vnt_cmd command, u8 *item0)
 
 void vResetCommandTimer(struct vnt_private *priv)
 {
-	priv->cbFreeCmdQueue = CMD_Q_SIZE;
-	priv->uCmdDequeueIdx = 0;
-	priv->uCmdEnqueueIdx = 0;
+	priv->free_cmd_queue = CMD_Q_SIZE;
+	priv->cmd_dequeue_idx = 0;
+	priv->cmd_enqueue_idx = 0;
 	priv->command_state = WLAN_CMD_IDLE;
-	priv->bCmdRunning = false;
+	priv->cmd_running = false;
 }

commit 9a309289b24afc1edb8f2be67efd7f91d163da81
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 13 10:42:44 2014 +0100

    staging: vt6656: remove unused variables bCmdClear and bNeedRadioOFF
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index c2da8cceff10..fa7c7b654cbd 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -211,5 +211,4 @@ void vResetCommandTimer(struct vnt_private *priv)
 	priv->uCmdEnqueueIdx = 0;
 	priv->command_state = WLAN_CMD_IDLE;
 	priv->bCmdRunning = false;
-	priv->bCmdClear = false;
 }

commit b595f9b89c609476de8165ee081f8fb5d25d02f7
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 13 10:42:43 2014 +0100

    staging: vt6656: remove typedef struct tagCMD_ITEM
    
    Since enum vnt_cmd is only member replace with array
    enum vnt_cmd cmd_queue with size of CMD_Q_SIZE
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index e0ad20aa49f5..c2da8cceff10 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -146,7 +146,7 @@ static int s_bCommandComplete(struct vnt_private *priv)
 		return true;
 	}
 
-	priv->command = priv->eCmdQueue[priv->uCmdDequeueIdx].cmd;
+	priv->command = priv->cmd_queue[priv->uCmdDequeueIdx];
 
 	ADD_ONE_WITH_WRAP_AROUND(priv->uCmdDequeueIdx, CMD_Q_SIZE);
 	priv->cbFreeCmdQueue++;
@@ -192,7 +192,7 @@ int bScheduleCommand(struct vnt_private *priv, enum vnt_cmd command, u8 *item0)
 	if (priv->cbFreeCmdQueue == 0)
 		return false;
 
-	priv->eCmdQueue[priv->uCmdEnqueueIdx].cmd = command;
+	priv->cmd_queue[priv->uCmdEnqueueIdx] = command;
 
 	ADD_ONE_WITH_WRAP_AROUND(priv->uCmdEnqueueIdx, CMD_Q_SIZE);
 	priv->cbFreeCmdQueue--;

commit ad74e91d06225e9f649baad786faf0992e996050
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 13 10:42:42 2014 +0100

    staging: vt6656: replace typedef enum tagCMD_STATE with enum vnt_cmd_state
    
    Replacing variables.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 3d9ace2febd0..e0ad20aa49f5 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -67,7 +67,7 @@ void vRunCommand(struct work_struct *work)
 	if (priv->bCmdRunning != true)
 		return;
 
-	switch (priv->eCommandState) {
+	switch (priv->command_state) {
 	case WLAN_CMD_INIT_MAC80211_START:
 		if (priv->mac_hw)
 			break;
@@ -139,7 +139,7 @@ void vRunCommand(struct work_struct *work)
 static int s_bCommandComplete(struct vnt_private *priv)
 {
 
-	priv->eCommandState = WLAN_CMD_IDLE;
+	priv->command_state = WLAN_CMD_IDLE;
 	if (priv->cbFreeCmdQueue == CMD_Q_SIZE) {
 		/* Command Queue Empty */
 		priv->bCmdRunning = false;
@@ -154,27 +154,27 @@ static int s_bCommandComplete(struct vnt_private *priv)
 
 	switch (priv->command) {
 	case WLAN_CMD_INIT_MAC80211:
-		priv->eCommandState = WLAN_CMD_INIT_MAC80211_START;
+		priv->command_state = WLAN_CMD_INIT_MAC80211_START;
 		break;
 
 	case WLAN_CMD_TBTT_WAKEUP:
-		priv->eCommandState = WLAN_CMD_TBTT_WAKEUP_START;
+		priv->command_state = WLAN_CMD_TBTT_WAKEUP_START;
 		break;
 
 	case WLAN_CMD_BECON_SEND:
-		priv->eCommandState = WLAN_CMD_BECON_SEND_START;
+		priv->command_state = WLAN_CMD_BECON_SEND_START;
 		break;
 
 	case WLAN_CMD_SETPOWER:
-		priv->eCommandState = WLAN_CMD_SETPOWER_START;
+		priv->command_state = WLAN_CMD_SETPOWER_START;
 		break;
 
 	case WLAN_CMD_CHANGE_ANTENNA:
-		priv->eCommandState = WLAN_CMD_CHANGE_ANTENNA_START;
+		priv->command_state = WLAN_CMD_CHANGE_ANTENNA_START;
 		break;
 
 	case WLAN_CMD_11H_CHSW:
-		priv->eCommandState = WLAN_CMD_11H_CHSW_START;
+		priv->command_state = WLAN_CMD_11H_CHSW_START;
 		break;
 
 	default:
@@ -209,7 +209,7 @@ void vResetCommandTimer(struct vnt_private *priv)
 	priv->cbFreeCmdQueue = CMD_Q_SIZE;
 	priv->uCmdDequeueIdx = 0;
 	priv->uCmdEnqueueIdx = 0;
-	priv->eCommandState = WLAN_CMD_IDLE;
+	priv->command_state = WLAN_CMD_IDLE;
 	priv->bCmdRunning = false;
 	priv->bCmdClear = false;
 }

commit 80f0d0923f7a8f580db2415e30580585e5d7f272
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jul 13 10:42:41 2014 +0100

    staging: vt6656: replace typedef enum tagCMD_CODE with enum vnt_cmd
    
    Replacing the variables.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index ade0f8117af7..3d9ace2febd0 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -146,13 +146,13 @@ static int s_bCommandComplete(struct vnt_private *priv)
 		return true;
 	}
 
-	priv->eCommand = priv->eCmdQueue[priv->uCmdDequeueIdx].eCmd;
+	priv->command = priv->eCmdQueue[priv->uCmdDequeueIdx].cmd;
 
 	ADD_ONE_WITH_WRAP_AROUND(priv->uCmdDequeueIdx, CMD_Q_SIZE);
 	priv->cbFreeCmdQueue++;
 	priv->bCmdRunning = true;
 
-	switch (priv->eCommand) {
+	switch (priv->command) {
 	case WLAN_CMD_INIT_MAC80211:
 		priv->eCommandState = WLAN_CMD_INIT_MAC80211_START;
 		break;
@@ -186,13 +186,13 @@ static int s_bCommandComplete(struct vnt_private *priv)
 	return true;
 }
 
-int bScheduleCommand(struct vnt_private *priv, CMD_CODE command, u8 *item0)
+int bScheduleCommand(struct vnt_private *priv, enum vnt_cmd command, u8 *item0)
 {
 
 	if (priv->cbFreeCmdQueue == 0)
 		return false;
 
-	priv->eCmdQueue[priv->uCmdEnqueueIdx].eCmd = command;
+	priv->eCmdQueue[priv->uCmdEnqueueIdx].cmd = command;
 
 	ADD_ONE_WITH_WRAP_AROUND(priv->uCmdEnqueueIdx, CMD_Q_SIZE);
 	priv->cbFreeCmdQueue--;

commit f7f048575727dca81f994590de3fbb62bceef4d9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Jul 12 07:53:48 2014 +0100

    staging: vt6656: wcmd replace debug message with dev_dbg
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 9130f146e112..ade0f8117af7 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -49,9 +49,6 @@
 #include "rf.h"
 #include "channel.h"
 
-static int msglevel = MSG_LEVEL_INFO;
-//static int msglevel = MSG_LEVEL_DEBUG;
-
 static int s_bCommandComplete(struct vnt_private *);
 
 static void vCommandTimerWait(struct vnt_private *priv, unsigned long msecs)
@@ -108,8 +105,8 @@ void vRunCommand(struct work_struct *work)
 		break;
 
 	case WLAN_CMD_CHANGE_ANTENNA_START:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO
-			"Change from Antenna%d to", (int)priv->dwRxAntennaSel);
+		dev_dbg(&priv->usb->dev, "Change from Antenna%d to",
+							priv->dwRxAntennaSel);
 
 		if (priv->dwRxAntennaSel == 0) {
 			priv->dwRxAntennaSel = 1;

commit 4e3af0fa6779c2779ad56575e7f5e965d2c30c07
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Jul 12 07:53:47 2014 +0100

    staging: vt6656: vResetCommandTimer remove camel case
    
    pDevice -> priv
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 76e7f78e179e..9130f146e112 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -207,12 +207,12 @@ int bScheduleCommand(struct vnt_private *priv, CMD_CODE command, u8 *item0)
 
 }
 
-void vResetCommandTimer(struct vnt_private *pDevice)
+void vResetCommandTimer(struct vnt_private *priv)
 {
-	pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
-	pDevice->uCmdDequeueIdx = 0;
-	pDevice->uCmdEnqueueIdx = 0;
-	pDevice->eCommandState = WLAN_CMD_IDLE;
-	pDevice->bCmdRunning = false;
-	pDevice->bCmdClear = false;
+	priv->cbFreeCmdQueue = CMD_Q_SIZE;
+	priv->uCmdDequeueIdx = 0;
+	priv->uCmdEnqueueIdx = 0;
+	priv->eCommandState = WLAN_CMD_IDLE;
+	priv->bCmdRunning = false;
+	priv->bCmdClear = false;
 }

commit f7e9ed41c9ef4a755d7e941b1cc0976b01e90940
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Jul 12 07:53:46 2014 +0100

    staging: vt6656: bScheduleCommand remove camel case
    
    Camel case changes
    pDevice -> priv
    eCommand -> command
    pbyItem0 -> item0
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index cdd828c25a07..76e7f78e179e 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -189,19 +189,19 @@ static int s_bCommandComplete(struct vnt_private *priv)
 	return true;
 }
 
-int bScheduleCommand(struct vnt_private *pDevice,
-		CMD_CODE eCommand, u8 *pbyItem0)
+int bScheduleCommand(struct vnt_private *priv, CMD_CODE command, u8 *item0)
 {
 
-	if (pDevice->cbFreeCmdQueue == 0)
+	if (priv->cbFreeCmdQueue == 0)
 		return false;
-	pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].eCmd = eCommand;
 
-	ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdEnqueueIdx, CMD_Q_SIZE);
-	pDevice->cbFreeCmdQueue--;
+	priv->eCmdQueue[priv->uCmdEnqueueIdx].eCmd = command;
 
-	if (pDevice->bCmdRunning == false)
-		s_bCommandComplete(pDevice);
+	ADD_ONE_WITH_WRAP_AROUND(priv->uCmdEnqueueIdx, CMD_Q_SIZE);
+	priv->cbFreeCmdQueue--;
+
+	if (priv->bCmdRunning == false)
+		s_bCommandComplete(priv);
 
 	return true;
 

commit d287093e4cd76b28e1312ae6ff577aea20aba47c
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Jul 12 07:53:45 2014 +0100

    staging: vt6656: s_bCommandComplete clean up and remove camel case
    
    pDevice -> priv
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index cc9d50aa2aca..cdd828c25a07 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -139,52 +139,52 @@ void vRunCommand(struct work_struct *work)
 	return;
 }
 
-static int s_bCommandComplete(struct vnt_private *pDevice)
+static int s_bCommandComplete(struct vnt_private *priv)
 {
 
-	pDevice->eCommandState = WLAN_CMD_IDLE;
-	if (pDevice->cbFreeCmdQueue == CMD_Q_SIZE) {
-		//Command Queue Empty
-		pDevice->bCmdRunning = false;
+	priv->eCommandState = WLAN_CMD_IDLE;
+	if (priv->cbFreeCmdQueue == CMD_Q_SIZE) {
+		/* Command Queue Empty */
+		priv->bCmdRunning = false;
 		return true;
 	}
 
-	pDevice->eCommand = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].eCmd;
+	priv->eCommand = priv->eCmdQueue[priv->uCmdDequeueIdx].eCmd;
 
-	ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdDequeueIdx, CMD_Q_SIZE);
-	pDevice->cbFreeCmdQueue++;
-	pDevice->bCmdRunning = true;
+	ADD_ONE_WITH_WRAP_AROUND(priv->uCmdDequeueIdx, CMD_Q_SIZE);
+	priv->cbFreeCmdQueue++;
+	priv->bCmdRunning = true;
 
-	switch (pDevice->eCommand) {
+	switch (priv->eCommand) {
 	case WLAN_CMD_INIT_MAC80211:
-		pDevice->eCommandState = WLAN_CMD_INIT_MAC80211_START;
+		priv->eCommandState = WLAN_CMD_INIT_MAC80211_START;
 		break;
 
 	case WLAN_CMD_TBTT_WAKEUP:
-		pDevice->eCommandState = WLAN_CMD_TBTT_WAKEUP_START;
+		priv->eCommandState = WLAN_CMD_TBTT_WAKEUP_START;
 		break;
 
 	case WLAN_CMD_BECON_SEND:
-		pDevice->eCommandState = WLAN_CMD_BECON_SEND_START;
+		priv->eCommandState = WLAN_CMD_BECON_SEND_START;
 		break;
 
 	case WLAN_CMD_SETPOWER:
-		pDevice->eCommandState = WLAN_CMD_SETPOWER_START;
+		priv->eCommandState = WLAN_CMD_SETPOWER_START;
 		break;
 
 	case WLAN_CMD_CHANGE_ANTENNA:
-		pDevice->eCommandState = WLAN_CMD_CHANGE_ANTENNA_START;
+		priv->eCommandState = WLAN_CMD_CHANGE_ANTENNA_START;
 		break;
 
 	case WLAN_CMD_11H_CHSW:
-		pDevice->eCommandState = WLAN_CMD_11H_CHSW_START;
+		priv->eCommandState = WLAN_CMD_11H_CHSW_START;
 		break;
 
 	default:
 		break;
 	}
 
-	vCommandTimerWait(pDevice, 0);
+	vCommandTimerWait(priv, 0);
 
 	return true;
 }

commit a675dc2136cff46c4148b6f1bed466d4b4e766e9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Jul 12 07:53:44 2014 +0100

    staging: vt6656: s_bCommandComplete remove else from if
    
    if returns out so remove else
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 1987d5c3ee01..cc9d50aa2aca 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -147,43 +147,45 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 		//Command Queue Empty
 		pDevice->bCmdRunning = false;
 		return true;
-	} else {
-		pDevice->eCommand = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].eCmd;
-
-		ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdDequeueIdx, CMD_Q_SIZE);
-		pDevice->cbFreeCmdQueue++;
-		pDevice->bCmdRunning = true;
-		switch (pDevice->eCommand) {
-		case WLAN_CMD_INIT_MAC80211:
-			pDevice->eCommandState = WLAN_CMD_INIT_MAC80211_START;
-			break;
+	}
 
-		case WLAN_CMD_TBTT_WAKEUP:
-			pDevice->eCommandState = WLAN_CMD_TBTT_WAKEUP_START;
-			break;
+	pDevice->eCommand = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].eCmd;
 
-		case WLAN_CMD_BECON_SEND:
-			pDevice->eCommandState = WLAN_CMD_BECON_SEND_START;
-			break;
+	ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdDequeueIdx, CMD_Q_SIZE);
+	pDevice->cbFreeCmdQueue++;
+	pDevice->bCmdRunning = true;
 
-		case WLAN_CMD_SETPOWER:
-			pDevice->eCommandState = WLAN_CMD_SETPOWER_START;
-			break;
+	switch (pDevice->eCommand) {
+	case WLAN_CMD_INIT_MAC80211:
+		pDevice->eCommandState = WLAN_CMD_INIT_MAC80211_START;
+		break;
 
-		case WLAN_CMD_CHANGE_ANTENNA:
-			pDevice->eCommandState = WLAN_CMD_CHANGE_ANTENNA_START;
-			break;
+	case WLAN_CMD_TBTT_WAKEUP:
+		pDevice->eCommandState = WLAN_CMD_TBTT_WAKEUP_START;
+		break;
 
-		case WLAN_CMD_11H_CHSW:
-			pDevice->eCommandState = WLAN_CMD_11H_CHSW_START;
-			break;
+	case WLAN_CMD_BECON_SEND:
+		pDevice->eCommandState = WLAN_CMD_BECON_SEND_START;
+		break;
 
-		default:
-			break;
-		}
-		vCommandTimerWait(pDevice, 0);
+	case WLAN_CMD_SETPOWER:
+		pDevice->eCommandState = WLAN_CMD_SETPOWER_START;
+		break;
+
+	case WLAN_CMD_CHANGE_ANTENNA:
+		pDevice->eCommandState = WLAN_CMD_CHANGE_ANTENNA_START;
+		break;
+
+	case WLAN_CMD_11H_CHSW:
+		pDevice->eCommandState = WLAN_CMD_11H_CHSW_START;
+		break;
+
+	default:
+		break;
 	}
 
+	vCommandTimerWait(pDevice, 0);
+
 	return true;
 }
 

commit 18647c5877125eade655b471c5a9f11268f568b6
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Jul 12 07:53:43 2014 +0100

    staging: vt6656: remove unused variables from struct tagCMD_ITEM
    
    Also remove local variables
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 5621c1496fd1..1987d5c3ee01 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -141,8 +141,6 @@ void vRunCommand(struct work_struct *work)
 
 static int s_bCommandComplete(struct vnt_private *pDevice)
 {
-	int bRadioCmd = false;
-	int bForceSCAN = true;
 
 	pDevice->eCommandState = WLAN_CMD_IDLE;
 	if (pDevice->cbFreeCmdQueue == CMD_Q_SIZE) {
@@ -151,8 +149,7 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 		return true;
 	} else {
 		pDevice->eCommand = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].eCmd;
-		bRadioCmd = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].bRadioCmd;
-		bForceSCAN = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].bForceSCAN;
+
 		ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdDequeueIdx, CMD_Q_SIZE);
 		pDevice->cbFreeCmdQueue++;
 		pDevice->bCmdRunning = true;
@@ -197,7 +194,6 @@ int bScheduleCommand(struct vnt_private *pDevice,
 	if (pDevice->cbFreeCmdQueue == 0)
 		return false;
 	pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].eCmd = eCommand;
-	pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = true;
 
 	ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdEnqueueIdx, CMD_Q_SIZE);
 	pDevice->cbFreeCmdQueue--;

commit cf07bb8e8407057bfc694399ca665c81e0dc15bb
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Jul 12 07:53:42 2014 +0100

    staging: vt6656: vRunCommand remove camel case.
    
    pDevice -> priv
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 50011937572a..5621c1496fd1 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -61,78 +61,80 @@ static void vCommandTimerWait(struct vnt_private *priv, unsigned long msecs)
 
 void vRunCommand(struct work_struct *work)
 {
-	struct vnt_private *pDevice =
+	struct vnt_private *priv =
 		container_of(work, struct vnt_private, run_command_work.work);
 
-	if (pDevice->Flags & fMP_DISCONNECTED)
+	if (priv->Flags & fMP_DISCONNECTED)
 		return;
 
-	if (pDevice->bCmdRunning != true)
+	if (priv->bCmdRunning != true)
 		return;
 
-	switch (pDevice->eCommandState) {
+	switch (priv->eCommandState) {
 	case WLAN_CMD_INIT_MAC80211_START:
-		if (pDevice->mac_hw)
+		if (priv->mac_hw)
 			break;
 
-		dev_info(&pDevice->usb->dev, "Starting mac80211\n");
+		dev_info(&priv->usb->dev, "Starting mac80211\n");
 
-		if (vnt_init(pDevice)) {
+		if (vnt_init(priv)) {
 			/* If fail all ends TODO retry */
-			dev_err(&pDevice->usb->dev, "failed to start\n");
-			ieee80211_free_hw(pDevice->hw);
+			dev_err(&priv->usb->dev, "failed to start\n");
+			ieee80211_free_hw(priv->hw);
 			return;
 		}
 
 		break;
 
 	case WLAN_CMD_TBTT_WAKEUP_START:
-		vnt_next_tbtt_wakeup(pDevice);
+		vnt_next_tbtt_wakeup(priv);
 		break;
 
 	case WLAN_CMD_BECON_SEND_START:
-		if (!pDevice->vif)
+		if (!priv->vif)
 			break;
 
-		vnt_beacon_make(pDevice, pDevice->vif);
+		vnt_beacon_make(priv, priv->vif);
 
-		vnt_mac_reg_bits_on(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
+		vnt_mac_reg_bits_on(priv, MAC_REG_TCR, TCR_AUTOBCNTX);
 
 		break;
 
 	case WLAN_CMD_SETPOWER_START:
 
-		vnt_rf_setpower(pDevice, pDevice->wCurrentRate,
-				pDevice->hw->conf.chandef.chan->hw_value);
+		vnt_rf_setpower(priv, priv->wCurrentRate,
+				priv->hw->conf.chandef.chan->hw_value);
 
 		break;
 
 	case WLAN_CMD_CHANGE_ANTENNA_START:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change from Antenna%d to", (int)pDevice->dwRxAntennaSel);
-		if (pDevice->dwRxAntennaSel == 0) {
-			pDevice->dwRxAntennaSel = 1;
-			if (pDevice->bTxRxAntInv == true)
-				BBvSetAntennaMode(pDevice, ANT_RXA);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO
+			"Change from Antenna%d to", (int)priv->dwRxAntennaSel);
+
+		if (priv->dwRxAntennaSel == 0) {
+			priv->dwRxAntennaSel = 1;
+			if (priv->bTxRxAntInv == true)
+				BBvSetAntennaMode(priv, ANT_RXA);
 			else
-				BBvSetAntennaMode(pDevice, ANT_RXB);
+				BBvSetAntennaMode(priv, ANT_RXB);
 		} else {
-			pDevice->dwRxAntennaSel = 0;
-			if (pDevice->bTxRxAntInv == true)
-				BBvSetAntennaMode(pDevice, ANT_RXB);
+			priv->dwRxAntennaSel = 0;
+			if (priv->bTxRxAntInv == true)
+				BBvSetAntennaMode(priv, ANT_RXB);
 			else
-				BBvSetAntennaMode(pDevice, ANT_RXA);
+				BBvSetAntennaMode(priv, ANT_RXA);
 		}
 		break;
 
 	case WLAN_CMD_11H_CHSW_START:
-		vnt_set_channel(pDevice, pDevice->hw->conf.chandef.chan->hw_value);
+		vnt_set_channel(priv, priv->hw->conf.chandef.chan->hw_value);
 		break;
 
 	default:
 		break;
 	} //switch
 
-	s_bCommandComplete(pDevice);
+	s_bCommandComplete(priv);
 
 	return;
 }

commit 43878a363b114424290d4c5fd1707fadb8335620
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Jul 12 07:53:41 2014 +0100

    staging: vt6656: wcmd remove unused commands
    
    WLAN_CMD_CHANGE_BBSENSITIVITY and WLAN_CMD_MAC_DISPOWERSAVING
    are already implemented and don't need the command timer.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 0b874868525b..50011937572a 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -63,7 +63,6 @@ void vRunCommand(struct work_struct *work)
 {
 	struct vnt_private *pDevice =
 		container_of(work, struct vnt_private, run_command_work.work);
-	u8 byData;
 
 	if (pDevice->Flags & fMP_DISCONNECTED)
 		return;
@@ -87,15 +86,6 @@ void vRunCommand(struct work_struct *work)
 
 		break;
 
-	case WLAN_CMD_CHANGE_BBSENSITIVITY_START:
-
-		pDevice->bStopDataPkt = true;
-		pDevice->byBBVGACurrent = pDevice->byBBVGANew;
-		BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change sensitivity pDevice->byBBVGACurrent = %x\n", pDevice->byBBVGACurrent);
-		pDevice->bStopDataPkt = false;
-		break;
-
 	case WLAN_CMD_TBTT_WAKEUP_START:
 		vnt_next_tbtt_wakeup(pDevice);
 		break;
@@ -134,26 +124,10 @@ void vRunCommand(struct work_struct *work)
 		}
 		break;
 
-	case WLAN_CMD_MAC_DISPOWERSAVING_START:
-		vnt_control_in_u8(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
-		if ((byData & PSCTL_PS) != 0) {
-			// disable power saving hw function
-			vnt_control_out(pDevice,
-					MESSAGE_TYPE_DISABLE_PS,
-					0,
-					0,
-					0,
-					NULL
-					);
-		}
-		break;
-
 	case WLAN_CMD_11H_CHSW_START:
 		vnt_set_channel(pDevice, pDevice->hw->conf.chandef.chan->hw_value);
 		break;
 
-	case WLAN_CMD_CONFIGURE_FILTER_START:
-		break;
 	default:
 		break;
 	} //switch
@@ -185,10 +159,6 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 			pDevice->eCommandState = WLAN_CMD_INIT_MAC80211_START;
 			break;
 
-		case WLAN_CMD_CHANGE_BBSENSITIVITY:
-			pDevice->eCommandState = WLAN_CMD_CHANGE_BBSENSITIVITY_START;
-			break;
-
 		case WLAN_CMD_TBTT_WAKEUP:
 			pDevice->eCommandState = WLAN_CMD_TBTT_WAKEUP_START;
 			break;
@@ -205,10 +175,6 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 			pDevice->eCommandState = WLAN_CMD_CHANGE_ANTENNA_START;
 			break;
 
-		case WLAN_CMD_MAC_DISPOWERSAVING:
-			pDevice->eCommandState = WLAN_CMD_MAC_DISPOWERSAVING_START;
-			break;
-
 		case WLAN_CMD_11H_CHSW:
 			pDevice->eCommandState = WLAN_CMD_11H_CHSW_START;
 			break;

commit c06b1ad093d7ab25e4618142f0a8d46509dd1fb0
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Jul 12 07:53:40 2014 +0100

    staging: vt6656: wcmd Remove command WLAN_CMD_RADIO
    
    Part of it has already been removed.  checking isr1 & ISR_GPIO3
    serves no purpose.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 2553cde8a16c..0b874868525b 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -185,10 +185,6 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 			pDevice->eCommandState = WLAN_CMD_INIT_MAC80211_START;
 			break;
 
-		case WLAN_CMD_RADIO:
-			pDevice->eCommandState = WLAN_CMD_RADIO_START;
-			pDevice->bRadioCmd = bRadioCmd;
-			break;
 		case WLAN_CMD_CHANGE_BBSENSITIVITY:
 			pDevice->eCommandState = WLAN_CMD_CHANGE_BBSENSITIVITY_START;
 			break;
@@ -234,16 +230,6 @@ int bScheduleCommand(struct vnt_private *pDevice,
 		return false;
 	pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].eCmd = eCommand;
 	pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = true;
-	if (pbyItem0 != NULL) {
-		switch (eCommand) {
-		case WLAN_CMD_RADIO:
-			pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bRadioCmd = *((int *)pbyItem0);
-			break;
-
-		default:
-			break;
-		}
-	}
 
 	ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdEnqueueIdx, CMD_Q_SIZE);
 	pDevice->cbFreeCmdQueue--;

commit e30546d6aa8f2032836a2f5ca98e0a4c467264d4
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Jul 12 07:53:39 2014 +0100

    staging: vt6656: vCommandTimerWait remove camel case.
    
    camel case changes
    pDevice -> priv
    MSecond -> msecs
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index b62726f29c53..2553cde8a16c 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -54,11 +54,9 @@ static int msglevel = MSG_LEVEL_INFO;
 
 static int s_bCommandComplete(struct vnt_private *);
 
-static void
-vCommandTimerWait(struct vnt_private *pDevice, unsigned long MSecond)
+static void vCommandTimerWait(struct vnt_private *priv, unsigned long msecs)
 {
-	schedule_delayed_work(&pDevice->run_command_work,
-						msecs_to_jiffies(MSecond));
+	schedule_delayed_work(&priv->run_command_work, msecs_to_jiffies(msecs));
 }
 
 void vRunCommand(struct work_struct *work)

commit a146d42d5abd10151f6759f0d4f9908c6499013c
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 25 21:20:07 2014 +0100

    staging: vt6656: dead code remove 80211hdr.h
    
    Remove all variables that are dead with this header
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 7c81034a790e..b62726f29c53 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -41,7 +41,6 @@
 #include "device.h"
 #include "mac.h"
 #include "card.h"
-#include "80211hdr.h"
 #include "wcmd.h"
 #include "power.h"
 #include "baseband.h"
@@ -237,7 +236,6 @@ int bScheduleCommand(struct vnt_private *pDevice,
 		return false;
 	pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].eCmd = eCommand;
 	pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = true;
-	memset(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID, 0 , WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
 	if (pbyItem0 != NULL) {
 		switch (eCommand) {
 		case WLAN_CMD_RADIO:

commit c4c9a92d26e46674c373fe1a1d8bc9c8a69861e5
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 25 21:20:05 2014 +0100

    staging: vt6656: dead code remove wmgr.h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index b190857da5a8..7c81034a790e 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -43,7 +43,6 @@
 #include "card.h"
 #include "80211hdr.h"
 #include "wcmd.h"
-#include "wmgr.h"
 #include "power.h"
 #include "baseband.h"
 #include "usbpipe.h"

commit ae9593ec37cda99ba65841ebefef110919b1f239
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 25 21:20:00 2014 +0100

    staging: vt6656: dead code remove tmacro.h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 106c4c4ce7f9..b190857da5a8 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -38,7 +38,6 @@
  *
  */
 
-#include "tmacro.h"
 #include "device.h"
 #include "mac.h"
 #include "card.h"

commit 93bf8a842a46bb321076a6fe4b68d0d7723ade1b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 25 21:19:59 2014 +0100

    staging: vt6656: dead code remove old key functions
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index d0632292afa0..106c4c4ce7f9 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -139,10 +139,6 @@ void vRunCommand(struct work_struct *work)
 		}
 		break;
 
-	case WLAN_CMD_REMOVE_ALLKEY_START:
-		KeybRemoveAllKey(pDevice, &(pDevice->sKey), pDevice->abyBSSID);
-		break;
-
 	case WLAN_CMD_MAC_DISPOWERSAVING_START:
 		vnt_control_in_u8(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
 		if ((byData & PSCTL_PS) != 0) {

commit e1aec72d99939069cb0f21fbd013f47c58824e5c
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 25 21:19:54 2014 +0100

    staging: vt6656: dead code remove iowpa.h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 00bed8cc4e37..d0632292afa0 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -51,7 +51,6 @@
 #include "rxtx.h"
 #include "rf.h"
 #include "channel.h"
-#include "iowpa.h"
 
 static int msglevel = MSG_LEVEL_INFO;
 //static int msglevel = MSG_LEVEL_DEBUG;

commit 03e77fe366f80bc545b46618c191600e99d8c2cb
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 25 21:19:50 2014 +0100

    staging: vt6656: dead code remove wctl
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index a777841b14e4..00bed8cc4e37 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -46,7 +46,6 @@
 #include "wcmd.h"
 #include "wmgr.h"
 #include "power.h"
-#include "wctl.h"
 #include "baseband.h"
 #include "usbpipe.h"
 #include "rxtx.h"

commit 169cd2e4702e6ea2eab659017b5806a7aa0887b1
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 25 21:19:43 2014 +0100

    staging: vt6656: wcmd remove dead code
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 4d7d5b14e7e5..a777841b14e4 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -57,207 +57,8 @@
 static int msglevel = MSG_LEVEL_INFO;
 //static int msglevel = MSG_LEVEL_DEBUG;
 
-static void s_vProbeChannel(struct vnt_private *);
-
-static struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *,
-	struct vnt_manager *pMgmt, u8 *pScanBSSID, PWLAN_IE_SSID pSSID,
-	PWLAN_IE_SUPP_RATES pCurrRates, PWLAN_IE_SUPP_RATES pCurrExtSuppRates);
-
 static int s_bCommandComplete(struct vnt_private *);
 
-static int s_bClearBSSID_SCAN(struct vnt_private *);
-
-/*
- * Description:
- *      Stop AdHoc beacon during scan process
- *
- * Parameters:
- *  In:
- *      pDevice     - Pointer to the adapter
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-
-static void vAdHocBeaconStop(struct vnt_private *pDevice)
-{
-	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
-	int bStop;
-
-	/*
-	 * temporarily stop Beacon packet for AdHoc Server
-	 * if all of the following coditions are met:
-	 *  (1) STA is in AdHoc mode
-	 *  (2) VT3253 is programmed as automatic Beacon Transmitting
-	 *  (3) One of the following conditions is met
-	 *      (3.1) AdHoc channel is in B/G band and the
-	 *      current scan channel is in A band
-	 *      or
-	 *      (3.2) AdHoc channel is in A mode
-	 */
-	bStop = false;
-	if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
-	    (pMgmt->eCurrState >= WMAC_STATE_STARTED)) {
-		if ((pMgmt->uIBSSChannel <=  CB_MAX_CHANNEL_24G) &&
-		    (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G)) {
-			bStop = true;
-		}
-		if (pMgmt->uIBSSChannel >  CB_MAX_CHANNEL_24G)
-			bStop = true;
-	}
-
-	if (bStop) {
-		//PMESG(("STOP_BEACON: IBSSChannel = %u, ScanChannel = %u\n",
-		//        pMgmt->uIBSSChannel, pMgmt->uScanChannel));
-		vnt_mac_reg_bits_off(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
-	}
-
-} /* vAdHocBeaconStop */
-
-/*
- * Description:
- *      Restart AdHoc beacon after scan process complete
- *
- * Parameters:
- *  In:
- *      pDevice     - Pointer to the adapter
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-static void vAdHocBeaconRestart(struct vnt_private *pDevice)
-{
-	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
-
-    /*
-     * Restart Beacon packet for AdHoc Server
-     * if all of the following coditions are met:
-     *  (1) STA is in AdHoc mode
-     *  (2) VT3253 is programmed as automatic Beacon Transmitting
-     */
-	if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
-	    (pMgmt->eCurrState >= WMAC_STATE_STARTED)) {
-		//PMESG(("RESTART_BEACON\n"));
-		vnt_mac_reg_bits_on(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
-	}
-
-}
-
-/*+
- *
- * Routine Description:
- *   Prepare and send probe request management frames.
- *
- *
- * Return Value:
- *    none.
- *
--*/
-
-static void s_vProbeChannel(struct vnt_private *pDevice)
-{
-	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
-	struct vnt_tx_mgmt *pTxPacket;
-	u8 abyCurrSuppRatesG[] = {WLAN_EID_SUPP_RATES,
-			8, 0x02, 0x04, 0x0B, 0x16, 0x24, 0x30, 0x48, 0x6C};
-			/* 1M,   2M,   5M,   11M,  18M,  24M,  36M,  54M*/
-	u8 abyCurrExtSuppRatesG[] = {WLAN_EID_EXTSUPP_RATES,
-			4, 0x0C, 0x12, 0x18, 0x60};
-			/* 6M,   9M,   12M,  48M*/
-	u8 abyCurrSuppRatesA[] = {WLAN_EID_SUPP_RATES,
-			8, 0x0C, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6C};
-	u8 abyCurrSuppRatesB[] = {WLAN_EID_SUPP_RATES,
-			4, 0x02, 0x04, 0x0B, 0x16};
-	u8 *pbyRate;
-	int ii;
-
-	if (pDevice->byBBType == BB_TYPE_11A)
-		pbyRate = &abyCurrSuppRatesA[0];
-	else if (pDevice->byBBType == BB_TYPE_11B)
-		pbyRate = &abyCurrSuppRatesB[0];
-	else
-		pbyRate = &abyCurrSuppRatesG[0];
-
-	// build an assocreq frame and send it
-	pTxPacket = s_MgrMakeProbeRequest
-		    (
-		     pDevice,
-		     pMgmt,
-		     pMgmt->abyScanBSSID,
-		     (PWLAN_IE_SSID)pMgmt->abyScanSSID,
-		     (PWLAN_IE_SUPP_RATES)pbyRate,
-		     (PWLAN_IE_SUPP_RATES)abyCurrExtSuppRatesG
-		     );
-
-	if (pTxPacket != NULL) {
-		for (ii = 0; ii < 1; ii++) {
-			if (csMgmt_xmit(pDevice, pTxPacket) != CMD_STATUS_PENDING) {
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request sending fail..\n");
-			} else {
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request is sending..\n");
-			}
-		}
-	}
-
-}
-
-/*+
- *
- * Routine Description:
- *  Constructs an probe request frame
- *
- *
- * Return Value:
- *    A ptr to Tx frame or NULL on allocation failure
- *
--*/
-
-static struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *pDevice,
-	struct vnt_manager *pMgmt, u8 *pScanBSSID, PWLAN_IE_SSID pSSID,
-	PWLAN_IE_SUPP_RATES pCurrRates, PWLAN_IE_SUPP_RATES pCurrExtSuppRates)
-{
-	struct vnt_tx_mgmt *pTxPacket = NULL;
-	WLAN_FR_PROBEREQ sFrame;
-
-	pTxPacket = (struct vnt_tx_mgmt *)pMgmt->pbyMgmtPacketPool;
-	memset(pTxPacket, 0, sizeof(struct vnt_tx_mgmt)
-		+ WLAN_PROBEREQ_FR_MAXLEN);
-	pTxPacket->p80211Header = (PUWLAN_80211HDR)((u8 *)pTxPacket
-		+ sizeof(struct vnt_tx_mgmt));
-	sFrame.pBuf = (u8 *)pTxPacket->p80211Header;
-	sFrame.len = WLAN_PROBEREQ_FR_MAXLEN;
-	vMgrEncodeProbeRequest(&sFrame);
-	sFrame.pHdr->sA3.wFrameCtl = cpu_to_le16(
-		(
-		 WLAN_SET_FC_FTYPE(WLAN_TYPE_MGR) |
-		 WLAN_SET_FC_FSTYPE(WLAN_FSTYPE_PROBEREQ)
-		 ));
-	memcpy(sFrame.pHdr->sA3.abyAddr1, pScanBSSID, WLAN_ADDR_LEN);
-	memcpy(sFrame.pHdr->sA3.abyAddr2, pMgmt->abyMACAddr, WLAN_ADDR_LEN);
-	memcpy(sFrame.pHdr->sA3.abyAddr3, pScanBSSID, WLAN_BSSID_LEN);
-	// Copy the SSID, pSSID->len=0 indicate broadcast SSID
-	sFrame.pSSID = (PWLAN_IE_SSID)(sFrame.pBuf + sFrame.len);
-	sFrame.len += pSSID->len + WLAN_IEHDR_LEN;
-	memcpy(sFrame.pSSID, pSSID, pSSID->len + WLAN_IEHDR_LEN);
-	sFrame.pSuppRates = (PWLAN_IE_SUPP_RATES)(sFrame.pBuf + sFrame.len);
-	sFrame.len += pCurrRates->len + WLAN_IEHDR_LEN;
-	memcpy(sFrame.pSuppRates, pCurrRates, pCurrRates->len + WLAN_IEHDR_LEN);
-	// Copy the extension rate set
-	if (pDevice->byBBType == BB_TYPE_11G) {
-		sFrame.pExtSuppRates = (PWLAN_IE_SUPP_RATES)(sFrame.pBuf + sFrame.len);
-		sFrame.len += pCurrExtSuppRates->len + WLAN_IEHDR_LEN;
-		memcpy(sFrame.pExtSuppRates, pCurrExtSuppRates, pCurrExtSuppRates->len + WLAN_IEHDR_LEN);
-	}
-	pTxPacket->cbMPDULen = sFrame.len;
-	pTxPacket->cbPayloadLen = sFrame.len - WLAN_HDR_ADDR3_LEN;
-
-	return pTxPacket;
-}
-
 static void
 vCommandTimerWait(struct vnt_private *pDevice, unsigned long MSecond)
 {
@@ -269,16 +70,7 @@ void vRunCommand(struct work_struct *work)
 {
 	struct vnt_private *pDevice =
 		container_of(work, struct vnt_private, run_command_work.work);
-	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
-	PWLAN_IE_SSID pItemSSID;
-	PWLAN_IE_SSID pItemSSIDCurr;
-	CMD_STATUS Status;
-	struct sk_buff  *skb;
-	union iwreq_data wrqu;
-	int ii;
-	u8 byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
 	u8 byData;
-	unsigned long flags;
 
 	if (pDevice->Flags & fMP_DISCONNECTED)
 		return;
@@ -300,533 +92,6 @@ void vRunCommand(struct work_struct *work)
 			return;
 		}
 
-		break;
-	case WLAN_CMD_SCAN_START:
-
-		pDevice->byReAssocCount = 0;
-		if (pDevice->bRadioOff == true)
-			break;
-
-		if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP)
-			break;
-
-		pItemSSID = (PWLAN_IE_SSID)pMgmt->abyScanSSID;
-
-		if (pMgmt->uScanChannel == 0)
-			pMgmt->uScanChannel = pDevice->byMinChannel;
-		if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
-			pDevice->eCommandState = WLAN_CMD_SCAN_END;
-			break;
-		} else {
-			if (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel)) {
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Invalid channel pMgmt->uScanChannel = %d\n", pMgmt->uScanChannel);
-				pMgmt->uScanChannel++;
-				break;
-			}
-			if (pMgmt->uScanChannel == pDevice->byMinChannel) {
-				// pMgmt->eScanType = WMAC_SCAN_ACTIVE;          //mike mark
-				pMgmt->abyScanBSSID[0] = 0xFF;
-				pMgmt->abyScanBSSID[1] = 0xFF;
-				pMgmt->abyScanBSSID[2] = 0xFF;
-				pMgmt->abyScanBSSID[3] = 0xFF;
-				pMgmt->abyScanBSSID[4] = 0xFF;
-				pMgmt->abyScanBSSID[5] = 0xFF;
-				pItemSSID->byElementID = WLAN_EID_SSID;
-				// clear bssid list
-				/* BSSvClearBSSList((void *) pDevice, pDevice->bLinkPass); */
-				pMgmt->eScanState = WMAC_IS_SCANNING;
-				pDevice->byScanBBType = pDevice->byBBType;  //lucas
-				pDevice->bStopDataPkt = true;
-				// Turn off RCR_BSSID filter every time
-				vnt_mac_reg_bits_off(pDevice, MAC_REG_RCR, RCR_BSSID);
-				pDevice->byRxMode &= ~RCR_BSSID;
-			}
-			//lucas
-			vAdHocBeaconStop(pDevice);
-			if ((pDevice->byBBType != BB_TYPE_11A) &&
-			    (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G)) {
-				pDevice->byBBType = BB_TYPE_11A;
-				vnt_set_bss_mode(pDevice);
-			} else if ((pDevice->byBBType == BB_TYPE_11A) &&
-				   (pMgmt->uScanChannel <= CB_MAX_CHANNEL_24G)) {
-				pDevice->byBBType = BB_TYPE_11G;
-				vnt_set_bss_mode(pDevice);
-			}
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning....  channel: [%d]\n", pMgmt->uScanChannel);
-			// Set channel
-			vnt_set_channel(pDevice, pMgmt->uScanChannel);
-			// Set Baseband to be more sensitive.
-
-			BBvSetShortSlotTime(pDevice);
-			BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
-			BBvUpdatePreEDThreshold(pDevice, true);
-
-			pMgmt->uScanChannel++;
-
-			while (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel) &&
-				pMgmt->uScanChannel <= pDevice->byMaxChannel){
-				pMgmt->uScanChannel++;
-			}
-
-			if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
-				// Set Baseband to be not sensitive and rescan
-				pDevice->eCommandState = WLAN_CMD_SCAN_END;
-			}
-			if ((pMgmt->b11hEnable == false) ||
-			    (pMgmt->uScanChannel < CB_MAX_CHANNEL_24G)) {
-				s_vProbeChannel(pDevice);
-				vCommandTimerWait((void *) pDevice, 100);
-				return;
-			} else {
-				vCommandTimerWait((void *) pDevice, WCMD_PASSIVE_SCAN_TIME);
-				return;
-			}
-		}
-
-		break;
-
-	case WLAN_CMD_SCAN_END:
-
-		// Set Baseband's sensitivity back.
-		if (pDevice->byBBType != pDevice->byScanBBType) {
-			pDevice->byBBType = pDevice->byScanBBType;
-			vnt_set_bss_mode(pDevice);
-		}
-
-		BBvSetShortSlotTime(pDevice);
-		BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
-		BBvUpdatePreEDThreshold(pDevice, false);
-
-		// Set channel back
-		vAdHocBeaconRestart(pDevice);
-		// Set channel back
-		vnt_set_channel(pDevice, pMgmt->uCurrChannel);
-		// Set Filter
-		if (pMgmt->bCurrBSSIDFilterOn) {
-			vnt_mac_reg_bits_on(pDevice, MAC_REG_RCR, RCR_BSSID);
-			pDevice->byRxMode |= RCR_BSSID;
-		}
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning, set back to channel: [%d]\n", pMgmt->uCurrChannel);
-		pMgmt->uScanChannel = 0;
-		pMgmt->eScanState = WMAC_NO_SCANNING;
-		pDevice->bStopDataPkt = false;
-
-		/*send scan event to wpa_Supplicant*/
-		PRINT_K("wireless_send_event--->SIOCGIWSCAN(scan done)\n");
-		memset(&wrqu, 0, sizeof(wrqu));
-		wireless_send_event(pDevice->dev, SIOCGIWSCAN, &wrqu, NULL);
-
-		break;
-
-	case WLAN_CMD_DISASSOCIATE_START:
-		pDevice->byReAssocCount = 0;
-		if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
-		    (pMgmt->eCurrState != WMAC_STATE_ASSOC)) {
-			break;
-		} else {
-			pDevice->bwextstep0 = false;
-			pDevice->bwextstep1 = false;
-			pDevice->bwextstep2 = false;
-			pDevice->bwextstep3 = false;
-			pDevice->bWPASuppWextEnabled = false;
-			pDevice->fWPA_Authened = false;
-
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Send Disassociation Packet..\n");
-			// reason = 8 : disassoc because sta has left
-			vMgrDisassocBeginSta((void *) pDevice,
-					     pMgmt,
-					     pMgmt->abyCurrBSSID,
-					     (8),
-					     &Status);
-			pDevice->bLinkPass = false;
-
-			vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_SLOW);
-
-			// unlock command busy
-			pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
-			pItemSSID->len = 0;
-			memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
-			pMgmt->eCurrState = WMAC_STATE_IDLE;
-			pMgmt->sNodeDBTable[0].bActive = false;
-//			pDevice->bBeaconBufReady = false;
-		}
-		netif_stop_queue(pDevice->dev);
-		if (pDevice->bNeedRadioOFF == true)
-			vnt_radio_power_off(pDevice);
-
-		break;
-
-	case WLAN_CMD_SSID_START:
-
-		pDevice->byReAssocCount = 0;
-		if (pDevice->bRadioOff == true)
-			break;
-
-		memcpy(pMgmt->abyAdHocSSID, pMgmt->abyDesireSSID,
-		       ((PWLAN_IE_SSID)pMgmt->abyDesireSSID)->len + WLAN_IEHDR_LEN);
-
-		pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
-		pItemSSIDCurr = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" cmd: desire ssid = %s\n", pItemSSID->abySSID);
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" cmd: curr ssid = %s\n", pItemSSIDCurr->abySSID);
-
-		if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Cmd pMgmt->eCurrState == WMAC_STATE_ASSOC\n");
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pItemSSID->len =%d\n", pItemSSID->len);
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pItemSSIDCurr->len = %d\n", pItemSSIDCurr->len);
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" desire ssid = %s\n", pItemSSID->abySSID);
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" curr ssid = %s\n", pItemSSIDCurr->abySSID);
-		}
-
-		if ((pMgmt->eCurrState == WMAC_STATE_ASSOC) ||
-		    ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED))) {
-			if (pItemSSID->len == pItemSSIDCurr->len) {
-				if (!memcmp(pItemSSID->abySSID,
-					pItemSSIDCurr->abySSID, pItemSSID->len))
-					break;
-			}
-			netif_stop_queue(pDevice->dev);
-			pDevice->bLinkPass = false;
-
-			vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_SLOW);
-		}
-		// set initial state
-		pMgmt->eCurrState = WMAC_STATE_IDLE;
-		pMgmt->eCurrMode = WMAC_MODE_STANDBY;
-		vnt_disable_power_saving(pDevice);
-		BSSvClearNodeDBTable(pDevice, 0);
-		vMgrJoinBSSBegin((void *) pDevice, &Status);
-		// if Infra mode
-		if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED)) {
-			// Call mgr to begin the deauthentication
-			// reason = (3) because sta has left ESS
-			if (pMgmt->eCurrState >= WMAC_STATE_AUTH) {
-				vMgrDeAuthenBeginSta((void *)pDevice,
-						     pMgmt,
-						     pMgmt->abyCurrBSSID,
-						     (3),
-						     &Status);
-			}
-			// Call mgr to begin the authentication
-			vMgrAuthenBeginSta((void *) pDevice, pMgmt, &Status);
-			if (Status == CMD_STATUS_SUCCESS) {
-				pDevice->byLinkWaitCount = 0;
-				pDevice->eCommandState = WLAN_AUTHENTICATE_WAIT;
-				vCommandTimerWait((void *) pDevice, AUTHENTICATE_TIMEOUT);
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Set eCommandState = WLAN_AUTHENTICATE_WAIT\n");
-				return;
-			}
-		}
-		// if Adhoc mode
-		else if (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
-			if (pMgmt->eCurrState == WMAC_STATE_JOINTED) {
-				if (netif_queue_stopped(pDevice->dev))
-					netif_wake_queue(pDevice->dev);
-				pDevice->bLinkPass = true;
-
-				vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_INTER);
-
-				pMgmt->sNodeDBTable[0].bActive = true;
-				pMgmt->sNodeDBTable[0].uInActiveCount = 0;
-			} else {
-				// start own IBSS
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "CreateOwn IBSS by CurrMode = IBSS_STA\n");
-				vMgrCreateOwnIBSS((void *) pDevice, &Status);
-				if (Status != CMD_STATUS_SUCCESS) {
-					DBG_PRT(MSG_LEVEL_DEBUG,
-						KERN_INFO "WLAN_CMD_IBSS_CREATE fail!\n");
-				}
-				BSSvAddMulticastNode(pDevice);
-			}
-			s_bClearBSSID_SCAN(pDevice);
-		}
-		// if SSID not found
-		else if (pMgmt->eCurrMode == WMAC_MODE_STANDBY) {
-			if (pMgmt->eConfigMode == WMAC_CONFIG_IBSS_STA ||
-			    pMgmt->eConfigMode == WMAC_CONFIG_AUTO) {
-				// start own IBSS
-				DBG_PRT(MSG_LEVEL_DEBUG,
-					KERN_INFO "CreateOwn IBSS by CurrMode = STANDBY\n");
-				vMgrCreateOwnIBSS((void *) pDevice, &Status);
-				if (Status != CMD_STATUS_SUCCESS) {
-					DBG_PRT(MSG_LEVEL_DEBUG,
-						KERN_INFO "WLAN_CMD_IBSS_CREATE fail!\n");
-				}
-				BSSvAddMulticastNode(pDevice);
-				s_bClearBSSID_SCAN(pDevice);
-/*
-				pDevice->bLinkPass = true;
-				if (netif_queue_stopped(pDevice->dev)){
-					netif_wake_queue(pDevice->dev);
-				}
-				s_bClearBSSID_SCAN(pDevice);
-*/
-			} else {
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Disconnect SSID none\n");
-				// if(pDevice->bWPASuppWextEnabled == true)
-				{
-					union iwreq_data  wrqu;
-					memset(&wrqu, 0, sizeof(wrqu));
-					wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-					PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated:vMgrJoinBSSBegin Fail !!)\n");
-					wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
-				}
-			}
-		}
-		break;
-
-	case WLAN_AUTHENTICATE_WAIT:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_AUTHENTICATE_WAIT\n");
-		if (pMgmt->eCurrState == WMAC_STATE_AUTH) {
-			pDevice->byLinkWaitCount = 0;
-			// Call mgr to begin the association
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_AUTH\n");
-			vMgrAssocBeginSta((void *) pDevice, pMgmt, &Status);
-			if (Status == CMD_STATUS_SUCCESS) {
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState = WLAN_ASSOCIATE_WAIT\n");
-				pDevice->byLinkWaitCount = 0;
-				pDevice->eCommandState = WLAN_ASSOCIATE_WAIT;
-				vCommandTimerWait((void *) pDevice, ASSOCIATE_TIMEOUT);
-				return;
-			}
-		} else if (pMgmt->eCurrState < WMAC_STATE_AUTHPENDING) {
-			printk("WLAN_AUTHENTICATE_WAIT:Authen Fail???\n");
-		} else if (pDevice->byLinkWaitCount <= 4) {
-			//mike add:wait another 2 sec if authenticated_frame delay!
-			pDevice->byLinkWaitCount++;
-			printk("WLAN_AUTHENTICATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
-			vCommandTimerWait((void *) pDevice, AUTHENTICATE_TIMEOUT/2);
-			return;
-		}
-		pDevice->byLinkWaitCount = 0;
-
-		break;
-
-	case WLAN_ASSOCIATE_WAIT:
-		if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_ASSOC\n");
-			if (pDevice->ePSMode != WMAC_POWER_CAM) {
-				vnt_enable_power_saving(pDevice,
-						pMgmt->wListenInterval);
-			}
-/*
-			if (pMgmt->eAuthenMode >= WMAC_AUTH_WPA) {
-				KeybRemoveAllKey(pDevice, &(pDevice->sKey), pDevice->abyBSSID);
-			}
-*/
-			pDevice->byLinkWaitCount = 0;
-			pDevice->byReAssocCount = 0;
-			pDevice->bLinkPass = true;
-
-			vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_INTER);
-
-			s_bClearBSSID_SCAN(pDevice);
-
-			if (netif_queue_stopped(pDevice->dev))
-				netif_wake_queue(pDevice->dev);
-
-		} else if (pMgmt->eCurrState < WMAC_STATE_ASSOCPENDING) {
-			printk("WLAN_ASSOCIATE_WAIT:Association Fail???\n");
-		} else if (pDevice->byLinkWaitCount <= 4) {
-			//mike add:wait another 2 sec if associated_frame delay!
-			pDevice->byLinkWaitCount++;
-			printk("WLAN_ASSOCIATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
-			vCommandTimerWait((void *) pDevice, ASSOCIATE_TIMEOUT/2);
-			return;
-		}
-
-		break;
-
-	case WLAN_CMD_AP_MODE_START:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_AP_MODE_START\n");
-
-		if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-			cancel_delayed_work_sync(&pDevice->second_callback_work);
-			pMgmt->eCurrState = WMAC_STATE_IDLE;
-			pMgmt->eCurrMode = WMAC_MODE_STANDBY;
-			pDevice->bLinkPass = false;
-
-			vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_SLOW);
-
-			BSSvClearNodeDBTable(pDevice, 0);
-
-			pDevice->uAssocCount = 0;
-			pMgmt->eCurrState = WMAC_STATE_IDLE;
-			pDevice->bFixRate = false;
-
-			vMgrCreateOwnIBSS((void *) pDevice, &Status);
-			if (Status != CMD_STATUS_SUCCESS) {
-				DBG_PRT(MSG_LEVEL_DEBUG,
-					KERN_INFO "vMgrCreateOwnIBSS fail!\n");
-			}
-			// always turn off unicast bit
-			vnt_mac_reg_bits_off(pDevice, MAC_REG_RCR, RCR_UNICAST);
-			pDevice->byRxMode &= ~RCR_UNICAST;
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wcmd: rx_mode = %x\n", pDevice->byRxMode);
-			BSSvAddMulticastNode(pDevice);
-			if (netif_queue_stopped(pDevice->dev))
-				netif_wake_queue(pDevice->dev);
-			pDevice->bLinkPass = true;
-
-			vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_INTER);
-
-			schedule_delayed_work(&pDevice->second_callback_work, HZ);
-		}
-		break;
-
-	case WLAN_CMD_TX_PSPACKET_START:
-		// DTIM Multicast tx
-		if (pMgmt->sNodeDBTable[0].bRxPSPoll) {
-			while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[0].sTxPSQueue)) != NULL) {
-				if (skb_queue_empty(&pMgmt->sNodeDBTable[0].sTxPSQueue)) {
-					pMgmt->abyPSTxMap[0] &= ~byMask[0];
-					pDevice->bMoreData = false;
-				} else {
-					pDevice->bMoreData = true;
-				}
-
-				spin_lock_irqsave(&pDevice->lock, flags);
-
-				if (nsDMA_tx_packet(pDevice, skb) != 0)
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Multicast ps tx fail\n");
-
-				spin_unlock_irqrestore(&pDevice->lock, flags);
-
-				pMgmt->sNodeDBTable[0].wEnQueueCnt--;
-			}
-		}
-
-		// PS nodes tx
-		for (ii = 1; ii < (MAX_NODE_NUM + 1); ii++) {
-			if (pMgmt->sNodeDBTable[ii].bActive &&
-			    pMgmt->sNodeDBTable[ii].bRxPSPoll) {
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Index=%d Enqueu Cnt= %d\n",
-						ii, pMgmt->sNodeDBTable[ii].wEnQueueCnt);
-				while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) != NULL) {
-					if (skb_queue_empty(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) {
-						// clear tx map
-						pMgmt->abyPSTxMap[pMgmt->sNodeDBTable[ii].wAID >> 3] &=
-									~byMask[pMgmt->sNodeDBTable[ii].wAID & 7];
-						pDevice->bMoreData = false;
-					} else {
-						pDevice->bMoreData = true;
-					}
-
-					spin_lock_irqsave(&pDevice->lock, flags);
-
-					if (nsDMA_tx_packet(pDevice, skb) != 0)
-						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "sta ps tx fail\n");
-
-					spin_unlock_irqrestore(&pDevice->lock, flags);
-
-					pMgmt->sNodeDBTable[ii].wEnQueueCnt--;
-					// check if sta ps enable, wait next pspoll
-					// if sta ps disable, send all pending buffers.
-					if (pMgmt->sNodeDBTable[ii].bPSEnable)
-						break;
-				}
-				if (skb_queue_empty(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) {
-					// clear tx map
-					pMgmt->abyPSTxMap[pMgmt->sNodeDBTable[ii].wAID >> 3] &=
-							~byMask[pMgmt->sNodeDBTable[ii].wAID & 7];
-					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Index=%d PS queue clear\n", ii);
-				}
-				pMgmt->sNodeDBTable[ii].bRxPSPoll = false;
-			}
-		}
-		break;
-
-	case WLAN_CMD_RADIO_START:
-
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_RADIO_START\n");
-//		if (pDevice->bRadioCmd == true)
-//			CARDbRadioPowerOn(pDevice);
-//		else
-//			CARDbRadioPowerOff(pDevice);
-		{
-			int ntStatus = STATUS_SUCCESS;
-			u8            byTmp;
-
-			ntStatus = vnt_control_in(pDevice,
-					MESSAGE_TYPE_READ,
-					MAC_REG_GPIOCTL1,
-					MESSAGE_REQUEST_MACREG,
-					1,
-					&byTmp);
-
-			if (ntStatus != STATUS_SUCCESS)
-				break;
-			if ((byTmp & GPIO3_DATA) == 0) {
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_OFF........................\n");
-				// Old commands are useless.
-				// empty command Q
-				pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
-				pDevice->uCmdDequeueIdx = 0;
-				pDevice->uCmdEnqueueIdx = 0;
-				//0415pDevice->bCmdRunning = false;
-				pDevice->bCmdClear = true;
-				pDevice->bStopTx0Pkt = false;
-				pDevice->bStopDataPkt = true;
-
-				pDevice->byKeyIndex = 0;
-				pDevice->bTransmitKey = false;
-
-				KeyvInitTable(pDevice, &pDevice->sKey);
-
-				pMgmt->byCSSPK = KEY_CTL_NONE;
-				pMgmt->byCSSGK = KEY_CTL_NONE;
-
-				if (pDevice->bLinkPass == true) {
-					// reason = 8 : disassoc because sta has left
-					vMgrDisassocBeginSta((void *) pDevice,
-							pMgmt,
-							pMgmt->abyCurrBSSID,
-							(8),
-							&Status);
-					pDevice->bLinkPass = false;
-					// unlock command busy
-					pMgmt->eCurrState = WMAC_STATE_IDLE;
-					pMgmt->sNodeDBTable[0].bActive = false;
-					// if(pDevice->bWPASuppWextEnabled == true)
-					{
-						union iwreq_data  wrqu;
-						memset(&wrqu, 0, sizeof(wrqu));
-						wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-						PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated)\n");
-						wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
-					}
-				}
-				pDevice->bwextstep0 = false;
-				pDevice->bwextstep1 = false;
-				pDevice->bwextstep2 = false;
-				pDevice->bwextstep3 = false;
-				pDevice->bWPASuppWextEnabled = false;
-				//clear current SSID
-				pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
-				pItemSSID->len = 0;
-				memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
-				//clear desired SSID
-				pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
-				pItemSSID->len = 0;
-				memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
-
-				netif_stop_queue(pDevice->dev);
-				vnt_radio_power_off(pDevice);
-				vnt_mac_reg_bits_on(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
-
-				vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_OFF);
-
-				pDevice->bHWRadioOff = true;
-			} else {
-				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_ON........................\n");
-				pDevice->bHWRadioOff = false;
-				vnt_radio_power_on(pDevice);
-				vnt_mac_reg_bits_off(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
-
-				vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_ON);
-			}
-		}
-
 		break;
 
 	case WLAN_CMD_CHANGE_BBSENSITIVITY_START:
@@ -911,8 +176,6 @@ void vRunCommand(struct work_struct *work)
 
 static int s_bCommandComplete(struct vnt_private *pDevice)
 {
-	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
-	PWLAN_IE_SSID pSSID;
 	int bRadioCmd = false;
 	int bForceSCAN = true;
 
@@ -923,7 +186,6 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 		return true;
 	} else {
 		pDevice->eCommand = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].eCmd;
-		pSSID = (PWLAN_IE_SSID)pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].abyCmdDesireSSID;
 		bRadioCmd = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].bRadioCmd;
 		bForceSCAN = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].bForceSCAN;
 		ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdDequeueIdx, CMD_Q_SIZE);
@@ -934,40 +196,6 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 			pDevice->eCommandState = WLAN_CMD_INIT_MAC80211_START;
 			break;
 
-		case WLAN_CMD_BSSID_SCAN:
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_BSSID_SCAN\n");
-			pDevice->eCommandState = WLAN_CMD_SCAN_START;
-			pMgmt->uScanChannel = 0;
-			if (pSSID->len != 0)
-				memcpy(pMgmt->abyScanSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-			else
-				memset(pMgmt->abyScanSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-/*
-			if ((bForceSCAN == false) && (pDevice->bLinkPass == true)) {
-				if ((pSSID->len == ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->len) &&
-				    ( !memcmp(pSSID->abySSID, ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->abySSID, pSSID->len))) {
-					pDevice->eCommandState = WLAN_CMD_IDLE;
-				}
-			}
-*/
-			break;
-		case WLAN_CMD_SSID:
-			pDevice->eCommandState = WLAN_CMD_SSID_START;
-			if (pSSID->len > WLAN_SSID_MAXLEN)
-				pSSID->len = WLAN_SSID_MAXLEN;
-			if (pSSID->len != 0)
-				memcpy(pMgmt->abyDesireSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_SSID_START\n");
-			break;
-		case WLAN_CMD_DISASSOCIATE:
-			pDevice->eCommandState = WLAN_CMD_DISASSOCIATE_START;
-			break;
-		case WLAN_CMD_RX_PSPOLL:
-			pDevice->eCommandState = WLAN_CMD_TX_PSPACKET_START;
-			break;
-		case WLAN_CMD_RUN_AP:
-			pDevice->eCommandState = WLAN_CMD_AP_MODE_START;
-			break;
 		case WLAN_CMD_RADIO:
 			pDevice->eCommandState = WLAN_CMD_RADIO_START;
 			pDevice->bRadioCmd = bRadioCmd;
@@ -992,10 +220,6 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 			pDevice->eCommandState = WLAN_CMD_CHANGE_ANTENNA_START;
 			break;
 
-		case WLAN_CMD_REMOVE_ALLKEY:
-			pDevice->eCommandState = WLAN_CMD_REMOVE_ALLKEY_START;
-			break;
-
 		case WLAN_CMD_MAC_DISPOWERSAVING:
 			pDevice->eCommandState = WLAN_CMD_MAC_DISPOWERSAVING_START;
 			break;
@@ -1004,11 +228,6 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 			pDevice->eCommandState = WLAN_CMD_11H_CHSW_START;
 			break;
 
-		case WLAN_CMD_CONFIGURE_FILTER:
-			pDevice->eCommandState =
-						WLAN_CMD_CONFIGURE_FILTER_START;
-			break;
-
 		default:
 			break;
 		}
@@ -1029,26 +248,6 @@ int bScheduleCommand(struct vnt_private *pDevice,
 	memset(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID, 0 , WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
 	if (pbyItem0 != NULL) {
 		switch (eCommand) {
-		case WLAN_CMD_BSSID_SCAN:
-			pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = false;
-			memcpy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
-				pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-			break;
-
-		case WLAN_CMD_SSID:
-			memcpy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
-				pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-			break;
-
-		case WLAN_CMD_DISASSOCIATE:
-			pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bNeedRadioOFF = *((int *)pbyItem0);
-			break;
-/*
-		case WLAN_CMD_DEAUTH:
-			pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].wDeAuthenReason = *((u16 *)pbyItem0);
-			break;
-*/
-
 		case WLAN_CMD_RADIO:
 			pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bRadioCmd = *((int *)pbyItem0);
 			break;
@@ -1068,38 +267,6 @@ int bScheduleCommand(struct vnt_private *pDevice,
 
 }
 
-/*
- * Description:
- *      Clear BSSID_SCAN cmd in CMD Queue
- *
- * Parameters:
- *  In:
- *      hDeviceContext  - Pointer to the adapter
- *      eCommand        - Command
- *  Out:
- *      none
- *
- * Return Value: true if success; otherwise false
- *
- */
-static int s_bClearBSSID_SCAN(struct vnt_private *pDevice)
-{
-	unsigned int uCmdDequeueIdx = pDevice->uCmdDequeueIdx;
-	unsigned int ii;
-
-	if ((pDevice->cbFreeCmdQueue < CMD_Q_SIZE) && (uCmdDequeueIdx != pDevice->uCmdEnqueueIdx)) {
-		for (ii = 0; ii < (CMD_Q_SIZE - pDevice->cbFreeCmdQueue); ii++) {
-			if (pDevice->eCmdQueue[uCmdDequeueIdx].eCmd == WLAN_CMD_BSSID_SCAN)
-				pDevice->eCmdQueue[uCmdDequeueIdx].eCmd = WLAN_CMD_IDLE;
-			ADD_ONE_WITH_WRAP_AROUND(uCmdDequeueIdx, CMD_Q_SIZE);
-			if (uCmdDequeueIdx == pDevice->uCmdEnqueueIdx)
-				break;
-		}
-	}
-	return true;
-}
-
-//mike add:reset command timer
 void vResetCommandTimer(struct vnt_private *pDevice)
 {
 	pDevice->cbFreeCmdQueue = CMD_Q_SIZE;

commit 2f8da5f40d2330a64754a8a58ef53eabe3a8bcc5
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 25 21:19:41 2014 +0100

    staging: vt6656: main_usb removed dead code
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 81a6683f3b58..4d7d5b14e7e5 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -899,7 +899,6 @@ void vRunCommand(struct work_struct *work)
 		break;
 
 	case WLAN_CMD_CONFIGURE_FILTER_START:
-		vnt_configure_filter(pDevice);
 		break;
 	default:
 		break;

commit 63e754d407949a7b80ce4398b7c66e3d2edd2990
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 25 21:14:33 2014 +0100

    staging: vt6656: mac80211 conversion: vRunCommand channel changes
    
    pDevice->hw->conf.chandef.chan->hw_value to find current channel
    
    Remove bChannelSwitch, uCurrChannel, byNewChannel and bStopDataPkt
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 3095689094fe..81a6683f3b58 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -855,7 +855,7 @@ void vRunCommand(struct work_struct *work)
 	case WLAN_CMD_SETPOWER_START:
 
 		vnt_rf_setpower(pDevice, pDevice->wCurrentRate,
-							pMgmt->uCurrChannel);
+				pDevice->hw->conf.chandef.chan->hw_value);
 
 		break;
 
@@ -895,10 +895,7 @@ void vRunCommand(struct work_struct *work)
 		break;
 
 	case WLAN_CMD_11H_CHSW_START:
-		vnt_set_channel(pDevice, pDevice->byNewChannel);
-		pDevice->bChannelSwitch = false;
-		pMgmt->uCurrChannel = pDevice->byNewChannel;
-		pDevice->bStopDataPkt = false;
+		vnt_set_channel(pDevice, pDevice->hw->conf.chandef.chan->hw_value);
 		break;
 
 	case WLAN_CMD_CONFIGURE_FILTER_START:

commit f31a67ae11b02638eb53838015f62c6aaff634ee
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 25 21:14:30 2014 +0100

    staging: vt6656: mac80211 conversion: vRunCommand change beacon
    
    Remove bMgrPrepareBeaconToSend
    
    Check that vif is not null
    
    Call vnt_beacon_make and turn on TCR_AUTOBCNTX.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 85adc1cd33c1..3095689094fe 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -843,7 +843,13 @@ void vRunCommand(struct work_struct *work)
 		break;
 
 	case WLAN_CMD_BECON_SEND_START:
-		bMgrPrepareBeaconToSend(pDevice, pMgmt);
+		if (!pDevice->vif)
+			break;
+
+		vnt_beacon_make(pDevice, pDevice->vif);
+
+		vnt_mac_reg_bits_on(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
+
 		break;
 
 	case WLAN_CMD_SETPOWER_START:

commit 30816f838a6589a76bca6d2afd73cafd02343429
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 25 21:14:27 2014 +0100

    staging: vt6656: mac80211 conversion: add vnt_init to bScheduleCommand
    
    start driver by linking vnt_init to vt6656_probe use bScheduleCommand
    to schedule new command WLAN_CMD_INIT_MAC80211
    
    vResetCommandTimer is now used to initiate command timer.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 4c3790857d3d..85adc1cd33c1 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -287,7 +287,20 @@ void vRunCommand(struct work_struct *work)
 		return;
 
 	switch (pDevice->eCommandState) {
+	case WLAN_CMD_INIT_MAC80211_START:
+		if (pDevice->mac_hw)
+			break;
+
+		dev_info(&pDevice->usb->dev, "Starting mac80211\n");
+
+		if (vnt_init(pDevice)) {
+			/* If fail all ends TODO retry */
+			dev_err(&pDevice->usb->dev, "failed to start\n");
+			ieee80211_free_hw(pDevice->hw);
+			return;
+		}
 
+		break;
 	case WLAN_CMD_SCAN_START:
 
 		pDevice->byReAssocCount = 0;
@@ -915,6 +928,10 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 		pDevice->cbFreeCmdQueue++;
 		pDevice->bCmdRunning = true;
 		switch (pDevice->eCommand) {
+		case WLAN_CMD_INIT_MAC80211:
+			pDevice->eCommandState = WLAN_CMD_INIT_MAC80211_START;
+			break;
+
 		case WLAN_CMD_BSSID_SCAN:
 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_BSSID_SCAN\n");
 			pDevice->eCommandState = WLAN_CMD_SCAN_START;
@@ -1083,8 +1100,6 @@ static int s_bClearBSSID_SCAN(struct vnt_private *pDevice)
 //mike add:reset command timer
 void vResetCommandTimer(struct vnt_private *pDevice)
 {
-	cancel_delayed_work_sync(&pDevice->run_command_work);
-
 	pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
 	pDevice->uCmdDequeueIdx = 0;
 	pDevice->uCmdEnqueueIdx = 0;

commit bb73fd0428fec595966369786ff0c6a8a0964cd3
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 4 18:25:26 2014 +0100

    staging: vt6656: rename PSbIsNextTBTTWakeUp to vnt_next_tbtt_wakeup
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index b2d7865a6f75..4c3790857d3d 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -826,7 +826,7 @@ void vRunCommand(struct work_struct *work)
 		break;
 
 	case WLAN_CMD_TBTT_WAKEUP_START:
-		PSbIsNextTBTTWakeUp(pDevice);
+		vnt_next_tbtt_wakeup(pDevice);
 		break;
 
 	case WLAN_CMD_BECON_SEND_START:

commit 905dba5cbd669bc9113560565dbfa18007b949ff
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 4 18:25:25 2014 +0100

    staging: vt6656: rename PSvDisablePowerSaving to vnt_disable_power_saving
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 55c55634e61b..b2d7865a6f75 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -480,7 +480,7 @@ void vRunCommand(struct work_struct *work)
 		// set initial state
 		pMgmt->eCurrState = WMAC_STATE_IDLE;
 		pMgmt->eCurrMode = WMAC_MODE_STANDBY;
-		PSvDisablePowerSaving((void *) pDevice);
+		vnt_disable_power_saving(pDevice);
 		BSSvClearNodeDBTable(pDevice, 0);
 		vMgrJoinBSSBegin((void *) pDevice, &Status);
 		// if Infra mode

commit c1d45af9162ba599f6712c69734511c4b0059b7a
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 4 18:25:24 2014 +0100

    staging: vt6656: rename PSvEnablePowerSaving to vnt_enable_power_saving
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index ae773a6bb3de..55c55634e61b 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -593,7 +593,7 @@ void vRunCommand(struct work_struct *work)
 		if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_ASSOC\n");
 			if (pDevice->ePSMode != WMAC_POWER_CAM) {
-				PSvEnablePowerSaving((void *) pDevice,
+				vnt_enable_power_saving(pDevice,
 						pMgmt->wListenInterval);
 			}
 /*

commit 369575377e8d47a9f7592f24917556f0c9996eaa
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat May 31 11:50:42 2014 +0100

    staging: vt6656: rename MACvRegBitsOff to vnt_mac_reg_bits_off
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 35cf0cf39d93..ae773a6bb3de 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -142,7 +142,7 @@ static void vAdHocBeaconRestart(struct vnt_private *pDevice)
 	if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
 	    (pMgmt->eCurrState >= WMAC_STATE_STARTED)) {
 		//PMESG(("RESTART_BEACON\n"));
-		MACvRegBitsOn(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
+		vnt_mac_reg_bits_on(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
 	}
 
 }
@@ -390,7 +390,7 @@ void vRunCommand(struct work_struct *work)
 		vnt_set_channel(pDevice, pMgmt->uCurrChannel);
 		// Set Filter
 		if (pMgmt->bCurrBSSIDFilterOn) {
-			MACvRegBitsOn(pDevice, MAC_REG_RCR, RCR_BSSID);
+			vnt_mac_reg_bits_on(pDevice, MAC_REG_RCR, RCR_BSSID);
 			pDevice->byRxMode |= RCR_BSSID;
 		}
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning, set back to channel: [%d]\n", pMgmt->uCurrChannel);
@@ -799,7 +799,7 @@ void vRunCommand(struct work_struct *work)
 
 				netif_stop_queue(pDevice->dev);
 				vnt_radio_power_off(pDevice);
-				MACvRegBitsOn(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
+				vnt_mac_reg_bits_on(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
 
 				vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_OFF);
 

commit a9bed1df5b698eca071a583eb4d66336fc8550f5
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat May 31 11:50:41 2014 +0100

    staging: vt6656: rename MACvRegBitsOff to vnt_mac_reg_bits_off
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index acd5be76a60a..35cf0cf39d93 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -111,7 +111,7 @@ static void vAdHocBeaconStop(struct vnt_private *pDevice)
 	if (bStop) {
 		//PMESG(("STOP_BEACON: IBSSChannel = %u, ScanChannel = %u\n",
 		//        pMgmt->uIBSSChannel, pMgmt->uScanChannel));
-		MACvRegBitsOff(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
+		vnt_mac_reg_bits_off(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
 	}
 
 } /* vAdHocBeaconStop */
@@ -325,7 +325,7 @@ void vRunCommand(struct work_struct *work)
 				pDevice->byScanBBType = pDevice->byBBType;  //lucas
 				pDevice->bStopDataPkt = true;
 				// Turn off RCR_BSSID filter every time
-				MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_BSSID);
+				vnt_mac_reg_bits_off(pDevice, MAC_REG_RCR, RCR_BSSID);
 				pDevice->byRxMode &= ~RCR_BSSID;
 			}
 			//lucas
@@ -647,7 +647,7 @@ void vRunCommand(struct work_struct *work)
 					KERN_INFO "vMgrCreateOwnIBSS fail!\n");
 			}
 			// always turn off unicast bit
-			MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_UNICAST);
+			vnt_mac_reg_bits_off(pDevice, MAC_REG_RCR, RCR_UNICAST);
 			pDevice->byRxMode &= ~RCR_UNICAST;
 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wcmd: rx_mode = %x\n", pDevice->byRxMode);
 			BSSvAddMulticastNode(pDevice);
@@ -808,7 +808,7 @@ void vRunCommand(struct work_struct *work)
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_ON........................\n");
 				pDevice->bHWRadioOff = false;
 				vnt_radio_power_on(pDevice);
-				MACvRegBitsOff(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
+				vnt_mac_reg_bits_off(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
 
 				vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_ON);
 			}

commit bc240f54e52fb1095ce86f86538eb2c30dffb154
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri May 30 23:22:54 2014 +0100

    staging: vt6656: rename CARDvSetBSSMode to vnt_set_bss_mode
    
    drop card and rename to vnt_set_bss_mode
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 191e7887198f..acd5be76a60a 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -333,11 +333,11 @@ void vRunCommand(struct work_struct *work)
 			if ((pDevice->byBBType != BB_TYPE_11A) &&
 			    (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G)) {
 				pDevice->byBBType = BB_TYPE_11A;
-				CARDvSetBSSMode(pDevice);
+				vnt_set_bss_mode(pDevice);
 			} else if ((pDevice->byBBType == BB_TYPE_11A) &&
 				   (pMgmt->uScanChannel <= CB_MAX_CHANNEL_24G)) {
 				pDevice->byBBType = BB_TYPE_11G;
-				CARDvSetBSSMode(pDevice);
+				vnt_set_bss_mode(pDevice);
 			}
 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning....  channel: [%d]\n", pMgmt->uScanChannel);
 			// Set channel
@@ -377,7 +377,7 @@ void vRunCommand(struct work_struct *work)
 		// Set Baseband's sensitivity back.
 		if (pDevice->byBBType != pDevice->byScanBBType) {
 			pDevice->byBBType = pDevice->byScanBBType;
-			CARDvSetBSSMode(pDevice);
+			vnt_set_bss_mode(pDevice);
 		}
 
 		BBvSetShortSlotTime(pDevice);

commit 8a5e6c8c67de72af991d29e498c4a210183375fc
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri May 30 23:22:53 2014 +0100

    staging: vt6656: rename CARDbRadioPowerOn to vnt_radio_power_on
    
    Drop card and rename to vnt_radio_power_on
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index d1d6cf28abf3..191e7887198f 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -807,7 +807,7 @@ void vRunCommand(struct work_struct *work)
 			} else {
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_ON........................\n");
 				pDevice->bHWRadioOff = false;
-				CARDbRadioPowerOn(pDevice);
+				vnt_radio_power_on(pDevice);
 				MACvRegBitsOff(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
 
 				vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_ON);

commit fa26e0bd299c3eefbc507ce6b4ee7b71aa431ea6
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri May 30 23:22:52 2014 +0100

    staging: vt6656: rename CARDbRadioPowerOff to vnt_radio_power_off
    
    Drop card and rename to vnt_radio_power_off
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index cec6fc6dc6b7..d1d6cf28abf3 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -439,7 +439,7 @@ void vRunCommand(struct work_struct *work)
 		}
 		netif_stop_queue(pDevice->dev);
 		if (pDevice->bNeedRadioOFF == true)
-			CARDbRadioPowerOff(pDevice);
+			vnt_radio_power_off(pDevice);
 
 		break;
 
@@ -798,7 +798,7 @@ void vRunCommand(struct work_struct *work)
 				memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
 
 				netif_stop_queue(pDevice->dev);
-				CARDbRadioPowerOff(pDevice);
+				vnt_radio_power_off(pDevice);
 				MACvRegBitsOn(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
 
 				vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_OFF);

commit 084fc8f31a9296a832ab1f81856955a35e47624e
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri May 30 16:27:40 2014 +0100

    staging: vt6656: rename CARDbSetMediaChannel to vnt_set_channel
    
    Drop card and media and just use vnt_set_channel.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index da72d4df6fca..cec6fc6dc6b7 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -341,7 +341,7 @@ void vRunCommand(struct work_struct *work)
 			}
 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning....  channel: [%d]\n", pMgmt->uScanChannel);
 			// Set channel
-			CARDbSetMediaChannel(pDevice, pMgmt->uScanChannel);
+			vnt_set_channel(pDevice, pMgmt->uScanChannel);
 			// Set Baseband to be more sensitive.
 
 			BBvSetShortSlotTime(pDevice);
@@ -387,7 +387,7 @@ void vRunCommand(struct work_struct *work)
 		// Set channel back
 		vAdHocBeaconRestart(pDevice);
 		// Set channel back
-		CARDbSetMediaChannel(pDevice, pMgmt->uCurrChannel);
+		vnt_set_channel(pDevice, pMgmt->uCurrChannel);
 		// Set Filter
 		if (pMgmt->bCurrBSSIDFilterOn) {
 			MACvRegBitsOn(pDevice, MAC_REG_RCR, RCR_BSSID);
@@ -876,7 +876,7 @@ void vRunCommand(struct work_struct *work)
 		break;
 
 	case WLAN_CMD_11H_CHSW_START:
-		CARDbSetMediaChannel(pDevice, pDevice->byNewChannel);
+		vnt_set_channel(pDevice, pDevice->byNewChannel);
 		pDevice->bChannelSwitch = false;
 		pMgmt->uCurrChannel = pDevice->byNewChannel;
 		pDevice->bStopDataPkt = false;

commit 4f5290ea3c2ad00cde2b5ec19c678c28cdc65597
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Tue May 27 21:05:21 2014 +0100

    staging: vt6656: rf.c/h rename RFbSetPower to vnt_rf_setpower
    
    Removing camel case
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 9a166fbcfa1f..da72d4df6fca 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -835,7 +835,8 @@ void vRunCommand(struct work_struct *work)
 
 	case WLAN_CMD_SETPOWER_START:
 
-		RFbSetPower(pDevice, pDevice->wCurrentRate, pMgmt->uCurrChannel);
+		vnt_rf_setpower(pDevice, pDevice->wCurrentRate,
+							pMgmt->uCurrChannel);
 
 		break;
 

commit 62c8526d60181da14fa73a43ed23f3314523b4f5
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon May 26 13:59:07 2014 +0100

    staging: vt6656: dead code remove control.c/h
    
    Replace control.h headers with usbpipe.h
    
    Also add to usbpipe.c its header
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 91754fd2cedb..9a166fbcfa1f 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -48,7 +48,7 @@
 #include "power.h"
 #include "wctl.h"
 #include "baseband.h"
-#include "control.h"
+#include "usbpipe.h"
 #include "rxtx.h"
 #include "rf.h"
 #include "channel.h"

commit 53742906bca9f035ec97fe3578c6064e015c3821
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon May 26 13:59:06 2014 +0100

    staging: vt6656: create vnt_control_in_u8 to replace ControlvReadByte
    
    ControlvReadByte will be removed in next patch
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 79f7463be443..91754fd2cedb 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -861,7 +861,7 @@ void vRunCommand(struct work_struct *work)
 		break;
 
 	case WLAN_CMD_MAC_DISPOWERSAVING_START:
-		ControlvReadByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
+		vnt_control_in_u8(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
 		if ((byData & PSCTL_PS) != 0) {
 			// disable power saving hw function
 			vnt_control_out(pDevice,

commit 96f6975bd3841a227185712bbd672c278e481816
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon May 26 13:59:04 2014 +0100

    staging: vt6656: Create new function to set led state.
    
    Create vnt_mac_set_led to set state and led.
    
    state has two modes LEDSTS_TMLEN which sets the blink rate
    on TX activity and LEDSTS_STS which sets the led.
    
    As result of this patch ControlvMaskByte becomes dead code.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index aae573baec1b..79f7463be443 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -426,7 +426,9 @@ void vRunCommand(struct work_struct *work)
 					     (8),
 					     &Status);
 			pDevice->bLinkPass = false;
-			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
+
+			vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_SLOW);
+
 			// unlock command busy
 			pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
 			pItemSSID->len = 0;
@@ -472,7 +474,8 @@ void vRunCommand(struct work_struct *work)
 			}
 			netif_stop_queue(pDevice->dev);
 			pDevice->bLinkPass = false;
-			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
+
+			vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_SLOW);
 		}
 		// set initial state
 		pMgmt->eCurrState = WMAC_STATE_IDLE;
@@ -507,7 +510,9 @@ void vRunCommand(struct work_struct *work)
 				if (netif_queue_stopped(pDevice->dev))
 					netif_wake_queue(pDevice->dev);
 				pDevice->bLinkPass = true;
-				ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
+
+				vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_INTER);
+
 				pMgmt->sNodeDBTable[0].bActive = true;
 				pMgmt->sNodeDBTable[0].uInActiveCount = 0;
 			} else {
@@ -538,7 +543,6 @@ void vRunCommand(struct work_struct *work)
 				s_bClearBSSID_SCAN(pDevice);
 /*
 				pDevice->bLinkPass = true;
-				ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
 				if (netif_queue_stopped(pDevice->dev)){
 					netif_wake_queue(pDevice->dev);
 				}
@@ -600,7 +604,9 @@ void vRunCommand(struct work_struct *work)
 			pDevice->byLinkWaitCount = 0;
 			pDevice->byReAssocCount = 0;
 			pDevice->bLinkPass = true;
-			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
+
+			vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_INTER);
+
 			s_bClearBSSID_SCAN(pDevice);
 
 			if (netif_queue_stopped(pDevice->dev))
@@ -626,7 +632,8 @@ void vRunCommand(struct work_struct *work)
 			pMgmt->eCurrState = WMAC_STATE_IDLE;
 			pMgmt->eCurrMode = WMAC_MODE_STANDBY;
 			pDevice->bLinkPass = false;
-			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
+
+			vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_SLOW);
 
 			BSSvClearNodeDBTable(pDevice, 0);
 
@@ -647,7 +654,9 @@ void vRunCommand(struct work_struct *work)
 			if (netif_queue_stopped(pDevice->dev))
 				netif_wake_queue(pDevice->dev);
 			pDevice->bLinkPass = true;
-			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
+
+			vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_INTER);
+
 			schedule_delayed_work(&pDevice->second_callback_work, HZ);
 		}
 		break;
@@ -791,14 +800,17 @@ void vRunCommand(struct work_struct *work)
 				netif_stop_queue(pDevice->dev);
 				CARDbRadioPowerOff(pDevice);
 				MACvRegBitsOn(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
-				ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_OFF);
+
+				vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_OFF);
+
 				pDevice->bHWRadioOff = true;
 			} else {
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_ON........................\n");
 				pDevice->bHWRadioOff = false;
 				CARDbRadioPowerOn(pDevice);
 				MACvRegBitsOff(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
-				ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_ON);
+
+				vnt_mac_set_led(pDevice, LEDSTS_STS, LEDSTS_ON);
 			}
 		}
 

commit 441c21c3f0a0db21e96f1598fb05ac3d8782ac59
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon May 26 13:59:02 2014 +0100

    staging: vt6656: rename PIPEnsControlIn/CONTROLnsRequestIn with vnt_control_in
    
    Replace all to CONTROLnsRequestIn with vnt_control_in and remove macro.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 99477944c045..aae573baec1b 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -725,7 +725,7 @@ void vRunCommand(struct work_struct *work)
 			int ntStatus = STATUS_SUCCESS;
 			u8            byTmp;
 
-			ntStatus = CONTROLnsRequestIn(pDevice,
+			ntStatus = vnt_control_in(pDevice,
 					MESSAGE_TYPE_READ,
 					MAC_REG_GPIOCTL1,
 					MESSAGE_REQUEST_MACREG,

commit 1390b02a2f5d3b8d0a13e2f2d67dc2a562bc0b89
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon May 26 13:59:01 2014 +0100

    staging: vt6656: rename PIPEnsControlOut/CONTROLnsRequestOut to vnt_control_out
    
    Rename all CONTROLnsRequestOut and remove macro from control.h
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index ff4e4ae0485d..99477944c045 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -852,7 +852,7 @@ void vRunCommand(struct work_struct *work)
 		ControlvReadByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
 		if ((byData & PSCTL_PS) != 0) {
 			// disable power saving hw function
-			CONTROLnsRequestOut(pDevice,
+			vnt_control_out(pDevice,
 					MESSAGE_TYPE_DISABLE_PS,
 					0,
 					0,

commit 90f96acd1b6ea7c16e43303f74bc97f8250010ac
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon May 19 20:32:54 2014 +0100

    staging: vt6656: Remove hostapd functions.
    
    Remove throughout driver
    bEnableHostapd
    bEnable8021x
    bEnableHostWEP
    struct net_device *apdev
    tx_80211
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index b742460670d3..ff4e4ae0485d 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -627,10 +627,9 @@ void vRunCommand(struct work_struct *work)
 			pMgmt->eCurrMode = WMAC_MODE_STANDBY;
 			pDevice->bLinkPass = false;
 			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
-			if (pDevice->bEnableHostWEP == true)
-				BSSvClearNodeDBTable(pDevice, 1);
-			else
-				BSSvClearNodeDBTable(pDevice, 0);
+
+			BSSvClearNodeDBTable(pDevice, 0);
+
 			pDevice->uAssocCount = 0;
 			pMgmt->eCurrState = WMAC_STATE_IDLE;
 			pDevice->bFixRate = false;

commit 9cade5aceb9c78b96260f78249cadc579ab4118c
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat May 17 09:50:39 2014 +0100

    staging: vt6656: Remove always true bUpdateBBVGA
    
    Remove true if statements.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 8fecb34297af..b742460670d3 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -344,11 +344,10 @@ void vRunCommand(struct work_struct *work)
 			CARDbSetMediaChannel(pDevice, pMgmt->uScanChannel);
 			// Set Baseband to be more sensitive.
 
-			if (pDevice->bUpdateBBVGA) {
-				BBvSetShortSlotTime(pDevice);
-				BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
-				BBvUpdatePreEDThreshold(pDevice, true);
-			}
+			BBvSetShortSlotTime(pDevice);
+			BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
+			BBvUpdatePreEDThreshold(pDevice, true);
+
 			pMgmt->uScanChannel++;
 
 			while (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel) &&
@@ -381,11 +380,9 @@ void vRunCommand(struct work_struct *work)
 			CARDvSetBSSMode(pDevice);
 		}
 
-		if (pDevice->bUpdateBBVGA) {
-			BBvSetShortSlotTime(pDevice);
-			BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
-			BBvUpdatePreEDThreshold(pDevice, false);
-		}
+		BBvSetShortSlotTime(pDevice);
+		BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
+		BBvUpdatePreEDThreshold(pDevice, false);
 
 		// Set channel back
 		vAdHocBeaconRestart(pDevice);

commit 60f8ce8dd6feb2d921a5513e79eaf9d6884abc09
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat May 17 09:50:30 2014 +0100

    staging: vt6656: rndis.h move all to device.h
    
    Commands macros are common to all source files.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 66d59d51bf82..8fecb34297af 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -51,7 +51,6 @@
 #include "control.h"
 #include "rxtx.h"
 #include "rf.h"
-#include "rndis.h"
 #include "channel.h"
 #include "iowpa.h"
 

commit 97641ca2b284ddc9870afdcfe22487702ee27b3e
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu May 15 22:49:18 2014 +0100

    staging: vt6656: lock changes: vRunCommand nsDMA_tx_packet
    
    vRunCommand is nolonger atomic add lock for nsDMA_tx_packet.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index d51cc90047f6..66d59d51bf82 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -279,6 +279,7 @@ void vRunCommand(struct work_struct *work)
 	int ii;
 	u8 byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
 	u8 byData;
+	unsigned long flags;
 
 	if (pDevice->Flags & fMP_DISCONNECTED)
 		return;
@@ -667,9 +668,13 @@ void vRunCommand(struct work_struct *work)
 					pDevice->bMoreData = true;
 				}
 
+				spin_lock_irqsave(&pDevice->lock, flags);
+
 				if (nsDMA_tx_packet(pDevice, skb) != 0)
 					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Multicast ps tx fail\n");
 
+				spin_unlock_irqrestore(&pDevice->lock, flags);
+
 				pMgmt->sNodeDBTable[0].wEnQueueCnt--;
 			}
 		}
@@ -690,9 +695,13 @@ void vRunCommand(struct work_struct *work)
 						pDevice->bMoreData = true;
 					}
 
+					spin_lock_irqsave(&pDevice->lock, flags);
+
 					if (nsDMA_tx_packet(pDevice, skb) != 0)
 						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "sta ps tx fail\n");
 
+					spin_unlock_irqrestore(&pDevice->lock, flags);
+
 					pMgmt->sNodeDBTable[ii].wEnQueueCnt--;
 					// check if sta ps enable, wait next pspoll
 					// if sta ps disable, send all pending buffers.

commit d1d4120f7fab69b32d40780b766109d377d743a7
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu May 15 22:49:13 2014 +0100

    staging: vt6656: lock changes: vRunCommand remove locks.
    
    Removing atomic locked paths to usbpipe.c PIPEnsControlOut and PIPEnsControlIn
    
    This function will nolonger need any locking.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index de7e80897abe..d51cc90047f6 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -286,8 +286,6 @@ void vRunCommand(struct work_struct *work)
 	if (pDevice->bCmdRunning != true)
 		return;
 
-	spin_lock_irq(&pDevice->lock);
-
 	switch (pDevice->eCommandState) {
 
 	case WLAN_CMD_SCAN_START:
@@ -365,11 +363,9 @@ void vRunCommand(struct work_struct *work)
 			if ((pMgmt->b11hEnable == false) ||
 			    (pMgmt->uScanChannel < CB_MAX_CHANNEL_24G)) {
 				s_vProbeChannel(pDevice);
-				spin_unlock_irq(&pDevice->lock);
 				vCommandTimerWait((void *) pDevice, 100);
 				return;
 			} else {
-				spin_unlock_irq(&pDevice->lock);
 				vCommandTimerWait((void *) pDevice, WCMD_PASSIVE_SCAN_TIME);
 				return;
 			}
@@ -504,7 +500,6 @@ void vRunCommand(struct work_struct *work)
 				pDevice->byLinkWaitCount = 0;
 				pDevice->eCommandState = WLAN_AUTHENTICATE_WAIT;
 				vCommandTimerWait((void *) pDevice, AUTHENTICATE_TIMEOUT);
-				spin_unlock_irq(&pDevice->lock);
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Set eCommandState = WLAN_AUTHENTICATE_WAIT\n");
 				return;
 			}
@@ -578,7 +573,6 @@ void vRunCommand(struct work_struct *work)
 				pDevice->byLinkWaitCount = 0;
 				pDevice->eCommandState = WLAN_ASSOCIATE_WAIT;
 				vCommandTimerWait((void *) pDevice, ASSOCIATE_TIMEOUT);
-				spin_unlock_irq(&pDevice->lock);
 				return;
 			}
 		} else if (pMgmt->eCurrState < WMAC_STATE_AUTHPENDING) {
@@ -587,7 +581,6 @@ void vRunCommand(struct work_struct *work)
 			//mike add:wait another 2 sec if authenticated_frame delay!
 			pDevice->byLinkWaitCount++;
 			printk("WLAN_AUTHENTICATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
-			spin_unlock_irq(&pDevice->lock);
 			vCommandTimerWait((void *) pDevice, AUTHENTICATE_TIMEOUT/2);
 			return;
 		}
@@ -622,7 +615,6 @@ void vRunCommand(struct work_struct *work)
 			//mike add:wait another 2 sec if associated_frame delay!
 			pDevice->byLinkWaitCount++;
 			printk("WLAN_ASSOCIATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
-			spin_unlock_irq(&pDevice->lock);
 			vCommandTimerWait((void *) pDevice, ASSOCIATE_TIMEOUT/2);
 			return;
 		}
@@ -752,9 +744,9 @@ void vRunCommand(struct work_struct *work)
 
 				pDevice->byKeyIndex = 0;
 				pDevice->bTransmitKey = false;
-				spin_unlock_irq(&pDevice->lock);
+
 				KeyvInitTable(pDevice, &pDevice->sKey);
-				spin_lock_irq(&pDevice->lock);
+
 				pMgmt->byCSSPK = KEY_CTL_NONE;
 				pMgmt->byCSSGK = KEY_CTL_NONE;
 
@@ -882,7 +874,6 @@ void vRunCommand(struct work_struct *work)
 
 	s_bCommandComplete(pDevice);
 
-	spin_unlock_irq(&pDevice->lock);
 	return;
 }
 

commit 05cc617b5db8a6debac873e4dcfbd6d679406730
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Apr 30 21:31:12 2014 +0100

    staging: vt6656: rxtx: Remove unused uDMAIdx from driver.
    
    Remove from functions and callers.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 3cf3f24247a3..de7e80897abe 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -675,7 +675,7 @@ void vRunCommand(struct work_struct *work)
 					pDevice->bMoreData = true;
 				}
 
-				if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0)
+				if (nsDMA_tx_packet(pDevice, skb) != 0)
 					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Multicast ps tx fail\n");
 
 				pMgmt->sNodeDBTable[0].wEnQueueCnt--;
@@ -698,7 +698,7 @@ void vRunCommand(struct work_struct *work)
 						pDevice->bMoreData = true;
 					}
 
-					if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0)
+					if (nsDMA_tx_packet(pDevice, skb) != 0)
 						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "sta ps tx fail\n");
 
 					pMgmt->sNodeDBTable[ii].wEnQueueCnt--;

commit 2ae2777c44d75d7754a80483ecaefc23cf5c41dc
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Feb 19 19:35:16 2014 +0000

    staging: vt6656: vRunCommand remove multi calls to s_bCommandComplete.
    
    Remove calls with break
    s_bCommandComplete(pDevice);
    spin_unlock_irq(&pDevice->lock);
    return;
    
    Add single call to s_bCommandComplete;
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 8c702c379739..3cf3f24247a3 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -293,17 +293,11 @@ void vRunCommand(struct work_struct *work)
 	case WLAN_CMD_SCAN_START:
 
 		pDevice->byReAssocCount = 0;
-		if (pDevice->bRadioOff == true) {
-			s_bCommandComplete(pDevice);
-			spin_unlock_irq(&pDevice->lock);
-			return;
-		}
+		if (pDevice->bRadioOff == true)
+			break;
 
-		if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-			s_bCommandComplete(pDevice);
-			spin_unlock_irq(&pDevice->lock);
-			return;
-		}
+		if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP)
+			break;
 
 		pItemSSID = (PWLAN_IE_SSID)pMgmt->abyScanSSID;
 
@@ -311,16 +305,12 @@ void vRunCommand(struct work_struct *work)
 			pMgmt->uScanChannel = pDevice->byMinChannel;
 		if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
 			pDevice->eCommandState = WLAN_CMD_SCAN_END;
-			s_bCommandComplete(pDevice);
-			spin_unlock_irq(&pDevice->lock);
-			return;
+			break;
 		} else {
 			if (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel)) {
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Invalid channel pMgmt->uScanChannel = %d\n", pMgmt->uScanChannel);
 				pMgmt->uScanChannel++;
-				s_bCommandComplete(pDevice);
-				spin_unlock_irq(&pDevice->lock);
-				return;
+				break;
 			}
 			if (pMgmt->uScanChannel == pDevice->byMinChannel) {
 				// pMgmt->eScanType = WMAC_SCAN_ACTIVE;          //mike mark
@@ -420,16 +410,13 @@ void vRunCommand(struct work_struct *work)
 		memset(&wrqu, 0, sizeof(wrqu));
 		wireless_send_event(pDevice->dev, SIOCGIWSCAN, &wrqu, NULL);
 
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_DISASSOCIATE_START:
 		pDevice->byReAssocCount = 0;
 		if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
 		    (pMgmt->eCurrState != WMAC_STATE_ASSOC)) {
-			s_bCommandComplete(pDevice);
-			spin_unlock_irq(&pDevice->lock);
-			return;
+			break;
 		} else {
 			pDevice->bwextstep0 = false;
 			pDevice->bwextstep1 = false;
@@ -458,17 +445,14 @@ void vRunCommand(struct work_struct *work)
 		netif_stop_queue(pDevice->dev);
 		if (pDevice->bNeedRadioOFF == true)
 			CARDbRadioPowerOff(pDevice);
-		s_bCommandComplete(pDevice);
+
 		break;
 
 	case WLAN_CMD_SSID_START:
 
 		pDevice->byReAssocCount = 0;
-		if (pDevice->bRadioOff == true) {
-			s_bCommandComplete(pDevice);
-			spin_unlock_irq(&pDevice->lock);
-			return;
-		}
+		if (pDevice->bRadioOff == true)
+			break;
 
 		memcpy(pMgmt->abyAdHocSSID, pMgmt->abyDesireSSID,
 		       ((PWLAN_IE_SSID)pMgmt->abyDesireSSID)->len + WLAN_IEHDR_LEN);
@@ -489,11 +473,9 @@ void vRunCommand(struct work_struct *work)
 		if ((pMgmt->eCurrState == WMAC_STATE_ASSOC) ||
 		    ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED))) {
 			if (pItemSSID->len == pItemSSIDCurr->len) {
-				if (memcmp(pItemSSID->abySSID, pItemSSIDCurr->abySSID, pItemSSID->len) == 0) {
-					s_bCommandComplete(pDevice);
-					spin_unlock_irq(&pDevice->lock);
-					return;
-				}
+				if (!memcmp(pItemSSID->abySSID,
+					pItemSSIDCurr->abySSID, pItemSSID->len))
+					break;
 			}
 			netif_stop_queue(pDevice->dev);
 			pDevice->bLinkPass = false;
@@ -582,7 +564,6 @@ void vRunCommand(struct work_struct *work)
 				}
 			}
 		}
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_AUTHENTICATE_WAIT:
@@ -612,7 +593,6 @@ void vRunCommand(struct work_struct *work)
 		}
 		pDevice->byLinkWaitCount = 0;
 
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_ASSOCIATE_WAIT:
@@ -647,7 +627,6 @@ void vRunCommand(struct work_struct *work)
 			return;
 		}
 
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_AP_MODE_START:
@@ -683,7 +662,6 @@ void vRunCommand(struct work_struct *work)
 			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
 			schedule_delayed_work(&pDevice->second_callback_work, HZ);
 		}
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_TX_PSPACKET_START:
@@ -738,8 +716,6 @@ void vRunCommand(struct work_struct *work)
 				pMgmt->sNodeDBTable[ii].bRxPSPoll = false;
 			}
 		}
-
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_RADIO_START:
@@ -760,11 +736,8 @@ void vRunCommand(struct work_struct *work)
 					1,
 					&byTmp);
 
-			if (ntStatus != STATUS_SUCCESS) {
-				s_bCommandComplete(pDevice);
-				spin_unlock_irq(&pDevice->lock);
-				return;
-			}
+			if (ntStatus != STATUS_SUCCESS)
+				break;
 			if ((byTmp & GPIO3_DATA) == 0) {
 				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_OFF........................\n");
 				// Old commands are useless.
@@ -833,7 +806,6 @@ void vRunCommand(struct work_struct *work)
 			}
 		}
 
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_CHANGE_BBSENSITIVITY_START:
@@ -843,24 +815,20 @@ void vRunCommand(struct work_struct *work)
 		BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change sensitivity pDevice->byBBVGACurrent = %x\n", pDevice->byBBVGACurrent);
 		pDevice->bStopDataPkt = false;
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_TBTT_WAKEUP_START:
 		PSbIsNextTBTTWakeUp(pDevice);
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_BECON_SEND_START:
 		bMgrPrepareBeaconToSend(pDevice, pMgmt);
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_SETPOWER_START:
 
 		RFbSetPower(pDevice, pDevice->wCurrentRate, pMgmt->uCurrChannel);
 
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_CHANGE_ANTENNA_START:
@@ -878,12 +846,10 @@ void vRunCommand(struct work_struct *work)
 			else
 				BBvSetAntennaMode(pDevice, ANT_RXA);
 		}
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_REMOVE_ALLKEY_START:
 		KeybRemoveAllKey(pDevice, &(pDevice->sKey), pDevice->abyBSSID);
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_MAC_DISPOWERSAVING_START:
@@ -898,7 +864,6 @@ void vRunCommand(struct work_struct *work)
 					NULL
 					);
 		}
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_11H_CHSW_START:
@@ -906,18 +871,17 @@ void vRunCommand(struct work_struct *work)
 		pDevice->bChannelSwitch = false;
 		pMgmt->uCurrChannel = pDevice->byNewChannel;
 		pDevice->bStopDataPkt = false;
-		s_bCommandComplete(pDevice);
 		break;
 
 	case WLAN_CMD_CONFIGURE_FILTER_START:
 		vnt_configure_filter(pDevice);
-		s_bCommandComplete(pDevice);
 		break;
 	default:
-		s_bCommandComplete(pDevice);
 		break;
 	} //switch
 
+	s_bCommandComplete(pDevice);
+
 	spin_unlock_irq(&pDevice->lock);
 	return;
 }

commit edd20e964072e1bfccee06362e55148d6a1117b5
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Feb 19 19:34:18 2014 +0000

    staging: vt6656: Move device_set_multi code call to vRunCommand
    
    device_set_multi is an atomic call, in order to reduce atomic area of driver
    move code to be called from vRunCommand.
    
    Later the atomic area of vRunCommand can be reduced.
    
    Change existing code in device_set_multi to new function
    vnt_configure_filter minus its locks.
    
    Change device_set_multi to call bScheduleCommand
    
    device_set_multi is nolonger called from device open.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 6b9522914634..8c702c379739 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -909,6 +909,10 @@ void vRunCommand(struct work_struct *work)
 		s_bCommandComplete(pDevice);
 		break;
 
+	case WLAN_CMD_CONFIGURE_FILTER_START:
+		vnt_configure_filter(pDevice);
+		s_bCommandComplete(pDevice);
+		break;
 	default:
 		s_bCommandComplete(pDevice);
 		break;
@@ -1009,6 +1013,11 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 			pDevice->eCommandState = WLAN_CMD_11H_CHSW_START;
 			break;
 
+		case WLAN_CMD_CONFIGURE_FILTER:
+			pDevice->eCommandState =
+						WLAN_CMD_CONFIGURE_FILTER_START;
+			break;
+
 		default:
 			break;
 		}

commit c47b0a34538dcbabb8aface7b4397148e6e24f17
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Nov 24 11:51:49 2013 +0000

    staging: vt6656: Remove always 0 variable dwDiagRefCount
    
    Remove > 0 code.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 2d05ccb58a7a..6b9522914634 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -283,8 +283,6 @@ void vRunCommand(struct work_struct *work)
 	if (pDevice->Flags & fMP_DISCONNECTED)
 		return;
 
-	if (pDevice->dwDiagRefCount != 0)
-		return;
 	if (pDevice->bCmdRunning != true)
 		return;
 

commit df6b85138faa297c643542047d09081877c24026
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Tue Nov 12 23:05:40 2013 +0530

    staging: vt6656: removed the trailing statement should be on next line error
    
    as per linux coding style trailing statments should not be there
    at the end of line, instead it should be placed in next line.
    hence removed that error by moving trailing statement to next
    line
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 9646d72dc9b2..2d05ccb58a7a 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -604,7 +604,8 @@ void vRunCommand(struct work_struct *work)
 			}
 		} else if (pMgmt->eCurrState < WMAC_STATE_AUTHPENDING) {
 			printk("WLAN_AUTHENTICATE_WAIT:Authen Fail???\n");
-		} else if (pDevice->byLinkWaitCount <= 4) {    //mike add:wait another 2 sec if authenticated_frame delay!
+		} else if (pDevice->byLinkWaitCount <= 4) {
+			//mike add:wait another 2 sec if authenticated_frame delay!
 			pDevice->byLinkWaitCount++;
 			printk("WLAN_AUTHENTICATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
 			spin_unlock_irq(&pDevice->lock);
@@ -639,7 +640,8 @@ void vRunCommand(struct work_struct *work)
 
 		} else if (pMgmt->eCurrState < WMAC_STATE_ASSOCPENDING) {
 			printk("WLAN_ASSOCIATE_WAIT:Association Fail???\n");
-		} else if (pDevice->byLinkWaitCount <= 4) {    //mike add:wait another 2 sec if associated_frame delay!
+		} else if (pDevice->byLinkWaitCount <= 4) {
+			//mike add:wait another 2 sec if associated_frame delay!
 			pDevice->byLinkWaitCount++;
 			printk("WLAN_ASSOCIATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
 			spin_unlock_irq(&pDevice->lock);

commit 819b920b7d66195c5e118e844239721b92ff8180
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Tue Nov 12 23:05:39 2013 +0530

    staging: vt6656: added space after coma operator in funtion call
    
    as per coding style a space is required after ',' operator
    in function calls, hence added the missing space after ','
    operator in a function call
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 640813e722a8..9646d72dc9b2 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -448,7 +448,7 @@ void vRunCommand(struct work_struct *work)
 					     (8),
 					     &Status);
 			pDevice->bLinkPass = false;
-			ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
+			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
 			// unlock command busy
 			pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
 			pItemSSID->len = 0;

commit 2eca4ead3819b375ec169bb9f38eba82bd0e1dca
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Tue Nov 12 23:05:38 2013 +0530

    staging: vt6656: removed all whitespace errors
    
    removed all whitespace errors from the code like no
    space at the start of line and indent the code
    wherever possible
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 246a266556a3..640813e722a8 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -651,7 +651,7 @@ void vRunCommand(struct work_struct *work)
 		break;
 
 	case WLAN_CMD_AP_MODE_START:
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_AP_MODE_START\n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_AP_MODE_START\n");
 
 		if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
 			cancel_delayed_work_sync(&pDevice->second_callback_work);
@@ -683,8 +683,8 @@ void vRunCommand(struct work_struct *work)
 			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
 			schedule_delayed_work(&pDevice->second_callback_work, HZ);
 		}
-            s_bCommandComplete(pDevice);
-            break;
+		s_bCommandComplete(pDevice);
+		break;
 
 	case WLAN_CMD_TX_PSPACKET_START:
 		// DTIM Multicast tx
@@ -704,7 +704,7 @@ void vRunCommand(struct work_struct *work)
 			}
 		}
 
-            // PS nodes tx
+		// PS nodes tx
 		for (ii = 1; ii < (MAX_NODE_NUM + 1); ii++) {
 			if (pMgmt->sNodeDBTable[ii].bActive &&
 			    pMgmt->sNodeDBTable[ii].bRxPSPoll) {

commit 820c9b12153d83319fdfbba2783ff1c07a1ad817
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Tue Nov 12 23:05:37 2013 +0530

    staging: vt6656: removed parenthesis from return statement
    
    parenthesis is not required in return statement since its
    not a fucntion, hence remove parentheses to comply with
    linux coding style
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index fa6234bbca11..246a266556a3 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -1023,7 +1023,7 @@ int bScheduleCommand(struct vnt_private *pDevice,
 {
 
 	if (pDevice->cbFreeCmdQueue == 0)
-		return (false);
+		return false;
 	pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].eCmd = eCommand;
 	pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = true;
 	memset(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID, 0 , WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
@@ -1064,7 +1064,7 @@ int bScheduleCommand(struct vnt_private *pDevice,
 	if (pDevice->bCmdRunning == false)
 		s_bCommandComplete(pDevice);
 
-	return (true);
+	return true;
 
 }
 

commit 97d59f87433d1a4eb6eafcd8b1896e239bf34569
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Tue Nov 12 23:05:36 2013 +0530

    staging: vt6656: indented the code under all function blocks
    
    indented the code under all functions to remove unnecessary space
    at start of a line and indent code wherver possible errors
    thrown from checkpatch script
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index a53a15a60b4e..fa6234bbca11 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -87,18 +87,18 @@ static void vAdHocBeaconStop(struct vnt_private *pDevice)
 	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
 	int bStop;
 
-    /*
-     * temporarily stop Beacon packet for AdHoc Server
-     * if all of the following coditions are met:
-     *  (1) STA is in AdHoc mode
-     *  (2) VT3253 is programmed as automatic Beacon Transmitting
-     *  (3) One of the following conditions is met
-     *      (3.1) AdHoc channel is in B/G band and the
-     *      current scan channel is in A band
-     *      or
-     *      (3.2) AdHoc channel is in A mode
-     */
-    bStop = false;
+	/*
+	 * temporarily stop Beacon packet for AdHoc Server
+	 * if all of the following coditions are met:
+	 *  (1) STA is in AdHoc mode
+	 *  (2) VT3253 is programmed as automatic Beacon Transmitting
+	 *  (3) One of the following conditions is met
+	 *      (3.1) AdHoc channel is in B/G band and the
+	 *      current scan channel is in A band
+	 *      or
+	 *      (3.2) AdHoc channel is in A mode
+	 */
+	bStop = false;
 	if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
 	    (pMgmt->eCurrState >= WMAC_STATE_STARTED)) {
 		if ((pMgmt->uIBSSChannel <=  CB_MAX_CHANNEL_24G) &&
@@ -183,16 +183,16 @@ static void s_vProbeChannel(struct vnt_private *pDevice)
 	else
 		pbyRate = &abyCurrSuppRatesG[0];
 
-    // build an assocreq frame and send it
-    pTxPacket = s_MgrMakeProbeRequest
-                (
-                  pDevice,
-                  pMgmt,
-                  pMgmt->abyScanBSSID,
-                  (PWLAN_IE_SSID)pMgmt->abyScanSSID,
-                  (PWLAN_IE_SUPP_RATES)pbyRate,
-                  (PWLAN_IE_SUPP_RATES)abyCurrExtSuppRatesG
-                );
+	// build an assocreq frame and send it
+	pTxPacket = s_MgrMakeProbeRequest
+		    (
+		     pDevice,
+		     pMgmt,
+		     pMgmt->abyScanBSSID,
+		     (PWLAN_IE_SSID)pMgmt->abyScanSSID,
+		     (PWLAN_IE_SUPP_RATES)pbyRate,
+		     (PWLAN_IE_SUPP_RATES)abyCurrExtSuppRatesG
+		     );
 
 	if (pTxPacket != NULL) {
 		for (ii = 0; ii < 1; ii++) {
@@ -229,34 +229,34 @@ static struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *pDevice,
 		+ WLAN_PROBEREQ_FR_MAXLEN);
 	pTxPacket->p80211Header = (PUWLAN_80211HDR)((u8 *)pTxPacket
 		+ sizeof(struct vnt_tx_mgmt));
-    sFrame.pBuf = (u8 *)pTxPacket->p80211Header;
-    sFrame.len = WLAN_PROBEREQ_FR_MAXLEN;
-    vMgrEncodeProbeRequest(&sFrame);
-    sFrame.pHdr->sA3.wFrameCtl = cpu_to_le16(
-        (
-        WLAN_SET_FC_FTYPE(WLAN_TYPE_MGR) |
-        WLAN_SET_FC_FSTYPE(WLAN_FSTYPE_PROBEREQ)
-        ));
-    memcpy(sFrame.pHdr->sA3.abyAddr1, pScanBSSID, WLAN_ADDR_LEN);
-    memcpy(sFrame.pHdr->sA3.abyAddr2, pMgmt->abyMACAddr, WLAN_ADDR_LEN);
-    memcpy(sFrame.pHdr->sA3.abyAddr3, pScanBSSID, WLAN_BSSID_LEN);
-    // Copy the SSID, pSSID->len=0 indicate broadcast SSID
-    sFrame.pSSID = (PWLAN_IE_SSID)(sFrame.pBuf + sFrame.len);
-    sFrame.len += pSSID->len + WLAN_IEHDR_LEN;
-    memcpy(sFrame.pSSID, pSSID, pSSID->len + WLAN_IEHDR_LEN);
-    sFrame.pSuppRates = (PWLAN_IE_SUPP_RATES)(sFrame.pBuf + sFrame.len);
-    sFrame.len += pCurrRates->len + WLAN_IEHDR_LEN;
-    memcpy(sFrame.pSuppRates, pCurrRates, pCurrRates->len + WLAN_IEHDR_LEN);
-    // Copy the extension rate set
+	sFrame.pBuf = (u8 *)pTxPacket->p80211Header;
+	sFrame.len = WLAN_PROBEREQ_FR_MAXLEN;
+	vMgrEncodeProbeRequest(&sFrame);
+	sFrame.pHdr->sA3.wFrameCtl = cpu_to_le16(
+		(
+		 WLAN_SET_FC_FTYPE(WLAN_TYPE_MGR) |
+		 WLAN_SET_FC_FSTYPE(WLAN_FSTYPE_PROBEREQ)
+		 ));
+	memcpy(sFrame.pHdr->sA3.abyAddr1, pScanBSSID, WLAN_ADDR_LEN);
+	memcpy(sFrame.pHdr->sA3.abyAddr2, pMgmt->abyMACAddr, WLAN_ADDR_LEN);
+	memcpy(sFrame.pHdr->sA3.abyAddr3, pScanBSSID, WLAN_BSSID_LEN);
+	// Copy the SSID, pSSID->len=0 indicate broadcast SSID
+	sFrame.pSSID = (PWLAN_IE_SSID)(sFrame.pBuf + sFrame.len);
+	sFrame.len += pSSID->len + WLAN_IEHDR_LEN;
+	memcpy(sFrame.pSSID, pSSID, pSSID->len + WLAN_IEHDR_LEN);
+	sFrame.pSuppRates = (PWLAN_IE_SUPP_RATES)(sFrame.pBuf + sFrame.len);
+	sFrame.len += pCurrRates->len + WLAN_IEHDR_LEN;
+	memcpy(sFrame.pSuppRates, pCurrRates, pCurrRates->len + WLAN_IEHDR_LEN);
+	// Copy the extension rate set
 	if (pDevice->byBBType == BB_TYPE_11G) {
 		sFrame.pExtSuppRates = (PWLAN_IE_SUPP_RATES)(sFrame.pBuf + sFrame.len);
 		sFrame.len += pCurrExtSuppRates->len + WLAN_IEHDR_LEN;
 		memcpy(sFrame.pExtSuppRates, pCurrExtSuppRates, pCurrExtSuppRates->len + WLAN_IEHDR_LEN);
 	}
-    pTxPacket->cbMPDULen = sFrame.len;
-    pTxPacket->cbPayloadLen = sFrame.len - WLAN_HDR_ADDR3_LEN;
+	pTxPacket->cbMPDULen = sFrame.len;
+	pTxPacket->cbPayloadLen = sFrame.len - WLAN_HDR_ADDR3_LEN;
 
-    return pTxPacket;
+	return pTxPacket;
 }
 
 static void
@@ -288,11 +288,11 @@ void vRunCommand(struct work_struct *work)
 	if (pDevice->bCmdRunning != true)
 		return;
 
-    spin_lock_irq(&pDevice->lock);
+	spin_lock_irq(&pDevice->lock);
 
-    switch (pDevice->eCommandState) {
+	switch (pDevice->eCommandState) {
 
-    case WLAN_CMD_SCAN_START:
+	case WLAN_CMD_SCAN_START:
 
 		pDevice->byReAssocCount = 0;
 		if (pDevice->bRadioOff == true) {
@@ -307,7 +307,7 @@ void vRunCommand(struct work_struct *work)
 			return;
 		}
 
-            pItemSSID = (PWLAN_IE_SSID)pMgmt->abyScanSSID;
+		pItemSSID = (PWLAN_IE_SSID)pMgmt->abyScanSSID;
 
 		if (pMgmt->uScanChannel == 0)
 			pMgmt->uScanChannel = pDevice->byMinChannel;
@@ -387,11 +387,11 @@ void vRunCommand(struct work_struct *work)
 			}
 		}
 
-            break;
+		break;
 
-    case WLAN_CMD_SCAN_END:
+	case WLAN_CMD_SCAN_END:
 
-            // Set Baseband's sensitivity back.
+		// Set Baseband's sensitivity back.
 		if (pDevice->byBBType != pDevice->byScanBBType) {
 			pDevice->byBBType = pDevice->byScanBBType;
 			CARDvSetBSSMode(pDevice);
@@ -403,29 +403,29 @@ void vRunCommand(struct work_struct *work)
 			BBvUpdatePreEDThreshold(pDevice, false);
 		}
 
-            // Set channel back
-            vAdHocBeaconRestart(pDevice);
-            // Set channel back
-            CARDbSetMediaChannel(pDevice, pMgmt->uCurrChannel);
-            // Set Filter
+		// Set channel back
+		vAdHocBeaconRestart(pDevice);
+		// Set channel back
+		CARDbSetMediaChannel(pDevice, pMgmt->uCurrChannel);
+		// Set Filter
 		if (pMgmt->bCurrBSSIDFilterOn) {
 			MACvRegBitsOn(pDevice, MAC_REG_RCR, RCR_BSSID);
 			pDevice->byRxMode |= RCR_BSSID;
 		}
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning, set back to channel: [%d]\n", pMgmt->uCurrChannel);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning, set back to channel: [%d]\n", pMgmt->uCurrChannel);
 		pMgmt->uScanChannel = 0;
-            pMgmt->eScanState = WMAC_NO_SCANNING;
-            pDevice->bStopDataPkt = false;
+		pMgmt->eScanState = WMAC_NO_SCANNING;
+		pDevice->bStopDataPkt = false;
 
 		/*send scan event to wpa_Supplicant*/
 		PRINT_K("wireless_send_event--->SIOCGIWSCAN(scan done)\n");
 		memset(&wrqu, 0, sizeof(wrqu));
 		wireless_send_event(pDevice->dev, SIOCGIWSCAN, &wrqu, NULL);
 
-            s_bCommandComplete(pDevice);
-            break;
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_CMD_DISASSOCIATE_START:
+	case WLAN_CMD_DISASSOCIATE_START:
 		pDevice->byReAssocCount = 0;
 		if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
 		    (pMgmt->eCurrState != WMAC_STATE_ASSOC)) {
@@ -457,13 +457,13 @@ void vRunCommand(struct work_struct *work)
 			pMgmt->sNodeDBTable[0].bActive = false;
 //			pDevice->bBeaconBufReady = false;
 		}
-            netif_stop_queue(pDevice->dev);
-            if (pDevice->bNeedRadioOFF == true)
-                CARDbRadioPowerOff(pDevice);
-            s_bCommandComplete(pDevice);
-            break;
+		netif_stop_queue(pDevice->dev);
+		if (pDevice->bNeedRadioOFF == true)
+			CARDbRadioPowerOff(pDevice);
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_CMD_SSID_START:
+	case WLAN_CMD_SSID_START:
 
 		pDevice->byReAssocCount = 0;
 		if (pDevice->bRadioOff == true) {
@@ -472,13 +472,13 @@ void vRunCommand(struct work_struct *work)
 			return;
 		}
 
-            memcpy(pMgmt->abyAdHocSSID, pMgmt->abyDesireSSID,
-                              ((PWLAN_IE_SSID)pMgmt->abyDesireSSID)->len + WLAN_IEHDR_LEN);
+		memcpy(pMgmt->abyAdHocSSID, pMgmt->abyDesireSSID,
+		       ((PWLAN_IE_SSID)pMgmt->abyDesireSSID)->len + WLAN_IEHDR_LEN);
 
-            pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
-            pItemSSIDCurr = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" cmd: desire ssid = %s\n", pItemSSID->abySSID);
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" cmd: curr ssid = %s\n", pItemSSIDCurr->abySSID);
+		pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
+		pItemSSIDCurr = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" cmd: desire ssid = %s\n", pItemSSID->abySSID);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" cmd: curr ssid = %s\n", pItemSSIDCurr->abySSID);
 
 		if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Cmd pMgmt->eCurrState == WMAC_STATE_ASSOC\n");
@@ -501,13 +501,13 @@ void vRunCommand(struct work_struct *work)
 			pDevice->bLinkPass = false;
 			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
 		}
-            // set initial state
-            pMgmt->eCurrState = WMAC_STATE_IDLE;
-            pMgmt->eCurrMode = WMAC_MODE_STANDBY;
-	    PSvDisablePowerSaving((void *) pDevice);
-            BSSvClearNodeDBTable(pDevice, 0);
-	    vMgrJoinBSSBegin((void *) pDevice, &Status);
-            // if Infra mode
+		// set initial state
+		pMgmt->eCurrState = WMAC_STATE_IDLE;
+		pMgmt->eCurrMode = WMAC_MODE_STANDBY;
+		PSvDisablePowerSaving((void *) pDevice);
+		BSSvClearNodeDBTable(pDevice, 0);
+		vMgrJoinBSSBegin((void *) pDevice, &Status);
+		// if Infra mode
 		if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED)) {
 			// Call mgr to begin the deauthentication
 			// reason = (3) because sta has left ESS
@@ -584,11 +584,11 @@ void vRunCommand(struct work_struct *work)
 				}
 			}
 		}
-            s_bCommandComplete(pDevice);
-            break;
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_AUTHENTICATE_WAIT:
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_AUTHENTICATE_WAIT\n");
+	case WLAN_AUTHENTICATE_WAIT:
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_AUTHENTICATE_WAIT\n");
 		if (pMgmt->eCurrState == WMAC_STATE_AUTH) {
 			pDevice->byLinkWaitCount = 0;
 			// Call mgr to begin the association
@@ -611,12 +611,12 @@ void vRunCommand(struct work_struct *work)
 			vCommandTimerWait((void *) pDevice, AUTHENTICATE_TIMEOUT/2);
 			return;
 		}
-	          pDevice->byLinkWaitCount = 0;
+		pDevice->byLinkWaitCount = 0;
 
-            s_bCommandComplete(pDevice);
-            break;
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_ASSOCIATE_WAIT:
+	case WLAN_ASSOCIATE_WAIT:
 		if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_ASSOC\n");
 			if (pDevice->ePSMode != WMAC_POWER_CAM) {
@@ -647,10 +647,10 @@ void vRunCommand(struct work_struct *work)
 			return;
 		}
 
-            s_bCommandComplete(pDevice);
-            break;
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_CMD_AP_MODE_START:
+	case WLAN_CMD_AP_MODE_START:
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_AP_MODE_START\n");
 
 		if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
@@ -686,8 +686,8 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-    case WLAN_CMD_TX_PSPACKET_START:
-            // DTIM Multicast tx
+	case WLAN_CMD_TX_PSPACKET_START:
+		// DTIM Multicast tx
 		if (pMgmt->sNodeDBTable[0].bRxPSPoll) {
 			while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[0].sTxPSQueue)) != NULL) {
 				if (skb_queue_empty(&pMgmt->sNodeDBTable[0].sTxPSQueue)) {
@@ -739,12 +739,12 @@ void vRunCommand(struct work_struct *work)
 			}
 		}
 
-            s_bCommandComplete(pDevice);
-            break;
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_CMD_RADIO_START:
+	case WLAN_CMD_RADIO_START:
 
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_RADIO_START\n");
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_RADIO_START\n");
 //		if (pDevice->bRadioCmd == true)
 //			CARDbRadioPowerOn(pDevice);
 //		else
@@ -833,38 +833,38 @@ void vRunCommand(struct work_struct *work)
 			}
 		}
 
-            s_bCommandComplete(pDevice);
-            break;
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_CMD_CHANGE_BBSENSITIVITY_START:
+	case WLAN_CMD_CHANGE_BBSENSITIVITY_START:
 
-            pDevice->bStopDataPkt = true;
-            pDevice->byBBVGACurrent = pDevice->byBBVGANew;
-            BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change sensitivity pDevice->byBBVGACurrent = %x\n", pDevice->byBBVGACurrent);
-            pDevice->bStopDataPkt = false;
-            s_bCommandComplete(pDevice);
-            break;
+		pDevice->bStopDataPkt = true;
+		pDevice->byBBVGACurrent = pDevice->byBBVGANew;
+		BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change sensitivity pDevice->byBBVGACurrent = %x\n", pDevice->byBBVGACurrent);
+		pDevice->bStopDataPkt = false;
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_CMD_TBTT_WAKEUP_START:
-            PSbIsNextTBTTWakeUp(pDevice);
-            s_bCommandComplete(pDevice);
-            break;
+	case WLAN_CMD_TBTT_WAKEUP_START:
+		PSbIsNextTBTTWakeUp(pDevice);
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_CMD_BECON_SEND_START:
-            bMgrPrepareBeaconToSend(pDevice, pMgmt);
-            s_bCommandComplete(pDevice);
-            break;
+	case WLAN_CMD_BECON_SEND_START:
+		bMgrPrepareBeaconToSend(pDevice, pMgmt);
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_CMD_SETPOWER_START:
+	case WLAN_CMD_SETPOWER_START:
 
-            RFbSetPower(pDevice, pDevice->wCurrentRate, pMgmt->uCurrChannel);
+		RFbSetPower(pDevice, pDevice->wCurrentRate, pMgmt->uCurrChannel);
 
-            s_bCommandComplete(pDevice);
-            break;
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_CMD_CHANGE_ANTENNA_START:
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change from Antenna%d to", (int)pDevice->dwRxAntennaSel);
+	case WLAN_CMD_CHANGE_ANTENNA_START:
+		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change from Antenna%d to", (int)pDevice->dwRxAntennaSel);
 		if (pDevice->dwRxAntennaSel == 0) {
 			pDevice->dwRxAntennaSel = 1;
 			if (pDevice->bTxRxAntInv == true)
@@ -878,16 +878,16 @@ void vRunCommand(struct work_struct *work)
 			else
 				BBvSetAntennaMode(pDevice, ANT_RXA);
 		}
-            s_bCommandComplete(pDevice);
-            break;
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_CMD_REMOVE_ALLKEY_START:
-            KeybRemoveAllKey(pDevice, &(pDevice->sKey), pDevice->abyBSSID);
-            s_bCommandComplete(pDevice);
-            break;
+	case WLAN_CMD_REMOVE_ALLKEY_START:
+		KeybRemoveAllKey(pDevice, &(pDevice->sKey), pDevice->abyBSSID);
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_CMD_MAC_DISPOWERSAVING_START:
-            ControlvReadByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
+	case WLAN_CMD_MAC_DISPOWERSAVING_START:
+		ControlvReadByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
 		if ((byData & PSCTL_PS) != 0) {
 			// disable power saving hw function
 			CONTROLnsRequestOut(pDevice,
@@ -898,24 +898,24 @@ void vRunCommand(struct work_struct *work)
 					NULL
 					);
 		}
-            s_bCommandComplete(pDevice);
-            break;
+		s_bCommandComplete(pDevice);
+		break;
 
-    case WLAN_CMD_11H_CHSW_START:
-            CARDbSetMediaChannel(pDevice, pDevice->byNewChannel);
-            pDevice->bChannelSwitch = false;
-            pMgmt->uCurrChannel = pDevice->byNewChannel;
-            pDevice->bStopDataPkt = false;
-            s_bCommandComplete(pDevice);
-            break;
+	case WLAN_CMD_11H_CHSW_START:
+		CARDbSetMediaChannel(pDevice, pDevice->byNewChannel);
+		pDevice->bChannelSwitch = false;
+		pMgmt->uCurrChannel = pDevice->byNewChannel;
+		pDevice->bStopDataPkt = false;
+		s_bCommandComplete(pDevice);
+		break;
 
-    default:
-            s_bCommandComplete(pDevice);
-            break;
-    } //switch
+	default:
+		s_bCommandComplete(pDevice);
+		break;
+	} //switch
 
-    spin_unlock_irq(&pDevice->lock);
-    return;
+	spin_unlock_irq(&pDevice->lock);
+	return;
 }
 
 static int s_bCommandComplete(struct vnt_private *pDevice)
@@ -925,7 +925,7 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 	int bRadioCmd = false;
 	int bForceSCAN = true;
 
-    pDevice->eCommandState = WLAN_CMD_IDLE;
+	pDevice->eCommandState = WLAN_CMD_IDLE;
 	if (pDevice->cbFreeCmdQueue == CMD_Q_SIZE) {
 		//Command Queue Empty
 		pDevice->bCmdRunning = false;
@@ -1015,7 +1015,7 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 		vCommandTimerWait(pDevice, 0);
 	}
 
-    return true;
+	return true;
 }
 
 int bScheduleCommand(struct vnt_private *pDevice,
@@ -1058,13 +1058,13 @@ int bScheduleCommand(struct vnt_private *pDevice,
 		}
 	}
 
-    ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdEnqueueIdx, CMD_Q_SIZE);
-    pDevice->cbFreeCmdQueue--;
+	ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdEnqueueIdx, CMD_Q_SIZE);
+	pDevice->cbFreeCmdQueue--;
 
 	if (pDevice->bCmdRunning == false)
 		s_bCommandComplete(pDevice);
 
-    return (true);
+	return (true);
 
 }
 
@@ -1096,7 +1096,7 @@ static int s_bClearBSSID_SCAN(struct vnt_private *pDevice)
 				break;
 		}
 	}
-    return true;
+	return true;
 }
 
 //mike add:reset command timer

commit cab086d37a8e024717fcd1d666999a05e0430588
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Tue Nov 12 23:05:35 2013 +0530

    staging: vt6656: indented all if-else statement blocks
    
    indented all if-else statement blocks to remove checkpatch
    warnings and errors like indent code wherever possible and
    no spaces at the start of line
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index c07737769e3b..a53a15a60b4e 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -99,21 +99,21 @@ static void vAdHocBeaconStop(struct vnt_private *pDevice)
      *      (3.2) AdHoc channel is in A mode
      */
     bStop = false;
-    if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
-    (pMgmt->eCurrState >= WMAC_STATE_STARTED)) {
-        if ((pMgmt->uIBSSChannel <=  CB_MAX_CHANNEL_24G) &&
-             (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G)) {
-            bStop = true;
-        }
-        if (pMgmt->uIBSSChannel >  CB_MAX_CHANNEL_24G)
-            bStop = true;
-    }
-
-    if (bStop) {
-        //PMESG(("STOP_BEACON: IBSSChannel = %u, ScanChannel = %u\n",
-        //        pMgmt->uIBSSChannel, pMgmt->uScanChannel));
-        MACvRegBitsOff(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
-    }
+	if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
+	    (pMgmt->eCurrState >= WMAC_STATE_STARTED)) {
+		if ((pMgmt->uIBSSChannel <=  CB_MAX_CHANNEL_24G) &&
+		    (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G)) {
+			bStop = true;
+		}
+		if (pMgmt->uIBSSChannel >  CB_MAX_CHANNEL_24G)
+			bStop = true;
+	}
+
+	if (bStop) {
+		//PMESG(("STOP_BEACON: IBSSChannel = %u, ScanChannel = %u\n",
+		//        pMgmt->uIBSSChannel, pMgmt->uScanChannel));
+		MACvRegBitsOff(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
+	}
 
 } /* vAdHocBeaconStop */
 
@@ -140,11 +140,11 @@ static void vAdHocBeaconRestart(struct vnt_private *pDevice)
      *  (1) STA is in AdHoc mode
      *  (2) VT3253 is programmed as automatic Beacon Transmitting
      */
-    if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
-    (pMgmt->eCurrState >= WMAC_STATE_STARTED)) {
-        //PMESG(("RESTART_BEACON\n"));
-        MACvRegBitsOn(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
-    }
+	if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
+	    (pMgmt->eCurrState >= WMAC_STATE_STARTED)) {
+		//PMESG(("RESTART_BEACON\n"));
+		MACvRegBitsOn(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
+	}
 
 }
 
@@ -194,15 +194,15 @@ static void s_vProbeChannel(struct vnt_private *pDevice)
                   (PWLAN_IE_SUPP_RATES)abyCurrExtSuppRatesG
                 );
 
-    if (pTxPacket != NULL) {
-        for (ii = 0; ii < 1; ii++) {
-            if (csMgmt_xmit(pDevice, pTxPacket) != CMD_STATUS_PENDING) {
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request sending fail..\n");
-	    } else {
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request is sending..\n");
-	    }
-        }
-    }
+	if (pTxPacket != NULL) {
+		for (ii = 0; ii < 1; ii++) {
+			if (csMgmt_xmit(pDevice, pTxPacket) != CMD_STATUS_PENDING) {
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request sending fail..\n");
+			} else {
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request is sending..\n");
+			}
+		}
+	}
 
 }
 
@@ -248,11 +248,11 @@ static struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *pDevice,
     sFrame.len += pCurrRates->len + WLAN_IEHDR_LEN;
     memcpy(sFrame.pSuppRates, pCurrRates, pCurrRates->len + WLAN_IEHDR_LEN);
     // Copy the extension rate set
-    if (pDevice->byBBType == BB_TYPE_11G) {
-        sFrame.pExtSuppRates = (PWLAN_IE_SUPP_RATES)(sFrame.pBuf + sFrame.len);
-        sFrame.len += pCurrExtSuppRates->len + WLAN_IEHDR_LEN;
-        memcpy(sFrame.pExtSuppRates, pCurrExtSuppRates, pCurrExtSuppRates->len + WLAN_IEHDR_LEN);
-    }
+	if (pDevice->byBBType == BB_TYPE_11G) {
+		sFrame.pExtSuppRates = (PWLAN_IE_SUPP_RATES)(sFrame.pBuf + sFrame.len);
+		sFrame.len += pCurrExtSuppRates->len + WLAN_IEHDR_LEN;
+		memcpy(sFrame.pExtSuppRates, pCurrExtSuppRates, pCurrExtSuppRates->len + WLAN_IEHDR_LEN);
+	}
     pTxPacket->cbMPDULen = sFrame.len;
     pTxPacket->cbPayloadLen = sFrame.len - WLAN_HDR_ADDR3_LEN;
 
@@ -283,10 +283,10 @@ void vRunCommand(struct work_struct *work)
 	if (pDevice->Flags & fMP_DISCONNECTED)
 		return;
 
-    if (pDevice->dwDiagRefCount != 0)
-        return;
-    if (pDevice->bCmdRunning != true)
-        return;
+	if (pDevice->dwDiagRefCount != 0)
+		return;
+	if (pDevice->bCmdRunning != true)
+		return;
 
     spin_lock_irq(&pDevice->lock);
 
@@ -295,126 +295,123 @@ void vRunCommand(struct work_struct *work)
     case WLAN_CMD_SCAN_START:
 
 		pDevice->byReAssocCount = 0;
-            if (pDevice->bRadioOff == true) {
-                s_bCommandComplete(pDevice);
-                spin_unlock_irq(&pDevice->lock);
-                return;
-            }
-
-            if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
-                s_bCommandComplete(pDevice);
-                spin_unlock_irq(&pDevice->lock);
-                return;
-            }
+		if (pDevice->bRadioOff == true) {
+			s_bCommandComplete(pDevice);
+			spin_unlock_irq(&pDevice->lock);
+			return;
+		}
+
+		if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+			s_bCommandComplete(pDevice);
+			spin_unlock_irq(&pDevice->lock);
+			return;
+		}
 
             pItemSSID = (PWLAN_IE_SSID)pMgmt->abyScanSSID;
 
-            if (pMgmt->uScanChannel == 0)
-                pMgmt->uScanChannel = pDevice->byMinChannel;
-            if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
-		pDevice->eCommandState = WLAN_CMD_SCAN_END;
-                s_bCommandComplete(pDevice);
-                spin_unlock_irq(&pDevice->lock);
-                return;
-
-            } else {
-                if (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel)) {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Invalid channel pMgmt->uScanChannel = %d\n", pMgmt->uScanChannel);
+		if (pMgmt->uScanChannel == 0)
+			pMgmt->uScanChannel = pDevice->byMinChannel;
+		if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
+			pDevice->eCommandState = WLAN_CMD_SCAN_END;
+			s_bCommandComplete(pDevice);
+			spin_unlock_irq(&pDevice->lock);
+			return;
+		} else {
+			if (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel)) {
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Invalid channel pMgmt->uScanChannel = %d\n", pMgmt->uScanChannel);
+				pMgmt->uScanChannel++;
+				s_bCommandComplete(pDevice);
+				spin_unlock_irq(&pDevice->lock);
+				return;
+			}
+			if (pMgmt->uScanChannel == pDevice->byMinChannel) {
+				// pMgmt->eScanType = WMAC_SCAN_ACTIVE;          //mike mark
+				pMgmt->abyScanBSSID[0] = 0xFF;
+				pMgmt->abyScanBSSID[1] = 0xFF;
+				pMgmt->abyScanBSSID[2] = 0xFF;
+				pMgmt->abyScanBSSID[3] = 0xFF;
+				pMgmt->abyScanBSSID[4] = 0xFF;
+				pMgmt->abyScanBSSID[5] = 0xFF;
+				pItemSSID->byElementID = WLAN_EID_SSID;
+				// clear bssid list
+				/* BSSvClearBSSList((void *) pDevice, pDevice->bLinkPass); */
+				pMgmt->eScanState = WMAC_IS_SCANNING;
+				pDevice->byScanBBType = pDevice->byBBType;  //lucas
+				pDevice->bStopDataPkt = true;
+				// Turn off RCR_BSSID filter every time
+				MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_BSSID);
+				pDevice->byRxMode &= ~RCR_BSSID;
+			}
+			//lucas
+			vAdHocBeaconStop(pDevice);
+			if ((pDevice->byBBType != BB_TYPE_11A) &&
+			    (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G)) {
+				pDevice->byBBType = BB_TYPE_11A;
+				CARDvSetBSSMode(pDevice);
+			} else if ((pDevice->byBBType == BB_TYPE_11A) &&
+				   (pMgmt->uScanChannel <= CB_MAX_CHANNEL_24G)) {
+				pDevice->byBBType = BB_TYPE_11G;
+				CARDvSetBSSMode(pDevice);
+			}
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning....  channel: [%d]\n", pMgmt->uScanChannel);
+			// Set channel
+			CARDbSetMediaChannel(pDevice, pMgmt->uScanChannel);
+			// Set Baseband to be more sensitive.
+
+			if (pDevice->bUpdateBBVGA) {
+				BBvSetShortSlotTime(pDevice);
+				BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
+				BBvUpdatePreEDThreshold(pDevice, true);
+			}
 			pMgmt->uScanChannel++;
-                    s_bCommandComplete(pDevice);
-                    spin_unlock_irq(&pDevice->lock);
-                    return;
-                }
-                if (pMgmt->uScanChannel == pDevice->byMinChannel) {
-                   // pMgmt->eScanType = WMAC_SCAN_ACTIVE;          //mike mark
-                    pMgmt->abyScanBSSID[0] = 0xFF;
-                    pMgmt->abyScanBSSID[1] = 0xFF;
-                    pMgmt->abyScanBSSID[2] = 0xFF;
-                    pMgmt->abyScanBSSID[3] = 0xFF;
-                    pMgmt->abyScanBSSID[4] = 0xFF;
-                    pMgmt->abyScanBSSID[5] = 0xFF;
-                    pItemSSID->byElementID = WLAN_EID_SSID;
-                    // clear bssid list
-		    /* BSSvClearBSSList((void *) pDevice,
-		       pDevice->bLinkPass); */
-                    pMgmt->eScanState = WMAC_IS_SCANNING;
-                    pDevice->byScanBBType = pDevice->byBBType;  //lucas
-                    pDevice->bStopDataPkt = true;
-                    // Turn off RCR_BSSID filter every time
-                    MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_BSSID);
-                    pDevice->byRxMode &= ~RCR_BSSID;
-
-                }
-                //lucas
-                vAdHocBeaconStop(pDevice);
-                if ((pDevice->byBBType != BB_TYPE_11A) && (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G)) {
-                    pDevice->byBBType = BB_TYPE_11A;
-                    CARDvSetBSSMode(pDevice);
-                } else if ((pDevice->byBBType == BB_TYPE_11A) && (pMgmt->uScanChannel <= CB_MAX_CHANNEL_24G)) {
-                    pDevice->byBBType = BB_TYPE_11G;
-                    CARDvSetBSSMode(pDevice);
-                }
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning....  channel: [%d]\n", pMgmt->uScanChannel);
-                // Set channel
-                CARDbSetMediaChannel(pDevice, pMgmt->uScanChannel);
-                // Set Baseband to be more sensitive.
-
-                if (pDevice->bUpdateBBVGA) {
-                    BBvSetShortSlotTime(pDevice);
-                    BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
-                    BBvUpdatePreEDThreshold(pDevice, true);
-                }
-                pMgmt->uScanChannel++;
-
-                while (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel) &&
-                        pMgmt->uScanChannel <= pDevice->byMaxChannel){
-                    pMgmt->uScanChannel++;
-                }
-
-                if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
-                    // Set Baseband to be not sensitive and rescan
-                    pDevice->eCommandState = WLAN_CMD_SCAN_END;
-
-                }
-                if ((pMgmt->b11hEnable == false) ||
-                    (pMgmt->uScanChannel < CB_MAX_CHANNEL_24G)) {
-                    s_vProbeChannel(pDevice);
-                    spin_unlock_irq(&pDevice->lock);
-		     vCommandTimerWait((void *) pDevice, 100);
-                    return;
-                } else {
-                    spin_unlock_irq(&pDevice->lock);
-		    vCommandTimerWait((void *) pDevice, WCMD_PASSIVE_SCAN_TIME);
-                    return;
-                }
-
-            }
+
+			while (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel) &&
+				pMgmt->uScanChannel <= pDevice->byMaxChannel){
+				pMgmt->uScanChannel++;
+			}
+
+			if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
+				// Set Baseband to be not sensitive and rescan
+				pDevice->eCommandState = WLAN_CMD_SCAN_END;
+			}
+			if ((pMgmt->b11hEnable == false) ||
+			    (pMgmt->uScanChannel < CB_MAX_CHANNEL_24G)) {
+				s_vProbeChannel(pDevice);
+				spin_unlock_irq(&pDevice->lock);
+				vCommandTimerWait((void *) pDevice, 100);
+				return;
+			} else {
+				spin_unlock_irq(&pDevice->lock);
+				vCommandTimerWait((void *) pDevice, WCMD_PASSIVE_SCAN_TIME);
+				return;
+			}
+		}
 
             break;
 
     case WLAN_CMD_SCAN_END:
 
             // Set Baseband's sensitivity back.
-            if (pDevice->byBBType != pDevice->byScanBBType) {
-                pDevice->byBBType = pDevice->byScanBBType;
-                CARDvSetBSSMode(pDevice);
-            }
+		if (pDevice->byBBType != pDevice->byScanBBType) {
+			pDevice->byBBType = pDevice->byScanBBType;
+			CARDvSetBSSMode(pDevice);
+		}
 
-            if (pDevice->bUpdateBBVGA) {
-                BBvSetShortSlotTime(pDevice);
-                BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
-                BBvUpdatePreEDThreshold(pDevice, false);
-            }
+		if (pDevice->bUpdateBBVGA) {
+			BBvSetShortSlotTime(pDevice);
+			BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
+			BBvUpdatePreEDThreshold(pDevice, false);
+		}
 
             // Set channel back
             vAdHocBeaconRestart(pDevice);
             // Set channel back
             CARDbSetMediaChannel(pDevice, pMgmt->uCurrChannel);
             // Set Filter
-            if (pMgmt->bCurrBSSIDFilterOn) {
-                MACvRegBitsOn(pDevice, MAC_REG_RCR, RCR_BSSID);
-                pDevice->byRxMode |= RCR_BSSID;
-            }
+		if (pMgmt->bCurrBSSIDFilterOn) {
+			MACvRegBitsOn(pDevice, MAC_REG_RCR, RCR_BSSID);
+			pDevice->byRxMode |= RCR_BSSID;
+		}
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning, set back to channel: [%d]\n", pMgmt->uCurrChannel);
 		pMgmt->uScanChannel = 0;
             pMgmt->eScanState = WMAC_NO_SCANNING;
@@ -430,37 +427,36 @@ void vRunCommand(struct work_struct *work)
 
     case WLAN_CMD_DISASSOCIATE_START:
 		pDevice->byReAssocCount = 0;
-            if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
-                (pMgmt->eCurrState != WMAC_STATE_ASSOC)) {
-                s_bCommandComplete(pDevice);
-                spin_unlock_irq(&pDevice->lock);
-                return;
-            } else {
-
-		      pDevice->bwextstep0 = false;
-                        pDevice->bwextstep1 = false;
-                        pDevice->bwextstep2 = false;
-                        pDevice->bwextstep3 = false;
-		   pDevice->bWPASuppWextEnabled = false;
-                   pDevice->fWPA_Authened = false;
-
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Send Disassociation Packet..\n");
-                // reason = 8 : disassoc because sta has left
-		vMgrDisassocBeginSta((void *) pDevice,
-				     pMgmt,
-				     pMgmt->abyCurrBSSID,
-				     (8),
-				     &Status);
-                pDevice->bLinkPass = false;
-                ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
-                // unlock command busy
-                pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
-                pItemSSID->len = 0;
-                memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
-                pMgmt->eCurrState = WMAC_STATE_IDLE;
-                pMgmt->sNodeDBTable[0].bActive = false;
-//                pDevice->bBeaconBufReady = false;
-            }
+		if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
+		    (pMgmt->eCurrState != WMAC_STATE_ASSOC)) {
+			s_bCommandComplete(pDevice);
+			spin_unlock_irq(&pDevice->lock);
+			return;
+		} else {
+			pDevice->bwextstep0 = false;
+			pDevice->bwextstep1 = false;
+			pDevice->bwextstep2 = false;
+			pDevice->bwextstep3 = false;
+			pDevice->bWPASuppWextEnabled = false;
+			pDevice->fWPA_Authened = false;
+
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Send Disassociation Packet..\n");
+			// reason = 8 : disassoc because sta has left
+			vMgrDisassocBeginSta((void *) pDevice,
+					     pMgmt,
+					     pMgmt->abyCurrBSSID,
+					     (8),
+					     &Status);
+			pDevice->bLinkPass = false;
+			ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
+			// unlock command busy
+			pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
+			pItemSSID->len = 0;
+			memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
+			pMgmt->eCurrState = WMAC_STATE_IDLE;
+			pMgmt->sNodeDBTable[0].bActive = false;
+//			pDevice->bBeaconBufReady = false;
+		}
             netif_stop_queue(pDevice->dev);
             if (pDevice->bNeedRadioOFF == true)
                 CARDbRadioPowerOff(pDevice);
@@ -470,11 +466,11 @@ void vRunCommand(struct work_struct *work)
     case WLAN_CMD_SSID_START:
 
 		pDevice->byReAssocCount = 0;
-            if (pDevice->bRadioOff == true) {
-                s_bCommandComplete(pDevice);
-                spin_unlock_irq(&pDevice->lock);
-                return;
-            }
+		if (pDevice->bRadioOff == true) {
+			s_bCommandComplete(pDevice);
+			spin_unlock_irq(&pDevice->lock);
+			return;
+		}
 
             memcpy(pMgmt->abyAdHocSSID, pMgmt->abyDesireSSID,
                               ((PWLAN_IE_SSID)pMgmt->abyDesireSSID)->len + WLAN_IEHDR_LEN);
@@ -484,28 +480,27 @@ void vRunCommand(struct work_struct *work)
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" cmd: desire ssid = %s\n", pItemSSID->abySSID);
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" cmd: curr ssid = %s\n", pItemSSIDCurr->abySSID);
 
-            if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Cmd pMgmt->eCurrState == WMAC_STATE_ASSOC\n");
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pItemSSID->len =%d\n", pItemSSID->len);
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pItemSSIDCurr->len = %d\n", pItemSSIDCurr->len);
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" desire ssid = %s\n", pItemSSID->abySSID);
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" curr ssid = %s\n", pItemSSIDCurr->abySSID);
-            }
-
-            if ((pMgmt->eCurrState == WMAC_STATE_ASSOC) ||
-                ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED))) {
-
-                if (pItemSSID->len == pItemSSIDCurr->len) {
-                    if (memcmp(pItemSSID->abySSID, pItemSSIDCurr->abySSID, pItemSSID->len) == 0) {
-                        s_bCommandComplete(pDevice);
-                        spin_unlock_irq(&pDevice->lock);
-                        return;
-                    }
-                }
-                netif_stop_queue(pDevice->dev);
-                pDevice->bLinkPass = false;
-                ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
-            }
+		if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Cmd pMgmt->eCurrState == WMAC_STATE_ASSOC\n");
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pItemSSID->len =%d\n", pItemSSID->len);
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pItemSSIDCurr->len = %d\n", pItemSSIDCurr->len);
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" desire ssid = %s\n", pItemSSID->abySSID);
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" curr ssid = %s\n", pItemSSIDCurr->abySSID);
+		}
+
+		if ((pMgmt->eCurrState == WMAC_STATE_ASSOC) ||
+		    ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED))) {
+			if (pItemSSID->len == pItemSSIDCurr->len) {
+				if (memcmp(pItemSSID->abySSID, pItemSSIDCurr->abySSID, pItemSSID->len) == 0) {
+					s_bCommandComplete(pDevice);
+					spin_unlock_irq(&pDevice->lock);
+					return;
+				}
+			}
+			netif_stop_queue(pDevice->dev);
+			pDevice->bLinkPass = false;
+			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
+		}
             // set initial state
             pMgmt->eCurrState = WMAC_STATE_IDLE;
             pMgmt->eCurrMode = WMAC_MODE_STANDBY;
@@ -513,145 +508,144 @@ void vRunCommand(struct work_struct *work)
             BSSvClearNodeDBTable(pDevice, 0);
 	    vMgrJoinBSSBegin((void *) pDevice, &Status);
             // if Infra mode
-            if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED)) {
-                // Call mgr to begin the deauthentication
-                // reason = (3) because sta has left ESS
-	      if (pMgmt->eCurrState >= WMAC_STATE_AUTH) {
-		vMgrDeAuthenBeginSta((void *)pDevice,
-				     pMgmt,
-				     pMgmt->abyCurrBSSID,
-				     (3),
-				     &Status);
-	      }
-                // Call mgr to begin the authentication
-		vMgrAuthenBeginSta((void *) pDevice, pMgmt, &Status);
-                if (Status == CMD_STATUS_SUCCESS) {
-		   pDevice->byLinkWaitCount = 0;
-                    pDevice->eCommandState = WLAN_AUTHENTICATE_WAIT;
-		    vCommandTimerWait((void *) pDevice, AUTHENTICATE_TIMEOUT);
-                    spin_unlock_irq(&pDevice->lock);
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Set eCommandState = WLAN_AUTHENTICATE_WAIT\n");
-                    return;
-                }
-            }
-            // if Adhoc mode
-            else if (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
-                if (pMgmt->eCurrState == WMAC_STATE_JOINTED) {
-                    if (netif_queue_stopped(pDevice->dev))
-                        netif_wake_queue(pDevice->dev);
-                    pDevice->bLinkPass = true;
-                    ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
-                    pMgmt->sNodeDBTable[0].bActive = true;
-                    pMgmt->sNodeDBTable[0].uInActiveCount = 0;
-                } else {
-                    // start own IBSS
-		    DBG_PRT(MSG_LEVEL_DEBUG,
-			    KERN_INFO "CreateOwn IBSS by CurrMode = IBSS_STA\n");
-		    vMgrCreateOwnIBSS((void *) pDevice, &Status);
-                    if (Status != CMD_STATUS_SUCCESS) {
-			DBG_PRT(MSG_LEVEL_DEBUG,
-				KERN_INFO "WLAN_CMD_IBSS_CREATE fail!\n");
-                    }
-                    BSSvAddMulticastNode(pDevice);
-                }
-                s_bClearBSSID_SCAN(pDevice);
-            }
-            // if SSID not found
-            else if (pMgmt->eCurrMode == WMAC_MODE_STANDBY) {
-                if (pMgmt->eConfigMode == WMAC_CONFIG_IBSS_STA ||
-                    pMgmt->eConfigMode == WMAC_CONFIG_AUTO) {
-                    // start own IBSS
-			DBG_PRT(MSG_LEVEL_DEBUG,
-				KERN_INFO "CreateOwn IBSS by CurrMode = STANDBY\n");
-		    vMgrCreateOwnIBSS((void *) pDevice, &Status);
-                    if (Status != CMD_STATUS_SUCCESS) {
-			DBG_PRT(MSG_LEVEL_DEBUG,
-				KERN_INFO "WLAN_CMD_IBSS_CREATE fail!\n");
-                    }
-                    BSSvAddMulticastNode(pDevice);
-                    s_bClearBSSID_SCAN(pDevice);
+		if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED)) {
+			// Call mgr to begin the deauthentication
+			// reason = (3) because sta has left ESS
+			if (pMgmt->eCurrState >= WMAC_STATE_AUTH) {
+				vMgrDeAuthenBeginSta((void *)pDevice,
+						     pMgmt,
+						     pMgmt->abyCurrBSSID,
+						     (3),
+						     &Status);
+			}
+			// Call mgr to begin the authentication
+			vMgrAuthenBeginSta((void *) pDevice, pMgmt, &Status);
+			if (Status == CMD_STATUS_SUCCESS) {
+				pDevice->byLinkWaitCount = 0;
+				pDevice->eCommandState = WLAN_AUTHENTICATE_WAIT;
+				vCommandTimerWait((void *) pDevice, AUTHENTICATE_TIMEOUT);
+				spin_unlock_irq(&pDevice->lock);
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Set eCommandState = WLAN_AUTHENTICATE_WAIT\n");
+				return;
+			}
+		}
+		// if Adhoc mode
+		else if (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
+			if (pMgmt->eCurrState == WMAC_STATE_JOINTED) {
+				if (netif_queue_stopped(pDevice->dev))
+					netif_wake_queue(pDevice->dev);
+				pDevice->bLinkPass = true;
+				ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
+				pMgmt->sNodeDBTable[0].bActive = true;
+				pMgmt->sNodeDBTable[0].uInActiveCount = 0;
+			} else {
+				// start own IBSS
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "CreateOwn IBSS by CurrMode = IBSS_STA\n");
+				vMgrCreateOwnIBSS((void *) pDevice, &Status);
+				if (Status != CMD_STATUS_SUCCESS) {
+					DBG_PRT(MSG_LEVEL_DEBUG,
+						KERN_INFO "WLAN_CMD_IBSS_CREATE fail!\n");
+				}
+				BSSvAddMulticastNode(pDevice);
+			}
+			s_bClearBSSID_SCAN(pDevice);
+		}
+		// if SSID not found
+		else if (pMgmt->eCurrMode == WMAC_MODE_STANDBY) {
+			if (pMgmt->eConfigMode == WMAC_CONFIG_IBSS_STA ||
+			    pMgmt->eConfigMode == WMAC_CONFIG_AUTO) {
+				// start own IBSS
+				DBG_PRT(MSG_LEVEL_DEBUG,
+					KERN_INFO "CreateOwn IBSS by CurrMode = STANDBY\n");
+				vMgrCreateOwnIBSS((void *) pDevice, &Status);
+				if (Status != CMD_STATUS_SUCCESS) {
+					DBG_PRT(MSG_LEVEL_DEBUG,
+						KERN_INFO "WLAN_CMD_IBSS_CREATE fail!\n");
+				}
+				BSSvAddMulticastNode(pDevice);
+				s_bClearBSSID_SCAN(pDevice);
 /*
-                    pDevice->bLinkPass = true;
-                    ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
-                    if (netif_queue_stopped(pDevice->dev)){
-                        netif_wake_queue(pDevice->dev);
-                    }
-                    s_bClearBSSID_SCAN(pDevice);
+				pDevice->bLinkPass = true;
+				ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
+				if (netif_queue_stopped(pDevice->dev)){
+					netif_wake_queue(pDevice->dev);
+				}
+				s_bClearBSSID_SCAN(pDevice);
 */
-                } else {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Disconnect SSID none\n");
-                    // if(pDevice->bWPASuppWextEnabled == true)
-                        {
-                  	union iwreq_data  wrqu;
-                  	memset(&wrqu, 0, sizeof(wrqu));
-                          wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-                  	PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated:vMgrJoinBSSBegin Fail !!)\n");
-                  	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
-                       }
-                }
-            }
+			} else {
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Disconnect SSID none\n");
+				// if(pDevice->bWPASuppWextEnabled == true)
+				{
+					union iwreq_data  wrqu;
+					memset(&wrqu, 0, sizeof(wrqu));
+					wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+					PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated:vMgrJoinBSSBegin Fail !!)\n");
+					wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
+				}
+			}
+		}
             s_bCommandComplete(pDevice);
             break;
 
     case WLAN_AUTHENTICATE_WAIT:
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_AUTHENTICATE_WAIT\n");
-            if (pMgmt->eCurrState == WMAC_STATE_AUTH) {
-		pDevice->byLinkWaitCount = 0;
-                // Call mgr to begin the association
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_AUTH\n");
-		vMgrAssocBeginSta((void *) pDevice, pMgmt, &Status);
-                if (Status == CMD_STATUS_SUCCESS) {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState = WLAN_ASSOCIATE_WAIT\n");
-		  pDevice->byLinkWaitCount = 0;
-                    pDevice->eCommandState = WLAN_ASSOCIATE_WAIT;
-		    vCommandTimerWait((void *) pDevice, ASSOCIATE_TIMEOUT);
-                    spin_unlock_irq(&pDevice->lock);
-                    return;
-                }
-            } else if (pMgmt->eCurrState < WMAC_STATE_AUTHPENDING) {
-               printk("WLAN_AUTHENTICATE_WAIT:Authen Fail???\n");
-	   } else if (pDevice->byLinkWaitCount <= 4) {    //mike add:wait another 2 sec if authenticated_frame delay!
-                pDevice->byLinkWaitCount++;
-	       printk("WLAN_AUTHENTICATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
-	       spin_unlock_irq(&pDevice->lock);
-	       vCommandTimerWait((void *) pDevice, AUTHENTICATE_TIMEOUT/2);
-	       return;
-	   }
+		if (pMgmt->eCurrState == WMAC_STATE_AUTH) {
+			pDevice->byLinkWaitCount = 0;
+			// Call mgr to begin the association
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_AUTH\n");
+			vMgrAssocBeginSta((void *) pDevice, pMgmt, &Status);
+			if (Status == CMD_STATUS_SUCCESS) {
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState = WLAN_ASSOCIATE_WAIT\n");
+				pDevice->byLinkWaitCount = 0;
+				pDevice->eCommandState = WLAN_ASSOCIATE_WAIT;
+				vCommandTimerWait((void *) pDevice, ASSOCIATE_TIMEOUT);
+				spin_unlock_irq(&pDevice->lock);
+				return;
+			}
+		} else if (pMgmt->eCurrState < WMAC_STATE_AUTHPENDING) {
+			printk("WLAN_AUTHENTICATE_WAIT:Authen Fail???\n");
+		} else if (pDevice->byLinkWaitCount <= 4) {    //mike add:wait another 2 sec if authenticated_frame delay!
+			pDevice->byLinkWaitCount++;
+			printk("WLAN_AUTHENTICATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
+			spin_unlock_irq(&pDevice->lock);
+			vCommandTimerWait((void *) pDevice, AUTHENTICATE_TIMEOUT/2);
+			return;
+		}
 	          pDevice->byLinkWaitCount = 0;
 
             s_bCommandComplete(pDevice);
             break;
 
     case WLAN_ASSOCIATE_WAIT:
-            if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_ASSOC\n");
-                if (pDevice->ePSMode != WMAC_POWER_CAM) {
-			PSvEnablePowerSaving((void *) pDevice,
-					     pMgmt->wListenInterval);
-                }
+		if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_ASSOC\n");
+			if (pDevice->ePSMode != WMAC_POWER_CAM) {
+				PSvEnablePowerSaving((void *) pDevice,
+						pMgmt->wListenInterval);
+			}
 /*
-                if (pMgmt->eAuthenMode >= WMAC_AUTH_WPA) {
-                    KeybRemoveAllKey(pDevice, &(pDevice->sKey), pDevice->abyBSSID);
-                }
+			if (pMgmt->eAuthenMode >= WMAC_AUTH_WPA) {
+				KeybRemoveAllKey(pDevice, &(pDevice->sKey), pDevice->abyBSSID);
+			}
 */
-                pDevice->byLinkWaitCount = 0;
-                pDevice->byReAssocCount = 0;
-                pDevice->bLinkPass = true;
-                ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
-                s_bClearBSSID_SCAN(pDevice);
-
-                if (netif_queue_stopped(pDevice->dev))
-                    netif_wake_queue(pDevice->dev);
-
-            } else if (pMgmt->eCurrState < WMAC_STATE_ASSOCPENDING) {
-               printk("WLAN_ASSOCIATE_WAIT:Association Fail???\n");
-	   } else if (pDevice->byLinkWaitCount <= 4) {    //mike add:wait another 2 sec if associated_frame delay!
-                pDevice->byLinkWaitCount++;
-	       printk("WLAN_ASSOCIATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
-	       spin_unlock_irq(&pDevice->lock);
-	       vCommandTimerWait((void *) pDevice, ASSOCIATE_TIMEOUT/2);
-	       return;
-	   }
+			pDevice->byLinkWaitCount = 0;
+			pDevice->byReAssocCount = 0;
+			pDevice->bLinkPass = true;
+			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
+			s_bClearBSSID_SCAN(pDevice);
+
+			if (netif_queue_stopped(pDevice->dev))
+				netif_wake_queue(pDevice->dev);
+
+		} else if (pMgmt->eCurrState < WMAC_STATE_ASSOCPENDING) {
+			printk("WLAN_ASSOCIATE_WAIT:Association Fail???\n");
+		} else if (pDevice->byLinkWaitCount <= 4) {    //mike add:wait another 2 sec if associated_frame delay!
+			pDevice->byLinkWaitCount++;
+			printk("WLAN_ASSOCIATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
+			spin_unlock_irq(&pDevice->lock);
+			vCommandTimerWait((void *) pDevice, ASSOCIATE_TIMEOUT/2);
+			return;
+		}
 
             s_bCommandComplete(pDevice);
             break;
@@ -659,91 +653,91 @@ void vRunCommand(struct work_struct *work)
     case WLAN_CMD_AP_MODE_START:
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_AP_MODE_START\n");
 
-            if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-		cancel_delayed_work_sync(&pDevice->second_callback_work);
-                pMgmt->eCurrState = WMAC_STATE_IDLE;
-                pMgmt->eCurrMode = WMAC_MODE_STANDBY;
-                pDevice->bLinkPass = false;
-                ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
-                if (pDevice->bEnableHostWEP == true)
-                    BSSvClearNodeDBTable(pDevice, 1);
-                else
-                    BSSvClearNodeDBTable(pDevice, 0);
-                pDevice->uAssocCount = 0;
-                pMgmt->eCurrState = WMAC_STATE_IDLE;
-                pDevice->bFixRate = false;
-
-		vMgrCreateOwnIBSS((void *) pDevice, &Status);
-		if (Status != CMD_STATUS_SUCCESS) {
-			DBG_PRT(MSG_LEVEL_DEBUG,
-				KERN_INFO "vMgrCreateOwnIBSS fail!\n");
-                }
-                // always turn off unicast bit
-                MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_UNICAST);
-                pDevice->byRxMode &= ~RCR_UNICAST;
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wcmd: rx_mode = %x\n", pDevice->byRxMode);
-                BSSvAddMulticastNode(pDevice);
-                if (netif_queue_stopped(pDevice->dev))
-                    netif_wake_queue(pDevice->dev);
-                pDevice->bLinkPass = true;
-                ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
-		schedule_delayed_work(&pDevice->second_callback_work, HZ);
-            }
+		if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
+			cancel_delayed_work_sync(&pDevice->second_callback_work);
+			pMgmt->eCurrState = WMAC_STATE_IDLE;
+			pMgmt->eCurrMode = WMAC_MODE_STANDBY;
+			pDevice->bLinkPass = false;
+			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
+			if (pDevice->bEnableHostWEP == true)
+				BSSvClearNodeDBTable(pDevice, 1);
+			else
+				BSSvClearNodeDBTable(pDevice, 0);
+			pDevice->uAssocCount = 0;
+			pMgmt->eCurrState = WMAC_STATE_IDLE;
+			pDevice->bFixRate = false;
+
+			vMgrCreateOwnIBSS((void *) pDevice, &Status);
+			if (Status != CMD_STATUS_SUCCESS) {
+				DBG_PRT(MSG_LEVEL_DEBUG,
+					KERN_INFO "vMgrCreateOwnIBSS fail!\n");
+			}
+			// always turn off unicast bit
+			MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_UNICAST);
+			pDevice->byRxMode &= ~RCR_UNICAST;
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wcmd: rx_mode = %x\n", pDevice->byRxMode);
+			BSSvAddMulticastNode(pDevice);
+			if (netif_queue_stopped(pDevice->dev))
+				netif_wake_queue(pDevice->dev);
+			pDevice->bLinkPass = true;
+			ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
+			schedule_delayed_work(&pDevice->second_callback_work, HZ);
+		}
             s_bCommandComplete(pDevice);
             break;
 
     case WLAN_CMD_TX_PSPACKET_START:
             // DTIM Multicast tx
-            if (pMgmt->sNodeDBTable[0].bRxPSPoll) {
-                while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[0].sTxPSQueue)) != NULL) {
-                    if (skb_queue_empty(&pMgmt->sNodeDBTable[0].sTxPSQueue)) {
-                        pMgmt->abyPSTxMap[0] &= ~byMask[0];
-                        pDevice->bMoreData = false;
-                    } else {
-                        pDevice->bMoreData = true;
-                    }
-
-                    if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0)
-                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Multicast ps tx fail\n");
-
-                    pMgmt->sNodeDBTable[0].wEnQueueCnt--;
-                }
-            }
+		if (pMgmt->sNodeDBTable[0].bRxPSPoll) {
+			while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[0].sTxPSQueue)) != NULL) {
+				if (skb_queue_empty(&pMgmt->sNodeDBTable[0].sTxPSQueue)) {
+					pMgmt->abyPSTxMap[0] &= ~byMask[0];
+					pDevice->bMoreData = false;
+				} else {
+					pDevice->bMoreData = true;
+				}
+
+				if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0)
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Multicast ps tx fail\n");
+
+				pMgmt->sNodeDBTable[0].wEnQueueCnt--;
+			}
+		}
 
             // PS nodes tx
-            for (ii = 1; ii < (MAX_NODE_NUM + 1); ii++) {
-                if (pMgmt->sNodeDBTable[ii].bActive &&
-                    pMgmt->sNodeDBTable[ii].bRxPSPoll) {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Index=%d Enqueu Cnt= %d\n",
-                               ii, pMgmt->sNodeDBTable[ii].wEnQueueCnt);
-                    while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) != NULL) {
-                        if (skb_queue_empty(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) {
-                            // clear tx map
-                            pMgmt->abyPSTxMap[pMgmt->sNodeDBTable[ii].wAID >> 3] &=
-                                    ~byMask[pMgmt->sNodeDBTable[ii].wAID & 7];
-                            pDevice->bMoreData = false;
-                        } else {
-                            pDevice->bMoreData = true;
-                        }
-
-                        if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0)
-                            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "sta ps tx fail\n");
-
-                        pMgmt->sNodeDBTable[ii].wEnQueueCnt--;
-                        // check if sta ps enable, wait next pspoll
-                        // if sta ps disable, send all pending buffers.
-                        if (pMgmt->sNodeDBTable[ii].bPSEnable)
-                            break;
-                    }
-                    if (skb_queue_empty(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) {
-                        // clear tx map
-                        pMgmt->abyPSTxMap[pMgmt->sNodeDBTable[ii].wAID >> 3] &=
-                                    ~byMask[pMgmt->sNodeDBTable[ii].wAID & 7];
-                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Index=%d PS queue clear\n", ii);
-                    }
-                    pMgmt->sNodeDBTable[ii].bRxPSPoll = false;
-                }
-            }
+		for (ii = 1; ii < (MAX_NODE_NUM + 1); ii++) {
+			if (pMgmt->sNodeDBTable[ii].bActive &&
+			    pMgmt->sNodeDBTable[ii].bRxPSPoll) {
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Index=%d Enqueu Cnt= %d\n",
+						ii, pMgmt->sNodeDBTable[ii].wEnQueueCnt);
+				while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) != NULL) {
+					if (skb_queue_empty(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) {
+						// clear tx map
+						pMgmt->abyPSTxMap[pMgmt->sNodeDBTable[ii].wAID >> 3] &=
+									~byMask[pMgmt->sNodeDBTable[ii].wAID & 7];
+						pDevice->bMoreData = false;
+					} else {
+						pDevice->bMoreData = true;
+					}
+
+					if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0)
+						DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "sta ps tx fail\n");
+
+					pMgmt->sNodeDBTable[ii].wEnQueueCnt--;
+					// check if sta ps enable, wait next pspoll
+					// if sta ps disable, send all pending buffers.
+					if (pMgmt->sNodeDBTable[ii].bPSEnable)
+						break;
+				}
+				if (skb_queue_empty(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) {
+					// clear tx map
+					pMgmt->abyPSTxMap[pMgmt->sNodeDBTable[ii].wAID >> 3] &=
+							~byMask[pMgmt->sNodeDBTable[ii].wAID & 7];
+					DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Index=%d PS queue clear\n", ii);
+				}
+				pMgmt->sNodeDBTable[ii].bRxPSPoll = false;
+			}
+		}
 
             s_bCommandComplete(pDevice);
             break;
@@ -751,94 +745,93 @@ void vRunCommand(struct work_struct *work)
     case WLAN_CMD_RADIO_START:
 
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_RADIO_START\n");
-       //     if (pDevice->bRadioCmd == true)
-       //         CARDbRadioPowerOn(pDevice);
-       //     else
-       //         CARDbRadioPowerOff(pDevice);
-
-       {
-	       int ntStatus = STATUS_SUCCESS;
-        u8            byTmp;
-
-        ntStatus = CONTROLnsRequestIn(pDevice,
-                                    MESSAGE_TYPE_READ,
-                                    MAC_REG_GPIOCTL1,
-                                    MESSAGE_REQUEST_MACREG,
-                                    1,
-                                    &byTmp);
-
-        if (ntStatus != STATUS_SUCCESS) {
-                s_bCommandComplete(pDevice);
-                spin_unlock_irq(&pDevice->lock);
-                return;
-        }
-        if ((byTmp & GPIO3_DATA) == 0) {
-	    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_OFF........................\n");
-                // Old commands are useless.
-                // empty command Q
-	       pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
-                pDevice->uCmdDequeueIdx = 0;
-                pDevice->uCmdEnqueueIdx = 0;
-                //0415pDevice->bCmdRunning = false;
-                pDevice->bCmdClear = true;
-                pDevice->bStopTx0Pkt = false;
-                pDevice->bStopDataPkt = true;
-
-                pDevice->byKeyIndex = 0;
-                pDevice->bTransmitKey = false;
-	    spin_unlock_irq(&pDevice->lock);
-	    KeyvInitTable(pDevice, &pDevice->sKey);
-	    spin_lock_irq(&pDevice->lock);
-	       pMgmt->byCSSPK = KEY_CTL_NONE;
-                pMgmt->byCSSGK = KEY_CTL_NONE;
-
-	  if (pDevice->bLinkPass == true) {
-                // reason = 8 : disassoc because sta has left
-		vMgrDisassocBeginSta((void *) pDevice,
-				     pMgmt,
-				     pMgmt->abyCurrBSSID,
-				     (8),
-				     &Status);
-                       pDevice->bLinkPass = false;
-                // unlock command busy
-                        pMgmt->eCurrState = WMAC_STATE_IDLE;
-                        pMgmt->sNodeDBTable[0].bActive = false;
-                    // if(pDevice->bWPASuppWextEnabled == true)
-                        {
-                  	union iwreq_data  wrqu;
-                  	memset(&wrqu, 0, sizeof(wrqu));
-                          wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-                  	PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated)\n");
-                  	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
-                       }
-	  	}
-	               pDevice->bwextstep0 = false;
-                        pDevice->bwextstep1 = false;
-                        pDevice->bwextstep2 = false;
-                        pDevice->bwextstep3 = false;
-		      pDevice->bWPASuppWextEnabled = false;
-	                  //clear current SSID
-                  pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
-                  pItemSSID->len = 0;
-                  memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
-                //clear desired SSID
-                pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
-                pItemSSID->len = 0;
-                memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
-
-	    netif_stop_queue(pDevice->dev);
-	    CARDbRadioPowerOff(pDevice);
-             MACvRegBitsOn(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
-	    ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_OFF);
-	    pDevice->bHWRadioOff = true;
-        } else {
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_ON........................\n");
-            pDevice->bHWRadioOff = false;
-                CARDbRadioPowerOn(pDevice);
-            MACvRegBitsOff(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
-            ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_ON);
-        }
-      }
+//		if (pDevice->bRadioCmd == true)
+//			CARDbRadioPowerOn(pDevice);
+//		else
+//			CARDbRadioPowerOff(pDevice);
+		{
+			int ntStatus = STATUS_SUCCESS;
+			u8            byTmp;
+
+			ntStatus = CONTROLnsRequestIn(pDevice,
+					MESSAGE_TYPE_READ,
+					MAC_REG_GPIOCTL1,
+					MESSAGE_REQUEST_MACREG,
+					1,
+					&byTmp);
+
+			if (ntStatus != STATUS_SUCCESS) {
+				s_bCommandComplete(pDevice);
+				spin_unlock_irq(&pDevice->lock);
+				return;
+			}
+			if ((byTmp & GPIO3_DATA) == 0) {
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_OFF........................\n");
+				// Old commands are useless.
+				// empty command Q
+				pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
+				pDevice->uCmdDequeueIdx = 0;
+				pDevice->uCmdEnqueueIdx = 0;
+				//0415pDevice->bCmdRunning = false;
+				pDevice->bCmdClear = true;
+				pDevice->bStopTx0Pkt = false;
+				pDevice->bStopDataPkt = true;
+
+				pDevice->byKeyIndex = 0;
+				pDevice->bTransmitKey = false;
+				spin_unlock_irq(&pDevice->lock);
+				KeyvInitTable(pDevice, &pDevice->sKey);
+				spin_lock_irq(&pDevice->lock);
+				pMgmt->byCSSPK = KEY_CTL_NONE;
+				pMgmt->byCSSGK = KEY_CTL_NONE;
+
+				if (pDevice->bLinkPass == true) {
+					// reason = 8 : disassoc because sta has left
+					vMgrDisassocBeginSta((void *) pDevice,
+							pMgmt,
+							pMgmt->abyCurrBSSID,
+							(8),
+							&Status);
+					pDevice->bLinkPass = false;
+					// unlock command busy
+					pMgmt->eCurrState = WMAC_STATE_IDLE;
+					pMgmt->sNodeDBTable[0].bActive = false;
+					// if(pDevice->bWPASuppWextEnabled == true)
+					{
+						union iwreq_data  wrqu;
+						memset(&wrqu, 0, sizeof(wrqu));
+						wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+						PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated)\n");
+						wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
+					}
+				}
+				pDevice->bwextstep0 = false;
+				pDevice->bwextstep1 = false;
+				pDevice->bwextstep2 = false;
+				pDevice->bwextstep3 = false;
+				pDevice->bWPASuppWextEnabled = false;
+				//clear current SSID
+				pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
+				pItemSSID->len = 0;
+				memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
+				//clear desired SSID
+				pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
+				pItemSSID->len = 0;
+				memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
+
+				netif_stop_queue(pDevice->dev);
+				CARDbRadioPowerOff(pDevice);
+				MACvRegBitsOn(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
+				ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_OFF);
+				pDevice->bHWRadioOff = true;
+			} else {
+				DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_ON........................\n");
+				pDevice->bHWRadioOff = false;
+				CARDbRadioPowerOn(pDevice);
+				MACvRegBitsOff(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
+				ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_ON);
+			}
+		}
 
             s_bCommandComplete(pDevice);
             break;
@@ -872,19 +865,19 @@ void vRunCommand(struct work_struct *work)
 
     case WLAN_CMD_CHANGE_ANTENNA_START:
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change from Antenna%d to", (int)pDevice->dwRxAntennaSel);
-            if (pDevice->dwRxAntennaSel == 0) {
-                pDevice->dwRxAntennaSel = 1;
-                if (pDevice->bTxRxAntInv == true)
-                    BBvSetAntennaMode(pDevice, ANT_RXA);
-                else
-                    BBvSetAntennaMode(pDevice, ANT_RXB);
-            } else {
-                pDevice->dwRxAntennaSel = 0;
-                if (pDevice->bTxRxAntInv == true)
-                    BBvSetAntennaMode(pDevice, ANT_RXB);
-                else
-                    BBvSetAntennaMode(pDevice, ANT_RXA);
-            }
+		if (pDevice->dwRxAntennaSel == 0) {
+			pDevice->dwRxAntennaSel = 1;
+			if (pDevice->bTxRxAntInv == true)
+				BBvSetAntennaMode(pDevice, ANT_RXA);
+			else
+				BBvSetAntennaMode(pDevice, ANT_RXB);
+		} else {
+			pDevice->dwRxAntennaSel = 0;
+			if (pDevice->bTxRxAntInv == true)
+				BBvSetAntennaMode(pDevice, ANT_RXB);
+			else
+				BBvSetAntennaMode(pDevice, ANT_RXA);
+		}
             s_bCommandComplete(pDevice);
             break;
 
@@ -895,16 +888,16 @@ void vRunCommand(struct work_struct *work)
 
     case WLAN_CMD_MAC_DISPOWERSAVING_START:
             ControlvReadByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
-            if ((byData & PSCTL_PS) != 0) {
-                // disable power saving hw function
-                CONTROLnsRequestOut(pDevice,
-                                MESSAGE_TYPE_DISABLE_PS,
-                                0,
-                                0,
-                                0,
-                                NULL
-                                );
-            }
+		if ((byData & PSCTL_PS) != 0) {
+			// disable power saving hw function
+			CONTROLnsRequestOut(pDevice,
+					MESSAGE_TYPE_DISABLE_PS,
+					0,
+					0,
+					0,
+					NULL
+					);
+		}
             s_bCommandComplete(pDevice);
             break;
 
@@ -933,95 +926,94 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 	int bForceSCAN = true;
 
     pDevice->eCommandState = WLAN_CMD_IDLE;
-    if (pDevice->cbFreeCmdQueue == CMD_Q_SIZE) {
-        //Command Queue Empty
-        pDevice->bCmdRunning = false;
-        return true;
-    } else {
-        pDevice->eCommand = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].eCmd;
-        pSSID = (PWLAN_IE_SSID)pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].abyCmdDesireSSID;
-        bRadioCmd = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].bRadioCmd;
-        bForceSCAN = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].bForceSCAN;
-        ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdDequeueIdx, CMD_Q_SIZE);
-        pDevice->cbFreeCmdQueue++;
-        pDevice->bCmdRunning = true;
-        switch (pDevice->eCommand) {
-        case WLAN_CMD_BSSID_SCAN:
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_BSSID_SCAN\n");
-                pDevice->eCommandState = WLAN_CMD_SCAN_START;
-                pMgmt->uScanChannel = 0;
-                if (pSSID->len != 0)
-                    memcpy(pMgmt->abyScanSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-                else
-                    memset(pMgmt->abyScanSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+	if (pDevice->cbFreeCmdQueue == CMD_Q_SIZE) {
+		//Command Queue Empty
+		pDevice->bCmdRunning = false;
+		return true;
+	} else {
+		pDevice->eCommand = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].eCmd;
+		pSSID = (PWLAN_IE_SSID)pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].abyCmdDesireSSID;
+		bRadioCmd = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].bRadioCmd;
+		bForceSCAN = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].bForceSCAN;
+		ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdDequeueIdx, CMD_Q_SIZE);
+		pDevice->cbFreeCmdQueue++;
+		pDevice->bCmdRunning = true;
+		switch (pDevice->eCommand) {
+		case WLAN_CMD_BSSID_SCAN:
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_BSSID_SCAN\n");
+			pDevice->eCommandState = WLAN_CMD_SCAN_START;
+			pMgmt->uScanChannel = 0;
+			if (pSSID->len != 0)
+				memcpy(pMgmt->abyScanSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+			else
+				memset(pMgmt->abyScanSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
 /*
-                if ((bForceSCAN == false) && (pDevice->bLinkPass == true)) {
-                    if ((pSSID->len == ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->len) &&
-                        ( !memcmp(pSSID->abySSID, ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->abySSID, pSSID->len))) {
-                        pDevice->eCommandState = WLAN_CMD_IDLE;
-                    }
-                }
+			if ((bForceSCAN == false) && (pDevice->bLinkPass == true)) {
+				if ((pSSID->len == ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->len) &&
+				    ( !memcmp(pSSID->abySSID, ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->abySSID, pSSID->len))) {
+					pDevice->eCommandState = WLAN_CMD_IDLE;
+				}
+			}
 */
-                break;
-        case WLAN_CMD_SSID:
-                pDevice->eCommandState = WLAN_CMD_SSID_START;
-                if (pSSID->len > WLAN_SSID_MAXLEN)
-                    pSSID->len = WLAN_SSID_MAXLEN;
-                if (pSSID->len != 0)
-                    memcpy(pMgmt->abyDesireSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_SSID_START\n");
-                break;
-        case WLAN_CMD_DISASSOCIATE:
-                pDevice->eCommandState = WLAN_CMD_DISASSOCIATE_START;
-                break;
-        case WLAN_CMD_RX_PSPOLL:
-                pDevice->eCommandState = WLAN_CMD_TX_PSPACKET_START;
-                break;
-        case WLAN_CMD_RUN_AP:
-                pDevice->eCommandState = WLAN_CMD_AP_MODE_START;
-                break;
-        case WLAN_CMD_RADIO:
-                pDevice->eCommandState = WLAN_CMD_RADIO_START;
-                pDevice->bRadioCmd = bRadioCmd;
-                break;
-        case WLAN_CMD_CHANGE_BBSENSITIVITY:
-                pDevice->eCommandState = WLAN_CMD_CHANGE_BBSENSITIVITY_START;
-                break;
-
-        case WLAN_CMD_TBTT_WAKEUP:
-                pDevice->eCommandState = WLAN_CMD_TBTT_WAKEUP_START;
-                break;
-
-        case WLAN_CMD_BECON_SEND:
-                pDevice->eCommandState = WLAN_CMD_BECON_SEND_START;
-                break;
-
-        case WLAN_CMD_SETPOWER:
-                pDevice->eCommandState = WLAN_CMD_SETPOWER_START;
-                break;
-
-        case WLAN_CMD_CHANGE_ANTENNA:
-                pDevice->eCommandState = WLAN_CMD_CHANGE_ANTENNA_START;
-                break;
-
-        case WLAN_CMD_REMOVE_ALLKEY:
-                pDevice->eCommandState = WLAN_CMD_REMOVE_ALLKEY_START;
-                break;
-
-        case WLAN_CMD_MAC_DISPOWERSAVING:
-                pDevice->eCommandState = WLAN_CMD_MAC_DISPOWERSAVING_START;
-                break;
-
-        case WLAN_CMD_11H_CHSW:
-                pDevice->eCommandState = WLAN_CMD_11H_CHSW_START;
-                break;
-
-        default:
-                break;
-
-        }
-	vCommandTimerWait(pDevice, 0);
-    }
+			break;
+		case WLAN_CMD_SSID:
+			pDevice->eCommandState = WLAN_CMD_SSID_START;
+			if (pSSID->len > WLAN_SSID_MAXLEN)
+				pSSID->len = WLAN_SSID_MAXLEN;
+			if (pSSID->len != 0)
+				memcpy(pMgmt->abyDesireSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_SSID_START\n");
+			break;
+		case WLAN_CMD_DISASSOCIATE:
+			pDevice->eCommandState = WLAN_CMD_DISASSOCIATE_START;
+			break;
+		case WLAN_CMD_RX_PSPOLL:
+			pDevice->eCommandState = WLAN_CMD_TX_PSPACKET_START;
+			break;
+		case WLAN_CMD_RUN_AP:
+			pDevice->eCommandState = WLAN_CMD_AP_MODE_START;
+			break;
+		case WLAN_CMD_RADIO:
+			pDevice->eCommandState = WLAN_CMD_RADIO_START;
+			pDevice->bRadioCmd = bRadioCmd;
+			break;
+		case WLAN_CMD_CHANGE_BBSENSITIVITY:
+			pDevice->eCommandState = WLAN_CMD_CHANGE_BBSENSITIVITY_START;
+			break;
+
+		case WLAN_CMD_TBTT_WAKEUP:
+			pDevice->eCommandState = WLAN_CMD_TBTT_WAKEUP_START;
+			break;
+
+		case WLAN_CMD_BECON_SEND:
+			pDevice->eCommandState = WLAN_CMD_BECON_SEND_START;
+			break;
+
+		case WLAN_CMD_SETPOWER:
+			pDevice->eCommandState = WLAN_CMD_SETPOWER_START;
+			break;
+
+		case WLAN_CMD_CHANGE_ANTENNA:
+			pDevice->eCommandState = WLAN_CMD_CHANGE_ANTENNA_START;
+			break;
+
+		case WLAN_CMD_REMOVE_ALLKEY:
+			pDevice->eCommandState = WLAN_CMD_REMOVE_ALLKEY_START;
+			break;
+
+		case WLAN_CMD_MAC_DISPOWERSAVING:
+			pDevice->eCommandState = WLAN_CMD_MAC_DISPOWERSAVING_START;
+			break;
+
+		case WLAN_CMD_11H_CHSW:
+			pDevice->eCommandState = WLAN_CMD_11H_CHSW_START;
+			break;
+
+		default:
+			break;
+		}
+		vCommandTimerWait(pDevice, 0);
+	}
 
     return true;
 }
@@ -1030,47 +1022,47 @@ int bScheduleCommand(struct vnt_private *pDevice,
 		CMD_CODE eCommand, u8 *pbyItem0)
 {
 
-    if (pDevice->cbFreeCmdQueue == 0)
-        return (false);
-    pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].eCmd = eCommand;
-    pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = true;
-    memset(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID, 0 , WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-    if (pbyItem0 != NULL) {
-        switch (eCommand) {
-        case WLAN_CMD_BSSID_SCAN:
-                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = false;
-                memcpy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
-                         pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-                break;
-
-        case WLAN_CMD_SSID:
-                memcpy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
-                         pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-                break;
-
-        case WLAN_CMD_DISASSOCIATE:
-                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bNeedRadioOFF = *((int *)pbyItem0);
-                break;
+	if (pDevice->cbFreeCmdQueue == 0)
+		return (false);
+	pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].eCmd = eCommand;
+	pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = true;
+	memset(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID, 0 , WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+	if (pbyItem0 != NULL) {
+		switch (eCommand) {
+		case WLAN_CMD_BSSID_SCAN:
+			pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = false;
+			memcpy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
+				pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+			break;
+
+		case WLAN_CMD_SSID:
+			memcpy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
+				pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+			break;
+
+		case WLAN_CMD_DISASSOCIATE:
+			pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bNeedRadioOFF = *((int *)pbyItem0);
+			break;
 /*
-        case WLAN_CMD_DEAUTH:
-                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].wDeAuthenReason = *((u16 *)pbyItem0);
-                break;
+		case WLAN_CMD_DEAUTH:
+			pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].wDeAuthenReason = *((u16 *)pbyItem0);
+			break;
 */
 
-        case WLAN_CMD_RADIO:
-                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bRadioCmd = *((int *)pbyItem0);
-                break;
+		case WLAN_CMD_RADIO:
+			pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bRadioCmd = *((int *)pbyItem0);
+			break;
 
-        default:
-                break;
-        }
-    }
+		default:
+			break;
+		}
+	}
 
     ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdEnqueueIdx, CMD_Q_SIZE);
     pDevice->cbFreeCmdQueue--;
 
-    if (pDevice->bCmdRunning == false)
-        s_bCommandComplete(pDevice);
+	if (pDevice->bCmdRunning == false)
+		s_bCommandComplete(pDevice);
 
     return (true);
 
@@ -1095,15 +1087,15 @@ static int s_bClearBSSID_SCAN(struct vnt_private *pDevice)
 	unsigned int uCmdDequeueIdx = pDevice->uCmdDequeueIdx;
 	unsigned int ii;
 
-    if ((pDevice->cbFreeCmdQueue < CMD_Q_SIZE) && (uCmdDequeueIdx != pDevice->uCmdEnqueueIdx)) {
-        for (ii = 0; ii < (CMD_Q_SIZE - pDevice->cbFreeCmdQueue); ii++) {
-            if (pDevice->eCmdQueue[uCmdDequeueIdx].eCmd == WLAN_CMD_BSSID_SCAN)
-                pDevice->eCmdQueue[uCmdDequeueIdx].eCmd = WLAN_CMD_IDLE;
-            ADD_ONE_WITH_WRAP_AROUND(uCmdDequeueIdx, CMD_Q_SIZE);
-            if (uCmdDequeueIdx == pDevice->uCmdEnqueueIdx)
-                break;
-        }
-    }
+	if ((pDevice->cbFreeCmdQueue < CMD_Q_SIZE) && (uCmdDequeueIdx != pDevice->uCmdEnqueueIdx)) {
+		for (ii = 0; ii < (CMD_Q_SIZE - pDevice->cbFreeCmdQueue); ii++) {
+			if (pDevice->eCmdQueue[uCmdDequeueIdx].eCmd == WLAN_CMD_BSSID_SCAN)
+				pDevice->eCmdQueue[uCmdDequeueIdx].eCmd = WLAN_CMD_IDLE;
+			ADD_ONE_WITH_WRAP_AROUND(uCmdDequeueIdx, CMD_Q_SIZE);
+			if (uCmdDequeueIdx == pDevice->uCmdEnqueueIdx)
+				break;
+		}
+	}
     return true;
 }
 

commit faaf9c195e162ec6c0d8c2247e06da4277dad80b
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Tue Nov 12 23:05:34 2013 +0530

    staging: vt6656: fixed the switch case indentation level error
    
    aligned the case statements of 'switch' so that the switch and
    case are on same indentation level to fix the following error.
            ERROR: switch and case should be at the same indent
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 5f8175368c4f..c07737769e3b 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -292,7 +292,7 @@ void vRunCommand(struct work_struct *work)
 
     switch (pDevice->eCommandState) {
 
-        case WLAN_CMD_SCAN_START:
+    case WLAN_CMD_SCAN_START:
 
 		pDevice->byReAssocCount = 0;
             if (pDevice->bRadioOff == true) {
@@ -392,7 +392,7 @@ void vRunCommand(struct work_struct *work)
 
             break;
 
-        case WLAN_CMD_SCAN_END:
+    case WLAN_CMD_SCAN_END:
 
             // Set Baseband's sensitivity back.
             if (pDevice->byBBType != pDevice->byScanBBType) {
@@ -428,7 +428,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_DISASSOCIATE_START:
+    case WLAN_CMD_DISASSOCIATE_START:
 		pDevice->byReAssocCount = 0;
             if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
                 (pMgmt->eCurrState != WMAC_STATE_ASSOC)) {
@@ -467,7 +467,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_SSID_START:
+    case WLAN_CMD_SSID_START:
 
 		pDevice->byReAssocCount = 0;
             if (pDevice->bRadioOff == true) {
@@ -593,7 +593,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_AUTHENTICATE_WAIT:
+    case WLAN_AUTHENTICATE_WAIT:
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_AUTHENTICATE_WAIT\n");
             if (pMgmt->eCurrState == WMAC_STATE_AUTH) {
 		pDevice->byLinkWaitCount = 0;
@@ -622,7 +622,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_ASSOCIATE_WAIT:
+    case WLAN_ASSOCIATE_WAIT:
             if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_ASSOC\n");
                 if (pDevice->ePSMode != WMAC_POWER_CAM) {
@@ -656,7 +656,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_AP_MODE_START:
+    case WLAN_CMD_AP_MODE_START:
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_AP_MODE_START\n");
 
             if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
@@ -692,7 +692,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_TX_PSPACKET_START:
+    case WLAN_CMD_TX_PSPACKET_START:
             // DTIM Multicast tx
             if (pMgmt->sNodeDBTable[0].bRxPSPoll) {
                 while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[0].sTxPSQueue)) != NULL) {
@@ -748,7 +748,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_RADIO_START:
+    case WLAN_CMD_RADIO_START:
 
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_RADIO_START\n");
        //     if (pDevice->bRadioCmd == true)
@@ -843,7 +843,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_CHANGE_BBSENSITIVITY_START:
+    case WLAN_CMD_CHANGE_BBSENSITIVITY_START:
 
             pDevice->bStopDataPkt = true;
             pDevice->byBBVGACurrent = pDevice->byBBVGANew;
@@ -853,24 +853,24 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_TBTT_WAKEUP_START:
+    case WLAN_CMD_TBTT_WAKEUP_START:
             PSbIsNextTBTTWakeUp(pDevice);
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_BECON_SEND_START:
+    case WLAN_CMD_BECON_SEND_START:
             bMgrPrepareBeaconToSend(pDevice, pMgmt);
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_SETPOWER_START:
+    case WLAN_CMD_SETPOWER_START:
 
             RFbSetPower(pDevice, pDevice->wCurrentRate, pMgmt->uCurrChannel);
 
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_CHANGE_ANTENNA_START:
+    case WLAN_CMD_CHANGE_ANTENNA_START:
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change from Antenna%d to", (int)pDevice->dwRxAntennaSel);
             if (pDevice->dwRxAntennaSel == 0) {
                 pDevice->dwRxAntennaSel = 1;
@@ -888,12 +888,12 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_REMOVE_ALLKEY_START:
+    case WLAN_CMD_REMOVE_ALLKEY_START:
             KeybRemoveAllKey(pDevice, &(pDevice->sKey), pDevice->abyBSSID);
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_MAC_DISPOWERSAVING_START:
+    case WLAN_CMD_MAC_DISPOWERSAVING_START:
             ControlvReadByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
             if ((byData & PSCTL_PS) != 0) {
                 // disable power saving hw function
@@ -908,7 +908,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_11H_CHSW_START:
+    case WLAN_CMD_11H_CHSW_START:
             CARDbSetMediaChannel(pDevice, pDevice->byNewChannel);
             pDevice->bChannelSwitch = false;
             pMgmt->uCurrChannel = pDevice->byNewChannel;
@@ -916,7 +916,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        default:
+    default:
             s_bCommandComplete(pDevice);
             break;
     } //switch
@@ -946,7 +946,7 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
         pDevice->cbFreeCmdQueue++;
         pDevice->bCmdRunning = true;
         switch (pDevice->eCommand) {
-            case WLAN_CMD_BSSID_SCAN:
+        case WLAN_CMD_BSSID_SCAN:
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_BSSID_SCAN\n");
                 pDevice->eCommandState = WLAN_CMD_SCAN_START;
                 pMgmt->uScanChannel = 0;
@@ -963,7 +963,7 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
                 }
 */
                 break;
-            case WLAN_CMD_SSID:
+        case WLAN_CMD_SSID:
                 pDevice->eCommandState = WLAN_CMD_SSID_START;
                 if (pSSID->len > WLAN_SSID_MAXLEN)
                     pSSID->len = WLAN_SSID_MAXLEN;
@@ -971,52 +971,52 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
                     memcpy(pMgmt->abyDesireSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_SSID_START\n");
                 break;
-            case WLAN_CMD_DISASSOCIATE:
+        case WLAN_CMD_DISASSOCIATE:
                 pDevice->eCommandState = WLAN_CMD_DISASSOCIATE_START;
                 break;
-            case WLAN_CMD_RX_PSPOLL:
+        case WLAN_CMD_RX_PSPOLL:
                 pDevice->eCommandState = WLAN_CMD_TX_PSPACKET_START;
                 break;
-            case WLAN_CMD_RUN_AP:
+        case WLAN_CMD_RUN_AP:
                 pDevice->eCommandState = WLAN_CMD_AP_MODE_START;
                 break;
-            case WLAN_CMD_RADIO:
+        case WLAN_CMD_RADIO:
                 pDevice->eCommandState = WLAN_CMD_RADIO_START;
                 pDevice->bRadioCmd = bRadioCmd;
                 break;
-            case WLAN_CMD_CHANGE_BBSENSITIVITY:
+        case WLAN_CMD_CHANGE_BBSENSITIVITY:
                 pDevice->eCommandState = WLAN_CMD_CHANGE_BBSENSITIVITY_START;
                 break;
 
-            case WLAN_CMD_TBTT_WAKEUP:
+        case WLAN_CMD_TBTT_WAKEUP:
                 pDevice->eCommandState = WLAN_CMD_TBTT_WAKEUP_START;
                 break;
 
-            case WLAN_CMD_BECON_SEND:
+        case WLAN_CMD_BECON_SEND:
                 pDevice->eCommandState = WLAN_CMD_BECON_SEND_START;
                 break;
 
-            case WLAN_CMD_SETPOWER:
+        case WLAN_CMD_SETPOWER:
                 pDevice->eCommandState = WLAN_CMD_SETPOWER_START;
                 break;
 
-            case WLAN_CMD_CHANGE_ANTENNA:
+        case WLAN_CMD_CHANGE_ANTENNA:
                 pDevice->eCommandState = WLAN_CMD_CHANGE_ANTENNA_START;
                 break;
 
-            case WLAN_CMD_REMOVE_ALLKEY:
+        case WLAN_CMD_REMOVE_ALLKEY:
                 pDevice->eCommandState = WLAN_CMD_REMOVE_ALLKEY_START;
                 break;
 
-            case WLAN_CMD_MAC_DISPOWERSAVING:
+        case WLAN_CMD_MAC_DISPOWERSAVING:
                 pDevice->eCommandState = WLAN_CMD_MAC_DISPOWERSAVING_START;
                 break;
 
-            case WLAN_CMD_11H_CHSW:
+        case WLAN_CMD_11H_CHSW:
                 pDevice->eCommandState = WLAN_CMD_11H_CHSW_START;
                 break;
 
-            default:
+        default:
                 break;
 
         }
@@ -1037,31 +1037,31 @@ int bScheduleCommand(struct vnt_private *pDevice,
     memset(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID, 0 , WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
     if (pbyItem0 != NULL) {
         switch (eCommand) {
-            case WLAN_CMD_BSSID_SCAN:
+        case WLAN_CMD_BSSID_SCAN:
                 pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = false;
                 memcpy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
                          pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
                 break;
 
-            case WLAN_CMD_SSID:
+        case WLAN_CMD_SSID:
                 memcpy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
                          pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
                 break;
 
-            case WLAN_CMD_DISASSOCIATE:
+        case WLAN_CMD_DISASSOCIATE:
                 pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bNeedRadioOFF = *((int *)pbyItem0);
                 break;
 /*
-            case WLAN_CMD_DEAUTH:
+        case WLAN_CMD_DEAUTH:
                 pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].wDeAuthenReason = *((u16 *)pbyItem0);
                 break;
 */
 
-            case WLAN_CMD_RADIO:
+        case WLAN_CMD_RADIO:
                 pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bRadioCmd = *((int *)pbyItem0);
                 break;
 
-            default:
+        default:
                 break;
         }
     }

commit 015bdc262bfe21042af4d554459647c8d1f9b571
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Tue Nov 12 23:05:33 2013 +0530

    staging: vt6656: fixed unnecessary whitespace warning
    
    removed the "unnecessary whitespace before quoted new line"
    warning reported by checkpatch script
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index a6681a2f7146..5f8175368c4f 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -197,9 +197,9 @@ static void s_vProbeChannel(struct vnt_private *pDevice)
     if (pTxPacket != NULL) {
         for (ii = 0; ii < 1; ii++) {
             if (csMgmt_xmit(pDevice, pTxPacket) != CMD_STATUS_PENDING) {
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request sending fail.. \n");
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request sending fail..\n");
 	    } else {
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request is sending.. \n");
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request is sending..\n");
 	    }
         }
     }
@@ -319,7 +319,7 @@ void vRunCommand(struct work_struct *work)
 
             } else {
                 if (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel)) {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Invalid channel pMgmt->uScanChannel = %d \n", pMgmt->uScanChannel);
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Invalid channel pMgmt->uScanChannel = %d\n", pMgmt->uScanChannel);
 			pMgmt->uScanChannel++;
                     s_bCommandComplete(pDevice);
                     spin_unlock_irq(&pDevice->lock);
@@ -704,7 +704,7 @@ void vRunCommand(struct work_struct *work)
                     }
 
                     if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0)
-                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Multicast ps tx fail \n");
+                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Multicast ps tx fail\n");
 
                     pMgmt->sNodeDBTable[0].wEnQueueCnt--;
                 }
@@ -727,7 +727,7 @@ void vRunCommand(struct work_struct *work)
                         }
 
                         if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0)
-                            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "sta ps tx fail \n");
+                            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "sta ps tx fail\n");
 
                         pMgmt->sNodeDBTable[ii].wEnQueueCnt--;
                         // check if sta ps enable, wait next pspoll
@@ -739,7 +739,7 @@ void vRunCommand(struct work_struct *work)
                         // clear tx map
                         pMgmt->abyPSTxMap[pMgmt->sNodeDBTable[ii].wAID >> 3] &=
                                     ~byMask[pMgmt->sNodeDBTable[ii].wAID & 7];
-                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Index=%d PS queue clear \n", ii);
+                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Index=%d PS queue clear\n", ii);
                     }
                     pMgmt->sNodeDBTable[ii].bRxPSPoll = false;
                 }

commit bfce700fb107bb0d3dcb29726629535892267dd2
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Tue Nov 12 23:05:32 2013 +0530

    staging: vt6656: fixed checkpatch errors related to close brace
    
    fixed following checkpatch error:
            ERROR: else should follow close brace '}'
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index cf234829806b..a6681a2f7146 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -350,8 +350,7 @@ void vRunCommand(struct work_struct *work)
                 if ((pDevice->byBBType != BB_TYPE_11A) && (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G)) {
                     pDevice->byBBType = BB_TYPE_11A;
                     CARDvSetBSSMode(pDevice);
-                }
-                else if ((pDevice->byBBType == BB_TYPE_11A) && (pMgmt->uScanChannel <= CB_MAX_CHANNEL_24G)) {
+                } else if ((pDevice->byBBType == BB_TYPE_11A) && (pMgmt->uScanChannel <= CB_MAX_CHANNEL_24G)) {
                     pDevice->byBBType = BB_TYPE_11G;
                     CARDvSetBSSMode(pDevice);
                 }
@@ -544,8 +543,7 @@ void vRunCommand(struct work_struct *work)
                     ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
                     pMgmt->sNodeDBTable[0].bActive = true;
                     pMgmt->sNodeDBTable[0].uInActiveCount = 0;
-                }
-                else {
+                } else {
                     // start own IBSS
 		    DBG_PRT(MSG_LEVEL_DEBUG,
 			    KERN_INFO "CreateOwn IBSS by CurrMode = IBSS_STA\n");
@@ -580,8 +578,7 @@ void vRunCommand(struct work_struct *work)
                     }
                     s_bClearBSSID_SCAN(pDevice);
 */
-                }
-                else {
+                } else {
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Disconnect SSID none\n");
                     // if(pDevice->bWPASuppWextEnabled == true)
                         {
@@ -611,11 +608,9 @@ void vRunCommand(struct work_struct *work)
                     spin_unlock_irq(&pDevice->lock);
                     return;
                 }
-            }
-	   else if (pMgmt->eCurrState < WMAC_STATE_AUTHPENDING) {
+            } else if (pMgmt->eCurrState < WMAC_STATE_AUTHPENDING) {
                printk("WLAN_AUTHENTICATE_WAIT:Authen Fail???\n");
-	   }
-	   else if (pDevice->byLinkWaitCount <= 4) {    //mike add:wait another 2 sec if authenticated_frame delay!
+	   } else if (pDevice->byLinkWaitCount <= 4) {    //mike add:wait another 2 sec if authenticated_frame delay!
                 pDevice->byLinkWaitCount++;
 	       printk("WLAN_AUTHENTICATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
 	       spin_unlock_irq(&pDevice->lock);
@@ -648,11 +643,9 @@ void vRunCommand(struct work_struct *work)
                 if (netif_queue_stopped(pDevice->dev))
                     netif_wake_queue(pDevice->dev);
 
-            }
-	   else if (pMgmt->eCurrState < WMAC_STATE_ASSOCPENDING) {
+            } else if (pMgmt->eCurrState < WMAC_STATE_ASSOCPENDING) {
                printk("WLAN_ASSOCIATE_WAIT:Association Fail???\n");
-	   }
-	   else if (pDevice->byLinkWaitCount <= 4) {    //mike add:wait another 2 sec if associated_frame delay!
+	   } else if (pDevice->byLinkWaitCount <= 4) {    //mike add:wait another 2 sec if associated_frame delay!
                 pDevice->byLinkWaitCount++;
 	       printk("WLAN_ASSOCIATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
 	       spin_unlock_irq(&pDevice->lock);
@@ -706,8 +699,7 @@ void vRunCommand(struct work_struct *work)
                     if (skb_queue_empty(&pMgmt->sNodeDBTable[0].sTxPSQueue)) {
                         pMgmt->abyPSTxMap[0] &= ~byMask[0];
                         pDevice->bMoreData = false;
-                    }
-                    else {
+                    } else {
                         pDevice->bMoreData = true;
                     }
 
@@ -730,8 +722,7 @@ void vRunCommand(struct work_struct *work)
                             pMgmt->abyPSTxMap[pMgmt->sNodeDBTable[ii].wAID >> 3] &=
                                     ~byMask[pMgmt->sNodeDBTable[ii].wAID & 7];
                             pDevice->bMoreData = false;
-                        }
-                        else {
+                        } else {
                             pDevice->bMoreData = true;
                         }
 
@@ -946,8 +937,7 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
         //Command Queue Empty
         pDevice->bCmdRunning = false;
         return true;
-    }
-    else {
+    } else {
         pDevice->eCommand = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].eCmd;
         pSSID = (PWLAN_IE_SSID)pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].abyCmdDesireSSID;
         bRadioCmd = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].bRadioCmd;

commit c3f007f5b6bcaeaf554014e3ec471c2308843c6e
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Tue Nov 12 23:05:31 2013 +0530

    staging: vt6656: fixed open brace placement related error
    
    fixed the following checkpatch error:
            ERROR: that open brace { should be on the previous line
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 5f0a00295ef4..cf234829806b 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -100,19 +100,16 @@ static void vAdHocBeaconStop(struct vnt_private *pDevice)
      */
     bStop = false;
     if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
-    (pMgmt->eCurrState >= WMAC_STATE_STARTED))
-    {
+    (pMgmt->eCurrState >= WMAC_STATE_STARTED)) {
         if ((pMgmt->uIBSSChannel <=  CB_MAX_CHANNEL_24G) &&
-             (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G))
-        {
+             (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G)) {
             bStop = true;
         }
         if (pMgmt->uIBSSChannel >  CB_MAX_CHANNEL_24G)
             bStop = true;
     }
 
-    if (bStop)
-    {
+    if (bStop) {
         //PMESG(("STOP_BEACON: IBSSChannel = %u, ScanChannel = %u\n",
         //        pMgmt->uIBSSChannel, pMgmt->uScanChannel));
         MACvRegBitsOff(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
@@ -144,8 +141,7 @@ static void vAdHocBeaconRestart(struct vnt_private *pDevice)
      *  (2) VT3253 is programmed as automatic Beacon Transmitting
      */
     if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
-    (pMgmt->eCurrState >= WMAC_STATE_STARTED))
-    {
+    (pMgmt->eCurrState >= WMAC_STATE_STARTED)) {
         //PMESG(("RESTART_BEACON\n"));
         MACvRegBitsOn(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
     }

commit 566597a37647c34600d971e5898d5816dddd7afd
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Tue Nov 12 23:05:30 2013 +0530

    staging: vt6656: removed unnecessary braces around if-else statements
    
    removed unnecessary braces around if-else statement whenever
    the if-else construct was followed by just single line of code
    to comply with linux coding style
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index ca57fc37d609..5f0a00295ef4 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -108,9 +108,7 @@ static void vAdHocBeaconStop(struct vnt_private *pDevice)
             bStop = true;
         }
         if (pMgmt->uIBSSChannel >  CB_MAX_CHANNEL_24G)
-        {
             bStop = true;
-        }
     }
 
     if (bStop)
@@ -182,13 +180,13 @@ static void s_vProbeChannel(struct vnt_private *pDevice)
 	u8 *pbyRate;
 	int ii;
 
-    if (pDevice->byBBType == BB_TYPE_11A) {
-        pbyRate = &abyCurrSuppRatesA[0];
-    } else if (pDevice->byBBType == BB_TYPE_11B) {
-        pbyRate = &abyCurrSuppRatesB[0];
-    } else {
-        pbyRate = &abyCurrSuppRatesG[0];
-    }
+	if (pDevice->byBBType == BB_TYPE_11A)
+		pbyRate = &abyCurrSuppRatesA[0];
+	else if (pDevice->byBBType == BB_TYPE_11B)
+		pbyRate = &abyCurrSuppRatesB[0];
+	else
+		pbyRate = &abyCurrSuppRatesG[0];
+
     // build an assocreq frame and send it
     pTxPacket = s_MgrMakeProbeRequest
                 (
@@ -204,10 +202,9 @@ static void s_vProbeChannel(struct vnt_private *pDevice)
         for (ii = 0; ii < 1; ii++) {
             if (csMgmt_xmit(pDevice, pTxPacket) != CMD_STATUS_PENDING) {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request sending fail.. \n");
-            }
-            else {
+	    } else {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request is sending.. \n");
-            }
+	    }
         }
     }
 
@@ -316,9 +313,8 @@ void vRunCommand(struct work_struct *work)
 
             pItemSSID = (PWLAN_IE_SSID)pMgmt->abyScanSSID;
 
-            if (pMgmt->uScanChannel == 0) {
+            if (pMgmt->uScanChannel == 0)
                 pMgmt->uScanChannel = pDevice->byMinChannel;
-            }
             if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
 		pDevice->eCommandState = WLAN_CMD_SCAN_END;
                 s_bCommandComplete(pDevice);
@@ -546,9 +542,8 @@ void vRunCommand(struct work_struct *work)
             // if Adhoc mode
             else if (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
                 if (pMgmt->eCurrState == WMAC_STATE_JOINTED) {
-                    if (netif_queue_stopped(pDevice->dev)) {
+                    if (netif_queue_stopped(pDevice->dev))
                         netif_wake_queue(pDevice->dev);
-                    }
                     pDevice->bLinkPass = true;
                     ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
                     pMgmt->sNodeDBTable[0].bActive = true;
@@ -654,9 +649,8 @@ void vRunCommand(struct work_struct *work)
                 ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
                 s_bClearBSSID_SCAN(pDevice);
 
-                if (netif_queue_stopped(pDevice->dev)) {
+                if (netif_queue_stopped(pDevice->dev))
                     netif_wake_queue(pDevice->dev);
-                }
 
             }
 	   else if (pMgmt->eCurrState < WMAC_STATE_ASSOCPENDING) {
@@ -700,9 +694,8 @@ void vRunCommand(struct work_struct *work)
                 pDevice->byRxMode &= ~RCR_UNICAST;
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wcmd: rx_mode = %x\n", pDevice->byRxMode);
                 BSSvAddMulticastNode(pDevice);
-                if (netif_queue_stopped(pDevice->dev)) {
+                if (netif_queue_stopped(pDevice->dev))
                     netif_wake_queue(pDevice->dev);
-                }
                 pDevice->bLinkPass = true;
                 ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
 		schedule_delayed_work(&pDevice->second_callback_work, HZ);
@@ -722,9 +715,8 @@ void vRunCommand(struct work_struct *work)
                         pDevice->bMoreData = true;
                     }
 
-                    if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0) {
+                    if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0)
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Multicast ps tx fail \n");
-                    }
 
                     pMgmt->sNodeDBTable[0].wEnQueueCnt--;
                 }
@@ -747,9 +739,8 @@ void vRunCommand(struct work_struct *work)
                             pDevice->bMoreData = true;
                         }
 
-                        if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0) {
+                        if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0)
                             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "sta ps tx fail \n");
-                        }
 
                         pMgmt->sNodeDBTable[ii].wEnQueueCnt--;
                         // check if sta ps enable, wait next pspoll
@@ -973,11 +964,10 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_BSSID_SCAN\n");
                 pDevice->eCommandState = WLAN_CMD_SCAN_START;
                 pMgmt->uScanChannel = 0;
-                if (pSSID->len != 0) {
+                if (pSSID->len != 0)
                     memcpy(pMgmt->abyScanSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-                } else {
+                else
                     memset(pMgmt->abyScanSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-                }
 /*
                 if ((bForceSCAN == false) && (pDevice->bLinkPass == true)) {
                     if ((pSSID->len == ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->len) &&
@@ -1054,9 +1044,8 @@ int bScheduleCommand(struct vnt_private *pDevice,
 		CMD_CODE eCommand, u8 *pbyItem0)
 {
 
-    if (pDevice->cbFreeCmdQueue == 0) {
+    if (pDevice->cbFreeCmdQueue == 0)
         return (false);
-    }
     pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].eCmd = eCommand;
     pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = true;
     memset(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID, 0 , WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
@@ -1094,11 +1083,9 @@ int bScheduleCommand(struct vnt_private *pDevice,
     ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdEnqueueIdx, CMD_Q_SIZE);
     pDevice->cbFreeCmdQueue--;
 
-    if (pDevice->bCmdRunning == false) {
+    if (pDevice->bCmdRunning == false)
         s_bCommandComplete(pDevice);
-    }
-    else {
-    }
+
     return (true);
 
 }

commit ebd381d9851bba4b9565ec3b414055c726391907
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Sun Nov 3 18:30:52 2013 +0530

    staging: vt6656: fixed whitespace related errors around operators
    
    removed prohibited spaces around operators and added required
    spaces around operators wherever necessary to fix checkpatch
    errors
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 1031e54284f7..ca57fc37d609 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -55,8 +55,8 @@
 #include "channel.h"
 #include "iowpa.h"
 
-static int          msglevel                =MSG_LEVEL_INFO;
-//static int          msglevel                =MSG_LEVEL_DEBUG;
+static int msglevel = MSG_LEVEL_INFO;
+//static int msglevel = MSG_LEVEL_DEBUG;
 
 static void s_vProbeChannel(struct vnt_private *);
 
@@ -200,8 +200,8 @@ static void s_vProbeChannel(struct vnt_private *pDevice)
                   (PWLAN_IE_SUPP_RATES)abyCurrExtSuppRatesG
                 );
 
-    if (pTxPacket != NULL ){
-        for (ii = 0; ii < 1 ; ii++) {
+    if (pTxPacket != NULL) {
+        for (ii = 0; ii < 1; ii++) {
             if (csMgmt_xmit(pDevice, pTxPacket) != CMD_STATUS_PENDING) {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request sending fail.. \n");
             }
@@ -244,9 +244,9 @@ static struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *pDevice,
         WLAN_SET_FC_FTYPE(WLAN_TYPE_MGR) |
         WLAN_SET_FC_FSTYPE(WLAN_FSTYPE_PROBEREQ)
         ));
-    memcpy( sFrame.pHdr->sA3.abyAddr1, pScanBSSID, WLAN_ADDR_LEN);
-    memcpy( sFrame.pHdr->sA3.abyAddr2, pMgmt->abyMACAddr, WLAN_ADDR_LEN);
-    memcpy( sFrame.pHdr->sA3.abyAddr3, pScanBSSID, WLAN_BSSID_LEN);
+    memcpy(sFrame.pHdr->sA3.abyAddr1, pScanBSSID, WLAN_ADDR_LEN);
+    memcpy(sFrame.pHdr->sA3.abyAddr2, pMgmt->abyMACAddr, WLAN_ADDR_LEN);
+    memcpy(sFrame.pHdr->sA3.abyAddr3, pScanBSSID, WLAN_BSSID_LEN);
     // Copy the SSID, pSSID->len=0 indicate broadcast SSID
     sFrame.pSSID = (PWLAN_IE_SSID)(sFrame.pBuf + sFrame.len);
     sFrame.len += pSSID->len + WLAN_IEHDR_LEN;
@@ -297,7 +297,7 @@ void vRunCommand(struct work_struct *work)
 
     spin_lock_irq(&pDevice->lock);
 
-    switch ( pDevice->eCommandState ) {
+    switch (pDevice->eCommandState) {
 
         case WLAN_CMD_SCAN_START:
 
@@ -316,7 +316,7 @@ void vRunCommand(struct work_struct *work)
 
             pItemSSID = (PWLAN_IE_SSID)pMgmt->abyScanSSID;
 
-            if (pMgmt->uScanChannel == 0 ) {
+            if (pMgmt->uScanChannel == 0) {
                 pMgmt->uScanChannel = pDevice->byMinChannel;
             }
             if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
@@ -327,7 +327,7 @@ void vRunCommand(struct work_struct *work)
 
             } else {
                 if (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel)) {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Invalid channel pMgmt->uScanChannel = %d \n",pMgmt->uScanChannel);
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Invalid channel pMgmt->uScanChannel = %d \n", pMgmt->uScanChannel);
 			pMgmt->uScanChannel++;
                     s_bCommandComplete(pDevice);
                     spin_unlock_irq(&pDevice->lock);
@@ -376,7 +376,7 @@ void vRunCommand(struct work_struct *work)
                 pMgmt->uScanChannel++;
 
                 while (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel) &&
-                        pMgmt->uScanChannel <= pDevice->byMaxChannel ){
+                        pMgmt->uScanChannel <= pDevice->byMaxChannel){
                     pMgmt->uScanChannel++;
                 }
 
@@ -437,7 +437,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_DISASSOCIATE_START :
+        case WLAN_CMD_DISASSOCIATE_START:
 		pDevice->byReAssocCount = 0;
             if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
                 (pMgmt->eCurrState != WMAC_STATE_ASSOC)) {
@@ -461,7 +461,7 @@ void vRunCommand(struct work_struct *work)
 				     (8),
 				     &Status);
                 pDevice->bLinkPass = false;
-                ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
+                ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
                 // unlock command busy
                 pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
                 pItemSSID->len = 0;
@@ -485,7 +485,7 @@ void vRunCommand(struct work_struct *work)
                 return;
             }
 
-            memcpy(pMgmt->abyAdHocSSID,pMgmt->abyDesireSSID,
+            memcpy(pMgmt->abyAdHocSSID, pMgmt->abyDesireSSID,
                               ((PWLAN_IE_SSID)pMgmt->abyDesireSSID)->len + WLAN_IEHDR_LEN);
 
             pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
@@ -495,14 +495,14 @@ void vRunCommand(struct work_struct *work)
 
             if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Cmd pMgmt->eCurrState == WMAC_STATE_ASSOC\n");
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pItemSSID->len =%d\n",pItemSSID->len);
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pItemSSIDCurr->len = %d\n",pItemSSIDCurr->len);
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pItemSSID->len =%d\n", pItemSSID->len);
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pItemSSIDCurr->len = %d\n", pItemSSIDCurr->len);
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" desire ssid = %s\n", pItemSSID->abySSID);
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" curr ssid = %s\n", pItemSSIDCurr->abySSID);
             }
 
             if ((pMgmt->eCurrState == WMAC_STATE_ASSOC) ||
-                ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)&& (pMgmt->eCurrState == WMAC_STATE_JOINTED))) {
+                ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED))) {
 
                 if (pItemSSID->len == pItemSSIDCurr->len) {
                     if (memcmp(pItemSSID->abySSID, pItemSSIDCurr->abySSID, pItemSSID->len) == 0) {
@@ -513,7 +513,7 @@ void vRunCommand(struct work_struct *work)
                 }
                 netif_stop_queue(pDevice->dev);
                 pDevice->bLinkPass = false;
-                ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
+                ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
             }
             // set initial state
             pMgmt->eCurrState = WMAC_STATE_IDLE;
@@ -546,11 +546,11 @@ void vRunCommand(struct work_struct *work)
             // if Adhoc mode
             else if (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
                 if (pMgmt->eCurrState == WMAC_STATE_JOINTED) {
-                    if (netif_queue_stopped(pDevice->dev)){
+                    if (netif_queue_stopped(pDevice->dev)) {
                         netif_wake_queue(pDevice->dev);
                     }
                     pDevice->bLinkPass = true;
-                    ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
+                    ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
                     pMgmt->sNodeDBTable[0].bActive = true;
                     pMgmt->sNodeDBTable[0].uInActiveCount = 0;
                 }
@@ -559,7 +559,7 @@ void vRunCommand(struct work_struct *work)
 		    DBG_PRT(MSG_LEVEL_DEBUG,
 			    KERN_INFO "CreateOwn IBSS by CurrMode = IBSS_STA\n");
 		    vMgrCreateOwnIBSS((void *) pDevice, &Status);
-                    if (Status != CMD_STATUS_SUCCESS){
+                    if (Status != CMD_STATUS_SUCCESS) {
 			DBG_PRT(MSG_LEVEL_DEBUG,
 				KERN_INFO "WLAN_CMD_IBSS_CREATE fail!\n");
                     }
@@ -575,7 +575,7 @@ void vRunCommand(struct work_struct *work)
 			DBG_PRT(MSG_LEVEL_DEBUG,
 				KERN_INFO "CreateOwn IBSS by CurrMode = STANDBY\n");
 		    vMgrCreateOwnIBSS((void *) pDevice, &Status);
-                    if (Status != CMD_STATUS_SUCCESS){
+                    if (Status != CMD_STATUS_SUCCESS) {
 			DBG_PRT(MSG_LEVEL_DEBUG,
 				KERN_INFO "WLAN_CMD_IBSS_CREATE fail!\n");
                     }
@@ -595,7 +595,7 @@ void vRunCommand(struct work_struct *work)
                     // if(pDevice->bWPASuppWextEnabled == true)
                         {
                   	union iwreq_data  wrqu;
-                  	memset(&wrqu, 0, sizeof (wrqu));
+                  	memset(&wrqu, 0, sizeof(wrqu));
                           wrqu.ap_addr.sa_family = ARPHRD_ETHER;
                   	PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated:vMgrJoinBSSBegin Fail !!)\n");
                   	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
@@ -605,7 +605,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_AUTHENTICATE_WAIT :
+        case WLAN_AUTHENTICATE_WAIT:
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_AUTHENTICATE_WAIT\n");
             if (pMgmt->eCurrState == WMAC_STATE_AUTH) {
 		pDevice->byLinkWaitCount = 0;
@@ -621,12 +621,12 @@ void vRunCommand(struct work_struct *work)
                     return;
                 }
             }
-	   else if(pMgmt->eCurrState < WMAC_STATE_AUTHPENDING) {
+	   else if (pMgmt->eCurrState < WMAC_STATE_AUTHPENDING) {
                printk("WLAN_AUTHENTICATE_WAIT:Authen Fail???\n");
 	   }
-	   else  if(pDevice->byLinkWaitCount <= 4){    //mike add:wait another 2 sec if authenticated_frame delay!
-                pDevice->byLinkWaitCount ++;
-	       printk("WLAN_AUTHENTICATE_WAIT:wait %d times!!\n",pDevice->byLinkWaitCount);
+	   else if (pDevice->byLinkWaitCount <= 4) {    //mike add:wait another 2 sec if authenticated_frame delay!
+                pDevice->byLinkWaitCount++;
+	       printk("WLAN_AUTHENTICATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
 	       spin_unlock_irq(&pDevice->lock);
 	       vCommandTimerWait((void *) pDevice, AUTHENTICATE_TIMEOUT/2);
 	       return;
@@ -636,7 +636,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_ASSOCIATE_WAIT :
+        case WLAN_ASSOCIATE_WAIT:
             if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_ASSOC\n");
                 if (pDevice->ePSMode != WMAC_POWER_CAM) {
@@ -651,20 +651,20 @@ void vRunCommand(struct work_struct *work)
                 pDevice->byLinkWaitCount = 0;
                 pDevice->byReAssocCount = 0;
                 pDevice->bLinkPass = true;
-                ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
+                ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
                 s_bClearBSSID_SCAN(pDevice);
 
-                if (netif_queue_stopped(pDevice->dev)){
+                if (netif_queue_stopped(pDevice->dev)) {
                     netif_wake_queue(pDevice->dev);
                 }
 
             }
-	   else if(pMgmt->eCurrState < WMAC_STATE_ASSOCPENDING) {
+	   else if (pMgmt->eCurrState < WMAC_STATE_ASSOCPENDING) {
                printk("WLAN_ASSOCIATE_WAIT:Association Fail???\n");
 	   }
-	   else  if(pDevice->byLinkWaitCount <= 4){    //mike add:wait another 2 sec if associated_frame delay!
-                pDevice->byLinkWaitCount ++;
-	       printk("WLAN_ASSOCIATE_WAIT:wait %d times!!\n",pDevice->byLinkWaitCount);
+	   else if (pDevice->byLinkWaitCount <= 4) {    //mike add:wait another 2 sec if associated_frame delay!
+                pDevice->byLinkWaitCount++;
+	       printk("WLAN_ASSOCIATE_WAIT:wait %d times!!\n", pDevice->byLinkWaitCount);
 	       spin_unlock_irq(&pDevice->lock);
 	       vCommandTimerWait((void *) pDevice, ASSOCIATE_TIMEOUT/2);
 	       return;
@@ -673,7 +673,7 @@ void vRunCommand(struct work_struct *work)
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_AP_MODE_START :
+        case WLAN_CMD_AP_MODE_START:
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_AP_MODE_START\n");
 
             if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
@@ -681,7 +681,7 @@ void vRunCommand(struct work_struct *work)
                 pMgmt->eCurrState = WMAC_STATE_IDLE;
                 pMgmt->eCurrMode = WMAC_MODE_STANDBY;
                 pDevice->bLinkPass = false;
-                ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
+                ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_SLOW);
                 if (pDevice->bEnableHostWEP == true)
                     BSSvClearNodeDBTable(pDevice, 1);
                 else
@@ -698,19 +698,19 @@ void vRunCommand(struct work_struct *work)
                 // always turn off unicast bit
                 MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_UNICAST);
                 pDevice->byRxMode &= ~RCR_UNICAST;
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wcmd: rx_mode = %x\n", pDevice->byRxMode );
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wcmd: rx_mode = %x\n", pDevice->byRxMode);
                 BSSvAddMulticastNode(pDevice);
-                if (netif_queue_stopped(pDevice->dev)){
+                if (netif_queue_stopped(pDevice->dev)) {
                     netif_wake_queue(pDevice->dev);
                 }
                 pDevice->bLinkPass = true;
-                ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
+                ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_INTER);
 		schedule_delayed_work(&pDevice->second_callback_work, HZ);
             }
             s_bCommandComplete(pDevice);
             break;
 
-        case WLAN_CMD_TX_PSPACKET_START :
+        case WLAN_CMD_TX_PSPACKET_START:
             // DTIM Multicast tx
             if (pMgmt->sNodeDBTable[0].bRxPSPoll) {
                 while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[0].sTxPSQueue)) != NULL) {
@@ -789,12 +789,12 @@ void vRunCommand(struct work_struct *work)
                                     1,
                                     &byTmp);
 
-        if ( ntStatus != STATUS_SUCCESS ) {
+        if (ntStatus != STATUS_SUCCESS) {
                 s_bCommandComplete(pDevice);
                 spin_unlock_irq(&pDevice->lock);
                 return;
         }
-        if ( (byTmp & GPIO3_DATA) == 0 ) {
+        if ((byTmp & GPIO3_DATA) == 0) {
 	    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_OFF........................\n");
                 // Old commands are useless.
                 // empty command Q
@@ -809,7 +809,7 @@ void vRunCommand(struct work_struct *work)
                 pDevice->byKeyIndex = 0;
                 pDevice->bTransmitKey = false;
 	    spin_unlock_irq(&pDevice->lock);
-	    KeyvInitTable(pDevice,&pDevice->sKey);
+	    KeyvInitTable(pDevice, &pDevice->sKey);
 	    spin_lock_irq(&pDevice->lock);
 	       pMgmt->byCSSPK = KEY_CTL_NONE;
                 pMgmt->byCSSGK = KEY_CTL_NONE;
@@ -828,7 +828,7 @@ void vRunCommand(struct work_struct *work)
                     // if(pDevice->bWPASuppWextEnabled == true)
                         {
                   	union iwreq_data  wrqu;
-                  	memset(&wrqu, 0, sizeof (wrqu));
+                  	memset(&wrqu, 0, sizeof(wrqu));
                           wrqu.ap_addr.sa_family = ARPHRD_ETHER;
                   	PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated)\n");
                   	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
@@ -850,15 +850,15 @@ void vRunCommand(struct work_struct *work)
 
 	    netif_stop_queue(pDevice->dev);
 	    CARDbRadioPowerOff(pDevice);
-             MACvRegBitsOn(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);
-	    ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_OFF);
+             MACvRegBitsOn(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
+	    ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_OFF);
 	    pDevice->bHWRadioOff = true;
         } else {
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_ON........................\n");
             pDevice->bHWRadioOff = false;
                 CARDbRadioPowerOn(pDevice);
-            MACvRegBitsOff(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);
-            ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_ON);
+            MACvRegBitsOff(pDevice, MAC_REG_GPIOCTL1, GPIO3_INTMD);
+            ControlvMaskByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PAPEDELAY, LEDSTS_STS, LEDSTS_ON);
         }
       }
 
@@ -894,14 +894,14 @@ void vRunCommand(struct work_struct *work)
 
         case WLAN_CMD_CHANGE_ANTENNA_START:
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change from Antenna%d to", (int)pDevice->dwRxAntennaSel);
-            if ( pDevice->dwRxAntennaSel == 0) {
-                pDevice->dwRxAntennaSel=1;
+            if (pDevice->dwRxAntennaSel == 0) {
+                pDevice->dwRxAntennaSel = 1;
                 if (pDevice->bTxRxAntInv == true)
                     BBvSetAntennaMode(pDevice, ANT_RXA);
                 else
                     BBvSetAntennaMode(pDevice, ANT_RXB);
             } else {
-                pDevice->dwRxAntennaSel=0;
+                pDevice->dwRxAntennaSel = 0;
                 if (pDevice->bTxRxAntInv == true)
                     BBvSetAntennaMode(pDevice, ANT_RXB);
                 else
@@ -916,8 +916,8 @@ void vRunCommand(struct work_struct *work)
             break;
 
         case WLAN_CMD_MAC_DISPOWERSAVING_START:
-            ControlvReadByte (pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
-            if ( (byData & PSCTL_PS) != 0 ) {
+            ControlvReadByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
+            if ((byData & PSCTL_PS) != 0) {
                 // disable power saving hw function
                 CONTROLnsRequestOut(pDevice,
                                 MESSAGE_TYPE_DISABLE_PS,
@@ -968,7 +968,7 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
         ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdDequeueIdx, CMD_Q_SIZE);
         pDevice->cbFreeCmdQueue++;
         pDevice->bCmdRunning = true;
-        switch ( pDevice->eCommand ) {
+        switch (pDevice->eCommand) {
             case WLAN_CMD_BSSID_SCAN:
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_BSSID_SCAN\n");
                 pDevice->eCommandState = WLAN_CMD_SCAN_START;
@@ -1123,7 +1123,7 @@ static int s_bClearBSSID_SCAN(struct vnt_private *pDevice)
 	unsigned int ii;
 
     if ((pDevice->cbFreeCmdQueue < CMD_Q_SIZE) && (uCmdDequeueIdx != pDevice->uCmdEnqueueIdx)) {
-        for (ii = 0; ii < (CMD_Q_SIZE - pDevice->cbFreeCmdQueue); ii ++) {
+        for (ii = 0; ii < (CMD_Q_SIZE - pDevice->cbFreeCmdQueue); ii++) {
             if (pDevice->eCmdQueue[uCmdDequeueIdx].eCmd == WLAN_CMD_BSSID_SCAN)
                 pDevice->eCmdQueue[uCmdDequeueIdx].eCmd = WLAN_CMD_IDLE;
             ADD_ONE_WITH_WRAP_AROUND(uCmdDequeueIdx, CMD_Q_SIZE);

commit 3b1388518a316f1eefe0b781e0583937d5407160
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Mon Nov 4 10:44:02 2013 +0200

    staging: vt6656: Fix (most) sparse warnings regarding static functions/variables
    
    This fixes sparse warnings for functions and variables, e.g.:
    * drivers/staging/vt6656/card.c:69:11: warning: symbol 'cwRXBCNTSFOff'
    was not declared. Should it be static?
    
    Some warnings were false positives, such as:
    * drivers/staging/vt6656/dpc.c:249:5: warning: symbol 'RXbBulkInProcessData'
    was not declared. Should it be static?
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 2f8e2a875331..1031e54284f7 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -224,7 +224,7 @@ static void s_vProbeChannel(struct vnt_private *pDevice)
  *
 -*/
 
-struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *pDevice,
+static struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *pDevice,
 	struct vnt_manager *pMgmt, u8 *pScanBSSID, PWLAN_IE_SSID pSSID,
 	PWLAN_IE_SUPP_RATES pCurrRates, PWLAN_IE_SUPP_RATES pCurrExtSuppRates)
 {
@@ -266,7 +266,8 @@ struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *pDevice,
     return pTxPacket;
 }
 
-void vCommandTimerWait(struct vnt_private *pDevice, unsigned long MSecond)
+static void
+vCommandTimerWait(struct vnt_private *pDevice, unsigned long MSecond)
 {
 	schedule_delayed_work(&pDevice->run_command_work,
 						msecs_to_jiffies(MSecond));

commit 60cc27472c9c4239cf6aec957fdb520510a5d93a
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Oct 14 19:46:52 2013 +0100

    staging: vt6656: Remove 10 second timer and move to BSSvSecondCallBack
    
    Remove sTimerTxData 10 second timer which triggers PSbSendNullPacket
    every 40 seconds when bLinkPass == true.
    
    Move the 40 second timer to the existing BSSvSecondCallBack
    one second delayed workqueue and trigger every 40 seconds when
    bLinkPass == true.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 95d2960bd1a1..2f8e2a875331 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -657,22 +657,6 @@ void vRunCommand(struct work_struct *work)
                     netif_wake_queue(pDevice->dev);
                 }
 
-		 if(pDevice->IsTxDataTrigger != false)   {    //TxDataTimer is not triggered at the first time
-                     // printk("Re-initial TxDataTimer****\n");
-		    del_timer(&pDevice->sTimerTxData);
-                      init_timer(&pDevice->sTimerTxData);
-			pDevice->sTimerTxData.data = (unsigned long) pDevice;
-                      pDevice->sTimerTxData.function = (TimerFunction)BSSvSecondTxData;
-                      pDevice->sTimerTxData.expires = RUN_AT(10*HZ);      //10s callback
-                      pDevice->fTxDataInSleep = false;
-                      pDevice->nTxDataTimeCout = 0;
-		 }
-		 else {
-		   // printk("mike:-->First time trigger TimerTxData InSleep\n");
-		 }
-		pDevice->IsTxDataTrigger = true;
-                add_timer(&pDevice->sTimerTxData);
-
             }
 	   else if(pMgmt->eCurrState < WMAC_STATE_ASSOCPENDING) {
                printk("WLAN_ASSOCIATE_WAIT:Association Fail???\n");
@@ -684,7 +668,6 @@ void vRunCommand(struct work_struct *work)
 	       vCommandTimerWait((void *) pDevice, ASSOCIATE_TIMEOUT/2);
 	       return;
 	   }
-	          pDevice->byLinkWaitCount = 0;
 
             s_bCommandComplete(pDevice);
             break;
@@ -1162,33 +1145,3 @@ void vResetCommandTimer(struct vnt_private *pDevice)
 	pDevice->bCmdRunning = false;
 	pDevice->bCmdClear = false;
 }
-
-void BSSvSecondTxData(struct vnt_private *pDevice)
-{
-	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
-
-	pDevice->nTxDataTimeCout++;
-
-	if (pDevice->nTxDataTimeCout < 4) {   //don't tx data if timer less than 40s
-		// printk("mike:%s-->no data Tx not exceed the desired Time as %d\n",__FUNCTION__,
-		//  	(int)pDevice->nTxDataTimeCout);
-		pDevice->sTimerTxData.expires = RUN_AT(10 * HZ);      //10s callback
-		add_timer(&pDevice->sTimerTxData);
-		return;
-	}
-
-	spin_lock_irq(&pDevice->lock);
-	//is wap_supplicant running successful OR only open && sharekey mode!
-	if (((pDevice->bLinkPass == true) &&
-		(pMgmt->eAuthenMode < WMAC_AUTH_WPA)) ||  //open && sharekey linking
-		(pDevice->fWPA_Authened == true)) {   //wpa linking
-		//   printk("mike:%s-->InSleep Tx Data Procedure\n",__FUNCTION__);
-		pDevice->fTxDataInSleep = true;
-		PSbSendNullPacket(pDevice);      //send null packet
-		pDevice->fTxDataInSleep = false;
-	}
-	spin_unlock_irq(&pDevice->lock);
-
-	pDevice->sTimerTxData.expires = RUN_AT(10 * HZ);      //10s callback
-	add_timer(&pDevice->sTimerTxData);
-}

commit 17f3ced05f5ae20c619103df9718af597cf83ac4
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Oct 14 19:51:45 2013 +0100

    staging: vt6656: return from workqueues on fMP_DISCONNECTED
    
    Return from work queues on flag fMP_DISCONNECTED to prevent
    any scheduling threads past closing of device.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index debb87a6aba7..95d2960bd1a1 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -286,6 +286,9 @@ void vRunCommand(struct work_struct *work)
 	u8 byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
 	u8 byData;
 
+	if (pDevice->Flags & fMP_DISCONNECTED)
+		return;
+
     if (pDevice->dwDiagRefCount != 0)
         return;
     if (pDevice->bCmdRunning != true)

commit bd9a6dbada2263ffb26eef7a67283553092d2dee
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri Sep 27 16:51:13 2013 +0100

    staging: vt6656: covert BSSvSecondCallBack to delayed_work.
    
    timer to delay workqueue.
    sTimerSecondCallback -> second_callback_work
    
    The delayed work queue is declared in device.h
    
    This timer is very heavy on the system.
    
    Improves over performance of driver and reduce the atomic
    area of driver.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 3b9bfcb40fcb..debb87a6aba7 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -690,7 +690,7 @@ void vRunCommand(struct work_struct *work)
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_AP_MODE_START\n");
 
             if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-                del_timer(&pMgmt->sTimerSecondCallback);
+		cancel_delayed_work_sync(&pDevice->second_callback_work);
                 pMgmt->eCurrState = WMAC_STATE_IDLE;
                 pMgmt->eCurrMode = WMAC_MODE_STANDBY;
                 pDevice->bLinkPass = false;
@@ -718,7 +718,7 @@ void vRunCommand(struct work_struct *work)
                 }
                 pDevice->bLinkPass = true;
                 ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
-                add_timer(&pMgmt->sTimerSecondCallback);
+		schedule_delayed_work(&pDevice->second_callback_work, HZ);
             }
             s_bCommandComplete(pDevice);
             break;

commit 94488a7ebfbc95c4b8fbfe39644e97b926a550a7
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Fri Sep 27 16:48:14 2013 +0100

    staging: vt6656: device.h convert sTimerCommand to delayed_work
    
    timer to delay workqueue.
    sTimerCommand -> run_command_work
    
    sTimerCommand is very heavy on the system timer.
    
    Improves over performance of driver and reduce the atomic
    area of driver.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 0013cb73d83b..3b9bfcb40fcb 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -268,20 +268,14 @@ struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *pDevice,
 
 void vCommandTimerWait(struct vnt_private *pDevice, unsigned long MSecond)
 {
-
-	init_timer(&pDevice->sTimerCommand);
-
-	pDevice->sTimerCommand.data = (unsigned long)pDevice;
-	pDevice->sTimerCommand.function = (TimerFunction)vRunCommand;
-	pDevice->sTimerCommand.expires = RUN_AT((MSecond * HZ) / 1000);
-
-	add_timer(&pDevice->sTimerCommand);
-
-	return;
+	schedule_delayed_work(&pDevice->run_command_work,
+						msecs_to_jiffies(MSecond));
 }
 
-void vRunCommand(struct vnt_private *pDevice)
+void vRunCommand(struct work_struct *work)
 {
+	struct vnt_private *pDevice =
+		container_of(work, struct vnt_private, run_command_work.work);
 	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
 	PWLAN_IE_SSID pItemSSID;
 	PWLAN_IE_SSID pItemSSIDCurr;
@@ -1156,14 +1150,8 @@ static int s_bClearBSSID_SCAN(struct vnt_private *pDevice)
 //mike add:reset command timer
 void vResetCommandTimer(struct vnt_private *pDevice)
 {
+	cancel_delayed_work_sync(&pDevice->run_command_work);
 
-	//delete timer
-	del_timer(&pDevice->sTimerCommand);
-	//init timer
-	init_timer(&pDevice->sTimerCommand);
-	pDevice->sTimerCommand.data = (unsigned long)pDevice;
-	pDevice->sTimerCommand.function = (TimerFunction)vRunCommand;
-	pDevice->sTimerCommand.expires = RUN_AT(HZ);
 	pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
 	pDevice->uCmdDequeueIdx = 0;
 	pDevice->uCmdEnqueueIdx = 0;

commit 9fbafdd9add10e349deeb1f38290943d5107e276
Author: Andres More <more.andres@gmail.com>
Date:   Tue Mar 26 18:18:30 2013 -0500

    staging: vt6656: remove consecutive newlines
    
    Several sed -i '/^$/{ N /^\n$/ D }' drivers/staging/vt6656/*.[ch]
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index d150d050df82..0013cb73d83b 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -55,11 +55,6 @@
 #include "channel.h"
 #include "iowpa.h"
 
-
-
-
-
-
 static int          msglevel                =MSG_LEVEL_INFO;
 //static int          msglevel                =MSG_LEVEL_DEBUG;
 
@@ -69,14 +64,10 @@ static struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *,
 	struct vnt_manager *pMgmt, u8 *pScanBSSID, PWLAN_IE_SSID pSSID,
 	PWLAN_IE_SUPP_RATES pCurrRates, PWLAN_IE_SUPP_RATES pCurrExtSuppRates);
 
-
 static int s_bCommandComplete(struct vnt_private *);
 
-
 static int s_bClearBSSID_SCAN(struct vnt_private *);
 
-
-
 /*
  * Description:
  *      Stop AdHoc beacon during scan process
@@ -131,7 +122,6 @@ static void vAdHocBeaconStop(struct vnt_private *pDevice)
 
 } /* vAdHocBeaconStop */
 
-
 /*
  * Description:
  *      Restart AdHoc beacon after scan process complete
@@ -164,7 +154,6 @@ static void vAdHocBeaconRestart(struct vnt_private *pDevice)
 
 }
 
-
 /*+
  *
  * Routine Description:
@@ -193,7 +182,6 @@ static void s_vProbeChannel(struct vnt_private *pDevice)
 	u8 *pbyRate;
 	int ii;
 
-
     if (pDevice->byBBType == BB_TYPE_11A) {
         pbyRate = &abyCurrSuppRatesA[0];
     } else if (pDevice->byBBType == BB_TYPE_11B) {
@@ -225,9 +213,6 @@ static void s_vProbeChannel(struct vnt_private *pDevice)
 
 }
 
-
-
-
 /*+
  *
  * Routine Description:
@@ -239,7 +224,6 @@ static void s_vProbeChannel(struct vnt_private *pDevice)
  *
 -*/
 
-
 struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *pDevice,
 	struct vnt_manager *pMgmt, u8 *pScanBSSID, PWLAN_IE_SSID pSSID,
 	PWLAN_IE_SUPP_RATES pCurrRates, PWLAN_IE_SUPP_RATES pCurrExtSuppRates)
@@ -247,7 +231,6 @@ struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *pDevice,
 	struct vnt_tx_mgmt *pTxPacket = NULL;
 	WLAN_FR_PROBEREQ sFrame;
 
-
 	pTxPacket = (struct vnt_tx_mgmt *)pMgmt->pbyMgmtPacketPool;
 	memset(pTxPacket, 0, sizeof(struct vnt_tx_mgmt)
 		+ WLAN_PROBEREQ_FR_MAXLEN);
@@ -309,7 +292,6 @@ void vRunCommand(struct vnt_private *pDevice)
 	u8 byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
 	u8 byData;
 
-
     if (pDevice->dwDiagRefCount != 0)
         return;
     if (pDevice->bCmdRunning != true)
@@ -496,7 +478,6 @@ void vRunCommand(struct vnt_private *pDevice)
             s_bCommandComplete(pDevice);
             break;
 
-
         case WLAN_CMD_SSID_START:
 
 		pDevice->byReAssocCount = 0;
@@ -903,7 +884,6 @@ void vRunCommand(struct vnt_private *pDevice)
             s_bCommandComplete(pDevice);
             break;
 
-
         case WLAN_CMD_CHANGE_BBSENSITIVITY_START:
 
             pDevice->bStopDataPkt = true;
@@ -954,7 +934,6 @@ void vRunCommand(struct vnt_private *pDevice)
             s_bCommandComplete(pDevice);
             break;
 
-
         case WLAN_CMD_MAC_DISPOWERSAVING_START:
             ControlvReadByte (pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
             if ( (byData & PSCTL_PS) != 0 ) {
@@ -987,7 +966,6 @@ void vRunCommand(struct vnt_private *pDevice)
     return;
 }
 
-
 static int s_bCommandComplete(struct vnt_private *pDevice)
 {
 	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
@@ -995,7 +973,6 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 	int bRadioCmd = false;
 	int bForceSCAN = true;
 
-
     pDevice->eCommandState = WLAN_CMD_IDLE;
     if (pDevice->cbFreeCmdQueue == CMD_Q_SIZE) {
         //Command Queue Empty
@@ -1176,7 +1153,6 @@ static int s_bClearBSSID_SCAN(struct vnt_private *pDevice)
     return true;
 }
 
-
 //mike add:reset command timer
 void vResetCommandTimer(struct vnt_private *pDevice)
 {

commit 257f65801520a5c888930d410f781d408a405990
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Mar 25 19:50:44 2013 +0000

    staging: vt6656: Fix stuck in scanning with variable uScanChannel.
    
    When pMgmt->uScanChannel > pDevice->byMaxChannel scanning ends
    but no SIOCGIWSCAN(scan done) message is sent. This section of code is
    duplicate of that in WLAN_CMD_SCAN_END which sends scan done.
    So remove it and jump eCommandState to WLAN_CMD_SCAN_END.
    
    Increment uScanChannel on !ChannelValid.
    
    At WLAN_CMD_SCAN_END reset uScanChannel to 0 when done.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index d6db8d5c4f61..d150d050df82 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -340,29 +340,7 @@ void vRunCommand(struct vnt_private *pDevice)
                 pMgmt->uScanChannel = pDevice->byMinChannel;
             }
             if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
-                pMgmt->eScanState = WMAC_NO_SCANNING;
-
-                if (pDevice->byBBType != pDevice->byScanBBType) {
-                    pDevice->byBBType = pDevice->byScanBBType;
-                    CARDvSetBSSMode(pDevice);
-                }
-
-                if (pDevice->bUpdateBBVGA) {
-                    BBvSetShortSlotTime(pDevice);
-                    BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
-                    BBvUpdatePreEDThreshold(pDevice, false);
-                }
-                // Set channel back
-                vAdHocBeaconRestart(pDevice);
-                // Set channel back
-                CARDbSetMediaChannel(pDevice, pMgmt->uCurrChannel);
-                // Set Filter
-                if (pMgmt->bCurrBSSIDFilterOn) {
-                    MACvRegBitsOn(pDevice, MAC_REG_RCR, RCR_BSSID);
-                    pDevice->byRxMode |= RCR_BSSID;
-                }
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning, set back to channel: [%d]\n", pMgmt->uCurrChannel);
-                pDevice->bStopDataPkt = false;
+		pDevice->eCommandState = WLAN_CMD_SCAN_END;
                 s_bCommandComplete(pDevice);
                 spin_unlock_irq(&pDevice->lock);
                 return;
@@ -370,6 +348,7 @@ void vRunCommand(struct vnt_private *pDevice)
             } else {
                 if (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel)) {
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Invalid channel pMgmt->uScanChannel = %d \n",pMgmt->uScanChannel);
+			pMgmt->uScanChannel++;
                     s_bCommandComplete(pDevice);
                     spin_unlock_irq(&pDevice->lock);
                     return;
@@ -466,6 +445,7 @@ void vRunCommand(struct vnt_private *pDevice)
                 pDevice->byRxMode |= RCR_BSSID;
             }
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning, set back to channel: [%d]\n", pMgmt->uCurrChannel);
+		pMgmt->uScanChannel = 0;
             pMgmt->eScanState = WMAC_NO_SCANNING;
             pDevice->bStopDataPkt = false;
 

commit 00d0603cbd9aa1c9a28c9fe973d14f74e83ba646
Author: Andres More <more.andres@gmail.com>
Date:   Mon Mar 18 20:33:51 2013 -0500

    staging: vt6656: remove code placeholders
    
    Removed comments from coding template.
    sed -i '/^\/\*---/d' drivers/staging/vt6656/*.[ch]
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 18e1d5bf5f60..d6db8d5c4f61 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -55,17 +55,13 @@
 #include "channel.h"
 #include "iowpa.h"
 
-/*---------------------  Static Definitions -------------------------*/
 
 
 
 
-/*---------------------  Static Classes  ----------------------------*/
 
-/*---------------------  Static Variables  --------------------------*/
 static int          msglevel                =MSG_LEVEL_INFO;
 //static int          msglevel                =MSG_LEVEL_DEBUG;
-/*---------------------  Static Functions  --------------------------*/
 
 static void s_vProbeChannel(struct vnt_private *);
 
@@ -79,9 +75,7 @@ static int s_bCommandComplete(struct vnt_private *);
 
 static int s_bClearBSSID_SCAN(struct vnt_private *);
 
-/*---------------------  Export Variables  --------------------------*/
 
-/*---------------------  Export Functions  --------------------------*/
 
 /*
  * Description:

commit 4fcf94980c994ed992d8efd1424bd842225f1cc6
Author: Andres More <more.andres@gmail.com>
Date:   Mon Feb 25 20:32:55 2013 -0500

    staging: vt6656: removed no longer useful ttype.h file
    
    Removed includes and added linux/types.h instead when needed.
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 4d9e1456a35d..18e1d5bf5f60 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -38,7 +38,6 @@
  *
  */
 
-#include "ttype.h"
 #include "tmacro.h"
 #include "device.h"
 #include "mac.h"

commit 3eaca0d2f5a4137d4a5ecf63cf34cdf13b499bee
Author: Andres More <more.andres@gmail.com>
Date:   Mon Feb 25 20:32:52 2013 -0500

    staging: vt6656: replaced custom WORD definition with u16
    
    Checkpatch findings were not resolved.
    
    sed -i 's/\bWORD\b/u16/g' drivers/staging/vt6656/*.[ch]
    sed -i 's/\bPWORD\b/u16 */g' drivers/staging/vt6656/*.[ch]
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 904b5dae5d2a..4d9e1456a35d 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -1147,7 +1147,7 @@ int bScheduleCommand(struct vnt_private *pDevice,
                 break;
 /*
             case WLAN_CMD_DEAUTH:
-                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].wDeAuthenReason = *((PWORD)pbyItem0);
+                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].wDeAuthenReason = *((u16 *)pbyItem0);
                 break;
 */
 

commit b902fbfebf2c80c3782e41eda24b487964a47fd1
Author: Andres More <more.andres@gmail.com>
Date:   Mon Feb 25 20:32:51 2013 -0500

    staging: vt6656: replaced custom BYTE definition with u8
    
    Checkpatch findings were not resolved, only direct replacement.
    
    sed -i 's/\bBYTE\b/u8/g' drivers/staging/vt6656/*.[ch]
    sed -i 's/\bPBYTE\b/u8 */g' drivers/staging/vt6656/*.[ch]
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 4bb652bf7cf6..904b5dae5d2a 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -260,7 +260,7 @@ struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *pDevice,
 		+ WLAN_PROBEREQ_FR_MAXLEN);
 	pTxPacket->p80211Header = (PUWLAN_80211HDR)((u8 *)pTxPacket
 		+ sizeof(struct vnt_tx_mgmt));
-    sFrame.pBuf = (PBYTE)pTxPacket->p80211Header;
+    sFrame.pBuf = (u8 *)pTxPacket->p80211Header;
     sFrame.len = WLAN_PROBEREQ_FR_MAXLEN;
     vMgrEncodeProbeRequest(&sFrame);
     sFrame.pHdr->sA3.wFrameCtl = cpu_to_le16(
@@ -845,7 +845,7 @@ void vRunCommand(struct vnt_private *pDevice)
 
        {
 	       int ntStatus = STATUS_SUCCESS;
-        BYTE            byTmp;
+        u8            byTmp;
 
         ntStatus = CONTROLnsRequestIn(pDevice,
                                     MESSAGE_TYPE_READ,

commit 4e9b5e2b8b7f1a9116d760a25f8ea98b3d5b64f4
Author: Andres More <more.andres@gmail.com>
Date:   Tue Feb 12 20:36:30 2013 -0500

    staging: vt6656: replaced custom TRUE definition with true
    
    Checkpatch findings were not resolved, just direct replacement.
    
    sed -i 's/\bTRUE\b/true/g' drivers/staging/vt6656/*.[ch]
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index b4d2989a949c..4bb652bf7cf6 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -121,11 +121,11 @@ static void vAdHocBeaconStop(struct vnt_private *pDevice)
         if ((pMgmt->uIBSSChannel <=  CB_MAX_CHANNEL_24G) &&
              (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G))
         {
-            bStop = TRUE;
+            bStop = true;
         }
         if (pMgmt->uIBSSChannel >  CB_MAX_CHANNEL_24G)
         {
-            bStop = TRUE;
+            bStop = true;
         }
     }
 
@@ -319,7 +319,7 @@ void vRunCommand(struct vnt_private *pDevice)
 
     if (pDevice->dwDiagRefCount != 0)
         return;
-    if (pDevice->bCmdRunning != TRUE)
+    if (pDevice->bCmdRunning != true)
         return;
 
     spin_lock_irq(&pDevice->lock);
@@ -329,7 +329,7 @@ void vRunCommand(struct vnt_private *pDevice)
         case WLAN_CMD_SCAN_START:
 
 		pDevice->byReAssocCount = 0;
-            if (pDevice->bRadioOff == TRUE) {
+            if (pDevice->bRadioOff == true) {
                 s_bCommandComplete(pDevice);
                 spin_unlock_irq(&pDevice->lock);
                 return;
@@ -395,7 +395,7 @@ void vRunCommand(struct vnt_private *pDevice)
 		       pDevice->bLinkPass); */
                     pMgmt->eScanState = WMAC_IS_SCANNING;
                     pDevice->byScanBBType = pDevice->byBBType;  //lucas
-                    pDevice->bStopDataPkt = TRUE;
+                    pDevice->bStopDataPkt = true;
                     // Turn off RCR_BSSID filter every time
                     MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_BSSID);
                     pDevice->byRxMode &= ~RCR_BSSID;
@@ -419,7 +419,7 @@ void vRunCommand(struct vnt_private *pDevice)
                 if (pDevice->bUpdateBBVGA) {
                     BBvSetShortSlotTime(pDevice);
                     BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
-                    BBvUpdatePreEDThreshold(pDevice, TRUE);
+                    BBvUpdatePreEDThreshold(pDevice, true);
                 }
                 pMgmt->uScanChannel++;
 
@@ -518,7 +518,7 @@ void vRunCommand(struct vnt_private *pDevice)
 //                pDevice->bBeaconBufReady = false;
             }
             netif_stop_queue(pDevice->dev);
-            if (pDevice->bNeedRadioOFF == TRUE)
+            if (pDevice->bNeedRadioOFF == true)
                 CARDbRadioPowerOff(pDevice);
             s_bCommandComplete(pDevice);
             break;
@@ -527,7 +527,7 @@ void vRunCommand(struct vnt_private *pDevice)
         case WLAN_CMD_SSID_START:
 
 		pDevice->byReAssocCount = 0;
-            if (pDevice->bRadioOff == TRUE) {
+            if (pDevice->bRadioOff == true) {
                 s_bCommandComplete(pDevice);
                 spin_unlock_irq(&pDevice->lock);
                 return;
@@ -597,9 +597,9 @@ void vRunCommand(struct vnt_private *pDevice)
                     if (netif_queue_stopped(pDevice->dev)){
                         netif_wake_queue(pDevice->dev);
                     }
-                    pDevice->bLinkPass = TRUE;
+                    pDevice->bLinkPass = true;
                     ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
-                    pMgmt->sNodeDBTable[0].bActive = TRUE;
+                    pMgmt->sNodeDBTable[0].bActive = true;
                     pMgmt->sNodeDBTable[0].uInActiveCount = 0;
                 }
                 else {
@@ -630,7 +630,7 @@ void vRunCommand(struct vnt_private *pDevice)
                     BSSvAddMulticastNode(pDevice);
                     s_bClearBSSID_SCAN(pDevice);
 /*
-                    pDevice->bLinkPass = TRUE;
+                    pDevice->bLinkPass = true;
                     ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
                     if (netif_queue_stopped(pDevice->dev)){
                         netif_wake_queue(pDevice->dev);
@@ -640,7 +640,7 @@ void vRunCommand(struct vnt_private *pDevice)
                 }
                 else {
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Disconnect SSID none\n");
-                    // if(pDevice->bWPASuppWextEnabled == TRUE)
+                    // if(pDevice->bWPASuppWextEnabled == true)
                         {
                   	union iwreq_data  wrqu;
                   	memset(&wrqu, 0, sizeof (wrqu));
@@ -698,7 +698,7 @@ void vRunCommand(struct vnt_private *pDevice)
 */
                 pDevice->byLinkWaitCount = 0;
                 pDevice->byReAssocCount = 0;
-                pDevice->bLinkPass = TRUE;
+                pDevice->bLinkPass = true;
                 ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
                 s_bClearBSSID_SCAN(pDevice);
 
@@ -719,7 +719,7 @@ void vRunCommand(struct vnt_private *pDevice)
 		 else {
 		   // printk("mike:-->First time trigger TimerTxData InSleep\n");
 		 }
-		pDevice->IsTxDataTrigger = TRUE;
+		pDevice->IsTxDataTrigger = true;
                 add_timer(&pDevice->sTimerTxData);
 
             }
@@ -747,7 +747,7 @@ void vRunCommand(struct vnt_private *pDevice)
                 pMgmt->eCurrMode = WMAC_MODE_STANDBY;
                 pDevice->bLinkPass = false;
                 ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
-                if (pDevice->bEnableHostWEP == TRUE)
+                if (pDevice->bEnableHostWEP == true)
                     BSSvClearNodeDBTable(pDevice, 1);
                 else
                     BSSvClearNodeDBTable(pDevice, 0);
@@ -768,7 +768,7 @@ void vRunCommand(struct vnt_private *pDevice)
                 if (netif_queue_stopped(pDevice->dev)){
                     netif_wake_queue(pDevice->dev);
                 }
-                pDevice->bLinkPass = TRUE;
+                pDevice->bLinkPass = true;
                 ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
                 add_timer(&pMgmt->sTimerSecondCallback);
             }
@@ -784,7 +784,7 @@ void vRunCommand(struct vnt_private *pDevice)
                         pDevice->bMoreData = false;
                     }
                     else {
-                        pDevice->bMoreData = TRUE;
+                        pDevice->bMoreData = true;
                     }
 
                     if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0) {
@@ -809,7 +809,7 @@ void vRunCommand(struct vnt_private *pDevice)
                             pDevice->bMoreData = false;
                         }
                         else {
-                            pDevice->bMoreData = TRUE;
+                            pDevice->bMoreData = true;
                         }
 
                         if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0) {
@@ -838,7 +838,7 @@ void vRunCommand(struct vnt_private *pDevice)
         case WLAN_CMD_RADIO_START:
 
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_RADIO_START\n");
-       //     if (pDevice->bRadioCmd == TRUE)
+       //     if (pDevice->bRadioCmd == true)
        //         CARDbRadioPowerOn(pDevice);
        //     else
        //         CARDbRadioPowerOff(pDevice);
@@ -867,9 +867,9 @@ void vRunCommand(struct vnt_private *pDevice)
                 pDevice->uCmdDequeueIdx = 0;
                 pDevice->uCmdEnqueueIdx = 0;
                 //0415pDevice->bCmdRunning = false;
-                pDevice->bCmdClear = TRUE;
+                pDevice->bCmdClear = true;
                 pDevice->bStopTx0Pkt = false;
-                pDevice->bStopDataPkt = TRUE;
+                pDevice->bStopDataPkt = true;
 
                 pDevice->byKeyIndex = 0;
                 pDevice->bTransmitKey = false;
@@ -879,7 +879,7 @@ void vRunCommand(struct vnt_private *pDevice)
 	       pMgmt->byCSSPK = KEY_CTL_NONE;
                 pMgmt->byCSSGK = KEY_CTL_NONE;
 
-	  if (pDevice->bLinkPass == TRUE) {
+	  if (pDevice->bLinkPass == true) {
                 // reason = 8 : disassoc because sta has left
 		vMgrDisassocBeginSta((void *) pDevice,
 				     pMgmt,
@@ -890,7 +890,7 @@ void vRunCommand(struct vnt_private *pDevice)
                 // unlock command busy
                         pMgmt->eCurrState = WMAC_STATE_IDLE;
                         pMgmt->sNodeDBTable[0].bActive = false;
-                    // if(pDevice->bWPASuppWextEnabled == TRUE)
+                    // if(pDevice->bWPASuppWextEnabled == true)
                         {
                   	union iwreq_data  wrqu;
                   	memset(&wrqu, 0, sizeof (wrqu));
@@ -917,7 +917,7 @@ void vRunCommand(struct vnt_private *pDevice)
 	    CARDbRadioPowerOff(pDevice);
              MACvRegBitsOn(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);
 	    ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_OFF);
-	    pDevice->bHWRadioOff = TRUE;
+	    pDevice->bHWRadioOff = true;
         } else {
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_ON........................\n");
             pDevice->bHWRadioOff = false;
@@ -933,7 +933,7 @@ void vRunCommand(struct vnt_private *pDevice)
 
         case WLAN_CMD_CHANGE_BBSENSITIVITY_START:
 
-            pDevice->bStopDataPkt = TRUE;
+            pDevice->bStopDataPkt = true;
             pDevice->byBBVGACurrent = pDevice->byBBVGANew;
             BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change sensitivity pDevice->byBBVGACurrent = %x\n", pDevice->byBBVGACurrent);
@@ -962,13 +962,13 @@ void vRunCommand(struct vnt_private *pDevice)
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change from Antenna%d to", (int)pDevice->dwRxAntennaSel);
             if ( pDevice->dwRxAntennaSel == 0) {
                 pDevice->dwRxAntennaSel=1;
-                if (pDevice->bTxRxAntInv == TRUE)
+                if (pDevice->bTxRxAntInv == true)
                     BBvSetAntennaMode(pDevice, ANT_RXA);
                 else
                     BBvSetAntennaMode(pDevice, ANT_RXB);
             } else {
                 pDevice->dwRxAntennaSel=0;
-                if (pDevice->bTxRxAntInv == TRUE)
+                if (pDevice->bTxRxAntInv == true)
                     BBvSetAntennaMode(pDevice, ANT_RXB);
                 else
                     BBvSetAntennaMode(pDevice, ANT_RXA);
@@ -1020,14 +1020,14 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
 	PWLAN_IE_SSID pSSID;
 	int bRadioCmd = false;
-	int bForceSCAN = TRUE;
+	int bForceSCAN = true;
 
 
     pDevice->eCommandState = WLAN_CMD_IDLE;
     if (pDevice->cbFreeCmdQueue == CMD_Q_SIZE) {
         //Command Queue Empty
         pDevice->bCmdRunning = false;
-        return TRUE;
+        return true;
     }
     else {
         pDevice->eCommand = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].eCmd;
@@ -1036,7 +1036,7 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
         bForceSCAN = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].bForceSCAN;
         ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdDequeueIdx, CMD_Q_SIZE);
         pDevice->cbFreeCmdQueue++;
-        pDevice->bCmdRunning = TRUE;
+        pDevice->bCmdRunning = true;
         switch ( pDevice->eCommand ) {
             case WLAN_CMD_BSSID_SCAN:
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_BSSID_SCAN\n");
@@ -1048,7 +1048,7 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
                     memset(pMgmt->abyScanSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
                 }
 /*
-                if ((bForceSCAN == false) && (pDevice->bLinkPass == TRUE)) {
+                if ((bForceSCAN == false) && (pDevice->bLinkPass == true)) {
                     if ((pSSID->len == ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->len) &&
                         ( !memcmp(pSSID->abySSID, ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->abySSID, pSSID->len))) {
                         pDevice->eCommandState = WLAN_CMD_IDLE;
@@ -1116,7 +1116,7 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 	vCommandTimerWait(pDevice, 0);
     }
 
-    return TRUE;
+    return true;
 }
 
 int bScheduleCommand(struct vnt_private *pDevice,
@@ -1127,7 +1127,7 @@ int bScheduleCommand(struct vnt_private *pDevice,
         return (false);
     }
     pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].eCmd = eCommand;
-    pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = TRUE;
+    pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = true;
     memset(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID, 0 , WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
     if (pbyItem0 != NULL) {
         switch (eCommand) {
@@ -1168,7 +1168,7 @@ int bScheduleCommand(struct vnt_private *pDevice,
     }
     else {
     }
-    return (TRUE);
+    return (true);
 
 }
 
@@ -1183,7 +1183,7 @@ int bScheduleCommand(struct vnt_private *pDevice,
  *  Out:
  *      none
  *
- * Return Value: TRUE if success; otherwise false
+ * Return Value: true if success; otherwise false
  *
  */
 static int s_bClearBSSID_SCAN(struct vnt_private *pDevice)
@@ -1200,7 +1200,7 @@ static int s_bClearBSSID_SCAN(struct vnt_private *pDevice)
                 break;
         }
     }
-    return TRUE;
+    return true;
 }
 
 
@@ -1239,11 +1239,11 @@ void BSSvSecondTxData(struct vnt_private *pDevice)
 
 	spin_lock_irq(&pDevice->lock);
 	//is wap_supplicant running successful OR only open && sharekey mode!
-	if (((pDevice->bLinkPass == TRUE) &&
+	if (((pDevice->bLinkPass == true) &&
 		(pMgmt->eAuthenMode < WMAC_AUTH_WPA)) ||  //open && sharekey linking
-		(pDevice->fWPA_Authened == TRUE)) {   //wpa linking
+		(pDevice->fWPA_Authened == true)) {   //wpa linking
 		//   printk("mike:%s-->InSleep Tx Data Procedure\n",__FUNCTION__);
-		pDevice->fTxDataInSleep = TRUE;
+		pDevice->fTxDataInSleep = true;
 		PSbSendNullPacket(pDevice);      //send null packet
 		pDevice->fTxDataInSleep = false;
 	}

commit e269fc2d129ade6543c22052755becf37e306e2a
Author: Andres More <more.andres@gmail.com>
Date:   Tue Feb 12 20:36:29 2013 -0500

    staging: vt6656: replaced custom FALSE definition with false
    
    Checkpatch findings were not resolved, just direct replacement.
    
    sed -i 's/\bFALSE\b/false/g' drivers/staging/vt6656/*.[ch]
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 51f48c1244f6..b4d2989a949c 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -114,7 +114,7 @@ static void vAdHocBeaconStop(struct vnt_private *pDevice)
      *      or
      *      (3.2) AdHoc channel is in A mode
      */
-    bStop = FALSE;
+    bStop = false;
     if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
     (pMgmt->eCurrState >= WMAC_STATE_STARTED))
     {
@@ -357,7 +357,7 @@ void vRunCommand(struct vnt_private *pDevice)
                 if (pDevice->bUpdateBBVGA) {
                     BBvSetShortSlotTime(pDevice);
                     BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
-                    BBvUpdatePreEDThreshold(pDevice, FALSE);
+                    BBvUpdatePreEDThreshold(pDevice, false);
                 }
                 // Set channel back
                 vAdHocBeaconRestart(pDevice);
@@ -369,7 +369,7 @@ void vRunCommand(struct vnt_private *pDevice)
                     pDevice->byRxMode |= RCR_BSSID;
                 }
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning, set back to channel: [%d]\n", pMgmt->uCurrChannel);
-                pDevice->bStopDataPkt = FALSE;
+                pDevice->bStopDataPkt = false;
                 s_bCommandComplete(pDevice);
                 spin_unlock_irq(&pDevice->lock);
                 return;
@@ -433,7 +433,7 @@ void vRunCommand(struct vnt_private *pDevice)
                     pDevice->eCommandState = WLAN_CMD_SCAN_END;
 
                 }
-                if ((pMgmt->b11hEnable == FALSE) ||
+                if ((pMgmt->b11hEnable == false) ||
                     (pMgmt->uScanChannel < CB_MAX_CHANNEL_24G)) {
                     s_vProbeChannel(pDevice);
                     spin_unlock_irq(&pDevice->lock);
@@ -460,7 +460,7 @@ void vRunCommand(struct vnt_private *pDevice)
             if (pDevice->bUpdateBBVGA) {
                 BBvSetShortSlotTime(pDevice);
                 BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
-                BBvUpdatePreEDThreshold(pDevice, FALSE);
+                BBvUpdatePreEDThreshold(pDevice, false);
             }
 
             // Set channel back
@@ -474,7 +474,7 @@ void vRunCommand(struct vnt_private *pDevice)
             }
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning, set back to channel: [%d]\n", pMgmt->uCurrChannel);
             pMgmt->eScanState = WMAC_NO_SCANNING;
-            pDevice->bStopDataPkt = FALSE;
+            pDevice->bStopDataPkt = false;
 
 		/*send scan event to wpa_Supplicant*/
 		PRINT_K("wireless_send_event--->SIOCGIWSCAN(scan done)\n");
@@ -493,12 +493,12 @@ void vRunCommand(struct vnt_private *pDevice)
                 return;
             } else {
 
-		      pDevice->bwextstep0 = FALSE;
-                        pDevice->bwextstep1 = FALSE;
-                        pDevice->bwextstep2 = FALSE;
-                        pDevice->bwextstep3 = FALSE;
-		   pDevice->bWPASuppWextEnabled = FALSE;
-                   pDevice->fWPA_Authened = FALSE;
+		      pDevice->bwextstep0 = false;
+                        pDevice->bwextstep1 = false;
+                        pDevice->bwextstep2 = false;
+                        pDevice->bwextstep3 = false;
+		   pDevice->bWPASuppWextEnabled = false;
+                   pDevice->fWPA_Authened = false;
 
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Send Disassociation Packet..\n");
                 // reason = 8 : disassoc because sta has left
@@ -507,15 +507,15 @@ void vRunCommand(struct vnt_private *pDevice)
 				     pMgmt->abyCurrBSSID,
 				     (8),
 				     &Status);
-                pDevice->bLinkPass = FALSE;
+                pDevice->bLinkPass = false;
                 ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
                 // unlock command busy
                 pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
                 pItemSSID->len = 0;
                 memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
                 pMgmt->eCurrState = WMAC_STATE_IDLE;
-                pMgmt->sNodeDBTable[0].bActive = FALSE;
-//                pDevice->bBeaconBufReady = FALSE;
+                pMgmt->sNodeDBTable[0].bActive = false;
+//                pDevice->bBeaconBufReady = false;
             }
             netif_stop_queue(pDevice->dev);
             if (pDevice->bNeedRadioOFF == TRUE)
@@ -560,7 +560,7 @@ void vRunCommand(struct vnt_private *pDevice)
                     }
                 }
                 netif_stop_queue(pDevice->dev);
-                pDevice->bLinkPass = FALSE;
+                pDevice->bLinkPass = false;
                 ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
             }
             // set initial state
@@ -706,14 +706,14 @@ void vRunCommand(struct vnt_private *pDevice)
                     netif_wake_queue(pDevice->dev);
                 }
 
-		 if(pDevice->IsTxDataTrigger != FALSE)   {    //TxDataTimer is not triggered at the first time
+		 if(pDevice->IsTxDataTrigger != false)   {    //TxDataTimer is not triggered at the first time
                      // printk("Re-initial TxDataTimer****\n");
 		    del_timer(&pDevice->sTimerTxData);
                       init_timer(&pDevice->sTimerTxData);
 			pDevice->sTimerTxData.data = (unsigned long) pDevice;
                       pDevice->sTimerTxData.function = (TimerFunction)BSSvSecondTxData;
                       pDevice->sTimerTxData.expires = RUN_AT(10*HZ);      //10s callback
-                      pDevice->fTxDataInSleep = FALSE;
+                      pDevice->fTxDataInSleep = false;
                       pDevice->nTxDataTimeCout = 0;
 		 }
 		 else {
@@ -745,7 +745,7 @@ void vRunCommand(struct vnt_private *pDevice)
                 del_timer(&pMgmt->sTimerSecondCallback);
                 pMgmt->eCurrState = WMAC_STATE_IDLE;
                 pMgmt->eCurrMode = WMAC_MODE_STANDBY;
-                pDevice->bLinkPass = FALSE;
+                pDevice->bLinkPass = false;
                 ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
                 if (pDevice->bEnableHostWEP == TRUE)
                     BSSvClearNodeDBTable(pDevice, 1);
@@ -753,7 +753,7 @@ void vRunCommand(struct vnt_private *pDevice)
                     BSSvClearNodeDBTable(pDevice, 0);
                 pDevice->uAssocCount = 0;
                 pMgmt->eCurrState = WMAC_STATE_IDLE;
-                pDevice->bFixRate = FALSE;
+                pDevice->bFixRate = false;
 
 		vMgrCreateOwnIBSS((void *) pDevice, &Status);
 		if (Status != CMD_STATUS_SUCCESS) {
@@ -781,7 +781,7 @@ void vRunCommand(struct vnt_private *pDevice)
                 while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[0].sTxPSQueue)) != NULL) {
                     if (skb_queue_empty(&pMgmt->sNodeDBTable[0].sTxPSQueue)) {
                         pMgmt->abyPSTxMap[0] &= ~byMask[0];
-                        pDevice->bMoreData = FALSE;
+                        pDevice->bMoreData = false;
                     }
                     else {
                         pDevice->bMoreData = TRUE;
@@ -806,7 +806,7 @@ void vRunCommand(struct vnt_private *pDevice)
                             // clear tx map
                             pMgmt->abyPSTxMap[pMgmt->sNodeDBTable[ii].wAID >> 3] &=
                                     ~byMask[pMgmt->sNodeDBTable[ii].wAID & 7];
-                            pDevice->bMoreData = FALSE;
+                            pDevice->bMoreData = false;
                         }
                         else {
                             pDevice->bMoreData = TRUE;
@@ -828,7 +828,7 @@ void vRunCommand(struct vnt_private *pDevice)
                                     ~byMask[pMgmt->sNodeDBTable[ii].wAID & 7];
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Index=%d PS queue clear \n", ii);
                     }
-                    pMgmt->sNodeDBTable[ii].bRxPSPoll = FALSE;
+                    pMgmt->sNodeDBTable[ii].bRxPSPoll = false;
                 }
             }
 
@@ -866,13 +866,13 @@ void vRunCommand(struct vnt_private *pDevice)
 	       pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
                 pDevice->uCmdDequeueIdx = 0;
                 pDevice->uCmdEnqueueIdx = 0;
-                //0415pDevice->bCmdRunning = FALSE;
+                //0415pDevice->bCmdRunning = false;
                 pDevice->bCmdClear = TRUE;
-                pDevice->bStopTx0Pkt = FALSE;
+                pDevice->bStopTx0Pkt = false;
                 pDevice->bStopDataPkt = TRUE;
 
                 pDevice->byKeyIndex = 0;
-                pDevice->bTransmitKey = FALSE;
+                pDevice->bTransmitKey = false;
 	    spin_unlock_irq(&pDevice->lock);
 	    KeyvInitTable(pDevice,&pDevice->sKey);
 	    spin_lock_irq(&pDevice->lock);
@@ -886,10 +886,10 @@ void vRunCommand(struct vnt_private *pDevice)
 				     pMgmt->abyCurrBSSID,
 				     (8),
 				     &Status);
-                       pDevice->bLinkPass = FALSE;
+                       pDevice->bLinkPass = false;
                 // unlock command busy
                         pMgmt->eCurrState = WMAC_STATE_IDLE;
-                        pMgmt->sNodeDBTable[0].bActive = FALSE;
+                        pMgmt->sNodeDBTable[0].bActive = false;
                     // if(pDevice->bWPASuppWextEnabled == TRUE)
                         {
                   	union iwreq_data  wrqu;
@@ -899,11 +899,11 @@ void vRunCommand(struct vnt_private *pDevice)
                   	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
                        }
 	  	}
-	               pDevice->bwextstep0 = FALSE;
-                        pDevice->bwextstep1 = FALSE;
-                        pDevice->bwextstep2 = FALSE;
-                        pDevice->bwextstep3 = FALSE;
-		      pDevice->bWPASuppWextEnabled = FALSE;
+	               pDevice->bwextstep0 = false;
+                        pDevice->bwextstep1 = false;
+                        pDevice->bwextstep2 = false;
+                        pDevice->bwextstep3 = false;
+		      pDevice->bWPASuppWextEnabled = false;
 	                  //clear current SSID
                   pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
                   pItemSSID->len = 0;
@@ -920,7 +920,7 @@ void vRunCommand(struct vnt_private *pDevice)
 	    pDevice->bHWRadioOff = TRUE;
         } else {
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_ON........................\n");
-            pDevice->bHWRadioOff = FALSE;
+            pDevice->bHWRadioOff = false;
                 CARDbRadioPowerOn(pDevice);
             MACvRegBitsOff(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);
             ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_ON);
@@ -937,7 +937,7 @@ void vRunCommand(struct vnt_private *pDevice)
             pDevice->byBBVGACurrent = pDevice->byBBVGANew;
             BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change sensitivity pDevice->byBBVGACurrent = %x\n", pDevice->byBBVGACurrent);
-            pDevice->bStopDataPkt = FALSE;
+            pDevice->bStopDataPkt = false;
             s_bCommandComplete(pDevice);
             break;
 
@@ -999,9 +999,9 @@ void vRunCommand(struct vnt_private *pDevice)
 
         case WLAN_CMD_11H_CHSW_START:
             CARDbSetMediaChannel(pDevice, pDevice->byNewChannel);
-            pDevice->bChannelSwitch = FALSE;
+            pDevice->bChannelSwitch = false;
             pMgmt->uCurrChannel = pDevice->byNewChannel;
-            pDevice->bStopDataPkt = FALSE;
+            pDevice->bStopDataPkt = false;
             s_bCommandComplete(pDevice);
             break;
 
@@ -1019,14 +1019,14 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
 {
 	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
 	PWLAN_IE_SSID pSSID;
-	int bRadioCmd = FALSE;
+	int bRadioCmd = false;
 	int bForceSCAN = TRUE;
 
 
     pDevice->eCommandState = WLAN_CMD_IDLE;
     if (pDevice->cbFreeCmdQueue == CMD_Q_SIZE) {
         //Command Queue Empty
-        pDevice->bCmdRunning = FALSE;
+        pDevice->bCmdRunning = false;
         return TRUE;
     }
     else {
@@ -1048,7 +1048,7 @@ static int s_bCommandComplete(struct vnt_private *pDevice)
                     memset(pMgmt->abyScanSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
                 }
 /*
-                if ((bForceSCAN == FALSE) && (pDevice->bLinkPass == TRUE)) {
+                if ((bForceSCAN == false) && (pDevice->bLinkPass == TRUE)) {
                     if ((pSSID->len == ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->len) &&
                         ( !memcmp(pSSID->abySSID, ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->abySSID, pSSID->len))) {
                         pDevice->eCommandState = WLAN_CMD_IDLE;
@@ -1124,7 +1124,7 @@ int bScheduleCommand(struct vnt_private *pDevice,
 {
 
     if (pDevice->cbFreeCmdQueue == 0) {
-        return (FALSE);
+        return (false);
     }
     pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].eCmd = eCommand;
     pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = TRUE;
@@ -1132,7 +1132,7 @@ int bScheduleCommand(struct vnt_private *pDevice,
     if (pbyItem0 != NULL) {
         switch (eCommand) {
             case WLAN_CMD_BSSID_SCAN:
-                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = FALSE;
+                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = false;
                 memcpy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
                          pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
                 break;
@@ -1163,7 +1163,7 @@ int bScheduleCommand(struct vnt_private *pDevice,
     ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdEnqueueIdx, CMD_Q_SIZE);
     pDevice->cbFreeCmdQueue--;
 
-    if (pDevice->bCmdRunning == FALSE) {
+    if (pDevice->bCmdRunning == false) {
         s_bCommandComplete(pDevice);
     }
     else {
@@ -1183,7 +1183,7 @@ int bScheduleCommand(struct vnt_private *pDevice,
  *  Out:
  *      none
  *
- * Return Value: TRUE if success; otherwise FALSE
+ * Return Value: TRUE if success; otherwise false
  *
  */
 static int s_bClearBSSID_SCAN(struct vnt_private *pDevice)
@@ -1219,8 +1219,8 @@ void vResetCommandTimer(struct vnt_private *pDevice)
 	pDevice->uCmdDequeueIdx = 0;
 	pDevice->uCmdEnqueueIdx = 0;
 	pDevice->eCommandState = WLAN_CMD_IDLE;
-	pDevice->bCmdRunning = FALSE;
-	pDevice->bCmdClear = FALSE;
+	pDevice->bCmdRunning = false;
+	pDevice->bCmdClear = false;
 }
 
 void BSSvSecondTxData(struct vnt_private *pDevice)
@@ -1245,7 +1245,7 @@ void BSSvSecondTxData(struct vnt_private *pDevice)
 		//   printk("mike:%s-->InSleep Tx Data Procedure\n",__FUNCTION__);
 		pDevice->fTxDataInSleep = TRUE;
 		PSbSendNullPacket(pDevice);      //send null packet
-		pDevice->fTxDataInSleep = FALSE;
+		pDevice->fTxDataInSleep = false;
 	}
 	spin_unlock_irq(&pDevice->lock);
 

commit 98583c095c8abc856ddcc87f341aa4bc0b44b038
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Dec 10 22:01:23 2012 +0000

    staging: vt6656: change baseband/mac/wcmd/wctl to new structures.
    
    This patch also cleans up function declarations, definitions and local variables
    were appropriate replacing types defined in "ttype.h" with linux/types.h.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 22f6b41cfd19..51f48c1244f6 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -68,33 +68,17 @@ static int          msglevel                =MSG_LEVEL_INFO;
 //static int          msglevel                =MSG_LEVEL_DEBUG;
 /*---------------------  Static Functions  --------------------------*/
 
-static
-void
-s_vProbeChannel(
-     PSDevice pDevice
-    );
+static void s_vProbeChannel(struct vnt_private *);
 
+static struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *,
+	struct vnt_manager *pMgmt, u8 *pScanBSSID, PWLAN_IE_SSID pSSID,
+	PWLAN_IE_SUPP_RATES pCurrRates, PWLAN_IE_SUPP_RATES pCurrExtSuppRates);
 
-static
-PSTxMgmtPacket
-s_MgrMakeProbeRequest(
-     PSDevice pDevice,
-     PSMgmtObject pMgmt,
-     PBYTE pScanBSSID,
-     PWLAN_IE_SSID pSSID,
-     PWLAN_IE_SUPP_RATES pCurrRates,
-     PWLAN_IE_SUPP_RATES pCurrExtSuppRates
-    );
 
+static int s_bCommandComplete(struct vnt_private *);
 
-static
-BOOL
-s_bCommandComplete (
-    PSDevice pDevice
-    );
 
-
-static BOOL s_bClearBSSID_SCAN(void *hDeviceContext);
+static int s_bClearBSSID_SCAN(struct vnt_private *);
 
 /*---------------------  Export Variables  --------------------------*/
 
@@ -114,13 +98,10 @@ static BOOL s_bClearBSSID_SCAN(void *hDeviceContext);
  *
  */
 
-static
-void
-vAdHocBeaconStop(PSDevice  pDevice)
+static void vAdHocBeaconStop(struct vnt_private *pDevice)
 {
-
-    PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
-    BOOL            bStop;
+	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
+	int bStop;
 
     /*
      * temporarily stop Beacon packet for AdHoc Server
@@ -171,11 +152,9 @@ vAdHocBeaconStop(PSDevice  pDevice)
  * Return Value: none
  *
  */
-static
-void
-vAdHocBeaconRestart(PSDevice pDevice)
+static void vAdHocBeaconRestart(struct vnt_private *pDevice)
 {
-    PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
+	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
 
     /*
      * Restart Beacon packet for AdHoc Server
@@ -204,22 +183,22 @@ vAdHocBeaconRestart(PSDevice pDevice)
  *
 -*/
 
-static
-void
-s_vProbeChannel(
-     PSDevice pDevice
-    )
+static void s_vProbeChannel(struct vnt_private *pDevice)
 {
-                                                     //1M,   2M,   5M,   11M,  18M,  24M,  36M,  54M
-    BYTE abyCurrSuppRatesG[] = {WLAN_EID_SUPP_RATES, 8, 0x02, 0x04, 0x0B, 0x16, 0x24, 0x30, 0x48, 0x6C};
-    BYTE abyCurrExtSuppRatesG[] = {WLAN_EID_EXTSUPP_RATES, 4, 0x0C, 0x12, 0x18, 0x60};
-                                                           //6M,   9M,   12M,  48M
-    BYTE abyCurrSuppRatesA[] = {WLAN_EID_SUPP_RATES, 8, 0x0C, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6C};
-    BYTE abyCurrSuppRatesB[] = {WLAN_EID_SUPP_RATES, 4, 0x02, 0x04, 0x0B, 0x16};
-    PBYTE           pbyRate;
-    PSTxMgmtPacket  pTxPacket;
-    PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
-    unsigned int            ii;
+	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
+	struct vnt_tx_mgmt *pTxPacket;
+	u8 abyCurrSuppRatesG[] = {WLAN_EID_SUPP_RATES,
+			8, 0x02, 0x04, 0x0B, 0x16, 0x24, 0x30, 0x48, 0x6C};
+			/* 1M,   2M,   5M,   11M,  18M,  24M,  36M,  54M*/
+	u8 abyCurrExtSuppRatesG[] = {WLAN_EID_EXTSUPP_RATES,
+			4, 0x0C, 0x12, 0x18, 0x60};
+			/* 6M,   9M,   12M,  48M*/
+	u8 abyCurrSuppRatesA[] = {WLAN_EID_SUPP_RATES,
+			8, 0x0C, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6C};
+	u8 abyCurrSuppRatesB[] = {WLAN_EID_SUPP_RATES,
+			4, 0x02, 0x04, 0x0B, 0x16};
+	u8 *pbyRate;
+	int ii;
 
 
     if (pDevice->byBBType == BB_TYPE_11A) {
@@ -268,24 +247,19 @@ s_vProbeChannel(
 -*/
 
 
-PSTxMgmtPacket
-s_MgrMakeProbeRequest(
-     PSDevice pDevice,
-     PSMgmtObject pMgmt,
-     PBYTE pScanBSSID,
-     PWLAN_IE_SSID pSSID,
-     PWLAN_IE_SUPP_RATES pCurrRates,
-     PWLAN_IE_SUPP_RATES pCurrExtSuppRates
-
-    )
+struct vnt_tx_mgmt *s_MgrMakeProbeRequest(struct vnt_private *pDevice,
+	struct vnt_manager *pMgmt, u8 *pScanBSSID, PWLAN_IE_SSID pSSID,
+	PWLAN_IE_SUPP_RATES pCurrRates, PWLAN_IE_SUPP_RATES pCurrExtSuppRates)
 {
-    PSTxMgmtPacket      pTxPacket = NULL;
-    WLAN_FR_PROBEREQ    sFrame;
+	struct vnt_tx_mgmt *pTxPacket = NULL;
+	WLAN_FR_PROBEREQ sFrame;
 
 
-    pTxPacket = (PSTxMgmtPacket)pMgmt->pbyMgmtPacketPool;
-    memset(pTxPacket, 0, sizeof(STxMgmtPacket) + WLAN_PROBEREQ_FR_MAXLEN);
-    pTxPacket->p80211Header = (PUWLAN_80211HDR)((PBYTE)pTxPacket + sizeof(STxMgmtPacket));
+	pTxPacket = (struct vnt_tx_mgmt *)pMgmt->pbyMgmtPacketPool;
+	memset(pTxPacket, 0, sizeof(struct vnt_tx_mgmt)
+		+ WLAN_PROBEREQ_FR_MAXLEN);
+	pTxPacket->p80211Header = (PUWLAN_80211HDR)((u8 *)pTxPacket
+		+ sizeof(struct vnt_tx_mgmt));
     sFrame.pBuf = (PBYTE)pTxPacket->p80211Header;
     sFrame.len = WLAN_PROBEREQ_FR_MAXLEN;
     vMgrEncodeProbeRequest(&sFrame);
@@ -316,9 +290,8 @@ s_MgrMakeProbeRequest(
     return pTxPacket;
 }
 
-void vCommandTimerWait(void *hDeviceContext, unsigned long MSecond)
+void vCommandTimerWait(struct vnt_private *pDevice, unsigned long MSecond)
 {
-	PSDevice pDevice = (PSDevice)hDeviceContext;
 
 	init_timer(&pDevice->sTimerCommand);
 
@@ -331,18 +304,17 @@ void vCommandTimerWait(void *hDeviceContext, unsigned long MSecond)
 	return;
 }
 
-void vRunCommand(void *hDeviceContext)
+void vRunCommand(struct vnt_private *pDevice)
 {
-    PSDevice        pDevice = (PSDevice)hDeviceContext;
-    PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
-    PWLAN_IE_SSID   pItemSSID;
-    PWLAN_IE_SSID   pItemSSIDCurr;
-    CMD_STATUS      Status;
-    unsigned int            ii;
-    BYTE            byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
-    struct sk_buff  *skb;
-    BYTE            byData;
+	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
+	PWLAN_IE_SSID pItemSSID;
+	PWLAN_IE_SSID pItemSSIDCurr;
+	CMD_STATUS Status;
+	struct sk_buff  *skb;
 	union iwreq_data wrqu;
+	int ii;
+	u8 byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
+	u8 byData;
 
 
     if (pDevice->dwDiagRefCount != 0)
@@ -1043,17 +1015,12 @@ void vRunCommand(void *hDeviceContext)
 }
 
 
-static
-BOOL
-s_bCommandComplete (
-    PSDevice pDevice
-    )
+static int s_bCommandComplete(struct vnt_private *pDevice)
 {
-    PWLAN_IE_SSID pSSID;
-    BOOL          bRadioCmd = FALSE;
-    //WORD          wDeAuthenReason = 0;
-    BOOL          bForceSCAN = TRUE;
-    PSMgmtObject  pMgmt = &(pDevice->sMgmtObj);
+	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
+	PWLAN_IE_SSID pSSID;
+	int bRadioCmd = FALSE;
+	int bForceSCAN = TRUE;
 
 
     pDevice->eCommandState = WLAN_CMD_IDLE;
@@ -1146,18 +1113,15 @@ s_bCommandComplete (
                 break;
 
         }
-	vCommandTimerWait((void *) pDevice, 0);
+	vCommandTimerWait(pDevice, 0);
     }
 
     return TRUE;
 }
 
-BOOL bScheduleCommand(void *hDeviceContext,
-		      CMD_CODE eCommand,
-		      PBYTE pbyItem0)
+int bScheduleCommand(struct vnt_private *pDevice,
+		CMD_CODE eCommand, u8 *pbyItem0)
 {
-    PSDevice        pDevice = (PSDevice)hDeviceContext;
-
 
     if (pDevice->cbFreeCmdQueue == 0) {
         return (FALSE);
@@ -1222,11 +1186,10 @@ BOOL bScheduleCommand(void *hDeviceContext,
  * Return Value: TRUE if success; otherwise FALSE
  *
  */
-static BOOL s_bClearBSSID_SCAN(void *hDeviceContext)
+static int s_bClearBSSID_SCAN(struct vnt_private *pDevice)
 {
-    PSDevice        pDevice = (PSDevice)hDeviceContext;
-    unsigned int            uCmdDequeueIdx = pDevice->uCmdDequeueIdx;
-    unsigned int            ii;
+	unsigned int uCmdDequeueIdx = pDevice->uCmdDequeueIdx;
+	unsigned int ii;
 
     if ((pDevice->cbFreeCmdQueue < CMD_Q_SIZE) && (uCmdDequeueIdx != pDevice->uCmdEnqueueIdx)) {
         for (ii = 0; ii < (CMD_Q_SIZE - pDevice->cbFreeCmdQueue); ii ++) {
@@ -1242,9 +1205,8 @@ static BOOL s_bClearBSSID_SCAN(void *hDeviceContext)
 
 
 //mike add:reset command timer
-void vResetCommandTimer(void *hDeviceContext)
+void vResetCommandTimer(struct vnt_private *pDevice)
 {
-	PSDevice pDevice = (PSDevice)hDeviceContext;
 
 	//delete timer
 	del_timer(&pDevice->sTimerCommand);
@@ -1261,10 +1223,9 @@ void vResetCommandTimer(void *hDeviceContext)
 	pDevice->bCmdClear = FALSE;
 }
 
-void BSSvSecondTxData(void *hDeviceContext)
+void BSSvSecondTxData(struct vnt_private *pDevice)
 {
-	PSDevice pDevice = (PSDevice)hDeviceContext;
-	PSMgmtObject pMgmt = &(pDevice->sMgmtObj);
+	struct vnt_manager *pMgmt = &pDevice->vnt_mgmt;
 
 	pDevice->nTxDataTimeCout++;
 

commit 0fdb56dabddd3706ab343aa1278019bd5c8aef21
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat Nov 24 14:53:07 2012 +0000

    staging: vt6656: send SIOCGIWSCAN at end of all scanning events.
    
    wpa supplicant can become confused if the scanning has ended on
    active scanning.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 99bced793767..22f6b41cfd19 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -342,6 +342,7 @@ void vRunCommand(void *hDeviceContext)
     BYTE            byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
     struct sk_buff  *skb;
     BYTE            byData;
+	union iwreq_data wrqu;
 
 
     if (pDevice->dwDiagRefCount != 0)
@@ -503,14 +504,11 @@ void vRunCommand(void *hDeviceContext)
             pMgmt->eScanState = WMAC_NO_SCANNING;
             pDevice->bStopDataPkt = FALSE;
 
-	if(pMgmt->eScanType == WMAC_SCAN_PASSIVE)
-		{
-			//send scan event to wpa_Supplicant
-				union iwreq_data wrqu;
-				PRINT_K("wireless_send_event--->SIOCGIWSCAN(scan done)\n");
-				memset(&wrqu, 0, sizeof(wrqu));
-				wireless_send_event(pDevice->dev, SIOCGIWSCAN, &wrqu, NULL);
-			}
+		/*send scan event to wpa_Supplicant*/
+		PRINT_K("wireless_send_event--->SIOCGIWSCAN(scan done)\n");
+		memset(&wrqu, 0, sizeof(wrqu));
+		wireless_send_event(pDevice->dev, SIOCGIWSCAN, &wrqu, NULL);
+
             s_bCommandComplete(pDevice);
             break;
 

commit f1426fd7ccff8f0a2c7cb7a5127baa73b7207db9
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Mon Nov 12 20:43:34 2012 +0000

    staging: vt6656: Remove WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT macro
    
    Already removed in parts of driver.
    
    Removed in remainder.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index b854d7ef97d7..99bced793767 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -503,7 +503,6 @@ void vRunCommand(void *hDeviceContext)
             pMgmt->eScanState = WMAC_NO_SCANNING;
             pDevice->bStopDataPkt = FALSE;
 
-#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 	if(pMgmt->eScanType == WMAC_SCAN_PASSIVE)
 		{
 			//send scan event to wpa_Supplicant
@@ -512,7 +511,6 @@ void vRunCommand(void *hDeviceContext)
 				memset(&wrqu, 0, sizeof(wrqu));
 				wireless_send_event(pDevice->dev, SIOCGIWSCAN, &wrqu, NULL);
 			}
-#endif
             s_bCommandComplete(pDevice);
             break;
 
@@ -525,13 +523,11 @@ void vRunCommand(void *hDeviceContext)
                 return;
             } else {
 
-          #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 		      pDevice->bwextstep0 = FALSE;
                         pDevice->bwextstep1 = FALSE;
                         pDevice->bwextstep2 = FALSE;
                         pDevice->bwextstep3 = FALSE;
 		   pDevice->bWPASuppWextEnabled = FALSE;
-	 #endif
                    pDevice->fWPA_Authened = FALSE;
 
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Send Disassociation Packet..\n");
@@ -674,7 +670,6 @@ void vRunCommand(void *hDeviceContext)
                 }
                 else {
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Disconnect SSID none\n");
-                     #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
                     // if(pDevice->bWPASuppWextEnabled == TRUE)
                         {
                   	union iwreq_data  wrqu;
@@ -683,7 +678,6 @@ void vRunCommand(void *hDeviceContext)
                   	PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated:vMgrJoinBSSBegin Fail !!)\n");
                   	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
                        }
-                    #endif
                 }
             }
             s_bCommandComplete(pDevice);
@@ -926,7 +920,6 @@ void vRunCommand(void *hDeviceContext)
                 // unlock command busy
                         pMgmt->eCurrState = WMAC_STATE_IDLE;
                         pMgmt->sNodeDBTable[0].bActive = FALSE;
-                     #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
                     // if(pDevice->bWPASuppWextEnabled == TRUE)
                         {
                   	union iwreq_data  wrqu;
@@ -935,15 +928,12 @@ void vRunCommand(void *hDeviceContext)
                   	PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated)\n");
                   	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
                        }
-                    #endif
 	  	}
-	       #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 	               pDevice->bwextstep0 = FALSE;
                         pDevice->bwextstep1 = FALSE;
                         pDevice->bwextstep2 = FALSE;
                         pDevice->bwextstep3 = FALSE;
 		      pDevice->bWPASuppWextEnabled = FALSE;
-		#endif
 	                  //clear current SSID
                   pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
                   pItemSSID->len = 0;

commit 70e227790d4ee4590023d8041a3485f8053593fc
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Nov 11 16:07:57 2012 +0000

    staging: vt6656: 64bit fixes: vCommandTimerWait change calculation of timer.
    
    The timer appears to run too fast/race on 64 bit systems.
    
    Using msecs_to_jiffies seems to cause a deadlock on 64 bit.
    
    A calculation of (MSecond * HZ) / 1000 appears to run satisfactory.
    
    Change BSSIDInfoCount to u32.
    
    After this patch the driver can be successfully connect on little endian 64/32 bit systems.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 586fbe1627f7..b854d7ef97d7 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -316,17 +316,19 @@ s_MgrMakeProbeRequest(
     return pTxPacket;
 }
 
-void vCommandTimerWait(void *hDeviceContext, unsigned int MSecond)
+void vCommandTimerWait(void *hDeviceContext, unsigned long MSecond)
 {
-    PSDevice        pDevice = (PSDevice)hDeviceContext;
+	PSDevice pDevice = (PSDevice)hDeviceContext;
 
-    init_timer(&pDevice->sTimerCommand);
-    pDevice->sTimerCommand.data = (unsigned long)pDevice;
-    pDevice->sTimerCommand.function = (TimerFunction)vRunCommand;
-    // RUN_AT :1 msec ~= (HZ/1024)
-    pDevice->sTimerCommand.expires = (unsigned int)RUN_AT((MSecond * HZ) >> 10);
-    add_timer(&pDevice->sTimerCommand);
-    return;
+	init_timer(&pDevice->sTimerCommand);
+
+	pDevice->sTimerCommand.data = (unsigned long)pDevice;
+	pDevice->sTimerCommand.function = (TimerFunction)vRunCommand;
+	pDevice->sTimerCommand.expires = RUN_AT((MSecond * HZ) / 1000);
+
+	add_timer(&pDevice->sTimerCommand);
+
+	return;
 }
 
 void vRunCommand(void *hDeviceContext)

commit a0a1f61afa1ff8edda4ad69f37fdd69fdb7d0453
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Sun Aug 26 08:16:43 2012 -0700

    staging "vt6656" Fix typos in comments, and in a printk message.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 23ed03c60287..586fbe1627f7 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -263,7 +263,7 @@ s_vProbeChannel(
  *
  *
  * Return Value:
- *    A ptr to Tx frame or NULL on allocation failue
+ *    A ptr to Tx frame or NULL on allocation failure
  *
 -*/
 
@@ -794,7 +794,7 @@ void vRunCommand(void *hDeviceContext)
 			DBG_PRT(MSG_LEVEL_DEBUG,
 				KERN_INFO "vMgrCreateOwnIBSS fail!\n");
                 }
-                // alway turn off unicast bit
+                // always turn off unicast bit
                 MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_UNICAST);
                 pDevice->byRxMode &= ~RCR_UNICAST;
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wcmd: rx_mode = %x\n", pDevice->byRxMode );
@@ -946,7 +946,7 @@ void vRunCommand(void *hDeviceContext)
                   pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
                   pItemSSID->len = 0;
                   memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
-                //clear dessire SSID
+                //clear desired SSID
                 pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
                 pItemSSID->len = 0;
                 memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);

commit 931846901c08a53b43590dd99bbf53026c4f0890
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Mon Aug 13 21:21:50 2012 +0900

    staging: vt6656: Fix typo in vt6656
    
    Correct spelling typo in staging/vt6656
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 9d2caa819f47..23ed03c60287 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -751,7 +751,7 @@ void vRunCommand(void *hDeviceContext)
                       pDevice->nTxDataTimeCout = 0;
 		 }
 		 else {
-		   // printk("mike:-->First time triger TimerTxData InSleep\n");
+		   // printk("mike:-->First time trigger TimerTxData InSleep\n");
 		 }
 		pDevice->IsTxDataTrigger = TRUE;
                 add_timer(&pDevice->sTimerTxData);

commit 3afe5f6ca150f1a402543b32f8fe66f759c7d8ed
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Sat Jul 14 02:07:18 2012 +0545

    staging/vt6656: cleanup coding style in vResetCommandTimer
    
    the following fixes...
    
    removed spaces at start of a line and used tabs
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index c9de9373b785..9d2caa819f47 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -1254,21 +1254,21 @@ static BOOL s_bClearBSSID_SCAN(void *hDeviceContext)
 //mike add:reset command timer
 void vResetCommandTimer(void *hDeviceContext)
 {
-  PSDevice        pDevice = (PSDevice)hDeviceContext;
+	PSDevice pDevice = (PSDevice)hDeviceContext;
 
-  //delete timer
-      del_timer(&pDevice->sTimerCommand);
-  //init timer
-      init_timer(&pDevice->sTimerCommand);
-    pDevice->sTimerCommand.data = (unsigned long)pDevice;
-    pDevice->sTimerCommand.function = (TimerFunction)vRunCommand;
-    pDevice->sTimerCommand.expires = RUN_AT(HZ);
-    pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
-    pDevice->uCmdDequeueIdx = 0;
-    pDevice->uCmdEnqueueIdx = 0;
-    pDevice->eCommandState = WLAN_CMD_IDLE;
-    pDevice->bCmdRunning = FALSE;
-    pDevice->bCmdClear = FALSE;
+	//delete timer
+	del_timer(&pDevice->sTimerCommand);
+	//init timer
+	init_timer(&pDevice->sTimerCommand);
+	pDevice->sTimerCommand.data = (unsigned long)pDevice;
+	pDevice->sTimerCommand.function = (TimerFunction)vRunCommand;
+	pDevice->sTimerCommand.expires = RUN_AT(HZ);
+	pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
+	pDevice->uCmdDequeueIdx = 0;
+	pDevice->uCmdEnqueueIdx = 0;
+	pDevice->eCommandState = WLAN_CMD_IDLE;
+	pDevice->bCmdRunning = FALSE;
+	pDevice->bCmdClear = FALSE;
 }
 
 void BSSvSecondTxData(void *hDeviceContext)

commit eab6e193076c8469971c57488d301b16014adf91
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Sat Jul 14 02:06:52 2012 +0545

    staging/vt6656: remove unnecessary return in BSSvSecondTxData
    
    this return is at the function end, and function is returning nothing..
    i.e a void.
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index cecfdb6fef5c..c9de9373b785 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -1300,5 +1300,4 @@ void BSSvSecondTxData(void *hDeviceContext)
 
 	pDevice->sTimerTxData.expires = RUN_AT(10 * HZ);      //10s callback
 	add_timer(&pDevice->sTimerTxData);
-	return;
 }

commit a984fa55400b647f88bb3ee64d0cf932f7b510cd
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Sat Jul 14 02:06:07 2012 +0545

    staging/vt6656: coding style fix in BSSvSecondTxData
    
    this function seemed bit more coding style fix...
    
    The following fixes:
    
    remove spaces at start of line and use tabs
    use space between if and (
    give a space in a multiplication operation
    use space after = and another variable/constant
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 78ea121b7e2e..cecfdb6fef5c 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -1273,32 +1273,32 @@ void vResetCommandTimer(void *hDeviceContext)
 
 void BSSvSecondTxData(void *hDeviceContext)
 {
-  PSDevice        pDevice = (PSDevice)hDeviceContext;
-  PSMgmtObject  pMgmt = &(pDevice->sMgmtObj);
-
-  pDevice->nTxDataTimeCout++;
-
-  if(pDevice->nTxDataTimeCout<4)     //don't tx data if timer less than 40s
-    {
-     // printk("mike:%s-->no data Tx not exceed the desired Time as %d\n",__FUNCTION__,
-	//  	(int)pDevice->nTxDataTimeCout);
-     pDevice->sTimerTxData.expires = RUN_AT(10*HZ);      //10s callback
-     add_timer(&pDevice->sTimerTxData);
-      return;
-    }
-
-  spin_lock_irq(&pDevice->lock);
-  //is wap_supplicant running successful OR only open && sharekey mode!
-  if(((pDevice->bLinkPass ==TRUE)&&(pMgmt->eAuthenMode < WMAC_AUTH_WPA)) ||  //open && sharekey linking
-      (pDevice->fWPA_Authened == TRUE)) {   //wpa linking
-        //   printk("mike:%s-->InSleep Tx Data Procedure\n",__FUNCTION__);
-	  pDevice->fTxDataInSleep = TRUE;
-	  PSbSendNullPacket(pDevice);      //send null packet
-	  pDevice->fTxDataInSleep = FALSE;
-  	}
-  spin_unlock_irq(&pDevice->lock);
-
-  pDevice->sTimerTxData.expires = RUN_AT(10*HZ);      //10s callback
-  add_timer(&pDevice->sTimerTxData);
-  return;
+	PSDevice pDevice = (PSDevice)hDeviceContext;
+	PSMgmtObject pMgmt = &(pDevice->sMgmtObj);
+
+	pDevice->nTxDataTimeCout++;
+
+	if (pDevice->nTxDataTimeCout < 4) {   //don't tx data if timer less than 40s
+		// printk("mike:%s-->no data Tx not exceed the desired Time as %d\n",__FUNCTION__,
+		//  	(int)pDevice->nTxDataTimeCout);
+		pDevice->sTimerTxData.expires = RUN_AT(10 * HZ);      //10s callback
+		add_timer(&pDevice->sTimerTxData);
+		return;
+	}
+
+	spin_lock_irq(&pDevice->lock);
+	//is wap_supplicant running successful OR only open && sharekey mode!
+	if (((pDevice->bLinkPass == TRUE) &&
+		(pMgmt->eAuthenMode < WMAC_AUTH_WPA)) ||  //open && sharekey linking
+		(pDevice->fWPA_Authened == TRUE)) {   //wpa linking
+		//   printk("mike:%s-->InSleep Tx Data Procedure\n",__FUNCTION__);
+		pDevice->fTxDataInSleep = TRUE;
+		PSbSendNullPacket(pDevice);      //send null packet
+		pDevice->fTxDataInSleep = FALSE;
+	}
+	spin_unlock_irq(&pDevice->lock);
+
+	pDevice->sTimerTxData.expires = RUN_AT(10 * HZ);      //10s callback
+	add_timer(&pDevice->sTimerTxData);
+	return;
 }

commit 9fc86028fa21f8831c0fdc701732cf491da1202c
Author: Joe Perches <joe@perches.com>
Date:   Sun Apr 10 14:31:32 2011 -0700

    staging: Remove unnecessary semicolons when if (foo) {...};
    
    Done via perl script:
    
    $ cat remove_semi_if.pl
    my $match_balanced_parentheses = qr/(\((?:[^\(\)]++|(?-1))*\))/;
    my $match_balanced_braces      = qr/(\{(?:[^\{\}]++|(?-1))*\})/;
    
    foreach my $file (@ARGV) {
        my $f;
        my $text;
        my $oldtext;
    
        next if ((-d $file));
    
        open($f, '<', $file)
            or die "$P: Can't open $file for read\n";
        $oldtext = do { local($/) ; <$f> };
        close($f);
    
        next if ($oldtext eq "");
    
        $text = $oldtext;
    
        my $count = 0;
        do {
            $count = 0;
            $count += $text =~ s@\b(if\s*${match_balanced_parentheses}\s*)${match_balanced_braces}\s*;@"$1$3"@egx;
        } while ($count > 0);
    
        if ($text ne $oldtext) {
            my $newfile = $file;
    
            open($f, '>', $newfile)
                or die "$P: Can't open $newfile for write\n";
            print $f $text;
            close($f);
        }
    }
    
    $
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 019fb52de366..78ea121b7e2e 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -642,7 +642,7 @@ void vRunCommand(void *hDeviceContext)
                     if (Status != CMD_STATUS_SUCCESS){
 			DBG_PRT(MSG_LEVEL_DEBUG,
 				KERN_INFO "WLAN_CMD_IBSS_CREATE fail!\n");
-                    };
+                    }
                     BSSvAddMulticastNode(pDevice);
                 }
                 s_bClearBSSID_SCAN(pDevice);
@@ -658,7 +658,7 @@ void vRunCommand(void *hDeviceContext)
                     if (Status != CMD_STATUS_SUCCESS){
 			DBG_PRT(MSG_LEVEL_DEBUG,
 				KERN_INFO "WLAN_CMD_IBSS_CREATE fail!\n");
-                    };
+                    }
                     BSSvAddMulticastNode(pDevice);
                     s_bClearBSSID_SCAN(pDevice);
 /*
@@ -793,7 +793,7 @@ void vRunCommand(void *hDeviceContext)
 		if (Status != CMD_STATUS_SUCCESS) {
 			DBG_PRT(MSG_LEVEL_DEBUG,
 				KERN_INFO "vMgrCreateOwnIBSS fail!\n");
-                };
+                }
                 // alway turn off unicast bit
                 MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_UNICAST);
                 pDevice->byRxMode &= ~RCR_UNICAST;
@@ -827,7 +827,7 @@ void vRunCommand(void *hDeviceContext)
 
                     pMgmt->sNodeDBTable[0].wEnQueueCnt--;
                 }
-            };
+            }
 
             // PS nodes tx
             for (ii = 1; ii < (MAX_NODE_NUM + 1); ii++) {

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index b83b660b1f0f..019fb52de366 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -421,7 +421,7 @@ void vRunCommand(void *hDeviceContext)
                     pMgmt->eScanState = WMAC_IS_SCANNING;
                     pDevice->byScanBBType = pDevice->byBBType;  //lucas
                     pDevice->bStopDataPkt = TRUE;
-                    // Turn off RCR_BSSID filter everytime
+                    // Turn off RCR_BSSID filter every time
                     MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_BSSID);
                     pDevice->byRxMode &= ~RCR_BSSID;
 
@@ -604,7 +604,7 @@ void vRunCommand(void *hDeviceContext)
             // if Infra mode
             if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED)) {
                 // Call mgr to begin the deauthentication
-                // reason = (3) beacuse sta has left ESS
+                // reason = (3) because sta has left ESS
 	      if (pMgmt->eCurrState >= WMAC_STATE_AUTH) {
 		vMgrDeAuthenBeginSta((void *)pDevice,
 				     pMgmt,

commit 465711b39d2fb326c5be27a4f69f70b2a41612cf
Author: Andres More <more.andres@gmail.com>
Date:   Tue Aug 3 20:25:50 2010 -0300

    staging: vt6656: removed not useful comments
    
    Removed comments about who changed/added lines, they do not seem useful.
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 686747a09294..b83b660b1f0f 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -500,7 +500,7 @@ void vRunCommand(void *hDeviceContext)
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning, set back to channel: [%d]\n", pMgmt->uCurrChannel);
             pMgmt->eScanState = WMAC_NO_SCANNING;
             pDevice->bStopDataPkt = FALSE;
-//2008-0409-07, <Add> by Einsn Liu
+
 #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 	if(pMgmt->eScanType == WMAC_SCAN_PASSIVE)
 		{
@@ -876,7 +876,7 @@ void vRunCommand(void *hDeviceContext)
        //         CARDbRadioPowerOn(pDevice);
        //     else
        //         CARDbRadioPowerOff(pDevice);
-       //2008-09-09<Add> BY Mike:Hot Key for Radio On/Off
+
        {
 	       int ntStatus = STATUS_SUCCESS;
         BYTE            byTmp;

commit 6487c49e8a739ae6020ccda9470f5837e792ab53
Author: Andres More <more.andres@gmail.com>
Date:   Mon Aug 2 20:51:57 2010 -0300

    staging: vt6656: removed NTSTATUS definition
    
    Replaced NTSTATUS with int, as defined in a couple of places.
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 6610721ed6cf..686747a09294 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -878,7 +878,7 @@ void vRunCommand(void *hDeviceContext)
        //         CARDbRadioPowerOff(pDevice);
        //2008-09-09<Add> BY Mike:Hot Key for Radio On/Off
        {
-        NTSTATUS        ntStatus = STATUS_SUCCESS;
+	       int ntStatus = STATUS_SUCCESS;
         BYTE            byTmp;
 
         ntStatus = CONTROLnsRequestIn(pDevice,

commit 5926b9ae320eadc22e33466b560f6ce1890f1780
Author: Andres More <more.andres@gmail.com>
Date:   Mon Jul 12 13:55:43 2010 -0300

    staging: vt6656: removed Adhoc_STA definition
    
    Removed an always defined macro, perhaps used to patch the driver
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 4f348801324c..6610721ed6cf 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -565,11 +565,9 @@ void vRunCommand(void *hDeviceContext)
                 return;
             }
 
-//20080131-03,<Add> by Mike Liu
-	#ifdef Adhoc_STA
             memcpy(pMgmt->abyAdHocSSID,pMgmt->abyDesireSSID,
                               ((PWLAN_IE_SSID)pMgmt->abyDesireSSID)->len + WLAN_IEHDR_LEN);
-	#endif
+
             pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
             pItemSSIDCurr = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" cmd: desire ssid = %s\n", pItemSSID->abySSID);

commit 89b28e5db83dc748f37fb7442cc880da49c348ce
Author: Andres More <more.andres@gmail.com>
Date:   Mon Jul 12 12:12:25 2010 -0300

    staging: vt6656: removed '#if 1'/'#if 0' definitions
    
    Removed code guarded by always false definitions.
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index ec1c05794d83..4f348801324c 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -1291,12 +1291,8 @@ void BSSvSecondTxData(void *hDeviceContext)
 
   spin_lock_irq(&pDevice->lock);
   //is wap_supplicant running successful OR only open && sharekey mode!
-  #if 1
   if(((pDevice->bLinkPass ==TRUE)&&(pMgmt->eAuthenMode < WMAC_AUTH_WPA)) ||  //open && sharekey linking
       (pDevice->fWPA_Authened == TRUE)) {   //wpa linking
- #else
-  if(pDevice->bLinkPass ==TRUE) {
- #endif
         //   printk("mike:%s-->InSleep Tx Data Procedure\n",__FUNCTION__);
 	  pDevice->fTxDataInSleep = TRUE;
 	  PSbSendNullPacket(pDevice);      //send null packet

commit feaf03d3b42290f4c275ebf11641759bf4e1c458
Author: Andres More <more.andres@gmail.com>
Date:   Fri Jun 25 20:20:58 2010 -0300

    staging: vt6656: removed TxInSleep definition
    
    Removed an always defined macro, perhaps used to patch the driver
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 7199f99a8b28..ec1c05794d83 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -742,8 +742,6 @@ void vRunCommand(void *hDeviceContext)
                     netif_wake_queue(pDevice->dev);
                 }
 
-	//2007-0115-07<Add>by MikeLiu
-	     #ifdef TxInSleep
 		 if(pDevice->IsTxDataTrigger != FALSE)   {    //TxDataTimer is not triggered at the first time
                      // printk("Re-initial TxDataTimer****\n");
 		    del_timer(&pDevice->sTimerTxData);
@@ -759,7 +757,6 @@ void vRunCommand(void *hDeviceContext)
 		 }
 		pDevice->IsTxDataTrigger = TRUE;
                 add_timer(&pDevice->sTimerTxData);
-             #endif
 
             }
 	   else if(pMgmt->eCurrState < WMAC_STATE_ASSOCPENDING) {
@@ -1276,8 +1273,6 @@ void vResetCommandTimer(void *hDeviceContext)
     pDevice->bCmdClear = FALSE;
 }
 
-//2007-0115-08<Add>by MikeLiu
-#ifdef TxInSleep
 void BSSvSecondTxData(void *hDeviceContext)
 {
   PSDevice        pDevice = (PSDevice)hDeviceContext;
@@ -1313,5 +1308,3 @@ void BSSvSecondTxData(void *hDeviceContext)
   add_timer(&pDevice->sTimerTxData);
   return;
 }
-#endif
-

commit 2a1a17498bcaea1580a4fa051286bc97d4c5e730
Author: Andres More <more.andres@gmail.com>
Date:   Mon Jun 21 11:27:24 2010 -0300

    Staging: vt6656: removed '#if 0' definitions
    
    Removed code in .c files that was being skipped by the preprocessor
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 72e21b6f0e88..7199f99a8b28 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -716,18 +716,6 @@ void vRunCommand(void *hDeviceContext)
 	       return;
 	   }
 	          pDevice->byLinkWaitCount = 0;
-		 #if 0
-                     #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-                    // if(pDevice->bWPASuppWextEnabled == TRUE)
-                        {
-                  	union iwreq_data  wrqu;
-                  	memset(&wrqu, 0, sizeof (wrqu));
-                          wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-                  	printk("wireless_send_event--->SIOCGIWAP(disassociated:AUTHENTICATE_WAIT_timeout)\n");
-                  	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
-                       }
-                    #endif
-	         #endif
 
             s_bCommandComplete(pDevice);
             break;
@@ -785,18 +773,6 @@ void vRunCommand(void *hDeviceContext)
 	       return;
 	   }
 	          pDevice->byLinkWaitCount = 0;
-		#if 0
-                     #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-                    // if(pDevice->bWPASuppWextEnabled == TRUE)
-                        {
-                  	union iwreq_data  wrqu;
-                  	memset(&wrqu, 0, sizeof (wrqu));
-                          wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-                  	printk("wireless_send_event--->SIOCGIWAP(disassociated:ASSOCIATE_WAIT_timeout)\n");
-                  	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
-                       }
-                    #endif
-		#endif
 
             s_bCommandComplete(pDevice);
             break;

commit cc856e61ee4ffb150ff352e3d6940978a2f819e8
Author: Andres More <more.andres@gmail.com>
Date:   Mon May 17 21:34:01 2010 -0300

    Staging: vt6656: removed custom UCHAR/USHORT/UINT/ULONG/ULONGLONG typedefs
    
    Cleared all checkpatch warnings but 'do not add new typedefs' ones.
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 6fec9094ccd0..72e21b6f0e88 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -219,7 +219,7 @@ s_vProbeChannel(
     PBYTE           pbyRate;
     PSTxMgmtPacket  pTxPacket;
     PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
-    UINT            ii;
+    unsigned int            ii;
 
 
     if (pDevice->byBBType == BB_TYPE_11A) {
@@ -316,15 +316,15 @@ s_MgrMakeProbeRequest(
     return pTxPacket;
 }
 
-void vCommandTimerWait(void *hDeviceContext, UINT MSecond)
+void vCommandTimerWait(void *hDeviceContext, unsigned int MSecond)
 {
     PSDevice        pDevice = (PSDevice)hDeviceContext;
 
     init_timer(&pDevice->sTimerCommand);
-    pDevice->sTimerCommand.data = (ULONG)pDevice;
+    pDevice->sTimerCommand.data = (unsigned long)pDevice;
     pDevice->sTimerCommand.function = (TimerFunction)vRunCommand;
     // RUN_AT :1 msec ~= (HZ/1024)
-    pDevice->sTimerCommand.expires = (UINT)RUN_AT((MSecond * HZ) >> 10);
+    pDevice->sTimerCommand.expires = (unsigned int)RUN_AT((MSecond * HZ) >> 10);
     add_timer(&pDevice->sTimerCommand);
     return;
 }
@@ -336,7 +336,7 @@ void vRunCommand(void *hDeviceContext)
     PWLAN_IE_SSID   pItemSSID;
     PWLAN_IE_SSID   pItemSSIDCurr;
     CMD_STATUS      Status;
-    UINT            ii;
+    unsigned int            ii;
     BYTE            byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
     struct sk_buff  *skb;
     BYTE            byData;
@@ -760,7 +760,7 @@ void vRunCommand(void *hDeviceContext)
                      // printk("Re-initial TxDataTimer****\n");
 		    del_timer(&pDevice->sTimerTxData);
                       init_timer(&pDevice->sTimerTxData);
-                      pDevice->sTimerTxData.data = (ULONG)pDevice;
+			pDevice->sTimerTxData.data = (unsigned long) pDevice;
                       pDevice->sTimerTxData.function = (TimerFunction)BSSvSecondTxData;
                       pDevice->sTimerTxData.expires = RUN_AT(10*HZ);      //10s callback
                       pDevice->fTxDataInSleep = FALSE;
@@ -1264,8 +1264,8 @@ BOOL bScheduleCommand(void *hDeviceContext,
 static BOOL s_bClearBSSID_SCAN(void *hDeviceContext)
 {
     PSDevice        pDevice = (PSDevice)hDeviceContext;
-    UINT            uCmdDequeueIdx = pDevice->uCmdDequeueIdx;
-    UINT            ii;
+    unsigned int            uCmdDequeueIdx = pDevice->uCmdDequeueIdx;
+    unsigned int            ii;
 
     if ((pDevice->cbFreeCmdQueue < CMD_Q_SIZE) && (uCmdDequeueIdx != pDevice->uCmdEnqueueIdx)) {
         for (ii = 0; ii < (CMD_Q_SIZE - pDevice->cbFreeCmdQueue); ii ++) {
@@ -1289,7 +1289,7 @@ void vResetCommandTimer(void *hDeviceContext)
       del_timer(&pDevice->sTimerCommand);
   //init timer
       init_timer(&pDevice->sTimerCommand);
-    pDevice->sTimerCommand.data = (ULONG)pDevice;
+    pDevice->sTimerCommand.data = (unsigned long)pDevice;
     pDevice->sTimerCommand.function = (TimerFunction)vRunCommand;
     pDevice->sTimerCommand.expires = RUN_AT(HZ);
     pDevice->cbFreeCmdQueue = CMD_Q_SIZE;

commit 0cbd8d9854284d3ff38d04aaa3ae726fb1c4a958
Author: Andres More <more.andres@gmail.com>
Date:   Thu May 6 20:34:29 2010 -0300

    staging: vt6656: code cleanup, removed HANDLE definition in ttype.h
    
    Checkpatch warnings about using externs in .c files were not resolved,
    neither some long lines on deeply nested code.
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 23db5f63c789..6fec9094ccd0 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -94,18 +94,12 @@ s_bCommandComplete (
     );
 
 
-static
-BOOL s_bClearBSSID_SCAN (
-     HANDLE hDeviceContext
-    );
+static BOOL s_bClearBSSID_SCAN(void *hDeviceContext);
 
 /*---------------------  Export Variables  --------------------------*/
 
-
 /*---------------------  Export Functions  --------------------------*/
 
-
-
 /*
  * Description:
  *      Stop AdHoc beacon during scan process
@@ -119,6 +113,7 @@ BOOL s_bClearBSSID_SCAN (
  * Return Value: none
  *
  */
+
 static
 void
 vAdHocBeaconStop(PSDevice  pDevice)
@@ -321,15 +316,7 @@ s_MgrMakeProbeRequest(
     return pTxPacket;
 }
 
-
-
-
-
-void
-vCommandTimerWait(
-     HANDLE    hDeviceContext,
-     UINT MSecond
-    )
+void vCommandTimerWait(void *hDeviceContext, UINT MSecond)
 {
     PSDevice        pDevice = (PSDevice)hDeviceContext;
 
@@ -342,13 +329,7 @@ vCommandTimerWait(
     return;
 }
 
-
-
-
-void
-vRunCommand(
-      HANDLE      hDeviceContext
-    )
+void vRunCommand(void *hDeviceContext)
 {
     PSDevice        pDevice = (PSDevice)hDeviceContext;
     PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
@@ -435,7 +416,8 @@ vRunCommand(
                     pMgmt->abyScanBSSID[5] = 0xFF;
                     pItemSSID->byElementID = WLAN_EID_SSID;
                     // clear bssid list
-                    // BSSvClearBSSList((HANDLE)pDevice, pDevice->bLinkPass);
+		    /* BSSvClearBSSList((void *) pDevice,
+		       pDevice->bLinkPass); */
                     pMgmt->eScanState = WMAC_IS_SCANNING;
                     pDevice->byScanBBType = pDevice->byBBType;  //lucas
                     pDevice->bStopDataPkt = TRUE;
@@ -480,11 +462,11 @@ vRunCommand(
                     (pMgmt->uScanChannel < CB_MAX_CHANNEL_24G)) {
                     s_vProbeChannel(pDevice);
                     spin_unlock_irq(&pDevice->lock);
-		     vCommandTimerWait((HANDLE)pDevice, 100);
+		     vCommandTimerWait((void *) pDevice, 100);
                     return;
                 } else {
                     spin_unlock_irq(&pDevice->lock);
-                    vCommandTimerWait((HANDLE)pDevice, WCMD_PASSIVE_SCAN_TIME);
+		    vCommandTimerWait((void *) pDevice, WCMD_PASSIVE_SCAN_TIME);
                     return;
                 }
 
@@ -552,7 +534,11 @@ vRunCommand(
 
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Send Disassociation Packet..\n");
                 // reason = 8 : disassoc because sta has left
-                vMgrDisassocBeginSta((HANDLE)pDevice, pMgmt, pMgmt->abyCurrBSSID, (8), &Status);
+		vMgrDisassocBeginSta((void *) pDevice,
+				     pMgmt,
+				     pMgmt->abyCurrBSSID,
+				     (8),
+				     &Status);
                 pDevice->bLinkPass = FALSE;
                 ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
                 // unlock command busy
@@ -614,22 +600,26 @@ vRunCommand(
             // set initial state
             pMgmt->eCurrState = WMAC_STATE_IDLE;
             pMgmt->eCurrMode = WMAC_MODE_STANDBY;
-            PSvDisablePowerSaving((HANDLE)pDevice);
+	    PSvDisablePowerSaving((void *) pDevice);
             BSSvClearNodeDBTable(pDevice, 0);
-            vMgrJoinBSSBegin((HANDLE)pDevice, &Status);
+	    vMgrJoinBSSBegin((void *) pDevice, &Status);
             // if Infra mode
             if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED)) {
                 // Call mgr to begin the deauthentication
                 // reason = (3) beacuse sta has left ESS
-                if (pMgmt->eCurrState>= WMAC_STATE_AUTH) {
-                    vMgrDeAuthenBeginSta((HANDLE)pDevice, pMgmt, pMgmt->abyCurrBSSID, (3), &Status);
-                }
+	      if (pMgmt->eCurrState >= WMAC_STATE_AUTH) {
+		vMgrDeAuthenBeginSta((void *)pDevice,
+				     pMgmt,
+				     pMgmt->abyCurrBSSID,
+				     (3),
+				     &Status);
+	      }
                 // Call mgr to begin the authentication
-                vMgrAuthenBeginSta((HANDLE)pDevice, pMgmt, &Status);
+		vMgrAuthenBeginSta((void *) pDevice, pMgmt, &Status);
                 if (Status == CMD_STATUS_SUCCESS) {
 		   pDevice->byLinkWaitCount = 0;
                     pDevice->eCommandState = WLAN_AUTHENTICATE_WAIT;
-                    vCommandTimerWait((HANDLE)pDevice, AUTHENTICATE_TIMEOUT);
+		    vCommandTimerWait((void *) pDevice, AUTHENTICATE_TIMEOUT);
                     spin_unlock_irq(&pDevice->lock);
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Set eCommandState = WLAN_AUTHENTICATE_WAIT\n");
                     return;
@@ -648,10 +638,12 @@ vRunCommand(
                 }
                 else {
                     // start own IBSS
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "CreateOwn IBSS by CurrMode = IBSS_STA \n");
-                    vMgrCreateOwnIBSS((HANDLE)pDevice, &Status);
+		    DBG_PRT(MSG_LEVEL_DEBUG,
+			    KERN_INFO "CreateOwn IBSS by CurrMode = IBSS_STA\n");
+		    vMgrCreateOwnIBSS((void *) pDevice, &Status);
                     if (Status != CMD_STATUS_SUCCESS){
-                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " WLAN_CMD_IBSS_CREATE fail ! \n");
+			DBG_PRT(MSG_LEVEL_DEBUG,
+				KERN_INFO "WLAN_CMD_IBSS_CREATE fail!\n");
                     };
                     BSSvAddMulticastNode(pDevice);
                 }
@@ -662,10 +654,12 @@ vRunCommand(
                 if (pMgmt->eConfigMode == WMAC_CONFIG_IBSS_STA ||
                     pMgmt->eConfigMode == WMAC_CONFIG_AUTO) {
                     // start own IBSS
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "CreateOwn IBSS by CurrMode = STANDBY \n");
-                    vMgrCreateOwnIBSS((HANDLE)pDevice, &Status);
+			DBG_PRT(MSG_LEVEL_DEBUG,
+				KERN_INFO "CreateOwn IBSS by CurrMode = STANDBY\n");
+		    vMgrCreateOwnIBSS((void *) pDevice, &Status);
                     if (Status != CMD_STATUS_SUCCESS){
-                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_IBSS_CREATE fail ! \n");
+			DBG_PRT(MSG_LEVEL_DEBUG,
+				KERN_INFO "WLAN_CMD_IBSS_CREATE fail!\n");
                     };
                     BSSvAddMulticastNode(pDevice);
                     s_bClearBSSID_SCAN(pDevice);
@@ -701,12 +695,12 @@ vRunCommand(
 		pDevice->byLinkWaitCount = 0;
                 // Call mgr to begin the association
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_AUTH\n");
-                vMgrAssocBeginSta((HANDLE)pDevice, pMgmt, &Status);
+		vMgrAssocBeginSta((void *) pDevice, pMgmt, &Status);
                 if (Status == CMD_STATUS_SUCCESS) {
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState = WLAN_ASSOCIATE_WAIT\n");
 		  pDevice->byLinkWaitCount = 0;
                     pDevice->eCommandState = WLAN_ASSOCIATE_WAIT;
-                    vCommandTimerWait((HANDLE)pDevice, ASSOCIATE_TIMEOUT);
+		    vCommandTimerWait((void *) pDevice, ASSOCIATE_TIMEOUT);
                     spin_unlock_irq(&pDevice->lock);
                     return;
                 }
@@ -718,7 +712,7 @@ vRunCommand(
                 pDevice->byLinkWaitCount ++;
 	       printk("WLAN_AUTHENTICATE_WAIT:wait %d times!!\n",pDevice->byLinkWaitCount);
 	       spin_unlock_irq(&pDevice->lock);
-	       vCommandTimerWait((HANDLE)pDevice, AUTHENTICATE_TIMEOUT/2);
+	       vCommandTimerWait((void *) pDevice, AUTHENTICATE_TIMEOUT/2);
 	       return;
 	   }
 	          pDevice->byLinkWaitCount = 0;
@@ -742,7 +736,8 @@ vRunCommand(
             if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_ASSOC\n");
                 if (pDevice->ePSMode != WMAC_POWER_CAM) {
-                    PSvEnablePowerSaving((HANDLE)pDevice, pMgmt->wListenInterval);
+			PSvEnablePowerSaving((void *) pDevice,
+					     pMgmt->wListenInterval);
                 }
 /*
                 if (pMgmt->eAuthenMode >= WMAC_AUTH_WPA) {
@@ -786,7 +781,7 @@ vRunCommand(
                 pDevice->byLinkWaitCount ++;
 	       printk("WLAN_ASSOCIATE_WAIT:wait %d times!!\n",pDevice->byLinkWaitCount);
 	       spin_unlock_irq(&pDevice->lock);
-	       vCommandTimerWait((HANDLE)pDevice, ASSOCIATE_TIMEOUT/2);
+	       vCommandTimerWait((void *) pDevice, ASSOCIATE_TIMEOUT/2);
 	       return;
 	   }
 	          pDevice->byLinkWaitCount = 0;
@@ -823,9 +818,10 @@ vRunCommand(
                 pMgmt->eCurrState = WMAC_STATE_IDLE;
                 pDevice->bFixRate = FALSE;
 
-                vMgrCreateOwnIBSS((HANDLE)pDevice, &Status);
-                if (Status != CMD_STATUS_SUCCESS){
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " vMgrCreateOwnIBSS fail ! \n");
+		vMgrCreateOwnIBSS((void *) pDevice, &Status);
+		if (Status != CMD_STATUS_SUCCESS) {
+			DBG_PRT(MSG_LEVEL_DEBUG,
+				KERN_INFO "vMgrCreateOwnIBSS fail!\n");
                 };
                 // alway turn off unicast bit
                 MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_UNICAST);
@@ -948,7 +944,11 @@ vRunCommand(
 
 	  if (pDevice->bLinkPass == TRUE) {
                 // reason = 8 : disassoc because sta has left
-                       vMgrDisassocBeginSta((HANDLE)pDevice, pMgmt, pMgmt->abyCurrBSSID, (8), &Status);
+		vMgrDisassocBeginSta((void *) pDevice,
+				     pMgmt,
+				     pMgmt->abyCurrBSSID,
+				     (8),
+				     &Status);
                        pDevice->bLinkPass = FALSE;
                 // unlock command busy
                         pMgmt->eCurrState = WMAC_STATE_IDLE;
@@ -1185,18 +1185,15 @@ s_bCommandComplete (
                 break;
 
         }
-
-        vCommandTimerWait((HANDLE)pDevice, 0);
+	vCommandTimerWait((void *) pDevice, 0);
     }
 
     return TRUE;
 }
 
-BOOL bScheduleCommand (
-     HANDLE hDeviceContext,
-     CMD_CODE    eCommand,
-     PBYTE       pbyItem0
-    )
+BOOL bScheduleCommand(void *hDeviceContext,
+		      CMD_CODE eCommand,
+		      PBYTE pbyItem0)
 {
     PSDevice        pDevice = (PSDevice)hDeviceContext;
 
@@ -1264,10 +1261,7 @@ BOOL bScheduleCommand (
  * Return Value: TRUE if success; otherwise FALSE
  *
  */
-static
-BOOL s_bClearBSSID_SCAN (
-     HANDLE hDeviceContext
-    )
+static BOOL s_bClearBSSID_SCAN(void *hDeviceContext)
 {
     PSDevice        pDevice = (PSDevice)hDeviceContext;
     UINT            uCmdDequeueIdx = pDevice->uCmdDequeueIdx;
@@ -1287,10 +1281,7 @@ BOOL s_bClearBSSID_SCAN (
 
 
 //mike add:reset command timer
-void
-vResetCommandTimer(
-     HANDLE      hDeviceContext
-    )
+void vResetCommandTimer(void *hDeviceContext)
 {
   PSDevice        pDevice = (PSDevice)hDeviceContext;
 
@@ -1311,10 +1302,7 @@ vResetCommandTimer(
 
 //2007-0115-08<Add>by MikeLiu
 #ifdef TxInSleep
-void
-BSSvSecondTxData(
-      HANDLE      hDeviceContext
-    )
+void BSSvSecondTxData(void *hDeviceContext)
 {
   PSDevice        pDevice = (PSDevice)hDeviceContext;
   PSMgmtObject  pMgmt = &(pDevice->sMgmtObj);

commit 8611a29ab967bc197494db19d31994d1b5a26fdc
Author: Andres More <more.andres@gmail.com>
Date:   Sat May 1 14:25:00 2010 -0300

    Staging: vt6656: removed VOID/PVOID definitions
    
    Warnings about the usage of externs in .c files were not resolved here.
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 7e543396536e..23db5f63c789 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -69,7 +69,7 @@ static int          msglevel                =MSG_LEVEL_INFO;
 /*---------------------  Static Functions  --------------------------*/
 
 static
-VOID
+void
 s_vProbeChannel(
      PSDevice pDevice
     );
@@ -210,7 +210,7 @@ vAdHocBeaconRestart(PSDevice pDevice)
 -*/
 
 static
-VOID
+void
 s_vProbeChannel(
      PSDevice pDevice
     )
@@ -325,7 +325,7 @@ s_MgrMakeProbeRequest(
 
 
 
-VOID
+void
 vCommandTimerWait(
      HANDLE    hDeviceContext,
      UINT MSecond
@@ -345,7 +345,7 @@ vCommandTimerWait(
 
 
 
-VOID
+void
 vRunCommand(
       HANDLE      hDeviceContext
     )
@@ -1287,7 +1287,7 @@ BOOL s_bClearBSSID_SCAN (
 
 
 //mike add:reset command timer
-VOID
+void
 vResetCommandTimer(
      HANDLE      hDeviceContext
     )
@@ -1311,7 +1311,7 @@ vResetCommandTimer(
 
 //2007-0115-08<Add>by MikeLiu
 #ifdef TxInSleep
-VOID
+void
 BSSvSecondTxData(
       HANDLE      hDeviceContext
     )

commit 592ccfebb3d7ae6d2fa367b97f080790befa3c6c
Author: Andres More <more.andres@gmail.com>
Date:   Sat Apr 17 12:07:42 2010 -0300

    Staging: vt6656: Removed IN definition
    
    Code cleanup, removed empty IN definition used to denote input parameters.
    
    Signed-off-by: Andres More <more.andres@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 51b2dcfbab91..7e543396536e 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -71,19 +71,19 @@ static int          msglevel                =MSG_LEVEL_INFO;
 static
 VOID
 s_vProbeChannel(
-    IN PSDevice pDevice
+     PSDevice pDevice
     );
 
 
 static
 PSTxMgmtPacket
 s_MgrMakeProbeRequest(
-    IN PSDevice pDevice,
-    IN PSMgmtObject pMgmt,
-    IN PBYTE pScanBSSID,
-    IN PWLAN_IE_SSID pSSID,
-    IN PWLAN_IE_SUPP_RATES pCurrRates,
-    IN PWLAN_IE_SUPP_RATES pCurrExtSuppRates
+     PSDevice pDevice,
+     PSMgmtObject pMgmt,
+     PBYTE pScanBSSID,
+     PWLAN_IE_SSID pSSID,
+     PWLAN_IE_SUPP_RATES pCurrRates,
+     PWLAN_IE_SUPP_RATES pCurrExtSuppRates
     );
 
 
@@ -96,7 +96,7 @@ s_bCommandComplete (
 
 static
 BOOL s_bClearBSSID_SCAN (
-    IN HANDLE hDeviceContext
+     HANDLE hDeviceContext
     );
 
 /*---------------------  Export Variables  --------------------------*/
@@ -212,7 +212,7 @@ vAdHocBeaconRestart(PSDevice pDevice)
 static
 VOID
 s_vProbeChannel(
-    IN PSDevice pDevice
+     PSDevice pDevice
     )
 {
                                                      //1M,   2M,   5M,   11M,  18M,  24M,  36M,  54M
@@ -275,12 +275,12 @@ s_vProbeChannel(
 
 PSTxMgmtPacket
 s_MgrMakeProbeRequest(
-    IN PSDevice pDevice,
-    IN PSMgmtObject pMgmt,
-    IN PBYTE pScanBSSID,
-    IN PWLAN_IE_SSID pSSID,
-    IN PWLAN_IE_SUPP_RATES pCurrRates,
-    IN PWLAN_IE_SUPP_RATES pCurrExtSuppRates
+     PSDevice pDevice,
+     PSMgmtObject pMgmt,
+     PBYTE pScanBSSID,
+     PWLAN_IE_SSID pSSID,
+     PWLAN_IE_SUPP_RATES pCurrRates,
+     PWLAN_IE_SUPP_RATES pCurrExtSuppRates
 
     )
 {
@@ -327,8 +327,8 @@ s_MgrMakeProbeRequest(
 
 VOID
 vCommandTimerWait(
-    IN HANDLE    hDeviceContext,
-    IN UINT MSecond
+     HANDLE    hDeviceContext,
+     UINT MSecond
     )
 {
     PSDevice        pDevice = (PSDevice)hDeviceContext;
@@ -347,7 +347,7 @@ vCommandTimerWait(
 
 VOID
 vRunCommand(
-    IN  HANDLE      hDeviceContext
+      HANDLE      hDeviceContext
     )
 {
     PSDevice        pDevice = (PSDevice)hDeviceContext;
@@ -1193,9 +1193,9 @@ s_bCommandComplete (
 }
 
 BOOL bScheduleCommand (
-    IN HANDLE hDeviceContext,
-    IN CMD_CODE    eCommand,
-    IN PBYTE       pbyItem0
+     HANDLE hDeviceContext,
+     CMD_CODE    eCommand,
+     PBYTE       pbyItem0
     )
 {
     PSDevice        pDevice = (PSDevice)hDeviceContext;
@@ -1266,7 +1266,7 @@ BOOL bScheduleCommand (
  */
 static
 BOOL s_bClearBSSID_SCAN (
-    IN HANDLE hDeviceContext
+     HANDLE hDeviceContext
     )
 {
     PSDevice        pDevice = (PSDevice)hDeviceContext;
@@ -1289,7 +1289,7 @@ BOOL s_bClearBSSID_SCAN (
 //mike add:reset command timer
 VOID
 vResetCommandTimer(
-    IN HANDLE      hDeviceContext
+     HANDLE      hDeviceContext
     )
 {
   PSDevice        pDevice = (PSDevice)hDeviceContext;
@@ -1313,7 +1313,7 @@ vResetCommandTimer(
 #ifdef TxInSleep
 VOID
 BSSvSecondTxData(
-    IN  HANDLE      hDeviceContext
+      HANDLE      hDeviceContext
     )
 {
   PSDevice        pDevice = (PSDevice)hDeviceContext;

commit bbc9a9916bc1cd997f3bf303e7930d5f3c804d37
Author: Andr Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:06 2009 -0200

    Staging: fix assorted typos all over the place
    
    Signed-off-by: Andr Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 0464093ed840..51b2dcfbab91 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -1331,7 +1331,7 @@ BSSvSecondTxData(
     }
 
   spin_lock_irq(&pDevice->lock);
-  //is wap_supplicant running sucessful OR only open && sharekey mode!
+  //is wap_supplicant running successful OR only open && sharekey mode!
   #if 1
   if(((pDevice->bLinkPass ==TRUE)&&(pMgmt->eAuthenMode < WMAC_AUTH_WPA)) ||  //open && sharekey linking
       (pDevice->fWPA_Authened == TRUE)) {   //wpa linking

commit 50fcfe57ee629c24f85618883c0eb09e3630339a
Author: Shawn Bohrer <shawn.bohrer@gmail.com>
Date:   Sun Oct 25 22:46:48 2009 -0500

    Staging: vt6656 remove duplicate includes
    
    Signed-off-by: Shawn Bohrer <shawn.bohrer@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 6912344fdfae..0464093ed840 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -48,7 +48,6 @@
 #include "wmgr.h"
 #include "power.h"
 #include "wctl.h"
-#include "card.h"
 #include "baseband.h"
 #include "control.h"
 #include "rxtx.h"

commit 3e362598fd3c7b8729afd0383a4cdf08849b020e
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:11 2009 -0700

    Staging: vt665x: Remove umem.h Part 2
    
    Remove references to umem.h macros and refer directly to memcpy
    functions.  Delete the include file.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index ce1d25060c04..6912344fdfae 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -51,7 +51,6 @@
 #include "card.h"
 #include "baseband.h"
 #include "control.h"
-#include "umem.h"
 #include "rxtx.h"
 #include "rf.h"
 #include "rndis.h"
@@ -1117,14 +1116,14 @@ s_bCommandComplete (
                 pDevice->eCommandState = WLAN_CMD_SCAN_START;
                 pMgmt->uScanChannel = 0;
                 if (pSSID->len != 0) {
-                    MEMvCopy(pMgmt->abyScanSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+                    memcpy(pMgmt->abyScanSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
                 } else {
                     memset(pMgmt->abyScanSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
                 }
 /*
                 if ((bForceSCAN == FALSE) && (pDevice->bLinkPass == TRUE)) {
                     if ((pSSID->len == ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->len) &&
-                        (MEMEqualMemory(pSSID->abySSID, ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->abySSID, pSSID->len))) {
+                        ( !memcmp(pSSID->abySSID, ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->abySSID, pSSID->len))) {
                         pDevice->eCommandState = WLAN_CMD_IDLE;
                     }
                 }
@@ -1135,7 +1134,7 @@ s_bCommandComplete (
                 if (pSSID->len > WLAN_SSID_MAXLEN)
                     pSSID->len = WLAN_SSID_MAXLEN;
                 if (pSSID->len != 0)
-                    MEMvCopy(pMgmt->abyDesireSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+                    memcpy(pMgmt->abyDesireSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_SSID_START\n");
                 break;
             case WLAN_CMD_DISASSOCIATE:
@@ -1213,12 +1212,12 @@ BOOL bScheduleCommand (
         switch (eCommand) {
             case WLAN_CMD_BSSID_SCAN:
                 pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = FALSE;
-                MEMvCopy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
+                memcpy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
                          pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
                 break;
 
             case WLAN_CMD_SSID:
-                MEMvCopy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
+                memcpy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
                          pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
                 break;
 

commit 9d26d60f99855056a20ac7c0b68eb5ed04619831
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:08 2009 -0700

    Staging: vt665x: Clean up include files, Part 1
    
    Remove cplusplus lines from include files
    Remove needless ifdefs on includes to conform with C
    conventions.  Remove misc commented code/includes
    Update TODO
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 899efb1d53f2..ce1d25060c04 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -38,67 +38,25 @@
  *
  */
 
-
-
-
-#if !defined(__TTYPE_H__)
 #include "ttype.h"
-#endif
-#if !defined(__TMACRO_H__)
 #include "tmacro.h"
-#endif
-#if !defined(__DEVICE_H__)
 #include "device.h"
-#endif
-#if !defined(__MAC_H__)
 #include "mac.h"
-#endif
-#if !defined(__CARD_H__)
 #include "card.h"
-#endif
-#if !defined(__80211HDR_H__)
 #include "80211hdr.h"
-#endif
-#if !defined(__WCMD_H__)
 #include "wcmd.h"
-#endif
-#if !defined(__WMGR_H__)
 #include "wmgr.h"
-#endif
-#if !defined(__POWER_H__)
 #include "power.h"
-#endif
-#if !defined(__WCTL_H__)
 #include "wctl.h"
-#endif
-#if !defined(__CARD_H__)
 #include "card.h"
-#endif
-#if !defined(__BASEBAND_H__)
 #include "baseband.h"
-#endif
-#if !defined(__CONTROL_H__)
 #include "control.h"
-#endif
-#if !defined(__UMEM_H__)
 #include "umem.h"
-#endif
-#if !defined(__RXTX_H__)
 #include "rxtx.h"
-#endif
-#if !defined(__RF_H__)
 #include "rf.h"
-#endif
-#if !defined(__RNDIS_H__)
 #include "rndis.h"
-#endif
-#if !defined (_CHANNEL_H_)
 #include "channel.h"
-#endif
-//DavidWang
-#if !defined(__IOWPA_H__)
 #include "iowpa.h"
-#endif
 
 /*---------------------  Static Definitions -------------------------*/
 

commit 193a823caaf0e2a79a447014be00a6b70ed216a2
Author: Jim Lieb <lieb@canonical.com>
Date:   Wed Aug 12 14:54:06 2009 -0700

    Staging: vt665x: Typedef and macro cleanup Part 1
    
    Clean up unused typedefs and macros to remove Win32'isms and
    misc non-linux constructs.  Text edits to referencing
    source for less frequently used macros.
    
    Signed-off-by: Jim Lieb <lieb@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 80d7ca73bcd9..899efb1d53f2 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -1265,7 +1265,7 @@ BOOL bScheduleCommand (
                 break;
 
             case WLAN_CMD_DISASSOCIATE:
-                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bNeedRadioOFF = *((PBOOL)pbyItem0);
+                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bNeedRadioOFF = *((int *)pbyItem0);
                 break;
 /*
             case WLAN_CMD_DEAUTH:
@@ -1274,7 +1274,7 @@ BOOL bScheduleCommand (
 */
 
             case WLAN_CMD_RADIO:
-                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bRadioCmd = *((PBOOL)pbyItem0);
+                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bRadioCmd = *((int *)pbyItem0);
                 break;
 
             default:

commit edb3a9507c898ae5f71bbaae932e66801318e90b
Author: Alexander Beregalov <a.beregalov@gmail.com>
Date:   Fri Jul 3 09:52:59 2009 +0400

    Staging: vt6656: remove dependency on kernel version
    
    Signed-off-by: Alexander Beregalov <a.beregalov@gmail.com>
    Acked-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 7c0829ee0ac0..80d7ca73bcd9 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -524,12 +524,7 @@ vRunCommand(
                     (pMgmt->uScanChannel < CB_MAX_CHANNEL_24G)) {
                     s_vProbeChannel(pDevice);
                     spin_unlock_irq(&pDevice->lock);
-		//2008-0526-02<Add>by MikeLiu
-                  #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
 		     vCommandTimerWait((HANDLE)pDevice, 100);
-                  #else
-                    vCommandTimerWait((HANDLE)pDevice, WCMD_ACTIVE_SCAN_TIME);
-		#endif
                     return;
                 } else {
                     spin_unlock_irq(&pDevice->lock);

commit 92b96797118e5836294a6d42a5a8e10b86f50e3f
Author: Forest Bond <forest@alittletooquiet.net>
Date:   Sat Jun 13 07:38:31 2009 -0400

    Staging: Add pristine upstream vt6656 driver sources to drivers/staging/vt6656.
    
    Add pristine upstream vt6656 driver sources to drivers/staging/vt6656.  These
    files were copied from the driver directory in the upstream source archive,
    available here:
    
      http://www.viaarena.com/Driver/VT6656_Linux_src_v1.19_12_x86.zip
    
    After copying, trailing whitespace was stripped.  This is GPL-licensed code.
    
    Signed-off-by: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
new file mode 100644
index 000000000000..7c0829ee0ac0
--- /dev/null
+++ b/drivers/staging/vt6656/wcmd.c
@@ -0,0 +1,1402 @@
+/*
+ * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * File: wcmd.c
+ *
+ * Purpose: Handles the management command interface functions
+ *
+ * Author: Lyndon Chen
+ *
+ * Date: May 8, 2003
+ *
+ * Functions:
+ *      s_vProbeChannel - Active scan channel
+ *      s_MgrMakeProbeRequest - Make ProbeRequest packet
+ *      CommandTimer - Timer function to handle command
+ *      s_bCommandComplete - Command Complete function
+ *      bScheduleCommand - Push Command and wait Command Scheduler to do
+ *      vCommandTimer- Command call back functions
+ *      vCommandTimerWait- Call back timer
+ *      s_bClearBSSID_SCAN- Clear BSSID_SCAN cmd in CMD Queue
+ *
+ * Revision History:
+ *
+ */
+
+
+
+
+#if !defined(__TTYPE_H__)
+#include "ttype.h"
+#endif
+#if !defined(__TMACRO_H__)
+#include "tmacro.h"
+#endif
+#if !defined(__DEVICE_H__)
+#include "device.h"
+#endif
+#if !defined(__MAC_H__)
+#include "mac.h"
+#endif
+#if !defined(__CARD_H__)
+#include "card.h"
+#endif
+#if !defined(__80211HDR_H__)
+#include "80211hdr.h"
+#endif
+#if !defined(__WCMD_H__)
+#include "wcmd.h"
+#endif
+#if !defined(__WMGR_H__)
+#include "wmgr.h"
+#endif
+#if !defined(__POWER_H__)
+#include "power.h"
+#endif
+#if !defined(__WCTL_H__)
+#include "wctl.h"
+#endif
+#if !defined(__CARD_H__)
+#include "card.h"
+#endif
+#if !defined(__BASEBAND_H__)
+#include "baseband.h"
+#endif
+#if !defined(__CONTROL_H__)
+#include "control.h"
+#endif
+#if !defined(__UMEM_H__)
+#include "umem.h"
+#endif
+#if !defined(__RXTX_H__)
+#include "rxtx.h"
+#endif
+#if !defined(__RF_H__)
+#include "rf.h"
+#endif
+#if !defined(__RNDIS_H__)
+#include "rndis.h"
+#endif
+#if !defined (_CHANNEL_H_)
+#include "channel.h"
+#endif
+//DavidWang
+#if !defined(__IOWPA_H__)
+#include "iowpa.h"
+#endif
+
+/*---------------------  Static Definitions -------------------------*/
+
+
+
+
+/*---------------------  Static Classes  ----------------------------*/
+
+/*---------------------  Static Variables  --------------------------*/
+static int          msglevel                =MSG_LEVEL_INFO;
+//static int          msglevel                =MSG_LEVEL_DEBUG;
+/*---------------------  Static Functions  --------------------------*/
+
+static
+VOID
+s_vProbeChannel(
+    IN PSDevice pDevice
+    );
+
+
+static
+PSTxMgmtPacket
+s_MgrMakeProbeRequest(
+    IN PSDevice pDevice,
+    IN PSMgmtObject pMgmt,
+    IN PBYTE pScanBSSID,
+    IN PWLAN_IE_SSID pSSID,
+    IN PWLAN_IE_SUPP_RATES pCurrRates,
+    IN PWLAN_IE_SUPP_RATES pCurrExtSuppRates
+    );
+
+
+static
+BOOL
+s_bCommandComplete (
+    PSDevice pDevice
+    );
+
+
+static
+BOOL s_bClearBSSID_SCAN (
+    IN HANDLE hDeviceContext
+    );
+
+/*---------------------  Export Variables  --------------------------*/
+
+
+/*---------------------  Export Functions  --------------------------*/
+
+
+
+/*
+ * Description:
+ *      Stop AdHoc beacon during scan process
+ *
+ * Parameters:
+ *  In:
+ *      pDevice     - Pointer to the adapter
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+static
+void
+vAdHocBeaconStop(PSDevice  pDevice)
+{
+
+    PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
+    BOOL            bStop;
+
+    /*
+     * temporarily stop Beacon packet for AdHoc Server
+     * if all of the following coditions are met:
+     *  (1) STA is in AdHoc mode
+     *  (2) VT3253 is programmed as automatic Beacon Transmitting
+     *  (3) One of the following conditions is met
+     *      (3.1) AdHoc channel is in B/G band and the
+     *      current scan channel is in A band
+     *      or
+     *      (3.2) AdHoc channel is in A mode
+     */
+    bStop = FALSE;
+    if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
+    (pMgmt->eCurrState >= WMAC_STATE_STARTED))
+    {
+        if ((pMgmt->uIBSSChannel <=  CB_MAX_CHANNEL_24G) &&
+             (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G))
+        {
+            bStop = TRUE;
+        }
+        if (pMgmt->uIBSSChannel >  CB_MAX_CHANNEL_24G)
+        {
+            bStop = TRUE;
+        }
+    }
+
+    if (bStop)
+    {
+        //PMESG(("STOP_BEACON: IBSSChannel = %u, ScanChannel = %u\n",
+        //        pMgmt->uIBSSChannel, pMgmt->uScanChannel));
+        MACvRegBitsOff(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
+    }
+
+} /* vAdHocBeaconStop */
+
+
+/*
+ * Description:
+ *      Restart AdHoc beacon after scan process complete
+ *
+ * Parameters:
+ *  In:
+ *      pDevice     - Pointer to the adapter
+ *  Out:
+ *      none
+ *
+ * Return Value: none
+ *
+ */
+static
+void
+vAdHocBeaconRestart(PSDevice pDevice)
+{
+    PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
+
+    /*
+     * Restart Beacon packet for AdHoc Server
+     * if all of the following coditions are met:
+     *  (1) STA is in AdHoc mode
+     *  (2) VT3253 is programmed as automatic Beacon Transmitting
+     */
+    if ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) &&
+    (pMgmt->eCurrState >= WMAC_STATE_STARTED))
+    {
+        //PMESG(("RESTART_BEACON\n"));
+        MACvRegBitsOn(pDevice, MAC_REG_TCR, TCR_AUTOBCNTX);
+    }
+
+}
+
+
+/*+
+ *
+ * Routine Description:
+ *   Prepare and send probe request management frames.
+ *
+ *
+ * Return Value:
+ *    none.
+ *
+-*/
+
+static
+VOID
+s_vProbeChannel(
+    IN PSDevice pDevice
+    )
+{
+                                                     //1M,   2M,   5M,   11M,  18M,  24M,  36M,  54M
+    BYTE abyCurrSuppRatesG[] = {WLAN_EID_SUPP_RATES, 8, 0x02, 0x04, 0x0B, 0x16, 0x24, 0x30, 0x48, 0x6C};
+    BYTE abyCurrExtSuppRatesG[] = {WLAN_EID_EXTSUPP_RATES, 4, 0x0C, 0x12, 0x18, 0x60};
+                                                           //6M,   9M,   12M,  48M
+    BYTE abyCurrSuppRatesA[] = {WLAN_EID_SUPP_RATES, 8, 0x0C, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6C};
+    BYTE abyCurrSuppRatesB[] = {WLAN_EID_SUPP_RATES, 4, 0x02, 0x04, 0x0B, 0x16};
+    PBYTE           pbyRate;
+    PSTxMgmtPacket  pTxPacket;
+    PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
+    UINT            ii;
+
+
+    if (pDevice->byBBType == BB_TYPE_11A) {
+        pbyRate = &abyCurrSuppRatesA[0];
+    } else if (pDevice->byBBType == BB_TYPE_11B) {
+        pbyRate = &abyCurrSuppRatesB[0];
+    } else {
+        pbyRate = &abyCurrSuppRatesG[0];
+    }
+    // build an assocreq frame and send it
+    pTxPacket = s_MgrMakeProbeRequest
+                (
+                  pDevice,
+                  pMgmt,
+                  pMgmt->abyScanBSSID,
+                  (PWLAN_IE_SSID)pMgmt->abyScanSSID,
+                  (PWLAN_IE_SUPP_RATES)pbyRate,
+                  (PWLAN_IE_SUPP_RATES)abyCurrExtSuppRatesG
+                );
+
+    if (pTxPacket != NULL ){
+        for (ii = 0; ii < 1 ; ii++) {
+            if (csMgmt_xmit(pDevice, pTxPacket) != CMD_STATUS_PENDING) {
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request sending fail.. \n");
+            }
+            else {
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Probe request is sending.. \n");
+            }
+        }
+    }
+
+}
+
+
+
+
+/*+
+ *
+ * Routine Description:
+ *  Constructs an probe request frame
+ *
+ *
+ * Return Value:
+ *    A ptr to Tx frame or NULL on allocation failue
+ *
+-*/
+
+
+PSTxMgmtPacket
+s_MgrMakeProbeRequest(
+    IN PSDevice pDevice,
+    IN PSMgmtObject pMgmt,
+    IN PBYTE pScanBSSID,
+    IN PWLAN_IE_SSID pSSID,
+    IN PWLAN_IE_SUPP_RATES pCurrRates,
+    IN PWLAN_IE_SUPP_RATES pCurrExtSuppRates
+
+    )
+{
+    PSTxMgmtPacket      pTxPacket = NULL;
+    WLAN_FR_PROBEREQ    sFrame;
+
+
+    pTxPacket = (PSTxMgmtPacket)pMgmt->pbyMgmtPacketPool;
+    memset(pTxPacket, 0, sizeof(STxMgmtPacket) + WLAN_PROBEREQ_FR_MAXLEN);
+    pTxPacket->p80211Header = (PUWLAN_80211HDR)((PBYTE)pTxPacket + sizeof(STxMgmtPacket));
+    sFrame.pBuf = (PBYTE)pTxPacket->p80211Header;
+    sFrame.len = WLAN_PROBEREQ_FR_MAXLEN;
+    vMgrEncodeProbeRequest(&sFrame);
+    sFrame.pHdr->sA3.wFrameCtl = cpu_to_le16(
+        (
+        WLAN_SET_FC_FTYPE(WLAN_TYPE_MGR) |
+        WLAN_SET_FC_FSTYPE(WLAN_FSTYPE_PROBEREQ)
+        ));
+    memcpy( sFrame.pHdr->sA3.abyAddr1, pScanBSSID, WLAN_ADDR_LEN);
+    memcpy( sFrame.pHdr->sA3.abyAddr2, pMgmt->abyMACAddr, WLAN_ADDR_LEN);
+    memcpy( sFrame.pHdr->sA3.abyAddr3, pScanBSSID, WLAN_BSSID_LEN);
+    // Copy the SSID, pSSID->len=0 indicate broadcast SSID
+    sFrame.pSSID = (PWLAN_IE_SSID)(sFrame.pBuf + sFrame.len);
+    sFrame.len += pSSID->len + WLAN_IEHDR_LEN;
+    memcpy(sFrame.pSSID, pSSID, pSSID->len + WLAN_IEHDR_LEN);
+    sFrame.pSuppRates = (PWLAN_IE_SUPP_RATES)(sFrame.pBuf + sFrame.len);
+    sFrame.len += pCurrRates->len + WLAN_IEHDR_LEN;
+    memcpy(sFrame.pSuppRates, pCurrRates, pCurrRates->len + WLAN_IEHDR_LEN);
+    // Copy the extension rate set
+    if (pDevice->byBBType == BB_TYPE_11G) {
+        sFrame.pExtSuppRates = (PWLAN_IE_SUPP_RATES)(sFrame.pBuf + sFrame.len);
+        sFrame.len += pCurrExtSuppRates->len + WLAN_IEHDR_LEN;
+        memcpy(sFrame.pExtSuppRates, pCurrExtSuppRates, pCurrExtSuppRates->len + WLAN_IEHDR_LEN);
+    }
+    pTxPacket->cbMPDULen = sFrame.len;
+    pTxPacket->cbPayloadLen = sFrame.len - WLAN_HDR_ADDR3_LEN;
+
+    return pTxPacket;
+}
+
+
+
+
+
+VOID
+vCommandTimerWait(
+    IN HANDLE    hDeviceContext,
+    IN UINT MSecond
+    )
+{
+    PSDevice        pDevice = (PSDevice)hDeviceContext;
+
+    init_timer(&pDevice->sTimerCommand);
+    pDevice->sTimerCommand.data = (ULONG)pDevice;
+    pDevice->sTimerCommand.function = (TimerFunction)vRunCommand;
+    // RUN_AT :1 msec ~= (HZ/1024)
+    pDevice->sTimerCommand.expires = (UINT)RUN_AT((MSecond * HZ) >> 10);
+    add_timer(&pDevice->sTimerCommand);
+    return;
+}
+
+
+
+
+VOID
+vRunCommand(
+    IN  HANDLE      hDeviceContext
+    )
+{
+    PSDevice        pDevice = (PSDevice)hDeviceContext;
+    PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
+    PWLAN_IE_SSID   pItemSSID;
+    PWLAN_IE_SSID   pItemSSIDCurr;
+    CMD_STATUS      Status;
+    UINT            ii;
+    BYTE            byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
+    struct sk_buff  *skb;
+    BYTE            byData;
+
+
+    if (pDevice->dwDiagRefCount != 0)
+        return;
+    if (pDevice->bCmdRunning != TRUE)
+        return;
+
+    spin_lock_irq(&pDevice->lock);
+
+    switch ( pDevice->eCommandState ) {
+
+        case WLAN_CMD_SCAN_START:
+
+		pDevice->byReAssocCount = 0;
+            if (pDevice->bRadioOff == TRUE) {
+                s_bCommandComplete(pDevice);
+                spin_unlock_irq(&pDevice->lock);
+                return;
+            }
+
+            if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
+                s_bCommandComplete(pDevice);
+                spin_unlock_irq(&pDevice->lock);
+                return;
+            }
+
+            pItemSSID = (PWLAN_IE_SSID)pMgmt->abyScanSSID;
+
+            if (pMgmt->uScanChannel == 0 ) {
+                pMgmt->uScanChannel = pDevice->byMinChannel;
+            }
+            if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
+                pMgmt->eScanState = WMAC_NO_SCANNING;
+
+                if (pDevice->byBBType != pDevice->byScanBBType) {
+                    pDevice->byBBType = pDevice->byScanBBType;
+                    CARDvSetBSSMode(pDevice);
+                }
+
+                if (pDevice->bUpdateBBVGA) {
+                    BBvSetShortSlotTime(pDevice);
+                    BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
+                    BBvUpdatePreEDThreshold(pDevice, FALSE);
+                }
+                // Set channel back
+                vAdHocBeaconRestart(pDevice);
+                // Set channel back
+                CARDbSetMediaChannel(pDevice, pMgmt->uCurrChannel);
+                // Set Filter
+                if (pMgmt->bCurrBSSIDFilterOn) {
+                    MACvRegBitsOn(pDevice, MAC_REG_RCR, RCR_BSSID);
+                    pDevice->byRxMode |= RCR_BSSID;
+                }
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning, set back to channel: [%d]\n", pMgmt->uCurrChannel);
+                pDevice->bStopDataPkt = FALSE;
+                s_bCommandComplete(pDevice);
+                spin_unlock_irq(&pDevice->lock);
+                return;
+
+            } else {
+                if (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel)) {
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Invalid channel pMgmt->uScanChannel = %d \n",pMgmt->uScanChannel);
+                    s_bCommandComplete(pDevice);
+                    spin_unlock_irq(&pDevice->lock);
+                    return;
+                }
+                if (pMgmt->uScanChannel == pDevice->byMinChannel) {
+                   // pMgmt->eScanType = WMAC_SCAN_ACTIVE;          //mike mark
+                    pMgmt->abyScanBSSID[0] = 0xFF;
+                    pMgmt->abyScanBSSID[1] = 0xFF;
+                    pMgmt->abyScanBSSID[2] = 0xFF;
+                    pMgmt->abyScanBSSID[3] = 0xFF;
+                    pMgmt->abyScanBSSID[4] = 0xFF;
+                    pMgmt->abyScanBSSID[5] = 0xFF;
+                    pItemSSID->byElementID = WLAN_EID_SSID;
+                    // clear bssid list
+                    // BSSvClearBSSList((HANDLE)pDevice, pDevice->bLinkPass);
+                    pMgmt->eScanState = WMAC_IS_SCANNING;
+                    pDevice->byScanBBType = pDevice->byBBType;  //lucas
+                    pDevice->bStopDataPkt = TRUE;
+                    // Turn off RCR_BSSID filter everytime
+                    MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_BSSID);
+                    pDevice->byRxMode &= ~RCR_BSSID;
+
+                }
+                //lucas
+                vAdHocBeaconStop(pDevice);
+                if ((pDevice->byBBType != BB_TYPE_11A) && (pMgmt->uScanChannel > CB_MAX_CHANNEL_24G)) {
+                    pDevice->byBBType = BB_TYPE_11A;
+                    CARDvSetBSSMode(pDevice);
+                }
+                else if ((pDevice->byBBType == BB_TYPE_11A) && (pMgmt->uScanChannel <= CB_MAX_CHANNEL_24G)) {
+                    pDevice->byBBType = BB_TYPE_11G;
+                    CARDvSetBSSMode(pDevice);
+                }
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning....  channel: [%d]\n", pMgmt->uScanChannel);
+                // Set channel
+                CARDbSetMediaChannel(pDevice, pMgmt->uScanChannel);
+                // Set Baseband to be more sensitive.
+
+                if (pDevice->bUpdateBBVGA) {
+                    BBvSetShortSlotTime(pDevice);
+                    BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
+                    BBvUpdatePreEDThreshold(pDevice, TRUE);
+                }
+                pMgmt->uScanChannel++;
+
+                while (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel) &&
+                        pMgmt->uScanChannel <= pDevice->byMaxChannel ){
+                    pMgmt->uScanChannel++;
+                }
+
+                if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
+                    // Set Baseband to be not sensitive and rescan
+                    pDevice->eCommandState = WLAN_CMD_SCAN_END;
+
+                }
+                if ((pMgmt->b11hEnable == FALSE) ||
+                    (pMgmt->uScanChannel < CB_MAX_CHANNEL_24G)) {
+                    s_vProbeChannel(pDevice);
+                    spin_unlock_irq(&pDevice->lock);
+		//2008-0526-02<Add>by MikeLiu
+                  #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+		     vCommandTimerWait((HANDLE)pDevice, 100);
+                  #else
+                    vCommandTimerWait((HANDLE)pDevice, WCMD_ACTIVE_SCAN_TIME);
+		#endif
+                    return;
+                } else {
+                    spin_unlock_irq(&pDevice->lock);
+                    vCommandTimerWait((HANDLE)pDevice, WCMD_PASSIVE_SCAN_TIME);
+                    return;
+                }
+
+            }
+
+            break;
+
+        case WLAN_CMD_SCAN_END:
+
+            // Set Baseband's sensitivity back.
+            if (pDevice->byBBType != pDevice->byScanBBType) {
+                pDevice->byBBType = pDevice->byScanBBType;
+                CARDvSetBSSMode(pDevice);
+            }
+
+            if (pDevice->bUpdateBBVGA) {
+                BBvSetShortSlotTime(pDevice);
+                BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
+                BBvUpdatePreEDThreshold(pDevice, FALSE);
+            }
+
+            // Set channel back
+            vAdHocBeaconRestart(pDevice);
+            // Set channel back
+            CARDbSetMediaChannel(pDevice, pMgmt->uCurrChannel);
+            // Set Filter
+            if (pMgmt->bCurrBSSIDFilterOn) {
+                MACvRegBitsOn(pDevice, MAC_REG_RCR, RCR_BSSID);
+                pDevice->byRxMode |= RCR_BSSID;
+            }
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Scanning, set back to channel: [%d]\n", pMgmt->uCurrChannel);
+            pMgmt->eScanState = WMAC_NO_SCANNING;
+            pDevice->bStopDataPkt = FALSE;
+//2008-0409-07, <Add> by Einsn Liu
+#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+	if(pMgmt->eScanType == WMAC_SCAN_PASSIVE)
+		{
+			//send scan event to wpa_Supplicant
+				union iwreq_data wrqu;
+				PRINT_K("wireless_send_event--->SIOCGIWSCAN(scan done)\n");
+				memset(&wrqu, 0, sizeof(wrqu));
+				wireless_send_event(pDevice->dev, SIOCGIWSCAN, &wrqu, NULL);
+			}
+#endif
+            s_bCommandComplete(pDevice);
+            break;
+
+        case WLAN_CMD_DISASSOCIATE_START :
+		pDevice->byReAssocCount = 0;
+            if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
+                (pMgmt->eCurrState != WMAC_STATE_ASSOC)) {
+                s_bCommandComplete(pDevice);
+                spin_unlock_irq(&pDevice->lock);
+                return;
+            } else {
+
+          #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+		      pDevice->bwextstep0 = FALSE;
+                        pDevice->bwextstep1 = FALSE;
+                        pDevice->bwextstep2 = FALSE;
+                        pDevice->bwextstep3 = FALSE;
+		   pDevice->bWPASuppWextEnabled = FALSE;
+	 #endif
+                   pDevice->fWPA_Authened = FALSE;
+
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Send Disassociation Packet..\n");
+                // reason = 8 : disassoc because sta has left
+                vMgrDisassocBeginSta((HANDLE)pDevice, pMgmt, pMgmt->abyCurrBSSID, (8), &Status);
+                pDevice->bLinkPass = FALSE;
+                ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
+                // unlock command busy
+                pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
+                pItemSSID->len = 0;
+                memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
+                pMgmt->eCurrState = WMAC_STATE_IDLE;
+                pMgmt->sNodeDBTable[0].bActive = FALSE;
+//                pDevice->bBeaconBufReady = FALSE;
+            }
+            netif_stop_queue(pDevice->dev);
+            if (pDevice->bNeedRadioOFF == TRUE)
+                CARDbRadioPowerOff(pDevice);
+            s_bCommandComplete(pDevice);
+            break;
+
+
+        case WLAN_CMD_SSID_START:
+
+		pDevice->byReAssocCount = 0;
+            if (pDevice->bRadioOff == TRUE) {
+                s_bCommandComplete(pDevice);
+                spin_unlock_irq(&pDevice->lock);
+                return;
+            }
+
+//20080131-03,<Add> by Mike Liu
+	#ifdef Adhoc_STA
+            memcpy(pMgmt->abyAdHocSSID,pMgmt->abyDesireSSID,
+                              ((PWLAN_IE_SSID)pMgmt->abyDesireSSID)->len + WLAN_IEHDR_LEN);
+	#endif
+            pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
+            pItemSSIDCurr = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" cmd: desire ssid = %s\n", pItemSSID->abySSID);
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" cmd: curr ssid = %s\n", pItemSSIDCurr->abySSID);
+
+            if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Cmd pMgmt->eCurrState == WMAC_STATE_ASSOC\n");
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pItemSSID->len =%d\n",pItemSSID->len);
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pItemSSIDCurr->len = %d\n",pItemSSIDCurr->len);
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" desire ssid = %s\n", pItemSSID->abySSID);
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" curr ssid = %s\n", pItemSSIDCurr->abySSID);
+            }
+
+            if ((pMgmt->eCurrState == WMAC_STATE_ASSOC) ||
+                ((pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)&& (pMgmt->eCurrState == WMAC_STATE_JOINTED))) {
+
+                if (pItemSSID->len == pItemSSIDCurr->len) {
+                    if (memcmp(pItemSSID->abySSID, pItemSSIDCurr->abySSID, pItemSSID->len) == 0) {
+                        s_bCommandComplete(pDevice);
+                        spin_unlock_irq(&pDevice->lock);
+                        return;
+                    }
+                }
+                netif_stop_queue(pDevice->dev);
+                pDevice->bLinkPass = FALSE;
+                ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
+            }
+            // set initial state
+            pMgmt->eCurrState = WMAC_STATE_IDLE;
+            pMgmt->eCurrMode = WMAC_MODE_STANDBY;
+            PSvDisablePowerSaving((HANDLE)pDevice);
+            BSSvClearNodeDBTable(pDevice, 0);
+            vMgrJoinBSSBegin((HANDLE)pDevice, &Status);
+            // if Infra mode
+            if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED)) {
+                // Call mgr to begin the deauthentication
+                // reason = (3) beacuse sta has left ESS
+                if (pMgmt->eCurrState>= WMAC_STATE_AUTH) {
+                    vMgrDeAuthenBeginSta((HANDLE)pDevice, pMgmt, pMgmt->abyCurrBSSID, (3), &Status);
+                }
+                // Call mgr to begin the authentication
+                vMgrAuthenBeginSta((HANDLE)pDevice, pMgmt, &Status);
+                if (Status == CMD_STATUS_SUCCESS) {
+		   pDevice->byLinkWaitCount = 0;
+                    pDevice->eCommandState = WLAN_AUTHENTICATE_WAIT;
+                    vCommandTimerWait((HANDLE)pDevice, AUTHENTICATE_TIMEOUT);
+                    spin_unlock_irq(&pDevice->lock);
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Set eCommandState = WLAN_AUTHENTICATE_WAIT\n");
+                    return;
+                }
+            }
+            // if Adhoc mode
+            else if (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {
+                if (pMgmt->eCurrState == WMAC_STATE_JOINTED) {
+                    if (netif_queue_stopped(pDevice->dev)){
+                        netif_wake_queue(pDevice->dev);
+                    }
+                    pDevice->bLinkPass = TRUE;
+                    ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
+                    pMgmt->sNodeDBTable[0].bActive = TRUE;
+                    pMgmt->sNodeDBTable[0].uInActiveCount = 0;
+                }
+                else {
+                    // start own IBSS
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "CreateOwn IBSS by CurrMode = IBSS_STA \n");
+                    vMgrCreateOwnIBSS((HANDLE)pDevice, &Status);
+                    if (Status != CMD_STATUS_SUCCESS){
+                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " WLAN_CMD_IBSS_CREATE fail ! \n");
+                    };
+                    BSSvAddMulticastNode(pDevice);
+                }
+                s_bClearBSSID_SCAN(pDevice);
+            }
+            // if SSID not found
+            else if (pMgmt->eCurrMode == WMAC_MODE_STANDBY) {
+                if (pMgmt->eConfigMode == WMAC_CONFIG_IBSS_STA ||
+                    pMgmt->eConfigMode == WMAC_CONFIG_AUTO) {
+                    // start own IBSS
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "CreateOwn IBSS by CurrMode = STANDBY \n");
+                    vMgrCreateOwnIBSS((HANDLE)pDevice, &Status);
+                    if (Status != CMD_STATUS_SUCCESS){
+                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_IBSS_CREATE fail ! \n");
+                    };
+                    BSSvAddMulticastNode(pDevice);
+                    s_bClearBSSID_SCAN(pDevice);
+/*
+                    pDevice->bLinkPass = TRUE;
+                    ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
+                    if (netif_queue_stopped(pDevice->dev)){
+                        netif_wake_queue(pDevice->dev);
+                    }
+                    s_bClearBSSID_SCAN(pDevice);
+*/
+                }
+                else {
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Disconnect SSID none\n");
+                     #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+                    // if(pDevice->bWPASuppWextEnabled == TRUE)
+                        {
+                  	union iwreq_data  wrqu;
+                  	memset(&wrqu, 0, sizeof (wrqu));
+                          wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+                  	PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated:vMgrJoinBSSBegin Fail !!)\n");
+                  	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
+                       }
+                    #endif
+                }
+            }
+            s_bCommandComplete(pDevice);
+            break;
+
+        case WLAN_AUTHENTICATE_WAIT :
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_AUTHENTICATE_WAIT\n");
+            if (pMgmt->eCurrState == WMAC_STATE_AUTH) {
+		pDevice->byLinkWaitCount = 0;
+                // Call mgr to begin the association
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_AUTH\n");
+                vMgrAssocBeginSta((HANDLE)pDevice, pMgmt, &Status);
+                if (Status == CMD_STATUS_SUCCESS) {
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState = WLAN_ASSOCIATE_WAIT\n");
+		  pDevice->byLinkWaitCount = 0;
+                    pDevice->eCommandState = WLAN_ASSOCIATE_WAIT;
+                    vCommandTimerWait((HANDLE)pDevice, ASSOCIATE_TIMEOUT);
+                    spin_unlock_irq(&pDevice->lock);
+                    return;
+                }
+            }
+	   else if(pMgmt->eCurrState < WMAC_STATE_AUTHPENDING) {
+               printk("WLAN_AUTHENTICATE_WAIT:Authen Fail???\n");
+	   }
+	   else  if(pDevice->byLinkWaitCount <= 4){    //mike add:wait another 2 sec if authenticated_frame delay!
+                pDevice->byLinkWaitCount ++;
+	       printk("WLAN_AUTHENTICATE_WAIT:wait %d times!!\n",pDevice->byLinkWaitCount);
+	       spin_unlock_irq(&pDevice->lock);
+	       vCommandTimerWait((HANDLE)pDevice, AUTHENTICATE_TIMEOUT/2);
+	       return;
+	   }
+	          pDevice->byLinkWaitCount = 0;
+		 #if 0
+                     #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+                    // if(pDevice->bWPASuppWextEnabled == TRUE)
+                        {
+                  	union iwreq_data  wrqu;
+                  	memset(&wrqu, 0, sizeof (wrqu));
+                          wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+                  	printk("wireless_send_event--->SIOCGIWAP(disassociated:AUTHENTICATE_WAIT_timeout)\n");
+                  	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
+                       }
+                    #endif
+	         #endif
+
+            s_bCommandComplete(pDevice);
+            break;
+
+        case WLAN_ASSOCIATE_WAIT :
+            if (pMgmt->eCurrState == WMAC_STATE_ASSOC) {
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCurrState == WMAC_STATE_ASSOC\n");
+                if (pDevice->ePSMode != WMAC_POWER_CAM) {
+                    PSvEnablePowerSaving((HANDLE)pDevice, pMgmt->wListenInterval);
+                }
+/*
+                if (pMgmt->eAuthenMode >= WMAC_AUTH_WPA) {
+                    KeybRemoveAllKey(pDevice, &(pDevice->sKey), pDevice->abyBSSID);
+                }
+*/
+                pDevice->byLinkWaitCount = 0;
+                pDevice->byReAssocCount = 0;
+                pDevice->bLinkPass = TRUE;
+                ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
+                s_bClearBSSID_SCAN(pDevice);
+
+                if (netif_queue_stopped(pDevice->dev)){
+                    netif_wake_queue(pDevice->dev);
+                }
+
+	//2007-0115-07<Add>by MikeLiu
+	     #ifdef TxInSleep
+		 if(pDevice->IsTxDataTrigger != FALSE)   {    //TxDataTimer is not triggered at the first time
+                     // printk("Re-initial TxDataTimer****\n");
+		    del_timer(&pDevice->sTimerTxData);
+                      init_timer(&pDevice->sTimerTxData);
+                      pDevice->sTimerTxData.data = (ULONG)pDevice;
+                      pDevice->sTimerTxData.function = (TimerFunction)BSSvSecondTxData;
+                      pDevice->sTimerTxData.expires = RUN_AT(10*HZ);      //10s callback
+                      pDevice->fTxDataInSleep = FALSE;
+                      pDevice->nTxDataTimeCout = 0;
+		 }
+		 else {
+		   // printk("mike:-->First time triger TimerTxData InSleep\n");
+		 }
+		pDevice->IsTxDataTrigger = TRUE;
+                add_timer(&pDevice->sTimerTxData);
+             #endif
+
+            }
+	   else if(pMgmt->eCurrState < WMAC_STATE_ASSOCPENDING) {
+               printk("WLAN_ASSOCIATE_WAIT:Association Fail???\n");
+	   }
+	   else  if(pDevice->byLinkWaitCount <= 4){    //mike add:wait another 2 sec if associated_frame delay!
+                pDevice->byLinkWaitCount ++;
+	       printk("WLAN_ASSOCIATE_WAIT:wait %d times!!\n",pDevice->byLinkWaitCount);
+	       spin_unlock_irq(&pDevice->lock);
+	       vCommandTimerWait((HANDLE)pDevice, ASSOCIATE_TIMEOUT/2);
+	       return;
+	   }
+	          pDevice->byLinkWaitCount = 0;
+		#if 0
+                     #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+                    // if(pDevice->bWPASuppWextEnabled == TRUE)
+                        {
+                  	union iwreq_data  wrqu;
+                  	memset(&wrqu, 0, sizeof (wrqu));
+                          wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+                  	printk("wireless_send_event--->SIOCGIWAP(disassociated:ASSOCIATE_WAIT_timeout)\n");
+                  	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
+                       }
+                    #endif
+		#endif
+
+            s_bCommandComplete(pDevice);
+            break;
+
+        case WLAN_CMD_AP_MODE_START :
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_AP_MODE_START\n");
+
+            if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
+                del_timer(&pMgmt->sTimerSecondCallback);
+                pMgmt->eCurrState = WMAC_STATE_IDLE;
+                pMgmt->eCurrMode = WMAC_MODE_STANDBY;
+                pDevice->bLinkPass = FALSE;
+                ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
+                if (pDevice->bEnableHostWEP == TRUE)
+                    BSSvClearNodeDBTable(pDevice, 1);
+                else
+                    BSSvClearNodeDBTable(pDevice, 0);
+                pDevice->uAssocCount = 0;
+                pMgmt->eCurrState = WMAC_STATE_IDLE;
+                pDevice->bFixRate = FALSE;
+
+                vMgrCreateOwnIBSS((HANDLE)pDevice, &Status);
+                if (Status != CMD_STATUS_SUCCESS){
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " vMgrCreateOwnIBSS fail ! \n");
+                };
+                // alway turn off unicast bit
+                MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_UNICAST);
+                pDevice->byRxMode &= ~RCR_UNICAST;
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wcmd: rx_mode = %x\n", pDevice->byRxMode );
+                BSSvAddMulticastNode(pDevice);
+                if (netif_queue_stopped(pDevice->dev)){
+                    netif_wake_queue(pDevice->dev);
+                }
+                pDevice->bLinkPass = TRUE;
+                ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_INTER);
+                add_timer(&pMgmt->sTimerSecondCallback);
+            }
+            s_bCommandComplete(pDevice);
+            break;
+
+        case WLAN_CMD_TX_PSPACKET_START :
+            // DTIM Multicast tx
+            if (pMgmt->sNodeDBTable[0].bRxPSPoll) {
+                while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[0].sTxPSQueue)) != NULL) {
+                    if (skb_queue_empty(&pMgmt->sNodeDBTable[0].sTxPSQueue)) {
+                        pMgmt->abyPSTxMap[0] &= ~byMask[0];
+                        pDevice->bMoreData = FALSE;
+                    }
+                    else {
+                        pDevice->bMoreData = TRUE;
+                    }
+
+                    if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0) {
+                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Multicast ps tx fail \n");
+                    }
+
+                    pMgmt->sNodeDBTable[0].wEnQueueCnt--;
+                }
+            };
+
+            // PS nodes tx
+            for (ii = 1; ii < (MAX_NODE_NUM + 1); ii++) {
+                if (pMgmt->sNodeDBTable[ii].bActive &&
+                    pMgmt->sNodeDBTable[ii].bRxPSPoll) {
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Index=%d Enqueu Cnt= %d\n",
+                               ii, pMgmt->sNodeDBTable[ii].wEnQueueCnt);
+                    while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) != NULL) {
+                        if (skb_queue_empty(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) {
+                            // clear tx map
+                            pMgmt->abyPSTxMap[pMgmt->sNodeDBTable[ii].wAID >> 3] &=
+                                    ~byMask[pMgmt->sNodeDBTable[ii].wAID & 7];
+                            pDevice->bMoreData = FALSE;
+                        }
+                        else {
+                            pDevice->bMoreData = TRUE;
+                        }
+
+                        if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb) != 0) {
+                            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "sta ps tx fail \n");
+                        }
+
+                        pMgmt->sNodeDBTable[ii].wEnQueueCnt--;
+                        // check if sta ps enable, wait next pspoll
+                        // if sta ps disable, send all pending buffers.
+                        if (pMgmt->sNodeDBTable[ii].bPSEnable)
+                            break;
+                    }
+                    if (skb_queue_empty(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) {
+                        // clear tx map
+                        pMgmt->abyPSTxMap[pMgmt->sNodeDBTable[ii].wAID >> 3] &=
+                                    ~byMask[pMgmt->sNodeDBTable[ii].wAID & 7];
+                        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Index=%d PS queue clear \n", ii);
+                    }
+                    pMgmt->sNodeDBTable[ii].bRxPSPoll = FALSE;
+                }
+            }
+
+            s_bCommandComplete(pDevice);
+            break;
+
+        case WLAN_CMD_RADIO_START:
+
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState == WLAN_CMD_RADIO_START\n");
+       //     if (pDevice->bRadioCmd == TRUE)
+       //         CARDbRadioPowerOn(pDevice);
+       //     else
+       //         CARDbRadioPowerOff(pDevice);
+       //2008-09-09<Add> BY Mike:Hot Key for Radio On/Off
+       {
+        NTSTATUS        ntStatus = STATUS_SUCCESS;
+        BYTE            byTmp;
+
+        ntStatus = CONTROLnsRequestIn(pDevice,
+                                    MESSAGE_TYPE_READ,
+                                    MAC_REG_GPIOCTL1,
+                                    MESSAGE_REQUEST_MACREG,
+                                    1,
+                                    &byTmp);
+
+        if ( ntStatus != STATUS_SUCCESS ) {
+                s_bCommandComplete(pDevice);
+                spin_unlock_irq(&pDevice->lock);
+                return;
+        }
+        if ( (byTmp & GPIO3_DATA) == 0 ) {
+	    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_OFF........................\n");
+                // Old commands are useless.
+                // empty command Q
+	       pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
+                pDevice->uCmdDequeueIdx = 0;
+                pDevice->uCmdEnqueueIdx = 0;
+                //0415pDevice->bCmdRunning = FALSE;
+                pDevice->bCmdClear = TRUE;
+                pDevice->bStopTx0Pkt = FALSE;
+                pDevice->bStopDataPkt = TRUE;
+
+                pDevice->byKeyIndex = 0;
+                pDevice->bTransmitKey = FALSE;
+	    spin_unlock_irq(&pDevice->lock);
+	    KeyvInitTable(pDevice,&pDevice->sKey);
+	    spin_lock_irq(&pDevice->lock);
+	       pMgmt->byCSSPK = KEY_CTL_NONE;
+                pMgmt->byCSSGK = KEY_CTL_NONE;
+
+	  if (pDevice->bLinkPass == TRUE) {
+                // reason = 8 : disassoc because sta has left
+                       vMgrDisassocBeginSta((HANDLE)pDevice, pMgmt, pMgmt->abyCurrBSSID, (8), &Status);
+                       pDevice->bLinkPass = FALSE;
+                // unlock command busy
+                        pMgmt->eCurrState = WMAC_STATE_IDLE;
+                        pMgmt->sNodeDBTable[0].bActive = FALSE;
+                     #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+                    // if(pDevice->bWPASuppWextEnabled == TRUE)
+                        {
+                  	union iwreq_data  wrqu;
+                  	memset(&wrqu, 0, sizeof (wrqu));
+                          wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+                  	PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated)\n");
+                  	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
+                       }
+                    #endif
+	  	}
+	       #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+	               pDevice->bwextstep0 = FALSE;
+                        pDevice->bwextstep1 = FALSE;
+                        pDevice->bwextstep2 = FALSE;
+                        pDevice->bwextstep3 = FALSE;
+		      pDevice->bWPASuppWextEnabled = FALSE;
+		#endif
+	                  //clear current SSID
+                  pItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
+                  pItemSSID->len = 0;
+                  memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
+                //clear dessire SSID
+                pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
+                pItemSSID->len = 0;
+                memset(pItemSSID->abySSID, 0, WLAN_SSID_MAXLEN);
+
+	    netif_stop_queue(pDevice->dev);
+	    CARDbRadioPowerOff(pDevice);
+             MACvRegBitsOn(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);
+	    ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_OFF);
+	    pDevice->bHWRadioOff = TRUE;
+        } else {
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" WLAN_CMD_RADIO_START_ON........................\n");
+            pDevice->bHWRadioOff = FALSE;
+                CARDbRadioPowerOn(pDevice);
+            MACvRegBitsOff(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);
+            ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_ON);
+        }
+      }
+
+            s_bCommandComplete(pDevice);
+            break;
+
+
+        case WLAN_CMD_CHANGE_BBSENSITIVITY_START:
+
+            pDevice->bStopDataPkt = TRUE;
+            pDevice->byBBVGACurrent = pDevice->byBBVGANew;
+            BBvSetVGAGainOffset(pDevice, pDevice->byBBVGACurrent);
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change sensitivity pDevice->byBBVGACurrent = %x\n", pDevice->byBBVGACurrent);
+            pDevice->bStopDataPkt = FALSE;
+            s_bCommandComplete(pDevice);
+            break;
+
+        case WLAN_CMD_TBTT_WAKEUP_START:
+            PSbIsNextTBTTWakeUp(pDevice);
+            s_bCommandComplete(pDevice);
+            break;
+
+        case WLAN_CMD_BECON_SEND_START:
+            bMgrPrepareBeaconToSend(pDevice, pMgmt);
+            s_bCommandComplete(pDevice);
+            break;
+
+        case WLAN_CMD_SETPOWER_START:
+
+            RFbSetPower(pDevice, pDevice->wCurrentRate, pMgmt->uCurrChannel);
+
+            s_bCommandComplete(pDevice);
+            break;
+
+        case WLAN_CMD_CHANGE_ANTENNA_START:
+            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Change from Antenna%d to", (int)pDevice->dwRxAntennaSel);
+            if ( pDevice->dwRxAntennaSel == 0) {
+                pDevice->dwRxAntennaSel=1;
+                if (pDevice->bTxRxAntInv == TRUE)
+                    BBvSetAntennaMode(pDevice, ANT_RXA);
+                else
+                    BBvSetAntennaMode(pDevice, ANT_RXB);
+            } else {
+                pDevice->dwRxAntennaSel=0;
+                if (pDevice->bTxRxAntInv == TRUE)
+                    BBvSetAntennaMode(pDevice, ANT_RXB);
+                else
+                    BBvSetAntennaMode(pDevice, ANT_RXA);
+            }
+            s_bCommandComplete(pDevice);
+            break;
+
+        case WLAN_CMD_REMOVE_ALLKEY_START:
+            KeybRemoveAllKey(pDevice, &(pDevice->sKey), pDevice->abyBSSID);
+            s_bCommandComplete(pDevice);
+            break;
+
+
+        case WLAN_CMD_MAC_DISPOWERSAVING_START:
+            ControlvReadByte (pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_PSCTL, &byData);
+            if ( (byData & PSCTL_PS) != 0 ) {
+                // disable power saving hw function
+                CONTROLnsRequestOut(pDevice,
+                                MESSAGE_TYPE_DISABLE_PS,
+                                0,
+                                0,
+                                0,
+                                NULL
+                                );
+            }
+            s_bCommandComplete(pDevice);
+            break;
+
+        case WLAN_CMD_11H_CHSW_START:
+            CARDbSetMediaChannel(pDevice, pDevice->byNewChannel);
+            pDevice->bChannelSwitch = FALSE;
+            pMgmt->uCurrChannel = pDevice->byNewChannel;
+            pDevice->bStopDataPkt = FALSE;
+            s_bCommandComplete(pDevice);
+            break;
+
+        default:
+            s_bCommandComplete(pDevice);
+            break;
+    } //switch
+
+    spin_unlock_irq(&pDevice->lock);
+    return;
+}
+
+
+static
+BOOL
+s_bCommandComplete (
+    PSDevice pDevice
+    )
+{
+    PWLAN_IE_SSID pSSID;
+    BOOL          bRadioCmd = FALSE;
+    //WORD          wDeAuthenReason = 0;
+    BOOL          bForceSCAN = TRUE;
+    PSMgmtObject  pMgmt = &(pDevice->sMgmtObj);
+
+
+    pDevice->eCommandState = WLAN_CMD_IDLE;
+    if (pDevice->cbFreeCmdQueue == CMD_Q_SIZE) {
+        //Command Queue Empty
+        pDevice->bCmdRunning = FALSE;
+        return TRUE;
+    }
+    else {
+        pDevice->eCommand = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].eCmd;
+        pSSID = (PWLAN_IE_SSID)pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].abyCmdDesireSSID;
+        bRadioCmd = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].bRadioCmd;
+        bForceSCAN = pDevice->eCmdQueue[pDevice->uCmdDequeueIdx].bForceSCAN;
+        ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdDequeueIdx, CMD_Q_SIZE);
+        pDevice->cbFreeCmdQueue++;
+        pDevice->bCmdRunning = TRUE;
+        switch ( pDevice->eCommand ) {
+            case WLAN_CMD_BSSID_SCAN:
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_BSSID_SCAN\n");
+                pDevice->eCommandState = WLAN_CMD_SCAN_START;
+                pMgmt->uScanChannel = 0;
+                if (pSSID->len != 0) {
+                    MEMvCopy(pMgmt->abyScanSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+                } else {
+                    memset(pMgmt->abyScanSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+                }
+/*
+                if ((bForceSCAN == FALSE) && (pDevice->bLinkPass == TRUE)) {
+                    if ((pSSID->len == ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->len) &&
+                        (MEMEqualMemory(pSSID->abySSID, ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->abySSID, pSSID->len))) {
+                        pDevice->eCommandState = WLAN_CMD_IDLE;
+                    }
+                }
+*/
+                break;
+            case WLAN_CMD_SSID:
+                pDevice->eCommandState = WLAN_CMD_SSID_START;
+                if (pSSID->len > WLAN_SSID_MAXLEN)
+                    pSSID->len = WLAN_SSID_MAXLEN;
+                if (pSSID->len != 0)
+                    MEMvCopy(pMgmt->abyDesireSSID, pSSID, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"eCommandState= WLAN_CMD_SSID_START\n");
+                break;
+            case WLAN_CMD_DISASSOCIATE:
+                pDevice->eCommandState = WLAN_CMD_DISASSOCIATE_START;
+                break;
+            case WLAN_CMD_RX_PSPOLL:
+                pDevice->eCommandState = WLAN_CMD_TX_PSPACKET_START;
+                break;
+            case WLAN_CMD_RUN_AP:
+                pDevice->eCommandState = WLAN_CMD_AP_MODE_START;
+                break;
+            case WLAN_CMD_RADIO:
+                pDevice->eCommandState = WLAN_CMD_RADIO_START;
+                pDevice->bRadioCmd = bRadioCmd;
+                break;
+            case WLAN_CMD_CHANGE_BBSENSITIVITY:
+                pDevice->eCommandState = WLAN_CMD_CHANGE_BBSENSITIVITY_START;
+                break;
+
+            case WLAN_CMD_TBTT_WAKEUP:
+                pDevice->eCommandState = WLAN_CMD_TBTT_WAKEUP_START;
+                break;
+
+            case WLAN_CMD_BECON_SEND:
+                pDevice->eCommandState = WLAN_CMD_BECON_SEND_START;
+                break;
+
+            case WLAN_CMD_SETPOWER:
+                pDevice->eCommandState = WLAN_CMD_SETPOWER_START;
+                break;
+
+            case WLAN_CMD_CHANGE_ANTENNA:
+                pDevice->eCommandState = WLAN_CMD_CHANGE_ANTENNA_START;
+                break;
+
+            case WLAN_CMD_REMOVE_ALLKEY:
+                pDevice->eCommandState = WLAN_CMD_REMOVE_ALLKEY_START;
+                break;
+
+            case WLAN_CMD_MAC_DISPOWERSAVING:
+                pDevice->eCommandState = WLAN_CMD_MAC_DISPOWERSAVING_START;
+                break;
+
+            case WLAN_CMD_11H_CHSW:
+                pDevice->eCommandState = WLAN_CMD_11H_CHSW_START;
+                break;
+
+            default:
+                break;
+
+        }
+
+        vCommandTimerWait((HANDLE)pDevice, 0);
+    }
+
+    return TRUE;
+}
+
+BOOL bScheduleCommand (
+    IN HANDLE hDeviceContext,
+    IN CMD_CODE    eCommand,
+    IN PBYTE       pbyItem0
+    )
+{
+    PSDevice        pDevice = (PSDevice)hDeviceContext;
+
+
+    if (pDevice->cbFreeCmdQueue == 0) {
+        return (FALSE);
+    }
+    pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].eCmd = eCommand;
+    pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = TRUE;
+    memset(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID, 0 , WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+    if (pbyItem0 != NULL) {
+        switch (eCommand) {
+            case WLAN_CMD_BSSID_SCAN:
+                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bForceSCAN = FALSE;
+                MEMvCopy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
+                         pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+                break;
+
+            case WLAN_CMD_SSID:
+                MEMvCopy(pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].abyCmdDesireSSID,
+                         pbyItem0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
+                break;
+
+            case WLAN_CMD_DISASSOCIATE:
+                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bNeedRadioOFF = *((PBOOL)pbyItem0);
+                break;
+/*
+            case WLAN_CMD_DEAUTH:
+                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].wDeAuthenReason = *((PWORD)pbyItem0);
+                break;
+*/
+
+            case WLAN_CMD_RADIO:
+                pDevice->eCmdQueue[pDevice->uCmdEnqueueIdx].bRadioCmd = *((PBOOL)pbyItem0);
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    ADD_ONE_WITH_WRAP_AROUND(pDevice->uCmdEnqueueIdx, CMD_Q_SIZE);
+    pDevice->cbFreeCmdQueue--;
+
+    if (pDevice->bCmdRunning == FALSE) {
+        s_bCommandComplete(pDevice);
+    }
+    else {
+    }
+    return (TRUE);
+
+}
+
+/*
+ * Description:
+ *      Clear BSSID_SCAN cmd in CMD Queue
+ *
+ * Parameters:
+ *  In:
+ *      hDeviceContext  - Pointer to the adapter
+ *      eCommand        - Command
+ *  Out:
+ *      none
+ *
+ * Return Value: TRUE if success; otherwise FALSE
+ *
+ */
+static
+BOOL s_bClearBSSID_SCAN (
+    IN HANDLE hDeviceContext
+    )
+{
+    PSDevice        pDevice = (PSDevice)hDeviceContext;
+    UINT            uCmdDequeueIdx = pDevice->uCmdDequeueIdx;
+    UINT            ii;
+
+    if ((pDevice->cbFreeCmdQueue < CMD_Q_SIZE) && (uCmdDequeueIdx != pDevice->uCmdEnqueueIdx)) {
+        for (ii = 0; ii < (CMD_Q_SIZE - pDevice->cbFreeCmdQueue); ii ++) {
+            if (pDevice->eCmdQueue[uCmdDequeueIdx].eCmd == WLAN_CMD_BSSID_SCAN)
+                pDevice->eCmdQueue[uCmdDequeueIdx].eCmd = WLAN_CMD_IDLE;
+            ADD_ONE_WITH_WRAP_AROUND(uCmdDequeueIdx, CMD_Q_SIZE);
+            if (uCmdDequeueIdx == pDevice->uCmdEnqueueIdx)
+                break;
+        }
+    }
+    return TRUE;
+}
+
+
+//mike add:reset command timer
+VOID
+vResetCommandTimer(
+    IN HANDLE      hDeviceContext
+    )
+{
+  PSDevice        pDevice = (PSDevice)hDeviceContext;
+
+  //delete timer
+      del_timer(&pDevice->sTimerCommand);
+  //init timer
+      init_timer(&pDevice->sTimerCommand);
+    pDevice->sTimerCommand.data = (ULONG)pDevice;
+    pDevice->sTimerCommand.function = (TimerFunction)vRunCommand;
+    pDevice->sTimerCommand.expires = RUN_AT(HZ);
+    pDevice->cbFreeCmdQueue = CMD_Q_SIZE;
+    pDevice->uCmdDequeueIdx = 0;
+    pDevice->uCmdEnqueueIdx = 0;
+    pDevice->eCommandState = WLAN_CMD_IDLE;
+    pDevice->bCmdRunning = FALSE;
+    pDevice->bCmdClear = FALSE;
+}
+
+//2007-0115-08<Add>by MikeLiu
+#ifdef TxInSleep
+VOID
+BSSvSecondTxData(
+    IN  HANDLE      hDeviceContext
+    )
+{
+  PSDevice        pDevice = (PSDevice)hDeviceContext;
+  PSMgmtObject  pMgmt = &(pDevice->sMgmtObj);
+
+  pDevice->nTxDataTimeCout++;
+
+  if(pDevice->nTxDataTimeCout<4)     //don't tx data if timer less than 40s
+    {
+     // printk("mike:%s-->no data Tx not exceed the desired Time as %d\n",__FUNCTION__,
+	//  	(int)pDevice->nTxDataTimeCout);
+     pDevice->sTimerTxData.expires = RUN_AT(10*HZ);      //10s callback
+     add_timer(&pDevice->sTimerTxData);
+      return;
+    }
+
+  spin_lock_irq(&pDevice->lock);
+  //is wap_supplicant running sucessful OR only open && sharekey mode!
+  #if 1
+  if(((pDevice->bLinkPass ==TRUE)&&(pMgmt->eAuthenMode < WMAC_AUTH_WPA)) ||  //open && sharekey linking
+      (pDevice->fWPA_Authened == TRUE)) {   //wpa linking
+ #else
+  if(pDevice->bLinkPass ==TRUE) {
+ #endif
+        //   printk("mike:%s-->InSleep Tx Data Procedure\n",__FUNCTION__);
+	  pDevice->fTxDataInSleep = TRUE;
+	  PSbSendNullPacket(pDevice);      //send null packet
+	  pDevice->fTxDataInSleep = FALSE;
+  	}
+  spin_unlock_irq(&pDevice->lock);
+
+  pDevice->sTimerTxData.expires = RUN_AT(10*HZ);      //10s callback
+  add_timer(&pDevice->sTimerTxData);
+  return;
+}
+#endif
+
