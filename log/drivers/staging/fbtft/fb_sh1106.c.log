commit c440eee1a7a1d0f2d5fc2ee6049e4a05da540f01
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Wed Jan 16 23:00:50 2019 +0530

    Staging: fbtft: Switch to the gpio descriptor interface
    
    This switches the fbtft driver to use GPIO descriptors
    rather than numerical gpios:
    
    Utilize the GPIO library's intrinsic handling of OF GPIOs
    and polarity. If the line is flagged active low, gpiolib
    will deal with this.
    
    Remove gpios from platform device structure. Neither assign
    statically numbers to gpios in platform device nor allow
    gpios to be parsed as module parameters.
    
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/fbtft/fb_sh1106.c b/drivers/staging/fbtft/fb_sh1106.c
index 00096f8d249a..6f7249493ea3 100644
--- a/drivers/staging/fbtft/fb_sh1106.c
+++ b/drivers/staging/fbtft/fb_sh1106.c
@@ -9,7 +9,7 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/delay.h>
 
 #include "fbtft.h"

commit 1315e8bad80c02a630e4f20e1518b21c3adef4d6
Author: Leonardo Brás <leobras.c@gmail.com>
Date:   Tue Aug 7 21:29:18 2018 -0300

    staging: fbtft: Erases some repetitive usage of function name - Style
    
    Changes this functions to avoid using "blank" on debug twice. Improves log readability.
    
    Signed-off-by: Leonardo Brás <leobras.c@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/fbtft/fb_sh1106.c b/drivers/staging/fbtft/fb_sh1106.c
index 3fc18c0a6f11..00096f8d249a 100644
--- a/drivers/staging/fbtft/fb_sh1106.c
+++ b/drivers/staging/fbtft/fb_sh1106.c
@@ -89,7 +89,7 @@ static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
 
 static int blank(struct fbtft_par *par, bool on)
 {
-	fbtft_par_dbg(DEBUG_BLANK, par, "%s(blank=%s)\n",
+	fbtft_par_dbg(DEBUG_BLANK, par, "(%s=%s)\n",
 		      __func__, on ? "true" : "false");
 
 	write_reg(par, on ? 0xAE : 0xAF);

commit 78c00ccc52619704a6ad8c1d4587b6bb2bfa341d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 11 11:08:55 2018 +0100

    staging: fbtft: remove redundant license text
    
    Now that the SPDX tag is in all fbtft files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/fbtft/fb_sh1106.c b/drivers/staging/fbtft/fb_sh1106.c
index a1d4545b8539..3fc18c0a6f11 100644
--- a/drivers/staging/fbtft/fb_sh1106.c
+++ b/drivers/staging/fbtft/fb_sh1106.c
@@ -4,16 +4,6 @@
  * Based on the SSD1306 driver by Noralf Tronnes
  *
  * Copyright (C) 2017 Heiner Kallweit
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/module.h>

commit 783de57c52874b0a7309a81662f1335c43134d3b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 11 11:08:54 2018 +0100

    staging: fbtft: add SPDX identifiers
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the all of the staging fbtft drivers to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/fbtft/fb_sh1106.c b/drivers/staging/fbtft/fb_sh1106.c
index 89c27a440305..a1d4545b8539 100644
--- a/drivers/staging/fbtft/fb_sh1106.c
+++ b/drivers/staging/fbtft/fb_sh1106.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * FB driver for the SH1106 OLED Controller
  * Based on the SSD1306 driver by Noralf Tronnes

commit 74ec0a0e373bfbf107f1eaba7eec8bbaf4e1d021
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Mar 2 22:20:42 2017 +0100

    staging: fbtft: fb_sh1106: use new helper helper fbtft_write_buf_dc
    
    Make use of new helper fbtft_write_buf_dc.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/fbtft/fb_sh1106.c b/drivers/staging/fbtft/fb_sh1106.c
index 124a4ca9051b..89c27a440305 100644
--- a/drivers/staging/fbtft/fb_sh1106.c
+++ b/drivers/staging/fbtft/fb_sh1106.c
@@ -140,13 +140,9 @@ static int write_vmem(struct fbtft_par *par, size_t offset, size_t len)
 					buf[x] |= BIT(i);
 
 		/* Write data */
-		gpio_set_value(par->gpio.dc, 1);
-		ret = par->fbtftops.write(par, buf, xres);
-		if (ret < 0) {
-			dev_err(par->info->device,
-				"write failed and returned: %d\n", ret);
+		ret = fbtft_write_buf_dc(par, buf, xres, 1);
+		if (ret < 0)
 			return ret;
-		}
 	}
 
 	return 0;
@@ -155,7 +151,7 @@ static int write_vmem(struct fbtft_par *par, size_t offset, size_t len)
 static void write_register(struct fbtft_par *par, int len, ...)
 {
 	va_list args;
-	int i, ret;
+	int i;
 
 	va_start(args, len);
 
@@ -163,12 +159,7 @@ static void write_register(struct fbtft_par *par, int len, ...)
 		par->buf[i] = va_arg(args, unsigned int);
 
 	/* keep DC low for all command bytes to transfer */
-	gpio_set_value(par->gpio.dc, 0);
-
-	ret = par->fbtftops.write(par, par->buf, len);
-	if (ret < 0)
-		dev_err(par->info->device,
-			"write() failed and returned %d\n", ret);
+	fbtft_write_buf_dc(par, par->buf, len, 0);
 
 	va_end(args);
 }

commit 82472b86186194458c9549516e53becbc33e941d
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Mar 2 21:03:44 2017 +0100

    staging: fbtft: fb_sh1106: use own implementation of write_register
    
    The default implementation of write_register keeps DC low for the first
    byte only. SH1106 requires DC to be low for all bytes of a multi-byte
    command. To deal with this limitation we currently use a separate call
    to write_reg for each single command byte what is not really efficient.
    
    Therefore override the default implementation of write_register with an
    own one which keeps DC low for all bytes.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/fbtft/fb_sh1106.c b/drivers/staging/fbtft/fb_sh1106.c
index b7896e552f7c..124a4ca9051b 100644
--- a/drivers/staging/fbtft/fb_sh1106.c
+++ b/drivers/staging/fbtft/fb_sh1106.c
@@ -27,17 +27,6 @@
 #define WIDTH		128
 #define HEIGHT		64
 
-/*
- * write_reg() caveat:
- *
- * This doesn't work because D/C has to be LOW for both values:
- * write_reg(par, val1, val2);
- *
- * Do it like this:
- * write_reg(par, val1);
- * write_reg(par, val2);
- */
-
 /* Init sequence based on the Adafruit SSD1306 Arduino library */
 static int init_display(struct fbtft_par *par)
 {
@@ -59,16 +48,13 @@ static int init_display(struct fbtft_par *par)
 	write_reg(par, 0xAE);
 
 	/* Set Display Clock Divide Ratio/ Oscillator Frequency */
-	write_reg(par, 0xD5);
-	write_reg(par, 0x80);
+	write_reg(par, 0xD5, 0x80);
 
 	/* Set Multiplex Ratio */
-	write_reg(par, 0xA8);
-	write_reg(par, par->info->var.yres - 1);
+	write_reg(par, 0xA8, par->info->var.yres - 1);
 
 	/* Set Display Offset */
-	write_reg(par, 0xD3);
-	write_reg(par, 0x0);
+	write_reg(par, 0xD3, 0x00);
 
 	/* Set Display Start Line */
 	write_reg(par, 0x40 | 0x0);
@@ -82,24 +68,21 @@ static int init_display(struct fbtft_par *par)
 	write_reg(par, 0xC8);
 
 	/* Set COM Pins Hardware Configuration */
-	write_reg(par, 0xDA);
 	if (par->info->var.yres == 64)
 		/* A[4]=1b, Alternative COM pin configuration */
-		write_reg(par, 0x12);
+		write_reg(par, 0xDA, 0x12);
 	else if (par->info->var.yres == 48)
 		/* A[4]=1b, Alternative COM pin configuration */
-		write_reg(par, 0x12);
+		write_reg(par, 0xDA, 0x12);
 	else
 		/* A[4]=0b, Sequential COM pin configuration */
-		write_reg(par, 0x02);
+		write_reg(par, 0xDA, 0x02);
 
 	/* Set Pre-charge Period */
-	write_reg(par, 0xD9);
-	write_reg(par, 0xF1);
+	write_reg(par, 0xD9, 0xF1);
 
 	/* Set VCOMH Deselect Level */
-	write_reg(par, 0xDB);
-	write_reg(par, 0x40);
+	write_reg(par, 0xDB, 0x40);
 
 	/* Set Display ON */
 	write_reg(par, 0xAF);
@@ -130,8 +113,7 @@ static int set_gamma(struct fbtft_par *par, u32 *curves)
 	curves[0] &= 0xFF;
 
 	/* Set Contrast Control for BANK0 */
-	write_reg(par, 0x81);
-	write_reg(par, curves[0]);
+	write_reg(par, 0x81, curves[0]);
 
 	return 0;
 }
@@ -148,11 +130,8 @@ static int write_vmem(struct fbtft_par *par, size_t offset, size_t len)
 	page_end = DIV_ROUND_UP(offset + len, 8 * 2 * xres);
 
 	for (page = page_start; page < page_end; page++) {
-		/* set page */
-		write_reg(par, 0xb0 | page);
-		/* set column to 2 to compensate for vidmem width 132 */
-		write_reg(par, 0x00 | 2);
-		write_reg(par, 0x10 | 0);
+		/* set page and set column to 2 because of vidmem width 132 */
+		write_reg(par, 0xb0 | page, 0x00 | 2, 0x10 | 0);
 
 		memset(buf, 0, xres);
 		for (x = 0; x < xres; x++)
@@ -173,6 +152,27 @@ static int write_vmem(struct fbtft_par *par, size_t offset, size_t len)
 	return 0;
 }
 
+static void write_register(struct fbtft_par *par, int len, ...)
+{
+	va_list args;
+	int i, ret;
+
+	va_start(args, len);
+
+	for (i = 0; i < len; i++)
+		par->buf[i] = va_arg(args, unsigned int);
+
+	/* keep DC low for all command bytes to transfer */
+	gpio_set_value(par->gpio.dc, 0);
+
+	ret = par->fbtftops.write(par, par->buf, len);
+	if (ret < 0)
+		dev_err(par->info->device,
+			"write() failed and returned %d\n", ret);
+
+	va_end(args);
+}
+
 static struct fbtft_display display = {
 	.regwidth = 8,
 	.width = WIDTH,
@@ -184,6 +184,7 @@ static struct fbtft_display display = {
 	.gamma = "cd",
 	.fbtftops = {
 		.write_vmem = write_vmem,
+		.write_register = write_register,
 		.init_display = init_display,
 		.set_addr_win = set_addr_win,
 		.blank = blank,

commit 079306e979d7f8bb1081ce43c7fc1fa8c1d45d55
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Feb 28 08:10:38 2017 +0100

    staging: fbtft: add adriver for SH1106
    
    This patch adds support for the SH1106 OLED controller chip.
    
    It's similar to the SSD1306, however it supports only a subset of
    commands and the internal video memory has a different width.
    
    Major differences:
    - Internal video memory has a width of 132 pixels
    - Only a subset of commands is supported
    - Only page addressing mode is supported, no support for vertical and
      horizontal addressing
    - SPI frequency limited to 2 MHz according to the datasheet
    
    Successfully tested with a 1.3" OLED display with this chip and
    SPI interface.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/fbtft/fb_sh1106.c b/drivers/staging/fbtft/fb_sh1106.c
new file mode 100644
index 000000000000..b7896e552f7c
--- /dev/null
+++ b/drivers/staging/fbtft/fb_sh1106.c
@@ -0,0 +1,203 @@
+/*
+ * FB driver for the SH1106 OLED Controller
+ * Based on the SSD1306 driver by Noralf Tronnes
+ *
+ * Copyright (C) 2017 Heiner Kallweit
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+
+#include "fbtft.h"
+
+#define DRVNAME		"fb_sh1106"
+#define WIDTH		128
+#define HEIGHT		64
+
+/*
+ * write_reg() caveat:
+ *
+ * This doesn't work because D/C has to be LOW for both values:
+ * write_reg(par, val1, val2);
+ *
+ * Do it like this:
+ * write_reg(par, val1);
+ * write_reg(par, val2);
+ */
+
+/* Init sequence based on the Adafruit SSD1306 Arduino library */
+static int init_display(struct fbtft_par *par)
+{
+	if (!par->info->var.xres || par->info->var.xres > WIDTH ||
+	    !par->info->var.yres || par->info->var.yres > HEIGHT ||
+	    par->info->var.yres % 8) {
+		dev_err(par->info->device, "Invalid screen size\n");
+		return -EINVAL;
+	}
+
+	if (par->info->var.rotate) {
+		dev_err(par->info->device, "Display rotation not supported\n");
+		return -EINVAL;
+	}
+
+	par->fbtftops.reset(par);
+
+	/* Set Display OFF */
+	write_reg(par, 0xAE);
+
+	/* Set Display Clock Divide Ratio/ Oscillator Frequency */
+	write_reg(par, 0xD5);
+	write_reg(par, 0x80);
+
+	/* Set Multiplex Ratio */
+	write_reg(par, 0xA8);
+	write_reg(par, par->info->var.yres - 1);
+
+	/* Set Display Offset */
+	write_reg(par, 0xD3);
+	write_reg(par, 0x0);
+
+	/* Set Display Start Line */
+	write_reg(par, 0x40 | 0x0);
+
+	/* Set Segment Re-map */
+	/* column address 127 is mapped to SEG0 */
+	write_reg(par, 0xA0 | 0x1);
+
+	/* Set COM Output Scan Direction */
+	/* remapped mode. Scan from COM[N-1] to COM0 */
+	write_reg(par, 0xC8);
+
+	/* Set COM Pins Hardware Configuration */
+	write_reg(par, 0xDA);
+	if (par->info->var.yres == 64)
+		/* A[4]=1b, Alternative COM pin configuration */
+		write_reg(par, 0x12);
+	else if (par->info->var.yres == 48)
+		/* A[4]=1b, Alternative COM pin configuration */
+		write_reg(par, 0x12);
+	else
+		/* A[4]=0b, Sequential COM pin configuration */
+		write_reg(par, 0x02);
+
+	/* Set Pre-charge Period */
+	write_reg(par, 0xD9);
+	write_reg(par, 0xF1);
+
+	/* Set VCOMH Deselect Level */
+	write_reg(par, 0xDB);
+	write_reg(par, 0x40);
+
+	/* Set Display ON */
+	write_reg(par, 0xAF);
+
+	msleep(150);
+
+	return 0;
+}
+
+static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
+{
+}
+
+static int blank(struct fbtft_par *par, bool on)
+{
+	fbtft_par_dbg(DEBUG_BLANK, par, "%s(blank=%s)\n",
+		      __func__, on ? "true" : "false");
+
+	write_reg(par, on ? 0xAE : 0xAF);
+
+	return 0;
+}
+
+/* Gamma is used to control Contrast */
+static int set_gamma(struct fbtft_par *par, u32 *curves)
+{
+	/* apply mask */
+	curves[0] &= 0xFF;
+
+	/* Set Contrast Control for BANK0 */
+	write_reg(par, 0x81);
+	write_reg(par, curves[0]);
+
+	return 0;
+}
+
+static int write_vmem(struct fbtft_par *par, size_t offset, size_t len)
+{
+	u16 *vmem16 = (u16 *)par->info->screen_buffer;
+	u32 xres = par->info->var.xres;
+	int page, page_start, page_end, x, i, ret;
+	u8 *buf = par->txbuf.buf;
+
+	/* offset refers to vmem with 2 bytes element size */
+	page_start = offset / (8 * 2 * xres);
+	page_end = DIV_ROUND_UP(offset + len, 8 * 2 * xres);
+
+	for (page = page_start; page < page_end; page++) {
+		/* set page */
+		write_reg(par, 0xb0 | page);
+		/* set column to 2 to compensate for vidmem width 132 */
+		write_reg(par, 0x00 | 2);
+		write_reg(par, 0x10 | 0);
+
+		memset(buf, 0, xres);
+		for (x = 0; x < xres; x++)
+			for (i = 0; i < 8; i++)
+				if (vmem16[(page * 8 + i) * xres + x])
+					buf[x] |= BIT(i);
+
+		/* Write data */
+		gpio_set_value(par->gpio.dc, 1);
+		ret = par->fbtftops.write(par, buf, xres);
+		if (ret < 0) {
+			dev_err(par->info->device,
+				"write failed and returned: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static struct fbtft_display display = {
+	.regwidth = 8,
+	.width = WIDTH,
+	.height = HEIGHT,
+	.txbuflen = WIDTH,
+	.gamma_num = 1,
+	.gamma_len = 1,
+	/* set default contrast to 0xcd = 80% */
+	.gamma = "cd",
+	.fbtftops = {
+		.write_vmem = write_vmem,
+		.init_display = init_display,
+		.set_addr_win = set_addr_win,
+		.blank = blank,
+		.set_gamma = set_gamma,
+	},
+};
+
+FBTFT_REGISTER_DRIVER(DRVNAME, "sinowealth,sh1106", &display);
+
+MODULE_ALIAS("spi:" DRVNAME);
+MODULE_ALIAS("platform:" DRVNAME);
+MODULE_ALIAS("spi:sh1106");
+MODULE_ALIAS("platform:sh1106");
+
+MODULE_DESCRIPTION("SH1106 OLED Driver");
+MODULE_AUTHOR("Heiner Kallweit");
+MODULE_LICENSE("GPL");
