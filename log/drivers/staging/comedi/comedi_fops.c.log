commit c1e8d7c6a7a682e1405e3e242d32fc377fd196ff
Author: Michel Lespinasse <walken@google.com>
Date:   Mon Jun 8 21:33:54 2020 -0700

    mmap locking API: convert mmap_sem comments
    
    Convert comments that reference mmap_sem to reference mmap_lock instead.
    
    [akpm@linux-foundation.org: fix up linux-next leftovers]
    [akpm@linux-foundation.org: s/lockaphore/lock/, per Vlastimil]
    [akpm@linux-foundation.org: more linux-next fixups, per Michel]
    
    Signed-off-by: Michel Lespinasse <walken@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
    Reviewed-by: Daniel Jordan <daniel.m.jordan@oracle.com>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Hubbard <jhubbard@nvidia.com>
    Cc: Laurent Dufour <ldufour@linux.ibm.com>
    Cc: Liam Howlett <Liam.Howlett@oracle.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ying Han <yinghan@google.com>
    Link: http://lkml.kernel.org/r/20200520052908.204642-13-walken@google.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a56c8f74a27b..e85a99b68f31 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2325,7 +2325,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	int retval = 0;
 
 	/*
-	 * 'trylock' avoids circular dependency with current->mm->mmap_sem
+	 * 'trylock' avoids circular dependency with current->mm->mmap_lock
 	 * and down-reading &dev->attach_lock should normally succeed without
 	 * contention unless the device is in the process of being attached
 	 * or detached.

commit 2e63f6ce7ed2c4ff83ba30ad9ccad422289a6c63
Merge: ae03c53d005e bac42fb21259
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 3 15:55:45 2020 -0700

    Merge branch 'uaccess.comedi' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull comedi uaccess cleanups from Al Viro:
     "Comedi compat ioctls done saner - killing the single biggest pile of
      __get_user/__put_user outside of arch/* in the process"
    
    * 'uaccess.comedi' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      comedi: get rid of compat_alloc_user_space() mess in COMEDI_CMD{,TEST} compat
      comedi: do_cmd_ioctl(): lift copyin/copyout into the caller
      comedi: do_cmdtest_ioctl(): lift copyin/copyout into the caller
      comedi: lift copy_from_user() into callers of __comedi_get_user_cmd()
      comedi: get rid of compat_alloc_user_space() mess in COMEDI_INSNLIST compat
      comedi: get rid of compat_alloc_user_space() mess in COMEDI_INSN compat
      comedi: get rid of compat_alloc_user_space() mess in COMEDI_RANGEINFO compat
      comedi: get rid of compat_alloc_user_space() mess in COMEDI_CHANINFO compat
      comedi: get rid of indirection via translated_ioctl()
      comedi: move compat ioctl handling to native fops

commit bac42fb21259783cb748ae54227a5e755340a396
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Apr 26 09:27:23 2020 -0400

    comedi: get rid of compat_alloc_user_space() mess in COMEDI_CMD{,TEST} compat
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c40df64e3ec7..dd14c2935292 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2931,155 +2931,106 @@ static int compat_rangeinfo(struct file *file, unsigned long arg)
 }
 
 /* Copy 32-bit cmd structure to native cmd structure. */
-static int get_compat_cmd(struct comedi_cmd __user *cmd,
+static int get_compat_cmd(struct comedi_cmd *cmd,
 			  struct comedi32_cmd_struct __user *cmd32)
 {
-	int err;
-	union {
-		unsigned int uint;
-		compat_uptr_t uptr;
-	} temp;
-
-	/* Copy cmd structure. */
-	if (!access_ok(cmd32, sizeof(*cmd32)) ||
-	    !access_ok(cmd, sizeof(*cmd)))
+	struct comedi32_cmd_struct v32;
+
+	if (copy_from_user(&v32, cmd32, sizeof(v32)))
 		return -EFAULT;
 
-	err = 0;
-	err |= __get_user(temp.uint, &cmd32->subdev);
-	err |= __put_user(temp.uint, &cmd->subdev);
-	err |= __get_user(temp.uint, &cmd32->flags);
-	err |= __put_user(temp.uint, &cmd->flags);
-	err |= __get_user(temp.uint, &cmd32->start_src);
-	err |= __put_user(temp.uint, &cmd->start_src);
-	err |= __get_user(temp.uint, &cmd32->start_arg);
-	err |= __put_user(temp.uint, &cmd->start_arg);
-	err |= __get_user(temp.uint, &cmd32->scan_begin_src);
-	err |= __put_user(temp.uint, &cmd->scan_begin_src);
-	err |= __get_user(temp.uint, &cmd32->scan_begin_arg);
-	err |= __put_user(temp.uint, &cmd->scan_begin_arg);
-	err |= __get_user(temp.uint, &cmd32->convert_src);
-	err |= __put_user(temp.uint, &cmd->convert_src);
-	err |= __get_user(temp.uint, &cmd32->convert_arg);
-	err |= __put_user(temp.uint, &cmd->convert_arg);
-	err |= __get_user(temp.uint, &cmd32->scan_end_src);
-	err |= __put_user(temp.uint, &cmd->scan_end_src);
-	err |= __get_user(temp.uint, &cmd32->scan_end_arg);
-	err |= __put_user(temp.uint, &cmd->scan_end_arg);
-	err |= __get_user(temp.uint, &cmd32->stop_src);
-	err |= __put_user(temp.uint, &cmd->stop_src);
-	err |= __get_user(temp.uint, &cmd32->stop_arg);
-	err |= __put_user(temp.uint, &cmd->stop_arg);
-	err |= __get_user(temp.uptr, &cmd32->chanlist);
-	err |= __put_user((unsigned int __force *)compat_ptr(temp.uptr),
-			  &cmd->chanlist);
-	err |= __get_user(temp.uint, &cmd32->chanlist_len);
-	err |= __put_user(temp.uint, &cmd->chanlist_len);
-	err |= __get_user(temp.uptr, &cmd32->data);
-	err |= __put_user(compat_ptr(temp.uptr), &cmd->data);
-	err |= __get_user(temp.uint, &cmd32->data_len);
-	err |= __put_user(temp.uint, &cmd->data_len);
-	return err ? -EFAULT : 0;
+	cmd->subdev = v32.subdev;
+	cmd->flags = v32.flags;
+	cmd->start_src = v32.start_src;
+	cmd->start_arg = v32.start_arg;
+	cmd->scan_begin_src = v32.scan_begin_src;
+	cmd->scan_begin_arg = v32.scan_begin_arg;
+	cmd->convert_src = v32.convert_src;
+	cmd->convert_arg = v32.convert_arg;
+	cmd->scan_end_src = v32.scan_end_src;
+	cmd->scan_end_arg = v32.scan_end_arg;
+	cmd->stop_src = v32.stop_src;
+	cmd->stop_arg = v32.stop_arg;
+	cmd->chanlist = compat_ptr(v32.chanlist);
+	cmd->chanlist_len = v32.chanlist_len;
+	cmd->data = compat_ptr(v32.data);
+	cmd->data_len = v32.data_len;
+	return 0;
 }
 
 /* Copy native cmd structure to 32-bit cmd structure. */
 static int put_compat_cmd(struct comedi32_cmd_struct __user *cmd32,
-			  struct comedi_cmd __user *cmd)
-{
-	int err;
-	unsigned int temp;
-
-	/*
-	 * Copy back most of cmd structure.
-	 *
-	 * Assume the pointer values are already valid.
-	 * (Could use ptr_to_compat() to set them.)
-	 */
-	if (!access_ok(cmd, sizeof(*cmd)) ||
-	    !access_ok(cmd32, sizeof(*cmd32)))
-		return -EFAULT;
-
-	err = 0;
-	err |= __get_user(temp, &cmd->subdev);
-	err |= __put_user(temp, &cmd32->subdev);
-	err |= __get_user(temp, &cmd->flags);
-	err |= __put_user(temp, &cmd32->flags);
-	err |= __get_user(temp, &cmd->start_src);
-	err |= __put_user(temp, &cmd32->start_src);
-	err |= __get_user(temp, &cmd->start_arg);
-	err |= __put_user(temp, &cmd32->start_arg);
-	err |= __get_user(temp, &cmd->scan_begin_src);
-	err |= __put_user(temp, &cmd32->scan_begin_src);
-	err |= __get_user(temp, &cmd->scan_begin_arg);
-	err |= __put_user(temp, &cmd32->scan_begin_arg);
-	err |= __get_user(temp, &cmd->convert_src);
-	err |= __put_user(temp, &cmd32->convert_src);
-	err |= __get_user(temp, &cmd->convert_arg);
-	err |= __put_user(temp, &cmd32->convert_arg);
-	err |= __get_user(temp, &cmd->scan_end_src);
-	err |= __put_user(temp, &cmd32->scan_end_src);
-	err |= __get_user(temp, &cmd->scan_end_arg);
-	err |= __put_user(temp, &cmd32->scan_end_arg);
-	err |= __get_user(temp, &cmd->stop_src);
-	err |= __put_user(temp, &cmd32->stop_src);
-	err |= __get_user(temp, &cmd->stop_arg);
-	err |= __put_user(temp, &cmd32->stop_arg);
+			  struct comedi_cmd *cmd)
+{
+	struct comedi32_cmd_struct v32;
+
+	memset(&v32, 0, sizeof(v32));
+	v32.subdev = cmd->subdev;
+	v32.flags = cmd->flags;
+	v32.start_src = cmd->start_src;
+	v32.start_arg = cmd->start_arg;
+	v32.scan_begin_src = cmd->scan_begin_src;
+	v32.scan_begin_arg = cmd->scan_begin_arg;
+	v32.convert_src = cmd->convert_src;
+	v32.convert_arg = cmd->convert_arg;
+	v32.scan_end_src = cmd->scan_end_src;
+	v32.scan_end_arg = cmd->scan_end_arg;
+	v32.stop_src = cmd->stop_src;
+	v32.stop_arg = cmd->stop_arg;
 	/* Assume chanlist pointer is unchanged. */
-	err |= __get_user(temp, &cmd->chanlist_len);
-	err |= __put_user(temp, &cmd32->chanlist_len);
-	/* Assume data pointer is unchanged. */
-	err |= __get_user(temp, &cmd->data_len);
-	err |= __put_user(temp, &cmd32->data_len);
-	return err ? -EFAULT : 0;
+	v32.chanlist = ptr_to_compat(cmd->chanlist);
+	v32.chanlist_len = cmd->chanlist_len;
+	v32.data = ptr_to_compat(cmd->data);
+	v32.data_len = cmd->data_len;
+	return copy_to_user(cmd32, &v32, sizeof(v32));
 }
 
 /* Handle 32-bit COMEDI_CMD ioctl. */
 static int compat_cmd(struct file *file, unsigned long arg)
 {
-	struct comedi_cmd __user *cmd;
-	struct comedi32_cmd_struct __user *cmd32;
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
+	struct comedi_cmd cmd;
+	bool copy = false;
 	int rc, err;
 
-	cmd32 = compat_ptr(arg);
-	cmd = compat_alloc_user_space(sizeof(*cmd));
-
-	rc = get_compat_cmd(cmd, cmd32);
+	rc = get_compat_cmd(&cmd, compat_ptr(arg));
 	if (rc)
 		return rc;
 
-	rc = comedi_unlocked_ioctl(file, COMEDI_CMD, (unsigned long)cmd);
-	if (rc == -EAGAIN) {
+	mutex_lock(&dev->mutex);
+	rc = do_cmd_ioctl(dev, &cmd, &copy, file);
+	mutex_unlock(&dev->mutex);
+	if (copy) {
 		/* Special case: copy cmd back to user. */
-		err = put_compat_cmd(cmd32, cmd);
+		err = put_compat_cmd(compat_ptr(arg), &cmd);
 		if (err)
 			rc = err;
 	}
-
 	return rc;
 }
 
 /* Handle 32-bit COMEDI_CMDTEST ioctl. */
 static int compat_cmdtest(struct file *file, unsigned long arg)
 {
-	struct comedi_cmd __user *cmd;
-	struct comedi32_cmd_struct __user *cmd32;
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
+	struct comedi_cmd cmd;
+	bool copy = false;
 	int rc, err;
 
-	cmd32 = compat_ptr(arg);
-	cmd = compat_alloc_user_space(sizeof(*cmd));
-
-	rc = get_compat_cmd(cmd, cmd32);
+	rc = get_compat_cmd(&cmd, compat_ptr(arg));
 	if (rc)
 		return rc;
 
-	rc = comedi_unlocked_ioctl(file, COMEDI_CMDTEST, (unsigned long)cmd);
-	if (rc < 0)
-		return rc;
-
-	err = put_compat_cmd(cmd32, cmd);
-	if (err)
-		rc = err;
-
+	mutex_lock(&dev->mutex);
+	rc = do_cmdtest_ioctl(dev, &cmd, &copy, file);
+	mutex_unlock(&dev->mutex);
+	if (copy) {
+		err = put_compat_cmd(compat_ptr(arg), &cmd);
+		if (err)
+			rc = err;
+	}
 	return rc;
 }
 

commit 0a3ccc75a95ff682de9315dee7e55efde1d5e30c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Apr 26 09:01:49 2020 -0400

    comedi: do_cmd_ioctl(): lift copyin/copyout into the caller
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 74020fee0ae9..c40df64e3ec7 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1741,9 +1741,8 @@ static int __comedi_get_user_chanlist(struct comedi_device *dev,
  *	possibly modified comedi_cmd structure (when -EAGAIN returned)
  */
 static int do_cmd_ioctl(struct comedi_device *dev,
-			struct comedi_cmd __user *arg, void *file)
+			struct comedi_cmd *cmd, bool *copy, void *file)
 {
-	struct comedi_cmd cmd;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 	unsigned int __user *user_chanlist;
@@ -1751,20 +1750,15 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 
 	lockdep_assert_held(&dev->mutex);
 
-	if (copy_from_user(&cmd, arg, sizeof(cmd))) {
-		dev_dbg(dev->class_dev, "bad cmd address\n");
-		return -EFAULT;
-	}
-
-	/* get the user's cmd and do some simple validation */
-	ret = __comedi_get_user_cmd(dev, &cmd);
+	/* do some simple cmd validation */
+	ret = __comedi_get_user_cmd(dev, cmd);
 	if (ret)
 		return ret;
 
 	/* save user's chanlist pointer so it can be restored later */
-	user_chanlist = (unsigned int __user *)cmd.chanlist;
+	user_chanlist = (unsigned int __user *)cmd->chanlist;
 
-	s = &dev->subdevices[cmd.subdev];
+	s = &dev->subdevices[cmd->subdev];
 	async = s->async;
 
 	/* are we locked? (ioctl lock) */
@@ -1780,13 +1774,13 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	}
 
 	/* make sure channel/gain list isn't too short */
-	if (cmd.chanlist_len < 1) {
+	if (cmd->chanlist_len < 1) {
 		dev_dbg(dev->class_dev, "channel/gain list too short %u < 1\n",
-			cmd.chanlist_len);
+			cmd->chanlist_len);
 		return -EINVAL;
 	}
 
-	async->cmd = cmd;
+	async->cmd = *cmd;
 	async->cmd.data = NULL;
 
 	/* load channel/gain list */
@@ -1798,15 +1792,11 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 
 	if (async->cmd.flags & CMDF_BOGUS || ret) {
 		dev_dbg(dev->class_dev, "test returned %d\n", ret);
-		cmd = async->cmd;
+		*cmd = async->cmd;
 		/* restore chanlist pointer before copying back */
-		cmd.chanlist = (unsigned int __force *)user_chanlist;
-		cmd.data = NULL;
-		if (copy_to_user(arg, &cmd, sizeof(cmd))) {
-			dev_dbg(dev->class_dev, "fault writing cmd\n");
-			ret = -EFAULT;
-			goto cleanup;
-		}
+		cmd->chanlist = (unsigned int __force *)user_chanlist;
+		cmd->data = NULL;
+		*copy = true;
 		ret = -EAGAIN;
 		goto cleanup;
 	}
@@ -2207,9 +2197,19 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 	case COMEDI_CANCEL:
 		rc = do_cancel_ioctl(dev, arg, file);
 		break;
-	case COMEDI_CMD:
-		rc = do_cmd_ioctl(dev, (struct comedi_cmd __user *)arg, file);
+	case COMEDI_CMD: {
+		struct comedi_cmd cmd;
+		bool copy = false;
+
+		if (copy_from_user(&cmd, (void __user *)arg, sizeof(cmd))) {
+			rc = -EFAULT;
+			break;
+		}
+		rc = do_cmd_ioctl(dev, &cmd, &copy, file);
+		if (copy && copy_to_user((void __user *)arg, &cmd, sizeof(cmd)))
+			rc = -EFAULT;
 		break;
+	}
 	case COMEDI_CMDTEST: {
 		struct comedi_cmd cmd;
 		bool copy = false;

commit f0e4de5cd0bb99a82445c5a3a876f162052689f8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Apr 26 08:56:55 2020 -0400

    comedi: do_cmdtest_ioctl(): lift copyin/copyout into the caller
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c136cb2f676a..74020fee0ae9 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1856,49 +1856,39 @@ static int do_cmd_ioctl(struct comedi_device *dev,
  *	possibly modified comedi_cmd structure
  */
 static int do_cmdtest_ioctl(struct comedi_device *dev,
-			    struct comedi_cmd __user *arg, void *file)
+			    struct comedi_cmd *cmd, bool *copy, void *file)
 {
-	struct comedi_cmd cmd;
 	struct comedi_subdevice *s;
 	unsigned int __user *user_chanlist;
 	int ret;
 
 	lockdep_assert_held(&dev->mutex);
 
-	if (copy_from_user(&cmd, arg, sizeof(cmd))) {
-		dev_dbg(dev->class_dev, "bad cmd address\n");
-		return -EFAULT;
-	}
-
-	/* get the user's cmd and do some simple validation */
-	ret = __comedi_get_user_cmd(dev, &cmd);
+	/* do some simple cmd validation */
+	ret = __comedi_get_user_cmd(dev, cmd);
 	if (ret)
 		return ret;
 
 	/* save user's chanlist pointer so it can be restored later */
-	user_chanlist = (unsigned int __user *)cmd.chanlist;
+	user_chanlist = (unsigned int __user *)cmd->chanlist;
 
-	s = &dev->subdevices[cmd.subdev];
+	s = &dev->subdevices[cmd->subdev];
 
 	/* user_chanlist can be NULL for COMEDI_CMDTEST ioctl */
 	if (user_chanlist) {
 		/* load channel/gain list */
-		ret = __comedi_get_user_chanlist(dev, s, user_chanlist, &cmd);
+		ret = __comedi_get_user_chanlist(dev, s, user_chanlist, cmd);
 		if (ret)
 			return ret;
 	}
 
-	ret = s->do_cmdtest(dev, s, &cmd);
+	ret = s->do_cmdtest(dev, s, cmd);
 
-	kfree(cmd.chanlist);	/* free kernel copy of user chanlist */
+	kfree(cmd->chanlist);	/* free kernel copy of user chanlist */
 
 	/* restore chanlist pointer before copying back */
-	cmd.chanlist = (unsigned int __force *)user_chanlist;
-
-	if (copy_to_user(arg, &cmd, sizeof(cmd))) {
-		dev_dbg(dev->class_dev, "bad cmd address\n");
-		ret = -EFAULT;
-	}
+	cmd->chanlist = (unsigned int __force *)user_chanlist;
+	*copy = true;
 
 	return ret;
 }
@@ -2220,10 +2210,19 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 	case COMEDI_CMD:
 		rc = do_cmd_ioctl(dev, (struct comedi_cmd __user *)arg, file);
 		break;
-	case COMEDI_CMDTEST:
-		rc = do_cmdtest_ioctl(dev, (struct comedi_cmd __user *)arg,
-				      file);
+	case COMEDI_CMDTEST: {
+		struct comedi_cmd cmd;
+		bool copy = false;
+
+		if (copy_from_user(&cmd, (void __user *)arg, sizeof(cmd))) {
+			rc = -EFAULT;
+			break;
+		}
+		rc = do_cmdtest_ioctl(dev, &cmd, &copy, file);
+		if (copy && copy_to_user((void __user *)arg, &cmd, sizeof(cmd)))
+			rc = -EFAULT;
 		break;
+	}
 	case COMEDI_INSNLIST: {
 		struct comedi_insnlist insnlist;
 		struct comedi_insn *insns = NULL;

commit 00035beeec2c067a8094d3d86b34cc797c3d6b21
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Apr 26 08:46:04 2020 -0400

    comedi: lift copy_from_user() into callers of __comedi_get_user_cmd()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 10ab24019fa5..c136cb2f676a 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1649,17 +1649,11 @@ static int do_insn_ioctl(struct comedi_device *dev,
 }
 
 static int __comedi_get_user_cmd(struct comedi_device *dev,
-				 struct comedi_cmd __user *arg,
 				 struct comedi_cmd *cmd)
 {
 	struct comedi_subdevice *s;
 
 	lockdep_assert_held(&dev->mutex);
-	if (copy_from_user(cmd, arg, sizeof(*cmd))) {
-		dev_dbg(dev->class_dev, "bad cmd address\n");
-		return -EFAULT;
-	}
-
 	if (cmd->subdev >= dev->n_subdevices) {
 		dev_dbg(dev->class_dev, "%d no such subdevice\n", cmd->subdev);
 		return -ENODEV;
@@ -1757,8 +1751,13 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 
 	lockdep_assert_held(&dev->mutex);
 
+	if (copy_from_user(&cmd, arg, sizeof(cmd))) {
+		dev_dbg(dev->class_dev, "bad cmd address\n");
+		return -EFAULT;
+	}
+
 	/* get the user's cmd and do some simple validation */
-	ret = __comedi_get_user_cmd(dev, arg, &cmd);
+	ret = __comedi_get_user_cmd(dev, &cmd);
 	if (ret)
 		return ret;
 
@@ -1866,8 +1865,13 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 
 	lockdep_assert_held(&dev->mutex);
 
+	if (copy_from_user(&cmd, arg, sizeof(cmd))) {
+		dev_dbg(dev->class_dev, "bad cmd address\n");
+		return -EFAULT;
+	}
+
 	/* get the user's cmd and do some simple validation */
-	ret = __comedi_get_user_cmd(dev, arg, &cmd);
+	ret = __comedi_get_user_cmd(dev, &cmd);
 	if (ret)
 		return ret;
 

commit b8d47d8813055ce38c0d2ad913d5462017e52692
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 25 20:33:04 2020 -0400

    comedi: get rid of compat_alloc_user_space() mess in COMEDI_INSNLIST compat
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 0e7ba0d3fa03..10ab24019fa5 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1520,34 +1520,19 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 #define MIN_SAMPLES 16
 #define MAX_SAMPLES 65536
 static int do_insnlist_ioctl(struct comedi_device *dev,
-			     struct comedi_insnlist __user *arg, void *file)
+			     struct comedi_insn *insns,
+			     unsigned int n_insns,
+			     void *file)
 {
-	struct comedi_insnlist insnlist;
-	struct comedi_insn *insns = NULL;
 	unsigned int *data = NULL;
 	unsigned int max_n_data_required = MIN_SAMPLES;
 	int i = 0;
 	int ret = 0;
 
 	lockdep_assert_held(&dev->mutex);
-	if (copy_from_user(&insnlist, arg, sizeof(insnlist)))
-		return -EFAULT;
-
-	insns = kcalloc(insnlist.n_insns, sizeof(*insns), GFP_KERNEL);
-	if (!insns) {
-		ret = -ENOMEM;
-		goto error;
-	}
-
-	if (copy_from_user(insns, insnlist.insns,
-			   sizeof(*insns) * insnlist.n_insns)) {
-		dev_dbg(dev->class_dev, "copy_from_user failed\n");
-		ret = -EFAULT;
-		goto error;
-	}
 
 	/* Determine maximum memory needed for all instructions. */
-	for (i = 0; i < insnlist.n_insns; ++i) {
+	for (i = 0; i < n_insns; ++i) {
 		if (insns[i].n > MAX_SAMPLES) {
 			dev_dbg(dev->class_dev,
 				"number of samples too large\n");
@@ -1565,7 +1550,7 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 		goto error;
 	}
 
-	for (i = 0; i < insnlist.n_insns; ++i) {
+	for (i = 0; i < n_insns; ++i) {
 		if (insns[i].insn & INSN_MASK_WRITE) {
 			if (copy_from_user(data, insns[i].data,
 					   insns[i].n * sizeof(unsigned int))) {
@@ -1592,7 +1577,6 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 	}
 
 error:
-	kfree(insns);
 	kfree(data);
 
 	if (ret < 0)
@@ -2236,11 +2220,30 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 		rc = do_cmdtest_ioctl(dev, (struct comedi_cmd __user *)arg,
 				      file);
 		break;
-	case COMEDI_INSNLIST:
-		rc = do_insnlist_ioctl(dev,
-				       (struct comedi_insnlist __user *)arg,
-				       file);
+	case COMEDI_INSNLIST: {
+		struct comedi_insnlist insnlist;
+		struct comedi_insn *insns = NULL;
+
+		if (copy_from_user(&insnlist, (void __user *)arg,
+				   sizeof(insnlist))) {
+			rc = -EFAULT;
+			break;
+		}
+		insns = kcalloc(insnlist.n_insns, sizeof(*insns), GFP_KERNEL);
+		if (!insns) {
+			rc = -ENOMEM;
+			break;
+		}
+		if (copy_from_user(insns, insnlist.insns,
+				   sizeof(*insns) * insnlist.n_insns)) {
+			rc = -EFAULT;
+			kfree(insns);
+			break;
+		}
+		rc = do_insnlist_ioctl(dev, insns, insnlist.n_insns, file);
+		kfree(insns);
 		break;
+	}
 	case COMEDI_INSN: {
 		struct comedi_insn insn;
 		if (copy_from_user(&insn, (void __user *)arg, sizeof(insn)))
@@ -3095,83 +3098,38 @@ static int get_compat_insn(struct comedi_insn *insn,
 	return 0;
 }
 
-/* Copy 32-bit insn structure to native insn structure. */
-static int __get_compat_insn(struct comedi_insn __user *insn,
-			   struct comedi32_insn_struct __user *insn32)
-{
-	int err;
-	union {
-		unsigned int uint;
-		compat_uptr_t uptr;
-	} temp;
-
-	/* Copy insn structure.  Ignore the unused members. */
-	err = 0;
-	if (!access_ok(insn32, sizeof(*insn32)) ||
-	    !access_ok(insn, sizeof(*insn)))
-		return -EFAULT;
-
-	err |= __get_user(temp.uint, &insn32->insn);
-	err |= __put_user(temp.uint, &insn->insn);
-	err |= __get_user(temp.uint, &insn32->n);
-	err |= __put_user(temp.uint, &insn->n);
-	err |= __get_user(temp.uptr, &insn32->data);
-	err |= __put_user(compat_ptr(temp.uptr), &insn->data);
-	err |= __get_user(temp.uint, &insn32->subdev);
-	err |= __put_user(temp.uint, &insn->subdev);
-	err |= __get_user(temp.uint, &insn32->chanspec);
-	err |= __put_user(temp.uint, &insn->chanspec);
-	return err ? -EFAULT : 0;
-}
-
 /* Handle 32-bit COMEDI_INSNLIST ioctl. */
 static int compat_insnlist(struct file *file, unsigned long arg)
 {
-	struct combined_insnlist {
-		struct comedi_insnlist insnlist;
-		struct comedi_insn insn[1];
-	} __user *s;
-	struct comedi32_insnlist_struct __user *insnlist32;
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
+	struct comedi32_insnlist_struct insnlist32;
 	struct comedi32_insn_struct __user *insn32;
-	compat_uptr_t uptr;
-	unsigned int n_insns, n;
-	int err, rc;
-
-	insnlist32 = compat_ptr(arg);
-
-	/* Get 32-bit insnlist structure.  */
-	if (!access_ok(insnlist32, sizeof(*insnlist32)))
-		return -EFAULT;
-
-	err = 0;
-	err |= __get_user(n_insns, &insnlist32->n_insns);
-	err |= __get_user(uptr, &insnlist32->insns);
-	insn32 = compat_ptr(uptr);
-	if (err)
-		return -EFAULT;
-
-	/* Allocate user memory to copy insnlist and insns into. */
-	s = compat_alloc_user_space(offsetof(struct combined_insnlist,
-					     insn[n_insns]));
+	struct comedi_insn *insns;
+	unsigned int n;
+	int rc;
 
-	/* Set native insnlist structure. */
-	if (!access_ok(&s->insnlist, sizeof(s->insnlist)))
+	if (copy_from_user(&insnlist32, compat_ptr(arg), sizeof(insnlist32)))
 		return -EFAULT;
 
-	err |= __put_user(n_insns, &s->insnlist.n_insns);
-	err |= __put_user(&s->insn[0], &s->insnlist.insns);
-	if (err)
-		return -EFAULT;
+	insns = kcalloc(insnlist32.n_insns, sizeof(*insns), GFP_KERNEL);
+	if (!insns)
+		return -ENOMEM;
 
 	/* Copy insn structures. */
-	for (n = 0; n < n_insns; n++) {
-		rc = __get_compat_insn(&s->insn[n], &insn32[n]);
-		if (rc)
+	insn32 = compat_ptr(insnlist32.insns);
+	for (n = 0; n < insnlist32.n_insns; n++) {
+		rc = get_compat_insn(insns + n, insn32 + n);
+		if (rc) {
+			kfree(insns);
 			return rc;
+		}
 	}
 
-	return comedi_unlocked_ioctl(file, COMEDI_INSNLIST,
-				(unsigned long)&s->insnlist);
+	mutex_lock(&dev->mutex);
+	rc = do_insnlist_ioctl(dev, insns, insnlist32.n_insns, file);
+	mutex_unlock(&dev->mutex);
+	return rc;
 }
 
 /* Handle 32-bit COMEDI_INSN ioctl. */

commit aa332e6759fac21b454e4959703777c771a9cd93
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 25 20:11:57 2020 -0400

    comedi: get rid of compat_alloc_user_space() mess in COMEDI_INSN compat
    
    Just take copy_from_user() out of do_insn_ioctl() into the caller and
    have compat_insn() build a native version and pass it to do_insn_ioctl()
    directly.
    
    One difference from the previous commits is that the helper used to
    convert 32bit variant to native has two users - compat_insn() and
    compat_insnlist().  The latter will be converted in next commit;
    for now we simply split the helper in two variants - "userland 32bit
    to kernel native" and "userland 32bit to userland native".  The latter
    is renamed old get_compat_insn(); it will be gone in the next commit.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index d96dc85d8a98..0e7ba0d3fa03 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1615,22 +1615,19 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
  *	data (for reads) to insn->data pointer
  */
 static int do_insn_ioctl(struct comedi_device *dev,
-			 struct comedi_insn __user *arg, void *file)
+			 struct comedi_insn *insn, void *file)
 {
-	struct comedi_insn insn;
 	unsigned int *data = NULL;
 	unsigned int n_data = MIN_SAMPLES;
 	int ret = 0;
 
 	lockdep_assert_held(&dev->mutex);
-	if (copy_from_user(&insn, arg, sizeof(insn)))
-		return -EFAULT;
 
-	n_data = max(n_data, insn.n);
+	n_data = max(n_data, insn->n);
 
 	/* This is where the behavior of insn and insnlist deviate. */
-	if (insn.n > MAX_SAMPLES) {
-		insn.n = MAX_SAMPLES;
+	if (insn->n > MAX_SAMPLES) {
+		insn->n = MAX_SAMPLES;
 		n_data = MAX_SAMPLES;
 	}
 
@@ -1640,26 +1637,26 @@ static int do_insn_ioctl(struct comedi_device *dev,
 		goto error;
 	}
 
-	if (insn.insn & INSN_MASK_WRITE) {
+	if (insn->insn & INSN_MASK_WRITE) {
 		if (copy_from_user(data,
-				   insn.data,
-				   insn.n * sizeof(unsigned int))) {
+				   insn->data,
+				   insn->n * sizeof(unsigned int))) {
 			ret = -EFAULT;
 			goto error;
 		}
 	}
-	ret = parse_insn(dev, &insn, data, file);
+	ret = parse_insn(dev, insn, data, file);
 	if (ret < 0)
 		goto error;
-	if (insn.insn & INSN_MASK_READ) {
-		if (copy_to_user(insn.data,
+	if (insn->insn & INSN_MASK_READ) {
+		if (copy_to_user(insn->data,
 				 data,
-				 insn.n * sizeof(unsigned int))) {
+				 insn->n * sizeof(unsigned int))) {
 			ret = -EFAULT;
 			goto error;
 		}
 	}
-	ret = insn.n;
+	ret = insn->n;
 
 error:
 	kfree(data);
@@ -2244,10 +2241,14 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 				       (struct comedi_insnlist __user *)arg,
 				       file);
 		break;
-	case COMEDI_INSN:
-		rc = do_insn_ioctl(dev, (struct comedi_insn __user *)arg,
-				   file);
+	case COMEDI_INSN: {
+		struct comedi_insn insn;
+		if (copy_from_user(&insn, (void __user *)arg, sizeof(insn)))
+			rc = -EFAULT;
+		else
+			rc = do_insn_ioctl(dev, &insn, file);
 		break;
+	}
 	case COMEDI_POLL:
 		rc = do_poll_ioctl(dev, arg, file);
 		break;
@@ -3077,7 +3078,25 @@ static int compat_cmdtest(struct file *file, unsigned long arg)
 }
 
 /* Copy 32-bit insn structure to native insn structure. */
-static int get_compat_insn(struct comedi_insn __user *insn,
+static int get_compat_insn(struct comedi_insn *insn,
+			   struct comedi32_insn_struct __user *insn32)
+{
+	struct comedi32_insn_struct v32;
+
+	/* Copy insn structure.  Ignore the unused members. */
+	if (copy_from_user(&v32, insn32, sizeof(v32)))
+		return -EFAULT;
+	memset(insn, 0, sizeof(*insn));
+	insn->insn = v32.insn;
+	insn->n = v32.n;
+	insn->data = compat_ptr(v32.data);
+	insn->subdev = v32.subdev;
+	insn->chanspec = v32.chanspec;
+	return 0;
+}
+
+/* Copy 32-bit insn structure to native insn structure. */
+static int __get_compat_insn(struct comedi_insn __user *insn,
 			   struct comedi32_insn_struct __user *insn32)
 {
 	int err;
@@ -3146,7 +3165,7 @@ static int compat_insnlist(struct file *file, unsigned long arg)
 
 	/* Copy insn structures. */
 	for (n = 0; n < n_insns; n++) {
-		rc = get_compat_insn(&s->insn[n], &insn32[n]);
+		rc = __get_compat_insn(&s->insn[n], &insn32[n]);
 		if (rc)
 			return rc;
 	}
@@ -3158,18 +3177,19 @@ static int compat_insnlist(struct file *file, unsigned long arg)
 /* Handle 32-bit COMEDI_INSN ioctl. */
 static int compat_insn(struct file *file, unsigned long arg)
 {
-	struct comedi_insn __user *insn;
-	struct comedi32_insn_struct __user *insn32;
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
+	struct comedi_insn insn;
 	int rc;
 
-	insn32 = compat_ptr(arg);
-	insn = compat_alloc_user_space(sizeof(*insn));
-
-	rc = get_compat_insn(insn, insn32);
+	rc = get_compat_insn(&insn, (void __user *)arg);
 	if (rc)
 		return rc;
 
-	return comedi_unlocked_ioctl(file, COMEDI_INSN, (unsigned long)insn);
+	mutex_lock(&dev->mutex);
+	rc = do_insn_ioctl(dev, &insn, file);
+	mutex_unlock(&dev->mutex);
+	return rc;
 }
 
 /*

commit 388138764e2549520afd0b3b4e15de8deb592ff6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 25 18:44:30 2020 -0400

    comedi: get rid of compat_alloc_user_space() mess in COMEDI_RANGEINFO compat
    
    Just take copy_from_user() out of do_rangeing_ioctl() into the caller and
    have compat_rangeinfo() build a native version and pass it to do_rangeinfo_ioctl()
    directly.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ab811735cd1b..d96dc85d8a98 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2210,9 +2210,14 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 			rc = do_chaninfo_ioctl(dev, &it);
 		break;
 	}
-	case COMEDI_RANGEINFO:
-		rc = do_rangeinfo_ioctl(dev, (void __user *)arg);
+	case COMEDI_RANGEINFO: {
+		struct comedi_rangeinfo it;
+		if (copy_from_user(&it, (void __user *)arg, sizeof(it)))
+			rc = -EFAULT;
+		else
+			rc = do_rangeinfo_ioctl(dev, &it);
 		break;
+	}
 	case COMEDI_BUFINFO:
 		rc = do_bufinfo_ioctl(dev,
 				      (struct comedi_bufinfo __user *)arg,
@@ -2900,32 +2905,22 @@ static int compat_chaninfo(struct file *file, unsigned long arg)
 /* Handle 32-bit COMEDI_RANGEINFO ioctl. */
 static int compat_rangeinfo(struct file *file, unsigned long arg)
 {
-	struct comedi_rangeinfo __user *rangeinfo;
-	struct comedi32_rangeinfo_struct __user *rangeinfo32;
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
+	struct comedi32_rangeinfo_struct rangeinfo32;
+	struct comedi_rangeinfo rangeinfo;
 	int err;
-	union {
-		unsigned int uint;
-		compat_uptr_t uptr;
-	} temp;
-
-	rangeinfo32 = compat_ptr(arg);
-	rangeinfo = compat_alloc_user_space(sizeof(*rangeinfo));
 
-	/* Copy rangeinfo structure. */
-	if (!access_ok(rangeinfo32, sizeof(*rangeinfo32)) ||
-	    !access_ok(rangeinfo, sizeof(*rangeinfo)))
+	if (copy_from_user(&rangeinfo32, compat_ptr(arg), sizeof(rangeinfo32)))
 		return -EFAULT;
+	memset(&rangeinfo, 0, sizeof(rangeinfo));
+	rangeinfo.range_type = rangeinfo32.range_type;
+	rangeinfo.range_ptr = compat_ptr(rangeinfo32.range_ptr);
 
-	err = 0;
-	err |= __get_user(temp.uint, &rangeinfo32->range_type);
-	err |= __put_user(temp.uint, &rangeinfo->range_type);
-	err |= __get_user(temp.uptr, &rangeinfo32->range_ptr);
-	err |= __put_user(compat_ptr(temp.uptr), &rangeinfo->range_ptr);
-	if (err)
-		return -EFAULT;
-
-	return comedi_unlocked_ioctl(file, COMEDI_RANGEINFO,
-				(unsigned long)rangeinfo);
+	mutex_lock(&dev->mutex);
+	err = do_rangeinfo_ioctl(dev, &rangeinfo);
+	mutex_unlock(&dev->mutex);
+	return err;
 }
 
 /* Copy 32-bit cmd structure to native cmd structure. */

commit 3fbfd2223a271426509830e6340c386a1054cfad
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 25 18:35:03 2020 -0400

    comedi: get rid of compat_alloc_user_space() mess in COMEDI_CHANINFO compat
    
    Just take copy_from_user() out of do_chaninfo_ioctl() into the caller and
    have compat_chaninfo() build a native version and pass it to do_chaninfo_ioctl()
    directly.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ecd29f28673c..ab811735cd1b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1049,31 +1049,28 @@ static int do_subdinfo_ioctl(struct comedi_device *dev,
  *	array of range table lengths to chaninfo->range_table_list if requested
  */
 static int do_chaninfo_ioctl(struct comedi_device *dev,
-			     struct comedi_chaninfo __user *arg)
+			     struct comedi_chaninfo *it)
 {
 	struct comedi_subdevice *s;
-	struct comedi_chaninfo it;
 
 	lockdep_assert_held(&dev->mutex);
-	if (copy_from_user(&it, arg, sizeof(it)))
-		return -EFAULT;
 
-	if (it.subdev >= dev->n_subdevices)
+	if (it->subdev >= dev->n_subdevices)
 		return -EINVAL;
-	s = &dev->subdevices[it.subdev];
+	s = &dev->subdevices[it->subdev];
 
-	if (it.maxdata_list) {
+	if (it->maxdata_list) {
 		if (s->maxdata || !s->maxdata_list)
 			return -EINVAL;
-		if (copy_to_user(it.maxdata_list, s->maxdata_list,
+		if (copy_to_user(it->maxdata_list, s->maxdata_list,
 				 s->n_chan * sizeof(unsigned int)))
 			return -EFAULT;
 	}
 
-	if (it.flaglist)
+	if (it->flaglist)
 		return -EINVAL;	/* flaglist not supported */
 
-	if (it.rangelist) {
+	if (it->rangelist) {
 		int i;
 
 		if (!s->range_table_list)
@@ -1081,9 +1078,9 @@ static int do_chaninfo_ioctl(struct comedi_device *dev,
 		for (i = 0; i < s->n_chan; i++) {
 			int x;
 
-			x = (dev->minor << 28) | (it.subdev << 24) | (i << 16) |
+			x = (dev->minor << 28) | (it->subdev << 24) | (i << 16) |
 			    (s->range_table_list[i]->length);
-			if (put_user(x, it.rangelist + i))
+			if (put_user(x, it->rangelist + i))
 				return -EFAULT;
 		}
 	}
@@ -2205,9 +2202,14 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 				       (struct comedi_subdinfo __user *)arg,
 				       file);
 		break;
-	case COMEDI_CHANINFO:
-		rc = do_chaninfo_ioctl(dev, (void __user *)arg);
+	case COMEDI_CHANINFO: {
+		struct comedi_chaninfo it;
+		if (copy_from_user(&it, (void __user *)arg, sizeof(it)))
+			rc = -EFAULT;
+		else
+			rc = do_chaninfo_ioctl(dev, &it);
 		break;
+	}
 	case COMEDI_RANGEINFO:
 		rc = do_rangeinfo_ioctl(dev, (void __user *)arg);
 		break;
@@ -2874,35 +2876,25 @@ struct comedi32_insnlist_struct {
 /* Handle 32-bit COMEDI_CHANINFO ioctl. */
 static int compat_chaninfo(struct file *file, unsigned long arg)
 {
-	struct comedi_chaninfo __user *chaninfo;
-	struct comedi32_chaninfo_struct __user *chaninfo32;
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
+	struct comedi32_chaninfo_struct chaninfo32;
+	struct comedi_chaninfo chaninfo;
 	int err;
-	union {
-		unsigned int uint;
-		compat_uptr_t uptr;
-	} temp;
 
-	chaninfo32 = compat_ptr(arg);
-	chaninfo = compat_alloc_user_space(sizeof(*chaninfo));
-
-	/* Copy chaninfo structure.  Ignore unused members. */
-	if (!access_ok(chaninfo32, sizeof(*chaninfo32)) ||
-	    !access_ok(chaninfo, sizeof(*chaninfo)))
+	if (copy_from_user(&chaninfo32, compat_ptr(arg), sizeof(chaninfo32)))
 		return -EFAULT;
 
-	err = 0;
-	err |= __get_user(temp.uint, &chaninfo32->subdev);
-	err |= __put_user(temp.uint, &chaninfo->subdev);
-	err |= __get_user(temp.uptr, &chaninfo32->maxdata_list);
-	err |= __put_user(compat_ptr(temp.uptr), &chaninfo->maxdata_list);
-	err |= __get_user(temp.uptr, &chaninfo32->flaglist);
-	err |= __put_user(compat_ptr(temp.uptr), &chaninfo->flaglist);
-	err |= __get_user(temp.uptr, &chaninfo32->rangelist);
-	err |= __put_user(compat_ptr(temp.uptr), &chaninfo->rangelist);
-	if (err)
-		return -EFAULT;
+	memset(&chaninfo, 0, sizeof(chaninfo));
+	chaninfo.subdev = chaninfo32.subdev;
+	chaninfo.maxdata_list = compat_ptr(chaninfo32.maxdata_list);
+	chaninfo.flaglist = compat_ptr(chaninfo32.flaglist);
+	chaninfo.rangelist = compat_ptr(chaninfo32.rangelist);
 
-	return comedi_unlocked_ioctl(file, COMEDI_CHANINFO, (unsigned long)chaninfo);
+	mutex_lock(&dev->mutex);
+	err = do_chaninfo_ioctl(dev, &chaninfo);
+	mutex_unlock(&dev->mutex);
+	return err;
 }
 
 /* Handle 32-bit COMEDI_RANGEINFO ioctl. */

commit 5c6a8747e0cff47071d6ad3fcfe6f86713cf543a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 25 18:23:17 2020 -0400

    comedi: get rid of indirection via translated_ioctl()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 9dfb81dfe43c..ecd29f28673c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2871,16 +2871,6 @@ struct comedi32_insnlist_struct {
 	compat_uptr_t insns;	/* 32-bit 'struct comedi_insn *' */
 };
 
-/* Handle translated ioctl. */
-static int translated_ioctl(struct file *file, unsigned int cmd,
-			    unsigned long arg)
-{
-	if (file->f_op->unlocked_ioctl)
-		return file->f_op->unlocked_ioctl(file, cmd, arg);
-
-	return -ENOTTY;
-}
-
 /* Handle 32-bit COMEDI_CHANINFO ioctl. */
 static int compat_chaninfo(struct file *file, unsigned long arg)
 {
@@ -2912,7 +2902,7 @@ static int compat_chaninfo(struct file *file, unsigned long arg)
 	if (err)
 		return -EFAULT;
 
-	return translated_ioctl(file, COMEDI_CHANINFO, (unsigned long)chaninfo);
+	return comedi_unlocked_ioctl(file, COMEDI_CHANINFO, (unsigned long)chaninfo);
 }
 
 /* Handle 32-bit COMEDI_RANGEINFO ioctl. */
@@ -2942,7 +2932,7 @@ static int compat_rangeinfo(struct file *file, unsigned long arg)
 	if (err)
 		return -EFAULT;
 
-	return translated_ioctl(file, COMEDI_RANGEINFO,
+	return comedi_unlocked_ioctl(file, COMEDI_RANGEINFO,
 				(unsigned long)rangeinfo);
 }
 
@@ -3063,7 +3053,7 @@ static int compat_cmd(struct file *file, unsigned long arg)
 	if (rc)
 		return rc;
 
-	rc = translated_ioctl(file, COMEDI_CMD, (unsigned long)cmd);
+	rc = comedi_unlocked_ioctl(file, COMEDI_CMD, (unsigned long)cmd);
 	if (rc == -EAGAIN) {
 		/* Special case: copy cmd back to user. */
 		err = put_compat_cmd(cmd32, cmd);
@@ -3088,7 +3078,7 @@ static int compat_cmdtest(struct file *file, unsigned long arg)
 	if (rc)
 		return rc;
 
-	rc = translated_ioctl(file, COMEDI_CMDTEST, (unsigned long)cmd);
+	rc = comedi_unlocked_ioctl(file, COMEDI_CMDTEST, (unsigned long)cmd);
 	if (rc < 0)
 		return rc;
 
@@ -3174,7 +3164,7 @@ static int compat_insnlist(struct file *file, unsigned long arg)
 			return rc;
 	}
 
-	return translated_ioctl(file, COMEDI_INSNLIST,
+	return comedi_unlocked_ioctl(file, COMEDI_INSNLIST,
 				(unsigned long)&s->insnlist);
 }
 
@@ -3192,7 +3182,7 @@ static int compat_insn(struct file *file, unsigned long arg)
 	if (rc)
 		return rc;
 
-	return translated_ioctl(file, COMEDI_INSN, (unsigned long)insn);
+	return comedi_unlocked_ioctl(file, COMEDI_INSN, (unsigned long)insn);
 }
 
 /*
@@ -3212,7 +3202,7 @@ static long comedi_compat_ioctl(struct file *file, unsigned int cmd, unsigned lo
 	case COMEDI_BUFINFO:
 		/* Just need to translate the pointer argument. */
 		arg = (unsigned long)compat_ptr(arg);
-		rc = translated_ioctl(file, cmd, arg);
+		rc = comedi_unlocked_ioctl(file, cmd, arg);
 		break;
 	case COMEDI_LOCK:
 	case COMEDI_UNLOCK:
@@ -3221,7 +3211,7 @@ static long comedi_compat_ioctl(struct file *file, unsigned int cmd, unsigned lo
 	case COMEDI_SETRSUBD:
 	case COMEDI_SETWSUBD:
 		/* No translation needed. */
-		rc = translated_ioctl(file, cmd, arg);
+		rc = comedi_unlocked_ioctl(file, cmd, arg);
 		break;
 	case COMEDI32_CHANINFO:
 		rc = compat_chaninfo(file, arg);

commit e0d0bf8a28eb04efd997478ef3d82319cdef9455
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 25 18:19:30 2020 -0400

    comedi: move compat ioctl handling to native fops
    
    mechanical move
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 08d1bbbebf2d..9dfb81dfe43c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -4,13 +4,14 @@
  * comedi kernel module
  *
  * COMEDI - Linux Control and Measurement Device Interface
- * Copyright (C) 1997-2000 David A. Schleef <ds@schleef.org>
+ * Copyright (C) 1997-2007 David A. Schleef <ds@schleef.org>
+ * compat ioctls:
+ * Author: Ian Abbott, MEV Ltd. <abbotti@mev.co.uk>
+ * Copyright (C) 2007 MEV Ltd. <http://www.mev.co.uk/>
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
-#include "comedi_compat32.h"
-
 #include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/kernel.h>
@@ -27,6 +28,7 @@
 
 #include <linux/io.h>
 #include <linux/uaccess.h>
+#include <linux/compat.h>
 
 #include "comedi_internal.h"
 
@@ -2806,6 +2808,449 @@ static int comedi_close(struct inode *inode, struct file *file)
 	return 0;
 }
 
+#ifdef CONFIG_COMPAT
+
+#define COMEDI32_CHANINFO _IOR(CIO, 3, struct comedi32_chaninfo_struct)
+#define COMEDI32_RANGEINFO _IOR(CIO, 8, struct comedi32_rangeinfo_struct)
+/*
+ * N.B. COMEDI32_CMD and COMEDI_CMD ought to use _IOWR, not _IOR.
+ * It's too late to change it now, but it only affects the command number.
+ */
+#define COMEDI32_CMD _IOR(CIO, 9, struct comedi32_cmd_struct)
+/*
+ * N.B. COMEDI32_CMDTEST and COMEDI_CMDTEST ought to use _IOWR, not _IOR.
+ * It's too late to change it now, but it only affects the command number.
+ */
+#define COMEDI32_CMDTEST _IOR(CIO, 10, struct comedi32_cmd_struct)
+#define COMEDI32_INSNLIST _IOR(CIO, 11, struct comedi32_insnlist_struct)
+#define COMEDI32_INSN _IOR(CIO, 12, struct comedi32_insn_struct)
+
+struct comedi32_chaninfo_struct {
+	unsigned int subdev;
+	compat_uptr_t maxdata_list;	/* 32-bit 'unsigned int *' */
+	compat_uptr_t flaglist;	/* 32-bit 'unsigned int *' */
+	compat_uptr_t rangelist;	/* 32-bit 'unsigned int *' */
+	unsigned int unused[4];
+};
+
+struct comedi32_rangeinfo_struct {
+	unsigned int range_type;
+	compat_uptr_t range_ptr;	/* 32-bit 'void *' */
+};
+
+struct comedi32_cmd_struct {
+	unsigned int subdev;
+	unsigned int flags;
+	unsigned int start_src;
+	unsigned int start_arg;
+	unsigned int scan_begin_src;
+	unsigned int scan_begin_arg;
+	unsigned int convert_src;
+	unsigned int convert_arg;
+	unsigned int scan_end_src;
+	unsigned int scan_end_arg;
+	unsigned int stop_src;
+	unsigned int stop_arg;
+	compat_uptr_t chanlist;	/* 32-bit 'unsigned int *' */
+	unsigned int chanlist_len;
+	compat_uptr_t data;	/* 32-bit 'short *' */
+	unsigned int data_len;
+};
+
+struct comedi32_insn_struct {
+	unsigned int insn;
+	unsigned int n;
+	compat_uptr_t data;	/* 32-bit 'unsigned int *' */
+	unsigned int subdev;
+	unsigned int chanspec;
+	unsigned int unused[3];
+};
+
+struct comedi32_insnlist_struct {
+	unsigned int n_insns;
+	compat_uptr_t insns;	/* 32-bit 'struct comedi_insn *' */
+};
+
+/* Handle translated ioctl. */
+static int translated_ioctl(struct file *file, unsigned int cmd,
+			    unsigned long arg)
+{
+	if (file->f_op->unlocked_ioctl)
+		return file->f_op->unlocked_ioctl(file, cmd, arg);
+
+	return -ENOTTY;
+}
+
+/* Handle 32-bit COMEDI_CHANINFO ioctl. */
+static int compat_chaninfo(struct file *file, unsigned long arg)
+{
+	struct comedi_chaninfo __user *chaninfo;
+	struct comedi32_chaninfo_struct __user *chaninfo32;
+	int err;
+	union {
+		unsigned int uint;
+		compat_uptr_t uptr;
+	} temp;
+
+	chaninfo32 = compat_ptr(arg);
+	chaninfo = compat_alloc_user_space(sizeof(*chaninfo));
+
+	/* Copy chaninfo structure.  Ignore unused members. */
+	if (!access_ok(chaninfo32, sizeof(*chaninfo32)) ||
+	    !access_ok(chaninfo, sizeof(*chaninfo)))
+		return -EFAULT;
+
+	err = 0;
+	err |= __get_user(temp.uint, &chaninfo32->subdev);
+	err |= __put_user(temp.uint, &chaninfo->subdev);
+	err |= __get_user(temp.uptr, &chaninfo32->maxdata_list);
+	err |= __put_user(compat_ptr(temp.uptr), &chaninfo->maxdata_list);
+	err |= __get_user(temp.uptr, &chaninfo32->flaglist);
+	err |= __put_user(compat_ptr(temp.uptr), &chaninfo->flaglist);
+	err |= __get_user(temp.uptr, &chaninfo32->rangelist);
+	err |= __put_user(compat_ptr(temp.uptr), &chaninfo->rangelist);
+	if (err)
+		return -EFAULT;
+
+	return translated_ioctl(file, COMEDI_CHANINFO, (unsigned long)chaninfo);
+}
+
+/* Handle 32-bit COMEDI_RANGEINFO ioctl. */
+static int compat_rangeinfo(struct file *file, unsigned long arg)
+{
+	struct comedi_rangeinfo __user *rangeinfo;
+	struct comedi32_rangeinfo_struct __user *rangeinfo32;
+	int err;
+	union {
+		unsigned int uint;
+		compat_uptr_t uptr;
+	} temp;
+
+	rangeinfo32 = compat_ptr(arg);
+	rangeinfo = compat_alloc_user_space(sizeof(*rangeinfo));
+
+	/* Copy rangeinfo structure. */
+	if (!access_ok(rangeinfo32, sizeof(*rangeinfo32)) ||
+	    !access_ok(rangeinfo, sizeof(*rangeinfo)))
+		return -EFAULT;
+
+	err = 0;
+	err |= __get_user(temp.uint, &rangeinfo32->range_type);
+	err |= __put_user(temp.uint, &rangeinfo->range_type);
+	err |= __get_user(temp.uptr, &rangeinfo32->range_ptr);
+	err |= __put_user(compat_ptr(temp.uptr), &rangeinfo->range_ptr);
+	if (err)
+		return -EFAULT;
+
+	return translated_ioctl(file, COMEDI_RANGEINFO,
+				(unsigned long)rangeinfo);
+}
+
+/* Copy 32-bit cmd structure to native cmd structure. */
+static int get_compat_cmd(struct comedi_cmd __user *cmd,
+			  struct comedi32_cmd_struct __user *cmd32)
+{
+	int err;
+	union {
+		unsigned int uint;
+		compat_uptr_t uptr;
+	} temp;
+
+	/* Copy cmd structure. */
+	if (!access_ok(cmd32, sizeof(*cmd32)) ||
+	    !access_ok(cmd, sizeof(*cmd)))
+		return -EFAULT;
+
+	err = 0;
+	err |= __get_user(temp.uint, &cmd32->subdev);
+	err |= __put_user(temp.uint, &cmd->subdev);
+	err |= __get_user(temp.uint, &cmd32->flags);
+	err |= __put_user(temp.uint, &cmd->flags);
+	err |= __get_user(temp.uint, &cmd32->start_src);
+	err |= __put_user(temp.uint, &cmd->start_src);
+	err |= __get_user(temp.uint, &cmd32->start_arg);
+	err |= __put_user(temp.uint, &cmd->start_arg);
+	err |= __get_user(temp.uint, &cmd32->scan_begin_src);
+	err |= __put_user(temp.uint, &cmd->scan_begin_src);
+	err |= __get_user(temp.uint, &cmd32->scan_begin_arg);
+	err |= __put_user(temp.uint, &cmd->scan_begin_arg);
+	err |= __get_user(temp.uint, &cmd32->convert_src);
+	err |= __put_user(temp.uint, &cmd->convert_src);
+	err |= __get_user(temp.uint, &cmd32->convert_arg);
+	err |= __put_user(temp.uint, &cmd->convert_arg);
+	err |= __get_user(temp.uint, &cmd32->scan_end_src);
+	err |= __put_user(temp.uint, &cmd->scan_end_src);
+	err |= __get_user(temp.uint, &cmd32->scan_end_arg);
+	err |= __put_user(temp.uint, &cmd->scan_end_arg);
+	err |= __get_user(temp.uint, &cmd32->stop_src);
+	err |= __put_user(temp.uint, &cmd->stop_src);
+	err |= __get_user(temp.uint, &cmd32->stop_arg);
+	err |= __put_user(temp.uint, &cmd->stop_arg);
+	err |= __get_user(temp.uptr, &cmd32->chanlist);
+	err |= __put_user((unsigned int __force *)compat_ptr(temp.uptr),
+			  &cmd->chanlist);
+	err |= __get_user(temp.uint, &cmd32->chanlist_len);
+	err |= __put_user(temp.uint, &cmd->chanlist_len);
+	err |= __get_user(temp.uptr, &cmd32->data);
+	err |= __put_user(compat_ptr(temp.uptr), &cmd->data);
+	err |= __get_user(temp.uint, &cmd32->data_len);
+	err |= __put_user(temp.uint, &cmd->data_len);
+	return err ? -EFAULT : 0;
+}
+
+/* Copy native cmd structure to 32-bit cmd structure. */
+static int put_compat_cmd(struct comedi32_cmd_struct __user *cmd32,
+			  struct comedi_cmd __user *cmd)
+{
+	int err;
+	unsigned int temp;
+
+	/*
+	 * Copy back most of cmd structure.
+	 *
+	 * Assume the pointer values are already valid.
+	 * (Could use ptr_to_compat() to set them.)
+	 */
+	if (!access_ok(cmd, sizeof(*cmd)) ||
+	    !access_ok(cmd32, sizeof(*cmd32)))
+		return -EFAULT;
+
+	err = 0;
+	err |= __get_user(temp, &cmd->subdev);
+	err |= __put_user(temp, &cmd32->subdev);
+	err |= __get_user(temp, &cmd->flags);
+	err |= __put_user(temp, &cmd32->flags);
+	err |= __get_user(temp, &cmd->start_src);
+	err |= __put_user(temp, &cmd32->start_src);
+	err |= __get_user(temp, &cmd->start_arg);
+	err |= __put_user(temp, &cmd32->start_arg);
+	err |= __get_user(temp, &cmd->scan_begin_src);
+	err |= __put_user(temp, &cmd32->scan_begin_src);
+	err |= __get_user(temp, &cmd->scan_begin_arg);
+	err |= __put_user(temp, &cmd32->scan_begin_arg);
+	err |= __get_user(temp, &cmd->convert_src);
+	err |= __put_user(temp, &cmd32->convert_src);
+	err |= __get_user(temp, &cmd->convert_arg);
+	err |= __put_user(temp, &cmd32->convert_arg);
+	err |= __get_user(temp, &cmd->scan_end_src);
+	err |= __put_user(temp, &cmd32->scan_end_src);
+	err |= __get_user(temp, &cmd->scan_end_arg);
+	err |= __put_user(temp, &cmd32->scan_end_arg);
+	err |= __get_user(temp, &cmd->stop_src);
+	err |= __put_user(temp, &cmd32->stop_src);
+	err |= __get_user(temp, &cmd->stop_arg);
+	err |= __put_user(temp, &cmd32->stop_arg);
+	/* Assume chanlist pointer is unchanged. */
+	err |= __get_user(temp, &cmd->chanlist_len);
+	err |= __put_user(temp, &cmd32->chanlist_len);
+	/* Assume data pointer is unchanged. */
+	err |= __get_user(temp, &cmd->data_len);
+	err |= __put_user(temp, &cmd32->data_len);
+	return err ? -EFAULT : 0;
+}
+
+/* Handle 32-bit COMEDI_CMD ioctl. */
+static int compat_cmd(struct file *file, unsigned long arg)
+{
+	struct comedi_cmd __user *cmd;
+	struct comedi32_cmd_struct __user *cmd32;
+	int rc, err;
+
+	cmd32 = compat_ptr(arg);
+	cmd = compat_alloc_user_space(sizeof(*cmd));
+
+	rc = get_compat_cmd(cmd, cmd32);
+	if (rc)
+		return rc;
+
+	rc = translated_ioctl(file, COMEDI_CMD, (unsigned long)cmd);
+	if (rc == -EAGAIN) {
+		/* Special case: copy cmd back to user. */
+		err = put_compat_cmd(cmd32, cmd);
+		if (err)
+			rc = err;
+	}
+
+	return rc;
+}
+
+/* Handle 32-bit COMEDI_CMDTEST ioctl. */
+static int compat_cmdtest(struct file *file, unsigned long arg)
+{
+	struct comedi_cmd __user *cmd;
+	struct comedi32_cmd_struct __user *cmd32;
+	int rc, err;
+
+	cmd32 = compat_ptr(arg);
+	cmd = compat_alloc_user_space(sizeof(*cmd));
+
+	rc = get_compat_cmd(cmd, cmd32);
+	if (rc)
+		return rc;
+
+	rc = translated_ioctl(file, COMEDI_CMDTEST, (unsigned long)cmd);
+	if (rc < 0)
+		return rc;
+
+	err = put_compat_cmd(cmd32, cmd);
+	if (err)
+		rc = err;
+
+	return rc;
+}
+
+/* Copy 32-bit insn structure to native insn structure. */
+static int get_compat_insn(struct comedi_insn __user *insn,
+			   struct comedi32_insn_struct __user *insn32)
+{
+	int err;
+	union {
+		unsigned int uint;
+		compat_uptr_t uptr;
+	} temp;
+
+	/* Copy insn structure.  Ignore the unused members. */
+	err = 0;
+	if (!access_ok(insn32, sizeof(*insn32)) ||
+	    !access_ok(insn, sizeof(*insn)))
+		return -EFAULT;
+
+	err |= __get_user(temp.uint, &insn32->insn);
+	err |= __put_user(temp.uint, &insn->insn);
+	err |= __get_user(temp.uint, &insn32->n);
+	err |= __put_user(temp.uint, &insn->n);
+	err |= __get_user(temp.uptr, &insn32->data);
+	err |= __put_user(compat_ptr(temp.uptr), &insn->data);
+	err |= __get_user(temp.uint, &insn32->subdev);
+	err |= __put_user(temp.uint, &insn->subdev);
+	err |= __get_user(temp.uint, &insn32->chanspec);
+	err |= __put_user(temp.uint, &insn->chanspec);
+	return err ? -EFAULT : 0;
+}
+
+/* Handle 32-bit COMEDI_INSNLIST ioctl. */
+static int compat_insnlist(struct file *file, unsigned long arg)
+{
+	struct combined_insnlist {
+		struct comedi_insnlist insnlist;
+		struct comedi_insn insn[1];
+	} __user *s;
+	struct comedi32_insnlist_struct __user *insnlist32;
+	struct comedi32_insn_struct __user *insn32;
+	compat_uptr_t uptr;
+	unsigned int n_insns, n;
+	int err, rc;
+
+	insnlist32 = compat_ptr(arg);
+
+	/* Get 32-bit insnlist structure.  */
+	if (!access_ok(insnlist32, sizeof(*insnlist32)))
+		return -EFAULT;
+
+	err = 0;
+	err |= __get_user(n_insns, &insnlist32->n_insns);
+	err |= __get_user(uptr, &insnlist32->insns);
+	insn32 = compat_ptr(uptr);
+	if (err)
+		return -EFAULT;
+
+	/* Allocate user memory to copy insnlist and insns into. */
+	s = compat_alloc_user_space(offsetof(struct combined_insnlist,
+					     insn[n_insns]));
+
+	/* Set native insnlist structure. */
+	if (!access_ok(&s->insnlist, sizeof(s->insnlist)))
+		return -EFAULT;
+
+	err |= __put_user(n_insns, &s->insnlist.n_insns);
+	err |= __put_user(&s->insn[0], &s->insnlist.insns);
+	if (err)
+		return -EFAULT;
+
+	/* Copy insn structures. */
+	for (n = 0; n < n_insns; n++) {
+		rc = get_compat_insn(&s->insn[n], &insn32[n]);
+		if (rc)
+			return rc;
+	}
+
+	return translated_ioctl(file, COMEDI_INSNLIST,
+				(unsigned long)&s->insnlist);
+}
+
+/* Handle 32-bit COMEDI_INSN ioctl. */
+static int compat_insn(struct file *file, unsigned long arg)
+{
+	struct comedi_insn __user *insn;
+	struct comedi32_insn_struct __user *insn32;
+	int rc;
+
+	insn32 = compat_ptr(arg);
+	insn = compat_alloc_user_space(sizeof(*insn));
+
+	rc = get_compat_insn(insn, insn32);
+	if (rc)
+		return rc;
+
+	return translated_ioctl(file, COMEDI_INSN, (unsigned long)insn);
+}
+
+/*
+ * compat_ioctl file operation.
+ *
+ * Returns -ENOIOCTLCMD for unrecognised ioctl codes.
+ */
+static long comedi_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int rc;
+
+	switch (cmd) {
+	case COMEDI_DEVCONFIG:
+	case COMEDI_DEVINFO:
+	case COMEDI_SUBDINFO:
+	case COMEDI_BUFCONFIG:
+	case COMEDI_BUFINFO:
+		/* Just need to translate the pointer argument. */
+		arg = (unsigned long)compat_ptr(arg);
+		rc = translated_ioctl(file, cmd, arg);
+		break;
+	case COMEDI_LOCK:
+	case COMEDI_UNLOCK:
+	case COMEDI_CANCEL:
+	case COMEDI_POLL:
+	case COMEDI_SETRSUBD:
+	case COMEDI_SETWSUBD:
+		/* No translation needed. */
+		rc = translated_ioctl(file, cmd, arg);
+		break;
+	case COMEDI32_CHANINFO:
+		rc = compat_chaninfo(file, arg);
+		break;
+	case COMEDI32_RANGEINFO:
+		rc = compat_rangeinfo(file, arg);
+		break;
+	case COMEDI32_CMD:
+		rc = compat_cmd(file, arg);
+		break;
+	case COMEDI32_CMDTEST:
+		rc = compat_cmdtest(file, arg);
+		break;
+	case COMEDI32_INSNLIST:
+		rc = compat_insnlist(file, arg);
+		break;
+	case COMEDI32_INSN:
+		rc = compat_insn(file, arg);
+		break;
+	default:
+		rc = -ENOIOCTLCMD;
+		break;
+	}
+	return rc;
+}
+#else
+#define comedi_compat_ioctl NULL
+#endif
+
 static const struct file_operations comedi_fops = {
 	.owner = THIS_MODULE,
 	.unlocked_ioctl = comedi_unlocked_ioctl,

commit 332e0e17ad49e084b7db670ef43b5eb59abd9e34
Author: Xiyu Yang <xiyuyang19@fudan.edu.cn>
Date:   Mon Apr 20 13:44:16 2020 +0800

    staging: comedi: Fix comedi_device refcnt leak in comedi_open
    
    comedi_open() invokes comedi_dev_get_from_minor(), which returns a
    reference of the COMEDI device to "dev" with increased refcount.
    
    When comedi_open() returns, "dev" becomes invalid, so the refcount
    should be decreased to keep refcount balanced.
    
    The reference counting issue happens in one exception handling path of
    comedi_open(). When "cfp" allocation is failed, the refcnt increased by
    comedi_dev_get_from_minor() is not decreased, causing a refcnt leak.
    
    Fix this issue by calling comedi_dev_put() on this error path when "cfp"
    allocation is failed.
    
    Fixes: 20f083c07565 ("staging: comedi: prepare support for per-file read and write subdevices")
    Signed-off-by: Xiyu Yang <xiyuyang19@fudan.edu.cn>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Xin Tan <tanxin.ctf@gmail.com>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Link: https://lore.kernel.org/r/1587361459-83622-1-git-send-email-xiyuyang19@fudan.edu.cn
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 08d1bbbebf2d..e84b4fb493d6 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2725,8 +2725,10 @@ static int comedi_open(struct inode *inode, struct file *file)
 	}
 
 	cfp = kzalloc(sizeof(*cfp), GFP_KERNEL);
-	if (!cfp)
+	if (!cfp) {
+		comedi_dev_put(dev);
 		return -ENOMEM;
+	}
 
 	cfp->dev = dev;
 

commit e36472145aa706c186a6bb4f6419c613b0b1305c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jun 25 12:26:59 2019 +0100

    staging: comedi: use dma_mmap_coherent for DMA-able buffer mmap
    
    Comedi's acquisition buffer allocation code can allocate the buffer from
    normal kernel memory or from DMA coherent memory depending on the
    `dma_async_dir` value in the comedi subdevice.  (A value of `DMA_NONE`
    causes the buffer to be allocated from normal kernel memory.  Other
    values cause the buffer to be allocated from DMA coherent memory.)   The
    buffer currently consists of a bunch of page-sized blocks that are
    vmap'ed into a contiguous range of virtual addresses. The pages are also
    mmap'able into user address space.  For DMA'able buffers, these
    page-sized blocks are allocated by `dma_alloc_coherent()`.
    
    For DMA-able buffers, the DMA API is currently abused in various ways,
    the most serious abuse being the calling of `virt_to_page()` on the
    blocks allocated by `dma_alloc_coherent()` and passing those pages to
    `vmap()` (for mapping to the kernels vmalloc address space) and via
    `page_to_pfn()` to `remap_pfn_range()` (for mmap'ing to user space).  it
    also uses the `__GFP_COMP` flag when allocating the blocks, and marks
    the allocated pages as reserved (which is unnecessary for DMA coherent
    allocations).
    
    The code can be changed to get rid of the vmap'ed address altogether if
    necessary, since there are only a few places in the comedi code that use
    the vmap'ed address directly and we also keep a list of the kernel
    addresses for the individual pages prior to the vmap operation. This
    would add some run-time overhead to buffer accesses.  The real killer is
    the mmap operation.
    
    For mmap, the address range specified in the VMA needs to be mmap'ed to
    the individually allocated page-sized blocks.  That is not a problem
    when the pages are allocated from normal kernel memory as the individual
    pages can be remapped by `remap_pfn_range()`, but it is a problem when
    the page-sized blocks are allocated by `dma_alloc_coherent()` because
    the DMA API currently has no support for splitting a VMA across multiple
    blocks of DMA coherent memory (or rather, no support for mapping part of
    a VMA range to a single block of DMA coherent memory).
    
    In order to comply with the DMA API and allow the buffer to be mmap'ed,
    the buffer needs to be allocated as a single block by a single call to
    `dma_alloc_coherent()`, freed by a single call to `dma_free_coherent()`,
    and mmap'ed to user space by a single call to `dma_mmap_coherent()`.
    This patch changes the buffer allocation, freeing, and mmap'ing code to
    do that, with the unfortunate consequence that buffer allocation is more
    likely to fail.  It also no longer uses the `__GFP_COMP` flag when
    allocating DMA coherent memory, no longer marks the
    allocated pages of DMA coherent memory as reserved, and no longer vmap's
    the DMA coherent memory pages (since they are contiguous anyway).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f6d1287c7b83..08d1bbbebf2d 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2301,11 +2301,12 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 	struct comedi_buf_map *bm = NULL;
+	struct comedi_buf_page *buf;
 	unsigned long start = vma->vm_start;
 	unsigned long size;
 	int n_pages;
 	int i;
-	int retval;
+	int retval = 0;
 
 	/*
 	 * 'trylock' avoids circular dependency with current->mm->mmap_sem
@@ -2361,24 +2362,36 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 		retval = -EINVAL;
 		goto done;
 	}
-	for (i = 0; i < n_pages; ++i) {
-		struct comedi_buf_page *buf = &bm->page_list[i];
+	if (bm->dma_dir != DMA_NONE) {
+		/*
+		 * DMA buffer was allocated as a single block.
+		 * Address is in page_list[0].
+		 */
+		buf = &bm->page_list[0];
+		retval = dma_mmap_coherent(bm->dma_hw_dev, vma, buf->virt_addr,
+					   buf->dma_addr, n_pages * PAGE_SIZE);
+	} else {
+		for (i = 0; i < n_pages; ++i) {
+			unsigned long pfn;
+
+			buf = &bm->page_list[i];
+			pfn = page_to_pfn(virt_to_page(buf->virt_addr));
+			retval = remap_pfn_range(vma, start, pfn, PAGE_SIZE,
+						 PAGE_SHARED);
+			if (retval)
+				break;
 
-		if (remap_pfn_range(vma, start,
-				    page_to_pfn(virt_to_page(buf->virt_addr)),
-				    PAGE_SIZE, PAGE_SHARED)) {
-			retval = -EAGAIN;
-			goto done;
+			start += PAGE_SIZE;
 		}
-		start += PAGE_SIZE;
 	}
 
-	vma->vm_ops = &comedi_vm_ops;
-	vma->vm_private_data = bm;
+	if (retval == 0) {
+		vma->vm_ops = &comedi_vm_ops;
+		vma->vm_private_data = bm;
 
-	vma->vm_ops->open(vma);
+		vma->vm_ops->open(vma);
+	}
 
-	retval = 0;
 done:
 	up_read(&dev->attach_lock);
 	comedi_buf_map_put(bm);	/* put reference to buf map - okay if NULL */

commit 77c21b626be5b6b30ca6f76ccd5ba1d14a8278a9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Apr 17 15:39:29 2019 +0100

    staging: comedi: Add lockdep_assert_held() calls for dev->mutex
    
    Lots of functions in the core comedi module expect the mutex in `struct
    comedi_device` to be held, so add calls to `lockdep_assert_held()` to
    check and document that.  An unusual case is the calls to
    `lockdep_assert_held()` after successful return from
    `comedi_alloc_board_minor()` which allocates a `struct comedi_device`
    and returns with its mutex locked.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 0caae4a5c471..f6d1287c7b83 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -164,6 +164,7 @@ static bool comedi_clear_board_dev(struct comedi_device *dev)
 	unsigned int i = dev->minor;
 	bool cleared = false;
 
+	lockdep_assert_held(&dev->mutex);
 	mutex_lock(&comedi_board_minor_table_lock);
 	if (dev == comedi_board_minor_table[i]) {
 		comedi_board_minor_table[i] = NULL;
@@ -260,6 +261,7 @@ comedi_read_subdevice(const struct comedi_device *dev, unsigned int minor)
 {
 	struct comedi_subdevice *s;
 
+	lockdep_assert_held(&dev->mutex);
 	if (minor >= COMEDI_NUM_BOARD_MINORS) {
 		s = comedi_subdevice_from_minor(dev, minor);
 		if (!s || (s->subdev_flags & SDF_CMD_READ))
@@ -273,6 +275,7 @@ comedi_write_subdevice(const struct comedi_device *dev, unsigned int minor)
 {
 	struct comedi_subdevice *s;
 
+	lockdep_assert_held(&dev->mutex);
 	if (minor >= COMEDI_NUM_BOARD_MINORS) {
 		s = comedi_subdevice_from_minor(dev, minor);
 		if (!s || (s->subdev_flags & SDF_CMD_WRITE))
@@ -336,6 +339,8 @@ static int resize_async_buffer(struct comedi_device *dev,
 	struct comedi_async *async = s->async;
 	int retval;
 
+	lockdep_assert_held(&dev->mutex);
+
 	if (new_size > async->max_bufsize)
 		return -EPERM;
 
@@ -726,6 +731,7 @@ static void do_become_nonbusy(struct comedi_device *dev,
 {
 	struct comedi_async *async = s->async;
 
+	lockdep_assert_held(&dev->mutex);
 	comedi_update_subdevice_runflags(s, COMEDI_SRF_RUNNING, 0);
 	if (async) {
 		comedi_buf_reset(s);
@@ -745,6 +751,7 @@ static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int ret = 0;
 
+	lockdep_assert_held(&dev->mutex);
 	if (comedi_is_subdevice_running(s) && s->cancel)
 		ret = s->cancel(dev, s);
 
@@ -758,6 +765,7 @@ void comedi_device_cancel_all(struct comedi_device *dev)
 	struct comedi_subdevice *s;
 	int i;
 
+	lockdep_assert_held(&dev->mutex);
 	if (!dev->attached)
 		return;
 
@@ -773,6 +781,7 @@ static int is_device_busy(struct comedi_device *dev)
 	struct comedi_subdevice *s;
 	int i;
 
+	lockdep_assert_held(&dev->mutex);
 	if (!dev->attached)
 		return 0;
 
@@ -805,6 +814,7 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 {
 	struct comedi_devconfig it;
 
+	lockdep_assert_held(&dev->mutex);
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
@@ -860,6 +870,7 @@ static int do_bufconfig_ioctl(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	int retval = 0;
 
+	lockdep_assert_held(&dev->mutex);
 	if (copy_from_user(&bc, arg, sizeof(bc)))
 		return -EFAULT;
 
@@ -920,6 +931,7 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	struct comedi_devinfo devinfo;
 
+	lockdep_assert_held(&dev->mutex);
 	memset(&devinfo, 0, sizeof(devinfo));
 
 	/* fill devinfo structure */
@@ -966,6 +978,7 @@ static int do_subdinfo_ioctl(struct comedi_device *dev,
 	struct comedi_subdinfo *tmp, *us;
 	struct comedi_subdevice *s;
 
+	lockdep_assert_held(&dev->mutex);
 	tmp = kcalloc(dev->n_subdevices, sizeof(*tmp), GFP_KERNEL);
 	if (!tmp)
 		return -ENOMEM;
@@ -1039,6 +1052,7 @@ static int do_chaninfo_ioctl(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	struct comedi_chaninfo it;
 
+	lockdep_assert_held(&dev->mutex);
 	if (copy_from_user(&it, arg, sizeof(it)))
 		return -EFAULT;
 
@@ -1098,6 +1112,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	int retval = 0;
 	bool become_nonbusy = false;
 
+	lockdep_assert_held(&dev->mutex);
 	if (copy_from_user(&bi, arg, sizeof(bi)))
 		return -EFAULT;
 
@@ -1282,6 +1297,7 @@ static int check_insn_device_config_length(struct comedi_insn *insn,
  */
 static int get_valid_routes(struct comedi_device *dev, unsigned int *data)
 {
+	lockdep_assert_held(&dev->mutex);
 	data[1] = dev->get_valid_routes(dev, data[1], data + 2);
 	return 0;
 }
@@ -1293,6 +1309,7 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 	int ret = 0;
 	int i;
 
+	lockdep_assert_held(&dev->mutex);
 	if (insn->insn & INSN_MASK_SPECIAL) {
 		/* a non-subdevice instruction */
 
@@ -1513,6 +1530,7 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 	int i = 0;
 	int ret = 0;
 
+	lockdep_assert_held(&dev->mutex);
 	if (copy_from_user(&insnlist, arg, sizeof(insnlist)))
 		return -EFAULT;
 
@@ -1605,6 +1623,7 @@ static int do_insn_ioctl(struct comedi_device *dev,
 	unsigned int n_data = MIN_SAMPLES;
 	int ret = 0;
 
+	lockdep_assert_held(&dev->mutex);
 	if (copy_from_user(&insn, arg, sizeof(insn)))
 		return -EFAULT;
 
@@ -1655,6 +1674,7 @@ static int __comedi_get_user_cmd(struct comedi_device *dev,
 {
 	struct comedi_subdevice *s;
 
+	lockdep_assert_held(&dev->mutex);
 	if (copy_from_user(cmd, arg, sizeof(*cmd))) {
 		dev_dbg(dev->class_dev, "bad cmd address\n");
 		return -EFAULT;
@@ -1713,6 +1733,7 @@ static int __comedi_get_user_chanlist(struct comedi_device *dev,
 	unsigned int *chanlist;
 	int ret;
 
+	lockdep_assert_held(&dev->mutex);
 	cmd->chanlist = NULL;
 	chanlist = memdup_user(user_chanlist,
 			       cmd->chanlist_len * sizeof(unsigned int));
@@ -1754,6 +1775,8 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	unsigned int __user *user_chanlist;
 	int ret;
 
+	lockdep_assert_held(&dev->mutex);
+
 	/* get the user's cmd and do some simple validation */
 	ret = __comedi_get_user_cmd(dev, arg, &cmd);
 	if (ret)
@@ -1861,6 +1884,8 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 	unsigned int __user *user_chanlist;
 	int ret;
 
+	lockdep_assert_held(&dev->mutex);
+
 	/* get the user's cmd and do some simple validation */
 	ret = __comedi_get_user_cmd(dev, arg, &cmd);
 	if (ret)
@@ -1914,6 +1939,7 @@ static int do_lock_ioctl(struct comedi_device *dev, unsigned long arg,
 	unsigned long flags;
 	struct comedi_subdevice *s;
 
+	lockdep_assert_held(&dev->mutex);
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
 	s = &dev->subdevices[arg];
@@ -1946,6 +1972,7 @@ static int do_unlock_ioctl(struct comedi_device *dev, unsigned long arg,
 {
 	struct comedi_subdevice *s;
 
+	lockdep_assert_held(&dev->mutex);
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
 	s = &dev->subdevices[arg];
@@ -1980,6 +2007,7 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned long arg,
 {
 	struct comedi_subdevice *s;
 
+	lockdep_assert_held(&dev->mutex);
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
 	s = &dev->subdevices[arg];
@@ -2013,6 +2041,7 @@ static int do_poll_ioctl(struct comedi_device *dev, unsigned long arg,
 {
 	struct comedi_subdevice *s;
 
+	lockdep_assert_held(&dev->mutex);
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
 	s = &dev->subdevices[arg];
@@ -2048,6 +2077,7 @@ static int do_setrsubd_ioctl(struct comedi_device *dev, unsigned long arg,
 	struct comedi_file *cfp = file->private_data;
 	struct comedi_subdevice *s_old, *s_new;
 
+	lockdep_assert_held(&dev->mutex);
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
 
@@ -2090,6 +2120,7 @@ static int do_setwsubd_ioctl(struct comedi_device *dev, unsigned long arg,
 	struct comedi_file *cfp = file->private_data;
 	struct comedi_subdevice *s_old, *s_new;
 
+	lockdep_assert_held(&dev->mutex);
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
 
@@ -2995,6 +3026,7 @@ static int __init comedi_init(void)
 			goto out_cleanup_board_minors;
 		}
 		/* comedi_alloc_board_minor() locked the mutex */
+		lockdep_assert_held(&dev->mutex);
 		mutex_unlock(&dev->mutex);
 	}
 

commit ee593133a76c0c86484929b1c7ac91a9f0b7492c
Author: Sandesh Kenjana Ashok <kas.sandesh@gmail.com>
Date:   Wed Jan 30 21:25:46 2019 +0100

    staging: comedi: comedi_fops.c: Remove redundant blank line
    
    Removed redunant blank line. Issue found by checkpatch.
    
    Signed-off-by: Sandesh Kenjana Ashok <kas.sandesh@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 38980fad8be4..0caae4a5c471 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1608,7 +1608,6 @@ static int do_insn_ioctl(struct comedi_device *dev,
 	if (copy_from_user(&insn, arg, sizeof(insn)))
 		return -EFAULT;
 
-
 	n_data = max(n_data, insn.n);
 
 	/* This is where the behavior of insn and insnlist deviate. */

commit 56eec1806fac3cc585eb8644e36e8cc30bcbcbb1
Author: Jitendra Khasdev <jkhasdev@gmail.com>
Date:   Tue Jan 15 21:06:56 2019 +0530

    staging: comedi: Removed not necessary braces for single block
    
    This patch is used to remove not necessary braces for single if block.
    
    Signed-off-by: Jitendra Khasdev <jkhasdev@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 5d2fcbfe02af..38980fad8be4 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1605,9 +1605,9 @@ static int do_insn_ioctl(struct comedi_device *dev,
 	unsigned int n_data = MIN_SAMPLES;
 	int ret = 0;
 
-	if (copy_from_user(&insn, arg, sizeof(insn))) {
+	if (copy_from_user(&insn, arg, sizeof(insn)))
 		return -EFAULT;
-	}
+
 
 	n_data = max(n_data, insn.n);
 

commit f8bc1b2efa05183f10451b7618243a4278bf6b16
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Tue Dec 4 12:07:50 2018 -0700

    staging: comedi: change do_insn*_ioctl to allow more samples
    
    Changes do_insn*_ioctl functions to allow for data lengths for each
    comedi_insn of up to 2^16.  This patch also changes these functions to only
    allocate as much memory as is necessary for each comedi_insn, rather than
    allocating a fixed-sized scratch space.
    
    In testing some user-space code for the new INSN_DEVICE_CONFIG_GET_ROUTES
    facility with some newer hardware, I discovered that do_insn_ioctl and
    do_insnlist_ioctl limited the amount of data that can be passed into the
    kernel for insn's to a length of 256.  For some newer hardware, the number
    of routes can be greater than 1000.  Working around the old limits (256)
    would complicate the user-space/kernel interaction.
    
    The new upper limit is reasonable with current memory available and does
    not otherwise impact the memory footprint for any current or otherwise
    typical configuration.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ceb6ba5dd57c..5d2fcbfe02af 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1501,25 +1501,21 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
  *	data (for reads) to insns[].data pointers
  */
 /* arbitrary limits */
-#define MAX_SAMPLES 256
+#define MIN_SAMPLES 16
+#define MAX_SAMPLES 65536
 static int do_insnlist_ioctl(struct comedi_device *dev,
 			     struct comedi_insnlist __user *arg, void *file)
 {
 	struct comedi_insnlist insnlist;
 	struct comedi_insn *insns = NULL;
 	unsigned int *data = NULL;
+	unsigned int max_n_data_required = MIN_SAMPLES;
 	int i = 0;
 	int ret = 0;
 
 	if (copy_from_user(&insnlist, arg, sizeof(insnlist)))
 		return -EFAULT;
 
-	data = kmalloc_array(MAX_SAMPLES, sizeof(unsigned int), GFP_KERNEL);
-	if (!data) {
-		ret = -ENOMEM;
-		goto error;
-	}
-
 	insns = kcalloc(insnlist.n_insns, sizeof(*insns), GFP_KERNEL);
 	if (!insns) {
 		ret = -ENOMEM;
@@ -1533,13 +1529,26 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 		goto error;
 	}
 
-	for (i = 0; i < insnlist.n_insns; i++) {
+	/* Determine maximum memory needed for all instructions. */
+	for (i = 0; i < insnlist.n_insns; ++i) {
 		if (insns[i].n > MAX_SAMPLES) {
 			dev_dbg(dev->class_dev,
 				"number of samples too large\n");
 			ret = -EINVAL;
 			goto error;
 		}
+		max_n_data_required = max(max_n_data_required, insns[i].n);
+	}
+
+	/* Allocate scratch space for all instruction data. */
+	data = kmalloc_array(max_n_data_required, sizeof(unsigned int),
+			     GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	for (i = 0; i < insnlist.n_insns; ++i) {
 		if (insns[i].insn & INSN_MASK_WRITE) {
 			if (copy_from_user(data, insns[i].data,
 					   insns[i].n * sizeof(unsigned int))) {
@@ -1593,22 +1602,27 @@ static int do_insn_ioctl(struct comedi_device *dev,
 {
 	struct comedi_insn insn;
 	unsigned int *data = NULL;
+	unsigned int n_data = MIN_SAMPLES;
 	int ret = 0;
 
-	data = kmalloc_array(MAX_SAMPLES, sizeof(unsigned int), GFP_KERNEL);
-	if (!data) {
-		ret = -ENOMEM;
-		goto error;
-	}
-
 	if (copy_from_user(&insn, arg, sizeof(insn))) {
-		ret = -EFAULT;
-		goto error;
+		return -EFAULT;
 	}
 
+	n_data = max(n_data, insn.n);
+
 	/* This is where the behavior of insn and insnlist deviate. */
-	if (insn.n > MAX_SAMPLES)
+	if (insn.n > MAX_SAMPLES) {
 		insn.n = MAX_SAMPLES;
+		n_data = MAX_SAMPLES;
+	}
+
+	data = kmalloc_array(n_data, sizeof(unsigned int), GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
 	if (insn.insn & INSN_MASK_WRITE) {
 		if (copy_from_user(data,
 				   insn.data,

commit e3b9ea9aae7e1576516da2b125d7add20663f591
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 30 14:17:13 2018 +0000

    staging: comedi: Check length of INSN_CONFIG_TIMER_1 instruction
    
    The contents of the Comedi configuration instruction
    `INSN_CONFIG_TIMER_1` instruction are not very well defined, but the one
    driver that uses it (the "cb_pcidas64" driver for the PCI-DAS4020/12
    card) assumes its `insn->n` is 5. Add a check in
    `check_insn_config_length()` to verify that `insn->n` is correct for
    this configuration instruction.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c1c6b2b4ab91..ceb6ba5dd57c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1209,6 +1209,7 @@ static int check_insn_config_length(struct comedi_insn *insn,
 		break;
 	case INSN_CONFIG_PWM_OUTPUT:
 	case INSN_CONFIG_ANALOG_TRIG:
+	case INSN_CONFIG_TIMER_1:
 		if (insn->n == 5)
 			return 0;
 		break;

commit d7569ad766511fe708a8bd7476baa305d1510daf
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Oct 3 14:56:02 2018 -0600

    staging: comedi: add new device-global config interface
    
    Adds interface for configuring options that are global to all sub-devices.
    For now, only options to configure device-globally identified signal routes
    have been defined.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 548baa790507..c1c6b2b4ab91 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1234,6 +1234,57 @@ static int check_insn_config_length(struct comedi_insn *insn,
 	return -EINVAL;
 }
 
+static int check_insn_device_config_length(struct comedi_insn *insn,
+					   unsigned int *data)
+{
+	if (insn->n < 1)
+		return -EINVAL;
+
+	switch (data[0]) {
+	case INSN_DEVICE_CONFIG_TEST_ROUTE:
+	case INSN_DEVICE_CONFIG_CONNECT_ROUTE:
+	case INSN_DEVICE_CONFIG_DISCONNECT_ROUTE:
+		if (insn->n == 3)
+			return 0;
+		break;
+	case INSN_DEVICE_CONFIG_GET_ROUTES:
+		/*
+		 * Big enough for config_id and the length of the userland
+		 * memory buffer.  Additional length should be in factors of 2
+		 * to communicate any returned route pairs (source,destination).
+		 */
+		if (insn->n >= 2)
+			return 0;
+		break;
+	}
+	return -EINVAL;
+}
+
+/**
+ * get_valid_routes() - Calls low-level driver get_valid_routes function to
+ *			either return a count of valid routes to user, or copy
+ *			of list of all valid device routes to buffer in
+ *			userspace.
+ * @dev: comedi device pointer
+ * @data: data from user insn call.  The length of the data must be >= 2.
+ *	  data[0] must contain the INSN_DEVICE_CONFIG config_id.
+ *	  data[1](input) contains the number of _pairs_ for which memory is
+ *		  allotted from the user.  If the user specifies '0', then only
+ *		  the number of pairs available is returned.
+ *	  data[1](output) returns either the number of pairs available (if none
+ *		  where requested) or the number of _pairs_ that are copied back
+ *		  to the user.
+ *	  data[2::2] returns each (source, destination) pair.
+ *
+ * Return: -EINVAL if low-level driver does not allocate and return routes as
+ *	   expected.  Returns 0 otherwise.
+ */
+static int get_valid_routes(struct comedi_device *dev, unsigned int *data)
+{
+	data[1] = dev->get_valid_routes(dev, data[1], data + 2);
+	return 0;
+}
+
 static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 		      unsigned int *data, void *file)
 {
@@ -1297,6 +1348,24 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 			if (ret >= 0)
 				ret = 1;
 			break;
+		case INSN_DEVICE_CONFIG:
+			ret = check_insn_device_config_length(insn, data);
+			if (ret)
+				break;
+
+			if (data[0] == INSN_DEVICE_CONFIG_GET_ROUTES) {
+				/*
+				 * data[1] should be the number of _pairs_ that
+				 * the memory can hold.
+				 */
+				data[1] = (insn->n - 2) / 2;
+				ret = get_valid_routes(dev, data);
+				break;
+			}
+
+			/* other global device config instructions. */
+			ret = dev->insn_device_config(dev, insn, data);
+			break;
 		default:
 			dev_dbg(dev->class_dev, "invalid insn\n");
 			ret = -EINVAL;

commit 832f33366c771855951313a9bab4926f2a0d37a1
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Sep 19 10:51:03 2018 -0600

    staging: comedi: add facility to directly query subdevice timing constraints
    
    Adds facility to directly query the hardware speed limits of subdevices,
    in particular for scan_begin and convert signals.  This information can be
    critical for integrating comedi with other hardware modules, and also
    comedi modules together with software where software requires specific
    timing capabilities in order to properly coordinate multiple devices.
    
    Currently, comedi_command_test almost satisfies this need, but really only
    for when *_src == TRIG_TIMER.  For *_src == TRIG_EXT, comedi_command_test
    does not help at all.  For many subdevices, one might simply use
    *_src==TRIG_TIMER in command_test in order to determine these limits.  For
    other subdevices, this tactic does not work since *_src == TRIG_TIMER might
    not be valid.  There is also the possibility that the timing limits are
    different between the TRIG_TIMER and TRIG_EXT modes.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e18b61cdbdeb..548baa790507 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1216,6 +1216,10 @@ static int check_insn_config_length(struct comedi_insn *insn,
 		if (insn->n == 6)
 			return 0;
 		break;
+	case INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS:
+		if (insn->n >= 4)
+			return 0;
+		break;
 		/*
 		 * by default we allow the insn since we don't have checks for
 		 * all possible cases yet

commit 642e0692bea6e7393c01e7074a55b491700f9e6e
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Sat Jul 14 21:14:58 2018 +0530

    staging: comedi: comedi_fops: Shift assignment operator '=' to previous line
    
    Shift '=' assignment operator to the end of previous
    line to conform to preferred kernel style line wrapping.
    Issue reported by checkpatch CHECK.
    
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1f3b1106f478..e18b61cdbdeb 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -79,8 +79,8 @@ MODULE_PARM_DESC(comedi_default_buf_size_kb,
 		 "default asynchronous buffer size in KiB (default "
 		 __MODULE_STRING(CONFIG_COMEDI_DEFAULT_BUF_SIZE_KB) ")");
 
-unsigned int comedi_default_buf_maxsize_kb
-	= CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB;
+unsigned int comedi_default_buf_maxsize_kb =
+	CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB;
 module_param(comedi_default_buf_maxsize_kb, uint, 0644);
 MODULE_PARM_DESC(comedi_default_buf_maxsize_kb,
 		 "default maximum size of asynchronous buffer in KiB (default "

commit b3c16227013f7f24429487cb501390c0f44fba8f
Author: Giulio Benetti <giulio.benetti@micronovasrl.com>
Date:   Tue Jun 12 16:50:28 2018 +0200

    staging: comedi: comedi_fops: make bool bit-field unsigned int bit-fields.
    
    Checkpatch complains on bool bitfields to be an int or u8/u16/u32
    bitfield.
    
    Make bool bit-fields to be unsigned int bit-fields.
    
    Signed-off-by: Giulio Benetti <giulio.benetti@micronovasrl.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c13772a0df58..1f3b1106f478 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -60,7 +60,7 @@ struct comedi_file {
 	struct comedi_subdevice *read_subdev;
 	struct comedi_subdevice *write_subdev;
 	unsigned int last_detach_count;
-	bool last_attached:1;
+	unsigned int last_attached:1;
 };
 
 #define COMEDI_NUM_MINORS 0x100

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ef733847eebe..c13772a0df58 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2288,7 +2288,7 @@ static __poll_t comedi_poll(struct file *file, poll_table *wait)
 		if (s->busy != file || !comedi_is_subdevice_running(s) ||
 		    (s->async->cmd.flags & CMDF_WRITE) ||
 		    comedi_buf_read_n_available(s) > 0)
-			mask |= POLLIN | POLLRDNORM;
+			mask |= EPOLLIN | EPOLLRDNORM;
 	}
 
 	s = comedi_file_write_subdevice(file);
@@ -2300,7 +2300,7 @@ static __poll_t comedi_poll(struct file *file, poll_table *wait)
 		if (s->busy != file || !comedi_is_subdevice_running(s) ||
 		    !(s->async->cmd.flags & CMDF_WRITE) ||
 		    comedi_buf_write_n_available(s) >= bps)
-			mask |= POLLOUT | POLLWRNORM;
+			mask |= EPOLLOUT | EPOLLWRNORM;
 	}
 
 done:

commit 5d8515bc232172963a4cef007e97b08c5e4d0533
Merge: db5933225f2f 3384e01179ef
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 1 09:51:57 2018 -0800

    Merge tag 'staging-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging/IIO updates from Greg KH:
     "Here is the big Staging and IIO driver patches for 4.16-rc1.
    
      There is the normal amount of new IIO drivers added, like all
      releases.
    
      The networking IPX and the ncpfs filesystem are moved into the staging
      tree, as they are on their way out of the kernel due to lack of use
      anymore.
    
      The visorbus subsystem finall has started moving out of the staging
      tree to the "real" part of the kernel, and the most and fsl-mc
      codebases are almost ready to move out, that will probably happen for
      4.17-rc1 if all goes well.
    
      Other than that, there is a bunch of license header cleanups in the
      tree, along with the normal amount of coding style churn that we all
      know and love for this codebase. I also got frustrated at the
      Meltdown/Spectre mess and took it out on the dgnc tty driver, deleting
      huge chunks of it that were never even being used.
    
      Full details of everything is in the shortlog.
    
      All of these patches have been in linux-next for a while with no
      reported issues"
    
    * tag 'staging-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (627 commits)
      staging: rtlwifi: remove redundant initialization of 'cfg_cmd'
      staging: rtl8723bs: remove a couple of redundant initializations
      staging: comedi: reformat lines to 80 chars or less
      staging: lustre: separate a connection destroy from free struct kib_conn
      Staging: rtl8723bs: Use !x instead of NULL comparison
      Staging: rtl8723bs: Remove dead code
      Staging: rtl8723bs: Change names to conform to the kernel code
      staging: ccree: Fix missing blank line after declaration
      staging: rtl8188eu: remove redundant initialization of 'pwrcfgcmd'
      staging: rtlwifi: remove unused RTLHALMAC_ST and RTLPHYDM_ST
      staging: fbtft: remove unused FB_TFT_SSD1325 kconfig
      staging: comedi: dt2811: remove redundant initialization of 'ns'
      staging: wilc1000: fix alignments to match open parenthesis
      staging: wilc1000: removed unnecessary defined enums typedef
      staging: wilc1000: remove unnecessary use of parentheses
      staging: rtl8192u: remove redundant initialization of 'timeout'
      staging: sm750fb: fix CamelCase for dispSet var
      staging: lustre: lnet/selftest: fix compile error on UP build
      staging: rtl8723bs: hal_com_phycfg: Remove unneeded semicolons
      staging: rts5208: Fix "seg_no" calculation in reset_ms_card()
      ...

commit afc9a42b7464f76e1388cad87d8543c69f6f74ed
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 3 06:39:46 2017 -0400

    the rest of drivers/*: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e19e395b0e44..491b54d986eb 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2276,9 +2276,9 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	return retval;
 }
 
-static unsigned int comedi_poll(struct file *file, poll_table *wait)
+static __poll_t comedi_poll(struct file *file, poll_table *wait)
 {
-	unsigned int mask = 0;
+	__poll_t mask = 0;
 	struct comedi_file *cfp = file->private_data;
 	struct comedi_device *dev = cfp->dev;
 	struct comedi_subdevice *s, *s_read;

commit f814e74c9b5f37f22fe28acc1989566b99adb170
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:45 2017 +0100

    staging: comedi: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index da7999777d39..4dbefc767e1b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -5,16 +5,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 1997-2000 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e19e395b0e44..da7999777d39 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * comedi/comedi_fops.c
  * comedi kernel module

commit e4f857f739fbd15fd36f10e7caab95779c1dc1e4
Author: Bryan Garza <bry@riseup.net>
Date:   Wed Aug 23 22:37:00 2017 +0000

    Staging: comedi: comedi_fops: fix dev_err() warning style
    
    Changed dev_err() call to use function name constant instead of hardcoded
    string. Issue found by checkpatch.
    
    Signed-off-by: Bryan Garza <bry@riseup.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 34ca7823255d..e19e395b0e44 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -745,7 +745,7 @@ static void do_become_nonbusy(struct comedi_device *dev,
 		wake_up_interruptible_all(&async->wait_head);
 	} else {
 		dev_err(dev->class_dev,
-			"BUG: (?) do_become_nonbusy called with async=NULL\n");
+			"BUG: (?) %s called with async=NULL\n", __func__);
 		s->busy = NULL;
 	}
 }

commit cef988642cdac44e910a27cb6e8166c96f86a0df
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jul 28 16:22:31 2017 +0100

    staging: comedi: comedi_fops: do not call blocking ops when !TASK_RUNNING
    
    Comedi's read and write file operation handlers (`comedi_read()` and
    `comedi_write()`) currently call `copy_to_user()` or `copy_from_user()`
    whilst in the `TASK_INTERRUPTIBLE` state, which falls foul of the
    `might_fault()` checks when enabled.  Fix it by setting the current task
    state back to `TASK_RUNNING` a bit earlier before calling these
    functions.
    
    Reported-by: Piotr Gregor <piotrgregor@rsyncme.org>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: <stable@vger.kernel.org> # 4.5+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ca11be21f64b..34ca7823255d 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2396,6 +2396,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 			continue;
 		}
 
+		set_current_state(TASK_RUNNING);
 		wp = async->buf_write_ptr;
 		n1 = min(n, async->prealloc_bufsz - wp);
 		n2 = n - n1;
@@ -2528,6 +2529,8 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 			}
 			continue;
 		}
+
+		set_current_state(TASK_RUNNING);
 		rp = async->buf_read_ptr;
 		n1 = min(n, async->prealloc_bufsz - rp);
 		n2 = n - n1;

commit 125178d1ebd6d76a5fb152cfb3cd50a3316cf3ba
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 16 19:35:35 2017 +0100

    staging: comedi: use centralized error clean-up in comedi_init()
    
    Centralize the "clean-up on error" handling in `comedi_init()` using
    `goto` statements.  Also change some of the explicit `-EIO` return
    values to the error return values from the failing functions as there is
    no good reason to use `-EIO` explicitly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 4ed485a99c68..ca11be21f64b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2881,29 +2881,25 @@ static int __init comedi_init(void)
 	retval = register_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 					COMEDI_NUM_MINORS, "comedi");
 	if (retval)
-		return -EIO;
+		return retval;
+
 	cdev_init(&comedi_cdev, &comedi_fops);
 	comedi_cdev.owner = THIS_MODULE;
 
 	retval = kobject_set_name(&comedi_cdev.kobj, "comedi");
-	if (retval) {
-		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-					 COMEDI_NUM_MINORS);
-		return retval;
-	}
+	if (retval)
+		goto out_unregister_chrdev_region;
+
+	retval = cdev_add(&comedi_cdev, MKDEV(COMEDI_MAJOR, 0),
+			  COMEDI_NUM_MINORS);
+	if (retval)
+		goto out_unregister_chrdev_region;
 
-	if (cdev_add(&comedi_cdev, MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS)) {
-		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-					 COMEDI_NUM_MINORS);
-		return -EIO;
-	}
 	comedi_class = class_create(THIS_MODULE, "comedi");
 	if (IS_ERR(comedi_class)) {
+		retval = PTR_ERR(comedi_class);
 		pr_err("failed to create class\n");
-		cdev_del(&comedi_cdev);
-		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-					 COMEDI_NUM_MINORS);
-		return PTR_ERR(comedi_class);
+		goto out_cdev_del;
 	}
 
 	comedi_class->dev_groups = comedi_dev_groups;
@@ -2914,12 +2910,8 @@ static int __init comedi_init(void)
 
 		dev = comedi_alloc_board_minor(NULL);
 		if (IS_ERR(dev)) {
-			comedi_cleanup_board_minors();
-			class_destroy(comedi_class);
-			cdev_del(&comedi_cdev);
-			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-						 COMEDI_NUM_MINORS);
-			return PTR_ERR(dev);
+			retval = PTR_ERR(dev);
+			goto out_cleanup_board_minors;
 		}
 		/* comedi_alloc_board_minor() locked the mutex */
 		mutex_unlock(&dev->mutex);
@@ -2929,6 +2921,15 @@ static int __init comedi_init(void)
 	comedi_proc_init();
 
 	return 0;
+
+out_cleanup_board_minors:
+	comedi_cleanup_board_minors();
+	class_destroy(comedi_class);
+out_cdev_del:
+	cdev_del(&comedi_cdev);
+out_unregister_chrdev_region:
+	unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);
+	return retval;
 }
 module_init(comedi_init);
 

commit a9332e9ad09c2644c99058fcf6ae2f355e93ce74
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 16 19:35:34 2017 +0100

    staging: comedi: fix clean-up of comedi_class in comedi_init()
    
    There is a clean-up bug in the core comedi module initialization
    functions, `comedi_init()`.  If the `comedi_num_legacy_minors` module
    parameter is non-zero (and valid), it creates that many "legacy" devices
    and registers them in SysFS.  A failure causes the function to clean up
    and return an error.  Unfortunately, it fails to destroy the "comedi"
    class that was created earlier.  Fix it by adding a call to
    `class_destroy(comedi_class)` at the appropriate place in the clean-up
    sequence.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: <stable@vger.kernel.org> # 3.9+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f191c2a75732..4ed485a99c68 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2915,6 +2915,7 @@ static int __init comedi_init(void)
 		dev = comedi_alloc_board_minor(NULL);
 		if (IS_ERR(dev)) {
 			comedi_cleanup_board_minors();
+			class_destroy(comedi_class);
 			cdev_del(&comedi_cdev);
 			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 						 COMEDI_NUM_MINORS);

commit 255364f7b8a0fee3fb642b3e1521e943dd67bfb3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 20 19:05:14 2017 +0100

    staging: comedi: support vm_access_process for mmap'd buffer
    
    If a process that has mmap'd a COMEDI buffer is being run under a
    debugger such as GDB, the buffer contents are inaccessible from the
    debugger.  Support the `access()` VM operation to allow the buffer
    contents to be accessed by another process.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 92d864fc08ac..f191c2a75732 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2165,9 +2165,24 @@ static void comedi_vm_close(struct vm_area_struct *area)
 	comedi_buf_map_put(bm);
 }
 
+static int comedi_vm_access(struct vm_area_struct *vma, unsigned long addr,
+			    void *buf, int len, int write)
+{
+	struct comedi_buf_map *bm = vma->vm_private_data;
+	unsigned long offset =
+	    addr - vma->vm_start + (vma->vm_pgoff << PAGE_SHIFT);
+
+	if (len < 0)
+		return -EINVAL;
+	if (len > vma->vm_end - addr)
+		len = vma->vm_end - addr;
+	return comedi_buf_map_access(bm, offset, buf, len, write);
+}
+
 static const struct vm_operations_struct comedi_vm_ops = {
 	.open = comedi_vm_open,
 	.close = comedi_vm_close,
+	.access = comedi_vm_access,
 };
 
 static int comedi_mmap(struct file *file, struct vm_area_struct *vma)

commit d1d78d20800f8e1bd41518d45d5a3d604d9b1040
Author: Cheah Kok Cheong <thrust73@gmail.com>
Date:   Wed Mar 8 02:13:58 2017 +0800

    Staging: comedi: comedi_fops: Change comedi_num_legacy_minors type
    
    Change to unsigned to allow removal of negative value check in
    init section. Use smaller data type since the max possible
    value currently is 48.
    
    Signed-off-by: Cheah Kok Cheong <thrust73@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 8deac8d9225d..92d864fc08ac 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -76,8 +76,8 @@ struct comedi_file {
 #define COMEDI_NUM_SUBDEVICE_MINORS	\
 	(COMEDI_NUM_MINORS - COMEDI_NUM_BOARD_MINORS)
 
-static int comedi_num_legacy_minors;
-module_param(comedi_num_legacy_minors, int, 0444);
+static unsigned short comedi_num_legacy_minors;
+module_param(comedi_num_legacy_minors, ushort, 0444);
 MODULE_PARM_DESC(comedi_num_legacy_minors,
 		 "number of comedi minor devices to reserve for non-auto-configured devices (default 0)"
 		);
@@ -2857,8 +2857,7 @@ static int __init comedi_init(void)
 
 	pr_info("version " COMEDI_RELEASE " - http://www.comedi.org\n");
 
-	if (comedi_num_legacy_minors < 0 ||
-	    comedi_num_legacy_minors > COMEDI_NUM_BOARD_MINORS) {
+	if (comedi_num_legacy_minors > COMEDI_NUM_BOARD_MINORS) {
 		pr_err("invalid value for module parameter \"comedi_num_legacy_minors\".  Valid values are 0 through %i.\n",
 		       COMEDI_NUM_BOARD_MINORS);
 		return -EINVAL;

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 57e8599b54e6..8deac8d9225d 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -23,7 +23,7 @@
 #include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
+#include <linux/sched/signal.h>
 #include <linux/fcntl.h>
 #include <linux/delay.h>
 #include <linux/mm.h>

commit 5dc6f89da13cdcf85996455b8e8618fe81de5a4b
Author: Cheah Kok Cheong <thrust73@gmail.com>
Date:   Sat Jan 7 19:13:12 2017 +0800

    Staging: comedi: comedi_fops: Remove unused stat.h header
    
    Unused after commit 6e3029397698 ("staging: comedi: comedi_fops:
    coding style fixes") - Fixed coding style in comedi_fops.c
    Symbolic to octal permission.
    
    Anyway it's included in module.h
    
    Signed-off-by: Cheah Kok Cheong <thrust73@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 859a28e50395..57e8599b54e6 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -33,7 +33,6 @@
 #include <linux/fs.h>
 #include "comedidev.h"
 #include <linux/cdev.h>
-#include <linux/stat.h>
 
 #include <linux/io.h>
 #include <linux/uaccess.h>

commit 38d14bdbe74d644f98f203ffcfe68ccc12a9fb35
Author: Cheah Kok Cheong <thrust73@gmail.com>
Date:   Sat Jan 7 19:13:11 2017 +0800

    Staging: comedi: comedi_fops: Remove unused vmalloc.h header
    
    Unused after commit d18431325be0 ("staging: comedi:
    deprecate loading firmware with comedi_config").
    
    Signed-off-by: Cheah Kok Cheong <thrust73@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 622ad0cc65df..859a28e50395 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -30,7 +30,6 @@
 #include <linux/slab.h>
 #include <linux/poll.h>
 #include <linux/device.h>
-#include <linux/vmalloc.h>
 #include <linux/fs.h>
 #include "comedidev.h"
 #include <linux/cdev.h>

commit 7bfe956c78b07d072df6b78b82417a11dff52bb7
Author: Cheah Kok Cheong <thrust73@gmail.com>
Date:   Sat Jan 7 19:13:10 2017 +0800

    Staging: comedi: comedi_fops: Remove redundant init.h header
    
    After commit 0fd972a7d91d ("module: relocate module_init
    from init.h to module.h"), including module.h will do and
    init.h is also thrown in.
    
    Signed-off-by: Cheah Kok Cheong <thrust73@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 268a91133745..622ad0cc65df 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -29,7 +29,6 @@
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/poll.h>
-#include <linux/init.h>
 #include <linux/device.h>
 #include <linux/vmalloc.h>
 #include <linux/fs.h>

commit 79adc3577e6d3c03e0ccf6b9f5a4731207ca1ea7
Author: Cheah Kok Cheong <thrust73@gmail.com>
Date:   Sat Jan 7 19:13:09 2017 +0800

    Staging: comedi: comedi_fops: Remove unused kmod.h header
    
    Unused after commit f30f2c2d417b ("staging: comedi:
    remove check for CONFIG_KMOD").
    
    Anyway it's included in module.h
    
    Signed-off-by: Cheah Kok Cheong <thrust73@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 02df354cf996..268a91133745 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -28,7 +28,6 @@
 #include <linux/delay.h>
 #include <linux/mm.h>
 #include <linux/slab.h>
-#include <linux/kmod.h>
 #include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/device.h>

commit bf279ece37d2a3eaaa9813fcd7a1d8a81eb29c20
Author: Cheah Kok Cheong <thrust73@gmail.com>
Date:   Fri Dec 30 19:25:52 2016 +0800

    Staging: comedi: comedi_fops: Avoid orphaned proc entry
    
    Move comedi_proc_init to the end to avoid orphaned proc entry
    if module loading failed.
    
    Signed-off-by: Cheah Kok Cheong <thrust73@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 64b3966c5f1f..02df354cf996 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2898,9 +2898,6 @@ static int __init comedi_init(void)
 
 	comedi_class->dev_groups = comedi_dev_groups;
 
-	/* XXX requires /proc interface */
-	comedi_proc_init();
-
 	/* create devices files for legacy/manual use */
 	for (i = 0; i < comedi_num_legacy_minors; i++) {
 		struct comedi_device *dev;
@@ -2917,6 +2914,9 @@ static int __init comedi_init(void)
 		mutex_unlock(&dev->mutex);
 	}
 
+	/* XXX requires /proc interface */
+	comedi_proc_init();
+
 	return 0;
 }
 module_init(comedi_init);

commit ec9d0754e0c64013278fda87d1bd6b8318747abe
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Tue Sep 20 03:21:38 2016 +0530

    staging: comedi: Use vma_pages function on vma object instead of explicit computation
    
    This patch uses vma_pages function on vma object instead of explicit
    computation.
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index bf922eafe07c..64b3966c5f1f 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2233,7 +2233,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 		goto done;
 	}
 
-	n_pages = size >> PAGE_SHIFT;
+	n_pages = vma_pages(vma);
 
 	/* get reference to current buf map (if any) */
 	bm = comedi_buf_map_from_subdev_get(s);

commit 6e30293976983daf09eea8e882d48a09c80d5987
Author: Matias Mucciolo <mmucciolo@suteba.org.ar>
Date:   Mon Sep 12 10:18:59 2016 -0300

    staging: comedi: comedi_fops: coding style fixes
    
    - Fixed coding style in comedi_fops.c Symbolic to octal permission.
    
    Signed-off-by: Matias Mucciolo <mmucciolo@suteba.org.ar>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1999eed4f4c5..bf922eafe07c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -81,20 +81,20 @@ struct comedi_file {
 	(COMEDI_NUM_MINORS - COMEDI_NUM_BOARD_MINORS)
 
 static int comedi_num_legacy_minors;
-module_param(comedi_num_legacy_minors, int, S_IRUGO);
+module_param(comedi_num_legacy_minors, int, 0444);
 MODULE_PARM_DESC(comedi_num_legacy_minors,
 		 "number of comedi minor devices to reserve for non-auto-configured devices (default 0)"
 		);
 
 unsigned int comedi_default_buf_size_kb = CONFIG_COMEDI_DEFAULT_BUF_SIZE_KB;
-module_param(comedi_default_buf_size_kb, uint, S_IRUGO | S_IWUSR);
+module_param(comedi_default_buf_size_kb, uint, 0644);
 MODULE_PARM_DESC(comedi_default_buf_size_kb,
 		 "default asynchronous buffer size in KiB (default "
 		 __MODULE_STRING(CONFIG_COMEDI_DEFAULT_BUF_SIZE_KB) ")");
 
 unsigned int comedi_default_buf_maxsize_kb
 	= CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB;
-module_param(comedi_default_buf_maxsize_kb, uint, S_IRUGO | S_IWUSR);
+module_param(comedi_default_buf_maxsize_kb, uint, 0644);
 MODULE_PARM_DESC(comedi_default_buf_maxsize_kb,
 		 "default maximum size of asynchronous buffer in KiB (default "
 		 __MODULE_STRING(CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB) ")");

commit 70db384cd6dd780a32197c194ad41735630d265e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jun 17 21:56:15 2016 +0200

    staging: comedi: avoid using timeval
    
    Comedi uses 32-bit seconds for its timestamps, on both 32-bit and
    64-bit machines. For all I can tell, this was originally meant as
    a 'timespec', which would overflow in 2038 because of the use of
    a signed 'long' on 32-bit machines, but it is now used as an
    array of two unsigned 'lsampl_t' values in comedilib, which will
    only overflow in 2106, on both 32-bit and 64-bit machines.
    
    In an effort to get rid of all uses of 'struct timeval' in the kernel,
    this replaces the internal code with a call to ktime_get_real_ts64()
    and a comment at the location of the conversion.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 4d87596137ed..1999eed4f4c5 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1256,16 +1256,17 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 		switch (insn->insn) {
 		case INSN_GTOD:
 			{
-				struct timeval tv;
+				struct timespec64 tv;
 
 				if (insn->n != 2) {
 					ret = -EINVAL;
 					break;
 				}
 
-				do_gettimeofday(&tv);
-				data[0] = tv.tv_sec;
-				data[1] = tv.tv_usec;
+				ktime_get_real_ts64(&tv);
+				/* unsigned data safe until 2106 */
+				data[0] = (unsigned int)tv.tv_sec;
+				data[1] = tv.tv_nsec / NSEC_PER_USEC;
 				ret = 2;
 
 				break;

commit 34d3473263250c4c0883d7d6d95e8f122d8d348d
Author: Shyam Saini <mayhs11saini@gmail.com>
Date:   Tue May 10 21:21:07 2016 +0530

    Staging: comedi: comedi_fops.c: Fixed coding style issue
    
    Fixed following checkpatch.pl warnings
    WARNING: Prefer WRITE_ONCE(<FOO>, <BAR>) over ACCESS_ONCE(<FOO>) = <BAR>
    
    WARNING: Prefer READ_ONCE(<FOO>) over ACCESS_ONCE(<FOO>)
    
    Signed-off-by: Shyam Saini <mayhs11saini@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 629080f39db0..4d87596137ed 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -312,8 +312,8 @@ static void comedi_file_reset(struct file *file)
 	}
 	cfp->last_attached = dev->attached;
 	cfp->last_detach_count = dev->detach_count;
-	ACCESS_ONCE(cfp->read_subdev) = read_s;
-	ACCESS_ONCE(cfp->write_subdev) = write_s;
+	WRITE_ONCE(cfp->read_subdev, read_s);
+	WRITE_ONCE(cfp->write_subdev, write_s);
 }
 
 static void comedi_file_check(struct file *file)
@@ -331,7 +331,7 @@ static struct comedi_subdevice *comedi_file_read_subdevice(struct file *file)
 	struct comedi_file *cfp = file->private_data;
 
 	comedi_file_check(file);
-	return ACCESS_ONCE(cfp->read_subdev);
+	return READ_ONCE(cfp->read_subdev);
 }
 
 static struct comedi_subdevice *comedi_file_write_subdevice(struct file *file)
@@ -339,7 +339,7 @@ static struct comedi_subdevice *comedi_file_write_subdevice(struct file *file)
 	struct comedi_file *cfp = file->private_data;
 
 	comedi_file_check(file);
-	return ACCESS_ONCE(cfp->write_subdev);
+	return READ_ONCE(cfp->write_subdev);
 }
 
 static int resize_async_buffer(struct comedi_device *dev,
@@ -1992,7 +1992,7 @@ static int do_setrsubd_ioctl(struct comedi_device *dev, unsigned long arg,
 	    !(s_old->async->cmd.flags & CMDF_WRITE))
 		return -EBUSY;
 
-	ACCESS_ONCE(cfp->read_subdev) = s_new;
+	WRITE_ONCE(cfp->read_subdev, s_new);
 	return 0;
 }
 
@@ -2034,7 +2034,7 @@ static int do_setwsubd_ioctl(struct comedi_device *dev, unsigned long arg,
 	    (s_old->async->cmd.flags & CMDF_WRITE))
 		return -EBUSY;
 
-	ACCESS_ONCE(cfp->write_subdev) = s_new;
+	WRITE_ONCE(cfp->write_subdev, s_new);
 	return 0;
 }
 

commit b2073dcb80b61043f6ae6aeb2311907b0418392a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 29 10:49:04 2016 +0100

    staging: comedi: comedi_fops.c: fix lines over 80 characters
    
    Fix checkpatch.pl warnings about lines over 80 characters in
    "comedi_fops.c".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 4bdea202c46c..629080f39db0 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -209,8 +209,8 @@ static void comedi_free_board_dev(struct comedi_device *dev)
 	}
 }
 
-static struct comedi_subdevice
-*comedi_subdevice_from_minor(const struct comedi_device *dev, unsigned int minor)
+static struct comedi_subdevice *
+comedi_subdevice_from_minor(const struct comedi_device *dev, unsigned int minor)
 {
 	struct comedi_subdevice *s;
 	unsigned int i = minor - COMEDI_NUM_BOARD_MINORS;
@@ -233,7 +233,8 @@ static struct comedi_device *comedi_dev_get_from_board_minor(unsigned int minor)
 	return dev;
 }
 
-static struct comedi_device *comedi_dev_get_from_subdevice_minor(unsigned int minor)
+static struct comedi_device *
+comedi_dev_get_from_subdevice_minor(unsigned int minor)
 {
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
@@ -342,7 +343,8 @@ static struct comedi_subdevice *comedi_file_write_subdevice(struct file *file)
 }
 
 static int resize_async_buffer(struct comedi_device *dev,
-			       struct comedi_subdevice *s, unsigned int new_size)
+			       struct comedi_subdevice *s,
+			       unsigned int new_size)
 {
 	struct comedi_async *async = s->async;
 	int retval;
@@ -628,7 +630,8 @@ static void __comedi_set_subdevice_runflags(struct comedi_subdevice *s,
 }
 
 static void comedi_update_subdevice_runflags(struct comedi_subdevice *s,
-					     unsigned int mask, unsigned int bits)
+					     unsigned int mask,
+					     unsigned int bits)
 {
 	unsigned long flags;
 
@@ -2485,7 +2488,8 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		n = min_t(size_t, m, nbytes);
 
 		if (n == 0) {
-			unsigned int runflags = comedi_get_subdevice_runflags(s);
+			unsigned int runflags =
+				     comedi_get_subdevice_runflags(s);
 
 			if (!comedi_is_runflags_running(runflags)) {
 				if (comedi_is_runflags_in_error(runflags))

commit d4d47895a906779b5e8df157f703f906d22305b5
Author: Leslie Klein <lesliebklein@gmail.com>
Date:   Mon Mar 21 09:18:35 2016 -0400

    Staging: comedi: comedi_fops: Replace 'unsigned' with 'unsigned int'
    
    Fix checkpatch warning:
    Prefer 'unsigned int' to bare use of 'unsigned'
    in file comedi_fops.c
    
    Signed-off-by: Leslie Klein <lesliebklein@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 7c7b477b0f28..4bdea202c46c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -186,7 +186,7 @@ static bool comedi_clear_board_dev(struct comedi_device *dev)
 	return cleared;
 }
 
-static struct comedi_device *comedi_clear_board_minor(unsigned minor)
+static struct comedi_device *comedi_clear_board_minor(unsigned int minor)
 {
 	struct comedi_device *dev;
 
@@ -210,7 +210,7 @@ static void comedi_free_board_dev(struct comedi_device *dev)
 }
 
 static struct comedi_subdevice
-*comedi_subdevice_from_minor(const struct comedi_device *dev, unsigned minor)
+*comedi_subdevice_from_minor(const struct comedi_device *dev, unsigned int minor)
 {
 	struct comedi_subdevice *s;
 	unsigned int i = minor - COMEDI_NUM_BOARD_MINORS;
@@ -223,7 +223,7 @@ static struct comedi_subdevice
 	return s;
 }
 
-static struct comedi_device *comedi_dev_get_from_board_minor(unsigned minor)
+static struct comedi_device *comedi_dev_get_from_board_minor(unsigned int minor)
 {
 	struct comedi_device *dev;
 
@@ -233,7 +233,7 @@ static struct comedi_device *comedi_dev_get_from_board_minor(unsigned minor)
 	return dev;
 }
 
-static struct comedi_device *comedi_dev_get_from_subdevice_minor(unsigned minor)
+static struct comedi_device *comedi_dev_get_from_subdevice_minor(unsigned int minor)
 {
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
@@ -258,7 +258,7 @@ static struct comedi_device *comedi_dev_get_from_subdevice_minor(unsigned minor)
  * reference incremented.  Return NULL if no COMEDI device exists with the
  * specified minor device number.
  */
-struct comedi_device *comedi_dev_get_from_minor(unsigned minor)
+struct comedi_device *comedi_dev_get_from_minor(unsigned int minor)
 {
 	if (minor < COMEDI_NUM_BOARD_MINORS)
 		return comedi_dev_get_from_board_minor(minor);
@@ -342,7 +342,7 @@ static struct comedi_subdevice *comedi_file_write_subdevice(struct file *file)
 }
 
 static int resize_async_buffer(struct comedi_device *dev,
-			       struct comedi_subdevice *s, unsigned new_size)
+			       struct comedi_subdevice *s, unsigned int new_size)
 {
 	struct comedi_async *async = s->async;
 	int retval;
@@ -616,19 +616,19 @@ static struct attribute *comedi_dev_attrs[] = {
 ATTRIBUTE_GROUPS(comedi_dev);
 
 static void __comedi_clear_subdevice_runflags(struct comedi_subdevice *s,
-					      unsigned bits)
+					      unsigned int bits)
 {
 	s->runflags &= ~bits;
 }
 
 static void __comedi_set_subdevice_runflags(struct comedi_subdevice *s,
-					    unsigned bits)
+					    unsigned int bits)
 {
 	s->runflags |= bits;
 }
 
 static void comedi_update_subdevice_runflags(struct comedi_subdevice *s,
-					     unsigned mask, unsigned bits)
+					     unsigned int mask, unsigned int bits)
 {
 	unsigned long flags;
 
@@ -638,15 +638,15 @@ static void comedi_update_subdevice_runflags(struct comedi_subdevice *s,
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 }
 
-static unsigned __comedi_get_subdevice_runflags(struct comedi_subdevice *s)
+static unsigned int __comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 {
 	return s->runflags;
 }
 
-static unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
+static unsigned int comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 {
 	unsigned long flags;
-	unsigned runflags;
+	unsigned int runflags;
 
 	spin_lock_irqsave(&s->spin_lock, flags);
 	runflags = __comedi_get_subdevice_runflags(s);
@@ -654,12 +654,12 @@ static unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 	return runflags;
 }
 
-static bool comedi_is_runflags_running(unsigned runflags)
+static bool comedi_is_runflags_running(unsigned int runflags)
 {
 	return runflags & COMEDI_SRF_RUNNING;
 }
 
-static bool comedi_is_runflags_in_error(unsigned runflags)
+static bool comedi_is_runflags_in_error(unsigned int runflags)
 {
 	return runflags & COMEDI_SRF_ERROR;
 }
@@ -673,7 +673,7 @@ static bool comedi_is_runflags_in_error(unsigned runflags)
  */
 bool comedi_is_subdevice_running(struct comedi_subdevice *s)
 {
-	unsigned runflags = comedi_get_subdevice_runflags(s);
+	unsigned int runflags = comedi_get_subdevice_runflags(s);
 
 	return comedi_is_runflags_running(runflags);
 }
@@ -681,14 +681,14 @@ EXPORT_SYMBOL_GPL(comedi_is_subdevice_running);
 
 static bool __comedi_is_subdevice_running(struct comedi_subdevice *s)
 {
-	unsigned runflags = __comedi_get_subdevice_runflags(s);
+	unsigned int runflags = __comedi_get_subdevice_runflags(s);
 
 	return comedi_is_runflags_running(runflags);
 }
 
 bool comedi_can_auto_free_spriv(struct comedi_subdevice *s)
 {
-	unsigned runflags = __comedi_get_subdevice_runflags(s);
+	unsigned int runflags = __comedi_get_subdevice_runflags(s);
 
 	return runflags & COMEDI_SRF_FREE_SPRIV;
 }
@@ -2038,7 +2038,7 @@ static int do_setwsubd_ioctl(struct comedi_device *dev, unsigned long arg,
 static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 				  unsigned long arg)
 {
-	unsigned minor = iminor(file_inode(file));
+	unsigned int minor = iminor(file_inode(file));
 	struct comedi_file *cfp = file->private_data;
 	struct comedi_device *dev = cfp->dev;
 	int rc;
@@ -2342,7 +2342,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 
 	add_wait_queue(&async->wait_head, &wait);
 	while (count == 0 && !retval) {
-		unsigned runflags;
+		unsigned int runflags;
 		unsigned int wp, n1, n2;
 
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -2485,7 +2485,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		n = min_t(size_t, m, nbytes);
 
 		if (n == 0) {
-			unsigned runflags = comedi_get_subdevice_runflags(s);
+			unsigned int runflags = comedi_get_subdevice_runflags(s);
 
 			if (!comedi_is_runflags_running(runflags)) {
 				if (comedi_is_runflags_in_error(runflags))
@@ -2573,7 +2573,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 
 static int comedi_open(struct inode *inode, struct file *file)
 {
-	const unsigned minor = iminor(inode);
+	const unsigned int minor = iminor(inode);
 	struct comedi_file *cfp;
 	struct comedi_device *dev = comedi_dev_get_from_minor(minor);
 	int rc;
@@ -2733,7 +2733,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 {
 	struct comedi_device *dev;
 	struct device *csdev;
-	unsigned i;
+	unsigned int i;
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev)
@@ -2791,7 +2791,7 @@ int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 {
 	struct comedi_device *dev = s->device;
 	struct device *csdev;
-	unsigned i;
+	unsigned int i;
 
 	mutex_lock(&comedi_subdevice_minor_table_lock);
 	for (i = 0; i < COMEDI_NUM_SUBDEVICE_MINORS; ++i) {
@@ -2841,7 +2841,7 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 static void comedi_cleanup_board_minors(void)
 {
 	struct comedi_device *dev;
-	unsigned i;
+	unsigned int i;
 
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
 		dev = comedi_clear_board_minor(i);

commit 44b8c793fc0d63060c6c87f0af4f9b367e2ec4fc
Author: Sandhya Bankar <bankarsandhya512@gmail.com>
Date:   Sun Mar 6 12:35:29 2016 +0530

    Staging: comedi: Use predefined macro offset_in_page() instead of (addr & ~PAGE_MASK).
    
    Use predefined macro offset_in_page() instead of (addr & ~PAGE_MASK).
    
    Signed-off-by: Sandhya Bankar <bankarsandhya512@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index d1cf6a1c92a4..7c7b477b0f28 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2224,7 +2224,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 		retval = -EFAULT;
 		goto done;
 	}
-	if (size & (~PAGE_MASK)) {
+	if (offset_in_page(size)) {
 		retval = -EFAULT;
 		goto done;
 	}

commit be611a1de3989bd03a09ae9fbfbacf19072169af
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 19 16:13:57 2016 +0000

    staging: comedi: COMEDI_BUFINFO: terminate "write" command when stopped
    
    The `COMEDI_BUFINFO` ioctl is used to advance the current position in
    the buffer by a specified amount (which can be 0) and get the current
    position.  An asynchronous command in the "read" direction is terminated
    automatically once it has stopped and information about the final
    position and error has been reported back to the user.  That is not
    currently done for commands in the "write" direction.  Change it to
    terminate the command in the "write" direction automatically.  If the
    command stopped with an error, report an `EPIPE` error back to the user,
    otherwise just report the final buffer position back to the user.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 7cb1d06a8124..d1cf6a1c92a4 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1121,6 +1121,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	if (!async || s->busy != file)
 		return -EINVAL;
 
+	runflags = comedi_get_subdevice_runflags(s);
 	if (!(async->cmd.flags & CMDF_WRITE)) {
 		/* command was set up in "read" direction */
 		if (bi.bytes_read) {
@@ -1132,7 +1133,6 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		 * {"read" position not updated or command stopped normally},
 		 * then become non-busy.
 		 */
-		runflags = comedi_get_subdevice_runflags(s);
 		if (comedi_buf_read_n_available(s) == 0 &&
 		    !comedi_is_runflags_running(runflags) &&
 		    (bi.bytes_read == 0 ||
@@ -1144,9 +1144,12 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		bi.bytes_written = 0;
 	} else {
 		/* command was set up in "write" direction */
-		if (!comedi_is_subdevice_running(s))
+		if (!comedi_is_runflags_running(runflags)) {
 			bi.bytes_written = 0;
-		if (bi.bytes_written) {
+			become_nonbusy = true;
+			if (comedi_is_runflags_in_error(runflags))
+				retval = -EPIPE;
+		} else if (bi.bytes_written) {
 			comedi_buf_write_alloc(s, bi.bytes_written);
 			bi.bytes_written =
 			    comedi_buf_write_free(s, bi.bytes_written);

commit 36a5117018a19d3694f841d91b6b8430260756e1
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 19 16:13:56 2016 +0000

    staging: comedi: COMEDI_BUFINFO: return -EPIPE for abnormal read
    
    The `COMEDI_BUFINFO` ioctl is used to advance the current position in
    the buffer by a specified amount (which can be 0) and get the current
    position.  If an asynchronous command in the "read" direction has
    stopped normally, the command is terminated as soon as the position has
    been advanced to the end of all available data.  This is not currently
    done if the command terminated with an error.  Change it to allow the
    command to be terminated even if it stopped with an error, but report an
    `EPIPE` error to the user first.  The `EPIPE` error will not be
    reported until the "read" position reported back to the user has been
    advanced to the end of all available data.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ffe58208869e..7cb1d06a8124 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -686,13 +686,6 @@ static bool __comedi_is_subdevice_running(struct comedi_subdevice *s)
 	return comedi_is_runflags_running(runflags);
 }
 
-static bool comedi_is_subdevice_idle(struct comedi_subdevice *s)
-{
-	unsigned runflags = comedi_get_subdevice_runflags(s);
-
-	return !(runflags & COMEDI_SRF_BUSY_MASK);
-}
-
 bool comedi_can_auto_free_spriv(struct comedi_subdevice *s)
 {
 	unsigned runflags = __comedi_get_subdevice_runflags(s);
@@ -1111,6 +1104,8 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	struct comedi_bufinfo bi;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
+	unsigned int runflags;
+	int retval = 0;
 	bool become_nonbusy = false;
 
 	if (copy_from_user(&bi, arg, sizeof(bi)))
@@ -1132,9 +1127,20 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 			comedi_buf_read_alloc(s, bi.bytes_read);
 			bi.bytes_read = comedi_buf_read_free(s, bi.bytes_read);
 		}
-		if (comedi_is_subdevice_idle(s) &&
-		    comedi_buf_read_n_available(s) == 0)
+		/*
+		 * If nothing left to read, and command has stopped, and
+		 * {"read" position not updated or command stopped normally},
+		 * then become non-busy.
+		 */
+		runflags = comedi_get_subdevice_runflags(s);
+		if (comedi_buf_read_n_available(s) == 0 &&
+		    !comedi_is_runflags_running(runflags) &&
+		    (bi.bytes_read == 0 ||
+		     !comedi_is_runflags_in_error(runflags))) {
 			become_nonbusy = true;
+			if (comedi_is_runflags_in_error(runflags))
+				retval = -EPIPE;
+		}
 		bi.bytes_written = 0;
 	} else {
 		/* command was set up in "write" direction */
@@ -1156,6 +1162,9 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	if (become_nonbusy)
 		do_become_nonbusy(dev, s);
 
+	if (retval)
+		return retval;
+
 	if (copy_to_user(arg, &bi, sizeof(bi)))
 		return -EFAULT;
 

commit f3aa8c0becfb1d968e552721cc1be8b91032539b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 19 16:13:55 2016 +0000

    staging: comedi: COMEDI_BUFINFO: become non-busy even if bytes_read is 0
    
    The `COMEDI_BUFINFO` ioctl is used to advance the current position in
    the buffer by a specified amount (which can be 0) and get the new
    position.  On input, the `bytes_read` member of `struct comedi_bufinfo`
    specified the amount to advance the "read" position for an asynchronous
    command in the "read" direction.  If the command has already stopped
    normally, and the "read" position has been advanced to the end of all
    available data, the command is terminated by calling
    `do_become_nonbusy()`.  (That is not currently done if the command
    stopped with an error.)  Currently, the command is only terminated if
    the user is trying to advance the "read" position by a non-zero amount.
    Change it to allow the command to be terminated even if the user is not
    trying to advance the "read" position.  This is justifiable, as the only
    time a command stops without error is when it has been set up to read a
    finite amount of data.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a9fabf7a1000..ffe58208869e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1131,11 +1131,10 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		if (bi.bytes_read) {
 			comedi_buf_read_alloc(s, bi.bytes_read);
 			bi.bytes_read = comedi_buf_read_free(s, bi.bytes_read);
-
-			if (comedi_is_subdevice_idle(s) &&
-			    comedi_buf_read_n_available(s) == 0)
-				become_nonbusy = true;
 		}
+		if (comedi_is_subdevice_idle(s) &&
+		    comedi_buf_read_n_available(s) == 0)
+			become_nonbusy = true;
 		bi.bytes_written = 0;
 	} else {
 		/* command was set up in "write" direction */

commit 57c563bf78f50d8a43e7ffe0087bc43dc0f188aa
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 19 16:13:54 2016 +0000

    staging: comedi: COMEDI_BUFINFO: return error if no active command
    
    The `COMEDI_BUFINFO` ioctl is used to advance the current position in
    the buffer and/or get the current buffer position.  If no asynchronous
    command is active (started via the file object that issued this ioctl),
    this information is meaningless.  Change it to return an error
    (`-EINVAL`) in this case.  Prior to this change, if a command was
    started via a different file object, the ioctl returned `-EACCES`, but
    now it will return `-EINVAL`, which is consistent with the current
    behavior of the "read" and "write" file operation handlers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b7c9270f9e92..a9fabf7a1000 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1123,24 +1123,8 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 
 	async = s->async;
 
-	if (!async) {
-		dev_dbg(dev->class_dev,
-			"subdevice does not have async capability\n");
-		bi.buf_write_ptr = 0;
-		bi.buf_read_ptr = 0;
-		bi.buf_write_count = 0;
-		bi.buf_read_count = 0;
-		bi.bytes_read = 0;
-		bi.bytes_written = 0;
-		goto copyback;
-	}
-	if (!s->busy) {
-		bi.bytes_read = 0;
-		bi.bytes_written = 0;
-		goto copyback_position;
-	}
-	if (s->busy != file)
-		return -EACCES;
+	if (!async || s->busy != file)
+		return -EINVAL;
 
 	if (!(async->cmd.flags & CMDF_WRITE)) {
 		/* command was set up in "read" direction */
@@ -1165,7 +1149,6 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		bi.bytes_read = 0;
 	}
 
-copyback_position:
 	bi.buf_write_count = async->buf_write_count;
 	bi.buf_write_ptr = async->buf_write_ptr;
 	bi.buf_read_count = async->buf_read_count;
@@ -1174,7 +1157,6 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	if (become_nonbusy)
 		do_become_nonbusy(dev, s);
 
-copyback:
 	if (copy_to_user(arg, &bi, sizeof(bi)))
 		return -EFAULT;
 

commit bb0c6bfac7d4aebb6525b285ca03c4316d72647a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 19 16:13:53 2016 +0000

    staging: comedi: COMEDI_BUFINFO: force bytes_written to 0 if stopped
    
    The `COMEDI_BUFINFO` ioctl is used to advance the current position in
    the buffer by a specified amount (which can be 0) and get the new
    position.  On input, the `bytes_written` member of `struct
    comedi_bufinfo` specifies the amount to advance the "write" position for
    an asynchronous command in the "write" direction.  On output, the member
    indicates the amount the "write" position has actually been advanced.
    Advancing the "write" position is current done even if the command has
    stopped and cannot use any more written data.  Change it to force the
    amount successfully written to 0 in that case.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e625ef2bcb7f..b7c9270f9e92 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1155,6 +1155,8 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		bi.bytes_written = 0;
 	} else {
 		/* command was set up in "write" direction */
+		if (!comedi_is_subdevice_running(s))
+			bi.bytes_written = 0;
 		if (bi.bytes_written) {
 			comedi_buf_write_alloc(s, bi.bytes_written);
 			bi.bytes_written =

commit 065785618c6712a39262e4183efce616f895e5ad
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 19 16:13:52 2016 +0000

    staging: comedi: COMEDI_BUFINFO: update buffer before becoming non-busy
    
    The `COMEDI_BUFINFO` ioctl is used to advance the current position in
    the buffer by a specified amount (which can be 0) and get the new
    position.  For an asynchronous command in the "read" direction, if the
    command has finished acquiring data normally, `do_become_nonbusy()` is
    called to terminate the command.  That resets the buffer position, and
    currently, the position information returned back to the user is after
    the buffer has been reset.  It should be more useful to return the
    buffer position before the reset, so move the call to
    `do_become_nonbusy()` after the code that gets the updated buffer
    position.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 04d6040246ee..e625ef2bcb7f 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1111,6 +1111,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	struct comedi_bufinfo bi;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
+	bool become_nonbusy = false;
 
 	if (copy_from_user(&bi, arg, sizeof(bi)))
 		return -EFAULT;
@@ -1149,7 +1150,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 
 			if (comedi_is_subdevice_idle(s) &&
 			    comedi_buf_read_n_available(s) == 0)
-				do_become_nonbusy(dev, s);
+				become_nonbusy = true;
 		}
 		bi.bytes_written = 0;
 	} else {
@@ -1168,6 +1169,9 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	bi.buf_read_count = async->buf_read_count;
 	bi.buf_read_ptr = async->buf_read_ptr;
 
+	if (become_nonbusy)
+		do_become_nonbusy(dev, s);
+
 copyback:
 	if (copy_to_user(arg, &bi, sizeof(bi)))
 		return -EFAULT;

commit 66c365026b18132b8d743254f0910be37565c5fa
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 19 16:13:51 2016 +0000

    staging: comedi: COMEDI_BUFINFO: force bytes_read or bytes_written to 0
    
    The `COMEDI_BUFINFO` ioctl is used to advance the current position in
    the buffer by a specified amount (which can be 0) and get the new
    position.  On input, the `bytes_read` member of `struct comedi_bufinfo`
    specifies the amount to advance the "read" position for an asynchronous
    command in the "read" direction, and the `bytes_written` member
    specifies the amount to advance the "write" position for a command in
    the "write" direction.  The handler `do_bufinfo_ioctl()` may adjust
    these by the amount the position is actually advanced before copying
    them back to the user.  Currently, it ignores the specified `bytes_read`
    value for a command in the "write" direction, and ignores the specified
    `bytes_written` for a command in the "read" direction, so the values
    copied back to the user are unchanged.  Change it to force the ignored
    value to 0 before copying the values back to the user.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 2cfb61e0f2b8..04d6040246ee 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1141,19 +1141,25 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	if (s->busy != file)
 		return -EACCES;
 
-	if (bi.bytes_read && !(async->cmd.flags & CMDF_WRITE)) {
-		comedi_buf_read_alloc(s, bi.bytes_read);
-		bi.bytes_read = comedi_buf_read_free(s, bi.bytes_read);
-
-		if (comedi_is_subdevice_idle(s) &&
-		    comedi_buf_read_n_available(s) == 0) {
-			do_become_nonbusy(dev, s);
+	if (!(async->cmd.flags & CMDF_WRITE)) {
+		/* command was set up in "read" direction */
+		if (bi.bytes_read) {
+			comedi_buf_read_alloc(s, bi.bytes_read);
+			bi.bytes_read = comedi_buf_read_free(s, bi.bytes_read);
+
+			if (comedi_is_subdevice_idle(s) &&
+			    comedi_buf_read_n_available(s) == 0)
+				do_become_nonbusy(dev, s);
 		}
-	}
-
-	if (bi.bytes_written && (async->cmd.flags & CMDF_WRITE)) {
-		comedi_buf_write_alloc(s, bi.bytes_written);
-		bi.bytes_written = comedi_buf_write_free(s, bi.bytes_written);
+		bi.bytes_written = 0;
+	} else {
+		/* command was set up in "write" direction */
+		if (bi.bytes_written) {
+			comedi_buf_write_alloc(s, bi.bytes_written);
+			bi.bytes_written =
+			    comedi_buf_write_free(s, bi.bytes_written);
+		}
+		bi.bytes_read = 0;
 	}
 
 copyback_position:

commit e5be74c7c23b159aa43c7e6708e46d71a7af677d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 19 16:13:50 2016 +0000

    staging: comedi: COMEDI_BUFINFO: get amount freed, not amount allocated
    
    The `COMEDI_BUFINFO` ioctl is used to advance the current position in
    the buffer by a specified amount (which can be 0) and get the new
    position.  On input, the `bytes_read` member of `struct comedi_bufinfo`
    specifies the amount to advance the "read" position for an asynchronous
    command in the "read" direction, and the `bytes_written` member
    specifies the amount to advance the "write" position for a command in
    the "write" direction.  The handler `do_bufinfo_ioctl()` may limit the
    specified values according to amount of readable or writable space in
    the buffer.  On output, the `struct comedi_bufinfo` is filled in with
    the updated position information, along with the adjusted `bytes_read`
    and `bytes_written` members.
    
    Advancing the buffer position occurs in two steps: first, some buffer
    space is allocated, and second, it is freed, advancing the current
    "read" or "write" position.  Currently, `do_bufinfo_ioctl()` limits
    `bytes_read` or `bytes_written` to the amount it could allocate in the
    first step, but that is invisible and irrelevant to the ioctl user.
    It's mostly irrelevant to the COMEDI internals as well, apart from
    limiting how much can be freed in the second step.  Change it to ignore
    how much it managed to allocate in the first step and just use the
    amount that was actually freed in the second step, which is the amount
    the current buffer position was actually moved by this ioctl call.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index d57fadef47fc..2cfb61e0f2b8 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1142,8 +1142,8 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		return -EACCES;
 
 	if (bi.bytes_read && !(async->cmd.flags & CMDF_WRITE)) {
-		bi.bytes_read = comedi_buf_read_alloc(s, bi.bytes_read);
-		comedi_buf_read_free(s, bi.bytes_read);
+		comedi_buf_read_alloc(s, bi.bytes_read);
+		bi.bytes_read = comedi_buf_read_free(s, bi.bytes_read);
 
 		if (comedi_is_subdevice_idle(s) &&
 		    comedi_buf_read_n_available(s) == 0) {
@@ -1152,9 +1152,8 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	}
 
 	if (bi.bytes_written && (async->cmd.flags & CMDF_WRITE)) {
-		bi.bytes_written =
-		    comedi_buf_write_alloc(s, bi.bytes_written);
-		comedi_buf_write_free(s, bi.bytes_written);
+		comedi_buf_write_alloc(s, bi.bytes_written);
+		bi.bytes_written = comedi_buf_write_free(s, bi.bytes_written);
 	}
 
 copyback_position:

commit 28a60c456bc52bbe949ad54c6b23917a651fc342
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 18 17:55:11 2015 +0000

    staging: comedi: check for more errors for zero-length write
    
    If the "write" file operation handler, `comedi_write()` is passed 0 for
    the amount to write, some error conditions are currently skipped and the
    function just returns 0.  Change it to check those error conditions and
    return an error value if appropriate.  The trickiest case is the check
    for when the previously set up asynchronous command has terminated with
    an error.  In that case, `-EPIPE` is returned (as it is for a write of
    non-zero length) and the subdevice gets marked as non-busy.
    
    A zero-length write that returns 0 has no other effects, in particular,
    it does not cause the subdevice to be marked as non-busy.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 5a9c9d9782f3..d57fadef47fc 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2331,8 +2331,6 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	}
 
 	async = s->async;
-	if (!nbytes)
-		goto out;
 	if (s->busy != file || !(async->cmd.flags & CMDF_WRITE)) {
 		retval = -EINVAL;
 		goto out;
@@ -2349,9 +2347,12 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 		if (!comedi_is_runflags_running(runflags)) {
 			if (comedi_is_runflags_in_error(runflags))
 				retval = -EPIPE;
-			become_nonbusy = true;
+			if (retval || nbytes)
+				become_nonbusy = true;
 			break;
 		}
+		if (nbytes == 0)
+			break;
 
 		/* Allocate all free buffer space. */
 		comedi_buf_write_alloc(s, async->prealloc_bufsz);

commit 3318c7add8b43a071498a973548dd24b55c587d4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 18 17:55:10 2015 +0000

    staging: comedi: simplify returned errors for comedi_write()
    
    In order to perform a "write" file operation, an asynchronous COMEDI
    command in the "write" direction needs to have been set up by the
    current file object on the COMEDI "write" subdevice associated with the
    file object.  If there is a "write" subdevice, but a command has not
    been set up by the file object (or is has been set-up in the wrong
    direction), `comedi_write()` currently returns one of two error values
    `-EINVAL` or `-EACCES`.  `-EACCES` is returned if the command was set up
    by a different subdevice, or somewhat randomly, if a COMEDI
    "instruction" is currently being processed.  `-EINVAL` is returned in
    other cases.  Simplify it by returning `-EINVAL` for all these cases.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 2a2b5a06ed0e..5a9c9d9782f3 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2333,15 +2333,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	async = s->async;
 	if (!nbytes)
 		goto out;
-	if (!s->busy) {
-		retval = -EINVAL;
-		goto out;
-	}
-	if (s->busy != file) {
-		retval = -EACCES;
-		goto out;
-	}
-	if (!(async->cmd.flags & CMDF_WRITE)) {
+	if (s->busy != file || !(async->cmd.flags & CMDF_WRITE)) {
 		retval = -EINVAL;
 		goto out;
 	}
@@ -2376,15 +2368,8 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 				retval = -ERESTARTSYS;
 				break;
 			}
-			if (!s->busy) {
-				retval = -EINVAL;
-				break;
-			}
-			if (s->busy != file) {
-				retval = -EACCES;
-				break;
-			}
-			if (!(async->cmd.flags & CMDF_WRITE)) {
+			if (s->busy != file ||
+			    !(async->cmd.flags & CMDF_WRITE)) {
 				retval = -EINVAL;
 				break;
 			}

commit 40d0e80e08012ac99b187cbaaeb8aab92b71714d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 18 17:55:09 2015 +0000

    staging: comedi: return error on "write" if no command set up
    
    The "write" file operation handler, `comedi_write()` returns an error
    for pretty much any condition that prevents a "write" going ahead.  One
    of the conditions that prevents a "write" going ahead is that no
    asynchronous command has been set up, but that currently results in a
    return value of 0 (unless COMEDI instructions are being processed or an
    asynchronous command has been set up by a different file object).
    Change it to return `-EINVAL` in this case.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 4dd42890c641..2a2b5a06ed0e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2331,9 +2331,12 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	}
 
 	async = s->async;
-
-	if (!s->busy || !nbytes)
+	if (!nbytes)
+		goto out;
+	if (!s->busy) {
+		retval = -EINVAL;
 		goto out;
+	}
 	if (s->busy != file) {
 		retval = -EACCES;
 		goto out;
@@ -2373,8 +2376,10 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 				retval = -ERESTARTSYS;
 				break;
 			}
-			if (!s->busy)
+			if (!s->busy) {
+				retval = -EINVAL;
 				break;
+			}
 			if (s->busy != file) {
 				retval = -EACCES;
 				break;

commit 35a7475dc818320915e89ed0217872ff1ab66ec2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 18 17:55:08 2015 +0000

    staging: comedi: allow buffer wraparound in comedi_write()
    
    `comedi_write()` copies data from the user buffer to the acquisition
    data buffer, which is cyclic, using a single call to `copy_from_user()`.
    It currently avoids having to deal with wraparound of the cyclic buffer
    by limiting the amount it copies (and the amount returned to the user).
    Change it to deal with the wraparound using two calls to
    `copy_from_user()` if necessary.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 8c784c483c3e..4dd42890c641 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2346,6 +2346,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	add_wait_queue(&async->wait_head, &wait);
 	while (count == 0 && !retval) {
 		unsigned runflags;
+		unsigned int wp, n1, n2;
 
 		set_current_state(TASK_INTERRUPTIBLE);
 
@@ -2360,9 +2361,6 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 		/* Allocate all free buffer space. */
 		comedi_buf_write_alloc(s, async->prealloc_bufsz);
 		m = comedi_buf_write_n_allocated(s);
-		/* Avoid buffer wraparound. */
-		if (async->buf_write_ptr + m > async->prealloc_bufsz)
-			m = async->prealloc_bufsz - async->buf_write_ptr;
 		n = min_t(size_t, m, nbytes);
 
 		if (n == 0) {
@@ -2388,8 +2386,14 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 			continue;
 		}
 
-		m = copy_from_user(async->prealloc_buf + async->buf_write_ptr,
-				   buf, n);
+		wp = async->buf_write_ptr;
+		n1 = min(n, async->prealloc_bufsz - wp);
+		n2 = n - n1;
+		m = copy_from_user(async->prealloc_buf + wp, buf, n1);
+		if (m)
+			m += n2;
+		else if (n2)
+			m = copy_from_user(async->prealloc_buf, buf + n1, n2);
 		if (m) {
 			n -= m;
 			retval = -EFAULT;

commit 591c5f8a599a58c7c3773027010e537fc1d7a7d5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 18 17:55:07 2015 +0000

    staging: comedi: avoid bad truncation of a size_t in comedi_write()
    
    At one point in `comedi_write()`, the variable `n` gets assigned to the
    minimum of the parameter `nbytes` and the amount of writeable buffer
    space.  The way that is done currently is unsafe in the unlikely case
    that `nbytes` exceeds `UINT_MAX`, so fix it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 188a12a02ce7..8c784c483c3e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2357,16 +2357,13 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 			break;
 		}
 
-		n = nbytes;
-
-		m = n;
+		/* Allocate all free buffer space. */
+		comedi_buf_write_alloc(s, async->prealloc_bufsz);
+		m = comedi_buf_write_n_allocated(s);
+		/* Avoid buffer wraparound. */
 		if (async->buf_write_ptr + m > async->prealloc_bufsz)
 			m = async->prealloc_bufsz - async->buf_write_ptr;
-		comedi_buf_write_alloc(s, async->prealloc_bufsz);
-		if (m > comedi_buf_write_n_allocated(s))
-			m = comedi_buf_write_n_allocated(s);
-		if (m < n)
-			n = m;
+		n = min_t(size_t, m, nbytes);
 
 		if (n == 0) {
 			if (file->f_flags & O_NONBLOCK) {

commit 84a185ec429fe64e5b0d81d7ac815c91578ee569
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 18 17:55:06 2015 +0000

    staging: comedi: make some variables unsigned in comedi_write()
    
    In `comedi_write()`, the `n` and `m` variables are of type `int`.
    Change them to `unsigned int` as they are used to measure a positive
    number of bytes.  The `count` variable is also of type `int` and holds
    the returned number of bytes written.  Change it to type `ssize_t` to
    match the function's return type.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 94c23484284f..188a12a02ce7 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2303,7 +2303,9 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 {
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
-	int n, m, count = 0, retval = 0;
+	unsigned int n, m;
+	ssize_t count = 0;
+	int retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	struct comedi_file *cfp = file->private_data;
 	struct comedi_device *dev = cfp->dev;

commit ed65bba31bdf038bada04415065b8d9b218b6066
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 18 17:55:05 2015 +0000

    staging: comedi: do extra checks for becoming non-busy for "write"
    
    `comedi_write()` is the handler for the "write" file operation for
    COMEDI devices.  It mostly runs without using the main mutex of the
    COMEDI device, but uses the `attach_lock` rw_semaphore to protect
    against the COMEDI device becoming "detached".  A file object can write
    data for a COMEDI asynchonous command if it initiated the command.  The
    COMEDI subdevice is marked as busy when the command is started.  At some
    point, the "write" handler detects that the command has terminated and
    so marks the subdevice as non-busy.
    
    In order to mark the subdevice as non-busy, the "write" handler needs to
    release the `attach_lock` rw_semaphore and `acquire the main `mutex`.
    There is a vulnerable point between the two, so it checks that the
    device is still attached after acquiring the mutex.  However, it does
    not currently check that the conditions for becoming non-busy still
    hold.  Add some more checks that the subdevice is still busy with a
    command initiated by the same file object, and that the command is in
    the correct direction (in case the subdevice supports both "read" and
    "write").
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c9da6f39b1c6..94c23484284f 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2420,10 +2420,15 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 		 * sufficient (unless there have been 2**32 detaches in the
 		 * meantime!), but check the subdevice pointer as well just in
 		 * case.
+		 *
+		 * Also check the subdevice is still in a suitable state to
+		 * become non-busy in case it changed behind our back.
 		 */
 		new_s = comedi_file_write_subdevice(file);
 		if (dev->attached && old_detach_count == dev->detach_count &&
-		    s == new_s && new_s->async == async)
+		    s == new_s && new_s->async == async && s->busy == file &&
+		    (async->cmd.flags & CMDF_WRITE) &&
+		    !comedi_is_subdevice_running(s))
 			do_become_nonbusy(dev, s);
 		mutex_unlock(&dev->mutex);
 	}

commit 06181de14ff09b274b699ee2dd39fe5e37efb419
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 18 17:55:04 2015 +0000

    staging: comedi: rearrange comedi_write() code
    
    Rearrange the code in `comedi_write()` to reduce the amount of
    indentation.  The code never reiterates the `while` loop once `count`
    has become non-zero, so we can check that in the `while` condition to
    save an indentation level.  (Note that `nbytes` has been checked to be
    non-zero before entering the loop, so we can remove that check.)  Move
    the code that makes the subdevice "become non-busy" outside the `while`
    loop, using a new flag variable `become_nonbusy` to decide whether it
    needs to be done.  This simplifies the wait queue handling so there is a
    single place where the task is removed from the wait queue, and we can
    remove the `on_wait_queue` flag variable.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 7b4af519e17e..c9da6f39b1c6 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2307,7 +2307,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	DECLARE_WAITQUEUE(wait, current);
 	struct comedi_file *cfp = file->private_data;
 	struct comedi_device *dev = cfp->dev;
-	bool on_wait_queue = false;
+	bool become_nonbusy = false;
 	bool attach_locked;
 	unsigned int old_detach_count;
 
@@ -2342,48 +2342,16 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	}
 
 	add_wait_queue(&async->wait_head, &wait);
-	on_wait_queue = true;
-	while (nbytes > 0 && !retval) {
+	while (count == 0 && !retval) {
 		unsigned runflags;
 
 		set_current_state(TASK_INTERRUPTIBLE);
 
 		runflags = comedi_get_subdevice_runflags(s);
 		if (!comedi_is_runflags_running(runflags)) {
-			if (count == 0) {
-				struct comedi_subdevice *new_s;
-
-				if (comedi_is_runflags_in_error(runflags))
-					retval = -EPIPE;
-				else
-					retval = 0;
-				/*
-				 * To avoid deadlock, cannot acquire dev->mutex
-				 * while dev->attach_lock is held.  Need to
-				 * remove task from the async wait queue before
-				 * releasing dev->attach_lock, as it might not
-				 * be valid afterwards.
-				 */
-				remove_wait_queue(&async->wait_head, &wait);
-				on_wait_queue = false;
-				up_read(&dev->attach_lock);
-				attach_locked = false;
-				mutex_lock(&dev->mutex);
-				/*
-				 * Become non-busy unless things have changed
-				 * behind our back.  Checking dev->detach_count
-				 * is unchanged ought to be sufficient (unless
-				 * there have been 2**32 detaches in the
-				 * meantime!), but check the subdevice pointer
-				 * as well just in case.
-				 */
-				new_s = comedi_file_write_subdevice(file);
-				if (dev->attached &&
-				    old_detach_count == dev->detach_count &&
-				    s == new_s && new_s->async == async)
-					do_become_nonbusy(dev, s);
-				mutex_unlock(&dev->mutex);
-			}
+			if (comedi_is_runflags_in_error(runflags))
+				retval = -EPIPE;
+			become_nonbusy = true;
 			break;
 		}
 
@@ -2433,12 +2401,33 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 		nbytes -= n;
 
 		buf += n;
-		break;		/* makes device work like a pipe */
 	}
-out:
-	if (on_wait_queue)
-		remove_wait_queue(&async->wait_head, &wait);
+	remove_wait_queue(&async->wait_head, &wait);
 	set_current_state(TASK_RUNNING);
+	if (become_nonbusy && count == 0) {
+		struct comedi_subdevice *new_s;
+
+		/*
+		 * To avoid deadlock, cannot acquire dev->mutex
+		 * while dev->attach_lock is held.
+		 */
+		up_read(&dev->attach_lock);
+		attach_locked = false;
+		mutex_lock(&dev->mutex);
+		/*
+		 * Check device hasn't become detached behind our back.
+		 * Checking dev->detach_count is unchanged ought to be
+		 * sufficient (unless there have been 2**32 detaches in the
+		 * meantime!), but check the subdevice pointer as well just in
+		 * case.
+		 */
+		new_s = comedi_file_write_subdevice(file);
+		if (dev->attached && old_detach_count == dev->detach_count &&
+		    s == new_s && new_s->async == async)
+			do_become_nonbusy(dev, s);
+		mutex_unlock(&dev->mutex);
+	}
+out:
 	if (attach_locked)
 		up_read(&dev->attach_lock);
 

commit 3c3bea26ad3037924fd066c14fd391a69103dd63
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 12 17:21:29 2015 +0100

    staging: comedi: check for more errors for zero-length read
    
    If the "read" file operation handler, `comedi_read()` is passed 0 for
    the amount to read, some error conditions are currently skipped and the
    function just returns 0.  Change it to check those error conditions and
    return an error value if appropriate.  The trickiest case is the check
    for when the previously set up asynchronous command has terminated with
    an error.  In that case, `-EPIPE` is returned (as it is for a read of
    non-zero length) and the subdevice gets marked as non-busy.
    
    A zero-length read that returns 0 has no other effects, in particular,
    it does not cause the subdevice to be marked as non-busy, and the return
    value does not indicate an "end-of-file" condition.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 466dc95d5611..7b4af519e17e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2478,15 +2478,13 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	}
 
 	async = s->async;
-	if (!nbytes)
-		goto out;
 	if (s->busy != file || (async->cmd.flags & CMDF_WRITE)) {
 		retval = -EINVAL;
 		goto out;
 	}
 
 	add_wait_queue(&async->wait_head, &wait);
-	while (nbytes > 0 && !retval) {
+	while (count == 0 && !retval) {
 		unsigned int rp, n1, n2;
 
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -2500,9 +2498,12 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 			if (!comedi_is_runflags_running(runflags)) {
 				if (comedi_is_runflags_in_error(runflags))
 					retval = -EPIPE;
-				become_nonbusy = true;
+				if (retval || nbytes)
+					become_nonbusy = true;
 				break;
 			}
+			if (nbytes == 0)
+				break;
 			if (file->f_flags & O_NONBLOCK) {
 				retval = -EAGAIN;
 				break;
@@ -2539,7 +2540,6 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		nbytes -= n;
 
 		buf += n;
-		break;		/* makes device work like a pipe */
 	}
 	remove_wait_queue(&async->wait_head, &wait);
 	set_current_state(TASK_RUNNING);

commit 39582847757ef79fb9de2661dd9297f1c988478d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 12 17:21:28 2015 +0100

    staging: comedi: simplify returned errors for comedi_read()
    
    In order to perform a "read" file operation, an asynchronous COMEDI
    command in the "read" direction needs to have been set up by the current
    file object on the COMEDI "read" subdevice associated with the file
    object.  If there is a "read" subdevice, but a command has not been set
    up by the file object (or is has been set-up in the wrong direction),
    `comedi_read()` currently returns one of two error values `-EINVAL` or
    `-EACCES`.  `-EACCES` is returned if the command was set up by a
    different subdevice, or somewhat randomly, if a COMEDI "instruction" is
    currently being processed.  `-EINVAL` is returned in other cases.
    Simplify it by returning `-EINVAL` for all these cases.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 190592ad0921..466dc95d5611 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2480,15 +2480,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	async = s->async;
 	if (!nbytes)
 		goto out;
-	if (!s->busy) {
-		retval = -EINVAL;
-		goto out;
-	}
-	if (s->busy != file) {
-		retval = -EACCES;
-		goto out;
-	}
-	if (async->cmd.flags & CMDF_WRITE) {
+	if (s->busy != file || (async->cmd.flags & CMDF_WRITE)) {
 		retval = -EINVAL;
 		goto out;
 	}
@@ -2520,15 +2512,8 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 				retval = -ERESTARTSYS;
 				break;
 			}
-			if (!s->busy) {
-				retval = -EINVAL;
-				break;
-			}
-			if (s->busy != file) {
-				retval = -EACCES;
-				break;
-			}
-			if (async->cmd.flags & CMDF_WRITE) {
+			if (s->busy != file ||
+			    (async->cmd.flags & CMDF_WRITE)) {
 				retval = -EINVAL;
 				break;
 			}

commit a8ed75c0836ebc530f7fbf613bba75de3656b105
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 12 17:21:27 2015 +0100

    staging: comedi: return error on "read" if no command set up
    
    The "read" file operation handler, `comedi_read()` returns an error for
    pretty much any condition that prevents a "read" going ahead.  One of
    the conditions that prevents a "read" going ahead is that no
    asynchronous command has been set up, but that currently results in a
    return value of 0 (unless COMEDI instructions are being processed or an
    asynchronous command has been set up by a different file object).
    Change it to return `-EINVAL` in this case.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 88ba0b648805..190592ad0921 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2478,8 +2478,12 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	}
 
 	async = s->async;
-	if (!s->busy || !nbytes)
+	if (!nbytes)
+		goto out;
+	if (!s->busy) {
+		retval = -EINVAL;
 		goto out;
+	}
 	if (s->busy != file) {
 		retval = -EACCES;
 		goto out;
@@ -2517,6 +2521,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 				break;
 			}
 			if (!s->busy) {
+				retval = -EINVAL;
 				break;
 			}
 			if (s->busy != file) {

commit f84e27adfc4cb0c4aa97d830c43f8c82aca0547c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 12 17:21:26 2015 +0100

    staging: comedi: remove superfluous retval = 0 in comedi_read()
    
    `comedi_read()` initializes `retval` to 0.  The other `retval = 0`
    assignments are superfluous, so remove them.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a979f621f932..88ba0b648805 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2504,8 +2504,6 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 			if (!comedi_is_runflags_running(runflags)) {
 				if (comedi_is_runflags_in_error(runflags))
 					retval = -EPIPE;
-				else
-					retval = 0;
 				become_nonbusy = true;
 				break;
 			}
@@ -2519,7 +2517,6 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 				break;
 			}
 			if (!s->busy) {
-				retval = 0;
 				break;
 			}
 			if (s->busy != file) {

commit 42ea907d785d522e5ae661c3774b8a801ac7f00b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 12 17:21:25 2015 +0100

    staging: comedi: allow buffer wraparound in comedi_read()
    
    `comedi_read()` copies data from the acquisition data buffer, which is
    cyclic, to the user buffer using a single call to `copy_to_user()`.  It
    currently avoids having to deal with wraparound of the cyclic buffer by
    limiting the amount it copies (and the amount returned to the user).
    Change it to deal with the wraparound using two calls to
    `copy_to_user()` if necessary.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f39448a0d301..a979f621f932 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2491,11 +2491,11 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 
 	add_wait_queue(&async->wait_head, &wait);
 	while (nbytes > 0 && !retval) {
+		unsigned int rp, n1, n2;
+
 		set_current_state(TASK_INTERRUPTIBLE);
 
 		m = comedi_buf_read_n_available(s);
-		if (async->buf_read_ptr + m > async->prealloc_bufsz)
-			m = async->prealloc_bufsz - async->buf_read_ptr;
 		n = min_t(size_t, m, nbytes);
 
 		if (n == 0) {
@@ -2532,8 +2532,14 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 			}
 			continue;
 		}
-		m = copy_to_user(buf, async->prealloc_buf +
-				 async->buf_read_ptr, n);
+		rp = async->buf_read_ptr;
+		n1 = min(n, async->prealloc_bufsz - rp);
+		n2 = n - n1;
+		m = copy_to_user(buf, async->prealloc_buf + rp, n1);
+		if (m)
+			m += n2;
+		else if (n2)
+			m = copy_to_user(buf + n1, async->prealloc_buf, n2);
 		if (m) {
 			n -= m;
 			retval = -EFAULT;

commit 8ea939284d3ebde02d5b46d50406c2b7faae1214
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 12 17:21:24 2015 +0100

    staging: comedi: avoid bad truncation of a size_t in comedi_read()
    
    At one point in `comedi_read()`, the variable `n` gets assigned to the
    minimum of the parameter `nbytes` and the amount of readable buffer
    space `m`.  The way that is done currently is unsafe in the unlikely
    case that `nbytes` exceeds `UINT_MAX`, so fix it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 92f571645f36..f39448a0d301 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2493,13 +2493,10 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	while (nbytes > 0 && !retval) {
 		set_current_state(TASK_INTERRUPTIBLE);
 
-		n = nbytes;
-
 		m = comedi_buf_read_n_available(s);
 		if (async->buf_read_ptr + m > async->prealloc_bufsz)
 			m = async->prealloc_bufsz - async->buf_read_ptr;
-		if (m < n)
-			n = m;
+		n = min_t(size_t, m, nbytes);
 
 		if (n == 0) {
 			unsigned runflags = comedi_get_subdevice_runflags(s);

commit 76e8e7d4ffb3300217b62637183282a5225d7394
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 12 17:21:23 2015 +0100

    staging: comedi: make some variables unsigned in comedi_read()
    
    In `comedi_read()`, the `n` and `m` variables are of type `int`.  Change
    them to `unsigned int` as they are used to measure a positive number of
    bytes.  The `count` variable is also of type `int` and holds the
    returned number of bytes.  Change it to type `ssize_t` to match the
    function's return type.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 49c46651ad23..92f571645f36 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2450,7 +2450,9 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 {
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
-	int n, m, count = 0, retval = 0;
+	unsigned int n, m;
+	ssize_t count = 0;
+	int retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	struct comedi_file *cfp = file->private_data;
 	struct comedi_device *dev = cfp->dev;

commit fd060c8f4c93ee564510aa86724d27dca31b9e2a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 12 17:21:22 2015 +0100

    staging: comedi: do extra checks for becoming non-busy for "read"
    
    `comedi_read()` is the handler for the "read" file operation for COMEDI
    devices.  It mostly runs without using the main mutex of the COMEDI
    device, but uses the `attach_lock` rwsemaphore to protect against the
    COMEDI device becoming "detached".  A file object can read data
    resulting from a COMEDI asynchonous command if it initiated the command.
    The COMEDI subdevice is marked as busy when the command is started.  At
    some point, the "read" handler detects that the command has terminated
    and all available data has been read and so marks the subdevice as
    non-busy.
    
    In order to mark the subdevice as non-busy, the "read" handler needs to
    release the `attach_lock` rwsemaphore and `acquire the main `mutex`.
    There is a vulnerable point between the two, so it checks that the
    device is still attached after acquiring the mutex.  However, it does
    not currently check that the conditions for becoming non-busy still
    hold.  Add some more checks that the subdevice is still busy with a
    command initiated by the same file object, that command is in the correct
    direction (in case the subdevice supports both "read" and "write"), that
    command has terminated, and has no data available to be read.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c74c50a6e52d..49c46651ad23 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2567,14 +2567,17 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		 * sufficient (unless there have been 2**32 detaches in the
 		 * meantime!), but check the subdevice pointer as well just in
 		 * case.
+		 *
+		 * Also check the subdevice is still in a suitable state to
+		 * become non-busy in case it changed behind our back.
 		 */
 		new_s = comedi_file_read_subdevice(file);
 		if (dev->attached && old_detach_count == dev->detach_count &&
-		    s == new_s && new_s->async == async) {
-			if (become_nonbusy ||
-			    comedi_buf_read_n_available(s) == 0)
-				do_become_nonbusy(dev, s);
-		}
+		    s == new_s && new_s->async == async && s->busy == file &&
+		    !(async->cmd.flags & CMDF_WRITE) &&
+		    !comedi_is_subdevice_running(s) &&
+		    comedi_buf_read_n_available(s) == 0)
+			do_become_nonbusy(dev, s);
 		mutex_unlock(&dev->mutex);
 	}
 out:

commit 09d6b9a9ddbbdbf4e45f553fa4405aeacfd12e47
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 12 17:21:21 2015 +0100

    staging: comedi: don't consider "unmunged" data when becoming non-busy
    
    If an asynchronous "read" command is no longer running but the subdevice
    is still busy, it becomes non-busy once there is no more data available
    in the buffer.  Some or all of the data written to the buffer might not
    have been "munged" yet, and it cannot be read until it has been munged
    by the writer.  However, since the command is no longer running, we
    cannot expect any remaining unmunged data to get munged so we should
    ignore it.  Call `comedi_buf_read_n_available()` to check the amount of
    munged data available to be read, replacing the call to
    `comedi_buf_n_bytes_ready()` which checked the amount of written (but
    possibly not yet munged) data available to be read.  This affects both
    the "read" file operation (done in `comedi_read()`) and the
    `COMEDI_BUFINFO` ioctl handling (done in `do_bufinfo_ioctl()`).  (The
    latter is used when data is transferred directly through the mmapped
    buffer instead of via the "read" file operation.)
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index bb2e0ae0e052..c74c50a6e52d 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1146,7 +1146,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		comedi_buf_read_free(s, bi.bytes_read);
 
 		if (comedi_is_subdevice_idle(s) &&
-		    comedi_buf_n_bytes_ready(s) == 0) {
+		    comedi_buf_read_n_available(s) == 0) {
 			do_become_nonbusy(dev, s);
 		}
 	}
@@ -2571,7 +2571,8 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		new_s = comedi_file_read_subdevice(file);
 		if (dev->attached && old_detach_count == dev->detach_count &&
 		    s == new_s && new_s->async == async) {
-			if (become_nonbusy || comedi_buf_n_bytes_ready(s) == 0)
+			if (become_nonbusy ||
+			    comedi_buf_read_n_available(s) == 0)
 				do_become_nonbusy(dev, s);
 		}
 		mutex_unlock(&dev->mutex);

commit 970679b04c4b2ae8aaede98e214449eb3e6e6b06
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 12 17:21:20 2015 +0100

    staging: comedi: remain busy until read end-of-file
    
    If a COMEDI subdevice is busy handling an asynchronous command in the
    "read" direction, then after the command has terminated itself, the
    "read" file operation handler, `comedi_read()` should keep the subdevice
    busy until all available data has been read and it has returned 0 to
    indicate an "end-of-file" condition.  Currently, it has a bug where it
    can mark the subdevice as non-busy even when returning a non-zero count.
    The bug is slightly hidden because the next "read" will return 0 because
    the subdevice is no longer busy.  Fix it by checking the return count is
    0 before deciding to mark the subdevice as non-busy.
    
    The call to `comedi_is_subdevice_idle()` is superfluous as the
    `become_nonbusy` variable will have been set to `true` when considering
    becoming non-busy.  Strictly speaking, checking the return count is
    superfluous too, as `become_nonbusy` doesn't get set to `true` unless
    the count is 0, but check the return count anyway to make the intention
    clearer.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index fe25287c5688..bb2e0ae0e052 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2551,7 +2551,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	}
 	remove_wait_queue(&async->wait_head, &wait);
 	set_current_state(TASK_RUNNING);
-	if (become_nonbusy || comedi_is_subdevice_idle(s)) {
+	if (become_nonbusy && count == 0) {
 		struct comedi_subdevice *new_s;
 
 		/*

commit d5eb3a742109015cd794e536fe0968197b917e05
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 9 12:26:52 2015 +0100

    staging: comedi: don't use mutex when polling file
    
    The main mutex in a comedi device can get held for quite a while when
    processing comedi instructions, so for performance reasons, the "read"
    and "write" file operations do not use it; they use use the
    `attach_lock` rwsemaphore to protect against the comedi device becoming
    detached at an inopportune moment.  Do the same for the "poll" file
    operation.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1d6bef285821..fe25287c5688 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2264,7 +2264,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	struct comedi_device *dev = cfp->dev;
 	struct comedi_subdevice *s, *s_read;
 
-	mutex_lock(&dev->mutex);
+	down_read(&dev->attach_lock);
 
 	if (!dev->attached) {
 		dev_dbg(dev->class_dev, "no driver attached\n");
@@ -2294,7 +2294,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	}
 
 done:
-	mutex_unlock(&dev->mutex);
+	up_read(&dev->attach_lock);
 	return mask;
 }
 

commit 3834234f99a07d1a84918cb15e9431420c5405f4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 9 12:26:51 2015 +0100

    staging: comedi: check command started by file being polled
    
    Currently, the "poll" file operation checks if an asynchronous "read"
    (or "write" command is active on the "read" (or "write" subdevice, but
    does not consider whether the command was started from the file object
    being polled.  Since that is the only file object able to read (or
    write) data, take it into consideration.
    
    With this change, if no read (or write) command is running on the
    subdevice, or it is started by a different file object, the file object
    is marked as readable (or writeable) regardless, but the read (or write)
    file operation will return an error.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 42f6971c8061..1d6bef285821 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2275,7 +2275,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	s_read = s;
 	if (s && s->async) {
 		poll_wait(file, &s->async->wait_head, wait);
-		if (!s->busy || !comedi_is_subdevice_running(s) ||
+		if (s->busy != file || !comedi_is_subdevice_running(s) ||
 		    (s->async->cmd.flags & CMDF_WRITE) ||
 		    comedi_buf_read_n_available(s) > 0)
 			mask |= POLLIN | POLLRDNORM;
@@ -2287,7 +2287,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 
 		if (s != s_read)
 			poll_wait(file, &s->async->wait_head, wait);
-		if (!s->busy || !comedi_is_subdevice_running(s) ||
+		if (s->busy != file || !comedi_is_subdevice_running(s) ||
 		    !(s->async->cmd.flags & CMDF_WRITE) ||
 		    comedi_buf_write_n_available(s) >= bps)
 			mask |= POLLOUT | POLLWRNORM;

commit ecf04ed34d65b735bbdfa9ae8ea378ffc0faa9f6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 9 12:26:50 2015 +0100

    staging: comedi: don't allocate buffer space when polling for write
    
    When handling the "poll" file operation and checking for `POLLOUT`,
    don't allocate space from the buffer for writing, just check that space
    is available for writing.  That check is done after checking that an
    asynchronous "write" command is running on the subdevice.  Allocating
    the buffer space before checking a "write" command is running can cause
    problems if the subdevice supports commands in either direction and
    currently has an active "read" command.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index bd124815c06a..42f6971c8061 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2287,10 +2287,9 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 
 		if (s != s_read)
 			poll_wait(file, &s->async->wait_head, wait);
-		comedi_buf_write_alloc(s, s->async->prealloc_bufsz);
 		if (!s->busy || !comedi_is_subdevice_running(s) ||
 		    !(s->async->cmd.flags & CMDF_WRITE) ||
-		    comedi_buf_write_n_allocated(s) >= bps)
+		    comedi_buf_write_n_available(s) >= bps)
 			mask |= POLLOUT | POLLWRNORM;
 	}
 

commit 322146d5d485cddb93761bd2593fbc932399b0a1
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 9 12:26:47 2015 +0100

    staging: comedi: don't poll_wait on same subdevice twice
    
    Comedi subdevices that support asynchronous acquisition commands have a
    wait queue head used for blocking reads or writes and for the poll file
    operation.  The comedi device may have several subdevices that support
    "read" and/or "write" commands, but each open file object has at most
    one "read" subdevice and one "write" subdevice.  It's possible (though
    rare) for those to be the same subdevice if the subdevice supports
    commands in either direction.  In that case, the "poll" file operation
    doesn't really need to do a `poll_wait()` on the same subdevice twice.
    Although harmless, it wastes a poll table entry.  Check for that, and
    avoid it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f341421f1644..bd124815c06a 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2262,7 +2262,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	unsigned int mask = 0;
 	struct comedi_file *cfp = file->private_data;
 	struct comedi_device *dev = cfp->dev;
-	struct comedi_subdevice *s;
+	struct comedi_subdevice *s, *s_read;
 
 	mutex_lock(&dev->mutex);
 
@@ -2272,6 +2272,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	}
 
 	s = comedi_file_read_subdevice(file);
+	s_read = s;
 	if (s && s->async) {
 		poll_wait(file, &s->async->wait_head, wait);
 		if (!s->busy || !comedi_is_subdevice_running(s) ||
@@ -2284,7 +2285,8 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	if (s && s->async) {
 		unsigned int bps = comedi_bytes_per_sample(s);
 
-		poll_wait(file, &s->async->wait_head, wait);
+		if (s != s_read)
+			poll_wait(file, &s->async->wait_head, wait);
 		comedi_buf_write_alloc(s, s->async->prealloc_bufsz);
 		if (!s->busy || !comedi_is_subdevice_running(s) ||
 		    !(s->async->cmd.flags & CMDF_WRITE) ||

commit 30cc9bd64c67c9b1f70a2779302da2ac05335d47
Author: Shraddha Barke <shraddha.6596@gmail.com>
Date:   Tue Oct 13 21:07:47 2015 +0530

    Staging: comedi: Remove exceptional & on function name
    
    n this file, function names are otherwise used as pointers without &.
    
    A simplified version of the Coccinelle semantic patch that makes this
    change is as follows:
    
    // <smpl>
    @r@
    identifier f;
    @@
    
    f(...) { ... }
    @@
    identifier r.f;
    @@
    
    - &f
    + f
    // </smpl>
    
    Signed-off-by: Shraddha Barke <shraddha.6596@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ef4b58b2f7ef..f341421f1644 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1341,7 +1341,7 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 			goto out;
 		}
 		/* This looks arbitrary.  It is. */
-		s->busy = &parse_insn;
+		s->busy = parse_insn;
 		switch (insn->insn) {
 		case INSN_READ:
 			ret = s->insn_read(dev, s, insn, data);

commit a3e399422f8c92b38ed2f95e56f0fa4c2eaecf5f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 23 16:33:27 2015 +0100

    staging: comedi: comedi_fops.c: Tweak kernel-doc for consistency
    
    Adjust the kernel-doc in this file for consistency of capitalization and
    punctuation.  Make more use of the special kernel-doc markers for
    parameter names, constant names, etc.  Use the correct kernel-doc tag
    for the return values sections.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 47d16488cb26..ef4b58b2f7ef 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -61,12 +61,12 @@
 #define COMEDI_SRF_BUSY_MASK	(COMEDI_SRF_ERROR | COMEDI_SRF_RUNNING)
 
 /**
- * struct comedi_file - per-file private data for comedi device
- * @dev: comedi_device struct
- * @read_subdev: current "read" subdevice
- * @write_subdev: current "write" subdevice
- * @last_detach_count: last known detach count
- * @last_attached: last known attached/detached state
+ * struct comedi_file - Per-file private data for COMEDI device
+ * @dev: COMEDI device.
+ * @read_subdev: Current "read" subdevice.
+ * @write_subdev: Current "write" subdevice.
+ * @last_detach_count: Last known detach count.
+ * @last_attached: Last known attached/detached state.
  */
 struct comedi_file {
 	struct comedi_device *dev;
@@ -131,15 +131,15 @@ static void comedi_dev_kref_release(struct kref *kref)
 }
 
 /**
- * comedi_dev_put - release a use of a comedi device structure
- * @dev: comedi_device struct
+ * comedi_dev_put() - Release a use of a COMEDI device
+ * @dev: COMEDI device.
  *
- * Must be called when a user of a comedi device is finished with it.
- * When the last user of the comedi device calls this function, the
- * comedi device is destroyed.
+ * Must be called when a user of a COMEDI device is finished with it.
+ * When the last user of the COMEDI device calls this function, the
+ * COMEDI device is destroyed.
  *
- * Return 1 if the comedi device is destroyed by this call or dev is
- * NULL, otherwise return 0.  Callers must not assume the comedi
+ * Return: 1 if the COMEDI device is destroyed by this call or @dev is
+ * NULL, otherwise return 0.  Callers must not assume the COMEDI
  * device is still valid if this function returns 0.
  */
 int comedi_dev_put(struct comedi_device *dev)
@@ -247,15 +247,15 @@ static struct comedi_device *comedi_dev_get_from_subdevice_minor(unsigned minor)
 }
 
 /**
- * comedi_dev_get_from_minor - get comedi device by minor device number
- * @minor: minor device number
+ * comedi_dev_get_from_minor() - Get COMEDI device by minor device number
+ * @minor: Minor device number.
  *
- * Finds the comedi device associated by the minor device number, if any,
- * and increments its reference count.  The comedi device is prevented from
+ * Finds the COMEDI device associated with the minor device number, if any,
+ * and increments its reference count.  The COMEDI device is prevented from
  * being freed until a matching call is made to comedi_dev_put().
  *
- * Return a pointer to the comedi device if it exists, with its usage
- * reference incremented.  Return NULL if no comedi device exists with the
+ * Return: A pointer to the COMEDI device if it exists, with its usage
+ * reference incremented.  Return NULL if no COMEDI device exists with the
  * specified minor device number.
  */
 struct comedi_device *comedi_dev_get_from_minor(unsigned minor)
@@ -665,11 +665,11 @@ static bool comedi_is_runflags_in_error(unsigned runflags)
 }
 
 /**
- * comedi_is_subdevice_running - check if async command running on subdevice
- * @s: comedi_subdevice struct
+ * comedi_is_subdevice_running() - Check if async command running on subdevice
+ * @s: COMEDI subdevice.
  *
- * Return true if an asynchronous comedi command is active on the comedi
- * subdevice, else return false.
+ * Return: %true if an asynchronous COMEDI command is active on the
+ * subdevice, else %false.
  */
 bool comedi_is_subdevice_running(struct comedi_subdevice *s)
 {
@@ -701,11 +701,12 @@ bool comedi_can_auto_free_spriv(struct comedi_subdevice *s)
 }
 
 /**
- * comedi_set_spriv_auto_free - mark subdevice private data as freeable
- * @s: comedi_subdevice struct
+ * comedi_set_spriv_auto_free() - Mark subdevice private data as freeable
+ * @s: COMEDI subdevice.
  *
  * Mark the subdevice as having a pointer to private data that can be
- * automatically freed by the comedi core during the detach.
+ * automatically freed when the COMEDI device is detached from the low-level
+ * driver.
  */
 void comedi_set_spriv_auto_free(struct comedi_subdevice *s)
 {
@@ -714,12 +715,16 @@ void comedi_set_spriv_auto_free(struct comedi_subdevice *s)
 EXPORT_SYMBOL_GPL(comedi_set_spriv_auto_free);
 
 /**
- * comedi_alloc_spriv - Allocate memory for the subdevice private data.
- * @s: comedi_subdevice struct
- * @size: size of the memory to allocate
+ * comedi_alloc_spriv - Allocate memory for the subdevice private data
+ * @s: COMEDI subdevice.
+ * @size: Size of the memory to allocate.
  *
- * This also sets the subdevice runflags to allow the core to automatically
- * free the private data during the detach.
+ * Allocate memory for the subdevice private data and point @s->private
+ * to it.  The memory will be freed automatically when the COMEDI device
+ * is detached from the low-level driver.
+ *
+ * Return: A pointer to the allocated memory @s->private on success.
+ * Return NULL on failure.
  */
 void *comedi_alloc_spriv(struct comedi_subdevice *s, size_t size)
 {
@@ -2686,15 +2691,15 @@ static const struct file_operations comedi_fops = {
 };
 
 /**
- * comedi_event - handle events for asynchronous comedi command
- * @dev: comedi_device struct
- * @s: comedi_subdevice struct associated with dev
- * Context: interrupt (usually), s->spin_lock spin-lock not held
+ * comedi_event() - Handle events for asynchronous COMEDI command
+ * @dev: COMEDI device.
+ * @s: COMEDI subdevice.
+ * Context: in_interrupt() (usually), @s->spin_lock spin-lock not held.
  *
- * If an asynchronous comedi command is active on the subdevice, process
- * any COMEDI_CB_... event flags that have been set, usually by an
+ * If an asynchronous COMEDI command is active on the subdevice, process
+ * any %COMEDI_CB_... event flags that have been set, usually by an
  * interrupt handler.  These may change the run state of the asynchronous
- * command, wake a task, and/or send a SIGIO signal.
+ * command, wake a task, and/or send a %SIGIO signal.
  */
 void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {

commit 63107ce85edc9296b518fa29f6fe80cc29cb9c68
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Sep 18 15:46:23 2015 +0100

    staging: comedi: comedi_fops.c: remove bogus kernel-doc for runflags
    
    The comment before the `COMEDI_SRF_...` macros starts with a kernel-doc
    mark but isn't valid kernel-doc.  There isn't a kernel-doc template for
    a group of macro constants.  These macros are all private anyway, so
    don't really need to be in kernel-doc.  Just change it to a normal
    comment.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 0e8a45102933..47d16488cb26 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -43,15 +43,15 @@
 
 #include "comedi_internal.h"
 
-/**
+/*
  * comedi_subdevice "runflags"
- * @COMEDI_SRF_RT:		DEPRECATED: command is running real-time
- * @COMEDI_SRF_ERROR:		indicates an COMEDI_CB_ERROR event has occurred
+ * COMEDI_SRF_RT:		DEPRECATED: command is running real-time
+ * COMEDI_SRF_ERROR:		indicates an COMEDI_CB_ERROR event has occurred
  *				since the last command was started
- * @COMEDI_SRF_RUNNING:		command is running
- * @COMEDI_SRF_FREE_SPRIV:	free s->private on detach
+ * COMEDI_SRF_RUNNING:		command is running
+ * COMEDI_SRF_FREE_SPRIV:	free s->private on detach
  *
- * @COMEDI_SRF_BUSY_MASK:	runflags that indicate the subdevice is "busy"
+ * COMEDI_SRF_BUSY_MASK:	runflags that indicate the subdevice is "busy"
  */
 #define COMEDI_SRF_RT		BIT(1)
 #define COMEDI_SRF_ERROR	BIT(2)

commit 7cbea8dc0127a95226c7722a738ac6534950ef67
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Wed Sep 9 15:39:26 2015 -0700

    mm: mark most vm_operations_struct const
    
    With two exceptions (drm/qxl and drm/radeon) all vm_operations_struct
    structs should be constant.
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index fd54d098ab02..0e8a45102933 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2156,7 +2156,7 @@ static void comedi_vm_close(struct vm_area_struct *area)
 	comedi_buf_map_put(bm);
 }
 
-static struct vm_operations_struct comedi_vm_ops = {
+static const struct vm_operations_struct comedi_vm_ops = {
 	.open = comedi_vm_open,
 	.close = comedi_vm_close,
 };

commit 2be8ae5898af956560e9f722b327add05574a1f7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 10 13:13:59 2015 -0700

    staging: comedi: comedi_fops: absorb comedi_free_board_minor()
    
    This function is only called by comedi_cleanup_board_minors() and the
    'minor' parameter will always be < COMEDI_NUM_BOARD_MINORS.
    
    For aesthetics, absorb the function and remove the unnecessary BUG_ON().
    
    Split the comedi_clear_board_minor() out to clarify that the return value
    is a comedi_device pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f7db91ca974e..fd54d098ab02 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2774,12 +2774,6 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	return dev;
 }
 
-static void comedi_free_board_minor(unsigned minor)
-{
-	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
-	comedi_free_board_dev(comedi_clear_board_minor(minor));
-}
-
 void comedi_release_hardware_device(struct device *hardware_device)
 {
 	int minor;
@@ -2852,10 +2846,13 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 
 static void comedi_cleanup_board_minors(void)
 {
+	struct comedi_device *dev;
 	unsigned i;
 
-	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++)
-		comedi_free_board_minor(i);
+	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
+		dev = comedi_clear_board_minor(i);
+		comedi_free_board_dev(dev);
+	}
 }
 
 static int __init comedi_init(void)

commit c4237a2b59432a6ebf73f813ad9e94ab408bb8f1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 10 13:14:00 2015 -0700

    staging: comedi: comedi_fops: remove BUG_ON() in comedi_dev_get_from_board_minor()
    
    This function is only called by comedi_dev_get_from_minor() and the 'minor'
    value will always be < COMEDI_NUM_BOARD_MINORS. Remove the unnecessary
    BUG_ON().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 2e69f5a4e7ec..f7db91ca974e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -227,7 +227,6 @@ static struct comedi_device *comedi_dev_get_from_board_minor(unsigned minor)
 {
 	struct comedi_device *dev;
 
-	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
 	mutex_lock(&comedi_board_minor_table_lock);
 	dev = comedi_dev_get(comedi_board_minor_table[minor]);
 	mutex_unlock(&comedi_board_minor_table_lock);

commit 5104a8988723b405c9e033b7e57267ebdd387d4d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 10 13:14:01 2015 -0700

    staging: comedi: comedi_fops: remove BUG_ON() in comedi_free_subdevice_minor()
    
    Drivers should not crash the kernel.
    
    This function is only called by comedi_device_detach_cleanup() and the
    s->minor will always be valid or the device wouldn't have attached in
    the first place.
    
    Leave the checks for safety in accessing the comedi_subdevice_minor_table
    array but remove the BUG_ON() calls.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 93b37e245f96..2e69f5a4e7ec 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2836,12 +2836,10 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 
 	if (!s)
 		return;
-	if (s->minor < 0)
+	if (s->minor < COMEDI_NUM_BOARD_MINORS ||
+	    s->minor >= COMEDI_NUM_MINORS)
 		return;
 
-	BUG_ON(s->minor >= COMEDI_NUM_MINORS);
-	BUG_ON(s->minor < COMEDI_NUM_BOARD_MINORS);
-
 	i = s->minor - COMEDI_NUM_BOARD_MINORS;
 	mutex_lock(&comedi_subdevice_minor_table_lock);
 	if (s == comedi_subdevice_minor_table[i])

commit 6b3703f4cb763d57ab26f2ad262a30cc7f87093c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 10 13:14:02 2015 -0700

    staging: comedi: comedi_fops: remove BUG_ON() in comedi_cleanup()
    
    The BUG_ON() checks in this function are not necessary.
    
    comedi_cleanup_board_minors() clears all the entries in the
    comedi_board_minor_table array and will call comedi_device_cleanup()
    for all attached devices. comedi_device_cleanup() will then
    clear the entries in the comedi_subdevice_minor_table array with
    comedi_free_subdevice_minor().
    
    Remove the BUG_ON(), drivers should not crash the kernel.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 62526ddcb48c..93b37e245f96 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2930,14 +2930,7 @@ module_init(comedi_init);
 
 static void __exit comedi_cleanup(void)
 {
-	int i;
-
 	comedi_cleanup_board_minors();
-	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i)
-		BUG_ON(comedi_board_minor_table[i]);
-	for (i = 0; i < COMEDI_NUM_SUBDEVICE_MINORS; ++i)
-		BUG_ON(comedi_subdevice_minor_table[i]);
-
 	class_destroy(comedi_class);
 	cdev_del(&comedi_cdev);
 	unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);

commit 0bb6419ccf5b2548ade321d5337e9d3252a3d4a1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 10 13:14:03 2015 -0700

    staging: comedi: comedi_fops: remove remaining BUG_ON() checks
    
    The BUG_ON() checks in comedi_subdevice_from_minor() and
    comedi_dev_get_from_subdevice_minor() are not necessary.
    
    The 'minor' numbers for a given comedi driver are setup by
    comedi_dev_get_from_subdevice_minor() and will always be in
    the correct range.
    
    Drivers should not crash the kernel, remove the BUG_ON() checks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 4820ab6d0aa8..62526ddcb48c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -215,7 +215,6 @@ static struct comedi_subdevice
 	struct comedi_subdevice *s;
 	unsigned int i = minor - COMEDI_NUM_BOARD_MINORS;
 
-	BUG_ON(i >= COMEDI_NUM_SUBDEVICE_MINORS);
 	mutex_lock(&comedi_subdevice_minor_table_lock);
 	s = comedi_subdevice_minor_table[i];
 	if (s && s->device != dev)
@@ -241,7 +240,6 @@ static struct comedi_device *comedi_dev_get_from_subdevice_minor(unsigned minor)
 	struct comedi_subdevice *s;
 	unsigned int i = minor - COMEDI_NUM_BOARD_MINORS;
 
-	BUG_ON(i >= COMEDI_NUM_SUBDEVICE_MINORS);
 	mutex_lock(&comedi_subdevice_minor_table_lock);
 	s = comedi_subdevice_minor_table[i];
 	dev = comedi_dev_get(s ? s->device : NULL);

commit 90e6f51da718fc982eafd3dd7d6c78b378f67136
Author: Santhosh Pai <santhosh.pai88@yahoo.com>
Date:   Mon Jun 29 10:44:03 2015 +0100

    staging: Comedi: comedi_fops: Fixed the return error code
    
    This patch fixes the checkpatch.pl warning:
    
    WARNING: ENOSYS means 'invalid syscall nr' and nothing else
    
    try_module_get fails when the reference count of the module is not
    allowed to be incremented ,and hence -ENXIO is returned indicating
    no device or address.
    
    [IA - combined two of santhosh's changes to the error return value!]
    
    Signed-off-by: santhosh pai <santhosh.pai88@yahoo.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1679bfba25a9..4820ab6d0aa8 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2606,7 +2606,7 @@ static int comedi_open(struct inode *inode, struct file *file)
 	}
 	if (dev->attached && dev->use_count == 0) {
 		if (!try_module_get(dev->driver->module)) {
-			rc = -ENOSYS;
+			rc = -ENXIO;
 			goto out;
 		}
 		if (dev->open) {

commit 0e0d311ebd589e65b8e5559e067d0dd109ac3434
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 7 17:06:52 2015 +0100

    staging: comedi: use CAP_SYS_ADMIN instead of CAP_NET_ADMIN
    
    If the "comedi" module has been loaded with the
    "comedi_num_legacy_minors" module parameter set to a non-zero value,
    some reserved comedi devices get created.  These can be attached to a
    low-level comedi driver using the `COMEDI_DEVCONFIG` ioctl command,
    which checks for the `CAP_SYS_ADMIN` capability.  Of course, the comedi
    device needs to be opened before the ioctl command can be sent.  If the
    comedi device is unattached, `comedi_open()` currently requires the
    `CAP_NET_ADMIN` capability.  It makes more sense to just require the
    `CAP_SYS_ADMIN` capability here, so change it.
    
    For the curious, commit a8f80e8ff94e ("Networking: use CAP_NET_ADMIN
    when deciding to call request_module") changed this capability from
    `CAP_SYS_MODULE` to `CAP_NET_ADMIN`, even though it doesn't seem
    relevant here.  The original `CAP_SYS_MODULE` capability was due to the
    function having some code to request a module using a "char-major-%i-%i"
    alias, but that was never compiled in and was removed by commit
    f30f2c2d417b ("staging: comedi: remove check for CONFIG_KMOD").
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 985d94b6cbfd..1679bfba25a9 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2599,8 +2599,8 @@ static int comedi_open(struct inode *inode, struct file *file)
 	cfp->dev = dev;
 
 	mutex_lock(&dev->mutex);
-	if (!dev->attached && !capable(CAP_NET_ADMIN)) {
-		dev_dbg(dev->class_dev, "not attached and not CAP_NET_ADMIN\n");
+	if (!dev->attached && !capable(CAP_SYS_ADMIN)) {
+		dev_dbg(dev->class_dev, "not attached and not CAP_SYS_ADMIN\n");
 		rc = -ENODEV;
 		goto out;
 	}

commit 3bc4cc7719f78b35d23c15ac377bcf9935f77d6c
Author: Hari Prasath Gujulan Elango <hgujulan@visteon.com>
Date:   Mon Jun 15 10:10:18 2015 +0000

    staging: comedi: remove commented code
    
    This patch removes commented code.This was a checkpatch warning.
    
    Signed-off-by: Hari Prasath Gujulan Elango <hgujulan@visteon.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 146ab009d5f7..985d94b6cbfd 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1085,11 +1085,6 @@ static int do_chaninfo_ioctl(struct comedi_device *dev,
 			if (put_user(x, it.rangelist + i))
 				return -EFAULT;
 		}
-#if 0
-		if (copy_to_user(it.rangelist, s->range_type_list,
-				 s->n_chan * sizeof(unsigned int)))
-			return -EFAULT;
-#endif
 	}
 
 	return 0;

commit 69e98df78271a71b688706dccf2ad4544d63a274
Author: Carlos E. Garcia <carlos@cgarcia.org>
Date:   Fri Apr 24 09:40:42 2015 -0400

    Staging: fixed multiple spelling errors.
    
    Fixed multiple spelling errors.
    
    Signed-off-by: Carlos E. Garcia <carlos@cgarcia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 6f269cc35633..146ab009d5f7 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1762,7 +1762,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 
 /*
  * COMEDI_CMDTEST ioctl
- * asynchronous aquisition command testing
+ * asynchronous acquisition command testing
  *
  * arg:
  *	pointer to comedi_cmd structure

commit eb340acaca5eea5f87a4a1b037a32e257d8509b5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Apr 21 13:18:11 2015 +0100

    staging: comedi: move COMEDI_SRF_... macros to "comedi_fops.c"
    
    The `COMEDI_SRF_...` macros define flag combinations in the `runflags`
    member of `struct comedi_subdevice`.  They are only used directly in
    "comedi_fops.c", so move them to there.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index fc339c5c50fc..6f269cc35633 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -43,6 +43,23 @@
 
 #include "comedi_internal.h"
 
+/**
+ * comedi_subdevice "runflags"
+ * @COMEDI_SRF_RT:		DEPRECATED: command is running real-time
+ * @COMEDI_SRF_ERROR:		indicates an COMEDI_CB_ERROR event has occurred
+ *				since the last command was started
+ * @COMEDI_SRF_RUNNING:		command is running
+ * @COMEDI_SRF_FREE_SPRIV:	free s->private on detach
+ *
+ * @COMEDI_SRF_BUSY_MASK:	runflags that indicate the subdevice is "busy"
+ */
+#define COMEDI_SRF_RT		BIT(1)
+#define COMEDI_SRF_ERROR	BIT(2)
+#define COMEDI_SRF_RUNNING	BIT(27)
+#define COMEDI_SRF_FREE_SPRIV	BIT(31)
+
+#define COMEDI_SRF_BUSY_MASK	(COMEDI_SRF_ERROR | COMEDI_SRF_RUNNING)
+
 /**
  * struct comedi_file - per-file private data for comedi device
  * @dev: comedi_device struct

commit 8fc369ae38ff281d38e9ea11805a5cae862989bc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Apr 21 13:18:10 2015 +0100

    staging: comedi: wrap COMEDI_SRF_FREE_SPRIV usage
    
    The `COMEDI_SRF_FREE_SPRIV` flag in the `runflags` member of `struct
    comedi_subdevice` indicates that the memory pointed to by the `private`
    member can be automatically freed by the comedi core on subdevice
    clean-up (when the low-level comedi device is being "detached").  the
    flag doesn't really belong in `runflags`, but it was somewhere
    convenient to keep it without having to add a new member to the
    structure.
    
    Rather than access the `COMEDI_SRF_FREE_SPRIV` flag directly, use some
    new wrapper functions:
    
    * comedi_can_auto_free_spriv(s) - checks whether the subdevice's
      `s->private` points to memory that can be freed automatically.
    * comedi_set_spriv_auto_free(s) - marks the subdevice as having a
      `s->private` that points to memory that can be freed automatically.
    
    Export `comedi_set_spriv_auto_free()` for use by the low-level comedi
    driver modules, in particular the "amplc_dio200_common" module.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e78ddbe5a954..fc339c5c50fc 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -679,8 +679,28 @@ static bool comedi_is_subdevice_idle(struct comedi_subdevice *s)
 	return !(runflags & COMEDI_SRF_BUSY_MASK);
 }
 
+bool comedi_can_auto_free_spriv(struct comedi_subdevice *s)
+{
+	unsigned runflags = __comedi_get_subdevice_runflags(s);
+
+	return runflags & COMEDI_SRF_FREE_SPRIV;
+}
+
+/**
+ * comedi_set_spriv_auto_free - mark subdevice private data as freeable
+ * @s: comedi_subdevice struct
+ *
+ * Mark the subdevice as having a pointer to private data that can be
+ * automatically freed by the comedi core during the detach.
+ */
+void comedi_set_spriv_auto_free(struct comedi_subdevice *s)
+{
+	__comedi_set_subdevice_runflags(s, COMEDI_SRF_FREE_SPRIV);
+}
+EXPORT_SYMBOL_GPL(comedi_set_spriv_auto_free);
+
 /**
- * comedi_alloc_spriv() - Allocate memory for the subdevice private data.
+ * comedi_alloc_spriv - Allocate memory for the subdevice private data.
  * @s: comedi_subdevice struct
  * @size: size of the memory to allocate
  *
@@ -691,7 +711,7 @@ void *comedi_alloc_spriv(struct comedi_subdevice *s, size_t size)
 {
 	s->private = kzalloc(size, GFP_KERNEL);
 	if (s->private)
-		s->runflags |= COMEDI_SRF_FREE_SPRIV;
+		comedi_set_spriv_auto_free(s);
 	return s->private;
 }
 EXPORT_SYMBOL_GPL(comedi_alloc_spriv);

commit ef4b4b274cf96a857dd78b49558509b55d75163a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 15:13:06 2015 +0000

    staging: comedi: comedi_fops: extend spin-lock scope in comedi_event()
    
    `comedi_event()` is called from low-level drivers to handle comedi
    asynchronous command event flags.  As a safety check, it checks the
    subdevice's "run" flags to make sure an asynchronous command is running.
    It can also change the run flags to mark the command as no longer
    running (possibly also marking it as terminated with an error).
    Checking the runflags and modifying them involves two uses of the
    subdevice's spin-lock.  It seems better to do it with a single use of
    the spin-lock.  This also avoids possible interactions with
    `do_become_nonbusy()`.
    
    Acquire the subdevice's spin-lock at the start of `comedi_event()` and
    release it near the end, before a possible call to `kill_fasync()` (but
    after it's parameter values have been determined).
    
    Add and make use of few new inline helper functions:
    
    * `__comedi_clear_subdevice_runflags()` -- clears some run flags without
      using the spin-lock
    * `__comedi_set_subdevice_runflags()` -- sets some run flags without
      using the spin-lock
    * `__comedi_get_subdevice_runflags()` -- a spin-lockless version of
      `comedi_get_subdevice_runflags()
    * `__comedi_is_subdevice_running()` -- a spin-lockless version of
    * `comedi_is_subdevice_running()`
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 7ae605f6bbb6..e78ddbe5a954 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -601,24 +601,41 @@ static struct attribute *comedi_dev_attrs[] = {
 };
 ATTRIBUTE_GROUPS(comedi_dev);
 
+static void __comedi_clear_subdevice_runflags(struct comedi_subdevice *s,
+					      unsigned bits)
+{
+	s->runflags &= ~bits;
+}
+
+static void __comedi_set_subdevice_runflags(struct comedi_subdevice *s,
+					    unsigned bits)
+{
+	s->runflags |= bits;
+}
+
 static void comedi_update_subdevice_runflags(struct comedi_subdevice *s,
 					     unsigned mask, unsigned bits)
 {
 	unsigned long flags;
 
 	spin_lock_irqsave(&s->spin_lock, flags);
-	s->runflags &= ~mask;
-	s->runflags |= (bits & mask);
+	__comedi_clear_subdevice_runflags(s, mask);
+	__comedi_set_subdevice_runflags(s, bits & mask);
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 }
 
+static unsigned __comedi_get_subdevice_runflags(struct comedi_subdevice *s)
+{
+	return s->runflags;
+}
+
 static unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 {
 	unsigned long flags;
 	unsigned runflags;
 
 	spin_lock_irqsave(&s->spin_lock, flags);
-	runflags = s->runflags;
+	runflags = __comedi_get_subdevice_runflags(s);
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 	return runflags;
 }
@@ -648,6 +665,13 @@ bool comedi_is_subdevice_running(struct comedi_subdevice *s)
 }
 EXPORT_SYMBOL_GPL(comedi_is_subdevice_running);
 
+static bool __comedi_is_subdevice_running(struct comedi_subdevice *s)
+{
+	unsigned runflags = __comedi_get_subdevice_runflags(s);
+
+	return comedi_is_runflags_running(runflags);
+}
+
 static bool comedi_is_subdevice_idle(struct comedi_subdevice *s)
 {
 	unsigned runflags = comedi_get_subdevice_runflags(s);
@@ -2646,40 +2670,38 @@ static const struct file_operations comedi_fops = {
 void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
-	unsigned runflags = 0;
-	unsigned runflags_mask = 0;
-	unsigned int events = async->events;
+	unsigned int events;
+	int si_code = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&s->spin_lock, flags);
 
+	events = async->events;
 	async->events = 0;
-	if (!comedi_is_subdevice_running(s))
+	if (!__comedi_is_subdevice_running(s)) {
+		spin_unlock_irqrestore(&s->spin_lock, flags);
 		return;
+	}
 
 	if (events & COMEDI_CB_CANCEL_MASK)
-		runflags_mask |= COMEDI_SRF_RUNNING;
+		__comedi_clear_subdevice_runflags(s, COMEDI_SRF_RUNNING);
 
 	/*
-	 * Remember if an error event has occurred, so an error
-	 * can be returned the next time the user does a read().
+	 * Remember if an error event has occurred, so an error can be
+	 * returned the next time the user does a read() or write().
 	 */
-	if (events & COMEDI_CB_ERROR_MASK) {
-		runflags_mask |= COMEDI_SRF_ERROR;
-		runflags |= COMEDI_SRF_ERROR;
-	}
-	if (runflags_mask) {
-		/*
-		 * Changes COMEDI_SRF_ERROR and COMEDI_SRF_RUNNING together
-		 * atomically.
-		 */
-		comedi_update_subdevice_runflags(s, runflags_mask, runflags);
-	}
+	if (events & COMEDI_CB_ERROR_MASK)
+		__comedi_set_subdevice_runflags(s, COMEDI_SRF_ERROR);
 
 	if (async->cb_mask & events) {
-		int si_code;
-
 		wake_up_interruptible(&async->wait_head);
 		si_code = async->cmd.flags & CMDF_WRITE ? POLL_OUT : POLL_IN;
-		kill_fasync(&dev->async_queue, SIGIO, si_code);
 	}
+
+	spin_unlock_irqrestore(&s->spin_lock, flags);
+
+	if (si_code)
+		kill_fasync(&dev->async_queue, SIGIO, si_code);
 }
 EXPORT_SYMBOL_GPL(comedi_event);
 

commit aa33122f005069cb3408acf609b78b9a62f58021
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 15:13:05 2015 +0000

    staging: comedi: comedi_fops: send SIGIO according to command direction
    
    `comedi_event()` is called from low-level drivers to handle comedi
    asynchronous command event flags.  Some events cause waiting tasks to be
    woken up, and a `SIGIO` signal to be sent via `kill_fasync()`.  The
    signal code is `POLL_OUT` if the subdevice supports commands in the
    "write" direction, or `POLL_IN` for the "read" direction.  If the
    subdevice supports commands in either direction, it sends two `SIGIO`
    signals, one with each code.  Change that latter case to only send one
    `SIGIO` signal, using the direction of the current command to determine
    the signal code.  If the `CMDF_WRITE` flag is set in the current
    command, it's in the "write" direction, otherwise it's in the "read"
    direction.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 68ced20f5ca5..7ae605f6bbb6 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2674,11 +2674,11 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	if (async->cb_mask & events) {
+		int si_code;
+
 		wake_up_interruptible(&async->wait_head);
-		if (s->subdev_flags & SDF_CMD_READ)
-			kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
-		if (s->subdev_flags & SDF_CMD_WRITE)
-			kill_fasync(&dev->async_queue, SIGIO, POLL_OUT);
+		si_code = async->cmd.flags & CMDF_WRITE ? POLL_OUT : POLL_IN;
+		kill_fasync(&dev->async_queue, SIGIO, si_code);
 	}
 }
 EXPORT_SYMBOL_GPL(comedi_event);

commit 922d9ced718268e464a0884ecee09da436e00d70
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 15:13:04 2015 +0000

    staging: comedi: comedi_fops: always clear events
    
    `comedi_event()` is called from low-level drivers to handle asynchronous
    command event flags that are stored in `s->async->events` for subdevice
    `s`.  It normally clears the event flags as well.  As a safety check, it
    does nothing if no asynchronous command is running, but it leaves
    `s->async->events` unchanged in this case.  For additional safety,
    change it to always clear the event flags to avoid leaving stale event
    flags set when another asynchronous command is set up.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 999e7d010c83..68ced20f5ca5 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2648,18 +2648,20 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_async *async = s->async;
 	unsigned runflags = 0;
 	unsigned runflags_mask = 0;
+	unsigned int events = async->events;
 
+	async->events = 0;
 	if (!comedi_is_subdevice_running(s))
 		return;
 
-	if (async->events & COMEDI_CB_CANCEL_MASK)
+	if (events & COMEDI_CB_CANCEL_MASK)
 		runflags_mask |= COMEDI_SRF_RUNNING;
 
 	/*
 	 * Remember if an error event has occurred, so an error
 	 * can be returned the next time the user does a read().
 	 */
-	if (async->events & COMEDI_CB_ERROR_MASK) {
+	if (events & COMEDI_CB_ERROR_MASK) {
 		runflags_mask |= COMEDI_SRF_ERROR;
 		runflags |= COMEDI_SRF_ERROR;
 	}
@@ -2671,14 +2673,13 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 		comedi_update_subdevice_runflags(s, runflags_mask, runflags);
 	}
 
-	if (async->cb_mask & async->events) {
+	if (async->cb_mask & events) {
 		wake_up_interruptible(&async->wait_head);
 		if (s->subdev_flags & SDF_CMD_READ)
 			kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
 		if (s->subdev_flags & SDF_CMD_WRITE)
 			kill_fasync(&dev->async_queue, SIGIO, POLL_OUT);
 	}
-	async->events = 0;
 }
 EXPORT_SYMBOL_GPL(comedi_event);
 

commit 258c1dd76bf1223a0f67ff8d799b5eb383a3a632
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 15:13:03 2015 +0000

    staging: comedi: comedi_fops: remove unnecessary s->async use
    
    In places where the `s->async` value has been stored in a local
    variable, use the variable instead of repeating `s->async`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 9e49c8ac0cba..999e7d010c83 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -687,7 +687,7 @@ static void do_become_nonbusy(struct comedi_device *dev,
 		kfree(async->cmd.chanlist);
 		async->cmd.chanlist = NULL;
 		s->busy = NULL;
-		wake_up_interruptible_all(&s->async->wait_head);
+		wake_up_interruptible_all(&async->wait_head);
 	} else {
 		dev_err(dev->class_dev,
 			"BUG: (?) do_become_nonbusy called with async=NULL\n");
@@ -2652,14 +2652,14 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (!comedi_is_subdevice_running(s))
 		return;
 
-	if (s->async->events & COMEDI_CB_CANCEL_MASK)
+	if (async->events & COMEDI_CB_CANCEL_MASK)
 		runflags_mask |= COMEDI_SRF_RUNNING;
 
 	/*
 	 * Remember if an error event has occurred, so an error
 	 * can be returned the next time the user does a read().
 	 */
-	if (s->async->events & COMEDI_CB_ERROR_MASK) {
+	if (async->events & COMEDI_CB_ERROR_MASK) {
 		runflags_mask |= COMEDI_SRF_ERROR;
 		runflags |= COMEDI_SRF_ERROR;
 	}
@@ -2671,14 +2671,14 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 		comedi_update_subdevice_runflags(s, runflags_mask, runflags);
 	}
 
-	if (async->cb_mask & s->async->events) {
+	if (async->cb_mask & async->events) {
 		wake_up_interruptible(&async->wait_head);
 		if (s->subdev_flags & SDF_CMD_READ)
 			kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
 		if (s->subdev_flags & SDF_CMD_WRITE)
 			kill_fasync(&dev->async_queue, SIGIO, POLL_OUT);
 	}
-	s->async->events = 0;
+	async->events = 0;
 }
 EXPORT_SYMBOL_GPL(comedi_event);
 

commit 38ee1fd309a629a618c031238c5d681ed4239af4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 15:13:02 2015 +0000

    staging: comedi: comedi_fops: simplify comedi_is_subdevice_idle()
    
    Don't use a conditional operator when a simple "not" will do.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 17ac2858205d..9e49c8ac0cba 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -652,7 +652,7 @@ static bool comedi_is_subdevice_idle(struct comedi_subdevice *s)
 {
 	unsigned runflags = comedi_get_subdevice_runflags(s);
 
-	return (runflags & COMEDI_SRF_BUSY_MASK) ? false : true;
+	return !(runflags & COMEDI_SRF_BUSY_MASK);
 }
 
 /**

commit b183a836fe02a59c2b55273655196ba288f3adb7
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 15:13:01 2015 +0000

    staging: comedi: comedi_fops: eliminate a use of subdevice spin-lock
    
    `comedi_is_subdevice_in_error()` is only used by `comedi_read()` and
    `comedi_write()` and is only called (soon) after
    `comedi_is_subdevice_running()` returns `false` (with extra conditions
    in the case of `comedi_write()`).  `comedi_is_subdevice_running()` and
    `comedi_get_subdevice_runflags()` both call
    `comedi_get_subdevice_runflags()` which uses the subdevice's spin-lock.
    
    Eliminate one use of the subdevice's spin-lock in `comedi_read()` and
    `comedi_write()` by calling `comedi_get_subdevice_runflags()` and
    checking the runflags directly.  Add a couple of inline functions to
    check the runflags: `comedi_is_runflags_running()` and
    `comedi_is_runflags_in_error()`.  These do the same test on runflags as
    `comedi_is_subdevice_running()` and `comedi_is_subdevice_in_error()` but
    get passed the runflags value directly.
    
    `comedi_is_subdevice_in_error()` is no longer used, so remove it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 2b75b7a1cee0..17ac2858205d 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -623,6 +623,16 @@ static unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 	return runflags;
 }
 
+static bool comedi_is_runflags_running(unsigned runflags)
+{
+	return runflags & COMEDI_SRF_RUNNING;
+}
+
+static bool comedi_is_runflags_in_error(unsigned runflags)
+{
+	return runflags & COMEDI_SRF_ERROR;
+}
+
 /**
  * comedi_is_subdevice_running - check if async command running on subdevice
  * @s: comedi_subdevice struct
@@ -634,17 +644,10 @@ bool comedi_is_subdevice_running(struct comedi_subdevice *s)
 {
 	unsigned runflags = comedi_get_subdevice_runflags(s);
 
-	return (runflags & COMEDI_SRF_RUNNING) ? true : false;
+	return comedi_is_runflags_running(runflags);
 }
 EXPORT_SYMBOL_GPL(comedi_is_subdevice_running);
 
-static bool comedi_is_subdevice_in_error(struct comedi_subdevice *s)
-{
-	unsigned runflags = comedi_get_subdevice_runflags(s);
-
-	return (runflags & COMEDI_SRF_ERROR) ? true : false;
-}
-
 static bool comedi_is_subdevice_idle(struct comedi_subdevice *s)
 {
 	unsigned runflags = comedi_get_subdevice_runflags(s);
@@ -2282,13 +2285,16 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	add_wait_queue(&async->wait_head, &wait);
 	on_wait_queue = true;
 	while (nbytes > 0 && !retval) {
+		unsigned runflags;
+
 		set_current_state(TASK_INTERRUPTIBLE);
 
-		if (!comedi_is_subdevice_running(s)) {
+		runflags = comedi_get_subdevice_runflags(s);
+		if (!comedi_is_runflags_running(runflags)) {
 			if (count == 0) {
 				struct comedi_subdevice *new_s;
 
-				if (comedi_is_subdevice_in_error(s))
+				if (comedi_is_runflags_in_error(runflags))
 					retval = -EPIPE;
 				else
 					retval = 0;
@@ -2435,8 +2441,10 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 			n = m;
 
 		if (n == 0) {
-			if (!comedi_is_subdevice_running(s)) {
-				if (comedi_is_subdevice_in_error(s))
+			unsigned runflags = comedi_get_subdevice_runflags(s);
+
+			if (!comedi_is_runflags_running(runflags)) {
+				if (comedi_is_runflags_in_error(runflags))
 					retval = -EPIPE;
 				else
 					retval = 0;

commit cc64ea4239c354d30f88130ecf5aa81a506b57e3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 15:13:00 2015 +0000

    staging: comedi: comedi_fops: rename comedi_set_subdevice_runflags()
    
    `comedi_set_subdevice_runflags()` changes the comedi subdevice's
    `runflags` member according to a bit-mask and new bit values.  It's name
    might suggest that it only "sets", not "clears".  Rename it to
    `comedi_update_subdevice_runflags()` to avoid confusion.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 8bf57b736659..2b75b7a1cee0 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -601,8 +601,8 @@ static struct attribute *comedi_dev_attrs[] = {
 };
 ATTRIBUTE_GROUPS(comedi_dev);
 
-static void comedi_set_subdevice_runflags(struct comedi_subdevice *s,
-					  unsigned mask, unsigned bits)
+static void comedi_update_subdevice_runflags(struct comedi_subdevice *s,
+					     unsigned mask, unsigned bits)
 {
 	unsigned long flags;
 
@@ -677,7 +677,7 @@ static void do_become_nonbusy(struct comedi_device *dev,
 {
 	struct comedi_async *async = s->async;
 
-	comedi_set_subdevice_runflags(s, COMEDI_SRF_RUNNING, 0);
+	comedi_update_subdevice_runflags(s, COMEDI_SRF_RUNNING, 0);
 	if (async) {
 		comedi_buf_reset(s);
 		async->inttrig = NULL;
@@ -1678,8 +1678,8 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	if (async->cmd.flags & CMDF_WAKE_EOS)
 		async->cb_mask |= COMEDI_CB_EOS;
 
-	comedi_set_subdevice_runflags(s, COMEDI_SRF_BUSY_MASK,
-				      COMEDI_SRF_RUNNING);
+	comedi_update_subdevice_runflags(s, COMEDI_SRF_BUSY_MASK,
+					 COMEDI_SRF_RUNNING);
 
 	/*
 	 * Set s->busy _after_ setting COMEDI_SRF_RUNNING flag to avoid
@@ -2657,10 +2657,10 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	if (runflags_mask) {
 		/*
-		 * Sets COMEDI_SRF_ERROR and COMEDI_SRF_RUNNING together
+		 * Changes COMEDI_SRF_ERROR and COMEDI_SRF_RUNNING together
 		 * atomically.
 		 */
-		comedi_set_subdevice_runflags(s, runflags_mask, runflags);
+		comedi_update_subdevice_runflags(s, runflags_mask, runflags);
 	}
 
 	if (async->cb_mask & s->async->events) {

commit a112eab4d5e78433a7c65b5703ad177cdabc6588
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Tue Mar 17 08:33:51 2015 +0300

    Staging: comedi: replace pr_err with dev_err
    
    This patch replace pr_err with dev_err, when appropriate device
    structure is found.
    Issue found using the following Coccinelle script:
    
    @r exists@
    identifier f, s, i;
    position p;
    @@
    
    f(...,struct s *i,...) {
    <+...
    when != i == NULL
    pr_err@p(...);
    ...+>
    }
    
    @rr@
    identifier r.s, fld;
    @@
    
    struct s {
            ...
            struct device *fld;
            ...
    };
    
    @@
    identifier r.i, rr.fld;
    position r.p;
    @@
    -pr_err@p
    +dev_err
       (
    + i->fld,
    ...)
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 2f8257cd9824..8bf57b736659 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2700,7 +2700,8 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 		mutex_unlock(&dev->mutex);
 		comedi_device_cleanup(dev);
 		comedi_dev_put(dev);
-		pr_err("ran out of minor numbers for board device files\n");
+		dev_err(hardware_device,
+			"ran out of minor numbers for board device files\n");
 		return ERR_PTR(-EBUSY);
 	}
 	dev->minor = i;
@@ -2753,7 +2754,8 @@ int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 	}
 	mutex_unlock(&comedi_subdevice_minor_table_lock);
 	if (i == COMEDI_NUM_SUBDEVICE_MINORS) {
-		pr_err("ran out of minor numbers for subdevice files\n");
+		dev_err(dev->class_dev,
+			"ran out of minor numbers for subdevice files\n");
 		return -EBUSY;
 	}
 	i += COMEDI_NUM_BOARD_MINORS;

commit 88cc30cfcfd38d81da3f8b4d9cedb16556c5fdfc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 4 12:15:28 2015 -0700

    staging: comedi: comedi_fops: (!foo) preferred over (foo == NULL)
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 727640e89c73..2f8257cd9824 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -144,7 +144,7 @@ static void comedi_device_cleanup(struct comedi_device *dev)
 {
 	struct module *driver_module = NULL;
 
-	if (dev == NULL)
+	if (!dev)
 		return;
 	mutex_lock(&dev->mutex);
 	if (dev->attached)
@@ -260,7 +260,7 @@ comedi_read_subdevice(const struct comedi_device *dev, unsigned int minor)
 
 	if (minor >= COMEDI_NUM_BOARD_MINORS) {
 		s = comedi_subdevice_from_minor(dev, minor);
-		if (s == NULL || (s->subdev_flags & SDF_CMD_READ))
+		if (!s || (s->subdev_flags & SDF_CMD_READ))
 			return s;
 	}
 	return dev->read_subdev;
@@ -273,7 +273,7 @@ comedi_write_subdevice(const struct comedi_device *dev, unsigned int minor)
 
 	if (minor >= COMEDI_NUM_BOARD_MINORS) {
 		s = comedi_subdevice_from_minor(dev, minor);
-		if (s == NULL || (s->subdev_flags & SDF_CMD_WRITE))
+		if (!s || (s->subdev_flags & SDF_CMD_WRITE))
 			return s;
 	}
 	return dev->write_subdev;
@@ -290,9 +290,9 @@ static void comedi_file_reset(struct file *file)
 	write_s = dev->write_subdev;
 	if (minor >= COMEDI_NUM_BOARD_MINORS) {
 		s = comedi_subdevice_from_minor(dev, minor);
-		if (s == NULL || s->subdev_flags & SDF_CMD_READ)
+		if (!s || s->subdev_flags & SDF_CMD_READ)
 			read_s = s;
-		if (s == NULL || s->subdev_flags & SDF_CMD_WRITE)
+		if (!s || s->subdev_flags & SDF_CMD_WRITE)
 			write_s = s;
 	}
 	cfp->last_attached = dev->attached;
@@ -759,7 +759,7 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
-	if (arg == NULL) {
+	if (!arg) {
 		if (is_device_busy(dev))
 			return -EBUSY;
 		if (dev->attached) {
@@ -1840,7 +1840,7 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned long arg,
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
 	s = &dev->subdevices[arg];
-	if (s->async == NULL)
+	if (!s->async)
 		return -EINVAL;
 
 	if (!s->busy)
@@ -2682,7 +2682,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	unsigned i;
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (dev == NULL)
+	if (!dev)
 		return ERR_PTR(-ENOMEM);
 	comedi_device_init(dev);
 	comedi_set_hw_dev(dev, hardware_device);
@@ -2690,7 +2690,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	mutex_lock(&comedi_board_minor_table_lock);
 	for (i = hardware_device ? comedi_num_legacy_minors : 0;
 	     i < COMEDI_NUM_BOARD_MINORS; ++i) {
-		if (comedi_board_minor_table[i] == NULL) {
+		if (!comedi_board_minor_table[i]) {
 			comedi_board_minor_table[i] = dev;
 			break;
 		}
@@ -2746,7 +2746,7 @@ int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 
 	mutex_lock(&comedi_subdevice_minor_table_lock);
 	for (i = 0; i < COMEDI_NUM_SUBDEVICE_MINORS; ++i) {
-		if (comedi_subdevice_minor_table[i] == NULL) {
+		if (!comedi_subdevice_minor_table[i]) {
 			comedi_subdevice_minor_table[i] = s;
 			break;
 		}
@@ -2771,7 +2771,7 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 {
 	unsigned int i;
 
-	if (s == NULL)
+	if (!s)
 		return;
 	if (s->minor < 0)
 		return;

commit a2aab8b481eb85ec445c2b50cfa263236aad07bd
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jan 28 18:41:50 2015 +0000

    staging: comedi: comedi_fops.c: reformat remaining block comments
    
    Reformat remaining block comments to use the usual block comment style.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 5403af127d71..727640e89c73 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -347,8 +347,7 @@ static int resize_async_buffer(struct comedi_device *dev,
 		return -EBUSY;
 	}
 
-	/* make sure buffer is an integral number of pages
-	 * (we round up) */
+	/* make sure buffer is an integral number of pages (we round up) */
 	new_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;
 
 	retval = comedi_buf_alloc(dev, s, new_size);
@@ -671,7 +670,7 @@ void *comedi_alloc_spriv(struct comedi_subdevice *s, size_t size)
 EXPORT_SYMBOL_GPL(comedi_alloc_spriv);
 
 /*
-   This function restores a subdevice to an idle state.
+ * This function restores a subdevice to an idle state.
  */
 static void do_become_nonbusy(struct comedi_device *dev,
 			      struct comedi_subdevice *s)
@@ -1162,8 +1161,10 @@ static int check_insn_config_length(struct comedi_insn *insn,
 		if (insn->n == 6)
 			return 0;
 		break;
-		/* by default we allow the insn since we don't have checks for
-		 * all possible cases yet */
+		/*
+		 * by default we allow the insn since we don't have checks for
+		 * all possible cases yet
+		 */
 	default:
 		pr_warn("No check for data length of config insn id %i is implemented\n",
 			data[0]);
@@ -1314,9 +1315,11 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 			if (insn->n != 2) {
 				ret = -EINVAL;
 			} else {
-				/* Most drivers ignore the base channel in
+				/*
+				 * Most drivers ignore the base channel in
 				 * insn->chanspec.  Fix this here if
-				 * the subdevice has <= 32 channels.  */
+				 * the subdevice has <= 32 channels.
+				 */
 				unsigned int orig_mask = data[0];
 				unsigned int shift = 0;
 
@@ -1977,8 +1980,10 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 
 	mutex_lock(&dev->mutex);
 
-	/* Device config is special, because it must work on
-	 * an unconfigured device. */
+	/*
+	 * Device config is special, because it must work on
+	 * an unconfigured device.
+	 */
 	if (cmd == COMEDI_DEVCONFIG) {
 		if (minor >= COMEDI_NUM_BOARD_MINORS) {
 			/* Device config not appropriate on non-board minors. */
@@ -1990,8 +1995,10 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 		if (rc == 0) {
 			if (arg == 0 &&
 			    dev->minor >= comedi_num_legacy_minors) {
-				/* Successfully unconfigured a dynamically
-				 * allocated device.  Try and remove it. */
+				/*
+				 * Successfully unconfigured a dynamically
+				 * allocated device.  Try and remove it.
+				 */
 				if (comedi_clear_board_dev(dev)) {
 					mutex_unlock(&dev->mutex);
 					comedi_free_board_dev(dev);

commit 18e01b24a7b60534a1871085a27bfee7d694bc55
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jan 28 18:41:47 2015 +0000

    staging: comedi: comedi_fops.c: reformat ioctl handler comments
    
    The unlocked_ioctl handler calls a different function to handle each
    supported ioctl command code.  Most of these have a block comment
    indicating which command code it handles, a brief description, and an
    informal description of the inputs and outputs.  These block comments
    are formatted in various styles.  Reformat them to the usual block
    comment style and do a bit of rewording for consistency.  The comment
    block for the `COMEDI_CMD` ioctl is missing, so add one.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 8f65097406d6..5403af127d71 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -740,18 +740,18 @@ static int is_device_busy(struct comedi_device *dev)
 }
 
 /*
-	COMEDI_DEVCONFIG
-	device config ioctl
-
-	arg:
-		pointer to devconfig structure
-
-	reads:
-		devconfig structure at arg
-
-	writes:
-		none
-*/
+ * COMEDI_DEVCONFIG ioctl
+ * attaches (and configures) or detaches a legacy device
+ *
+ * arg:
+ *	pointer to comedi_devconfig structure (NULL if detaching)
+ *
+ * reads:
+ *	comedi_devconfig structure (if attaching)
+ *
+ * writes:
+ *	nothing
+ */
 static int do_devconfig_ioctl(struct comedi_device *dev,
 			      struct comedi_devconfig __user *arg)
 {
@@ -792,19 +792,18 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 }
 
 /*
-	COMEDI_BUFCONFIG
-	buffer configuration ioctl
-
-	arg:
-		pointer to bufconfig structure
-
-	reads:
-		bufconfig at arg
-
-	writes:
-		modified bufconfig at arg
-
-*/
+ * COMEDI_BUFCONFIG ioctl
+ * buffer configuration
+ *
+ * arg:
+ *	pointer to comedi_bufconfig structure
+ *
+ * reads:
+ *	comedi_bufconfig structure
+ *
+ * writes:
+ *	modified comedi_bufconfig structure
+ */
 static int do_bufconfig_ioctl(struct comedi_device *dev,
 			      struct comedi_bufconfig __user *arg)
 {
@@ -854,19 +853,18 @@ static int do_bufconfig_ioctl(struct comedi_device *dev,
 }
 
 /*
-	COMEDI_DEVINFO
-	device info ioctl
-
-	arg:
-		pointer to devinfo structure
-
-	reads:
-		none
-
-	writes:
-		devinfo structure
-
-*/
+ * COMEDI_DEVINFO ioctl
+ * device info
+ *
+ * arg:
+ *	pointer to comedi_devinfo structure
+ *
+ * reads:
+ *	nothing
+ *
+ * writes:
+ *	comedi_devinfo structure
+ */
 static int do_devinfo_ioctl(struct comedi_device *dev,
 			    struct comedi_devinfo __user *arg,
 			    struct file *file)
@@ -901,19 +899,18 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 }
 
 /*
-	COMEDI_SUBDINFO
-	subdevice info ioctl
-
-	arg:
-		pointer to array of subdevice info structures
-
-	reads:
-		none
-
-	writes:
-		array of subdevice info structures at arg
-
-*/
+ * COMEDI_SUBDINFO ioctl
+ * subdevices info
+ *
+ * arg:
+ *	pointer to array of comedi_subdinfo structures
+ *
+ * reads:
+ *	nothing
+ *
+ * writes:
+ *	array of comedi_subdinfo structures
+ */
 static int do_subdinfo_ioctl(struct comedi_device *dev,
 			     struct comedi_subdinfo __user *arg, void *file)
 {
@@ -975,19 +972,19 @@ static int do_subdinfo_ioctl(struct comedi_device *dev,
 }
 
 /*
-	COMEDI_CHANINFO
-	subdevice info ioctl
-
-	arg:
-		pointer to chaninfo structure
-
-	reads:
-		chaninfo structure at arg
-
-	writes:
-		arrays at elements of chaninfo structure
-
-*/
+ * COMEDI_CHANINFO ioctl
+ * subdevice channel info
+ *
+ * arg:
+ *	pointer to comedi_chaninfo structure
+ *
+ * reads:
+ *	comedi_chaninfo structure
+ *
+ * writes:
+ *	array of maxdata values to chaninfo->maxdata_list if requested
+ *	array of range table lengths to chaninfo->range_table_list if requested
+ */
 static int do_chaninfo_ioctl(struct comedi_device *dev,
 			     struct comedi_chaninfo __user *arg)
 {
@@ -1035,20 +1032,19 @@ static int do_chaninfo_ioctl(struct comedi_device *dev,
 	return 0;
 }
 
- /*
-    COMEDI_BUFINFO
-    buffer information ioctl
-
-    arg:
-    pointer to bufinfo structure
-
-    reads:
-    bufinfo at arg
-
-    writes:
-    modified bufinfo at arg
-
-  */
+/*
+ * COMEDI_BUFINFO ioctl
+ * buffer information
+ *
+ * arg:
+ *	pointer to comedi_bufinfo structure
+ *
+ * reads:
+ *	comedi_bufinfo structure
+ *
+ * writes:
+ *	modified comedi_bufinfo structure
+ */
 static int do_bufinfo_ioctl(struct comedi_device *dev,
 			    struct comedi_bufinfo __user *arg, void *file)
 {
@@ -1357,19 +1353,19 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 }
 
 /*
- *	COMEDI_INSNLIST
- *	synchronous instructions
+ * COMEDI_INSNLIST ioctl
+ * synchronous instruction list
  *
- *	arg:
- *		pointer to sync cmd structure
+ * arg:
+ *	pointer to comedi_insnlist structure
  *
- *	reads:
- *		sync cmd struct at arg
- *		instruction list
- *		data (for writes)
+ * reads:
+ *	comedi_insnlist structure
+ *	array of comedi_insn structures from insnlist->insns pointer
+ *	data (for writes) from insns[].data pointers
  *
- *	writes:
- *		data (for reads)
+ * writes:
+ *	data (for reads) to insns[].data pointers
  */
 /* arbitrary limits */
 #define MAX_SAMPLES 256
@@ -1446,18 +1442,18 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 }
 
 /*
- *	COMEDI_INSN
- *	synchronous instructions
+ * COMEDI_INSN ioctl
+ * synchronous instruction
  *
- *	arg:
- *		pointer to insn
+ * arg:
+ *	pointer to comedi_insn structure
  *
- *	reads:
- *		struct comedi_insn struct at arg
- *		data (for writes)
+ * reads:
+ *	comedi_insn structure
+ *	data (for writes) from insn->data pointer
  *
- *	writes:
- *		data (for reads)
+ * writes:
+ *	data (for reads) to insn->data pointer
  */
 static int do_insn_ioctl(struct comedi_device *dev,
 			 struct comedi_insn __user *arg, void *file)
@@ -1589,6 +1585,20 @@ static int __comedi_get_user_chanlist(struct comedi_device *dev,
 	return 0;
 }
 
+/*
+ * COMEDI_CMD ioctl
+ * asynchronous acquisition command set-up
+ *
+ * arg:
+ *	pointer to comedi_cmd structure
+ *
+ * reads:
+ *	comedi_cmd structure
+ *	channel/range list from cmd->chanlist pointer
+ *
+ * writes:
+ *	possibly modified comedi_cmd structure (when -EAGAIN returned)
+ */
 static int do_cmd_ioctl(struct comedi_device *dev,
 			struct comedi_cmd __user *arg, void *file)
 {
@@ -1684,20 +1694,19 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 }
 
 /*
-	COMEDI_CMDTEST
-	command testing ioctl
-
-	arg:
-		pointer to cmd structure
-
-	reads:
-		cmd structure at arg
-		channel/range list
-
-	writes:
-		modified cmd structure at arg
-
-*/
+ * COMEDI_CMDTEST ioctl
+ * asynchronous aquisition command testing
+ *
+ * arg:
+ *	pointer to comedi_cmd structure
+ *
+ * reads:
+ *	comedi_cmd structure
+ *	channel/range list from cmd->chanlist pointer
+ *
+ * writes:
+ *	possibly modified comedi_cmd structure
+ */
 static int do_cmdtest_ioctl(struct comedi_device *dev,
 			    struct comedi_cmd __user *arg, void *file)
 {
@@ -1740,20 +1749,18 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 }
 
 /*
-	COMEDI_LOCK
-	lock subdevice
-
-	arg:
-		subdevice number
-
-	reads:
-		none
-
-	writes:
-		none
-
-*/
-
+ * COMEDI_LOCK ioctl
+ * lock subdevice
+ *
+ * arg:
+ *	subdevice number
+ *
+ * reads:
+ *	nothing
+ *
+ * writes:
+ *	nothing
+ */
 static int do_lock_ioctl(struct comedi_device *dev, unsigned long arg,
 			 void *file)
 {
@@ -1776,21 +1783,18 @@ static int do_lock_ioctl(struct comedi_device *dev, unsigned long arg,
 }
 
 /*
-	COMEDI_UNLOCK
-	unlock subdevice
-
-	arg:
-		subdevice number
-
-	reads:
-		none
-
-	writes:
-		none
-
-	This function isn't protected by the semaphore, since
-	we already own the lock.
-*/
+ * COMEDI_UNLOCK ioctl
+ * unlock subdevice
+ *
+ * arg:
+ *	subdevice number
+ *
+ * reads:
+ *	nothing
+ *
+ * writes:
+ *	nothing
+ */
 static int do_unlock_ioctl(struct comedi_device *dev, unsigned long arg,
 			   void *file)
 {
@@ -1813,19 +1817,18 @@ static int do_unlock_ioctl(struct comedi_device *dev, unsigned long arg,
 }
 
 /*
-	COMEDI_CANCEL
-	cancel acquisition ioctl
-
-	arg:
-		subdevice number
-
-	reads:
-		nothing
-
-	writes:
-		nothing
-
-*/
+ * COMEDI_CANCEL ioctl
+ * cancel asynchronous acquisition
+ *
+ * arg:
+ *	subdevice number
+ *
+ * reads:
+ *	nothing
+ *
+ * writes:
+ *	nothing
+ */
 static int do_cancel_ioctl(struct comedi_device *dev, unsigned long arg,
 			   void *file)
 {
@@ -1847,19 +1850,18 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned long arg,
 }
 
 /*
-	COMEDI_POLL ioctl
-	instructs driver to synchronize buffers
-
-	arg:
-		subdevice number
-
-	reads:
-		nothing
-
-	writes:
-		nothing
-
-*/
+ * COMEDI_POLL ioctl
+ * instructs driver to synchronize buffers
+ *
+ * arg:
+ *	subdevice number
+ *
+ * reads:
+ *	nothing
+ *
+ * writes:
+ *	nothing
+ */
 static int do_poll_ioctl(struct comedi_device *dev, unsigned long arg,
 			 void *file)
 {

commit dd630cdeb160fc4f219481a68771d683d59178ee
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jan 28 18:41:46 2015 +0000

    staging: comedi: comedi_fops.c: document exported functions
    
    Add kerneldoc for exported functions `comedi_dev_put()`,
    `comedi_dev_get_from_minor()`, `comedi_is_subdevice_running()`, and
    `comedi_event()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index bb2e7961ec3c..8f65097406d6 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -113,6 +113,18 @@ static void comedi_dev_kref_release(struct kref *kref)
 	kfree(dev);
 }
 
+/**
+ * comedi_dev_put - release a use of a comedi device structure
+ * @dev: comedi_device struct
+ *
+ * Must be called when a user of a comedi device is finished with it.
+ * When the last user of the comedi device calls this function, the
+ * comedi device is destroyed.
+ *
+ * Return 1 if the comedi device is destroyed by this call or dev is
+ * NULL, otherwise return 0.  Callers must not assume the comedi
+ * device is still valid if this function returns 0.
+ */
 int comedi_dev_put(struct comedi_device *dev)
 {
 	if (dev)
@@ -220,6 +232,18 @@ static struct comedi_device *comedi_dev_get_from_subdevice_minor(unsigned minor)
 	return dev;
 }
 
+/**
+ * comedi_dev_get_from_minor - get comedi device by minor device number
+ * @minor: minor device number
+ *
+ * Finds the comedi device associated by the minor device number, if any,
+ * and increments its reference count.  The comedi device is prevented from
+ * being freed until a matching call is made to comedi_dev_put().
+ *
+ * Return a pointer to the comedi device if it exists, with its usage
+ * reference incremented.  Return NULL if no comedi device exists with the
+ * specified minor device number.
+ */
 struct comedi_device *comedi_dev_get_from_minor(unsigned minor)
 {
 	if (minor < COMEDI_NUM_BOARD_MINORS)
@@ -600,6 +624,13 @@ static unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 	return runflags;
 }
 
+/**
+ * comedi_is_subdevice_running - check if async command running on subdevice
+ * @s: comedi_subdevice struct
+ *
+ * Return true if an asynchronous comedi command is active on the comedi
+ * subdevice, else return false.
+ */
 bool comedi_is_subdevice_running(struct comedi_subdevice *s)
 {
 	unsigned runflags = comedi_get_subdevice_runflags(s);
@@ -2584,6 +2615,17 @@ static const struct file_operations comedi_fops = {
 	.llseek = noop_llseek,
 };
 
+/**
+ * comedi_event - handle events for asynchronous comedi command
+ * @dev: comedi_device struct
+ * @s: comedi_subdevice struct associated with dev
+ * Context: interrupt (usually), s->spin_lock spin-lock not held
+ *
+ * If an asynchronous comedi command is active on the subdevice, process
+ * any COMEDI_CB_... event flags that have been set, usually by an
+ * interrupt handler.  These may change the run state of the asynchronous
+ * command, wake a task, and/or send a SIGIO signal.
+ */
 void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;

commit f6fef5df1accf2851d4c357eddcde8bcaf8349d6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jan 28 18:41:45 2015 +0000

    staging: comedi: comedi_fops.c: reformat copyright header
    
    Use the usual block comment style.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 68bfe92319e6..bb2e7961ec3c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1,20 +1,20 @@
 /*
-    comedi/comedi_fops.c
-    comedi kernel module
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 1997-2000 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
+ * comedi/comedi_fops.c
+ * comedi kernel module
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 1997-2000 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 

commit 84bb0bccd26ec3029124a9dd200b985c1cde77bd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:00 2015 -0700

    staging: comedi: comedidev.h: add namespace to the subdevice "runflags"
    
    Tidy up and document the subdevice "runflags". Rename them so they have
    comedi namespace.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f143cb64d69e..68bfe92319e6 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -604,7 +604,7 @@ bool comedi_is_subdevice_running(struct comedi_subdevice *s)
 {
 	unsigned runflags = comedi_get_subdevice_runflags(s);
 
-	return (runflags & SRF_RUNNING) ? true : false;
+	return (runflags & COMEDI_SRF_RUNNING) ? true : false;
 }
 EXPORT_SYMBOL_GPL(comedi_is_subdevice_running);
 
@@ -612,14 +612,14 @@ static bool comedi_is_subdevice_in_error(struct comedi_subdevice *s)
 {
 	unsigned runflags = comedi_get_subdevice_runflags(s);
 
-	return (runflags & SRF_ERROR) ? true : false;
+	return (runflags & COMEDI_SRF_ERROR) ? true : false;
 }
 
 static bool comedi_is_subdevice_idle(struct comedi_subdevice *s)
 {
 	unsigned runflags = comedi_get_subdevice_runflags(s);
 
-	return (runflags & (SRF_ERROR | SRF_RUNNING)) ? false : true;
+	return (runflags & COMEDI_SRF_BUSY_MASK) ? false : true;
 }
 
 /**
@@ -634,7 +634,7 @@ void *comedi_alloc_spriv(struct comedi_subdevice *s, size_t size)
 {
 	s->private = kzalloc(size, GFP_KERNEL);
 	if (s->private)
-		s->runflags |= SRF_FREE_SPRIV;
+		s->runflags |= COMEDI_SRF_FREE_SPRIV;
 	return s->private;
 }
 EXPORT_SYMBOL_GPL(comedi_alloc_spriv);
@@ -647,7 +647,7 @@ static void do_become_nonbusy(struct comedi_device *dev,
 {
 	struct comedi_async *async = s->async;
 
-	comedi_set_subdevice_runflags(s, SRF_RUNNING, 0);
+	comedi_set_subdevice_runflags(s, COMEDI_SRF_RUNNING, 0);
 	if (async) {
 		comedi_buf_reset(s);
 		async->inttrig = NULL;
@@ -1634,10 +1634,13 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	if (async->cmd.flags & CMDF_WAKE_EOS)
 		async->cb_mask |= COMEDI_CB_EOS;
 
-	comedi_set_subdevice_runflags(s, SRF_ERROR | SRF_RUNNING, SRF_RUNNING);
+	comedi_set_subdevice_runflags(s, COMEDI_SRF_BUSY_MASK,
+				      COMEDI_SRF_RUNNING);
 
-	/* set s->busy _after_ setting SRF_RUNNING flag to avoid race with
-	 * comedi_read() or comedi_write() */
+	/*
+	 * Set s->busy _after_ setting COMEDI_SRF_RUNNING flag to avoid
+	 * race with comedi_read() or comedi_write().
+	 */
 	s->busy = file;
 	ret = s->do_cmd(dev, s);
 	if (ret == 0)
@@ -2591,18 +2594,21 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 		return;
 
 	if (s->async->events & COMEDI_CB_CANCEL_MASK)
-		runflags_mask |= SRF_RUNNING;
+		runflags_mask |= COMEDI_SRF_RUNNING;
 
 	/*
 	 * Remember if an error event has occurred, so an error
 	 * can be returned the next time the user does a read().
 	 */
 	if (s->async->events & COMEDI_CB_ERROR_MASK) {
-		runflags_mask |= SRF_ERROR;
-		runflags |= SRF_ERROR;
+		runflags_mask |= COMEDI_SRF_ERROR;
+		runflags |= COMEDI_SRF_ERROR;
 	}
 	if (runflags_mask) {
-		/*sets SRF_ERROR and SRF_RUNNING together atomically */
+		/*
+		 * Sets COMEDI_SRF_ERROR and COMEDI_SRF_RUNNING together
+		 * atomically.
+		 */
 		comedi_set_subdevice_runflags(s, runflags_mask, runflags);
 	}
 

commit c299a6789c35392dcd66f806013bab86969cf5c4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Nov 4 18:09:01 2014 +0000

    staging: comedi: add ioctls to set per-file read and write subdevice
    
    Now that Comedi has the structures in place to support setting the
    current "read" and/or "write" subdevice on a per-file object basis, add
    new ioctls to set them.  The newly chosen "read" ("write") subdevice
    needs to support "read" ("write") commands, and the file cannot be busy
    handling a "read" ("write") command on the previous subdevice (if any).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 79b852c6d868..f143cb64d69e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1847,6 +1847,90 @@ static int do_poll_ioctl(struct comedi_device *dev, unsigned long arg,
 	return -EINVAL;
 }
 
+/*
+ * COMEDI_SETRSUBD ioctl
+ * sets the current "read" subdevice on a per-file basis
+ *
+ * arg:
+ *	subdevice number
+ *
+ * reads:
+ *	nothing
+ *
+ * writes:
+ *	nothing
+ */
+static int do_setrsubd_ioctl(struct comedi_device *dev, unsigned long arg,
+			     struct file *file)
+{
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_subdevice *s_old, *s_new;
+
+	if (arg >= dev->n_subdevices)
+		return -EINVAL;
+
+	s_new = &dev->subdevices[arg];
+	s_old = comedi_file_read_subdevice(file);
+	if (s_old == s_new)
+		return 0;	/* no change */
+
+	if (!(s_new->subdev_flags & SDF_CMD_READ))
+		return -EINVAL;
+
+	/*
+	 * Check the file isn't still busy handling a "read" command on the
+	 * old subdevice (if any).
+	 */
+	if (s_old && s_old->busy == file && s_old->async &&
+	    !(s_old->async->cmd.flags & CMDF_WRITE))
+		return -EBUSY;
+
+	ACCESS_ONCE(cfp->read_subdev) = s_new;
+	return 0;
+}
+
+/*
+ * COMEDI_SETWSUBD ioctl
+ * sets the current "write" subdevice on a per-file basis
+ *
+ * arg:
+ *	subdevice number
+ *
+ * reads:
+ *	nothing
+ *
+ * writes:
+ *	nothing
+ */
+static int do_setwsubd_ioctl(struct comedi_device *dev, unsigned long arg,
+			     struct file *file)
+{
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_subdevice *s_old, *s_new;
+
+	if (arg >= dev->n_subdevices)
+		return -EINVAL;
+
+	s_new = &dev->subdevices[arg];
+	s_old = comedi_file_write_subdevice(file);
+	if (s_old == s_new)
+		return 0;	/* no change */
+
+	if (!(s_new->subdev_flags & SDF_CMD_WRITE))
+		return -EINVAL;
+
+	/*
+	 * Check the file isn't still busy handling a "write" command on the
+	 * old subdevice (if any).
+	 */
+	if (s_old && s_old->busy == file && s_old->async &&
+	    (s_old->async->cmd.flags & CMDF_WRITE))
+		return -EBUSY;
+
+	ACCESS_ONCE(cfp->write_subdev) = s_new;
+	return 0;
+}
+
 static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 				  unsigned long arg)
 {
@@ -1941,6 +2025,12 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 	case COMEDI_POLL:
 		rc = do_poll_ioctl(dev, arg, file);
 		break;
+	case COMEDI_SETRSUBD:
+		rc = do_setrsubd_ioctl(dev, arg, file);
+		break;
+	case COMEDI_SETWSUBD:
+		rc = do_setwsubd_ioctl(dev, arg, file);
+		break;
 	default:
 		rc = -ENOTTY;
 		break;

commit 20f083c07565cb75a5f04e97acfc8faff2b13101
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Nov 4 18:09:00 2014 +0000

    staging: comedi: prepare support for per-file read and write subdevices
    
    Comedi devices may have several subdevices that support "read" and/or
    "write" asynchronous commands that use the "read" or "write" file
    operations for data transfer.  The low-level Comedi drivers may nominate
    a default "read" subdevice and/or a default "write" subdevice, but it
    may have other subdevices that support asynchronous commands.
    
    The Comedi core provides a somewhat clunky mechanism to provide access
    to the asynchronous command support of the non-default subdevices.  When
    a low-level device is "attached" to a core Comedi device, it dynamically
    allocates a minor device number for each of the subdevices that support
    asynchrounous commands and associates them with files created in SysFS
    named "comediX_subdY", where "X" is the minor device number of the main
    comedi device, and "Y" is the subdevice number.  An application can open
    these subdevice-specific files and they behave like the regular
    "comediX" files except that the "read" and/or "write" subdevice may be
    different to the default chosen by the low-level driver.
    
    This patch adds a layer of indirection between the file object and the
    comedi device object to allow the current "read" and/or "write"
    subdevice to be altered after opening the Comedi device, on a per-file
    object basis.  The advantage is that an application only needs to open
    the main Comedi device file and can then choose which subdevice it wants
    to "read" or "write".  The main Comedi device file can be opened more
    than once, and each file object can choose the "read" and "write"
    subdevices independently.
    
    The new `struct comedi_file` is created on "open" and freed on
    "release".  It includes pointers to the main Comedi device structure,
    and to the current "read" and "write" subdevice structures (which may be
    NULL).  It also has information to keep track of when a low-level device
    has been attached or detached since the previous time the file object
    was used.  In that case, the current "read" and "write" subdevices in
    the `struct comedi_file` will be changed to the new defaults (or set to
    NULL).  (The change to new defaults is done by `comedi_file_reset()`.
    The checking for attach/detach is done by `comedi_file_check()` which
    will call `comedi_file_reset()` if there have been any attach/detach
    operations since the previous call.)
    
    A subsequent patch will add the ioctls to change the current "read" and
    "write" subdevices.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 65894fd8b67b..79b852c6d868 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -43,6 +43,22 @@
 
 #include "comedi_internal.h"
 
+/**
+ * struct comedi_file - per-file private data for comedi device
+ * @dev: comedi_device struct
+ * @read_subdev: current "read" subdevice
+ * @write_subdev: current "write" subdevice
+ * @last_detach_count: last known detach count
+ * @last_attached: last known attached/detached state
+ */
+struct comedi_file {
+	struct comedi_device *dev;
+	struct comedi_subdevice *read_subdev;
+	struct comedi_subdevice *write_subdev;
+	unsigned int last_detach_count;
+	bool last_attached:1;
+};
+
 #define COMEDI_NUM_MINORS 0x100
 #define COMEDI_NUM_SUBDEVICE_MINORS	\
 	(COMEDI_NUM_MINORS - COMEDI_NUM_BOARD_MINORS)
@@ -239,6 +255,54 @@ comedi_write_subdevice(const struct comedi_device *dev, unsigned int minor)
 	return dev->write_subdev;
 }
 
+static void comedi_file_reset(struct file *file)
+{
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
+	struct comedi_subdevice *s, *read_s, *write_s;
+	unsigned int minor = iminor(file_inode(file));
+
+	read_s = dev->read_subdev;
+	write_s = dev->write_subdev;
+	if (minor >= COMEDI_NUM_BOARD_MINORS) {
+		s = comedi_subdevice_from_minor(dev, minor);
+		if (s == NULL || s->subdev_flags & SDF_CMD_READ)
+			read_s = s;
+		if (s == NULL || s->subdev_flags & SDF_CMD_WRITE)
+			write_s = s;
+	}
+	cfp->last_attached = dev->attached;
+	cfp->last_detach_count = dev->detach_count;
+	ACCESS_ONCE(cfp->read_subdev) = read_s;
+	ACCESS_ONCE(cfp->write_subdev) = write_s;
+}
+
+static void comedi_file_check(struct file *file)
+{
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
+
+	if (cfp->last_attached != dev->attached ||
+	    cfp->last_detach_count != dev->detach_count)
+		comedi_file_reset(file);
+}
+
+static struct comedi_subdevice *comedi_file_read_subdevice(struct file *file)
+{
+	struct comedi_file *cfp = file->private_data;
+
+	comedi_file_check(file);
+	return ACCESS_ONCE(cfp->read_subdev);
+}
+
+static struct comedi_subdevice *comedi_file_write_subdevice(struct file *file)
+{
+	struct comedi_file *cfp = file->private_data;
+
+	comedi_file_check(file);
+	return ACCESS_ONCE(cfp->write_subdev);
+}
+
 static int resize_async_buffer(struct comedi_device *dev,
 			       struct comedi_subdevice *s, unsigned new_size)
 {
@@ -776,7 +840,6 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 			    struct comedi_devinfo __user *arg,
 			    struct file *file)
 {
-	const unsigned minor = iminor(file_inode(file));
 	struct comedi_subdevice *s;
 	struct comedi_devinfo devinfo;
 
@@ -788,13 +851,13 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 	strlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
 	strlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
 
-	s = comedi_read_subdevice(dev, minor);
+	s = comedi_file_read_subdevice(file);
 	if (s)
 		devinfo.read_subdevice = s->index;
 	else
 		devinfo.read_subdevice = -1;
 
-	s = comedi_write_subdevice(dev, minor);
+	s = comedi_file_write_subdevice(file);
 	if (s)
 		devinfo.write_subdevice = s->index;
 	else
@@ -1787,8 +1850,9 @@ static int do_poll_ioctl(struct comedi_device *dev, unsigned long arg,
 static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 				  unsigned long arg)
 {
-	const unsigned minor = iminor(file_inode(file));
-	struct comedi_device *dev = file->private_data;
+	unsigned minor = iminor(file_inode(file));
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
 	int rc;
 
 	mutex_lock(&dev->mutex);
@@ -1910,8 +1974,8 @@ static struct vm_operations_struct comedi_vm_ops = {
 
 static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	const unsigned minor = iminor(file_inode(file));
-	struct comedi_device *dev = file->private_data;
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 	struct comedi_buf_map *bm = NULL;
@@ -1937,9 +2001,9 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	}
 
 	if (vma->vm_flags & VM_WRITE)
-		s = comedi_write_subdevice(dev, minor);
+		s = comedi_file_write_subdevice(file);
 	else
-		s = comedi_read_subdevice(dev, minor);
+		s = comedi_file_read_subdevice(file);
 	if (!s) {
 		retval = -EINVAL;
 		goto done;
@@ -2002,8 +2066,8 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 static unsigned int comedi_poll(struct file *file, poll_table *wait)
 {
 	unsigned int mask = 0;
-	const unsigned minor = iminor(file_inode(file));
-	struct comedi_device *dev = file->private_data;
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
 	struct comedi_subdevice *s;
 
 	mutex_lock(&dev->mutex);
@@ -2013,7 +2077,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 		goto done;
 	}
 
-	s = comedi_read_subdevice(dev, minor);
+	s = comedi_file_read_subdevice(file);
 	if (s && s->async) {
 		poll_wait(file, &s->async->wait_head, wait);
 		if (!s->busy || !comedi_is_subdevice_running(s) ||
@@ -2022,7 +2086,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 			mask |= POLLIN | POLLRDNORM;
 	}
 
-	s = comedi_write_subdevice(dev, minor);
+	s = comedi_file_write_subdevice(file);
 	if (s && s->async) {
 		unsigned int bps = comedi_bytes_per_sample(s);
 
@@ -2046,8 +2110,8 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	struct comedi_async *async;
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
-	const unsigned minor = iminor(file_inode(file));
-	struct comedi_device *dev = file->private_data;
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
 	bool on_wait_queue = false;
 	bool attach_locked;
 	unsigned int old_detach_count;
@@ -2063,7 +2127,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 		goto out;
 	}
 
-	s = comedi_write_subdevice(dev, minor);
+	s = comedi_file_write_subdevice(file);
 	if (!s || !s->async) {
 		retval = -EIO;
 		goto out;
@@ -2115,7 +2179,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 				 * meantime!), but check the subdevice pointer
 				 * as well just in case.
 				 */
-				new_s = comedi_write_subdevice(dev, minor);
+				new_s = comedi_file_write_subdevice(file);
 				if (dev->attached &&
 				    old_detach_count == dev->detach_count &&
 				    s == new_s && new_s->async == async)
@@ -2190,8 +2254,8 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	struct comedi_async *async;
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
-	const unsigned minor = iminor(file_inode(file));
-	struct comedi_device *dev = file->private_data;
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
 	unsigned int old_detach_count;
 	bool become_nonbusy = false;
 	bool attach_locked;
@@ -2207,7 +2271,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		goto out;
 	}
 
-	s = comedi_read_subdevice(dev, minor);
+	s = comedi_file_read_subdevice(file);
 	if (!s || !s->async) {
 		retval = -EIO;
 		goto out;
@@ -2304,7 +2368,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		 * meantime!), but check the subdevice pointer as well just in
 		 * case.
 		 */
-		new_s = comedi_read_subdevice(dev, minor);
+		new_s = comedi_file_read_subdevice(file);
 		if (dev->attached && old_detach_count == dev->detach_count &&
 		    s == new_s && new_s->async == async) {
 			if (become_nonbusy || comedi_buf_n_bytes_ready(s) == 0)
@@ -2322,6 +2386,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 static int comedi_open(struct inode *inode, struct file *file)
 {
 	const unsigned minor = iminor(inode);
+	struct comedi_file *cfp;
 	struct comedi_device *dev = comedi_dev_get_from_minor(minor);
 	int rc;
 
@@ -2330,6 +2395,12 @@ static int comedi_open(struct inode *inode, struct file *file)
 		return -ENODEV;
 	}
 
+	cfp = kzalloc(sizeof(*cfp), GFP_KERNEL);
+	if (!cfp)
+		return -ENOMEM;
+
+	cfp->dev = dev;
+
 	mutex_lock(&dev->mutex);
 	if (!dev->attached && !capable(CAP_NET_ADMIN)) {
 		dev_dbg(dev->class_dev, "not attached and not CAP_NET_ADMIN\n");
@@ -2351,26 +2422,31 @@ static int comedi_open(struct inode *inode, struct file *file)
 	}
 
 	dev->use_count++;
-	file->private_data = dev;
+	file->private_data = cfp;
+	comedi_file_reset(file);
 	rc = 0;
 
 out:
 	mutex_unlock(&dev->mutex);
-	if (rc)
+	if (rc) {
 		comedi_dev_put(dev);
+		kfree(cfp);
+	}
 	return rc;
 }
 
 static int comedi_fasync(int fd, struct file *file, int on)
 {
-	struct comedi_device *dev = file->private_data;
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
 
 	return fasync_helper(fd, file, on, &dev->async_queue);
 }
 
 static int comedi_close(struct inode *inode, struct file *file)
 {
-	struct comedi_device *dev = file->private_data;
+	struct comedi_file *cfp = file->private_data;
+	struct comedi_device *dev = cfp->dev;
 	struct comedi_subdevice *s = NULL;
 	int i;
 
@@ -2396,6 +2472,7 @@ static int comedi_close(struct inode *inode, struct file *file)
 
 	mutex_unlock(&dev->mutex);
 	comedi_dev_put(dev);
+	kfree(cfp);
 
 	return 0;
 }

commit c39e050d21d107d26183be0f22b89eccccdbe61c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:28 2014 -0700

    staging: comedi: remove use of 'bytes_per_sample()'
    
    This inline helper function has been replaced with comedi_bytes_per_sample().
    The same commit (bf33eb4b4f57) introduced a couple other related helper
    functions a manipulate the sample size.
    
    Use the new helper functions to remove the use of 'bytes_per_sample()' and
    remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 704ae25c5710..65894fd8b67b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2024,7 +2024,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 
 	s = comedi_write_subdevice(dev, minor);
 	if (s && s->async) {
-		unsigned int bps = bytes_per_sample(s);
+		unsigned int bps = comedi_bytes_per_sample(s);
 
 		poll_wait(file, &s->async->wait_head, wait);
 		comedi_buf_write_alloc(s, s->async->prealloc_bufsz);

commit 75f6108fa91bb80e9f7e8ead81f0cedf171d00a2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Oct 30 12:42:32 2014 +0000

    staging: comedi: check actual data direction for COMEDI_BUFINFO ioctl
    
    `do_bufinfo_ioctl()` handled the `COMEDI_BUFINFO` ioctl.  It is supposed
    to update the read or write positions in the buffer depending on the
    direction of data transfer set up by the asynchronous command.
    Currently it checks the `SDF_CMD_READ` and `SDF_CMD_WRITE` subdevice
    flags.  That's fine for most subdevices - the ones that only support one
    direction, but is incorrect for those subdevices that allow the command
    to be set up in either direction.  Since we now set the `CMDF_WRITE`
    flag according to the data transfer direction of the current command
    running on the subdevice, check that flag instead.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 63afd78441f1..704ae25c5710 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -991,7 +991,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	if (s->busy != file)
 		return -EACCES;
 
-	if (bi.bytes_read && (s->subdev_flags & SDF_CMD_READ)) {
+	if (bi.bytes_read && !(async->cmd.flags & CMDF_WRITE)) {
 		bi.bytes_read = comedi_buf_read_alloc(s, bi.bytes_read);
 		comedi_buf_read_free(s, bi.bytes_read);
 
@@ -1001,7 +1001,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		}
 	}
 
-	if (bi.bytes_written && (s->subdev_flags & SDF_CMD_WRITE)) {
+	if (bi.bytes_written && (async->cmd.flags & CMDF_WRITE)) {
 		bi.bytes_written =
 		    comedi_buf_write_alloc(s, bi.bytes_written);
 		comedi_buf_write_free(s, bi.bytes_written);

commit 662c722b645b22782eecdddf324c3a64d303baf3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Oct 30 12:42:31 2014 +0000

    staging: comedi: check command direction in poll() file operation
    
    `comedi_poll()` handles the poll() file operation for comedi devices.
    
    If no asynchronous command has been set up on the current "read"
    subdevice, it sets the `POLLIN` and `POLLRDNORM` bits in the return
    value to indicate that the read() file operation would not block as it
    would return an error.  Add a check so it also does that if the
    asynchronous command has been set up in the "write" direction as that
    also causes the read() file operation to return an error.
    
    Similarly, if no asynchronous command has need set up on the current
    "write" subdevice, it sets the `POLLOUT` and `POLLWRNORM` bits in the
    return value to indicate that the write() file operation would not block
    as it would return an error.  Add a check so it also does that if the
    asynchronous command has been set up in the "read" direction as that
    also causes the write() file operation to return an error.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 0ed6f1f00e7f..63afd78441f1 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2017,6 +2017,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	if (s && s->async) {
 		poll_wait(file, &s->async->wait_head, wait);
 		if (!s->busy || !comedi_is_subdevice_running(s) ||
+		    (s->async->cmd.flags & CMDF_WRITE) ||
 		    comedi_buf_read_n_available(s) > 0)
 			mask |= POLLIN | POLLRDNORM;
 	}
@@ -2028,6 +2029,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 		poll_wait(file, &s->async->wait_head, wait);
 		comedi_buf_write_alloc(s, s->async->prealloc_bufsz);
 		if (!s->busy || !comedi_is_subdevice_running(s) ||
+		    !(s->async->cmd.flags & CMDF_WRITE) ||
 		    comedi_buf_write_n_allocated(s) >= bps)
 			mask |= POLLOUT | POLLWRNORM;
 	}

commit f739850941bc300ed4dc18e22d42cbb670bf69b6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Oct 30 12:42:30 2014 +0000

    staging: comedi: don't allow write() on async command set up for "read"
    
    If a Comedi asynchronous command has been set up for data transfer in
    the "read" direction on the current "write" subdevice (for those
    subdevices that support both directions), don't allow the "write" file
    operation as that would mess with the data in the comedi data buffer
    that is written by the low-level comedi hardware driver.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 452121b6a604..0ed6f1f00e7f 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2075,6 +2075,10 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 		retval = -EACCES;
 		goto out;
 	}
+	if (!(async->cmd.flags & CMDF_WRITE)) {
+		retval = -EINVAL;
+		goto out;
+	}
 
 	add_wait_queue(&async->wait_head, &wait);
 	on_wait_queue = true;
@@ -2146,6 +2150,10 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 				retval = -EACCES;
 				break;
 			}
+			if (!(async->cmd.flags & CMDF_WRITE)) {
+				retval = -EINVAL;
+				break;
+			}
 			continue;
 		}
 

commit f025ab9eb73e46f761f469a2bb7c26a159b3e6c9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Oct 30 12:42:29 2014 +0000

    staging: comedi: don't allow read() on async command set up for "write"
    
    If a Comedi asynchronous command has been set up for data transfer in
    the "write" direction on the current "read" subdevice (for those
    subdevices that support both directions), don't allow the "read" file
    operation as that would mess with the data in the comedi data buffer
    that is read by the low-level comedi hardware driver.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b489d9481a69..452121b6a604 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2210,6 +2210,10 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		retval = -EACCES;
 		goto out;
 	}
+	if (async->cmd.flags & CMDF_WRITE) {
+		retval = -EINVAL;
+		goto out;
+	}
 
 	add_wait_queue(&async->wait_head, &wait);
 	while (nbytes > 0 && !retval) {
@@ -2249,6 +2253,10 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 				retval = -EACCES;
 				break;
 			}
+			if (async->cmd.flags & CMDF_WRITE) {
+				retval = -EINVAL;
+				break;
+			}
 			continue;
 		}
 		m = copy_to_user(buf, async->prealloc_buf +

commit 5d070cf25c4ecefaaa845ee7c1c3719c90f1c370
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Oct 30 12:42:26 2014 +0000

    staging: comedi: maybe force CMDF_WRITE command flag
    
    Most comedi subdevices that support asynchronous commands only support
    data transfer in either the "read" or "write" direction, as indicated by
    the `SDF_CMD_READ` and `SDF_CMD_WRITE` subdevice flags, although a few
    support both directions on the same subdevice (though not
    simultaneously).  The `struct comedi_cmd` structure passed via ioctl
    call to set up the command contains a `CMDF_WRITE` flag that can be used
    to choose the direction if the subdevice supports both directions, but
    the flag is optional if the subdevice only supports data transfer in one
    direction.
    
    If the subdevice only supports asynchronous data transfer in a sing
    direction, set the `CMDF_WRITE` flag to the correct state so that Comedi
    can make use of it later.  In the case of the `COMEDI_CMDTEST` ioctl,
    the updated flag will be written back to the `struct comedi_cmd` in
    user-space.  In the case of the `COMEDI_CMD` ioctl, the flag only gets
    written back if an error is detected while testing the command, or if
    the `CMDF_BOGUS` command flag is set.  Since `__comedi_get_user_cmd()`
    is called for both ioctls, that's a good place to set the flag.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c1fe9e0e46d1..b489d9481a69 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1451,6 +1451,21 @@ static int __comedi_get_user_cmd(struct comedi_device *dev,
 		return -EINVAL;
 	}
 
+	/*
+	 * Set the CMDF_WRITE flag to the correct state if the subdevice
+	 * supports only "read" commands or only "write" commands.
+	 */
+	switch (s->subdev_flags & (SDF_CMD_READ | SDF_CMD_WRITE)) {
+	case SDF_CMD_READ:
+		cmd->flags &= ~CMDF_WRITE;
+		break;
+	case SDF_CMD_WRITE:
+		cmd->flags |= CMDF_WRITE;
+		break;
+	default:
+		break;
+	}
+
 	return 0;
 }
 

commit 7cbe010a5ea728d7c4440b11a1a3997faca0e46d
Merge: 9056be30542b 0df1f2487d2f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Nov 2 18:06:03 2014 -0800

    Merge 3.18-rc3 into staging-next
    
    We want the upstream fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 238b5ad855924919e5b98d0c772d9dc78795639b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 20 15:10:40 2014 +0100

    staging: comedi: fix memory leak / bad pointer freeing for chanlist
    
    As a follow-up to commit 6cab7a37f5c04 ("staging: comedi: (regression)
    channel list must be set for COMEDI_CMD ioctl"), Hartley Sweeten pointed
    out another couple of bugs stemming from commit 6cab7a37f5c04 ("staging:
    comedi: comedi_fops: introduce __comedi_get_user_chanlist()").
    
    Firstly, `do_cmdtest_ioctl()` never frees the kernel copy of the user
    chanlist allocated by `__comedi_get_user_chanlist()`, so that memory is
    leaked.  Fix it by freeing the allocated kernel memory pointed to by
    `cmd.chanlist` before that pointer is overwritten with its original
    pointer to user memory before `cmd` is copied back to user-space.
    
    Secondly, if `__comedi_get_user_chanlist()` returns an error,
    `cmd->chanlist` is left unchanged and in fact will be a pointer to user
    memory.  This causes `do_cmd_ioctl()` to `goto cleanup` and call
    `do_become_nonbusy()` which would attempt to free the memory pointed to
    by the user-space pointer.  Fix it by setting `cmd->chanlist` to NULL at
    the start of `__comedi_get_user_chanlist()`.
    
    Fixes: c6cd0eefb27b ("staging: comedi: comedi_fops: introduce __comedi_get_user_chanlist()")
    Reported-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: <stable@vger.kernel.org> # 3.15.y 3.16.y 3.17.y: 6cab7a37f5c04
    Cc: <stable@vger.kernel.org> # 3.15.y 3.16.y 3.17.y
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f9f61bda92e2..9c32f0276009 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1462,6 +1462,7 @@ static int __comedi_get_user_chanlist(struct comedi_device *dev,
 	unsigned int *chanlist;
 	int ret;
 
+	cmd->chanlist = NULL;
 	chanlist = memdup_user(user_chanlist,
 			       cmd->chanlist_len * sizeof(unsigned int));
 	if (IS_ERR(chanlist))
@@ -1615,6 +1616,8 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 
 	ret = s->do_cmdtest(dev, s, &cmd);
 
+	kfree(cmd.chanlist);	/* free kernel copy of user chanlist */
+
 	/* restore chanlist pointer before copying back */
 	cmd.chanlist = (unsigned int __force *)user_chanlist;
 

commit c1a6eac1694b1236115ee6e93a4efbf02d05fea3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 28 17:15:47 2014 +0000

    staging: comedi: widen subdevice number argument in ioctl handlers
    
    For the `COMEDI_LOCK`, `COMEDI_UNLOCK`, `COMEDI_CANCEL`, and
    `COMEDI_POLL` ioctls the third argument is a comedi subdevice number.
    This is passed as an `unsigned long`, but when it is passed down to the
    ioctl command-specific handler functions `do_lock_ioctl()`,
    `do_unlock_ioctl()`, `do_cancel_ioctl()`, and `do_poll_ioctl()`, the
    value has been narrowed to an `unsigned int`.  Pass through the argument
    as an `unsigned long` to avoid truncating the value on 64-bit
    architectures.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a9b7fe52d380..f9f61bda92e2 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1641,7 +1641,7 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 
 */
 
-static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,
+static int do_lock_ioctl(struct comedi_device *dev, unsigned long arg,
 			 void *file)
 {
 	int ret = 0;
@@ -1678,7 +1678,7 @@ static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,
 	This function isn't protected by the semaphore, since
 	we already own the lock.
 */
-static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg,
+static int do_unlock_ioctl(struct comedi_device *dev, unsigned long arg,
 			   void *file)
 {
 	struct comedi_subdevice *s;
@@ -1713,7 +1713,7 @@ static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg,
 		nothing
 
 */
-static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
+static int do_cancel_ioctl(struct comedi_device *dev, unsigned long arg,
 			   void *file)
 {
 	struct comedi_subdevice *s;
@@ -1750,7 +1750,7 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
 		nothing
 
 */
-static int do_poll_ioctl(struct comedi_device *dev, unsigned int arg,
+static int do_poll_ioctl(struct comedi_device *dev, unsigned long arg,
 			 void *file)
 {
 	struct comedi_subdevice *s;

commit 781f933c151ee47e3cc1c8ef5491db23f1b61c9a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 13 09:56:08 2014 -0700

    staging: comedi: comedidev.h: clarify async->event error/cancel detection
    
    Introduce COMEDI_CB_ERROR_MASK and COMEDI_CB_CANCEL_MASK to clarify the
    async->events that indicate errors and cancel an async command.
    
    Use the new defines to tidy up and clarify the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 224af2b2a685..2fb0f874f71f 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1555,9 +1555,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 
 	comedi_buf_reset(s);
 
-	async->cb_mask =
-	    COMEDI_CB_EOA | COMEDI_CB_BLOCK | COMEDI_CB_ERROR |
-	    COMEDI_CB_OVERFLOW;
+	async->cb_mask = COMEDI_CB_BLOCK | COMEDI_CB_CANCEL_MASK;
 	if (async->cmd.flags & CMDF_WAKE_EOS)
 		async->cb_mask |= COMEDI_CB_EOS;
 
@@ -2390,14 +2388,14 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (!comedi_is_subdevice_running(s))
 		return;
 
-	if (s->
-	    async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
-			     COMEDI_CB_OVERFLOW)) {
+	if (s->async->events & COMEDI_CB_CANCEL_MASK)
 		runflags_mask |= SRF_RUNNING;
-	}
-	/* remember if an error event has occurred, so an error
-	 * can be returned the next time the user does a read() */
-	if (s->async->events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {
+
+	/*
+	 * Remember if an error event has occurred, so an error
+	 * can be returned the next time the user does a read().
+	 */
+	if (s->async->events & COMEDI_CB_ERROR_MASK) {
 		runflags_mask |= SRF_ERROR;
 		runflags |= SRF_ERROR;
 	}

commit 6cab7a37f5c048bb2a768f24b0ec748b052fda09
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 8 16:09:14 2014 +0100

    staging: comedi: (regression) channel list must be set for COMEDI_CMD ioctl
    
    `do_cmd_ioctl()`, the handler for the `COMEDI_CMD` ioctl can incorrectly
    call the Comedi subdevice's `do_cmd()` handler with a NULL channel list
    pointer.  This is a regression as the `do_cmd()` handler has never been
    expected to deal with that, leading to a kernel OOPS when it tries to
    dereference it.
    
    A NULL channel list pointer is allowed for the `COMEDI_CMDTEST` ioctl,
    handled by `do_cmdtest_ioctl()` and the subdevice's `do_cmdtest()`
    handler, but not for the `COMEDI_CMD` ioctl and its handlers.
    
    Both `do_cmd_ioctl()` and `do_cmdtest_ioctl()` call
    `__comedi_get_user_chanlist()` to copy the channel list from user memory
    into dynamically allocated kernel memory and check it for consistency.
    That function currently returns 0 if the `user_chanlist` parameter
    (pointing to the channel list in user memory) is NULL.  That's fine for
    `do_cmdtest_ioctl()`, but `do_cmd_ioctl()` incorrectly assumes the
    kernel copy of the channel list has been set-up correctly.
    
    Fix it by not allowing the `user_chanlist` parameter to be NULL in
    `__comedi_get_user_chanlist()`, and only calling it from
    `do_cmdtest_ioctl()` if the parameter is non-NULL.
    
    Thanks to Bernd Porr for reporting the bug via an initial patch sent
    privately.
    
    Fixes: c6cd0eefb27b ("staging: comedi: comedi_fops: introduce __comedi_get_user_chanlist()")
    Reported-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Bernd Porr <mail@berndporr.me.uk>
    Cc: <stable@vger.kernel.org> # 3.15.y 3.16.y 3.17.y
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 495969f46e76..a9b7fe52d380 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1462,10 +1462,6 @@ static int __comedi_get_user_chanlist(struct comedi_device *dev,
 	unsigned int *chanlist;
 	int ret;
 
-	/* user_chanlist could be NULL for do_cmdtest ioctls */
-	if (!user_chanlist)
-		return 0;
-
 	chanlist = memdup_user(user_chanlist,
 			       cmd->chanlist_len * sizeof(unsigned int));
 	if (IS_ERR(chanlist))
@@ -1609,10 +1605,13 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 
 	s = &dev->subdevices[cmd.subdev];
 
-	/* load channel/gain list */
-	ret = __comedi_get_user_chanlist(dev, s, user_chanlist, &cmd);
-	if (ret)
-		return ret;
+	/* user_chanlist can be NULL for COMEDI_CMDTEST ioctl */
+	if (user_chanlist) {
+		/* load channel/gain list */
+		ret = __comedi_get_user_chanlist(dev, s, user_chanlist, &cmd);
+		if (ret)
+			return ret;
+	}
 
 	ret = s->do_cmdtest(dev, s, &cmd);
 

commit fe43ec5350d34244dedf3e6647f991f7c348c82d
Author: Heena Sirwani <heenasirwani@gmail.com>
Date:   Mon Oct 6 13:46:09 2014 +0530

    Staging: comedi: Compressed two lines of code into one.
    
    The following patch compressed two lines of code into one using
    coccinelle and removed an unused variable.
    The semantic patch used is as follows:
    
    @@
    expression ret;
    identifier f;
    @@
    
    -ret =
    +return
         f(...);
    -return ret;
    
    Signed-off-by: Heena Sirwani <heenasirwani@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 495969f46e76..224af2b2a685 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1718,7 +1718,6 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
 			   void *file)
 {
 	struct comedi_subdevice *s;
-	int ret;
 
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
@@ -1732,9 +1731,7 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
 	if (s->busy != file)
 		return -EBUSY;
 
-	ret = do_cancel(dev, s);
-
-	return ret;
+	return do_cancel(dev, s);
 }
 
 /*

commit b0446a21bd4be9c5f27f15ea03fc0cba7d33acd6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:44 2014 +0100

    staging: comedi: use CMDF_BOGUS in do_cmd_ioctl()
    
    `TRIG_BOGUS` is now just a synonym for `CMDF_BOGUS`.  Change
    `do_cmd_ioctl()` to use the new name.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 9d60a39ac961..495969f46e76 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1532,7 +1532,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 
 	ret = s->do_cmdtest(dev, s, &async->cmd);
 
-	if (async->cmd.flags & TRIG_BOGUS || ret) {
+	if (async->cmd.flags & CMDF_BOGUS || ret) {
 		dev_dbg(dev->class_dev, "test returned %d\n", ret);
 		cmd = async->cmd;
 		/* restore chanlist pointer before copying back */

commit d8bff6e35e87ca5d8cd348d2563b34afb4faf28b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:30 2014 +0100

    staging: comedi: use CMDF_WAKE_EOS in do_cmd_ioctl()
    
    `TRIG_WAKE_EOS` is now just a synonym for `CMDF_WAKE_EOS`.  Change
    `do_cmd_ioctl()` to use the new name.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 2182c7463cdb..9d60a39ac961 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1558,7 +1558,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	async->cb_mask =
 	    COMEDI_CB_EOA | COMEDI_CB_BLOCK | COMEDI_CB_ERROR |
 	    COMEDI_CB_OVERFLOW;
-	if (async->cmd.flags & TRIG_WAKE_EOS)
+	if (async->cmd.flags & CMDF_WAKE_EOS)
 		async->cb_mask |= COMEDI_CB_EOS;
 
 	comedi_set_subdevice_runflags(s, SRF_ERROR | SRF_RUNNING, SRF_RUNNING);

commit d546b8966e66b114809d4af14e2d837adeeec2fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 21 11:48:32 2014 -0700

    staging: comedi: comedidev.h: remove 'new_size' param from subdevice (*buf_change)
    
    This parameter is never used by any of the comedi drivers that provide a
    (*buf_change) callback. If the 'new_size' is needed in the callback it can
    be found from the 's->async->prealloc_bufsz' as done in the ni_pcidio driver.
    
    Remove the unused parameter.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 84a1e429f24c..2182c7463cdb 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -268,7 +268,7 @@ static int resize_async_buffer(struct comedi_device *dev,
 		return retval;
 
 	if (s->buf_change) {
-		retval = s->buf_change(dev, s, new_size);
+		retval = s->buf_change(dev, s);
 		if (retval < 0)
 			return retval;
 	}

commit 90ac0764e01f310588e578d26f554cb0008b5091
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 21 11:01:26 2014 -0700

    staging: comedi: comedi_fops: remove disabled subdevice lock/unlock callback
    
    According to Ian Abbott, this code was added in comedi-0.7.6 back in June 1999
    and has always been disabled.
    
    The 'lock_f' and 'unlock' members don't even exist in the comedi_subdevice.
    Just remove the disabled code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 01fb31d7f3cd..84a1e429f24c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1660,14 +1660,6 @@ static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,
 		s->lock = file;
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 
-#if 0
-	if (ret < 0)
-		return ret;
-
-	if (s->lock_f)
-		ret = s->lock_f(dev, s);
-#endif
-
 	return ret;
 }
 
@@ -1702,14 +1694,8 @@ static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg,
 	if (s->lock && s->lock != file)
 		return -EACCES;
 
-	if (s->lock == file) {
-#if 0
-		if (s->unlock)
-			s->unlock(dev, s);
-#endif
-
+	if (s->lock == file)
 		s->lock = NULL;
-	}
 
 	return 0;
 }

commit 36efbacdcb25427fda00d9af5c22a4f3a8867632
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 14:28:14 2014 -0700

    staging: comedi: comedi_fops: checkpatch.pl --strict cleanup
    
    Fix the checkpatch.pl --strict issues:
    
    CHECK: braces {} should be used on all arms of this statement
    CHECK: Alignment should match open parenthesis
    CHECK: Prefer kzalloc(sizeof(*dev)...) over kzalloc(sizeof(struct comedi_device)...)
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 175003125784..01fb31d7f3cd 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1227,10 +1227,9 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 				/* Most drivers ignore the base channel in
 				 * insn->chanspec.  Fix this here if
 				 * the subdevice has <= 32 channels.  */
-				unsigned int shift;
-				unsigned int orig_mask;
+				unsigned int orig_mask = data[0];
+				unsigned int shift = 0;
 
-				orig_mask = data[0];
 				if (s->n_chan <= 32) {
 					shift = CR_CHAN(insn->chanspec);
 					if (shift > 0) {
@@ -1238,8 +1237,7 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 						data[0] <<= shift;
 						data[1] <<= shift;
 					}
-				} else
-					shift = 0;
+				}
 				ret = s->insn_bits(dev, s, insn, data);
 				data[0] = orig_mask;
 				if (shift > 0)
@@ -2178,7 +2176,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 }
 
 static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
-				loff_t *offset)
+			   loff_t *offset)
 {
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
@@ -2443,7 +2441,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	struct device *csdev;
 	unsigned i;
 
-	dev = kzalloc(sizeof(struct comedi_device), GFP_KERNEL);
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (dev == NULL)
 		return ERR_PTR(-ENOMEM);
 	comedi_device_init(dev);

commit 5ee226306cdc46c68bbbacdbb76120e18a5ae239
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 13:29:58 2014 -0700

    staging: comedi: comedi_fops: remove commented out debug messages
    
    Remove the commented out printk() debug.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 9670b244fc69..175003125784 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2222,10 +2222,8 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		n = nbytes;
 
 		m = comedi_buf_read_n_available(s);
-		/* printk("%d available\n",m); */
 		if (async->buf_read_ptr + m > async->prealloc_bufsz)
 			m = async->prealloc_bufsz - async->buf_read_ptr;
-		/* printk("%d contiguous\n",m); */
 		if (m < n)
 			n = m;
 

commit c2ad078b504c85e83fb9a223136f29349888fe7a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 12:27:32 2014 -0700

    staging: comedi: comedi_fops: use pr_fmt()
    
    There are a number of pr_{level} messages in this file that are used
    to print kernel messages when the device pointer is not available for
    a dev_{level} message.
    
    Use pr_fmt() to ensure all of these messages have the module prefix.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 630ef1fbb360..9670b244fc69 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -16,6 +16,8 @@
     GNU General Public License for more details.
 */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include "comedi_compat32.h"
 
 #include <linux/module.h>
@@ -1073,11 +1075,10 @@ static int check_insn_config_length(struct comedi_insn *insn,
 		/* by default we allow the insn since we don't have checks for
 		 * all possible cases yet */
 	default:
-		pr_warn("comedi: No check for data length of config insn id %i is implemented.\n",
+		pr_warn("No check for data length of config insn id %i is implemented\n",
 			data[0]);
-		pr_warn("comedi: Add a check to %s in %s.\n",
-			__func__, __FILE__);
-		pr_warn("comedi: Assuming n=%i is correct.\n", insn->n);
+		pr_warn("Add a check to %s in %s\n", __func__, __FILE__);
+		pr_warn("Assuming n=%i is correct\n", insn->n);
 		return 0;
 	}
 	return -EINVAL;
@@ -2463,7 +2464,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 		mutex_unlock(&dev->mutex);
 		comedi_device_cleanup(dev);
 		comedi_dev_put(dev);
-		pr_err("comedi: error: ran out of minor numbers for board device files.\n");
+		pr_err("ran out of minor numbers for board device files\n");
 		return ERR_PTR(-EBUSY);
 	}
 	dev->minor = i;
@@ -2516,7 +2517,7 @@ int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 	}
 	mutex_unlock(&comedi_subdevice_minor_table_lock);
 	if (i == COMEDI_NUM_SUBDEVICE_MINORS) {
-		pr_err("comedi: error: ran out of minor numbers for subdevice files.\n");
+		pr_err("ran out of minor numbers for subdevice files\n");
 		return -EBUSY;
 	}
 	i += COMEDI_NUM_BOARD_MINORS;
@@ -2566,11 +2567,11 @@ static int __init comedi_init(void)
 	int i;
 	int retval;
 
-	pr_info("comedi: version " COMEDI_RELEASE " - http://www.comedi.org\n");
+	pr_info("version " COMEDI_RELEASE " - http://www.comedi.org\n");
 
 	if (comedi_num_legacy_minors < 0 ||
 	    comedi_num_legacy_minors > COMEDI_NUM_BOARD_MINORS) {
-		pr_err("comedi: error: invalid value for module parameter \"comedi_num_legacy_minors\".  Valid values are 0 through %i.\n",
+		pr_err("invalid value for module parameter \"comedi_num_legacy_minors\".  Valid values are 0 through %i.\n",
 		       COMEDI_NUM_BOARD_MINORS);
 		return -EINVAL;
 	}
@@ -2596,7 +2597,7 @@ static int __init comedi_init(void)
 	}
 	comedi_class = class_create(THIS_MODULE, "comedi");
 	if (IS_ERR(comedi_class)) {
-		pr_err("comedi: failed to create class\n");
+		pr_err("failed to create class\n");
 		cdev_del(&comedi_cdev);
 		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 					 COMEDI_NUM_MINORS);

commit 6b362f5bea0dfbb648656041a92f6a00b298f558
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:56 2014 -0700

    staging: comedi: remove comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character.
    
    All of the users of this function have been converted to use dev_err()
    directly. Remove the now unused function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 36862965051b..630ef1fbb360 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2401,12 +2401,6 @@ static const struct file_operations comedi_fops = {
 	.llseek = noop_llseek,
 };
 
-void comedi_error(const struct comedi_device *dev, const char *s)
-{
-	dev_err(dev->class_dev, "%s: %s\n", dev->driver->driver_name, s);
-}
-EXPORT_SYMBOL_GPL(comedi_error);
-
 void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;

commit cb3aadaec89109edb60d4829ce82e50b27cb4ce6
Author: Kinka Huang <kinkabrain@gmail.com>
Date:   Tue Jul 15 23:11:02 2014 +0800

    staging: comedi: removing not useful `else` after return
    
    Signed-off-by: Kinka Huang <kinkabrain@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 038b69a93185..36862965051b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -206,8 +206,8 @@ struct comedi_device *comedi_dev_get_from_minor(unsigned minor)
 {
 	if (minor < COMEDI_NUM_BOARD_MINORS)
 		return comedi_dev_get_from_board_minor(minor);
-	else
-		return comedi_dev_get_from_subdevice_minor(minor);
+
+	return comedi_dev_get_from_subdevice_minor(minor);
 }
 EXPORT_SYMBOL_GPL(comedi_dev_get_from_minor);
 
@@ -2625,10 +2625,9 @@ static int __init comedi_init(void)
 			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 						 COMEDI_NUM_MINORS);
 			return PTR_ERR(dev);
-		} else {
-			/* comedi_alloc_board_minor() locked the mutex */
-			mutex_unlock(&dev->mutex);
 		}
+		/* comedi_alloc_board_minor() locked the mutex */
+		mutex_unlock(&dev->mutex);
 	}
 
 	return 0;

commit a5bde3a163cc4701e693c7c1d9cb9d6c9b888c75
Author: Anton Protopopov <a.s.protopopov@gmail.com>
Date:   Wed Jul 9 09:12:37 2014 +0400

    Staging: comedi: check the return value of kobject_set_name
    
    Added a check of the return value of the kobject_set_name function.
    
    Signed-off-by: Anton Protopopov <a.s.protopopov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e8e38098dcf8..038b69a93185 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2587,7 +2587,14 @@ static int __init comedi_init(void)
 		return -EIO;
 	cdev_init(&comedi_cdev, &comedi_fops);
 	comedi_cdev.owner = THIS_MODULE;
-	kobject_set_name(&comedi_cdev.kobj, "comedi");
+
+	retval = kobject_set_name(&comedi_cdev.kobj, "comedi");
+	if (retval) {
+		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+					 COMEDI_NUM_MINORS);
+		return retval;
+	}
+
 	if (cdev_add(&comedi_cdev, MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS)) {
 		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 					 COMEDI_NUM_MINORS);

commit 0e02dcae1ce238a2afda25da8cfd829c540088bb
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jul 2 12:02:16 2014 +0100

    staging: comedi: allow COMEDI_BUFINFO, COMEDI_CANCEL and COMEDI_POLL on locked subdevice
    
    Comedi subdevices can be locked for mostly exclusive access by a
    particular file object by means of the COMEDI_LOCK ioctl.  Some
    operations disregard the lock.  For example, the read() and write() file
    operations are allowed for the file object that set up an asynchronous
    command on the subdevice (making it "busy") regardless of whether it is
    locked.
    
    The COMEDI_BUFINFO, COMEDI_CANCEL and COMEDI_POLL ioctls are also
    associated with the file object that made the subdevice "busy" with a
    command.  They currently obey the exclusive access lock on the subdevice
    as well, but it makes more sense for them to ignore it like the read()
    and write() file operations.  Remove the exclusive subdevice access
    checks for these ioctls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index d4904cc50f77..e8e38098dcf8 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -968,9 +968,6 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 
 	s = &dev->subdevices[bi.subdevice];
 
-	if (s->lock && s->lock != file)
-		return -EACCES;
-
 	async = s->async;
 
 	if (!async) {
@@ -1744,9 +1741,6 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
 	if (s->async == NULL)
 		return -EINVAL;
 
-	if (s->lock && s->lock != file)
-		return -EACCES;
-
 	if (!s->busy)
 		return 0;
 
@@ -1781,9 +1775,6 @@ static int do_poll_ioctl(struct comedi_device *dev, unsigned int arg,
 		return -EINVAL;
 	s = &dev->subdevices[arg];
 
-	if (s->lock && s->lock != file)
-		return -EACCES;
-
 	if (!s->busy)
 		return 0;
 

commit f4f3f7cf27e7ae015672b59ec40c7deabeaf5d2e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 10:58:28 2014 -0700

    staging: comedi: introduce comedi_buf_n_bytes_ready()
    
    Introduce an inline helper to return the number of bytes that are
    ready to read from the comedi_async buffer. Use the helper in the
    comedi drivers that currently do the calculation as part of the
    (*poll) operation.
    
    Also, use the helper in comedi_fops where the calculation is used as
    part of the subdevice going nonbusy.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c54ed42f8310..d4904cc50f77 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -997,7 +997,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		comedi_buf_read_free(s, bi.bytes_read);
 
 		if (comedi_is_subdevice_idle(s) &&
-		    async->buf_write_count == async->buf_read_count) {
+		    comedi_buf_n_bytes_ready(s) == 0) {
 			do_become_nonbusy(dev, s);
 		}
 	}
@@ -2303,8 +2303,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		new_s = comedi_read_subdevice(dev, minor);
 		if (dev->attached && old_detach_count == dev->detach_count &&
 		    s == new_s && new_s->async == async) {
-			if (become_nonbusy ||
-			    async->buf_read_count - async->buf_write_count == 0)
+			if (become_nonbusy || comedi_buf_n_bytes_ready(s) == 0)
 				do_become_nonbusy(dev, s);
 		}
 		mutex_unlock(&dev->mutex);

commit f4a8f5288929e11c0e393d14e59eee1cca2c8ae4
Author: Wolfgang Ocker <weo@weo1.de>
Date:   Mon Jun 2 22:48:06 2014 +0200

    staging: comedi: style - use kmalloc_array(n, s, ...) instead of kmalloc(n*s, ...)
    
    Fix a style issue reported by checkpatch.pl for the Eudyptula challenge
    
    Signed-off-by: Wolfgang Ocker <weo@weo1.de>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 9d99fb3c18a6..c54ed42f8310 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1295,7 +1295,7 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 	if (copy_from_user(&insnlist, arg, sizeof(insnlist)))
 		return -EFAULT;
 
-	data = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);
+	data = kmalloc_array(MAX_SAMPLES, sizeof(unsigned int), GFP_KERNEL);
 	if (!data) {
 		ret = -ENOMEM;
 		goto error;
@@ -1376,7 +1376,7 @@ static int do_insn_ioctl(struct comedi_device *dev,
 	unsigned int *data = NULL;
 	int ret = 0;
 
-	data = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);
+	data = kmalloc_array(MAX_SAMPLES, sizeof(unsigned int), GFP_KERNEL);
 	if (!data) {
 		ret = -ENOMEM;
 		goto error;

commit a5897f77607c52acb078b152b59fbe29ac92c640
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 27 15:06:17 2014 +0100

    staging: comedi: remove in_request_module
    
    The `in_request_module` member of `struct comedi_device` is only ever
    set to `false`, so remove the code that checks for it being `true` and
    remove the member.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 70ad00c501ef..9d99fb3c18a6 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2327,38 +2327,12 @@ static int comedi_open(struct inode *inode, struct file *file)
 		return -ENODEV;
 	}
 
-	/* This is slightly hacky, but we want module autoloading
-	 * to work for root.
-	 * case: user opens device, attached -> ok
-	 * case: user opens device, unattached, !in_request_module -> autoload
-	 * case: user opens device, unattached, in_request_module -> fail
-	 * case: root opens device, attached -> ok
-	 * case: root opens device, unattached, in_request_module -> ok
-	 *   (typically called from modprobe)
-	 * case: root opens device, unattached, !in_request_module -> autoload
-	 *
-	 * The last could be changed to "-> ok", which would deny root
-	 * autoloading.
-	 */
 	mutex_lock(&dev->mutex);
-	if (dev->attached)
-		goto ok;
-	if (!capable(CAP_NET_ADMIN) && dev->in_request_module) {
-		dev_dbg(dev->class_dev, "in request module\n");
-		rc = -ENODEV;
-		goto out;
-	}
-	if (capable(CAP_NET_ADMIN) && dev->in_request_module)
-		goto ok;
-
-	dev->in_request_module = false;
-
 	if (!dev->attached && !capable(CAP_NET_ADMIN)) {
 		dev_dbg(dev->class_dev, "not attached and not CAP_NET_ADMIN\n");
 		rc = -ENODEV;
 		goto out;
 	}
-ok:
 	if (dev->attached && dev->use_count == 0) {
 		if (!try_module_get(dev->driver->module)) {
 			rc = -ENOSYS;

commit f30f2c2d417b9de3d967016ade0bea2d93190624
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Mon May 26 21:09:10 2014 +0200

    staging: comedi: remove check for CONFIG_KMOD
    
    The comedi driver was added in v2.6.29. That's the same release that
    removed the Kconfig symbol KMOD. So the code behind a test for its
    macro has been hidden since it was in staging. Remove it.
    
    Remove a useless assignment to "dev->in_request_module" too. That
    variable seems pointless anyhow, but that's a different issue.
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 012c8fd1aabb..70ad00c501ef 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2351,14 +2351,6 @@ static int comedi_open(struct inode *inode, struct file *file)
 	if (capable(CAP_NET_ADMIN) && dev->in_request_module)
 		goto ok;
 
-	dev->in_request_module = true;
-
-#ifdef CONFIG_KMOD
-	mutex_unlock(&dev->mutex);
-	request_module("char-major-%i-%i", COMEDI_MAJOR, dev->minor);
-	mutex_lock(&dev->mutex);
-#endif
-
 	dev->in_request_module = false;
 
 	if (!dev->attached && !capable(CAP_NET_ADMIN)) {

commit d4526ab4e03bb16beee03547bfcbc1d8e09707f1
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:11 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_is_mmapped()
    
    Change the parameters of `comedi_buf_is_mmapped()` to pass a pointer to
    the comedi subdevice instead of a pointer to the "async" structure
    belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 98229bd6cfb2..012c8fd1aabb 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -251,7 +251,7 @@ static int resize_async_buffer(struct comedi_device *dev,
 			"subdevice is busy, cannot resize buffer\n");
 		return -EBUSY;
 	}
-	if (comedi_buf_is_mmapped(async)) {
+	if (comedi_buf_is_mmapped(s)) {
 		dev_dbg(dev->class_dev,
 			"subdevice is mmapped, cannot resize buffer\n");
 		return -EBUSY;
@@ -635,7 +635,7 @@ static int is_device_busy(struct comedi_device *dev)
 		s = &dev->subdevices[i];
 		if (s->busy)
 			return 1;
-		if (s->async && comedi_buf_is_mmapped(s->async))
+		if (s->async && comedi_buf_is_mmapped(s))
 			return 1;
 	}
 

commit fcc18a9aa2c43765ba37012879936fbf142ba91c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:10 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_reset()
    
    Change the parameters of `comedi_buf_reset()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ada6024be6ee..98229bd6cfb2 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -583,7 +583,7 @@ static void do_become_nonbusy(struct comedi_device *dev,
 
 	comedi_set_subdevice_runflags(s, SRF_RUNNING, 0);
 	if (async) {
-		comedi_buf_reset(async);
+		comedi_buf_reset(s);
 		async->inttrig = NULL;
 		kfree(async->cmd.chanlist);
 		async->cmd.chanlist = NULL;
@@ -1557,7 +1557,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 		goto cleanup;
 	}
 
-	comedi_buf_reset(async);
+	comedi_buf_reset(s);
 
 	async->cb_mask =
 	    COMEDI_CB_EOA | COMEDI_CB_BLOCK | COMEDI_CB_ERROR |

commit e9edef3a5454a19fd0d0c342cc88b6310b871a48
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:09 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_read_n_available()
    
    Change the parameters of `comedi_buf_read_n_available()` to pass a
    pointer to the comedi subdevice instead of a pointer to the "async"
    structure belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 365e191228be..ada6024be6ee 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2029,7 +2029,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	if (s && s->async) {
 		poll_wait(file, &s->async->wait_head, wait);
 		if (!s->busy || !comedi_is_subdevice_running(s) ||
-		    comedi_buf_read_n_available(s->async) > 0)
+		    comedi_buf_read_n_available(s) > 0)
 			mask |= POLLIN | POLLRDNORM;
 	}
 
@@ -2229,7 +2229,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 
 		n = nbytes;
 
-		m = comedi_buf_read_n_available(async);
+		m = comedi_buf_read_n_available(s);
 		/* printk("%d available\n",m); */
 		if (async->buf_read_ptr + m > async->prealloc_bufsz)
 			m = async->prealloc_bufsz - async->buf_read_ptr;

commit f1df8662859e7edee134d3d77f241a32c9cfb8ef
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:08 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_read_free()
    
    Change the parameters of `comedi_buf_read_free()` to pass a pointer to
    the comedi subdevice instead of a pointer to the "async" structure
    belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 5164374f5ab2..365e191228be 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -994,7 +994,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 
 	if (bi.bytes_read && (s->subdev_flags & SDF_CMD_READ)) {
 		bi.bytes_read = comedi_buf_read_alloc(s, bi.bytes_read);
-		comedi_buf_read_free(async, bi.bytes_read);
+		comedi_buf_read_free(s, bi.bytes_read);
 
 		if (comedi_is_subdevice_idle(s) &&
 		    async->buf_write_count == async->buf_read_count) {
@@ -2273,7 +2273,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		}
 
 		comedi_buf_read_alloc(s, n);
-		comedi_buf_read_free(async, n);
+		comedi_buf_read_free(s, n);
 
 		count += n;
 		nbytes -= n;

commit d13be55a37a136ee4274680308b7d0d7e3818bf3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:07 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_read_alloc()
    
    Change the parameters of `comedi_buf_read_alloc()` to pass a pointer to
    the comedi subdevice instead of a pointer to the "async" structure
    belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index bc9386350b76..5164374f5ab2 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -993,7 +993,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		return -EACCES;
 
 	if (bi.bytes_read && (s->subdev_flags & SDF_CMD_READ)) {
-		bi.bytes_read = comedi_buf_read_alloc(async, bi.bytes_read);
+		bi.bytes_read = comedi_buf_read_alloc(s, bi.bytes_read);
 		comedi_buf_read_free(async, bi.bytes_read);
 
 		if (comedi_is_subdevice_idle(s) &&
@@ -2272,7 +2272,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 			retval = -EFAULT;
 		}
 
-		comedi_buf_read_alloc(async, n);
+		comedi_buf_read_alloc(s, n);
 		comedi_buf_read_free(async, n);
 
 		count += n;

commit 0f1f34e844a24187270315ffb539d4bd1900c333
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:06 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_write_n_allocated()
    
    Change the parameters of `comedi_buf_write_n_allocated()` to pass a
    pointer to the comedi subdevice instead of a pointer to the "async"
    structure belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c7010b315701..bc9386350b76 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2040,7 +2040,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 		poll_wait(file, &s->async->wait_head, wait);
 		comedi_buf_write_alloc(s, s->async->prealloc_bufsz);
 		if (!s->busy || !comedi_is_subdevice_running(s) ||
-		    comedi_buf_write_n_allocated(s->async) >= bps)
+		    comedi_buf_write_n_allocated(s) >= bps)
 			mask |= POLLOUT | POLLWRNORM;
 	}
 
@@ -2137,8 +2137,8 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 		if (async->buf_write_ptr + m > async->prealloc_bufsz)
 			m = async->prealloc_bufsz - async->buf_write_ptr;
 		comedi_buf_write_alloc(s, async->prealloc_bufsz);
-		if (m > comedi_buf_write_n_allocated(async))
-			m = comedi_buf_write_n_allocated(async);
+		if (m > comedi_buf_write_n_allocated(s))
+			m = comedi_buf_write_n_allocated(s);
 		if (m < n)
 			n = m;
 

commit 940dd35d5812ead0b93f3f2a1f44732ac069000b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:05 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_write_free()
    
    Change the parameters of `comedi_buf_write_free()` to pass a pointer to
    the comedi subdevice instead of a pointer to the "async" structure
    belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 58c1f6e18d27..c7010b315701 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1005,7 +1005,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	if (bi.bytes_written && (s->subdev_flags & SDF_CMD_WRITE)) {
 		bi.bytes_written =
 		    comedi_buf_write_alloc(s, bi.bytes_written);
-		comedi_buf_write_free(async, bi.bytes_written);
+		comedi_buf_write_free(s, bi.bytes_written);
 	}
 
 copyback_position:
@@ -2167,7 +2167,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 			n -= m;
 			retval = -EFAULT;
 		}
-		comedi_buf_write_free(async, n);
+		comedi_buf_write_free(s, n);
 
 		count += n;
 		nbytes -= n;

commit 24e894bbf247ecdeed3ed2f77f658da756760f60
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:04 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_write_alloc()
    
    Change the parameters of `comedi_buf_write_alloc()` to pass a pointer to
    the comedi subdevice instead of a pointer to the "async" structure
    belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 0affd1f96660..58c1f6e18d27 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1004,7 +1004,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 
 	if (bi.bytes_written && (s->subdev_flags & SDF_CMD_WRITE)) {
 		bi.bytes_written =
-		    comedi_buf_write_alloc(async, bi.bytes_written);
+		    comedi_buf_write_alloc(s, bi.bytes_written);
 		comedi_buf_write_free(async, bi.bytes_written);
 	}
 
@@ -2038,7 +2038,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 		unsigned int bps = bytes_per_sample(s);
 
 		poll_wait(file, &s->async->wait_head, wait);
-		comedi_buf_write_alloc(s->async, s->async->prealloc_bufsz);
+		comedi_buf_write_alloc(s, s->async->prealloc_bufsz);
 		if (!s->busy || !comedi_is_subdevice_running(s) ||
 		    comedi_buf_write_n_allocated(s->async) >= bps)
 			mask |= POLLOUT | POLLWRNORM;
@@ -2136,7 +2136,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 		m = n;
 		if (async->buf_write_ptr + m > async->prealloc_bufsz)
 			m = async->prealloc_bufsz - async->buf_write_ptr;
-		comedi_buf_write_alloc(async, async->prealloc_bufsz);
+		comedi_buf_write_alloc(s, async->prealloc_bufsz);
 		if (m > comedi_buf_write_n_allocated(async))
 			m = comedi_buf_write_n_allocated(async);
 		if (m < n)

commit 482f0a21904583923d5c37f84586839c026a734b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 2 13:50:14 2014 +0100

    staging: comedi: remove async parameter from resize_async_buffer()
    
    The `struct comedi_async *async` parameter of `resize_async_buffer()` is
    redundant as its value can be easily derived from the `struct
    comedi_subdevice *s` parameter as `s->async`.  Remove the parameter.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ecd27a6fc7f9..0affd1f96660 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -238,9 +238,9 @@ comedi_write_subdevice(const struct comedi_device *dev, unsigned int minor)
 }
 
 static int resize_async_buffer(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_async *async, unsigned new_size)
+			       struct comedi_subdevice *s, unsigned new_size)
 {
+	struct comedi_async *async = s->async;
 	int retval;
 
 	if (new_size > async->max_bufsize)
@@ -380,7 +380,7 @@ static ssize_t read_buffer_kb_store(struct device *csdev,
 	mutex_lock(&dev->mutex);
 	s = comedi_read_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
-		err = resize_async_buffer(dev, s, s->async, size);
+		err = resize_async_buffer(dev, s, size);
 	else
 		err = -EINVAL;
 	mutex_unlock(&dev->mutex);
@@ -493,7 +493,7 @@ static ssize_t write_buffer_kb_store(struct device *csdev,
 	mutex_lock(&dev->mutex);
 	s = comedi_write_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
-		err = resize_async_buffer(dev, s, s->async, size);
+		err = resize_async_buffer(dev, s, size);
 	else
 		err = -EINVAL;
 	mutex_unlock(&dev->mutex);
@@ -741,7 +741,7 @@ static int do_bufconfig_ioctl(struct comedi_device *dev,
 	}
 
 	if (bc.size) {
-		retval = resize_async_buffer(dev, s, async, bc.size);
+		retval = resize_async_buffer(dev, s, bc.size);
 		if (retval < 0)
 			return retval;
 	}

commit 0ce016d0986ae618e0686489ad7b858fa13b885d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 2 13:50:13 2014 +0100

    staging: comedi: remove redundant pointer dereference in comedi_poll()
    
    `s->async->subdevice` in `comedi_poll()` points to the same `struct
    comedi_subdevice` as `s`, so the double pointer reference is redundant.
    Just use `s`.
    
    (`s->async->subdevice` is initialized by
    `__comedi_device_postconfig_async()` in
    "drivers/staging/comedi/drivers.c" and doesn't change.)
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b24bf9bcbe2d..ecd27a6fc7f9 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2035,7 +2035,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 
 	s = comedi_write_subdevice(dev, minor);
 	if (s && s->async) {
-		unsigned int bps = bytes_per_sample(s->async->subdevice);
+		unsigned int bps = bytes_per_sample(s);
 
 		poll_wait(file, &s->async->wait_head, wait);
 		comedi_buf_write_alloc(s->async, s->async->prealloc_bufsz);

commit 4bac39f6c9b00c9cfc3e418ea1d0afcd1c113c2f
Author: Raghavendra Ganiga <ravi23ganiga@gmail.com>
Date:   Thu May 1 13:53:12 2014 +0530

    staging: comedi: fix coding style issues in comedi_fops.c
    
    This is a patch to fix coding style
    warnings found by checkpatch.pl tool
    
    Signed-off-by: Raghavendra Chandra Ganiga <ravi23ganiga@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 70545e670dd0..b24bf9bcbe2d 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -668,6 +668,7 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 			return -EBUSY;
 		if (dev->attached) {
 			struct module *driver_module = dev->driver->module;
+
 			comedi_device_detach(dev);
 			module_put(driver_module);
 		}
@@ -2653,6 +2654,7 @@ static int __init comedi_init(void)
 	/* create devices files for legacy/manual use */
 	for (i = 0; i < comedi_num_legacy_minors; i++) {
 		struct comedi_device *dev;
+
 		dev = comedi_alloc_board_minor(NULL);
 		if (IS_ERR(dev)) {
 			comedi_cleanup_board_minors();

commit 3eb9992caff10b62cf0ed0bcb1667a58b13188fa
Merge: e347fa5f4271 a798c10faf62
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 22 10:08:40 2014 -0700

    Merge 3.15-rc2 into staging-next
    
    This resolves a bunch of merge errors with other fixes that are already
    in Linus's tree.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b34aa86f12e8848ba453215602c8c50fa63c4cb3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 10 19:41:57 2014 +0100

    staging: comedi: fix circular locking dependency in comedi_mmap()
    
    Mmapping a comedi data buffer with lockdep checking enabled produced the
    following kernel debug messages:
    
    ======================================================
    [ INFO: possible circular locking dependency detected ]
    3.5.0-rc3-ija1+ #9 Tainted: G         C
    -------------------------------------------------------
    comedi_test/4160 is trying to acquire lock:
     (&dev->mutex#2){+.+.+.}, at: [<ffffffffa00313f4>] comedi_mmap+0x57/0x1d9 [comedi]
    
    but task is already holding lock:
     (&mm->mmap_sem){++++++}, at: [<ffffffff810c96fe>] vm_mmap_pgoff+0x41/0x76
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #1 (&mm->mmap_sem){++++++}:
           [<ffffffff8106d0e8>] lock_acquire+0x97/0x105
           [<ffffffff810ce3bc>] might_fault+0x6d/0x90
           [<ffffffffa0031ffb>] do_devinfo_ioctl.isra.7+0x11e/0x14c [comedi]
           [<ffffffffa003227f>] comedi_unlocked_ioctl+0x256/0xe48 [comedi]
           [<ffffffff810f7fcd>] vfs_ioctl+0x18/0x34
           [<ffffffff810f87fd>] do_vfs_ioctl+0x382/0x43c
           [<ffffffff810f88f9>] sys_ioctl+0x42/0x65
           [<ffffffff81415c62>] system_call_fastpath+0x16/0x1b
    
    -> #0 (&dev->mutex#2){+.+.+.}:
           [<ffffffff8106c528>] __lock_acquire+0x101d/0x1591
           [<ffffffff8106d0e8>] lock_acquire+0x97/0x105
           [<ffffffff8140c894>] mutex_lock_nested+0x46/0x2a4
           [<ffffffffa00313f4>] comedi_mmap+0x57/0x1d9 [comedi]
           [<ffffffff810d5816>] mmap_region+0x281/0x492
           [<ffffffff810d5c92>] do_mmap_pgoff+0x26b/0x2a7
           [<ffffffff810c971a>] vm_mmap_pgoff+0x5d/0x76
           [<ffffffff810d493f>] sys_mmap_pgoff+0xc7/0x10d
           [<ffffffff81004d36>] sys_mmap+0x16/0x20
           [<ffffffff81415c62>] system_call_fastpath+0x16/0x1b
    
    other info that might help us debug this:
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(&mm->mmap_sem);
                                   lock(&dev->mutex#2);
                                   lock(&mm->mmap_sem);
      lock(&dev->mutex#2);
    
     *** DEADLOCK ***
    
    To avoid the circular dependency, just try to get the lock in
    `comedi_mmap()` instead of blocking.  Since the comedi device's main mutex
    is heavily used, do a down-read of its `attach_lock` rwsemaphore
    instead.  Trying to down-read `attach_lock` should only fail if
    some task has down-write locked it, and that is only done while the
    comedi device is being attached to or detached from a low-level hardware
    device.
    
    Unfortunately, acquiring the `attach_lock` doesn't prevent another
    task replacing the comedi data buffer we are trying to mmap.  The
    details of the buffer are held in a `struct comedi_buf_map` and pointed
    to by `s->async->buf_map` where `s` is the comedi subdevice whose buffer
    we are trying to map.  The `struct comedi_buf_map` is already reference
    counted with a `struct kref`, so we can stop it being freed prematurely.
    
    Modify `comedi_mmap()` to call new function
    `comedi_buf_map_from_subdev_get()` to read the subdevice's current
    buffer map pointer and increment its reference instead of accessing
    `async->buf_map` directly.  Call `comedi_buf_map_put()` to decrement the
    reference once the buffer map structure has been dealt with.  (Note that
    `comedi_buf_map_put()` does nothing if passed a NULL pointer.)
    
    `comedi_buf_map_from_subdev_get()` checks the subdevice's buffer map
    pointer has been set and the buffer map has been initialized enough for
    `comedi_mmap()` to deal with it (specifically, check the `n_pages`
    member has been set to a non-zero value).  If all is well, the buffer
    map's reference is incremented and a pointer to it is returned.  The
    comedi subdevice's spin-lock is used to protect the checks.  Also use
    the spin-lock in `__comedi_buf_alloc()` and `__comedi_buf_free()` to
    protect changes to the subdevice's buffer map structure pointer and the
    buffer map structure's `n_pages` member.  (This checking of `n_pages` is
    a bit clunky and I [Ian Abbott] plan to deal with it in the future.)
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: <stable@vger.kernel.org> # 3.14.x, 3.15.x
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ea6dc36d753b..acc80197e35e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1926,14 +1926,21 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	struct comedi_device *dev = file->private_data;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
-	struct comedi_buf_map *bm;
+	struct comedi_buf_map *bm = NULL;
 	unsigned long start = vma->vm_start;
 	unsigned long size;
 	int n_pages;
 	int i;
 	int retval;
 
-	mutex_lock(&dev->mutex);
+	/*
+	 * 'trylock' avoids circular dependency with current->mm->mmap_sem
+	 * and down-reading &dev->attach_lock should normally succeed without
+	 * contention unless the device is in the process of being attached
+	 * or detached.
+	 */
+	if (!down_read_trylock(&dev->attach_lock))
+		return -EAGAIN;
 
 	if (!dev->attached) {
 		dev_dbg(dev->class_dev, "no driver attached\n");
@@ -1973,7 +1980,9 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	}
 
 	n_pages = size >> PAGE_SHIFT;
-	bm = async->buf_map;
+
+	/* get reference to current buf map (if any) */
+	bm = comedi_buf_map_from_subdev_get(s);
 	if (!bm || n_pages > bm->n_pages) {
 		retval = -EINVAL;
 		goto done;
@@ -1997,7 +2006,8 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 
 	retval = 0;
 done:
-	mutex_unlock(&dev->mutex);
+	up_read(&dev->attach_lock);
+	comedi_buf_map_put(bm);	/* put reference to buf map - okay if NULL */
 	return retval;
 }
 

commit b2f4874174b17db72d4a67aec2dac56304ceb8ba
Author: Yves Deweerdt <yves.deweerdt.linux@gmail.com>
Date:   Mon Mar 31 22:55:39 2014 +0200

    staging: comedi: comedy_fops.c: fix line over 80, characters warnings
    
    Signed-off-by: Yves Deweerdt <yves.deweerdt.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1e91161fb38f..e283e6c7b52b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1435,13 +1435,15 @@ static int __comedi_get_user_cmd(struct comedi_device *dev,
 	s = &dev->subdevices[cmd->subdev];
 
 	if (s->type == COMEDI_SUBD_UNUSED) {
-		dev_dbg(dev->class_dev, "%d not valid subdevice\n", cmd->subdev);
+		dev_dbg(dev->class_dev, "%d not valid subdevice\n",
+			cmd->subdev);
 		return -EIO;
 	}
 
 	if (!s->do_cmd || !s->do_cmdtest || !s->async) {
 		dev_dbg(dev->class_dev,
-			"subdevice %d does not support commands\n", cmd->subdev);
+			"subdevice %d does not support commands\n",
+			cmd->subdev);
 		return -EIO;
 	}
 

commit f619621f409a9e8d5c56b2089d359fe3b5b8ad57
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Mar 31 10:50:36 2014 +0300

    staging: comedi: remove an unneeded variable
    
    "chanlist" was left over, we don't need it any more.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ea6dc36d753b..1e91161fb38f 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1597,7 +1597,6 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 {
 	struct comedi_cmd cmd;
 	struct comedi_subdevice *s;
-	unsigned int *chanlist = NULL;
 	unsigned int __user *user_chanlist;
 	int ret;
 
@@ -1626,8 +1625,6 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 		ret = -EFAULT;
 	}
 
-	kfree(chanlist);
-
 	return ret;
 }
 

commit c6cd0eefb27b47a3f67ec0adbea14b4f97d72ec9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 6 12:02:57 2014 -0700

    staging: comedi: comedi_fops: introduce __comedi_get_user_chanlist()
    
    The COMEDI_CMD and COMEDI_CMDTEST ioctl functions both copy the chanlist
    passed by the user from __user memory space to kernel memory space. They
    then do some sanity checking of the chanlist with comedi_check_chanlist()
    before the subdevice (*do_cmdtest) and (*do_cmd) operations are called.
    
    Introduce a helper function to handle the memdup_user() and the sanity
    checking.
    
    Also, remove the unnecessary dev_dbg() when the memdup_user() or
    comedi_check_chanlist() fail.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index bf5265a083f6..ea6dc36d753b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1455,6 +1455,35 @@ static int __comedi_get_user_cmd(struct comedi_device *dev,
 	return 0;
 }
 
+static int __comedi_get_user_chanlist(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      unsigned int __user *user_chanlist,
+				      struct comedi_cmd *cmd)
+{
+	unsigned int *chanlist;
+	int ret;
+
+	/* user_chanlist could be NULL for do_cmdtest ioctls */
+	if (!user_chanlist)
+		return 0;
+
+	chanlist = memdup_user(user_chanlist,
+			       cmd->chanlist_len * sizeof(unsigned int));
+	if (IS_ERR(chanlist))
+		return PTR_ERR(chanlist);
+
+	/* make sure each element in channel/gain list is valid */
+	ret = comedi_check_chanlist(s, cmd->chanlist_len, chanlist);
+	if (ret < 0) {
+		kfree(chanlist);
+		return ret;
+	}
+
+	cmd->chanlist = chanlist;
+
+	return 0;
+}
+
 static int do_cmd_ioctl(struct comedi_device *dev,
 			struct comedi_cmd __user *arg, void *file)
 {
@@ -1496,26 +1525,11 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 
 	async->cmd = cmd;
 	async->cmd.data = NULL;
-	/* load channel/gain list */
-	async->cmd.chanlist = memdup_user(user_chanlist,
-					  async->cmd.chanlist_len *
-					  sizeof(int));
-	if (IS_ERR(async->cmd.chanlist)) {
-		ret = PTR_ERR(async->cmd.chanlist);
-		async->cmd.chanlist = NULL;
-		dev_dbg(dev->class_dev, "memdup_user failed with code %d\n",
-			ret);
-		goto cleanup;
-	}
 
-	/* make sure each element in channel/gain list is valid */
-	ret = comedi_check_chanlist(s,
-				    async->cmd.chanlist_len,
-				    async->cmd.chanlist);
-	if (ret < 0) {
-		dev_dbg(dev->class_dev, "bad chanlist\n");
+	/* load channel/gain list */
+	ret = __comedi_get_user_chanlist(dev, s, user_chanlist, &async->cmd);
+	if (ret)
 		goto cleanup;
-	}
 
 	ret = s->do_cmdtest(dev, s, &async->cmd);
 
@@ -1598,26 +1612,9 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 	s = &dev->subdevices[cmd.subdev];
 
 	/* load channel/gain list */
-	if (cmd.chanlist) {
-		chanlist = memdup_user(user_chanlist,
-				       cmd.chanlist_len * sizeof(int));
-		if (IS_ERR(chanlist)) {
-			ret = PTR_ERR(chanlist);
-			chanlist = NULL;
-			dev_dbg(dev->class_dev,
-				"memdup_user exited with code %d", ret);
-			goto cleanup;
-		}
-
-		/* make sure each element in channel/gain list is valid */
-		ret = comedi_check_chanlist(s, cmd.chanlist_len, chanlist);
-		if (ret < 0) {
-			dev_dbg(dev->class_dev, "bad chanlist\n");
-			goto cleanup;
-		}
-
-		cmd.chanlist = chanlist;
-	}
+	ret = __comedi_get_user_chanlist(dev, s, user_chanlist, &cmd);
+	if (ret)
+		return ret;
 
 	ret = s->do_cmdtest(dev, s, &cmd);
 
@@ -1627,9 +1624,8 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 	if (copy_to_user(arg, &cmd, sizeof(cmd))) {
 		dev_dbg(dev->class_dev, "bad cmd address\n");
 		ret = -EFAULT;
-		goto cleanup;
 	}
-cleanup:
+
 	kfree(chanlist);
 
 	return ret;

commit 87ece583310d47bcf0027e4a77c990bbb010fc5e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 6 12:02:56 2014 -0700

    staging: comedi: comedi_fops: introduce __comedi_get_user_cmd()
    
    The COMEDI_CMD and COMEDI_CMDTEST ioctl functions both copy the
    comedi_cmd passed by the user from __user memory space to kernel
    memory space. They then do some basic sanity checking of the cmd
    before the subdevice (*do_cmdtest) and (*do_cmd) operations are
    called.
    
    Introduce a helper function to handle the copy_from_user() and
    do the basic sanity checking.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a819e543ed30..bf5265a083f6 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1416,41 +1416,65 @@ static int do_insn_ioctl(struct comedi_device *dev,
 	return ret;
 }
 
-static int do_cmd_ioctl(struct comedi_device *dev,
-			struct comedi_cmd __user *arg, void *file)
+static int __comedi_get_user_cmd(struct comedi_device *dev,
+				 struct comedi_cmd __user *arg,
+				 struct comedi_cmd *cmd)
 {
-	struct comedi_cmd cmd;
 	struct comedi_subdevice *s;
-	struct comedi_async *async;
-	int ret = 0;
-	unsigned int __user *user_chanlist;
 
-	if (copy_from_user(&cmd, arg, sizeof(cmd))) {
+	if (copy_from_user(cmd, arg, sizeof(*cmd))) {
 		dev_dbg(dev->class_dev, "bad cmd address\n");
 		return -EFAULT;
 	}
-	/* save user's chanlist pointer so it can be restored later */
-	user_chanlist = (unsigned int __user *)cmd.chanlist;
 
-	if (cmd.subdev >= dev->n_subdevices) {
-		dev_dbg(dev->class_dev, "%d no such subdevice\n", cmd.subdev);
+	if (cmd->subdev >= dev->n_subdevices) {
+		dev_dbg(dev->class_dev, "%d no such subdevice\n", cmd->subdev);
 		return -ENODEV;
 	}
 
-	s = &dev->subdevices[cmd.subdev];
-	async = s->async;
+	s = &dev->subdevices[cmd->subdev];
 
 	if (s->type == COMEDI_SUBD_UNUSED) {
-		dev_dbg(dev->class_dev, "%d not valid subdevice\n", cmd.subdev);
+		dev_dbg(dev->class_dev, "%d not valid subdevice\n", cmd->subdev);
 		return -EIO;
 	}
 
 	if (!s->do_cmd || !s->do_cmdtest || !s->async) {
 		dev_dbg(dev->class_dev,
-			"subdevice %i does not support commands\n", cmd.subdev);
+			"subdevice %d does not support commands\n", cmd->subdev);
 		return -EIO;
 	}
 
+	/* make sure channel/gain list isn't too long */
+	if (cmd->chanlist_len > s->len_chanlist) {
+		dev_dbg(dev->class_dev, "channel/gain list too long %d > %d\n",
+			cmd->chanlist_len, s->len_chanlist);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int do_cmd_ioctl(struct comedi_device *dev,
+			struct comedi_cmd __user *arg, void *file)
+{
+	struct comedi_cmd cmd;
+	struct comedi_subdevice *s;
+	struct comedi_async *async;
+	unsigned int __user *user_chanlist;
+	int ret;
+
+	/* get the user's cmd and do some simple validation */
+	ret = __comedi_get_user_cmd(dev, arg, &cmd);
+	if (ret)
+		return ret;
+
+	/* save user's chanlist pointer so it can be restored later */
+	user_chanlist = (unsigned int __user *)cmd.chanlist;
+
+	s = &dev->subdevices[cmd.subdev];
+	async = s->async;
+
 	/* are we locked? (ioctl lock) */
 	if (s->lock && s->lock != file) {
 		dev_dbg(dev->class_dev, "subdevice locked\n");
@@ -1463,13 +1487,6 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 		return -EBUSY;
 	}
 
-	/* make sure channel/gain list isn't too long */
-	if (cmd.chanlist_len > s->len_chanlist) {
-		dev_dbg(dev->class_dev, "channel/gain list too long %u > %d\n",
-			cmd.chanlist_len, s->len_chanlist);
-		return -EINVAL;
-	}
-
 	/* make sure channel/gain list isn't too short */
 	if (cmd.chanlist_len < 1) {
 		dev_dbg(dev->class_dev, "channel/gain list too short %u < 1\n",
@@ -1566,41 +1583,19 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 {
 	struct comedi_cmd cmd;
 	struct comedi_subdevice *s;
-	int ret = 0;
 	unsigned int *chanlist = NULL;
 	unsigned int __user *user_chanlist;
+	int ret;
+
+	/* get the user's cmd and do some simple validation */
+	ret = __comedi_get_user_cmd(dev, arg, &cmd);
+	if (ret)
+		return ret;
 
-	if (copy_from_user(&cmd, arg, sizeof(cmd))) {
-		dev_dbg(dev->class_dev, "bad cmd address\n");
-		return -EFAULT;
-	}
 	/* save user's chanlist pointer so it can be restored later */
 	user_chanlist = (unsigned int __user *)cmd.chanlist;
 
-	if (cmd.subdev >= dev->n_subdevices) {
-		dev_dbg(dev->class_dev, "%d no such subdevice\n", cmd.subdev);
-		return -ENODEV;
-	}
-
 	s = &dev->subdevices[cmd.subdev];
-	if (s->type == COMEDI_SUBD_UNUSED) {
-		dev_dbg(dev->class_dev, "%d not valid subdevice\n", cmd.subdev);
-		return -EIO;
-	}
-
-	if (!s->do_cmd || !s->do_cmdtest) {
-		dev_dbg(dev->class_dev,
-			"subdevice %i does not support commands\n", cmd.subdev);
-		return -EIO;
-	}
-
-	/* make sure channel/gain list isn't too long */
-	if (cmd.chanlist_len > s->len_chanlist) {
-		dev_dbg(dev->class_dev, "channel/gain list too long %d > %d\n",
-			cmd.chanlist_len, s->len_chanlist);
-		ret = -EINVAL;
-		goto cleanup;
-	}
 
 	/* load channel/gain list */
 	if (cmd.chanlist) {

commit cc0f58a9b98f14aa09d2a8cb81a394bee8d7f2f4
Author: Monam Agarwal <monamagarwal123@gmail.com>
Date:   Mon Feb 24 22:19:42 2014 +0530

    Staging: comedi: Fix line length exceeding 80 characters
    
    Signed-off-by: Monam Agarwal <monamagarwal123@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ac1edd9d1e21..a819e543ed30 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1481,7 +1481,8 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	async->cmd.data = NULL;
 	/* load channel/gain list */
 	async->cmd.chanlist = memdup_user(user_chanlist,
-					  async->cmd.chanlist_len * sizeof(int));
+					  async->cmd.chanlist_len *
+					  sizeof(int));
 	if (IS_ERR(async->cmd.chanlist)) {
 		ret = PTR_ERR(async->cmd.chanlist);
 		async->cmd.chanlist = NULL;

commit 22ca19d93d92c79cff68270846a84bd34fe6fb34
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:45 2014 -0700

    staging: comedi: move (*insn_{read, write}) timeout debug messages to core
    
    Have the comedi core display a standard dev_dbg() message when a timeout
    occurs and remove all the driver specific messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b36b76060d03..ac1edd9d1e21 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1194,6 +1194,11 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 		switch (insn->insn) {
 		case INSN_READ:
 			ret = s->insn_read(dev, s, insn, data);
+			if (ret == -ETIMEDOUT) {
+				dev_dbg(dev->class_dev,
+					"subdevice %d read instruction timed out\n",
+					s->index);
+			}
 			break;
 		case INSN_WRITE:
 			maxdata = s->maxdata_list
@@ -1207,8 +1212,14 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 					break;
 				}
 			}
-			if (ret == 0)
+			if (ret == 0) {
 				ret = s->insn_write(dev, s, insn, data);
+				if (ret == -ETIMEDOUT) {
+					dev_dbg(dev->class_dev,
+						"subdevice %d write instruction timed out\n",
+						s->index);
+				}
+			}
 			break;
 		case INSN_BITS:
 			if (insn->n != 2) {

commit ecd56ff9d1873fb04846a5847d3c53837084fa69
Author: Chase Southwood <chase.southwood@yahoo.com>
Date:   Wed Feb 12 02:28:35 2014 -0600

    Staging: comedi: Correct a few printf format codes
    
    My static checker found some slightly inaccurate format codes in printf
    calls in comedi_fops.c and drivers/comedi_bond.c.  It may be slightly
    pedantic to change them, but using the correctly corresponding format
    codes is probably a good idea.  All but one were unsigned ints that were
    formatted with %i, change these to %u, and one was an int formatted with
    %u, we want to format this with %d.
    
    Signed-off-by: Chase Southwood <chase.southwood@yahoo.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c22c617b0da1..b36b76060d03 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -297,7 +297,7 @@ static ssize_t max_read_buffer_kb_show(struct device *csdev,
 	mutex_unlock(&dev->mutex);
 
 	comedi_dev_put(dev);
-	return snprintf(buf, PAGE_SIZE, "%i\n", size);
+	return snprintf(buf, PAGE_SIZE, "%u\n", size);
 }
 
 static ssize_t max_read_buffer_kb_store(struct device *csdev,
@@ -353,7 +353,7 @@ static ssize_t read_buffer_kb_show(struct device *csdev,
 	mutex_unlock(&dev->mutex);
 
 	comedi_dev_put(dev);
-	return snprintf(buf, PAGE_SIZE, "%i\n", size);
+	return snprintf(buf, PAGE_SIZE, "%u\n", size);
 }
 
 static ssize_t read_buffer_kb_store(struct device *csdev,
@@ -410,7 +410,7 @@ static ssize_t max_write_buffer_kb_show(struct device *csdev,
 	mutex_unlock(&dev->mutex);
 
 	comedi_dev_put(dev);
-	return snprintf(buf, PAGE_SIZE, "%i\n", size);
+	return snprintf(buf, PAGE_SIZE, "%u\n", size);
 }
 
 static ssize_t max_write_buffer_kb_store(struct device *csdev,
@@ -466,7 +466,7 @@ static ssize_t write_buffer_kb_show(struct device *csdev,
 	mutex_unlock(&dev->mutex);
 
 	comedi_dev_put(dev);
-	return snprintf(buf, PAGE_SIZE, "%i\n", size);
+	return snprintf(buf, PAGE_SIZE, "%u\n", size);
 }
 
 static ssize_t write_buffer_kb_store(struct device *csdev,

commit 52ef9e7cb317fcb7f8b63f1bec7271e40341ce98
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jan 7 12:38:32 2014 +0000

    staging: comedi: fix bug destroying subdevice files after parent
    
    `comedi_free_board_dev()` is called (via `comedi_auto_unconfig()` -->
    `comedi_release_hardware_device()`) when an auto-configured comedi
    device is removed.  This destroys the main sysfs class device and then
    calls `comedi_device_cleanup()` to clean up the comedi device.  For
    comedi devices that have comedi subdevices that asynchronous commands,
    the clean up involves destroying the sysfs class devices associated with
    those subdevices.
    
    There is a bug in the above sequence because the sysfs class devices
    associated with the comedi subdevices are children of the sysfs class
    device associated with the main comedi device.  Therefore they will have
    been automatically destroyed when the main sysfs class device is
    destroyed.  When they are destroyed again as part of the clean-up, they
    will not be found, leading to a warning and a stack trace similar to
    this:
    
    ------------[ cut here ]------------
    WARNING: CPU: 1 PID: 1213 at fs/sysfs/group.c:214
    sysfs_remove_group+0x4e/0xa7()
    sysfs group ffffffff817504c0 not found for kobject 'comedi4_subd0'
    Modules linked in: nfsd auth_rpcgss oid_registry exportfs nfs_acl lockd
    bridge stp llc sunrpc fuse binfmt_misc cpufreq_userspace sr_mod
    snd_hda_codec_analog cdrom powernow_k8 kvm_amd kvm amplc_pci230(C)
    8255(C) comedi(C) pcmcia xhci_hcd ehci_pci pcmcia_core ohci_pci ohci_hcd
    ehci_hcd usbcore snd_hda_intel snd_hda_codec snd_pcm k8temp
    snd_page_alloc 8139too snd_timer snd soundcore mii usb_common forcedeth
    pata_amd
    CPU: 1 PID: 1213 Comm: kworker/u4:6 Tainted: G         C
    3.13.0-rc5-ija1+ #20
    Hardware name: System manufacturer System Product Name/M2N-E, BIOS ASUS
    M2N-E ACPI BIOS Revision 5001 03/23/2010
    Workqueue: sysfsd sysfs_schedule_callback_work
     0000000000000000 ffff8800bf17fb38 ffffffff814672ce ffff8800bf17fb80
     ffff8800bf17fb70 ffffffff8103470b ffffffff8114f780 0000000000000000
     ffffffff817504c0 ffff8800bf39f410 ffff880139b68670 ffff8800bf17fbd0
    Call Trace:
     [<ffffffff814672ce>] dump_stack+0x45/0x56
     [<ffffffff8103470b>] warn_slowpath_common+0x7a/0x93
     [<ffffffff8114f780>] ? sysfs_remove_group+0x4e/0xa7
     [<ffffffff8103476b>] warn_slowpath_fmt+0x47/0x49
     [<ffffffff8114e92d>] ? sysfs_get_dirent_ns+0x5e/0x66
     [<ffffffff8114f780>] sysfs_remove_group+0x4e/0xa7
     [<ffffffff8132aac0>] dpm_sysfs_remove+0x37/0x3b
     [<ffffffff81323781>] device_del+0x3e/0x173
     [<ffffffff813238c3>] device_unregister+0xd/0x18
     [<ffffffff8132392e>] device_destroy+0x33/0x37
     [<ffffffffa0212086>] comedi_free_subdevice_minor+0x80/0x92 [comedi]
     [<ffffffffa02128bb>] comedi_device_detach+0x79/0x152 [comedi]
     [<ffffffffa020f223>] comedi_device_cleanup+0x36/0x57 [comedi]
     [<ffffffffa020f275>] comedi_free_board_dev+0x31/0x3c [comedi]
     [<ffffffffa0211f2a>] comedi_release_hardware_device+0x5a/0x73 [comedi]
     [<ffffffffa0212547>] comedi_auto_unconfig+0xe/0x10 [comedi]
     [<ffffffffa021357c>] comedi_pci_auto_unconfig+0x10/0x12 [comedi]
     [<ffffffff811d2335>] pci_device_remove+0x40/0x8a
     [<ffffffff813261d0>] __device_release_driver+0x84/0xda
     [<ffffffff81326244>] device_release_driver+0x1e/0x2b
     [<ffffffff811cdcb5>] pci_stop_bus_device+0x44/0x87
     [<ffffffff811cdde2>] pci_stop_and_remove_bus_device+0xd/0x18
     [<ffffffff811d3f3d>] remove_callback+0x20/0x2f
     [<ffffffff8114d1f7>] sysfs_schedule_callback_work+0xf/0x70
     [<ffffffff81049498>] process_one_work+0x1d6/0x34c
     [<ffffffff81049a5f>] worker_thread+0x1cf/0x2b5
     [<ffffffff81049890>] ? rescuer_thread+0x258/0x258
     [<ffffffff8104e0e6>] kthread+0xd6/0xde
     [<ffffffff8104e010>] ? kthread_create_on_node+0x160/0x160
     [<ffffffff81472cbc>] ret_from_fork+0x7c/0xb0
     [<ffffffff8104e010>] ? kthread_create_on_node+0x160/0x160
    ---[ end trace 94722aa2936a7adf ]---
    
    To correct the bug, rearrange `comedi_free_board_dev()` to destroy the
    main sysfs class device *after* the clean-up operation.
    
    Thanks to Bernd Porr for finding the bug and his initial attempt to fix
    it.
    
    Reported-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index d7f63c483ad3..c22c617b0da1 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -153,11 +153,11 @@ static struct comedi_device *comedi_clear_board_minor(unsigned minor)
 static void comedi_free_board_dev(struct comedi_device *dev)
 {
 	if (dev) {
+		comedi_device_cleanup(dev);
 		if (dev->class_dev) {
 			device_destroy(comedi_class,
 				       MKDEV(COMEDI_MAJOR, dev->minor));
 		}
-		comedi_device_cleanup(dev);
 		comedi_dev_put(dev);
 	}
 }

commit e56b1401056288a725d50942ef300dcbed5e519a
Author: Bernd Porr <mail@berndporr.me.uk>
Date:   Wed Dec 11 16:06:15 2013 +0000

    staging: comedi: fix result of memdup_user for user chanlist
    
    If the channel list is not set in userspace we get an error at
    PTR_ERR(async->cmd.chanlist). However, do_become_nonbusy(dev, s) cleans
    up this pointer which causes a kernel ooops. Setting the channel list in
    async to NULL and checking this in do_become_nonbusy prevents the oops.
    
    [Ian Abbott] Also do the same for the chanlist allocated in
    do_cmdtest_ioctl().
    
    Signed-off-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index fc3404882ae8..d7f63c483ad3 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1473,6 +1473,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 					  async->cmd.chanlist_len * sizeof(int));
 	if (IS_ERR(async->cmd.chanlist)) {
 		ret = PTR_ERR(async->cmd.chanlist);
+		async->cmd.chanlist = NULL;
 		dev_dbg(dev->class_dev, "memdup_user failed with code %d\n",
 			ret);
 		goto cleanup;
@@ -1595,6 +1596,7 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 				       cmd.chanlist_len * sizeof(int));
 		if (IS_ERR(chanlist)) {
 			ret = PTR_ERR(chanlist);
+			chanlist = NULL;
 			dev_dbg(dev->class_dev,
 				"memdup_user exited with code %d", ret);
 			goto cleanup;

commit 1363e4fb4f460a903f3d62d7c1466ce76e31adb0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Dec 11 14:51:03 2013 +0000

    staging/comedi: bug fix for module usage count on device removal
    
    When a dynamically created comedi device is being automatically removed
    by a call to `comedi_auto_unconfig()` from the lower level driver,
    `comedi_device_cleanup()` is called to perform the detachment from the
    lower level driver.  If the comedi device is open at the time,
    `dev->use_count` will be the the number of outstanding opens.  The
    function currently decrements the the module counts of the "comedi"
    module and the low-level driver module by this amount and reduces
    `dev->use_count` to zero.  There are various problems with this as the
    `release` file operation handler `comedi_close()` also decrements
    `dev->use_count` and decrements the module usage counts.  This means
    that `dev->use_count` and the module counts can end up negative.
    
    Also, the assumed one-to-one relationship between the file open count
    and the low-level module usage count is invalid and can get screwed up.
    We only want to stop the low-level module being unloaded while a comedi
    device using the module has an open file object.
    
    Also, there is no need to manipulate the module count of the core
    "comedi" module at all since the comedi module is the owner of the file
    operations structure and the system will not unload the module while
    there are open file objects using it.
    
    Correct the bugs and simplify as follows:
    
    1. Get rid of the module count manipulations of the core "comedi" module
    (`THIS_MODULE`) altogether.
    
    2. Don't alter `dev->use_count` in `comedi_device_cleanup()` as it
    should only be altered by the `open` and `release` file operation
    handlers `comedi_open()` and `comedi_close()`.
    
    3. Increment the low-level module count for the following reasons:
    
      a) In `comedi_open()` if the open count was zero and the comedi device
         is attached to the low-level driver.
      b) When the `COMEDI_DEVCONFIG` ioctl is used to manually attach an
         unattached comedi device to a low-level driver.  The open count
         will be greater than zero at this time.  The actual increment of
         the low-level module count is already done by
         `comedi_device_attach()`.
    
    4. Decrement the low-level module count for the following reasons:
    
      a) In `comedi_close()` if the open count was 1 and the comedi device
         is attached to the low-level driver.
      b) In `comedi_device_cleanup()` (called via `comedi_auto_unconfig()`
         --> `comedi_release_hardware_device()` -->
         `comedi_free_board_dev()` when the comedi device is automatically
         unconfigured due to action by the low-level driver) if the device
         was attached (which it should be) and open count was non-zero
         (greater than zero).
      c) When the `COMEDI_DEVCONFIG` ioctl is used to manually detach the
         comedi device from the low-level driver.  The open count will be
         greater than zero at this time.
    
    The open count should never go negative.  Parts 3 and 4 ensure that the
    low-level module usage count is incremented on entering the state where
    the comedi device is attached to the low-level driver AND the open count
    is greater than zero, and is decremented on leaving that state.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 6e5f538023c1..fc3404882ae8 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -120,12 +120,8 @@ static void comedi_device_cleanup(struct comedi_device *dev)
 	if (dev->attached)
 		driver_module = dev->driver->module;
 	comedi_device_detach(dev);
-	while (dev->use_count > 0) {
-		if (driver_module)
-			module_put(driver_module);
-		module_put(THIS_MODULE);
-		dev->use_count--;
-	}
+	if (driver_module && dev->use_count)
+		module_put(driver_module);
 	mutex_unlock(&dev->mutex);
 }
 
@@ -2356,22 +2352,17 @@ static int comedi_open(struct inode *inode, struct file *file)
 		goto out;
 	}
 ok:
-	__module_get(THIS_MODULE);
-
-	if (dev->attached) {
+	if (dev->attached && dev->use_count == 0) {
 		if (!try_module_get(dev->driver->module)) {
-			module_put(THIS_MODULE);
 			rc = -ENOSYS;
 			goto out;
 		}
-	}
-
-	if (dev->attached && dev->use_count == 0 && dev->open) {
-		rc = dev->open(dev);
-		if (rc < 0) {
-			module_put(dev->driver->module);
-			module_put(THIS_MODULE);
-			goto out;
+		if (dev->open) {
+			rc = dev->open(dev);
+			if (rc < 0) {
+				module_put(dev->driver->module);
+				goto out;
+			}
 		}
 	}
 
@@ -2411,12 +2402,11 @@ static int comedi_close(struct inode *inode, struct file *file)
 				s->lock = NULL;
 		}
 	}
-	if (dev->attached && dev->use_count == 1 && dev->close)
-		dev->close(dev);
-
-	module_put(THIS_MODULE);
-	if (dev->attached)
+	if (dev->attached && dev->use_count == 1) {
+		if (dev->close)
+			dev->close(dev);
 		module_put(dev->driver->module);
+	}
 
 	dev->use_count--;
 

commit 8f988d8784e3fa4bb50dabeec516cd3fbdb4ea73
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Dec 11 14:51:02 2013 +0000

    staging/comedi: keep reference to class device after destroyed
    
    When a dynamically allocated `struct comedi_device` gets automatically
    unconfigured by a call to `comedi_auto_unconfig()` from a lower-level
    driver's bus removal function (e.g. when a USB device is disconnected),
    the class device in `dev->class_dev` (where `dev` points to the `struct
    comedi_device`) is destroyed by a call to `device_destroy()` that
    matches a previous call to `device_create()`.
    
    However, if the `struct comedi_device` is still associated with an open
    file object, the now invalid `dev->class_dev` pointer may still be
    passed to `dev_printk()` (via `dev_dbg()` etc.), producing bogus output
    or worse.
    
    To fix this, call `get_device()` on the class device if
    `device_create()` was successful.  Add a matching call to `put_device()`
    in `comedi_dev_kref_release()` when the `struct comedi_device` is freed.
    The calls to `dev_dbg()` etc. after the call to `device_destroy()` will
    still produce valid output, although the device will have been
    unregistered in sysfs.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index cdaef09c8993..6e5f538023c1 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -91,6 +91,7 @@ static void comedi_dev_kref_release(struct kref *kref)
 		container_of(kref, struct comedi_device, refcount);
 
 	mutex_destroy(&dev->mutex);
+	put_device(dev->class_dev);
 	kfree(dev);
 }
 
@@ -2514,7 +2515,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	csdev = device_create(comedi_class, hardware_device,
 			      MKDEV(COMEDI_MAJOR, i), NULL, "comedi%i", i);
 	if (!IS_ERR(csdev))
-		dev->class_dev = csdev;
+		dev->class_dev = get_device(csdev);
 
 	/* Note: dev->mutex needs to be unlocked by the caller. */
 	return dev;

commit 272850f07c47ab1bef4386e41d006a0e6c1654a9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:11 2013 -0700

    staging: comedi: comedi_fops: remove use of DPRINTK
    
    Use dev_dbg(), or pr_debug() when dev is not valid, instead of the
    DPRINTK macro to output the comedi debugging information.
    
    Remove the debug messages for allocation failures. The failure will
    have already generated a message.
    
    Reword the messages that include the dev->minor number. This number
    will already be displayed as part of the dev_dbg() output.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1071c9601d1a..cdaef09c8993 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -250,11 +250,13 @@ static int resize_async_buffer(struct comedi_device *dev,
 		return -EPERM;
 
 	if (s->busy) {
-		DPRINTK("subdevice is busy, cannot resize buffer\n");
+		dev_dbg(dev->class_dev,
+			"subdevice is busy, cannot resize buffer\n");
 		return -EBUSY;
 	}
 	if (comedi_buf_is_mmapped(async)) {
-		DPRINTK("subdevice is mmapped, cannot resize buffer\n");
+		dev_dbg(dev->class_dev,
+			"subdevice is mmapped, cannot resize buffer\n");
 		return -EBUSY;
 	}
 
@@ -272,8 +274,8 @@ static int resize_async_buffer(struct comedi_device *dev,
 			return retval;
 	}
 
-	DPRINTK("comedi%i subd %d buffer resized to %i bytes\n",
-		dev->minor, s->index, async->prealloc_bufsz);
+	dev_dbg(dev->class_dev, "subd %d buffer resized to %i bytes\n",
+		s->index, async->prealloc_bufsz);
 	return 0;
 }
 
@@ -726,7 +728,8 @@ static int do_bufconfig_ioctl(struct comedi_device *dev,
 	async = s->async;
 
 	if (!async) {
-		DPRINTK("subdevice does not have async capability\n");
+		dev_dbg(dev->class_dev,
+			"subdevice does not have async capability\n");
 		bc.size = 0;
 		bc.maximum_size = 0;
 		goto copyback;
@@ -973,7 +976,8 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	async = s->async;
 
 	if (!async) {
-		DPRINTK("subdevice does not have async capability\n");
+		dev_dbg(dev->class_dev,
+			"subdevice does not have async capability\n");
 		bi.buf_write_ptr = 0;
 		bi.buf_read_ptr = 0;
 		bi.buf_write_count = 0;
@@ -1125,19 +1129,20 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 				break;
 			}
 			if (insn->subdev >= dev->n_subdevices) {
-				DPRINTK("%d not usable subdevice\n",
+				dev_dbg(dev->class_dev,
+					"%d not usable subdevice\n",
 					insn->subdev);
 				ret = -EINVAL;
 				break;
 			}
 			s = &dev->subdevices[insn->subdev];
 			if (!s->async) {
-				DPRINTK("no async\n");
+				dev_dbg(dev->class_dev, "no async\n");
 				ret = -EINVAL;
 				break;
 			}
 			if (!s->async->inttrig) {
-				DPRINTK("no inttrig\n");
+				dev_dbg(dev->class_dev, "no inttrig\n");
 				ret = -EAGAIN;
 				break;
 			}
@@ -1146,7 +1151,7 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 				ret = 1;
 			break;
 		default:
-			DPRINTK("invalid insn\n");
+			dev_dbg(dev->class_dev, "invalid insn\n");
 			ret = -EINVAL;
 			break;
 		}
@@ -1155,21 +1160,23 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 		unsigned int maxdata;
 
 		if (insn->subdev >= dev->n_subdevices) {
-			DPRINTK("subdevice %d out of range\n", insn->subdev);
+			dev_dbg(dev->class_dev, "subdevice %d out of range\n",
+				insn->subdev);
 			ret = -EINVAL;
 			goto out;
 		}
 		s = &dev->subdevices[insn->subdev];
 
 		if (s->type == COMEDI_SUBD_UNUSED) {
-			DPRINTK("%d not usable subdevice\n", insn->subdev);
+			dev_dbg(dev->class_dev, "%d not usable subdevice\n",
+				insn->subdev);
 			ret = -EIO;
 			goto out;
 		}
 
 		/* are we locked? (ioctl lock) */
 		if (s->lock && s->lock != file) {
-			DPRINTK("device locked\n");
+			dev_dbg(dev->class_dev, "device locked\n");
 			ret = -EACCES;
 			goto out;
 		}
@@ -1177,7 +1184,7 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 		ret = comedi_check_chanlist(s, 1, &insn->chanspec);
 		if (ret < 0) {
 			ret = -EINVAL;
-			DPRINTK("bad chanspec\n");
+			dev_dbg(dev->class_dev, "bad chanspec\n");
 			goto out;
 		}
 
@@ -1198,7 +1205,8 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 			for (i = 0; i < insn->n; ++i) {
 				if (data[i] > maxdata) {
 					ret = -EINVAL;
-					DPRINTK("bad data value(s)\n");
+					dev_dbg(dev->class_dev,
+						"bad data value(s)\n");
 					break;
 				}
 			}
@@ -1280,35 +1288,35 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 
 	data = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);
 	if (!data) {
-		DPRINTK("kmalloc failed\n");
 		ret = -ENOMEM;
 		goto error;
 	}
 
 	insns = kcalloc(insnlist.n_insns, sizeof(*insns), GFP_KERNEL);
 	if (!insns) {
-		DPRINTK("kmalloc failed\n");
 		ret = -ENOMEM;
 		goto error;
 	}
 
 	if (copy_from_user(insns, insnlist.insns,
 			   sizeof(*insns) * insnlist.n_insns)) {
-		DPRINTK("copy_from_user failed\n");
+		dev_dbg(dev->class_dev, "copy_from_user failed\n");
 		ret = -EFAULT;
 		goto error;
 	}
 
 	for (i = 0; i < insnlist.n_insns; i++) {
 		if (insns[i].n > MAX_SAMPLES) {
-			DPRINTK("number of samples too large\n");
+			dev_dbg(dev->class_dev,
+				"number of samples too large\n");
 			ret = -EINVAL;
 			goto error;
 		}
 		if (insns[i].insn & INSN_MASK_WRITE) {
 			if (copy_from_user(data, insns[i].data,
 					   insns[i].n * sizeof(unsigned int))) {
-				DPRINTK("copy_from_user failed\n");
+				dev_dbg(dev->class_dev,
+					"copy_from_user failed\n");
 				ret = -EFAULT;
 				goto error;
 			}
@@ -1319,7 +1327,8 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 		if (insns[i].insn & INSN_MASK_READ) {
 			if (copy_to_user(insns[i].data, data,
 					 insns[i].n * sizeof(unsigned int))) {
-				DPRINTK("copy_to_user failed\n");
+				dev_dbg(dev->class_dev,
+					"copy_to_user failed\n");
 				ret = -EFAULT;
 				goto error;
 			}
@@ -1409,14 +1418,14 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	unsigned int __user *user_chanlist;
 
 	if (copy_from_user(&cmd, arg, sizeof(cmd))) {
-		DPRINTK("bad cmd address\n");
+		dev_dbg(dev->class_dev, "bad cmd address\n");
 		return -EFAULT;
 	}
 	/* save user's chanlist pointer so it can be restored later */
 	user_chanlist = (unsigned int __user *)cmd.chanlist;
 
 	if (cmd.subdev >= dev->n_subdevices) {
-		DPRINTK("%d no such subdevice\n", cmd.subdev);
+		dev_dbg(dev->class_dev, "%d no such subdevice\n", cmd.subdev);
 		return -ENODEV;
 	}
 
@@ -1424,38 +1433,38 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	async = s->async;
 
 	if (s->type == COMEDI_SUBD_UNUSED) {
-		DPRINTK("%d not valid subdevice\n", cmd.subdev);
+		dev_dbg(dev->class_dev, "%d not valid subdevice\n", cmd.subdev);
 		return -EIO;
 	}
 
 	if (!s->do_cmd || !s->do_cmdtest || !s->async) {
-		DPRINTK("subdevice %i does not support commands\n",
-			cmd.subdev);
+		dev_dbg(dev->class_dev,
+			"subdevice %i does not support commands\n", cmd.subdev);
 		return -EIO;
 	}
 
 	/* are we locked? (ioctl lock) */
 	if (s->lock && s->lock != file) {
-		DPRINTK("subdevice locked\n");
+		dev_dbg(dev->class_dev, "subdevice locked\n");
 		return -EACCES;
 	}
 
 	/* are we busy? */
 	if (s->busy) {
-		DPRINTK("subdevice busy\n");
+		dev_dbg(dev->class_dev, "subdevice busy\n");
 		return -EBUSY;
 	}
 
 	/* make sure channel/gain list isn't too long */
 	if (cmd.chanlist_len > s->len_chanlist) {
-		DPRINTK("channel/gain list too long %u > %d\n",
+		dev_dbg(dev->class_dev, "channel/gain list too long %u > %d\n",
 			cmd.chanlist_len, s->len_chanlist);
 		return -EINVAL;
 	}
 
 	/* make sure channel/gain list isn't too short */
 	if (cmd.chanlist_len < 1) {
-		DPRINTK("channel/gain list too short %u < 1\n",
+		dev_dbg(dev->class_dev, "channel/gain list too short %u < 1\n",
 			cmd.chanlist_len);
 		return -EINVAL;
 	}
@@ -1467,7 +1476,8 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 					  async->cmd.chanlist_len * sizeof(int));
 	if (IS_ERR(async->cmd.chanlist)) {
 		ret = PTR_ERR(async->cmd.chanlist);
-		DPRINTK("memdup_user failed with code %d\n", ret);
+		dev_dbg(dev->class_dev, "memdup_user failed with code %d\n",
+			ret);
 		goto cleanup;
 	}
 
@@ -1476,20 +1486,20 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 				    async->cmd.chanlist_len,
 				    async->cmd.chanlist);
 	if (ret < 0) {
-		DPRINTK("bad chanlist\n");
+		dev_dbg(dev->class_dev, "bad chanlist\n");
 		goto cleanup;
 	}
 
 	ret = s->do_cmdtest(dev, s, &async->cmd);
 
 	if (async->cmd.flags & TRIG_BOGUS || ret) {
-		DPRINTK("test returned %d\n", ret);
+		dev_dbg(dev->class_dev, "test returned %d\n", ret);
 		cmd = async->cmd;
 		/* restore chanlist pointer before copying back */
 		cmd.chanlist = (unsigned int __force *)user_chanlist;
 		cmd.data = NULL;
 		if (copy_to_user(arg, &cmd, sizeof(cmd))) {
-			DPRINTK("fault writing cmd\n");
+			dev_dbg(dev->class_dev, "fault writing cmd\n");
 			ret = -EFAULT;
 			goto cleanup;
 		}
@@ -1499,7 +1509,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 
 	if (!async->prealloc_bufsz) {
 		ret = -ENOMEM;
-		DPRINTK("no buffer (?)\n");
+		dev_dbg(dev->class_dev, "no buffer (?)\n");
 		goto cleanup;
 	}
 
@@ -1551,32 +1561,32 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 	unsigned int __user *user_chanlist;
 
 	if (copy_from_user(&cmd, arg, sizeof(cmd))) {
-		DPRINTK("bad cmd address\n");
+		dev_dbg(dev->class_dev, "bad cmd address\n");
 		return -EFAULT;
 	}
 	/* save user's chanlist pointer so it can be restored later */
 	user_chanlist = (unsigned int __user *)cmd.chanlist;
 
 	if (cmd.subdev >= dev->n_subdevices) {
-		DPRINTK("%d no such subdevice\n", cmd.subdev);
+		dev_dbg(dev->class_dev, "%d no such subdevice\n", cmd.subdev);
 		return -ENODEV;
 	}
 
 	s = &dev->subdevices[cmd.subdev];
 	if (s->type == COMEDI_SUBD_UNUSED) {
-		DPRINTK("%d not valid subdevice\n", cmd.subdev);
+		dev_dbg(dev->class_dev, "%d not valid subdevice\n", cmd.subdev);
 		return -EIO;
 	}
 
 	if (!s->do_cmd || !s->do_cmdtest) {
-		DPRINTK("subdevice %i does not support commands\n",
-			cmd.subdev);
+		dev_dbg(dev->class_dev,
+			"subdevice %i does not support commands\n", cmd.subdev);
 		return -EIO;
 	}
 
 	/* make sure channel/gain list isn't too long */
 	if (cmd.chanlist_len > s->len_chanlist) {
-		DPRINTK("channel/gain list too long %d > %d\n",
+		dev_dbg(dev->class_dev, "channel/gain list too long %d > %d\n",
 			cmd.chanlist_len, s->len_chanlist);
 		ret = -EINVAL;
 		goto cleanup;
@@ -1588,14 +1598,15 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 				       cmd.chanlist_len * sizeof(int));
 		if (IS_ERR(chanlist)) {
 			ret = PTR_ERR(chanlist);
-			DPRINTK("memdup_user exited with code %d", ret);
+			dev_dbg(dev->class_dev,
+				"memdup_user exited with code %d", ret);
 			goto cleanup;
 		}
 
 		/* make sure each element in channel/gain list is valid */
 		ret = comedi_check_chanlist(s, cmd.chanlist_len, chanlist);
 		if (ret < 0) {
-			DPRINTK("bad chanlist\n");
+			dev_dbg(dev->class_dev, "bad chanlist\n");
 			goto cleanup;
 		}
 
@@ -1608,7 +1619,7 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 	cmd.chanlist = (unsigned int __force *)user_chanlist;
 
 	if (copy_to_user(arg, &cmd, sizeof(cmd))) {
-		DPRINTK("bad cmd address\n");
+		dev_dbg(dev->class_dev, "bad cmd address\n");
 		ret = -EFAULT;
 		goto cleanup;
 	}
@@ -1818,7 +1829,7 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 	}
 
 	if (!dev->attached) {
-		DPRINTK("no driver configured on /dev/comedi%i\n", dev->minor);
+		dev_dbg(dev->class_dev, "no driver attached\n");
 		rc = -ENODEV;
 		goto done;
 	}
@@ -1923,7 +1934,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	mutex_lock(&dev->mutex);
 
 	if (!dev->attached) {
-		DPRINTK("no driver configured on comedi%i\n", dev->minor);
+		dev_dbg(dev->class_dev, "no driver attached\n");
 		retval = -ENODEV;
 		goto done;
 	}
@@ -1944,7 +1955,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	}
 
 	if (vma->vm_pgoff != 0) {
-		DPRINTK("comedi: mmap() offset must be 0.\n");
+		dev_dbg(dev->class_dev, "mmap() offset must be 0.\n");
 		retval = -EINVAL;
 		goto done;
 	}
@@ -1998,7 +2009,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	mutex_lock(&dev->mutex);
 
 	if (!dev->attached) {
-		DPRINTK("no driver configured on comedi%i\n", dev->minor);
+		dev_dbg(dev->class_dev, "no driver attached\n");
 		goto done;
 	}
 
@@ -2045,7 +2056,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	old_detach_count = dev->detach_count;
 
 	if (!dev->attached) {
-		DPRINTK("no driver configured on comedi%i\n", dev->minor);
+		dev_dbg(dev->class_dev, "no driver attached\n");
 		retval = -ENODEV;
 		goto out;
 	}
@@ -2181,7 +2192,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	old_detach_count = dev->detach_count;
 
 	if (!dev->attached) {
-		DPRINTK("no driver configured on comedi%i\n", dev->minor);
+		dev_dbg(dev->class_dev, "no driver attached\n");
 		retval = -ENODEV;
 		goto out;
 	}
@@ -2300,7 +2311,7 @@ static int comedi_open(struct inode *inode, struct file *file)
 	int rc;
 
 	if (!dev) {
-		DPRINTK("invalid minor number\n");
+		pr_debug("invalid minor number\n");
 		return -ENODEV;
 	}
 
@@ -2321,7 +2332,7 @@ static int comedi_open(struct inode *inode, struct file *file)
 	if (dev->attached)
 		goto ok;
 	if (!capable(CAP_NET_ADMIN) && dev->in_request_module) {
-		DPRINTK("in request module\n");
+		dev_dbg(dev->class_dev, "in request module\n");
 		rc = -ENODEV;
 		goto out;
 	}
@@ -2339,7 +2350,7 @@ static int comedi_open(struct inode *inode, struct file *file)
 	dev->in_request_module = false;
 
 	if (!dev->attached && !capable(CAP_NET_ADMIN)) {
-		DPRINTK("not attached and not CAP_NET_ADMIN\n");
+		dev_dbg(dev->class_dev, "not attached and not CAP_NET_ADMIN\n");
 		rc = -ENODEV;
 		goto out;
 	}
@@ -2440,8 +2451,6 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned runflags = 0;
 	unsigned runflags_mask = 0;
 
-	/* DPRINTK("comedi_event 0x%x\n",mask); */
-
 	if (!comedi_is_subdevice_running(s))
 		return;
 

commit d2601699d3381525d87cc7ccb3e886697c5af812
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 22 10:45:38 2013 -0700

    staging: comedi: remove comedi_debug module parameter
    
    Remove this module parameter and use the CONFIG_COMEDI_DEBUG option to
    enable normal kernel debugging with -DDEBUG flag.
    
    Remove the #undef DEBUG from all the comedi source files so they will
    honour the -DDEBUG flag.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 58f2b27144ca..1071c9601d1a 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -16,8 +16,6 @@
     GNU General Public License for more details.
 */
 
-#undef DEBUG
-
 #include "comedi_compat32.h"
 
 #include <linux/module.h>
@@ -47,15 +45,6 @@
 #define COMEDI_NUM_SUBDEVICE_MINORS	\
 	(COMEDI_NUM_MINORS - COMEDI_NUM_BOARD_MINORS)
 
-#ifdef CONFIG_COMEDI_DEBUG
-int comedi_debug;
-EXPORT_SYMBOL_GPL(comedi_debug);
-module_param(comedi_debug, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(comedi_debug,
-		 "enable comedi core and driver debugging if non-zero (default 0)"
-		);
-#endif
-
 static int comedi_num_legacy_minors;
 module_param(comedi_num_legacy_minors, int, S_IRUGO);
 MODULE_PARM_DESC(comedi_num_legacy_minors,

commit af93da31634d6d55c9d313b5c49af8b272f7cb79
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:43 2013 +0000

    staging: comedi: protect buffer from being freed while mmapped
    
    If a comedi device is automatically detached by `comedi_auto_unconfig()`
    any data buffers associated with subdevices that support asynchronous
    commands will be freed.  If the buffer is mmapped at the time, bad
    things are likely to happen!  Prevent this by moving some of the buffer
    details from `struct comedi_async` into a new, dynamically allocated,
    and kref-counted `struct comedi_buf_map`.  This holds a list of pages, a
    reference count, and enough information to free the pages.  The new
    member `buf_map` of `struct comedi_async` points to a `struct
    comedi_buf_map` when the buffer size is non-zero.
    
    Provide a new helper function `comedi_buf_is_mapped()` to check whether
    an a buffer is mmapped.  If it is mmapped, the buffer is not allowed to
    be resized and the device is not allowed to be manually detached by the
    `COMEDI_DEVCONFIG` ioctl.  Provide helper functions
    `comedi_buf_map_get()` and `comedi_buf_map_put()` to manipulate the
    reference count of the `struct comedi_buf_map`, which will be freed
    along with its contents via the 'release' callback of the `kref_put()`
    call.  The reference count is manipulated by the vma operations and the
    mmap file operation.
    
    Now, when the comedi device is automatically detached, the buffer will
    be effectively freed by calling `comedi_buf_alloc()` with a new buffer
    size of 0.  That calls local function `__comedi_buf_free()` which calls
    `comedi_buf_map_put()` on the `buf_map` member to free it.  It won't
    actually be freed until the final 'put'.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 8cb9d956e8f2..58f2b27144ca 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -264,7 +264,7 @@ static int resize_async_buffer(struct comedi_device *dev,
 		DPRINTK("subdevice is busy, cannot resize buffer\n");
 		return -EBUSY;
 	}
-	if (async->mmap_count) {
+	if (comedi_buf_is_mmapped(async)) {
 		DPRINTK("subdevice is mmapped, cannot resize buffer\n");
 		return -EBUSY;
 	}
@@ -647,7 +647,7 @@ static int is_device_busy(struct comedi_device *dev)
 		s = &dev->subdevices[i];
 		if (s->busy)
 			return 1;
-		if (s->async && s->async->mmap_count)
+		if (s->async && comedi_buf_is_mmapped(s->async))
 			return 1;
 	}
 
@@ -1899,28 +1899,18 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 
 static void comedi_vm_open(struct vm_area_struct *area)
 {
-	struct comedi_async *async;
-	struct comedi_device *dev;
+	struct comedi_buf_map *bm;
 
-	async = area->vm_private_data;
-	dev = async->subdevice->device;
-
-	mutex_lock(&dev->mutex);
-	async->mmap_count++;
-	mutex_unlock(&dev->mutex);
+	bm = area->vm_private_data;
+	comedi_buf_map_get(bm);
 }
 
 static void comedi_vm_close(struct vm_area_struct *area)
 {
-	struct comedi_async *async;
-	struct comedi_device *dev;
+	struct comedi_buf_map *bm;
 
-	async = area->vm_private_data;
-	dev = async->subdevice->device;
-
-	mutex_lock(&dev->mutex);
-	async->mmap_count--;
-	mutex_unlock(&dev->mutex);
+	bm = area->vm_private_data;
+	comedi_buf_map_put(bm);
 }
 
 static struct vm_operations_struct comedi_vm_ops = {
@@ -1934,6 +1924,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	struct comedi_device *dev = file->private_data;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
+	struct comedi_buf_map *bm;
 	unsigned long start = vma->vm_start;
 	unsigned long size;
 	int n_pages;
@@ -1980,8 +1971,13 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	}
 
 	n_pages = size >> PAGE_SHIFT;
+	bm = async->buf_map;
+	if (!bm || n_pages > bm->n_pages) {
+		retval = -EINVAL;
+		goto done;
+	}
 	for (i = 0; i < n_pages; ++i) {
-		struct comedi_buf_page *buf = &async->buf_page_list[i];
+		struct comedi_buf_page *buf = &bm->page_list[i];
 
 		if (remap_pfn_range(vma, start,
 				    page_to_pfn(virt_to_page(buf->virt_addr)),
@@ -1993,9 +1989,9 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	}
 
 	vma->vm_ops = &comedi_vm_ops;
-	vma->vm_private_data = async;
+	vma->vm_private_data = bm;
 
-	async->mmap_count++;
+	vma->vm_ops->open(vma);
 
 	retval = 0;
 done:

commit 63ab039511509739f881acfb99aef76b772e35a2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:42 2013 +0000

    staging: comedi: make determination of read or write subdevice safer
    
    `comedi_read_subdevice()` and `comedi_write_subdevice()` respectively
    determine the read and write subdevice to use for a comedi device,
    depending on a minor device number passed in.  The comedi device has a
    main "board" minor device number and may also have dynamically assigned,
    subdevice-specific minor device numbers, in a range of numbers shared by
    all comedi devices.  If the minor device number is within the range of
    subdevice-specific minor device numbers, both functions call
    `comedi_subdevice_from_minor()` to determine what subdevice is
    associated with the minor device number (if any) and then check the
    subdevice belongs to the comedi device.  Since the subdevice might
    belong to a different comedi device, the check is not protected against
    the subdevice being freed.  Perform the check in
    `comedi_subdevice_from_minor()` instead, where it is protected against
    the subdevice being freed.  Make it return `NULL` if the subdevice does
    not belong to the device.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index d569484f315b..8cb9d956e8f2 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -177,7 +177,7 @@ static void comedi_free_board_dev(struct comedi_device *dev)
 }
 
 static struct comedi_subdevice
-*comedi_subdevice_from_minor(unsigned minor)
+*comedi_subdevice_from_minor(const struct comedi_device *dev, unsigned minor)
 {
 	struct comedi_subdevice *s;
 	unsigned int i = minor - COMEDI_NUM_BOARD_MINORS;
@@ -185,6 +185,8 @@ static struct comedi_subdevice
 	BUG_ON(i >= COMEDI_NUM_SUBDEVICE_MINORS);
 	mutex_lock(&comedi_subdevice_minor_table_lock);
 	s = comedi_subdevice_minor_table[i];
+	if (s && s->device != dev)
+		s = NULL;
 	mutex_unlock(&comedi_subdevice_minor_table_lock);
 	return s;
 }
@@ -229,10 +231,8 @@ comedi_read_subdevice(const struct comedi_device *dev, unsigned int minor)
 	struct comedi_subdevice *s;
 
 	if (minor >= COMEDI_NUM_BOARD_MINORS) {
-		s = comedi_subdevice_from_minor(minor);
-		if (!s || s->device != dev)
-			return NULL;
-		if (s->subdev_flags & SDF_CMD_READ)
+		s = comedi_subdevice_from_minor(dev, minor);
+		if (s == NULL || (s->subdev_flags & SDF_CMD_READ))
 			return s;
 	}
 	return dev->read_subdev;
@@ -244,10 +244,8 @@ comedi_write_subdevice(const struct comedi_device *dev, unsigned int minor)
 	struct comedi_subdevice *s;
 
 	if (minor >= COMEDI_NUM_BOARD_MINORS) {
-		s = comedi_subdevice_from_minor(minor);
-		if (!s || s->device != dev)
-			return NULL;
-		if (s->subdev_flags & SDF_CMD_WRITE)
+		s = comedi_subdevice_from_minor(dev, minor);
+		if (s == NULL || (s->subdev_flags & SDF_CMD_WRITE))
 			return s;
 	}
 	return dev->write_subdev;

commit 49445b9117a6e9ca9a741251784432a1da2f9919
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:41 2013 +0000

    staging: comedi: remove comedi_dev_from_minor()
    
    The `comedi_dev_from_minor()` function is no longer used, so remove it.
    Calls to it have either been replaced by calls to
    `comedi_dev_get_from_minor()` or by using the `private_data` member of
    the open file object.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 08aa93a1c87c..d569484f315b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -189,34 +189,6 @@ static struct comedi_subdevice
 	return s;
 }
 
-static struct comedi_device *comedi_dev_from_board_minor(unsigned minor)
-{
-	struct comedi_device *dev;
-
-	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
-	mutex_lock(&comedi_board_minor_table_lock);
-	dev = comedi_board_minor_table[minor];
-	mutex_unlock(&comedi_board_minor_table_lock);
-	return dev;
-}
-
-static struct comedi_device *comedi_dev_from_subdevice_minor(unsigned minor)
-{
-	struct comedi_subdevice *s;
-
-	s = comedi_subdevice_from_minor(minor);
-	return s ? s->device : NULL;
-}
-
-struct comedi_device *comedi_dev_from_minor(unsigned minor)
-{
-	if (minor < COMEDI_NUM_BOARD_MINORS)
-		return comedi_dev_from_board_minor(minor);
-	else
-		return comedi_dev_from_subdevice_minor(minor);
-}
-EXPORT_SYMBOL_GPL(comedi_dev_from_minor);
-
 static struct comedi_device *comedi_dev_get_from_board_minor(unsigned minor)
 {
 	struct comedi_device *dev;

commit e5d670dcb7b336fb0c2fcff29ce87892e492e6b3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:40 2013 +0000

    staging: comedi: use file->private_data in file operations
    
    Since the `struct comedi_device` should now be protected from being
    freed while an open file object is using it, use the `private_data`
    member of the `struct file` to point to it.  Set it in `comedi_open()`
    and use it in the other file operation handlers instead of calling
    `comedi_dev_from_minor()` and checking the result.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 37400e85c417..08aa93a1c87c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1828,12 +1828,9 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 				  unsigned long arg)
 {
 	const unsigned minor = iminor(file_inode(file));
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_device *dev = file->private_data;
 	int rc;
 
-	if (!dev)
-		return -ENODEV;
-
 	mutex_lock(&dev->mutex);
 
 	/* Device config is special, because it must work on
@@ -1964,7 +1961,7 @@ static struct vm_operations_struct comedi_vm_ops = {
 static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	const unsigned minor = iminor(file_inode(file));
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_device *dev = file->private_data;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 	unsigned long start = vma->vm_start;
@@ -1973,9 +1970,6 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	int i;
 	int retval;
 
-	if (!dev)
-		return -ENODEV;
-
 	mutex_lock(&dev->mutex);
 
 	if (!dev->attached) {
@@ -2043,12 +2037,9 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 {
 	unsigned int mask = 0;
 	const unsigned minor = iminor(file_inode(file));
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_device *dev = file->private_data;
 	struct comedi_subdevice *s;
 
-	if (!dev)
-		return -ENODEV;
-
 	mutex_lock(&dev->mutex);
 
 	if (!dev->attached) {
@@ -2088,14 +2079,11 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file_inode(file));
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_device *dev = file->private_data;
 	bool on_wait_queue = false;
 	bool attach_locked;
 	unsigned int old_detach_count;
 
-	if (!dev)
-		return -ENODEV;
-
 	/* Protect against device detachment during operation. */
 	down_read(&dev->attach_lock);
 	attach_locked = true;
@@ -2227,14 +2215,11 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file_inode(file));
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_device *dev = file->private_data;
 	unsigned int old_detach_count;
 	bool become_nonbusy = false;
 	bool attach_locked;
 
-	if (!dev)
-		return -ENODEV;
-
 	/* Protect against device detachment during operation. */
 	down_read(&dev->attach_lock);
 	attach_locked = true;
@@ -2424,6 +2409,7 @@ static int comedi_open(struct inode *inode, struct file *file)
 	}
 
 	dev->use_count++;
+	file->private_data = dev;
 	rc = 0;
 
 out:
@@ -2435,25 +2421,17 @@ static int comedi_open(struct inode *inode, struct file *file)
 
 static int comedi_fasync(int fd, struct file *file, int on)
 {
-	const unsigned minor = iminor(file_inode(file));
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
-
-	if (!dev)
-		return -ENODEV;
+	struct comedi_device *dev = file->private_data;
 
 	return fasync_helper(fd, file, on, &dev->async_queue);
 }
 
 static int comedi_close(struct inode *inode, struct file *file)
 {
-	const unsigned minor = iminor(inode);
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_device *dev = file->private_data;
 	struct comedi_subdevice *s = NULL;
 	int i;
 
-	if (!dev)
-		return -ENODEV;
-
 	mutex_lock(&dev->mutex);
 
 	if (dev->subdevices) {

commit be535c9a058b73600666d5431cfb442f39989a33
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:37 2013 +0000

    staging: comedi: use refcount in sysfs attribute handlers
    
    Call `comedi_dev_get_from_minor()` instead of `comedi_dev_from_minor()`
    in the sysfs attribute handler functions to increment the reference of
    the `struct comedi_device` during the operation.  Call
    `comedi_dev_put()` to decrement the reference afterwards.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 0ff69133c212..37400e85c417 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -328,7 +328,7 @@ static ssize_t max_read_buffer_kb_show(struct device *csdev,
 	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
-	dev = comedi_dev_from_minor(minor);
+	dev = comedi_dev_get_from_minor(minor);
 	if (!dev)
 		return -ENODEV;
 
@@ -338,6 +338,7 @@ static ssize_t max_read_buffer_kb_show(struct device *csdev,
 		size = s->async->max_bufsize / 1024;
 	mutex_unlock(&dev->mutex);
 
+	comedi_dev_put(dev);
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
@@ -358,7 +359,7 @@ static ssize_t max_read_buffer_kb_store(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
-	dev = comedi_dev_from_minor(minor);
+	dev = comedi_dev_get_from_minor(minor);
 	if (!dev)
 		return -ENODEV;
 
@@ -370,6 +371,7 @@ static ssize_t max_read_buffer_kb_store(struct device *csdev,
 		err = -EINVAL;
 	mutex_unlock(&dev->mutex);
 
+	comedi_dev_put(dev);
 	return err ? err : count;
 }
 static DEVICE_ATTR_RW(max_read_buffer_kb);
@@ -382,7 +384,7 @@ static ssize_t read_buffer_kb_show(struct device *csdev,
 	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
-	dev = comedi_dev_from_minor(minor);
+	dev = comedi_dev_get_from_minor(minor);
 	if (!dev)
 		return -ENODEV;
 
@@ -392,6 +394,7 @@ static ssize_t read_buffer_kb_show(struct device *csdev,
 		size = s->async->prealloc_bufsz / 1024;
 	mutex_unlock(&dev->mutex);
 
+	comedi_dev_put(dev);
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
@@ -412,7 +415,7 @@ static ssize_t read_buffer_kb_store(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
-	dev = comedi_dev_from_minor(minor);
+	dev = comedi_dev_get_from_minor(minor);
 	if (!dev)
 		return -ENODEV;
 
@@ -424,6 +427,7 @@ static ssize_t read_buffer_kb_store(struct device *csdev,
 		err = -EINVAL;
 	mutex_unlock(&dev->mutex);
 
+	comedi_dev_put(dev);
 	return err ? err : count;
 }
 static DEVICE_ATTR_RW(read_buffer_kb);
@@ -437,7 +441,7 @@ static ssize_t max_write_buffer_kb_show(struct device *csdev,
 	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
-	dev = comedi_dev_from_minor(minor);
+	dev = comedi_dev_get_from_minor(minor);
 	if (!dev)
 		return -ENODEV;
 
@@ -447,6 +451,7 @@ static ssize_t max_write_buffer_kb_show(struct device *csdev,
 		size = s->async->max_bufsize / 1024;
 	mutex_unlock(&dev->mutex);
 
+	comedi_dev_put(dev);
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
@@ -467,7 +472,7 @@ static ssize_t max_write_buffer_kb_store(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
-	dev = comedi_dev_from_minor(minor);
+	dev = comedi_dev_get_from_minor(minor);
 	if (!dev)
 		return -ENODEV;
 
@@ -479,6 +484,7 @@ static ssize_t max_write_buffer_kb_store(struct device *csdev,
 		err = -EINVAL;
 	mutex_unlock(&dev->mutex);
 
+	comedi_dev_put(dev);
 	return err ? err : count;
 }
 static DEVICE_ATTR_RW(max_write_buffer_kb);
@@ -491,7 +497,7 @@ static ssize_t write_buffer_kb_show(struct device *csdev,
 	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
-	dev = comedi_dev_from_minor(minor);
+	dev = comedi_dev_get_from_minor(minor);
 	if (!dev)
 		return -ENODEV;
 
@@ -501,6 +507,7 @@ static ssize_t write_buffer_kb_show(struct device *csdev,
 		size = s->async->prealloc_bufsz / 1024;
 	mutex_unlock(&dev->mutex);
 
+	comedi_dev_put(dev);
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
@@ -521,7 +528,7 @@ static ssize_t write_buffer_kb_store(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
-	dev = comedi_dev_from_minor(minor);
+	dev = comedi_dev_get_from_minor(minor);
 	if (!dev)
 		return -ENODEV;
 
@@ -533,6 +540,7 @@ static ssize_t write_buffer_kb_store(struct device *csdev,
 		err = -EINVAL;
 	mutex_unlock(&dev->mutex);
 
+	comedi_dev_put(dev);
 	return err ? err : count;
 }
 static DEVICE_ATTR_RW(write_buffer_kb);

commit fc406986d4115dfbd5e2ea8a0e96920e97162689
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:34 2013 +0000

    staging: comedi: increment reference while file open
    
    In the 'open' file operation handler `comedi_open()` in "comedi_fops.c",
    call `comedi_dev_get_from_minor()` instead of `comedi_dev_from_minor()`
    to get the pointer to the `struct comedi_device`.  This increments the
    reference to prevent it being freed.  Call `comedi_dev_put()` to
    decrement the reference  on failure, and also call it from the 'release'
    file operation handler `comedi_close()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 5e5ddbdbad0b..0ff69133c212 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2348,7 +2348,8 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 static int comedi_open(struct inode *inode, struct file *file)
 {
 	const unsigned minor = iminor(inode);
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_device *dev = comedi_dev_get_from_minor(minor);
+	int rc;
 
 	if (!dev) {
 		DPRINTK("invalid minor number\n");
@@ -2373,8 +2374,8 @@ static int comedi_open(struct inode *inode, struct file *file)
 		goto ok;
 	if (!capable(CAP_NET_ADMIN) && dev->in_request_module) {
 		DPRINTK("in request module\n");
-		mutex_unlock(&dev->mutex);
-		return -ENODEV;
+		rc = -ENODEV;
+		goto out;
 	}
 	if (capable(CAP_NET_ADMIN) && dev->in_request_module)
 		goto ok;
@@ -2391,8 +2392,8 @@ static int comedi_open(struct inode *inode, struct file *file)
 
 	if (!dev->attached && !capable(CAP_NET_ADMIN)) {
 		DPRINTK("not attached and not CAP_NET_ADMIN\n");
-		mutex_unlock(&dev->mutex);
-		return -ENODEV;
+		rc = -ENODEV;
+		goto out;
 	}
 ok:
 	__module_get(THIS_MODULE);
@@ -2400,26 +2401,28 @@ static int comedi_open(struct inode *inode, struct file *file)
 	if (dev->attached) {
 		if (!try_module_get(dev->driver->module)) {
 			module_put(THIS_MODULE);
-			mutex_unlock(&dev->mutex);
-			return -ENOSYS;
+			rc = -ENOSYS;
+			goto out;
 		}
 	}
 
 	if (dev->attached && dev->use_count == 0 && dev->open) {
-		int rc = dev->open(dev);
+		rc = dev->open(dev);
 		if (rc < 0) {
 			module_put(dev->driver->module);
 			module_put(THIS_MODULE);
-			mutex_unlock(&dev->mutex);
-			return rc;
+			goto out;
 		}
 	}
 
 	dev->use_count++;
+	rc = 0;
 
+out:
 	mutex_unlock(&dev->mutex);
-
-	return 0;
+	if (rc)
+		comedi_dev_put(dev);
+	return rc;
 }
 
 static int comedi_fasync(int fd, struct file *file, int on)
@@ -2465,6 +2468,7 @@ static int comedi_close(struct inode *inode, struct file *file)
 	dev->use_count--;
 
 	mutex_unlock(&dev->mutex);
+	comedi_dev_put(dev);
 
 	return 0;
 }

commit b449c1cad7e3acf80834d4bdb1b6241d5d8dd249
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:33 2013 +0000

    staging: comedi: add comedi_dev_get_from_minor()
    
    Add function `struct comedi_device *comedi_dev_get_from_minor(unsigned
    minor)`.  This behaves like the existing `comedi_dev_from_minor()`
    except that it also increments the `struct kref refcount` member (via
    new helper function `comedi_dev_get()`) to prevent it being freed.  If
    it returns a valid pointer, the caller is responsible for calling
    `comedi_dev_put()` to decrement the reference count.
    
    Export `comedi_dev_get_from_minor()` and `comedi_dev_put()` as they will
    be used by the "kcomedilib" module in addition to the "comedi" module
    itself.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 403324c895b1..5e5ddbdbad0b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -111,6 +111,14 @@ int comedi_dev_put(struct comedi_device *dev)
 		return kref_put(&dev->refcount, comedi_dev_kref_release);
 	return 1;
 }
+EXPORT_SYMBOL_GPL(comedi_dev_put);
+
+static struct comedi_device *comedi_dev_get(struct comedi_device *dev)
+{
+	if (dev)
+		kref_get(&dev->refcount);
+	return dev;
+}
 
 static void comedi_device_cleanup(struct comedi_device *dev)
 {
@@ -209,6 +217,40 @@ struct comedi_device *comedi_dev_from_minor(unsigned minor)
 }
 EXPORT_SYMBOL_GPL(comedi_dev_from_minor);
 
+static struct comedi_device *comedi_dev_get_from_board_minor(unsigned minor)
+{
+	struct comedi_device *dev;
+
+	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
+	mutex_lock(&comedi_board_minor_table_lock);
+	dev = comedi_dev_get(comedi_board_minor_table[minor]);
+	mutex_unlock(&comedi_board_minor_table_lock);
+	return dev;
+}
+
+static struct comedi_device *comedi_dev_get_from_subdevice_minor(unsigned minor)
+{
+	struct comedi_device *dev;
+	struct comedi_subdevice *s;
+	unsigned int i = minor - COMEDI_NUM_BOARD_MINORS;
+
+	BUG_ON(i >= COMEDI_NUM_SUBDEVICE_MINORS);
+	mutex_lock(&comedi_subdevice_minor_table_lock);
+	s = comedi_subdevice_minor_table[i];
+	dev = comedi_dev_get(s ? s->device : NULL);
+	mutex_unlock(&comedi_subdevice_minor_table_lock);
+	return dev;
+}
+
+struct comedi_device *comedi_dev_get_from_minor(unsigned minor)
+{
+	if (minor < COMEDI_NUM_BOARD_MINORS)
+		return comedi_dev_get_from_board_minor(minor);
+	else
+		return comedi_dev_get_from_subdevice_minor(minor);
+}
+EXPORT_SYMBOL_GPL(comedi_dev_get_from_minor);
+
 static struct comedi_subdevice *
 comedi_read_subdevice(const struct comedi_device *dev, unsigned int minor)
 {

commit 5b13ed94a7d24fdc8abbac81e7e4d30ab22c6540
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:32 2013 +0000

    staging: comedi: add a kref to comedi device
    
    Add a `struct kref refcount` member to `struct comedi_device` to allow
    safe destruction of the comedi device.  Only free the comedi device via
    the 'release' callback `kref_put()`.  Currently, nothing calls
    `kref_put()`, so the safe destruction is ineffective, but this will be
    addressed by later patches.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index fa8da20df753..403324c895b1 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -89,12 +89,29 @@ static struct cdev comedi_cdev;
 
 static void comedi_device_init(struct comedi_device *dev)
 {
+	kref_init(&dev->refcount);
 	spin_lock_init(&dev->spinlock);
 	mutex_init(&dev->mutex);
 	init_rwsem(&dev->attach_lock);
 	dev->minor = -1;
 }
 
+static void comedi_dev_kref_release(struct kref *kref)
+{
+	struct comedi_device *dev =
+		container_of(kref, struct comedi_device, refcount);
+
+	mutex_destroy(&dev->mutex);
+	kfree(dev);
+}
+
+int comedi_dev_put(struct comedi_device *dev)
+{
+	if (dev)
+		return kref_put(&dev->refcount, comedi_dev_kref_release);
+	return 1;
+}
+
 static void comedi_device_cleanup(struct comedi_device *dev)
 {
 	struct module *driver_module = NULL;
@@ -112,7 +129,6 @@ static void comedi_device_cleanup(struct comedi_device *dev)
 		dev->use_count--;
 	}
 	mutex_unlock(&dev->mutex);
-	mutex_destroy(&dev->mutex);
 }
 
 static bool comedi_clear_board_dev(struct comedi_device *dev)
@@ -148,7 +164,7 @@ static void comedi_free_board_dev(struct comedi_device *dev)
 				       MKDEV(COMEDI_MAJOR, dev->minor));
 		}
 		comedi_device_cleanup(dev);
-		kfree(dev);
+		comedi_dev_put(dev);
 	}
 }
 
@@ -2494,7 +2510,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	if (i == COMEDI_NUM_BOARD_MINORS) {
 		mutex_unlock(&dev->mutex);
 		comedi_device_cleanup(dev);
-		kfree(dev);
+		comedi_dev_put(dev);
 		pr_err("comedi: error: ran out of minor numbers for board device files.\n");
 		return ERR_PTR(-EBUSY);
 	}

commit 45c2bc557ca333a2115bb9f812b026b482cca5fa
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:31 2013 +0000

    staging: comedi: protect against detach during read operation
    
    The 'read' file operation for comedi devices does not use the main mutex
    in the `struct comedi_device` to avoid contention with some ioctls that
    may take a while to complete.  Use the `attach_lock` semaphore to
    protect against detachment while the 'read' operation is in progress.
    This is a `struct rw_semaphore` and we read-lock it to protect against
    device detachment.
    
    Note that `comedi_device_cancel_all()` is called during device
    detachment, which cancels any ongoing asynchronous commands.  This will
    wake up any blocked readers which will then release the `attach_lock`
    semaphore and complete the 'read' operation early.
    
    The only time the 'read' file operation does use the main mutex is at
    the end of the command when it has to call `do_become_nonbusy()` to mark
    the subdevice as no longer busy handling an asynchronous command.  To
    avoid deadlock, it has to remove the task from the wait queue and
    release the `attach_lock` semaphore before acquiring the main mutex.  It
    then needs to confirm the device is still attached.  Unfortunately, we
    do not yet protect against a dynamically allocated `struct
    comedi_device` being deleted during the operation.  This will be
    addressed by a later patch.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1ae2bdf08646..fa8da20df753 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2162,24 +2162,37 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file_inode(file));
 	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	unsigned int old_detach_count;
+	bool become_nonbusy = false;
+	bool attach_locked;
 
 	if (!dev)
 		return -ENODEV;
 
+	/* Protect against device detachment during operation. */
+	down_read(&dev->attach_lock);
+	attach_locked = true;
+	old_detach_count = dev->detach_count;
+
 	if (!dev->attached) {
 		DPRINTK("no driver configured on comedi%i\n", dev->minor);
-		return -ENODEV;
+		retval = -ENODEV;
+		goto out;
 	}
 
 	s = comedi_read_subdevice(dev, minor);
-	if (!s || !s->async)
-		return -EIO;
+	if (!s || !s->async) {
+		retval = -EIO;
+		goto out;
+	}
 
 	async = s->async;
 	if (!s->busy || !nbytes)
-		return 0;
-	if (s->busy != file)
-		return -EACCES;
+		goto out;
+	if (s->busy != file) {
+		retval = -EACCES;
+		goto out;
+	}
 
 	add_wait_queue(&async->wait_head, &wait);
 	while (nbytes > 0 && !retval) {
@@ -2197,13 +2210,11 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 
 		if (n == 0) {
 			if (!comedi_is_subdevice_running(s)) {
-				mutex_lock(&dev->mutex);
-				do_become_nonbusy(dev, s);
 				if (comedi_is_subdevice_in_error(s))
 					retval = -EPIPE;
 				else
 					retval = 0;
-				mutex_unlock(&dev->mutex);
+				become_nonbusy = true;
 				break;
 			}
 			if (file->f_flags & O_NONBLOCK) {
@@ -2241,14 +2252,37 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		buf += n;
 		break;		/* makes device work like a pipe */
 	}
-	if (comedi_is_subdevice_idle(s)) {
+	remove_wait_queue(&async->wait_head, &wait);
+	set_current_state(TASK_RUNNING);
+	if (become_nonbusy || comedi_is_subdevice_idle(s)) {
+		struct comedi_subdevice *new_s;
+
+		/*
+		 * To avoid deadlock, cannot acquire dev->mutex
+		 * while dev->attach_lock is held.
+		 */
+		up_read(&dev->attach_lock);
+		attach_locked = false;
 		mutex_lock(&dev->mutex);
-		if (async->buf_read_count - async->buf_write_count == 0)
-			do_become_nonbusy(dev, s);
+		/*
+		 * Check device hasn't become detached behind our back.
+		 * Checking dev->detach_count is unchanged ought to be
+		 * sufficient (unless there have been 2**32 detaches in the
+		 * meantime!), but check the subdevice pointer as well just in
+		 * case.
+		 */
+		new_s = comedi_read_subdevice(dev, minor);
+		if (dev->attached && old_detach_count == dev->detach_count &&
+		    s == new_s && new_s->async == async) {
+			if (become_nonbusy ||
+			    async->buf_read_count - async->buf_write_count == 0)
+				do_become_nonbusy(dev, s);
+		}
 		mutex_unlock(&dev->mutex);
 	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&async->wait_head, &wait);
+out:
+	if (attach_locked)
+		up_read(&dev->attach_lock);
 
 	return count ? count : retval;
 }

commit 9329f13956bb8e43c254e7137386dce0b35f24b6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:30 2013 +0000

    staging: comedi: protect against detach during write operation
    
    The 'write' file operation for comedi devices does not use the main
    mutex in the `struct comedi_device` to avoid contention with some ioctls
    that may take a while to complete.  Use the `attach_lock` semaphore to
    protect against detachment while the 'write' operation is in progress.
    This is a `struct rw_semaphore` and we read-lock it to protect against
    device detachment.
    
    Note that `comedi_device_cancel_all()` is called during device
    detachment, which cancels any ongoing asynchronous commands.  This will
    wake up any blocked writers which will then release the `attach_lock`
    semaphore and complete the 'write' operation early.
    
    The only time the 'write' file operation does use the main mutex is at
    the end of the command when it has to call `do_become_nonbusy()` to mark
    the subdevice as no longer busy handling an asynchronous command.  To
    avoid deadlock, it has to remove the task from the wait queue and
    release the `attach_lock` semaphore before acquiring the main mutex.  It
    then needs to confirm that the device is still attached.  Unfortunately,
    we do not yet protect against a dynamically allocated `struct
    comedi_device` being deleted during the operation.  This will be
    addressed by a later patch.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index eafa18efdeea..1ae2bdf08646 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2023,38 +2023,77 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file_inode(file));
 	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	bool on_wait_queue = false;
+	bool attach_locked;
+	unsigned int old_detach_count;
 
 	if (!dev)
 		return -ENODEV;
 
+	/* Protect against device detachment during operation. */
+	down_read(&dev->attach_lock);
+	attach_locked = true;
+	old_detach_count = dev->detach_count;
+
 	if (!dev->attached) {
 		DPRINTK("no driver configured on comedi%i\n", dev->minor);
-		return -ENODEV;
+		retval = -ENODEV;
+		goto out;
 	}
 
 	s = comedi_write_subdevice(dev, minor);
-	if (!s || !s->async)
-		return -EIO;
+	if (!s || !s->async) {
+		retval = -EIO;
+		goto out;
+	}
 
 	async = s->async;
 
 	if (!s->busy || !nbytes)
-		return 0;
-	if (s->busy != file)
-		return -EACCES;
+		goto out;
+	if (s->busy != file) {
+		retval = -EACCES;
+		goto out;
+	}
 
 	add_wait_queue(&async->wait_head, &wait);
+	on_wait_queue = true;
 	while (nbytes > 0 && !retval) {
 		set_current_state(TASK_INTERRUPTIBLE);
 
 		if (!comedi_is_subdevice_running(s)) {
 			if (count == 0) {
-				mutex_lock(&dev->mutex);
+				struct comedi_subdevice *new_s;
+
 				if (comedi_is_subdevice_in_error(s))
 					retval = -EPIPE;
 				else
 					retval = 0;
-				do_become_nonbusy(dev, s);
+				/*
+				 * To avoid deadlock, cannot acquire dev->mutex
+				 * while dev->attach_lock is held.  Need to
+				 * remove task from the async wait queue before
+				 * releasing dev->attach_lock, as it might not
+				 * be valid afterwards.
+				 */
+				remove_wait_queue(&async->wait_head, &wait);
+				on_wait_queue = false;
+				up_read(&dev->attach_lock);
+				attach_locked = false;
+				mutex_lock(&dev->mutex);
+				/*
+				 * Become non-busy unless things have changed
+				 * behind our back.  Checking dev->detach_count
+				 * is unchanged ought to be sufficient (unless
+				 * there have been 2**32 detaches in the
+				 * meantime!), but check the subdevice pointer
+				 * as well just in case.
+				 */
+				new_s = comedi_write_subdevice(dev, minor);
+				if (dev->attached &&
+				    old_detach_count == dev->detach_count &&
+				    s == new_s && new_s->async == async)
+					do_become_nonbusy(dev, s);
 				mutex_unlock(&dev->mutex);
 			}
 			break;
@@ -2104,8 +2143,12 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 		buf += n;
 		break;		/* makes device work like a pipe */
 	}
+out:
+	if (on_wait_queue)
+		remove_wait_queue(&async->wait_head, &wait);
 	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&async->wait_head, &wait);
+	if (attach_locked)
+		up_read(&dev->attach_lock);
 
 	return count ? count : retval;
 }

commit d19db51a0eeb659cd924a9d08b20a2ed4ee46b15
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:28 2013 +0000

    staging: comedi: cancel commands before detaching device
    
    The comedi core module's handling of the `COMEDI_DEVCONFIG` ioctl will
    not allow a device to be detached if it is busy.  However, comedi
    devices can also be auto-detached due to a removal of a hardware device.
    One of the things we should do in that case is cancel any asynchronous
    commands that are running.  Add a new function
    `comedi_device_cancel_all()` to do that and call it from
    `comedi_device_detach()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 9c85f01e847b..eafa18efdeea 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -584,6 +584,21 @@ static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return ret;
 }
 
+void comedi_device_cancel_all(struct comedi_device *dev)
+{
+	struct comedi_subdevice *s;
+	int i;
+
+	if (!dev->attached)
+		return;
+
+	for (i = 0; i < dev->n_subdevices; i++) {
+		s = &dev->subdevices[i];
+		if (s->async)
+			do_cancel(dev, s);
+	}
+}
+
 static int is_device_busy(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s;

commit 8da8c86f52e5487adfa2e3bae4d539e46f2714dd
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:27 2013 +0000

    staging: comedi: wake up async waiters when become non-busy
    
    Wake up all waiters on the comedi subdevice's async wait queue whenever
    the subdevice is marked "non-busy".  This happens when an asynchronous
    command is cancelled or when a command is terminated and all data has
    been read or written.  Note: use `wake_up_interruptible_all()` as we
    only use interruptible waits.
    
    Remove the call to `wake_up_interruptible()` from `do_cancel_ioctl()` as
    it will call `wake_up_interruptible_all()` indirectly via `do_cancel()`
    and `do_become_nonbusy()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a1705ed0b844..9c85f01e847b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -563,12 +563,13 @@ static void do_become_nonbusy(struct comedi_device *dev,
 		async->inttrig = NULL;
 		kfree(async->cmd.chanlist);
 		async->cmd.chanlist = NULL;
+		s->busy = NULL;
+		wake_up_interruptible_all(&s->async->wait_head);
 	} else {
 		dev_err(dev->class_dev,
 			"BUG: (?) do_become_nonbusy called with async=NULL\n");
+		s->busy = NULL;
 	}
-
-	s->busy = NULL;
 }
 
 static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -1700,7 +1701,6 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
 		return -EBUSY;
 
 	ret = do_cancel(dev, s);
-	wake_up_interruptible(&s->async->wait_head);
 
 	return ret;
 }

commit 2f3fdcd7ce935f6f2899ceab57dc8fe5286db3e1
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:24 2013 +0000

    staging: comedi: add rw_semaphore to protect against device detachment
    
    The 'read' and 'write' file operations on comedi devices do not use the
    main mutex in the `struct comedi_device` to avoid contention with ioctls
    that may take a while to complete.  However, it is necessary to protect
    against the device being detached while the operation is in progress.
    Add member `struct rw_semaphore attach_lock` to `struct comedi_device`
    for this purpose and initialize it on creation.
    
    The actual locking and unlocking will be implemented by subsequent
    patches.  Tasks that are attaching or detaching comedi devices will
    write-acquire the new semaphore whilst also holding the main mutex in
    the `struct comedi_device`.  Tasks that wish to protect against the
    comedi device being detached need to acquire either the main mutex, or
    read-acquire the new semaphore, or both in that order.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 0d8565428abb..a1705ed0b844 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -91,6 +91,7 @@ static void comedi_device_init(struct comedi_device *dev)
 {
 	spin_lock_init(&dev->spinlock);
 	mutex_init(&dev->mutex);
+	init_rwsem(&dev->attach_lock);
 	dev->minor = -1;
 }
 

commit c265be0121154709a0b16f13c87ff58245ba81bc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:22 2013 +0000

    staging: comedi: remove unused command callback support
    
    The 'kcomedilib' module used to provide functions to allow asynchronous
    comedi commands to be set up from another kernel module, but now
    commands can only be set up by ioctls from user space via the core
    comedi module.  Since support for commands initiated from kernel space
    has been dropped, the `cb_func` and `cb_arg` members of `struct
    comedi_async` are never set (although the `cb_mask` member is still used
    to mask comedi events).  The `SRF_USER` bit of the comedi subdevice
    runflags is no longer needed to distinguish commands from user and
    kernel space since they only come from user space.
    
    Don't bother setting or testing the `SRF_USER` flag, and get rid of it,
    along with the `cb_func` and `cb_arg` members.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f3d59e2a1152..0d8565428abb 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1469,8 +1469,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	if (async->cmd.flags & TRIG_WAKE_EOS)
 		async->cb_mask |= COMEDI_CB_EOS;
 
-	comedi_set_subdevice_runflags(s, SRF_USER | SRF_ERROR | SRF_RUNNING,
-				      SRF_USER | SRF_RUNNING);
+	comedi_set_subdevice_runflags(s, SRF_ERROR | SRF_RUNNING, SRF_RUNNING);
 
 	/* set s->busy _after_ setting SRF_RUNNING flag to avoid race with
 	 * comedi_read() or comedi_write() */
@@ -1700,8 +1699,7 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
 		return -EBUSY;
 
 	ret = do_cancel(dev, s);
-	if (comedi_get_subdevice_runflags(s) & SRF_USER)
-		wake_up_interruptible(&s->async->wait_head);
+	wake_up_interruptible(&s->async->wait_head);
 
 	return ret;
 }
@@ -2368,16 +2366,11 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	if (async->cb_mask & s->async->events) {
-		if (comedi_get_subdevice_runflags(s) & SRF_USER) {
-			wake_up_interruptible(&async->wait_head);
-			if (s->subdev_flags & SDF_CMD_READ)
-				kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
-			if (s->subdev_flags & SDF_CMD_WRITE)
-				kill_fasync(&dev->async_queue, SIGIO, POLL_OUT);
-		} else {
-			if (async->cb_func)
-				async->cb_func(s->async->events, async->cb_arg);
-		}
+		wake_up_interruptible(&async->wait_head);
+		if (s->subdev_flags & SDF_CMD_READ)
+			kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
+		if (s->subdev_flags & SDF_CMD_WRITE)
+			kill_fasync(&dev->async_queue, SIGIO, POLL_OUT);
 	}
 	s->async->events = 0;
 }

commit f0c80e4e1cd00dfaff98be961bcf28f504d628dc
Author: Teodora Baluta <teobaluta@gmail.com>
Date:   Tue Oct 29 00:09:18 2013 +0200

    staging: comedi: use memdup_user to simplify code
    
    Use memdup_user rather than duplicating implementation. Fix following
    coccinelle warnings:
    
    drivers/staging/comedi/comedi_fops.c:1425:5-12: WARNING opportunity for memdup_user
    drivers/staging/comedi/comedi_fops.c:1553:6-13: WARNING opportunity for memdup_user
    
    Signed-off-by: Teodora Baluta <teobaluta@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 721df313f8df..f3d59e2a1152 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1421,17 +1421,11 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	async->cmd = cmd;
 	async->cmd.data = NULL;
 	/* load channel/gain list */
-	async->cmd.chanlist =
-	    kmalloc(async->cmd.chanlist_len * sizeof(int), GFP_KERNEL);
-	if (!async->cmd.chanlist) {
-		DPRINTK("allocation failed\n");
-		return -ENOMEM;
-	}
-
-	if (copy_from_user(async->cmd.chanlist, user_chanlist,
-			   async->cmd.chanlist_len * sizeof(int))) {
-		DPRINTK("fault reading chanlist\n");
-		ret = -EFAULT;
+	async->cmd.chanlist = memdup_user(user_chanlist,
+					  async->cmd.chanlist_len * sizeof(int));
+	if (IS_ERR(async->cmd.chanlist)) {
+		ret = PTR_ERR(async->cmd.chanlist);
+		DPRINTK("memdup_user failed with code %d\n", ret);
 		goto cleanup;
 	}
 
@@ -1549,18 +1543,11 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 
 	/* load channel/gain list */
 	if (cmd.chanlist) {
-		chanlist =
-		    kmalloc(cmd.chanlist_len * sizeof(int), GFP_KERNEL);
-		if (!chanlist) {
-			DPRINTK("allocation failed\n");
-			ret = -ENOMEM;
-			goto cleanup;
-		}
-
-		if (copy_from_user(chanlist, user_chanlist,
-				   cmd.chanlist_len * sizeof(int))) {
-			DPRINTK("fault reading chanlist\n");
-			ret = -EFAULT;
+		chanlist = memdup_user(user_chanlist,
+				       cmd.chanlist_len * sizeof(int));
+		if (IS_ERR(chanlist)) {
+			ret = PTR_ERR(chanlist);
+			DPRINTK("memdup_user exited with code %d", ret);
 			goto cleanup;
 		}
 

commit 67aa4acbc97f6a55b328e4e2305ef19cbe949d85
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 7 15:51:58 2013 +0100

    staging: comedi: avoid memleak for subdevice private
    
    `comedi_alloc_spriv()` allocates private storage for a comedi subdevice
    and sets the `SRF_FREE_SPRIV` flag in the `runflags` member of the
    subdevice to allow the private storage to be automatically freed when
    the comedi device is being cleaned up.  Unfortunately, the flag gets
    clobbered by `do_cmd_ioctl()` which calls
    `comedi_set_subdevice_runflags()` with a mask value `~0` and only the
    `SRF_USER` and `SRF_RUNNING` flags set, all the other SRF flags being
    cleared.
    
    Change the calls to `comedi_set_subdevice_runflags()` that currently use
    a mask value of `~0` to use a more relevant mask value.  For
    `do_cmd_ioctl()`, the relevant SRF flags are `SRF_USER`, `SRF_ERROR` and
    `SRF_RUNNING`.  (At one time, `SRF_RT` would be included in that set of
    flags, but it is no longer used.)  For `comedi_alloc_spriv()` replace
    the call to `comedi_set_subdevice_runflags()` with a simple
    OR-assignment to avoid unnecessary use of a spin-lock.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: <stable@vger.kernel.org> # 3.11.y
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 3594bd49bf0d..721df313f8df 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -543,7 +543,7 @@ void *comedi_alloc_spriv(struct comedi_subdevice *s, size_t size)
 {
 	s->private = kzalloc(size, GFP_KERNEL);
 	if (s->private)
-		comedi_set_subdevice_runflags(s, ~0, SRF_FREE_SPRIV);
+		s->runflags |= SRF_FREE_SPRIV;
 	return s->private;
 }
 EXPORT_SYMBOL_GPL(comedi_alloc_spriv);
@@ -1475,7 +1475,8 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	if (async->cmd.flags & TRIG_WAKE_EOS)
 		async->cb_mask |= COMEDI_CB_EOS;
 
-	comedi_set_subdevice_runflags(s, ~0, SRF_USER | SRF_RUNNING);
+	comedi_set_subdevice_runflags(s, SRF_USER | SRF_ERROR | SRF_RUNNING,
+				      SRF_USER | SRF_RUNNING);
 
 	/* set s->busy _after_ setting SRF_RUNNING flag to avoid race with
 	 * comedi_read() or comedi_write() */

commit cd94d281e9fa804c42a4e1b61f4430dbbf4cea18
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 7 16:50:06 2013 +0100

    staging: comedi: remove 'settling_time_0' from subdevice
    
    The `settling_time_0` member of `struct comedi_subdevice` can be set by
    a low-level comedi driver and will be copied to user-space as part of
    the information provided by the `COMEDI_SUBDINFO` ioctl.  No comedi
    driver has ever set it; it's just been left at its initial value of 0.
    Remove it to save a bit of space, and behave as though it is 0.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ff0e46d513ec..3594bd49bf0d 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -826,8 +826,6 @@ static int do_subdinfo_ioctl(struct comedi_device *dev,
 			us->insn_bits_support = COMEDI_SUPPORTED;
 		else
 			us->insn_bits_support = COMEDI_UNSUPPORTED;
-
-		us->settling_time_0 = s->settling_time_0;
 	}
 
 	ret = copy_to_user(arg, tmp, dev->n_subdevices * sizeof(*tmp));

commit 64d9b1d293fef4854a759ad946c2b99a20cc197b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 7 16:50:05 2013 +0100

    staging: comedi: remove unused 'channel flags' support
    
    The `flags` and `flaglist` members of `struct comedi_subdevice` were
    defined to supply "all-channel" flags via the `COMEDI_SUBDINFO` ioctl,
    or "channel-specific" flags via the `COMEDI_CHANINFO` ioctls,
    respectively.  However, no comedi driver has ever set them.
    
    It's not entirely clear how "all-channel" flags would differ from the
    "subdevice" flags passed by `COMEDI_SUBDINFO`.  It is conceivable that
    "channel-specific" flags could be used to describe different analog
    reference values (or whatever) supported by different channels.
    Presumably these would use some sub-set of the `SDF_xxx` subdevice flag
    values, or possibly the `CR_xxx` flag values that get packed into a
    "chanspec" value (along with a channel number and range code).  The
    original intentions are lost in the mists of time.
    
    For now, just remove the `flags` and `flaglist` members from `struct
    comedi_subdevice` and behave as though they have been left at their
    default values (0 or NULL) by the low-level comedi driver.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1636c7ca57e2..ff0e46d513ec 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -806,7 +806,6 @@ static int do_subdinfo_ioctl(struct comedi_device *dev,
 		} else {
 			us->range_type = 0;	/* XXX */
 		}
-		us->flags = s->flags;
 
 		if (s->busy)
 			us->subd_flags |= SDF_BUSY;
@@ -818,8 +817,6 @@ static int do_subdinfo_ioctl(struct comedi_device *dev,
 			us->subd_flags |= SDF_LOCK_OWNER;
 		if (!s->maxdata && s->maxdata_list)
 			us->subd_flags |= SDF_MAXDATA;
-		if (s->flaglist)
-			us->subd_flags |= SDF_FLAGS;
 		if (s->range_table_list)
 			us->subd_flags |= SDF_RANGETYPE;
 		if (s->do_cmd)
@@ -875,13 +872,8 @@ static int do_chaninfo_ioctl(struct comedi_device *dev,
 			return -EFAULT;
 	}
 
-	if (it.flaglist) {
-		if (!s->flaglist)
-			return -EINVAL;
-		if (copy_to_user(it.flaglist, s->flaglist,
-				 s->n_chan * sizeof(unsigned int)))
-			return -EFAULT;
-	}
+	if (it.flaglist)
+		return -EINVAL;	/* flaglist not supported */
 
 	if (it.rangelist) {
 		int i;

commit 751144271f4b63d5de9005ea4e5e6e5c7c6fd629
Merge: 542a086ac72f 91121c103ae9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 3 11:37:57 2013 -0700

    Merge tag 'staging-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging tree merge from Greg KH:
     "Here's the bit staging tree pull request for 3.12-rc1.
    
      Lots of staging driver updates, and fixes.  Lustre is finally enabled
      in the build, and lots of cleanup started happening in it.  There's a
      new wireless driver in here, and 2 new TTY drivers, which cause the
      overall lines added/removed to be quite large on the "added" side.
    
      The IIO driver updates are also coming through here, as they are tied
      to the staging iio drivers"
    
    * tag 'staging-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (942 commits)
      staging: dwc2: make dwc2_core_params documentation more complete
      staging: dwc2: validate the value for phy_utmi_width
      staging: dwc2: interpret all hwcfg and related register at init time
      staging: dwc2: properly mask the GRXFSIZ register
      staging: dwc2: remove redundant register reads
      staging: dwc2: re-use hptxfsiz variable
      staging: dwc2: simplify debug output in dwc_hc_init
      staging: dwc2: add missing shift
      staging: dwc2: simplify register shift expressions
      staging: dwc2: only read the snpsid register once
      staging: dwc2: unshift non-bool register value constants
      staging: dwc2: fix off-by-one in check for max_packet_count parameter
      staging: dwc2: remove specific fifo size constants
      Staging:BCM:DDRInit.c:Renaming __FUNCTION__
      staging: bcm: remove Version.h file.
      staging: rtl8188eu: off by one in rtw_set_802_11_add_wep()
      staging: r8188eu: copying one byte too much
      staging: rtl8188eu: || vs && typo
      staging: r8188eu: off by one bugs
      staging: crystalhd: Resolve sparse 'different base types' warnings.
      ...

commit b78b6b3a9af239549ea863e085223d1d4f65a608
Merge: 7f4708abf16a 5ae90d8e467e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 29 12:30:13 2013 -0700

    Merge 3.11-rc3 into driver-core-next
    
    We want these fixes in this branch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 01731cf2eee38410b505c447026e46a591674835
Merge: 6496c045292b 5ae90d8e467e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 29 07:40:10 2013 -0700

    Merge 3.11-rc3 into staging-next
    
    We want these fixes here.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e56341ad380114454119ac043e6d710ddbbb7710
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 24 15:05:25 2013 -0700

    staging: comedi: convert class code to use dev_groups
    
    The dev_attrs field of struct class is going away soon, dev_groups
    should be used instead.  This converts the comedi class code to use the
    correct field.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 8647518259f6..2f2ff8f08783 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -262,7 +262,7 @@ static int resize_async_buffer(struct comedi_device *dev,
 
 /* sysfs attribute files */
 
-static ssize_t show_max_read_buffer_kb(struct device *csdev,
+static ssize_t max_read_buffer_kb_show(struct device *csdev,
 				       struct device_attribute *attr, char *buf)
 {
 	unsigned int minor = MINOR(csdev->devt);
@@ -283,7 +283,7 @@ static ssize_t show_max_read_buffer_kb(struct device *csdev,
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
-static ssize_t store_max_read_buffer_kb(struct device *csdev,
+static ssize_t max_read_buffer_kb_store(struct device *csdev,
 					struct device_attribute *attr,
 					const char *buf, size_t count)
 {
@@ -314,8 +314,9 @@ static ssize_t store_max_read_buffer_kb(struct device *csdev,
 
 	return err ? err : count;
 }
+static DEVICE_ATTR_RW(max_read_buffer_kb);
 
-static ssize_t show_read_buffer_kb(struct device *csdev,
+static ssize_t read_buffer_kb_show(struct device *csdev,
 				   struct device_attribute *attr, char *buf)
 {
 	unsigned int minor = MINOR(csdev->devt);
@@ -336,7 +337,7 @@ static ssize_t show_read_buffer_kb(struct device *csdev,
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
-static ssize_t store_read_buffer_kb(struct device *csdev,
+static ssize_t read_buffer_kb_store(struct device *csdev,
 				    struct device_attribute *attr,
 				    const char *buf, size_t count)
 {
@@ -367,8 +368,9 @@ static ssize_t store_read_buffer_kb(struct device *csdev,
 
 	return err ? err : count;
 }
+static DEVICE_ATTR_RW(read_buffer_kb);
 
-static ssize_t show_max_write_buffer_kb(struct device *csdev,
+static ssize_t max_write_buffer_kb_show(struct device *csdev,
 					struct device_attribute *attr,
 					char *buf)
 {
@@ -390,7 +392,7 @@ static ssize_t show_max_write_buffer_kb(struct device *csdev,
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
-static ssize_t store_max_write_buffer_kb(struct device *csdev,
+static ssize_t max_write_buffer_kb_store(struct device *csdev,
 					 struct device_attribute *attr,
 					 const char *buf, size_t count)
 {
@@ -421,8 +423,9 @@ static ssize_t store_max_write_buffer_kb(struct device *csdev,
 
 	return err ? err : count;
 }
+static DEVICE_ATTR_RW(max_write_buffer_kb);
 
-static ssize_t show_write_buffer_kb(struct device *csdev,
+static ssize_t write_buffer_kb_show(struct device *csdev,
 				    struct device_attribute *attr, char *buf)
 {
 	unsigned int minor = MINOR(csdev->devt);
@@ -443,7 +446,7 @@ static ssize_t show_write_buffer_kb(struct device *csdev,
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
-static ssize_t store_write_buffer_kb(struct device *csdev,
+static ssize_t write_buffer_kb_store(struct device *csdev,
 				     struct device_attribute *attr,
 				     const char *buf, size_t count)
 {
@@ -474,18 +477,16 @@ static ssize_t store_write_buffer_kb(struct device *csdev,
 
 	return err ? err : count;
 }
+static DEVICE_ATTR_RW(write_buffer_kb);
 
-static struct device_attribute comedi_dev_attrs[] = {
-	__ATTR(max_read_buffer_kb, S_IRUGO | S_IWUSR,
-		show_max_read_buffer_kb, store_max_read_buffer_kb),
-	__ATTR(read_buffer_kb, S_IRUGO | S_IWUSR | S_IWGRP,
-		show_read_buffer_kb, store_read_buffer_kb),
-	__ATTR(max_write_buffer_kb, S_IRUGO | S_IWUSR,
-		show_max_write_buffer_kb, store_max_write_buffer_kb),
-	__ATTR(write_buffer_kb, S_IRUGO | S_IWUSR | S_IWGRP,
-		show_write_buffer_kb, store_write_buffer_kb),
-	__ATTR_NULL
+static struct attribute *comedi_dev_attrs[] = {
+	&dev_attr_max_read_buffer_kb.attr,
+	&dev_attr_read_buffer_kb.attr,
+	&dev_attr_max_write_buffer_kb.attr,
+	&dev_attr_write_buffer_kb.attr,
+	NULL,
 };
+ATTRIBUTE_GROUPS(comedi_dev);
 
 static void comedi_set_subdevice_runflags(struct comedi_subdevice *s,
 					  unsigned mask, unsigned bits)
@@ -2554,7 +2555,7 @@ static int __init comedi_init(void)
 		return PTR_ERR(comedi_class);
 	}
 
-	comedi_class->dev_attrs = comedi_dev_attrs;
+	comedi_class->dev_groups = comedi_dev_groups;
 
 	/* XXX requires /proc interface */
 	comedi_proc_init();

commit 4b18f08be01a7b3c7b6df497137b6e3cb28adaa3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jul 5 16:49:34 2013 +0100

    staging: comedi: fix a race between do_cmd_ioctl() and read/write
    
    `do_cmd_ioctl()` is called with the comedi device's mutex locked to
    process the `COMEDI_CMD` ioctl to set up comedi's asynchronous command
    handling on a comedi subdevice.  `comedi_read()` and `comedi_write()`
    are the `read` and `write` handlers for the comedi device, but do not
    lock the mutex (for performance reasons, as some things can hold the
    mutex for quite a long time).
    
    There is a race condition if `comedi_read()` or `comedi_write()` is
    running at the same time and for the same file object and comedi
    subdevice as `do_cmd_ioctl()`.  `do_cmd_ioctl()` sets the subdevice's
    `busy` pointer to the file object way before it sets the `SRF_RUNNING` flag
    in the subdevice's `runflags` member.  `comedi_read() and
    `comedi_write()` check the subdevice's `busy` pointer is pointing to the
    current file object, then if the `SRF_RUNNING` flag is not set, will call
    `do_become_nonbusy()` to shut down the asyncronous command.  Bad things
    can happen if the asynchronous command is being shutdown and set up at
    the same time.
    
    To prevent the race, don't set the `busy` pointer until
    after the `SRF_RUNNING` flag has been set.  Also, make sure the mutex is
    held in `comedi_read()` and `comedi_write()` while calling
    `do_become_nonbusy()` in order to avoid moving the race condition to a
    point within that function.
    
    Change some error handling `goto cleanup` statements in `do_cmd_ioctl()`
    to simple `return -ERRFOO` statements as a result of changing when the
    `busy` pointer is set.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 6cdef9d5f8d0..f4a197b2d1fd 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1413,22 +1413,19 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 		DPRINTK("subdevice busy\n");
 		return -EBUSY;
 	}
-	s->busy = file;
 
 	/* make sure channel/gain list isn't too long */
 	if (cmd.chanlist_len > s->len_chanlist) {
 		DPRINTK("channel/gain list too long %u > %d\n",
 			cmd.chanlist_len, s->len_chanlist);
-		ret = -EINVAL;
-		goto cleanup;
+		return -EINVAL;
 	}
 
 	/* make sure channel/gain list isn't too short */
 	if (cmd.chanlist_len < 1) {
 		DPRINTK("channel/gain list too short %u < 1\n",
 			cmd.chanlist_len);
-		ret = -EINVAL;
-		goto cleanup;
+		return -EINVAL;
 	}
 
 	async->cmd = cmd;
@@ -1438,8 +1435,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	    kmalloc(async->cmd.chanlist_len * sizeof(int), GFP_KERNEL);
 	if (!async->cmd.chanlist) {
 		DPRINTK("allocation failed\n");
-		ret = -ENOMEM;
-		goto cleanup;
+		return -ENOMEM;
 	}
 
 	if (copy_from_user(async->cmd.chanlist, user_chanlist,
@@ -1491,6 +1487,9 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 
 	comedi_set_subdevice_runflags(s, ~0, SRF_USER | SRF_RUNNING);
 
+	/* set s->busy _after_ setting SRF_RUNNING flag to avoid race with
+	 * comedi_read() or comedi_write() */
+	s->busy = file;
 	ret = s->do_cmd(dev, s);
 	if (ret == 0)
 		return 0;
@@ -2058,11 +2057,13 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 
 		if (!comedi_is_subdevice_running(s)) {
 			if (count == 0) {
+				mutex_lock(&dev->mutex);
 				if (comedi_is_subdevice_in_error(s))
 					retval = -EPIPE;
 				else
 					retval = 0;
 				do_become_nonbusy(dev, s);
+				mutex_unlock(&dev->mutex);
 			}
 			break;
 		}
@@ -2161,11 +2162,13 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 
 		if (n == 0) {
 			if (!comedi_is_subdevice_running(s)) {
+				mutex_lock(&dev->mutex);
 				do_become_nonbusy(dev, s);
 				if (comedi_is_subdevice_in_error(s))
 					retval = -EPIPE;
 				else
 					retval = 0;
+				mutex_unlock(&dev->mutex);
 				break;
 			}
 			if (file->f_flags & O_NONBLOCK) {
@@ -2203,9 +2206,11 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		buf += n;
 		break;		/* makes device work like a pipe */
 	}
-	if (comedi_is_subdevice_idle(s) &&
-	    async->buf_read_count - async->buf_write_count == 0) {
-		do_become_nonbusy(dev, s);
+	if (comedi_is_subdevice_idle(s)) {
+		mutex_lock(&dev->mutex);
+		if (async->buf_read_count - async->buf_write_count == 0)
+			do_become_nonbusy(dev, s);
+		mutex_unlock(&dev->mutex);
 	}
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(&async->wait_head, &wait);

commit 69acbaac303e8cb948801a9ddd0ac24e86cc4a1b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jul 8 13:36:19 2013 +0100

    staging: comedi: COMEDI_CANCEL ioctl should wake up read/write
    
    Comedi devices can do blocking read() or write() (or poll()) if an
    asynchronous command has been set up, blocking for data (for read()) or
    buffer space (for write()).  Various events associated with the
    asynchronous command will wake up the blocked reader or writer (or
    poller).  It is also possible to force the asynchronous command to
    terminate by issuing a `COMEDI_CANCEL` ioctl.  That shuts down the
    asynchronous command, but does not currently wake up the blocked reader
    or writer (or poller).  If the blocked task could be woken up, it would
    see that the command is no longer active and return.  The caller of the
    `COMEDI_CANCEL` ioctl could attempt to wake up the blocked task by
    sending a signal, but that's a nasty workaround.
    
    Change `do_cancel_ioctl()` to wake up the wait queue after it returns
    from `do_cancel()`.  `do_cancel()` can propagate an error return value
    from the low-level comedi driver's cancel routine, but it always shuts
    the command down regardless, so `do_cancel_ioctl()` can wake up he wait
    queue regardless of the return value from `do_cancel()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 8647518259f6..6cdef9d5f8d0 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1705,6 +1705,7 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
 			   void *file)
 {
 	struct comedi_subdevice *s;
+	int ret;
 
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
@@ -1721,7 +1722,11 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
 	if (s->busy != file)
 		return -EBUSY;
 
-	return do_cancel(dev, s);
+	ret = do_cancel(dev, s);
+	if (comedi_get_subdevice_runflags(s) & SRF_USER)
+		wake_up_interruptible(&s->async->wait_head);
+
+	return ret;
 }
 
 /*

commit 8e6b7915a1da703617dca28c33e150141fcec9b0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:05:07 2013 -0700

    staging: comedi: drivers do not need <linux/ioport.h>
    
    All the ioport resources are managed by the comedi core. None of
    the drivers depend on <linux/ioport.h>. Remove the includes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 8647518259f6..ad275567c09a 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -26,7 +26,6 @@
 #include <linux/sched.h>
 #include <linux/fcntl.h>
 #include <linux/delay.h>
-#include <linux/ioport.h>
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/kmod.h>

commit 790eac5640abf7a57fa3a644386df330e18c11b0
Merge: 0b0585c3e192 48bde8d3620f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 09:10:19 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull second set of VFS changes from Al Viro:
     "Assorted f_pos race fixes, making do_splice_direct() safe to call with
      i_mutex on parent, O_TMPFILE support, Jeff's locks.c series,
      ->d_hash/->d_compare calling conventions changes from Linus, misc
      stuff all over the place."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (63 commits)
      Document ->tmpfile()
      ext4: ->tmpfile() support
      vfs: export lseek_execute() to modules
      lseek_execute() doesn't need an inode passed to it
      block_dev: switch to fixed_size_llseek()
      cpqphp_sysfs: switch to fixed_size_llseek()
      tile-srom: switch to fixed_size_llseek()
      proc_powerpc: switch to fixed_size_llseek()
      ubi/cdev: switch to fixed_size_llseek()
      pci/proc: switch to fixed_size_llseek()
      isapnp: switch to fixed_size_llseek()
      lpfc: switch to fixed_size_llseek()
      locks: give the blocked_hash its own spinlock
      locks: add a new "lm_owner_key" lock operation
      locks: turn the blocked_list into a hashtable
      locks: convert fl_link to a hlist_node
      locks: avoid taking global lock if possible when waking up blocked waiters
      locks: protect most of the file_lock handling with i_lock
      locks: encapsulate the fl_link list handling
      locks: make "added" in __posix_lock_file a bool
      ...

commit a44f52096c0b35214953124754dc034a889dc3b0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 16 19:05:07 2013 +0400

    comedi: quit wanking with FASYNC in ->release()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 924c54c9c31f..a9754e84eb8a 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2317,9 +2317,6 @@ static int comedi_close(struct inode *inode, struct file *file)
 
 	mutex_unlock(&dev->mutex);
 
-	if (file->f_flags & FASYNC)
-		comedi_fasync(-1, file, 0);
-
 	return 0;
 }
 

commit 0480bcb9fb5e279df9d39f21bb0e87ab15b5092a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jun 19 15:24:36 2013 -0700

    staging: comedi: have comedi_set_spriv() allocate the memory
    
    As suggested by Ian Abbott, comedi_set_spriv() can only be used to
    set the subdevice->private pointer to something that can be kfree()'d.
    Rename the function to comedi_alloc_spriv() and have it kzalloc() the
    memory as well as set the private pointer. This saves a function call
    in the drivers and avoids the possibility of incorrectly calling
    comedi_set_spriv() for some pointer that is not meant to be kfree()'d.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 423f882416d9..0794aacc928a 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -532,19 +532,21 @@ static bool comedi_is_subdevice_idle(struct comedi_subdevice *s)
 }
 
 /**
- * comedi_set_spriv() - Set the subdevice private data pointer.
+ * comedi_alloc_spriv() - Allocate memory for the subdevice private data.
  * @s: comedi_subdevice struct
- * @data: pointer to the private data
+ * @size: size of the memory to allocate
  *
  * This also sets the subdevice runflags to allow the core to automatically
  * free the private data during the detach.
  */
-void comedi_set_spriv(struct comedi_subdevice *s, void *data)
+void *comedi_alloc_spriv(struct comedi_subdevice *s, size_t size)
 {
-	s->private = data;
-	comedi_set_subdevice_runflags(s, ~0, SRF_FREE_SPRIV);
+	s->private = kzalloc(size, GFP_KERNEL);
+	if (s->private)
+		comedi_set_subdevice_runflags(s, ~0, SRF_FREE_SPRIV);
+	return s->private;
 }
-EXPORT_SYMBOL_GPL(comedi_set_spriv);
+EXPORT_SYMBOL_GPL(comedi_alloc_spriv);
 
 /*
    This function restores a subdevice to an idle state.

commit 588ba6dc5fb4bdca47a3da38c2718fbb82d3eee1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 11 11:32:29 2013 -0700

    staging: comedi: drivers: let core handle freeing s->private
    
    Introduce a new subdevice runflags, SRF_FREE_SPRIV, and a new helper
    function, comedi_set_spriv(), that the drivers can use to set the
    comedi_subdevice private data pointer. The helper function will also
    set SRF_FREE_SPRIV to allow the comedi core to automatically free the
    subdevice private data during the cleanup_device() stage of the detach.
    
    Currently s->private is only allocated by the 8255, addi_watchdog,
    amplc_dio200_common, and ni_65xx drivers. All users of those drivers
    can then have the comedi_spriv_free() calls removed and in many cases
    the (*detach) can then simply be the appropriate comedi core provided
    function.
    
    The ni_65xx driver uses a helper function, ni_65xx_alloc_subdevice_private(),
    to allocate the private data. Refactor the function to return an errno
    or call comedi_set_spriv() instead of returning a pointer to the private
    data and requiring the caller to handle it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c561a0eda92a..423f882416d9 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -531,6 +531,21 @@ static bool comedi_is_subdevice_idle(struct comedi_subdevice *s)
 	return (runflags & (SRF_ERROR | SRF_RUNNING)) ? false : true;
 }
 
+/**
+ * comedi_set_spriv() - Set the subdevice private data pointer.
+ * @s: comedi_subdevice struct
+ * @data: pointer to the private data
+ *
+ * This also sets the subdevice runflags to allow the core to automatically
+ * free the private data during the detach.
+ */
+void comedi_set_spriv(struct comedi_subdevice *s, void *data)
+{
+	s->private = data;
+	comedi_set_subdevice_runflags(s, ~0, SRF_FREE_SPRIV);
+}
+EXPORT_SYMBOL_GPL(comedi_set_spriv);
+
 /*
    This function restores a subdevice to an idle state.
  */

commit 7b1a5e2f4f5afde4f1dadf58223c2f293208293b
Author: Gngr Erseymen <gelurine@gmail.com>
Date:   Fri Jun 7 21:29:50 2013 +0300

    staging: comedi: remove 'bi.subdevice < 0' check in do_bufinfo_ioctl()
    
    Type of variable 'bi' is struct comedi_bufinfo and 'subdevice' is
    defined as unsigned, so there is no need to check if it is less then
    zero.
    
    Signed-off-by: Gngr Erseymen <gelurine@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 986f19572689..c561a0eda92a 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -913,7 +913,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	if (copy_from_user(&bi, arg, sizeof(bi)))
 		return -EFAULT;
 
-	if (bi.subdevice >= dev->n_subdevices || bi.subdevice < 0)
+	if (bi.subdevice >= dev->n_subdevices)
 		return -EINVAL;
 
 	s = &dev->subdevices[bi.subdevice];

commit 11f80ddfd51f802575dc8b00ca59156d8e6a3e6e
Author: Gngr Erseymen <gelurine@gmail.com>
Date:   Fri Jun 7 21:29:49 2013 +0300

    staging: comedi: remove 'bc.subdevice < 0' check in do_bufconfig_ioctl()
    
    Type of variable 'bc' is struct comedi_bufconfig and 'subdevice' is
    defined as unsigned, so there is no need to check if it is less then
    zero.
    
    Signed-off-by: Gngr Erseymen <gelurine@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 610be19d859f..986f19572689 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -660,7 +660,7 @@ static int do_bufconfig_ioctl(struct comedi_device *dev,
 	if (copy_from_user(&bc, arg, sizeof(bc)))
 		return -EFAULT;
 
-	if (bc.subdevice >= dev->n_subdevices || bc.subdevice < 0)
+	if (bc.subdevice >= dev->n_subdevices)
 		return -EINVAL;
 
 	s = &dev->subdevices[bc.subdevice];

commit 829455bb0e994373519e3c58d403fc1148f44630
Merge: 42b4212baa28 e4aa937ec75d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 27 10:54:33 2013 +0900

    Merge 3.10-rc3 into staging-next
    
    We want the changes here, and we resolve the merge conflict that was
    happening in the nvec_kbd.c file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b3fab427739c76871c96834e72c369dd0e502d4b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 10 14:08:28 2013 +0100

    staging: comedi: allow buffer resize if previous resize failed
    
    When a comedi device is successfully attached, those subdevices that
    support asynchronous commands will have had buffers allocated
    successfully.  It is possible to resize the buffers afterwards, but if
    the resize fails the subdevice is left with no buffer
    (`s->async->prealloc_buf == NULL`).  Currently, this also causes any
    subsequent attempts to resize the buffer to fail with an error, which
    seems like a bad idea.
    
    Remove the check in `resize_async_buffer()` that causes the resize to
    fail if the subdevice currently has no buffer (presumably due to the
    failure of a previous resize attempt).  Callers of
    `resize_async_buffer()` have already checked that the subdevice is
    allowed to have a buffer.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 00f2547024ec..924c54c9c31f 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -246,9 +246,6 @@ static int resize_async_buffer(struct comedi_device *dev,
 		return -EBUSY;
 	}
 
-	if (!async->prealloc_buf)
-		return -EINVAL;
-
 	/* make sure buffer is an integral number of pages
 	 * (we round up) */
 	new_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 00f2547024ec..0e781732cc1a 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -14,11 +14,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
 */
 
 #undef DEBUG

commit 5660e7427113eff85ae712af9cf98c8c5bd368e3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 12 10:11:54 2013 -0700

    staging: comedi: use EXPORT_SYMBOL_GPL() for all exported symbols
    
    Comedi is licensed under GPL. Some if its exports are currently
    EXPORT_SYMBOL() and others are EXPORT_SYMBOL_GPL(). Change them all
    to EXPORT_SYMBOL_GPL() and see if anyone reports any fall out.
    
    If any of the symbols "need" to be EXPORT_SYMBOL() they will be
    addressed as needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index dec04b9b025e..00f2547024ec 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -55,7 +55,7 @@
 
 #ifdef CONFIG_COMEDI_DEBUG
 int comedi_debug;
-EXPORT_SYMBOL(comedi_debug);
+EXPORT_SYMBOL_GPL(comedi_debug);
 module_param(comedi_debug, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(comedi_debug,
 		 "enable comedi core and driver debugging if non-zero (default 0)"
@@ -2344,7 +2344,7 @@ void comedi_error(const struct comedi_device *dev, const char *s)
 {
 	dev_err(dev->class_dev, "%s: %s\n", dev->driver->driver_name, s);
 }
-EXPORT_SYMBOL(comedi_error);
+EXPORT_SYMBOL_GPL(comedi_error);
 
 void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
@@ -2387,7 +2387,7 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	s->async->events = 0;
 }
-EXPORT_SYMBOL(comedi_event);
+EXPORT_SYMBOL_GPL(comedi_event);
 
 /* Note: the ->mutex is pre-locked on successful return */
 struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)

commit db210da268ec537f8944ea5bc490184a6707c8a2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:18 2013 +0100

    staging: comedi: add comedi_clear_board_dev()
    
    Add local function `comedi_clear_board_dev()` as a safer alternative to
    `comedi_clear_board_minor()` when we already have a pointer to a `struct
    comedi_device`.  It uses the board minor device number stored in the
    `struct comedi_device` (which must have already been initialized) and
    only clears the entry in `comedi_board_minor_table[]` if it points to
    the specified `struct comedi_device`.  Rather than returning the old
    table entry, it returns `true` if the entry matched (and so has just
    been cleared) and returns `false` otherwise.
    
    Call `comedi_clear_board_dev()` instead of `comedi_clear_board_minor()`
    in `comedi_unlocked_ioctl()` (in the code that frees a dynamically
    allocated comedi device detached by the `COMEDI_DEVCONFIG` ioctl).  That
    ought to return `true` but check it just in case before freeing the
    device.  There is still a race condition here which needs to be dealt
    with once we've implemented reference counting for `struct
    comedi_device`s.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b5e4bf1373e2..dec04b9b025e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -120,6 +120,20 @@ static void comedi_device_cleanup(struct comedi_device *dev)
 	mutex_destroy(&dev->mutex);
 }
 
+static bool comedi_clear_board_dev(struct comedi_device *dev)
+{
+	unsigned int i = dev->minor;
+	bool cleared = false;
+
+	mutex_lock(&comedi_board_minor_table_lock);
+	if (dev == comedi_board_minor_table[i]) {
+		comedi_board_minor_table[i] = NULL;
+		cleared = true;
+	}
+	mutex_unlock(&comedi_board_minor_table_lock);
+	return cleared;
+}
+
 static struct comedi_device *comedi_clear_board_minor(unsigned minor)
 {
 	struct comedi_device *dev;
@@ -1766,9 +1780,7 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 			    dev->minor >= comedi_num_legacy_minors) {
 				/* Successfully unconfigured a dynamically
 				 * allocated device.  Try and remove it. */
-				struct comedi_device *devr;
-				devr = comedi_clear_board_minor(dev->minor);
-				if (dev == devr) {
+				if (comedi_clear_board_dev(dev)) {
 					mutex_unlock(&dev->mutex);
 					comedi_free_board_dev(dev);
 					return rc;

commit c6f5b4d587a46fc0713cecc30ef3993c59b7e41e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:17 2013 +0100

    staging: comedi: remove struct comedi_file_info
    
    `struct comedi_file_info` is no longer used so remove it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 7b0951e9a0a5..b5e4bf1373e2 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -81,12 +81,6 @@ MODULE_PARM_DESC(comedi_default_buf_maxsize_kb,
 		 "default maximum size of asynchronous buffer in KiB (default "
 		 __MODULE_STRING(CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB) ")");
 
-struct comedi_file_info {
-	struct comedi_device *device;
-	struct comedi_subdevice *read_subdevice;
-	struct comedi_subdevice *write_subdevice;
-};
-
 static DEFINE_MUTEX(comedi_board_minor_table_lock);
 static struct comedi_device
 *comedi_board_minor_table[COMEDI_NUM_BOARD_MINORS];

commit cb6b79dedb5e57a51761d5d08540b5e1127df571
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:16 2013 +0100

    staging: comedi: simplify comedi_board_minor_table[]
    
    `comedi_alloc_board_minor()` allocates and initializes a `struct
    comedi_file_info` and a `struct comedi_device`, and assigns a board
    minor device number (if there are any available), storing a pointer to
    the allocated `struct comedi_file_info` in
    `comedi_board_minor_table[minor]` where `minor` is the board minor
    device number.
    
    There is no longer anything useful in the `struct comedi_file_info`
    apart from the pointer to the `struct comedi_device` that was allocated,
    so the `struct comedi_file_info` is superfluous.
    
    Change `comedi_board_minor_table[]` to hold pointers to the actual
    `struct comedi_device`'s.  `comedi_alloc_board_minor()` no longer needs
    to allocate a `struct comedi_file_info`.  Replace
    `comedi_free_board_file_info()` with `comedi_free_board_dev()` with its
    parameter pointing to the `struct comedi_device` to be freed (there is
    no longer a `struct comedi_file_info` to be freed).
    
    There are consequential changes to `comedi_dev_from_board_minor()`,
    `comedi_clear_board_minor()` (which now returns a `struct comedi_device
    *`), `comedi_free_board_minor()`, `comedi_release_hardware_device()` and
    `comedi_unlocked_ioctl()` (when dealing with detachment of a dynamically
    allocated comedi device by the `COMEDI_DEVCONFIG` ioctl).
    
    `comedi_dev_from_file_info()` is no longer used as a result of the above
    changes so remove it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 4e4ccc2f59b8..7b0951e9a0a5 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -88,7 +88,7 @@ struct comedi_file_info {
 };
 
 static DEFINE_MUTEX(comedi_board_minor_table_lock);
-static struct comedi_file_info
+static struct comedi_device
 *comedi_board_minor_table[COMEDI_NUM_BOARD_MINORS];
 
 static DEFINE_MUTEX(comedi_subdevice_minor_table_lock);
@@ -126,30 +126,26 @@ static void comedi_device_cleanup(struct comedi_device *dev)
 	mutex_destroy(&dev->mutex);
 }
 
-static struct comedi_file_info *comedi_clear_board_minor(unsigned minor)
+static struct comedi_device *comedi_clear_board_minor(unsigned minor)
 {
-	struct comedi_file_info *info;
+	struct comedi_device *dev;
 
 	mutex_lock(&comedi_board_minor_table_lock);
-	info = comedi_board_minor_table[minor];
+	dev = comedi_board_minor_table[minor];
 	comedi_board_minor_table[minor] = NULL;
 	mutex_unlock(&comedi_board_minor_table_lock);
-	return info;
+	return dev;
 }
 
-static void comedi_free_board_file_info(struct comedi_file_info *info)
+static void comedi_free_board_dev(struct comedi_device *dev)
 {
-	if (info) {
-		struct comedi_device *dev = info->device;
-		if (dev) {
-			if (dev->class_dev) {
-				device_destroy(comedi_class,
-					       MKDEV(COMEDI_MAJOR, dev->minor));
-			}
-			comedi_device_cleanup(dev);
-			kfree(dev);
+	if (dev) {
+		if (dev->class_dev) {
+			device_destroy(comedi_class,
+				       MKDEV(COMEDI_MAJOR, dev->minor));
 		}
-		kfree(info);
+		comedi_device_cleanup(dev);
+		kfree(dev);
 	}
 }
 
@@ -166,21 +162,15 @@ static struct comedi_subdevice
 	return s;
 }
 
-static struct comedi_device *
-comedi_dev_from_file_info(struct comedi_file_info *info)
-{
-	return info ? info->device : NULL;
-}
-
 static struct comedi_device *comedi_dev_from_board_minor(unsigned minor)
 {
-	struct comedi_file_info *info;
+	struct comedi_device *dev;
 
 	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
 	mutex_lock(&comedi_board_minor_table_lock);
-	info = comedi_board_minor_table[minor];
+	dev = comedi_board_minor_table[minor];
 	mutex_unlock(&comedi_board_minor_table_lock);
-	return comedi_dev_from_file_info(info);
+	return dev;
 }
 
 static struct comedi_device *comedi_dev_from_subdevice_minor(unsigned minor)
@@ -1782,11 +1772,11 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 			    dev->minor >= comedi_num_legacy_minors) {
 				/* Successfully unconfigured a dynamically
 				 * allocated device.  Try and remove it. */
-				struct comedi_file_info *info;
-				info = comedi_clear_board_minor(dev->minor);
-				if (info) {
+				struct comedi_device *devr;
+				devr = comedi_clear_board_minor(dev->minor);
+				if (dev == devr) {
 					mutex_unlock(&dev->mutex);
-					comedi_free_board_file_info(info);
+					comedi_free_board_dev(dev);
 					return rc;
 				}
 			}
@@ -2396,20 +2386,13 @@ EXPORT_SYMBOL(comedi_event);
 /* Note: the ->mutex is pre-locked on successful return */
 struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 {
-	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct device *csdev;
 	unsigned i;
 
-	info = kzalloc(sizeof(*info), GFP_KERNEL);
-	if (info == NULL)
-		return ERR_PTR(-ENOMEM);
 	dev = kzalloc(sizeof(struct comedi_device), GFP_KERNEL);
-	if (dev == NULL) {
-		kfree(info);
+	if (dev == NULL)
 		return ERR_PTR(-ENOMEM);
-	}
-	info->device = dev;
 	comedi_device_init(dev);
 	comedi_set_hw_dev(dev, hardware_device);
 	mutex_lock(&dev->mutex);
@@ -2417,7 +2400,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	for (i = hardware_device ? comedi_num_legacy_minors : 0;
 	     i < COMEDI_NUM_BOARD_MINORS; ++i) {
 		if (comedi_board_minor_table[i] == NULL) {
-			comedi_board_minor_table[i] = info;
+			comedi_board_minor_table[i] = dev;
 			break;
 		}
 	}
@@ -2426,7 +2409,6 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 		mutex_unlock(&dev->mutex);
 		comedi_device_cleanup(dev);
 		kfree(dev);
-		kfree(info);
 		pr_err("comedi: error: ran out of minor numbers for board device files.\n");
 		return ERR_PTR(-EBUSY);
 	}
@@ -2443,22 +2425,22 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 static void comedi_free_board_minor(unsigned minor)
 {
 	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
-	comedi_free_board_file_info(comedi_clear_board_minor(minor));
+	comedi_free_board_dev(comedi_clear_board_minor(minor));
 }
 
 void comedi_release_hardware_device(struct device *hardware_device)
 {
 	int minor;
-	struct comedi_file_info *info;
+	struct comedi_device *dev;
 
 	for (minor = comedi_num_legacy_minors; minor < COMEDI_NUM_BOARD_MINORS;
 	     minor++) {
 		mutex_lock(&comedi_board_minor_table_lock);
-		info = comedi_board_minor_table[minor];
-		if (info && info->device->hw_dev == hardware_device) {
+		dev = comedi_board_minor_table[minor];
+		if (dev && dev->hw_dev == hardware_device) {
 			comedi_board_minor_table[minor] = NULL;
 			mutex_unlock(&comedi_board_minor_table_lock);
-			comedi_free_board_file_info(info);
+			comedi_free_board_dev(dev);
 			break;
 		}
 		mutex_unlock(&comedi_board_minor_table_lock);

commit bd5b4173d50af86798d98b147321a92cf3a0a8ec
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:15 2013 +0100

    staging: comedi: simplify comedi_subdevice_minor_table[]
    
    `comedi_alloc_subdevice_minor()` allocates and initializes a `struct
    comedi_file_info` and assigns a subdevice minor device number (if there
    are any available), storing a pointer to the allocated `struct
    comedi_file_info` in `comedi_subdevice_minor_table[i]` where `i` is the
    array index corresponding to the subdevice minor device number (indexed
    by subdevice minor device number minus `COMEDI_NUM_BOARD_MINORS`).
    
    The information stored in the `struct comedi_file_info` can be derived
    from the subdevice structure (`struct comedi_subdevice`) itself, so the
    `struct comedi_file_info` is superfluous.
    
    Change `comedi_subdevice_minor_table[]` to hold pointers to the actual
    `struct comedi_subdevice`'s.  `comedi_alloc_subdevice_minor()` no longer
    needs to allocate a `struct comedi_file_info` and
    `comedi_free_subdevice_info()` no longer has a `struct comedi_file_info`
    to free.
    
    Replace `comedi_file_info_from_minor()` with
    `comedi_subdevice_from_minor()`, returning a (possibly NULL) pointer to
    a `struct comedi_subdevice` from the table.  This has knock-on effects
    for `comedi_dev_from_subdevice_minor()`, `comedi_read_subdevice()` and
    `comedi_write_subdevice()`.  In particular, `comedi_read_subdevice()`
    and `comedi_write_subdevice()` now need to check the subdevice flags to
    see if the determine whether to override the comedi device's default
    read/write subdevice.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 71156bdfcdc8..4e4ccc2f59b8 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -93,7 +93,7 @@ static struct comedi_file_info
 
 static DEFINE_MUTEX(comedi_subdevice_minor_table_lock);
 /* Note: indexed by minor - COMEDI_NUM_BOARD_MINORS. */
-static struct comedi_file_info
+static struct comedi_subdevice
 *comedi_subdevice_minor_table[COMEDI_NUM_SUBDEVICE_MINORS];
 
 static struct class *comedi_class;
@@ -153,17 +153,17 @@ static void comedi_free_board_file_info(struct comedi_file_info *info)
 	}
 }
 
-static struct comedi_file_info
-*comedi_file_info_from_subdevice_minor(unsigned minor)
+static struct comedi_subdevice
+*comedi_subdevice_from_minor(unsigned minor)
 {
-	struct comedi_file_info *info;
+	struct comedi_subdevice *s;
 	unsigned int i = minor - COMEDI_NUM_BOARD_MINORS;
 
 	BUG_ON(i >= COMEDI_NUM_SUBDEVICE_MINORS);
 	mutex_lock(&comedi_subdevice_minor_table_lock);
-	info = comedi_subdevice_minor_table[i];
+	s = comedi_subdevice_minor_table[i];
 	mutex_unlock(&comedi_subdevice_minor_table_lock);
-	return info;
+	return s;
 }
 
 static struct comedi_device *
@@ -185,10 +185,10 @@ static struct comedi_device *comedi_dev_from_board_minor(unsigned minor)
 
 static struct comedi_device *comedi_dev_from_subdevice_minor(unsigned minor)
 {
-	struct comedi_file_info *info;
+	struct comedi_subdevice *s;
 
-	info = comedi_file_info_from_subdevice_minor(minor);
-	return comedi_dev_from_file_info(info);
+	s = comedi_subdevice_from_minor(minor);
+	return s ? s->device : NULL;
 }
 
 struct comedi_device *comedi_dev_from_minor(unsigned minor)
@@ -203,14 +203,14 @@ EXPORT_SYMBOL_GPL(comedi_dev_from_minor);
 static struct comedi_subdevice *
 comedi_read_subdevice(const struct comedi_device *dev, unsigned int minor)
 {
-	struct comedi_file_info *info;
+	struct comedi_subdevice *s;
 
 	if (minor >= COMEDI_NUM_BOARD_MINORS) {
-		info = comedi_file_info_from_subdevice_minor(minor);
-		if (!info || info->device != dev)
+		s = comedi_subdevice_from_minor(minor);
+		if (!s || s->device != dev)
 			return NULL;
-		if (info->read_subdevice)
-			return info->read_subdevice;
+		if (s->subdev_flags & SDF_CMD_READ)
+			return s;
 	}
 	return dev->read_subdev;
 }
@@ -218,14 +218,14 @@ comedi_read_subdevice(const struct comedi_device *dev, unsigned int minor)
 static struct comedi_subdevice *
 comedi_write_subdevice(const struct comedi_device *dev, unsigned int minor)
 {
-	struct comedi_file_info *info;
+	struct comedi_subdevice *s;
 
 	if (minor >= COMEDI_NUM_BOARD_MINORS) {
-		info = comedi_file_info_from_subdevice_minor(minor);
-		if (!info || info->device != dev)
+		s = comedi_subdevice_from_minor(minor);
+		if (!s || s->device != dev)
 			return NULL;
-		if (info->write_subdevice)
-			return info->write_subdevice;
+		if (s->subdev_flags & SDF_CMD_WRITE)
+			return s;
 	}
 	return dev->write_subdev;
 }
@@ -2468,28 +2468,18 @@ void comedi_release_hardware_device(struct device *hardware_device)
 int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 {
 	struct comedi_device *dev = s->device;
-	struct comedi_file_info *info;
 	struct device *csdev;
 	unsigned i;
 
-	info = kzalloc(sizeof(*info), GFP_KERNEL);
-	if (!info)
-		return -ENOMEM;
-	info->device = dev;
-	if (s->subdev_flags & SDF_CMD_READ)
-		info->read_subdevice = s;
-	if (s->subdev_flags & SDF_CMD_WRITE)
-		info->write_subdevice = s;
 	mutex_lock(&comedi_subdevice_minor_table_lock);
 	for (i = 0; i < COMEDI_NUM_SUBDEVICE_MINORS; ++i) {
 		if (comedi_subdevice_minor_table[i] == NULL) {
-			comedi_subdevice_minor_table[i] = info;
+			comedi_subdevice_minor_table[i] = s;
 			break;
 		}
 	}
 	mutex_unlock(&comedi_subdevice_minor_table_lock);
 	if (i == COMEDI_NUM_SUBDEVICE_MINORS) {
-		kfree(info);
 		pr_err("comedi: error: ran out of minor numbers for subdevice files.\n");
 		return -EBUSY;
 	}
@@ -2506,7 +2496,6 @@ int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 
 void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 {
-	struct comedi_file_info *info;
 	unsigned int i;
 
 	if (s == NULL)
@@ -2519,14 +2508,13 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 
 	i = s->minor - COMEDI_NUM_BOARD_MINORS;
 	mutex_lock(&comedi_subdevice_minor_table_lock);
-	info = comedi_subdevice_minor_table[i];
-	comedi_subdevice_minor_table[i] = NULL;
+	if (s == comedi_subdevice_minor_table[i])
+		comedi_subdevice_minor_table[i] = NULL;
 	mutex_unlock(&comedi_subdevice_minor_table_lock);
 	if (s->class_dev) {
 		device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, s->minor));
 		s->class_dev = NULL;
 	}
-	kfree(info);
 }
 
 static void comedi_cleanup_board_minors(void)

commit dac59de2dd438a54007135ac3c2e6b6b06b5f6d6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:14 2013 +0100

    staging: comedi: remove comedi_file_info_from_board_minor()
    
    Merge the code from `comedi_file_info_from_board_minor()` into
    `comedi_dev_from_board_minor()` and remove it since nothing else calls
    it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 64721f7f089b..71156bdfcdc8 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -153,18 +153,6 @@ static void comedi_free_board_file_info(struct comedi_file_info *info)
 	}
 }
 
-static struct comedi_file_info
-*comedi_file_info_from_board_minor(unsigned minor)
-{
-	struct comedi_file_info *info;
-
-	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
-	mutex_lock(&comedi_board_minor_table_lock);
-	info = comedi_board_minor_table[minor];
-	mutex_unlock(&comedi_board_minor_table_lock);
-	return info;
-}
-
 static struct comedi_file_info
 *comedi_file_info_from_subdevice_minor(unsigned minor)
 {
@@ -188,7 +176,10 @@ static struct comedi_device *comedi_dev_from_board_minor(unsigned minor)
 {
 	struct comedi_file_info *info;
 
-	info = comedi_file_info_from_board_minor(minor);
+	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
+	mutex_lock(&comedi_board_minor_table_lock);
+	info = comedi_board_minor_table[minor];
+	mutex_unlock(&comedi_board_minor_table_lock);
 	return comedi_dev_from_file_info(info);
 }
 

commit 0fcc9d48a0e620ee5097cbcbf8aedc5d736a01b8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:13 2013 +0100

    staging: comedi: remove comedi_clear_subdevice_minor()
    
    Merge the code from `comedi_clear_subdevice_minor()` into
    `comedi_free_subdevice_minor()` and remove it since nothing else calls
    it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 5f3b1524e07d..64721f7f089b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -137,18 +137,6 @@ static struct comedi_file_info *comedi_clear_board_minor(unsigned minor)
 	return info;
 }
 
-static struct comedi_file_info *comedi_clear_subdevice_minor(unsigned minor)
-{
-	struct comedi_file_info *info;
-	unsigned int i = minor - COMEDI_NUM_BOARD_MINORS;
-
-	mutex_lock(&comedi_subdevice_minor_table_lock);
-	info = comedi_subdevice_minor_table[i];
-	comedi_subdevice_minor_table[i] = NULL;
-	mutex_unlock(&comedi_subdevice_minor_table_lock);
-	return info;
-}
-
 static void comedi_free_board_file_info(struct comedi_file_info *info)
 {
 	if (info) {
@@ -2528,6 +2516,7 @@ int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 {
 	struct comedi_file_info *info;
+	unsigned int i;
 
 	if (s == NULL)
 		return;
@@ -2537,7 +2526,11 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 	BUG_ON(s->minor >= COMEDI_NUM_MINORS);
 	BUG_ON(s->minor < COMEDI_NUM_BOARD_MINORS);
 
-	info = comedi_clear_subdevice_minor(s->minor);
+	i = s->minor - COMEDI_NUM_BOARD_MINORS;
+	mutex_lock(&comedi_subdevice_minor_table_lock);
+	info = comedi_subdevice_minor_table[i];
+	comedi_subdevice_minor_table[i] = NULL;
+	mutex_unlock(&comedi_subdevice_minor_table_lock);
 	if (s->class_dev) {
 		device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, s->minor));
 		s->class_dev = NULL;

commit f3abc831386e3606fbb21acf0ee5231df0d0185f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:12 2013 +0100

    staging: comedi: refactor comedi_dev_from_minor()
    
    Refactor `comedi_dev_from_minor()` to call one of two new functions
    `comedi_dev_from_board_minor()` (for minor device numbers less than
    `COMEDI_NUM_BOARD_MINORS`) or `comedi_dev_from_subdevice_minor()` (for
    minor device numbers greater than or equal to `COMEDI_NUM_BOARD_MINORS`,
    which are subdevice minor device numbers).
    
    Remove `comedi_file_info_from_minor()` as it is no longer used.
    
    This is a step towards removing `struct comedi_file_info`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index beb579ddab63..5f3b1524e07d 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -190,23 +190,34 @@ static struct comedi_file_info
 	return info;
 }
 
-static struct comedi_file_info *comedi_file_info_from_minor(unsigned minor)
-{
-	if (minor < COMEDI_NUM_BOARD_MINORS)
-		return comedi_file_info_from_board_minor(minor);
-	else
-		return comedi_file_info_from_subdevice_minor(minor);
-}
-
 static struct comedi_device *
 comedi_dev_from_file_info(struct comedi_file_info *info)
 {
 	return info ? info->device : NULL;
 }
 
+static struct comedi_device *comedi_dev_from_board_minor(unsigned minor)
+{
+	struct comedi_file_info *info;
+
+	info = comedi_file_info_from_board_minor(minor);
+	return comedi_dev_from_file_info(info);
+}
+
+static struct comedi_device *comedi_dev_from_subdevice_minor(unsigned minor)
+{
+	struct comedi_file_info *info;
+
+	info = comedi_file_info_from_subdevice_minor(minor);
+	return comedi_dev_from_file_info(info);
+}
+
 struct comedi_device *comedi_dev_from_minor(unsigned minor)
 {
-	return comedi_dev_from_file_info(comedi_file_info_from_minor(minor));
+	if (minor < COMEDI_NUM_BOARD_MINORS)
+		return comedi_dev_from_board_minor(minor);
+	else
+		return comedi_dev_from_subdevice_minor(minor);
 }
 EXPORT_SYMBOL_GPL(comedi_dev_from_minor);
 

commit 5e04c25435e2cf0049def6ab4c28e49494a68dde
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:11 2013 +0100

    staging: comedi: reduce use of struct comedi_file_info
    
    Since the parameters of `comedi_read_subdevice()` and
    `comedi_write_subdevice()` have changed, there is no longer a need to
    keep a local variable `struct comedi_file_info *info` hanging around in
    the file operation functions and device attribute access functions.
    Remove the variable from those function and replace the call sequence
    `info = comedi_file_info_from_minor(minor)`,  `dev =
    comedi_dev_from_file_info(info)` with the simpler `dev =
    comedi_dev_from_minor(minor)`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 269284812c61..beb579ddab63 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -286,16 +286,14 @@ static ssize_t show_max_read_buffer_kb(struct device *csdev,
 				       struct device_attribute *attr, char *buf)
 {
 	unsigned int minor = MINOR(csdev->devt);
-	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
-	info = comedi_file_info_from_minor(minor);
-	if (!info)
+	dev = comedi_dev_from_minor(minor);
+	if (!dev)
 		return -ENODEV;
 
-	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_read_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
@@ -310,7 +308,6 @@ static ssize_t store_max_read_buffer_kb(struct device *csdev,
 					const char *buf, size_t count)
 {
 	unsigned int minor = MINOR(csdev->devt);
-	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size;
@@ -323,11 +320,10 @@ static ssize_t store_max_read_buffer_kb(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
-	info = comedi_file_info_from_minor(minor);
-	if (!info)
+	dev = comedi_dev_from_minor(minor);
+	if (!dev)
 		return -ENODEV;
 
-	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_read_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
@@ -343,16 +339,14 @@ static ssize_t show_read_buffer_kb(struct device *csdev,
 				   struct device_attribute *attr, char *buf)
 {
 	unsigned int minor = MINOR(csdev->devt);
-	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
-	info = comedi_file_info_from_minor(minor);
-	if (!info)
+	dev = comedi_dev_from_minor(minor);
+	if (!dev)
 		return -ENODEV;
 
-	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_read_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
@@ -367,7 +361,6 @@ static ssize_t store_read_buffer_kb(struct device *csdev,
 				    const char *buf, size_t count)
 {
 	unsigned int minor = MINOR(csdev->devt);
-	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size;
@@ -380,11 +373,10 @@ static ssize_t store_read_buffer_kb(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
-	info = comedi_file_info_from_minor(minor);
-	if (!info)
+	dev = comedi_dev_from_minor(minor);
+	if (!dev)
 		return -ENODEV;
 
-	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_read_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
@@ -401,16 +393,14 @@ static ssize_t show_max_write_buffer_kb(struct device *csdev,
 					char *buf)
 {
 	unsigned int minor = MINOR(csdev->devt);
-	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
-	info = comedi_file_info_from_minor(minor);
-	if (!info)
+	dev = comedi_dev_from_minor(minor);
+	if (!dev)
 		return -ENODEV;
 
-	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_write_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
@@ -425,7 +415,6 @@ static ssize_t store_max_write_buffer_kb(struct device *csdev,
 					 const char *buf, size_t count)
 {
 	unsigned int minor = MINOR(csdev->devt);
-	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size;
@@ -438,11 +427,10 @@ static ssize_t store_max_write_buffer_kb(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
-	info = comedi_file_info_from_minor(minor);
-	if (!info)
+	dev = comedi_dev_from_minor(minor);
+	if (!dev)
 		return -ENODEV;
 
-	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_write_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
@@ -458,16 +446,14 @@ static ssize_t show_write_buffer_kb(struct device *csdev,
 				    struct device_attribute *attr, char *buf)
 {
 	unsigned int minor = MINOR(csdev->devt);
-	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
-	info = comedi_file_info_from_minor(minor);
-	if (!info)
+	dev = comedi_dev_from_minor(minor);
+	if (!dev)
 		return -ENODEV;
 
-	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_write_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
@@ -482,7 +468,6 @@ static ssize_t store_write_buffer_kb(struct device *csdev,
 				     const char *buf, size_t count)
 {
 	unsigned int minor = MINOR(csdev->devt);
-	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size;
@@ -495,11 +480,10 @@ static ssize_t store_write_buffer_kb(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
-	info = comedi_file_info_from_minor(minor);
-	if (!info)
+	dev = comedi_dev_from_minor(minor);
+	if (!dev)
 		return -ENODEV;
 
-	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_write_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
@@ -1785,8 +1769,7 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 				  unsigned long arg)
 {
 	const unsigned minor = iminor(file_inode(file));
-	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev = comedi_dev_from_file_info(info);
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
 	int rc;
 
 	if (!dev)
@@ -1809,6 +1792,7 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 			    dev->minor >= comedi_num_legacy_minors) {
 				/* Successfully unconfigured a dynamically
 				 * allocated device.  Try and remove it. */
+				struct comedi_file_info *info;
 				info = comedi_clear_board_minor(dev->minor);
 				if (info) {
 					mutex_unlock(&dev->mutex);
@@ -1923,8 +1907,7 @@ static struct vm_operations_struct comedi_vm_ops = {
 static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	const unsigned minor = iminor(file_inode(file));
-	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev = comedi_dev_from_file_info(info);
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 	unsigned long start = vma->vm_start;
@@ -2003,8 +1986,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 {
 	unsigned int mask = 0;
 	const unsigned minor = iminor(file_inode(file));
-	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev = comedi_dev_from_file_info(info);
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
 	struct comedi_subdevice *s;
 
 	if (!dev)
@@ -2049,8 +2031,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file_inode(file));
-	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev = comedi_dev_from_file_info(info);
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
 
 	if (!dev)
 		return -ENODEV;
@@ -2144,8 +2125,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file_inode(file));
-	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev = comedi_dev_from_file_info(info);
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
 
 	if (!dev)
 		return -ENODEV;

commit da56fdc6cd6ebefb597bbf9f1b30c2b0a39c9f56
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:10 2013 +0100

    staging: comedi: change comedi_read/write_subdevice() parameters
    
    `comedi_read_subdevice()` and `comedi_write_subdevice()` currently take
    a single parameter pointing to a `struct comedi_file_info`.  I'm trying
    to get rid of `struct comedi_file_info` so as part of that plan,
    `comedi_read_subdevice()` and `comedi_write_subdevice()` need to change.
    Change them to take two parameters: a pointer to a `struct
    comedi_device` and a minor device number.  If the minor device number is
    a "board" minor device number (`minor < COMEDI_NUM_BOARD_MINORS`) we'll
    always return the default read or write subdevice.  If the minor device
    number if a "subdevice" minor device number a different read or write
    subdevice may be returned.  In that case, use the subdevice minor device
    number to look up the information about whether the default read or
    write subdevice needs to be overridden.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 95a418b3fa00..269284812c61 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -211,23 +211,33 @@ struct comedi_device *comedi_dev_from_minor(unsigned minor)
 EXPORT_SYMBOL_GPL(comedi_dev_from_minor);
 
 static struct comedi_subdevice *
-comedi_read_subdevice(const struct comedi_file_info *info)
+comedi_read_subdevice(const struct comedi_device *dev, unsigned int minor)
 {
-	if (info->read_subdevice)
-		return info->read_subdevice;
-	if (info->device)
-		return info->device->read_subdev;
-	return NULL;
+	struct comedi_file_info *info;
+
+	if (minor >= COMEDI_NUM_BOARD_MINORS) {
+		info = comedi_file_info_from_subdevice_minor(minor);
+		if (!info || info->device != dev)
+			return NULL;
+		if (info->read_subdevice)
+			return info->read_subdevice;
+	}
+	return dev->read_subdev;
 }
 
 static struct comedi_subdevice *
-comedi_write_subdevice(const struct comedi_file_info *info)
+comedi_write_subdevice(const struct comedi_device *dev, unsigned int minor)
 {
-	if (info->write_subdevice)
-		return info->write_subdevice;
-	if (info->device)
-		return info->device->write_subdev;
-	return NULL;
+	struct comedi_file_info *info;
+
+	if (minor >= COMEDI_NUM_BOARD_MINORS) {
+		info = comedi_file_info_from_subdevice_minor(minor);
+		if (!info || info->device != dev)
+			return NULL;
+		if (info->write_subdevice)
+			return info->write_subdevice;
+	}
+	return dev->write_subdev;
 }
 
 static int resize_async_buffer(struct comedi_device *dev,
@@ -287,7 +297,7 @@ static ssize_t show_max_read_buffer_kb(struct device *csdev,
 
 	dev = info->device;
 	mutex_lock(&dev->mutex);
-	s = comedi_read_subdevice(info);
+	s = comedi_read_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
 		size = s->async->max_bufsize / 1024;
 	mutex_unlock(&dev->mutex);
@@ -319,7 +329,7 @@ static ssize_t store_max_read_buffer_kb(struct device *csdev,
 
 	dev = info->device;
 	mutex_lock(&dev->mutex);
-	s = comedi_read_subdevice(info);
+	s = comedi_read_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
 		s->async->max_bufsize = size;
 	else
@@ -344,7 +354,7 @@ static ssize_t show_read_buffer_kb(struct device *csdev,
 
 	dev = info->device;
 	mutex_lock(&dev->mutex);
-	s = comedi_read_subdevice(info);
+	s = comedi_read_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
 		size = s->async->prealloc_bufsz / 1024;
 	mutex_unlock(&dev->mutex);
@@ -376,7 +386,7 @@ static ssize_t store_read_buffer_kb(struct device *csdev,
 
 	dev = info->device;
 	mutex_lock(&dev->mutex);
-	s = comedi_read_subdevice(info);
+	s = comedi_read_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
 		err = resize_async_buffer(dev, s, s->async, size);
 	else
@@ -402,7 +412,7 @@ static ssize_t show_max_write_buffer_kb(struct device *csdev,
 
 	dev = info->device;
 	mutex_lock(&dev->mutex);
-	s = comedi_write_subdevice(info);
+	s = comedi_write_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
 		size = s->async->max_bufsize / 1024;
 	mutex_unlock(&dev->mutex);
@@ -434,7 +444,7 @@ static ssize_t store_max_write_buffer_kb(struct device *csdev,
 
 	dev = info->device;
 	mutex_lock(&dev->mutex);
-	s = comedi_write_subdevice(info);
+	s = comedi_write_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
 		s->async->max_bufsize = size;
 	else
@@ -459,7 +469,7 @@ static ssize_t show_write_buffer_kb(struct device *csdev,
 
 	dev = info->device;
 	mutex_lock(&dev->mutex);
-	s = comedi_write_subdevice(info);
+	s = comedi_write_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
 		size = s->async->prealloc_bufsz / 1024;
 	mutex_unlock(&dev->mutex);
@@ -491,7 +501,7 @@ static ssize_t store_write_buffer_kb(struct device *csdev,
 
 	dev = info->device;
 	mutex_lock(&dev->mutex);
-	s = comedi_write_subdevice(info);
+	s = comedi_write_subdevice(dev, minor);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
 		err = resize_async_buffer(dev, s, s->async, size);
 	else
@@ -741,7 +751,6 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 			    struct file *file)
 {
 	const unsigned minor = iminor(file_inode(file));
-	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
 	struct comedi_subdevice *s;
 	struct comedi_devinfo devinfo;
 
@@ -753,13 +762,13 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 	strlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
 	strlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
 
-	s = comedi_read_subdevice(info);
+	s = comedi_read_subdevice(dev, minor);
 	if (s)
 		devinfo.read_subdevice = s->index;
 	else
 		devinfo.read_subdevice = -1;
 
-	s = comedi_write_subdevice(info);
+	s = comedi_write_subdevice(dev, minor);
 	if (s)
 		devinfo.write_subdevice = s->index;
 	else
@@ -1936,9 +1945,9 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	}
 
 	if (vma->vm_flags & VM_WRITE)
-		s = comedi_write_subdevice(info);
+		s = comedi_write_subdevice(dev, minor);
 	else
-		s = comedi_read_subdevice(info);
+		s = comedi_read_subdevice(dev, minor);
 	if (!s) {
 		retval = -EINVAL;
 		goto done;
@@ -2008,7 +2017,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 		goto done;
 	}
 
-	s = comedi_read_subdevice(info);
+	s = comedi_read_subdevice(dev, minor);
 	if (s && s->async) {
 		poll_wait(file, &s->async->wait_head, wait);
 		if (!s->busy || !comedi_is_subdevice_running(s) ||
@@ -2016,7 +2025,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 			mask |= POLLIN | POLLRDNORM;
 	}
 
-	s = comedi_write_subdevice(info);
+	s = comedi_write_subdevice(dev, minor);
 	if (s && s->async) {
 		unsigned int bps = bytes_per_sample(s->async->subdevice);
 
@@ -2051,7 +2060,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 		return -ENODEV;
 	}
 
-	s = comedi_write_subdevice(info);
+	s = comedi_write_subdevice(dev, minor);
 	if (!s || !s->async)
 		return -EIO;
 
@@ -2146,7 +2155,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		return -ENODEV;
 	}
 
-	s = comedi_read_subdevice(info);
+	s = comedi_read_subdevice(dev, minor);
 	if (!s || !s->async)
 		return -EIO;
 

commit c88db46908490f8ae3e3bca3533fbe6250762385
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:09 2013 +0100

    staging: comedi: use minor device number in attribute functions
    
    The comedi device attribute functions such as
    `show_max_read_buffer_kb()` call `dev_get_drvdata()` to get a pointer to
    a `struct comedi_file_info` from the private driver data field of class
    device.  Change them to use the minor device number to look up this
    pointer value so they behave more like the file operation functions.
    Check the pointer is non-NULL as the entry in the minor device table
    could have been set to NULL.  Note that there is still a race condition
    in the use of this pointer value after acquiring the mutex which needs
    to be dealt with once reference counting has been implemented for comedi
    devices.
    
    The calls to `dev_set_drvdata()` from `comedi_alloc_board_minor()` and
    `comedi_alloc_subdevice_minor()` are no longer needed so remove them.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index d06b13a0ed57..95a418b3fa00 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -275,11 +275,16 @@ static int resize_async_buffer(struct comedi_device *dev,
 static ssize_t show_max_read_buffer_kb(struct device *csdev,
 				       struct device_attribute *attr, char *buf)
 {
-	struct comedi_file_info *info = dev_get_drvdata(csdev);
+	unsigned int minor = MINOR(csdev->devt);
+	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
+	info = comedi_file_info_from_minor(minor);
+	if (!info)
+		return -ENODEV;
+
 	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_read_subdevice(info);
@@ -294,7 +299,8 @@ static ssize_t store_max_read_buffer_kb(struct device *csdev,
 					struct device_attribute *attr,
 					const char *buf, size_t count)
 {
-	struct comedi_file_info *info = dev_get_drvdata(csdev);
+	unsigned int minor = MINOR(csdev->devt);
+	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size;
@@ -307,6 +313,10 @@ static ssize_t store_max_read_buffer_kb(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
+	info = comedi_file_info_from_minor(minor);
+	if (!info)
+		return -ENODEV;
+
 	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_read_subdevice(info);
@@ -322,11 +332,16 @@ static ssize_t store_max_read_buffer_kb(struct device *csdev,
 static ssize_t show_read_buffer_kb(struct device *csdev,
 				   struct device_attribute *attr, char *buf)
 {
-	struct comedi_file_info *info = dev_get_drvdata(csdev);
+	unsigned int minor = MINOR(csdev->devt);
+	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
+	info = comedi_file_info_from_minor(minor);
+	if (!info)
+		return -ENODEV;
+
 	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_read_subdevice(info);
@@ -341,7 +356,8 @@ static ssize_t store_read_buffer_kb(struct device *csdev,
 				    struct device_attribute *attr,
 				    const char *buf, size_t count)
 {
-	struct comedi_file_info *info = dev_get_drvdata(csdev);
+	unsigned int minor = MINOR(csdev->devt);
+	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size;
@@ -354,6 +370,10 @@ static ssize_t store_read_buffer_kb(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
+	info = comedi_file_info_from_minor(minor);
+	if (!info)
+		return -ENODEV;
+
 	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_read_subdevice(info);
@@ -370,11 +390,16 @@ static ssize_t show_max_write_buffer_kb(struct device *csdev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	struct comedi_file_info *info = dev_get_drvdata(csdev);
+	unsigned int minor = MINOR(csdev->devt);
+	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
+	info = comedi_file_info_from_minor(minor);
+	if (!info)
+		return -ENODEV;
+
 	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_write_subdevice(info);
@@ -389,7 +414,8 @@ static ssize_t store_max_write_buffer_kb(struct device *csdev,
 					 struct device_attribute *attr,
 					 const char *buf, size_t count)
 {
-	struct comedi_file_info *info = dev_get_drvdata(csdev);
+	unsigned int minor = MINOR(csdev->devt);
+	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size;
@@ -402,6 +428,10 @@ static ssize_t store_max_write_buffer_kb(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
+	info = comedi_file_info_from_minor(minor);
+	if (!info)
+		return -ENODEV;
+
 	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_write_subdevice(info);
@@ -417,11 +447,16 @@ static ssize_t store_max_write_buffer_kb(struct device *csdev,
 static ssize_t show_write_buffer_kb(struct device *csdev,
 				    struct device_attribute *attr, char *buf)
 {
-	struct comedi_file_info *info = dev_get_drvdata(csdev);
+	unsigned int minor = MINOR(csdev->devt);
+	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
+	info = comedi_file_info_from_minor(minor);
+	if (!info)
+		return -ENODEV;
+
 	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_write_subdevice(info);
@@ -436,7 +471,8 @@ static ssize_t store_write_buffer_kb(struct device *csdev,
 				     struct device_attribute *attr,
 				     const char *buf, size_t count)
 {
-	struct comedi_file_info *info = dev_get_drvdata(csdev);
+	unsigned int minor = MINOR(csdev->devt);
+	struct comedi_file_info *info;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	unsigned int size;
@@ -449,6 +485,10 @@ static ssize_t store_write_buffer_kb(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
+	info = comedi_file_info_from_minor(minor);
+	if (!info)
+		return -ENODEV;
+
 	dev = info->device;
 	mutex_lock(&dev->mutex);
 	s = comedi_write_subdevice(info);
@@ -2416,7 +2456,6 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 			      MKDEV(COMEDI_MAJOR, i), NULL, "comedi%i", i);
 	if (!IS_ERR(csdev))
 		dev->class_dev = csdev;
-	dev_set_drvdata(csdev, info);
 
 	/* Note: dev->mutex needs to be unlocked by the caller. */
 	return dev;
@@ -2482,7 +2521,6 @@ int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 			      dev->minor, s->index);
 	if (!IS_ERR(csdev))
 		s->class_dev = csdev;
-	dev_set_drvdata(csdev, info);
 
 	return 0;
 }

commit 7f4656c5f780520262f7eeda926844761e859c6b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:08 2013 +0100

    staging: comedi: get mutex before subdevice in attribute functions
    
    The comedi device attribute functions such as
    `show_read_buffer_kb()` or `show_write_buffer_kb()` call
    `comedi_read_subdevice()` or `comedi_write_subdevice()` without
    acquiring the comedi device's mutex first, although the functions do
    acquire the mutex afterwards.  Change them to acquire the mutex first.
    This is consistent with most of the comedi device file operation
    functions (apart from `comedi_read()` and `comedi_write()` which
    probably need looking at).
    
    Despite the use of the mutex, there are still race conditions as the
    `struct comedi_file_info *info` variable value set before acquiring the
    mutex could be stale after acquiring the mutex.  This problem will be
    dealt with once reference counting has been implemented for the comedi
    devices.
    
    This patch also adds local variable `struct comedi_device *dev` to the
    functions to reduce the use of the `info` variable a little bit.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f379335073a0..d06b13a0ed57 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -276,13 +276,16 @@ static ssize_t show_max_read_buffer_kb(struct device *csdev,
 				       struct device_attribute *attr, char *buf)
 {
 	struct comedi_file_info *info = dev_get_drvdata(csdev);
-	struct comedi_subdevice *s = comedi_read_subdevice(info);
+	struct comedi_device *dev;
+	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
-	mutex_lock(&info->device->mutex);
+	dev = info->device;
+	mutex_lock(&dev->mutex);
+	s = comedi_read_subdevice(info);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
 		size = s->async->max_bufsize / 1024;
-	mutex_unlock(&info->device->mutex);
+	mutex_unlock(&dev->mutex);
 
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
@@ -292,7 +295,8 @@ static ssize_t store_max_read_buffer_kb(struct device *csdev,
 					const char *buf, size_t count)
 {
 	struct comedi_file_info *info = dev_get_drvdata(csdev);
-	struct comedi_subdevice *s = comedi_read_subdevice(info);
+	struct comedi_device *dev;
+	struct comedi_subdevice *s;
 	unsigned int size;
 	int err;
 
@@ -303,12 +307,14 @@ static ssize_t store_max_read_buffer_kb(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
-	mutex_lock(&info->device->mutex);
+	dev = info->device;
+	mutex_lock(&dev->mutex);
+	s = comedi_read_subdevice(info);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
 		s->async->max_bufsize = size;
 	else
 		err = -EINVAL;
-	mutex_unlock(&info->device->mutex);
+	mutex_unlock(&dev->mutex);
 
 	return err ? err : count;
 }
@@ -317,13 +323,16 @@ static ssize_t show_read_buffer_kb(struct device *csdev,
 				   struct device_attribute *attr, char *buf)
 {
 	struct comedi_file_info *info = dev_get_drvdata(csdev);
-	struct comedi_subdevice *s = comedi_read_subdevice(info);
+	struct comedi_device *dev;
+	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
-	mutex_lock(&info->device->mutex);
+	dev = info->device;
+	mutex_lock(&dev->mutex);
+	s = comedi_read_subdevice(info);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
 		size = s->async->prealloc_bufsz / 1024;
-	mutex_unlock(&info->device->mutex);
+	mutex_unlock(&dev->mutex);
 
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
@@ -333,7 +342,8 @@ static ssize_t store_read_buffer_kb(struct device *csdev,
 				    const char *buf, size_t count)
 {
 	struct comedi_file_info *info = dev_get_drvdata(csdev);
-	struct comedi_subdevice *s = comedi_read_subdevice(info);
+	struct comedi_device *dev;
+	struct comedi_subdevice *s;
 	unsigned int size;
 	int err;
 
@@ -344,12 +354,14 @@ static ssize_t store_read_buffer_kb(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
-	mutex_lock(&info->device->mutex);
+	dev = info->device;
+	mutex_lock(&dev->mutex);
+	s = comedi_read_subdevice(info);
 	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
-		err = resize_async_buffer(info->device, s, s->async, size);
+		err = resize_async_buffer(dev, s, s->async, size);
 	else
 		err = -EINVAL;
-	mutex_unlock(&info->device->mutex);
+	mutex_unlock(&dev->mutex);
 
 	return err ? err : count;
 }
@@ -359,13 +371,16 @@ static ssize_t show_max_write_buffer_kb(struct device *csdev,
 					char *buf)
 {
 	struct comedi_file_info *info = dev_get_drvdata(csdev);
-	struct comedi_subdevice *s = comedi_write_subdevice(info);
+	struct comedi_device *dev;
+	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
-	mutex_lock(&info->device->mutex);
+	dev = info->device;
+	mutex_lock(&dev->mutex);
+	s = comedi_write_subdevice(info);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
 		size = s->async->max_bufsize / 1024;
-	mutex_unlock(&info->device->mutex);
+	mutex_unlock(&dev->mutex);
 
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
@@ -375,7 +390,8 @@ static ssize_t store_max_write_buffer_kb(struct device *csdev,
 					 const char *buf, size_t count)
 {
 	struct comedi_file_info *info = dev_get_drvdata(csdev);
-	struct comedi_subdevice *s = comedi_write_subdevice(info);
+	struct comedi_device *dev;
+	struct comedi_subdevice *s;
 	unsigned int size;
 	int err;
 
@@ -386,12 +402,14 @@ static ssize_t store_max_write_buffer_kb(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
-	mutex_lock(&info->device->mutex);
+	dev = info->device;
+	mutex_lock(&dev->mutex);
+	s = comedi_write_subdevice(info);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
 		s->async->max_bufsize = size;
 	else
 		err = -EINVAL;
-	mutex_unlock(&info->device->mutex);
+	mutex_unlock(&dev->mutex);
 
 	return err ? err : count;
 }
@@ -400,13 +418,16 @@ static ssize_t show_write_buffer_kb(struct device *csdev,
 				    struct device_attribute *attr, char *buf)
 {
 	struct comedi_file_info *info = dev_get_drvdata(csdev);
-	struct comedi_subdevice *s = comedi_write_subdevice(info);
+	struct comedi_device *dev;
+	struct comedi_subdevice *s;
 	unsigned int size = 0;
 
-	mutex_lock(&info->device->mutex);
+	dev = info->device;
+	mutex_lock(&dev->mutex);
+	s = comedi_write_subdevice(info);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
 		size = s->async->prealloc_bufsz / 1024;
-	mutex_unlock(&info->device->mutex);
+	mutex_unlock(&dev->mutex);
 
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
@@ -416,7 +437,8 @@ static ssize_t store_write_buffer_kb(struct device *csdev,
 				     const char *buf, size_t count)
 {
 	struct comedi_file_info *info = dev_get_drvdata(csdev);
-	struct comedi_subdevice *s = comedi_write_subdevice(info);
+	struct comedi_device *dev;
+	struct comedi_subdevice *s;
 	unsigned int size;
 	int err;
 
@@ -427,12 +449,14 @@ static ssize_t store_write_buffer_kb(struct device *csdev,
 		return -EINVAL;
 	size *= 1024;
 
-	mutex_lock(&info->device->mutex);
+	dev = info->device;
+	mutex_lock(&dev->mutex);
+	s = comedi_write_subdevice(info);
 	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
-		err = resize_async_buffer(info->device, s, s->async, size);
+		err = resize_async_buffer(dev, s, s->async, size);
 	else
 		err = -EINVAL;
-	mutex_unlock(&info->device->mutex);
+	mutex_unlock(&dev->mutex);
 
 	return err ? err : count;
 }

commit 7a4e5a9f3c9f002b36fa91c1accae8f9b5c66cc8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:07 2013 +0100

    staging: comedi: rename dev parameter of device attribute functions
    
    Most of the comedi core uses the identifier `dev` to point to a `struct
    comedi_device`.  The device sysfs attribute functions such as
    `show_max_read_buffer_kb()` use the parameter id `dev` to point to a
    `struct device`.  Rename the parameter to `csdev` for "class device" for
    consistency with the functions that call `device_create()` to create
    these class devices (`comedi_alloc_board_minor()` and
    `comedi_alloc_subdevice_minor()`).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b73d8066cd15..f379335073a0 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -272,10 +272,10 @@ static int resize_async_buffer(struct comedi_device *dev,
 
 /* sysfs attribute files */
 
-static ssize_t show_max_read_buffer_kb(struct device *dev,
+static ssize_t show_max_read_buffer_kb(struct device *csdev,
 				       struct device_attribute *attr, char *buf)
 {
-	struct comedi_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(csdev);
 	struct comedi_subdevice *s = comedi_read_subdevice(info);
 	unsigned int size = 0;
 
@@ -287,11 +287,11 @@ static ssize_t show_max_read_buffer_kb(struct device *dev,
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
-static ssize_t store_max_read_buffer_kb(struct device *dev,
+static ssize_t store_max_read_buffer_kb(struct device *csdev,
 					struct device_attribute *attr,
 					const char *buf, size_t count)
 {
-	struct comedi_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(csdev);
 	struct comedi_subdevice *s = comedi_read_subdevice(info);
 	unsigned int size;
 	int err;
@@ -313,10 +313,10 @@ static ssize_t store_max_read_buffer_kb(struct device *dev,
 	return err ? err : count;
 }
 
-static ssize_t show_read_buffer_kb(struct device *dev,
+static ssize_t show_read_buffer_kb(struct device *csdev,
 				   struct device_attribute *attr, char *buf)
 {
-	struct comedi_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(csdev);
 	struct comedi_subdevice *s = comedi_read_subdevice(info);
 	unsigned int size = 0;
 
@@ -328,11 +328,11 @@ static ssize_t show_read_buffer_kb(struct device *dev,
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
-static ssize_t store_read_buffer_kb(struct device *dev,
+static ssize_t store_read_buffer_kb(struct device *csdev,
 				    struct device_attribute *attr,
 				    const char *buf, size_t count)
 {
-	struct comedi_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(csdev);
 	struct comedi_subdevice *s = comedi_read_subdevice(info);
 	unsigned int size;
 	int err;
@@ -354,11 +354,11 @@ static ssize_t store_read_buffer_kb(struct device *dev,
 	return err ? err : count;
 }
 
-static ssize_t show_max_write_buffer_kb(struct device *dev,
+static ssize_t show_max_write_buffer_kb(struct device *csdev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	struct comedi_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(csdev);
 	struct comedi_subdevice *s = comedi_write_subdevice(info);
 	unsigned int size = 0;
 
@@ -370,11 +370,11 @@ static ssize_t show_max_write_buffer_kb(struct device *dev,
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
-static ssize_t store_max_write_buffer_kb(struct device *dev,
+static ssize_t store_max_write_buffer_kb(struct device *csdev,
 					 struct device_attribute *attr,
 					 const char *buf, size_t count)
 {
-	struct comedi_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(csdev);
 	struct comedi_subdevice *s = comedi_write_subdevice(info);
 	unsigned int size;
 	int err;
@@ -396,10 +396,10 @@ static ssize_t store_max_write_buffer_kb(struct device *dev,
 	return err ? err : count;
 }
 
-static ssize_t show_write_buffer_kb(struct device *dev,
+static ssize_t show_write_buffer_kb(struct device *csdev,
 				    struct device_attribute *attr, char *buf)
 {
-	struct comedi_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(csdev);
 	struct comedi_subdevice *s = comedi_write_subdevice(info);
 	unsigned int size = 0;
 
@@ -411,11 +411,11 @@ static ssize_t show_write_buffer_kb(struct device *dev,
 	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
-static ssize_t store_write_buffer_kb(struct device *dev,
+static ssize_t store_write_buffer_kb(struct device *csdev,
 				     struct device_attribute *attr,
 				     const char *buf, size_t count)
 {
-	struct comedi_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(csdev);
 	struct comedi_subdevice *s = comedi_write_subdevice(info);
 	unsigned int size;
 	int err;

commit 0918e595ae45d99e0bd8a9950a0f0cb0e2a9c948
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:06 2013 +0100

    staging: comedi: remove hardware_device from struct comedi_device_info
    
    The `hardware_device` member of `struct comedi_device_info` is only set
    to point to a hardware device by the auto-configuration code (specifically
    `comedi_alloc_board_minor() with a non-NULL `hardware_device` parameter)
    so that it can be found again by the auto-unconfiguration code
    (specifically `comedi_release_hardware_device()`).  However, as
    `info->device->hw_dev` (where `info` is a pointer to the `struct
    comedi_device_info`) is set to the same value as `info->hardware_device`
    (by calling `comedi_set_hw_dev()` with the same hardware device pointer)
    we can look for that instead, so there is no need for the
    `hardware_device` member any more.  Get rid of it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 00481357a7b8..b73d8066cd15 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -85,7 +85,6 @@ struct comedi_file_info {
 	struct comedi_device *device;
 	struct comedi_subdevice *read_subdevice;
 	struct comedi_subdevice *write_subdevice;
-	struct device *hardware_device;
 };
 
 static DEFINE_MUTEX(comedi_board_minor_table_lock);
@@ -2368,7 +2367,6 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 		return ERR_PTR(-ENOMEM);
 	}
 	info->device = dev;
-	info->hardware_device = hardware_device;
 	comedi_device_init(dev);
 	comedi_set_hw_dev(dev, hardware_device);
 	mutex_lock(&dev->mutex);
@@ -2415,7 +2413,7 @@ void comedi_release_hardware_device(struct device *hardware_device)
 	     minor++) {
 		mutex_lock(&comedi_board_minor_table_lock);
 		info = comedi_board_minor_table[minor];
-		if (info && info->hardware_device == hardware_device) {
+		if (info && info->device->hw_dev == hardware_device) {
 			comedi_board_minor_table[minor] = NULL;
 			mutex_unlock(&comedi_board_minor_table_lock);
 			comedi_free_board_file_info(info);

commit ea1cc3973a6f3832956d99f74b20970a4e71bd37
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:05 2013 +0100

    staging: comedi: remove comedi_clear_minor()
    
    `comedi_clear_minor()` calls either `comedi_clear_board_minor()` or
    `comedi_clear_subdevice_minor()` depending on its minor device number
    parameter.  The one it calls only depends on where it is called from, so
    bypass the calls to `comedi_clear_minor()` and remove it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c57f853d3c46..00481357a7b8 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -150,14 +150,6 @@ static struct comedi_file_info *comedi_clear_subdevice_minor(unsigned minor)
 	return info;
 }
 
-static struct comedi_file_info *comedi_clear_minor(unsigned minor)
-{
-	if (minor < COMEDI_NUM_BOARD_MINORS)
-		return comedi_clear_board_minor(minor);
-	else
-		return comedi_clear_subdevice_minor(minor);
-}
-
 static void comedi_free_board_file_info(struct comedi_file_info *info)
 {
 	if (info) {
@@ -1745,7 +1737,7 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 			    dev->minor >= comedi_num_legacy_minors) {
 				/* Successfully unconfigured a dynamically
 				 * allocated device.  Try and remove it. */
-				info = comedi_clear_minor(dev->minor);
+				info = comedi_clear_board_minor(dev->minor);
 				if (info) {
 					mutex_unlock(&dev->mutex);
 					comedi_free_board_file_info(info);
@@ -2411,7 +2403,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 static void comedi_free_board_minor(unsigned minor)
 {
 	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
-	comedi_free_board_file_info(comedi_clear_minor(minor));
+	comedi_free_board_file_info(comedi_clear_board_minor(minor));
 }
 
 void comedi_release_hardware_device(struct device *hardware_device)
@@ -2485,7 +2477,7 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 	BUG_ON(s->minor >= COMEDI_NUM_MINORS);
 	BUG_ON(s->minor < COMEDI_NUM_BOARD_MINORS);
 
-	info = comedi_clear_minor(s->minor);
+	info = comedi_clear_subdevice_minor(s->minor);
 	if (s->class_dev) {
 		device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, s->minor));
 		s->class_dev = NULL;

commit 5b7dba1bdda5b5864b61d28e32f860510e9a660f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:04 2013 +0100

    staging: comedi: separate board and subdevice minor tables
    
    The comedi core reserves minor device numbers from 0 to
    `COMEDI_NUM_BOARD_MINORS - 1` (0 to 0x30 - 1) for the main comedi
    "board" devices and reserves minor device numbers from
    `COMEDI_NUM_BOARD_MINORS` to `COMEDI_NUM_MINORS - 1` (0x30 to 0x100 - 1)
    for comedi subdevices (or at least those that claim to support
    asynchronous comedi commands).  There is an array
    `comedi_file_info_table[COMEDI_NUM_MINORS]` used to hold pointers to
    information for each board minor device number and subdevice minor
    device number that has been allocated (with NULL pointers for those not
    allocated), along with a protective lock `comedi_file_info_table_lock`.
    
    Since the ranges of board minor device numbers and subdevice minor
    device numbers do not overlap, we can use separate tables and separate
    locks for the different types of minor device numbers.  This will allow
    us to use different pointer types for the elements of each table in the
    future without just using a generic `void *`.  (At the moment, the table
    elements point to a `struct comedi_file_info` allocated dynamically for
    each allocated board minor device or subdevice minor device, but I plan
    to get rid of that data structure.)
    
    Replace `comedi_file_info_table[COMEDI_NUM_MINORS]` with two new arrays
    of the same type, `comedi_board_minor_table[COMEDI_NUM_BOARD_MINORS]`
    for board minors, and
    `comedi_subdevice_minor_table[COMEDI_NUM_SUBDEVICE_MINORS]` for
    subdevice minors (where `COMEDI_NUM_SUBDEVICE_MINORS` is
    `COMEDI_NUM_MINORS - COMEDI_NUM_BOARD_MINORS`).
    `comedi_subdevice_minor_table[]` is indexed by the subdevice minor
    number minus `COMEDI_NUM_BOARD_MINORS` since `COMEDI_NUM_BOARD_MINORS`
    is the first valid subdevice minor number.
    
    Replace `comedi_file_info_table_lock` with
    `comedi_board_minor_table_lock` for board minors and
    `comedi_subdevice_minor_table_lock` for subdevice minors.
    
    Refactor `comedi_clear_minor()` to call one of two new functions
    `comedi_clear_board_minor()` and `comedi_clear_subdevice_minor()`
    depending on the minor device number passed as a parameter.  Similarly,
    refactor `comedi_file_info_from_minor()` to call one of two new
    functions `comedi_file_info_from_board_minor()` and
    `comedi_file_info_from_subdevice_minor()` depending on the minor device
    number parameter.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c99b28943c7d..c57f853d3c46 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -50,6 +50,8 @@
 #include "comedi_internal.h"
 
 #define COMEDI_NUM_MINORS 0x100
+#define COMEDI_NUM_SUBDEVICE_MINORS	\
+	(COMEDI_NUM_MINORS - COMEDI_NUM_BOARD_MINORS)
 
 #ifdef CONFIG_COMEDI_DEBUG
 int comedi_debug;
@@ -86,8 +88,14 @@ struct comedi_file_info {
 	struct device *hardware_device;
 };
 
-static DEFINE_MUTEX(comedi_file_info_table_lock);
-static struct comedi_file_info *comedi_file_info_table[COMEDI_NUM_MINORS];
+static DEFINE_MUTEX(comedi_board_minor_table_lock);
+static struct comedi_file_info
+*comedi_board_minor_table[COMEDI_NUM_BOARD_MINORS];
+
+static DEFINE_MUTEX(comedi_subdevice_minor_table_lock);
+/* Note: indexed by minor - COMEDI_NUM_BOARD_MINORS. */
+static struct comedi_file_info
+*comedi_subdevice_minor_table[COMEDI_NUM_SUBDEVICE_MINORS];
 
 static struct class *comedi_class;
 static struct cdev comedi_cdev;
@@ -119,17 +127,37 @@ static void comedi_device_cleanup(struct comedi_device *dev)
 	mutex_destroy(&dev->mutex);
 }
 
-static struct comedi_file_info *comedi_clear_minor(unsigned minor)
+static struct comedi_file_info *comedi_clear_board_minor(unsigned minor)
 {
 	struct comedi_file_info *info;
 
-	mutex_lock(&comedi_file_info_table_lock);
-	info = comedi_file_info_table[minor];
-	comedi_file_info_table[minor] = NULL;
-	mutex_unlock(&comedi_file_info_table_lock);
+	mutex_lock(&comedi_board_minor_table_lock);
+	info = comedi_board_minor_table[minor];
+	comedi_board_minor_table[minor] = NULL;
+	mutex_unlock(&comedi_board_minor_table_lock);
 	return info;
 }
 
+static struct comedi_file_info *comedi_clear_subdevice_minor(unsigned minor)
+{
+	struct comedi_file_info *info;
+	unsigned int i = minor - COMEDI_NUM_BOARD_MINORS;
+
+	mutex_lock(&comedi_subdevice_minor_table_lock);
+	info = comedi_subdevice_minor_table[i];
+	comedi_subdevice_minor_table[i] = NULL;
+	mutex_unlock(&comedi_subdevice_minor_table_lock);
+	return info;
+}
+
+static struct comedi_file_info *comedi_clear_minor(unsigned minor)
+{
+	if (minor < COMEDI_NUM_BOARD_MINORS)
+		return comedi_clear_board_minor(minor);
+	else
+		return comedi_clear_subdevice_minor(minor);
+}
+
 static void comedi_free_board_file_info(struct comedi_file_info *info)
 {
 	if (info) {
@@ -146,17 +174,39 @@ static void comedi_free_board_file_info(struct comedi_file_info *info)
 	}
 }
 
-static struct comedi_file_info *comedi_file_info_from_minor(unsigned minor)
+static struct comedi_file_info
+*comedi_file_info_from_board_minor(unsigned minor)
 {
 	struct comedi_file_info *info;
 
-	BUG_ON(minor >= COMEDI_NUM_MINORS);
-	mutex_lock(&comedi_file_info_table_lock);
-	info = comedi_file_info_table[minor];
-	mutex_unlock(&comedi_file_info_table_lock);
+	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
+	mutex_lock(&comedi_board_minor_table_lock);
+	info = comedi_board_minor_table[minor];
+	mutex_unlock(&comedi_board_minor_table_lock);
 	return info;
 }
 
+static struct comedi_file_info
+*comedi_file_info_from_subdevice_minor(unsigned minor)
+{
+	struct comedi_file_info *info;
+	unsigned int i = minor - COMEDI_NUM_BOARD_MINORS;
+
+	BUG_ON(i >= COMEDI_NUM_SUBDEVICE_MINORS);
+	mutex_lock(&comedi_subdevice_minor_table_lock);
+	info = comedi_subdevice_minor_table[i];
+	mutex_unlock(&comedi_subdevice_minor_table_lock);
+	return info;
+}
+
+static struct comedi_file_info *comedi_file_info_from_minor(unsigned minor)
+{
+	if (minor < COMEDI_NUM_BOARD_MINORS)
+		return comedi_file_info_from_board_minor(minor);
+	else
+		return comedi_file_info_from_subdevice_minor(minor);
+}
+
 static struct comedi_device *
 comedi_dev_from_file_info(struct comedi_file_info *info)
 {
@@ -2330,15 +2380,15 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	comedi_device_init(dev);
 	comedi_set_hw_dev(dev, hardware_device);
 	mutex_lock(&dev->mutex);
-	mutex_lock(&comedi_file_info_table_lock);
+	mutex_lock(&comedi_board_minor_table_lock);
 	for (i = hardware_device ? comedi_num_legacy_minors : 0;
 	     i < COMEDI_NUM_BOARD_MINORS; ++i) {
-		if (comedi_file_info_table[i] == NULL) {
-			comedi_file_info_table[i] = info;
+		if (comedi_board_minor_table[i] == NULL) {
+			comedi_board_minor_table[i] = info;
 			break;
 		}
 	}
-	mutex_unlock(&comedi_file_info_table_lock);
+	mutex_unlock(&comedi_board_minor_table_lock);
 	if (i == COMEDI_NUM_BOARD_MINORS) {
 		mutex_unlock(&dev->mutex);
 		comedi_device_cleanup(dev);
@@ -2371,15 +2421,15 @@ void comedi_release_hardware_device(struct device *hardware_device)
 
 	for (minor = comedi_num_legacy_minors; minor < COMEDI_NUM_BOARD_MINORS;
 	     minor++) {
-		mutex_lock(&comedi_file_info_table_lock);
-		info = comedi_file_info_table[minor];
+		mutex_lock(&comedi_board_minor_table_lock);
+		info = comedi_board_minor_table[minor];
 		if (info && info->hardware_device == hardware_device) {
-			comedi_file_info_table[minor] = NULL;
-			mutex_unlock(&comedi_file_info_table_lock);
+			comedi_board_minor_table[minor] = NULL;
+			mutex_unlock(&comedi_board_minor_table_lock);
 			comedi_free_board_file_info(info);
 			break;
 		}
-		mutex_unlock(&comedi_file_info_table_lock);
+		mutex_unlock(&comedi_board_minor_table_lock);
 	}
 }
 
@@ -2398,19 +2448,20 @@ int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 		info->read_subdevice = s;
 	if (s->subdev_flags & SDF_CMD_WRITE)
 		info->write_subdevice = s;
-	mutex_lock(&comedi_file_info_table_lock);
-	for (i = COMEDI_NUM_BOARD_MINORS; i < COMEDI_NUM_MINORS; ++i) {
-		if (comedi_file_info_table[i] == NULL) {
-			comedi_file_info_table[i] = info;
+	mutex_lock(&comedi_subdevice_minor_table_lock);
+	for (i = 0; i < COMEDI_NUM_SUBDEVICE_MINORS; ++i) {
+		if (comedi_subdevice_minor_table[i] == NULL) {
+			comedi_subdevice_minor_table[i] = info;
 			break;
 		}
 	}
-	mutex_unlock(&comedi_file_info_table_lock);
-	if (i == COMEDI_NUM_MINORS) {
+	mutex_unlock(&comedi_subdevice_minor_table_lock);
+	if (i == COMEDI_NUM_SUBDEVICE_MINORS) {
 		kfree(info);
 		pr_err("comedi: error: ran out of minor numbers for subdevice files.\n");
 		return -EBUSY;
 	}
+	i += COMEDI_NUM_BOARD_MINORS;
 	s->minor = i;
 	csdev = device_create(comedi_class, dev->class_dev,
 			      MKDEV(COMEDI_MAJOR, i), NULL, "comedi%i_subd%i",
@@ -2515,8 +2566,10 @@ static void __exit comedi_cleanup(void)
 	int i;
 
 	comedi_cleanup_board_minors();
-	for (i = 0; i < COMEDI_NUM_MINORS; ++i)
-		BUG_ON(comedi_file_info_table[i]);
+	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i)
+		BUG_ON(comedi_board_minor_table[i]);
+	for (i = 0; i < COMEDI_NUM_SUBDEVICE_MINORS; ++i)
+		BUG_ON(comedi_subdevice_minor_table[i]);
 
 	class_destroy(comedi_class);
 	cdev_del(&comedi_cdev);

commit 8907cf6c5da2bb6d877c8ba59f90aff1b72cd814
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:03 2013 +0100

    staging: comedi: remove COMEDI_FIRST_SUBDEVICE_MINOR
    
    The macro `COMEDI_FIRST_SUBDEVICE_MINOR` just expands to another macro
    `COMEDI_NUM_BOARD_MINORS`.  Replace uses of
    `COMEDI_FIRST_SUBDEVICE_MINOR` with `COMEDI_NUM_BOARD_MINORS` and get
    rid of the former.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e69e9d453433..c99b28943c7d 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -50,7 +50,6 @@
 #include "comedi_internal.h"
 
 #define COMEDI_NUM_MINORS 0x100
-#define COMEDI_FIRST_SUBDEVICE_MINOR COMEDI_NUM_BOARD_MINORS
 
 #ifdef CONFIG_COMEDI_DEBUG
 int comedi_debug;
@@ -2400,7 +2399,7 @@ int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 	if (s->subdev_flags & SDF_CMD_WRITE)
 		info->write_subdevice = s;
 	mutex_lock(&comedi_file_info_table_lock);
-	for (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_MINORS; ++i) {
+	for (i = COMEDI_NUM_BOARD_MINORS; i < COMEDI_NUM_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
 			comedi_file_info_table[i] = info;
 			break;
@@ -2433,7 +2432,7 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 		return;
 
 	BUG_ON(s->minor >= COMEDI_NUM_MINORS);
-	BUG_ON(s->minor < COMEDI_FIRST_SUBDEVICE_MINOR);
+	BUG_ON(s->minor < COMEDI_NUM_BOARD_MINORS);
 
 	info = comedi_clear_minor(s->minor);
 	if (s->class_dev) {

commit eda56825d582901b6a1c36fb8d754a3ebee0388c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:02 2013 +0100

    staging: comedi: move COMEDI_NUM_MINORS and COMEDI_FIRST_SUBDEVICE_MINOR
    
    The macro definitions `COMEDI_NUM_MINORS` and
    `COMEDI_FIRST_SUBDEVICE_MINOR` are only used in "comedi_fops.c" so move
    them to there from "comedidev.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 873860ff8bc1..e69e9d453433 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -49,6 +49,9 @@
 
 #include "comedi_internal.h"
 
+#define COMEDI_NUM_MINORS 0x100
+#define COMEDI_FIRST_SUBDEVICE_MINOR COMEDI_NUM_BOARD_MINORS
+
 #ifdef CONFIG_COMEDI_DEBUG
 int comedi_debug;
 EXPORT_SYMBOL(comedi_debug);

commit da619f5575e111f176f9f6d888dbeaf3210ff1f2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:01 2013 +0100

    staging: comedi: change comedi_file_info_table_lock to mutex
    
    The spin-lock `comedi_file_info_table_lock` is used to protect against
    simultaneous modification and access of `comedi_file_info_table[]`.
    Change it from a spin-lock to a mutex as it is only used in contexts
    where sleeping is allowed.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b3e533759174..873860ff8bc1 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -84,7 +84,7 @@ struct comedi_file_info {
 	struct device *hardware_device;
 };
 
-static DEFINE_SPINLOCK(comedi_file_info_table_lock);
+static DEFINE_MUTEX(comedi_file_info_table_lock);
 static struct comedi_file_info *comedi_file_info_table[COMEDI_NUM_MINORS];
 
 static struct class *comedi_class;
@@ -121,10 +121,10 @@ static struct comedi_file_info *comedi_clear_minor(unsigned minor)
 {
 	struct comedi_file_info *info;
 
-	spin_lock(&comedi_file_info_table_lock);
+	mutex_lock(&comedi_file_info_table_lock);
 	info = comedi_file_info_table[minor];
 	comedi_file_info_table[minor] = NULL;
-	spin_unlock(&comedi_file_info_table_lock);
+	mutex_unlock(&comedi_file_info_table_lock);
 	return info;
 }
 
@@ -149,9 +149,9 @@ static struct comedi_file_info *comedi_file_info_from_minor(unsigned minor)
 	struct comedi_file_info *info;
 
 	BUG_ON(minor >= COMEDI_NUM_MINORS);
-	spin_lock(&comedi_file_info_table_lock);
+	mutex_lock(&comedi_file_info_table_lock);
 	info = comedi_file_info_table[minor];
-	spin_unlock(&comedi_file_info_table_lock);
+	mutex_unlock(&comedi_file_info_table_lock);
 	return info;
 }
 
@@ -2328,7 +2328,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	comedi_device_init(dev);
 	comedi_set_hw_dev(dev, hardware_device);
 	mutex_lock(&dev->mutex);
-	spin_lock(&comedi_file_info_table_lock);
+	mutex_lock(&comedi_file_info_table_lock);
 	for (i = hardware_device ? comedi_num_legacy_minors : 0;
 	     i < COMEDI_NUM_BOARD_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
@@ -2336,7 +2336,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 			break;
 		}
 	}
-	spin_unlock(&comedi_file_info_table_lock);
+	mutex_unlock(&comedi_file_info_table_lock);
 	if (i == COMEDI_NUM_BOARD_MINORS) {
 		mutex_unlock(&dev->mutex);
 		comedi_device_cleanup(dev);
@@ -2369,15 +2369,15 @@ void comedi_release_hardware_device(struct device *hardware_device)
 
 	for (minor = comedi_num_legacy_minors; minor < COMEDI_NUM_BOARD_MINORS;
 	     minor++) {
-		spin_lock(&comedi_file_info_table_lock);
+		mutex_lock(&comedi_file_info_table_lock);
 		info = comedi_file_info_table[minor];
 		if (info && info->hardware_device == hardware_device) {
 			comedi_file_info_table[minor] = NULL;
-			spin_unlock(&comedi_file_info_table_lock);
+			mutex_unlock(&comedi_file_info_table_lock);
 			comedi_free_board_file_info(info);
 			break;
 		}
-		spin_unlock(&comedi_file_info_table_lock);
+		mutex_unlock(&comedi_file_info_table_lock);
 	}
 }
 
@@ -2396,14 +2396,14 @@ int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 		info->read_subdevice = s;
 	if (s->subdev_flags & SDF_CMD_WRITE)
 		info->write_subdevice = s;
-	spin_lock(&comedi_file_info_table_lock);
+	mutex_lock(&comedi_file_info_table_lock);
 	for (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
 			comedi_file_info_table[i] = info;
 			break;
 		}
 	}
-	spin_unlock(&comedi_file_info_table_lock);
+	mutex_unlock(&comedi_file_info_table_lock);
 	if (i == COMEDI_NUM_MINORS) {
 		kfree(info);
 		pr_err("comedi: error: ran out of minor numbers for subdevice files.\n");

commit db2e3487a5fa1f650680c672e0742d943039d2cc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:00 2013 +0100

    staging: comedi: set hw_dev in comedi_alloc_board_minor()
    
    Call `comedi_set_hw_dev()` to set the `hw_dev` member of `struct
    comedi_device` in `comedi_alloc_board_minor()` instead of in
    `comedi_auto_config()`.  Don't bother to check for an error returned by
    `comedi_set_hw_dev()` here; it only fails when changing a non-NULL
    pointer to a different non-NULL pointer and since the `struct
    comedi_device` has just been allocated and initialized, its `hw_dev`
    will be NULL already.  Calling `comedi_set_hw_dev()` with a non-NULL
    hardware device pointer increments the kref counter for the hardware
    device.
    
    If `comedi_alloc_board_minor()` fails further down the function, we rely
    on its call to `comedi_device_cleanup()` to call `comedi_clear_hw_dev()`
    (via `comedi_device_detach()` and `cleanup_device()`) to clear `hw_dev`
    and decrement its kref counter.  (That's the "beneficial side-effect"
    mentioned in the patch that replaced `__comedi_device_detach()`.)
    
    Remove the call to `comedi_set_hw_dev()` from `comedi_auto_config()` as
    the call to `comedi_alloc_board_minor()` does it for us.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 229be419b014..b3e533759174 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2326,6 +2326,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	info->device = dev;
 	info->hardware_device = hardware_device;
 	comedi_device_init(dev);
+	comedi_set_hw_dev(dev, hardware_device);
 	mutex_lock(&dev->mutex);
 	spin_lock(&comedi_file_info_table_lock);
 	for (i = hardware_device ? comedi_num_legacy_minors : 0;

commit b2a644b435de1d45bd8b5d4e391c894a662eb1f3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:56 2013 +0100

    staging: comedi: simplify driver module counting
    
    For a legacy device attachment with the `COMEDI_DEVCONFIG` ioctl,
    `do_devconfig_ioctl()` calls `comedi_device_attach()` to find a matching
    device driver and attach the device.  It then tries to increment the
    device driver's module count and if that fails it detaches the device.
    So on successful attachment of a device by the `COMEDI_DEVCONFIG` ioctl,
    the device driver's module count will have been incremented.
    
    `comedi_device_attach()` is called from nowhere else.  It already
    increments the device driver's module count temporarily and decrements
    it again; if it gets as far as calling `comedi_device_postconfig()` the
    module count is decremented within that function.
    
    Simplify the above by removing the decrement of the device driver module
    count from `comedi_device_postconfig()`.  If the call to
    `comedi_device_postconfig()` succeeds, `comedi_device_attach()` will
    return with the module count still incremented, otherwise decrement the
    module count before returning the error.  Don't try and increment the
    module count in `do_devconfig_ioctl()` after a successful return from
    `comedi_device_attach()` as the module count has now already been
    incremented.
    
    `comedi_device_postconfig()` is also called by `comedi_auto_config()`
    which currently has to increment the device driver's module count
    temporarily so that `comedi_device_postconfig()` can decrement it, but
    always returns with no overall change to the module count.  Remove all
    the module count manipulations from `comedi_device_postconfig()`.  There
    is no other reason for `comedi_auto_config()` to increment the device
    driver's module count temporarily, since it is only called (indirectly)
    from the device driver itself (usually via one of the wrappers
    `comedi_pci_auto_config()` or `comedi_usb_auto_config()`).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1c310e790b62..229be419b014 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -520,7 +520,6 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 			      struct comedi_devconfig __user *arg)
 {
 	struct comedi_devconfig it;
-	int ret;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
@@ -551,15 +550,8 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 		/* don't re-use dynamically allocated comedi devices */
 		return -EBUSY;
 
-	ret = comedi_device_attach(dev, &it);
-	if (ret == 0) {
-		if (!try_module_get(dev->driver->module)) {
-			comedi_device_detach(dev);
-			ret = -ENOSYS;
-		}
-	}
-
-	return ret;
+	/* This increments the driver module count on success. */
+	return comedi_device_attach(dev, &it);
 }
 
 /*

commit d9740a0314a744a8f6406c55e033d60c45b67f74
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:55 2013 +0100

    staging: comedi: avoid forward declarations
    
    Move a few functions and variables to avoid a couple of forward
    declarations.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index d80060a14977..1c310e790b62 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -87,8 +87,62 @@ struct comedi_file_info {
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_file_info *comedi_file_info_table[COMEDI_NUM_MINORS];
 
-static struct comedi_file_info *comedi_clear_minor(unsigned minor);
-static void comedi_free_board_file_info(struct comedi_file_info *info);
+static struct class *comedi_class;
+static struct cdev comedi_cdev;
+
+static void comedi_device_init(struct comedi_device *dev)
+{
+	spin_lock_init(&dev->spinlock);
+	mutex_init(&dev->mutex);
+	dev->minor = -1;
+}
+
+static void comedi_device_cleanup(struct comedi_device *dev)
+{
+	struct module *driver_module = NULL;
+
+	if (dev == NULL)
+		return;
+	mutex_lock(&dev->mutex);
+	if (dev->attached)
+		driver_module = dev->driver->module;
+	comedi_device_detach(dev);
+	while (dev->use_count > 0) {
+		if (driver_module)
+			module_put(driver_module);
+		module_put(THIS_MODULE);
+		dev->use_count--;
+	}
+	mutex_unlock(&dev->mutex);
+	mutex_destroy(&dev->mutex);
+}
+
+static struct comedi_file_info *comedi_clear_minor(unsigned minor)
+{
+	struct comedi_file_info *info;
+
+	spin_lock(&comedi_file_info_table_lock);
+	info = comedi_file_info_table[minor];
+	comedi_file_info_table[minor] = NULL;
+	spin_unlock(&comedi_file_info_table_lock);
+	return info;
+}
+
+static void comedi_free_board_file_info(struct comedi_file_info *info)
+{
+	if (info) {
+		struct comedi_device *dev = info->device;
+		if (dev) {
+			if (dev->class_dev) {
+				device_destroy(comedi_class,
+					       MKDEV(COMEDI_MAJOR, dev->minor));
+			}
+			comedi_device_cleanup(dev);
+			kfree(dev);
+		}
+		kfree(info);
+	}
+}
 
 static struct comedi_file_info *comedi_file_info_from_minor(unsigned minor)
 {
@@ -2212,9 +2266,6 @@ static const struct file_operations comedi_fops = {
 	.llseek = noop_llseek,
 };
 
-static struct class *comedi_class;
-static struct cdev comedi_cdev;
-
 void comedi_error(const struct comedi_device *dev, const char *s)
 {
 	dev_err(dev->class_dev, "%s: %s\n", dev->driver->driver_name, s);
@@ -2264,33 +2315,6 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 EXPORT_SYMBOL(comedi_event);
 
-static void comedi_device_init(struct comedi_device *dev)
-{
-	spin_lock_init(&dev->spinlock);
-	mutex_init(&dev->mutex);
-	dev->minor = -1;
-}
-
-static void comedi_device_cleanup(struct comedi_device *dev)
-{
-	struct module *driver_module = NULL;
-
-	if (dev == NULL)
-		return;
-	mutex_lock(&dev->mutex);
-	if (dev->attached)
-		driver_module = dev->driver->module;
-	comedi_device_detach(dev);
-	while (dev->use_count > 0) {
-		if (driver_module)
-			module_put(driver_module);
-		module_put(THIS_MODULE);
-		dev->use_count--;
-	}
-	mutex_unlock(&dev->mutex);
-	mutex_destroy(&dev->mutex);
-}
-
 /* Note: the ->mutex is pre-locked on successful return */
 struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 {
@@ -2339,33 +2363,6 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	return dev;
 }
 
-static struct comedi_file_info *comedi_clear_minor(unsigned minor)
-{
-	struct comedi_file_info *info;
-
-	spin_lock(&comedi_file_info_table_lock);
-	info = comedi_file_info_table[minor];
-	comedi_file_info_table[minor] = NULL;
-	spin_unlock(&comedi_file_info_table_lock);
-	return info;
-}
-
-static void comedi_free_board_file_info(struct comedi_file_info *info)
-{
-	if (info) {
-		struct comedi_device *dev = info->device;
-		if (dev) {
-			if (dev->class_dev) {
-				device_destroy(comedi_class,
-					       MKDEV(COMEDI_MAJOR, dev->minor));
-			}
-			comedi_device_cleanup(dev);
-			kfree(dev);
-		}
-		kfree(info);
-	}
-}
-
 static void comedi_free_board_minor(unsigned minor)
 {
 	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);

commit 8ab4ed6ef1c218cac4270cd20a714b83da6907a3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:54 2013 +0100

    staging: comedi: remove manually unconfigured dynamic devices
    
    If a dynamically allocated (non-legacy, and automatically configured)
    comedi device has been successfully unconfigured by use of the
    `COMEDI_DEVCONFIG` ioctl, then remove the device afterwards.
    (Dynamically identified comedi devices are identified by their minor
    device number being `comedi_num_legacy_minors` or greater.)  This is
    done in `comedi_unlocked_ioctl()` on return from `do_devconfig_ioctl()`.
    
    Note that there is an unlikely race condition with some other thread
    that has just called `comedi_file_info_from_minor()` or
    `comedi_dev_from_minor()` and is about to use the device, but that race
    condition also exists for automatically removed devices and will be
    dealt with properly once reference counting of comedi devices has been
    implemented.  We do avoid a race condition between automatic removal and
    removal by the `COMEDI_DEVCONFIG` ioctl though.
    
    Also add an extra precaution in `do_devconfig_ioctl()` to avoid
    configuring a dynamically allocated device since there is a tight
    window avoiding the race condition where this could happen and the
    device is about to be removed anyway.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a155bf2c6592..d80060a14977 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -87,6 +87,9 @@ struct comedi_file_info {
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_file_info *comedi_file_info_table[COMEDI_NUM_MINORS];
 
+static struct comedi_file_info *comedi_clear_minor(unsigned minor);
+static void comedi_free_board_file_info(struct comedi_file_info *info);
+
 static struct comedi_file_info *comedi_file_info_from_minor(unsigned minor)
 {
 	struct comedi_file_info *info;
@@ -490,6 +493,10 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 		return -EINVAL;
 	}
 
+	if (dev->minor >= comedi_num_legacy_minors)
+		/* don't re-use dynamically allocated comedi devices */
+		return -EBUSY;
+
 	ret = comedi_device_attach(dev, &it);
 	if (ret == 0) {
 		if (!try_module_get(dev->driver->module)) {
@@ -1635,6 +1642,19 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 		}
 		rc = do_devconfig_ioctl(dev,
 					(struct comedi_devconfig __user *)arg);
+		if (rc == 0) {
+			if (arg == 0 &&
+			    dev->minor >= comedi_num_legacy_minors) {
+				/* Successfully unconfigured a dynamically
+				 * allocated device.  Try and remove it. */
+				info = comedi_clear_minor(dev->minor);
+				if (info) {
+					mutex_unlock(&dev->mutex);
+					comedi_free_board_file_info(info);
+					return rc;
+				}
+			}
+		}
 		goto done;
 	}
 

commit 1f423cfcf56052b462c4bceefb950921c9a0f495
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:53 2013 +0100

    staging: comedi: no need to evade comedi_auto_unconfig()
    
    When `comedi_unlocked_ioctl()` handled the `COMEDI_DEVCONFIG` ioctl via
    a call to `do_devconfig()`, this used to be allowed to attach a legacy
    hardware device to any board minor device, and the auto-unconfiguration
    code for non-legacy used to search all board minor devices to find the
    hardware device being removed.  After calling `do_devconfig()`
    successfully, `comedi_unlocked_ioctl()` sets the `hardware_device`
    member of the `struct comedi_file_info` to NULL to stop the
    auto-unconfiguration code finding it by accident and unconfiguring the
    wrong comedi device as a result.
    
    The above is no longer necessary because `do_devconfig()` now only
    allows legacy hardware devices to be attached to comedi board minor
    device numbers below `comedi_num_legacy_minors` and the
    auto-unconfiguration code (particularly
    `comedi_release_hardware_device()`) only searches comedi board minor
    device numbers greater than or equal to `comedi_num_legacy_minors`, so
    there is no overlap.
    
    Remove the now unnecessary setting of `info->hardware_device = NULL` in
    `comedi_unlocked_ioctl()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ffa64228c3cf..a155bf2c6592 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1635,9 +1635,6 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 		}
 		rc = do_devconfig_ioctl(dev,
 					(struct comedi_devconfig __user *)arg);
-		if (rc == 0)
-			/* Evade comedi_auto_unconfig(). */
-			info->hardware_device = NULL;
 		goto done;
 	}
 

commit 38b9722a4414c395c6c1e82cd5f8ee64a23313b8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:52 2013 +0100

    staging: comedi: avoid releasing legacy minors automatically
    
    `comedi_alloc_board_minor()` is called for both reserved "legacy"
    devices created during module initialization, and for dynamically
    created devices (via `comedi_auto_config()`).  All the minor device
    numbers from 0 to `comedi_num_legacy_minors - 1` are for legacy devices
    and all those from `comedi_num_legacy_minors` to
    `COMEDI_NUM_BOARD_MINORS - 1` are for dynamically created devices.
    
    `comedi_release_hardware_device()` is called (via
    `comedi_auto_unconfig()`) when a dynamically created device is being
    removed.  It needs to search the table of minor device numbers to see
    which one is associated with the hardware device.  It currently starts
    the search at minor device number 0.  Change it to start from
    `comedi_num_legacy_minors` to skip over those belonging to legacy
    devices.  Also change `comedi_alloc_board_minor()` to skip the legacy
    devices when searching for a free minor device number for the
    dynamically created device.  (The validity of the `hardware_device`
    parameter is used to distinguish the legacy devices from the dynamically
    created ones.)
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 061b55b48383..ffa64228c3cf 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2295,7 +2295,8 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	comedi_device_init(dev);
 	mutex_lock(&dev->mutex);
 	spin_lock(&comedi_file_info_table_lock);
-	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i) {
+	for (i = hardware_device ? comedi_num_legacy_minors : 0;
+	     i < COMEDI_NUM_BOARD_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
 			comedi_file_info_table[i] = info;
 			break;
@@ -2359,7 +2360,8 @@ void comedi_release_hardware_device(struct device *hardware_device)
 	int minor;
 	struct comedi_file_info *info;
 
-	for (minor = 0; minor < COMEDI_NUM_BOARD_MINORS; minor++) {
+	for (minor = comedi_num_legacy_minors; minor < COMEDI_NUM_BOARD_MINORS;
+	     minor++) {
 		spin_lock(&comedi_file_info_table_lock);
 		info = comedi_file_info_table[minor];
 		if (info && info->hardware_device == hardware_device) {

commit 07778393d9a8dbc4b9306d20a8ecfe053771ba93
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:51 2013 +0100

    staging: comedi: pre-lock mutex on creation of comedi device
    
    Return from `comedi_alloc_board_minor()` with the mutex of the created
    `struct comedi_device` pre-locked.  This allows further initialization
    by the caller without the worry of something getting in there first.
    
    `comedi_auto_config()` no longer needs to check if the device is already
    "attached" since whatever was trying to attach the device would need to
    have locked the mutex first.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f9d0a7242474..061b55b48383 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2274,6 +2274,7 @@ static void comedi_device_cleanup(struct comedi_device *dev)
 	mutex_destroy(&dev->mutex);
 }
 
+/* Note: the ->mutex is pre-locked on successful return */
 struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 {
 	struct comedi_file_info *info;
@@ -2292,6 +2293,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	info->device = dev;
 	info->hardware_device = hardware_device;
 	comedi_device_init(dev);
+	mutex_lock(&dev->mutex);
 	spin_lock(&comedi_file_info_table_lock);
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
@@ -2301,6 +2303,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 	}
 	spin_unlock(&comedi_file_info_table_lock);
 	if (i == COMEDI_NUM_BOARD_MINORS) {
+		mutex_unlock(&dev->mutex);
 		comedi_device_cleanup(dev);
 		kfree(dev);
 		kfree(info);
@@ -2314,6 +2317,7 @@ struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 		dev->class_dev = csdev;
 	dev_set_drvdata(csdev, info);
 
+	/* Note: dev->mutex needs to be unlocked by the caller. */
 	return dev;
 }
 
@@ -2485,6 +2489,9 @@ static int __init comedi_init(void)
 			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 						 COMEDI_NUM_MINORS);
 			return PTR_ERR(dev);
+		} else {
+			/* comedi_alloc_board_minor() locked the mutex */
+			mutex_unlock(&dev->mutex);
 		}
 	}
 

commit 7638ffcb50903d9ddbf605c7e9578d72658a960a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:50 2013 +0100

    staging: comedi: change comedi_alloc_board_minor() to return pointer
    
    Change `comedi_alloc_board_minor()` to return a pointer to the allocated
    `struct comedi_device` instead of a minor device number.  Return an
    `ERR_PTR()` value on error instead of a negative error number.  This
    saves a call to `comedi_dev_from_minor()` in `comedi_auto_config()`.
    
    Also change it to use a local variable `dev` to hold the pointer to the
    `struct comedi_device` instead of using `info->device` all the time.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 38c5f5fb0075..f9d0a7242474 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2274,22 +2274,24 @@ static void comedi_device_cleanup(struct comedi_device *dev)
 	mutex_destroy(&dev->mutex);
 }
 
-int comedi_alloc_board_minor(struct device *hardware_device)
+struct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)
 {
 	struct comedi_file_info *info;
+	struct comedi_device *dev;
 	struct device *csdev;
 	unsigned i;
 
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (info == NULL)
-		return -ENOMEM;
-	info->device = kzalloc(sizeof(struct comedi_device), GFP_KERNEL);
-	if (info->device == NULL) {
+		return ERR_PTR(-ENOMEM);
+	dev = kzalloc(sizeof(struct comedi_device), GFP_KERNEL);
+	if (dev == NULL) {
 		kfree(info);
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
 	}
+	info->device = dev;
 	info->hardware_device = hardware_device;
-	comedi_device_init(info->device);
+	comedi_device_init(dev);
 	spin_lock(&comedi_file_info_table_lock);
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
@@ -2299,20 +2301,20 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	}
 	spin_unlock(&comedi_file_info_table_lock);
 	if (i == COMEDI_NUM_BOARD_MINORS) {
-		comedi_device_cleanup(info->device);
-		kfree(info->device);
+		comedi_device_cleanup(dev);
+		kfree(dev);
 		kfree(info);
 		pr_err("comedi: error: ran out of minor numbers for board device files.\n");
-		return -EBUSY;
+		return ERR_PTR(-EBUSY);
 	}
-	info->device->minor = i;
+	dev->minor = i;
 	csdev = device_create(comedi_class, hardware_device,
 			      MKDEV(COMEDI_MAJOR, i), NULL, "comedi%i", i);
 	if (!IS_ERR(csdev))
-		info->device->class_dev = csdev;
+		dev->class_dev = csdev;
 	dev_set_drvdata(csdev, info);
 
-	return i;
+	return dev;
 }
 
 static struct comedi_file_info *comedi_clear_minor(unsigned minor)
@@ -2475,14 +2477,14 @@ static int __init comedi_init(void)
 
 	/* create devices files for legacy/manual use */
 	for (i = 0; i < comedi_num_legacy_minors; i++) {
-		int minor;
-		minor = comedi_alloc_board_minor(NULL);
-		if (minor < 0) {
+		struct comedi_device *dev;
+		dev = comedi_alloc_board_minor(NULL);
+		if (IS_ERR(dev)) {
 			comedi_cleanup_board_minors();
 			cdev_del(&comedi_cdev);
 			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 						 COMEDI_NUM_MINORS);
-			return minor;
+			return PTR_ERR(dev);
 		}
 	}
 

commit 70f30c3771f1e7c55d381954d84beff9c257a2b6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:49 2013 +0100

    staging: comedi: make comedi_free_board_minor() static
    
    `comedi_free_board_minor()` is now only called from the same .c file it
    is defined in, so give it static linkage.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ce050e4ba107..38c5f5fb0075 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2342,7 +2342,7 @@ static void comedi_free_board_file_info(struct comedi_file_info *info)
 	}
 }
 
-void comedi_free_board_minor(unsigned minor)
+static void comedi_free_board_minor(unsigned minor)
 {
 	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
 	comedi_free_board_file_info(comedi_clear_minor(minor));

commit 3346b798f202bf2f5b5272870ecdb75acec2e752
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:47 2013 +0100

    staging: comedi: add comedi_release_hardware_device()
    
    Add `comedi_release_hardware_device()` as a replacement for the call
    sequence `comedi_find_board_minor()`, `comedi_free_board_minor()`.  This
    is slightly safer as we can make sure nothing funny happens to the found
    `comedi_file_info_table[]` entry in the middle of the sequence.  Change
    `comedi_auto_unconfig()` to call the new function instead of the old
    sequence.  Remove `comedi_find_board_minor()` as it has no other
    callers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 8b5fa2fc9a82..ce050e4ba107 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2348,7 +2348,7 @@ void comedi_free_board_minor(unsigned minor)
 	comedi_free_board_file_info(comedi_clear_minor(minor));
 }
 
-int comedi_find_board_minor(struct device *hardware_device)
+void comedi_release_hardware_device(struct device *hardware_device)
 {
 	int minor;
 	struct comedi_file_info *info;
@@ -2357,12 +2357,13 @@ int comedi_find_board_minor(struct device *hardware_device)
 		spin_lock(&comedi_file_info_table_lock);
 		info = comedi_file_info_table[minor];
 		if (info && info->hardware_device == hardware_device) {
+			comedi_file_info_table[minor] = NULL;
 			spin_unlock(&comedi_file_info_table_lock);
-			return minor;
+			comedi_free_board_file_info(info);
+			break;
 		}
 		spin_unlock(&comedi_file_info_table_lock);
 	}
-	return -ENODEV;
 }
 
 int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)

commit 24fb134d1c336b263f75d7659f56a96382aebb56
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:46 2013 +0100

    staging: comedi: refactor comedi_free_board_minor()
    
    Split out the part of `comedi_free_board_minor()` that clears the
    `comedi_file_info_table[]` element into new function
    `comedi_clear_minor()`.  Split out the remainder of the original
    function into new function `comedi_free_board_file_info()`.
    
    Also re-use a call to `comedi_clear_minor()` in
    `comedi_free_subdevice_minor()` instead of doing the same thing inline.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 70b2034116fc..8b5fa2fc9a82 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2315,16 +2315,19 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	return i;
 }
 
-void comedi_free_board_minor(unsigned minor)
+static struct comedi_file_info *comedi_clear_minor(unsigned minor)
 {
 	struct comedi_file_info *info;
 
-	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
 	spin_lock(&comedi_file_info_table_lock);
 	info = comedi_file_info_table[minor];
 	comedi_file_info_table[minor] = NULL;
 	spin_unlock(&comedi_file_info_table_lock);
+	return info;
+}
 
+static void comedi_free_board_file_info(struct comedi_file_info *info)
+{
 	if (info) {
 		struct comedi_device *dev = info->device;
 		if (dev) {
@@ -2339,6 +2342,12 @@ void comedi_free_board_minor(unsigned minor)
 	}
 }
 
+void comedi_free_board_minor(unsigned minor)
+{
+	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
+	comedi_free_board_file_info(comedi_clear_minor(minor));
+}
+
 int comedi_find_board_minor(struct device *hardware_device)
 {
 	int minor;
@@ -2407,11 +2416,7 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 	BUG_ON(s->minor >= COMEDI_NUM_MINORS);
 	BUG_ON(s->minor < COMEDI_FIRST_SUBDEVICE_MINOR);
 
-	spin_lock(&comedi_file_info_table_lock);
-	info = comedi_file_info_table[s->minor];
-	comedi_file_info_table[s->minor] = NULL;
-	spin_unlock(&comedi_file_info_table_lock);
-
+	info = comedi_clear_minor(s->minor);
 	if (s->class_dev) {
 		device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, s->minor));
 		s->class_dev = NULL;

commit a649a6754d246d5b5447f74b86ed4b947e5f5446
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:45 2013 +0100

    staging: comedi: adjust module count on device cleanup
    
    `comedi_device_cleanup()` is called just before freeing a comedi device.
    It is possible for the device to still be open in which case the module
    reference counts for the core comedi module and possibly the low-level
    driver module will remain out of whack because `comedi_close()` will not
    find the comedi device and so will not decrement the module counts.
    
    This really needs to be handled better, but for now decrement the module
    counts in `comedi_device_cleanup()` according to the number of
    outstanding opens.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f2bfa0efcf74..70b2034116fc 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2256,10 +2256,20 @@ static void comedi_device_init(struct comedi_device *dev)
 
 static void comedi_device_cleanup(struct comedi_device *dev)
 {
+	struct module *driver_module = NULL;
+
 	if (dev == NULL)
 		return;
 	mutex_lock(&dev->mutex);
+	if (dev->attached)
+		driver_module = dev->driver->module;
 	comedi_device_detach(dev);
+	while (dev->use_count > 0) {
+		if (driver_module)
+			module_put(driver_module);
+		module_put(THIS_MODULE);
+		dev->use_count--;
+	}
 	mutex_unlock(&dev->mutex);
 	mutex_destroy(&dev->mutex);
 }

commit 4ca7da6e8234c864c8694237c26e4d574b9fd00a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:44 2013 +0100

    staging: comedi: remove memset() call from comedi_device_init()
    
    `comedi_device_init()` is only called from one place
    (`comedi_alloc_board_minor()`) and the `struct comedi_device` has
    already been zeroed out by `kzalloc()`.  Don't bother zeroing it out
    again with `memset()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c8a704b92daf..f2bfa0efcf74 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2249,7 +2249,6 @@ EXPORT_SYMBOL(comedi_event);
 
 static void comedi_device_init(struct comedi_device *dev)
 {
-	memset(dev, 0, sizeof(*dev));
 	spin_lock_init(&dev->spinlock);
 	mutex_init(&dev->mutex);
 	dev->minor = -1;

commit 9162220068c45ce7a564db07ccb45f7462a39eba
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:43 2013 +0100

    staging: comedi: no need to zero out comedi_file_info_table[]
    
    In the comedi core module, `comedi_file_info_table[]` is tentatively
    defined in the .bss section, so will already be zeroed out on
    initialization.  Don't bother zeroing it out again in the module
    initialization function `comedi_init()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 6bcbb52510ef..c8a704b92daf 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2432,9 +2432,6 @@ static int __init comedi_init(void)
 		return -EINVAL;
 	}
 
-	memset(comedi_file_info_table, 0,
-	       sizeof(struct comedi_file_info *) * COMEDI_NUM_MINORS);
-
 	retval = register_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 					COMEDI_NUM_MINORS, "comedi");
 	if (retval)

commit 13f12b5aea501bce146cdf213d1819083aadc847
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:34 2013 +0000

    staging: comedi: make 'in_request_module' a bool bit-field
    
    Change the `in_request_module` member of `struct comedi_device` to a
    1-bit bit-field of type `bool` and move it into a suitable hole in the
    data type to save a few bytes.  Change the assigned values to `true` and
    `false`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e336b281b847..6bcbb52510ef 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2067,12 +2067,12 @@ static int comedi_open(struct inode *inode, struct file *file)
 	/* This is slightly hacky, but we want module autoloading
 	 * to work for root.
 	 * case: user opens device, attached -> ok
-	 * case: user opens device, unattached, in_request_module=0 -> autoload
-	 * case: user opens device, unattached, in_request_module=1 -> fail
+	 * case: user opens device, unattached, !in_request_module -> autoload
+	 * case: user opens device, unattached, in_request_module -> fail
 	 * case: root opens device, attached -> ok
-	 * case: root opens device, unattached, in_request_module=1 -> ok
+	 * case: root opens device, unattached, in_request_module -> ok
 	 *   (typically called from modprobe)
-	 * case: root opens device, unattached, in_request_module=0 -> autoload
+	 * case: root opens device, unattached, !in_request_module -> autoload
 	 *
 	 * The last could be changed to "-> ok", which would deny root
 	 * autoloading.
@@ -2088,7 +2088,7 @@ static int comedi_open(struct inode *inode, struct file *file)
 	if (capable(CAP_NET_ADMIN) && dev->in_request_module)
 		goto ok;
 
-	dev->in_request_module = 1;
+	dev->in_request_module = true;
 
 #ifdef CONFIG_KMOD
 	mutex_unlock(&dev->mutex);
@@ -2096,7 +2096,7 @@ static int comedi_open(struct inode *inode, struct file *file)
 	mutex_lock(&dev->mutex);
 #endif
 
-	dev->in_request_module = 0;
+	dev->in_request_module = false;
 
 	if (!dev->attached && !capable(CAP_NET_ADMIN)) {
 		DPRINTK("not attached and not CAP_NET_ADMIN\n");

commit 6131ffaa1f091415b7a24abb01f033d9c0a727f4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Feb 27 16:59:05 2013 -0500

    more file_inode() open-coded instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 195d56d8a1ee..e336b281b847 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -580,7 +580,7 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 			    struct comedi_devinfo __user *arg,
 			    struct file *file)
 {
-	const unsigned minor = iminor(file->f_dentry->d_inode);
+	const unsigned minor = iminor(file_inode(file));
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
 	struct comedi_subdevice *s;
 	struct comedi_devinfo devinfo;
@@ -1615,7 +1615,7 @@ static int do_poll_ioctl(struct comedi_device *dev, unsigned int arg,
 static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 				  unsigned long arg)
 {
-	const unsigned minor = iminor(file->f_dentry->d_inode);
+	const unsigned minor = iminor(file_inode(file));
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
 	struct comedi_device *dev = comedi_dev_from_file_info(info);
 	int rc;
@@ -1743,7 +1743,7 @@ static struct vm_operations_struct comedi_vm_ops = {
 
 static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	const unsigned minor = iminor(file->f_dentry->d_inode);
+	const unsigned minor = iminor(file_inode(file));
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
 	struct comedi_device *dev = comedi_dev_from_file_info(info);
 	struct comedi_subdevice *s;
@@ -1823,7 +1823,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 static unsigned int comedi_poll(struct file *file, poll_table *wait)
 {
 	unsigned int mask = 0;
-	const unsigned minor = iminor(file->f_dentry->d_inode);
+	const unsigned minor = iminor(file_inode(file));
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
 	struct comedi_device *dev = comedi_dev_from_file_info(info);
 	struct comedi_subdevice *s;
@@ -1869,7 +1869,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	struct comedi_async *async;
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
-	const unsigned minor = iminor(file->f_dentry->d_inode);
+	const unsigned minor = iminor(file_inode(file));
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
 	struct comedi_device *dev = comedi_dev_from_file_info(info);
 
@@ -1964,7 +1964,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	struct comedi_async *async;
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
-	const unsigned minor = iminor(file->f_dentry->d_inode);
+	const unsigned minor = iminor(file_inode(file));
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
 	struct comedi_device *dev = comedi_dev_from_file_info(info);
 
@@ -2133,7 +2133,7 @@ static int comedi_open(struct inode *inode, struct file *file)
 
 static int comedi_fasync(int fd, struct file *file, int on)
 {
-	const unsigned minor = iminor(file->f_dentry->d_inode);
+	const unsigned minor = iminor(file_inode(file));
 	struct comedi_device *dev = comedi_dev_from_minor(minor);
 
 	if (!dev)

commit b12da2e4337ce235c4c5951b2217330587f3dda4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Feb 7 16:03:01 2013 +0000

    staging: comedi: correct error message in comedi_alloc_subdevice_minor()
    
    `comedi_alloc_subdevice_minors()` currently prints a message about
    running out of minor numbers board device files if it runs out of minor
    device numbers.  Change it to complain about running out of minor device
    numbers for subdevice files as these are in a different range, not
    shared with those for board device files.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 4f587ea13634..195d56d8a1ee 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2372,7 +2372,7 @@ int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 	spin_unlock(&comedi_file_info_table_lock);
 	if (i == COMEDI_NUM_MINORS) {
 		kfree(info);
-		pr_err("comedi: error: ran out of minor numbers for board device files.\n");
+		pr_err("comedi: error: ran out of minor numbers for subdevice files.\n");
 		return -EBUSY;
 	}
 	s->minor = i;

commit da7185462e86b4832342d7e02e52b889126a0fcf
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Feb 7 16:03:00 2013 +0000

    staging: comedi: don't return minor from comedi_alloc_subdevice_minor()
    
    `comedi_alloc_subdevice_minor()` currently returns the allocated minor
    device number on success.  This is not really of any interest to the
    caller (in fact the return value is not even checked), so just return 0
    on success.  If the caller really needs to know the allocated minor
    device number it can look in `s->minor`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b1e8cdbd1ce7..4f587ea13634 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2383,7 +2383,7 @@ int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 		s->class_dev = csdev;
 	dev_set_drvdata(csdev, info);
 
-	return i;
+	return 0;
 }
 
 void comedi_free_subdevice_minor(struct comedi_subdevice *s)

commit cc400e185c07c15a42d2635995f422de5b94b696
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Feb 5 12:50:40 2013 +0000

    staging: comedi: check s->async for poll(), read() and write()
    
    Some low-level comedi drivers (incorrectly) point `dev->read_subdev` or
    `dev->write_subdev` to a subdevice that does not support asynchronous
    commands.  Comedi's poll(), read() and write() file operation handlers
    assume these subdevices do support asynchronous commands.  In
    particular, they assume `s->async` is valid (where `s` points to the
    read or write subdevice), which it won't be if it has been set
    incorrectly.  This can lead to a NULL pointer dereference.
    
    Check `s->async` is non-NULL in `comedi_poll()`, `comedi_read()` and
    `comedi_write()` to avoid the bug.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index bd89e785fe6c..b1e8cdbd1ce7 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1839,7 +1839,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	}
 
 	s = comedi_read_subdevice(info);
-	if (s) {
+	if (s && s->async) {
 		poll_wait(file, &s->async->wait_head, wait);
 		if (!s->busy || !comedi_is_subdevice_running(s) ||
 		    comedi_buf_read_n_available(s->async) > 0)
@@ -1847,7 +1847,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	}
 
 	s = comedi_write_subdevice(info);
-	if (s) {
+	if (s && s->async) {
 		unsigned int bps = bytes_per_sample(s->async->subdevice);
 
 		poll_wait(file, &s->async->wait_head, wait);
@@ -1882,7 +1882,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	}
 
 	s = comedi_write_subdevice(info);
-	if (!s)
+	if (!s || !s->async)
 		return -EIO;
 
 	async = s->async;
@@ -1977,7 +1977,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	}
 
 	s = comedi_read_subdevice(info);
-	if (!s)
+	if (!s || !s->async)
 		return -EIO;
 
 	async = s->async;

commit 4a79f730179061c54d5c4ce1b59c1babbb05912f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 17:13:01 2013 -0700

    staging: comedi: remove 'comedi_autoconfig' module parameter
    
    This module parameter is used to enable the auto config mechanism
    in the comedi core. Most of the PCI, PCMCIA, and USB drivers have
    been converted to use the auto config mechanism and will not attach
    if it is disabled.
    
    Since the 'comedi_autoconfig' parameter is defaulted to true, just
    remove it so that the comedi drivers that use auto config will
    always be able to attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ee127b368d57..bd89e785fe6c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -58,11 +58,6 @@ MODULE_PARM_DESC(comedi_debug,
 		);
 #endif
 
-bool comedi_autoconfig = true;
-module_param(comedi_autoconfig, bool, S_IRUGO);
-MODULE_PARM_DESC(comedi_autoconfig,
-		 "enable drivers to auto-configure comedi devices (default 1)");
-
 static int comedi_num_legacy_minors;
 module_param(comedi_num_legacy_minors, int, S_IRUGO);
 MODULE_PARM_DESC(comedi_num_legacy_minors,
@@ -2437,14 +2432,6 @@ static int __init comedi_init(void)
 		return -EINVAL;
 	}
 
-	/*
-	 * comedi is unusable if both comedi_autoconfig and
-	 * comedi_num_legacy_minors are zero, so we might as well adjust the
-	 * defaults in that case
-	 */
-	if (!comedi_autoconfig && comedi_num_legacy_minors == 0)
-		comedi_num_legacy_minors = 16;
-
 	memset(comedi_file_info_table, 0,
 	       sizeof(struct comedi_file_info *) * COMEDI_NUM_MINORS);
 

commit f65cc5447eaea9f7be1ff54e27c9658a66c5910f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 1 10:20:30 2013 +0000

    staging: comedi: change comedi_alloc_subdevice_minor parameters
    
    `comedi_alloc_subdevice_minor()` doesn't really need a parameter
    pointing to a `struct comedi_device` as it can get this information from
    the parameter pointing to a `struct comedi_subdevice`.  Just pass the
    subdevice parameter.
    
    Signed-by: Ian Abbott <abbotti@mev.co.uk>
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c7377d012a6d..ee127b368d57 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2352,9 +2352,9 @@ int comedi_find_board_minor(struct device *hardware_device)
 	return -ENODEV;
 }
 
-int comedi_alloc_subdevice_minor(struct comedi_device *dev,
-				 struct comedi_subdevice *s)
+int comedi_alloc_subdevice_minor(struct comedi_subdevice *s)
 {
+	struct comedi_device *dev = s->device;
 	struct comedi_file_info *info;
 	struct device *csdev;
 	unsigned i;

commit 682b911938f8c0e88c8204bb1178c2c7728d5661
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 28 17:07:39 2013 +0000

    staging: comedi: cleanup all board minors on module exit
    
    The comedi core module optionally allocates some legacy board minor
    devices on module load and cleans these up on module exit.  These are
    used for manual configuration of comedi boards (for those low-level
    comedi drivers that support manual configuration - mainly for ISA
    boards).  Other board minor devices are created and destroyed
    dynamically in response to bus device probe and remove requests.  The
    ioctl used for manual configuration (attachment) and removal
    (detachment) of devices is COMEDI_DEVCONFIG, but that works for any
    board minor device, including those that were originally created
    dynamically.
    
    If the COMEDI_DEVCONFIG ioctl is used to manually detach an
    automatically created and attached device, commit
    7d3135af399e92cf4c9bbc5f86b6c140aab3b88c ("staging: comedi: prevent
    auto-unconfig of manually configured devices") ensures that the board
    minor will no longer be automatically detached and destroyed by a bus
    device remove request.  From that point on the board minor behaves more
    like one of the comedi "legacy" board minors.  (There would be some
    justification for destroying the board minor instead, but I'd rather
    leave that decision until removal of board minors has been
    made safer than it currently is.)  Although the board minor behaves more
    like a legacy board minor, it is not currently cleaned up on module
    exit.  In fact, the module exit code will bug out because this board
    minor has not been cleaned up.
    
    Change comedi_cleanup_legacy_minors() (called from the module exit code,
    and from the module init code on error) to clean up all board minors.
    Rename the function to comedi_cleanup_board_minors() to reflect the
    change in functionality.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 38e4fcb418c0..c7377d012a6d 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2415,11 +2415,11 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 	kfree(info);
 }
 
-static void comedi_cleanup_legacy_minors(void)
+static void comedi_cleanup_board_minors(void)
 {
 	unsigned i;
 
-	for (i = 0; i < comedi_num_legacy_minors; i++)
+	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++)
 		comedi_free_board_minor(i);
 }
 
@@ -2479,7 +2479,7 @@ static int __init comedi_init(void)
 		int minor;
 		minor = comedi_alloc_board_minor(NULL);
 		if (minor < 0) {
-			comedi_cleanup_legacy_minors();
+			comedi_cleanup_board_minors();
 			cdev_del(&comedi_cdev);
 			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 						 COMEDI_NUM_MINORS);
@@ -2495,7 +2495,7 @@ static void __exit comedi_cleanup(void)
 {
 	int i;
 
-	comedi_cleanup_legacy_minors();
+	comedi_cleanup_board_minors();
 	for (i = 0; i < COMEDI_NUM_MINORS; ++i)
 		BUG_ON(comedi_file_info_table[i]);
 

commit 754ab5c0e55dd118273ca2c217c4d95e9fbc8259
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 28 16:14:31 2013 +0000

    staging: comedi: disallow COMEDI_DEVCONFIG on non-board minors
    
    Comedi has two sorts of minor devices:
    (a) normal board minor devices in the range 0 to
    COMEDI_NUM_BOARD_MINORS-1 inclusive; and
    (b) special subdevice minor devices in the range COMEDI_NUM_BOARD_MINORS
    upwards that are used to open the same underlying comedi device as the
    normal board minor devices, but with non-default read and write
    subdevices for asynchronous commands.
    
    The special subdevice minor devices get created when a board supporting
    asynchronous commands is attached to a normal board minor device, and
    destroyed when the board is detached from the normal board minor device.
    One way to attach or detach a board is by using the COMEDI_DEVCONFIG
    ioctl.  This should only be used on normal board minors as the special
    subdevice minors are too ephemeral.  In particular, the change
    introduced in commit 7d3135af399e92cf4c9bbc5f86b6c140aab3b88c ("staging:
    comedi: prevent auto-unconfig of manually configured devices") breaks
    horribly for special subdevice minor devices.
    
    Since there's no legitimate use for the COMEDI_DEVCONFIG ioctl on a
    special subdevice minor device node, disallow it and return -ENOTTY.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index fa534fe4864b..38e4fcb418c0 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1633,6 +1633,11 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 	/* Device config is special, because it must work on
 	 * an unconfigured device. */
 	if (cmd == COMEDI_DEVCONFIG) {
+		if (minor >= COMEDI_NUM_BOARD_MINORS) {
+			/* Device config not appropriate on non-board minors. */
+			rc = -ENOTTY;
+			goto done;
+		}
 		rc = do_devconfig_ioctl(dev,
 					(struct comedi_devconfig __user *)arg);
 		if (rc == 0)

commit 104640606be0df6bcdb5ec7960a9c3c1278117ae
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jan 29 14:05:58 2013 +0000

    staging: comedi: don't override read/write subdevice if not supported
    
    For comedi devices that support asynchronous commands on some of their
    subdevices, the comedi core creates extra device files for each of those
    subdevices of the form "/dev/comedi%i_subd%i".  These use the same
    comedi device as the corresponding "/dev/comedi%i" but override the
    default "read" and "write" subdevice for the device.  Currently it
    overrides both the read and write subdevice, but it only makes sense to
    override the "read" subdevice if the subdevice supports "read" commands,
    and to override the "write" subdevice if the subdevice supports "write"
    commands.
    
    In `comedi_alloc_subdevice_minor()`, only set `info->read_subdevice`
    non-NULL if the subdevice has the `SDF_CMD_READ` flag set, and only set
    `info->write_subdevice` non-NULL if the subdevice has the
    `SDF_CMD_WRITE` flag set.  (`comedi_read_subdevice(info)` will use the
    device's default read subdevice if `info->read_subdevice` is NULL.
    `comedi_write_subdevice(info)` will use the device's default write
    subdevice if `info->write_subdevice` is NULL.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b798e42ee014..fa534fe4864b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2358,8 +2358,10 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	if (!info)
 		return -ENOMEM;
 	info->device = dev;
-	info->read_subdevice = s;
-	info->write_subdevice = s;
+	if (s->subdev_flags & SDF_CMD_READ)
+		info->read_subdevice = s;
+	if (s->subdev_flags & SDF_CMD_WRITE)
+		info->write_subdevice = s;
 	spin_lock(&comedi_file_info_table_lock);
 	for (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {

commit 5b6cbd87d3b9324e2c4200dd5b1b275999044ad8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 21 14:02:59 2013 -0700

    staging: comedi: comedi_fops: remove last forward declaration
    
    There is still a forward declaration in this file for parse_insn().
    Remove the need for it by moving do_insnlist_ioctl() down a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index dc3588a2c98b..b798e42ee014 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -842,96 +842,6 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	return 0;
 }
 
-static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
-		      unsigned int *data, void *file);
-/*
- *	COMEDI_INSNLIST
- *	synchronous instructions
- *
- *	arg:
- *		pointer to sync cmd structure
- *
- *	reads:
- *		sync cmd struct at arg
- *		instruction list
- *		data (for writes)
- *
- *	writes:
- *		data (for reads)
- */
-/* arbitrary limits */
-#define MAX_SAMPLES 256
-static int do_insnlist_ioctl(struct comedi_device *dev,
-			     struct comedi_insnlist __user *arg, void *file)
-{
-	struct comedi_insnlist insnlist;
-	struct comedi_insn *insns = NULL;
-	unsigned int *data = NULL;
-	int i = 0;
-	int ret = 0;
-
-	if (copy_from_user(&insnlist, arg, sizeof(insnlist)))
-		return -EFAULT;
-
-	data = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);
-	if (!data) {
-		DPRINTK("kmalloc failed\n");
-		ret = -ENOMEM;
-		goto error;
-	}
-
-	insns = kcalloc(insnlist.n_insns, sizeof(*insns), GFP_KERNEL);
-	if (!insns) {
-		DPRINTK("kmalloc failed\n");
-		ret = -ENOMEM;
-		goto error;
-	}
-
-	if (copy_from_user(insns, insnlist.insns,
-			   sizeof(*insns) * insnlist.n_insns)) {
-		DPRINTK("copy_from_user failed\n");
-		ret = -EFAULT;
-		goto error;
-	}
-
-	for (i = 0; i < insnlist.n_insns; i++) {
-		if (insns[i].n > MAX_SAMPLES) {
-			DPRINTK("number of samples too large\n");
-			ret = -EINVAL;
-			goto error;
-		}
-		if (insns[i].insn & INSN_MASK_WRITE) {
-			if (copy_from_user(data, insns[i].data,
-					   insns[i].n * sizeof(unsigned int))) {
-				DPRINTK("copy_from_user failed\n");
-				ret = -EFAULT;
-				goto error;
-			}
-		}
-		ret = parse_insn(dev, insns + i, data, file);
-		if (ret < 0)
-			goto error;
-		if (insns[i].insn & INSN_MASK_READ) {
-			if (copy_to_user(insns[i].data, data,
-					 insns[i].n * sizeof(unsigned int))) {
-				DPRINTK("copy_to_user failed\n");
-				ret = -EFAULT;
-				goto error;
-			}
-		}
-		if (need_resched())
-			schedule();
-	}
-
-error:
-	kfree(insns);
-	kfree(data);
-
-	if (ret < 0)
-		return ret;
-	return i;
-}
-
 static int check_insn_config_length(struct comedi_insn *insn,
 				    unsigned int *data)
 {
@@ -1162,6 +1072,94 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 	return ret;
 }
 
+/*
+ *	COMEDI_INSNLIST
+ *	synchronous instructions
+ *
+ *	arg:
+ *		pointer to sync cmd structure
+ *
+ *	reads:
+ *		sync cmd struct at arg
+ *		instruction list
+ *		data (for writes)
+ *
+ *	writes:
+ *		data (for reads)
+ */
+/* arbitrary limits */
+#define MAX_SAMPLES 256
+static int do_insnlist_ioctl(struct comedi_device *dev,
+			     struct comedi_insnlist __user *arg, void *file)
+{
+	struct comedi_insnlist insnlist;
+	struct comedi_insn *insns = NULL;
+	unsigned int *data = NULL;
+	int i = 0;
+	int ret = 0;
+
+	if (copy_from_user(&insnlist, arg, sizeof(insnlist)))
+		return -EFAULT;
+
+	data = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);
+	if (!data) {
+		DPRINTK("kmalloc failed\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	insns = kcalloc(insnlist.n_insns, sizeof(*insns), GFP_KERNEL);
+	if (!insns) {
+		DPRINTK("kmalloc failed\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	if (copy_from_user(insns, insnlist.insns,
+			   sizeof(*insns) * insnlist.n_insns)) {
+		DPRINTK("copy_from_user failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	for (i = 0; i < insnlist.n_insns; i++) {
+		if (insns[i].n > MAX_SAMPLES) {
+			DPRINTK("number of samples too large\n");
+			ret = -EINVAL;
+			goto error;
+		}
+		if (insns[i].insn & INSN_MASK_WRITE) {
+			if (copy_from_user(data, insns[i].data,
+					   insns[i].n * sizeof(unsigned int))) {
+				DPRINTK("copy_from_user failed\n");
+				ret = -EFAULT;
+				goto error;
+			}
+		}
+		ret = parse_insn(dev, insns + i, data, file);
+		if (ret < 0)
+			goto error;
+		if (insns[i].insn & INSN_MASK_READ) {
+			if (copy_to_user(insns[i].data, data,
+					 insns[i].n * sizeof(unsigned int))) {
+				DPRINTK("copy_to_user failed\n");
+				ret = -EFAULT;
+				goto error;
+			}
+		}
+		if (need_resched())
+			schedule();
+	}
+
+error:
+	kfree(insns);
+	kfree(data);
+
+	if (ret < 0)
+		return ret;
+	return i;
+}
+
 /*
  *	COMEDI_INSN
  *	synchronous instructions

commit 24d8e51ef3671f7dff0aaee0f3cf4c55d33c7292
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Mon Jan 21 21:29:43 2013 +0100

    staging/comedi: Use bool initializations
    
    Found with coccicheck.
    
    The semantic patch that makes this output is available
    in scripts/coccinelle/misc/boolinit.cocci.
    
    More information about semantic patching is available at
    http://coccinelle.lip6.fr/
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 3e82ab9bc51b..dc3588a2c98b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -58,7 +58,7 @@ MODULE_PARM_DESC(comedi_debug,
 		);
 #endif
 
-bool comedi_autoconfig = 1;
+bool comedi_autoconfig = true;
 module_param(comedi_autoconfig, bool, S_IRUGO);
 MODULE_PARM_DESC(comedi_autoconfig,
 		 "enable drivers to auto-configure comedi devices (default 1)");
@@ -2437,7 +2437,7 @@ static int __init comedi_init(void)
 	 * comedi_num_legacy_minors are zero, so we might as well adjust the
 	 * defaults in that case
 	 */
-	if (comedi_autoconfig == 0 && comedi_num_legacy_minors == 0)
+	if (!comedi_autoconfig && comedi_num_legacy_minors == 0)
 		comedi_num_legacy_minors = 16;
 
 	memset(comedi_file_info_table, 0,

commit 61c9fb0eb08bc9b7164a6181b0062d9959406a34
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 9 13:27:07 2013 -0700

    staging: comedi: comedi_buf: rename comedi_reset_async_buf()
    
    For aesthetic reasons, rename this function to comedi_buf_reset(). This
    makes all the asynchronous buffer functions have the same namespace.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 599e77524133..3e82ab9bc51b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -408,7 +408,7 @@ static void do_become_nonbusy(struct comedi_device *dev,
 
 	comedi_set_subdevice_runflags(s, SRF_RUNNING, 0);
 	if (async) {
-		comedi_reset_async_buf(async);
+		comedi_buf_reset(async);
 		async->inttrig = NULL;
 		kfree(async->cmd.chanlist);
 		async->cmd.chanlist = NULL;
@@ -1338,7 +1338,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 		goto cleanup;
 	}
 
-	comedi_reset_async_buf(async);
+	comedi_buf_reset(async);
 
 	async->cb_mask =
 	    COMEDI_CB_EOA | COMEDI_CB_BLOCK | COMEDI_CB_ERROR |

commit d18431325be0d485f58097755de5ec90091f336d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 9 09:46:10 2013 -0700

    staging: comedi: deprecate loading firmware with comedi_config
    
    All the comedi drivers have been converted to use the request_firmware()
    hotplug interface. The COMEDI_DEVCONFIG ioctl support for passing the
    firmware blob as 'aux_data' is no longer required.
    
    Remove the feature and give the user a dev_warn message if it is
    attempted.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 7d1e1d5db607..599e77524133 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -469,8 +469,6 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 {
 	struct comedi_devconfig it;
 	int ret;
-	unsigned char *aux_data = NULL;
-	int aux_len;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
@@ -491,31 +489,10 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 
 	it.board_name[COMEDI_NAMELEN - 1] = 0;
 
-	if (comedi_aux_data(it.options, 0) &&
-	    it.options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
-		int bit_shift;
-		aux_len = it.options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
-		if (aux_len < 0)
-			return -EFAULT;
-
-		aux_data = vmalloc(aux_len);
-		if (!aux_data)
-			return -ENOMEM;
-
-		if (copy_from_user(aux_data,
-				   (unsigned char __user *
-				    )comedi_aux_data(it.options, 0), aux_len)) {
-			vfree(aux_data);
-			return -EFAULT;
-		}
-		it.options[COMEDI_DEVCONF_AUX_DATA_LO] =
-		    (unsigned long)aux_data;
-		if (sizeof(void *) > sizeof(int)) {
-			bit_shift = sizeof(int) * 8;
-			it.options[COMEDI_DEVCONF_AUX_DATA_HI] =
-			    ((unsigned long)aux_data) >> bit_shift;
-		} else
-			it.options[COMEDI_DEVCONF_AUX_DATA_HI] = 0;
+	if (it.options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
+		dev_warn(dev->class_dev,
+			 "comedi_config --init_data is deprecated\n");
+		return -EINVAL;
 	}
 
 	ret = comedi_device_attach(dev, &it);
@@ -526,9 +503,6 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 		}
 	}
 
-	if (aux_data)
-		vfree(aux_data);
-
 	return ret;
 }
 

commit ba1bcf6f23e192e88b7c07d20d6221a0bcb7929e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jan 8 13:27:48 2013 +0000

    staging: comedi: (core): add comedi_dev_from_file_info()
    
    Setting `info = comedi_file_info_from_minor(minor)` and `dev =
    comedi_dev_from_minor(minor)` in the same function is a bit of a waste.
    The latter function is just a call of the former followed by a
    conditional return of an embedded pointer (`info->device`) or NULL.  The
    former function uses a spin-lock which is where the wastfulness comes
    in.
    
    Move the "followed by a conditional return of an embedded pointer" part
    into a new function `comedi_dev_from_file_info` and call this instead of
    `comedi_dev_from_minor()` in the places where
    `comedi_file_info_from_minor()` is also called.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index cd2c7d40d4db..7d1e1d5db607 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -103,14 +103,16 @@ static struct comedi_file_info *comedi_file_info_from_minor(unsigned minor)
 	return info;
 }
 
-struct comedi_device *comedi_dev_from_minor(unsigned minor)
+static struct comedi_device *
+comedi_dev_from_file_info(struct comedi_file_info *info)
 {
-	struct comedi_file_info *info;
-
-	info = comedi_file_info_from_minor(minor);
-
 	return info ? info->device : NULL;
 }
+
+struct comedi_device *comedi_dev_from_minor(unsigned minor)
+{
+	return comedi_dev_from_file_info(comedi_file_info_from_minor(minor));
+}
 EXPORT_SYMBOL_GPL(comedi_dev_from_minor);
 
 static struct comedi_subdevice *
@@ -1647,8 +1649,8 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 				  unsigned long arg)
 {
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
+	struct comedi_device *dev = comedi_dev_from_file_info(info);
 	int rc;
 
 	if (!dev)
@@ -1771,7 +1773,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_device *dev = comedi_dev_from_file_info(info);
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 	unsigned long start = vma->vm_start;
@@ -1851,7 +1853,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	unsigned int mask = 0;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_device *dev = comedi_dev_from_file_info(info);
 	struct comedi_subdevice *s;
 
 	if (!dev)
@@ -1897,7 +1899,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_device *dev = comedi_dev_from_file_info(info);
 
 	if (!dev)
 		return -ENODEV;
@@ -1992,7 +1994,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_device *dev = comedi_dev_from_file_info(info);
 
 	if (!dev)
 		return -ENODEV;

commit 17cb3be61b45d716f6b21a9380925493413ce0ed
Merge: d7f9729f6e06 e16a922a27ec
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 7 15:17:52 2013 -0800

    Merge branch 'staging-linus' into staging-next
    
    This is to get the comedi fixes, and resolve the issue in comdi_test.c
    and comedi_fops.c that were caused by changes in both branches.
    
    It also allows the fwserial driver changes to be applied, as they
    required the fixes that are in staging-linus.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 90a35c15c5d7d5c6254772d2752975dda185710c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 17:27:02 2012 -0700

    staging: comedi: store the 'index' for each subdevice
    
    Store the 'index' for each comedi_subdevice when they are initially
    allocated by comedi_alloc_subdevice(). This allows removing the
    pointer math in comedi_fops.c which is used to figure out the
    index that user space uses to access the individual subdevices.
    
    Fix the ni_mio_common driver so it also uses the 'index' instead
    of doing the pointer math.
    
    Also, remove a couple unused macros in the pcmda12, pcmmio, and
    pcmuio drivers which also do the pointer math to figure out the
    index.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index dda47b161bcf..2fd577fa941e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -169,7 +169,7 @@ static int resize_async_buffer(struct comedi_device *dev,
 	}
 
 	DPRINTK("comedi%i subd %d buffer resized to %i bytes\n",
-		dev->minor, (int)(s - dev->subdevices), async->prealloc_bufsz);
+		dev->minor, s->index, async->prealloc_bufsz);
 	return 0;
 }
 
@@ -624,13 +624,13 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 
 	s = comedi_read_subdevice(info);
 	if (s)
-		devinfo.read_subdevice = s - dev->subdevices;
+		devinfo.read_subdevice = s->index;
 	else
 		devinfo.read_subdevice = -1;
 
 	s = comedi_write_subdevice(info);
 	if (s)
-		devinfo.write_subdevice = s - dev->subdevices;
+		devinfo.write_subdevice = s->index;
 	else
 		devinfo.write_subdevice = -1;
 
@@ -2398,7 +2398,7 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	s->minor = i;
 	csdev = device_create(comedi_class, dev->class_dev,
 			      MKDEV(COMEDI_MAJOR, i), NULL, "comedi%i_subd%i",
-			      dev->minor, (int)(s - dev->subdevices));
+			      dev->minor, s->index);
 	if (!IS_ERR(csdev))
 		s->class_dev = csdev;
 	dev_set_drvdata(csdev, info);

commit 71cf6d3ee9351d668e9374d4026bf3337540eb22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:45:34 2012 -0700

    staging: comedi: comedi_fops: use kzalloc in comedi_alloc_subdevice_minor()
    
    The hardware_device member of comedi_file_info is not set in this
    function. Use kzalloc to make sure this pointer does not contain
    invalid data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 2826a29479c2..dda47b161bcf 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2376,8 +2376,8 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	struct device *csdev;
 	unsigned i;
 
-	info = kmalloc(sizeof(*info), GFP_KERNEL);
-	if (info == NULL)
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info)
 		return -ENOMEM;
 	info->device = dev;
 	info->read_subdevice = s;

commit a52840a98bbb50a7ed881b6cc361957c58c2731d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:45:12 2012 -0700

    staging: comedi: comedi_fops: cleanup comedi_mmap()
    
    Use comedi_dev_from_minor() to simplify the return -ENODEV tests.
    
    Change the (foo == NULL) tests to simply (!foo).
    
    Use a local variable to hold a pointer to the async->buf_page_list[]
    when doing the remap_pfn_range(). This cleans up the ugly line breaks
    for the page_to_pfn(virt_to_page(...) operation.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 8d407ccd4ed4..2826a29479c2 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1766,39 +1766,38 @@ static struct vm_operations_struct comedi_vm_ops = {
 static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_async *async = NULL;
+	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_subdevice *s;
+	struct comedi_async *async;
 	unsigned long start = vma->vm_start;
 	unsigned long size;
 	int n_pages;
 	int i;
 	int retval;
-	struct comedi_subdevice *s;
-	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev;
 
-	if (info == NULL)
-		return -ENODEV;
-	dev = info->device;
-	if (dev == NULL)
+	if (!dev)
 		return -ENODEV;
 
 	mutex_lock(&dev->mutex);
+
 	if (!dev->attached) {
 		DPRINTK("no driver configured on comedi%i\n", dev->minor);
 		retval = -ENODEV;
 		goto done;
 	}
+
 	if (vma->vm_flags & VM_WRITE)
 		s = comedi_write_subdevice(info);
 	else
 		s = comedi_read_subdevice(info);
-
-	if (s == NULL) {
+	if (!s) {
 		retval = -EINVAL;
 		goto done;
 	}
+
 	async = s->async;
-	if (async == NULL) {
+	if (!async) {
 		retval = -EINVAL;
 		goto done;
 	}
@@ -1821,11 +1820,11 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 
 	n_pages = size >> PAGE_SHIFT;
 	for (i = 0; i < n_pages; ++i) {
+		struct comedi_buf_page *buf = &async->buf_page_list[i];
+
 		if (remap_pfn_range(vma, start,
-				    page_to_pfn(virt_to_page
-						(async->buf_page_list
-						 [i].virt_addr)), PAGE_SIZE,
-				    PAGE_SHARED)) {
+				    page_to_pfn(virt_to_page(buf->virt_addr)),
+				    PAGE_SIZE, PAGE_SHARED)) {
 			retval = -EAGAIN;
 			goto done;
 		}

commit 401d99de5c0b70f7d64a410ed01d19032698656c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:44:46 2012 -0700

    staging: comedi: comedi_fops: cleanup comedi_{read, write}_subdevice()
    
    Flip the info->device tests so than the return NULL occurs last.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 33f5187e49db..8d407ccd4ed4 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -118,9 +118,9 @@ comedi_read_subdevice(const struct comedi_file_info *info)
 {
 	if (info->read_subdevice)
 		return info->read_subdevice;
-	if (info->device == NULL)
-		return NULL;
-	return info->device->read_subdev;
+	if (info->device)
+		return info->device->read_subdev;
+	return NULL;
 }
 
 static struct comedi_subdevice *
@@ -128,9 +128,9 @@ comedi_write_subdevice(const struct comedi_file_info *info)
 {
 	if (info->write_subdevice)
 		return info->write_subdevice;
-	if (info->device == NULL)
-		return NULL;
-	return info->device->write_subdev;
+	if (info->device)
+		return info->device->write_subdev;
+	return NULL;
 }
 
 static int resize_async_buffer(struct comedi_device *dev,

commit 9682e28c49f85d4a3c5d2cab401d03ae266f6dde
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:44:24 2012 -0700

    staging: comedi: comedi_fops: introduce comedi_is_subdevice_idle()
    
    Introduce, and use, a helper to check the subdevice runflags to see if
    it is not in error and not running.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index eb962178b643..33f5187e49db 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -389,6 +389,13 @@ static bool comedi_is_subdevice_in_error(struct comedi_subdevice *s)
 	return (runflags & SRF_ERROR) ? true : false;
 }
 
+static bool comedi_is_subdevice_idle(struct comedi_subdevice *s)
+{
+	unsigned runflags = comedi_get_subdevice_runflags(s);
+
+	return (runflags & (SRF_ERROR | SRF_RUNNING)) ? false : true;
+}
+
 /*
    This function restores a subdevice to an idle state.
  */
@@ -834,9 +841,8 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		bi.bytes_read = comedi_buf_read_alloc(async, bi.bytes_read);
 		comedi_buf_read_free(async, bi.bytes_read);
 
-		if (!(comedi_get_subdevice_runflags(s) & (SRF_ERROR |
-							  SRF_RUNNING))
-		    && async->buf_write_count == async->buf_read_count) {
+		if (comedi_is_subdevice_idle(s) &&
+		    async->buf_write_count == async->buf_read_count) {
 			do_become_nonbusy(dev, s);
 		}
 	}
@@ -2061,7 +2067,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		buf += n;
 		break;		/* makes device work like a pipe */
 	}
-	if (!(comedi_get_subdevice_runflags(s) & (SRF_ERROR | SRF_RUNNING)) &&
+	if (comedi_is_subdevice_idle(s) &&
 	    async->buf_read_count - async->buf_write_count == 0) {
 		do_become_nonbusy(dev, s);
 	}

commit c098c21a9d32f1cd828f23e617cb55909c75e7e2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:44:02 2012 -0700

    staging: comedi: comedi_fops: introduce comedi_is_subdevice_in_error()
    
    Introduce, and use, a helper to check the subdevice runflags to see if
    the SRF_ERROR flag is set.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 7d85f57f584b..eb962178b643 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -382,6 +382,13 @@ bool comedi_is_subdevice_running(struct comedi_subdevice *s)
 }
 EXPORT_SYMBOL_GPL(comedi_is_subdevice_running);
 
+static bool comedi_is_subdevice_in_error(struct comedi_subdevice *s)
+{
+	unsigned runflags = comedi_get_subdevice_runflags(s);
+
+	return (runflags & SRF_ERROR) ? true : false;
+}
+
 /*
    This function restores a subdevice to an idle state.
  */
@@ -1908,12 +1915,10 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 
 		if (!comedi_is_subdevice_running(s)) {
 			if (count == 0) {
-				if (comedi_get_subdevice_runflags(s) &
-					SRF_ERROR) {
+				if (comedi_is_subdevice_in_error(s))
 					retval = -EPIPE;
-				} else {
+				else
 					retval = 0;
-				}
 				do_become_nonbusy(dev, s);
 			}
 			break;
@@ -2015,12 +2020,10 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		if (n == 0) {
 			if (!comedi_is_subdevice_running(s)) {
 				do_become_nonbusy(dev, s);
-				if (comedi_get_subdevice_runflags(s) &
-				    SRF_ERROR) {
+				if (comedi_is_subdevice_in_error(s))
 					retval = -EPIPE;
-				} else {
+				else
 					retval = 0;
-				}
 				break;
 			}
 			if (file->f_flags & O_NONBLOCK) {

commit ade1764ff5f03bea4bc848de5e6d3db0758ff15a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:43:40 2012 -0700

    staging: comedi: comedi_fops: don't export comedi_get_subdevice_runflags()
    
    The subdevice runflags are protected with a spin_lock. Only the comedi
    core should be accessing them directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b67fb0dc7a7b..7d85f57f584b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -363,7 +363,7 @@ static void comedi_set_subdevice_runflags(struct comedi_subdevice *s,
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 }
 
-unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
+static unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 {
 	unsigned long flags;
 	unsigned runflags;
@@ -373,7 +373,6 @@ unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 	return runflags;
 }
-EXPORT_SYMBOL(comedi_get_subdevice_runflags);
 
 bool comedi_is_subdevice_running(struct comedi_subdevice *s)
 {

commit f012463068dbe0be2680aca6c607f7c6f5f0cdf3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:43:18 2012 -0700

    staging: comedi: use comedi_is_subdevice_running()
    
    Use the helper function comedi_is_subdevice_running() instead of getting
    the subdevice runflags and then masking the result.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 368dbc90da3b..b67fb0dc7a7b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -409,7 +409,7 @@ static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int ret = 0;
 
-	if ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) && s->cancel)
+	if (comedi_is_subdevice_running(s) && s->cancel)
 		ret = s->cancel(dev, s);
 
 	do_become_nonbusy(dev, s);
@@ -660,7 +660,7 @@ static int do_subdinfo_ioctl(struct comedi_device *dev,
 		us->type = s->type;
 		us->n_chan = s->n_chan;
 		us->subd_flags = s->subdev_flags;
-		if (comedi_get_subdevice_runflags(s) & SRF_RUNNING)
+		if (comedi_is_subdevice_running(s))
 			us->subd_flags |= SDF_RUNNING;
 #define TIMER_nanosec 5		/* backwards compatibility */
 		us->timer_type = TIMER_nanosec;
@@ -1852,7 +1852,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	s = comedi_read_subdevice(info);
 	if (s) {
 		poll_wait(file, &s->async->wait_head, wait);
-		if (!s->busy || !(comedi_get_subdevice_runflags(s) & SRF_RUNNING) ||
+		if (!s->busy || !comedi_is_subdevice_running(s) ||
 		    comedi_buf_read_n_available(s->async) > 0)
 			mask |= POLLIN | POLLRDNORM;
 	}
@@ -1863,7 +1863,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 
 		poll_wait(file, &s->async->wait_head, wait);
 		comedi_buf_write_alloc(s->async, s->async->prealloc_bufsz);
-		if (!s->busy || !(comedi_get_subdevice_runflags(s) & SRF_RUNNING) ||
+		if (!s->busy || !comedi_is_subdevice_running(s) ||
 		    comedi_buf_write_n_allocated(s->async) >= bps)
 			mask |= POLLOUT | POLLWRNORM;
 	}
@@ -1907,7 +1907,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	while (nbytes > 0 && !retval) {
 		set_current_state(TASK_INTERRUPTIBLE);
 
-		if (!(comedi_get_subdevice_runflags(s) & SRF_RUNNING)) {
+		if (!comedi_is_subdevice_running(s)) {
 			if (count == 0) {
 				if (comedi_get_subdevice_runflags(s) &
 					SRF_ERROR) {
@@ -2014,7 +2014,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 			n = m;
 
 		if (n == 0) {
-			if (!(comedi_get_subdevice_runflags(s) & SRF_RUNNING)) {
+			if (!comedi_is_subdevice_running(s)) {
 				do_become_nonbusy(dev, s);
 				if (comedi_get_subdevice_runflags(s) &
 				    SRF_ERROR) {
@@ -2227,7 +2227,7 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* DPRINTK("comedi_event 0x%x\n",mask); */
 
-	if ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) == 0)
+	if (!comedi_is_subdevice_running(s))
 		return;
 
 	if (s->

commit e0dac318ee2807d5ec1b09c1a608fdc25ef2ac7b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:42:47 2012 -0700

    staging: comedi: comedi_fops: introduce comedi_is_subdevice_running()
    
    Introduce a helper function that checks the subdevice runflags to
    see if the subdevice is running a command.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 0161f94cd759..368dbc90da3b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -375,6 +375,14 @@ unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 }
 EXPORT_SYMBOL(comedi_get_subdevice_runflags);
 
+bool comedi_is_subdevice_running(struct comedi_subdevice *s)
+{
+	unsigned runflags = comedi_get_subdevice_runflags(s);
+
+	return (runflags & SRF_RUNNING) ? true : false;
+}
+EXPORT_SYMBOL_GPL(comedi_is_subdevice_running);
+
 /*
    This function restores a subdevice to an idle state.
  */

commit 74120719a70c984e04c16afe53dbdea868bed6da
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:42:26 2012 -0700

    staging: comedi: comedi_fops: move comedi_get_subdevice_runflags()
    
    For aesthetic reasons, move this function so its near
    comedi_set_subdevice_runflags().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index bc45c12e84d2..0161f94cd759 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -363,6 +363,18 @@ static void comedi_set_subdevice_runflags(struct comedi_subdevice *s,
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 }
 
+unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
+{
+	unsigned long flags;
+	unsigned runflags;
+
+	spin_lock_irqsave(&s->spin_lock, flags);
+	runflags = s->runflags;
+	spin_unlock_irqrestore(&s->spin_lock, flags);
+	return runflags;
+}
+EXPORT_SYMBOL(comedi_get_subdevice_runflags);
+
 /*
    This function restores a subdevice to an idle state.
  */
@@ -2242,18 +2254,6 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 EXPORT_SYMBOL(comedi_event);
 
-unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
-{
-	unsigned long flags;
-	unsigned runflags;
-
-	spin_lock_irqsave(&s->spin_lock, flags);
-	runflags = s->runflags;
-	spin_unlock_irqrestore(&s->spin_lock, flags);
-	return runflags;
-}
-EXPORT_SYMBOL(comedi_get_subdevice_runflags);
-
 static void comedi_device_init(struct comedi_device *dev)
 {
 	memset(dev, 0, sizeof(*dev));

commit bc252fd12c9430a011497d3726fad47683d58dc0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:42:02 2012 -0700

    staging: comedi: comedi_fops: fix a number of sizeof(struct foo) forms
    
    As mentioned in CodingStyle, the prefered form is:
    
            p = kmalloc(sizeof(*p), ...);
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a7bec57a0ab7..bc45c12e84d2 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -451,7 +451,7 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 		return 0;
 	}
 
-	if (copy_from_user(&it, arg, sizeof(struct comedi_devconfig)))
+	if (copy_from_user(&it, arg, sizeof(it)))
 		return -EFAULT;
 
 	it.board_name[COMEDI_NAMELEN - 1] = 0;
@@ -519,7 +519,7 @@ static int do_bufconfig_ioctl(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	int retval = 0;
 
-	if (copy_from_user(&bc, arg, sizeof(struct comedi_bufconfig)))
+	if (copy_from_user(&bc, arg, sizeof(bc)))
 		return -EFAULT;
 
 	if (bc.subdevice >= dev->n_subdevices || bc.subdevice < 0)
@@ -552,7 +552,7 @@ static int do_bufconfig_ioctl(struct comedi_device *dev,
 	bc.maximum_size = async->max_bufsize;
 
 copyback:
-	if (copy_to_user(arg, &bc, sizeof(struct comedi_bufconfig)))
+	if (copy_to_user(arg, &bc, sizeof(bc)))
 		return -EFAULT;
 
 	return 0;
@@ -601,7 +601,7 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 	else
 		devinfo.write_subdevice = -1;
 
-	if (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))
+	if (copy_to_user(arg, &devinfo, sizeof(devinfo)))
 		return -EFAULT;
 
 	return 0;
@@ -628,9 +628,7 @@ static int do_subdinfo_ioctl(struct comedi_device *dev,
 	struct comedi_subdinfo *tmp, *us;
 	struct comedi_subdevice *s;
 
-	tmp =
-	    kcalloc(dev->n_subdevices, sizeof(struct comedi_subdinfo),
-		    GFP_KERNEL);
+	tmp = kcalloc(dev->n_subdevices, sizeof(*tmp), GFP_KERNEL);
 	if (!tmp)
 		return -ENOMEM;
 
@@ -681,8 +679,7 @@ static int do_subdinfo_ioctl(struct comedi_device *dev,
 		us->settling_time_0 = s->settling_time_0;
 	}
 
-	ret = copy_to_user(arg, tmp,
-			   dev->n_subdevices * sizeof(struct comedi_subdinfo));
+	ret = copy_to_user(arg, tmp, dev->n_subdevices * sizeof(*tmp));
 
 	kfree(tmp);
 
@@ -709,7 +706,7 @@ static int do_chaninfo_ioctl(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	struct comedi_chaninfo it;
 
-	if (copy_from_user(&it, arg, sizeof(struct comedi_chaninfo)))
+	if (copy_from_user(&it, arg, sizeof(it)))
 		return -EFAULT;
 
 	if (it.subdev >= dev->n_subdevices)
@@ -776,7 +773,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 
-	if (copy_from_user(&bi, arg, sizeof(struct comedi_bufinfo)))
+	if (copy_from_user(&bi, arg, sizeof(bi)))
 		return -EFAULT;
 
 	if (bi.subdevice >= dev->n_subdevices || bi.subdevice < 0)
@@ -831,7 +828,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	bi.buf_read_ptr = async->buf_read_ptr;
 
 copyback:
-	if (copy_to_user(arg, &bi, sizeof(struct comedi_bufinfo)))
+	if (copy_to_user(arg, &bi, sizeof(bi)))
 		return -EFAULT;
 
 	return 0;
@@ -865,7 +862,7 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 	int i = 0;
 	int ret = 0;
 
-	if (copy_from_user(&insnlist, arg, sizeof(struct comedi_insnlist)))
+	if (copy_from_user(&insnlist, arg, sizeof(insnlist)))
 		return -EFAULT;
 
 	data = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);
@@ -875,8 +872,7 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 		goto error;
 	}
 
-	insns =
-	    kcalloc(insnlist.n_insns, sizeof(struct comedi_insn), GFP_KERNEL);
+	insns = kcalloc(insnlist.n_insns, sizeof(*insns), GFP_KERNEL);
 	if (!insns) {
 		DPRINTK("kmalloc failed\n");
 		ret = -ENOMEM;
@@ -884,7 +880,7 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 	}
 
 	if (copy_from_user(insns, insnlist.insns,
-			   sizeof(struct comedi_insn) * insnlist.n_insns)) {
+			   sizeof(*insns) * insnlist.n_insns)) {
 		DPRINTK("copy_from_user failed\n");
 		ret = -EFAULT;
 		goto error;
@@ -1185,7 +1181,7 @@ static int do_insn_ioctl(struct comedi_device *dev,
 		goto error;
 	}
 
-	if (copy_from_user(&insn, arg, sizeof(struct comedi_insn))) {
+	if (copy_from_user(&insn, arg, sizeof(insn))) {
 		ret = -EFAULT;
 		goto error;
 	}
@@ -1229,7 +1225,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	int ret = 0;
 	unsigned int __user *user_chanlist;
 
-	if (copy_from_user(&cmd, arg, sizeof(struct comedi_cmd))) {
+	if (copy_from_user(&cmd, arg, sizeof(cmd))) {
 		DPRINTK("bad cmd address\n");
 		return -EFAULT;
 	}
@@ -1319,7 +1315,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 		/* restore chanlist pointer before copying back */
 		cmd.chanlist = (unsigned int __force *)user_chanlist;
 		cmd.data = NULL;
-		if (copy_to_user(arg, &cmd, sizeof(struct comedi_cmd))) {
+		if (copy_to_user(arg, &cmd, sizeof(cmd))) {
 			DPRINTK("fault writing cmd\n");
 			ret = -EFAULT;
 			goto cleanup;
@@ -1378,7 +1374,7 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 	unsigned int *chanlist = NULL;
 	unsigned int __user *user_chanlist;
 
-	if (copy_from_user(&cmd, arg, sizeof(struct comedi_cmd))) {
+	if (copy_from_user(&cmd, arg, sizeof(cmd))) {
 		DPRINTK("bad cmd address\n");
 		return -EFAULT;
 	}
@@ -1442,7 +1438,7 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 	/* restore chanlist pointer before copying back */
 	cmd.chanlist = (unsigned int __force *)user_chanlist;
 
-	if (copy_to_user(arg, &cmd, sizeof(struct comedi_cmd))) {
+	if (copy_to_user(arg, &cmd, sizeof(cmd))) {
 		DPRINTK("bad cmd address\n");
 		ret = -EFAULT;
 		goto cleanup;
@@ -2260,7 +2256,7 @@ EXPORT_SYMBOL(comedi_get_subdevice_runflags);
 
 static void comedi_device_init(struct comedi_device *dev)
 {
-	memset(dev, 0, sizeof(struct comedi_device));
+	memset(dev, 0, sizeof(*dev));
 	spin_lock_init(&dev->spinlock);
 	mutex_init(&dev->mutex);
 	dev->minor = -1;
@@ -2282,7 +2278,7 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	struct device *csdev;
 	unsigned i;
 
-	info = kzalloc(sizeof(struct comedi_file_info), GFP_KERNEL);
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (info == NULL)
 		return -ENOMEM;
 	info->device = kzalloc(sizeof(struct comedi_device), GFP_KERNEL);
@@ -2365,7 +2361,7 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	struct device *csdev;
 	unsigned i;
 
-	info = kmalloc(sizeof(struct comedi_file_info), GFP_KERNEL);
+	info = kmalloc(sizeof(*info), GFP_KERNEL);
 	if (info == NULL)
 		return -ENOMEM;
 	info->device = dev;

commit 76cca89f4b032abad514c0821be35d999c9707ce
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:41:42 2012 -0700

    staging: comedi: comedi_fops: move comedi_cleanup_legacy_minors()
    
    This function is only called by the module_{init,exit} functions. For
    aesthetic reasons, move it near them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 805a503ce215..a7bec57a0ab7 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2197,14 +2197,6 @@ static const struct file_operations comedi_fops = {
 static struct class *comedi_class;
 static struct cdev comedi_cdev;
 
-static void comedi_cleanup_legacy_minors(void)
-{
-	unsigned i;
-
-	for (i = 0; i < comedi_num_legacy_minors; i++)
-		comedi_free_board_minor(i);
-}
-
 void comedi_error(const struct comedi_device *dev, const char *s)
 {
 	dev_err(dev->class_dev, "%s: %s\n", dev->driver->driver_name, s);
@@ -2427,6 +2419,14 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 	kfree(info);
 }
 
+static void comedi_cleanup_legacy_minors(void)
+{
+	unsigned i;
+
+	for (i = 0; i < comedi_num_legacy_minors; i++)
+		comedi_free_board_minor(i);
+}
+
 static int __init comedi_init(void)
 {
 	int i;

commit 91fa0b0c96eb46444c9bc0d2994626fc371dd6db
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:41:19 2012 -0700

    staging: comedi: comedi_fops: move the module_{init, exit} functions to EOF
    
    For aesthetic reasons, move the module_{init,exit} functions to the end
    of the file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a0661877c13c..805a503ce215 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2205,91 +2205,6 @@ static void comedi_cleanup_legacy_minors(void)
 		comedi_free_board_minor(i);
 }
 
-static int __init comedi_init(void)
-{
-	int i;
-	int retval;
-
-	pr_info("comedi: version " COMEDI_RELEASE " - http://www.comedi.org\n");
-
-	if (comedi_num_legacy_minors < 0 ||
-	    comedi_num_legacy_minors > COMEDI_NUM_BOARD_MINORS) {
-		pr_err("comedi: error: invalid value for module parameter \"comedi_num_legacy_minors\".  Valid values are 0 through %i.\n",
-		       COMEDI_NUM_BOARD_MINORS);
-		return -EINVAL;
-	}
-
-	/*
-	 * comedi is unusable if both comedi_autoconfig and
-	 * comedi_num_legacy_minors are zero, so we might as well adjust the
-	 * defaults in that case
-	 */
-	if (comedi_autoconfig == 0 && comedi_num_legacy_minors == 0)
-		comedi_num_legacy_minors = 16;
-
-	memset(comedi_file_info_table, 0,
-	       sizeof(struct comedi_file_info *) * COMEDI_NUM_MINORS);
-
-	retval = register_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-					COMEDI_NUM_MINORS, "comedi");
-	if (retval)
-		return -EIO;
-	cdev_init(&comedi_cdev, &comedi_fops);
-	comedi_cdev.owner = THIS_MODULE;
-	kobject_set_name(&comedi_cdev.kobj, "comedi");
-	if (cdev_add(&comedi_cdev, MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS)) {
-		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-					 COMEDI_NUM_MINORS);
-		return -EIO;
-	}
-	comedi_class = class_create(THIS_MODULE, "comedi");
-	if (IS_ERR(comedi_class)) {
-		pr_err("comedi: failed to create class\n");
-		cdev_del(&comedi_cdev);
-		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-					 COMEDI_NUM_MINORS);
-		return PTR_ERR(comedi_class);
-	}
-
-	comedi_class->dev_attrs = comedi_dev_attrs;
-
-	/* XXX requires /proc interface */
-	comedi_proc_init();
-
-	/* create devices files for legacy/manual use */
-	for (i = 0; i < comedi_num_legacy_minors; i++) {
-		int minor;
-		minor = comedi_alloc_board_minor(NULL);
-		if (minor < 0) {
-			comedi_cleanup_legacy_minors();
-			cdev_del(&comedi_cdev);
-			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-						 COMEDI_NUM_MINORS);
-			return minor;
-		}
-	}
-
-	return 0;
-}
-
-static void __exit comedi_cleanup(void)
-{
-	int i;
-
-	comedi_cleanup_legacy_minors();
-	for (i = 0; i < COMEDI_NUM_MINORS; ++i)
-		BUG_ON(comedi_file_info_table[i]);
-
-	class_destroy(comedi_class);
-	cdev_del(&comedi_cdev);
-	unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);
-
-	comedi_proc_cleanup();
-}
-
-module_init(comedi_init);
-module_exit(comedi_cleanup);
-
 void comedi_error(const struct comedi_device *dev, const char *s)
 {
 	dev_err(dev->class_dev, "%s: %s\n", dev->driver->driver_name, s);
@@ -2512,6 +2427,90 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 	kfree(info);
 }
 
+static int __init comedi_init(void)
+{
+	int i;
+	int retval;
+
+	pr_info("comedi: version " COMEDI_RELEASE " - http://www.comedi.org\n");
+
+	if (comedi_num_legacy_minors < 0 ||
+	    comedi_num_legacy_minors > COMEDI_NUM_BOARD_MINORS) {
+		pr_err("comedi: error: invalid value for module parameter \"comedi_num_legacy_minors\".  Valid values are 0 through %i.\n",
+		       COMEDI_NUM_BOARD_MINORS);
+		return -EINVAL;
+	}
+
+	/*
+	 * comedi is unusable if both comedi_autoconfig and
+	 * comedi_num_legacy_minors are zero, so we might as well adjust the
+	 * defaults in that case
+	 */
+	if (comedi_autoconfig == 0 && comedi_num_legacy_minors == 0)
+		comedi_num_legacy_minors = 16;
+
+	memset(comedi_file_info_table, 0,
+	       sizeof(struct comedi_file_info *) * COMEDI_NUM_MINORS);
+
+	retval = register_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+					COMEDI_NUM_MINORS, "comedi");
+	if (retval)
+		return -EIO;
+	cdev_init(&comedi_cdev, &comedi_fops);
+	comedi_cdev.owner = THIS_MODULE;
+	kobject_set_name(&comedi_cdev.kobj, "comedi");
+	if (cdev_add(&comedi_cdev, MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS)) {
+		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+					 COMEDI_NUM_MINORS);
+		return -EIO;
+	}
+	comedi_class = class_create(THIS_MODULE, "comedi");
+	if (IS_ERR(comedi_class)) {
+		pr_err("comedi: failed to create class\n");
+		cdev_del(&comedi_cdev);
+		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+					 COMEDI_NUM_MINORS);
+		return PTR_ERR(comedi_class);
+	}
+
+	comedi_class->dev_attrs = comedi_dev_attrs;
+
+	/* XXX requires /proc interface */
+	comedi_proc_init();
+
+	/* create devices files for legacy/manual use */
+	for (i = 0; i < comedi_num_legacy_minors; i++) {
+		int minor;
+		minor = comedi_alloc_board_minor(NULL);
+		if (minor < 0) {
+			comedi_cleanup_legacy_minors();
+			cdev_del(&comedi_cdev);
+			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+						 COMEDI_NUM_MINORS);
+			return minor;
+		}
+	}
+
+	return 0;
+}
+module_init(comedi_init);
+
+static void __exit comedi_cleanup(void)
+{
+	int i;
+
+	comedi_cleanup_legacy_minors();
+	for (i = 0; i < COMEDI_NUM_MINORS; ++i)
+		BUG_ON(comedi_file_info_table[i]);
+
+	class_destroy(comedi_class);
+	cdev_del(&comedi_cdev);
+	unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);
+
+	comedi_proc_cleanup();
+}
+module_exit(comedi_cleanup);
+
 MODULE_AUTHOR("http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi core module");
 MODULE_LICENSE("GPL");

commit a5787824c08f553a5f283fb754b2473a6ad19857
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:40:59 2012 -0700

    staging: comedi: comedi_fops: move the MODULE_* information to EOF
    
    For aesthetic reasons, move the MODULE_* information to the end of
    the file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 0e9b5220ce22..a0661877c13c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -49,10 +49,6 @@
 
 #include "comedi_internal.h"
 
-MODULE_AUTHOR("http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi core module");
-MODULE_LICENSE("GPL");
-
 #ifdef CONFIG_COMEDI_DEBUG
 int comedi_debug;
 EXPORT_SYMBOL(comedi_debug);
@@ -2515,3 +2511,7 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 	}
 	kfree(info);
 }
+
+MODULE_AUTHOR("http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi core module");
+MODULE_LICENSE("GPL");

commit 2714b019fd570309e9a4cab2b988cbb7a36bbecd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:40:34 2012 -0700

    staging: comedi: comedi_fops: remove the goto's in comedi_write()
    
    Use comedi_dev_from_minor() to simplify the return -ENODEV tests.
    
    Cleanup the sanity checking a bit and remove the need for the goto's
    when returning an initial error condition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index cf1410dfc52c..0e9b5220ce22 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1870,39 +1870,27 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev;
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
 
-	if (info == NULL)
-		return -ENODEV;
-	dev = info->device;
-	if (dev == NULL)
+	if (!dev)
 		return -ENODEV;
 
 	if (!dev->attached) {
 		DPRINTK("no driver configured on comedi%i\n", dev->minor);
-		retval = -ENODEV;
-		goto done;
+		return -ENODEV;
 	}
 
 	s = comedi_write_subdevice(info);
-	if (s == NULL) {
-		retval = -EIO;
-		goto done;
-	}
+	if (!s)
+		return -EIO;
+
 	async = s->async;
 
-	if (!nbytes) {
-		retval = 0;
-		goto done;
-	}
-	if (!s->busy) {
-		retval = 0;
-		goto done;
-	}
-	if (s->busy != file) {
-		retval = -EACCES;
-		goto done;
-	}
+	if (!s->busy || !nbytes)
+		return 0;
+	if (s->busy != file)
+		return -EACCES;
+
 	add_wait_queue(&async->wait_head, &wait);
 	while (nbytes > 0 && !retval) {
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -1967,7 +1955,6 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(&async->wait_head, &wait);
 
-done:
 	return count ? count : retval;
 }
 

commit 5c87fef53cb338a919a18349facaf172c1f0cf75
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:40:08 2012 -0700

    staging: comedi: comedi_fops: remove the goto's in comedi_read()
    
    Use comedi_dev_from_minor() to simplify the return -ENODEV tests.
    
    Cleanup the sanity checking a bit and remove the need for the goto's
    when returning an initial error condition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 093f403554ce..cf1410dfc52c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1980,38 +1980,25 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev;
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
 
-	if (info == NULL)
-		return -ENODEV;
-	dev = info->device;
-	if (dev == NULL)
+	if (!dev)
 		return -ENODEV;
 
 	if (!dev->attached) {
 		DPRINTK("no driver configured on comedi%i\n", dev->minor);
-		retval = -ENODEV;
-		goto done;
+		return -ENODEV;
 	}
 
 	s = comedi_read_subdevice(info);
-	if (s == NULL) {
-		retval = -EIO;
-		goto done;
-	}
+	if (!s)
+		return -EIO;
+
 	async = s->async;
-	if (!nbytes) {
-		retval = 0;
-		goto done;
-	}
-	if (!s->busy) {
-		retval = 0;
-		goto done;
-	}
-	if (s->busy != file) {
-		retval = -EACCES;
-		goto done;
-	}
+	if (!s->busy || !nbytes)
+		return 0;
+	if (s->busy != file)
+		return -EACCES;
 
 	add_wait_queue(&async->wait_head, &wait);
 	while (nbytes > 0 && !retval) {
@@ -2080,7 +2067,6 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(&async->wait_head, &wait);
 
-done:
 	return count ? count : retval;
 }
 

commit ca081b1d7e2f355b54a6fa1e63f84b8ceb9597de
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:39:44 2012 -0700

    staging: comedi: comedi_fops: cleanup comedi_poll()
    
    Consolidate the local variables 'read_subdev' and 'write_subdev' into a
    single local variable 's'.
    
    Use comedi_dev_from_minor() to simplify the return -ENODEV tests.
    
    Use a goto in the !dev->attached test so that the mutex_unlock() call
    is in a common place.
    
    Cleanup the formating of the || in the read and write subdevice poll
    code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f67b12a7b847..093f403554ce 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1823,49 +1823,40 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 {
 	unsigned int mask = 0;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_subdevice *read_subdev;
-	struct comedi_subdevice *write_subdev;
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_device *dev;
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
+	struct comedi_subdevice *s;
 
-	if (info == NULL)
-		return -ENODEV;
-	dev = info->device;
-	if (dev == NULL)
+	if (!dev)
 		return -ENODEV;
 
 	mutex_lock(&dev->mutex);
+
 	if (!dev->attached) {
 		DPRINTK("no driver configured on comedi%i\n", dev->minor);
-		mutex_unlock(&dev->mutex);
-		return 0;
+		goto done;
 	}
 
-	mask = 0;
-	read_subdev = comedi_read_subdevice(info);
-	if (read_subdev) {
-		poll_wait(file, &read_subdev->async->wait_head, wait);
-		if (!read_subdev->busy
-		    || comedi_buf_read_n_available(read_subdev->async) > 0
-		    || !(comedi_get_subdevice_runflags(read_subdev) &
-			 SRF_RUNNING)) {
+	s = comedi_read_subdevice(info);
+	if (s) {
+		poll_wait(file, &s->async->wait_head, wait);
+		if (!s->busy || !(comedi_get_subdevice_runflags(s) & SRF_RUNNING) ||
+		    comedi_buf_read_n_available(s->async) > 0)
 			mask |= POLLIN | POLLRDNORM;
-		}
 	}
-	write_subdev = comedi_write_subdevice(info);
-	if (write_subdev) {
-		poll_wait(file, &write_subdev->async->wait_head, wait);
-		comedi_buf_write_alloc(write_subdev->async,
-				       write_subdev->async->prealloc_bufsz);
-		if (!write_subdev->busy
-		    || !(comedi_get_subdevice_runflags(write_subdev) &
-			 SRF_RUNNING)
-		    || comedi_buf_write_n_allocated(write_subdev->async) >=
-		    bytes_per_sample(write_subdev->async->subdevice)) {
+
+	s = comedi_write_subdevice(info);
+	if (s) {
+		unsigned int bps = bytes_per_sample(s->async->subdevice);
+
+		poll_wait(file, &s->async->wait_head, wait);
+		comedi_buf_write_alloc(s->async, s->async->prealloc_bufsz);
+		if (!s->busy || !(comedi_get_subdevice_runflags(s) & SRF_RUNNING) ||
+		    comedi_buf_write_n_allocated(s->async) >= bps)
 			mask |= POLLOUT | POLLWRNORM;
-		}
 	}
 
+done:
 	mutex_unlock(&dev->mutex);
 	return mask;
 }

commit 0e700923bf63b4afb7bb213f140d5a6e28c32aa6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:39:18 2012 -0700

    staging: comedi: comedi_fops: cleanup do_devinfo_ioctl()
    
    Consolidate the local variables 'read_subdev' and 'write_subdev' into a
    single local variable 's'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a480b6ee5770..f67b12a7b847 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -580,11 +580,10 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 			    struct comedi_devinfo __user *arg,
 			    struct file *file)
 {
-	struct comedi_devinfo devinfo;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_subdevice *read_subdev = comedi_read_subdevice(info);
-	struct comedi_subdevice *write_subdev = comedi_write_subdevice(info);
+	struct comedi_subdevice *s;
+	struct comedi_devinfo devinfo;
 
 	memset(&devinfo, 0, sizeof(devinfo));
 
@@ -594,13 +593,15 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 	strlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
 	strlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
 
-	if (read_subdev)
-		devinfo.read_subdevice = read_subdev - dev->subdevices;
+	s = comedi_read_subdevice(info);
+	if (s)
+		devinfo.read_subdevice = s - dev->subdevices;
 	else
 		devinfo.read_subdevice = -1;
 
-	if (write_subdev)
-		devinfo.write_subdevice = write_subdev - dev->subdevices;
+	s = comedi_write_subdevice(info);
+	if (s)
+		devinfo.write_subdevice = s - dev->subdevices;
 	else
 		devinfo.write_subdevice = -1;
 

commit 7d8a25674f8358e09daf4f1ed4e7dd93416f7b5b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:38:53 2012 -0700

    staging: comedi: comedi_fops: rename comedi_{read,write}_subdevice()
    
    The 'get' usually implies increasing a reference count of an object.
    These function return a pointer but do not do any reference counting.
    For aesthetic reasons, rename the functions to better represent what
    they do.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 0920dcc7949f..a480b6ee5770 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -118,7 +118,7 @@ struct comedi_device *comedi_dev_from_minor(unsigned minor)
 EXPORT_SYMBOL_GPL(comedi_dev_from_minor);
 
 static struct comedi_subdevice *
-comedi_get_read_subdevice(const struct comedi_file_info *info)
+comedi_read_subdevice(const struct comedi_file_info *info)
 {
 	if (info->read_subdevice)
 		return info->read_subdevice;
@@ -128,7 +128,7 @@ comedi_get_read_subdevice(const struct comedi_file_info *info)
 }
 
 static struct comedi_subdevice *
-comedi_get_write_subdevice(const struct comedi_file_info *info)
+comedi_write_subdevice(const struct comedi_file_info *info)
 {
 	if (info->write_subdevice)
 		return info->write_subdevice;
@@ -183,7 +183,7 @@ static ssize_t show_max_read_buffer_kb(struct device *dev,
 				       struct device_attribute *attr, char *buf)
 {
 	struct comedi_file_info *info = dev_get_drvdata(dev);
-	struct comedi_subdevice *s = comedi_get_read_subdevice(info);
+	struct comedi_subdevice *s = comedi_read_subdevice(info);
 	unsigned int size = 0;
 
 	mutex_lock(&info->device->mutex);
@@ -199,7 +199,7 @@ static ssize_t store_max_read_buffer_kb(struct device *dev,
 					const char *buf, size_t count)
 {
 	struct comedi_file_info *info = dev_get_drvdata(dev);
-	struct comedi_subdevice *s = comedi_get_read_subdevice(info);
+	struct comedi_subdevice *s = comedi_read_subdevice(info);
 	unsigned int size;
 	int err;
 
@@ -224,7 +224,7 @@ static ssize_t show_read_buffer_kb(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
 	struct comedi_file_info *info = dev_get_drvdata(dev);
-	struct comedi_subdevice *s = comedi_get_read_subdevice(info);
+	struct comedi_subdevice *s = comedi_read_subdevice(info);
 	unsigned int size = 0;
 
 	mutex_lock(&info->device->mutex);
@@ -240,7 +240,7 @@ static ssize_t store_read_buffer_kb(struct device *dev,
 				    const char *buf, size_t count)
 {
 	struct comedi_file_info *info = dev_get_drvdata(dev);
-	struct comedi_subdevice *s = comedi_get_read_subdevice(info);
+	struct comedi_subdevice *s = comedi_read_subdevice(info);
 	unsigned int size;
 	int err;
 
@@ -266,7 +266,7 @@ static ssize_t show_max_write_buffer_kb(struct device *dev,
 					char *buf)
 {
 	struct comedi_file_info *info = dev_get_drvdata(dev);
-	struct comedi_subdevice *s = comedi_get_write_subdevice(info);
+	struct comedi_subdevice *s = comedi_write_subdevice(info);
 	unsigned int size = 0;
 
 	mutex_lock(&info->device->mutex);
@@ -282,7 +282,7 @@ static ssize_t store_max_write_buffer_kb(struct device *dev,
 					 const char *buf, size_t count)
 {
 	struct comedi_file_info *info = dev_get_drvdata(dev);
-	struct comedi_subdevice *s = comedi_get_write_subdevice(info);
+	struct comedi_subdevice *s = comedi_write_subdevice(info);
 	unsigned int size;
 	int err;
 
@@ -307,7 +307,7 @@ static ssize_t show_write_buffer_kb(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
 	struct comedi_file_info *info = dev_get_drvdata(dev);
-	struct comedi_subdevice *s = comedi_get_write_subdevice(info);
+	struct comedi_subdevice *s = comedi_write_subdevice(info);
 	unsigned int size = 0;
 
 	mutex_lock(&info->device->mutex);
@@ -323,7 +323,7 @@ static ssize_t store_write_buffer_kb(struct device *dev,
 				     const char *buf, size_t count)
 {
 	struct comedi_file_info *info = dev_get_drvdata(dev);
-	struct comedi_subdevice *s = comedi_get_write_subdevice(info);
+	struct comedi_subdevice *s = comedi_write_subdevice(info);
 	unsigned int size;
 	int err;
 
@@ -583,10 +583,8 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 	struct comedi_devinfo devinfo;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
-	struct comedi_subdevice *read_subdev =
-	    comedi_get_read_subdevice(info);
-	struct comedi_subdevice *write_subdev =
-	    comedi_get_write_subdevice(info);
+	struct comedi_subdevice *read_subdev = comedi_read_subdevice(info);
+	struct comedi_subdevice *write_subdev = comedi_write_subdevice(info);
 
 	memset(&devinfo, 0, sizeof(devinfo));
 
@@ -1766,9 +1764,9 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 		goto done;
 	}
 	if (vma->vm_flags & VM_WRITE)
-		s = comedi_get_write_subdevice(info);
+		s = comedi_write_subdevice(info);
 	else
-		s = comedi_get_read_subdevice(info);
+		s = comedi_read_subdevice(info);
 
 	if (s == NULL) {
 		retval = -EINVAL;
@@ -1843,7 +1841,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	}
 
 	mask = 0;
-	read_subdev = comedi_get_read_subdevice(info);
+	read_subdev = comedi_read_subdevice(info);
 	if (read_subdev) {
 		poll_wait(file, &read_subdev->async->wait_head, wait);
 		if (!read_subdev->busy
@@ -1853,7 +1851,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 			mask |= POLLIN | POLLRDNORM;
 		}
 	}
-	write_subdev = comedi_get_write_subdevice(info);
+	write_subdev = comedi_write_subdevice(info);
 	if (write_subdev) {
 		poll_wait(file, &write_subdev->async->wait_head, wait);
 		comedi_buf_write_alloc(write_subdev->async,
@@ -1894,7 +1892,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 		goto done;
 	}
 
-	s = comedi_get_write_subdevice(info);
+	s = comedi_write_subdevice(info);
 	if (s == NULL) {
 		retval = -EIO;
 		goto done;
@@ -2004,7 +2002,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		goto done;
 	}
 
-	s = comedi_get_read_subdevice(info);
+	s = comedi_read_subdevice(info);
 	if (s == NULL) {
 		retval = -EIO;
 		goto done;

commit ed69335c727b7a499ac8499d943c6c879c937d69
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:38:30 2012 -0700

    staging: comedi: comedi_fops: rename comedi_get_device_file_info()
    
    The 'get' usually implies increasing a reference count of an object.
    This function returns a pointer but does not do any reference counting.
    For aesthetic reasons, rename the function to better represent what
    its doing.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index cc6f32d614b6..0920dcc7949f 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -96,7 +96,7 @@ struct comedi_file_info {
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_file_info *comedi_file_info_table[COMEDI_NUM_MINORS];
 
-static struct comedi_file_info *comedi_get_device_file_info(unsigned minor)
+static struct comedi_file_info *comedi_file_info_from_minor(unsigned minor)
 {
 	struct comedi_file_info *info;
 
@@ -111,7 +111,7 @@ struct comedi_device *comedi_dev_from_minor(unsigned minor)
 {
 	struct comedi_file_info *info;
 
-	info = comedi_get_device_file_info(minor);
+	info = comedi_file_info_from_minor(minor);
 
 	return info ? info->device : NULL;
 }
@@ -582,7 +582,7 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 {
 	struct comedi_devinfo devinfo;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_file_info *info = comedi_get_device_file_info(minor);
+	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
 	struct comedi_subdevice *read_subdev =
 	    comedi_get_read_subdevice(info);
 	struct comedi_subdevice *write_subdev =
@@ -1750,7 +1750,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	int i;
 	int retval;
 	struct comedi_subdevice *s;
-	struct comedi_file_info *info = comedi_get_device_file_info(minor);
+	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
 	struct comedi_device *dev;
 
 	if (info == NULL)
@@ -1826,7 +1826,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_subdevice *read_subdev;
 	struct comedi_subdevice *write_subdev;
-	struct comedi_file_info *info = comedi_get_device_file_info(minor);
+	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
 	struct comedi_device *dev;
 
 	if (info == NULL)
@@ -1879,7 +1879,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_file_info *info = comedi_get_device_file_info(minor);
+	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
 	struct comedi_device *dev;
 
 	if (info == NULL)
@@ -1989,7 +1989,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_file_info *info = comedi_get_device_file_info(minor);
+	struct comedi_file_info *info = comedi_file_info_from_minor(minor);
 	struct comedi_device *dev;
 
 	if (info == NULL)

commit cd6b7636e961b621b54f6f132db81c3ea7c2ca5e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:38:02 2012 -0700

    staging: comedi: comedi_fops: rename struct comedi_device_file_info
    
    For aesthetic reasons, rename this struct to comedi_file_info. It's
    a bit shorter and allows fixing some of the ugly line breaks used
    to keep the lines < 80 chars.
    
    Also, consistently use the local variable name 'info' instead of the
    longer 'dev_file_info' to also fix some ugly line breaks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e66464b9b408..cc6f32d614b6 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -86,7 +86,7 @@ MODULE_PARM_DESC(comedi_default_buf_maxsize_kb,
 		 "default maximum size of asynchronous buffer in KiB (default "
 		 __MODULE_STRING(CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB) ")");
 
-struct comedi_device_file_info {
+struct comedi_file_info {
 	struct comedi_device *device;
 	struct comedi_subdevice *read_subdevice;
 	struct comedi_subdevice *write_subdevice;
@@ -94,13 +94,11 @@ struct comedi_device_file_info {
 };
 
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
-static struct comedi_device_file_info
-*comedi_file_info_table[COMEDI_NUM_MINORS];
+static struct comedi_file_info *comedi_file_info_table[COMEDI_NUM_MINORS];
 
-static struct comedi_device_file_info *
-comedi_get_device_file_info(unsigned minor)
+static struct comedi_file_info *comedi_get_device_file_info(unsigned minor)
 {
-	struct comedi_device_file_info *info;
+	struct comedi_file_info *info;
 
 	BUG_ON(minor >= COMEDI_NUM_MINORS);
 	spin_lock(&comedi_file_info_table_lock);
@@ -111,7 +109,7 @@ comedi_get_device_file_info(unsigned minor)
 
 struct comedi_device *comedi_dev_from_minor(unsigned minor)
 {
-	struct comedi_device_file_info *info;
+	struct comedi_file_info *info;
 
 	info = comedi_get_device_file_info(minor);
 
@@ -120,7 +118,7 @@ struct comedi_device *comedi_dev_from_minor(unsigned minor)
 EXPORT_SYMBOL_GPL(comedi_dev_from_minor);
 
 static struct comedi_subdevice *
-comedi_get_read_subdevice(const struct comedi_device_file_info *info)
+comedi_get_read_subdevice(const struct comedi_file_info *info)
 {
 	if (info->read_subdevice)
 		return info->read_subdevice;
@@ -130,7 +128,7 @@ comedi_get_read_subdevice(const struct comedi_device_file_info *info)
 }
 
 static struct comedi_subdevice *
-comedi_get_write_subdevice(const struct comedi_device_file_info *info)
+comedi_get_write_subdevice(const struct comedi_file_info *info)
 {
 	if (info->write_subdevice)
 		return info->write_subdevice;
@@ -184,7 +182,7 @@ static int resize_async_buffer(struct comedi_device *dev,
 static ssize_t show_max_read_buffer_kb(struct device *dev,
 				       struct device_attribute *attr, char *buf)
 {
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(dev);
 	struct comedi_subdevice *s = comedi_get_read_subdevice(info);
 	unsigned int size = 0;
 
@@ -200,7 +198,7 @@ static ssize_t store_max_read_buffer_kb(struct device *dev,
 					struct device_attribute *attr,
 					const char *buf, size_t count)
 {
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(dev);
 	struct comedi_subdevice *s = comedi_get_read_subdevice(info);
 	unsigned int size;
 	int err;
@@ -225,7 +223,7 @@ static ssize_t store_max_read_buffer_kb(struct device *dev,
 static ssize_t show_read_buffer_kb(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(dev);
 	struct comedi_subdevice *s = comedi_get_read_subdevice(info);
 	unsigned int size = 0;
 
@@ -241,7 +239,7 @@ static ssize_t store_read_buffer_kb(struct device *dev,
 				    struct device_attribute *attr,
 				    const char *buf, size_t count)
 {
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(dev);
 	struct comedi_subdevice *s = comedi_get_read_subdevice(info);
 	unsigned int size;
 	int err;
@@ -267,7 +265,7 @@ static ssize_t show_max_write_buffer_kb(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(dev);
 	struct comedi_subdevice *s = comedi_get_write_subdevice(info);
 	unsigned int size = 0;
 
@@ -283,7 +281,7 @@ static ssize_t store_max_write_buffer_kb(struct device *dev,
 					 struct device_attribute *attr,
 					 const char *buf, size_t count)
 {
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(dev);
 	struct comedi_subdevice *s = comedi_get_write_subdevice(info);
 	unsigned int size;
 	int err;
@@ -308,7 +306,7 @@ static ssize_t store_max_write_buffer_kb(struct device *dev,
 static ssize_t show_write_buffer_kb(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(dev);
 	struct comedi_subdevice *s = comedi_get_write_subdevice(info);
 	unsigned int size = 0;
 
@@ -324,7 +322,7 @@ static ssize_t store_write_buffer_kb(struct device *dev,
 				     struct device_attribute *attr,
 				     const char *buf, size_t count)
 {
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	struct comedi_file_info *info = dev_get_drvdata(dev);
 	struct comedi_subdevice *s = comedi_get_write_subdevice(info);
 	unsigned int size;
 	int err;
@@ -584,12 +582,11 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 {
 	struct comedi_devinfo devinfo;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info =
-	    comedi_get_device_file_info(minor);
+	struct comedi_file_info *info = comedi_get_device_file_info(minor);
 	struct comedi_subdevice *read_subdev =
-	    comedi_get_read_subdevice(dev_file_info);
+	    comedi_get_read_subdevice(info);
 	struct comedi_subdevice *write_subdev =
-	    comedi_get_write_subdevice(dev_file_info);
+	    comedi_get_write_subdevice(info);
 
 	memset(&devinfo, 0, sizeof(devinfo));
 
@@ -1753,13 +1750,12 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	int i;
 	int retval;
 	struct comedi_subdevice *s;
-	struct comedi_device_file_info *dev_file_info;
+	struct comedi_file_info *info = comedi_get_device_file_info(minor);
 	struct comedi_device *dev;
 
-	dev_file_info = comedi_get_device_file_info(minor);
-	if (dev_file_info == NULL)
+	if (info == NULL)
 		return -ENODEV;
-	dev = dev_file_info->device;
+	dev = info->device;
 	if (dev == NULL)
 		return -ENODEV;
 
@@ -1770,9 +1766,9 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 		goto done;
 	}
 	if (vma->vm_flags & VM_WRITE)
-		s = comedi_get_write_subdevice(dev_file_info);
+		s = comedi_get_write_subdevice(info);
 	else
-		s = comedi_get_read_subdevice(dev_file_info);
+		s = comedi_get_read_subdevice(info);
 
 	if (s == NULL) {
 		retval = -EINVAL;
@@ -1830,13 +1826,12 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_subdevice *read_subdev;
 	struct comedi_subdevice *write_subdev;
-	struct comedi_device_file_info *dev_file_info;
+	struct comedi_file_info *info = comedi_get_device_file_info(minor);
 	struct comedi_device *dev;
-	dev_file_info = comedi_get_device_file_info(minor);
 
-	if (dev_file_info == NULL)
+	if (info == NULL)
 		return -ENODEV;
-	dev = dev_file_info->device;
+	dev = info->device;
 	if (dev == NULL)
 		return -ENODEV;
 
@@ -1848,7 +1843,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	}
 
 	mask = 0;
-	read_subdev = comedi_get_read_subdevice(dev_file_info);
+	read_subdev = comedi_get_read_subdevice(info);
 	if (read_subdev) {
 		poll_wait(file, &read_subdev->async->wait_head, wait);
 		if (!read_subdev->busy
@@ -1858,7 +1853,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 			mask |= POLLIN | POLLRDNORM;
 		}
 	}
-	write_subdev = comedi_get_write_subdevice(dev_file_info);
+	write_subdev = comedi_get_write_subdevice(info);
 	if (write_subdev) {
 		poll_wait(file, &write_subdev->async->wait_head, wait);
 		comedi_buf_write_alloc(write_subdev->async,
@@ -1884,13 +1879,12 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info;
+	struct comedi_file_info *info = comedi_get_device_file_info(minor);
 	struct comedi_device *dev;
-	dev_file_info = comedi_get_device_file_info(minor);
 
-	if (dev_file_info == NULL)
+	if (info == NULL)
 		return -ENODEV;
-	dev = dev_file_info->device;
+	dev = info->device;
 	if (dev == NULL)
 		return -ENODEV;
 
@@ -1900,7 +1894,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 		goto done;
 	}
 
-	s = comedi_get_write_subdevice(dev_file_info);
+	s = comedi_get_write_subdevice(info);
 	if (s == NULL) {
 		retval = -EIO;
 		goto done;
@@ -1995,13 +1989,12 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info;
+	struct comedi_file_info *info = comedi_get_device_file_info(minor);
 	struct comedi_device *dev;
-	dev_file_info = comedi_get_device_file_info(minor);
 
-	if (dev_file_info == NULL)
+	if (info == NULL)
 		return -ENODEV;
-	dev = dev_file_info->device;
+	dev = info->device;
 	if (dev == NULL)
 		return -ENODEV;
 
@@ -2011,7 +2004,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 		goto done;
 	}
 
-	s = comedi_get_read_subdevice(dev_file_info);
+	s = comedi_get_read_subdevice(info);
 	if (s == NULL) {
 		retval = -EIO;
 		goto done;
@@ -2276,7 +2269,7 @@ static int __init comedi_init(void)
 		comedi_num_legacy_minors = 16;
 
 	memset(comedi_file_info_table, 0,
-	       sizeof(struct comedi_device_file_info *) * COMEDI_NUM_MINORS);
+	       sizeof(struct comedi_file_info *) * COMEDI_NUM_MINORS);
 
 	retval = register_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 					COMEDI_NUM_MINORS, "comedi");
@@ -2419,11 +2412,11 @@ static void comedi_device_cleanup(struct comedi_device *dev)
 
 int comedi_alloc_board_minor(struct device *hardware_device)
 {
-	struct comedi_device_file_info *info;
+	struct comedi_file_info *info;
 	struct device *csdev;
 	unsigned i;
 
-	info = kzalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
+	info = kzalloc(sizeof(struct comedi_file_info), GFP_KERNEL);
 	if (info == NULL)
 		return -ENOMEM;
 	info->device = kzalloc(sizeof(struct comedi_device), GFP_KERNEL);
@@ -2460,7 +2453,7 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 
 void comedi_free_board_minor(unsigned minor)
 {
-	struct comedi_device_file_info *info;
+	struct comedi_file_info *info;
 
 	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
 	spin_lock(&comedi_file_info_table_lock);
@@ -2485,7 +2478,7 @@ void comedi_free_board_minor(unsigned minor)
 int comedi_find_board_minor(struct device *hardware_device)
 {
 	int minor;
-	struct comedi_device_file_info *info;
+	struct comedi_file_info *info;
 
 	for (minor = 0; minor < COMEDI_NUM_BOARD_MINORS; minor++) {
 		spin_lock(&comedi_file_info_table_lock);
@@ -2502,11 +2495,11 @@ int comedi_find_board_minor(struct device *hardware_device)
 int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 				 struct comedi_subdevice *s)
 {
-	struct comedi_device_file_info *info;
+	struct comedi_file_info *info;
 	struct device *csdev;
 	unsigned i;
 
-	info = kmalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
+	info = kmalloc(sizeof(struct comedi_file_info), GFP_KERNEL);
 	if (info == NULL)
 		return -ENOMEM;
 	info->device = dev;
@@ -2538,7 +2531,7 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 
 void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 {
-	struct comedi_device_file_info *info;
+	struct comedi_file_info *info;
 
 	if (s == NULL)
 		return;

commit e79c8d21000eb484c54b2fa2f42e6b55775ef144
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:36:42 2012 -0700

    staging: comedi: don't expose struct comedi_device_file_info
    
    This structure is only used in comedi_fops.c as part of handling
    the file operations and sysfs files. Remove it's defenition from
    comedidev.h so it's not exposed to the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1950f1ea6bb4..e66464b9b408 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -86,6 +86,13 @@ MODULE_PARM_DESC(comedi_default_buf_maxsize_kb,
 		 "default maximum size of asynchronous buffer in KiB (default "
 		 __MODULE_STRING(CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB) ")");
 
+struct comedi_device_file_info {
+	struct comedi_device *device;
+	struct comedi_subdevice *read_subdevice;
+	struct comedi_subdevice *write_subdevice;
+	struct device *hardware_device;
+};
+
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info
 *comedi_file_info_table[COMEDI_NUM_MINORS];

commit 87b1ad7a80d0a297448893e06f37c775951119d0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:36:00 2012 -0700

    staging: comedi: comedi_fops: don't export comedi_get_device_file_info()
    
    This function is now only used in comedi_fops.c and does not need
    to be exported.
    
    Make it static and move it to avoid forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 3945b5f0e5fa..1950f1ea6bb4 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -90,6 +90,18 @@ static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info
 *comedi_file_info_table[COMEDI_NUM_MINORS];
 
+static struct comedi_device_file_info *
+comedi_get_device_file_info(unsigned minor)
+{
+	struct comedi_device_file_info *info;
+
+	BUG_ON(minor >= COMEDI_NUM_MINORS);
+	spin_lock(&comedi_file_info_table_lock);
+	info = comedi_file_info_table[minor];
+	spin_unlock(&comedi_file_info_table_lock);
+	return info;
+}
+
 struct comedi_device *comedi_dev_from_minor(unsigned minor)
 {
 	struct comedi_device_file_info *info;
@@ -2540,15 +2552,3 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 	}
 	kfree(info);
 }
-
-struct comedi_device_file_info *comedi_get_device_file_info(unsigned minor)
-{
-	struct comedi_device_file_info *info;
-
-	BUG_ON(minor >= COMEDI_NUM_MINORS);
-	spin_lock(&comedi_file_info_table_lock);
-	info = comedi_file_info_table[minor];
-	spin_unlock(&comedi_file_info_table_lock);
-	return info;
-}
-EXPORT_SYMBOL_GPL(comedi_get_device_file_info);

commit 4da5fa9a439fda3019585aecab44462fd641b6f8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:35:23 2012 -0700

    staging: comedi: use comedi_dev_from_minor()
    
    Remove the need to export comedi_get_device_file_info() by using the
    new helper comedi_dev_from_minor(). This will also allow us to make
    the comedi_device_file_info struct private.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 647c7f347ee0..3945b5f0e5fa 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1608,14 +1608,11 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 				  unsigned long arg)
 {
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info =
-	    comedi_get_device_file_info(minor);
-	struct comedi_device *dev;
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
 	int rc;
 
-	if (dev_file_info == NULL || dev_file_info->device == NULL)
+	if (!dev)
 		return -ENODEV;
-	dev = dev_file_info->device;
 
 	mutex_lock(&dev->mutex);
 
@@ -2088,12 +2085,9 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 static int comedi_open(struct inode *inode, struct file *file)
 {
 	const unsigned minor = iminor(inode);
-	struct comedi_device_file_info *dev_file_info =
-	    comedi_get_device_file_info(minor);
-	struct comedi_device *dev =
-	    dev_file_info ? dev_file_info->device : NULL;
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
 
-	if (dev == NULL) {
+	if (!dev) {
 		DPRINTK("invalid minor number\n");
 		return -ENODEV;
 	}
@@ -2168,14 +2162,9 @@ static int comedi_open(struct inode *inode, struct file *file)
 static int comedi_fasync(int fd, struct file *file, int on)
 {
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info;
-	struct comedi_device *dev;
-	dev_file_info = comedi_get_device_file_info(minor);
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
 
-	if (dev_file_info == NULL)
-		return -ENODEV;
-	dev = dev_file_info->device;
-	if (dev == NULL)
+	if (!dev)
 		return -ENODEV;
 
 	return fasync_helper(fd, file, on, &dev->async_queue);
@@ -2184,16 +2173,11 @@ static int comedi_fasync(int fd, struct file *file, int on)
 static int comedi_close(struct inode *inode, struct file *file)
 {
 	const unsigned minor = iminor(inode);
+	struct comedi_device *dev = comedi_dev_from_minor(minor);
 	struct comedi_subdevice *s = NULL;
 	int i;
-	struct comedi_device_file_info *dev_file_info;
-	struct comedi_device *dev;
-	dev_file_info = comedi_get_device_file_info(minor);
 
-	if (dev_file_info == NULL)
-		return -ENODEV;
-	dev = dev_file_info->device;
-	if (dev == NULL)
+	if (!dev)
 		return -ENODEV;
 
 	mutex_lock(&dev->mutex);

commit 85104e9b409013c78624b367dec02e6ccc996635
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:34:40 2012 -0700

    staging: comedi: comedi_fops: introduce comedi_dev_from_minor()
    
    A number of functions have to call comedi_get_device_file_info()
    to get the comedi_device_file_info pointer for a given minor. That
    pointer is only used to get the actual comedi_device pointer for
    the minor.
    
    Introduce a new helper function, comedi_dev_from_minor(), to simplify
    this operation. This will also allow us to make the comedi_device_file_info
    struct private.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 38de7f70f0b8..647c7f347ee0 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -90,6 +90,16 @@ static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info
 *comedi_file_info_table[COMEDI_NUM_MINORS];
 
+struct comedi_device *comedi_dev_from_minor(unsigned minor)
+{
+	struct comedi_device_file_info *info;
+
+	info = comedi_get_device_file_info(minor);
+
+	return info ? info->device : NULL;
+}
+EXPORT_SYMBOL_GPL(comedi_dev_from_minor);
+
 static struct comedi_subdevice *
 comedi_get_read_subdevice(const struct comedi_device_file_info *info)
 {

commit 43bd33f22444868cbc9d4cbec7a3efb0a7c2cb25
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:33:29 2012 -0700

    staging: comedi: don't expose comedi_get_{read, write}_subdevice
    
    These two inline helper function in comedidev.h are only used in
    comedi_fops.c. They return information that should only be used
    by the comedi core.
    
    Move both functions to comedi_fops.c so they aren't exposed to
    the comedi drivers. Also, remove the inline tag and let the
    compiler figure it out.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 91b9e93321e2..38de7f70f0b8 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -90,6 +90,26 @@ static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info
 *comedi_file_info_table[COMEDI_NUM_MINORS];
 
+static struct comedi_subdevice *
+comedi_get_read_subdevice(const struct comedi_device_file_info *info)
+{
+	if (info->read_subdevice)
+		return info->read_subdevice;
+	if (info->device == NULL)
+		return NULL;
+	return info->device->read_subdev;
+}
+
+static struct comedi_subdevice *
+comedi_get_write_subdevice(const struct comedi_device_file_info *info)
+{
+	if (info->write_subdevice)
+		return info->write_subdevice;
+	if (info->device == NULL)
+		return NULL;
+	return info->device->write_subdev;
+}
+
 static int resize_async_buffer(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_async *async, unsigned new_size)

commit 2aae0076c9676a6e56793e25df95eab4bdadc94e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:31:57 2012 -0700

    staging: comedi: comedi_fops: remove forward declarations
    
    Move a couple of the functions to remove the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b7bba1790a20..91b9e93321e2 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -90,14 +90,6 @@ static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info
 *comedi_file_info_table[COMEDI_NUM_MINORS];
 
-static void do_become_nonbusy(struct comedi_device *dev,
-			      struct comedi_subdevice *s);
-static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-
-static int comedi_fasync(int fd, struct file *file, int on);
-
-static int is_device_busy(struct comedi_device *dev);
-
 static int resize_async_buffer(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_async *async, unsigned new_size)
@@ -317,6 +309,70 @@ static struct device_attribute comedi_dev_attrs[] = {
 	__ATTR_NULL
 };
 
+static void comedi_set_subdevice_runflags(struct comedi_subdevice *s,
+					  unsigned mask, unsigned bits)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&s->spin_lock, flags);
+	s->runflags &= ~mask;
+	s->runflags |= (bits & mask);
+	spin_unlock_irqrestore(&s->spin_lock, flags);
+}
+
+/*
+   This function restores a subdevice to an idle state.
+ */
+static void do_become_nonbusy(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
+{
+	struct comedi_async *async = s->async;
+
+	comedi_set_subdevice_runflags(s, SRF_RUNNING, 0);
+	if (async) {
+		comedi_reset_async_buf(async);
+		async->inttrig = NULL;
+		kfree(async->cmd.chanlist);
+		async->cmd.chanlist = NULL;
+	} else {
+		dev_err(dev->class_dev,
+			"BUG: (?) do_become_nonbusy called with async=NULL\n");
+	}
+
+	s->busy = NULL;
+}
+
+static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+{
+	int ret = 0;
+
+	if ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) && s->cancel)
+		ret = s->cancel(dev, s);
+
+	do_become_nonbusy(dev, s);
+
+	return ret;
+}
+
+static int is_device_busy(struct comedi_device *dev)
+{
+	struct comedi_subdevice *s;
+	int i;
+
+	if (!dev->attached)
+		return 0;
+
+	for (i = 0; i < dev->n_subdevices; i++) {
+		s = &dev->subdevices[i];
+		if (s->busy)
+			return 1;
+		if (s->async && s->async->mmap_count)
+			return 1;
+	}
+
+	return 0;
+}
+
 /*
 	COMEDI_DEVCONFIG
 	device config ioctl
@@ -1123,17 +1179,6 @@ static int do_insn_ioctl(struct comedi_device *dev,
 	return ret;
 }
 
-static void comedi_set_subdevice_runflags(struct comedi_subdevice *s,
-					  unsigned mask, unsigned bits)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->spin_lock, flags);
-	s->runflags &= ~mask;
-	s->runflags |= (bits & mask);
-	spin_unlock_irqrestore(&s->spin_lock, flags);
-}
-
 static int do_cmd_ioctl(struct comedi_device *dev,
 			struct comedi_cmd __user *arg, void *file)
 {
@@ -1621,19 +1666,6 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 	return rc;
 }
 
-static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	int ret = 0;
-
-	if ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) && s->cancel)
-		ret = s->cancel(dev, s);
-
-	do_become_nonbusy(dev, s);
-
-	return ret;
-}
-
-
 static void comedi_vm_open(struct vm_area_struct *area)
 {
 	struct comedi_async *async;
@@ -2023,28 +2055,6 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	return count ? count : retval;
 }
 
-/*
-   This function restores a subdevice to an idle state.
- */
-static void do_become_nonbusy(struct comedi_device *dev,
-			      struct comedi_subdevice *s)
-{
-	struct comedi_async *async = s->async;
-
-	comedi_set_subdevice_runflags(s, SRF_RUNNING, 0);
-	if (async) {
-		comedi_reset_async_buf(async);
-		async->inttrig = NULL;
-		kfree(async->cmd.chanlist);
-		async->cmd.chanlist = NULL;
-	} else {
-		dev_err(dev->class_dev,
-			"BUG: (?) do_become_nonbusy called with async=NULL\n");
-	}
-
-	s->busy = NULL;
-}
-
 static int comedi_open(struct inode *inode, struct file *file)
 {
 	const unsigned minor = iminor(inode);
@@ -2125,6 +2135,22 @@ static int comedi_open(struct inode *inode, struct file *file)
 	return 0;
 }
 
+static int comedi_fasync(int fd, struct file *file, int on)
+{
+	const unsigned minor = iminor(file->f_dentry->d_inode);
+	struct comedi_device_file_info *dev_file_info;
+	struct comedi_device *dev;
+	dev_file_info = comedi_get_device_file_info(minor);
+
+	if (dev_file_info == NULL)
+		return -ENODEV;
+	dev = dev_file_info->device;
+	if (dev == NULL)
+		return -ENODEV;
+
+	return fasync_helper(fd, file, on, &dev->async_queue);
+}
+
 static int comedi_close(struct inode *inode, struct file *file)
 {
 	const unsigned minor = iminor(inode);
@@ -2169,22 +2195,6 @@ static int comedi_close(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static int comedi_fasync(int fd, struct file *file, int on)
-{
-	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info;
-	struct comedi_device *dev;
-	dev_file_info = comedi_get_device_file_info(minor);
-
-	if (dev_file_info == NULL)
-		return -ENODEV;
-	dev = dev_file_info->device;
-	if (dev == NULL)
-		return -ENODEV;
-
-	return fasync_helper(fd, file, on, &dev->async_queue);
-}
-
 static const struct file_operations comedi_fops = {
 	.owner = THIS_MODULE,
 	.unlocked_ioctl = comedi_unlocked_ioctl,
@@ -2356,25 +2366,6 @@ unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 }
 EXPORT_SYMBOL(comedi_get_subdevice_runflags);
 
-static int is_device_busy(struct comedi_device *dev)
-{
-	struct comedi_subdevice *s;
-	int i;
-
-	if (!dev->attached)
-		return 0;
-
-	for (i = 0; i < dev->n_subdevices; i++) {
-		s = &dev->subdevices[i];
-		if (s->busy)
-			return 1;
-		if (s->async && s->async->mmap_count)
-			return 1;
-	}
-
-	return 0;
-}
-
 static void comedi_device_init(struct comedi_device *dev)
 {
 	memset(dev, 0, sizeof(struct comedi_device));

commit 7d3135af399e92cf4c9bbc5f86b6c140aab3b88c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Dec 4 15:59:55 2012 +0000

    staging: comedi: prevent auto-unconfig of manually configured devices
    
    When a low-level comedi driver auto-configures a device, a `struct
    comedi_dev_file_info` is allocated (as well as a `struct
    comedi_device`) by `comedi_alloc_board_minor()`.  A pointer to the
    hardware `struct device` is stored as a cookie in the `struct
    comedi_dev_file_info`.  When the low-level comedi driver
    auto-unconfigures the device, `comedi_auto_unconfig()` uses the cookie
    to find the `struct comedi_dev_file_info` so it can detach the comedi
    device from the driver, clean it up and free it.
    
    A problem arises if the user manually unconfigures and reconfigures the
    comedi device using the `COMEDI_DEVCONFIG` ioctl so that is no longer
    associated with the original hardware device.  The problem is that the
    cookie is not cleared, so that a call to `comedi_auto_unconfig()` from
    the low-level driver will still find it, detach it, clean it up and free
    it.
    
    Stop this problem occurring by always clearing the `hardware_device`
    cookie in the `struct comedi_dev_file_info` whenever the
    `COMEDI_DEVCONFIG` ioctl call is successful.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b7bba1790a20..9b038e4a7e71 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1549,6 +1549,9 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 	if (cmd == COMEDI_DEVCONFIG) {
 		rc = do_devconfig_ioctl(dev,
 					(struct comedi_devconfig __user *)arg);
+		if (rc == 0)
+			/* Evade comedi_auto_unconfig(). */
+			dev_file_info->hardware_device = NULL;
 		goto done;
 	}
 

commit 1b6c710e2a0f636aa038dc80dc114edf8217f5e6
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Nov 26 17:34:29 2012 -0700

    staging: comedi: remove unnecessary '#define __NO_VERSION__'
    
    This define is no longer required for multi-file modules.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 06906f6f7f49..b7bba1790a20 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -23,7 +23,6 @@
 
 #undef DEBUG
 
-#define __NO_VERSION__
 #include "comedi_compat32.h"
 
 #include <linux/module.h>

commit b0a2b6d8ac9ce5d27c9086a196d8f44194561979
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 14 11:22:57 2012 +0000

    staging: comedi: check data length for INSN_CONFIG_DIGITAL_TRIG
    
    The newly defined format for the `INSN_CONFIG_DIGITAL_TRIG`
    configuration instruction expects 6 data values.  Check the length in
    `check_insn_config_length()` before calling the comedi subdevice's
    `insn_config` handler.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c2a32cf95a82..06906f6f7f49 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -880,6 +880,10 @@ static int check_insn_config_length(struct comedi_insn *insn,
 		if (insn->n == 5)
 			return 0;
 		break;
+	case INSN_CONFIG_DIGITAL_TRIG:
+		if (insn->n == 6)
+			return 0;
+		break;
 		/* by default we allow the insn since we don't have checks for
 		 * all possible cases yet */
 	default:

commit c8cad4c89ee3b15935c532210ae6ebb5c0a2734d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 19 19:37:39 2012 +0100

    staging: comedi: fix memory leak for saved channel list
    
    When `do_cmd_ioctl()` allocates memory for the kernel copy of a channel
    list, it frees any previously allocated channel list in
    `async->cmd.chanlist` and replaces it with the new one.  However, if the
    device is ever removed (or "detached") the cleanup code in
    `cleanup_device()` in "drivers.c" does not free this memory so it is
    lost.
    
    A sensible place to free the kernel copy of the channel list is in
    `do_become_nonbusy()` as at that point the comedi asynchronous command
    associated with the channel list is no longer valid.  Free the channel
    list in `do_become_nonbusy()` instead of `do_cmd_ioctl()` and clear the
    pointer to prevent it being freed more than once.
    
    Note that `cleanup_device()` could be called at an inappropriate time
    while the comedi device is open, but that's a separate bug not related
    to this this patch.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f496f4d96c83..c2a32cf95a82 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1195,7 +1195,6 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 		goto cleanup;
 	}
 
-	kfree(async->cmd.chanlist);
 	async->cmd = cmd;
 	async->cmd.data = NULL;
 	/* load channel/gain list */
@@ -2033,6 +2032,8 @@ static void do_become_nonbusy(struct comedi_device *dev,
 	if (async) {
 		comedi_reset_async_buf(async);
 		async->inttrig = NULL;
+		kfree(async->cmd.chanlist);
+		async->cmd.chanlist = NULL;
 	} else {
 		dev_err(dev->class_dev,
 			"BUG: (?) do_become_nonbusy called with async=NULL\n");

commit 5d06e3df280bd230e2eadc16372e62818c63e894
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 18 19:46:58 2012 +0100

    staging: comedi: don't dereference user memory for INSN_INTTRIG
    
    `parse_insn()` is dereferencing the user-space pointer `insn->data`
    directly when handling the `INSN_INTTRIG` comedi instruction.  It
    shouldn't be using `insn->data` at all; it should be using the separate
    `data` pointer passed to the function.  Fix it.
    
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 9b9d4e8a2cf9..f496f4d96c83 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -950,7 +950,7 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 				ret = -EAGAIN;
 				break;
 			}
-			ret = s->async->inttrig(dev, s, insn->data[0]);
+			ret = s->async->inttrig(dev, s, data[0]);
 			if (ret >= 0)
 				ret = 1;
 			break;

commit dc881f294eb957bded69b5e7f2f72831e2d00ac4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 18 19:46:57 2012 +0100

    staging: comedi: fix sparse warning in do_devconfig_ioctl()
    
    For the COMEDI_DEVCONFIG ioctl, the user application may embed a pointer
    to firmware data within a designated element (or two elements for 64-bit
    pointers) of the `options[]` array in the `struct comedi_devconfig`.
    `do_devconfig_ioctl()` calls `comedi_aux_data()` to extract the pointer
    value.  It needs to be treated as a `__user` pointer so the firmware
    data can be copied into kernel memory, so cast the result of
    `comedi_aux_data()` to avoid a "sparse" warning.  This is not ideal but
    `comedi_aux_data()` is called elsewhere in a wholly kernel memory
    context so we can't just change its return type to include the `__user`
    tag.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 626fa723f199..9b9d4e8a2cf9 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -370,7 +370,8 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 			return -ENOMEM;
 
 		if (copy_from_user(aux_data,
-				   comedi_aux_data(it.options, 0), aux_len)) {
+				   (unsigned char __user *
+				    )comedi_aux_data(it.options, 0), aux_len)) {
 			vfree(aux_data);
 			return -EFAULT;
 		}

commit 95bc359f98a077a5cfc34feb0a333d11a4124b1c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Sep 18 11:43:52 2012 -0700

    staging: comedi: comedi_fops: cast the cmd->chanlist to the correct address space
    
    Rename 'chanlist_saver' to 'user_chanlist' to avoid confusion that
    it's actually a __user *.
    
    The chanlist pointer in comedi_cmd is still a user space pointer when
    the comedi_cmd is copied with copy_from_user() in do_cmd_ioctl() and
    do_cmdtest_ioctl(). This pointer needs to be cast when it is saved in
    user_chanlist in order to preserve its address space.
    
    The copy_from_user() call to copy the chanlist to the kernel space
    comedi_command requires the second parameter to be a __user pointer.
    Use the correctly cast user_chanlist instead of cmd->chanlist.
    
    Before the comedi_cmd is copied back to user space, the saved
    user_chanlist pointer is restored. Cast the user_chanlist again so
    that the address space matches the comedi_cmd.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index df627c8223d5..626fa723f199 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1137,14 +1137,14 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 	int ret = 0;
-	unsigned int __user *chanlist_saver = NULL;
+	unsigned int __user *user_chanlist;
 
 	if (copy_from_user(&cmd, arg, sizeof(struct comedi_cmd))) {
 		DPRINTK("bad cmd address\n");
 		return -EFAULT;
 	}
 	/* save user's chanlist pointer so it can be restored later */
-	chanlist_saver = cmd.chanlist;
+	user_chanlist = (unsigned int __user *)cmd.chanlist;
 
 	if (cmd.subdev >= dev->n_subdevices) {
 		DPRINTK("%d no such subdevice\n", cmd.subdev);
@@ -1206,7 +1206,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 		goto cleanup;
 	}
 
-	if (copy_from_user(async->cmd.chanlist, cmd.chanlist,
+	if (copy_from_user(async->cmd.chanlist, user_chanlist,
 			   async->cmd.chanlist_len * sizeof(int))) {
 		DPRINTK("fault reading chanlist\n");
 		ret = -EFAULT;
@@ -1228,7 +1228,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 		DPRINTK("test returned %d\n", ret);
 		cmd = async->cmd;
 		/* restore chanlist pointer before copying back */
-		cmd.chanlist = chanlist_saver;
+		cmd.chanlist = (unsigned int __force *)user_chanlist;
 		cmd.data = NULL;
 		if (copy_to_user(arg, &cmd, sizeof(struct comedi_cmd))) {
 			DPRINTK("fault writing cmd\n");
@@ -1287,14 +1287,14 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	int ret = 0;
 	unsigned int *chanlist = NULL;
-	unsigned int __user *chanlist_saver = NULL;
+	unsigned int __user *user_chanlist;
 
 	if (copy_from_user(&cmd, arg, sizeof(struct comedi_cmd))) {
 		DPRINTK("bad cmd address\n");
 		return -EFAULT;
 	}
 	/* save user's chanlist pointer so it can be restored later */
-	chanlist_saver = cmd.chanlist;
+	user_chanlist = (unsigned int __user *)cmd.chanlist;
 
 	if (cmd.subdev >= dev->n_subdevices) {
 		DPRINTK("%d no such subdevice\n", cmd.subdev);
@@ -1331,7 +1331,7 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 			goto cleanup;
 		}
 
-		if (copy_from_user(chanlist, cmd.chanlist,
+		if (copy_from_user(chanlist, user_chanlist,
 				   cmd.chanlist_len * sizeof(int))) {
 			DPRINTK("fault reading chanlist\n");
 			ret = -EFAULT;
@@ -1351,7 +1351,7 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 	ret = s->do_cmdtest(dev, s, &cmd);
 
 	/* restore chanlist pointer before copying back */
-	cmd.chanlist = chanlist_saver;
+	cmd.chanlist = (unsigned int __force *)user_chanlist;
 
 	if (copy_to_user(arg, &cmd, sizeof(struct comedi_cmd))) {
 		DPRINTK("bad cmd address\n");

commit f8348677b1fffff801d5323db7ccadfdb2b290d0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Sep 18 11:43:13 2012 -0700

    staging: comedi: comedi_fops: rename user_cmd in do_cmdtest_ioctl
    
    This local variable is used to hold the comedi_cmd that is passed
    to the kernel as the argument to the COMEDI_CMDTEST ioctl. Its filled
    in with a copy_from_user() call. The name 'user_cmd' is a bit
    confusing since it's actually kernel data.
    
    Rename the local variable to 'cmd' to avoid the confusion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a240e661c7b7..df627c8223d5 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1283,77 +1283,77 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 static int do_cmdtest_ioctl(struct comedi_device *dev,
 			    struct comedi_cmd __user *arg, void *file)
 {
-	struct comedi_cmd user_cmd;
+	struct comedi_cmd cmd;
 	struct comedi_subdevice *s;
 	int ret = 0;
 	unsigned int *chanlist = NULL;
 	unsigned int __user *chanlist_saver = NULL;
 
-	if (copy_from_user(&user_cmd, arg, sizeof(struct comedi_cmd))) {
+	if (copy_from_user(&cmd, arg, sizeof(struct comedi_cmd))) {
 		DPRINTK("bad cmd address\n");
 		return -EFAULT;
 	}
 	/* save user's chanlist pointer so it can be restored later */
-	chanlist_saver = user_cmd.chanlist;
+	chanlist_saver = cmd.chanlist;
 
-	if (user_cmd.subdev >= dev->n_subdevices) {
-		DPRINTK("%d no such subdevice\n", user_cmd.subdev);
+	if (cmd.subdev >= dev->n_subdevices) {
+		DPRINTK("%d no such subdevice\n", cmd.subdev);
 		return -ENODEV;
 	}
 
-	s = &dev->subdevices[user_cmd.subdev];
+	s = &dev->subdevices[cmd.subdev];
 	if (s->type == COMEDI_SUBD_UNUSED) {
-		DPRINTK("%d not valid subdevice\n", user_cmd.subdev);
+		DPRINTK("%d not valid subdevice\n", cmd.subdev);
 		return -EIO;
 	}
 
 	if (!s->do_cmd || !s->do_cmdtest) {
 		DPRINTK("subdevice %i does not support commands\n",
-			user_cmd.subdev);
+			cmd.subdev);
 		return -EIO;
 	}
 
 	/* make sure channel/gain list isn't too long */
-	if (user_cmd.chanlist_len > s->len_chanlist) {
+	if (cmd.chanlist_len > s->len_chanlist) {
 		DPRINTK("channel/gain list too long %d > %d\n",
-			user_cmd.chanlist_len, s->len_chanlist);
+			cmd.chanlist_len, s->len_chanlist);
 		ret = -EINVAL;
 		goto cleanup;
 	}
 
 	/* load channel/gain list */
-	if (user_cmd.chanlist) {
+	if (cmd.chanlist) {
 		chanlist =
-		    kmalloc(user_cmd.chanlist_len * sizeof(int), GFP_KERNEL);
+		    kmalloc(cmd.chanlist_len * sizeof(int), GFP_KERNEL);
 		if (!chanlist) {
 			DPRINTK("allocation failed\n");
 			ret = -ENOMEM;
 			goto cleanup;
 		}
 
-		if (copy_from_user(chanlist, user_cmd.chanlist,
-				   user_cmd.chanlist_len * sizeof(int))) {
+		if (copy_from_user(chanlist, cmd.chanlist,
+				   cmd.chanlist_len * sizeof(int))) {
 			DPRINTK("fault reading chanlist\n");
 			ret = -EFAULT;
 			goto cleanup;
 		}
 
 		/* make sure each element in channel/gain list is valid */
-		ret = comedi_check_chanlist(s, user_cmd.chanlist_len, chanlist);
+		ret = comedi_check_chanlist(s, cmd.chanlist_len, chanlist);
 		if (ret < 0) {
 			DPRINTK("bad chanlist\n");
 			goto cleanup;
 		}
 
-		user_cmd.chanlist = chanlist;
+		cmd.chanlist = chanlist;
 	}
 
-	ret = s->do_cmdtest(dev, s, &user_cmd);
+	ret = s->do_cmdtest(dev, s, &cmd);
 
 	/* restore chanlist pointer before copying back */
-	user_cmd.chanlist = chanlist_saver;
+	cmd.chanlist = chanlist_saver;
 
-	if (copy_to_user(arg, &user_cmd, sizeof(struct comedi_cmd))) {
+	if (copy_to_user(arg, &cmd, sizeof(struct comedi_cmd))) {
 		DPRINTK("bad cmd address\n");
 		ret = -EFAULT;
 		goto cleanup;

commit 88bc0574ba6a7cb38f4b5ea2f0e5ed9fe4ab7e27
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Sep 18 11:42:37 2012 -0700

    staging: comedi: comedi_fops: rename user_cmd in do_cmd_ioctl
    
    This local variable is used to hold the comedi_cmd that is passed
    to the kernel as the argument to the COMEDI_CMD ioctl. Its filled
    in with a copy_from_user() call. The name 'user_cmd' is a bit
    confusing since it's actually kernel data.
    
    Rename the local variable to 'cmd' to avoid the confusion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 04e299a0bea1..a240e661c7b7 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1133,35 +1133,35 @@ static void comedi_set_subdevice_runflags(struct comedi_subdevice *s,
 static int do_cmd_ioctl(struct comedi_device *dev,
 			struct comedi_cmd __user *arg, void *file)
 {
-	struct comedi_cmd user_cmd;
+	struct comedi_cmd cmd;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 	int ret = 0;
 	unsigned int __user *chanlist_saver = NULL;
 
-	if (copy_from_user(&user_cmd, arg, sizeof(struct comedi_cmd))) {
+	if (copy_from_user(&cmd, arg, sizeof(struct comedi_cmd))) {
 		DPRINTK("bad cmd address\n");
 		return -EFAULT;
 	}
 	/* save user's chanlist pointer so it can be restored later */
-	chanlist_saver = user_cmd.chanlist;
+	chanlist_saver = cmd.chanlist;
 
-	if (user_cmd.subdev >= dev->n_subdevices) {
-		DPRINTK("%d no such subdevice\n", user_cmd.subdev);
+	if (cmd.subdev >= dev->n_subdevices) {
+		DPRINTK("%d no such subdevice\n", cmd.subdev);
 		return -ENODEV;
 	}
 
-	s = &dev->subdevices[user_cmd.subdev];
+	s = &dev->subdevices[cmd.subdev];
 	async = s->async;
 
 	if (s->type == COMEDI_SUBD_UNUSED) {
-		DPRINTK("%d not valid subdevice\n", user_cmd.subdev);
+		DPRINTK("%d not valid subdevice\n", cmd.subdev);
 		return -EIO;
 	}
 
 	if (!s->do_cmd || !s->do_cmdtest || !s->async) {
 		DPRINTK("subdevice %i does not support commands\n",
-			user_cmd.subdev);
+			cmd.subdev);
 		return -EIO;
 	}
 
@@ -1179,23 +1179,23 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	s->busy = file;
 
 	/* make sure channel/gain list isn't too long */
-	if (user_cmd.chanlist_len > s->len_chanlist) {
+	if (cmd.chanlist_len > s->len_chanlist) {
 		DPRINTK("channel/gain list too long %u > %d\n",
-			user_cmd.chanlist_len, s->len_chanlist);
+			cmd.chanlist_len, s->len_chanlist);
 		ret = -EINVAL;
 		goto cleanup;
 	}
 
 	/* make sure channel/gain list isn't too short */
-	if (user_cmd.chanlist_len < 1) {
+	if (cmd.chanlist_len < 1) {
 		DPRINTK("channel/gain list too short %u < 1\n",
-			user_cmd.chanlist_len);
+			cmd.chanlist_len);
 		ret = -EINVAL;
 		goto cleanup;
 	}
 
 	kfree(async->cmd.chanlist);
-	async->cmd = user_cmd;
+	async->cmd = cmd;
 	async->cmd.data = NULL;
 	/* load channel/gain list */
 	async->cmd.chanlist =
@@ -1206,7 +1206,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 		goto cleanup;
 	}
 
-	if (copy_from_user(async->cmd.chanlist, user_cmd.chanlist,
+	if (copy_from_user(async->cmd.chanlist, cmd.chanlist,
 			   async->cmd.chanlist_len * sizeof(int))) {
 		DPRINTK("fault reading chanlist\n");
 		ret = -EFAULT;
@@ -1226,11 +1226,11 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 
 	if (async->cmd.flags & TRIG_BOGUS || ret) {
 		DPRINTK("test returned %d\n", ret);
-		user_cmd = async->cmd;
+		cmd = async->cmd;
 		/* restore chanlist pointer before copying back */
-		user_cmd.chanlist = chanlist_saver;
-		user_cmd.data = NULL;
-		if (copy_to_user(arg, &user_cmd, sizeof(struct comedi_cmd))) {
+		cmd.chanlist = chanlist_saver;
+		cmd.data = NULL;
+		if (copy_to_user(arg, &cmd, sizeof(struct comedi_cmd))) {
 			DPRINTK("fault writing cmd\n");
 			ret = -EFAULT;
 			goto cleanup;

commit cbe01f723e9287adb70410b69bedfdc87cd820b4
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Sep 18 11:41:54 2012 -0700

    staging: comedi: comedi_fops: rename the __user *cmd param in do_cmd_ioctl
    
    This parameter is actually the unsigned long arg passed in the ioctl.
    comedi_unlocked_ioctl() casts it as a (struct comedi_cmd __user *)
    when calling do_cmd_ioctl(). Rename the variable to keep this clear.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 00d8d1fd6e89..04e299a0bea1 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1131,7 +1131,7 @@ static void comedi_set_subdevice_runflags(struct comedi_subdevice *s,
 }
 
 static int do_cmd_ioctl(struct comedi_device *dev,
-			struct comedi_cmd __user *cmd, void *file)
+			struct comedi_cmd __user *arg, void *file)
 {
 	struct comedi_cmd user_cmd;
 	struct comedi_subdevice *s;
@@ -1139,7 +1139,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	int ret = 0;
 	unsigned int __user *chanlist_saver = NULL;
 
-	if (copy_from_user(&user_cmd, cmd, sizeof(struct comedi_cmd))) {
+	if (copy_from_user(&user_cmd, arg, sizeof(struct comedi_cmd))) {
 		DPRINTK("bad cmd address\n");
 		return -EFAULT;
 	}
@@ -1230,7 +1230,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 		/* restore chanlist pointer before copying back */
 		user_cmd.chanlist = chanlist_saver;
 		user_cmd.data = NULL;
-		if (copy_to_user(cmd, &user_cmd, sizeof(struct comedi_cmd))) {
+		if (copy_to_user(arg, &user_cmd, sizeof(struct comedi_cmd))) {
 			DPRINTK("fault writing cmd\n");
 			ret = -EFAULT;
 			goto cleanup;

commit 3e76c95107a3423e3dc9d6df09ad802f0e237e9b
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 17 13:13:12 2012 -0700

    staging: comedi: comedi_fops: make internal function static
    
    The function do_become_nonbusy() is only referenced in this file.
    Make it static.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index fb2ed2fbb6c8..00d8d1fd6e89 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2023,7 +2023,8 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 /*
    This function restores a subdevice to an idle state.
  */
-void do_become_nonbusy(struct comedi_device *dev, struct comedi_subdevice *s)
+static void do_become_nonbusy(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 

commit b077f2cd9b63798c676d62e03c85ace094e2d970
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:20:58 2012 -0700

    staging: comedi: comedi_fops: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 7a76f9c07afd..fb2ed2fbb6c8 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -426,7 +426,7 @@ static int do_bufconfig_ioctl(struct comedi_device *dev,
 	if (bc.subdevice >= dev->n_subdevices || bc.subdevice < 0)
 		return -EINVAL;
 
-	s = dev->subdevices + bc.subdevice;
+	s = &dev->subdevices[bc.subdevice];
 	async = s->async;
 
 	if (!async) {
@@ -539,7 +539,7 @@ static int do_subdinfo_ioctl(struct comedi_device *dev,
 
 	/* fill subdinfo structs */
 	for (i = 0; i < dev->n_subdevices; i++) {
-		s = dev->subdevices + i;
+		s = &dev->subdevices[i];
 		us = tmp + i;
 
 		us->type = s->type;
@@ -617,7 +617,7 @@ static int do_chaninfo_ioctl(struct comedi_device *dev,
 
 	if (it.subdev >= dev->n_subdevices)
 		return -EINVAL;
-	s = dev->subdevices + it.subdev;
+	s = &dev->subdevices[it.subdev];
 
 	if (it.maxdata_list) {
 		if (s->maxdata || !s->maxdata_list)
@@ -685,7 +685,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 	if (bi.subdevice >= dev->n_subdevices || bi.subdevice < 0)
 		return -EINVAL;
 
-	s = dev->subdevices + bi.subdevice;
+	s = &dev->subdevices[bi.subdevice];
 
 	if (s->lock && s->lock != file)
 		return -EACCES;
@@ -938,7 +938,7 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 				ret = -EINVAL;
 				break;
 			}
-			s = dev->subdevices + insn->subdev;
+			s = &dev->subdevices[insn->subdev];
 			if (!s->async) {
 				DPRINTK("no async\n");
 				ret = -EINVAL;
@@ -967,7 +967,7 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 			ret = -EINVAL;
 			goto out;
 		}
-		s = dev->subdevices + insn->subdev;
+		s = &dev->subdevices[insn->subdev];
 
 		if (s->type == COMEDI_SUBD_UNUSED) {
 			DPRINTK("%d not usable subdevice\n", insn->subdev);
@@ -1151,7 +1151,7 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 		return -ENODEV;
 	}
 
-	s = dev->subdevices + user_cmd.subdev;
+	s = &dev->subdevices[user_cmd.subdev];
 	async = s->async;
 
 	if (s->type == COMEDI_SUBD_UNUSED) {
@@ -1301,7 +1301,7 @@ static int do_cmdtest_ioctl(struct comedi_device *dev,
 		return -ENODEV;
 	}
 
-	s = dev->subdevices + user_cmd.subdev;
+	s = &dev->subdevices[user_cmd.subdev];
 	if (s->type == COMEDI_SUBD_UNUSED) {
 		DPRINTK("%d not valid subdevice\n", user_cmd.subdev);
 		return -EIO;
@@ -1388,7 +1388,7 @@ static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,
 
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
-	s = dev->subdevices + arg;
+	s = &dev->subdevices[arg];
 
 	spin_lock_irqsave(&s->spin_lock, flags);
 	if (s->busy || s->lock)
@@ -1431,7 +1431,7 @@ static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg,
 
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
-	s = dev->subdevices + arg;
+	s = &dev->subdevices[arg];
 
 	if (s->busy)
 		return -EBUSY;
@@ -1472,7 +1472,7 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
 
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
-	s = dev->subdevices + arg;
+	s = &dev->subdevices[arg];
 	if (s->async == NULL)
 		return -EINVAL;
 
@@ -1509,7 +1509,7 @@ static int do_poll_ioctl(struct comedi_device *dev, unsigned int arg,
 
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
-	s = dev->subdevices + arg;
+	s = &dev->subdevices[arg];
 
 	if (s->lock && s->lock != file)
 		return -EACCES;
@@ -2138,7 +2138,7 @@ static int comedi_close(struct inode *inode, struct file *file)
 
 	if (dev->subdevices) {
 		for (i = 0; i < dev->n_subdevices; i++) {
-			s = dev->subdevices + i;
+			s = &dev->subdevices[i];
 
 			if (s->busy == file)
 				do_cancel(dev, s);
@@ -2359,7 +2359,7 @@ static int is_device_busy(struct comedi_device *dev)
 		return 0;
 
 	for (i = 0; i < dev->n_subdevices; i++) {
-		s = dev->subdevices + i;
+		s = &dev->subdevices[i];
 		if (s->busy)
 			return 1;
 		if (s->async && s->async->mmap_count)

commit 4f870fe6269bbc7cca2a70c50a4cc6f811fe21c5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Aug 16 14:38:05 2012 +0100

    staging: comedi: replace printk calls in comedi core
    
    Replace the printk() calls in the comedi core module with something more
    suitable, such as dev_...() or pr_...().  Remove the ones that report a
    failure to increment a module count (try_module_get() failure).  Change
    the printk() call in the DPRINTK() macro to pr_debug().
    
    TODO: Most of the DPRINTK() calls need to be replaced with something
    else.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e82126407e95..7a76f9c07afd 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -882,14 +882,12 @@ static int check_insn_config_length(struct comedi_insn *insn,
 		/* by default we allow the insn since we don't have checks for
 		 * all possible cases yet */
 	default:
-		printk(KERN_WARNING
-		       "comedi: no check for data length of config insn id "
-		       "%i is implemented.\n"
-		       " Add a check to %s in %s.\n"
-		       " Assuming n=%i is correct.\n", data[0], __func__,
-		       __FILE__, insn->n);
+		pr_warn("comedi: No check for data length of config insn id %i is implemented.\n",
+			data[0]);
+		pr_warn("comedi: Add a check to %s in %s.\n",
+			__func__, __FILE__);
+		pr_warn("comedi: Assuming n=%i is correct.\n", insn->n);
 		return 0;
-		break;
 	}
 	return -EINVAL;
 }
@@ -2034,8 +2032,8 @@ void do_become_nonbusy(struct comedi_device *dev, struct comedi_subdevice *s)
 		comedi_reset_async_buf(async);
 		async->inttrig = NULL;
 	} else {
-		printk(KERN_ERR
-		       "BUG: (?) do_become_nonbusy called with async=0\n");
+		dev_err(dev->class_dev,
+			"BUG: (?) do_become_nonbusy called with async=NULL\n");
 	}
 
 	s->busy = NULL;
@@ -2211,14 +2209,12 @@ static int __init comedi_init(void)
 	int i;
 	int retval;
 
-	printk(KERN_INFO "comedi: version " COMEDI_RELEASE
-	       " - http://www.comedi.org\n");
+	pr_info("comedi: version " COMEDI_RELEASE " - http://www.comedi.org\n");
 
 	if (comedi_num_legacy_minors < 0 ||
 	    comedi_num_legacy_minors > COMEDI_NUM_BOARD_MINORS) {
-		printk(KERN_ERR "comedi: error: invalid value for module "
-		       "parameter \"comedi_num_legacy_minors\".  Valid values "
-		       "are 0 through %i.\n", COMEDI_NUM_BOARD_MINORS);
+		pr_err("comedi: error: invalid value for module parameter \"comedi_num_legacy_minors\".  Valid values are 0 through %i.\n",
+		       COMEDI_NUM_BOARD_MINORS);
 		return -EINVAL;
 	}
 
@@ -2247,7 +2243,7 @@ static int __init comedi_init(void)
 	}
 	comedi_class = class_create(THIS_MODULE, "comedi");
 	if (IS_ERR(comedi_class)) {
-		printk(KERN_ERR "comedi: failed to create class");
+		pr_err("comedi: failed to create class\n");
 		cdev_del(&comedi_cdev);
 		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 					 COMEDI_NUM_MINORS);
@@ -2295,8 +2291,7 @@ module_exit(comedi_cleanup);
 
 void comedi_error(const struct comedi_device *dev, const char *s)
 {
-	printk(KERN_ERR "comedi%d: %s: %s\n", dev->minor,
-	       dev->driver->driver_name, s);
+	dev_err(dev->class_dev, "%s: %s\n", dev->driver->driver_name, s);
 }
 EXPORT_SYMBOL(comedi_error);
 
@@ -2420,9 +2415,7 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 		comedi_device_cleanup(info->device);
 		kfree(info->device);
 		kfree(info);
-		printk(KERN_ERR
-		       "comedi: error: "
-		       "ran out of minor numbers for board device files.\n");
+		pr_err("comedi: error: ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}
 	info->device->minor = i;
@@ -2499,9 +2492,7 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	spin_unlock(&comedi_file_info_table_lock);
 	if (i == COMEDI_NUM_MINORS) {
 		kfree(info);
-		printk(KERN_ERR
-		       "comedi: error: "
-		       "ran out of minor numbers for board device files.\n");
+		pr_err("comedi: error: ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}
 	s->minor = i;

commit f286766e4ba899043714471a0a2c9f1474d2ab5c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jun 19 10:17:46 2012 +0100

    staging: comedi: remove comedi_fops.h
    
    Move the contents of "comedi_fops.h" into "comedi_internal.h" and delete
    "comedi_fops.h". It only contains a couple of external variable
    declarations (and #include <linux/types.h>) and one of those isn't even
    declared in "comedi_fops.c".  The other one is an external declaration
    of a variable used to store a module parameter and some of those are
    already externally declared in "comedi_internal.h", so they can keep it
    company!
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1079b0e7a264..e82126407e95 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -24,7 +24,6 @@
 #undef DEBUG
 
 #define __NO_VERSION__
-#include "comedi_fops.h"
 #include "comedi_compat32.h"
 
 #include <linux/module.h>

commit 3a5fa27516116352e810b2122afd82c3d5cbcc7e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jun 19 10:17:44 2012 +0100

    staging: comedi: rename internal.h to comedi_internal.h
    
    Use a less generic name for this internal header file included by
    various parts of the comedi core.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 3650753b62f7..1079b0e7a264 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -49,7 +49,7 @@
 #include <linux/io.h>
 #include <linux/uaccess.h>
 
-#include "internal.h"
+#include "comedi_internal.h"
 
 MODULE_AUTHOR("http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi core module");

commit 8cb8aad7d34cdc82fe205905c8dff771efb9604d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jun 19 10:17:43 2012 +0100

    staging: comedi: make class and file operations static
    
    A couple of global variables in "comedi_fops.c" are only referenced from
    that .c file and can be declared 'static'.  Also remove them from
    "comedi_fops.h" where they are declared 'extern'.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ad8634734194..3650753b62f7 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2182,7 +2182,7 @@ static int comedi_fasync(int fd, struct file *file, int on)
 	return fasync_helper(fd, file, on, &dev->async_queue);
 }
 
-const struct file_operations comedi_fops = {
+static const struct file_operations comedi_fops = {
 	.owner = THIS_MODULE,
 	.unlocked_ioctl = comedi_unlocked_ioctl,
 	.compat_ioctl = comedi_compat_ioctl,
@@ -2196,7 +2196,7 @@ const struct file_operations comedi_fops = {
 	.llseek = noop_llseek,
 };
 
-struct class *comedi_class;
+static struct class *comedi_class;
 static struct cdev comedi_cdev;
 
 static void comedi_cleanup_legacy_minors(void)

commit 47db6d58099437ddcec4fd2e572c95eba8c37cdd
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Jun 7 17:05:27 2012 -0700

    staging: comedi: refactor comedi_fops to remove most of the forward declarations
    
    Move the comedi_unlocked_ioctl function in order to remove most of
    the forward declarations in this file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b3b86d48c771..ad8634734194 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -92,36 +92,6 @@ static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info
 *comedi_file_info_table[COMEDI_NUM_MINORS];
 
-static int do_devconfig_ioctl(struct comedi_device *dev,
-			      struct comedi_devconfig __user *arg);
-static int do_bufconfig_ioctl(struct comedi_device *dev,
-			      struct comedi_bufconfig __user *arg);
-static int do_devinfo_ioctl(struct comedi_device *dev,
-			    struct comedi_devinfo __user *arg,
-			    struct file *file);
-static int do_subdinfo_ioctl(struct comedi_device *dev,
-			     struct comedi_subdinfo __user *arg, void *file);
-static int do_chaninfo_ioctl(struct comedi_device *dev,
-			     struct comedi_chaninfo __user *arg);
-static int do_bufinfo_ioctl(struct comedi_device *dev,
-			    struct comedi_bufinfo __user *arg, void *file);
-static int do_cmd_ioctl(struct comedi_device *dev,
-			struct comedi_cmd __user *arg, void *file);
-static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,
-			 void *file);
-static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg,
-			   void *file);
-static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
-			   void *file);
-static int do_cmdtest_ioctl(struct comedi_device *dev,
-			    struct comedi_cmd __user *arg, void *file);
-static int do_insnlist_ioctl(struct comedi_device *dev,
-			     struct comedi_insnlist __user *arg, void *file);
-static int do_insn_ioctl(struct comedi_device *dev,
-			 struct comedi_insn __user *arg, void *file);
-static int do_poll_ioctl(struct comedi_device *dev, unsigned int subd,
-			 void *file);
-
 static void do_become_nonbusy(struct comedi_device *dev,
 			      struct comedi_subdevice *s);
 static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
@@ -349,98 +319,6 @@ static struct device_attribute comedi_dev_attrs[] = {
 	__ATTR_NULL
 };
 
-static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
-				  unsigned long arg)
-{
-	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info =
-	    comedi_get_device_file_info(minor);
-	struct comedi_device *dev;
-	int rc;
-
-	if (dev_file_info == NULL || dev_file_info->device == NULL)
-		return -ENODEV;
-	dev = dev_file_info->device;
-
-	mutex_lock(&dev->mutex);
-
-	/* Device config is special, because it must work on
-	 * an unconfigured device. */
-	if (cmd == COMEDI_DEVCONFIG) {
-		rc = do_devconfig_ioctl(dev,
-					(struct comedi_devconfig __user *)arg);
-		goto done;
-	}
-
-	if (!dev->attached) {
-		DPRINTK("no driver configured on /dev/comedi%i\n", dev->minor);
-		rc = -ENODEV;
-		goto done;
-	}
-
-	switch (cmd) {
-	case COMEDI_BUFCONFIG:
-		rc = do_bufconfig_ioctl(dev,
-					(struct comedi_bufconfig __user *)arg);
-		break;
-	case COMEDI_DEVINFO:
-		rc = do_devinfo_ioctl(dev, (struct comedi_devinfo __user *)arg,
-				      file);
-		break;
-	case COMEDI_SUBDINFO:
-		rc = do_subdinfo_ioctl(dev,
-				       (struct comedi_subdinfo __user *)arg,
-				       file);
-		break;
-	case COMEDI_CHANINFO:
-		rc = do_chaninfo_ioctl(dev, (void __user *)arg);
-		break;
-	case COMEDI_RANGEINFO:
-		rc = do_rangeinfo_ioctl(dev, (void __user *)arg);
-		break;
-	case COMEDI_BUFINFO:
-		rc = do_bufinfo_ioctl(dev,
-				      (struct comedi_bufinfo __user *)arg,
-				      file);
-		break;
-	case COMEDI_LOCK:
-		rc = do_lock_ioctl(dev, arg, file);
-		break;
-	case COMEDI_UNLOCK:
-		rc = do_unlock_ioctl(dev, arg, file);
-		break;
-	case COMEDI_CANCEL:
-		rc = do_cancel_ioctl(dev, arg, file);
-		break;
-	case COMEDI_CMD:
-		rc = do_cmd_ioctl(dev, (struct comedi_cmd __user *)arg, file);
-		break;
-	case COMEDI_CMDTEST:
-		rc = do_cmdtest_ioctl(dev, (struct comedi_cmd __user *)arg,
-				      file);
-		break;
-	case COMEDI_INSNLIST:
-		rc = do_insnlist_ioctl(dev,
-				       (struct comedi_insnlist __user *)arg,
-				       file);
-		break;
-	case COMEDI_INSN:
-		rc = do_insn_ioctl(dev, (struct comedi_insn __user *)arg,
-				   file);
-		break;
-	case COMEDI_POLL:
-		rc = do_poll_ioctl(dev, arg, file);
-		break;
-	default:
-		rc = -ENOTTY;
-		break;
-	}
-
-done:
-	mutex_unlock(&dev->mutex);
-	return rc;
-}
-
 /*
 	COMEDI_DEVCONFIG
 	device config ioctl
@@ -1651,6 +1529,98 @@ static int do_poll_ioctl(struct comedi_device *dev, unsigned int arg,
 	return -EINVAL;
 }
 
+static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
+				  unsigned long arg)
+{
+	const unsigned minor = iminor(file->f_dentry->d_inode);
+	struct comedi_device_file_info *dev_file_info =
+	    comedi_get_device_file_info(minor);
+	struct comedi_device *dev;
+	int rc;
+
+	if (dev_file_info == NULL || dev_file_info->device == NULL)
+		return -ENODEV;
+	dev = dev_file_info->device;
+
+	mutex_lock(&dev->mutex);
+
+	/* Device config is special, because it must work on
+	 * an unconfigured device. */
+	if (cmd == COMEDI_DEVCONFIG) {
+		rc = do_devconfig_ioctl(dev,
+					(struct comedi_devconfig __user *)arg);
+		goto done;
+	}
+
+	if (!dev->attached) {
+		DPRINTK("no driver configured on /dev/comedi%i\n", dev->minor);
+		rc = -ENODEV;
+		goto done;
+	}
+
+	switch (cmd) {
+	case COMEDI_BUFCONFIG:
+		rc = do_bufconfig_ioctl(dev,
+					(struct comedi_bufconfig __user *)arg);
+		break;
+	case COMEDI_DEVINFO:
+		rc = do_devinfo_ioctl(dev, (struct comedi_devinfo __user *)arg,
+				      file);
+		break;
+	case COMEDI_SUBDINFO:
+		rc = do_subdinfo_ioctl(dev,
+				       (struct comedi_subdinfo __user *)arg,
+				       file);
+		break;
+	case COMEDI_CHANINFO:
+		rc = do_chaninfo_ioctl(dev, (void __user *)arg);
+		break;
+	case COMEDI_RANGEINFO:
+		rc = do_rangeinfo_ioctl(dev, (void __user *)arg);
+		break;
+	case COMEDI_BUFINFO:
+		rc = do_bufinfo_ioctl(dev,
+				      (struct comedi_bufinfo __user *)arg,
+				      file);
+		break;
+	case COMEDI_LOCK:
+		rc = do_lock_ioctl(dev, arg, file);
+		break;
+	case COMEDI_UNLOCK:
+		rc = do_unlock_ioctl(dev, arg, file);
+		break;
+	case COMEDI_CANCEL:
+		rc = do_cancel_ioctl(dev, arg, file);
+		break;
+	case COMEDI_CMD:
+		rc = do_cmd_ioctl(dev, (struct comedi_cmd __user *)arg, file);
+		break;
+	case COMEDI_CMDTEST:
+		rc = do_cmdtest_ioctl(dev, (struct comedi_cmd __user *)arg,
+				      file);
+		break;
+	case COMEDI_INSNLIST:
+		rc = do_insnlist_ioctl(dev,
+				       (struct comedi_insnlist __user *)arg,
+				       file);
+		break;
+	case COMEDI_INSN:
+		rc = do_insn_ioctl(dev, (struct comedi_insn __user *)arg,
+				   file);
+		break;
+	case COMEDI_POLL:
+		rc = do_poll_ioctl(dev, arg, file);
+		break;
+	default:
+		rc = -ENOTTY;
+		break;
+	}
+
+done:
+	mutex_unlock(&dev->mutex);
+	return rc;
+}
+
 static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int ret = 0;

commit 72fd9facfb697d5f7b61958bb10efaabbd8461eb
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 5 10:18:02 2012 -0700

    staging: comedi: cleanup sysfs functions
    
    Make the comedi sysfs functions a bit more concise by shortening
    some of the verbose variable names and reusing some of the
    variables that were used for intermediate calculations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 76776571ed91..b3b86d48c771 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -172,28 +172,19 @@ static int resize_async_buffer(struct comedi_device *dev,
 
 /* sysfs attribute files */
 
-static const unsigned bytes_per_kibi = 1024;
-
 static ssize_t show_max_read_buffer_kb(struct device *dev,
 				       struct device_attribute *attr, char *buf)
 {
-	ssize_t retval;
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned max_buffer_size_kb = 0;
-	struct comedi_subdevice *const read_subdevice =
-	    comedi_get_read_subdevice(info);
+	struct comedi_subdevice *s = comedi_get_read_subdevice(info);
+	unsigned int size = 0;
 
 	mutex_lock(&info->device->mutex);
-	if (read_subdevice &&
-	    (read_subdevice->subdev_flags & SDF_CMD_READ) &&
-	    read_subdevice->async) {
-		max_buffer_size_kb = read_subdevice->async->max_bufsize /
-		    bytes_per_kibi;
-	}
-	retval = snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
+	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
+		size = s->async->max_bufsize / 1024;
 	mutex_unlock(&info->device->mutex);
 
-	return retval;
+	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
 static ssize_t store_max_read_buffer_kb(struct device *dev,
@@ -201,52 +192,40 @@ static ssize_t store_max_read_buffer_kb(struct device *dev,
 					const char *buf, size_t count)
 {
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned int new_max_size_kb;
-	unsigned int new_max_size;
-	int ret;
-	struct comedi_subdevice *const read_subdevice =
-	    comedi_get_read_subdevice(info);
-
-	ret = kstrtouint(buf, 10, &new_max_size_kb);
-	if (ret)
-		return ret;
-	if (new_max_size_kb > (UINT_MAX / bytes_per_kibi))
+	struct comedi_subdevice *s = comedi_get_read_subdevice(info);
+	unsigned int size;
+	int err;
+
+	err = kstrtouint(buf, 10, &size);
+	if (err)
+		return err;
+	if (size > (UINT_MAX / 1024))
 		return -EINVAL;
-	new_max_size = new_max_size_kb * bytes_per_kibi;
+	size *= 1024;
 
 	mutex_lock(&info->device->mutex);
-	if (read_subdevice == NULL ||
-	    (read_subdevice->subdev_flags & SDF_CMD_READ) == 0 ||
-	    read_subdevice->async == NULL) {
-		mutex_unlock(&info->device->mutex);
-		return -EINVAL;
-	}
-	read_subdevice->async->max_bufsize = new_max_size;
+	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
+		s->async->max_bufsize = size;
+	else
+		err = -EINVAL;
 	mutex_unlock(&info->device->mutex);
 
-	return count;
+	return err ? err : count;
 }
 
 static ssize_t show_read_buffer_kb(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
-	ssize_t retval;
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned buffer_size_kb = 0;
-	struct comedi_subdevice *const read_subdevice =
-	    comedi_get_read_subdevice(info);
+	struct comedi_subdevice *s = comedi_get_read_subdevice(info);
+	unsigned int size = 0;
 
 	mutex_lock(&info->device->mutex);
-	if (read_subdevice &&
-	    (read_subdevice->subdev_flags & SDF_CMD_READ) &&
-	    read_subdevice->async) {
-		buffer_size_kb = read_subdevice->async->prealloc_bufsz /
-		    bytes_per_kibi;
-	}
-	retval = snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
+	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
+		size = s->async->prealloc_bufsz / 1024;
 	mutex_unlock(&info->device->mutex);
 
-	return retval;
+	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
 static ssize_t store_read_buffer_kb(struct device *dev,
@@ -254,57 +233,41 @@ static ssize_t store_read_buffer_kb(struct device *dev,
 				    const char *buf, size_t count)
 {
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned int new_size_kb;
-	unsigned int new_size;
-	int retval;
-	int ret;
-	struct comedi_subdevice *const read_subdevice =
-	    comedi_get_read_subdevice(info);
-
-	ret = kstrtouint(buf, 10, &new_size_kb);
-	if (ret)
-		return ret;
-	if (new_size_kb > (UINT_MAX / bytes_per_kibi))
+	struct comedi_subdevice *s = comedi_get_read_subdevice(info);
+	unsigned int size;
+	int err;
+
+	err = kstrtouint(buf, 10, &size);
+	if (err)
+		return err;
+	if (size > (UINT_MAX / 1024))
 		return -EINVAL;
-	new_size = new_size_kb * bytes_per_kibi;
+	size *= 1024;
 
 	mutex_lock(&info->device->mutex);
-	if (read_subdevice == NULL ||
-	    (read_subdevice->subdev_flags & SDF_CMD_READ) == 0 ||
-	    read_subdevice->async == NULL) {
-		mutex_unlock(&info->device->mutex);
-		return -EINVAL;
-	}
-	retval = resize_async_buffer(info->device, read_subdevice,
-				     read_subdevice->async, new_size);
+	if (s && (s->subdev_flags & SDF_CMD_READ) && s->async)
+		err = resize_async_buffer(info->device, s, s->async, size);
+	else
+		err = -EINVAL;
 	mutex_unlock(&info->device->mutex);
 
-	if (retval < 0)
-		return retval;
-	return count;
+	return err ? err : count;
 }
 
 static ssize_t show_max_write_buffer_kb(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	ssize_t retval;
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned max_buffer_size_kb = 0;
-	struct comedi_subdevice *const write_subdevice =
-	    comedi_get_write_subdevice(info);
+	struct comedi_subdevice *s = comedi_get_write_subdevice(info);
+	unsigned int size = 0;
 
 	mutex_lock(&info->device->mutex);
-	if (write_subdevice &&
-	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) &&
-	    write_subdevice->async) {
-		max_buffer_size_kb = write_subdevice->async->max_bufsize /
-		    bytes_per_kibi;
-	}
-	retval = snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
+	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
+		size = s->async->max_bufsize / 1024;
 	mutex_unlock(&info->device->mutex);
 
-	return retval;
+	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
 static ssize_t store_max_write_buffer_kb(struct device *dev,
@@ -312,52 +275,40 @@ static ssize_t store_max_write_buffer_kb(struct device *dev,
 					 const char *buf, size_t count)
 {
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned int new_max_size_kb;
-	unsigned int new_max_size;
-	int ret;
-	struct comedi_subdevice *const write_subdevice =
-	    comedi_get_write_subdevice(info);
-
-	ret = kstrtouint(buf, 10, &new_max_size_kb);
-	if (ret)
-		return ret;
-	if (new_max_size_kb > (UINT_MAX / bytes_per_kibi))
+	struct comedi_subdevice *s = comedi_get_write_subdevice(info);
+	unsigned int size;
+	int err;
+
+	err = kstrtouint(buf, 10, &size);
+	if (err)
+		return err;
+	if (size > (UINT_MAX / 1024))
 		return -EINVAL;
-	new_max_size = new_max_size_kb * bytes_per_kibi;
+	size *= 1024;
 
 	mutex_lock(&info->device->mutex);
-	if (write_subdevice == NULL ||
-	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) == 0 ||
-	    write_subdevice->async == NULL) {
-		mutex_unlock(&info->device->mutex);
-		return -EINVAL;
-	}
-	write_subdevice->async->max_bufsize = new_max_size;
+	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
+		s->async->max_bufsize = size;
+	else
+		err = -EINVAL;
 	mutex_unlock(&info->device->mutex);
 
-	return count;
+	return err ? err : count;
 }
 
 static ssize_t show_write_buffer_kb(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
-	ssize_t retval;
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned buffer_size_kb = 0;
-	struct comedi_subdevice *const write_subdevice =
-	    comedi_get_write_subdevice(info);
+	struct comedi_subdevice *s = comedi_get_write_subdevice(info);
+	unsigned int size = 0;
 
 	mutex_lock(&info->device->mutex);
-	if (write_subdevice &&
-	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) &&
-	    write_subdevice->async) {
-		buffer_size_kb = write_subdevice->async->prealloc_bufsz /
-		    bytes_per_kibi;
-	}
-	retval = snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
+	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
+		size = s->async->prealloc_bufsz / 1024;
 	mutex_unlock(&info->device->mutex);
 
-	return retval;
+	return snprintf(buf, PAGE_SIZE, "%i\n", size);
 }
 
 static ssize_t store_write_buffer_kb(struct device *dev,
@@ -365,34 +316,25 @@ static ssize_t store_write_buffer_kb(struct device *dev,
 				     const char *buf, size_t count)
 {
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned int new_size_kb;
-	unsigned int new_size;
-	int retval;
-	int ret;
-	struct comedi_subdevice *const write_subdevice =
-	    comedi_get_write_subdevice(info);
-
-	ret = kstrtouint(buf, 10, &new_size_kb);
-	if (ret)
-		return ret;
-	if (new_size_kb > (UINT_MAX / bytes_per_kibi))
+	struct comedi_subdevice *s = comedi_get_write_subdevice(info);
+	unsigned int size;
+	int err;
+
+	err = kstrtouint(buf, 10, &size);
+	if (err)
+		return err;
+	if (size > (UINT_MAX / 1024))
 		return -EINVAL;
-	new_size = ((uint64_t) new_size_kb) * bytes_per_kibi;
+	size *= 1024;
 
 	mutex_lock(&info->device->mutex);
-	if (write_subdevice == NULL ||
-	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) == 0 ||
-	    write_subdevice->async == NULL) {
-		mutex_unlock(&info->device->mutex);
-		return -EINVAL;
-	}
-	retval = resize_async_buffer(info->device, write_subdevice,
-				     write_subdevice->async, new_size);
+	if (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)
+		err = resize_async_buffer(info->device, s, s->async, size);
+	else
+		err = -EINVAL;
 	mutex_unlock(&info->device->mutex);
 
-	if (retval < 0)
-		return retval;
-	return count;
+	return err ? err : count;
 }
 
 static struct device_attribute comedi_dev_attrs[] = {

commit fb60367d5dff0e2ee3032f7daf212e5ed9863552
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 10 18:05:28 2012 -0700

    staging: comedi: register sysfs device attributes with driver core
    
    Currently the sysfs device attributes are created by the comedi
    core after each comedi device is created. This can lead to a race
    condition where userspace gets an add event before the files are
    created.
    
    Register the device attributes with the comedi class so that the
    driver core handles creating them and we avoid the race.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 44ca1feebe24..76776571ed91 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -227,9 +227,6 @@ static ssize_t store_max_read_buffer_kb(struct device *dev,
 	return count;
 }
 
-static DEVICE_ATTR(max_read_buffer_kb, S_IRUGO | S_IWUSR,
-		show_max_read_buffer_kb, store_max_read_buffer_kb);
-
 static ssize_t show_read_buffer_kb(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
@@ -287,9 +284,6 @@ static ssize_t store_read_buffer_kb(struct device *dev,
 	return count;
 }
 
-static DEVICE_ATTR(read_buffer_kb, S_IRUGO | S_IWUSR | S_IWGRP,
-		show_read_buffer_kb, store_read_buffer_kb);
-
 static ssize_t show_max_write_buffer_kb(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
@@ -344,9 +338,6 @@ static ssize_t store_max_write_buffer_kb(struct device *dev,
 	return count;
 }
 
-static DEVICE_ATTR(max_write_buffer_kb, S_IRUGO | S_IWUSR,
-		show_max_write_buffer_kb, store_max_write_buffer_kb);
-
 static ssize_t show_write_buffer_kb(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
@@ -404,19 +395,16 @@ static ssize_t store_write_buffer_kb(struct device *dev,
 	return count;
 }
 
-static DEVICE_ATTR(write_buffer_kb, S_IRUGO | S_IWUSR | S_IWGRP,
-		show_write_buffer_kb, store_write_buffer_kb);
-
-static struct attribute *comedi_attrs[] = {
-	&dev_attr_max_read_buffer_kb.attr,
-	&dev_attr_read_buffer_kb.attr,
-	&dev_attr_max_write_buffer_kb.attr,
-	&dev_attr_write_buffer_kb.attr,
-	NULL
-};
-
-static const struct attribute_group comedi_sysfs_files = {
-	.attrs	= comedi_attrs,
+static struct device_attribute comedi_dev_attrs[] = {
+	__ATTR(max_read_buffer_kb, S_IRUGO | S_IWUSR,
+		show_max_read_buffer_kb, store_max_read_buffer_kb),
+	__ATTR(read_buffer_kb, S_IRUGO | S_IWUSR | S_IWGRP,
+		show_read_buffer_kb, store_read_buffer_kb),
+	__ATTR(max_write_buffer_kb, S_IRUGO | S_IWUSR,
+		show_max_write_buffer_kb, store_max_write_buffer_kb),
+	__ATTR(write_buffer_kb, S_IRUGO | S_IWUSR | S_IWGRP,
+		show_write_buffer_kb, store_write_buffer_kb),
+	__ATTR_NULL
 };
 
 static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
@@ -2355,6 +2343,8 @@ static int __init comedi_init(void)
 		return PTR_ERR(comedi_class);
 	}
 
+	comedi_class->dev_attrs = comedi_dev_attrs;
+
 	/* XXX requires /proc interface */
 	comedi_proc_init();
 
@@ -2496,7 +2486,6 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	struct comedi_device_file_info *info;
 	struct device *csdev;
 	unsigned i;
-	int retval;
 
 	info = kzalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
 	if (info == NULL)
@@ -2532,14 +2521,6 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 		info->device->class_dev = csdev;
 	dev_set_drvdata(csdev, info);
 
-	retval = sysfs_create_group(&csdev->kobj, &comedi_sysfs_files);
-	if (retval) {
-		printk(KERN_ERR
-		       "comedi: failed to create sysfs attribute files\n");
-		comedi_free_board_minor(i);
-		return retval;
-	}
-
 	return i;
 }
 
@@ -2590,7 +2571,6 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	struct comedi_device_file_info *info;
 	struct device *csdev;
 	unsigned i;
-	int retval;
 
 	info = kmalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
 	if (info == NULL)
@@ -2621,14 +2601,6 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 		s->class_dev = csdev;
 	dev_set_drvdata(csdev, info);
 
-	retval = sysfs_create_group(&csdev->kobj, &comedi_sysfs_files);
-	if (retval) {
-		printk(KERN_ERR
-		       "comedi: failed to create sysfs attribute files\n");
-		comedi_free_subdevice_minor(s);
-		return retval;
-	}
-
 	return i;
 }
 

commit a5011a261574239403468368605f5e0625dcfb56
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed May 9 09:20:08 2012 -0700

    staging: comedi: refactor sysfs files in comedi_fops.c
    
    Refactor the sysfs attributes and functions to remove
    the need for the forward declarations and use the
    DEVICE_ATTR macro to define them.
    
    Instead of individually creating sysfs device attribute
    files, wrap them in an attribute_group and use the
    sysfs_create_group function to create them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 06fc6569c859..44ca1feebe24 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -129,15 +129,295 @@ static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int comedi_fasync(int fd, struct file *file, int on);
 
 static int is_device_busy(struct comedi_device *dev);
+
 static int resize_async_buffer(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
-			       struct comedi_async *async, unsigned new_size);
+			       struct comedi_async *async, unsigned new_size)
+{
+	int retval;
+
+	if (new_size > async->max_bufsize)
+		return -EPERM;
+
+	if (s->busy) {
+		DPRINTK("subdevice is busy, cannot resize buffer\n");
+		return -EBUSY;
+	}
+	if (async->mmap_count) {
+		DPRINTK("subdevice is mmapped, cannot resize buffer\n");
+		return -EBUSY;
+	}
+
+	if (!async->prealloc_buf)
+		return -EINVAL;
+
+	/* make sure buffer is an integral number of pages
+	 * (we round up) */
+	new_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;
+
+	retval = comedi_buf_alloc(dev, s, new_size);
+	if (retval < 0)
+		return retval;
+
+	if (s->buf_change) {
+		retval = s->buf_change(dev, s, new_size);
+		if (retval < 0)
+			return retval;
+	}
+
+	DPRINTK("comedi%i subd %d buffer resized to %i bytes\n",
+		dev->minor, (int)(s - dev->subdevices), async->prealloc_bufsz);
+	return 0;
+}
+
+/* sysfs attribute files */
+
+static const unsigned bytes_per_kibi = 1024;
+
+static ssize_t show_max_read_buffer_kb(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	ssize_t retval;
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned max_buffer_size_kb = 0;
+	struct comedi_subdevice *const read_subdevice =
+	    comedi_get_read_subdevice(info);
+
+	mutex_lock(&info->device->mutex);
+	if (read_subdevice &&
+	    (read_subdevice->subdev_flags & SDF_CMD_READ) &&
+	    read_subdevice->async) {
+		max_buffer_size_kb = read_subdevice->async->max_bufsize /
+		    bytes_per_kibi;
+	}
+	retval = snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
+	mutex_unlock(&info->device->mutex);
+
+	return retval;
+}
+
+static ssize_t store_max_read_buffer_kb(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned int new_max_size_kb;
+	unsigned int new_max_size;
+	int ret;
+	struct comedi_subdevice *const read_subdevice =
+	    comedi_get_read_subdevice(info);
+
+	ret = kstrtouint(buf, 10, &new_max_size_kb);
+	if (ret)
+		return ret;
+	if (new_max_size_kb > (UINT_MAX / bytes_per_kibi))
+		return -EINVAL;
+	new_max_size = new_max_size_kb * bytes_per_kibi;
+
+	mutex_lock(&info->device->mutex);
+	if (read_subdevice == NULL ||
+	    (read_subdevice->subdev_flags & SDF_CMD_READ) == 0 ||
+	    read_subdevice->async == NULL) {
+		mutex_unlock(&info->device->mutex);
+		return -EINVAL;
+	}
+	read_subdevice->async->max_bufsize = new_max_size;
+	mutex_unlock(&info->device->mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(max_read_buffer_kb, S_IRUGO | S_IWUSR,
+		show_max_read_buffer_kb, store_max_read_buffer_kb);
+
+static ssize_t show_read_buffer_kb(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	ssize_t retval;
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned buffer_size_kb = 0;
+	struct comedi_subdevice *const read_subdevice =
+	    comedi_get_read_subdevice(info);
+
+	mutex_lock(&info->device->mutex);
+	if (read_subdevice &&
+	    (read_subdevice->subdev_flags & SDF_CMD_READ) &&
+	    read_subdevice->async) {
+		buffer_size_kb = read_subdevice->async->prealloc_bufsz /
+		    bytes_per_kibi;
+	}
+	retval = snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
+	mutex_unlock(&info->device->mutex);
+
+	return retval;
+}
+
+static ssize_t store_read_buffer_kb(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned int new_size_kb;
+	unsigned int new_size;
+	int retval;
+	int ret;
+	struct comedi_subdevice *const read_subdevice =
+	    comedi_get_read_subdevice(info);
+
+	ret = kstrtouint(buf, 10, &new_size_kb);
+	if (ret)
+		return ret;
+	if (new_size_kb > (UINT_MAX / bytes_per_kibi))
+		return -EINVAL;
+	new_size = new_size_kb * bytes_per_kibi;
+
+	mutex_lock(&info->device->mutex);
+	if (read_subdevice == NULL ||
+	    (read_subdevice->subdev_flags & SDF_CMD_READ) == 0 ||
+	    read_subdevice->async == NULL) {
+		mutex_unlock(&info->device->mutex);
+		return -EINVAL;
+	}
+	retval = resize_async_buffer(info->device, read_subdevice,
+				     read_subdevice->async, new_size);
+	mutex_unlock(&info->device->mutex);
+
+	if (retval < 0)
+		return retval;
+	return count;
+}
 
-/* declarations for sysfs attribute files */
-static struct device_attribute dev_attr_max_read_buffer_kb;
-static struct device_attribute dev_attr_read_buffer_kb;
-static struct device_attribute dev_attr_max_write_buffer_kb;
-static struct device_attribute dev_attr_write_buffer_kb;
+static DEVICE_ATTR(read_buffer_kb, S_IRUGO | S_IWUSR | S_IWGRP,
+		show_read_buffer_kb, store_read_buffer_kb);
+
+static ssize_t show_max_write_buffer_kb(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	ssize_t retval;
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned max_buffer_size_kb = 0;
+	struct comedi_subdevice *const write_subdevice =
+	    comedi_get_write_subdevice(info);
+
+	mutex_lock(&info->device->mutex);
+	if (write_subdevice &&
+	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) &&
+	    write_subdevice->async) {
+		max_buffer_size_kb = write_subdevice->async->max_bufsize /
+		    bytes_per_kibi;
+	}
+	retval = snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
+	mutex_unlock(&info->device->mutex);
+
+	return retval;
+}
+
+static ssize_t store_max_write_buffer_kb(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned int new_max_size_kb;
+	unsigned int new_max_size;
+	int ret;
+	struct comedi_subdevice *const write_subdevice =
+	    comedi_get_write_subdevice(info);
+
+	ret = kstrtouint(buf, 10, &new_max_size_kb);
+	if (ret)
+		return ret;
+	if (new_max_size_kb > (UINT_MAX / bytes_per_kibi))
+		return -EINVAL;
+	new_max_size = new_max_size_kb * bytes_per_kibi;
+
+	mutex_lock(&info->device->mutex);
+	if (write_subdevice == NULL ||
+	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) == 0 ||
+	    write_subdevice->async == NULL) {
+		mutex_unlock(&info->device->mutex);
+		return -EINVAL;
+	}
+	write_subdevice->async->max_bufsize = new_max_size;
+	mutex_unlock(&info->device->mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(max_write_buffer_kb, S_IRUGO | S_IWUSR,
+		show_max_write_buffer_kb, store_max_write_buffer_kb);
+
+static ssize_t show_write_buffer_kb(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	ssize_t retval;
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned buffer_size_kb = 0;
+	struct comedi_subdevice *const write_subdevice =
+	    comedi_get_write_subdevice(info);
+
+	mutex_lock(&info->device->mutex);
+	if (write_subdevice &&
+	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) &&
+	    write_subdevice->async) {
+		buffer_size_kb = write_subdevice->async->prealloc_bufsz /
+		    bytes_per_kibi;
+	}
+	retval = snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
+	mutex_unlock(&info->device->mutex);
+
+	return retval;
+}
+
+static ssize_t store_write_buffer_kb(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned int new_size_kb;
+	unsigned int new_size;
+	int retval;
+	int ret;
+	struct comedi_subdevice *const write_subdevice =
+	    comedi_get_write_subdevice(info);
+
+	ret = kstrtouint(buf, 10, &new_size_kb);
+	if (ret)
+		return ret;
+	if (new_size_kb > (UINT_MAX / bytes_per_kibi))
+		return -EINVAL;
+	new_size = ((uint64_t) new_size_kb) * bytes_per_kibi;
+
+	mutex_lock(&info->device->mutex);
+	if (write_subdevice == NULL ||
+	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) == 0 ||
+	    write_subdevice->async == NULL) {
+		mutex_unlock(&info->device->mutex);
+		return -EINVAL;
+	}
+	retval = resize_async_buffer(info->device, write_subdevice,
+				     write_subdevice->async, new_size);
+	mutex_unlock(&info->device->mutex);
+
+	if (retval < 0)
+		return retval;
+	return count;
+}
+
+static DEVICE_ATTR(write_buffer_kb, S_IRUGO | S_IWUSR | S_IWGRP,
+		show_write_buffer_kb, store_write_buffer_kb);
+
+static struct attribute *comedi_attrs[] = {
+	&dev_attr_max_read_buffer_kb.attr,
+	&dev_attr_read_buffer_kb.attr,
+	&dev_attr_max_write_buffer_kb.attr,
+	&dev_attr_write_buffer_kb.attr,
+	NULL
+};
+
+static const struct attribute_group comedi_sysfs_files = {
+	.attrs	= comedi_attrs,
+};
 
 static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 				  unsigned long arg)
@@ -1937,804 +2217,453 @@ static int comedi_open(struct inode *inode, struct file *file)
 
 	dev->use_count++;
 
-	mutex_unlock(&dev->mutex);
-
-	return 0;
-}
-
-static int comedi_close(struct inode *inode, struct file *file)
-{
-	const unsigned minor = iminor(inode);
-	struct comedi_subdevice *s = NULL;
-	int i;
-	struct comedi_device_file_info *dev_file_info;
-	struct comedi_device *dev;
-	dev_file_info = comedi_get_device_file_info(minor);
-
-	if (dev_file_info == NULL)
-		return -ENODEV;
-	dev = dev_file_info->device;
-	if (dev == NULL)
-		return -ENODEV;
-
-	mutex_lock(&dev->mutex);
-
-	if (dev->subdevices) {
-		for (i = 0; i < dev->n_subdevices; i++) {
-			s = dev->subdevices + i;
-
-			if (s->busy == file)
-				do_cancel(dev, s);
-			if (s->lock == file)
-				s->lock = NULL;
-		}
-	}
-	if (dev->attached && dev->use_count == 1 && dev->close)
-		dev->close(dev);
-
-	module_put(THIS_MODULE);
-	if (dev->attached)
-		module_put(dev->driver->module);
-
-	dev->use_count--;
-
-	mutex_unlock(&dev->mutex);
-
-	if (file->f_flags & FASYNC)
-		comedi_fasync(-1, file, 0);
-
-	return 0;
-}
-
-static int comedi_fasync(int fd, struct file *file, int on)
-{
-	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info;
-	struct comedi_device *dev;
-	dev_file_info = comedi_get_device_file_info(minor);
-
-	if (dev_file_info == NULL)
-		return -ENODEV;
-	dev = dev_file_info->device;
-	if (dev == NULL)
-		return -ENODEV;
-
-	return fasync_helper(fd, file, on, &dev->async_queue);
-}
-
-const struct file_operations comedi_fops = {
-	.owner = THIS_MODULE,
-	.unlocked_ioctl = comedi_unlocked_ioctl,
-	.compat_ioctl = comedi_compat_ioctl,
-	.open = comedi_open,
-	.release = comedi_close,
-	.read = comedi_read,
-	.write = comedi_write,
-	.mmap = comedi_mmap,
-	.poll = comedi_poll,
-	.fasync = comedi_fasync,
-	.llseek = noop_llseek,
-};
-
-struct class *comedi_class;
-static struct cdev comedi_cdev;
-
-static void comedi_cleanup_legacy_minors(void)
-{
-	unsigned i;
-
-	for (i = 0; i < comedi_num_legacy_minors; i++)
-		comedi_free_board_minor(i);
-}
-
-static int __init comedi_init(void)
-{
-	int i;
-	int retval;
-
-	printk(KERN_INFO "comedi: version " COMEDI_RELEASE
-	       " - http://www.comedi.org\n");
-
-	if (comedi_num_legacy_minors < 0 ||
-	    comedi_num_legacy_minors > COMEDI_NUM_BOARD_MINORS) {
-		printk(KERN_ERR "comedi: error: invalid value for module "
-		       "parameter \"comedi_num_legacy_minors\".  Valid values "
-		       "are 0 through %i.\n", COMEDI_NUM_BOARD_MINORS);
-		return -EINVAL;
-	}
-
-	/*
-	 * comedi is unusable if both comedi_autoconfig and
-	 * comedi_num_legacy_minors are zero, so we might as well adjust the
-	 * defaults in that case
-	 */
-	if (comedi_autoconfig == 0 && comedi_num_legacy_minors == 0)
-		comedi_num_legacy_minors = 16;
-
-	memset(comedi_file_info_table, 0,
-	       sizeof(struct comedi_device_file_info *) * COMEDI_NUM_MINORS);
-
-	retval = register_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-					COMEDI_NUM_MINORS, "comedi");
-	if (retval)
-		return -EIO;
-	cdev_init(&comedi_cdev, &comedi_fops);
-	comedi_cdev.owner = THIS_MODULE;
-	kobject_set_name(&comedi_cdev.kobj, "comedi");
-	if (cdev_add(&comedi_cdev, MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS)) {
-		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-					 COMEDI_NUM_MINORS);
-		return -EIO;
-	}
-	comedi_class = class_create(THIS_MODULE, "comedi");
-	if (IS_ERR(comedi_class)) {
-		printk(KERN_ERR "comedi: failed to create class");
-		cdev_del(&comedi_cdev);
-		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-					 COMEDI_NUM_MINORS);
-		return PTR_ERR(comedi_class);
-	}
-
-	/* XXX requires /proc interface */
-	comedi_proc_init();
-
-	/* create devices files for legacy/manual use */
-	for (i = 0; i < comedi_num_legacy_minors; i++) {
-		int minor;
-		minor = comedi_alloc_board_minor(NULL);
-		if (minor < 0) {
-			comedi_cleanup_legacy_minors();
-			cdev_del(&comedi_cdev);
-			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-						 COMEDI_NUM_MINORS);
-			return minor;
-		}
-	}
-
-	return 0;
-}
-
-static void __exit comedi_cleanup(void)
-{
-	int i;
-
-	comedi_cleanup_legacy_minors();
-	for (i = 0; i < COMEDI_NUM_MINORS; ++i)
-		BUG_ON(comedi_file_info_table[i]);
-
-	class_destroy(comedi_class);
-	cdev_del(&comedi_cdev);
-	unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);
-
-	comedi_proc_cleanup();
-}
-
-module_init(comedi_init);
-module_exit(comedi_cleanup);
-
-void comedi_error(const struct comedi_device *dev, const char *s)
-{
-	printk(KERN_ERR "comedi%d: %s: %s\n", dev->minor,
-	       dev->driver->driver_name, s);
-}
-EXPORT_SYMBOL(comedi_error);
-
-void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	struct comedi_async *async = s->async;
-	unsigned runflags = 0;
-	unsigned runflags_mask = 0;
-
-	/* DPRINTK("comedi_event 0x%x\n",mask); */
-
-	if ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) == 0)
-		return;
-
-	if (s->
-	    async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
-			     COMEDI_CB_OVERFLOW)) {
-		runflags_mask |= SRF_RUNNING;
-	}
-	/* remember if an error event has occurred, so an error
-	 * can be returned the next time the user does a read() */
-	if (s->async->events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {
-		runflags_mask |= SRF_ERROR;
-		runflags |= SRF_ERROR;
-	}
-	if (runflags_mask) {
-		/*sets SRF_ERROR and SRF_RUNNING together atomically */
-		comedi_set_subdevice_runflags(s, runflags_mask, runflags);
-	}
-
-	if (async->cb_mask & s->async->events) {
-		if (comedi_get_subdevice_runflags(s) & SRF_USER) {
-			wake_up_interruptible(&async->wait_head);
-			if (s->subdev_flags & SDF_CMD_READ)
-				kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
-			if (s->subdev_flags & SDF_CMD_WRITE)
-				kill_fasync(&dev->async_queue, SIGIO, POLL_OUT);
-		} else {
-			if (async->cb_func)
-				async->cb_func(s->async->events, async->cb_arg);
-		}
-	}
-	s->async->events = 0;
-}
-EXPORT_SYMBOL(comedi_event);
-
-unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
-{
-	unsigned long flags;
-	unsigned runflags;
+	mutex_unlock(&dev->mutex);
 
-	spin_lock_irqsave(&s->spin_lock, flags);
-	runflags = s->runflags;
-	spin_unlock_irqrestore(&s->spin_lock, flags);
-	return runflags;
+	return 0;
 }
-EXPORT_SYMBOL(comedi_get_subdevice_runflags);
 
-static int is_device_busy(struct comedi_device *dev)
+static int comedi_close(struct inode *inode, struct file *file)
 {
-	struct comedi_subdevice *s;
+	const unsigned minor = iminor(inode);
+	struct comedi_subdevice *s = NULL;
 	int i;
+	struct comedi_device_file_info *dev_file_info;
+	struct comedi_device *dev;
+	dev_file_info = comedi_get_device_file_info(minor);
 
-	if (!dev->attached)
-		return 0;
+	if (dev_file_info == NULL)
+		return -ENODEV;
+	dev = dev_file_info->device;
+	if (dev == NULL)
+		return -ENODEV;
 
-	for (i = 0; i < dev->n_subdevices; i++) {
-		s = dev->subdevices + i;
-		if (s->busy)
-			return 1;
-		if (s->async && s->async->mmap_count)
-			return 1;
+	mutex_lock(&dev->mutex);
+
+	if (dev->subdevices) {
+		for (i = 0; i < dev->n_subdevices; i++) {
+			s = dev->subdevices + i;
+
+			if (s->busy == file)
+				do_cancel(dev, s);
+			if (s->lock == file)
+				s->lock = NULL;
+		}
 	}
+	if (dev->attached && dev->use_count == 1 && dev->close)
+		dev->close(dev);
+
+	module_put(THIS_MODULE);
+	if (dev->attached)
+		module_put(dev->driver->module);
+
+	dev->use_count--;
+
+	mutex_unlock(&dev->mutex);
+
+	if (file->f_flags & FASYNC)
+		comedi_fasync(-1, file, 0);
 
 	return 0;
 }
 
-static void comedi_device_init(struct comedi_device *dev)
+static int comedi_fasync(int fd, struct file *file, int on)
 {
-	memset(dev, 0, sizeof(struct comedi_device));
-	spin_lock_init(&dev->spinlock);
-	mutex_init(&dev->mutex);
-	dev->minor = -1;
-}
+	const unsigned minor = iminor(file->f_dentry->d_inode);
+	struct comedi_device_file_info *dev_file_info;
+	struct comedi_device *dev;
+	dev_file_info = comedi_get_device_file_info(minor);
 
-static void comedi_device_cleanup(struct comedi_device *dev)
-{
+	if (dev_file_info == NULL)
+		return -ENODEV;
+	dev = dev_file_info->device;
 	if (dev == NULL)
-		return;
-	mutex_lock(&dev->mutex);
-	comedi_device_detach(dev);
-	mutex_unlock(&dev->mutex);
-	mutex_destroy(&dev->mutex);
+		return -ENODEV;
+
+	return fasync_helper(fd, file, on, &dev->async_queue);
 }
 
-int comedi_alloc_board_minor(struct device *hardware_device)
+const struct file_operations comedi_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = comedi_unlocked_ioctl,
+	.compat_ioctl = comedi_compat_ioctl,
+	.open = comedi_open,
+	.release = comedi_close,
+	.read = comedi_read,
+	.write = comedi_write,
+	.mmap = comedi_mmap,
+	.poll = comedi_poll,
+	.fasync = comedi_fasync,
+	.llseek = noop_llseek,
+};
+
+struct class *comedi_class;
+static struct cdev comedi_cdev;
+
+static void comedi_cleanup_legacy_minors(void)
 {
-	struct comedi_device_file_info *info;
-	struct device *csdev;
 	unsigned i;
-	int retval;
 
-	info = kzalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
-	if (info == NULL)
-		return -ENOMEM;
-	info->device = kzalloc(sizeof(struct comedi_device), GFP_KERNEL);
-	if (info->device == NULL) {
-		kfree(info);
-		return -ENOMEM;
-	}
-	info->hardware_device = hardware_device;
-	comedi_device_init(info->device);
-	spin_lock(&comedi_file_info_table_lock);
-	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i) {
-		if (comedi_file_info_table[i] == NULL) {
-			comedi_file_info_table[i] = info;
-			break;
-		}
-	}
-	spin_unlock(&comedi_file_info_table_lock);
-	if (i == COMEDI_NUM_BOARD_MINORS) {
-		comedi_device_cleanup(info->device);
-		kfree(info->device);
-		kfree(info);
-		printk(KERN_ERR
-		       "comedi: error: "
-		       "ran out of minor numbers for board device files.\n");
-		return -EBUSY;
-	}
-	info->device->minor = i;
-	csdev = device_create(comedi_class, hardware_device,
-			      MKDEV(COMEDI_MAJOR, i), NULL, "comedi%i", i);
-	if (!IS_ERR(csdev))
-		info->device->class_dev = csdev;
-	dev_set_drvdata(csdev, info);
-	retval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);
-	if (retval) {
-		printk(KERN_ERR
-		       "comedi: "
-		       "failed to create sysfs attribute file \"%s\".\n",
-		       dev_attr_max_read_buffer_kb.attr.name);
-		comedi_free_board_minor(i);
-		return retval;
-	}
-	retval = device_create_file(csdev, &dev_attr_read_buffer_kb);
-	if (retval) {
-		printk(KERN_ERR
-		       "comedi: "
-		       "failed to create sysfs attribute file \"%s\".\n",
-		       dev_attr_read_buffer_kb.attr.name);
-		comedi_free_board_minor(i);
-		return retval;
-	}
-	retval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);
-	if (retval) {
-		printk(KERN_ERR
-		       "comedi: "
-		       "failed to create sysfs attribute file \"%s\".\n",
-		       dev_attr_max_write_buffer_kb.attr.name);
-		comedi_free_board_minor(i);
-		return retval;
-	}
-	retval = device_create_file(csdev, &dev_attr_write_buffer_kb);
-	if (retval) {
-		printk(KERN_ERR
-		       "comedi: "
-		       "failed to create sysfs attribute file \"%s\".\n",
-		       dev_attr_write_buffer_kb.attr.name);
+	for (i = 0; i < comedi_num_legacy_minors; i++)
 		comedi_free_board_minor(i);
-		return retval;
-	}
-	return i;
 }
 
-void comedi_free_board_minor(unsigned minor)
+static int __init comedi_init(void)
 {
-	struct comedi_device_file_info *info;
+	int i;
+	int retval;
 
-	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
-	spin_lock(&comedi_file_info_table_lock);
-	info = comedi_file_info_table[minor];
-	comedi_file_info_table[minor] = NULL;
-	spin_unlock(&comedi_file_info_table_lock);
+	printk(KERN_INFO "comedi: version " COMEDI_RELEASE
+	       " - http://www.comedi.org\n");
 
-	if (info) {
-		struct comedi_device *dev = info->device;
-		if (dev) {
-			if (dev->class_dev) {
-				device_destroy(comedi_class,
-					       MKDEV(COMEDI_MAJOR, dev->minor));
-			}
-			comedi_device_cleanup(dev);
-			kfree(dev);
-		}
-		kfree(info);
+	if (comedi_num_legacy_minors < 0 ||
+	    comedi_num_legacy_minors > COMEDI_NUM_BOARD_MINORS) {
+		printk(KERN_ERR "comedi: error: invalid value for module "
+		       "parameter \"comedi_num_legacy_minors\".  Valid values "
+		       "are 0 through %i.\n", COMEDI_NUM_BOARD_MINORS);
+		return -EINVAL;
 	}
-}
-
-int comedi_find_board_minor(struct device *hardware_device)
-{
-	int minor;
-	struct comedi_device_file_info *info;
 
-	for (minor = 0; minor < COMEDI_NUM_BOARD_MINORS; minor++) {
-		spin_lock(&comedi_file_info_table_lock);
-		info = comedi_file_info_table[minor];
-		if (info && info->hardware_device == hardware_device) {
-			spin_unlock(&comedi_file_info_table_lock);
-			return minor;
-		}
-		spin_unlock(&comedi_file_info_table_lock);
-	}
-	return -ENODEV;
-}
+	/*
+	 * comedi is unusable if both comedi_autoconfig and
+	 * comedi_num_legacy_minors are zero, so we might as well adjust the
+	 * defaults in that case
+	 */
+	if (comedi_autoconfig == 0 && comedi_num_legacy_minors == 0)
+		comedi_num_legacy_minors = 16;
 
-int comedi_alloc_subdevice_minor(struct comedi_device *dev,
-				 struct comedi_subdevice *s)
-{
-	struct comedi_device_file_info *info;
-	struct device *csdev;
-	unsigned i;
-	int retval;
+	memset(comedi_file_info_table, 0,
+	       sizeof(struct comedi_device_file_info *) * COMEDI_NUM_MINORS);
 
-	info = kmalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
-	if (info == NULL)
-		return -ENOMEM;
-	info->device = dev;
-	info->read_subdevice = s;
-	info->write_subdevice = s;
-	spin_lock(&comedi_file_info_table_lock);
-	for (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_MINORS; ++i) {
-		if (comedi_file_info_table[i] == NULL) {
-			comedi_file_info_table[i] = info;
-			break;
-		}
-	}
-	spin_unlock(&comedi_file_info_table_lock);
-	if (i == COMEDI_NUM_MINORS) {
-		kfree(info);
-		printk(KERN_ERR
-		       "comedi: error: "
-		       "ran out of minor numbers for board device files.\n");
-		return -EBUSY;
-	}
-	s->minor = i;
-	csdev = device_create(comedi_class, dev->class_dev,
-			      MKDEV(COMEDI_MAJOR, i), NULL, "comedi%i_subd%i",
-			      dev->minor, (int)(s - dev->subdevices));
-	if (!IS_ERR(csdev))
-		s->class_dev = csdev;
-	dev_set_drvdata(csdev, info);
-	retval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);
-	if (retval) {
-		printk(KERN_ERR
-		       "comedi: "
-		       "failed to create sysfs attribute file \"%s\".\n",
-		       dev_attr_max_read_buffer_kb.attr.name);
-		comedi_free_subdevice_minor(s);
-		return retval;
-	}
-	retval = device_create_file(csdev, &dev_attr_read_buffer_kb);
-	if (retval) {
-		printk(KERN_ERR
-		       "comedi: "
-		       "failed to create sysfs attribute file \"%s\".\n",
-		       dev_attr_read_buffer_kb.attr.name);
-		comedi_free_subdevice_minor(s);
-		return retval;
+	retval = register_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+					COMEDI_NUM_MINORS, "comedi");
+	if (retval)
+		return -EIO;
+	cdev_init(&comedi_cdev, &comedi_fops);
+	comedi_cdev.owner = THIS_MODULE;
+	kobject_set_name(&comedi_cdev.kobj, "comedi");
+	if (cdev_add(&comedi_cdev, MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS)) {
+		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+					 COMEDI_NUM_MINORS);
+		return -EIO;
 	}
-	retval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);
-	if (retval) {
-		printk(KERN_ERR
-		       "comedi: "
-		       "failed to create sysfs attribute file \"%s\".\n",
-		       dev_attr_max_write_buffer_kb.attr.name);
-		comedi_free_subdevice_minor(s);
-		return retval;
+	comedi_class = class_create(THIS_MODULE, "comedi");
+	if (IS_ERR(comedi_class)) {
+		printk(KERN_ERR "comedi: failed to create class");
+		cdev_del(&comedi_cdev);
+		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+					 COMEDI_NUM_MINORS);
+		return PTR_ERR(comedi_class);
 	}
-	retval = device_create_file(csdev, &dev_attr_write_buffer_kb);
-	if (retval) {
-		printk(KERN_ERR
-		       "comedi: "
-		       "failed to create sysfs attribute file \"%s\".\n",
-		       dev_attr_write_buffer_kb.attr.name);
-		comedi_free_subdevice_minor(s);
-		return retval;
+
+	/* XXX requires /proc interface */
+	comedi_proc_init();
+
+	/* create devices files for legacy/manual use */
+	for (i = 0; i < comedi_num_legacy_minors; i++) {
+		int minor;
+		minor = comedi_alloc_board_minor(NULL);
+		if (minor < 0) {
+			comedi_cleanup_legacy_minors();
+			cdev_del(&comedi_cdev);
+			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+						 COMEDI_NUM_MINORS);
+			return minor;
+		}
 	}
-	return i;
+
+	return 0;
 }
 
-void comedi_free_subdevice_minor(struct comedi_subdevice *s)
+static void __exit comedi_cleanup(void)
 {
-	struct comedi_device_file_info *info;
-
-	if (s == NULL)
-		return;
-	if (s->minor < 0)
-		return;
+	int i;
 
-	BUG_ON(s->minor >= COMEDI_NUM_MINORS);
-	BUG_ON(s->minor < COMEDI_FIRST_SUBDEVICE_MINOR);
+	comedi_cleanup_legacy_minors();
+	for (i = 0; i < COMEDI_NUM_MINORS; ++i)
+		BUG_ON(comedi_file_info_table[i]);
 
-	spin_lock(&comedi_file_info_table_lock);
-	info = comedi_file_info_table[s->minor];
-	comedi_file_info_table[s->minor] = NULL;
-	spin_unlock(&comedi_file_info_table_lock);
+	class_destroy(comedi_class);
+	cdev_del(&comedi_cdev);
+	unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);
 
-	if (s->class_dev) {
-		device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, s->minor));
-		s->class_dev = NULL;
-	}
-	kfree(info);
+	comedi_proc_cleanup();
 }
 
-struct comedi_device_file_info *comedi_get_device_file_info(unsigned minor)
-{
-	struct comedi_device_file_info *info;
+module_init(comedi_init);
+module_exit(comedi_cleanup);
 
-	BUG_ON(minor >= COMEDI_NUM_MINORS);
-	spin_lock(&comedi_file_info_table_lock);
-	info = comedi_file_info_table[minor];
-	spin_unlock(&comedi_file_info_table_lock);
-	return info;
+void comedi_error(const struct comedi_device *dev, const char *s)
+{
+	printk(KERN_ERR "comedi%d: %s: %s\n", dev->minor,
+	       dev->driver->driver_name, s);
 }
-EXPORT_SYMBOL_GPL(comedi_get_device_file_info);
+EXPORT_SYMBOL(comedi_error);
 
-static int resize_async_buffer(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_async *async, unsigned new_size)
+void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	int retval;
+	struct comedi_async *async = s->async;
+	unsigned runflags = 0;
+	unsigned runflags_mask = 0;
 
-	if (new_size > async->max_bufsize)
-		return -EPERM;
+	/* DPRINTK("comedi_event 0x%x\n",mask); */
 
-	if (s->busy) {
-		DPRINTK("subdevice is busy, cannot resize buffer\n");
-		return -EBUSY;
+	if ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) == 0)
+		return;
+
+	if (s->
+	    async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
+			     COMEDI_CB_OVERFLOW)) {
+		runflags_mask |= SRF_RUNNING;
 	}
-	if (async->mmap_count) {
-		DPRINTK("subdevice is mmapped, cannot resize buffer\n");
-		return -EBUSY;
+	/* remember if an error event has occurred, so an error
+	 * can be returned the next time the user does a read() */
+	if (s->async->events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {
+		runflags_mask |= SRF_ERROR;
+		runflags |= SRF_ERROR;
 	}
-
-	if (!async->prealloc_buf)
-		return -EINVAL;
-
-	/* make sure buffer is an integral number of pages
-	 * (we round up) */
-	new_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;
-
-	retval = comedi_buf_alloc(dev, s, new_size);
-	if (retval < 0)
-		return retval;
-
-	if (s->buf_change) {
-		retval = s->buf_change(dev, s, new_size);
-		if (retval < 0)
-			return retval;
+	if (runflags_mask) {
+		/*sets SRF_ERROR and SRF_RUNNING together atomically */
+		comedi_set_subdevice_runflags(s, runflags_mask, runflags);
 	}
 
-	DPRINTK("comedi%i subd %d buffer resized to %i bytes\n",
-		dev->minor, (int)(s - dev->subdevices), async->prealloc_bufsz);
-	return 0;
+	if (async->cb_mask & s->async->events) {
+		if (comedi_get_subdevice_runflags(s) & SRF_USER) {
+			wake_up_interruptible(&async->wait_head);
+			if (s->subdev_flags & SDF_CMD_READ)
+				kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
+			if (s->subdev_flags & SDF_CMD_WRITE)
+				kill_fasync(&dev->async_queue, SIGIO, POLL_OUT);
+		} else {
+			if (async->cb_func)
+				async->cb_func(s->async->events, async->cb_arg);
+		}
+	}
+	s->async->events = 0;
 }
+EXPORT_SYMBOL(comedi_event);
 
-/* sysfs attribute files */
-
-static const unsigned bytes_per_kibi = 1024;
-
-static ssize_t show_max_read_buffer_kb(struct device *dev,
-				       struct device_attribute *attr, char *buf)
+unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 {
-	ssize_t retval;
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned max_buffer_size_kb = 0;
-	struct comedi_subdevice *const read_subdevice =
-	    comedi_get_read_subdevice(info);
-
-	mutex_lock(&info->device->mutex);
-	if (read_subdevice &&
-	    (read_subdevice->subdev_flags & SDF_CMD_READ) &&
-	    read_subdevice->async) {
-		max_buffer_size_kb = read_subdevice->async->max_bufsize /
-		    bytes_per_kibi;
-	}
-	retval = snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
-	mutex_unlock(&info->device->mutex);
+	unsigned long flags;
+	unsigned runflags;
 
-	return retval;
+	spin_lock_irqsave(&s->spin_lock, flags);
+	runflags = s->runflags;
+	spin_unlock_irqrestore(&s->spin_lock, flags);
+	return runflags;
 }
+EXPORT_SYMBOL(comedi_get_subdevice_runflags);
 
-static ssize_t store_max_read_buffer_kb(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
+static int is_device_busy(struct comedi_device *dev)
 {
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned int new_max_size_kb;
-	unsigned int new_max_size;
-	int ret;
-	struct comedi_subdevice *const read_subdevice =
-	    comedi_get_read_subdevice(info);
+	struct comedi_subdevice *s;
+	int i;
 
-	ret = kstrtouint(buf, 10, &new_max_size_kb);
-	if (ret)
-		return ret;
-	if (new_max_size_kb > (UINT_MAX / bytes_per_kibi))
-		return -EINVAL;
-	new_max_size = new_max_size_kb * bytes_per_kibi;
+	if (!dev->attached)
+		return 0;
 
-	mutex_lock(&info->device->mutex);
-	if (read_subdevice == NULL ||
-	    (read_subdevice->subdev_flags & SDF_CMD_READ) == 0 ||
-	    read_subdevice->async == NULL) {
-		mutex_unlock(&info->device->mutex);
-		return -EINVAL;
+	for (i = 0; i < dev->n_subdevices; i++) {
+		s = dev->subdevices + i;
+		if (s->busy)
+			return 1;
+		if (s->async && s->async->mmap_count)
+			return 1;
 	}
-	read_subdevice->async->max_bufsize = new_max_size;
-	mutex_unlock(&info->device->mutex);
 
-	return count;
+	return 0;
 }
 
-static struct device_attribute dev_attr_max_read_buffer_kb = {
-	.attr = {
-		 .name = "max_read_buffer_kb",
-		 .mode = S_IRUGO | S_IWUSR},
-	.show = &show_max_read_buffer_kb,
-	.store = &store_max_read_buffer_kb
-};
+static void comedi_device_init(struct comedi_device *dev)
+{
+	memset(dev, 0, sizeof(struct comedi_device));
+	spin_lock_init(&dev->spinlock);
+	mutex_init(&dev->mutex);
+	dev->minor = -1;
+}
 
-static ssize_t show_read_buffer_kb(struct device *dev,
-				   struct device_attribute *attr, char *buf)
+static void comedi_device_cleanup(struct comedi_device *dev)
 {
-	ssize_t retval;
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned buffer_size_kb = 0;
-	struct comedi_subdevice *const read_subdevice =
-	    comedi_get_read_subdevice(info);
+	if (dev == NULL)
+		return;
+	mutex_lock(&dev->mutex);
+	comedi_device_detach(dev);
+	mutex_unlock(&dev->mutex);
+	mutex_destroy(&dev->mutex);
+}
+
+int comedi_alloc_board_minor(struct device *hardware_device)
+{
+	struct comedi_device_file_info *info;
+	struct device *csdev;
+	unsigned i;
+	int retval;
+
+	info = kzalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	info->device = kzalloc(sizeof(struct comedi_device), GFP_KERNEL);
+	if (info->device == NULL) {
+		kfree(info);
+		return -ENOMEM;
+	}
+	info->hardware_device = hardware_device;
+	comedi_device_init(info->device);
+	spin_lock(&comedi_file_info_table_lock);
+	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i) {
+		if (comedi_file_info_table[i] == NULL) {
+			comedi_file_info_table[i] = info;
+			break;
+		}
+	}
+	spin_unlock(&comedi_file_info_table_lock);
+	if (i == COMEDI_NUM_BOARD_MINORS) {
+		comedi_device_cleanup(info->device);
+		kfree(info->device);
+		kfree(info);
+		printk(KERN_ERR
+		       "comedi: error: "
+		       "ran out of minor numbers for board device files.\n");
+		return -EBUSY;
+	}
+	info->device->minor = i;
+	csdev = device_create(comedi_class, hardware_device,
+			      MKDEV(COMEDI_MAJOR, i), NULL, "comedi%i", i);
+	if (!IS_ERR(csdev))
+		info->device->class_dev = csdev;
+	dev_set_drvdata(csdev, info);
 
-	mutex_lock(&info->device->mutex);
-	if (read_subdevice &&
-	    (read_subdevice->subdev_flags & SDF_CMD_READ) &&
-	    read_subdevice->async) {
-		buffer_size_kb = read_subdevice->async->prealloc_bufsz /
-		    bytes_per_kibi;
+	retval = sysfs_create_group(&csdev->kobj, &comedi_sysfs_files);
+	if (retval) {
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute files\n");
+		comedi_free_board_minor(i);
+		return retval;
 	}
-	retval = snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
-	mutex_unlock(&info->device->mutex);
 
-	return retval;
+	return i;
 }
 
-static ssize_t store_read_buffer_kb(struct device *dev,
-				    struct device_attribute *attr,
-				    const char *buf, size_t count)
+void comedi_free_board_minor(unsigned minor)
 {
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned int new_size_kb;
-	unsigned int new_size;
-	int retval;
-	int ret;
-	struct comedi_subdevice *const read_subdevice =
-	    comedi_get_read_subdevice(info);
+	struct comedi_device_file_info *info;
 
-	ret = kstrtouint(buf, 10, &new_size_kb);
-	if (ret)
-		return ret;
-	if (new_size_kb > (UINT_MAX / bytes_per_kibi))
-		return -EINVAL;
-	new_size = new_size_kb * bytes_per_kibi;
+	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
+	spin_lock(&comedi_file_info_table_lock);
+	info = comedi_file_info_table[minor];
+	comedi_file_info_table[minor] = NULL;
+	spin_unlock(&comedi_file_info_table_lock);
 
-	mutex_lock(&info->device->mutex);
-	if (read_subdevice == NULL ||
-	    (read_subdevice->subdev_flags & SDF_CMD_READ) == 0 ||
-	    read_subdevice->async == NULL) {
-		mutex_unlock(&info->device->mutex);
-		return -EINVAL;
+	if (info) {
+		struct comedi_device *dev = info->device;
+		if (dev) {
+			if (dev->class_dev) {
+				device_destroy(comedi_class,
+					       MKDEV(COMEDI_MAJOR, dev->minor));
+			}
+			comedi_device_cleanup(dev);
+			kfree(dev);
+		}
+		kfree(info);
 	}
-	retval = resize_async_buffer(info->device, read_subdevice,
-				     read_subdevice->async, new_size);
-	mutex_unlock(&info->device->mutex);
-
-	if (retval < 0)
-		return retval;
-	return count;
 }
 
-static struct device_attribute dev_attr_read_buffer_kb = {
-	.attr = {
-		 .name = "read_buffer_kb",
-		 .mode = S_IRUGO | S_IWUSR | S_IWGRP},
-	.show = &show_read_buffer_kb,
-	.store = &store_read_buffer_kb
-};
-
-static ssize_t show_max_write_buffer_kb(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
+int comedi_find_board_minor(struct device *hardware_device)
 {
-	ssize_t retval;
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned max_buffer_size_kb = 0;
-	struct comedi_subdevice *const write_subdevice =
-	    comedi_get_write_subdevice(info);
+	int minor;
+	struct comedi_device_file_info *info;
 
-	mutex_lock(&info->device->mutex);
-	if (write_subdevice &&
-	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) &&
-	    write_subdevice->async) {
-		max_buffer_size_kb = write_subdevice->async->max_bufsize /
-		    bytes_per_kibi;
+	for (minor = 0; minor < COMEDI_NUM_BOARD_MINORS; minor++) {
+		spin_lock(&comedi_file_info_table_lock);
+		info = comedi_file_info_table[minor];
+		if (info && info->hardware_device == hardware_device) {
+			spin_unlock(&comedi_file_info_table_lock);
+			return minor;
+		}
+		spin_unlock(&comedi_file_info_table_lock);
 	}
-	retval = snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
-	mutex_unlock(&info->device->mutex);
-
-	return retval;
+	return -ENODEV;
 }
 
-static ssize_t store_max_write_buffer_kb(struct device *dev,
-					 struct device_attribute *attr,
-					 const char *buf, size_t count)
+int comedi_alloc_subdevice_minor(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
 {
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned int new_max_size_kb;
-	unsigned int new_max_size;
-	int ret;
-	struct comedi_subdevice *const write_subdevice =
-	    comedi_get_write_subdevice(info);
+	struct comedi_device_file_info *info;
+	struct device *csdev;
+	unsigned i;
+	int retval;
 
-	ret = kstrtouint(buf, 10, &new_max_size_kb);
-	if (ret)
-		return ret;
-	if (new_max_size_kb > (UINT_MAX / bytes_per_kibi))
-		return -EINVAL;
-	new_max_size = new_max_size_kb * bytes_per_kibi;
+	info = kmalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	info->device = dev;
+	info->read_subdevice = s;
+	info->write_subdevice = s;
+	spin_lock(&comedi_file_info_table_lock);
+	for (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_MINORS; ++i) {
+		if (comedi_file_info_table[i] == NULL) {
+			comedi_file_info_table[i] = info;
+			break;
+		}
+	}
+	spin_unlock(&comedi_file_info_table_lock);
+	if (i == COMEDI_NUM_MINORS) {
+		kfree(info);
+		printk(KERN_ERR
+		       "comedi: error: "
+		       "ran out of minor numbers for board device files.\n");
+		return -EBUSY;
+	}
+	s->minor = i;
+	csdev = device_create(comedi_class, dev->class_dev,
+			      MKDEV(COMEDI_MAJOR, i), NULL, "comedi%i_subd%i",
+			      dev->minor, (int)(s - dev->subdevices));
+	if (!IS_ERR(csdev))
+		s->class_dev = csdev;
+	dev_set_drvdata(csdev, info);
 
-	mutex_lock(&info->device->mutex);
-	if (write_subdevice == NULL ||
-	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) == 0 ||
-	    write_subdevice->async == NULL) {
-		mutex_unlock(&info->device->mutex);
-		return -EINVAL;
+	retval = sysfs_create_group(&csdev->kobj, &comedi_sysfs_files);
+	if (retval) {
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute files\n");
+		comedi_free_subdevice_minor(s);
+		return retval;
 	}
-	write_subdevice->async->max_bufsize = new_max_size;
-	mutex_unlock(&info->device->mutex);
 
-	return count;
+	return i;
 }
 
-static struct device_attribute dev_attr_max_write_buffer_kb = {
-	.attr = {
-		 .name = "max_write_buffer_kb",
-		 .mode = S_IRUGO | S_IWUSR},
-	.show = &show_max_write_buffer_kb,
-	.store = &store_max_write_buffer_kb
-};
-
-static ssize_t show_write_buffer_kb(struct device *dev,
-				    struct device_attribute *attr, char *buf)
+void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 {
-	ssize_t retval;
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned buffer_size_kb = 0;
-	struct comedi_subdevice *const write_subdevice =
-	    comedi_get_write_subdevice(info);
-
-	mutex_lock(&info->device->mutex);
-	if (write_subdevice &&
-	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) &&
-	    write_subdevice->async) {
-		buffer_size_kb = write_subdevice->async->prealloc_bufsz /
-		    bytes_per_kibi;
-	}
-	retval = snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
-	mutex_unlock(&info->device->mutex);
+	struct comedi_device_file_info *info;
 
-	return retval;
-}
+	if (s == NULL)
+		return;
+	if (s->minor < 0)
+		return;
 
-static ssize_t store_write_buffer_kb(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t count)
-{
-	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned int new_size_kb;
-	unsigned int new_size;
-	int retval;
-	int ret;
-	struct comedi_subdevice *const write_subdevice =
-	    comedi_get_write_subdevice(info);
+	BUG_ON(s->minor >= COMEDI_NUM_MINORS);
+	BUG_ON(s->minor < COMEDI_FIRST_SUBDEVICE_MINOR);
 
-	ret = kstrtouint(buf, 10, &new_size_kb);
-	if (ret)
-		return ret;
-	if (new_size_kb > (UINT_MAX / bytes_per_kibi))
-		return -EINVAL;
-	new_size = ((uint64_t) new_size_kb) * bytes_per_kibi;
+	spin_lock(&comedi_file_info_table_lock);
+	info = comedi_file_info_table[s->minor];
+	comedi_file_info_table[s->minor] = NULL;
+	spin_unlock(&comedi_file_info_table_lock);
 
-	mutex_lock(&info->device->mutex);
-	if (write_subdevice == NULL ||
-	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) == 0 ||
-	    write_subdevice->async == NULL) {
-		mutex_unlock(&info->device->mutex);
-		return -EINVAL;
+	if (s->class_dev) {
+		device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, s->minor));
+		s->class_dev = NULL;
 	}
-	retval = resize_async_buffer(info->device, write_subdevice,
-				     write_subdevice->async, new_size);
-	mutex_unlock(&info->device->mutex);
-
-	if (retval < 0)
-		return retval;
-	return count;
+	kfree(info);
 }
 
-static struct device_attribute dev_attr_write_buffer_kb = {
-	.attr = {
-		 .name = "write_buffer_kb",
-		 .mode = S_IRUGO | S_IWUSR | S_IWGRP},
-	.show = &show_write_buffer_kb,
-	.store = &store_write_buffer_kb
-};
+struct comedi_device_file_info *comedi_get_device_file_info(unsigned minor)
+{
+	struct comedi_device_file_info *info;
+
+	BUG_ON(minor >= COMEDI_NUM_MINORS);
+	spin_lock(&comedi_file_info_table_lock);
+	info = comedi_file_info_table[minor];
+	spin_unlock(&comedi_file_info_table_lock);
+	return info;
+}
+EXPORT_SYMBOL_GPL(comedi_get_device_file_info);

commit abae41e6438b798e046d721b6ccdd55b4a398170
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Apr 22 13:37:09 2012 +0200

    drivers/staging/comedi/comedi_fops.c: add missing vfree
    
    aux_free is freed on all other exits from the function.  By removing the
    return, we can benefit from the vfree already at the end of the function.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a0861fbc980e..06fc6569c859 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -301,7 +301,7 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 	if (ret == 0) {
 		if (!try_module_get(dev->driver->module)) {
 			comedi_device_detach(dev);
-			return -ENOSYS;
+			ret = -ENOSYS;
 		}
 	}
 

commit 1ae5062a33be13a72d37ec46808490d471b0c1d3
Author: Benedikt Bergenthal <benedikt@kdrennert.de>
Date:   Mon Apr 16 12:40:22 2012 +0200

    Drivers: Staging: Comedi: comedi_fops: Fixed a code style issue
    
    Fixed a code style issue.
    
    Signed-off-by: Benedikt Bergenthal <benedikt@kdrennert.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 3222ac6706b4..a0861fbc980e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1566,7 +1566,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	return retval;
 }
 
-static unsigned int comedi_poll(struct file *file, poll_table * wait)
+static unsigned int comedi_poll(struct file *file, poll_table *wait)
 {
 	unsigned int mask = 0;
 	const unsigned minor = iminor(file->f_dentry->d_inode);

commit 234bb3c60f1f1489630750aba4adf40154e0bd70
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Apr 13 14:12:54 2012 +0100

    staging: comedi: Add kernel config for default buffer sizes
    
    Allow the default values for the module parameters for the default
    initial buffer size and default maximum buffer size to be specified in
    the kernel configuration.
    
    I'm not sure what the defaults for the defaults for the defaults should
    be, but 64 KiB seems to small, so I used values suggested by Bernd Porr,
    which are 2048 KiB for the default initial buffer size and 20480 for the
    default maximum buffer size.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: Bernd Porr <berndporr@f2s.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ef7bbe416614..3222ac6706b4 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -55,9 +55,6 @@ MODULE_AUTHOR("http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi core module");
 MODULE_LICENSE("GPL");
 
-#define DEFAULT_BUF_MAXSIZE_KB 64
-#define DEFAULT_BUF_SIZE_KB 64
-
 #ifdef CONFIG_COMEDI_DEBUG
 int comedi_debug;
 EXPORT_SYMBOL(comedi_debug);
@@ -78,17 +75,18 @@ MODULE_PARM_DESC(comedi_num_legacy_minors,
 		 "number of comedi minor devices to reserve for non-auto-configured devices (default 0)"
 		);
 
-unsigned int comedi_default_buf_size_kb = DEFAULT_BUF_SIZE_KB;
+unsigned int comedi_default_buf_size_kb = CONFIG_COMEDI_DEFAULT_BUF_SIZE_KB;
 module_param(comedi_default_buf_size_kb, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(comedi_default_buf_size_kb,
 		 "default asynchronous buffer size in KiB (default "
-		 __MODULE_STRING(DEFAULT_BUF_SIZE_KB) ")");
+		 __MODULE_STRING(CONFIG_COMEDI_DEFAULT_BUF_SIZE_KB) ")");
 
-unsigned int comedi_default_buf_maxsize_kb = DEFAULT_BUF_MAXSIZE_KB;
+unsigned int comedi_default_buf_maxsize_kb
+	= CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB;
 module_param(comedi_default_buf_maxsize_kb, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(comedi_default_buf_maxsize_kb,
 		 "default maximum size of asynchronous buffer in KiB (default "
-		 __MODULE_STRING(DEFAULT_BUF_MAXSIZE_KB) ")");
+		 __MODULE_STRING(CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB) ")");
 
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info

commit 4d7df821277e82ebe2fc9c9af07c928a83f572b8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Apr 13 14:12:53 2012 +0100

    staging: comedi: Add module parameters for default buffer size
    
    For comedi subdevices that support asynchronous transfer commands, the
    initial buffer size and maximum buffer size for the transfer are both
    set to 64 KiB when the comedi device is "attached" to the hardware
    device.  For many applications with reasonable fast sample rates and
    slow user-space (e.g. Python) these sizes are a bit too small.
    
    A task with CAP_SYS_ADMIN privileges can change the maximum buffer size
    for a comedi subdevice with an ioctl call or by writing to a device
    attribute file in sysfs, but that's not very convenient.  For comedi
    devices attached during system startup, this could be done by a start-up
    script, but for hot-plugged devices it would require scripts run by udev
    rules, etc.
    
    Rather than use hardwired values, this patch introduces a couple of
    module parameters to set the defaults for the initial buffer size
    (comedi_default_buf_size_kb) and maximum buffer size
    (comedi_default_buf_maxsize_kb).  These values are applied in place of
    the previous hard-wired values when the comedi device is "attached".
    The module parameter values are in units of KiB for consistency with the
    existing device attribute files.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index fdf42822b962..ef7bbe416614 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -55,17 +55,40 @@ MODULE_AUTHOR("http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi core module");
 MODULE_LICENSE("GPL");
 
+#define DEFAULT_BUF_MAXSIZE_KB 64
+#define DEFAULT_BUF_SIZE_KB 64
+
 #ifdef CONFIG_COMEDI_DEBUG
 int comedi_debug;
 EXPORT_SYMBOL(comedi_debug);
-module_param(comedi_debug, int, 0644);
+module_param(comedi_debug, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(comedi_debug,
+		 "enable comedi core and driver debugging if non-zero (default 0)"
+		);
 #endif
 
 bool comedi_autoconfig = 1;
-module_param(comedi_autoconfig, bool, 0444);
+module_param(comedi_autoconfig, bool, S_IRUGO);
+MODULE_PARM_DESC(comedi_autoconfig,
+		 "enable drivers to auto-configure comedi devices (default 1)");
 
 static int comedi_num_legacy_minors;
-module_param(comedi_num_legacy_minors, int, 0444);
+module_param(comedi_num_legacy_minors, int, S_IRUGO);
+MODULE_PARM_DESC(comedi_num_legacy_minors,
+		 "number of comedi minor devices to reserve for non-auto-configured devices (default 0)"
+		);
+
+unsigned int comedi_default_buf_size_kb = DEFAULT_BUF_SIZE_KB;
+module_param(comedi_default_buf_size_kb, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(comedi_default_buf_size_kb,
+		 "default asynchronous buffer size in KiB (default "
+		 __MODULE_STRING(DEFAULT_BUF_SIZE_KB) ")");
+
+unsigned int comedi_default_buf_maxsize_kb = DEFAULT_BUF_MAXSIZE_KB;
+module_param(comedi_default_buf_maxsize_kb, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(comedi_default_buf_maxsize_kb,
+		 "default maximum size of asynchronous buffer in KiB (default "
+		 __MODULE_STRING(DEFAULT_BUF_MAXSIZE_KB) ")");
 
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info

commit c43435d7722134ed1fda58ce1025f41029bd58ad
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:58 2012 +0100

    staging: comedi: don't hijack hardware device private data
    
    comedi_auto_config() associates a Comedi minor device number with an
    auto-configured hardware device and comedi_auto_unconfig() disassociates
    it.  Currently, these use the hardware device's private data pointer to
    point to some allocated storage holding the minor device number.  This
    is a bit of a waste of the hardware device's private data pointer,
    preventing it from being used for something more useful by the low-level
    comedi device drivers.  For example, it would make more sense if
    comedi_usb_auto_config() was passed a pointer to the struct
    usb_interface instead of the struct usb_device, but this cannot be done
    currently because the low-level comedi drivers already use the private
    data pointer in the struct usb_interface for something more useful.
    
    This patch stops the comedi core hijacking the hardware device's private
    data pointer.  Instead, comedi_auto_config() stores a pointer to the
    hardware device's struct device in the struct comedi_device_file_info
    associated with the minor device number, and comedi_auto_unconfig()
    calls new function comedi_find_board_minor() to recover the minor device
    number associated with the hardware device.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f5417a3df240..fdf42822b962 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2205,6 +2205,7 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 		kfree(info);
 		return -ENOMEM;
 	}
+	info->hardware_device = hardware_device;
 	comedi_device_init(info->device);
 	spin_lock(&comedi_file_info_table_lock);
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i) {
@@ -2292,6 +2293,23 @@ void comedi_free_board_minor(unsigned minor)
 	}
 }
 
+int comedi_find_board_minor(struct device *hardware_device)
+{
+	int minor;
+	struct comedi_device_file_info *info;
+
+	for (minor = 0; minor < COMEDI_NUM_BOARD_MINORS; minor++) {
+		spin_lock(&comedi_file_info_table_lock);
+		info = comedi_file_info_table[minor];
+		if (info && info->hardware_device == hardware_device) {
+			spin_unlock(&comedi_file_info_table_lock);
+			return minor;
+		}
+		spin_unlock(&comedi_file_info_table_lock);
+	}
+	return -ENODEV;
+}
+
 int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 				 struct comedi_subdevice *s)
 {

commit 7cbd8f3dcaeeb489894fb49e669b007455d9785e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:57 2012 +0100

    staging: comedi: don't disable IRQ for comedi_file_info_table_lock
    
    None of the functions that acquire the comedi_file_info_table_lock
    spin-lock need to disable interrupts.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 9bcf87ae4c00..f5417a3df240 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2192,7 +2192,6 @@ static void comedi_device_cleanup(struct comedi_device *dev)
 
 int comedi_alloc_board_minor(struct device *hardware_device)
 {
-	unsigned long flags;
 	struct comedi_device_file_info *info;
 	struct device *csdev;
 	unsigned i;
@@ -2207,14 +2206,14 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 		return -ENOMEM;
 	}
 	comedi_device_init(info->device);
-	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock(&comedi_file_info_table_lock);
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
 			comedi_file_info_table[i] = info;
 			break;
 		}
 	}
-	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock(&comedi_file_info_table_lock);
 	if (i == COMEDI_NUM_BOARD_MINORS) {
 		comedi_device_cleanup(info->device);
 		kfree(info->device);
@@ -2271,14 +2270,13 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 
 void comedi_free_board_minor(unsigned minor)
 {
-	unsigned long flags;
 	struct comedi_device_file_info *info;
 
 	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
-	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock(&comedi_file_info_table_lock);
 	info = comedi_file_info_table[minor];
 	comedi_file_info_table[minor] = NULL;
-	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock(&comedi_file_info_table_lock);
 
 	if (info) {
 		struct comedi_device *dev = info->device;
@@ -2297,7 +2295,6 @@ void comedi_free_board_minor(unsigned minor)
 int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 				 struct comedi_subdevice *s)
 {
-	unsigned long flags;
 	struct comedi_device_file_info *info;
 	struct device *csdev;
 	unsigned i;
@@ -2309,14 +2306,14 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	info->device = dev;
 	info->read_subdevice = s;
 	info->write_subdevice = s;
-	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock(&comedi_file_info_table_lock);
 	for (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
 			comedi_file_info_table[i] = info;
 			break;
 		}
 	}
-	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock(&comedi_file_info_table_lock);
 	if (i == COMEDI_NUM_MINORS) {
 		kfree(info);
 		printk(KERN_ERR
@@ -2372,7 +2369,6 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 
 void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 {
-	unsigned long flags;
 	struct comedi_device_file_info *info;
 
 	if (s == NULL)
@@ -2383,10 +2379,10 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 	BUG_ON(s->minor >= COMEDI_NUM_MINORS);
 	BUG_ON(s->minor < COMEDI_FIRST_SUBDEVICE_MINOR);
 
-	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock(&comedi_file_info_table_lock);
 	info = comedi_file_info_table[s->minor];
 	comedi_file_info_table[s->minor] = NULL;
-	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock(&comedi_file_info_table_lock);
 
 	if (s->class_dev) {
 		device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, s->minor));
@@ -2397,13 +2393,12 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 
 struct comedi_device_file_info *comedi_get_device_file_info(unsigned minor)
 {
-	unsigned long flags;
 	struct comedi_device_file_info *info;
 
 	BUG_ON(minor >= COMEDI_NUM_MINORS);
-	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock(&comedi_file_info_table_lock);
 	info = comedi_file_info_table[minor];
-	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock(&comedi_file_info_table_lock);
 	return info;
 }
 EXPORT_SYMBOL_GPL(comedi_get_device_file_info);

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 0d18d80bcd25..9bcf87ae4c00 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -61,7 +61,7 @@ EXPORT_SYMBOL(comedi_debug);
 module_param(comedi_debug, int, 0644);
 #endif
 
-int comedi_autoconfig = 1;
+bool comedi_autoconfig = 1;
 module_param(comedi_autoconfig, bool, 0444);
 
 static int comedi_num_legacy_minors;

commit 70fe742c94d4d5e7763c3f864f13c0e907ac3d48
Author: Florian Schmaus <fschmaus@gmail.com>
Date:   Wed Dec 14 14:23:24 2011 +0100

    staging: comedi_fops.c whitespace fixes
    
    Changed whitespaces in comedi/*.c to tabs where necessary. All .c
    files within comedi now have no obvious style problems as reported by
    checkpatch.pl
    
    Signed-off-by: Florian Schmaus <fschmaus@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 9c8b33cc438e..0d18d80bcd25 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1479,10 +1479,10 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 
 	dev_file_info = comedi_get_device_file_info(minor);
 	if (dev_file_info == NULL)
-	        return -ENODEV;
+		return -ENODEV;
 	dev = dev_file_info->device;
 	if (dev == NULL)
-	        return -ENODEV;
+		return -ENODEV;
 
 	mutex_lock(&dev->mutex);
 	if (!dev->attached) {
@@ -1556,10 +1556,10 @@ static unsigned int comedi_poll(struct file *file, poll_table * wait)
 	dev_file_info = comedi_get_device_file_info(minor);
 
 	if (dev_file_info == NULL)
-	        return -ENODEV;
+		return -ENODEV;
 	dev = dev_file_info->device;
 	if (dev == NULL)
-	        return -ENODEV;
+		return -ENODEV;
 
 	mutex_lock(&dev->mutex);
 	if (!dev->attached) {
@@ -1610,10 +1610,10 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	dev_file_info = comedi_get_device_file_info(minor);
 
 	if (dev_file_info == NULL)
-	        return -ENODEV;
+		return -ENODEV;
 	dev = dev_file_info->device;
 	if (dev == NULL)
-	        return -ENODEV;
+		return -ENODEV;
 
 	if (!dev->attached) {
 		DPRINTK("no driver configured on comedi%i\n", dev->minor);
@@ -1721,10 +1721,10 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	dev_file_info = comedi_get_device_file_info(minor);
 
 	if (dev_file_info == NULL)
-	        return -ENODEV;
+		return -ENODEV;
 	dev = dev_file_info->device;
 	if (dev == NULL)
-	        return -ENODEV;
+		return -ENODEV;
 
 	if (!dev->attached) {
 		DPRINTK("no driver configured on comedi%i\n", dev->minor);
@@ -1931,10 +1931,10 @@ static int comedi_close(struct inode *inode, struct file *file)
 	dev_file_info = comedi_get_device_file_info(minor);
 
 	if (dev_file_info == NULL)
-	        return -ENODEV;
+		return -ENODEV;
 	dev = dev_file_info->device;
 	if (dev == NULL)
-	        return -ENODEV;
+		return -ENODEV;
 
 	mutex_lock(&dev->mutex);
 
@@ -1973,10 +1973,10 @@ static int comedi_fasync(int fd, struct file *file, int on)
 	dev_file_info = comedi_get_device_file_info(minor);
 
 	if (dev_file_info == NULL)
-	        return -ENODEV;
+		return -ENODEV;
 	dev = dev_file_info->device;
 	if (dev == NULL)
-	        return -ENODEV;
+		return -ENODEV;
 
 	return fasync_helper(fd, file, on, &dev->async_queue);
 }

commit 407f3fd8faf80f77c47ebda7501c6a8698d2f3a6
Merge: dc47ce90c3a8 1d06825b0ede
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Dec 9 19:01:27 2011 -0800

    Merge 3.2-rc5 into staging-next
    
    This resolves the conflict in the
    drivers/staging/iio/industrialio-core.c file due to two different
    changes made to resolve the same problem.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c5018168a59b92ec3bd0f7b598e6d0d64d507e1e
Author: Florian Schmaus <fschmaus@gmail.com>
Date:   Thu Dec 8 12:12:45 2011 +0100

    staging: comedi: comedi_fops: Removed int overflow check
    
    This became unnecessary with the previous commit.
    Improved the readability of the remaining check, by using UINT_MAX.
    
    Signed-off-by: Florian Schmaus <fschmaus@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 60200b46be0b..15877fb0a363 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2430,7 +2430,7 @@ static ssize_t store_max_read_buffer_kb(struct device *dev,
 {
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
 	unsigned int new_max_size_kb;
-	uint64_t new_max_size;
+	unsigned int new_max_size;
 	int ret;
 	struct comedi_subdevice *const read_subdevice =
 	    comedi_get_read_subdevice(info);
@@ -2438,11 +2438,9 @@ static ssize_t store_max_read_buffer_kb(struct device *dev,
 	ret = kstrtouint(buf, 10, &new_max_size_kb);
 	if (ret)
 		return ret;
-	if (new_max_size_kb != (uint32_t) new_max_size_kb)
-		return -EINVAL;
-	new_max_size = ((uint64_t) new_max_size_kb) * bytes_per_kibi;
-	if (new_max_size != (uint32_t) new_max_size)
+	if (new_max_size_kb > (UINT_MAX / bytes_per_kibi))
 		return -EINVAL;
+	new_max_size = new_max_size_kb * bytes_per_kibi;
 
 	mutex_lock(&info->device->mutex);
 	if (read_subdevice == NULL ||
@@ -2493,7 +2491,7 @@ static ssize_t store_read_buffer_kb(struct device *dev,
 {
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
 	unsigned int new_size_kb;
-	uint64_t new_size;
+	unsigned int new_size;
 	int retval;
 	int ret;
 	struct comedi_subdevice *const read_subdevice =
@@ -2502,11 +2500,9 @@ static ssize_t store_read_buffer_kb(struct device *dev,
 	ret = kstrtouint(buf, 10, &new_size_kb);
 	if (ret)
 		return ret;
-	if (new_size_kb != (uint32_t) new_size_kb)
-		return -EINVAL;
-	new_size = ((uint64_t) new_size_kb) * bytes_per_kibi;
-	if (new_size != (uint32_t) new_size)
+	if (new_size_kb > (UINT_MAX / bytes_per_kibi))
 		return -EINVAL;
+	new_size = new_size_kb * bytes_per_kibi;
 
 	mutex_lock(&info->device->mutex);
 	if (read_subdevice == NULL ||
@@ -2561,7 +2557,7 @@ static ssize_t store_max_write_buffer_kb(struct device *dev,
 {
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
 	unsigned int new_max_size_kb;
-	uint64_t new_max_size;
+	unsigned int new_max_size;
 	int ret;
 	struct comedi_subdevice *const write_subdevice =
 	    comedi_get_write_subdevice(info);
@@ -2569,11 +2565,9 @@ static ssize_t store_max_write_buffer_kb(struct device *dev,
 	ret = kstrtouint(buf, 10, &new_max_size_kb);
 	if (ret)
 		return ret;
-	if (new_max_size_kb != (uint32_t) new_max_size_kb)
-		return -EINVAL;
-	new_max_size = ((uint64_t) new_max_size_kb) * bytes_per_kibi;
-	if (new_max_size != (uint32_t) new_max_size)
+	if (new_max_size_kb > (UINT_MAX / bytes_per_kibi))
 		return -EINVAL;
+	new_max_size = new_max_size_kb * bytes_per_kibi;
 
 	mutex_lock(&info->device->mutex);
 	if (write_subdevice == NULL ||
@@ -2624,7 +2618,7 @@ static ssize_t store_write_buffer_kb(struct device *dev,
 {
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
 	unsigned int new_size_kb;
-	uint64_t new_size;
+	unsigned int new_size;
 	int retval;
 	int ret;
 	struct comedi_subdevice *const write_subdevice =
@@ -2633,11 +2627,9 @@ static ssize_t store_write_buffer_kb(struct device *dev,
 	ret = kstrtouint(buf, 10, &new_size_kb);
 	if (ret)
 		return ret;
-	if (new_size_kb != (uint32_t) new_size_kb)
+	if (new_size_kb > (UINT_MAX / bytes_per_kibi))
 		return -EINVAL;
 	new_size = ((uint64_t) new_size_kb) * bytes_per_kibi;
-	if (new_size != (uint32_t) new_size)
-		return -EINVAL;
 
 	mutex_lock(&info->device->mutex);
 	if (write_subdevice == NULL ||

commit 2e1c394fc398afb75d89c53f933149d33dc9e280
Author: Florian Schmaus <fschmaus@gmail.com>
Date:   Thu Dec 8 12:12:44 2011 +0100

    staging: comedi: comedi_fops: Replace deprecated strict_strtoul with kstrtouint
    
    As reported by checkpatch.pl strict_strtoul should be replaced. It was
    replaced with kstrtouint since async->max_bufsize is an unsigned int
    anyway.
    
    Signed-off-by: Florian Schmaus <fschmaus@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 21d8c1c16cd8..60200b46be0b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2429,13 +2429,15 @@ static ssize_t store_max_read_buffer_kb(struct device *dev,
 					const char *buf, size_t count)
 {
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned long new_max_size_kb;
+	unsigned int new_max_size_kb;
 	uint64_t new_max_size;
+	int ret;
 	struct comedi_subdevice *const read_subdevice =
 	    comedi_get_read_subdevice(info);
 
-	if (strict_strtoul(buf, 10, &new_max_size_kb))
-		return -EINVAL;
+	ret = kstrtouint(buf, 10, &new_max_size_kb);
+	if (ret)
+		return ret;
 	if (new_max_size_kb != (uint32_t) new_max_size_kb)
 		return -EINVAL;
 	new_max_size = ((uint64_t) new_max_size_kb) * bytes_per_kibi;
@@ -2490,14 +2492,16 @@ static ssize_t store_read_buffer_kb(struct device *dev,
 				    const char *buf, size_t count)
 {
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned long new_size_kb;
+	unsigned int new_size_kb;
 	uint64_t new_size;
 	int retval;
+	int ret;
 	struct comedi_subdevice *const read_subdevice =
 	    comedi_get_read_subdevice(info);
 
-	if (strict_strtoul(buf, 10, &new_size_kb))
-		return -EINVAL;
+	ret = kstrtouint(buf, 10, &new_size_kb);
+	if (ret)
+		return ret;
 	if (new_size_kb != (uint32_t) new_size_kb)
 		return -EINVAL;
 	new_size = ((uint64_t) new_size_kb) * bytes_per_kibi;
@@ -2556,13 +2560,15 @@ static ssize_t store_max_write_buffer_kb(struct device *dev,
 					 const char *buf, size_t count)
 {
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned long new_max_size_kb;
+	unsigned int new_max_size_kb;
 	uint64_t new_max_size;
+	int ret;
 	struct comedi_subdevice *const write_subdevice =
 	    comedi_get_write_subdevice(info);
 
-	if (strict_strtoul(buf, 10, &new_max_size_kb))
-		return -EINVAL;
+	ret = kstrtouint(buf, 10, &new_max_size_kb);
+	if (ret)
+		return ret;
 	if (new_max_size_kb != (uint32_t) new_max_size_kb)
 		return -EINVAL;
 	new_max_size = ((uint64_t) new_max_size_kb) * bytes_per_kibi;
@@ -2617,14 +2623,16 @@ static ssize_t store_write_buffer_kb(struct device *dev,
 				     const char *buf, size_t count)
 {
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
-	unsigned long new_size_kb;
+	unsigned int new_size_kb;
 	uint64_t new_size;
 	int retval;
+	int ret;
 	struct comedi_subdevice *const write_subdevice =
 	    comedi_get_write_subdevice(info);
 
-	if (strict_strtoul(buf, 10, &new_size_kb))
-		return -EINVAL;
+	ret = kstrtouint(buf, 10, &new_size_kb);
+	if (ret)
+		return ret;
 	if (new_size_kb != (uint32_t) new_size_kb)
 		return -EINVAL;
 	new_size = ((uint64_t) new_size_kb) * bytes_per_kibi;

commit dfd8ee92a9192d78aa38cf8699df3630a7c88c85
Author: Xi Wang <xi.wang@gmail.com>
Date:   Fri Nov 25 16:46:51 2011 -0500

    Staging: comedi: fix integer overflow in do_insnlist_ioctl()
    
    There is a potential integer overflow in do_insnlist_ioctl() if
    userspace passes in a large insnlist.n_insns.  The call to kmalloc()
    would allocate a small buffer, leading to a memory corruption.
    
    The bug was reported by Dan Carpenter <dan.carpenter@oracle.com>
    and Haogang Chen <haogangchen@gmail.com>.  The patch was suggested by
    Ian Abbott <abbotti@mev.co.uk> and Lars-Peter Clausen <lars@metafoo.de>.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reported-by: Haogang Chen <haogangchen@gmail.com>.
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Xi Wang <xi.wang@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ebdcecda3583..5e78c77d5a08 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -671,7 +671,7 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 	}
 
 	insns =
-	    kmalloc(sizeof(struct comedi_insn) * insnlist.n_insns, GFP_KERNEL);
+	    kcalloc(insnlist.n_insns, sizeof(struct comedi_insn), GFP_KERNEL);
 	if (!insns) {
 		DPRINTK("kmalloc failed\n");
 		ret = -ENOMEM;

commit 06b446c8af5db5a98b2eaa30b513c79089ed254b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 28 04:34:34 2011 +0900

    Revert "Staging: comedi: integer overflow in do_insnlist_ioctl()"
    
    This reverts commit e384a41141949843899affcf51f4e6e646c1fe9f.
    It's not the correct way to solve this issue.
    
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ed4853f194c4..ebdcecda3583 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -670,11 +670,6 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 		goto error;
 	}
 
-	if (sizeof(struct comedi_insn) * insnlist.n_insns < insnlist.n_insns) {
-		ret = -EINVAL;
-		goto error;
-	}
-
 	insns =
 	    kmalloc(sizeof(struct comedi_insn) * insnlist.n_insns, GFP_KERNEL);
 	if (!insns) {

commit e384a41141949843899affcf51f4e6e646c1fe9f
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Nov 4 21:20:43 2011 +0300

    Staging: comedi: integer overflow in do_insnlist_ioctl()
    
    There is an integer overflow here that could cause memory corruption
    on 32 bit systems.
    
    insnlist.n_insns could be a very high value size calculation for
    kmalloc() could overflow resulting in a smaller "insns" than
    expected.  In the for (i = 0; i < insnlist.n_insns; i++) {... loop
    we would read past the end of the buffer, possibly corrupting memory
    as well.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ebdcecda3583..ed4853f194c4 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -670,6 +670,11 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 		goto error;
 	}
 
+	if (sizeof(struct comedi_insn) * insnlist.n_insns < insnlist.n_insns) {
+		ret = -EINVAL;
+		goto error;
+	}
+
 	insns =
 	    kmalloc(sizeof(struct comedi_insn) * insnlist.n_insns, GFP_KERNEL);
 	if (!insns) {

commit 6a9ce6b654e491981f6ef7e214cbd4f63e033848
Author: Federico Vaga <federico.vaga@gmail.com>
Date:   Sat Oct 29 09:47:39 2011 +0200

    Staging: comedi: fix signal handling in read and write
    
    After sleeping on a wait queue, signal_pending(current) should be
    checked (not before sleeping).
    
    Acked-by: Alessandro Rubini <rubini@gnudd.com>
    Signed-off-by: Federico Vaga <federico.vaga@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 88caa7376999..ebdcecda3583 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1673,11 +1673,11 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 				retval = -EAGAIN;
 				break;
 			}
+			schedule();
 			if (signal_pending(current)) {
 				retval = -ERESTARTSYS;
 				break;
 			}
-			schedule();
 			if (!s->busy)
 				break;
 			if (s->busy != file) {
@@ -1780,11 +1780,11 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 				retval = -EAGAIN;
 				break;
 			}
+			schedule();
 			if (signal_pending(current)) {
 				retval = -ERESTARTSYS;
 				break;
 			}
-			schedule();
 			if (!s->busy) {
 				retval = 0;
 				break;

commit df30b21cb0eed5ba8a8e0cdfeebc66ba8cde821d
Author: Federico Vaga <federico.vaga@gmail.com>
Date:   Sat Oct 29 09:45:39 2011 +0200

    Staging: comedi: fix mmap_count
    
    In comedi_fops, mmap_count is decremented at comedi_vm_ops->close but
    it is not incremented at comedi_vm_ops->open. This may result in a negative
    counter.  The patch introduces the open method to keep the counter
    consistent.
    
    The bug was triggerd by this sample code:
    
            mmap(0, ...., comedi_fd);
            fork();
            exit(0);
    
    Acked-by: Alessandro Rubini <rubini@gnudd.com>
    Signed-off-by: Federico Vaga <federico.vaga@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 156622a6f162..88caa7376999 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1432,7 +1432,21 @@ static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return ret;
 }
 
-static void comedi_unmap(struct vm_area_struct *area)
+
+static void comedi_vm_open(struct vm_area_struct *area)
+{
+	struct comedi_async *async;
+	struct comedi_device *dev;
+
+	async = area->vm_private_data;
+	dev = async->subdevice->device;
+
+	mutex_lock(&dev->mutex);
+	async->mmap_count++;
+	mutex_unlock(&dev->mutex);
+}
+
+static void comedi_vm_close(struct vm_area_struct *area)
 {
 	struct comedi_async *async;
 	struct comedi_device *dev;
@@ -1446,7 +1460,8 @@ static void comedi_unmap(struct vm_area_struct *area)
 }
 
 static struct vm_operations_struct comedi_vm_ops = {
-	.close = comedi_unmap,
+	.open = comedi_vm_open,
+	.close = comedi_vm_close,
 };
 
 static int comedi_mmap(struct file *file, struct vm_area_struct *vma)

commit 3ffab428f40849ed5f21bcfd7285bdef7902f9ca
Author: Bernd Porr <berndporr@f2s.com>
Date:   Tue Nov 8 21:23:03 2011 +0000

    staging: comedi: fix oops for USB DAQ devices.
    
    This fixes kernel oops when an USB DAQ device is plugged out while it's
    communicating with the userspace software.
    
    Signed-off-by: Bernd Porr <berndporr@f2s.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 21d8c1c16cd8..156622a6f162 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1452,9 +1452,6 @@ static struct vm_operations_struct comedi_vm_ops = {
 static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info =
-	    comedi_get_device_file_info(minor);
-	struct comedi_device *dev = dev_file_info->device;
 	struct comedi_async *async = NULL;
 	unsigned long start = vma->vm_start;
 	unsigned long size;
@@ -1462,6 +1459,15 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	int i;
 	int retval;
 	struct comedi_subdevice *s;
+	struct comedi_device_file_info *dev_file_info;
+	struct comedi_device *dev;
+
+	dev_file_info = comedi_get_device_file_info(minor);
+	if (dev_file_info == NULL)
+	        return -ENODEV;
+	dev = dev_file_info->device;
+	if (dev == NULL)
+	        return -ENODEV;
 
 	mutex_lock(&dev->mutex);
 	if (!dev->attached) {
@@ -1528,11 +1534,17 @@ static unsigned int comedi_poll(struct file *file, poll_table * wait)
 {
 	unsigned int mask = 0;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info =
-	    comedi_get_device_file_info(minor);
-	struct comedi_device *dev = dev_file_info->device;
 	struct comedi_subdevice *read_subdev;
 	struct comedi_subdevice *write_subdev;
+	struct comedi_device_file_info *dev_file_info;
+	struct comedi_device *dev;
+	dev_file_info = comedi_get_device_file_info(minor);
+
+	if (dev_file_info == NULL)
+	        return -ENODEV;
+	dev = dev_file_info->device;
+	if (dev == NULL)
+	        return -ENODEV;
 
 	mutex_lock(&dev->mutex);
 	if (!dev->attached) {
@@ -1578,9 +1590,15 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info =
-	    comedi_get_device_file_info(minor);
-	struct comedi_device *dev = dev_file_info->device;
+	struct comedi_device_file_info *dev_file_info;
+	struct comedi_device *dev;
+	dev_file_info = comedi_get_device_file_info(minor);
+
+	if (dev_file_info == NULL)
+	        return -ENODEV;
+	dev = dev_file_info->device;
+	if (dev == NULL)
+	        return -ENODEV;
 
 	if (!dev->attached) {
 		DPRINTK("no driver configured on comedi%i\n", dev->minor);
@@ -1683,9 +1701,15 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info =
-	    comedi_get_device_file_info(minor);
-	struct comedi_device *dev = dev_file_info->device;
+	struct comedi_device_file_info *dev_file_info;
+	struct comedi_device *dev;
+	dev_file_info = comedi_get_device_file_info(minor);
+
+	if (dev_file_info == NULL)
+	        return -ENODEV;
+	dev = dev_file_info->device;
+	if (dev == NULL)
+	        return -ENODEV;
 
 	if (!dev->attached) {
 		DPRINTK("no driver configured on comedi%i\n", dev->minor);
@@ -1885,11 +1909,17 @@ static int comedi_open(struct inode *inode, struct file *file)
 static int comedi_close(struct inode *inode, struct file *file)
 {
 	const unsigned minor = iminor(inode);
-	struct comedi_device_file_info *dev_file_info =
-	    comedi_get_device_file_info(minor);
-	struct comedi_device *dev = dev_file_info->device;
 	struct comedi_subdevice *s = NULL;
 	int i;
+	struct comedi_device_file_info *dev_file_info;
+	struct comedi_device *dev;
+	dev_file_info = comedi_get_device_file_info(minor);
+
+	if (dev_file_info == NULL)
+	        return -ENODEV;
+	dev = dev_file_info->device;
+	if (dev == NULL)
+	        return -ENODEV;
 
 	mutex_lock(&dev->mutex);
 
@@ -1923,10 +1953,15 @@ static int comedi_close(struct inode *inode, struct file *file)
 static int comedi_fasync(int fd, struct file *file, int on)
 {
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info =
-	    comedi_get_device_file_info(minor);
+	struct comedi_device_file_info *dev_file_info;
+	struct comedi_device *dev;
+	dev_file_info = comedi_get_device_file_info(minor);
 
-	struct comedi_device *dev = dev_file_info->device;
+	if (dev_file_info == NULL)
+	        return -ENODEV;
+	dev = dev_file_info->device;
+	if (dev == NULL)
+	        return -ENODEV;
 
 	return fasync_helper(fd, file, on, &dev->async_queue);
 }

commit f5283a4bb8f5ef274e9de58c751edb2a2d66bef4
Author: Mark Pearson <markpearson_de@yahoo.de>
Date:   Sun Jul 10 21:16:38 2011 +0200

    Staging: comedi: Fixed coding style issues.
    
    comedi_fops.c : A forward decleration was declared as extern although it
                    is a function private to this file. Changed the
                    decleration to static.
    
    Signed-off-by: Mark Pearson <markpearson_de@yahoo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e90e3cceb5f8..21d8c1c16cd8 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -101,7 +101,7 @@ static int do_insn_ioctl(struct comedi_device *dev,
 static int do_poll_ioctl(struct comedi_device *dev, unsigned int subd,
 			 void *file);
 
-extern void do_become_nonbusy(struct comedi_device *dev,
+static void do_become_nonbusy(struct comedi_device *dev,
 			      struct comedi_subdevice *s);
 static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 

commit 0435f9337f051db77b4eaf02eee83e7a29f3474a
Author: Pavel Roskin <proski@gnu.org>
Date:   Wed Jul 6 10:15:44 2011 -0400

    staging: comedi: remove COMEDI_DEVICE_CREATE macro, expand all callers
    
    This is no longer needed as the code is now in the main kernel tree.
    
    Signed-off-by: Pavel Roskin <proski@gnu.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 419976b40bf4..e90e3cceb5f8 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2175,9 +2175,8 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 		return -EBUSY;
 	}
 	info->device->minor = i;
-	csdev = COMEDI_DEVICE_CREATE(comedi_class, NULL,
-				     MKDEV(COMEDI_MAJOR, i), NULL,
-				     hardware_device, "comedi%i", i);
+	csdev = device_create(comedi_class, hardware_device,
+			      MKDEV(COMEDI_MAJOR, i), NULL, "comedi%i", i);
 	if (!IS_ERR(csdev))
 		info->device->class_dev = csdev;
 	dev_set_drvdata(csdev, info);
@@ -2276,10 +2275,9 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 		return -EBUSY;
 	}
 	s->minor = i;
-	csdev = COMEDI_DEVICE_CREATE(comedi_class, dev->class_dev,
-				     MKDEV(COMEDI_MAJOR, i), NULL, NULL,
-				     "comedi%i_subd%i", dev->minor,
-				     (int)(s - dev->subdevices));
+	csdev = device_create(comedi_class, dev->class_dev,
+			      MKDEV(COMEDI_MAJOR, i), NULL, "comedi%i_subd%i",
+			      dev->minor, (int)(s - dev->subdevices));
 	if (!IS_ERR(csdev))
 		s->class_dev = csdev;
 	dev_set_drvdata(csdev, info);

commit 819cbb120eaec7e014e5abd029260db1ca8c5735
Author: Vasiliy Kulikov <segoon@openwall.com>
Date:   Sun Jun 26 12:56:22 2011 +0400

    staging: comedi: fix infoleak to userspace
    
    driver_name and board_name are pointers to strings, not buffers of size
    COMEDI_NAMELEN.  Copying COMEDI_NAMELEN bytes of a string containing
    less than COMEDI_NAMELEN-1 bytes would leak some unrelated bytes.
    
    Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 15a209f5b486..419976b40bf4 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -383,8 +383,8 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 	/* fill devinfo structure */
 	devinfo.version_code = COMEDI_VERSION_CODE;
 	devinfo.n_subdevs = dev->n_subdevices;
-	memcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
-	memcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
+	strlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
+	strlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
 
 	if (read_subdev)
 		devinfo.read_subdevice = read_subdev - dev->subdevices;

commit c5274ab09747d0ef829f9b8f040756758e5de55c
Author: Greg Dietsche <Gregory.Dietsche@cuw.edu>
Date:   Mon Jun 13 13:11:47 2011 -0500

    staging: remove unnecessary code
    
    Compile tested.
    remove unnecessary code that matches this coccinelle pattern
            if (...)
                    return ret;
            return ret;
    
    Signed-off-by: Greg Dietsche <Gregory.Dietsche@cuw.edu>
    Acked-by: Franky Lin <frankyl@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e7e72b8d8cde..15a209f5b486 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1291,10 +1291,10 @@ static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,
 		s->lock = file;
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 
+#if 0
 	if (ret < 0)
 		return ret;
 
-#if 0
 	if (s->lock_f)
 		ret = s->lock_f(dev, s);
 #endif

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a4ceb29c358e..e7e72b8d8cde 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2064,7 +2064,7 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 			     COMEDI_CB_OVERFLOW)) {
 		runflags_mask |= SRF_RUNNING;
 	}
-	/* remember if an error event has occured, so an error
+	/* remember if an error event has occurred, so an error
 	 * can be returned the next time the user does a read() */
 	if (s->async->events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {
 		runflags_mask |= SRF_ERROR;

commit 2f644ccfc5a3195290d12b8eedf18a37bba27d98
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jan 18 17:44:33 2011 +0000

    staging: comedi: Make INSN_BITS behavior consistent across drivers
    
    Most comedi hardware drivers that support the INSN_BITS instruction
    ignore the base channel (specified by insn->chanspec) and assume it is
    0.  The base channel is supposed to affect how the mask (in data[0]) and
    bits (in data[1]) are treated.  Bit 0 applies to the base channel, bit 1
    applies to base channel plus 1, etc.
    
    For subdevices with no more than 32 channels, this patch modifies the
    chanspec and data before presenting it to the hardware driver, and
    modifies the data bits read back by the hardware driver (into data[1]).
    This makes it appear to the hardware driver that the base channel was
    set to 0.
    
    For subdevices with more than 32 channels, the instruction is left
    unmodified, as it is assumed that the hardware driver takes note of the
    base channel in this case in order to provide access beyond channel 31.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 093032ba521a..a4ceb29c358e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -910,9 +910,28 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 		case INSN_BITS:
 			if (insn->n != 2) {
 				ret = -EINVAL;
-				break;
+			} else {
+				/* Most drivers ignore the base channel in
+				 * insn->chanspec.  Fix this here if
+				 * the subdevice has <= 32 channels.  */
+				unsigned int shift;
+				unsigned int orig_mask;
+
+				orig_mask = data[0];
+				if (s->n_chan <= 32) {
+					shift = CR_CHAN(insn->chanspec);
+					if (shift > 0) {
+						insn->chanspec = 0;
+						data[0] <<= shift;
+						data[1] <<= shift;
+					}
+				} else
+					shift = 0;
+				ret = s->insn_bits(dev, s, insn, data);
+				data[0] = orig_mask;
+				if (shift > 0)
+					data[1] >>= shift;
 			}
-			ret = s->insn_bits(dev, s, insn, data);
 			break;
 		case INSN_CONFIG:
 			ret = check_insn_config_length(insn, data);

commit e4c5bf8e3dca827a1b3a6fac494eae8c74b7e1e7
Merge: 81280572ca6f a4ac0d847af9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 28 09:44:56 2010 -0700

    Merge 'staging-next' to Linus's tree
    
    This merges the staging-next tree to Linus's tree and resolves
    some conflicts that were present due to changes in other trees that were
    affected by files here.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 14091313cebb..fecb89e8c663 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1922,6 +1922,7 @@ const struct file_operations comedi_fops = {
 	.mmap = comedi_mmap,
 	.poll = comedi_poll,
 	.fasync = comedi_fasync,
+	.llseek = noop_llseek,
 };
 
 struct class *comedi_class;

commit 81604d43ade6abd316444f99ddb633f2e5a3f3eb
Author: Vasiliy Kulikov <segooon@gmail.com>
Date:   Sun Sep 5 22:32:33 2010 +0400

    staging: comedi: check return code of put_user
    
    Function put_user may fail. Check for it.
    
    Signed-off-by: Vasiliy Kulikov <segooon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 14091313cebb..98fa255d862e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -537,7 +537,8 @@ static int do_chaninfo_ioctl(struct comedi_device *dev,
 
 			x = (dev->minor << 28) | (it.subdev << 24) | (i << 16) |
 			    (s->range_table_list[i]->length);
-			put_user(x, it.rangelist + i);
+			if (put_user(x, it.rangelist + i))
+				return -EFAULT;
 		}
 #if 0
 		if (copy_to_user(it.rangelist, s->range_type_list,

commit 3c17ba0743d75f9888d905ddf9f8551c7dd36493
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed May 19 14:10:00 2010 +0100

    Staging: comedi: Allow 'open' driver method to fail
    
    Some comedi drivers should return an error from their 'open' method when
    something goes wrong.  Change the prototype of the 'open' method in
    'struct comedi_device' to allow this, and change the drivers that use it.
    Propagate any error to the 'open' file operation.
    
    The corresponding 'close' method won't be called when the 'open' method
    fails, so drivers failing the 'open' need to clean up any mess they
    created.
    
    The dt9812 and serial2002 drivers can now return an error on 'open'.
    The jr3_pci driver also uses the 'open' method but doesn't fail it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index aeb2c00875cd..14091313cebb 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1845,8 +1845,15 @@ static int comedi_open(struct inode *inode, struct file *file)
 		}
 	}
 
-	if (dev->attached && dev->use_count == 0 && dev->open)
-		dev->open(dev);
+	if (dev->attached && dev->use_count == 0 && dev->open) {
+		int rc = dev->open(dev);
+		if (rc < 0) {
+			module_put(dev->driver->module);
+			module_put(THIS_MODULE);
+			mutex_unlock(&dev->mutex);
+			return rc;
+		}
+	}
 
 	dev->use_count++;
 

commit 53fa827e295d8b09a2446b3126577244644d256d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed May 19 18:09:50 2010 +0100

    Staging: comedi: For COMEDI_BUFINFO, check access to command
    
    Don't allow COMEDI_BUFINFO ioctl if some other file object has locked
    the subdevice or has an active command.  If there is no active command,
    just report back the last buffer position.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 75256251250d..aeb2c00875cd 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -83,7 +83,7 @@ static int do_subdinfo_ioctl(struct comedi_device *dev,
 static int do_chaninfo_ioctl(struct comedi_device *dev,
 			     struct comedi_chaninfo __user *arg);
 static int do_bufinfo_ioctl(struct comedi_device *dev,
-			    struct comedi_bufinfo __user *arg);
+			    struct comedi_bufinfo __user *arg, void *file);
 static int do_cmd_ioctl(struct comedi_device *dev,
 			struct comedi_cmd __user *arg, void *file);
 static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,
@@ -169,7 +169,8 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 		break;
 	case COMEDI_BUFINFO:
 		rc = do_bufinfo_ioctl(dev,
-				      (struct comedi_bufinfo __user *)arg);
+				      (struct comedi_bufinfo __user *)arg,
+				      file);
 		break;
 	case COMEDI_LOCK:
 		rc = do_lock_ioctl(dev, arg, file);
@@ -563,7 +564,7 @@ static int do_chaninfo_ioctl(struct comedi_device *dev,
 
   */
 static int do_bufinfo_ioctl(struct comedi_device *dev,
-			    struct comedi_bufinfo __user *arg)
+			    struct comedi_bufinfo __user *arg, void *file)
 {
 	struct comedi_bufinfo bi;
 	struct comedi_subdevice *s;
@@ -576,6 +577,10 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		return -EINVAL;
 
 	s = dev->subdevices + bi.subdevice;
+
+	if (s->lock && s->lock != file)
+		return -EACCES;
+
 	async = s->async;
 
 	if (!async) {
@@ -588,6 +593,13 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		bi.bytes_written = 0;
 		goto copyback;
 	}
+	if (!s->busy) {
+		bi.bytes_read = 0;
+		bi.bytes_written = 0;
+		goto copyback_position;
+	}
+	if (s->busy != file)
+		return -EACCES;
 
 	if (bi.bytes_read && (s->subdev_flags & SDF_CMD_READ)) {
 		bi.bytes_read = comedi_buf_read_alloc(async, bi.bytes_read);
@@ -606,6 +618,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		comedi_buf_write_free(async, bi.bytes_written);
 	}
 
+copyback_position:
 	bi.buf_write_count = async->buf_write_count;
 	bi.buf_write_ptr = async->buf_write_ptr;
 	bi.buf_read_count = async->buf_read_count;

commit 4772c018e35b6a21e8a8bde54568b59998540a16
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed May 19 18:09:49 2010 +0100

    Staging: comedi: COMEDI_BUFINFO with no async - report no bytes read or written
    
    When the COMEDI_BUFINFO ioctl is used on a subdevice without
    asynchronous streaming command support, set 'bytes_read = 0' and
    'bytes_written = 0' in the buffer info returned back to the user.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 39ed22b80229..75256251250d 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -584,6 +584,8 @@ static int do_bufinfo_ioctl(struct comedi_device *dev,
 		bi.buf_read_ptr = 0;
 		bi.buf_write_count = 0;
 		bi.buf_read_count = 0;
+		bi.bytes_read = 0;
+		bi.bytes_written = 0;
 		goto copyback;
 	}
 

commit d261154057c27f6c1d256b6198b0ad08733f1758
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed May 19 17:22:41 2010 +0100

    Staging: comedi: don't write to buffer if command finished
    
    For write(), any data copied to the data buffer after the previously
    set up streaming acquisition command has finished won't be used, but a
    non-empty write() does not currently return 0 (or -EPIPE on error) after
    the command has finished until the data buffer has been filled up.
    Change this behavior to return 0 (or -EPIPE) any time after the command
    has finished, without bothering to fill up the buffer with more useless
    data.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index aced00e5cd10..39ed22b80229 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1576,6 +1576,19 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 	while (nbytes > 0 && !retval) {
 		set_current_state(TASK_INTERRUPTIBLE);
 
+		if (!(comedi_get_subdevice_runflags(s) & SRF_RUNNING)) {
+			if (count == 0) {
+				if (comedi_get_subdevice_runflags(s) &
+					SRF_ERROR) {
+					retval = -EPIPE;
+				} else {
+					retval = 0;
+				}
+				do_become_nonbusy(dev, s);
+			}
+			break;
+		}
+
 		n = nbytes;
 
 		m = n;
@@ -1588,16 +1601,6 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 			n = m;
 
 		if (n == 0) {
-			if (!(comedi_get_subdevice_runflags(s) & SRF_RUNNING)) {
-				if (comedi_get_subdevice_runflags(s) &
-				    SRF_ERROR) {
-					retval = -EPIPE;
-				} else {
-					retval = 0;
-				}
-				do_become_nonbusy(dev, s);
-				break;
-			}
 			if (file->f_flags & O_NONBLOCK) {
 				retval = -EAGAIN;
 				break;

commit 21fe2eea6381845956322e63e441f351774de7f9
Author: Mark <reodge@gmail.com>
Date:   Thu May 13 17:44:39 2010 +0800

    Staging: comedi: Fix long line lengths in comedi_fops.c
    
    This patch fixes lots of long line lengths in comedi_fops.c found by
    checkpatch.pl
    
    Signed-off-by: Mark Rankilor <reodge@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e7095d766f40..aced00e5cd10 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -952,8 +952,9 @@ static int do_insn_ioctl(struct comedi_device *dev,
 	if (insn.n > MAX_SAMPLES)
 		insn.n = MAX_SAMPLES;
 	if (insn.insn & INSN_MASK_WRITE) {
-		if (copy_from_user
-		    (data, insn.data, insn.n * sizeof(unsigned int))) {
+		if (copy_from_user(data,
+				   insn.data,
+				   insn.n * sizeof(unsigned int))) {
 			ret = -EFAULT;
 			goto error;
 		}
@@ -962,7 +963,9 @@ static int do_insn_ioctl(struct comedi_device *dev,
 	if (ret < 0)
 		goto error;
 	if (insn.insn & INSN_MASK_READ) {
-		if (copy_to_user(insn.data, data, insn.n * sizeof(unsigned int))) {
+		if (copy_to_user(insn.data,
+				 data,
+				 insn.n * sizeof(unsigned int))) {
 			ret = -EFAULT;
 			goto error;
 		}
@@ -1070,7 +1073,9 @@ static int do_cmd_ioctl(struct comedi_device *dev,
 	}
 
 	/* make sure each element in channel/gain list is valid */
-	ret = comedi_check_chanlist(s, async->cmd.chanlist_len, async->cmd.chanlist);
+	ret = comedi_check_chanlist(s,
+				    async->cmd.chanlist_len,
+				    async->cmd.chanlist);
 	if (ret < 0) {
 		DPRINTK("bad chanlist\n");
 		goto cleanup;
@@ -2119,8 +2124,8 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 		kfree(info->device);
 		kfree(info);
 		printk(KERN_ERR
-
-		       "comedi: error: ran out of minor numbers for board device files.\n");
+		       "comedi: error: "
+		       "ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}
 	info->device->minor = i;
@@ -2133,7 +2138,8 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	retval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);
 	if (retval) {
 		printk(KERN_ERR
-		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       "comedi: "
+		       "failed to create sysfs attribute file \"%s\".\n",
 		       dev_attr_max_read_buffer_kb.attr.name);
 		comedi_free_board_minor(i);
 		return retval;
@@ -2141,7 +2147,8 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	retval = device_create_file(csdev, &dev_attr_read_buffer_kb);
 	if (retval) {
 		printk(KERN_ERR
-		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       "comedi: "
+		       "failed to create sysfs attribute file \"%s\".\n",
 		       dev_attr_read_buffer_kb.attr.name);
 		comedi_free_board_minor(i);
 		return retval;
@@ -2149,7 +2156,8 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	retval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);
 	if (retval) {
 		printk(KERN_ERR
-		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       "comedi: "
+		       "failed to create sysfs attribute file \"%s\".\n",
 		       dev_attr_max_write_buffer_kb.attr.name);
 		comedi_free_board_minor(i);
 		return retval;
@@ -2157,7 +2165,8 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	retval = device_create_file(csdev, &dev_attr_write_buffer_kb);
 	if (retval) {
 		printk(KERN_ERR
-		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       "comedi: "
+		       "failed to create sysfs attribute file \"%s\".\n",
 		       dev_attr_write_buffer_kb.attr.name);
 		comedi_free_board_minor(i);
 		return retval;
@@ -2216,7 +2225,8 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	if (i == COMEDI_NUM_MINORS) {
 		kfree(info);
 		printk(KERN_ERR
-		       "comedi: error: ran out of minor numbers for board device files.\n");
+		       "comedi: error: "
+		       "ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}
 	s->minor = i;
@@ -2230,7 +2240,8 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	retval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);
 	if (retval) {
 		printk(KERN_ERR
-		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       "comedi: "
+		       "failed to create sysfs attribute file \"%s\".\n",
 		       dev_attr_max_read_buffer_kb.attr.name);
 		comedi_free_subdevice_minor(s);
 		return retval;
@@ -2238,7 +2249,8 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	retval = device_create_file(csdev, &dev_attr_read_buffer_kb);
 	if (retval) {
 		printk(KERN_ERR
-		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       "comedi: "
+		       "failed to create sysfs attribute file \"%s\".\n",
 		       dev_attr_read_buffer_kb.attr.name);
 		comedi_free_subdevice_minor(s);
 		return retval;
@@ -2246,7 +2258,8 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	retval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);
 	if (retval) {
 		printk(KERN_ERR
-		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       "comedi: "
+		       "failed to create sysfs attribute file \"%s\".\n",
 		       dev_attr_max_write_buffer_kb.attr.name);
 		comedi_free_subdevice_minor(s);
 		return retval;
@@ -2254,7 +2267,8 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	retval = device_create_file(csdev, &dev_attr_write_buffer_kb);
 	if (retval) {
 		printk(KERN_ERR
-		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       "comedi: "
+		       "failed to create sysfs attribute file \"%s\".\n",
 		       dev_attr_write_buffer_kb.attr.name);
 		comedi_free_subdevice_minor(s);
 		return retval;

commit 92d0127c9d249c078b0939050f25041ed37be7cd
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 3 16:32:28 2010 -0700

    Staging: comedi: __user markup on comedi_fops.c
    
    Hm, what a mess.  I tried to properly mark up the __user pointers,
    but for some of these structures, we use them both in the kernel,
    and across the user/kernel boundry, which isn't ok.  So we end
    up generating a few new sparse warnings in places we were not before,
    but the large majority of things are now properly tagged in the fops
    file.
    
    The whole ioctl interface needs to be carefully looked at in the future.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ce8e2549b8ff..e7095d766f40 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -64,7 +64,7 @@ module_param(comedi_debug, int, 0644);
 int comedi_autoconfig = 1;
 module_param(comedi_autoconfig, bool, 0444);
 
-int comedi_num_legacy_minors;
+static int comedi_num_legacy_minors;
 module_param(comedi_num_legacy_minors, int, 0444);
 
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
@@ -72,25 +72,32 @@ static struct comedi_device_file_info
 *comedi_file_info_table[COMEDI_NUM_MINORS];
 
 static int do_devconfig_ioctl(struct comedi_device *dev,
-			      struct comedi_devconfig *arg);
-static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg);
+			      struct comedi_devconfig __user *arg);
+static int do_bufconfig_ioctl(struct comedi_device *dev,
+			      struct comedi_bufconfig __user *arg);
 static int do_devinfo_ioctl(struct comedi_device *dev,
-			    struct comedi_devinfo *arg, struct file *file);
+			    struct comedi_devinfo __user *arg,
+			    struct file *file);
 static int do_subdinfo_ioctl(struct comedi_device *dev,
-			     struct comedi_subdinfo *arg, void *file);
+			     struct comedi_subdinfo __user *arg, void *file);
 static int do_chaninfo_ioctl(struct comedi_device *dev,
-			     struct comedi_chaninfo *arg);
-static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg);
-static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file);
+			     struct comedi_chaninfo __user *arg);
+static int do_bufinfo_ioctl(struct comedi_device *dev,
+			    struct comedi_bufinfo __user *arg);
+static int do_cmd_ioctl(struct comedi_device *dev,
+			struct comedi_cmd __user *arg, void *file);
 static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,
 			 void *file);
 static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg,
 			   void *file);
 static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
 			   void *file);
-static int do_cmdtest_ioctl(struct comedi_device *dev, void *arg, void *file);
-static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file);
-static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file);
+static int do_cmdtest_ioctl(struct comedi_device *dev,
+			    struct comedi_cmd __user *arg, void *file);
+static int do_insnlist_ioctl(struct comedi_device *dev,
+			     struct comedi_insnlist __user *arg, void *file);
+static int do_insn_ioctl(struct comedi_device *dev,
+			 struct comedi_insn __user *arg, void *file);
 static int do_poll_ioctl(struct comedi_device *dev, unsigned int subd,
 			 void *file);
 
@@ -129,7 +136,8 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 	/* Device config is special, because it must work on
 	 * an unconfigured device. */
 	if (cmd == COMEDI_DEVCONFIG) {
-		rc = do_devconfig_ioctl(dev, (void *)arg);
+		rc = do_devconfig_ioctl(dev,
+					(struct comedi_devconfig __user *)arg);
 		goto done;
 	}
 
@@ -141,22 +149,27 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 
 	switch (cmd) {
 	case COMEDI_BUFCONFIG:
-		rc = do_bufconfig_ioctl(dev, (void *)arg);
+		rc = do_bufconfig_ioctl(dev,
+					(struct comedi_bufconfig __user *)arg);
 		break;
 	case COMEDI_DEVINFO:
-		rc = do_devinfo_ioctl(dev, (void *)arg, file);
+		rc = do_devinfo_ioctl(dev, (struct comedi_devinfo __user *)arg,
+				      file);
 		break;
 	case COMEDI_SUBDINFO:
-		rc = do_subdinfo_ioctl(dev, (void *)arg, file);
+		rc = do_subdinfo_ioctl(dev,
+				       (struct comedi_subdinfo __user *)arg,
+				       file);
 		break;
 	case COMEDI_CHANINFO:
-		rc = do_chaninfo_ioctl(dev, (void *)arg);
+		rc = do_chaninfo_ioctl(dev, (void __user *)arg);
 		break;
 	case COMEDI_RANGEINFO:
-		rc = do_rangeinfo_ioctl(dev, (void *)arg);
+		rc = do_rangeinfo_ioctl(dev, (void __user *)arg);
 		break;
 	case COMEDI_BUFINFO:
-		rc = do_bufinfo_ioctl(dev, (void *)arg);
+		rc = do_bufinfo_ioctl(dev,
+				      (struct comedi_bufinfo __user *)arg);
 		break;
 	case COMEDI_LOCK:
 		rc = do_lock_ioctl(dev, arg, file);
@@ -168,16 +181,20 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 		rc = do_cancel_ioctl(dev, arg, file);
 		break;
 	case COMEDI_CMD:
-		rc = do_cmd_ioctl(dev, (void *)arg, file);
+		rc = do_cmd_ioctl(dev, (struct comedi_cmd __user *)arg, file);
 		break;
 	case COMEDI_CMDTEST:
-		rc = do_cmdtest_ioctl(dev, (void *)arg, file);
+		rc = do_cmdtest_ioctl(dev, (struct comedi_cmd __user *)arg,
+				      file);
 		break;
 	case COMEDI_INSNLIST:
-		rc = do_insnlist_ioctl(dev, (void *)arg, file);
+		rc = do_insnlist_ioctl(dev,
+				       (struct comedi_insnlist __user *)arg,
+				       file);
 		break;
 	case COMEDI_INSN:
-		rc = do_insn_ioctl(dev, (void *)arg, file);
+		rc = do_insn_ioctl(dev, (struct comedi_insn __user *)arg,
+				   file);
 		break;
 	case COMEDI_POLL:
 		rc = do_poll_ioctl(dev, arg, file);
@@ -206,7 +223,7 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 		none
 */
 static int do_devconfig_ioctl(struct comedi_device *dev,
-			      struct comedi_devconfig *arg)
+			      struct comedi_devconfig __user *arg)
 {
 	struct comedi_devconfig it;
 	int ret;
@@ -286,7 +303,8 @@ static int do_devconfig_ioctl(struct comedi_device *dev,
 		modified bufconfig at arg
 
 */
-static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg)
+static int do_bufconfig_ioctl(struct comedi_device *dev,
+			      struct comedi_bufconfig __user *arg)
 {
 	struct comedi_bufconfig bc;
 	struct comedi_async *async;
@@ -347,7 +365,8 @@ static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg)
 
 */
 static int do_devinfo_ioctl(struct comedi_device *dev,
-			    struct comedi_devinfo *arg, struct file *file)
+			    struct comedi_devinfo __user *arg,
+			    struct file *file)
 {
 	struct comedi_devinfo devinfo;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
@@ -397,7 +416,7 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 
 */
 static int do_subdinfo_ioctl(struct comedi_device *dev,
-			     struct comedi_subdinfo *arg, void *file)
+			     struct comedi_subdinfo __user *arg, void *file)
 {
 	int ret, i;
 	struct comedi_subdinfo *tmp, *us;
@@ -479,7 +498,7 @@ static int do_subdinfo_ioctl(struct comedi_device *dev,
 
 */
 static int do_chaninfo_ioctl(struct comedi_device *dev,
-			     struct comedi_chaninfo *arg)
+			     struct comedi_chaninfo __user *arg)
 {
 	struct comedi_subdevice *s;
 	struct comedi_chaninfo it;
@@ -543,7 +562,8 @@ static int do_chaninfo_ioctl(struct comedi_device *dev,
     modified bufinfo at arg
 
   */
-static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg)
+static int do_bufinfo_ioctl(struct comedi_device *dev,
+			    struct comedi_bufinfo __user *arg)
 {
 	struct comedi_bufinfo bi;
 	struct comedi_subdevice *s;
@@ -615,7 +635,8 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
  */
 /* arbitrary limits */
 #define MAX_SAMPLES 256
-static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file)
+static int do_insnlist_ioctl(struct comedi_device *dev,
+			     struct comedi_insnlist __user *arg, void *file)
 {
 	struct comedi_insnlist insnlist;
 	struct comedi_insn *insns = NULL;
@@ -909,7 +930,8 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
  *	writes:
  *		data (for reads)
  */
-static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file)
+static int do_insn_ioctl(struct comedi_device *dev,
+			 struct comedi_insn __user *arg, void *file)
 {
 	struct comedi_insn insn;
 	unsigned int *data = NULL;
@@ -940,8 +962,7 @@ static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file)
 	if (ret < 0)
 		goto error;
 	if (insn.insn & INSN_MASK_READ) {
-		if (copy_to_user
-		    (insn.data, data, insn.n * sizeof(unsigned int))) {
+		if (copy_to_user(insn.data, data, insn.n * sizeof(unsigned int))) {
 			ret = -EFAULT;
 			goto error;
 		}
@@ -965,30 +986,16 @@ static void comedi_set_subdevice_runflags(struct comedi_subdevice *s,
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 }
 
-/*
-	COMEDI_CMD
-	command ioctl
-
-	arg:
-		pointer to cmd structure
-
-	reads:
-		cmd structure at arg
-		channel/range list
-
-	writes:
-		modified cmd structure at arg
-
-*/
-static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file)
+static int do_cmd_ioctl(struct comedi_device *dev,
+			struct comedi_cmd __user *cmd, void *file)
 {
 	struct comedi_cmd user_cmd;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 	int ret = 0;
-	unsigned int *chanlist_saver = NULL;
+	unsigned int __user *chanlist_saver = NULL;
 
-	if (copy_from_user(&user_cmd, arg, sizeof(struct comedi_cmd))) {
+	if (copy_from_user(&user_cmd, cmd, sizeof(struct comedi_cmd))) {
 		DPRINTK("bad cmd address\n");
 		return -EFAULT;
 	}
@@ -1077,7 +1084,7 @@ static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file)
 		/* restore chanlist pointer before copying back */
 		user_cmd.chanlist = chanlist_saver;
 		user_cmd.data = NULL;
-		if (copy_to_user(arg, &user_cmd, sizeof(struct comedi_cmd))) {
+		if (copy_to_user(cmd, &user_cmd, sizeof(struct comedi_cmd))) {
 			DPRINTK("fault writing cmd\n");
 			ret = -EFAULT;
 			goto cleanup;
@@ -1127,13 +1134,14 @@ static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file)
 		modified cmd structure at arg
 
 */
-static int do_cmdtest_ioctl(struct comedi_device *dev, void *arg, void *file)
+static int do_cmdtest_ioctl(struct comedi_device *dev,
+			    struct comedi_cmd __user *arg, void *file)
 {
 	struct comedi_cmd user_cmd;
 	struct comedi_subdevice *s;
 	int ret = 0;
 	unsigned int *chanlist = NULL;
-	unsigned int *chanlist_saver = NULL;
+	unsigned int __user *chanlist_saver = NULL;
 
 	if (copy_from_user(&user_cmd, arg, sizeof(struct comedi_cmd))) {
 		DPRINTK("bad cmd address\n");
@@ -1384,7 +1392,7 @@ static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return ret;
 }
 
-void comedi_unmap(struct vm_area_struct *area)
+static void comedi_unmap(struct vm_area_struct *area)
 {
 	struct comedi_async *async;
 	struct comedi_device *dev;
@@ -1522,8 +1530,8 @@ static unsigned int comedi_poll(struct file *file, poll_table * wait)
 	return mask;
 }
 
-static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
-				loff_t *offset)
+static ssize_t comedi_write(struct file *file, const char __user *buf,
+			    size_t nbytes, loff_t *offset)
 {
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
@@ -1624,7 +1632,7 @@ static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
 	return count ? count : retval;
 }
 
-static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
+static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 				loff_t *offset)
 {
 	struct comedi_subdevice *s;
@@ -2063,7 +2071,7 @@ static int is_device_busy(struct comedi_device *dev)
 	return 0;
 }
 
-void comedi_device_init(struct comedi_device *dev)
+static void comedi_device_init(struct comedi_device *dev)
 {
 	memset(dev, 0, sizeof(struct comedi_device));
 	spin_lock_init(&dev->spinlock);
@@ -2071,7 +2079,7 @@ void comedi_device_init(struct comedi_device *dev)
 	dev->minor = -1;
 }
 
-void comedi_device_cleanup(struct comedi_device *dev)
+static void comedi_device_cleanup(struct comedi_device *dev)
 {
 	if (dev == NULL)
 		return;

commit 9e8c604821b372c6e98e9632f5617913bf92ae45
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 3 15:24:14 2010 -0700

    Staging: comedi: make comedi_free_board_minor local to comedi core
    
    No one outside of the comedi core calls this function, so don't export
    it to the world.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 2634af2f33df..ce8e2549b8ff 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2181,7 +2181,6 @@ void comedi_free_board_minor(unsigned minor)
 		kfree(info);
 	}
 }
-EXPORT_SYMBOL_GPL(comedi_free_board_minor);
 
 int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 				 struct comedi_subdevice *s)

commit 242e7ad91a067243d7ab63b6a25ed2e085733446
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 3 15:20:29 2010 -0700

    Staging: comedi: make comedi_alloc_board_minor local to comedi core
    
    No one outside of the comedi core calls this function, so create
    an internal.h file to put the prototype in, and don't export
    it to the world.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 135c80ab6d10..2634af2f33df 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -49,7 +49,7 @@
 #include <linux/io.h>
 #include <linux/uaccess.h>
 
-/* #include "kvmem.h" */
+#include "internal.h"
 
 MODULE_AUTHOR("http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi core module");
@@ -2156,7 +2156,6 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	}
 	return i;
 }
-EXPORT_SYMBOL_GPL(comedi_alloc_board_minor);
 
 void comedi_free_board_minor(unsigned minor)
 {

commit 181bd67bf5780b941f2cba6247ed1c0cdfce468a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 3 15:15:06 2010 -0700

    Staging: comedi: make comedi_set_subdevice_runflags() static
    
    No one calls this anymore, except the core comedi code, so
    mark it static and don't export it.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index b11f9b08000b..135c80ab6d10 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -954,6 +954,17 @@ static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file)
 	return ret;
 }
 
+static void comedi_set_subdevice_runflags(struct comedi_subdevice *s,
+					  unsigned mask, unsigned bits)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&s->spin_lock, flags);
+	s->runflags &= ~mask;
+	s->runflags |= (bits & mask);
+	spin_unlock_irqrestore(&s->spin_lock, flags);
+}
+
 /*
 	COMEDI_CMD
 	command ioctl
@@ -2021,18 +2032,6 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 EXPORT_SYMBOL(comedi_event);
 
-void comedi_set_subdevice_runflags(struct comedi_subdevice *s, unsigned mask,
-				   unsigned bits)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->spin_lock, flags);
-	s->runflags &= ~mask;
-	s->runflags |= (bits & mask);
-	spin_unlock_irqrestore(&s->spin_lock, flags);
-}
-EXPORT_SYMBOL(comedi_set_subdevice_runflags);
-
 unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 {
 	unsigned long flags;

commit 0fd0ca75fd9eb0e9cde49c28ad227c2d8d049366
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat May 1 12:33:17 2010 -0700

    Staging: comedi: rename check_chanlist to comedi_check_chanlist
    
    It's a global function, so properly name it and move the
    export to where the function is located at.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 4fe3d0c2e6bf..b11f9b08000b 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -839,7 +839,7 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 			goto out;
 		}
 
-		ret = check_chanlist(s, 1, &insn->chanspec);
+		ret = comedi_check_chanlist(s, 1, &insn->chanspec);
 		if (ret < 0) {
 			ret = -EINVAL;
 			DPRINTK("bad chanspec\n");
@@ -1052,7 +1052,7 @@ static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file)
 	}
 
 	/* make sure each element in channel/gain list is valid */
-	ret = check_chanlist(s, async->cmd.chanlist_len, async->cmd.chanlist);
+	ret = comedi_check_chanlist(s, async->cmd.chanlist_len, async->cmd.chanlist);
 	if (ret < 0) {
 		DPRINTK("bad chanlist\n");
 		goto cleanup;
@@ -1174,7 +1174,7 @@ static int do_cmdtest_ioctl(struct comedi_device *dev, void *arg, void *file)
 		}
 
 		/* make sure each element in channel/gain list is valid */
-		ret = check_chanlist(s, user_cmd.chanlist_len, chanlist);
+		ret = comedi_check_chanlist(s, user_cmd.chanlist_len, chanlist);
 		if (ret < 0) {
 			DPRINTK("bad chanlist\n");
 			goto cleanup;

commit 18736438ae4ab3d96602b92446e07cc03c024b02
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat May 1 12:02:23 2010 -0700

    Staging: comedi: more EXPORT_SYMBOL movement
    
    This moves the markings to the comedi_fops.c file, where
    they belong.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1b3aed4ee60a..4fe3d0c2e6bf 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -57,6 +57,7 @@ MODULE_LICENSE("GPL");
 
 #ifdef CONFIG_COMEDI_DEBUG
 int comedi_debug;
+EXPORT_SYMBOL(comedi_debug);
 module_param(comedi_debug, int, 0644);
 #endif
 
@@ -1975,6 +1976,7 @@ void comedi_error(const struct comedi_device *dev, const char *s)
 	printk(KERN_ERR "comedi%d: %s: %s\n", dev->minor,
 	       dev->driver->driver_name, s);
 }
+EXPORT_SYMBOL(comedi_error);
 
 void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
@@ -2017,6 +2019,7 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	s->async->events = 0;
 }
+EXPORT_SYMBOL(comedi_event);
 
 void comedi_set_subdevice_runflags(struct comedi_subdevice *s, unsigned mask,
 				   unsigned bits)
@@ -2028,6 +2031,7 @@ void comedi_set_subdevice_runflags(struct comedi_subdevice *s, unsigned mask,
 	s->runflags |= (bits & mask);
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 }
+EXPORT_SYMBOL(comedi_set_subdevice_runflags);
 
 unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 {
@@ -2039,6 +2043,7 @@ unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 	return runflags;
 }
+EXPORT_SYMBOL(comedi_get_subdevice_runflags);
 
 static int is_device_busy(struct comedi_device *dev)
 {
@@ -2152,6 +2157,7 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	}
 	return i;
 }
+EXPORT_SYMBOL_GPL(comedi_alloc_board_minor);
 
 void comedi_free_board_minor(unsigned minor)
 {
@@ -2177,6 +2183,7 @@ void comedi_free_board_minor(unsigned minor)
 		kfree(info);
 	}
 }
+EXPORT_SYMBOL_GPL(comedi_free_board_minor);
 
 int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 				 struct comedi_subdevice *s)
@@ -2286,6 +2293,7 @@ struct comedi_device_file_info *comedi_get_device_file_info(unsigned minor)
 	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 	return info;
 }
+EXPORT_SYMBOL_GPL(comedi_get_device_file_info);
 
 static int resize_async_buffer(struct comedi_device *dev,
 			       struct comedi_subdevice *s,

commit 3fffdf2045d0dbca3833f8f54ae41ce5f2c0b8fa
Author: Mark Rankilor <reodge@gmail.com>
Date:   Thu Apr 29 18:17:16 2010 +0800

    Staging: comedi: added log level to printk's in comedi_fops.c
    
    This patches comedi_fops.c to add kernel log level to some printk calls
    
    Signed-off-by: Mark Rankilor <reodge@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 287a1af3d013..1b3aed4ee60a 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -736,7 +736,8 @@ static int check_insn_config_length(struct comedi_insn *insn,
 		/* by default we allow the insn since we don't have checks for
 		 * all possible cases yet */
 	default:
-		printk("comedi: no check for data length of config insn id "
+		printk(KERN_WARNING
+		       "comedi: no check for data length of config insn id "
 		       "%i is implemented.\n"
 		       " Add a check to %s in %s.\n"
 		       " Assuming n=%i is correct.\n", data[0], __func__,
@@ -1925,7 +1926,7 @@ static int __init comedi_init(void)
 	}
 	comedi_class = class_create(THIS_MODULE, "comedi");
 	if (IS_ERR(comedi_class)) {
-		printk("comedi: failed to create class");
+		printk(KERN_ERR "comedi: failed to create class");
 		cdev_del(&comedi_cdev);
 		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 					 COMEDI_NUM_MINORS);
@@ -1971,7 +1972,8 @@ module_exit(comedi_cleanup);
 
 void comedi_error(const struct comedi_device *dev, const char *s)
 {
-	printk("comedi%d: %s: %s\n", dev->minor, dev->driver->driver_name, s);
+	printk(KERN_ERR "comedi%d: %s: %s\n", dev->minor,
+	       dev->driver->driver_name, s);
 }
 
 void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)

commit 20617f22b006e12b81602d80d85f8f3f7efdef45
Author: Pieter De Praetere <pieterc.depraetere@ugent.be>
Date:   Wed Mar 10 09:47:44 2010 +0100

    Staging: comedi: fix whitespace coding style issues in comedi_fops.c
    
    Solves warnings found by the checkpatch.pl tool: spaces before tabs.
    
    Signed-off-by: Pieter De Praetere <pieterc.depraetere@ugent.be>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index aca96747e5e2..287a1af3d013 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -598,19 +598,19 @@ static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg)
 static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 		      unsigned int *data, void *file);
 /*
- * 	COMEDI_INSNLIST
- * 	synchronous instructions
+ *	COMEDI_INSNLIST
+ *	synchronous instructions
  *
- * 	arg:
- * 		pointer to sync cmd structure
+ *	arg:
+ *		pointer to sync cmd structure
  *
- * 	reads:
- * 		sync cmd struct at arg
- * 		instruction list
- * 		data (for writes)
+ *	reads:
+ *		sync cmd struct at arg
+ *		instruction list
+ *		data (for writes)
  *
- * 	writes:
- * 		data (for reads)
+ *	writes:
+ *		data (for reads)
  */
 /* arbitrary limits */
 #define MAX_SAMPLES 256
@@ -894,18 +894,18 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
 }
 
 /*
- * 	COMEDI_INSN
- * 	synchronous instructions
+ *	COMEDI_INSN
+ *	synchronous instructions
  *
- * 	arg:
- * 		pointer to insn
+ *	arg:
+ *		pointer to insn
  *
- * 	reads:
- * 		struct comedi_insn struct at arg
- * 		data (for writes)
+ *	reads:
+ *		struct comedi_insn struct at arg
+ *		data (for writes)
  *
- * 	writes:
- * 		data (for reads)
+ *	writes:
+ *		data (for reads)
  */
 static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
@@ -2105,6 +2105,7 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 		kfree(info->device);
 		kfree(info);
 		printk(KERN_ERR
+
 		       "comedi: error: ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}

commit 6705b68d0be284e2f9949f3657ea65d426d0f988
Author: Andrea Gelmini <andrea.gelmini@gelma.net>
Date:   Fri Feb 26 10:14:55 2010 +0100

    Staging: comedi: comedi_fops.c: Checkpatch cleanup
    
    ERROR: do not initialise externals to 0 or NULL
    +int comedi_num_legacy_minors = 0;
    
    WARNING: braces {} are not necessary for single statement blocks
    +                       if (s->subdev_flags & SDF_CMD_READ) {
    +                               kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
    +                       }
    
    WARNING: braces {} are not necessary for single statement blocks
    +                       if (s->subdev_flags & SDF_CMD_WRITE) {
    +                               kill_fasync(&dev->async_queue, SIGIO, POLL_OUT);
    +                       }
    
    Signed-off-by: Andrea Gelmini <andrea.gelmini@gelma.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 8117748ad5a5..aca96747e5e2 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -63,7 +63,7 @@ module_param(comedi_debug, int, 0644);
 int comedi_autoconfig = 1;
 module_param(comedi_autoconfig, bool, 0444);
 
-int comedi_num_legacy_minors = 0;
+int comedi_num_legacy_minors;
 module_param(comedi_num_legacy_minors, int, 0444);
 
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
@@ -1510,7 +1510,7 @@ static unsigned int comedi_poll(struct file *file, poll_table * wait)
 }
 
 static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
-			    loff_t * offset)
+				loff_t *offset)
 {
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
@@ -1612,7 +1612,7 @@ static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
 }
 
 static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
-			   loff_t * offset)
+				loff_t *offset)
 {
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
@@ -2004,12 +2004,10 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (async->cb_mask & s->async->events) {
 		if (comedi_get_subdevice_runflags(s) & SRF_USER) {
 			wake_up_interruptible(&async->wait_head);
-			if (s->subdev_flags & SDF_CMD_READ) {
+			if (s->subdev_flags & SDF_CMD_READ)
 				kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
-			}
-			if (s->subdev_flags & SDF_CMD_WRITE) {
+			if (s->subdev_flags & SDF_CMD_WRITE)
 				kill_fasync(&dev->async_queue, SIGIO, POLL_OUT);
-			}
 		} else {
 			if (async->cb_func)
 				async->cb_func(s->async->events, async->cb_arg);

commit 5d7ae225540a98b6ee7ab1447c6a1eed89c219cd
Author: Shawn Bohrer <shawn.bohrer@gmail.com>
Date:   Sun Oct 18 15:32:16 2009 -0500

    Staging: comedi: remove check for HAVE_COMPAT_IOCTL
    
    All new kernels have support for compat_ioctl so remove the check and support
    for older kernels.
    
    Signed-off-by: Shawn Bohrer <shawn.bohrer@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a79b37f591ae..8117748ad5a5 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1863,9 +1863,7 @@ static int comedi_fasync(int fd, struct file *file, int on)
 const struct file_operations comedi_fops = {
 	.owner = THIS_MODULE,
 	.unlocked_ioctl = comedi_unlocked_ioctl,
-#ifdef HAVE_COMPAT_IOCTL
 	.compat_ioctl = comedi_compat_ioctl,
-#endif
 	.open = comedi_open,
 	.release = comedi_close,
 	.read = comedi_read,
@@ -1950,8 +1948,6 @@ static int __init comedi_init(void)
 		}
 	}
 
-	comedi_register_ioctl32();
-
 	return 0;
 }
 
@@ -1968,8 +1964,6 @@ static void __exit comedi_cleanup(void)
 	unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);
 
 	comedi_proc_cleanup();
-
-	comedi_unregister_ioctl32();
 }
 
 module_init(comedi_init);

commit 00a1855c21ab1efc71db98b0a87ea3d0ee7b8d92
Author: Shawn Bohrer <shawn.bohrer@gmail.com>
Date:   Sun Oct 18 15:32:15 2009 -0500

    staging: comedi: Remove check for HAVE_UNLOCKED_IOCTL
    
    All new kernels have unlocked_ioctl so we don't need to check.
    
    Signed-off-by: Shawn Bohrer <shawn.bohrer@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index aaad76e0a76a..a79b37f591ae 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -110,13 +110,8 @@ static struct device_attribute dev_attr_read_buffer_kb;
 static struct device_attribute dev_attr_max_write_buffer_kb;
 static struct device_attribute dev_attr_write_buffer_kb;
 
-#ifdef HAVE_UNLOCKED_IOCTL
 static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
 				  unsigned long arg)
-#else
-static int comedi_ioctl(struct inode *inode, struct file *file,
-			unsigned int cmd, unsigned long arg)
-#endif
 {
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_device_file_info *dev_file_info =
@@ -1867,11 +1862,7 @@ static int comedi_fasync(int fd, struct file *file, int on)
 
 const struct file_operations comedi_fops = {
 	.owner = THIS_MODULE,
-#ifdef HAVE_UNLOCKED_IOCTL
 	.unlocked_ioctl = comedi_unlocked_ioctl,
-#else
-	.ioctl = comedi_ioctl,
-#endif
 #ifdef HAVE_COMPAT_IOCTL
 	.compat_ioctl = comedi_compat_ioctl,
 #endif

commit b8b5cd9f87e08f72c78d9197bf199821fda4ba36
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 21 14:55:23 2009 -0400

    Staging: comedi: Corrected type of a printk argument in resize_async_buffer().
    
    Signed-off-by: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f54bb9b3ee37..aaad76e0a76a 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2337,7 +2337,7 @@ static int resize_async_buffer(struct comedi_device *dev,
 	}
 
 	DPRINTK("comedi%i subd %d buffer resized to %i bytes\n",
-		dev->minor, s - dev->subdevices, async->prealloc_bufsz);
+		dev->minor, (int)(s - dev->subdevices), async->prealloc_bufsz);
 	return 0;
 }
 

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 640f65c6ef84..f54bb9b3ee37 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -68,26 +68,33 @@ module_param(comedi_num_legacy_minors, int, 0444);
 
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info
-    *comedi_file_info_table[COMEDI_NUM_MINORS];
+*comedi_file_info_table[COMEDI_NUM_MINORS];
 
-static int do_devconfig_ioctl(struct comedi_device *dev, struct comedi_devconfig *arg);
+static int do_devconfig_ioctl(struct comedi_device *dev,
+			      struct comedi_devconfig *arg);
 static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg);
-static int do_devinfo_ioctl(struct comedi_device *dev, struct comedi_devinfo *arg,
-			    struct file *file);
-static int do_subdinfo_ioctl(struct comedi_device *dev, struct comedi_subdinfo *arg,
-			     void *file);
-static int do_chaninfo_ioctl(struct comedi_device *dev, struct comedi_chaninfo *arg);
+static int do_devinfo_ioctl(struct comedi_device *dev,
+			    struct comedi_devinfo *arg, struct file *file);
+static int do_subdinfo_ioctl(struct comedi_device *dev,
+			     struct comedi_subdinfo *arg, void *file);
+static int do_chaninfo_ioctl(struct comedi_device *dev,
+			     struct comedi_chaninfo *arg);
 static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg);
 static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file);
-static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg, void *file);
-static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg, void *file);
-static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg, void *file);
+static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,
+			 void *file);
+static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg,
+			   void *file);
+static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
+			   void *file);
 static int do_cmdtest_ioctl(struct comedi_device *dev, void *arg, void *file);
 static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file);
 static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file);
-static int do_poll_ioctl(struct comedi_device *dev, unsigned int subd, void *file);
+static int do_poll_ioctl(struct comedi_device *dev, unsigned int subd,
+			 void *file);
 
-extern void do_become_nonbusy(struct comedi_device *dev, struct comedi_subdevice *s);
+extern void do_become_nonbusy(struct comedi_device *dev,
+			      struct comedi_subdevice *s);
 static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static int comedi_fasync(int fd, struct file *file, int on);
@@ -202,7 +209,8 @@ static int comedi_ioctl(struct inode *inode, struct file *file,
 	writes:
 		none
 */
-static int do_devconfig_ioctl(struct comedi_device *dev, struct comedi_devconfig *arg)
+static int do_devconfig_ioctl(struct comedi_device *dev,
+			      struct comedi_devconfig *arg)
 {
 	struct comedi_devconfig it;
 	int ret;
@@ -342,8 +350,8 @@ static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg)
 		devinfo structure
 
 */
-static int do_devinfo_ioctl(struct comedi_device *dev, struct comedi_devinfo *arg,
-			    struct file *file)
+static int do_devinfo_ioctl(struct comedi_device *dev,
+			    struct comedi_devinfo *arg, struct file *file)
 {
 	struct comedi_devinfo devinfo;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
@@ -392,14 +400,16 @@ static int do_devinfo_ioctl(struct comedi_device *dev, struct comedi_devinfo *ar
 		array of subdevice info structures at arg
 
 */
-static int do_subdinfo_ioctl(struct comedi_device *dev, struct comedi_subdinfo *arg,
-			     void *file)
+static int do_subdinfo_ioctl(struct comedi_device *dev,
+			     struct comedi_subdinfo *arg, void *file)
 {
 	int ret, i;
 	struct comedi_subdinfo *tmp, *us;
 	struct comedi_subdevice *s;
 
-	tmp = kcalloc(dev->n_subdevices, sizeof(struct comedi_subdinfo), GFP_KERNEL);
+	tmp =
+	    kcalloc(dev->n_subdevices, sizeof(struct comedi_subdinfo),
+		    GFP_KERNEL);
 	if (!tmp)
 		return -ENOMEM;
 
@@ -472,7 +482,8 @@ static int do_subdinfo_ioctl(struct comedi_device *dev, struct comedi_subdinfo *
 		arrays at elements of chaninfo structure
 
 */
-static int do_chaninfo_ioctl(struct comedi_device *dev, struct comedi_chaninfo *arg)
+static int do_chaninfo_ioctl(struct comedi_device *dev,
+			     struct comedi_chaninfo *arg)
 {
 	struct comedi_subdevice *s;
 	struct comedi_chaninfo it;
@@ -514,7 +525,7 @@ static int do_chaninfo_ioctl(struct comedi_device *dev, struct comedi_chaninfo *
 		}
 #if 0
 		if (copy_to_user(it.rangelist, s->range_type_list,
-				 s->n_chan*sizeof(unsigned int)))
+				 s->n_chan * sizeof(unsigned int)))
 			return -EFAULT;
 #endif
 	}
@@ -589,8 +600,8 @@ static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg)
 	return 0;
 }
 
-static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn, unsigned int *data,
-		      void *file);
+static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
+		      unsigned int *data, void *file);
 /*
  * 	COMEDI_INSNLIST
  * 	synchronous instructions
@@ -626,7 +637,8 @@ static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file)
 		goto error;
 	}
 
-	insns = kmalloc(sizeof(struct comedi_insn) * insnlist.n_insns, GFP_KERNEL);
+	insns =
+	    kmalloc(sizeof(struct comedi_insn) * insnlist.n_insns, GFP_KERNEL);
 	if (!insns) {
 		DPRINTK("kmalloc failed\n");
 		ret = -ENOMEM;
@@ -678,7 +690,8 @@ static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file)
 	return i;
 }
 
-static int check_insn_config_length(struct comedi_insn *insn, unsigned int *data)
+static int check_insn_config_length(struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -725,22 +738,22 @@ static int check_insn_config_length(struct comedi_insn *insn, unsigned int *data
 		if (insn->n == 5)
 			return 0;
 		break;
-	/* by default we allow the insn since we don't have checks for
-	 * all possible cases yet */
+		/* by default we allow the insn since we don't have checks for
+		 * all possible cases yet */
 	default:
 		printk("comedi: no check for data length of config insn id "
-			  "%i is implemented.\n"
-			  " Add a check to %s in %s.\n"
-			  " Assuming n=%i is correct.\n", data[0], __func__,
-			  __FILE__, insn->n);
+		       "%i is implemented.\n"
+		       " Add a check to %s in %s.\n"
+		       " Assuming n=%i is correct.\n", data[0], __func__,
+		       __FILE__, insn->n);
 		return 0;
 		break;
 	}
 	return -EINVAL;
 }
 
-static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn, unsigned int *data,
-		      void *file)
+static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
+		      unsigned int *data, void *file)
 {
 	struct comedi_subdevice *s;
 	int ret = 0;
@@ -920,7 +933,8 @@ static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file)
 	if (insn.n > MAX_SAMPLES)
 		insn.n = MAX_SAMPLES;
 	if (insn.insn & INSN_MASK_WRITE) {
-		if (copy_from_user(data, insn.data, insn.n * sizeof(unsigned int))) {
+		if (copy_from_user
+		    (data, insn.data, insn.n * sizeof(unsigned int))) {
 			ret = -EFAULT;
 			goto error;
 		}
@@ -929,7 +943,8 @@ static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file)
 	if (ret < 0)
 		goto error;
 	if (insn.insn & INSN_MASK_READ) {
-		if (copy_to_user(insn.data, data, insn.n * sizeof(unsigned int))) {
+		if (copy_to_user
+		    (insn.data, data, insn.n * sizeof(unsigned int))) {
 			ret = -EFAULT;
 			goto error;
 		}
@@ -1202,7 +1217,8 @@ static int do_cmdtest_ioctl(struct comedi_device *dev, void *arg, void *file)
 
 */
 
-static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
+static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,
+			 void *file)
 {
 	int ret = 0;
 	unsigned long flags;
@@ -1246,7 +1262,8 @@ static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg, void *file
 	This function isn't protected by the semaphore, since
 	we already own the lock.
 */
-static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
+static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg,
+			   void *file)
 {
 	struct comedi_subdevice *s;
 
@@ -1286,7 +1303,8 @@ static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg, void *fi
 		nothing
 
 */
-static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
+static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
+			   void *file)
 {
 	struct comedi_subdevice *s;
 
@@ -1322,7 +1340,8 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg, void *fi
 		nothing
 
 */
-static int do_poll_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
+static int do_poll_ioctl(struct comedi_device *dev, unsigned int arg,
+			 void *file)
 {
 	struct comedi_subdevice *s;
 
@@ -1371,7 +1390,7 @@ void comedi_unmap(struct vm_area_struct *area)
 }
 
 static struct vm_operations_struct comedi_vm_ops = {
-	.close =	comedi_unmap,
+	.close = comedi_unmap,
 };
 
 static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
@@ -1428,10 +1447,10 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	n_pages = size >> PAGE_SHIFT;
 	for (i = 0; i < n_pages; ++i) {
 		if (remap_pfn_range(vma, start,
-				    page_to_pfn(virt_to_page(async->
-							     buf_page_list[i].
-							     virt_addr)),
-				    PAGE_SIZE, PAGE_SHARED)) {
+				    page_to_pfn(virt_to_page
+						(async->buf_page_list
+						 [i].virt_addr)), PAGE_SIZE,
+				    PAGE_SHARED)) {
 			retval = -EAGAIN;
 			goto done;
 		}
@@ -1449,7 +1468,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	return retval;
 }
 
-static unsigned int comedi_poll(struct file *file, poll_table *wait)
+static unsigned int comedi_poll(struct file *file, poll_table * wait)
 {
 	unsigned int mask = 0;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
@@ -1496,7 +1515,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 }
 
 static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
-			    loff_t *offset)
+			    loff_t * offset)
 {
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
@@ -1598,7 +1617,7 @@ static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
 }
 
 static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
-			   loff_t *offset)
+			   loff_t * offset)
 {
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
@@ -1729,7 +1748,8 @@ static int comedi_open(struct inode *inode, struct file *file)
 	const unsigned minor = iminor(inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
-	struct comedi_device *dev = dev_file_info ? dev_file_info->device : NULL;
+	struct comedi_device *dev =
+	    dev_file_info ? dev_file_info->device : NULL;
 
 	if (dev == NULL) {
 		DPRINTK("invalid minor number\n");
@@ -1846,22 +1866,22 @@ static int comedi_fasync(int fd, struct file *file, int on)
 }
 
 const struct file_operations comedi_fops = {
-      .owner =		THIS_MODULE,
+	.owner = THIS_MODULE,
 #ifdef HAVE_UNLOCKED_IOCTL
-      .unlocked_ioctl =	comedi_unlocked_ioctl,
+	.unlocked_ioctl = comedi_unlocked_ioctl,
 #else
-      .ioctl =		comedi_ioctl,
+	.ioctl = comedi_ioctl,
 #endif
 #ifdef HAVE_COMPAT_IOCTL
-      .compat_ioctl =	comedi_compat_ioctl,
+	.compat_ioctl = comedi_compat_ioctl,
 #endif
-      .open =		comedi_open,
-      .release =	comedi_close,
-      .read =		comedi_read,
-      .write =		comedi_write,
-      .mmap =		comedi_mmap,
-      .poll =		comedi_poll,
-      .fasync =		comedi_fasync,
+	.open = comedi_open,
+	.release = comedi_close,
+	.read = comedi_read,
+	.write = comedi_write,
+	.mmap = comedi_mmap,
+	.poll = comedi_poll,
+	.fasync = comedi_fasync,
 };
 
 struct class *comedi_class;
@@ -1952,7 +1972,6 @@ static void __exit comedi_cleanup(void)
 	for (i = 0; i < COMEDI_NUM_MINORS; ++i)
 		BUG_ON(comedi_file_info_table[i]);
 
-
 	class_destroy(comedi_class);
 	cdev_del(&comedi_cdev);
 	unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);
@@ -1981,8 +2000,9 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 	if ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) == 0)
 		return;
 
-	if (s->async->
-	    events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {
+	if (s->
+	    async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
+			     COMEDI_CB_OVERFLOW)) {
 		runflags_mask |= SRF_RUNNING;
 	}
 	/* remember if an error event has occured, so an error
@@ -2000,12 +2020,10 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 		if (comedi_get_subdevice_runflags(s) & SRF_USER) {
 			wake_up_interruptible(&async->wait_head);
 			if (s->subdev_flags & SDF_CMD_READ) {
-				kill_fasync(&dev->async_queue, SIGIO,
-					    POLL_IN);
+				kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
 			}
 			if (s->subdev_flags & SDF_CMD_WRITE) {
-				kill_fasync(&dev->async_queue, SIGIO,
-					    POLL_OUT);
+				kill_fasync(&dev->async_queue, SIGIO, POLL_OUT);
 			}
 		} else {
 			if (async->cb_func)
@@ -2103,7 +2121,8 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 		comedi_device_cleanup(info->device);
 		kfree(info->device);
 		kfree(info);
-		printk(KERN_ERR "comedi: error: ran out of minor numbers for board device files.\n");
+		printk(KERN_ERR
+		       "comedi: error: ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}
 	info->device->minor = i;
@@ -2115,29 +2134,33 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	dev_set_drvdata(csdev, info);
 	retval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_max_read_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_max_read_buffer_kb.attr.name);
 		comedi_free_board_minor(i);
 		return retval;
 	}
 	retval = device_create_file(csdev, &dev_attr_read_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_read_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_read_buffer_kb.attr.name);
 		comedi_free_board_minor(i);
 		return retval;
 	}
 	retval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_max_write_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_max_write_buffer_kb.attr.name);
 		comedi_free_board_minor(i);
 		return retval;
 	}
 	retval = device_create_file(csdev, &dev_attr_write_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_write_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_write_buffer_kb.attr.name);
 		comedi_free_board_minor(i);
 		return retval;
 	}
@@ -2194,7 +2217,8 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 	if (i == COMEDI_NUM_MINORS) {
 		kfree(info);
-		printk(KERN_ERR "comedi: error: ran out of minor numbers for board device files.\n");
+		printk(KERN_ERR
+		       "comedi: error: ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}
 	s->minor = i;
@@ -2207,29 +2231,33 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	dev_set_drvdata(csdev, info);
 	retval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_max_read_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_max_read_buffer_kb.attr.name);
 		comedi_free_subdevice_minor(s);
 		return retval;
 	}
 	retval = device_create_file(csdev, &dev_attr_read_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_read_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_read_buffer_kb.attr.name);
 		comedi_free_subdevice_minor(s);
 		return retval;
 	}
 	retval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_max_write_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_max_write_buffer_kb.attr.name);
 		comedi_free_subdevice_minor(s);
 		return retval;
 	}
 	retval = device_create_file(csdev, &dev_attr_write_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_write_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_write_buffer_kb.attr.name);
 		comedi_free_subdevice_minor(s);
 		return retval;
 	}
@@ -2295,7 +2323,7 @@ static int resize_async_buffer(struct comedi_device *dev,
 		return -EINVAL;
 
 	/* make sure buffer is an integral number of pages
-		* (we round up) */
+	 * (we round up) */
 	new_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;
 
 	retval = comedi_buf_alloc(dev, s, new_size);
@@ -2324,16 +2352,16 @@ static ssize_t show_max_read_buffer_kb(struct device *dev,
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
 	unsigned max_buffer_size_kb = 0;
 	struct comedi_subdevice *const read_subdevice =
-					comedi_get_read_subdevice(info);
+	    comedi_get_read_subdevice(info);
 
 	mutex_lock(&info->device->mutex);
 	if (read_subdevice &&
 	    (read_subdevice->subdev_flags & SDF_CMD_READ) &&
 	    read_subdevice->async) {
 		max_buffer_size_kb = read_subdevice->async->max_bufsize /
-					bytes_per_kibi;
+		    bytes_per_kibi;
 	}
-	retval =  snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
+	retval = snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
 	mutex_unlock(&info->device->mutex);
 
 	return retval;
@@ -2347,14 +2375,14 @@ static ssize_t store_max_read_buffer_kb(struct device *dev,
 	unsigned long new_max_size_kb;
 	uint64_t new_max_size;
 	struct comedi_subdevice *const read_subdevice =
-					comedi_get_read_subdevice(info);
+	    comedi_get_read_subdevice(info);
 
 	if (strict_strtoul(buf, 10, &new_max_size_kb))
 		return -EINVAL;
-	if (new_max_size_kb != (uint32_t)new_max_size_kb)
+	if (new_max_size_kb != (uint32_t) new_max_size_kb)
 		return -EINVAL;
-	new_max_size = ((uint64_t)new_max_size_kb) * bytes_per_kibi;
-	if (new_max_size != (uint32_t)new_max_size)
+	new_max_size = ((uint64_t) new_max_size_kb) * bytes_per_kibi;
+	if (new_max_size != (uint32_t) new_max_size)
 		return -EINVAL;
 
 	mutex_lock(&info->device->mutex);
@@ -2372,9 +2400,8 @@ static ssize_t store_max_read_buffer_kb(struct device *dev,
 
 static struct device_attribute dev_attr_max_read_buffer_kb = {
 	.attr = {
-			.name = "max_read_buffer_kb",
-			.mode = S_IRUGO | S_IWUSR
-		},
+		 .name = "max_read_buffer_kb",
+		 .mode = S_IRUGO | S_IWUSR},
 	.show = &show_max_read_buffer_kb,
 	.store = &store_max_read_buffer_kb
 };
@@ -2386,16 +2413,16 @@ static ssize_t show_read_buffer_kb(struct device *dev,
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
 	unsigned buffer_size_kb = 0;
 	struct comedi_subdevice *const read_subdevice =
-					comedi_get_read_subdevice(info);
+	    comedi_get_read_subdevice(info);
 
 	mutex_lock(&info->device->mutex);
 	if (read_subdevice &&
-		(read_subdevice->subdev_flags & SDF_CMD_READ) &&
-		read_subdevice->async) {
+	    (read_subdevice->subdev_flags & SDF_CMD_READ) &&
+	    read_subdevice->async) {
 		buffer_size_kb = read_subdevice->async->prealloc_bufsz /
-					bytes_per_kibi;
+		    bytes_per_kibi;
 	}
-	retval =  snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
+	retval = snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
 	mutex_unlock(&info->device->mutex);
 
 	return retval;
@@ -2410,14 +2437,14 @@ static ssize_t store_read_buffer_kb(struct device *dev,
 	uint64_t new_size;
 	int retval;
 	struct comedi_subdevice *const read_subdevice =
-					comedi_get_read_subdevice(info);
+	    comedi_get_read_subdevice(info);
 
 	if (strict_strtoul(buf, 10, &new_size_kb))
 		return -EINVAL;
-	if (new_size_kb != (uint32_t)new_size_kb)
+	if (new_size_kb != (uint32_t) new_size_kb)
 		return -EINVAL;
-	new_size = ((uint64_t)new_size_kb) * bytes_per_kibi;
-	if (new_size != (uint32_t)new_size)
+	new_size = ((uint64_t) new_size_kb) * bytes_per_kibi;
+	if (new_size != (uint32_t) new_size)
 		return -EINVAL;
 
 	mutex_lock(&info->device->mutex);
@@ -2438,9 +2465,8 @@ static ssize_t store_read_buffer_kb(struct device *dev,
 
 static struct device_attribute dev_attr_read_buffer_kb = {
 	.attr = {
-			.name = "read_buffer_kb",
-			.mode = S_IRUGO | S_IWUSR | S_IWGRP
-		},
+		 .name = "read_buffer_kb",
+		 .mode = S_IRUGO | S_IWUSR | S_IWGRP},
 	.show = &show_read_buffer_kb,
 	.store = &store_read_buffer_kb
 };
@@ -2453,16 +2479,16 @@ static ssize_t show_max_write_buffer_kb(struct device *dev,
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
 	unsigned max_buffer_size_kb = 0;
 	struct comedi_subdevice *const write_subdevice =
-					comedi_get_write_subdevice(info);
+	    comedi_get_write_subdevice(info);
 
 	mutex_lock(&info->device->mutex);
 	if (write_subdevice &&
 	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) &&
 	    write_subdevice->async) {
 		max_buffer_size_kb = write_subdevice->async->max_bufsize /
-					bytes_per_kibi;
+		    bytes_per_kibi;
 	}
-	retval =  snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
+	retval = snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
 	mutex_unlock(&info->device->mutex);
 
 	return retval;
@@ -2476,14 +2502,14 @@ static ssize_t store_max_write_buffer_kb(struct device *dev,
 	unsigned long new_max_size_kb;
 	uint64_t new_max_size;
 	struct comedi_subdevice *const write_subdevice =
-					comedi_get_write_subdevice(info);
+	    comedi_get_write_subdevice(info);
 
 	if (strict_strtoul(buf, 10, &new_max_size_kb))
 		return -EINVAL;
-	if (new_max_size_kb != (uint32_t)new_max_size_kb)
+	if (new_max_size_kb != (uint32_t) new_max_size_kb)
 		return -EINVAL;
-	new_max_size = ((uint64_t)new_max_size_kb) * bytes_per_kibi;
-	if (new_max_size != (uint32_t)new_max_size)
+	new_max_size = ((uint64_t) new_max_size_kb) * bytes_per_kibi;
+	if (new_max_size != (uint32_t) new_max_size)
 		return -EINVAL;
 
 	mutex_lock(&info->device->mutex);
@@ -2501,9 +2527,8 @@ static ssize_t store_max_write_buffer_kb(struct device *dev,
 
 static struct device_attribute dev_attr_max_write_buffer_kb = {
 	.attr = {
-			.name = "max_write_buffer_kb",
-			.mode = S_IRUGO | S_IWUSR
-		},
+		 .name = "max_write_buffer_kb",
+		 .mode = S_IRUGO | S_IWUSR},
 	.show = &show_max_write_buffer_kb,
 	.store = &store_max_write_buffer_kb
 };
@@ -2515,16 +2540,16 @@ static ssize_t show_write_buffer_kb(struct device *dev,
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
 	unsigned buffer_size_kb = 0;
 	struct comedi_subdevice *const write_subdevice =
-					comedi_get_write_subdevice(info);
+	    comedi_get_write_subdevice(info);
 
 	mutex_lock(&info->device->mutex);
 	if (write_subdevice &&
 	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) &&
 	    write_subdevice->async) {
 		buffer_size_kb = write_subdevice->async->prealloc_bufsz /
-					bytes_per_kibi;
+		    bytes_per_kibi;
 	}
-	retval =  snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
+	retval = snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
 	mutex_unlock(&info->device->mutex);
 
 	return retval;
@@ -2539,14 +2564,14 @@ static ssize_t store_write_buffer_kb(struct device *dev,
 	uint64_t new_size;
 	int retval;
 	struct comedi_subdevice *const write_subdevice =
-					comedi_get_write_subdevice(info);
+	    comedi_get_write_subdevice(info);
 
 	if (strict_strtoul(buf, 10, &new_size_kb))
 		return -EINVAL;
-	if (new_size_kb != (uint32_t)new_size_kb)
+	if (new_size_kb != (uint32_t) new_size_kb)
 		return -EINVAL;
-	new_size = ((uint64_t)new_size_kb) * bytes_per_kibi;
-	if (new_size != (uint32_t)new_size)
+	new_size = ((uint64_t) new_size_kb) * bytes_per_kibi;
+	if (new_size != (uint32_t) new_size)
 		return -EINVAL;
 
 	mutex_lock(&info->device->mutex);
@@ -2557,7 +2582,7 @@ static ssize_t store_write_buffer_kb(struct device *dev,
 		return -EINVAL;
 	}
 	retval = resize_async_buffer(info->device, write_subdevice,
-		write_subdevice->async, new_size);
+				     write_subdevice->async, new_size);
 	mutex_unlock(&info->device->mutex);
 
 	if (retval < 0)
@@ -2567,9 +2592,8 @@ static ssize_t store_write_buffer_kb(struct device *dev,
 
 static struct device_attribute dev_attr_write_buffer_kb = {
 	.attr = {
-			.name = "write_buffer_kb",
-			.mode = S_IRUGO | S_IWUSR | S_IWGRP
-		},
+		 .name = "write_buffer_kb",
+		 .mode = S_IRUGO | S_IWUSR | S_IWGRP},
 	.show = &show_write_buffer_kb,
 	.store = &store_write_buffer_kb
 };

commit a8f80e8ff94ecba629542d9b4b5f5a8ee3eb565c
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Aug 13 09:44:51 2009 -0400

    Networking: use CAP_NET_ADMIN when deciding to call request_module
    
    The networking code checks CAP_SYS_MODULE before using request_module() to
    try to load a kernel module.  While this seems reasonable it's actually
    weakening system security since we have to allow CAP_SYS_MODULE for things
    like /sbin/ip and bluetoothd which need to be able to trigger module loads.
    CAP_SYS_MODULE actually grants those binaries the ability to directly load
    any code into the kernel.  We should instead be protecting modprobe and the
    modules on disk, rather than granting random programs the ability to load code
    directly into the kernel.  Instead we are going to gate those networking checks
    on CAP_NET_ADMIN which still limits them to root but which does not grant
    those processes the ability to load arbitrary code into the kernel.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Acked-by: Paul Moore <paul.moore@hp.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 9d7c99394ec6..640f65c6ef84 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1752,12 +1752,12 @@ static int comedi_open(struct inode *inode, struct file *file)
 	mutex_lock(&dev->mutex);
 	if (dev->attached)
 		goto ok;
-	if (!capable(CAP_SYS_MODULE) && dev->in_request_module) {
+	if (!capable(CAP_NET_ADMIN) && dev->in_request_module) {
 		DPRINTK("in request module\n");
 		mutex_unlock(&dev->mutex);
 		return -ENODEV;
 	}
-	if (capable(CAP_SYS_MODULE) && dev->in_request_module)
+	if (capable(CAP_NET_ADMIN) && dev->in_request_module)
 		goto ok;
 
 	dev->in_request_module = 1;
@@ -1770,8 +1770,8 @@ static int comedi_open(struct inode *inode, struct file *file)
 
 	dev->in_request_module = 0;
 
-	if (!dev->attached && !capable(CAP_SYS_MODULE)) {
-		DPRINTK("not attached and not CAP_SYS_MODULE\n");
+	if (!dev->attached && !capable(CAP_NET_ADMIN)) {
+		DPRINTK("not attached and not CAP_NET_ADMIN\n");
 		mutex_unlock(&dev->mutex);
 		return -ENODEV;
 	}

commit fcea115462c690ba09f9df7471d60dda0d86a4ea
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:15:30 2009 -0700

    Staging: comedi: remove some RT code that lingered
    
    This removes some pieces of RT code that was part of the main code
    paths.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 61b586477c10..9d7c99394ec6 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1998,27 +1998,18 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (async->cb_mask & s->async->events) {
 		if (comedi_get_subdevice_runflags(s) & SRF_USER) {
-			if (dev->rt) {
-				printk("BUG: comedi_event() code unreachable\n");
-			} else {
-				wake_up_interruptible(&async->wait_head);
-				if (s->subdev_flags & SDF_CMD_READ) {
-					kill_fasync(&dev->async_queue, SIGIO,
-						    POLL_IN);
-				}
-				if (s->subdev_flags & SDF_CMD_WRITE) {
-					kill_fasync(&dev->async_queue, SIGIO,
-						    POLL_OUT);
-				}
+			wake_up_interruptible(&async->wait_head);
+			if (s->subdev_flags & SDF_CMD_READ) {
+				kill_fasync(&dev->async_queue, SIGIO,
+					    POLL_IN);
+			}
+			if (s->subdev_flags & SDF_CMD_WRITE) {
+				kill_fasync(&dev->async_queue, SIGIO,
+					    POLL_OUT);
 			}
 		} else {
 			if (async->cb_func)
 				async->cb_func(s->async->events, async->cb_arg);
-			/* XXX bug here.  If subdevice A is rt, and
-			 * subdevice B tries to callback to a normal
-			 * linux kernel function, it will be at the
-			 * wrong priority.  Since this isn't very
-			 * common, I'm not going to worry about it. */
 		}
 	}
 	s->async->events = 0;

commit 25436dc9d84f1be60ff549c9ab712bba2835f284
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:14:34 2009 -0700

    Staging: comedi: remove RT code
    
    This removes the unused RT code from the comedi subsystem.
    
    A lot of drivers needed to then include interrupt.h on their own, as they
    were picking it up through the comedi_rt.h inclusion.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 9713fc746561..61b586477c10 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1079,13 +1079,6 @@ static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file)
 
 	comedi_set_subdevice_runflags(s, ~0, SRF_USER | SRF_RUNNING);
 
-#ifdef CONFIG_COMEDI_RT
-	if (async->cmd.flags & TRIG_RT) {
-		if (comedi_switch_to_rt(dev) == 0)
-			comedi_set_subdevice_runflags(s, SRF_RT, SRF_RT);
-	}
-#endif
-
 	ret = s->do_cmd(dev, s);
 	if (ret == 0)
 		return 0;
@@ -1720,12 +1713,6 @@ void do_become_nonbusy(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_async *async = s->async;
 
 	comedi_set_subdevice_runflags(s, SRF_RUNNING, 0);
-#ifdef CONFIG_COMEDI_RT
-	if (comedi_get_subdevice_runflags(s) & SRF_RT) {
-		comedi_switch_to_non_rt(dev);
-		comedi_set_subdevice_runflags(s, SRF_RT, 0);
-	}
-#endif
 	if (async) {
 		comedi_reset_async_buf(async);
 		async->inttrig = NULL;
@@ -1952,8 +1939,6 @@ static int __init comedi_init(void)
 		}
 	}
 
-	comedi_rt_init();
-
 	comedi_register_ioctl32();
 
 	return 0;
@@ -1974,8 +1959,6 @@ static void __exit comedi_cleanup(void)
 
 	comedi_proc_cleanup();
 
-	comedi_rt_cleanup();
-
 	comedi_unregister_ioctl32();
 }
 
@@ -2015,15 +1998,8 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (async->cb_mask & s->async->events) {
 		if (comedi_get_subdevice_runflags(s) & SRF_USER) {
-
 			if (dev->rt) {
-#ifdef CONFIG_COMEDI_RT
-				/* pend wake up */
-				comedi_rt_pend_wakeup(&async->wait_head);
-#else
-				printk
-				    ("BUG: comedi_event() code unreachable\n");
-#endif
+				printk("BUG: comedi_event() code unreachable\n");
 			} else {
 				wake_up_interruptible(&async->wait_head);
 				if (s->subdev_flags & SDF_CMD_READ) {

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index bb4a2897feae..9713fc746561 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -728,7 +728,7 @@ static int check_insn_config_length(struct comedi_insn *insn, unsigned int *data
 	/* by default we allow the insn since we don't have checks for
 	 * all possible cases yet */
 	default:
-		rt_printk("comedi: no check for data length of config insn id "
+		printk("comedi: no check for data length of config insn id "
 			  "%i is implemented.\n"
 			  " Add a check to %s in %s.\n"
 			  " Assuming n=%i is correct.\n", data[0], __func__,
@@ -1219,12 +1219,12 @@ static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg, void *file
 		return -EINVAL;
 	s = dev->subdevices + arg;
 
-	comedi_spin_lock_irqsave(&s->spin_lock, flags);
+	spin_lock_irqsave(&s->spin_lock, flags);
 	if (s->busy || s->lock)
 		ret = -EBUSY;
 	else
 		s->lock = file;
-	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
+	spin_unlock_irqrestore(&s->spin_lock, flags);
 
 	if (ret < 0)
 		return ret;
@@ -1984,8 +1984,7 @@ module_exit(comedi_cleanup);
 
 void comedi_error(const struct comedi_device *dev, const char *s)
 {
-	rt_printk("comedi%d: %s: %s\n", dev->minor, dev->driver->driver_name,
-		  s);
+	printk("comedi%d: %s: %s\n", dev->minor, dev->driver->driver_name, s);
 }
 
 void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -2054,10 +2053,10 @@ void comedi_set_subdevice_runflags(struct comedi_subdevice *s, unsigned mask,
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&s->spin_lock, flags);
+	spin_lock_irqsave(&s->spin_lock, flags);
 	s->runflags &= ~mask;
 	s->runflags |= (bits & mask);
-	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
+	spin_unlock_irqrestore(&s->spin_lock, flags);
 }
 
 unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
@@ -2065,9 +2064,9 @@ unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 	unsigned long flags;
 	unsigned runflags;
 
-	comedi_spin_lock_irqsave(&s->spin_lock, flags);
+	spin_lock_irqsave(&s->spin_lock, flags);
 	runflags = s->runflags;
-	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
+	spin_unlock_irqrestore(&s->spin_lock, flags);
 	return runflags;
 }
 
@@ -2125,14 +2124,14 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 		return -ENOMEM;
 	}
 	comedi_device_init(info->device);
-	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
 			comedi_file_info_table[i] = info;
 			break;
 		}
 	}
-	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 	if (i == COMEDI_NUM_BOARD_MINORS) {
 		comedi_device_cleanup(info->device);
 		kfree(info->device);
@@ -2184,10 +2183,10 @@ void comedi_free_board_minor(unsigned minor)
 	struct comedi_device_file_info *info;
 
 	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
-	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
 	info = comedi_file_info_table[minor];
 	comedi_file_info_table[minor] = NULL;
-	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 
 	if (info) {
 		struct comedi_device *dev = info->device;
@@ -2218,14 +2217,14 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev,
 	info->device = dev;
 	info->read_subdevice = s;
 	info->write_subdevice = s;
-	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
 	for (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
 			comedi_file_info_table[i] = info;
 			break;
 		}
 	}
-	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 	if (i == COMEDI_NUM_MINORS) {
 		kfree(info);
 		printk(KERN_ERR "comedi: error: ran out of minor numbers for board device files.\n");
@@ -2283,10 +2282,10 @@ void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 	BUG_ON(s->minor >= COMEDI_NUM_MINORS);
 	BUG_ON(s->minor < COMEDI_FIRST_SUBDEVICE_MINOR);
 
-	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
 	info = comedi_file_info_table[s->minor];
 	comedi_file_info_table[s->minor] = NULL;
-	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 
 	if (s->class_dev) {
 		device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, s->minor));
@@ -2301,9 +2300,9 @@ struct comedi_device_file_info *comedi_get_device_file_info(unsigned minor)
 	struct comedi_device_file_info *info;
 
 	BUG_ON(minor >= COMEDI_NUM_MINORS);
-	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
 	info = comedi_file_info_table[minor];
-	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 	return info;
 }
 

commit 883db3d9bb4d50f05cbb8b5197f6aef10c1231a9
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Tue Apr 14 11:21:41 2009 -0400

    Staging: comedi: Added sysfs attribute files for setting and querying subdevice buffer sizes.
    
    Signed-off-by: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 19dce2ebfc19..bb4a2897feae 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -44,6 +44,7 @@
 #include <linux/fs.h>
 #include "comedidev.h"
 #include <linux/cdev.h>
+#include <linux/stat.h>
 
 #include <linux/io.h>
 #include <linux/uaccess.h>
@@ -92,6 +93,15 @@ static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int comedi_fasync(int fd, struct file *file, int on);
 
 static int is_device_busy(struct comedi_device *dev);
+static int resize_async_buffer(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_async *async, unsigned new_size);
+
+/* declarations for sysfs attribute files */
+static struct device_attribute dev_attr_max_read_buffer_kb;
+static struct device_attribute dev_attr_read_buffer_kb;
+static struct device_attribute dev_attr_max_write_buffer_kb;
+static struct device_attribute dev_attr_write_buffer_kb;
 
 #ifdef HAVE_UNLOCKED_IOCTL
 static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
@@ -277,7 +287,7 @@ static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg)
 	struct comedi_bufconfig bc;
 	struct comedi_async *async;
 	struct comedi_subdevice *s;
-	int ret = 0;
+	int retval = 0;
 
 	if (copy_from_user(&bc, arg, sizeof(struct comedi_bufconfig)))
 		return -EFAULT;
@@ -303,37 +313,9 @@ static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg)
 	}
 
 	if (bc.size) {
-		if (bc.size > async->max_bufsize)
-			return -EPERM;
-
-		if (s->busy) {
-			DPRINTK("subdevice is busy, cannot resize buffer\n");
-			return -EBUSY;
-		}
-		if (async->mmap_count) {
-			DPRINTK("subdevice is mmapped, cannot resize buffer\n");
-			return -EBUSY;
-		}
-
-		if (!async->prealloc_buf)
-			return -EINVAL;
-
-		/* make sure buffer is an integral number of pages
-		 * (we round up) */
-		bc.size = (bc.size + PAGE_SIZE - 1) & PAGE_MASK;
-
-		ret = comedi_buf_alloc(dev, s, bc.size);
-		if (ret < 0)
-			return ret;
-
-		if (s->buf_change) {
-			ret = s->buf_change(dev, s, bc.size);
-			if (ret < 0)
-				return ret;
-		}
-
-		DPRINTK("comedi%i subd %d buffer resized to %i bytes\n",
-			dev->minor, bc.subdevice, async->prealloc_bufsz);
+		retval = resize_async_buffer(dev, s, async, bc.size);
+		if (retval < 0)
+			return retval;
 	}
 
 	bc.size = async->prealloc_bufsz;
@@ -2132,6 +2114,7 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	struct comedi_device_file_info *info;
 	struct device *csdev;
 	unsigned i;
+	int retval;
 
 	info = kzalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
 	if (info == NULL)
@@ -2154,8 +2137,7 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 		comedi_device_cleanup(info->device);
 		kfree(info->device);
 		kfree(info);
-		rt_printk
-		    ("comedi: error: ran out of minor numbers for board device files.\n");
+		printk(KERN_ERR "comedi: error: ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}
 	info->device->minor = i;
@@ -2164,7 +2146,35 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 				     hardware_device, "comedi%i", i);
 	if (!IS_ERR(csdev))
 		info->device->class_dev = csdev;
-
+	dev_set_drvdata(csdev, info);
+	retval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);
+	if (retval) {
+		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
+			dev_attr_max_read_buffer_kb.attr.name);
+		comedi_free_board_minor(i);
+		return retval;
+	}
+	retval = device_create_file(csdev, &dev_attr_read_buffer_kb);
+	if (retval) {
+		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
+			dev_attr_read_buffer_kb.attr.name);
+		comedi_free_board_minor(i);
+		return retval;
+	}
+	retval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);
+	if (retval) {
+		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
+			dev_attr_max_write_buffer_kb.attr.name);
+		comedi_free_board_minor(i);
+		return retval;
+	}
+	retval = device_create_file(csdev, &dev_attr_write_buffer_kb);
+	if (retval) {
+		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
+			dev_attr_write_buffer_kb.attr.name);
+		comedi_free_board_minor(i);
+		return retval;
+	}
 	return i;
 }
 
@@ -2193,12 +2203,14 @@ void comedi_free_board_minor(unsigned minor)
 	}
 }
 
-int comedi_alloc_subdevice_minor(struct comedi_device *dev, struct comedi_subdevice *s)
+int comedi_alloc_subdevice_minor(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
 {
 	unsigned long flags;
 	struct comedi_device_file_info *info;
 	struct device *csdev;
 	unsigned i;
+	int retval;
 
 	info = kmalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
 	if (info == NULL)
@@ -2216,8 +2228,7 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev, struct comedi_subdev
 	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 	if (i == COMEDI_NUM_MINORS) {
 		kfree(info);
-		rt_printk
-		    ("comedi: error: ran out of minor numbers for board device files.\n");
+		printk(KERN_ERR "comedi: error: ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}
 	s->minor = i;
@@ -2227,7 +2238,35 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev, struct comedi_subdev
 				     (int)(s - dev->subdevices));
 	if (!IS_ERR(csdev))
 		s->class_dev = csdev;
-
+	dev_set_drvdata(csdev, info);
+	retval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);
+	if (retval) {
+		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
+			dev_attr_max_read_buffer_kb.attr.name);
+		comedi_free_subdevice_minor(s);
+		return retval;
+	}
+	retval = device_create_file(csdev, &dev_attr_read_buffer_kb);
+	if (retval) {
+		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
+			dev_attr_read_buffer_kb.attr.name);
+		comedi_free_subdevice_minor(s);
+		return retval;
+	}
+	retval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);
+	if (retval) {
+		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
+			dev_attr_max_write_buffer_kb.attr.name);
+		comedi_free_subdevice_minor(s);
+		return retval;
+	}
+	retval = device_create_file(csdev, &dev_attr_write_buffer_kb);
+	if (retval) {
+		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
+			dev_attr_write_buffer_kb.attr.name);
+		comedi_free_subdevice_minor(s);
+		return retval;
+	}
 	return i;
 }
 
@@ -2267,3 +2306,304 @@ struct comedi_device_file_info *comedi_get_device_file_info(unsigned minor)
 	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 	return info;
 }
+
+static int resize_async_buffer(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_async *async, unsigned new_size)
+{
+	int retval;
+
+	if (new_size > async->max_bufsize)
+		return -EPERM;
+
+	if (s->busy) {
+		DPRINTK("subdevice is busy, cannot resize buffer\n");
+		return -EBUSY;
+	}
+	if (async->mmap_count) {
+		DPRINTK("subdevice is mmapped, cannot resize buffer\n");
+		return -EBUSY;
+	}
+
+	if (!async->prealloc_buf)
+		return -EINVAL;
+
+	/* make sure buffer is an integral number of pages
+		* (we round up) */
+	new_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;
+
+	retval = comedi_buf_alloc(dev, s, new_size);
+	if (retval < 0)
+		return retval;
+
+	if (s->buf_change) {
+		retval = s->buf_change(dev, s, new_size);
+		if (retval < 0)
+			return retval;
+	}
+
+	DPRINTK("comedi%i subd %d buffer resized to %i bytes\n",
+		dev->minor, s - dev->subdevices, async->prealloc_bufsz);
+	return 0;
+}
+
+/* sysfs attribute files */
+
+static const unsigned bytes_per_kibi = 1024;
+
+static ssize_t show_max_read_buffer_kb(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	ssize_t retval;
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned max_buffer_size_kb = 0;
+	struct comedi_subdevice *const read_subdevice =
+					comedi_get_read_subdevice(info);
+
+	mutex_lock(&info->device->mutex);
+	if (read_subdevice &&
+	    (read_subdevice->subdev_flags & SDF_CMD_READ) &&
+	    read_subdevice->async) {
+		max_buffer_size_kb = read_subdevice->async->max_bufsize /
+					bytes_per_kibi;
+	}
+	retval =  snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
+	mutex_unlock(&info->device->mutex);
+
+	return retval;
+}
+
+static ssize_t store_max_read_buffer_kb(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned long new_max_size_kb;
+	uint64_t new_max_size;
+	struct comedi_subdevice *const read_subdevice =
+					comedi_get_read_subdevice(info);
+
+	if (strict_strtoul(buf, 10, &new_max_size_kb))
+		return -EINVAL;
+	if (new_max_size_kb != (uint32_t)new_max_size_kb)
+		return -EINVAL;
+	new_max_size = ((uint64_t)new_max_size_kb) * bytes_per_kibi;
+	if (new_max_size != (uint32_t)new_max_size)
+		return -EINVAL;
+
+	mutex_lock(&info->device->mutex);
+	if (read_subdevice == NULL ||
+	    (read_subdevice->subdev_flags & SDF_CMD_READ) == 0 ||
+	    read_subdevice->async == NULL) {
+		mutex_unlock(&info->device->mutex);
+		return -EINVAL;
+	}
+	read_subdevice->async->max_bufsize = new_max_size;
+	mutex_unlock(&info->device->mutex);
+
+	return count;
+}
+
+static struct device_attribute dev_attr_max_read_buffer_kb = {
+	.attr = {
+			.name = "max_read_buffer_kb",
+			.mode = S_IRUGO | S_IWUSR
+		},
+	.show = &show_max_read_buffer_kb,
+	.store = &store_max_read_buffer_kb
+};
+
+static ssize_t show_read_buffer_kb(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	ssize_t retval;
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned buffer_size_kb = 0;
+	struct comedi_subdevice *const read_subdevice =
+					comedi_get_read_subdevice(info);
+
+	mutex_lock(&info->device->mutex);
+	if (read_subdevice &&
+		(read_subdevice->subdev_flags & SDF_CMD_READ) &&
+		read_subdevice->async) {
+		buffer_size_kb = read_subdevice->async->prealloc_bufsz /
+					bytes_per_kibi;
+	}
+	retval =  snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
+	mutex_unlock(&info->device->mutex);
+
+	return retval;
+}
+
+static ssize_t store_read_buffer_kb(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned long new_size_kb;
+	uint64_t new_size;
+	int retval;
+	struct comedi_subdevice *const read_subdevice =
+					comedi_get_read_subdevice(info);
+
+	if (strict_strtoul(buf, 10, &new_size_kb))
+		return -EINVAL;
+	if (new_size_kb != (uint32_t)new_size_kb)
+		return -EINVAL;
+	new_size = ((uint64_t)new_size_kb) * bytes_per_kibi;
+	if (new_size != (uint32_t)new_size)
+		return -EINVAL;
+
+	mutex_lock(&info->device->mutex);
+	if (read_subdevice == NULL ||
+	    (read_subdevice->subdev_flags & SDF_CMD_READ) == 0 ||
+	    read_subdevice->async == NULL) {
+		mutex_unlock(&info->device->mutex);
+		return -EINVAL;
+	}
+	retval = resize_async_buffer(info->device, read_subdevice,
+				     read_subdevice->async, new_size);
+	mutex_unlock(&info->device->mutex);
+
+	if (retval < 0)
+		return retval;
+	return count;
+}
+
+static struct device_attribute dev_attr_read_buffer_kb = {
+	.attr = {
+			.name = "read_buffer_kb",
+			.mode = S_IRUGO | S_IWUSR | S_IWGRP
+		},
+	.show = &show_read_buffer_kb,
+	.store = &store_read_buffer_kb
+};
+
+static ssize_t show_max_write_buffer_kb(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	ssize_t retval;
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned max_buffer_size_kb = 0;
+	struct comedi_subdevice *const write_subdevice =
+					comedi_get_write_subdevice(info);
+
+	mutex_lock(&info->device->mutex);
+	if (write_subdevice &&
+	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) &&
+	    write_subdevice->async) {
+		max_buffer_size_kb = write_subdevice->async->max_bufsize /
+					bytes_per_kibi;
+	}
+	retval =  snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
+	mutex_unlock(&info->device->mutex);
+
+	return retval;
+}
+
+static ssize_t store_max_write_buffer_kb(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned long new_max_size_kb;
+	uint64_t new_max_size;
+	struct comedi_subdevice *const write_subdevice =
+					comedi_get_write_subdevice(info);
+
+	if (strict_strtoul(buf, 10, &new_max_size_kb))
+		return -EINVAL;
+	if (new_max_size_kb != (uint32_t)new_max_size_kb)
+		return -EINVAL;
+	new_max_size = ((uint64_t)new_max_size_kb) * bytes_per_kibi;
+	if (new_max_size != (uint32_t)new_max_size)
+		return -EINVAL;
+
+	mutex_lock(&info->device->mutex);
+	if (write_subdevice == NULL ||
+	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) == 0 ||
+	    write_subdevice->async == NULL) {
+		mutex_unlock(&info->device->mutex);
+		return -EINVAL;
+	}
+	write_subdevice->async->max_bufsize = new_max_size;
+	mutex_unlock(&info->device->mutex);
+
+	return count;
+}
+
+static struct device_attribute dev_attr_max_write_buffer_kb = {
+	.attr = {
+			.name = "max_write_buffer_kb",
+			.mode = S_IRUGO | S_IWUSR
+		},
+	.show = &show_max_write_buffer_kb,
+	.store = &store_max_write_buffer_kb
+};
+
+static ssize_t show_write_buffer_kb(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	ssize_t retval;
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned buffer_size_kb = 0;
+	struct comedi_subdevice *const write_subdevice =
+					comedi_get_write_subdevice(info);
+
+	mutex_lock(&info->device->mutex);
+	if (write_subdevice &&
+	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) &&
+	    write_subdevice->async) {
+		buffer_size_kb = write_subdevice->async->prealloc_bufsz /
+					bytes_per_kibi;
+	}
+	retval =  snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
+	mutex_unlock(&info->device->mutex);
+
+	return retval;
+}
+
+static ssize_t store_write_buffer_kb(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct comedi_device_file_info *info = dev_get_drvdata(dev);
+	unsigned long new_size_kb;
+	uint64_t new_size;
+	int retval;
+	struct comedi_subdevice *const write_subdevice =
+					comedi_get_write_subdevice(info);
+
+	if (strict_strtoul(buf, 10, &new_size_kb))
+		return -EINVAL;
+	if (new_size_kb != (uint32_t)new_size_kb)
+		return -EINVAL;
+	new_size = ((uint64_t)new_size_kb) * bytes_per_kibi;
+	if (new_size != (uint32_t)new_size)
+		return -EINVAL;
+
+	mutex_lock(&info->device->mutex);
+	if (write_subdevice == NULL ||
+	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) == 0 ||
+	    write_subdevice->async == NULL) {
+		mutex_unlock(&info->device->mutex);
+		return -EINVAL;
+	}
+	retval = resize_async_buffer(info->device, write_subdevice,
+		write_subdevice->async, new_size);
+	mutex_unlock(&info->device->mutex);
+
+	if (retval < 0)
+		return retval;
+	return count;
+}
+
+static struct device_attribute dev_attr_write_buffer_kb = {
+	.attr = {
+			.name = "write_buffer_kb",
+			.mode = S_IRUGO | S_IWUSR | S_IWGRP
+		},
+	.show = &show_write_buffer_kb,
+	.store = &store_write_buffer_kb
+};

commit 9aa5339ac1eba5268df69bbcdf1abb9fae5afeca
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:42 2009 -0400

    Staging: comedi: Remove comedi_bufinfo typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 5cb6031656bb..19dce2ebfc19 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -556,11 +556,11 @@ static int do_chaninfo_ioctl(struct comedi_device *dev, struct comedi_chaninfo *
   */
 static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg)
 {
-	comedi_bufinfo bi;
+	struct comedi_bufinfo bi;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 
-	if (copy_from_user(&bi, arg, sizeof(comedi_bufinfo)))
+	if (copy_from_user(&bi, arg, sizeof(struct comedi_bufinfo)))
 		return -EFAULT;
 
 	if (bi.subdevice >= dev->n_subdevices || bi.subdevice < 0)
@@ -601,7 +601,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg)
 	bi.buf_read_ptr = async->buf_read_ptr;
 
 copyback:
-	if (copy_to_user(arg, &bi, sizeof(comedi_bufinfo)))
+	if (copy_to_user(arg, &bi, sizeof(struct comedi_bufinfo)))
 		return -EFAULT;
 
 	return 0;

commit be6aba4a423629126f318d351b2d0eb00abb9dd5
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:37 2009 -0400

    Staging: comedi: Remove comedi_bufconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 0e9ad62c6ec9..5cb6031656bb 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -274,12 +274,12 @@ static int do_devconfig_ioctl(struct comedi_device *dev, struct comedi_devconfig
 */
 static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg)
 {
-	comedi_bufconfig bc;
+	struct comedi_bufconfig bc;
 	struct comedi_async *async;
 	struct comedi_subdevice *s;
 	int ret = 0;
 
-	if (copy_from_user(&bc, arg, sizeof(comedi_bufconfig)))
+	if (copy_from_user(&bc, arg, sizeof(struct comedi_bufconfig)))
 		return -EFAULT;
 
 	if (bc.subdevice >= dev->n_subdevices || bc.subdevice < 0)
@@ -340,7 +340,7 @@ static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg)
 	bc.maximum_size = async->max_bufsize;
 
 copyback:
-	if (copy_to_user(arg, &bc, sizeof(comedi_bufconfig)))
+	if (copy_to_user(arg, &bc, sizeof(struct comedi_bufconfig)))
 		return -EFAULT;
 
 	return 0;

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 2d99a4e33b58..0e9ad62c6ec9 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -69,7 +69,7 @@ static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info
     *comedi_file_info_table[COMEDI_NUM_MINORS];
 
-static int do_devconfig_ioctl(struct comedi_device *dev, comedi_devconfig *arg);
+static int do_devconfig_ioctl(struct comedi_device *dev, struct comedi_devconfig *arg);
 static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg);
 static int do_devinfo_ioctl(struct comedi_device *dev, struct comedi_devinfo *arg,
 			    struct file *file);
@@ -192,9 +192,9 @@ static int comedi_ioctl(struct inode *inode, struct file *file,
 	writes:
 		none
 */
-static int do_devconfig_ioctl(struct comedi_device *dev, comedi_devconfig *arg)
+static int do_devconfig_ioctl(struct comedi_device *dev, struct comedi_devconfig *arg)
 {
-	comedi_devconfig it;
+	struct comedi_devconfig it;
 	int ret;
 	unsigned char *aux_data = NULL;
 	int aux_len;
@@ -213,7 +213,7 @@ static int do_devconfig_ioctl(struct comedi_device *dev, comedi_devconfig *arg)
 		return 0;
 	}
 
-	if (copy_from_user(&it, arg, sizeof(comedi_devconfig)))
+	if (copy_from_user(&it, arg, sizeof(struct comedi_devconfig)))
 		return -EFAULT;
 
 	it.board_name[COMEDI_NAMELEN - 1] = 0;

commit 063db04b8901c5cf84c552a5053748d183d34e61
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:15 2009 -0400

    Staging: comedi: Remove comedi_devinfo typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index bc1bc3df9197..2d99a4e33b58 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -71,7 +71,7 @@ static struct comedi_device_file_info
 
 static int do_devconfig_ioctl(struct comedi_device *dev, comedi_devconfig *arg);
 static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg);
-static int do_devinfo_ioctl(struct comedi_device *dev, comedi_devinfo *arg,
+static int do_devinfo_ioctl(struct comedi_device *dev, struct comedi_devinfo *arg,
 			    struct file *file);
 static int do_subdinfo_ioctl(struct comedi_device *dev, struct comedi_subdinfo *arg,
 			     void *file);
@@ -360,10 +360,10 @@ static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg)
 		devinfo structure
 
 */
-static int do_devinfo_ioctl(struct comedi_device *dev, comedi_devinfo *arg,
+static int do_devinfo_ioctl(struct comedi_device *dev, struct comedi_devinfo *arg,
 			    struct file *file)
 {
-	comedi_devinfo devinfo;
+	struct comedi_devinfo devinfo;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
@@ -390,7 +390,7 @@ static int do_devinfo_ioctl(struct comedi_device *dev, comedi_devinfo *arg,
 	else
 		devinfo.write_subdevice = -1;
 
-	if (copy_to_user(arg, &devinfo, sizeof(comedi_devinfo)))
+	if (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))
 		return -EFAULT;
 
 	return 0;

commit bd52efbbcc9f5d70c736b9b73c82aee149da1fe5
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:09 2009 -0400

    Staging: comedi: Remove comedi_subdinfo typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1ffaf8c38f13..bc1bc3df9197 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -73,7 +73,7 @@ static int do_devconfig_ioctl(struct comedi_device *dev, comedi_devconfig *arg);
 static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg);
 static int do_devinfo_ioctl(struct comedi_device *dev, comedi_devinfo *arg,
 			    struct file *file);
-static int do_subdinfo_ioctl(struct comedi_device *dev, comedi_subdinfo *arg,
+static int do_subdinfo_ioctl(struct comedi_device *dev, struct comedi_subdinfo *arg,
 			     void *file);
 static int do_chaninfo_ioctl(struct comedi_device *dev, struct comedi_chaninfo *arg);
 static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg);
@@ -410,14 +410,14 @@ static int do_devinfo_ioctl(struct comedi_device *dev, comedi_devinfo *arg,
 		array of subdevice info structures at arg
 
 */
-static int do_subdinfo_ioctl(struct comedi_device *dev, comedi_subdinfo *arg,
+static int do_subdinfo_ioctl(struct comedi_device *dev, struct comedi_subdinfo *arg,
 			     void *file)
 {
 	int ret, i;
-	comedi_subdinfo *tmp, *us;
+	struct comedi_subdinfo *tmp, *us;
 	struct comedi_subdevice *s;
 
-	tmp = kcalloc(dev->n_subdevices, sizeof(comedi_subdinfo), GFP_KERNEL);
+	tmp = kcalloc(dev->n_subdevices, sizeof(struct comedi_subdinfo), GFP_KERNEL);
 	if (!tmp)
 		return -ENOMEM;
 
@@ -469,7 +469,7 @@ static int do_subdinfo_ioctl(struct comedi_device *dev, comedi_subdinfo *arg,
 	}
 
 	ret = copy_to_user(arg, tmp,
-			   dev->n_subdevices * sizeof(comedi_subdinfo));
+			   dev->n_subdevices * sizeof(struct comedi_subdinfo));
 
 	kfree(tmp);
 

commit a18b416dc11ff9596ebf2012b1d15f485b951b28
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:04 2009 -0400

    Staging: comedi: Remove comedi_chaninfo typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a70d71b8b0f0..1ffaf8c38f13 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -75,7 +75,7 @@ static int do_devinfo_ioctl(struct comedi_device *dev, comedi_devinfo *arg,
 			    struct file *file);
 static int do_subdinfo_ioctl(struct comedi_device *dev, comedi_subdinfo *arg,
 			     void *file);
-static int do_chaninfo_ioctl(struct comedi_device *dev, comedi_chaninfo *arg);
+static int do_chaninfo_ioctl(struct comedi_device *dev, struct comedi_chaninfo *arg);
 static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg);
 static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file);
 static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg, void *file);
@@ -490,12 +490,12 @@ static int do_subdinfo_ioctl(struct comedi_device *dev, comedi_subdinfo *arg,
 		arrays at elements of chaninfo structure
 
 */
-static int do_chaninfo_ioctl(struct comedi_device *dev, comedi_chaninfo *arg)
+static int do_chaninfo_ioctl(struct comedi_device *dev, struct comedi_chaninfo *arg)
 {
 	struct comedi_subdevice *s;
-	comedi_chaninfo it;
+	struct comedi_chaninfo it;
 
-	if (copy_from_user(&it, arg, sizeof(comedi_chaninfo)))
+	if (copy_from_user(&it, arg, sizeof(struct comedi_chaninfo)))
 		return -EFAULT;
 
 	if (it.subdev >= dev->n_subdevices)

commit da613f4fabb43b8bc551bb874792e1f22a698696
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:59 2009 -0400

    Staging: comedi: Remove comedi_insnlist typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index d944c5e64eb4..a70d71b8b0f0 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -628,13 +628,13 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn, unsig
 #define MAX_SAMPLES 256
 static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
-	comedi_insnlist insnlist;
+	struct comedi_insnlist insnlist;
 	struct comedi_insn *insns = NULL;
 	unsigned int *data = NULL;
 	int i = 0;
 	int ret = 0;
 
-	if (copy_from_user(&insnlist, arg, sizeof(comedi_insnlist)))
+	if (copy_from_user(&insnlist, arg, sizeof(struct comedi_insnlist)))
 		return -EFAULT;
 
 	data = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1d83c0890b4e..d944c5e64eb4 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -607,7 +607,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg)
 	return 0;
 }
 
-static int parse_insn(struct comedi_device *dev, comedi_insn *insn, unsigned int *data,
+static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn, unsigned int *data,
 		      void *file);
 /*
  * 	COMEDI_INSNLIST
@@ -629,7 +629,7 @@ static int parse_insn(struct comedi_device *dev, comedi_insn *insn, unsigned int
 static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
 	comedi_insnlist insnlist;
-	comedi_insn *insns = NULL;
+	struct comedi_insn *insns = NULL;
 	unsigned int *data = NULL;
 	int i = 0;
 	int ret = 0;
@@ -644,7 +644,7 @@ static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file)
 		goto error;
 	}
 
-	insns = kmalloc(sizeof(comedi_insn) * insnlist.n_insns, GFP_KERNEL);
+	insns = kmalloc(sizeof(struct comedi_insn) * insnlist.n_insns, GFP_KERNEL);
 	if (!insns) {
 		DPRINTK("kmalloc failed\n");
 		ret = -ENOMEM;
@@ -652,7 +652,7 @@ static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file)
 	}
 
 	if (copy_from_user(insns, insnlist.insns,
-			   sizeof(comedi_insn) * insnlist.n_insns)) {
+			   sizeof(struct comedi_insn) * insnlist.n_insns)) {
 		DPRINTK("copy_from_user failed\n");
 		ret = -EFAULT;
 		goto error;
@@ -696,7 +696,7 @@ static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file)
 	return i;
 }
 
-static int check_insn_config_length(comedi_insn *insn, unsigned int *data)
+static int check_insn_config_length(struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -757,7 +757,7 @@ static int check_insn_config_length(comedi_insn *insn, unsigned int *data)
 	return -EINVAL;
 }
 
-static int parse_insn(struct comedi_device *dev, comedi_insn *insn, unsigned int *data,
+static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn, unsigned int *data,
 		      void *file)
 {
 	struct comedi_subdevice *s;
@@ -911,7 +911,7 @@ static int parse_insn(struct comedi_device *dev, comedi_insn *insn, unsigned int
  * 		pointer to insn
  *
  * 	reads:
- * 		comedi_insn struct at arg
+ * 		struct comedi_insn struct at arg
  * 		data (for writes)
  *
  * 	writes:
@@ -919,7 +919,7 @@ static int parse_insn(struct comedi_device *dev, comedi_insn *insn, unsigned int
  */
 static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
-	comedi_insn insn;
+	struct comedi_insn insn;
 	unsigned int *data = NULL;
 	int ret = 0;
 
@@ -929,7 +929,7 @@ static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file)
 		goto error;
 	}
 
-	if (copy_from_user(&insn, arg, sizeof(comedi_insn))) {
+	if (copy_from_user(&insn, arg, sizeof(struct comedi_insn))) {
 		ret = -EFAULT;
 		goto error;
 	}

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 524bef968a1c..1d83c0890b4e 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -977,13 +977,13 @@ static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file)
 */
 static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
-	comedi_cmd user_cmd;
+	struct comedi_cmd user_cmd;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 	int ret = 0;
 	unsigned int *chanlist_saver = NULL;
 
-	if (copy_from_user(&user_cmd, arg, sizeof(comedi_cmd))) {
+	if (copy_from_user(&user_cmd, arg, sizeof(struct comedi_cmd))) {
 		DPRINTK("bad cmd address\n");
 		return -EFAULT;
 	}
@@ -1072,7 +1072,7 @@ static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file)
 		/* restore chanlist pointer before copying back */
 		user_cmd.chanlist = chanlist_saver;
 		user_cmd.data = NULL;
-		if (copy_to_user(arg, &user_cmd, sizeof(comedi_cmd))) {
+		if (copy_to_user(arg, &user_cmd, sizeof(struct comedi_cmd))) {
 			DPRINTK("fault writing cmd\n");
 			ret = -EFAULT;
 			goto cleanup;
@@ -1131,13 +1131,13 @@ static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file)
 */
 static int do_cmdtest_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
-	comedi_cmd user_cmd;
+	struct comedi_cmd user_cmd;
 	struct comedi_subdevice *s;
 	int ret = 0;
 	unsigned int *chanlist = NULL;
 	unsigned int *chanlist_saver = NULL;
 
-	if (copy_from_user(&user_cmd, arg, sizeof(comedi_cmd))) {
+	if (copy_from_user(&user_cmd, arg, sizeof(struct comedi_cmd))) {
 		DPRINTK("bad cmd address\n");
 		return -EFAULT;
 	}
@@ -1201,7 +1201,7 @@ static int do_cmdtest_ioctl(struct comedi_device *dev, void *arg, void *file)
 	/* restore chanlist pointer before copying back */
 	user_cmd.chanlist = chanlist_saver;
 
-	if (copy_to_user(arg, &user_cmd, sizeof(comedi_cmd))) {
+	if (copy_to_user(arg, &user_cmd, sizeof(struct comedi_cmd))) {
 		DPRINTK("bad cmd address\n");
 		ret = -EFAULT;
 		goto cleanup;

commit 0bfbbe8f09617247c87d3b626cbf007c423afff1
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:36 2009 -0400

    Staging: comedi: Remove device_create_result_type typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index d38addd01d4a..524bef968a1c 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2130,7 +2130,7 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 {
 	unsigned long flags;
 	struct comedi_device_file_info *info;
-	device_create_result_type *csdev;
+	struct device *csdev;
 	unsigned i;
 
 	info = kzalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
@@ -2197,7 +2197,7 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev, struct comedi_subdev
 {
 	unsigned long flags;
 	struct comedi_device_file_info *info;
-	device_create_result_type *csdev;
+	struct device *csdev;
 	unsigned i;
 
 	info = kmalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index eac18a742b22..d38addd01d4a 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -275,7 +275,7 @@ static int do_devconfig_ioctl(struct comedi_device *dev, comedi_devconfig *arg)
 static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg)
 {
 	comedi_bufconfig bc;
-	comedi_async *async;
+	struct comedi_async *async;
 	struct comedi_subdevice *s;
 	int ret = 0;
 
@@ -558,7 +558,7 @@ static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg)
 {
 	comedi_bufinfo bi;
 	struct comedi_subdevice *s;
-	comedi_async *async;
+	struct comedi_async *async;
 
 	if (copy_from_user(&bi, arg, sizeof(comedi_bufinfo)))
 		return -EFAULT;
@@ -979,7 +979,7 @@ static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
 	comedi_cmd user_cmd;
 	struct comedi_subdevice *s;
-	comedi_async *async;
+	struct comedi_async *async;
 	int ret = 0;
 	unsigned int *chanlist_saver = NULL;
 
@@ -1384,7 +1384,7 @@ static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 
 void comedi_unmap(struct vm_area_struct *area)
 {
-	comedi_async *async;
+	struct comedi_async *async;
 	struct comedi_device *dev;
 
 	async = area->vm_private_data;
@@ -1405,7 +1405,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
 	struct comedi_device *dev = dev_file_info->device;
-	comedi_async *async = NULL;
+	struct comedi_async *async = NULL;
 	unsigned long start = vma->vm_start;
 	unsigned long size;
 	int n_pages;
@@ -1524,7 +1524,7 @@ static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
 			    loff_t *offset)
 {
 	struct comedi_subdevice *s;
-	comedi_async *async;
+	struct comedi_async *async;
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
@@ -1626,7 +1626,7 @@ static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
 			   loff_t *offset)
 {
 	struct comedi_subdevice *s;
-	comedi_async *async;
+	struct comedi_async *async;
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
@@ -1735,7 +1735,7 @@ static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
  */
 void do_become_nonbusy(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 
 	comedi_set_subdevice_runflags(s, SRF_RUNNING, 0);
 #ifdef CONFIG_COMEDI_RT
@@ -2008,7 +2008,7 @@ void comedi_error(const struct comedi_device *dev, const char *s)
 
 void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	unsigned runflags = 0;
 	unsigned runflags_mask = 0;
 

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index c8169e03693f..eac18a742b22 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -86,8 +86,8 @@ static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file);
 static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file);
 static int do_poll_ioctl(struct comedi_device *dev, unsigned int subd, void *file);
 
-extern void do_become_nonbusy(struct comedi_device *dev, comedi_subdevice *s);
-static int do_cancel(struct comedi_device *dev, comedi_subdevice *s);
+extern void do_become_nonbusy(struct comedi_device *dev, struct comedi_subdevice *s);
+static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static int comedi_fasync(int fd, struct file *file, int on);
 
@@ -276,7 +276,7 @@ static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg)
 {
 	comedi_bufconfig bc;
 	comedi_async *async;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int ret = 0;
 
 	if (copy_from_user(&bc, arg, sizeof(comedi_bufconfig)))
@@ -367,9 +367,9 @@ static int do_devinfo_ioctl(struct comedi_device *dev, comedi_devinfo *arg,
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
-	comedi_subdevice *read_subdev =
+	struct comedi_subdevice *read_subdev =
 	    comedi_get_read_subdevice(dev_file_info);
-	comedi_subdevice *write_subdev =
+	struct comedi_subdevice *write_subdev =
 	    comedi_get_write_subdevice(dev_file_info);
 
 	memset(&devinfo, 0, sizeof(devinfo));
@@ -415,7 +415,7 @@ static int do_subdinfo_ioctl(struct comedi_device *dev, comedi_subdinfo *arg,
 {
 	int ret, i;
 	comedi_subdinfo *tmp, *us;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	tmp = kcalloc(dev->n_subdevices, sizeof(comedi_subdinfo), GFP_KERNEL);
 	if (!tmp)
@@ -492,7 +492,7 @@ static int do_subdinfo_ioctl(struct comedi_device *dev, comedi_subdinfo *arg,
 */
 static int do_chaninfo_ioctl(struct comedi_device *dev, comedi_chaninfo *arg)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	comedi_chaninfo it;
 
 	if (copy_from_user(&it, arg, sizeof(comedi_chaninfo)))
@@ -557,7 +557,7 @@ static int do_chaninfo_ioctl(struct comedi_device *dev, comedi_chaninfo *arg)
 static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg)
 {
 	comedi_bufinfo bi;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	comedi_async *async;
 
 	if (copy_from_user(&bi, arg, sizeof(comedi_bufinfo)))
@@ -760,7 +760,7 @@ static int check_insn_config_length(comedi_insn *insn, unsigned int *data)
 static int parse_insn(struct comedi_device *dev, comedi_insn *insn, unsigned int *data,
 		      void *file)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int ret = 0;
 	int i;
 
@@ -978,7 +978,7 @@ static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file)
 static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
 	comedi_cmd user_cmd;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	comedi_async *async;
 	int ret = 0;
 	unsigned int *chanlist_saver = NULL;
@@ -1132,7 +1132,7 @@ static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file)
 static int do_cmdtest_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
 	comedi_cmd user_cmd;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int ret = 0;
 	unsigned int *chanlist = NULL;
 	unsigned int *chanlist_saver = NULL;
@@ -1231,7 +1231,7 @@ static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg, void *file
 {
 	int ret = 0;
 	unsigned long flags;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
@@ -1273,7 +1273,7 @@ static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg, void *file
 */
 static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
@@ -1313,7 +1313,7 @@ static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg, void *fi
 */
 static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
@@ -1349,7 +1349,7 @@ static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg, void *fi
 */
 static int do_poll_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	if (arg >= dev->n_subdevices)
 		return -EINVAL;
@@ -1370,7 +1370,7 @@ static int do_poll_ioctl(struct comedi_device *dev, unsigned int arg, void *file
 	return -EINVAL;
 }
 
-static int do_cancel(struct comedi_device *dev, comedi_subdevice *s)
+static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int ret = 0;
 
@@ -1411,7 +1411,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	int n_pages;
 	int i;
 	int retval;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	mutex_lock(&dev->mutex);
 	if (!dev->attached) {
@@ -1481,8 +1481,8 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
 	struct comedi_device *dev = dev_file_info->device;
-	comedi_subdevice *read_subdev;
-	comedi_subdevice *write_subdev;
+	struct comedi_subdevice *read_subdev;
+	struct comedi_subdevice *write_subdev;
 
 	mutex_lock(&dev->mutex);
 	if (!dev->attached) {
@@ -1523,7 +1523,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
 			    loff_t *offset)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	comedi_async *async;
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
@@ -1625,7 +1625,7 @@ static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
 static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
 			   loff_t *offset)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	comedi_async *async;
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
@@ -1733,7 +1733,7 @@ static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
 /*
    This function restores a subdevice to an idle state.
  */
-void do_become_nonbusy(struct comedi_device *dev, comedi_subdevice *s)
+void do_become_nonbusy(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	comedi_async *async = s->async;
 
@@ -1833,7 +1833,7 @@ static int comedi_close(struct inode *inode, struct file *file)
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
 	struct comedi_device *dev = dev_file_info->device;
-	comedi_subdevice *s = NULL;
+	struct comedi_subdevice *s = NULL;
 	int i;
 
 	mutex_lock(&dev->mutex);
@@ -2006,7 +2006,7 @@ void comedi_error(const struct comedi_device *dev, const char *s)
 		  s);
 }
 
-void comedi_event(struct comedi_device *dev, comedi_subdevice *s)
+void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	comedi_async *async = s->async;
 	unsigned runflags = 0;
@@ -2067,7 +2067,7 @@ void comedi_event(struct comedi_device *dev, comedi_subdevice *s)
 	s->async->events = 0;
 }
 
-void comedi_set_subdevice_runflags(comedi_subdevice *s, unsigned mask,
+void comedi_set_subdevice_runflags(struct comedi_subdevice *s, unsigned mask,
 				   unsigned bits)
 {
 	unsigned long flags;
@@ -2078,7 +2078,7 @@ void comedi_set_subdevice_runflags(comedi_subdevice *s, unsigned mask,
 	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
 }
 
-unsigned comedi_get_subdevice_runflags(comedi_subdevice *s)
+unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 {
 	unsigned long flags;
 	unsigned runflags;
@@ -2091,7 +2091,7 @@ unsigned comedi_get_subdevice_runflags(comedi_subdevice *s)
 
 static int is_device_busy(struct comedi_device *dev)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int i;
 
 	if (!dev->attached)
@@ -2193,7 +2193,7 @@ void comedi_free_board_minor(unsigned minor)
 	}
 }
 
-int comedi_alloc_subdevice_minor(struct comedi_device *dev, comedi_subdevice *s)
+int comedi_alloc_subdevice_minor(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 	struct comedi_device_file_info *info;
@@ -2231,7 +2231,7 @@ int comedi_alloc_subdevice_minor(struct comedi_device *dev, comedi_subdevice *s)
 	return i;
 }
 
-void comedi_free_subdevice_minor(comedi_subdevice *s)
+void comedi_free_subdevice_minor(struct comedi_subdevice *s)
 {
 	unsigned long flags;
 	struct comedi_device_file_info *info;

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 82bb66994e17..c8169e03693f 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -69,29 +69,29 @@ static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info
     *comedi_file_info_table[COMEDI_NUM_MINORS];
 
-static int do_devconfig_ioctl(comedi_device *dev, comedi_devconfig *arg);
-static int do_bufconfig_ioctl(comedi_device *dev, void *arg);
-static int do_devinfo_ioctl(comedi_device *dev, comedi_devinfo *arg,
+static int do_devconfig_ioctl(struct comedi_device *dev, comedi_devconfig *arg);
+static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg);
+static int do_devinfo_ioctl(struct comedi_device *dev, comedi_devinfo *arg,
 			    struct file *file);
-static int do_subdinfo_ioctl(comedi_device *dev, comedi_subdinfo *arg,
+static int do_subdinfo_ioctl(struct comedi_device *dev, comedi_subdinfo *arg,
 			     void *file);
-static int do_chaninfo_ioctl(comedi_device *dev, comedi_chaninfo *arg);
-static int do_bufinfo_ioctl(comedi_device *dev, void *arg);
-static int do_cmd_ioctl(comedi_device *dev, void *arg, void *file);
-static int do_lock_ioctl(comedi_device *dev, unsigned int arg, void *file);
-static int do_unlock_ioctl(comedi_device *dev, unsigned int arg, void *file);
-static int do_cancel_ioctl(comedi_device *dev, unsigned int arg, void *file);
-static int do_cmdtest_ioctl(comedi_device *dev, void *arg, void *file);
-static int do_insnlist_ioctl(comedi_device *dev, void *arg, void *file);
-static int do_insn_ioctl(comedi_device *dev, void *arg, void *file);
-static int do_poll_ioctl(comedi_device *dev, unsigned int subd, void *file);
-
-extern void do_become_nonbusy(comedi_device *dev, comedi_subdevice *s);
-static int do_cancel(comedi_device *dev, comedi_subdevice *s);
+static int do_chaninfo_ioctl(struct comedi_device *dev, comedi_chaninfo *arg);
+static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg);
+static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file);
+static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg, void *file);
+static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg, void *file);
+static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg, void *file);
+static int do_cmdtest_ioctl(struct comedi_device *dev, void *arg, void *file);
+static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file);
+static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file);
+static int do_poll_ioctl(struct comedi_device *dev, unsigned int subd, void *file);
+
+extern void do_become_nonbusy(struct comedi_device *dev, comedi_subdevice *s);
+static int do_cancel(struct comedi_device *dev, comedi_subdevice *s);
 
 static int comedi_fasync(int fd, struct file *file, int on);
 
-static int is_device_busy(comedi_device *dev);
+static int is_device_busy(struct comedi_device *dev);
 
 #ifdef HAVE_UNLOCKED_IOCTL
 static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
@@ -104,7 +104,7 @@ static int comedi_ioctl(struct inode *inode, struct file *file,
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
-	comedi_device *dev;
+	struct comedi_device *dev;
 	int rc;
 
 	if (dev_file_info == NULL || dev_file_info->device == NULL)
@@ -192,7 +192,7 @@ static int comedi_ioctl(struct inode *inode, struct file *file,
 	writes:
 		none
 */
-static int do_devconfig_ioctl(comedi_device *dev, comedi_devconfig *arg)
+static int do_devconfig_ioctl(struct comedi_device *dev, comedi_devconfig *arg)
 {
 	comedi_devconfig it;
 	int ret;
@@ -272,7 +272,7 @@ static int do_devconfig_ioctl(comedi_device *dev, comedi_devconfig *arg)
 		modified bufconfig at arg
 
 */
-static int do_bufconfig_ioctl(comedi_device *dev, void *arg)
+static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg)
 {
 	comedi_bufconfig bc;
 	comedi_async *async;
@@ -360,7 +360,7 @@ static int do_bufconfig_ioctl(comedi_device *dev, void *arg)
 		devinfo structure
 
 */
-static int do_devinfo_ioctl(comedi_device *dev, comedi_devinfo *arg,
+static int do_devinfo_ioctl(struct comedi_device *dev, comedi_devinfo *arg,
 			    struct file *file)
 {
 	comedi_devinfo devinfo;
@@ -410,7 +410,7 @@ static int do_devinfo_ioctl(comedi_device *dev, comedi_devinfo *arg,
 		array of subdevice info structures at arg
 
 */
-static int do_subdinfo_ioctl(comedi_device *dev, comedi_subdinfo *arg,
+static int do_subdinfo_ioctl(struct comedi_device *dev, comedi_subdinfo *arg,
 			     void *file)
 {
 	int ret, i;
@@ -490,7 +490,7 @@ static int do_subdinfo_ioctl(comedi_device *dev, comedi_subdinfo *arg,
 		arrays at elements of chaninfo structure
 
 */
-static int do_chaninfo_ioctl(comedi_device *dev, comedi_chaninfo *arg)
+static int do_chaninfo_ioctl(struct comedi_device *dev, comedi_chaninfo *arg)
 {
 	comedi_subdevice *s;
 	comedi_chaninfo it;
@@ -554,7 +554,7 @@ static int do_chaninfo_ioctl(comedi_device *dev, comedi_chaninfo *arg)
     modified bufinfo at arg
 
   */
-static int do_bufinfo_ioctl(comedi_device *dev, void *arg)
+static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg)
 {
 	comedi_bufinfo bi;
 	comedi_subdevice *s;
@@ -607,7 +607,7 @@ static int do_bufinfo_ioctl(comedi_device *dev, void *arg)
 	return 0;
 }
 
-static int parse_insn(comedi_device *dev, comedi_insn *insn, unsigned int *data,
+static int parse_insn(struct comedi_device *dev, comedi_insn *insn, unsigned int *data,
 		      void *file);
 /*
  * 	COMEDI_INSNLIST
@@ -626,7 +626,7 @@ static int parse_insn(comedi_device *dev, comedi_insn *insn, unsigned int *data,
  */
 /* arbitrary limits */
 #define MAX_SAMPLES 256
-static int do_insnlist_ioctl(comedi_device *dev, void *arg, void *file)
+static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
 	comedi_insnlist insnlist;
 	comedi_insn *insns = NULL;
@@ -757,7 +757,7 @@ static int check_insn_config_length(comedi_insn *insn, unsigned int *data)
 	return -EINVAL;
 }
 
-static int parse_insn(comedi_device *dev, comedi_insn *insn, unsigned int *data,
+static int parse_insn(struct comedi_device *dev, comedi_insn *insn, unsigned int *data,
 		      void *file)
 {
 	comedi_subdevice *s;
@@ -917,7 +917,7 @@ static int parse_insn(comedi_device *dev, comedi_insn *insn, unsigned int *data,
  * 	writes:
  * 		data (for reads)
  */
-static int do_insn_ioctl(comedi_device *dev, void *arg, void *file)
+static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
 	comedi_insn insn;
 	unsigned int *data = NULL;
@@ -975,7 +975,7 @@ static int do_insn_ioctl(comedi_device *dev, void *arg, void *file)
 		modified cmd structure at arg
 
 */
-static int do_cmd_ioctl(comedi_device *dev, void *arg, void *file)
+static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
 	comedi_cmd user_cmd;
 	comedi_subdevice *s;
@@ -1129,7 +1129,7 @@ static int do_cmd_ioctl(comedi_device *dev, void *arg, void *file)
 		modified cmd structure at arg
 
 */
-static int do_cmdtest_ioctl(comedi_device *dev, void *arg, void *file)
+static int do_cmdtest_ioctl(struct comedi_device *dev, void *arg, void *file)
 {
 	comedi_cmd user_cmd;
 	comedi_subdevice *s;
@@ -1227,7 +1227,7 @@ static int do_cmdtest_ioctl(comedi_device *dev, void *arg, void *file)
 
 */
 
-static int do_lock_ioctl(comedi_device *dev, unsigned int arg, void *file)
+static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
 {
 	int ret = 0;
 	unsigned long flags;
@@ -1271,7 +1271,7 @@ static int do_lock_ioctl(comedi_device *dev, unsigned int arg, void *file)
 	This function isn't protected by the semaphore, since
 	we already own the lock.
 */
-static int do_unlock_ioctl(comedi_device *dev, unsigned int arg, void *file)
+static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
 {
 	comedi_subdevice *s;
 
@@ -1311,7 +1311,7 @@ static int do_unlock_ioctl(comedi_device *dev, unsigned int arg, void *file)
 		nothing
 
 */
-static int do_cancel_ioctl(comedi_device *dev, unsigned int arg, void *file)
+static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
 {
 	comedi_subdevice *s;
 
@@ -1347,7 +1347,7 @@ static int do_cancel_ioctl(comedi_device *dev, unsigned int arg, void *file)
 		nothing
 
 */
-static int do_poll_ioctl(comedi_device *dev, unsigned int arg, void *file)
+static int do_poll_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
 {
 	comedi_subdevice *s;
 
@@ -1370,7 +1370,7 @@ static int do_poll_ioctl(comedi_device *dev, unsigned int arg, void *file)
 	return -EINVAL;
 }
 
-static int do_cancel(comedi_device *dev, comedi_subdevice *s)
+static int do_cancel(struct comedi_device *dev, comedi_subdevice *s)
 {
 	int ret = 0;
 
@@ -1385,7 +1385,7 @@ static int do_cancel(comedi_device *dev, comedi_subdevice *s)
 void comedi_unmap(struct vm_area_struct *area)
 {
 	comedi_async *async;
-	comedi_device *dev;
+	struct comedi_device *dev;
 
 	async = area->vm_private_data;
 	dev = async->subdevice->device;
@@ -1404,7 +1404,7 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
-	comedi_device *dev = dev_file_info->device;
+	struct comedi_device *dev = dev_file_info->device;
 	comedi_async *async = NULL;
 	unsigned long start = vma->vm_start;
 	unsigned long size;
@@ -1480,7 +1480,7 @@ static unsigned int comedi_poll(struct file *file, poll_table *wait)
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
-	comedi_device *dev = dev_file_info->device;
+	struct comedi_device *dev = dev_file_info->device;
 	comedi_subdevice *read_subdev;
 	comedi_subdevice *write_subdev;
 
@@ -1530,7 +1530,7 @@ static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
-	comedi_device *dev = dev_file_info->device;
+	struct comedi_device *dev = dev_file_info->device;
 
 	if (!dev->attached) {
 		DPRINTK("no driver configured on comedi%i\n", dev->minor);
@@ -1632,7 +1632,7 @@ static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
-	comedi_device *dev = dev_file_info->device;
+	struct comedi_device *dev = dev_file_info->device;
 
 	if (!dev->attached) {
 		DPRINTK("no driver configured on comedi%i\n", dev->minor);
@@ -1733,7 +1733,7 @@ static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
 /*
    This function restores a subdevice to an idle state.
  */
-void do_become_nonbusy(comedi_device *dev, comedi_subdevice *s)
+void do_become_nonbusy(struct comedi_device *dev, comedi_subdevice *s)
 {
 	comedi_async *async = s->async;
 
@@ -1760,7 +1760,7 @@ static int comedi_open(struct inode *inode, struct file *file)
 	const unsigned minor = iminor(inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
-	comedi_device *dev = dev_file_info ? dev_file_info->device : NULL;
+	struct comedi_device *dev = dev_file_info ? dev_file_info->device : NULL;
 
 	if (dev == NULL) {
 		DPRINTK("invalid minor number\n");
@@ -1832,7 +1832,7 @@ static int comedi_close(struct inode *inode, struct file *file)
 	const unsigned minor = iminor(inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
-	comedi_device *dev = dev_file_info->device;
+	struct comedi_device *dev = dev_file_info->device;
 	comedi_subdevice *s = NULL;
 	int i;
 
@@ -1871,7 +1871,7 @@ static int comedi_fasync(int fd, struct file *file, int on)
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
 
-	comedi_device *dev = dev_file_info->device;
+	struct comedi_device *dev = dev_file_info->device;
 
 	return fasync_helper(fd, file, on, &dev->async_queue);
 }
@@ -2000,13 +2000,13 @@ static void __exit comedi_cleanup(void)
 module_init(comedi_init);
 module_exit(comedi_cleanup);
 
-void comedi_error(const comedi_device *dev, const char *s)
+void comedi_error(const struct comedi_device *dev, const char *s)
 {
 	rt_printk("comedi%d: %s: %s\n", dev->minor, dev->driver->driver_name,
 		  s);
 }
 
-void comedi_event(comedi_device *dev, comedi_subdevice *s)
+void comedi_event(struct comedi_device *dev, comedi_subdevice *s)
 {
 	comedi_async *async = s->async;
 	unsigned runflags = 0;
@@ -2089,7 +2089,7 @@ unsigned comedi_get_subdevice_runflags(comedi_subdevice *s)
 	return runflags;
 }
 
-static int is_device_busy(comedi_device *dev)
+static int is_device_busy(struct comedi_device *dev)
 {
 	comedi_subdevice *s;
 	int i;
@@ -2108,15 +2108,15 @@ static int is_device_busy(comedi_device *dev)
 	return 0;
 }
 
-void comedi_device_init(comedi_device *dev)
+void comedi_device_init(struct comedi_device *dev)
 {
-	memset(dev, 0, sizeof(comedi_device));
+	memset(dev, 0, sizeof(struct comedi_device));
 	spin_lock_init(&dev->spinlock);
 	mutex_init(&dev->mutex);
 	dev->minor = -1;
 }
 
-void comedi_device_cleanup(comedi_device *dev)
+void comedi_device_cleanup(struct comedi_device *dev)
 {
 	if (dev == NULL)
 		return;
@@ -2136,7 +2136,7 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	info = kzalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
 	if (info == NULL)
 		return -ENOMEM;
-	info->device = kzalloc(sizeof(comedi_device), GFP_KERNEL);
+	info->device = kzalloc(sizeof(struct comedi_device), GFP_KERNEL);
 	if (info->device == NULL) {
 		kfree(info);
 		return -ENOMEM;
@@ -2180,7 +2180,7 @@ void comedi_free_board_minor(unsigned minor)
 	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 
 	if (info) {
-		comedi_device *dev = info->device;
+		struct comedi_device *dev = info->device;
 		if (dev) {
 			if (dev->class_dev) {
 				device_destroy(comedi_class,
@@ -2193,7 +2193,7 @@ void comedi_free_board_minor(unsigned minor)
 	}
 }
 
-int comedi_alloc_subdevice_minor(comedi_device *dev, comedi_subdevice *s)
+int comedi_alloc_subdevice_minor(struct comedi_device *dev, comedi_subdevice *s)
 {
 	unsigned long flags;
 	struct comedi_device_file_info *info;

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index fa5ef2ee4eda..82bb66994e17 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -506,7 +506,7 @@ static int do_chaninfo_ioctl(comedi_device *dev, comedi_chaninfo *arg)
 		if (s->maxdata || !s->maxdata_list)
 			return -EINVAL;
 		if (copy_to_user(it.maxdata_list, s->maxdata_list,
-				 s->n_chan * sizeof(lsampl_t)))
+				 s->n_chan * sizeof(unsigned int)))
 			return -EFAULT;
 	}
 
@@ -607,7 +607,7 @@ static int do_bufinfo_ioctl(comedi_device *dev, void *arg)
 	return 0;
 }
 
-static int parse_insn(comedi_device *dev, comedi_insn *insn, lsampl_t *data,
+static int parse_insn(comedi_device *dev, comedi_insn *insn, unsigned int *data,
 		      void *file);
 /*
  * 	COMEDI_INSNLIST
@@ -630,14 +630,14 @@ static int do_insnlist_ioctl(comedi_device *dev, void *arg, void *file)
 {
 	comedi_insnlist insnlist;
 	comedi_insn *insns = NULL;
-	lsampl_t *data = NULL;
+	unsigned int *data = NULL;
 	int i = 0;
 	int ret = 0;
 
 	if (copy_from_user(&insnlist, arg, sizeof(comedi_insnlist)))
 		return -EFAULT;
 
-	data = kmalloc(sizeof(lsampl_t) * MAX_SAMPLES, GFP_KERNEL);
+	data = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);
 	if (!data) {
 		DPRINTK("kmalloc failed\n");
 		ret = -ENOMEM;
@@ -666,7 +666,7 @@ static int do_insnlist_ioctl(comedi_device *dev, void *arg, void *file)
 		}
 		if (insns[i].insn & INSN_MASK_WRITE) {
 			if (copy_from_user(data, insns[i].data,
-					   insns[i].n * sizeof(lsampl_t))) {
+					   insns[i].n * sizeof(unsigned int))) {
 				DPRINTK("copy_from_user failed\n");
 				ret = -EFAULT;
 				goto error;
@@ -677,7 +677,7 @@ static int do_insnlist_ioctl(comedi_device *dev, void *arg, void *file)
 			goto error;
 		if (insns[i].insn & INSN_MASK_READ) {
 			if (copy_to_user(insns[i].data, data,
-					 insns[i].n * sizeof(lsampl_t))) {
+					 insns[i].n * sizeof(unsigned int))) {
 				DPRINTK("copy_to_user failed\n");
 				ret = -EFAULT;
 				goto error;
@@ -696,7 +696,7 @@ static int do_insnlist_ioctl(comedi_device *dev, void *arg, void *file)
 	return i;
 }
 
-static int check_insn_config_length(comedi_insn *insn, lsampl_t *data)
+static int check_insn_config_length(comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -757,7 +757,7 @@ static int check_insn_config_length(comedi_insn *insn, lsampl_t *data)
 	return -EINVAL;
 }
 
-static int parse_insn(comedi_device *dev, comedi_insn *insn, lsampl_t *data,
+static int parse_insn(comedi_device *dev, comedi_insn *insn, unsigned int *data,
 		      void *file)
 {
 	comedi_subdevice *s;
@@ -825,7 +825,7 @@ static int parse_insn(comedi_device *dev, comedi_insn *insn, lsampl_t *data,
 		}
 	} else {
 		/* a subdevice instruction */
-		lsampl_t maxdata;
+		unsigned int maxdata;
 
 		if (insn->subdev >= dev->n_subdevices) {
 			DPRINTK("subdevice %d out of range\n", insn->subdev);
@@ -920,10 +920,10 @@ static int parse_insn(comedi_device *dev, comedi_insn *insn, lsampl_t *data,
 static int do_insn_ioctl(comedi_device *dev, void *arg, void *file)
 {
 	comedi_insn insn;
-	lsampl_t *data = NULL;
+	unsigned int *data = NULL;
 	int ret = 0;
 
-	data = kmalloc(sizeof(lsampl_t) * MAX_SAMPLES, GFP_KERNEL);
+	data = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);
 	if (!data) {
 		ret = -ENOMEM;
 		goto error;
@@ -938,7 +938,7 @@ static int do_insn_ioctl(comedi_device *dev, void *arg, void *file)
 	if (insn.n > MAX_SAMPLES)
 		insn.n = MAX_SAMPLES;
 	if (insn.insn & INSN_MASK_WRITE) {
-		if (copy_from_user(data, insn.data, insn.n * sizeof(lsampl_t))) {
+		if (copy_from_user(data, insn.data, insn.n * sizeof(unsigned int))) {
 			ret = -EFAULT;
 			goto error;
 		}
@@ -947,7 +947,7 @@ static int do_insn_ioctl(comedi_device *dev, void *arg, void *file)
 	if (ret < 0)
 		goto error;
 	if (insn.insn & INSN_MASK_READ) {
-		if (copy_to_user(insn.data, data, insn.n * sizeof(lsampl_t))) {
+		if (copy_to_user(insn.data, data, insn.n * sizeof(unsigned int))) {
 			ret = -EFAULT;
 			goto error;
 		}

commit 979200719d35934367bbf97d9b7d22d5b5281dda
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Feb 9 16:51:38 2009 +0000

    Staging: comedi: comedi_open: Fix null pointer dereference.
    
    This can happen if other minor devices are used.
    
    From: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 6867b0938e15..fa5ef2ee4eda 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1760,7 +1760,8 @@ static int comedi_open(struct inode *inode, struct file *file)
 	const unsigned minor = iminor(inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
-	comedi_device *dev = dev_file_info->device;
+	comedi_device *dev = dev_file_info ? dev_file_info->device : NULL;
+
 	if (dev == NULL) {
 		DPRINTK("invalid minor number\n");
 		return -ENODEV;

commit 56d92c60e6dc708541711e9de4993e7d527d08e8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Feb 9 16:32:12 2009 +0000

    Staging: comedi: newer gcc warning fixes
    
    Fix GCC warning in call to request_module(): "format not a string
    literal and no format arguments".
    
    From: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index fbd3d1c6c647..6867b0938e15 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1757,7 +1757,6 @@ void do_become_nonbusy(comedi_device *dev, comedi_subdevice *s)
 
 static int comedi_open(struct inode *inode, struct file *file)
 {
-	char mod[32];
 	const unsigned minor = iminor(inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
@@ -1793,10 +1792,9 @@ static int comedi_open(struct inode *inode, struct file *file)
 
 	dev->in_request_module = 1;
 
-	sprintf(mod, "char-major-%i-%i", COMEDI_MAJOR, dev->minor);
 #ifdef CONFIG_KMOD
 	mutex_unlock(&dev->mutex);
-	request_module(mod);
+	request_module("char-major-%i-%i", COMEDI_MAJOR, dev->minor);
 	mutex_lock(&dev->mutex);
 #endif
 

commit 53b670a75bef4bf6484bbf6ca6a896c365676fd4
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Mon Dec 15 13:48:47 2008 +0000

    Staging: comedi: fix bug with invalid minor number usage.
    
    Return error instead of segfaulting if user trys to run comedi_config on
    a device file with and invalid minor number.
    
    From: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 1464f550a5af..fbd3d1c6c647 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -104,9 +104,13 @@ static int comedi_ioctl(struct inode *inode, struct file *file,
 	const unsigned minor = iminor(file->f_dentry->d_inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
-	comedi_device *dev = dev_file_info->device;
+	comedi_device *dev;
 	int rc;
 
+	if (dev_file_info == NULL || dev_file_info->device == NULL)
+		return -ENODEV;
+	dev = dev_file_info->device;
+
 	mutex_lock(&dev->mutex);
 
 	/* Device config is special, because it must work on

commit a3cb729ef4a192f04179f780122df78ef1ffe779
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Mon Dec 15 13:44:45 2008 +0000

    Staging: comedi: Added some validation of comedi module parameter values.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ed9f2bb88752..1464f550a5af 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1911,6 +1911,22 @@ static int __init comedi_init(void)
 	printk(KERN_INFO "comedi: version " COMEDI_RELEASE
 	       " - http://www.comedi.org\n");
 
+	if (comedi_num_legacy_minors < 0 ||
+	    comedi_num_legacy_minors > COMEDI_NUM_BOARD_MINORS) {
+		printk(KERN_ERR "comedi: error: invalid value for module "
+		       "parameter \"comedi_num_legacy_minors\".  Valid values "
+		       "are 0 through %i.\n", COMEDI_NUM_BOARD_MINORS);
+		return -EINVAL;
+	}
+
+	/*
+	 * comedi is unusable if both comedi_autoconfig and
+	 * comedi_num_legacy_minors are zero, so we might as well adjust the
+	 * defaults in that case
+	 */
+	if (comedi_autoconfig == 0 && comedi_num_legacy_minors == 0)
+		comedi_num_legacy_minors = 16;
+
 	memset(comedi_file_info_table, 0,
 	       sizeof(struct comedi_device_file_info *) * COMEDI_NUM_MINORS);
 

commit 4c41f3ae3bf0bcc53f259b657c2fbc3961ff2b8a
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Tue Dec 9 14:47:22 2008 +0000

    Staging: comedi: Fixed minor numbers for subdevice files.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index bacfa2b4b229..ed9f2bb88752 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2188,7 +2188,7 @@ int comedi_alloc_subdevice_minor(comedi_device *dev, comedi_subdevice *s)
 	info->read_subdevice = s;
 	info->write_subdevice = s;
 	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
-	for (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_BOARD_MINORS; ++i) {
+	for (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
 			comedi_file_info_table[i] = info;
 			break;

commit 1dd33ab8a9397793d65b9fc090174ff7cdfaff95
Author: Bernd Porr <BerndPorr@f2s.com>
Date:   Mon Dec 8 23:30:13 2008 +0000

    Staging: comedi: add comedi_num_legacy_minors module parameter
    
    As suggested the legacy device count is set to zero. A new module
    parameter for comedi_fops allows setting the number of legacy devices:
    comedi_num_legacy_minors. The default is zero.
    
    
    From: Bernd Porr <BerndPorr@f2s.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 682e648ff3dd..bacfa2b4b229 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -62,6 +62,9 @@ module_param(comedi_debug, int, 0644);
 int comedi_autoconfig = 1;
 module_param(comedi_autoconfig, bool, 0444);
 
+int comedi_num_legacy_minors = 0;
+module_param(comedi_num_legacy_minors, int, 0444);
+
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info
     *comedi_file_info_table[COMEDI_NUM_MINORS];
@@ -1896,7 +1899,7 @@ static void comedi_cleanup_legacy_minors(void)
 {
 	unsigned i;
 
-	for (i = 0; i < COMEDI_NUM_LEGACY_MINORS; i++)
+	for (i = 0; i < comedi_num_legacy_minors; i++)
 		comedi_free_board_minor(i);
 }
 
@@ -1936,7 +1939,7 @@ static int __init comedi_init(void)
 	comedi_proc_init();
 
 	/* create devices files for legacy/manual use */
-	for (i = 0; i < COMEDI_NUM_LEGACY_MINORS; i++) {
+	for (i = 0; i < comedi_num_legacy_minors; i++) {
 		int minor;
 		minor = comedi_alloc_board_minor(NULL);
 		if (minor < 0) {

commit 6a9d7a21d710e544df20266b83b7829d9f7a1020
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Dec 8 17:05:50 2008 +0000

    Staging: comedi: Add a module parameter 'comedi_autoconfig'.
    
    Set it to 0 or 'N' to disable autoconfiguration.
    It is enabled by default.
    
    From: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 018c964396df..682e648ff3dd 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -59,6 +59,9 @@ int comedi_debug;
 module_param(comedi_debug, int, 0644);
 #endif
 
+int comedi_autoconfig = 1;
+module_param(comedi_autoconfig, bool, 0444);
+
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info
     *comedi_file_info_table[COMEDI_NUM_MINORS];

commit 476b847733636ce5765093f5d1a369cc470e78e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 13 17:05:58 2008 -0800

    Staging: comedi: fix checkpatch.pl errors in comedi_fops.c
    
    There are still some >80 character lines in there, but
    this catches the majority of the issues.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index f44566416f5b..018c964396df 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -45,10 +45,10 @@
 #include "comedidev.h"
 #include <linux/cdev.h>
 
-#include <asm/io.h>
-#include <asm/uaccess.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
 
-//#include "kvmem.h"
+/* #include "kvmem.h" */
 
 MODULE_AUTHOR("http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi core module");
@@ -60,42 +60,44 @@ module_param(comedi_debug, int, 0644);
 #endif
 
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
-static struct comedi_device_file_info* comedi_file_info_table[COMEDI_NUM_MINORS];
-
-static int do_devconfig_ioctl(comedi_device * dev, comedi_devconfig * arg);
-static int do_bufconfig_ioctl(comedi_device * dev, void *arg);
-static int do_devinfo_ioctl(comedi_device * dev, comedi_devinfo * arg,
-	struct file *file);
-static int do_subdinfo_ioctl(comedi_device * dev, comedi_subdinfo * arg,
-	void *file);
-static int do_chaninfo_ioctl(comedi_device * dev, comedi_chaninfo * arg);
-static int do_bufinfo_ioctl(comedi_device * dev, void *arg);
-static int do_cmd_ioctl(comedi_device * dev, void *arg, void *file);
-static int do_lock_ioctl(comedi_device * dev, unsigned int arg, void *file);
-static int do_unlock_ioctl(comedi_device * dev, unsigned int arg, void *file);
-static int do_cancel_ioctl(comedi_device * dev, unsigned int arg, void *file);
-static int do_cmdtest_ioctl(comedi_device * dev, void *arg, void *file);
-static int do_insnlist_ioctl(comedi_device * dev, void *arg, void *file);
-static int do_insn_ioctl(comedi_device * dev, void *arg, void *file);
-static int do_poll_ioctl(comedi_device * dev, unsigned int subd, void *file);
-
-void do_become_nonbusy(comedi_device * dev, comedi_subdevice * s);
-static int do_cancel(comedi_device * dev, comedi_subdevice * s);
+static struct comedi_device_file_info
+    *comedi_file_info_table[COMEDI_NUM_MINORS];
+
+static int do_devconfig_ioctl(comedi_device *dev, comedi_devconfig *arg);
+static int do_bufconfig_ioctl(comedi_device *dev, void *arg);
+static int do_devinfo_ioctl(comedi_device *dev, comedi_devinfo *arg,
+			    struct file *file);
+static int do_subdinfo_ioctl(comedi_device *dev, comedi_subdinfo *arg,
+			     void *file);
+static int do_chaninfo_ioctl(comedi_device *dev, comedi_chaninfo *arg);
+static int do_bufinfo_ioctl(comedi_device *dev, void *arg);
+static int do_cmd_ioctl(comedi_device *dev, void *arg, void *file);
+static int do_lock_ioctl(comedi_device *dev, unsigned int arg, void *file);
+static int do_unlock_ioctl(comedi_device *dev, unsigned int arg, void *file);
+static int do_cancel_ioctl(comedi_device *dev, unsigned int arg, void *file);
+static int do_cmdtest_ioctl(comedi_device *dev, void *arg, void *file);
+static int do_insnlist_ioctl(comedi_device *dev, void *arg, void *file);
+static int do_insn_ioctl(comedi_device *dev, void *arg, void *file);
+static int do_poll_ioctl(comedi_device *dev, unsigned int subd, void *file);
+
+extern void do_become_nonbusy(comedi_device *dev, comedi_subdevice *s);
+static int do_cancel(comedi_device *dev, comedi_subdevice *s);
 
 static int comedi_fasync(int fd, struct file *file, int on);
 
-static int is_device_busy(comedi_device * dev);
+static int is_device_busy(comedi_device *dev);
 
 #ifdef HAVE_UNLOCKED_IOCTL
 static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
-	unsigned long arg)
+				  unsigned long arg)
 #else
 static int comedi_ioctl(struct inode *inode, struct file *file,
-	unsigned int cmd, unsigned long arg)
+			unsigned int cmd, unsigned long arg)
 #endif
 {
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	struct comedi_device_file_info *dev_file_info =
+	    comedi_get_device_file_info(minor);
 	comedi_device *dev = dev_file_info->device;
 	int rc;
 
@@ -162,7 +164,7 @@ static int comedi_ioctl(struct inode *inode, struct file *file,
 		break;
 	}
 
-      done:
+done:
 	mutex_unlock(&dev->mutex);
 	return rc;
 }
@@ -180,7 +182,7 @@ static int comedi_ioctl(struct inode *inode, struct file *file,
 	writes:
 		none
 */
-static int do_devconfig_ioctl(comedi_device * dev, comedi_devconfig * arg)
+static int do_devconfig_ioctl(comedi_device *dev, comedi_devconfig *arg)
 {
 	comedi_devconfig it;
 	int ret;
@@ -193,8 +195,7 @@ static int do_devconfig_ioctl(comedi_device * dev, comedi_devconfig * arg)
 	if (arg == NULL) {
 		if (is_device_busy(dev))
 			return -EBUSY;
-		if(dev->attached)
-		{
+		if (dev->attached) {
 			struct module *driver_module = dev->driver->module;
 			comedi_device_detach(dev);
 			module_put(driver_module);
@@ -208,7 +209,7 @@ static int do_devconfig_ioctl(comedi_device * dev, comedi_devconfig * arg)
 	it.board_name[COMEDI_NAMELEN - 1] = 0;
 
 	if (comedi_aux_data(it.options, 0) &&
-		it.options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
+	    it.options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
 		int bit_shift;
 		aux_len = it.options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
 		if (aux_len < 0)
@@ -219,24 +220,23 @@ static int do_devconfig_ioctl(comedi_device * dev, comedi_devconfig * arg)
 			return -ENOMEM;
 
 		if (copy_from_user(aux_data,
-				comedi_aux_data(it.options, 0), aux_len)) {
+				   comedi_aux_data(it.options, 0), aux_len)) {
 			vfree(aux_data);
 			return -EFAULT;
 		}
 		it.options[COMEDI_DEVCONF_AUX_DATA_LO] =
-			(unsigned long)aux_data;
+		    (unsigned long)aux_data;
 		if (sizeof(void *) > sizeof(int)) {
 			bit_shift = sizeof(int) * 8;
 			it.options[COMEDI_DEVCONF_AUX_DATA_HI] =
-				((unsigned long)aux_data) >> bit_shift;
+			    ((unsigned long)aux_data) >> bit_shift;
 		} else
 			it.options[COMEDI_DEVCONF_AUX_DATA_HI] = 0;
 	}
 
 	ret = comedi_device_attach(dev, &it);
-	if(ret == 0)
-	{
-		if(!try_module_get(dev->driver->module)) {
+	if (ret == 0) {
+		if (!try_module_get(dev->driver->module)) {
 			comedi_device_detach(dev);
 			return -ENOSYS;
 		}
@@ -262,7 +262,7 @@ static int do_devconfig_ioctl(comedi_device * dev, comedi_devconfig * arg)
 		modified bufconfig at arg
 
 */
-static int do_bufconfig_ioctl(comedi_device * dev, void *arg)
+static int do_bufconfig_ioctl(comedi_device *dev, void *arg)
 {
 	comedi_bufconfig bc;
 	comedi_async *async;
@@ -329,7 +329,7 @@ static int do_bufconfig_ioctl(comedi_device * dev, void *arg)
 	bc.size = async->prealloc_bufsz;
 	bc.maximum_size = async->max_bufsize;
 
-      copyback:
+copyback:
 	if (copy_to_user(arg, &bc, sizeof(comedi_bufconfig)))
 		return -EFAULT;
 
@@ -350,14 +350,17 @@ static int do_bufconfig_ioctl(comedi_device * dev, void *arg)
 		devinfo structure
 
 */
-static int do_devinfo_ioctl(comedi_device * dev, comedi_devinfo * arg,
-	struct file *file)
+static int do_devinfo_ioctl(comedi_device *dev, comedi_devinfo *arg,
+			    struct file *file)
 {
 	comedi_devinfo devinfo;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
-	comedi_subdevice *read_subdev = comedi_get_read_subdevice(dev_file_info);
-	comedi_subdevice *write_subdev = comedi_get_write_subdevice(dev_file_info);
+	struct comedi_device_file_info *dev_file_info =
+	    comedi_get_device_file_info(minor);
+	comedi_subdevice *read_subdev =
+	    comedi_get_read_subdevice(dev_file_info);
+	comedi_subdevice *write_subdev =
+	    comedi_get_write_subdevice(dev_file_info);
 
 	memset(&devinfo, 0, sizeof(devinfo));
 
@@ -367,16 +370,15 @@ static int do_devinfo_ioctl(comedi_device * dev, comedi_devinfo * arg,
 	memcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
 	memcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
 
-	if (read_subdev) {
+	if (read_subdev)
 		devinfo.read_subdevice = read_subdev - dev->subdevices;
-	} else {
+	else
 		devinfo.read_subdevice = -1;
-	}
-	if (write_subdev) {
+
+	if (write_subdev)
 		devinfo.write_subdevice = write_subdev - dev->subdevices;
-	} else {
+	else
 		devinfo.write_subdevice = -1;
-	}
 
 	if (copy_to_user(arg, &devinfo, sizeof(comedi_devinfo)))
 		return -EFAULT;
@@ -398,8 +400,8 @@ static int do_devinfo_ioctl(comedi_device * dev, comedi_devinfo * arg,
 		array of subdevice info structures at arg
 
 */
-static int do_subdinfo_ioctl(comedi_device * dev, comedi_subdinfo * arg,
-	void *file)
+static int do_subdinfo_ioctl(comedi_device *dev, comedi_subdinfo *arg,
+			     void *file)
 {
 	int ret, i;
 	comedi_subdinfo *tmp, *us;
@@ -425,8 +427,7 @@ static int do_subdinfo_ioctl(comedi_device * dev, comedi_subdinfo * arg,
 		us->maxdata = s->maxdata;
 		if (s->range_table) {
 			us->range_type =
-				(i << 24) | (0 << 16) | (s->
-				range_table->length);
+			    (i << 24) | (0 << 16) | (s->range_table->length);
 		} else {
 			us->range_type = 0;	/* XXX */
 		}
@@ -458,7 +459,7 @@ static int do_subdinfo_ioctl(comedi_device * dev, comedi_subdinfo * arg,
 	}
 
 	ret = copy_to_user(arg, tmp,
-		dev->n_subdevices * sizeof(comedi_subdinfo));
+			   dev->n_subdevices * sizeof(comedi_subdinfo));
 
 	kfree(tmp);
 
@@ -479,7 +480,7 @@ static int do_subdinfo_ioctl(comedi_device * dev, comedi_subdinfo * arg,
 		arrays at elements of chaninfo structure
 
 */
-static int do_chaninfo_ioctl(comedi_device * dev, comedi_chaninfo * arg)
+static int do_chaninfo_ioctl(comedi_device *dev, comedi_chaninfo *arg)
 {
 	comedi_subdevice *s;
 	comedi_chaninfo it;
@@ -495,7 +496,7 @@ static int do_chaninfo_ioctl(comedi_device * dev, comedi_chaninfo * arg)
 		if (s->maxdata || !s->maxdata_list)
 			return -EINVAL;
 		if (copy_to_user(it.maxdata_list, s->maxdata_list,
-				s->n_chan * sizeof(lsampl_t)))
+				 s->n_chan * sizeof(lsampl_t)))
 			return -EFAULT;
 	}
 
@@ -503,7 +504,7 @@ static int do_chaninfo_ioctl(comedi_device * dev, comedi_chaninfo * arg)
 		if (!s->flaglist)
 			return -EINVAL;
 		if (copy_to_user(it.flaglist, s->flaglist,
-				s->n_chan * sizeof(unsigned int)))
+				 s->n_chan * sizeof(unsigned int)))
 			return -EFAULT;
 	}
 
@@ -516,11 +517,14 @@ static int do_chaninfo_ioctl(comedi_device * dev, comedi_chaninfo * arg)
 			int x;
 
 			x = (dev->minor << 28) | (it.subdev << 24) | (i << 16) |
-				(s->range_table_list[i]->length);
+			    (s->range_table_list[i]->length);
 			put_user(x, it.rangelist + i);
 		}
-		//if(copy_to_user(it.rangelist,s->range_type_list,s->n_chan*sizeof(unsigned int)))
-		//      return -EFAULT;
+#if 0
+		if (copy_to_user(it.rangelist, s->range_type_list,
+				 s->n_chan*sizeof(unsigned int)))
+			return -EFAULT;
+#endif
 	}
 
 	return 0;
@@ -540,7 +544,7 @@ static int do_chaninfo_ioctl(comedi_device * dev, comedi_chaninfo * arg)
     modified bufinfo at arg
 
   */
-static int do_bufinfo_ioctl(comedi_device * dev, void *arg)
+static int do_bufinfo_ioctl(comedi_device *dev, void *arg)
 {
 	comedi_bufinfo bi;
 	comedi_subdevice *s;
@@ -569,15 +573,15 @@ static int do_bufinfo_ioctl(comedi_device * dev, void *arg)
 		comedi_buf_read_free(async, bi.bytes_read);
 
 		if (!(comedi_get_subdevice_runflags(s) & (SRF_ERROR |
-					SRF_RUNNING))
-			&& async->buf_write_count == async->buf_read_count) {
+							  SRF_RUNNING))
+		    && async->buf_write_count == async->buf_read_count) {
 			do_become_nonbusy(dev, s);
 		}
 	}
 
 	if (bi.bytes_written && (s->subdev_flags & SDF_CMD_WRITE)) {
 		bi.bytes_written =
-			comedi_buf_write_alloc(async, bi.bytes_written);
+		    comedi_buf_write_alloc(async, bi.bytes_written);
 		comedi_buf_write_free(async, bi.bytes_written);
 	}
 
@@ -586,15 +590,15 @@ static int do_bufinfo_ioctl(comedi_device * dev, void *arg)
 	bi.buf_read_count = async->buf_read_count;
 	bi.buf_read_ptr = async->buf_read_ptr;
 
-      copyback:
+copyback:
 	if (copy_to_user(arg, &bi, sizeof(comedi_bufinfo)))
 		return -EFAULT;
 
 	return 0;
 }
 
-static int parse_insn(comedi_device * dev, comedi_insn * insn, lsampl_t * data,
-	void *file);
+static int parse_insn(comedi_device *dev, comedi_insn *insn, lsampl_t *data,
+		      void *file);
 /*
  * 	COMEDI_INSNLIST
  * 	synchronous instructions
@@ -612,7 +616,7 @@ static int parse_insn(comedi_device * dev, comedi_insn * insn, lsampl_t * data,
  */
 /* arbitrary limits */
 #define MAX_SAMPLES 256
-static int do_insnlist_ioctl(comedi_device * dev, void *arg, void *file)
+static int do_insnlist_ioctl(comedi_device *dev, void *arg, void *file)
 {
 	comedi_insnlist insnlist;
 	comedi_insn *insns = NULL;
@@ -638,7 +642,7 @@ static int do_insnlist_ioctl(comedi_device * dev, void *arg, void *file)
 	}
 
 	if (copy_from_user(insns, insnlist.insns,
-			sizeof(comedi_insn) * insnlist.n_insns)) {
+			   sizeof(comedi_insn) * insnlist.n_insns)) {
 		DPRINTK("copy_from_user failed\n");
 		ret = -EFAULT;
 		goto error;
@@ -652,7 +656,7 @@ static int do_insnlist_ioctl(comedi_device * dev, void *arg, void *file)
 		}
 		if (insns[i].insn & INSN_MASK_WRITE) {
 			if (copy_from_user(data, insns[i].data,
-					insns[i].n * sizeof(lsampl_t))) {
+					   insns[i].n * sizeof(lsampl_t))) {
 				DPRINTK("copy_from_user failed\n");
 				ret = -EFAULT;
 				goto error;
@@ -663,7 +667,7 @@ static int do_insnlist_ioctl(comedi_device * dev, void *arg, void *file)
 			goto error;
 		if (insns[i].insn & INSN_MASK_READ) {
 			if (copy_to_user(insns[i].data, data,
-					insns[i].n * sizeof(lsampl_t))) {
+					 insns[i].n * sizeof(lsampl_t))) {
 				DPRINTK("copy_to_user failed\n");
 				ret = -EFAULT;
 				goto error;
@@ -673,20 +677,19 @@ static int do_insnlist_ioctl(comedi_device * dev, void *arg, void *file)
 			schedule();
 	}
 
-      error:
-	if (insns)
-		kfree(insns);
-	if (data)
-		kfree(data);
+error:
+	kfree(insns);
+	kfree(data);
 
 	if (ret < 0)
 		return ret;
 	return i;
 }
 
-static int check_insn_config_length(comedi_insn * insn, lsampl_t * data)
+static int check_insn_config_length(comedi_insn *insn, lsampl_t *data)
 {
-	if(insn->n < 1) return -EINVAL;
+	if (insn->n < 1)
+		return -EINVAL;
 
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
@@ -730,21 +733,22 @@ static int check_insn_config_length(comedi_insn * insn, lsampl_t * data)
 		if (insn->n == 5)
 			return 0;
 		break;
-		//by default we allow the insn since we don't have checks for all possible cases yet
+	/* by default we allow the insn since we don't have checks for
+	 * all possible cases yet */
 	default:
-		rt_printk
-			("comedi: no check for data length of config insn id %i is implemented.\n"
-			" Add a check to %s in %s.\n"
-			" Assuming n=%i is correct.\n", data[0], __FUNCTION__,
-			__FILE__, insn->n);
+		rt_printk("comedi: no check for data length of config insn id "
+			  "%i is implemented.\n"
+			  " Add a check to %s in %s.\n"
+			  " Assuming n=%i is correct.\n", data[0], __func__,
+			  __FILE__, insn->n);
 		return 0;
 		break;
 	}
 	return -EINVAL;
 }
 
-static int parse_insn(comedi_device * dev, comedi_insn * insn, lsampl_t * data,
-	void *file)
+static int parse_insn(comedi_device *dev, comedi_insn *insn, lsampl_t *data,
+		      void *file)
 {
 	comedi_subdevice *s;
 	int ret = 0;
@@ -833,7 +837,8 @@ static int parse_insn(comedi_device * dev, comedi_insn * insn, lsampl_t * data,
 			goto out;
 		}
 
-		if ((ret = check_chanlist(s, 1, &insn->chanspec)) < 0) {
+		ret = check_chanlist(s, 1, &insn->chanspec);
+		if (ret < 0) {
 			ret = -EINVAL;
 			DPRINTK("bad chanspec\n");
 			goto out;
@@ -851,8 +856,8 @@ static int parse_insn(comedi_device * dev, comedi_insn * insn, lsampl_t * data,
 			break;
 		case INSN_WRITE:
 			maxdata = s->maxdata_list
-				? s->maxdata_list[CR_CHAN(insn->chanspec)]
-				: s->maxdata;
+			    ? s->maxdata_list[CR_CHAN(insn->chanspec)]
+			    : s->maxdata;
 			for (i = 0; i < insn->n; ++i) {
 				if (data[i] > maxdata) {
 					ret = -EINVAL;
@@ -884,7 +889,7 @@ static int parse_insn(comedi_device * dev, comedi_insn * insn, lsampl_t * data,
 		s->busy = NULL;
 	}
 
-      out:
+out:
 	return ret;
 }
 
@@ -902,7 +907,7 @@ static int parse_insn(comedi_device * dev, comedi_insn * insn, lsampl_t * data,
  * 	writes:
  * 		data (for reads)
  */
-static int do_insn_ioctl(comedi_device * dev, void *arg, void *file)
+static int do_insn_ioctl(comedi_device *dev, void *arg, void *file)
 {
 	comedi_insn insn;
 	lsampl_t *data = NULL;
@@ -939,9 +944,8 @@ static int do_insn_ioctl(comedi_device * dev, void *arg, void *file)
 	}
 	ret = insn.n;
 
-      error:
-	if (data)
-		kfree(data);
+error:
+	kfree(data);
 
 	return ret;
 }
@@ -961,7 +965,7 @@ static int do_insn_ioctl(comedi_device * dev, void *arg, void *file)
 		modified cmd structure at arg
 
 */
-static int do_cmd_ioctl(comedi_device * dev, void *arg, void *file)
+static int do_cmd_ioctl(comedi_device *dev, void *arg, void *file)
 {
 	comedi_cmd user_cmd;
 	comedi_subdevice *s;
@@ -973,7 +977,7 @@ static int do_cmd_ioctl(comedi_device * dev, void *arg, void *file)
 		DPRINTK("bad cmd address\n");
 		return -EFAULT;
 	}
-	// save user's chanlist pointer so it can be restored later
+	/* save user's chanlist pointer so it can be restored later */
 	chanlist_saver = user_cmd.chanlist;
 
 	if (user_cmd.subdev >= dev->n_subdevices) {
@@ -1024,13 +1028,12 @@ static int do_cmd_ioctl(comedi_device * dev, void *arg, void *file)
 		goto cleanup;
 	}
 
-	if (async->cmd.chanlist)
-		kfree(async->cmd.chanlist);
+	kfree(async->cmd.chanlist);
 	async->cmd = user_cmd;
 	async->cmd.data = NULL;
 	/* load channel/gain list */
 	async->cmd.chanlist =
-		kmalloc(async->cmd.chanlist_len * sizeof(int), GFP_KERNEL);
+	    kmalloc(async->cmd.chanlist_len * sizeof(int), GFP_KERNEL);
 	if (!async->cmd.chanlist) {
 		DPRINTK("allocation failed\n");
 		ret = -ENOMEM;
@@ -1038,15 +1041,15 @@ static int do_cmd_ioctl(comedi_device * dev, void *arg, void *file)
 	}
 
 	if (copy_from_user(async->cmd.chanlist, user_cmd.chanlist,
-			async->cmd.chanlist_len * sizeof(int))) {
+			   async->cmd.chanlist_len * sizeof(int))) {
 		DPRINTK("fault reading chanlist\n");
 		ret = -EFAULT;
 		goto cleanup;
 	}
 
 	/* make sure each element in channel/gain list is valid */
-	if ((ret = check_chanlist(s, async->cmd.chanlist_len,
-				async->cmd.chanlist)) < 0) {
+	ret = check_chanlist(s, async->cmd.chanlist_len, async->cmd.chanlist);
+	if (ret < 0) {
 		DPRINTK("bad chanlist\n");
 		goto cleanup;
 	}
@@ -1056,7 +1059,7 @@ static int do_cmd_ioctl(comedi_device * dev, void *arg, void *file)
 	if (async->cmd.flags & TRIG_BOGUS || ret) {
 		DPRINTK("test returned %d\n", ret);
 		user_cmd = async->cmd;
-		// restore chanlist pointer before copying back
+		/* restore chanlist pointer before copying back */
 		user_cmd.chanlist = chanlist_saver;
 		user_cmd.data = NULL;
 		if (copy_to_user(arg, &user_cmd, sizeof(comedi_cmd))) {
@@ -1077,11 +1080,10 @@ static int do_cmd_ioctl(comedi_device * dev, void *arg, void *file)
 	comedi_reset_async_buf(async);
 
 	async->cb_mask =
-		COMEDI_CB_EOA | COMEDI_CB_BLOCK | COMEDI_CB_ERROR |
-		COMEDI_CB_OVERFLOW;
-	if (async->cmd.flags & TRIG_WAKE_EOS) {
+	    COMEDI_CB_EOA | COMEDI_CB_BLOCK | COMEDI_CB_ERROR |
+	    COMEDI_CB_OVERFLOW;
+	if (async->cmd.flags & TRIG_WAKE_EOS)
 		async->cb_mask |= COMEDI_CB_EOS;
-	}
 
 	comedi_set_subdevice_runflags(s, ~0, SRF_USER | SRF_RUNNING);
 
@@ -1096,7 +1098,7 @@ static int do_cmd_ioctl(comedi_device * dev, void *arg, void *file)
 	if (ret == 0)
 		return 0;
 
-      cleanup:
+cleanup:
 	do_become_nonbusy(dev, s);
 
 	return ret;
@@ -1117,7 +1119,7 @@ static int do_cmd_ioctl(comedi_device * dev, void *arg, void *file)
 		modified cmd structure at arg
 
 */
-static int do_cmdtest_ioctl(comedi_device * dev, void *arg, void *file)
+static int do_cmdtest_ioctl(comedi_device *dev, void *arg, void *file)
 {
 	comedi_cmd user_cmd;
 	comedi_subdevice *s;
@@ -1129,7 +1131,7 @@ static int do_cmdtest_ioctl(comedi_device * dev, void *arg, void *file)
 		DPRINTK("bad cmd address\n");
 		return -EFAULT;
 	}
-	// save user's chanlist pointer so it can be restored later
+	/* save user's chanlist pointer so it can be restored later */
 	chanlist_saver = user_cmd.chanlist;
 
 	if (user_cmd.subdev >= dev->n_subdevices) {
@@ -1160,8 +1162,7 @@ static int do_cmdtest_ioctl(comedi_device * dev, void *arg, void *file)
 	/* load channel/gain list */
 	if (user_cmd.chanlist) {
 		chanlist =
-			kmalloc(user_cmd.chanlist_len * sizeof(int),
-			GFP_KERNEL);
+		    kmalloc(user_cmd.chanlist_len * sizeof(int), GFP_KERNEL);
 		if (!chanlist) {
 			DPRINTK("allocation failed\n");
 			ret = -ENOMEM;
@@ -1169,15 +1170,15 @@ static int do_cmdtest_ioctl(comedi_device * dev, void *arg, void *file)
 		}
 
 		if (copy_from_user(chanlist, user_cmd.chanlist,
-				user_cmd.chanlist_len * sizeof(int))) {
+				   user_cmd.chanlist_len * sizeof(int))) {
 			DPRINTK("fault reading chanlist\n");
 			ret = -EFAULT;
 			goto cleanup;
 		}
 
 		/* make sure each element in channel/gain list is valid */
-		if ((ret = check_chanlist(s, user_cmd.chanlist_len,
-					chanlist)) < 0) {
+		ret = check_chanlist(s, user_cmd.chanlist_len, chanlist);
+		if (ret < 0) {
 			DPRINTK("bad chanlist\n");
 			goto cleanup;
 		}
@@ -1187,7 +1188,7 @@ static int do_cmdtest_ioctl(comedi_device * dev, void *arg, void *file)
 
 	ret = s->do_cmdtest(dev, s, &user_cmd);
 
-	// restore chanlist pointer before copying back
+	/* restore chanlist pointer before copying back */
 	user_cmd.chanlist = chanlist_saver;
 
 	if (copy_to_user(arg, &user_cmd, sizeof(comedi_cmd))) {
@@ -1195,9 +1196,8 @@ static int do_cmdtest_ioctl(comedi_device * dev, void *arg, void *file)
 		ret = -EFAULT;
 		goto cleanup;
 	}
-      cleanup:
-	if (chanlist)
-		kfree(chanlist);
+cleanup:
+	kfree(chanlist);
 
 	return ret;
 }
@@ -1217,7 +1217,7 @@ static int do_cmdtest_ioctl(comedi_device * dev, void *arg, void *file)
 
 */
 
-static int do_lock_ioctl(comedi_device * dev, unsigned int arg, void *file)
+static int do_lock_ioctl(comedi_device *dev, unsigned int arg, void *file)
 {
 	int ret = 0;
 	unsigned long flags;
@@ -1228,11 +1228,10 @@ static int do_lock_ioctl(comedi_device * dev, unsigned int arg, void *file)
 	s = dev->subdevices + arg;
 
 	comedi_spin_lock_irqsave(&s->spin_lock, flags);
-	if (s->busy || s->lock) {
+	if (s->busy || s->lock)
 		ret = -EBUSY;
-	} else {
+	else
 		s->lock = file;
-	}
 	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
 
 	if (ret < 0)
@@ -1262,7 +1261,7 @@ static int do_lock_ioctl(comedi_device * dev, unsigned int arg, void *file)
 	This function isn't protected by the semaphore, since
 	we already own the lock.
 */
-static int do_unlock_ioctl(comedi_device * dev, unsigned int arg, void *file)
+static int do_unlock_ioctl(comedi_device *dev, unsigned int arg, void *file)
 {
 	comedi_subdevice *s;
 
@@ -1302,7 +1301,7 @@ static int do_unlock_ioctl(comedi_device * dev, unsigned int arg, void *file)
 		nothing
 
 */
-static int do_cancel_ioctl(comedi_device * dev, unsigned int arg, void *file)
+static int do_cancel_ioctl(comedi_device *dev, unsigned int arg, void *file)
 {
 	comedi_subdevice *s;
 
@@ -1338,7 +1337,7 @@ static int do_cancel_ioctl(comedi_device * dev, unsigned int arg, void *file)
 		nothing
 
 */
-static int do_poll_ioctl(comedi_device * dev, unsigned int arg, void *file)
+static int do_poll_ioctl(comedi_device *dev, unsigned int arg, void *file)
 {
 	comedi_subdevice *s;
 
@@ -1361,7 +1360,7 @@ static int do_poll_ioctl(comedi_device * dev, unsigned int arg, void *file)
 	return -EINVAL;
 }
 
-static int do_cancel(comedi_device * dev, comedi_subdevice * s)
+static int do_cancel(comedi_device *dev, comedi_subdevice *s)
 {
 	int ret = 0;
 
@@ -1387,13 +1386,14 @@ void comedi_unmap(struct vm_area_struct *area)
 }
 
 static struct vm_operations_struct comedi_vm_ops = {
-      close:comedi_unmap,
+	.close =	comedi_unmap,
 };
 
 static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	struct comedi_device_file_info *dev_file_info =
+	    comedi_get_device_file_info(minor);
 	comedi_device *dev = dev_file_info->device;
 	comedi_async *async = NULL;
 	unsigned long start = vma->vm_start;
@@ -1409,11 +1409,11 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 		retval = -ENODEV;
 		goto done;
 	}
-	if (vma->vm_flags & VM_WRITE) {
+	if (vma->vm_flags & VM_WRITE)
 		s = comedi_get_write_subdevice(dev_file_info);
-	} else {
+	else
 		s = comedi_get_read_subdevice(dev_file_info);
-	}
+
 	if (s == NULL) {
 		retval = -EINVAL;
 		goto done;
@@ -1443,9 +1443,10 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	n_pages = size >> PAGE_SHIFT;
 	for (i = 0; i < n_pages; ++i) {
 		if (remap_pfn_range(vma, start,
-				page_to_pfn(virt_to_page(async->
-						buf_page_list[i].virt_addr)),
-				PAGE_SIZE, PAGE_SHARED)) {
+				    page_to_pfn(virt_to_page(async->
+							     buf_page_list[i].
+							     virt_addr)),
+				    PAGE_SIZE, PAGE_SHARED)) {
 			retval = -EAGAIN;
 			goto done;
 		}
@@ -1458,16 +1459,17 @@ static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
 	async->mmap_count++;
 
 	retval = 0;
-      done:
+done:
 	mutex_unlock(&dev->mutex);
 	return retval;
 }
 
-static unsigned int comedi_poll(struct file *file, poll_table * wait)
+static unsigned int comedi_poll(struct file *file, poll_table *wait)
 {
 	unsigned int mask = 0;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	struct comedi_device_file_info *dev_file_info =
+	    comedi_get_device_file_info(minor);
 	comedi_device *dev = dev_file_info->device;
 	comedi_subdevice *read_subdev;
 	comedi_subdevice *write_subdev;
@@ -1484,21 +1486,22 @@ static unsigned int comedi_poll(struct file *file, poll_table * wait)
 	if (read_subdev) {
 		poll_wait(file, &read_subdev->async->wait_head, wait);
 		if (!read_subdev->busy
-			|| comedi_buf_read_n_available(read_subdev->async) > 0
-			|| !(comedi_get_subdevice_runflags(read_subdev) &
-				SRF_RUNNING)) {
+		    || comedi_buf_read_n_available(read_subdev->async) > 0
+		    || !(comedi_get_subdevice_runflags(read_subdev) &
+			 SRF_RUNNING)) {
 			mask |= POLLIN | POLLRDNORM;
 		}
 	}
 	write_subdev = comedi_get_write_subdevice(dev_file_info);
 	if (write_subdev) {
 		poll_wait(file, &write_subdev->async->wait_head, wait);
-		comedi_buf_write_alloc(write_subdev->async, write_subdev->async->prealloc_bufsz);
+		comedi_buf_write_alloc(write_subdev->async,
+				       write_subdev->async->prealloc_bufsz);
 		if (!write_subdev->busy
-			|| !(comedi_get_subdevice_runflags(write_subdev) &
-				SRF_RUNNING)
-			|| comedi_buf_write_n_allocated(write_subdev->async) >=
-			bytes_per_sample(write_subdev->async->subdevice)) {
+		    || !(comedi_get_subdevice_runflags(write_subdev) &
+			 SRF_RUNNING)
+		    || comedi_buf_write_n_allocated(write_subdev->async) >=
+		    bytes_per_sample(write_subdev->async->subdevice)) {
 			mask |= POLLOUT | POLLWRNORM;
 		}
 	}
@@ -1508,14 +1511,15 @@ static unsigned int comedi_poll(struct file *file, poll_table * wait)
 }
 
 static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
-	loff_t * offset)
+			    loff_t *offset)
 {
 	comedi_subdevice *s;
 	comedi_async *async;
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	struct comedi_device_file_info *dev_file_info =
+	    comedi_get_device_file_info(minor);
 	comedi_device *dev = dev_file_info->device;
 
 	if (!dev->attached) {
@@ -1550,20 +1554,18 @@ static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
 		n = nbytes;
 
 		m = n;
-		if (async->buf_write_ptr + m > async->prealloc_bufsz) {
+		if (async->buf_write_ptr + m > async->prealloc_bufsz)
 			m = async->prealloc_bufsz - async->buf_write_ptr;
-		}
 		comedi_buf_write_alloc(async, async->prealloc_bufsz);
-		if (m > comedi_buf_write_n_allocated(async)) {
+		if (m > comedi_buf_write_n_allocated(async))
 			m = comedi_buf_write_n_allocated(async);
-		}
 		if (m < n)
 			n = m;
 
 		if (n == 0) {
 			if (!(comedi_get_subdevice_runflags(s) & SRF_RUNNING)) {
 				if (comedi_get_subdevice_runflags(s) &
-					SRF_ERROR) {
+				    SRF_ERROR) {
 					retval = -EPIPE;
 				} else {
 					retval = 0;
@@ -1580,9 +1582,8 @@ static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
 				break;
 			}
 			schedule();
-			if (!s->busy) {
+			if (!s->busy)
 				break;
-			}
 			if (s->busy != file) {
 				retval = -EACCES;
 				break;
@@ -1591,7 +1592,7 @@ static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
 		}
 
 		m = copy_from_user(async->prealloc_buf + async->buf_write_ptr,
-			buf, n);
+				   buf, n);
 		if (m) {
 			n -= m;
 			retval = -EFAULT;
@@ -1608,18 +1609,19 @@ static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
 	remove_wait_queue(&async->wait_head, &wait);
 
 done:
-	return (count ? count : retval);
+	return count ? count : retval;
 }
 
 static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
-	loff_t * offset)
+			   loff_t *offset)
 {
 	comedi_subdevice *s;
 	comedi_async *async;
 	int n, m, count = 0, retval = 0;
 	DECLARE_WAITQUEUE(wait, current);
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	struct comedi_device_file_info *dev_file_info =
+	    comedi_get_device_file_info(minor);
 	comedi_device *dev = dev_file_info->device;
 
 	if (!dev->attached) {
@@ -1654,11 +1656,10 @@ static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
 		n = nbytes;
 
 		m = comedi_buf_read_n_available(async);
-//printk("%d available\n",m);
-		if (async->buf_read_ptr + m > async->prealloc_bufsz) {
+		/* printk("%d available\n",m); */
+		if (async->buf_read_ptr + m > async->prealloc_bufsz)
 			m = async->prealloc_bufsz - async->buf_read_ptr;
-		}
-//printk("%d contiguous\n",m);
+		/* printk("%d contiguous\n",m); */
 		if (m < n)
 			n = m;
 
@@ -1666,7 +1667,7 @@ static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
 			if (!(comedi_get_subdevice_runflags(s) & SRF_RUNNING)) {
 				do_become_nonbusy(dev, s);
 				if (comedi_get_subdevice_runflags(s) &
-					SRF_ERROR) {
+				    SRF_ERROR) {
 					retval = -EPIPE;
 				} else {
 					retval = 0;
@@ -1693,7 +1694,7 @@ static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
 			continue;
 		}
 		m = copy_to_user(buf, async->prealloc_buf +
-			async->buf_read_ptr, n);
+				 async->buf_read_ptr, n);
 		if (m) {
 			n -= m;
 			retval = -EFAULT;
@@ -1709,20 +1710,20 @@ static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
 		break;		/* makes device work like a pipe */
 	}
 	if (!(comedi_get_subdevice_runflags(s) & (SRF_ERROR | SRF_RUNNING)) &&
-		async->buf_read_count - async->buf_write_count == 0) {
+	    async->buf_read_count - async->buf_write_count == 0) {
 		do_become_nonbusy(dev, s);
 	}
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(&async->wait_head, &wait);
 
 done:
-	return (count ? count : retval);
+	return count ? count : retval;
 }
 
 /*
    This function restores a subdevice to an idle state.
  */
-void do_become_nonbusy(comedi_device * dev, comedi_subdevice * s)
+void do_become_nonbusy(comedi_device *dev, comedi_subdevice *s)
 {
 	comedi_async *async = s->async;
 
@@ -1737,7 +1738,8 @@ void do_become_nonbusy(comedi_device * dev, comedi_subdevice * s)
 		comedi_reset_async_buf(async);
 		async->inttrig = NULL;
 	} else {
-		printk("BUG: (?) do_become_nonbusy called with async=0\n");
+		printk(KERN_ERR
+		       "BUG: (?) do_become_nonbusy called with async=0\n");
 	}
 
 	s->busy = NULL;
@@ -1747,7 +1749,8 @@ static int comedi_open(struct inode *inode, struct file *file)
 {
 	char mod[32];
 	const unsigned minor = iminor(inode);
-	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	struct comedi_device_file_info *dev_file_info =
+	    comedi_get_device_file_info(minor);
 	comedi_device *dev = dev_file_info->device;
 	if (dev == NULL) {
 		DPRINTK("invalid minor number\n");
@@ -1805,9 +1808,8 @@ static int comedi_open(struct inode *inode, struct file *file)
 		}
 	}
 
-	if (dev->attached && dev->use_count == 0 && dev->open) {
+	if (dev->attached && dev->use_count == 0 && dev->open)
 		dev->open(dev);
-	}
 
 	dev->use_count++;
 
@@ -1819,7 +1821,8 @@ static int comedi_open(struct inode *inode, struct file *file)
 static int comedi_close(struct inode *inode, struct file *file)
 {
 	const unsigned minor = iminor(inode);
-	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	struct comedi_device_file_info *dev_file_info =
+	    comedi_get_device_file_info(minor);
 	comedi_device *dev = dev_file_info->device;
 	comedi_subdevice *s = NULL;
 	int i;
@@ -1830,30 +1833,25 @@ static int comedi_close(struct inode *inode, struct file *file)
 		for (i = 0; i < dev->n_subdevices; i++) {
 			s = dev->subdevices + i;
 
-			if (s->busy == file) {
+			if (s->busy == file)
 				do_cancel(dev, s);
-			}
-			if (s->lock == file) {
+			if (s->lock == file)
 				s->lock = NULL;
-			}
 		}
 	}
-	if (dev->attached && dev->use_count == 1 && dev->close) {
+	if (dev->attached && dev->use_count == 1 && dev->close)
 		dev->close(dev);
-	}
 
 	module_put(THIS_MODULE);
-	if (dev->attached) {
+	if (dev->attached)
 		module_put(dev->driver->module);
-	}
 
 	dev->use_count--;
 
 	mutex_unlock(&dev->mutex);
 
-	if (file->f_flags & FASYNC) {
+	if (file->f_flags & FASYNC)
 		comedi_fasync(-1, file, 0);
-	}
 
 	return 0;
 }
@@ -1861,40 +1859,42 @@ static int comedi_close(struct inode *inode, struct file *file)
 static int comedi_fasync(int fd, struct file *file, int on)
 {
 	const unsigned minor = iminor(file->f_dentry->d_inode);
-	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	struct comedi_device_file_info *dev_file_info =
+	    comedi_get_device_file_info(minor);
+
 	comedi_device *dev = dev_file_info->device;
 
 	return fasync_helper(fd, file, on, &dev->async_queue);
 }
 
 const struct file_operations comedi_fops = {
-      owner:THIS_MODULE,
+      .owner =		THIS_MODULE,
 #ifdef HAVE_UNLOCKED_IOCTL
-      unlocked_ioctl:comedi_unlocked_ioctl,
+      .unlocked_ioctl =	comedi_unlocked_ioctl,
 #else
-      ioctl:comedi_ioctl,
+      .ioctl =		comedi_ioctl,
 #endif
 #ifdef HAVE_COMPAT_IOCTL
-      compat_ioctl:comedi_compat_ioctl,
+      .compat_ioctl =	comedi_compat_ioctl,
 #endif
-      open:comedi_open,
-      release:comedi_close,
-      read:comedi_read,
-      write:comedi_write,
-      mmap:comedi_mmap,
-      poll:comedi_poll,
-      fasync:comedi_fasync,
+      .open =		comedi_open,
+      .release =	comedi_close,
+      .read =		comedi_read,
+      .write =		comedi_write,
+      .mmap =		comedi_mmap,
+      .poll =		comedi_poll,
+      .fasync =		comedi_fasync,
 };
 
-struct class *comedi_class = NULL;
+struct class *comedi_class;
 static struct cdev comedi_cdev;
 
 static void comedi_cleanup_legacy_minors(void)
 {
 	unsigned i;
-	for (i = 0; i < COMEDI_NUM_LEGACY_MINORS; i++) {
+
+	for (i = 0; i < COMEDI_NUM_LEGACY_MINORS; i++)
 		comedi_free_board_minor(i);
-	}
 }
 
 static int __init comedi_init(void)
@@ -1902,13 +1902,14 @@ static int __init comedi_init(void)
 	int i;
 	int retval;
 
-	printk("comedi: version " COMEDI_RELEASE
-		" - http://www.comedi.org\n");
+	printk(KERN_INFO "comedi: version " COMEDI_RELEASE
+	       " - http://www.comedi.org\n");
 
-	memset(comedi_file_info_table, 0, sizeof(struct comedi_device_file_info*) * COMEDI_NUM_MINORS);
+	memset(comedi_file_info_table, 0,
+	       sizeof(struct comedi_device_file_info *) * COMEDI_NUM_MINORS);
 
 	retval = register_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-		COMEDI_NUM_MINORS, "comedi");
+					COMEDI_NUM_MINORS, "comedi");
 	if (retval)
 		return -EIO;
 	cdev_init(&comedi_cdev, &comedi_fops);
@@ -1916,7 +1917,7 @@ static int __init comedi_init(void)
 	kobject_set_name(&comedi_cdev.kobj, "comedi");
 	if (cdev_add(&comedi_cdev, MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS)) {
 		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-			COMEDI_NUM_MINORS);
+					 COMEDI_NUM_MINORS);
 		return -EIO;
 	}
 	comedi_class = class_create(THIS_MODULE, "comedi");
@@ -1924,23 +1925,22 @@ static int __init comedi_init(void)
 		printk("comedi: failed to create class");
 		cdev_del(&comedi_cdev);
 		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-			COMEDI_NUM_MINORS);
+					 COMEDI_NUM_MINORS);
 		return PTR_ERR(comedi_class);
 	}
 
 	/* XXX requires /proc interface */
 	comedi_proc_init();
 
-	// create devices files for legacy/manual use
+	/* create devices files for legacy/manual use */
 	for (i = 0; i < COMEDI_NUM_LEGACY_MINORS; i++) {
 		int minor;
 		minor = comedi_alloc_board_minor(NULL);
-		if(minor < 0)
-		{
+		if (minor < 0) {
 			comedi_cleanup_legacy_minors();
 			cdev_del(&comedi_cdev);
 			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
-				COMEDI_NUM_MINORS);
+						 COMEDI_NUM_MINORS);
 			return minor;
 		}
 	}
@@ -1957,10 +1957,9 @@ static void __exit comedi_cleanup(void)
 	int i;
 
 	comedi_cleanup_legacy_minors();
-	for(i = 0; i < COMEDI_NUM_MINORS; ++i)
-	{
+	for (i = 0; i < COMEDI_NUM_MINORS; ++i)
 		BUG_ON(comedi_file_info_table[i]);
-	}
+
 
 	class_destroy(comedi_class);
 	cdev_del(&comedi_cdev);
@@ -1976,26 +1975,25 @@ static void __exit comedi_cleanup(void)
 module_init(comedi_init);
 module_exit(comedi_cleanup);
 
-void comedi_error(const comedi_device * dev, const char *s)
+void comedi_error(const comedi_device *dev, const char *s)
 {
 	rt_printk("comedi%d: %s: %s\n", dev->minor, dev->driver->driver_name,
-		s);
+		  s);
 }
 
-void comedi_event(comedi_device * dev, comedi_subdevice * s)
+void comedi_event(comedi_device *dev, comedi_subdevice *s)
 {
 	comedi_async *async = s->async;
 	unsigned runflags = 0;
 	unsigned runflags_mask = 0;
 
-	//DPRINTK("comedi_event 0x%x\n",mask);
+	/* DPRINTK("comedi_event 0x%x\n",mask); */
 
 	if ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) == 0)
 		return;
 
 	if (s->async->
-		events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
-	{
+	    events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {
 		runflags_mask |= SRF_RUNNING;
 	}
 	/* remember if an error event has occured, so an error
@@ -2014,20 +2012,21 @@ void comedi_event(comedi_device * dev, comedi_subdevice * s)
 
 			if (dev->rt) {
 #ifdef CONFIG_COMEDI_RT
-				// pend wake up
+				/* pend wake up */
 				comedi_rt_pend_wakeup(&async->wait_head);
 #else
-				printk("BUG: comedi_event() code unreachable\n");
+				printk
+				    ("BUG: comedi_event() code unreachable\n");
 #endif
 			} else {
 				wake_up_interruptible(&async->wait_head);
 				if (s->subdev_flags & SDF_CMD_READ) {
 					kill_fasync(&dev->async_queue, SIGIO,
-						POLL_IN);
+						    POLL_IN);
 				}
 				if (s->subdev_flags & SDF_CMD_WRITE) {
 					kill_fasync(&dev->async_queue, SIGIO,
-						POLL_OUT);
+						    POLL_OUT);
 				}
 			}
 		} else {
@@ -2043,8 +2042,8 @@ void comedi_event(comedi_device * dev, comedi_subdevice * s)
 	s->async->events = 0;
 }
 
-void comedi_set_subdevice_runflags(comedi_subdevice * s, unsigned mask,
-	unsigned bits)
+void comedi_set_subdevice_runflags(comedi_subdevice *s, unsigned mask,
+				   unsigned bits)
 {
 	unsigned long flags;
 
@@ -2054,7 +2053,7 @@ void comedi_set_subdevice_runflags(comedi_subdevice * s, unsigned mask,
 	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
 }
 
-unsigned comedi_get_subdevice_runflags(comedi_subdevice * s)
+unsigned comedi_get_subdevice_runflags(comedi_subdevice *s)
 {
 	unsigned long flags;
 	unsigned runflags;
@@ -2065,7 +2064,7 @@ unsigned comedi_get_subdevice_runflags(comedi_subdevice * s)
 	return runflags;
 }
 
-static int is_device_busy(comedi_device * dev)
+static int is_device_busy(comedi_device *dev)
 {
 	comedi_subdevice *s;
 	int i;
@@ -2094,7 +2093,8 @@ void comedi_device_init(comedi_device *dev)
 
 void comedi_device_cleanup(comedi_device *dev)
 {
-	if(dev == NULL) return;
+	if (dev == NULL)
+		return;
 	mutex_lock(&dev->mutex);
 	comedi_device_detach(dev);
 	mutex_unlock(&dev->mutex);
@@ -2109,38 +2109,37 @@ int comedi_alloc_board_minor(struct device *hardware_device)
 	unsigned i;
 
 	info = kzalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
-	if(info == NULL) return -ENOMEM;
+	if (info == NULL)
+		return -ENOMEM;
 	info->device = kzalloc(sizeof(comedi_device), GFP_KERNEL);
-	if(info->device == NULL)
-	{
+	if (info->device == NULL) {
 		kfree(info);
 		return -ENOMEM;
 	}
 	comedi_device_init(info->device);
 	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
-	for(i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i)
-	{
-		if(comedi_file_info_table[i] == NULL)
-		{
+	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i) {
+		if (comedi_file_info_table[i] == NULL) {
 			comedi_file_info_table[i] = info;
 			break;
 		}
 	}
 	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
-	if(i == COMEDI_NUM_BOARD_MINORS)
-	{
+	if (i == COMEDI_NUM_BOARD_MINORS) {
 		comedi_device_cleanup(info->device);
 		kfree(info->device);
 		kfree(info);
-		rt_printk("comedi: error: ran out of minor numbers for board device files.\n");
+		rt_printk
+		    ("comedi: error: ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}
 	info->device->minor = i;
 	csdev = COMEDI_DEVICE_CREATE(comedi_class, NULL,
-		MKDEV(COMEDI_MAJOR, i), NULL, hardware_device, "comedi%i", i);
-	if(!IS_ERR(csdev)) {
+				     MKDEV(COMEDI_MAJOR, i), NULL,
+				     hardware_device, "comedi%i", i);
+	if (!IS_ERR(csdev))
 		info->device->class_dev = csdev;
-	}
+
 	return i;
 }
 
@@ -2155,14 +2154,12 @@ void comedi_free_board_minor(unsigned minor)
 	comedi_file_info_table[minor] = NULL;
 	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 
-	if(info)
-	{
+	if (info) {
 		comedi_device *dev = info->device;
-		if(dev)
-		{
-			if(dev->class_dev)
-			{
-				device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, dev->minor));
+		if (dev) {
+			if (dev->class_dev) {
+				device_destroy(comedi_class,
+					       MKDEV(COMEDI_MAJOR, dev->minor));
 			}
 			comedi_device_cleanup(dev);
 			kfree(dev);
@@ -2179,33 +2176,33 @@ int comedi_alloc_subdevice_minor(comedi_device *dev, comedi_subdevice *s)
 	unsigned i;
 
 	info = kmalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
-	if(info == NULL) return -ENOMEM;
+	if (info == NULL)
+		return -ENOMEM;
 	info->device = dev;
 	info->read_subdevice = s;
 	info->write_subdevice = s;
 	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
-	for(i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_BOARD_MINORS; ++i)
-	{
-		if(comedi_file_info_table[i] == NULL)
-		{
+	for (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_BOARD_MINORS; ++i) {
+		if (comedi_file_info_table[i] == NULL) {
 			comedi_file_info_table[i] = info;
 			break;
 		}
 	}
 	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
-	if(i == COMEDI_NUM_MINORS)
-	{
+	if (i == COMEDI_NUM_MINORS) {
 		kfree(info);
-		rt_printk("comedi: error: ran out of minor numbers for board device files.\n");
+		rt_printk
+		    ("comedi: error: ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}
 	s->minor = i;
 	csdev = COMEDI_DEVICE_CREATE(comedi_class, dev->class_dev,
-		MKDEV(COMEDI_MAJOR, i), NULL, NULL, "comedi%i_subd%i", dev->minor, (int)(s - dev->subdevices));
-	if(!IS_ERR(csdev))
-	{
+				     MKDEV(COMEDI_MAJOR, i), NULL, NULL,
+				     "comedi%i_subd%i", dev->minor,
+				     (int)(s - dev->subdevices));
+	if (!IS_ERR(csdev))
 		s->class_dev = csdev;
-	}
+
 	return i;
 }
 
@@ -2214,8 +2211,10 @@ void comedi_free_subdevice_minor(comedi_subdevice *s)
 	unsigned long flags;
 	struct comedi_device_file_info *info;
 
-	if(s == NULL) return;
-	if(s->minor < 0) return;
+	if (s == NULL)
+		return;
+	if (s->minor < 0)
+		return;
 
 	BUG_ON(s->minor >= COMEDI_NUM_MINORS);
 	BUG_ON(s->minor < COMEDI_FIRST_SUBDEVICE_MINOR);
@@ -2225,8 +2224,7 @@ void comedi_free_subdevice_minor(comedi_subdevice *s)
 	comedi_file_info_table[s->minor] = NULL;
 	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 
-	if(s->class_dev)
-	{
+	if (s->class_dev) {
 		device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, s->minor));
 		s->class_dev = NULL;
 	}

commit ed9eccbe8970f6eedc1b978c157caf1251a896d4
Author: David Schleef <ds@schleef.org>
Date:   Tue Nov 4 20:29:31 2008 -0800

    Staging: add comedi core
    
    This adds the Comedi core to the staging tree.
    This is a data acquision infrastructure for Linux, providing a common
    interface for these types of drivers.
    
    Taken directly from the comedi git tree, with only minor tweaks
    by Greg to get it to build properly within the kernel tree.
    
    From: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Shawn Bohrer <shawn.bohrer@gmail.com>
    Signed-off-by: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
new file mode 100644
index 000000000000..f44566416f5b
--- /dev/null
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -0,0 +1,2246 @@
+/*
+    comedi/comedi_fops.c
+    comedi kernel module
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 1997-2000 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#undef DEBUG
+
+#define __NO_VERSION__
+#include "comedi_fops.h"
+#include "comedi_compat32.h"
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fcntl.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/kmod.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include "comedidev.h"
+#include <linux/cdev.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+//#include "kvmem.h"
+
+MODULE_AUTHOR("http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi core module");
+MODULE_LICENSE("GPL");
+
+#ifdef CONFIG_COMEDI_DEBUG
+int comedi_debug;
+module_param(comedi_debug, int, 0644);
+#endif
+
+static DEFINE_SPINLOCK(comedi_file_info_table_lock);
+static struct comedi_device_file_info* comedi_file_info_table[COMEDI_NUM_MINORS];
+
+static int do_devconfig_ioctl(comedi_device * dev, comedi_devconfig * arg);
+static int do_bufconfig_ioctl(comedi_device * dev, void *arg);
+static int do_devinfo_ioctl(comedi_device * dev, comedi_devinfo * arg,
+	struct file *file);
+static int do_subdinfo_ioctl(comedi_device * dev, comedi_subdinfo * arg,
+	void *file);
+static int do_chaninfo_ioctl(comedi_device * dev, comedi_chaninfo * arg);
+static int do_bufinfo_ioctl(comedi_device * dev, void *arg);
+static int do_cmd_ioctl(comedi_device * dev, void *arg, void *file);
+static int do_lock_ioctl(comedi_device * dev, unsigned int arg, void *file);
+static int do_unlock_ioctl(comedi_device * dev, unsigned int arg, void *file);
+static int do_cancel_ioctl(comedi_device * dev, unsigned int arg, void *file);
+static int do_cmdtest_ioctl(comedi_device * dev, void *arg, void *file);
+static int do_insnlist_ioctl(comedi_device * dev, void *arg, void *file);
+static int do_insn_ioctl(comedi_device * dev, void *arg, void *file);
+static int do_poll_ioctl(comedi_device * dev, unsigned int subd, void *file);
+
+void do_become_nonbusy(comedi_device * dev, comedi_subdevice * s);
+static int do_cancel(comedi_device * dev, comedi_subdevice * s);
+
+static int comedi_fasync(int fd, struct file *file, int on);
+
+static int is_device_busy(comedi_device * dev);
+
+#ifdef HAVE_UNLOCKED_IOCTL
+static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,
+	unsigned long arg)
+#else
+static int comedi_ioctl(struct inode *inode, struct file *file,
+	unsigned int cmd, unsigned long arg)
+#endif
+{
+	const unsigned minor = iminor(file->f_dentry->d_inode);
+	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	comedi_device *dev = dev_file_info->device;
+	int rc;
+
+	mutex_lock(&dev->mutex);
+
+	/* Device config is special, because it must work on
+	 * an unconfigured device. */
+	if (cmd == COMEDI_DEVCONFIG) {
+		rc = do_devconfig_ioctl(dev, (void *)arg);
+		goto done;
+	}
+
+	if (!dev->attached) {
+		DPRINTK("no driver configured on /dev/comedi%i\n", dev->minor);
+		rc = -ENODEV;
+		goto done;
+	}
+
+	switch (cmd) {
+	case COMEDI_BUFCONFIG:
+		rc = do_bufconfig_ioctl(dev, (void *)arg);
+		break;
+	case COMEDI_DEVINFO:
+		rc = do_devinfo_ioctl(dev, (void *)arg, file);
+		break;
+	case COMEDI_SUBDINFO:
+		rc = do_subdinfo_ioctl(dev, (void *)arg, file);
+		break;
+	case COMEDI_CHANINFO:
+		rc = do_chaninfo_ioctl(dev, (void *)arg);
+		break;
+	case COMEDI_RANGEINFO:
+		rc = do_rangeinfo_ioctl(dev, (void *)arg);
+		break;
+	case COMEDI_BUFINFO:
+		rc = do_bufinfo_ioctl(dev, (void *)arg);
+		break;
+	case COMEDI_LOCK:
+		rc = do_lock_ioctl(dev, arg, file);
+		break;
+	case COMEDI_UNLOCK:
+		rc = do_unlock_ioctl(dev, arg, file);
+		break;
+	case COMEDI_CANCEL:
+		rc = do_cancel_ioctl(dev, arg, file);
+		break;
+	case COMEDI_CMD:
+		rc = do_cmd_ioctl(dev, (void *)arg, file);
+		break;
+	case COMEDI_CMDTEST:
+		rc = do_cmdtest_ioctl(dev, (void *)arg, file);
+		break;
+	case COMEDI_INSNLIST:
+		rc = do_insnlist_ioctl(dev, (void *)arg, file);
+		break;
+	case COMEDI_INSN:
+		rc = do_insn_ioctl(dev, (void *)arg, file);
+		break;
+	case COMEDI_POLL:
+		rc = do_poll_ioctl(dev, arg, file);
+		break;
+	default:
+		rc = -ENOTTY;
+		break;
+	}
+
+      done:
+	mutex_unlock(&dev->mutex);
+	return rc;
+}
+
+/*
+	COMEDI_DEVCONFIG
+	device config ioctl
+
+	arg:
+		pointer to devconfig structure
+
+	reads:
+		devconfig structure at arg
+
+	writes:
+		none
+*/
+static int do_devconfig_ioctl(comedi_device * dev, comedi_devconfig * arg)
+{
+	comedi_devconfig it;
+	int ret;
+	unsigned char *aux_data = NULL;
+	int aux_len;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (arg == NULL) {
+		if (is_device_busy(dev))
+			return -EBUSY;
+		if(dev->attached)
+		{
+			struct module *driver_module = dev->driver->module;
+			comedi_device_detach(dev);
+			module_put(driver_module);
+		}
+		return 0;
+	}
+
+	if (copy_from_user(&it, arg, sizeof(comedi_devconfig)))
+		return -EFAULT;
+
+	it.board_name[COMEDI_NAMELEN - 1] = 0;
+
+	if (comedi_aux_data(it.options, 0) &&
+		it.options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
+		int bit_shift;
+		aux_len = it.options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
+		if (aux_len < 0)
+			return -EFAULT;
+
+		aux_data = vmalloc(aux_len);
+		if (!aux_data)
+			return -ENOMEM;
+
+		if (copy_from_user(aux_data,
+				comedi_aux_data(it.options, 0), aux_len)) {
+			vfree(aux_data);
+			return -EFAULT;
+		}
+		it.options[COMEDI_DEVCONF_AUX_DATA_LO] =
+			(unsigned long)aux_data;
+		if (sizeof(void *) > sizeof(int)) {
+			bit_shift = sizeof(int) * 8;
+			it.options[COMEDI_DEVCONF_AUX_DATA_HI] =
+				((unsigned long)aux_data) >> bit_shift;
+		} else
+			it.options[COMEDI_DEVCONF_AUX_DATA_HI] = 0;
+	}
+
+	ret = comedi_device_attach(dev, &it);
+	if(ret == 0)
+	{
+		if(!try_module_get(dev->driver->module)) {
+			comedi_device_detach(dev);
+			return -ENOSYS;
+		}
+	}
+
+	if (aux_data)
+		vfree(aux_data);
+
+	return ret;
+}
+
+/*
+	COMEDI_BUFCONFIG
+	buffer configuration ioctl
+
+	arg:
+		pointer to bufconfig structure
+
+	reads:
+		bufconfig at arg
+
+	writes:
+		modified bufconfig at arg
+
+*/
+static int do_bufconfig_ioctl(comedi_device * dev, void *arg)
+{
+	comedi_bufconfig bc;
+	comedi_async *async;
+	comedi_subdevice *s;
+	int ret = 0;
+
+	if (copy_from_user(&bc, arg, sizeof(comedi_bufconfig)))
+		return -EFAULT;
+
+	if (bc.subdevice >= dev->n_subdevices || bc.subdevice < 0)
+		return -EINVAL;
+
+	s = dev->subdevices + bc.subdevice;
+	async = s->async;
+
+	if (!async) {
+		DPRINTK("subdevice does not have async capability\n");
+		bc.size = 0;
+		bc.maximum_size = 0;
+		goto copyback;
+	}
+
+	if (bc.maximum_size) {
+		if (!capable(CAP_SYS_ADMIN))
+			return -EPERM;
+
+		async->max_bufsize = bc.maximum_size;
+	}
+
+	if (bc.size) {
+		if (bc.size > async->max_bufsize)
+			return -EPERM;
+
+		if (s->busy) {
+			DPRINTK("subdevice is busy, cannot resize buffer\n");
+			return -EBUSY;
+		}
+		if (async->mmap_count) {
+			DPRINTK("subdevice is mmapped, cannot resize buffer\n");
+			return -EBUSY;
+		}
+
+		if (!async->prealloc_buf)
+			return -EINVAL;
+
+		/* make sure buffer is an integral number of pages
+		 * (we round up) */
+		bc.size = (bc.size + PAGE_SIZE - 1) & PAGE_MASK;
+
+		ret = comedi_buf_alloc(dev, s, bc.size);
+		if (ret < 0)
+			return ret;
+
+		if (s->buf_change) {
+			ret = s->buf_change(dev, s, bc.size);
+			if (ret < 0)
+				return ret;
+		}
+
+		DPRINTK("comedi%i subd %d buffer resized to %i bytes\n",
+			dev->minor, bc.subdevice, async->prealloc_bufsz);
+	}
+
+	bc.size = async->prealloc_bufsz;
+	bc.maximum_size = async->max_bufsize;
+
+      copyback:
+	if (copy_to_user(arg, &bc, sizeof(comedi_bufconfig)))
+		return -EFAULT;
+
+	return 0;
+}
+
+/*
+	COMEDI_DEVINFO
+	device info ioctl
+
+	arg:
+		pointer to devinfo structure
+
+	reads:
+		none
+
+	writes:
+		devinfo structure
+
+*/
+static int do_devinfo_ioctl(comedi_device * dev, comedi_devinfo * arg,
+	struct file *file)
+{
+	comedi_devinfo devinfo;
+	const unsigned minor = iminor(file->f_dentry->d_inode);
+	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	comedi_subdevice *read_subdev = comedi_get_read_subdevice(dev_file_info);
+	comedi_subdevice *write_subdev = comedi_get_write_subdevice(dev_file_info);
+
+	memset(&devinfo, 0, sizeof(devinfo));
+
+	/* fill devinfo structure */
+	devinfo.version_code = COMEDI_VERSION_CODE;
+	devinfo.n_subdevs = dev->n_subdevices;
+	memcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
+	memcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
+
+	if (read_subdev) {
+		devinfo.read_subdevice = read_subdev - dev->subdevices;
+	} else {
+		devinfo.read_subdevice = -1;
+	}
+	if (write_subdev) {
+		devinfo.write_subdevice = write_subdev - dev->subdevices;
+	} else {
+		devinfo.write_subdevice = -1;
+	}
+
+	if (copy_to_user(arg, &devinfo, sizeof(comedi_devinfo)))
+		return -EFAULT;
+
+	return 0;
+}
+
+/*
+	COMEDI_SUBDINFO
+	subdevice info ioctl
+
+	arg:
+		pointer to array of subdevice info structures
+
+	reads:
+		none
+
+	writes:
+		array of subdevice info structures at arg
+
+*/
+static int do_subdinfo_ioctl(comedi_device * dev, comedi_subdinfo * arg,
+	void *file)
+{
+	int ret, i;
+	comedi_subdinfo *tmp, *us;
+	comedi_subdevice *s;
+
+	tmp = kcalloc(dev->n_subdevices, sizeof(comedi_subdinfo), GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+
+	/* fill subdinfo structs */
+	for (i = 0; i < dev->n_subdevices; i++) {
+		s = dev->subdevices + i;
+		us = tmp + i;
+
+		us->type = s->type;
+		us->n_chan = s->n_chan;
+		us->subd_flags = s->subdev_flags;
+		if (comedi_get_subdevice_runflags(s) & SRF_RUNNING)
+			us->subd_flags |= SDF_RUNNING;
+#define TIMER_nanosec 5		/* backwards compatibility */
+		us->timer_type = TIMER_nanosec;
+		us->len_chanlist = s->len_chanlist;
+		us->maxdata = s->maxdata;
+		if (s->range_table) {
+			us->range_type =
+				(i << 24) | (0 << 16) | (s->
+				range_table->length);
+		} else {
+			us->range_type = 0;	/* XXX */
+		}
+		us->flags = s->flags;
+
+		if (s->busy)
+			us->subd_flags |= SDF_BUSY;
+		if (s->busy == file)
+			us->subd_flags |= SDF_BUSY_OWNER;
+		if (s->lock)
+			us->subd_flags |= SDF_LOCKED;
+		if (s->lock == file)
+			us->subd_flags |= SDF_LOCK_OWNER;
+		if (!s->maxdata && s->maxdata_list)
+			us->subd_flags |= SDF_MAXDATA;
+		if (s->flaglist)
+			us->subd_flags |= SDF_FLAGS;
+		if (s->range_table_list)
+			us->subd_flags |= SDF_RANGETYPE;
+		if (s->do_cmd)
+			us->subd_flags |= SDF_CMD;
+
+		if (s->insn_bits != &insn_inval)
+			us->insn_bits_support = COMEDI_SUPPORTED;
+		else
+			us->insn_bits_support = COMEDI_UNSUPPORTED;
+
+		us->settling_time_0 = s->settling_time_0;
+	}
+
+	ret = copy_to_user(arg, tmp,
+		dev->n_subdevices * sizeof(comedi_subdinfo));
+
+	kfree(tmp);
+
+	return ret ? -EFAULT : 0;
+}
+
+/*
+	COMEDI_CHANINFO
+	subdevice info ioctl
+
+	arg:
+		pointer to chaninfo structure
+
+	reads:
+		chaninfo structure at arg
+
+	writes:
+		arrays at elements of chaninfo structure
+
+*/
+static int do_chaninfo_ioctl(comedi_device * dev, comedi_chaninfo * arg)
+{
+	comedi_subdevice *s;
+	comedi_chaninfo it;
+
+	if (copy_from_user(&it, arg, sizeof(comedi_chaninfo)))
+		return -EFAULT;
+
+	if (it.subdev >= dev->n_subdevices)
+		return -EINVAL;
+	s = dev->subdevices + it.subdev;
+
+	if (it.maxdata_list) {
+		if (s->maxdata || !s->maxdata_list)
+			return -EINVAL;
+		if (copy_to_user(it.maxdata_list, s->maxdata_list,
+				s->n_chan * sizeof(lsampl_t)))
+			return -EFAULT;
+	}
+
+	if (it.flaglist) {
+		if (!s->flaglist)
+			return -EINVAL;
+		if (copy_to_user(it.flaglist, s->flaglist,
+				s->n_chan * sizeof(unsigned int)))
+			return -EFAULT;
+	}
+
+	if (it.rangelist) {
+		int i;
+
+		if (!s->range_table_list)
+			return -EINVAL;
+		for (i = 0; i < s->n_chan; i++) {
+			int x;
+
+			x = (dev->minor << 28) | (it.subdev << 24) | (i << 16) |
+				(s->range_table_list[i]->length);
+			put_user(x, it.rangelist + i);
+		}
+		//if(copy_to_user(it.rangelist,s->range_type_list,s->n_chan*sizeof(unsigned int)))
+		//      return -EFAULT;
+	}
+
+	return 0;
+}
+
+ /*
+    COMEDI_BUFINFO
+    buffer information ioctl
+
+    arg:
+    pointer to bufinfo structure
+
+    reads:
+    bufinfo at arg
+
+    writes:
+    modified bufinfo at arg
+
+  */
+static int do_bufinfo_ioctl(comedi_device * dev, void *arg)
+{
+	comedi_bufinfo bi;
+	comedi_subdevice *s;
+	comedi_async *async;
+
+	if (copy_from_user(&bi, arg, sizeof(comedi_bufinfo)))
+		return -EFAULT;
+
+	if (bi.subdevice >= dev->n_subdevices || bi.subdevice < 0)
+		return -EINVAL;
+
+	s = dev->subdevices + bi.subdevice;
+	async = s->async;
+
+	if (!async) {
+		DPRINTK("subdevice does not have async capability\n");
+		bi.buf_write_ptr = 0;
+		bi.buf_read_ptr = 0;
+		bi.buf_write_count = 0;
+		bi.buf_read_count = 0;
+		goto copyback;
+	}
+
+	if (bi.bytes_read && (s->subdev_flags & SDF_CMD_READ)) {
+		bi.bytes_read = comedi_buf_read_alloc(async, bi.bytes_read);
+		comedi_buf_read_free(async, bi.bytes_read);
+
+		if (!(comedi_get_subdevice_runflags(s) & (SRF_ERROR |
+					SRF_RUNNING))
+			&& async->buf_write_count == async->buf_read_count) {
+			do_become_nonbusy(dev, s);
+		}
+	}
+
+	if (bi.bytes_written && (s->subdev_flags & SDF_CMD_WRITE)) {
+		bi.bytes_written =
+			comedi_buf_write_alloc(async, bi.bytes_written);
+		comedi_buf_write_free(async, bi.bytes_written);
+	}
+
+	bi.buf_write_count = async->buf_write_count;
+	bi.buf_write_ptr = async->buf_write_ptr;
+	bi.buf_read_count = async->buf_read_count;
+	bi.buf_read_ptr = async->buf_read_ptr;
+
+      copyback:
+	if (copy_to_user(arg, &bi, sizeof(comedi_bufinfo)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int parse_insn(comedi_device * dev, comedi_insn * insn, lsampl_t * data,
+	void *file);
+/*
+ * 	COMEDI_INSNLIST
+ * 	synchronous instructions
+ *
+ * 	arg:
+ * 		pointer to sync cmd structure
+ *
+ * 	reads:
+ * 		sync cmd struct at arg
+ * 		instruction list
+ * 		data (for writes)
+ *
+ * 	writes:
+ * 		data (for reads)
+ */
+/* arbitrary limits */
+#define MAX_SAMPLES 256
+static int do_insnlist_ioctl(comedi_device * dev, void *arg, void *file)
+{
+	comedi_insnlist insnlist;
+	comedi_insn *insns = NULL;
+	lsampl_t *data = NULL;
+	int i = 0;
+	int ret = 0;
+
+	if (copy_from_user(&insnlist, arg, sizeof(comedi_insnlist)))
+		return -EFAULT;
+
+	data = kmalloc(sizeof(lsampl_t) * MAX_SAMPLES, GFP_KERNEL);
+	if (!data) {
+		DPRINTK("kmalloc failed\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	insns = kmalloc(sizeof(comedi_insn) * insnlist.n_insns, GFP_KERNEL);
+	if (!insns) {
+		DPRINTK("kmalloc failed\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	if (copy_from_user(insns, insnlist.insns,
+			sizeof(comedi_insn) * insnlist.n_insns)) {
+		DPRINTK("copy_from_user failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	for (i = 0; i < insnlist.n_insns; i++) {
+		if (insns[i].n > MAX_SAMPLES) {
+			DPRINTK("number of samples too large\n");
+			ret = -EINVAL;
+			goto error;
+		}
+		if (insns[i].insn & INSN_MASK_WRITE) {
+			if (copy_from_user(data, insns[i].data,
+					insns[i].n * sizeof(lsampl_t))) {
+				DPRINTK("copy_from_user failed\n");
+				ret = -EFAULT;
+				goto error;
+			}
+		}
+		ret = parse_insn(dev, insns + i, data, file);
+		if (ret < 0)
+			goto error;
+		if (insns[i].insn & INSN_MASK_READ) {
+			if (copy_to_user(insns[i].data, data,
+					insns[i].n * sizeof(lsampl_t))) {
+				DPRINTK("copy_to_user failed\n");
+				ret = -EFAULT;
+				goto error;
+			}
+		}
+		if (need_resched())
+			schedule();
+	}
+
+      error:
+	if (insns)
+		kfree(insns);
+	if (data)
+		kfree(data);
+
+	if (ret < 0)
+		return ret;
+	return i;
+}
+
+static int check_insn_config_length(comedi_insn * insn, lsampl_t * data)
+{
+	if(insn->n < 1) return -EINVAL;
+
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+	case INSN_CONFIG_DIO_INPUT:
+	case INSN_CONFIG_DISARM:
+	case INSN_CONFIG_RESET:
+		if (insn->n == 1)
+			return 0;
+		break;
+	case INSN_CONFIG_ARM:
+	case INSN_CONFIG_DIO_QUERY:
+	case INSN_CONFIG_BLOCK_SIZE:
+	case INSN_CONFIG_FILTER:
+	case INSN_CONFIG_SERIAL_CLOCK:
+	case INSN_CONFIG_BIDIRECTIONAL_DATA:
+	case INSN_CONFIG_ALT_SOURCE:
+	case INSN_CONFIG_SET_COUNTER_MODE:
+	case INSN_CONFIG_8254_READ_STATUS:
+	case INSN_CONFIG_SET_ROUTING:
+	case INSN_CONFIG_GET_ROUTING:
+	case INSN_CONFIG_GET_PWM_STATUS:
+	case INSN_CONFIG_PWM_SET_PERIOD:
+	case INSN_CONFIG_PWM_GET_PERIOD:
+		if (insn->n == 2)
+			return 0;
+		break;
+	case INSN_CONFIG_SET_GATE_SRC:
+	case INSN_CONFIG_GET_GATE_SRC:
+	case INSN_CONFIG_SET_CLOCK_SRC:
+	case INSN_CONFIG_GET_CLOCK_SRC:
+	case INSN_CONFIG_SET_OTHER_SRC:
+	case INSN_CONFIG_GET_COUNTER_STATUS:
+	case INSN_CONFIG_PWM_SET_H_BRIDGE:
+	case INSN_CONFIG_PWM_GET_H_BRIDGE:
+	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
+		if (insn->n == 3)
+			return 0;
+		break;
+	case INSN_CONFIG_PWM_OUTPUT:
+	case INSN_CONFIG_ANALOG_TRIG:
+		if (insn->n == 5)
+			return 0;
+		break;
+		//by default we allow the insn since we don't have checks for all possible cases yet
+	default:
+		rt_printk
+			("comedi: no check for data length of config insn id %i is implemented.\n"
+			" Add a check to %s in %s.\n"
+			" Assuming n=%i is correct.\n", data[0], __FUNCTION__,
+			__FILE__, insn->n);
+		return 0;
+		break;
+	}
+	return -EINVAL;
+}
+
+static int parse_insn(comedi_device * dev, comedi_insn * insn, lsampl_t * data,
+	void *file)
+{
+	comedi_subdevice *s;
+	int ret = 0;
+	int i;
+
+	if (insn->insn & INSN_MASK_SPECIAL) {
+		/* a non-subdevice instruction */
+
+		switch (insn->insn) {
+		case INSN_GTOD:
+			{
+				struct timeval tv;
+
+				if (insn->n != 2) {
+					ret = -EINVAL;
+					break;
+				}
+
+				do_gettimeofday(&tv);
+				data[0] = tv.tv_sec;
+				data[1] = tv.tv_usec;
+				ret = 2;
+
+				break;
+			}
+		case INSN_WAIT:
+			if (insn->n != 1 || data[0] >= 100000) {
+				ret = -EINVAL;
+				break;
+			}
+			udelay(data[0] / 1000);
+			ret = 1;
+			break;
+		case INSN_INTTRIG:
+			if (insn->n != 1) {
+				ret = -EINVAL;
+				break;
+			}
+			if (insn->subdev >= dev->n_subdevices) {
+				DPRINTK("%d not usable subdevice\n",
+					insn->subdev);
+				ret = -EINVAL;
+				break;
+			}
+			s = dev->subdevices + insn->subdev;
+			if (!s->async) {
+				DPRINTK("no async\n");
+				ret = -EINVAL;
+				break;
+			}
+			if (!s->async->inttrig) {
+				DPRINTK("no inttrig\n");
+				ret = -EAGAIN;
+				break;
+			}
+			ret = s->async->inttrig(dev, s, insn->data[0]);
+			if (ret >= 0)
+				ret = 1;
+			break;
+		default:
+			DPRINTK("invalid insn\n");
+			ret = -EINVAL;
+			break;
+		}
+	} else {
+		/* a subdevice instruction */
+		lsampl_t maxdata;
+
+		if (insn->subdev >= dev->n_subdevices) {
+			DPRINTK("subdevice %d out of range\n", insn->subdev);
+			ret = -EINVAL;
+			goto out;
+		}
+		s = dev->subdevices + insn->subdev;
+
+		if (s->type == COMEDI_SUBD_UNUSED) {
+			DPRINTK("%d not usable subdevice\n", insn->subdev);
+			ret = -EIO;
+			goto out;
+		}
+
+		/* are we locked? (ioctl lock) */
+		if (s->lock && s->lock != file) {
+			DPRINTK("device locked\n");
+			ret = -EACCES;
+			goto out;
+		}
+
+		if ((ret = check_chanlist(s, 1, &insn->chanspec)) < 0) {
+			ret = -EINVAL;
+			DPRINTK("bad chanspec\n");
+			goto out;
+		}
+
+		if (s->busy) {
+			ret = -EBUSY;
+			goto out;
+		}
+		/* This looks arbitrary.  It is. */
+		s->busy = &parse_insn;
+		switch (insn->insn) {
+		case INSN_READ:
+			ret = s->insn_read(dev, s, insn, data);
+			break;
+		case INSN_WRITE:
+			maxdata = s->maxdata_list
+				? s->maxdata_list[CR_CHAN(insn->chanspec)]
+				: s->maxdata;
+			for (i = 0; i < insn->n; ++i) {
+				if (data[i] > maxdata) {
+					ret = -EINVAL;
+					DPRINTK("bad data value(s)\n");
+					break;
+				}
+			}
+			if (ret == 0)
+				ret = s->insn_write(dev, s, insn, data);
+			break;
+		case INSN_BITS:
+			if (insn->n != 2) {
+				ret = -EINVAL;
+				break;
+			}
+			ret = s->insn_bits(dev, s, insn, data);
+			break;
+		case INSN_CONFIG:
+			ret = check_insn_config_length(insn, data);
+			if (ret)
+				break;
+			ret = s->insn_config(dev, s, insn, data);
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+
+		s->busy = NULL;
+	}
+
+      out:
+	return ret;
+}
+
+/*
+ * 	COMEDI_INSN
+ * 	synchronous instructions
+ *
+ * 	arg:
+ * 		pointer to insn
+ *
+ * 	reads:
+ * 		comedi_insn struct at arg
+ * 		data (for writes)
+ *
+ * 	writes:
+ * 		data (for reads)
+ */
+static int do_insn_ioctl(comedi_device * dev, void *arg, void *file)
+{
+	comedi_insn insn;
+	lsampl_t *data = NULL;
+	int ret = 0;
+
+	data = kmalloc(sizeof(lsampl_t) * MAX_SAMPLES, GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	if (copy_from_user(&insn, arg, sizeof(comedi_insn))) {
+		ret = -EFAULT;
+		goto error;
+	}
+
+	/* This is where the behavior of insn and insnlist deviate. */
+	if (insn.n > MAX_SAMPLES)
+		insn.n = MAX_SAMPLES;
+	if (insn.insn & INSN_MASK_WRITE) {
+		if (copy_from_user(data, insn.data, insn.n * sizeof(lsampl_t))) {
+			ret = -EFAULT;
+			goto error;
+		}
+	}
+	ret = parse_insn(dev, &insn, data, file);
+	if (ret < 0)
+		goto error;
+	if (insn.insn & INSN_MASK_READ) {
+		if (copy_to_user(insn.data, data, insn.n * sizeof(lsampl_t))) {
+			ret = -EFAULT;
+			goto error;
+		}
+	}
+	ret = insn.n;
+
+      error:
+	if (data)
+		kfree(data);
+
+	return ret;
+}
+
+/*
+	COMEDI_CMD
+	command ioctl
+
+	arg:
+		pointer to cmd structure
+
+	reads:
+		cmd structure at arg
+		channel/range list
+
+	writes:
+		modified cmd structure at arg
+
+*/
+static int do_cmd_ioctl(comedi_device * dev, void *arg, void *file)
+{
+	comedi_cmd user_cmd;
+	comedi_subdevice *s;
+	comedi_async *async;
+	int ret = 0;
+	unsigned int *chanlist_saver = NULL;
+
+	if (copy_from_user(&user_cmd, arg, sizeof(comedi_cmd))) {
+		DPRINTK("bad cmd address\n");
+		return -EFAULT;
+	}
+	// save user's chanlist pointer so it can be restored later
+	chanlist_saver = user_cmd.chanlist;
+
+	if (user_cmd.subdev >= dev->n_subdevices) {
+		DPRINTK("%d no such subdevice\n", user_cmd.subdev);
+		return -ENODEV;
+	}
+
+	s = dev->subdevices + user_cmd.subdev;
+	async = s->async;
+
+	if (s->type == COMEDI_SUBD_UNUSED) {
+		DPRINTK("%d not valid subdevice\n", user_cmd.subdev);
+		return -EIO;
+	}
+
+	if (!s->do_cmd || !s->do_cmdtest || !s->async) {
+		DPRINTK("subdevice %i does not support commands\n",
+			user_cmd.subdev);
+		return -EIO;
+	}
+
+	/* are we locked? (ioctl lock) */
+	if (s->lock && s->lock != file) {
+		DPRINTK("subdevice locked\n");
+		return -EACCES;
+	}
+
+	/* are we busy? */
+	if (s->busy) {
+		DPRINTK("subdevice busy\n");
+		return -EBUSY;
+	}
+	s->busy = file;
+
+	/* make sure channel/gain list isn't too long */
+	if (user_cmd.chanlist_len > s->len_chanlist) {
+		DPRINTK("channel/gain list too long %u > %d\n",
+			user_cmd.chanlist_len, s->len_chanlist);
+		ret = -EINVAL;
+		goto cleanup;
+	}
+
+	/* make sure channel/gain list isn't too short */
+	if (user_cmd.chanlist_len < 1) {
+		DPRINTK("channel/gain list too short %u < 1\n",
+			user_cmd.chanlist_len);
+		ret = -EINVAL;
+		goto cleanup;
+	}
+
+	if (async->cmd.chanlist)
+		kfree(async->cmd.chanlist);
+	async->cmd = user_cmd;
+	async->cmd.data = NULL;
+	/* load channel/gain list */
+	async->cmd.chanlist =
+		kmalloc(async->cmd.chanlist_len * sizeof(int), GFP_KERNEL);
+	if (!async->cmd.chanlist) {
+		DPRINTK("allocation failed\n");
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	if (copy_from_user(async->cmd.chanlist, user_cmd.chanlist,
+			async->cmd.chanlist_len * sizeof(int))) {
+		DPRINTK("fault reading chanlist\n");
+		ret = -EFAULT;
+		goto cleanup;
+	}
+
+	/* make sure each element in channel/gain list is valid */
+	if ((ret = check_chanlist(s, async->cmd.chanlist_len,
+				async->cmd.chanlist)) < 0) {
+		DPRINTK("bad chanlist\n");
+		goto cleanup;
+	}
+
+	ret = s->do_cmdtest(dev, s, &async->cmd);
+
+	if (async->cmd.flags & TRIG_BOGUS || ret) {
+		DPRINTK("test returned %d\n", ret);
+		user_cmd = async->cmd;
+		// restore chanlist pointer before copying back
+		user_cmd.chanlist = chanlist_saver;
+		user_cmd.data = NULL;
+		if (copy_to_user(arg, &user_cmd, sizeof(comedi_cmd))) {
+			DPRINTK("fault writing cmd\n");
+			ret = -EFAULT;
+			goto cleanup;
+		}
+		ret = -EAGAIN;
+		goto cleanup;
+	}
+
+	if (!async->prealloc_bufsz) {
+		ret = -ENOMEM;
+		DPRINTK("no buffer (?)\n");
+		goto cleanup;
+	}
+
+	comedi_reset_async_buf(async);
+
+	async->cb_mask =
+		COMEDI_CB_EOA | COMEDI_CB_BLOCK | COMEDI_CB_ERROR |
+		COMEDI_CB_OVERFLOW;
+	if (async->cmd.flags & TRIG_WAKE_EOS) {
+		async->cb_mask |= COMEDI_CB_EOS;
+	}
+
+	comedi_set_subdevice_runflags(s, ~0, SRF_USER | SRF_RUNNING);
+
+#ifdef CONFIG_COMEDI_RT
+	if (async->cmd.flags & TRIG_RT) {
+		if (comedi_switch_to_rt(dev) == 0)
+			comedi_set_subdevice_runflags(s, SRF_RT, SRF_RT);
+	}
+#endif
+
+	ret = s->do_cmd(dev, s);
+	if (ret == 0)
+		return 0;
+
+      cleanup:
+	do_become_nonbusy(dev, s);
+
+	return ret;
+}
+
+/*
+	COMEDI_CMDTEST
+	command testing ioctl
+
+	arg:
+		pointer to cmd structure
+
+	reads:
+		cmd structure at arg
+		channel/range list
+
+	writes:
+		modified cmd structure at arg
+
+*/
+static int do_cmdtest_ioctl(comedi_device * dev, void *arg, void *file)
+{
+	comedi_cmd user_cmd;
+	comedi_subdevice *s;
+	int ret = 0;
+	unsigned int *chanlist = NULL;
+	unsigned int *chanlist_saver = NULL;
+
+	if (copy_from_user(&user_cmd, arg, sizeof(comedi_cmd))) {
+		DPRINTK("bad cmd address\n");
+		return -EFAULT;
+	}
+	// save user's chanlist pointer so it can be restored later
+	chanlist_saver = user_cmd.chanlist;
+
+	if (user_cmd.subdev >= dev->n_subdevices) {
+		DPRINTK("%d no such subdevice\n", user_cmd.subdev);
+		return -ENODEV;
+	}
+
+	s = dev->subdevices + user_cmd.subdev;
+	if (s->type == COMEDI_SUBD_UNUSED) {
+		DPRINTK("%d not valid subdevice\n", user_cmd.subdev);
+		return -EIO;
+	}
+
+	if (!s->do_cmd || !s->do_cmdtest) {
+		DPRINTK("subdevice %i does not support commands\n",
+			user_cmd.subdev);
+		return -EIO;
+	}
+
+	/* make sure channel/gain list isn't too long */
+	if (user_cmd.chanlist_len > s->len_chanlist) {
+		DPRINTK("channel/gain list too long %d > %d\n",
+			user_cmd.chanlist_len, s->len_chanlist);
+		ret = -EINVAL;
+		goto cleanup;
+	}
+
+	/* load channel/gain list */
+	if (user_cmd.chanlist) {
+		chanlist =
+			kmalloc(user_cmd.chanlist_len * sizeof(int),
+			GFP_KERNEL);
+		if (!chanlist) {
+			DPRINTK("allocation failed\n");
+			ret = -ENOMEM;
+			goto cleanup;
+		}
+
+		if (copy_from_user(chanlist, user_cmd.chanlist,
+				user_cmd.chanlist_len * sizeof(int))) {
+			DPRINTK("fault reading chanlist\n");
+			ret = -EFAULT;
+			goto cleanup;
+		}
+
+		/* make sure each element in channel/gain list is valid */
+		if ((ret = check_chanlist(s, user_cmd.chanlist_len,
+					chanlist)) < 0) {
+			DPRINTK("bad chanlist\n");
+			goto cleanup;
+		}
+
+		user_cmd.chanlist = chanlist;
+	}
+
+	ret = s->do_cmdtest(dev, s, &user_cmd);
+
+	// restore chanlist pointer before copying back
+	user_cmd.chanlist = chanlist_saver;
+
+	if (copy_to_user(arg, &user_cmd, sizeof(comedi_cmd))) {
+		DPRINTK("bad cmd address\n");
+		ret = -EFAULT;
+		goto cleanup;
+	}
+      cleanup:
+	if (chanlist)
+		kfree(chanlist);
+
+	return ret;
+}
+
+/*
+	COMEDI_LOCK
+	lock subdevice
+
+	arg:
+		subdevice number
+
+	reads:
+		none
+
+	writes:
+		none
+
+*/
+
+static int do_lock_ioctl(comedi_device * dev, unsigned int arg, void *file)
+{
+	int ret = 0;
+	unsigned long flags;
+	comedi_subdevice *s;
+
+	if (arg >= dev->n_subdevices)
+		return -EINVAL;
+	s = dev->subdevices + arg;
+
+	comedi_spin_lock_irqsave(&s->spin_lock, flags);
+	if (s->busy || s->lock) {
+		ret = -EBUSY;
+	} else {
+		s->lock = file;
+	}
+	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
+
+	if (ret < 0)
+		return ret;
+
+#if 0
+	if (s->lock_f)
+		ret = s->lock_f(dev, s);
+#endif
+
+	return ret;
+}
+
+/*
+	COMEDI_UNLOCK
+	unlock subdevice
+
+	arg:
+		subdevice number
+
+	reads:
+		none
+
+	writes:
+		none
+
+	This function isn't protected by the semaphore, since
+	we already own the lock.
+*/
+static int do_unlock_ioctl(comedi_device * dev, unsigned int arg, void *file)
+{
+	comedi_subdevice *s;
+
+	if (arg >= dev->n_subdevices)
+		return -EINVAL;
+	s = dev->subdevices + arg;
+
+	if (s->busy)
+		return -EBUSY;
+
+	if (s->lock && s->lock != file)
+		return -EACCES;
+
+	if (s->lock == file) {
+#if 0
+		if (s->unlock)
+			s->unlock(dev, s);
+#endif
+
+		s->lock = NULL;
+	}
+
+	return 0;
+}
+
+/*
+	COMEDI_CANCEL
+	cancel acquisition ioctl
+
+	arg:
+		subdevice number
+
+	reads:
+		nothing
+
+	writes:
+		nothing
+
+*/
+static int do_cancel_ioctl(comedi_device * dev, unsigned int arg, void *file)
+{
+	comedi_subdevice *s;
+
+	if (arg >= dev->n_subdevices)
+		return -EINVAL;
+	s = dev->subdevices + arg;
+	if (s->async == NULL)
+		return -EINVAL;
+
+	if (s->lock && s->lock != file)
+		return -EACCES;
+
+	if (!s->busy)
+		return 0;
+
+	if (s->busy != file)
+		return -EBUSY;
+
+	return do_cancel(dev, s);
+}
+
+/*
+	COMEDI_POLL ioctl
+	instructs driver to synchronize buffers
+
+	arg:
+		subdevice number
+
+	reads:
+		nothing
+
+	writes:
+		nothing
+
+*/
+static int do_poll_ioctl(comedi_device * dev, unsigned int arg, void *file)
+{
+	comedi_subdevice *s;
+
+	if (arg >= dev->n_subdevices)
+		return -EINVAL;
+	s = dev->subdevices + arg;
+
+	if (s->lock && s->lock != file)
+		return -EACCES;
+
+	if (!s->busy)
+		return 0;
+
+	if (s->busy != file)
+		return -EBUSY;
+
+	if (s->poll)
+		return s->poll(dev, s);
+
+	return -EINVAL;
+}
+
+static int do_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	int ret = 0;
+
+	if ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) && s->cancel)
+		ret = s->cancel(dev, s);
+
+	do_become_nonbusy(dev, s);
+
+	return ret;
+}
+
+void comedi_unmap(struct vm_area_struct *area)
+{
+	comedi_async *async;
+	comedi_device *dev;
+
+	async = area->vm_private_data;
+	dev = async->subdevice->device;
+
+	mutex_lock(&dev->mutex);
+	async->mmap_count--;
+	mutex_unlock(&dev->mutex);
+}
+
+static struct vm_operations_struct comedi_vm_ops = {
+      close:comedi_unmap,
+};
+
+static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	const unsigned minor = iminor(file->f_dentry->d_inode);
+	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	comedi_device *dev = dev_file_info->device;
+	comedi_async *async = NULL;
+	unsigned long start = vma->vm_start;
+	unsigned long size;
+	int n_pages;
+	int i;
+	int retval;
+	comedi_subdevice *s;
+
+	mutex_lock(&dev->mutex);
+	if (!dev->attached) {
+		DPRINTK("no driver configured on comedi%i\n", dev->minor);
+		retval = -ENODEV;
+		goto done;
+	}
+	if (vma->vm_flags & VM_WRITE) {
+		s = comedi_get_write_subdevice(dev_file_info);
+	} else {
+		s = comedi_get_read_subdevice(dev_file_info);
+	}
+	if (s == NULL) {
+		retval = -EINVAL;
+		goto done;
+	}
+	async = s->async;
+	if (async == NULL) {
+		retval = -EINVAL;
+		goto done;
+	}
+
+	if (vma->vm_pgoff != 0) {
+		DPRINTK("comedi: mmap() offset must be 0.\n");
+		retval = -EINVAL;
+		goto done;
+	}
+
+	size = vma->vm_end - vma->vm_start;
+	if (size > async->prealloc_bufsz) {
+		retval = -EFAULT;
+		goto done;
+	}
+	if (size & (~PAGE_MASK)) {
+		retval = -EFAULT;
+		goto done;
+	}
+
+	n_pages = size >> PAGE_SHIFT;
+	for (i = 0; i < n_pages; ++i) {
+		if (remap_pfn_range(vma, start,
+				page_to_pfn(virt_to_page(async->
+						buf_page_list[i].virt_addr)),
+				PAGE_SIZE, PAGE_SHARED)) {
+			retval = -EAGAIN;
+			goto done;
+		}
+		start += PAGE_SIZE;
+	}
+
+	vma->vm_ops = &comedi_vm_ops;
+	vma->vm_private_data = async;
+
+	async->mmap_count++;
+
+	retval = 0;
+      done:
+	mutex_unlock(&dev->mutex);
+	return retval;
+}
+
+static unsigned int comedi_poll(struct file *file, poll_table * wait)
+{
+	unsigned int mask = 0;
+	const unsigned minor = iminor(file->f_dentry->d_inode);
+	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	comedi_device *dev = dev_file_info->device;
+	comedi_subdevice *read_subdev;
+	comedi_subdevice *write_subdev;
+
+	mutex_lock(&dev->mutex);
+	if (!dev->attached) {
+		DPRINTK("no driver configured on comedi%i\n", dev->minor);
+		mutex_unlock(&dev->mutex);
+		return 0;
+	}
+
+	mask = 0;
+	read_subdev = comedi_get_read_subdevice(dev_file_info);
+	if (read_subdev) {
+		poll_wait(file, &read_subdev->async->wait_head, wait);
+		if (!read_subdev->busy
+			|| comedi_buf_read_n_available(read_subdev->async) > 0
+			|| !(comedi_get_subdevice_runflags(read_subdev) &
+				SRF_RUNNING)) {
+			mask |= POLLIN | POLLRDNORM;
+		}
+	}
+	write_subdev = comedi_get_write_subdevice(dev_file_info);
+	if (write_subdev) {
+		poll_wait(file, &write_subdev->async->wait_head, wait);
+		comedi_buf_write_alloc(write_subdev->async, write_subdev->async->prealloc_bufsz);
+		if (!write_subdev->busy
+			|| !(comedi_get_subdevice_runflags(write_subdev) &
+				SRF_RUNNING)
+			|| comedi_buf_write_n_allocated(write_subdev->async) >=
+			bytes_per_sample(write_subdev->async->subdevice)) {
+			mask |= POLLOUT | POLLWRNORM;
+		}
+	}
+
+	mutex_unlock(&dev->mutex);
+	return mask;
+}
+
+static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
+	loff_t * offset)
+{
+	comedi_subdevice *s;
+	comedi_async *async;
+	int n, m, count = 0, retval = 0;
+	DECLARE_WAITQUEUE(wait, current);
+	const unsigned minor = iminor(file->f_dentry->d_inode);
+	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	comedi_device *dev = dev_file_info->device;
+
+	if (!dev->attached) {
+		DPRINTK("no driver configured on comedi%i\n", dev->minor);
+		retval = -ENODEV;
+		goto done;
+	}
+
+	s = comedi_get_write_subdevice(dev_file_info);
+	if (s == NULL) {
+		retval = -EIO;
+		goto done;
+	}
+	async = s->async;
+
+	if (!nbytes) {
+		retval = 0;
+		goto done;
+	}
+	if (!s->busy) {
+		retval = 0;
+		goto done;
+	}
+	if (s->busy != file) {
+		retval = -EACCES;
+		goto done;
+	}
+	add_wait_queue(&async->wait_head, &wait);
+	while (nbytes > 0 && !retval) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		n = nbytes;
+
+		m = n;
+		if (async->buf_write_ptr + m > async->prealloc_bufsz) {
+			m = async->prealloc_bufsz - async->buf_write_ptr;
+		}
+		comedi_buf_write_alloc(async, async->prealloc_bufsz);
+		if (m > comedi_buf_write_n_allocated(async)) {
+			m = comedi_buf_write_n_allocated(async);
+		}
+		if (m < n)
+			n = m;
+
+		if (n == 0) {
+			if (!(comedi_get_subdevice_runflags(s) & SRF_RUNNING)) {
+				if (comedi_get_subdevice_runflags(s) &
+					SRF_ERROR) {
+					retval = -EPIPE;
+				} else {
+					retval = 0;
+				}
+				do_become_nonbusy(dev, s);
+				break;
+			}
+			if (file->f_flags & O_NONBLOCK) {
+				retval = -EAGAIN;
+				break;
+			}
+			if (signal_pending(current)) {
+				retval = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+			if (!s->busy) {
+				break;
+			}
+			if (s->busy != file) {
+				retval = -EACCES;
+				break;
+			}
+			continue;
+		}
+
+		m = copy_from_user(async->prealloc_buf + async->buf_write_ptr,
+			buf, n);
+		if (m) {
+			n -= m;
+			retval = -EFAULT;
+		}
+		comedi_buf_write_free(async, n);
+
+		count += n;
+		nbytes -= n;
+
+		buf += n;
+		break;		/* makes device work like a pipe */
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&async->wait_head, &wait);
+
+done:
+	return (count ? count : retval);
+}
+
+static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
+	loff_t * offset)
+{
+	comedi_subdevice *s;
+	comedi_async *async;
+	int n, m, count = 0, retval = 0;
+	DECLARE_WAITQUEUE(wait, current);
+	const unsigned minor = iminor(file->f_dentry->d_inode);
+	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	comedi_device *dev = dev_file_info->device;
+
+	if (!dev->attached) {
+		DPRINTK("no driver configured on comedi%i\n", dev->minor);
+		retval = -ENODEV;
+		goto done;
+	}
+
+	s = comedi_get_read_subdevice(dev_file_info);
+	if (s == NULL) {
+		retval = -EIO;
+		goto done;
+	}
+	async = s->async;
+	if (!nbytes) {
+		retval = 0;
+		goto done;
+	}
+	if (!s->busy) {
+		retval = 0;
+		goto done;
+	}
+	if (s->busy != file) {
+		retval = -EACCES;
+		goto done;
+	}
+
+	add_wait_queue(&async->wait_head, &wait);
+	while (nbytes > 0 && !retval) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		n = nbytes;
+
+		m = comedi_buf_read_n_available(async);
+//printk("%d available\n",m);
+		if (async->buf_read_ptr + m > async->prealloc_bufsz) {
+			m = async->prealloc_bufsz - async->buf_read_ptr;
+		}
+//printk("%d contiguous\n",m);
+		if (m < n)
+			n = m;
+
+		if (n == 0) {
+			if (!(comedi_get_subdevice_runflags(s) & SRF_RUNNING)) {
+				do_become_nonbusy(dev, s);
+				if (comedi_get_subdevice_runflags(s) &
+					SRF_ERROR) {
+					retval = -EPIPE;
+				} else {
+					retval = 0;
+				}
+				break;
+			}
+			if (file->f_flags & O_NONBLOCK) {
+				retval = -EAGAIN;
+				break;
+			}
+			if (signal_pending(current)) {
+				retval = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+			if (!s->busy) {
+				retval = 0;
+				break;
+			}
+			if (s->busy != file) {
+				retval = -EACCES;
+				break;
+			}
+			continue;
+		}
+		m = copy_to_user(buf, async->prealloc_buf +
+			async->buf_read_ptr, n);
+		if (m) {
+			n -= m;
+			retval = -EFAULT;
+		}
+
+		comedi_buf_read_alloc(async, n);
+		comedi_buf_read_free(async, n);
+
+		count += n;
+		nbytes -= n;
+
+		buf += n;
+		break;		/* makes device work like a pipe */
+	}
+	if (!(comedi_get_subdevice_runflags(s) & (SRF_ERROR | SRF_RUNNING)) &&
+		async->buf_read_count - async->buf_write_count == 0) {
+		do_become_nonbusy(dev, s);
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&async->wait_head, &wait);
+
+done:
+	return (count ? count : retval);
+}
+
+/*
+   This function restores a subdevice to an idle state.
+ */
+void do_become_nonbusy(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_async *async = s->async;
+
+	comedi_set_subdevice_runflags(s, SRF_RUNNING, 0);
+#ifdef CONFIG_COMEDI_RT
+	if (comedi_get_subdevice_runflags(s) & SRF_RT) {
+		comedi_switch_to_non_rt(dev);
+		comedi_set_subdevice_runflags(s, SRF_RT, 0);
+	}
+#endif
+	if (async) {
+		comedi_reset_async_buf(async);
+		async->inttrig = NULL;
+	} else {
+		printk("BUG: (?) do_become_nonbusy called with async=0\n");
+	}
+
+	s->busy = NULL;
+}
+
+static int comedi_open(struct inode *inode, struct file *file)
+{
+	char mod[32];
+	const unsigned minor = iminor(inode);
+	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	comedi_device *dev = dev_file_info->device;
+	if (dev == NULL) {
+		DPRINTK("invalid minor number\n");
+		return -ENODEV;
+	}
+
+	/* This is slightly hacky, but we want module autoloading
+	 * to work for root.
+	 * case: user opens device, attached -> ok
+	 * case: user opens device, unattached, in_request_module=0 -> autoload
+	 * case: user opens device, unattached, in_request_module=1 -> fail
+	 * case: root opens device, attached -> ok
+	 * case: root opens device, unattached, in_request_module=1 -> ok
+	 *   (typically called from modprobe)
+	 * case: root opens device, unattached, in_request_module=0 -> autoload
+	 *
+	 * The last could be changed to "-> ok", which would deny root
+	 * autoloading.
+	 */
+	mutex_lock(&dev->mutex);
+	if (dev->attached)
+		goto ok;
+	if (!capable(CAP_SYS_MODULE) && dev->in_request_module) {
+		DPRINTK("in request module\n");
+		mutex_unlock(&dev->mutex);
+		return -ENODEV;
+	}
+	if (capable(CAP_SYS_MODULE) && dev->in_request_module)
+		goto ok;
+
+	dev->in_request_module = 1;
+
+	sprintf(mod, "char-major-%i-%i", COMEDI_MAJOR, dev->minor);
+#ifdef CONFIG_KMOD
+	mutex_unlock(&dev->mutex);
+	request_module(mod);
+	mutex_lock(&dev->mutex);
+#endif
+
+	dev->in_request_module = 0;
+
+	if (!dev->attached && !capable(CAP_SYS_MODULE)) {
+		DPRINTK("not attached and not CAP_SYS_MODULE\n");
+		mutex_unlock(&dev->mutex);
+		return -ENODEV;
+	}
+ok:
+	__module_get(THIS_MODULE);
+
+	if (dev->attached) {
+		if (!try_module_get(dev->driver->module)) {
+			module_put(THIS_MODULE);
+			mutex_unlock(&dev->mutex);
+			return -ENOSYS;
+		}
+	}
+
+	if (dev->attached && dev->use_count == 0 && dev->open) {
+		dev->open(dev);
+	}
+
+	dev->use_count++;
+
+	mutex_unlock(&dev->mutex);
+
+	return 0;
+}
+
+static int comedi_close(struct inode *inode, struct file *file)
+{
+	const unsigned minor = iminor(inode);
+	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	comedi_device *dev = dev_file_info->device;
+	comedi_subdevice *s = NULL;
+	int i;
+
+	mutex_lock(&dev->mutex);
+
+	if (dev->subdevices) {
+		for (i = 0; i < dev->n_subdevices; i++) {
+			s = dev->subdevices + i;
+
+			if (s->busy == file) {
+				do_cancel(dev, s);
+			}
+			if (s->lock == file) {
+				s->lock = NULL;
+			}
+		}
+	}
+	if (dev->attached && dev->use_count == 1 && dev->close) {
+		dev->close(dev);
+	}
+
+	module_put(THIS_MODULE);
+	if (dev->attached) {
+		module_put(dev->driver->module);
+	}
+
+	dev->use_count--;
+
+	mutex_unlock(&dev->mutex);
+
+	if (file->f_flags & FASYNC) {
+		comedi_fasync(-1, file, 0);
+	}
+
+	return 0;
+}
+
+static int comedi_fasync(int fd, struct file *file, int on)
+{
+	const unsigned minor = iminor(file->f_dentry->d_inode);
+	struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(minor);
+	comedi_device *dev = dev_file_info->device;
+
+	return fasync_helper(fd, file, on, &dev->async_queue);
+}
+
+const struct file_operations comedi_fops = {
+      owner:THIS_MODULE,
+#ifdef HAVE_UNLOCKED_IOCTL
+      unlocked_ioctl:comedi_unlocked_ioctl,
+#else
+      ioctl:comedi_ioctl,
+#endif
+#ifdef HAVE_COMPAT_IOCTL
+      compat_ioctl:comedi_compat_ioctl,
+#endif
+      open:comedi_open,
+      release:comedi_close,
+      read:comedi_read,
+      write:comedi_write,
+      mmap:comedi_mmap,
+      poll:comedi_poll,
+      fasync:comedi_fasync,
+};
+
+struct class *comedi_class = NULL;
+static struct cdev comedi_cdev;
+
+static void comedi_cleanup_legacy_minors(void)
+{
+	unsigned i;
+	for (i = 0; i < COMEDI_NUM_LEGACY_MINORS; i++) {
+		comedi_free_board_minor(i);
+	}
+}
+
+static int __init comedi_init(void)
+{
+	int i;
+	int retval;
+
+	printk("comedi: version " COMEDI_RELEASE
+		" - http://www.comedi.org\n");
+
+	memset(comedi_file_info_table, 0, sizeof(struct comedi_device_file_info*) * COMEDI_NUM_MINORS);
+
+	retval = register_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+		COMEDI_NUM_MINORS, "comedi");
+	if (retval)
+		return -EIO;
+	cdev_init(&comedi_cdev, &comedi_fops);
+	comedi_cdev.owner = THIS_MODULE;
+	kobject_set_name(&comedi_cdev.kobj, "comedi");
+	if (cdev_add(&comedi_cdev, MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS)) {
+		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+			COMEDI_NUM_MINORS);
+		return -EIO;
+	}
+	comedi_class = class_create(THIS_MODULE, "comedi");
+	if (IS_ERR(comedi_class)) {
+		printk("comedi: failed to create class");
+		cdev_del(&comedi_cdev);
+		unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+			COMEDI_NUM_MINORS);
+		return PTR_ERR(comedi_class);
+	}
+
+	/* XXX requires /proc interface */
+	comedi_proc_init();
+
+	// create devices files for legacy/manual use
+	for (i = 0; i < COMEDI_NUM_LEGACY_MINORS; i++) {
+		int minor;
+		minor = comedi_alloc_board_minor(NULL);
+		if(minor < 0)
+		{
+			comedi_cleanup_legacy_minors();
+			cdev_del(&comedi_cdev);
+			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
+				COMEDI_NUM_MINORS);
+			return minor;
+		}
+	}
+
+	comedi_rt_init();
+
+	comedi_register_ioctl32();
+
+	return 0;
+}
+
+static void __exit comedi_cleanup(void)
+{
+	int i;
+
+	comedi_cleanup_legacy_minors();
+	for(i = 0; i < COMEDI_NUM_MINORS; ++i)
+	{
+		BUG_ON(comedi_file_info_table[i]);
+	}
+
+	class_destroy(comedi_class);
+	cdev_del(&comedi_cdev);
+	unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);
+
+	comedi_proc_cleanup();
+
+	comedi_rt_cleanup();
+
+	comedi_unregister_ioctl32();
+}
+
+module_init(comedi_init);
+module_exit(comedi_cleanup);
+
+void comedi_error(const comedi_device * dev, const char *s)
+{
+	rt_printk("comedi%d: %s: %s\n", dev->minor, dev->driver->driver_name,
+		s);
+}
+
+void comedi_event(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_async *async = s->async;
+	unsigned runflags = 0;
+	unsigned runflags_mask = 0;
+
+	//DPRINTK("comedi_event 0x%x\n",mask);
+
+	if ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) == 0)
+		return;
+
+	if (s->async->
+		events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
+	{
+		runflags_mask |= SRF_RUNNING;
+	}
+	/* remember if an error event has occured, so an error
+	 * can be returned the next time the user does a read() */
+	if (s->async->events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {
+		runflags_mask |= SRF_ERROR;
+		runflags |= SRF_ERROR;
+	}
+	if (runflags_mask) {
+		/*sets SRF_ERROR and SRF_RUNNING together atomically */
+		comedi_set_subdevice_runflags(s, runflags_mask, runflags);
+	}
+
+	if (async->cb_mask & s->async->events) {
+		if (comedi_get_subdevice_runflags(s) & SRF_USER) {
+
+			if (dev->rt) {
+#ifdef CONFIG_COMEDI_RT
+				// pend wake up
+				comedi_rt_pend_wakeup(&async->wait_head);
+#else
+				printk("BUG: comedi_event() code unreachable\n");
+#endif
+			} else {
+				wake_up_interruptible(&async->wait_head);
+				if (s->subdev_flags & SDF_CMD_READ) {
+					kill_fasync(&dev->async_queue, SIGIO,
+						POLL_IN);
+				}
+				if (s->subdev_flags & SDF_CMD_WRITE) {
+					kill_fasync(&dev->async_queue, SIGIO,
+						POLL_OUT);
+				}
+			}
+		} else {
+			if (async->cb_func)
+				async->cb_func(s->async->events, async->cb_arg);
+			/* XXX bug here.  If subdevice A is rt, and
+			 * subdevice B tries to callback to a normal
+			 * linux kernel function, it will be at the
+			 * wrong priority.  Since this isn't very
+			 * common, I'm not going to worry about it. */
+		}
+	}
+	s->async->events = 0;
+}
+
+void comedi_set_subdevice_runflags(comedi_subdevice * s, unsigned mask,
+	unsigned bits)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&s->spin_lock, flags);
+	s->runflags &= ~mask;
+	s->runflags |= (bits & mask);
+	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
+}
+
+unsigned comedi_get_subdevice_runflags(comedi_subdevice * s)
+{
+	unsigned long flags;
+	unsigned runflags;
+
+	comedi_spin_lock_irqsave(&s->spin_lock, flags);
+	runflags = s->runflags;
+	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
+	return runflags;
+}
+
+static int is_device_busy(comedi_device * dev)
+{
+	comedi_subdevice *s;
+	int i;
+
+	if (!dev->attached)
+		return 0;
+
+	for (i = 0; i < dev->n_subdevices; i++) {
+		s = dev->subdevices + i;
+		if (s->busy)
+			return 1;
+		if (s->async && s->async->mmap_count)
+			return 1;
+	}
+
+	return 0;
+}
+
+void comedi_device_init(comedi_device *dev)
+{
+	memset(dev, 0, sizeof(comedi_device));
+	spin_lock_init(&dev->spinlock);
+	mutex_init(&dev->mutex);
+	dev->minor = -1;
+}
+
+void comedi_device_cleanup(comedi_device *dev)
+{
+	if(dev == NULL) return;
+	mutex_lock(&dev->mutex);
+	comedi_device_detach(dev);
+	mutex_unlock(&dev->mutex);
+	mutex_destroy(&dev->mutex);
+}
+
+int comedi_alloc_board_minor(struct device *hardware_device)
+{
+	unsigned long flags;
+	struct comedi_device_file_info *info;
+	device_create_result_type *csdev;
+	unsigned i;
+
+	info = kzalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
+	if(info == NULL) return -ENOMEM;
+	info->device = kzalloc(sizeof(comedi_device), GFP_KERNEL);
+	if(info->device == NULL)
+	{
+		kfree(info);
+		return -ENOMEM;
+	}
+	comedi_device_init(info->device);
+	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	for(i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i)
+	{
+		if(comedi_file_info_table[i] == NULL)
+		{
+			comedi_file_info_table[i] = info;
+			break;
+		}
+	}
+	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	if(i == COMEDI_NUM_BOARD_MINORS)
+	{
+		comedi_device_cleanup(info->device);
+		kfree(info->device);
+		kfree(info);
+		rt_printk("comedi: error: ran out of minor numbers for board device files.\n");
+		return -EBUSY;
+	}
+	info->device->minor = i;
+	csdev = COMEDI_DEVICE_CREATE(comedi_class, NULL,
+		MKDEV(COMEDI_MAJOR, i), NULL, hardware_device, "comedi%i", i);
+	if(!IS_ERR(csdev)) {
+		info->device->class_dev = csdev;
+	}
+	return i;
+}
+
+void comedi_free_board_minor(unsigned minor)
+{
+	unsigned long flags;
+	struct comedi_device_file_info *info;
+
+	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
+	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	info = comedi_file_info_table[minor];
+	comedi_file_info_table[minor] = NULL;
+	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+
+	if(info)
+	{
+		comedi_device *dev = info->device;
+		if(dev)
+		{
+			if(dev->class_dev)
+			{
+				device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, dev->minor));
+			}
+			comedi_device_cleanup(dev);
+			kfree(dev);
+		}
+		kfree(info);
+	}
+}
+
+int comedi_alloc_subdevice_minor(comedi_device *dev, comedi_subdevice *s)
+{
+	unsigned long flags;
+	struct comedi_device_file_info *info;
+	device_create_result_type *csdev;
+	unsigned i;
+
+	info = kmalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);
+	if(info == NULL) return -ENOMEM;
+	info->device = dev;
+	info->read_subdevice = s;
+	info->write_subdevice = s;
+	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	for(i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_BOARD_MINORS; ++i)
+	{
+		if(comedi_file_info_table[i] == NULL)
+		{
+			comedi_file_info_table[i] = info;
+			break;
+		}
+	}
+	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	if(i == COMEDI_NUM_MINORS)
+	{
+		kfree(info);
+		rt_printk("comedi: error: ran out of minor numbers for board device files.\n");
+		return -EBUSY;
+	}
+	s->minor = i;
+	csdev = COMEDI_DEVICE_CREATE(comedi_class, dev->class_dev,
+		MKDEV(COMEDI_MAJOR, i), NULL, NULL, "comedi%i_subd%i", dev->minor, (int)(s - dev->subdevices));
+	if(!IS_ERR(csdev))
+	{
+		s->class_dev = csdev;
+	}
+	return i;
+}
+
+void comedi_free_subdevice_minor(comedi_subdevice *s)
+{
+	unsigned long flags;
+	struct comedi_device_file_info *info;
+
+	if(s == NULL) return;
+	if(s->minor < 0) return;
+
+	BUG_ON(s->minor >= COMEDI_NUM_MINORS);
+	BUG_ON(s->minor < COMEDI_FIRST_SUBDEVICE_MINOR);
+
+	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	info = comedi_file_info_table[s->minor];
+	comedi_file_info_table[s->minor] = NULL;
+	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+
+	if(s->class_dev)
+	{
+		device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, s->minor));
+		s->class_dev = NULL;
+	}
+	kfree(info);
+}
+
+struct comedi_device_file_info *comedi_get_device_file_info(unsigned minor)
+{
+	unsigned long flags;
+	struct comedi_device_file_info *info;
+
+	BUG_ON(minor >= COMEDI_NUM_MINORS);
+	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	info = comedi_file_info_table[minor];
+	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	return info;
+}
