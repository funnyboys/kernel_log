commit f44303e85268cc6cd6b1e545d3845f1d81cb6728
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Apr 17 15:39:30 2019 +0100

    staging: comedi: Add lockdep_assert_held() calls for dev->attach_lock
    
    There are not a lot of functions in the core comedi module that require
    the R/W semaphore `attach_lock` in `struct comedi_device` to be locked
    (although there are a few functions that require at least one of
    `attach_lock` and `mutex` to be locked).  One function that requires the
    caller to lock `attach_lock` is `comedi_device_detach_cleanup()` so add
    a call to `lockdep_assert_held()` to check and document that.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index fdf0a5761f9b..750a6ff3c03c 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -159,6 +159,7 @@ static void comedi_device_detach_cleanup(struct comedi_device *dev)
 	int i;
 	struct comedi_subdevice *s;
 
+	lockdep_assert_held(&dev->attach_lock);
 	lockdep_assert_held(&dev->mutex);
 	if (dev->subdevices) {
 		for (i = 0; i < dev->n_subdevices; i++) {

commit 77c21b626be5b6b30ca6f76ccd5ba1d14a8278a9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Apr 17 15:39:29 2019 +0100

    staging: comedi: Add lockdep_assert_held() calls for dev->mutex
    
    Lots of functions in the core comedi module expect the mutex in `struct
    comedi_device` to be held, so add calls to `lockdep_assert_held()` to
    check and document that.  An unusual case is the calls to
    `lockdep_assert_held()` after successful return from
    `comedi_alloc_board_minor()` which allocates a `struct comedi_device`
    and returns with its mutex locked.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index b7b9e48d4303..fdf0a5761f9b 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -159,6 +159,7 @@ static void comedi_device_detach_cleanup(struct comedi_device *dev)
 	int i;
 	struct comedi_subdevice *s;
 
+	lockdep_assert_held(&dev->mutex);
 	if (dev->subdevices) {
 		for (i = 0; i < dev->n_subdevices; i++) {
 			s = &dev->subdevices[i];
@@ -196,6 +197,7 @@ static void comedi_device_detach_cleanup(struct comedi_device *dev)
 
 void comedi_device_detach(struct comedi_device *dev)
 {
+	lockdep_assert_held(&dev->mutex);
 	comedi_device_cancel_all(dev);
 	down_write(&dev->attach_lock);
 	dev->attached = false;
@@ -643,6 +645,7 @@ static int __comedi_device_postconfig_async(struct comedi_device *dev,
 	unsigned int buf_size;
 	int ret;
 
+	lockdep_assert_held(&dev->mutex);
 	if ((s->subdev_flags & (SDF_CMD_READ | SDF_CMD_WRITE)) == 0) {
 		dev_warn(dev->class_dev,
 			 "async subdevices must support SDF_CMD_READ or SDF_CMD_WRITE\n");
@@ -690,6 +693,7 @@ static int __comedi_device_postconfig(struct comedi_device *dev)
 	int ret;
 	int i;
 
+	lockdep_assert_held(&dev->mutex);
 	if (!dev->insn_device_config)
 		dev->insn_device_config = insn_device_inval;
 
@@ -747,6 +751,7 @@ static int comedi_device_postconfig(struct comedi_device *dev)
 {
 	int ret;
 
+	lockdep_assert_held(&dev->mutex);
 	ret = __comedi_device_postconfig(dev);
 	if (ret < 0)
 		return ret;
@@ -946,6 +951,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_driver *driv;
 	int ret;
 
+	lockdep_assert_held(&dev->mutex);
 	if (dev->attached)
 		return -EBUSY;
 
@@ -1053,6 +1059,7 @@ int comedi_auto_config(struct device *hardware_device,
 		return PTR_ERR(dev);
 	}
 	/* Note: comedi_alloc_board_minor() locked dev->mutex. */
+	lockdep_assert_held(&dev->mutex);
 
 	dev->driver = driver;
 	dev->board_name = dev->driver->driver_name;

commit f439696c81fcfe70ad46554fbec1c851bab9345a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Apr 17 15:35:31 2019 +0100

    staging: comedi: don't release mutex too early in comedi_auto_config()
    
    `comedi_auto_config()` uses `dev->class_dev` for logging a kernel
    message after releasing `dev->mutex`.  There is an unlikely possibility
    that the Comedi device `dev` will have been removed by the
    `COMEDI_DEVCONFIG` ioctl() command.  Keep hold of the mutex until the
    kernel message has been sent to prevent that.  The function can call
    `comedi_release_hardware_device()` on error.  In that case, the mutex
    must be unlocked before that.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 5a32b8fc000e..b7b9e48d4303 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -1059,12 +1059,12 @@ int comedi_auto_config(struct device *hardware_device,
 	ret = driver->auto_attach(dev, context);
 	if (ret >= 0)
 		ret = comedi_device_postconfig(dev);
-	mutex_unlock(&dev->mutex);
 
 	if (ret < 0) {
 		dev_warn(hardware_device,
 			 "driver '%s' failed to auto-configure device.\n",
 			 driver->driver_name);
+		mutex_unlock(&dev->mutex);
 		comedi_release_hardware_device(hardware_device);
 	} else {
 		/*
@@ -1074,6 +1074,7 @@ int comedi_auto_config(struct device *hardware_device,
 		dev_info(dev->class_dev,
 			 "driver '%s' has successfully auto-configured '%s'.\n",
 			 driver->driver_name, dev->board_name);
+		mutex_unlock(&dev->mutex);
 	}
 	return ret;
 }

commit bafd9c64056cd034a1174dcadb65cd3b294ff8f6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 4 14:33:54 2019 +0000

    staging: comedi: ni_mio_common: Fix divide-by-zero for DIO cmdtest
    
    `ni_cdio_cmdtest()` validates Comedi asynchronous commands for the DIO
    subdevice (subdevice 2) of supported National Instruments M-series
    cards.  It is called when handling the `COMEDI_CMD` and `COMEDI_CMDTEST`
    ioctls for this subdevice.  There are two causes for a possible
    divide-by-zero error when validating that the `stop_arg` member of the
    passed-in command is not too large.
    
    The first cause for the divide-by-zero is that calls to
    `comedi_bytes_per_scan()` are only valid once the command has been
    copied to `s->async->cmd`, but that copy is only done for the
    `COMEDI_CMD` ioctl.  For the `COMEDI_CMDTEST` ioctl, it will use
    whatever was left there by the previous `COMEDI_CMD` ioctl, if any.
    (This is very likely, as it is usual for the application to use
    `COMEDI_CMDTEST` before `COMEDI_CMD`.) If there has been no previous,
    valid `COMEDI_CMD` for this subdevice, then `comedi_bytes_per_scan()`
    will return 0, so the subsequent division in `ni_cdio_cmdtest()` of
    `s->async->prealloc_bufsz / comedi_bytes_per_scan(s)` will be a
    divide-by-zero error.  To fix this error, call a new function
    `comedi_bytes_per_scan_cmd(s, cmd)`, based on the existing
    `comedi_bytes_per_scan(s)` but using a specified `struct comedi_cmd` for
    its calculations.  (Also refactor `comedi_bytes_per_scan()` to call the
    new function.)
    
    Once the first cause for the divide-by-zero has been fixed, the second
    cause is that `comedi_bytes_per_scan_cmd()` can legitimately return 0 if
    the `scan_end_arg` member of the `struct comedi_cmd` being tested is 0.
    Fix it by only performing the division (and validating that `stop_arg`
    is no more than the maximum value) if `comedi_bytes_per_scan_cmd()`
    returns a non-zero value.
    
    The problem was reported on the COMEDI mailing list here:
    https://groups.google.com/forum/#!topic/comedi_list/4t9WlHzMhKM
    
    Reported-by: Ivan Vasilyev <grabesstimme@gmail.com>
    Tested-by: Ivan Vasilyev <grabesstimme@gmail.com>
    Fixes: f164cbf98fa8 ("staging: comedi: ni_mio_common: add finite regeneration to dio output")
    Cc: <stable@vger.kernel.org> # 4.6+
    Cc: Spencer E. Olson <olsonse@umich.edu>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index eefa62f42c0f..5a32b8fc000e 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -394,11 +394,13 @@ unsigned int comedi_dio_update_state(struct comedi_subdevice *s,
 EXPORT_SYMBOL_GPL(comedi_dio_update_state);
 
 /**
- * comedi_bytes_per_scan() - Get length of asynchronous command "scan" in bytes
+ * comedi_bytes_per_scan_cmd() - Get length of asynchronous command "scan" in
+ * bytes
  * @s: COMEDI subdevice.
+ * @cmd: COMEDI command.
  *
  * Determines the overall scan length according to the subdevice type and the
- * number of channels in the scan.
+ * number of channels in the scan for the specified command.
  *
  * For digital input, output or input/output subdevices, samples for
  * multiple channels are assumed to be packed into one or more unsigned
@@ -408,9 +410,9 @@ EXPORT_SYMBOL_GPL(comedi_dio_update_state);
  *
  * Returns the overall scan length in bytes.
  */
-unsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)
+unsigned int comedi_bytes_per_scan_cmd(struct comedi_subdevice *s,
+				       struct comedi_cmd *cmd)
 {
-	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int num_samples;
 	unsigned int bits_per_sample;
 
@@ -427,6 +429,29 @@ unsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)
 	}
 	return comedi_samples_to_bytes(s, num_samples);
 }
+EXPORT_SYMBOL_GPL(comedi_bytes_per_scan_cmd);
+
+/**
+ * comedi_bytes_per_scan() - Get length of asynchronous command "scan" in bytes
+ * @s: COMEDI subdevice.
+ *
+ * Determines the overall scan length according to the subdevice type and the
+ * number of channels in the scan for the current command.
+ *
+ * For digital input, output or input/output subdevices, samples for
+ * multiple channels are assumed to be packed into one or more unsigned
+ * short or unsigned int values according to the subdevice's %SDF_LSAMPL
+ * flag.  For other types of subdevice, samples are assumed to occupy a
+ * whole unsigned short or unsigned int according to the %SDF_LSAMPL flag.
+ *
+ * Returns the overall scan length in bytes.
+ */
+unsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)
+{
+	struct comedi_cmd *cmd = &s->async->cmd;
+
+	return comedi_bytes_per_scan_cmd(s, cmd);
+}
 EXPORT_SYMBOL_GPL(comedi_bytes_per_scan);
 
 static unsigned int __comedi_nscans_left(struct comedi_subdevice *s,

commit d7569ad766511fe708a8bd7476baa305d1510daf
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Oct 3 14:56:02 2018 -0600

    staging: comedi: add new device-global config interface
    
    Adds interface for configuring options that are global to all sub-devices.
    For now, only options to configure device-globally identified signal routes
    have been defined.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 57dd63d548b7..eefa62f42c0f 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -211,6 +211,19 @@ static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)
 	return -EINVAL;
 }
 
+static int insn_device_inval(struct comedi_device *dev,
+			     struct comedi_insn *insn, unsigned int *data)
+{
+	return -EINVAL;
+}
+
+static unsigned int get_zero_valid_routes(struct comedi_device *dev,
+					  unsigned int n_pairs,
+					  unsigned int *pair_data)
+{
+	return 0;
+}
+
 int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
 	       struct comedi_insn *insn, unsigned int *data)
 {
@@ -652,6 +665,12 @@ static int __comedi_device_postconfig(struct comedi_device *dev)
 	int ret;
 	int i;
 
+	if (!dev->insn_device_config)
+		dev->insn_device_config = insn_device_inval;
+
+	if (!dev->get_valid_routes)
+		dev->get_valid_routes = get_zero_valid_routes;
+
 	for (i = 0; i < dev->n_subdevices; i++) {
 		s = &dev->subdevices[i];
 

commit 2665df51017b15119987913bfa39d02d71cb7232
Author: Chris Opperman <eklikeroomys@gmail.com>
Date:   Wed Jun 13 19:14:35 2018 +0200

    staging: comedi: Improved readability of function comedi_nsamples_left.
    
    Improve readability of comedi_nsamples_left:
    a) Reduce nesting by using more return statements.
    b) Declare variables scans_left and samples_left at start of function.
    c) Change type of scans_Left to unsigned long long to avoid cast.
    
    Signed-off-by: Chris Opperman <eklikeroomys@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 9d733471ca2e..57dd63d548b7 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -473,21 +473,21 @@ unsigned int comedi_nsamples_left(struct comedi_subdevice *s,
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
+	unsigned long long scans_left;
+	unsigned long long samples_left;
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		unsigned int scans_left = __comedi_nscans_left(s, cmd->stop_arg);
-		unsigned int scan_pos =
-		    comedi_bytes_to_samples(s, async->scan_progress);
-		unsigned long long samples_left = 0;
-
-		if (scans_left) {
-			samples_left = ((unsigned long long)scans_left *
-					cmd->scan_end_arg) - scan_pos;
-		}
+	if (cmd->stop_src != TRIG_COUNT)
+		return nsamples;
 
-		if (samples_left < nsamples)
-			nsamples = samples_left;
-	}
+	scans_left = __comedi_nscans_left(s, cmd->stop_arg);
+	if (!scans_left)
+		return 0;
+
+	samples_left = scans_left * cmd->scan_end_arg -
+		comedi_bytes_to_samples(s, async->scan_progress);
+
+	if (samples_left < nsamples)
+		return samples_left;
 	return nsamples;
 }
 EXPORT_SYMBOL_GPL(comedi_nsamples_left);

commit a42ae5905140c324362fe5036ae1dbb16e4d359c
Author: Frank Mori Hess <fmh6jj@gmail.com>
Date:   Thu Feb 15 15:13:42 2018 -0500

    staging: comedi: fix comedi_nsamples_left.
    
    A rounding error was causing comedi_nsamples_left to
    return the wrong value when nsamples was not a multiple
    of the scan length.
    
    Cc: <stable@vger.kernel.org> # v4.4+
    Signed-off-by: Frank Mori Hess <fmh6jj@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index e618a87521a3..9d733471ca2e 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -475,8 +475,7 @@ unsigned int comedi_nsamples_left(struct comedi_subdevice *s,
 	struct comedi_cmd *cmd = &async->cmd;
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		unsigned int nscans = nsamples / cmd->scan_end_arg;
-		unsigned int scans_left = __comedi_nscans_left(s, nscans);
+		unsigned int scans_left = __comedi_nscans_left(s, cmd->stop_arg);
 		unsigned int scan_pos =
 		    comedi_bytes_to_samples(s, async->scan_progress);
 		unsigned long long samples_left = 0;

commit f814e74c9b5f37f22fe28acc1989566b99adb170
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:45 2017 +0100

    staging: comedi: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 393dd5c708ba..e618a87521a3 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -6,16 +6,6 @@
  *  COMEDI - Linux Control and Measurement Device Interface
  *  Copyright (C) 1997-2000 David A. Schleef <ds@schleef.org>
  *  Copyright (C) 2002 Frank Mori Hess <fmhess@users.sourceforge.net>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
  */
 
 #include <linux/device.h>

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 0b43db6371c6..393dd5c708ba 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  *  module/drivers.c
  *  functions for manipulating drivers

commit 423a8a6eac2432a50e7ca4e4342a41ad3cf951e7
Author: Simo Koskinen <koskisoft@gmail.com>
Date:   Mon Aug 28 15:01:32 2017 +0200

    staging: comedi: coding style fixes found by checkpatch.pl
    
    The patch removes "WARNING: Prefer using '"%s...", __func__'
    to using 'xxxxxxxx', this function's name, in a string" warnings
    reported by checkpatch.pl script.
    
    Signed-off-by: Simo Koskinen <koskisoft@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index a5bf2cc165c0..0b43db6371c6 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -995,12 +995,12 @@ int comedi_auto_config(struct device *hardware_device,
 	int ret;
 
 	if (!hardware_device) {
-		pr_warn("BUG! comedi_auto_config called with NULL hardware_device\n");
+		pr_warn("BUG! %s called with NULL hardware_device\n", __func__);
 		return -EINVAL;
 	}
 	if (!driver) {
 		dev_warn(hardware_device,
-			 "BUG! comedi_auto_config called with NULL comedi driver\n");
+			 "BUG! %s called with NULL comedi driver\n", __func__);
 		return -EINVAL;
 	}
 

commit 37a7029b755b0b82c22a69880106d95ca66af0ba
Author: Ramiro Oliveira <Ramiro.Oliveira@synopsys.com>
Date:   Fri Sep 30 11:32:05 2016 +0100

    Staging: comedi: Align the * in block comments
    
    Align the * on each line of block comments as reported by checkpatch
    
    Signed-off-by: Ramiro Oliveira <roliveir@synopsys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 44511d729450..a5bf2cc165c0 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -15,7 +15,7 @@
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
-*/
+ */
 
 #include <linux/device.h>
 #include <linux/module.h>

commit 7be7cd10ade121cd5363c5f8790638b177b5e9dd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 30 10:47:25 2016 -0700

    staging: comedi: drivers: fix possible bug in comedi_handle_events()
    
    This function assumes that the async subdevice has a cancel() function.
    It looks like all the current comedi drivers implement a cancel() for
    the async subdevices except for the dt2814 analog input usbdevice.
    
    Fix comedi_handle_events() so it does not try to call a non-existent
    cancel() function.
    
    Add a dev_warn() to __comedi_device_postconfig_async() so that any new
    driver authors will be reminded to implement the cancel().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index e3bbc8f724ba..44511d729450 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -564,7 +564,7 @@ unsigned int comedi_handle_events(struct comedi_device *dev,
 	if (events == 0)
 		return events;
 
-	if (events & COMEDI_CB_CANCEL_MASK)
+	if ((events & COMEDI_CB_CANCEL_MASK) && s->cancel)
 		s->cancel(dev, s);
 
 	comedi_event(dev, s);
@@ -625,6 +625,9 @@ static int __comedi_device_postconfig_async(struct comedi_device *dev,
 			 "async subdevices must have a do_cmdtest() function\n");
 		return -EINVAL;
 	}
+	if (!s->cancel)
+		dev_warn(dev->class_dev,
+			 "async subdevices should have a cancel() function\n");
 
 	async = kzalloc(sizeof(*async), GFP_KERNEL);
 	if (!async)

commit f91852ce61339ca0ca557c7ce5838f3a774a1bf5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 30 10:47:24 2016 -0700

    staging: comedi: drivers: tidy up insn_rw_emulate_bits()
    
    Tidy up this function and fix the checkpatch.pl issues:
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index b63dd2ef78b5..e3bbc8f724ba 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -575,38 +575,35 @@ EXPORT_SYMBOL_GPL(comedi_handle_events);
 
 static int insn_rw_emulate_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
-	struct comedi_insn new_insn;
+	struct comedi_insn _insn;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int base_chan = (chan < 32) ? 0 : chan;
+	unsigned int _data[2];
 	int ret;
-	static const unsigned channels_per_bitfield = 32;
-
-	unsigned chan = CR_CHAN(insn->chanspec);
-	const unsigned base_bitfield_channel =
-	    (chan < channels_per_bitfield) ? 0 : chan;
-	unsigned int new_data[2];
 
-	memset(new_data, 0, sizeof(new_data));
-	memset(&new_insn, 0, sizeof(new_insn));
-	new_insn.insn = INSN_BITS;
-	new_insn.chanspec = base_bitfield_channel;
-	new_insn.n = 2;
-	new_insn.subdev = insn->subdev;
+	memset(_data, 0, sizeof(_data));
+	memset(&_insn, 0, sizeof(_insn));
+	_insn.insn = INSN_BITS;
+	_insn.chanspec = base_chan;
+	_insn.n = 2;
+	_insn.subdev = insn->subdev;
 
 	if (insn->insn == INSN_WRITE) {
 		if (!(s->subdev_flags & SDF_WRITABLE))
 			return -EINVAL;
-		new_data[0] = 1 << (chan - base_bitfield_channel); /* mask */
-		new_data[1] = data[0] ? (1 << (chan - base_bitfield_channel))
-			      : 0; /* bits */
+		_data[0] = 1 << (chan - base_chan);		    /* mask */
+		_data[1] = data[0] ? (1 << (chan - base_chan)) : 0; /* bits */
 	}
 
-	ret = s->insn_bits(dev, s, &new_insn, new_data);
+	ret = s->insn_bits(dev, s, &_insn, _data);
 	if (ret < 0)
 		return ret;
 
 	if (insn->insn == INSN_READ)
-		data[0] = (new_data[1] >> (chan - base_bitfield_channel)) & 1;
+		data[0] = (_data[1] >> (chan - base_chan)) & 1;
 
 	return 1;
 }

commit 92d354cbe95fcaa0e5f795ad7706bc8393915c57
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 23 10:56:09 2015 +0100

    staging: comedi: fix extreme case of comedi_nsamples_left()
    
    `comedi_nsamples_left(s, nsamples)` returns the number of samples
    remaining to complete an asynchronous command or the passed in
    `nsamples`, whichever is lower.  However, it goes wrong in the extreme
    case of setting the `nsamples` parameter to `UINT_MAX` when the number
    of conversions per "scan" (`s->async->cmd.scan_end_arg`) is 1.  It uses
    `comedi_nscans_remaining(s, nscans)` to determine the number of scans
    remaining, or the parameter `nscans`, whichever is lower.  To determine
    the parameter `nscans`, it divides `nsamples` by the number of
    conversions per scan and adds 1.  The addition of 1 is to avoid setting
    the parameter `nscans` to 0, as `comedi_nscans_remaining(s, nscans)`
    treats that value specially.  However in the extreme case where
    `nsamples` is `UINT_MAX` and the number of samples per scan is 1, the
    addition of 1 to `nscans` overflows, producing the unwanted 0.
    
    Fix it by refactoring new a function `__comedi_nscans_remaining(s,
    nscans)` out of `comedi_nscans_remaining(s, nscans)`.  The new function
    does everything except the special handling when `nscans` is 0.  Change
    `comedi_nsamples_remaining()` to call the new function without adding 1
    to `nscans` to avoid the overflow.
    
    This overflow bug doesn't affect any of the current COMEDI drivers.  I
    stumbled across it while changing to one of the drivers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index aae94815b593..b63dd2ef78b5 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -425,6 +425,24 @@ unsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)
 }
 EXPORT_SYMBOL_GPL(comedi_bytes_per_scan);
 
+static unsigned int __comedi_nscans_left(struct comedi_subdevice *s,
+					 unsigned int nscans)
+{
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		unsigned int scans_left = 0;
+
+		if (async->scans_done < cmd->stop_arg)
+			scans_left = cmd->stop_arg - async->scans_done;
+
+		if (nscans > scans_left)
+			nscans = scans_left;
+	}
+	return nscans;
+}
+
 /**
  * comedi_nscans_left() - Return the number of scans left in the command
  * @s: COMEDI subdevice.
@@ -442,25 +460,12 @@ EXPORT_SYMBOL_GPL(comedi_bytes_per_scan);
 unsigned int comedi_nscans_left(struct comedi_subdevice *s,
 				unsigned int nscans)
 {
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
-
 	if (nscans == 0) {
 		unsigned int nbytes = comedi_buf_read_n_available(s);
 
 		nscans = nbytes / comedi_bytes_per_scan(s);
 	}
-
-	if (cmd->stop_src == TRIG_COUNT) {
-		unsigned int scans_left = 0;
-
-		if (async->scans_done < cmd->stop_arg)
-			scans_left = cmd->stop_arg - async->scans_done;
-
-		if (nscans > scans_left)
-			nscans = scans_left;
-	}
-	return nscans;
+	return __comedi_nscans_left(s, nscans);
 }
 EXPORT_SYMBOL_GPL(comedi_nscans_left);
 
@@ -479,9 +484,8 @@ unsigned int comedi_nsamples_left(struct comedi_subdevice *s,
 	struct comedi_cmd *cmd = &async->cmd;
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		/* +1 to force comedi_nscans_left() to return the scans left */
-		unsigned int nscans = (nsamples / cmd->scan_end_arg) + 1;
-		unsigned int scans_left = comedi_nscans_left(s, nscans);
+		unsigned int nscans = nsamples / cmd->scan_end_arg;
+		unsigned int scans_left = __comedi_nscans_left(s, nscans);
 		unsigned int scan_pos =
 		    comedi_bytes_to_samples(s, async->scan_progress);
 		unsigned long long samples_left = 0;

commit 9b34845ee3620ddf1329932edde00bd5b4b9d466
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Sep 17 17:19:17 2015 +0100

    staging: comedi: drivers.c: document exported functions
    
    Add missing kernel-doc to the low-level COMEDI driver API functions
    exported from "drivers.c" and tart up some of the existing kernel-doc
    comments for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 711811771bfc..aae94815b593 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -34,6 +34,28 @@ struct comedi_driver *comedi_drivers;
 /* protects access to comedi_drivers */
 DEFINE_MUTEX(comedi_drivers_list_lock);
 
+/**
+ * comedi_set_hw_dev() - Set hardware device associated with COMEDI device
+ * @dev: COMEDI device.
+ * @hw_dev: Hardware device.
+ *
+ * For automatically configured COMEDI devices (resulting from a call to
+ * comedi_auto_config() or one of its wrappers from the low-level COMEDI
+ * driver), comedi_set_hw_dev() is called automatically by the COMEDI core
+ * to associate the COMEDI device with the hardware device.  It can also be
+ * called directly by "legacy" low-level COMEDI drivers that rely on the
+ * %COMEDI_DEVCONFIG ioctl to configure the hardware as long as the hardware
+ * has a &struct device.
+ *
+ * If @dev->hw_dev is NULL, it gets a reference to @hw_dev and sets
+ * @dev->hw_dev, otherwise, it does nothing.  Calling it multiple times
+ * with the same hardware device is not considered an error.  If it gets
+ * a reference to the hardware device, it will be automatically 'put' when
+ * the device is detached from COMEDI.
+ *
+ * Returns 0 if @dev->hw_dev was NULL or the same as @hw_dev, otherwise
+ * returns -EEXIST.
+ */
 int comedi_set_hw_dev(struct comedi_device *dev, struct device *hw_dev)
 {
 	if (hw_dev == dev->hw_dev)
@@ -52,9 +74,15 @@ static void comedi_clear_hw_dev(struct comedi_device *dev)
 }
 
 /**
- * comedi_alloc_devpriv() - Allocate memory for the device private data.
- * @dev: comedi_device struct
- * @size: size of the memory to allocate
+ * comedi_alloc_devpriv() - Allocate memory for the device private data
+ * @dev: COMEDI device.
+ * @size: Size of the memory to allocate.
+ *
+ * The allocated memory is zero-filled.  @dev->private points to it on
+ * return.  The memory will be automatically freed when the COMEDI device is
+ * "detached".
+ *
+ * Returns a pointer to the allocated memory, or NULL on failure.
  */
 void *comedi_alloc_devpriv(struct comedi_device *dev, size_t size)
 {
@@ -63,6 +91,18 @@ void *comedi_alloc_devpriv(struct comedi_device *dev, size_t size)
 }
 EXPORT_SYMBOL_GPL(comedi_alloc_devpriv);
 
+/**
+ * comedi_alloc_subdevices() - Allocate subdevices for COMEDI device
+ * @dev: COMEDI device.
+ * @num_subdevices: Number of subdevices to allocate.
+ *
+ * Allocates and initializes an array of &struct comedi_subdevice for the
+ * COMEDI device.  If successful, sets @dev->subdevices to point to the
+ * first one and @dev->n_subdevices to the number.
+ *
+ * Returns 0 on success, -EINVAL if @num_subdevices is < 1, or -ENOMEM if
+ * failed to allocate the memory.
+ */
 int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 {
 	struct comedi_subdevice *s;
@@ -90,8 +130,22 @@ int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 EXPORT_SYMBOL_GPL(comedi_alloc_subdevices);
 
 /**
- * comedi_alloc_subdev_readback() - Allocate memory for the subdevice readback.
- * @s: comedi_subdevice struct
+ * comedi_alloc_subdev_readback() - Allocate memory for the subdevice readback
+ * @s: COMEDI subdevice.
+ *
+ * This is called by low-level COMEDI drivers to allocate an array to record
+ * the last values written to a subdevice's analog output channels (at least
+ * by the %INSN_WRITE instruction), to allow them to be read back by an
+ * %INSN_READ instruction.  It also provides a default handler for the
+ * %INSN_READ instruction unless one has already been set.
+ *
+ * On success, @s->readback points to the first element of the array, which
+ * is zero-filled.  The low-level driver is responsible for updating its
+ * contents.  @s->insn_read will be set to comedi_readback_insn_read()
+ * unless it is already non-NULL.
+ *
+ * Returns 0 on success, -EINVAL if the subdevice has no channels, or
+ * -ENOMEM on allocation failure.
  */
 int comedi_alloc_subdev_readback(struct comedi_subdevice *s)
 {
@@ -174,10 +228,20 @@ int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
 
 /**
  * comedi_readback_insn_read() - A generic (*insn_read) for subdevice readback.
- * @dev: comedi_device struct
- * @s: comedi_subdevice struct
- * @insn: comedi_insn struct
- * @data: pointer to return the readback data
+ * @dev: COMEDI device.
+ * @s: COMEDI subdevice.
+ * @insn: COMEDI instruction.
+ * @data: Pointer to return the readback data.
+ *
+ * Handles the %INSN_READ instruction for subdevices that use the readback
+ * array allocated by comedi_alloc_subdev_readback().  It may be used
+ * directly as the subdevice's handler (@s->insn_read) or called via a
+ * wrapper.
+ *
+ * @insn->n is normally 1, which will read a single value.  If higher, the
+ * same element of the readback array will be read multiple times.
+ *
+ * Returns @insn->n on success, or -EINVAL if @s->readback is NULL.
  */
 int comedi_readback_insn_read(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
@@ -198,12 +262,21 @@ int comedi_readback_insn_read(struct comedi_device *dev,
 EXPORT_SYMBOL_GPL(comedi_readback_insn_read);
 
 /**
- * comedi_timeout() - busy-wait for a driver condition to occur.
- * @dev: comedi_device struct
- * @s: comedi_subdevice struct
- * @insn: comedi_insn struct
- * @cb: callback to check for the condition
- * @context: private context from the driver
+ * comedi_timeout() - Busy-wait for a driver condition to occur
+ * @dev: COMEDI device.
+ * @s: COMEDI subdevice.
+ * @insn: COMEDI instruction.
+ * @cb: Callback to check for the condition.
+ * @context: Private context from the driver.
+ *
+ * Busy-waits for up to a second (%COMEDI_TIMEOUT_MS) for the condition or
+ * some error (other than -EBUSY) to occur.  The parameters @dev, @s, @insn,
+ * and @context are passed to the callback function, which returns -EBUSY to
+ * continue waiting or some other value to stop waiting (generally 0 if the
+ * condition occurred, or some error value).
+ *
+ * Returns -ETIMEDOUT if timed out, otherwise the return value from the
+ * callback function.
  */
 int comedi_timeout(struct comedi_device *dev,
 		   struct comedi_subdevice *s,
@@ -228,12 +301,30 @@ int comedi_timeout(struct comedi_device *dev,
 EXPORT_SYMBOL_GPL(comedi_timeout);
 
 /**
- * comedi_dio_insn_config() - boilerplate (*insn_config) for DIO subdevices.
- * @dev: comedi_device struct
- * @s: comedi_subdevice struct
- * @insn: comedi_insn struct
- * @data: parameters for the @insn
- * @mask: io_bits mask for grouped channels
+ * comedi_dio_insn_config() - Boilerplate (*insn_config) for DIO subdevices
+ * @dev: COMEDI device.
+ * @s: COMEDI subdevice.
+ * @insn: COMEDI instruction.
+ * @data: Instruction parameters and return data.
+ * @mask: io_bits mask for grouped channels, or 0 for single channel.
+ *
+ * If @mask is 0, it is replaced with a single-bit mask corresponding to the
+ * channel number specified by @insn->chanspec.  Otherwise, @mask
+ * corresponds to a group of channels (which should include the specified
+ * channel) that are always configured together as inputs or outputs.
+ *
+ * Partially handles the %INSN_CONFIG_DIO_INPUT, %INSN_CONFIG_DIO_OUTPUTS,
+ * and %INSN_CONFIG_DIO_QUERY instructions.  The first two update
+ * @s->io_bits to record the directions of the masked channels.  The last
+ * one sets @data[1] to the current direction of the group of channels
+ * (%COMEDI_INPUT) or %COMEDI_OUTPUT) as recorded in @s->io_bits.
+ *
+ * The caller is responsible for updating the DIO direction in the hardware
+ * registers if this function returns 0.
+ *
+ * Returns 0 for a %INSN_CONFIG_DIO_INPUT or %INSN_CONFIG_DIO_OUTPUT
+ * instruction, @insn->n (> 0) for a %INSN_CONFIG_DIO_QUERY instruction, or
+ * -EINVAL for some other instruction.
  */
 int comedi_dio_insn_config(struct comedi_device *dev,
 			   struct comedi_subdevice *s,
@@ -268,9 +359,18 @@ int comedi_dio_insn_config(struct comedi_device *dev,
 EXPORT_SYMBOL_GPL(comedi_dio_insn_config);
 
 /**
- * comedi_dio_update_state() - update the internal state of DIO subdevices.
- * @s: comedi_subdevice struct
- * @data: the channel mask and bits to update
+ * comedi_dio_update_state() - Update the internal state of DIO subdevices
+ * @s: COMEDI subdevice.
+ * @data: The channel mask and bits to update.
+ *
+ * Updates @s->state which holds the internal state of the outputs for DIO
+ * or DO subdevices (up to 32 channels).  @data[0] contains a bit-mask of
+ * the channels to be updated.  @data[1] contains a bit-mask of those
+ * channels to be set to '1'.  The caller is responsible for updating the
+ * outputs in hardware according to @s->state.  As a minimum, the channels
+ * in the returned bit-mask need to be updated.
+ *
+ * Returns @mask with non-existent channels removed.
  */
 unsigned int comedi_dio_update_state(struct comedi_subdevice *s,
 				     unsigned int *data)
@@ -290,17 +390,17 @@ unsigned int comedi_dio_update_state(struct comedi_subdevice *s,
 EXPORT_SYMBOL_GPL(comedi_dio_update_state);
 
 /**
- * comedi_bytes_per_scan - get length of asynchronous command "scan" in bytes
- * @s: comedi_subdevice struct
+ * comedi_bytes_per_scan() - Get length of asynchronous command "scan" in bytes
+ * @s: COMEDI subdevice.
  *
  * Determines the overall scan length according to the subdevice type and the
  * number of channels in the scan.
  *
- * For digital input, output or input/output subdevices, samples for multiple
- * channels are assumed to be packed into one or more unsigned short or
- * unsigned int values according to the subdevice's SDF_LSAMPL flag.  For other
- * types of subdevice, samples are assumed to occupy a whole unsigned short or
- * unsigned int according to the SDF_LSAMPL flag.
+ * For digital input, output or input/output subdevices, samples for
+ * multiple channels are assumed to be packed into one or more unsigned
+ * short or unsigned int values according to the subdevice's %SDF_LSAMPL
+ * flag.  For other types of subdevice, samples are assumed to occupy a
+ * whole unsigned short or unsigned int according to the %SDF_LSAMPL flag.
  *
  * Returns the overall scan length in bytes.
  */
@@ -326,18 +426,18 @@ unsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)
 EXPORT_SYMBOL_GPL(comedi_bytes_per_scan);
 
 /**
- * comedi_nscans_left - return the number of scans left in the command
- * @s: comedi_subdevice struct
- * @nscans: the expected number of scans
+ * comedi_nscans_left() - Return the number of scans left in the command
+ * @s: COMEDI subdevice.
+ * @nscans: The expected number of scans or 0 for all available scans.
  *
- * If nscans is 0, the number of scans available in the async buffer will be
- * used. Otherwise the expected number of scans will be used.
+ * If @nscans is 0, it is set to the number of scans available in the
+ * async buffer.
  *
- * If the async command has a stop_src of TRIG_COUNT, the nscans will be
- * checked against the number of scans left in the command.
+ * If the async command has a stop_src of %TRIG_COUNT, the @nscans will be
+ * checked against the number of scans remaining to complete the command.
  *
  * The return value will then be either the expected number of scans or the
- * number of scans remaining in the command.
+ * number of scans remaining to complete the command, whichever is fewer.
  */
 unsigned int comedi_nscans_left(struct comedi_subdevice *s,
 				unsigned int nscans)
@@ -365,12 +465,12 @@ unsigned int comedi_nscans_left(struct comedi_subdevice *s,
 EXPORT_SYMBOL_GPL(comedi_nscans_left);
 
 /**
- * comedi_nsamples_left - return the number of samples left in the command
- * @s: comedi_subdevice struct
- * @nsamples: the expected number of samples
+ * comedi_nsamples_left() - Return the number of samples left in the command
+ * @s: COMEDI subdevice.
+ * @nsamples: The expected number of samples.
  *
- * Returns the expected number of samples of the number of samples remaining
- * in the command.
+ * Returns the number of samples remaining to complete the command, or the
+ * specified expected number of samples (@nsamples), whichever is fewer.
  */
 unsigned int comedi_nsamples_left(struct comedi_subdevice *s,
 				  unsigned int nsamples)
@@ -399,14 +499,14 @@ unsigned int comedi_nsamples_left(struct comedi_subdevice *s,
 EXPORT_SYMBOL_GPL(comedi_nsamples_left);
 
 /**
- * comedi_inc_scan_progress - update scan progress in asynchronous command
- * @s: comedi_subdevice struct
- * @num_bytes: amount of data in bytes to increment scan progress
+ * comedi_inc_scan_progress() - Update scan progress in asynchronous command
+ * @s: COMEDI subdevice.
+ * @num_bytes: Amount of data in bytes to increment scan progress.
  *
- * Increments the scan progress by the number of bytes specified by num_bytes.
+ * Increments the scan progress by the number of bytes specified by @num_bytes.
  * If the scan progress reaches or exceeds the scan length in bytes, reduce
  * it modulo the scan length in bytes and set the "end of scan" asynchronous
- * event flag to be processed later.
+ * event flag (%COMEDI_CB_EOS) to be processed later.
  */
 void comedi_inc_scan_progress(struct comedi_subdevice *s,
 			      unsigned int num_bytes)
@@ -437,12 +537,12 @@ void comedi_inc_scan_progress(struct comedi_subdevice *s,
 EXPORT_SYMBOL_GPL(comedi_inc_scan_progress);
 
 /**
- * comedi_handle_events - handle events and possibly stop acquisition
- * @dev: comedi_device struct
- * @s: comedi_subdevice struct
+ * comedi_handle_events() - Handle events and possibly stop acquisition
+ * @dev: COMEDI device.
+ * @s: COMEDI subdevice.
  *
  * Handles outstanding asynchronous acquisition event flags associated
- * with the subdevice.  Call the subdevice's "->cancel()" handler if the
+ * with the subdevice.  Call the subdevice's @s->cancel() handler if the
  * "end of acquisition", "error" or "overflow" event flags are set in order
  * to stop the acquisition at the driver level.
  *
@@ -677,12 +777,19 @@ static void comedi_report_boards(struct comedi_driver *driv)
 }
 
 /**
- * comedi_load_firmware() - Request and load firmware for a device.
- * @dev: comedi_device struct
- * @hw_device: device struct for the comedi_device
- * @name: the name of the firmware image
- * @cb: callback to the upload the firmware image
- * @context: private context from the driver
+ * comedi_load_firmware() - Request and load firmware for a device
+ * @dev: COMEDI device.
+ * @device: Hardware device.
+ * @name: The name of the firmware image.
+ * @cb: Callback to the upload the firmware image.
+ * @context: Private context from the driver.
+ *
+ * Sends a firmware request for the hardware device and waits for it.  Calls
+ * the callback function to upload the firmware to the device, them releases
+ * the firmware.
+ *
+ * Returns 0 on success, -EINVAL if @cb is NULL, or a negative error number
+ * from the firmware request or the callback function.
  */
 int comedi_load_firmware(struct comedi_device *dev,
 			 struct device *device,
@@ -709,10 +816,16 @@ int comedi_load_firmware(struct comedi_device *dev,
 EXPORT_SYMBOL_GPL(comedi_load_firmware);
 
 /**
- * __comedi_request_region() - Request an I/O reqion for a legacy driver.
- * @dev: comedi_device struct
- * @start: base address of the I/O reqion
- * @len: length of the I/O region
+ * __comedi_request_region() - Request an I/O region for a legacy driver
+ * @dev: COMEDI device.
+ * @start: Base address of the I/O region.
+ * @len: Length of the I/O region.
+ *
+ * Requests the specified I/O port region which must start at a non-zero
+ * address.
+ *
+ * Returns 0 on success, -EINVAL if @start is 0, or -EIO if the request
+ * fails.
  */
 int __comedi_request_region(struct comedi_device *dev,
 			    unsigned long start, unsigned long len)
@@ -735,10 +848,19 @@ int __comedi_request_region(struct comedi_device *dev,
 EXPORT_SYMBOL_GPL(__comedi_request_region);
 
 /**
- * comedi_request_region() - Request an I/O reqion for a legacy driver.
- * @dev: comedi_device struct
- * @start: base address of the I/O reqion
- * @len: length of the I/O region
+ * comedi_request_region() - Request an I/O region for a legacy driver
+ * @dev: COMEDI device.
+ * @start: Base address of the I/O region.
+ * @len: Length of the I/O region.
+ *
+ * Requests the specified I/O port region which must start at a non-zero
+ * address.
+ *
+ * On success, @dev->iobase is set to the base address of the region and
+ * @dev->iolen is set to its length.
+ *
+ * Returns 0 on success, -EINVAL if @start is 0, or -EIO if the request
+ * fails.
  */
 int comedi_request_region(struct comedi_device *dev,
 			  unsigned long start, unsigned long len)
@@ -756,8 +878,16 @@ int comedi_request_region(struct comedi_device *dev,
 EXPORT_SYMBOL_GPL(comedi_request_region);
 
 /**
- * comedi_legacy_detach() - A generic (*detach) function for legacy drivers.
- * @dev: comedi_device struct
+ * comedi_legacy_detach() - A generic (*detach) function for legacy drivers
+ * @dev: COMEDI device.
+ *
+ * This is a simple, generic 'detach' handler for legacy COMEDI devices that
+ * just use a single I/O port region and possibly an IRQ and that don't need
+ * any special clean-up for their private device or subdevice storage.  It
+ * can also be called by a driver-specific 'detach' handler.
+ *
+ * If @dev->irq is non-zero, the IRQ will be freed.  If @dev->iobase and
+ * @dev->iolen are both non-zero, the I/O port region will be released.
  */
 void comedi_legacy_detach(struct comedi_device *dev)
 {
@@ -831,6 +961,29 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return ret;
 }
 
+/**
+ * comedi_auto_config() - Create a COMEDI device for a hardware device
+ * @hardware_device: Hardware device.
+ * @driver: COMEDI low-level driver for the hardware device.
+ * @context: Driver context for the auto_attach handler.
+ *
+ * Allocates a new COMEDI device for the hardware device and calls the
+ * low-level driver's 'auto_attach' handler to set-up the hardware and
+ * allocate the COMEDI subdevices.  Additional "post-configuration" setting
+ * up is performed on successful return from the 'auto_attach' handler.
+ * If the 'auto_attach' handler fails, the low-level driver's 'detach'
+ * handler will be called as part of the clean-up.
+ *
+ * This is usually called from a wrapper function in a bus-specific COMEDI
+ * module, which in turn is usually called from a bus device 'probe'
+ * function in the low-level driver.
+ *
+ * Returns 0 on success, -EINVAL if the parameters are invalid or the
+ * post-configuration determines the driver has set the COMEDI device up
+ * incorrectly, -ENOMEM if failed to allocate memory, -EBUSY if run out of
+ * COMEDI minor device numbers, or some negative error number returned by
+ * the driver's 'auto_attach' handler.
+ */
 int comedi_auto_config(struct device *hardware_device,
 		       struct comedi_driver *driver, unsigned long context)
 {
@@ -888,6 +1041,22 @@ int comedi_auto_config(struct device *hardware_device,
 }
 EXPORT_SYMBOL_GPL(comedi_auto_config);
 
+/**
+ * comedi_auto_unconfig() - Unconfigure auto-allocated COMEDI device
+ * @hardware_device: Hardware device previously passed to
+ *                   comedi_auto_config().
+ *
+ * Cleans up and eventually destroys the COMEDI device allocated by
+ * comedi_auto_config() for the same hardware device.  As part of this
+ * clean-up, the low-level COMEDI driver's 'detach' handler will be called.
+ * (The COMEDI device itself will persist in an unattached state if it is
+ * still open, until it is released, and any mmapped buffers will persist
+ * until they are munmapped.)
+ *
+ * This is usually called from a wrapper module in a bus-specific COMEDI
+ * module, which in turn is usually set as the bus device 'remove' function
+ * in the low-level COMEDI driver.
+ */
 void comedi_auto_unconfig(struct device *hardware_device)
 {
 	if (!hardware_device)
@@ -896,6 +1065,17 @@ void comedi_auto_unconfig(struct device *hardware_device)
 }
 EXPORT_SYMBOL_GPL(comedi_auto_unconfig);
 
+/**
+ * comedi_driver_register() - Register a low-level COMEDI driver
+ * @driver: Low-level COMEDI driver.
+ *
+ * The low-level COMEDI driver is added to the list of registered COMEDI
+ * drivers.  This is used by the handler for the "/proc/comedi" file and is
+ * also used by the handler for the %COMEDI_DEVCONFIG ioctl to configure
+ * "legacy" COMEDI devices (for those low-level drivers that support it).
+ *
+ * Returns 0.
+ */
 int comedi_driver_register(struct comedi_driver *driver)
 {
 	mutex_lock(&comedi_drivers_list_lock);
@@ -907,6 +1087,15 @@ int comedi_driver_register(struct comedi_driver *driver)
 }
 EXPORT_SYMBOL_GPL(comedi_driver_register);
 
+/**
+ * comedi_driver_unregister() - Unregister a low-level COMEDI driver
+ * @driver: Low-level COMEDI driver.
+ *
+ * The low-level COMEDI driver is removed from the list of registered COMEDI
+ * drivers.  Detaches any COMEDI devices attached to the driver, which will
+ * result in the low-level driver's 'detach' handler being called for those
+ * devices before this function returns.
+ */
 void comedi_driver_unregister(struct comedi_driver *driver)
 {
 	struct comedi_driver *prev;

commit d35d893965a6d7efe995d7f8d66b2427c14bbc36
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Sep 17 17:19:16 2015 +0100

    staging: comedi: drivers.c: replace #include <linux/dma-mapping.h>
    
    Comedi's "drivers.c" doesn't use anything from `<linux/dma-mapping.h>`,
    but it does use `DMA_NONE` from `<linux/dma-direction.h>`, so replace
    the appropriate `#include` directive.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index e3b9957b7dc0..711811771bfc 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -23,7 +23,7 @@
 #include <linux/kernel.h>
 #include <linux/ioport.h>
 #include <linux/slab.h>
-#include <linux/dma-mapping.h>
+#include <linux/dma-direction.h>
 #include <linux/interrupt.h>
 #include <linux/firmware.h>
 

commit db0700a18d7d8832e3f5f5c3a55f197258e257e5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Sep 17 17:19:15 2015 +0100

    staging: comedi: drivers.c: remove irrelevant #includes
    
    Comedi's "drivers.c" doesn't use anything from these included headers,
    so remove them.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 387fac106084..e3b9957b7dc0 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -20,18 +20,10 @@
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/errno.h>
-#include <linux/kconfig.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/fcntl.h>
 #include <linux/ioport.h>
-#include <linux/mm.h>
 #include <linux/slab.h>
-#include <linux/highmem.h>	/* for SuSE brokenness */
-#include <linux/vmalloc.h>
-#include <linux/cdev.h>
 #include <linux/dma-mapping.h>
-#include <linux/io.h>
 #include <linux/interrupt.h>
 #include <linux/firmware.h>
 

commit 50fbb884e1afdb8f650b10e86e5975ca4ec53e6b
Author: Marcos Canán <mcanan@gmail.com>
Date:   Wed Sep 16 17:48:57 2015 -0300

    staging: comedi: drivers: coding style: fixed block comment style
    
    This is a patch to the drivers.c file that fixes
    a block comment style.
    
    Signed-off-by: Marcos Canán <mcanan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index b03bc6639f79..387fac106084 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -1,20 +1,20 @@
 /*
-    module/drivers.c
-    functions for manipulating drivers
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 1997-2000 David A. Schleef <ds@schleef.org>
-    Copyright (C) 2002 Frank Mori Hess <fmhess@users.sourceforge.net>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+ *  module/drivers.c
+ *  functions for manipulating drivers
+ *
+ *  COMEDI - Linux Control and Measurement Device Interface
+ *  Copyright (C) 1997-2000 David A. Schleef <ds@schleef.org>
+ *  Copyright (C) 2002 Frank Mori Hess <fmhess@users.sourceforge.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
 */
 
 #include <linux/device.h>

commit 1a59adb222bc4758241eb4ff253faa5b1ebd4cab
Author: Ted Chen <tedc.37zngo@gmail.com>
Date:   Wed Aug 5 01:18:46 2015 +0800

    staging: comedi: do not return -ENOSYS.
    
    fixed coding style issue by replacing ENOSYS
    with EIO because it means 'invalid syscall nr'
    and nothing else.
    
    Signed-off-by: Ted Chen <tedc.37zngo@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index ed0b60c925de..b03bc6639f79 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -820,7 +820,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			 "driver '%s' does not support attach using comedi_config\n",
 			 driv->driver_name);
 		module_put(driv->module);
-		ret = -ENOSYS;
+		ret = -EIO;
 		goto out;
 	}
 	dev->driver = driv;

commit 8fc369ae38ff281d38e9ea11805a5cae862989bc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Apr 21 13:18:10 2015 +0100

    staging: comedi: wrap COMEDI_SRF_FREE_SPRIV usage
    
    The `COMEDI_SRF_FREE_SPRIV` flag in the `runflags` member of `struct
    comedi_subdevice` indicates that the memory pointed to by the `private`
    member can be automatically freed by the comedi core on subdevice
    clean-up (when the low-level comedi device is being "detached").  the
    flag doesn't really belong in `runflags`, but it was somewhere
    convenient to keep it without having to add a new member to the
    structure.
    
    Rather than access the `COMEDI_SRF_FREE_SPRIV` flag directly, use some
    new wrapper functions:
    
    * comedi_can_auto_free_spriv(s) - checks whether the subdevice's
      `s->private` points to memory that can be freed automatically.
    * comedi_set_spriv_auto_free(s) - marks the subdevice as having a
      `s->private` that points to memory that can be freed automatically.
    
    Export `comedi_set_spriv_auto_free()` for use by the low-level comedi
    driver modules, in particular the "amplc_dio200_common" module.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 57dcffe00204..ed0b60c925de 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -125,7 +125,7 @@ static void comedi_device_detach_cleanup(struct comedi_device *dev)
 	if (dev->subdevices) {
 		for (i = 0; i < dev->n_subdevices; i++) {
 			s = &dev->subdevices[i];
-			if (s->runflags & COMEDI_SRF_FREE_SPRIV)
+			if (comedi_can_auto_free_spriv(s))
 				kfree(s->private);
 			comedi_free_subdevice_minor(s);
 			if (s->async) {

commit e2850160763e716e55fa6328bfab335cac90fc80
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 4 12:15:29 2015 -0700

    staging: comedi: drivers: (!foo) preferred over (foo == NULL)
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index e87c68cf11d4..57dcffe00204 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -46,7 +46,7 @@ int comedi_set_hw_dev(struct comedi_device *dev, struct device *hw_dev)
 {
 	if (hw_dev == dev->hw_dev)
 		return 0;
-	if (dev->hw_dev != NULL)
+	if (dev->hw_dev)
 		return -EEXIST;
 	dev->hw_dev = get_device(hw_dev);
 	return 0;
@@ -802,7 +802,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 		module_put(driv->module);
 	}
-	if (driv == NULL) {
+	if (!driv) {
 		/*  recognize has failed if we get here */
 		/*  report valid board names before returning error */
 		for (driv = comedi_drivers; driv; driv = driv->next) {
@@ -814,7 +814,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		ret = -EIO;
 		goto out;
 	}
-	if (driv->attach == NULL) {
+	if (!driv->attach) {
 		/* driver does not support manual configuration */
 		dev_warn(dev->class_dev,
 			 "driver '%s' does not support attach using comedi_config\n",
@@ -898,7 +898,7 @@ EXPORT_SYMBOL_GPL(comedi_auto_config);
 
 void comedi_auto_unconfig(struct device *hardware_device)
 {
-	if (hardware_device == NULL)
+	if (!hardware_device)
 		return;
 	comedi_release_hardware_device(hardware_device);
 }

commit 43db062afe993fbfed184d78293527679fef9784
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:57:29 2015 -0700

    staging: comedi: add 'pacer' member to struct comedi_device
    
    Add a new member to the comedi_device struct for a comedi_8254 'pacer'. This
    provides a convient place to store the data allocated by the comedi_8254 module
    for boards that use an 8254 device to create the data acquisition pacer clock.
    
    Automatically free this pointer in comedi_device_detach_cleanup() so that the
    drivers don't need to do it when then are detached.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index f32e71438948..e87c68cf11d4 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -139,7 +139,9 @@ static void comedi_device_detach_cleanup(struct comedi_device *dev)
 		dev->n_subdevices = 0;
 	}
 	kfree(dev->private);
+	kfree(dev->pacer);
 	dev->private = NULL;
+	dev->pacer = NULL;
 	dev->driver = NULL;
 	dev->board_name = NULL;
 	dev->board_ptr = NULL;

commit 84bb0bccd26ec3029124a9dd200b985c1cde77bd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:00 2015 -0700

    staging: comedi: comedidev.h: add namespace to the subdevice "runflags"
    
    Tidy up and document the subdevice "runflags". Rename them so they have
    comedi namespace.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 61802d7947ae..f32e71438948 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -125,7 +125,7 @@ static void comedi_device_detach_cleanup(struct comedi_device *dev)
 	if (dev->subdevices) {
 		for (i = 0; i < dev->n_subdevices; i++) {
 			s = &dev->subdevices[i];
-			if (s->runflags & SRF_FREE_SPRIV)
+			if (s->runflags & COMEDI_SRF_FREE_SPRIV)
 				kfree(s->private);
 			comedi_free_subdevice_minor(s);
 			if (s->async) {

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index e516ed907f7e..61802d7947ae 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -109,6 +109,10 @@ int comedi_alloc_subdev_readback(struct comedi_subdevice *s)
 	s->readback = kcalloc(s->n_chan, sizeof(*s->readback), GFP_KERNEL);
 	if (!s->readback)
 		return -ENOMEM;
+
+	if (!s->insn_read)
+		s->insn_read = comedi_readback_insn_read;
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(comedi_alloc_subdev_readback);

commit af57d89e162a18676cb87825e193125e40f4c34b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 12 16:00:48 2014 +0000

    staging: comedi: fix scan_end_arg == chanlist_len assumption
    
    Some comedi drivers allow the `scan_end_arg` value of an asynchronous
    command to be a multiple (> 1) of the `chanlist_len` although most
    require them to be the same value.
    
    `comedi_bytes_per_scan()` is incorrectly using `chanlist_len` as the
    length of the scan.  Change it to use `scan_end_arg`.
    
    `comedi_nsamples_left()` is incorrectly using `cur_chan` as the current
    sample position in the scan (it is actually the current position in the
    channel list).  Change it to use the actual sample position in the scan.
    (Unfortunately we only have the current scan position in bytes currently,
    so convert that to a sample position.)
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 82ac84504589..e516ed907f7e 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -317,10 +317,10 @@ unsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)
 	case COMEDI_SUBD_DO:
 	case COMEDI_SUBD_DIO:
 		bits_per_sample = 8 * comedi_bytes_per_sample(s);
-		num_samples = DIV_ROUND_UP(cmd->chanlist_len, bits_per_sample);
+		num_samples = DIV_ROUND_UP(cmd->scan_end_arg, bits_per_sample);
 		break;
 	default:
-		num_samples = cmd->chanlist_len;
+		num_samples = cmd->scan_end_arg;
 		break;
 	}
 	return comedi_samples_to_bytes(s, num_samples);
@@ -384,11 +384,13 @@ unsigned int comedi_nsamples_left(struct comedi_subdevice *s,
 		/* +1 to force comedi_nscans_left() to return the scans left */
 		unsigned int nscans = (nsamples / cmd->scan_end_arg) + 1;
 		unsigned int scans_left = comedi_nscans_left(s, nscans);
+		unsigned int scan_pos =
+		    comedi_bytes_to_samples(s, async->scan_progress);
 		unsigned long long samples_left = 0;
 
 		if (scans_left) {
 			samples_left = ((unsigned long long)scans_left *
-				       cmd->scan_end_arg) - async->cur_chan;
+					cmd->scan_end_arg) - scan_pos;
 		}
 
 		if (samples_left < nsamples)

commit f615915ee5faf74d8912df1694e810c8269f6b3f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:31:33 2014 -0700

    staging: comedi: drivers: introduce comedi_nsamples_left()
    
    Introduce a helper function to calculate the number of samples remaining
    when the cmd->stop_src is TRIG_COUNT.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 00194a5092cf..82ac84504589 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -366,6 +366,38 @@ unsigned int comedi_nscans_left(struct comedi_subdevice *s,
 }
 EXPORT_SYMBOL_GPL(comedi_nscans_left);
 
+/**
+ * comedi_nsamples_left - return the number of samples left in the command
+ * @s: comedi_subdevice struct
+ * @nsamples: the expected number of samples
+ *
+ * Returns the expected number of samples of the number of samples remaining
+ * in the command.
+ */
+unsigned int comedi_nsamples_left(struct comedi_subdevice *s,
+				  unsigned int nsamples)
+{
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		/* +1 to force comedi_nscans_left() to return the scans left */
+		unsigned int nscans = (nsamples / cmd->scan_end_arg) + 1;
+		unsigned int scans_left = comedi_nscans_left(s, nscans);
+		unsigned long long samples_left = 0;
+
+		if (scans_left) {
+			samples_left = ((unsigned long long)scans_left *
+				       cmd->scan_end_arg) - async->cur_chan;
+		}
+
+		if (samples_left < nsamples)
+			nsamples = samples_left;
+	}
+	return nsamples;
+}
+EXPORT_SYMBOL_GPL(comedi_nsamples_left);
+
 /**
  * comedi_inc_scan_progress - update scan progress in asynchronous command
  * @s: comedi_subdevice struct

commit 2ee37750014220c5cc5f560e967432edb870c890
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:31:29 2014 -0700

    staging: comedi: drivers: introduce comedi_nscans_left()
    
    Introduce a helper function to determine the number of scans left in
    the async command.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 02a01baf5cc6..00194a5092cf 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -327,6 +327,45 @@ unsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)
 }
 EXPORT_SYMBOL_GPL(comedi_bytes_per_scan);
 
+/**
+ * comedi_nscans_left - return the number of scans left in the command
+ * @s: comedi_subdevice struct
+ * @nscans: the expected number of scans
+ *
+ * If nscans is 0, the number of scans available in the async buffer will be
+ * used. Otherwise the expected number of scans will be used.
+ *
+ * If the async command has a stop_src of TRIG_COUNT, the nscans will be
+ * checked against the number of scans left in the command.
+ *
+ * The return value will then be either the expected number of scans or the
+ * number of scans remaining in the command.
+ */
+unsigned int comedi_nscans_left(struct comedi_subdevice *s,
+				unsigned int nscans)
+{
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+
+	if (nscans == 0) {
+		unsigned int nbytes = comedi_buf_read_n_available(s);
+
+		nscans = nbytes / comedi_bytes_per_scan(s);
+	}
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		unsigned int scans_left = 0;
+
+		if (async->scans_done < cmd->stop_arg)
+			scans_left = cmd->stop_arg - async->scans_done;
+
+		if (nscans > scans_left)
+			nscans = scans_left;
+	}
+	return nscans;
+}
+EXPORT_SYMBOL_GPL(comedi_nscans_left);
+
 /**
  * comedi_inc_scan_progress - update scan progress in asynchronous command
  * @s: comedi_subdevice struct

commit 1dacbe5b26268fd3eaa6dad41271d296b072f3df
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:20:52 2014 -0700

    staging: comedi: comedidev.h: add 'scans_done' member to comedi_async
    
    Introduce a new member to comedi_async to count the number of scans completed.
    This member is cleared by comedi_buf_reset() along with the other comedi_async
    members. It is incremented in comedi_inc_scan_progress() when the end of scan
    is detected.
    
    This member will be used to clean up the scan counting in the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 9a8c5fc8e8fe..02a01baf5cc6 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -352,6 +352,13 @@ void comedi_inc_scan_progress(struct comedi_subdevice *s,
 
 	async->scan_progress += num_bytes;
 	if (async->scan_progress >= scan_length) {
+		unsigned int nscans = async->scan_progress / scan_length;
+
+		if (async->scans_done < (UINT_MAX - nscans))
+			async->scans_done += nscans;
+		else
+			async->scans_done = UINT_MAX;
+
 		async->scan_progress %= scan_length;
 		async->events |= COMEDI_CB_EOS;
 	}

commit c39e050d21d107d26183be0f22b89eccccdbe61c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:28 2014 -0700

    staging: comedi: remove use of 'bytes_per_sample()'
    
    This inline helper function has been replaced with comedi_bytes_per_sample().
    The same commit (bf33eb4b4f57) introduced a couple other related helper
    functions a manipulate the sample size.
    
    Use the new helper functions to remove the use of 'bytes_per_sample()' and
    remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 9c55dc759af8..9a8c5fc8e8fe 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -316,14 +316,14 @@ unsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)
 	case COMEDI_SUBD_DI:
 	case COMEDI_SUBD_DO:
 	case COMEDI_SUBD_DIO:
-		bits_per_sample = 8 * bytes_per_sample(s);
+		bits_per_sample = 8 * comedi_bytes_per_sample(s);
 		num_samples = DIV_ROUND_UP(cmd->chanlist_len, bits_per_sample);
 		break;
 	default:
 		num_samples = cmd->chanlist_len;
 		break;
 	}
-	return num_samples * bytes_per_sample(s);
+	return comedi_samples_to_bytes(s, num_samples);
 }
 EXPORT_SYMBOL_GPL(comedi_bytes_per_scan);
 

commit f8736ca466e2014d6e8bad478fcc5e5cb0105af0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 09:49:31 2014 -0700

    staging: comedi: drivers: move comedi_async 'cur_chan' tracking into the core
    
    The commedi_async 'cur_chan' member is used to track the current position
    in the chanlist for a scan. Currently only a couple comedi drivers use
    this member.
    
    For aeshtetics, move the 'cur_chan' tracking into the core for non-SDF_PACKED
    subdevices. The 'cur_chan' will be updated after reading or writing samples
    to the async buffer by comedi_inc_scan_progress(). All non-SDF_PACKED subdevices
    will then automatiaclly track the 'cur_chan'.
    
    Some of the drivers use the 'cur_chan' to detect the end of scan event when
    counting scans. The COMEDI_CB_EOS event is automatically added by the core
    when the end of scan is detected. The drivers just need to check if the
    'cur_chan' is 0 to count the number of scans completed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index ff2df8587eca..9c55dc759af8 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -341,8 +341,15 @@ void comedi_inc_scan_progress(struct comedi_subdevice *s,
 			      unsigned int num_bytes)
 {
 	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int scan_length = comedi_bytes_per_scan(s);
 
+	/* track the 'cur_chan' for non-SDF_PACKED subdevices */
+	if (!(s->subdev_flags & SDF_PACKED)) {
+		async->cur_chan += comedi_bytes_to_samples(s, num_bytes);
+		async->cur_chan %= cmd->chanlist_len;
+	}
+
 	async->scan_progress += num_bytes;
 	if (async->scan_progress >= scan_length) {
 		async->scan_progress %= scan_length;

commit 781f933c151ee47e3cc1c8ef5491db23f1b61c9a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 13 09:56:08 2014 -0700

    staging: comedi: comedidev.h: clarify async->event error/cancel detection
    
    Introduce COMEDI_CB_ERROR_MASK and COMEDI_CB_CANCEL_MASK to clarify the
    async->events that indicate errors and cancel an async command.
    
    Use the new defines to tidy up and clarify the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 859b722188cc..ff2df8587eca 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -375,7 +375,7 @@ unsigned int comedi_handle_events(struct comedi_device *dev,
 	if (events == 0)
 		return events;
 
-	if (events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
+	if (events & COMEDI_CB_CANCEL_MASK)
 		s->cancel(dev, s);
 
 	comedi_event(dev, s);

commit 583bea6c40fa281a6735a717d1855f31f2c6b187
Author: Tapasweni Pathak <tapaswenipathak@gmail.com>
Date:   Wed Oct 8 22:55:45 2014 +0530

    staging: comedi: use DIV_ROUND_UP
    
    The kernel.h macro DIV_ROUND_UP performs the computation (((n) + (d) - 1) /
    (d)) but is perhaps more readable.
    
    Coccinelle script used :
    
    // <smpl>
    @haskernel@
    @@
    @depends on haskernel@
    expression n,d;
    @@
    (
    - (n + d - 1) / d
    + DIV_ROUND_UP(n,d)
    |
    - (n + (d - 1)) / d
    + DIV_ROUND_UP(n,d)
    )
    @depends on haskernel@
    expression n,d;
    @@
    - DIV_ROUND_UP((n),d)
    + DIV_ROUND_UP(n,d)
    @depends on haskernel@
    expression n,d;
    @@
    - DIV_ROUND_UP(n,(d))
    + DIV_ROUND_UP(n,d)
    // </smpl>
    
    Signed-off-by: Tapasweni Pathak <tapaswenipathak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 3e5bccbc9c39..859b722188cc 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -317,8 +317,7 @@ unsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)
 	case COMEDI_SUBD_DO:
 	case COMEDI_SUBD_DIO:
 		bits_per_sample = 8 * bytes_per_sample(s);
-		num_samples = (cmd->chanlist_len + bits_per_sample - 1) /
-				bits_per_sample;
+		num_samples = DIV_ROUND_UP(cmd->chanlist_len, bits_per_sample);
 		break;
 	default:
 		num_samples = cmd->chanlist_len;

commit b8d57655fdedd40c8ef234b13b4da05dd607dbb5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 15 13:46:06 2014 +0100

    staging: comedi: migrate copyrights from "comedi_fc.c"
    
    The "comedi_fc" module was originally written and copyrighted by Frank
    Mori Hess, but the functionality has been migrated into the core
    "comedi" module.  Move the copyright notices over to the affected .c
    files in the core comedi module.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 3c7d86597ae9..3e5bccbc9c39 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -4,6 +4,7 @@
 
     COMEDI - Linux Control and Measurement Device Interface
     Copyright (C) 1997-2000 David A. Schleef <ds@schleef.org>
+    Copyright (C) 2002 Frank Mori Hess <fmhess@users.sourceforge.net>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by

commit 5a7803592409dc3b6ea3bce53a7517114f748dc8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 15 13:46:01 2014 +0100

    staging: comedi: add comedi_handle_events()
    
    The "comedi_fc" module contains a few functions useful to Comedi
    drivers.  Their functionality is being migrated to the core "comedi"
    module and renamed to start with the prefix `comedi_`.  As part of this
    migration, move `cfc_handle_events()` into the core comedi module and
    rename it to `comedi_handle_events()`.  Change the external declaration
    of `cfc_handle_events()` into an inline function that calls
    `comedi_handle_events()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 691a2c40bb63..3c7d86597ae9 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -351,6 +351,39 @@ void comedi_inc_scan_progress(struct comedi_subdevice *s,
 }
 EXPORT_SYMBOL_GPL(comedi_inc_scan_progress);
 
+/**
+ * comedi_handle_events - handle events and possibly stop acquisition
+ * @dev: comedi_device struct
+ * @s: comedi_subdevice struct
+ *
+ * Handles outstanding asynchronous acquisition event flags associated
+ * with the subdevice.  Call the subdevice's "->cancel()" handler if the
+ * "end of acquisition", "error" or "overflow" event flags are set in order
+ * to stop the acquisition at the driver level.
+ *
+ * Calls comedi_event() to further process the event flags, which may mark
+ * the asynchronous command as no longer running, possibly terminated with
+ * an error, and may wake up tasks.
+ *
+ * Return a bit-mask of the handled events.
+ */
+unsigned int comedi_handle_events(struct comedi_device *dev,
+				  struct comedi_subdevice *s)
+{
+	unsigned int events = s->async->events;
+
+	if (events == 0)
+		return events;
+
+	if (events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
+		s->cancel(dev, s);
+
+	comedi_event(dev, s);
+
+	return events;
+}
+EXPORT_SYMBOL_GPL(comedi_handle_events);
+
 static int insn_rw_emulate_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)

commit 2b4e1f632478f43bda1b38e04e0d740980fff1f3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 15 13:45:59 2014 +0100

    staging: comedi: add comedi_inc_scan_progress()
    
    The "comedi_fc" module contains a few functions useful to Comedi
    drivers.  Their functionality is being migrated to the core "comedi"
    module and renamed to start with the prefix `comedi_`.  As part of this
    migration, move `cfc_inc_scan_progress()` into the core comedi module
    and rename it to `comedi_inc_scan_progress()`.  Change the external
    declaration of `cfc_inc_scan_progress()` into an inline function that
    calls `comedi_inc_scan_progress()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 891c092697c5..691a2c40bb63 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -327,6 +327,30 @@ unsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)
 }
 EXPORT_SYMBOL_GPL(comedi_bytes_per_scan);
 
+/**
+ * comedi_inc_scan_progress - update scan progress in asynchronous command
+ * @s: comedi_subdevice struct
+ * @num_bytes: amount of data in bytes to increment scan progress
+ *
+ * Increments the scan progress by the number of bytes specified by num_bytes.
+ * If the scan progress reaches or exceeds the scan length in bytes, reduce
+ * it modulo the scan length in bytes and set the "end of scan" asynchronous
+ * event flag to be processed later.
+ */
+void comedi_inc_scan_progress(struct comedi_subdevice *s,
+			      unsigned int num_bytes)
+{
+	struct comedi_async *async = s->async;
+	unsigned int scan_length = comedi_bytes_per_scan(s);
+
+	async->scan_progress += num_bytes;
+	if (async->scan_progress >= scan_length) {
+		async->scan_progress %= scan_length;
+		async->events |= COMEDI_CB_EOS;
+	}
+}
+EXPORT_SYMBOL_GPL(comedi_inc_scan_progress);
+
 static int insn_rw_emulate_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)

commit f146fe63416de7162090a48135d33a2b74a4efcc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 15 13:45:57 2014 +0100

    staging: comedi: add comedi_bytes_per_scan()
    
    The "comedi_fc" module contains a few functions useful to Comedi
    drivers.  Their functionality is being migrated to the core "comedi"
    module and renamed to start with the prefix `comedi_`.  As part of this
    migration, move `cfc_bytes_per_scan()` into the core comedi module and
    rename it to `comedi_bytes_per_scan()`.  Change the external declaration
    of `cfc_bytes_per_scan()` into an inline function that calls
    `comedi_bytes_per_scan()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index c4ed8fd68688..891c092697c5 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -290,6 +290,43 @@ unsigned int comedi_dio_update_state(struct comedi_subdevice *s,
 }
 EXPORT_SYMBOL_GPL(comedi_dio_update_state);
 
+/**
+ * comedi_bytes_per_scan - get length of asynchronous command "scan" in bytes
+ * @s: comedi_subdevice struct
+ *
+ * Determines the overall scan length according to the subdevice type and the
+ * number of channels in the scan.
+ *
+ * For digital input, output or input/output subdevices, samples for multiple
+ * channels are assumed to be packed into one or more unsigned short or
+ * unsigned int values according to the subdevice's SDF_LSAMPL flag.  For other
+ * types of subdevice, samples are assumed to occupy a whole unsigned short or
+ * unsigned int according to the SDF_LSAMPL flag.
+ *
+ * Returns the overall scan length in bytes.
+ */
+unsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)
+{
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int num_samples;
+	unsigned int bits_per_sample;
+
+	switch (s->type) {
+	case COMEDI_SUBD_DI:
+	case COMEDI_SUBD_DO:
+	case COMEDI_SUBD_DIO:
+		bits_per_sample = 8 * bytes_per_sample(s);
+		num_samples = (cmd->chanlist_len + bits_per_sample - 1) /
+				bits_per_sample;
+		break;
+	default:
+		num_samples = cmd->chanlist_len;
+		break;
+	}
+	return num_samples * bytes_per_sample(s);
+}
+EXPORT_SYMBOL_GPL(comedi_bytes_per_scan);
+
 static int insn_rw_emulate_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)

commit d27620669209e3cc87f13449326eeb68229e4bd0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:03:54 2014 -0700

    staging: comedi: add a 'readback' member to comedi_subdevice
    
    The analog output hardware in most comedi drivers does not provide a
    way to readback to last values written to the channels. In order to
    provide an (*insn_read) for the analog output subdevice, the comedi
    drivers save the last values for each channel in the private data.
    
    Add a new member, 'readback', to the comedi_subdevice definition to
    provide a common way to save these values.
    
    Introduce a comedi core function, comedi_alloc_subdev_readback(), to
    allocate the memory needed to save the values. This memory will be
    automatically kfree'd when the driver is detached.
    
    Introduce a comedi core function, comedi_readback_insn_read(), that
    the comedi drivers can use for the (*insn_read) of a subdevice to
    return the saved values for each channel.
    
    This will allow removing the boilerplate in the comedi drivers to
    return the saved values. In some drivers it will also allow removing
    the private data completely.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 9ada130f2a76..c4ed8fd68688 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -96,6 +96,22 @@ int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 }
 EXPORT_SYMBOL_GPL(comedi_alloc_subdevices);
 
+/**
+ * comedi_alloc_subdev_readback() - Allocate memory for the subdevice readback.
+ * @s: comedi_subdevice struct
+ */
+int comedi_alloc_subdev_readback(struct comedi_subdevice *s)
+{
+	if (!s->n_chan)
+		return -EINVAL;
+
+	s->readback = kcalloc(s->n_chan, sizeof(*s->readback), GFP_KERNEL);
+	if (!s->readback)
+		return -ENOMEM;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(comedi_alloc_subdev_readback);
+
 static void comedi_device_detach_cleanup(struct comedi_device *dev)
 {
 	int i;
@@ -111,6 +127,7 @@ static void comedi_device_detach_cleanup(struct comedi_device *dev)
 				comedi_buf_alloc(dev, s, 0);
 				kfree(s->async);
 			}
+			kfree(s->readback);
 		}
 		kfree(dev->subdevices);
 		dev->subdevices = NULL;
@@ -156,6 +173,31 @@ int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
 	return -EINVAL;
 }
 
+/**
+ * comedi_readback_insn_read() - A generic (*insn_read) for subdevice readback.
+ * @dev: comedi_device struct
+ * @s: comedi_subdevice struct
+ * @insn: comedi_insn struct
+ * @data: pointer to return the readback data
+ */
+int comedi_readback_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
+{
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int i;
+
+	if (!s->readback)
+		return -EINVAL;
+
+	for (i = 0; i < insn->n; i++)
+		data[i] = s->readback[chan];
+
+	return insn->n;
+}
+EXPORT_SYMBOL_GPL(comedi_readback_insn_read);
+
 /**
  * comedi_timeout() - busy-wait for a driver condition to occur.
  * @dev: comedi_device struct

commit d7e6dc1338eebae3b324b9a99e9d03d80c43aaef
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jul 29 15:01:20 2014 -0700

    staging: comedi: add an 'mmio' member to comedi_device
    
    All the comedi drivers that use memory mapped io currently have a
    void __iomem * member in their private data for the driver. For
    some of the drivers this is actually the only member in that data.
    
    For convienence, add a new member to the comedi_device for this
    void __iomem *.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 42ddf1332ce8..9ada130f2a76 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -121,6 +121,7 @@ static void comedi_device_detach_cleanup(struct comedi_device *dev)
 	dev->driver = NULL;
 	dev->board_name = NULL;
 	dev->board_ptr = NULL;
+	dev->mmio = NULL;
 	dev->iobase = 0;
 	dev->iolen = 0;
 	dev->ioenabled = false;

commit d546b8966e66b114809d4af14e2d837adeeec2fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 21 11:48:32 2014 -0700

    staging: comedi: comedidev.h: remove 'new_size' param from subdevice (*buf_change)
    
    This parameter is never used by any of the comedi drivers that provide a
    (*buf_change) callback. If the 'new_size' is needed in the callback it can
    be found from the 's->async->prealloc_bufsz' as done in the ni_pcidio driver.
    
    Remove the unused parameter.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 6ec4a4176e73..42ddf1332ce8 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -320,7 +320,7 @@ static int __comedi_device_postconfig_async(struct comedi_device *dev,
 		return -ENOMEM;
 	}
 	if (s->buf_change) {
-		ret = s->buf_change(dev, s, buf_size);
+		ret = s->buf_change(dev, s);
 		if (ret < 0)
 			return ret;
 	}

commit 3df9f21af9d52fd4fd85e874ebba5e9cc4905e7d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 14:28:11 2014 -0700

    staging: comedi: drivers.c: checkpatch.pl --strict cleanup
    
    Fix the checkpatch.pl --strict issues:
    
    CHECK: DEFINE_MUTEX definition without comment
    CHECK: braces {} should be used on all arms of this statement
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 9bfd05b361ea..6ec4a4176e73 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -38,6 +38,7 @@
 #include "comedi_internal.h"
 
 struct comedi_driver *comedi_drivers;
+/* protects access to comedi_drivers */
 DEFINE_MUTEX(comedi_drivers_list_lock);
 
 int comedi_set_hw_dev(struct comedi_device *dev, struct device *hw_dev)
@@ -566,8 +567,9 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			dev->board_ptr = comedi_recognize(driv, it->board_name);
 			if (dev->board_ptr)
 				break;
-		} else if (strcmp(driv->driver_name, it->board_name) == 0)
+		} else if (strcmp(driv->driver_name, it->board_name) == 0) {
 			break;
+		}
 		module_put(driv->module);
 	}
 	if (driv == NULL) {

commit 6b362f5bea0dfbb648656041a92f6a00b298f558
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:56 2014 -0700

    staging: comedi: remove comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character.
    
    All of the users of this function have been converted to use dev_err()
    directly. Remove the now unused function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 299726f39e26..9bfd05b361ea 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -591,8 +591,6 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		ret = -ENOSYS;
 		goto out;
 	}
-	/* initialize dev->driver here so
-	 * comedi_error() can be called from attach */
 	dev->driver = driv;
 	dev->board_name = dev->board_ptr ? *(const char **)dev->board_ptr
 					 : dev->driver->driver_name;

commit 2891911a32e81942cefb1bbc1398f39e9fe76db5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:18 2014 +0100

    staging: comedi: remove subdevice member of struct comedi_async
    
    The `async` member of `struct comedi_subdevice` may point to a `struct
    comedi_async` or may be NULL.  The `subdevice` member of `struct
    comedi_async` points back to the `struct comedi_subdevice` associated
    with it in a one-to-one relationship.
    
    All uses of the `subdevice` member of `struct comedi_async` apart from
    its initialization have now been removed (by passing around a pointer to
    the subdevice instead of to the "async" structure), so get rid of it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index cb5d21411a0c..299726f39e26 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -307,7 +307,6 @@ static int __comedi_device_postconfig_async(struct comedi_device *dev,
 		return -ENOMEM;
 
 	init_waitqueue_head(&async->wait_head);
-	async->subdevice = s;
 	s->async = async;
 
 	async->max_bufsize = comedi_default_buf_maxsize_kb * 1024;

commit 1e4742df19bee14669e72ee3da670c3b6b33cd5e
Author: Yves Deweerdt <yves.deweerdt.linux@gmail.com>
Date:   Mon Mar 31 22:55:44 2014 +0200

    staging: comedi: drivers.c: Fix missing a blank line, after declarations warning
    
    Signed-off-by: Yves Deweerdt <yves.deweerdt.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index ab0e8ed47291..cb5d21411a0c 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -258,6 +258,7 @@ static int insn_rw_emulate_bits(struct comedi_device *dev,
 	const unsigned base_bitfield_channel =
 	    (chan < channels_per_bitfield) ? 0 : chan;
 	unsigned int new_data[2];
+
 	memset(new_data, 0, sizeof(new_data));
 	memset(&new_insn, 0, sizeof(new_insn));
 	new_insn.insn = INSN_BITS;

commit 915064086e0189ed2aa69fddf14718aabbb541cb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:00 2014 -0700

    staging: comedi: introduce comedi_timeout()
    
    Introduce a comedi core helper function to handle the boilerplate
    needed by the drivers to busy- wait for a condition to occur.
    Typically this condition is the analog input/output end-of-conversion
    used with the comedi (*insn_read) and (*insn_write) operations.
    
    To use this function, the drivers just need to provide a callback
    that checks for the desired condition. The callback should return
    0 if the condition is met or -EBUSY if it is still waiting. Any
    other errno will be returned to the caller. If the timeout occurs
    before the condition is met -ETIMEDOUT will be returned.
    
    The parameters to the callback function are the comedi_device,
    comedi_subdevice, and comedi_insn pointers that were passed to the
    (*insn_read) or (*insn_write) as well as an unsigned long, driver
    specific, 'context' that can be used to pass any other information
    that might be needed in the callback. This 'context' could be anything
    such as the register offset to read the status or the bits needed
    to check the status. The comedi_timeout() function itself does not
    use any of these parameters.
    
    This will help remove all the crazy "wait this many loops" used by
    some of the drivers. It also creates a common errno for comedi to
    detect when a timeout occurs.
    
    ADC/DAC conversion times are typically pretty fast, usually around
    100K samples/sec (10 usec). A conservative timeout of 1 second is used
    in comedi_timeout().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 5b15033a94bf..ab0e8ed47291 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -154,6 +154,36 @@ int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
 	return -EINVAL;
 }
 
+/**
+ * comedi_timeout() - busy-wait for a driver condition to occur.
+ * @dev: comedi_device struct
+ * @s: comedi_subdevice struct
+ * @insn: comedi_insn struct
+ * @cb: callback to check for the condition
+ * @context: private context from the driver
+ */
+int comedi_timeout(struct comedi_device *dev,
+		   struct comedi_subdevice *s,
+		   struct comedi_insn *insn,
+		   int (*cb)(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn,
+			     unsigned long context),
+		   unsigned long context)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(COMEDI_TIMEOUT_MS);
+	int ret;
+
+	while (time_before(jiffies, timeout)) {
+		ret = cb(dev, s, insn, context);
+		if (ret != -EBUSY)
+			return ret;	/* success (0) or non EBUSY errno */
+		cpu_relax();
+	}
+	return -ETIMEDOUT;
+}
+EXPORT_SYMBOL_GPL(comedi_timeout);
+
 /**
  * comedi_dio_insn_config() - boilerplate (*insn_config) for DIO subdevices.
  * @dev: comedi_device struct

commit f1ffdfcc52744ed264041741020364cfbad9c0de
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jan 21 17:06:34 2014 +0000

    staging: comedi: fix too early cleanup in comedi_auto_config()
    
    `comedi_auto_config()` is usually called from the probe routine of a
    low-level comedi driver to allocate and auto-configure a comedi device.
    Part of this involves calling the low-level driver's `auto_attach()`
    handler, and if that is successful, `comedi_device_postconfig()` tries
    to complete the configuration of the comedi device.  If either of those
    fail, `comedi_device_detach()` is called to clean up, and
    `comedi_release_hardware_device()` is called to remove the dynamically
    allocated comedi device.
    
    Unfortunately, `comedi_device_detach()` clears the `hw_dev` member of
    the `struct comedi_device` (indirectly via `comedi_clear_hw_dev()`), and
    that stops `comedi_release_hardware_device()` finding the comedi device
    associated with the hardware device, so the comedi device won't be
    removed properly.
    
    Since `comedi_release_hardware_device()` also calls
    `comedi_device_detach()` (assuming it finds the comedi device associated
    with the hardware device), the fix is to remove the direct call to
    `comedi_device_detach()` from `comedi_auto_config()` and let the call to
    `comedi_release_hardware_device()` take care of it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 246080316c90..5b15033a94bf 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -616,8 +616,6 @@ int comedi_auto_config(struct device *hardware_device,
 	ret = driver->auto_attach(dev, context);
 	if (ret >= 0)
 		ret = comedi_device_postconfig(dev);
-	if (ret < 0)
-		comedi_device_detach(dev);
 	mutex_unlock(&dev->mutex);
 
 	if (ret < 0) {

commit bcb6232d090c82e41d6bce9474e031bfd948fcdb
Author: Bernd Porr <mail@berndporr.me.uk>
Date:   Tue Jan 7 21:42:25 2014 +0000

    staging: comedi: report success/failure of autoconfig
    
    Added success message to the driver autoconfig and error
    message in case it fails. A success message is required
    so that the user can find out which comedi driver has been
    associated with which udev device. This also makes troubleshooting
    much easier when more than one card is in the computer or
    there is a mix of USB and PCI devices.
    As Ian suggested we should report both the driver and the board
    which might have different names, especially if one driver covers a
    range of different boards.
    
    Signed-off-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 9d71b4d8540b..246080316c90 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -603,8 +603,12 @@ int comedi_auto_config(struct device *hardware_device,
 	}
 
 	dev = comedi_alloc_board_minor(hardware_device);
-	if (IS_ERR(dev))
+	if (IS_ERR(dev)) {
+		dev_warn(hardware_device,
+			 "driver '%s' could not create device.\n",
+			 driver->driver_name);
 		return PTR_ERR(dev);
+	}
 	/* Note: comedi_alloc_board_minor() locked dev->mutex. */
 
 	dev->driver = driver;
@@ -616,8 +620,20 @@ int comedi_auto_config(struct device *hardware_device,
 		comedi_device_detach(dev);
 	mutex_unlock(&dev->mutex);
 
-	if (ret < 0)
+	if (ret < 0) {
+		dev_warn(hardware_device,
+			 "driver '%s' failed to auto-configure device.\n",
+			 driver->driver_name);
 		comedi_release_hardware_device(hardware_device);
+	} else {
+		/*
+		 * class_dev should be set properly here
+		 *  after a successful auto config
+		 */
+		dev_info(dev->class_dev,
+			 "driver '%s' has successfully auto-configured '%s'.\n",
+			 driver->driver_name, dev->board_name);
+	}
 	return ret;
 }
 EXPORT_SYMBOL_GPL(comedi_auto_config);

commit 912cbd495204ee6fcb67b8704ffbda10615d1f2f
Merge: 1785faacf3ac 413541dd66d5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Dec 24 10:06:37 2013 -0800

    Merge 3.13-rc5 into staging-next
    
    This resolves a merge issue with drivers/staging/imx-drm/imx-drm-core.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c6236c0ce39c809c336ca929f68cf8ad02cf94e0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 10 16:31:25 2013 -0700

    staging: comedi: drivers: fix return value of comedi_load_firmware()
    
    Some of the callback functions that upload the firmware in the comedi
    drivers return a positive value indicating the number of bytes sent
    to the device. Detect this condition and just return '0' to indicate
    a successful upload.
    
    Reported-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Ian Abbott <abbotti@mev.co.uk>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 8f02bf66e20b..4964d2a2fc7d 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -446,7 +446,7 @@ int comedi_load_firmware(struct comedi_device *dev,
 		release_firmware(fw);
 	}
 
-	return ret;
+	return ret < 0 ? ret : 0;
 }
 EXPORT_SYMBOL_GPL(comedi_load_firmware);
 

commit a200fadca97abb337dcc28e737c1a2e11f56b714
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:35 2013 +0000

    staging: comedi: use refcount in comedi_driver_unregister()
    
    Change `comedi_driver_unregister()` to call
    `comedi_dev_get_from_minor()` instead of `comedi_dev_from_minor()` when
    finding devices using the driver.  This increments the reference count
    to prevent the device being removed while it is being checked to see if
    it is attached to the driver.  Call `comedi_dev_put()` to decrement the
    reference afterwards.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 15b1ab885e77..a5d03b9c3717 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -662,7 +662,7 @@ void comedi_driver_unregister(struct comedi_driver *driver)
 
 	/* check for devices using this driver */
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
-		struct comedi_device *dev = comedi_dev_from_minor(i);
+		struct comedi_device *dev = comedi_dev_get_from_minor(i);
 
 		if (!dev)
 			continue;
@@ -676,6 +676,7 @@ void comedi_driver_unregister(struct comedi_driver *driver)
 			comedi_device_detach(dev);
 		}
 		mutex_unlock(&dev->mutex);
+		comedi_dev_put(dev);
 	}
 }
 EXPORT_SYMBOL_GPL(comedi_driver_unregister);

commit ef77c0b2570623f1d72527cb1c6c3f3d3c59793e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:29 2013 +0000

    staging: comedi: add detachment counter for validity checks
    
    Add a member `detach_count` to `struct comedi_device` that is
    incremented every time the device gets detached.  This will be used in
    some validity checks in the 'read' and 'write' file operations to make
    sure the attachment remains valid.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 4f727731a72d..15b1ab885e77 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -136,6 +136,7 @@ void comedi_device_detach(struct comedi_device *dev)
 	comedi_device_cancel_all(dev);
 	down_write(&dev->attach_lock);
 	dev->attached = false;
+	dev->detach_count++;
 	if (dev->driver)
 		dev->driver->detach(dev);
 	comedi_device_detach_cleanup(dev);

commit d19db51a0eeb659cd924a9d08b20a2ed4ee46b15
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:28 2013 +0000

    staging: comedi: cancel commands before detaching device
    
    The comedi core module's handling of the `COMEDI_DEVCONFIG` ioctl will
    not allow a device to be detached if it is busy.  However, comedi
    devices can also be auto-detached due to a removal of a hardware device.
    One of the things we should do in that case is cancel any asynchronous
    commands that are running.  Add a new function
    `comedi_device_cancel_all()` to do that and call it from
    `comedi_device_detach()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 1f44f2939f6a..4f727731a72d 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -133,6 +133,7 @@ static void comedi_device_detach_cleanup(struct comedi_device *dev)
 
 void comedi_device_detach(struct comedi_device *dev)
 {
+	comedi_device_cancel_all(dev);
 	down_write(&dev->attach_lock);
 	dev->attached = false;
 	if (dev->driver)

commit 3867e20db4823c733710f11b65606a9ed7d297c2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:26 2013 +0000

    staging: comedi: cleanup_device() -> comedi_device_detach_cleanup()
    
    Rename the local function `cleanup_device()` to
    `comedi_device_detach_cleanup()`.  It is only called from the
    `comedi_device_detach()` function and that is called from
    `comedi_device_cleanup()` and other places.  The more specific function
    name seems less confusing.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index c398422e073d..1f44f2939f6a 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -95,7 +95,7 @@ int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 }
 EXPORT_SYMBOL_GPL(comedi_alloc_subdevices);
 
-static void cleanup_device(struct comedi_device *dev)
+static void comedi_device_detach_cleanup(struct comedi_device *dev)
 {
 	int i;
 	struct comedi_subdevice *s;
@@ -137,7 +137,7 @@ void comedi_device_detach(struct comedi_device *dev)
 	dev->attached = false;
 	if (dev->driver)
 		dev->driver->detach(dev);
-	cleanup_device(dev);
+	comedi_device_detach_cleanup(dev);
 	up_write(&dev->attach_lock);
 }
 

commit bf11c134246e8f3cfa2582a3d2af84ed7dfd59b6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 8 15:03:25 2013 +0000

    staging: comedi: use attach_lock semaphore during attach and detach
    
    Acquire the `attach_lock` semaphore in the `struct comedi_device` while
    modifying the `attached` flag.  This is a "write" acquire.  Note that
    the main mutex in the `struct comedi_device` is also held at this time.
    Tasks wishing to check the device is attached will need to either
    acquire the main mutex, or "read" acquire the `attach_lock` semaphore,
    or both in that order.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 8f02bf66e20b..c398422e073d 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -133,10 +133,12 @@ static void cleanup_device(struct comedi_device *dev)
 
 void comedi_device_detach(struct comedi_device *dev)
 {
+	down_write(&dev->attach_lock);
 	dev->attached = false;
 	if (dev->driver)
 		dev->driver->detach(dev);
 	cleanup_device(dev);
+	up_write(&dev->attach_lock);
 }
 
 static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -355,8 +357,9 @@ static int comedi_device_postconfig(struct comedi_device *dev)
 	ret = __comedi_device_postconfig(dev);
 	if (ret < 0)
 		return ret;
-	smp_wmb();
+	down_write(&dev->attach_lock);
 	dev->attached = true;
+	up_write(&dev->attach_lock);
 	return 0;
 }
 

commit 05e60b13a36bf4b6bd4d724b2332d6c3a4023998
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:04:56 2013 -0700

    staging: comedi: drivers: introduce comedi_dio_update_state()
    
    The (*insn_bits) functions for DIO and DO subdevices typically use
    the subdevice 's->state' to hold the current state of the output
    channels. The 'insn' passed to these functions, INSN_BITS, specifies
    two parameters passed in the 'data'.
    
      data[0] = 'mask', the channels to update
      data[1] = 'bits', the new state for the channels
    
    Introduce a helper function to handle the boilerplate used to
    update the internal state.
    
    Note that the 'mask' is filtered by the 'chanmask' of the channels
    actually supported by the subdevice. This is used to protect any
    non-channel related bits that are stored in the subdevice state.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index aeef59492ba2..8f02bf66e20b 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -190,6 +190,28 @@ int comedi_dio_insn_config(struct comedi_device *dev,
 }
 EXPORT_SYMBOL_GPL(comedi_dio_insn_config);
 
+/**
+ * comedi_dio_update_state() - update the internal state of DIO subdevices.
+ * @s: comedi_subdevice struct
+ * @data: the channel mask and bits to update
+ */
+unsigned int comedi_dio_update_state(struct comedi_subdevice *s,
+				     unsigned int *data)
+{
+	unsigned int chanmask = (s->n_chan < 32) ? ((1 << s->n_chan) - 1)
+						 : 0xffffffff;
+	unsigned int mask = data[0] & chanmask;
+	unsigned int bits = data[1];
+
+	if (mask) {
+		s->state &= ~mask;
+		s->state |= (bits & mask);
+	}
+
+	return mask;
+}
+EXPORT_SYMBOL_GPL(comedi_dio_update_state);
+
 static int insn_rw_emulate_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)

commit 09567cb4373e962a3079bb06352e1e5452d9a340
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 10:47:03 2013 -0700

    staging: comedi: initialize subdevice s->io_bits in postconfig
    
    The subdevice 'io_bits' is a bit mask of the i/o configuration for
    digital subdevices. '0' values indicate that a channel is configured
    as an input and '1' values that the channel is an output. Since the
    subdevice data is kzalloc()'d, all channels default as inputs.
    
    Modify __comedi_device_postconfig() so that 'io_bits' is correctly
    initialized for Digital Output subdevices.
    
    Remove all the unnecessary initializations of 's->io_bits' from the
    drivers. Also, remove the unnecessary initialization of the 's->state'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 317a821b7906..aeef59492ba2 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -285,6 +285,13 @@ static int __comedi_device_postconfig(struct comedi_device *dev)
 		if (s->type == COMEDI_SUBD_UNUSED)
 			continue;
 
+		if (s->type == COMEDI_SUBD_DO) {
+			if (s->n_chan < 32)
+				s->io_bits = (1 << s->n_chan) - 1;
+			else
+				s->io_bits = 0xffffffff;
+		}
+
 		if (s->len_chanlist == 0)
 			s->len_chanlist = 1;
 

commit 751144271f4b63d5de9005ea4e5e6e5c7c6fd629
Merge: 542a086ac72f 91121c103ae9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 3 11:37:57 2013 -0700

    Merge tag 'staging-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging tree merge from Greg KH:
     "Here's the bit staging tree pull request for 3.12-rc1.
    
      Lots of staging driver updates, and fixes.  Lustre is finally enabled
      in the build, and lots of cleanup started happening in it.  There's a
      new wireless driver in here, and 2 new TTY drivers, which cause the
      overall lines added/removed to be quite large on the "added" side.
    
      The IIO driver updates are also coming through here, as they are tied
      to the staging iio drivers"
    
    * tag 'staging-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (942 commits)
      staging: dwc2: make dwc2_core_params documentation more complete
      staging: dwc2: validate the value for phy_utmi_width
      staging: dwc2: interpret all hwcfg and related register at init time
      staging: dwc2: properly mask the GRXFSIZ register
      staging: dwc2: remove redundant register reads
      staging: dwc2: re-use hptxfsiz variable
      staging: dwc2: simplify debug output in dwc_hc_init
      staging: dwc2: add missing shift
      staging: dwc2: simplify register shift expressions
      staging: dwc2: only read the snpsid register once
      staging: dwc2: unshift non-bool register value constants
      staging: dwc2: fix off-by-one in check for max_packet_count parameter
      staging: dwc2: remove specific fifo size constants
      Staging:BCM:DDRInit.c:Renaming __FUNCTION__
      staging: bcm: remove Version.h file.
      staging: rtl8188eu: off by one in rtw_set_802_11_add_wep()
      staging: r8188eu: copying one byte too much
      staging: rtl8188eu: || vs && typo
      staging: r8188eu: off by one bugs
      staging: crystalhd: Resolve sparse 'different base types' warnings.
      ...

commit 3955dfa8216f712bc204a5ad2f4e51efff252fde
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Aug 23 12:37:17 2013 +0100

    staging: comedi: bug-fix NULL pointer dereference on failed attach
    
    Commit dcd7b8bd63cb81c5b973bf86510ca3c80bbbd162 ("staging: comedi: put
    module _after_ detach" by myself) reversed a couple of calls in
    `comedi_device_attach()` when recovering from an error returned by the
    low-level driver's 'attach' handler.  Unfortunately, that introduced a
    NULL pointer dereference bug as `dev->driver` is NULL after the call to
    `comedi_device_detach()`.   We still have a pointer to the low-level
    comedi driver structure in the `driv` variable, so use that instead.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: <stable@vger.kernel.org> # 3.10+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index e25eba5713c1..b3b5125faa72 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -482,7 +482,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		ret = comedi_device_postconfig(dev);
 	if (ret < 0) {
 		comedi_device_detach(dev);
-		module_put(dev->driver->module);
+		module_put(driv->module);
 	}
 	/* On success, the driver module count has been incremented. */
 	return ret;

commit e523c6c86232eb5564662aa17199c676d127bc5e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 6 09:31:35 2013 -0700

    staging: comedi: drivers: introduce comedi_dio_insn_config()
    
    DIO subdevices always handle the INSN_CONFIG_DIO_{INPUT,OUTPUT} instructions
    to configure the DIO channels. They also always handle the INSN_CONFIG_DIO_QUERY
    instruction to query the configuration of a DIO channel.
    
    Introduce a helper function to handle the (*insn_config) boilerplate for
    comedi DIO subdevices. This function has the same paramters as (*insn_config)
    functions with an additional parameter to allow the caller to pass a 'mask'
    value for grouped DIO channels.
    
    This function returns:
    
      0 if the instruction was successful but requires additional handling by
      the caller (INSN_CONFIG_DIO_{INPUT,OUTPUT}
    
      insn->n if the instruction was handled (INSN_CONFIG_DIO_QUERY)
    
      -EINVAL for all unhandled instructions
    
    The caller is responsible for actually configuring the hardware based on
    the configuration (s->io_bits).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 791a26bd5f63..60fd81c71a12 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -150,6 +150,46 @@ int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
 	return -EINVAL;
 }
 
+/**
+ * comedi_dio_insn_config() - boilerplate (*insn_config) for DIO subdevices.
+ * @dev: comedi_device struct
+ * @s: comedi_subdevice struct
+ * @insn: comedi_insn struct
+ * @data: parameters for the @insn
+ * @mask: io_bits mask for grouped channels
+ */
+int comedi_dio_insn_config(struct comedi_device *dev,
+			   struct comedi_subdevice *s,
+			   struct comedi_insn *insn,
+			   unsigned int *data,
+			   unsigned int mask)
+{
+	unsigned int chan_mask = 1 << CR_CHAN(insn->chanspec);
+
+	if (!mask)
+		mask = chan_mask;
+
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_INPUT:
+		s->io_bits &= ~mask;
+		break;
+
+	case INSN_CONFIG_DIO_OUTPUT:
+		s->io_bits |= mask;
+		break;
+
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		return insn->n;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(comedi_dio_insn_config);
+
 static int insn_rw_emulate_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)

commit 99ac7cccb50fcbacdc21620a898e6d64b58a2282
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 12 15:16:24 2013 -0700

    Revert "staging: comedi: core: introduce comedi_dio_insn_config()"
    
    This reverts commit 4f76463d3b8f8cc0cac5bb292ec766848f3f4fa1.
    
    I applied an incorrect version here as well :(
    
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 60fd81c71a12..791a26bd5f63 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -150,46 +150,6 @@ int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
 	return -EINVAL;
 }
 
-/**
- * comedi_dio_insn_config() - boilerplate (*insn_config) for DIO subdevices.
- * @dev: comedi_device struct
- * @s: comedi_subdevice struct
- * @insn: comedi_insn struct
- * @data: parameters for the @insn
- * @mask: io_bits mask for grouped channels
- */
-int comedi_dio_insn_config(struct comedi_device *dev,
-			   struct comedi_subdevice *s,
-			   struct comedi_insn *insn,
-			   unsigned int *data,
-			   unsigned int mask)
-{
-	unsigned int chan_mask = 1 << CR_CHAN(insn->chanspec);
-
-	if (!mask)
-		mask = chan_mask;
-
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_INPUT:
-		s->io_bits &= ~mask;
-		break;
-
-	case INSN_CONFIG_DIO_OUTPUT:
-		s->io_bits |= mask;
-		break;
-
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
-		return insn->n;
-
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(comedi_dio_insn_config);
-
 static int insn_rw_emulate_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)

commit 4f76463d3b8f8cc0cac5bb292ec766848f3f4fa1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 5 15:00:05 2013 -0700

    staging: comedi: core: introduce comedi_dio_insn_config()
    
    DIO subdevices always handle the INSN_CONFIG_DIO_{INPUT,OUTPUT} instructions
    to configure the dio channels. They also always handle the INSN_CONFIG_DIO_QUERY
    instruction to query the configuration of a dio channel.
    
    Introduce a helper function to handle the (*insn_config) boilerplate for
    comedi DIO subdevices. This function has the same parameters as (*insn_config)
    functions with an additional parameter to allow the caller to pass a 'mask'
    value for grouped dio channels.
    
    This function returns:
    
      0 if the instruction was successful but requires additional handling by
      the caller (INSN_CONFIG_DIO_{INPUT,OUTPUT}
    
      insn->n if the instruction was handled (INSN_CONFIG_DIO_QUERY)
    
      -EINVAL for all unhandled instructions
    
    The caller is responsible for actually configuring the hardware based on
    the configuration (s->io_bits).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 791a26bd5f63..60fd81c71a12 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -150,6 +150,46 @@ int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
 	return -EINVAL;
 }
 
+/**
+ * comedi_dio_insn_config() - boilerplate (*insn_config) for DIO subdevices.
+ * @dev: comedi_device struct
+ * @s: comedi_subdevice struct
+ * @insn: comedi_insn struct
+ * @data: parameters for the @insn
+ * @mask: io_bits mask for grouped channels
+ */
+int comedi_dio_insn_config(struct comedi_device *dev,
+			   struct comedi_subdevice *s,
+			   struct comedi_insn *insn,
+			   unsigned int *data,
+			   unsigned int mask)
+{
+	unsigned int chan_mask = 1 << CR_CHAN(insn->chanspec);
+
+	if (!mask)
+		mask = chan_mask;
+
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_INPUT:
+		s->io_bits &= ~mask;
+		break;
+
+	case INSN_CONFIG_DIO_OUTPUT:
+		s->io_bits |= mask;
+		break;
+
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		return insn->n;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(comedi_dio_insn_config);
+
 static int insn_rw_emulate_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)

commit c383e2d6dacf0b6fdd40fbaf044e235cac54a20f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jun 27 14:50:58 2013 +0100

    staging: comedi: use a mutex when accessing driver list
    
    Low-level comedi drivers registered with the comedi core by
    `comedi_driver_register()` are linked together into a simple linked list
    headed by the `comedi_drivers` variable and chained by the `next` member
    of `struct comedi_driver`.  A driver is removed from the list by
    `comedi_driver_unregister()`.  The driver list is iterated through by
    `comedi_device_attach()` when the `COMEDI_DEVCONFIG` ioctl is used to
    attach a "legacy" device to a driver, and is also iterated through by
    `comedi_read()` in "proc.c" when reading "/proc/comedi".
    
    There is currently no protection against items being added or removed
    from the list while it is being iterated.  Add a mutex
    `comedi_drivers_list_lock` to be locked while adding or removing an item
    on the list, or when iterating through the list.
    
    `comedi_driver_unregister()` also checks for and detaches any devices
    using the driver.  This is currently done before unlinking the driver
    from the list, but it makes more sense to unlink the driver from the
    list first to prevent `comedi_device_attach()` attempting to use it, so
    move the unlinking part to the start of the function.  Also, in
    `comedi_device_attach()` hold on to the mutex until we've finished
    attempting to attach the device to avoid it interfering with the
    detachment in `comedi_driver_unregister()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index ba5d6d927a49..791a26bd5f63 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -38,6 +38,7 @@
 #include "comedi_internal.h"
 
 struct comedi_driver *comedi_drivers;
+DEFINE_MUTEX(comedi_drivers_list_lock);
 
 int comedi_set_hw_dev(struct comedi_device *dev, struct device *hw_dev)
 {
@@ -453,6 +454,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (dev->attached)
 		return -EBUSY;
 
+	mutex_lock(&comedi_drivers_list_lock);
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module))
 			continue;
@@ -473,7 +475,8 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			comedi_report_boards(driv);
 			module_put(driv->module);
 		}
-		return -EIO;
+		ret = -EIO;
+		goto out;
 	}
 	if (driv->attach == NULL) {
 		/* driver does not support manual configuration */
@@ -481,7 +484,8 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			 "driver '%s' does not support attach using comedi_config\n",
 			 driv->driver_name);
 		module_put(driv->module);
-		return -ENOSYS;
+		ret = -ENOSYS;
+		goto out;
 	}
 	/* initialize dev->driver here so
 	 * comedi_error() can be called from attach */
@@ -496,6 +500,8 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		module_put(dev->driver->module);
 	}
 	/* On success, the driver module count has been incremented. */
+out:
+	mutex_unlock(&comedi_drivers_list_lock);
 	return ret;
 }
 
@@ -552,8 +558,10 @@ EXPORT_SYMBOL_GPL(comedi_auto_unconfig);
 
 int comedi_driver_register(struct comedi_driver *driver)
 {
+	mutex_lock(&comedi_drivers_list_lock);
 	driver->next = comedi_drivers;
 	comedi_drivers = driver;
+	mutex_unlock(&comedi_drivers_list_lock);
 
 	return 0;
 }
@@ -564,6 +572,20 @@ void comedi_driver_unregister(struct comedi_driver *driver)
 	struct comedi_driver *prev;
 	int i;
 
+	/* unlink the driver */
+	mutex_lock(&comedi_drivers_list_lock);
+	if (comedi_drivers == driver) {
+		comedi_drivers = driver->next;
+	} else {
+		for (prev = comedi_drivers; prev->next; prev = prev->next) {
+			if (prev->next == driver) {
+				prev->next = driver->next;
+				break;
+			}
+		}
+	}
+	mutex_unlock(&comedi_drivers_list_lock);
+
 	/* check for devices using this driver */
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
 		struct comedi_device *dev = comedi_dev_from_minor(i);
@@ -581,17 +603,5 @@ void comedi_driver_unregister(struct comedi_driver *driver)
 		}
 		mutex_unlock(&dev->mutex);
 	}
-
-	if (comedi_drivers == driver) {
-		comedi_drivers = driver->next;
-		return;
-	}
-
-	for (prev = comedi_drivers; prev->next; prev = prev->next) {
-		if (prev->next == driver) {
-			prev->next = driver->next;
-			return;
-		}
-	}
 }
 EXPORT_SYMBOL_GPL(comedi_driver_unregister);

commit 99c0e2691736d56190764bfdc59f11b090cda4ff
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jun 27 14:50:57 2013 +0100

    staging: comedi: return void from comedi_driver_unregister()
    
    'Unregister' functions generally return `void`.
    `comedi_driver_unregister()` currently returns an `int` errno value.
    Nothing looks at the return value.  Change the return type to `void`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index a15934f94ab0..ba5d6d927a49 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -559,7 +559,7 @@ int comedi_driver_register(struct comedi_driver *driver)
 }
 EXPORT_SYMBOL_GPL(comedi_driver_register);
 
-int comedi_driver_unregister(struct comedi_driver *driver)
+void comedi_driver_unregister(struct comedi_driver *driver)
 {
 	struct comedi_driver *prev;
 	int i;
@@ -584,15 +584,14 @@ int comedi_driver_unregister(struct comedi_driver *driver)
 
 	if (comedi_drivers == driver) {
 		comedi_drivers = driver->next;
-		return 0;
+		return;
 	}
 
 	for (prev = comedi_drivers; prev->next; prev = prev->next) {
 		if (prev->next == driver) {
 			prev->next = driver->next;
-			return 0;
+			return;
 		}
 	}
-	return -EINVAL;
 }
 EXPORT_SYMBOL_GPL(comedi_driver_unregister);

commit d92fef8d2552ffde42b6092cb467f3021ebf8b98
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:05:31 2013 -0700

    staging: comedi: do not include <linux/delay.h> if its not needed
    
    Some of the comedi files include this header but don't need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 87df7960c96f..a15934f94ab0 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -23,7 +23,6 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/fcntl.h>
-#include <linux/delay.h>
 #include <linux/ioport.h>
 #include <linux/mm.h>
 #include <linux/slab.h>

commit 54db996e6dab51571718e8e97c26fdc695e254ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:14 2013 -0700

    staging: comedi: drivers: introduce comedi_alloc_devpriv()
    
    Introduce a helper function to allocate memory and set the
    comedi_device private data pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index e25eba5713c1..87df7960c96f 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -57,6 +57,18 @@ static void comedi_clear_hw_dev(struct comedi_device *dev)
 	dev->hw_dev = NULL;
 }
 
+/**
+ * comedi_alloc_devpriv() - Allocate memory for the device private data.
+ * @dev: comedi_device struct
+ * @size: size of the memory to allocate
+ */
+void *comedi_alloc_devpriv(struct comedi_device *dev, size_t size)
+{
+	dev->private = kzalloc(size, GFP_KERNEL);
+	return dev->private;
+}
+EXPORT_SYMBOL_GPL(comedi_alloc_devpriv);
+
 int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 {
 	struct comedi_subdevice *s;

commit 588ba6dc5fb4bdca47a3da38c2718fbb82d3eee1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 11 11:32:29 2013 -0700

    staging: comedi: drivers: let core handle freeing s->private
    
    Introduce a new subdevice runflags, SRF_FREE_SPRIV, and a new helper
    function, comedi_set_spriv(), that the drivers can use to set the
    comedi_subdevice private data pointer. The helper function will also
    set SRF_FREE_SPRIV to allow the comedi core to automatically free the
    subdevice private data during the cleanup_device() stage of the detach.
    
    Currently s->private is only allocated by the 8255, addi_watchdog,
    amplc_dio200_common, and ni_65xx drivers. All users of those drivers
    can then have the comedi_spriv_free() calls removed and in many cases
    the (*detach) can then simply be the appropriate comedi core provided
    function.
    
    The ni_65xx driver uses a helper function, ni_65xx_alloc_subdevice_private(),
    to allocate the private data. Refactor the function to return an errno
    or call comedi_set_spriv() instead of returning a pointer to the private
    data and requiring the caller to handle it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index f3e57fd8b2fb..e25eba5713c1 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -83,18 +83,6 @@ int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 }
 EXPORT_SYMBOL_GPL(comedi_alloc_subdevices);
 
-void comedi_spriv_free(struct comedi_device *dev, int subdev_num)
-{
-	struct comedi_subdevice *s;
-
-	if (dev->subdevices && subdev_num < dev->n_subdevices) {
-		s = &dev->subdevices[subdev_num];
-		kfree(s->private);
-		s->private = NULL;
-	}
-}
-EXPORT_SYMBOL_GPL(comedi_spriv_free);
-
 static void cleanup_device(struct comedi_device *dev)
 {
 	int i;
@@ -103,6 +91,8 @@ static void cleanup_device(struct comedi_device *dev)
 	if (dev->subdevices) {
 		for (i = 0; i < dev->n_subdevices; i++) {
 			s = &dev->subdevices[i];
+			if (s->runflags & SRF_FREE_SPRIV)
+				kfree(s->private);
 			comedi_free_subdevice_minor(s);
 			if (s->async) {
 				comedi_buf_alloc(dev, s, 0);

commit d569541e537e13136fc775a902cda06f4c48bbe1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 17 11:18:01 2013 -0700

    staging: comedi: ni_pcidio: use comedi_load_firmware()
    
    Use comedi_load_firmware() instead of duplicating the code in a
    private function.
    
    This driver loads multiple firmware images to the device. Modify
    comedi_load_firmware() to take a 'context' that is passed to the
    firmware upload callback function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 12f1974f2c81..f3e57fd8b2fb 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -353,12 +353,15 @@ static void comedi_report_boards(struct comedi_driver *driv)
  * @hw_device: device struct for the comedi_device
  * @name: the name of the firmware image
  * @cb: callback to the upload the firmware image
+ * @context: private context from the driver
  */
 int comedi_load_firmware(struct comedi_device *dev,
 			 struct device *device,
 			 const char *name,
 			 int (*cb)(struct comedi_device *dev,
-				   const u8 *data, size_t size))
+				   const u8 *data, size_t size,
+				   unsigned long context),
+			 unsigned long context)
 {
 	const struct firmware *fw;
 	int ret;
@@ -368,7 +371,7 @@ int comedi_load_firmware(struct comedi_device *dev,
 
 	ret = request_firmware(&fw, name, device);
 	if (ret == 0) {
-		ret = cb(dev, fw->data, fw->size);
+		ret = cb(dev, fw->data, fw->size, context);
 		release_firmware(fw);
 	}
 

commit 9ff8b151881adb408d1337bd7654cc869e9f42e0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 17 11:17:00 2013 -0700

    staging: comedi: drivers: generalize comedi_load_firmware()
    
    Move comedi_load_firmware() from jr3_pci.c to drivers.c and export
    it for general use by the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 216ba443ee61..12f1974f2c81 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -33,6 +33,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/io.h>
 #include <linux/interrupt.h>
+#include <linux/firmware.h>
 
 #include "comedidev.h"
 #include "comedi_internal.h"
@@ -346,6 +347,35 @@ static void comedi_report_boards(struct comedi_driver *driv)
 		pr_info(" %s\n", driv->driver_name);
 }
 
+/**
+ * comedi_load_firmware() - Request and load firmware for a device.
+ * @dev: comedi_device struct
+ * @hw_device: device struct for the comedi_device
+ * @name: the name of the firmware image
+ * @cb: callback to the upload the firmware image
+ */
+int comedi_load_firmware(struct comedi_device *dev,
+			 struct device *device,
+			 const char *name,
+			 int (*cb)(struct comedi_device *dev,
+				   const u8 *data, size_t size))
+{
+	const struct firmware *fw;
+	int ret;
+
+	if (!cb)
+		return -EINVAL;
+
+	ret = request_firmware(&fw, name, device);
+	if (ret == 0) {
+		ret = cb(dev, fw->data, fw->size);
+		release_firmware(fw);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(comedi_load_firmware);
+
 /**
  * __comedi_request_region() - Request an I/O reqion for a legacy driver.
  * @dev: comedi_device struct

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 06d190f8fd34..216ba443ee61 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -14,11 +14,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
 */
 
 #include <linux/device.h>

commit 3d1fe3f785c80e17f62acf8f92570ae9210bd588
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:37 2013 -0700

    staging: comedi: drivers: free_irq() in comedi_legacy_detach()
    
    All the legacy comedi drivers now call comedi_legacy_detach()
    either directly or as part of their (*detach). Move the free_irq()
    into comedi_legacy_detach() so that the drivers don't have to
    deal with it.
    
    For drivers that then only call comedi_legacy_detach() in their
    private (*detach), remove the private function and use the helper
    directly for the (*detach).
    
    The amplc_pc236 and ni_labpc drivers are hybrid legacy/PCI drivers.
    In the detach of a PCI board free_irq() still needs to be handled
    by the driver.
    
    The pcl724 and pcl726 drivers currently have the free_irq() #ifdef'ed
    out. The comedi_legacy_detach() function sanity checks that the irq
    has been requested before freeing it so they are safe to convert.
    
    For aesthetic reasons, move the #ifdef unused chunk in the pcl816
    driver up to the previous #ifdef unused block.
    
    The pcmio and pcmuio drivers request multiple irqs and handle the
    freeing of them. Remove the 'dev->irq = irq[0]' in those drivers
    so that comedi_legacy_detach() does not attempt to free the irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 6fecefeb51f1..06d190f8fd34 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -37,6 +37,7 @@
 #include <linux/cdev.h>
 #include <linux/dma-mapping.h>
 #include <linux/io.h>
+#include <linux/interrupt.h>
 
 #include "comedidev.h"
 #include "comedi_internal.h"
@@ -403,6 +404,10 @@ EXPORT_SYMBOL_GPL(comedi_request_region);
  */
 void comedi_legacy_detach(struct comedi_device *dev)
 {
+	if (dev->irq) {
+		free_irq(dev->irq, dev);
+		dev->irq = 0;
+	}
 	if (dev->iobase && dev->iolen) {
 		release_region(dev->iobase, dev->iolen);
 		dev->iobase = 0;

commit 316f97f169084c9a984d989d88ddce4eff60d749
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:31:29 2013 -0700

    staging: comedi: drivers: introduce comedi_legacy_detach()
    
    This function is intended to be used by the comedi legacy (ISA) drivers
    either directly as the (*detach) function or as a helper in the drivers
    private (*detach) function.
    
    Modify the comedi_request_region() helper so that it stores the 'len' of
    the region as well as the 'start' after the region has been successfuly
    allocated by request_region() in __comedi_request_region(). This region
    will then be automatically released detach of the driver by the
    comedi_legacy_detach() helper.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 2a28f64dc74c..6fecefeb51f1 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -122,6 +122,7 @@ static void cleanup_device(struct comedi_device *dev)
 	dev->board_name = NULL;
 	dev->board_ptr = NULL;
 	dev->iobase = 0;
+	dev->iolen = 0;
 	dev->ioenabled = false;
 	dev->irq = 0;
 	dev->read_subdev = NULL;
@@ -387,13 +388,29 @@ int comedi_request_region(struct comedi_device *dev,
 	int ret;
 
 	ret = __comedi_request_region(dev, start, len);
-	if (ret == 0)
+	if (ret == 0) {
 		dev->iobase = start;
+		dev->iolen = len;
+	}
 
 	return ret;
 }
 EXPORT_SYMBOL_GPL(comedi_request_region);
 
+/**
+ * comedi_legacy_detach() - A generic (*detach) function for legacy drivers.
+ * @dev: comedi_device struct
+ */
+void comedi_legacy_detach(struct comedi_device *dev)
+{
+	if (dev->iobase && dev->iolen) {
+		release_region(dev->iobase, dev->iolen);
+		dev->iobase = 0;
+		dev->iolen = 0;
+	}
+}
+EXPORT_SYMBOL_GPL(comedi_legacy_detach);
+
 int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_driver *driv;

commit 2f69915c728c3be41e12dbbbdd4eeb8d3388d58c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 15 16:41:57 2013 -0700

    staging: comedi: introduce, and use, comedi_spriv_free()
    
    The comedi_subdevice 'private' variable is a void * that is available
    for the subdevice to use in manner. It's common in comedi drivers for
    the driver to allocate memory for a subdevice and store the pointer
    to that memory in the 'private' variable. It's then the responsibility
    of the driver to free that memory when the device is detached.
    
    Due to how the attach/detach works in comedi, the drivers need to do
    some sanity checking before they can free the allocated memory during
    the detach.
    
    Introduce a helper function, comedi_spriv_free(), to handle freeing
    the private data allocated for a subdevice. This allows moving all the
    sanity checks into the helper function and makes it safe to call
    with any context. It also allows removing some of the boilerplate
    code in the (*detach) functions.
    
    Remove the subdev_8255_cleanup() export in the 8255 subdevice driver
    as well as the addi_watchdog_cleanup() export in the addi_watchdog
    driver and use the new helper instead.
    
    The amplc_dio200_common driver uses a number of local helper functions
    to free the private data for it's subdevices. Remove those as well and
    use the new helper.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 8a19f22d4ab9..2a28f64dc74c 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -86,6 +86,18 @@ int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 }
 EXPORT_SYMBOL_GPL(comedi_alloc_subdevices);
 
+void comedi_spriv_free(struct comedi_device *dev, int subdev_num)
+{
+	struct comedi_subdevice *s;
+
+	if (dev->subdevices && subdev_num < dev->n_subdevices) {
+		s = &dev->subdevices[subdev_num];
+		kfree(s->private);
+		s->private = NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(comedi_spriv_free);
+
 static void cleanup_device(struct comedi_device *dev)
 {
 	int i;

commit 5660e7427113eff85ae712af9cf98c8c5bd368e3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 12 10:11:54 2013 -0700

    staging: comedi: use EXPORT_SYMBOL_GPL() for all exported symbols
    
    Comedi is licensed under GPL. Some if its exports are currently
    EXPORT_SYMBOL() and others are EXPORT_SYMBOL_GPL(). Change them all
    to EXPORT_SYMBOL_GPL() and see if anyone reports any fall out.
    
    If any of the symbols "need" to be EXPORT_SYMBOL() they will be
    addressed as needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index c8ebaed5c4b5..8a19f22d4ab9 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -494,7 +494,7 @@ int comedi_driver_register(struct comedi_driver *driver)
 
 	return 0;
 }
-EXPORT_SYMBOL(comedi_driver_register);
+EXPORT_SYMBOL_GPL(comedi_driver_register);
 
 int comedi_driver_unregister(struct comedi_driver *driver)
 {
@@ -532,4 +532,4 @@ int comedi_driver_unregister(struct comedi_driver *driver)
 	}
 	return -EINVAL;
 }
-EXPORT_SYMBOL(comedi_driver_unregister);
+EXPORT_SYMBOL_GPL(comedi_driver_unregister);

commit ca8b296409c9800923fd431af15345e4da872bc0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:30:11 2013 -0700

    staging: comedi: drivers: refactor comedi_request_region()
    
    Split comedi_request_region() into two helper functions.
    
    __comedi_request_region()
    Handles the actual request_region() call.
    
    comedi_request_region()
    Calls __comedi_request_region() and then sets dev->iobase if the
    request was successful.
    
    This allows drivers to use the __comedi_request_region() helper
    to handle the request without setting the dev->iobase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 6456a6422048..c8ebaed5c4b5 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -338,13 +338,13 @@ static void comedi_report_boards(struct comedi_driver *driv)
 }
 
 /**
- * comedi_request_region() - Request an I/O reqion for a legacy driver.
+ * __comedi_request_region() - Request an I/O reqion for a legacy driver.
  * @dev: comedi_device struct
  * @start: base address of the I/O reqion
  * @len: length of the I/O region
  */
-int comedi_request_region(struct comedi_device *dev,
-			  unsigned long start, unsigned long len)
+int __comedi_request_region(struct comedi_device *dev,
+			    unsigned long start, unsigned long len)
 {
 	if (!start) {
 		dev_warn(dev->class_dev,
@@ -358,10 +358,28 @@ int comedi_request_region(struct comedi_device *dev,
 			 dev->board_name, start, len);
 		return -EIO;
 	}
-	dev->iobase = start;
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(__comedi_request_region);
+
+/**
+ * comedi_request_region() - Request an I/O reqion for a legacy driver.
+ * @dev: comedi_device struct
+ * @start: base address of the I/O reqion
+ * @len: length of the I/O region
+ */
+int comedi_request_region(struct comedi_device *dev,
+			  unsigned long start, unsigned long len)
+{
+	int ret;
+
+	ret = __comedi_request_region(dev, start, len);
+	if (ret == 0)
+		dev->iobase = start;
+
+	return ret;
+}
 EXPORT_SYMBOL_GPL(comedi_request_region);
 
 int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)

commit f375ac5f197d32aeffe5436e5864525cc14ce44a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:05:54 2013 -0700

    staging: comedi: drivers: introduce comedi_request_region()
    
    Introduce a helper function to handle the request_region() for legacy
    comedi drivers.
    
    As pointed out by Ian Abbott, legacy devices are configured manually
    with the "comedi_config" program. The error messages are useful
    diagnostics when trying to attach to these boards.
    
    Providing a helper function allows consolidating the error messages
    in the drivers and providing a consistent format for the errors.
    
    This helper also sets the dev->iobase automatically for the driver
    if the request_region() is successful.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 4a1eb7b7a8da..6456a6422048 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -337,6 +337,33 @@ static void comedi_report_boards(struct comedi_driver *driv)
 		pr_info(" %s\n", driv->driver_name);
 }
 
+/**
+ * comedi_request_region() - Request an I/O reqion for a legacy driver.
+ * @dev: comedi_device struct
+ * @start: base address of the I/O reqion
+ * @len: length of the I/O region
+ */
+int comedi_request_region(struct comedi_device *dev,
+			  unsigned long start, unsigned long len)
+{
+	if (!start) {
+		dev_warn(dev->class_dev,
+			 "%s: a I/O base address must be specified\n",
+			 dev->board_name);
+		return -EINVAL;
+	}
+
+	if (!request_region(start, len, dev->board_name)) {
+		dev_warn(dev->class_dev, "%s: I/O port conflict (%#lx,%lu)\n",
+			 dev->board_name, start, len);
+		return -EIO;
+	}
+	dev->iobase = start;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(comedi_request_region);
+
 int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_driver *driv;

commit ae5dd5fcab2d9978e1a0a900a8598b4d92f02657
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 8 10:56:02 2013 -0700

    staging: comedi: drivers: dev->board_name is always valid
    
    The dev->board_name is always initialized before calling the(*attach)
    or (*auto_attach) function. The "BUG" check in comedi_device_postconfig()
    is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 09d67dac74bc..4a1eb7b7a8da 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -272,13 +272,8 @@ static int comedi_device_postconfig(struct comedi_device *dev)
 	int ret;
 
 	ret = __comedi_device_postconfig(dev);
-	if (ret < 0) {
+	if (ret < 0)
 		return ret;
-	}
-	if (!dev->board_name) {
-		dev_warn(dev->class_dev, "BUG: dev->board_name=NULL\n");
-		dev->board_name = "BUG";
-	}
 	smp_wmb();
 	dev->attached = true;
 	return 0;

commit 34b68400ee3aabda0cd0c951fca3b8e6fd96c015
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 8 10:55:29 2013 -0700

    staging: comedi: drivers: set dev->board_name before attaching
    
    The comedi (*attach) and (*auto_attach) functions are used to attach
    legacy and PnP type devices to the comedi subsystem. If we can set the
    dev->board_name before doing the attach, the drivers will not have to
    worry about doing it.
    
    Drivers that do additional probing can still change the dev->board_name
    if necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 8db9deed3bc6..09d67dac74bc 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -383,6 +383,8 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* initialize dev->driver here so
 	 * comedi_error() can be called from attach */
 	dev->driver = driv;
+	dev->board_name = dev->board_ptr ? *(const char **)dev->board_ptr
+					 : dev->driver->driver_name;
 	ret = driv->attach(dev, it);
 	if (ret >= 0)
 		ret = comedi_device_postconfig(dev);
@@ -423,6 +425,7 @@ int comedi_auto_config(struct device *hardware_device,
 	/* Note: comedi_alloc_board_minor() locked dev->mutex. */
 
 	dev->driver = driver;
+	dev->board_name = dev->driver->driver_name;
 	ret = driver->auto_attach(dev, context);
 	if (ret >= 0)
 		ret = comedi_device_postconfig(dev);

commit 6013a9a57bbe0fd147482297b04d3d848aa24b67
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 8 10:55:05 2013 -0700

    staging: comedi: drivers: rename 'comedi_dev' in comedi_auto_config()
    
    The struct comedi_device pointer in this file, and the rest of the
    comedi subsystem, is typically called 'dev'. Rename the local variable
    'comedi_dev' in comedi_auto_config() for consistency.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 81705fbfc018..8db9deed3bc6 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -397,7 +397,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 int comedi_auto_config(struct device *hardware_device,
 		       struct comedi_driver *driver, unsigned long context)
 {
-	struct comedi_device *comedi_dev;
+	struct comedi_device *dev;
 	int ret;
 
 	if (!hardware_device) {
@@ -417,18 +417,18 @@ int comedi_auto_config(struct device *hardware_device,
 		return -EINVAL;
 	}
 
-	comedi_dev = comedi_alloc_board_minor(hardware_device);
-	if (IS_ERR(comedi_dev))
-		return PTR_ERR(comedi_dev);
-	/* Note: comedi_alloc_board_minor() locked comedi_dev->mutex. */
+	dev = comedi_alloc_board_minor(hardware_device);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+	/* Note: comedi_alloc_board_minor() locked dev->mutex. */
 
-	comedi_dev->driver = driver;
-	ret = driver->auto_attach(comedi_dev, context);
+	dev->driver = driver;
+	ret = driver->auto_attach(dev, context);
 	if (ret >= 0)
-		ret = comedi_device_postconfig(comedi_dev);
+		ret = comedi_device_postconfig(dev);
 	if (ret < 0)
-		comedi_device_detach(comedi_dev);
-	mutex_unlock(&comedi_dev->mutex);
+		comedi_device_detach(dev);
+	mutex_unlock(&dev->mutex);
 
 	if (ret < 0)
 		comedi_release_hardware_device(hardware_device);

commit db2e3487a5fa1f650680c672e0742d943039d2cc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:59:00 2013 +0100

    staging: comedi: set hw_dev in comedi_alloc_board_minor()
    
    Call `comedi_set_hw_dev()` to set the `hw_dev` member of `struct
    comedi_device` in `comedi_alloc_board_minor()` instead of in
    `comedi_auto_config()`.  Don't bother to check for an error returned by
    `comedi_set_hw_dev()` here; it only fails when changing a non-NULL
    pointer to a different non-NULL pointer and since the `struct
    comedi_device` has just been allocated and initialized, its `hw_dev`
    will be NULL already.  Calling `comedi_set_hw_dev()` with a non-NULL
    hardware device pointer increments the kref counter for the hardware
    device.
    
    If `comedi_alloc_board_minor()` fails further down the function, we rely
    on its call to `comedi_device_cleanup()` to call `comedi_clear_hw_dev()`
    (via `comedi_device_detach()` and `cleanup_device()`) to clear `hw_dev`
    and decrement its kref counter.  (That's the "beneficial side-effect"
    mentioned in the patch that replaced `__comedi_device_detach()`.)
    
    Remove the call to `comedi_set_hw_dev()` from `comedi_auto_config()` as
    the call to `comedi_alloc_board_minor()` does it for us.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index fe2ad91f5aab..81705fbfc018 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -422,7 +422,6 @@ int comedi_auto_config(struct device *hardware_device,
 		return PTR_ERR(comedi_dev);
 	/* Note: comedi_alloc_board_minor() locked comedi_dev->mutex. */
 
-	comedi_set_hw_dev(comedi_dev, hardware_device);
 	comedi_dev->driver = driver;
 	ret = driver->auto_attach(comedi_dev, context);
 	if (ret >= 0)

commit 74ece108f9e55e7967d24a61e30f43e3aceb4809
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:59 2013 +0100

    staging: comedi: move detach out of post-config
    
    `comedi_device_postconfig()` calls `comedi_device_detach()` on failure.
    Remove that call and make the callers of `comedi_device_postconfig()`
    call `comedi_device_detach()` themselves if it returns an error.  This
    seems more logical as the callers of `comedi_device_postconfig()` called
    `comedi_device_detach()` anyway if they didn't call
    `comedi_device_postconfig()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index cf1ca822a2ce..fe2ad91f5aab 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -273,7 +273,6 @@ static int comedi_device_postconfig(struct comedi_device *dev)
 
 	ret = __comedi_device_postconfig(dev);
 	if (ret < 0) {
-		comedi_device_detach(dev);
 		return ret;
 	}
 	if (!dev->board_name) {
@@ -385,14 +384,12 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	 * comedi_error() can be called from attach */
 	dev->driver = driv;
 	ret = driv->attach(dev, it);
+	if (ret >= 0)
+		ret = comedi_device_postconfig(dev);
 	if (ret < 0) {
 		comedi_device_detach(dev);
 		module_put(dev->driver->module);
-		return ret;
 	}
-	ret = comedi_device_postconfig(dev);
-	if (ret < 0)
-		module_put(dev->driver->module);
 	/* On success, the driver module count has been incremented. */
 	return ret;
 }
@@ -428,10 +425,10 @@ int comedi_auto_config(struct device *hardware_device,
 	comedi_set_hw_dev(comedi_dev, hardware_device);
 	comedi_dev->driver = driver;
 	ret = driver->auto_attach(comedi_dev, context);
+	if (ret >= 0)
+		ret = comedi_device_postconfig(comedi_dev);
 	if (ret < 0)
 		comedi_device_detach(comedi_dev);
-	else
-		ret = comedi_device_postconfig(comedi_dev);
 	mutex_unlock(&comedi_dev->mutex);
 
 	if (ret < 0)

commit 016599f589a50feee9f515dc1e7879e390ae229f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:58 2013 +0100

    staging: comedi: replace __comedi_device_detach()
    
    `comedi_device_detach()` does nothing if the `struct comedi_device`'s
    `attached` member is false, otherwise it calls
    `__comedi_device_detach()` to do the real work.
    `__comedi_device_detach()` is called from various other functions in
    "drivers.c" (`comedi_device_postconfig()`, `comedi_device_attach()`, and
    `comedi_auto_config()`) to bypass the check for the `attached` member
    being false.
    
    If we make `__comedi_device_detach()` safe to call when the `attached`
    member is already false, we can remove the check in
    `comedi_device_detach()`, subsume `__comedi_device_detach()` within
    `comedi_device_detach()`, and replace all the calls to
    `__comedi_device_detach()` with calls to `comedi_device_detach()`.
    
    In fact, it is already safe to call `__comedi_device_detach()` when the
    `attached` member is false.  We just need to remove the warning message
    it outputs when the `driver` member is NULL.  Then the function becomes
    idempotent without outputting spurious warnings.  (It is idempotent
    because `dev->driver->detach()` will only be called once at most and the
    call to `cleanup_device()` is idempotent itself.)
    
    Combine `comedi_device_detach()` with `__comedi_device_detach()`,
    removing the check for the `attached` member being false and removing
    the warning about the `driver` member being NULL, and replace all calls
    to `__comedi_device_detach()` with calls to the combined
    `comedi_device_detach()`.
    
    A beneficial side-effect of the above change is that a call to
    `comedi_device_detach()` will always result in a call to
    `cleanup_device()` and so always result in a call to
    `comedi_clear_hw_dev()`.  We will make use of this beneficial
    side-effect in a later patch.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 6f232b8128c0..cf1ca822a2ce 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -119,24 +119,14 @@ static void cleanup_device(struct comedi_device *dev)
 	comedi_clear_hw_dev(dev);
 }
 
-static void __comedi_device_detach(struct comedi_device *dev)
+void comedi_device_detach(struct comedi_device *dev)
 {
 	dev->attached = false;
 	if (dev->driver)
 		dev->driver->detach(dev);
-	else
-		dev_warn(dev->class_dev,
-			 "BUG: dev->driver=NULL in comedi_device_detach()\n");
 	cleanup_device(dev);
 }
 
-void comedi_device_detach(struct comedi_device *dev)
-{
-	if (!dev->attached)
-		return;
-	__comedi_device_detach(dev);
-}
-
 static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	return -EINVAL;
@@ -283,7 +273,7 @@ static int comedi_device_postconfig(struct comedi_device *dev)
 
 	ret = __comedi_device_postconfig(dev);
 	if (ret < 0) {
-		__comedi_device_detach(dev);
+		comedi_device_detach(dev);
 		return ret;
 	}
 	if (!dev->board_name) {
@@ -396,7 +386,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->driver = driv;
 	ret = driv->attach(dev, it);
 	if (ret < 0) {
-		__comedi_device_detach(dev);
+		comedi_device_detach(dev);
 		module_put(dev->driver->module);
 		return ret;
 	}
@@ -439,7 +429,7 @@ int comedi_auto_config(struct device *hardware_device,
 	comedi_dev->driver = driver;
 	ret = driver->auto_attach(comedi_dev, context);
 	if (ret < 0)
-		__comedi_device_detach(comedi_dev);
+		comedi_device_detach(comedi_dev);
 	else
 		ret = comedi_device_postconfig(comedi_dev);
 	mutex_unlock(&comedi_dev->mutex);

commit dcd7b8bd63cb81c5b973bf86510ca3c80bbbd162
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:57 2013 +0100

    staging: comedi: put module _after_ detach
    
    On failure of the call to the low-level comedi device driver's
    `->attach()` handler from `__comedi_device_attach()`, reverse the
    current ordering of the calls to `module_put()` and
    `comedi_device_detach()` because `__comedi_device_detach()` will call
    code in the module being put.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 73727a73bd34..6f232b8128c0 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -396,8 +396,8 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->driver = driv;
 	ret = driv->attach(dev, it);
 	if (ret < 0) {
-		module_put(dev->driver->module);
 		__comedi_device_detach(dev);
+		module_put(dev->driver->module);
 		return ret;
 	}
 	ret = comedi_device_postconfig(dev);

commit b2a644b435de1d45bd8b5d4e391c894a662eb1f3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:56 2013 +0100

    staging: comedi: simplify driver module counting
    
    For a legacy device attachment with the `COMEDI_DEVCONFIG` ioctl,
    `do_devconfig_ioctl()` calls `comedi_device_attach()` to find a matching
    device driver and attach the device.  It then tries to increment the
    device driver's module count and if that fails it detaches the device.
    So on successful attachment of a device by the `COMEDI_DEVCONFIG` ioctl,
    the device driver's module count will have been incremented.
    
    `comedi_device_attach()` is called from nowhere else.  It already
    increments the device driver's module count temporarily and decrements
    it again; if it gets as far as calling `comedi_device_postconfig()` the
    module count is decremented within that function.
    
    Simplify the above by removing the decrement of the device driver module
    count from `comedi_device_postconfig()`.  If the call to
    `comedi_device_postconfig()` succeeds, `comedi_device_attach()` will
    return with the module count still incremented, otherwise decrement the
    module count before returning the error.  Don't try and increment the
    module count in `do_devconfig_ioctl()` after a successful return from
    `comedi_device_attach()` as the module count has now already been
    incremented.
    
    `comedi_device_postconfig()` is also called by `comedi_auto_config()`
    which currently has to increment the device driver's module count
    temporarily so that `comedi_device_postconfig()` can decrement it, but
    always returns with no overall change to the module count.  Remove all
    the module count manipulations from `comedi_device_postconfig()`.  There
    is no other reason for `comedi_auto_config()` to increment the device
    driver's module count temporarily, since it is only called (indirectly)
    from the device driver itself (usually via one of the wrappers
    `comedi_pci_auto_config()` or `comedi_usb_auto_config()`).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index caadd3bd72ac..73727a73bd34 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -277,11 +277,11 @@ static int __comedi_device_postconfig(struct comedi_device *dev)
 }
 
 /* do a little post-config cleanup */
-/* called with module refcount incremented, decrements it */
 static int comedi_device_postconfig(struct comedi_device *dev)
 {
-	int ret = __comedi_device_postconfig(dev);
-	module_put(dev->driver->module);
+	int ret;
+
+	ret = __comedi_device_postconfig(dev);
 	if (ret < 0) {
 		__comedi_device_detach(dev);
 		return ret;
@@ -400,7 +400,11 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		__comedi_device_detach(dev);
 		return ret;
 	}
-	return comedi_device_postconfig(dev);
+	ret = comedi_device_postconfig(dev);
+	if (ret < 0)
+		module_put(dev->driver->module);
+	/* On success, the driver module count has been incremented. */
+	return ret;
 }
 
 int comedi_auto_config(struct device *hardware_device,
@@ -431,19 +435,13 @@ int comedi_auto_config(struct device *hardware_device,
 		return PTR_ERR(comedi_dev);
 	/* Note: comedi_alloc_board_minor() locked comedi_dev->mutex. */
 
-	if (!try_module_get(driver->module))
-		ret = -EIO;
-	else {
-		comedi_set_hw_dev(comedi_dev, hardware_device);
-		comedi_dev->driver = driver;
-		ret = driver->auto_attach(comedi_dev, context);
-		if (ret < 0) {
-			module_put(driver->module);
-			__comedi_device_detach(comedi_dev);
-		} else {
-			ret = comedi_device_postconfig(comedi_dev);
-		}
-	}
+	comedi_set_hw_dev(comedi_dev, hardware_device);
+	comedi_dev->driver = driver;
+	ret = driver->auto_attach(comedi_dev, context);
+	if (ret < 0)
+		__comedi_device_detach(comedi_dev);
+	else
+		ret = comedi_device_postconfig(comedi_dev);
 	mutex_unlock(&comedi_dev->mutex);
 
 	if (ret < 0)

commit 07778393d9a8dbc4b9306d20a8ecfe053771ba93
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:51 2013 +0100

    staging: comedi: pre-lock mutex on creation of comedi device
    
    Return from `comedi_alloc_board_minor()` with the mutex of the created
    `struct comedi_device` pre-locked.  This allows further initialization
    by the caller without the worry of something getting in there first.
    
    `comedi_auto_config()` no longer needs to check if the device is already
    "attached" since whatever was trying to attach the device would need to
    have locked the mutex first.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 0b72af8c4480..caadd3bd72ac 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -429,11 +429,9 @@ int comedi_auto_config(struct device *hardware_device,
 	comedi_dev = comedi_alloc_board_minor(hardware_device);
 	if (IS_ERR(comedi_dev))
 		return PTR_ERR(comedi_dev);
+	/* Note: comedi_alloc_board_minor() locked comedi_dev->mutex. */
 
-	mutex_lock(&comedi_dev->mutex);
-	if (comedi_dev->attached)
-		ret = -EBUSY;
-	else if (!try_module_get(driver->module))
+	if (!try_module_get(driver->module))
 		ret = -EIO;
 	else {
 		comedi_set_hw_dev(comedi_dev, hardware_device);

commit 7638ffcb50903d9ddbf605c7e9578d72658a960a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:50 2013 +0100

    staging: comedi: change comedi_alloc_board_minor() to return pointer
    
    Change `comedi_alloc_board_minor()` to return a pointer to the allocated
    `struct comedi_device` instead of a minor device number.  Return an
    `ERR_PTR()` value on error instead of a negative error number.  This
    saves a call to `comedi_dev_from_minor()` in `comedi_auto_config()`.
    
    Also change it to use a local variable `dev` to hold the pointer to the
    `struct comedi_device` instead of using `info->device` all the time.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 5a506a5bab68..0b72af8c4480 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -406,7 +406,6 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 int comedi_auto_config(struct device *hardware_device,
 		       struct comedi_driver *driver, unsigned long context)
 {
-	int minor;
 	struct comedi_device *comedi_dev;
 	int ret;
 
@@ -427,11 +426,9 @@ int comedi_auto_config(struct device *hardware_device,
 		return -EINVAL;
 	}
 
-	minor = comedi_alloc_board_minor(hardware_device);
-	if (minor < 0)
-		return minor;
-
-	comedi_dev = comedi_dev_from_minor(minor);
+	comedi_dev = comedi_alloc_board_minor(hardware_device);
+	if (IS_ERR(comedi_dev))
+		return PTR_ERR(comedi_dev);
 
 	mutex_lock(&comedi_dev->mutex);
 	if (comedi_dev->attached)

commit f5b31e15acd1ab2fd9b9022c29a66f4625fa5658
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:48 2013 +0100

    staging: comedi: call comedi_release_hardware_device() on error
    
    If `comedi_auto_config()` fails after allocating the minor device, call
    `comedi_release_hardware_device()` instead of
    `comedi_free_board_minor()` to free the minor device.  That's the same
    call that `comedi_auto_unconfig()` uses, and is slightly safer as it
    checks the minor device number is still tied to the same hardware
    device.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 29c8f5037065..5a506a5bab68 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -452,7 +452,7 @@ int comedi_auto_config(struct device *hardware_device,
 	mutex_unlock(&comedi_dev->mutex);
 
 	if (ret < 0)
-		comedi_free_board_minor(minor);
+		comedi_release_hardware_device(hardware_device);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(comedi_auto_config);

commit 3346b798f202bf2f5b5272870ecdb75acec2e752
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:47 2013 +0100

    staging: comedi: add comedi_release_hardware_device()
    
    Add `comedi_release_hardware_device()` as a replacement for the call
    sequence `comedi_find_board_minor()`, `comedi_free_board_minor()`.  This
    is slightly safer as we can make sure nothing funny happens to the found
    `comedi_file_info_table[]` entry in the middle of the sequence.  Change
    `comedi_auto_unconfig()` to call the new function instead of the old
    sequence.  Remove `comedi_find_board_minor()` as it has no other
    callers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 4460814d5344..29c8f5037065 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -459,14 +459,9 @@ EXPORT_SYMBOL_GPL(comedi_auto_config);
 
 void comedi_auto_unconfig(struct device *hardware_device)
 {
-	int minor;
-
 	if (hardware_device == NULL)
 		return;
-	minor = comedi_find_board_minor(hardware_device);
-	if (minor < 0)
-		return;
-	comedi_free_board_minor(minor);
+	comedi_release_hardware_device(hardware_device);
 }
 EXPORT_SYMBOL_GPL(comedi_auto_unconfig);
 

commit f08e0ac59a93db2d8abc7000e2647164104524c6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Apr 4 14:58:42 2013 +0100

    staging: comedi: check comedi_auto_config() params
    
    Do some minimal error checking of the parameters of
    `comedi_auto_config()`.  Just make sure the `hardware_device` and
    `driver` parameters are non-NULL.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 4724f275830c..4460814d5344 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -410,6 +410,16 @@ int comedi_auto_config(struct device *hardware_device,
 	struct comedi_device *comedi_dev;
 	int ret;
 
+	if (!hardware_device) {
+		pr_warn("BUG! comedi_auto_config called with NULL hardware_device\n");
+		return -EINVAL;
+	}
+	if (!driver) {
+		dev_warn(hardware_device,
+			 "BUG! comedi_auto_config called with NULL comedi driver\n");
+		return -EINVAL;
+	}
+
 	if (!driver->auto_attach) {
 		dev_warn(hardware_device,
 			 "BUG! comedi driver '%s' has no auto_attach handler\n",

commit 00ca6884186f18a758eae37e94f7c3c0527f8f30
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:35 2013 +0000

    staging: comedi: add 'ioenabled' flag to device
    
    Add 1-bit bit-field member `ioenabled` of type `bool` to `struct
    comedi_device`.  Use this to keep track of whether a PCI device and its
    BARs have been successfully enabled by `comedi_pci_enable()`.  This
    avoids overloading the meaning of the `iobase` member which is used by
    several drivers to hold the base port I/O address of a board's "main"
    registers.  Other drivers using MMIO use `iobase` as a flag to indicate
    that the preceding call to `comedi_pci_enable()` was successful.  They
    no longer need to do that.
    
    The name `ioenabled` is intended to be PCI-agnostic so it can be used
    for similar purposes by non-PCI drivers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 87052735d91c..4724f275830c 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -110,6 +110,7 @@ static void cleanup_device(struct comedi_device *dev)
 	dev->board_name = NULL;
 	dev->board_ptr = NULL;
 	dev->iobase = 0;
+	dev->ioenabled = false;
 	dev->irq = 0;
 	dev->read_subdev = NULL;
 	dev->write_subdev = NULL;

commit a7401cddcdf739d3cb9598c9b3787a732fc87809
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:33 2013 +0000

    staging: comedi: make 'dev->attached' a bool bit-field
    
    Change the `attached` member of `struct comedi_device` to a 1-bit
    bit-field of type `bool`.  Change assigned values to `true` and `false`
    and replace or remove comparison operations with simple boolean tests.
    
    We'll put some extra bit-fields in the gap later to save space.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 64be7c5e891e..87052735d91c 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -120,7 +120,7 @@ static void cleanup_device(struct comedi_device *dev)
 
 static void __comedi_device_detach(struct comedi_device *dev)
 {
-	dev->attached = 0;
+	dev->attached = false;
 	if (dev->driver)
 		dev->driver->detach(dev);
 	else
@@ -290,7 +290,7 @@ static int comedi_device_postconfig(struct comedi_device *dev)
 		dev->board_name = "BUG";
 	}
 	smp_wmb();
-	dev->attached = 1;
+	dev->attached = true;
 	return 0;
 }
 

commit 78110bb8dc4a7ff331bfa3cfe7d4e287cfb3f22b
Author: Joe Perches <joe@perches.com>
Date:   Mon Feb 11 09:41:29 2013 -0800

    staging: Remove unnecessary OOM messages
    
    alloc failures already get standardized OOM
    messages and a dump_stack.
    
    For the affected mallocs around these OOM messages:
    
    Converted kzallocs with multiplies to kcalloc.
    Converted kmallocs with multiplies to kmalloc_array.
    Converted a kmalloc/strlen/strncpy to kstrdup.
    Moved a spin_lock below a removed OOM message and
    removed a now unnecessary spin_unlock.
    Neatened alignment and whitespace.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index e57e661e1251..64be7c5e891e 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -203,10 +203,9 @@ static int __comedi_device_postconfig_async(struct comedi_device *dev,
 	}
 
 	async = kzalloc(sizeof(*async), GFP_KERNEL);
-	if (!async) {
-		dev_warn(dev->class_dev, "failed to allocate async struct\n");
+	if (!async)
 		return -ENOMEM;
-	}
+
 	init_waitqueue_head(&async->wait_head);
 	async->subdevice = s;
 	s->async = async;

commit 4a79f730179061c54d5c4ce1b59c1babbb05912f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 17:13:01 2013 -0700

    staging: comedi: remove 'comedi_autoconfig' module parameter
    
    This module parameter is used to enable the auto config mechanism
    in the comedi core. Most of the PCI, PCMCIA, and USB drivers have
    been converted to use the auto config mechanism and will not attach
    if it is disabled.
    
    Since the 'comedi_autoconfig' parameter is defaulted to true, just
    remove it so that the comedi drivers that use auto config will
    always be able to attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index d91b173b1f40..e57e661e1251 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -410,9 +410,6 @@ int comedi_auto_config(struct device *hardware_device,
 	struct comedi_device *comedi_dev;
 	int ret;
 
-	if (!comedi_autoconfig)
-		return 0;
-
 	if (!driver->auto_attach) {
 		dev_warn(hardware_device,
 			 "BUG! comedi driver '%s' has no auto_attach handler\n",

commit de06d7c6b8e3b886eec0302ecbadf76944a42ca4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 1 13:23:20 2013 +0000

    staging: comedi: restrict comedi_set_hw_dev() usage
    
    Don't allow comedi drivers to change `dev->hw_dev` using
    `comedi_set_hw_dev()` if it's already been set.  Return `-EEXIST` in
    that case.
    
    `dev->hw_dev` needs to be set to NULL by the core during clean-up of the
    comedi device, so add a local function `comedi_clear_hw_dev()` to do
    that.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 5adf9fc45de4..d91b173b1f40 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -45,14 +45,21 @@ struct comedi_driver *comedi_drivers;
 
 int comedi_set_hw_dev(struct comedi_device *dev, struct device *hw_dev)
 {
-	struct device *old_hw_dev = dev->hw_dev;
-
+	if (hw_dev == dev->hw_dev)
+		return 0;
+	if (dev->hw_dev != NULL)
+		return -EEXIST;
 	dev->hw_dev = get_device(hw_dev);
-	put_device(old_hw_dev);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(comedi_set_hw_dev);
 
+static void comedi_clear_hw_dev(struct comedi_device *dev)
+{
+	put_device(dev->hw_dev);
+	dev->hw_dev = NULL;
+}
+
 int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 {
 	struct comedi_subdevice *s;
@@ -108,7 +115,7 @@ static void cleanup_device(struct comedi_device *dev)
 	dev->write_subdev = NULL;
 	dev->open = NULL;
 	dev->close = NULL;
-	comedi_set_hw_dev(dev, NULL);
+	comedi_clear_hw_dev(dev);
 }
 
 static void __comedi_device_detach(struct comedi_device *dev)

commit da71751177f35f0ca5494968cc237511c423a744
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 1 13:23:19 2013 +0000

    staging: comedi: export comedi_set_hw_dev()
    
    Chnage the inline `comedi_set_hw_dev()` to an exported function and
    change it's return type from `void` to `int` so we can impose some
    restrictions (in a later patch) and return an error if necessary.
    
    Only a few comedi drivers call this, although they don't need to if the
    hardware device has been attached automatically via
    `comedi_auto_config()` and the comedi driver's `auto_attach()` method.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index cc6240aa5790..5adf9fc45de4 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -43,6 +43,16 @@
 
 struct comedi_driver *comedi_drivers;
 
+int comedi_set_hw_dev(struct comedi_device *dev, struct device *hw_dev)
+{
+	struct device *old_hw_dev = dev->hw_dev;
+
+	dev->hw_dev = get_device(hw_dev);
+	put_device(old_hw_dev);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(comedi_set_hw_dev);
+
 int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 {
 	struct comedi_subdevice *s;

commit f65cc5447eaea9f7be1ff54e27c9658a66c5910f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 1 10:20:30 2013 +0000

    staging: comedi: change comedi_alloc_subdevice_minor parameters
    
    `comedi_alloc_subdevice_minor()` doesn't really need a parameter
    pointing to a `struct comedi_device` as it can get this information from
    the parameter pointing to a `struct comedi_subdevice`.  Just pass the
    subdevice parameter.
    
    Signed-by: Ian Abbott <abbotti@mev.co.uk>
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index fe91e758184f..cc6240aa5790 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -209,7 +209,7 @@ static int __comedi_device_postconfig_async(struct comedi_device *dev,
 			return ret;
 	}
 
-	comedi_alloc_subdevice_minor(dev, s);
+	comedi_alloc_subdevice_minor(s);
 
 	return 0;
 }

commit 1ae6b20b88737f1828649b6cbe349c83b9f97bf0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:24:38 2013 -0700

    staging: comedi: tidy up the general purpose driver functions
    
    Group all the general comedi driver register/config/attach
    prototypes into one place in comedidev.h.
    
    Reorder the functions in drivers.c a bit so they are in a more
    logical usage order (bottom to top).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 151e0845569e..fe91e758184f 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -386,53 +386,6 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return comedi_device_postconfig(dev);
 }
 
-int comedi_driver_register(struct comedi_driver *driver)
-{
-	driver->next = comedi_drivers;
-	comedi_drivers = driver;
-
-	return 0;
-}
-EXPORT_SYMBOL(comedi_driver_register);
-
-int comedi_driver_unregister(struct comedi_driver *driver)
-{
-	struct comedi_driver *prev;
-	int i;
-
-	/* check for devices using this driver */
-	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
-		struct comedi_device *dev = comedi_dev_from_minor(i);
-
-		if (!dev)
-			continue;
-
-		mutex_lock(&dev->mutex);
-		if (dev->attached && dev->driver == driver) {
-			if (dev->use_count)
-				dev_warn(dev->class_dev,
-					 "BUG! detaching device with use_count=%d\n",
-					 dev->use_count);
-			comedi_device_detach(dev);
-		}
-		mutex_unlock(&dev->mutex);
-	}
-
-	if (comedi_drivers == driver) {
-		comedi_drivers = driver->next;
-		return 0;
-	}
-
-	for (prev = comedi_drivers; prev->next; prev = prev->next) {
-		if (prev->next == driver) {
-			prev->next = driver->next;
-			return 0;
-		}
-	}
-	return -EINVAL;
-}
-EXPORT_SYMBOL(comedi_driver_unregister);
-
 int comedi_auto_config(struct device *hardware_device,
 		       struct comedi_driver *driver, unsigned long context)
 {
@@ -492,3 +445,50 @@ void comedi_auto_unconfig(struct device *hardware_device)
 	comedi_free_board_minor(minor);
 }
 EXPORT_SYMBOL_GPL(comedi_auto_unconfig);
+
+int comedi_driver_register(struct comedi_driver *driver)
+{
+	driver->next = comedi_drivers;
+	comedi_drivers = driver;
+
+	return 0;
+}
+EXPORT_SYMBOL(comedi_driver_register);
+
+int comedi_driver_unregister(struct comedi_driver *driver)
+{
+	struct comedi_driver *prev;
+	int i;
+
+	/* check for devices using this driver */
+	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
+		struct comedi_device *dev = comedi_dev_from_minor(i);
+
+		if (!dev)
+			continue;
+
+		mutex_lock(&dev->mutex);
+		if (dev->attached && dev->driver == driver) {
+			if (dev->use_count)
+				dev_warn(dev->class_dev,
+					 "BUG! detaching device with use_count=%d\n",
+					 dev->use_count);
+			comedi_device_detach(dev);
+		}
+		mutex_unlock(&dev->mutex);
+	}
+
+	if (comedi_drivers == driver) {
+		comedi_drivers = driver->next;
+		return 0;
+	}
+
+	for (prev = comedi_drivers; prev->next; prev = prev->next) {
+		if (prev->next == driver) {
+			prev->next = driver->next;
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+EXPORT_SYMBOL(comedi_driver_unregister);

commit 309231d7a610554b02084ff7b465e43ef383a3bc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:44 2013 -0700

    staging: comedi: conditionally build in PCMCIA driver support
    
    Separate the comedi_pcmcia_* functions out of drivers.c into a new
    source file, comedi_pcmcia.c. This allows conditionally building
    support for comedi pcmcia drivers into the comedi core without the
    need for the #if'defery. Fix the Kconfig and Makefile appropriately.
    
    Group all the comedi_pcmcia_* prototypes into one place in comedidev.h.
    Protect these prototypes with an #ifdef so that building a comedi
    pcmcia driver without PCMCIA support will cause a build error. This
    will normally not happen as long as the comedi pcmcia driver is placed
    in the proper group in the Kconfig.
    
    Remove the #include <pcmcia/*.h> from drivers.c. These includes are only
    needed by the comedi pcmcia driver support code and the pcmcia drivers.
    The include should occur in those files.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 4e6e8a1700f5..151e0845569e 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -23,8 +23,6 @@
 
 #include <linux/device.h>
 #include <linux/module.h>
-#include <pcmcia/cistpl.h>
-#include <pcmcia/ds.h>
 #include <linux/errno.h>
 #include <linux/kconfig.h>
 #include <linux/kernel.h>
@@ -494,33 +492,3 @@ void comedi_auto_unconfig(struct device *hardware_device)
 	comedi_free_board_minor(minor);
 }
 EXPORT_SYMBOL_GPL(comedi_auto_unconfig);
-
-#if IS_ENABLED(CONFIG_PCMCIA)
-int comedi_pcmcia_driver_register(struct comedi_driver *comedi_driver,
-		struct pcmcia_driver *pcmcia_driver)
-{
-	int ret;
-
-	ret = comedi_driver_register(comedi_driver);
-	if (ret < 0)
-		return ret;
-
-	ret = pcmcia_register_driver(pcmcia_driver);
-	if (ret < 0) {
-		comedi_driver_unregister(comedi_driver);
-		return ret;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(comedi_pcmcia_driver_register);
-
-void comedi_pcmcia_driver_unregister(struct comedi_driver *comedi_driver,
-		struct pcmcia_driver *pcmcia_driver)
-{
-	pcmcia_unregister_driver(pcmcia_driver);
-	comedi_driver_unregister(comedi_driver);
-}
-EXPORT_SYMBOL_GPL(comedi_pcmcia_driver_unregister);
-
-#endif

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 86fcd3698216..4e6e8a1700f5 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -23,7 +23,6 @@
 
 #include <linux/device.h>
 #include <linux/module.h>
-#include <linux/pci.h>
 #include <pcmcia/cistpl.h>
 #include <pcmcia/ds.h>
 #include <linux/errno.h>
@@ -496,73 +495,6 @@ void comedi_auto_unconfig(struct device *hardware_device)
 }
 EXPORT_SYMBOL_GPL(comedi_auto_unconfig);
 
-/**
- * comedi_pci_enable() - Enable the PCI device and request the regions.
- * @pdev: pci_dev struct
- * @res_name: name for the requested reqource
- */
-int comedi_pci_enable(struct pci_dev *pdev, const char *res_name)
-{
-	int rc;
-
-	rc = pci_enable_device(pdev);
-	if (rc < 0)
-		return rc;
-
-	rc = pci_request_regions(pdev, res_name);
-	if (rc < 0)
-		pci_disable_device(pdev);
-
-	return rc;
-}
-EXPORT_SYMBOL_GPL(comedi_pci_enable);
-
-/**
- * comedi_pci_disable() - Release the regions and disable the PCI device.
- * @pdev: pci_dev struct
- *
- * This must be matched with a previous successful call to comedi_pci_enable().
- */
-void comedi_pci_disable(struct pci_dev *pdev)
-{
-	pci_release_regions(pdev);
-	pci_disable_device(pdev);
-}
-EXPORT_SYMBOL_GPL(comedi_pci_disable);
-
-int comedi_pci_driver_register(struct comedi_driver *comedi_driver,
-		struct pci_driver *pci_driver)
-{
-	int ret;
-
-	ret = comedi_driver_register(comedi_driver);
-	if (ret < 0)
-		return ret;
-
-	ret = pci_register_driver(pci_driver);
-	if (ret < 0) {
-		comedi_driver_unregister(comedi_driver);
-		return ret;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(comedi_pci_driver_register);
-
-void comedi_pci_driver_unregister(struct comedi_driver *comedi_driver,
-		struct pci_driver *pci_driver)
-{
-	pci_unregister_driver(pci_driver);
-	comedi_driver_unregister(comedi_driver);
-}
-EXPORT_SYMBOL_GPL(comedi_pci_driver_unregister);
-
-void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
-{
-	comedi_auto_unconfig(&pcidev->dev);
-}
-EXPORT_SYMBOL_GPL(comedi_pci_auto_unconfig);
-
 #if IS_ENABLED(CONFIG_PCMCIA)
 int comedi_pcmcia_driver_register(struct comedi_driver *comedi_driver,
 		struct pcmcia_driver *pcmcia_driver)

commit abac8b54a353b9a1ac7d09ff790812655f618896
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:21:49 2013 -0700

    staging: comedi: conditionally build in USB driver support
    
    Separate the comedi_usb_* functions out of drivers.c into a new
    source file, comedi_usb.c. This allows conditionally building
    support for comedi USB drivers into the comedi core without the
    need for the #if'defery. Fix the Kconfig and Makefile appropriately.
    For aesthetic reasons, add some whitespace to the Makefile to keep
    everything lined up.
    
    Group all the comedi_usb_* prototypes into one place in comedidev.h.
    Protect these prototypes with an #ifdef so that building a comedi
    usb driver without USB support will cause a build error. This will
    normally not happen as long as the comedi USB driver is placed in
    the proper group in the Kconfig.
    
    Remove the #include<linux/usb.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi USB driver support code and the
    USB drivers. The include should occur in those files.
    
    Removing the include of usb.h exposed a couple drivers that need
    <linux/interrupt.h> and <linux/sched.h>. Add the missing includes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 87eeee58bda7..86fcd3698216 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -26,7 +26,6 @@
 #include <linux/pci.h>
 #include <pcmcia/cistpl.h>
 #include <pcmcia/ds.h>
-#include <linux/usb.h>
 #include <linux/errno.h>
 #include <linux/kconfig.h>
 #include <linux/kernel.h>
@@ -593,34 +592,3 @@ void comedi_pcmcia_driver_unregister(struct comedi_driver *comedi_driver,
 EXPORT_SYMBOL_GPL(comedi_pcmcia_driver_unregister);
 
 #endif
-
-#if IS_ENABLED(CONFIG_USB)
-
-int comedi_usb_driver_register(struct comedi_driver *comedi_driver,
-		struct usb_driver *usb_driver)
-{
-	int ret;
-
-	ret = comedi_driver_register(comedi_driver);
-	if (ret < 0)
-		return ret;
-
-	ret = usb_register(usb_driver);
-	if (ret < 0) {
-		comedi_driver_unregister(comedi_driver);
-		return ret;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(comedi_usb_driver_register);
-
-void comedi_usb_driver_unregister(struct comedi_driver *comedi_driver,
-		struct usb_driver *usb_driver)
-{
-	usb_deregister(usb_driver);
-	comedi_driver_unregister(comedi_driver);
-}
-EXPORT_SYMBOL_GPL(comedi_usb_driver_unregister);
-
-#endif

commit c2f90a20c9166bf9effb064703903039a49324e3
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Wed Jan 23 00:03:30 2013 +0100

    staging/comedi: Move comedi_pci_auto_unconfig to drivers.c
    
    Since comedi_pci_auto_unconfig cannot be inlined anymore after
     staging/comedi: Use comedi_pci_auto_unconfig directly for
     pci_driver.remove
    is applied, it makes sense to move it drivers.c
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 1c7d4da9775a..87eeee58bda7 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -558,6 +558,12 @@ void comedi_pci_driver_unregister(struct comedi_driver *comedi_driver,
 }
 EXPORT_SYMBOL_GPL(comedi_pci_driver_unregister);
 
+void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
+{
+	comedi_auto_unconfig(&pcidev->dev);
+}
+EXPORT_SYMBOL_GPL(comedi_pci_auto_unconfig);
+
 #if IS_ENABLED(CONFIG_PCMCIA)
 int comedi_pcmcia_driver_register(struct comedi_driver *comedi_driver,
 		struct pcmcia_driver *pcmcia_driver)

commit de59c285a4787dfc2ac4f2546ef0082ae08754e2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 21 14:37:46 2013 -0700

    staging: comedi: drivers (core): remove BUG_ON in comedi_auto_unconfig()
    
    comedi_find_board_minor() will always return a ninor number between
    0 and < COMEDI_NUM_BOARD_MINORS, or -ENODEV if a minor is not found.
    
    Remove the unnecessary BUG_ON().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 7e8ee5dde3be..1c7d4da9775a 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -493,7 +493,6 @@ void comedi_auto_unconfig(struct device *hardware_device)
 	minor = comedi_find_board_minor(hardware_device);
 	if (minor < 0)
 		return;
-	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
 	comedi_free_board_minor(minor);
 }
 EXPORT_SYMBOL_GPL(comedi_auto_unconfig);

commit 57b71c3e6f4c8b944e6721d89ccb566aee439f97
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 21 14:37:15 2013 -0700

    staging: comedi: drivers (core): don't BUG_ON due to faulty drivers
    
    The postconfig for drivers that support async commands currently can
    BUG_ON if the subdevice was improperly configured by the driver.
    
    Change the BUG_ON so that a dev_warn() is output and the postconfig
    returns -EINVAL. This will prevent the comedi core from attaching to
    the faulty driver but does not BUG the kernel.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index e5fe2e1f83f7..7e8ee5dde3be 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -178,8 +178,16 @@ static int __comedi_device_postconfig_async(struct comedi_device *dev,
 	unsigned int buf_size;
 	int ret;
 
-	BUG_ON((s->subdev_flags & (SDF_CMD_READ | SDF_CMD_WRITE)) == 0);
-	BUG_ON(!s->do_cmdtest);
+	if ((s->subdev_flags & (SDF_CMD_READ | SDF_CMD_WRITE)) == 0) {
+		dev_warn(dev->class_dev,
+			 "async subdevices must support SDF_CMD_READ or SDF_CMD_WRITE\n");
+		return -EINVAL;
+	}
+	if (!s->do_cmdtest) {
+		dev_warn(dev->class_dev,
+			 "async subdevices must have a do_cmdtest() function\n");
+		return -EINVAL;
+	}
 
 	async = kzalloc(sizeof(*async), GFP_KERNEL);
 	if (!async) {

commit 40f58a65c9f6cbb540ec2db6ac9d963d402014c3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 21 14:36:40 2013 -0700

    staging: comedi: drivers (core): factor out async subdevice postconfig
    
    Factor the setup of an async subdevice out of postconfig(). This allows
    bringing the code back a couple indents and makes the postconfig a bit
    clearer.
    
    For aesthetic reasons, rename postconfig() to __comedi_device_postconfig().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 27a480044ed6..e5fe2e1f83f7 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -171,12 +171,50 @@ static int insn_rw_emulate_bits(struct comedi_device *dev,
 	return 1;
 }
 
-static int postconfig(struct comedi_device *dev)
+static int __comedi_device_postconfig_async(struct comedi_device *dev,
+					    struct comedi_subdevice *s)
+{
+	struct comedi_async *async;
+	unsigned int buf_size;
+	int ret;
+
+	BUG_ON((s->subdev_flags & (SDF_CMD_READ | SDF_CMD_WRITE)) == 0);
+	BUG_ON(!s->do_cmdtest);
+
+	async = kzalloc(sizeof(*async), GFP_KERNEL);
+	if (!async) {
+		dev_warn(dev->class_dev, "failed to allocate async struct\n");
+		return -ENOMEM;
+	}
+	init_waitqueue_head(&async->wait_head);
+	async->subdevice = s;
+	s->async = async;
+
+	async->max_bufsize = comedi_default_buf_maxsize_kb * 1024;
+	buf_size = comedi_default_buf_size_kb * 1024;
+	if (buf_size > async->max_bufsize)
+		buf_size = async->max_bufsize;
+
+	if (comedi_buf_alloc(dev, s, buf_size) < 0) {
+		dev_warn(dev->class_dev, "Buffer allocation failed\n");
+		return -ENOMEM;
+	}
+	if (s->buf_change) {
+		ret = s->buf_change(dev, s, buf_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	comedi_alloc_subdevice_minor(dev, s);
+
+	return 0;
+}
+
+static int __comedi_device_postconfig(struct comedi_device *dev)
 {
-	int i;
 	struct comedi_subdevice *s;
-	struct comedi_async *async = NULL;
 	int ret;
+	int i;
 
 	for (i = 0; i < dev->n_subdevices; i++) {
 		s = &dev->subdevices[i];
@@ -188,42 +226,9 @@ static int postconfig(struct comedi_device *dev)
 			s->len_chanlist = 1;
 
 		if (s->do_cmd) {
-			unsigned int buf_size;
-
-			BUG_ON((s->subdev_flags & (SDF_CMD_READ |
-						   SDF_CMD_WRITE)) == 0);
-			BUG_ON(!s->do_cmdtest);
-
-			async =
-			    kzalloc(sizeof(struct comedi_async), GFP_KERNEL);
-			if (async == NULL) {
-				dev_warn(dev->class_dev,
-					 "failed to allocate async struct\n");
-				return -ENOMEM;
-			}
-			init_waitqueue_head(&async->wait_head);
-			async->subdevice = s;
-			s->async = async;
-
-			async->max_bufsize =
-				comedi_default_buf_maxsize_kb * 1024;
-			buf_size = comedi_default_buf_size_kb * 1024;
-			if (buf_size > async->max_bufsize)
-				buf_size = async->max_bufsize;
-
-			async->prealloc_buf = NULL;
-			async->prealloc_bufsz = 0;
-			if (comedi_buf_alloc(dev, s, buf_size) < 0) {
-				dev_warn(dev->class_dev,
-					 "Buffer allocation failed\n");
-				return -ENOMEM;
-			}
-			if (s->buf_change) {
-				ret = s->buf_change(dev, s, buf_size);
-				if (ret < 0)
-					return ret;
-			}
-			comedi_alloc_subdevice_minor(dev, s);
+			ret = __comedi_device_postconfig_async(dev, s);
+			if (ret)
+				return ret;
 		}
 
 		if (!s->range_table && !s->range_table_list)
@@ -254,7 +259,7 @@ static int postconfig(struct comedi_device *dev)
 /* called with module refcount incremented, decrements it */
 static int comedi_device_postconfig(struct comedi_device *dev)
 {
-	int ret = postconfig(dev);
+	int ret = __comedi_device_postconfig(dev);
 	module_put(dev->driver->module);
 	if (ret < 0) {
 		__comedi_device_detach(dev);

commit 01fca37863afc312afaf79c56a565d8b69058561
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 21 14:36:11 2013 -0700

    staging: comedi: drivers (core): remove forward declarations
    
    Move a couple of the functions to avoid the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index cebdd9e8670f..27a480044ed6 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -45,14 +45,6 @@
 #include "comedidev.h"
 #include "comedi_internal.h"
 
-static int postconfig(struct comedi_device *dev);
-static int insn_rw_emulate_bits(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data);
-static void *comedi_recognize(struct comedi_driver *driv, const char *name);
-static void comedi_report_boards(struct comedi_driver *driv);
-static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s);
-
 struct comedi_driver *comedi_drivers;
 
 int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
@@ -131,121 +123,53 @@ void comedi_device_detach(struct comedi_device *dev)
 	__comedi_device_detach(dev);
 }
 
-/* do a little post-config cleanup */
-/* called with module refcount incremented, decrements it */
-static int comedi_device_postconfig(struct comedi_device *dev)
-{
-	int ret = postconfig(dev);
-	module_put(dev->driver->module);
-	if (ret < 0) {
-		__comedi_device_detach(dev);
-		return ret;
-	}
-	if (!dev->board_name) {
-		dev_warn(dev->class_dev, "BUG: dev->board_name=NULL\n");
-		dev->board_name = "BUG";
-	}
-	smp_wmb();
-	dev->attached = 1;
-	return 0;
-}
-
-int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct comedi_driver *driv;
-	int ret;
-
-	if (dev->attached)
-		return -EBUSY;
-
-	for (driv = comedi_drivers; driv; driv = driv->next) {
-		if (!try_module_get(driv->module))
-			continue;
-		if (driv->num_names) {
-			dev->board_ptr = comedi_recognize(driv, it->board_name);
-			if (dev->board_ptr)
-				break;
-		} else if (strcmp(driv->driver_name, it->board_name) == 0)
-			break;
-		module_put(driv->module);
-	}
-	if (driv == NULL) {
-		/*  recognize has failed if we get here */
-		/*  report valid board names before returning error */
-		for (driv = comedi_drivers; driv; driv = driv->next) {
-			if (!try_module_get(driv->module))
-				continue;
-			comedi_report_boards(driv);
-			module_put(driv->module);
-		}
-		return -EIO;
-	}
-	if (driv->attach == NULL) {
-		/* driver does not support manual configuration */
-		dev_warn(dev->class_dev,
-			 "driver '%s' does not support attach using comedi_config\n",
-			 driv->driver_name);
-		module_put(driv->module);
-		return -ENOSYS;
-	}
-	/* initialize dev->driver here so
-	 * comedi_error() can be called from attach */
-	dev->driver = driv;
-	ret = driv->attach(dev, it);
-	if (ret < 0) {
-		module_put(dev->driver->module);
-		__comedi_device_detach(dev);
-		return ret;
-	}
-	return comedi_device_postconfig(dev);
+	return -EINVAL;
 }
 
-int comedi_driver_register(struct comedi_driver *driver)
+int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
+	       struct comedi_insn *insn, unsigned int *data)
 {
-	driver->next = comedi_drivers;
-	comedi_drivers = driver;
-
-	return 0;
+	return -EINVAL;
 }
-EXPORT_SYMBOL(comedi_driver_register);
 
-int comedi_driver_unregister(struct comedi_driver *driver)
+static int insn_rw_emulate_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
-	struct comedi_driver *prev;
-	int i;
-
-	/* check for devices using this driver */
-	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
-		struct comedi_device *dev = comedi_dev_from_minor(i);
+	struct comedi_insn new_insn;
+	int ret;
+	static const unsigned channels_per_bitfield = 32;
 
-		if (!dev)
-			continue;
+	unsigned chan = CR_CHAN(insn->chanspec);
+	const unsigned base_bitfield_channel =
+	    (chan < channels_per_bitfield) ? 0 : chan;
+	unsigned int new_data[2];
+	memset(new_data, 0, sizeof(new_data));
+	memset(&new_insn, 0, sizeof(new_insn));
+	new_insn.insn = INSN_BITS;
+	new_insn.chanspec = base_bitfield_channel;
+	new_insn.n = 2;
+	new_insn.subdev = insn->subdev;
 
-		mutex_lock(&dev->mutex);
-		if (dev->attached && dev->driver == driver) {
-			if (dev->use_count)
-				dev_warn(dev->class_dev,
-					 "BUG! detaching device with use_count=%d\n",
-					 dev->use_count);
-			comedi_device_detach(dev);
-		}
-		mutex_unlock(&dev->mutex);
+	if (insn->insn == INSN_WRITE) {
+		if (!(s->subdev_flags & SDF_WRITABLE))
+			return -EINVAL;
+		new_data[0] = 1 << (chan - base_bitfield_channel); /* mask */
+		new_data[1] = data[0] ? (1 << (chan - base_bitfield_channel))
+			      : 0; /* bits */
 	}
 
-	if (comedi_drivers == driver) {
-		comedi_drivers = driver->next;
-		return 0;
-	}
+	ret = s->insn_bits(dev, s, &new_insn, new_data);
+	if (ret < 0)
+		return ret;
 
-	for (prev = comedi_drivers; prev->next; prev = prev->next) {
-		if (prev->next == driver) {
-			prev->next = driver->next;
-			return 0;
-		}
-	}
-	return -EINVAL;
+	if (insn->insn == INSN_READ)
+		data[0] = (new_data[1] >> (chan - base_bitfield_channel)) & 1;
+
+	return 1;
 }
-EXPORT_SYMBOL(comedi_driver_unregister);
 
 static int postconfig(struct comedi_device *dev)
 {
@@ -326,6 +250,25 @@ static int postconfig(struct comedi_device *dev)
 	return 0;
 }
 
+/* do a little post-config cleanup */
+/* called with module refcount incremented, decrements it */
+static int comedi_device_postconfig(struct comedi_device *dev)
+{
+	int ret = postconfig(dev);
+	module_put(dev->driver->module);
+	if (ret < 0) {
+		__comedi_device_detach(dev);
+		return ret;
+	}
+	if (!dev->board_name) {
+		dev_warn(dev->class_dev, "BUG: dev->board_name=NULL\n");
+		dev->board_name = "BUG";
+	}
+	smp_wmb();
+	dev->attached = 1;
+	return 0;
+}
+
 /*
  * Generic recognize function for drivers that register their supported
  * board names.
@@ -384,53 +327,102 @@ static void comedi_report_boards(struct comedi_driver *driv)
 		pr_info(" %s\n", driv->driver_name);
 }
 
-static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)
+int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	return -EINVAL;
+	struct comedi_driver *driv;
+	int ret;
+
+	if (dev->attached)
+		return -EBUSY;
+
+	for (driv = comedi_drivers; driv; driv = driv->next) {
+		if (!try_module_get(driv->module))
+			continue;
+		if (driv->num_names) {
+			dev->board_ptr = comedi_recognize(driv, it->board_name);
+			if (dev->board_ptr)
+				break;
+		} else if (strcmp(driv->driver_name, it->board_name) == 0)
+			break;
+		module_put(driv->module);
+	}
+	if (driv == NULL) {
+		/*  recognize has failed if we get here */
+		/*  report valid board names before returning error */
+		for (driv = comedi_drivers; driv; driv = driv->next) {
+			if (!try_module_get(driv->module))
+				continue;
+			comedi_report_boards(driv);
+			module_put(driv->module);
+		}
+		return -EIO;
+	}
+	if (driv->attach == NULL) {
+		/* driver does not support manual configuration */
+		dev_warn(dev->class_dev,
+			 "driver '%s' does not support attach using comedi_config\n",
+			 driv->driver_name);
+		module_put(driv->module);
+		return -ENOSYS;
+	}
+	/* initialize dev->driver here so
+	 * comedi_error() can be called from attach */
+	dev->driver = driv;
+	ret = driv->attach(dev, it);
+	if (ret < 0) {
+		module_put(dev->driver->module);
+		__comedi_device_detach(dev);
+		return ret;
+	}
+	return comedi_device_postconfig(dev);
 }
 
-int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
-	       struct comedi_insn *insn, unsigned int *data)
+int comedi_driver_register(struct comedi_driver *driver)
 {
-	return -EINVAL;
+	driver->next = comedi_drivers;
+	comedi_drivers = driver;
+
+	return 0;
 }
+EXPORT_SYMBOL(comedi_driver_register);
 
-static int insn_rw_emulate_bits(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+int comedi_driver_unregister(struct comedi_driver *driver)
 {
-	struct comedi_insn new_insn;
-	int ret;
-	static const unsigned channels_per_bitfield = 32;
+	struct comedi_driver *prev;
+	int i;
 
-	unsigned chan = CR_CHAN(insn->chanspec);
-	const unsigned base_bitfield_channel =
-	    (chan < channels_per_bitfield) ? 0 : chan;
-	unsigned int new_data[2];
-	memset(new_data, 0, sizeof(new_data));
-	memset(&new_insn, 0, sizeof(new_insn));
-	new_insn.insn = INSN_BITS;
-	new_insn.chanspec = base_bitfield_channel;
-	new_insn.n = 2;
-	new_insn.subdev = insn->subdev;
+	/* check for devices using this driver */
+	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
+		struct comedi_device *dev = comedi_dev_from_minor(i);
 
-	if (insn->insn == INSN_WRITE) {
-		if (!(s->subdev_flags & SDF_WRITABLE))
-			return -EINVAL;
-		new_data[0] = 1 << (chan - base_bitfield_channel); /* mask */
-		new_data[1] = data[0] ? (1 << (chan - base_bitfield_channel))
-			      : 0; /* bits */
-	}
+		if (!dev)
+			continue;
 
-	ret = s->insn_bits(dev, s, &new_insn, new_data);
-	if (ret < 0)
-		return ret;
+		mutex_lock(&dev->mutex);
+		if (dev->attached && dev->driver == driver) {
+			if (dev->use_count)
+				dev_warn(dev->class_dev,
+					 "BUG! detaching device with use_count=%d\n",
+					 dev->use_count);
+			comedi_device_detach(dev);
+		}
+		mutex_unlock(&dev->mutex);
+	}
 
-	if (insn->insn == INSN_READ)
-		data[0] = (new_data[1] >> (chan - base_bitfield_channel)) & 1;
+	if (comedi_drivers == driver) {
+		comedi_drivers = driver->next;
+		return 0;
+	}
 
-	return 1;
+	for (prev = comedi_drivers; prev->next; prev = prev->next) {
+		if (prev->next == driver) {
+			prev->next = driver->next;
+			return 0;
+		}
+	}
+	return -EINVAL;
 }
+EXPORT_SYMBOL(comedi_driver_unregister);
 
 int comedi_auto_config(struct device *hardware_device,
 		       struct comedi_driver *driver, unsigned long context)

commit 37fbb4acda89447b8b37e0cc5d1bd8f7ce9b1bb4
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Mon Jan 21 21:51:57 2013 +0100

    staging/comedi: remove workaround for !pci_driver.name
    
    All pci drivers in drivers/ have the pci_driver.name field set, so we
    can remove this workaround and the accompanying todo.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 8b681ac7b31d..cebdd9e8670f 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -536,10 +536,6 @@ int comedi_pci_driver_register(struct comedi_driver *comedi_driver,
 	if (ret < 0)
 		return ret;
 
-	/* FIXME: Remove this test after auditing all comedi pci drivers */
-	if (!pci_driver->name)
-		pci_driver->name = comedi_driver->driver_name;
-
 	ret = pci_register_driver(pci_driver);
 	if (ret < 0) {
 		comedi_driver_unregister(comedi_driver);

commit d607ffac4cbd22599f2b006465c722104cc1cd1b
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Mon Jan 14 22:00:48 2013 +0100

    staging/comedi: Add macro for registering a comedi PCMCIA driver
    
    This patch introduces a new macro 'module_comedi_pcmcia_driver'
    for comedi PCMCIA drivers which do not do anything special in module
    init/exit. This eliminates a lot of boilerplate.
    
    Adapted from 'module_comedi_pci_driver'
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index dca26f521fd0..8b681ac7b31d 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -24,6 +24,8 @@
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/pci.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
 #include <linux/usb.h>
 #include <linux/errno.h>
 #include <linux/kconfig.h>
@@ -556,6 +558,36 @@ void comedi_pci_driver_unregister(struct comedi_driver *comedi_driver,
 }
 EXPORT_SYMBOL_GPL(comedi_pci_driver_unregister);
 
+#if IS_ENABLED(CONFIG_PCMCIA)
+int comedi_pcmcia_driver_register(struct comedi_driver *comedi_driver,
+		struct pcmcia_driver *pcmcia_driver)
+{
+	int ret;
+
+	ret = comedi_driver_register(comedi_driver);
+	if (ret < 0)
+		return ret;
+
+	ret = pcmcia_register_driver(pcmcia_driver);
+	if (ret < 0) {
+		comedi_driver_unregister(comedi_driver);
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(comedi_pcmcia_driver_register);
+
+void comedi_pcmcia_driver_unregister(struct comedi_driver *comedi_driver,
+		struct pcmcia_driver *pcmcia_driver)
+{
+	pcmcia_unregister_driver(pcmcia_driver);
+	comedi_driver_unregister(comedi_driver);
+}
+EXPORT_SYMBOL_GPL(comedi_pcmcia_driver_unregister);
+
+#endif
+
 #if IS_ENABLED(CONFIG_USB)
 
 int comedi_usb_driver_register(struct comedi_driver *comedi_driver,

commit ea082fb1b0ee42b6430c83a6dc9d795381a87264
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 9 13:25:06 2013 -0700

    staging: comedi: separate out comedi_buf_* functions
    
    Create a new file, comedi_buf.c, to hold all the comedi_async buffer
    functions. Currently they are all in drivers.c and really don't have
    any association with that source file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index b67a0c9b149e..dca26f521fd0 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -430,404 +430,6 @@ static int insn_rw_emulate_bits(struct comedi_device *dev,
 	return 1;
 }
 
-int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
-		     unsigned long new_size)
-{
-	struct comedi_async *async = s->async;
-
-	/* Round up new_size to multiple of PAGE_SIZE */
-	new_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;
-
-	/* if no change is required, do nothing */
-	if (async->prealloc_buf && async->prealloc_bufsz == new_size)
-		return 0;
-
-	/*  deallocate old buffer */
-	if (async->prealloc_buf) {
-		vunmap(async->prealloc_buf);
-		async->prealloc_buf = NULL;
-		async->prealloc_bufsz = 0;
-	}
-	if (async->buf_page_list) {
-		unsigned i;
-		for (i = 0; i < async->n_buf_pages; ++i) {
-			if (async->buf_page_list[i].virt_addr) {
-				clear_bit(PG_reserved,
-					&(virt_to_page(async->buf_page_list[i].
-							virt_addr)->flags));
-				if (s->async_dma_dir != DMA_NONE) {
-					dma_free_coherent(dev->hw_dev,
-							  PAGE_SIZE,
-							  async->
-							  buf_page_list
-							  [i].virt_addr,
-							  async->
-							  buf_page_list
-							  [i].dma_addr);
-				} else {
-					free_page((unsigned long)
-						  async->buf_page_list[i].
-						  virt_addr);
-				}
-			}
-		}
-		vfree(async->buf_page_list);
-		async->buf_page_list = NULL;
-		async->n_buf_pages = 0;
-	}
-	/*  allocate new buffer */
-	if (new_size) {
-		unsigned i = 0;
-		unsigned n_pages = new_size >> PAGE_SHIFT;
-		struct page **pages = NULL;
-
-		async->buf_page_list =
-		    vzalloc(sizeof(struct comedi_buf_page) * n_pages);
-		if (async->buf_page_list)
-			pages = vmalloc(sizeof(struct page *) * n_pages);
-
-		if (pages) {
-			for (i = 0; i < n_pages; i++) {
-				if (s->async_dma_dir != DMA_NONE) {
-					async->buf_page_list[i].virt_addr =
-					    dma_alloc_coherent(dev->hw_dev,
-							       PAGE_SIZE,
-							       &async->
-							       buf_page_list
-							       [i].dma_addr,
-							       GFP_KERNEL |
-							       __GFP_COMP);
-				} else {
-					async->buf_page_list[i].virt_addr =
-					    (void *)
-					    get_zeroed_page(GFP_KERNEL);
-				}
-				if (async->buf_page_list[i].virt_addr == NULL)
-					break;
-
-				set_bit(PG_reserved,
-					&(virt_to_page(async->buf_page_list[i].
-							virt_addr)->flags));
-				pages[i] = virt_to_page(async->buf_page_list[i].
-								virt_addr);
-			}
-		}
-		if (i == n_pages) {
-			async->prealloc_buf =
-#ifdef PAGE_KERNEL_NOCACHE
-			    vmap(pages, n_pages, VM_MAP, PAGE_KERNEL_NOCACHE);
-#else
-			    vmap(pages, n_pages, VM_MAP, PAGE_KERNEL);
-#endif
-		}
-		vfree(pages);
-
-		if (async->prealloc_buf == NULL) {
-			/* Some allocation failed above. */
-			if (async->buf_page_list) {
-				for (i = 0; i < n_pages; i++) {
-					if (async->buf_page_list[i].virt_addr ==
-					    NULL) {
-						break;
-					}
-					clear_bit(PG_reserved,
-						&(virt_to_page(async->
-							buf_page_list[i].
-							virt_addr)->flags));
-					if (s->async_dma_dir != DMA_NONE) {
-						dma_free_coherent(dev->hw_dev,
-								  PAGE_SIZE,
-								  async->
-								  buf_page_list
-								  [i].virt_addr,
-								  async->
-								  buf_page_list
-								  [i].dma_addr);
-					} else {
-						free_page((unsigned long)
-							  async->buf_page_list
-							  [i].virt_addr);
-					}
-				}
-				vfree(async->buf_page_list);
-				async->buf_page_list = NULL;
-			}
-			return -ENOMEM;
-		}
-		async->n_buf_pages = n_pages;
-	}
-	async->prealloc_bufsz = new_size;
-
-	return 0;
-}
-
-/* munging is applied to data by core as it passes between user
- * and kernel space */
-static unsigned int comedi_buf_munge(struct comedi_async *async,
-				     unsigned int num_bytes)
-{
-	struct comedi_subdevice *s = async->subdevice;
-	unsigned int count = 0;
-	const unsigned num_sample_bytes = bytes_per_sample(s);
-
-	if (s->munge == NULL || (async->cmd.flags & CMDF_RAWDATA)) {
-		async->munge_count += num_bytes;
-		BUG_ON((int)(async->munge_count - async->buf_write_count) > 0);
-		return num_bytes;
-	}
-	/* don't munge partial samples */
-	num_bytes -= num_bytes % num_sample_bytes;
-	while (count < num_bytes) {
-		int block_size;
-
-		block_size = num_bytes - count;
-		if (block_size < 0) {
-			dev_warn(s->device->class_dev,
-				 "%s: %s: bug! block_size is negative\n",
-				 __FILE__, __func__);
-			break;
-		}
-		if ((int)(async->munge_ptr + block_size -
-			  async->prealloc_bufsz) > 0)
-			block_size = async->prealloc_bufsz - async->munge_ptr;
-
-		s->munge(s->device, s, async->prealloc_buf + async->munge_ptr,
-			 block_size, async->munge_chan);
-
-		smp_wmb();	/* barrier insures data is munged in buffer
-				 * before munge_count is incremented */
-
-		async->munge_chan += block_size / num_sample_bytes;
-		async->munge_chan %= async->cmd.chanlist_len;
-		async->munge_count += block_size;
-		async->munge_ptr += block_size;
-		async->munge_ptr %= async->prealloc_bufsz;
-		count += block_size;
-	}
-	BUG_ON((int)(async->munge_count - async->buf_write_count) > 0);
-	return count;
-}
-
-unsigned int comedi_buf_write_n_available(struct comedi_async *async)
-{
-	unsigned int free_end;
-	unsigned int nbytes;
-
-	if (async == NULL)
-		return 0;
-
-	free_end = async->buf_read_count + async->prealloc_bufsz;
-	nbytes = free_end - async->buf_write_alloc_count;
-	nbytes -= nbytes % bytes_per_sample(async->subdevice);
-	/* barrier insures the read of buf_read_count in this
-	   query occurs before any following writes to the buffer which
-	   might be based on the return value from this query.
-	 */
-	smp_mb();
-	return nbytes;
-}
-
-/* allocates chunk for the writer from free buffer space */
-unsigned int comedi_buf_write_alloc(struct comedi_async *async,
-				    unsigned int nbytes)
-{
-	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
-
-	if ((int)(async->buf_write_alloc_count + nbytes - free_end) > 0)
-		nbytes = free_end - async->buf_write_alloc_count;
-
-	async->buf_write_alloc_count += nbytes;
-	/* barrier insures the read of buf_read_count above occurs before
-	   we write data to the write-alloc'ed buffer space */
-	smp_mb();
-	return nbytes;
-}
-EXPORT_SYMBOL(comedi_buf_write_alloc);
-
-/* allocates nothing unless it can completely fulfill the request */
-unsigned int comedi_buf_write_alloc_strict(struct comedi_async *async,
-					   unsigned int nbytes)
-{
-	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
-
-	if ((int)(async->buf_write_alloc_count + nbytes - free_end) > 0)
-		nbytes = 0;
-
-	async->buf_write_alloc_count += nbytes;
-	/* barrier insures the read of buf_read_count above occurs before
-	   we write data to the write-alloc'ed buffer space */
-	smp_mb();
-	return nbytes;
-}
-
-/* transfers a chunk from writer to filled buffer space */
-unsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes)
-{
-	if ((int)(async->buf_write_count + nbytes -
-		  async->buf_write_alloc_count) > 0) {
-		dev_info(async->subdevice->device->class_dev,
-			 "attempted to write-free more bytes than have been write-allocated.\n");
-		nbytes = async->buf_write_alloc_count - async->buf_write_count;
-	}
-	async->buf_write_count += nbytes;
-	async->buf_write_ptr += nbytes;
-	comedi_buf_munge(async, async->buf_write_count - async->munge_count);
-	if (async->buf_write_ptr >= async->prealloc_bufsz)
-		async->buf_write_ptr %= async->prealloc_bufsz;
-
-	return nbytes;
-}
-EXPORT_SYMBOL(comedi_buf_write_free);
-
-/* allocates a chunk for the reader from filled (and munged) buffer space */
-unsigned comedi_buf_read_alloc(struct comedi_async *async, unsigned nbytes)
-{
-	if ((int)(async->buf_read_alloc_count + nbytes - async->munge_count) >
-	    0) {
-		nbytes = async->munge_count - async->buf_read_alloc_count;
-	}
-	async->buf_read_alloc_count += nbytes;
-	/* barrier insures read of munge_count occurs before we actually read
-	   data out of buffer */
-	smp_rmb();
-	return nbytes;
-}
-EXPORT_SYMBOL(comedi_buf_read_alloc);
-
-/* transfers control of a chunk from reader to free buffer space */
-unsigned comedi_buf_read_free(struct comedi_async *async, unsigned int nbytes)
-{
-	/* barrier insures data has been read out of
-	 * buffer before read count is incremented */
-	smp_mb();
-	if ((int)(async->buf_read_count + nbytes -
-		  async->buf_read_alloc_count) > 0) {
-		dev_info(async->subdevice->device->class_dev,
-			 "attempted to read-free more bytes than have been read-allocated.\n");
-		nbytes = async->buf_read_alloc_count - async->buf_read_count;
-	}
-	async->buf_read_count += nbytes;
-	async->buf_read_ptr += nbytes;
-	async->buf_read_ptr %= async->prealloc_bufsz;
-	return nbytes;
-}
-EXPORT_SYMBOL(comedi_buf_read_free);
-
-void comedi_buf_memcpy_to(struct comedi_async *async, unsigned int offset,
-			  const void *data, unsigned int num_bytes)
-{
-	unsigned int write_ptr = async->buf_write_ptr + offset;
-
-	if (write_ptr >= async->prealloc_bufsz)
-		write_ptr %= async->prealloc_bufsz;
-
-	while (num_bytes) {
-		unsigned int block_size;
-
-		if (write_ptr + num_bytes > async->prealloc_bufsz)
-			block_size = async->prealloc_bufsz - write_ptr;
-		else
-			block_size = num_bytes;
-
-		memcpy(async->prealloc_buf + write_ptr, data, block_size);
-
-		data += block_size;
-		num_bytes -= block_size;
-
-		write_ptr = 0;
-	}
-}
-EXPORT_SYMBOL(comedi_buf_memcpy_to);
-
-void comedi_buf_memcpy_from(struct comedi_async *async, unsigned int offset,
-			    void *dest, unsigned int nbytes)
-{
-	void *src;
-	unsigned int read_ptr = async->buf_read_ptr + offset;
-
-	if (read_ptr >= async->prealloc_bufsz)
-		read_ptr %= async->prealloc_bufsz;
-
-	while (nbytes) {
-		unsigned int block_size;
-
-		src = async->prealloc_buf + read_ptr;
-
-		if (nbytes >= async->prealloc_bufsz - read_ptr)
-			block_size = async->prealloc_bufsz - read_ptr;
-		else
-			block_size = nbytes;
-
-		memcpy(dest, src, block_size);
-		nbytes -= block_size;
-		dest += block_size;
-		read_ptr = 0;
-	}
-}
-EXPORT_SYMBOL(comedi_buf_memcpy_from);
-
-unsigned int comedi_buf_read_n_available(struct comedi_async *async)
-{
-	unsigned num_bytes;
-
-	if (async == NULL)
-		return 0;
-	num_bytes = async->munge_count - async->buf_read_count;
-	/* barrier insures the read of munge_count in this
-	   query occurs before any following reads of the buffer which
-	   might be based on the return value from this query.
-	 */
-	smp_rmb();
-	return num_bytes;
-}
-EXPORT_SYMBOL(comedi_buf_read_n_available);
-
-int comedi_buf_get(struct comedi_async *async, short *x)
-{
-	unsigned int n = comedi_buf_read_n_available(async);
-
-	if (n < sizeof(short))
-		return 0;
-	comedi_buf_read_alloc(async, sizeof(short));
-	*x = *(short *)(async->prealloc_buf + async->buf_read_ptr);
-	comedi_buf_read_free(async, sizeof(short));
-	return 1;
-}
-EXPORT_SYMBOL(comedi_buf_get);
-
-int comedi_buf_put(struct comedi_async *async, short x)
-{
-	unsigned int n = comedi_buf_write_alloc_strict(async, sizeof(short));
-
-	if (n < sizeof(short)) {
-		async->events |= COMEDI_CB_ERROR;
-		return 0;
-	}
-	*(short *)(async->prealloc_buf + async->buf_write_ptr) = x;
-	comedi_buf_write_free(async, sizeof(short));
-	return 1;
-}
-EXPORT_SYMBOL(comedi_buf_put);
-
-void comedi_reset_async_buf(struct comedi_async *async)
-{
-	async->buf_write_alloc_count = 0;
-	async->buf_write_count = 0;
-	async->buf_read_alloc_count = 0;
-	async->buf_read_count = 0;
-
-	async->buf_write_ptr = 0;
-	async->buf_read_ptr = 0;
-
-	async->cur_chan = 0;
-	async->scan_progress = 0;
-	async->munge_chan = 0;
-	async->munge_count = 0;
-	async->munge_ptr = 0;
-
-	async->events = 0;
-}
-
 int comedi_auto_config(struct device *hardware_device,
 		       struct comedi_driver *driver, unsigned long context)
 {

commit 90a35c15c5d7d5c6254772d2752975dda185710c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 17:27:02 2012 -0700

    staging: comedi: store the 'index' for each subdevice
    
    Store the 'index' for each comedi_subdevice when they are initially
    allocated by comedi_alloc_subdevice(). This allows removing the
    pointer math in comedi_fops.c which is used to figure out the
    index that user space uses to access the individual subdevices.
    
    Fix the ni_mio_common driver so it also uses the 'index' instead
    of doing the pointer math.
    
    Also, remove a couple unused macros in the pcmda12, pcmmio, and
    pcmuio drivers which also do the pointer math to figure out the
    index.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index c0adc166d2b4..b67a0c9b149e 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -70,6 +70,7 @@ int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 	for (i = 0; i < num_subdevices; ++i) {
 		s = &dev->subdevices[i];
 		s->device = dev;
+		s->index = i;
 		s->async_dma_dir = DMA_NONE;
 		spin_lock_init(&s->spin_lock);
 		s->minor = -1;

commit 4da5fa9a439fda3019585aecab44462fd641b6f8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:35:23 2012 -0700

    staging: comedi: use comedi_dev_from_minor()
    
    Remove the need to export comedi_get_device_file_info() by using the
    new helper comedi_dev_from_minor(). This will also allow us to make
    the comedi_device_file_info struct private.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 50cf498698e2..c0adc166d2b4 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -213,13 +213,10 @@ int comedi_driver_unregister(struct comedi_driver *driver)
 
 	/* check for devices using this driver */
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
-		struct comedi_device_file_info *dev_file_info =
-		    comedi_get_device_file_info(i);
-		struct comedi_device *dev;
+		struct comedi_device *dev = comedi_dev_from_minor(i);
 
-		if (dev_file_info == NULL)
+		if (!dev)
 			continue;
-		dev = dev_file_info->device;
 
 		mutex_lock(&dev->mutex);
 		if (dev->attached && dev->driver == driver) {
@@ -834,7 +831,6 @@ int comedi_auto_config(struct device *hardware_device,
 		       struct comedi_driver *driver, unsigned long context)
 {
 	int minor;
-	struct comedi_device_file_info *dev_file_info;
 	struct comedi_device *comedi_dev;
 	int ret;
 
@@ -852,8 +848,7 @@ int comedi_auto_config(struct device *hardware_device,
 	if (minor < 0)
 		return minor;
 
-	dev_file_info = comedi_get_device_file_info(minor);
-	comedi_dev = dev_file_info->device;
+	comedi_dev = comedi_dev_from_minor(minor);
 
 	mutex_lock(&comedi_dev->mutex);
 	if (comedi_dev->attached)

commit 1b6c710e2a0f636aa038dc80dc114edf8217f5e6
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Nov 26 17:34:29 2012 -0700

    staging: comedi: remove unnecessary '#define __NO_VERSION__'
    
    This define is no longer required for multi-file modules.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 7a507a4c147d..50cf498698e2 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -21,7 +21,6 @@
 
 */
 
-#define __NO_VERSION__
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/pci.h>

commit 1be287f9dba0e2d5f94edaa54ecda957d1274c7f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Nov 26 17:34:11 2012 -0700

    staging: comedi: remove unnecessary '#define _GNU_SOURCE'
    
    This define is not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 7175c302b0c0..7a507a4c147d 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -21,8 +21,6 @@
 
 */
 
-#define _GNU_SOURCE
-
 #define __NO_VERSION__
 #include <linux/device.h>
 #include <linux/module.h>

commit 581a7ddec13d8f08b308c4764090bf57b0254f6f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 14 13:10:40 2012 +0000

    staging: comedi: use inlines for PCI/USB auto config
    
    Apart from the somewhat unnecessary `BUG_ON()` calls,
    `comedi_pci_auto_config()` and `comedi_usb_auto_config()` are just
    one-line wrappers around `comedi_auto_config()`, and
    `comedi_pci_auto_unconfig()` and `comedi_usb_auto_unconfig()` are just
    one-line wrappers around `comedi_auto_unconfig()`.  Convert them to
    inline functions and remove the `BUG_ON()` calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 8de9a24d9ad9..7175c302b0c0 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -930,18 +930,6 @@ void comedi_pci_disable(struct pci_dev *pdev)
 }
 EXPORT_SYMBOL_GPL(comedi_pci_disable);
 
-int comedi_pci_auto_config(struct pci_dev *pcidev, struct comedi_driver *driver)
-{
-	return comedi_auto_config(&pcidev->dev, driver, 0);
-}
-EXPORT_SYMBOL_GPL(comedi_pci_auto_config);
-
-void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
-{
-	comedi_auto_unconfig(&pcidev->dev);
-}
-EXPORT_SYMBOL_GPL(comedi_pci_auto_unconfig);
-
 int comedi_pci_driver_register(struct comedi_driver *comedi_driver,
 		struct pci_driver *pci_driver)
 {
@@ -975,21 +963,6 @@ EXPORT_SYMBOL_GPL(comedi_pci_driver_unregister);
 
 #if IS_ENABLED(CONFIG_USB)
 
-int comedi_usb_auto_config(struct usb_interface *intf,
-			   struct comedi_driver *driver)
-{
-	BUG_ON(intf == NULL);
-	return comedi_auto_config(&intf->dev, driver, 0);
-}
-EXPORT_SYMBOL_GPL(comedi_usb_auto_config);
-
-void comedi_usb_auto_unconfig(struct usb_interface *intf)
-{
-	BUG_ON(intf == NULL);
-	comedi_auto_unconfig(&intf->dev);
-}
-EXPORT_SYMBOL_GPL(comedi_usb_auto_unconfig);
-
 int comedi_usb_driver_register(struct comedi_driver *comedi_driver,
 		struct usb_driver *usb_driver)
 {

commit a588da1d5aac72801df0c83075225a6074c81ac5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 14 13:10:38 2012 +0000

    staging: comedi: simplify comedi_auto_attach()
    
    `comedi_auto_config()` just calls internal function
    `comedi_auto_config_helper()`, passing it a wrapper function
    `comedi_auto_config_wrapper()` to handle the specifics of checking and
    calling the low-level comedi driver's `auto_attach()` handler.
    
    Since there are no other callers of `comedi_auto_config_helper()` or
    `comedi_auto_config_wrapper()`, combine everything into the single
    exported function `comedi_auto_config()`.
    
    Change the ordering of the check for existence of the low-level comedi
    driver's `auto_attach()` handler and the allocation of the comedi minor
    device number.  This means the log message warning of the absence of the
    handler now has to be refer to the hardware device instead of the
    not-yet-allocated comedi device.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index d27425eb9771..8de9a24d9ad9 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -833,12 +833,8 @@ void comedi_reset_async_buf(struct comedi_async *async)
 	async->events = 0;
 }
 
-static int
-comedi_auto_config_helper(struct device *hardware_device,
-			  struct comedi_driver *driver,
-			  int (*attach_wrapper) (struct comedi_device *,
-						 unsigned long),
-			  unsigned long context)
+int comedi_auto_config(struct device *hardware_device,
+		       struct comedi_driver *driver, unsigned long context)
 {
 	int minor;
 	struct comedi_device_file_info *dev_file_info;
@@ -848,6 +844,13 @@ comedi_auto_config_helper(struct device *hardware_device,
 	if (!comedi_autoconfig)
 		return 0;
 
+	if (!driver->auto_attach) {
+		dev_warn(hardware_device,
+			 "BUG! comedi driver '%s' has no auto_attach handler\n",
+			 driver->driver_name);
+		return -EINVAL;
+	}
+
 	minor = comedi_alloc_board_minor(hardware_device);
 	if (minor < 0)
 		return minor;
@@ -862,9 +865,8 @@ comedi_auto_config_helper(struct device *hardware_device,
 		ret = -EIO;
 	else {
 		comedi_set_hw_dev(comedi_dev, hardware_device);
-		/* set comedi_dev->driver here for attach wrapper */
 		comedi_dev->driver = driver;
-		ret = (*attach_wrapper)(comedi_dev, context);
+		ret = driver->auto_attach(comedi_dev, context);
 		if (ret < 0) {
 			module_put(driver->module);
 			__comedi_device_detach(comedi_dev);
@@ -878,25 +880,6 @@ comedi_auto_config_helper(struct device *hardware_device,
 		comedi_free_board_minor(minor);
 	return ret;
 }
-
-static int comedi_auto_config_wrapper(struct comedi_device *dev,
-				      unsigned long context)
-{
-	if (!dev->driver->auto_attach) {
-		dev_warn(dev->class_dev,
-			 "BUG! driver '%s' has no auto_attach handler\n",
-			 dev->driver->driver_name);
-		return -EINVAL;
-	}
-	return dev->driver->auto_attach(dev, context);
-}
-
-int comedi_auto_config(struct device *hardware_device,
-		       struct comedi_driver *driver, unsigned long context)
-{
-	return comedi_auto_config_helper(hardware_device, driver,
-					 comedi_auto_config_wrapper, context);
-}
 EXPORT_SYMBOL_GPL(comedi_auto_config);
 
 void comedi_auto_unconfig(struct device *hardware_device)

commit af448aca8fa41789aec8a968a56ed0868c803a2b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 14 13:10:37 2012 +0000

    staging: comedi: don't check driver->auto_attach
    
    There is no need for `comedi_pci_auto_config()` and
    `comedi_usb_auto_config()` to check that `driver->auto_attach` is
    non-null before calling `comedi_auto_attach()` as this check is done by
    `comedi_auto_config()` itself (actually by
    `comedi_auto_config_wrapper()`).  Remove the unnecessary checks.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 047c1d911c8d..d27425eb9771 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -949,11 +949,7 @@ EXPORT_SYMBOL_GPL(comedi_pci_disable);
 
 int comedi_pci_auto_config(struct pci_dev *pcidev, struct comedi_driver *driver)
 {
-
-	if (driver->auto_attach)
-		return comedi_auto_config(&pcidev->dev, driver, 0);
-	else
-		return -EINVAL;
+	return comedi_auto_config(&pcidev->dev, driver, 0);
 }
 EXPORT_SYMBOL_GPL(comedi_pci_auto_config);
 
@@ -1000,10 +996,7 @@ int comedi_usb_auto_config(struct usb_interface *intf,
 			   struct comedi_driver *driver)
 {
 	BUG_ON(intf == NULL);
-	if (driver->auto_attach)
-		return comedi_auto_config(&intf->dev, driver, 0);
-	else
-		return -EINVAL;
+	return comedi_auto_config(&intf->dev, driver, 0);
 }
 EXPORT_SYMBOL_GPL(comedi_usb_auto_config);
 

commit 45d6f1965e9a8b830dd69b98cf8d45de53394ee5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 14 13:10:36 2012 +0000

    staging: comedi: don't call attach_usb handler
    
    All the Comedi drivers that call `comedi_usb_auto_config()` have
    replaced the `attach_usb()` handler in their `struct comedi_driver` with
    a `auto_attach()` handler, so there is no need to check for the
    existence of the `attach_usb()` handler any more.  Remove this check and
    the code that calls it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index f780d38d6da0..047c1d911c8d 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -996,27 +996,11 @@ EXPORT_SYMBOL_GPL(comedi_pci_driver_unregister);
 
 #if IS_ENABLED(CONFIG_USB)
 
-static int comedi_usb_attach_wrapper(struct comedi_device *dev,
-				     unsigned long context)
-{
-	return dev->driver->attach_usb(dev, (struct usb_interface *)context);
-}
-
-static int comedi_new_usb_auto_config(struct usb_interface *intf,
-				      struct comedi_driver *driver)
-{
-	return comedi_auto_config_helper(&intf->dev, driver,
-					 comedi_usb_attach_wrapper,
-					 (unsigned long)intf);
-}
-
 int comedi_usb_auto_config(struct usb_interface *intf,
 			   struct comedi_driver *driver)
 {
 	BUG_ON(intf == NULL);
-	if (driver->attach_usb)
-		return comedi_new_usb_auto_config(intf, driver);
-	else if (driver->auto_attach)
+	if (driver->auto_attach)
 		return comedi_auto_config(&intf->dev, driver, 0);
 	else
 		return -EINVAL;

commit a692e9743a7b2085afbca2f7e50a449c3e205cc0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 14 13:10:35 2012 +0000

    staging: comedi: don't call attach_pci handler
    
    All the Comedi drivers that call `comedi_pci_auto_config()` have
    replaced the `attach_pci()` handler in their `struct comedi_driver` with
    a `auto_attach()` handler, so there is no need to check for the
    existence of the `attach_pci()` handler any more.  Remove this check and
    the code that calls it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index d8c3cd32f452..f780d38d6da0 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -947,26 +947,10 @@ void comedi_pci_disable(struct pci_dev *pdev)
 }
 EXPORT_SYMBOL_GPL(comedi_pci_disable);
 
-static int comedi_pci_attach_wrapper(struct comedi_device *dev,
-				     unsigned long context)
-{
-	return dev->driver->attach_pci(dev, (struct pci_dev *)context);
-}
-
-static int comedi_new_pci_auto_config(struct pci_dev *pcidev,
-				      struct comedi_driver *driver)
-{
-	return comedi_auto_config_helper(&pcidev->dev, driver,
-					 comedi_pci_attach_wrapper,
-					 (unsigned long)pcidev);
-}
-
 int comedi_pci_auto_config(struct pci_dev *pcidev, struct comedi_driver *driver)
 {
 
-	if (driver->attach_pci)
-		return comedi_new_pci_auto_config(pcidev, driver);
-	else if (driver->auto_attach)
+	if (driver->auto_attach)
 		return comedi_auto_config(&pcidev->dev, driver, 0);
 	else
 		return -EINVAL;

commit 847d74a26010e9bae51299b7c1008c5ec9a349f4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 14 13:10:34 2012 +0000

    staging: comedi: remove old auto-config
    
    All the Comedi drivers that call `comedi_pci_auto_config()` or
    `comedi_usb_auto_config()` define a `auto_attach()` handler in their
    `struct comedi_driver`.  There is no need to fall back to abusing the
    `attach()` handler any more, so remove the code that supports that.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index adae25643b1b..d8c3cd32f452 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -879,49 +879,6 @@ comedi_auto_config_helper(struct device *hardware_device,
 	return ret;
 }
 
-static int comedi_old_auto_config_wrapper(struct comedi_device *dev,
-					  unsigned long context)
-{
-	struct comedi_devconfig *it = (struct comedi_devconfig *)context;
-	struct comedi_driver *driv = dev->driver;
-
-	if (driv->num_names) {
-		/* look for generic board entry matching driver name, which
-		 * has already been copied to it->board_name */
-		dev->board_ptr = comedi_recognize(driv, it->board_name);
-		if (dev->board_ptr == NULL) {
-			dev_warn(dev->class_dev,
-				 "auto config failed to find board entry '%s' for driver '%s'\n",
-				 it->board_name, driv->driver_name);
-			comedi_report_boards(driv);
-			return -EINVAL;
-		}
-	}
-	if (!driv->attach) {
-		dev_warn(dev->class_dev,
-			 "BUG! driver '%s' using old-style auto config but has no attach handler\n",
-			 driv->driver_name);
-		return -EINVAL;
-	}
-	return driv->attach(dev, it);
-}
-
-static int comedi_old_auto_config(struct device *hardware_device,
-				  struct comedi_driver *driver,
-				  const int *options, unsigned num_options)
-{
-	struct comedi_devconfig it;
-
-	memset(&it, 0, sizeof(it));
-	strncpy(it.board_name, driver->driver_name, COMEDI_NAMELEN);
-	it.board_name[COMEDI_NAMELEN - 1] = '\0';
-	BUG_ON(num_options > COMEDI_NDEVCONFOPTS);
-	memcpy(it.options, options, num_options * sizeof(int));
-	return comedi_auto_config_helper(hardware_device, driver,
-					 comedi_old_auto_config_wrapper,
-					 (unsigned long)&it);
-}
-
 static int comedi_auto_config_wrapper(struct comedi_device *dev,
 				      unsigned long context)
 {
@@ -990,20 +947,6 @@ void comedi_pci_disable(struct pci_dev *pdev)
 }
 EXPORT_SYMBOL_GPL(comedi_pci_disable);
 
-static int comedi_old_pci_auto_config(struct pci_dev *pcidev,
-				      struct comedi_driver *driver)
-{
-	int options[2];
-
-	/*  pci bus */
-	options[0] = pcidev->bus->number;
-	/*  pci slot */
-	options[1] = PCI_SLOT(pcidev->devfn);
-
-	return comedi_old_auto_config(&pcidev->dev, driver,
-				      options, ARRAY_SIZE(options));
-}
-
 static int comedi_pci_attach_wrapper(struct comedi_device *dev,
 				     unsigned long context)
 {
@@ -1026,7 +969,7 @@ int comedi_pci_auto_config(struct pci_dev *pcidev, struct comedi_driver *driver)
 	else if (driver->auto_attach)
 		return comedi_auto_config(&pcidev->dev, driver, 0);
 	else
-		return comedi_old_pci_auto_config(pcidev, driver);
+		return -EINVAL;
 }
 EXPORT_SYMBOL_GPL(comedi_pci_auto_config);
 
@@ -1069,12 +1012,6 @@ EXPORT_SYMBOL_GPL(comedi_pci_driver_unregister);
 
 #if IS_ENABLED(CONFIG_USB)
 
-static int comedi_old_usb_auto_config(struct usb_interface *intf,
-				      struct comedi_driver *driver)
-{
-	return comedi_old_auto_config(&intf->dev, driver, NULL, 0);
-}
-
 static int comedi_usb_attach_wrapper(struct comedi_device *dev,
 				     unsigned long context)
 {
@@ -1098,7 +1035,7 @@ int comedi_usb_auto_config(struct usb_interface *intf,
 	else if (driver->auto_attach)
 		return comedi_auto_config(&intf->dev, driver, 0);
 	else
-		return comedi_old_usb_auto_config(intf, driver);
+		return -EINVAL;
 }
 EXPORT_SYMBOL_GPL(comedi_usb_auto_config);
 

commit d5121914a22c22d849abb57d086fe408c9ca2c0c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Sat Oct 27 21:44:15 2012 +0100

    staging: comedi: support auto_attach() for PCI and USB
    
    Allow `comedi_pci_auto_config()` and `comedi_usb_auto_config()` to use
    the new `auto_attach()` hook in the low-level driver's `struct
    comedi_driver` if it is set and the `attach_pci()` or `attach_usb()`
    hook (for PCI or USB respectively) is `NULL`.
    
    Eventually, the `auto_attach()` hook will be the only way of
    auto-configuring hardware devices as comedi devices and the bus-type
    specific `attach_pci()` and `attach_usb()` hooks will be removed.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index d60fa551a535..adae25643b1b 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -1023,6 +1023,8 @@ int comedi_pci_auto_config(struct pci_dev *pcidev, struct comedi_driver *driver)
 
 	if (driver->attach_pci)
 		return comedi_new_pci_auto_config(pcidev, driver);
+	else if (driver->auto_attach)
+		return comedi_auto_config(&pcidev->dev, driver, 0);
 	else
 		return comedi_old_pci_auto_config(pcidev, driver);
 }
@@ -1093,6 +1095,8 @@ int comedi_usb_auto_config(struct usb_interface *intf,
 	BUG_ON(intf == NULL);
 	if (driver->attach_usb)
 		return comedi_new_usb_auto_config(intf, driver);
+	else if (driver->auto_attach)
+		return comedi_auto_config(&intf->dev, driver, 0);
 	else
 		return comedi_old_usb_auto_config(intf, driver);
 }

commit 8ed705aff0652fdbd2c6b406155d7d480e1aabe0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Sat Oct 27 21:44:14 2012 +0100

    staging: comedi: add generic auto-config functions
    
    Add (and export) generic auto-config function `comedi_auto_config()` to
    allow hardware devices on arbitrary bus types (e.g. platform devices,
    spi devices, etc.) to be auto-configured as comedi devices.  This uses a
    new `auto_attach()` hook in the `struct comedi_driver`.  This new hook
    will eventually replace the bus-specific `attach_pci()` and
    `attach_usb()` hooks in the low-level comedi drivers.
    
    When the `auto_attach()` hook is called in the low-level driver, the
    `hw_dev` member of the `struct comedi_device` will have already been set
    to the hardware device passed to `comedi_auto_config()`.  The low-level
    driver can convert this to some bus-device wrapper structure pointer,
    possibly with the help of the `context` parameter that is passed
    unchanged from the `comedi_auto_config()` call.
    
    Also export the existing `comedi_auto_unconfig()` function as the
    matching call to `comedi_auto_config()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 4e61f5bd6792..d60fa551a535 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -922,7 +922,27 @@ static int comedi_old_auto_config(struct device *hardware_device,
 					 (unsigned long)&it);
 }
 
-static void comedi_auto_unconfig(struct device *hardware_device)
+static int comedi_auto_config_wrapper(struct comedi_device *dev,
+				      unsigned long context)
+{
+	if (!dev->driver->auto_attach) {
+		dev_warn(dev->class_dev,
+			 "BUG! driver '%s' has no auto_attach handler\n",
+			 dev->driver->driver_name);
+		return -EINVAL;
+	}
+	return dev->driver->auto_attach(dev, context);
+}
+
+int comedi_auto_config(struct device *hardware_device,
+		       struct comedi_driver *driver, unsigned long context)
+{
+	return comedi_auto_config_helper(hardware_device, driver,
+					 comedi_auto_config_wrapper, context);
+}
+EXPORT_SYMBOL_GPL(comedi_auto_config);
+
+void comedi_auto_unconfig(struct device *hardware_device)
 {
 	int minor;
 
@@ -934,6 +954,7 @@ static void comedi_auto_unconfig(struct device *hardware_device)
 	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
 	comedi_free_board_minor(minor);
 }
+EXPORT_SYMBOL_GPL(comedi_auto_unconfig);
 
 /**
  * comedi_pci_enable() - Enable the PCI device and request the regions.

commit 156096a0398fd5c42beeed87ad9b79134d890d22
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Sat Oct 27 21:44:13 2012 +0100

    staging: comedi: rename old auto-config functions
    
    Rename `comedi_auto_config()` to `comedi_old_auto_config()`, and
    `comedi_auto_config_wrapper()` to `comedi_old_auto_config_wrapper()`.
    These functions are deprecated and will be removed once the few
    remaining low-level comedi drivers that use them have been updated.
    (The low-level drivers in question support auto-configuration of
    detected comedi devices, but still use the `attach()` hook in their
    `struct comedi_driver` to do so.)
    
    This internal change frees up the name `comedi_auto_config` for future
    use.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 2c3db49c0dfd..4e61f5bd6792 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -879,8 +879,8 @@ comedi_auto_config_helper(struct device *hardware_device,
 	return ret;
 }
 
-static int comedi_auto_config_wrapper(struct comedi_device *dev,
-				      unsigned long context)
+static int comedi_old_auto_config_wrapper(struct comedi_device *dev,
+					  unsigned long context)
 {
 	struct comedi_devconfig *it = (struct comedi_devconfig *)context;
 	struct comedi_driver *driv = dev->driver;
@@ -906,9 +906,9 @@ static int comedi_auto_config_wrapper(struct comedi_device *dev,
 	return driv->attach(dev, it);
 }
 
-static int comedi_auto_config(struct device *hardware_device,
-			      struct comedi_driver *driver, const int *options,
-			      unsigned num_options)
+static int comedi_old_auto_config(struct device *hardware_device,
+				  struct comedi_driver *driver,
+				  const int *options, unsigned num_options)
 {
 	struct comedi_devconfig it;
 
@@ -918,7 +918,7 @@ static int comedi_auto_config(struct device *hardware_device,
 	BUG_ON(num_options > COMEDI_NDEVCONFOPTS);
 	memcpy(it.options, options, num_options * sizeof(int));
 	return comedi_auto_config_helper(hardware_device, driver,
-					 comedi_auto_config_wrapper,
+					 comedi_old_auto_config_wrapper,
 					 (unsigned long)&it);
 }
 
@@ -979,8 +979,8 @@ static int comedi_old_pci_auto_config(struct pci_dev *pcidev,
 	/*  pci slot */
 	options[1] = PCI_SLOT(pcidev->devfn);
 
-	return comedi_auto_config(&pcidev->dev, driver,
-				  options, ARRAY_SIZE(options));
+	return comedi_old_auto_config(&pcidev->dev, driver,
+				      options, ARRAY_SIZE(options));
 }
 
 static int comedi_pci_attach_wrapper(struct comedi_device *dev,
@@ -1049,7 +1049,7 @@ EXPORT_SYMBOL_GPL(comedi_pci_driver_unregister);
 static int comedi_old_usb_auto_config(struct usb_interface *intf,
 				      struct comedi_driver *driver)
 {
-	return comedi_auto_config(&intf->dev, driver, NULL, 0);
+	return comedi_old_auto_config(&intf->dev, driver, NULL, 0);
 }
 
 static int comedi_usb_attach_wrapper(struct comedi_device *dev,

commit f9c3e4e7a797ec7c0de3ad6372ca332692cd0115
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Sat Oct 27 21:44:12 2012 +0100

    staging: comedi: change type of auto-config context
    
    Change the type of the context parameter passed to
    `comedi_auto_config_helper()` from `void *` to `unsigned long`.  It's
    currently just an internal change and all current internal usages pass
    pointers in the context, but future uses of this function may pass
    integer values or pointer values at the whim of a lower-level comedi
    driver and the `unsigned long` type expresses this better as it is
    commonly used in the Linux kernel to hold such values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 09e1daf95767..2c3db49c0dfd 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -837,7 +837,8 @@ static int
 comedi_auto_config_helper(struct device *hardware_device,
 			  struct comedi_driver *driver,
 			  int (*attach_wrapper) (struct comedi_device *,
-						 void *), void *context)
+						 unsigned long),
+			  unsigned long context)
 {
 	int minor;
 	struct comedi_device_file_info *dev_file_info;
@@ -878,9 +879,10 @@ comedi_auto_config_helper(struct device *hardware_device,
 	return ret;
 }
 
-static int comedi_auto_config_wrapper(struct comedi_device *dev, void *context)
+static int comedi_auto_config_wrapper(struct comedi_device *dev,
+				      unsigned long context)
 {
-	struct comedi_devconfig *it = context;
+	struct comedi_devconfig *it = (struct comedi_devconfig *)context;
 	struct comedi_driver *driv = dev->driver;
 
 	if (driv->num_names) {
@@ -916,7 +918,8 @@ static int comedi_auto_config(struct device *hardware_device,
 	BUG_ON(num_options > COMEDI_NDEVCONFOPTS);
 	memcpy(it.options, options, num_options * sizeof(int));
 	return comedi_auto_config_helper(hardware_device, driver,
-					 comedi_auto_config_wrapper, &it);
+					 comedi_auto_config_wrapper,
+					 (unsigned long)&it);
 }
 
 static void comedi_auto_unconfig(struct device *hardware_device)
@@ -980,16 +983,18 @@ static int comedi_old_pci_auto_config(struct pci_dev *pcidev,
 				  options, ARRAY_SIZE(options));
 }
 
-static int comedi_pci_attach_wrapper(struct comedi_device *dev, void *pcidev)
+static int comedi_pci_attach_wrapper(struct comedi_device *dev,
+				     unsigned long context)
 {
-	return dev->driver->attach_pci(dev, pcidev);
+	return dev->driver->attach_pci(dev, (struct pci_dev *)context);
 }
 
 static int comedi_new_pci_auto_config(struct pci_dev *pcidev,
 				      struct comedi_driver *driver)
 {
 	return comedi_auto_config_helper(&pcidev->dev, driver,
-					 comedi_pci_attach_wrapper, pcidev);
+					 comedi_pci_attach_wrapper,
+					 (unsigned long)pcidev);
 }
 
 int comedi_pci_auto_config(struct pci_dev *pcidev, struct comedi_driver *driver)
@@ -1047,16 +1052,18 @@ static int comedi_old_usb_auto_config(struct usb_interface *intf,
 	return comedi_auto_config(&intf->dev, driver, NULL, 0);
 }
 
-static int comedi_usb_attach_wrapper(struct comedi_device *dev, void *intf)
+static int comedi_usb_attach_wrapper(struct comedi_device *dev,
+				     unsigned long context)
 {
-	return dev->driver->attach_usb(dev, intf);
+	return dev->driver->attach_usb(dev, (struct usb_interface *)context);
 }
 
 static int comedi_new_usb_auto_config(struct usb_interface *intf,
 				      struct comedi_driver *driver)
 {
 	return comedi_auto_config_helper(&intf->dev, driver,
-					 comedi_usb_attach_wrapper, intf);
+					 comedi_usb_attach_wrapper,
+					 (unsigned long)intf);
 }
 
 int comedi_usb_auto_config(struct usb_interface *intf,

commit 26cbd46529c07b50e92861f06497a5f327c48e69
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 15 13:07:32 2012 +0100

    staging: comedi: always set hw_dev during auto-config
    
    Auto-configuration (auto-attachment) of USB and PCI comedi devices all
    goes through `comedi_auto_config_helper()`.  That is a good place to set
    the comedi device's `hw_dev` pointer to the hardware `struct device` via
    a call to `comedi_set_hw_dev(comedi_device, hardware_device)` as it may
    obviate the need for the low-level comedi driver to make this call.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 1db6bfdbf13b..09e1daf95767 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -860,6 +860,7 @@ comedi_auto_config_helper(struct device *hardware_device,
 	else if (!try_module_get(driver->module))
 		ret = -EIO;
 	else {
+		comedi_set_hw_dev(comedi_dev, hardware_device);
 		/* set comedi_dev->driver here for attach wrapper */
 		comedi_dev->driver = driver;
 		ret = (*attach_wrapper)(comedi_dev, context);

commit 9f82e95773f0f02cfc948c8346a61d161f4eb61b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 18 19:46:59 2012 +0100

    staging: comedi: sparse warning in insn_rw_emulate_bits()
    
    `insn_rw_emulate_bits()` is used to emulate the `INSN_READ` and
    `INSN_WRITE` comedi instructions for subdevices that don't have an
    `insn_read()` or `insn_write()` handler but do have an `insn_bits()`
    handler.
    
    The function fills in a temporary `struct comedi_insn` called `new_insn`
    to pass to the subdevice's `insn_bits()` handler.  In doing so, it sets
    the `new_insn.data` pointer to point to a temporary data array.  This
    results in a warning from "sparse" because the `data` pointer in `struct
    comedi_insn` has the `__user` tag.  The subdevice's `insn_bits()`
    handler ignores it anyway as it gets passed a pointer to the temporary
    data array in a separate parameter.  Don't bother setting
    `new_insn.data`; just leave it set to `NULL` (done by an earlier
    `memset()`).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 2c21dbd89455..1db6bfdbf13b 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -415,7 +415,6 @@ static int insn_rw_emulate_bits(struct comedi_device *dev,
 	new_insn.insn = INSN_BITS;
 	new_insn.chanspec = base_bitfield_channel;
 	new_insn.n = 2;
-	new_insn.data = new_data;
 	new_insn.subdev = insn->subdev;
 
 	if (insn->insn == INSN_WRITE) {

commit 559e9a6899cd3056764e4272681b64eb326df3f1
Author: Güngör Erseymen <gelurine@gmail.com>
Date:   Tue Sep 11 17:56:42 2012 +0300

    staging: comedi: fix brace coding style issues
    
    Fix coding style issues by removing unnecessary braces.
    
    Signed-off-by: Güngör Erseymen <gelurine@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 5e91444b7d3d..2c21dbd89455 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -159,9 +159,8 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EBUSY;
 
 	for (driv = comedi_drivers; driv; driv = driv->next) {
-		if (!try_module_get(driv->module)) {
+		if (!try_module_get(driv->module))
 			continue;
-		}
 		if (driv->num_names) {
 			dev->board_ptr = comedi_recognize(driv, it->board_name);
 			if (dev->board_ptr)
@@ -174,9 +173,8 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		/*  recognize has failed if we get here */
 		/*  report valid board names before returning error */
 		for (driv = comedi_drivers; driv; driv = driv->next) {
-			if (!try_module_get(driv->module)) {
+			if (!try_module_get(driv->module))
 				continue;
-			}
 			comedi_report_boards(driv);
 			module_put(driv->module);
 		}

commit 5e4c58ce65103a820c4ca4b4b0bd8609e638cf75
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:21:25 2012 -0700

    staging: comedi: drivers: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 3153388ab810..5e91444b7d3d 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -71,7 +71,7 @@ int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 	dev->n_subdevices = num_subdevices;
 
 	for (i = 0; i < num_subdevices; ++i) {
-		s = dev->subdevices + i;
+		s = &dev->subdevices[i];
 		s->device = dev;
 		s->async_dma_dir = DMA_NONE;
 		spin_lock_init(&s->spin_lock);
@@ -88,7 +88,7 @@ static void cleanup_device(struct comedi_device *dev)
 
 	if (dev->subdevices) {
 		for (i = 0; i < dev->n_subdevices; i++) {
-			s = dev->subdevices + i;
+			s = &dev->subdevices[i];
 			comedi_free_subdevice_minor(s);
 			if (s->async) {
 				comedi_buf_alloc(dev, s, 0);
@@ -260,7 +260,7 @@ static int postconfig(struct comedi_device *dev)
 	int ret;
 
 	for (i = 0; i < dev->n_subdevices; i++) {
-		s = dev->subdevices + i;
+		s = &dev->subdevices[i];
 
 		if (s->type == COMEDI_SUBD_UNUSED)
 			continue;

commit 8f8b77bfdce811acbcf2248219a7aab5f92de938
Merge: d602a064f981 fea7a08acb13
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 27 07:10:40 2012 -0700

    Merge 3.6-rc3 into staging-next
    
    This picks up fixes we want in this branch to allow us to properly test.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4f870fe6269bbc7cca2a70c50a4cc6f811fe21c5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Aug 16 14:38:05 2012 +0100

    staging: comedi: replace printk calls in comedi core
    
    Replace the printk() calls in the comedi core module with something more
    suitable, such as dev_...() or pr_...().  Remove the ones that report a
    failure to increment a module count (try_module_get() failure).  Change
    the printk() call in the DPRINTK() macro to pr_debug().
    
    TODO: Most of the DPRINTK() calls need to be replaced with something
    else.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index c8adc5e009c8..c9f5c1f7a9e9 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -119,8 +119,8 @@ static void __comedi_device_detach(struct comedi_device *dev)
 	if (dev->driver)
 		dev->driver->detach(dev);
 	else
-		printk(KERN_WARNING
-		       "BUG: dev->driver=NULL in comedi_device_detach()\n");
+		dev_warn(dev->class_dev,
+			 "BUG: dev->driver=NULL in comedi_device_detach()\n");
 	cleanup_device(dev);
 }
 
@@ -142,8 +142,7 @@ static int comedi_device_postconfig(struct comedi_device *dev)
 		return ret;
 	}
 	if (!dev->board_name) {
-		printk(KERN_WARNING "BUG: dev->board_name=<%p>\n",
-		       dev->board_name);
+		dev_warn(dev->class_dev, "BUG: dev->board_name=NULL\n");
 		dev->board_name = "BUG";
 	}
 	smp_wmb();
@@ -161,7 +160,6 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
-			printk(KERN_INFO "comedi: failed to increment module count, skipping\n");
 			continue;
 		}
 		if (driv->num_names) {
@@ -177,8 +175,6 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		/*  report valid board names before returning error */
 		for (driv = comedi_drivers; driv; driv = driv->next) {
 			if (!try_module_get(driv->module)) {
-				printk(KERN_INFO
-				       "comedi: failed to increment module count\n");
 				continue;
 			}
 			comedi_report_boards(driv);
@@ -233,8 +229,9 @@ int comedi_driver_unregister(struct comedi_driver *driver)
 		mutex_lock(&dev->mutex);
 		if (dev->attached && dev->driver == driver) {
 			if (dev->use_count)
-				printk(KERN_WARNING "BUG! detaching device with use_count=%d\n",
-						dev->use_count);
+				dev_warn(dev->class_dev,
+					 "BUG! detaching device with use_count=%d\n",
+					 dev->use_count);
 			comedi_device_detach(dev);
 		}
 		mutex_unlock(&dev->mutex);
@@ -281,8 +278,8 @@ static int postconfig(struct comedi_device *dev)
 			async =
 			    kzalloc(sizeof(struct comedi_async), GFP_KERNEL);
 			if (async == NULL) {
-				printk(KERN_INFO
-				       "failed to allocate async struct\n");
+				dev_warn(dev->class_dev,
+					 "failed to allocate async struct\n");
 				return -ENOMEM;
 			}
 			init_waitqueue_head(&async->wait_head);
@@ -298,7 +295,8 @@ static int postconfig(struct comedi_device *dev)
 			async->prealloc_buf = NULL;
 			async->prealloc_bufsz = 0;
 			if (comedi_buf_alloc(dev, s, buf_size) < 0) {
-				printk(KERN_INFO "Buffer allocation failed\n");
+				dev_warn(dev->class_dev,
+					 "Buffer allocation failed\n");
 				return -ENOMEM;
 			}
 			if (s->buf_change) {
@@ -378,17 +376,17 @@ static void comedi_report_boards(struct comedi_driver *driv)
 	unsigned int i;
 	const char *const *name_ptr;
 
-	printk(KERN_INFO "comedi: valid board names for %s driver are:\n",
-	       driv->driver_name);
+	pr_info("comedi: valid board names for %s driver are:\n",
+		driv->driver_name);
 
 	name_ptr = driv->board_name;
 	for (i = 0; i < driv->num_names; i++) {
-		printk(KERN_INFO " %s\n", *name_ptr);
+		pr_info(" %s\n", *name_ptr);
 		name_ptr = (const char **)((char *)name_ptr + driv->offset);
 	}
 
 	if (driv->num_names == 0)
-		printk(KERN_INFO " %s\n", driv->driver_name);
+		pr_info(" %s\n", driv->driver_name);
 }
 
 static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -592,9 +590,9 @@ static unsigned int comedi_buf_munge(struct comedi_async *async,
 
 		block_size = num_bytes - count;
 		if (block_size < 0) {
-			printk(KERN_WARNING
-			       "%s: %s: bug! block_size is negative\n",
-			       __FILE__, __func__);
+			dev_warn(s->device->class_dev,
+				 "%s: %s: bug! block_size is negative\n",
+				 __FILE__, __func__);
 			break;
 		}
 		if ((int)(async->munge_ptr + block_size -
@@ -675,7 +673,8 @@ unsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes)
 {
 	if ((int)(async->buf_write_count + nbytes -
 		  async->buf_write_alloc_count) > 0) {
-		printk(KERN_INFO "comedi: attempted to write-free more bytes than have been write-allocated.\n");
+		dev_info(async->subdevice->device->class_dev,
+			 "attempted to write-free more bytes than have been write-allocated.\n");
 		nbytes = async->buf_write_alloc_count - async->buf_write_count;
 	}
 	async->buf_write_count += nbytes;
@@ -711,8 +710,8 @@ unsigned comedi_buf_read_free(struct comedi_async *async, unsigned int nbytes)
 	smp_mb();
 	if ((int)(async->buf_read_count + nbytes -
 		  async->buf_read_alloc_count) > 0) {
-		printk(KERN_INFO
-		       "comedi: attempted to read-free more bytes than have been read-allocated.\n");
+		dev_info(async->subdevice->device->class_dev,
+			 "attempted to read-free more bytes than have been read-allocated.\n");
 		nbytes = async->buf_read_alloc_count - async->buf_read_count;
 	}
 	async->buf_read_count += nbytes;
@@ -861,10 +860,9 @@ comedi_auto_config_helper(struct device *hardware_device,
 	mutex_lock(&comedi_dev->mutex);
 	if (comedi_dev->attached)
 		ret = -EBUSY;
-	else if (!try_module_get(driver->module)) {
-		printk(KERN_INFO "comedi: failed to increment module count\n");
+	else if (!try_module_get(driver->module))
 		ret = -EIO;
-	} else {
+	else {
 		/* set comedi_dev->driver here for attach wrapper */
 		comedi_dev->driver = driver;
 		ret = (*attach_wrapper)(comedi_dev, context);
@@ -892,17 +890,17 @@ static int comedi_auto_config_wrapper(struct comedi_device *dev, void *context)
 		 * has already been copied to it->board_name */
 		dev->board_ptr = comedi_recognize(driv, it->board_name);
 		if (dev->board_ptr == NULL) {
-			printk(KERN_WARNING
-			       "comedi: auto config failed to find board entry '%s' for driver '%s'\n",
-			       it->board_name, driv->driver_name);
+			dev_warn(dev->class_dev,
+				 "auto config failed to find board entry '%s' for driver '%s'\n",
+				 it->board_name, driv->driver_name);
 			comedi_report_boards(driv);
 			return -EINVAL;
 		}
 	}
 	if (!driv->attach) {
-		printk(KERN_WARNING
-		       "comedi: BUG! driver '%s' using old-style auto config but has no attach handler\n",
-		       driv->driver_name);
+		dev_warn(dev->class_dev,
+			 "BUG! driver '%s' using old-style auto config but has no attach handler\n",
+			 driv->driver_name);
 		return -EINVAL;
 	}
 	return driv->attach(dev, it);

commit 8c3714d60c0b681179000e3e1b5aae15d99e6218
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Aug 15 15:02:45 2012 +0100

    staging: comedi: make attach handler optional
    
    Some low-level Comedi drivers no longer support manual configuration of
    devices with the COMEDI_DEVCONFIG ioctl (used by the comedi_config
    program).  For those drivers, the 'attach_pci' or 'attach_usb' handler
    will be set in the struct comedi_driver to configure devices
    automatically (via comedi_pci_auto_config() or
    comedi_usb_auto_config()).  Their 'attach' handlers are redundant but
    the the comedi core module currently requires it to be set.
    
    Make the 'attach' handler optional and issue a warning if something
    wants to call it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index c0fdb00783ed..c8adc5e009c8 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -186,6 +186,14 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 		return -EIO;
 	}
+	if (driv->attach == NULL) {
+		/* driver does not support manual configuration */
+		dev_warn(dev->class_dev,
+			 "driver '%s' does not support attach using comedi_config\n",
+			 driv->driver_name);
+		module_put(driv->module);
+		return -ENOSYS;
+	}
 	/* initialize dev->driver here so
 	 * comedi_error() can be called from attach */
 	dev->driver = driv;
@@ -885,13 +893,18 @@ static int comedi_auto_config_wrapper(struct comedi_device *dev, void *context)
 		dev->board_ptr = comedi_recognize(driv, it->board_name);
 		if (dev->board_ptr == NULL) {
 			printk(KERN_WARNING
-			       "comedi: auto config failed to find board entry"
-			       " '%s' for driver '%s'\n", it->board_name,
-			       driv->driver_name);
+			       "comedi: auto config failed to find board entry '%s' for driver '%s'\n",
+			       it->board_name, driv->driver_name);
 			comedi_report_boards(driv);
 			return -EINVAL;
 		}
 	}
+	if (!driv->attach) {
+		printk(KERN_WARNING
+		       "comedi: BUG! driver '%s' using old-style auto config but has no attach handler\n",
+		       driv->driver_name);
+		return -EINVAL;
+	}
 	return driv->attach(dev, it);
 }
 

commit 80eb7a506fdcea08f86c9dfc7c638303bf02a3c8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Aug 14 11:29:17 2012 +0100

    staging: comedi: Fix reversed test in comedi_device_attach()
    
    Commit 3902a370281d2f2b130f141e8cf94eab40125769 (staging: comedi:
    refactor comedi_device_attach() a bit) by yours truly introduced an
    inverted logic bug in comedi_device_attach() for the case where the
    driver expects the device to be configured by driver name rather than
    board name.  The result of a strcmp() is being tested incorrectly.  Fix
    it.
    
    Thanks to Stephen N Chivers for discovering the bug and suggesting the
    fix.
    
    Cc: <stable@vger.kernel.org> # 3.5.x
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index c0fdb00783ed..2359151af7e1 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -168,7 +168,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			dev->board_ptr = comedi_recognize(driv, it->board_name);
 			if (dev->board_ptr)
 				break;
-		} else if (strcmp(driv->driver_name, it->board_name))
+		} else if (strcmp(driv->driver_name, it->board_name) == 0)
 			break;
 		module_put(driv->module);
 	}

commit f286766e4ba899043714471a0a2c9f1474d2ab5c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jun 19 10:17:46 2012 +0100

    staging: comedi: remove comedi_fops.h
    
    Move the contents of "comedi_fops.h" into "comedi_internal.h" and delete
    "comedi_fops.h". It only contains a couple of external variable
    declarations (and #include <linux/types.h>) and one of those isn't even
    declared in "comedi_fops.c".  The other one is an external declaration
    of a variable used to store a module parameter and some of those are
    already externally declared in "comedi_internal.h", so they can keep it
    company!
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index fe455e786ee4..c0fdb00783ed 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -24,7 +24,6 @@
 #define _GNU_SOURCE
 
 #define __NO_VERSION__
-#include "comedi_fops.h"
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/pci.h>

commit 3a5fa27516116352e810b2122afd82c3d5cbcc7e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jun 19 10:17:44 2012 +0100

    staging: comedi: rename internal.h to comedi_internal.h
    
    Use a less generic name for this internal header file included by
    various parts of the comedi core.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index bac3bc11d519..fe455e786ee4 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -45,7 +45,7 @@
 #include <linux/io.h>
 
 #include "comedidev.h"
-#include "internal.h"
+#include "comedi_internal.h"
 
 static int postconfig(struct comedi_device *dev);
 static int insn_rw_emulate_bits(struct comedi_device *dev,

commit 89a86a2da30a6a90dda719874092905cd762b7ef
Merge: 71f882fe7182 364ed2f4653d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jun 13 16:57:09 2012 -0700

    Merge branch 'staging-linus' into staging-next
    
    We need this for the pstore fixes that went into the staging-linus branch, so
    that things apply properly for the pstore/android code merge.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 03afcf472785a63d720202d28d51852d965a95d9
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:55 2012 -0700

    staging: comedi: cleanup comedi_alloc_subdevices
    
    Access the individual comedi_subdevices using a pointer instead
    of directly accessing as an array. This is how the rest of the
    comedi core accesses them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index ecad2288c9fb..6af4a5b302df 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -58,21 +58,24 @@ struct comedi_driver *comedi_drivers;
 
 int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 {
+	struct comedi_subdevice *s;
 	int i;
 
 	if (num_subdevices < 1)
 		return -EINVAL;
-	dev->subdevices =
-	    kcalloc(num_subdevices, sizeof(struct comedi_subdevice),
-		    GFP_KERNEL);
-	if (!dev->subdevices)
+
+	s = kcalloc(num_subdevices, sizeof(*s), GFP_KERNEL);
+	if (!s)
 		return -ENOMEM;
+	dev->subdevices = s;
 	dev->n_subdevices = num_subdevices;
+
 	for (i = 0; i < num_subdevices; ++i) {
-		dev->subdevices[i].device = dev;
-		dev->subdevices[i].async_dma_dir = DMA_NONE;
-		spin_lock_init(&dev->subdevices[i].spin_lock);
-		dev->subdevices[i].minor = -1;
+		s = dev->subdevices + i;
+		s->device = dev;
+		s->async_dma_dir = DMA_NONE;
+		spin_lock_init(&s->spin_lock);
+		s->minor = -1;
 	}
 	return 0;
 }

commit fba1d0faf726b442ab8771d5e9fbaf5f5a4c624c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:58:27 2012 -0700

    staging: comedi: only set dev->n_subdevices when kcalloc succeedes
    
    It's possible for the kcalloc in comedi_alloc_subdevices to fail.
    Only set the dev->n_subdevices variable if the allocation is
    successful.
    
    Since the core sets dev->n_subdevices, remove all the places in the
    drivers where this variable was getting set.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 61161ce8e93f..ecad2288c9fb 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -62,12 +62,12 @@ int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 
 	if (num_subdevices < 1)
 		return -EINVAL;
-	dev->n_subdevices = num_subdevices;
 	dev->subdevices =
 	    kcalloc(num_subdevices, sizeof(struct comedi_subdevice),
 		    GFP_KERNEL);
 	if (!dev->subdevices)
 		return -ENOMEM;
+	dev->n_subdevices = num_subdevices;
 	for (i = 0; i < num_subdevices; ++i) {
 		dev->subdevices[i].device = dev;
 		dev->subdevices[i].async_dma_dir = DMA_NONE;

commit 7f801c41714729f7741a042de839918be2bb56f0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:57:45 2012 -0700

    staging: comedi: sanity check num_subdevices parameter in comedi_alloc_subdevices
    
    It's possible for a couple of the comedi drivers to incorrectly call
    comedi_alloc_subdevices with num_subdevices = 0. Add a sanity check
    before doing the kcalloc.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbot@mev.co.uk>
    Cc: Frank Mori Hess <kmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 979aa0e88997..61161ce8e93f 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -60,6 +60,8 @@ int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 {
 	int i;
 
+	if (num_subdevices < 1)
+		return -EINVAL;
 	dev->n_subdevices = num_subdevices;
 	dev->subdevices =
 	    kcalloc(num_subdevices, sizeof(struct comedi_subdevice),

commit 8b9ba6e5efc3213f384cda155861a4f7ae903365
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:57:27 2012 -0700

    staging: comedi: change type of num_subdevices parameter to comedi_alloc_subdevices
    
    The n_subdevices variable of struct comedi_device is an int type.
    Change the type of the comedi_alloc_subdevices 'num_subdevices' from
    an unsigned int to an int to match it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 541364782b5f..979aa0e88997 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -56,10 +56,9 @@ static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s);
 
 struct comedi_driver *comedi_drivers;
 
-int comedi_alloc_subdevices(struct comedi_device *dev,
-			    unsigned int num_subdevices)
+int comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)
 {
-	unsigned i;
+	int i;
 
 	dev->n_subdevices = num_subdevices;
 	dev->subdevices =

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 49e53eaa8e41..541364782b5f 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -56,6 +56,27 @@ static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s);
 
 struct comedi_driver *comedi_drivers;
 
+int comedi_alloc_subdevices(struct comedi_device *dev,
+			    unsigned int num_subdevices)
+{
+	unsigned i;
+
+	dev->n_subdevices = num_subdevices;
+	dev->subdevices =
+	    kcalloc(num_subdevices, sizeof(struct comedi_subdevice),
+		    GFP_KERNEL);
+	if (!dev->subdevices)
+		return -ENOMEM;
+	for (i = 0; i < num_subdevices; ++i) {
+		dev->subdevices[i].device = dev;
+		dev->subdevices[i].async_dma_dir = DMA_NONE;
+		spin_lock_init(&dev->subdevices[i].spin_lock);
+		dev->subdevices[i].minor = -1;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(comedi_alloc_subdevices);
+
 static void cleanup_device(struct comedi_device *dev)
 {
 	int i;

commit 4e2f002f7a9b316640eb06ef6df767f017e3e7b1
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jun 6 15:17:02 2012 +0100

    staging: comedi: describe comedi_recognize()
    
    Add a comment to comedi_recognize() to describe what it does as it's a
    bit confusing.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 9d2b206251ac..49e53eaa8e41 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -300,8 +300,32 @@ static int postconfig(struct comedi_device *dev)
 	return 0;
 }
 
-/* generic recognize function for drivers
- * that register their supported board names */
+/*
+ * Generic recognize function for drivers that register their supported
+ * board names.
+ *
+ * 'driv->board_name' points to a 'const char *' member within the
+ * zeroth element of an array of some private board information
+ * structure, say 'struct foo_board' containing a member 'const char
+ * *board_name' that is initialized to point to a board name string that
+ * is one of the candidates matched against this function's 'name'
+ * parameter.
+ *
+ * 'driv->offset' is the size of the private board information
+ * structure, say 'sizeof(struct foo_board)', and 'driv->num_names' is
+ * the length of the array of private board information structures.
+ *
+ * If one of the board names in the array of private board information
+ * structures matches the name supplied to this function, the function
+ * returns a pointer to the pointer to the board name, otherwise it
+ * returns NULL.  The return value ends up in the 'board_ptr' member of
+ * a 'struct comedi_device' that the low-level comedi driver's
+ * 'attach()' hook can convert to a point to a particular element of its
+ * array of private board information structures by subtracting the
+ * offset of the member that points to the board name.  (No subtraction
+ * is required if the board name pointer is the first member of the
+ * private board information structure, which is generally the case.)
+ */
 static void *comedi_recognize(struct comedi_driver *driv, const char *name)
 {
 	char **name_ptr = (char **)driv->board_name;

commit 78b10615ad295393a7d66ea57218171c0a07c059
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Mon Jun 11 16:35:50 2012 -0700

    staging/comedi: fix build for USB not enabled
    
    Calls to optional subsystems cannot be made indiscriminately.
    Enclose all of the usb helper functions inside
    #if IS_ENABLED(CONFIG_USB)
    to fix these build errors.
    
    (The pci helper functions are OK since there are stubs in
    linux/pci.h for the called functions when PCI is not enabled.
    Possibly the same could be done for the called USB functions.)
    
    ERROR: "usb_deregister" [drivers/staging/comedi/comedi.ko] undefined!
    ERROR: "usb_register_driver" [drivers/staging/comedi/comedi.ko] undefined!
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 1c3d6386ea36..aeac1caba3f9 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -30,6 +30,7 @@
 #include <linux/pci.h>
 #include <linux/usb.h>
 #include <linux/errno.h>
+#include <linux/kconfig.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/fcntl.h>
@@ -981,6 +982,8 @@ void comedi_pci_driver_unregister(struct comedi_driver *comedi_driver,
 }
 EXPORT_SYMBOL_GPL(comedi_pci_driver_unregister);
 
+#if IS_ENABLED(CONFIG_USB)
+
 static int comedi_old_usb_auto_config(struct usb_interface *intf,
 				      struct comedi_driver *driver)
 {
@@ -1043,3 +1046,5 @@ void comedi_usb_driver_unregister(struct comedi_driver *comedi_driver,
 	comedi_driver_unregister(comedi_driver);
 }
 EXPORT_SYMBOL_GPL(comedi_usb_driver_unregister);
+
+#endif

commit 1364b02fbf6e2d298ff2428ace81f9c6517b4bd8
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 31 13:56:28 2012 -0700

    staging: comedi: drivers.c: remove unused inline functions
    
    Remove the inline functions uvirt_to_kva and kvirt_to_kva, they
    are not referenced by any of the drivers.c code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 438c52a313b1..9d2b206251ac 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -383,39 +383,6 @@ static int insn_rw_emulate_bits(struct comedi_device *dev,
 	return 1;
 }
 
-static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
-{
-	unsigned long ret = 0UL;
-	pmd_t *pmd;
-	pte_t *ptep, pte;
-	pud_t *pud;
-
-	if (!pgd_none(*pgd)) {
-		pud = pud_offset(pgd, adr);
-		pmd = pmd_offset(pud, adr);
-		if (!pmd_none(*pmd)) {
-			ptep = pte_offset_kernel(pmd, adr);
-			pte = *ptep;
-			if (pte_present(pte)) {
-				ret = (unsigned long)
-				    page_address(pte_page(pte));
-				ret |= (adr & (PAGE_SIZE - 1));
-			}
-		}
-	}
-	return ret;
-}
-
-static inline unsigned long kvirt_to_kva(unsigned long adr)
-{
-	unsigned long va, kva;
-
-	va = adr;
-	kva = uvirt_to_kva(pgd_offset_k(va), va);
-
-	return kva;
-}
-
 int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 		     unsigned long new_size)
 {

commit 1c9de58acc06cba56b5f1bd17a5a74a66427f8b1
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Sat May 26 15:14:45 2012 +0300

    staging: comedi: cleanup comedi_recognize()
    
    This function is more complicated than it needs to be because of the
    consts.  It's not worth saving them when we drop the consts anyway
    when we return (void *)name_ptr.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc:
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 7289dcb5c32c..438c52a313b1 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -304,14 +304,13 @@ static int postconfig(struct comedi_device *dev)
  * that register their supported board names */
 static void *comedi_recognize(struct comedi_driver *driv, const char *name)
 {
-	unsigned i;
-	const char *const *name_ptr = driv->board_name;
+	char **name_ptr = (char **)driv->board_name;
+	int i;
+
 	for (i = 0; i < driv->num_names; i++) {
 		if (strcmp(*name_ptr, name) == 0)
-			return (void *)name_ptr;
-		name_ptr =
-		    (const char *const *)((const char *)name_ptr +
-					  driv->offset);
+			return name_ptr;
+		name_ptr = (void *)name_ptr + driv->offset;
 	}
 
 	return NULL;

commit 55c03cff7fd73349473cc0a964df9d55b312dbbc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon May 21 17:12:12 2012 -0700

    staging: comedi: remove private header comedi_pci.h
    
    Remove the private header, comedi_pci.h, by moving the two
    helper functions into divers.c and providing the prototypes
    in comedidev.h.
    
    This allows the comedi_pci_enable/disable helper functions
    to be shared instead of having an inline version in every
    comedi pci driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 1c3d6386ea36..7289dcb5c32c 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -908,6 +908,40 @@ static void comedi_auto_unconfig(struct device *hardware_device)
 	comedi_free_board_minor(minor);
 }
 
+/**
+ * comedi_pci_enable() - Enable the PCI device and request the regions.
+ * @pdev: pci_dev struct
+ * @res_name: name for the requested reqource
+ */
+int comedi_pci_enable(struct pci_dev *pdev, const char *res_name)
+{
+	int rc;
+
+	rc = pci_enable_device(pdev);
+	if (rc < 0)
+		return rc;
+
+	rc = pci_request_regions(pdev, res_name);
+	if (rc < 0)
+		pci_disable_device(pdev);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(comedi_pci_enable);
+
+/**
+ * comedi_pci_disable() - Release the regions and disable the PCI device.
+ * @pdev: pci_dev struct
+ *
+ * This must be matched with a previous successful call to comedi_pci_enable().
+ */
+void comedi_pci_disable(struct pci_dev *pdev)
+{
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+}
+EXPORT_SYMBOL_GPL(comedi_pci_disable);
+
 static int comedi_old_pci_auto_config(struct pci_dev *pcidev,
 				      struct comedi_driver *driver)
 {

commit 64255031bde68bd0f7ec934b83842619d513cf91
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed May 16 18:18:52 2012 -0700

    staging: comedi: Add helper macro for comedi usb driver boilerplate
    
    Introduce the module_comedi_usb_driver macro, and the
    associated register/unregister functions, which is a
    convenience macro for comedi usb driver modules similar
    to module_platform_driver. It is intended to be used by
    drivers where the init/exit section does nothing but
    register/unregister the comedi driver and associated usb
    driver. By using this macro it is possible to eliminate
    a few lines of boilerplate code per comedi usb driver.
    
    Also, when registering the usb driver check for failure
    and unregister the comedi driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 3a8295080961..1c3d6386ea36 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -1016,3 +1016,30 @@ void comedi_usb_auto_unconfig(struct usb_interface *intf)
 	comedi_auto_unconfig(&intf->dev);
 }
 EXPORT_SYMBOL_GPL(comedi_usb_auto_unconfig);
+
+int comedi_usb_driver_register(struct comedi_driver *comedi_driver,
+		struct usb_driver *usb_driver)
+{
+	int ret;
+
+	ret = comedi_driver_register(comedi_driver);
+	if (ret < 0)
+		return ret;
+
+	ret = usb_register(usb_driver);
+	if (ret < 0) {
+		comedi_driver_unregister(comedi_driver);
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(comedi_usb_driver_register);
+
+void comedi_usb_driver_unregister(struct comedi_driver *comedi_driver,
+		struct usb_driver *usb_driver)
+{
+	usb_deregister(usb_driver);
+	comedi_driver_unregister(comedi_driver);
+}
+EXPORT_SYMBOL_GPL(comedi_usb_driver_unregister);

commit d4899c6ff86ea9836c89250cb2127aa64765b35a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri May 11 16:15:39 2012 -0700

    staging: comedi: Add helper macro for comedi pci driver boilerplate
    
    Introduce the module_comedi_pci_driver macro, and the
    associated register/unregister functions, which is a
    convenience macro for comedi pci driver modules similar
    to module_platform_driver. It is intended to be used by
    drivers where the init/exit section does nothing but
    register/unregister the comedi driver and associated pci
    driver. By using this macro it is possible to eliminate
    a few lines of boilerplate code per comedi pci driver.
    
    Add a check to make sure that the pci_driver->name is
    set. Once all the comedi pci drivers have been fixed this
    will be removed.
    
    Also, when registering the pci driver check for failure
    and unregister the comedi driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 49681a1a6fa6..3a8295080961 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -950,6 +950,37 @@ void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
 }
 EXPORT_SYMBOL_GPL(comedi_pci_auto_unconfig);
 
+int comedi_pci_driver_register(struct comedi_driver *comedi_driver,
+		struct pci_driver *pci_driver)
+{
+	int ret;
+
+	ret = comedi_driver_register(comedi_driver);
+	if (ret < 0)
+		return ret;
+
+	/* FIXME: Remove this test after auditing all comedi pci drivers */
+	if (!pci_driver->name)
+		pci_driver->name = comedi_driver->driver_name;
+
+	ret = pci_register_driver(pci_driver);
+	if (ret < 0) {
+		comedi_driver_unregister(comedi_driver);
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(comedi_pci_driver_register);
+
+void comedi_pci_driver_unregister(struct comedi_driver *comedi_driver,
+		struct pci_driver *pci_driver)
+{
+	pci_unregister_driver(pci_driver);
+	comedi_driver_unregister(comedi_driver);
+}
+EXPORT_SYMBOL_GPL(comedi_pci_driver_unregister);
+
 static int comedi_old_usb_auto_config(struct usb_interface *intf,
 				      struct comedi_driver *driver)
 {

commit 4d7df821277e82ebe2fc9c9af07c928a83f572b8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Apr 13 14:12:53 2012 +0100

    staging: comedi: Add module parameters for default buffer size
    
    For comedi subdevices that support asynchronous transfer commands, the
    initial buffer size and maximum buffer size for the transfer are both
    set to 64 KiB when the comedi device is "attached" to the hardware
    device.  For many applications with reasonable fast sample rates and
    slow user-space (e.g. Python) these sizes are a bit too small.
    
    A task with CAP_SYS_ADMIN privileges can change the maximum buffer size
    for a comedi subdevice with an ioctl call or by writing to a device
    attribute file in sysfs, but that's not very convenient.  For comedi
    devices attached during system startup, this could be done by a start-up
    script, but for hot-plugged devices it would require scripts run by udev
    rules, etc.
    
    Rather than use hardwired values, this patch introduces a couple of
    module parameters to set the defaults for the initial buffer size
    (comedi_default_buf_size_kb) and maximum buffer size
    (comedi_default_buf_maxsize_kb).  These values are applied in place of
    the previous hard-wired values when the comedi device is "attached".
    The module parameter values are in units of KiB for consistency with the
    existing device attribute files.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 872b598b7939..49681a1a6fa6 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -239,6 +239,8 @@ static int postconfig(struct comedi_device *dev)
 			s->len_chanlist = 1;
 
 		if (s->do_cmd) {
+			unsigned int buf_size;
+
 			BUG_ON((s->subdev_flags & (SDF_CMD_READ |
 						   SDF_CMD_WRITE)) == 0);
 			BUG_ON(!s->do_cmdtest);
@@ -254,19 +256,20 @@ static int postconfig(struct comedi_device *dev)
 			async->subdevice = s;
 			s->async = async;
 
-#define DEFAULT_BUF_MAXSIZE (64*1024)
-#define DEFAULT_BUF_SIZE (64*1024)
-
-			async->max_bufsize = DEFAULT_BUF_MAXSIZE;
+			async->max_bufsize =
+				comedi_default_buf_maxsize_kb * 1024;
+			buf_size = comedi_default_buf_size_kb * 1024;
+			if (buf_size > async->max_bufsize)
+				buf_size = async->max_bufsize;
 
 			async->prealloc_buf = NULL;
 			async->prealloc_bufsz = 0;
-			if (comedi_buf_alloc(dev, s, DEFAULT_BUF_SIZE) < 0) {
+			if (comedi_buf_alloc(dev, s, buf_size) < 0) {
 				printk(KERN_INFO "Buffer allocation failed\n");
 				return -ENOMEM;
 			}
 			if (s->buf_change) {
-				ret = s->buf_change(dev, s, DEFAULT_BUF_SIZE);
+				ret = s->buf_change(dev, s, buf_size);
 				if (ret < 0)
 					return ret;
 			}

commit cf938c247307826e70f93dd9072c70d3020d6d67
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:15:03 2012 +0100

    staging: comedi: restrict comedi_auto_config() to single driver
    
    comedi_auto_config() only needs to consider a single struct
    comedi_driver object, but it currently calls comedi_device_attach()
    which looks at all struct comedi_driver objects registered with the
    Comedi core.
    
    Instead, call the recently added comedi_auto_config_helper() with a new
    wrapper comedi_auto_config_wrapper() to mimic the effect of
    comedi_device_attach() for a single struct comedi_driver.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index aec9c35428cc..872b598b7939 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -856,37 +856,40 @@ comedi_auto_config_helper(struct device *hardware_device,
 	return ret;
 }
 
+static int comedi_auto_config_wrapper(struct comedi_device *dev, void *context)
+{
+	struct comedi_devconfig *it = context;
+	struct comedi_driver *driv = dev->driver;
+
+	if (driv->num_names) {
+		/* look for generic board entry matching driver name, which
+		 * has already been copied to it->board_name */
+		dev->board_ptr = comedi_recognize(driv, it->board_name);
+		if (dev->board_ptr == NULL) {
+			printk(KERN_WARNING
+			       "comedi: auto config failed to find board entry"
+			       " '%s' for driver '%s'\n", it->board_name,
+			       driv->driver_name);
+			comedi_report_boards(driv);
+			return -EINVAL;
+		}
+	}
+	return driv->attach(dev, it);
+}
+
 static int comedi_auto_config(struct device *hardware_device,
 			      struct comedi_driver *driver, const int *options,
 			      unsigned num_options)
 {
 	struct comedi_devconfig it;
-	int minor;
-	struct comedi_device_file_info *dev_file_info;
-	int retval;
-
-	if (!comedi_autoconfig)
-		return 0;
-
-	minor = comedi_alloc_board_minor(hardware_device);
-	if (minor < 0)
-		return minor;
-
-	dev_file_info = comedi_get_device_file_info(minor);
 
 	memset(&it, 0, sizeof(it));
 	strncpy(it.board_name, driver->driver_name, COMEDI_NAMELEN);
 	it.board_name[COMEDI_NAMELEN - 1] = '\0';
 	BUG_ON(num_options > COMEDI_NDEVCONFOPTS);
 	memcpy(it.options, options, num_options * sizeof(int));
-
-	mutex_lock(&dev_file_info->device->mutex);
-	retval = comedi_device_attach(dev_file_info->device, &it);
-	mutex_unlock(&dev_file_info->device->mutex);
-
-	if (retval < 0)
-		comedi_free_board_minor(minor);
-	return retval;
+	return comedi_auto_config_helper(hardware_device, driver,
+					 comedi_auto_config_wrapper, &it);
 }
 
 static void comedi_auto_unconfig(struct device *hardware_device)

commit 63bf3d11df34426caa81e5478b2ff0e99875e972
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:15:02 2012 +0100

    staging: comedi: pass struct comedi_driver * to comedi_auto_config()
    
    Pass a pointer to the struct comedi_driver to comedi_auto_config()
    instead of the driver name.  comedi_auto_config() will be changed to
    make use of this.  It currently calls comedi_device_attach() which
    examines the whole list of struct comedi_driver objects.  It will be
    changed to restrict itself to just the supplied struct comedi_driver
    object.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 69e6fa345d3f..aec9c35428cc 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -857,7 +857,7 @@ comedi_auto_config_helper(struct device *hardware_device,
 }
 
 static int comedi_auto_config(struct device *hardware_device,
-			      const char *board_name, const int *options,
+			      struct comedi_driver *driver, const int *options,
 			      unsigned num_options)
 {
 	struct comedi_devconfig it;
@@ -875,7 +875,7 @@ static int comedi_auto_config(struct device *hardware_device,
 	dev_file_info = comedi_get_device_file_info(minor);
 
 	memset(&it, 0, sizeof(it));
-	strncpy(it.board_name, board_name, COMEDI_NAMELEN);
+	strncpy(it.board_name, driver->driver_name, COMEDI_NAMELEN);
 	it.board_name[COMEDI_NAMELEN - 1] = '\0';
 	BUG_ON(num_options > COMEDI_NDEVCONFOPTS);
 	memcpy(it.options, options, num_options * sizeof(int));
@@ -912,7 +912,7 @@ static int comedi_old_pci_auto_config(struct pci_dev *pcidev,
 	/*  pci slot */
 	options[1] = PCI_SLOT(pcidev->devfn);
 
-	return comedi_auto_config(&pcidev->dev, driver->driver_name,
+	return comedi_auto_config(&pcidev->dev, driver,
 				  options, ARRAY_SIZE(options));
 }
 
@@ -947,7 +947,7 @@ EXPORT_SYMBOL_GPL(comedi_pci_auto_unconfig);
 static int comedi_old_usb_auto_config(struct usb_interface *intf,
 				      struct comedi_driver *driver)
 {
-	return comedi_auto_config(&intf->dev, driver->driver_name, NULL, 0);
+	return comedi_auto_config(&intf->dev, driver, NULL, 0);
 }
 
 static int comedi_usb_attach_wrapper(struct comedi_device *dev, void *intf)

commit f4011670023f28cf9081904f8986c0c1be5c9f1e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:15:01 2012 +0100

    staging: comedi: add bus-type-specific attach hooks for PCI and USB
    
    The Comedi auto-configuration mechanism used to bind hardware devices to
    comedi devices automatically is pretty kludgy.  It fakes a "manual"
    configuration of the comedi device as though the COMEDI_DEVCONFIG ioctl
    (or the 'comedi_config' utility) were used.  In particular, the
    low-level comedi driver's '->attach()' routine is called with a pointer
    to the struct comedi_device being attached and a pointer to a 'struct
    devconfig' containing a device name string and a few integer options to
    help the attach routine locate the device being attached.  In the case
    of PCI devices, these integer options are the PCI bus and slot numbers.
    In the case of USB devices, there are no integer options and it relies
    more on pot luck to attach the correct device.
    
    This patch adds a couple of bus-type-specific attach routine hooks to
    the struct comedi_driver, which a low-level driver can optionally fill
    in if it supports auto-configuration.
    
    A low-level driver that supports auto-configuration of {PCI,USB} devices
    calls the existing comedi_{pci,usb}_auto_config() when it wishes to
    auto-configure a freshly probed device (maybe after loading firmware).
    This will call the new '->attach_{pci,usb}()' hook if the driver has
    defined it, otherwise it will fall back to calling the '->attach()' hook
    as before.  The '->attach_{pci,usb}()' hook gets a pointer to the struct
    comedi_device and a pointer to the struct {pci_dev,usb_interface} and
    can figure out the {PCI,USB} device details for itself.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index cfb6fe94f782..69e6fa345d3f 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -811,6 +811,51 @@ void comedi_reset_async_buf(struct comedi_async *async)
 	async->events = 0;
 }
 
+static int
+comedi_auto_config_helper(struct device *hardware_device,
+			  struct comedi_driver *driver,
+			  int (*attach_wrapper) (struct comedi_device *,
+						 void *), void *context)
+{
+	int minor;
+	struct comedi_device_file_info *dev_file_info;
+	struct comedi_device *comedi_dev;
+	int ret;
+
+	if (!comedi_autoconfig)
+		return 0;
+
+	minor = comedi_alloc_board_minor(hardware_device);
+	if (minor < 0)
+		return minor;
+
+	dev_file_info = comedi_get_device_file_info(minor);
+	comedi_dev = dev_file_info->device;
+
+	mutex_lock(&comedi_dev->mutex);
+	if (comedi_dev->attached)
+		ret = -EBUSY;
+	else if (!try_module_get(driver->module)) {
+		printk(KERN_INFO "comedi: failed to increment module count\n");
+		ret = -EIO;
+	} else {
+		/* set comedi_dev->driver here for attach wrapper */
+		comedi_dev->driver = driver;
+		ret = (*attach_wrapper)(comedi_dev, context);
+		if (ret < 0) {
+			module_put(driver->module);
+			__comedi_device_detach(comedi_dev);
+		} else {
+			ret = comedi_device_postconfig(comedi_dev);
+		}
+	}
+	mutex_unlock(&comedi_dev->mutex);
+
+	if (ret < 0)
+		comedi_free_board_minor(minor);
+	return ret;
+}
+
 static int comedi_auto_config(struct device *hardware_device,
 			      const char *board_name, const int *options,
 			      unsigned num_options)
@@ -857,7 +902,8 @@ static void comedi_auto_unconfig(struct device *hardware_device)
 	comedi_free_board_minor(minor);
 }
 
-int comedi_pci_auto_config(struct pci_dev *pcidev, struct comedi_driver *driver)
+static int comedi_old_pci_auto_config(struct pci_dev *pcidev,
+				      struct comedi_driver *driver)
 {
 	int options[2];
 
@@ -869,6 +915,27 @@ int comedi_pci_auto_config(struct pci_dev *pcidev, struct comedi_driver *driver)
 	return comedi_auto_config(&pcidev->dev, driver->driver_name,
 				  options, ARRAY_SIZE(options));
 }
+
+static int comedi_pci_attach_wrapper(struct comedi_device *dev, void *pcidev)
+{
+	return dev->driver->attach_pci(dev, pcidev);
+}
+
+static int comedi_new_pci_auto_config(struct pci_dev *pcidev,
+				      struct comedi_driver *driver)
+{
+	return comedi_auto_config_helper(&pcidev->dev, driver,
+					 comedi_pci_attach_wrapper, pcidev);
+}
+
+int comedi_pci_auto_config(struct pci_dev *pcidev, struct comedi_driver *driver)
+{
+
+	if (driver->attach_pci)
+		return comedi_new_pci_auto_config(pcidev, driver);
+	else
+		return comedi_old_pci_auto_config(pcidev, driver);
+}
 EXPORT_SYMBOL_GPL(comedi_pci_auto_config);
 
 void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
@@ -877,11 +944,32 @@ void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
 }
 EXPORT_SYMBOL_GPL(comedi_pci_auto_unconfig);
 
+static int comedi_old_usb_auto_config(struct usb_interface *intf,
+				      struct comedi_driver *driver)
+{
+	return comedi_auto_config(&intf->dev, driver->driver_name, NULL, 0);
+}
+
+static int comedi_usb_attach_wrapper(struct comedi_device *dev, void *intf)
+{
+	return dev->driver->attach_usb(dev, intf);
+}
+
+static int comedi_new_usb_auto_config(struct usb_interface *intf,
+				      struct comedi_driver *driver)
+{
+	return comedi_auto_config_helper(&intf->dev, driver,
+					 comedi_usb_attach_wrapper, intf);
+}
+
 int comedi_usb_auto_config(struct usb_interface *intf,
 			   struct comedi_driver *driver)
 {
 	BUG_ON(intf == NULL);
-	return comedi_auto_config(&intf->dev, driver->driver_name, NULL, 0);
+	if (driver->attach_usb)
+		return comedi_new_usb_auto_config(intf, driver);
+	else
+		return comedi_old_usb_auto_config(intf, driver);
 }
 EXPORT_SYMBOL_GPL(comedi_usb_auto_config);
 

commit 3902a370281d2f2b130f141e8cf94eab40125769
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:15:00 2012 +0100

    staging: comedi: refactor comedi_device_attach() a bit
    
    Split the post-config part of comedi_device_attach() into new function
    comedi_device_postconfig() and rearrange the rest of the function a bit.
    
    The new comedi_device_postconfig() function will be called by some new
    bus-type-specific auto-attach functions.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index feb33f86023b..cfb6fe94f782 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -106,6 +106,26 @@ void comedi_device_detach(struct comedi_device *dev)
 	__comedi_device_detach(dev);
 }
 
+/* do a little post-config cleanup */
+/* called with module refcount incremented, decrements it */
+static int comedi_device_postconfig(struct comedi_device *dev)
+{
+	int ret = postconfig(dev);
+	module_put(dev->driver->module);
+	if (ret < 0) {
+		__comedi_device_detach(dev);
+		return ret;
+	}
+	if (!dev->board_name) {
+		printk(KERN_WARNING "BUG: dev->board_name=<%p>\n",
+		       dev->board_name);
+		dev->board_name = "BUG";
+	}
+	smp_wmb();
+	dev->attached = 1;
+	return 0;
+}
+
 int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_driver *driv;
@@ -121,59 +141,36 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 		if (driv->num_names) {
 			dev->board_ptr = comedi_recognize(driv, it->board_name);
-			if (dev->board_ptr == NULL) {
-				module_put(driv->module);
-				continue;
-			}
-		} else {
-			if (strcmp(driv->driver_name, it->board_name)) {
-				module_put(driv->module);
+			if (dev->board_ptr)
+				break;
+		} else if (strcmp(driv->driver_name, it->board_name))
+			break;
+		module_put(driv->module);
+	}
+	if (driv == NULL) {
+		/*  recognize has failed if we get here */
+		/*  report valid board names before returning error */
+		for (driv = comedi_drivers; driv; driv = driv->next) {
+			if (!try_module_get(driv->module)) {
+				printk(KERN_INFO
+				       "comedi: failed to increment module count\n");
 				continue;
 			}
+			comedi_report_boards(driv);
+			module_put(driv->module);
 		}
-		/* initialize dev->driver here so
-		 * comedi_error() can be called from attach */
-		dev->driver = driv;
-		ret = driv->attach(dev, it);
-		if (ret < 0) {
-			module_put(dev->driver->module);
-			__comedi_device_detach(dev);
-			return ret;
-		}
-		goto attached;
+		return -EIO;
 	}
-
-	/*  recognize has failed if we get here */
-	/*  report valid board names before returning error */
-	for (driv = comedi_drivers; driv; driv = driv->next) {
-		if (!try_module_get(driv->module)) {
-			printk(KERN_INFO
-			       "comedi: failed to increment module count\n");
-			continue;
-		}
-		comedi_report_boards(driv);
-		module_put(driv->module);
-	}
-	return -EIO;
-
-attached:
-	/* do a little post-config cleanup */
-	ret = postconfig(dev);
-	module_put(dev->driver->module);
+	/* initialize dev->driver here so
+	 * comedi_error() can be called from attach */
+	dev->driver = driv;
+	ret = driv->attach(dev, it);
 	if (ret < 0) {
+		module_put(dev->driver->module);
 		__comedi_device_detach(dev);
 		return ret;
 	}
-
-	if (!dev->board_name) {
-		printk(KERN_WARNING "BUG: dev->board_name=<%p>\n",
-		       dev->board_name);
-		dev->board_name = "BUG";
-	}
-	smp_wmb();
-	dev->attached = 1;
-
-	return 0;
+	return comedi_device_postconfig(dev);
 }
 
 int comedi_driver_register(struct comedi_driver *driver)

commit d8b6ca0850c558f21989d468801ad1414b1372c4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:59 2012 +0100

    staging: comedi: pass usb interface to comedi_usb_auto_config
    
    The comedi_usb_auto_config() and comedi_usb_auto_unconfig() functions
    currently take a 'struct usb_device *'.  It makes more sense to pass a
    'struct usb_interface *' to allow for composite USB devices.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 417aed2ab738..feb33f86023b 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -880,17 +880,17 @@ void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
 }
 EXPORT_SYMBOL_GPL(comedi_pci_auto_unconfig);
 
-int comedi_usb_auto_config(struct usb_device *usbdev,
+int comedi_usb_auto_config(struct usb_interface *intf,
 			   struct comedi_driver *driver)
 {
-	BUG_ON(usbdev == NULL);
-	return comedi_auto_config(&usbdev->dev, driver->driver_name, NULL, 0);
+	BUG_ON(intf == NULL);
+	return comedi_auto_config(&intf->dev, driver->driver_name, NULL, 0);
 }
 EXPORT_SYMBOL_GPL(comedi_usb_auto_config);
 
-void comedi_usb_auto_unconfig(struct usb_device *usbdev)
+void comedi_usb_auto_unconfig(struct usb_interface *intf)
 {
-	BUG_ON(usbdev == NULL);
-	comedi_auto_unconfig(&usbdev->dev);
+	BUG_ON(intf == NULL);
+	comedi_auto_unconfig(&intf->dev);
 }
 EXPORT_SYMBOL_GPL(comedi_usb_auto_unconfig);

commit c43435d7722134ed1fda58ce1025f41029bd58ad
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:58 2012 +0100

    staging: comedi: don't hijack hardware device private data
    
    comedi_auto_config() associates a Comedi minor device number with an
    auto-configured hardware device and comedi_auto_unconfig() disassociates
    it.  Currently, these use the hardware device's private data pointer to
    point to some allocated storage holding the minor device number.  This
    is a bit of a waste of the hardware device's private data pointer,
    preventing it from being used for something more useful by the low-level
    comedi device drivers.  For example, it would make more sense if
    comedi_usb_auto_config() was passed a pointer to the struct
    usb_interface instead of the struct usb_device, but this cannot be done
    currently because the low-level comedi drivers already use the private
    data pointer in the struct usb_interface for something more useful.
    
    This patch stops the comedi core hijacking the hardware device's private
    data pointer.  Instead, comedi_auto_config() stores a pointer to the
    hardware device's struct device in the struct comedi_device_file_info
    associated with the minor device number, and comedi_auto_unconfig()
    calls new function comedi_find_board_minor() to recover the minor device
    number associated with the hardware device.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 9dd2da1e97ad..417aed2ab738 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -822,25 +822,14 @@ static int comedi_auto_config(struct device *hardware_device,
 	int minor;
 	struct comedi_device_file_info *dev_file_info;
 	int retval;
-	unsigned *private_data = NULL;
 
-	if (!comedi_autoconfig) {
-		dev_set_drvdata(hardware_device, NULL);
+	if (!comedi_autoconfig)
 		return 0;
-	}
 
 	minor = comedi_alloc_board_minor(hardware_device);
 	if (minor < 0)
 		return minor;
 
-	private_data = kmalloc(sizeof(unsigned), GFP_KERNEL);
-	if (private_data == NULL) {
-		retval = -ENOMEM;
-		goto cleanup;
-	}
-	*private_data = minor;
-	dev_set_drvdata(hardware_device, private_data);
-
 	dev_file_info = comedi_get_device_file_info(minor);
 
 	memset(&it, 0, sizeof(it));
@@ -853,25 +842,22 @@ static int comedi_auto_config(struct device *hardware_device,
 	retval = comedi_device_attach(dev_file_info->device, &it);
 	mutex_unlock(&dev_file_info->device->mutex);
 
-cleanup:
-	if (retval < 0) {
-		kfree(private_data);
+	if (retval < 0)
 		comedi_free_board_minor(minor);
-	}
 	return retval;
 }
 
 static void comedi_auto_unconfig(struct device *hardware_device)
 {
-	unsigned *minor = (unsigned *)dev_get_drvdata(hardware_device);
-	if (minor == NULL)
-		return;
-
-	BUG_ON(*minor >= COMEDI_NUM_BOARD_MINORS);
+	int minor;
 
-	comedi_free_board_minor(*minor);
-	dev_set_drvdata(hardware_device, NULL);
-	kfree(minor);
+	if (hardware_device == NULL)
+		return;
+	minor = comedi_find_board_minor(hardware_device);
+	if (minor < 0)
+		return;
+	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
+	comedi_free_board_minor(minor);
 }
 
 int comedi_pci_auto_config(struct pci_dev *pcidev, struct comedi_driver *driver)

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index bf185e2807d1..9dd2da1e97ad 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -874,7 +874,7 @@ static void comedi_auto_unconfig(struct device *hardware_device)
 	kfree(minor);
 }
 
-int comedi_pci_auto_config(struct pci_dev *pcidev, const char *board_name)
+int comedi_pci_auto_config(struct pci_dev *pcidev, struct comedi_driver *driver)
 {
 	int options[2];
 
@@ -883,7 +883,7 @@ int comedi_pci_auto_config(struct pci_dev *pcidev, const char *board_name)
 	/*  pci slot */
 	options[1] = PCI_SLOT(pcidev->devfn);
 
-	return comedi_auto_config(&pcidev->dev, board_name,
+	return comedi_auto_config(&pcidev->dev, driver->driver_name,
 				  options, ARRAY_SIZE(options));
 }
 EXPORT_SYMBOL_GPL(comedi_pci_auto_config);
@@ -894,10 +894,11 @@ void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
 }
 EXPORT_SYMBOL_GPL(comedi_pci_auto_unconfig);
 
-int comedi_usb_auto_config(struct usb_device *usbdev, const char *board_name)
+int comedi_usb_auto_config(struct usb_device *usbdev,
+			   struct comedi_driver *driver)
 {
 	BUG_ON(usbdev == NULL);
-	return comedi_auto_config(&usbdev->dev, board_name, NULL, 0);
+	return comedi_auto_config(&usbdev->dev, driver->driver_name, NULL, 0);
 }
 EXPORT_SYMBOL_GPL(comedi_usb_auto_config);
 

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index db1fd63aaab3..bf185e2807d1 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -42,7 +42,6 @@
 #include <linux/cdev.h>
 #include <linux/dma-mapping.h>
 #include <linux/io.h>
-#include <asm/system.h>
 
 #include "comedidev.h"
 #include "internal.h"

commit 408093d2a1724ea4c8518bd2bfee166132a6cbfa
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 9 12:13:08 2011 -0700

    Staging: comedi: drivers.c: fix PAGE_KERNEL_NOCACHE issue
    
    Not all arches have PAGE_KERNEL_NOCACHE, so use the "normal" PAGE_KERNEL
    on those that do not have it.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 6d60e91b3a85..db1fd63aaab3 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -502,7 +502,11 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 		if (i == n_pages) {
 			async->prealloc_buf =
+#ifdef PAGE_KERNEL_NOCACHE
 			    vmap(pages, n_pages, VM_MAP, PAGE_KERNEL_NOCACHE);
+#else
+			    vmap(pages, n_pages, VM_MAP, PAGE_KERNEL);
+#endif
 		}
 		vfree(pages);
 

commit 3ad4e219606fa317f778b26553889520aed7925c
Author: Micha Hergarden <micha.hergarden@gmail.com>
Date:   Wed Feb 2 21:25:07 2011 +0100

    staging: comedi: fix coding style issue in drivers.c
    
    This is a patch to the drivers.c file that fixes up a
    braces around single statement warning found by the
    checkpatch.pl tool
    
    Signed-off-by: Micha Hergarden <micha.hergarden@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index dca861ee0466..6d60e91b3a85 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -471,9 +471,9 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 
 		async->buf_page_list =
 		    vzalloc(sizeof(struct comedi_buf_page) * n_pages);
-		if (async->buf_page_list) {
+		if (async->buf_page_list)
 			pages = vmalloc(sizeof(struct page *) * n_pages);
-		}
+
 		if (pages) {
 			for (i = 0; i < n_pages; i++) {
 				if (s->async_dma_dir != DMA_NONE) {

commit 88ab8a8445838785e38af378740ab57f8cb6cb8a
Author: Xenofon Foukas <foukas.xenofon@gmail.com>
Date:   Sat Dec 4 00:17:55 2010 +0200

    Staging: comedi: Fix coding style issues in drivers.c
    
    This patch fixes line over 80 characters warning issues found
    in file drivers.c
    
    Signed-off-by: Xenofon Foukas <foukas.xenofon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index ef24a530278b..dca861ee0466 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -117,8 +117,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
-			printk
-			    (KERN_INFO "comedi: failed to increment module count, skipping\n");
+			printk(KERN_INFO "comedi: failed to increment module count, skipping\n");
 			continue;
 		}
 		if (driv->num_names) {
@@ -205,9 +204,8 @@ int comedi_driver_unregister(struct comedi_driver *driver)
 		mutex_lock(&dev->mutex);
 		if (dev->attached && dev->driver == driver) {
 			if (dev->use_count)
-				printk
-				    (KERN_WARNING "BUG! detaching device with use_count=%d\n",
-				     dev->use_count);
+				printk(KERN_WARNING "BUG! detaching device with use_count=%d\n",
+						dev->use_count);
 			comedi_device_detach(dev);
 		}
 		mutex_unlock(&dev->mutex);
@@ -442,7 +440,9 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 		unsigned i;
 		for (i = 0; i < async->n_buf_pages; ++i) {
 			if (async->buf_page_list[i].virt_addr) {
-				clear_bit(PG_reserved, &(virt_to_page(async->buf_page_list[i].virt_addr)->flags));
+				clear_bit(PG_reserved,
+					&(virt_to_page(async->buf_page_list[i].
+							virt_addr)->flags));
 				if (s->async_dma_dir != DMA_NONE) {
 					dma_free_coherent(dev->hw_dev,
 							  PAGE_SIZE,
@@ -494,8 +494,10 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 					break;
 
 				set_bit(PG_reserved,
-					&(virt_to_page(async->buf_page_list[i].virt_addr)->flags));
-				pages[i] = virt_to_page(async->buf_page_list[i].virt_addr);
+					&(virt_to_page(async->buf_page_list[i].
+							virt_addr)->flags));
+				pages[i] = virt_to_page(async->buf_page_list[i].
+								virt_addr);
 			}
 		}
 		if (i == n_pages) {
@@ -512,7 +514,10 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 					    NULL) {
 						break;
 					}
-					clear_bit(PG_reserved, &(virt_to_page(async->buf_page_list[i].virt_addr)->flags));
+					clear_bit(PG_reserved,
+						&(virt_to_page(async->
+							buf_page_list[i].
+							virt_addr)->flags));
 					if (s->async_dma_dir != DMA_NONE) {
 						dma_free_coherent(dev->hw_dev,
 								  PAGE_SIZE,
@@ -644,8 +649,7 @@ unsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes)
 {
 	if ((int)(async->buf_write_count + nbytes -
 		  async->buf_write_alloc_count) > 0) {
-		printk
-		    (KERN_INFO "comedi: attempted to write-free more bytes than have been write-allocated.\n");
+		printk(KERN_INFO "comedi: attempted to write-free more bytes than have been write-allocated.\n");
 		nbytes = async->buf_write_alloc_count - async->buf_write_count;
 	}
 	async->buf_write_count += nbytes;

commit 5b84cc781058bb452f869d84bb24442ec51948c4
Author: Joe Perches <joe@perches.com>
Date:   Thu Nov 4 20:07:59 2010 -0700

    staging: Use vzalloc
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 4a29ed737e3f..ef24a530278b 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -470,10 +470,8 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 		struct page **pages = NULL;
 
 		async->buf_page_list =
-		    vmalloc(sizeof(struct comedi_buf_page) * n_pages);
+		    vzalloc(sizeof(struct comedi_buf_page) * n_pages);
 		if (async->buf_page_list) {
-			memset(async->buf_page_list, 0,
-			       sizeof(struct comedi_buf_page) * n_pages);
 			pages = vmalloc(sizeof(struct page *) * n_pages);
 		}
 		if (pages) {

commit 67b0e64a7b219550cc3378800f680e2bb86a10f9
Author: Mark Rankilor <reodge@gmail.com>
Date:   Thu May 6 17:36:38 2010 +0800

    Staging: comedi: Fixed printk call lengths and log levels
    
    This is a patch to include log levels and fix some over length lines in
    printk calls in drivers.c
    
    Signed-off-by: Mark Rankilor <reodge@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 1f48b6dca08b..4a29ed737e3f 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -95,7 +95,8 @@ static void __comedi_device_detach(struct comedi_device *dev)
 	if (dev->driver)
 		dev->driver->detach(dev);
 	else
-		printk(KERN_WARNING "BUG: dev->driver=NULL in comedi_device_detach()\n");
+		printk(KERN_WARNING
+		       "BUG: dev->driver=NULL in comedi_device_detach()\n");
 	cleanup_device(dev);
 }
 
@@ -148,7 +149,8 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/*  report valid board names before returning error */
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
-			printk(KERN_INFO "comedi: failed to increment module count\n");
+			printk(KERN_INFO
+			       "comedi: failed to increment module count\n");
 			continue;
 		}
 		comedi_report_boards(driv);
@@ -250,7 +252,8 @@ static int postconfig(struct comedi_device *dev)
 			async =
 			    kzalloc(sizeof(struct comedi_async), GFP_KERNEL);
 			if (async == NULL) {
-				printk(KERN_INFO "failed to allocate async struct\n");
+				printk(KERN_INFO
+				       "failed to allocate async struct\n");
 				return -ENOMEM;
 			}
 			init_waitqueue_head(&async->wait_head);
@@ -560,7 +563,8 @@ static unsigned int comedi_buf_munge(struct comedi_async *async,
 
 		block_size = num_bytes - count;
 		if (block_size < 0) {
-			printk(KERN_WARNING "%s: %s: bug! block_size is negative\n",
+			printk(KERN_WARNING
+			       "%s: %s: bug! block_size is negative\n",
 			       __FILE__, __func__);
 			break;
 		}
@@ -679,8 +683,8 @@ unsigned comedi_buf_read_free(struct comedi_async *async, unsigned int nbytes)
 	smp_mb();
 	if ((int)(async->buf_read_count + nbytes -
 		  async->buf_read_alloc_count) > 0) {
-		printk
-		    ("comedi: attempted to read-free more bytes than have been read-allocated.\n");
+		printk(KERN_INFO
+		       "comedi: attempted to read-free more bytes than have been read-allocated.\n");
 		nbytes = async->buf_read_alloc_count - async->buf_read_count;
 	}
 	async->buf_read_count += nbytes;

commit 7029a87455af3cf303e8d6d0db8c26b6a94f1020
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 3 15:55:45 2010 -0700

    Staging: comedi: drivers.c sparse cleanup
    
    Fix up some sparse issues in drivers.c
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index f68fab9c5509..1f48b6dca08b 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -54,16 +54,9 @@ static int insn_rw_emulate_bits(struct comedi_device *dev,
 static void *comedi_recognize(struct comedi_driver *driv, const char *name);
 static void comedi_report_boards(struct comedi_driver *driv);
 static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s);
-int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
-		     unsigned long new_size);
 
 struct comedi_driver *comedi_drivers;
 
-int comedi_modprobe(int minor)
-{
-	return -EINVAL;
-}
-
 static void cleanup_device(struct comedi_device *dev)
 {
 	int i;
@@ -84,7 +77,7 @@ static void cleanup_device(struct comedi_device *dev)
 	}
 	kfree(dev->private);
 	dev->private = NULL;
-	dev->driver = 0;
+	dev->driver = NULL;
 	dev->board_name = NULL;
 	dev->board_ptr = NULL;
 	dev->iobase = 0;
@@ -309,7 +302,7 @@ static int postconfig(struct comedi_device *dev)
 
 /* generic recognize function for drivers
  * that register their supported board names */
-void *comedi_recognize(struct comedi_driver *driv, const char *name)
+static void *comedi_recognize(struct comedi_driver *driv, const char *name)
 {
 	unsigned i;
 	const char *const *name_ptr = driv->board_name;
@@ -324,7 +317,7 @@ void *comedi_recognize(struct comedi_driver *driv, const char *name)
 	return NULL;
 }
 
-void comedi_report_boards(struct comedi_driver *driv)
+static void comedi_report_boards(struct comedi_driver *driv)
 {
 	unsigned int i;
 	const char *const *name_ptr;
@@ -548,8 +541,8 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 
 /* munging is applied to data by core as it passes between user
  * and kernel space */
-unsigned int comedi_buf_munge(struct comedi_async *async,
-			      unsigned int num_bytes)
+static unsigned int comedi_buf_munge(struct comedi_async *async,
+				     unsigned int num_bytes)
 {
 	struct comedi_subdevice *s = async->subdevice;
 	unsigned int count = 0;
@@ -812,8 +805,9 @@ void comedi_reset_async_buf(struct comedi_async *async)
 	async->events = 0;
 }
 
-int comedi_auto_config(struct device *hardware_device, const char *board_name,
-		       const int *options, unsigned num_options)
+static int comedi_auto_config(struct device *hardware_device,
+			      const char *board_name, const int *options,
+			      unsigned num_options)
 {
 	struct comedi_devconfig it;
 	int minor;
@@ -858,7 +852,7 @@ int comedi_auto_config(struct device *hardware_device, const char *board_name,
 	return retval;
 }
 
-void comedi_auto_unconfig(struct device *hardware_device)
+static void comedi_auto_unconfig(struct device *hardware_device)
 {
 	unsigned *minor = (unsigned *)dev_get_drvdata(hardware_device);
 	if (minor == NULL)

commit 09372df0dff51121e772ca5870fb565a08840c86
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 3 15:27:52 2010 -0700

    Staging: comedi: make comedi_reset_async_buf local to comedi core
    
    No one outside of the comedi core calls this function, so don't export
    it to the world.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 475778fb6801..f68fab9c5509 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -811,7 +811,6 @@ void comedi_reset_async_buf(struct comedi_async *async)
 
 	async->events = 0;
 }
-EXPORT_SYMBOL(comedi_reset_async_buf);
 
 int comedi_auto_config(struct device *hardware_device, const char *board_name,
 		       const int *options, unsigned num_options)

commit 242e7ad91a067243d7ab63b6a25ed2e085733446
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 3 15:20:29 2010 -0700

    Staging: comedi: make comedi_alloc_board_minor local to comedi core
    
    No one outside of the comedi core calls this function, so create
    an internal.h file to put the prototype in, and don't export
    it to the world.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index a8f3d790b3d5..475778fb6801 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -37,15 +37,16 @@
 #include <linux/ioport.h>
 #include <linux/mm.h>
 #include <linux/slab.h>
-#include "comedidev.h"
 #include <linux/highmem.h>	/* for SuSE brokenness */
 #include <linux/vmalloc.h>
 #include <linux/cdev.h>
 #include <linux/dma-mapping.h>
-
 #include <linux/io.h>
 #include <asm/system.h>
 
+#include "comedidev.h"
+#include "internal.h"
+
 static int postconfig(struct comedi_device *dev);
 static int insn_rw_emulate_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,

commit aad4029a49e17d8529b8b802d4ecd774ef941f7c
Author: Mark Rankilor <reodge@gmail.com>
Date:   Mon May 3 18:07:36 2010 +0800

    Staging: comedi: Adjusted some long line lengths in drivers.c
    
    This patch fixes some long line lengths in drivers.c that checkpatch.pl was
    complaining about
    
    Signed-off-by: Mark Rankilor <reodge@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index d7a450917405..a8f3d790b3d5 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -172,7 +172,8 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	if (!dev->board_name) {
-		printk(KERN_WARNING "BUG: dev->board_name=<%p>\n", dev->board_name);
+		printk(KERN_WARNING "BUG: dev->board_name=<%p>\n",
+		       dev->board_name);
 		dev->board_name = "BUG";
 	}
 	smp_wmb();
@@ -374,8 +375,9 @@ static int insn_rw_emulate_bits(struct comedi_device *dev,
 	if (insn->insn == INSN_WRITE) {
 		if (!(s->subdev_flags & SDF_WRITABLE))
 			return -EINVAL;
-		new_data[0] = 1 << (chan - base_bitfield_channel);	/* mask */
-		new_data[1] = data[0] ? (1 << (chan - base_bitfield_channel)) : 0;	/* bits */
+		new_data[0] = 1 << (chan - base_bitfield_channel); /* mask */
+		new_data[1] = data[0] ? (1 << (chan - base_bitfield_channel))
+			      : 0; /* bits */
 	}
 
 	ret = s->insn_bits(dev, s, &new_insn, new_data);

commit 4bf935596bfabe3f951bc0331ebd893ef06e1123
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat May 1 12:38:02 2010 -0700

    Staging: comedi: remove comedi_ksyms.c
    
    Move the 4 remaining exports to their function location
    and then remove the comedi_ksyms.c file, as it's no longer
    needed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 2b7eda501809..d7a450917405 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -881,20 +881,24 @@ int comedi_pci_auto_config(struct pci_dev *pcidev, const char *board_name)
 	return comedi_auto_config(&pcidev->dev, board_name,
 				  options, ARRAY_SIZE(options));
 }
+EXPORT_SYMBOL_GPL(comedi_pci_auto_config);
 
 void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
 {
 	comedi_auto_unconfig(&pcidev->dev);
 }
+EXPORT_SYMBOL_GPL(comedi_pci_auto_unconfig);
 
 int comedi_usb_auto_config(struct usb_device *usbdev, const char *board_name)
 {
 	BUG_ON(usbdev == NULL);
 	return comedi_auto_config(&usbdev->dev, board_name, NULL, 0);
 }
+EXPORT_SYMBOL_GPL(comedi_usb_auto_config);
 
 void comedi_usb_auto_unconfig(struct usb_device *usbdev)
 {
 	BUG_ON(usbdev == NULL);
 	comedi_auto_unconfig(&usbdev->dev);
 }
+EXPORT_SYMBOL_GPL(comedi_usb_auto_unconfig);

commit d58214b0b8662f1b27d538390ecc49bbea0cd754
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat May 1 11:54:07 2010 -0700

    Staging: comedi: move a bunch of EXPORT_SYMBOL lines
    
    Move the ones that are needed to be in drivers.c into the
    file.  This is with the goal of deleting the comedi_ksyms.c
    file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 800106ae9901..2b7eda501809 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -188,6 +188,7 @@ int comedi_driver_register(struct comedi_driver *driver)
 
 	return 0;
 }
+EXPORT_SYMBOL(comedi_driver_register);
 
 int comedi_driver_unregister(struct comedi_driver *driver)
 {
@@ -228,6 +229,7 @@ int comedi_driver_unregister(struct comedi_driver *driver)
 	}
 	return -EINVAL;
 }
+EXPORT_SYMBOL(comedi_driver_unregister);
 
 static int postconfig(struct comedi_device *dev)
 {
@@ -621,6 +623,7 @@ unsigned int comedi_buf_write_alloc(struct comedi_async *async,
 	smp_mb();
 	return nbytes;
 }
+EXPORT_SYMBOL(comedi_buf_write_alloc);
 
 /* allocates nothing unless it can completely fulfill the request */
 unsigned int comedi_buf_write_alloc_strict(struct comedi_async *async,
@@ -655,6 +658,7 @@ unsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes)
 
 	return nbytes;
 }
+EXPORT_SYMBOL(comedi_buf_write_free);
 
 /* allocates a chunk for the reader from filled (and munged) buffer space */
 unsigned comedi_buf_read_alloc(struct comedi_async *async, unsigned nbytes)
@@ -669,6 +673,7 @@ unsigned comedi_buf_read_alloc(struct comedi_async *async, unsigned nbytes)
 	smp_rmb();
 	return nbytes;
 }
+EXPORT_SYMBOL(comedi_buf_read_alloc);
 
 /* transfers control of a chunk from reader to free buffer space */
 unsigned comedi_buf_read_free(struct comedi_async *async, unsigned int nbytes)
@@ -687,6 +692,7 @@ unsigned comedi_buf_read_free(struct comedi_async *async, unsigned int nbytes)
 	async->buf_read_ptr %= async->prealloc_bufsz;
 	return nbytes;
 }
+EXPORT_SYMBOL(comedi_buf_read_free);
 
 void comedi_buf_memcpy_to(struct comedi_async *async, unsigned int offset,
 			  const void *data, unsigned int num_bytes)
@@ -712,6 +718,7 @@ void comedi_buf_memcpy_to(struct comedi_async *async, unsigned int offset,
 		write_ptr = 0;
 	}
 }
+EXPORT_SYMBOL(comedi_buf_memcpy_to);
 
 void comedi_buf_memcpy_from(struct comedi_async *async, unsigned int offset,
 			    void *dest, unsigned int nbytes)
@@ -738,6 +745,7 @@ void comedi_buf_memcpy_from(struct comedi_async *async, unsigned int offset,
 		read_ptr = 0;
 	}
 }
+EXPORT_SYMBOL(comedi_buf_memcpy_from);
 
 unsigned int comedi_buf_read_n_available(struct comedi_async *async)
 {
@@ -753,6 +761,7 @@ unsigned int comedi_buf_read_n_available(struct comedi_async *async)
 	smp_rmb();
 	return num_bytes;
 }
+EXPORT_SYMBOL(comedi_buf_read_n_available);
 
 int comedi_buf_get(struct comedi_async *async, short *x)
 {
@@ -765,6 +774,7 @@ int comedi_buf_get(struct comedi_async *async, short *x)
 	comedi_buf_read_free(async, sizeof(short));
 	return 1;
 }
+EXPORT_SYMBOL(comedi_buf_get);
 
 int comedi_buf_put(struct comedi_async *async, short x)
 {
@@ -778,6 +788,7 @@ int comedi_buf_put(struct comedi_async *async, short x)
 	comedi_buf_write_free(async, sizeof(short));
 	return 1;
 }
+EXPORT_SYMBOL(comedi_buf_put);
 
 void comedi_reset_async_buf(struct comedi_async *async)
 {
@@ -797,6 +808,7 @@ void comedi_reset_async_buf(struct comedi_async *async)
 
 	async->events = 0;
 }
+EXPORT_SYMBOL(comedi_reset_async_buf);
 
 int comedi_auto_config(struct device *hardware_device, const char *board_name,
 		       const int *options, unsigned num_options)

commit be29eac8ed3fd21d86f79d2e84dff49b8a13cd2c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 30 15:55:39 2010 -0700

    Staging: comedi: remove wrapper.h
    
    Just make the bit call when it is needed, no need to wrap
    things up like this for no reason.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 4b69d06ca735..800106ae9901 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -38,7 +38,6 @@
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include "comedidev.h"
-#include "wrapper.h"
 #include <linux/highmem.h>	/* for SuSE brokenness */
 #include <linux/vmalloc.h>
 #include <linux/cdev.h>
@@ -442,9 +441,7 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 		unsigned i;
 		for (i = 0; i < async->n_buf_pages; ++i) {
 			if (async->buf_page_list[i].virt_addr) {
-				mem_map_unreserve(virt_to_page
-						  (async->buf_page_list[i].
-						   virt_addr));
+				clear_bit(PG_reserved, &(virt_to_page(async->buf_page_list[i].virt_addr)->flags));
 				if (s->async_dma_dir != DMA_NONE) {
 					dma_free_coherent(dev->hw_dev,
 							  PAGE_SIZE,
@@ -497,12 +494,9 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 				if (async->buf_page_list[i].virt_addr == NULL)
 					break;
 
-				mem_map_reserve(virt_to_page
-						(async->buf_page_list[i].
-						 virt_addr));
-				pages[i] =
-				    virt_to_page(async->
-						 buf_page_list[i].virt_addr);
+				set_bit(PG_reserved,
+					&(virt_to_page(async->buf_page_list[i].virt_addr)->flags));
+				pages[i] = virt_to_page(async->buf_page_list[i].virt_addr);
 			}
 		}
 		if (i == n_pages) {
@@ -519,9 +513,7 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 					    NULL) {
 						break;
 					}
-					mem_map_unreserve(virt_to_page
-							  (async->buf_page_list
-							   [i].virt_addr));
+					clear_bit(PG_reserved, &(virt_to_page(async->buf_page_list[i].virt_addr)->flags));
 					if (s->async_dma_dir != DMA_NONE) {
 						dma_free_coherent(dev->hw_dev,
 								  PAGE_SIZE,

commit ac4898a0f81d3b3c218cb4d17bac1750ef82e456
Author: Zachary Richey <zr.public@gmail.com>
Date:   Mon Apr 26 07:49:37 2010 -0400

    Staging: comedi: fixed coding style issues in drivers.c
    
    This patch fixes coding style issues found by checkpatch.pl, and doesnt
    line break string literals.
    
    Signed-off-by: Zachary Richey <zr.public@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 44d6b62c230d..4b69d06ca735 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -102,7 +102,7 @@ static void __comedi_device_detach(struct comedi_device *dev)
 	if (dev->driver)
 		dev->driver->detach(dev);
 	else
-		printk("BUG: dev->driver=NULL in comedi_device_detach()\n");
+		printk(KERN_WARNING "BUG: dev->driver=NULL in comedi_device_detach()\n");
 	cleanup_device(dev);
 }
 
@@ -124,7 +124,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
 			printk
-			    ("comedi: failed to increment module count, skipping\n");
+			    (KERN_INFO "comedi: failed to increment module count, skipping\n");
 			continue;
 		}
 		if (driv->num_names) {
@@ -139,7 +139,8 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				continue;
 			}
 		}
-		/* initialize dev->driver here so comedi_error() can be called from attach */
+		/* initialize dev->driver here so
+		 * comedi_error() can be called from attach */
 		dev->driver = driv;
 		ret = driv->attach(dev, it);
 		if (ret < 0) {
@@ -154,7 +155,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/*  report valid board names before returning error */
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
-			printk("comedi: failed to increment module count\n");
+			printk(KERN_INFO "comedi: failed to increment module count\n");
 			continue;
 		}
 		comedi_report_boards(driv);
@@ -172,7 +173,7 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	if (!dev->board_name) {
-		printk("BUG: dev->board_name=<%p>\n", dev->board_name);
+		printk(KERN_WARNING "BUG: dev->board_name=<%p>\n", dev->board_name);
 		dev->board_name = "BUG";
 	}
 	smp_wmb();
@@ -208,7 +209,7 @@ int comedi_driver_unregister(struct comedi_driver *driver)
 		if (dev->attached && dev->driver == driver) {
 			if (dev->use_count)
 				printk
-				    ("BUG! detaching device with use_count=%d\n",
+				    (KERN_WARNING "BUG! detaching device with use_count=%d\n",
 				     dev->use_count);
 			comedi_device_detach(dev);
 		}
@@ -253,7 +254,7 @@ static int postconfig(struct comedi_device *dev)
 			async =
 			    kzalloc(sizeof(struct comedi_async), GFP_KERNEL);
 			if (async == NULL) {
-				printk("failed to allocate async struct\n");
+				printk(KERN_INFO "failed to allocate async struct\n");
 				return -ENOMEM;
 			}
 			init_waitqueue_head(&async->wait_head);
@@ -268,7 +269,7 @@ static int postconfig(struct comedi_device *dev)
 			async->prealloc_buf = NULL;
 			async->prealloc_bufsz = 0;
 			if (comedi_buf_alloc(dev, s, DEFAULT_BUF_SIZE) < 0) {
-				printk("Buffer allocation failed\n");
+				printk(KERN_INFO "Buffer allocation failed\n");
 				return -ENOMEM;
 			}
 			if (s->buf_change) {
@@ -303,7 +304,8 @@ static int postconfig(struct comedi_device *dev)
 	return 0;
 }
 
-/*  generic recognize function for drivers that register their supported board names */
+/* generic recognize function for drivers
+ * that register their supported board names */
 void *comedi_recognize(struct comedi_driver *driv, const char *name)
 {
 	unsigned i;
@@ -324,17 +326,17 @@ void comedi_report_boards(struct comedi_driver *driv)
 	unsigned int i;
 	const char *const *name_ptr;
 
-	printk("comedi: valid board names for %s driver are:\n",
+	printk(KERN_INFO "comedi: valid board names for %s driver are:\n",
 	       driv->driver_name);
 
 	name_ptr = driv->board_name;
 	for (i = 0; i < driv->num_names; i++) {
-		printk(" %s\n", *name_ptr);
+		printk(KERN_INFO " %s\n", *name_ptr);
 		name_ptr = (const char **)((char *)name_ptr + driv->offset);
 	}
 
 	if (driv->num_names == 0)
-		printk(" %s\n", driv->driver_name);
+		printk(KERN_INFO " %s\n", driv->driver_name);
 }
 
 static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -568,7 +570,7 @@ unsigned int comedi_buf_munge(struct comedi_async *async,
 
 		block_size = num_bytes - count;
 		if (block_size < 0) {
-			printk("%s: %s: bug! block_size is negative\n",
+			printk(KERN_WARNING "%s: %s: bug! block_size is negative\n",
 			       __FILE__, __func__);
 			break;
 		}
@@ -579,7 +581,8 @@ unsigned int comedi_buf_munge(struct comedi_async *async,
 		s->munge(s->device, s, async->prealloc_buf + async->munge_ptr,
 			 block_size, async->munge_chan);
 
-		smp_wmb();	/* barrier insures data is munged in buffer before munge_count is incremented */
+		smp_wmb();	/* barrier insures data is munged in buffer
+				 * before munge_count is incremented */
 
 		async->munge_chan += block_size / num_sample_bytes;
 		async->munge_chan %= async->cmd.chanlist_len;
@@ -649,7 +652,7 @@ unsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes)
 	if ((int)(async->buf_write_count + nbytes -
 		  async->buf_write_alloc_count) > 0) {
 		printk
-		    ("comedi: attempted to write-free more bytes than have been write-allocated.\n");
+		    (KERN_INFO "comedi: attempted to write-free more bytes than have been write-allocated.\n");
 		nbytes = async->buf_write_alloc_count - async->buf_write_count;
 	}
 	async->buf_write_count += nbytes;
@@ -678,7 +681,8 @@ unsigned comedi_buf_read_alloc(struct comedi_async *async, unsigned nbytes)
 /* transfers control of a chunk from reader to free buffer space */
 unsigned comedi_buf_read_free(struct comedi_async *async, unsigned int nbytes)
 {
-	/*  barrier insures data has been read out of buffer before read count is incremented */
+	/* barrier insures data has been read out of
+	 * buffer before read count is incremented */
 	smp_mb();
 	if ((int)(async->buf_read_count + nbytes -
 		  async->buf_read_alloc_count) > 0) {

commit 5617f9da4619ec975514e6b385a052e024215da3
Author: Andrea Gelmini <andrea.gelmini@gelma.net>
Date:   Fri Feb 26 17:37:00 2010 +0100

    Staging: comedi: drivers.c: Checkpatch cleanup
    
    WARNING: Use #include <linux/io.h> instead of <asm/io.h>
    +#include <asm/io.h>
    
    WARNING: braces {} are not necessary for any arm of this statement
    +       if (dev->driver) {
    [...]
    +       } else {
    [...]
    
    WARNING: braces {} are not necessary for single statement blocks
    +       if (insn->insn == INSN_READ) {
    +               data[0] = (new_data[1] >> (chan - base_bitfield_channel)) & 1;
    +       }
    
    WARNING: braces {} are not necessary for single statement blocks
    +       if (async->prealloc_buf && async->prealloc_bufsz == new_size) {
    +               return 0;
    +       }
    
    WARNING: braces {} are not necessary for single statement blocks
    +                               if (async->buf_page_list[i].virt_addr == NULL) {
    +                                       break;
    +                               }
    
    WARNING: braces {} are not necessary for single statement blocks
    +       if ((int)(async->buf_write_alloc_count + nbytes - free_end) > 0) {
    +               nbytes = free_end - async->buf_write_alloc_count;
    +       }
    
    WARNING: braces {} are not necessary for single statement blocks
    +       if ((int)(async->buf_write_alloc_count + nbytes - free_end) > 0) {
    +               nbytes = 0;
    +       }
    
    WARNING: braces {} are not necessary for single statement blocks
    +       if (async->buf_write_ptr >= async->prealloc_bufsz) {
    +               async->buf_write_ptr %= async->prealloc_bufsz;
    +       }
    
    Signed-off-by: Andrea Gelmini <andrea.gelmini@gelma.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index c2a632d31c61..44d6b62c230d 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -44,7 +44,7 @@
 #include <linux/cdev.h>
 #include <linux/dma-mapping.h>
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <asm/system.h>
 
 static int postconfig(struct comedi_device *dev);
@@ -99,11 +99,10 @@ static void cleanup_device(struct comedi_device *dev)
 static void __comedi_device_detach(struct comedi_device *dev)
 {
 	dev->attached = 0;
-	if (dev->driver) {
+	if (dev->driver)
 		dev->driver->detach(dev);
-	} else {
+	else
 		printk("BUG: dev->driver=NULL in comedi_device_detach()\n");
-	}
 	cleanup_device(dev);
 }
 
@@ -380,9 +379,8 @@ static int insn_rw_emulate_bits(struct comedi_device *dev,
 	if (ret < 0)
 		return ret;
 
-	if (insn->insn == INSN_READ) {
+	if (insn->insn == INSN_READ)
 		data[0] = (new_data[1] >> (chan - base_bitfield_channel)) & 1;
-	}
 
 	return 1;
 }
@@ -429,9 +427,9 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 	new_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;
 
 	/* if no change is required, do nothing */
-	if (async->prealloc_buf && async->prealloc_bufsz == new_size) {
+	if (async->prealloc_buf && async->prealloc_bufsz == new_size)
 		return 0;
-	}
+
 	/*  deallocate old buffer */
 	if (async->prealloc_buf) {
 		vunmap(async->prealloc_buf);
@@ -494,9 +492,9 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 					    (void *)
 					    get_zeroed_page(GFP_KERNEL);
 				}
-				if (async->buf_page_list[i].virt_addr == NULL) {
+				if (async->buf_page_list[i].virt_addr == NULL)
 					break;
-				}
+
 				mem_map_reserve(virt_to_page
 						(async->buf_page_list[i].
 						 virt_addr));
@@ -619,9 +617,9 @@ unsigned int comedi_buf_write_alloc(struct comedi_async *async,
 {
 	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
 
-	if ((int)(async->buf_write_alloc_count + nbytes - free_end) > 0) {
+	if ((int)(async->buf_write_alloc_count + nbytes - free_end) > 0)
 		nbytes = free_end - async->buf_write_alloc_count;
-	}
+
 	async->buf_write_alloc_count += nbytes;
 	/* barrier insures the read of buf_read_count above occurs before
 	   we write data to the write-alloc'ed buffer space */
@@ -635,9 +633,9 @@ unsigned int comedi_buf_write_alloc_strict(struct comedi_async *async,
 {
 	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
 
-	if ((int)(async->buf_write_alloc_count + nbytes - free_end) > 0) {
+	if ((int)(async->buf_write_alloc_count + nbytes - free_end) > 0)
 		nbytes = 0;
-	}
+
 	async->buf_write_alloc_count += nbytes;
 	/* barrier insures the read of buf_read_count above occurs before
 	   we write data to the write-alloc'ed buffer space */
@@ -657,9 +655,9 @@ unsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes)
 	async->buf_write_count += nbytes;
 	async->buf_write_ptr += nbytes;
 	comedi_buf_munge(async, async->buf_write_count - async->munge_count);
-	if (async->buf_write_ptr >= async->prealloc_bufsz) {
+	if (async->buf_write_ptr >= async->prealloc_bufsz)
 		async->buf_write_ptr %= async->prealloc_bufsz;
-	}
+
 	return nbytes;
 }
 

commit d43d27abf7a2e8388bb0b1d9bf33bd427bc2137a
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Sep 21 11:53:27 2009 -0700

    Staging: comedi: drivers.c: checkpatch fix
    
    Fix a checkpatch.pl error. Fix struct * foo to struct *foo
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index dc53aeeac68f..c2a632d31c61 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -387,7 +387,7 @@ static int insn_rw_emulate_bits(struct comedi_device *dev,
 	return 1;
 }
 
-static inline unsigned long uvirt_to_kva(pgd_t * pgd, unsigned long adr)
+static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
 {
 	unsigned long ret = 0UL;
 	pmd_t *pmd;

commit b455073c885cf78cfea1704ce9587806ec8e3c30
Author: Figo.zhang <figo1802@gmail.com>
Date:   Sat Jun 6 19:11:31 2009 +0800

    Staging: comedi: no need for checking vfree call
    
    vfree() does it's own NULL checking,so no need for check before
    calling it.
    
    'pages' is local variable argment,so in v2, it is no need assignment
     to NULL.
    
    Signed-off-by: Figo.zhang <figo1802@gmail.com>
    Acked-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 5157c89ec4ee..dc53aeeac68f 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -509,9 +509,8 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 			async->prealloc_buf =
 			    vmap(pages, n_pages, VM_MAP, PAGE_KERNEL_NOCACHE);
 		}
-		if (pages) {
-			vfree(pages);
-		}
+		vfree(pages);
+
 		if (async->prealloc_buf == NULL) {
 			/* Some allocation failed above. */
 			if (async->buf_page_list) {

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 42a02571ff1b..5157c89ec4ee 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -48,13 +48,14 @@
 #include <asm/system.h>
 
 static int postconfig(struct comedi_device *dev);
-static int insn_rw_emulate_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static void *comedi_recognize(struct comedi_driver * driv, const char *name);
+static int insn_rw_emulate_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static void *comedi_recognize(struct comedi_driver *driv, const char *name);
 static void comedi_report_boards(struct comedi_driver *driv);
 static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s);
 int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size);
+		     unsigned long new_size);
 
 struct comedi_driver *comedi_drivers;
 
@@ -123,7 +124,8 @@ int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
-			printk("comedi: failed to increment module count, skipping\n");
+			printk
+			    ("comedi: failed to increment module count, skipping\n");
 			continue;
 		}
 		if (driv->num_names) {
@@ -195,16 +197,20 @@ int comedi_driver_unregister(struct comedi_driver *driver)
 
 	/* check for devices using this driver */
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
-		struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(i);
+		struct comedi_device_file_info *dev_file_info =
+		    comedi_get_device_file_info(i);
 		struct comedi_device *dev;
 
-		if (dev_file_info == NULL) continue;
+		if (dev_file_info == NULL)
+			continue;
 		dev = dev_file_info->device;
 
 		mutex_lock(&dev->mutex);
 		if (dev->attached && dev->driver == driver) {
 			if (dev->use_count)
-				printk("BUG! detaching device with use_count=%d\n", dev->use_count);
+				printk
+				    ("BUG! detaching device with use_count=%d\n",
+				     dev->use_count);
 			comedi_device_detach(dev);
 		}
 		mutex_unlock(&dev->mutex);
@@ -242,10 +248,11 @@ static int postconfig(struct comedi_device *dev)
 
 		if (s->do_cmd) {
 			BUG_ON((s->subdev_flags & (SDF_CMD_READ |
-				SDF_CMD_WRITE)) == 0);
+						   SDF_CMD_WRITE)) == 0);
 			BUG_ON(!s->do_cmdtest);
 
-			async = kzalloc(sizeof(struct comedi_async), GFP_KERNEL);
+			async =
+			    kzalloc(sizeof(struct comedi_async), GFP_KERNEL);
 			if (async == NULL) {
 				printk("failed to allocate async struct\n");
 				return -ENOMEM;
@@ -298,7 +305,7 @@ static int postconfig(struct comedi_device *dev)
 }
 
 /*  generic recognize function for drivers that register their supported board names */
-void *comedi_recognize(struct comedi_driver * driv, const char *name)
+void *comedi_recognize(struct comedi_driver *driv, const char *name)
 {
 	unsigned i;
 	const char *const *name_ptr = driv->board_name;
@@ -306,8 +313,8 @@ void *comedi_recognize(struct comedi_driver * driv, const char *name)
 		if (strcmp(*name_ptr, name) == 0)
 			return (void *)name_ptr;
 		name_ptr =
-			(const char *const *)((const char *)name_ptr +
-			driv->offset);
+		    (const char *const *)((const char *)name_ptr +
+					  driv->offset);
 	}
 
 	return NULL;
@@ -319,7 +326,7 @@ void comedi_report_boards(struct comedi_driver *driv)
 	const char *const *name_ptr;
 
 	printk("comedi: valid board names for %s driver are:\n",
-		driv->driver_name);
+	       driv->driver_name);
 
 	name_ptr = driv->board_name;
 	for (i = 0; i < driv->num_names; i++) {
@@ -337,13 +344,14 @@ static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+	       struct comedi_insn *insn, unsigned int *data)
 {
 	return -EINVAL;
 }
 
-static int insn_rw_emulate_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int insn_rw_emulate_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	struct comedi_insn new_insn;
 	int ret;
@@ -351,7 +359,7 @@ static int insn_rw_emulate_bits(struct comedi_device *dev, struct comedi_subdevi
 
 	unsigned chan = CR_CHAN(insn->chanspec);
 	const unsigned base_bitfield_channel =
-		(chan < channels_per_bitfield) ? 0 : chan;
+	    (chan < channels_per_bitfield) ? 0 : chan;
 	unsigned int new_data[2];
 	memset(new_data, 0, sizeof(new_data));
 	memset(&new_insn, 0, sizeof(new_insn));
@@ -379,7 +387,7 @@ static int insn_rw_emulate_bits(struct comedi_device *dev, struct comedi_subdevi
 	return 1;
 }
 
-static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
+static inline unsigned long uvirt_to_kva(pgd_t * pgd, unsigned long adr)
 {
 	unsigned long ret = 0UL;
 	pmd_t *pmd;
@@ -394,7 +402,7 @@ static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
 			pte = *ptep;
 			if (pte_present(pte)) {
 				ret = (unsigned long)
-					page_address(pte_page(pte));
+				    page_address(pte_page(pte));
 				ret |= (adr & (PAGE_SIZE - 1));
 			}
 		}
@@ -413,7 +421,7 @@ static inline unsigned long kvirt_to_kva(unsigned long adr)
 }
 
 int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size)
+		     unsigned long new_size)
 {
 	struct comedi_async *async = s->async;
 
@@ -434,18 +442,22 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 		unsigned i;
 		for (i = 0; i < async->n_buf_pages; ++i) {
 			if (async->buf_page_list[i].virt_addr) {
-				mem_map_unreserve(virt_to_page(async->
-						buf_page_list[i].virt_addr));
+				mem_map_unreserve(virt_to_page
+						  (async->buf_page_list[i].
+						   virt_addr));
 				if (s->async_dma_dir != DMA_NONE) {
 					dma_free_coherent(dev->hw_dev,
-						PAGE_SIZE,
-						async->buf_page_list[i].
-						virt_addr,
-						async->buf_page_list[i].
-						dma_addr);
+							  PAGE_SIZE,
+							  async->
+							  buf_page_list
+							  [i].virt_addr,
+							  async->
+							  buf_page_list
+							  [i].dma_addr);
 				} else {
-					free_page((unsigned long)async->
-						buf_page_list[i].virt_addr);
+					free_page((unsigned long)
+						  async->buf_page_list[i].
+						  virt_addr);
 				}
 			}
 		}
@@ -460,40 +472,42 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 		struct page **pages = NULL;
 
 		async->buf_page_list =
-			vmalloc(sizeof(struct comedi_buf_page) * n_pages);
+		    vmalloc(sizeof(struct comedi_buf_page) * n_pages);
 		if (async->buf_page_list) {
 			memset(async->buf_page_list, 0,
-				sizeof(struct comedi_buf_page) * n_pages);
+			       sizeof(struct comedi_buf_page) * n_pages);
 			pages = vmalloc(sizeof(struct page *) * n_pages);
 		}
 		if (pages) {
 			for (i = 0; i < n_pages; i++) {
 				if (s->async_dma_dir != DMA_NONE) {
 					async->buf_page_list[i].virt_addr =
-						dma_alloc_coherent(dev->hw_dev,
-						PAGE_SIZE,
-						&async->buf_page_list[i].
-						dma_addr,
-						GFP_KERNEL | __GFP_COMP);
+					    dma_alloc_coherent(dev->hw_dev,
+							       PAGE_SIZE,
+							       &async->
+							       buf_page_list
+							       [i].dma_addr,
+							       GFP_KERNEL |
+							       __GFP_COMP);
 				} else {
 					async->buf_page_list[i].virt_addr =
-						(void *)
-						get_zeroed_page(GFP_KERNEL);
+					    (void *)
+					    get_zeroed_page(GFP_KERNEL);
 				}
 				if (async->buf_page_list[i].virt_addr == NULL) {
 					break;
 				}
-				mem_map_reserve(virt_to_page(async->
-						buf_page_list[i].virt_addr));
+				mem_map_reserve(virt_to_page
+						(async->buf_page_list[i].
+						 virt_addr));
 				pages[i] =
-					virt_to_page(async->buf_page_list[i].
-					virt_addr);
+				    virt_to_page(async->
+						 buf_page_list[i].virt_addr);
 			}
 		}
 		if (i == n_pages) {
 			async->prealloc_buf =
-				vmap(pages, n_pages, VM_MAP,
-				PAGE_KERNEL_NOCACHE);
+			    vmap(pages, n_pages, VM_MAP, PAGE_KERNEL_NOCACHE);
 		}
 		if (pages) {
 			vfree(pages);
@@ -503,23 +517,25 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 			if (async->buf_page_list) {
 				for (i = 0; i < n_pages; i++) {
 					if (async->buf_page_list[i].virt_addr ==
-						NULL) {
+					    NULL) {
 						break;
 					}
-					mem_map_unreserve(virt_to_page(async->
-							buf_page_list[i].
-							virt_addr));
+					mem_map_unreserve(virt_to_page
+							  (async->buf_page_list
+							   [i].virt_addr));
 					if (s->async_dma_dir != DMA_NONE) {
 						dma_free_coherent(dev->hw_dev,
-							PAGE_SIZE,
-							async->buf_page_list[i].
-							virt_addr,
-							async->buf_page_list[i].
-							dma_addr);
+								  PAGE_SIZE,
+								  async->
+								  buf_page_list
+								  [i].virt_addr,
+								  async->
+								  buf_page_list
+								  [i].dma_addr);
 					} else {
-						free_page((unsigned long)async->
-							buf_page_list[i].
-							virt_addr);
+						free_page((unsigned long)
+							  async->buf_page_list
+							  [i].virt_addr);
 					}
 				}
 				vfree(async->buf_page_list);
@@ -536,7 +552,8 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 
 /* munging is applied to data by core as it passes between user
  * and kernel space */
-unsigned int comedi_buf_munge(struct comedi_async *async, unsigned int num_bytes)
+unsigned int comedi_buf_munge(struct comedi_async *async,
+			      unsigned int num_bytes)
 {
 	struct comedi_subdevice *s = async->subdevice;
 	unsigned int count = 0;
@@ -555,15 +572,15 @@ unsigned int comedi_buf_munge(struct comedi_async *async, unsigned int num_bytes
 		block_size = num_bytes - count;
 		if (block_size < 0) {
 			printk("%s: %s: bug! block_size is negative\n",
-				__FILE__, __func__);
+			       __FILE__, __func__);
 			break;
 		}
 		if ((int)(async->munge_ptr + block_size -
-				async->prealloc_bufsz) > 0)
+			  async->prealloc_bufsz) > 0)
 			block_size = async->prealloc_bufsz - async->munge_ptr;
 
 		s->munge(s->device, s, async->prealloc_buf + async->munge_ptr,
-			block_size, async->munge_chan);
+			 block_size, async->munge_chan);
 
 		smp_wmb();	/* barrier insures data is munged in buffer before munge_count is incremented */
 
@@ -598,7 +615,8 @@ unsigned int comedi_buf_write_n_available(struct comedi_async *async)
 }
 
 /* allocates chunk for the writer from free buffer space */
-unsigned int comedi_buf_write_alloc(struct comedi_async *async, unsigned int nbytes)
+unsigned int comedi_buf_write_alloc(struct comedi_async *async,
+				    unsigned int nbytes)
 {
 	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
 
@@ -614,7 +632,7 @@ unsigned int comedi_buf_write_alloc(struct comedi_async *async, unsigned int nby
 
 /* allocates nothing unless it can completely fulfill the request */
 unsigned int comedi_buf_write_alloc_strict(struct comedi_async *async,
-	unsigned int nbytes)
+					   unsigned int nbytes)
 {
 	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
 
@@ -632,8 +650,9 @@ unsigned int comedi_buf_write_alloc_strict(struct comedi_async *async,
 unsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes)
 {
 	if ((int)(async->buf_write_count + nbytes -
-			async->buf_write_alloc_count) > 0) {
-		printk("comedi: attempted to write-free more bytes than have been write-allocated.\n");
+		  async->buf_write_alloc_count) > 0) {
+		printk
+		    ("comedi: attempted to write-free more bytes than have been write-allocated.\n");
 		nbytes = async->buf_write_alloc_count - async->buf_write_count;
 	}
 	async->buf_write_count += nbytes;
@@ -649,7 +668,7 @@ unsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes)
 unsigned comedi_buf_read_alloc(struct comedi_async *async, unsigned nbytes)
 {
 	if ((int)(async->buf_read_alloc_count + nbytes - async->munge_count) >
-		0) {
+	    0) {
 		nbytes = async->munge_count - async->buf_read_alloc_count;
 	}
 	async->buf_read_alloc_count += nbytes;
@@ -665,8 +684,9 @@ unsigned comedi_buf_read_free(struct comedi_async *async, unsigned int nbytes)
 	/*  barrier insures data has been read out of buffer before read count is incremented */
 	smp_mb();
 	if ((int)(async->buf_read_count + nbytes -
-			async->buf_read_alloc_count) > 0) {
-		printk("comedi: attempted to read-free more bytes than have been read-allocated.\n");
+		  async->buf_read_alloc_count) > 0) {
+		printk
+		    ("comedi: attempted to read-free more bytes than have been read-allocated.\n");
 		nbytes = async->buf_read_alloc_count - async->buf_read_count;
 	}
 	async->buf_read_count += nbytes;
@@ -676,7 +696,7 @@ unsigned comedi_buf_read_free(struct comedi_async *async, unsigned int nbytes)
 }
 
 void comedi_buf_memcpy_to(struct comedi_async *async, unsigned int offset,
-	const void *data, unsigned int num_bytes)
+			  const void *data, unsigned int num_bytes)
 {
 	unsigned int write_ptr = async->buf_write_ptr + offset;
 
@@ -701,7 +721,7 @@ void comedi_buf_memcpy_to(struct comedi_async *async, unsigned int offset,
 }
 
 void comedi_buf_memcpy_from(struct comedi_async *async, unsigned int offset,
-	void *dest, unsigned int nbytes)
+			    void *dest, unsigned int nbytes)
 {
 	void *src;
 	unsigned int read_ptr = async->buf_read_ptr + offset;
@@ -748,7 +768,7 @@ int comedi_buf_get(struct comedi_async *async, short *x)
 	if (n < sizeof(short))
 		return 0;
 	comedi_buf_read_alloc(async, sizeof(short));
-	*x = *(short *) (async->prealloc_buf + async->buf_read_ptr);
+	*x = *(short *)(async->prealloc_buf + async->buf_read_ptr);
 	comedi_buf_read_free(async, sizeof(short));
 	return 1;
 }
@@ -761,7 +781,7 @@ int comedi_buf_put(struct comedi_async *async, short x)
 		async->events |= COMEDI_CB_ERROR;
 		return 0;
 	}
-	*(short *) (async->prealloc_buf + async->buf_write_ptr) = x;
+	*(short *)(async->prealloc_buf + async->buf_write_ptr) = x;
 	comedi_buf_write_free(async, sizeof(short));
 	return 1;
 }
@@ -785,7 +805,8 @@ void comedi_reset_async_buf(struct comedi_async *async)
 	async->events = 0;
 }
 
-int comedi_auto_config(struct device *hardware_device, const char *board_name, const int *options, unsigned num_options)
+int comedi_auto_config(struct device *hardware_device, const char *board_name,
+		       const int *options, unsigned num_options)
 {
 	struct comedi_devconfig it;
 	int minor;
@@ -799,7 +820,8 @@ int comedi_auto_config(struct device *hardware_device, const char *board_name, c
 	}
 
 	minor = comedi_alloc_board_minor(hardware_device);
-	if (minor < 0) return minor;
+	if (minor < 0)
+		return minor;
 
 	private_data = kmalloc(sizeof(unsigned), GFP_KERNEL);
 	if (private_data == NULL) {
@@ -822,8 +844,7 @@ int comedi_auto_config(struct device *hardware_device, const char *board_name, c
 	mutex_unlock(&dev_file_info->device->mutex);
 
 cleanup:
-	if (retval < 0)
-	{
+	if (retval < 0) {
 		kfree(private_data);
 		comedi_free_board_minor(minor);
 	}
@@ -833,7 +854,8 @@ int comedi_auto_config(struct device *hardware_device, const char *board_name, c
 void comedi_auto_unconfig(struct device *hardware_device)
 {
 	unsigned *minor = (unsigned *)dev_get_drvdata(hardware_device);
-	if (minor == NULL) return;
+	if (minor == NULL)
+		return;
 
 	BUG_ON(*minor >= COMEDI_NUM_BOARD_MINORS);
 
@@ -860,8 +882,7 @@ void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
 	comedi_auto_unconfig(&pcidev->dev);
 }
 
-int comedi_usb_auto_config(struct usb_device *usbdev,
-	const char *board_name)
+int comedi_usb_auto_config(struct usb_device *usbdev, const char *board_name)
 {
 	BUG_ON(usbdev == NULL);
 	return comedi_auto_config(&usbdev->dev, board_name, NULL, 0);

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index e5185ac3604c..42a02571ff1b 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -554,7 +554,7 @@ unsigned int comedi_buf_munge(struct comedi_async *async, unsigned int num_bytes
 
 		block_size = num_bytes - count;
 		if (block_size < 0) {
-			rt_printk("%s: %s: bug! block_size is negative\n",
+			printk("%s: %s: bug! block_size is negative\n",
 				__FILE__, __func__);
 			break;
 		}
@@ -633,8 +633,7 @@ unsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes)
 {
 	if ((int)(async->buf_write_count + nbytes -
 			async->buf_write_alloc_count) > 0) {
-		rt_printk
-			("comedi: attempted to write-free more bytes than have been write-allocated.\n");
+		printk("comedi: attempted to write-free more bytes than have been write-allocated.\n");
 		nbytes = async->buf_write_alloc_count - async->buf_write_count;
 	}
 	async->buf_write_count += nbytes;
@@ -667,8 +666,7 @@ unsigned comedi_buf_read_free(struct comedi_async *async, unsigned int nbytes)
 	smp_mb();
 	if ((int)(async->buf_read_count + nbytes -
 			async->buf_read_alloc_count) > 0) {
-		rt_printk
-			("comedi: attempted to read-free more bytes than have been read-allocated.\n");
+		printk("comedi: attempted to read-free more bytes than have been read-allocated.\n");
 		nbytes = async->buf_read_alloc_count - async->buf_read_count;
 	}
 	async->buf_read_count += nbytes;

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index cabbf090f60b..e5185ac3604c 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -853,7 +853,8 @@ int comedi_pci_auto_config(struct pci_dev *pcidev, const char *board_name)
 	/*  pci slot */
 	options[1] = PCI_SLOT(pcidev->devfn);
 
-	return comedi_auto_config(&pcidev->dev, board_name, options, sizeof(options) / sizeof(options[0]));
+	return comedi_auto_config(&pcidev->dev, board_name,
+				  options, ARRAY_SIZE(options));
 }
 
 void comedi_pci_auto_unconfig(struct pci_dev *pcidev)

commit 53106ae68acf6eda9593150a25fc44e30fd5ff68
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:21 2009 -0400

    Staging Comedi: fix spacing around parens
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 6e13e450dc73..cabbf090f60b 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -198,7 +198,7 @@ int comedi_driver_unregister(struct comedi_driver *driver)
 		struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(i);
 		struct comedi_device *dev;
 
-		if(dev_file_info == NULL) continue;
+		if (dev_file_info == NULL) continue;
 		dev = dev_file_info->device;
 
 		mutex_lock(&dev->mutex);
@@ -801,7 +801,7 @@ int comedi_auto_config(struct device *hardware_device, const char *board_name, c
 	}
 
 	minor = comedi_alloc_board_minor(hardware_device);
-	if(minor < 0) return minor;
+	if (minor < 0) return minor;
 
 	private_data = kmalloc(sizeof(unsigned), GFP_KERNEL);
 	if (private_data == NULL) {
@@ -824,7 +824,7 @@ int comedi_auto_config(struct device *hardware_device, const char *board_name, c
 	mutex_unlock(&dev_file_info->device->mutex);
 
 cleanup:
-	if(retval < 0)
+	if (retval < 0)
 	{
 		kfree(private_data);
 		comedi_free_board_minor(minor);
@@ -835,7 +835,7 @@ int comedi_auto_config(struct device *hardware_device, const char *board_name, c
 void comedi_auto_unconfig(struct device *hardware_device)
 {
 	unsigned *minor = (unsigned *)dev_get_drvdata(hardware_device);
-	if(minor == NULL) return;
+	if (minor == NULL) return;
 
 	BUG_ON(*minor >= COMEDI_NUM_BOARD_MINORS);
 

commit 2961f24f78f456a0a2d0dada56ee795232fe21b3
Author: Stoyan Gaydarov <stoyboyker@gmail.com>
Date:   Tue Mar 10 00:10:27 2009 -0500

    Staging: BUG to BUG_ON changes
    
    Signed-off-by: Stoyan Gaydarov <stoyboyker@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 3e397d01ccce..6e13e450dc73 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -544,8 +544,7 @@ unsigned int comedi_buf_munge(struct comedi_async *async, unsigned int num_bytes
 
 	if (s->munge == NULL || (async->cmd.flags & CMDF_RAWDATA)) {
 		async->munge_count += num_bytes;
-		if ((int)(async->munge_count - async->buf_write_count) > 0)
-			BUG();
+		BUG_ON((int)(async->munge_count - async->buf_write_count) > 0);
 		return num_bytes;
 	}
 	/* don't munge partial samples */
@@ -575,8 +574,7 @@ unsigned int comedi_buf_munge(struct comedi_async *async, unsigned int num_bytes
 		async->munge_ptr %= async->prealloc_bufsz;
 		count += block_size;
 	}
-	if ((int)(async->munge_count - async->buf_write_count) > 0)
-		BUG();
+	BUG_ON((int)(async->munge_count - async->buf_write_count) > 0);
 	return count;
 }
 

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 9728c7430f8b..3e397d01ccce 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -113,7 +113,7 @@ void comedi_device_detach(struct comedi_device *dev)
 	__comedi_device_detach(dev);
 }
 
-int comedi_device_attach(struct comedi_device *dev, comedi_devconfig *it)
+int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_driver *driv;
 	int ret;
@@ -791,7 +791,7 @@ void comedi_reset_async_buf(struct comedi_async *async)
 
 int comedi_auto_config(struct device *hardware_device, const char *board_name, const int *options, unsigned num_options)
 {
-	comedi_devconfig it;
+	struct comedi_devconfig it;
 	int minor;
 	struct comedi_device_file_info *dev_file_info;
 	int retval;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 2d09a01c86c3..9728c7430f8b 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -49,7 +49,7 @@
 
 static int postconfig(struct comedi_device *dev);
 static int insn_rw_emulate_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data);
+	struct comedi_insn *insn, unsigned int *data);
 static void *comedi_recognize(struct comedi_driver * driv, const char *name);
 static void comedi_report_boards(struct comedi_driver *driv);
 static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s);
@@ -337,15 +337,15 @@ static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data)
+	struct comedi_insn *insn, unsigned int *data)
 {
 	return -EINVAL;
 }
 
 static int insn_rw_emulate_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data)
+	struct comedi_insn *insn, unsigned int *data)
 {
-	comedi_insn new_insn;
+	struct comedi_insn new_insn;
 	int ret;
 	static const unsigned channels_per_bitfield = 32;
 

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 30e3beb6e97b..2d09a01c86c3 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -50,13 +50,13 @@
 static int postconfig(struct comedi_device *dev);
 static int insn_rw_emulate_bits(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static void *comedi_recognize(comedi_driver * driv, const char *name);
-static void comedi_report_boards(comedi_driver *driv);
+static void *comedi_recognize(struct comedi_driver * driv, const char *name);
+static void comedi_report_boards(struct comedi_driver *driv);
 static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s);
 int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned long new_size);
 
-comedi_driver *comedi_drivers;
+struct comedi_driver *comedi_drivers;
 
 int comedi_modprobe(int minor)
 {
@@ -115,7 +115,7 @@ void comedi_device_detach(struct comedi_device *dev)
 
 int comedi_device_attach(struct comedi_device *dev, comedi_devconfig *it)
 {
-	comedi_driver *driv;
+	struct comedi_driver *driv;
 	int ret;
 
 	if (dev->attached)
@@ -180,7 +180,7 @@ int comedi_device_attach(struct comedi_device *dev, comedi_devconfig *it)
 	return 0;
 }
 
-int comedi_driver_register(comedi_driver *driver)
+int comedi_driver_register(struct comedi_driver *driver)
 {
 	driver->next = comedi_drivers;
 	comedi_drivers = driver;
@@ -188,9 +188,9 @@ int comedi_driver_register(comedi_driver *driver)
 	return 0;
 }
 
-int comedi_driver_unregister(comedi_driver *driver)
+int comedi_driver_unregister(struct comedi_driver *driver)
 {
-	comedi_driver *prev;
+	struct comedi_driver *prev;
 	int i;
 
 	/* check for devices using this driver */
@@ -298,7 +298,7 @@ static int postconfig(struct comedi_device *dev)
 }
 
 /*  generic recognize function for drivers that register their supported board names */
-void *comedi_recognize(comedi_driver * driv, const char *name)
+void *comedi_recognize(struct comedi_driver * driv, const char *name)
 {
 	unsigned i;
 	const char *const *name_ptr = driv->board_name;
@@ -313,7 +313,7 @@ void *comedi_recognize(comedi_driver * driv, const char *name)
 	return NULL;
 }
 
-void comedi_report_boards(comedi_driver *driv)
+void comedi_report_boards(struct comedi_driver *driv)
 {
 	unsigned int i;
 	const char *const *name_ptr;

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 32f3aca2d7f4..30e3beb6e97b 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -228,7 +228,7 @@ static int postconfig(struct comedi_device *dev)
 {
 	int i;
 	struct comedi_subdevice *s;
-	comedi_async *async = NULL;
+	struct comedi_async *async = NULL;
 	int ret;
 
 	for (i = 0; i < dev->n_subdevices; i++) {
@@ -245,7 +245,7 @@ static int postconfig(struct comedi_device *dev)
 				SDF_CMD_WRITE)) == 0);
 			BUG_ON(!s->do_cmdtest);
 
-			async = kzalloc(sizeof(comedi_async), GFP_KERNEL);
+			async = kzalloc(sizeof(struct comedi_async), GFP_KERNEL);
 			if (async == NULL) {
 				printk("failed to allocate async struct\n");
 				return -ENOMEM;
@@ -415,7 +415,7 @@ static inline unsigned long kvirt_to_kva(unsigned long adr)
 int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned long new_size)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 
 	/* Round up new_size to multiple of PAGE_SIZE */
 	new_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;
@@ -536,7 +536,7 @@ int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 
 /* munging is applied to data by core as it passes between user
  * and kernel space */
-unsigned int comedi_buf_munge(comedi_async *async, unsigned int num_bytes)
+unsigned int comedi_buf_munge(struct comedi_async *async, unsigned int num_bytes)
 {
 	struct comedi_subdevice *s = async->subdevice;
 	unsigned int count = 0;
@@ -580,7 +580,7 @@ unsigned int comedi_buf_munge(comedi_async *async, unsigned int num_bytes)
 	return count;
 }
 
-unsigned int comedi_buf_write_n_available(comedi_async *async)
+unsigned int comedi_buf_write_n_available(struct comedi_async *async)
 {
 	unsigned int free_end;
 	unsigned int nbytes;
@@ -600,7 +600,7 @@ unsigned int comedi_buf_write_n_available(comedi_async *async)
 }
 
 /* allocates chunk for the writer from free buffer space */
-unsigned int comedi_buf_write_alloc(comedi_async *async, unsigned int nbytes)
+unsigned int comedi_buf_write_alloc(struct comedi_async *async, unsigned int nbytes)
 {
 	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
 
@@ -615,7 +615,7 @@ unsigned int comedi_buf_write_alloc(comedi_async *async, unsigned int nbytes)
 }
 
 /* allocates nothing unless it can completely fulfill the request */
-unsigned int comedi_buf_write_alloc_strict(comedi_async *async,
+unsigned int comedi_buf_write_alloc_strict(struct comedi_async *async,
 	unsigned int nbytes)
 {
 	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
@@ -631,7 +631,7 @@ unsigned int comedi_buf_write_alloc_strict(comedi_async *async,
 }
 
 /* transfers a chunk from writer to filled buffer space */
-unsigned comedi_buf_write_free(comedi_async *async, unsigned int nbytes)
+unsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes)
 {
 	if ((int)(async->buf_write_count + nbytes -
 			async->buf_write_alloc_count) > 0) {
@@ -649,7 +649,7 @@ unsigned comedi_buf_write_free(comedi_async *async, unsigned int nbytes)
 }
 
 /* allocates a chunk for the reader from filled (and munged) buffer space */
-unsigned comedi_buf_read_alloc(comedi_async *async, unsigned nbytes)
+unsigned comedi_buf_read_alloc(struct comedi_async *async, unsigned nbytes)
 {
 	if ((int)(async->buf_read_alloc_count + nbytes - async->munge_count) >
 		0) {
@@ -663,7 +663,7 @@ unsigned comedi_buf_read_alloc(comedi_async *async, unsigned nbytes)
 }
 
 /* transfers control of a chunk from reader to free buffer space */
-unsigned comedi_buf_read_free(comedi_async *async, unsigned int nbytes)
+unsigned comedi_buf_read_free(struct comedi_async *async, unsigned int nbytes)
 {
 	/*  barrier insures data has been read out of buffer before read count is incremented */
 	smp_mb();
@@ -679,7 +679,7 @@ unsigned comedi_buf_read_free(comedi_async *async, unsigned int nbytes)
 	return nbytes;
 }
 
-void comedi_buf_memcpy_to(comedi_async *async, unsigned int offset,
+void comedi_buf_memcpy_to(struct comedi_async *async, unsigned int offset,
 	const void *data, unsigned int num_bytes)
 {
 	unsigned int write_ptr = async->buf_write_ptr + offset;
@@ -704,7 +704,7 @@ void comedi_buf_memcpy_to(comedi_async *async, unsigned int offset,
 	}
 }
 
-void comedi_buf_memcpy_from(comedi_async *async, unsigned int offset,
+void comedi_buf_memcpy_from(struct comedi_async *async, unsigned int offset,
 	void *dest, unsigned int nbytes)
 {
 	void *src;
@@ -730,7 +730,7 @@ void comedi_buf_memcpy_from(comedi_async *async, unsigned int offset,
 	}
 }
 
-unsigned int comedi_buf_read_n_available(comedi_async *async)
+unsigned int comedi_buf_read_n_available(struct comedi_async *async)
 {
 	unsigned num_bytes;
 
@@ -745,7 +745,7 @@ unsigned int comedi_buf_read_n_available(comedi_async *async)
 	return num_bytes;
 }
 
-int comedi_buf_get(comedi_async *async, short *x)
+int comedi_buf_get(struct comedi_async *async, short *x)
 {
 	unsigned int n = comedi_buf_read_n_available(async);
 
@@ -757,7 +757,7 @@ int comedi_buf_get(comedi_async *async, short *x)
 	return 1;
 }
 
-int comedi_buf_put(comedi_async *async, short x)
+int comedi_buf_put(struct comedi_async *async, short x)
 {
 	unsigned int n = comedi_buf_write_alloc_strict(async, sizeof(short));
 
@@ -770,7 +770,7 @@ int comedi_buf_put(comedi_async *async, short x)
 	return 1;
 }
 
-void comedi_reset_async_buf(comedi_async *async)
+void comedi_reset_async_buf(struct comedi_async *async)
 {
 	async->buf_write_alloc_count = 0;
 	async->buf_write_count = 0;

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index f0eb7341d9ab..32f3aca2d7f4 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -48,12 +48,12 @@
 #include <asm/system.h>
 
 static int postconfig(struct comedi_device *dev);
-static int insn_rw_emulate_bits(struct comedi_device *dev, comedi_subdevice *s,
+static int insn_rw_emulate_bits(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
 static void *comedi_recognize(comedi_driver * driv, const char *name);
 static void comedi_report_boards(comedi_driver *driv);
-static int poll_invalid(struct comedi_device *dev, comedi_subdevice *s);
-int comedi_buf_alloc(struct comedi_device *dev, comedi_subdevice *s,
+static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s);
+int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned long new_size);
 
 comedi_driver *comedi_drivers;
@@ -66,7 +66,7 @@ int comedi_modprobe(int minor)
 static void cleanup_device(struct comedi_device *dev)
 {
 	int i;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	if (dev->subdevices) {
 		for (i = 0; i < dev->n_subdevices; i++) {
@@ -227,7 +227,7 @@ int comedi_driver_unregister(comedi_driver *driver)
 static int postconfig(struct comedi_device *dev)
 {
 	int i;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	comedi_async *async = NULL;
 	int ret;
 
@@ -331,18 +331,18 @@ void comedi_report_boards(comedi_driver *driv)
 		printk(" %s\n", driv->driver_name);
 }
 
-static int poll_invalid(struct comedi_device *dev, comedi_subdevice *s)
+static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	return -EINVAL;
 }
 
-int insn_inval(struct comedi_device *dev, comedi_subdevice *s,
+int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 	return -EINVAL;
 }
 
-static int insn_rw_emulate_bits(struct comedi_device *dev, comedi_subdevice *s,
+static int insn_rw_emulate_bits(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 	comedi_insn new_insn;
@@ -412,7 +412,7 @@ static inline unsigned long kvirt_to_kva(unsigned long adr)
 	return kva;
 }
 
-int comedi_buf_alloc(struct comedi_device *dev, comedi_subdevice *s,
+int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned long new_size)
 {
 	comedi_async *async = s->async;
@@ -538,7 +538,7 @@ int comedi_buf_alloc(struct comedi_device *dev, comedi_subdevice *s,
  * and kernel space */
 unsigned int comedi_buf_munge(comedi_async *async, unsigned int num_bytes)
 {
-	comedi_subdevice *s = async->subdevice;
+	struct comedi_subdevice *s = async->subdevice;
 	unsigned int count = 0;
 	const unsigned num_sample_bytes = bytes_per_sample(s);
 

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 49834ebfcb19..f0eb7341d9ab 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -47,13 +47,13 @@
 #include <asm/io.h>
 #include <asm/system.h>
 
-static int postconfig(comedi_device *dev);
-static int insn_rw_emulate_bits(comedi_device *dev, comedi_subdevice *s,
+static int postconfig(struct comedi_device *dev);
+static int insn_rw_emulate_bits(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
 static void *comedi_recognize(comedi_driver * driv, const char *name);
 static void comedi_report_boards(comedi_driver *driv);
-static int poll_invalid(comedi_device *dev, comedi_subdevice *s);
-int comedi_buf_alloc(comedi_device *dev, comedi_subdevice *s,
+static int poll_invalid(struct comedi_device *dev, comedi_subdevice *s);
+int comedi_buf_alloc(struct comedi_device *dev, comedi_subdevice *s,
 	unsigned long new_size);
 
 comedi_driver *comedi_drivers;
@@ -63,7 +63,7 @@ int comedi_modprobe(int minor)
 	return -EINVAL;
 }
 
-static void cleanup_device(comedi_device *dev)
+static void cleanup_device(struct comedi_device *dev)
 {
 	int i;
 	comedi_subdevice *s;
@@ -95,7 +95,7 @@ static void cleanup_device(comedi_device *dev)
 	comedi_set_hw_dev(dev, NULL);
 }
 
-static void __comedi_device_detach(comedi_device *dev)
+static void __comedi_device_detach(struct comedi_device *dev)
 {
 	dev->attached = 0;
 	if (dev->driver) {
@@ -106,14 +106,14 @@ static void __comedi_device_detach(comedi_device *dev)
 	cleanup_device(dev);
 }
 
-void comedi_device_detach(comedi_device *dev)
+void comedi_device_detach(struct comedi_device *dev)
 {
 	if (!dev->attached)
 		return;
 	__comedi_device_detach(dev);
 }
 
-int comedi_device_attach(comedi_device *dev, comedi_devconfig *it)
+int comedi_device_attach(struct comedi_device *dev, comedi_devconfig *it)
 {
 	comedi_driver *driv;
 	int ret;
@@ -196,7 +196,7 @@ int comedi_driver_unregister(comedi_driver *driver)
 	/* check for devices using this driver */
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
 		struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(i);
-		comedi_device *dev;
+		struct comedi_device *dev;
 
 		if(dev_file_info == NULL) continue;
 		dev = dev_file_info->device;
@@ -224,7 +224,7 @@ int comedi_driver_unregister(comedi_driver *driver)
 	return -EINVAL;
 }
 
-static int postconfig(comedi_device *dev)
+static int postconfig(struct comedi_device *dev)
 {
 	int i;
 	comedi_subdevice *s;
@@ -331,18 +331,18 @@ void comedi_report_boards(comedi_driver *driv)
 		printk(" %s\n", driv->driver_name);
 }
 
-static int poll_invalid(comedi_device *dev, comedi_subdevice *s)
+static int poll_invalid(struct comedi_device *dev, comedi_subdevice *s)
 {
 	return -EINVAL;
 }
 
-int insn_inval(comedi_device *dev, comedi_subdevice *s,
+int insn_inval(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 	return -EINVAL;
 }
 
-static int insn_rw_emulate_bits(comedi_device *dev, comedi_subdevice *s,
+static int insn_rw_emulate_bits(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 	comedi_insn new_insn;
@@ -412,7 +412,7 @@ static inline unsigned long kvirt_to_kva(unsigned long adr)
 	return kva;
 }
 
-int comedi_buf_alloc(comedi_device *dev, comedi_subdevice *s,
+int comedi_buf_alloc(struct comedi_device *dev, comedi_subdevice *s,
 	unsigned long new_size)
 {
 	comedi_async *async = s->async;

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 07456c0709dc..49834ebfcb19 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -49,7 +49,7 @@
 
 static int postconfig(comedi_device *dev);
 static int insn_rw_emulate_bits(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data);
+	comedi_insn *insn, unsigned int *data);
 static void *comedi_recognize(comedi_driver * driv, const char *name);
 static void comedi_report_boards(comedi_driver *driv);
 static int poll_invalid(comedi_device *dev, comedi_subdevice *s);
@@ -337,13 +337,13 @@ static int poll_invalid(comedi_device *dev, comedi_subdevice *s)
 }
 
 int insn_inval(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data)
+	comedi_insn *insn, unsigned int *data)
 {
 	return -EINVAL;
 }
 
 static int insn_rw_emulate_bits(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data)
+	comedi_insn *insn, unsigned int *data)
 {
 	comedi_insn new_insn;
 	int ret;
@@ -352,7 +352,7 @@ static int insn_rw_emulate_bits(comedi_device *dev, comedi_subdevice *s,
 	unsigned chan = CR_CHAN(insn->chanspec);
 	const unsigned base_bitfield_channel =
 		(chan < channels_per_bitfield) ? 0 : chan;
-	lsampl_t new_data[2];
+	unsigned int new_data[2];
 	memset(new_data, 0, sizeof(new_data));
 	memset(&new_insn, 0, sizeof(new_insn));
 	new_insn.insn = INSN_BITS;
@@ -745,28 +745,28 @@ unsigned int comedi_buf_read_n_available(comedi_async *async)
 	return num_bytes;
 }
 
-int comedi_buf_get(comedi_async *async, sampl_t *x)
+int comedi_buf_get(comedi_async *async, short *x)
 {
 	unsigned int n = comedi_buf_read_n_available(async);
 
-	if (n < sizeof(sampl_t))
+	if (n < sizeof(short))
 		return 0;
-	comedi_buf_read_alloc(async, sizeof(sampl_t));
-	*x = *(sampl_t *) (async->prealloc_buf + async->buf_read_ptr);
-	comedi_buf_read_free(async, sizeof(sampl_t));
+	comedi_buf_read_alloc(async, sizeof(short));
+	*x = *(short *) (async->prealloc_buf + async->buf_read_ptr);
+	comedi_buf_read_free(async, sizeof(short));
 	return 1;
 }
 
-int comedi_buf_put(comedi_async *async, sampl_t x)
+int comedi_buf_put(comedi_async *async, short x)
 {
-	unsigned int n = comedi_buf_write_alloc_strict(async, sizeof(sampl_t));
+	unsigned int n = comedi_buf_write_alloc_strict(async, sizeof(short));
 
-	if (n < sizeof(sampl_t)) {
+	if (n < sizeof(short)) {
 		async->events |= COMEDI_CB_ERROR;
 		return 0;
 	}
-	*(sampl_t *) (async->prealloc_buf + async->buf_write_ptr) = x;
-	comedi_buf_write_free(async, sizeof(sampl_t));
+	*(short *) (async->prealloc_buf + async->buf_write_ptr) = x;
+	comedi_buf_write_free(async, sizeof(short));
 	return 1;
 }
 

commit dedd1325f1d53e2a2604457c4b3af9e62dde5001
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:04:18 2009 -0400

    Staging: comedi: Remove checks for NULL before calling kfree()
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index a252081b6a08..07456c0709dc 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -81,10 +81,8 @@ static void cleanup_device(comedi_device *dev)
 		dev->subdevices = NULL;
 		dev->n_subdevices = 0;
 	}
-	if (dev->private) {
-		kfree(dev->private);
-		dev->private = NULL;
-	}
+	kfree(dev->private);
+	dev->private = NULL;
 	dev->driver = 0;
 	dev->board_name = NULL;
 	dev->board_ptr = NULL;

commit e473e9120b0a2d7252aca1ed9db5adadee36c0fa
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:03:29 2009 -0400

    Staging: comedi: Change "foo * bar" to "foo *bar"
    
    Removes checkpatch.pl errors
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 48e54042f8b3..a252081b6a08 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -47,13 +47,13 @@
 #include <asm/io.h>
 #include <asm/system.h>
 
-static int postconfig(comedi_device * dev);
-static int insn_rw_emulate_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+static int postconfig(comedi_device *dev);
+static int insn_rw_emulate_bits(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
 static void *comedi_recognize(comedi_driver * driv, const char *name);
-static void comedi_report_boards(comedi_driver * driv);
-static int poll_invalid(comedi_device * dev, comedi_subdevice * s);
-int comedi_buf_alloc(comedi_device * dev, comedi_subdevice * s,
+static void comedi_report_boards(comedi_driver *driv);
+static int poll_invalid(comedi_device *dev, comedi_subdevice *s);
+int comedi_buf_alloc(comedi_device *dev, comedi_subdevice *s,
 	unsigned long new_size);
 
 comedi_driver *comedi_drivers;
@@ -63,7 +63,7 @@ int comedi_modprobe(int minor)
 	return -EINVAL;
 }
 
-static void cleanup_device(comedi_device * dev)
+static void cleanup_device(comedi_device *dev)
 {
 	int i;
 	comedi_subdevice *s;
@@ -97,7 +97,7 @@ static void cleanup_device(comedi_device * dev)
 	comedi_set_hw_dev(dev, NULL);
 }
 
-static void __comedi_device_detach(comedi_device * dev)
+static void __comedi_device_detach(comedi_device *dev)
 {
 	dev->attached = 0;
 	if (dev->driver) {
@@ -108,14 +108,14 @@ static void __comedi_device_detach(comedi_device * dev)
 	cleanup_device(dev);
 }
 
-void comedi_device_detach(comedi_device * dev)
+void comedi_device_detach(comedi_device *dev)
 {
 	if (!dev->attached)
 		return;
 	__comedi_device_detach(dev);
 }
 
-int comedi_device_attach(comedi_device * dev, comedi_devconfig * it)
+int comedi_device_attach(comedi_device *dev, comedi_devconfig *it)
 {
 	comedi_driver *driv;
 	int ret;
@@ -182,7 +182,7 @@ int comedi_device_attach(comedi_device * dev, comedi_devconfig * it)
 	return 0;
 }
 
-int comedi_driver_register(comedi_driver * driver)
+int comedi_driver_register(comedi_driver *driver)
 {
 	driver->next = comedi_drivers;
 	comedi_drivers = driver;
@@ -190,7 +190,7 @@ int comedi_driver_register(comedi_driver * driver)
 	return 0;
 }
 
-int comedi_driver_unregister(comedi_driver * driver)
+int comedi_driver_unregister(comedi_driver *driver)
 {
 	comedi_driver *prev;
 	int i;
@@ -226,7 +226,7 @@ int comedi_driver_unregister(comedi_driver * driver)
 	return -EINVAL;
 }
 
-static int postconfig(comedi_device * dev)
+static int postconfig(comedi_device *dev)
 {
 	int i;
 	comedi_subdevice *s;
@@ -315,7 +315,7 @@ void *comedi_recognize(comedi_driver * driv, const char *name)
 	return NULL;
 }
 
-void comedi_report_boards(comedi_driver * driv)
+void comedi_report_boards(comedi_driver *driv)
 {
 	unsigned int i;
 	const char *const *name_ptr;
@@ -333,19 +333,19 @@ void comedi_report_boards(comedi_driver * driv)
 		printk(" %s\n", driv->driver_name);
 }
 
-static int poll_invalid(comedi_device * dev, comedi_subdevice * s)
+static int poll_invalid(comedi_device *dev, comedi_subdevice *s)
 {
 	return -EINVAL;
 }
 
-int insn_inval(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+int insn_inval(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	return -EINVAL;
 }
 
-static int insn_rw_emulate_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int insn_rw_emulate_bits(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	comedi_insn new_insn;
 	int ret;
@@ -381,7 +381,7 @@ static int insn_rw_emulate_bits(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static inline unsigned long uvirt_to_kva(pgd_t * pgd, unsigned long adr)
+static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
 {
 	unsigned long ret = 0UL;
 	pmd_t *pmd;
@@ -414,7 +414,7 @@ static inline unsigned long kvirt_to_kva(unsigned long adr)
 	return kva;
 }
 
-int comedi_buf_alloc(comedi_device * dev, comedi_subdevice * s,
+int comedi_buf_alloc(comedi_device *dev, comedi_subdevice *s,
 	unsigned long new_size)
 {
 	comedi_async *async = s->async;
@@ -538,7 +538,7 @@ int comedi_buf_alloc(comedi_device * dev, comedi_subdevice * s,
 
 /* munging is applied to data by core as it passes between user
  * and kernel space */
-unsigned int comedi_buf_munge(comedi_async * async, unsigned int num_bytes)
+unsigned int comedi_buf_munge(comedi_async *async, unsigned int num_bytes)
 {
 	comedi_subdevice *s = async->subdevice;
 	unsigned int count = 0;
@@ -582,7 +582,7 @@ unsigned int comedi_buf_munge(comedi_async * async, unsigned int num_bytes)
 	return count;
 }
 
-unsigned int comedi_buf_write_n_available(comedi_async * async)
+unsigned int comedi_buf_write_n_available(comedi_async *async)
 {
 	unsigned int free_end;
 	unsigned int nbytes;
@@ -602,7 +602,7 @@ unsigned int comedi_buf_write_n_available(comedi_async * async)
 }
 
 /* allocates chunk for the writer from free buffer space */
-unsigned int comedi_buf_write_alloc(comedi_async * async, unsigned int nbytes)
+unsigned int comedi_buf_write_alloc(comedi_async *async, unsigned int nbytes)
 {
 	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
 
@@ -617,7 +617,7 @@ unsigned int comedi_buf_write_alloc(comedi_async * async, unsigned int nbytes)
 }
 
 /* allocates nothing unless it can completely fulfill the request */
-unsigned int comedi_buf_write_alloc_strict(comedi_async * async,
+unsigned int comedi_buf_write_alloc_strict(comedi_async *async,
 	unsigned int nbytes)
 {
 	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
@@ -633,7 +633,7 @@ unsigned int comedi_buf_write_alloc_strict(comedi_async * async,
 }
 
 /* transfers a chunk from writer to filled buffer space */
-unsigned comedi_buf_write_free(comedi_async * async, unsigned int nbytes)
+unsigned comedi_buf_write_free(comedi_async *async, unsigned int nbytes)
 {
 	if ((int)(async->buf_write_count + nbytes -
 			async->buf_write_alloc_count) > 0) {
@@ -651,7 +651,7 @@ unsigned comedi_buf_write_free(comedi_async * async, unsigned int nbytes)
 }
 
 /* allocates a chunk for the reader from filled (and munged) buffer space */
-unsigned comedi_buf_read_alloc(comedi_async * async, unsigned nbytes)
+unsigned comedi_buf_read_alloc(comedi_async *async, unsigned nbytes)
 {
 	if ((int)(async->buf_read_alloc_count + nbytes - async->munge_count) >
 		0) {
@@ -665,7 +665,7 @@ unsigned comedi_buf_read_alloc(comedi_async * async, unsigned nbytes)
 }
 
 /* transfers control of a chunk from reader to free buffer space */
-unsigned comedi_buf_read_free(comedi_async * async, unsigned int nbytes)
+unsigned comedi_buf_read_free(comedi_async *async, unsigned int nbytes)
 {
 	/*  barrier insures data has been read out of buffer before read count is incremented */
 	smp_mb();
@@ -681,7 +681,7 @@ unsigned comedi_buf_read_free(comedi_async * async, unsigned int nbytes)
 	return nbytes;
 }
 
-void comedi_buf_memcpy_to(comedi_async * async, unsigned int offset,
+void comedi_buf_memcpy_to(comedi_async *async, unsigned int offset,
 	const void *data, unsigned int num_bytes)
 {
 	unsigned int write_ptr = async->buf_write_ptr + offset;
@@ -706,7 +706,7 @@ void comedi_buf_memcpy_to(comedi_async * async, unsigned int offset,
 	}
 }
 
-void comedi_buf_memcpy_from(comedi_async * async, unsigned int offset,
+void comedi_buf_memcpy_from(comedi_async *async, unsigned int offset,
 	void *dest, unsigned int nbytes)
 {
 	void *src;
@@ -732,7 +732,7 @@ void comedi_buf_memcpy_from(comedi_async * async, unsigned int offset,
 	}
 }
 
-unsigned int comedi_buf_read_n_available(comedi_async * async)
+unsigned int comedi_buf_read_n_available(comedi_async *async)
 {
 	unsigned num_bytes;
 
@@ -747,7 +747,7 @@ unsigned int comedi_buf_read_n_available(comedi_async * async)
 	return num_bytes;
 }
 
-int comedi_buf_get(comedi_async * async, sampl_t * x)
+int comedi_buf_get(comedi_async *async, sampl_t *x)
 {
 	unsigned int n = comedi_buf_read_n_available(async);
 
@@ -759,7 +759,7 @@ int comedi_buf_get(comedi_async * async, sampl_t * x)
 	return 1;
 }
 
-int comedi_buf_put(comedi_async * async, sampl_t x)
+int comedi_buf_put(comedi_async *async, sampl_t x)
 {
 	unsigned int n = comedi_buf_write_alloc_strict(async, sizeof(sampl_t));
 
@@ -772,7 +772,7 @@ int comedi_buf_put(comedi_async * async, sampl_t x)
 	return 1;
 }
 
-void comedi_reset_async_buf(comedi_async * async)
+void comedi_reset_async_buf(comedi_async *async)
 {
 	async->buf_write_alloc_count = 0;
 	async->buf_write_count = 0;

commit b6c777571b8d387d3add91170826f32a379e4313
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:03:24 2009 -0400

    Staging: comedi: Convert C99 style comments to traditional style comments
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index e14aef2a197a..48e54042f8b3 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -140,7 +140,7 @@ int comedi_device_attach(comedi_device * dev, comedi_devconfig * it)
 				continue;
 			}
 		}
-		//initialize dev->driver here so comedi_error() can be called from attach
+		/* initialize dev->driver here so comedi_error() can be called from attach */
 		dev->driver = driv;
 		ret = driv->attach(dev, it);
 		if (ret < 0) {
@@ -151,8 +151,8 @@ int comedi_device_attach(comedi_device * dev, comedi_devconfig * it)
 		goto attached;
 	}
 
-	// recognize has failed if we get here
-	// report valid board names before returning error
+	/*  recognize has failed if we get here */
+	/*  report valid board names before returning error */
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
 			printk("comedi: failed to increment module count\n");
@@ -299,7 +299,7 @@ static int postconfig(comedi_device * dev)
 	return 0;
 }
 
-// generic recognize function for drivers that register their supported board names
+/*  generic recognize function for drivers that register their supported board names */
 void *comedi_recognize(comedi_driver * driv, const char *name)
 {
 	unsigned i;
@@ -426,7 +426,7 @@ int comedi_buf_alloc(comedi_device * dev, comedi_subdevice * s,
 	if (async->prealloc_buf && async->prealloc_bufsz == new_size) {
 		return 0;
 	}
-	// deallocate old buffer
+	/*  deallocate old buffer */
 	if (async->prealloc_buf) {
 		vunmap(async->prealloc_buf);
 		async->prealloc_buf = NULL;
@@ -455,7 +455,7 @@ int comedi_buf_alloc(comedi_device * dev, comedi_subdevice * s,
 		async->buf_page_list = NULL;
 		async->n_buf_pages = 0;
 	}
-	// allocate new buffer
+	/*  allocate new buffer */
 	if (new_size) {
 		unsigned i = 0;
 		unsigned n_pages = new_size >> PAGE_SHIFT;
@@ -568,7 +568,7 @@ unsigned int comedi_buf_munge(comedi_async * async, unsigned int num_bytes)
 		s->munge(s->device, s, async->prealloc_buf + async->munge_ptr,
 			block_size, async->munge_chan);
 
-		smp_wmb();	//barrier insures data is munged in buffer before munge_count is incremented
+		smp_wmb();	/* barrier insures data is munged in buffer before munge_count is incremented */
 
 		async->munge_chan += block_size / num_sample_bytes;
 		async->munge_chan %= async->cmd.chanlist_len;
@@ -667,7 +667,7 @@ unsigned comedi_buf_read_alloc(comedi_async * async, unsigned nbytes)
 /* transfers control of a chunk from reader to free buffer space */
 unsigned comedi_buf_read_free(comedi_async * async, unsigned int nbytes)
 {
-	// barrier insures data has been read out of buffer before read count is incremented
+	/*  barrier insures data has been read out of buffer before read count is incremented */
 	smp_mb();
 	if ((int)(async->buf_read_count + nbytes -
 			async->buf_read_alloc_count) > 0) {
@@ -852,9 +852,9 @@ int comedi_pci_auto_config(struct pci_dev *pcidev, const char *board_name)
 {
 	int options[2];
 
-	// pci bus
+	/*  pci bus */
 	options[0] = pcidev->bus->number;
-	// pci slot
+	/*  pci slot */
 	options[1] = PCI_SLOT(pcidev->devfn);
 
 	return comedi_auto_config(&pcidev->dev, board_name, options, sizeof(options) / sizeof(options[0]));

commit 719548ef66175bdea228f7b377a4edc259d16ab2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Dec 9 11:07:22 2008 +0000

    Staging: comedi: Make comedi_auto_config() succeed when auto-configuration disabled.
    
    Otherwise it would not work properly.
    
    From: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 7322eb8e2ba9..e14aef2a197a 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -799,8 +799,10 @@ int comedi_auto_config(struct device *hardware_device, const char *board_name, c
 	int retval;
 	unsigned *private_data = NULL;
 
-	if (!comedi_autoconfig)
-		return -ENODEV;
+	if (!comedi_autoconfig) {
+		dev_set_drvdata(hardware_device, NULL);
+		return 0;
+	}
 
 	minor = comedi_alloc_board_minor(hardware_device);
 	if(minor < 0) return minor;

commit c28264dac4348b1514a9a0abcf0014c6b460637f
Author: Bernd Porr <BerndPorr@f2s.com>
Date:   Mon Dec 8 23:30:13 2008 +0000

    Staging: comedi: add comedi_usb_auto_[un]config functions
    
    This will be used by the usbdux and usbduxfast drivers.
    
    From: Bernd Porr <BerndPorr@f2s.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 5579aa0a9331..7322eb8e2ba9 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -28,6 +28,7 @@
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/pci.h>
+#include <linux/usb.h>
 #include <linux/errno.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -796,13 +797,21 @@ int comedi_auto_config(struct device *hardware_device, const char *board_name, c
 	int minor;
 	struct comedi_device_file_info *dev_file_info;
 	int retval;
+	unsigned *private_data = NULL;
 
 	if (!comedi_autoconfig)
 		return -ENODEV;
 
 	minor = comedi_alloc_board_minor(hardware_device);
 	if(minor < 0) return minor;
-	dev_set_drvdata(hardware_device, (void*)(unsigned long)minor);
+
+	private_data = kmalloc(sizeof(unsigned), GFP_KERNEL);
+	if (private_data == NULL) {
+		retval = -ENOMEM;
+		goto cleanup;
+	}
+	*private_data = minor;
+	dev_set_drvdata(hardware_device, private_data);
 
 	dev_file_info = comedi_get_device_file_info(minor);
 
@@ -815,8 +824,11 @@ int comedi_auto_config(struct device *hardware_device, const char *board_name, c
 	mutex_lock(&dev_file_info->device->mutex);
 	retval = comedi_device_attach(dev_file_info->device, &it);
 	mutex_unlock(&dev_file_info->device->mutex);
+
+cleanup:
 	if(retval < 0)
 	{
+		kfree(private_data);
 		comedi_free_board_minor(minor);
 	}
 	return retval;
@@ -824,11 +836,14 @@ int comedi_auto_config(struct device *hardware_device, const char *board_name, c
 
 void comedi_auto_unconfig(struct device *hardware_device)
 {
-	unsigned long minor = (unsigned long)dev_get_drvdata(hardware_device);
+	unsigned *minor = (unsigned *)dev_get_drvdata(hardware_device);
+	if(minor == NULL) return;
 
-	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
+	BUG_ON(*minor >= COMEDI_NUM_BOARD_MINORS);
 
-	comedi_free_board_minor(minor);
+	comedi_free_board_minor(*minor);
+	dev_set_drvdata(hardware_device, NULL);
+	kfree(minor);
 }
 
 int comedi_pci_auto_config(struct pci_dev *pcidev, const char *board_name)
@@ -847,3 +862,16 @@ void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
 {
 	comedi_auto_unconfig(&pcidev->dev);
 }
+
+int comedi_usb_auto_config(struct usb_device *usbdev,
+	const char *board_name)
+{
+	BUG_ON(usbdev == NULL);
+	return comedi_auto_config(&usbdev->dev, board_name, NULL, 0);
+}
+
+void comedi_usb_auto_unconfig(struct usb_device *usbdev)
+{
+	BUG_ON(usbdev == NULL);
+	comedi_auto_unconfig(&usbdev->dev);
+}

commit 6a9d7a21d710e544df20266b83b7829d9f7a1020
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Dec 8 17:05:50 2008 +0000

    Staging: comedi: Add a module parameter 'comedi_autoconfig'.
    
    Set it to 0 or 'N' to disable autoconfiguration.
    It is enabled by default.
    
    From: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 36a93b95e3f2..5579aa0a9331 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -797,6 +797,9 @@ int comedi_auto_config(struct device *hardware_device, const char *board_name, c
 	struct comedi_device_file_info *dev_file_info;
 	int retval;
 
+	if (!comedi_autoconfig)
+		return -ENODEV;
+
 	minor = comedi_alloc_board_minor(hardware_device);
 	if(minor < 0) return minor;
 	dev_set_drvdata(hardware_device, (void*)(unsigned long)minor);

commit d599edcaea987e233fad808f88850f725e8a5530
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Jan 7 14:31:57 2009 -0800

    staging: __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 06372b227bb2..36a93b95e3f2 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -557,7 +557,7 @@ unsigned int comedi_buf_munge(comedi_async * async, unsigned int num_bytes)
 		block_size = num_bytes - count;
 		if (block_size < 0) {
 			rt_printk("%s: %s: bug! block_size is negative\n",
-				__FILE__, __FUNCTION__);
+				__FILE__, __func__);
 			break;
 		}
 		if ((int)(async->munge_ptr + block_size -

commit ed9eccbe8970f6eedc1b978c157caf1251a896d4
Author: David Schleef <ds@schleef.org>
Date:   Tue Nov 4 20:29:31 2008 -0800

    Staging: add comedi core
    
    This adds the Comedi core to the staging tree.
    This is a data acquision infrastructure for Linux, providing a common
    interface for these types of drivers.
    
    Taken directly from the comedi git tree, with only minor tweaks
    by Greg to get it to build properly within the kernel tree.
    
    From: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Shawn Bohrer <shawn.bohrer@gmail.com>
    Signed-off-by: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
new file mode 100644
index 000000000000..06372b227bb2
--- /dev/null
+++ b/drivers/staging/comedi/drivers.c
@@ -0,0 +1,846 @@
+/*
+    module/drivers.c
+    functions for manipulating drivers
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 1997-2000 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#define _GNU_SOURCE
+
+#define __NO_VERSION__
+#include "comedi_fops.h"
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fcntl.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include "comedidev.h"
+#include "wrapper.h"
+#include <linux/highmem.h>	/* for SuSE brokenness */
+#include <linux/vmalloc.h>
+#include <linux/cdev.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/io.h>
+#include <asm/system.h>
+
+static int postconfig(comedi_device * dev);
+static int insn_rw_emulate_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static void *comedi_recognize(comedi_driver * driv, const char *name);
+static void comedi_report_boards(comedi_driver * driv);
+static int poll_invalid(comedi_device * dev, comedi_subdevice * s);
+int comedi_buf_alloc(comedi_device * dev, comedi_subdevice * s,
+	unsigned long new_size);
+
+comedi_driver *comedi_drivers;
+
+int comedi_modprobe(int minor)
+{
+	return -EINVAL;
+}
+
+static void cleanup_device(comedi_device * dev)
+{
+	int i;
+	comedi_subdevice *s;
+
+	if (dev->subdevices) {
+		for (i = 0; i < dev->n_subdevices; i++) {
+			s = dev->subdevices + i;
+			comedi_free_subdevice_minor(s);
+			if (s->async) {
+				comedi_buf_alloc(dev, s, 0);
+				kfree(s->async);
+			}
+		}
+		kfree(dev->subdevices);
+		dev->subdevices = NULL;
+		dev->n_subdevices = 0;
+	}
+	if (dev->private) {
+		kfree(dev->private);
+		dev->private = NULL;
+	}
+	dev->driver = 0;
+	dev->board_name = NULL;
+	dev->board_ptr = NULL;
+	dev->iobase = 0;
+	dev->irq = 0;
+	dev->read_subdev = NULL;
+	dev->write_subdev = NULL;
+	dev->open = NULL;
+	dev->close = NULL;
+	comedi_set_hw_dev(dev, NULL);
+}
+
+static void __comedi_device_detach(comedi_device * dev)
+{
+	dev->attached = 0;
+	if (dev->driver) {
+		dev->driver->detach(dev);
+	} else {
+		printk("BUG: dev->driver=NULL in comedi_device_detach()\n");
+	}
+	cleanup_device(dev);
+}
+
+void comedi_device_detach(comedi_device * dev)
+{
+	if (!dev->attached)
+		return;
+	__comedi_device_detach(dev);
+}
+
+int comedi_device_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_driver *driv;
+	int ret;
+
+	if (dev->attached)
+		return -EBUSY;
+
+	for (driv = comedi_drivers; driv; driv = driv->next) {
+		if (!try_module_get(driv->module)) {
+			printk("comedi: failed to increment module count, skipping\n");
+			continue;
+		}
+		if (driv->num_names) {
+			dev->board_ptr = comedi_recognize(driv, it->board_name);
+			if (dev->board_ptr == NULL) {
+				module_put(driv->module);
+				continue;
+			}
+		} else {
+			if (strcmp(driv->driver_name, it->board_name)) {
+				module_put(driv->module);
+				continue;
+			}
+		}
+		//initialize dev->driver here so comedi_error() can be called from attach
+		dev->driver = driv;
+		ret = driv->attach(dev, it);
+		if (ret < 0) {
+			module_put(dev->driver->module);
+			__comedi_device_detach(dev);
+			return ret;
+		}
+		goto attached;
+	}
+
+	// recognize has failed if we get here
+	// report valid board names before returning error
+	for (driv = comedi_drivers; driv; driv = driv->next) {
+		if (!try_module_get(driv->module)) {
+			printk("comedi: failed to increment module count\n");
+			continue;
+		}
+		comedi_report_boards(driv);
+		module_put(driv->module);
+	}
+	return -EIO;
+
+attached:
+	/* do a little post-config cleanup */
+	ret = postconfig(dev);
+	module_put(dev->driver->module);
+	if (ret < 0) {
+		__comedi_device_detach(dev);
+		return ret;
+	}
+
+	if (!dev->board_name) {
+		printk("BUG: dev->board_name=<%p>\n", dev->board_name);
+		dev->board_name = "BUG";
+	}
+	smp_wmb();
+	dev->attached = 1;
+
+	return 0;
+}
+
+int comedi_driver_register(comedi_driver * driver)
+{
+	driver->next = comedi_drivers;
+	comedi_drivers = driver;
+
+	return 0;
+}
+
+int comedi_driver_unregister(comedi_driver * driver)
+{
+	comedi_driver *prev;
+	int i;
+
+	/* check for devices using this driver */
+	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
+		struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(i);
+		comedi_device *dev;
+
+		if(dev_file_info == NULL) continue;
+		dev = dev_file_info->device;
+
+		mutex_lock(&dev->mutex);
+		if (dev->attached && dev->driver == driver) {
+			if (dev->use_count)
+				printk("BUG! detaching device with use_count=%d\n", dev->use_count);
+			comedi_device_detach(dev);
+		}
+		mutex_unlock(&dev->mutex);
+	}
+
+	if (comedi_drivers == driver) {
+		comedi_drivers = driver->next;
+		return 0;
+	}
+
+	for (prev = comedi_drivers; prev->next; prev = prev->next) {
+		if (prev->next == driver) {
+			prev->next = driver->next;
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+static int postconfig(comedi_device * dev)
+{
+	int i;
+	comedi_subdevice *s;
+	comedi_async *async = NULL;
+	int ret;
+
+	for (i = 0; i < dev->n_subdevices; i++) {
+		s = dev->subdevices + i;
+
+		if (s->type == COMEDI_SUBD_UNUSED)
+			continue;
+
+		if (s->len_chanlist == 0)
+			s->len_chanlist = 1;
+
+		if (s->do_cmd) {
+			BUG_ON((s->subdev_flags & (SDF_CMD_READ |
+				SDF_CMD_WRITE)) == 0);
+			BUG_ON(!s->do_cmdtest);
+
+			async = kzalloc(sizeof(comedi_async), GFP_KERNEL);
+			if (async == NULL) {
+				printk("failed to allocate async struct\n");
+				return -ENOMEM;
+			}
+			init_waitqueue_head(&async->wait_head);
+			async->subdevice = s;
+			s->async = async;
+
+#define DEFAULT_BUF_MAXSIZE (64*1024)
+#define DEFAULT_BUF_SIZE (64*1024)
+
+			async->max_bufsize = DEFAULT_BUF_MAXSIZE;
+
+			async->prealloc_buf = NULL;
+			async->prealloc_bufsz = 0;
+			if (comedi_buf_alloc(dev, s, DEFAULT_BUF_SIZE) < 0) {
+				printk("Buffer allocation failed\n");
+				return -ENOMEM;
+			}
+			if (s->buf_change) {
+				ret = s->buf_change(dev, s, DEFAULT_BUF_SIZE);
+				if (ret < 0)
+					return ret;
+			}
+			comedi_alloc_subdevice_minor(dev, s);
+		}
+
+		if (!s->range_table && !s->range_table_list)
+			s->range_table = &range_unknown;
+
+		if (!s->insn_read && s->insn_bits)
+			s->insn_read = insn_rw_emulate_bits;
+		if (!s->insn_write && s->insn_bits)
+			s->insn_write = insn_rw_emulate_bits;
+
+		if (!s->insn_read)
+			s->insn_read = insn_inval;
+		if (!s->insn_write)
+			s->insn_write = insn_inval;
+		if (!s->insn_bits)
+			s->insn_bits = insn_inval;
+		if (!s->insn_config)
+			s->insn_config = insn_inval;
+
+		if (!s->poll)
+			s->poll = poll_invalid;
+	}
+
+	return 0;
+}
+
+// generic recognize function for drivers that register their supported board names
+void *comedi_recognize(comedi_driver * driv, const char *name)
+{
+	unsigned i;
+	const char *const *name_ptr = driv->board_name;
+	for (i = 0; i < driv->num_names; i++) {
+		if (strcmp(*name_ptr, name) == 0)
+			return (void *)name_ptr;
+		name_ptr =
+			(const char *const *)((const char *)name_ptr +
+			driv->offset);
+	}
+
+	return NULL;
+}
+
+void comedi_report_boards(comedi_driver * driv)
+{
+	unsigned int i;
+	const char *const *name_ptr;
+
+	printk("comedi: valid board names for %s driver are:\n",
+		driv->driver_name);
+
+	name_ptr = driv->board_name;
+	for (i = 0; i < driv->num_names; i++) {
+		printk(" %s\n", *name_ptr);
+		name_ptr = (const char **)((char *)name_ptr + driv->offset);
+	}
+
+	if (driv->num_names == 0)
+		printk(" %s\n", driv->driver_name);
+}
+
+static int poll_invalid(comedi_device * dev, comedi_subdevice * s)
+{
+	return -EINVAL;
+}
+
+int insn_inval(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	return -EINVAL;
+}
+
+static int insn_rw_emulate_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	comedi_insn new_insn;
+	int ret;
+	static const unsigned channels_per_bitfield = 32;
+
+	unsigned chan = CR_CHAN(insn->chanspec);
+	const unsigned base_bitfield_channel =
+		(chan < channels_per_bitfield) ? 0 : chan;
+	lsampl_t new_data[2];
+	memset(new_data, 0, sizeof(new_data));
+	memset(&new_insn, 0, sizeof(new_insn));
+	new_insn.insn = INSN_BITS;
+	new_insn.chanspec = base_bitfield_channel;
+	new_insn.n = 2;
+	new_insn.data = new_data;
+	new_insn.subdev = insn->subdev;
+
+	if (insn->insn == INSN_WRITE) {
+		if (!(s->subdev_flags & SDF_WRITABLE))
+			return -EINVAL;
+		new_data[0] = 1 << (chan - base_bitfield_channel);	/* mask */
+		new_data[1] = data[0] ? (1 << (chan - base_bitfield_channel)) : 0;	/* bits */
+	}
+
+	ret = s->insn_bits(dev, s, &new_insn, new_data);
+	if (ret < 0)
+		return ret;
+
+	if (insn->insn == INSN_READ) {
+		data[0] = (new_data[1] >> (chan - base_bitfield_channel)) & 1;
+	}
+
+	return 1;
+}
+
+static inline unsigned long uvirt_to_kva(pgd_t * pgd, unsigned long adr)
+{
+	unsigned long ret = 0UL;
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+	pud_t *pud;
+
+	if (!pgd_none(*pgd)) {
+		pud = pud_offset(pgd, adr);
+		pmd = pmd_offset(pud, adr);
+		if (!pmd_none(*pmd)) {
+			ptep = pte_offset_kernel(pmd, adr);
+			pte = *ptep;
+			if (pte_present(pte)) {
+				ret = (unsigned long)
+					page_address(pte_page(pte));
+				ret |= (adr & (PAGE_SIZE - 1));
+			}
+		}
+	}
+	return ret;
+}
+
+static inline unsigned long kvirt_to_kva(unsigned long adr)
+{
+	unsigned long va, kva;
+
+	va = adr;
+	kva = uvirt_to_kva(pgd_offset_k(va), va);
+
+	return kva;
+}
+
+int comedi_buf_alloc(comedi_device * dev, comedi_subdevice * s,
+	unsigned long new_size)
+{
+	comedi_async *async = s->async;
+
+	/* Round up new_size to multiple of PAGE_SIZE */
+	new_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;
+
+	/* if no change is required, do nothing */
+	if (async->prealloc_buf && async->prealloc_bufsz == new_size) {
+		return 0;
+	}
+	// deallocate old buffer
+	if (async->prealloc_buf) {
+		vunmap(async->prealloc_buf);
+		async->prealloc_buf = NULL;
+		async->prealloc_bufsz = 0;
+	}
+	if (async->buf_page_list) {
+		unsigned i;
+		for (i = 0; i < async->n_buf_pages; ++i) {
+			if (async->buf_page_list[i].virt_addr) {
+				mem_map_unreserve(virt_to_page(async->
+						buf_page_list[i].virt_addr));
+				if (s->async_dma_dir != DMA_NONE) {
+					dma_free_coherent(dev->hw_dev,
+						PAGE_SIZE,
+						async->buf_page_list[i].
+						virt_addr,
+						async->buf_page_list[i].
+						dma_addr);
+				} else {
+					free_page((unsigned long)async->
+						buf_page_list[i].virt_addr);
+				}
+			}
+		}
+		vfree(async->buf_page_list);
+		async->buf_page_list = NULL;
+		async->n_buf_pages = 0;
+	}
+	// allocate new buffer
+	if (new_size) {
+		unsigned i = 0;
+		unsigned n_pages = new_size >> PAGE_SHIFT;
+		struct page **pages = NULL;
+
+		async->buf_page_list =
+			vmalloc(sizeof(struct comedi_buf_page) * n_pages);
+		if (async->buf_page_list) {
+			memset(async->buf_page_list, 0,
+				sizeof(struct comedi_buf_page) * n_pages);
+			pages = vmalloc(sizeof(struct page *) * n_pages);
+		}
+		if (pages) {
+			for (i = 0; i < n_pages; i++) {
+				if (s->async_dma_dir != DMA_NONE) {
+					async->buf_page_list[i].virt_addr =
+						dma_alloc_coherent(dev->hw_dev,
+						PAGE_SIZE,
+						&async->buf_page_list[i].
+						dma_addr,
+						GFP_KERNEL | __GFP_COMP);
+				} else {
+					async->buf_page_list[i].virt_addr =
+						(void *)
+						get_zeroed_page(GFP_KERNEL);
+				}
+				if (async->buf_page_list[i].virt_addr == NULL) {
+					break;
+				}
+				mem_map_reserve(virt_to_page(async->
+						buf_page_list[i].virt_addr));
+				pages[i] =
+					virt_to_page(async->buf_page_list[i].
+					virt_addr);
+			}
+		}
+		if (i == n_pages) {
+			async->prealloc_buf =
+				vmap(pages, n_pages, VM_MAP,
+				PAGE_KERNEL_NOCACHE);
+		}
+		if (pages) {
+			vfree(pages);
+		}
+		if (async->prealloc_buf == NULL) {
+			/* Some allocation failed above. */
+			if (async->buf_page_list) {
+				for (i = 0; i < n_pages; i++) {
+					if (async->buf_page_list[i].virt_addr ==
+						NULL) {
+						break;
+					}
+					mem_map_unreserve(virt_to_page(async->
+							buf_page_list[i].
+							virt_addr));
+					if (s->async_dma_dir != DMA_NONE) {
+						dma_free_coherent(dev->hw_dev,
+							PAGE_SIZE,
+							async->buf_page_list[i].
+							virt_addr,
+							async->buf_page_list[i].
+							dma_addr);
+					} else {
+						free_page((unsigned long)async->
+							buf_page_list[i].
+							virt_addr);
+					}
+				}
+				vfree(async->buf_page_list);
+				async->buf_page_list = NULL;
+			}
+			return -ENOMEM;
+		}
+		async->n_buf_pages = n_pages;
+	}
+	async->prealloc_bufsz = new_size;
+
+	return 0;
+}
+
+/* munging is applied to data by core as it passes between user
+ * and kernel space */
+unsigned int comedi_buf_munge(comedi_async * async, unsigned int num_bytes)
+{
+	comedi_subdevice *s = async->subdevice;
+	unsigned int count = 0;
+	const unsigned num_sample_bytes = bytes_per_sample(s);
+
+	if (s->munge == NULL || (async->cmd.flags & CMDF_RAWDATA)) {
+		async->munge_count += num_bytes;
+		if ((int)(async->munge_count - async->buf_write_count) > 0)
+			BUG();
+		return num_bytes;
+	}
+	/* don't munge partial samples */
+	num_bytes -= num_bytes % num_sample_bytes;
+	while (count < num_bytes) {
+		int block_size;
+
+		block_size = num_bytes - count;
+		if (block_size < 0) {
+			rt_printk("%s: %s: bug! block_size is negative\n",
+				__FILE__, __FUNCTION__);
+			break;
+		}
+		if ((int)(async->munge_ptr + block_size -
+				async->prealloc_bufsz) > 0)
+			block_size = async->prealloc_bufsz - async->munge_ptr;
+
+		s->munge(s->device, s, async->prealloc_buf + async->munge_ptr,
+			block_size, async->munge_chan);
+
+		smp_wmb();	//barrier insures data is munged in buffer before munge_count is incremented
+
+		async->munge_chan += block_size / num_sample_bytes;
+		async->munge_chan %= async->cmd.chanlist_len;
+		async->munge_count += block_size;
+		async->munge_ptr += block_size;
+		async->munge_ptr %= async->prealloc_bufsz;
+		count += block_size;
+	}
+	if ((int)(async->munge_count - async->buf_write_count) > 0)
+		BUG();
+	return count;
+}
+
+unsigned int comedi_buf_write_n_available(comedi_async * async)
+{
+	unsigned int free_end;
+	unsigned int nbytes;
+
+	if (async == NULL)
+		return 0;
+
+	free_end = async->buf_read_count + async->prealloc_bufsz;
+	nbytes = free_end - async->buf_write_alloc_count;
+	nbytes -= nbytes % bytes_per_sample(async->subdevice);
+	/* barrier insures the read of buf_read_count in this
+	   query occurs before any following writes to the buffer which
+	   might be based on the return value from this query.
+	 */
+	smp_mb();
+	return nbytes;
+}
+
+/* allocates chunk for the writer from free buffer space */
+unsigned int comedi_buf_write_alloc(comedi_async * async, unsigned int nbytes)
+{
+	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
+
+	if ((int)(async->buf_write_alloc_count + nbytes - free_end) > 0) {
+		nbytes = free_end - async->buf_write_alloc_count;
+	}
+	async->buf_write_alloc_count += nbytes;
+	/* barrier insures the read of buf_read_count above occurs before
+	   we write data to the write-alloc'ed buffer space */
+	smp_mb();
+	return nbytes;
+}
+
+/* allocates nothing unless it can completely fulfill the request */
+unsigned int comedi_buf_write_alloc_strict(comedi_async * async,
+	unsigned int nbytes)
+{
+	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
+
+	if ((int)(async->buf_write_alloc_count + nbytes - free_end) > 0) {
+		nbytes = 0;
+	}
+	async->buf_write_alloc_count += nbytes;
+	/* barrier insures the read of buf_read_count above occurs before
+	   we write data to the write-alloc'ed buffer space */
+	smp_mb();
+	return nbytes;
+}
+
+/* transfers a chunk from writer to filled buffer space */
+unsigned comedi_buf_write_free(comedi_async * async, unsigned int nbytes)
+{
+	if ((int)(async->buf_write_count + nbytes -
+			async->buf_write_alloc_count) > 0) {
+		rt_printk
+			("comedi: attempted to write-free more bytes than have been write-allocated.\n");
+		nbytes = async->buf_write_alloc_count - async->buf_write_count;
+	}
+	async->buf_write_count += nbytes;
+	async->buf_write_ptr += nbytes;
+	comedi_buf_munge(async, async->buf_write_count - async->munge_count);
+	if (async->buf_write_ptr >= async->prealloc_bufsz) {
+		async->buf_write_ptr %= async->prealloc_bufsz;
+	}
+	return nbytes;
+}
+
+/* allocates a chunk for the reader from filled (and munged) buffer space */
+unsigned comedi_buf_read_alloc(comedi_async * async, unsigned nbytes)
+{
+	if ((int)(async->buf_read_alloc_count + nbytes - async->munge_count) >
+		0) {
+		nbytes = async->munge_count - async->buf_read_alloc_count;
+	}
+	async->buf_read_alloc_count += nbytes;
+	/* barrier insures read of munge_count occurs before we actually read
+	   data out of buffer */
+	smp_rmb();
+	return nbytes;
+}
+
+/* transfers control of a chunk from reader to free buffer space */
+unsigned comedi_buf_read_free(comedi_async * async, unsigned int nbytes)
+{
+	// barrier insures data has been read out of buffer before read count is incremented
+	smp_mb();
+	if ((int)(async->buf_read_count + nbytes -
+			async->buf_read_alloc_count) > 0) {
+		rt_printk
+			("comedi: attempted to read-free more bytes than have been read-allocated.\n");
+		nbytes = async->buf_read_alloc_count - async->buf_read_count;
+	}
+	async->buf_read_count += nbytes;
+	async->buf_read_ptr += nbytes;
+	async->buf_read_ptr %= async->prealloc_bufsz;
+	return nbytes;
+}
+
+void comedi_buf_memcpy_to(comedi_async * async, unsigned int offset,
+	const void *data, unsigned int num_bytes)
+{
+	unsigned int write_ptr = async->buf_write_ptr + offset;
+
+	if (write_ptr >= async->prealloc_bufsz)
+		write_ptr %= async->prealloc_bufsz;
+
+	while (num_bytes) {
+		unsigned int block_size;
+
+		if (write_ptr + num_bytes > async->prealloc_bufsz)
+			block_size = async->prealloc_bufsz - write_ptr;
+		else
+			block_size = num_bytes;
+
+		memcpy(async->prealloc_buf + write_ptr, data, block_size);
+
+		data += block_size;
+		num_bytes -= block_size;
+
+		write_ptr = 0;
+	}
+}
+
+void comedi_buf_memcpy_from(comedi_async * async, unsigned int offset,
+	void *dest, unsigned int nbytes)
+{
+	void *src;
+	unsigned int read_ptr = async->buf_read_ptr + offset;
+
+	if (read_ptr >= async->prealloc_bufsz)
+		read_ptr %= async->prealloc_bufsz;
+
+	while (nbytes) {
+		unsigned int block_size;
+
+		src = async->prealloc_buf + read_ptr;
+
+		if (nbytes >= async->prealloc_bufsz - read_ptr)
+			block_size = async->prealloc_bufsz - read_ptr;
+		else
+			block_size = nbytes;
+
+		memcpy(dest, src, block_size);
+		nbytes -= block_size;
+		dest += block_size;
+		read_ptr = 0;
+	}
+}
+
+unsigned int comedi_buf_read_n_available(comedi_async * async)
+{
+	unsigned num_bytes;
+
+	if (async == NULL)
+		return 0;
+	num_bytes = async->munge_count - async->buf_read_count;
+	/* barrier insures the read of munge_count in this
+	   query occurs before any following reads of the buffer which
+	   might be based on the return value from this query.
+	 */
+	smp_rmb();
+	return num_bytes;
+}
+
+int comedi_buf_get(comedi_async * async, sampl_t * x)
+{
+	unsigned int n = comedi_buf_read_n_available(async);
+
+	if (n < sizeof(sampl_t))
+		return 0;
+	comedi_buf_read_alloc(async, sizeof(sampl_t));
+	*x = *(sampl_t *) (async->prealloc_buf + async->buf_read_ptr);
+	comedi_buf_read_free(async, sizeof(sampl_t));
+	return 1;
+}
+
+int comedi_buf_put(comedi_async * async, sampl_t x)
+{
+	unsigned int n = comedi_buf_write_alloc_strict(async, sizeof(sampl_t));
+
+	if (n < sizeof(sampl_t)) {
+		async->events |= COMEDI_CB_ERROR;
+		return 0;
+	}
+	*(sampl_t *) (async->prealloc_buf + async->buf_write_ptr) = x;
+	comedi_buf_write_free(async, sizeof(sampl_t));
+	return 1;
+}
+
+void comedi_reset_async_buf(comedi_async * async)
+{
+	async->buf_write_alloc_count = 0;
+	async->buf_write_count = 0;
+	async->buf_read_alloc_count = 0;
+	async->buf_read_count = 0;
+
+	async->buf_write_ptr = 0;
+	async->buf_read_ptr = 0;
+
+	async->cur_chan = 0;
+	async->scan_progress = 0;
+	async->munge_chan = 0;
+	async->munge_count = 0;
+	async->munge_ptr = 0;
+
+	async->events = 0;
+}
+
+int comedi_auto_config(struct device *hardware_device, const char *board_name, const int *options, unsigned num_options)
+{
+	comedi_devconfig it;
+	int minor;
+	struct comedi_device_file_info *dev_file_info;
+	int retval;
+
+	minor = comedi_alloc_board_minor(hardware_device);
+	if(minor < 0) return minor;
+	dev_set_drvdata(hardware_device, (void*)(unsigned long)minor);
+
+	dev_file_info = comedi_get_device_file_info(minor);
+
+	memset(&it, 0, sizeof(it));
+	strncpy(it.board_name, board_name, COMEDI_NAMELEN);
+	it.board_name[COMEDI_NAMELEN - 1] = '\0';
+	BUG_ON(num_options > COMEDI_NDEVCONFOPTS);
+	memcpy(it.options, options, num_options * sizeof(int));
+
+	mutex_lock(&dev_file_info->device->mutex);
+	retval = comedi_device_attach(dev_file_info->device, &it);
+	mutex_unlock(&dev_file_info->device->mutex);
+	if(retval < 0)
+	{
+		comedi_free_board_minor(minor);
+	}
+	return retval;
+}
+
+void comedi_auto_unconfig(struct device *hardware_device)
+{
+	unsigned long minor = (unsigned long)dev_get_drvdata(hardware_device);
+
+	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
+
+	comedi_free_board_minor(minor);
+}
+
+int comedi_pci_auto_config(struct pci_dev *pcidev, const char *board_name)
+{
+	int options[2];
+
+	// pci bus
+	options[0] = pcidev->bus->number;
+	// pci slot
+	options[1] = PCI_SLOT(pcidev->devfn);
+
+	return comedi_auto_config(&pcidev->dev, board_name, options, sizeof(options) / sizeof(options[0]));
+}
+
+void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
+{
+	comedi_auto_unconfig(&pcidev->dev);
+}
