commit 7379e6baeddf580d01feca650ec1ad508b6ea8ee
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jun 26 14:17:39 2019 +0100

    staging: comedi: amplc_pci230: fix null pointer deref on interrupt
    
    The interrupt handler `pci230_interrupt()` causes a null pointer
    dereference for a PCI260 card.  There is no analog output subdevice for
    a PCI260.  The `dev->write_subdev` subdevice pointer and therefore the
    `s_ao` subdevice pointer variable will be `NULL` for a PCI260.  The
    following call near the end of the interrupt handler results in the null
    pointer dereference for a PCI260:
    
            comedi_handle_events(dev, s_ao);
    
    Fix it by only calling the above function if `s_ao` is valid.
    
    Note that the other uses of `s_ao` in the calls
    `pci230_handle_ao_nofifo(dev, s_ao);` and `pci230_handle_ao_fifo(dev,
    s_ao);` will never be reached for a PCI260, so they are safe.
    
    Fixes: 39064f23284c ("staging: comedi: amplc_pci230: use comedi_handle_events()")
    Cc: <stable@vger.kernel.org> # v3.19+
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 65f60c2b702a..f7e673121864 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2330,7 +2330,8 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	devpriv->intr_running = false;
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
-	comedi_handle_events(dev, s_ao);
+	if (s_ao)
+		comedi_handle_events(dev, s_ao);
 	comedi_handle_events(dev, s_ai);
 
 	return IRQ_HANDLED;

commit 557e36194ed4052a8767e356784027b545c8a311
Author: Sanjana Sanikommu <sanjana99reddy99@gmail.com>
Date:   Sun Mar 31 16:17:30 2019 +0530

    staging: comedi: Prefer using BIT macro in various files.
    
    Challenge suggested by coccinelle.
    
    Replace bit shifting on 1 with the BIT(x) macro.
    Coccinelle script:
    
    @@
    constant c;
    @@
    
    -(1 << c)
    +BIT(c)
    
    Signed-off-by: Sanjana Sanikommu <sanjana99reddy99@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 08ffe26c5d43..65f60c2b702a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2464,7 +2464,7 @@ static int pci230_auto_attach(struct comedi_device *dev,
 	devpriv->adcg = 0;
 	devpriv->adccon = PCI230_ADC_TRIG_NONE | PCI230_ADC_IM_SE |
 			  PCI230_ADC_IR_BIP;
-	outw(1 << 0, devpriv->daqio + PCI230_ADCEN);
+	outw(BIT(0), devpriv->daqio + PCI230_ADCEN);
 	outw(devpriv->adcg, devpriv->daqio + PCI230_ADCG);
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
 	     devpriv->daqio + PCI230_ADCCON);

commit 904f9d4d3a83ef0eccaea5fe455f2c586c6f5cf0
Author: Giulio Benetti <giulio.benetti@micronovasrl.com>
Date:   Tue Jun 12 16:50:32 2018 +0200

    staging: comedi: drivers: amplc_pci230: make bool bit-field unsigned int bit-fields.
    
    Checkpatch complains on bool bitfields to be an int or u8/u16/u32
    bitfield.
    
    Make bool bit-fields to be unsigned int bit-fields.
    
    Signed-off-by: Giulio Benetti <giulio.benetti@micronovasrl.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 15fc7f19051a..08ffe26c5d43 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -444,7 +444,7 @@ struct pci230_board {
 	unsigned char ai_bits;
 	unsigned char ao_bits;
 	unsigned char min_hwver; /* Minimum hardware version supported. */
-	bool have_dio:1;
+	unsigned int have_dio:1;
 };
 
 static const struct pci230_board pci230_boards[] = {
@@ -490,11 +490,11 @@ struct pci230_private {
 	unsigned short adcg;		/* ADCG register value */
 	unsigned char ier;		/* Interrupt enable bits */
 	unsigned char res_owned[NUM_OWNERS]; /* Owned resources */
-	bool intr_running:1;		/* Flag set in interrupt routine */
-	bool ai_bipolar:1;		/* Flag AI range is bipolar */
-	bool ao_bipolar:1;		/* Flag AO range is bipolar */
-	bool ai_cmd_started:1;		/* Flag AI command started */
-	bool ao_cmd_started:1;		/* Flag AO command started */
+	unsigned int intr_running:1;	/* Flag set in interrupt routine */
+	unsigned int ai_bipolar:1;	/* Flag AI range is bipolar */
+	unsigned int ao_bipolar:1;	/* Flag AO range is bipolar */
+	unsigned int ai_cmd_started:1;	/* Flag AI command started */
+	unsigned int ao_cmd_started:1;	/* Flag AO command started */
 };
 
 /* PCI230 clock source periods in ns */

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a876d22fb948..15fc7f19051a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -7,16 +7,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 48c7890c3007..a876d22fb948 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * comedi/drivers/amplc_pci230.c
  * Driver for Amplicon PCI230 and PCI260 Multifunction I/O boards.

commit c5665dfb902f84002e14d30d97b47886fc9fe161
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Apr 4 11:29:54 2017 +0100

    staging: comedi: amplc_pci230: convert CLK_CONFIG() macro to function
    
    Convert the `CLK_CONFIG(chan, src)` macro to a static function
    `pci230_clk_config(chan, src)`.  This is consistent with an earlier
    change to convert `GAT_CONFIG(chan, src)` to a static function.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 9c360307f699..48c7890c3007 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -376,8 +376,11 @@
 #define CLK_1KHZ	5	/* internal 1 kHz clock */
 #define CLK_OUTNM1	6	/* output of channel-1 modulo total */
 #define CLK_EXT		7	/* external clock */
-/* Macro to construct clock input configuration register value. */
-#define CLK_CONFIG(chan, src)	((((chan) & 3) << 3) | ((src) & 7))
+
+static unsigned int pci230_clk_config(unsigned int chan, unsigned int src)
+{
+	return ((chan & 3) << 3) | (src & 7);
+}
 
 /*
  * Counter/timer gate input configuration sources.
@@ -697,7 +700,7 @@ static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 	/* Determine clock source and count. */
 	clk_src = pci230_choose_clk_count(ns, &count, flags);
 	/* Program clock source. */
-	outb(CLK_CONFIG(ct, clk_src), dev->iobase + PCI230_ZCLK_SCE);
+	outb(pci230_clk_config(ct, clk_src), dev->iobase + PCI230_ZCLK_SCE);
 	/* Set initial count. */
 	if (count >= 65536)
 		count = 0;

commit 112d55e5855423652aa334a13a34fccb70780069
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Apr 4 11:29:53 2017 +0100

    staging: comedi: amplc_pci230: remove 'inline' from pci230_gat_config()
    
    Let the compiler figure out whether `pci230_gat_config()` should be
    inlined by itself.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 42945de31fe2..9c360307f699 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -387,8 +387,7 @@
 #define GAT_EXT		2	/* external gate input (PPCn on PCI230) */
 #define GAT_NOUTNM2	3	/* inverted output of channel-2 modulo total */
 
-static inline unsigned int pci230_gat_config(unsigned int chan,
-					     unsigned int src)
+static unsigned int pci230_gat_config(unsigned int chan, unsigned int src)
 {
 	return ((chan & 3) << 3) | (src & 7);
 }

commit e76415f47f9f4ec4f0289f8194eae0726dc27dfd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 30 12:19:22 2016 -0700

    staging: comedi: amplc_pci230: Prefer kernel type 'u64' over 'uint64_t'
    
    Fix the checkpatch.pl issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 5d0cb37c4e0e..42945de31fe2 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -637,10 +637,10 @@ static void pci230_release_all_resources(struct comedi_device *dev,
 	pci230_release_shared(dev, (unsigned char)~0, owner);
 }
 
-static unsigned int pci230_divide_ns(uint64_t ns, unsigned int timebase,
+static unsigned int pci230_divide_ns(u64 ns, unsigned int timebase,
 				     unsigned int flags)
 {
-	uint64_t div;
+	u64 div;
 	unsigned int rem;
 
 	div = ns;
@@ -663,7 +663,7 @@ static unsigned int pci230_divide_ns(uint64_t ns, unsigned int timebase,
  * Given desired period in ns, returns the required internal clock source
  * and gets the initial count.
  */
-static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
+static unsigned int pci230_choose_clk_count(u64 ns, unsigned int *count,
 					    unsigned int flags)
 {
 	unsigned int clk_src, cnt;
@@ -687,7 +687,7 @@ static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int flags)
 }
 
 static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
-				    unsigned int mode, uint64_t ns,
+				    unsigned int mode, u64 ns,
 				    unsigned int flags)
 {
 	unsigned int clk_src;
@@ -2250,7 +2250,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			zgat = pci230_gat_config(0, GAT_VCC);
 			outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 			pci230_ct_setup_ns_mode(dev, 0, I8254_MODE1,
-						((uint64_t)cmd->convert_arg *
+						((u64)cmd->convert_arg *
 						 cmd->scan_end_arg),
 						CMDF_ROUND_UP);
 			if (cmd->scan_begin_src == TRIG_TIMER) {

commit 61ac7ccfb5cbe59ee940f0a7b3ad4fd3e3ce8c37
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 30 12:19:21 2016 -0700

    staging: comedi: amplc_pci230: Prefer using the BIT macro
    
    Fix the checkpatch.pl issues by using the BIT macro and defining some
    macros for the multi-bit fields.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index cf5ac8aad236..5d0cb37c4e0e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -237,47 +237,50 @@
 /*
  * DACCON read-write values.
  */
-#define PCI230_DAC_OR_UNI		(0 << 0) /* Output range unipolar */
-#define PCI230_DAC_OR_BIP		(1 << 0) /* Output range bipolar */
-#define PCI230_DAC_OR_MASK		(1 << 0)
+#define PCI230_DAC_OR(x)		(((x) & 0x1) << 0)
+#define PCI230_DAC_OR_UNI		PCI230_DAC_OR(0) /* Output unipolar */
+#define PCI230_DAC_OR_BIP		PCI230_DAC_OR(1) /* Output bipolar */
+#define PCI230_DAC_OR_MASK		PCI230_DAC_OR(1)
 /*
  * The following applies only if DAC FIFO support is enabled in the EXTFUNC
  * register (and only for PCI230+ hardware version 2 onwards).
  */
-#define PCI230P2_DAC_FIFO_EN		(1 << 8) /* FIFO enable */
+#define PCI230P2_DAC_FIFO_EN		BIT(8) /* FIFO enable */
 /*
  * The following apply only if the DAC FIFO is enabled (and only for PCI230+
  * hardware version 2 onwards).
  */
-#define PCI230P2_DAC_TRIG_NONE		(0 << 2) /* No trigger */
-#define PCI230P2_DAC_TRIG_SW		(1 << 2) /* Software trigger trigger */
-#define PCI230P2_DAC_TRIG_EXTP		(2 << 2) /* EXTTRIG +ve edge trigger */
-#define PCI230P2_DAC_TRIG_EXTN		(3 << 2) /* EXTTRIG -ve edge trigger */
-#define PCI230P2_DAC_TRIG_Z2CT0		(4 << 2) /* CT0-OUT +ve edge trigger */
-#define PCI230P2_DAC_TRIG_Z2CT1		(5 << 2) /* CT1-OUT +ve edge trigger */
-#define PCI230P2_DAC_TRIG_Z2CT2		(6 << 2) /* CT2-OUT +ve edge trigger */
-#define PCI230P2_DAC_TRIG_MASK		(7 << 2)
-#define PCI230P2_DAC_FIFO_WRAP		(1 << 7) /* FIFO wraparound mode */
-#define PCI230P2_DAC_INT_FIFO_EMPTY	(0 << 9) /* FIFO interrupt empty */
-#define PCI230P2_DAC_INT_FIFO_NEMPTY	(1 << 9)
-#define PCI230P2_DAC_INT_FIFO_NHALF	(2 << 9) /* FIFO intr not half full */
-#define PCI230P2_DAC_INT_FIFO_HALF	(3 << 9)
-#define PCI230P2_DAC_INT_FIFO_NFULL	(4 << 9) /* FIFO interrupt not full */
-#define PCI230P2_DAC_INT_FIFO_FULL	(5 << 9)
-#define PCI230P2_DAC_INT_FIFO_MASK	(7 << 9)
+#define PCI230P2_DAC_TRIG(x)		(((x) & 0x7) << 2)
+#define PCI230P2_DAC_TRIG_NONE		PCI230P2_DAC_TRIG(0) /* none */
+#define PCI230P2_DAC_TRIG_SW		PCI230P2_DAC_TRIG(1) /* soft trig */
+#define PCI230P2_DAC_TRIG_EXTP		PCI230P2_DAC_TRIG(2) /* ext + edge */
+#define PCI230P2_DAC_TRIG_EXTN		PCI230P2_DAC_TRIG(3) /* ext - edge */
+#define PCI230P2_DAC_TRIG_Z2CT0		PCI230P2_DAC_TRIG(4) /* Z2 CT0 out */
+#define PCI230P2_DAC_TRIG_Z2CT1		PCI230P2_DAC_TRIG(5) /* Z2 CT1 out */
+#define PCI230P2_DAC_TRIG_Z2CT2		PCI230P2_DAC_TRIG(6) /* Z2 CT2 out */
+#define PCI230P2_DAC_TRIG_MASK		PCI230P2_DAC_TRIG(7)
+#define PCI230P2_DAC_FIFO_WRAP		BIT(7) /* FIFO wraparound mode */
+#define PCI230P2_DAC_INT_FIFO(x)	(((x) & 7) << 9)
+#define PCI230P2_DAC_INT_FIFO_EMPTY	PCI230P2_DAC_INT_FIFO(0) /* empty */
+#define PCI230P2_DAC_INT_FIFO_NEMPTY	PCI230P2_DAC_INT_FIFO(1) /* !empty */
+#define PCI230P2_DAC_INT_FIFO_NHALF	PCI230P2_DAC_INT_FIFO(2) /* !half */
+#define PCI230P2_DAC_INT_FIFO_HALF	PCI230P2_DAC_INT_FIFO(3) /* half */
+#define PCI230P2_DAC_INT_FIFO_NFULL	PCI230P2_DAC_INT_FIFO(4) /* !full */
+#define PCI230P2_DAC_INT_FIFO_FULL	PCI230P2_DAC_INT_FIFO(5) /* full */
+#define PCI230P2_DAC_INT_FIFO_MASK	PCI230P2_DAC_INT_FIFO(7)
 
 /*
  * DACCON read-only values.
  */
-#define PCI230_DAC_BUSY			(1 << 1) /* DAC busy. */
+#define PCI230_DAC_BUSY			BIT(1) /* DAC busy. */
 /*
  * The following apply only if the DAC FIFO is enabled (and only for PCI230+
  * hardware version 2 onwards).
  */
-#define PCI230P2_DAC_FIFO_UNDERRUN_LATCHED	(1 << 5) /* Underrun error */
-#define PCI230P2_DAC_FIFO_EMPTY		(1 << 13) /* FIFO empty */
-#define PCI230P2_DAC_FIFO_FULL		(1 << 14) /* FIFO full */
-#define PCI230P2_DAC_FIFO_HALF		(1 << 15) /* FIFO half full */
+#define PCI230P2_DAC_FIFO_UNDERRUN_LATCHED	BIT(5) /* Underrun error */
+#define PCI230P2_DAC_FIFO_EMPTY		BIT(13) /* FIFO empty */
+#define PCI230P2_DAC_FIFO_FULL		BIT(14) /* FIFO full */
+#define PCI230P2_DAC_FIFO_HALF		BIT(15) /* FIFO half full */
 
 /*
  * DACCON write-only, transient values.
@@ -286,8 +289,8 @@
  * The following apply only if the DAC FIFO is enabled (and only for PCI230+
  * hardware version 2 onwards).
  */
-#define PCI230P2_DAC_FIFO_UNDERRUN_CLEAR	(1 << 5) /* Clear underrun */
-#define PCI230P2_DAC_FIFO_RESET		(1 << 12) /* FIFO reset */
+#define PCI230P2_DAC_FIFO_UNDERRUN_CLEAR	BIT(5) /* Clear underrun */
+#define PCI230P2_DAC_FIFO_RESET		BIT(12) /* FIFO reset */
 
 /*
  * PCI230+ hardware version 2 DAC FIFO levels.
@@ -304,44 +307,48 @@
 /*
  * ADCCON read/write values.
  */
-#define PCI230_ADC_TRIG_NONE		(0 << 0) /* No trigger */
-#define PCI230_ADC_TRIG_SW		(1 << 0) /* Software trigger trigger */
-#define PCI230_ADC_TRIG_EXTP		(2 << 0) /* EXTTRIG +ve edge trigger */
-#define PCI230_ADC_TRIG_EXTN		(3 << 0) /* EXTTRIG -ve edge trigger */
-#define PCI230_ADC_TRIG_Z2CT0		(4 << 0) /* CT0-OUT +ve edge trigger */
-#define PCI230_ADC_TRIG_Z2CT1		(5 << 0) /* CT1-OUT +ve edge trigger */
-#define PCI230_ADC_TRIG_Z2CT2		(6 << 0) /* CT2-OUT +ve edge trigger */
-#define PCI230_ADC_TRIG_MASK		(7 << 0)
-#define PCI230_ADC_IR_UNI		(0 << 3) /* Input range unipolar */
-#define PCI230_ADC_IR_BIP		(1 << 3) /* Input range bipolar */
-#define PCI230_ADC_IR_MASK		(1 << 3)
-#define PCI230_ADC_IM_SE		(0 << 4) /* Input mode single ended */
-#define PCI230_ADC_IM_DIF		(1 << 4) /* Input mode differential */
-#define PCI230_ADC_IM_MASK		(1 << 4)
-#define PCI230_ADC_FIFO_EN		(1 << 8) /* FIFO enable */
-#define PCI230_ADC_INT_FIFO_EMPTY	(0 << 9)
-#define PCI230_ADC_INT_FIFO_NEMPTY	(1 << 9) /* FIFO interrupt not empty */
-#define PCI230_ADC_INT_FIFO_NHALF	(2 << 9)
-#define PCI230_ADC_INT_FIFO_HALF	(3 << 9) /* FIFO interrupt half full */
-#define PCI230_ADC_INT_FIFO_NFULL	(4 << 9)
-#define PCI230_ADC_INT_FIFO_FULL	(5 << 9) /* FIFO interrupt full */
-#define PCI230P_ADC_INT_FIFO_THRESH	(7 << 9) /* FIFO interrupt threshold */
-#define PCI230_ADC_INT_FIFO_MASK	(7 << 9)
+#define PCI230_ADC_TRIG(x)		(((x) & 0x7) << 0)
+#define PCI230_ADC_TRIG_NONE		PCI230_ADC_TRIG(0) /* none */
+#define PCI230_ADC_TRIG_SW		PCI230_ADC_TRIG(1) /* soft trig */
+#define PCI230_ADC_TRIG_EXTP		PCI230_ADC_TRIG(2) /* ext + edge */
+#define PCI230_ADC_TRIG_EXTN		PCI230_ADC_TRIG(3) /* ext - edge */
+#define PCI230_ADC_TRIG_Z2CT0		PCI230_ADC_TRIG(4) /* Z2 CT0 out*/
+#define PCI230_ADC_TRIG_Z2CT1		PCI230_ADC_TRIG(5) /* Z2 CT1 out */
+#define PCI230_ADC_TRIG_Z2CT2		PCI230_ADC_TRIG(6) /* Z2 CT2 out */
+#define PCI230_ADC_TRIG_MASK		PCI230_ADC_TRIG(7)
+#define PCI230_ADC_IR(x)		(((x) & 0x1) << 3)
+#define PCI230_ADC_IR_UNI		PCI230_ADC_IR(0) /* Input unipolar */
+#define PCI230_ADC_IR_BIP		PCI230_ADC_IR(1) /* Input bipolar */
+#define PCI230_ADC_IR_MASK		PCI230_ADC_IR(1)
+#define PCI230_ADC_IM(x)		(((x) & 0x1) << 4)
+#define PCI230_ADC_IM_SE		PCI230_ADC_IM(0) /* single ended */
+#define PCI230_ADC_IM_DIF		PCI230_ADC_IM(1) /* differential */
+#define PCI230_ADC_IM_MASK		PCI230_ADC_IM(1)
+#define PCI230_ADC_FIFO_EN		BIT(8) /* FIFO enable */
+#define PCI230_ADC_INT_FIFO(x)		(((x) & 0x7) << 9)
+#define PCI230_ADC_INT_FIFO_EMPTY	PCI230_ADC_INT_FIFO(0) /* empty */
+#define PCI230_ADC_INT_FIFO_NEMPTY	PCI230_ADC_INT_FIFO(1) /* !empty */
+#define PCI230_ADC_INT_FIFO_NHALF	PCI230_ADC_INT_FIFO(2) /* !half */
+#define PCI230_ADC_INT_FIFO_HALF	PCI230_ADC_INT_FIFO(3) /* half */
+#define PCI230_ADC_INT_FIFO_NFULL	PCI230_ADC_INT_FIFO(4) /* !full */
+#define PCI230_ADC_INT_FIFO_FULL	PCI230_ADC_INT_FIFO(5) /* full */
+#define PCI230P_ADC_INT_FIFO_THRESH	PCI230_ADC_INT_FIFO(7) /* threshold */
+#define PCI230_ADC_INT_FIFO_MASK	PCI230_ADC_INT_FIFO(7)
 
 /*
  * ADCCON write-only, transient values.
  */
-#define PCI230_ADC_FIFO_RESET		(1 << 12) /* FIFO reset */
-#define PCI230_ADC_GLOB_RESET		(1 << 13) /* Global reset */
+#define PCI230_ADC_FIFO_RESET		BIT(12) /* FIFO reset */
+#define PCI230_ADC_GLOB_RESET		BIT(13) /* Global reset */
 
 /*
  * ADCCON read-only values.
  */
-#define PCI230_ADC_BUSY			(1 << 15) /* ADC busy */
-#define PCI230_ADC_FIFO_EMPTY		(1 << 12) /* FIFO empty */
-#define PCI230_ADC_FIFO_FULL		(1 << 13) /* FIFO full */
-#define PCI230_ADC_FIFO_HALF		(1 << 14) /* FIFO half full */
-#define PCI230_ADC_FIFO_FULL_LATCHED	(1 << 5)  /* FIFO overrun occurred */
+#define PCI230_ADC_BUSY			BIT(15) /* ADC busy */
+#define PCI230_ADC_FIFO_EMPTY		BIT(12) /* FIFO empty */
+#define PCI230_ADC_FIFO_FULL		BIT(13) /* FIFO full */
+#define PCI230_ADC_FIFO_HALF		BIT(14) /* FIFO half full */
+#define PCI230_ADC_FIFO_FULL_LATCHED	BIT(5)  /* FIFO overrun occurred */
 
 /*
  * PCI230 ADC FIFO levels.
@@ -353,10 +360,10 @@
  * PCI230+ EXTFUNC values.
  */
 /* Route EXTTRIG pin to external gate inputs. */
-#define PCI230P_EXTFUNC_GAT_EXTTRIG	(1 << 0)
+#define PCI230P_EXTFUNC_GAT_EXTTRIG	BIT(0)
 /* PCI230+ hardware version 2 values. */
 /* Allow DAC FIFO to be enabled. */
-#define PCI230P2_EXTFUNC_DACFIFO	(1 << 1)
+#define PCI230P2_EXTFUNC_DACFIFO	BIT(1)
 
 /*
  * Counter/timer clock input configuration sources.
@@ -402,20 +409,20 @@ static inline unsigned int pci230_gat_config(unsigned int chan,
  * Interrupt enables/status register values.
  */
 #define PCI230_INT_DISABLE		0
-#define PCI230_INT_PPI_C0		(1 << 0)
-#define PCI230_INT_PPI_C3		(1 << 1)
-#define PCI230_INT_ADC			(1 << 2)
-#define PCI230_INT_ZCLK_CT1		(1 << 5)
+#define PCI230_INT_PPI_C0		BIT(0)
+#define PCI230_INT_PPI_C3		BIT(1)
+#define PCI230_INT_ADC			BIT(2)
+#define PCI230_INT_ZCLK_CT1		BIT(5)
 /* For PCI230+ hardware version 2 when DAC FIFO enabled. */
-#define PCI230P2_INT_DAC		(1 << 4)
+#define PCI230P2_INT_DAC		BIT(4)
 
 /*
  * (Potentially) shared resources and their owners
  */
 enum {
-	RES_Z2CT0 = (1U << 0),	/* Z2-CT0 */
-	RES_Z2CT1 = (1U << 1),	/* Z2-CT1 */
-	RES_Z2CT2 = (1U << 2)	/* Z2-CT2 */
+	RES_Z2CT0 = BIT(0),	/* Z2-CT0 */
+	RES_Z2CT1 = BIT(1),	/* Z2-CT1 */
+	RES_Z2CT2 = BIT(2)	/* Z2-CT2 */
 };
 
 enum {

commit 094c0741dec38c73793f674293dcd2026d1e77d7
Author: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
Date:   Tue Mar 22 10:28:51 2016 +0530

    staging: comedi: amplc_pci230: Convert macro GAT_CONFIG to static inline function
    
    Convert macro GAT_CONFIG to static inline function as static inline
    functions are preferred over macros. This change is possible since the
    arguments at all call sites have the same type.
    
    This was done using Coccinelle:
    
    @r@
    expression e;
    @@
    - #define GAT_CONFIG(chan, src) e
    + static inline unsigned int pci230_gat_config(unsigned int chan,
    +                                              unsigned int src)
    +{
    +       return ((chan & 3) << 3) | (src & 7);
    +}
    
    @r1@
    expression dev,reg,chan,src;
    @@
    -GAT_CONFIG(chan, src)
    +pci230_gat_config(chan, src)
    
    Also, the comment describing the macro has been removed manually.
    
    Signed-off-by: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 907c39cc89d7..cf5ac8aad236 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -379,8 +379,12 @@
 #define GAT_GND		1	/* GND (i.e. disabled) */
 #define GAT_EXT		2	/* external gate input (PPCn on PCI230) */
 #define GAT_NOUTNM2	3	/* inverted output of channel-2 modulo total */
-/* Macro to construct gate input configuration register value. */
-#define GAT_CONFIG(chan, src)	((((chan) & 3) << 3) | ((src) & 7))
+
+static inline unsigned int pci230_gat_config(unsigned int chan,
+					     unsigned int src)
+{
+	return ((chan & 3) << 3) | (src & 7);
+}
 
 /*
  * Summary of CLK_OUTNM1 and GAT_NOUTNM2 connections for PCI230 and PCI260:
@@ -1263,7 +1267,8 @@ static void pci230_ao_start(struct comedi_device *dev,
 					       irqflags);
 		}
 		/* Set CT1 gate high to start counting. */
-		outb(GAT_CONFIG(1, GAT_VCC), dev->iobase + PCI230_ZGAT_SCE);
+		outb(pci230_gat_config(1, GAT_VCC),
+		     dev->iobase + PCI230_ZGAT_SCE);
 		break;
 	case TRIG_INT:
 		async->inttrig = pci230_ao_inttrig_scan_begin;
@@ -1351,7 +1356,8 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * cmd->scan_begin_arg is sampling period in ns.
 		 * Gate it off for now.
 		 */
-		outb(GAT_CONFIG(1, GAT_GND), dev->iobase + PCI230_ZGAT_SCE);
+		outb(pci230_gat_config(1, GAT_GND),
+		     dev->iobase + PCI230_ZGAT_SCE);
 		pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
 					cmd->scan_begin_arg,
 					cmd->flags);
@@ -1792,9 +1798,9 @@ static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
 	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
 	if (devpriv->ai_cmd_started) {
 		/* Trigger scan by waggling CT0 gate source. */
-		zgat = GAT_CONFIG(0, GAT_GND);
+		zgat = pci230_gat_config(0, GAT_GND);
 		outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
-		zgat = GAT_CONFIG(0, GAT_VCC);
+		zgat = pci230_gat_config(0, GAT_VCC);
 		outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 	}
 	spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
@@ -1926,20 +1932,20 @@ static void pci230_ai_start(struct comedi_device *dev,
 			 * Conversion timer CT2 needs to be gated by
 			 * inverted output of monostable CT2.
 			 */
-			zgat = GAT_CONFIG(2, GAT_NOUTNM2);
+			zgat = pci230_gat_config(2, GAT_NOUTNM2);
 		} else {
 			/*
 			 * Conversion timer CT2 needs to be gated on
 			 * continuously.
 			 */
-			zgat = GAT_CONFIG(2, GAT_VCC);
+			zgat = pci230_gat_config(2, GAT_VCC);
 		}
 		outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 		if (cmd->scan_begin_src != TRIG_FOLLOW) {
 			/* Set monostable CT0 trigger source. */
 			switch (cmd->scan_begin_src) {
 			default:
-				zgat = GAT_CONFIG(0, GAT_VCC);
+				zgat = pci230_gat_config(0, GAT_VCC);
 				break;
 			case TRIG_EXT:
 				/*
@@ -1950,21 +1956,21 @@ static void pci230_ai_start(struct comedi_device *dev,
 				 * input in order to use it as an external scan
 				 * trigger.
 				 */
-				zgat = GAT_CONFIG(0, GAT_EXT);
+				zgat = pci230_gat_config(0, GAT_EXT);
 				break;
 			case TRIG_TIMER:
 				/*
 				 * Monostable CT0 triggered by rising edge on
 				 * inverted output of CT1 (falling edge on CT1).
 				 */
-				zgat = GAT_CONFIG(0, GAT_NOUTNM2);
+				zgat = pci230_gat_config(0, GAT_NOUTNM2);
 				break;
 			case TRIG_INT:
 				/*
 				 * Monostable CT0 is triggered by inttrig
 				 * function waggling the CT0 gate source.
 				 */
-				zgat = GAT_CONFIG(0, GAT_VCC);
+				zgat = pci230_gat_config(0, GAT_VCC);
 				break;
 			}
 			outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
@@ -1974,7 +1980,7 @@ static void pci230_ai_start(struct comedi_device *dev,
 				 * Scan period timer CT1 needs to be
 				 * gated on to start counting.
 				 */
-				zgat = GAT_CONFIG(1, GAT_VCC);
+				zgat = pci230_gat_config(1, GAT_VCC);
 				outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 				break;
 			case TRIG_INT:
@@ -2216,7 +2222,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * Note, counter/timer output 2 can be monitored on the
 		 * connector: PCI230 pin 21, PCI260 pin 18.
 		 */
-		zgat = GAT_CONFIG(2, GAT_GND);
+		zgat = pci230_gat_config(2, GAT_GND);
 		outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 		/* Set counter/timer 2 to the specified conversion period. */
 		pci230_ct_setup_ns_mode(dev, 2, I8254_MODE3, cmd->convert_arg,
@@ -2234,7 +2240,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			 * monostable to stop it triggering.  The trigger
 			 * source will be changed later.
 			 */
-			zgat = GAT_CONFIG(0, GAT_VCC);
+			zgat = pci230_gat_config(0, GAT_VCC);
 			outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 			pci230_ct_setup_ns_mode(dev, 0, I8254_MODE1,
 						((uint64_t)cmd->convert_arg *
@@ -2247,7 +2253,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				 *
 				 * Set up CT1 but gate it off for now.
 				 */
-				zgat = GAT_CONFIG(1, GAT_GND);
+				zgat = pci230_gat_config(1, GAT_GND);
 				outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 				pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
 							cmd->scan_begin_arg,

commit df6ba4f16170838482319f40ce1a2b280b9e80f3
Author: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
Date:   Thu Mar 10 00:03:49 2016 +0530

    staging: comedi: drivers: amplc_pci230: Prefer using macro DIV_ROUND_UP
    
    The macro DIV_ROUND_UP performs the computation
    (((n) + (d) - 1) /(d)). It clarifies the divisor calculations.
    This was done using the coccinelle script:
    @@
    expression e1;
    expression e2;
    @@
    (
    - ((e1) + e2 - 1) / (e2)
    + DIV_ROUND_UP(e1,e2)
    |
    - ((e1) + (e2 - 1)) / (e2)
    + DIV_ROUND_UP(e1,e2)
    )
    
    Signed-off-by: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index d1fe88a6133f..907c39cc89d7 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -642,7 +642,7 @@ static unsigned int pci230_divide_ns(uint64_t ns, unsigned int timebase,
 	case CMDF_ROUND_DOWN:
 		break;
 	case CMDF_ROUND_UP:
-		div += (rem + timebase - 1) / timebase;
+		div += DIV_ROUND_UP(rem, timebase);
 		break;
 	}
 	return div > UINT_MAX ? UINT_MAX : (unsigned int)div;

commit 2ead7b32aadc83833d7cf6e9751ef56b89e90462
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Fri Feb 19 20:57:15 2016 +0530

    staging: comedi: drivers: Use DIV_ROUND_CLOSEST
    
    The kernel.h macro DIV_ROUND_CLOSEST performs the computation
    `(x +d/2)/d` but is perhaps more readable.
    
    The Coccinelle script used is as follows:
    // <smpl>
    @@
    expression x,__divisor;
    @@
    - (((x) + ((__divisor) / 2)) / (__divisor))
    + DIV_ROUND_CLOSEST(x,__divisor)
    // </smpl>
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 4b39f6960c0a..d1fe88a6133f 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -637,7 +637,7 @@ static unsigned int pci230_divide_ns(uint64_t ns, unsigned int timebase,
 	switch (flags & CMDF_ROUND_MASK) {
 	default:
 	case CMDF_ROUND_NEAREST:
-		div += (rem + (timebase / 2)) / timebase;
+		div += DIV_ROUND_CLOSEST(rem, timebase);
 		break;
 	case CMDF_ROUND_DOWN:
 		break;

commit e4c0c6bc0c3baa6ba8cce4db5568fe9db5ad3c5f
Author: Shraddha Barke <shraddha.6596@gmail.com>
Date:   Thu Oct 15 00:58:26 2015 +0530

    Staging: comedi: Remove unnecessary cast on void pointer
    
    void pointers do not need to be cast to other pointer types.
    
    The semantic patch used to find this:
    
    @r@
    expression x;
    void* e;
    type T;
    identifier f;
    @@
    
    (
      *((T *)e)
    |
      ((T *)x)[...]
    |
      ((T *)x)->f
    |
    - (T *)
      e
    )
    
    Signed-off-by: Shraddha Barke <shraddha.6596@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 5c5c4e2ec3d5..4b39f6960c0a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2275,7 +2275,7 @@ static int pci230_ai_cancel(struct comedi_device *dev,
 static irqreturn_t pci230_interrupt(int irq, void *d)
 {
 	unsigned char status_int, valid_status_int, temp_ier;
-	struct comedi_device *dev = (struct comedi_device *)d;
+	struct comedi_device *dev = d;
 	struct pci230_private *devpriv = dev->private;
 	struct comedi_subdevice *s_ao = dev->write_subdev;
 	struct comedi_subdevice *s_ai = dev->read_subdev;

commit 5e97650cf506bbaacc3149c07bc2c7dcae4f13af
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 18 10:54:40 2015 -0700

    staging: comedi: amplc_pci230: rename 'thisboard' variables
    
    For aesthetics, rename the 'thisboard' variables to 'board'. That name
    is more commonly used for the boardinfo pointer in comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 42e4923bcf03..5c5c4e2ec3d5 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -528,7 +528,7 @@ static const struct comedi_lrange pci230_ao_range = {
 
 static unsigned short pci230_ai_read(struct comedi_device *dev)
 {
-	const struct pci230_board *thisboard = dev->board_ptr;
+	const struct pci230_board *board = dev->board_ptr;
 	struct pci230_private *devpriv = dev->private;
 	unsigned short data;
 
@@ -543,21 +543,21 @@ static unsigned short pci230_ai_read(struct comedi_device *dev)
 	 */
 	if (devpriv->ai_bipolar)
 		data ^= 0x8000;
-	data >>= (16 - thisboard->ai_bits);
+	data >>= (16 - board->ai_bits);
 	return data;
 }
 
 static unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
 					     unsigned short datum)
 {
-	const struct pci230_board *thisboard = dev->board_ptr;
+	const struct pci230_board *board = dev->board_ptr;
 	struct pci230_private *devpriv = dev->private;
 
 	/*
 	 * PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
 	 * four bits reserved for expansion).  PCI230+ is also 12 bit AO.
 	 */
-	datum <<= (16 - thisboard->ao_bits);
+	datum <<= (16 - board->ao_bits);
 	/*
 	 * If a bipolar range was specified, mangle it
 	 * (straight binary->twos complement).
@@ -877,7 +877,7 @@ static int pci230_ao_check_chanlist(struct comedi_device *dev,
 static int pci230_ao_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	const struct pci230_board *thisboard = dev->board_ptr;
+	const struct pci230_board *board = dev->board_ptr;
 	struct pci230_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int tmp;
@@ -887,14 +887,14 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);
 
 	tmp = TRIG_TIMER | TRIG_INT;
-	if (thisboard->min_hwver > 0 && devpriv->hwver >= 2) {
+	if (board->min_hwver > 0 && devpriv->hwver >= 2) {
 		/*
 		 * For PCI230+ hardware version 2 onwards, allow external
 		 * trigger from EXTTRIG/EXTCONVCLK input (PCI230+ pin 25).
 		 *
 		 * FIXME: The permitted scan_begin_src values shouldn't depend
 		 * on devpriv->hwver (the detected card's actual hardware
-		 * version).  They should only depend on thisboard->min_hwver
+		 * version).  They should only depend on board->min_hwver
 		 * (the static capabilities of the configured card).  To fix
 		 * it, a new card model, e.g. "pci230+2" would have to be
 		 * defined with min_hwver set to 2.  It doesn't seem worth it
@@ -1500,7 +1500,7 @@ static int pci230_ai_check_chanlist(struct comedi_device *dev,
 static int pci230_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	const struct pci230_board *thisboard = dev->board_ptr;
+	const struct pci230_board *board = dev->board_ptr;
 	struct pci230_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int tmp;
@@ -1510,7 +1510,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
 
 	tmp = TRIG_FOLLOW | TRIG_TIMER | TRIG_INT;
-	if (thisboard->have_dio || thisboard->min_hwver > 0) {
+	if (board->have_dio || board->min_hwver > 0) {
 		/*
 		 * Unfortunately, we cannot trigger a scan off an external
 		 * source on the PCI260 board, since it uses the PPIC0 (DIO)
@@ -2364,7 +2364,7 @@ static int pci230_auto_attach(struct comedi_device *dev,
 			      unsigned long context_unused)
 {
 	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
-	const struct pci230_board *thisboard;
+	const struct pci230_board *board;
 	struct pci230_private *devpriv;
 	struct comedi_subdevice *s;
 	int rc;
@@ -2381,14 +2381,14 @@ static int pci230_auto_attach(struct comedi_device *dev,
 	spin_lock_init(&devpriv->ai_stop_spinlock);
 	spin_lock_init(&devpriv->ao_stop_spinlock);
 
-	dev->board_ptr = pci230_find_pci_board(pci_dev);
-	if (!dev->board_ptr) {
+	board = pci230_find_pci_board(pci_dev);
+	if (!board) {
 		dev_err(dev->class_dev,
 			"amplc_pci230: BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
-	thisboard = dev->board_ptr;
-	dev->board_name = thisboard->name;
+	dev->board_ptr = board;
+	dev->board_name = board->name;
 
 	rc = comedi_pci_enable(dev);
 	if (rc)
@@ -2414,15 +2414,15 @@ static int pci230_auto_attach(struct comedi_device *dev,
 		unsigned short extfunc = 0;
 
 		devpriv->hwver = inw(devpriv->daqio + PCI230P_HWVER);
-		if (devpriv->hwver < thisboard->min_hwver) {
+		if (devpriv->hwver < board->min_hwver) {
 			dev_err(dev->class_dev,
 				"%s - bad hardware version - got %u, need %u\n",
 				dev->board_name, devpriv->hwver,
-				thisboard->min_hwver);
+				board->min_hwver);
 			return -EIO;
 		}
 		if (devpriv->hwver > 0) {
-			if (!thisboard->have_dio) {
+			if (!board->have_dio) {
 				/*
 				 * No DIO ports.  Route counters' external gates
 				 * to the EXTTRIG signal (PCI260+ pin 17).
@@ -2432,7 +2432,7 @@ static int pci230_auto_attach(struct comedi_device *dev,
 				 */
 				extfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;
 			}
-			if (thisboard->ao_bits && devpriv->hwver >= 2) {
+			if (board->ao_bits && devpriv->hwver >= 2) {
 				/* Enable DAC FIFO functionality. */
 				extfunc |= PCI230P2_EXTFUNC_DACFIFO;
 			}
@@ -2484,7 +2484,7 @@ static int pci230_auto_attach(struct comedi_device *dev,
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;
 	s->n_chan = 16;
-	s->maxdata = (1 << thisboard->ai_bits) - 1;
+	s->maxdata = (1 << board->ai_bits) - 1;
 	s->range_table = &pci230_ai_range;
 	s->insn_read = pci230_ai_insn_read;
 	s->len_chanlist = 256;	/* but there are restrictions. */
@@ -2498,11 +2498,11 @@ static int pci230_auto_attach(struct comedi_device *dev,
 
 	s = &dev->subdevices[1];
 	/* analog output subdevice */
-	if (thisboard->ao_bits) {
+	if (board->ao_bits) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
 		s->n_chan = 2;
-		s->maxdata = (1 << thisboard->ao_bits) - 1;
+		s->maxdata = (1 << board->ao_bits) - 1;
 		s->range_table = &pci230_ao_range;
 		s->insn_write = pci230_ao_insn_write;
 		s->len_chanlist = 2;
@@ -2523,7 +2523,7 @@ static int pci230_auto_attach(struct comedi_device *dev,
 
 	s = &dev->subdevices[2];
 	/* digital i/o subdevice */
-	if (thisboard->have_dio) {
+	if (board->have_dio) {
 		rc = subdev_8255_init(dev, s, NULL, PCI230_PPI_X_BASE);
 		if (rc)
 			return rc;

commit d46bc00c3fac4c1066dd88582f215187436d1711
Author: Hari Prasath Gujulan Elango <hgujulan@visteon.com>
Date:   Tue Jun 16 13:43:50 2015 +0000

    staging: comedi: amplc_pci230: rename 'todo' variable
    
    This patch renames the very generic variable name 'todo' to
    nsamples.
    
    Signed-off-by: Hari Prasath Gujulan Elango <hgujulan@visteon.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 20d592002557..42e4923bcf03 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2011,17 +2011,17 @@ static void pci230_handle_ai(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int status_fifo;
 	unsigned int i;
-	unsigned int todo;
+	unsigned int nsamples;
 	unsigned int fifoamount;
 	unsigned short val;
 
 	/* Determine number of samples to read. */
-	todo = comedi_nsamples_left(s, PCI230_ADC_FIFOLEVEL_HALFFULL);
-	if (todo == 0)
+	nsamples = comedi_nsamples_left(s, PCI230_ADC_FIFOLEVEL_HALFFULL);
+	if (nsamples == 0)
 		return;
 
 	fifoamount = 0;
-	for (i = 0; i < todo; i++) {
+	for (i = 0; i < nsamples; i++) {
 		if (fifoamount == 0) {
 			/* Read FIFO state. */
 			status_fifo = inw(devpriv->daqio + PCI230_ADCCON);

commit a716811441368c90efd55955d1404c3f51aac391
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:03 2015 +0000

    staging: comedi: amplc_pci230: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a145f39682f4..20d592002557 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -186,7 +186,6 @@
 
 #include "../comedi_pci.h"
 
-#include "comedi_fc.h"
 #include "comedi_8254.h"
 #include "8255.h"
 
@@ -885,7 +884,7 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);
 
 	tmp = TRIG_TIMER | TRIG_INT;
 	if (thisboard->min_hwver > 0 && devpriv->hwver >= 2) {
@@ -905,19 +904,19 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 		 */
 		tmp |= TRIG_EXT;
 	}
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, tmp);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, tmp);
 
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -926,7 +925,7 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 #define MAX_SPEED_AO	8000	/* 8000 ns => 125 kHz */
 /*
@@ -937,10 +936,10 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 MAX_SPEED_AO);
-		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
-						 MIN_SPEED_AO);
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    MAX_SPEED_AO);
+		err |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,
+						    MIN_SPEED_AO);
 		break;
 	case TRIG_EXT:
 		/*
@@ -965,16 +964,17 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 		}
 		break;
 	default:
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 		break;
 	}
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -1507,7 +1507,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
 
 	tmp = TRIG_FOLLOW | TRIG_TIMER | TRIG_INT;
 	if (thisboard->have_dio || thisboard->min_hwver > 0) {
@@ -1519,21 +1519,21 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 		 */
 		tmp |= TRIG_EXT;
 	}
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, tmp);
-	err |= cfc_check_trigger_src(&cmd->convert_src,
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, tmp);
+	err |= comedi_check_trigger_src(&cmd->convert_src,
 					TRIG_TIMER | TRIG_INT | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -1550,7 +1550,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 #define MAX_SPEED_AI_SE		3200	/* PCI230 SE:   3200 ns => 312.5 kHz */
 #define MAX_SPEED_AI_DIFF	8000	/* PCI230 DIFF: 8000 ns => 125 kHz */
@@ -1585,10 +1585,10 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 			max_speed_ai = MAX_SPEED_AI_PLUS;
 		}
 
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 max_speed_ai);
-		err |= cfc_check_trigger_arg_max(&cmd->convert_arg,
-						 MIN_SPEED_AI);
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
+						    max_speed_ai);
+		err |= comedi_check_trigger_arg_max(&cmd->convert_arg,
+						    MIN_SPEED_AI);
 	} else if (cmd->convert_src == TRIG_EXT) {
 		/*
 		 * external trigger
@@ -1623,18 +1623,20 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 			 * convert_arg == 0 => trigger on -ve edge.
 			 * convert_arg == 1 => trigger on +ve edge.
 			 */
-			err |= cfc_check_trigger_arg_max(&cmd->convert_arg, 1);
+			err |= comedi_check_trigger_arg_max(&cmd->convert_arg,
+							    1);
 		}
 	} else {
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
 	}
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_EXT) {
 		/*
@@ -1659,7 +1661,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 			err |= -EINVAL;
 
 	} else {
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 	}
 
 	if (err)

commit 0d23c28c23b99e8d813248143f65d22b78a9826f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 10 16:10:44 2015 +0000

    staging: comedi: amplc_pci230: include new "comedi_pci.h" header
    
    Include the new "../comedi_pci.h" header instead of <linux/pci.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 2dd794d01354..a145f39682f4 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -181,11 +181,10 @@
  */
 
 #include <linux/module.h>
-#include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 
-#include "../comedidev.h"
+#include "../comedi_pci.h"
 
 #include "comedi_fc.h"
 #include "comedi_8254.h"

commit 4d719cecc08ecc58040ffd751423810b4c19d772
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 4 12:15:31 2015 -0700

    staging: comedi: amplc_pci230: (!foo) preferred over (foo == NULL)
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a977156ca468..2dd794d01354 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2381,7 +2381,7 @@ static int pci230_auto_attach(struct comedi_device *dev,
 	spin_lock_init(&devpriv->ao_stop_spinlock);
 
 	dev->board_ptr = pci230_find_pci_board(pci_dev);
-	if (dev->board_ptr == NULL) {
+	if (!dev->board_ptr) {
 		dev_err(dev->class_dev,
 			"amplc_pci230: BUG! cannot determine board type!\n");
 		return -EINVAL;

commit 25182d27513d541bfd32163982e80457b3ee1cd0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:57:41 2015 -0700

    staging: comedi: amplc_pci230: convert driver to use the comedi_8254 module
    
    This driver uses an 8254 timer to generate the pacer clock used for analog
    input data conversion. Convert it to use the comedi_8254 module to provide
    support for the 8254 timer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 49806a5e514c..a977156ca468 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -188,7 +188,7 @@
 #include "../comedidev.h"
 
 #include "comedi_fc.h"
-#include "8253.h"
+#include "comedi_8254.h"
 #include "8255.h"
 
 /*
@@ -206,10 +206,6 @@
 #define PCI230_PPI_X_C		0x02	/* User PPI (82C55) port C */
 #define PCI230_PPI_X_CMD	0x03	/* User PPI (82C55) control word */
 #define PCI230_Z2_CT_BASE	0x14	/* 82C54 counter/timer base */
-#define PCI230_Z2_CT0		0x14	/* 82C54 counter/timer 0 */
-#define PCI230_Z2_CT1		0x15	/* 82C54 counter/timer 1 */
-#define PCI230_Z2_CT2		0x16	/* 82C54 counter/timer 2 */
-#define PCI230_Z2_CTC		0x17	/* 82C54 counter/timer control word */
 #define PCI230_ZCLK_SCE		0x1A	/* Group Z Clock Configuration */
 #define PCI230_ZGAT_SCE		0x1D	/* Group Z Gate Configuration */
 #define PCI230_INT_SCE		0x1E	/* Interrupt source mask (w) */
@@ -377,12 +373,6 @@
 #define CLK_EXT		7	/* external clock */
 /* Macro to construct clock input configuration register value. */
 #define CLK_CONFIG(chan, src)	((((chan) & 3) << 3) | ((src) & 7))
-/* Timebases in ns. */
-#define TIMEBASE_10MHZ		100
-#define TIMEBASE_1MHZ		1000
-#define TIMEBASE_100KHZ		10000
-#define TIMEBASE_10KHZ		100000
-#define TIMEBASE_1KHZ		1000000
 
 /*
  * Counter/timer gate input configuration sources.
@@ -507,11 +497,11 @@ struct pci230_private {
 
 /* PCI230 clock source periods in ns */
 static const unsigned int pci230_timebase[8] = {
-	[CLK_10MHZ] = TIMEBASE_10MHZ,
-	[CLK_1MHZ] = TIMEBASE_1MHZ,
-	[CLK_100KHZ] = TIMEBASE_100KHZ,
-	[CLK_10KHZ] = TIMEBASE_10KHZ,
-	[CLK_1KHZ] = TIMEBASE_1KHZ,
+	[CLK_10MHZ]	= I8254_OSC_BASE_10MHZ,
+	[CLK_1MHZ]	= I8254_OSC_BASE_1MHZ,
+	[CLK_100KHZ]	= I8254_OSC_BASE_100KHZ,
+	[CLK_10KHZ]	= I8254_OSC_BASE_10KHZ,
+	[CLK_1KHZ]	= I8254_OSC_BASE_1KHZ,
 };
 
 /* PCI230 analogue input range table */
@@ -695,7 +685,7 @@ static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 	unsigned int count;
 
 	/* Set mode. */
-	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, ct, mode);
+	comedi_8254_set_mode(dev->pacer, ct, mode);
 	/* Determine clock source and count. */
 	clk_src = pci230_choose_clk_count(ns, &count, flags);
 	/* Program clock source. */
@@ -704,13 +694,13 @@ static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 	if (count >= 65536)
 		count = 0;
 
-	i8254_write(dev->iobase + PCI230_Z2_CT_BASE, 0, ct, count);
+	comedi_8254_write(dev->pacer, ct, count);
 }
 
 static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)
 {
-	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, ct, I8254_MODE1);
 	/* Counter ct, 8254 mode 1, initial count not written. */
+	comedi_8254_set_mode(dev->pacer, ct, I8254_MODE1);
 }
 
 static int pci230_ai_eoc(struct comedi_device *dev,
@@ -760,7 +750,7 @@ static int pci230_ai_insn_read(struct comedi_device *dev,
 	 */
 	adccon = PCI230_ADC_TRIG_Z2CT2 | PCI230_ADC_FIFO_EN;
 	/* Set Z2-CT2 output low to avoid any false triggers. */
-	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE0);
+	comedi_8254_set_mode(dev->pacer, 2, I8254_MODE0);
 	devpriv->ai_bipolar = comedi_range_is_bipolar(s, range);
 	if (aref == AREF_DIFF) {
 		/* Differential. */
@@ -811,10 +801,8 @@ static int pci230_ai_insn_read(struct comedi_device *dev,
 		 * Trigger conversion by toggling Z2-CT2 output
 		 * (finish with output high).
 		 */
-		i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0,
-			       2, I8254_MODE0);
-		i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0,
-			       2, I8254_MODE1);
+		comedi_8254_set_mode(dev->pacer, 2, I8254_MODE0);
+		comedi_8254_set_mode(dev->pacer, 2, I8254_MODE1);
 
 		/* wait for conversion to end */
 		ret = comedi_timeout(dev, s, insn, pci230_ai_eoc, 0);
@@ -1767,8 +1755,8 @@ static int pci230_ai_inttrig_convert(struct comedi_device *dev,
 	 * Trigger conversion by toggling Z2-CT2 output.
 	 * Finish with output high.
 	 */
-	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE0);
-	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE1);
+	comedi_8254_set_mode(dev->pacer, 2, I8254_MODE0);
+	comedi_8254_set_mode(dev->pacer, 2, I8254_MODE1);
 	/*
 	 * Delay.  Should driver be responsible for this?  An
 	 * alternative would be to wait until conversion is complete,
@@ -2189,7 +2177,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * Set counter/timer 2 output high for use as the initial start
 	 * conversion source.
 	 */
-	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE1);
+	comedi_8254_set_mode(dev->pacer, 2, I8254_MODE1);
 
 	/*
 	 * Temporarily use CT2 output as conversion trigger source and
@@ -2481,6 +2469,11 @@ static int pci230_auto_attach(struct comedi_device *dev,
 			dev->irq = pci_dev->irq;
 	}
 
+	dev->pacer = comedi_8254_init(dev->iobase + PCI230_Z2_CT_BASE,
+				      0, I8254_IO8, 0);
+	if (!dev->pacer)
+		return -ENOMEM;
+
 	rc = comedi_alloc_subdevices(dev, 3);
 	if (rc)
 		return rc;

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index fb0b70fdce7d..49806a5e514c 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2511,7 +2511,6 @@ static int pci230_auto_attach(struct comedi_device *dev,
 		s->maxdata = (1 << thisboard->ao_bits) - 1;
 		s->range_table = &pci230_ao_range;
 		s->insn_write = pci230_ao_insn_write;
-		s->insn_read = comedi_readback_insn_read;
 		s->len_chanlist = 2;
 		if (dev->irq) {
 			dev->write_subdev = s;

commit c6de95f467073aa0913de9bace18946c51283826
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:31:34 2014 -0700

    staging: comedi: amplc_pci230: use comedi_async 'scans_done' to detect AI EOA
    
    Remove the private data member 'ai_scan_count' and use the comedi_async 'scans_done'
    member to detect the analog input end-of-acquisition.
    
    Use the comedi_nsamples_left() helper to work out the number of 'wake' samples in
    pci230_ai_update_fifo_trigger_level() and the number of 'todo' samples actually
    added to the async buffer in pci230_handle_ai().
    
    Remove the unnecessary COMEDI_CB_OVERFLOW event for the hardware FIFO overflow
    error. The COMEDI_CB_ERROR event will terminate the command.
    
    comedi_buf_write_samples() can fail if the async buffer does not have room for
    the sample. The it will set the COMEDI_CB_OVERFLOW event and return 0. Detect
    this and quit trying to read and add more samples. The event will terminate the
    command.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 5f4b67505932..fb0b70fdce7d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -490,7 +490,6 @@ struct pci230_private {
 	spinlock_t ai_stop_spinlock;	/* Spin lock for stopping AI command */
 	spinlock_t ao_stop_spinlock;	/* Spin lock for stopping AO command */
 	unsigned long daqio;		/* PCI230's DAQ I/O space */
-	unsigned int ai_scan_count;	/* Number of AI scans remaining */
 	int intr_cpuid;			/* ID of CPU running ISR */
 	unsigned short hwver;		/* Hardware version (for '+' models) */
 	unsigned short adccon;		/* ADCCON register value */
@@ -1720,19 +1719,15 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 {
 	struct pci230_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int scanlen = cmd->scan_end_arg;
 	unsigned int wake;
 	unsigned short triglev;
 	unsigned short adccon;
 
 	if (cmd->flags & CMDF_WAKE_EOS)
-		wake = scanlen - s->async->cur_chan;
-	else if (cmd->stop_src != TRIG_COUNT ||
-		 devpriv->ai_scan_count >= PCI230_ADC_FIFOLEVEL_HALFFULL ||
-		 scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL)
-		wake = PCI230_ADC_FIFOLEVEL_HALFFULL;
+		wake = cmd->scan_end_arg - s->async->cur_chan;
 	else
-		wake = devpriv->ai_scan_count * scanlen - s->async->cur_chan;
+		wake = comedi_nsamples_left(s, PCI230_ADC_FIFOLEVEL_HALFFULL);
+
 	if (wake >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
 		triglev = PCI230_ADC_INT_FIFO_HALF;
 	} else if (wake > 1 && devpriv->hwver > 0) {
@@ -2025,8 +2020,6 @@ static void pci230_handle_ai(struct comedi_device *dev,
 	struct pci230_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	unsigned int scanlen = cmd->scan_end_arg;
-	unsigned int events = 0;
 	unsigned int status_fifo;
 	unsigned int i;
 	unsigned int todo;
@@ -2034,20 +2027,10 @@ static void pci230_handle_ai(struct comedi_device *dev,
 	unsigned short val;
 
 	/* Determine number of samples to read. */
-	if (cmd->stop_src != TRIG_COUNT) {
-		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
-	} else if (devpriv->ai_scan_count == 0) {
-		todo = 0;
-	} else if (devpriv->ai_scan_count > PCI230_ADC_FIFOLEVEL_HALFFULL ||
-		   scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL) {
-		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
-	} else {
-		todo = devpriv->ai_scan_count * scanlen - async->cur_chan;
-		if (todo > PCI230_ADC_FIFOLEVEL_HALFFULL)
-			todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
-	}
+	todo = comedi_nsamples_left(s, PCI230_ADC_FIFOLEVEL_HALFFULL);
 	if (todo == 0)
 		return;
+
 	fifoamount = 0;
 	for (i = 0; i < todo; i++) {
 		if (fifoamount == 0) {
@@ -2059,7 +2042,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 				 * unnoticed by the caller.
 				 */
 				dev_err(dev->class_dev, "AI FIFO overrun\n");
-				events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
+				async->events |= COMEDI_CB_ERROR;
 				break;
 			} else if (status_fifo & PCI230_ADC_FIFO_EMPTY) {
 				/* FIFO empty. */
@@ -2080,21 +2063,21 @@ static void pci230_handle_ai(struct comedi_device *dev,
 		}
 
 		val = pci230_ai_read(dev);
-		comedi_buf_write_samples(s, &val, 1);
+		if (!comedi_buf_write_samples(s, &val, 1))
+			break;
 
 		fifoamount--;
-		if (async->cur_chan == 0)
-			devpriv->ai_scan_count--;
-	}
-	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_scan_count == 0) {
-		/* End of acquisition. */
-		events |= COMEDI_CB_EOA;
+
+		if (cmd->stop_src == TRIG_COUNT &&
+		    async->scans_done >= cmd->stop_arg) {
+			async->events |= COMEDI_CB_EOA;
+			break;
+		}
 	}
-	async->events |= events;
-	if (!(async->events & COMEDI_CB_CANCEL_MASK)) {
-		/* update FIFO interrupt trigger level */
+
+	/* update FIFO interrupt trigger level if still running */
+	if (!(async->events & COMEDI_CB_CANCEL_MASK))
 		pci230_ai_update_fifo_trigger_level(dev, s);
-	}
 }
 
 static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -2130,8 +2113,6 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (!pci230_claim_shared(dev, res_mask, OWNER_AICMD))
 		return -EBUSY;
 
-	devpriv->ai_scan_count = cmd->stop_arg;
-
 	/*
 	 * Steps:
 	 * - Set channel scan list.

commit a65ccf634c91005bfc2c715b09aa43c1b18ce865
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:31:32 2014 -0700

    staging: comedi: amplc_pci230: use comedi_async 'scans_done' to detect AO EOA
    
    Remove the private data member 'ai_count' and use the comedi_async 'scans_done'
    member to detect the analog output end-of-acquisition.
    
    Use the helper function comedi_nscans_left() to get the number of scans in the
    async buffer of left in the command.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a46fffd28a3e..5f4b67505932 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -491,7 +491,6 @@ struct pci230_private {
 	spinlock_t ao_stop_spinlock;	/* Spin lock for stopping AO command */
 	unsigned long daqio;		/* PCI230's DAQ I/O space */
 	unsigned int ai_scan_count;	/* Number of AI scans remaining */
-	unsigned int ao_scan_count;	/* Number of AO scans remaining.  */
 	int intr_cpuid;			/* ID of CPU running ISR */
 	unsigned short hwver;		/* Hardware version (for '+' models) */
 	unsigned short adccon;		/* ADCCON register value */
@@ -1073,13 +1072,12 @@ static void pci230_ao_stop(struct comedi_device *dev,
 static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
-	struct pci230_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned short data;
 	int i;
 
-	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_scan_count == 0)
+	if (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)
 		return;
 
 	for (i = 0; i < cmd->chanlist_len; i++) {
@@ -1093,13 +1091,8 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 		s->readback[chan] = data;
 	}
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		devpriv->ao_scan_count--;
-		if (devpriv->ao_scan_count == 0) {
-			/* End of acquisition. */
-			async->events |= COMEDI_CB_EOA;
-		}
-	}
+	if (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)
+		async->events |= COMEDI_CB_EOA;
 }
 
 /*
@@ -1112,7 +1105,7 @@ static bool pci230_handle_ao_fifo(struct comedi_device *dev,
 	struct pci230_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	unsigned int num_scans;
+	unsigned int num_scans = comedi_nscans_left(s, 0);
 	unsigned int room;
 	unsigned short dacstat;
 	unsigned int i, n;
@@ -1120,17 +1113,10 @@ static bool pci230_handle_ao_fifo(struct comedi_device *dev,
 
 	/* Get DAC FIFO status. */
 	dacstat = inw(devpriv->daqio + PCI230_DACCON);
-	/* Determine number of scans available in buffer. */
-	num_scans = comedi_buf_read_n_available(s) / comedi_bytes_per_scan(s);
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* Fixed number of scans. */
-		if (num_scans > devpriv->ao_scan_count)
-			num_scans = devpriv->ao_scan_count;
-		if (devpriv->ao_scan_count == 0) {
-			/* End of acquisition. */
-			events |= COMEDI_CB_EOA;
-		}
-	}
+
+	if (cmd->stop_src == TRIG_COUNT && num_scans == 0)
+		events |= COMEDI_CB_EOA;
+
 	if (events == 0) {
 		/* Check for FIFO underrun. */
 		if (dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) {
@@ -1175,21 +1161,16 @@ static bool pci230_handle_ao_fifo(struct comedi_device *dev,
 			}
 		}
 
-		if (cmd->stop_src == TRIG_COUNT) {
-			devpriv->ao_scan_count -= num_scans;
-			if (devpriv->ao_scan_count == 0) {
-				/*
-				 * All data for the command has been written
-				 * to FIFO.  Set FIFO interrupt trigger level
-				 * to 'empty'.
-				 */
-				devpriv->daccon =
-				    (devpriv->daccon &
-				     ~PCI230P2_DAC_INT_FIFO_MASK) |
-				    PCI230P2_DAC_INT_FIFO_EMPTY;
-				outw(devpriv->daccon,
-				     devpriv->daqio + PCI230_DACCON);
-			}
+		if (cmd->stop_src == TRIG_COUNT &&
+		    async->scans_done >= cmd->stop_arg) {
+			/*
+			 * All data for the command has been written
+			 * to FIFO.  Set FIFO interrupt trigger level
+			 * to 'empty'.
+			 */
+			devpriv->daccon &= ~PCI230P2_DAC_INT_FIFO_MASK;
+			devpriv->daccon |= PCI230P2_DAC_INT_FIFO_EMPTY;
+			outw(devpriv->daccon, devpriv->daqio + PCI230_DACCON);
 		}
 		/* Check if FIFO underrun occurred while writing to FIFO. */
 		dacstat = inw(devpriv->daqio + PCI230_DACCON);
@@ -1341,8 +1322,6 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			return -EBUSY;
 	}
 
-	devpriv->ao_scan_count = cmd->stop_arg;
-
 	/*
 	 * Set range - see analogue output range table; 0 => unipolar 10V,
 	 * 1 => bipolar +/-10V range scale

commit 272fe8f51fd8b8cd1637c8d2ca868cbff725405e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 09:49:32 2014 -0700

    staging: comedi: amplc_pci230: remove private data 'ai_scan_pos'
    
    This member of the private data is replicating what the comedi_async
    'cur_chan' member is used for. Use that instead and remove the private
    data member.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 44c967f43d9a..a46fffd28a3e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -491,7 +491,6 @@ struct pci230_private {
 	spinlock_t ao_stop_spinlock;	/* Spin lock for stopping AO command */
 	unsigned long daqio;		/* PCI230's DAQ I/O space */
 	unsigned int ai_scan_count;	/* Number of AI scans remaining */
-	unsigned int ai_scan_pos;	/* Current position within AI scan */
 	unsigned int ao_scan_count;	/* Number of AO scans remaining.  */
 	int intr_cpuid;			/* ID of CPU running ISR */
 	unsigned short hwver;		/* Hardware version (for '+' models) */
@@ -1748,13 +1747,13 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 	unsigned short adccon;
 
 	if (cmd->flags & CMDF_WAKE_EOS)
-		wake = scanlen - devpriv->ai_scan_pos;
+		wake = scanlen - s->async->cur_chan;
 	else if (cmd->stop_src != TRIG_COUNT ||
 		 devpriv->ai_scan_count >= PCI230_ADC_FIFOLEVEL_HALFFULL ||
 		 scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL)
 		wake = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	else
-		wake = devpriv->ai_scan_count * scanlen - devpriv->ai_scan_pos;
+		wake = devpriv->ai_scan_count * scanlen - s->async->cur_chan;
 	if (wake >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
 		triglev = PCI230_ADC_INT_FIFO_HALF;
 	} else if (wake > 1 && devpriv->hwver > 0) {
@@ -2064,7 +2063,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 		   scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL) {
 		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	} else {
-		todo = devpriv->ai_scan_count * scanlen - devpriv->ai_scan_pos;
+		todo = devpriv->ai_scan_count * scanlen - async->cur_chan;
 		if (todo > PCI230_ADC_FIFOLEVEL_HALFFULL)
 			todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	}
@@ -2105,13 +2104,8 @@ static void pci230_handle_ai(struct comedi_device *dev,
 		comedi_buf_write_samples(s, &val, 1);
 
 		fifoamount--;
-		devpriv->ai_scan_pos++;
-		if (devpriv->ai_scan_pos == scanlen) {
-			/* End of scan. */
-			devpriv->ai_scan_pos = 0;
+		if (async->cur_chan == 0)
 			devpriv->ai_scan_count--;
-			async->events |= COMEDI_CB_EOS;
-		}
 	}
 	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_scan_count == 0) {
 		/* End of acquisition. */
@@ -2158,7 +2152,6 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EBUSY;
 
 	devpriv->ai_scan_count = cmd->stop_arg;
-	devpriv->ai_scan_pos = 0;	/* Position within scan. */
 
 	/*
 	 * Steps:

commit 48e08de087ad53b9893cbc44d5ce88e0b8d9f025
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:52 2014 -0700

    staging: comedi: amplc_pci230: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the sample to the async buffer.
    
    The async events will set properly by the core. A dev_warn() message will
    also be output by the core if the buffer overflows. Remove the unnecessary
    events and dev_err() message in the driver.
    
    The core will also add the COMEDI_CB_BLOCK event when data is written to
    the async buffer. Remove the unnecessary event in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index f9b952f7173e..44c967f43d9a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2053,6 +2053,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 	unsigned int i;
 	unsigned int todo;
 	unsigned int fifoamount;
+	unsigned short val;
 
 	/* Determine number of samples to read. */
 	if (cmd->stop_src != TRIG_COUNT) {
@@ -2099,12 +2100,10 @@ static void pci230_handle_ai(struct comedi_device *dev,
 				fifoamount = 1;
 			}
 		}
-		/* Read sample and store in Comedi's circular buffer. */
-		if (comedi_buf_put(s, pci230_ai_read(dev)) == 0) {
-			events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
-			dev_err(dev->class_dev, "AI buffer overflow\n");
-			break;
-		}
+
+		val = pci230_ai_read(dev);
+		comedi_buf_write_samples(s, &val, 1);
+
 		fifoamount--;
 		devpriv->ai_scan_pos++;
 		if (devpriv->ai_scan_pos == scanlen) {
@@ -2117,9 +2116,6 @@ static void pci230_handle_ai(struct comedi_device *dev,
 	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_scan_count == 0) {
 		/* End of acquisition. */
 		events |= COMEDI_CB_EOA;
-	} else {
-		/* More samples required, tell Comedi to block. */
-		events |= COMEDI_CB_BLOCK;
 	}
 	async->events |= events;
 	if (!(async->events & COMEDI_CB_CANCEL_MASK)) {

commit dec1a2668629755b4c926f1473ecd2615d3a3d73
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 14:36:44 2014 -0700

    staging: comedi: amplc_pci230: use comedi_buf_read_samples()
    
    Use comedi_buf_read_samples() to read the analog output samples from
    the async buffer. That function will set the COMEDI_CB_BLOCK event
    when samples are read from the async buffer. In addition, the core
    will also handle the end-of-scan detection and set the COMEDI_CB_EOS
    event.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a3b34d881a08..f9b952f7173e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1075,26 +1075,25 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
 	struct pci230_private *devpriv = dev->private;
-	unsigned short data;
-	int i, ret;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
+	unsigned short data;
+	int i;
 
 	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_scan_count == 0)
 		return;
+
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 
-		/* Read sample from Comedi's circular buffer. */
-		ret = comedi_buf_get(s, &data);
-		if (ret == 0) {
-			s->async->events |= COMEDI_CB_OVERFLOW;
+		if (!comedi_buf_read_samples(s, &data, 1)) {
+			async->events |= COMEDI_CB_OVERFLOW;
 			return;
 		}
 		pci230_ao_write_nofifo(dev, data, chan);
 		s->readback[chan] = data;
 	}
-	async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+
 	if (cmd->stop_src == TRIG_COUNT) {
 		devpriv->ao_scan_count--;
 		if (devpriv->ao_scan_count == 0) {
@@ -1171,12 +1170,12 @@ static bool pci230_handle_ao_fifo(struct comedi_device *dev,
 				unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 				unsigned short datum;
 
-				comedi_buf_get(s, &datum);
+				comedi_buf_read_samples(s, &datum, 1);
 				pci230_ao_write_fifo(dev, datum, chan);
 				s->readback[chan] = datum;
 			}
 		}
-		events |= COMEDI_CB_EOS | COMEDI_CB_BLOCK;
+
 		if (cmd->stop_src == TRIG_COUNT) {
 			devpriv->ao_scan_count -= num_scans;
 			if (devpriv->ao_scan_count == 0) {

commit 781f933c151ee47e3cc1c8ef5491db23f1b61c9a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 13 09:56:08 2014 -0700

    staging: comedi: comedidev.h: clarify async->event error/cancel detection
    
    Introduce COMEDI_CB_ERROR_MASK and COMEDI_CB_CANCEL_MASK to clarify the
    async->events that indicate errors and cancel an async command.
    
    Use the new defines to tidy up and clarify the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a04ce6bd3705..a3b34d881a08 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1119,7 +1119,6 @@ static bool pci230_handle_ao_fifo(struct comedi_device *dev,
 	unsigned short dacstat;
 	unsigned int i, n;
 	unsigned int events = 0;
-	bool running;
 
 	/* Get DAC FIFO status. */
 	dacstat = inw(devpriv->daqio + PCI230_DACCON);
@@ -1201,12 +1200,8 @@ static bool pci230_handle_ao_fifo(struct comedi_device *dev,
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
 	}
-	if (events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
-		running = false;
-	else
-		running = true;
 	async->events |= events;
-	return running;
+	return !(async->events & COMEDI_CB_CANCEL_MASK);
 }
 
 static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
@@ -2128,8 +2123,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 		events |= COMEDI_CB_BLOCK;
 	}
 	async->events |= events;
-	if (!(async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
-			       COMEDI_CB_OVERFLOW))) {
+	if (!(async->events & COMEDI_CB_CANCEL_MASK)) {
 		/* update FIFO interrupt trigger level */
 		pci230_ai_update_fifo_trigger_level(dev, s);
 	}

commit 36df06978adb2e960bad458a47a44e3f1cd4be2b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:41:14 2014 -0700

    staging: comedi: amplc_pci230: use comedi_bytes_per_scan()
    
    This inline function is just a wrapper around comedi_bytes_per_scan().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index b8fded313d64..a04ce6bd3705 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1124,7 +1124,7 @@ static bool pci230_handle_ao_fifo(struct comedi_device *dev,
 	/* Get DAC FIFO status. */
 	dacstat = inw(devpriv->daqio + PCI230_DACCON);
 	/* Determine number of scans available in buffer. */
-	num_scans = comedi_buf_read_n_available(s) / cfc_bytes_per_scan(s);
+	num_scans = comedi_buf_read_n_available(s) / comedi_bytes_per_scan(s);
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* Fixed number of scans. */
 		if (num_scans > devpriv->ao_scan_count)

commit 39064f23284c68d3ce98e7f7b673a0ffa78c17ce
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:35:42 2014 -0700

    staging: comedi: amplc_pci230: use comedi_handle_events()
    
    Use comedi_handle_events() to automatically (*cancel) the async command
    for an end-of-acquisition or if an error/overflow occurs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 8ed150689f97..b8fded313d64 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1089,8 +1089,6 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 		ret = comedi_buf_get(s, &data);
 		if (ret == 0) {
 			s->async->events |= COMEDI_CB_OVERFLOW;
-			pci230_ao_stop(dev, s);
-			dev_err(dev->class_dev, "AO buffer underrun\n");
 			return;
 		}
 		pci230_ao_write_nofifo(dev, data, chan);
@@ -1102,7 +1100,6 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 		if (devpriv->ao_scan_count == 0) {
 			/* End of acquisition. */
 			async->events |= COMEDI_CB_EOA;
-			pci230_ao_stop(dev, s);
 		}
 	}
 }
@@ -1204,13 +1201,10 @@ static bool pci230_handle_ao_fifo(struct comedi_device *dev,
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
 	}
-	if (events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {
-		/* Stopping AO due to completion or error. */
-		pci230_ao_stop(dev, s);
+	if (events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
 		running = false;
-	} else {
+	else
 		running = true;
-	}
 	async->events |= events;
 	return running;
 }
@@ -1235,7 +1229,7 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 		/* Not using DAC FIFO. */
 		spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
 		pci230_handle_ao_nofifo(dev, s);
-		comedi_event(dev, s);
+		comedi_handle_events(dev, s);
 	} else {
 		/* Using DAC FIFO. */
 		/* Read DACSWTRIG register to trigger conversion. */
@@ -1265,7 +1259,7 @@ static void pci230_ao_start(struct comedi_device *dev,
 
 		/* Preload FIFO data. */
 		run = pci230_handle_ao_fifo(dev, s);
-		comedi_event(dev, s);
+		comedi_handle_events(dev, s);
 		if (!run) {
 			/* Stopped. */
 			return;
@@ -2134,11 +2128,8 @@ static void pci230_handle_ai(struct comedi_device *dev,
 		events |= COMEDI_CB_BLOCK;
 	}
 	async->events |= events;
-	if (async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
-			     COMEDI_CB_OVERFLOW)) {
-		/* disable hardware conversions */
-		pci230_ai_stop(dev, s);
-	} else {
+	if (!(async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
+			       COMEDI_CB_OVERFLOW))) {
 		/* update FIFO interrupt trigger level */
 		pci230_ai_update_fifo_trigger_level(dev, s);
 	}
@@ -2355,7 +2346,8 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	unsigned char status_int, valid_status_int, temp_ier;
 	struct comedi_device *dev = (struct comedi_device *)d;
 	struct pci230_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
+	struct comedi_subdevice *s_ao = dev->write_subdev;
+	struct comedi_subdevice *s_ai = dev->read_subdev;
 	unsigned long irqflags;
 
 	/* Read interrupt status/enable register. */
@@ -2385,23 +2377,14 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	 * two.
 	 */
 
-	if (valid_status_int & PCI230_INT_ZCLK_CT1) {
-		s = dev->write_subdev;
-		pci230_handle_ao_nofifo(dev, s);
-		comedi_event(dev, s);
-	}
+	if (valid_status_int & PCI230_INT_ZCLK_CT1)
+		pci230_handle_ao_nofifo(dev, s_ao);
 
-	if (valid_status_int & PCI230P2_INT_DAC) {
-		s = dev->write_subdev;
-		pci230_handle_ao_fifo(dev, s);
-		comedi_event(dev, s);
-	}
+	if (valid_status_int & PCI230P2_INT_DAC)
+		pci230_handle_ao_fifo(dev, s_ao);
 
-	if (valid_status_int & PCI230_INT_ADC) {
-		s = dev->read_subdev;
-		pci230_handle_ai(dev, s);
-		comedi_event(dev, s);
-	}
+	if (valid_status_int & PCI230_INT_ADC)
+		pci230_handle_ai(dev, s_ai);
 
 	/* Reenable interrupts. */
 	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
@@ -2410,6 +2393,9 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	devpriv->intr_running = false;
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
+	comedi_handle_events(dev, s_ao);
+	comedi_handle_events(dev, s_ai);
+
 	return IRQ_HANDLED;
 }
 

commit 2d00485cacf729149eccceccadac95f86df3b1e1
Author: Tapasweni Pathak <tapaswenipathak@gmail.com>
Date:   Mon Oct 6 11:26:49 2014 +0530

    staging: comedi: drivers: Replace "the the " with "the"
    
    This patch replace "the the " with "the".
    The replacement couldn't be automated because sometimes
    the first "the" was meant to be another word.
    
    Signed-off-by: Tapasweni Pathak <tapaswenipathak@gmail.com>
    Acked-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 01796cd28e5b..8ed150689f97 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -35,7 +35,7 @@
  * automatically.
  *
  * The PCI230+ and PCI260+ have the same PCI device IDs as the PCI230 and
- * PCI260, but can be distinguished by the the size of the PCI regions.  A
+ * PCI260, but can be distinguished by the size of the PCI regions.  A
  * card will be configured as a "+" model if detected as such.
  *
  * Subdevices:

commit 1dabb50199791d60b15ddfc958a8b56e5ea26460
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:44 2014 -0700

    staging: comedi: amplc_pci230: 'ai_scan_count' is always 'stop_arg'
    
    When the cmd->stop_src == TRIG_COUNT, the 'ai_scan_count' is the cmd->stop_arg.
    For any other stop_src the 'ai_scan_count' is 0, which is also the cmd->stop_arg.
    
    Simplify the 'ai_scan_count' initialization.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a0bf4600c992..01796cd28e5b 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2177,11 +2177,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (!pci230_claim_shared(dev, res_mask, OWNER_AICMD))
 		return -EBUSY;
 
-	/* Get number of scans required. */
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->ai_scan_count = cmd->stop_arg;
-	else	/* TRIG_NONE, user calls cancel */
-		devpriv->ai_scan_count = 0;
+	devpriv->ai_scan_count = cmd->stop_arg;
 	devpriv->ai_scan_pos = 0;	/* Position within scan. */
 
 	/*

commit df9f5bad2187203d6c87cb406bab5f7675618498
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:43 2014 -0700

    staging: comedi: amplc_pci230: remove analog input "empty acquisition" async command
    
    This driver currently allows a cmd->stop_src == TRIG_COUNT with a cmd->stop_arg
    of 0. This causes the (*do_cmd) to immediately generate a COMEDI_CB_EOA event
    without acquiring any data.
    
    This "empty acquisition" async command is not really useful. Validate that the
    cmd->stop_arg is >= 1 in the (*do_cmdtest) and remove the "empty acquisition"
    code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a4d94f2605a3..a0bf4600c992 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1679,7 +1679,9 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->stop_src == TRIG_NONE)
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_EXT) {
@@ -1908,13 +1910,6 @@ static void pci230_ai_start(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &async->cmd;
 
 	devpriv->ai_cmd_started = true;
-	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_scan_count == 0) {
-		/* An empty acquisition! */
-		async->events |= COMEDI_CB_EOA;
-		pci230_ai_stop(dev, s);
-		comedi_event(dev, s);
-		return;
-	}
 
 	/* Enable ADC FIFO trigger level interrupt. */
 	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);

commit 6fabddd2261a84a4dbb4aac61baa7b4652c126e1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:42 2014 -0700

    staging: comedi: amplc_pci230: 'ao_scan_count' is always 'stop_arg'
    
    When the cmd->stop_src == TRIG_COUNT, the 'ao_scan_count' is the cmd->stop_arg.
    For any other stop_src the 'ao_scan_count' is 0, which is also the cmd->stop_arg.
    
    Simplify the 'ao_scan_count' initialization.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 886186d00d4d..a4d94f2605a3 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1354,11 +1354,7 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			return -EBUSY;
 	}
 
-	/* Get number of scans required. */
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->ao_scan_count = cmd->stop_arg;
-	else	/* TRIG_NONE, user calls cancel */
-		devpriv->ao_scan_count = 0;
+	devpriv->ao_scan_count = cmd->stop_arg;
 
 	/*
 	 * Set range - see analogue output range table; 0 => unipolar 10V,

commit 54d2925bd6b49b5330e8ebbdc83416b0b1605fa2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:41 2014 -0700

    staging: comedi: amplc_pci230: remove analog output "empty acquisition" async command
    
    This driver currently allows a cmd->stop_src == TRIG_COUNT with a cmd->stop_arg
    of 0. This causes the (*do_cmd) to immediately generate a COMEDI_CB_EOA event
    without acquiring any data.
    
    This "empty acquisition" async command is not really useful. Validate that the
    cmd->stop_arg is >= 1 in the (*do_cmdtest) and remove the "empty acquisition"
    code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index e9ca1745f0c9..886186d00d4d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -987,7 +987,9 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->stop_src == TRIG_NONE)
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
@@ -1255,13 +1257,7 @@ static void pci230_ao_start(struct comedi_device *dev,
 	unsigned long irqflags;
 
 	devpriv->ao_cmd_started = true;
-	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_scan_count == 0) {
-		/* An empty acquisition! */
-		async->events |= COMEDI_CB_EOA;
-		pci230_ao_stop(dev, s);
-		comedi_event(dev, s);
-		return;
-	}
+
 	if (devpriv->hwver >= 2) {
 		/* Using DAC FIFO. */
 		unsigned short scantrig;

commit e857c7ca7e2e2e4b2f58353d83648a1f2b8e6f54
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:22 2014 +0100

    staging: comedi: amplc_pci230: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index eb7501262dc8..e9ca1745f0c9 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -543,7 +543,7 @@ static const struct comedi_lrange pci230_ao_range = {
 
 static unsigned short pci230_ai_read(struct comedi_device *dev)
 {
-	const struct pci230_board *thisboard = comedi_board(dev);
+	const struct pci230_board *thisboard = dev->board_ptr;
 	struct pci230_private *devpriv = dev->private;
 	unsigned short data;
 
@@ -565,7 +565,7 @@ static unsigned short pci230_ai_read(struct comedi_device *dev)
 static unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
 					     unsigned short datum)
 {
-	const struct pci230_board *thisboard = comedi_board(dev);
+	const struct pci230_board *thisboard = dev->board_ptr;
 	struct pci230_private *devpriv = dev->private;
 
 	/*
@@ -894,7 +894,7 @@ static int pci230_ao_check_chanlist(struct comedi_device *dev,
 static int pci230_ao_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	const struct pci230_board *thisboard = comedi_board(dev);
+	const struct pci230_board *thisboard = dev->board_ptr;
 	struct pci230_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int tmp;
@@ -1556,7 +1556,7 @@ static int pci230_ai_check_chanlist(struct comedi_device *dev,
 static int pci230_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	const struct pci230_board *thisboard = comedi_board(dev);
+	const struct pci230_board *thisboard = dev->board_ptr;
 	struct pci230_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int tmp;
@@ -2487,7 +2487,7 @@ static int pci230_auto_attach(struct comedi_device *dev,
 			"amplc_pci230: BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
-	thisboard = comedi_board(dev);
+	thisboard = dev->board_ptr;
 	dev->board_name = thisboard->name;
 
 	rc = comedi_pci_enable(dev);

commit b8096616042aa52acde60b5aa610de112a93ad09
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:49 2014 +0100

    staging: comedi: amplc_pci230: use CMDF_ROUND_...
    
    Replace use of the `TRIG_ROUND_...` macros with the new names
    `CMDF_ROUND_...`.  The numeric values are unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 6642744b7871..eb7501262dc8 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -649,14 +649,14 @@ static unsigned int pci230_divide_ns(uint64_t ns, unsigned int timebase,
 
 	div = ns;
 	rem = do_div(div, timebase);
-	switch (flags & TRIG_ROUND_MASK) {
+	switch (flags & CMDF_ROUND_MASK) {
 	default:
-	case TRIG_ROUND_NEAREST:
+	case CMDF_ROUND_NEAREST:
 		div += (rem + (timebase / 2)) / timebase;
 		break;
-	case TRIG_ROUND_DOWN:
+	case CMDF_ROUND_DOWN:
 		break;
-	case TRIG_ROUND_UP:
+	case CMDF_ROUND_UP:
 		div += (rem + timebase - 1) / timebase;
 		break;
 	}
@@ -1735,7 +1735,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 		if (!pci230_ai_check_scan_period(cmd)) {
 			/* Was below minimum required.  Round up. */
 			pci230_ns_to_single_timer(&cmd->scan_begin_arg,
-						  TRIG_ROUND_UP);
+						  CMDF_ROUND_UP);
 			pci230_ai_check_scan_period(cmd);
 		}
 		if (tmp != cmd->scan_begin_arg)
@@ -2334,7 +2334,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			pci230_ct_setup_ns_mode(dev, 0, I8254_MODE1,
 						((uint64_t)cmd->convert_arg *
 						 cmd->scan_end_arg),
-						TRIG_ROUND_UP);
+						CMDF_ROUND_UP);
 			if (cmd->scan_begin_src == TRIG_TIMER) {
 				/*
 				 * Monostable on CT0 will be triggered by

commit e455494472330e73ffbbf35e6664e4fdc16edc54
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:34 2014 +0100

    staging: comedi: amplc_pci230: use CMDF_WAKE_EOS
    
    Replace use of `TRIG_WAKE_EOS` command flag with the new name
    `CMDF_WAKE_EOS`.  The numeric value is unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 66e7a4743f00..6642744b7871 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1765,7 +1765,7 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 	unsigned short triglev;
 	unsigned short adccon;
 
-	if (cmd->flags & TRIG_WAKE_EOS)
+	if (cmd->flags & CMDF_WAKE_EOS)
 		wake = scanlen - devpriv->ai_scan_pos;
 	else if (cmd->stop_src != TRIG_COUNT ||
 		 devpriv->ai_scan_count >= PCI230_ADC_FIFOLEVEL_HALFFULL ||

commit d8b0e4230fc3078314cedf674a664d227cd5c0e1
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:04:00 2014 +0100

    staging: comedi: amplc_pci230: simplify interrupt enable handling
    
    `struct pci230_private` has two members to manage the enabled interrupt
    sources.  `int_en` is the interrupt sources we want to be enabled and
    `ier` is a shadow of the write-only interrupt enable register.  They
    have the same value most of the time.  They differ in the interrupt
    handler (`pci230_interrupt()`) itself when it temporarily clears bits in
    the interrupt enable register and the `ier` member in order to unlatch
    them in hardware, but leaves the `int_en` member alone.  They also
    differ in `pci230_ai_stop()` and `pci230_ao_stop()` which clear bits in
    the `int_en` member and wait for the interrupt handler to finish before
    copying the value to the `ier` member and the interrupt enable register.
    
    Simplify the handling a bit, by making the `ier` member take on the role
    of the `int_en` member, and allowing the value to differ from the
    interrupt enable register while the interrupt handler is running.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 7748e17828ef..66e7a4743f00 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -499,8 +499,7 @@ struct pci230_private {
 	unsigned short daccon;		/* DACCON register value */
 	unsigned short adcfifothresh;	/* ADC FIFO threshold (PCI230+/260+) */
 	unsigned short adcg;		/* ADCG register value */
-	unsigned char int_en;		/* Interrupt enable bits */
-	unsigned char ier;		/* Copy of interrupt enable register */
+	unsigned char ier;		/* Interrupt enable bits */
 	unsigned char res_owned[NUM_OWNERS]; /* Owned resources */
 	bool intr_running:1;		/* Flag set in interrupt routine */
 	bool ai_bipolar:1;		/* Flag AI range is bipolar */
@@ -1049,15 +1048,12 @@ static void pci230_ao_stop(struct comedi_device *dev,
 	 * unless we are called from the interrupt routine.
 	 */
 	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-	devpriv->int_en &= ~intsrc;
+	devpriv->ier &= ~intsrc;
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
 		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	}
-	if (devpriv->ier != devpriv->int_en) {
-		devpriv->ier = devpriv->int_en;
-		outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
-	}
+	outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 	if (devpriv->hwver >= 2) {
 		/*
@@ -1311,7 +1307,6 @@ static void pci230_ao_start(struct comedi_device *dev,
 			/* Not using DAC FIFO. */
 			/* Enable CT1 timer interrupt. */
 			spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-			devpriv->int_en |= PCI230_INT_ZCLK_CT1;
 			devpriv->ier |= PCI230_INT_ZCLK_CT1;
 			outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 			spin_unlock_irqrestore(&devpriv->isr_spinlock,
@@ -1327,7 +1322,6 @@ static void pci230_ao_start(struct comedi_device *dev,
 	if (devpriv->hwver >= 2) {
 		/* Using DAC FIFO.  Enable DAC FIFO interrupt. */
 		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-		devpriv->int_en |= PCI230P2_INT_DAC;
 		devpriv->ier |= PCI230P2_INT_DAC;
 		outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
@@ -1892,15 +1886,12 @@ static void pci230_ai_stop(struct comedi_device *dev,
 	 * Disable ADC interrupt and wait for interrupt routine to finish
 	 * running unless we are called from the interrupt routine.
 	 */
-	devpriv->int_en &= ~PCI230_INT_ADC;
+	devpriv->ier &= ~PCI230_INT_ADC;
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
 		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	}
-	if (devpriv->ier != devpriv->int_en) {
-		devpriv->ier = devpriv->int_en;
-		outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
-	}
+	outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 	/*
 	 * Reset FIFO, disable FIFO and set start conversion source to none.
@@ -1935,7 +1926,6 @@ static void pci230_ai_start(struct comedi_device *dev,
 
 	/* Enable ADC FIFO trigger level interrupt. */
 	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-	devpriv->int_en |= PCI230_INT_ADC;
 	devpriv->ier |= PCI230_INT_ADC;
 	outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
@@ -2379,7 +2369,7 @@ static int pci230_ai_cancel(struct comedi_device *dev,
 /* Interrupt handler */
 static irqreturn_t pci230_interrupt(int irq, void *d)
 {
-	unsigned char status_int, valid_status_int;
+	unsigned char status_int, valid_status_int, temp_ier;
 	struct comedi_device *dev = (struct comedi_device *)d;
 	struct pci230_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
@@ -2392,14 +2382,14 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 		return IRQ_NONE;
 
 	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-	valid_status_int = devpriv->int_en & status_int;
+	valid_status_int = devpriv->ier & status_int;
 	/*
 	 * Disable triggered interrupts.
 	 * (Only those interrupts that need re-enabling, are, later in the
 	 * handler).
 	 */
-	devpriv->ier = devpriv->int_en & ~status_int;
-	outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
+	temp_ier = devpriv->ier & ~status_int;
+	outb(temp_ier, dev->iobase + PCI230_INT_SCE);
 	devpriv->intr_running = true;
 	devpriv->intr_cpuid = THISCPU;
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
@@ -2432,10 +2422,8 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 
 	/* Reenable interrupts. */
 	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-	if (devpriv->ier != devpriv->int_en) {
-		devpriv->ier = devpriv->int_en;
+	if (devpriv->ier != temp_ier)
 		outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
-	}
 	devpriv->intr_running = false;
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 

commit bb8ef9231f9f7ee1dc685ac6b0f2360a4eab0e31
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:59 2014 +0100

    staging: comedi: amplc_pci230: change pci230_handle_ao_fifo() return type
    
    Change the return type of `pci230_handle_ao_fifo()` from `int` to
    `bool`.  A return value of `true` indicates the AO command is still
    running.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 27ff5bec8bc7..7748e17828ef 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1109,10 +1109,12 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 	}
 }
 
-/* Loads DAC FIFO (if using it) from buffer. */
-/* Returns 0 if AO finished due to completion or error, 1 if still going. */
-static int pci230_handle_ao_fifo(struct comedi_device *dev,
-				 struct comedi_subdevice *s)
+/*
+ * Loads DAC FIFO (if using it) from buffer.
+ * Returns false if AO finished due to completion or error, true if still going.
+ */
+static bool pci230_handle_ao_fifo(struct comedi_device *dev,
+				  struct comedi_subdevice *s)
 {
 	struct pci230_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
@@ -1122,7 +1124,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 	unsigned short dacstat;
 	unsigned int i, n;
 	unsigned int events = 0;
-	int running;
+	bool running;
 
 	/* Get DAC FIFO status. */
 	dacstat = inw(devpriv->daqio + PCI230_DACCON);
@@ -1207,9 +1209,9 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 	if (events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {
 		/* Stopping AO due to completion or error. */
 		pci230_ao_stop(dev, s);
-		running = 0;
+		running = false;
 	} else {
-		running = 1;
+		running = true;
 	}
 	async->events |= events;
 	return running;
@@ -1267,7 +1269,7 @@ static void pci230_ao_start(struct comedi_device *dev,
 	if (devpriv->hwver >= 2) {
 		/* Using DAC FIFO. */
 		unsigned short scantrig;
-		int run;
+		bool run;
 
 		/* Preload FIFO data. */
 		run = pci230_handle_ao_fifo(dev, s);

commit 39455e17fa9c453c3671b34ca67d79904fafccb8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:58 2014 +0100

    staging: comedi: amplc_pci230: reduce indentation in pci230_ai_start()
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index b0313c8d4836..27ff5bec8bc7 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1928,139 +1928,134 @@ static void pci230_ai_start(struct comedi_device *dev,
 		async->events |= COMEDI_CB_EOA;
 		pci230_ai_stop(dev, s);
 		comedi_event(dev, s);
-	} else {
-		/* Enable ADC FIFO trigger level interrupt. */
-		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-		devpriv->int_en |= PCI230_INT_ADC;
-		devpriv->ier |= PCI230_INT_ADC;
-		outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
-		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+		return;
+	}
 
-		/*
-		 * Update conversion trigger source which is currently set
-		 * to CT2 output, which is currently stuck high.
-		 */
-		switch (cmd->convert_src) {
-		default:
-			conv = PCI230_ADC_TRIG_NONE;
-			break;
-		case TRIG_TIMER:
-			/* Using CT2 output. */
-			conv = PCI230_ADC_TRIG_Z2CT2;
-			break;
-		case TRIG_EXT:
-			if (cmd->convert_arg & CR_EDGE) {
-				if ((cmd->convert_arg & CR_INVERT) == 0) {
-					/* Trigger on +ve edge. */
-					conv = PCI230_ADC_TRIG_EXTP;
-				} else {
-					/* Trigger on -ve edge. */
-					conv = PCI230_ADC_TRIG_EXTN;
-				}
+	/* Enable ADC FIFO trigger level interrupt. */
+	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	devpriv->int_en |= PCI230_INT_ADC;
+	devpriv->ier |= PCI230_INT_ADC;
+	outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
+	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+
+	/*
+	 * Update conversion trigger source which is currently set
+	 * to CT2 output, which is currently stuck high.
+	 */
+	switch (cmd->convert_src) {
+	default:
+		conv = PCI230_ADC_TRIG_NONE;
+		break;
+	case TRIG_TIMER:
+		/* Using CT2 output. */
+		conv = PCI230_ADC_TRIG_Z2CT2;
+		break;
+	case TRIG_EXT:
+		if (cmd->convert_arg & CR_EDGE) {
+			if ((cmd->convert_arg & CR_INVERT) == 0) {
+				/* Trigger on +ve edge. */
+				conv = PCI230_ADC_TRIG_EXTP;
 			} else {
-				/* Backwards compatibility. */
-				if (cmd->convert_arg) {
-					/* Trigger on +ve edge. */
-					conv = PCI230_ADC_TRIG_EXTP;
-				} else {
-					/* Trigger on -ve edge. */
-					conv = PCI230_ADC_TRIG_EXTN;
-				}
+				/* Trigger on -ve edge. */
+				conv = PCI230_ADC_TRIG_EXTN;
+			}
+		} else {
+			/* Backwards compatibility. */
+			if (cmd->convert_arg) {
+				/* Trigger on +ve edge. */
+				conv = PCI230_ADC_TRIG_EXTP;
+			} else {
+				/* Trigger on -ve edge. */
+				conv = PCI230_ADC_TRIG_EXTN;
 			}
-			break;
-		case TRIG_INT:
-			/*
-			 * Use CT2 output for software trigger due to problems
-			 * in differential mode on PCI230/260.
-			 */
-			conv = PCI230_ADC_TRIG_Z2CT2;
-			break;
 		}
-		devpriv->adccon =
-		    (devpriv->adccon & ~PCI230_ADC_TRIG_MASK) | conv;
-		outw(devpriv->adccon, devpriv->daqio + PCI230_ADCCON);
-		if (cmd->convert_src == TRIG_INT)
-			async->inttrig = pci230_ai_inttrig_convert;
-
+		break;
+	case TRIG_INT:
 		/*
-		 * Update FIFO interrupt trigger level, which is currently
-		 * set to "full".
+		 * Use CT2 output for software trigger due to problems
+		 * in differential mode on PCI230/260.
 		 */
-		pci230_ai_update_fifo_trigger_level(dev, s);
-		if (cmd->convert_src == TRIG_TIMER) {
-			/* Update timer gates. */
-			unsigned char zgat;
+		conv = PCI230_ADC_TRIG_Z2CT2;
+		break;
+	}
+	devpriv->adccon = (devpriv->adccon & ~PCI230_ADC_TRIG_MASK) | conv;
+	outw(devpriv->adccon, devpriv->daqio + PCI230_ADCCON);
+	if (cmd->convert_src == TRIG_INT)
+		async->inttrig = pci230_ai_inttrig_convert;
+
+	/*
+	 * Update FIFO interrupt trigger level, which is currently
+	 * set to "full".
+	 */
+	pci230_ai_update_fifo_trigger_level(dev, s);
+	if (cmd->convert_src == TRIG_TIMER) {
+		/* Update timer gates. */
+		unsigned char zgat;
 
-			if (cmd->scan_begin_src != TRIG_FOLLOW) {
+		if (cmd->scan_begin_src != TRIG_FOLLOW) {
+			/*
+			 * Conversion timer CT2 needs to be gated by
+			 * inverted output of monostable CT2.
+			 */
+			zgat = GAT_CONFIG(2, GAT_NOUTNM2);
+		} else {
+			/*
+			 * Conversion timer CT2 needs to be gated on
+			 * continuously.
+			 */
+			zgat = GAT_CONFIG(2, GAT_VCC);
+		}
+		outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
+		if (cmd->scan_begin_src != TRIG_FOLLOW) {
+			/* Set monostable CT0 trigger source. */
+			switch (cmd->scan_begin_src) {
+			default:
+				zgat = GAT_CONFIG(0, GAT_VCC);
+				break;
+			case TRIG_EXT:
 				/*
-				 * Conversion timer CT2 needs to be gated by
-				 * inverted output of monostable CT2.
+				 * For CT0 on PCI230, the external trigger
+				 * (gate) signal comes from PPC0, which is
+				 * channel 16 of the DIO subdevice.  The
+				 * application needs to configure this as an
+				 * input in order to use it as an external scan
+				 * trigger.
 				 */
-				zgat = GAT_CONFIG(2, GAT_NOUTNM2);
-			} else {
+				zgat = GAT_CONFIG(0, GAT_EXT);
+				break;
+			case TRIG_TIMER:
 				/*
-				 * Conversion timer CT2 needs to be gated on
-				 * continuously.
+				 * Monostable CT0 triggered by rising edge on
+				 * inverted output of CT1 (falling edge on CT1).
 				 */
-				zgat = GAT_CONFIG(2, GAT_VCC);
+				zgat = GAT_CONFIG(0, GAT_NOUTNM2);
+				break;
+			case TRIG_INT:
+				/*
+				 * Monostable CT0 is triggered by inttrig
+				 * function waggling the CT0 gate source.
+				 */
+				zgat = GAT_CONFIG(0, GAT_VCC);
+				break;
 			}
 			outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
-			if (cmd->scan_begin_src != TRIG_FOLLOW) {
-				/* Set monostable CT0 trigger source. */
-				switch (cmd->scan_begin_src) {
-				default:
-					zgat = GAT_CONFIG(0, GAT_VCC);
-					break;
-				case TRIG_EXT:
-					/*
-					 * For CT0 on PCI230, the external
-					 * trigger (gate) signal comes from
-					 * PPC0, which is channel 16 of the DIO
-					 * subdevice.  The application needs to
-					 * configure this as an input in order
-					 * to use it as an external scan
-					 * trigger.
-					 */
-					zgat = GAT_CONFIG(0, GAT_EXT);
-					break;
-				case TRIG_TIMER:
-					/*
-					 * Monostable CT0 triggered by rising
-					 * edge on inverted output of CT1
-					 * (falling edge on CT1).
-					 */
-					zgat = GAT_CONFIG(0, GAT_NOUTNM2);
-					break;
-				case TRIG_INT:
-					/*
-					 * Monostable CT0 is triggered by
-					 * inttrig function waggling the CT0
-					 * gate source.
-					 */
-					zgat = GAT_CONFIG(0, GAT_VCC);
-					break;
-				}
+			switch (cmd->scan_begin_src) {
+			case TRIG_TIMER:
+				/*
+				 * Scan period timer CT1 needs to be
+				 * gated on to start counting.
+				 */
+				zgat = GAT_CONFIG(1, GAT_VCC);
 				outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
-				switch (cmd->scan_begin_src) {
-				case TRIG_TIMER:
-					/*
-					 * Scan period timer CT1 needs to be
-					 * gated on to start counting.
-					 */
-					zgat = GAT_CONFIG(1, GAT_VCC);
-					outb(zgat,
-					     dev->iobase + PCI230_ZGAT_SCE);
-					break;
-				case TRIG_INT:
-					async->inttrig =
-					    pci230_ai_inttrig_scan_begin;
-					break;
-				}
+				break;
+			case TRIG_INT:
+				async->inttrig = pci230_ai_inttrig_scan_begin;
+				break;
 			}
-		} else if (cmd->convert_src != TRIG_INT) {
-			/* No longer need Z2-CT2. */
-			pci230_release_shared(dev, RES_Z2CT2, OWNER_AICMD);
 		}
+	} else if (cmd->convert_src != TRIG_INT) {
+		/* No longer need Z2-CT2. */
+		pci230_release_shared(dev, RES_Z2CT2, OWNER_AICMD);
 	}
 }
 

commit a6303f15e25babc6b13bd82489264226d5ec8f8a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:57 2014 +0100

    staging: comedi: amplc_pci230: reduce indentation in pci230_ai_inttrig_convert()
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index e0b40b38e24b..b0313c8d4836 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1802,43 +1802,39 @@ static int pci230_ai_inttrig_convert(struct comedi_device *dev,
 {
 	struct pci230_private *devpriv = dev->private;
 	unsigned long irqflags;
+	unsigned int delayus;
 
 	if (trig_num)
 		return -EINVAL;
 
 	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
-	if (devpriv->ai_cmd_started) {
-		unsigned int delayus;
-
-		/*
-		 * Trigger conversion by toggling Z2-CT2 output.
-		 * Finish with output high.
-		 */
-		i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0,
-			       2, I8254_MODE0);
-		i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0,
-			       2, I8254_MODE1);
-		/*
-		 * Delay.  Should driver be responsible for this?  An
-		 * alternative would be to wait until conversion is complete,
-		 * but we can't tell when it's complete because the ADC busy
-		 * bit has a different meaning when FIFO enabled (and when
-		 * FIFO not enabled, it only works for software triggers).
-		 */
-		if ((devpriv->adccon & PCI230_ADC_IM_MASK) ==
-		    PCI230_ADC_IM_DIF && devpriv->hwver == 0) {
-			/* PCI230/260 in differential mode */
-			delayus = 8;
-		} else {
-			/* single-ended or PCI230+/260+ */
-			delayus = 4;
-		}
+	if (!devpriv->ai_cmd_started) {
 		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
-		udelay(delayus);
+		return 1;
+	}
+	/*
+	 * Trigger conversion by toggling Z2-CT2 output.
+	 * Finish with output high.
+	 */
+	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE0);
+	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE1);
+	/*
+	 * Delay.  Should driver be responsible for this?  An
+	 * alternative would be to wait until conversion is complete,
+	 * but we can't tell when it's complete because the ADC busy
+	 * bit has a different meaning when FIFO enabled (and when
+	 * FIFO not enabled, it only works for software triggers).
+	 */
+	if ((devpriv->adccon & PCI230_ADC_IM_MASK) == PCI230_ADC_IM_DIF &&
+	    devpriv->hwver == 0) {
+		/* PCI230/260 in differential mode */
+		delayus = 8;
 	} else {
-		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
+		/* single-ended or PCI230+/260+ */
+		delayus = 4;
 	}
-
+	spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
+	udelay(delayus);
 	return 1;
 }
 

commit a046e4c1cc64aec5653abaf3de215c2131252ea6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:56 2014 +0100

    staging: comedi: amplc_pci230: reduce indentation in pci230_ao_start()
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a44b056bc1b7..e0b40b38e24b 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1262,78 +1262,73 @@ static void pci230_ao_start(struct comedi_device *dev,
 		async->events |= COMEDI_CB_EOA;
 		pci230_ao_stop(dev, s);
 		comedi_event(dev, s);
-	} else {
-		if (devpriv->hwver >= 2) {
-			/* Using DAC FIFO. */
-			unsigned short scantrig;
-			int run;
-
-			/* Preload FIFO data. */
-			run = pci230_handle_ao_fifo(dev, s);
-			comedi_event(dev, s);
-			if (!run) {
-				/* Stopped. */
-				return;
-			}
-			/* Set scan trigger source. */
-			switch (cmd->scan_begin_src) {
-			case TRIG_TIMER:
-				scantrig = PCI230P2_DAC_TRIG_Z2CT1;
-				break;
-			case TRIG_EXT:
-				/* Trigger on EXTTRIG/EXTCONVCLK pin. */
-				if ((cmd->scan_begin_arg & CR_INVERT) == 0) {
-					/* +ve edge */
-					scantrig = PCI230P2_DAC_TRIG_EXTP;
-				} else {
-					/* -ve edge */
-					scantrig = PCI230P2_DAC_TRIG_EXTN;
-				}
-				break;
-			case TRIG_INT:
-				scantrig = PCI230P2_DAC_TRIG_SW;
-				break;
-			default:
-				/* Shouldn't get here. */
-				scantrig = PCI230P2_DAC_TRIG_NONE;
-				break;
-			}
-			devpriv->daccon =
-			    (devpriv->daccon & ~PCI230P2_DAC_TRIG_MASK) |
-			    scantrig;
-			outw(devpriv->daccon, devpriv->daqio + PCI230_DACCON);
+		return;
+	}
+	if (devpriv->hwver >= 2) {
+		/* Using DAC FIFO. */
+		unsigned short scantrig;
+		int run;
+
+		/* Preload FIFO data. */
+		run = pci230_handle_ao_fifo(dev, s);
+		comedi_event(dev, s);
+		if (!run) {
+			/* Stopped. */
+			return;
 		}
+		/* Set scan trigger source. */
 		switch (cmd->scan_begin_src) {
 		case TRIG_TIMER:
-			if (devpriv->hwver < 2) {
-				/* Not using DAC FIFO. */
-				/* Enable CT1 timer interrupt. */
-				spin_lock_irqsave(&devpriv->isr_spinlock,
-						  irqflags);
-				devpriv->int_en |= PCI230_INT_ZCLK_CT1;
-				devpriv->ier |= PCI230_INT_ZCLK_CT1;
-				outb(devpriv->ier,
-				     dev->iobase + PCI230_INT_SCE);
-				spin_unlock_irqrestore(&devpriv->isr_spinlock,
-						       irqflags);
+			scantrig = PCI230P2_DAC_TRIG_Z2CT1;
+			break;
+		case TRIG_EXT:
+			/* Trigger on EXTTRIG/EXTCONVCLK pin. */
+			if ((cmd->scan_begin_arg & CR_INVERT) == 0) {
+				/* +ve edge */
+				scantrig = PCI230P2_DAC_TRIG_EXTP;
+			} else {
+				/* -ve edge */
+				scantrig = PCI230P2_DAC_TRIG_EXTN;
 			}
-			/* Set CT1 gate high to start counting. */
-			outb(GAT_CONFIG(1, GAT_VCC),
-			     dev->iobase + PCI230_ZGAT_SCE);
 			break;
 		case TRIG_INT:
-			async->inttrig = pci230_ao_inttrig_scan_begin;
+			scantrig = PCI230P2_DAC_TRIG_SW;
+			break;
+		default:
+			/* Shouldn't get here. */
+			scantrig = PCI230P2_DAC_TRIG_NONE;
 			break;
 		}
-		if (devpriv->hwver >= 2) {
-			/* Using DAC FIFO.  Enable DAC FIFO interrupt. */
+		devpriv->daccon =
+		    (devpriv->daccon & ~PCI230P2_DAC_TRIG_MASK) | scantrig;
+		outw(devpriv->daccon, devpriv->daqio + PCI230_DACCON);
+	}
+	switch (cmd->scan_begin_src) {
+	case TRIG_TIMER:
+		if (devpriv->hwver < 2) {
+			/* Not using DAC FIFO. */
+			/* Enable CT1 timer interrupt. */
 			spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-			devpriv->int_en |= PCI230P2_INT_DAC;
-			devpriv->ier |= PCI230P2_INT_DAC;
+			devpriv->int_en |= PCI230_INT_ZCLK_CT1;
+			devpriv->ier |= PCI230_INT_ZCLK_CT1;
 			outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 			spin_unlock_irqrestore(&devpriv->isr_spinlock,
 					       irqflags);
 		}
+		/* Set CT1 gate high to start counting. */
+		outb(GAT_CONFIG(1, GAT_VCC), dev->iobase + PCI230_ZGAT_SCE);
+		break;
+	case TRIG_INT:
+		async->inttrig = pci230_ao_inttrig_scan_begin;
+		break;
+	}
+	if (devpriv->hwver >= 2) {
+		/* Using DAC FIFO.  Enable DAC FIFO interrupt. */
+		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+		devpriv->int_en |= PCI230P2_INT_DAC;
+		devpriv->ier |= PCI230P2_INT_DAC;
+		outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
+		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 	}
 }
 

commit 0dab04882ed3be085faf370b34f0e6fee5eb5afc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:55 2014 +0100

    staging: comedi: amplc_pci230: reduce indentation in pci230_ao_inttrig_scan_begin()
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 727de3d75c7b..a44b056bc1b7 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1226,28 +1226,25 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 		return -EINVAL;
 
 	spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
-	if (devpriv->ao_cmd_started) {
-		/* Perform scan. */
-		if (devpriv->hwver < 2) {
-			/* Not using DAC FIFO. */
-			spin_unlock_irqrestore(&devpriv->ao_stop_spinlock,
-					       irqflags);
-			pci230_handle_ao_nofifo(dev, s);
-			comedi_event(dev, s);
-		} else {
-			/* Using DAC FIFO. */
-			/* Read DACSWTRIG register to trigger conversion. */
-			inw(devpriv->daqio + PCI230P2_DACSWTRIG);
-			spin_unlock_irqrestore(&devpriv->ao_stop_spinlock,
-					       irqflags);
-		}
-		/* Delay.  Should driver be responsible for this? */
-		/* XXX TODO: See if DAC busy bit can be used. */
-		udelay(8);
+	if (!devpriv->ao_cmd_started) {
+		spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
+		return 1;
+	}
+	/* Perform scan. */
+	if (devpriv->hwver < 2) {
+		/* Not using DAC FIFO. */
+		spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
+		pci230_handle_ao_nofifo(dev, s);
+		comedi_event(dev, s);
 	} else {
+		/* Using DAC FIFO. */
+		/* Read DACSWTRIG register to trigger conversion. */
+		inw(devpriv->daqio + PCI230P2_DACSWTRIG);
 		spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
 	}
-
+	/* Delay.  Should driver be responsible for this? */
+	/* XXX TODO: See if DAC busy bit can be used. */
+	udelay(8);
 	return 1;
 }
 

commit beafb60389773e13152c7f67e05ba05111eef0f4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:54 2014 +0100

    staging: comedi: amplc_pci230: rewrite shared resource handling
    
    Some counter channels may be required for AI commands and AO commands.
    Depending on how the commands are set up, it may not be possible to run
    both at the same time, so we keep some state and code to find out if the
    required resources are busy or not.
    
    The existing code is a bit unwieldy - the code for claiming resources
    involves two `for` loops for example.  Rewrite it to make it simpler.
    
    The new code just has a bit-mask value for each shared resource (counter
    channels), and an array indexed by resource "owners" (AI and AO
    commands), so the code for claiming resources now just has a single loop
    that checks that none of the other owners have claimed the wanted
    resources.
    
    Rename the functions involved, because the old names involving 'put' and
    'get' suggested some sort of usage counting.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 7a8291adecea..727de3d75c7b 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -421,16 +421,15 @@
  * (Potentially) shared resources and their owners
  */
 enum {
-	RES_Z2CT0,		/* Z2-CT0 */
-	RES_Z2CT1,		/* Z2-CT1 */
-	RES_Z2CT2,		/* Z2-CT2 */
-	NUM_RESOURCES		/* Number of (potentially) shared resources. */
+	RES_Z2CT0 = (1U << 0),	/* Z2-CT0 */
+	RES_Z2CT1 = (1U << 1),	/* Z2-CT1 */
+	RES_Z2CT2 = (1U << 2)	/* Z2-CT2 */
 };
 
 enum {
-	OWNER_NONE,		/* Not owned */
 	OWNER_AICMD,		/* Owned by AI command */
-	OWNER_AOCMD		/* Owned by AO command */
+	OWNER_AOCMD,		/* Owned by AO command */
+	NUM_OWNERS		/* Number of owners */
 };
 
 /*
@@ -502,7 +501,7 @@ struct pci230_private {
 	unsigned short adcg;		/* ADCG register value */
 	unsigned char int_en;		/* Interrupt enable bits */
 	unsigned char ier;		/* Copy of interrupt enable register */
-	unsigned char res_owner[NUM_RESOURCES]; /* Shared resource owners */
+	unsigned char res_owned[NUM_OWNERS]; /* Owned resources */
 	bool intr_running:1;		/* Flag set in interrupt routine */
 	bool ai_bipolar:1;		/* Flag AI range is bipolar */
 	bool ao_bipolar:1;		/* Flag AO range is bipolar */
@@ -604,77 +603,43 @@ static void pci230_ao_write_fifo(struct comedi_device *dev,
 	     devpriv->daqio + PCI230P2_DACDATA);
 }
 
-static int pci230_get_resources(struct comedi_device *dev,
-				unsigned int res_mask, unsigned char owner)
+static bool pci230_claim_shared(struct comedi_device *dev,
+				unsigned char res_mask, unsigned int owner)
 {
 	struct pci230_private *devpriv = dev->private;
-	int ok;
-	unsigned int i;
-	unsigned int b;
-	unsigned int claimed;
+	unsigned int o;
 	unsigned long irqflags;
 
-	ok = 1;
-	claimed = 0;
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
-	for (b = 1, i = 0; i < NUM_RESOURCES && res_mask; b <<= 1, i++) {
-		if (res_mask & b) {
-			res_mask &= ~b;
-			if (devpriv->res_owner[i] == OWNER_NONE) {
-				devpriv->res_owner[i] = owner;
-				claimed |= b;
-			} else if (devpriv->res_owner[i] != owner) {
-				for (b = 1, i = 0; claimed; b <<= 1, i++) {
-					if (claimed & b) {
-						devpriv->res_owner[i] =
-						    OWNER_NONE;
-						claimed &= ~b;
-					}
-				}
-				ok = 0;
-				break;
-			}
+	for (o = 0; o < NUM_OWNERS; o++) {
+		if (o == owner)
+			continue;
+		if (devpriv->res_owned[o] & res_mask) {
+			spin_unlock_irqrestore(&devpriv->res_spinlock,
+					       irqflags);
+			return false;
 		}
 	}
+	devpriv->res_owned[owner] |= res_mask;
 	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
-	return ok;
-}
-
-static int pci230_get_one_resource(struct comedi_device *dev,
-				   unsigned int resource, unsigned char owner)
-{
-	return pci230_get_resources(dev, 1U << resource, owner);
+	return true;
 }
 
-static void pci230_put_resources(struct comedi_device *dev,
-				 unsigned int res_mask, unsigned char owner)
+static void pci230_release_shared(struct comedi_device *dev,
+				  unsigned char res_mask, unsigned int owner)
 {
 	struct pci230_private *devpriv = dev->private;
-	unsigned int i;
-	unsigned int b;
 	unsigned long irqflags;
 
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
-	for (b = 1, i = 0; i < NUM_RESOURCES && res_mask; b <<= 1, i++) {
-		if (res_mask & b) {
-			res_mask &= ~b;
-			if (devpriv->res_owner[i] == owner)
-				devpriv->res_owner[i] = OWNER_NONE;
-		}
-	}
+	devpriv->res_owned[owner] &= ~res_mask;
 	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
 }
 
-static void pci230_put_one_resource(struct comedi_device *dev,
-				    unsigned int resource, unsigned char owner)
-{
-	pci230_put_resources(dev, 1U << resource, owner);
-}
-
-static void pci230_put_all_resources(struct comedi_device *dev,
-				     unsigned char owner)
+static void pci230_release_all_resources(struct comedi_device *dev,
+					 unsigned int owner)
 {
-	pci230_put_resources(dev, (1U << NUM_RESOURCES) - 1, owner);
+	pci230_release_shared(dev, (unsigned char)~0, owner);
 }
 
 static unsigned int pci230_divide_ns(uint64_t ns, unsigned int timebase,
@@ -1105,7 +1070,7 @@ static void pci230_ao_stop(struct comedi_device *dev,
 		     devpriv->daqio + PCI230_DACCON);
 	}
 	/* Release resources. */
-	pci230_put_all_resources(dev, OWNER_AOCMD);
+	pci230_release_all_resources(dev, OWNER_AOCMD);
 }
 
 static void pci230_handle_ao_nofifo(struct comedi_device *dev,
@@ -1401,7 +1366,7 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		/* Claim Z2-CT1. */
-		if (!pci230_get_one_resource(dev, RES_Z2CT1, OWNER_AOCMD))
+		if (!pci230_claim_shared(dev, RES_Z2CT1, OWNER_AOCMD))
 			return -EBUSY;
 	}
 
@@ -1957,7 +1922,7 @@ static void pci230_ai_stop(struct comedi_device *dev,
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
 	     devpriv->daqio + PCI230_ADCCON);
 	/* Release resources. */
-	pci230_put_all_resources(dev, OWNER_AICMD);
+	pci230_release_all_resources(dev, OWNER_AICMD);
 }
 
 static void pci230_ai_start(struct comedi_device *dev,
@@ -2106,7 +2071,7 @@ static void pci230_ai_start(struct comedi_device *dev,
 			}
 		} else if (cmd->convert_src != TRIG_INT) {
 			/* No longer need Z2-CT2. */
-			pci230_put_one_resource(dev, RES_Z2CT2, OWNER_AICMD);
+			pci230_release_shared(dev, RES_Z2CT2, OWNER_AICMD);
 		}
 	}
 }
@@ -2237,17 +2202,17 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * Need Z2-CT2 to supply a conversion trigger source at a high
 	 * logic level, even if not doing timed conversions.
 	 */
-	res_mask |= 1U << RES_Z2CT2;
+	res_mask |= RES_Z2CT2;
 	if (cmd->scan_begin_src != TRIG_FOLLOW) {
 		/* Using Z2-CT0 monostable to gate Z2-CT2 conversion timer */
-		res_mask |= 1U << RES_Z2CT0;
+		res_mask |= RES_Z2CT0;
 		if (cmd->scan_begin_src == TRIG_TIMER) {
 			/* Using Z2-CT1 for scan frequency */
-			res_mask |= 1U << RES_Z2CT1;
+			res_mask |= RES_Z2CT1;
 		}
 	}
 	/* Claim resources. */
-	if (!pci230_get_resources(dev, res_mask, OWNER_AICMD))
+	if (!pci230_claim_shared(dev, res_mask, OWNER_AICMD))
 		return -EBUSY;
 
 	/* Get number of scans required. */

commit 4b0ff3dc5e3d86ada66afcaab46a766d326facd4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:53 2014 +0100

    staging: comedi: amplc_pci230: replace `state` member with bitfields
    
    The `state` member of `struct pci230_private` is used with the atomic
    bit-op functions and has a couple of bits defined, `AI_CMD_STARTED` and
    `AO_CMD_STARTED`.  Spin-locks are used to protect the clearing of these
    bits and other stuff.  No special protection is used for setting these
    bits.  Replace the `state` member with a couple of new, single-bit
    bitfield members, `ai_cmd_started` and `ao_cmd_started` to save some
    space.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 29e6016e7444..7a8291adecea 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -443,10 +443,6 @@ enum {
 /* Current CPU.  XXX should this be hard_smp_processor_id()? */
 #define THISCPU		smp_processor_id()
 
-/* State flags for atomic bit operations */
-#define AI_CMD_STARTED	0
-#define AO_CMD_STARTED	1
-
 /*
  * Board descriptions for the two boards supported.
  */
@@ -495,7 +491,6 @@ struct pci230_private {
 	spinlock_t ai_stop_spinlock;	/* Spin lock for stopping AI command */
 	spinlock_t ao_stop_spinlock;	/* Spin lock for stopping AO command */
 	unsigned long daqio;		/* PCI230's DAQ I/O space */
-	unsigned long state;		/* State flags */
 	unsigned int ai_scan_count;	/* Number of AI scans remaining */
 	unsigned int ai_scan_pos;	/* Current position within AI scan */
 	unsigned int ao_scan_count;	/* Number of AO scans remaining.  */
@@ -511,6 +506,8 @@ struct pci230_private {
 	bool intr_running:1;		/* Flag set in interrupt routine */
 	bool ai_bipolar:1;		/* Flag AI range is bipolar */
 	bool ao_bipolar:1;		/* Flag AO range is bipolar */
+	bool ai_cmd_started:1;		/* Flag AI command started */
+	bool ao_cmd_started:1;		/* Flag AO command started */
 };
 
 /* PCI230 clock source periods in ns */
@@ -1060,11 +1057,12 @@ static void pci230_ao_stop(struct comedi_device *dev,
 	struct pci230_private *devpriv = dev->private;
 	unsigned long irqflags;
 	unsigned char intsrc;
-	int started;
+	bool started;
 	struct comedi_cmd *cmd;
 
 	spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
-	started = test_and_clear_bit(AO_CMD_STARTED, &devpriv->state);
+	started = devpriv->ao_cmd_started;
+	devpriv->ao_cmd_started = false;
 	spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
 	if (!started)
 		return;
@@ -1263,7 +1261,7 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 		return -EINVAL;
 
 	spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
-	if (test_bit(AO_CMD_STARTED, &devpriv->state)) {
+	if (devpriv->ao_cmd_started) {
 		/* Perform scan. */
 		if (devpriv->hwver < 2) {
 			/* Not using DAC FIFO. */
@@ -1296,7 +1294,7 @@ static void pci230_ao_start(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long irqflags;
 
-	set_bit(AO_CMD_STARTED, &devpriv->state);
+	devpriv->ao_cmd_started = true;
 	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_scan_count == 0) {
 		/* An empty acquisition! */
 		async->events |= COMEDI_CB_EOA;
@@ -1852,7 +1850,7 @@ static int pci230_ai_inttrig_convert(struct comedi_device *dev,
 		return -EINVAL;
 
 	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
-	if (test_bit(AI_CMD_STARTED, &devpriv->state)) {
+	if (devpriv->ai_cmd_started) {
 		unsigned int delayus;
 
 		/*
@@ -1899,7 +1897,7 @@ static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
 		return -EINVAL;
 
 	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
-	if (test_bit(AI_CMD_STARTED, &devpriv->state)) {
+	if (devpriv->ai_cmd_started) {
 		/* Trigger scan by waggling CT0 gate source. */
 		zgat = GAT_CONFIG(0, GAT_GND);
 		outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
@@ -1917,10 +1915,11 @@ static void pci230_ai_stop(struct comedi_device *dev,
 	struct pci230_private *devpriv = dev->private;
 	unsigned long irqflags;
 	struct comedi_cmd *cmd;
-	int started;
+	bool started;
 
 	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
-	started = test_and_clear_bit(AI_CMD_STARTED, &devpriv->state);
+	started = devpriv->ai_cmd_started;
+	devpriv->ai_cmd_started = false;
 	spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
 	if (!started)
 		return;
@@ -1970,7 +1969,7 @@ static void pci230_ai_start(struct comedi_device *dev,
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 
-	set_bit(AI_CMD_STARTED, &devpriv->state);
+	devpriv->ai_cmd_started = true;
 	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_scan_count == 0) {
 		/* An empty acquisition! */
 		async->events |= COMEDI_CB_EOA;

commit abea4ff48541348be06f6cd01d4db8badbbc2065
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:52 2014 +0100

    staging: comedi: amplc_pci230: make `intr_running` a bitfield
    
    Change the `intr_running` member of `struct pci230_private` into a
    single-bit bitfield of type `bool` to save a bit of space.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 895982099aaa..29e6016e7444 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -507,8 +507,8 @@ struct pci230_private {
 	unsigned short adcg;		/* ADCG register value */
 	unsigned char int_en;		/* Interrupt enable bits */
 	unsigned char ier;		/* Copy of interrupt enable register */
-	unsigned char intr_running;	/* Flag set in interrupt routine */
 	unsigned char res_owner[NUM_RESOURCES]; /* Shared resource owners */
+	bool intr_running:1;		/* Flag set in interrupt routine */
 	bool ai_bipolar:1;		/* Flag AI range is bipolar */
 	bool ao_bipolar:1;		/* Flag AO range is bipolar */
 };
@@ -2451,7 +2451,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	 */
 	devpriv->ier = devpriv->int_en & ~status_int;
 	outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
-	devpriv->intr_running = 1;
+	devpriv->intr_running = true;
 	devpriv->intr_cpuid = THISCPU;
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
@@ -2487,7 +2487,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 		devpriv->ier = devpriv->int_en;
 		outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 	}
-	devpriv->intr_running = 0;
+	devpriv->intr_running = false;
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
 	return IRQ_HANDLED;

commit 2cd5da05b0ea4bf178fab718d42de5a386600991
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:51 2014 +0100

    staging: comedi: amplc_pci230: use comedi_range_is_bipolar()
    
    Use the inline `comedi_range_is_bipolar()` function from "comedidev.h"
    to decide whether a range is bipolar or unipolar instead of using the
    local static arrays `pci230_ai_bipolar[]` and `pci230_ao_bipolar[]`
    which can then be removed.
    
    Change the types of the `ai_bipolar` and `ao_bipolar` members of `struct
    pci230_private` to `bool` to match the return value of
    `comedi_range_is_bipolar()` and change them into single-bit bitfields to
    save a bit of space.  Also change the type and name of some local
    variables in `pci230_ai_check_chanlist()` that hold the result of
    `comedi_range_is_bipolar()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 6cd235df5c96..895982099aaa 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -506,11 +506,11 @@ struct pci230_private {
 	unsigned short adcfifothresh;	/* ADC FIFO threshold (PCI230+/260+) */
 	unsigned short adcg;		/* ADCG register value */
 	unsigned char int_en;		/* Interrupt enable bits */
-	unsigned char ai_bipolar;	/* Flag AI range is bipolar */
-	unsigned char ao_bipolar;	/* Flag AO range is bipolar */
 	unsigned char ier;		/* Copy of interrupt enable register */
 	unsigned char intr_running;	/* Flag set in interrupt routine */
 	unsigned char res_owner[NUM_RESOURCES]; /* Shared resource owners */
+	bool ai_bipolar:1;		/* Flag AI range is bipolar */
+	bool ao_bipolar:1;		/* Flag AO range is bipolar */
 };
 
 /* PCI230 clock source periods in ns */
@@ -538,9 +538,6 @@ static const struct comedi_lrange pci230_ai_range = {
 /* PCI230 analogue gain bits for each input range. */
 static const unsigned char pci230_ai_gain[7] = { 0, 1, 2, 3, 1, 2, 3 };
 
-/* PCI230 adccon bipolar flag for each analogue input range. */
-static const unsigned char pci230_ai_bipolar[7] = { 1, 1, 1, 1, 0, 0, 0 };
-
 /* PCI230 analogue output range table */
 static const struct comedi_lrange pci230_ao_range = {
 	2, {
@@ -549,9 +546,6 @@ static const struct comedi_lrange pci230_ao_range = {
 	}
 };
 
-/* PCI230 daccon bipolar flag for each analogue output range. */
-static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
-
 static unsigned short pci230_ai_read(struct comedi_device *dev)
 {
 	const struct pci230_board *thisboard = comedi_board(dev);
@@ -809,7 +803,7 @@ static int pci230_ai_insn_read(struct comedi_device *dev,
 	adccon = PCI230_ADC_TRIG_Z2CT2 | PCI230_ADC_FIFO_EN;
 	/* Set Z2-CT2 output low to avoid any false triggers. */
 	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE0);
-	devpriv->ai_bipolar = pci230_ai_bipolar[range];
+	devpriv->ai_bipolar = comedi_range_is_bipolar(s, range);
 	if (aref == AREF_DIFF) {
 		/* Differential. */
 		gainshift = chan * 2;
@@ -892,7 +886,7 @@ static int pci230_ao_insn_write(struct comedi_device *dev,
 	 * Set range - see analogue output range table; 0 => unipolar 10V,
 	 * 1 => bipolar +/-10V range scale
 	 */
-	devpriv->ao_bipolar = pci230_ao_bipolar[range];
+	devpriv->ao_bipolar = comedi_range_is_bipolar(s, range);
 	outw(range, devpriv->daqio + PCI230_DACCON);
 
 	for (i = 0; i < insn->n; i++) {
@@ -1424,7 +1418,7 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * 1 => bipolar +/-10V range scale
 	 */
 	range = CR_RANGE(cmd->chanlist[0]);
-	devpriv->ao_bipolar = pci230_ao_bipolar[range];
+	devpriv->ao_bipolar = comedi_range_is_bipolar(s, range);
 	daccon = devpriv->ao_bipolar ? PCI230_DAC_OR_BIP : PCI230_DAC_OR_UNI;
 	/* Use DAC FIFO for hardware version 2 onwards. */
 	if (devpriv->hwver >= 2) {
@@ -1514,7 +1508,7 @@ static int pci230_ai_check_chanlist(struct comedi_device *dev,
 	unsigned int prev_chan = 0;
 	unsigned int prev_range = 0;
 	unsigned int prev_aref = 0;
-	unsigned int prev_polarity = 0;
+	bool prev_bipolar = false;
 	unsigned int subseq_len = 0;
 	int i;
 
@@ -1523,7 +1517,7 @@ static int pci230_ai_check_chanlist(struct comedi_device *dev,
 		unsigned int chan = CR_CHAN(chanspec);
 		unsigned int range = CR_RANGE(chanspec);
 		unsigned int aref = CR_AREF(chanspec);
-		unsigned int polarity = pci230_ai_bipolar[range];
+		bool bipolar = comedi_range_is_bipolar(s, range);
 
 		if (aref == AREF_DIFF && chan >= max_diff_chan) {
 			dev_dbg(dev->class_dev,
@@ -1555,7 +1549,7 @@ static int pci230_ai_check_chanlist(struct comedi_device *dev,
 				return -EINVAL;
 			}
 
-			if (polarity != prev_polarity) {
+			if (bipolar != prev_bipolar) {
 				dev_dbg(dev->class_dev,
 					"%s: channel sequence ranges must be all bipolar or all unipolar\n",
 					__func__);
@@ -1573,7 +1567,7 @@ static int pci230_ai_check_chanlist(struct comedi_device *dev,
 		prev_chan = chan;
 		prev_range = range;
 		prev_aref = aref;
-		prev_polarity = polarity;
+		prev_bipolar = bipolar;
 	}
 
 	if (subseq_len == 0)
@@ -2296,7 +2290,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	range = CR_RANGE(cmd->chanlist[0]);
-	devpriv->ai_bipolar = pci230_ai_bipolar[range];
+	devpriv->ai_bipolar = comedi_range_is_bipolar(s, range);
 	if (devpriv->ai_bipolar)
 		adccon |= PCI230_ADC_IR_BIP;
 	else

commit 14c289d896d31903b04656701464de46ffb197c5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:50 2014 +0100

    staging: comedi: amplc_pci230: add `pci230_` prefix to functions
    
    Most functions in "amplc_pci230" are named with the prefix `pci230_`,
    apart from one or two that have the prefix `amplc_pci230_` and a few
    odd-balls with no particular prefix.  Rename the ones without a prefix
    for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 72da4b6c6154..6cd235df5c96 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -613,8 +613,8 @@ static void pci230_ao_write_fifo(struct comedi_device *dev,
 	     devpriv->daqio + PCI230P2_DACDATA);
 }
 
-static int get_resources(struct comedi_device *dev, unsigned int res_mask,
-			 unsigned char owner)
+static int pci230_get_resources(struct comedi_device *dev,
+				unsigned int res_mask, unsigned char owner)
 {
 	struct pci230_private *devpriv = dev->private;
 	int ok;
@@ -649,14 +649,14 @@ static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 	return ok;
 }
 
-static int get_one_resource(struct comedi_device *dev,
-			    unsigned int resource, unsigned char owner)
+static int pci230_get_one_resource(struct comedi_device *dev,
+				   unsigned int resource, unsigned char owner)
 {
-	return get_resources(dev, 1U << resource, owner);
+	return pci230_get_resources(dev, 1U << resource, owner);
 }
 
-static void put_resources(struct comedi_device *dev, unsigned int res_mask,
-			  unsigned char owner)
+static void pci230_put_resources(struct comedi_device *dev,
+				 unsigned int res_mask, unsigned char owner)
 {
 	struct pci230_private *devpriv = dev->private;
 	unsigned int i;
@@ -674,19 +674,20 @@ static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
 }
 
-static void put_one_resource(struct comedi_device *dev,
-			     unsigned int resource, unsigned char owner)
+static void pci230_put_one_resource(struct comedi_device *dev,
+				    unsigned int resource, unsigned char owner)
 {
-	put_resources(dev, 1U << resource, owner);
+	pci230_put_resources(dev, 1U << resource, owner);
 }
 
-static void put_all_resources(struct comedi_device *dev, unsigned char owner)
+static void pci230_put_all_resources(struct comedi_device *dev,
+				     unsigned char owner)
 {
-	put_resources(dev, (1U << NUM_RESOURCES) - 1, owner);
+	pci230_put_resources(dev, (1U << NUM_RESOURCES) - 1, owner);
 }
 
-static unsigned int divide_ns(uint64_t ns, unsigned int timebase,
-			      unsigned int flags)
+static unsigned int pci230_divide_ns(uint64_t ns, unsigned int timebase,
+				     unsigned int flags)
 {
 	uint64_t div;
 	unsigned int rem;
@@ -717,7 +718,7 @@ static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
 	unsigned int clk_src, cnt;
 
 	for (clk_src = CLK_10MHZ;; clk_src++) {
-		cnt = divide_ns(ns, pci230_timebase[clk_src], flags);
+		cnt = pci230_divide_ns(ns, pci230_timebase[clk_src], flags);
 		if (cnt <= 65536 || clk_src == CLK_1KHZ)
 			break;
 	}
@@ -1112,7 +1113,7 @@ static void pci230_ao_stop(struct comedi_device *dev,
 		     devpriv->daqio + PCI230_DACCON);
 	}
 	/* Release resources. */
-	put_all_resources(dev, OWNER_AOCMD);
+	pci230_put_all_resources(dev, OWNER_AOCMD);
 }
 
 static void pci230_handle_ao_nofifo(struct comedi_device *dev,
@@ -1408,7 +1409,7 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		/* Claim Z2-CT1. */
-		if (!get_one_resource(dev, RES_Z2CT1, OWNER_AOCMD))
+		if (!pci230_get_one_resource(dev, RES_Z2CT1, OWNER_AOCMD))
 			return -EBUSY;
 	}
 
@@ -1963,7 +1964,7 @@ static void pci230_ai_stop(struct comedi_device *dev,
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
 	     devpriv->daqio + PCI230_ADCCON);
 	/* Release resources. */
-	put_all_resources(dev, OWNER_AICMD);
+	pci230_put_all_resources(dev, OWNER_AICMD);
 }
 
 static void pci230_ai_start(struct comedi_device *dev,
@@ -2112,7 +2113,7 @@ static void pci230_ai_start(struct comedi_device *dev,
 			}
 		} else if (cmd->convert_src != TRIG_INT) {
 			/* No longer need Z2-CT2. */
-			put_one_resource(dev, RES_Z2CT2, OWNER_AICMD);
+			pci230_put_one_resource(dev, RES_Z2CT2, OWNER_AICMD);
 		}
 	}
 }
@@ -2253,7 +2254,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		}
 	}
 	/* Claim resources. */
-	if (!get_resources(dev, res_mask, OWNER_AICMD))
+	if (!pci230_get_resources(dev, res_mask, OWNER_AICMD))
 		return -EBUSY;
 
 	/* Get number of scans required. */

commit d4c5cc31183db5d545f5ec3aa71b8c7545f2ac31
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:49 2014 +0100

    staging: comedi: amplc_pci230: rename pci230_ai_rinsn()
    
    Rename the AI subdevice "insn_read" handler function `pci230_ai_rinsn()`
    to `pci230_ai_insn_read()` for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index d8322682854b..72da4b6c6154 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -774,9 +774,9 @@ static int pci230_ai_eoc(struct comedi_device *dev,
 	return -EBUSY;
 }
 
-static int pci230_ai_rinsn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data)
+static int pci230_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	struct pci230_private *devpriv = dev->private;
 	unsigned int n;
@@ -2649,7 +2649,7 @@ static int pci230_auto_attach(struct comedi_device *dev,
 	s->n_chan = 16;
 	s->maxdata = (1 << thisboard->ai_bits) - 1;
 	s->range_table = &pci230_ai_range;
-	s->insn_read = pci230_ai_rinsn;
+	s->insn_read = pci230_ai_insn_read;
 	s->len_chanlist = 256;	/* but there are restrictions. */
 	if (dev->irq) {
 		dev->read_subdev = s;

commit d9a687958e39bdf041c7164c0e8a259e9a5e889d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:48 2014 +0100

    staging: comedi: amplc_pci230: remove 'inline'
    
    Some functions in "amplc_pci230.c" are declared `inline`.  Remove the
    `inline` specifiers and let the compiler do what it wants with them.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 70b210bc4c02..d8322682854b 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -573,8 +573,8 @@ static unsigned short pci230_ai_read(struct comedi_device *dev)
 	return data;
 }
 
-static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
-						    unsigned short datum)
+static unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
+					     unsigned short datum)
 {
 	const struct pci230_board *thisboard = comedi_board(dev);
 	struct pci230_private *devpriv = dev->private;
@@ -593,9 +593,8 @@ static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
 	return datum;
 }
 
-static inline void pci230_ao_write_nofifo(struct comedi_device *dev,
-					  unsigned short datum,
-					  unsigned int chan)
+static void pci230_ao_write_nofifo(struct comedi_device *dev,
+				   unsigned short datum, unsigned int chan)
 {
 	struct pci230_private *devpriv = dev->private;
 
@@ -604,8 +603,8 @@ static inline void pci230_ao_write_nofifo(struct comedi_device *dev,
 	     devpriv->daqio + ((chan == 0) ? PCI230_DACOUT1 : PCI230_DACOUT2));
 }
 
-static inline void pci230_ao_write_fifo(struct comedi_device *dev,
-					unsigned short datum, unsigned int chan)
+static void pci230_ao_write_fifo(struct comedi_device *dev,
+				 unsigned short datum, unsigned int chan)
 {
 	struct pci230_private *devpriv = dev->private;
 
@@ -650,8 +649,8 @@ static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 	return ok;
 }
 
-static inline int get_one_resource(struct comedi_device *dev,
-				   unsigned int resource, unsigned char owner)
+static int get_one_resource(struct comedi_device *dev,
+			    unsigned int resource, unsigned char owner)
 {
 	return get_resources(dev, 1U << resource, owner);
 }
@@ -675,14 +674,13 @@ static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
 }
 
-static inline void put_one_resource(struct comedi_device *dev,
-				    unsigned int resource, unsigned char owner)
+static void put_one_resource(struct comedi_device *dev,
+			     unsigned int resource, unsigned char owner)
 {
 	put_resources(dev, 1U << resource, owner);
 }
 
-static inline void put_all_resources(struct comedi_device *dev,
-				     unsigned char owner)
+static void put_all_resources(struct comedi_device *dev, unsigned char owner)
 {
 	put_resources(dev, (1U << NUM_RESOURCES) - 1, owner);
 }

commit 66a462ba451346599d0b78098e41eceac3099946
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:47 2014 +0100

    staging: comedi: amplc_pci230: simplify pci230_ai_read()
    
    `pci230_ai_read()` reads a sample from the ADC data register and
    converts it to a comedi sample value.  The AI sample may have 12 or 16
    bits of resolution, depending on the board type, but 12-bit sample
    values are in bits 15 to 4 of the register.  The hardware value is
    signed, 2's complement if set to a bipolar mode, or unsigned, straight
    binary if set to a unipolar mode.  To convert to a Comedi sample value
    it may need shifting right by 4 bits, and the top bit of the sample
    value may need to be toggled.
    
    Simplify the existing code by doing the 2's complement to straight
    binary conversion before the shift.  That way, it is always bit 15 that
    is inverted regardless of the resolution.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index e4151d778834..70b210bc4c02 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -563,16 +563,13 @@ static unsigned short pci230_ai_read(struct comedi_device *dev)
 	/*
 	 * PCI230 is 12 bit - stored in upper bits of 16 bit register
 	 * (lower four bits reserved for expansion).  PCI230+ is 16 bit AI.
-	 */
-	data = data >> (16 - thisboard->ai_bits);
-
-	/*
+	 *
 	 * If a bipolar range was specified, mangle it
 	 * (twos complement->straight binary).
 	 */
 	if (devpriv->ai_bipolar)
-		data ^= 1 << (thisboard->ai_bits - 1);
-
+		data ^= 0x8000;
+	data >>= (16 - thisboard->ai_bits);
 	return data;
 }
 

commit 9405d8724045a84c960a1e4ac9876cf5fb1de35e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:46 2014 +0100

    staging: comedi: amplc_pci230: simplify pci230_ao_mangle_datum()
    
    `pci230_ao_mangle_datum()` converts comedi sample values for the AO
    subdevice to hardware register values.  The comedi sample value will be
    an unsigned value in the range 0 to 4095 (assuming 12-bit resolution).
    The hardware wants the value shifted so the m.s. bit of the sample in in
    bit 15.  If set to a bipolar range, it also expects a 2's complement
    value, so the top bit of the sample value needs to be inverted in that
    case.
    
    Simplify the existing code by doing the 2's complement conversion after
    the shift.  That way, it is always bit 15 that is inverted regardless of
    the resolution.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 7fa9c70c98a4..e4151d778834 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -582,18 +582,17 @@ static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
 	const struct pci230_board *thisboard = comedi_board(dev);
 	struct pci230_private *devpriv = dev->private;
 
-	/*
-	 * If a bipolar range was specified, mangle it
-	 * (straight binary->twos complement).
-	 */
-	if (devpriv->ao_bipolar)
-		datum ^= 1 << (thisboard->ao_bits - 1);
-
 	/*
 	 * PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
 	 * four bits reserved for expansion).  PCI230+ is also 12 bit AO.
 	 */
 	datum <<= (16 - thisboard->ao_bits);
+	/*
+	 * If a bipolar range was specified, mangle it
+	 * (straight binary->twos complement).
+	 */
+	if (devpriv->ao_bipolar)
+		datum ^= 0x8000;
 	return datum;
 }
 

commit 33af02c7b259a60dca2cd1ca11a4568dcc000113
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:45 2014 +0100

    staging: comedi: amplc_pci230: shrink struct pci230_board
    
    The `ai_bits`, `ao_bits`, and `min_hwver` members of `struct
    pci230_board` are only set to small, non-negative values, so make them
    `unsigned char`.  The `have_dio` member is used as a boolean so change
    it to a bitfield of type `bool`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 75b0e7911793..7fa9c70c98a4 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -454,10 +454,10 @@ enum {
 struct pci230_board {
 	const char *name;
 	unsigned short id;
-	int ai_bits;
-	int ao_bits;
-	int have_dio;
-	unsigned int min_hwver;	/* Minimum hardware version supported. */
+	unsigned char ai_bits;
+	unsigned char ao_bits;
+	unsigned char min_hwver; /* Minimum hardware version supported. */
+	bool have_dio:1;
 };
 
 static const struct pci230_board pci230_boards[] = {
@@ -466,7 +466,7 @@ static const struct pci230_board pci230_boards[] = {
 		.id		= PCI_DEVICE_ID_PCI230,
 		.ai_bits	= 16,
 		.ao_bits	= 12,
-		.have_dio	= 1,
+		.have_dio	= true,
 		.min_hwver	= 1,
 	},
 	{
@@ -480,7 +480,7 @@ static const struct pci230_board pci230_boards[] = {
 		.id		= PCI_DEVICE_ID_PCI230,
 		.ai_bits	= 12,
 		.ao_bits	= 12,
-		.have_dio	= 1,
+		.have_dio	= true,
 	},
 	{
 		.name		= "pci260",

commit 867ae76dda9365c125ac88f256ca20d557e9e6e8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:44 2014 +0100

    staging: comedi: amplc_pci230: remove ao_chans member
    
    The PCI230(+) has an AO subdevice with 2 channels, but the PCI260(+) has
    none.
    
    The `ao_chans` member of `struct pci230_board` indicates whether the
    board has an AO subdevice and the number of AO channels.  The
    `ao_bits` member indicates the AO sample width in bits and will only be
    non-zero for boards with an AO subdevice.
    
    Use `ao_bits` to indicate whether the board has an AO subdevice.  If it
    has, assume the the number of AO channels is 2.  Then the `ao_chans`
    member becomes redundant and can be removed.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 42a79d26dd97..75b0e7911793 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -455,7 +455,6 @@ struct pci230_board {
 	const char *name;
 	unsigned short id;
 	int ai_bits;
-	int ao_chans;
 	int ao_bits;
 	int have_dio;
 	unsigned int min_hwver;	/* Minimum hardware version supported. */
@@ -466,7 +465,6 @@ static const struct pci230_board pci230_boards[] = {
 		.name		= "pci230+",
 		.id		= PCI_DEVICE_ID_PCI230,
 		.ai_bits	= 16,
-		.ao_chans	= 2,
 		.ao_bits	= 12,
 		.have_dio	= 1,
 		.min_hwver	= 1,
@@ -481,7 +479,6 @@ static const struct pci230_board pci230_boards[] = {
 		.name		= "pci230",
 		.id		= PCI_DEVICE_ID_PCI230,
 		.ai_bits	= 12,
-		.ao_chans	= 2,
 		.ao_bits	= 12,
 		.have_dio	= 1,
 	},
@@ -2609,7 +2606,7 @@ static int pci230_auto_attach(struct comedi_device *dev,
 				 */
 				extfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;
 			}
-			if (thisboard->ao_chans > 0 && devpriv->hwver >= 2) {
+			if (thisboard->ao_bits && devpriv->hwver >= 2) {
 				/* Enable DAC FIFO functionality. */
 				extfunc |= PCI230P2_EXTFUNC_DACFIFO;
 			}
@@ -2670,15 +2667,15 @@ static int pci230_auto_attach(struct comedi_device *dev,
 
 	s = &dev->subdevices[1];
 	/* analog output subdevice */
-	if (thisboard->ao_chans > 0) {
+	if (thisboard->ao_bits) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
-		s->n_chan = thisboard->ao_chans;
+		s->n_chan = 2;
 		s->maxdata = (1 << thisboard->ao_bits) - 1;
 		s->range_table = &pci230_ao_range;
 		s->insn_write = pci230_ao_insn_write;
 		s->insn_read = comedi_readback_insn_read;
-		s->len_chanlist = thisboard->ao_chans;
+		s->len_chanlist = 2;
 		if (dev->irq) {
 			dev->write_subdev = s;
 			s->subdev_flags |= SDF_CMD_WRITE;

commit e69ad291fbb08f79bf8014efeb29e2a74944bfa8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:43 2014 +0100

    staging: comedi: amplc_pci230: remove ai_chans member
    
    All boards supported by the "amplc_pci230" driver have 16 AI channels,
    so the `ai_chans` member of `struct pci230_board` is superfluous and can
    be removed.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 794e0ca4197e..42a79d26dd97 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -454,7 +454,6 @@ enum {
 struct pci230_board {
 	const char *name;
 	unsigned short id;
-	int ai_chans;
 	int ai_bits;
 	int ao_chans;
 	int ao_bits;
@@ -466,7 +465,6 @@ static const struct pci230_board pci230_boards[] = {
 	{
 		.name		= "pci230+",
 		.id		= PCI_DEVICE_ID_PCI230,
-		.ai_chans	= 16,
 		.ai_bits	= 16,
 		.ao_chans	= 2,
 		.ao_bits	= 12,
@@ -476,14 +474,12 @@ static const struct pci230_board pci230_boards[] = {
 	{
 		.name		= "pci260+",
 		.id		= PCI_DEVICE_ID_PCI260,
-		.ai_chans	= 16,
 		.ai_bits	= 16,
 		.min_hwver	= 1,
 	},
 	{
 		.name		= "pci230",
 		.id		= PCI_DEVICE_ID_PCI230,
-		.ai_chans	= 16,
 		.ai_bits	= 12,
 		.ao_chans	= 2,
 		.ao_bits	= 12,
@@ -492,7 +488,6 @@ static const struct pci230_board pci230_boards[] = {
 	{
 		.name		= "pci260",
 		.id		= PCI_DEVICE_ID_PCI260,
-		.ai_chans	= 16,
 		.ai_bits	= 12,
 	},
 };
@@ -2660,7 +2655,7 @@ static int pci230_auto_attach(struct comedi_device *dev,
 	/* analog input subdevice */
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;
-	s->n_chan = thisboard->ai_chans;
+	s->n_chan = 16;
 	s->maxdata = (1 << thisboard->ai_bits) - 1;
 	s->range_table = &pci230_ai_range;
 	s->insn_read = pci230_ai_rinsn;

commit 0a89e7147229d183f9e5566fc774d8e0dfeff627
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:42 2014 +0100

    staging: comedi: amplc_pci230: absorb pci230_alloc_private()
    
    `pci230_alloc_private()` is now only called from `pci230_auto_attach()`
    to allocate private device storage and initialize various spin-lock
    members therein.  Absorb the body of `pci230_alloc_private()` into
    `pci230_auto_attach()` itself.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index bd2e6483ac55..794e0ca4197e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2542,21 +2542,6 @@ static const struct pci230_board *pci230_find_pci_board(struct pci_dev *pci_dev)
 	return NULL;
 }
 
-static int pci230_alloc_private(struct comedi_device *dev)
-{
-	struct pci230_private *devpriv;
-
-	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
-	if (!devpriv)
-		return -ENOMEM;
-
-	spin_lock_init(&devpriv->isr_spinlock);
-	spin_lock_init(&devpriv->res_spinlock);
-	spin_lock_init(&devpriv->ai_stop_spinlock);
-	spin_lock_init(&devpriv->ao_stop_spinlock);
-	return 0;
-}
-
 static int pci230_auto_attach(struct comedi_device *dev,
 			      unsigned long context_unused)
 {
@@ -2569,9 +2554,14 @@ static int pci230_auto_attach(struct comedi_device *dev,
 	dev_info(dev->class_dev, "amplc_pci230: attach pci %s\n",
 		 pci_name(pci_dev));
 
-	rc = pci230_alloc_private(dev);
-	if (rc)
-		return rc;
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
+	if (!devpriv)
+		return -ENOMEM;
+
+	spin_lock_init(&devpriv->isr_spinlock);
+	spin_lock_init(&devpriv->res_spinlock);
+	spin_lock_init(&devpriv->ai_stop_spinlock);
+	spin_lock_init(&devpriv->ao_stop_spinlock);
 
 	dev->board_ptr = pci230_find_pci_board(pci_dev);
 	if (dev->board_ptr == NULL) {
@@ -2580,8 +2570,6 @@ static int pci230_auto_attach(struct comedi_device *dev,
 		return -EINVAL;
 	}
 	thisboard = comedi_board(dev);
-	devpriv = dev->private;
-
 	dev->board_name = thisboard->name;
 
 	rc = comedi_pci_enable(dev);

commit 77ffced7af82c13243a642e731b52fc1714fd48a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:41 2014 +0100

    staging: comedi: amplc_pci230: no need to comedi_set_hw_dev() here
    
    The comedi core module calls `comedi_set_hw_dev()` to associate the
    hardware `struct device` with the `struct comedi_device` before it calls
    the comedi driver's "auto_attach" hook `pci230_auto_attach()`.  There is
    no need for `pci230_auto_attach()` to call `comedi_set_hw_dev()` itself,
    so remove the call.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 46977e53a16d..bd2e6483ac55 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2582,8 +2582,6 @@ static int pci230_auto_attach(struct comedi_device *dev,
 	thisboard = comedi_board(dev);
 	devpriv = dev->private;
 
-	comedi_set_hw_dev(dev, &pci_dev->dev);
-
 	dev->board_name = thisboard->name;
 
 	rc = comedi_pci_enable(dev);

commit c800752bc85c8efb00d77c60aa89f585cc5f7bee
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:40 2014 +0100

    staging: comedi: amplc_pci230: absorb pci230_attach_common()
    
    `pci230_attach_common()` is now only called from `pci230_auto_attach()`,
    so absorb it into that function.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 35d7f0c9836f..46977e53a16d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2557,15 +2557,31 @@ static int pci230_alloc_private(struct comedi_device *dev)
 	return 0;
 }
 
-/* Common part of attach and auto_attach. */
-static int pci230_attach_common(struct comedi_device *dev,
-				struct pci_dev *pci_dev)
+static int pci230_auto_attach(struct comedi_device *dev,
+			      unsigned long context_unused)
 {
-	const struct pci230_board *thisboard = comedi_board(dev);
-	struct pci230_private *devpriv = dev->private;
+	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
+	const struct pci230_board *thisboard;
+	struct pci230_private *devpriv;
 	struct comedi_subdevice *s;
 	int rc;
 
+	dev_info(dev->class_dev, "amplc_pci230: attach pci %s\n",
+		 pci_name(pci_dev));
+
+	rc = pci230_alloc_private(dev);
+	if (rc)
+		return rc;
+
+	dev->board_ptr = pci230_find_pci_board(pci_dev);
+	if (dev->board_ptr == NULL) {
+		dev_err(dev->class_dev,
+			"amplc_pci230: BUG! cannot determine board type!\n");
+		return -EINVAL;
+	}
+	thisboard = comedi_board(dev);
+	devpriv = dev->private;
+
 	comedi_set_hw_dev(dev, &pci_dev->dev);
 
 	dev->board_name = thisboard->name;
@@ -2710,28 +2726,6 @@ static int pci230_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
-static int pci230_auto_attach(struct comedi_device *dev,
-			      unsigned long context_unused)
-{
-	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
-	int rc;
-
-	dev_info(dev->class_dev, "amplc_pci230: attach pci %s\n",
-		 pci_name(pci_dev));
-
-	rc = pci230_alloc_private(dev);
-	if (rc)
-		return rc;
-
-	dev->board_ptr = pci230_find_pci_board(pci_dev);
-	if (dev->board_ptr == NULL) {
-		dev_err(dev->class_dev,
-			"amplc_pci230: BUG! cannot determine board type!\n");
-		return -EINVAL;
-	}
-	return pci230_attach_common(dev, pci_dev);
-}
-
 static struct comedi_driver amplc_pci230_driver = {
 	.driver_name	= "amplc_pci230",
 	.module		= THIS_MODULE,

commit 5668ddf083fd7db5b904fc8332f4b28748fe5eed
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:39 2014 +0100

    staging: comedi: amplc_pci230: set detach handler to comedi_pci_detach()
    
    Since the comedi driver's "detach`" handler `pci230_detach()` now merely
    calls `comedi_pci_detach()` with the same parameter, use
    `comedi_pci_detach()` itself as the "detach" handler.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 39fa2f63f14a..35d7f0c9836f 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2732,16 +2732,11 @@ static int pci230_auto_attach(struct comedi_device *dev,
 	return pci230_attach_common(dev, pci_dev);
 }
 
-static void pci230_detach(struct comedi_device *dev)
-{
-	comedi_pci_detach(dev);
-}
-
 static struct comedi_driver amplc_pci230_driver = {
 	.driver_name	= "amplc_pci230",
 	.module		= THIS_MODULE,
 	.auto_attach	= pci230_auto_attach,
-	.detach		= pci230_detach,
+	.detach		= comedi_pci_detach,
 };
 
 static int amplc_pci230_pci_probe(struct pci_dev *dev,

commit 228df3c99b511ec563dbbd3c7385a3ed83201dd5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:38 2014 +0100

    staging: comedi: amplc_pci230: no need to manipulate PCI ref count
    
    This driver no longer supports a "legacy" attach mechanism that searches
    for a suitable PCI device and increments it's reference count, but since
    the common "detach" handler `pci230_detach()` still has a left-over
    `pci_dev_put()`, a matching `pci_dev_get()` is needed in the
    "auto_attach" handler `pci230_auto_attach()`.  There is no longer any
    reason to "get" and "put" the PCI device, so those calls can be removed.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 393712c1b13e..39fa2f63f14a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2729,23 +2729,12 @@ static int pci230_auto_attach(struct comedi_device *dev,
 			"amplc_pci230: BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
-	/*
-	 * Need to 'get' the PCI device to match the 'put' in pci230_detach().
-	 * TODO: Remove the pci_dev_get() and matching pci_dev_put() once
-	 * support for manual attachment of PCI devices via pci230_attach()
-	 * has been removed.
-	 */
-	pci_dev_get(pci_dev);
 	return pci230_attach_common(dev, pci_dev);
 }
 
 static void pci230_detach(struct comedi_device *dev)
 {
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-
 	comedi_pci_detach(dev);
-	if (pcidev)
-		pci_dev_put(pcidev);
 }
 
 static struct comedi_driver amplc_pci230_driver = {

commit ca5119c93f0dee89b5543fbdbc0c96a046ed20e6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:37 2014 +0100

    staging: comedi: amplc_pci230: remove "legacy" attach mechanism
    
    The "amplc_pci230" driver currently retains the legacy attach mechanism
    to allow devices to be attached manually via the `COMEDI_DEVCONFIG`
    ioctl.  The only real use for this is to pretend that a PCI230+ or
    PCI260+ is a PCI230 or PCI260 for backwards compatibility, as they have
    different number of bits of resolution on the AI subdevice.  Since the
    card would be automatically configured as a PCI230+ or PCI260+ at PCI
    probe time anyway, hopefully any users who want it to appear as a PCI230
    or PCI260 would have got tired of removing the automatically configured
    device and configuring it manually by now and will have updated their
    software to cope with the PCI230+ or PCI260+.
    
    Get rid of the legacy attach mechanism by removing the Comedi driver
    "attach" handler `pci230_attach()` and associated code.  Also remove the
    "wildcard" entry from the board table `pci230_boards[]` as it is no
    longer needed.  Don't bother initializing the `board_name`, `offset`,
    and `num_names` members of `struct comedi_driver amplc_pci230_driver`
    any longer as they are only needed when configuring the device manually.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 56141de44fd4..393712c1b13e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -24,24 +24,19 @@
  * Author: Allan Willcox <allanwillcox@ozemail.com.au>,
  *   Steve D Sharples <steve.sharples@nottingham.ac.uk>,
  *   Ian Abbott <abbotti@mev.co.uk>
- * Updated: Wed, 22 Oct 2008 12:34:49 +0100
- * Devices: [Amplicon] PCI230 (pci230 or amplc_pci230),
- *   PCI230+ (pci230+ or amplc_pci230),
- *   PCI260 (pci260 or amplc_pci230), PCI260+ (pci260+ or amplc_pci230)
+ * Updated: Mon, 01 Sep 2014 10:09:16 +0000
+ * Devices: [Amplicon] PCI230 (amplc_pci230), PCI230+, PCI260, PCI260+
  * Status: works
  *
  * Configuration options:
- *   [0] - PCI bus of device (optional).
- *   [1] - PCI slot of device (optional).
- *           If bus/slot is not specified, the first available PCI device
- *           will be used.
+ *   none
  *
- * Configuring a "amplc_pci230" will match any supported card and it will
- * choose the best match, picking the "+" models if possible.  Configuring
- * a "pci230" will match a PCI230 or PCI230+ card and it will be treated as
- * a PCI230.  Configuring a "pci260" will match a PCI260 or PCI260+ card
- * and it will be treated as a PCI260.  Configuring a "pci230+" will match
- * a PCI230+ card.  Configuring a "pci260+" will match a PCI260+ card.
+ * Manual configuration of PCI cards is not supported; they are configured
+ * automatically.
+ *
+ * The PCI230+ and PCI260+ have the same PCI device IDs as the PCI230 and
+ * PCI260, but can be distinguished by the the size of the PCI regions.  A
+ * card will be configured as a "+" model if detected as such.
  *
  * Subdevices:
  *
@@ -201,7 +196,6 @@
  */
 #define PCI_DEVICE_ID_PCI230 0x0000
 #define PCI_DEVICE_ID_PCI260 0x0006
-#define PCI_DEVICE_ID_INVALID 0xffff
 
 /*
  * PCI230 i/o space 1 registers.
@@ -501,11 +495,6 @@ static const struct pci230_board pci230_boards[] = {
 		.ai_chans	= 16,
 		.ai_bits	= 12,
 	},
-	{
-		/* Wildcard matches any above */
-		.name		= "amplc_pci230",
-		.id		= PCI_DEVICE_ID_INVALID,
-	},
 };
 
 struct pci230_private {
@@ -2553,46 +2542,6 @@ static const struct pci230_board *pci230_find_pci_board(struct pci_dev *pci_dev)
 	return NULL;
 }
 
-/* Look for PCI device matching requested board name, bus and slot. */
-static struct pci_dev *pci230_find_pci_dev(struct comedi_device *dev,
-					   struct comedi_devconfig *it)
-{
-	const struct pci230_board *thisboard = comedi_board(dev);
-	struct pci_dev *pci_dev = NULL;
-	int bus = it->options[0];
-	int slot = it->options[1];
-
-	for_each_pci_dev(pci_dev) {
-		/* Check vendor ID (same for all supported PCI boards). */
-		if (pci_dev->vendor != PCI_VENDOR_ID_AMPLICON)
-			continue;
-		/* If bus/slot specified, check them. */
-		if ((bus || slot) &&
-		    (bus != pci_dev->bus->number ||
-		     slot != PCI_SLOT(pci_dev->devfn)))
-			continue;
-		if (thisboard->id == PCI_DEVICE_ID_INVALID) {
-			/* Wildcard board matches any supported PCI board. */
-			const struct pci230_board *foundboard;
-
-			foundboard = pci230_find_pci_board(pci_dev);
-			if (foundboard == NULL)
-				continue;
-			/* Replace wildcard board_ptr. */
-			dev->board_ptr = foundboard;
-		} else {
-			/* Need to match a specific board. */
-			if (!pci230_match_pci_board(thisboard, pci_dev))
-				continue;
-		}
-		return pci_dev;
-	}
-	dev_err(dev->class_dev,
-		"No supported board found! (req. bus %d, slot %d)\n",
-		bus, slot);
-	return NULL;
-}
-
 static int pci230_alloc_private(struct comedi_device *dev)
 {
 	struct pci230_private *devpriv;
@@ -2761,25 +2710,6 @@ static int pci230_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
-static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
-{
-	const struct pci230_board *thisboard = comedi_board(dev);
-	struct pci_dev *pci_dev;
-	int rc;
-
-	dev_info(dev->class_dev, "amplc_pci230: attach %s %d,%d\n",
-		 thisboard->name, it->options[0], it->options[1]);
-
-	rc = pci230_alloc_private(dev);
-	if (rc)
-		return rc;
-
-	pci_dev = pci230_find_pci_dev(dev, it);
-	if (!pci_dev)
-		return -EIO;
-	return pci230_attach_common(dev, pci_dev);
-}
-
 static int pci230_auto_attach(struct comedi_device *dev,
 			      unsigned long context_unused)
 {
@@ -2821,12 +2751,8 @@ static void pci230_detach(struct comedi_device *dev)
 static struct comedi_driver amplc_pci230_driver = {
 	.driver_name	= "amplc_pci230",
 	.module		= THIS_MODULE,
-	.attach		= pci230_attach,
 	.auto_attach	= pci230_auto_attach,
 	.detach		= pci230_detach,
-	.board_name	= &pci230_boards[0].name,
-	.offset		= sizeof(pci230_boards[0]),
-	.num_names	= ARRAY_SIZE(pci230_boards),
 };
 
 static int amplc_pci230_pci_probe(struct pci_dev *dev,

commit 840d435f15f43bd3b45be586d3cc3b4803939176
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:36 2014 +0100

    staging: comedi: amplc_pci230: collapse some 'else { if' chains
    
    Where the only thing in an `else { ... }` block is another `if`
    statement, collapse it to an `else if {` block where it makes sense to
    do so.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 0ba06f71c09a..56141de44fd4 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1844,32 +1844,25 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 	unsigned short triglev;
 	unsigned short adccon;
 
-	if (cmd->flags & TRIG_WAKE_EOS) {
-		/* Wake at end of scan. */
+	if (cmd->flags & TRIG_WAKE_EOS)
 		wake = scanlen - devpriv->ai_scan_pos;
-	} else {
-		if (cmd->stop_src != TRIG_COUNT ||
-		    devpriv->ai_scan_count >= PCI230_ADC_FIFOLEVEL_HALFFULL ||
-		    scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
-			wake = PCI230_ADC_FIFOLEVEL_HALFFULL;
-		} else {
-			wake = devpriv->ai_scan_count * scanlen -
-			       devpriv->ai_scan_pos;
-		}
-	}
+	else if (cmd->stop_src != TRIG_COUNT ||
+		 devpriv->ai_scan_count >= PCI230_ADC_FIFOLEVEL_HALFFULL ||
+		 scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL)
+		wake = PCI230_ADC_FIFOLEVEL_HALFFULL;
+	else
+		wake = devpriv->ai_scan_count * scanlen - devpriv->ai_scan_pos;
 	if (wake >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
 		triglev = PCI230_ADC_INT_FIFO_HALF;
-	} else {
-		if (wake > 1 && devpriv->hwver > 0) {
-			/* PCI230+/260+ programmable FIFO interrupt level. */
-			if (devpriv->adcfifothresh != wake) {
-				devpriv->adcfifothresh = wake;
-				outw(wake, devpriv->daqio + PCI230P_ADCFFTH);
-			}
-			triglev = PCI230P_ADC_INT_FIFO_THRESH;
-		} else {
-			triglev = PCI230_ADC_INT_FIFO_NEMPTY;
+	} else if (wake > 1 && devpriv->hwver > 0) {
+		/* PCI230+/260+ programmable FIFO interrupt level. */
+		if (devpriv->adcfifothresh != wake) {
+			devpriv->adcfifothresh = wake;
+			outw(wake, devpriv->daqio + PCI230P_ADCFFTH);
 		}
+		triglev = PCI230P_ADC_INT_FIFO_THRESH;
+	} else {
+		triglev = PCI230_ADC_INT_FIFO_NEMPTY;
 	}
 	adccon = (devpriv->adccon & ~PCI230_ADC_INT_FIFO_MASK) | triglev;
 	if (adccon != devpriv->adccon) {
@@ -2211,19 +2204,15 @@ static void pci230_handle_ai(struct comedi_device *dev,
 			} else if (status_fifo & PCI230_ADC_FIFO_HALF) {
 				/* FIFO half full. */
 				fifoamount = PCI230_ADC_FIFOLEVEL_HALFFULL;
+			} else if (devpriv->hwver > 0) {
+				/* Read PCI230+/260+ ADC FIFO level. */
+				fifoamount = inw(devpriv->daqio +
+						 PCI230P_ADCFFLEV);
+				if (fifoamount == 0)
+					break;	/* Shouldn't happen. */
 			} else {
 				/* FIFO not empty. */
-				if (devpriv->hwver > 0) {
-					/* Read PCI230+/260+ ADC FIFO level. */
-					fifoamount = inw(devpriv->daqio +
-							 PCI230P_ADCFFLEV);
-					if (fifoamount == 0) {
-						/* Shouldn't happen. */
-						break;
-					}
-				} else {
-					fifoamount = 1;
-				}
+				fifoamount = 1;
 			}
 		}
 		/* Read sample and store in Comedi's circular buffer. */

commit cbbbd20d04282cfb19829aaa646cf57700635841
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:35 2014 +0100

    staging: comedi: amplc_pci230: remove some unnecessary parentheses
    
    Remove some pairs of parentheses that don't really improve readability.
    Also, reduce the amount of leading whitespace in a few places.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 09b392bbc541..0ba06f71c09a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -650,7 +650,7 @@ static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 	ok = 1;
 	claimed = 0;
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
-	for (b = 1, i = 0; (i < NUM_RESOURCES) && res_mask; b <<= 1, i++) {
+	for (b = 1, i = 0; i < NUM_RESOURCES && res_mask; b <<= 1, i++) {
 		if (res_mask & b) {
 			res_mask &= ~b;
 			if (devpriv->res_owner[i] == OWNER_NONE) {
@@ -676,7 +676,7 @@ static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 static inline int get_one_resource(struct comedi_device *dev,
 				   unsigned int resource, unsigned char owner)
 {
-	return get_resources(dev, (1U << resource), owner);
+	return get_resources(dev, 1U << resource, owner);
 }
 
 static void put_resources(struct comedi_device *dev, unsigned int res_mask,
@@ -688,7 +688,7 @@ static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 	unsigned long irqflags;
 
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
-	for (b = 1, i = 0; (i < NUM_RESOURCES) && res_mask; b <<= 1, i++) {
+	for (b = 1, i = 0; i < NUM_RESOURCES && res_mask; b <<= 1, i++) {
 		if (res_mask & b) {
 			res_mask &= ~b;
 			if (devpriv->res_owner[i] == owner)
@@ -701,7 +701,7 @@ static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 static inline void put_one_resource(struct comedi_device *dev,
 				    unsigned int resource, unsigned char owner)
 {
-	put_resources(dev, (1U << resource), owner);
+	put_resources(dev, 1U << resource, owner);
 }
 
 static inline void put_all_resources(struct comedi_device *dev,
@@ -743,7 +743,7 @@ static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
 
 	for (clk_src = CLK_10MHZ;; clk_src++) {
 		cnt = divide_ns(ns, pci230_timebase[clk_src], flags);
-		if ((cnt <= 65536) || (clk_src == CLK_1KHZ))
+		if (cnt <= 65536 || clk_src == CLK_1KHZ)
 			break;
 	}
 	*count = cnt;
@@ -973,7 +973,7 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT);
 
 	tmp = TRIG_TIMER | TRIG_INT;
-	if ((thisboard->min_hwver > 0) && (devpriv->hwver >= 2)) {
+	if (thisboard->min_hwver > 0 && devpriv->hwver >= 2) {
 		/*
 		 * For PCI230+ hardware version 2 onwards, allow external
 		 * trigger from EXTTRIG/EXTCONVCLK input (PCI230+ pin 25).
@@ -1041,11 +1041,11 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 		 * The only flags allowed are CR_EDGE and CR_INVERT.
 		 * The CR_EDGE flag is ignored.
 		 */
-		if (cmd->scan_begin_arg &
-		    (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) {
-			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-						      CR_FLAGS_MASK &
-						      ~(CR_EDGE | CR_INVERT));
+		if (cmd->scan_begin_arg & CR_FLAGS_MASK &
+		    ~(CR_EDGE | CR_INVERT)) {
+			cmd->scan_begin_arg =
+			    COMBINE(cmd->scan_begin_arg, 0,
+				    CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
 			err |= -EINVAL;
 		}
 		break;
@@ -1215,8 +1215,8 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 		 * (otherwise there will be loads of "DAC FIFO not half full"
 		 * interrupts).
 		 */
-		if ((num_scans == 0) &&
-		    ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {
+		if (num_scans == 0 &&
+		    (dacstat & PCI230P2_DAC_FIFO_HALF) == 0) {
 			dev_err(dev->class_dev, "AO buffer underrun\n");
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
@@ -1515,8 +1515,8 @@ static int pci230_ai_check_scan_period(struct comedi_cmd *cmd)
 		chanlist_len = 1;
 
 	min_scan_period = chanlist_len * cmd->convert_arg;
-	if ((min_scan_period < chanlist_len) ||
-	    (min_scan_period < cmd->convert_arg)) {
+	if (min_scan_period < chanlist_len ||
+	    min_scan_period < cmd->convert_arg) {
 		/* Arithmetic overflow. */
 		min_scan_period = UINT_MAX;
 		err++;
@@ -1645,7 +1645,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
 
 	tmp = TRIG_FOLLOW | TRIG_TIMER | TRIG_INT;
-	if ((thisboard->have_dio) || (thisboard->min_hwver > 0)) {
+	if (thisboard->have_dio || thisboard->min_hwver > 0) {
 		/*
 		 * Unfortunately, we cannot trigger a scan off an external
 		 * source on the PCI260 board, since it uses the PPIC0 (DIO)
@@ -1676,8 +1676,8 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 	 * If scan_begin_src is not TRIG_FOLLOW, then a monostable will be
 	 * set up to generate a fixed number of timed conversion pulses.
 	 */
-	if ((cmd->scan_begin_src != TRIG_FOLLOW) &&
-	    (cmd->convert_src != TRIG_TIMER))
+	if (cmd->scan_begin_src != TRIG_FOLLOW &&
+	    cmd->convert_src != TRIG_TIMER)
 		err |= -EINVAL;
 
 	if (err)
@@ -1704,7 +1704,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 			 * PCI230 or PCI260.  Max speed depends whether
 			 * single-ended or pseudo-differential.
 			 */
-			if (cmd->chanlist && (cmd->chanlist_len > 0)) {
+			if (cmd->chanlist && cmd->chanlist_len > 0) {
 				/* Peek analogue reference of first channel. */
 				if (CR_AREF(cmd->chanlist[0]) == AREF_DIFF)
 					max_speed_ai = MAX_SPEED_AI_DIFF;
@@ -1744,13 +1744,12 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 			 * The only flags allowed are CR_INVERT and CR_EDGE.
 			 * CR_EDGE is required.
 			 */
-			if ((cmd->convert_arg &
-			     (CR_FLAGS_MASK & ~CR_INVERT)) != CR_EDGE) {
+			if ((cmd->convert_arg & CR_FLAGS_MASK & ~CR_INVERT) !=
+			    CR_EDGE) {
 				/* Set CR_EDGE, preserve CR_INVERT. */
-				cmd->convert_arg = COMBINE(cmd->start_arg,
-							   (CR_EDGE | 0),
-							   CR_FLAGS_MASK &
-							   ~CR_INVERT);
+				cmd->convert_arg =
+				    COMBINE(cmd->start_arg, CR_EDGE | 0,
+					    CR_FLAGS_MASK & ~CR_INVERT);
 				err |= -EINVAL;
 			}
 		} else {
@@ -1854,14 +1853,14 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 		    scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
 			wake = PCI230_ADC_FIFOLEVEL_HALFFULL;
 		} else {
-			wake = (devpriv->ai_scan_count * scanlen) -
+			wake = devpriv->ai_scan_count * scanlen -
 			       devpriv->ai_scan_pos;
 		}
 	}
 	if (wake >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
 		triglev = PCI230_ADC_INT_FIFO_HALF;
 	} else {
-		if ((wake > 1) && (devpriv->hwver > 0)) {
+		if (wake > 1 && devpriv->hwver > 0) {
 			/* PCI230+/260+ programmable FIFO interrupt level. */
 			if (devpriv->adcfifothresh != wake) {
 				devpriv->adcfifothresh = wake;
@@ -1908,8 +1907,8 @@ static int pci230_ai_inttrig_convert(struct comedi_device *dev,
 		 * bit has a different meaning when FIFO enabled (and when
 		 * FIFO not enabled, it only works for software triggers).
 		 */
-		if (((devpriv->adccon & PCI230_ADC_IM_MASK) ==
-		     PCI230_ADC_IM_DIF) && (devpriv->hwver == 0)) {
+		if ((devpriv->adccon & PCI230_ADC_IM_MASK) ==
+		    PCI230_ADC_IM_DIF && devpriv->hwver == 0) {
 			/* PCI230/260 in differential mode */
 			delayus = 8;
 		} else {
@@ -2183,12 +2182,11 @@ static void pci230_handle_ai(struct comedi_device *dev,
 		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	} else if (devpriv->ai_scan_count == 0) {
 		todo = 0;
-	} else if ((devpriv->ai_scan_count > PCI230_ADC_FIFOLEVEL_HALFFULL) ||
-		   (scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL)) {
+	} else if (devpriv->ai_scan_count > PCI230_ADC_FIFOLEVEL_HALFFULL ||
+		   scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL) {
 		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	} else {
-		todo = (devpriv->ai_scan_count * scanlen) -
-		       devpriv->ai_scan_pos;
+		todo = devpriv->ai_scan_count * scanlen - devpriv->ai_scan_pos;
 		if (todo > PCI230_ADC_FIFOLEVEL_HALFFULL)
 			todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	}
@@ -2281,13 +2279,13 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * Need Z2-CT2 to supply a conversion trigger source at a high
 	 * logic level, even if not doing timed conversions.
 	 */
-	res_mask |= (1U << RES_Z2CT2);
+	res_mask |= 1U << RES_Z2CT2;
 	if (cmd->scan_begin_src != TRIG_FOLLOW) {
 		/* Using Z2-CT0 monostable to gate Z2-CT2 conversion timer */
-		res_mask |= (1U << RES_Z2CT0);
+		res_mask |= 1U << RES_Z2CT0;
 		if (cmd->scan_begin_src == TRIG_TIMER) {
 			/* Using Z2-CT1 for scan frequency */
-			res_mask |= (1U << RES_Z2CT1);
+			res_mask |= 1U << RES_Z2CT1;
 		}
 	}
 	/* Claim resources. */
@@ -2360,7 +2358,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				adcen |= 1 << gainshift;
 			}
 		} else {
-			gainshift = (chan & ~1);
+			gainshift = chan & ~1;
 			adcen |= 1 << chan;
 		}
 		devpriv->adcg = (devpriv->adcg & ~(3 << gainshift)) |
@@ -2676,8 +2674,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 				 */
 				extfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;
 			}
-			if ((thisboard->ao_chans > 0) &&
-			    (devpriv->hwver >= 2)) {
+			if (thisboard->ao_chans > 0 && devpriv->hwver >= 2) {
 				/* Enable DAC FIFO functionality. */
 				extfunc |= PCI230P2_EXTFUNC_DACFIFO;
 			}

commit a4869826926197d75bb568131fb8a51627669401
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:34 2014 +0100

    staging: comedi: amplc_pci230: don't use multiple blank lines
    
    Fix checkpatch issues: "CHECK: Please don't use multiple blank lines".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index d077254f4656..09b392bbc541 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -864,7 +864,6 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 	else
 		adccon |= PCI230_ADC_IR_UNI;
 
-
 	/*
 	 * Enable only this channel in the scan list - otherwise by default
 	 * we'll get one sample from each channel.
@@ -2295,7 +2294,6 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (!get_resources(dev, res_mask, OWNER_AICMD))
 		return -EBUSY;
 
-
 	/* Get number of scans required. */
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ai_scan_count = cmd->stop_arg;
@@ -2487,7 +2485,6 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	if (status_int == PCI230_INT_DISABLE)
 		return IRQ_NONE;
 
-
 	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	valid_status_int = devpriv->int_en & status_int;
 	/*

commit cc0f88e9ca5483a7078f382f5944a1095ab89582
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 12:03:33 2014 +0100

    staging: comedi: amplc_pci230: update MODULE_DESCRIPTION()
    
    Replace the generic, Comedi low-level driver module description string
    with something more specific.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index cd63706ea941..d077254f4656 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2869,5 +2869,5 @@ static struct pci_driver amplc_pci230_pci_driver = {
 module_comedi_pci_driver(amplc_pci230_driver, amplc_pci230_pci_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("Comedi driver for Amplicon PCI230(+) and PCI260(+)");
 MODULE_LICENSE("GPL");

commit 94254d1baec765b22cc5df3a9a16a8cc9a79d406
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Aug 26 10:55:51 2014 +0300

    staging: comedi: amplc_pci230: fix a precedence bug
    
    The addition operation has higher precedence than ?: so this would write
    to PCI230_DACOUT1 instead of devpriv->daqio + PCI230_DACOUT1.
    
    Fixes: 4f9c63fe5333 ('staging: comedi: amplc_pci230: refactor iobase addresses')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 0da5a4a47961..cd63706ea941 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -624,7 +624,7 @@ static inline void pci230_ao_write_nofifo(struct comedi_device *dev,
 
 	/* Write mangled datum to appropriate DACOUT register. */
 	outw(pci230_ao_mangle_datum(dev, datum),
-	     devpriv->daqio + ((chan) == 0) ? PCI230_DACOUT1 : PCI230_DACOUT2);
+	     devpriv->daqio + ((chan == 0) ? PCI230_DACOUT1 : PCI230_DACOUT2));
 }
 
 static inline void pci230_ao_write_fifo(struct comedi_device *dev,

commit aac307f9dd5ce1fe651140a036ab4b0a0571b54a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 17:55:48 2014 -0700

    staging: comedi: comedi_pci: introduce comedi_pci_detach()
    
    Introduce a generic (*detach) function for comedi PCI drivers to handle
    the boilerplate code needed to detach a PCI driver.
    
    This function works similar to comedi_legacy_detach() where it will:
    
      * free the dev->irq if it has been requested
      * iounmap the dev->mmio addres if it has been ioremap'ed
    
    The helper then calls comedi_pci_disable() to release the regions and
    disable the PCI device.
    
    Use the new helper directly for the (*detach) in the following cases:
    
      * where comedi_pci_disable() is used directly for the (*detach)
      * where the detach function is just boilerplate
    
    Use the new helper in the (*detach) of the simpler PCI drivers. Call
    the helper after disabling interrupts (reset) and before any additional
    cleanup (kfree) to avoid any race conditions with the interrupt handler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 2fc499217377..0da5a4a47961 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2830,9 +2830,7 @@ static void pci230_detach(struct comedi_device *dev)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	comedi_pci_disable(dev);
+	comedi_pci_detach(dev);
 	if (pcidev)
 		pci_dev_put(pcidev);
 }

commit 38f9980f644a8e5eb06360b7105a6077b1198b89
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:24 2014 -0700

    staging: comedi: amplc_pci230: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    For aesthetics, rename the (*insn_write) function and tidy it up.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 0fd212f5fa2a..2fc499217377 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -515,7 +515,6 @@ struct pci230_private {
 	spinlock_t ao_stop_spinlock;	/* Spin lock for stopping AO command */
 	unsigned long daqio;		/* PCI230's DAQ I/O space */
 	unsigned long state;		/* State flags */
-	unsigned int ao_readback[2];	/* Used for AO readback */
 	unsigned int ai_scan_count;	/* Number of AI scans remaining */
 	unsigned int ai_scan_pos;	/* Current position within AI scan */
 	unsigned int ao_scan_count;	/* Number of AO scans remaining.  */
@@ -623,9 +622,6 @@ static inline void pci230_ao_write_nofifo(struct comedi_device *dev,
 {
 	struct pci230_private *devpriv = dev->private;
 
-	/* Store unmangled datum to be read back later. */
-	devpriv->ao_readback[chan] = datum;
-
 	/* Write mangled datum to appropriate DACOUT register. */
 	outw(pci230_ao_mangle_datum(dev, datum),
 	     devpriv->daqio + ((chan) == 0) ? PCI230_DACOUT1 : PCI230_DACOUT2);
@@ -636,9 +632,6 @@ static inline void pci230_ao_write_fifo(struct comedi_device *dev,
 {
 	struct pci230_private *devpriv = dev->private;
 
-	/* Store unmangled datum to be read back later. */
-	devpriv->ao_readback[chan] = datum;
-
 	/* Write mangled datum to appropriate DACDATA register. */
 	outw(pci230_ao_mangle_datum(dev, datum),
 	     devpriv->daqio + PCI230P2_DACDATA);
@@ -909,20 +902,16 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 	return n;
 }
 
-/*
- *  COMEDI_SUBD_AO instructions;
- */
-static int pci230_ao_winsn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data)
+static int pci230_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	struct pci230_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	unsigned int val = s->readback[chan];
 	int i;
-	int chan, range;
-
-	/* Unpack channel and range. */
-	chan = CR_CHAN(insn->chanspec);
-	range = CR_RANGE(insn->chanspec);
 
 	/*
 	 * Set range - see analogue output range table; 0 => unipolar 10V,
@@ -931,35 +920,13 @@ static int pci230_ao_winsn(struct comedi_device *dev,
 	devpriv->ao_bipolar = pci230_ao_bipolar[range];
 	outw(range, devpriv->daqio + PCI230_DACCON);
 
-	/*
-	 * Writing a list of values to an AO channel is probably not
-	 * very useful, but that's how the interface is defined.
-	 */
 	for (i = 0; i < insn->n; i++) {
-		/* Write value to DAC and store it. */
-		pci230_ao_write_nofifo(dev, data[i], chan);
+		val = data[i];
+		pci230_ao_write_nofifo(dev, val, chan);
 	}
+	s->readback[chan] = val;
 
-	/* return the number of samples read/written */
-	return i;
-}
-
-/*
- * AO subdevices should have a read insn as well as a write insn.
- * Usually this means copying a value stored in devpriv.
- */
-static int pci230_ao_rinsn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data)
-{
-	struct pci230_private *devpriv = dev->private;
-	int i;
-	int chan = CR_CHAN(insn->chanspec);
-
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->ao_readback[chan];
-
-	return i;
+	return insn->n;
 }
 
 static int pci230_ao_check_chanlist(struct comedi_device *dev,
@@ -1186,6 +1153,8 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_scan_count == 0)
 		return;
 	for (i = 0; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+
 		/* Read sample from Comedi's circular buffer. */
 		ret = comedi_buf_get(s, &data);
 		if (ret == 0) {
@@ -1194,8 +1163,8 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 			dev_err(dev->class_dev, "AO buffer underrun\n");
 			return;
 		}
-		/* Write value to DAC. */
-		pci230_ao_write_nofifo(dev, data, CR_CHAN(cmd->chanlist[i]));
+		pci230_ao_write_nofifo(dev, data, chan);
+		s->readback[chan] = data;
 	}
 	async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -1271,11 +1240,12 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 		/* Process scans. */
 		for (n = 0; n < num_scans; n++) {
 			for (i = 0; i < cmd->chanlist_len; i++) {
+				unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 				unsigned short datum;
 
 				comedi_buf_get(s, &datum);
-				pci230_ao_write_fifo(dev, datum,
-						     CR_CHAN(cmd->chanlist[i]));
+				pci230_ao_write_fifo(dev, datum, chan);
+				s->readback[chan] = datum;
 			}
 		}
 		events |= COMEDI_CB_EOS | COMEDI_CB_BLOCK;
@@ -2777,8 +2747,8 @@ static int pci230_attach_common(struct comedi_device *dev,
 		s->n_chan = thisboard->ao_chans;
 		s->maxdata = (1 << thisboard->ao_bits) - 1;
 		s->range_table = &pci230_ao_range;
-		s->insn_write = pci230_ao_winsn;
-		s->insn_read = pci230_ao_rinsn;
+		s->insn_write = pci230_ao_insn_write;
+		s->insn_read = comedi_readback_insn_read;
 		s->len_chanlist = thisboard->ao_chans;
 		if (dev->irq) {
 			dev->write_subdev = s;
@@ -2787,6 +2757,10 @@ static int pci230_attach_common(struct comedi_device *dev,
 			s->do_cmdtest = pci230_ao_cmdtest;
 			s->cancel = pci230_ao_cancel;
 		}
+
+		rc = comedi_alloc_subdev_readback(s);
+		if (rc)
+			return rc;
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}

commit 4085e93b9fecfad454159694c19efc36e7ac1cdf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:26 2014 -0700

    staging: comedi: 8255: refactor how the (*io) function works
    
    Currently, all users of is module that use the default (*io) function
    pass an 'iobase' to subdev_8255_init() of the form:
    
      dev->iobase + OFFSET_TO_8255_BASE_REG
    
    Now that the (*io) callback includes the comedi_device 'dev' pointer
    the 'dev->iobase' does not need to be included.
    
    Modify the default (*io) function, subdev_8255_io(), to automatically
    add the dev->iobase to the address when reading/writing the port.
    
    For aesthetics, rename the subdevice private data member to 'regbase'.
    Also, rename the local variables in this module that are used to
    access this member.
    
    Add a comment in dev_8255_attach() about the 'iobase' that is passed
    to subdev_8255_init(). For manually attached 8255 devices the io
    region is requested with __comedi_request_region() which does not
    set dev->iobase. For these devices the 'regbase' is actually the
    'iobase'.
    
    Remove the, now unnecessary, dev->iobase from all the callers of
    subdev_8255_init(). There are a couple drivers that only passed the
    dev->iobase. For those drivers pass a 'regbase' of 0x00.
    
    Note that the das16m1 driver is a bit goofy. The devpriv->extra_iobase
    is requested using __comedi_request_region() which does not set the
    dev->iobase. But the starting address passed is dev->iobase + DAS16M1_82C55
    so a 'regbase' of DAS16M1_82C55 is passed to subdev_8255_init().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 7b56f68b3b4f..0fd212f5fa2a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2794,8 +2794,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 	s = &dev->subdevices[2];
 	/* digital i/o subdevice */
 	if (thisboard->have_dio) {
-		rc = subdev_8255_init(dev, s, NULL,
-				      dev->iobase + PCI230_PPI_X_BASE);
+		rc = subdev_8255_init(dev, s, NULL, PCI230_PPI_X_BASE);
 		if (rc)
 			return rc;
 	} else {

commit 4f9c63fe5333b27ab23ed399830c7977f6970744
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:18 2014 -0700

    staging: comedi: amplc_pci230: refactor iobase addresses
    
    This driver uses two iobase addresses, found in PCI bars 2 and 3.
    Currently, the address in PCI bar 2 is saved in the private data as
    'iobase1' and the address in PCI bar 3 is saved in the comedi_device
    as the 'iobase'. The 'iobase' is the base address of the daq
    registers (ai/ao) of the board. The 'iobase1' address is the base
    address of the 8255, 8254, configuration, and interrupt registers.
    
    Flip the saving of these base addresses. Save the address from PCI
    bar 2 in the comedi_device 'iobase' and the address from PCI bar 3
    in the private data as 'daqio'.
    
    This will help with some cleanup of the 8255 module.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 684275d76e8c..7b56f68b3b4f 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -513,8 +513,8 @@ struct pci230_private {
 	spinlock_t res_spinlock;	/* Shared resources spin lock */
 	spinlock_t ai_stop_spinlock;	/* Spin lock for stopping AI command */
 	spinlock_t ao_stop_spinlock;	/* Spin lock for stopping AO command */
+	unsigned long daqio;		/* PCI230's DAQ I/O space */
 	unsigned long state;		/* State flags */
-	unsigned long iobase1;		/* PCI230's I/O space 1 */
 	unsigned int ao_readback[2];	/* Used for AO readback */
 	unsigned int ai_scan_count;	/* Number of AI scans remaining */
 	unsigned int ai_scan_pos;	/* Current position within AI scan */
@@ -579,7 +579,7 @@ static unsigned short pci230_ai_read(struct comedi_device *dev)
 	unsigned short data;
 
 	/* Read sample. */
-	data = inw(dev->iobase + PCI230_ADCDATA);
+	data = inw(devpriv->daqio + PCI230_ADCDATA);
 	/*
 	 * PCI230 is 12 bit - stored in upper bits of 16 bit register
 	 * (lower four bits reserved for expansion).  PCI230+ is 16 bit AI.
@@ -628,7 +628,7 @@ static inline void pci230_ao_write_nofifo(struct comedi_device *dev,
 
 	/* Write mangled datum to appropriate DACOUT register. */
 	outw(pci230_ao_mangle_datum(dev, datum),
-	     dev->iobase + (((chan) == 0) ? PCI230_DACOUT1 : PCI230_DACOUT2));
+	     devpriv->daqio + ((chan) == 0) ? PCI230_DACOUT1 : PCI230_DACOUT2);
 }
 
 static inline void pci230_ao_write_fifo(struct comedi_device *dev,
@@ -641,7 +641,7 @@ static inline void pci230_ao_write_fifo(struct comedi_device *dev,
 
 	/* Write mangled datum to appropriate DACDATA register. */
 	outw(pci230_ao_mangle_datum(dev, datum),
-	     dev->iobase + PCI230P2_DACDATA);
+	     devpriv->daqio + PCI230P2_DACDATA);
 }
 
 static int get_resources(struct comedi_device *dev, unsigned int res_mask,
@@ -770,29 +770,25 @@ static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 				    unsigned int mode, uint64_t ns,
 				    unsigned int flags)
 {
-	struct pci230_private *devpriv = dev->private;
 	unsigned int clk_src;
 	unsigned int count;
 
 	/* Set mode. */
-	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, mode);
+	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, ct, mode);
 	/* Determine clock source and count. */
 	clk_src = pci230_choose_clk_count(ns, &count, flags);
 	/* Program clock source. */
-	outb(CLK_CONFIG(ct, clk_src), devpriv->iobase1 + PCI230_ZCLK_SCE);
+	outb(CLK_CONFIG(ct, clk_src), dev->iobase + PCI230_ZCLK_SCE);
 	/* Set initial count. */
 	if (count >= 65536)
 		count = 0;
 
-	i8254_write(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, count);
+	i8254_write(dev->iobase + PCI230_Z2_CT_BASE, 0, ct, count);
 }
 
 static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)
 {
-	struct pci230_private *devpriv = dev->private;
-
-	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct,
-		       I8254_MODE1);
+	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, ct, I8254_MODE1);
 	/* Counter ct, 8254 mode 1, initial count not written. */
 }
 
@@ -801,9 +797,10 @@ static int pci230_ai_eoc(struct comedi_device *dev,
 			 struct comedi_insn *insn,
 			 unsigned long context)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned int status;
 
-	status = inw(dev->iobase + PCI230_ADCCON);
+	status = inw(devpriv->daqio + PCI230_ADCCON);
 	if ((status & PCI230_ADC_FIFO_EMPTY) == 0)
 		return 0;
 	return -EBUSY;
@@ -842,7 +839,7 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 	 */
 	adccon = PCI230_ADC_TRIG_Z2CT2 | PCI230_ADC_FIFO_EN;
 	/* Set Z2-CT2 output low to avoid any false triggers. */
-	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE0);
+	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE0);
 	devpriv->ai_bipolar = pci230_ai_bipolar[range];
 	if (aref == AREF_DIFF) {
 		/* Differential. */
@@ -879,14 +876,14 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 	 * Enable only this channel in the scan list - otherwise by default
 	 * we'll get one sample from each channel.
 	 */
-	outw(adcen, dev->iobase + PCI230_ADCEN);
+	outw(adcen, devpriv->daqio + PCI230_ADCEN);
 
 	/* Set gain for channel. */
-	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
+	outw(devpriv->adcg, devpriv->daqio + PCI230_ADCG);
 
 	/* Specify uni/bip, se/diff, conversion source, and reset FIFO. */
 	devpriv->adccon = adccon;
-	outw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);
+	outw(adccon | PCI230_ADC_FIFO_RESET, devpriv->daqio + PCI230_ADCCON);
 
 	/* Convert n samples */
 	for (n = 0; n < insn->n; n++) {
@@ -894,10 +891,10 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 		 * Trigger conversion by toggling Z2-CT2 output
 		 * (finish with output high).
 		 */
-		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
-			       I8254_MODE0);
-		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
-			       I8254_MODE1);
+		i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0,
+			       2, I8254_MODE0);
+		i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0,
+			       2, I8254_MODE1);
 
 		/* wait for conversion to end */
 		ret = comedi_timeout(dev, s, insn, pci230_ai_eoc, 0);
@@ -932,7 +929,7 @@ static int pci230_ao_winsn(struct comedi_device *dev,
 	 * 1 => bipolar +/-10V range scale
 	 */
 	devpriv->ao_bipolar = pci230_ao_bipolar[range];
-	outw(range, dev->iobase + PCI230_DACCON);
+	outw(range, devpriv->daqio + PCI230_DACCON);
 
 	/*
 	 * Writing a list of values to an AO channel is probably not
@@ -1160,7 +1157,7 @@ static void pci230_ao_stop(struct comedi_device *dev,
 	}
 	if (devpriv->ier != devpriv->int_en) {
 		devpriv->ier = devpriv->int_en;
-		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+		outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 	}
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 	if (devpriv->hwver >= 2) {
@@ -1171,7 +1168,7 @@ static void pci230_ao_stop(struct comedi_device *dev,
 		devpriv->daccon &= PCI230_DAC_OR_MASK;
 		outw(devpriv->daccon | PCI230P2_DAC_FIFO_RESET |
 		     PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,
-		     dev->iobase + PCI230_DACCON);
+		     devpriv->daqio + PCI230_DACCON);
 	}
 	/* Release resources. */
 	put_all_resources(dev, OWNER_AOCMD);
@@ -1227,7 +1224,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 	int running;
 
 	/* Get DAC FIFO status. */
-	dacstat = inw(dev->iobase + PCI230_DACCON);
+	dacstat = inw(devpriv->daqio + PCI230_DACCON);
 	/* Determine number of scans available in buffer. */
 	num_scans = comedi_buf_read_n_available(s) / cfc_bytes_per_scan(s);
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -1295,11 +1292,11 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 				     ~PCI230P2_DAC_INT_FIFO_MASK) |
 				    PCI230P2_DAC_INT_FIFO_EMPTY;
 				outw(devpriv->daccon,
-				     dev->iobase + PCI230_DACCON);
+				     devpriv->daqio + PCI230_DACCON);
 			}
 		}
 		/* Check if FIFO underrun occurred while writing to FIFO. */
-		dacstat = inw(dev->iobase + PCI230_DACCON);
+		dacstat = inw(devpriv->daqio + PCI230_DACCON);
 		if (dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) {
 			dev_err(dev->class_dev, "AO FIFO underrun\n");
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
@@ -1338,7 +1335,7 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 		} else {
 			/* Using DAC FIFO. */
 			/* Read DACSWTRIG register to trigger conversion. */
-			inw(dev->iobase + PCI230P2_DACSWTRIG);
+			inw(devpriv->daqio + PCI230P2_DACSWTRIG);
 			spin_unlock_irqrestore(&devpriv->ao_stop_spinlock,
 					       irqflags);
 		}
@@ -1405,7 +1402,7 @@ static void pci230_ao_start(struct comedi_device *dev,
 			devpriv->daccon =
 			    (devpriv->daccon & ~PCI230P2_DAC_TRIG_MASK) |
 			    scantrig;
-			outw(devpriv->daccon, dev->iobase + PCI230_DACCON);
+			outw(devpriv->daccon, devpriv->daqio + PCI230_DACCON);
 		}
 		switch (cmd->scan_begin_src) {
 		case TRIG_TIMER:
@@ -1417,13 +1414,13 @@ static void pci230_ao_start(struct comedi_device *dev,
 				devpriv->int_en |= PCI230_INT_ZCLK_CT1;
 				devpriv->ier |= PCI230_INT_ZCLK_CT1;
 				outb(devpriv->ier,
-				     devpriv->iobase1 + PCI230_INT_SCE);
+				     dev->iobase + PCI230_INT_SCE);
 				spin_unlock_irqrestore(&devpriv->isr_spinlock,
 						       irqflags);
 			}
 			/* Set CT1 gate high to start counting. */
 			outb(GAT_CONFIG(1, GAT_VCC),
-			     devpriv->iobase1 + PCI230_ZGAT_SCE);
+			     dev->iobase + PCI230_ZGAT_SCE);
 			break;
 		case TRIG_INT:
 			async->inttrig = pci230_ao_inttrig_scan_begin;
@@ -1434,7 +1431,7 @@ static void pci230_ao_start(struct comedi_device *dev,
 			spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 			devpriv->int_en |= PCI230P2_INT_DAC;
 			devpriv->ier |= PCI230P2_INT_DAC;
-			outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+			outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 			spin_unlock_irqrestore(&devpriv->isr_spinlock,
 					       irqflags);
 		}
@@ -1494,7 +1491,7 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			dacen |= 1 << CR_CHAN(cmd->chanlist[i]);
 
 		/* Set channel scan list. */
-		outw(dacen, dev->iobase + PCI230P2_DACEN);
+		outw(dacen, devpriv->daqio + PCI230P2_DACEN);
 		/*
 		 * Enable DAC FIFO.
 		 * Set DAC scan source to 'none'.
@@ -1509,7 +1506,7 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* Set DACCON. */
-	outw(daccon, dev->iobase + PCI230_DACCON);
+	outw(daccon, devpriv->daqio + PCI230_DACCON);
 	/* Preserve most of DACCON apart from write-only, transient bits. */
 	devpriv->daccon = daccon & ~(PCI230P2_DAC_FIFO_RESET |
 				     PCI230P2_DAC_FIFO_UNDERRUN_CLEAR);
@@ -1520,8 +1517,7 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * cmd->scan_begin_arg is sampling period in ns.
 		 * Gate it off for now.
 		 */
-		outb(GAT_CONFIG(1, GAT_GND),
-		     devpriv->iobase1 + PCI230_ZGAT_SCE);
+		outb(GAT_CONFIG(1, GAT_GND), dev->iobase + PCI230_ZGAT_SCE);
 		pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
 					cmd->scan_begin_arg,
 					cmd->flags);
@@ -1900,7 +1896,7 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 			/* PCI230+/260+ programmable FIFO interrupt level. */
 			if (devpriv->adcfifothresh != wake) {
 				devpriv->adcfifothresh = wake;
-				outw(wake, dev->iobase + PCI230P_ADCFFTH);
+				outw(wake, devpriv->daqio + PCI230P_ADCFFTH);
 			}
 			triglev = PCI230P_ADC_INT_FIFO_THRESH;
 		} else {
@@ -1910,7 +1906,7 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 	adccon = (devpriv->adccon & ~PCI230_ADC_INT_FIFO_MASK) | triglev;
 	if (adccon != devpriv->adccon) {
 		devpriv->adccon = adccon;
-		outw(adccon, dev->iobase + PCI230_ADCCON);
+		outw(adccon, devpriv->daqio + PCI230_ADCCON);
 	}
 }
 
@@ -1932,10 +1928,10 @@ static int pci230_ai_inttrig_convert(struct comedi_device *dev,
 		 * Trigger conversion by toggling Z2-CT2 output.
 		 * Finish with output high.
 		 */
-		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
-			       I8254_MODE0);
-		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
-			       I8254_MODE1);
+		i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0,
+			       2, I8254_MODE0);
+		i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0,
+			       2, I8254_MODE1);
 		/*
 		 * Delay.  Should driver be responsible for this?  An
 		 * alternative would be to wait until conversion is complete,
@@ -1975,9 +1971,9 @@ static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
 	if (test_bit(AI_CMD_STARTED, &devpriv->state)) {
 		/* Trigger scan by waggling CT0 gate source. */
 		zgat = GAT_CONFIG(0, GAT_GND);
-		outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+		outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 		zgat = GAT_CONFIG(0, GAT_VCC);
-		outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+		outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 	}
 	spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
 
@@ -2018,7 +2014,7 @@ static void pci230_ai_stop(struct comedi_device *dev,
 	}
 	if (devpriv->ier != devpriv->int_en) {
 		devpriv->ier = devpriv->int_en;
-		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+		outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 	}
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 	/*
@@ -2029,7 +2025,7 @@ static void pci230_ai_stop(struct comedi_device *dev,
 	    (devpriv->adccon & (PCI230_ADC_IR_MASK | PCI230_ADC_IM_MASK)) |
 	    PCI230_ADC_TRIG_NONE;
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
-	     dev->iobase + PCI230_ADCCON);
+	     devpriv->daqio + PCI230_ADCCON);
 	/* Release resources. */
 	put_all_resources(dev, OWNER_AICMD);
 }
@@ -2054,7 +2050,7 @@ static void pci230_ai_start(struct comedi_device *dev,
 		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 		devpriv->int_en |= PCI230_INT_ADC;
 		devpriv->ier |= PCI230_INT_ADC;
-		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+		outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
 		/*
@@ -2099,7 +2095,7 @@ static void pci230_ai_start(struct comedi_device *dev,
 		}
 		devpriv->adccon =
 		    (devpriv->adccon & ~PCI230_ADC_TRIG_MASK) | conv;
-		outw(devpriv->adccon, dev->iobase + PCI230_ADCCON);
+		outw(devpriv->adccon, devpriv->daqio + PCI230_ADCCON);
 		if (cmd->convert_src == TRIG_INT)
 			async->inttrig = pci230_ai_inttrig_convert;
 
@@ -2125,7 +2121,7 @@ static void pci230_ai_start(struct comedi_device *dev,
 				 */
 				zgat = GAT_CONFIG(2, GAT_VCC);
 			}
-			outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+			outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 			if (cmd->scan_begin_src != TRIG_FOLLOW) {
 				/* Set monostable CT0 trigger source. */
 				switch (cmd->scan_begin_src) {
@@ -2161,7 +2157,7 @@ static void pci230_ai_start(struct comedi_device *dev,
 					zgat = GAT_CONFIG(0, GAT_VCC);
 					break;
 				}
-				outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+				outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 				switch (cmd->scan_begin_src) {
 				case TRIG_TIMER:
 					/*
@@ -2169,8 +2165,8 @@ static void pci230_ai_start(struct comedi_device *dev,
 					 * gated on to start counting.
 					 */
 					zgat = GAT_CONFIG(1, GAT_VCC);
-					outb(zgat, devpriv->iobase1 +
-						   PCI230_ZGAT_SCE);
+					outb(zgat,
+					     dev->iobase + PCI230_ZGAT_SCE);
 					break;
 				case TRIG_INT:
 					async->inttrig =
@@ -2233,7 +2229,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 	for (i = 0; i < todo; i++) {
 		if (fifoamount == 0) {
 			/* Read FIFO state. */
-			status_fifo = inw(dev->iobase + PCI230_ADCCON);
+			status_fifo = inw(devpriv->daqio + PCI230_ADCCON);
 			if (status_fifo & PCI230_ADC_FIFO_FULL_LATCHED) {
 				/*
 				 * Report error otherwise FIFO overruns will go
@@ -2252,8 +2248,8 @@ static void pci230_handle_ai(struct comedi_device *dev,
 				/* FIFO not empty. */
 				if (devpriv->hwver > 0) {
 					/* Read PCI230+/260+ ADC FIFO level. */
-					fifoamount =
-					    inw(dev->iobase + PCI230P_ADCFFLEV);
+					fifoamount = inw(devpriv->daqio +
+							 PCI230P_ADCFFLEV);
 					if (fifoamount == 0) {
 						/* Shouldn't happen. */
 						break;
@@ -2404,16 +2400,16 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* Set channel scan list. */
-	outw(adcen, dev->iobase + PCI230_ADCEN);
+	outw(adcen, devpriv->daqio + PCI230_ADCEN);
 
 	/* Set channel gains. */
-	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
+	outw(devpriv->adcg, devpriv->daqio + PCI230_ADCG);
 
 	/*
 	 * Set counter/timer 2 output high for use as the initial start
 	 * conversion source.
 	 */
-	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE1);
+	i8254_set_mode(dev->iobase + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE1);
 
 	/*
 	 * Temporarily use CT2 output as conversion trigger source and
@@ -2429,7 +2425,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * PCI230/260, but that will be dealt with later.
 	 */
 	devpriv->adccon = adccon;
-	outw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);
+	outw(adccon | PCI230_ADC_FIFO_RESET, devpriv->daqio + PCI230_ADCCON);
 
 	/*
 	 * Delay -
@@ -2443,7 +2439,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	usleep_range(25, 100);
 
 	/* Reset FIFO again. */
-	outw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);
+	outw(adccon | PCI230_ADC_FIFO_RESET, devpriv->daqio + PCI230_ADCCON);
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		/*
@@ -2452,7 +2448,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * connector: PCI230 pin 21, PCI260 pin 18.
 		 */
 		zgat = GAT_CONFIG(2, GAT_GND);
-		outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+		outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 		/* Set counter/timer 2 to the specified conversion period. */
 		pci230_ct_setup_ns_mode(dev, 2, I8254_MODE3, cmd->convert_arg,
 					cmd->flags);
@@ -2470,7 +2466,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			 * source will be changed later.
 			 */
 			zgat = GAT_CONFIG(0, GAT_VCC);
-			outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+			outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 			pci230_ct_setup_ns_mode(dev, 0, I8254_MODE1,
 						((uint64_t)cmd->convert_arg *
 						 cmd->scan_end_arg),
@@ -2483,7 +2479,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				 * Set up CT1 but gate it off for now.
 				 */
 				zgat = GAT_CONFIG(1, GAT_GND);
-				outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+				outb(zgat, dev->iobase + PCI230_ZGAT_SCE);
 				pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
 							cmd->scan_begin_arg,
 							cmd->flags);
@@ -2516,7 +2512,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	unsigned long irqflags;
 
 	/* Read interrupt status/enable register. */
-	status_int = inb(devpriv->iobase1 + PCI230_INT_STAT);
+	status_int = inb(dev->iobase + PCI230_INT_STAT);
 
 	if (status_int == PCI230_INT_DISABLE)
 		return IRQ_NONE;
@@ -2530,7 +2526,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	 * handler).
 	 */
 	devpriv->ier = devpriv->int_en & ~status_int;
-	outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+	outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 	devpriv->intr_running = 1;
 	devpriv->intr_cpuid = THISCPU;
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
@@ -2565,7 +2561,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	if (devpriv->ier != devpriv->int_en) {
 		devpriv->ier = devpriv->int_en;
-		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+		outb(devpriv->ier, dev->iobase + PCI230_INT_SCE);
 	}
 	devpriv->intr_running = 0;
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
@@ -2665,8 +2661,6 @@ static int pci230_attach_common(struct comedi_device *dev,
 	const struct pci230_board *thisboard = comedi_board(dev);
 	struct pci230_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
-	unsigned long iobase1, iobase2;
-	/* PCI230's I/O spaces 1 and 2 respectively. */
 	int rc;
 
 	comedi_set_hw_dev(dev, &pci_dev->dev);
@@ -2681,15 +2675,14 @@ static int pci230_attach_common(struct comedi_device *dev,
 	 * Read base addresses of the PCI230's two I/O regions from PCI
 	 * configuration register.
 	 */
-	iobase1 = pci_resource_start(pci_dev, 2);
-	iobase2 = pci_resource_start(pci_dev, 3);
+	dev->iobase = pci_resource_start(pci_dev, 2);
+	devpriv->daqio = pci_resource_start(pci_dev, 3);
 	dev_dbg(dev->class_dev,
 		"%s I/O region 1 0x%04lx I/O region 2 0x%04lx\n",
-		dev->board_name, iobase1, iobase2);
-	devpriv->iobase1 = iobase1;
-	dev->iobase = iobase2;
+		dev->board_name, dev->iobase, devpriv->daqio);
 	/* Read bits of DACCON register - only the output range. */
-	devpriv->daccon = inw(dev->iobase + PCI230_DACCON) & PCI230_DAC_OR_MASK;
+	devpriv->daccon = inw(devpriv->daqio + PCI230_DACCON) &
+			  PCI230_DAC_OR_MASK;
 	/*
 	 * Read hardware version register and set extended function register
 	 * if they exist.
@@ -2697,7 +2690,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 	if (pci_resource_len(pci_dev, 3) >= 32) {
 		unsigned short extfunc = 0;
 
-		devpriv->hwver = inw(dev->iobase + PCI230P_HWVER);
+		devpriv->hwver = inw(devpriv->daqio + PCI230P_HWVER);
 		if (devpriv->hwver < thisboard->min_hwver) {
 			dev_err(dev->class_dev,
 				"%s - bad hardware version - got %u, need %u\n",
@@ -2722,7 +2715,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 				extfunc |= PCI230P2_EXTFUNC_DACFIFO;
 			}
 		}
-		outw(extfunc, dev->iobase + PCI230P_EXTFUNC);
+		outw(extfunc, devpriv->daqio + PCI230P_EXTFUNC);
 		if (extfunc & PCI230P2_EXTFUNC_DACFIFO) {
 			/*
 			 * Temporarily enable DAC FIFO, reset it and disable
@@ -2730,23 +2723,23 @@ static int pci230_attach_common(struct comedi_device *dev,
 			 */
 			outw(devpriv->daccon | PCI230P2_DAC_FIFO_EN |
 			     PCI230P2_DAC_FIFO_RESET,
-			     dev->iobase + PCI230_DACCON);
+			     devpriv->daqio + PCI230_DACCON);
 			/* Clear DAC FIFO channel enable register. */
-			outw(0, dev->iobase + PCI230P2_DACEN);
+			outw(0, devpriv->daqio + PCI230P2_DACEN);
 			/* Disable DAC FIFO. */
-			outw(devpriv->daccon, dev->iobase + PCI230_DACCON);
+			outw(devpriv->daccon, devpriv->daqio + PCI230_DACCON);
 		}
 	}
 	/* Disable board's interrupts. */
-	outb(0, devpriv->iobase1 + PCI230_INT_SCE);
+	outb(0, dev->iobase + PCI230_INT_SCE);
 	/* Set ADC to a reasonable state. */
 	devpriv->adcg = 0;
 	devpriv->adccon = PCI230_ADC_TRIG_NONE | PCI230_ADC_IM_SE |
 			  PCI230_ADC_IR_BIP;
-	outw(1 << 0, dev->iobase + PCI230_ADCEN);
-	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
+	outw(1 << 0, devpriv->daqio + PCI230_ADCEN);
+	outw(devpriv->adcg, devpriv->daqio + PCI230_ADCG);
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
-	     dev->iobase + PCI230_ADCCON);
+	     devpriv->daqio + PCI230_ADCCON);
 
 	if (pci_dev->irq) {
 		rc = request_irq(pci_dev->irq, pci230_interrupt, IRQF_SHARED,
@@ -2802,7 +2795,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 	/* digital i/o subdevice */
 	if (thisboard->have_dio) {
 		rc = subdev_8255_init(dev, s, NULL,
-				      devpriv->iobase1 + PCI230_PPI_X_BASE);
+				      dev->iobase + PCI230_PPI_X_BASE);
 		if (rc)
 			return rc;
 	} else {

commit ab35426810e855e5cffa8d7cebbfe8d1c53594c3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:26 2014 +0100

    staging: comedi: amplc_pci230: tidy up stuct pci230_private
    
    Align the member comments a bit better in the declaration of `struct
    pci230_private`.  Also remove the heading comment as it is just a
    boilerplate comedi comment.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 2d8cdb15780a..684275d76e8c 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -508,40 +508,29 @@ static const struct pci230_board pci230_boards[] = {
 	},
 };
 
-/*
- * This structure is for data unique to this hardware driver.  If
- * several hardware drivers keep similar information in this structure,
- * feel free to suggest moving the variable to the struct comedi_device struct.
- */
 struct pci230_private {
 	spinlock_t isr_spinlock;	/* Interrupt spin lock */
 	spinlock_t res_spinlock;	/* Shared resources spin lock */
 	spinlock_t ai_stop_spinlock;	/* Spin lock for stopping AI command */
 	spinlock_t ao_stop_spinlock;	/* Spin lock for stopping AO command */
-	unsigned long state;	/* State flags */
-	unsigned long iobase1;	/* PCI230's I/O space 1 */
+	unsigned long state;		/* State flags */
+	unsigned long iobase1;		/* PCI230's I/O space 1 */
 	unsigned int ao_readback[2];	/* Used for AO readback */
-	/* Number of analogue input scans remaining.  */
-	unsigned int ai_scan_count;
-	/* Current position within analogue input scan */
-	unsigned int ai_scan_pos;
-	/* Number of analogue output scans remaining.  */
-	unsigned int ao_scan_count;
-	int intr_cpuid;		/* ID of CPU running interrupt routine. */
-	unsigned short hwver;	/* Hardware version (for '+' models). */
-	unsigned short adccon;	/* ADCCON register value. */
-	unsigned short daccon;	/* DACCON register value. */
-	/* ADC FIFO programmable interrupt level threshold (PCI230+/260+). */
-	unsigned short adcfifothresh;
-	unsigned short adcg;	/* ADCG register value. */
-	unsigned char int_en;	/* Interrupt enables bits. */
-	/* Set if bipolar input range so we know to mangle it. */
-	unsigned char ai_bipolar;
-	/* Set if bipolar output range so we know to mangle it. */
-	unsigned char ao_bipolar;
-	unsigned char ier;	/* Copy of interrupt enables/status register. */
-	unsigned char intr_running;	/* Flag set in interrupt routine. */
-	unsigned char res_owner[NUM_RESOURCES];	/* Shared resource owners. */
+	unsigned int ai_scan_count;	/* Number of AI scans remaining */
+	unsigned int ai_scan_pos;	/* Current position within AI scan */
+	unsigned int ao_scan_count;	/* Number of AO scans remaining.  */
+	int intr_cpuid;			/* ID of CPU running ISR */
+	unsigned short hwver;		/* Hardware version (for '+' models) */
+	unsigned short adccon;		/* ADCCON register value */
+	unsigned short daccon;		/* DACCON register value */
+	unsigned short adcfifothresh;	/* ADC FIFO threshold (PCI230+/260+) */
+	unsigned short adcg;		/* ADCG register value */
+	unsigned char int_en;		/* Interrupt enable bits */
+	unsigned char ai_bipolar;	/* Flag AI range is bipolar */
+	unsigned char ao_bipolar;	/* Flag AO range is bipolar */
+	unsigned char ier;		/* Copy of interrupt enable register */
+	unsigned char intr_running;	/* Flag set in interrupt routine */
+	unsigned char res_owner[NUM_RESOURCES]; /* Shared resource owners */
 };
 
 /* PCI230 clock source periods in ns */

commit 5565353c36df092402a446c77c0ffccbe6ae04f9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:25 2014 +0100

    staging: comedi: amplc_pci230: no need to initialize named members to zero
    
    The members of the elements of `pci230_boards[]` that are not explicitly
    named in their initializers will be initialized to 0 automatically, so
    there is no need to initialize them to 0 explicitly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 0bef12ff80ab..2d8cdb15780a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -484,9 +484,6 @@ static const struct pci230_board pci230_boards[] = {
 		.id		= PCI_DEVICE_ID_PCI260,
 		.ai_chans	= 16,
 		.ai_bits	= 16,
-		.ao_chans	= 0,
-		.ao_bits	= 0,
-		.have_dio	= 0,
 		.min_hwver	= 1,
 	},
 	{
@@ -503,9 +500,6 @@ static const struct pci230_board pci230_boards[] = {
 		.id		= PCI_DEVICE_ID_PCI260,
 		.ai_chans	= 16,
 		.ai_bits	= 12,
-		.ao_chans	= 0,
-		.ao_bits	= 0,
-		.have_dio	= 0,
 	},
 	{
 		/* Wildcard matches any above */

commit bb4bbac2ff5b7a8e184fb98086e2e5e9bc5394e0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:24 2014 +0100

    staging: comedi: amplc_pci230: add whitespace to pci230_boards[]
    
    Add a bit of whitespace to the initializer of `pci230_boards[]` for
    aesthetic reasons.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 47069fd17611..0bef12ff80ab 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -467,49 +467,51 @@ struct pci230_board {
 	int have_dio;
 	unsigned int min_hwver;	/* Minimum hardware version supported. */
 };
+
 static const struct pci230_board pci230_boards[] = {
 	{
-	 .name = "pci230+",
-	 .id = PCI_DEVICE_ID_PCI230,
-	 .ai_chans = 16,
-	 .ai_bits = 16,
-	 .ao_chans = 2,
-	 .ao_bits = 12,
-	 .have_dio = 1,
-	 .min_hwver = 1,
-	 },
+		.name		= "pci230+",
+		.id		= PCI_DEVICE_ID_PCI230,
+		.ai_chans	= 16,
+		.ai_bits	= 16,
+		.ao_chans	= 2,
+		.ao_bits	= 12,
+		.have_dio	= 1,
+		.min_hwver	= 1,
+	},
 	{
-	 .name = "pci260+",
-	 .id = PCI_DEVICE_ID_PCI260,
-	 .ai_chans = 16,
-	 .ai_bits = 16,
-	 .ao_chans = 0,
-	 .ao_bits = 0,
-	 .have_dio = 0,
-	 .min_hwver = 1,
-	 },
+		.name		= "pci260+",
+		.id		= PCI_DEVICE_ID_PCI260,
+		.ai_chans	= 16,
+		.ai_bits	= 16,
+		.ao_chans	= 0,
+		.ao_bits	= 0,
+		.have_dio	= 0,
+		.min_hwver	= 1,
+	},
 	{
-	 .name = "pci230",
-	 .id = PCI_DEVICE_ID_PCI230,
-	 .ai_chans = 16,
-	 .ai_bits = 12,
-	 .ao_chans = 2,
-	 .ao_bits = 12,
-	 .have_dio = 1,
-	 },
+		.name		= "pci230",
+		.id		= PCI_DEVICE_ID_PCI230,
+		.ai_chans	= 16,
+		.ai_bits	= 12,
+		.ao_chans	= 2,
+		.ao_bits	= 12,
+		.have_dio	= 1,
+	},
 	{
-	 .name = "pci260",
-	 .id = PCI_DEVICE_ID_PCI260,
-	 .ai_chans = 16,
-	 .ai_bits = 12,
-	 .ao_chans = 0,
-	 .ao_bits = 0,
-	 .have_dio = 0,
-	 },
+		.name		= "pci260",
+		.id		= PCI_DEVICE_ID_PCI260,
+		.ai_chans	= 16,
+		.ai_bits	= 12,
+		.ao_chans	= 0,
+		.ao_bits	= 0,
+		.have_dio	= 0,
+	},
 	{
-	 .name = "amplc_pci230",	/* Wildcard matches any above */
-	 .id = PCI_DEVICE_ID_INVALID,
-	 },
+		/* Wildcard matches any above */
+		.name		= "amplc_pci230",
+		.id		= PCI_DEVICE_ID_INVALID,
+	},
 };
 
 /*

commit 2503f6fe8945d163bda7dc23bb05952ac84b4257
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:23 2014 +0100

    staging: comedi: amplc_pci230: no need for '&function'
    
    Remove the "address-of" operator when the operand is a function.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 37e72f6c0254..47069fd17611 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2781,13 +2781,13 @@ static int pci230_attach_common(struct comedi_device *dev,
 	s->n_chan = thisboard->ai_chans;
 	s->maxdata = (1 << thisboard->ai_bits) - 1;
 	s->range_table = &pci230_ai_range;
-	s->insn_read = &pci230_ai_rinsn;
+	s->insn_read = pci230_ai_rinsn;
 	s->len_chanlist = 256;	/* but there are restrictions. */
 	if (dev->irq) {
 		dev->read_subdev = s;
 		s->subdev_flags |= SDF_CMD_READ;
-		s->do_cmd = &pci230_ai_cmd;
-		s->do_cmdtest = &pci230_ai_cmdtest;
+		s->do_cmd = pci230_ai_cmd;
+		s->do_cmdtest = pci230_ai_cmdtest;
 		s->cancel = pci230_ai_cancel;
 	}
 
@@ -2799,14 +2799,14 @@ static int pci230_attach_common(struct comedi_device *dev,
 		s->n_chan = thisboard->ao_chans;
 		s->maxdata = (1 << thisboard->ao_bits) - 1;
 		s->range_table = &pci230_ao_range;
-		s->insn_write = &pci230_ao_winsn;
-		s->insn_read = &pci230_ao_rinsn;
+		s->insn_write = pci230_ao_winsn;
+		s->insn_read = pci230_ao_rinsn;
 		s->len_chanlist = thisboard->ao_chans;
 		if (dev->irq) {
 			dev->write_subdev = s;
 			s->subdev_flags |= SDF_CMD_WRITE;
-			s->do_cmd = &pci230_ao_cmd;
-			s->do_cmdtest = &pci230_ao_cmdtest;
+			s->do_cmd = pci230_ao_cmd;
+			s->do_cmdtest = pci230_ao_cmdtest;
 			s->cancel = pci230_ao_cancel;
 		}
 	} else {

commit 2ba8906f6f5eb15d4628514e098af1001c244a8a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:22 2014 +0100

    staging: comedi: amplc_pci230: remove some indentation in pci230_ai_check_chanlist()
    
    A few lines in `pci230_ai_check_chanlist()` are indented one level too
    much, so remove the excess indentation.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 4222e2852722..37e72f6c0254 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1616,10 +1616,10 @@ static int pci230_ai_check_chanlist(struct comedi_device *dev,
 
 			if (subseq_len > 0 &&
 			    cmd->chanlist[i % subseq_len] != chanspec) {
-					dev_dbg(dev->class_dev,
-						"%s: channel numbers must increase or sequence must repeat exactly\n",
-						__func__);
-					return -EINVAL;
+				dev_dbg(dev->class_dev,
+					"%s: channel numbers must increase or sequence must repeat exactly\n",
+					__func__);
+				return -EINVAL;
 			}
 
 			if (aref != prev_aref) {

commit a190d26a0d1eee141de3bf690eb3e4ab05203efd
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:20 2014 +0100

    staging: comedi: amplc_pci230: omit '!= 0' from logical expressions
    
    Since anything non-zero is logically "true", don't bother doing
    "not-equal" comparisons with zero.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 311c4974439b..4222e2852722 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -672,16 +672,15 @@ static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 	ok = 1;
 	claimed = 0;
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
-	for (b = 1, i = 0; (i < NUM_RESOURCES) && (res_mask != 0);
-	     b <<= 1, i++) {
-		if ((res_mask & b) != 0) {
+	for (b = 1, i = 0; (i < NUM_RESOURCES) && res_mask; b <<= 1, i++) {
+		if (res_mask & b) {
 			res_mask &= ~b;
 			if (devpriv->res_owner[i] == OWNER_NONE) {
 				devpriv->res_owner[i] = owner;
 				claimed |= b;
 			} else if (devpriv->res_owner[i] != owner) {
-				for (b = 1, i = 0; claimed != 0; b <<= 1, i++) {
-					if ((claimed & b) != 0) {
+				for (b = 1, i = 0; claimed; b <<= 1, i++) {
+					if (claimed & b) {
 						devpriv->res_owner[i] =
 						    OWNER_NONE;
 						claimed &= ~b;
@@ -711,9 +710,8 @@ static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 	unsigned long irqflags;
 
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
-	for (b = 1, i = 0; (i < NUM_RESOURCES) && (res_mask != 0);
-	     b <<= 1, i++) {
-		if ((res_mask & b) != 0) {
+	for (b = 1, i = 0; (i < NUM_RESOURCES) && res_mask; b <<= 1, i++) {
+		if (res_mask & b) {
 			res_mask &= ~b;
 			if (devpriv->res_owner[i] == owner)
 				devpriv->res_owner[i] = OWNER_NONE;
@@ -1086,7 +1084,7 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 		 * External trigger - for PCI230+ hardware version 2 onwards.
 		 */
 		/* Trigger number must be 0. */
-		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
+		if (cmd->scan_begin_arg & ~CR_FLAGS_MASK) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      ~CR_FLAGS_MASK);
 			err |= -EINVAL;
@@ -1095,8 +1093,8 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 		 * The only flags allowed are CR_EDGE and CR_INVERT.
 		 * The CR_EDGE flag is ignored.
 		 */
-		if ((cmd->scan_begin_arg &
-		     (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {
+		if (cmd->scan_begin_arg &
+		    (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      CR_FLAGS_MASK &
 						      ~(CR_EDGE | CR_INVERT));
@@ -1258,7 +1256,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 	}
 	if (events == 0) {
 		/* Check for FIFO underrun. */
-		if ((dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) != 0) {
+		if (dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) {
 			dev_err(dev->class_dev, "AO FIFO underrun\n");
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
@@ -1275,11 +1273,11 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 	}
 	if (events == 0) {
 		/* Determine how much room is in the FIFO (in samples). */
-		if ((dacstat & PCI230P2_DAC_FIFO_FULL) != 0)
+		if (dacstat & PCI230P2_DAC_FIFO_FULL)
 			room = PCI230P2_DAC_FIFOROOM_FULL;
-		else if ((dacstat & PCI230P2_DAC_FIFO_HALF) != 0)
+		else if (dacstat & PCI230P2_DAC_FIFO_HALF)
 			room = PCI230P2_DAC_FIFOROOM_HALFTOFULL;
-		else if ((dacstat & PCI230P2_DAC_FIFO_EMPTY) != 0)
+		else if (dacstat & PCI230P2_DAC_FIFO_EMPTY)
 			room = PCI230P2_DAC_FIFOROOM_EMPTY;
 		else
 			room = PCI230P2_DAC_FIFOROOM_ONETOHALF;
@@ -1317,13 +1315,12 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 		}
 		/* Check if FIFO underrun occurred while writing to FIFO. */
 		dacstat = inw(dev->iobase + PCI230_DACCON);
-		if ((dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) != 0) {
+		if (dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) {
 			dev_err(dev->class_dev, "AO FIFO underrun\n");
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
 	}
-	if ((events &
-	     (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) != 0) {
+	if (events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {
 		/* Stopping AO due to completion or error. */
 		pci230_ao_stop(dev, s);
 		running = 0;
@@ -1341,7 +1338,7 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 	struct pci230_private *devpriv = dev->private;
 	unsigned long irqflags;
 
-	if (trig_num != 0)
+	if (trig_num)
 		return -EINVAL;
 
 	spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
@@ -1656,7 +1653,7 @@ static int pci230_ai_check_chanlist(struct comedi_device *dev,
 	if (subseq_len == 0)
 		subseq_len = cmd->chanlist_len;
 
-	if ((cmd->chanlist_len % subseq_len) != 0) {
+	if (cmd->chanlist_len % subseq_len) {
 		dev_dbg(dev->class_dev,
 			"%s: sequence must repeat exactly\n", __func__);
 		return -EINVAL;
@@ -1674,7 +1671,7 @@ static int pci230_ai_check_chanlist(struct comedi_device *dev,
 	 * the bug, but the second one does, and we can't tell them apart!
 	 */
 	if (devpriv->hwver > 0 && devpriv->hwver < 4) {
-		if (subseq_len > 1 && CR_CHAN(cmd->chanlist[0]) != 0) {
+		if (subseq_len > 1 && CR_CHAN(cmd->chanlist[0])) {
 			dev_info(dev->class_dev,
 				 "amplc_pci230: ai_cmdtest: Buggy PCI230+/260+ h/w version %u requires first channel of multi-channel sequence to be 0 (corrected in h/w version 4)\n",
 				 devpriv->hwver);
@@ -1786,9 +1783,9 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 		 * convert_arg == (CR_EDGE | CR_INVERT | 0)
 		 *                => trigger on -ve edge.
 		 */
-		if ((cmd->convert_arg & CR_FLAGS_MASK) != 0) {
+		if (cmd->convert_arg & CR_FLAGS_MASK) {
 			/* Trigger number must be 0. */
-			if ((cmd->convert_arg & ~CR_FLAGS_MASK) != 0) {
+			if (cmd->convert_arg & ~CR_FLAGS_MASK) {
 				cmd->convert_arg = COMBINE(cmd->convert_arg, 0,
 							   ~CR_FLAGS_MASK);
 				err |= -EINVAL;
@@ -1829,13 +1826,13 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 		 * scan_begin_arg==0 => use PPC0 input -> gate of CT0 -> gate
 		 * of CT2 (sample convert trigger is CT2)
 		 */
-		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
+		if (cmd->scan_begin_arg & ~CR_FLAGS_MASK) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      ~CR_FLAGS_MASK);
 			err |= -EINVAL;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
-		if ((cmd->scan_begin_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
+		if (cmd->scan_begin_arg & CR_FLAGS_MASK & ~CR_EDGE) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      CR_FLAGS_MASK & ~CR_EDGE);
 			err |= -EINVAL;
@@ -1898,7 +1895,7 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 	unsigned short triglev;
 	unsigned short adccon;
 
-	if ((cmd->flags & TRIG_WAKE_EOS) != 0) {
+	if (cmd->flags & TRIG_WAKE_EOS) {
 		/* Wake at end of scan. */
 		wake = scanlen - devpriv->ai_scan_pos;
 	} else {
@@ -1939,7 +1936,7 @@ static int pci230_ai_inttrig_convert(struct comedi_device *dev,
 	struct pci230_private *devpriv = dev->private;
 	unsigned long irqflags;
 
-	if (trig_num != 0)
+	if (trig_num)
 		return -EINVAL;
 
 	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
@@ -1986,7 +1983,7 @@ static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
 	unsigned long irqflags;
 	unsigned char zgat;
 
-	if (trig_num != 0)
+	if (trig_num)
 		return -EINVAL;
 
 	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
@@ -2088,7 +2085,7 @@ static void pci230_ai_start(struct comedi_device *dev,
 			conv = PCI230_ADC_TRIG_Z2CT2;
 			break;
 		case TRIG_EXT:
-			if ((cmd->convert_arg & CR_EDGE) != 0) {
+			if (cmd->convert_arg & CR_EDGE) {
 				if ((cmd->convert_arg & CR_INVERT) == 0) {
 					/* Trigger on +ve edge. */
 					conv = PCI230_ADC_TRIG_EXTP;
@@ -2098,7 +2095,7 @@ static void pci230_ai_start(struct comedi_device *dev,
 				}
 			} else {
 				/* Backwards compatibility. */
-				if (cmd->convert_arg != 0) {
+				if (cmd->convert_arg) {
 					/* Trigger on +ve edge. */
 					conv = PCI230_ADC_TRIG_EXTP;
 				} else {
@@ -2252,7 +2249,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 		if (fifoamount == 0) {
 			/* Read FIFO state. */
 			status_fifo = inw(dev->iobase + PCI230_ADCCON);
-			if ((status_fifo & PCI230_ADC_FIFO_FULL_LATCHED) != 0) {
+			if (status_fifo & PCI230_ADC_FIFO_FULL_LATCHED) {
 				/*
 				 * Report error otherwise FIFO overruns will go
 				 * unnoticed by the caller.
@@ -2260,10 +2257,10 @@ static void pci230_handle_ai(struct comedi_device *dev,
 				dev_err(dev->class_dev, "AI FIFO overrun\n");
 				events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 				break;
-			} else if ((status_fifo & PCI230_ADC_FIFO_EMPTY) != 0) {
+			} else if (status_fifo & PCI230_ADC_FIFO_EMPTY) {
 				/* FIFO empty. */
 				break;
-			} else if ((status_fifo & PCI230_ADC_FIFO_HALF) != 0) {
+			} else if (status_fifo & PCI230_ADC_FIFO_HALF) {
 				/* FIFO half full. */
 				fifoamount = PCI230_ADC_FIFOLEVEL_HALFFULL;
 			} else {
@@ -2304,8 +2301,8 @@ static void pci230_handle_ai(struct comedi_device *dev,
 		events |= COMEDI_CB_BLOCK;
 	}
 	async->events |= events;
-	if ((async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
-			      COMEDI_CB_OVERFLOW)) != 0) {
+	if (async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
+			     COMEDI_CB_OVERFLOW)) {
 		/* disable hardware conversions */
 		pci230_ai_stop(dev, s);
 	} else {
@@ -2561,19 +2558,19 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	 * two.
 	 */
 
-	if ((valid_status_int & PCI230_INT_ZCLK_CT1) != 0) {
+	if (valid_status_int & PCI230_INT_ZCLK_CT1) {
 		s = dev->write_subdev;
 		pci230_handle_ao_nofifo(dev, s);
 		comedi_event(dev, s);
 	}
 
-	if ((valid_status_int & PCI230P2_INT_DAC) != 0) {
+	if (valid_status_int & PCI230P2_INT_DAC) {
 		s = dev->write_subdev;
 		pci230_handle_ao_fifo(dev, s);
 		comedi_event(dev, s);
 	}
 
-	if ((valid_status_int & PCI230_INT_ADC) != 0) {
+	if (valid_status_int & PCI230_INT_ADC) {
 		s = dev->read_subdev;
 		pci230_handle_ai(dev, s);
 		comedi_event(dev, s);
@@ -2741,7 +2738,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 			}
 		}
 		outw(extfunc, dev->iobase + PCI230P_EXTFUNC);
-		if ((extfunc & PCI230P2_EXTFUNC_DACFIFO) != 0) {
+		if (extfunc & PCI230P2_EXTFUNC_DACFIFO) {
 			/*
 			 * Temporarily enable DAC FIFO, reset it and disable
 			 * FIFO wraparound.

commit 76cb39e014da351eebfdfa77dc69e4978ebcb6b2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:19 2014 +0100

    staging: comedi: amplc_pci230: don't begin line with binary operator
    
    If an expression involving a binary operator needs to be split across
    two lines, put the split after the operator.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 4d3d3cbfe3a2..311c4974439b 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -682,8 +682,8 @@ static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 			} else if (devpriv->res_owner[i] != owner) {
 				for (b = 1, i = 0; claimed != 0; b <<= 1, i++) {
 					if ((claimed & b) != 0) {
-						devpriv->res_owner[i]
-						    = OWNER_NONE;
+						devpriv->res_owner[i] =
+						    OWNER_NONE;
 						claimed &= ~b;
 					}
 				}
@@ -884,8 +884,8 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 		gainshift = chan & ~1;
 		adccon |= PCI230_ADC_IM_SE;
 	}
-	devpriv->adcg = (devpriv->adcg & ~(3 << gainshift))
-	    | (pci230_ai_gain[range] << gainshift);
+	devpriv->adcg = (devpriv->adcg & ~(3 << gainshift)) |
+			(pci230_ai_gain[range] << gainshift);
 	if (devpriv->ai_bipolar)
 		adccon |= PCI230_ADC_IR_BIP;
 	else
@@ -1095,8 +1095,8 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 		 * The only flags allowed are CR_EDGE and CR_INVERT.
 		 * The CR_EDGE flag is ignored.
 		 */
-		if ((cmd->scan_begin_arg
-		     & (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {
+		if ((cmd->scan_begin_arg &
+		     (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      CR_FLAGS_MASK &
 						      ~(CR_EDGE | CR_INVERT));
@@ -1186,8 +1186,8 @@ static void pci230_ao_stop(struct comedi_device *dev,
 		 * disable FIFO.
 		 */
 		devpriv->daccon &= PCI230_DAC_OR_MASK;
-		outw(devpriv->daccon | PCI230P2_DAC_FIFO_RESET
-		     | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,
+		outw(devpriv->daccon | PCI230P2_DAC_FIFO_RESET |
+		     PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,
 		     dev->iobase + PCI230_DACCON);
 	}
 	/* Release resources. */
@@ -1307,10 +1307,10 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 				 * to FIFO.  Set FIFO interrupt trigger level
 				 * to 'empty'.
 				 */
-				devpriv->daccon = (devpriv->daccon
-						   &
-						   ~PCI230P2_DAC_INT_FIFO_MASK)
-				    | PCI230P2_DAC_INT_FIFO_EMPTY;
+				devpriv->daccon =
+				    (devpriv->daccon &
+				     ~PCI230P2_DAC_INT_FIFO_MASK) |
+				    PCI230P2_DAC_INT_FIFO_EMPTY;
 				outw(devpriv->daccon,
 				     dev->iobase + PCI230_DACCON);
 			}
@@ -1322,8 +1322,8 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
 	}
-	if ((events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
-	    != 0) {
+	if ((events &
+	     (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) != 0) {
 		/* Stopping AO due to completion or error. */
 		pci230_ao_stop(dev, s);
 		running = 0;
@@ -1420,8 +1420,8 @@ static void pci230_ao_start(struct comedi_device *dev,
 				scantrig = PCI230P2_DAC_TRIG_NONE;
 				break;
 			}
-			devpriv->daccon = (devpriv->daccon
-					   & ~PCI230P2_DAC_TRIG_MASK) |
+			devpriv->daccon =
+			    (devpriv->daccon & ~PCI230P2_DAC_TRIG_MASK) |
 			    scantrig;
 			outw(devpriv->daccon, dev->iobase + PCI230_DACCON);
 		}
@@ -1521,16 +1521,16 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 *
 		 * N.B. DAC FIFO interrupts are currently disabled.
 		 */
-		daccon |= PCI230P2_DAC_FIFO_EN | PCI230P2_DAC_FIFO_RESET
-		    | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR
-		    | PCI230P2_DAC_TRIG_NONE | PCI230P2_DAC_INT_FIFO_NHALF;
+		daccon |= PCI230P2_DAC_FIFO_EN | PCI230P2_DAC_FIFO_RESET |
+			  PCI230P2_DAC_FIFO_UNDERRUN_CLEAR |
+			  PCI230P2_DAC_TRIG_NONE | PCI230P2_DAC_INT_FIFO_NHALF;
 	}
 
 	/* Set DACCON. */
 	outw(daccon, dev->iobase + PCI230_DACCON);
 	/* Preserve most of DACCON apart from write-only, transient bits. */
-	devpriv->daccon = daccon
-	    & ~(PCI230P2_DAC_FIFO_RESET | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR);
+	devpriv->daccon = daccon & ~(PCI230P2_DAC_FIFO_RESET |
+				     PCI230P2_DAC_FIFO_UNDERRUN_CLEAR);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		/*
@@ -1797,8 +1797,8 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 			 * The only flags allowed are CR_INVERT and CR_EDGE.
 			 * CR_EDGE is required.
 			 */
-			if ((cmd->convert_arg & (CR_FLAGS_MASK & ~CR_INVERT))
-			    != CR_EDGE) {
+			if ((cmd->convert_arg &
+			     (CR_FLAGS_MASK & ~CR_INVERT)) != CR_EDGE) {
 				/* Set CR_EDGE, preserve CR_INVERT. */
 				cmd->convert_arg = COMBINE(cmd->start_arg,
 							   (CR_EDGE | 0),
@@ -1907,8 +1907,8 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 		    scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
 			wake = PCI230_ADC_FIFOLEVEL_HALFFULL;
 		} else {
-			wake = (devpriv->ai_scan_count * scanlen)
-			    - devpriv->ai_scan_pos;
+			wake = (devpriv->ai_scan_count * scanlen) -
+			       devpriv->ai_scan_pos;
 		}
 	}
 	if (wake >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
@@ -2043,8 +2043,8 @@ static void pci230_ai_stop(struct comedi_device *dev,
 	 * Reset FIFO, disable FIFO and set start conversion source to none.
 	 * Keep se/diff and bip/uni settings.
 	 */
-	devpriv->adccon = (devpriv->adccon & (PCI230_ADC_IR_MASK
-					      | PCI230_ADC_IM_MASK)) |
+	devpriv->adccon =
+	    (devpriv->adccon & (PCI230_ADC_IR_MASK | PCI230_ADC_IM_MASK)) |
 	    PCI230_ADC_TRIG_NONE;
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
 	     dev->iobase + PCI230_ADCCON);
@@ -2115,8 +2115,8 @@ static void pci230_ai_start(struct comedi_device *dev,
 			conv = PCI230_ADC_TRIG_Z2CT2;
 			break;
 		}
-		devpriv->adccon = (devpriv->adccon & ~PCI230_ADC_TRIG_MASK)
-		    | conv;
+		devpriv->adccon =
+		    (devpriv->adccon & ~PCI230_ADC_TRIG_MASK) | conv;
 		outw(devpriv->adccon, dev->iobase + PCI230_ADCCON);
 		if (cmd->convert_src == TRIG_INT)
 			async->inttrig = pci230_ai_inttrig_convert;
@@ -2187,8 +2187,8 @@ static void pci230_ai_start(struct comedi_device *dev,
 					 * gated on to start counting.
 					 */
 					zgat = GAT_CONFIG(1, GAT_VCC);
-					outb(zgat, devpriv->iobase1
-					     + PCI230_ZGAT_SCE);
+					outb(zgat, devpriv->iobase1 +
+						   PCI230_ZGAT_SCE);
 					break;
 				case TRIG_INT:
 					async->inttrig =
@@ -2240,8 +2240,8 @@ static void pci230_handle_ai(struct comedi_device *dev,
 		   (scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL)) {
 		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	} else {
-		todo = (devpriv->ai_scan_count * scanlen)
-		    - devpriv->ai_scan_pos;
+		todo = (devpriv->ai_scan_count * scanlen) -
+		       devpriv->ai_scan_pos;
 		if (todo > PCI230_ADC_FIFOLEVEL_HALFFULL)
 			todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	}
@@ -2270,8 +2270,8 @@ static void pci230_handle_ai(struct comedi_device *dev,
 				/* FIFO not empty. */
 				if (devpriv->hwver > 0) {
 					/* Read PCI230+/260+ ADC FIFO level. */
-					fifoamount = inw(dev->iobase
-							 + PCI230P_ADCFFLEV);
+					fifoamount =
+					    inw(dev->iobase + PCI230P_ADCFFLEV);
 					if (fifoamount == 0) {
 						/* Shouldn't happen. */
 						break;
@@ -2417,8 +2417,8 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			gainshift = (chan & ~1);
 			adcen |= 1 << chan;
 		}
-		devpriv->adcg = (devpriv->adcg & ~(3 << gainshift))
-		    | (pci230_ai_gain[range] << gainshift);
+		devpriv->adcg = (devpriv->adcg & ~(3 << gainshift)) |
+				(pci230_ai_gain[range] << gainshift);
 	}
 
 	/* Set channel scan list. */
@@ -2490,8 +2490,8 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			zgat = GAT_CONFIG(0, GAT_VCC);
 			outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 			pci230_ct_setup_ns_mode(dev, 0, I8254_MODE1,
-						((uint64_t) cmd->convert_arg
-						 * cmd->scan_end_arg),
+						((uint64_t)cmd->convert_arg *
+						 cmd->scan_end_arg),
 						TRIG_ROUND_UP);
 			if (cmd->scan_begin_src == TRIG_TIMER) {
 				/*
@@ -2746,8 +2746,8 @@ static int pci230_attach_common(struct comedi_device *dev,
 			 * Temporarily enable DAC FIFO, reset it and disable
 			 * FIFO wraparound.
 			 */
-			outw(devpriv->daccon | PCI230P2_DAC_FIFO_EN
-			     | PCI230P2_DAC_FIFO_RESET,
+			outw(devpriv->daccon | PCI230P2_DAC_FIFO_EN |
+			     PCI230P2_DAC_FIFO_RESET,
 			     dev->iobase + PCI230_DACCON);
 			/* Clear DAC FIFO channel enable register. */
 			outw(0, dev->iobase + PCI230P2_DACEN);
@@ -2759,8 +2759,8 @@ static int pci230_attach_common(struct comedi_device *dev,
 	outb(0, devpriv->iobase1 + PCI230_INT_SCE);
 	/* Set ADC to a reasonable state. */
 	devpriv->adcg = 0;
-	devpriv->adccon = PCI230_ADC_TRIG_NONE | PCI230_ADC_IM_SE
-	    | PCI230_ADC_IR_BIP;
+	devpriv->adccon = PCI230_ADC_TRIG_NONE | PCI230_ADC_IM_SE |
+			  PCI230_ADC_IR_BIP;
 	outw(1 << 0, dev->iobase + PCI230_ADCEN);
 	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,

commit 8b39e8e973f91f9b80ba1a42e9be7e24eb040081
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:18 2014 +0100

    staging: comedi: amplc_pci230: add whitespace to register values
    
    Several macros are defined for bit-field values within hardware
    registers.  They are defined as left-shifted values.  Add some
    whitespace around the left-shift operator.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index f94b542ca76d..4d3d3cbfe3a2 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -249,47 +249,47 @@
 /*
  * DACCON read-write values.
  */
-#define PCI230_DAC_OR_UNI		(0<<0)	/* Output range unipolar */
-#define PCI230_DAC_OR_BIP		(1<<0)	/* Output range bipolar */
-#define PCI230_DAC_OR_MASK		(1<<0)
+#define PCI230_DAC_OR_UNI		(0 << 0) /* Output range unipolar */
+#define PCI230_DAC_OR_BIP		(1 << 0) /* Output range bipolar */
+#define PCI230_DAC_OR_MASK		(1 << 0)
 /*
  * The following applies only if DAC FIFO support is enabled in the EXTFUNC
  * register (and only for PCI230+ hardware version 2 onwards).
  */
-#define PCI230P2_DAC_FIFO_EN		(1<<8)	/* FIFO enable */
+#define PCI230P2_DAC_FIFO_EN		(1 << 8) /* FIFO enable */
 /*
  * The following apply only if the DAC FIFO is enabled (and only for PCI230+
  * hardware version 2 onwards).
  */
-#define PCI230P2_DAC_TRIG_NONE		(0<<2)	/* No trigger */
-#define PCI230P2_DAC_TRIG_SW		(1<<2)	/* Software trigger trigger */
-#define PCI230P2_DAC_TRIG_EXTP		(2<<2)	/* EXTTRIG +ve edge trigger */
-#define PCI230P2_DAC_TRIG_EXTN		(3<<2)	/* EXTTRIG -ve edge trigger */
-#define PCI230P2_DAC_TRIG_Z2CT0		(4<<2)	/* CT0-OUT +ve edge trigger */
-#define PCI230P2_DAC_TRIG_Z2CT1		(5<<2)	/* CT1-OUT +ve edge trigger */
-#define PCI230P2_DAC_TRIG_Z2CT2		(6<<2)	/* CT2-OUT +ve edge trigger */
-#define PCI230P2_DAC_TRIG_MASK		(7<<2)
-#define PCI230P2_DAC_FIFO_WRAP		(1<<7)	/* FIFO wraparound mode */
-#define PCI230P2_DAC_INT_FIFO_EMPTY	(0<<9)	/* FIFO interrupt empty */
-#define PCI230P2_DAC_INT_FIFO_NEMPTY	(1<<9)
-#define PCI230P2_DAC_INT_FIFO_NHALF	(2<<9)	/* FIFO intr not half full */
-#define PCI230P2_DAC_INT_FIFO_HALF	(3<<9)
-#define PCI230P2_DAC_INT_FIFO_NFULL	(4<<9)	/* FIFO interrupt not full */
-#define PCI230P2_DAC_INT_FIFO_FULL	(5<<9)
-#define PCI230P2_DAC_INT_FIFO_MASK	(7<<9)
+#define PCI230P2_DAC_TRIG_NONE		(0 << 2) /* No trigger */
+#define PCI230P2_DAC_TRIG_SW		(1 << 2) /* Software trigger trigger */
+#define PCI230P2_DAC_TRIG_EXTP		(2 << 2) /* EXTTRIG +ve edge trigger */
+#define PCI230P2_DAC_TRIG_EXTN		(3 << 2) /* EXTTRIG -ve edge trigger */
+#define PCI230P2_DAC_TRIG_Z2CT0		(4 << 2) /* CT0-OUT +ve edge trigger */
+#define PCI230P2_DAC_TRIG_Z2CT1		(5 << 2) /* CT1-OUT +ve edge trigger */
+#define PCI230P2_DAC_TRIG_Z2CT2		(6 << 2) /* CT2-OUT +ve edge trigger */
+#define PCI230P2_DAC_TRIG_MASK		(7 << 2)
+#define PCI230P2_DAC_FIFO_WRAP		(1 << 7) /* FIFO wraparound mode */
+#define PCI230P2_DAC_INT_FIFO_EMPTY	(0 << 9) /* FIFO interrupt empty */
+#define PCI230P2_DAC_INT_FIFO_NEMPTY	(1 << 9)
+#define PCI230P2_DAC_INT_FIFO_NHALF	(2 << 9) /* FIFO intr not half full */
+#define PCI230P2_DAC_INT_FIFO_HALF	(3 << 9)
+#define PCI230P2_DAC_INT_FIFO_NFULL	(4 << 9) /* FIFO interrupt not full */
+#define PCI230P2_DAC_INT_FIFO_FULL	(5 << 9)
+#define PCI230P2_DAC_INT_FIFO_MASK	(7 << 9)
 
 /*
  * DACCON read-only values.
  */
-#define PCI230_DAC_BUSY			(1<<1)	/* DAC busy. */
+#define PCI230_DAC_BUSY			(1 << 1) /* DAC busy. */
 /*
  * The following apply only if the DAC FIFO is enabled (and only for PCI230+
  * hardware version 2 onwards).
  */
-#define PCI230P2_DAC_FIFO_UNDERRUN_LATCHED	(1<<5)	/* Underrun error */
-#define PCI230P2_DAC_FIFO_EMPTY		(1<<13)	/* FIFO empty */
-#define PCI230P2_DAC_FIFO_FULL		(1<<14)	/* FIFO full */
-#define PCI230P2_DAC_FIFO_HALF		(1<<15)	/* FIFO half full */
+#define PCI230P2_DAC_FIFO_UNDERRUN_LATCHED	(1 << 5) /* Underrun error */
+#define PCI230P2_DAC_FIFO_EMPTY		(1 << 13) /* FIFO empty */
+#define PCI230P2_DAC_FIFO_FULL		(1 << 14) /* FIFO full */
+#define PCI230P2_DAC_FIFO_HALF		(1 << 15) /* FIFO half full */
 
 /*
  * DACCON write-only, transient values.
@@ -298,8 +298,8 @@
  * The following apply only if the DAC FIFO is enabled (and only for PCI230+
  * hardware version 2 onwards).
  */
-#define PCI230P2_DAC_FIFO_UNDERRUN_CLEAR	(1<<5)	/* Clear underrun */
-#define PCI230P2_DAC_FIFO_RESET		(1<<12)	/* FIFO reset */
+#define PCI230P2_DAC_FIFO_UNDERRUN_CLEAR	(1 << 5) /* Clear underrun */
+#define PCI230P2_DAC_FIFO_RESET		(1 << 12) /* FIFO reset */
 
 /*
  * PCI230+ hardware version 2 DAC FIFO levels.
@@ -316,44 +316,44 @@
 /*
  * ADCCON read/write values.
  */
-#define PCI230_ADC_TRIG_NONE		(0<<0)	/* No trigger */
-#define PCI230_ADC_TRIG_SW		(1<<0)	/* Software trigger trigger */
-#define PCI230_ADC_TRIG_EXTP		(2<<0)	/* EXTTRIG +ve edge trigger */
-#define PCI230_ADC_TRIG_EXTN		(3<<0)	/* EXTTRIG -ve edge trigger */
-#define PCI230_ADC_TRIG_Z2CT0		(4<<0)	/* CT0-OUT +ve edge trigger */
-#define PCI230_ADC_TRIG_Z2CT1		(5<<0)	/* CT1-OUT +ve edge trigger */
-#define PCI230_ADC_TRIG_Z2CT2		(6<<0)	/* CT2-OUT +ve edge trigger */
-#define PCI230_ADC_TRIG_MASK		(7<<0)
-#define PCI230_ADC_IR_UNI		(0<<3)	/* Input range unipolar */
-#define PCI230_ADC_IR_BIP		(1<<3)	/* Input range bipolar */
-#define PCI230_ADC_IR_MASK		(1<<3)
-#define PCI230_ADC_IM_SE		(0<<4)	/* Input mode single ended */
-#define PCI230_ADC_IM_DIF		(1<<4)	/* Input mode differential */
-#define PCI230_ADC_IM_MASK		(1<<4)
-#define PCI230_ADC_FIFO_EN		(1<<8)	/* FIFO enable */
-#define PCI230_ADC_INT_FIFO_EMPTY	(0<<9)
-#define PCI230_ADC_INT_FIFO_NEMPTY	(1<<9)	/* FIFO interrupt not empty */
-#define PCI230_ADC_INT_FIFO_NHALF	(2<<9)
-#define PCI230_ADC_INT_FIFO_HALF	(3<<9)	/* FIFO interrupt half full */
-#define PCI230_ADC_INT_FIFO_NFULL	(4<<9)
-#define PCI230_ADC_INT_FIFO_FULL	(5<<9)	/* FIFO interrupt full */
-#define PCI230P_ADC_INT_FIFO_THRESH	(7<<9)	/* FIFO interrupt threshold */
-#define PCI230_ADC_INT_FIFO_MASK	(7<<9)
+#define PCI230_ADC_TRIG_NONE		(0 << 0) /* No trigger */
+#define PCI230_ADC_TRIG_SW		(1 << 0) /* Software trigger trigger */
+#define PCI230_ADC_TRIG_EXTP		(2 << 0) /* EXTTRIG +ve edge trigger */
+#define PCI230_ADC_TRIG_EXTN		(3 << 0) /* EXTTRIG -ve edge trigger */
+#define PCI230_ADC_TRIG_Z2CT0		(4 << 0) /* CT0-OUT +ve edge trigger */
+#define PCI230_ADC_TRIG_Z2CT1		(5 << 0) /* CT1-OUT +ve edge trigger */
+#define PCI230_ADC_TRIG_Z2CT2		(6 << 0) /* CT2-OUT +ve edge trigger */
+#define PCI230_ADC_TRIG_MASK		(7 << 0)
+#define PCI230_ADC_IR_UNI		(0 << 3) /* Input range unipolar */
+#define PCI230_ADC_IR_BIP		(1 << 3) /* Input range bipolar */
+#define PCI230_ADC_IR_MASK		(1 << 3)
+#define PCI230_ADC_IM_SE		(0 << 4) /* Input mode single ended */
+#define PCI230_ADC_IM_DIF		(1 << 4) /* Input mode differential */
+#define PCI230_ADC_IM_MASK		(1 << 4)
+#define PCI230_ADC_FIFO_EN		(1 << 8) /* FIFO enable */
+#define PCI230_ADC_INT_FIFO_EMPTY	(0 << 9)
+#define PCI230_ADC_INT_FIFO_NEMPTY	(1 << 9) /* FIFO interrupt not empty */
+#define PCI230_ADC_INT_FIFO_NHALF	(2 << 9)
+#define PCI230_ADC_INT_FIFO_HALF	(3 << 9) /* FIFO interrupt half full */
+#define PCI230_ADC_INT_FIFO_NFULL	(4 << 9)
+#define PCI230_ADC_INT_FIFO_FULL	(5 << 9) /* FIFO interrupt full */
+#define PCI230P_ADC_INT_FIFO_THRESH	(7 << 9) /* FIFO interrupt threshold */
+#define PCI230_ADC_INT_FIFO_MASK	(7 << 9)
 
 /*
  * ADCCON write-only, transient values.
  */
-#define PCI230_ADC_FIFO_RESET		(1<<12)	/* FIFO reset */
-#define PCI230_ADC_GLOB_RESET		(1<<13)	/* Global reset */
+#define PCI230_ADC_FIFO_RESET		(1 << 12) /* FIFO reset */
+#define PCI230_ADC_GLOB_RESET		(1 << 13) /* Global reset */
 
 /*
  * ADCCON read-only values.
  */
-#define PCI230_ADC_BUSY			(1<<15)	/* ADC busy */
-#define PCI230_ADC_FIFO_EMPTY		(1<<12)	/* FIFO empty */
-#define PCI230_ADC_FIFO_FULL		(1<<13)	/* FIFO full */
-#define PCI230_ADC_FIFO_HALF		(1<<14)	/* FIFO half full */
-#define PCI230_ADC_FIFO_FULL_LATCHED	(1<<5)	/* Indicates overrun occurred */
+#define PCI230_ADC_BUSY			(1 << 15) /* ADC busy */
+#define PCI230_ADC_FIFO_EMPTY		(1 << 12) /* FIFO empty */
+#define PCI230_ADC_FIFO_FULL		(1 << 13) /* FIFO full */
+#define PCI230_ADC_FIFO_HALF		(1 << 14) /* FIFO half full */
+#define PCI230_ADC_FIFO_FULL_LATCHED	(1 << 5)  /* FIFO overrun occurred */
 
 /*
  * PCI230 ADC FIFO levels.
@@ -365,10 +365,10 @@
  * PCI230+ EXTFUNC values.
  */
 /* Route EXTTRIG pin to external gate inputs. */
-#define PCI230P_EXTFUNC_GAT_EXTTRIG	(1<<0)
+#define PCI230P_EXTFUNC_GAT_EXTTRIG	(1 << 0)
 /* PCI230+ hardware version 2 values. */
 /* Allow DAC FIFO to be enabled. */
-#define PCI230P2_EXTFUNC_DACFIFO	(1<<1)
+#define PCI230P2_EXTFUNC_DACFIFO	(1 << 1)
 
 /*
  * Counter/timer clock input configuration sources.
@@ -416,12 +416,12 @@
  * Interrupt enables/status register values.
  */
 #define PCI230_INT_DISABLE		0
-#define PCI230_INT_PPI_C0		(1<<0)
-#define PCI230_INT_PPI_C3		(1<<1)
-#define PCI230_INT_ADC			(1<<2)
-#define PCI230_INT_ZCLK_CT1		(1<<5)
+#define PCI230_INT_PPI_C0		(1 << 0)
+#define PCI230_INT_PPI_C3		(1 << 1)
+#define PCI230_INT_ADC			(1 << 2)
+#define PCI230_INT_ZCLK_CT1		(1 << 5)
 /* For PCI230+ hardware version 2 when DAC FIFO enabled. */
-#define PCI230P2_INT_DAC		(1<<4)
+#define PCI230P2_INT_DAC		(1 << 4)
 
 /*
  * (Potentially) shared resources and their owners

commit 5c165423bcb92ecd8aba93af25823ee567fb0280
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:17 2014 +0100

    staging: comedi: amplc_pci230: remove PCI230_TEST_BIT()
    
    The `PCI230_TEST_BIT()` macro is never used.  Remove it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index e6744a5e0189..f94b542ca76d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -423,9 +423,6 @@
 /* For PCI230+ hardware version 2 when DAC FIFO enabled. */
 #define PCI230P2_INT_DAC		(1<<4)
 
-/* Assumes bits numbered with zero offset, ie. 0-15 */
-#define PCI230_TEST_BIT(val, n)	((val>>n)&1)
-
 /*
  * (Potentially) shared resources and their owners
  */

commit e58dbebcc79c9ac92c77448eadf294533aa7cf50
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:16 2014 +0100

    staging: comedi: amplc_pci230: remove PCI230_ADC_CONV
    
    The macro `PCI230_ADC_CONV` is never used.  Just remove it.  (At one
    time, the value was written to the `PCI230_ADCSWTRIG` register to
    trigger a conversion, but any value would do, and the driver no longer
    uses that register to trigger conversions anyway.)
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 7983a0d53928..e6744a5e0189 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -361,12 +361,6 @@
 #define PCI230_ADC_FIFOLEVEL_HALFFULL	2049	/* Value for FIFO half full */
 #define PCI230_ADC_FIFOLEVEL_FULL	4096	/* FIFO size */
 
-/*
- * Value to write to ADCSWTRIG to trigger ADC conversion in software trigger
- * mode.  Can be anything.
- */
-#define PCI230_ADC_CONV			0xffff
-
 /*
  * PCI230+ EXTFUNC values.
  */

commit ad501004d61f542c7cc5fce965e407dc05e2cbda
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:15 2014 +0100

    staging: comedi: amplc_pci230: remove unused settling time constants
    
    The macro constants `PCI230_DAC_SETTLE`, `PCI230_ADC_SETTLE` and
    `PCI230_MUX_SETTLE` are never used.  Just remove them.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 00d7a2277e85..7983a0d53928 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -246,19 +246,6 @@
 #define PCI230P2_DACSWTRIG	0x02	/* DAC soft trigger (FIFO mode) (r) */
 #define PCI230P2_DACEN		0x06	/* DAC channel enable (FIFO mode) */
 
-/*
- * Convertor related constants.
- */
-/* Analogue output settling time in s (DAC itself is 1s nominally). */
-#define PCI230_DAC_SETTLE 5
-/*
- * Analogue input settling time in s (ADC itself is 1.6s nominally but we
- * poll anyway).
- */
-#define PCI230_ADC_SETTLE 1
-/* ADC MUX settling time in S - 10s for se, 20s de. */
-#define PCI230_MUX_SETTLE 10
-
 /*
  * DACCON read-write values.
  */

commit e3f59e1c5f48bf1ba07467ff83bf8d889e273c8a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:14 2014 +0100

    staging: comedi: amplc_pci230: usleep_range is preferred over udelay
    
    Fix checkpatch issue: "CHECK: usleep_range is preferred over udelay; see
    Documentation/timers/timers-howto.txt".  I picked 100 us as a reasonable
    upper bound, but it's not that critical.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 76c4625991b2..00d7a2277e85 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2480,7 +2480,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * channel gains and scan list _before_ the first FIFO reset also
 	 * helps, though only slightly.
 	 */
-	udelay(25);
+	usleep_range(25, 100);
 
 	/* Reset FIFO again. */
 	outw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);

commit 9fd8fc3fd0f199a0aadda393b13541aec585175b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:13 2014 +0100

    staging: comedi: amplc_pci230: alignment should match open parenthesis
    
    Fix checkpatch issue: "CHECK: Alignment should match open parenthesis".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 51f28b6a05d9..76c4625991b2 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2872,7 +2872,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 }
 
 static int pci230_auto_attach(struct comedi_device *dev,
-					unsigned long context_unused)
+			      unsigned long context_unused)
 {
 	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
 	int rc;

commit 16de83f53aeb376e65f15bc717d4582068c371f5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:12 2014 +0100

    staging: comedi: amplc_pci230: blank lines aren't necessary before a close brace '}'
    
    Fix checkpatch issues: "CHECK: Blank lines aren't necessary before a
    close brace '}'".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 0609e5149405..51f28b6a05d9 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -739,7 +739,6 @@ static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 			res_mask &= ~b;
 			if (devpriv->res_owner[i] == owner)
 				devpriv->res_owner[i] = OWNER_NONE;
-
 		}
 	}
 	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
@@ -792,7 +791,6 @@ static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
 		cnt = divide_ns(ns, pci230_timebase[clk_src], flags);
 		if ((cnt <= 65536) || (clk_src == CLK_1KHZ))
 			break;
-
 	}
 	*count = cnt;
 	return clk_src;
@@ -1448,7 +1446,6 @@ static void pci230_ao_start(struct comedi_device *dev,
 					   & ~PCI230P2_DAC_TRIG_MASK) |
 			    scantrig;
 			outw(devpriv->daccon, dev->iobase + PCI230_DACCON);
-
 		}
 		switch (cmd->scan_begin_src) {
 		case TRIG_TIMER:
@@ -1512,7 +1509,6 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* Claim Z2-CT1. */
 		if (!get_one_resource(dev, RES_Z2CT1, OWNER_AOCMD))
 			return -EBUSY;
-
 	}
 
 	/* Get number of scans required. */

commit c8e8b7a15517756a6501a636f3cfccbdd17e633a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:11 2014 +0100

    staging: comedi: amplc_pci230: logical continuations should be on the previous line
    
    Fix checkpatch issues "CHECK: Logical continuations should be on the
    previous line".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index c6c3c4ae2263..0609e5149405 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -694,8 +694,8 @@ static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 	ok = 1;
 	claimed = 0;
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
-	for (b = 1, i = 0; (i < NUM_RESOURCES)
-	     && (res_mask != 0); b <<= 1, i++) {
+	for (b = 1, i = 0; (i < NUM_RESOURCES) && (res_mask != 0);
+	     b <<= 1, i++) {
 		if ((res_mask & b) != 0) {
 			res_mask &= ~b;
 			if (devpriv->res_owner[i] == OWNER_NONE) {
@@ -733,8 +733,8 @@ static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 	unsigned long irqflags;
 
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
-	for (b = 1, i = 0; (i < NUM_RESOURCES)
-	     && (res_mask != 0); b <<= 1, i++) {
+	for (b = 1, i = 0; (i < NUM_RESOURCES) && (res_mask != 0);
+	     b <<= 1, i++) {
 		if ((res_mask & b) != 0) {
 			res_mask &= ~b;
 			if (devpriv->res_owner[i] == owner)
@@ -1291,8 +1291,8 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 		 * (otherwise there will be loads of "DAC FIFO not half full"
 		 * interrupts).
 		 */
-		if ((num_scans == 0)
-		    && ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {
+		if ((num_scans == 0) &&
+		    ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {
 			dev_err(dev->class_dev, "AO buffer underrun\n");
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
@@ -1594,8 +1594,8 @@ static int pci230_ai_check_scan_period(struct comedi_cmd *cmd)
 		chanlist_len = 1;
 
 	min_scan_period = chanlist_len * cmd->convert_arg;
-	if ((min_scan_period < chanlist_len)
-	    || (min_scan_period < cmd->convert_arg)) {
+	if ((min_scan_period < chanlist_len) ||
+	    (min_scan_period < cmd->convert_arg)) {
 		/* Arithmetic overflow. */
 		min_scan_period = UINT_MAX;
 		err++;
@@ -1755,8 +1755,8 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 	 * If scan_begin_src is not TRIG_FOLLOW, then a monostable will be
 	 * set up to generate a fixed number of timed conversion pulses.
 	 */
-	if ((cmd->scan_begin_src != TRIG_FOLLOW)
-	    && (cmd->convert_src != TRIG_TIMER))
+	if ((cmd->scan_begin_src != TRIG_FOLLOW) &&
+	    (cmd->convert_src != TRIG_TIMER))
 		err |= -EINVAL;
 
 	if (err)
@@ -1987,9 +1987,8 @@ static int pci230_ai_inttrig_convert(struct comedi_device *dev,
 		 * bit has a different meaning when FIFO enabled (and when
 		 * FIFO not enabled, it only works for software triggers).
 		 */
-		if (((devpriv->adccon & PCI230_ADC_IM_MASK)
-		     == PCI230_ADC_IM_DIF)
-		    && (devpriv->hwver == 0)) {
+		if (((devpriv->adccon & PCI230_ADC_IM_MASK) ==
+		     PCI230_ADC_IM_DIF) && (devpriv->hwver == 0)) {
 			/* PCI230/260 in differential mode */
 			delayus = 8;
 		} else {
@@ -2263,8 +2262,8 @@ static void pci230_handle_ai(struct comedi_device *dev,
 		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	} else if (devpriv->ai_scan_count == 0) {
 		todo = 0;
-	} else if ((devpriv->ai_scan_count > PCI230_ADC_FIFOLEVEL_HALFFULL)
-		   || (scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL)) {
+	} else if ((devpriv->ai_scan_count > PCI230_ADC_FIFOLEVEL_HALFFULL) ||
+		   (scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL)) {
 		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	} else {
 		todo = (devpriv->ai_scan_count * scanlen)
@@ -2761,8 +2760,8 @@ static int pci230_attach_common(struct comedi_device *dev,
 				 */
 				extfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;
 			}
-			if ((thisboard->ao_chans > 0)
-			    && (devpriv->hwver >= 2)) {
+			if ((thisboard->ao_chans > 0) &&
+			    (devpriv->hwver >= 2)) {
 				/* Enable DAC FIFO functionality. */
 				extfunc |= PCI230P2_EXTFUNC_DACFIFO;
 			}

commit 1446b44bedfd09a11ae97b58932fec7775f4bae1
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:10 2014 +0100

    staging: comedi: amplc_pci230: fix checkpatch line over 80 characters
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index cb86d04a3173..c6c3c4ae2263 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -664,10 +664,8 @@ static inline void pci230_ao_write_nofifo(struct comedi_device *dev,
 	devpriv->ao_readback[chan] = datum;
 
 	/* Write mangled datum to appropriate DACOUT register. */
-	outw(pci230_ao_mangle_datum(dev, datum), dev->iobase + (((chan) == 0)
-								? PCI230_DACOUT1
-								:
-								PCI230_DACOUT2));
+	outw(pci230_ao_mangle_datum(dev, datum),
+	     dev->iobase + (((chan) == 0) ? PCI230_DACOUT1 : PCI230_DACOUT2));
 }
 
 static inline void pci230_ao_write_fifo(struct comedi_device *dev,

commit 0af871dbb77d8530bfd12fa8690af8d71feb212f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 29 12:58:09 2014 +0100

    staging: comedi: amplc_pci230: reformat a load of comments
    
    Reformat a load of comments to fit in with the preferred coding style,
    including the copyright and driver description comments at the top of
    the file.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a61d9904d970..cb86d04a3173 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1,188 +1,189 @@
- /*
-    comedi/drivers/amplc_pci230.c
-    Driver for Amplicon PCI230 and PCI260 Multifunction I/O boards.
-
-    Copyright (C) 2001 Allan Willcox <allanwillcox@ozemail.com.au>
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
+/*
+ * comedi/drivers/amplc_pci230.c
+ * Driver for Amplicon PCI230 and PCI260 Multifunction I/O boards.
+ *
+ * Copyright (C) 2001 Allan Willcox <allanwillcox@ozemail.com.au>
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-  */
 /*
-Driver: amplc_pci230
-Description: Amplicon PCI230, PCI260 Multifunction I/O boards
-Author: Allan Willcox <allanwillcox@ozemail.com.au>,
-  Steve D Sharples <steve.sharples@nottingham.ac.uk>,
-  Ian Abbott <abbotti@mev.co.uk>
-Updated: Wed, 22 Oct 2008 12:34:49 +0100
-Devices: [Amplicon] PCI230 (pci230 or amplc_pci230),
-  PCI230+ (pci230+ or amplc_pci230),
-  PCI260 (pci260 or amplc_pci230), PCI260+ (pci260+ or amplc_pci230)
-Status: works
-
-Configuration options:
-  [0] - PCI bus of device (optional).
-  [1] - PCI slot of device (optional).
-          If bus/slot is not specified, the first available PCI device
-          will be used.
-
-Configuring a "amplc_pci230" will match any supported card and it will
-choose the best match, picking the "+" models if possible.  Configuring
-a "pci230" will match a PCI230 or PCI230+ card and it will be treated as
-a PCI230.  Configuring a "pci260" will match a PCI260 or PCI260+ card
-and it will be treated as a PCI260.  Configuring a "pci230+" will match
-a PCI230+ card.  Configuring a "pci260+" will match a PCI260+ card.
-
-Subdevices:
-
-                PCI230(+)    PCI260(+)
-                ---------    ---------
-  Subdevices       3            1
-        0          AI           AI
-	1          AO
-	2          DIO
-
-AI Subdevice:
-
-  The AI subdevice has 16 single-ended channels or 8 differential
-  channels.
-
-  The PCI230 and PCI260 cards have 12-bit resolution.  The PCI230+ and
-  PCI260+ cards have 16-bit resolution.
-
-  For differential mode, use inputs 2N and 2N+1 for channel N (e.g. use
-  inputs 14 and 15 for channel 7).  If the card is physically a PCI230
-  or PCI260 then it actually uses a "pseudo-differential" mode where the
-  inputs are sampled a few microseconds apart.  The PCI230+ and PCI260+
-  use true differential sampling.  Another difference is that if the
-  card is physically a PCI230 or PCI260, the inverting input is 2N,
-  whereas for a PCI230+ or PCI260+ the inverting input is 2N+1.  So if a
-  PCI230 is physically replaced by a PCI230+ (or a PCI260 with a
-  PCI260+) and differential mode is used, the differential inputs need
-  to be physically swapped on the connector.
-
-  The following input ranges are supported:
-
-    0 => [-10, +10] V
-    1 => [-5, +5] V
-    2 => [-2.5, +2.5] V
-    3 => [-1.25, +1.25] V
-    4 => [0, 10] V
-    5 => [0, 5] V
-    6 => [0, 2.5] V
-
-AI Commands:
-
-  +=========+==============+===========+============+==========+
-  |start_src|scan_begin_src|convert_src|scan_end_src| stop_src |
-  +=========+==============+===========+============+==========+
-  |TRIG_NOW | TRIG_FOLLOW  |TRIG_TIMER | TRIG_COUNT |TRIG_NONE |
-  |TRIG_INT |              |TRIG_EXT(3)|            |TRIG_COUNT|
-  |         |              |TRIG_INT   |            |          |
-  |         |--------------|-----------|            |          |
-  |         | TRIG_TIMER(1)|TRIG_TIMER |            |          |
-  |         | TRIG_EXT(2)  |           |            |          |
-  |         | TRIG_INT     |           |            |          |
-  +---------+--------------+-----------+------------+----------+
-
-  Note 1: If AI command and AO command are used simultaneously, only
-          one may have scan_begin_src == TRIG_TIMER.
-
-  Note 2: For PCI230 and PCI230+, scan_begin_src == TRIG_EXT uses
-          DIO channel 16 (pin 49) which will need to be configured as
-          a digital input.  For PCI260+, the EXTTRIG/EXTCONVCLK input
-          (pin 17) is used instead.  For PCI230, scan_begin_src ==
-          TRIG_EXT is not supported.  The trigger is a rising edge
-          on the input.
-
-  Note 3: For convert_src == TRIG_EXT, the EXTTRIG/EXTCONVCLK input
-          (pin 25 on PCI230(+), pin 17 on PCI260(+)) is used.  The
-          convert_arg value is interpreted as follows:
-
-            convert_arg == (CR_EDGE | 0) => rising edge
-            convert_arg == (CR_EDGE | CR_INVERT | 0) => falling edge
-            convert_arg == 0 => falling edge (backwards compatibility)
-            convert_arg == 1 => rising edge (backwards compatibility)
-
-  All entries in the channel list must use the same analogue reference.
-  If the analogue reference is not AREF_DIFF (not differential) each
-  pair of channel numbers (0 and 1, 2 and 3, etc.) must use the same
-  input range.  The input ranges used in the sequence must be all
-  bipolar (ranges 0 to 3) or all unipolar (ranges 4 to 6).  The channel
-  sequence must consist of 1 or more identical subsequences.  Within the
-  subsequence, channels must be in ascending order with no repeated
-  channels.  For example, the following sequences are valid: 0 1 2 3
-  (single valid subsequence), 0 2 3 5 0 2 3 5 (repeated valid
-  subsequence), 1 1 1 1 (repeated valid subsequence).  The following
-  sequences are invalid: 0 3 2 1 (invalid subsequence), 0 2 3 5 0 2 3
-  (incompletely repeated subsequence).  Some versions of the PCI230+ and
-  PCI260+ have a bug that requires a subsequence longer than one entry
-  long to include channel 0.
-
-AO Subdevice:
-
-  The AO subdevice has 2 channels with 12-bit resolution.
-
-  The following output ranges are supported:
-
-    0 => [0, 10] V
-    1 => [-10, +10] V
-
-AO Commands:
-
-  +=========+==============+===========+============+==========+
-  |start_src|scan_begin_src|convert_src|scan_end_src| stop_src |
-  +=========+==============+===========+============+==========+
-  |TRIG_INT | TRIG_TIMER(1)| TRIG_NOW  | TRIG_COUNT |TRIG_NONE |
-  |         | TRIG_EXT(2)  |           |            |TRIG_COUNT|
-  |         | TRIG_INT     |           |            |          |
-  +---------+--------------+-----------+------------+----------+
-
-  Note 1: If AI command and AO command are used simultaneously, only
-          one may have scan_begin_src == TRIG_TIMER.
-
-  Note 2: scan_begin_src == TRIG_EXT is only supported if the card is
-          configured as a PCI230+ and is only supported on later
-          versions of the card.  As a card configured as a PCI230+ is
-          not guaranteed to support external triggering, please consider
-          this support to be a bonus.  It uses the EXTTRIG/ EXTCONVCLK
-          input (PCI230+ pin 25).  Triggering will be on the rising edge
-          unless the CR_INVERT flag is set in scan_begin_arg.
-
-  The channels in the channel sequence must be in ascending order with
-  no repeats.  All entries in the channel sequence must use the same
-  output range.
-
-DIO Subdevice:
-
-  The DIO subdevice is a 8255 chip providing 24 DIO channels.  The DIO
-  channels are configurable as inputs or outputs in four groups:
-
-    Port A  - channels  0 to  7
-    Port B  - channels  8 to 15
-    Port CL - channels 16 to 19
-    Port CH - channels 20 to 23
-
-  Only mode 0 of the 8255 chip is supported.
-
-  Bit 0 of port C (DIO channel 16) is also used as an external scan
-  trigger input for AI commands on PCI230 and PCI230+, so would need to
-  be configured as an input to use it for that purpose.
-*/
+ * Driver: amplc_pci230
+ * Description: Amplicon PCI230, PCI260 Multifunction I/O boards
+ * Author: Allan Willcox <allanwillcox@ozemail.com.au>,
+ *   Steve D Sharples <steve.sharples@nottingham.ac.uk>,
+ *   Ian Abbott <abbotti@mev.co.uk>
+ * Updated: Wed, 22 Oct 2008 12:34:49 +0100
+ * Devices: [Amplicon] PCI230 (pci230 or amplc_pci230),
+ *   PCI230+ (pci230+ or amplc_pci230),
+ *   PCI260 (pci260 or amplc_pci230), PCI260+ (pci260+ or amplc_pci230)
+ * Status: works
+ *
+ * Configuration options:
+ *   [0] - PCI bus of device (optional).
+ *   [1] - PCI slot of device (optional).
+ *           If bus/slot is not specified, the first available PCI device
+ *           will be used.
+ *
+ * Configuring a "amplc_pci230" will match any supported card and it will
+ * choose the best match, picking the "+" models if possible.  Configuring
+ * a "pci230" will match a PCI230 or PCI230+ card and it will be treated as
+ * a PCI230.  Configuring a "pci260" will match a PCI260 or PCI260+ card
+ * and it will be treated as a PCI260.  Configuring a "pci230+" will match
+ * a PCI230+ card.  Configuring a "pci260+" will match a PCI260+ card.
+ *
+ * Subdevices:
+ *
+ *                 PCI230(+)    PCI260(+)
+ *                 ---------    ---------
+ *   Subdevices       3            1
+ *         0          AI           AI
+ *         1          AO
+ *         2          DIO
+ *
+ * AI Subdevice:
+ *
+ *   The AI subdevice has 16 single-ended channels or 8 differential
+ *   channels.
+ *
+ *   The PCI230 and PCI260 cards have 12-bit resolution.  The PCI230+ and
+ *   PCI260+ cards have 16-bit resolution.
+ *
+ *   For differential mode, use inputs 2N and 2N+1 for channel N (e.g. use
+ *   inputs 14 and 15 for channel 7).  If the card is physically a PCI230
+ *   or PCI260 then it actually uses a "pseudo-differential" mode where the
+ *   inputs are sampled a few microseconds apart.  The PCI230+ and PCI260+
+ *   use true differential sampling.  Another difference is that if the
+ *   card is physically a PCI230 or PCI260, the inverting input is 2N,
+ *   whereas for a PCI230+ or PCI260+ the inverting input is 2N+1.  So if a
+ *   PCI230 is physically replaced by a PCI230+ (or a PCI260 with a
+ *   PCI260+) and differential mode is used, the differential inputs need
+ *   to be physically swapped on the connector.
+ *
+ *   The following input ranges are supported:
+ *
+ *     0 => [-10, +10] V
+ *     1 => [-5, +5] V
+ *     2 => [-2.5, +2.5] V
+ *     3 => [-1.25, +1.25] V
+ *     4 => [0, 10] V
+ *     5 => [0, 5] V
+ *     6 => [0, 2.5] V
+ *
+ * AI Commands:
+ *
+ *   +=========+==============+===========+============+==========+
+ *   |start_src|scan_begin_src|convert_src|scan_end_src| stop_src |
+ *   +=========+==============+===========+============+==========+
+ *   |TRIG_NOW | TRIG_FOLLOW  |TRIG_TIMER | TRIG_COUNT |TRIG_NONE |
+ *   |TRIG_INT |              |TRIG_EXT(3)|            |TRIG_COUNT|
+ *   |         |              |TRIG_INT   |            |          |
+ *   |         |--------------|-----------|            |          |
+ *   |         | TRIG_TIMER(1)|TRIG_TIMER |            |          |
+ *   |         | TRIG_EXT(2)  |           |            |          |
+ *   |         | TRIG_INT     |           |            |          |
+ *   +---------+--------------+-----------+------------+----------+
+ *
+ *   Note 1: If AI command and AO command are used simultaneously, only
+ *           one may have scan_begin_src == TRIG_TIMER.
+ *
+ *   Note 2: For PCI230 and PCI230+, scan_begin_src == TRIG_EXT uses
+ *           DIO channel 16 (pin 49) which will need to be configured as
+ *           a digital input.  For PCI260+, the EXTTRIG/EXTCONVCLK input
+ *           (pin 17) is used instead.  For PCI230, scan_begin_src ==
+ *           TRIG_EXT is not supported.  The trigger is a rising edge
+ *           on the input.
+ *
+ *   Note 3: For convert_src == TRIG_EXT, the EXTTRIG/EXTCONVCLK input
+ *           (pin 25 on PCI230(+), pin 17 on PCI260(+)) is used.  The
+ *           convert_arg value is interpreted as follows:
+ *
+ *             convert_arg == (CR_EDGE | 0) => rising edge
+ *             convert_arg == (CR_EDGE | CR_INVERT | 0) => falling edge
+ *             convert_arg == 0 => falling edge (backwards compatibility)
+ *             convert_arg == 1 => rising edge (backwards compatibility)
+ *
+ *   All entries in the channel list must use the same analogue reference.
+ *   If the analogue reference is not AREF_DIFF (not differential) each
+ *   pair of channel numbers (0 and 1, 2 and 3, etc.) must use the same
+ *   input range.  The input ranges used in the sequence must be all
+ *   bipolar (ranges 0 to 3) or all unipolar (ranges 4 to 6).  The channel
+ *   sequence must consist of 1 or more identical subsequences.  Within the
+ *   subsequence, channels must be in ascending order with no repeated
+ *   channels.  For example, the following sequences are valid: 0 1 2 3
+ *   (single valid subsequence), 0 2 3 5 0 2 3 5 (repeated valid
+ *   subsequence), 1 1 1 1 (repeated valid subsequence).  The following
+ *   sequences are invalid: 0 3 2 1 (invalid subsequence), 0 2 3 5 0 2 3
+ *   (incompletely repeated subsequence).  Some versions of the PCI230+ and
+ *   PCI260+ have a bug that requires a subsequence longer than one entry
+ *   long to include channel 0.
+ *
+ * AO Subdevice:
+ *
+ *   The AO subdevice has 2 channels with 12-bit resolution.
+ *   The following output ranges are supported:
+ *     0 => [0, 10] V
+ *     1 => [-10, +10] V
+ *
+ * AO Commands:
+ *
+ *   +=========+==============+===========+============+==========+
+ *   |start_src|scan_begin_src|convert_src|scan_end_src| stop_src |
+ *   +=========+==============+===========+============+==========+
+ *   |TRIG_INT | TRIG_TIMER(1)| TRIG_NOW  | TRIG_COUNT |TRIG_NONE |
+ *   |         | TRIG_EXT(2)  |           |            |TRIG_COUNT|
+ *   |         | TRIG_INT     |           |            |          |
+ *   +---------+--------------+-----------+------------+----------+
+ *
+ *   Note 1: If AI command and AO command are used simultaneously, only
+ *           one may have scan_begin_src == TRIG_TIMER.
+ *
+ *   Note 2: scan_begin_src == TRIG_EXT is only supported if the card is
+ *           configured as a PCI230+ and is only supported on later
+ *           versions of the card.  As a card configured as a PCI230+ is
+ *           not guaranteed to support external triggering, please consider
+ *           this support to be a bonus.  It uses the EXTTRIG/ EXTCONVCLK
+ *           input (PCI230+ pin 25).  Triggering will be on the rising edge
+ *           unless the CR_INVERT flag is set in scan_begin_arg.
+ *
+ *   The channels in the channel sequence must be in ascending order with
+ *   no repeats.  All entries in the channel sequence must use the same
+ *   output range.
+ *
+ * DIO Subdevice:
+ *
+ *   The DIO subdevice is a 8255 chip providing 24 DIO channels.  The DIO
+ *   channels are configurable as inputs or outputs in four groups:
+ *
+ *     Port A  - channels  0 to  7
+ *     Port B  - channels  8 to 15
+ *     Port CL - channels 16 to 19
+ *     Port CH - channels 20 to 23
+ *
+ *   Only mode 0 of the 8255 chip is supported.
+ *
+ *   Bit 0 of port C (DIO channel 16) is also used as an external scan
+ *   trigger input for AI commands on PCI230 and PCI230+, so would need to
+ *   be configured as an input to use it for that purpose.
+ */
+
 /*
-Extra triggered scan functionality, interrupt bug-fix added by Steve Sharples.
-Support for PCI230+/260+, more triggered scan functionality, and workarounds
-for (or detection of) various hardware problems added by Ian Abbott.
-*/
+ * Extra triggered scan functionality, interrupt bug-fix added by Steve
+ * Sharples.  Support for PCI230+/260+, more triggered scan functionality,
+ * and workarounds for (or detection of) various hardware problems added
+ * by Ian Abbott.
+ */
 
 #include <linux/module.h>
 #include <linux/pci.h>
@@ -195,12 +196,16 @@ for (or detection of) various hardware problems added by Ian Abbott.
 #include "8253.h"
 #include "8255.h"
 
-/* PCI230 PCI configuration register information */
+/*
+ * PCI230 PCI configuration register information
+ */
 #define PCI_DEVICE_ID_PCI230 0x0000
 #define PCI_DEVICE_ID_PCI260 0x0006
 #define PCI_DEVICE_ID_INVALID 0xffff
 
-/* PCI230 i/o space 1 registers. */
+/*
+ * PCI230 i/o space 1 registers.
+ */
 #define PCI230_PPI_X_BASE	0x00	/* User PPI (82C55) base */
 #define PCI230_PPI_X_A		0x00	/* User PPI (82C55) port A */
 #define PCI230_PPI_X_B		0x01	/* User PPI (82C55) port B */
@@ -216,7 +221,9 @@ for (or detection of) various hardware problems added by Ian Abbott.
 #define PCI230_INT_SCE		0x1E	/* Interrupt source mask (w) */
 #define PCI230_INT_STAT		0x1E	/* Interrupt status (r) */
 
-/* PCI230 i/o space 2 registers. */
+/*
+ * PCI230 i/o space 2 registers.
+ */
 #define PCI230_DACCON		0x00	/* DAC control */
 #define PCI230_DACOUT1		0x02	/* DAC channel 0 (w) */
 #define PCI230_DACOUT2		0x04	/* DAC channel 1 (w) (not FIFO mode) */
@@ -239,24 +246,34 @@ for (or detection of) various hardware problems added by Ian Abbott.
 #define PCI230P2_DACSWTRIG	0x02	/* DAC soft trigger (FIFO mode) (r) */
 #define PCI230P2_DACEN		0x06	/* DAC channel enable (FIFO mode) */
 
-/* Convertor related constants. */
-#define PCI230_DAC_SETTLE 5	/* Analogue output settling time in s */
-				/* (DAC itself is 1s nominally). */
-#define PCI230_ADC_SETTLE 1	/* Analogue input settling time in s */
-				/* (ADC itself is 1.6s nominally but we poll
-				 * anyway). */
-#define PCI230_MUX_SETTLE 10	/* ADC MUX settling time in S */
-				/* - 10s for se, 20s de. */
+/*
+ * Convertor related constants.
+ */
+/* Analogue output settling time in s (DAC itself is 1s nominally). */
+#define PCI230_DAC_SETTLE 5
+/*
+ * Analogue input settling time in s (ADC itself is 1.6s nominally but we
+ * poll anyway).
+ */
+#define PCI230_ADC_SETTLE 1
+/* ADC MUX settling time in S - 10s for se, 20s de. */
+#define PCI230_MUX_SETTLE 10
 
-/* DACCON read-write values. */
+/*
+ * DACCON read-write values.
+ */
 #define PCI230_DAC_OR_UNI		(0<<0)	/* Output range unipolar */
 #define PCI230_DAC_OR_BIP		(1<<0)	/* Output range bipolar */
 #define PCI230_DAC_OR_MASK		(1<<0)
-/* The following applies only if DAC FIFO support is enabled in the EXTFUNC
- * register (and only for PCI230+ hardware version 2 onwards). */
+/*
+ * The following applies only if DAC FIFO support is enabled in the EXTFUNC
+ * register (and only for PCI230+ hardware version 2 onwards).
+ */
 #define PCI230P2_DAC_FIFO_EN		(1<<8)	/* FIFO enable */
-/* The following apply only if the DAC FIFO is enabled (and only for PCI230+
- * hardware version 2 onwards). */
+/*
+ * The following apply only if the DAC FIFO is enabled (and only for PCI230+
+ * hardware version 2 onwards).
+ */
 #define PCI230P2_DAC_TRIG_NONE		(0<<2)	/* No trigger */
 #define PCI230P2_DAC_TRIG_SW		(1<<2)	/* Software trigger trigger */
 #define PCI230P2_DAC_TRIG_EXTP		(2<<2)	/* EXTTRIG +ve edge trigger */
@@ -274,22 +291,32 @@ for (or detection of) various hardware problems added by Ian Abbott.
 #define PCI230P2_DAC_INT_FIFO_FULL	(5<<9)
 #define PCI230P2_DAC_INT_FIFO_MASK	(7<<9)
 
-/* DACCON read-only values. */
+/*
+ * DACCON read-only values.
+ */
 #define PCI230_DAC_BUSY			(1<<1)	/* DAC busy. */
-/* The following apply only if the DAC FIFO is enabled (and only for PCI230+
- * hardware version 2 onwards). */
+/*
+ * The following apply only if the DAC FIFO is enabled (and only for PCI230+
+ * hardware version 2 onwards).
+ */
 #define PCI230P2_DAC_FIFO_UNDERRUN_LATCHED	(1<<5)	/* Underrun error */
 #define PCI230P2_DAC_FIFO_EMPTY		(1<<13)	/* FIFO empty */
 #define PCI230P2_DAC_FIFO_FULL		(1<<14)	/* FIFO full */
 #define PCI230P2_DAC_FIFO_HALF		(1<<15)	/* FIFO half full */
 
-/* DACCON write-only, transient values. */
-/* The following apply only if the DAC FIFO is enabled (and only for PCI230+
- * hardware version 2 onwards). */
+/*
+ * DACCON write-only, transient values.
+ */
+/*
+ * The following apply only if the DAC FIFO is enabled (and only for PCI230+
+ * hardware version 2 onwards).
+ */
 #define PCI230P2_DAC_FIFO_UNDERRUN_CLEAR	(1<<5)	/* Clear underrun */
 #define PCI230P2_DAC_FIFO_RESET		(1<<12)	/* FIFO reset */
 
-/* PCI230+ hardware version 2 DAC FIFO levels. */
+/*
+ * PCI230+ hardware version 2 DAC FIFO levels.
+ */
 #define PCI230P2_DAC_FIFOLEVEL_HALF	512
 #define PCI230P2_DAC_FIFOLEVEL_FULL	1024
 /* Free space in DAC FIFO. */
@@ -299,7 +326,9 @@ for (or detection of) various hardware problems added by Ian Abbott.
 #define PCI230P2_DAC_FIFOROOM_HALFTOFULL	1
 #define PCI230P2_DAC_FIFOROOM_FULL		0
 
-/* ADCCON read/write values. */
+/*
+ * ADCCON read/write values.
+ */
 #define PCI230_ADC_TRIG_NONE		(0<<0)	/* No trigger */
 #define PCI230_ADC_TRIG_SW		(1<<0)	/* Software trigger trigger */
 #define PCI230_ADC_TRIG_EXTP		(2<<0)	/* EXTTRIG +ve edge trigger */
@@ -324,31 +353,41 @@ for (or detection of) various hardware problems added by Ian Abbott.
 #define PCI230P_ADC_INT_FIFO_THRESH	(7<<9)	/* FIFO interrupt threshold */
 #define PCI230_ADC_INT_FIFO_MASK	(7<<9)
 
-/* ADCCON write-only, transient values. */
+/*
+ * ADCCON write-only, transient values.
+ */
 #define PCI230_ADC_FIFO_RESET		(1<<12)	/* FIFO reset */
 #define PCI230_ADC_GLOB_RESET		(1<<13)	/* Global reset */
 
-/* ADCCON read-only values. */
+/*
+ * ADCCON read-only values.
+ */
 #define PCI230_ADC_BUSY			(1<<15)	/* ADC busy */
 #define PCI230_ADC_FIFO_EMPTY		(1<<12)	/* FIFO empty */
 #define PCI230_ADC_FIFO_FULL		(1<<13)	/* FIFO full */
 #define PCI230_ADC_FIFO_HALF		(1<<14)	/* FIFO half full */
 #define PCI230_ADC_FIFO_FULL_LATCHED	(1<<5)	/* Indicates overrun occurred */
 
-/* PCI230 ADC FIFO levels. */
+/*
+ * PCI230 ADC FIFO levels.
+ */
 #define PCI230_ADC_FIFOLEVEL_HALFFULL	2049	/* Value for FIFO half full */
 #define PCI230_ADC_FIFOLEVEL_FULL	4096	/* FIFO size */
 
-/* Value to write to ADCSWTRIG to trigger ADC conversion in software trigger
- * mode.  Can be anything.  */
+/*
+ * Value to write to ADCSWTRIG to trigger ADC conversion in software trigger
+ * mode.  Can be anything.
+ */
 #define PCI230_ADC_CONV			0xffff
 
-/* PCI230+ EXTFUNC values. */
+/*
+ * PCI230+ EXTFUNC values.
+ */
+/* Route EXTTRIG pin to external gate inputs. */
 #define PCI230P_EXTFUNC_GAT_EXTTRIG	(1<<0)
-			/* Route EXTTRIG pin to external gate inputs. */
 /* PCI230+ hardware version 2 values. */
+/* Allow DAC FIFO to be enabled. */
 #define PCI230P2_EXTFUNC_DACFIFO	(1<<1)
-			/* Allow DAC FIFO to be enabled. */
 
 /*
  * Counter/timer clock input configuration sources.
@@ -392,7 +431,9 @@ for (or detection of) various hardware problems added by Ian Abbott.
  * Z2-CT2       Z2-CT1-OUT      /Z2-CT0-OUT
  */
 
-/* Interrupt enables/status register values. */
+/*
+ * Interrupt enables/status register values.
+ */
 #define PCI230_INT_DISABLE		0
 #define PCI230_INT_PPI_C0		(1<<0)
 #define PCI230_INT_PPI_C3		(1<<1)
@@ -401,10 +442,12 @@ for (or detection of) various hardware problems added by Ian Abbott.
 /* For PCI230+ hardware version 2 when DAC FIFO enabled. */
 #define PCI230P2_INT_DAC		(1<<4)
 
+/* Assumes bits numbered with zero offset, ie. 0-15 */
 #define PCI230_TEST_BIT(val, n)	((val>>n)&1)
-			/* Assumes bits numbered with zero offset, ie. 0-15 */
 
-/* (Potentially) shared resources and their owners */
+/*
+ * (Potentially) shared resources and their owners
+ */
 enum {
 	RES_Z2CT0,		/* Z2-CT0 */
 	RES_Z2CT1,		/* Z2-CT1 */
@@ -491,9 +534,11 @@ static const struct pci230_board pci230_boards[] = {
 	 },
 };
 
-/* this structure is for data unique to this hardware driver.  If
-   several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the struct comedi_device struct.  */
+/*
+ * This structure is for data unique to this hardware driver.  If
+ * several hardware drivers keep similar information in this structure,
+ * feel free to suggest moving the variable to the struct comedi_device struct.
+ */
 struct pci230_private {
 	spinlock_t isr_spinlock;	/* Interrupt spin lock */
 	spinlock_t res_spinlock;	/* Shared resources spin lock */
@@ -502,24 +547,24 @@ struct pci230_private {
 	unsigned long state;	/* State flags */
 	unsigned long iobase1;	/* PCI230's I/O space 1 */
 	unsigned int ao_readback[2];	/* Used for AO readback */
-	unsigned int ai_scan_count;	/* Number of analogue input scans
-					 * remaining.  */
-	unsigned int ai_scan_pos;	/* Current position within analogue
-					 * input scan */
-	unsigned int ao_scan_count;	/* Number of analogue output scans
-					 * remaining.  */
+	/* Number of analogue input scans remaining.  */
+	unsigned int ai_scan_count;
+	/* Current position within analogue input scan */
+	unsigned int ai_scan_pos;
+	/* Number of analogue output scans remaining.  */
+	unsigned int ao_scan_count;
 	int intr_cpuid;		/* ID of CPU running interrupt routine. */
 	unsigned short hwver;	/* Hardware version (for '+' models). */
 	unsigned short adccon;	/* ADCCON register value. */
 	unsigned short daccon;	/* DACCON register value. */
-	unsigned short adcfifothresh;	/* ADC FIFO programmable interrupt
-					 * level threshold (PCI230+/260+). */
+	/* ADC FIFO programmable interrupt level threshold (PCI230+/260+). */
+	unsigned short adcfifothresh;
 	unsigned short adcg;	/* ADCG register value. */
 	unsigned char int_en;	/* Interrupt enables bits. */
-	unsigned char ai_bipolar;	/* Set if bipolar input range so we
-					 * know to mangle it. */
-	unsigned char ao_bipolar;	/* Set if bipolar output range so we
-					 * know to mangle it. */
+	/* Set if bipolar input range so we know to mangle it. */
+	unsigned char ai_bipolar;
+	/* Set if bipolar output range so we know to mangle it. */
+	unsigned char ao_bipolar;
 	unsigned char ier;	/* Copy of interrupt enables/status register. */
 	unsigned char intr_running;	/* Flag set in interrupt routine. */
 	unsigned char res_owner[NUM_RESOURCES];	/* Shared resource owners. */
@@ -572,13 +617,16 @@ static unsigned short pci230_ai_read(struct comedi_device *dev)
 
 	/* Read sample. */
 	data = inw(dev->iobase + PCI230_ADCDATA);
-	/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
-	 * four bits reserved for expansion). */
-	/* PCI230+ is 16 bit AI. */
+	/*
+	 * PCI230 is 12 bit - stored in upper bits of 16 bit register
+	 * (lower four bits reserved for expansion).  PCI230+ is 16 bit AI.
+	 */
 	data = data >> (16 - thisboard->ai_bits);
 
-	/* If a bipolar range was specified, mangle it (twos
-	 * complement->straight binary). */
+	/*
+	 * If a bipolar range was specified, mangle it
+	 * (twos complement->straight binary).
+	 */
 	if (devpriv->ai_bipolar)
 		data ^= 1 << (thisboard->ai_bits - 1);
 
@@ -591,14 +639,17 @@ static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
 	const struct pci230_board *thisboard = comedi_board(dev);
 	struct pci230_private *devpriv = dev->private;
 
-	/* If a bipolar range was specified, mangle it (straight binary->twos
-	 * complement). */
+	/*
+	 * If a bipolar range was specified, mangle it
+	 * (straight binary->twos complement).
+	 */
 	if (devpriv->ao_bipolar)
 		datum ^= 1 << (thisboard->ao_bits - 1);
 
-	/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
-	 * four bits reserved for expansion). */
-	/* PCI230+ is also 12 bit AO. */
+	/*
+	 * PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
+	 * four bits reserved for expansion).  PCI230+ is also 12 bit AO.
+	 */
 	datum <<= (16 - thisboard->ao_bits);
 	return datum;
 }
@@ -730,8 +781,10 @@ static unsigned int divide_ns(uint64_t ns, unsigned int timebase,
 	return div > UINT_MAX ? UINT_MAX : (unsigned int)div;
 }
 
-/* Given desired period in ns, returns the required internal clock source
- * and gets the initial count. */
+/*
+ * Given desired period in ns, returns the required internal clock source
+ * and gets the initial count.
+ */
 static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
 					    unsigned int flags)
 {
@@ -824,7 +877,8 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 		}
 	}
 
-	/* Use Z2-CT2 as a conversion trigger instead of the built-in
+	/*
+	 * Use Z2-CT2 as a conversion trigger instead of the built-in
 	 * software trigger, as otherwise triggering of differential channels
 	 * doesn't work properly for some versions of PCI230/260.  Also set
 	 * FIFO mode because the ADC busy bit only works for software triggers.
@@ -837,12 +891,16 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 		/* Differential. */
 		gainshift = chan * 2;
 		if (devpriv->hwver == 0) {
-			/* Original PCI230/260 expects both inputs of the
-			 * differential channel to be enabled. */
+			/*
+			 * Original PCI230/260 expects both inputs of the
+			 * differential channel to be enabled.
+			 */
 			adcen = 3 << gainshift;
 		} else {
-			/* PCI230+/260+ expects only one input of the
-			 * differential channel to be enabled. */
+			/*
+			 * PCI230+/260+ expects only one input of the
+			 * differential channel to be enabled.
+			 */
 			adcen = 1 << gainshift;
 		}
 		adccon |= PCI230_ADC_IM_DIF;
@@ -860,8 +918,10 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 		adccon |= PCI230_ADC_IR_UNI;
 
 
-	/* Enable only this channel in the scan list - otherwise by default
-	 * we'll get one sample from each channel. */
+	/*
+	 * Enable only this channel in the scan list - otherwise by default
+	 * we'll get one sample from each channel.
+	 */
 	outw(adcen, dev->iobase + PCI230_ADCEN);
 
 	/* Set gain for channel. */
@@ -873,8 +933,10 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 
 	/* Convert n samples */
 	for (n = 0; n < insn->n; n++) {
-		/* Trigger conversion by toggling Z2-CT2 output (finish with
-		 * output high). */
+		/*
+		 * Trigger conversion by toggling Z2-CT2 output
+		 * (finish with output high).
+		 */
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
 			       I8254_MODE0);
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
@@ -908,13 +970,17 @@ static int pci230_ao_winsn(struct comedi_device *dev,
 	chan = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
 
-	/* Set range - see analogue output range table; 0 => unipolar 10V,
-	 * 1 => bipolar +/-10V range scale */
+	/*
+	 * Set range - see analogue output range table; 0 => unipolar 10V,
+	 * 1 => bipolar +/-10V range scale
+	 */
 	devpriv->ao_bipolar = pci230_ao_bipolar[range];
 	outw(range, dev->iobase + PCI230_DACCON);
 
-	/* Writing a list of values to an AO channel is probably not
-	 * very useful, but that's how the interface is defined. */
+	/*
+	 * Writing a list of values to an AO channel is probably not
+	 * very useful, but that's how the interface is defined.
+	 */
 	for (i = 0; i < insn->n; i++) {
 		/* Write value to DAC and store it. */
 		pci230_ao_write_nofifo(dev, data[i], chan);
@@ -924,8 +990,10 @@ static int pci230_ao_winsn(struct comedi_device *dev,
 	return i;
 }
 
-/* AO subdevices should have a read insn as well as a write insn.
- * Usually this means copying a value stored in devpriv. */
+/*
+ * AO subdevices should have a read insn as well as a write insn.
+ * Usually this means copying a value stored in devpriv.
+ */
 static int pci230_ao_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
@@ -1026,10 +1094,11 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
 #define MAX_SPEED_AO	8000	/* 8000 ns => 125 kHz */
+/*
+ * Comedi limit due to unsigned int cmd.  Driver limit =
+ * 2^16 (16bit * counter) * 1000000ns (1kHz onboard clock) = 65.536s
+ */
 #define MIN_SPEED_AO	4294967295u	/* 4294967295ns = 4.29s */
-			/*- Comedi limit due to unsigned int cmd.  Driver limit
-			 * = 2^16 (16bit * counter) * 1000000ns (1kHz onboard
-			 * clock) = 65.536s */
 
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
@@ -1039,15 +1108,19 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 						 MIN_SPEED_AO);
 		break;
 	case TRIG_EXT:
-		/* External trigger - for PCI230+ hardware version 2 onwards. */
+		/*
+		 * External trigger - for PCI230+ hardware version 2 onwards.
+		 */
 		/* Trigger number must be 0. */
 		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      ~CR_FLAGS_MASK);
 			err |= -EINVAL;
 		}
-		/* The only flags allowed are CR_EDGE and CR_INVERT.  The
-		 * CR_EDGE flag is ignored. */
+		/*
+		 * The only flags allowed are CR_EDGE and CR_INVERT.
+		 * The CR_EDGE flag is ignored.
+		 */
 		if ((cmd->scan_begin_arg
 		     & (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
@@ -1069,9 +1142,7 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	/* Step 4: fix up any arguments.
-	 * "argument conflict" returned by comedilib to user mode process
-	 * if this fails. */
+	/* Step 4: fix up any arguments */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
@@ -1120,8 +1191,10 @@ static void pci230_ao_stop(struct comedi_device *dev,
 		/* Using DAC FIFO interrupt. */
 		intsrc = PCI230P2_INT_DAC;
 	}
-	/* Disable interrupt and wait for interrupt routine to finish running
-	 * unless we are called from the interrupt routine. */
+	/*
+	 * Disable interrupt and wait for interrupt routine to finish running
+	 * unless we are called from the interrupt routine.
+	 */
 	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	devpriv->int_en &= ~intsrc;
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
@@ -1134,8 +1207,10 @@ static void pci230_ao_stop(struct comedi_device *dev,
 	}
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 	if (devpriv->hwver >= 2) {
-		/* Using DAC FIFO.  Reset FIFO, clear underrun error,
-		 * disable FIFO. */
+		/*
+		 * Using DAC FIFO.  Reset FIFO, clear underrun error,
+		 * disable FIFO.
+		 */
 		devpriv->daccon &= PCI230_DAC_OR_MASK;
 		outw(devpriv->daccon | PCI230P2_DAC_FIFO_RESET
 		     | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,
@@ -1213,9 +1288,11 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 			dev_err(dev->class_dev, "AO FIFO underrun\n");
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
-		/* Check for buffer underrun if FIFO less than half full
+		/*
+		 * Check for buffer underrun if FIFO less than half full
 		 * (otherwise there will be loads of "DAC FIFO not half full"
-		 * interrupts). */
+		 * interrupts).
+		 */
 		if ((num_scans == 0)
 		    && ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {
 			dev_err(dev->class_dev, "AO buffer underrun\n");
@@ -1251,9 +1328,11 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 		if (cmd->stop_src == TRIG_COUNT) {
 			devpriv->ao_scan_count -= num_scans;
 			if (devpriv->ao_scan_count == 0) {
-				/* All data for the command has been written
+				/*
+				 * All data for the command has been written
 				 * to FIFO.  Set FIFO interrupt trigger level
-				 * to 'empty'. */
+				 * to 'empty'.
+				 */
 				devpriv->daccon = (devpriv->daccon
 						   &
 						   ~PCI230P2_DAC_INT_FIFO_MASK)
@@ -1444,8 +1523,10 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	else	/* TRIG_NONE, user calls cancel */
 		devpriv->ao_scan_count = 0;
 
-	/* Set range - see analogue output range table; 0 => unipolar 10V,
-	 * 1 => bipolar +/-10V range scale */
+	/*
+	 * Set range - see analogue output range table; 0 => unipolar 10V,
+	 * 1 => bipolar +/-10V range scale
+	 */
 	range = CR_RANGE(cmd->chanlist[0]);
 	devpriv->ao_bipolar = pci230_ao_bipolar[range];
 	daccon = devpriv->ao_bipolar ? PCI230_DAC_OR_BIP : PCI230_DAC_OR_UNI;
@@ -1480,9 +1561,11 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	    & ~(PCI230P2_DAC_FIFO_RESET | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		/* Set the counter timer 1 to the specified scan frequency. */
-		/* cmd->scan_begin_arg is sampling period in ns */
-		/* gate it off for now. */
+		/*
+		 * Set the counter timer 1 to the specified scan frequency.
+		 * cmd->scan_begin_arg is sampling period in ns.
+		 * Gate it off for now.
+		 */
 		outb(GAT_CONFIG(1, GAT_GND),
 		     devpriv->iobase1 + PCI230_ZGAT_SCE);
 		pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
@@ -1688,17 +1771,20 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 #define MAX_SPEED_AI_SE		3200	/* PCI230 SE:   3200 ns => 312.5 kHz */
 #define MAX_SPEED_AI_DIFF	8000	/* PCI230 DIFF: 8000 ns => 125 kHz */
 #define MAX_SPEED_AI_PLUS	4000	/* PCI230+:     4000 ns => 250 kHz */
+/*
+ * Comedi limit due to unsigned int cmd.  Driver limit =
+ * 2^16 (16bit * counter) * 1000000ns (1kHz onboard clock) = 65.536s
+ */
 #define MIN_SPEED_AI	4294967295u	/* 4294967295ns = 4.29s */
-			/*- Comedi limit due to unsigned int cmd.  Driver limit
-			 * = 2^16 (16bit * counter) * 1000000ns (1kHz onboard
-			 * clock) = 65.536s */
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		unsigned int max_speed_ai;
 
 		if (devpriv->hwver == 0) {
-			/* PCI230 or PCI260.  Max speed depends whether
-			 * single-ended or pseudo-differential. */
+			/*
+			 * PCI230 or PCI260.  Max speed depends whether
+			 * single-ended or pseudo-differential.
+			 */
 			if (cmd->chanlist && (cmd->chanlist_len > 0)) {
 				/* Peek analogue reference of first channel. */
 				if (CR_AREF(cmd->chanlist[0]) == AREF_DIFF)
@@ -1735,8 +1821,10 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 							   ~CR_FLAGS_MASK);
 				err |= -EINVAL;
 			}
-			/* The only flags allowed are CR_INVERT and CR_EDGE.
-			 * CR_EDGE is required. */
+			/*
+			 * The only flags allowed are CR_INVERT and CR_EDGE.
+			 * CR_EDGE is required.
+			 */
 			if ((cmd->convert_arg & (CR_FLAGS_MASK & ~CR_INVERT))
 			    != CR_EDGE) {
 				/* Set CR_EDGE, preserve CR_INVERT. */
@@ -1747,9 +1835,11 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 				err |= -EINVAL;
 			}
 		} else {
-			/* Backwards compatibility with previous versions. */
-			/* convert_arg == 0 => trigger on -ve edge. */
-			/* convert_arg == 1 => trigger on +ve edge. */
+			/*
+			 * Backwards compatibility with previous versions:
+			 * convert_arg == 0 => trigger on -ve edge.
+			 * convert_arg == 1 => trigger on +ve edge.
+			 */
 			err |= cfc_check_trigger_arg_max(&cmd->convert_arg, 1);
 		}
 	} else {
@@ -1762,9 +1852,11 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_EXT) {
-		/* external "trigger" to begin each scan
+		/*
+		 * external "trigger" to begin each scan:
 		 * scan_begin_arg==0 => use PPC0 input -> gate of CT0 -> gate
-		 * of CT2 (sample convert trigger is CT2) */
+		 * of CT2 (sample convert trigger is CT2)
+		 */
 		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      ~CR_FLAGS_MASK);
@@ -1788,9 +1880,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	/* Step 4: fix up any arguments.
-	 * "argument conflict" returned by comedilib to user mode process
-	 * if this fails. */
+	/* Step 4: fix up any arguments */
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
@@ -1884,17 +1974,21 @@ static int pci230_ai_inttrig_convert(struct comedi_device *dev,
 	if (test_bit(AI_CMD_STARTED, &devpriv->state)) {
 		unsigned int delayus;
 
-		/* Trigger conversion by toggling Z2-CT2 output.  Finish
-		 * with output high. */
+		/*
+		 * Trigger conversion by toggling Z2-CT2 output.
+		 * Finish with output high.
+		 */
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
 			       I8254_MODE0);
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
 			       I8254_MODE1);
-		/* Delay.  Should driver be responsible for this?  An
+		/*
+		 * Delay.  Should driver be responsible for this?  An
 		 * alternative would be to wait until conversion is complete,
 		 * but we can't tell when it's complete because the ADC busy
 		 * bit has a different meaning when FIFO enabled (and when
-		 * FIFO not enabled, it only works for software triggers). */
+		 * FIFO not enabled, it only works for software triggers).
+		 */
 		if (((devpriv->adccon & PCI230_ADC_IM_MASK)
 		     == PCI230_ADC_IM_DIF)
 		    && (devpriv->hwver == 0)) {
@@ -1960,8 +2054,10 @@ static void pci230_ai_stop(struct comedi_device *dev,
 		pci230_cancel_ct(dev, 0);
 	}
 	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-	/* Disable ADC interrupt and wait for interrupt routine to finish
-	 * running unless we are called from the interrupt routine. */
+	/*
+	 * Disable ADC interrupt and wait for interrupt routine to finish
+	 * running unless we are called from the interrupt routine.
+	 */
 	devpriv->int_en &= ~PCI230_INT_ADC;
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
 		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
@@ -1972,8 +2068,10 @@ static void pci230_ai_stop(struct comedi_device *dev,
 		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 	}
 	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
-	/* Reset FIFO, disable FIFO and set start conversion source to none.
-	 * Keep se/diff and bip/uni settings */
+	/*
+	 * Reset FIFO, disable FIFO and set start conversion source to none.
+	 * Keep se/diff and bip/uni settings.
+	 */
 	devpriv->adccon = (devpriv->adccon & (PCI230_ADC_IR_MASK
 					      | PCI230_ADC_IM_MASK)) |
 	    PCI230_ADC_TRIG_NONE;
@@ -2006,8 +2104,10 @@ static void pci230_ai_start(struct comedi_device *dev,
 		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
-		/* Update conversion trigger source which is currently set
-		 * to CT2 output, which is currently stuck high. */
+		/*
+		 * Update conversion trigger source which is currently set
+		 * to CT2 output, which is currently stuck high.
+		 */
 		switch (cmd->convert_src) {
 		default:
 			conv = PCI230_ADC_TRIG_NONE;
@@ -2037,8 +2137,10 @@ static void pci230_ai_start(struct comedi_device *dev,
 			}
 			break;
 		case TRIG_INT:
-			/* Use CT2 output for software trigger due to problems
-			 * in differential mode on PCI230/260. */
+			/*
+			 * Use CT2 output for software trigger due to problems
+			 * in differential mode on PCI230/260.
+			 */
 			conv = PCI230_ADC_TRIG_Z2CT2;
 			break;
 		}
@@ -2048,20 +2150,26 @@ static void pci230_ai_start(struct comedi_device *dev,
 		if (cmd->convert_src == TRIG_INT)
 			async->inttrig = pci230_ai_inttrig_convert;
 
-		/* Update FIFO interrupt trigger level, which is currently
-		 * set to "full".  */
+		/*
+		 * Update FIFO interrupt trigger level, which is currently
+		 * set to "full".
+		 */
 		pci230_ai_update_fifo_trigger_level(dev, s);
 		if (cmd->convert_src == TRIG_TIMER) {
 			/* Update timer gates. */
 			unsigned char zgat;
 
 			if (cmd->scan_begin_src != TRIG_FOLLOW) {
-				/* Conversion timer CT2 needs to be gated by
-				 * inverted output of monostable CT2. */
+				/*
+				 * Conversion timer CT2 needs to be gated by
+				 * inverted output of monostable CT2.
+				 */
 				zgat = GAT_CONFIG(2, GAT_NOUTNM2);
 			} else {
-				/* Conversion timer CT2 needs to be gated on
-				 * continuously. */
+				/*
+				 * Conversion timer CT2 needs to be gated on
+				 * continuously.
+				 */
 				zgat = GAT_CONFIG(2, GAT_VCC);
 			}
 			outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
@@ -2103,8 +2211,10 @@ static void pci230_ai_start(struct comedi_device *dev,
 				outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 				switch (cmd->scan_begin_src) {
 				case TRIG_TIMER:
-					/* Scan period timer CT1 needs to be
-					 * gated on to start counting. */
+					/*
+					 * Scan period timer CT1 needs to be
+					 * gated on to start counting.
+					 */
 					zgat = GAT_CONFIG(1, GAT_VCC);
 					outb(zgat, devpriv->iobase1
 					     + PCI230_ZGAT_SCE);
@@ -2172,8 +2282,10 @@ static void pci230_handle_ai(struct comedi_device *dev,
 			/* Read FIFO state. */
 			status_fifo = inw(dev->iobase + PCI230_ADCCON);
 			if ((status_fifo & PCI230_ADC_FIFO_FULL_LATCHED) != 0) {
-				/* Report error otherwise FIFO overruns will go
-				 * unnoticed by the caller. */
+				/*
+				 * Report error otherwise FIFO overruns will go
+				 * unnoticed by the caller.
+				 */
 				dev_err(dev->class_dev, "AI FIFO overrun\n");
 				events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 				break;
@@ -2247,8 +2359,10 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * Determine which shared resources are needed.
 	 */
 	res_mask = 0;
-	/* Need Z2-CT2 to supply a conversion trigger source at a high
-	 * logic level, even if not doing timed conversions. */
+	/*
+	 * Need Z2-CT2 to supply a conversion trigger source at a high
+	 * logic level, even if not doing timed conversions.
+	 */
 	res_mask |= (1U << RES_Z2CT2);
 	if (cmd->scan_begin_src != TRIG_FOLLOW) {
 		/* Using Z2-CT0 monostable to gate Z2-CT2 conversion timer */
@@ -2270,7 +2384,8 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_scan_count = 0;
 	devpriv->ai_scan_pos = 0;	/* Position within scan. */
 
-	/* Steps;
+	/*
+	 * Steps:
 	 * - Set channel scan list.
 	 * - Set channel gains.
 	 * - Enable and reset FIFO, specify uni/bip, se/diff, and set
@@ -2315,12 +2430,16 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		if (diff) {
 			gainshift = 2 * chan;
 			if (devpriv->hwver == 0) {
-				/* Original PCI230/260 expects both inputs of
-				 * the differential channel to be enabled. */
+				/*
+				 * Original PCI230/260 expects both inputs of
+				 * the differential channel to be enabled.
+				 */
 				adcen |= 3 << gainshift;
 			} else {
-				/* PCI230+/260+ expects only one input of the
-				 * differential channel to be enabled. */
+				/*
+				 * PCI230+/260+ expects only one input of the
+				 * differential channel to be enabled.
+				 */
 				adcen |= 1 << gainshift;
 			}
 		} else {
@@ -2337,38 +2456,48 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* Set channel gains. */
 	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
 
-	/* Set counter/timer 2 output high for use as the initial start
-	 * conversion source. */
+	/*
+	 * Set counter/timer 2 output high for use as the initial start
+	 * conversion source.
+	 */
 	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE1);
 
-	/* Temporarily use CT2 output as conversion trigger source and
-	 * temporarily set FIFO interrupt trigger level to 'full'. */
+	/*
+	 * Temporarily use CT2 output as conversion trigger source and
+	 * temporarily set FIFO interrupt trigger level to 'full'.
+	 */
 	adccon |= PCI230_ADC_INT_FIFO_FULL | PCI230_ADC_TRIG_Z2CT2;
 
-	/* Enable and reset FIFO, specify FIFO trigger level full, specify
+	/*
+	 * Enable and reset FIFO, specify FIFO trigger level full, specify
 	 * uni/bip, se/diff, and temporarily set the start conversion source
 	 * to CT2 output.  Note that CT2 output is currently high, and this
 	 * will produce a false conversion trigger on some versions of the
-	 * PCI230/260, but that will be dealt with later. */
+	 * PCI230/260, but that will be dealt with later.
+	 */
 	devpriv->adccon = adccon;
 	outw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);
 
-	/* Delay */
-	/* Failure to include this will result in the first few channels'-worth
+	/*
+	 * Delay -
+	 * Failure to include this will result in the first few channels'-worth
 	 * of data being corrupt, normally manifesting itself by large negative
 	 * voltages. It seems the board needs time to settle between the first
 	 * FIFO reset (above) and the second FIFO reset (below). Setting the
 	 * channel gains and scan list _before_ the first FIFO reset also
-	 * helps, though only slightly. */
+	 * helps, though only slightly.
+	 */
 	udelay(25);
 
 	/* Reset FIFO again. */
 	outw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		/* Set up CT2 as conversion timer, but gate it off for now.
+		/*
+		 * Set up CT2 as conversion timer, but gate it off for now.
 		 * Note, counter/timer output 2 can be monitored on the
-		 * connector: PCI230 pin 21, PCI260 pin 18. */
+		 * connector: PCI230 pin 21, PCI260 pin 18.
+		 */
 		zgat = GAT_CONFIG(2, GAT_GND);
 		outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 		/* Set counter/timer 2 to the specified conversion period. */
@@ -2442,9 +2571,11 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 
 	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	valid_status_int = devpriv->int_en & status_int;
-	/* Disable triggered interrupts.
+	/*
+	 * Disable triggered interrupts.
 	 * (Only those interrupts that need re-enabling, are, later in the
-	 * handler).  */
+	 * handler).
+	 */
 	devpriv->ier = devpriv->int_en & ~status_int;
 	outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 	devpriv->intr_running = 1;
@@ -2501,8 +2632,10 @@ static bool pci230_match_pci_board(const struct pci230_board *board,
 	/* Looking for a '+' model.  First check length of registers. */
 	if (pci_resource_len(pci_dev, 3) < 32)
 		return false;	/* Not a '+' model. */
-	/* TODO: temporarily enable PCI device and read the hardware version
-	 * register.  For now, assume it's okay. */
+	/*
+	 * TODO: temporarily enable PCI device and read the hardware version
+	 * register.  For now, assume it's okay.
+	 */
 	return true;
 }
 
@@ -2591,8 +2724,10 @@ static int pci230_attach_common(struct comedi_device *dev,
 	if (rc)
 		return rc;
 
-	/* Read base addresses of the PCI230's two I/O regions from PCI
-	 * configuration register. */
+	/*
+	 * Read base addresses of the PCI230's two I/O regions from PCI
+	 * configuration register.
+	 */
 	iobase1 = pci_resource_start(pci_dev, 2);
 	iobase2 = pci_resource_start(pci_dev, 3);
 	dev_dbg(dev->class_dev,
@@ -2602,8 +2737,10 @@ static int pci230_attach_common(struct comedi_device *dev,
 	dev->iobase = iobase2;
 	/* Read bits of DACCON register - only the output range. */
 	devpriv->daccon = inw(dev->iobase + PCI230_DACCON) & PCI230_DAC_OR_MASK;
-	/* Read hardware version register and set extended function register
-	 * if they exist. */
+	/*
+	 * Read hardware version register and set extended function register
+	 * if they exist.
+	 */
 	if (pci_resource_len(pci_dev, 3) >= 32) {
 		unsigned short extfunc = 0;
 
@@ -2617,11 +2754,13 @@ static int pci230_attach_common(struct comedi_device *dev,
 		}
 		if (devpriv->hwver > 0) {
 			if (!thisboard->have_dio) {
-				/* No DIO ports.  Route counters' external gates
+				/*
+				 * No DIO ports.  Route counters' external gates
 				 * to the EXTTRIG signal (PCI260+ pin 17).
 				 * (Otherwise, they would be routed to DIO
 				 * inputs PC0, PC1 and PC2 which don't exist
-				 * on PCI260[+].) */
+				 * on PCI260[+].)
+				 */
 				extfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;
 			}
 			if ((thisboard->ao_chans > 0)
@@ -2632,8 +2771,10 @@ static int pci230_attach_common(struct comedi_device *dev,
 		}
 		outw(extfunc, dev->iobase + PCI230P_EXTFUNC);
 		if ((extfunc & PCI230P2_EXTFUNC_DACFIFO) != 0) {
-			/* Temporarily enable DAC FIFO, reset it and disable
-			 * FIFO wraparound. */
+			/*
+			 * Temporarily enable DAC FIFO, reset it and disable
+			 * FIFO wraparound.
+			 */
 			outw(devpriv->daccon | PCI230P2_DAC_FIFO_EN
 			     | PCI230P2_DAC_FIFO_RESET,
 			     dev->iobase + PCI230_DACCON);

commit 862755ec07572036b0c69d738b88f89b6beede99
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:22 2014 -0700

    staging: comedi: drivers: remove unnecessary *_SIZE defines
    
    Some of the legacy comedi drivers have a *_SIZE define that is only
    passed to comedi_request_region() to specify the size of the region.
    
    Some of the pnp drivers (pci, etc.) also have a *_SIZE define which
    is unused.
    
    For aesthetics, remove these defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index eca16a6b09d7..a61d9904d970 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -200,9 +200,6 @@ for (or detection of) various hardware problems added by Ian Abbott.
 #define PCI_DEVICE_ID_PCI260 0x0006
 #define PCI_DEVICE_ID_INVALID 0xffff
 
-#define PCI230_IO1_SIZE 32	/* Size of I/O space 1 */
-#define PCI230_IO2_SIZE 16	/* Size of I/O space 2 */
-
 /* PCI230 i/o space 1 registers. */
 #define PCI230_PPI_X_BASE	0x00	/* User PPI (82C55) base */
 #define PCI230_PPI_X_A		0x00	/* User PPI (82C55) port A */

commit a207c12f62e8b53e1e1600ca384b13a39a9feed2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:16 2014 -0700

    staging: comedi: drivers: cleanup cmd->flags use
    
    Most of the comedi drivers that support async commands have some sort
    of timer to control the acquisition timing. For these drivers, Step 4
    of the (*do_cmdtest) operations calls a ns_to_timer() function that
    converts the desired ns time of the command into a value used to set
    the timer. These ns_to_timer() functions also typically pass the
    cmd->flags in order to determine the desired rounding mode.
    
    Some of the drivers mask the cmd->flags with TRIG_ROUND_MASK when
    calling the ns_to_timer() functions. Move all the masking into the
    ns_to_timer() functions and just pass the cmd->flags directly.
    
    The cmd->flags member is an unsigned int, change the parameter type
    in the the ns_to_timer() functions to match.
    
    For aesthetics, rename the parameter in all the ns_to_timer()
    functions to 'flags'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 2c318fc721e9..eca16a6b09d7 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -712,15 +712,14 @@ static inline void put_all_resources(struct comedi_device *dev,
 }
 
 static unsigned int divide_ns(uint64_t ns, unsigned int timebase,
-			      unsigned int round_mode)
+			      unsigned int flags)
 {
 	uint64_t div;
 	unsigned int rem;
 
 	div = ns;
 	rem = do_div(div, timebase);
-	round_mode &= TRIG_ROUND_MASK;
-	switch (round_mode) {
+	switch (flags & TRIG_ROUND_MASK) {
 	default:
 	case TRIG_ROUND_NEAREST:
 		div += (rem + (timebase / 2)) / timebase;
@@ -737,12 +736,12 @@ static unsigned int divide_ns(uint64_t ns, unsigned int timebase,
 /* Given desired period in ns, returns the required internal clock source
  * and gets the initial count. */
 static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
-					    unsigned int round_mode)
+					    unsigned int flags)
 {
 	unsigned int clk_src, cnt;
 
 	for (clk_src = CLK_10MHZ;; clk_src++) {
-		cnt = divide_ns(ns, pci230_timebase[clk_src], round_mode);
+		cnt = divide_ns(ns, pci230_timebase[clk_src], flags);
 		if ((cnt <= 65536) || (clk_src == CLK_1KHZ))
 			break;
 
@@ -751,18 +750,18 @@ static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
 	return clk_src;
 }
 
-static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round)
+static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int flags)
 {
 	unsigned int count;
 	unsigned int clk_src;
 
-	clk_src = pci230_choose_clk_count(*ns, &count, round);
+	clk_src = pci230_choose_clk_count(*ns, &count, flags);
 	*ns = count * pci230_timebase[clk_src];
 }
 
 static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 				    unsigned int mode, uint64_t ns,
-				    unsigned int round)
+				    unsigned int flags)
 {
 	struct pci230_private *devpriv = dev->private;
 	unsigned int clk_src;
@@ -771,7 +770,7 @@ static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 	/* Set mode. */
 	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, mode);
 	/* Determine clock source and count. */
-	clk_src = pci230_choose_clk_count(ns, &count, round);
+	clk_src = pci230_choose_clk_count(ns, &count, flags);
 	/* Program clock source. */
 	outb(CLK_CONFIG(ct, clk_src), devpriv->iobase1 + PCI230_ZCLK_SCE);
 	/* Set initial count. */
@@ -1079,8 +1078,7 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
-		pci230_ns_to_single_timer(&cmd->scan_begin_arg,
-					  cmd->flags & TRIG_ROUND_MASK);
+		pci230_ns_to_single_timer(&cmd->scan_begin_arg, cmd->flags);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -1492,7 +1490,7 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		     devpriv->iobase1 + PCI230_ZGAT_SCE);
 		pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
 					cmd->scan_begin_arg,
-					cmd->flags & TRIG_ROUND_MASK);
+					cmd->flags);
 	}
 
 	/* N.B. cmd->start_src == TRIG_INT */
@@ -1799,8 +1797,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
-		pci230_ns_to_single_timer(&cmd->convert_arg,
-					  cmd->flags & TRIG_ROUND_MASK);
+		pci230_ns_to_single_timer(&cmd->convert_arg, cmd->flags);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -1808,8 +1805,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		/* N.B. cmd->convert_arg is also TRIG_TIMER */
 		tmp = cmd->scan_begin_arg;
-		pci230_ns_to_single_timer(&cmd->scan_begin_arg,
-					  cmd->flags & TRIG_ROUND_MASK);
+		pci230_ns_to_single_timer(&cmd->scan_begin_arg, cmd->flags);
 		if (!pci230_ai_check_scan_period(cmd)) {
 			/* Was below minimum required.  Round up. */
 			pci230_ns_to_single_timer(&cmd->scan_begin_arg,
@@ -2380,7 +2376,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 		/* Set counter/timer 2 to the specified conversion period. */
 		pci230_ct_setup_ns_mode(dev, 2, I8254_MODE3, cmd->convert_arg,
-					cmd->flags & TRIG_ROUND_MASK);
+					cmd->flags);
 		if (cmd->scan_begin_src != TRIG_FOLLOW) {
 			/*
 			 * Set up monostable on CT0 output for scan timing.  A
@@ -2411,9 +2407,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 				pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
 							cmd->scan_begin_arg,
-							cmd->
-							flags &
-							TRIG_ROUND_MASK);
+							cmd->flags);
 			}
 		}
 	}

commit 8f35f91838189c0be82d61d1bfafdb3e7af46d53
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:47 2014 -0700

    staging: comedi: amplc_pci230: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index f00344902216..2c318fc721e9 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1167,7 +1167,7 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 		if (ret == 0) {
 			s->async->events |= COMEDI_CB_OVERFLOW;
 			pci230_ao_stop(dev, s);
-			comedi_error(dev, "AO buffer underrun");
+			dev_err(dev->class_dev, "AO buffer underrun\n");
 			return;
 		}
 		/* Write value to DAC. */
@@ -1215,7 +1215,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 	if (events == 0) {
 		/* Check for FIFO underrun. */
 		if ((dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) != 0) {
-			comedi_error(dev, "AO FIFO underrun");
+			dev_err(dev->class_dev, "AO FIFO underrun\n");
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
 		/* Check for buffer underrun if FIFO less than half full
@@ -1223,7 +1223,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 		 * interrupts). */
 		if ((num_scans == 0)
 		    && ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {
-			comedi_error(dev, "AO buffer underrun");
+			dev_err(dev->class_dev, "AO buffer underrun\n");
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
 	}
@@ -1270,7 +1270,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 		/* Check if FIFO underrun occurred while writing to FIFO. */
 		dacstat = inw(dev->iobase + PCI230_DACCON);
 		if ((dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) != 0) {
-			comedi_error(dev, "AO FIFO underrun");
+			dev_err(dev->class_dev, "AO FIFO underrun\n");
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
 	}
@@ -2181,7 +2181,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 			if ((status_fifo & PCI230_ADC_FIFO_FULL_LATCHED) != 0) {
 				/* Report error otherwise FIFO overruns will go
 				 * unnoticed by the caller. */
-				comedi_error(dev, "AI FIFO overrun");
+				dev_err(dev->class_dev, "AI FIFO overrun\n");
 				events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 				break;
 			} else if ((status_fifo & PCI230_ADC_FIFO_EMPTY) != 0) {
@@ -2208,7 +2208,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 		/* Read sample and store in Comedi's circular buffer. */
 		if (comedi_buf_put(s, pci230_ai_read(dev)) == 0) {
 			events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
-			comedi_error(dev, "AI buffer overflow");
+			dev_err(dev->class_dev, "AI buffer overflow\n");
 			break;
 		}
 		fifoamount--;

commit 0a9e58d6e68f1656be234e92a4eeae8f98dd4dd1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:01:52 2014 -0700

    staging: comedi: amplc_pci230: checkpatch.pl cleanup (void function return)
    
    Fix the checkpatch.pl warning in this file:
    
    WARNING: void function return statements are not generally useful
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 3895bc7cb3e3..f00344902216 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -758,7 +758,6 @@ static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round)
 
 	clk_src = pci230_choose_clk_count(*ns, &count, round);
 	*ns = count * pci230_timebase[clk_src];
-	return;
 }
 
 static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,

commit b7a775f815f2469b40636369e73c9e3db2a045d9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:31:07 2014 -0700

    staging: comedi: amplc_pci230: use cfc_bytes_per_scan()
    
    Use the comedi_fc helper function to get the 'bytes_per_scan'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 9c8254386704..3895bc7cb3e3 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1197,15 +1197,13 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 	unsigned int room;
 	unsigned short dacstat;
 	unsigned int i, n;
-	unsigned int bytes_per_scan;
 	unsigned int events = 0;
 	int running;
 
 	/* Get DAC FIFO status. */
 	dacstat = inw(dev->iobase + PCI230_DACCON);
 	/* Determine number of scans available in buffer. */
-	bytes_per_scan = cmd->chanlist_len * sizeof(short);
-	num_scans = comedi_buf_read_n_available(s) / bytes_per_scan;
+	num_scans = comedi_buf_read_n_available(s) / cfc_bytes_per_scan(s);
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* Fixed number of scans. */
 		if (num_scans > devpriv->ao_scan_count)

commit 1eb9cf92da92a33d38c6418b609743e673f366fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:49 2014 -0700

    staging: comedi: amplc_pci230: use comedi_cmd pointer
    
    Use the local variable to access the comedi_cmd as a pointer in
    pci230_handle_ai() instead of getting to it from the comedi_async
    pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index d6f6a7a5bad1..9c8254386704 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2151,14 +2151,14 @@ static void pci230_handle_ai(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	struct pci230_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	unsigned int scanlen = cmd->scan_end_arg;
 	unsigned int events = 0;
 	unsigned int status_fifo;
 	unsigned int i;
 	unsigned int todo;
 	unsigned int fifoamount;
-	struct comedi_async *async = s->async;
-	unsigned int scanlen = async->cmd.scan_end_arg;
 
 	/* Determine number of samples to read. */
 	if (cmd->stop_src != TRIG_COUNT) {

commit e9edef3a5454a19fd0d0c342cc88b6310b871a48
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:09 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_read_n_available()
    
    Change the parameters of `comedi_buf_read_n_available()` to pass a
    pointer to the comedi subdevice instead of a pointer to the "async"
    structure belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index d0740d603ae7..d6f6a7a5bad1 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1205,7 +1205,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 	dacstat = inw(dev->iobase + PCI230_DACCON);
 	/* Determine number of scans available in buffer. */
 	bytes_per_scan = cmd->chanlist_len * sizeof(short);
-	num_scans = comedi_buf_read_n_available(async) / bytes_per_scan;
+	num_scans = comedi_buf_read_n_available(s) / bytes_per_scan;
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* Fixed number of scans. */
 		if (num_scans > devpriv->ao_scan_count)

commit 458c13e935d9f33fffb099e49ecb53c67ddd1a21
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:00 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_get()
    
    Change the parameters of `comedi_buf_get()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function gets a sample value from the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 9541e240925e..d0740d603ae7 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1164,7 +1164,7 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 		return;
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		/* Read sample from Comedi's circular buffer. */
-		ret = comedi_buf_get(s->async, &data);
+		ret = comedi_buf_get(s, &data);
 		if (ret == 0) {
 			s->async->events |= COMEDI_CB_OVERFLOW;
 			pci230_ao_stop(dev, s);
@@ -1250,7 +1250,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 			for (i = 0; i < cmd->chanlist_len; i++) {
 				unsigned short datum;
 
-				comedi_buf_get(async, &datum);
+				comedi_buf_get(s, &datum);
 				pci230_ao_write_fifo(dev, datum,
 						     CR_CHAN(cmd->chanlist[i]));
 			}

commit 3672effdeae5395d661a2103f69082146ef949fc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:11:59 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_put()
    
    Change the parameters of `comedi_buf_put()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function puts a sample value in the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index ff927c641748..9541e240925e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2209,7 +2209,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 			}
 		}
 		/* Read sample and store in Comedi's circular buffer. */
-		if (comedi_buf_put(async, pci230_ai_read(dev)) == 0) {
+		if (comedi_buf_put(s, pci230_ai_read(dev)) == 0) {
 			events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
 			comedi_error(dev, "AI buffer overflow");
 			break;

commit 7586fd6b3e2df042ce2b45cf4ab43a92af1a27ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:39 2014 -0700

    staging: comedi: amplc_pci230: remove 'ao_continuous' from private data
    
    This member of the private data can be determined by checking the cmd->stop_src.
    Do that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index c00bd7c46366..ff927c641748 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -519,10 +519,6 @@ struct pci230_private {
 					 * level threshold (PCI230+/260+). */
 	unsigned short adcg;	/* ADCG register value. */
 	unsigned char int_en;	/* Interrupt enables bits. */
-	unsigned char ao_continuous;	/* Flag set when cmd->stop_src ==
-					 * TRIG_NONE - user chooses to stop
-					 * continuous conversion by
-					 * cancelation. */
 	unsigned char ai_bipolar;	/* Set if bipolar input range so we
 					 * know to mangle it. */
 	unsigned char ao_bipolar;	/* Set if bipolar output range so we
@@ -1164,7 +1160,7 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 
-	if (!devpriv->ao_continuous && (devpriv->ao_scan_count == 0))
+	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_scan_count == 0)
 		return;
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		/* Read sample from Comedi's circular buffer. */
@@ -1179,7 +1175,7 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 		pci230_ao_write_nofifo(dev, data, CR_CHAN(cmd->chanlist[i]));
 	}
 	async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
-	if (!devpriv->ao_continuous) {
+	if (cmd->stop_src == TRIG_COUNT) {
 		devpriv->ao_scan_count--;
 		if (devpriv->ao_scan_count == 0) {
 			/* End of acquisition. */
@@ -1210,7 +1206,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 	/* Determine number of scans available in buffer. */
 	bytes_per_scan = cmd->chanlist_len * sizeof(short);
 	num_scans = comedi_buf_read_n_available(async) / bytes_per_scan;
-	if (!devpriv->ao_continuous) {
+	if (cmd->stop_src == TRIG_COUNT) {
 		/* Fixed number of scans. */
 		if (num_scans > devpriv->ao_scan_count)
 			num_scans = devpriv->ao_scan_count;
@@ -1260,7 +1256,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 			}
 		}
 		events |= COMEDI_CB_EOS | COMEDI_CB_BLOCK;
-		if (!devpriv->ao_continuous) {
+		if (cmd->stop_src == TRIG_COUNT) {
 			devpriv->ao_scan_count -= num_scans;
 			if (devpriv->ao_scan_count == 0) {
 				/* All data for the command has been written
@@ -1338,7 +1334,7 @@ static void pci230_ao_start(struct comedi_device *dev,
 	unsigned long irqflags;
 
 	set_bit(AO_CMD_STARTED, &devpriv->state);
-	if (!devpriv->ao_continuous && (devpriv->ao_scan_count == 0)) {
+	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_scan_count == 0) {
 		/* An empty acquisition! */
 		async->events |= COMEDI_CB_EOA;
 		pci230_ao_stop(dev, s);
@@ -1451,14 +1447,10 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* Get number of scans required. */
-	if (cmd->stop_src == TRIG_COUNT) {
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ao_scan_count = cmd->stop_arg;
-		devpriv->ao_continuous = 0;
-	} else {
-		/* TRIG_NONE, user calls cancel. */
+	else	/* TRIG_NONE, user calls cancel */
 		devpriv->ao_scan_count = 0;
-		devpriv->ao_continuous = 1;
-	}
 
 	/* Set range - see analogue output range table; 0 => unipolar 10V,
 	 * 1 => bipolar +/-10V range scale */

commit bca4eac8fd36e8ab2990d513a9d6a34d2a5bd502
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:38 2014 -0700

    staging: comedi: amplc_pci230: remove 'ai_continuous' from private data
    
    This member of the private data can be determined by checking the cmd->stop_src.
    Do that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index d7ffd18206f9..c00bd7c46366 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -519,10 +519,6 @@ struct pci230_private {
 					 * level threshold (PCI230+/260+). */
 	unsigned short adcg;	/* ADCG register value. */
 	unsigned char int_en;	/* Interrupt enables bits. */
-	unsigned char ai_continuous;	/* Flag set when cmd->stop_src ==
-					 * TRIG_NONE - user chooses to stop
-					 * continuous conversion by
-					 * cancelation. */
 	unsigned char ao_continuous;	/* Flag set when cmd->stop_src ==
 					 * TRIG_NONE - user chooses to stop
 					 * continuous conversion by
@@ -1862,9 +1858,9 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 		/* Wake at end of scan. */
 		wake = scanlen - devpriv->ai_scan_pos;
 	} else {
-		if (devpriv->ai_continuous
-		    || (devpriv->ai_scan_count >= PCI230_ADC_FIFOLEVEL_HALFFULL)
-		    || (scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL)) {
+		if (cmd->stop_src != TRIG_COUNT ||
+		    devpriv->ai_scan_count >= PCI230_ADC_FIFOLEVEL_HALFFULL ||
+		    scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
 			wake = PCI230_ADC_FIFOLEVEL_HALFFULL;
 		} else {
 			wake = (devpriv->ai_scan_count * scanlen)
@@ -2015,7 +2011,7 @@ static void pci230_ai_start(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &async->cmd;
 
 	set_bit(AI_CMD_STARTED, &devpriv->state);
-	if (!devpriv->ai_continuous && (devpriv->ai_scan_count == 0)) {
+	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_scan_count == 0) {
 		/* An empty acquisition! */
 		async->events |= COMEDI_CB_EOA;
 		pci230_ai_stop(dev, s);
@@ -2163,6 +2159,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	struct pci230_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int events = 0;
 	unsigned int status_fifo;
 	unsigned int i;
@@ -2172,7 +2169,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 	unsigned int scanlen = async->cmd.scan_end_arg;
 
 	/* Determine number of samples to read. */
-	if (devpriv->ai_continuous) {
+	if (cmd->stop_src != TRIG_COUNT) {
 		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	} else if (devpriv->ai_scan_count == 0) {
 		todo = 0;
@@ -2234,7 +2231,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 			async->events |= COMEDI_CB_EOS;
 		}
 	}
-	if (!devpriv->ai_continuous && (devpriv->ai_scan_count == 0)) {
+	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_scan_count == 0) {
 		/* End of acquisition. */
 		events |= COMEDI_CB_EOA;
 	} else {
@@ -2285,14 +2282,10 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 
 	/* Get number of scans required. */
-	if (cmd->stop_src == TRIG_COUNT) {
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ai_scan_count = cmd->stop_arg;
-		devpriv->ai_continuous = 0;
-	} else {
-		/* TRIG_NONE, user calls cancel. */
+	else	/* TRIG_NONE, user calls cancel */
 		devpriv->ai_scan_count = 0;
-		devpriv->ai_continuous = 1;
-	}
 	devpriv->ai_scan_pos = 0;	/* Position within scan. */
 
 	/* Steps;

commit 2cc3460d51947987713451ad9423ba230cbfec00
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:07:55 2014 -0700

    staging: comedi: amplc_pci230: fix the ai/ao cmd->start_arg use for TRIG_INT
    
    This driver trivially validates the cmd->start_arg for all cmd->start_src values
    to be 0. For TRIG_INT source, the cmd->start_arg is actually the valid trig_num
    that is passed to the async (*inttrig) callback.
    
    Refactor the (*inttrig) functions so that the cmd->start_arg is used to check the
    trig_num instead of the open coded values.
    
    For aesthetics, refactor the ai (*do_cmd) to remove some unnecessary {}.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 7149f471f542..d7ffd18206f9 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1427,7 +1427,9 @@ static int pci230_ao_inttrig_start(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   unsigned int trig_num)
 {
-	if (trig_num != 0)
+	struct comedi_cmd *cmd = &s->async->cmd;
+
+	if (trig_num != cmd->start_src)
 		return -EINVAL;
 
 	s->async->inttrig = NULL;
@@ -2146,7 +2148,9 @@ static int pci230_ai_inttrig_start(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   unsigned int trig_num)
 {
-	if (trig_num != 0)
+	struct comedi_cmd *cmd = &s->async->cmd;
+
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	s->async->inttrig = NULL;
@@ -2432,12 +2436,10 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		}
 	}
 
-	if (cmd->start_src == TRIG_INT) {
+	if (cmd->start_src == TRIG_INT)
 		s->async->inttrig = pci230_ai_inttrig_start;
-	} else {
-		/* TRIG_NOW */
+	else	/* TRIG_NOW */
 		pci230_ai_start(dev, s);
-	}
 
 	return 0;
 }

commit e39a9704687efef22810c68defa9a4410dbd74c9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 16 14:19:09 2014 -0700

    staging: comedi: amplc_pci230: factor out chanlist checking from (*do_cmdtest)
    
    Step 5 of the (*do_cmdtest) validates that the cmd->chanlist is compatible
    with the hardware.
    
    For aesthetics, factor out the step 5 code for the analog output and analog
    input async command support. Tidy up the factored out code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 99e60835dc4a..7149f471f542 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -953,6 +953,38 @@ static int pci230_ao_rinsn(struct comedi_device *dev,
 	return i;
 }
 
+static int pci230_ao_check_chanlist(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_cmd *cmd)
+{
+	unsigned int prev_chan = CR_CHAN(cmd->chanlist[0]);
+	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
+	int i;
+
+	for (i = 1; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+		unsigned int range = CR_RANGE(cmd->chanlist[i]);
+
+		if (chan < prev_chan) {
+			dev_dbg(dev->class_dev,
+				"%s: channel numbers must increase\n",
+				__func__);
+			return -EINVAL;
+		}
+
+		if (range != range0) {
+			dev_dbg(dev->class_dev,
+				"%s: channels must have the same range\n",
+				__func__);
+			return -EINVAL;
+		}
+
+		prev_chan = chan;
+	}
+
+	return 0;
+}
+
 static int pci230_ao_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
@@ -1065,48 +1097,9 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 4;
 
-	/* Step 5: check channel list if it exists. */
-
-	if (cmd->chanlist && cmd->chanlist_len > 0) {
-		enum {
-			seq_err = (1 << 0),
-			range_err = (1 << 1)
-		};
-		unsigned int errors;
-		unsigned int n;
-		unsigned int chan, prev_chan;
-		unsigned int range, first_range;
-
-		prev_chan = CR_CHAN(cmd->chanlist[0]);
-		first_range = CR_RANGE(cmd->chanlist[0]);
-		errors = 0;
-		for (n = 1; n < cmd->chanlist_len; n++) {
-			chan = CR_CHAN(cmd->chanlist[n]);
-			range = CR_RANGE(cmd->chanlist[n]);
-			/* Channel numbers must strictly increase. */
-			if (chan < prev_chan)
-				errors |= seq_err;
-
-			/* Ranges must be the same. */
-			if (range != first_range)
-				errors |= range_err;
-
-			prev_chan = chan;
-		}
-		if (errors != 0) {
-			err++;
-			if ((errors & seq_err) != 0) {
-				dev_dbg(dev->class_dev,
-					"%s: channel numbers must increase\n",
-					__func__);
-			}
-			if ((errors & range_err) != 0) {
-				dev_dbg(dev->class_dev,
-					"%s: channels must have the same range\n",
-					__func__);
-			}
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= pci230_ao_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;
@@ -1552,6 +1545,109 @@ static int pci230_ai_check_scan_period(struct comedi_cmd *cmd)
 	return !err;
 }
 
+static int pci230_ai_check_chanlist(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_cmd *cmd)
+{
+	struct pci230_private *devpriv = dev->private;
+	unsigned int max_diff_chan = (s->n_chan / 2) - 1;
+	unsigned int prev_chan = 0;
+	unsigned int prev_range = 0;
+	unsigned int prev_aref = 0;
+	unsigned int prev_polarity = 0;
+	unsigned int subseq_len = 0;
+	int i;
+
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		unsigned int chanspec = cmd->chanlist[i];
+		unsigned int chan = CR_CHAN(chanspec);
+		unsigned int range = CR_RANGE(chanspec);
+		unsigned int aref = CR_AREF(chanspec);
+		unsigned int polarity = pci230_ai_bipolar[range];
+
+		if (aref == AREF_DIFF && chan >= max_diff_chan) {
+			dev_dbg(dev->class_dev,
+				"%s: differential channel number out of range 0 to %u\n",
+				__func__, max_diff_chan);
+			return -EINVAL;
+		}
+
+		if (i > 0) {
+			/*
+			 * Channel numbers must strictly increase or
+			 * subsequence must repeat exactly.
+			 */
+			if (chan <= prev_chan && subseq_len == 0)
+				subseq_len = i;
+
+			if (subseq_len > 0 &&
+			    cmd->chanlist[i % subseq_len] != chanspec) {
+					dev_dbg(dev->class_dev,
+						"%s: channel numbers must increase or sequence must repeat exactly\n",
+						__func__);
+					return -EINVAL;
+			}
+
+			if (aref != prev_aref) {
+				dev_dbg(dev->class_dev,
+					"%s: channel sequence analogue references must be all the same (single-ended or differential)\n",
+					__func__);
+				return -EINVAL;
+			}
+
+			if (polarity != prev_polarity) {
+				dev_dbg(dev->class_dev,
+					"%s: channel sequence ranges must be all bipolar or all unipolar\n",
+					__func__);
+				return -EINVAL;
+			}
+
+			if (aref != AREF_DIFF && range != prev_range &&
+			    ((chan ^ prev_chan) & ~1) == 0) {
+				dev_dbg(dev->class_dev,
+					"%s: single-ended channel pairs must have the same range\n",
+					__func__);
+				return -EINVAL;
+			}
+		}
+		prev_chan = chan;
+		prev_range = range;
+		prev_aref = aref;
+		prev_polarity = polarity;
+	}
+
+	if (subseq_len == 0)
+		subseq_len = cmd->chanlist_len;
+
+	if ((cmd->chanlist_len % subseq_len) != 0) {
+		dev_dbg(dev->class_dev,
+			"%s: sequence must repeat exactly\n", __func__);
+		return -EINVAL;
+	}
+
+	/*
+	 * Buggy PCI230+ or PCI260+ requires channel 0 to be (first) in the
+	 * sequence if the sequence contains more than one channel. Hardware
+	 * versions 1 and 2 have the bug. There is no hardware version 3.
+	 *
+	 * Actually, there are two firmwares that report themselves as
+	 * hardware version 1 (the boards have different ADC chips with
+	 * slightly different timing requirements, which was supposed to
+	 * be invisible to software). The first one doesn't seem to have
+	 * the bug, but the second one does, and we can't tell them apart!
+	 */
+	if (devpriv->hwver > 0 && devpriv->hwver < 4) {
+		if (subseq_len > 1 && CR_CHAN(cmd->chanlist[0]) != 0) {
+			dev_info(dev->class_dev,
+				 "amplc_pci230: ai_cmdtest: Buggy PCI230+/260+ h/w version %u requires first channel of multi-channel sequence to be 0 (corrected in h/w version 4)\n",
+				 devpriv->hwver);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int pci230_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
@@ -1740,136 +1836,9 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 4;
 
-	/* Step 5: check channel list if it exists. */
-
-	if (cmd->chanlist && cmd->chanlist_len > 0) {
-		enum {
-			seq_err = 1 << 0,
-			rangepair_err = 1 << 1,
-			polarity_err = 1 << 2,
-			aref_err = 1 << 3,
-			diffchan_err = 1 << 4,
-			buggy_chan0_err = 1 << 5
-		};
-		unsigned int errors;
-		unsigned int chan, prev_chan;
-		unsigned int range, prev_range;
-		unsigned int polarity, prev_polarity;
-		unsigned int aref, prev_aref;
-		unsigned int subseq_len;
-		unsigned int n;
-
-		subseq_len = 0;
-		errors = 0;
-		prev_chan = prev_aref = prev_range = prev_polarity = 0;
-		for (n = 0; n < cmd->chanlist_len; n++) {
-			chan = CR_CHAN(cmd->chanlist[n]);
-			range = CR_RANGE(cmd->chanlist[n]);
-			aref = CR_AREF(cmd->chanlist[n]);
-			polarity = pci230_ai_bipolar[range];
-			/* Only the first half of the channels are available if
-			 * differential.  (These are remapped in software.  In
-			 * hardware, only the even channels are available.) */
-			if ((aref == AREF_DIFF)
-			    && (chan >= (s->n_chan / 2))) {
-				errors |= diffchan_err;
-			}
-			if (n > 0) {
-				/* Channel numbers must strictly increase or
-				 * subsequence must repeat exactly. */
-				if ((chan <= prev_chan)
-				    && (subseq_len == 0)) {
-					subseq_len = n;
-				}
-				if ((subseq_len > 0)
-				    && (cmd->chanlist[n] !=
-					cmd->chanlist[n % subseq_len])) {
-					errors |= seq_err;
-				}
-				/* Channels must have same AREF. */
-				if (aref != prev_aref)
-					errors |= aref_err;
-
-				/* Channel ranges must have same polarity. */
-				if (polarity != prev_polarity)
-					errors |= polarity_err;
-
-				/* Single-ended channel pairs must have same
-				 * range.  */
-				if ((aref != AREF_DIFF)
-				    && (((chan ^ prev_chan) & ~1) == 0)
-				    && (range != prev_range)) {
-					errors |= rangepair_err;
-				}
-			}
-			prev_chan = chan;
-			prev_range = range;
-			prev_aref = aref;
-			prev_polarity = polarity;
-		}
-		if (subseq_len == 0) {
-			/* Subsequence is whole sequence. */
-			subseq_len = n;
-		}
-		/* If channel list is a repeating subsequence, need a whole
-		 * number of repeats. */
-		if ((n % subseq_len) != 0)
-			errors |= seq_err;
-
-		if ((devpriv->hwver > 0) && (devpriv->hwver < 4)) {
-			/*
-			 * Buggy PCI230+ or PCI260+ requires channel 0 to be
-			 * (first) in the sequence if the sequence contains
-			 * more than one channel.  Hardware versions 1 and 2
-			 * have the bug.  There is no hardware version 3.
-			 *
-			 * Actually, there are two firmwares that report
-			 * themselves as hardware version 1 (the boards
-			 * have different ADC chips with slightly different
-			 * timing requirements, which was supposed to be
-			 * invisible to software).  The first one doesn't
-			 * seem to have the bug, but the second one
-			 * does, and we can't tell them apart!
-			 */
-			if ((subseq_len > 1)
-			    && (CR_CHAN(cmd->chanlist[0]) != 0)) {
-				errors |= buggy_chan0_err;
-			}
-		}
-		if (errors != 0) {
-			err++;
-			if ((errors & seq_err) != 0) {
-				dev_dbg(dev->class_dev,
-					"%s: channel numbers must increase or sequence must repeat exactly\n",
-					__func__);
-			}
-			if ((errors & rangepair_err) != 0) {
-				dev_dbg(dev->class_dev,
-					"%s: single-ended channel pairs must have the same range\n",
-					__func__);
-			}
-			if ((errors & polarity_err) != 0) {
-				dev_dbg(dev->class_dev,
-					"%s: channel sequence ranges must be all bipolar or all unipolar\n",
-					__func__);
-			}
-			if ((errors & aref_err) != 0) {
-				dev_dbg(dev->class_dev,
-					"%s: channel sequence analogue references must be all the same (single-ended or differential)\n",
-					__func__);
-			}
-			if ((errors & diffchan_err) != 0) {
-				dev_dbg(dev->class_dev,
-					"%s: differential channel number out of range 0 to %u\n",
-					__func__, (s->n_chan / 2) - 1);
-			}
-			if ((errors & buggy_chan0_err) != 0) {
-				dev_info(dev->class_dev,
-					 "amplc_pci230: ai_cmdtest: Buggy PCI230+/260+ h/w version %u requires first channel of multi-channel sequence to be 0 (corrected in h/w version 4)\n",
-					 devpriv->hwver);
-			}
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= pci230_ai_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;

commit 22ca19d93d92c79cff68270846a84bd34fe6fb34
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:45 2014 -0700

    staging: comedi: move (*insn_{read, write}) timeout debug messages to core
    
    Have the comedi core display a standard dev_dbg() message when a timeout
    occurs and remove all the driver specific messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index b606bdb2826e..99e60835dc4a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -895,10 +895,8 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 
 		/* wait for conversion to end */
 		ret = comedi_timeout(dev, s, insn, pci230_ai_eoc, 0);
-		if (ret) {
-			dev_err(dev->class_dev, "timeout\n");
+		if (ret)
 			return ret;
-		}
 
 		/* read data */
 		data[n] = pci230_ai_read(dev);

commit 0883fcab44dd5a70b800d700dc23144b0734f77d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:31 2014 -0700

    staging: comedi: amplc_pci230: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 7356fee67379..b606bdb2826e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -799,19 +799,29 @@ static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)
 	/* Counter ct, 8254 mode 1, initial count not written. */
 }
 
-/*
- *  COMEDI_SUBD_AI instruction;
- */
+static int pci230_ai_eoc(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 struct comedi_insn *insn,
+			 unsigned long context)
+{
+	unsigned int status;
+
+	status = inw(dev->iobase + PCI230_ADCCON);
+	if ((status & PCI230_ADC_FIFO_EMPTY) == 0)
+		return 0;
+	return -EBUSY;
+}
+
 static int pci230_ai_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
 	struct pci230_private *devpriv = dev->private;
-	unsigned int n, i;
+	unsigned int n;
 	unsigned int chan, range, aref;
 	unsigned int gainshift;
-	unsigned int status;
 	unsigned short adccon, adcen;
+	int ret;
 
 	/* Unpack channel and range. */
 	chan = CR_CHAN(insn->chanspec);
@@ -883,17 +893,11 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
 			       I8254_MODE1);
 
-#define TIMEOUT 100
 		/* wait for conversion to end */
-		for (i = 0; i < TIMEOUT; i++) {
-			status = inw(dev->iobase + PCI230_ADCCON);
-			if (!(status & PCI230_ADC_FIFO_EMPTY))
-				break;
-			udelay(1);
-		}
-		if (i == TIMEOUT) {
+		ret = comedi_timeout(dev, s, insn, pci230_ai_eoc, 0);
+		if (ret) {
 			dev_err(dev->class_dev, "timeout\n");
-			return -ETIMEDOUT;
+			return ret;
 		}
 
 		/* read data */

commit c93999c21319439c4fe2da85f2ec40ed477379ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 3 11:26:50 2014 -0700

    staging: comedi: drivers: remove final 'attach' messages
    
    These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 8b8b2ac4bf7f..7356fee67379 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2768,8 +2768,8 @@ static int pci230_attach_common(struct comedi_device *dev,
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}
-	dev_info(dev->class_dev, "attached\n");
-	return 1;
+
+	return 0;
 }
 
 static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)

commit ce921ae41919d033b4cd1d639f2a5f42dd41e802
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 3 10:43:27 2014 -0700

    staging: comedi: amplc_pci230: standardize error handling of subdev_8255_init()
    
    The subdev_8255_init() call returns 0 for success of a negative errno for failure.
    For aesthetics, change the error test in this driver from (rc < 0) to simply (rc)
    to follow the style of the other users of this function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index c08dfbbe4062..8b8b2ac4bf7f 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2762,8 +2762,8 @@ static int pci230_attach_common(struct comedi_device *dev,
 	/* digital i/o subdevice */
 	if (thisboard->have_dio) {
 		rc = subdev_8255_init(dev, s, NULL,
-				      (devpriv->iobase1 + PCI230_PPI_X_BASE));
-		if (rc < 0)
+				      devpriv->iobase1 + PCI230_PPI_X_BASE);
+		if (rc)
 			return rc;
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;

commit 1179b1d780c53b0aff6d0b28a526adffdd2015df
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:13 2013 -0700

    staging: comedi: amplc_pci230: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 48a0f527b431..c08dfbbe4062 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -546,15 +546,16 @@ static const unsigned int pci230_timebase[8] = {
 };
 
 /* PCI230 analogue input range table */
-static const struct comedi_lrange pci230_ai_range = { 7, {
-							  BIP_RANGE(10),
-							  BIP_RANGE(5),
-							  BIP_RANGE(2.5),
-							  BIP_RANGE(1.25),
-							  UNI_RANGE(10),
-							  UNI_RANGE(5),
-							  UNI_RANGE(2.5)
-							  }
+static const struct comedi_lrange pci230_ai_range = {
+	7, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5)
+	}
 };
 
 /* PCI230 analogue gain bits for each input range. */
@@ -564,10 +565,11 @@ static const unsigned char pci230_ai_gain[7] = { 0, 1, 2, 3, 1, 2, 3 };
 static const unsigned char pci230_ai_bipolar[7] = { 1, 1, 1, 1, 0, 0, 0 };
 
 /* PCI230 analogue output range table */
-static const struct comedi_lrange pci230_ao_range = { 2, {
-							  UNI_RANGE(10),
-							  BIP_RANGE(10)
-							  }
+static const struct comedi_lrange pci230_ao_range = {
+	2, {
+		UNI_RANGE(10),
+		BIP_RANGE(10)
+	}
 };
 
 /* PCI230 daccon bipolar flag for each analogue output range. */

commit e10c19a83c223777d5b302c683fdbad9cc57ff53
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 13:43:33 2013 -0700

    staging: comedi: amplc_pci230: tidy up irq request
    
    Clean up the irq request in the attach of this driver and remove the
    dev_{level} noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 58e7a43586e6..48a0f527b431 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2633,7 +2633,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	unsigned long iobase1, iobase2;
 	/* PCI230's I/O spaces 1 and 2 respectively. */
-	int irq_hdl, rc;
+	int rc;
 
 	comedi_set_hw_dev(dev, &pci_dev->dev);
 
@@ -2705,16 +2705,12 @@ static int pci230_attach_common(struct comedi_device *dev,
 	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
 	     dev->iobase + PCI230_ADCCON);
-	/* Register the interrupt handler. */
-	irq_hdl = request_irq(pci_dev->irq, pci230_interrupt,
-			      IRQF_SHARED, "amplc_pci230", dev);
-	if (irq_hdl < 0) {
-		dev_warn(dev->class_dev,
-			 "unable to register irq %u, commands will not be available\n",
-			 pci_dev->irq);
-	} else {
-		dev->irq = pci_dev->irq;
-		dev_dbg(dev->class_dev, "registered irq %u\n", pci_dev->irq);
+
+	if (pci_dev->irq) {
+		rc = request_irq(pci_dev->irq, pci230_interrupt, IRQF_SHARED,
+				 dev->board_name, dev);
+		if (rc == 0)
+			dev->irq = pci_dev->irq;
 	}
 
 	rc = comedi_alloc_subdevices(dev, 3);
@@ -2730,14 +2726,14 @@ static int pci230_attach_common(struct comedi_device *dev,
 	s->range_table = &pci230_ai_range;
 	s->insn_read = &pci230_ai_rinsn;
 	s->len_chanlist = 256;	/* but there are restrictions. */
-	/* Only register commands if the interrupt handler is installed. */
-	if (irq_hdl == 0) {
+	if (dev->irq) {
 		dev->read_subdev = s;
 		s->subdev_flags |= SDF_CMD_READ;
 		s->do_cmd = &pci230_ai_cmd;
 		s->do_cmdtest = &pci230_ai_cmdtest;
 		s->cancel = pci230_ai_cancel;
 	}
+
 	s = &dev->subdevices[1];
 	/* analog output subdevice */
 	if (thisboard->ao_chans > 0) {
@@ -2749,9 +2745,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 		s->insn_write = &pci230_ao_winsn;
 		s->insn_read = &pci230_ao_rinsn;
 		s->len_chanlist = thisboard->ao_chans;
-		/* Only register commands if the interrupt handler is
-		 * installed. */
-		if (irq_hdl == 0) {
+		if (dev->irq) {
 			dev->write_subdev = s;
 			s->subdev_flags |= SDF_CMD_WRITE;
 			s->do_cmd = &pci230_ao_cmd;
@@ -2761,6 +2755,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}
+
 	s = &dev->subdevices[2];
 	/* digital i/o subdevice */
 	if (thisboard->have_dio) {

commit 41e043fcfa2236bb2c4a8335eb09f4c8cee224b3
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 3 08:26:00 2013 +0900

    staging: remove DEFINE_PCI_DEVICE_TABLE macro
    
    Don't use DEFINE_PCI_DEVICE_TABLE macro, because this macro
    is not preferred.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index e11d7cec11e6..58e7a43586e6 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2852,7 +2852,7 @@ static int amplc_pci230_pci_probe(struct pci_dev *dev,
 				      id->driver_data);
 }
 
-static DEFINE_PCI_DEVICE_TABLE(amplc_pci230_pci_table) = {
+static const struct pci_device_id amplc_pci230_pci_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI230) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI260) },
 	{ 0 }

commit 2ec3839416e34ebf8103458f2fa64db53b5f13bd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 22 10:47:01 2013 -0700

    staging: comedi: amplc_pci230: remove use of DPRINTK
    
    Use dev_dbg() instead of the DPRINTK macro to output the comedi
    debugging information.
    
    The dev_dbg() will prefix the messages appropriately so remove the
    "comedi%d: amplc_pci230: " portion and use __func__ to show the
    actual function name for debugging.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a97bbd6ca3db..e11d7cec11e6 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -818,9 +818,9 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 	if (aref == AREF_DIFF) {
 		/* Differential. */
 		if (chan >= s->n_chan / 2) {
-			DPRINTK("comedi%d: amplc_pci230: ai_rinsn: "
-				"differential channel number out of range "
-				"0 to %u\n", dev->minor, (s->n_chan / 2) - 1);
+			dev_dbg(dev->class_dev,
+				"%s: differential channel number out of range 0 to %u\n",
+				__func__, (s->n_chan / 2) - 1);
 			return -EINVAL;
 		}
 	}
@@ -1092,14 +1092,14 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 		if (errors != 0) {
 			err++;
 			if ((errors & seq_err) != 0) {
-				DPRINTK("comedi%d: amplc_pci230: ao_cmdtest: "
-					"channel numbers must increase\n",
-					dev->minor);
+				dev_dbg(dev->class_dev,
+					"%s: channel numbers must increase\n",
+					__func__);
 			}
 			if ((errors & range_err) != 0) {
-				DPRINTK("comedi%d: amplc_pci230: ao_cmdtest: "
-					"channels must have the same range\n",
-					dev->minor);
+				dev_dbg(dev->class_dev,
+					"%s: channels must have the same range\n",
+					__func__);
 			}
 		}
 	}
@@ -1835,33 +1835,29 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 		if (errors != 0) {
 			err++;
 			if ((errors & seq_err) != 0) {
-				DPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "
-					"channel numbers must increase or "
-					"sequence must repeat exactly\n",
-					dev->minor);
+				dev_dbg(dev->class_dev,
+					"%s: channel numbers must increase or sequence must repeat exactly\n",
+					__func__);
 			}
 			if ((errors & rangepair_err) != 0) {
-				DPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "
-					"single-ended channel pairs must "
-					"have the same range\n", dev->minor);
+				dev_dbg(dev->class_dev,
+					"%s: single-ended channel pairs must have the same range\n",
+					__func__);
 			}
 			if ((errors & polarity_err) != 0) {
-				DPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "
-					"channel sequence ranges must be all "
-					"bipolar or all unipolar\n",
-					dev->minor);
+				dev_dbg(dev->class_dev,
+					"%s: channel sequence ranges must be all bipolar or all unipolar\n",
+					__func__);
 			}
 			if ((errors & aref_err) != 0) {
-				DPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "
-					"channel sequence analogue references "
-					"must be all the same (single-ended "
-					"or differential)\n", dev->minor);
+				dev_dbg(dev->class_dev,
+					"%s: channel sequence analogue references must be all the same (single-ended or differential)\n",
+					__func__);
 			}
 			if ((errors & diffchan_err) != 0) {
-				DPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "
-					"differential channel number out of "
-					"range 0 to %u\n", dev->minor,
-					(s->n_chan / 2) - 1);
+				dev_dbg(dev->class_dev,
+					"%s: differential channel number out of range 0 to %u\n",
+					__func__, (s->n_chan / 2) - 1);
 			}
 			if ((errors & buggy_chan0_err) != 0) {
 				dev_info(dev->class_dev,

commit 863e52769d43a5adbd1de99c70d6db0759529970
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:13 2013 +0100

    staging: comedi: amplc_pci230: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Replace all uses of `short` to handle sample values in the
    "amplc_pci230" driver with `unsigned short` for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 43059c25d5ea..a97bbd6ca3db 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -573,14 +573,14 @@ static const struct comedi_lrange pci230_ao_range = { 2, {
 /* PCI230 daccon bipolar flag for each analogue output range. */
 static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
 
-static short pci230_ai_read(struct comedi_device *dev)
+static unsigned short pci230_ai_read(struct comedi_device *dev)
 {
 	const struct pci230_board *thisboard = comedi_board(dev);
 	struct pci230_private *devpriv = dev->private;
-	short data;
+	unsigned short data;
 
 	/* Read sample. */
-	data = (short)inw(dev->iobase + PCI230_ADCDATA);
+	data = inw(dev->iobase + PCI230_ADCDATA);
 	/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
 	 * four bits reserved for expansion). */
 	/* PCI230+ is 16 bit AI. */
@@ -595,7 +595,7 @@ static short pci230_ai_read(struct comedi_device *dev)
 }
 
 static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
-						    short datum)
+						    unsigned short datum)
 {
 	const struct pci230_board *thisboard = comedi_board(dev);
 	struct pci230_private *devpriv = dev->private;
@@ -609,11 +609,12 @@ static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
 	 * four bits reserved for expansion). */
 	/* PCI230+ is also 12 bit AO. */
 	datum <<= (16 - thisboard->ao_bits);
-	return (unsigned short)datum;
+	return datum;
 }
 
 static inline void pci230_ao_write_nofifo(struct comedi_device *dev,
-					  short datum, unsigned int chan)
+					  unsigned short datum,
+					  unsigned int chan)
 {
 	struct pci230_private *devpriv = dev->private;
 
@@ -627,8 +628,8 @@ static inline void pci230_ao_write_nofifo(struct comedi_device *dev,
 								PCI230_DACOUT2));
 }
 
-static inline void pci230_ao_write_fifo(struct comedi_device *dev, short datum,
-					unsigned int chan)
+static inline void pci230_ao_write_fifo(struct comedi_device *dev,
+					unsigned short datum, unsigned int chan)
 {
 	struct pci230_private *devpriv = dev->private;
 
@@ -1165,7 +1166,7 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
 	struct pci230_private *devpriv = dev->private;
-	short data;
+	unsigned short data;
 	int i, ret;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1258,7 +1259,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 		/* Process scans. */
 		for (n = 0; n < num_scans; n++) {
 			for (i = 0; i < cmd->chanlist_len; i++) {
-				short datum;
+				unsigned short datum;
 
 				comedi_buf_get(async, &datum);
 				pci230_ao_write_fifo(dev, datum,

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 147702b51872..43059c25d5ea 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -184,6 +184,7 @@ Support for PCI230+/260+, more triggered scan functionality, and workarounds
 for (or detection of) various hardware problems added by Ian Abbott.
 */
 
+#include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 846d6448fa4d..147702b51872 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2615,10 +2615,9 @@ static int pci230_alloc_private(struct comedi_device *dev)
 {
 	struct pci230_private *devpriv;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	spin_lock_init(&devpriv->isr_spinlock);
 	spin_lock_init(&devpriv->res_spinlock);

commit 588ba6dc5fb4bdca47a3da38c2718fbb82d3eee1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 11 11:32:29 2013 -0700

    staging: comedi: drivers: let core handle freeing s->private
    
    Introduce a new subdevice runflags, SRF_FREE_SPRIV, and a new helper
    function, comedi_set_spriv(), that the drivers can use to set the
    comedi_subdevice private data pointer. The helper function will also
    set SRF_FREE_SPRIV to allow the comedi core to automatically free the
    subdevice private data during the cleanup_device() stage of the detach.
    
    Currently s->private is only allocated by the 8255, addi_watchdog,
    amplc_dio200_common, and ni_65xx drivers. All users of those drivers
    can then have the comedi_spriv_free() calls removed and in many cases
    the (*detach) can then simply be the appropriate comedi core provided
    function.
    
    The ni_65xx driver uses a helper function, ni_65xx_alloc_subdevice_private(),
    to allocate the private data. Refactor the function to return an errno
    or call comedi_set_spriv() instead of returning a pointer to the private
    data and requiring the caller to handle it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 08ff12837e00..846d6448fa4d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2830,7 +2830,6 @@ static void pci230_detach(struct comedi_device *dev)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 
-	comedi_spriv_free(dev, 2);
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	comedi_pci_disable(dev);

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 49200fbd60b9..08ff12837e00 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -16,10 +16,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   */
 /*
 Driver: amplc_pci230

commit 2f69915c728c3be41e12dbbbdd4eeb8d3388d58c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 15 16:41:57 2013 -0700

    staging: comedi: introduce, and use, comedi_spriv_free()
    
    The comedi_subdevice 'private' variable is a void * that is available
    for the subdevice to use in manner. It's common in comedi drivers for
    the driver to allocate memory for a subdevice and store the pointer
    to that memory in the 'private' variable. It's then the responsibility
    of the driver to free that memory when the device is detached.
    
    Due to how the attach/detach works in comedi, the drivers need to do
    some sanity checking before they can free the allocated memory during
    the detach.
    
    Introduce a helper function, comedi_spriv_free(), to handle freeing
    the private data allocated for a subdevice. This allows moving all the
    sanity checks into the helper function and makes it safe to call
    with any context. It also allows removing some of the boilerplate
    code in the (*detach) functions.
    
    Remove the subdev_8255_cleanup() export in the 8255 subdevice driver
    as well as the addi_watchdog_cleanup() export in the addi_watchdog
    driver and use the new helper instead.
    
    The amplc_dio200_common driver uses a number of local helper functions
    to free the private data for it's subdevices. Remove those as well and
    use the new helper.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index b6e4af444ef5..49200fbd60b9 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2832,11 +2832,9 @@ static int pci230_auto_attach(struct comedi_device *dev,
 
 static void pci230_detach(struct comedi_device *dev)
 {
-	const struct pci230_board *thisboard = comedi_board(dev);
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 
-	if (dev->subdevices && thisboard->have_dio)
-		subdev_8255_cleanup(dev, &dev->subdevices[2]);
+	comedi_spriv_free(dev, 2);
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	comedi_pci_disable(dev);

commit 818f569fe930c5b8a05d1a44ece3c63c99c13c88
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:36:31 2013 -0700

    staging: comedi_pci: pass comedi_device to comedi_pci_enable()
    
    Make comedi_pci_enable() use the same parameter type as
    comedi_pci_disable(). This also allows comedi_pci_enable
    to automatically determine the resource name passed to
    pci_request_regions().
    
    Make sure the errno value returned is passed on instead of
    assuming an errno. Also, remove any kernel noise that is
    generated when the call fails.
    
    The National Instruments drivers that use the mite module
    currently enable the PCI device in the mite module. For
    those drivers move the call to comedi_pci_enable into the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 1bfe893b4cb2..b6e4af444ef5 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2645,12 +2645,11 @@ static int pci230_attach_common(struct comedi_device *dev,
 	comedi_set_hw_dev(dev, &pci_dev->dev);
 
 	dev->board_name = thisboard->name;
-	/* Enable PCI device and reserve I/O spaces. */
-	if (comedi_pci_enable(pci_dev, "amplc_pci230") < 0) {
-		dev_err(dev->class_dev,
-			"failed to enable PCI device and request regions\n");
-		return -EIO;
-	}
+
+	rc = comedi_pci_enable(dev);
+	if (rc)
+		return rc;
+
 	/* Read base addresses of the PCI230's two I/O regions from PCI
 	 * configuration register. */
 	iobase1 = pci_resource_start(pci_dev, 2);

commit 7f072f54ae5dc9965cbe450419b1389d13e2b849
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:35:51 2013 -0700

    staging: comedi_pci: make comedi_pci_disable() safe to call
    
    Currently all the comedi PCI drivers need to do some checking in
    their (*detach) before calling comedi_pci_disable() in order to
    make sure the PCI device has actually be enabled.
    
    Change the parameter passed to comedi_pci_disable() from a struct
    pci_dev pointer to a comedi_device pointer and have comedi_pci_disable()
    handle all the checking.
    
    For most comedi PCI drivers this also allows removing the local
    variable holding the pointer to the pci_dev. For some of the drivers
    comedi_pci_disable can now be used directly as the (*detach) function.
    
    The National Instruments drivers that use the mite module currently
    enable/disable the PCI device in the mite module. For those drivers
    move the call to comedi_pci_disable into the driver and make sure
    dev->iobase is set to a non-zero value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 70074b512130..1bfe893b4cb2 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2840,11 +2840,9 @@ static void pci230_detach(struct comedi_device *dev)
 		subdev_8255_cleanup(dev, &dev->subdevices[2]);
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (pcidev) {
-		if (dev->iobase)
-			comedi_pci_disable(pcidev);
+	comedi_pci_disable(dev);
+	if (pcidev)
 		pci_dev_put(pcidev);
-	}
 }
 
 static struct comedi_driver amplc_pci230_driver = {

commit b8f4ac237e382accd4b30c75043939f7ed9e79a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 09:53:41 2013 -0700

    staging: comedi: comedi_pci: change the comedi_pci_auto_config() 'context'
    
    The comedi_pci_auto_config() function is used to allow the PCI driver
    (*probe) function to automatically call the comedi driver (*auto_attach).
    This allows the comedi driver to be part of the PnP process when the
    PCI device is detected.
    
    Currently the comedi_pci_auto_config() always passes a 'context' of '0'
    to comedi_auto_config(). This makes the 'context' a bit useless.
    
    Modify comedi_pci_auto_config() to allow the comedi pci drivers to pass
    a 'context' from the PCI driver.
    
    Make all the comedi pci drivers pass the pci_device_id 'driver_data' as
    the 'context'. Since none of the comedi pci drivers currently set the
    'driver_data' the 'context' will still be '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index e2244c6e536b..70074b512130 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2859,9 +2859,10 @@ static struct comedi_driver amplc_pci230_driver = {
 };
 
 static int amplc_pci230_pci_probe(struct pci_dev *dev,
-					    const struct pci_device_id *ent)
+				  const struct pci_device_id *id)
 {
-	return comedi_pci_auto_config(dev, &amplc_pci230_driver);
+	return comedi_pci_auto_config(dev, &amplc_pci230_driver,
+				      id->driver_data);
 }
 
 static DEFINE_PCI_DEVICE_TABLE(amplc_pci230_pci_table) = {

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 2440596a3ec4..e2244c6e536b 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -188,11 +188,12 @@ Support for PCI230+/260+, more triggered scan functionality, and workarounds
 for (or detection of) various hardware problems added by Ian Abbott.
 */
 
-#include "../comedidev.h"
-
+#include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 
+#include "../comedidev.h"
+
 #include "comedi_fc.h"
 #include "8253.h"
 #include "8255.h"

commit 9901a4d75d007686e8f6473189cafc4b216b7449
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Tue Jan 22 23:40:03 2013 +0100

    staging/comedi: Use comedi_pci_auto_unconfig directly for pci_driver.remove
    
    (Almost) all comedi pci drivers have some wrapper for their
    pci_driver.remove function which simply calls comedi_pci_auto_unconfig
    which has the same function prototype as the wrapper.
    
    -> we can remove these wrappers and call comedi_pci_auto_unconfig
    directly. This removes a lot some boilerplate code and saves some bytes.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 366c68be56bd..2440596a3ec4 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2863,11 +2863,6 @@ static int amplc_pci230_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &amplc_pci230_driver);
 }
 
-static void amplc_pci230_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
 static DEFINE_PCI_DEVICE_TABLE(amplc_pci230_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI230) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI260) },
@@ -2879,7 +2874,7 @@ static struct pci_driver amplc_pci230_pci_driver = {
 	.name		= "amplc_pci230",
 	.id_table	= amplc_pci230_pci_table,
 	.probe		= amplc_pci230_pci_probe,
-	.remove		= amplc_pci230_pci_remove
+	.remove		= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(amplc_pci230_driver, amplc_pci230_pci_driver);
 

commit 53b800198592b0ff96577ecc5f116f7d902a4362
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:36 2012 -0500

    staging: comedi: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index c16a45a83bb0..366c68be56bd 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2863,7 +2863,7 @@ static int amplc_pci230_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &amplc_pci230_driver);
 }
 
-static void __devexit amplc_pci230_pci_remove(struct pci_dev *dev)
+static void amplc_pci230_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }

commit a690b7e535f2f97a3a05ee570715abeb60a8910f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:58 2012 -0500

    staging: comedi: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index d0ea06992520..c16a45a83bb0 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2801,7 +2801,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return pci230_attach_common(dev, pci_dev);
 }
 
-static int __devinit pci230_auto_attach(struct comedi_device *dev,
+static int pci230_auto_attach(struct comedi_device *dev,
 					unsigned long context_unused)
 {
 	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
@@ -2857,7 +2857,7 @@ static struct comedi_driver amplc_pci230_driver = {
 	.num_names	= ARRAY_SIZE(pci230_boards),
 };
 
-static int __devinit amplc_pci230_pci_probe(struct pci_dev *dev,
+static int amplc_pci230_pci_probe(struct pci_dev *dev,
 					    const struct pci_device_id *ent)
 {
 	return comedi_pci_auto_config(dev, &amplc_pci230_driver);

commit a471eace7baa40cdf16d3f26b2f78ddce613ca8f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:37 2012 -0500

    staging: comedi: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 7cc48ec1d5f8..d0ea06992520 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2879,7 +2879,7 @@ static struct pci_driver amplc_pci230_pci_driver = {
 	.name		= "amplc_pci230",
 	.id_table	= amplc_pci230_pci_table,
 	.probe		= amplc_pci230_pci_probe,
-	.remove		= __devexit_p(amplc_pci230_pci_remove)
+	.remove		= amplc_pci230_pci_remove
 };
 module_comedi_pci_driver(amplc_pci230_driver, amplc_pci230_pci_driver);
 

commit 670c475cf02d1fe715c61a605eadb1a8776a8c4c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:53:08 2012 -0700

    staging: comedi: amplc_pci230: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of pci230_{ao,ai}_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index ef87946e6422..7cc48ec1d5f8 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -999,14 +999,10 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* Step 3: make sure arguments are trivially compatible.
-	 * "invalid argument" returned by comedilib to user mode process
-	 * if this fails. */
+	/* Step 3: check if arguments are trivially valid */
+
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
 #define MAX_SPEED_AO	8000	/* 8000 ns => 125 kHz */
 #define MIN_SPEED_AO	4294967295u	/* 4294967295ns = 4.29s */
 			/*- Comedi limit due to unsigned int cmd.  Driver limit
@@ -1015,14 +1011,10 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
-		if (cmd->scan_begin_arg < MAX_SPEED_AO) {
-			cmd->scan_begin_arg = MAX_SPEED_AO;
-			err++;
-		}
-		if (cmd->scan_begin_arg > MIN_SPEED_AO) {
-			cmd->scan_begin_arg = MIN_SPEED_AO;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+						 MAX_SPEED_AO);
+		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
+						 MIN_SPEED_AO);
 		break;
 	case TRIG_EXT:
 		/* External trigger - for PCI230+ hardware version 2 onwards. */
@@ -1030,37 +1022,27 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      ~CR_FLAGS_MASK);
-			err++;
+			err |= -EINVAL;
 		}
 		/* The only flags allowed are CR_EDGE and CR_INVERT.  The
 		 * CR_EDGE flag is ignored. */
 		if ((cmd->scan_begin_arg
 		     & (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {
-			cmd->scan_begin_arg =
-			    COMBINE(cmd->scan_begin_arg, 0,
-				    CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
-			err++;
+			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
+						      CR_FLAGS_MASK &
+						      ~(CR_EDGE | CR_INVERT));
+			err |= -EINVAL;
 		}
 		break;
 	default:
-		if (cmd->scan_begin_arg != 0) {
-			cmd->scan_begin_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 		break;
 	}
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-	if (cmd->stop_src == TRIG_NONE) {
-		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	if (cmd->stop_src == TRIG_NONE)
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -1618,14 +1600,10 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* Step 3: make sure arguments are trivially compatible.
-	 * "invalid argument" returned by comedilib to user mode process
-	 * if this fails. */
+	/* Step 3: check if arguments are trivially valid */
+
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
 #define MAX_SPEED_AI_SE		3200	/* PCI230 SE:   3200 ns => 312.5 kHz */
 #define MAX_SPEED_AI_DIFF	8000	/* PCI230 DIFF: 8000 ns => 125 kHz */
 #define MAX_SPEED_AI_PLUS	4000	/* PCI230+:     4000 ns => 250 kHz */
@@ -1656,14 +1634,10 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 			max_speed_ai = MAX_SPEED_AI_PLUS;
 		}
 
-		if (cmd->convert_arg < max_speed_ai) {
-			cmd->convert_arg = max_speed_ai;
-			err++;
-		}
-		if (cmd->convert_arg > MIN_SPEED_AI) {
-			cmd->convert_arg = MIN_SPEED_AI;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+						 max_speed_ai);
+		err |= cfc_check_trigger_arg_max(&cmd->convert_arg,
+						 MIN_SPEED_AI);
 	} else if (cmd->convert_src == TRIG_EXT) {
 		/*
 		 * external trigger
@@ -1678,46 +1652,33 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 			if ((cmd->convert_arg & ~CR_FLAGS_MASK) != 0) {
 				cmd->convert_arg = COMBINE(cmd->convert_arg, 0,
 							   ~CR_FLAGS_MASK);
-				err++;
+				err |= -EINVAL;
 			}
 			/* The only flags allowed are CR_INVERT and CR_EDGE.
 			 * CR_EDGE is required. */
 			if ((cmd->convert_arg & (CR_FLAGS_MASK & ~CR_INVERT))
 			    != CR_EDGE) {
 				/* Set CR_EDGE, preserve CR_INVERT. */
-				cmd->convert_arg =
-				    COMBINE(cmd->start_arg, (CR_EDGE | 0),
-					    CR_FLAGS_MASK & ~CR_INVERT);
-				err++;
+				cmd->convert_arg = COMBINE(cmd->start_arg,
+							   (CR_EDGE | 0),
+							   CR_FLAGS_MASK &
+							   ~CR_INVERT);
+				err |= -EINVAL;
 			}
 		} else {
 			/* Backwards compatibility with previous versions. */
 			/* convert_arg == 0 => trigger on -ve edge. */
 			/* convert_arg == 1 => trigger on +ve edge. */
-			if (cmd->convert_arg > 1) {
-				/* Default to trigger on +ve edge. */
-				cmd->convert_arg = 1;
-				err++;
-			}
+			err |= cfc_check_trigger_arg_max(&cmd->convert_arg, 1);
 		}
 	} else {
-		if (cmd->convert_arg != 0) {
-			cmd->convert_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 	}
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->stop_src == TRIG_NONE) {
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	if (cmd->stop_src == TRIG_NONE)
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_EXT) {
 		/* external "trigger" to begin each scan
@@ -1726,24 +1687,21 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      ~CR_FLAGS_MASK);
-			err++;
+			err |= -EINVAL;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
 		if ((cmd->scan_begin_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      CR_FLAGS_MASK & ~CR_EDGE);
-			err++;
+			err |= -EINVAL;
 		}
 	} else if (cmd->scan_begin_src == TRIG_TIMER) {
 		/* N.B. cmd->convert_arg is also TRIG_TIMER */
 		if (!pci230_ai_check_scan_period(cmd))
-			err++;
+			err |= -EINVAL;
 
 	} else {
-		if (cmd->scan_begin_arg != 0) {
-			cmd->scan_begin_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 	}
 
 	if (err)

commit 750af5e568d060ec6994cdcb4e86cdddfcd473c0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 30 13:30:04 2012 +0000

    staging: comedi/drivers: use auto_attach instead of attach_pci
    
    Change comedi drivers for PCI boards to use the new `auto_attach()`
    method instead of the `attach_pci()` method.  I plan to remove the
    `attach_pci()` and `attach_usb()` methods from `struct comedi_driver`
    once nothing is using them.
    
    Tag the functions with `__devinit` where they are not already so tagged,
    as they are only called during PCI probe.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index db67c8313ca8..ef87946e6422 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2672,7 +2672,7 @@ static int pci230_alloc_private(struct comedi_device *dev)
 	return 0;
 }
 
-/* Common part of attach and attach_pci. */
+/* Common part of attach and auto_attach. */
 static int pci230_attach_common(struct comedi_device *dev,
 				struct pci_dev *pci_dev)
 {

commit 1ed1b3df2e02b8f890e0f3b9d3dad0f39e3418a8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Sat Oct 27 21:44:18 2012 +0100

    staging: comedi: amplc_pci230: use auto_attach() hook
    
    Use the new `auto_attach()` hook in the `struct comedi_driver` instead
    of the old `attach_pci()` hook.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index d66d7d797f7c..db67c8313ca8 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2843,9 +2843,10 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return pci230_attach_common(dev, pci_dev);
 }
 
-static int __devinit pci230_attach_pci(struct comedi_device *dev,
-				       struct pci_dev *pci_dev)
+static int __devinit pci230_auto_attach(struct comedi_device *dev,
+					unsigned long context_unused)
 {
+	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
 	int rc;
 
 	dev_info(dev->class_dev, "amplc_pci230: attach pci %s\n",
@@ -2891,7 +2892,7 @@ static struct comedi_driver amplc_pci230_driver = {
 	.driver_name	= "amplc_pci230",
 	.module		= THIS_MODULE,
 	.attach		= pci230_attach,
-	.attach_pci	= pci230_attach_pci,
+	.auto_attach	= pci230_auto_attach,
 	.detach		= pci230_detach,
 	.board_name	= &pci230_boards[0].name,
 	.offset		= sizeof(pci230_boards[0]),

commit 2847ff5d1b63496c2e3eedb8efad2752cc2e195d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Oct 24 18:14:40 2012 -0700

    staging: comedi: comedidev.h: add PCI_VENDOR_ID_AMPLICON
    
    Add a define for the Amplicon Liveline Limited PCI vendor id.
    Remove the duplicates in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 2675eefe8b5a..d66d7d797f7c 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -198,7 +198,6 @@ for (or detection of) various hardware problems added by Ian Abbott.
 #include "8255.h"
 
 /* PCI230 PCI configuration register information */
-#define PCI_VENDOR_ID_AMPLICON 0x14dc
 #define PCI_DEVICE_ID_PCI230 0x0000
 #define PCI_DEVICE_ID_PCI260 0x0006
 #define PCI_DEVICE_ID_INVALID 0xffff

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index cf454b9cb292..2675eefe8b5a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2660,12 +2660,11 @@ static struct pci_dev *pci230_find_pci_dev(struct comedi_device *dev,
 static int pci230_alloc_private(struct comedi_device *dev)
 {
 	struct pci230_private *devpriv;
-	int err;
 
-	err = alloc_private(dev, sizeof(*devpriv));
-	if (err)
-		return err;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	spin_lock_init(&devpriv->isr_spinlock);
 	spin_lock_init(&devpriv->res_spinlock);

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index bd8fb876ce2e..cf454b9cb292 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2662,13 +2662,11 @@ static int pci230_alloc_private(struct comedi_device *dev)
 	struct pci230_private *devpriv;
 	int err;
 
-	/* sets dev->private to allocated memory */
-	err = alloc_private(dev, sizeof(struct pci230_private));
-	if (err) {
-		dev_err(dev->class_dev, "error! out of memory!\n");
+	err = alloc_private(dev, sizeof(*devpriv));
+	if (err)
 		return err;
-	}
 	devpriv = dev->private;
+
 	spin_lock_init(&devpriv->isr_spinlock);
 	spin_lock_init(&devpriv->res_spinlock);
 	spin_lock_init(&devpriv->ai_stop_spinlock);
@@ -2836,9 +2834,11 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	dev_info(dev->class_dev, "amplc_pci230: attach %s %d,%d\n",
 		 thisboard->name, it->options[0], it->options[1]);
-	rc = pci230_alloc_private(dev); /* sets dev->private */
+
+	rc = pci230_alloc_private(dev);
 	if (rc)
 		return rc;
+
 	pci_dev = pci230_find_pci_dev(dev, it);
 	if (!pci_dev)
 		return -EIO;
@@ -2852,9 +2852,11 @@ static int __devinit pci230_attach_pci(struct comedi_device *dev,
 
 	dev_info(dev->class_dev, "amplc_pci230: attach pci %s\n",
 		 pci_name(pci_dev));
-	rc = pci230_alloc_private(dev); /* sets dev->private */
+
+	rc = pci230_alloc_private(dev);
 	if (rc)
 		return rc;
+
 	dev->board_ptr = pci230_find_pci_board(pci_dev);
 	if (dev->board_ptr == NULL) {
 		dev_err(dev->class_dev,

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 4c9f1314ea1d..bd8fb876ce2e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -193,6 +193,7 @@ for (or detection of) various hardware problems added by Ian Abbott.
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 
+#include "comedi_fc.h"
 #include "8253.h"
 #include "8255.h"
 
@@ -958,23 +959,11 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 	int err = 0;
 	unsigned int tmp;
 
-	/* cmdtest tests a particular command to see if it is valid.
-	 * Using the cmdtest ioctl, a user can create a valid cmd
-	 * and then have it executes by the cmd ioctl.
-	 *
-	 * cmdtest returns 1,2,3,4 or 0, depending on which tests
-	 * the command passes. */
+	/* Step 1 : check if triggers are trivially valid */
 
-	/* Step 1: make sure trigger sources are trivially valid.
-	 * "invalid source" returned by comedilib to user mode process
-	 * if this fails. */
-
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_INT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT);
 
-	tmp = cmd->scan_begin_src;
+	tmp = TRIG_TIMER | TRIG_INT;
 	if ((thisboard->min_hwver > 0) && (devpriv->hwver >= 2)) {
 		/*
 		 * For PCI230+ hardware version 2 onwards, allow external
@@ -990,46 +979,23 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 		 * scan_begin_src==TRIG_EXT support to be a bonus rather than a
 		 * guarantee!
 		 */
-		cmd->scan_begin_src &= TRIG_TIMER | TRIG_INT | TRIG_EXT;
-	} else {
-		cmd->scan_begin_src &= TRIG_TIMER | TRIG_INT;
+		tmp |= TRIG_EXT;
 	}
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, tmp);
 
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* Step 2: make sure trigger sources are unique and mutually compatible
-	 * "source conflict" returned by comedilib to user mode process
-	 * if this fails. */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/* these tests are true if more than one _src bit is set */
-	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
-		err++;
-	if ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)
-		err++;
-	if ((cmd->convert_src & (cmd->convert_src - 1)) != 0)
-		err++;
-	if ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)
-		err++;
-	if ((cmd->stop_src & (cmd->stop_src - 1)) != 0)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;
@@ -1610,75 +1576,45 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 	int err = 0;
 	unsigned int tmp;
 
-	/* cmdtest tests a particular command to see if it is valid.
-	 * Using the cmdtest ioctl, a user can create a valid cmd
-	 * and then have it executes by the cmd ioctl.
-	 *
-	 * cmdtest returns 1,2,3,4,5 or 0, depending on which tests
-	 * the command passes. */
+	/* Step 1 : check if triggers are trivially valid */
 
-	/* Step 1: make sure trigger sources are trivially valid.
-	 * "invalid source" returned by comedilib to user mode process
-	 * if this fails. */
-
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_INT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
 
-	tmp = cmd->scan_begin_src;
-	/* Unfortunately, we cannot trigger a scan off an external source
-	 * on the PCI260 board, since it uses the PPIC0 (DIO) input, which
-	 * isn't present on the PCI260.  For PCI260+ we can use the
-	 * EXTTRIG/EXTCONVCLK input on pin 17 instead. */
+	tmp = TRIG_FOLLOW | TRIG_TIMER | TRIG_INT;
 	if ((thisboard->have_dio) || (thisboard->min_hwver > 0)) {
-		cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_INT
-		    | TRIG_EXT;
-	} else {
-		cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_INT;
+		/*
+		 * Unfortunately, we cannot trigger a scan off an external
+		 * source on the PCI260 board, since it uses the PPIC0 (DIO)
+		 * input, which isn't present on the PCI260.  For PCI260+
+		 * we can use the EXTTRIG/EXTCONVCLK input on pin 17 instead.
+		 */
+		tmp |= TRIG_EXT;
 	}
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_TIMER | TRIG_INT | TRIG_EXT;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, tmp);
+	err |= cfc_check_trigger_src(&cmd->convert_src,
+					TRIG_TIMER | TRIG_INT | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* Step 2: make sure trigger sources are unique and mutually compatible
-	 * "source conflict" returned by comedilib to user mode process
-	 * if this fails. */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/* these tests are true if more than one _src bit is set */
-	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
-		err++;
-	if ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)
-		err++;
-	if ((cmd->convert_src & (cmd->convert_src - 1)) != 0)
-		err++;
-	if ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)
-		err++;
-	if ((cmd->stop_src & (cmd->stop_src - 1)) != 0)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
-	/* If scan_begin_src is not TRIG_FOLLOW, then a monostable will be
-	 * set up to generate a fixed number of timed conversion pulses. */
+	/*
+	 * If scan_begin_src is not TRIG_FOLLOW, then a monostable will be
+	 * set up to generate a fixed number of timed conversion pulses.
+	 */
 	if ((cmd->scan_begin_src != TRIG_FOLLOW)
 	    && (cmd->convert_src != TRIG_TIMER))
-		err++;
+		err |= -EINVAL;
 
 	if (err)
 		return 2;

commit 5bf4a7a7081204eca004e04b0da726513f49142c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:30:47 2012 -0700

    staging: comedi: amplc_pci230: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 66e74bd12267..4c9f1314ea1d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2838,7 +2838,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 	if (rc)
 		return rc;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	/* analog input subdevice */
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;
@@ -2855,7 +2855,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 		s->do_cmdtest = &pci230_ai_cmdtest;
 		s->cancel = pci230_ai_cancel;
 	}
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	/* analog output subdevice */
 	if (thisboard->ao_chans > 0) {
 		s->type = COMEDI_SUBD_AO;
@@ -2878,7 +2878,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	/* digital i/o subdevice */
 	if (thisboard->have_dio) {
 		rc = subdev_8255_init(dev, s, NULL,
@@ -2941,7 +2941,7 @@ static void pci230_detach(struct comedi_device *dev)
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 
 	if (dev->subdevices && thisboard->have_dio)
-		subdev_8255_cleanup(dev, dev->subdevices + 2);
+		subdev_8255_cleanup(dev, &dev->subdevices[2]);
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (pcidev) {

commit 4375e61ed21d629fe922b3e5591ad6588f715137
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 3 16:39:42 2012 +0100

    staging: comedi: amplc_pci230: Fix PCI ref count
    
    When attaching a PCI device manually via the comedi driver `attach` hook
    (`pci230_attach()`) (called by the comedi core for the `COMEDI_DEVCONFIG`
    ioctl), its reference count is incremented in the `for_each_pci_dev`
    loop (in `pci230_find_pci_dev()`).  It is decremented when the `detach`
    hook (`pci230_detach()`) is called to detach the device.  However, when
    the PCI device is attached automatically via the `attach_pci` hook
    (`pci230_attach_pci()`, called at probe time via
    `comedi_pci_auto_config()`) it's reference count is not incremented so
    there will be an unmatched decrement when detaching the device.
    
    Increment the PCI device reference count in `pci230_attach_pci()` to
    correct the mismatch.
    
    Once support for manual configuration has been removed from this driver,
    the calls to `pci_dev_get()` and `pci_dev_put()` can be removed.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 1b67d0c61fa7..66e74bd12267 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2925,6 +2925,13 @@ static int __devinit pci230_attach_pci(struct comedi_device *dev,
 			"amplc_pci230: BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
+	/*
+	 * Need to 'get' the PCI device to match the 'put' in pci230_detach().
+	 * TODO: Remove the pci_dev_get() and matching pci_dev_put() once
+	 * support for manual attachment of PCI devices via pci230_attach()
+	 * has been removed.
+	 */
+	pci_dev_get(pci_dev);
 	return pci230_attach_common(dev, pci_dev);
 }
 

commit c5866e7850e015b984aae4ad56998f6ced69af8e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jul 18 18:42:07 2012 -0700

    staging: comedi: amplc_pci230: store the pci_dev in the comedi_device
    
    Use the hw_dev pointer in the comedi_device struct to hold the
    pci_dev instead of carrying it in the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 0b09934d967f..1b67d0c61fa7 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -500,7 +500,6 @@ static const struct pci230_board pci230_boards[] = {
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.  */
 struct pci230_private {
-	struct pci_dev *pci_dev;
 	spinlock_t isr_spinlock;	/* Interrupt spin lock */
 	spinlock_t res_spinlock;	/* Shared resources spin lock */
 	spinlock_t ai_stop_spinlock;	/* Spin lock for stopping AI command */
@@ -2752,7 +2751,8 @@ static int pci230_attach_common(struct comedi_device *dev,
 	/* PCI230's I/O spaces 1 and 2 respectively. */
 	int irq_hdl, rc;
 
-	devpriv->pci_dev = pci_dev;
+	comedi_set_hw_dev(dev, &pci_dev->dev);
+
 	dev->board_name = thisboard->name;
 	/* Enable PCI device and reserve I/O spaces. */
 	if (comedi_pci_enable(pci_dev, "amplc_pci230") < 0) {
@@ -2823,16 +2823,15 @@ static int pci230_attach_common(struct comedi_device *dev,
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
 	     dev->iobase + PCI230_ADCCON);
 	/* Register the interrupt handler. */
-	irq_hdl = request_irq(devpriv->pci_dev->irq, pci230_interrupt,
+	irq_hdl = request_irq(pci_dev->irq, pci230_interrupt,
 			      IRQF_SHARED, "amplc_pci230", dev);
 	if (irq_hdl < 0) {
 		dev_warn(dev->class_dev,
 			 "unable to register irq %u, commands will not be available\n",
-			 devpriv->pci_dev->irq);
+			 pci_dev->irq);
 	} else {
-		dev->irq = devpriv->pci_dev->irq;
-		dev_dbg(dev->class_dev, "registered irq %u\n",
-			devpriv->pci_dev->irq);
+		dev->irq = pci_dev->irq;
+		dev_dbg(dev->class_dev, "registered irq %u\n", pci_dev->irq);
 	}
 
 	rc = comedi_alloc_subdevices(dev, 3);
@@ -2932,18 +2931,16 @@ static int __devinit pci230_attach_pci(struct comedi_device *dev,
 static void pci230_detach(struct comedi_device *dev)
 {
 	const struct pci230_board *thisboard = comedi_board(dev);
-	struct pci230_private *devpriv = dev->private;
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 
 	if (dev->subdevices && thisboard->have_dio)
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (devpriv) {
-		if (devpriv->pci_dev) {
-			if (dev->iobase)
-				comedi_pci_disable(devpriv->pci_dev);
-			pci_dev_put(devpriv->pci_dev);
-		}
+	if (pcidev) {
+		if (dev->iobase)
+			comedi_pci_disable(pcidev);
+		pci_dev_put(pcidev);
 	}
 }
 

commit 2605d35b439da85634db975d98bc7be76f9d563a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jul 18 18:41:47 2012 -0700

    staging: comedi: amplc_pci230: cleanup "find pci device" code
    
    For aesthetic reasons, rename the function and pass the
    comedi_devconfig struct instead of pre-parsing out the bus/slot
    information.
    
    Consolidate the dev_err messages when a pci device is not found.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 3d7f2cda980a..0b09934d967f 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2683,11 +2683,13 @@ static const struct pci230_board *pci230_find_pci_board(struct pci_dev *pci_dev)
 }
 
 /* Look for PCI device matching requested board name, bus and slot. */
-static struct pci_dev *pci230_find_pci(struct comedi_device *dev,
-				       int bus, int slot)
+static struct pci_dev *pci230_find_pci_dev(struct comedi_device *dev,
+					   struct comedi_devconfig *it)
 {
 	const struct pci230_board *thisboard = comedi_board(dev);
 	struct pci_dev *pci_dev = NULL;
+	int bus = it->options[0];
+	int slot = it->options[1];
 
 	for_each_pci_dev(pci_dev) {
 		/* Check vendor ID (same for all supported PCI boards). */
@@ -2707,23 +2709,16 @@ static struct pci_dev *pci230_find_pci(struct comedi_device *dev,
 				continue;
 			/* Replace wildcard board_ptr. */
 			dev->board_ptr = foundboard;
-			thisboard = comedi_board(dev);
 		} else {
 			/* Need to match a specific board. */
 			if (!pci230_match_pci_board(thisboard, pci_dev))
 				continue;
 		}
-		/* Found a matching PCI device. */
 		return pci_dev;
 	}
-	/* No matching PCI device found. */
-	if (bus || slot)
-		dev_err(dev->class_dev,
-			"error! no %s found at pci %02x:%02x\n",
-			thisboard->name, bus, slot);
-	else
-		dev_err(dev->class_dev,
-			"error! no %s found\n", thisboard->name);
+	dev_err(dev->class_dev,
+		"No supported board found! (req. bus %d, slot %d)\n",
+		bus, slot);
 	return NULL;
 }
 
@@ -2909,8 +2904,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	rc = pci230_alloc_private(dev); /* sets dev->private */
 	if (rc)
 		return rc;
-	/* Find card. */
-	pci_dev = pci230_find_pci(dev, it->options[0], it->options[1]);
+	pci_dev = pci230_find_pci_dev(dev, it);
 	if (!pci_dev)
 		return -EIO;
 	return pci230_attach_common(dev, pci_dev);

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 52f3cb8fb2d1..3d7f2cda980a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2840,8 +2840,10 @@ static int pci230_attach_common(struct comedi_device *dev,
 			devpriv->pci_dev->irq);
 	}
 
-	if (comedi_alloc_subdevices(dev, 3) < 0)
-		return -ENOMEM;
+	rc = comedi_alloc_subdevices(dev, 3);
+	if (rc)
+		return rc;
+
 	s = dev->subdevices + 0;
 	/* analog input subdevice */
 	s->type = COMEDI_SUBD_AI;

commit eea6838b1206b0ac90110f1a6f58e101aa496e99
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:15 2012 -0700

    staging: comedi: remove the "Allocate the subdevice..." comments
    
    These comments are redundant. The function name 'comedi_alloc_subdevices'
    provides this information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <ian@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index e6598cafb39a..52f3cb8fb2d1 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2839,10 +2839,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 		dev_dbg(dev->class_dev, "registered irq %u\n",
 			devpriv->pci_dev->irq);
 	}
-	/*
-	 * Allocate the subdevice structures.  alloc_subdevice() is a
-	 * convenient macro defined in comedidev.h.
-	 */
+
 	if (comedi_alloc_subdevices(dev, 3) < 0)
 		return -ENOMEM;
 	s = dev->subdevices + 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 2a43df5d966e..e6598cafb39a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -2843,7 +2843,7 @@ static int pci230_attach_common(struct comedi_device *dev,
 	 * Allocate the subdevice structures.  alloc_subdevice() is a
 	 * convenient macro defined in comedidev.h.
 	 */
-	if (alloc_subdevices(dev, 3) < 0)
+	if (comedi_alloc_subdevices(dev, 3) < 0)
 		return -ENOMEM;
 	s = dev->subdevices + 0;
 	/* analog input subdevice */

commit 83afda9d449c61b55881d50465833784d8fda786
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 8 10:40:05 2012 +0100

    staging: comedi: amplc_pci230: Replace NULLFUNC
    
    The source code defines a macro NULLFUNC
    
      #define NULLFUNC 0
    
    and uses it as a generic null function pointer constant.  This is
    superfluous.  Just use NULL instead.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index f2ad35c6527d..2a43df5d966e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -430,9 +430,6 @@ enum {
 /* Combine old and new bits. */
 #define COMBINE(old, new, mask)	(((old) & ~(mask)) | ((new) & (mask)))
 
-/* A generic null function pointer value.  */
-#define NULLFUNC	0
-
 /* Current CPU.  XXX should this be hard_smp_processor_id()? */
 #define THISCPU		smp_processor_id()
 
@@ -1491,7 +1488,7 @@ static int pci230_ao_inttrig_start(struct comedi_device *dev,
 	if (trig_num != 0)
 		return -EINVAL;
 
-	s->async->inttrig = NULLFUNC;
+	s->async->inttrig = NULL;
 	pci230_ao_start(dev, s);
 
 	return 1;
@@ -2292,7 +2289,7 @@ static int pci230_ai_inttrig_start(struct comedi_device *dev,
 	if (trig_num != 0)
 		return -EINVAL;
 
-	s->async->inttrig = NULLFUNC;
+	s->async->inttrig = NULL;
 	pci230_ai_start(dev, s);
 
 	return 1;

commit f59f231e3db835353d8d1ff91062d89140dc8be3
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jun 8 09:52:58 2012 +0300

    staging: comedi: amplc_pci230: add a missing unlock
    
    This side of the if else statement returned with the lock held and IRQs
    disabled.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 30487be11650..f2ad35c6527d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1387,6 +1387,8 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 		/* Delay.  Should driver be responsible for this? */
 		/* XXX TODO: See if DAC busy bit can be used. */
 		udelay(8);
+	} else {
+		spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
 	}
 
 	return 1;

commit 5d3b0d1859722a855b0310fcdc34c2e545cc1c7d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 1 17:31:45 2012 +0100

    staging: comedi: amplc_pci230: Remove forward declarations 4
    
    Move these functions and remove their forward declarations:
    pci230_ai_stop(), pci230_handle_ai().  Also move pci230_ai_cancel() for
    aesthetic reasons.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 0e9c4ba6e6c0..30487be11650 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -579,11 +579,6 @@ static const struct comedi_lrange pci230_ao_range = { 2, {
 /* PCI230 daccon bipolar flag for each analogue output range. */
 static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
 
-static void pci230_ai_stop(struct comedi_device *dev,
-			   struct comedi_subdevice *s);
-static void pci230_handle_ai(struct comedi_device *dev,
-			     struct comedi_subdevice *s);
-
 static short pci230_ai_read(struct comedi_device *dev)
 {
 	const struct pci230_board *thisboard = comedi_board(dev);
@@ -2103,6 +2098,52 @@ static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
 	return 1;
 }
 
+static void pci230_ai_stop(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
+{
+	struct pci230_private *devpriv = dev->private;
+	unsigned long irqflags;
+	struct comedi_cmd *cmd;
+	int started;
+
+	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
+	started = test_and_clear_bit(AI_CMD_STARTED, &devpriv->state);
+	spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
+	if (!started)
+		return;
+	cmd = &s->async->cmd;
+	if (cmd->convert_src == TRIG_TIMER) {
+		/* Stop conversion rate generator. */
+		pci230_cancel_ct(dev, 2);
+	}
+	if (cmd->scan_begin_src != TRIG_FOLLOW) {
+		/* Stop scan period monostable. */
+		pci230_cancel_ct(dev, 0);
+	}
+	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	/* Disable ADC interrupt and wait for interrupt routine to finish
+	 * running unless we are called from the interrupt routine. */
+	devpriv->int_en &= ~PCI230_INT_ADC;
+	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
+		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	}
+	if (devpriv->ier != devpriv->int_en) {
+		devpriv->ier = devpriv->int_en;
+		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+	}
+	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+	/* Reset FIFO, disable FIFO and set start conversion source to none.
+	 * Keep se/diff and bip/uni settings */
+	devpriv->adccon = (devpriv->adccon & (PCI230_ADC_IR_MASK
+					      | PCI230_ADC_IM_MASK)) |
+	    PCI230_ADC_TRIG_NONE;
+	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
+	     dev->iobase + PCI230_ADCCON);
+	/* Release resources. */
+	put_all_resources(dev, OWNER_AICMD);
+}
+
 static void pci230_ai_start(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
@@ -2255,6 +2296,99 @@ static int pci230_ai_inttrig_start(struct comedi_device *dev,
 	return 1;
 }
 
+static void pci230_handle_ai(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
+{
+	struct pci230_private *devpriv = dev->private;
+	unsigned int events = 0;
+	unsigned int status_fifo;
+	unsigned int i;
+	unsigned int todo;
+	unsigned int fifoamount;
+	struct comedi_async *async = s->async;
+	unsigned int scanlen = async->cmd.scan_end_arg;
+
+	/* Determine number of samples to read. */
+	if (devpriv->ai_continuous) {
+		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
+	} else if (devpriv->ai_scan_count == 0) {
+		todo = 0;
+	} else if ((devpriv->ai_scan_count > PCI230_ADC_FIFOLEVEL_HALFFULL)
+		   || (scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL)) {
+		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
+	} else {
+		todo = (devpriv->ai_scan_count * scanlen)
+		    - devpriv->ai_scan_pos;
+		if (todo > PCI230_ADC_FIFOLEVEL_HALFFULL)
+			todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
+	}
+	if (todo == 0)
+		return;
+	fifoamount = 0;
+	for (i = 0; i < todo; i++) {
+		if (fifoamount == 0) {
+			/* Read FIFO state. */
+			status_fifo = inw(dev->iobase + PCI230_ADCCON);
+			if ((status_fifo & PCI230_ADC_FIFO_FULL_LATCHED) != 0) {
+				/* Report error otherwise FIFO overruns will go
+				 * unnoticed by the caller. */
+				comedi_error(dev, "AI FIFO overrun");
+				events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
+				break;
+			} else if ((status_fifo & PCI230_ADC_FIFO_EMPTY) != 0) {
+				/* FIFO empty. */
+				break;
+			} else if ((status_fifo & PCI230_ADC_FIFO_HALF) != 0) {
+				/* FIFO half full. */
+				fifoamount = PCI230_ADC_FIFOLEVEL_HALFFULL;
+			} else {
+				/* FIFO not empty. */
+				if (devpriv->hwver > 0) {
+					/* Read PCI230+/260+ ADC FIFO level. */
+					fifoamount = inw(dev->iobase
+							 + PCI230P_ADCFFLEV);
+					if (fifoamount == 0) {
+						/* Shouldn't happen. */
+						break;
+					}
+				} else {
+					fifoamount = 1;
+				}
+			}
+		}
+		/* Read sample and store in Comedi's circular buffer. */
+		if (comedi_buf_put(async, pci230_ai_read(dev)) == 0) {
+			events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
+			comedi_error(dev, "AI buffer overflow");
+			break;
+		}
+		fifoamount--;
+		devpriv->ai_scan_pos++;
+		if (devpriv->ai_scan_pos == scanlen) {
+			/* End of scan. */
+			devpriv->ai_scan_pos = 0;
+			devpriv->ai_scan_count--;
+			async->events |= COMEDI_CB_EOS;
+		}
+	}
+	if (!devpriv->ai_continuous && (devpriv->ai_scan_count == 0)) {
+		/* End of acquisition. */
+		events |= COMEDI_CB_EOA;
+	} else {
+		/* More samples required, tell Comedi to block. */
+		events |= COMEDI_CB_BLOCK;
+	}
+	async->events |= events;
+	if ((async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
+			      COMEDI_CB_OVERFLOW)) != 0) {
+		/* disable hardware conversions */
+		pci230_ai_stop(dev, s);
+	} else {
+		/* update FIFO interrupt trigger level */
+		pci230_ai_update_fifo_trigger_level(dev, s);
+	}
+}
+
 static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pci230_private *devpriv = dev->private;
@@ -2449,6 +2583,13 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static int pci230_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
+{
+	pci230_ai_stop(dev, s);
+	return 0;
+}
+
 /* Interrupt handler */
 static irqreturn_t pci230_interrupt(int irq, void *d)
 {
@@ -2514,165 +2655,6 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void pci230_handle_ai(struct comedi_device *dev,
-			     struct comedi_subdevice *s)
-{
-	struct pci230_private *devpriv = dev->private;
-	unsigned int events = 0;
-	unsigned int status_fifo;
-	unsigned int i;
-	unsigned int todo;
-	unsigned int fifoamount;
-	struct comedi_async *async = s->async;
-	unsigned int scanlen = async->cmd.scan_end_arg;
-
-	/* Determine number of samples to read. */
-	if (devpriv->ai_continuous) {
-		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
-	} else if (devpriv->ai_scan_count == 0) {
-		todo = 0;
-	} else if ((devpriv->ai_scan_count > PCI230_ADC_FIFOLEVEL_HALFFULL)
-		   || (scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL)) {
-		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
-	} else {
-		todo = (devpriv->ai_scan_count * scanlen)
-		    - devpriv->ai_scan_pos;
-		if (todo > PCI230_ADC_FIFOLEVEL_HALFFULL)
-			todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
-
-	}
-
-	if (todo == 0)
-		return;
-
-
-	fifoamount = 0;
-	for (i = 0; i < todo; i++) {
-		if (fifoamount == 0) {
-			/* Read FIFO state. */
-			status_fifo = inw(dev->iobase + PCI230_ADCCON);
-
-			if ((status_fifo & PCI230_ADC_FIFO_FULL_LATCHED) != 0) {
-				/* Report error otherwise FIFO overruns will go
-				 * unnoticed by the caller. */
-				comedi_error(dev, "AI FIFO overrun");
-				events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
-				break;
-			} else if ((status_fifo & PCI230_ADC_FIFO_EMPTY) != 0) {
-				/* FIFO empty. */
-				break;
-			} else if ((status_fifo & PCI230_ADC_FIFO_HALF) != 0) {
-				/* FIFO half full. */
-				fifoamount = PCI230_ADC_FIFOLEVEL_HALFFULL;
-			} else {
-				/* FIFO not empty. */
-				if (devpriv->hwver > 0) {
-					/* Read PCI230+/260+ ADC FIFO level. */
-					fifoamount = inw(dev->iobase
-							 + PCI230P_ADCFFLEV);
-					if (fifoamount == 0) {
-						/* Shouldn't happen. */
-						break;
-					}
-				} else {
-					fifoamount = 1;
-				}
-			}
-		}
-
-		/* Read sample and store in Comedi's circular buffer. */
-		if (comedi_buf_put(async, pci230_ai_read(dev)) == 0) {
-			events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
-			comedi_error(dev, "AI buffer overflow");
-			break;
-		}
-		fifoamount--;
-		devpriv->ai_scan_pos++;
-		if (devpriv->ai_scan_pos == scanlen) {
-			/* End of scan. */
-			devpriv->ai_scan_pos = 0;
-			devpriv->ai_scan_count--;
-			async->events |= COMEDI_CB_EOS;
-		}
-	}
-
-	if (!devpriv->ai_continuous && (devpriv->ai_scan_count == 0)) {
-		/* End of acquisition. */
-		events |= COMEDI_CB_EOA;
-	} else {
-		/* More samples required, tell Comedi to block. */
-		events |= COMEDI_CB_BLOCK;
-	}
-	async->events |= events;
-
-	if ((async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
-			      COMEDI_CB_OVERFLOW)) != 0) {
-		/* disable hardware conversions */
-		pci230_ai_stop(dev, s);
-	} else {
-		/* update FIFO interrupt trigger level */
-		pci230_ai_update_fifo_trigger_level(dev, s);
-	}
-}
-
-static void pci230_ai_stop(struct comedi_device *dev,
-			   struct comedi_subdevice *s)
-{
-	struct pci230_private *devpriv = dev->private;
-	unsigned long irqflags;
-	struct comedi_cmd *cmd;
-	int started;
-
-	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
-	started = test_and_clear_bit(AI_CMD_STARTED, &devpriv->state);
-	spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
-	if (!started)
-		return;
-
-
-	cmd = &s->async->cmd;
-	if (cmd->convert_src == TRIG_TIMER) {
-		/* Stop conversion rate generator. */
-		pci230_cancel_ct(dev, 2);
-	}
-	if (cmd->scan_begin_src != TRIG_FOLLOW) {
-		/* Stop scan period monostable. */
-		pci230_cancel_ct(dev, 0);
-	}
-
-	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-	/* Disable ADC interrupt and wait for interrupt routine to finish
-	 * running unless we are called from the interrupt routine. */
-	devpriv->int_en &= ~PCI230_INT_ADC;
-	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
-		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
-		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-	}
-	if (devpriv->ier != devpriv->int_en) {
-		devpriv->ier = devpriv->int_en;
-		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
-	}
-	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
-
-	/* Reset FIFO, disable FIFO and set start conversion source to none.
-	 * Keep se/diff and bip/uni settings */
-	devpriv->adccon = (devpriv->adccon & (PCI230_ADC_IR_MASK
-					      | PCI230_ADC_IM_MASK)) |
-	    PCI230_ADC_TRIG_NONE;
-	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
-	     dev->iobase + PCI230_ADCCON);
-
-	/* Release resources. */
-	put_all_resources(dev, OWNER_AICMD);
-}
-
-static int pci230_ai_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s)
-{
-	pci230_ai_stop(dev, s);
-	return 0;
-}
-
 /* Check if PCI device matches a specific board. */
 static bool pci230_match_pci_board(const struct pci230_board *board,
 				   struct pci_dev *pci_dev)

commit bd4447e597e0609fccb91aeeb2add40a7fcf3289
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 1 17:31:44 2012 +0100

    staging: comedi: amplc_pci230: Remove forward declarations 3
    
    Move these functions and remove their forward declarations:
    pci230_ao_stop(), pci230_handle_ao_nofifo(), pci230_handle_ao_fifo().
    Also move pci230_ao_cancel() for aesthetic reasons.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index d028962a5384..0e9c4ba6e6c0 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -579,12 +579,6 @@ static const struct comedi_lrange pci230_ao_range = { 2, {
 /* PCI230 daccon bipolar flag for each analogue output range. */
 static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
 
-static void pci230_ao_stop(struct comedi_device *dev,
-			   struct comedi_subdevice *s);
-static void pci230_handle_ao_nofifo(struct comedi_device *dev,
-				    struct comedi_subdevice *s);
-static int pci230_handle_ao_fifo(struct comedi_device *dev,
-				 struct comedi_subdevice *s);
 static void pci230_ai_stop(struct comedi_device *dev,
 			   struct comedi_subdevice *s);
 static void pci230_handle_ai(struct comedi_device *dev,
@@ -1179,6 +1173,196 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
+static void pci230_ao_stop(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
+{
+	struct pci230_private *devpriv = dev->private;
+	unsigned long irqflags;
+	unsigned char intsrc;
+	int started;
+	struct comedi_cmd *cmd;
+
+	spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
+	started = test_and_clear_bit(AO_CMD_STARTED, &devpriv->state);
+	spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
+	if (!started)
+		return;
+	cmd = &s->async->cmd;
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		/* Stop scan rate generator. */
+		pci230_cancel_ct(dev, 1);
+	}
+	/* Determine interrupt source. */
+	if (devpriv->hwver < 2) {
+		/* Not using DAC FIFO.  Using CT1 interrupt. */
+		intsrc = PCI230_INT_ZCLK_CT1;
+	} else {
+		/* Using DAC FIFO interrupt. */
+		intsrc = PCI230P2_INT_DAC;
+	}
+	/* Disable interrupt and wait for interrupt routine to finish running
+	 * unless we are called from the interrupt routine. */
+	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	devpriv->int_en &= ~intsrc;
+	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
+		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	}
+	if (devpriv->ier != devpriv->int_en) {
+		devpriv->ier = devpriv->int_en;
+		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+	}
+	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+	if (devpriv->hwver >= 2) {
+		/* Using DAC FIFO.  Reset FIFO, clear underrun error,
+		 * disable FIFO. */
+		devpriv->daccon &= PCI230_DAC_OR_MASK;
+		outw(devpriv->daccon | PCI230P2_DAC_FIFO_RESET
+		     | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,
+		     dev->iobase + PCI230_DACCON);
+	}
+	/* Release resources. */
+	put_all_resources(dev, OWNER_AOCMD);
+}
+
+static void pci230_handle_ao_nofifo(struct comedi_device *dev,
+				    struct comedi_subdevice *s)
+{
+	struct pci230_private *devpriv = dev->private;
+	short data;
+	int i, ret;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+
+	if (!devpriv->ao_continuous && (devpriv->ao_scan_count == 0))
+		return;
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		/* Read sample from Comedi's circular buffer. */
+		ret = comedi_buf_get(s->async, &data);
+		if (ret == 0) {
+			s->async->events |= COMEDI_CB_OVERFLOW;
+			pci230_ao_stop(dev, s);
+			comedi_error(dev, "AO buffer underrun");
+			return;
+		}
+		/* Write value to DAC. */
+		pci230_ao_write_nofifo(dev, data, CR_CHAN(cmd->chanlist[i]));
+	}
+	async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+	if (!devpriv->ao_continuous) {
+		devpriv->ao_scan_count--;
+		if (devpriv->ao_scan_count == 0) {
+			/* End of acquisition. */
+			async->events |= COMEDI_CB_EOA;
+			pci230_ao_stop(dev, s);
+		}
+	}
+}
+
+/* Loads DAC FIFO (if using it) from buffer. */
+/* Returns 0 if AO finished due to completion or error, 1 if still going. */
+static int pci230_handle_ao_fifo(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
+{
+	struct pci230_private *devpriv = dev->private;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	unsigned int num_scans;
+	unsigned int room;
+	unsigned short dacstat;
+	unsigned int i, n;
+	unsigned int bytes_per_scan;
+	unsigned int events = 0;
+	int running;
+
+	/* Get DAC FIFO status. */
+	dacstat = inw(dev->iobase + PCI230_DACCON);
+	/* Determine number of scans available in buffer. */
+	bytes_per_scan = cmd->chanlist_len * sizeof(short);
+	num_scans = comedi_buf_read_n_available(async) / bytes_per_scan;
+	if (!devpriv->ao_continuous) {
+		/* Fixed number of scans. */
+		if (num_scans > devpriv->ao_scan_count)
+			num_scans = devpriv->ao_scan_count;
+		if (devpriv->ao_scan_count == 0) {
+			/* End of acquisition. */
+			events |= COMEDI_CB_EOA;
+		}
+	}
+	if (events == 0) {
+		/* Check for FIFO underrun. */
+		if ((dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) != 0) {
+			comedi_error(dev, "AO FIFO underrun");
+			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
+		}
+		/* Check for buffer underrun if FIFO less than half full
+		 * (otherwise there will be loads of "DAC FIFO not half full"
+		 * interrupts). */
+		if ((num_scans == 0)
+		    && ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {
+			comedi_error(dev, "AO buffer underrun");
+			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
+		}
+	}
+	if (events == 0) {
+		/* Determine how much room is in the FIFO (in samples). */
+		if ((dacstat & PCI230P2_DAC_FIFO_FULL) != 0)
+			room = PCI230P2_DAC_FIFOROOM_FULL;
+		else if ((dacstat & PCI230P2_DAC_FIFO_HALF) != 0)
+			room = PCI230P2_DAC_FIFOROOM_HALFTOFULL;
+		else if ((dacstat & PCI230P2_DAC_FIFO_EMPTY) != 0)
+			room = PCI230P2_DAC_FIFOROOM_EMPTY;
+		else
+			room = PCI230P2_DAC_FIFOROOM_ONETOHALF;
+		/* Convert room to number of scans that can be added. */
+		room /= cmd->chanlist_len;
+		/* Determine number of scans to process. */
+		if (num_scans > room)
+			num_scans = room;
+		/* Process scans. */
+		for (n = 0; n < num_scans; n++) {
+			for (i = 0; i < cmd->chanlist_len; i++) {
+				short datum;
+
+				comedi_buf_get(async, &datum);
+				pci230_ao_write_fifo(dev, datum,
+						     CR_CHAN(cmd->chanlist[i]));
+			}
+		}
+		events |= COMEDI_CB_EOS | COMEDI_CB_BLOCK;
+		if (!devpriv->ao_continuous) {
+			devpriv->ao_scan_count -= num_scans;
+			if (devpriv->ao_scan_count == 0) {
+				/* All data for the command has been written
+				 * to FIFO.  Set FIFO interrupt trigger level
+				 * to 'empty'. */
+				devpriv->daccon = (devpriv->daccon
+						   &
+						   ~PCI230P2_DAC_INT_FIFO_MASK)
+				    | PCI230P2_DAC_INT_FIFO_EMPTY;
+				outw(devpriv->daccon,
+				     dev->iobase + PCI230_DACCON);
+			}
+		}
+		/* Check if FIFO underrun occurred while writing to FIFO. */
+		dacstat = inw(dev->iobase + PCI230_DACCON);
+		if ((dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) != 0) {
+			comedi_error(dev, "AO FIFO underrun");
+			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
+		}
+	}
+	if ((events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
+	    != 0) {
+		/* Stopping AO due to completion or error. */
+		pci230_ao_stop(dev, s);
+		running = 0;
+	} else {
+		running = 1;
+	}
+	async->events |= events;
+	return running;
+}
+
 static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 					struct comedi_subdevice *s,
 					unsigned int trig_num)
@@ -1394,6 +1578,13 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static int pci230_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
+{
+	pci230_ao_stop(dev, s);
+	return 0;
+}
+
 static int pci230_ai_check_scan_period(struct comedi_cmd *cmd)
 {
 	unsigned int min_scan_period, chanlist_len;
@@ -2323,151 +2514,6 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void pci230_handle_ao_nofifo(struct comedi_device *dev,
-				    struct comedi_subdevice *s)
-{
-	struct pci230_private *devpriv = dev->private;
-	short data;
-	int i, ret;
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
-
-	if (!devpriv->ao_continuous && (devpriv->ao_scan_count == 0))
-		return;
-
-
-	for (i = 0; i < cmd->chanlist_len; i++) {
-		/* Read sample from Comedi's circular buffer. */
-		ret = comedi_buf_get(s->async, &data);
-		if (ret == 0) {
-			s->async->events |= COMEDI_CB_OVERFLOW;
-			pci230_ao_stop(dev, s);
-			comedi_error(dev, "AO buffer underrun");
-			return;
-		}
-		/* Write value to DAC. */
-		pci230_ao_write_nofifo(dev, data, CR_CHAN(cmd->chanlist[i]));
-	}
-
-	async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
-	if (!devpriv->ao_continuous) {
-		devpriv->ao_scan_count--;
-		if (devpriv->ao_scan_count == 0) {
-			/* End of acquisition. */
-			async->events |= COMEDI_CB_EOA;
-			pci230_ao_stop(dev, s);
-		}
-	}
-}
-
-/* Loads DAC FIFO (if using it) from buffer. */
-/* Returns 0 if AO finished due to completion or error, 1 if still going. */
-static int pci230_handle_ao_fifo(struct comedi_device *dev,
-				 struct comedi_subdevice *s)
-{
-	struct pci230_private *devpriv = dev->private;
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
-	unsigned int num_scans;
-	unsigned int room;
-	unsigned short dacstat;
-	unsigned int i, n;
-	unsigned int bytes_per_scan;
-	unsigned int events = 0;
-	int running;
-
-	/* Get DAC FIFO status. */
-	dacstat = inw(dev->iobase + PCI230_DACCON);
-
-	/* Determine number of scans available in buffer. */
-	bytes_per_scan = cmd->chanlist_len * sizeof(short);
-	num_scans = comedi_buf_read_n_available(async) / bytes_per_scan;
-	if (!devpriv->ao_continuous) {
-		/* Fixed number of scans. */
-		if (num_scans > devpriv->ao_scan_count)
-			num_scans = devpriv->ao_scan_count;
-
-		if (devpriv->ao_scan_count == 0) {
-			/* End of acquisition. */
-			events |= COMEDI_CB_EOA;
-		}
-	}
-	if (events == 0) {
-		/* Check for FIFO underrun. */
-		if ((dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) != 0) {
-			comedi_error(dev, "AO FIFO underrun");
-			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
-		}
-		/* Check for buffer underrun if FIFO less than half full
-		 * (otherwise there will be loads of "DAC FIFO not half full"
-		 * interrupts). */
-		if ((num_scans == 0)
-		    && ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {
-			comedi_error(dev, "AO buffer underrun");
-			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
-		}
-	}
-	if (events == 0) {
-		/* Determine how much room is in the FIFO (in samples). */
-		if ((dacstat & PCI230P2_DAC_FIFO_FULL) != 0)
-			room = PCI230P2_DAC_FIFOROOM_FULL;
-		else if ((dacstat & PCI230P2_DAC_FIFO_HALF) != 0)
-			room = PCI230P2_DAC_FIFOROOM_HALFTOFULL;
-		else if ((dacstat & PCI230P2_DAC_FIFO_EMPTY) != 0)
-			room = PCI230P2_DAC_FIFOROOM_EMPTY;
-		else
-			room = PCI230P2_DAC_FIFOROOM_ONETOHALF;
-
-		/* Convert room to number of scans that can be added. */
-		room /= cmd->chanlist_len;
-		/* Determine number of scans to process. */
-		if (num_scans > room)
-			num_scans = room;
-
-		/* Process scans. */
-		for (n = 0; n < num_scans; n++) {
-			for (i = 0; i < cmd->chanlist_len; i++) {
-				short datum;
-
-				comedi_buf_get(async, &datum);
-				pci230_ao_write_fifo(dev, datum,
-						     CR_CHAN(cmd->chanlist[i]));
-			}
-		}
-		events |= COMEDI_CB_EOS | COMEDI_CB_BLOCK;
-		if (!devpriv->ao_continuous) {
-			devpriv->ao_scan_count -= num_scans;
-			if (devpriv->ao_scan_count == 0) {
-				/* All data for the command has been written
-				 * to FIFO.  Set FIFO interrupt trigger level
-				 * to 'empty'. */
-				devpriv->daccon = (devpriv->daccon
-						   &
-						   ~PCI230P2_DAC_INT_FIFO_MASK)
-				    | PCI230P2_DAC_INT_FIFO_EMPTY;
-				outw(devpriv->daccon,
-				     dev->iobase + PCI230_DACCON);
-			}
-		}
-		/* Check if FIFO underrun occurred while writing to FIFO. */
-		dacstat = inw(dev->iobase + PCI230_DACCON);
-		if ((dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) != 0) {
-			comedi_error(dev, "AO FIFO underrun");
-			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
-		}
-	}
-	if ((events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
-	    != 0) {
-		/* Stopping AO due to completion or error. */
-		pci230_ao_stop(dev, s);
-		running = 0;
-	} else {
-		running = 1;
-	}
-	async->events |= events;
-	return running;
-}
-
 static void pci230_handle_ai(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
@@ -2569,70 +2615,6 @@ static void pci230_handle_ai(struct comedi_device *dev,
 	}
 }
 
-static void pci230_ao_stop(struct comedi_device *dev,
-			   struct comedi_subdevice *s)
-{
-	struct pci230_private *devpriv = dev->private;
-	unsigned long irqflags;
-	unsigned char intsrc;
-	int started;
-	struct comedi_cmd *cmd;
-
-	spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
-	started = test_and_clear_bit(AO_CMD_STARTED, &devpriv->state);
-	spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
-	if (!started)
-		return;
-
-
-	cmd = &s->async->cmd;
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		/* Stop scan rate generator. */
-		pci230_cancel_ct(dev, 1);
-	}
-
-	/* Determine interrupt source. */
-	if (devpriv->hwver < 2) {
-		/* Not using DAC FIFO.  Using CT1 interrupt. */
-		intsrc = PCI230_INT_ZCLK_CT1;
-	} else {
-		/* Using DAC FIFO interrupt. */
-		intsrc = PCI230P2_INT_DAC;
-	}
-	/* Disable interrupt and wait for interrupt routine to finish running
-	 * unless we are called from the interrupt routine. */
-	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-	devpriv->int_en &= ~intsrc;
-	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
-		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
-		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
-	}
-	if (devpriv->ier != devpriv->int_en) {
-		devpriv->ier = devpriv->int_en;
-		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
-	}
-	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
-
-	if (devpriv->hwver >= 2) {
-		/* Using DAC FIFO.  Reset FIFO, clear underrun error,
-		 * disable FIFO. */
-		devpriv->daccon &= PCI230_DAC_OR_MASK;
-		outw(devpriv->daccon | PCI230P2_DAC_FIFO_RESET
-		     | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,
-		     dev->iobase + PCI230_DACCON);
-	}
-
-	/* Release resources. */
-	put_all_resources(dev, OWNER_AOCMD);
-}
-
-static int pci230_ao_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s)
-{
-	pci230_ao_stop(dev, s);
-	return 0;
-}
-
 static void pci230_ai_stop(struct comedi_device *dev,
 			   struct comedi_subdevice *s)
 {

commit 091e8d8ff434f5e6e67dcfd742e2df8cac999ce4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 1 17:31:43 2012 +0100

    staging: comedi: amplc_pci230: Remove forward declarations 2
    
    Remove some forward function declarations: pci230_ct_setup_ns_mode(),
    pci230_ns_to_single_timer(), pci230_cancel_ct().  Also need to move:
    divide_ns().
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a99e90f7b556..d028962a5384 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -579,11 +579,6 @@ static const struct comedi_lrange pci230_ao_range = { 2, {
 /* PCI230 daccon bipolar flag for each analogue output range. */
 static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
 
-static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
-				    unsigned int mode, uint64_t ns,
-				    unsigned int round);
-static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round);
-static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct);
 static void pci230_ao_stop(struct comedi_device *dev,
 			   struct comedi_subdevice *s);
 static void pci230_handle_ao_nofifo(struct comedi_device *dev,
@@ -738,6 +733,86 @@ static inline void put_all_resources(struct comedi_device *dev,
 	put_resources(dev, (1U << NUM_RESOURCES) - 1, owner);
 }
 
+static unsigned int divide_ns(uint64_t ns, unsigned int timebase,
+			      unsigned int round_mode)
+{
+	uint64_t div;
+	unsigned int rem;
+
+	div = ns;
+	rem = do_div(div, timebase);
+	round_mode &= TRIG_ROUND_MASK;
+	switch (round_mode) {
+	default:
+	case TRIG_ROUND_NEAREST:
+		div += (rem + (timebase / 2)) / timebase;
+		break;
+	case TRIG_ROUND_DOWN:
+		break;
+	case TRIG_ROUND_UP:
+		div += (rem + timebase - 1) / timebase;
+		break;
+	}
+	return div > UINT_MAX ? UINT_MAX : (unsigned int)div;
+}
+
+/* Given desired period in ns, returns the required internal clock source
+ * and gets the initial count. */
+static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
+					    unsigned int round_mode)
+{
+	unsigned int clk_src, cnt;
+
+	for (clk_src = CLK_10MHZ;; clk_src++) {
+		cnt = divide_ns(ns, pci230_timebase[clk_src], round_mode);
+		if ((cnt <= 65536) || (clk_src == CLK_1KHZ))
+			break;
+
+	}
+	*count = cnt;
+	return clk_src;
+}
+
+static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round)
+{
+	unsigned int count;
+	unsigned int clk_src;
+
+	clk_src = pci230_choose_clk_count(*ns, &count, round);
+	*ns = count * pci230_timebase[clk_src];
+	return;
+}
+
+static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
+				    unsigned int mode, uint64_t ns,
+				    unsigned int round)
+{
+	struct pci230_private *devpriv = dev->private;
+	unsigned int clk_src;
+	unsigned int count;
+
+	/* Set mode. */
+	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, mode);
+	/* Determine clock source and count. */
+	clk_src = pci230_choose_clk_count(ns, &count, round);
+	/* Program clock source. */
+	outb(CLK_CONFIG(ct, clk_src), devpriv->iobase1 + PCI230_ZCLK_SCE);
+	/* Set initial count. */
+	if (count >= 65536)
+		count = 0;
+
+	i8254_write(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, count);
+}
+
+static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)
+{
+	struct pci230_private *devpriv = dev->private;
+
+	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct,
+		       I8254_MODE1);
+	/* Counter ct, 8254 mode 1, initial count not written. */
+}
+
 /*
  *  COMEDI_SUBD_AI instruction;
  */
@@ -2183,86 +2258,6 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static unsigned int divide_ns(uint64_t ns, unsigned int timebase,
-			      unsigned int round_mode)
-{
-	uint64_t div;
-	unsigned int rem;
-
-	div = ns;
-	rem = do_div(div, timebase);
-	round_mode &= TRIG_ROUND_MASK;
-	switch (round_mode) {
-	default:
-	case TRIG_ROUND_NEAREST:
-		div += (rem + (timebase / 2)) / timebase;
-		break;
-	case TRIG_ROUND_DOWN:
-		break;
-	case TRIG_ROUND_UP:
-		div += (rem + timebase - 1) / timebase;
-		break;
-	}
-	return div > UINT_MAX ? UINT_MAX : (unsigned int)div;
-}
-
-/* Given desired period in ns, returns the required internal clock source
- * and gets the initial count. */
-static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
-					    unsigned int round_mode)
-{
-	unsigned int clk_src, cnt;
-
-	for (clk_src = CLK_10MHZ;; clk_src++) {
-		cnt = divide_ns(ns, pci230_timebase[clk_src], round_mode);
-		if ((cnt <= 65536) || (clk_src == CLK_1KHZ))
-			break;
-
-	}
-	*count = cnt;
-	return clk_src;
-}
-
-static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round)
-{
-	unsigned int count;
-	unsigned int clk_src;
-
-	clk_src = pci230_choose_clk_count(*ns, &count, round);
-	*ns = count * pci230_timebase[clk_src];
-	return;
-}
-
-static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
-				    unsigned int mode, uint64_t ns,
-				    unsigned int round)
-{
-	struct pci230_private *devpriv = dev->private;
-	unsigned int clk_src;
-	unsigned int count;
-
-	/* Set mode. */
-	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, mode);
-	/* Determine clock source and count. */
-	clk_src = pci230_choose_clk_count(ns, &count, round);
-	/* Program clock source. */
-	outb(CLK_CONFIG(ct, clk_src), devpriv->iobase1 + PCI230_ZCLK_SCE);
-	/* Set initial count. */
-	if (count >= 65536)
-		count = 0;
-
-	i8254_write(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, count);
-}
-
-static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)
-{
-	struct pci230_private *devpriv = dev->private;
-
-	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct,
-		       I8254_MODE1);
-	/* Counter ct, 8254 mode 1, initial count not written. */
-}
-
 /* Interrupt handler */
 static irqreturn_t pci230_interrupt(int irq, void *d)
 {

commit 027ee06835e96d425998003fe0b60ab128581fd6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 1 17:31:42 2012 +0100

    staging: comedi: amplc_pci230: Remove forward declarations 1
    
    Remove the redundant forward function declarations.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index fbc9da99c6f5..a99e90f7b556 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -579,39 +579,17 @@ static const struct comedi_lrange pci230_ao_range = { 2, {
 /* PCI230 daccon bipolar flag for each analogue output range. */
 static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
 
-static int pci230_ai_rinsn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data);
-static int pci230_ao_winsn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data);
-static int pci230_ao_rinsn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data);
 static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 				    unsigned int mode, uint64_t ns,
 				    unsigned int round);
 static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round);
 static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct);
-static irqreturn_t pci230_interrupt(int irq, void *d);
-static int pci230_ao_cmdtest(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_cmd *cmd);
-static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pci230_ao_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s);
 static void pci230_ao_stop(struct comedi_device *dev,
 			   struct comedi_subdevice *s);
 static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 				    struct comedi_subdevice *s);
 static int pci230_handle_ao_fifo(struct comedi_device *dev,
 				 struct comedi_subdevice *s);
-static int pci230_ai_cmdtest(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_cmd *cmd);
-static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pci230_ai_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s);
 static void pci230_ai_stop(struct comedi_device *dev,
 			   struct comedi_subdevice *s);
 static void pci230_handle_ai(struct comedi_device *dev,

commit ba54fa6893aa72159c046c6099f7644df745feea
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 1 17:31:41 2012 +0100

    staging: comedi: amplc_pci230: Add attach_pci() hook
    
    Implement the attach_pci() hook as function pci230_attach_pci().  This
    is called by comedi_pci_auto_config() in preference to the old attach()
    hook (implemented by pci230_attach() and still required for "manual"
    configuration of comedi devices).  The advantage of the attach_pci()
    hook is that it avoids searching for the PCI device.
    
    Refactor pci230_attach() and factor out code common to pci230_attach()
    and pci230_attach_pci() into new functions pci230_match_pci_board(),
    pci230_find_pci_board(), pci230_find_pci(), pci230_alloc_private() and
    pci230_attach_common().
    
    Finally, move pci230_attach() and pci230_detach() along with all the new
    functions towards the bottom of the file as it makes the patch much
    cleaner (though longer) and I plan to move things around soon to get
    rid of the remaining forward references.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 6d3c6c9dff00..fbc9da99c6f5 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -499,8 +499,6 @@ static const struct pci230_board pci230_boards[] = {
 	 },
 };
 
-#define n_pci230_boards ARRAY_SIZE(pci230_boards)
-
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.  */
@@ -686,281 +684,6 @@ static inline void pci230_ao_write_fifo(struct comedi_device *dev, short datum,
 	     dev->iobase + PCI230P2_DACDATA);
 }
 
-/*
- * Attach is called by the Comedi core to configure the driver
- * for a particular board.  If you specified a board_name array
- * in the driver structure, dev->board_ptr contains that
- * address.
- */
-static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
-{
-	const struct pci230_board *thisboard = comedi_board(dev);
-	struct pci230_private *devpriv;
-	struct comedi_subdevice *s;
-	unsigned long iobase1, iobase2;
-	/* PCI230's I/O spaces 1 and 2 respectively. */
-	struct pci_dev *pci_dev = NULL;
-	int i = 0, irq_hdl, rc;
-
-	dev_info(dev->class_dev, "amplc_pci230: attach %s %d,%d\n",
-		 thisboard->name, it->options[0], it->options[1]);
-
-	/* Allocate the private structure area using alloc_private().
-	 * Macro defined in comedidev.h - memsets struct fields to 0. */
-	if ((alloc_private(dev, sizeof(struct pci230_private))) < 0)
-		return -ENOMEM;
-	devpriv = dev->private;
-
-	spin_lock_init(&devpriv->isr_spinlock);
-	spin_lock_init(&devpriv->res_spinlock);
-	spin_lock_init(&devpriv->ai_stop_spinlock);
-	spin_lock_init(&devpriv->ao_stop_spinlock);
-	/* Find card */
-	for_each_pci_dev(pci_dev) {
-		if (it->options[0] || it->options[1]) {
-			/* Match against bus/slot options. */
-			if (it->options[0] != pci_dev->bus->number ||
-			    it->options[1] != PCI_SLOT(pci_dev->devfn))
-				continue;
-		}
-		if (pci_dev->vendor != PCI_VENDOR_ID_AMPLICON)
-			continue;
-		if (thisboard->id == PCI_DEVICE_ID_INVALID) {
-			/* The name was specified as "amplc_pci230" which is
-			 * used to match any supported device.  Replace the
-			 * current dev->board_ptr with one that matches the
-			 * PCI device ID. */
-			for (i = 0; i < n_pci230_boards; i++) {
-				if (pci_dev->device == pci230_boards[i].id) {
-					if (pci230_boards[i].min_hwver > 0) {
-						/* Check for a '+' model.
-						 * First check length of
-						 * registers. */
-						if (pci_resource_len(pci_dev, 3)
-						    < 32) {
-							/* Not a '+' model. */
-							continue;
-						}
-						/* TODO: temporarily enable the
-						 * PCI device and read the
-						 * hardware version register.
-						 * For now assume it's okay. */
-					}
-					/* Change board_ptr to matched board */
-					dev->board_ptr = &pci230_boards[i];
-					thisboard = comedi_board(dev);
-					break;
-				}
-			}
-			if (i < n_pci230_boards)
-				break;
-		} else {
-			/* The name was specified as a specific device name.
-			 * The current dev->board_ptr is correct.  Check
-			 * whether it matches the PCI device ID. */
-			if (thisboard->id == pci_dev->device) {
-				/* Check minimum hardware version. */
-				if (thisboard->min_hwver > 0) {
-					/* Looking for a '+' model.  First
-					 * check length of registers. */
-					if (pci_resource_len(pci_dev, 3) < 32) {
-						/* Not a '+' model. */
-						continue;
-					}
-					/* TODO: temporarily enable the PCI
-					 * device and read the hardware version
-					 * register.  For now, assume it's
-					 * okay. */
-					break;
-				} else {
-					break;
-				}
-			}
-		}
-	}
-	if (!pci_dev) {
-		dev_err(dev->class_dev, "No %s card found\n", thisboard->name);
-		return -EIO;
-	}
-	devpriv->pci_dev = pci_dev;
-
-	/*
-	 * Initialize dev->board_name.
-	 */
-	dev->board_name = thisboard->name;
-
-	/* Enable PCI device and reserve I/O spaces. */
-	if (comedi_pci_enable(pci_dev, "amplc_pci230") < 0) {
-		dev_err(dev->class_dev,
-			"failed to enable PCI device and request regions\n");
-		return -EIO;
-	}
-
-	/* Read base addresses of the PCI230's two I/O regions from PCI
-	 * configuration register. */
-	iobase1 = pci_resource_start(pci_dev, 2);
-	iobase2 = pci_resource_start(pci_dev, 3);
-
-	dev_dbg(dev->class_dev,
-		"%s I/O region 1 0x%04lx I/O region 2 0x%04lx\n",
-		dev->board_name, iobase1, iobase2);
-
-	devpriv->iobase1 = iobase1;
-	dev->iobase = iobase2;
-
-	/* Read bits of DACCON register - only the output range. */
-	devpriv->daccon = inw(dev->iobase + PCI230_DACCON) & PCI230_DAC_OR_MASK;
-
-	/* Read hardware version register and set extended function register
-	 * if they exist. */
-	if (pci_resource_len(pci_dev, 3) >= 32) {
-		unsigned short extfunc = 0;
-
-		devpriv->hwver = inw(dev->iobase + PCI230P_HWVER);
-		if (devpriv->hwver < thisboard->min_hwver) {
-			dev_err(dev->class_dev,
-				"%s - bad hardware version - got %u, need %u\n",
-				dev->board_name, devpriv->hwver,
-				thisboard->min_hwver);
-			return -EIO;
-		}
-		if (devpriv->hwver > 0) {
-			if (!thisboard->have_dio) {
-				/* No DIO ports.  Route counters' external gates
-				 * to the EXTTRIG signal (PCI260+ pin 17).
-				 * (Otherwise, they would be routed to DIO
-				 * inputs PC0, PC1 and PC2 which don't exist
-				 * on PCI260[+].) */
-				extfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;
-			}
-			if ((thisboard->ao_chans > 0)
-			    && (devpriv->hwver >= 2)) {
-				/* Enable DAC FIFO functionality. */
-				extfunc |= PCI230P2_EXTFUNC_DACFIFO;
-			}
-		}
-		outw(extfunc, dev->iobase + PCI230P_EXTFUNC);
-		if ((extfunc & PCI230P2_EXTFUNC_DACFIFO) != 0) {
-			/* Temporarily enable DAC FIFO, reset it and disable
-			 * FIFO wraparound. */
-			outw(devpriv->daccon | PCI230P2_DAC_FIFO_EN
-			     | PCI230P2_DAC_FIFO_RESET,
-			     dev->iobase + PCI230_DACCON);
-			/* Clear DAC FIFO channel enable register. */
-			outw(0, dev->iobase + PCI230P2_DACEN);
-			/* Disable DAC FIFO. */
-			outw(devpriv->daccon, dev->iobase + PCI230_DACCON);
-		}
-	}
-
-	/* Disable board's interrupts. */
-	outb(0, devpriv->iobase1 + PCI230_INT_SCE);
-
-	/* Set ADC to a reasonable state. */
-	devpriv->adcg = 0;
-	devpriv->adccon = PCI230_ADC_TRIG_NONE | PCI230_ADC_IM_SE
-	    | PCI230_ADC_IR_BIP;
-	outw(1 << 0, dev->iobase + PCI230_ADCEN);
-	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
-	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
-	     dev->iobase + PCI230_ADCCON);
-
-	/* Register the interrupt handler. */
-	irq_hdl = request_irq(devpriv->pci_dev->irq, pci230_interrupt,
-			      IRQF_SHARED, "amplc_pci230", dev);
-	if (irq_hdl < 0) {
-		dev_warn(dev->class_dev,
-			 "unable to register irq %u, commands will not be available\n",
-			 devpriv->pci_dev->irq);
-	} else {
-		dev->irq = devpriv->pci_dev->irq;
-		dev_dbg(dev->class_dev, "registered irq %u\n",
-			devpriv->pci_dev->irq);
-	}
-
-	/*
-	 * Allocate the subdevice structures.  alloc_subdevice() is a
-	 * convenient macro defined in comedidev.h.
-	 */
-	if (alloc_subdevices(dev, 3) < 0)
-		return -ENOMEM;
-
-	s = dev->subdevices + 0;
-	/* analog input subdevice */
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;
-	s->n_chan = thisboard->ai_chans;
-	s->maxdata = (1 << thisboard->ai_bits) - 1;
-	s->range_table = &pci230_ai_range;
-	s->insn_read = &pci230_ai_rinsn;
-	s->len_chanlist = 256;	/* but there are restrictions. */
-	/* Only register commands if the interrupt handler is installed. */
-	if (irq_hdl == 0) {
-		dev->read_subdev = s;
-		s->subdev_flags |= SDF_CMD_READ;
-		s->do_cmd = &pci230_ai_cmd;
-		s->do_cmdtest = &pci230_ai_cmdtest;
-		s->cancel = pci230_ai_cancel;
-	}
-
-	s = dev->subdevices + 1;
-	/* analog output subdevice */
-	if (thisboard->ao_chans > 0) {
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
-		s->n_chan = thisboard->ao_chans;
-		s->maxdata = (1 << thisboard->ao_bits) - 1;
-		s->range_table = &pci230_ao_range;
-		s->insn_write = &pci230_ao_winsn;
-		s->insn_read = &pci230_ao_rinsn;
-		s->len_chanlist = thisboard->ao_chans;
-		/* Only register commands if the interrupt handler is
-		 * installed. */
-		if (irq_hdl == 0) {
-			dev->write_subdev = s;
-			s->subdev_flags |= SDF_CMD_WRITE;
-			s->do_cmd = &pci230_ao_cmd;
-			s->do_cmdtest = &pci230_ao_cmdtest;
-			s->cancel = pci230_ao_cancel;
-		}
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
-
-	s = dev->subdevices + 2;
-	/* digital i/o subdevice */
-	if (thisboard->have_dio) {
-		rc = subdev_8255_init(dev, s, NULL,
-				      (devpriv->iobase1 + PCI230_PPI_X_BASE));
-		if (rc < 0)
-			return rc;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
-
-	dev_info(dev->class_dev, "attached\n");
-
-	return 1;
-}
-
-static void pci230_detach(struct comedi_device *dev)
-{
-	const struct pci230_board *thisboard = comedi_board(dev);
-	struct pci230_private *devpriv = dev->private;
-
-	if (dev->subdevices && thisboard->have_dio)
-		subdev_8255_cleanup(dev, dev->subdevices + 2);
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	if (devpriv) {
-		if (devpriv->pci_dev) {
-			if (dev->iobase)
-				comedi_pci_disable(devpriv->pci_dev);
-			pci_dev_put(devpriv->pci_dev);
-		}
-	}
-}
-
 static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 			 unsigned char owner)
 {
@@ -2995,10 +2718,311 @@ static int pci230_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
+/* Check if PCI device matches a specific board. */
+static bool pci230_match_pci_board(const struct pci230_board *board,
+				   struct pci_dev *pci_dev)
+{
+	/* assume pci_dev->device != PCI_DEVICE_ID_INVALID */
+	if (board->id != pci_dev->device)
+		return false;
+	if (board->min_hwver == 0)
+		return true;
+	/* Looking for a '+' model.  First check length of registers. */
+	if (pci_resource_len(pci_dev, 3) < 32)
+		return false;	/* Not a '+' model. */
+	/* TODO: temporarily enable PCI device and read the hardware version
+	 * register.  For now, assume it's okay. */
+	return true;
+}
+
+/* Look for board matching PCI device. */
+static const struct pci230_board *pci230_find_pci_board(struct pci_dev *pci_dev)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(pci230_boards); i++)
+		if (pci230_match_pci_board(&pci230_boards[i], pci_dev))
+			return &pci230_boards[i];
+	return NULL;
+}
+
+/* Look for PCI device matching requested board name, bus and slot. */
+static struct pci_dev *pci230_find_pci(struct comedi_device *dev,
+				       int bus, int slot)
+{
+	const struct pci230_board *thisboard = comedi_board(dev);
+	struct pci_dev *pci_dev = NULL;
+
+	for_each_pci_dev(pci_dev) {
+		/* Check vendor ID (same for all supported PCI boards). */
+		if (pci_dev->vendor != PCI_VENDOR_ID_AMPLICON)
+			continue;
+		/* If bus/slot specified, check them. */
+		if ((bus || slot) &&
+		    (bus != pci_dev->bus->number ||
+		     slot != PCI_SLOT(pci_dev->devfn)))
+			continue;
+		if (thisboard->id == PCI_DEVICE_ID_INVALID) {
+			/* Wildcard board matches any supported PCI board. */
+			const struct pci230_board *foundboard;
+
+			foundboard = pci230_find_pci_board(pci_dev);
+			if (foundboard == NULL)
+				continue;
+			/* Replace wildcard board_ptr. */
+			dev->board_ptr = foundboard;
+			thisboard = comedi_board(dev);
+		} else {
+			/* Need to match a specific board. */
+			if (!pci230_match_pci_board(thisboard, pci_dev))
+				continue;
+		}
+		/* Found a matching PCI device. */
+		return pci_dev;
+	}
+	/* No matching PCI device found. */
+	if (bus || slot)
+		dev_err(dev->class_dev,
+			"error! no %s found at pci %02x:%02x\n",
+			thisboard->name, bus, slot);
+	else
+		dev_err(dev->class_dev,
+			"error! no %s found\n", thisboard->name);
+	return NULL;
+}
+
+static int pci230_alloc_private(struct comedi_device *dev)
+{
+	struct pci230_private *devpriv;
+	int err;
+
+	/* sets dev->private to allocated memory */
+	err = alloc_private(dev, sizeof(struct pci230_private));
+	if (err) {
+		dev_err(dev->class_dev, "error! out of memory!\n");
+		return err;
+	}
+	devpriv = dev->private;
+	spin_lock_init(&devpriv->isr_spinlock);
+	spin_lock_init(&devpriv->res_spinlock);
+	spin_lock_init(&devpriv->ai_stop_spinlock);
+	spin_lock_init(&devpriv->ao_stop_spinlock);
+	return 0;
+}
+
+/* Common part of attach and attach_pci. */
+static int pci230_attach_common(struct comedi_device *dev,
+				struct pci_dev *pci_dev)
+{
+	const struct pci230_board *thisboard = comedi_board(dev);
+	struct pci230_private *devpriv = dev->private;
+	struct comedi_subdevice *s;
+	unsigned long iobase1, iobase2;
+	/* PCI230's I/O spaces 1 and 2 respectively. */
+	int irq_hdl, rc;
+
+	devpriv->pci_dev = pci_dev;
+	dev->board_name = thisboard->name;
+	/* Enable PCI device and reserve I/O spaces. */
+	if (comedi_pci_enable(pci_dev, "amplc_pci230") < 0) {
+		dev_err(dev->class_dev,
+			"failed to enable PCI device and request regions\n");
+		return -EIO;
+	}
+	/* Read base addresses of the PCI230's two I/O regions from PCI
+	 * configuration register. */
+	iobase1 = pci_resource_start(pci_dev, 2);
+	iobase2 = pci_resource_start(pci_dev, 3);
+	dev_dbg(dev->class_dev,
+		"%s I/O region 1 0x%04lx I/O region 2 0x%04lx\n",
+		dev->board_name, iobase1, iobase2);
+	devpriv->iobase1 = iobase1;
+	dev->iobase = iobase2;
+	/* Read bits of DACCON register - only the output range. */
+	devpriv->daccon = inw(dev->iobase + PCI230_DACCON) & PCI230_DAC_OR_MASK;
+	/* Read hardware version register and set extended function register
+	 * if they exist. */
+	if (pci_resource_len(pci_dev, 3) >= 32) {
+		unsigned short extfunc = 0;
+
+		devpriv->hwver = inw(dev->iobase + PCI230P_HWVER);
+		if (devpriv->hwver < thisboard->min_hwver) {
+			dev_err(dev->class_dev,
+				"%s - bad hardware version - got %u, need %u\n",
+				dev->board_name, devpriv->hwver,
+				thisboard->min_hwver);
+			return -EIO;
+		}
+		if (devpriv->hwver > 0) {
+			if (!thisboard->have_dio) {
+				/* No DIO ports.  Route counters' external gates
+				 * to the EXTTRIG signal (PCI260+ pin 17).
+				 * (Otherwise, they would be routed to DIO
+				 * inputs PC0, PC1 and PC2 which don't exist
+				 * on PCI260[+].) */
+				extfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;
+			}
+			if ((thisboard->ao_chans > 0)
+			    && (devpriv->hwver >= 2)) {
+				/* Enable DAC FIFO functionality. */
+				extfunc |= PCI230P2_EXTFUNC_DACFIFO;
+			}
+		}
+		outw(extfunc, dev->iobase + PCI230P_EXTFUNC);
+		if ((extfunc & PCI230P2_EXTFUNC_DACFIFO) != 0) {
+			/* Temporarily enable DAC FIFO, reset it and disable
+			 * FIFO wraparound. */
+			outw(devpriv->daccon | PCI230P2_DAC_FIFO_EN
+			     | PCI230P2_DAC_FIFO_RESET,
+			     dev->iobase + PCI230_DACCON);
+			/* Clear DAC FIFO channel enable register. */
+			outw(0, dev->iobase + PCI230P2_DACEN);
+			/* Disable DAC FIFO. */
+			outw(devpriv->daccon, dev->iobase + PCI230_DACCON);
+		}
+	}
+	/* Disable board's interrupts. */
+	outb(0, devpriv->iobase1 + PCI230_INT_SCE);
+	/* Set ADC to a reasonable state. */
+	devpriv->adcg = 0;
+	devpriv->adccon = PCI230_ADC_TRIG_NONE | PCI230_ADC_IM_SE
+	    | PCI230_ADC_IR_BIP;
+	outw(1 << 0, dev->iobase + PCI230_ADCEN);
+	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
+	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
+	     dev->iobase + PCI230_ADCCON);
+	/* Register the interrupt handler. */
+	irq_hdl = request_irq(devpriv->pci_dev->irq, pci230_interrupt,
+			      IRQF_SHARED, "amplc_pci230", dev);
+	if (irq_hdl < 0) {
+		dev_warn(dev->class_dev,
+			 "unable to register irq %u, commands will not be available\n",
+			 devpriv->pci_dev->irq);
+	} else {
+		dev->irq = devpriv->pci_dev->irq;
+		dev_dbg(dev->class_dev, "registered irq %u\n",
+			devpriv->pci_dev->irq);
+	}
+	/*
+	 * Allocate the subdevice structures.  alloc_subdevice() is a
+	 * convenient macro defined in comedidev.h.
+	 */
+	if (alloc_subdevices(dev, 3) < 0)
+		return -ENOMEM;
+	s = dev->subdevices + 0;
+	/* analog input subdevice */
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;
+	s->n_chan = thisboard->ai_chans;
+	s->maxdata = (1 << thisboard->ai_bits) - 1;
+	s->range_table = &pci230_ai_range;
+	s->insn_read = &pci230_ai_rinsn;
+	s->len_chanlist = 256;	/* but there are restrictions. */
+	/* Only register commands if the interrupt handler is installed. */
+	if (irq_hdl == 0) {
+		dev->read_subdev = s;
+		s->subdev_flags |= SDF_CMD_READ;
+		s->do_cmd = &pci230_ai_cmd;
+		s->do_cmdtest = &pci230_ai_cmdtest;
+		s->cancel = pci230_ai_cancel;
+	}
+	s = dev->subdevices + 1;
+	/* analog output subdevice */
+	if (thisboard->ao_chans > 0) {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
+		s->n_chan = thisboard->ao_chans;
+		s->maxdata = (1 << thisboard->ao_bits) - 1;
+		s->range_table = &pci230_ao_range;
+		s->insn_write = &pci230_ao_winsn;
+		s->insn_read = &pci230_ao_rinsn;
+		s->len_chanlist = thisboard->ao_chans;
+		/* Only register commands if the interrupt handler is
+		 * installed. */
+		if (irq_hdl == 0) {
+			dev->write_subdev = s;
+			s->subdev_flags |= SDF_CMD_WRITE;
+			s->do_cmd = &pci230_ao_cmd;
+			s->do_cmdtest = &pci230_ao_cmdtest;
+			s->cancel = pci230_ao_cancel;
+		}
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+	s = dev->subdevices + 2;
+	/* digital i/o subdevice */
+	if (thisboard->have_dio) {
+		rc = subdev_8255_init(dev, s, NULL,
+				      (devpriv->iobase1 + PCI230_PPI_X_BASE));
+		if (rc < 0)
+			return rc;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+	dev_info(dev->class_dev, "attached\n");
+	return 1;
+}
+
+static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+	const struct pci230_board *thisboard = comedi_board(dev);
+	struct pci_dev *pci_dev;
+	int rc;
+
+	dev_info(dev->class_dev, "amplc_pci230: attach %s %d,%d\n",
+		 thisboard->name, it->options[0], it->options[1]);
+	rc = pci230_alloc_private(dev); /* sets dev->private */
+	if (rc)
+		return rc;
+	/* Find card. */
+	pci_dev = pci230_find_pci(dev, it->options[0], it->options[1]);
+	if (!pci_dev)
+		return -EIO;
+	return pci230_attach_common(dev, pci_dev);
+}
+
+static int __devinit pci230_attach_pci(struct comedi_device *dev,
+				       struct pci_dev *pci_dev)
+{
+	int rc;
+
+	dev_info(dev->class_dev, "amplc_pci230: attach pci %s\n",
+		 pci_name(pci_dev));
+	rc = pci230_alloc_private(dev); /* sets dev->private */
+	if (rc)
+		return rc;
+	dev->board_ptr = pci230_find_pci_board(pci_dev);
+	if (dev->board_ptr == NULL) {
+		dev_err(dev->class_dev,
+			"amplc_pci230: BUG! cannot determine board type!\n");
+		return -EINVAL;
+	}
+	return pci230_attach_common(dev, pci_dev);
+}
+
+static void pci230_detach(struct comedi_device *dev)
+{
+	const struct pci230_board *thisboard = comedi_board(dev);
+	struct pci230_private *devpriv = dev->private;
+
+	if (dev->subdevices && thisboard->have_dio)
+		subdev_8255_cleanup(dev, dev->subdevices + 2);
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	if (devpriv) {
+		if (devpriv->pci_dev) {
+			if (dev->iobase)
+				comedi_pci_disable(devpriv->pci_dev);
+			pci_dev_put(devpriv->pci_dev);
+		}
+	}
+}
+
 static struct comedi_driver amplc_pci230_driver = {
 	.driver_name	= "amplc_pci230",
 	.module		= THIS_MODULE,
 	.attach		= pci230_attach,
+	.attach_pci	= pci230_attach_pci,
 	.detach		= pci230_detach,
 	.board_name	= &pci230_boards[0].name,
 	.offset		= sizeof(pci230_boards[0]),

commit 967bfbc2c90e456bdfc0ef045dd1e81221461c06
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 1 17:31:40 2012 +0100

    staging: comedi: amplc_pci230: Remove thisboard and devpriv macros
    
    The 'thisboard' and 'devpriv' macros rely on a local variable having a
    specific name and yield pointers derived from that local variable.
    Replace the macros with local variables wherever they occur.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 512ead739895..6d3c6c9dff00 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -499,11 +499,7 @@ static const struct pci230_board pci230_boards[] = {
 	 },
 };
 
-/*
- * Useful for shorthand access to the particular board structure
- */
 #define n_pci230_boards ARRAY_SIZE(pci230_boards)
-#define thisboard ((const struct pci230_board *)dev->board_ptr)
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
@@ -548,8 +544,6 @@ struct pci230_private {
 	unsigned char res_owner[NUM_RESOURCES];	/* Shared resource owners. */
 };
 
-#define devpriv ((struct pci230_private *)dev->private)
-
 /* PCI230 clock source periods in ns */
 static const unsigned int pci230_timebase[8] = {
 	[CLK_10MHZ] = TIMEBASE_10MHZ,
@@ -627,9 +621,12 @@ static void pci230_handle_ai(struct comedi_device *dev,
 
 static short pci230_ai_read(struct comedi_device *dev)
 {
-	/* Read sample. */
-	short data = (short)inw(dev->iobase + PCI230_ADCDATA);
+	const struct pci230_board *thisboard = comedi_board(dev);
+	struct pci230_private *devpriv = dev->private;
+	short data;
 
+	/* Read sample. */
+	data = (short)inw(dev->iobase + PCI230_ADCDATA);
 	/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
 	 * four bits reserved for expansion). */
 	/* PCI230+ is 16 bit AI. */
@@ -646,12 +643,14 @@ static short pci230_ai_read(struct comedi_device *dev)
 static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
 						    short datum)
 {
+	const struct pci230_board *thisboard = comedi_board(dev);
+	struct pci230_private *devpriv = dev->private;
+
 	/* If a bipolar range was specified, mangle it (straight binary->twos
 	 * complement). */
 	if (devpriv->ao_bipolar)
 		datum ^= 1 << (thisboard->ao_bits - 1);
 
-
 	/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
 	 * four bits reserved for expansion). */
 	/* PCI230+ is also 12 bit AO. */
@@ -662,6 +661,8 @@ static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
 static inline void pci230_ao_write_nofifo(struct comedi_device *dev,
 					  short datum, unsigned int chan)
 {
+	struct pci230_private *devpriv = dev->private;
+
 	/* Store unmangled datum to be read back later. */
 	devpriv->ao_readback[chan] = datum;
 
@@ -675,6 +676,8 @@ static inline void pci230_ao_write_nofifo(struct comedi_device *dev,
 static inline void pci230_ao_write_fifo(struct comedi_device *dev, short datum,
 					unsigned int chan)
 {
+	struct pci230_private *devpriv = dev->private;
+
 	/* Store unmangled datum to be read back later. */
 	devpriv->ao_readback[chan] = datum;
 
@@ -691,6 +694,8 @@ static inline void pci230_ao_write_fifo(struct comedi_device *dev, short datum,
  */
 static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct pci230_board *thisboard = comedi_board(dev);
+	struct pci230_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned long iobase1, iobase2;
 	/* PCI230's I/O spaces 1 and 2 respectively. */
@@ -704,6 +709,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	 * Macro defined in comedidev.h - memsets struct fields to 0. */
 	if ((alloc_private(dev, sizeof(struct pci230_private))) < 0)
 		return -ENOMEM;
+	devpriv = dev->private;
 
 	spin_lock_init(&devpriv->isr_spinlock);
 	spin_lock_init(&devpriv->res_spinlock);
@@ -742,6 +748,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 					}
 					/* Change board_ptr to matched board */
 					dev->board_ptr = &pci230_boards[i];
+					thisboard = comedi_board(dev);
 					break;
 				}
 			}
@@ -938,6 +945,9 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void pci230_detach(struct comedi_device *dev)
 {
+	const struct pci230_board *thisboard = comedi_board(dev);
+	struct pci230_private *devpriv = dev->private;
+
 	if (dev->subdevices && thisboard->have_dio)
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
 	if (dev->irq)
@@ -954,6 +964,7 @@ static void pci230_detach(struct comedi_device *dev)
 static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 			 unsigned char owner)
 {
+	struct pci230_private *devpriv = dev->private;
 	int ok;
 	unsigned int i;
 	unsigned int b;
@@ -996,6 +1007,7 @@ static inline int get_one_resource(struct comedi_device *dev,
 static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 			  unsigned char owner)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned int i;
 	unsigned int b;
 	unsigned long irqflags;
@@ -1032,6 +1044,7 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned int n, i;
 	unsigned int chan, range, aref;
 	unsigned int gainshift;
@@ -1136,6 +1149,7 @@ static int pci230_ao_winsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	struct pci230_private *devpriv = dev->private;
 	int i;
 	int chan, range;
 
@@ -1165,6 +1179,7 @@ static int pci230_ao_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	struct pci230_private *devpriv = dev->private;
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -1177,6 +1192,8 @@ static int pci230_ao_rinsn(struct comedi_device *dev,
 static int pci230_ao_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
+	const struct pci230_board *thisboard = comedi_board(dev);
+	struct pci230_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int tmp;
 
@@ -1390,6 +1407,7 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 					struct comedi_subdevice *s,
 					unsigned int trig_num)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned long irqflags;
 
 	if (trig_num != 0)
@@ -1422,6 +1440,7 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 static void pci230_ao_start(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	struct pci230_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long irqflags;
@@ -1523,6 +1542,7 @@ static int pci230_ao_inttrig_start(struct comedi_device *dev,
 
 static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned short daccon;
 	unsigned int range;
 
@@ -1625,6 +1645,8 @@ static int pci230_ai_check_scan_period(struct comedi_cmd *cmd)
 static int pci230_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
+	const struct pci230_board *thisboard = comedi_board(dev);
+	struct pci230_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int tmp;
 
@@ -2006,6 +2028,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 						struct comedi_subdevice *s)
 {
+	struct pci230_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int scanlen = cmd->scan_end_arg;
 	unsigned int wake;
@@ -2050,6 +2073,7 @@ static int pci230_ai_inttrig_convert(struct comedi_device *dev,
 				     struct comedi_subdevice *s,
 				     unsigned int trig_num)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned long irqflags;
 
 	if (trig_num != 0)
@@ -2092,6 +2116,7 @@ static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
 					struct comedi_subdevice *s,
 					unsigned int trig_num)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned long irqflags;
 	unsigned char zgat;
 
@@ -2114,6 +2139,7 @@ static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
 static void pci230_ai_start(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned long irqflags;
 	unsigned short conv;
 	struct comedi_async *async = s->async;
@@ -2264,6 +2290,7 @@ static int pci230_ai_inttrig_start(struct comedi_device *dev,
 
 static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned int i, chan, range, diff;
 	unsigned int res_mask;
 	unsigned short adccon, adcen;
@@ -2509,6 +2536,7 @@ static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 				    unsigned int mode, uint64_t ns,
 				    unsigned int round)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned int clk_src;
 	unsigned int count;
 
@@ -2527,6 +2555,8 @@ static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 
 static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)
 {
+	struct pci230_private *devpriv = dev->private;
+
 	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct,
 		       I8254_MODE1);
 	/* Counter ct, 8254 mode 1, initial count not written. */
@@ -2537,6 +2567,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 {
 	unsigned char status_int, valid_status_int;
 	struct comedi_device *dev = (struct comedi_device *)d;
+	struct pci230_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	unsigned long irqflags;
 
@@ -2599,6 +2630,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
+	struct pci230_private *devpriv = dev->private;
 	short data;
 	int i, ret;
 	struct comedi_async *async = s->async;
@@ -2637,6 +2669,7 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 static int pci230_handle_ao_fifo(struct comedi_device *dev,
 				 struct comedi_subdevice *s)
 {
+	struct pci230_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int num_scans;
@@ -2742,6 +2775,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 static void pci230_handle_ai(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned int events = 0;
 	unsigned int status_fifo;
 	unsigned int i;
@@ -2842,6 +2876,7 @@ static void pci230_handle_ai(struct comedi_device *dev,
 static void pci230_ao_stop(struct comedi_device *dev,
 			   struct comedi_subdevice *s)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned long irqflags;
 	unsigned char intsrc;
 	int started;
@@ -2905,6 +2940,7 @@ static int pci230_ao_cancel(struct comedi_device *dev,
 static void pci230_ai_stop(struct comedi_device *dev,
 			   struct comedi_subdevice *s)
 {
+	struct pci230_private *devpriv = dev->private;
 	unsigned long irqflags;
 	struct comedi_cmd *cmd;
 	int started;

commit 4b05d17d8dcea60ccb1c39aaec60164dccdbc3e5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 1 17:31:39 2012 +0100

    staging: comedi: amplc_pci230: Replace printk calls
    
    Replace the printk calls with dev_info, dev_err, etc.
    
    A load of DPRINTK() macro calls which may result in printk() calls
    have been left alone to be tackled en masse at a later date.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index b05a684b80ba..512ead739895 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -697,8 +697,8 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct pci_dev *pci_dev = NULL;
 	int i = 0, irq_hdl, rc;
 
-	printk("comedi%d: amplc_pci230: attach %s %d,%d\n", dev->minor,
-	       thisboard->name, it->options[0], it->options[1]);
+	dev_info(dev->class_dev, "amplc_pci230: attach %s %d,%d\n",
+		 thisboard->name, it->options[0], it->options[1]);
 
 	/* Allocate the private structure area using alloc_private().
 	 * Macro defined in comedidev.h - memsets struct fields to 0. */
@@ -772,8 +772,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 	if (!pci_dev) {
-		printk("comedi%d: No %s card found\n", dev->minor,
-		       thisboard->name);
+		dev_err(dev->class_dev, "No %s card found\n", thisboard->name);
 		return -EIO;
 	}
 	devpriv->pci_dev = pci_dev;
@@ -785,8 +784,8 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* Enable PCI device and reserve I/O spaces. */
 	if (comedi_pci_enable(pci_dev, "amplc_pci230") < 0) {
-		printk("comedi%d: failed to enable PCI device "
-		       "and request regions\n", dev->minor);
+		dev_err(dev->class_dev,
+			"failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
 
@@ -795,8 +794,9 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	iobase1 = pci_resource_start(pci_dev, 2);
 	iobase2 = pci_resource_start(pci_dev, 3);
 
-	printk("comedi%d: %s I/O region 1 0x%04lx I/O region 2 0x%04lx\n",
-	       dev->minor, dev->board_name, iobase1, iobase2);
+	dev_dbg(dev->class_dev,
+		"%s I/O region 1 0x%04lx I/O region 2 0x%04lx\n",
+		dev->board_name, iobase1, iobase2);
 
 	devpriv->iobase1 = iobase1;
 	dev->iobase = iobase2;
@@ -811,10 +811,10 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		devpriv->hwver = inw(dev->iobase + PCI230P_HWVER);
 		if (devpriv->hwver < thisboard->min_hwver) {
-			printk("comedi%d: %s - bad hardware version "
-			       "- got %u, need %u\n", dev->minor,
-			       dev->board_name, devpriv->hwver,
-			       thisboard->min_hwver);
+			dev_err(dev->class_dev,
+				"%s - bad hardware version - got %u, need %u\n",
+				dev->board_name, devpriv->hwver,
+				thisboard->min_hwver);
 			return -EIO;
 		}
 		if (devpriv->hwver > 0) {
@@ -862,13 +862,13 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	irq_hdl = request_irq(devpriv->pci_dev->irq, pci230_interrupt,
 			      IRQF_SHARED, "amplc_pci230", dev);
 	if (irq_hdl < 0) {
-		printk("comedi%d: unable to register irq, "
-		       "commands will not be available %d\n", dev->minor,
-		       devpriv->pci_dev->irq);
+		dev_warn(dev->class_dev,
+			 "unable to register irq %u, commands will not be available\n",
+			 devpriv->pci_dev->irq);
 	} else {
 		dev->irq = devpriv->pci_dev->irq;
-		printk("comedi%d: registered irq %u\n", dev->minor,
-		       devpriv->pci_dev->irq);
+		dev_dbg(dev->class_dev, "registered irq %u\n",
+			devpriv->pci_dev->irq);
 	}
 
 	/*
@@ -931,7 +931,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	printk("comedi%d: attached\n", dev->minor);
+	dev_info(dev->class_dev, "attached\n");
 
 	return 1;
 }
@@ -1117,9 +1117,7 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 			udelay(1);
 		}
 		if (i == TIMEOUT) {
-			/* printk() should be used instead of printk()
-			 * whenever the code can be called from real-time. */
-			printk("timeout\n");
+			dev_err(dev->class_dev, "timeout\n");
 			return -ETIMEDOUT;
 		}
 
@@ -1992,13 +1990,9 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 					(s->n_chan / 2) - 1);
 			}
 			if ((errors & buggy_chan0_err) != 0) {
-				/* Use printk instead of DPRINTK here. */
-				printk("comedi: comedi%d: amplc_pci230: "
-				       "ai_cmdtest: Buggy PCI230+/260+ "
-				       "h/w version %u requires first channel "
-				       "of multi-channel sequence to be 0 "
-				       "(corrected in h/w version 4)\n",
-				       dev->minor, devpriv->hwver);
+				dev_info(dev->class_dev,
+					 "amplc_pci230: ai_cmdtest: Buggy PCI230+/260+ h/w version %u requires first channel of multi-channel sequence to be 0 (corrected in h/w version 4)\n",
+					 devpriv->hwver);
 			}
 		}
 	}

commit 55c03cff7fd73349473cc0a964df9d55b312dbbc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon May 21 17:12:12 2012 -0700

    staging: comedi: remove private header comedi_pci.h
    
    Remove the private header, comedi_pci.h, by moving the two
    helper functions into divers.c and providing the prototypes
    in comedidev.h.
    
    This allows the comedi_pci_enable/disable helper functions
    to be shared instead of having an inline version in every
    comedi pci driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index d4c80b1281f2..b05a684b80ba 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -193,7 +193,6 @@ for (or detection of) various hardware problems added by Ian Abbott.
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 
-#include "comedi_pci.h"
 #include "8253.h"
 #include "8255.h"
 

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 2a23f158c288..d4c80b1281f2 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -937,35 +937,19 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 1;
 }
 
-/*
- * _detach is called to deconfigure a device.  It should deallocate
- * resources.
- * This function is also called when _attach() fails, so it should be
- * careful not to release resources that were not necessarily
- * allocated by _attach().  dev->private and dev->subdevices are
- * deallocated automatically by the core.
- */
-static int pci230_detach(struct comedi_device *dev)
+static void pci230_detach(struct comedi_device *dev)
 {
-	printk("comedi%d: amplc_pci230: remove\n", dev->minor);
-
 	if (dev->subdevices && thisboard->have_dio)
-		/* Clean up dio subdevice. */
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
-
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-
 	if (devpriv) {
 		if (devpriv->pci_dev) {
 			if (dev->iobase)
 				comedi_pci_disable(devpriv->pci_dev);
-
 			pci_dev_put(devpriv->pci_dev);
 		}
 	}
-
-	return 0;
 }
 
 static int get_resources(struct comedi_device *dev, unsigned int res_mask,

commit c57630673b84a2e0563ea63117062b1ab51f4bbf
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 15 14:08:11 2012 -0700

    staging: comedi: refactor amplc_pci230 driver and use module_comedi_pci_driver
    
    Move the module_init/module_exit routines and the associated
    struct comedi_drive and struct pci_driver to the end of the
    source. This is more typical of how other drivers are written
    and removes the need for the forward declarations.
    
    Convert the driver to use the module_comedi_pci_driver() macro
    which makes the code smaller and a bit simpler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 1d2eb47d32b4..2a23f158c288 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -500,13 +500,6 @@ static const struct pci230_board pci230_boards[] = {
 	 },
 };
 
-static DEFINE_PCI_DEVICE_TABLE(pci230_pci_table) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI230) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI260) },
-	{0}
-};
-
-MODULE_DEVICE_TABLE(pci, pci230_pci_table);
 /*
  * Useful for shorthand access to the particular board structure
  */
@@ -595,65 +588,6 @@ static const struct comedi_lrange pci230_ao_range = { 2, {
 /* PCI230 daccon bipolar flag for each analogue output range. */
 static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
 
-/*
- * The struct comedi_driver structure tells the Comedi core module
- * which functions to call to configure/deconfigure (attach/detach)
- * the board, and also about the kernel module that contains
- * the device code.
- */
-static int pci230_attach(struct comedi_device *dev,
-			 struct comedi_devconfig *it);
-static int pci230_detach(struct comedi_device *dev);
-static struct comedi_driver driver_amplc_pci230 = {
-	.driver_name = "amplc_pci230",
-	.module = THIS_MODULE,
-	.attach = pci230_attach,
-	.detach = pci230_detach,
-	.board_name = &pci230_boards[0].name,
-	.offset = sizeof(pci230_boards[0]),
-	.num_names = ARRAY_SIZE(pci230_boards),
-};
-
-static int __devinit driver_amplc_pci230_pci_probe(struct pci_dev *dev,
-						   const struct pci_device_id
-						   *ent)
-{
-	return comedi_pci_auto_config(dev, &driver_amplc_pci230);
-}
-
-static void __devexit driver_amplc_pci230_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
-static struct pci_driver driver_amplc_pci230_pci_driver = {
-	.id_table = pci230_pci_table,
-	.probe = &driver_amplc_pci230_pci_probe,
-	.remove = __devexit_p(&driver_amplc_pci230_pci_remove)
-};
-
-static int __init driver_amplc_pci230_init_module(void)
-{
-	int retval;
-
-	retval = comedi_driver_register(&driver_amplc_pci230);
-	if (retval < 0)
-		return retval;
-
-	driver_amplc_pci230_pci_driver.name =
-	    (char *)driver_amplc_pci230.driver_name;
-	return pci_register_driver(&driver_amplc_pci230_pci_driver);
-}
-
-static void __exit driver_amplc_pci230_cleanup_module(void)
-{
-	pci_unregister_driver(&driver_amplc_pci230_pci_driver);
-	comedi_driver_unregister(&driver_amplc_pci230);
-}
-
-module_init(driver_amplc_pci230_init_module);
-module_exit(driver_amplc_pci230_cleanup_module);
-
 static int pci230_ai_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data);
@@ -3048,6 +2982,42 @@ static int pci230_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
+static struct comedi_driver amplc_pci230_driver = {
+	.driver_name	= "amplc_pci230",
+	.module		= THIS_MODULE,
+	.attach		= pci230_attach,
+	.detach		= pci230_detach,
+	.board_name	= &pci230_boards[0].name,
+	.offset		= sizeof(pci230_boards[0]),
+	.num_names	= ARRAY_SIZE(pci230_boards),
+};
+
+static int __devinit amplc_pci230_pci_probe(struct pci_dev *dev,
+					    const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, &amplc_pci230_driver);
+}
+
+static void __devexit amplc_pci230_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(amplc_pci230_pci_table) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI230) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI260) },
+	{ 0 }
+};
+MODULE_DEVICE_TABLE(pci, amplc_pci230_pci_table);
+
+static struct pci_driver amplc_pci230_pci_driver = {
+	.name		= "amplc_pci230",
+	.id_table	= amplc_pci230_pci_table,
+	.probe		= amplc_pci230_pci_probe,
+	.remove		= __devexit_p(amplc_pci230_pci_remove)
+};
+module_comedi_pci_driver(amplc_pci230_driver, amplc_pci230_pci_driver);
+
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");
 MODULE_LICENSE("GPL");

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 538979551c8e..1d2eb47d32b4 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -618,7 +618,7 @@ static int __devinit driver_amplc_pci230_pci_probe(struct pci_dev *dev,
 						   const struct pci_device_id
 						   *ent)
 {
-	return comedi_pci_auto_config(dev, driver_amplc_pci230.driver_name);
+	return comedi_pci_auto_config(dev, &driver_amplc_pci230);
 }
 
 static void __devexit driver_amplc_pci230_pci_remove(struct pci_dev *dev)

commit 7b0be12b26d86ea2bd5079f0d723289e2f5a43a9
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Mon Nov 7 00:54:02 2011 +0100

    staging/comedi/amplc: Convert pci_table entries to PCI_DEVICE (if PCI_ANY_ID is used)
    
    This patch converts pci_table entries to use the PCI_DEVICE macro,
    if .subvendor and .subdevice are set to PCI_ANY_ID,
    and thus improves readablity.
    
    Since the driver_data field isn't used anywhere we can also drop the
    assignments for class, class_mask and driver_data.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 7edeb1103dc8..538979551c8e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -501,12 +501,9 @@ static const struct pci230_board pci230_boards[] = {
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pci230_pci_table) = {
-	{
-	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI230, PCI_ANY_ID,
-		    PCI_ANY_ID, 0, 0, 0}, {
-	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI260, PCI_ANY_ID,
-		    PCI_ANY_ID, 0, 0, 0}, {
-	0}
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI230) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI260) },
+	{0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci230_pci_table);

commit 859171ca92f2865453b4b2e17bf679c67044a833
Author: Joe Perches <joe@perches.com>
Date:   Sun Nov 14 19:04:48 2010 -0800

    drivers/staging: Remove unnecessary semicolons
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 5d064577b2f1..7edeb1103dc8 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -971,7 +971,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (thisboard->ao_chans > 0) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
-		s->n_chan = thisboard->ao_chans;;
+		s->n_chan = thisboard->ao_chans;
 		s->maxdata = (1 << thisboard->ao_bits) - 1;
 		s->range_table = &pci230_ao_range;
 		s->insn_write = &pci230_ao_winsn;

commit 20fb2280815510533cbd7785b53821ca7209345b
Author: Kulikov Vasiliy <segooon@gmail.com>
Date:   Sat Jul 3 19:20:47 2010 +0400

    Staging: comedi: use for_each_pci_dev()
    
    Use for_each_pci_dev() to simplify the code.
    
    Signed-off-by: Kulikov Vasiliy <segooon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index b572df718f21..5d064577b2f1 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -764,7 +764,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	unsigned long iobase1, iobase2;
 	/* PCI230's I/O spaces 1 and 2 respectively. */
-	struct pci_dev *pci_dev;
+	struct pci_dev *pci_dev = NULL;
 	int i = 0, irq_hdl, rc;
 
 	printk("comedi%d: amplc_pci230: attach %s %d,%d\n", dev->minor,
@@ -780,9 +780,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	spin_lock_init(&devpriv->ai_stop_spinlock);
 	spin_lock_init(&devpriv->ao_stop_spinlock);
 	/* Find card */
-	for (pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-	     pci_dev != NULL;
-	     pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) {
+	for_each_pci_dev(pci_dev) {
 		if (it->options[0] || it->options[1]) {
 			/* Match against bus/slot options. */
 			if (it->options[0] != pci_dev->bus->number ||

commit 727b286b44ea359d66f47d241cc2cdad36ed7bdc
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:31 2010 +0200

    Staging: comedi: Remove COMEDI_PCI_INITCLEANUP macro
    
    Move the PCI devinit/devexit routines to the respective C source files
    instead of calling COMEDI_PCI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 53d34147813b..b572df718f21 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -617,7 +617,45 @@ static struct comedi_driver driver_amplc_pci230 = {
 	.num_names = ARRAY_SIZE(pci230_boards),
 };
 
-COMEDI_PCI_INITCLEANUP(driver_amplc_pci230, pci230_pci_table);
+static int __devinit driver_amplc_pci230_pci_probe(struct pci_dev *dev,
+						   const struct pci_device_id
+						   *ent)
+{
+	return comedi_pci_auto_config(dev, driver_amplc_pci230.driver_name);
+}
+
+static void __devexit driver_amplc_pci230_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static struct pci_driver driver_amplc_pci230_pci_driver = {
+	.id_table = pci230_pci_table,
+	.probe = &driver_amplc_pci230_pci_probe,
+	.remove = __devexit_p(&driver_amplc_pci230_pci_remove)
+};
+
+static int __init driver_amplc_pci230_init_module(void)
+{
+	int retval;
+
+	retval = comedi_driver_register(&driver_amplc_pci230);
+	if (retval < 0)
+		return retval;
+
+	driver_amplc_pci230_pci_driver.name =
+	    (char *)driver_amplc_pci230.driver_name;
+	return pci_register_driver(&driver_amplc_pci230_pci_driver);
+}
+
+static void __exit driver_amplc_pci230_cleanup_module(void)
+{
+	pci_unregister_driver(&driver_amplc_pci230_pci_driver);
+	comedi_driver_unregister(&driver_amplc_pci230);
+}
+
+module_init(driver_amplc_pci230_init_module);
+module_exit(driver_amplc_pci230_cleanup_module);
 
 static int pci230_ai_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 7fffd967d47e..53d34147813b 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -3014,3 +3014,7 @@ static int pci230_ai_cancel(struct comedi_device *dev,
 	pci230_ai_stop(dev, s);
 	return 0;
 }
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 25f1a98bfd0b2a097c8477e4b7bdf6dccf3886b6
Author: Jason Wong <tsanghan@gmail.com>
Date:   Sat Mar 13 00:32:33 2010 +0800

    Staging: comedi: amplc_pci230: fix brace coding style issue
    
    Fixed multiple brace coding style issue.
    
    Signed-off-by: Jason Wong <tsanghan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 091a1a5822a8..7fffd967d47e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -669,9 +669,9 @@ static short pci230_ai_read(struct comedi_device *dev)
 
 	/* If a bipolar range was specified, mangle it (twos
 	 * complement->straight binary). */
-	if (devpriv->ai_bipolar) {
+	if (devpriv->ai_bipolar)
 		data ^= 1 << (thisboard->ai_bits - 1);
-	}
+
 	return data;
 }
 
@@ -680,9 +680,9 @@ static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
 {
 	/* If a bipolar range was specified, mangle it (straight binary->twos
 	 * complement). */
-	if (devpriv->ao_bipolar) {
+	if (devpriv->ao_bipolar)
 		datum ^= 1 << (thisboard->ao_bits - 1);
-	}
+
 
 	/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
 	 * four bits reserved for expansion). */
@@ -734,9 +734,9 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* Allocate the private structure area using alloc_private().
 	 * Macro defined in comedidev.h - memsets struct fields to 0. */
-	if ((alloc_private(dev, sizeof(struct pci230_private))) < 0) {
+	if ((alloc_private(dev, sizeof(struct pci230_private))) < 0)
 		return -ENOMEM;
-	}
+
 	spin_lock_init(&devpriv->isr_spinlock);
 	spin_lock_init(&devpriv->res_spinlock);
 	spin_lock_init(&devpriv->ai_stop_spinlock);
@@ -991,9 +991,9 @@ static int pci230_detach(struct comedi_device *dev)
 
 	if (devpriv) {
 		if (devpriv->pci_dev) {
-			if (dev->iobase) {
+			if (dev->iobase)
 				comedi_pci_disable(devpriv->pci_dev);
-			}
+
 			pci_dev_put(devpriv->pci_dev);
 		}
 	}
@@ -1055,9 +1055,9 @@ static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 	     && (res_mask != 0); b <<= 1, i++) {
 		if ((res_mask & b) != 0) {
 			res_mask &= ~b;
-			if (devpriv->res_owner[i] == owner) {
+			if (devpriv->res_owner[i] == owner)
 				devpriv->res_owner[i] = OWNER_NONE;
-			}
+
 		}
 	}
 	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
@@ -1132,11 +1132,11 @@ static int pci230_ai_rinsn(struct comedi_device *dev,
 	}
 	devpriv->adcg = (devpriv->adcg & ~(3 << gainshift))
 	    | (pci230_ai_gain[range] << gainshift);
-	if (devpriv->ai_bipolar) {
+	if (devpriv->ai_bipolar)
 		adccon |= PCI230_ADC_IR_BIP;
-	} else {
+	else
 		adccon |= PCI230_ADC_IR_UNI;
-	}
+
 
 	/* Enable only this channel in the scan list - otherwise by default
 	 * we'll get one sample from each channel. */
@@ -1408,13 +1408,13 @@ static int pci230_ao_cmdtest(struct comedi_device *dev,
 			chan = CR_CHAN(cmd->chanlist[n]);
 			range = CR_RANGE(cmd->chanlist[n]);
 			/* Channel numbers must strictly increase. */
-			if (chan < prev_chan) {
+			if (chan < prev_chan)
 				errors |= seq_err;
-			}
+
 			/* Ranges must be the same. */
-			if (range != first_range) {
+			if (range != first_range)
 				errors |= range_err;
-			}
+
 			prev_chan = chan;
 		}
 		if (errors != 0) {
@@ -1583,9 +1583,9 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		/* Claim Z2-CT1. */
-		if (!get_one_resource(dev, RES_Z2CT1, OWNER_AOCMD)) {
+		if (!get_one_resource(dev, RES_Z2CT1, OWNER_AOCMD))
 			return -EBUSY;
-		}
+
 	}
 
 	/* Get number of scans required. */
@@ -1609,9 +1609,9 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		unsigned int i;
 
 		dacen = 0;
-		for (i = 0; i < cmd->chanlist_len; i++) {
+		for (i = 0; i < cmd->chanlist_len; i++)
 			dacen |= 1 << CR_CHAN(cmd->chanlist[i]);
-		}
+
 		/* Set channel scan list. */
 		outw(dacen, dev->iobase + PCI230P2_DACEN);
 		/*
@@ -1656,9 +1656,9 @@ static int pci230_ai_check_scan_period(struct comedi_cmd *cmd)
 	int err = 0;
 
 	chanlist_len = cmd->chanlist_len;
-	if (cmd->chanlist_len == 0) {
+	if (cmd->chanlist_len == 0)
 		chanlist_len = 1;
-	}
+
 	min_scan_period = chanlist_len * cmd->convert_arg;
 	if ((min_scan_period < chanlist_len)
 	    || (min_scan_period < cmd->convert_arg)) {
@@ -1777,11 +1777,11 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 			 * single-ended or pseudo-differential. */
 			if (cmd->chanlist && (cmd->chanlist_len > 0)) {
 				/* Peek analogue reference of first channel. */
-				if (CR_AREF(cmd->chanlist[0]) == AREF_DIFF) {
+				if (CR_AREF(cmd->chanlist[0]) == AREF_DIFF)
 					max_speed_ai = MAX_SPEED_AI_DIFF;
-				} else {
+				else
 					max_speed_ai = MAX_SPEED_AI_SE;
-				}
+
 			} else {
 				/* No channel list.  Assume single-ended. */
 				max_speed_ai = MAX_SPEED_AI_SE;
@@ -1871,9 +1871,9 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 		}
 	} else if (cmd->scan_begin_src == TRIG_TIMER) {
 		/* N.B. cmd->convert_arg is also TRIG_TIMER */
-		if (!pci230_ai_check_scan_period(cmd)) {
+		if (!pci230_ai_check_scan_period(cmd))
 			err++;
-		}
+
 	} else {
 		if (cmd->scan_begin_arg != 0) {
 			cmd->scan_begin_arg = 0;
@@ -1961,13 +1961,13 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 					errors |= seq_err;
 				}
 				/* Channels must have same AREF. */
-				if (aref != prev_aref) {
+				if (aref != prev_aref)
 					errors |= aref_err;
-				}
+
 				/* Channel ranges must have same polarity. */
-				if (polarity != prev_polarity) {
+				if (polarity != prev_polarity)
 					errors |= polarity_err;
-				}
+
 				/* Single-ended channel pairs must have same
 				 * range.  */
 				if ((aref != AREF_DIFF)
@@ -1987,9 +1987,9 @@ static int pci230_ai_cmdtest(struct comedi_device *dev,
 		}
 		/* If channel list is a repeating subsequence, need a whole
 		 * number of repeats. */
-		if ((n % subseq_len) != 0) {
+		if ((n % subseq_len) != 0)
 			errors |= seq_err;
-		}
+
 		if ((devpriv->hwver > 0) && (devpriv->hwver < 4)) {
 			/*
 			 * Buggy PCI230+ or PCI260+ requires channel 0 to be
@@ -2228,9 +2228,9 @@ static void pci230_ai_start(struct comedi_device *dev,
 		devpriv->adccon = (devpriv->adccon & ~PCI230_ADC_TRIG_MASK)
 		    | conv;
 		outw(devpriv->adccon, dev->iobase + PCI230_ADCCON);
-		if (cmd->convert_src == TRIG_INT) {
+		if (cmd->convert_src == TRIG_INT)
 			async->inttrig = pci230_ai_inttrig_convert;
-		}
+
 		/* Update FIFO interrupt trigger level, which is currently
 		 * set to "full".  */
 		pci230_ai_update_fifo_trigger_level(dev, s);
@@ -2345,9 +2345,9 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		}
 	}
 	/* Claim resources. */
-	if (!get_resources(dev, res_mask, OWNER_AICMD)) {
+	if (!get_resources(dev, res_mask, OWNER_AICMD))
 		return -EBUSY;
-	}
+
 
 	/* Get number of scans required. */
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -2392,11 +2392,11 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	range = CR_RANGE(cmd->chanlist[0]);
 	devpriv->ai_bipolar = pci230_ai_bipolar[range];
-	if (devpriv->ai_bipolar) {
+	if (devpriv->ai_bipolar)
 		adccon |= PCI230_ADC_IR_BIP;
-	} else {
+	else
 		adccon |= PCI230_ADC_IR_UNI;
-	}
+
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		unsigned int gainshift;
 
@@ -2543,9 +2543,9 @@ static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
 
 	for (clk_src = CLK_10MHZ;; clk_src++) {
 		cnt = divide_ns(ns, pci230_timebase[clk_src], round_mode);
-		if ((cnt <= 65536) || (clk_src == CLK_1KHZ)) {
+		if ((cnt <= 65536) || (clk_src == CLK_1KHZ))
 			break;
-		}
+
 	}
 	*count = cnt;
 	return clk_src;
@@ -2575,9 +2575,9 @@ static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 	/* Program clock source. */
 	outb(CLK_CONFIG(ct, clk_src), devpriv->iobase1 + PCI230_ZCLK_SCE);
 	/* Set initial count. */
-	if (count >= 65536) {
+	if (count >= 65536)
 		count = 0;
-	}
+
 	i8254_write(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, count);
 }
 
@@ -2599,9 +2599,9 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	/* Read interrupt status/enable register. */
 	status_int = inb(devpriv->iobase1 + PCI230_INT_STAT);
 
-	if (status_int == PCI230_INT_DISABLE) {
+	if (status_int == PCI230_INT_DISABLE)
 		return IRQ_NONE;
-	}
+
 
 	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	valid_status_int = devpriv->int_en & status_int;
@@ -2660,9 +2660,9 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev,
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 
-	if (!devpriv->ao_continuous && (devpriv->ao_scan_count == 0)) {
+	if (!devpriv->ao_continuous && (devpriv->ao_scan_count == 0))
 		return;
-	}
+
 
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		/* Read sample from Comedi's circular buffer. */
@@ -2711,9 +2711,9 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 	num_scans = comedi_buf_read_n_available(async) / bytes_per_scan;
 	if (!devpriv->ao_continuous) {
 		/* Fixed number of scans. */
-		if (num_scans > devpriv->ao_scan_count) {
+		if (num_scans > devpriv->ao_scan_count)
 			num_scans = devpriv->ao_scan_count;
-		}
+
 		if (devpriv->ao_scan_count == 0) {
 			/* End of acquisition. */
 			events |= COMEDI_CB_EOA;
@@ -2736,21 +2736,21 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev,
 	}
 	if (events == 0) {
 		/* Determine how much room is in the FIFO (in samples). */
-		if ((dacstat & PCI230P2_DAC_FIFO_FULL) != 0) {
+		if ((dacstat & PCI230P2_DAC_FIFO_FULL) != 0)
 			room = PCI230P2_DAC_FIFOROOM_FULL;
-		} else if ((dacstat & PCI230P2_DAC_FIFO_HALF) != 0) {
+		else if ((dacstat & PCI230P2_DAC_FIFO_HALF) != 0)
 			room = PCI230P2_DAC_FIFOROOM_HALFTOFULL;
-		} else if ((dacstat & PCI230P2_DAC_FIFO_EMPTY) != 0) {
+		else if ((dacstat & PCI230P2_DAC_FIFO_EMPTY) != 0)
 			room = PCI230P2_DAC_FIFOROOM_EMPTY;
-		} else {
+		else
 			room = PCI230P2_DAC_FIFOROOM_ONETOHALF;
-		}
+
 		/* Convert room to number of scans that can be added. */
 		room /= cmd->chanlist_len;
 		/* Determine number of scans to process. */
-		if (num_scans > room) {
+		if (num_scans > room)
 			num_scans = room;
-		}
+
 		/* Process scans. */
 		for (n = 0; n < num_scans; n++) {
 			for (i = 0; i < cmd->chanlist_len; i++) {
@@ -2817,14 +2817,14 @@ static void pci230_handle_ai(struct comedi_device *dev,
 	} else {
 		todo = (devpriv->ai_scan_count * scanlen)
 		    - devpriv->ai_scan_pos;
-		if (todo > PCI230_ADC_FIFOLEVEL_HALFFULL) {
+		if (todo > PCI230_ADC_FIFOLEVEL_HALFFULL)
 			todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
-		}
+
 	}
 
-	if (todo == 0) {
+	if (todo == 0)
 		return;
-	}
+
 
 	fifoamount = 0;
 	for (i = 0; i < todo; i++) {
@@ -2906,9 +2906,9 @@ static void pci230_ao_stop(struct comedi_device *dev,
 	spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
 	started = test_and_clear_bit(AO_CMD_STARTED, &devpriv->state);
 	spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
-	if (!started) {
+	if (!started)
 		return;
-	}
+
 
 	cmd = &s->async->cmd;
 	if (cmd->scan_begin_src == TRIG_TIMER) {
@@ -2968,9 +2968,9 @@ static void pci230_ai_stop(struct comedi_device *dev,
 	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
 	started = test_and_clear_bit(AI_CMD_STARTED, &devpriv->state);
 	spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
-	if (!started) {
+	if (!started)
 		return;
-	}
+
 
 	cmd = &s->async->cmd;
 	if (cmd->convert_src == TRIG_TIMER) {

commit b6ac161364eccce1bea4a23a9de395883e90d7ab
Author: Stoyan Gaydarov <sgayda2@uiuc.edu>
Date:   Tue Jul 21 22:02:27 2009 -0500

    Staging: ARRAY_SIZE changes
    
    These changes were a direct result of using a semantic patch
    More information can be found at http://www.emn.fr/x-info/coccinelle/
    
    Signed-off-by: Stoyan Gaydarov <sgayda2@uiuc.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index c4d8c4cae4a5..091a1a5822a8 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -513,7 +513,7 @@ MODULE_DEVICE_TABLE(pci, pci230_pci_table);
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define n_pci230_boards (sizeof(pci230_boards)/sizeof(pci230_boards[0]))
+#define n_pci230_boards ARRAY_SIZE(pci230_boards)
 #define thisboard ((const struct pci230_board *)dev->board_ptr)
 
 /* this structure is for data unique to this hardware driver.  If

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 21133f068bf3..c4d8c4cae4a5 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -457,55 +457,56 @@ struct pci230_board {
 };
 static const struct pci230_board pci230_boards[] = {
 	{
-	.name = "pci230+",
-	.id = PCI_DEVICE_ID_PCI230,
-	.ai_chans = 16,
-	.ai_bits = 16,
-	.ao_chans = 2,
-	.ao_bits = 12,
-	.have_dio = 1,
-	.min_hwver = 1,
-		},
+	 .name = "pci230+",
+	 .id = PCI_DEVICE_ID_PCI230,
+	 .ai_chans = 16,
+	 .ai_bits = 16,
+	 .ao_chans = 2,
+	 .ao_bits = 12,
+	 .have_dio = 1,
+	 .min_hwver = 1,
+	 },
 	{
-	.name = "pci260+",
-	.id = PCI_DEVICE_ID_PCI260,
-	.ai_chans = 16,
-	.ai_bits = 16,
-	.ao_chans = 0,
-	.ao_bits = 0,
-	.have_dio = 0,
-	.min_hwver = 1,
-		},
+	 .name = "pci260+",
+	 .id = PCI_DEVICE_ID_PCI260,
+	 .ai_chans = 16,
+	 .ai_bits = 16,
+	 .ao_chans = 0,
+	 .ao_bits = 0,
+	 .have_dio = 0,
+	 .min_hwver = 1,
+	 },
 	{
-	.name = "pci230",
-	.id = PCI_DEVICE_ID_PCI230,
-	.ai_chans = 16,
-	.ai_bits = 12,
-	.ao_chans = 2,
-	.ao_bits = 12,
-	.have_dio = 1,
-		},
+	 .name = "pci230",
+	 .id = PCI_DEVICE_ID_PCI230,
+	 .ai_chans = 16,
+	 .ai_bits = 12,
+	 .ao_chans = 2,
+	 .ao_bits = 12,
+	 .have_dio = 1,
+	 },
 	{
-	.name = "pci260",
-	.id = PCI_DEVICE_ID_PCI260,
-	.ai_chans = 16,
-	.ai_bits = 12,
-	.ao_chans = 0,
-	.ao_bits = 0,
-	.have_dio = 0,
-		},
+	 .name = "pci260",
+	 .id = PCI_DEVICE_ID_PCI260,
+	 .ai_chans = 16,
+	 .ai_bits = 12,
+	 .ao_chans = 0,
+	 .ao_bits = 0,
+	 .have_dio = 0,
+	 },
 	{
-	.name = "amplc_pci230",	/* Wildcard matches any above */
-	.id = PCI_DEVICE_ID_INVALID,
-		},
+	 .name = "amplc_pci230",	/* Wildcard matches any above */
+	 .id = PCI_DEVICE_ID_INVALID,
+	 },
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pci230_pci_table) = {
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI230, PCI_ANY_ID, PCI_ANY_ID,
-		0, 0, 0},
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI260, PCI_ANY_ID, PCI_ANY_ID,
-		0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI230, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI260, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci230_pci_table);
@@ -571,14 +572,14 @@ static const unsigned int pci230_timebase[8] = {
 
 /* PCI230 analogue input range table */
 static const struct comedi_lrange pci230_ai_range = { 7, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5)
-	}
+							  BIP_RANGE(10),
+							  BIP_RANGE(5),
+							  BIP_RANGE(2.5),
+							  BIP_RANGE(1.25),
+							  UNI_RANGE(10),
+							  UNI_RANGE(5),
+							  UNI_RANGE(2.5)
+							  }
 };
 
 /* PCI230 analogue gain bits for each input range. */
@@ -589,9 +590,9 @@ static const unsigned char pci230_ai_bipolar[7] = { 1, 1, 1, 1, 0, 0, 0 };
 
 /* PCI230 analogue output range table */
 static const struct comedi_lrange pci230_ao_range = { 2, {
-			UNI_RANGE(10),
-			BIP_RANGE(10)
-	}
+							  UNI_RANGE(10),
+							  BIP_RANGE(10)
+							  }
 };
 
 /* PCI230 daccon bipolar flag for each analogue output range. */
@@ -603,7 +604,8 @@ static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci230_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pci230_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_pci230 = {
 	.driver_name = "amplc_pci230",
@@ -617,35 +619,48 @@ static struct comedi_driver driver_amplc_pci230 = {
 
 COMEDI_PCI_INITCLEANUP(driver_amplc_pci230, pci230_pci_table);
 
-static int pci230_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pci230_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pci230_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int pci230_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int pci230_ao_winsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int pci230_ao_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
 static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
-	unsigned int mode, uint64_t ns, unsigned int round);
+				    unsigned int mode, uint64_t ns,
+				    unsigned int round);
 static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round);
 static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct);
 static irqreturn_t pci230_interrupt(int irq, void *d);
-static int pci230_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int pci230_ao_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd);
 static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pci230_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static void pci230_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s);
-static void pci230_handle_ao_nofifo(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pci230_handle_ao_fifo(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int pci230_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static void pci230_ao_stop(struct comedi_device *dev,
+			   struct comedi_subdevice *s);
+static void pci230_handle_ao_nofifo(struct comedi_device *dev,
+				    struct comedi_subdevice *s);
+static int pci230_handle_ao_fifo(struct comedi_device *dev,
+				 struct comedi_subdevice *s);
+static int pci230_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd);
 static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pci230_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static void pci230_ai_stop(struct comedi_device *dev, struct comedi_subdevice *s);
-static void pci230_handle_ai(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pci230_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static void pci230_ai_stop(struct comedi_device *dev,
+			   struct comedi_subdevice *s);
+static void pci230_handle_ai(struct comedi_device *dev,
+			     struct comedi_subdevice *s);
 
 static short pci230_ai_read(struct comedi_device *dev)
 {
 	/* Read sample. */
-	short data = (short) inw(dev->iobase + PCI230_ADCDATA);
+	short data = (short)inw(dev->iobase + PCI230_ADCDATA);
 
 	/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
 	 * four bits reserved for expansion). */
@@ -661,7 +676,7 @@ static short pci230_ai_read(struct comedi_device *dev)
 }
 
 static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
-	short datum)
+						    short datum)
 {
 	/* If a bipolar range was specified, mangle it (straight binary->twos
 	 * complement). */
@@ -676,26 +691,28 @@ static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
 	return (unsigned short)datum;
 }
 
-static inline void pci230_ao_write_nofifo(struct comedi_device *dev, short datum,
-	unsigned int chan)
+static inline void pci230_ao_write_nofifo(struct comedi_device *dev,
+					  short datum, unsigned int chan)
 {
 	/* Store unmangled datum to be read back later. */
 	devpriv->ao_readback[chan] = datum;
 
 	/* Write mangled datum to appropriate DACOUT register. */
 	outw(pci230_ao_mangle_datum(dev, datum), dev->iobase + (((chan) == 0)
-			? PCI230_DACOUT1 : PCI230_DACOUT2));
+								? PCI230_DACOUT1
+								:
+								PCI230_DACOUT2));
 }
 
 static inline void pci230_ao_write_fifo(struct comedi_device *dev, short datum,
-	unsigned int chan)
+					unsigned int chan)
 {
 	/* Store unmangled datum to be read back later. */
 	devpriv->ao_readback[chan] = datum;
 
 	/* Write mangled datum to appropriate DACDATA register. */
 	outw(pci230_ao_mangle_datum(dev, datum),
-		dev->iobase + PCI230P2_DACDATA);
+	     dev->iobase + PCI230P2_DACDATA);
 }
 
 /*
@@ -713,7 +730,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int i = 0, irq_hdl, rc;
 
 	printk("comedi%d: amplc_pci230: attach %s %d,%d\n", dev->minor,
-		thisboard->name, it->options[0], it->options[1]);
+	       thisboard->name, it->options[0], it->options[1]);
 
 	/* Allocate the private structure area using alloc_private().
 	 * Macro defined in comedidev.h - memsets struct fields to 0. */
@@ -726,12 +743,12 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	spin_lock_init(&devpriv->ao_stop_spinlock);
 	/* Find card */
 	for (pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pci_dev != NULL;
-		pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) {
+	     pci_dev != NULL;
+	     pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) {
 		if (it->options[0] || it->options[1]) {
 			/* Match against bus/slot options. */
 			if (it->options[0] != pci_dev->bus->number ||
-				it->options[1] != PCI_SLOT(pci_dev->devfn))
+			    it->options[1] != PCI_SLOT(pci_dev->devfn))
 				continue;
 		}
 		if (pci_dev->vendor != PCI_VENDOR_ID_AMPLICON)
@@ -748,7 +765,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 						 * First check length of
 						 * registers. */
 						if (pci_resource_len(pci_dev, 3)
-							< 32) {
+						    < 32) {
 							/* Not a '+' model. */
 							continue;
 						}
@@ -790,7 +807,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	if (!pci_dev) {
 		printk("comedi%d: No %s card found\n", dev->minor,
-			thisboard->name);
+		       thisboard->name);
 		return -EIO;
 	}
 	devpriv->pci_dev = pci_dev;
@@ -803,7 +820,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* Enable PCI device and reserve I/O spaces. */
 	if (comedi_pci_enable(pci_dev, "amplc_pci230") < 0) {
 		printk("comedi%d: failed to enable PCI device "
-			"and request regions\n", dev->minor);
+		       "and request regions\n", dev->minor);
 		return -EIO;
 	}
 
@@ -813,7 +830,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	iobase2 = pci_resource_start(pci_dev, 3);
 
 	printk("comedi%d: %s I/O region 1 0x%04lx I/O region 2 0x%04lx\n",
-		dev->minor, dev->board_name, iobase1, iobase2);
+	       dev->minor, dev->board_name, iobase1, iobase2);
 
 	devpriv->iobase1 = iobase1;
 	dev->iobase = iobase2;
@@ -829,9 +846,9 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->hwver = inw(dev->iobase + PCI230P_HWVER);
 		if (devpriv->hwver < thisboard->min_hwver) {
 			printk("comedi%d: %s - bad hardware version "
-				"- got %u, need %u\n", dev->minor,
-				dev->board_name, devpriv->hwver,
-				thisboard->min_hwver);
+			       "- got %u, need %u\n", dev->minor,
+			       dev->board_name, devpriv->hwver,
+			       thisboard->min_hwver);
 			return -EIO;
 		}
 		if (devpriv->hwver > 0) {
@@ -844,7 +861,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				extfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;
 			}
 			if ((thisboard->ao_chans > 0)
-				&& (devpriv->hwver >= 2)) {
+			    && (devpriv->hwver >= 2)) {
 				/* Enable DAC FIFO functionality. */
 				extfunc |= PCI230P2_EXTFUNC_DACFIFO;
 			}
@@ -854,8 +871,8 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			/* Temporarily enable DAC FIFO, reset it and disable
 			 * FIFO wraparound. */
 			outw(devpriv->daccon | PCI230P2_DAC_FIFO_EN
-				| PCI230P2_DAC_FIFO_RESET,
-				dev->iobase + PCI230_DACCON);
+			     | PCI230P2_DAC_FIFO_RESET,
+			     dev->iobase + PCI230_DACCON);
 			/* Clear DAC FIFO channel enable register. */
 			outw(0, dev->iobase + PCI230P2_DACEN);
 			/* Disable DAC FIFO. */
@@ -869,23 +886,23 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* Set ADC to a reasonable state. */
 	devpriv->adcg = 0;
 	devpriv->adccon = PCI230_ADC_TRIG_NONE | PCI230_ADC_IM_SE
-		| PCI230_ADC_IR_BIP;
+	    | PCI230_ADC_IR_BIP;
 	outw(1 << 0, dev->iobase + PCI230_ADCEN);
 	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
-		dev->iobase + PCI230_ADCCON);
+	     dev->iobase + PCI230_ADCCON);
 
 	/* Register the interrupt handler. */
 	irq_hdl = request_irq(devpriv->pci_dev->irq, pci230_interrupt,
 			      IRQF_SHARED, "amplc_pci230", dev);
 	if (irq_hdl < 0) {
 		printk("comedi%d: unable to register irq, "
-			"commands will not be available %d\n", dev->minor,
-			devpriv->pci_dev->irq);
+		       "commands will not be available %d\n", dev->minor,
+		       devpriv->pci_dev->irq);
 	} else {
 		dev->irq = devpriv->pci_dev->irq;
 		printk("comedi%d: registered irq %u\n", dev->minor,
-			devpriv->pci_dev->irq);
+		       devpriv->pci_dev->irq);
 	}
 
 	/*
@@ -941,7 +958,7 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* digital i/o subdevice */
 	if (thisboard->have_dio) {
 		rc = subdev_8255_init(dev, s, NULL,
-			(devpriv->iobase1 + PCI230_PPI_X_BASE));
+				      (devpriv->iobase1 + PCI230_PPI_X_BASE));
 		if (rc < 0)
 			return rc;
 	} else {
@@ -985,7 +1002,7 @@ static int pci230_detach(struct comedi_device *dev)
 }
 
 static int get_resources(struct comedi_device *dev, unsigned int res_mask,
-	unsigned char owner)
+			 unsigned char owner)
 {
 	int ok;
 	unsigned int i;
@@ -997,7 +1014,7 @@ static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 	claimed = 0;
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
 	for (b = 1, i = 0; (i < NUM_RESOURCES)
-		&& (res_mask != 0); b <<= 1, i++) {
+	     && (res_mask != 0); b <<= 1, i++) {
 		if ((res_mask & b) != 0) {
 			res_mask &= ~b;
 			if (devpriv->res_owner[i] == OWNER_NONE) {
@@ -1007,7 +1024,7 @@ static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 				for (b = 1, i = 0; claimed != 0; b <<= 1, i++) {
 					if ((claimed & b) != 0) {
 						devpriv->res_owner[i]
-							= OWNER_NONE;
+						    = OWNER_NONE;
 						claimed &= ~b;
 					}
 				}
@@ -1020,14 +1037,14 @@ static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 	return ok;
 }
 
-static inline int get_one_resource(struct comedi_device *dev, unsigned int resource,
-	unsigned char owner)
+static inline int get_one_resource(struct comedi_device *dev,
+				   unsigned int resource, unsigned char owner)
 {
 	return get_resources(dev, (1U << resource), owner);
 }
 
 static void put_resources(struct comedi_device *dev, unsigned int res_mask,
-	unsigned char owner)
+			  unsigned char owner)
 {
 	unsigned int i;
 	unsigned int b;
@@ -1035,7 +1052,7 @@ static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
 	for (b = 1, i = 0; (i < NUM_RESOURCES)
-		&& (res_mask != 0); b <<= 1, i++) {
+	     && (res_mask != 0); b <<= 1, i++) {
 		if ((res_mask & b) != 0) {
 			res_mask &= ~b;
 			if (devpriv->res_owner[i] == owner) {
@@ -1046,13 +1063,14 @@ static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
 }
 
-static inline void put_one_resource(struct comedi_device *dev, unsigned int resource,
-	unsigned char owner)
+static inline void put_one_resource(struct comedi_device *dev,
+				    unsigned int resource, unsigned char owner)
 {
 	put_resources(dev, (1U << resource), owner);
 }
 
-static inline void put_all_resources(struct comedi_device *dev, unsigned char owner)
+static inline void put_all_resources(struct comedi_device *dev,
+				     unsigned char owner)
 {
 	put_resources(dev, (1U << NUM_RESOURCES) - 1, owner);
 }
@@ -1060,8 +1078,9 @@ static inline void put_all_resources(struct comedi_device *dev, unsigned char ow
 /*
  *  COMEDI_SUBD_AI instruction;
  */
-static int pci230_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci230_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	unsigned int n, i;
 	unsigned int chan, range, aref;
@@ -1112,7 +1131,7 @@ static int pci230_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s
 		adccon |= PCI230_ADC_IM_SE;
 	}
 	devpriv->adcg = (devpriv->adcg & ~(3 << gainshift))
-		| (pci230_ai_gain[range] << gainshift);
+	    | (pci230_ai_gain[range] << gainshift);
 	if (devpriv->ai_bipolar) {
 		adccon |= PCI230_ADC_IR_BIP;
 	} else {
@@ -1135,9 +1154,9 @@ static int pci230_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s
 		/* Trigger conversion by toggling Z2-CT2 output (finish with
 		 * output high). */
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
-			I8254_MODE0);
+			       I8254_MODE0);
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
-			I8254_MODE1);
+			       I8254_MODE1);
 
 #define TIMEOUT 100
 		/* wait for conversion to end */
@@ -1165,8 +1184,9 @@ static int pci230_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s
 /*
  *  COMEDI_SUBD_AO instructions;
  */
-static int pci230_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci230_ao_winsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int i;
 	int chan, range;
@@ -1193,8 +1213,9 @@ static int pci230_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int pci230_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci230_ao_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1205,8 +1226,8 @@ static int pci230_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s
 	return i;
 }
 
-static int pci230_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int pci230_ao_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1317,17 +1338,16 @@ static int pci230_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 		/* Trigger number must be 0. */
 		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-				~CR_FLAGS_MASK);
+						      ~CR_FLAGS_MASK);
 			err++;
 		}
 		/* The only flags allowed are CR_EDGE and CR_INVERT.  The
 		 * CR_EDGE flag is ignored. */
 		if ((cmd->scan_begin_arg
-				& (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) !=
-			0) {
+		     & (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {
 			cmd->scan_begin_arg =
-				COMBINE(cmd->scan_begin_arg, 0,
-				CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
+			    COMBINE(cmd->scan_begin_arg, 0,
+				    CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
 			err++;
 		}
 		break;
@@ -1361,7 +1381,7 @@ static int pci230_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		pci230_ns_to_single_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -1419,7 +1439,8 @@ static int pci230_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 }
 
 static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int trig_num)
+					struct comedi_subdevice *s,
+					unsigned int trig_num)
 {
 	unsigned long irqflags;
 
@@ -1431,16 +1452,16 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 		/* Perform scan. */
 		if (devpriv->hwver < 2) {
 			/* Not using DAC FIFO. */
-			spin_unlock_irqrestore(&devpriv->
-				ao_stop_spinlock, irqflags);
+			spin_unlock_irqrestore(&devpriv->ao_stop_spinlock,
+					       irqflags);
 			pci230_handle_ao_nofifo(dev, s);
 			comedi_event(dev, s);
 		} else {
 			/* Using DAC FIFO. */
 			/* Read DACSWTRIG register to trigger conversion. */
 			inw(dev->iobase + PCI230P2_DACSWTRIG);
-			spin_unlock_irqrestore(&devpriv->
-				ao_stop_spinlock, irqflags);
+			spin_unlock_irqrestore(&devpriv->ao_stop_spinlock,
+					       irqflags);
 		}
 		/* Delay.  Should driver be responsible for this? */
 		/* XXX TODO: See if DAC busy bit can be used. */
@@ -1450,7 +1471,8 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 	return 1;
 }
 
-static void pci230_ao_start(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci230_ao_start(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1499,7 +1521,8 @@ static void pci230_ao_start(struct comedi_device *dev, struct comedi_subdevice *
 				break;
 			}
 			devpriv->daccon = (devpriv->daccon
-				& ~PCI230P2_DAC_TRIG_MASK) | scantrig;
+					   & ~PCI230P2_DAC_TRIG_MASK) |
+			    scantrig;
 			outw(devpriv->daccon, dev->iobase + PCI230_DACCON);
 
 		}
@@ -1509,17 +1532,17 @@ static void pci230_ao_start(struct comedi_device *dev, struct comedi_subdevice *
 				/* Not using DAC FIFO. */
 				/* Enable CT1 timer interrupt. */
 				spin_lock_irqsave(&devpriv->isr_spinlock,
-					irqflags);
+						  irqflags);
 				devpriv->int_en |= PCI230_INT_ZCLK_CT1;
 				devpriv->ier |= PCI230_INT_ZCLK_CT1;
 				outb(devpriv->ier,
-					devpriv->iobase1 + PCI230_INT_SCE);
-				spin_unlock_irqrestore(&devpriv->
-					isr_spinlock, irqflags);
+				     devpriv->iobase1 + PCI230_INT_SCE);
+				spin_unlock_irqrestore(&devpriv->isr_spinlock,
+						       irqflags);
 			}
 			/* Set CT1 gate high to start counting. */
 			outb(GAT_CONFIG(1, GAT_VCC),
-				devpriv->iobase1 + PCI230_ZGAT_SCE);
+			     devpriv->iobase1 + PCI230_ZGAT_SCE);
 			break;
 		case TRIG_INT:
 			async->inttrig = pci230_ao_inttrig_scan_begin;
@@ -1527,19 +1550,19 @@ static void pci230_ao_start(struct comedi_device *dev, struct comedi_subdevice *
 		}
 		if (devpriv->hwver >= 2) {
 			/* Using DAC FIFO.  Enable DAC FIFO interrupt. */
-			spin_lock_irqsave(&devpriv->isr_spinlock,
-				irqflags);
+			spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 			devpriv->int_en |= PCI230P2_INT_DAC;
 			devpriv->ier |= PCI230P2_INT_DAC;
 			outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 			spin_unlock_irqrestore(&devpriv->isr_spinlock,
-				irqflags);
+					       irqflags);
 		}
 	}
 }
 
-static int pci230_ao_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trig_num)
+static int pci230_ao_inttrig_start(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned int trig_num)
 {
 	if (trig_num != 0)
 		return -EINVAL;
@@ -1600,24 +1623,25 @@ static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * N.B. DAC FIFO interrupts are currently disabled.
 		 */
 		daccon |= PCI230P2_DAC_FIFO_EN | PCI230P2_DAC_FIFO_RESET
-			| PCI230P2_DAC_FIFO_UNDERRUN_CLEAR
-			| PCI230P2_DAC_TRIG_NONE | PCI230P2_DAC_INT_FIFO_NHALF;
+		    | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR
+		    | PCI230P2_DAC_TRIG_NONE | PCI230P2_DAC_INT_FIFO_NHALF;
 	}
 
 	/* Set DACCON. */
 	outw(daccon, dev->iobase + PCI230_DACCON);
 	/* Preserve most of DACCON apart from write-only, transient bits. */
 	devpriv->daccon = daccon
-		& ~(PCI230P2_DAC_FIFO_RESET | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR);
+	    & ~(PCI230P2_DAC_FIFO_RESET | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		/* Set the counter timer 1 to the specified scan frequency. */
 		/* cmd->scan_begin_arg is sampling period in ns */
 		/* gate it off for now. */
 		outb(GAT_CONFIG(1, GAT_GND),
-			devpriv->iobase1 + PCI230_ZGAT_SCE);
+		     devpriv->iobase1 + PCI230_ZGAT_SCE);
 		pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
-			cmd->scan_begin_arg, cmd->flags & TRIG_ROUND_MASK);
+					cmd->scan_begin_arg,
+					cmd->flags & TRIG_ROUND_MASK);
 	}
 
 	/* N.B. cmd->start_src == TRIG_INT */
@@ -1637,7 +1661,7 @@ static int pci230_ai_check_scan_period(struct comedi_cmd *cmd)
 	}
 	min_scan_period = chanlist_len * cmd->convert_arg;
 	if ((min_scan_period < chanlist_len)
-		|| (min_scan_period < cmd->convert_arg)) {
+	    || (min_scan_period < cmd->convert_arg)) {
 		/* Arithmetic overflow. */
 		min_scan_period = UINT_MAX;
 		err++;
@@ -1650,8 +1674,8 @@ static int pci230_ai_check_scan_period(struct comedi_cmd *cmd)
 	return !err;
 }
 
-static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int pci230_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1679,7 +1703,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	 * EXTTRIG/EXTCONVCLK input on pin 17 instead. */
 	if ((thisboard->have_dio) || (thisboard->min_hwver > 0)) {
 		cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_INT
-			| TRIG_EXT;
+		    | TRIG_EXT;
 	} else {
 		cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_INT;
 	}
@@ -1723,7 +1747,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	/* If scan_begin_src is not TRIG_FOLLOW, then a monostable will be
 	 * set up to generate a fixed number of timed conversion pulses. */
 	if ((cmd->scan_begin_src != TRIG_FOLLOW)
-		&& (cmd->convert_src != TRIG_TIMER))
+	    && (cmd->convert_src != TRIG_TIMER))
 		err++;
 
 	if (err)
@@ -1788,17 +1812,17 @@ static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 			/* Trigger number must be 0. */
 			if ((cmd->convert_arg & ~CR_FLAGS_MASK) != 0) {
 				cmd->convert_arg = COMBINE(cmd->convert_arg, 0,
-					~CR_FLAGS_MASK);
+							   ~CR_FLAGS_MASK);
 				err++;
 			}
 			/* The only flags allowed are CR_INVERT and CR_EDGE.
 			 * CR_EDGE is required. */
 			if ((cmd->convert_arg & (CR_FLAGS_MASK & ~CR_INVERT))
-				!= CR_EDGE) {
+			    != CR_EDGE) {
 				/* Set CR_EDGE, preserve CR_INVERT. */
 				cmd->convert_arg =
-					COMBINE(cmd->start_arg, (CR_EDGE | 0),
-					CR_FLAGS_MASK & ~CR_INVERT);
+				    COMBINE(cmd->start_arg, (CR_EDGE | 0),
+					    CR_FLAGS_MASK & ~CR_INVERT);
 				err++;
 			}
 		} else {
@@ -1836,13 +1860,13 @@ static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 		 * of CT2 (sample convert trigger is CT2) */
 		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-				~CR_FLAGS_MASK);
+						      ~CR_FLAGS_MASK);
 			err++;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
 		if ((cmd->scan_begin_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-				CR_FLAGS_MASK & ~CR_EDGE);
+						      CR_FLAGS_MASK & ~CR_EDGE);
 			err++;
 		}
 	} else if (cmd->scan_begin_src == TRIG_TIMER) {
@@ -1867,7 +1891,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		pci230_ns_to_single_timer(&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -1876,11 +1900,11 @@ static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 		/* N.B. cmd->convert_arg is also TRIG_TIMER */
 		tmp = cmd->scan_begin_arg;
 		pci230_ns_to_single_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (!pci230_ai_check_scan_period(cmd)) {
 			/* Was below minimum required.  Round up. */
 			pci230_ns_to_single_timer(&cmd->scan_begin_arg,
-				TRIG_ROUND_UP);
+						  TRIG_ROUND_UP);
 			pci230_ai_check_scan_period(cmd);
 		}
 		if (tmp != cmd->scan_begin_arg)
@@ -1921,20 +1945,19 @@ static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 			 * differential.  (These are remapped in software.  In
 			 * hardware, only the even channels are available.) */
 			if ((aref == AREF_DIFF)
-				&& (chan >= (s->n_chan / 2))) {
+			    && (chan >= (s->n_chan / 2))) {
 				errors |= diffchan_err;
 			}
 			if (n > 0) {
 				/* Channel numbers must strictly increase or
 				 * subsequence must repeat exactly. */
 				if ((chan <= prev_chan)
-					&& (subseq_len == 0)) {
+				    && (subseq_len == 0)) {
 					subseq_len = n;
 				}
 				if ((subseq_len > 0)
-					&& (cmd->chanlist[n] !=
-						cmd->chanlist[n %
-							subseq_len])) {
+				    && (cmd->chanlist[n] !=
+					cmd->chanlist[n % subseq_len])) {
 					errors |= seq_err;
 				}
 				/* Channels must have same AREF. */
@@ -1948,8 +1971,8 @@ static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 				/* Single-ended channel pairs must have same
 				 * range.  */
 				if ((aref != AREF_DIFF)
-					&& (((chan ^ prev_chan) & ~1) == 0)
-					&& (range != prev_range)) {
+				    && (((chan ^ prev_chan) & ~1) == 0)
+				    && (range != prev_range)) {
 					errors |= rangepair_err;
 				}
 			}
@@ -1983,7 +2006,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 			 * does, and we can't tell them apart!
 			 */
 			if ((subseq_len > 1)
-				&& (CR_CHAN(cmd->chanlist[0]) != 0)) {
+			    && (CR_CHAN(cmd->chanlist[0]) != 0)) {
 				errors |= buggy_chan0_err;
 			}
 		}
@@ -2021,11 +2044,11 @@ static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 			if ((errors & buggy_chan0_err) != 0) {
 				/* Use printk instead of DPRINTK here. */
 				printk("comedi: comedi%d: amplc_pci230: "
-					"ai_cmdtest: Buggy PCI230+/260+ "
-					"h/w version %u requires first channel "
-					"of multi-channel sequence to be 0 "
-					"(corrected in h/w version 4)\n",
-					dev->minor, devpriv->hwver);
+				       "ai_cmdtest: Buggy PCI230+/260+ "
+				       "h/w version %u requires first channel "
+				       "of multi-channel sequence to be 0 "
+				       "(corrected in h/w version 4)\n",
+				       dev->minor, devpriv->hwver);
 			}
 		}
 	}
@@ -2037,7 +2060,7 @@ static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 }
 
 static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
-	struct comedi_subdevice *s)
+						struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int scanlen = cmd->scan_end_arg;
@@ -2050,13 +2073,12 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 		wake = scanlen - devpriv->ai_scan_pos;
 	} else {
 		if (devpriv->ai_continuous
-			|| (devpriv->ai_scan_count
-				>= PCI230_ADC_FIFOLEVEL_HALFFULL)
-			|| (scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL)) {
+		    || (devpriv->ai_scan_count >= PCI230_ADC_FIFOLEVEL_HALFFULL)
+		    || (scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL)) {
 			wake = PCI230_ADC_FIFOLEVEL_HALFFULL;
 		} else {
 			wake = (devpriv->ai_scan_count * scanlen)
-				- devpriv->ai_scan_pos;
+			    - devpriv->ai_scan_pos;
 		}
 	}
 	if (wake >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
@@ -2080,8 +2102,9 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
 	}
 }
 
-static int pci230_ai_inttrig_convert(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trig_num)
+static int pci230_ai_inttrig_convert(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     unsigned int trig_num)
 {
 	unsigned long irqflags;
 
@@ -2095,36 +2118,35 @@ static int pci230_ai_inttrig_convert(struct comedi_device *dev, struct comedi_su
 		/* Trigger conversion by toggling Z2-CT2 output.  Finish
 		 * with output high. */
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
-			I8254_MODE0);
+			       I8254_MODE0);
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
-			I8254_MODE1);
+			       I8254_MODE1);
 		/* Delay.  Should driver be responsible for this?  An
 		 * alternative would be to wait until conversion is complete,
 		 * but we can't tell when it's complete because the ADC busy
 		 * bit has a different meaning when FIFO enabled (and when
 		 * FIFO not enabled, it only works for software triggers). */
 		if (((devpriv->adccon & PCI230_ADC_IM_MASK)
-				== PCI230_ADC_IM_DIF)
-			&& (devpriv->hwver == 0)) {
+		     == PCI230_ADC_IM_DIF)
+		    && (devpriv->hwver == 0)) {
 			/* PCI230/260 in differential mode */
 			delayus = 8;
 		} else {
 			/* single-ended or PCI230+/260+ */
 			delayus = 4;
 		}
-		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
-			irqflags);
+		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
 		udelay(delayus);
 	} else {
-		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
-			irqflags);
+		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
 	}
 
 	return 1;
 }
 
 static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int trig_num)
+					struct comedi_subdevice *s,
+					unsigned int trig_num)
 {
 	unsigned long irqflags;
 	unsigned char zgat;
@@ -2145,7 +2167,8 @@ static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
 	return 1;
 }
 
-static void pci230_ai_start(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci230_ai_start(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	unsigned long irqflags;
 	unsigned short conv;
@@ -2203,7 +2226,7 @@ static void pci230_ai_start(struct comedi_device *dev, struct comedi_subdevice *
 			break;
 		}
 		devpriv->adccon = (devpriv->adccon & ~PCI230_ADC_TRIG_MASK)
-			| conv;
+		    | conv;
 		outw(devpriv->adccon, dev->iobase + PCI230_ADCCON);
 		if (cmd->convert_src == TRIG_INT) {
 			async->inttrig = pci230_ai_inttrig_convert;
@@ -2267,11 +2290,11 @@ static void pci230_ai_start(struct comedi_device *dev, struct comedi_subdevice *
 					 * gated on to start counting. */
 					zgat = GAT_CONFIG(1, GAT_VCC);
 					outb(zgat, devpriv->iobase1
-						+ PCI230_ZGAT_SCE);
+					     + PCI230_ZGAT_SCE);
 					break;
 				case TRIG_INT:
 					async->inttrig =
-						pci230_ai_inttrig_scan_begin;
+					    pci230_ai_inttrig_scan_begin;
 					break;
 				}
 			}
@@ -2282,8 +2305,9 @@ static void pci230_ai_start(struct comedi_device *dev, struct comedi_subdevice *
 	}
 }
 
-static int pci230_ai_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trig_num)
+static int pci230_ai_inttrig_start(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned int trig_num)
 {
 	if (trig_num != 0)
 		return -EINVAL;
@@ -2394,7 +2418,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			adcen |= 1 << chan;
 		}
 		devpriv->adcg = (devpriv->adcg & ~(3 << gainshift))
-			| (pci230_ai_gain[range] << gainshift);
+		    | (pci230_ai_gain[range] << gainshift);
 	}
 
 	/* Set channel scan list. */
@@ -2439,7 +2463,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 		/* Set counter/timer 2 to the specified conversion period. */
 		pci230_ct_setup_ns_mode(dev, 2, I8254_MODE3, cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					cmd->flags & TRIG_ROUND_MASK);
 		if (cmd->scan_begin_src != TRIG_FOLLOW) {
 			/*
 			 * Set up monostable on CT0 output for scan timing.  A
@@ -2456,8 +2480,9 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			zgat = GAT_CONFIG(0, GAT_VCC);
 			outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 			pci230_ct_setup_ns_mode(dev, 0, I8254_MODE1,
-				((uint64_t) cmd->convert_arg
-					* cmd->scan_end_arg), TRIG_ROUND_UP);
+						((uint64_t) cmd->convert_arg
+						 * cmd->scan_end_arg),
+						TRIG_ROUND_UP);
 			if (cmd->scan_begin_src == TRIG_TIMER) {
 				/*
 				 * Monostable on CT0 will be triggered by
@@ -2468,8 +2493,10 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				zgat = GAT_CONFIG(1, GAT_GND);
 				outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 				pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
-					cmd->scan_begin_arg,
-					cmd->flags & TRIG_ROUND_MASK);
+							cmd->scan_begin_arg,
+							cmd->
+							flags &
+							TRIG_ROUND_MASK);
 			}
 		}
 	}
@@ -2485,7 +2512,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static unsigned int divide_ns(uint64_t ns, unsigned int timebase,
-	unsigned int round_mode)
+			      unsigned int round_mode)
 {
 	uint64_t div;
 	unsigned int rem;
@@ -2510,7 +2537,7 @@ static unsigned int divide_ns(uint64_t ns, unsigned int timebase,
 /* Given desired period in ns, returns the required internal clock source
  * and gets the initial count. */
 static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
-	unsigned int round_mode)
+					    unsigned int round_mode)
 {
 	unsigned int clk_src, cnt;
 
@@ -2535,7 +2562,8 @@ static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round)
 }
 
 static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
-	unsigned int mode, uint64_t ns, unsigned int round)
+				    unsigned int mode, uint64_t ns,
+				    unsigned int round)
 {
 	unsigned int clk_src;
 	unsigned int count;
@@ -2556,7 +2584,7 @@ static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)
 {
 	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct,
-		I8254_MODE1);
+		       I8254_MODE1);
 	/* Counter ct, 8254 mode 1, initial count not written. */
 }
 
@@ -2564,7 +2592,7 @@ static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)
 static irqreturn_t pci230_interrupt(int irq, void *d)
 {
 	unsigned char status_int, valid_status_int;
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s;
 	unsigned long irqflags;
 
@@ -2624,7 +2652,8 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void pci230_handle_ao_nofifo(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci230_handle_ao_nofifo(struct comedi_device *dev,
+				    struct comedi_subdevice *s)
 {
 	short data;
 	int i, ret;
@@ -2661,7 +2690,8 @@ static void pci230_handle_ao_nofifo(struct comedi_device *dev, struct comedi_sub
 
 /* Loads DAC FIFO (if using it) from buffer. */
 /* Returns 0 if AO finished due to completion or error, 1 if still going. */
-static int pci230_handle_ao_fifo(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci230_handle_ao_fifo(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -2699,7 +2729,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev, struct comedi_subdev
 		 * (otherwise there will be loads of "DAC FIFO not half full"
 		 * interrupts). */
 		if ((num_scans == 0)
-			&& ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {
+		    && ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {
 			comedi_error(dev, "AO buffer underrun");
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
@@ -2728,7 +2758,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev, struct comedi_subdev
 
 				comedi_buf_get(async, &datum);
 				pci230_ao_write_fifo(dev, datum,
-					CR_CHAN(cmd->chanlist[i]));
+						     CR_CHAN(cmd->chanlist[i]));
 			}
 		}
 		events |= COMEDI_CB_EOS | COMEDI_CB_BLOCK;
@@ -2739,10 +2769,11 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev, struct comedi_subdev
 				 * to FIFO.  Set FIFO interrupt trigger level
 				 * to 'empty'. */
 				devpriv->daccon = (devpriv->daccon
-					& ~PCI230P2_DAC_INT_FIFO_MASK)
-					| PCI230P2_DAC_INT_FIFO_EMPTY;
+						   &
+						   ~PCI230P2_DAC_INT_FIFO_MASK)
+				    | PCI230P2_DAC_INT_FIFO_EMPTY;
 				outw(devpriv->daccon,
-					dev->iobase + PCI230_DACCON);
+				     dev->iobase + PCI230_DACCON);
 			}
 		}
 		/* Check if FIFO underrun occurred while writing to FIFO. */
@@ -2753,7 +2784,7 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev, struct comedi_subdev
 		}
 	}
 	if ((events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
-		!= 0) {
+	    != 0) {
 		/* Stopping AO due to completion or error. */
 		pci230_ao_stop(dev, s);
 		running = 0;
@@ -2764,7 +2795,8 @@ static int pci230_handle_ao_fifo(struct comedi_device *dev, struct comedi_subdev
 	return running;
 }
 
-static void pci230_handle_ai(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci230_handle_ai(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	unsigned int events = 0;
 	unsigned int status_fifo;
@@ -2780,11 +2812,11 @@ static void pci230_handle_ai(struct comedi_device *dev, struct comedi_subdevice
 	} else if (devpriv->ai_scan_count == 0) {
 		todo = 0;
 	} else if ((devpriv->ai_scan_count > PCI230_ADC_FIFOLEVEL_HALFFULL)
-		|| (scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL)) {
+		   || (scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL)) {
 		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	} else {
 		todo = (devpriv->ai_scan_count * scanlen)
-			- devpriv->ai_scan_pos;
+		    - devpriv->ai_scan_pos;
 		if (todo > PCI230_ADC_FIFOLEVEL_HALFFULL) {
 			todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 		}
@@ -2817,7 +2849,7 @@ static void pci230_handle_ai(struct comedi_device *dev, struct comedi_subdevice
 				if (devpriv->hwver > 0) {
 					/* Read PCI230+/260+ ADC FIFO level. */
 					fifoamount = inw(dev->iobase
-						+ PCI230P_ADCFFLEV);
+							 + PCI230P_ADCFFLEV);
 					if (fifoamount == 0) {
 						/* Shouldn't happen. */
 						break;
@@ -2854,7 +2886,7 @@ static void pci230_handle_ai(struct comedi_device *dev, struct comedi_subdevice
 	async->events |= events;
 
 	if ((async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
-				COMEDI_CB_OVERFLOW)) != 0) {
+			      COMEDI_CB_OVERFLOW)) != 0) {
 		/* disable hardware conversions */
 		pci230_ai_stop(dev, s);
 	} else {
@@ -2863,7 +2895,8 @@ static void pci230_handle_ai(struct comedi_device *dev, struct comedi_subdevice
 	}
 }
 
-static void pci230_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci230_ao_stop(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	unsigned long irqflags;
 	unsigned char intsrc;
@@ -2910,21 +2943,23 @@ static void pci230_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s
 		 * disable FIFO. */
 		devpriv->daccon &= PCI230_DAC_OR_MASK;
 		outw(devpriv->daccon | PCI230P2_DAC_FIFO_RESET
-			| PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,
-			dev->iobase + PCI230_DACCON);
+		     | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,
+		     dev->iobase + PCI230_DACCON);
 	}
 
 	/* Release resources. */
 	put_all_resources(dev, OWNER_AOCMD);
 }
 
-static int pci230_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci230_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	pci230_ao_stop(dev, s);
 	return 0;
 }
 
-static void pci230_ai_stop(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci230_ai_stop(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	unsigned long irqflags;
 	struct comedi_cmd *cmd;
@@ -2964,15 +2999,17 @@ static void pci230_ai_stop(struct comedi_device *dev, struct comedi_subdevice *s
 	/* Reset FIFO, disable FIFO and set start conversion source to none.
 	 * Keep se/diff and bip/uni settings */
 	devpriv->adccon = (devpriv->adccon & (PCI230_ADC_IR_MASK
-			| PCI230_ADC_IM_MASK)) | PCI230_ADC_TRIG_NONE;
+					      | PCI230_ADC_IM_MASK)) |
+	    PCI230_ADC_TRIG_NONE;
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
-		dev->iobase + PCI230_ADCCON);
+	     dev->iobase + PCI230_ADCCON);
 
 	/* Release resources. */
 	put_all_resources(dev, OWNER_AICMD);
 }
 
-static int pci230_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci230_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	pci230_ai_stop(dev, s);
 	return 0;

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 057443551c23..21133f068bf3 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -876,8 +876,8 @@ static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		dev->iobase + PCI230_ADCCON);
 
 	/* Register the interrupt handler. */
-	irq_hdl = comedi_request_irq(devpriv->pci_dev->irq, pci230_interrupt,
-		IRQF_SHARED, "amplc_pci230", dev);
+	irq_hdl = request_irq(devpriv->pci_dev->irq, pci230_interrupt,
+			      IRQF_SHARED, "amplc_pci230", dev);
 	if (irq_hdl < 0) {
 		printk("comedi%d: unable to register irq, "
 			"commands will not be available %d\n", dev->minor,
@@ -970,7 +970,7 @@ static int pci230_detach(struct comedi_device *dev)
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	if (devpriv) {
 		if (devpriv->pci_dev) {
@@ -995,7 +995,7 @@ static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 
 	ok = 1;
 	claimed = 0;
-	comedi_spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
 	for (b = 1, i = 0; (i < NUM_RESOURCES)
 		&& (res_mask != 0); b <<= 1, i++) {
 		if ((res_mask & b) != 0) {
@@ -1016,7 +1016,7 @@ static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 			}
 		}
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
 	return ok;
 }
 
@@ -1033,7 +1033,7 @@ static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 	unsigned int b;
 	unsigned long irqflags;
 
-	comedi_spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
 	for (b = 1, i = 0; (i < NUM_RESOURCES)
 		&& (res_mask != 0); b <<= 1, i++) {
 		if ((res_mask & b) != 0) {
@@ -1043,7 +1043,7 @@ static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 			}
 		}
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
 }
 
 static inline void put_one_resource(struct comedi_device *dev, unsigned int resource,
@@ -1145,12 +1145,12 @@ static int pci230_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s
 			status = inw(dev->iobase + PCI230_ADCCON);
 			if (!(status & PCI230_ADC_FIFO_EMPTY))
 				break;
-			comedi_udelay(1);
+			udelay(1);
 		}
 		if (i == TIMEOUT) {
-			/* rt_printk() should be used instead of printk()
+			/* printk() should be used instead of printk()
 			 * whenever the code can be called from real-time. */
-			rt_printk("timeout\n");
+			printk("timeout\n");
 			return -ETIMEDOUT;
 		}
 
@@ -1426,12 +1426,12 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 	if (trig_num != 0)
 		return -EINVAL;
 
-	comedi_spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
 	if (test_bit(AO_CMD_STARTED, &devpriv->state)) {
 		/* Perform scan. */
 		if (devpriv->hwver < 2) {
 			/* Not using DAC FIFO. */
-			comedi_spin_unlock_irqrestore(&devpriv->
+			spin_unlock_irqrestore(&devpriv->
 				ao_stop_spinlock, irqflags);
 			pci230_handle_ao_nofifo(dev, s);
 			comedi_event(dev, s);
@@ -1439,12 +1439,12 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
 			/* Using DAC FIFO. */
 			/* Read DACSWTRIG register to trigger conversion. */
 			inw(dev->iobase + PCI230P2_DACSWTRIG);
-			comedi_spin_unlock_irqrestore(&devpriv->
+			spin_unlock_irqrestore(&devpriv->
 				ao_stop_spinlock, irqflags);
 		}
 		/* Delay.  Should driver be responsible for this? */
 		/* XXX TODO: See if DAC busy bit can be used. */
-		comedi_udelay(8);
+		udelay(8);
 	}
 
 	return 1;
@@ -1508,13 +1508,13 @@ static void pci230_ao_start(struct comedi_device *dev, struct comedi_subdevice *
 			if (devpriv->hwver < 2) {
 				/* Not using DAC FIFO. */
 				/* Enable CT1 timer interrupt. */
-				comedi_spin_lock_irqsave(&devpriv->isr_spinlock,
+				spin_lock_irqsave(&devpriv->isr_spinlock,
 					irqflags);
 				devpriv->int_en |= PCI230_INT_ZCLK_CT1;
 				devpriv->ier |= PCI230_INT_ZCLK_CT1;
 				outb(devpriv->ier,
 					devpriv->iobase1 + PCI230_INT_SCE);
-				comedi_spin_unlock_irqrestore(&devpriv->
+				spin_unlock_irqrestore(&devpriv->
 					isr_spinlock, irqflags);
 			}
 			/* Set CT1 gate high to start counting. */
@@ -1527,12 +1527,12 @@ static void pci230_ao_start(struct comedi_device *dev, struct comedi_subdevice *
 		}
 		if (devpriv->hwver >= 2) {
 			/* Using DAC FIFO.  Enable DAC FIFO interrupt. */
-			comedi_spin_lock_irqsave(&devpriv->isr_spinlock,
+			spin_lock_irqsave(&devpriv->isr_spinlock,
 				irqflags);
 			devpriv->int_en |= PCI230P2_INT_DAC;
 			devpriv->ier |= PCI230P2_INT_DAC;
 			outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
-			comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock,
+			spin_unlock_irqrestore(&devpriv->isr_spinlock,
 				irqflags);
 		}
 	}
@@ -2088,7 +2088,7 @@ static int pci230_ai_inttrig_convert(struct comedi_device *dev, struct comedi_su
 	if (trig_num != 0)
 		return -EINVAL;
 
-	comedi_spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
 	if (test_bit(AI_CMD_STARTED, &devpriv->state)) {
 		unsigned int delayus;
 
@@ -2112,11 +2112,11 @@ static int pci230_ai_inttrig_convert(struct comedi_device *dev, struct comedi_su
 			/* single-ended or PCI230+/260+ */
 			delayus = 4;
 		}
-		comedi_spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
+		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
 			irqflags);
-		comedi_udelay(delayus);
+		udelay(delayus);
 	} else {
-		comedi_spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
+		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
 			irqflags);
 	}
 
@@ -2132,7 +2132,7 @@ static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
 	if (trig_num != 0)
 		return -EINVAL;
 
-	comedi_spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
 	if (test_bit(AI_CMD_STARTED, &devpriv->state)) {
 		/* Trigger scan by waggling CT0 gate source. */
 		zgat = GAT_CONFIG(0, GAT_GND);
@@ -2140,7 +2140,7 @@ static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
 		zgat = GAT_CONFIG(0, GAT_VCC);
 		outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
 
 	return 1;
 }
@@ -2160,11 +2160,11 @@ static void pci230_ai_start(struct comedi_device *dev, struct comedi_subdevice *
 		comedi_event(dev, s);
 	} else {
 		/* Enable ADC FIFO trigger level interrupt. */
-		comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 		devpriv->int_en |= PCI230_INT_ADC;
 		devpriv->ier |= PCI230_INT_ADC;
 		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
-		comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
 		/* Update conversion trigger source which is currently set
 		 * to CT2 output, which is currently stuck high. */
@@ -2426,7 +2426,7 @@ static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * FIFO reset (above) and the second FIFO reset (below). Setting the
 	 * channel gains and scan list _before_ the first FIFO reset also
 	 * helps, though only slightly. */
-	comedi_udelay(25);
+	udelay(25);
 
 	/* Reset FIFO again. */
 	outw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);
@@ -2575,7 +2575,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 		return IRQ_NONE;
 	}
 
-	comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	valid_status_int = devpriv->int_en & status_int;
 	/* Disable triggered interrupts.
 	 * (Only those interrupts that need re-enabling, are, later in the
@@ -2584,7 +2584,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 	devpriv->intr_running = 1;
 	devpriv->intr_cpuid = THISCPU;
-	comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
 	/*
 	 * Check the source of interrupt and handle it.
@@ -2613,13 +2613,13 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	}
 
 	/* Reenable interrupts. */
-	comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	if (devpriv->ier != devpriv->int_en) {
 		devpriv->ier = devpriv->int_en;
 		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 	}
 	devpriv->intr_running = 0;
-	comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
 	return IRQ_HANDLED;
 }
@@ -2870,9 +2870,9 @@ static void pci230_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s
 	int started;
 	struct comedi_cmd *cmd;
 
-	comedi_spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
 	started = test_and_clear_bit(AO_CMD_STARTED, &devpriv->state);
-	comedi_spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
 	if (!started) {
 		return;
 	}
@@ -2893,17 +2893,17 @@ static void pci230_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s
 	}
 	/* Disable interrupt and wait for interrupt routine to finish running
 	 * unless we are called from the interrupt routine. */
-	comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	devpriv->int_en &= ~intsrc;
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
-		comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
-		comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	}
 	if (devpriv->ier != devpriv->int_en) {
 		devpriv->ier = devpriv->int_en;
 		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
 	if (devpriv->hwver >= 2) {
 		/* Using DAC FIFO.  Reset FIFO, clear underrun error,
@@ -2930,9 +2930,9 @@ static void pci230_ai_stop(struct comedi_device *dev, struct comedi_subdevice *s
 	struct comedi_cmd *cmd;
 	int started;
 
-	comedi_spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
 	started = test_and_clear_bit(AI_CMD_STARTED, &devpriv->state);
-	comedi_spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
 	if (!started) {
 		return;
 	}
@@ -2947,19 +2947,19 @@ static void pci230_ai_stop(struct comedi_device *dev, struct comedi_subdevice *s
 		pci230_cancel_ct(dev, 0);
 	}
 
-	comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	/* Disable ADC interrupt and wait for interrupt routine to finish
 	 * running unless we are called from the interrupt routine. */
 	devpriv->int_en &= ~PCI230_INT_ADC;
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
-		comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
-		comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	}
 	if (devpriv->ier != devpriv->int_en) {
 		devpriv->ier = devpriv->int_en;
 		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
 	/* Reset FIFO, disable FIFO and set start conversion source to none.
 	 * Keep se/diff and bip/uni settings */

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 1d675173cd32..057443551c23 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -612,7 +612,7 @@ static struct comedi_driver driver_amplc_pci230 = {
 	.detach = pci230_detach,
 	.board_name = &pci230_boards[0].name,
 	.offset = sizeof(pci230_boards[0]),
-	.num_names = sizeof(pci230_boards) / sizeof(pci230_boards[0]),
+	.num_names = ARRAY_SIZE(pci230_boards),
 };
 
 COMEDI_PCI_INITCLEANUP(driver_amplc_pci230, pci230_pci_table);

commit 814900c904140cfe7f3e48cabec06b3eec57e0ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:54 2009 -0400

    Staging: comedi: more fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 94f45029a9cf..1d675173cd32 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -617,32 +617,32 @@ static struct comedi_driver driver_amplc_pci230 = {
 
 COMEDI_PCI_INITCLEANUP(driver_amplc_pci230, pci230_pci_table);
 
-static int pci230_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int pci230_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int pci230_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static void pci230_ct_setup_ns_mode(struct comedi_device * dev, unsigned int ct,
+static int pci230_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int pci230_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int pci230_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 	unsigned int mode, uint64_t ns, unsigned int round);
 static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round);
-static void pci230_cancel_ct(struct comedi_device * dev, unsigned int ct);
+static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct);
 static irqreturn_t pci230_interrupt(int irq, void *d);
-static int pci230_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int pci230_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int pci230_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static void pci230_ao_stop(struct comedi_device * dev, struct comedi_subdevice * s);
-static void pci230_handle_ao_nofifo(struct comedi_device * dev, struct comedi_subdevice * s);
-static int pci230_handle_ao_fifo(struct comedi_device * dev, struct comedi_subdevice * s);
-static int pci230_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int pci230_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int pci230_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static void pci230_ai_stop(struct comedi_device * dev, struct comedi_subdevice * s);
-static void pci230_handle_ai(struct comedi_device * dev, struct comedi_subdevice * s);
-
-static short pci230_ai_read(struct comedi_device * dev)
+static int pci230_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pci230_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static void pci230_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s);
+static void pci230_handle_ao_nofifo(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pci230_handle_ao_fifo(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pci230_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static void pci230_ai_stop(struct comedi_device *dev, struct comedi_subdevice *s);
+static void pci230_handle_ai(struct comedi_device *dev, struct comedi_subdevice *s);
+
+static short pci230_ai_read(struct comedi_device *dev)
 {
 	/* Read sample. */
 	short data = (short) inw(dev->iobase + PCI230_ADCDATA);

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 570ad457fe55..94f45029a9cf 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -457,46 +457,46 @@ struct pci230_board {
 };
 static const struct pci230_board pci230_boards[] = {
 	{
-	      name:	"pci230+",
-	      id:	PCI_DEVICE_ID_PCI230,
-	      ai_chans:16,
-	      ai_bits:	16,
-	      ao_chans:2,
-	      ao_bits:	12,
-	      have_dio:1,
-	      min_hwver:1,
+	.name = "pci230+",
+	.id = PCI_DEVICE_ID_PCI230,
+	.ai_chans = 16,
+	.ai_bits = 16,
+	.ao_chans = 2,
+	.ao_bits = 12,
+	.have_dio = 1,
+	.min_hwver = 1,
 		},
 	{
-	      name:	"pci260+",
-	      id:	PCI_DEVICE_ID_PCI260,
-	      ai_chans:16,
-	      ai_bits:	16,
-	      ao_chans:0,
-	      ao_bits:	0,
-	      have_dio:0,
-	      min_hwver:1,
+	.name = "pci260+",
+	.id = PCI_DEVICE_ID_PCI260,
+	.ai_chans = 16,
+	.ai_bits = 16,
+	.ao_chans = 0,
+	.ao_bits = 0,
+	.have_dio = 0,
+	.min_hwver = 1,
 		},
 	{
-	      name:	"pci230",
-	      id:	PCI_DEVICE_ID_PCI230,
-	      ai_chans:16,
-	      ai_bits:	12,
-	      ao_chans:2,
-	      ao_bits:	12,
-	      have_dio:1,
+	.name = "pci230",
+	.id = PCI_DEVICE_ID_PCI230,
+	.ai_chans = 16,
+	.ai_bits = 12,
+	.ao_chans = 2,
+	.ao_bits = 12,
+	.have_dio = 1,
 		},
 	{
-	      name:	"pci260",
-	      id:	PCI_DEVICE_ID_PCI260,
-	      ai_chans:16,
-	      ai_bits:	12,
-	      ao_chans:0,
-	      ao_bits:	0,
-	      have_dio:0,
+	.name = "pci260",
+	.id = PCI_DEVICE_ID_PCI260,
+	.ai_chans = 16,
+	.ai_bits = 12,
+	.ao_chans = 0,
+	.ao_bits = 0,
+	.have_dio = 0,
 		},
 	{
-	      name:	"amplc_pci230",	/* Wildcard matches any above */
-	      id:	PCI_DEVICE_ID_INVALID,
+	.name = "amplc_pci230",	/* Wildcard matches any above */
+	.id = PCI_DEVICE_ID_INVALID,
 		},
 };
 
@@ -606,13 +606,13 @@ static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
 static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int pci230_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_pci230 = {
-      driver_name:"amplc_pci230",
-      module:THIS_MODULE,
-      attach:pci230_attach,
-      detach:pci230_detach,
-      board_name:&pci230_boards[0].name,
-      offset:sizeof(pci230_boards[0]),
-      num_names:sizeof(pci230_boards) / sizeof(pci230_boards[0]),
+	.driver_name = "amplc_pci230",
+	.module = THIS_MODULE,
+	.attach = pci230_attach,
+	.detach = pci230_detach,
+	.board_name = &pci230_boards[0].name,
+	.offset = sizeof(pci230_boards[0]),
+	.num_names = sizeof(pci230_boards) / sizeof(pci230_boards[0]),
 };
 
 COMEDI_PCI_INITCLEANUP(driver_amplc_pci230, pci230_pci_table);

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 0fa228f6edc4..570ad457fe55 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -603,8 +603,8 @@ static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pci230_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int pci230_detach(struct comedi_device * dev);
+static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci230_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_pci230 = {
       driver_name:"amplc_pci230",
       module:THIS_MODULE,
@@ -660,7 +660,7 @@ static short pci230_ai_read(struct comedi_device * dev)
 	return data;
 }
 
-static inline unsigned short pci230_ao_mangle_datum(struct comedi_device * dev,
+static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
 	short datum)
 {
 	/* If a bipolar range was specified, mangle it (straight binary->twos
@@ -676,7 +676,7 @@ static inline unsigned short pci230_ao_mangle_datum(struct comedi_device * dev,
 	return (unsigned short)datum;
 }
 
-static inline void pci230_ao_write_nofifo(struct comedi_device * dev, short datum,
+static inline void pci230_ao_write_nofifo(struct comedi_device *dev, short datum,
 	unsigned int chan)
 {
 	/* Store unmangled datum to be read back later. */
@@ -687,7 +687,7 @@ static inline void pci230_ao_write_nofifo(struct comedi_device * dev, short datu
 			? PCI230_DACOUT1 : PCI230_DACOUT2));
 }
 
-static inline void pci230_ao_write_fifo(struct comedi_device * dev, short datum,
+static inline void pci230_ao_write_fifo(struct comedi_device *dev, short datum,
 	unsigned int chan)
 {
 	/* Store unmangled datum to be read back later. */
@@ -704,7 +704,7 @@ static inline void pci230_ao_write_fifo(struct comedi_device * dev, short datum,
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pci230_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase1, iobase2;
@@ -961,7 +961,7 @@ static int pci230_attach(struct comedi_device * dev, struct comedi_devconfig * i
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int pci230_detach(struct comedi_device * dev)
+static int pci230_detach(struct comedi_device *dev)
 {
 	printk("comedi%d: amplc_pci230: remove\n", dev->minor);
 
@@ -984,7 +984,7 @@ static int pci230_detach(struct comedi_device * dev)
 	return 0;
 }
 
-static int get_resources(struct comedi_device * dev, unsigned int res_mask,
+static int get_resources(struct comedi_device *dev, unsigned int res_mask,
 	unsigned char owner)
 {
 	int ok;
@@ -1020,13 +1020,13 @@ static int get_resources(struct comedi_device * dev, unsigned int res_mask,
 	return ok;
 }
 
-static inline int get_one_resource(struct comedi_device * dev, unsigned int resource,
+static inline int get_one_resource(struct comedi_device *dev, unsigned int resource,
 	unsigned char owner)
 {
 	return get_resources(dev, (1U << resource), owner);
 }
 
-static void put_resources(struct comedi_device * dev, unsigned int res_mask,
+static void put_resources(struct comedi_device *dev, unsigned int res_mask,
 	unsigned char owner)
 {
 	unsigned int i;
@@ -1046,13 +1046,13 @@ static void put_resources(struct comedi_device * dev, unsigned int res_mask,
 	comedi_spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
 }
 
-static inline void put_one_resource(struct comedi_device * dev, unsigned int resource,
+static inline void put_one_resource(struct comedi_device *dev, unsigned int resource,
 	unsigned char owner)
 {
 	put_resources(dev, (1U << resource), owner);
 }
 
-static inline void put_all_resources(struct comedi_device * dev, unsigned char owner)
+static inline void put_all_resources(struct comedi_device *dev, unsigned char owner)
 {
 	put_resources(dev, (1U << NUM_RESOURCES) - 1, owner);
 }
@@ -1060,8 +1060,8 @@ static inline void put_all_resources(struct comedi_device * dev, unsigned char o
 /*
  *  COMEDI_SUBD_AI instruction;
  */
-static int pci230_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pci230_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int n, i;
 	unsigned int chan, range, aref;
@@ -1165,8 +1165,8 @@ static int pci230_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 /*
  *  COMEDI_SUBD_AO instructions;
  */
-static int pci230_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pci230_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan, range;
@@ -1193,8 +1193,8 @@ static int pci230_ao_winsn(struct comedi_device * dev, struct comedi_subdevice *
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int pci230_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pci230_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1205,8 +1205,8 @@ static int pci230_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 	return i;
 }
 
-static int pci230_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int pci230_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1418,8 +1418,8 @@ static int pci230_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static int pci230_ao_inttrig_scan_begin(struct comedi_device * dev,
-	struct comedi_subdevice * s, unsigned int trig_num)
+static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
+	struct comedi_subdevice *s, unsigned int trig_num)
 {
 	unsigned long irqflags;
 
@@ -1450,7 +1450,7 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device * dev,
 	return 1;
 }
 
-static void pci230_ao_start(struct comedi_device * dev, struct comedi_subdevice * s)
+static void pci230_ao_start(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1538,7 +1538,7 @@ static void pci230_ao_start(struct comedi_device * dev, struct comedi_subdevice
 	}
 }
 
-static int pci230_ao_inttrig_start(struct comedi_device * dev, struct comedi_subdevice * s,
+static int pci230_ao_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trig_num)
 {
 	if (trig_num != 0)
@@ -1550,7 +1550,7 @@ static int pci230_ao_inttrig_start(struct comedi_device * dev, struct comedi_sub
 	return 1;
 }
 
-static int pci230_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned short daccon;
 	unsigned int range;
@@ -1626,7 +1626,7 @@ static int pci230_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 	return 0;
 }
 
-static int pci230_ai_check_scan_period(struct comedi_cmd * cmd)
+static int pci230_ai_check_scan_period(struct comedi_cmd *cmd)
 {
 	unsigned int min_scan_period, chanlist_len;
 	int err = 0;
@@ -1650,8 +1650,8 @@ static int pci230_ai_check_scan_period(struct comedi_cmd * cmd)
 	return !err;
 }
 
-static int pci230_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -2036,8 +2036,8 @@ static int pci230_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static void pci230_ai_update_fifo_trigger_level(struct comedi_device * dev,
-	struct comedi_subdevice * s)
+static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
+	struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int scanlen = cmd->scan_end_arg;
@@ -2080,7 +2080,7 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device * dev,
 	}
 }
 
-static int pci230_ai_inttrig_convert(struct comedi_device * dev, struct comedi_subdevice * s,
+static int pci230_ai_inttrig_convert(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trig_num)
 {
 	unsigned long irqflags;
@@ -2123,8 +2123,8 @@ static int pci230_ai_inttrig_convert(struct comedi_device * dev, struct comedi_s
 	return 1;
 }
 
-static int pci230_ai_inttrig_scan_begin(struct comedi_device * dev,
-	struct comedi_subdevice * s, unsigned int trig_num)
+static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
+	struct comedi_subdevice *s, unsigned int trig_num)
 {
 	unsigned long irqflags;
 	unsigned char zgat;
@@ -2145,7 +2145,7 @@ static int pci230_ai_inttrig_scan_begin(struct comedi_device * dev,
 	return 1;
 }
 
-static void pci230_ai_start(struct comedi_device * dev, struct comedi_subdevice * s)
+static void pci230_ai_start(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long irqflags;
 	unsigned short conv;
@@ -2282,7 +2282,7 @@ static void pci230_ai_start(struct comedi_device * dev, struct comedi_subdevice
 	}
 }
 
-static int pci230_ai_inttrig_start(struct comedi_device * dev, struct comedi_subdevice * s,
+static int pci230_ai_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trig_num)
 {
 	if (trig_num != 0)
@@ -2294,7 +2294,7 @@ static int pci230_ai_inttrig_start(struct comedi_device * dev, struct comedi_sub
 	return 1;
 }
 
-static int pci230_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned int i, chan, range, diff;
 	unsigned int res_mask;
@@ -2534,7 +2534,7 @@ static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round)
 	return;
 }
 
-static void pci230_ct_setup_ns_mode(struct comedi_device * dev, unsigned int ct,
+static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
 	unsigned int mode, uint64_t ns, unsigned int round)
 {
 	unsigned int clk_src;
@@ -2553,7 +2553,7 @@ static void pci230_ct_setup_ns_mode(struct comedi_device * dev, unsigned int ct,
 	i8254_write(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, count);
 }
 
-static void pci230_cancel_ct(struct comedi_device * dev, unsigned int ct)
+static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)
 {
 	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct,
 		I8254_MODE1);
@@ -2624,7 +2624,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void pci230_handle_ao_nofifo(struct comedi_device * dev, struct comedi_subdevice * s)
+static void pci230_handle_ao_nofifo(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	short data;
 	int i, ret;
@@ -2661,7 +2661,7 @@ static void pci230_handle_ao_nofifo(struct comedi_device * dev, struct comedi_su
 
 /* Loads DAC FIFO (if using it) from buffer. */
 /* Returns 0 if AO finished due to completion or error, 1 if still going. */
-static int pci230_handle_ao_fifo(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pci230_handle_ao_fifo(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -2764,7 +2764,7 @@ static int pci230_handle_ao_fifo(struct comedi_device * dev, struct comedi_subde
 	return running;
 }
 
-static void pci230_handle_ai(struct comedi_device * dev, struct comedi_subdevice * s)
+static void pci230_handle_ai(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned int events = 0;
 	unsigned int status_fifo;
@@ -2863,7 +2863,7 @@ static void pci230_handle_ai(struct comedi_device * dev, struct comedi_subdevice
 	}
 }
 
-static void pci230_ao_stop(struct comedi_device * dev, struct comedi_subdevice * s)
+static void pci230_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long irqflags;
 	unsigned char intsrc;
@@ -2918,13 +2918,13 @@ static void pci230_ao_stop(struct comedi_device * dev, struct comedi_subdevice *
 	put_all_resources(dev, OWNER_AOCMD);
 }
 
-static int pci230_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pci230_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	pci230_ao_stop(dev, s);
 	return 0;
 }
 
-static void pci230_ai_stop(struct comedi_device * dev, struct comedi_subdevice * s)
+static void pci230_ai_stop(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long irqflags;
 	struct comedi_cmd *cmd;
@@ -2972,7 +2972,7 @@ static void pci230_ai_stop(struct comedi_device * dev, struct comedi_subdevice *
 	put_all_resources(dev, OWNER_AICMD);
 }
 
-static int pci230_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pci230_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	pci230_ai_stop(dev, s);
 	return 0;

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 0c9e5737e100..0fa228f6edc4 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -187,9 +187,11 @@ Extra triggered scan functionality, interrupt bug-fix added by Steve Sharples.
 Support for PCI230+/260+, more triggered scan functionality, and workarounds
 for (or detection of) various hardware problems added by Ian Abbott.
 */
+
 #include "../comedidev.h"
 
 #include <linux/delay.h>
+#include <linux/interrupt.h>
 
 #include "comedi_pci.h"
 #include "8253.h"
@@ -625,7 +627,7 @@ static void pci230_ct_setup_ns_mode(struct comedi_device * dev, unsigned int ct,
 	unsigned int mode, uint64_t ns, unsigned int round);
 static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round);
 static void pci230_cancel_ct(struct comedi_device * dev, unsigned int ct);
-static irqreturn_t pci230_interrupt(int irq, void *d PT_REGS_ARG);
+static irqreturn_t pci230_interrupt(int irq, void *d);
 static int pci230_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_cmd * cmd);
 static int pci230_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
@@ -2559,7 +2561,7 @@ static void pci230_cancel_ct(struct comedi_device * dev, unsigned int ct)
 }
 
 /* Interrupt handler */
-static irqreturn_t pci230_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t pci230_interrupt(int irq, void *d)
 {
 	unsigned char status_int, valid_status_int;
 	struct comedi_device *dev = (struct comedi_device *) d;

commit b3e8fa97c454246be2bc6f4ddf20951c5b74bc22
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:10:23 2009 -0400

    Staging: comedi: Remove pci230_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index a534763a90f9..0c9e5737e100 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -443,7 +443,7 @@ enum {
  * Board descriptions for the two boards supported.
  */
 
-typedef struct pci230_board_struct {
+struct pci230_board {
 	const char *name;
 	unsigned short id;
 	int ai_chans;
@@ -452,8 +452,8 @@ typedef struct pci230_board_struct {
 	int ao_bits;
 	int have_dio;
 	unsigned int min_hwver;	/* Minimum hardware version supported. */
-} pci230_board;
-static const pci230_board pci230_boards[] = {
+};
+static const struct pci230_board pci230_boards[] = {
 	{
 	      name:	"pci230+",
 	      id:	PCI_DEVICE_ID_PCI230,
@@ -511,7 +511,7 @@ MODULE_DEVICE_TABLE(pci, pci230_pci_table);
  * Useful for shorthand access to the particular board structure
  */
 #define n_pci230_boards (sizeof(pci230_boards)/sizeof(pci230_boards[0]))
-#define thisboard ((const pci230_board *)dev->board_ptr)
+#define thisboard ((const struct pci230_board *)dev->board_ptr)
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 432f05ba3bc5..a534763a90f9 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -601,7 +601,7 @@ static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pci230_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pci230_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int pci230_detach(struct comedi_device * dev);
 static struct comedi_driver driver_amplc_pci230 = {
       driver_name:"amplc_pci230",
@@ -702,7 +702,7 @@ static inline void pci230_ao_write_fifo(struct comedi_device * dev, short datum,
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pci230_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int pci230_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase1, iobase2;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index d985f649f9fb..432f05ba3bc5 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -616,11 +616,11 @@ static struct comedi_driver driver_amplc_pci230 = {
 COMEDI_PCI_INITCLEANUP(driver_amplc_pci230, pci230_pci_table);
 
 static int pci230_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int pci230_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int pci230_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static void pci230_ct_setup_ns_mode(struct comedi_device * dev, unsigned int ct,
 	unsigned int mode, uint64_t ns, unsigned int round);
 static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round);
@@ -1059,7 +1059,7 @@ static inline void put_all_resources(struct comedi_device * dev, unsigned char o
  *  COMEDI_SUBD_AI instruction;
  */
 static int pci230_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int n, i;
 	unsigned int chan, range, aref;
@@ -1164,7 +1164,7 @@ static int pci230_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
  *  COMEDI_SUBD_AO instructions;
  */
 static int pci230_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan, range;
@@ -1192,7 +1192,7 @@ static int pci230_ao_winsn(struct comedi_device * dev, struct comedi_subdevice *
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
 static int pci230_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 7e7f627abb24..d985f649f9fb 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -627,14 +627,14 @@ static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round);
 static void pci230_cancel_ct(struct comedi_device * dev, unsigned int ct);
 static irqreturn_t pci230_interrupt(int irq, void *d PT_REGS_ARG);
 static int pci230_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int pci230_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int pci230_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static void pci230_ao_stop(struct comedi_device * dev, struct comedi_subdevice * s);
 static void pci230_handle_ao_nofifo(struct comedi_device * dev, struct comedi_subdevice * s);
 static int pci230_handle_ao_fifo(struct comedi_device * dev, struct comedi_subdevice * s);
 static int pci230_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int pci230_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int pci230_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static void pci230_ai_stop(struct comedi_device * dev, struct comedi_subdevice * s);
@@ -1204,7 +1204,7 @@ static int pci230_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 static int pci230_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1451,7 +1451,7 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device * dev,
 static void pci230_ao_start(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long irqflags;
 
 	set_bit(AO_CMD_STARTED, &devpriv->state);
@@ -1554,7 +1554,7 @@ static int pci230_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 	unsigned int range;
 
 	/* Get the command. */
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		/* Claim Z2-CT1. */
@@ -1624,7 +1624,7 @@ static int pci230_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 	return 0;
 }
 
-static int pci230_ai_check_scan_period(comedi_cmd * cmd)
+static int pci230_ai_check_scan_period(struct comedi_cmd * cmd)
 {
 	unsigned int min_scan_period, chanlist_len;
 	int err = 0;
@@ -1649,7 +1649,7 @@ static int pci230_ai_check_scan_period(comedi_cmd * cmd)
 }
 
 static int pci230_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -2037,7 +2037,7 @@ static int pci230_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 static void pci230_ai_update_fifo_trigger_level(struct comedi_device * dev,
 	struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int scanlen = cmd->scan_end_arg;
 	unsigned int wake;
 	unsigned short triglev;
@@ -2148,7 +2148,7 @@ static void pci230_ai_start(struct comedi_device * dev, struct comedi_subdevice
 	unsigned long irqflags;
 	unsigned short conv;
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 
 	set_bit(AI_CMD_STARTED, &devpriv->state);
 	if (!devpriv->ai_continuous && (devpriv->ai_scan_count == 0)) {
@@ -2301,7 +2301,7 @@ static int pci230_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 
 	/* Get the command. */
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 
 	/*
 	 * Determine which shared resources are needed.
@@ -2627,7 +2627,7 @@ static void pci230_handle_ao_nofifo(struct comedi_device * dev, struct comedi_su
 	short data;
 	int i, ret;
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 
 	if (!devpriv->ao_continuous && (devpriv->ao_scan_count == 0)) {
 		return;
@@ -2662,7 +2662,7 @@ static void pci230_handle_ao_nofifo(struct comedi_device * dev, struct comedi_su
 static int pci230_handle_ao_fifo(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int num_scans;
 	unsigned int room;
 	unsigned short dacstat;
@@ -2866,7 +2866,7 @@ static void pci230_ao_stop(struct comedi_device * dev, struct comedi_subdevice *
 	unsigned long irqflags;
 	unsigned char intsrc;
 	int started;
-	comedi_cmd *cmd;
+	struct comedi_cmd *cmd;
 
 	comedi_spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
 	started = test_and_clear_bit(AO_CMD_STARTED, &devpriv->state);
@@ -2925,7 +2925,7 @@ static int pci230_ao_cancel(struct comedi_device * dev, struct comedi_subdevice
 static void pci230_ai_stop(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long irqflags;
-	comedi_cmd *cmd;
+	struct comedi_cmd *cmd;
 	int started;
 
 	comedi_spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 7676f22772bf..7e7f627abb24 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -568,7 +568,7 @@ static const unsigned int pci230_timebase[8] = {
 };
 
 /* PCI230 analogue input range table */
-static const comedi_lrange pci230_ai_range = { 7, {
+static const struct comedi_lrange pci230_ai_range = { 7, {
 			BIP_RANGE(10),
 			BIP_RANGE(5),
 			BIP_RANGE(2.5),
@@ -586,7 +586,7 @@ static const unsigned char pci230_ai_gain[7] = { 0, 1, 2, 3, 1, 2, 3 };
 static const unsigned char pci230_ai_bipolar[7] = { 1, 1, 1, 1, 0, 0, 0 };
 
 /* PCI230 analogue output range table */
-static const comedi_lrange pci230_ao_range = { 2, {
+static const struct comedi_lrange pci230_ao_range = { 2, {
 			UNI_RANGE(10),
 			BIP_RANGE(10)
 	}

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 99ffbd2a961c..7676f22772bf 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -596,14 +596,14 @@ static const comedi_lrange pci230_ao_range = { 2, {
 static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
 
 /*
- * The comedi_driver structure tells the Comedi core module
+ * The struct comedi_driver structure tells the Comedi core module
  * which functions to call to configure/deconfigure (attach/detach)
  * the board, and also about the kernel module that contains
  * the device code.
  */
 static int pci230_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int pci230_detach(struct comedi_device * dev);
-static comedi_driver driver_amplc_pci230 = {
+static struct comedi_driver driver_amplc_pci230 = {
       driver_name:"amplc_pci230",
       module:THIS_MODULE,
       attach:pci230_attach,

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index ee5f20320256..99ffbd2a961c 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -1450,7 +1450,7 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device * dev,
 
 static void pci230_ao_start(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned long irqflags;
 
@@ -2147,7 +2147,7 @@ static void pci230_ai_start(struct comedi_device * dev, struct comedi_subdevice
 {
 	unsigned long irqflags;
 	unsigned short conv;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 
 	set_bit(AI_CMD_STARTED, &devpriv->state);
@@ -2300,7 +2300,7 @@ static int pci230_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 	unsigned char zgat;
 
 	/* Get the command. */
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 
 	/*
@@ -2626,7 +2626,7 @@ static void pci230_handle_ao_nofifo(struct comedi_device * dev, struct comedi_su
 {
 	short data;
 	int i, ret;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 
 	if (!devpriv->ao_continuous && (devpriv->ao_scan_count == 0)) {
@@ -2661,7 +2661,7 @@ static void pci230_handle_ao_nofifo(struct comedi_device * dev, struct comedi_su
 /* Returns 0 if AO finished due to completion or error, 1 if still going. */
 static int pci230_handle_ao_fifo(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned int num_scans;
 	unsigned int room;
@@ -2769,7 +2769,7 @@ static void pci230_handle_ai(struct comedi_device * dev, struct comedi_subdevice
 	unsigned int i;
 	unsigned int todo;
 	unsigned int fifoamount;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	unsigned int scanlen = async->cmd.scan_end_arg;
 
 	/* Determine number of samples to read. */

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index c66a840085f7..ee5f20320256 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -615,30 +615,30 @@ static comedi_driver driver_amplc_pci230 = {
 
 COMEDI_PCI_INITCLEANUP(driver_amplc_pci230, pci230_pci_table);
 
-static int pci230_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int pci230_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int pci230_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static void pci230_ct_setup_ns_mode(struct comedi_device * dev, unsigned int ct,
 	unsigned int mode, uint64_t ns, unsigned int round);
 static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round);
 static void pci230_cancel_ct(struct comedi_device * dev, unsigned int ct);
 static irqreturn_t pci230_interrupt(int irq, void *d PT_REGS_ARG);
-static int pci230_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int pci230_ao_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int pci230_ao_cancel(struct comedi_device * dev, comedi_subdevice * s);
-static void pci230_ao_stop(struct comedi_device * dev, comedi_subdevice * s);
-static void pci230_handle_ao_nofifo(struct comedi_device * dev, comedi_subdevice * s);
-static int pci230_handle_ao_fifo(struct comedi_device * dev, comedi_subdevice * s);
-static int pci230_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int pci230_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static void pci230_ao_stop(struct comedi_device * dev, struct comedi_subdevice * s);
+static void pci230_handle_ao_nofifo(struct comedi_device * dev, struct comedi_subdevice * s);
+static int pci230_handle_ao_fifo(struct comedi_device * dev, struct comedi_subdevice * s);
+static int pci230_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int pci230_ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int pci230_ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
-static void pci230_ai_stop(struct comedi_device * dev, comedi_subdevice * s);
-static void pci230_handle_ai(struct comedi_device * dev, comedi_subdevice * s);
+static int pci230_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int pci230_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static void pci230_ai_stop(struct comedi_device * dev, struct comedi_subdevice * s);
+static void pci230_handle_ai(struct comedi_device * dev, struct comedi_subdevice * s);
 
 static short pci230_ai_read(struct comedi_device * dev)
 {
@@ -704,7 +704,7 @@ static inline void pci230_ao_write_fifo(struct comedi_device * dev, short datum,
  */
 static int pci230_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	unsigned long iobase1, iobase2;
 	/* PCI230's I/O spaces 1 and 2 respectively. */
 	struct pci_dev *pci_dev;
@@ -1058,7 +1058,7 @@ static inline void put_all_resources(struct comedi_device * dev, unsigned char o
 /*
  *  COMEDI_SUBD_AI instruction;
  */
-static int pci230_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int n, i;
@@ -1163,7 +1163,7 @@ static int pci230_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 /*
  *  COMEDI_SUBD_AO instructions;
  */
-static int pci230_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -1191,7 +1191,7 @@ static int pci230_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int pci230_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -1203,7 +1203,7 @@ static int pci230_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	return i;
 }
 
-static int pci230_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1417,7 +1417,7 @@ static int pci230_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 }
 
 static int pci230_ao_inttrig_scan_begin(struct comedi_device * dev,
-	comedi_subdevice * s, unsigned int trig_num)
+	struct comedi_subdevice * s, unsigned int trig_num)
 {
 	unsigned long irqflags;
 
@@ -1448,7 +1448,7 @@ static int pci230_ao_inttrig_scan_begin(struct comedi_device * dev,
 	return 1;
 }
 
-static void pci230_ao_start(struct comedi_device * dev, comedi_subdevice * s)
+static void pci230_ao_start(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -1536,7 +1536,7 @@ static void pci230_ao_start(struct comedi_device * dev, comedi_subdevice * s)
 	}
 }
 
-static int pci230_ao_inttrig_start(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_inttrig_start(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trig_num)
 {
 	if (trig_num != 0)
@@ -1548,7 +1548,7 @@ static int pci230_ao_inttrig_start(struct comedi_device * dev, comedi_subdevice
 	return 1;
 }
 
-static int pci230_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int pci230_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned short daccon;
 	unsigned int range;
@@ -1648,7 +1648,7 @@ static int pci230_ai_check_scan_period(comedi_cmd * cmd)
 	return !err;
 }
 
-static int pci230_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -2035,7 +2035,7 @@ static int pci230_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 }
 
 static void pci230_ai_update_fifo_trigger_level(struct comedi_device * dev,
-	comedi_subdevice * s)
+	struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int scanlen = cmd->scan_end_arg;
@@ -2078,7 +2078,7 @@ static void pci230_ai_update_fifo_trigger_level(struct comedi_device * dev,
 	}
 }
 
-static int pci230_ai_inttrig_convert(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ai_inttrig_convert(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trig_num)
 {
 	unsigned long irqflags;
@@ -2122,7 +2122,7 @@ static int pci230_ai_inttrig_convert(struct comedi_device * dev, comedi_subdevic
 }
 
 static int pci230_ai_inttrig_scan_begin(struct comedi_device * dev,
-	comedi_subdevice * s, unsigned int trig_num)
+	struct comedi_subdevice * s, unsigned int trig_num)
 {
 	unsigned long irqflags;
 	unsigned char zgat;
@@ -2143,7 +2143,7 @@ static int pci230_ai_inttrig_scan_begin(struct comedi_device * dev,
 	return 1;
 }
 
-static void pci230_ai_start(struct comedi_device * dev, comedi_subdevice * s)
+static void pci230_ai_start(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long irqflags;
 	unsigned short conv;
@@ -2280,7 +2280,7 @@ static void pci230_ai_start(struct comedi_device * dev, comedi_subdevice * s)
 	}
 }
 
-static int pci230_ai_inttrig_start(struct comedi_device * dev, comedi_subdevice * s,
+static int pci230_ai_inttrig_start(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trig_num)
 {
 	if (trig_num != 0)
@@ -2292,7 +2292,7 @@ static int pci230_ai_inttrig_start(struct comedi_device * dev, comedi_subdevice
 	return 1;
 }
 
-static int pci230_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int pci230_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned int i, chan, range, diff;
 	unsigned int res_mask;
@@ -2563,7 +2563,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	unsigned char status_int, valid_status_int;
 	struct comedi_device *dev = (struct comedi_device *) d;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	unsigned long irqflags;
 
 	/* Read interrupt status/enable register. */
@@ -2622,7 +2622,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-static void pci230_handle_ao_nofifo(struct comedi_device * dev, comedi_subdevice * s)
+static void pci230_handle_ao_nofifo(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	short data;
 	int i, ret;
@@ -2659,7 +2659,7 @@ static void pci230_handle_ao_nofifo(struct comedi_device * dev, comedi_subdevice
 
 /* Loads DAC FIFO (if using it) from buffer. */
 /* Returns 0 if AO finished due to completion or error, 1 if still going. */
-static int pci230_handle_ao_fifo(struct comedi_device * dev, comedi_subdevice * s)
+static int pci230_handle_ao_fifo(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -2762,7 +2762,7 @@ static int pci230_handle_ao_fifo(struct comedi_device * dev, comedi_subdevice *
 	return running;
 }
 
-static void pci230_handle_ai(struct comedi_device * dev, comedi_subdevice * s)
+static void pci230_handle_ai(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned int events = 0;
 	unsigned int status_fifo;
@@ -2861,7 +2861,7 @@ static void pci230_handle_ai(struct comedi_device * dev, comedi_subdevice * s)
 	}
 }
 
-static void pci230_ao_stop(struct comedi_device * dev, comedi_subdevice * s)
+static void pci230_ao_stop(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long irqflags;
 	unsigned char intsrc;
@@ -2916,13 +2916,13 @@ static void pci230_ao_stop(struct comedi_device * dev, comedi_subdevice * s)
 	put_all_resources(dev, OWNER_AOCMD);
 }
 
-static int pci230_ao_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int pci230_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	pci230_ao_stop(dev, s);
 	return 0;
 }
 
-static void pci230_ai_stop(struct comedi_device * dev, comedi_subdevice * s)
+static void pci230_ai_stop(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long irqflags;
 	comedi_cmd *cmd;
@@ -2970,7 +2970,7 @@ static void pci230_ai_stop(struct comedi_device * dev, comedi_subdevice * s)
 	put_all_resources(dev, OWNER_AICMD);
 }
 
-static int pci230_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int pci230_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	pci230_ai_stop(dev, s);
 	return 0;

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 4463e9803e08..c66a840085f7 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -515,7 +515,7 @@ MODULE_DEVICE_TABLE(pci, pci230_pci_table);
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the comedi_device struct.  */
+   feel free to suggest moving the variable to the struct comedi_device struct.  */
 struct pci230_private {
 	struct pci_dev *pci_dev;
 	spinlock_t isr_spinlock;	/* Interrupt spin lock */
@@ -601,8 +601,8 @@ static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pci230_attach(comedi_device * dev, comedi_devconfig * it);
-static int pci230_detach(comedi_device * dev);
+static int pci230_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pci230_detach(struct comedi_device * dev);
 static comedi_driver driver_amplc_pci230 = {
       driver_name:"amplc_pci230",
       module:THIS_MODULE,
@@ -615,32 +615,32 @@ static comedi_driver driver_amplc_pci230 = {
 
 COMEDI_PCI_INITCLEANUP(driver_amplc_pci230, pci230_pci_table);
 
-static int pci230_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int pci230_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int pci230_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static void pci230_ct_setup_ns_mode(comedi_device * dev, unsigned int ct,
+static void pci230_ct_setup_ns_mode(struct comedi_device * dev, unsigned int ct,
 	unsigned int mode, uint64_t ns, unsigned int round);
 static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round);
-static void pci230_cancel_ct(comedi_device * dev, unsigned int ct);
+static void pci230_cancel_ct(struct comedi_device * dev, unsigned int ct);
 static irqreturn_t pci230_interrupt(int irq, void *d PT_REGS_ARG);
-static int pci230_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int pci230_ao_cmd(comedi_device * dev, comedi_subdevice * s);
-static int pci230_ao_cancel(comedi_device * dev, comedi_subdevice * s);
-static void pci230_ao_stop(comedi_device * dev, comedi_subdevice * s);
-static void pci230_handle_ao_nofifo(comedi_device * dev, comedi_subdevice * s);
-static int pci230_handle_ao_fifo(comedi_device * dev, comedi_subdevice * s);
-static int pci230_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int pci230_ao_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static void pci230_ao_stop(struct comedi_device * dev, comedi_subdevice * s);
+static void pci230_handle_ao_nofifo(struct comedi_device * dev, comedi_subdevice * s);
+static int pci230_handle_ao_fifo(struct comedi_device * dev, comedi_subdevice * s);
+static int pci230_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int pci230_ai_cmd(comedi_device * dev, comedi_subdevice * s);
-static int pci230_ai_cancel(comedi_device * dev, comedi_subdevice * s);
-static void pci230_ai_stop(comedi_device * dev, comedi_subdevice * s);
-static void pci230_handle_ai(comedi_device * dev, comedi_subdevice * s);
+static int pci230_ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int pci230_ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static void pci230_ai_stop(struct comedi_device * dev, comedi_subdevice * s);
+static void pci230_handle_ai(struct comedi_device * dev, comedi_subdevice * s);
 
-static short pci230_ai_read(comedi_device * dev)
+static short pci230_ai_read(struct comedi_device * dev)
 {
 	/* Read sample. */
 	short data = (short) inw(dev->iobase + PCI230_ADCDATA);
@@ -658,7 +658,7 @@ static short pci230_ai_read(comedi_device * dev)
 	return data;
 }
 
-static inline unsigned short pci230_ao_mangle_datum(comedi_device * dev,
+static inline unsigned short pci230_ao_mangle_datum(struct comedi_device * dev,
 	short datum)
 {
 	/* If a bipolar range was specified, mangle it (straight binary->twos
@@ -674,7 +674,7 @@ static inline unsigned short pci230_ao_mangle_datum(comedi_device * dev,
 	return (unsigned short)datum;
 }
 
-static inline void pci230_ao_write_nofifo(comedi_device * dev, short datum,
+static inline void pci230_ao_write_nofifo(struct comedi_device * dev, short datum,
 	unsigned int chan)
 {
 	/* Store unmangled datum to be read back later. */
@@ -685,7 +685,7 @@ static inline void pci230_ao_write_nofifo(comedi_device * dev, short datum,
 			? PCI230_DACOUT1 : PCI230_DACOUT2));
 }
 
-static inline void pci230_ao_write_fifo(comedi_device * dev, short datum,
+static inline void pci230_ao_write_fifo(struct comedi_device * dev, short datum,
 	unsigned int chan)
 {
 	/* Store unmangled datum to be read back later. */
@@ -702,7 +702,7 @@ static inline void pci230_ao_write_fifo(comedi_device * dev, short datum,
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pci230_attach(comedi_device * dev, comedi_devconfig * it)
+static int pci230_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	unsigned long iobase1, iobase2;
@@ -959,7 +959,7 @@ static int pci230_attach(comedi_device * dev, comedi_devconfig * it)
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int pci230_detach(comedi_device * dev)
+static int pci230_detach(struct comedi_device * dev)
 {
 	printk("comedi%d: amplc_pci230: remove\n", dev->minor);
 
@@ -982,7 +982,7 @@ static int pci230_detach(comedi_device * dev)
 	return 0;
 }
 
-static int get_resources(comedi_device * dev, unsigned int res_mask,
+static int get_resources(struct comedi_device * dev, unsigned int res_mask,
 	unsigned char owner)
 {
 	int ok;
@@ -1018,13 +1018,13 @@ static int get_resources(comedi_device * dev, unsigned int res_mask,
 	return ok;
 }
 
-static inline int get_one_resource(comedi_device * dev, unsigned int resource,
+static inline int get_one_resource(struct comedi_device * dev, unsigned int resource,
 	unsigned char owner)
 {
 	return get_resources(dev, (1U << resource), owner);
 }
 
-static void put_resources(comedi_device * dev, unsigned int res_mask,
+static void put_resources(struct comedi_device * dev, unsigned int res_mask,
 	unsigned char owner)
 {
 	unsigned int i;
@@ -1044,13 +1044,13 @@ static void put_resources(comedi_device * dev, unsigned int res_mask,
 	comedi_spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
 }
 
-static inline void put_one_resource(comedi_device * dev, unsigned int resource,
+static inline void put_one_resource(struct comedi_device * dev, unsigned int resource,
 	unsigned char owner)
 {
 	put_resources(dev, (1U << resource), owner);
 }
 
-static inline void put_all_resources(comedi_device * dev, unsigned char owner)
+static inline void put_all_resources(struct comedi_device * dev, unsigned char owner)
 {
 	put_resources(dev, (1U << NUM_RESOURCES) - 1, owner);
 }
@@ -1058,7 +1058,7 @@ static inline void put_all_resources(comedi_device * dev, unsigned char owner)
 /*
  *  COMEDI_SUBD_AI instruction;
  */
-static int pci230_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int n, i;
@@ -1163,7 +1163,7 @@ static int pci230_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 /*
  *  COMEDI_SUBD_AO instructions;
  */
-static int pci230_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -1191,7 +1191,7 @@ static int pci230_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int pci230_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -1203,7 +1203,7 @@ static int pci230_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return i;
 }
 
-static int pci230_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1416,7 +1416,7 @@ static int pci230_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int pci230_ao_inttrig_scan_begin(comedi_device * dev,
+static int pci230_ao_inttrig_scan_begin(struct comedi_device * dev,
 	comedi_subdevice * s, unsigned int trig_num)
 {
 	unsigned long irqflags;
@@ -1448,7 +1448,7 @@ static int pci230_ao_inttrig_scan_begin(comedi_device * dev,
 	return 1;
 }
 
-static void pci230_ao_start(comedi_device * dev, comedi_subdevice * s)
+static void pci230_ao_start(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -1536,7 +1536,7 @@ static void pci230_ao_start(comedi_device * dev, comedi_subdevice * s)
 	}
 }
 
-static int pci230_ao_inttrig_start(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ao_inttrig_start(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trig_num)
 {
 	if (trig_num != 0)
@@ -1548,7 +1548,7 @@ static int pci230_ao_inttrig_start(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int pci230_ao_cmd(comedi_device * dev, comedi_subdevice * s)
+static int pci230_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned short daccon;
 	unsigned int range;
@@ -1648,7 +1648,7 @@ static int pci230_ai_check_scan_period(comedi_cmd * cmd)
 	return !err;
 }
 
-static int pci230_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -2034,7 +2034,7 @@ static int pci230_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static void pci230_ai_update_fifo_trigger_level(comedi_device * dev,
+static void pci230_ai_update_fifo_trigger_level(struct comedi_device * dev,
 	comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
@@ -2078,7 +2078,7 @@ static void pci230_ai_update_fifo_trigger_level(comedi_device * dev,
 	}
 }
 
-static int pci230_ai_inttrig_convert(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ai_inttrig_convert(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trig_num)
 {
 	unsigned long irqflags;
@@ -2121,7 +2121,7 @@ static int pci230_ai_inttrig_convert(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int pci230_ai_inttrig_scan_begin(comedi_device * dev,
+static int pci230_ai_inttrig_scan_begin(struct comedi_device * dev,
 	comedi_subdevice * s, unsigned int trig_num)
 {
 	unsigned long irqflags;
@@ -2143,7 +2143,7 @@ static int pci230_ai_inttrig_scan_begin(comedi_device * dev,
 	return 1;
 }
 
-static void pci230_ai_start(comedi_device * dev, comedi_subdevice * s)
+static void pci230_ai_start(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long irqflags;
 	unsigned short conv;
@@ -2280,7 +2280,7 @@ static void pci230_ai_start(comedi_device * dev, comedi_subdevice * s)
 	}
 }
 
-static int pci230_ai_inttrig_start(comedi_device * dev, comedi_subdevice * s,
+static int pci230_ai_inttrig_start(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trig_num)
 {
 	if (trig_num != 0)
@@ -2292,7 +2292,7 @@ static int pci230_ai_inttrig_start(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int pci230_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int pci230_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned int i, chan, range, diff;
 	unsigned int res_mask;
@@ -2532,7 +2532,7 @@ static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round)
 	return;
 }
 
-static void pci230_ct_setup_ns_mode(comedi_device * dev, unsigned int ct,
+static void pci230_ct_setup_ns_mode(struct comedi_device * dev, unsigned int ct,
 	unsigned int mode, uint64_t ns, unsigned int round)
 {
 	unsigned int clk_src;
@@ -2551,7 +2551,7 @@ static void pci230_ct_setup_ns_mode(comedi_device * dev, unsigned int ct,
 	i8254_write(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, count);
 }
 
-static void pci230_cancel_ct(comedi_device * dev, unsigned int ct)
+static void pci230_cancel_ct(struct comedi_device * dev, unsigned int ct)
 {
 	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct,
 		I8254_MODE1);
@@ -2562,7 +2562,7 @@ static void pci230_cancel_ct(comedi_device * dev, unsigned int ct)
 static irqreturn_t pci230_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	unsigned char status_int, valid_status_int;
-	comedi_device *dev = (comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *) d;
 	comedi_subdevice *s;
 	unsigned long irqflags;
 
@@ -2622,7 +2622,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-static void pci230_handle_ao_nofifo(comedi_device * dev, comedi_subdevice * s)
+static void pci230_handle_ao_nofifo(struct comedi_device * dev, comedi_subdevice * s)
 {
 	short data;
 	int i, ret;
@@ -2659,7 +2659,7 @@ static void pci230_handle_ao_nofifo(comedi_device * dev, comedi_subdevice * s)
 
 /* Loads DAC FIFO (if using it) from buffer. */
 /* Returns 0 if AO finished due to completion or error, 1 if still going. */
-static int pci230_handle_ao_fifo(comedi_device * dev, comedi_subdevice * s)
+static int pci230_handle_ao_fifo(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -2762,7 +2762,7 @@ static int pci230_handle_ao_fifo(comedi_device * dev, comedi_subdevice * s)
 	return running;
 }
 
-static void pci230_handle_ai(comedi_device * dev, comedi_subdevice * s)
+static void pci230_handle_ai(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned int events = 0;
 	unsigned int status_fifo;
@@ -2861,7 +2861,7 @@ static void pci230_handle_ai(comedi_device * dev, comedi_subdevice * s)
 	}
 }
 
-static void pci230_ao_stop(comedi_device * dev, comedi_subdevice * s)
+static void pci230_ao_stop(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long irqflags;
 	unsigned char intsrc;
@@ -2916,13 +2916,13 @@ static void pci230_ao_stop(comedi_device * dev, comedi_subdevice * s)
 	put_all_resources(dev, OWNER_AOCMD);
 }
 
-static int pci230_ao_cancel(comedi_device * dev, comedi_subdevice * s)
+static int pci230_ao_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	pci230_ao_stop(dev, s);
 	return 0;
 }
 
-static void pci230_ai_stop(comedi_device * dev, comedi_subdevice * s)
+static void pci230_ai_stop(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long irqflags;
 	comedi_cmd *cmd;
@@ -2970,7 +2970,7 @@ static void pci230_ai_stop(comedi_device * dev, comedi_subdevice * s)
 	put_all_resources(dev, OWNER_AICMD);
 }
 
-static int pci230_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int pci230_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	pci230_ai_stop(dev, s);
 	return 0;

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
index 39482742401e..4463e9803e08 100644
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -524,7 +524,7 @@ struct pci230_private {
 	spinlock_t ao_stop_spinlock;	/* Spin lock for stopping AO command */
 	unsigned long state;	/* State flags */
 	unsigned long iobase1;	/* PCI230's I/O space 1 */
-	lsampl_t ao_readback[2];	/* Used for AO readback */
+	unsigned int ao_readback[2];	/* Used for AO readback */
 	unsigned int ai_scan_count;	/* Number of analogue input scans
 					 * remaining.  */
 	unsigned int ai_scan_pos;	/* Current position within analogue
@@ -616,11 +616,11 @@ static comedi_driver driver_amplc_pci230 = {
 COMEDI_PCI_INITCLEANUP(driver_amplc_pci230, pci230_pci_table);
 
 static int pci230_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int pci230_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int pci230_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static void pci230_ct_setup_ns_mode(comedi_device * dev, unsigned int ct,
 	unsigned int mode, uint64_t ns, unsigned int round);
 static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round);
@@ -640,10 +640,10 @@ static int pci230_ai_cancel(comedi_device * dev, comedi_subdevice * s);
 static void pci230_ai_stop(comedi_device * dev, comedi_subdevice * s);
 static void pci230_handle_ai(comedi_device * dev, comedi_subdevice * s);
 
-static sampl_t pci230_ai_read(comedi_device * dev)
+static short pci230_ai_read(comedi_device * dev)
 {
 	/* Read sample. */
-	sampl_t data = (sampl_t) inw(dev->iobase + PCI230_ADCDATA);
+	short data = (short) inw(dev->iobase + PCI230_ADCDATA);
 
 	/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
 	 * four bits reserved for expansion). */
@@ -659,7 +659,7 @@ static sampl_t pci230_ai_read(comedi_device * dev)
 }
 
 static inline unsigned short pci230_ao_mangle_datum(comedi_device * dev,
-	sampl_t datum)
+	short datum)
 {
 	/* If a bipolar range was specified, mangle it (straight binary->twos
 	 * complement). */
@@ -674,7 +674,7 @@ static inline unsigned short pci230_ao_mangle_datum(comedi_device * dev,
 	return (unsigned short)datum;
 }
 
-static inline void pci230_ao_write_nofifo(comedi_device * dev, sampl_t datum,
+static inline void pci230_ao_write_nofifo(comedi_device * dev, short datum,
 	unsigned int chan)
 {
 	/* Store unmangled datum to be read back later. */
@@ -685,7 +685,7 @@ static inline void pci230_ao_write_nofifo(comedi_device * dev, sampl_t datum,
 			? PCI230_DACOUT1 : PCI230_DACOUT2));
 }
 
-static inline void pci230_ao_write_fifo(comedi_device * dev, sampl_t datum,
+static inline void pci230_ao_write_fifo(comedi_device * dev, short datum,
 	unsigned int chan)
 {
 	/* Store unmangled datum to be read back later. */
@@ -1059,7 +1059,7 @@ static inline void put_all_resources(comedi_device * dev, unsigned char owner)
  *  COMEDI_SUBD_AI instruction;
  */
 static int pci230_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int n, i;
 	unsigned int chan, range, aref;
@@ -1164,7 +1164,7 @@ static int pci230_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
  *  COMEDI_SUBD_AO instructions;
  */
 static int pci230_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan, range;
@@ -1192,7 +1192,7 @@ static int pci230_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
 static int pci230_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -2624,7 +2624,7 @@ static irqreturn_t pci230_interrupt(int irq, void *d PT_REGS_ARG)
 
 static void pci230_handle_ao_nofifo(comedi_device * dev, comedi_subdevice * s)
 {
-	sampl_t data;
+	short data;
 	int i, ret;
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -2675,7 +2675,7 @@ static int pci230_handle_ao_fifo(comedi_device * dev, comedi_subdevice * s)
 	dacstat = inw(dev->iobase + PCI230_DACCON);
 
 	/* Determine number of scans available in buffer. */
-	bytes_per_scan = cmd->chanlist_len * sizeof(sampl_t);
+	bytes_per_scan = cmd->chanlist_len * sizeof(short);
 	num_scans = comedi_buf_read_n_available(async) / bytes_per_scan;
 	if (!devpriv->ao_continuous) {
 		/* Fixed number of scans. */
@@ -2722,7 +2722,7 @@ static int pci230_handle_ao_fifo(comedi_device * dev, comedi_subdevice * s)
 		/* Process scans. */
 		for (n = 0; n < num_scans; n++) {
 			for (i = 0; i < cmd->chanlist_len; i++) {
-				sampl_t datum;
+				short datum;
 
 				comedi_buf_get(async, &datum);
 				pci230_ao_write_fifo(dev, datum,

commit 70a350c348c0bcd036691dee8482c30630d84f8f
Author: Allan Willcox <allanwillcox@ozemail.com.au>
Date:   Wed Feb 18 15:27:06 2009 -0800

    Staging: comedi: add amplc_pci230 driver
    
    Driver for Amplicon PCI230 and PCI260 Multifunction I/O boards
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Steve D Sharples <steve.sharples@nottingham.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci230.c b/drivers/staging/comedi/drivers/amplc_pci230.c
new file mode 100644
index 000000000000..39482742401e
--- /dev/null
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -0,0 +1,2977 @@
+ /*
+    comedi/drivers/amplc_pci230.c
+    Driver for Amplicon PCI230 and PCI260 Multifunction I/O boards.
+
+    Copyright (C) 2001 Allan Willcox <allanwillcox@ozemail.com.au>
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+/*
+Driver: amplc_pci230
+Description: Amplicon PCI230, PCI260 Multifunction I/O boards
+Author: Allan Willcox <allanwillcox@ozemail.com.au>,
+  Steve D Sharples <steve.sharples@nottingham.ac.uk>,
+  Ian Abbott <abbotti@mev.co.uk>
+Updated: Wed, 22 Oct 2008 12:34:49 +0100
+Devices: [Amplicon] PCI230 (pci230 or amplc_pci230),
+  PCI230+ (pci230+ or amplc_pci230),
+  PCI260 (pci260 or amplc_pci230), PCI260+ (pci260+ or amplc_pci230)
+Status: works
+
+Configuration options:
+  [0] - PCI bus of device (optional).
+  [1] - PCI slot of device (optional).
+          If bus/slot is not specified, the first available PCI device
+          will be used.
+
+Configuring a "amplc_pci230" will match any supported card and it will
+choose the best match, picking the "+" models if possible.  Configuring
+a "pci230" will match a PCI230 or PCI230+ card and it will be treated as
+a PCI230.  Configuring a "pci260" will match a PCI260 or PCI260+ card
+and it will be treated as a PCI260.  Configuring a "pci230+" will match
+a PCI230+ card.  Configuring a "pci260+" will match a PCI260+ card.
+
+Subdevices:
+
+                PCI230(+)    PCI260(+)
+                ---------    ---------
+  Subdevices       3            1
+        0          AI           AI
+	1          AO
+	2          DIO
+
+AI Subdevice:
+
+  The AI subdevice has 16 single-ended channels or 8 differential
+  channels.
+
+  The PCI230 and PCI260 cards have 12-bit resolution.  The PCI230+ and
+  PCI260+ cards have 16-bit resolution.
+
+  For differential mode, use inputs 2N and 2N+1 for channel N (e.g. use
+  inputs 14 and 15 for channel 7).  If the card is physically a PCI230
+  or PCI260 then it actually uses a "pseudo-differential" mode where the
+  inputs are sampled a few microseconds apart.  The PCI230+ and PCI260+
+  use true differential sampling.  Another difference is that if the
+  card is physically a PCI230 or PCI260, the inverting input is 2N,
+  whereas for a PCI230+ or PCI260+ the inverting input is 2N+1.  So if a
+  PCI230 is physically replaced by a PCI230+ (or a PCI260 with a
+  PCI260+) and differential mode is used, the differential inputs need
+  to be physically swapped on the connector.
+
+  The following input ranges are supported:
+
+    0 => [-10, +10] V
+    1 => [-5, +5] V
+    2 => [-2.5, +2.5] V
+    3 => [-1.25, +1.25] V
+    4 => [0, 10] V
+    5 => [0, 5] V
+    6 => [0, 2.5] V
+
+AI Commands:
+
+  +=========+==============+===========+============+==========+
+  |start_src|scan_begin_src|convert_src|scan_end_src| stop_src |
+  +=========+==============+===========+============+==========+
+  |TRIG_NOW | TRIG_FOLLOW  |TRIG_TIMER | TRIG_COUNT |TRIG_NONE |
+  |TRIG_INT |              |TRIG_EXT(3)|            |TRIG_COUNT|
+  |         |              |TRIG_INT   |            |          |
+  |         |--------------|-----------|            |          |
+  |         | TRIG_TIMER(1)|TRIG_TIMER |            |          |
+  |         | TRIG_EXT(2)  |           |            |          |
+  |         | TRIG_INT     |           |            |          |
+  +---------+--------------+-----------+------------+----------+
+
+  Note 1: If AI command and AO command are used simultaneously, only
+          one may have scan_begin_src == TRIG_TIMER.
+
+  Note 2: For PCI230 and PCI230+, scan_begin_src == TRIG_EXT uses
+          DIO channel 16 (pin 49) which will need to be configured as
+          a digital input.  For PCI260+, the EXTTRIG/EXTCONVCLK input
+          (pin 17) is used instead.  For PCI230, scan_begin_src ==
+          TRIG_EXT is not supported.  The trigger is a rising edge
+          on the input.
+
+  Note 3: For convert_src == TRIG_EXT, the EXTTRIG/EXTCONVCLK input
+          (pin 25 on PCI230(+), pin 17 on PCI260(+)) is used.  The
+          convert_arg value is interpreted as follows:
+
+            convert_arg == (CR_EDGE | 0) => rising edge
+            convert_arg == (CR_EDGE | CR_INVERT | 0) => falling edge
+            convert_arg == 0 => falling edge (backwards compatibility)
+            convert_arg == 1 => rising edge (backwards compatibility)
+
+  All entries in the channel list must use the same analogue reference.
+  If the analogue reference is not AREF_DIFF (not differential) each
+  pair of channel numbers (0 and 1, 2 and 3, etc.) must use the same
+  input range.  The input ranges used in the sequence must be all
+  bipolar (ranges 0 to 3) or all unipolar (ranges 4 to 6).  The channel
+  sequence must consist of 1 or more identical subsequences.  Within the
+  subsequence, channels must be in ascending order with no repeated
+  channels.  For example, the following sequences are valid: 0 1 2 3
+  (single valid subsequence), 0 2 3 5 0 2 3 5 (repeated valid
+  subsequence), 1 1 1 1 (repeated valid subsequence).  The following
+  sequences are invalid: 0 3 2 1 (invalid subsequence), 0 2 3 5 0 2 3
+  (incompletely repeated subsequence).  Some versions of the PCI230+ and
+  PCI260+ have a bug that requires a subsequence longer than one entry
+  long to include channel 0.
+
+AO Subdevice:
+
+  The AO subdevice has 2 channels with 12-bit resolution.
+
+  The following output ranges are supported:
+
+    0 => [0, 10] V
+    1 => [-10, +10] V
+
+AO Commands:
+
+  +=========+==============+===========+============+==========+
+  |start_src|scan_begin_src|convert_src|scan_end_src| stop_src |
+  +=========+==============+===========+============+==========+
+  |TRIG_INT | TRIG_TIMER(1)| TRIG_NOW  | TRIG_COUNT |TRIG_NONE |
+  |         | TRIG_EXT(2)  |           |            |TRIG_COUNT|
+  |         | TRIG_INT     |           |            |          |
+  +---------+--------------+-----------+------------+----------+
+
+  Note 1: If AI command and AO command are used simultaneously, only
+          one may have scan_begin_src == TRIG_TIMER.
+
+  Note 2: scan_begin_src == TRIG_EXT is only supported if the card is
+          configured as a PCI230+ and is only supported on later
+          versions of the card.  As a card configured as a PCI230+ is
+          not guaranteed to support external triggering, please consider
+          this support to be a bonus.  It uses the EXTTRIG/ EXTCONVCLK
+          input (PCI230+ pin 25).  Triggering will be on the rising edge
+          unless the CR_INVERT flag is set in scan_begin_arg.
+
+  The channels in the channel sequence must be in ascending order with
+  no repeats.  All entries in the channel sequence must use the same
+  output range.
+
+DIO Subdevice:
+
+  The DIO subdevice is a 8255 chip providing 24 DIO channels.  The DIO
+  channels are configurable as inputs or outputs in four groups:
+
+    Port A  - channels  0 to  7
+    Port B  - channels  8 to 15
+    Port CL - channels 16 to 19
+    Port CH - channels 20 to 23
+
+  Only mode 0 of the 8255 chip is supported.
+
+  Bit 0 of port C (DIO channel 16) is also used as an external scan
+  trigger input for AI commands on PCI230 and PCI230+, so would need to
+  be configured as an input to use it for that purpose.
+*/
+/*
+Extra triggered scan functionality, interrupt bug-fix added by Steve Sharples.
+Support for PCI230+/260+, more triggered scan functionality, and workarounds
+for (or detection of) various hardware problems added by Ian Abbott.
+*/
+#include "../comedidev.h"
+
+#include <linux/delay.h>
+
+#include "comedi_pci.h"
+#include "8253.h"
+#include "8255.h"
+
+/* PCI230 PCI configuration register information */
+#define PCI_VENDOR_ID_AMPLICON 0x14dc
+#define PCI_DEVICE_ID_PCI230 0x0000
+#define PCI_DEVICE_ID_PCI260 0x0006
+#define PCI_DEVICE_ID_INVALID 0xffff
+
+#define PCI230_IO1_SIZE 32	/* Size of I/O space 1 */
+#define PCI230_IO2_SIZE 16	/* Size of I/O space 2 */
+
+/* PCI230 i/o space 1 registers. */
+#define PCI230_PPI_X_BASE	0x00	/* User PPI (82C55) base */
+#define PCI230_PPI_X_A		0x00	/* User PPI (82C55) port A */
+#define PCI230_PPI_X_B		0x01	/* User PPI (82C55) port B */
+#define PCI230_PPI_X_C		0x02	/* User PPI (82C55) port C */
+#define PCI230_PPI_X_CMD	0x03	/* User PPI (82C55) control word */
+#define PCI230_Z2_CT_BASE	0x14	/* 82C54 counter/timer base */
+#define PCI230_Z2_CT0		0x14	/* 82C54 counter/timer 0 */
+#define PCI230_Z2_CT1		0x15	/* 82C54 counter/timer 1 */
+#define PCI230_Z2_CT2		0x16	/* 82C54 counter/timer 2 */
+#define PCI230_Z2_CTC		0x17	/* 82C54 counter/timer control word */
+#define PCI230_ZCLK_SCE		0x1A	/* Group Z Clock Configuration */
+#define PCI230_ZGAT_SCE		0x1D	/* Group Z Gate Configuration */
+#define PCI230_INT_SCE		0x1E	/* Interrupt source mask (w) */
+#define PCI230_INT_STAT		0x1E	/* Interrupt status (r) */
+
+/* PCI230 i/o space 2 registers. */
+#define PCI230_DACCON		0x00	/* DAC control */
+#define PCI230_DACOUT1		0x02	/* DAC channel 0 (w) */
+#define PCI230_DACOUT2		0x04	/* DAC channel 1 (w) (not FIFO mode) */
+#define PCI230_ADCDATA		0x08	/* ADC data (r) */
+#define PCI230_ADCSWTRIG	0x08	/* ADC software trigger (w) */
+#define PCI230_ADCCON		0x0A	/* ADC control */
+#define PCI230_ADCEN		0x0C	/* ADC channel enable bits */
+#define PCI230_ADCG		0x0E	/* ADC gain control bits */
+/* PCI230+ i/o space 2 additional registers. */
+#define PCI230P_ADCTRIG		0x10	/* ADC start acquisition trigger */
+#define PCI230P_ADCTH		0x12	/* ADC analog trigger threshold */
+#define PCI230P_ADCFFTH		0x14	/* ADC FIFO interrupt threshold */
+#define PCI230P_ADCFFLEV	0x16	/* ADC FIFO level (r) */
+#define PCI230P_ADCPTSC		0x18	/* ADC pre-trigger sample count (r) */
+#define PCI230P_ADCHYST		0x1A	/* ADC analog trigger hysteresys */
+#define PCI230P_EXTFUNC		0x1C	/* Extended functions */
+#define PCI230P_HWVER		0x1E	/* Hardware version (r) */
+/* PCI230+ hardware version 2 onwards. */
+#define PCI230P2_DACDATA	0x02	/* DAC data (FIFO mode) (w) */
+#define PCI230P2_DACSWTRIG	0x02	/* DAC soft trigger (FIFO mode) (r) */
+#define PCI230P2_DACEN		0x06	/* DAC channel enable (FIFO mode) */
+
+/* Convertor related constants. */
+#define PCI230_DAC_SETTLE 5	/* Analogue output settling time in s */
+				/* (DAC itself is 1s nominally). */
+#define PCI230_ADC_SETTLE 1	/* Analogue input settling time in s */
+				/* (ADC itself is 1.6s nominally but we poll
+				 * anyway). */
+#define PCI230_MUX_SETTLE 10	/* ADC MUX settling time in S */
+				/* - 10s for se, 20s de. */
+
+/* DACCON read-write values. */
+#define PCI230_DAC_OR_UNI		(0<<0)	/* Output range unipolar */
+#define PCI230_DAC_OR_BIP		(1<<0)	/* Output range bipolar */
+#define PCI230_DAC_OR_MASK		(1<<0)
+/* The following applies only if DAC FIFO support is enabled in the EXTFUNC
+ * register (and only for PCI230+ hardware version 2 onwards). */
+#define PCI230P2_DAC_FIFO_EN		(1<<8)	/* FIFO enable */
+/* The following apply only if the DAC FIFO is enabled (and only for PCI230+
+ * hardware version 2 onwards). */
+#define PCI230P2_DAC_TRIG_NONE		(0<<2)	/* No trigger */
+#define PCI230P2_DAC_TRIG_SW		(1<<2)	/* Software trigger trigger */
+#define PCI230P2_DAC_TRIG_EXTP		(2<<2)	/* EXTTRIG +ve edge trigger */
+#define PCI230P2_DAC_TRIG_EXTN		(3<<2)	/* EXTTRIG -ve edge trigger */
+#define PCI230P2_DAC_TRIG_Z2CT0		(4<<2)	/* CT0-OUT +ve edge trigger */
+#define PCI230P2_DAC_TRIG_Z2CT1		(5<<2)	/* CT1-OUT +ve edge trigger */
+#define PCI230P2_DAC_TRIG_Z2CT2		(6<<2)	/* CT2-OUT +ve edge trigger */
+#define PCI230P2_DAC_TRIG_MASK		(7<<2)
+#define PCI230P2_DAC_FIFO_WRAP		(1<<7)	/* FIFO wraparound mode */
+#define PCI230P2_DAC_INT_FIFO_EMPTY	(0<<9)	/* FIFO interrupt empty */
+#define PCI230P2_DAC_INT_FIFO_NEMPTY	(1<<9)
+#define PCI230P2_DAC_INT_FIFO_NHALF	(2<<9)	/* FIFO intr not half full */
+#define PCI230P2_DAC_INT_FIFO_HALF	(3<<9)
+#define PCI230P2_DAC_INT_FIFO_NFULL	(4<<9)	/* FIFO interrupt not full */
+#define PCI230P2_DAC_INT_FIFO_FULL	(5<<9)
+#define PCI230P2_DAC_INT_FIFO_MASK	(7<<9)
+
+/* DACCON read-only values. */
+#define PCI230_DAC_BUSY			(1<<1)	/* DAC busy. */
+/* The following apply only if the DAC FIFO is enabled (and only for PCI230+
+ * hardware version 2 onwards). */
+#define PCI230P2_DAC_FIFO_UNDERRUN_LATCHED	(1<<5)	/* Underrun error */
+#define PCI230P2_DAC_FIFO_EMPTY		(1<<13)	/* FIFO empty */
+#define PCI230P2_DAC_FIFO_FULL		(1<<14)	/* FIFO full */
+#define PCI230P2_DAC_FIFO_HALF		(1<<15)	/* FIFO half full */
+
+/* DACCON write-only, transient values. */
+/* The following apply only if the DAC FIFO is enabled (and only for PCI230+
+ * hardware version 2 onwards). */
+#define PCI230P2_DAC_FIFO_UNDERRUN_CLEAR	(1<<5)	/* Clear underrun */
+#define PCI230P2_DAC_FIFO_RESET		(1<<12)	/* FIFO reset */
+
+/* PCI230+ hardware version 2 DAC FIFO levels. */
+#define PCI230P2_DAC_FIFOLEVEL_HALF	512
+#define PCI230P2_DAC_FIFOLEVEL_FULL	1024
+/* Free space in DAC FIFO. */
+#define PCI230P2_DAC_FIFOROOM_EMPTY		PCI230P2_DAC_FIFOLEVEL_FULL
+#define PCI230P2_DAC_FIFOROOM_ONETOHALF		\
+	(PCI230P2_DAC_FIFOLEVEL_FULL - PCI230P2_DAC_FIFOLEVEL_HALF)
+#define PCI230P2_DAC_FIFOROOM_HALFTOFULL	1
+#define PCI230P2_DAC_FIFOROOM_FULL		0
+
+/* ADCCON read/write values. */
+#define PCI230_ADC_TRIG_NONE		(0<<0)	/* No trigger */
+#define PCI230_ADC_TRIG_SW		(1<<0)	/* Software trigger trigger */
+#define PCI230_ADC_TRIG_EXTP		(2<<0)	/* EXTTRIG +ve edge trigger */
+#define PCI230_ADC_TRIG_EXTN		(3<<0)	/* EXTTRIG -ve edge trigger */
+#define PCI230_ADC_TRIG_Z2CT0		(4<<0)	/* CT0-OUT +ve edge trigger */
+#define PCI230_ADC_TRIG_Z2CT1		(5<<0)	/* CT1-OUT +ve edge trigger */
+#define PCI230_ADC_TRIG_Z2CT2		(6<<0)	/* CT2-OUT +ve edge trigger */
+#define PCI230_ADC_TRIG_MASK		(7<<0)
+#define PCI230_ADC_IR_UNI		(0<<3)	/* Input range unipolar */
+#define PCI230_ADC_IR_BIP		(1<<3)	/* Input range bipolar */
+#define PCI230_ADC_IR_MASK		(1<<3)
+#define PCI230_ADC_IM_SE		(0<<4)	/* Input mode single ended */
+#define PCI230_ADC_IM_DIF		(1<<4)	/* Input mode differential */
+#define PCI230_ADC_IM_MASK		(1<<4)
+#define PCI230_ADC_FIFO_EN		(1<<8)	/* FIFO enable */
+#define PCI230_ADC_INT_FIFO_EMPTY	(0<<9)
+#define PCI230_ADC_INT_FIFO_NEMPTY	(1<<9)	/* FIFO interrupt not empty */
+#define PCI230_ADC_INT_FIFO_NHALF	(2<<9)
+#define PCI230_ADC_INT_FIFO_HALF	(3<<9)	/* FIFO interrupt half full */
+#define PCI230_ADC_INT_FIFO_NFULL	(4<<9)
+#define PCI230_ADC_INT_FIFO_FULL	(5<<9)	/* FIFO interrupt full */
+#define PCI230P_ADC_INT_FIFO_THRESH	(7<<9)	/* FIFO interrupt threshold */
+#define PCI230_ADC_INT_FIFO_MASK	(7<<9)
+
+/* ADCCON write-only, transient values. */
+#define PCI230_ADC_FIFO_RESET		(1<<12)	/* FIFO reset */
+#define PCI230_ADC_GLOB_RESET		(1<<13)	/* Global reset */
+
+/* ADCCON read-only values. */
+#define PCI230_ADC_BUSY			(1<<15)	/* ADC busy */
+#define PCI230_ADC_FIFO_EMPTY		(1<<12)	/* FIFO empty */
+#define PCI230_ADC_FIFO_FULL		(1<<13)	/* FIFO full */
+#define PCI230_ADC_FIFO_HALF		(1<<14)	/* FIFO half full */
+#define PCI230_ADC_FIFO_FULL_LATCHED	(1<<5)	/* Indicates overrun occurred */
+
+/* PCI230 ADC FIFO levels. */
+#define PCI230_ADC_FIFOLEVEL_HALFFULL	2049	/* Value for FIFO half full */
+#define PCI230_ADC_FIFOLEVEL_FULL	4096	/* FIFO size */
+
+/* Value to write to ADCSWTRIG to trigger ADC conversion in software trigger
+ * mode.  Can be anything.  */
+#define PCI230_ADC_CONV			0xffff
+
+/* PCI230+ EXTFUNC values. */
+#define PCI230P_EXTFUNC_GAT_EXTTRIG	(1<<0)
+			/* Route EXTTRIG pin to external gate inputs. */
+/* PCI230+ hardware version 2 values. */
+#define PCI230P2_EXTFUNC_DACFIFO	(1<<1)
+			/* Allow DAC FIFO to be enabled. */
+
+/*
+ * Counter/timer clock input configuration sources.
+ */
+#define CLK_CLK		0	/* reserved (channel-specific clock) */
+#define CLK_10MHZ	1	/* internal 10 MHz clock */
+#define CLK_1MHZ	2	/* internal 1 MHz clock */
+#define CLK_100KHZ	3	/* internal 100 kHz clock */
+#define CLK_10KHZ	4	/* internal 10 kHz clock */
+#define CLK_1KHZ	5	/* internal 1 kHz clock */
+#define CLK_OUTNM1	6	/* output of channel-1 modulo total */
+#define CLK_EXT		7	/* external clock */
+/* Macro to construct clock input configuration register value. */
+#define CLK_CONFIG(chan, src)	((((chan) & 3) << 3) | ((src) & 7))
+/* Timebases in ns. */
+#define TIMEBASE_10MHZ		100
+#define TIMEBASE_1MHZ		1000
+#define TIMEBASE_100KHZ		10000
+#define TIMEBASE_10KHZ		100000
+#define TIMEBASE_1KHZ		1000000
+
+/*
+ * Counter/timer gate input configuration sources.
+ */
+#define GAT_VCC		0	/* VCC (i.e. enabled) */
+#define GAT_GND		1	/* GND (i.e. disabled) */
+#define GAT_EXT		2	/* external gate input (PPCn on PCI230) */
+#define GAT_NOUTNM2	3	/* inverted output of channel-2 modulo total */
+/* Macro to construct gate input configuration register value. */
+#define GAT_CONFIG(chan, src)	((((chan) & 3) << 3) | ((src) & 7))
+
+/*
+ * Summary of CLK_OUTNM1 and GAT_NOUTNM2 connections for PCI230 and PCI260:
+ *
+ *              Channel's       Channel's
+ *              clock input     gate input
+ * Channel      CLK_OUTNM1      GAT_NOUTNM2
+ * -------      ----------      -----------
+ * Z2-CT0       Z2-CT2-OUT      /Z2-CT1-OUT
+ * Z2-CT1       Z2-CT0-OUT      /Z2-CT2-OUT
+ * Z2-CT2       Z2-CT1-OUT      /Z2-CT0-OUT
+ */
+
+/* Interrupt enables/status register values. */
+#define PCI230_INT_DISABLE		0
+#define PCI230_INT_PPI_C0		(1<<0)
+#define PCI230_INT_PPI_C3		(1<<1)
+#define PCI230_INT_ADC			(1<<2)
+#define PCI230_INT_ZCLK_CT1		(1<<5)
+/* For PCI230+ hardware version 2 when DAC FIFO enabled. */
+#define PCI230P2_INT_DAC		(1<<4)
+
+#define PCI230_TEST_BIT(val, n)	((val>>n)&1)
+			/* Assumes bits numbered with zero offset, ie. 0-15 */
+
+/* (Potentially) shared resources and their owners */
+enum {
+	RES_Z2CT0,		/* Z2-CT0 */
+	RES_Z2CT1,		/* Z2-CT1 */
+	RES_Z2CT2,		/* Z2-CT2 */
+	NUM_RESOURCES		/* Number of (potentially) shared resources. */
+};
+
+enum {
+	OWNER_NONE,		/* Not owned */
+	OWNER_AICMD,		/* Owned by AI command */
+	OWNER_AOCMD		/* Owned by AO command */
+};
+
+/*
+ * Handy macros.
+ */
+
+/* Combine old and new bits. */
+#define COMBINE(old, new, mask)	(((old) & ~(mask)) | ((new) & (mask)))
+
+/* A generic null function pointer value.  */
+#define NULLFUNC	0
+
+/* Current CPU.  XXX should this be hard_smp_processor_id()? */
+#define THISCPU		smp_processor_id()
+
+/* State flags for atomic bit operations */
+#define AI_CMD_STARTED	0
+#define AO_CMD_STARTED	1
+
+/*
+ * Board descriptions for the two boards supported.
+ */
+
+typedef struct pci230_board_struct {
+	const char *name;
+	unsigned short id;
+	int ai_chans;
+	int ai_bits;
+	int ao_chans;
+	int ao_bits;
+	int have_dio;
+	unsigned int min_hwver;	/* Minimum hardware version supported. */
+} pci230_board;
+static const pci230_board pci230_boards[] = {
+	{
+	      name:	"pci230+",
+	      id:	PCI_DEVICE_ID_PCI230,
+	      ai_chans:16,
+	      ai_bits:	16,
+	      ao_chans:2,
+	      ao_bits:	12,
+	      have_dio:1,
+	      min_hwver:1,
+		},
+	{
+	      name:	"pci260+",
+	      id:	PCI_DEVICE_ID_PCI260,
+	      ai_chans:16,
+	      ai_bits:	16,
+	      ao_chans:0,
+	      ao_bits:	0,
+	      have_dio:0,
+	      min_hwver:1,
+		},
+	{
+	      name:	"pci230",
+	      id:	PCI_DEVICE_ID_PCI230,
+	      ai_chans:16,
+	      ai_bits:	12,
+	      ao_chans:2,
+	      ao_bits:	12,
+	      have_dio:1,
+		},
+	{
+	      name:	"pci260",
+	      id:	PCI_DEVICE_ID_PCI260,
+	      ai_chans:16,
+	      ai_bits:	12,
+	      ao_chans:0,
+	      ao_bits:	0,
+	      have_dio:0,
+		},
+	{
+	      name:	"amplc_pci230",	/* Wildcard matches any above */
+	      id:	PCI_DEVICE_ID_INVALID,
+		},
+};
+
+static DEFINE_PCI_DEVICE_TABLE(pci230_pci_table) = {
+	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI230, PCI_ANY_ID, PCI_ANY_ID,
+		0, 0, 0},
+	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI260, PCI_ANY_ID, PCI_ANY_ID,
+		0, 0, 0},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, pci230_pci_table);
+/*
+ * Useful for shorthand access to the particular board structure
+ */
+#define n_pci230_boards (sizeof(pci230_boards)/sizeof(pci230_boards[0]))
+#define thisboard ((const pci230_board *)dev->board_ptr)
+
+/* this structure is for data unique to this hardware driver.  If
+   several hardware drivers keep similar information in this structure,
+   feel free to suggest moving the variable to the comedi_device struct.  */
+struct pci230_private {
+	struct pci_dev *pci_dev;
+	spinlock_t isr_spinlock;	/* Interrupt spin lock */
+	spinlock_t res_spinlock;	/* Shared resources spin lock */
+	spinlock_t ai_stop_spinlock;	/* Spin lock for stopping AI command */
+	spinlock_t ao_stop_spinlock;	/* Spin lock for stopping AO command */
+	unsigned long state;	/* State flags */
+	unsigned long iobase1;	/* PCI230's I/O space 1 */
+	lsampl_t ao_readback[2];	/* Used for AO readback */
+	unsigned int ai_scan_count;	/* Number of analogue input scans
+					 * remaining.  */
+	unsigned int ai_scan_pos;	/* Current position within analogue
+					 * input scan */
+	unsigned int ao_scan_count;	/* Number of analogue output scans
+					 * remaining.  */
+	int intr_cpuid;		/* ID of CPU running interrupt routine. */
+	unsigned short hwver;	/* Hardware version (for '+' models). */
+	unsigned short adccon;	/* ADCCON register value. */
+	unsigned short daccon;	/* DACCON register value. */
+	unsigned short adcfifothresh;	/* ADC FIFO programmable interrupt
+					 * level threshold (PCI230+/260+). */
+	unsigned short adcg;	/* ADCG register value. */
+	unsigned char int_en;	/* Interrupt enables bits. */
+	unsigned char ai_continuous;	/* Flag set when cmd->stop_src ==
+					 * TRIG_NONE - user chooses to stop
+					 * continuous conversion by
+					 * cancelation. */
+	unsigned char ao_continuous;	/* Flag set when cmd->stop_src ==
+					 * TRIG_NONE - user chooses to stop
+					 * continuous conversion by
+					 * cancelation. */
+	unsigned char ai_bipolar;	/* Set if bipolar input range so we
+					 * know to mangle it. */
+	unsigned char ao_bipolar;	/* Set if bipolar output range so we
+					 * know to mangle it. */
+	unsigned char ier;	/* Copy of interrupt enables/status register. */
+	unsigned char intr_running;	/* Flag set in interrupt routine. */
+	unsigned char res_owner[NUM_RESOURCES];	/* Shared resource owners. */
+};
+
+#define devpriv ((struct pci230_private *)dev->private)
+
+/* PCI230 clock source periods in ns */
+static const unsigned int pci230_timebase[8] = {
+	[CLK_10MHZ] = TIMEBASE_10MHZ,
+	[CLK_1MHZ] = TIMEBASE_1MHZ,
+	[CLK_100KHZ] = TIMEBASE_100KHZ,
+	[CLK_10KHZ] = TIMEBASE_10KHZ,
+	[CLK_1KHZ] = TIMEBASE_1KHZ,
+};
+
+/* PCI230 analogue input range table */
+static const comedi_lrange pci230_ai_range = { 7, {
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2.5)
+	}
+};
+
+/* PCI230 analogue gain bits for each input range. */
+static const unsigned char pci230_ai_gain[7] = { 0, 1, 2, 3, 1, 2, 3 };
+
+/* PCI230 adccon bipolar flag for each analogue input range. */
+static const unsigned char pci230_ai_bipolar[7] = { 1, 1, 1, 1, 0, 0, 0 };
+
+/* PCI230 analogue output range table */
+static const comedi_lrange pci230_ao_range = { 2, {
+			UNI_RANGE(10),
+			BIP_RANGE(10)
+	}
+};
+
+/* PCI230 daccon bipolar flag for each analogue output range. */
+static const unsigned char pci230_ao_bipolar[2] = { 0, 1 };
+
+/*
+ * The comedi_driver structure tells the Comedi core module
+ * which functions to call to configure/deconfigure (attach/detach)
+ * the board, and also about the kernel module that contains
+ * the device code.
+ */
+static int pci230_attach(comedi_device * dev, comedi_devconfig * it);
+static int pci230_detach(comedi_device * dev);
+static comedi_driver driver_amplc_pci230 = {
+      driver_name:"amplc_pci230",
+      module:THIS_MODULE,
+      attach:pci230_attach,
+      detach:pci230_detach,
+      board_name:&pci230_boards[0].name,
+      offset:sizeof(pci230_boards[0]),
+      num_names:sizeof(pci230_boards) / sizeof(pci230_boards[0]),
+};
+
+COMEDI_PCI_INITCLEANUP(driver_amplc_pci230, pci230_pci_table);
+
+static int pci230_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int pci230_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int pci230_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static void pci230_ct_setup_ns_mode(comedi_device * dev, unsigned int ct,
+	unsigned int mode, uint64_t ns, unsigned int round);
+static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round);
+static void pci230_cancel_ct(comedi_device * dev, unsigned int ct);
+static irqreturn_t pci230_interrupt(int irq, void *d PT_REGS_ARG);
+static int pci230_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int pci230_ao_cmd(comedi_device * dev, comedi_subdevice * s);
+static int pci230_ao_cancel(comedi_device * dev, comedi_subdevice * s);
+static void pci230_ao_stop(comedi_device * dev, comedi_subdevice * s);
+static void pci230_handle_ao_nofifo(comedi_device * dev, comedi_subdevice * s);
+static int pci230_handle_ao_fifo(comedi_device * dev, comedi_subdevice * s);
+static int pci230_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int pci230_ai_cmd(comedi_device * dev, comedi_subdevice * s);
+static int pci230_ai_cancel(comedi_device * dev, comedi_subdevice * s);
+static void pci230_ai_stop(comedi_device * dev, comedi_subdevice * s);
+static void pci230_handle_ai(comedi_device * dev, comedi_subdevice * s);
+
+static sampl_t pci230_ai_read(comedi_device * dev)
+{
+	/* Read sample. */
+	sampl_t data = (sampl_t) inw(dev->iobase + PCI230_ADCDATA);
+
+	/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
+	 * four bits reserved for expansion). */
+	/* PCI230+ is 16 bit AI. */
+	data = data >> (16 - thisboard->ai_bits);
+
+	/* If a bipolar range was specified, mangle it (twos
+	 * complement->straight binary). */
+	if (devpriv->ai_bipolar) {
+		data ^= 1 << (thisboard->ai_bits - 1);
+	}
+	return data;
+}
+
+static inline unsigned short pci230_ao_mangle_datum(comedi_device * dev,
+	sampl_t datum)
+{
+	/* If a bipolar range was specified, mangle it (straight binary->twos
+	 * complement). */
+	if (devpriv->ao_bipolar) {
+		datum ^= 1 << (thisboard->ao_bits - 1);
+	}
+
+	/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
+	 * four bits reserved for expansion). */
+	/* PCI230+ is also 12 bit AO. */
+	datum <<= (16 - thisboard->ao_bits);
+	return (unsigned short)datum;
+}
+
+static inline void pci230_ao_write_nofifo(comedi_device * dev, sampl_t datum,
+	unsigned int chan)
+{
+	/* Store unmangled datum to be read back later. */
+	devpriv->ao_readback[chan] = datum;
+
+	/* Write mangled datum to appropriate DACOUT register. */
+	outw(pci230_ao_mangle_datum(dev, datum), dev->iobase + (((chan) == 0)
+			? PCI230_DACOUT1 : PCI230_DACOUT2));
+}
+
+static inline void pci230_ao_write_fifo(comedi_device * dev, sampl_t datum,
+	unsigned int chan)
+{
+	/* Store unmangled datum to be read back later. */
+	devpriv->ao_readback[chan] = datum;
+
+	/* Write mangled datum to appropriate DACDATA register. */
+	outw(pci230_ao_mangle_datum(dev, datum),
+		dev->iobase + PCI230P2_DACDATA);
+}
+
+/*
+ * Attach is called by the Comedi core to configure the driver
+ * for a particular board.  If you specified a board_name array
+ * in the driver structure, dev->board_ptr contains that
+ * address.
+ */
+static int pci230_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	unsigned long iobase1, iobase2;
+	/* PCI230's I/O spaces 1 and 2 respectively. */
+	struct pci_dev *pci_dev;
+	int i = 0, irq_hdl, rc;
+
+	printk("comedi%d: amplc_pci230: attach %s %d,%d\n", dev->minor,
+		thisboard->name, it->options[0], it->options[1]);
+
+	/* Allocate the private structure area using alloc_private().
+	 * Macro defined in comedidev.h - memsets struct fields to 0. */
+	if ((alloc_private(dev, sizeof(struct pci230_private))) < 0) {
+		return -ENOMEM;
+	}
+	spin_lock_init(&devpriv->isr_spinlock);
+	spin_lock_init(&devpriv->res_spinlock);
+	spin_lock_init(&devpriv->ai_stop_spinlock);
+	spin_lock_init(&devpriv->ao_stop_spinlock);
+	/* Find card */
+	for (pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
+		pci_dev != NULL;
+		pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) {
+		if (it->options[0] || it->options[1]) {
+			/* Match against bus/slot options. */
+			if (it->options[0] != pci_dev->bus->number ||
+				it->options[1] != PCI_SLOT(pci_dev->devfn))
+				continue;
+		}
+		if (pci_dev->vendor != PCI_VENDOR_ID_AMPLICON)
+			continue;
+		if (thisboard->id == PCI_DEVICE_ID_INVALID) {
+			/* The name was specified as "amplc_pci230" which is
+			 * used to match any supported device.  Replace the
+			 * current dev->board_ptr with one that matches the
+			 * PCI device ID. */
+			for (i = 0; i < n_pci230_boards; i++) {
+				if (pci_dev->device == pci230_boards[i].id) {
+					if (pci230_boards[i].min_hwver > 0) {
+						/* Check for a '+' model.
+						 * First check length of
+						 * registers. */
+						if (pci_resource_len(pci_dev, 3)
+							< 32) {
+							/* Not a '+' model. */
+							continue;
+						}
+						/* TODO: temporarily enable the
+						 * PCI device and read the
+						 * hardware version register.
+						 * For now assume it's okay. */
+					}
+					/* Change board_ptr to matched board */
+					dev->board_ptr = &pci230_boards[i];
+					break;
+				}
+			}
+			if (i < n_pci230_boards)
+				break;
+		} else {
+			/* The name was specified as a specific device name.
+			 * The current dev->board_ptr is correct.  Check
+			 * whether it matches the PCI device ID. */
+			if (thisboard->id == pci_dev->device) {
+				/* Check minimum hardware version. */
+				if (thisboard->min_hwver > 0) {
+					/* Looking for a '+' model.  First
+					 * check length of registers. */
+					if (pci_resource_len(pci_dev, 3) < 32) {
+						/* Not a '+' model. */
+						continue;
+					}
+					/* TODO: temporarily enable the PCI
+					 * device and read the hardware version
+					 * register.  For now, assume it's
+					 * okay. */
+					break;
+				} else {
+					break;
+				}
+			}
+		}
+	}
+	if (!pci_dev) {
+		printk("comedi%d: No %s card found\n", dev->minor,
+			thisboard->name);
+		return -EIO;
+	}
+	devpriv->pci_dev = pci_dev;
+
+	/*
+	 * Initialize dev->board_name.
+	 */
+	dev->board_name = thisboard->name;
+
+	/* Enable PCI device and reserve I/O spaces. */
+	if (comedi_pci_enable(pci_dev, "amplc_pci230") < 0) {
+		printk("comedi%d: failed to enable PCI device "
+			"and request regions\n", dev->minor);
+		return -EIO;
+	}
+
+	/* Read base addresses of the PCI230's two I/O regions from PCI
+	 * configuration register. */
+	iobase1 = pci_resource_start(pci_dev, 2);
+	iobase2 = pci_resource_start(pci_dev, 3);
+
+	printk("comedi%d: %s I/O region 1 0x%04lx I/O region 2 0x%04lx\n",
+		dev->minor, dev->board_name, iobase1, iobase2);
+
+	devpriv->iobase1 = iobase1;
+	dev->iobase = iobase2;
+
+	/* Read bits of DACCON register - only the output range. */
+	devpriv->daccon = inw(dev->iobase + PCI230_DACCON) & PCI230_DAC_OR_MASK;
+
+	/* Read hardware version register and set extended function register
+	 * if they exist. */
+	if (pci_resource_len(pci_dev, 3) >= 32) {
+		unsigned short extfunc = 0;
+
+		devpriv->hwver = inw(dev->iobase + PCI230P_HWVER);
+		if (devpriv->hwver < thisboard->min_hwver) {
+			printk("comedi%d: %s - bad hardware version "
+				"- got %u, need %u\n", dev->minor,
+				dev->board_name, devpriv->hwver,
+				thisboard->min_hwver);
+			return -EIO;
+		}
+		if (devpriv->hwver > 0) {
+			if (!thisboard->have_dio) {
+				/* No DIO ports.  Route counters' external gates
+				 * to the EXTTRIG signal (PCI260+ pin 17).
+				 * (Otherwise, they would be routed to DIO
+				 * inputs PC0, PC1 and PC2 which don't exist
+				 * on PCI260[+].) */
+				extfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;
+			}
+			if ((thisboard->ao_chans > 0)
+				&& (devpriv->hwver >= 2)) {
+				/* Enable DAC FIFO functionality. */
+				extfunc |= PCI230P2_EXTFUNC_DACFIFO;
+			}
+		}
+		outw(extfunc, dev->iobase + PCI230P_EXTFUNC);
+		if ((extfunc & PCI230P2_EXTFUNC_DACFIFO) != 0) {
+			/* Temporarily enable DAC FIFO, reset it and disable
+			 * FIFO wraparound. */
+			outw(devpriv->daccon | PCI230P2_DAC_FIFO_EN
+				| PCI230P2_DAC_FIFO_RESET,
+				dev->iobase + PCI230_DACCON);
+			/* Clear DAC FIFO channel enable register. */
+			outw(0, dev->iobase + PCI230P2_DACEN);
+			/* Disable DAC FIFO. */
+			outw(devpriv->daccon, dev->iobase + PCI230_DACCON);
+		}
+	}
+
+	/* Disable board's interrupts. */
+	outb(0, devpriv->iobase1 + PCI230_INT_SCE);
+
+	/* Set ADC to a reasonable state. */
+	devpriv->adcg = 0;
+	devpriv->adccon = PCI230_ADC_TRIG_NONE | PCI230_ADC_IM_SE
+		| PCI230_ADC_IR_BIP;
+	outw(1 << 0, dev->iobase + PCI230_ADCEN);
+	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
+	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
+		dev->iobase + PCI230_ADCCON);
+
+	/* Register the interrupt handler. */
+	irq_hdl = comedi_request_irq(devpriv->pci_dev->irq, pci230_interrupt,
+		IRQF_SHARED, "amplc_pci230", dev);
+	if (irq_hdl < 0) {
+		printk("comedi%d: unable to register irq, "
+			"commands will not be available %d\n", dev->minor,
+			devpriv->pci_dev->irq);
+	} else {
+		dev->irq = devpriv->pci_dev->irq;
+		printk("comedi%d: registered irq %u\n", dev->minor,
+			devpriv->pci_dev->irq);
+	}
+
+	/*
+	 * Allocate the subdevice structures.  alloc_subdevice() is a
+	 * convenient macro defined in comedidev.h.
+	 */
+	if (alloc_subdevices(dev, 3) < 0)
+		return -ENOMEM;
+
+	s = dev->subdevices + 0;
+	/* analog input subdevice */
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;
+	s->n_chan = thisboard->ai_chans;
+	s->maxdata = (1 << thisboard->ai_bits) - 1;
+	s->range_table = &pci230_ai_range;
+	s->insn_read = &pci230_ai_rinsn;
+	s->len_chanlist = 256;	/* but there are restrictions. */
+	/* Only register commands if the interrupt handler is installed. */
+	if (irq_hdl == 0) {
+		dev->read_subdev = s;
+		s->subdev_flags |= SDF_CMD_READ;
+		s->do_cmd = &pci230_ai_cmd;
+		s->do_cmdtest = &pci230_ai_cmdtest;
+		s->cancel = pci230_ai_cancel;
+	}
+
+	s = dev->subdevices + 1;
+	/* analog output subdevice */
+	if (thisboard->ao_chans > 0) {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
+		s->n_chan = thisboard->ao_chans;;
+		s->maxdata = (1 << thisboard->ao_bits) - 1;
+		s->range_table = &pci230_ao_range;
+		s->insn_write = &pci230_ao_winsn;
+		s->insn_read = &pci230_ao_rinsn;
+		s->len_chanlist = thisboard->ao_chans;
+		/* Only register commands if the interrupt handler is
+		 * installed. */
+		if (irq_hdl == 0) {
+			dev->write_subdev = s;
+			s->subdev_flags |= SDF_CMD_WRITE;
+			s->do_cmd = &pci230_ao_cmd;
+			s->do_cmdtest = &pci230_ao_cmdtest;
+			s->cancel = pci230_ao_cancel;
+		}
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	s = dev->subdevices + 2;
+	/* digital i/o subdevice */
+	if (thisboard->have_dio) {
+		rc = subdev_8255_init(dev, s, NULL,
+			(devpriv->iobase1 + PCI230_PPI_X_BASE));
+		if (rc < 0)
+			return rc;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	printk("comedi%d: attached\n", dev->minor);
+
+	return 1;
+}
+
+/*
+ * _detach is called to deconfigure a device.  It should deallocate
+ * resources.
+ * This function is also called when _attach() fails, so it should be
+ * careful not to release resources that were not necessarily
+ * allocated by _attach().  dev->private and dev->subdevices are
+ * deallocated automatically by the core.
+ */
+static int pci230_detach(comedi_device * dev)
+{
+	printk("comedi%d: amplc_pci230: remove\n", dev->minor);
+
+	if (dev->subdevices && thisboard->have_dio)
+		/* Clean up dio subdevice. */
+		subdev_8255_cleanup(dev, dev->subdevices + 2);
+
+	if (dev->irq)
+		comedi_free_irq(dev->irq, dev);
+
+	if (devpriv) {
+		if (devpriv->pci_dev) {
+			if (dev->iobase) {
+				comedi_pci_disable(devpriv->pci_dev);
+			}
+			pci_dev_put(devpriv->pci_dev);
+		}
+	}
+
+	return 0;
+}
+
+static int get_resources(comedi_device * dev, unsigned int res_mask,
+	unsigned char owner)
+{
+	int ok;
+	unsigned int i;
+	unsigned int b;
+	unsigned int claimed;
+	unsigned long irqflags;
+
+	ok = 1;
+	claimed = 0;
+	comedi_spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
+	for (b = 1, i = 0; (i < NUM_RESOURCES)
+		&& (res_mask != 0); b <<= 1, i++) {
+		if ((res_mask & b) != 0) {
+			res_mask &= ~b;
+			if (devpriv->res_owner[i] == OWNER_NONE) {
+				devpriv->res_owner[i] = owner;
+				claimed |= b;
+			} else if (devpriv->res_owner[i] != owner) {
+				for (b = 1, i = 0; claimed != 0; b <<= 1, i++) {
+					if ((claimed & b) != 0) {
+						devpriv->res_owner[i]
+							= OWNER_NONE;
+						claimed &= ~b;
+					}
+				}
+				ok = 0;
+				break;
+			}
+		}
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
+	return ok;
+}
+
+static inline int get_one_resource(comedi_device * dev, unsigned int resource,
+	unsigned char owner)
+{
+	return get_resources(dev, (1U << resource), owner);
+}
+
+static void put_resources(comedi_device * dev, unsigned int res_mask,
+	unsigned char owner)
+{
+	unsigned int i;
+	unsigned int b;
+	unsigned long irqflags;
+
+	comedi_spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
+	for (b = 1, i = 0; (i < NUM_RESOURCES)
+		&& (res_mask != 0); b <<= 1, i++) {
+		if ((res_mask & b) != 0) {
+			res_mask &= ~b;
+			if (devpriv->res_owner[i] == owner) {
+				devpriv->res_owner[i] = OWNER_NONE;
+			}
+		}
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
+}
+
+static inline void put_one_resource(comedi_device * dev, unsigned int resource,
+	unsigned char owner)
+{
+	put_resources(dev, (1U << resource), owner);
+}
+
+static inline void put_all_resources(comedi_device * dev, unsigned char owner)
+{
+	put_resources(dev, (1U << NUM_RESOURCES) - 1, owner);
+}
+
+/*
+ *  COMEDI_SUBD_AI instruction;
+ */
+static int pci230_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int n, i;
+	unsigned int chan, range, aref;
+	unsigned int gainshift;
+	unsigned int status;
+	unsigned short adccon, adcen;
+
+	/* Unpack channel and range. */
+	chan = CR_CHAN(insn->chanspec);
+	range = CR_RANGE(insn->chanspec);
+	aref = CR_AREF(insn->chanspec);
+	if (aref == AREF_DIFF) {
+		/* Differential. */
+		if (chan >= s->n_chan / 2) {
+			DPRINTK("comedi%d: amplc_pci230: ai_rinsn: "
+				"differential channel number out of range "
+				"0 to %u\n", dev->minor, (s->n_chan / 2) - 1);
+			return -EINVAL;
+		}
+	}
+
+	/* Use Z2-CT2 as a conversion trigger instead of the built-in
+	 * software trigger, as otherwise triggering of differential channels
+	 * doesn't work properly for some versions of PCI230/260.  Also set
+	 * FIFO mode because the ADC busy bit only works for software triggers.
+	 */
+	adccon = PCI230_ADC_TRIG_Z2CT2 | PCI230_ADC_FIFO_EN;
+	/* Set Z2-CT2 output low to avoid any false triggers. */
+	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE0);
+	devpriv->ai_bipolar = pci230_ai_bipolar[range];
+	if (aref == AREF_DIFF) {
+		/* Differential. */
+		gainshift = chan * 2;
+		if (devpriv->hwver == 0) {
+			/* Original PCI230/260 expects both inputs of the
+			 * differential channel to be enabled. */
+			adcen = 3 << gainshift;
+		} else {
+			/* PCI230+/260+ expects only one input of the
+			 * differential channel to be enabled. */
+			adcen = 1 << gainshift;
+		}
+		adccon |= PCI230_ADC_IM_DIF;
+	} else {
+		/* Single ended. */
+		adcen = 1 << chan;
+		gainshift = chan & ~1;
+		adccon |= PCI230_ADC_IM_SE;
+	}
+	devpriv->adcg = (devpriv->adcg & ~(3 << gainshift))
+		| (pci230_ai_gain[range] << gainshift);
+	if (devpriv->ai_bipolar) {
+		adccon |= PCI230_ADC_IR_BIP;
+	} else {
+		adccon |= PCI230_ADC_IR_UNI;
+	}
+
+	/* Enable only this channel in the scan list - otherwise by default
+	 * we'll get one sample from each channel. */
+	outw(adcen, dev->iobase + PCI230_ADCEN);
+
+	/* Set gain for channel. */
+	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
+
+	/* Specify uni/bip, se/diff, conversion source, and reset FIFO. */
+	devpriv->adccon = adccon;
+	outw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);
+
+	/* Convert n samples */
+	for (n = 0; n < insn->n; n++) {
+		/* Trigger conversion by toggling Z2-CT2 output (finish with
+		 * output high). */
+		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
+			I8254_MODE0);
+		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
+			I8254_MODE1);
+
+#define TIMEOUT 100
+		/* wait for conversion to end */
+		for (i = 0; i < TIMEOUT; i++) {
+			status = inw(dev->iobase + PCI230_ADCCON);
+			if (!(status & PCI230_ADC_FIFO_EMPTY))
+				break;
+			comedi_udelay(1);
+		}
+		if (i == TIMEOUT) {
+			/* rt_printk() should be used instead of printk()
+			 * whenever the code can be called from real-time. */
+			rt_printk("timeout\n");
+			return -ETIMEDOUT;
+		}
+
+		/* read data */
+		data[n] = pci230_ai_read(dev);
+	}
+
+	/* return the number of samples read/written */
+	return n;
+}
+
+/*
+ *  COMEDI_SUBD_AO instructions;
+ */
+static int pci230_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+	int chan, range;
+
+	/* Unpack channel and range. */
+	chan = CR_CHAN(insn->chanspec);
+	range = CR_RANGE(insn->chanspec);
+
+	/* Set range - see analogue output range table; 0 => unipolar 10V,
+	 * 1 => bipolar +/-10V range scale */
+	devpriv->ao_bipolar = pci230_ao_bipolar[range];
+	outw(range, dev->iobase + PCI230_DACCON);
+
+	/* Writing a list of values to an AO channel is probably not
+	 * very useful, but that's how the interface is defined. */
+	for (i = 0; i < insn->n; i++) {
+		/* Write value to DAC and store it. */
+		pci230_ao_write_nofifo(dev, data[i], chan);
+	}
+
+	/* return the number of samples read/written */
+	return i;
+}
+
+/* AO subdevices should have a read insn as well as a write insn.
+ * Usually this means copying a value stored in devpriv. */
+static int pci230_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+	int chan = CR_CHAN(insn->chanspec);
+
+	for (i = 0; i < insn->n; i++)
+		data[i] = devpriv->ao_readback[chan];
+
+	return i;
+}
+
+static int pci230_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	unsigned int tmp;
+
+	/* cmdtest tests a particular command to see if it is valid.
+	 * Using the cmdtest ioctl, a user can create a valid cmd
+	 * and then have it executes by the cmd ioctl.
+	 *
+	 * cmdtest returns 1,2,3,4 or 0, depending on which tests
+	 * the command passes. */
+
+	/* Step 1: make sure trigger sources are trivially valid.
+	 * "invalid source" returned by comedilib to user mode process
+	 * if this fails. */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_INT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	if ((thisboard->min_hwver > 0) && (devpriv->hwver >= 2)) {
+		/*
+		 * For PCI230+ hardware version 2 onwards, allow external
+		 * trigger from EXTTRIG/EXTCONVCLK input (PCI230+ pin 25).
+		 *
+		 * FIXME: The permitted scan_begin_src values shouldn't depend
+		 * on devpriv->hwver (the detected card's actual hardware
+		 * version).  They should only depend on thisboard->min_hwver
+		 * (the static capabilities of the configured card).  To fix
+		 * it, a new card model, e.g. "pci230+2" would have to be
+		 * defined with min_hwver set to 2.  It doesn't seem worth it
+		 * for this alone.  At the moment, please consider
+		 * scan_begin_src==TRIG_EXT support to be a bonus rather than a
+		 * guarantee!
+		 */
+		cmd->scan_begin_src &= TRIG_TIMER | TRIG_INT | TRIG_EXT;
+	} else {
+		cmd->scan_begin_src &= TRIG_TIMER | TRIG_INT;
+	}
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* Step 2: make sure trigger sources are unique and mutually compatible
+	 * "source conflict" returned by comedilib to user mode process
+	 * if this fails. */
+
+	/* these tests are true if more than one _src bit is set */
+	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
+		err++;
+	if ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)
+		err++;
+	if ((cmd->convert_src & (cmd->convert_src - 1)) != 0)
+		err++;
+	if ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)
+		err++;
+	if ((cmd->stop_src & (cmd->stop_src - 1)) != 0)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* Step 3: make sure arguments are trivially compatible.
+	 * "invalid argument" returned by comedilib to user mode process
+	 * if this fails. */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+#define MAX_SPEED_AO	8000	/* 8000 ns => 125 kHz */
+#define MIN_SPEED_AO	4294967295u	/* 4294967295ns = 4.29s */
+			/*- Comedi limit due to unsigned int cmd.  Driver limit
+			 * = 2^16 (16bit * counter) * 1000000ns (1kHz onboard
+			 * clock) = 65.536s */
+
+	switch (cmd->scan_begin_src) {
+	case TRIG_TIMER:
+		if (cmd->scan_begin_arg < MAX_SPEED_AO) {
+			cmd->scan_begin_arg = MAX_SPEED_AO;
+			err++;
+		}
+		if (cmd->scan_begin_arg > MIN_SPEED_AO) {
+			cmd->scan_begin_arg = MIN_SPEED_AO;
+			err++;
+		}
+		break;
+	case TRIG_EXT:
+		/* External trigger - for PCI230+ hardware version 2 onwards. */
+		/* Trigger number must be 0. */
+		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
+			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
+				~CR_FLAGS_MASK);
+			err++;
+		}
+		/* The only flags allowed are CR_EDGE and CR_INVERT.  The
+		 * CR_EDGE flag is ignored. */
+		if ((cmd->scan_begin_arg
+				& (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) !=
+			0) {
+			cmd->scan_begin_arg =
+				COMBINE(cmd->scan_begin_arg, 0,
+				CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
+			err++;
+		}
+		break;
+	default:
+		if (cmd->scan_begin_arg != 0) {
+			cmd->scan_begin_arg = 0;
+			err++;
+		}
+		break;
+	}
+
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_NONE) {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* Step 4: fix up any arguments.
+	 * "argument conflict" returned by comedilib to user mode process
+	 * if this fails. */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		tmp = cmd->scan_begin_arg;
+		pci230_ns_to_single_timer(&cmd->scan_begin_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->scan_begin_arg)
+			err++;
+	}
+
+	if (err)
+		return 4;
+
+	/* Step 5: check channel list if it exists. */
+
+	if (cmd->chanlist && cmd->chanlist_len > 0) {
+		enum {
+			seq_err = (1 << 0),
+			range_err = (1 << 1)
+		};
+		unsigned int errors;
+		unsigned int n;
+		unsigned int chan, prev_chan;
+		unsigned int range, first_range;
+
+		prev_chan = CR_CHAN(cmd->chanlist[0]);
+		first_range = CR_RANGE(cmd->chanlist[0]);
+		errors = 0;
+		for (n = 1; n < cmd->chanlist_len; n++) {
+			chan = CR_CHAN(cmd->chanlist[n]);
+			range = CR_RANGE(cmd->chanlist[n]);
+			/* Channel numbers must strictly increase. */
+			if (chan < prev_chan) {
+				errors |= seq_err;
+			}
+			/* Ranges must be the same. */
+			if (range != first_range) {
+				errors |= range_err;
+			}
+			prev_chan = chan;
+		}
+		if (errors != 0) {
+			err++;
+			if ((errors & seq_err) != 0) {
+				DPRINTK("comedi%d: amplc_pci230: ao_cmdtest: "
+					"channel numbers must increase\n",
+					dev->minor);
+			}
+			if ((errors & range_err) != 0) {
+				DPRINTK("comedi%d: amplc_pci230: ao_cmdtest: "
+					"channels must have the same range\n",
+					dev->minor);
+			}
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static int pci230_ao_inttrig_scan_begin(comedi_device * dev,
+	comedi_subdevice * s, unsigned int trig_num)
+{
+	unsigned long irqflags;
+
+	if (trig_num != 0)
+		return -EINVAL;
+
+	comedi_spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
+	if (test_bit(AO_CMD_STARTED, &devpriv->state)) {
+		/* Perform scan. */
+		if (devpriv->hwver < 2) {
+			/* Not using DAC FIFO. */
+			comedi_spin_unlock_irqrestore(&devpriv->
+				ao_stop_spinlock, irqflags);
+			pci230_handle_ao_nofifo(dev, s);
+			comedi_event(dev, s);
+		} else {
+			/* Using DAC FIFO. */
+			/* Read DACSWTRIG register to trigger conversion. */
+			inw(dev->iobase + PCI230P2_DACSWTRIG);
+			comedi_spin_unlock_irqrestore(&devpriv->
+				ao_stop_spinlock, irqflags);
+		}
+		/* Delay.  Should driver be responsible for this? */
+		/* XXX TODO: See if DAC busy bit can be used. */
+		comedi_udelay(8);
+	}
+
+	return 1;
+}
+
+static void pci230_ao_start(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	unsigned long irqflags;
+
+	set_bit(AO_CMD_STARTED, &devpriv->state);
+	if (!devpriv->ao_continuous && (devpriv->ao_scan_count == 0)) {
+		/* An empty acquisition! */
+		async->events |= COMEDI_CB_EOA;
+		pci230_ao_stop(dev, s);
+		comedi_event(dev, s);
+	} else {
+		if (devpriv->hwver >= 2) {
+			/* Using DAC FIFO. */
+			unsigned short scantrig;
+			int run;
+
+			/* Preload FIFO data. */
+			run = pci230_handle_ao_fifo(dev, s);
+			comedi_event(dev, s);
+			if (!run) {
+				/* Stopped. */
+				return;
+			}
+			/* Set scan trigger source. */
+			switch (cmd->scan_begin_src) {
+			case TRIG_TIMER:
+				scantrig = PCI230P2_DAC_TRIG_Z2CT1;
+				break;
+			case TRIG_EXT:
+				/* Trigger on EXTTRIG/EXTCONVCLK pin. */
+				if ((cmd->scan_begin_arg & CR_INVERT) == 0) {
+					/* +ve edge */
+					scantrig = PCI230P2_DAC_TRIG_EXTP;
+				} else {
+					/* -ve edge */
+					scantrig = PCI230P2_DAC_TRIG_EXTN;
+				}
+				break;
+			case TRIG_INT:
+				scantrig = PCI230P2_DAC_TRIG_SW;
+				break;
+			default:
+				/* Shouldn't get here. */
+				scantrig = PCI230P2_DAC_TRIG_NONE;
+				break;
+			}
+			devpriv->daccon = (devpriv->daccon
+				& ~PCI230P2_DAC_TRIG_MASK) | scantrig;
+			outw(devpriv->daccon, dev->iobase + PCI230_DACCON);
+
+		}
+		switch (cmd->scan_begin_src) {
+		case TRIG_TIMER:
+			if (devpriv->hwver < 2) {
+				/* Not using DAC FIFO. */
+				/* Enable CT1 timer interrupt. */
+				comedi_spin_lock_irqsave(&devpriv->isr_spinlock,
+					irqflags);
+				devpriv->int_en |= PCI230_INT_ZCLK_CT1;
+				devpriv->ier |= PCI230_INT_ZCLK_CT1;
+				outb(devpriv->ier,
+					devpriv->iobase1 + PCI230_INT_SCE);
+				comedi_spin_unlock_irqrestore(&devpriv->
+					isr_spinlock, irqflags);
+			}
+			/* Set CT1 gate high to start counting. */
+			outb(GAT_CONFIG(1, GAT_VCC),
+				devpriv->iobase1 + PCI230_ZGAT_SCE);
+			break;
+		case TRIG_INT:
+			async->inttrig = pci230_ao_inttrig_scan_begin;
+			break;
+		}
+		if (devpriv->hwver >= 2) {
+			/* Using DAC FIFO.  Enable DAC FIFO interrupt. */
+			comedi_spin_lock_irqsave(&devpriv->isr_spinlock,
+				irqflags);
+			devpriv->int_en |= PCI230P2_INT_DAC;
+			devpriv->ier |= PCI230P2_INT_DAC;
+			outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+			comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock,
+				irqflags);
+		}
+	}
+}
+
+static int pci230_ao_inttrig_start(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trig_num)
+{
+	if (trig_num != 0)
+		return -EINVAL;
+
+	s->async->inttrig = NULLFUNC;
+	pci230_ao_start(dev, s);
+
+	return 1;
+}
+
+static int pci230_ao_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned short daccon;
+	unsigned int range;
+
+	/* Get the command. */
+	comedi_cmd *cmd = &s->async->cmd;
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		/* Claim Z2-CT1. */
+		if (!get_one_resource(dev, RES_Z2CT1, OWNER_AOCMD)) {
+			return -EBUSY;
+		}
+	}
+
+	/* Get number of scans required. */
+	if (cmd->stop_src == TRIG_COUNT) {
+		devpriv->ao_scan_count = cmd->stop_arg;
+		devpriv->ao_continuous = 0;
+	} else {
+		/* TRIG_NONE, user calls cancel. */
+		devpriv->ao_scan_count = 0;
+		devpriv->ao_continuous = 1;
+	}
+
+	/* Set range - see analogue output range table; 0 => unipolar 10V,
+	 * 1 => bipolar +/-10V range scale */
+	range = CR_RANGE(cmd->chanlist[0]);
+	devpriv->ao_bipolar = pci230_ao_bipolar[range];
+	daccon = devpriv->ao_bipolar ? PCI230_DAC_OR_BIP : PCI230_DAC_OR_UNI;
+	/* Use DAC FIFO for hardware version 2 onwards. */
+	if (devpriv->hwver >= 2) {
+		unsigned short dacen;
+		unsigned int i;
+
+		dacen = 0;
+		for (i = 0; i < cmd->chanlist_len; i++) {
+			dacen |= 1 << CR_CHAN(cmd->chanlist[i]);
+		}
+		/* Set channel scan list. */
+		outw(dacen, dev->iobase + PCI230P2_DACEN);
+		/*
+		 * Enable DAC FIFO.
+		 * Set DAC scan source to 'none'.
+		 * Set DAC FIFO interrupt trigger level to 'not half full'.
+		 * Reset DAC FIFO and clear underrun.
+		 *
+		 * N.B. DAC FIFO interrupts are currently disabled.
+		 */
+		daccon |= PCI230P2_DAC_FIFO_EN | PCI230P2_DAC_FIFO_RESET
+			| PCI230P2_DAC_FIFO_UNDERRUN_CLEAR
+			| PCI230P2_DAC_TRIG_NONE | PCI230P2_DAC_INT_FIFO_NHALF;
+	}
+
+	/* Set DACCON. */
+	outw(daccon, dev->iobase + PCI230_DACCON);
+	/* Preserve most of DACCON apart from write-only, transient bits. */
+	devpriv->daccon = daccon
+		& ~(PCI230P2_DAC_FIFO_RESET | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR);
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		/* Set the counter timer 1 to the specified scan frequency. */
+		/* cmd->scan_begin_arg is sampling period in ns */
+		/* gate it off for now. */
+		outb(GAT_CONFIG(1, GAT_GND),
+			devpriv->iobase1 + PCI230_ZGAT_SCE);
+		pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
+			cmd->scan_begin_arg, cmd->flags & TRIG_ROUND_MASK);
+	}
+
+	/* N.B. cmd->start_src == TRIG_INT */
+	s->async->inttrig = pci230_ao_inttrig_start;
+
+	return 0;
+}
+
+static int pci230_ai_check_scan_period(comedi_cmd * cmd)
+{
+	unsigned int min_scan_period, chanlist_len;
+	int err = 0;
+
+	chanlist_len = cmd->chanlist_len;
+	if (cmd->chanlist_len == 0) {
+		chanlist_len = 1;
+	}
+	min_scan_period = chanlist_len * cmd->convert_arg;
+	if ((min_scan_period < chanlist_len)
+		|| (min_scan_period < cmd->convert_arg)) {
+		/* Arithmetic overflow. */
+		min_scan_period = UINT_MAX;
+		err++;
+	}
+	if (cmd->scan_begin_arg < min_scan_period) {
+		cmd->scan_begin_arg = min_scan_period;
+		err++;
+	}
+
+	return !err;
+}
+
+static int pci230_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	unsigned int tmp;
+
+	/* cmdtest tests a particular command to see if it is valid.
+	 * Using the cmdtest ioctl, a user can create a valid cmd
+	 * and then have it executes by the cmd ioctl.
+	 *
+	 * cmdtest returns 1,2,3,4,5 or 0, depending on which tests
+	 * the command passes. */
+
+	/* Step 1: make sure trigger sources are trivially valid.
+	 * "invalid source" returned by comedilib to user mode process
+	 * if this fails. */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_INT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	/* Unfortunately, we cannot trigger a scan off an external source
+	 * on the PCI260 board, since it uses the PPIC0 (DIO) input, which
+	 * isn't present on the PCI260.  For PCI260+ we can use the
+	 * EXTTRIG/EXTCONVCLK input on pin 17 instead. */
+	if ((thisboard->have_dio) || (thisboard->min_hwver > 0)) {
+		cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_INT
+			| TRIG_EXT;
+	} else {
+		cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_INT;
+	}
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_TIMER | TRIG_INT | TRIG_EXT;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* Step 2: make sure trigger sources are unique and mutually compatible
+	 * "source conflict" returned by comedilib to user mode process
+	 * if this fails. */
+
+	/* these tests are true if more than one _src bit is set */
+	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
+		err++;
+	if ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)
+		err++;
+	if ((cmd->convert_src & (cmd->convert_src - 1)) != 0)
+		err++;
+	if ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)
+		err++;
+	if ((cmd->stop_src & (cmd->stop_src - 1)) != 0)
+		err++;
+
+	/* If scan_begin_src is not TRIG_FOLLOW, then a monostable will be
+	 * set up to generate a fixed number of timed conversion pulses. */
+	if ((cmd->scan_begin_src != TRIG_FOLLOW)
+		&& (cmd->convert_src != TRIG_TIMER))
+		err++;
+
+	if (err)
+		return 2;
+
+	/* Step 3: make sure arguments are trivially compatible.
+	 * "invalid argument" returned by comedilib to user mode process
+	 * if this fails. */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+#define MAX_SPEED_AI_SE		3200	/* PCI230 SE:   3200 ns => 312.5 kHz */
+#define MAX_SPEED_AI_DIFF	8000	/* PCI230 DIFF: 8000 ns => 125 kHz */
+#define MAX_SPEED_AI_PLUS	4000	/* PCI230+:     4000 ns => 250 kHz */
+#define MIN_SPEED_AI	4294967295u	/* 4294967295ns = 4.29s */
+			/*- Comedi limit due to unsigned int cmd.  Driver limit
+			 * = 2^16 (16bit * counter) * 1000000ns (1kHz onboard
+			 * clock) = 65.536s */
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		unsigned int max_speed_ai;
+
+		if (devpriv->hwver == 0) {
+			/* PCI230 or PCI260.  Max speed depends whether
+			 * single-ended or pseudo-differential. */
+			if (cmd->chanlist && (cmd->chanlist_len > 0)) {
+				/* Peek analogue reference of first channel. */
+				if (CR_AREF(cmd->chanlist[0]) == AREF_DIFF) {
+					max_speed_ai = MAX_SPEED_AI_DIFF;
+				} else {
+					max_speed_ai = MAX_SPEED_AI_SE;
+				}
+			} else {
+				/* No channel list.  Assume single-ended. */
+				max_speed_ai = MAX_SPEED_AI_SE;
+			}
+		} else {
+			/* PCI230+ or PCI260+. */
+			max_speed_ai = MAX_SPEED_AI_PLUS;
+		}
+
+		if (cmd->convert_arg < max_speed_ai) {
+			cmd->convert_arg = max_speed_ai;
+			err++;
+		}
+		if (cmd->convert_arg > MIN_SPEED_AI) {
+			cmd->convert_arg = MIN_SPEED_AI;
+			err++;
+		}
+	} else if (cmd->convert_src == TRIG_EXT) {
+		/*
+		 * external trigger
+		 *
+		 * convert_arg == (CR_EDGE | 0)
+		 *                => trigger on +ve edge.
+		 * convert_arg == (CR_EDGE | CR_INVERT | 0)
+		 *                => trigger on -ve edge.
+		 */
+		if ((cmd->convert_arg & CR_FLAGS_MASK) != 0) {
+			/* Trigger number must be 0. */
+			if ((cmd->convert_arg & ~CR_FLAGS_MASK) != 0) {
+				cmd->convert_arg = COMBINE(cmd->convert_arg, 0,
+					~CR_FLAGS_MASK);
+				err++;
+			}
+			/* The only flags allowed are CR_INVERT and CR_EDGE.
+			 * CR_EDGE is required. */
+			if ((cmd->convert_arg & (CR_FLAGS_MASK & ~CR_INVERT))
+				!= CR_EDGE) {
+				/* Set CR_EDGE, preserve CR_INVERT. */
+				cmd->convert_arg =
+					COMBINE(cmd->start_arg, (CR_EDGE | 0),
+					CR_FLAGS_MASK & ~CR_INVERT);
+				err++;
+			}
+		} else {
+			/* Backwards compatibility with previous versions. */
+			/* convert_arg == 0 => trigger on -ve edge. */
+			/* convert_arg == 1 => trigger on +ve edge. */
+			if (cmd->convert_arg > 1) {
+				/* Default to trigger on +ve edge. */
+				cmd->convert_arg = 1;
+				err++;
+			}
+		}
+	} else {
+		if (cmd->convert_arg != 0) {
+			cmd->convert_arg = 0;
+			err++;
+		}
+	}
+
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	if (cmd->stop_src == TRIG_NONE) {
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (cmd->scan_begin_src == TRIG_EXT) {
+		/* external "trigger" to begin each scan
+		 * scan_begin_arg==0 => use PPC0 input -> gate of CT0 -> gate
+		 * of CT2 (sample convert trigger is CT2) */
+		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
+			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
+				~CR_FLAGS_MASK);
+			err++;
+		}
+		/* The only flag allowed is CR_EDGE, which is ignored. */
+		if ((cmd->scan_begin_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
+			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
+				CR_FLAGS_MASK & ~CR_EDGE);
+			err++;
+		}
+	} else if (cmd->scan_begin_src == TRIG_TIMER) {
+		/* N.B. cmd->convert_arg is also TRIG_TIMER */
+		if (!pci230_ai_check_scan_period(cmd)) {
+			err++;
+		}
+	} else {
+		if (cmd->scan_begin_arg != 0) {
+			cmd->scan_begin_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* Step 4: fix up any arguments.
+	 * "argument conflict" returned by comedilib to user mode process
+	 * if this fails. */
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		tmp = cmd->convert_arg;
+		pci230_ns_to_single_timer(&cmd->convert_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->convert_arg)
+			err++;
+	}
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		/* N.B. cmd->convert_arg is also TRIG_TIMER */
+		tmp = cmd->scan_begin_arg;
+		pci230_ns_to_single_timer(&cmd->scan_begin_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (!pci230_ai_check_scan_period(cmd)) {
+			/* Was below minimum required.  Round up. */
+			pci230_ns_to_single_timer(&cmd->scan_begin_arg,
+				TRIG_ROUND_UP);
+			pci230_ai_check_scan_period(cmd);
+		}
+		if (tmp != cmd->scan_begin_arg)
+			err++;
+	}
+
+	if (err)
+		return 4;
+
+	/* Step 5: check channel list if it exists. */
+
+	if (cmd->chanlist && cmd->chanlist_len > 0) {
+		enum {
+			seq_err = 1 << 0,
+			rangepair_err = 1 << 1,
+			polarity_err = 1 << 2,
+			aref_err = 1 << 3,
+			diffchan_err = 1 << 4,
+			buggy_chan0_err = 1 << 5
+		};
+		unsigned int errors;
+		unsigned int chan, prev_chan;
+		unsigned int range, prev_range;
+		unsigned int polarity, prev_polarity;
+		unsigned int aref, prev_aref;
+		unsigned int subseq_len;
+		unsigned int n;
+
+		subseq_len = 0;
+		errors = 0;
+		prev_chan = prev_aref = prev_range = prev_polarity = 0;
+		for (n = 0; n < cmd->chanlist_len; n++) {
+			chan = CR_CHAN(cmd->chanlist[n]);
+			range = CR_RANGE(cmd->chanlist[n]);
+			aref = CR_AREF(cmd->chanlist[n]);
+			polarity = pci230_ai_bipolar[range];
+			/* Only the first half of the channels are available if
+			 * differential.  (These are remapped in software.  In
+			 * hardware, only the even channels are available.) */
+			if ((aref == AREF_DIFF)
+				&& (chan >= (s->n_chan / 2))) {
+				errors |= diffchan_err;
+			}
+			if (n > 0) {
+				/* Channel numbers must strictly increase or
+				 * subsequence must repeat exactly. */
+				if ((chan <= prev_chan)
+					&& (subseq_len == 0)) {
+					subseq_len = n;
+				}
+				if ((subseq_len > 0)
+					&& (cmd->chanlist[n] !=
+						cmd->chanlist[n %
+							subseq_len])) {
+					errors |= seq_err;
+				}
+				/* Channels must have same AREF. */
+				if (aref != prev_aref) {
+					errors |= aref_err;
+				}
+				/* Channel ranges must have same polarity. */
+				if (polarity != prev_polarity) {
+					errors |= polarity_err;
+				}
+				/* Single-ended channel pairs must have same
+				 * range.  */
+				if ((aref != AREF_DIFF)
+					&& (((chan ^ prev_chan) & ~1) == 0)
+					&& (range != prev_range)) {
+					errors |= rangepair_err;
+				}
+			}
+			prev_chan = chan;
+			prev_range = range;
+			prev_aref = aref;
+			prev_polarity = polarity;
+		}
+		if (subseq_len == 0) {
+			/* Subsequence is whole sequence. */
+			subseq_len = n;
+		}
+		/* If channel list is a repeating subsequence, need a whole
+		 * number of repeats. */
+		if ((n % subseq_len) != 0) {
+			errors |= seq_err;
+		}
+		if ((devpriv->hwver > 0) && (devpriv->hwver < 4)) {
+			/*
+			 * Buggy PCI230+ or PCI260+ requires channel 0 to be
+			 * (first) in the sequence if the sequence contains
+			 * more than one channel.  Hardware versions 1 and 2
+			 * have the bug.  There is no hardware version 3.
+			 *
+			 * Actually, there are two firmwares that report
+			 * themselves as hardware version 1 (the boards
+			 * have different ADC chips with slightly different
+			 * timing requirements, which was supposed to be
+			 * invisible to software).  The first one doesn't
+			 * seem to have the bug, but the second one
+			 * does, and we can't tell them apart!
+			 */
+			if ((subseq_len > 1)
+				&& (CR_CHAN(cmd->chanlist[0]) != 0)) {
+				errors |= buggy_chan0_err;
+			}
+		}
+		if (errors != 0) {
+			err++;
+			if ((errors & seq_err) != 0) {
+				DPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "
+					"channel numbers must increase or "
+					"sequence must repeat exactly\n",
+					dev->minor);
+			}
+			if ((errors & rangepair_err) != 0) {
+				DPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "
+					"single-ended channel pairs must "
+					"have the same range\n", dev->minor);
+			}
+			if ((errors & polarity_err) != 0) {
+				DPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "
+					"channel sequence ranges must be all "
+					"bipolar or all unipolar\n",
+					dev->minor);
+			}
+			if ((errors & aref_err) != 0) {
+				DPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "
+					"channel sequence analogue references "
+					"must be all the same (single-ended "
+					"or differential)\n", dev->minor);
+			}
+			if ((errors & diffchan_err) != 0) {
+				DPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "
+					"differential channel number out of "
+					"range 0 to %u\n", dev->minor,
+					(s->n_chan / 2) - 1);
+			}
+			if ((errors & buggy_chan0_err) != 0) {
+				/* Use printk instead of DPRINTK here. */
+				printk("comedi: comedi%d: amplc_pci230: "
+					"ai_cmdtest: Buggy PCI230+/260+ "
+					"h/w version %u requires first channel "
+					"of multi-channel sequence to be 0 "
+					"(corrected in h/w version 4)\n",
+					dev->minor, devpriv->hwver);
+			}
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static void pci230_ai_update_fifo_trigger_level(comedi_device * dev,
+	comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	unsigned int scanlen = cmd->scan_end_arg;
+	unsigned int wake;
+	unsigned short triglev;
+	unsigned short adccon;
+
+	if ((cmd->flags & TRIG_WAKE_EOS) != 0) {
+		/* Wake at end of scan. */
+		wake = scanlen - devpriv->ai_scan_pos;
+	} else {
+		if (devpriv->ai_continuous
+			|| (devpriv->ai_scan_count
+				>= PCI230_ADC_FIFOLEVEL_HALFFULL)
+			|| (scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL)) {
+			wake = PCI230_ADC_FIFOLEVEL_HALFFULL;
+		} else {
+			wake = (devpriv->ai_scan_count * scanlen)
+				- devpriv->ai_scan_pos;
+		}
+	}
+	if (wake >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
+		triglev = PCI230_ADC_INT_FIFO_HALF;
+	} else {
+		if ((wake > 1) && (devpriv->hwver > 0)) {
+			/* PCI230+/260+ programmable FIFO interrupt level. */
+			if (devpriv->adcfifothresh != wake) {
+				devpriv->adcfifothresh = wake;
+				outw(wake, dev->iobase + PCI230P_ADCFFTH);
+			}
+			triglev = PCI230P_ADC_INT_FIFO_THRESH;
+		} else {
+			triglev = PCI230_ADC_INT_FIFO_NEMPTY;
+		}
+	}
+	adccon = (devpriv->adccon & ~PCI230_ADC_INT_FIFO_MASK) | triglev;
+	if (adccon != devpriv->adccon) {
+		devpriv->adccon = adccon;
+		outw(adccon, dev->iobase + PCI230_ADCCON);
+	}
+}
+
+static int pci230_ai_inttrig_convert(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trig_num)
+{
+	unsigned long irqflags;
+
+	if (trig_num != 0)
+		return -EINVAL;
+
+	comedi_spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
+	if (test_bit(AI_CMD_STARTED, &devpriv->state)) {
+		unsigned int delayus;
+
+		/* Trigger conversion by toggling Z2-CT2 output.  Finish
+		 * with output high. */
+		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
+			I8254_MODE0);
+		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
+			I8254_MODE1);
+		/* Delay.  Should driver be responsible for this?  An
+		 * alternative would be to wait until conversion is complete,
+		 * but we can't tell when it's complete because the ADC busy
+		 * bit has a different meaning when FIFO enabled (and when
+		 * FIFO not enabled, it only works for software triggers). */
+		if (((devpriv->adccon & PCI230_ADC_IM_MASK)
+				== PCI230_ADC_IM_DIF)
+			&& (devpriv->hwver == 0)) {
+			/* PCI230/260 in differential mode */
+			delayus = 8;
+		} else {
+			/* single-ended or PCI230+/260+ */
+			delayus = 4;
+		}
+		comedi_spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
+			irqflags);
+		comedi_udelay(delayus);
+	} else {
+		comedi_spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
+			irqflags);
+	}
+
+	return 1;
+}
+
+static int pci230_ai_inttrig_scan_begin(comedi_device * dev,
+	comedi_subdevice * s, unsigned int trig_num)
+{
+	unsigned long irqflags;
+	unsigned char zgat;
+
+	if (trig_num != 0)
+		return -EINVAL;
+
+	comedi_spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
+	if (test_bit(AI_CMD_STARTED, &devpriv->state)) {
+		/* Trigger scan by waggling CT0 gate source. */
+		zgat = GAT_CONFIG(0, GAT_GND);
+		outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+		zgat = GAT_CONFIG(0, GAT_VCC);
+		outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
+
+	return 1;
+}
+
+static void pci230_ai_start(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long irqflags;
+	unsigned short conv;
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+
+	set_bit(AI_CMD_STARTED, &devpriv->state);
+	if (!devpriv->ai_continuous && (devpriv->ai_scan_count == 0)) {
+		/* An empty acquisition! */
+		async->events |= COMEDI_CB_EOA;
+		pci230_ai_stop(dev, s);
+		comedi_event(dev, s);
+	} else {
+		/* Enable ADC FIFO trigger level interrupt. */
+		comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+		devpriv->int_en |= PCI230_INT_ADC;
+		devpriv->ier |= PCI230_INT_ADC;
+		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+		comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+
+		/* Update conversion trigger source which is currently set
+		 * to CT2 output, which is currently stuck high. */
+		switch (cmd->convert_src) {
+		default:
+			conv = PCI230_ADC_TRIG_NONE;
+			break;
+		case TRIG_TIMER:
+			/* Using CT2 output. */
+			conv = PCI230_ADC_TRIG_Z2CT2;
+			break;
+		case TRIG_EXT:
+			if ((cmd->convert_arg & CR_EDGE) != 0) {
+				if ((cmd->convert_arg & CR_INVERT) == 0) {
+					/* Trigger on +ve edge. */
+					conv = PCI230_ADC_TRIG_EXTP;
+				} else {
+					/* Trigger on -ve edge. */
+					conv = PCI230_ADC_TRIG_EXTN;
+				}
+			} else {
+				/* Backwards compatibility. */
+				if (cmd->convert_arg != 0) {
+					/* Trigger on +ve edge. */
+					conv = PCI230_ADC_TRIG_EXTP;
+				} else {
+					/* Trigger on -ve edge. */
+					conv = PCI230_ADC_TRIG_EXTN;
+				}
+			}
+			break;
+		case TRIG_INT:
+			/* Use CT2 output for software trigger due to problems
+			 * in differential mode on PCI230/260. */
+			conv = PCI230_ADC_TRIG_Z2CT2;
+			break;
+		}
+		devpriv->adccon = (devpriv->adccon & ~PCI230_ADC_TRIG_MASK)
+			| conv;
+		outw(devpriv->adccon, dev->iobase + PCI230_ADCCON);
+		if (cmd->convert_src == TRIG_INT) {
+			async->inttrig = pci230_ai_inttrig_convert;
+		}
+		/* Update FIFO interrupt trigger level, which is currently
+		 * set to "full".  */
+		pci230_ai_update_fifo_trigger_level(dev, s);
+		if (cmd->convert_src == TRIG_TIMER) {
+			/* Update timer gates. */
+			unsigned char zgat;
+
+			if (cmd->scan_begin_src != TRIG_FOLLOW) {
+				/* Conversion timer CT2 needs to be gated by
+				 * inverted output of monostable CT2. */
+				zgat = GAT_CONFIG(2, GAT_NOUTNM2);
+			} else {
+				/* Conversion timer CT2 needs to be gated on
+				 * continuously. */
+				zgat = GAT_CONFIG(2, GAT_VCC);
+			}
+			outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+			if (cmd->scan_begin_src != TRIG_FOLLOW) {
+				/* Set monostable CT0 trigger source. */
+				switch (cmd->scan_begin_src) {
+				default:
+					zgat = GAT_CONFIG(0, GAT_VCC);
+					break;
+				case TRIG_EXT:
+					/*
+					 * For CT0 on PCI230, the external
+					 * trigger (gate) signal comes from
+					 * PPC0, which is channel 16 of the DIO
+					 * subdevice.  The application needs to
+					 * configure this as an input in order
+					 * to use it as an external scan
+					 * trigger.
+					 */
+					zgat = GAT_CONFIG(0, GAT_EXT);
+					break;
+				case TRIG_TIMER:
+					/*
+					 * Monostable CT0 triggered by rising
+					 * edge on inverted output of CT1
+					 * (falling edge on CT1).
+					 */
+					zgat = GAT_CONFIG(0, GAT_NOUTNM2);
+					break;
+				case TRIG_INT:
+					/*
+					 * Monostable CT0 is triggered by
+					 * inttrig function waggling the CT0
+					 * gate source.
+					 */
+					zgat = GAT_CONFIG(0, GAT_VCC);
+					break;
+				}
+				outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+				switch (cmd->scan_begin_src) {
+				case TRIG_TIMER:
+					/* Scan period timer CT1 needs to be
+					 * gated on to start counting. */
+					zgat = GAT_CONFIG(1, GAT_VCC);
+					outb(zgat, devpriv->iobase1
+						+ PCI230_ZGAT_SCE);
+					break;
+				case TRIG_INT:
+					async->inttrig =
+						pci230_ai_inttrig_scan_begin;
+					break;
+				}
+			}
+		} else if (cmd->convert_src != TRIG_INT) {
+			/* No longer need Z2-CT2. */
+			put_one_resource(dev, RES_Z2CT2, OWNER_AICMD);
+		}
+	}
+}
+
+static int pci230_ai_inttrig_start(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trig_num)
+{
+	if (trig_num != 0)
+		return -EINVAL;
+
+	s->async->inttrig = NULLFUNC;
+	pci230_ai_start(dev, s);
+
+	return 1;
+}
+
+static int pci230_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned int i, chan, range, diff;
+	unsigned int res_mask;
+	unsigned short adccon, adcen;
+	unsigned char zgat;
+
+	/* Get the command. */
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+
+	/*
+	 * Determine which shared resources are needed.
+	 */
+	res_mask = 0;
+	/* Need Z2-CT2 to supply a conversion trigger source at a high
+	 * logic level, even if not doing timed conversions. */
+	res_mask |= (1U << RES_Z2CT2);
+	if (cmd->scan_begin_src != TRIG_FOLLOW) {
+		/* Using Z2-CT0 monostable to gate Z2-CT2 conversion timer */
+		res_mask |= (1U << RES_Z2CT0);
+		if (cmd->scan_begin_src == TRIG_TIMER) {
+			/* Using Z2-CT1 for scan frequency */
+			res_mask |= (1U << RES_Z2CT1);
+		}
+	}
+	/* Claim resources. */
+	if (!get_resources(dev, res_mask, OWNER_AICMD)) {
+		return -EBUSY;
+	}
+
+	/* Get number of scans required. */
+	if (cmd->stop_src == TRIG_COUNT) {
+		devpriv->ai_scan_count = cmd->stop_arg;
+		devpriv->ai_continuous = 0;
+	} else {
+		/* TRIG_NONE, user calls cancel. */
+		devpriv->ai_scan_count = 0;
+		devpriv->ai_continuous = 1;
+	}
+	devpriv->ai_scan_pos = 0;	/* Position within scan. */
+
+	/* Steps;
+	 * - Set channel scan list.
+	 * - Set channel gains.
+	 * - Enable and reset FIFO, specify uni/bip, se/diff, and set
+	 *   start conversion source to point to something at a high logic
+	 *   level (we use the output of counter/timer 2 for this purpose.
+	 * - PAUSE to allow things to settle down.
+	 * - Reset the FIFO again because it needs resetting twice and there
+	 *   may have been a false conversion trigger on some versions of
+	 *   PCI230/260 due to the start conversion source being set to a
+	 *   high logic level.
+	 * - Enable ADC FIFO level interrupt.
+	 * - Set actual conversion trigger source and FIFO interrupt trigger
+	 *   level.
+	 * - If convert_src is TRIG_TIMER, set up the timers.
+	 */
+
+	adccon = PCI230_ADC_FIFO_EN;
+	adcen = 0;
+
+	if (CR_AREF(cmd->chanlist[0]) == AREF_DIFF) {
+		/* Differential - all channels must be differential. */
+		diff = 1;
+		adccon |= PCI230_ADC_IM_DIF;
+	} else {
+		/* Single ended - all channels must be single-ended. */
+		diff = 0;
+		adccon |= PCI230_ADC_IM_SE;
+	}
+
+	range = CR_RANGE(cmd->chanlist[0]);
+	devpriv->ai_bipolar = pci230_ai_bipolar[range];
+	if (devpriv->ai_bipolar) {
+		adccon |= PCI230_ADC_IR_BIP;
+	} else {
+		adccon |= PCI230_ADC_IR_UNI;
+	}
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		unsigned int gainshift;
+
+		chan = CR_CHAN(cmd->chanlist[i]);
+		range = CR_RANGE(cmd->chanlist[i]);
+		if (diff) {
+			gainshift = 2 * chan;
+			if (devpriv->hwver == 0) {
+				/* Original PCI230/260 expects both inputs of
+				 * the differential channel to be enabled. */
+				adcen |= 3 << gainshift;
+			} else {
+				/* PCI230+/260+ expects only one input of the
+				 * differential channel to be enabled. */
+				adcen |= 1 << gainshift;
+			}
+		} else {
+			gainshift = (chan & ~1);
+			adcen |= 1 << chan;
+		}
+		devpriv->adcg = (devpriv->adcg & ~(3 << gainshift))
+			| (pci230_ai_gain[range] << gainshift);
+	}
+
+	/* Set channel scan list. */
+	outw(adcen, dev->iobase + PCI230_ADCEN);
+
+	/* Set channel gains. */
+	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
+
+	/* Set counter/timer 2 output high for use as the initial start
+	 * conversion source. */
+	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE1);
+
+	/* Temporarily use CT2 output as conversion trigger source and
+	 * temporarily set FIFO interrupt trigger level to 'full'. */
+	adccon |= PCI230_ADC_INT_FIFO_FULL | PCI230_ADC_TRIG_Z2CT2;
+
+	/* Enable and reset FIFO, specify FIFO trigger level full, specify
+	 * uni/bip, se/diff, and temporarily set the start conversion source
+	 * to CT2 output.  Note that CT2 output is currently high, and this
+	 * will produce a false conversion trigger on some versions of the
+	 * PCI230/260, but that will be dealt with later. */
+	devpriv->adccon = adccon;
+	outw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);
+
+	/* Delay */
+	/* Failure to include this will result in the first few channels'-worth
+	 * of data being corrupt, normally manifesting itself by large negative
+	 * voltages. It seems the board needs time to settle between the first
+	 * FIFO reset (above) and the second FIFO reset (below). Setting the
+	 * channel gains and scan list _before_ the first FIFO reset also
+	 * helps, though only slightly. */
+	comedi_udelay(25);
+
+	/* Reset FIFO again. */
+	outw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		/* Set up CT2 as conversion timer, but gate it off for now.
+		 * Note, counter/timer output 2 can be monitored on the
+		 * connector: PCI230 pin 21, PCI260 pin 18. */
+		zgat = GAT_CONFIG(2, GAT_GND);
+		outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+		/* Set counter/timer 2 to the specified conversion period. */
+		pci230_ct_setup_ns_mode(dev, 2, I8254_MODE3, cmd->convert_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (cmd->scan_begin_src != TRIG_FOLLOW) {
+			/*
+			 * Set up monostable on CT0 output for scan timing.  A
+			 * rising edge on the trigger (gate) input of CT0 will
+			 * trigger the monostable, causing its output to go low
+			 * for the configured period.  The period depends on
+			 * the conversion period and the number of conversions
+			 * in the scan.
+			 *
+			 * Set the trigger high before setting up the
+			 * monostable to stop it triggering.  The trigger
+			 * source will be changed later.
+			 */
+			zgat = GAT_CONFIG(0, GAT_VCC);
+			outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+			pci230_ct_setup_ns_mode(dev, 0, I8254_MODE1,
+				((uint64_t) cmd->convert_arg
+					* cmd->scan_end_arg), TRIG_ROUND_UP);
+			if (cmd->scan_begin_src == TRIG_TIMER) {
+				/*
+				 * Monostable on CT0 will be triggered by
+				 * output of CT1 at configured scan frequency.
+				 *
+				 * Set up CT1 but gate it off for now.
+				 */
+				zgat = GAT_CONFIG(1, GAT_GND);
+				outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
+				pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
+					cmd->scan_begin_arg,
+					cmd->flags & TRIG_ROUND_MASK);
+			}
+		}
+	}
+
+	if (cmd->start_src == TRIG_INT) {
+		s->async->inttrig = pci230_ai_inttrig_start;
+	} else {
+		/* TRIG_NOW */
+		pci230_ai_start(dev, s);
+	}
+
+	return 0;
+}
+
+static unsigned int divide_ns(uint64_t ns, unsigned int timebase,
+	unsigned int round_mode)
+{
+	uint64_t div;
+	unsigned int rem;
+
+	div = ns;
+	rem = do_div(div, timebase);
+	round_mode &= TRIG_ROUND_MASK;
+	switch (round_mode) {
+	default:
+	case TRIG_ROUND_NEAREST:
+		div += (rem + (timebase / 2)) / timebase;
+		break;
+	case TRIG_ROUND_DOWN:
+		break;
+	case TRIG_ROUND_UP:
+		div += (rem + timebase - 1) / timebase;
+		break;
+	}
+	return div > UINT_MAX ? UINT_MAX : (unsigned int)div;
+}
+
+/* Given desired period in ns, returns the required internal clock source
+ * and gets the initial count. */
+static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
+	unsigned int round_mode)
+{
+	unsigned int clk_src, cnt;
+
+	for (clk_src = CLK_10MHZ;; clk_src++) {
+		cnt = divide_ns(ns, pci230_timebase[clk_src], round_mode);
+		if ((cnt <= 65536) || (clk_src == CLK_1KHZ)) {
+			break;
+		}
+	}
+	*count = cnt;
+	return clk_src;
+}
+
+static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round)
+{
+	unsigned int count;
+	unsigned int clk_src;
+
+	clk_src = pci230_choose_clk_count(*ns, &count, round);
+	*ns = count * pci230_timebase[clk_src];
+	return;
+}
+
+static void pci230_ct_setup_ns_mode(comedi_device * dev, unsigned int ct,
+	unsigned int mode, uint64_t ns, unsigned int round)
+{
+	unsigned int clk_src;
+	unsigned int count;
+
+	/* Set mode. */
+	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, mode);
+	/* Determine clock source and count. */
+	clk_src = pci230_choose_clk_count(ns, &count, round);
+	/* Program clock source. */
+	outb(CLK_CONFIG(ct, clk_src), devpriv->iobase1 + PCI230_ZCLK_SCE);
+	/* Set initial count. */
+	if (count >= 65536) {
+		count = 0;
+	}
+	i8254_write(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, count);
+}
+
+static void pci230_cancel_ct(comedi_device * dev, unsigned int ct)
+{
+	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct,
+		I8254_MODE1);
+	/* Counter ct, 8254 mode 1, initial count not written. */
+}
+
+/* Interrupt handler */
+static irqreturn_t pci230_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	unsigned char status_int, valid_status_int;
+	comedi_device *dev = (comedi_device *) d;
+	comedi_subdevice *s;
+	unsigned long irqflags;
+
+	/* Read interrupt status/enable register. */
+	status_int = inb(devpriv->iobase1 + PCI230_INT_STAT);
+
+	if (status_int == PCI230_INT_DISABLE) {
+		return IRQ_NONE;
+	}
+
+	comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	valid_status_int = devpriv->int_en & status_int;
+	/* Disable triggered interrupts.
+	 * (Only those interrupts that need re-enabling, are, later in the
+	 * handler).  */
+	devpriv->ier = devpriv->int_en & ~status_int;
+	outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+	devpriv->intr_running = 1;
+	devpriv->intr_cpuid = THISCPU;
+	comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+
+	/*
+	 * Check the source of interrupt and handle it.
+	 * The PCI230 can cope with concurrent ADC, DAC, PPI C0 and C3
+	 * interrupts.  However, at present (Comedi-0.7.60) does not allow
+	 * concurrent execution of commands, instructions or a mixture of the
+	 * two.
+	 */
+
+	if ((valid_status_int & PCI230_INT_ZCLK_CT1) != 0) {
+		s = dev->write_subdev;
+		pci230_handle_ao_nofifo(dev, s);
+		comedi_event(dev, s);
+	}
+
+	if ((valid_status_int & PCI230P2_INT_DAC) != 0) {
+		s = dev->write_subdev;
+		pci230_handle_ao_fifo(dev, s);
+		comedi_event(dev, s);
+	}
+
+	if ((valid_status_int & PCI230_INT_ADC) != 0) {
+		s = dev->read_subdev;
+		pci230_handle_ai(dev, s);
+		comedi_event(dev, s);
+	}
+
+	/* Reenable interrupts. */
+	comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	if (devpriv->ier != devpriv->int_en) {
+		devpriv->ier = devpriv->int_en;
+		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+	}
+	devpriv->intr_running = 0;
+	comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+
+	return IRQ_HANDLED;
+}
+
+static void pci230_handle_ao_nofifo(comedi_device * dev, comedi_subdevice * s)
+{
+	sampl_t data;
+	int i, ret;
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+
+	if (!devpriv->ao_continuous && (devpriv->ao_scan_count == 0)) {
+		return;
+	}
+
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		/* Read sample from Comedi's circular buffer. */
+		ret = comedi_buf_get(s->async, &data);
+		if (ret == 0) {
+			s->async->events |= COMEDI_CB_OVERFLOW;
+			pci230_ao_stop(dev, s);
+			comedi_error(dev, "AO buffer underrun");
+			return;
+		}
+		/* Write value to DAC. */
+		pci230_ao_write_nofifo(dev, data, CR_CHAN(cmd->chanlist[i]));
+	}
+
+	async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+	if (!devpriv->ao_continuous) {
+		devpriv->ao_scan_count--;
+		if (devpriv->ao_scan_count == 0) {
+			/* End of acquisition. */
+			async->events |= COMEDI_CB_EOA;
+			pci230_ao_stop(dev, s);
+		}
+	}
+}
+
+/* Loads DAC FIFO (if using it) from buffer. */
+/* Returns 0 if AO finished due to completion or error, 1 if still going. */
+static int pci230_handle_ao_fifo(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	unsigned int num_scans;
+	unsigned int room;
+	unsigned short dacstat;
+	unsigned int i, n;
+	unsigned int bytes_per_scan;
+	unsigned int events = 0;
+	int running;
+
+	/* Get DAC FIFO status. */
+	dacstat = inw(dev->iobase + PCI230_DACCON);
+
+	/* Determine number of scans available in buffer. */
+	bytes_per_scan = cmd->chanlist_len * sizeof(sampl_t);
+	num_scans = comedi_buf_read_n_available(async) / bytes_per_scan;
+	if (!devpriv->ao_continuous) {
+		/* Fixed number of scans. */
+		if (num_scans > devpriv->ao_scan_count) {
+			num_scans = devpriv->ao_scan_count;
+		}
+		if (devpriv->ao_scan_count == 0) {
+			/* End of acquisition. */
+			events |= COMEDI_CB_EOA;
+		}
+	}
+	if (events == 0) {
+		/* Check for FIFO underrun. */
+		if ((dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) != 0) {
+			comedi_error(dev, "AO FIFO underrun");
+			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
+		}
+		/* Check for buffer underrun if FIFO less than half full
+		 * (otherwise there will be loads of "DAC FIFO not half full"
+		 * interrupts). */
+		if ((num_scans == 0)
+			&& ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {
+			comedi_error(dev, "AO buffer underrun");
+			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
+		}
+	}
+	if (events == 0) {
+		/* Determine how much room is in the FIFO (in samples). */
+		if ((dacstat & PCI230P2_DAC_FIFO_FULL) != 0) {
+			room = PCI230P2_DAC_FIFOROOM_FULL;
+		} else if ((dacstat & PCI230P2_DAC_FIFO_HALF) != 0) {
+			room = PCI230P2_DAC_FIFOROOM_HALFTOFULL;
+		} else if ((dacstat & PCI230P2_DAC_FIFO_EMPTY) != 0) {
+			room = PCI230P2_DAC_FIFOROOM_EMPTY;
+		} else {
+			room = PCI230P2_DAC_FIFOROOM_ONETOHALF;
+		}
+		/* Convert room to number of scans that can be added. */
+		room /= cmd->chanlist_len;
+		/* Determine number of scans to process. */
+		if (num_scans > room) {
+			num_scans = room;
+		}
+		/* Process scans. */
+		for (n = 0; n < num_scans; n++) {
+			for (i = 0; i < cmd->chanlist_len; i++) {
+				sampl_t datum;
+
+				comedi_buf_get(async, &datum);
+				pci230_ao_write_fifo(dev, datum,
+					CR_CHAN(cmd->chanlist[i]));
+			}
+		}
+		events |= COMEDI_CB_EOS | COMEDI_CB_BLOCK;
+		if (!devpriv->ao_continuous) {
+			devpriv->ao_scan_count -= num_scans;
+			if (devpriv->ao_scan_count == 0) {
+				/* All data for the command has been written
+				 * to FIFO.  Set FIFO interrupt trigger level
+				 * to 'empty'. */
+				devpriv->daccon = (devpriv->daccon
+					& ~PCI230P2_DAC_INT_FIFO_MASK)
+					| PCI230P2_DAC_INT_FIFO_EMPTY;
+				outw(devpriv->daccon,
+					dev->iobase + PCI230_DACCON);
+			}
+		}
+		/* Check if FIFO underrun occurred while writing to FIFO. */
+		dacstat = inw(dev->iobase + PCI230_DACCON);
+		if ((dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) != 0) {
+			comedi_error(dev, "AO FIFO underrun");
+			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
+		}
+	}
+	if ((events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
+		!= 0) {
+		/* Stopping AO due to completion or error. */
+		pci230_ao_stop(dev, s);
+		running = 0;
+	} else {
+		running = 1;
+	}
+	async->events |= events;
+	return running;
+}
+
+static void pci230_handle_ai(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned int events = 0;
+	unsigned int status_fifo;
+	unsigned int i;
+	unsigned int todo;
+	unsigned int fifoamount;
+	comedi_async *async = s->async;
+	unsigned int scanlen = async->cmd.scan_end_arg;
+
+	/* Determine number of samples to read. */
+	if (devpriv->ai_continuous) {
+		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
+	} else if (devpriv->ai_scan_count == 0) {
+		todo = 0;
+	} else if ((devpriv->ai_scan_count > PCI230_ADC_FIFOLEVEL_HALFFULL)
+		|| (scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL)) {
+		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
+	} else {
+		todo = (devpriv->ai_scan_count * scanlen)
+			- devpriv->ai_scan_pos;
+		if (todo > PCI230_ADC_FIFOLEVEL_HALFFULL) {
+			todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
+		}
+	}
+
+	if (todo == 0) {
+		return;
+	}
+
+	fifoamount = 0;
+	for (i = 0; i < todo; i++) {
+		if (fifoamount == 0) {
+			/* Read FIFO state. */
+			status_fifo = inw(dev->iobase + PCI230_ADCCON);
+
+			if ((status_fifo & PCI230_ADC_FIFO_FULL_LATCHED) != 0) {
+				/* Report error otherwise FIFO overruns will go
+				 * unnoticed by the caller. */
+				comedi_error(dev, "AI FIFO overrun");
+				events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
+				break;
+			} else if ((status_fifo & PCI230_ADC_FIFO_EMPTY) != 0) {
+				/* FIFO empty. */
+				break;
+			} else if ((status_fifo & PCI230_ADC_FIFO_HALF) != 0) {
+				/* FIFO half full. */
+				fifoamount = PCI230_ADC_FIFOLEVEL_HALFFULL;
+			} else {
+				/* FIFO not empty. */
+				if (devpriv->hwver > 0) {
+					/* Read PCI230+/260+ ADC FIFO level. */
+					fifoamount = inw(dev->iobase
+						+ PCI230P_ADCFFLEV);
+					if (fifoamount == 0) {
+						/* Shouldn't happen. */
+						break;
+					}
+				} else {
+					fifoamount = 1;
+				}
+			}
+		}
+
+		/* Read sample and store in Comedi's circular buffer. */
+		if (comedi_buf_put(async, pci230_ai_read(dev)) == 0) {
+			events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
+			comedi_error(dev, "AI buffer overflow");
+			break;
+		}
+		fifoamount--;
+		devpriv->ai_scan_pos++;
+		if (devpriv->ai_scan_pos == scanlen) {
+			/* End of scan. */
+			devpriv->ai_scan_pos = 0;
+			devpriv->ai_scan_count--;
+			async->events |= COMEDI_CB_EOS;
+		}
+	}
+
+	if (!devpriv->ai_continuous && (devpriv->ai_scan_count == 0)) {
+		/* End of acquisition. */
+		events |= COMEDI_CB_EOA;
+	} else {
+		/* More samples required, tell Comedi to block. */
+		events |= COMEDI_CB_BLOCK;
+	}
+	async->events |= events;
+
+	if ((async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
+				COMEDI_CB_OVERFLOW)) != 0) {
+		/* disable hardware conversions */
+		pci230_ai_stop(dev, s);
+	} else {
+		/* update FIFO interrupt trigger level */
+		pci230_ai_update_fifo_trigger_level(dev, s);
+	}
+}
+
+static void pci230_ao_stop(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long irqflags;
+	unsigned char intsrc;
+	int started;
+	comedi_cmd *cmd;
+
+	comedi_spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
+	started = test_and_clear_bit(AO_CMD_STARTED, &devpriv->state);
+	comedi_spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
+	if (!started) {
+		return;
+	}
+
+	cmd = &s->async->cmd;
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		/* Stop scan rate generator. */
+		pci230_cancel_ct(dev, 1);
+	}
+
+	/* Determine interrupt source. */
+	if (devpriv->hwver < 2) {
+		/* Not using DAC FIFO.  Using CT1 interrupt. */
+		intsrc = PCI230_INT_ZCLK_CT1;
+	} else {
+		/* Using DAC FIFO interrupt. */
+		intsrc = PCI230P2_INT_DAC;
+	}
+	/* Disable interrupt and wait for interrupt routine to finish running
+	 * unless we are called from the interrupt routine. */
+	comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	devpriv->int_en &= ~intsrc;
+	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
+		comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+		comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	}
+	if (devpriv->ier != devpriv->int_en) {
+		devpriv->ier = devpriv->int_en;
+		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+
+	if (devpriv->hwver >= 2) {
+		/* Using DAC FIFO.  Reset FIFO, clear underrun error,
+		 * disable FIFO. */
+		devpriv->daccon &= PCI230_DAC_OR_MASK;
+		outw(devpriv->daccon | PCI230P2_DAC_FIFO_RESET
+			| PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,
+			dev->iobase + PCI230_DACCON);
+	}
+
+	/* Release resources. */
+	put_all_resources(dev, OWNER_AOCMD);
+}
+
+static int pci230_ao_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	pci230_ao_stop(dev, s);
+	return 0;
+}
+
+static void pci230_ai_stop(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long irqflags;
+	comedi_cmd *cmd;
+	int started;
+
+	comedi_spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
+	started = test_and_clear_bit(AI_CMD_STARTED, &devpriv->state);
+	comedi_spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
+	if (!started) {
+		return;
+	}
+
+	cmd = &s->async->cmd;
+	if (cmd->convert_src == TRIG_TIMER) {
+		/* Stop conversion rate generator. */
+		pci230_cancel_ct(dev, 2);
+	}
+	if (cmd->scan_begin_src != TRIG_FOLLOW) {
+		/* Stop scan period monostable. */
+		pci230_cancel_ct(dev, 0);
+	}
+
+	comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	/* Disable ADC interrupt and wait for interrupt routine to finish
+	 * running unless we are called from the interrupt routine. */
+	devpriv->int_en &= ~PCI230_INT_ADC;
+	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
+		comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+		comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	}
+	if (devpriv->ier != devpriv->int_en) {
+		devpriv->ier = devpriv->int_en;
+		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+
+	/* Reset FIFO, disable FIFO and set start conversion source to none.
+	 * Keep se/diff and bip/uni settings */
+	devpriv->adccon = (devpriv->adccon & (PCI230_ADC_IR_MASK
+			| PCI230_ADC_IM_MASK)) | PCI230_ADC_TRIG_NONE;
+	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
+		dev->iobase + PCI230_ADCCON);
+
+	/* Release resources. */
+	put_all_resources(dev, OWNER_AICMD);
+}
+
+static int pci230_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	pci230_ai_stop(dev, s);
+	return 0;
+}
