commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 115911bbe8ad..8cf09ef3012f 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -6,16 +6,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 /*
  * Driver: das800

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index fd4cb4911671..115911bbe8ad 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * comedi/drivers/das800.c
  * Driver for Keitley das800 series boards and compatibles

commit deecca61b3d33221bd3d30241dd083d53de67aa1
Author: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
Date:   Tue Jun 7 14:06:18 2016 +0530

    Staging: comedi: fix comment issue fixed for das800.c
    
    This is a patch to the das800.c file that fixes up a
    WARNING: 'Block comments use a trailing */ on a separate line'
    found by the checkpatch.pl tool
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 9059872b407b..fd4cb4911671 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -1,56 +1,56 @@
 /*
-    comedi/drivers/das800.c
-    Driver for Keitley das800 series boards and compatibles
-    Copyright (C) 2000 Frank Mori Hess <fmhess@users.sourceforge.net>
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
+ * comedi/drivers/das800.c
+ * Driver for Keitley das800 series boards and compatibles
+ * Copyright (C) 2000 Frank Mori Hess <fmhess@users.sourceforge.net>
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 /*
-Driver: das800
-Description: Keithley Metrabyte DAS800 (& compatibles)
-Author: Frank Mori Hess <fmhess@users.sourceforge.net>
-Devices: [Keithley Metrabyte] DAS-800 (das-800), DAS-801 (das-801),
-  DAS-802 (das-802),
-  [Measurement Computing] CIO-DAS800 (cio-das800),
-  CIO-DAS801 (cio-das801), CIO-DAS802 (cio-das802),
-  CIO-DAS802/16 (cio-das802/16)
-Status: works, cio-das802/16 untested - email me if you have tested it
-
-Configuration options:
-  [0] - I/O port base address
-  [1] - IRQ (optional, required for timed or externally triggered conversions)
-
-Notes:
-	IRQ can be omitted, although the cmd interface will not work without it.
-
-	All entries in the channel/gain list must use the same gain and be
-	consecutive channels counting upwards in channel number (these are
-	hardware limitations.)
-
-	I've never tested the gain setting stuff since I only have a
-	DAS-800 board with fixed gain.
-
-	The cio-das802/16 does not have a fifo-empty status bit!  Therefore
-	only fifo-half-full transfers are possible with this card.
-
-cmd triggers supported:
-	start_src:      TRIG_NOW | TRIG_EXT
-	scan_begin_src: TRIG_FOLLOW
-	scan_end_src:   TRIG_COUNT
-	convert_src:    TRIG_TIMER | TRIG_EXT
-	stop_src:       TRIG_NONE | TRIG_COUNT
-*/
+ * Driver: das800
+ * Description: Keithley Metrabyte DAS800 (& compatibles)
+ * Author: Frank Mori Hess <fmhess@users.sourceforge.net>
+ * Devices: [Keithley Metrabyte] DAS-800 (das-800), DAS-801 (das-801),
+ * DAS-802 (das-802),
+ * [Measurement Computing] CIO-DAS800 (cio-das800),
+ * CIO-DAS801 (cio-das801), CIO-DAS802 (cio-das802),
+ * CIO-DAS802/16 (cio-das802/16)
+ * Status: works, cio-das802/16 untested - email me if you have tested it
+ *
+ * Configuration options:
+ * [0] - I/O port base address
+ * [1] - IRQ (optional, required for timed or externally triggered conversions)
+ *
+ * Notes:
+ *	IRQ can be omitted, although the cmd interface will not work without it.
+ *
+ *	All entries in the channel/gain list must use the same gain and be
+ *	consecutive channels counting upwards in channel number (these are
+ *	hardware limitations.)
+ *
+ *	I've never tested the gain setting stuff since I only have a
+ *	DAS-800 board with fixed gain.
+ *
+ *	The cio-das802/16 does not have a fifo-empty status bit!  Therefore
+ *	only fifo-half-full transfers are possible with this card.
+ *
+ * cmd triggers supported:
+ *	start_src:      TRIG_NOW | TRIG_EXT
+ *	scan_begin_src: TRIG_FOLLOW
+ *	scan_end_src:   TRIG_COUNT
+ *	convert_src:    TRIG_TIMER | TRIG_EXT
+ *	stop_src:       TRIG_NONE | TRIG_COUNT
+ */
 
 #include <linux/module.h>
 #include <linux/interrupt.h>

commit f7ede00d609d24dae6ef47d294630e81b8ce3091
Author: Nikita Eshkeev <kastolom@gmail.com>
Date:   Tue May 3 18:22:23 2016 +0300

    staging:comedi:Use unsigned int instead of unsigned
    
    This patch fixed the checkpatch.pl warning:
    
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Signed-off-by: Nikita Eshkeev <kastolom@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index b02f12201cf7..9059872b407b 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -218,7 +218,7 @@ struct das800_private {
 };
 
 static void das800_ind_write(struct comedi_device *dev,
-			     unsigned val, unsigned reg)
+			     unsigned int val, unsigned int reg)
 {
 	/*
 	 * Select dev->iobase + 2 to be desired register
@@ -228,7 +228,7 @@ static void das800_ind_write(struct comedi_device *dev,
 	outb(val, dev->iobase + 2);
 }
 
-static unsigned das800_ind_read(struct comedi_device *dev, unsigned reg)
+static unsigned int das800_ind_read(struct comedi_device *dev, unsigned int reg)
 {
 	/*
 	 * Select dev->iobase + 7 to be desired register

commit 4f3aa186d325f469c142ce8c804548e2b2f18a9d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 18 10:54:48 2015 -0700

    staging: comedi: das800: rename 'thisboard' variables
    
    For aesthetics, rename the 'thisboard' variables to 'board'. That name
    is more commonly used for the boardinfo pointer in comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index bc9fa4b317b2..b02f12201cf7 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -240,13 +240,13 @@ static unsigned das800_ind_read(struct comedi_device *dev, unsigned reg)
 
 static void das800_enable(struct comedi_device *dev)
 {
-	const struct das800_board *thisboard = dev->board_ptr;
+	const struct das800_board *board = dev->board_ptr;
 	struct das800_private *devpriv = dev->private;
 	unsigned long irq_flags;
 
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	/*  enable fifo-half full interrupts for cio-das802/16 */
-	if (thisboard->resolution == 16)
+	if (board->resolution == 16)
 		outb(CIO_ENHF, dev->iobase + DAS800_GAIN);
 	/* enable hardware triggering */
 	das800_ind_write(dev, CONV_HCEN, CONV_CONTROL);
@@ -303,7 +303,7 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
 {
-	const struct das800_board *thisboard = dev->board_ptr;
+	const struct das800_board *board = dev->board_ptr;
 	int err = 0;
 
 	/* Step 1 : check if triggers are trivially valid */
@@ -335,7 +335,7 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
-						    thisboard->ai_speed);
+						    board->ai_speed);
 	}
 
 	err |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);
@@ -375,7 +375,7 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 static int das800_ai_do_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	const struct das800_board *thisboard = dev->board_ptr;
+	const struct das800_board *board = dev->board_ptr;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int gain = CR_RANGE(cmd->chanlist[0]);
@@ -393,7 +393,7 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	/* set gain */
-	if (thisboard->resolution == 12 && gain > 0)
+	if (board->resolution == 12 && gain > 0)
 		gain += 0x7;
 	gain &= 0xf;
 	outb(gain, dev->iobase + DAS800_GAIN);
@@ -606,8 +606,8 @@ static int das800_do_insn_bits(struct comedi_device *dev,
 
 static const struct das800_board *das800_probe(struct comedi_device *dev)
 {
-	const struct das800_board *thisboard = dev->board_ptr;
-	int index = thisboard ? thisboard - das800_boards : -EINVAL;
+	const struct das800_board *board = dev->board_ptr;
+	int index = board ? board - das800_boards : -EINVAL;
 	int id_bits;
 	unsigned long irq_flags;
 
@@ -628,18 +628,18 @@ static const struct das800_board *das800_probe(struct comedi_device *dev)
 	switch (id_bits) {
 	case 0x0:
 		if (index == BOARD_DAS800 || index == BOARD_CIODAS800)
-			return thisboard;
+			return board;
 		index = BOARD_DAS800;
 		break;
 	case 0x2:
 		if (index == BOARD_DAS801 || index == BOARD_CIODAS801)
-			return thisboard;
+			return board;
 		index = BOARD_DAS801;
 		break;
 	case 0x3:
 		if (index == BOARD_DAS802 || index == BOARD_CIODAS802 ||
 		    index == BOARD_CIODAS80216)
-			return thisboard;
+			return board;
 		index = BOARD_DAS802;
 		break;
 	default:
@@ -655,7 +655,7 @@ static const struct das800_board *das800_probe(struct comedi_device *dev)
 
 static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct das800_board *thisboard;
+	const struct das800_board *board;
 	struct das800_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned int irq = it->options[1];
@@ -670,11 +670,11 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	thisboard = das800_probe(dev);
-	if (!thisboard)
+	board = das800_probe(dev);
+	if (!board)
 		return -ENODEV;
-	dev->board_ptr = thisboard;
-	dev->board_name = thisboard->name;
+	dev->board_ptr = board;
+	dev->board_name = board->name;
 
 	if (irq > 1 && irq <= 7) {
 		ret = request_irq(irq, das800_interrupt, 0, dev->board_name,
@@ -698,8 +698,8 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->type		= COMEDI_SUBD_AI;
 	s->subdev_flags	= SDF_READABLE | SDF_GROUND;
 	s->n_chan	= 8;
-	s->maxdata	= (1 << thisboard->resolution) - 1;
-	s->range_table	= thisboard->ai_range;
+	s->maxdata	= (1 << board->resolution) - 1;
+	s->range_table	= board->ai_range;
 	s->insn_read	= das800_ai_insn_read;
 	if (dev->irq) {
 		s->subdev_flags	|= SDF_CMD_READ;

commit a69153f66f3caef506a6a03a6f6ba76f75f57d29
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 18 10:54:47 2015 -0700

    staging: comedi: das800: cleanup das800_probe()
    
    Make this function return a pointer to the boardinfo instead of an index.
     Since it's not typical, add a comment to clarify why this legacy driver
    does a probe. For aesthetics, rename the local variable 'board' to 'index.
    
    Consolidate the dev_dbg() messages when a probed boardinfo is used and
    remove the extra dev_dbg() message when the boardinfo is not found.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 39d304a1259f..bc9fa4b317b2 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -604,44 +604,53 @@ static int das800_do_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int das800_probe(struct comedi_device *dev)
+static const struct das800_board *das800_probe(struct comedi_device *dev)
 {
 	const struct das800_board *thisboard = dev->board_ptr;
-	int board = thisboard ? thisboard - das800_boards : -EINVAL;
+	int index = thisboard ? thisboard - das800_boards : -EINVAL;
 	int id_bits;
 	unsigned long irq_flags;
 
+	/*
+	 * The dev->board_ptr will be set by comedi_device_attach() if the
+	 * board name provided by the user matches a board->name in this
+	 * driver. If so, this function sanity checks the id_bits to verify
+	 * that the board is correct.
+	 *
+	 * If the dev->board_ptr is not set, the user is trying to attach
+	 * an unspecified board to this driver. In this case the id_bits
+	 * are used to 'probe' for the correct dev->board_ptr.
+	 */
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	id_bits = das800_ind_read(dev, ID) & 0x3;
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	switch (id_bits) {
 	case 0x0:
-		if (board == BOARD_DAS800 || board == BOARD_CIODAS800)
-			break;
-		dev_dbg(dev->class_dev, "Board model (probed): DAS-800\n");
-		board = BOARD_DAS800;
+		if (index == BOARD_DAS800 || index == BOARD_CIODAS800)
+			return thisboard;
+		index = BOARD_DAS800;
 		break;
 	case 0x2:
-		if (board == BOARD_DAS801 || board == BOARD_CIODAS801)
-			break;
-		dev_dbg(dev->class_dev, "Board model (probed): DAS-801\n");
-		board = BOARD_DAS801;
+		if (index == BOARD_DAS801 || index == BOARD_CIODAS801)
+			return thisboard;
+		index = BOARD_DAS801;
 		break;
 	case 0x3:
-		if (board == BOARD_DAS802 || board == BOARD_CIODAS802 ||
-		    board == BOARD_CIODAS80216)
-			break;
-		dev_dbg(dev->class_dev, "Board model (probed): DAS-802\n");
-		board = BOARD_DAS802;
+		if (index == BOARD_DAS802 || index == BOARD_CIODAS802 ||
+		    index == BOARD_CIODAS80216)
+			return thisboard;
+		index = BOARD_DAS802;
 		break;
 	default:
 		dev_dbg(dev->class_dev, "Board model: 0x%x (unknown)\n",
 			id_bits);
-		board = -EINVAL;
-		break;
+		return NULL;
 	}
-	return board;
+	dev_dbg(dev->class_dev, "Board model (probed): %s series\n",
+		das800_boards[index].name);
+
+	return &das800_boards[index];
 }
 
 static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -651,7 +660,6 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	unsigned int irq = it->options[1];
 	unsigned long irq_flags;
-	int board;
 	int ret;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
@@ -662,13 +670,10 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	board = das800_probe(dev);
-	if (board < 0) {
-		dev_dbg(dev->class_dev, "unable to determine board type\n");
+	thisboard = das800_probe(dev);
+	if (!thisboard)
 		return -ENODEV;
-	}
-	dev->board_ptr = das800_boards + board;
-	thisboard = dev->board_ptr;
+	dev->board_ptr = thisboard;
 	dev->board_name = thisboard->name;
 
 	if (irq > 1 && irq <= 7) {

commit 5519108b114e7a5bc012d51e33a2d651efe4047a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:12 2015 +0000

    staging: comedi: das800: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index ece3e56a72bb..39d304a1259f 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -58,7 +58,6 @@ cmd triggers supported:
 
 #include "../comedidev.h"
 
-#include "comedi_fc.h"
 #include "comedi_8254.h"
 
 #define N_CHAN_AI             8	/*  number of analog input channels */
@@ -309,20 +308,21 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);
+	err |= comedi_check_trigger_src(&cmd->convert_src,
+					TRIG_TIMER | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -331,19 +331,21 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->convert_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 thisboard->ai_speed);
+	if (cmd->convert_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
+						    thisboard->ai_speed);
+	}
 
-	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -354,7 +356,7 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 		unsigned int arg = cmd->convert_arg;
 
 		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
 	if (err)

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 50ca03bd6459..ece3e56a72bb 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -43,8 +43,6 @@ Configuration options:
 
 	The cio-das802/16 does not have a fifo-empty status bit!  Therefore
 	only fifo-half-full transfers are possible with this card.
-*/
-/*
 
 cmd triggers supported:
 	start_src:      TRIG_NOW | TRIG_EXT
@@ -52,8 +50,6 @@ cmd triggers supported:
 	scan_end_src:   TRIG_COUNT
 	convert_src:    TRIG_TIMER | TRIG_EXT
 	stop_src:       TRIG_NONE | TRIG_COUNT
-
-
 */
 
 #include <linux/module.h>

commit e4690dec50ebb886b33a62858d13266ee020e035
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:57:37 2015 -0700

    staging: comedi: das800: convert driver to use the comedi_8254 module
    
    This driver uses an 8254 timer to generate the pacer clock used for analog
    input data acquisition. Convert it to use the comedi_8254 module to provide
    support for the 8254 timer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index ff7f4be3f314..50ca03bd6459 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -58,12 +58,12 @@ cmd triggers supported:
 
 #include <linux/module.h>
 #include <linux/interrupt.h>
-#include "../comedidev.h"
-
 #include <linux/delay.h>
 
-#include "8253.h"
+#include "../comedidev.h"
+
 #include "comedi_fc.h"
+#include "comedi_8254.h"
 
 #define N_CHAN_AI             8	/*  number of analog input channels */
 
@@ -219,8 +219,6 @@ static const struct das800_board das800_boards[] = {
 };
 
 struct das800_private {
-	unsigned int divisor1;	/* counter 1 value for timed conversions */
-	unsigned int divisor2;	/* counter 2 value for timed conversions */
 	unsigned int do_bits;	/* digital output bits */
 };
 
@@ -272,17 +270,6 @@ static void das800_disable(struct comedi_device *dev)
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
-static void das800_set_frequency(struct comedi_device *dev)
-{
-	struct das800_private *devpriv = dev->private;
-	unsigned long timer_base = dev->iobase + DAS800_8254;
-
-	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
-	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
-	i8254_write(timer_base, 0, 1, devpriv->divisor1);
-	i8254_write(timer_base, 0, 2, devpriv->divisor2);
-}
-
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	das800_disable(dev);
@@ -322,9 +309,7 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 				struct comedi_cmd *cmd)
 {
 	const struct das800_board *thisboard = dev->board_ptr;
-	struct das800_private *devpriv = dev->private;
 	int err = 0;
-	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -370,11 +355,9 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		arg = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_1MHZ,
-					  &devpriv->divisor1,
-					  &devpriv->divisor2,
-					  &arg, cmd->flags);
+		unsigned int arg = cmd->convert_arg;
+
+		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
@@ -426,8 +409,8 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 		conv_bits |= DTEN;
 	if (cmd->convert_src == TRIG_TIMER) {
 		conv_bits |= CASC | ITE;
-		/* set conversion frequency */
-		das800_set_frequency(dev);
+		comedi_8254_update_divisors(dev->pacer);
+		comedi_8254_pacer_enable(dev->pacer, 1, 2, true);
 	}
 
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
@@ -697,6 +680,11 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			dev->irq = irq;
 	}
 
+	dev->pacer = comedi_8254_init(dev->iobase + DAS800_8254,
+				      I8254_OSC_BASE_1MHZ, I8254_IO8, 0);
+	if (!dev->pacer)
+		return -ENOMEM;
+
 	ret = comedi_alloc_subdevices(dev, 3);
 	if (ret)
 		return ret;

commit 3e6cb74f5632e1ac2b4209b4d2c64fca43e2838b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:02 2015 -0700

    staging: comedi: drivers: remove inappropriate COMEDI_CB_EOA events
    
    Hardware errors should be reported with the COMEDI_CB_ERROR event. This event
    will cause the async command to cancel. It's not necessary to also set the
    COMEDI_CB_EOA event. Remove these events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index e5bdc2423445..ff7f4be3f314 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -511,7 +511,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 
 	if (fifo_overflow) {
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		async->events |= COMEDI_CB_ERROR;
 		comedi_handle_events(dev, s);
 		return IRQ_HANDLED;
 	}

commit 5e62863aea463c9bf24538315327d0922be35d64
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:21:09 2014 -0700

    staging: comedi: das800: use comedi_async 'scans_done' to detect EOA
    
    Remove the private data member 'count' and use the comedi_async 'scans_done'
    member to detect the end-of-acquisition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 55bc494838b5..e5bdc2423445 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -219,7 +219,6 @@ static const struct das800_board das800_boards[] = {
 };
 
 struct das800_private {
-	unsigned int count;	/* number of data points left to be taken */
 	unsigned int divisor1;	/* counter 1 value for timed conversions */
 	unsigned int divisor2;	/* counter 2 value for timed conversions */
 	unsigned int do_bits;	/* digital output bits */
@@ -286,9 +285,6 @@ static void das800_set_frequency(struct comedi_device *dev)
 
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct das800_private *devpriv = dev->private;
-
-	devpriv->count = 0;
 	das800_disable(dev);
 	return 0;
 }
@@ -399,7 +395,6 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
 	const struct das800_board *thisboard = dev->board_ptr;
-	struct das800_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int gain = CR_RANGE(cmd->chanlist[0]);
@@ -422,11 +417,6 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	gain &= 0xf;
 	outb(gain, dev->iobase + DAS800_GAIN);
 
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->count = cmd->stop_arg * cmd->chanlist_len;
-	else	/* TRIG_NONE */
-		devpriv->count = 0;
-
 	/* enable auto channel scan, send interrupts on end of conversion
 	 * and set clock source to internal or external
 	 */
@@ -509,11 +499,13 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 		if (s->maxdata == 0x0fff)
 			val >>= 4;	/* 12-bit sample */
 
-		/* if there are more data points to collect */
-		if (cmd->stop_src == TRIG_NONE || devpriv->count > 0) {
-			val &= s->maxdata;
-			comedi_buf_write_samples(s, &val, 1);
-			devpriv->count--;
+		val &= s->maxdata;
+		comedi_buf_write_samples(s, &val, 1);
+
+		if (cmd->stop_src == TRIG_COUNT &&
+		    async->scans_done >= cmd->stop_arg) {
+			async->events |= COMEDI_CB_EOA;
+			break;
 		}
 	}
 
@@ -524,9 +516,11 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	if (cmd->stop_src == TRIG_NONE || devpriv->count > 0) {
-		/* Re-enable card's interrupt.
-		 * We already have spinlock, so indirect addressing is safe */
+	if (!(async->events & COMEDI_CB_CANCEL_MASK)) {
+		/*
+		 * Re-enable card's interrupt.
+		 * We already have spinlock, so indirect addressing is safe
+		 */
 		das800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits,
 				 CONTROL1);
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
@@ -534,7 +528,6 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 		/* otherwise, stop taking data */
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		das800_disable(dev);
-		async->events |= COMEDI_CB_EOA;
 	}
 	comedi_handle_events(dev, s);
 	return IRQ_HANDLED;

commit 453fd2b395799fa2e83e3e926ff7fee810d26f92
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:19:36 2014 -0700

    staging: comedi: drivers: digital output subdevices do not need SDF_READABLE
    
    The SDF_READABLE flag is not necessary for digital output subdevices. For
    consistency, remove this flag from the comedi drivers that set it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 6013099891c0..55bc494838b5 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -737,7 +737,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* Digital Output subdevice */
 	s = &dev->subdevices[2];
 	s->type		= COMEDI_SUBD_DO;
-	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE;
+	s->subdev_flags	= SDF_WRITABLE;
 	s->n_chan	= 4;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;

commit ad9eb43c93d83578674e1da78a0bd792c3a22513
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:27 2014 -0700

    staging: comedi: das800: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() instead of cfc_write_to_buffer() to add the
    single sample to the async buffer.
    
    The core will add the COMEDI_CB_BLOCK event when data is written to the
    async buffer. Remove the unnecessary event from the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index e284d202b7e7..6013099891c0 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -511,12 +511,11 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 
 		/* if there are more data points to collect */
 		if (cmd->stop_src == TRIG_NONE || devpriv->count > 0) {
-			/* write data point to buffer */
-			cfc_write_to_buffer(s, val & s->maxdata);
+			val &= s->maxdata;
+			comedi_buf_write_samples(s, &val, 1);
 			devpriv->count--;
 		}
 	}
-	async->events |= COMEDI_CB_BLOCK;
 
 	if (fifo_overflow) {
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);

commit 837a12643bd8367e0999b73a9a1e746fa52863f0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:22 2014 -0700

    staging: comedi: das800: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index d75e5528258c..e284d202b7e7 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -521,7 +521,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	if (fifo_overflow) {
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		cfc_handle_events(dev, s);
+		comedi_handle_events(dev, s);
 		return IRQ_HANDLED;
 	}
 
@@ -537,7 +537,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 		das800_disable(dev);
 		async->events |= COMEDI_CB_EOA;
 	}
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 	return IRQ_HANDLED;
 }
 

commit b77930940d2a3b9d69cbe1b637159bab6a1ade25
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:30 2014 +0100

    staging: comedi: das800: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index cbbb29797b83..d75e5528258c 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -248,7 +248,7 @@ static unsigned das800_ind_read(struct comedi_device *dev, unsigned reg)
 
 static void das800_enable(struct comedi_device *dev)
 {
-	const struct das800_board *thisboard = comedi_board(dev);
+	const struct das800_board *thisboard = dev->board_ptr;
 	struct das800_private *devpriv = dev->private;
 	unsigned long irq_flags;
 
@@ -325,7 +325,7 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
 {
-	const struct das800_board *thisboard = comedi_board(dev);
+	const struct das800_board *thisboard = dev->board_ptr;
 	struct das800_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int arg;
@@ -398,7 +398,7 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 static int das800_ai_do_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	const struct das800_board *thisboard = comedi_board(dev);
+	const struct das800_board *thisboard = dev->board_ptr;
 	struct das800_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -633,7 +633,7 @@ static int das800_do_insn_bits(struct comedi_device *dev,
 
 static int das800_probe(struct comedi_device *dev)
 {
-	const struct das800_board *thisboard = comedi_board(dev);
+	const struct das800_board *thisboard = dev->board_ptr;
 	int board = thisboard ? thisboard - das800_boards : -EINVAL;
 	int id_bits;
 	unsigned long irq_flags;
@@ -695,7 +695,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENODEV;
 	}
 	dev->board_ptr = das800_boards + board;
-	thisboard = comedi_board(dev);
+	thisboard = dev->board_ptr;
 	dev->board_name = thisboard->name;
 
 	if (irq > 1 && irq <= 7) {

commit 862755ec07572036b0c69d738b88f89b6beede99
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:22 2014 -0700

    staging: comedi: drivers: remove unnecessary *_SIZE defines
    
    Some of the legacy comedi drivers have a *_SIZE define that is only
    passed to comedi_request_region() to specify the size of the region.
    
    Some of the pnp drivers (pci, etc.) also have a *_SIZE define which
    is unused.
    
    For aesthetics, remove these defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 6f7f8d531dd5..cbbb29797b83 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -65,7 +65,6 @@ cmd triggers supported:
 #include "8253.h"
 #include "comedi_fc.h"
 
-#define DAS800_SIZE           8
 #define N_CHAN_AI             8	/*  number of analog input channels */
 
 /* Registers for the das800 */
@@ -686,7 +685,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!devpriv)
 		return -ENOMEM;
 
-	ret = comedi_request_region(dev, it->options[0], DAS800_SIZE);
+	ret = comedi_request_region(dev, it->options[0], 0x8);
 	if (ret)
 		return ret;
 

commit 9dad12fe4746c091ba7304bbd690f4a05fb1216a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:46 2014 -0700

    staging: comedi: das800: remove 'forever' from private data
    
    This member of the private data can be determined from the
    cmd->stop_src. Do that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 1e2e3d56d9fe..6f7f8d531dd5 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -224,7 +224,6 @@ struct das800_private {
 	unsigned int divisor1;	/* counter 1 value for timed conversions */
 	unsigned int divisor2;	/* counter 2 value for timed conversions */
 	unsigned int do_bits;	/* digital output bits */
-	bool forever;		/* flag that we should take data forever */
 };
 
 static void das800_ind_write(struct comedi_device *dev,
@@ -290,7 +289,6 @@ static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct das800_private *devpriv = dev->private;
 
-	devpriv->forever = false;
 	devpriv->count = 0;
 	das800_disable(dev);
 	return 0;
@@ -425,13 +423,10 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	gain &= 0xf;
 	outb(gain, dev->iobase + DAS800_GAIN);
 
-	if (cmd->stop_src == TRIG_COUNT) {
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->count = cmd->stop_arg * cmd->chanlist_len;
-		devpriv->forever = false;
-	} else {	/* TRIG_NONE */
-		devpriv->forever = true;
+	else	/* TRIG_NONE */
 		devpriv->count = 0;
-	}
 
 	/* enable auto channel scan, send interrupts on end of conversion
 	 * and set clock source to internal or external
@@ -467,7 +462,8 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct das800_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_async *async = s ? s->async : NULL;
+	struct comedi_async *async;
+	struct comedi_cmd *cmd;
 	unsigned long irq_flags;
 	unsigned int status;
 	unsigned int val;
@@ -481,6 +477,9 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	if (!dev->attached)
 		return IRQ_HANDLED;
 
+	async = s->async;
+	cmd = &async->cmd;
+
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	status = das800_ind_read(dev, CONTROL1) & STATUS2_HCEN;
 	/*
@@ -512,7 +511,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 			val >>= 4;	/* 12-bit sample */
 
 		/* if there are more data points to collect */
-		if (devpriv->count > 0 || devpriv->forever) {
+		if (cmd->stop_src == TRIG_NONE || devpriv->count > 0) {
 			/* write data point to buffer */
 			cfc_write_to_buffer(s, val & s->maxdata);
 			devpriv->count--;
@@ -527,7 +526,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	if (devpriv->count > 0 || devpriv->forever) {
+	if (cmd->stop_src == TRIG_NONE || devpriv->count > 0) {
 		/* Re-enable card's interrupt.
 		 * We already have spinlock, so indirect addressing is safe */
 		das800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits,

commit 8ffffae6cf20099f03a9bb178b5c2f2c006b94a5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:45 2014 -0700

    staging: comedi: das800: add a local var for the comedi_cmd pointer
    
    For aesthetics, use a local variable to access the comedi_cmd as a
    pointer in das800_ai_do_cmd() instead of getting to it from the
    comedi_async pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 38f6a6d9e1dc..1e2e3d56d9fe 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -404,9 +404,10 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
-	unsigned int gain = CR_RANGE(async->cmd.chanlist[0]);
-	unsigned int start_chan = CR_CHAN(async->cmd.chanlist[0]);
-	unsigned int end_chan = (start_chan + async->cmd.chanlist_len - 1) % 8;
+	struct comedi_cmd *cmd = &async->cmd;
+	unsigned int gain = CR_RANGE(cmd->chanlist[0]);
+	unsigned int start_chan = CR_CHAN(cmd->chanlist[0]);
+	unsigned int end_chan = (start_chan + cmd->chanlist_len - 1) % 8;
 	unsigned int scan_chans = (end_chan << 3) | start_chan;
 	int conv_bits;
 	unsigned long irq_flags;
@@ -424,8 +425,8 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	gain &= 0xf;
 	outb(gain, dev->iobase + DAS800_GAIN);
 
-	if (async->cmd.stop_src == TRIG_COUNT) {
-		devpriv->count = async->cmd.stop_arg * async->cmd.chanlist_len;
+	if (cmd->stop_src == TRIG_COUNT) {
+		devpriv->count = cmd->stop_arg * cmd->chanlist_len;
 		devpriv->forever = false;
 	} else {	/* TRIG_NONE */
 		devpriv->forever = true;
@@ -437,9 +438,9 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	 */
 	conv_bits = 0;
 	conv_bits |= EACS | IEOC;
-	if (async->cmd.start_src == TRIG_EXT)
+	if (cmd->start_src == TRIG_EXT)
 		conv_bits |= DTEN;
-	if (async->cmd.convert_src == TRIG_TIMER) {
+	if (cmd->convert_src == TRIG_TIMER) {
 		conv_bits |= CASC | ITE;
 		/* set conversion frequency */
 		das800_set_frequency(dev);

commit 58245cc968b1e44bbc3055a8fac25ed3449914a9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:12:47 2014 -0700

    staging: comedi: das800: use comedi_fc helpers to validate timer args
    
    Use the comedi_fc helper cfc_check_trigger_arg_is() to validate the
    trigger arguments when the source is TRIG_TIMER.
    
    All the arguments are unsigned int, change the local variable to an
    unsigned int and rename it for aesthetic reasons.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 615ae3f1c6cc..38f6a6d9e1dc 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -331,6 +331,7 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
 	int err = 0;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -376,15 +377,12 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		int tmp = cmd->convert_arg;
-
-		/* calculate counter values that give desired timing */
+		arg = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_1MHZ,
 					  &devpriv->divisor1,
 					  &devpriv->divisor2,
-					  &cmd->convert_arg, cmd->flags);
-		if (tmp != cmd->convert_arg)
-			err++;
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
 	if (err)

commit 52c9e62cf3247cb0599197e7a27356e6a2513a80
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:55 2014 -0700

    staging: comedi: das800: clarify 8254 timer programming
    
    Refactor the 8254 timer programming to use the i8254_set_mode()
    and i8254_write() helpers instead of i8254_load(). This allows
    us to use the I8254_MODE* defines to clarify the code.
    
    The das800_set_frequency() function will not fail. For aesthetics
    change the return to a void and remove the error handling.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index e2dc43dbdc5e..615ae3f1c6cc 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -275,19 +275,15 @@ static void das800_disable(struct comedi_device *dev)
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
-static int das800_set_frequency(struct comedi_device *dev)
+static void das800_set_frequency(struct comedi_device *dev)
 {
 	struct das800_private *devpriv = dev->private;
-	int err = 0;
-
-	if (i8254_load(dev->iobase + DAS800_8254, 0, 1, devpriv->divisor1, 2))
-		err++;
-	if (i8254_load(dev->iobase + DAS800_8254, 0, 2, devpriv->divisor2, 2))
-		err++;
-	if (err)
-		return -1;
+	unsigned long timer_base = dev->iobase + DAS800_8254;
 
-	return 0;
+	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
+	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
+	i8254_write(timer_base, 0, 1, devpriv->divisor1);
+	i8254_write(timer_base, 0, 2, devpriv->divisor2);
 }
 
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -448,10 +444,7 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	if (async->cmd.convert_src == TRIG_TIMER) {
 		conv_bits |= CASC | ITE;
 		/* set conversion frequency */
-		if (das800_set_frequency(dev) < 0) {
-			comedi_error(dev, "Error setting up counters");
-			return -1;
-		}
+		das800_set_frequency(dev);
 	}
 
 	spin_lock_irqsave(&dev->spinlock, irq_flags);

commit 1d57261c96cf37949b87d9d239afb3734846d78e
Author: Christian Engelmayer <cengelma@gmx.at>
Date:   Sat Apr 26 16:04:29 2014 +0200

    staging: comedi: remove duplicate pointer assignments in attach functions
    
    Some board pointer are assigned twice via comedi_board() in the comedi low
    level driver attach functions. Remove the duplicate assignment from the
    variable definition where the pointer is not used anyway until assigned later
    in the function when dev->board_ptr, that comedi_board() relies on, is setup
    correctly.
    
    Signed-off-by: Christian Engelmayer <cengelma@gmx.at>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index b23a12ce7651..e2dc43dbdc5e 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -683,7 +683,7 @@ static int das800_probe(struct comedi_device *dev)
 
 static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct das800_board *thisboard = comedi_board(dev);
+	const struct das800_board *thisboard;
 	struct das800_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned int irq = it->options[1];

commit 1626657f35f5b2973fa50f16fb49e20a626cb636
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 16 14:19:15 2014 -0700

    staging: comedi: das800: factor out chanlist checking from (*do_cmdtest)
    
    Step 5 of the (*do_cmdtest) validates that the cmd->chanlist is compatible
    with the hardware.
    
    For aesthetics, factor out the step 5 code for the analog input async command
    support. Tidy up the factored out code.
    
    To minimize the noise, change the dev_err() to dev_dbg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 3e408370dcf3..b23a12ce7651 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -300,6 +300,34 @@ static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static int das800_ai_check_chanlist(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_cmd *cmd)
+{
+	unsigned int chan0 = CR_CHAN(cmd->chanlist[0]);
+	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
+	int i;
+
+	for (i = 1; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+		unsigned int range = CR_RANGE(cmd->chanlist[i]);
+
+		if (chan != (chan0 + i) % s->n_chan) {
+			dev_dbg(dev->class_dev,
+				"chanlist must be consecutive, counting upwards\n");
+			return -EINVAL;
+		}
+
+		if (range != range0) {
+			dev_dbg(dev->class_dev,
+				"chanlist must all have the same gain\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int das800_ai_do_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
@@ -366,27 +394,9 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 4;
 
-	/*  check channel/gain list against card's limitations */
-	if (cmd->chanlist) {
-		unsigned int chan = CR_CHAN(cmd->chanlist[0]);
-		unsigned int range = CR_RANGE(cmd->chanlist[0]);
-		unsigned int next;
-		int i;
-
-		for (i = 1; i < cmd->chanlist_len; i++) {
-			next = cmd->chanlist[i];
-			if (CR_CHAN(next) != (chan + i) % N_CHAN_AI) {
-				dev_err(dev->class_dev,
-					"chanlist must be consecutive, counting upwards\n");
-				err++;
-			}
-			if (CR_RANGE(next) != range) {
-				dev_err(dev->class_dev,
-					"chanlist must all have the same gain\n");
-				err++;
-			}
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= das800_ai_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;

commit 52037a0d520e988e3287b28bc767b58ddc66ad94
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:46 2014 -0700

    staging: comedi: drivers should not clear the async->events
    
    The comedi core resets the async->events in comedi_buf_reset() which is
    called when the subdevice is restored to an idle state and at the start
    of an async command. The async->events are also cleared after handling
    the events in comedi_event().
    
    Drivers should not clear the events manually.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index a4fb3d64420c..3e408370dcf3 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -448,7 +448,6 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	das800_ind_write(dev, conv_bits, CONV_CONTROL);
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
-	async->events = 0;
 	das800_enable(dev);
 	return 0;
 }

commit f382898fabfa77dda6d77e8ad81fd7cc8edd0cee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:31 2014 -0700

    staging: comedi: das800: use cfc_handle_events()
    
    Use the comedi_fc helper function to automatically call the subdevice
    (*cancel) function when needed and call comedi_event().
    
    Also, remove the clearing of the event, comedi_event() does that.
    
    In the Kconfig, COMEDI_DAS800 already selects COMEDI_FC.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 8c15929811b6..a4fb3d64420c 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -521,10 +521,8 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 
 	if (fifo_overflow) {
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-		das800_cancel(dev, s);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		comedi_event(dev, s);
-		async->events = 0;
+		cfc_handle_events(dev, s);
 		return IRQ_HANDLED;
 	}
 
@@ -540,8 +538,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 		das800_disable(dev);
 		async->events |= COMEDI_CB_EOA;
 	}
-	comedi_event(dev, s);
-	async->events = 0;
+	cfc_handle_events(dev, s);
 	return IRQ_HANDLED;
 }
 

commit b41b267dbd17a24657c9bac2150fc1f10061b522
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 15:20:35 2014 -0700

    staging: comedi: das800: trigger sources are validated in (*do_cmdtest)
    
    The trigger sources were already validataed in the (*do_cmdtest) before the
    (*do_cmd) is called. Refactor the code in das800_ai_do_cmd() to use if/else
    instead of the switch since the default cases can never be reached.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index dbe94cea5905..8c15929811b6 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -420,17 +420,12 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	gain &= 0xf;
 	outb(gain, dev->iobase + DAS800_GAIN);
 
-	switch (async->cmd.stop_src) {
-	case TRIG_COUNT:
+	if (async->cmd.stop_src == TRIG_COUNT) {
 		devpriv->count = async->cmd.stop_arg * async->cmd.chanlist_len;
 		devpriv->forever = false;
-		break;
-	case TRIG_NONE:
+	} else {	/* TRIG_NONE */
 		devpriv->forever = true;
 		devpriv->count = 0;
-		break;
-	default:
-		break;
 	}
 
 	/* enable auto channel scan, send interrupts on end of conversion
@@ -440,19 +435,13 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	conv_bits |= EACS | IEOC;
 	if (async->cmd.start_src == TRIG_EXT)
 		conv_bits |= DTEN;
-	switch (async->cmd.convert_src) {
-	case TRIG_TIMER:
+	if (async->cmd.convert_src == TRIG_TIMER) {
 		conv_bits |= CASC | ITE;
 		/* set conversion frequency */
 		if (das800_set_frequency(dev) < 0) {
 			comedi_error(dev, "Error setting up counters");
 			return -1;
 		}
-		break;
-	case TRIG_EXT:
-		break;
-	default:
-		break;
 	}
 
 	spin_lock_irqsave(&dev->spinlock, irq_flags);

commit 90bc68ec9dec1e343ea7ac5e8ac8df5cd101947b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:04 2014 -0700

    staging: comedi: das800: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 5af0a5764a8c..dbe94cea5905 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -556,15 +556,17 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static int das800_wait_for_conv(struct comedi_device *dev, int timeout)
+static int das800_ai_eoc(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 struct comedi_insn *insn,
+			 unsigned long context)
 {
-	int i;
+	unsigned int status;
 
-	for (i = 0; i < timeout; i++) {
-		if (!(inb(dev->iobase + DAS800_STATUS) & BUSY))
-			return 0;
-	}
-	return -ETIME;
+	status = inb(dev->iobase + DAS800_STATUS);
+	if ((status & BUSY) == 0)
+		return 0;
+	return -EBUSY;
 }
 
 static int das800_ai_insn_read(struct comedi_device *dev,
@@ -599,7 +601,7 @@ static int das800_ai_insn_read(struct comedi_device *dev,
 		/* trigger conversion */
 		outb_p(0, dev->iobase + DAS800_MSB);
 
-		ret = das800_wait_for_conv(dev, 1000);
+		ret = comedi_timeout(dev, s, insn, das800_ai_eoc, 0);
 		if (ret)
 			return ret;
 

commit cb9cfd7ed3f6ed4c40167b4251cdb382b6b3ba1c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 26 11:40:15 2013 -0700

    staging: comedi: 8253.h: tidy up the i8253_cascade_ns_to_timer*() users
    
    Introduce a couple defines for the common 8254 oscillator base values
    used in the comedi drivers and remove the custom defines and open
    coded values.
    
    Change the i8253_cascade_ns_to_timer_2div() calls in the drivers to
    the more generic i8253_cascade_ns_to_timer(). They are identical due
    to the #define in the 8253.h header.
    
    Remove the extra mask by TRIG_ROUND_MASK of the 'round_mode' parameter
    to i8253_cascade_ns_to_timer(). That function already handles the mask.
    
    Tidy up all the calls to i8253_cascade_ns_to_timer().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index b80dd0362ffc..5af0a5764a8c 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -66,7 +66,6 @@ cmd triggers supported:
 #include "comedi_fc.h"
 
 #define DAS800_SIZE           8
-#define TIMER_BASE            1000
 #define N_CHAN_AI             8	/*  number of analog input channels */
 
 /* Registers for the das800 */
@@ -356,11 +355,10 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 		int tmp = cmd->convert_arg;
 
 		/* calculate counter values that give desired timing */
-		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-					       &devpriv->divisor1,
-					       &devpriv->divisor2,
-					       &cmd->convert_arg,
-					       cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_1MHZ,
+					  &devpriv->divisor1,
+					  &devpriv->divisor2,
+					  &cmd->convert_arg, cmd->flags);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}

commit 97f4289ad08cffe55de06d4ac4f89ac540450aee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:05:58 2013 -0700

    staging: comedi: drivers: use comedi_dio_update_state() for simple cases
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state for simple cases where the hardware is updated
    when any channel is modified.
    
    Also, fix a bug in the amplc_pc263 and amplc_pci263 drivers where the
    current state is not returned in data[1].
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 11e16114e4e3..b80dd0362ffc 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -630,13 +630,9 @@ static int das800_do_insn_bits(struct comedi_device *dev,
 			       unsigned int *data)
 {
 	struct das800_private *devpriv = dev->private;
-	unsigned int mask = data[0];
-	unsigned int bits = data[1];
 	unsigned long irq_flags;
 
-	if (mask) {
-		s->state &= ~mask;
-		s->state |= (bits & mask);
+	if (comedi_dio_update_state(s, data)) {
 		devpriv->do_bits = s->state << 4;
 
 		spin_lock_irqsave(&dev->spinlock, irq_flags);

commit 8e6b7915a1da703617dca28c33e150141fcec9b0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:05:07 2013 -0700

    staging: comedi: drivers do not need <linux/ioport.h>
    
    All the ioport resources are managed by the comedi core. None of
    the drivers depend on <linux/ioport.h>. Remove the includes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 13e1cd0afd32..11e16114e4e3 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -60,7 +60,6 @@ cmd triggers supported:
 #include <linux/interrupt.h>
 #include "../comedidev.h"
 
-#include <linux/ioport.h>
 #include <linux/delay.h>
 
 #include "8253.h"

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index f3f4be5b3a59..13e1cd0afd32 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -56,6 +56,7 @@ cmd triggers supported:
 
 */
 
+#include <linux/module.h>
 #include <linux/interrupt.h>
 #include "../comedidev.h"
 

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 091cd911b38a..f3f4be5b3a59 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -700,10 +700,9 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int board;
 	int ret;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	ret = comedi_request_region(dev, it->options[0], DAS800_SIZE);
 	if (ret)

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 9ce6cbcc7ee8..091cd911b38a 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -15,12 +15,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-************************************************************************
 */
 /*
 Driver: das800

commit eca7cf725617c08f02a9f74155ced6d2de9f0a63
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:38:26 2013 -0700

    staging: comedi: das800: cleanup the cio-das802/16 fifo comments
    
    Cleanup the comments about the cio-das802/16 specific register
    defines. This also removes a checkpatch.pl warning about > 80
    char lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index bb0c40627ae2..9ce6cbcc7ee8 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -95,8 +95,8 @@ cmd triggers supported:
 #define   IRQ                   0x8
 #define   BUSY                  0x80
 #define DAS800_GAIN           3
-#define   CIO_FFOV              0x8	/*  fifo overflow for cio-das802/16 */
-#define   CIO_ENHF              0x90	/*  interrupt fifo half full for cio-das802/16 */
+#define   CIO_FFOV              0x8   /* cio-das802/16 fifo overflow */
+#define   CIO_ENHF              0x90  /* cio-das802/16 fifo half full int ena */
 #define   CONTROL1              0x80
 #define   CONV_CONTROL          0xa0
 #define   SCAN_LIMITS           0xc0

commit d24160f83d5fd7d4ef383085cae90aa27ce63ed6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:38:06 2013 -0700

    staging: comedi: das800: rename CamelCase vars in das800_ai_do_cmd()
    
    Rename the CamelCase variables in das800_ai_do_cmd().
    
    For aesthetic reasons, initialize the variables when they are
    declared.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 9eced6205511..bb0c40627ae2 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -407,25 +407,22 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 {
 	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
-	int startChan, endChan, scan, gain;
+	struct comedi_async *async = s->async;
+	unsigned int gain = CR_RANGE(async->cmd.chanlist[0]);
+	unsigned int start_chan = CR_CHAN(async->cmd.chanlist[0]);
+	unsigned int end_chan = (start_chan + async->cmd.chanlist_len - 1) % 8;
+	unsigned int scan_chans = (end_chan << 3) | start_chan;
 	int conv_bits;
 	unsigned long irq_flags;
-	struct comedi_async *async = s->async;
 
 	das800_disable(dev);
 
-	/* set channel scan limits */
-	startChan = CR_CHAN(async->cmd.chanlist[0]);
-	endChan = (startChan + async->cmd.chanlist_len - 1) % 8;
-	scan = (endChan << 3) | startChan;
-
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	/* set scan limits */
-	das800_ind_write(dev, scan, SCAN_LIMITS);
+	das800_ind_write(dev, scan_chans, SCAN_LIMITS);
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	/* set gain */
-	gain = CR_RANGE(async->cmd.chanlist[0]);
 	if (thisboard->resolution == 12 && gain > 0)
 		gain += 0x7;
 	gain &= 0xf;

commit ad5774fcd2cd40dd8a0f3d9db9b0a3538d47e610
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:37:48 2013 -0700

    staging: comedi: das800: tidy up the private data
    
    For aesthetic reasons, change the 'do_bits' type to unsigned int
    to match the subdevice s->state. and change the 'forever' flag
    to a bool.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index b72bbe98d543..9eced6205511 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -228,10 +228,10 @@ static const struct das800_board das800_boards[] = {
 
 struct das800_private {
 	unsigned int count;	/* number of data points left to be taken */
-	int forever;		/* flag that we should take data forever */
 	unsigned int divisor1;	/* counter 1 value for timed conversions */
 	unsigned int divisor2;	/* counter 2 value for timed conversions */
-	int do_bits;		/* digital output bits */
+	unsigned int do_bits;	/* digital output bits */
+	bool forever;		/* flag that we should take data forever */
 };
 
 static void das800_ind_write(struct comedi_device *dev,
@@ -301,7 +301,7 @@ static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct das800_private *devpriv = dev->private;
 
-	devpriv->forever = 0;
+	devpriv->forever = false;
 	devpriv->count = 0;
 	das800_disable(dev);
 	return 0;
@@ -434,10 +434,10 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	switch (async->cmd.stop_src) {
 	case TRIG_COUNT:
 		devpriv->count = async->cmd.stop_arg * async->cmd.chanlist_len;
-		devpriv->forever = 0;
+		devpriv->forever = false;
 		break;
 	case TRIG_NONE:
-		devpriv->forever = 1;
+		devpriv->forever = true;
 		devpriv->count = 0;
 		break;
 	default:

commit 7f340859f26e6de7069d0c4f234d948820c4fd47
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:37:29 2013 -0700

    staging: comedi: das800: tidy up das800_interrupt()
    
    Rename the CamelCase variable 'dataPoint'.
    
    Cleanup some of the comments and fix the > 80 char lines.
    
    Use the das800_ai_get_sample() helper to get the analog input data.
    
    Change the fifo flags into bools and make sure to check for the
    fifo overflow while reading the samples. This also fixes the overflow
    detection for 12-bit resolutions. In the current code the 'dataPoint'
    value has been shifted and masked. This could result in fifo_overflow
    being invalidly true.
    
    Remove the need for the 'thisboard' pointer by using the subdevice
    'maxdata' to determine the sample size.
    
    The devpriv->forever flag is really a bool. Treat it as such.
    
    Remove the comedi_error() messages. The user will get the error
    condition back in the async event. The message is just added noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index c30309cbc855..b72bbe98d543 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -107,6 +107,8 @@ cmd triggers supported:
 #define   STATUS2_INTE          0X20
 #define DAS800_ID             7
 
+#define DAS802_16_HALF_FIFO_SZ	128
+
 struct das800_board {
 	const char *name;
 	int ai_speed;
@@ -483,92 +485,79 @@ static unsigned int das800_ai_get_sample(struct comedi_device *dev)
 
 static irqreturn_t das800_interrupt(int irq, void *d)
 {
-	short i;		/* loop index */
-	short dataPoint = 0;
 	struct comedi_device *dev = d;
-	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->read_subdev;	/* analog input subdevice */
-	struct comedi_async *async;
-	int status;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_async *async = s ? s->async : NULL;
 	unsigned long irq_flags;
-	static const int max_loops = 128;	/*  half-fifo size for cio-das802/16 */
-	/*  flags */
-	int fifo_empty = 0;
-	int fifo_overflow = 0;
+	unsigned int status;
+	unsigned int val;
+	bool fifo_empty;
+	bool fifo_overflow;
+	int i;
 
 	status = inb(dev->iobase + DAS800_STATUS);
-	/* if interrupt was not generated by board or driver not attached, quit */
 	if (!(status & IRQ))
 		return IRQ_NONE;
-	if (!(dev->attached))
+	if (!dev->attached)
 		return IRQ_HANDLED;
 
-	/* wait until here to initialize async, since we will get null dereference
-	 * if interrupt occurs before driver is fully attached!
-	 */
-	async = s->async;
-
-	/*  if hardware conversions are not enabled, then quit */
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	status = das800_ind_read(dev, CONTROL1) & STATUS2_HCEN;
-	/* don't release spinlock yet since we want to make sure no one else disables hardware conversions */
+	/*
+	 * Don't release spinlock yet since we want to make sure
+	 * no one else disables hardware conversions.
+	 */
+
+	/* if hardware conversions are not enabled, then quit */
 	if (status == 0) {
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		return IRQ_HANDLED;
 	}
 
-	/* loop while card's fifo is not empty (and limit to half fifo for cio-das802/16) */
-	for (i = 0; i < max_loops; i++) {
-		/* read 16 bits from dev->iobase and dev->iobase + 1 */
-		dataPoint = inb(dev->iobase + DAS800_LSB);
-		dataPoint += inb(dev->iobase + DAS800_MSB) << 8;
-		if (thisboard->resolution == 12) {
-			fifo_empty = dataPoint & FIFO_EMPTY;
-			fifo_overflow = dataPoint & FIFO_OVF;
-			if (fifo_overflow)
-				break;
+	for (i = 0; i < DAS802_16_HALF_FIFO_SZ; i++) {
+		val = das800_ai_get_sample(dev);
+		if (s->maxdata == 0x0fff) {
+			fifo_empty = !!(val & FIFO_EMPTY);
+			fifo_overflow = !!(val & FIFO_OVF);
 		} else {
-			fifo_empty = 0;	/*  cio-das802/16 has no fifo empty status bit */
+			/* cio-das802/16 has no fifo empty status bit */
+			fifo_empty = false;
+			fifo_overflow = !!(inb(dev->iobase + DAS800_GAIN) &
+						CIO_FFOV);
 		}
-		if (fifo_empty)
+		if (fifo_empty || fifo_overflow)
 			break;
-		/* strip off extraneous bits for 12 bit cards */
-		if (thisboard->resolution == 12)
-			dataPoint = (dataPoint >> 4) & 0xfff;
+
+		if (s->maxdata == 0x0fff)
+			val >>= 4;	/* 12-bit sample */
+
 		/* if there are more data points to collect */
-		if (devpriv->count > 0 || devpriv->forever == 1) {
+		if (devpriv->count > 0 || devpriv->forever) {
 			/* write data point to buffer */
-			cfc_write_to_buffer(s, dataPoint);
-			if (devpriv->count > 0)
-				devpriv->count--;
+			cfc_write_to_buffer(s, val & s->maxdata);
+			devpriv->count--;
 		}
 	}
 	async->events |= COMEDI_CB_BLOCK;
-	/* check for fifo overflow */
-	if (thisboard->resolution == 12) {
-		fifo_overflow = dataPoint & FIFO_OVF;
-		/*  else cio-das802/16 */
-	} else {
-		fifo_overflow = inb(dev->iobase + DAS800_GAIN) & CIO_FFOV;
-	}
+
 	if (fifo_overflow) {
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-		comedi_error(dev, "DAS800 FIFO overflow");
 		das800_cancel(dev, s);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		comedi_event(dev, s);
 		async->events = 0;
 		return IRQ_HANDLED;
 	}
-	if (devpriv->count > 0 || devpriv->forever == 1) {
+
+	if (devpriv->count > 0 || devpriv->forever) {
 		/* Re-enable card's interrupt.
 		 * We already have spinlock, so indirect addressing is safe */
 		das800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits,
 				 CONTROL1);
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-		/* otherwise, stop taking data */
 	} else {
+		/* otherwise, stop taking data */
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		das800_disable(dev);
 		async->events |= COMEDI_CB_EOA;

commit b4780a3afb944765f4b94d79463e570e4472ccb6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:37:03 2013 -0700

    staging: comedi: das800: tidy up das800_ai_insn_read()
    
    Introduce a couple helper functions to read the 16-bit analog input
    sample and to wait for the analog conversion to complete.
    
    Tidy up the das800_ai_insn_read() function by using the new helpers.
    Also, remove the need for 'thisboard' in the function by checking the
    subdevice 'maxdata' variable to determine the analog input resolution.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index cc4202eb3958..c30309cbc855 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -473,6 +473,14 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	return 0;
 }
 
+static unsigned int das800_ai_get_sample(struct comedi_device *dev)
+{
+	unsigned int lsb = inb(dev->iobase + DAS800_LSB);
+	unsigned int msb = inb(dev->iobase + DAS800_MSB);
+
+	return (msb << 8) | lsb;
+}
+
 static irqreturn_t das800_interrupt(int irq, void *d)
 {
 	short i;		/* loop index */
@@ -570,61 +578,60 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
+static int das800_wait_for_conv(struct comedi_device *dev, int timeout)
+{
+	int i;
+
+	for (i = 0; i < timeout; i++) {
+		if (!(inb(dev->iobase + DAS800_STATUS) & BUSY))
+			return 0;
+	}
+	return -ETIME;
+}
+
 static int das800_ai_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn,
 			       unsigned int *data)
 {
-	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
-	int i, n;
-	int chan;
-	int range;
-	int lsb, msb;
-	int timeout = 1000;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
 	unsigned long irq_flags;
+	unsigned int val;
+	int ret;
+	int i;
 
 	das800_disable(dev);
 
 	/* set multiplexer */
-	chan = CR_CHAN(insn->chanspec);
-
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	das800_ind_write(dev, chan | devpriv->do_bits, CONTROL1);
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	/* set gain / range */
-	range = CR_RANGE(insn->chanspec);
-	if (thisboard->resolution == 12 && range)
+	if (s->maxdata == 0x0fff && range)
 		range += 0x7;
 	range &= 0xf;
 	outb(range, dev->iobase + DAS800_GAIN);
 
 	udelay(5);
 
-	for (n = 0; n < insn->n; n++) {
+	for (i = 0; i < insn->n; i++) {
 		/* trigger conversion */
 		outb_p(0, dev->iobase + DAS800_MSB);
 
-		for (i = 0; i < timeout; i++) {
-			if (!(inb(dev->iobase + DAS800_STATUS) & BUSY))
-				break;
-		}
-		if (i == timeout) {
-			comedi_error(dev, "timeout");
-			return -ETIME;
-		}
-		lsb = inb(dev->iobase + DAS800_LSB);
-		msb = inb(dev->iobase + DAS800_MSB);
-		if (thisboard->resolution == 12) {
-			data[n] = (lsb >> 4) & 0xff;
-			data[n] |= (msb << 4);
-		} else {
-			data[n] = (msb << 8) | lsb;
-		}
+		ret = das800_wait_for_conv(dev, 1000);
+		if (ret)
+			return ret;
+
+		val = das800_ai_get_sample(dev);
+		if (s->maxdata == 0x0fff)
+			val >>= 4;	/* 12-bit sample */
+		data[i] = val & s->maxdata;
 	}
 
-	return n;
+	return insn->n;
 }
 
 static int das800_di_insn_bits(struct comedi_device *dev,

commit e245b6d12691c1e178a6a075ac3cd1b7cd0d2e0e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:36:45 2013 -0700

    staging: comedi: das800: tidy up das800_di_insn_bits()
    
    For digital input subdevices, the (*insn_bits) function simply needs
    to return the status of the input channels in data[1].
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 4f6698dc76db..cc4202eb3958 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -632,12 +632,7 @@ static int das800_di_insn_bits(struct comedi_device *dev,
 			       struct comedi_insn *insn,
 			       unsigned int *data)
 {
-	unsigned int bits;
-
-	bits = inb(dev->iobase + DAS800_STATUS) >> 4;
-	bits &= 0x7;
-	data[1] = bits;
-	data[0] = 0;
+	data[1] = (inb(dev->iobase + DAS800_STATUS) >> 4) & 0x7;
 
 	return insn->n;
 }

commit 26234771c1a53b0a3bf69c161d79cd37c77ebd1a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:36:28 2013 -0700

    staging: comedi: das800: tidy up das800_do_insn_bits()
    
    Use a couple local variables, mask and bits, to clarify this function.
    
    Its only necessary to update the outputs if the mask indicates that
    the bits are changing. Modify this function accordingly. Also, use
    the subdevice 'state' variable to hold the actual output channel
    state instead of needing to get it from the private data and shift
    it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index b68c74106117..4f6698dc76db 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -648,21 +648,22 @@ static int das800_do_insn_bits(struct comedi_device *dev,
 			       unsigned int *data)
 {
 	struct das800_private *devpriv = dev->private;
-	int wbits;
+	unsigned int mask = data[0];
+	unsigned int bits = data[1];
 	unsigned long irq_flags;
 
-	/*  only set bits that have been masked */
-	data[0] &= 0xf;
-	wbits = devpriv->do_bits >> 4;
-	wbits &= ~data[0];
-	wbits |= data[0] & data[1];
-	devpriv->do_bits = wbits << 4;
+	if (mask) {
+		s->state &= ~mask;
+		s->state |= (bits & mask);
+		devpriv->do_bits = s->state << 4;
 
-	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	das800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits, CONTROL1);
-	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		spin_lock_irqsave(&dev->spinlock, irq_flags);
+		das800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits,
+				 CONTROL1);
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	}
 
-	data[1] = wbits;
+	data[1] = s->state;
 
 	return insn->n;
 }

commit 264601c231c9c9dec3da2c665c0b9cbec11d8c9e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:36:11 2013 -0700

    staging: comedi: das800: remove extra divisor calculation call
    
    The comedi core always calls the (*do_cmdtest) function before it
    calls the (*do_cmd) function. The divisors were already calculated
    in das800_ai_do_cmdtest(), it is not necessary to calculate them
    again in das800_ai_do_cmd().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 642eae46a4ee..b68c74106117 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -453,11 +453,6 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	case TRIG_TIMER:
 		conv_bits |= CASC | ITE;
 		/* set conversion frequency */
-		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-					       &(devpriv->divisor2),
-					       &(async->cmd.convert_arg),
-					       async->cmd.
-					       flags & TRIG_ROUND_MASK);
 		if (das800_set_frequency(dev) < 0) {
 			comedi_error(dev, "Error setting up counters");
 			return -1;

commit 57d1ebf795a3cdde46ee30e4ad77b4ae02fa1569
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:35:49 2013 -0700

    staging: comedi: das800: rename {enable,disable}_das800
    
    For aesthetic reasons, rename these functions to match the namespace
    of the rest of the driver. Also, remove the unnecessary comments.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 7518d912bbf5..642eae46a4ee 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -253,8 +253,7 @@ static unsigned das800_ind_read(struct comedi_device *dev, unsigned reg)
 	return inb(dev->iobase + 7);
 }
 
-/* enable_das800 makes the card start taking hardware triggered conversions */
-static void enable_das800(struct comedi_device *dev)
+static void das800_enable(struct comedi_device *dev)
 {
 	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
@@ -271,8 +270,7 @@ static void enable_das800(struct comedi_device *dev)
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
-/* disable_das800 stops hardware triggered conversions */
-static void disable_das800(struct comedi_device *dev)
+static void das800_disable(struct comedi_device *dev)
 {
 	unsigned long irq_flags;
 
@@ -303,7 +301,7 @@ static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	devpriv->forever = 0;
 	devpriv->count = 0;
-	disable_das800(dev);
+	das800_disable(dev);
 	return 0;
 }
 
@@ -412,7 +410,7 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	unsigned long irq_flags;
 	struct comedi_async *async = s->async;
 
-	disable_das800(dev);
+	das800_disable(dev);
 
 	/* set channel scan limits */
 	startChan = CR_CHAN(async->cmd.chanlist[0]);
@@ -476,7 +474,7 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	async->events = 0;
-	enable_das800(dev);
+	das800_enable(dev);
 	return 0;
 }
 
@@ -569,7 +567,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 		/* otherwise, stop taking data */
 	} else {
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-		disable_das800(dev);	/* disable hardware triggered conversions */
+		das800_disable(dev);
 		async->events |= COMEDI_CB_EOA;
 	}
 	comedi_event(dev, s);
@@ -591,7 +589,7 @@ static int das800_ai_insn_read(struct comedi_device *dev,
 	int timeout = 1000;
 	unsigned long irq_flags;
 
-	disable_das800(dev);	/* disable hardware conversions (enables software conversions) */
+	das800_disable(dev);
 
 	/* set multiplexer */
 	chan = CR_CHAN(insn->chanspec);
@@ -788,7 +786,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->range_table	= &range_digital;
 	s->insn_bits	= das800_do_insn_bits;
 
-	disable_das800(dev);
+	das800_disable(dev);
 
 	/* initialize digital out channels */
 	spin_lock_irqsave(&dev->spinlock, irq_flags);

commit d7427345e8364a0fc96dd6c6be3fd6235d6eb17a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:35:31 2013 -0700

    staging: comedi: das800: tidy up subdevice init
    
    For aesthetic reasons, rename some of the subdevice functions
    to help with greps and add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 1260ebacca18..7518d912bbf5 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -577,9 +577,10 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static int das800_ai_rinsn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data)
+static int das800_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
 	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
@@ -633,9 +634,10 @@ static int das800_ai_rinsn(struct comedi_device *dev,
 	return n;
 }
 
-static int das800_di_rbits(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data)
+static int das800_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
 	unsigned int bits;
 
@@ -647,9 +649,10 @@ static int das800_di_rbits(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int das800_do_wbits(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data)
+static int das800_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
 	struct das800_private *devpriv = dev->private;
 	int wbits;
@@ -750,7 +753,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	/* analog input subdevice */
+	/* Analog Input subdevice */
 	s = &dev->subdevices[0];
 	dev->read_subdev = s;
 	s->type		= COMEDI_SUBD_AI;
@@ -758,7 +761,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->n_chan	= 8;
 	s->maxdata	= (1 << thisboard->resolution) - 1;
 	s->range_table	= thisboard->ai_range;
-	s->insn_read	= das800_ai_rinsn;
+	s->insn_read	= das800_ai_insn_read;
 	if (dev->irq) {
 		s->subdev_flags	|= SDF_CMD_READ;
 		s->len_chanlist	= 8;
@@ -767,23 +770,23 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->cancel	= das800_cancel;
 	}
 
-	/* di */
+	/* Digital Input subdevice */
 	s = &dev->subdevices[1];
-	s->type = COMEDI_SUBD_DI;
-	s->subdev_flags = SDF_READABLE;
-	s->n_chan = 3;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_bits = das800_di_rbits;
-
-	/* do */
+	s->type		= COMEDI_SUBD_DI;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= 3;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= das800_di_insn_bits;
+
+	/* Digital Output subdevice */
 	s = &dev->subdevices[2];
-	s->type = COMEDI_SUBD_DO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 4;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_bits = das800_do_wbits;
+	s->type		= COMEDI_SUBD_DO;
+	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE;
+	s->n_chan	= 4;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= das800_do_insn_bits;
 
 	disable_das800(dev);
 

commit f05ffb6e12bcfcce5bb6c8eadbabe3b7ebe8f7db
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:35:12 2013 -0700

    staging: comedi: das800: allow attaching without interrupt support
    
    Interrupts are only requires for the analog input async command support.
    
    Allow the driver to attach to the board if the request_irq() fails.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 78e913e3dfe3..1260ebacca18 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -737,22 +737,14 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	dev->board_ptr = das800_boards + board;
 	thisboard = comedi_board(dev);
+	dev->board_name = thisboard->name;
 
-	/* grab our IRQ */
-	if (irq == 1 || irq > 7) {
-		dev_err(dev->class_dev, "irq out of range\n");
-		return -EINVAL;
-	}
-	if (irq) {
-		if (request_irq(irq, das800_interrupt, 0, "das800", dev)) {
-			dev_err(dev->class_dev, "unable to allocate irq %u\n",
-				irq);
-			return -EINVAL;
-		}
+	if (irq > 1 && irq <= 7) {
+		ret = request_irq(irq, das800_interrupt, 0, dev->board_name,
+				  dev);
+		if (ret == 0)
+			dev->irq = irq;
 	}
-	dev->irq = irq;
-
-	dev->board_name = thisboard->name;
 
 	ret = comedi_alloc_subdevices(dev, 3);
 	if (ret)

commit 77630119ba0d64ddbe1c839adfd05483d403a0ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:34:54 2013 -0700

    staging: comedi: das800: interrupts are required for async command support
    
    Interrupt support is optional with this driver. Only hook up the async
    command support for the analog input subdevice if the user requested an
    interrupt when attaching to the board. This also allows removing the
    extra test in das800_ai_do_cmd().
    
    For aesthetic reasons, add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 3711f81321d9..78e913e3dfe3 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -412,12 +412,6 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	unsigned long irq_flags;
 	struct comedi_async *async = s->async;
 
-	if (!dev->irq) {
-		comedi_error(dev,
-			     "no irq assigned for das-800, cannot do hardware conversions");
-		return -1;
-	}
-
 	disable_das800(dev);
 
 	/* set channel scan limits */
@@ -767,16 +761,19 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* analog input subdevice */
 	s = &dev->subdevices[0];
 	dev->read_subdev = s;
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
-	s->n_chan = 8;
-	s->len_chanlist = 8;
-	s->maxdata = (1 << thisboard->resolution) - 1;
-	s->range_table = thisboard->ai_range;
-	s->do_cmd = das800_ai_do_cmd;
-	s->do_cmdtest = das800_ai_do_cmdtest;
-	s->insn_read = das800_ai_rinsn;
-	s->cancel = das800_cancel;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND;
+	s->n_chan	= 8;
+	s->maxdata	= (1 << thisboard->resolution) - 1;
+	s->range_table	= thisboard->ai_range;
+	s->insn_read	= das800_ai_rinsn;
+	if (dev->irq) {
+		s->subdev_flags	|= SDF_CMD_READ;
+		s->len_chanlist	= 8;
+		s->do_cmdtest	= das800_ai_do_cmdtest;
+		s->do_cmd	= das800_ai_do_cmd;
+		s->cancel	= das800_cancel;
+	}
 
 	/* di */
 	s = &dev->subdevices[1];

commit 2bc405831d5bd83f263c2a0eac915ba5292d4cbe
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:34:35 2013 -0700

    staging: comedi: das800: tidy up das800_ai_do_cmdtest()
    
    For aesthetic reasons, move some of the local variables to the place
    they are actually used. Also, rename the CamelCase 'startChan' local
    variable.
    
    Remove the unnecessary '()' around the variables passed in the
    i8253_cascade_ns_to_timer_2div() call.
    
    Add a local variable, 'next', to hold the cmd->chanlist[i] value
    used in the loop that checks the channel/gain list.
    
    Replace the comedi_error() with dev_dbg() and shorten the messages
    a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 4c28b383869d..3711f81321d9 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -314,9 +314,6 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
 	int err = 0;
-	int tmp;
-	int gain, startChan;
-	int i;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -362,11 +359,13 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		tmp = cmd->convert_arg;
+		int tmp = cmd->convert_arg;
+
 		/* calculate counter values that give desired timing */
-		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-					       &(devpriv->divisor2),
-					       &(cmd->convert_arg),
+		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
+					       &devpriv->divisor1,
+					       &devpriv->divisor2,
+					       &cmd->convert_arg,
 					       cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
@@ -377,18 +376,21 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 
 	/*  check channel/gain list against card's limitations */
 	if (cmd->chanlist) {
-		gain = CR_RANGE(cmd->chanlist[0]);
-		startChan = CR_CHAN(cmd->chanlist[0]);
+		unsigned int chan = CR_CHAN(cmd->chanlist[0]);
+		unsigned int range = CR_RANGE(cmd->chanlist[0]);
+		unsigned int next;
+		int i;
+
 		for (i = 1; i < cmd->chanlist_len; i++) {
-			if (CR_CHAN(cmd->chanlist[i]) !=
-			    (startChan + i) % N_CHAN_AI) {
-				comedi_error(dev,
-					     "entries in chanlist must be consecutive channels, counting upwards\n");
+			next = cmd->chanlist[i];
+			if (CR_CHAN(next) != (chan + i) % N_CHAN_AI) {
+				dev_err(dev->class_dev,
+					"chanlist must be consecutive, counting upwards\n");
 				err++;
 			}
-			if (CR_RANGE(cmd->chanlist[i]) != gain) {
-				comedi_error(dev,
-					     "entries in chanlist must all have the same gain\n");
+			if (CR_RANGE(next) != range) {
+				dev_err(dev->class_dev,
+					"chanlist must all have the same gain\n");
 				err++;
 			}
 		}

commit 808cea5a5d538d787f42e2ec48527bfb7e830490
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:34:19 2013 -0700

    staging: comedi: das800: remove 'volatile' on private data variables
    
    As indicated by checkpatch.pl, "WARNING: Use of volatile is usually
    wrong: ...". The variables in the private data that are marked
    volatile don't need to be. Remove the volatile.
    
    Also, cleanup the comments to avoid > 80 char lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index e2bd371114be..4c28b383869d 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -225,11 +225,11 @@ static const struct das800_board das800_boards[] = {
 };
 
 struct das800_private {
-	volatile unsigned int count;	/* number of data points left to be taken */
-	volatile int forever;	/* flag indicating whether we should take data forever */
-	unsigned int divisor1;	/* value to load into board's counter 1 for timed conversions */
-	unsigned int divisor2;	/* value to load into board's counter 2 for timed conversions */
-	volatile int do_bits;	/* digital output bits */
+	unsigned int count;	/* number of data points left to be taken */
+	int forever;		/* flag that we should take data forever */
+	unsigned int divisor1;	/* counter 1 value for timed conversions */
+	unsigned int divisor2;	/* counter 2 value for timed conversions */
+	int do_bits;		/* digital output bits */
 };
 
 static void das800_ind_write(struct comedi_device *dev,

commit c1a5917157c115875d71c94fac75071a8b88ba15
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:34:00 2013 -0700

    staging: comedi: das800: cleanup the boardinfo
    
    For aesthetic reasons, name the enum used for the boardinfo indexes
    and change them to uppercase with the prefix BOARD_.
    
    Add some whitespace to the boardinfo declaration and use the enum
    values to clarify the table.
    
    Tidy up the das800_probe() function and only output a dev_dbg()
    message if a board model is actually probed. If the user provided
    the correct boardname when attaching to this driver the message
    is just added noise.
    
    For the 'default' case when checking the proded id, output the
    id_bits and return -EINVAL. It should not be assumed that unknown
    boards will work with this driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index a71a290739cc..e2bd371114be 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -169,51 +169,59 @@ static const struct comedi_lrange range_das80216_ai = {
 	}
 };
 
-enum { das800, ciodas800, das801, ciodas801, das802, ciodas802, ciodas80216 };
+enum das800_boardinfo {
+	BOARD_DAS800,
+	BOARD_CIODAS800,
+	BOARD_DAS801,
+	BOARD_CIODAS801,
+	BOARD_DAS802,
+	BOARD_CIODAS802,
+	BOARD_CIODAS80216,
+};
 
 static const struct das800_board das800_boards[] = {
-	{
-	 .name = "das-800",
-	 .ai_speed = 25000,
-	 .ai_range = &range_bipolar5,
-	 .resolution = 12,
-	 },
-	{
-	 .name = "cio-das800",
-	 .ai_speed = 20000,
-	 .ai_range = &range_bipolar5,
-	 .resolution = 12,
-	 },
-	{
-	 .name = "das-801",
-	 .ai_speed = 25000,
-	 .ai_range = &range_das801_ai,
-	 .resolution = 12,
-	 },
-	{
-	 .name = "cio-das801",
-	 .ai_speed = 20000,
-	 .ai_range = &range_cio_das801_ai,
-	 .resolution = 12,
-	 },
-	{
-	 .name = "das-802",
-	 .ai_speed = 25000,
-	 .ai_range = &range_das802_ai,
-	 .resolution = 12,
-	 },
-	{
-	 .name = "cio-das802",
-	 .ai_speed = 20000,
-	 .ai_range = &range_das802_ai,
-	 .resolution = 12,
-	 },
-	{
-	 .name = "cio-das802/16",
-	 .ai_speed = 10000,
-	 .ai_range = &range_das80216_ai,
-	 .resolution = 16,
-	 },
+	[BOARD_DAS800] = {
+		.name		= "das-800",
+		.ai_speed	= 25000,
+		.ai_range	= &range_bipolar5,
+		.resolution	= 12,
+	},
+	[BOARD_CIODAS800] = {
+		.name		= "cio-das800",
+		.ai_speed	= 20000,
+		.ai_range	= &range_bipolar5,
+		.resolution	= 12,
+	},
+	[BOARD_DAS801] = {
+		.name		= "das-801",
+		.ai_speed	= 25000,
+		.ai_range	= &range_das801_ai,
+		.resolution	= 12,
+	},
+	[BOARD_CIODAS801] = {
+		.name		= "cio-das801",
+		.ai_speed	= 20000,
+		.ai_range	= &range_cio_das801_ai,
+		.resolution	= 12,
+	},
+	[BOARD_DAS802] = {
+		.name		= "das-802",
+		.ai_speed	= 25000,
+		.ai_range	= &range_das802_ai,
+		.resolution	= 12,
+	},
+	[BOARD_CIODAS802] = {
+		.name		= "cio-das802",
+		.ai_speed	= 20000,
+		.ai_range	= &range_das802_ai,
+		.resolution	= 12,
+	},
+	[BOARD_CIODAS80216] = {
+		.name		= "cio-das802/16",
+		.ai_speed	= 10000,
+		.ai_range	= &range_das80216_ai,
+		.resolution	= 16,
+	},
 };
 
 struct das800_private {
@@ -670,65 +678,41 @@ static int das800_do_wbits(struct comedi_device *dev,
 static int das800_probe(struct comedi_device *dev)
 {
 	const struct das800_board *thisboard = comedi_board(dev);
+	int board = thisboard ? thisboard - das800_boards : -EINVAL;
 	int id_bits;
 	unsigned long irq_flags;
-	int board;
 
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	id_bits = das800_ind_read(dev, ID) & 0x3;
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
-	board = thisboard - das800_boards;
-
 	switch (id_bits) {
 	case 0x0:
-		if (board == das800) {
-			dev_dbg(dev->class_dev, "Board model: DAS-800\n");
-			return board;
-		}
-		if (board == ciodas800) {
-			dev_dbg(dev->class_dev, "Board model: CIO-DAS800\n");
-			return board;
-		}
+		if (board == BOARD_DAS800 || board == BOARD_CIODAS800)
+			break;
 		dev_dbg(dev->class_dev, "Board model (probed): DAS-800\n");
-		return das800;
+		board = BOARD_DAS800;
 		break;
 	case 0x2:
-		if (board == das801) {
-			dev_dbg(dev->class_dev, "Board model: DAS-801\n");
-			return board;
-		}
-		if (board == ciodas801) {
-			dev_dbg(dev->class_dev, "Board model: CIO-DAS801\n");
-			return board;
-		}
+		if (board == BOARD_DAS801 || board == BOARD_CIODAS801)
+			break;
 		dev_dbg(dev->class_dev, "Board model (probed): DAS-801\n");
-		return das801;
+		board = BOARD_DAS801;
 		break;
 	case 0x3:
-		if (board == das802) {
-			dev_dbg(dev->class_dev, "Board model: DAS-802\n");
-			return board;
-		}
-		if (board == ciodas802) {
-			dev_dbg(dev->class_dev, "Board model: CIO-DAS802\n");
-			return board;
-		}
-		if (board == ciodas80216) {
-			dev_dbg(dev->class_dev, "Board model: CIO-DAS802/16\n");
-			return board;
-		}
+		if (board == BOARD_DAS802 || board == BOARD_CIODAS802 ||
+		    board == BOARD_CIODAS80216)
+			break;
 		dev_dbg(dev->class_dev, "Board model (probed): DAS-802\n");
-		return das802;
+		board = BOARD_DAS802;
 		break;
 	default:
-		dev_dbg(dev->class_dev,
-			"Board model: probe returned 0x%x (unknown)\n",
+		dev_dbg(dev->class_dev, "Board model: 0x%x (unknown)\n",
 			id_bits);
-		return board;
+		board = -EINVAL;
 		break;
 	}
-	return -1;
+	return board;
 }
 
 static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)

commit b678075f9a9bad493ddb6dda833c9f334bf2dc1d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:33:41 2013 -0700

    staging: comedi: das800: cleanup range table declarations
    
    Use the BIP_RANGE and UNI_RANGE macros to define the range
    tables instead of the more generic RANGE macro.
    
    Tidy up the whitespace of the tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index bc8a23e8a5d7..a71a290739cc 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -115,62 +115,58 @@ struct das800_board {
 };
 
 static const struct comedi_lrange range_das801_ai = {
-	9,
-	{
-	 RANGE(-5, 5),
-	 RANGE(-10, 10),
-	 RANGE(0, 10),
-	 RANGE(-0.5, 0.5),
-	 RANGE(0, 1),
-	 RANGE(-0.05, 0.05),
-	 RANGE(0, 0.1),
-	 RANGE(-0.01, 0.01),
-	 RANGE(0, 0.02),
-	 }
+	9, {
+		BIP_RANGE(5),
+		BIP_RANGE(10),
+		UNI_RANGE(10),
+		BIP_RANGE(0.5),
+		UNI_RANGE(1),
+		BIP_RANGE(0.05),
+		UNI_RANGE(0.1),
+		BIP_RANGE(0.01),
+		UNI_RANGE(0.02)
+	}
 };
 
 static const struct comedi_lrange range_cio_das801_ai = {
-	9,
-	{
-	 RANGE(-5, 5),
-	 RANGE(-10, 10),
-	 RANGE(0, 10),
-	 RANGE(-0.5, 0.5),
-	 RANGE(0, 1),
-	 RANGE(-0.05, 0.05),
-	 RANGE(0, 0.1),
-	 RANGE(-0.005, 0.005),
-	 RANGE(0, 0.01),
-	 }
+	9, {
+		BIP_RANGE(5),
+		BIP_RANGE(10),
+		UNI_RANGE(10),
+		BIP_RANGE(0.5),
+		UNI_RANGE(1),
+		BIP_RANGE(0.05),
+		UNI_RANGE(0.1),
+		BIP_RANGE(0.005),
+		UNI_RANGE(0.01)
+	}
 };
 
 static const struct comedi_lrange range_das802_ai = {
-	9,
-	{
-	 RANGE(-5, 5),
-	 RANGE(-10, 10),
-	 RANGE(0, 10),
-	 RANGE(-2.5, 2.5),
-	 RANGE(0, 5),
-	 RANGE(-1.25, 1.25),
-	 RANGE(0, 2.5),
-	 RANGE(-0.625, 0.625),
-	 RANGE(0, 1.25),
-	 }
+	9, {
+		BIP_RANGE(5),
+		BIP_RANGE(10),
+		UNI_RANGE(10),
+		BIP_RANGE(2.5),
+		UNI_RANGE(5),
+		BIP_RANGE(1.25),
+		UNI_RANGE(2.5),
+		BIP_RANGE(0.625),
+		UNI_RANGE(1.25)
+	}
 };
 
 static const struct comedi_lrange range_das80216_ai = {
-	8,
-	{
-	 RANGE(-10, 10),
-	 RANGE(0, 10),
-	 RANGE(-5, 5),
-	 RANGE(0, 5),
-	 RANGE(-2.5, 2.5),
-	 RANGE(0, 2.5),
-	 RANGE(-1.25, 1.25),
-	 RANGE(0, 1.25),
-	 }
+	8, {
+		BIP_RANGE(10),
+		UNI_RANGE(10),
+		BIP_RANGE(5),
+		UNI_RANGE(5),
+		BIP_RANGE(2.5),
+		UNI_RANGE(2.5),
+		BIP_RANGE(1.25),
+		UNI_RANGE(1.25)
+	}
 };
 
 enum { das800, ciodas800, das801, ciodas801, das802, ciodas802, ciodas80216 };

commit 0a8fc08910cfec7713801b7097e9a31c960339b8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:33:22 2013 -0700

    staging: comedi: das800: introduce das800_ind_{write, read}()
    
    The GAS800_GAIN register contains some bits that enable indirect
    writing to additional registers on the board through iobase + 2
    and indirect reading of addition registers through iobase + 7.
    
    Introduce some helper functions to handle the indirect register
    write/read.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 18e2ac02aff1..bc8a23e8a5d7 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -228,6 +228,27 @@ struct das800_private {
 	volatile int do_bits;	/* digital output bits */
 };
 
+static void das800_ind_write(struct comedi_device *dev,
+			     unsigned val, unsigned reg)
+{
+	/*
+	 * Select dev->iobase + 2 to be desired register
+	 * then write to that register.
+	 */
+	outb(reg, dev->iobase + DAS800_GAIN);
+	outb(val, dev->iobase + 2);
+}
+
+static unsigned das800_ind_read(struct comedi_device *dev, unsigned reg)
+{
+	/*
+	 * Select dev->iobase + 7 to be desired register
+	 * then read from that register.
+	 */
+	outb(reg, dev->iobase + DAS800_GAIN);
+	return inb(dev->iobase + 7);
+}
+
 /* enable_das800 makes the card start taking hardware triggered conversions */
 static void enable_das800(struct comedi_device *dev)
 {
@@ -239,10 +260,10 @@ static void enable_das800(struct comedi_device *dev)
 	/*  enable fifo-half full interrupts for cio-das802/16 */
 	if (thisboard->resolution == 16)
 		outb(CIO_ENHF, dev->iobase + DAS800_GAIN);
-	outb(CONV_CONTROL, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be conversion control register */
-	outb(CONV_HCEN, dev->iobase + DAS800_CONV_CONTROL);	/* enable hardware triggering */
-	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
-	outb(CONTROL1_INTE | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);	/* enable card's interrupt */
+	/* enable hardware triggering */
+	das800_ind_write(dev, CONV_HCEN, CONV_CONTROL);
+	/* enable card's interrupt */
+	das800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits, CONTROL1);
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
@@ -250,9 +271,10 @@ static void enable_das800(struct comedi_device *dev)
 static void disable_das800(struct comedi_device *dev)
 {
 	unsigned long irq_flags;
+
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(CONV_CONTROL, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be conversion control register */
-	outb(0x0, dev->iobase + DAS800_CONV_CONTROL);	/* disable hardware triggering of conversions */
+	/* disable hardware triggering of conversions */
+	das800_ind_write(dev, 0x0, CONV_CONTROL);
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
@@ -398,8 +420,8 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	scan = (endChan << 3) | startChan;
 
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(SCAN_LIMITS, dev->iobase + DAS800_GAIN);	/* select base address + 2 to be scan limits register */
-	outb(scan, dev->iobase + DAS800_SCAN_LIMITS);	/* set scan limits */
+	/* set scan limits */
+	das800_ind_write(dev, scan, SCAN_LIMITS);
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	/* set gain */
@@ -450,9 +472,9 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	}
 
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(CONV_CONTROL, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be conversion control register */
-	outb(conv_bits, dev->iobase + DAS800_CONV_CONTROL);
+	das800_ind_write(dev, conv_bits, CONV_CONTROL);
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+
 	async->events = 0;
 	enable_das800(dev);
 	return 0;
@@ -488,8 +510,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 
 	/*  if hardware conversions are not enabled, then quit */
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be STATUS2 register */
-	status = inb(dev->iobase + DAS800_STATUS2) & STATUS2_HCEN;
+	status = das800_ind_read(dev, CONTROL1) & STATUS2_HCEN;
 	/* don't release spinlock yet since we want to make sure no one else disables hardware conversions */
 	if (status == 0) {
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
@@ -542,9 +563,8 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	if (devpriv->count > 0 || devpriv->forever == 1) {
 		/* Re-enable card's interrupt.
 		 * We already have spinlock, so indirect addressing is safe */
-		outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
-		outb(CONTROL1_INTE | devpriv->do_bits,
-		     dev->iobase + DAS800_CONTROL1);
+		das800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits,
+				 CONTROL1);
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		/* otherwise, stop taking data */
 	} else {
@@ -576,8 +596,7 @@ static int das800_ai_rinsn(struct comedi_device *dev,
 	chan = CR_CHAN(insn->chanspec);
 
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
-	outb(chan | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);
+	das800_ind_write(dev, chan | devpriv->do_bits, CONTROL1);
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	/* set gain / range */
@@ -644,8 +663,7 @@ static int das800_do_wbits(struct comedi_device *dev,
 	devpriv->do_bits = wbits << 4;
 
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
-	outb(devpriv->do_bits | CONTROL1_INTE, dev->iobase + DAS800_CONTROL1);
+	das800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits, CONTROL1);
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	data[1] = wbits;
@@ -661,8 +679,7 @@ static int das800_probe(struct comedi_device *dev)
 	int board;
 
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(ID, dev->iobase + DAS800_GAIN);
-	id_bits = inb(dev->iobase + DAS800_ID) & 0x3;
+	id_bits = das800_ind_read(dev, ID) & 0x3;
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	board = thisboard - das800_boards;
@@ -801,8 +818,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* initialize digital out channels */
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
-	outb(CONTROL1_INTE | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);
+	das800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits, CONTROL1);
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	return 0;

commit fe9b0850ab8f6f5a91a170cca07d24a2afb4ceb9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:33:03 2013 -0700

    staging: comedi: das800: remove forward declarations
    
    Move the das800_cancel() and das800_interrupt() functions to remove
    the need for the remaining forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 596be5e991b6..18e2ac02aff1 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -228,122 +228,6 @@ struct das800_private {
 	volatile int do_bits;	/* digital output bits */
 };
 
-static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-
-static irqreturn_t das800_interrupt(int irq, void *d);
-static void enable_das800(struct comedi_device *dev);
-static void disable_das800(struct comedi_device *dev);
-
-/* interrupt service routine */
-static irqreturn_t das800_interrupt(int irq, void *d)
-{
-	short i;		/* loop index */
-	short dataPoint = 0;
-	struct comedi_device *dev = d;
-	const struct das800_board *thisboard = comedi_board(dev);
-	struct das800_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->read_subdev;	/* analog input subdevice */
-	struct comedi_async *async;
-	int status;
-	unsigned long irq_flags;
-	static const int max_loops = 128;	/*  half-fifo size for cio-das802/16 */
-	/*  flags */
-	int fifo_empty = 0;
-	int fifo_overflow = 0;
-
-	status = inb(dev->iobase + DAS800_STATUS);
-	/* if interrupt was not generated by board or driver not attached, quit */
-	if (!(status & IRQ))
-		return IRQ_NONE;
-	if (!(dev->attached))
-		return IRQ_HANDLED;
-
-	/* wait until here to initialize async, since we will get null dereference
-	 * if interrupt occurs before driver is fully attached!
-	 */
-	async = s->async;
-
-	/*  if hardware conversions are not enabled, then quit */
-	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be STATUS2 register */
-	status = inb(dev->iobase + DAS800_STATUS2) & STATUS2_HCEN;
-	/* don't release spinlock yet since we want to make sure no one else disables hardware conversions */
-	if (status == 0) {
-		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-		return IRQ_HANDLED;
-	}
-
-	/* loop while card's fifo is not empty (and limit to half fifo for cio-das802/16) */
-	for (i = 0; i < max_loops; i++) {
-		/* read 16 bits from dev->iobase and dev->iobase + 1 */
-		dataPoint = inb(dev->iobase + DAS800_LSB);
-		dataPoint += inb(dev->iobase + DAS800_MSB) << 8;
-		if (thisboard->resolution == 12) {
-			fifo_empty = dataPoint & FIFO_EMPTY;
-			fifo_overflow = dataPoint & FIFO_OVF;
-			if (fifo_overflow)
-				break;
-		} else {
-			fifo_empty = 0;	/*  cio-das802/16 has no fifo empty status bit */
-		}
-		if (fifo_empty)
-			break;
-		/* strip off extraneous bits for 12 bit cards */
-		if (thisboard->resolution == 12)
-			dataPoint = (dataPoint >> 4) & 0xfff;
-		/* if there are more data points to collect */
-		if (devpriv->count > 0 || devpriv->forever == 1) {
-			/* write data point to buffer */
-			cfc_write_to_buffer(s, dataPoint);
-			if (devpriv->count > 0)
-				devpriv->count--;
-		}
-	}
-	async->events |= COMEDI_CB_BLOCK;
-	/* check for fifo overflow */
-	if (thisboard->resolution == 12) {
-		fifo_overflow = dataPoint & FIFO_OVF;
-		/*  else cio-das802/16 */
-	} else {
-		fifo_overflow = inb(dev->iobase + DAS800_GAIN) & CIO_FFOV;
-	}
-	if (fifo_overflow) {
-		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-		comedi_error(dev, "DAS800 FIFO overflow");
-		das800_cancel(dev, s);
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		comedi_event(dev, s);
-		async->events = 0;
-		return IRQ_HANDLED;
-	}
-	if (devpriv->count > 0 || devpriv->forever == 1) {
-		/* Re-enable card's interrupt.
-		 * We already have spinlock, so indirect addressing is safe */
-		outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
-		outb(CONTROL1_INTE | devpriv->do_bits,
-		     dev->iobase + DAS800_CONTROL1);
-		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-		/* otherwise, stop taking data */
-	} else {
-		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-		disable_das800(dev);	/* disable hardware triggered conversions */
-		async->events |= COMEDI_CB_EOA;
-	}
-	comedi_event(dev, s);
-	async->events = 0;
-	return IRQ_HANDLED;
-}
-
-static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	struct das800_private *devpriv = dev->private;
-
-	devpriv->forever = 0;
-	devpriv->count = 0;
-	disable_das800(dev);
-	return 0;
-}
-
 /* enable_das800 makes the card start taking hardware triggered conversions */
 static void enable_das800(struct comedi_device *dev)
 {
@@ -387,6 +271,16 @@ static int das800_set_frequency(struct comedi_device *dev)
 	return 0;
 }
 
+static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+{
+	struct das800_private *devpriv = dev->private;
+
+	devpriv->forever = 0;
+	devpriv->count = 0;
+	disable_das800(dev);
+	return 0;
+}
+
 static int das800_ai_do_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
@@ -564,6 +458,105 @@ static int das800_ai_do_cmd(struct comedi_device *dev,
 	return 0;
 }
 
+static irqreturn_t das800_interrupt(int irq, void *d)
+{
+	short i;		/* loop index */
+	short dataPoint = 0;
+	struct comedi_device *dev = d;
+	const struct das800_board *thisboard = comedi_board(dev);
+	struct das800_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;	/* analog input subdevice */
+	struct comedi_async *async;
+	int status;
+	unsigned long irq_flags;
+	static const int max_loops = 128;	/*  half-fifo size for cio-das802/16 */
+	/*  flags */
+	int fifo_empty = 0;
+	int fifo_overflow = 0;
+
+	status = inb(dev->iobase + DAS800_STATUS);
+	/* if interrupt was not generated by board or driver not attached, quit */
+	if (!(status & IRQ))
+		return IRQ_NONE;
+	if (!(dev->attached))
+		return IRQ_HANDLED;
+
+	/* wait until here to initialize async, since we will get null dereference
+	 * if interrupt occurs before driver is fully attached!
+	 */
+	async = s->async;
+
+	/*  if hardware conversions are not enabled, then quit */
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be STATUS2 register */
+	status = inb(dev->iobase + DAS800_STATUS2) & STATUS2_HCEN;
+	/* don't release spinlock yet since we want to make sure no one else disables hardware conversions */
+	if (status == 0) {
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		return IRQ_HANDLED;
+	}
+
+	/* loop while card's fifo is not empty (and limit to half fifo for cio-das802/16) */
+	for (i = 0; i < max_loops; i++) {
+		/* read 16 bits from dev->iobase and dev->iobase + 1 */
+		dataPoint = inb(dev->iobase + DAS800_LSB);
+		dataPoint += inb(dev->iobase + DAS800_MSB) << 8;
+		if (thisboard->resolution == 12) {
+			fifo_empty = dataPoint & FIFO_EMPTY;
+			fifo_overflow = dataPoint & FIFO_OVF;
+			if (fifo_overflow)
+				break;
+		} else {
+			fifo_empty = 0;	/*  cio-das802/16 has no fifo empty status bit */
+		}
+		if (fifo_empty)
+			break;
+		/* strip off extraneous bits for 12 bit cards */
+		if (thisboard->resolution == 12)
+			dataPoint = (dataPoint >> 4) & 0xfff;
+		/* if there are more data points to collect */
+		if (devpriv->count > 0 || devpriv->forever == 1) {
+			/* write data point to buffer */
+			cfc_write_to_buffer(s, dataPoint);
+			if (devpriv->count > 0)
+				devpriv->count--;
+		}
+	}
+	async->events |= COMEDI_CB_BLOCK;
+	/* check for fifo overflow */
+	if (thisboard->resolution == 12) {
+		fifo_overflow = dataPoint & FIFO_OVF;
+		/*  else cio-das802/16 */
+	} else {
+		fifo_overflow = inb(dev->iobase + DAS800_GAIN) & CIO_FFOV;
+	}
+	if (fifo_overflow) {
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		comedi_error(dev, "DAS800 FIFO overflow");
+		das800_cancel(dev, s);
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		comedi_event(dev, s);
+		async->events = 0;
+		return IRQ_HANDLED;
+	}
+	if (devpriv->count > 0 || devpriv->forever == 1) {
+		/* Re-enable card's interrupt.
+		 * We already have spinlock, so indirect addressing is safe */
+		outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
+		outb(CONTROL1_INTE | devpriv->do_bits,
+		     dev->iobase + DAS800_CONTROL1);
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		/* otherwise, stop taking data */
+	} else {
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		disable_das800(dev);	/* disable hardware triggered conversions */
+		async->events |= COMEDI_CB_EOA;
+	}
+	comedi_event(dev, s);
+	async->events = 0;
+	return IRQ_HANDLED;
+}
+
 static int das800_ai_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)

commit 62c3b4bf66bfff62faf4556ee5ba251ba5e8b506
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:32:43 2013 -0700

    staging: comedi: das800: move das800_set_frequency()
    
    Move das800_set_frequency() to avoid the need for the forward
    declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 630a14dd5b2e..596be5e991b6 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -233,7 +233,6 @@ static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static irqreturn_t das800_interrupt(int irq, void *d);
 static void enable_das800(struct comedi_device *dev);
 static void disable_das800(struct comedi_device *dev);
-static int das800_set_frequency(struct comedi_device *dev);
 
 /* interrupt service routine */
 static irqreturn_t das800_interrupt(int irq, void *d)
@@ -373,6 +372,21 @@ static void disable_das800(struct comedi_device *dev)
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
+static int das800_set_frequency(struct comedi_device *dev)
+{
+	struct das800_private *devpriv = dev->private;
+	int err = 0;
+
+	if (i8254_load(dev->iobase + DAS800_8254, 0, 1, devpriv->divisor1, 2))
+		err++;
+	if (i8254_load(dev->iobase + DAS800_8254, 0, 2, devpriv->divisor2, 2))
+		err++;
+	if (err)
+		return -1;
+
+	return 0;
+}
+
 static int das800_ai_do_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
@@ -646,22 +660,6 @@ static int das800_do_wbits(struct comedi_device *dev,
 	return insn->n;
 }
 
-/* loads counters with divisor1, divisor2 from private structure */
-static int das800_set_frequency(struct comedi_device *dev)
-{
-	struct das800_private *devpriv = dev->private;
-	int err = 0;
-
-	if (i8254_load(dev->iobase + DAS800_8254, 0, 1, devpriv->divisor1, 2))
-		err++;
-	if (i8254_load(dev->iobase + DAS800_8254, 0, 2, devpriv->divisor2, 2))
-		err++;
-	if (err)
-		return -1;
-
-	return 0;
-}
-
 static int das800_probe(struct comedi_device *dev)
 {
 	const struct das800_board *thisboard = comedi_board(dev);

commit 4f71ceebebe8af5a4cbedf13c88d1908a96987fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:32:25 2013 -0700

    staging: comedi: das800: move das800_probe()
    
    For aesthetic reasons, move the das800_probe() function near its
    only caller, das800_attach().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index b3221b77559e..630a14dd5b2e 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -235,73 +235,6 @@ static void enable_das800(struct comedi_device *dev);
 static void disable_das800(struct comedi_device *dev);
 static int das800_set_frequency(struct comedi_device *dev);
 
-/* checks and probes das-800 series board type */
-static int das800_probe(struct comedi_device *dev)
-{
-	const struct das800_board *thisboard = comedi_board(dev);
-	int id_bits;
-	unsigned long irq_flags;
-	int board;
-
-	/*  'comedi spin lock irqsave' disables even rt interrupts, we use them to protect indirect addressing */
-	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(ID, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be ID register */
-	id_bits = inb(dev->iobase + DAS800_ID) & 0x3;	/* get id bits */
-	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-
-	board = thisboard - das800_boards;
-
-	switch (id_bits) {
-	case 0x0:
-		if (board == das800) {
-			dev_dbg(dev->class_dev, "Board model: DAS-800\n");
-			return board;
-		}
-		if (board == ciodas800) {
-			dev_dbg(dev->class_dev, "Board model: CIO-DAS800\n");
-			return board;
-		}
-		dev_dbg(dev->class_dev, "Board model (probed): DAS-800\n");
-		return das800;
-		break;
-	case 0x2:
-		if (board == das801) {
-			dev_dbg(dev->class_dev, "Board model: DAS-801\n");
-			return board;
-		}
-		if (board == ciodas801) {
-			dev_dbg(dev->class_dev, "Board model: CIO-DAS801\n");
-			return board;
-		}
-		dev_dbg(dev->class_dev, "Board model (probed): DAS-801\n");
-		return das801;
-		break;
-	case 0x3:
-		if (board == das802) {
-			dev_dbg(dev->class_dev, "Board model: DAS-802\n");
-			return board;
-		}
-		if (board == ciodas802) {
-			dev_dbg(dev->class_dev, "Board model: CIO-DAS802\n");
-			return board;
-		}
-		if (board == ciodas80216) {
-			dev_dbg(dev->class_dev, "Board model: CIO-DAS802/16\n");
-			return board;
-		}
-		dev_dbg(dev->class_dev, "Board model (probed): DAS-802\n");
-		return das802;
-		break;
-	default:
-		dev_dbg(dev->class_dev,
-			"Board model: probe returned 0x%x (unknown)\n",
-			id_bits);
-		return board;
-		break;
-	}
-	return -1;
-}
-
 /* interrupt service routine */
 static irqreturn_t das800_interrupt(int irq, void *d)
 {
@@ -729,6 +662,71 @@ static int das800_set_frequency(struct comedi_device *dev)
 	return 0;
 }
 
+static int das800_probe(struct comedi_device *dev)
+{
+	const struct das800_board *thisboard = comedi_board(dev);
+	int id_bits;
+	unsigned long irq_flags;
+	int board;
+
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(ID, dev->iobase + DAS800_GAIN);
+	id_bits = inb(dev->iobase + DAS800_ID) & 0x3;
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+
+	board = thisboard - das800_boards;
+
+	switch (id_bits) {
+	case 0x0:
+		if (board == das800) {
+			dev_dbg(dev->class_dev, "Board model: DAS-800\n");
+			return board;
+		}
+		if (board == ciodas800) {
+			dev_dbg(dev->class_dev, "Board model: CIO-DAS800\n");
+			return board;
+		}
+		dev_dbg(dev->class_dev, "Board model (probed): DAS-800\n");
+		return das800;
+		break;
+	case 0x2:
+		if (board == das801) {
+			dev_dbg(dev->class_dev, "Board model: DAS-801\n");
+			return board;
+		}
+		if (board == ciodas801) {
+			dev_dbg(dev->class_dev, "Board model: CIO-DAS801\n");
+			return board;
+		}
+		dev_dbg(dev->class_dev, "Board model (probed): DAS-801\n");
+		return das801;
+		break;
+	case 0x3:
+		if (board == das802) {
+			dev_dbg(dev->class_dev, "Board model: DAS-802\n");
+			return board;
+		}
+		if (board == ciodas802) {
+			dev_dbg(dev->class_dev, "Board model: CIO-DAS802\n");
+			return board;
+		}
+		if (board == ciodas80216) {
+			dev_dbg(dev->class_dev, "Board model: CIO-DAS802/16\n");
+			return board;
+		}
+		dev_dbg(dev->class_dev, "Board model (probed): DAS-802\n");
+		return das802;
+		break;
+	default:
+		dev_dbg(dev->class_dev,
+			"Board model: probe returned 0x%x (unknown)\n",
+			id_bits);
+		return board;
+		break;
+	}
+	return -1;
+}
+
 static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct das800_board *thisboard = comedi_board(dev);

commit 92046ae49dec96ec40d861721c922c50fabf1756
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:32:06 2013 -0700

    staging: comedi: das800: move das800_attach()
    
    The move the das800_attach() function near the comedi_driver
    declaration at the end of the file. This also removes the need
    for some of the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 3a4041d6f5e6..b3221b77559e 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -233,21 +233,6 @@ static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static irqreturn_t das800_interrupt(int irq, void *d);
 static void enable_das800(struct comedi_device *dev);
 static void disable_das800(struct comedi_device *dev);
-static int das800_ai_do_cmdtest(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_cmd *cmd);
-static int das800_ai_do_cmd(struct comedi_device *dev,
-			    struct comedi_subdevice *s);
-static int das800_ai_rinsn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data);
-static int das800_di_rbits(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data);
-static int das800_do_wbits(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data);
-static int das800_probe(struct comedi_device *dev);
 static int das800_set_frequency(struct comedi_device *dev);
 
 /* checks and probes das-800 series board type */
@@ -417,96 +402,6 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
-{
-	const struct das800_board *thisboard = comedi_board(dev);
-	struct das800_private *devpriv;
-	struct comedi_subdevice *s;
-	unsigned int irq = it->options[1];
-	unsigned long irq_flags;
-	int board;
-	int ret;
-
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
-	if (!devpriv)
-		return -ENOMEM;
-	dev->private = devpriv;
-
-	ret = comedi_request_region(dev, it->options[0], DAS800_SIZE);
-	if (ret)
-		return ret;
-
-	board = das800_probe(dev);
-	if (board < 0) {
-		dev_dbg(dev->class_dev, "unable to determine board type\n");
-		return -ENODEV;
-	}
-	dev->board_ptr = das800_boards + board;
-	thisboard = comedi_board(dev);
-
-	/* grab our IRQ */
-	if (irq == 1 || irq > 7) {
-		dev_err(dev->class_dev, "irq out of range\n");
-		return -EINVAL;
-	}
-	if (irq) {
-		if (request_irq(irq, das800_interrupt, 0, "das800", dev)) {
-			dev_err(dev->class_dev, "unable to allocate irq %u\n",
-				irq);
-			return -EINVAL;
-		}
-	}
-	dev->irq = irq;
-
-	dev->board_name = thisboard->name;
-
-	ret = comedi_alloc_subdevices(dev, 3);
-	if (ret)
-		return ret;
-
-	/* analog input subdevice */
-	s = &dev->subdevices[0];
-	dev->read_subdev = s;
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
-	s->n_chan = 8;
-	s->len_chanlist = 8;
-	s->maxdata = (1 << thisboard->resolution) - 1;
-	s->range_table = thisboard->ai_range;
-	s->do_cmd = das800_ai_do_cmd;
-	s->do_cmdtest = das800_ai_do_cmdtest;
-	s->insn_read = das800_ai_rinsn;
-	s->cancel = das800_cancel;
-
-	/* di */
-	s = &dev->subdevices[1];
-	s->type = COMEDI_SUBD_DI;
-	s->subdev_flags = SDF_READABLE;
-	s->n_chan = 3;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_bits = das800_di_rbits;
-
-	/* do */
-	s = &dev->subdevices[2];
-	s->type = COMEDI_SUBD_DO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 4;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_bits = das800_do_wbits;
-
-	disable_das800(dev);
-
-	/* initialize digital out channels */
-	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
-	outb(CONTROL1_INTE | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);
-	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-
-	return 0;
-};
-
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct das800_private *devpriv = dev->private;
@@ -834,6 +729,96 @@ static int das800_set_frequency(struct comedi_device *dev)
 	return 0;
 }
 
+static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+	const struct das800_board *thisboard = comedi_board(dev);
+	struct das800_private *devpriv;
+	struct comedi_subdevice *s;
+	unsigned int irq = it->options[1];
+	unsigned long irq_flags;
+	int board;
+	int ret;
+
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
+
+	ret = comedi_request_region(dev, it->options[0], DAS800_SIZE);
+	if (ret)
+		return ret;
+
+	board = das800_probe(dev);
+	if (board < 0) {
+		dev_dbg(dev->class_dev, "unable to determine board type\n");
+		return -ENODEV;
+	}
+	dev->board_ptr = das800_boards + board;
+	thisboard = comedi_board(dev);
+
+	/* grab our IRQ */
+	if (irq == 1 || irq > 7) {
+		dev_err(dev->class_dev, "irq out of range\n");
+		return -EINVAL;
+	}
+	if (irq) {
+		if (request_irq(irq, das800_interrupt, 0, "das800", dev)) {
+			dev_err(dev->class_dev, "unable to allocate irq %u\n",
+				irq);
+			return -EINVAL;
+		}
+	}
+	dev->irq = irq;
+
+	dev->board_name = thisboard->name;
+
+	ret = comedi_alloc_subdevices(dev, 3);
+	if (ret)
+		return ret;
+
+	/* analog input subdevice */
+	s = &dev->subdevices[0];
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
+	s->n_chan = 8;
+	s->len_chanlist = 8;
+	s->maxdata = (1 << thisboard->resolution) - 1;
+	s->range_table = thisboard->ai_range;
+	s->do_cmd = das800_ai_do_cmd;
+	s->do_cmdtest = das800_ai_do_cmdtest;
+	s->insn_read = das800_ai_rinsn;
+	s->cancel = das800_cancel;
+
+	/* di */
+	s = &dev->subdevices[1];
+	s->type = COMEDI_SUBD_DI;
+	s->subdev_flags = SDF_READABLE;
+	s->n_chan = 3;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_bits = das800_di_rbits;
+
+	/* do */
+	s = &dev->subdevices[2];
+	s->type = COMEDI_SUBD_DO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = 4;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_bits = das800_do_wbits;
+
+	disable_das800(dev);
+
+	/* initialize digital out channels */
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
+	outb(CONTROL1_INTE | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+
+	return 0;
+};
+
 static struct comedi_driver driver_das800 = {
 	.driver_name	= "das800",
 	.module		= THIS_MODULE,

commit 79a8c0e20eb9f0cb6aaaab87c56addff606d19fe
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 18:31:47 2013 -0700

    staging: comedi: das800: move module_{init, exit} to end of file
    
    The module_comedi_driver() macro provides the module_{init.exit}
    code for this driver. Move the macro call and the comedi_driver
    declaration to the end of the file. This also removes the need
    for the das800_attach() forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 6e37033eab5b..3a4041d6f5e6 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -228,20 +228,8 @@ struct das800_private {
 	volatile int do_bits;	/* digital output bits */
 };
 
-static int das800_attach(struct comedi_device *dev,
-			 struct comedi_devconfig *it);
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
-static struct comedi_driver driver_das800 = {
-	.driver_name = "das800",
-	.module = THIS_MODULE,
-	.attach = das800_attach,
-	.detach = comedi_legacy_detach,
-	.num_names = ARRAY_SIZE(das800_boards),
-	.board_name = &das800_boards[0].name,
-	.offset = sizeof(struct das800_board),
-};
-
 static irqreturn_t das800_interrupt(int irq, void *d);
 static void enable_das800(struct comedi_device *dev);
 static void disable_das800(struct comedi_device *dev);
@@ -329,8 +317,6 @@ static int das800_probe(struct comedi_device *dev)
 	return -1;
 }
 
-module_comedi_driver(driver_das800);
-
 /* interrupt service routine */
 static irqreturn_t das800_interrupt(int irq, void *d)
 {
@@ -848,6 +834,17 @@ static int das800_set_frequency(struct comedi_device *dev)
 	return 0;
 }
 
+static struct comedi_driver driver_das800 = {
+	.driver_name	= "das800",
+	.module		= THIS_MODULE,
+	.attach		= das800_attach,
+	.detach		= comedi_legacy_detach,
+	.num_names	= ARRAY_SIZE(das800_boards),
+	.board_name	= &das800_boards[0].name,
+	.offset		= sizeof(struct das800_board),
+};
+module_comedi_driver(driver_das800);
+
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");
 MODULE_LICENSE("GPL");

commit 3d1fe3f785c80e17f62acf8f92570ae9210bd588
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:37 2013 -0700

    staging: comedi: drivers: free_irq() in comedi_legacy_detach()
    
    All the legacy comedi drivers now call comedi_legacy_detach()
    either directly or as part of their (*detach). Move the free_irq()
    into comedi_legacy_detach() so that the drivers don't have to
    deal with it.
    
    For drivers that then only call comedi_legacy_detach() in their
    private (*detach), remove the private function and use the helper
    directly for the (*detach).
    
    The amplc_pc236 and ni_labpc drivers are hybrid legacy/PCI drivers.
    In the detach of a PCI board free_irq() still needs to be handled
    by the driver.
    
    The pcl724 and pcl726 drivers currently have the free_irq() #ifdef'ed
    out. The comedi_legacy_detach() function sanity checks that the irq
    has been requested before freeing it so they are safe to convert.
    
    For aesthetic reasons, move the #ifdef unused chunk in the pcl816
    driver up to the previous #ifdef unused block.
    
    The pcmio and pcmuio drivers request multiple irqs and handle the
    freeing of them. Remove the 'dev->irq = irq[0]' in those drivers
    so that comedi_legacy_detach() does not attempt to free the irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 3456d9eb18e1..6e37033eab5b 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -230,14 +230,13 @@ struct das800_private {
 
 static int das800_attach(struct comedi_device *dev,
 			 struct comedi_devconfig *it);
-static void das800_detach(struct comedi_device *dev);
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static struct comedi_driver driver_das800 = {
 	.driver_name = "das800",
 	.module = THIS_MODULE,
 	.attach = das800_attach,
-	.detach = das800_detach,
+	.detach = comedi_legacy_detach,
 	.num_names = ARRAY_SIZE(das800_boards),
 	.board_name = &das800_boards[0].name,
 	.offset = sizeof(struct das800_board),
@@ -522,13 +521,6 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 0;
 };
 
-static void das800_detach(struct comedi_device *dev)
-{
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	comedi_legacy_detach(dev);
-}
-
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct das800_private *devpriv = dev->private;

commit a32c6d0084992d3e58a93120c9ce9527e80c651e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:19 2013 -0700

    staging: comedi: drivers: use comedi_legacy_detach()
    
    Use comedi_legacy_detach() to release the I/O region requested
    by these drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index d56584d171c8..3456d9eb18e1 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -524,11 +524,10 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void das800_detach(struct comedi_device *dev)
 {
-	if (dev->iobase)
-		release_region(dev->iobase, DAS800_SIZE);
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-};
+	comedi_legacy_detach(dev);
+}
 
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {

commit 5c7fa612f48bfdaff2b655111bf46e5636b4f687
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:16:18 2013 -0700

    staging: comedi: das800: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Remove the noise when the board is first attached as well as the
    error message when the request_region() fails, comedi_request_reqion()
    will output the error message if necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 14975f8e5b49..d56584d171c8 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -437,33 +437,19 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv;
 	struct comedi_subdevice *s;
-	unsigned long iobase = it->options[0];
 	unsigned int irq = it->options[1];
 	unsigned long irq_flags;
 	int board;
 	int ret;
 
-	dev_info(dev->class_dev, "das800: io 0x%lx\n", iobase);
-	if (irq)
-		dev_dbg(dev->class_dev, "irq %u\n", irq);
-
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	if (iobase == 0) {
-		dev_err(dev->class_dev,
-			"io base address required for das800\n");
-		return -EINVAL;
-	}
-
-	/* check if io addresses are available */
-	if (!request_region(iobase, DAS800_SIZE, "das800")) {
-		dev_err(dev->class_dev, "I/O port conflict\n");
-		return -EIO;
-	}
-	dev->iobase = iobase;
+	ret = comedi_request_region(dev, it->options[0], DAS800_SIZE);
+	if (ret)
+		return ret;
 
 	board = das800_probe(dev);
 	if (board < 0) {

commit 3cb65d4d9dfe058c58755d5b371f4d071437a6c1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 5 17:35:44 2013 -0700

    staging: comedi: das800: remove 'thisboard' macro
    
    The 'thisboard' macro relies on a local variable having a specific
    name and yields a pointer derived from that local variable.
    
    Replace the macro with local variables and use the comedi_board()
    helper to get the pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 1cf9ddd90838..14975f8e5b49 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -220,11 +220,6 @@ static const struct das800_board das800_boards[] = {
 	 },
 };
 
-/*
- * Useful for shorthand access to the particular board structure
- */
-#define thisboard ((const struct das800_board *)dev->board_ptr)
-
 struct das800_private {
 	volatile unsigned int count;	/* number of data points left to be taken */
 	volatile int forever;	/* flag indicating whether we should take data forever */
@@ -271,6 +266,7 @@ static int das800_set_frequency(struct comedi_device *dev);
 /* checks and probes das-800 series board type */
 static int das800_probe(struct comedi_device *dev)
 {
+	const struct das800_board *thisboard = comedi_board(dev);
 	int id_bits;
 	unsigned long irq_flags;
 	int board;
@@ -342,6 +338,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	short i;		/* loop index */
 	short dataPoint = 0;
 	struct comedi_device *dev = d;
+	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;	/* analog input subdevice */
 	struct comedi_async *async;
@@ -437,6 +434,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 
 static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
@@ -473,6 +471,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENODEV;
 	}
 	dev->board_ptr = das800_boards + board;
+	thisboard = comedi_board(dev);
 
 	/* grab our IRQ */
 	if (irq == 1 || irq > 7) {
@@ -558,6 +557,7 @@ static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 /* enable_das800 makes the card start taking hardware triggered conversions */
 static void enable_das800(struct comedi_device *dev)
 {
+	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
 	unsigned long irq_flags;
 
@@ -586,6 +586,7 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
 {
+	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
 	int err = 0;
 	int tmp;
@@ -677,6 +678,7 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 static int das800_ai_do_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
 	int startChan, endChan, scan, gain;
 	int conv_bits;
@@ -761,6 +763,7 @@ static int das800_ai_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	const struct das800_board *thisboard = comedi_board(dev);
 	struct das800_private *devpriv = dev->private;
 	int i, n;
 	int chan;

commit f737279b36f9e345c406e599880a3392fbd95a33
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 3 13:37:21 2013 -0700

    staging: comedi: das800: use comedi provided range_bipolar5
    
    Remove the private range, range_das800_ai, in this driver and use
    the comedi provided range_bipolar5 instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 38f625be812a..1cf9ddd90838 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -114,14 +114,6 @@ struct das800_board {
 	int resolution;
 };
 
-/* analog input ranges */
-static const struct comedi_lrange range_das800_ai = {
-	1,
-	{
-	 RANGE(-5, 5),
-	 }
-};
-
 static const struct comedi_lrange range_das801_ai = {
 	9,
 	{
@@ -187,13 +179,13 @@ static const struct das800_board das800_boards[] = {
 	{
 	 .name = "das-800",
 	 .ai_speed = 25000,
-	 .ai_range = &range_das800_ai,
+	 .ai_range = &range_bipolar5,
 	 .resolution = 12,
 	 },
 	{
 	 .name = "cio-das800",
 	 .ai_speed = 20000,
-	 .ai_range = &range_das800_ai,
+	 .ai_range = &range_bipolar5,
 	 .resolution = 12,
 	 },
 	{

commit 50b825ffa3f3c16d273e396f8a2977d2a76da2fd
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:50:51 2012 -0700

    staging: comedi: das800: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of das800_ai_do_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 85ab24c4556a..38f625be812a 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -622,37 +622,21 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < thisboard->ai_speed) {
-			cmd->convert_arg = thisboard->ai_speed;
-			err++;
-		}
-	}
-	if (!cmd->chanlist_len) {
-		cmd->chanlist_len = 1;
-		err++;
-	}
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (!cmd->stop_arg) {
-			cmd->stop_arg = 1;
-			err++;
-		}
-	} else {		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+
+	if (cmd->convert_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+						 thisboard->ai_speed);
+
+	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit 3d568028ba910ab03b3186d0b8331acd8f0ec15e
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Fri Oct 26 23:23:00 2012 +0800

    staging: comedi: use module_comedi_driver to simplify the code
    
    Use the module_comedi_driver() macro to make the code simpler
    by eliminating module_init and module_exit calls.
    
    dpatch engine is used to auto generate this patch.
    (https://github.com/weiyj/dpatch)
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 1ba26b46fd9a..85ab24c4556a 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -342,22 +342,7 @@ static int das800_probe(struct comedi_device *dev)
 	return -1;
 }
 
-/*
- * A convenient macro that defines init_module() and cleanup_module(),
- * as necessary.
- */
-static int __init driver_das800_init_module(void)
-{
-	return comedi_driver_register(&driver_das800);
-}
-
-static void __exit driver_das800_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_das800);
-}
-
-module_init(driver_das800_init_module);
-module_exit(driver_das800_cleanup_module);
+module_comedi_driver(driver_das800);
 
 /* interrupt service routine */
 static irqreturn_t das800_interrupt(int irq, void *d)

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 2a6df6b6ae39..1ba26b46fd9a 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -472,10 +472,10 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (irq)
 		dev_dbg(dev->class_dev, "irq %u\n", irq);
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	if (iobase == 0) {
 		dev_err(dev->class_dev,

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 215deac0a396..2a6df6b6ae39 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -241,8 +241,6 @@ struct das800_private {
 	volatile int do_bits;	/* digital output bits */
 };
 
-#define devpriv ((struct das800_private *)dev->private)
-
 static int das800_attach(struct comedi_device *dev,
 			 struct comedi_devconfig *it);
 static void das800_detach(struct comedi_device *dev);
@@ -367,6 +365,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	short i;		/* loop index */
 	short dataPoint = 0;
 	struct comedi_device *dev = d;
+	struct das800_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;	/* analog input subdevice */
 	struct comedi_async *async;
 	int status;
@@ -461,6 +460,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 
 static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	struct das800_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
 	unsigned int irq = it->options[1];
@@ -472,9 +472,10 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (irq)
 		dev_dbg(dev->class_dev, "irq %u\n", irq);
 
-	/* allocate and initialize dev->private */
-	if (alloc_private(dev, sizeof(struct das800_private)) < 0)
-		return -ENOMEM;
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
+		return ret;
+	devpriv = dev->private;
 
 	if (iobase == 0) {
 		dev_err(dev->class_dev,
@@ -569,6 +570,8 @@ static void das800_detach(struct comedi_device *dev)
 
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct das800_private *devpriv = dev->private;
+
 	devpriv->forever = 0;
 	devpriv->count = 0;
 	disable_das800(dev);
@@ -578,7 +581,9 @@ static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 /* enable_das800 makes the card start taking hardware triggered conversions */
 static void enable_das800(struct comedi_device *dev)
 {
+	struct das800_private *devpriv = dev->private;
 	unsigned long irq_flags;
+
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	/*  enable fifo-half full interrupts for cio-das802/16 */
 	if (thisboard->resolution == 16)
@@ -604,6 +609,7 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
 {
+	struct das800_private *devpriv = dev->private;
 	int err = 0;
 	int tmp;
 	int gain, startChan;
@@ -710,6 +716,7 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 static int das800_ai_do_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	struct das800_private *devpriv = dev->private;
 	int startChan, endChan, scan, gain;
 	int conv_bits;
 	unsigned long irq_flags;
@@ -793,6 +800,7 @@ static int das800_ai_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	struct das800_private *devpriv = dev->private;
 	int i, n;
 	int chan;
 	int range;
@@ -862,6 +870,7 @@ static int das800_do_wbits(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	struct das800_private *devpriv = dev->private;
 	int wbits;
 	unsigned long irq_flags;
 
@@ -885,6 +894,7 @@ static int das800_do_wbits(struct comedi_device *dev,
 /* loads counters with divisor1, divisor2 from private structure */
 static int das800_set_frequency(struct comedi_device *dev)
 {
+	struct das800_private *devpriv = dev->private;
 	int err = 0;
 
 	if (i8254_load(dev->iobase + DAS800_8254, 0, 1, devpriv->divisor1, 2))

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 8e89101ad3a2..215deac0a396 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -609,44 +609,24 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev,
 	int gain, startChan;
 	int i;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_EXT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_FOLLOW;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
-		err++;
-	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit f20dce3848c8335dc80600093ce5c22ddadc2b93
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:38:30 2012 -0700

    staging: comedi: das800: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 834054d7f109..8e89101ad3a2 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -517,7 +517,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 
 	/* analog input subdevice */
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
@@ -531,7 +531,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->cancel = das800_cancel;
 
 	/* di */
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE;
 	s->n_chan = 3;
@@ -540,7 +540,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->insn_bits = das800_di_rbits;
 
 	/* do */
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
 	s->n_chan = 4;

commit 77d2f7c24725e3caa82492dd3d1cbd466b8a0abf
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:38:11 2012 -0700

    staging: comedi: das800: 'dev->subdevices + 0' is already known
    
    There is no need to calculate the subdevice for the call to
    das800_cancel. The variable 's' in this function is set to the
    'dev->read_subdev' which is the same as 'dev->subdevices + 0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index a0959a5e8747..834054d7f109 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -435,7 +435,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	if (fifo_overflow) {
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		comedi_error(dev, "DAS800 FIFO overflow");
-		das800_cancel(dev, dev->subdevices + 0);
+		das800_cancel(dev, s);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		comedi_event(dev, s);
 		async->events = 0;

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 917b31812b6c..a0959a5e8747 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -875,7 +875,7 @@ static int das800_di_rbits(struct comedi_device *dev,
 	data[1] = bits;
 	data[0] = 0;
 
-	return 2;
+	return insn->n;
 }
 
 static int das800_do_wbits(struct comedi_device *dev,
@@ -899,7 +899,7 @@ static int das800_do_wbits(struct comedi_device *dev,
 
 	data[1] = wbits;
 
-	return 2;
+	return insn->n;
 }
 
 /* loads counters with divisor1, divisor2 from private structure */

commit f41ad6675f2d5705a0fc1e210af8eb4a27dbacb4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jun 18 14:05:34 2012 +0100

    staging: comedi: change device used in dev_...() calls
    
    A previous set of patches by Ravishankar Karkala Mallikarjunayya
    replaced a load of printk() calls with dev_info(), dev_err(), etc.
    Unfortunately, these used the 'struct device *hw_dev' member of 'struct
    comedi_device') as the first parameter of these dev_...() calls, but
    that pointer is usually NULL, so the kernel log messages come out a bit
    wrong (they contain the phrase "(NULL device *)").
    
    Use the 'struct device *class_dev' member of 'struct comedi_device'
    instead for these dev_...() calls.  It will be non-NULL and somewhat
    meaningful to users.  It's also consistent with those comedi drivers
    that already use the class_dev member in their dev_...() calls.
    
    Some of the messages included the format "comedi%d" with the minor
    device number used for the "%d".  This is now redundant as it will be
    the same as the dev_name() part of the kernel log message produced by
    the dev_...() calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 81698b1fd0da..917b31812b6c 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -296,46 +296,47 @@ static int das800_probe(struct comedi_device *dev)
 	switch (id_bits) {
 	case 0x0:
 		if (board == das800) {
-			dev_dbg(dev->hw_dev, "Board model: DAS-800\n");
+			dev_dbg(dev->class_dev, "Board model: DAS-800\n");
 			return board;
 		}
 		if (board == ciodas800) {
-			dev_dbg(dev->hw_dev, "Board model: CIO-DAS800\n");
+			dev_dbg(dev->class_dev, "Board model: CIO-DAS800\n");
 			return board;
 		}
-		dev_dbg(dev->hw_dev, "Board model (probed): DAS-800\n");
+		dev_dbg(dev->class_dev, "Board model (probed): DAS-800\n");
 		return das800;
 		break;
 	case 0x2:
 		if (board == das801) {
-			dev_dbg(dev->hw_dev, "Board model: DAS-801\n");
+			dev_dbg(dev->class_dev, "Board model: DAS-801\n");
 			return board;
 		}
 		if (board == ciodas801) {
-			dev_dbg(dev->hw_dev, "Board model: CIO-DAS801\n");
+			dev_dbg(dev->class_dev, "Board model: CIO-DAS801\n");
 			return board;
 		}
-		dev_dbg(dev->hw_dev, "Board model (probed): DAS-801\n");
+		dev_dbg(dev->class_dev, "Board model (probed): DAS-801\n");
 		return das801;
 		break;
 	case 0x3:
 		if (board == das802) {
-			dev_dbg(dev->hw_dev, "Board model: DAS-802\n");
+			dev_dbg(dev->class_dev, "Board model: DAS-802\n");
 			return board;
 		}
 		if (board == ciodas802) {
-			dev_dbg(dev->hw_dev, "Board model: CIO-DAS802\n");
+			dev_dbg(dev->class_dev, "Board model: CIO-DAS802\n");
 			return board;
 		}
 		if (board == ciodas80216) {
-			dev_dbg(dev->hw_dev, "Board model: CIO-DAS802/16\n");
+			dev_dbg(dev->class_dev, "Board model: CIO-DAS802/16\n");
 			return board;
 		}
-		dev_dbg(dev->hw_dev, "Board model (probed): DAS-802\n");
+		dev_dbg(dev->class_dev, "Board model (probed): DAS-802\n");
 		return das802;
 		break;
 	default:
-		dev_dbg(dev->hw_dev, "Board model: probe returned 0x%x (unknown)\n",
+		dev_dbg(dev->class_dev,
+			"Board model: probe returned 0x%x (unknown)\n",
 			id_bits);
 		return board;
 		break;
@@ -467,42 +468,42 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int board;
 	int ret;
 
-	dev_info(dev->hw_dev, "comedi%d: das800: io 0x%lx\n", dev->minor,
-		 iobase);
+	dev_info(dev->class_dev, "das800: io 0x%lx\n", iobase);
 	if (irq)
-		dev_dbg(dev->hw_dev, "irq %u\n", irq);
+		dev_dbg(dev->class_dev, "irq %u\n", irq);
 
 	/* allocate and initialize dev->private */
 	if (alloc_private(dev, sizeof(struct das800_private)) < 0)
 		return -ENOMEM;
 
 	if (iobase == 0) {
-		dev_err(dev->hw_dev, "io base address required for das800\n");
+		dev_err(dev->class_dev,
+			"io base address required for das800\n");
 		return -EINVAL;
 	}
 
 	/* check if io addresses are available */
 	if (!request_region(iobase, DAS800_SIZE, "das800")) {
-		dev_err(dev->hw_dev, "I/O port conflict\n");
+		dev_err(dev->class_dev, "I/O port conflict\n");
 		return -EIO;
 	}
 	dev->iobase = iobase;
 
 	board = das800_probe(dev);
 	if (board < 0) {
-		dev_dbg(dev->hw_dev, "unable to determine board type\n");
+		dev_dbg(dev->class_dev, "unable to determine board type\n");
 		return -ENODEV;
 	}
 	dev->board_ptr = das800_boards + board;
 
 	/* grab our IRQ */
 	if (irq == 1 || irq > 7) {
-		dev_err(dev->hw_dev, "irq out of range\n");
+		dev_err(dev->class_dev, "irq out of range\n");
 		return -EINVAL;
 	}
 	if (irq) {
 		if (request_irq(irq, das800_interrupt, 0, "das800", dev)) {
-			dev_err(dev->hw_dev, "unable to allocate irq %u\n",
+			dev_err(dev->class_dev, "unable to allocate irq %u\n",
 				irq);
 			return -EINVAL;
 		}

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 6263f532e5da..81698b1fd0da 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -465,6 +465,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned int irq = it->options[1];
 	unsigned long irq_flags;
 	int board;
+	int ret;
 
 	dev_info(dev->hw_dev, "comedi%d: das800: io 0x%lx\n", dev->minor,
 		 iobase);
@@ -510,8 +511,9 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	dev->board_name = thisboard->name;
 
-	if (comedi_alloc_subdevices(dev, 3) < 0)
-		return -ENOMEM;
+	ret = comedi_alloc_subdevices(dev, 3);
+	if (ret)
+		return ret;
 
 	/* analog input subdevice */
 	s = dev->subdevices + 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 4e33b2a28d97..6263f532e5da 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -510,7 +510,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	dev->board_name = thisboard->name;
 
-	if (alloc_subdevices(dev, 3) < 0)
+	if (comedi_alloc_subdevices(dev, 3) < 0)
 		return -ENOMEM;
 
 	/* analog input subdevice */

commit bc04bec0e0c982dfc90e206ea51f19bd650ccee2
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Sun May 27 01:45:19 2012 +0900

    staging: comedi: Fix typo in comedi
    
    Correct spelling typo in comments within staging/comedi.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index a3a54e1c5c98..4e33b2a28d97 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -450,7 +450,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 		/* otherwise, stop taking data */
 	} else {
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-		disable_das800(dev);	/* diable hardware triggered conversions */
+		disable_das800(dev);	/* disable hardware triggered conversions */
 		async->events |= COMEDI_CB_EOA;
 	}
 	comedi_event(dev, s);

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 6e347b40fe61..a3a54e1c5c98 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -245,7 +245,7 @@ struct das800_private {
 
 static int das800_attach(struct comedi_device *dev,
 			 struct comedi_devconfig *it);
-static int das800_detach(struct comedi_device *dev);
+static void das800_detach(struct comedi_device *dev);
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static struct comedi_driver driver_das800 = {
@@ -556,16 +556,12 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 0;
 };
 
-static int das800_detach(struct comedi_device *dev)
+static void das800_detach(struct comedi_device *dev)
 {
-	dev_info(dev->hw_dev, "comedi%d: das800: remove\n", dev->minor);
-
-	/* only free stuff if it has been allocated by _attach */
 	if (dev->iobase)
 		release_region(dev->iobase, DAS800_SIZE);
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	return 0;
 };
 
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)

commit e75aca92867eb687f6a2e0663db124f3fe3b4f1c
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Sat Nov 19 10:06:48 2011 +0530

    Staging: comedi: fix printk issue in das800.c
    
    This is a patch to the das800.c file that fixes up a printk
    warning found by the checkpatch.pl tool.
    
    converted printks to dev_dbg.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index ade55f1d864b..6e347b40fe61 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -296,47 +296,47 @@ static int das800_probe(struct comedi_device *dev)
 	switch (id_bits) {
 	case 0x0:
 		if (board == das800) {
-			printk(" Board model: DAS-800\n");
+			dev_dbg(dev->hw_dev, "Board model: DAS-800\n");
 			return board;
 		}
 		if (board == ciodas800) {
-			printk(" Board model: CIO-DAS800\n");
+			dev_dbg(dev->hw_dev, "Board model: CIO-DAS800\n");
 			return board;
 		}
-		printk(" Board model (probed): DAS-800\n");
+		dev_dbg(dev->hw_dev, "Board model (probed): DAS-800\n");
 		return das800;
 		break;
 	case 0x2:
 		if (board == das801) {
-			printk(" Board model: DAS-801\n");
+			dev_dbg(dev->hw_dev, "Board model: DAS-801\n");
 			return board;
 		}
 		if (board == ciodas801) {
-			printk(" Board model: CIO-DAS801\n");
+			dev_dbg(dev->hw_dev, "Board model: CIO-DAS801\n");
 			return board;
 		}
-		printk(" Board model (probed): DAS-801\n");
+		dev_dbg(dev->hw_dev, "Board model (probed): DAS-801\n");
 		return das801;
 		break;
 	case 0x3:
 		if (board == das802) {
-			printk(" Board model: DAS-802\n");
+			dev_dbg(dev->hw_dev, "Board model: DAS-802\n");
 			return board;
 		}
 		if (board == ciodas802) {
-			printk(" Board model: CIO-DAS802\n");
+			dev_dbg(dev->hw_dev, "Board model: CIO-DAS802\n");
 			return board;
 		}
 		if (board == ciodas80216) {
-			printk(" Board model: CIO-DAS802/16\n");
+			dev_dbg(dev->hw_dev, "Board model: CIO-DAS802/16\n");
 			return board;
 		}
-		printk(" Board model (probed): DAS-802\n");
+		dev_dbg(dev->hw_dev, "Board model (probed): DAS-802\n");
 		return das802;
 		break;
 	default:
-		printk(" Board model: probe returned 0x%x (unknown)\n",
-		       id_bits);
+		dev_dbg(dev->hw_dev, "Board model: probe returned 0x%x (unknown)\n",
+			id_bits);
 		return board;
 		break;
 	}

commit bb1defe4653567f7754af741e20a79796a81beaa
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Sat Nov 19 10:06:47 2011 +0530

    Staging: comedi: fix printk issue in das800.c
    
    This is a patch to the das800.c file that fixes up a printk
    warning found by the checkpatch.pl tool.
    
    converted printks to dev_version.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 96d41ad76956..ade55f1d864b 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -466,42 +466,43 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned long irq_flags;
 	int board;
 
-	printk("comedi%d: das800: io 0x%lx", dev->minor, iobase);
+	dev_info(dev->hw_dev, "comedi%d: das800: io 0x%lx\n", dev->minor,
+		 iobase);
 	if (irq)
-		printk(", irq %u", irq);
-	printk("\n");
+		dev_dbg(dev->hw_dev, "irq %u\n", irq);
 
 	/* allocate and initialize dev->private */
 	if (alloc_private(dev, sizeof(struct das800_private)) < 0)
 		return -ENOMEM;
 
 	if (iobase == 0) {
-		printk("io base address required for das800\n");
+		dev_err(dev->hw_dev, "io base address required for das800\n");
 		return -EINVAL;
 	}
 
 	/* check if io addresses are available */
 	if (!request_region(iobase, DAS800_SIZE, "das800")) {
-		printk("I/O port conflict\n");
+		dev_err(dev->hw_dev, "I/O port conflict\n");
 		return -EIO;
 	}
 	dev->iobase = iobase;
 
 	board = das800_probe(dev);
 	if (board < 0) {
-		printk("unable to determine board type\n");
+		dev_dbg(dev->hw_dev, "unable to determine board type\n");
 		return -ENODEV;
 	}
 	dev->board_ptr = das800_boards + board;
 
 	/* grab our IRQ */
 	if (irq == 1 || irq > 7) {
-		printk("irq out of range\n");
+		dev_err(dev->hw_dev, "irq out of range\n");
 		return -EINVAL;
 	}
 	if (irq) {
 		if (request_irq(irq, das800_interrupt, 0, "das800", dev)) {
-			printk("unable to allocate irq %u\n", irq);
+			dev_err(dev->hw_dev, "unable to allocate irq %u\n",
+				irq);
 			return -EINVAL;
 		}
 	}
@@ -557,7 +558,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static int das800_detach(struct comedi_device *dev)
 {
-	printk("comedi%d: das800: remove\n", dev->minor);
+	dev_info(dev->hw_dev, "comedi%d: das800: remove\n", dev->minor);
 
 	/* only free stuff if it has been allocated by _attach */
 	if (dev->iobase)

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index aecaedc5027e..96d41ad76956 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -391,7 +391,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be STATUS2 register */
 	status = inb(dev->iobase + DAS800_STATUS2) & STATUS2_HCEN;
-	/* don't release spinlock yet since we want to make sure noone else disables hardware conversions */
+	/* don't release spinlock yet since we want to make sure no one else disables hardware conversions */
 	if (status == 0) {
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		return IRQ_HANDLED;

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index b4083af4a66a..aecaedc5027e 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -347,7 +347,18 @@ static int das800_probe(struct comedi_device *dev)
  * A convenient macro that defines init_module() and cleanup_module(),
  * as necessary.
  */
-COMEDI_INITCLEANUP(driver_das800);
+static int __init driver_das800_init_module(void)
+{
+	return comedi_driver_register(&driver_das800);
+}
+
+static void __exit driver_das800_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_das800);
+}
+
+module_init(driver_das800_init_module);
+module_exit(driver_das800_cleanup_module);
 
 /* interrupt service routine */
 static irqreturn_t das800_interrupt(int irq, void *d)

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index aadc4971c909..b4083af4a66a 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -905,3 +905,7 @@ static int das800_set_frequency(struct comedi_device *dev)
 
 	return 0;
 }
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 882e5b32b5d68960f46331215fc3c301df508110
Author: Andrea Gelmini <andrea.gelmini@gelma.net>
Date:   Fri Feb 26 10:15:08 2010 +0100

    Staging: comedi: cb_pcimdas.c: more Checkpatch cleanup
    
    WARNING: braces {} are not necessary for single statement blocks
    +               if (fifo_empty) {
    +                       break;
    +               }
    
    WARNING: braces {} are not necessary for single statement blocks
    +       if (irq) {
    +               printk(", irq %u", irq);
    +       }
    
    Signed-off-by: Andrea Gelmini <andrea.gelmini@gelma.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index ecb97cdbce26..aadc4971c909 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -399,9 +399,8 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 		} else {
 			fifo_empty = 0;	/*  cio-das802/16 has no fifo empty status bit */
 		}
-		if (fifo_empty) {
+		if (fifo_empty)
 			break;
-		}
 		/* strip off extraneous bits for 12 bit cards */
 		if (thisboard->resolution == 12)
 			dataPoint = (dataPoint >> 4) & 0xfff;
@@ -457,9 +456,8 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int board;
 
 	printk("comedi%d: das800: io 0x%lx", dev->minor, iobase);
-	if (irq) {
+	if (irq)
 		printk(", irq %u", irq);
-	}
 	printk("\n");
 
 	/* allocate and initialize dev->private */

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 70e9d699c7a3..ecb97cdbce26 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -118,114 +118,114 @@ struct das800_board {
 static const struct comedi_lrange range_das800_ai = {
 	1,
 	{
-			RANGE(-5, 5),
-		}
+	 RANGE(-5, 5),
+	 }
 };
 
 static const struct comedi_lrange range_das801_ai = {
 	9,
 	{
-			RANGE(-5, 5),
-			RANGE(-10, 10),
-			RANGE(0, 10),
-			RANGE(-0.5, 0.5),
-			RANGE(0, 1),
-			RANGE(-0.05, 0.05),
-			RANGE(0, 0.1),
-			RANGE(-0.01, 0.01),
-			RANGE(0, 0.02),
-		}
+	 RANGE(-5, 5),
+	 RANGE(-10, 10),
+	 RANGE(0, 10),
+	 RANGE(-0.5, 0.5),
+	 RANGE(0, 1),
+	 RANGE(-0.05, 0.05),
+	 RANGE(0, 0.1),
+	 RANGE(-0.01, 0.01),
+	 RANGE(0, 0.02),
+	 }
 };
 
 static const struct comedi_lrange range_cio_das801_ai = {
 	9,
 	{
-			RANGE(-5, 5),
-			RANGE(-10, 10),
-			RANGE(0, 10),
-			RANGE(-0.5, 0.5),
-			RANGE(0, 1),
-			RANGE(-0.05, 0.05),
-			RANGE(0, 0.1),
-			RANGE(-0.005, 0.005),
-			RANGE(0, 0.01),
-		}
+	 RANGE(-5, 5),
+	 RANGE(-10, 10),
+	 RANGE(0, 10),
+	 RANGE(-0.5, 0.5),
+	 RANGE(0, 1),
+	 RANGE(-0.05, 0.05),
+	 RANGE(0, 0.1),
+	 RANGE(-0.005, 0.005),
+	 RANGE(0, 0.01),
+	 }
 };
 
 static const struct comedi_lrange range_das802_ai = {
 	9,
 	{
-			RANGE(-5, 5),
-			RANGE(-10, 10),
-			RANGE(0, 10),
-			RANGE(-2.5, 2.5),
-			RANGE(0, 5),
-			RANGE(-1.25, 1.25),
-			RANGE(0, 2.5),
-			RANGE(-0.625, 0.625),
-			RANGE(0, 1.25),
-		}
+	 RANGE(-5, 5),
+	 RANGE(-10, 10),
+	 RANGE(0, 10),
+	 RANGE(-2.5, 2.5),
+	 RANGE(0, 5),
+	 RANGE(-1.25, 1.25),
+	 RANGE(0, 2.5),
+	 RANGE(-0.625, 0.625),
+	 RANGE(0, 1.25),
+	 }
 };
 
 static const struct comedi_lrange range_das80216_ai = {
 	8,
 	{
-			RANGE(-10, 10),
-			RANGE(0, 10),
-			RANGE(-5, 5),
-			RANGE(0, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(0, 2.5),
-			RANGE(-1.25, 1.25),
-			RANGE(0, 1.25),
-		}
+	 RANGE(-10, 10),
+	 RANGE(0, 10),
+	 RANGE(-5, 5),
+	 RANGE(0, 5),
+	 RANGE(-2.5, 2.5),
+	 RANGE(0, 2.5),
+	 RANGE(-1.25, 1.25),
+	 RANGE(0, 1.25),
+	 }
 };
 
 enum { das800, ciodas800, das801, ciodas801, das802, ciodas802, ciodas80216 };
 
 static const struct das800_board das800_boards[] = {
 	{
-	.name = "das-800",
-	.ai_speed = 25000,
-	.ai_range = &range_das800_ai,
-	.resolution = 12,
-		},
+	 .name = "das-800",
+	 .ai_speed = 25000,
+	 .ai_range = &range_das800_ai,
+	 .resolution = 12,
+	 },
 	{
-	.name = "cio-das800",
-	.ai_speed = 20000,
-	.ai_range = &range_das800_ai,
-	.resolution = 12,
-		},
+	 .name = "cio-das800",
+	 .ai_speed = 20000,
+	 .ai_range = &range_das800_ai,
+	 .resolution = 12,
+	 },
 	{
-	.name = "das-801",
-	.ai_speed = 25000,
-	.ai_range = &range_das801_ai,
-	.resolution = 12,
-		},
+	 .name = "das-801",
+	 .ai_speed = 25000,
+	 .ai_range = &range_das801_ai,
+	 .resolution = 12,
+	 },
 	{
-	.name = "cio-das801",
-	.ai_speed = 20000,
-	.ai_range = &range_cio_das801_ai,
-	.resolution = 12,
-		},
+	 .name = "cio-das801",
+	 .ai_speed = 20000,
+	 .ai_range = &range_cio_das801_ai,
+	 .resolution = 12,
+	 },
 	{
-	.name = "das-802",
-	.ai_speed = 25000,
-	.ai_range = &range_das802_ai,
-	.resolution = 12,
-		},
+	 .name = "das-802",
+	 .ai_speed = 25000,
+	 .ai_range = &range_das802_ai,
+	 .resolution = 12,
+	 },
 	{
-	.name = "cio-das802",
-	.ai_speed = 20000,
-	.ai_range = &range_das802_ai,
-	.resolution = 12,
-		},
+	 .name = "cio-das802",
+	 .ai_speed = 20000,
+	 .ai_range = &range_das802_ai,
+	 .resolution = 12,
+	 },
 	{
-	.name = "cio-das802/16",
-	.ai_speed = 10000,
-	.ai_range = &range_das80216_ai,
-	.resolution = 16,
-		},
+	 .name = "cio-das802/16",
+	 .ai_speed = 10000,
+	 .ai_range = &range_das80216_ai,
+	 .resolution = 16,
+	 },
 };
 
 /*
@@ -243,7 +243,8 @@ struct das800_private {
 
 #define devpriv ((struct das800_private *)dev->private)
 
-static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int das800_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int das800_detach(struct comedi_device *dev);
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
@@ -260,15 +261,20 @@ static struct comedi_driver driver_das800 = {
 static irqreturn_t das800_interrupt(int irq, void *d);
 static void enable_das800(struct comedi_device *dev);
 static void disable_das800(struct comedi_device *dev);
-static int das800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int das800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int das800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int das800_ai_do_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd);
+static int das800_ai_do_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static int das800_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int das800_di_rbits(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int das800_do_wbits(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
 static int das800_probe(struct comedi_device *dev);
 static int das800_set_frequency(struct comedi_device *dev);
 
@@ -330,7 +336,7 @@ static int das800_probe(struct comedi_device *dev)
 		break;
 	default:
 		printk(" Board model: probe returned 0x%x (unknown)\n",
-			id_bits);
+		       id_bits);
 		return board;
 		break;
 	}
@@ -429,7 +435,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 		 * We already have spinlock, so indirect addressing is safe */
 		outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
 		outb(CONTROL1_INTE | devpriv->do_bits,
-			dev->iobase + DAS800_CONTROL1);
+		     dev->iobase + DAS800_CONTROL1);
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		/* otherwise, stop taking data */
 	} else {
@@ -585,8 +591,9 @@ static void disable_das800(struct comedi_device *dev)
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
-static int das800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int das800_ai_do_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -676,8 +683,9 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 		tmp = cmd->convert_arg;
 		/* calculate counter values that give desired timing */
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-			&(devpriv->divisor2), &(cmd->convert_arg),
-			cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor2),
+					       &(cmd->convert_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -691,14 +699,14 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 		startChan = CR_CHAN(cmd->chanlist[0]);
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) !=
-				(startChan + i) % N_CHAN_AI) {
+			    (startChan + i) % N_CHAN_AI) {
 				comedi_error(dev,
-					"entries in chanlist must be consecutive channels, counting upwards\n");
+					     "entries in chanlist must be consecutive channels, counting upwards\n");
 				err++;
 			}
 			if (CR_RANGE(cmd->chanlist[i]) != gain) {
 				comedi_error(dev,
-					"entries in chanlist must all have the same gain\n");
+					     "entries in chanlist must all have the same gain\n");
 				err++;
 			}
 		}
@@ -710,7 +718,8 @@ static int das800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 	return 0;
 }
 
-static int das800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int das800_ai_do_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	int startChan, endChan, scan, gain;
 	int conv_bits;
@@ -719,7 +728,7 @@ static int das800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *
 
 	if (!dev->irq) {
 		comedi_error(dev,
-			"no irq assigned for das-800, cannot do hardware conversions");
+			     "no irq assigned for das-800, cannot do hardware conversions");
 		return -1;
 	}
 
@@ -767,8 +776,10 @@ static int das800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *
 		conv_bits |= CASC | ITE;
 		/* set conversion frequency */
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-			&(devpriv->divisor2), &(async->cmd.convert_arg),
-			async->cmd.flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor2),
+					       &(async->cmd.convert_arg),
+					       async->cmd.
+					       flags & TRIG_ROUND_MASK);
 		if (das800_set_frequency(dev) < 0) {
 			comedi_error(dev, "Error setting up counters");
 			return -1;
@@ -789,8 +800,9 @@ static int das800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *
 	return 0;
 }
 
-static int das800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das800_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int i, n;
 	int chan;
@@ -843,8 +855,9 @@ static int das800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s
 	return n;
 }
 
-static int das800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das800_di_rbits(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	unsigned int bits;
 
@@ -856,8 +869,9 @@ static int das800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s
 	return 2;
 }
 
-static int das800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das800_do_wbits(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int wbits;
 	unsigned long irq_flags;

commit 25436dc9d84f1be60ff549c9ab712bba2835f284
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:14:34 2009 -0700

    Staging: comedi: remove RT code
    
    This removes the unused RT code from the comedi subsystem.
    
    A lot of drivers needed to then include interrupt.h on their own, as they
    were picking it up through the comedi_rt.h inclusion.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index ef64a20d836b..70e9d699c7a3 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -62,6 +62,7 @@ cmd triggers supported:
 
 */
 
+#include <linux/interrupt.h>
 #include "../comedidev.h"
 
 #include <linux/ioport.h>

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 6ee9648e5e18..ef64a20d836b 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -279,10 +279,10 @@ static int das800_probe(struct comedi_device *dev)
 	int board;
 
 	/*  'comedi spin lock irqsave' disables even rt interrupts, we use them to protect indirect addressing */
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(ID, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be ID register */
 	id_bits = inb(dev->iobase + DAS800_ID) & 0x3;	/* get id bits */
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	board = thisboard - das800_boards;
 
@@ -370,12 +370,12 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	async = s->async;
 
 	/*  if hardware conversions are not enabled, then quit */
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be STATUS2 register */
 	status = inb(dev->iobase + DAS800_STATUS2) & STATUS2_HCEN;
 	/* don't release spinlock yet since we want to make sure noone else disables hardware conversions */
 	if (status == 0) {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		return IRQ_HANDLED;
 	}
 
@@ -415,7 +415,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 		fifo_overflow = inb(dev->iobase + DAS800_GAIN) & CIO_FFOV;
 	}
 	if (fifo_overflow) {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		comedi_error(dev, "DAS800 FIFO overflow");
 		das800_cancel(dev, dev->subdevices + 0);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
@@ -429,10 +429,10 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 		outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
 		outb(CONTROL1_INTE | devpriv->do_bits,
 			dev->iobase + DAS800_CONTROL1);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		/* otherwise, stop taking data */
 	} else {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		disable_das800(dev);	/* diable hardware triggered conversions */
 		async->events |= COMEDI_CB_EOA;
 	}
@@ -484,7 +484,7 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EINVAL;
 	}
 	if (irq) {
-		if (comedi_request_irq(irq, das800_interrupt, 0, "das800", dev)) {
+		if (request_irq(irq, das800_interrupt, 0, "das800", dev)) {
 			printk("unable to allocate irq %u\n", irq);
 			return -EINVAL;
 		}
@@ -531,10 +531,10 @@ static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	disable_das800(dev);
 
 	/* initialize digital out channels */
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
 	outb(CONTROL1_INTE | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	return 0;
 };
@@ -547,7 +547,7 @@ static int das800_detach(struct comedi_device *dev)
 	if (dev->iobase)
 		release_region(dev->iobase, DAS800_SIZE);
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	return 0;
 };
 
@@ -563,7 +563,7 @@ static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static void enable_das800(struct comedi_device *dev)
 {
 	unsigned long irq_flags;
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	/*  enable fifo-half full interrupts for cio-das802/16 */
 	if (thisboard->resolution == 16)
 		outb(CIO_ENHF, dev->iobase + DAS800_GAIN);
@@ -571,17 +571,17 @@ static void enable_das800(struct comedi_device *dev)
 	outb(CONV_HCEN, dev->iobase + DAS800_CONV_CONTROL);	/* enable hardware triggering */
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
 	outb(CONTROL1_INTE | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);	/* enable card's interrupt */
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
 /* disable_das800 stops hardware triggered conversions */
 static void disable_das800(struct comedi_device *dev)
 {
 	unsigned long irq_flags;
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONV_CONTROL, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be conversion control register */
 	outb(0x0, dev->iobase + DAS800_CONV_CONTROL);	/* disable hardware triggering of conversions */
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
 static int das800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -729,10 +729,10 @@ static int das800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *
 	endChan = (startChan + async->cmd.chanlist_len - 1) % 8;
 	scan = (endChan << 3) | startChan;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(SCAN_LIMITS, dev->iobase + DAS800_GAIN);	/* select base address + 2 to be scan limits register */
 	outb(scan, dev->iobase + DAS800_SCAN_LIMITS);	/* set scan limits */
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	/* set gain */
 	gain = CR_RANGE(async->cmd.chanlist[0]);
@@ -779,10 +779,10 @@ static int das800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *
 		break;
 	}
 
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONV_CONTROL, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be conversion control register */
 	outb(conv_bits, dev->iobase + DAS800_CONV_CONTROL);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 	async->events = 0;
 	enable_das800(dev);
 	return 0;
@@ -803,10 +803,10 @@ static int das800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s
 	/* set multiplexer */
 	chan = CR_CHAN(insn->chanspec);
 
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
 	outb(chan | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	/* set gain / range */
 	range = CR_RANGE(insn->chanspec);
@@ -815,7 +815,7 @@ static int das800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s
 	range &= 0xf;
 	outb(range, dev->iobase + DAS800_GAIN);
 
-	comedi_udelay(5);
+	udelay(5);
 
 	for (n = 0; n < insn->n; n++) {
 		/* trigger conversion */
@@ -868,10 +868,10 @@ static int das800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s
 	wbits |= data[0] & data[1];
 	devpriv->do_bits = wbits << 4;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
 	outb(devpriv->do_bits | CONTROL1_INTE, dev->iobase + DAS800_CONTROL1);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	data[1] = wbits;
 

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index db646598619e..6ee9648e5e18 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -251,7 +251,7 @@ static struct comedi_driver driver_das800 = {
 	.module = THIS_MODULE,
 	.attach = das800_attach,
 	.detach = das800_detach,
-	.num_names = sizeof(das800_boards) / sizeof(struct das800_board),
+	.num_names = ARRAY_SIZE(das800_boards),
 	.board_name = &das800_boards[0].name,
 	.offset = sizeof(struct das800_board),
 };

commit 814900c904140cfe7f3e48cabec06b3eec57e0ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:54 2009 -0400

    Staging: comedi: more fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 71aeae3d57a8..db646598619e 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -257,22 +257,22 @@ static struct comedi_driver driver_das800 = {
 };
 
 static irqreturn_t das800_interrupt(int irq, void *d);
-static void enable_das800(struct comedi_device * dev);
-static void disable_das800(struct comedi_device * dev);
-static int das800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int das800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int das800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int das800_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int das800_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int das800_probe(struct comedi_device * dev);
-static int das800_set_frequency(struct comedi_device * dev);
+static void enable_das800(struct comedi_device *dev);
+static void disable_das800(struct comedi_device *dev);
+static int das800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int das800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int das800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int das800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int das800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int das800_probe(struct comedi_device *dev);
+static int das800_set_frequency(struct comedi_device *dev);
 
 /* checks and probes das-800 series board type */
-static int das800_probe(struct comedi_device * dev)
+static int das800_probe(struct comedi_device *dev)
 {
 	int id_bits;
 	unsigned long irq_flags;

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index aa1ae24da84c..71aeae3d57a8 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -184,46 +184,46 @@ enum { das800, ciodas800, das801, ciodas801, das802, ciodas802, ciodas80216 };
 
 static const struct das800_board das800_boards[] = {
 	{
-	      name:	"das-800",
-	      ai_speed:25000,
-	      ai_range:&range_das800_ai,
-	      resolution:12,
+	.name = "das-800",
+	.ai_speed = 25000,
+	.ai_range = &range_das800_ai,
+	.resolution = 12,
 		},
 	{
-	      name:	"cio-das800",
-	      ai_speed:20000,
-	      ai_range:&range_das800_ai,
-	      resolution:12,
+	.name = "cio-das800",
+	.ai_speed = 20000,
+	.ai_range = &range_das800_ai,
+	.resolution = 12,
 		},
 	{
-	      name:	"das-801",
-	      ai_speed:25000,
-	      ai_range:&range_das801_ai,
-	      resolution:12,
+	.name = "das-801",
+	.ai_speed = 25000,
+	.ai_range = &range_das801_ai,
+	.resolution = 12,
 		},
 	{
-	      name:	"cio-das801",
-	      ai_speed:20000,
-	      ai_range:&range_cio_das801_ai,
-	      resolution:12,
+	.name = "cio-das801",
+	.ai_speed = 20000,
+	.ai_range = &range_cio_das801_ai,
+	.resolution = 12,
 		},
 	{
-	      name:	"das-802",
-	      ai_speed:25000,
-	      ai_range:&range_das802_ai,
-	      resolution:12,
+	.name = "das-802",
+	.ai_speed = 25000,
+	.ai_range = &range_das802_ai,
+	.resolution = 12,
 		},
 	{
-	      name:	"cio-das802",
-	      ai_speed:20000,
-	      ai_range:&range_das802_ai,
-	      resolution:12,
+	.name = "cio-das802",
+	.ai_speed = 20000,
+	.ai_range = &range_das802_ai,
+	.resolution = 12,
 		},
 	{
-	      name:	"cio-das802/16",
-	      ai_speed:10000,
-	      ai_range:&range_das80216_ai,
-	      resolution:16,
+	.name = "cio-das802/16",
+	.ai_speed = 10000,
+	.ai_range = &range_das80216_ai,
+	.resolution = 16,
 		},
 };
 
@@ -247,13 +247,13 @@ static int das800_detach(struct comedi_device *dev);
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static struct comedi_driver driver_das800 = {
-      driver_name:"das800",
-      module:THIS_MODULE,
-      attach:das800_attach,
-      detach:das800_detach,
-      num_names:sizeof(das800_boards) / sizeof(struct das800_board),
-      board_name:&das800_boards[0].name,
-      offset:sizeof(struct das800_board),
+	.driver_name = "das800",
+	.module = THIS_MODULE,
+	.attach = das800_attach,
+	.detach = das800_detach,
+	.num_names = sizeof(das800_boards) / sizeof(struct das800_board),
+	.board_name = &das800_boards[0].name,
+	.offset = sizeof(struct das800_board),
 };
 
 static irqreturn_t das800_interrupt(int irq, void *d);

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index eafee0c655aa..aa1ae24da84c 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -242,9 +242,9 @@ struct das800_private {
 
 #define devpriv ((struct das800_private *)dev->private)
 
-static int das800_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int das800_detach(struct comedi_device * dev);
-static int das800_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int das800_detach(struct comedi_device *dev);
+static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static struct comedi_driver driver_das800 = {
       driver_name:"das800",
@@ -441,7 +441,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static int das800_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
@@ -539,7 +539,7 @@ static int das800_attach(struct comedi_device * dev, struct comedi_devconfig * i
 	return 0;
 };
 
-static int das800_detach(struct comedi_device * dev)
+static int das800_detach(struct comedi_device *dev)
 {
 	printk("comedi%d: das800: remove\n", dev->minor);
 
@@ -551,7 +551,7 @@ static int das800_detach(struct comedi_device * dev)
 	return 0;
 };
 
-static int das800_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	devpriv->forever = 0;
 	devpriv->count = 0;
@@ -560,7 +560,7 @@ static int das800_cancel(struct comedi_device * dev, struct comedi_subdevice * s
 }
 
 /* enable_das800 makes the card start taking hardware triggered conversions */
-static void enable_das800(struct comedi_device * dev)
+static void enable_das800(struct comedi_device *dev)
 {
 	unsigned long irq_flags;
 	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
@@ -575,7 +575,7 @@ static void enable_das800(struct comedi_device * dev)
 }
 
 /* disable_das800 stops hardware triggered conversions */
-static void disable_das800(struct comedi_device * dev)
+static void disable_das800(struct comedi_device *dev)
 {
 	unsigned long irq_flags;
 	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
@@ -584,8 +584,8 @@ static void disable_das800(struct comedi_device * dev)
 	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
-static int das800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int das800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -709,7 +709,7 @@ static int das800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdev
 	return 0;
 }
 
-static int das800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int das800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int startChan, endChan, scan, gain;
 	int conv_bits;
@@ -788,8 +788,8 @@ static int das800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static int das800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int das800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int chan;
@@ -842,8 +842,8 @@ static int das800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 	return n;
 }
 
-static int das800_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int das800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits;
 
@@ -855,8 +855,8 @@ static int das800_di_rbits(struct comedi_device * dev, struct comedi_subdevice *
 	return 2;
 }
 
-static int das800_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int das800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int wbits;
 	unsigned long irq_flags;
@@ -879,7 +879,7 @@ static int das800_do_wbits(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 /* loads counters with divisor1, divisor2 from private structure */
-static int das800_set_frequency(struct comedi_device * dev)
+static int das800_set_frequency(struct comedi_device *dev)
 {
 	int err = 0;
 

commit 2696fb57e6af653dd8b4df41b16754579f42fc78
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:29:34 2009 -0400

    Staging: comedi: Remove C99 comments
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index ee659fdd1b59..eafee0c655aa 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -72,7 +72,7 @@ cmd triggers supported:
 
 #define DAS800_SIZE           8
 #define TIMER_BASE            1000
-#define N_CHAN_AI             8	// number of analog input channels
+#define N_CHAN_AI             8	/*  number of analog input channels */
 
 /* Registers for the das800 */
 
@@ -94,8 +94,8 @@ cmd triggers supported:
 #define   IRQ                   0x8
 #define   BUSY                  0x80
 #define DAS800_GAIN           3
-#define   CIO_FFOV              0x8	// fifo overflow for cio-das802/16
-#define   CIO_ENHF              0x90	// interrupt fifo half full for cio-das802/16
+#define   CIO_FFOV              0x8	/*  fifo overflow for cio-das802/16 */
+#define   CIO_ENHF              0x90	/*  interrupt fifo half full for cio-das802/16 */
 #define   CONTROL1              0x80
 #define   CONV_CONTROL          0xa0
 #define   SCAN_LIMITS           0xc0
@@ -113,7 +113,7 @@ struct das800_board {
 	int resolution;
 };
 
-//analog input ranges
+/* analog input ranges */
 static const struct comedi_lrange range_das800_ai = {
 	1,
 	{
@@ -278,7 +278,7 @@ static int das800_probe(struct comedi_device * dev)
 	unsigned long irq_flags;
 	int board;
 
-	// 'comedi spin lock irqsave' disables even rt interrupts, we use them to protect indirect addressing
+	/*  'comedi spin lock irqsave' disables even rt interrupts, we use them to protect indirect addressing */
 	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(ID, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be ID register */
 	id_bits = inb(dev->iobase + DAS800_ID) & 0x3;	/* get id bits */
@@ -352,8 +352,8 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	struct comedi_async *async;
 	int status;
 	unsigned long irq_flags;
-	static const int max_loops = 128;	// half-fifo size for cio-das802/16
-	// flags
+	static const int max_loops = 128;	/*  half-fifo size for cio-das802/16 */
+	/*  flags */
 	int fifo_empty = 0;
 	int fifo_overflow = 0;
 
@@ -369,7 +369,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	 */
 	async = s->async;
 
-	// if hardware conversions are not enabled, then quit
+	/*  if hardware conversions are not enabled, then quit */
 	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be STATUS2 register */
 	status = inb(dev->iobase + DAS800_STATUS2) & STATUS2_HCEN;
@@ -390,7 +390,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 			if (fifo_overflow)
 				break;
 		} else {
-			fifo_empty = 0;	// cio-das802/16 has no fifo empty status bit
+			fifo_empty = 0;	/*  cio-das802/16 has no fifo empty status bit */
 		}
 		if (fifo_empty) {
 			break;
@@ -410,7 +410,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	/* check for fifo overflow */
 	if (thisboard->resolution == 12) {
 		fifo_overflow = dataPoint & FIFO_OVF;
-		// else cio-das802/16
+		/*  else cio-das802/16 */
 	} else {
 		fifo_overflow = inb(dev->iobase + DAS800_GAIN) & CIO_FFOV;
 	}
@@ -564,7 +564,7 @@ static void enable_das800(struct comedi_device * dev)
 {
 	unsigned long irq_flags;
 	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
-	// enable fifo-half full interrupts for cio-das802/16
+	/*  enable fifo-half full interrupts for cio-das802/16 */
 	if (thisboard->resolution == 16)
 		outb(CIO_ENHF, dev->iobase + DAS800_GAIN);
 	outb(CONV_CONTROL, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be conversion control register */
@@ -684,7 +684,7 @@ static int das800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdev
 	if (err)
 		return 4;
 
-	// check channel/gain list against card's limitations
+	/*  check channel/gain list against card's limitations */
 	if (cmd->chanlist) {
 		gain = CR_RANGE(cmd->chanlist[0]);
 		startChan = CR_CHAN(cmd->chanlist[0]);
@@ -861,7 +861,7 @@ static int das800_do_wbits(struct comedi_device * dev, struct comedi_subdevice *
 	int wbits;
 	unsigned long irq_flags;
 
-	// only set bits that have been masked
+	/*  only set bits that have been masked */
 	data[0] &= 0xf;
 	wbits = devpriv->do_bits >> 4;
 	wbits &= ~data[0];

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 7a6656bf809c..ee659fdd1b59 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -256,7 +256,7 @@ static struct comedi_driver driver_das800 = {
       offset:sizeof(struct das800_board),
 };
 
-static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG);
+static irqreturn_t das800_interrupt(int irq, void *d);
 static void enable_das800(struct comedi_device * dev);
 static void disable_das800(struct comedi_device * dev);
 static int das800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
@@ -343,7 +343,7 @@ static int das800_probe(struct comedi_device * dev)
 COMEDI_INITCLEANUP(driver_das800);
 
 /* interrupt service routine */
-static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t das800_interrupt(int irq, void *d)
 {
 	short i;		/* loop index */
 	short dataPoint = 0;

commit 938f185d4eea489ad802554e2faef9c99e377aa5
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:13:47 2009 -0400

    Staging: comedi: das800: Remove das800_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 71586cccdaca..7a6656bf809c 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -232,15 +232,15 @@ static const struct das800_board das800_boards[] = {
  */
 #define thisboard ((const struct das800_board *)dev->board_ptr)
 
-typedef struct {
+struct das800_private {
 	volatile unsigned int count;	/* number of data points left to be taken */
 	volatile int forever;	/* flag indicating whether we should take data forever */
 	unsigned int divisor1;	/* value to load into board's counter 1 for timed conversions */
 	unsigned int divisor2;	/* value to load into board's counter 2 for timed conversions */
 	volatile int do_bits;	/* digital output bits */
-} das800_private;
+};
 
-#define devpriv ((das800_private *)dev->private)
+#define devpriv ((struct das800_private *)dev->private)
 
 static int das800_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int das800_detach(struct comedi_device * dev);
@@ -456,7 +456,7 @@ static int das800_attach(struct comedi_device * dev, struct comedi_devconfig * i
 	printk("\n");
 
 	/* allocate and initialize dev->private */
-	if (alloc_private(dev, sizeof(das800_private)) < 0)
+	if (alloc_private(dev, sizeof(struct das800_private)) < 0)
 		return -ENOMEM;
 
 	if (iobase == 0) {

commit febc2ed696fe88e3e438554f94dc0d2901a37c1f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:13:42 2009 -0400

    Staging: comedi: Remove das800_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 85407ef8dfb1..71586cccdaca 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -106,12 +106,12 @@ cmd triggers supported:
 #define   STATUS2_INTE          0X20
 #define DAS800_ID             7
 
-typedef struct das800_board_struct {
+struct das800_board {
 	const char *name;
 	int ai_speed;
 	const struct comedi_lrange *ai_range;
 	int resolution;
-} das800_board;
+};
 
 //analog input ranges
 static const struct comedi_lrange range_das800_ai = {
@@ -182,7 +182,7 @@ static const struct comedi_lrange range_das80216_ai = {
 
 enum { das800, ciodas800, das801, ciodas801, das802, ciodas802, ciodas80216 };
 
-static const das800_board das800_boards[] = {
+static const struct das800_board das800_boards[] = {
 	{
 	      name:	"das-800",
 	      ai_speed:25000,
@@ -230,7 +230,7 @@ static const das800_board das800_boards[] = {
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((const das800_board *)dev->board_ptr)
+#define thisboard ((const struct das800_board *)dev->board_ptr)
 
 typedef struct {
 	volatile unsigned int count;	/* number of data points left to be taken */
@@ -251,9 +251,9 @@ static struct comedi_driver driver_das800 = {
       module:THIS_MODULE,
       attach:das800_attach,
       detach:das800_detach,
-      num_names:sizeof(das800_boards) / sizeof(das800_board),
+      num_names:sizeof(das800_boards) / sizeof(struct das800_board),
       board_name:&das800_boards[0].name,
-      offset:sizeof(das800_board),
+      offset:sizeof(struct das800_board),
 };
 
 static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG);

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 179a694b0745..85407ef8dfb1 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -242,7 +242,7 @@ typedef struct {
 
 #define devpriv ((das800_private *)dev->private)
 
-static int das800_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int das800_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int das800_detach(struct comedi_device * dev);
 static int das800_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 
@@ -441,7 +441,7 @@ static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-static int das800_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int das800_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 6f94a6663eca..179a694b0745 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -263,11 +263,11 @@ static int das800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdev
 	struct comedi_cmd * cmd);
 static int das800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int das800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int das800_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int das800_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int das800_probe(struct comedi_device * dev);
 static int das800_set_frequency(struct comedi_device * dev);
 
@@ -789,7 +789,7 @@ static int das800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int das800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
 	int chan;
@@ -843,7 +843,7 @@ static int das800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 static int das800_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits;
 
@@ -856,7 +856,7 @@ static int das800_di_rbits(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 static int das800_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int wbits;
 	unsigned long irq_flags;

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 6485e33fb520..6f94a6663eca 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -260,7 +260,7 @@ static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG);
 static void enable_das800(struct comedi_device * dev);
 static void disable_das800(struct comedi_device * dev);
 static int das800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int das800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int das800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
@@ -585,7 +585,7 @@ static void disable_das800(struct comedi_device * dev)
 }
 
 static int das800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 83422936021f..6485e33fb520 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -109,19 +109,19 @@ cmd triggers supported:
 typedef struct das800_board_struct {
 	const char *name;
 	int ai_speed;
-	const comedi_lrange *ai_range;
+	const struct comedi_lrange *ai_range;
 	int resolution;
 } das800_board;
 
 //analog input ranges
-static const comedi_lrange range_das800_ai = {
+static const struct comedi_lrange range_das800_ai = {
 	1,
 	{
 			RANGE(-5, 5),
 		}
 };
 
-static const comedi_lrange range_das801_ai = {
+static const struct comedi_lrange range_das801_ai = {
 	9,
 	{
 			RANGE(-5, 5),
@@ -136,7 +136,7 @@ static const comedi_lrange range_das801_ai = {
 		}
 };
 
-static const comedi_lrange range_cio_das801_ai = {
+static const struct comedi_lrange range_cio_das801_ai = {
 	9,
 	{
 			RANGE(-5, 5),
@@ -151,7 +151,7 @@ static const comedi_lrange range_cio_das801_ai = {
 		}
 };
 
-static const comedi_lrange range_das802_ai = {
+static const struct comedi_lrange range_das802_ai = {
 	9,
 	{
 			RANGE(-5, 5),
@@ -166,7 +166,7 @@ static const comedi_lrange range_das802_ai = {
 		}
 };
 
-static const comedi_lrange range_das80216_ai = {
+static const struct comedi_lrange range_das80216_ai = {
 	8,
 	{
 			RANGE(-10, 10),

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 92df82216f3e..83422936021f 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -246,7 +246,7 @@ static int das800_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int das800_detach(struct comedi_device * dev);
 static int das800_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 
-static comedi_driver driver_das800 = {
+static struct comedi_driver driver_das800 = {
       driver_name:"das800",
       module:THIS_MODULE,
       attach:das800_attach,

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 7833e56b0124..92df82216f3e 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -349,7 +349,7 @@ static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG)
 	short dataPoint = 0;
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;	/* analog input subdevice */
-	comedi_async *async;
+	struct comedi_async *async;
 	int status;
 	unsigned long irq_flags;
 	static const int max_loops = 128;	// half-fifo size for cio-das802/16
@@ -714,7 +714,7 @@ static int das800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice
 	int startChan, endChan, scan, gain;
 	int conv_bits;
 	unsigned long irq_flags;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 
 	if (!dev->irq) {
 		comedi_error(dev,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 73068309ae9c..7833e56b0124 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -244,7 +244,7 @@ typedef struct {
 
 static int das800_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int das800_detach(struct comedi_device * dev);
-static int das800_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int das800_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 
 static comedi_driver driver_das800 = {
       driver_name:"das800",
@@ -259,14 +259,14 @@ static comedi_driver driver_das800 = {
 static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG);
 static void enable_das800(struct comedi_device * dev);
 static void disable_das800(struct comedi_device * dev);
-static int das800_ai_do_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int das800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int das800_ai_do_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int das800_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int das800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int das800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das800_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
+static int das800_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das800_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
+static int das800_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static int das800_probe(struct comedi_device * dev);
 static int das800_set_frequency(struct comedi_device * dev);
@@ -348,7 +348,7 @@ static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG)
 	short i;		/* loop index */
 	short dataPoint = 0;
 	struct comedi_device *dev = d;
-	comedi_subdevice *s = dev->read_subdev;	/* analog input subdevice */
+	struct comedi_subdevice *s = dev->read_subdev;	/* analog input subdevice */
 	comedi_async *async;
 	int status;
 	unsigned long irq_flags;
@@ -443,7 +443,7 @@ static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG)
 
 static int das800_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
 	unsigned int irq = it->options[1];
 	unsigned long irq_flags;
@@ -551,7 +551,7 @@ static int das800_detach(struct comedi_device * dev)
 	return 0;
 };
 
-static int das800_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int das800_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	devpriv->forever = 0;
 	devpriv->count = 0;
@@ -584,7 +584,7 @@ static void disable_das800(struct comedi_device * dev)
 	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
-static int das800_ai_do_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int das800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -709,7 +709,7 @@ static int das800_ai_do_cmdtest(struct comedi_device * dev, comedi_subdevice * s
 	return 0;
 }
 
-static int das800_ai_do_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int das800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int startChan, endChan, scan, gain;
 	int conv_bits;
@@ -788,7 +788,7 @@ static int das800_ai_do_cmd(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int das800_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int das800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
@@ -842,7 +842,7 @@ static int das800_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int das800_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
+static int das800_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits;
@@ -855,7 +855,7 @@ static int das800_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int das800_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
+static int das800_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int wbits;

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index 7e658dbfa07a..73068309ae9c 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -242,9 +242,9 @@ typedef struct {
 
 #define devpriv ((das800_private *)dev->private)
 
-static int das800_attach(comedi_device * dev, comedi_devconfig * it);
-static int das800_detach(comedi_device * dev);
-static int das800_cancel(comedi_device * dev, comedi_subdevice * s);
+static int das800_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int das800_detach(struct comedi_device * dev);
+static int das800_cancel(struct comedi_device * dev, comedi_subdevice * s);
 
 static comedi_driver driver_das800 = {
       driver_name:"das800",
@@ -257,22 +257,22 @@ static comedi_driver driver_das800 = {
 };
 
 static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG);
-static void enable_das800(comedi_device * dev);
-static void disable_das800(comedi_device * dev);
-static int das800_ai_do_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static void enable_das800(struct comedi_device * dev);
+static void disable_das800(struct comedi_device * dev);
+static int das800_ai_do_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int das800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s);
-static int das800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int das800_ai_do_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int das800_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das800_di_rbits(comedi_device * dev, comedi_subdevice * s,
+static int das800_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das800_do_wbits(comedi_device * dev, comedi_subdevice * s,
+static int das800_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das800_probe(comedi_device * dev);
-static int das800_set_frequency(comedi_device * dev);
+static int das800_probe(struct comedi_device * dev);
+static int das800_set_frequency(struct comedi_device * dev);
 
 /* checks and probes das-800 series board type */
-static int das800_probe(comedi_device * dev)
+static int das800_probe(struct comedi_device * dev)
 {
 	int id_bits;
 	unsigned long irq_flags;
@@ -347,7 +347,7 @@ static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	short i;		/* loop index */
 	short dataPoint = 0;
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s = dev->read_subdev;	/* analog input subdevice */
 	comedi_async *async;
 	int status;
@@ -441,7 +441,7 @@ static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-static int das800_attach(comedi_device * dev, comedi_devconfig * it)
+static int das800_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
@@ -539,7 +539,7 @@ static int das800_attach(comedi_device * dev, comedi_devconfig * it)
 	return 0;
 };
 
-static int das800_detach(comedi_device * dev)
+static int das800_detach(struct comedi_device * dev)
 {
 	printk("comedi%d: das800: remove\n", dev->minor);
 
@@ -551,7 +551,7 @@ static int das800_detach(comedi_device * dev)
 	return 0;
 };
 
-static int das800_cancel(comedi_device * dev, comedi_subdevice * s)
+static int das800_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	devpriv->forever = 0;
 	devpriv->count = 0;
@@ -560,7 +560,7 @@ static int das800_cancel(comedi_device * dev, comedi_subdevice * s)
 }
 
 /* enable_das800 makes the card start taking hardware triggered conversions */
-static void enable_das800(comedi_device * dev)
+static void enable_das800(struct comedi_device * dev)
 {
 	unsigned long irq_flags;
 	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
@@ -575,7 +575,7 @@ static void enable_das800(comedi_device * dev)
 }
 
 /* disable_das800 stops hardware triggered conversions */
-static void disable_das800(comedi_device * dev)
+static void disable_das800(struct comedi_device * dev)
 {
 	unsigned long irq_flags;
 	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
@@ -584,7 +584,7 @@ static void disable_das800(comedi_device * dev)
 	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
-static int das800_ai_do_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int das800_ai_do_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -709,7 +709,7 @@ static int das800_ai_do_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int das800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s)
+static int das800_ai_do_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	int startChan, endChan, scan, gain;
 	int conv_bits;
@@ -788,7 +788,7 @@ static int das800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int das800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int das800_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
@@ -842,7 +842,7 @@ static int das800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int das800_di_rbits(comedi_device * dev, comedi_subdevice * s,
+static int das800_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits;
@@ -855,7 +855,7 @@ static int das800_di_rbits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int das800_do_wbits(comedi_device * dev, comedi_subdevice * s,
+static int das800_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int wbits;
@@ -879,7 +879,7 @@ static int das800_do_wbits(comedi_device * dev, comedi_subdevice * s,
 }
 
 /* loads counters with divisor1, divisor2 from private structure */
-static int das800_set_frequency(comedi_device * dev)
+static int das800_set_frequency(struct comedi_device * dev)
 {
 	int err = 0;
 

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index d0ec47e6b70e..7e658dbfa07a 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -263,11 +263,11 @@ static int das800_ai_do_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
 static int das800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s);
 static int das800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int das800_di_rbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int das800_do_wbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int das800_probe(comedi_device * dev);
 static int das800_set_frequency(comedi_device * dev);
 
@@ -346,7 +346,7 @@ COMEDI_INITCLEANUP(driver_das800);
 static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	short i;		/* loop index */
-	sampl_t dataPoint = 0;
+	short dataPoint = 0;
 	comedi_device *dev = d;
 	comedi_subdevice *s = dev->read_subdev;	/* analog input subdevice */
 	comedi_async *async;
@@ -789,7 +789,7 @@ static int das800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s)
 }
 
 static int das800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
 	int chan;
@@ -843,9 +843,9 @@ static int das800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int das800_di_rbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
-	lsampl_t bits;
+	unsigned int bits;
 
 	bits = inb(dev->iobase + DAS800_STATUS) >> 4;
 	bits &= 0x7;
@@ -856,7 +856,7 @@ static int das800_di_rbits(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int das800_do_wbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int wbits;
 	unsigned long irq_flags;

commit 3726e56b17762b3f13410b9c41029a13fef8c67f
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Thu Feb 19 09:57:07 2009 -0800

    Staging: comedi: add das800 driver
    
    Driver for Keitley das800 series boards and compatibles
    
    From: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
new file mode 100644
index 000000000000..d0ec47e6b70e
--- /dev/null
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -0,0 +1,894 @@
+/*
+    comedi/drivers/das800.c
+    Driver for Keitley das800 series boards and compatibles
+    Copyright (C) 2000 Frank Mori Hess <fmhess@users.sourceforge.net>
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+************************************************************************
+*/
+/*
+Driver: das800
+Description: Keithley Metrabyte DAS800 (& compatibles)
+Author: Frank Mori Hess <fmhess@users.sourceforge.net>
+Devices: [Keithley Metrabyte] DAS-800 (das-800), DAS-801 (das-801),
+  DAS-802 (das-802),
+  [Measurement Computing] CIO-DAS800 (cio-das800),
+  CIO-DAS801 (cio-das801), CIO-DAS802 (cio-das802),
+  CIO-DAS802/16 (cio-das802/16)
+Status: works, cio-das802/16 untested - email me if you have tested it
+
+Configuration options:
+  [0] - I/O port base address
+  [1] - IRQ (optional, required for timed or externally triggered conversions)
+
+Notes:
+	IRQ can be omitted, although the cmd interface will not work without it.
+
+	All entries in the channel/gain list must use the same gain and be
+	consecutive channels counting upwards in channel number (these are
+	hardware limitations.)
+
+	I've never tested the gain setting stuff since I only have a
+	DAS-800 board with fixed gain.
+
+	The cio-das802/16 does not have a fifo-empty status bit!  Therefore
+	only fifo-half-full transfers are possible with this card.
+*/
+/*
+
+cmd triggers supported:
+	start_src:      TRIG_NOW | TRIG_EXT
+	scan_begin_src: TRIG_FOLLOW
+	scan_end_src:   TRIG_COUNT
+	convert_src:    TRIG_TIMER | TRIG_EXT
+	stop_src:       TRIG_NONE | TRIG_COUNT
+
+
+*/
+
+#include "../comedidev.h"
+
+#include <linux/ioport.h>
+#include <linux/delay.h>
+
+#include "8253.h"
+#include "comedi_fc.h"
+
+#define DAS800_SIZE           8
+#define TIMER_BASE            1000
+#define N_CHAN_AI             8	// number of analog input channels
+
+/* Registers for the das800 */
+
+#define DAS800_LSB            0
+#define   FIFO_EMPTY            0x1
+#define   FIFO_OVF              0x2
+#define DAS800_MSB            1
+#define DAS800_CONTROL1       2
+#define   CONTROL1_INTE         0x8
+#define DAS800_CONV_CONTROL   2
+#define   ITE                   0x1
+#define   CASC                  0x2
+#define   DTEN                  0x4
+#define   IEOC                  0x8
+#define   EACS                  0x10
+#define   CONV_HCEN             0x80
+#define DAS800_SCAN_LIMITS    2
+#define DAS800_STATUS         2
+#define   IRQ                   0x8
+#define   BUSY                  0x80
+#define DAS800_GAIN           3
+#define   CIO_FFOV              0x8	// fifo overflow for cio-das802/16
+#define   CIO_ENHF              0x90	// interrupt fifo half full for cio-das802/16
+#define   CONTROL1              0x80
+#define   CONV_CONTROL          0xa0
+#define   SCAN_LIMITS           0xc0
+#define   ID                    0xe0
+#define DAS800_8254           4
+#define DAS800_STATUS2        7
+#define   STATUS2_HCEN          0x80
+#define   STATUS2_INTE          0X20
+#define DAS800_ID             7
+
+typedef struct das800_board_struct {
+	const char *name;
+	int ai_speed;
+	const comedi_lrange *ai_range;
+	int resolution;
+} das800_board;
+
+//analog input ranges
+static const comedi_lrange range_das800_ai = {
+	1,
+	{
+			RANGE(-5, 5),
+		}
+};
+
+static const comedi_lrange range_das801_ai = {
+	9,
+	{
+			RANGE(-5, 5),
+			RANGE(-10, 10),
+			RANGE(0, 10),
+			RANGE(-0.5, 0.5),
+			RANGE(0, 1),
+			RANGE(-0.05, 0.05),
+			RANGE(0, 0.1),
+			RANGE(-0.01, 0.01),
+			RANGE(0, 0.02),
+		}
+};
+
+static const comedi_lrange range_cio_das801_ai = {
+	9,
+	{
+			RANGE(-5, 5),
+			RANGE(-10, 10),
+			RANGE(0, 10),
+			RANGE(-0.5, 0.5),
+			RANGE(0, 1),
+			RANGE(-0.05, 0.05),
+			RANGE(0, 0.1),
+			RANGE(-0.005, 0.005),
+			RANGE(0, 0.01),
+		}
+};
+
+static const comedi_lrange range_das802_ai = {
+	9,
+	{
+			RANGE(-5, 5),
+			RANGE(-10, 10),
+			RANGE(0, 10),
+			RANGE(-2.5, 2.5),
+			RANGE(0, 5),
+			RANGE(-1.25, 1.25),
+			RANGE(0, 2.5),
+			RANGE(-0.625, 0.625),
+			RANGE(0, 1.25),
+		}
+};
+
+static const comedi_lrange range_das80216_ai = {
+	8,
+	{
+			RANGE(-10, 10),
+			RANGE(0, 10),
+			RANGE(-5, 5),
+			RANGE(0, 5),
+			RANGE(-2.5, 2.5),
+			RANGE(0, 2.5),
+			RANGE(-1.25, 1.25),
+			RANGE(0, 1.25),
+		}
+};
+
+enum { das800, ciodas800, das801, ciodas801, das802, ciodas802, ciodas80216 };
+
+static const das800_board das800_boards[] = {
+	{
+	      name:	"das-800",
+	      ai_speed:25000,
+	      ai_range:&range_das800_ai,
+	      resolution:12,
+		},
+	{
+	      name:	"cio-das800",
+	      ai_speed:20000,
+	      ai_range:&range_das800_ai,
+	      resolution:12,
+		},
+	{
+	      name:	"das-801",
+	      ai_speed:25000,
+	      ai_range:&range_das801_ai,
+	      resolution:12,
+		},
+	{
+	      name:	"cio-das801",
+	      ai_speed:20000,
+	      ai_range:&range_cio_das801_ai,
+	      resolution:12,
+		},
+	{
+	      name:	"das-802",
+	      ai_speed:25000,
+	      ai_range:&range_das802_ai,
+	      resolution:12,
+		},
+	{
+	      name:	"cio-das802",
+	      ai_speed:20000,
+	      ai_range:&range_das802_ai,
+	      resolution:12,
+		},
+	{
+	      name:	"cio-das802/16",
+	      ai_speed:10000,
+	      ai_range:&range_das80216_ai,
+	      resolution:16,
+		},
+};
+
+/*
+ * Useful for shorthand access to the particular board structure
+ */
+#define thisboard ((const das800_board *)dev->board_ptr)
+
+typedef struct {
+	volatile unsigned int count;	/* number of data points left to be taken */
+	volatile int forever;	/* flag indicating whether we should take data forever */
+	unsigned int divisor1;	/* value to load into board's counter 1 for timed conversions */
+	unsigned int divisor2;	/* value to load into board's counter 2 for timed conversions */
+	volatile int do_bits;	/* digital output bits */
+} das800_private;
+
+#define devpriv ((das800_private *)dev->private)
+
+static int das800_attach(comedi_device * dev, comedi_devconfig * it);
+static int das800_detach(comedi_device * dev);
+static int das800_cancel(comedi_device * dev, comedi_subdevice * s);
+
+static comedi_driver driver_das800 = {
+      driver_name:"das800",
+      module:THIS_MODULE,
+      attach:das800_attach,
+      detach:das800_detach,
+      num_names:sizeof(das800_boards) / sizeof(das800_board),
+      board_name:&das800_boards[0].name,
+      offset:sizeof(das800_board),
+};
+
+static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG);
+static void enable_das800(comedi_device * dev);
+static void disable_das800(comedi_device * dev);
+static int das800_ai_do_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int das800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s);
+static int das800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das800_di_rbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das800_do_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das800_probe(comedi_device * dev);
+static int das800_set_frequency(comedi_device * dev);
+
+/* checks and probes das-800 series board type */
+static int das800_probe(comedi_device * dev)
+{
+	int id_bits;
+	unsigned long irq_flags;
+	int board;
+
+	// 'comedi spin lock irqsave' disables even rt interrupts, we use them to protect indirect addressing
+	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(ID, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be ID register */
+	id_bits = inb(dev->iobase + DAS800_ID) & 0x3;	/* get id bits */
+	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+
+	board = thisboard - das800_boards;
+
+	switch (id_bits) {
+	case 0x0:
+		if (board == das800) {
+			printk(" Board model: DAS-800\n");
+			return board;
+		}
+		if (board == ciodas800) {
+			printk(" Board model: CIO-DAS800\n");
+			return board;
+		}
+		printk(" Board model (probed): DAS-800\n");
+		return das800;
+		break;
+	case 0x2:
+		if (board == das801) {
+			printk(" Board model: DAS-801\n");
+			return board;
+		}
+		if (board == ciodas801) {
+			printk(" Board model: CIO-DAS801\n");
+			return board;
+		}
+		printk(" Board model (probed): DAS-801\n");
+		return das801;
+		break;
+	case 0x3:
+		if (board == das802) {
+			printk(" Board model: DAS-802\n");
+			return board;
+		}
+		if (board == ciodas802) {
+			printk(" Board model: CIO-DAS802\n");
+			return board;
+		}
+		if (board == ciodas80216) {
+			printk(" Board model: CIO-DAS802/16\n");
+			return board;
+		}
+		printk(" Board model (probed): DAS-802\n");
+		return das802;
+		break;
+	default:
+		printk(" Board model: probe returned 0x%x (unknown)\n",
+			id_bits);
+		return board;
+		break;
+	}
+	return -1;
+}
+
+/*
+ * A convenient macro that defines init_module() and cleanup_module(),
+ * as necessary.
+ */
+COMEDI_INITCLEANUP(driver_das800);
+
+/* interrupt service routine */
+static irqreturn_t das800_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	short i;		/* loop index */
+	sampl_t dataPoint = 0;
+	comedi_device *dev = d;
+	comedi_subdevice *s = dev->read_subdev;	/* analog input subdevice */
+	comedi_async *async;
+	int status;
+	unsigned long irq_flags;
+	static const int max_loops = 128;	// half-fifo size for cio-das802/16
+	// flags
+	int fifo_empty = 0;
+	int fifo_overflow = 0;
+
+	status = inb(dev->iobase + DAS800_STATUS);
+	/* if interrupt was not generated by board or driver not attached, quit */
+	if (!(status & IRQ))
+		return IRQ_NONE;
+	if (!(dev->attached))
+		return IRQ_HANDLED;
+
+	/* wait until here to initialize async, since we will get null dereference
+	 * if interrupt occurs before driver is fully attached!
+	 */
+	async = s->async;
+
+	// if hardware conversions are not enabled, then quit
+	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be STATUS2 register */
+	status = inb(dev->iobase + DAS800_STATUS2) & STATUS2_HCEN;
+	/* don't release spinlock yet since we want to make sure noone else disables hardware conversions */
+	if (status == 0) {
+		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		return IRQ_HANDLED;
+	}
+
+	/* loop while card's fifo is not empty (and limit to half fifo for cio-das802/16) */
+	for (i = 0; i < max_loops; i++) {
+		/* read 16 bits from dev->iobase and dev->iobase + 1 */
+		dataPoint = inb(dev->iobase + DAS800_LSB);
+		dataPoint += inb(dev->iobase + DAS800_MSB) << 8;
+		if (thisboard->resolution == 12) {
+			fifo_empty = dataPoint & FIFO_EMPTY;
+			fifo_overflow = dataPoint & FIFO_OVF;
+			if (fifo_overflow)
+				break;
+		} else {
+			fifo_empty = 0;	// cio-das802/16 has no fifo empty status bit
+		}
+		if (fifo_empty) {
+			break;
+		}
+		/* strip off extraneous bits for 12 bit cards */
+		if (thisboard->resolution == 12)
+			dataPoint = (dataPoint >> 4) & 0xfff;
+		/* if there are more data points to collect */
+		if (devpriv->count > 0 || devpriv->forever == 1) {
+			/* write data point to buffer */
+			cfc_write_to_buffer(s, dataPoint);
+			if (devpriv->count > 0)
+				devpriv->count--;
+		}
+	}
+	async->events |= COMEDI_CB_BLOCK;
+	/* check for fifo overflow */
+	if (thisboard->resolution == 12) {
+		fifo_overflow = dataPoint & FIFO_OVF;
+		// else cio-das802/16
+	} else {
+		fifo_overflow = inb(dev->iobase + DAS800_GAIN) & CIO_FFOV;
+	}
+	if (fifo_overflow) {
+		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		comedi_error(dev, "DAS800 FIFO overflow");
+		das800_cancel(dev, dev->subdevices + 0);
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		comedi_event(dev, s);
+		async->events = 0;
+		return IRQ_HANDLED;
+	}
+	if (devpriv->count > 0 || devpriv->forever == 1) {
+		/* Re-enable card's interrupt.
+		 * We already have spinlock, so indirect addressing is safe */
+		outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
+		outb(CONTROL1_INTE | devpriv->do_bits,
+			dev->iobase + DAS800_CONTROL1);
+		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		/* otherwise, stop taking data */
+	} else {
+		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		disable_das800(dev);	/* diable hardware triggered conversions */
+		async->events |= COMEDI_CB_EOA;
+	}
+	comedi_event(dev, s);
+	async->events = 0;
+	return IRQ_HANDLED;
+}
+
+static int das800_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	unsigned long iobase = it->options[0];
+	unsigned int irq = it->options[1];
+	unsigned long irq_flags;
+	int board;
+
+	printk("comedi%d: das800: io 0x%lx", dev->minor, iobase);
+	if (irq) {
+		printk(", irq %u", irq);
+	}
+	printk("\n");
+
+	/* allocate and initialize dev->private */
+	if (alloc_private(dev, sizeof(das800_private)) < 0)
+		return -ENOMEM;
+
+	if (iobase == 0) {
+		printk("io base address required for das800\n");
+		return -EINVAL;
+	}
+
+	/* check if io addresses are available */
+	if (!request_region(iobase, DAS800_SIZE, "das800")) {
+		printk("I/O port conflict\n");
+		return -EIO;
+	}
+	dev->iobase = iobase;
+
+	board = das800_probe(dev);
+	if (board < 0) {
+		printk("unable to determine board type\n");
+		return -ENODEV;
+	}
+	dev->board_ptr = das800_boards + board;
+
+	/* grab our IRQ */
+	if (irq == 1 || irq > 7) {
+		printk("irq out of range\n");
+		return -EINVAL;
+	}
+	if (irq) {
+		if (comedi_request_irq(irq, das800_interrupt, 0, "das800", dev)) {
+			printk("unable to allocate irq %u\n", irq);
+			return -EINVAL;
+		}
+	}
+	dev->irq = irq;
+
+	dev->board_name = thisboard->name;
+
+	if (alloc_subdevices(dev, 3) < 0)
+		return -ENOMEM;
+
+	/* analog input subdevice */
+	s = dev->subdevices + 0;
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
+	s->n_chan = 8;
+	s->len_chanlist = 8;
+	s->maxdata = (1 << thisboard->resolution) - 1;
+	s->range_table = thisboard->ai_range;
+	s->do_cmd = das800_ai_do_cmd;
+	s->do_cmdtest = das800_ai_do_cmdtest;
+	s->insn_read = das800_ai_rinsn;
+	s->cancel = das800_cancel;
+
+	/* di */
+	s = dev->subdevices + 1;
+	s->type = COMEDI_SUBD_DI;
+	s->subdev_flags = SDF_READABLE;
+	s->n_chan = 3;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_bits = das800_di_rbits;
+
+	/* do */
+	s = dev->subdevices + 2;
+	s->type = COMEDI_SUBD_DO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = 4;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_bits = das800_do_wbits;
+
+	disable_das800(dev);
+
+	/* initialize digital out channels */
+	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
+	outb(CONTROL1_INTE | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+
+	return 0;
+};
+
+static int das800_detach(comedi_device * dev)
+{
+	printk("comedi%d: das800: remove\n", dev->minor);
+
+	/* only free stuff if it has been allocated by _attach */
+	if (dev->iobase)
+		release_region(dev->iobase, DAS800_SIZE);
+	if (dev->irq)
+		comedi_free_irq(dev->irq, dev);
+	return 0;
+};
+
+static int das800_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	devpriv->forever = 0;
+	devpriv->count = 0;
+	disable_das800(dev);
+	return 0;
+}
+
+/* enable_das800 makes the card start taking hardware triggered conversions */
+static void enable_das800(comedi_device * dev)
+{
+	unsigned long irq_flags;
+	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	// enable fifo-half full interrupts for cio-das802/16
+	if (thisboard->resolution == 16)
+		outb(CIO_ENHF, dev->iobase + DAS800_GAIN);
+	outb(CONV_CONTROL, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be conversion control register */
+	outb(CONV_HCEN, dev->iobase + DAS800_CONV_CONTROL);	/* enable hardware triggering */
+	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
+	outb(CONTROL1_INTE | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);	/* enable card's interrupt */
+	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+}
+
+/* disable_das800 stops hardware triggered conversions */
+static void disable_das800(comedi_device * dev)
+{
+	unsigned long irq_flags;
+	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(CONV_CONTROL, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be conversion control register */
+	outb(0x0, dev->iobase + DAS800_CONV_CONTROL);	/* disable hardware triggering of conversions */
+	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+}
+
+static int das800_ai_do_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+	int gain, startChan;
+	int i;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_EXT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_FOLLOW;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
+		err++;
+	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < thisboard->ai_speed) {
+			cmd->convert_arg = thisboard->ai_speed;
+			err++;
+		}
+	}
+	if (!cmd->chanlist_len) {
+		cmd->chanlist_len = 1;
+		err++;
+	}
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (!cmd->stop_arg) {
+			cmd->stop_arg = 1;
+			err++;
+		}
+	} else {		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		tmp = cmd->convert_arg;
+		/* calculate counter values that give desired timing */
+		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
+			&(devpriv->divisor2), &(cmd->convert_arg),
+			cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->convert_arg)
+			err++;
+	}
+
+	if (err)
+		return 4;
+
+	// check channel/gain list against card's limitations
+	if (cmd->chanlist) {
+		gain = CR_RANGE(cmd->chanlist[0]);
+		startChan = CR_CHAN(cmd->chanlist[0]);
+		for (i = 1; i < cmd->chanlist_len; i++) {
+			if (CR_CHAN(cmd->chanlist[i]) !=
+				(startChan + i) % N_CHAN_AI) {
+				comedi_error(dev,
+					"entries in chanlist must be consecutive channels, counting upwards\n");
+				err++;
+			}
+			if (CR_RANGE(cmd->chanlist[i]) != gain) {
+				comedi_error(dev,
+					"entries in chanlist must all have the same gain\n");
+				err++;
+			}
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static int das800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	int startChan, endChan, scan, gain;
+	int conv_bits;
+	unsigned long irq_flags;
+	comedi_async *async = s->async;
+
+	if (!dev->irq) {
+		comedi_error(dev,
+			"no irq assigned for das-800, cannot do hardware conversions");
+		return -1;
+	}
+
+	disable_das800(dev);
+
+	/* set channel scan limits */
+	startChan = CR_CHAN(async->cmd.chanlist[0]);
+	endChan = (startChan + async->cmd.chanlist_len - 1) % 8;
+	scan = (endChan << 3) | startChan;
+
+	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(SCAN_LIMITS, dev->iobase + DAS800_GAIN);	/* select base address + 2 to be scan limits register */
+	outb(scan, dev->iobase + DAS800_SCAN_LIMITS);	/* set scan limits */
+	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+
+	/* set gain */
+	gain = CR_RANGE(async->cmd.chanlist[0]);
+	if (thisboard->resolution == 12 && gain > 0)
+		gain += 0x7;
+	gain &= 0xf;
+	outb(gain, dev->iobase + DAS800_GAIN);
+
+	switch (async->cmd.stop_src) {
+	case TRIG_COUNT:
+		devpriv->count = async->cmd.stop_arg * async->cmd.chanlist_len;
+		devpriv->forever = 0;
+		break;
+	case TRIG_NONE:
+		devpriv->forever = 1;
+		devpriv->count = 0;
+		break;
+	default:
+		break;
+	}
+
+	/* enable auto channel scan, send interrupts on end of conversion
+	 * and set clock source to internal or external
+	 */
+	conv_bits = 0;
+	conv_bits |= EACS | IEOC;
+	if (async->cmd.start_src == TRIG_EXT)
+		conv_bits |= DTEN;
+	switch (async->cmd.convert_src) {
+	case TRIG_TIMER:
+		conv_bits |= CASC | ITE;
+		/* set conversion frequency */
+		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
+			&(devpriv->divisor2), &(async->cmd.convert_arg),
+			async->cmd.flags & TRIG_ROUND_MASK);
+		if (das800_set_frequency(dev) < 0) {
+			comedi_error(dev, "Error setting up counters");
+			return -1;
+		}
+		break;
+	case TRIG_EXT:
+		break;
+	default:
+		break;
+	}
+
+	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(CONV_CONTROL, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be conversion control register */
+	outb(conv_bits, dev->iobase + DAS800_CONV_CONTROL);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	async->events = 0;
+	enable_das800(dev);
+	return 0;
+}
+
+static int das800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i, n;
+	int chan;
+	int range;
+	int lsb, msb;
+	int timeout = 1000;
+	unsigned long irq_flags;
+
+	disable_das800(dev);	/* disable hardware conversions (enables software conversions) */
+
+	/* set multiplexer */
+	chan = CR_CHAN(insn->chanspec);
+
+	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
+	outb(chan | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+
+	/* set gain / range */
+	range = CR_RANGE(insn->chanspec);
+	if (thisboard->resolution == 12 && range)
+		range += 0x7;
+	range &= 0xf;
+	outb(range, dev->iobase + DAS800_GAIN);
+
+	comedi_udelay(5);
+
+	for (n = 0; n < insn->n; n++) {
+		/* trigger conversion */
+		outb_p(0, dev->iobase + DAS800_MSB);
+
+		for (i = 0; i < timeout; i++) {
+			if (!(inb(dev->iobase + DAS800_STATUS) & BUSY))
+				break;
+		}
+		if (i == timeout) {
+			comedi_error(dev, "timeout");
+			return -ETIME;
+		}
+		lsb = inb(dev->iobase + DAS800_LSB);
+		msb = inb(dev->iobase + DAS800_MSB);
+		if (thisboard->resolution == 12) {
+			data[n] = (lsb >> 4) & 0xff;
+			data[n] |= (msb << 4);
+		} else {
+			data[n] = (msb << 8) | lsb;
+		}
+	}
+
+	return n;
+}
+
+static int das800_di_rbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	lsampl_t bits;
+
+	bits = inb(dev->iobase + DAS800_STATUS) >> 4;
+	bits &= 0x7;
+	data[1] = bits;
+	data[0] = 0;
+
+	return 2;
+}
+
+static int das800_do_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int wbits;
+	unsigned long irq_flags;
+
+	// only set bits that have been masked
+	data[0] &= 0xf;
+	wbits = devpriv->do_bits >> 4;
+	wbits &= ~data[0];
+	wbits |= data[0] & data[1];
+	devpriv->do_bits = wbits << 4;
+
+	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
+	outb(devpriv->do_bits | CONTROL1_INTE, dev->iobase + DAS800_CONTROL1);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+
+	data[1] = wbits;
+
+	return 2;
+}
+
+/* loads counters with divisor1, divisor2 from private structure */
+static int das800_set_frequency(comedi_device * dev)
+{
+	int err = 0;
+
+	if (i8254_load(dev->iobase + DAS800_8254, 0, 1, devpriv->divisor1, 2))
+		err++;
+	if (i8254_load(dev->iobase + DAS800_8254, 0, 2, devpriv->divisor2, 2))
+		err++;
+	if (err)
+		return -1;
+
+	return 0;
+}
