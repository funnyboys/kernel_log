commit ba932fcfee28b6a23bb8a903ce5a2210ac861721
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Oct 3 14:56:03 2018 -0600

    staging: comedi: ni_routing: Add NI signal routing info
    
    See README for a thorough discussion of this content.
    
    Adds tables of all register values for routing various signals to various
    terminals on National Instruments hardware.  This information is directly
    compared to and taken from register-level programming documentation and/or
    register-level programming examples as provided by National Instruments.
    
    Furthermore, this information was mostly compared (favorably) to the
    register values already used in the comedi drivers for NI hardware.
    
    Adds tables of valid routes for many devices.  This information is not
    consistent from device to device, nor entirely consistent within device
    families.  One additional major challenge is that this information does not
    seem to be obtainable in any programmatic fashion, neither through the
    proprietary NIDAQmx(-base) c-libraries, nor with register level
    programming, _nor_ through any documentation.  In fact, the only consistent
    source of this information is through the proprietary NI-MAX software,
    which currently only runs on Windows platforms.  A further challenge is
    that this information cannot be exported from NI-MAX, except by screenshot.
    
    The collection and maintenance of this information is somewhat tedious and
    requires frequent re-examination and comparison of NI-MAX and/or the
    NI-MHDDK documentation (register programming information) and NI-MHDDK
    examples.  Tools are added with this patch to facilitate generating CSV
    files from the data tables.  These CSV files can be used with a spreadsheet
    program to provide better visual comparision with screenshots gathered from
    NI-MAX.  Tools are also added to regenerate the data tables from CSV
    content--this greatly enhances updating data tables with large changes
    (such as when adding devices).
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_routing/ni_route_values/ni_eseries.c b/drivers/staging/comedi/drivers/ni_routing/ni_route_values/ni_eseries.c
new file mode 100644
index 000000000000..d1ab3c9ce585
--- /dev/null
+++ b/drivers/staging/comedi/drivers/ni_routing/ni_route_values/ni_eseries.c
@@ -0,0 +1,602 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* vim: set ts=8 sw=8 noet tw=80 nowrap: */
+/*
+ *  comedi/drivers/ni_routing/ni_route_values/ni_eseries.c
+ *  Route information for NI_ESERIES boards.
+ *
+ *  COMEDI - Linux Control and Measurement Device Interface
+ *  Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+/*
+ * This file includes a list of all the values of various signals routes
+ * available on NI 660x hardware.  In many cases, one does not explicitly make
+ * these routes, rather one might indicate that something is used as the source
+ * of one particular trigger or another (using *_src=TRIG_EXT).
+ *
+ * The contents of this file can be generated using the tools in
+ * comedi/drivers/ni_routing/tools.  This file also contains specific notes to
+ * this family of devices.
+ *
+ * Please use those tools to help maintain the contents of this file, but be
+ * mindful to not lose the notes already made in this file, since these notes
+ * are critical to a complete undertsanding of the register values of this
+ * family.
+ */
+
+#include "../ni_route_values.h"
+#include "all.h"
+
+/*
+ * Note that for e-series devices, the backplane TRIGGER_LINE(6) is generally
+ * not connected to RTSI(6).
+ */
+
+const struct family_route_values ni_eseries_route_values = {
+	.family = "ni_eseries",
+	.register_values = {
+		/*
+		 * destination = {
+		 *              source          = register value,
+		 *              ...
+		 * }
+		 */
+		[B(NI_PFI(0))] = {
+			[B(NI_AI_StartTrigger)]	= I(NI_PFI_OUTPUT_AI_START1),
+		},
+		[B(NI_PFI(1))] = {
+			[B(NI_AI_ReferenceTrigger)]	= I(NI_PFI_OUTPUT_AI_START2),
+		},
+		[B(NI_PFI(2))] = {
+			[B(NI_AI_ConvertClock)]	= I(NI_PFI_OUTPUT_AI_CONVERT),
+		},
+		[B(NI_PFI(3))] = {
+			[B(NI_CtrSource(1))]	= I(NI_PFI_OUTPUT_G_SRC1),
+		},
+		[B(NI_PFI(4))] = {
+			[B(NI_CtrGate(1))]	= I(NI_PFI_OUTPUT_G_GATE1),
+		},
+		[B(NI_PFI(5))] = {
+			[B(NI_AO_SampleClock)]	= I(NI_PFI_OUTPUT_AO_UPDATE_N),
+		},
+		[B(NI_PFI(6))] = {
+			[B(NI_AO_StartTrigger)]	= I(NI_PFI_OUTPUT_AO_START1),
+		},
+		[B(NI_PFI(7))] = {
+			[B(NI_AI_SampleClock)]	= I(NI_PFI_OUTPUT_AI_START_PULSE),
+		},
+		[B(NI_PFI(8))] = {
+			[B(NI_CtrSource(0))]	= I(NI_PFI_OUTPUT_G_SRC0),
+		},
+		[B(NI_PFI(9))] = {
+			[B(NI_CtrGate(0))]	= I(NI_PFI_OUTPUT_G_GATE0),
+		},
+		[B(TRIGGER_LINE(0))] = {
+			[B(NI_RTSI_BRD(0))]	= I(8),
+			[B(NI_RTSI_BRD(1))]	= I(9),
+			[B(NI_RTSI_BRD(2))]	= I(10),
+			[B(NI_RTSI_BRD(3))]	= I(11),
+			[B(NI_CtrSource(0))]	= I(5),
+			[B(NI_CtrGate(0))]	= I(6),
+			[B(NI_AI_StartTrigger)]	= I(0),
+			[B(NI_AI_ReferenceTrigger)]	= I(1),
+			[B(NI_AI_ConvertClock)]	= I(2),
+			[B(NI_AO_SampleClock)]	= I(3),
+			[B(NI_AO_StartTrigger)]	= I(4),
+			[B(NI_RGOUT0)]	= I(7),
+		},
+		[B(TRIGGER_LINE(1))] = {
+			[B(NI_RTSI_BRD(0))]	= I(8),
+			[B(NI_RTSI_BRD(1))]	= I(9),
+			[B(NI_RTSI_BRD(2))]	= I(10),
+			[B(NI_RTSI_BRD(3))]	= I(11),
+			[B(NI_CtrSource(0))]	= I(5),
+			[B(NI_CtrGate(0))]	= I(6),
+			[B(NI_AI_StartTrigger)]	= I(0),
+			[B(NI_AI_ReferenceTrigger)]	= I(1),
+			[B(NI_AI_ConvertClock)]	= I(2),
+			[B(NI_AO_SampleClock)]	= I(3),
+			[B(NI_AO_StartTrigger)]	= I(4),
+			[B(NI_RGOUT0)]	= I(7),
+		},
+		[B(TRIGGER_LINE(2))] = {
+			[B(NI_RTSI_BRD(0))]	= I(8),
+			[B(NI_RTSI_BRD(1))]	= I(9),
+			[B(NI_RTSI_BRD(2))]	= I(10),
+			[B(NI_RTSI_BRD(3))]	= I(11),
+			[B(NI_CtrSource(0))]	= I(5),
+			[B(NI_CtrGate(0))]	= I(6),
+			[B(NI_AI_StartTrigger)]	= I(0),
+			[B(NI_AI_ReferenceTrigger)]	= I(1),
+			[B(NI_AI_ConvertClock)]	= I(2),
+			[B(NI_AO_SampleClock)]	= I(3),
+			[B(NI_AO_StartTrigger)]	= I(4),
+			[B(NI_RGOUT0)]	= I(7),
+		},
+		[B(TRIGGER_LINE(3))] = {
+			[B(NI_RTSI_BRD(0))]	= I(8),
+			[B(NI_RTSI_BRD(1))]	= I(9),
+			[B(NI_RTSI_BRD(2))]	= I(10),
+			[B(NI_RTSI_BRD(3))]	= I(11),
+			[B(NI_CtrSource(0))]	= I(5),
+			[B(NI_CtrGate(0))]	= I(6),
+			[B(NI_AI_StartTrigger)]	= I(0),
+			[B(NI_AI_ReferenceTrigger)]	= I(1),
+			[B(NI_AI_ConvertClock)]	= I(2),
+			[B(NI_AO_SampleClock)]	= I(3),
+			[B(NI_AO_StartTrigger)]	= I(4),
+			[B(NI_RGOUT0)]	= I(7),
+		},
+		[B(TRIGGER_LINE(4))] = {
+			[B(NI_RTSI_BRD(0))]	= I(8),
+			[B(NI_RTSI_BRD(1))]	= I(9),
+			[B(NI_RTSI_BRD(2))]	= I(10),
+			[B(NI_RTSI_BRD(3))]	= I(11),
+			[B(NI_CtrSource(0))]	= I(5),
+			[B(NI_CtrGate(0))]	= I(6),
+			[B(NI_AI_StartTrigger)]	= I(0),
+			[B(NI_AI_ReferenceTrigger)]	= I(1),
+			[B(NI_AI_ConvertClock)]	= I(2),
+			[B(NI_AO_SampleClock)]	= I(3),
+			[B(NI_AO_StartTrigger)]	= I(4),
+			[B(NI_RGOUT0)]	= I(7),
+		},
+		[B(TRIGGER_LINE(5))] = {
+			[B(NI_RTSI_BRD(0))]	= I(8),
+			[B(NI_RTSI_BRD(1))]	= I(9),
+			[B(NI_RTSI_BRD(2))]	= I(10),
+			[B(NI_RTSI_BRD(3))]	= I(11),
+			[B(NI_CtrSource(0))]	= I(5),
+			[B(NI_CtrGate(0))]	= I(6),
+			[B(NI_AI_StartTrigger)]	= I(0),
+			[B(NI_AI_ReferenceTrigger)]	= I(1),
+			[B(NI_AI_ConvertClock)]	= I(2),
+			[B(NI_AO_SampleClock)]	= I(3),
+			[B(NI_AO_StartTrigger)]	= I(4),
+			[B(NI_RGOUT0)]	= I(7),
+		},
+		[B(TRIGGER_LINE(6))] = {
+			[B(NI_RTSI_BRD(0))]	= I(8),
+			[B(NI_RTSI_BRD(1))]	= I(9),
+			[B(NI_RTSI_BRD(2))]	= I(10),
+			[B(NI_RTSI_BRD(3))]	= I(11),
+			[B(NI_CtrSource(0))]	= I(5),
+			[B(NI_CtrGate(0))]	= I(6),
+			[B(NI_AI_StartTrigger)]	= I(0),
+			[B(NI_AI_ReferenceTrigger)]	= I(1),
+			[B(NI_AI_ConvertClock)]	= I(2),
+			[B(NI_AO_SampleClock)]	= I(3),
+			[B(NI_AO_StartTrigger)]	= I(4),
+			[B(NI_RGOUT0)]	= I(7),
+		},
+		[B(TRIGGER_LINE(7))] = {
+			[B(NI_20MHzTimebase)]	= I(NI_RTSI_OUTPUT_RTSI_OSC),
+		},
+		[B(NI_RTSI_BRD(0))] = {
+			[B(TRIGGER_LINE(0))]	= I(0),
+			[B(TRIGGER_LINE(1))]	= I(1),
+			[B(TRIGGER_LINE(2))]	= I(2),
+			[B(TRIGGER_LINE(3))]	= I(3),
+			[B(TRIGGER_LINE(4))]	= I(4),
+			[B(TRIGGER_LINE(5))]	= I(5),
+			[B(TRIGGER_LINE(6))]	= I(6),
+			[B(PXI_Star)]	= I(6),
+			[B(NI_AI_STOP)]	= I(7),
+		},
+		[B(NI_RTSI_BRD(1))] = {
+			[B(TRIGGER_LINE(0))]	= I(0),
+			[B(TRIGGER_LINE(1))]	= I(1),
+			[B(TRIGGER_LINE(2))]	= I(2),
+			[B(TRIGGER_LINE(3))]	= I(3),
+			[B(TRIGGER_LINE(4))]	= I(4),
+			[B(TRIGGER_LINE(5))]	= I(5),
+			[B(TRIGGER_LINE(6))]	= I(6),
+			[B(PXI_Star)]	= I(6),
+			[B(NI_AI_STOP)]	= I(7),
+		},
+		[B(NI_RTSI_BRD(2))] = {
+			[B(TRIGGER_LINE(0))]	= I(0),
+			[B(TRIGGER_LINE(1))]	= I(1),
+			[B(TRIGGER_LINE(2))]	= I(2),
+			[B(TRIGGER_LINE(3))]	= I(3),
+			[B(TRIGGER_LINE(4))]	= I(4),
+			[B(TRIGGER_LINE(5))]	= I(5),
+			[B(TRIGGER_LINE(6))]	= I(6),
+			[B(PXI_Star)]	= I(6),
+			[B(NI_AI_SampleClock)]	= I(7),
+		},
+		[B(NI_RTSI_BRD(3))] = {
+			[B(TRIGGER_LINE(0))]	= I(0),
+			[B(TRIGGER_LINE(1))]	= I(1),
+			[B(TRIGGER_LINE(2))]	= I(2),
+			[B(TRIGGER_LINE(3))]	= I(3),
+			[B(TRIGGER_LINE(4))]	= I(4),
+			[B(TRIGGER_LINE(5))]	= I(5),
+			[B(TRIGGER_LINE(6))]	= I(6),
+			[B(PXI_Star)]	= I(6),
+			[B(NI_AI_SampleClock)]	= I(7),
+		},
+		[B(NI_CtrSource(0))] = {
+			/* These are not currently implemented in ni modules */
+			[B(NI_PFI(0))]	= U(1),
+			[B(NI_PFI(1))]	= U(2),
+			[B(NI_PFI(2))]	= U(3),
+			[B(NI_PFI(3))]	= U(4),
+			[B(NI_PFI(4))]	= U(5),
+			[B(NI_PFI(5))]	= U(6),
+			[B(NI_PFI(6))]	= U(7),
+			[B(NI_PFI(7))]	= U(8),
+			[B(NI_PFI(8))]	= U(9),
+			[B(NI_PFI(9))]	= U(10),
+			[B(TRIGGER_LINE(0))]	= U(11),
+			[B(TRIGGER_LINE(1))]	= U(12),
+			[B(TRIGGER_LINE(2))]	= U(13),
+			[B(TRIGGER_LINE(3))]	= U(14),
+			[B(TRIGGER_LINE(4))]	= U(15),
+			[B(TRIGGER_LINE(5))]	= U(16),
+			[B(TRIGGER_LINE(6))]	= U(17),
+			[B(NI_CtrInternalOutput(1))]	= U(19),
+			[B(PXI_Star)]	= U(17),
+			[B(NI_20MHzTimebase)]	= U(0),
+			[B(NI_100kHzTimebase)]	= U(18),
+			[B(NI_LogicLow)]	= U(31),
+		},
+		[B(NI_CtrSource(1))] = {
+			/* These are not currently implemented in ni modules */
+			[B(NI_PFI(0))]	= U(1),
+			[B(NI_PFI(1))]	= U(2),
+			[B(NI_PFI(2))]	= U(3),
+			[B(NI_PFI(3))]	= U(4),
+			[B(NI_PFI(4))]	= U(5),
+			[B(NI_PFI(5))]	= U(6),
+			[B(NI_PFI(6))]	= U(7),
+			[B(NI_PFI(7))]	= U(8),
+			[B(NI_PFI(8))]	= U(9),
+			[B(NI_PFI(9))]	= U(10),
+			[B(TRIGGER_LINE(0))]	= U(11),
+			[B(TRIGGER_LINE(1))]	= U(12),
+			[B(TRIGGER_LINE(2))]	= U(13),
+			[B(TRIGGER_LINE(3))]	= U(14),
+			[B(TRIGGER_LINE(4))]	= U(15),
+			[B(TRIGGER_LINE(5))]	= U(16),
+			[B(TRIGGER_LINE(6))]	= U(17),
+			[B(NI_CtrInternalOutput(0))]	= U(19),
+			[B(PXI_Star)]	= U(17),
+			[B(NI_20MHzTimebase)]	= U(0),
+			[B(NI_100kHzTimebase)]	= U(18),
+			[B(NI_LogicLow)]	= U(31),
+		},
+		[B(NI_CtrGate(0))] = {
+			[B(NI_PFI(0))]	= I(1),
+			[B(NI_PFI(1))]	= I(2),
+			[B(NI_PFI(2))]	= I(3),
+			[B(NI_PFI(3))]	= I(4),
+			[B(NI_PFI(4))]	= I(5),
+			[B(NI_PFI(5))]	= I(6),
+			[B(NI_PFI(6))]	= I(7),
+			[B(NI_PFI(7))]	= I(8),
+			[B(NI_PFI(8))]	= I(9),
+			[B(NI_PFI(9))]	= I(10),
+			[B(TRIGGER_LINE(0))]	= I(11),
+			[B(TRIGGER_LINE(1))]	= I(12),
+			[B(TRIGGER_LINE(2))]	= I(13),
+			[B(TRIGGER_LINE(3))]	= I(14),
+			[B(TRIGGER_LINE(4))]	= I(15),
+			[B(TRIGGER_LINE(5))]	= I(16),
+			[B(TRIGGER_LINE(6))]	= I(17),
+			[B(NI_CtrInternalOutput(1))]	= I(20),
+			[B(PXI_Star)]	= I(17),
+			[B(NI_AI_StartTrigger)]	= I(21),
+			[B(NI_AI_ReferenceTrigger)]	= I(18),
+			[B(NI_LogicLow)]	= I(31),
+		},
+		[B(NI_CtrGate(1))] = {
+			[B(NI_PFI(0))]	= I(1),
+			[B(NI_PFI(1))]	= I(2),
+			[B(NI_PFI(2))]	= I(3),
+			[B(NI_PFI(3))]	= I(4),
+			[B(NI_PFI(4))]	= I(5),
+			[B(NI_PFI(5))]	= I(6),
+			[B(NI_PFI(6))]	= I(7),
+			[B(NI_PFI(7))]	= I(8),
+			[B(NI_PFI(8))]	= I(9),
+			[B(NI_PFI(9))]	= I(10),
+			[B(TRIGGER_LINE(0))]	= I(11),
+			[B(TRIGGER_LINE(1))]	= I(12),
+			[B(TRIGGER_LINE(2))]	= I(13),
+			[B(TRIGGER_LINE(3))]	= I(14),
+			[B(TRIGGER_LINE(4))]	= I(15),
+			[B(TRIGGER_LINE(5))]	= I(16),
+			[B(TRIGGER_LINE(6))]	= I(17),
+			[B(NI_CtrInternalOutput(0))]	= I(20),
+			[B(PXI_Star)]	= I(17),
+			[B(NI_AI_StartTrigger)]	= I(21),
+			[B(NI_AI_ReferenceTrigger)]	= I(18),
+			[B(NI_LogicLow)]	= I(31),
+		},
+		[B(NI_CtrOut(0))] = {
+			[B(TRIGGER_LINE(0))]	= I(1),
+			[B(TRIGGER_LINE(1))]	= I(2),
+			[B(TRIGGER_LINE(2))]	= I(3),
+			[B(TRIGGER_LINE(3))]	= I(4),
+			[B(TRIGGER_LINE(4))]	= I(5),
+			[B(TRIGGER_LINE(5))]	= I(6),
+			[B(TRIGGER_LINE(6))]	= I(7),
+			[B(NI_CtrInternalOutput(0))]	= I(0),
+			[B(PXI_Star)]	= I(7),
+		},
+		[B(NI_CtrOut(1))] = {
+			[B(NI_CtrInternalOutput(1))]	= I(0),
+		},
+		[B(NI_AI_SampleClock)] = {
+			[B(NI_PFI(0))]	= I(1),
+			[B(NI_PFI(1))]	= I(2),
+			[B(NI_PFI(2))]	= I(3),
+			[B(NI_PFI(3))]	= I(4),
+			[B(NI_PFI(4))]	= I(5),
+			[B(NI_PFI(5))]	= I(6),
+			[B(NI_PFI(6))]	= I(7),
+			[B(NI_PFI(7))]	= I(8),
+			[B(NI_PFI(8))]	= I(9),
+			[B(NI_PFI(9))]	= I(10),
+			[B(TRIGGER_LINE(0))]	= I(11),
+			[B(TRIGGER_LINE(1))]	= I(12),
+			[B(TRIGGER_LINE(2))]	= I(13),
+			[B(TRIGGER_LINE(3))]	= I(14),
+			[B(TRIGGER_LINE(4))]	= I(15),
+			[B(TRIGGER_LINE(5))]	= I(16),
+			[B(TRIGGER_LINE(6))]	= I(17),
+			[B(NI_CtrInternalOutput(0))]	= I(19),
+			[B(PXI_Star)]	= I(17),
+			[B(NI_AI_SampleClockTimebase)]	= I(0),
+			[B(NI_LogicLow)]	= I(31),
+		},
+		[B(NI_AI_SampleClockTimebase)] = {
+			/* These are not currently implemented in ni modules */
+			[B(NI_PFI(0))]	= U(1),
+			[B(NI_PFI(1))]	= U(2),
+			[B(NI_PFI(2))]	= U(3),
+			[B(NI_PFI(3))]	= U(4),
+			[B(NI_PFI(4))]	= U(5),
+			[B(NI_PFI(5))]	= U(6),
+			[B(NI_PFI(6))]	= U(7),
+			[B(NI_PFI(7))]	= U(8),
+			[B(NI_PFI(8))]	= U(9),
+			[B(NI_PFI(9))]	= U(10),
+			[B(TRIGGER_LINE(0))]	= U(11),
+			[B(TRIGGER_LINE(1))]	= U(12),
+			[B(TRIGGER_LINE(2))]	= U(13),
+			[B(TRIGGER_LINE(3))]	= U(14),
+			[B(TRIGGER_LINE(4))]	= U(15),
+			[B(TRIGGER_LINE(5))]	= U(16),
+			[B(TRIGGER_LINE(6))]	= U(17),
+			[B(PXI_Star)]	= U(17),
+			[B(NI_20MHzTimebase)]	= U(0),
+			[B(NI_100kHzTimebase)]	= U(19),
+			[B(NI_LogicLow)]	= U(31),
+		},
+		[B(NI_AI_StartTrigger)] = {
+			[B(NI_PFI(0))]	= I(1),
+			[B(NI_PFI(1))]	= I(2),
+			[B(NI_PFI(2))]	= I(3),
+			[B(NI_PFI(3))]	= I(4),
+			[B(NI_PFI(4))]	= I(5),
+			[B(NI_PFI(5))]	= I(6),
+			[B(NI_PFI(6))]	= I(7),
+			[B(NI_PFI(7))]	= I(8),
+			[B(NI_PFI(8))]	= I(9),
+			[B(NI_PFI(9))]	= I(10),
+			[B(TRIGGER_LINE(0))]	= I(11),
+			[B(TRIGGER_LINE(1))]	= I(12),
+			[B(TRIGGER_LINE(2))]	= I(13),
+			[B(TRIGGER_LINE(3))]	= I(14),
+			[B(TRIGGER_LINE(4))]	= I(15),
+			[B(TRIGGER_LINE(5))]	= I(16),
+			[B(TRIGGER_LINE(6))]	= I(17),
+			[B(NI_CtrInternalOutput(0))]	= I(18),
+			[B(PXI_Star)]	= I(17),
+			[B(NI_LogicLow)]	= I(31),
+		},
+		[B(NI_AI_ReferenceTrigger)] = {
+			/* These are not currently implemented in ni modules */
+			[B(NI_PFI(0))]	= U(1),
+			[B(NI_PFI(1))]	= U(2),
+			[B(NI_PFI(2))]	= U(3),
+			[B(NI_PFI(3))]	= U(4),
+			[B(NI_PFI(4))]	= U(5),
+			[B(NI_PFI(5))]	= U(6),
+			[B(NI_PFI(6))]	= U(7),
+			[B(NI_PFI(7))]	= U(8),
+			[B(NI_PFI(8))]	= U(9),
+			[B(NI_PFI(9))]	= U(10),
+			[B(TRIGGER_LINE(0))]	= U(11),
+			[B(TRIGGER_LINE(1))]	= U(12),
+			[B(TRIGGER_LINE(2))]	= U(13),
+			[B(TRIGGER_LINE(3))]	= U(14),
+			[B(TRIGGER_LINE(4))]	= U(15),
+			[B(TRIGGER_LINE(5))]	= U(16),
+			[B(TRIGGER_LINE(6))]	= U(17),
+			[B(PXI_Star)]	= U(17),
+			[B(NI_LogicLow)]	= U(31),
+		},
+		[B(NI_AI_ConvertClock)] = {
+			[B(NI_PFI(0))]	= I(1),
+			[B(NI_PFI(1))]	= I(2),
+			[B(NI_PFI(2))]	= I(3),
+			[B(NI_PFI(3))]	= I(4),
+			[B(NI_PFI(4))]	= I(5),
+			[B(NI_PFI(5))]	= I(6),
+			[B(NI_PFI(6))]	= I(7),
+			[B(NI_PFI(7))]	= I(8),
+			[B(NI_PFI(8))]	= I(9),
+			[B(NI_PFI(9))]	= I(10),
+			[B(TRIGGER_LINE(0))]	= I(11),
+			[B(TRIGGER_LINE(1))]	= I(12),
+			[B(TRIGGER_LINE(2))]	= I(13),
+			[B(TRIGGER_LINE(3))]	= I(14),
+			[B(TRIGGER_LINE(4))]	= I(15),
+			[B(TRIGGER_LINE(5))]	= I(16),
+			[B(TRIGGER_LINE(6))]	= I(17),
+			[B(NI_CtrInternalOutput(0))]	= I(19),
+			[B(PXI_Star)]	= I(17),
+			[B(NI_AI_ConvertClockTimebase)]	= I(0),
+			[B(NI_LogicLow)]	= I(31),
+		},
+		[B(NI_AI_ConvertClockTimebase)] = {
+			/* These are not currently implemented in ni modules */
+			[B(NI_AI_SampleClockTimebase)]	= U(0),
+			[B(NI_20MHzTimebase)]	= U(1),
+		},
+		[B(NI_AI_PauseTrigger)] = {
+			/* These are not currently implemented in ni modules */
+			[B(NI_PFI(0))]	= U(1),
+			[B(NI_PFI(1))]	= U(2),
+			[B(NI_PFI(2))]	= U(3),
+			[B(NI_PFI(3))]	= U(4),
+			[B(NI_PFI(4))]	= U(5),
+			[B(NI_PFI(5))]	= U(6),
+			[B(NI_PFI(6))]	= U(7),
+			[B(NI_PFI(7))]	= U(8),
+			[B(NI_PFI(8))]	= U(9),
+			[B(NI_PFI(9))]	= U(10),
+			[B(TRIGGER_LINE(0))]	= U(11),
+			[B(TRIGGER_LINE(1))]	= U(12),
+			[B(TRIGGER_LINE(2))]	= U(13),
+			[B(TRIGGER_LINE(3))]	= U(14),
+			[B(TRIGGER_LINE(4))]	= U(15),
+			[B(TRIGGER_LINE(5))]	= U(16),
+			[B(TRIGGER_LINE(6))]	= U(17),
+			[B(PXI_Star)]	= U(17),
+			[B(NI_LogicLow)]	= U(31),
+		},
+		[B(NI_AO_SampleClock)] = {
+			[B(NI_PFI(0))]	= I(1),
+			[B(NI_PFI(1))]	= I(2),
+			[B(NI_PFI(2))]	= I(3),
+			[B(NI_PFI(3))]	= I(4),
+			[B(NI_PFI(4))]	= I(5),
+			[B(NI_PFI(5))]	= I(6),
+			[B(NI_PFI(6))]	= I(7),
+			[B(NI_PFI(7))]	= I(8),
+			[B(NI_PFI(8))]	= I(9),
+			[B(NI_PFI(9))]	= I(10),
+			[B(TRIGGER_LINE(0))]	= I(11),
+			[B(TRIGGER_LINE(1))]	= I(12),
+			[B(TRIGGER_LINE(2))]	= I(13),
+			[B(TRIGGER_LINE(3))]	= I(14),
+			[B(TRIGGER_LINE(4))]	= I(15),
+			[B(TRIGGER_LINE(5))]	= I(16),
+			[B(TRIGGER_LINE(6))]	= I(17),
+			[B(NI_CtrInternalOutput(1))]	= I(19),
+			[B(PXI_Star)]	= I(17),
+			[B(NI_AO_SampleClockTimebase)]	= I(0),
+			[B(NI_LogicLow)]	= I(31),
+		},
+		[B(NI_AO_SampleClockTimebase)] = {
+			/* These are not currently implemented in ni modules */
+			[B(NI_PFI(0))]	= U(1),
+			[B(NI_PFI(1))]	= U(2),
+			[B(NI_PFI(2))]	= U(3),
+			[B(NI_PFI(3))]	= U(4),
+			[B(NI_PFI(4))]	= U(5),
+			[B(NI_PFI(5))]	= U(6),
+			[B(NI_PFI(6))]	= U(7),
+			[B(NI_PFI(7))]	= U(8),
+			[B(NI_PFI(8))]	= U(9),
+			[B(NI_PFI(9))]	= U(10),
+			[B(TRIGGER_LINE(0))]	= U(11),
+			[B(TRIGGER_LINE(1))]	= U(12),
+			[B(TRIGGER_LINE(2))]	= U(13),
+			[B(TRIGGER_LINE(3))]	= U(14),
+			[B(TRIGGER_LINE(4))]	= U(15),
+			[B(TRIGGER_LINE(5))]	= U(16),
+			[B(TRIGGER_LINE(6))]	= U(17),
+			[B(PXI_Star)]	= U(17),
+			[B(NI_20MHzTimebase)]	= U(0),
+			[B(NI_100kHzTimebase)]	= U(19),
+			[B(NI_LogicLow)]	= U(31),
+		},
+		[B(NI_AO_StartTrigger)] = {
+			[B(NI_PFI(0))]	= I(1),
+			[B(NI_PFI(1))]	= I(2),
+			[B(NI_PFI(2))]	= I(3),
+			[B(NI_PFI(3))]	= I(4),
+			[B(NI_PFI(4))]	= I(5),
+			[B(NI_PFI(5))]	= I(6),
+			[B(NI_PFI(6))]	= I(7),
+			[B(NI_PFI(7))]	= I(8),
+			[B(NI_PFI(8))]	= I(9),
+			[B(NI_PFI(9))]	= I(10),
+			[B(TRIGGER_LINE(0))]	= I(11),
+			[B(TRIGGER_LINE(1))]	= I(12),
+			[B(TRIGGER_LINE(2))]	= I(13),
+			[B(TRIGGER_LINE(3))]	= I(14),
+			[B(TRIGGER_LINE(4))]	= I(15),
+			[B(TRIGGER_LINE(5))]	= I(16),
+			[B(TRIGGER_LINE(6))]	= I(17),
+			[B(PXI_Star)]	= I(17),
+			/*
+			 * for the signal route
+			 * (NI_AI_StartTrigger->NI_AO_StartTrigger), MHDDK says
+			 * used register value 18 and DAQ-STC says 19.
+			 * Hoping that the MHDDK is correct--being a "working"
+			 * example.
+			 */
+			[B(NI_AI_StartTrigger)]	= I(18),
+			[B(NI_LogicLow)]	= I(31),
+		},
+		[B(NI_AO_PauseTrigger)] = {
+			/* These are not currently implemented in ni modules */
+			[B(NI_PFI(0))]	= U(1),
+			[B(NI_PFI(1))]	= U(2),
+			[B(NI_PFI(2))]	= U(3),
+			[B(NI_PFI(3))]	= U(4),
+			[B(NI_PFI(4))]	= U(5),
+			[B(NI_PFI(5))]	= U(6),
+			[B(NI_PFI(6))]	= U(7),
+			[B(NI_PFI(7))]	= U(8),
+			[B(NI_PFI(8))]	= U(9),
+			[B(NI_PFI(9))]	= U(10),
+			[B(TRIGGER_LINE(0))]	= U(11),
+			[B(TRIGGER_LINE(1))]	= U(12),
+			[B(TRIGGER_LINE(2))]	= U(13),
+			[B(TRIGGER_LINE(3))]	= U(14),
+			[B(TRIGGER_LINE(4))]	= U(15),
+			[B(TRIGGER_LINE(5))]	= U(16),
+			[B(TRIGGER_LINE(6))]	= U(17),
+			[B(PXI_Star)]	= U(17),
+			[B(NI_LogicLow)]	= U(31),
+		},
+		[B(NI_MasterTimebase)] = {
+			/* These are not currently implemented in ni modules */
+			[B(TRIGGER_LINE(7))]	= U(1),
+			[B(PXI_Star)]	= U(2),
+			[B(PXI_Clk10)]	= U(3),
+			[B(NI_10MHzRefClock)]	= U(0),
+		},
+		/*
+		 * This symbol is not defined and nothing for this is
+		 * implemented--just including this because data was found in
+		 * the NI-STC for it--can't remember where.
+		 * [B(NI_FrequencyOutTimebase)] = {
+		 *	** These are not currently implemented in ni modules **
+		 *	[B(NI_20MHzTimebase)]	= U(0),
+		 *	[B(NI_100kHzTimebase)]	= U(1),
+		 * },
+		 */
+		[B(NI_RGOUT0)] = {
+			[B(NI_CtrInternalOutput(0))]	= I(0),
+			[B(NI_CtrOut(0))]	= I(1),
+		},
+	},
+};
