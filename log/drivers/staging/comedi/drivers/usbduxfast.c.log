commit 5618332e5b955b4bff06d0b88146b971c8dd7b32
Author: Bernd Porr <mail@berndporr.me.uk>
Date:   Mon Nov 18 23:07:59 2019 +0000

    staging: comedi: usbduxfast: usbduxfast_ai_cmdtest rounding error
    
    The userspace comedilib function 'get_cmd_generic_timed' fills
    the cmd structure with an informed guess and then calls the
    function 'usbduxfast_ai_cmdtest' in this driver repeatedly while
    'usbduxfast_ai_cmdtest' is modifying the cmd struct until it
    no longer changes. However, because of rounding errors this never
    converged because 'steps = (cmd->convert_arg * 30) / 1000' and then
    back to 'cmd->convert_arg = (steps * 1000) / 30' won't be the same
    because of rounding errors. 'Steps' should only be converted back to
    the 'convert_arg' if 'steps' has actually been modified. In addition
    the case of steps being 0 wasn't checked which is also now done.
    
    Signed-off-by: Bernd Porr <mail@berndporr.me.uk>
    Cc: <stable@vger.kernel.org> # 4.4+
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Link: https://lore.kernel.org/r/20191118230759.1727-1-mail@berndporr.me.uk
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 04bc488385e6..4af012968cb6 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- *  Copyright (C) 2004-2014 Bernd Porr, mail@berndporr.me.uk
+ *  Copyright (C) 2004-2019 Bernd Porr, mail@berndporr.me.uk
  */
 
 /*
@@ -8,7 +8,7 @@
  * Description: University of Stirling USB DAQ & INCITE Technology Limited
  * Devices: [ITL] USB-DUX-FAST (usbduxfast)
  * Author: Bernd Porr <mail@berndporr.me.uk>
- * Updated: 10 Oct 2014
+ * Updated: 16 Nov 2019
  * Status: stable
  */
 
@@ -22,6 +22,7 @@
  *
  *
  * Revision history:
+ * 1.0: Fixed a rounding error in usbduxfast_ai_cmdtest
  * 0.9: Dropping the first data packet which seems to be from the last transfer.
  *      Buffer overflows in the FX2 are handed over to comedi.
  * 0.92: Dropping now 4 packets. The quad buffer has to be emptied.
@@ -350,6 +351,7 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 				 struct comedi_cmd *cmd)
 {
 	int err = 0;
+	int err2 = 0;
 	unsigned int steps;
 	unsigned int arg;
 
@@ -399,11 +401,16 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	 */
 	steps = (cmd->convert_arg * 30) / 1000;
 	if (cmd->chanlist_len !=  1)
-		err |= comedi_check_trigger_arg_min(&steps,
-						    MIN_SAMPLING_PERIOD);
-	err |= comedi_check_trigger_arg_max(&steps, MAX_SAMPLING_PERIOD);
-	arg = (steps * 1000) / 30;
-	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
+		err2 |= comedi_check_trigger_arg_min(&steps,
+						     MIN_SAMPLING_PERIOD);
+	else
+		err2 |= comedi_check_trigger_arg_min(&steps, 1);
+	err2 |= comedi_check_trigger_arg_max(&steps, MAX_SAMPLING_PERIOD);
+	if (err2) {
+		err |= err2;
+		arg = (steps * 1000) / 30;
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
+	}
 
 	if (cmd->stop_src == TRIG_COUNT)
 		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);

commit 35756f3dbf4347b8e4b7dcd781da887cafab4786
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Apr 17 16:50:09 2019 +0100

    staging: comedi: usbduxfast: Call mutex_destroy() on private mutex
    
    `usbduxfast_detach()` is the Comedi "detach" handler for the usbduxfast
    driver.  When it is called, the private data for the device is about to
    be freed.  The private date contains a mutex `devpriv->mut` that was
    initialized when the private data was allocated.  Call `mutex_destroy()`
    to mark it as invalid.
    
    The calls to `mutex_lock()` and `mutex_unlock()` in
    `usbduxfast_detach()` are probably not required, especially as the mutex
    is about to be destroyed, but leave them alone for now.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 0d54f394dbd2..04bc488385e6 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -993,6 +993,8 @@ static void usbduxfast_detach(struct comedi_device *dev)
 	kfree(devpriv->duxbuf);
 
 	mutex_unlock(&devpriv->mut);
+
+	mutex_destroy(&devpriv->mut);
 }
 
 static struct comedi_driver usbduxfast_driver = {

commit 037e9edf9d058f68ec33ec518e41c63949f84a0c
Author: Matteo Croce <mcroce@redhat.com>
Date:   Fri Jan 4 22:50:12 2019 +0100

    staging: comedi: fix typo
    
    Fix spelling mistake: "lenghth" -> "length"
    
    Signed-off-by: Matteo Croce <mcroce@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index e18c0723b760..0d54f394dbd2 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -61,7 +61,7 @@
 #define USBDUXFASTSUB_CPUCS	0xE600
 
 /*
- * max lenghth of the transfer-buffer for software upload
+ * max length of the transfer-buffer for software upload
  */
 #define TB_LEN	0x2000
 

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 2015a0cf8314..e18c0723b760 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1,16 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
  *  Copyright (C) 2004-2014 Bernd Porr, mail@berndporr.me.uk
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 608403c7586b..2015a0cf8314 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  *  Copyright (C) 2004-2014 Bernd Porr, mail@berndporr.me.uk
  *

commit 1a55f38d630285b53b83f6809c34c599d43f02c0
Author: Wolfram Sang <wsa-dev@sang-engineering.com>
Date:   Thu Aug 11 23:23:38 2016 +0200

    staging: comedi: drivers: usbduxfast: don't print error when allocating urb fails
    
    kmalloc will print enough information in case of failure.
    
    Signed-off-by: Wolfram Sang <wsa-dev@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 10f94ec34536..608403c7586b 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -946,10 +946,8 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	}
 
 	devpriv->urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!devpriv->urb) {
-		dev_err(dev->class_dev, "Could not alloc. urb\n");
+	if (!devpriv->urb)
 		return -ENOMEM;
-	}
 
 	devpriv->inbuf = kmalloc(SIZEINBUF, GFP_KERNEL);
 	if (!devpriv->inbuf)

commit 27a90695e02759ccab58ca610af4f8ed79d8a35c
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Fri Oct 2 22:07:54 2015 +0200

    Staging: comedi: Use mutex instead of semaphore in usbduxfast.c
    
    Replace binary semaphore with mutex because mutex gives better
    performance.
    This change is safe because the thread that decrements the value of semaphore
    is also the one that increments it, and acts like a mutex where owner of the
    lock is the only one that can release the lock.
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index c6b2a6582127..10f94ec34536 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -160,7 +160,7 @@ struct usbduxfast_private {
 	s8 *inbuf;
 	short int ai_cmd_running;	/* asynchronous command is running */
 	int ignore;		/* counter which ignores the first buffers */
-	struct semaphore sem;
+	struct mutex mut;
 };
 
 /*
@@ -221,9 +221,9 @@ static int usbduxfast_ai_cancel(struct comedi_device *dev,
 	struct usbduxfast_private *devpriv = dev->private;
 	int ret;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	ret = usbduxfast_ai_stop(dev, 1);
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret;
 }
@@ -444,7 +444,7 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	if (!devpriv->ai_cmd_running) {
 		devpriv->ai_cmd_running = 1;
@@ -452,14 +452,14 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 		if (ret < 0) {
 			dev_err(dev->class_dev, "urbSubmit: err=%d\n", ret);
 			devpriv->ai_cmd_running = 0;
-			up(&devpriv->sem);
+			mutex_unlock(&devpriv->mut);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	} else {
 		dev_err(dev->class_dev, "ai is already running\n");
 	}
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 	return 1;
 }
 
@@ -472,7 +472,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	int j, ret;
 	long steps, steps_tmp;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	if (devpriv->ai_cmd_running) {
 		ret = -EBUSY;
 		goto cmd_exit;
@@ -751,7 +751,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	}
 
 cmd_exit:
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret;
 }
@@ -772,12 +772,12 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	int i, j, n, actual_length;
 	int ret;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	if (devpriv->ai_cmd_running) {
 		dev_err(dev->class_dev,
 			"ai_insn_read not possible, async cmd is running\n");
-		up(&devpriv->sem);
+		mutex_unlock(&devpriv->mut);
 		return -EBUSY;
 	}
 
@@ -799,7 +799,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 
 	ret = usbduxfast_send_cmd(dev, SENDADCOMMANDS);
 	if (ret < 0) {
-		up(&devpriv->sem);
+		mutex_unlock(&devpriv->mut);
 		return ret;
 	}
 
@@ -809,7 +809,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 				   &actual_length, 10000);
 		if (ret < 0) {
 			dev_err(dev->class_dev, "insn timeout, no data\n");
-			up(&devpriv->sem);
+			mutex_unlock(&devpriv->mut);
 			return ret;
 		}
 	}
@@ -820,13 +820,13 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 				   &actual_length, 10000);
 		if (ret < 0) {
 			dev_err(dev->class_dev, "insn data error: %d\n", ret);
-			up(&devpriv->sem);
+			mutex_unlock(&devpriv->mut);
 			return ret;
 		}
 		n = actual_length / sizeof(u16);
 		if ((n % 16) != 0) {
 			dev_err(dev->class_dev, "insn data packet corrupted\n");
-			up(&devpriv->sem);
+			mutex_unlock(&devpriv->mut);
 			return -EINVAL;
 		}
 		for (j = chan; (j < n) && (i < insn->n); j = j + 16) {
@@ -835,7 +835,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 		}
 	}
 
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return insn->n;
 }
@@ -930,7 +930,7 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	if (!devpriv)
 		return -ENOMEM;
 
-	sema_init(&devpriv->sem, 1);
+	mutex_init(&devpriv->mut);
 	usb_set_intfdata(intf, devpriv);
 
 	devpriv->duxbuf = kmalloc(SIZEOFDUXBUF, GFP_KERNEL);
@@ -989,7 +989,7 @@ static void usbduxfast_detach(struct comedi_device *dev)
 	if (!devpriv)
 		return;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	usb_set_intfdata(intf, NULL);
 
@@ -1003,7 +1003,7 @@ static void usbduxfast_detach(struct comedi_device *dev)
 
 	kfree(devpriv->duxbuf);
 
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 }
 
 static struct comedi_driver usbduxfast_driver = {

commit e48c9c260189e28b57ab3a7cf68c5a29ab6dbf51
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:14:06 2015 -0700

    staging: comedi: usbduxfast: remove unnecessary clearing of private data
    
    The clearing of the private data members in the (*detatch) is not
    necessary. The comedi core is going to kfree the private data as soon
    as the (*detach) finishes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 4c86a9a913cd..c6b2a6582127 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -998,16 +998,10 @@ static void usbduxfast_detach(struct comedi_device *dev)
 		usb_kill_urb(devpriv->urb);
 
 		kfree(devpriv->inbuf);
-		devpriv->inbuf = NULL;
-
 		usb_free_urb(devpriv->urb);
-		devpriv->urb = NULL;
 	}
 
 	kfree(devpriv->duxbuf);
-	devpriv->duxbuf = NULL;
-
-	devpriv->ai_cmd_running = 0;
 
 	up(&devpriv->sem);
 }

commit 42293db075e121d6baef4d0cd7865e060631f3ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:14:05 2015 -0700

    staging: comedi: usbduxfast: absorb usbduxfast_attach_common()
    
    This function is only called by the (*auto_attach) to do the final
    setup of the analog input subdevice.
    
    For aesthetics absorb it into usbduxfast_auto_attach() and reorder
    the initialization of the subdevice to better follow the "norm" in
    comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 149b558a8896..4c86a9a913cd 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -840,32 +840,6 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int usbduxfast_attach_common(struct comedi_device *dev)
-{
-	struct comedi_subdevice *s;
-	int ret;
-
-	ret = comedi_alloc_subdevices(dev, 1);
-	if (ret)
-		return ret;
-
-	/* Analog Input subdevice */
-	s = &dev->subdevices[0];
-	dev->read_subdev = s;
-	s->type		= COMEDI_SUBD_AI;
-	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
-	s->n_chan	= 16;
-	s->len_chanlist	= 16;
-	s->insn_read	= usbduxfast_ai_insn_read;
-	s->do_cmdtest	= usbduxfast_ai_cmdtest;
-	s->do_cmd	= usbduxfast_ai_cmd;
-	s->cancel	= usbduxfast_ai_cancel;
-	s->maxdata	= 0x1000;	/* 12-bit + 1 overflow bit */
-	s->range_table	= &range_usbduxfast_ai_range;
-
-	return 0;
-}
-
 static int usbduxfast_upload_firmware(struct comedi_device *dev,
 				      const u8 *data, size_t size,
 				      unsigned long context)
@@ -943,6 +917,7 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxfast_private *devpriv;
+	struct comedi_subdevice *s;
 	int ret;
 
 	if (usb->speed != USB_SPEED_HIGH) {
@@ -985,7 +960,25 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	return usbduxfast_attach_common(dev);
+	ret = comedi_alloc_subdevices(dev, 1);
+	if (ret)
+		return ret;
+
+	/* Analog Input subdevice */
+	s = &dev->subdevices[0];
+	dev->read_subdev = s;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
+	s->n_chan	= 16;
+	s->maxdata	= 0x1000;	/* 12-bit + 1 overflow bit */
+	s->range_table	= &range_usbduxfast_ai_range;
+	s->insn_read	= usbduxfast_ai_insn_read;
+	s->len_chanlist	= s->n_chan;
+	s->do_cmdtest	= usbduxfast_ai_cmdtest;
+	s->do_cmd	= usbduxfast_ai_cmd;
+	s->cancel	= usbduxfast_ai_cancel;
+
+	return 0;
 }
 
 static void usbduxfast_detach(struct comedi_device *dev)

commit 7c79c014cba5694633ada77811ce14654dfb8227
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:14:04 2015 -0700

    staging: comedi: usbduxfast: remove unnecessary semaphore down/up
    
    The semaphore down/up in usbduxfast_attach_common() is not necessary.
    This function is only called as part of the (*auto_attach) and does
    not talk to the USB device.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 9e846b43f54e..149b558a8896 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -842,17 +842,12 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 
 static int usbduxfast_attach_common(struct comedi_device *dev)
 {
-	struct usbduxfast_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	int ret;
 
-	down(&devpriv->sem);
-
 	ret = comedi_alloc_subdevices(dev, 1);
-	if (ret) {
-		up(&devpriv->sem);
+	if (ret)
 		return ret;
-	}
 
 	/* Analog Input subdevice */
 	s = &dev->subdevices[0];
@@ -868,8 +863,6 @@ static int usbduxfast_attach_common(struct comedi_device *dev)
 	s->maxdata	= 0x1000;	/* 12-bit + 1 overflow bit */
 	s->range_table	= &range_usbduxfast_ai_range;
 
-	up(&devpriv->sem);
-
 	return 0;
 }
 

commit a05e94bd5230a90eca2905495e764a0ad707c498
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:14:03 2015 -0700

    staging: comedi: usbduxfast: document strange ai maxdata
    
    The subdevice 'maxdata' is typically a mask of the valid bits that can
    be returned by a subdevice, (1 << bits) - 1. The analog inputs of this
    device have a resolution of 12-bits so the 'maxdata' should be 0x0fff.
    But, this hardware can produce a value of 0x1000 indicating an overflow
    from the ADC. The comedilib library's comedi_to_phys() function will
    then return NAN when this value is read from the hardware.
    
    Add a comment to clarify the strage 'maxdata' value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 60f1c5e15a6a..9e846b43f54e 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -865,7 +865,7 @@ static int usbduxfast_attach_common(struct comedi_device *dev)
 	s->do_cmdtest	= usbduxfast_ai_cmdtest;
 	s->do_cmd	= usbduxfast_ai_cmd;
 	s->cancel	= usbduxfast_ai_cancel;
-	s->maxdata	= 0x1000;
+	s->maxdata	= 0x1000;	/* 12-bit + 1 overflow bit */
 	s->range_table	= &range_usbduxfast_ai_range;
 
 	up(&devpriv->sem);

commit 7b0fc5baa0bd75fa04cd784828d7d072fb905144
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:14:02 2015 -0700

    staging: comedi: usbduxfast: use a common exit path in ai (*do_cmd)
    
    For aesthetics, use 'goto' and a common exit point in this function so
    that the up of the semaphore is not overlooked.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index ae775964c7d5..60f1c5e15a6a 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -470,14 +470,12 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int rngmask = 0xff;
 	int j, ret;
-	int result;
 	long steps, steps_tmp;
 
 	down(&devpriv->sem);
 	if (devpriv->ai_cmd_running) {
-		dev_err(dev->class_dev, "ai_cmd not possible\n");
-		up(&devpriv->sem);
-		return -EBUSY;
+		ret = -EBUSY;
+		goto cmd_exit;
 	}
 
 	/*
@@ -734,11 +732,9 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	}
 
 	/* 0 means that the AD commands are sent */
-	result = usbduxfast_send_cmd(dev, SENDADCOMMANDS);
-	if (result < 0) {
-		up(&devpriv->sem);
-		return result;
-	}
+	ret = usbduxfast_send_cmd(dev, SENDADCOMMANDS);
+	if (ret < 0)
+		goto cmd_exit;
 
 	if ((cmd->start_src == TRIG_NOW) || (cmd->start_src == TRIG_EXT)) {
 		/* enable this acquisition operation */
@@ -747,16 +743,17 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		if (ret < 0) {
 			devpriv->ai_cmd_running = 0;
 			/* fixme: unlink here?? */
-			up(&devpriv->sem);
-			return ret;
+			goto cmd_exit;
 		}
 		s->async->inttrig = NULL;
 	} else {	/* TRIG_INT */
 		s->async->inttrig = usbduxfast_ai_inttrig;
 	}
+
+cmd_exit:
 	up(&devpriv->sem);
 
-	return 0;
+	return ret;
 }
 
 /*

commit c748debc66026d1400686ce9bd5183d5bcf36ec3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:14:01 2015 -0700

    staging: comedi: usbduxfast: tidy up the conversion timing validation
    
    Cleanup the validation of the cmd->convert_arg to use the same calculation
    in the (*do_cmdtest) and the (*do_cmd).
    
    Remove the, then unnecessary, redundant check in the (*do_cmd).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index e18b14e9abbf..ae775964c7d5 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -359,8 +359,8 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 				 struct comedi_cmd *cmd)
 {
 	int err = 0;
-	long int steps, tmp;
-	int min_sample_period;
+	unsigned int steps;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -399,21 +399,20 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
 					   cmd->chanlist_len);
 
-	if (cmd->chanlist_len == 1)
-		min_sample_period = 1;
-	else
-		min_sample_period = MIN_SAMPLING_PERIOD;
-
-	steps = cmd->convert_arg * 30;
-	if (steps < (min_sample_period * 1000))
-		steps = min_sample_period * 1000;
-
-	if (steps > (MAX_SAMPLING_PERIOD * 1000))
-		steps = MAX_SAMPLING_PERIOD * 1000;
-
-	/* calc arg again */
-	tmp = steps / 30;
-	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, tmp);
+	/*
+	 * Validate the conversion timing:
+	 * for 1 channel the timing in 30MHz "steps" is:
+	 *	steps <= MAX_SAMPLING_PERIOD
+	 * for all other chanlist_len it is:
+	 *	MIN_SAMPLING_PERIOD <= steps <= MAX_SAMPLING_PERIOD
+	 */
+	steps = (cmd->convert_arg * 30) / 1000;
+	if (cmd->chanlist_len !=  1)
+		err |= comedi_check_trigger_arg_min(&steps,
+						    MIN_SAMPLING_PERIOD);
+	err |= comedi_check_trigger_arg_max(&steps, MAX_SAMPLING_PERIOD);
+	arg = (steps * 1000) / 30;
+	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 
 	if (cmd->stop_src == TRIG_COUNT)
 		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
@@ -489,19 +488,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 
 	steps = (cmd->convert_arg * 30) / 1000;
 
-	if ((steps < MIN_SAMPLING_PERIOD) && (cmd->chanlist_len != 1)) {
-		dev_err(dev->class_dev,
-			"steps=%ld, scan_begin_arg=%d. Not properly tested by cmdtest?\n",
-			steps, cmd->scan_begin_arg);
-		up(&devpriv->sem);
-		return -EINVAL;
-	}
-	if (steps > MAX_SAMPLING_PERIOD) {
-		dev_err(dev->class_dev, "sampling rate too low\n");
-		up(&devpriv->sem);
-		return -EINVAL;
-	}
-
 	switch (cmd->chanlist_len) {
 	case 1:
 		/*

commit fe0d96bf5198a06d4620a10f7faba0e596902e72
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:14:00 2015 -0700

    staging: comedi: usbduxfast: TRIG_EXT is only valid for cmd->start_src
    
    According to the code, and verified with the author Bernd Porr, the
    TRIG_EXT trigger is only valid for the cmd->start_src. Remove this
    trigger from the cmd->scan_begin_src and cmd->convert_src.
    
    The only valid scan_begin_src is then TRIG_FOLLOW  and the convert_src
    is only TRIG_TIMER. Remove the redundant unique trigger checks in Step
    2b of the (*do_cmdtest) as well as any other unnecessary checks of
    those trigger sources.
    
    Also remove the incorrect comment for a cmd->stop_src of TRIG_EXT.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 118347671107..e18b14e9abbf 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -366,10 +366,8 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 
 	err |= comedi_check_trigger_src(&cmd->start_src,
 					TRIG_NOW | TRIG_EXT | TRIG_INT);
-	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
-					TRIG_FOLLOW | TRIG_EXT);
-	err |= comedi_check_trigger_src(&cmd->convert_src,
-					TRIG_TIMER | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);
 	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
@@ -379,16 +377,10 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	/* Step 2a : make sure trigger sources are unique */
 
 	err |= comedi_check_trigger_is_unique(cmd->start_src);
-	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= comedi_check_trigger_is_unique(cmd->convert_src);
 	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
-	/* can't have external stop and start triggers at once */
-	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)
-		err |= -EINVAL;
-
 	if (err)
 		return 2;
 
@@ -412,34 +404,21 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	else
 		min_sample_period = MIN_SAMPLING_PERIOD;
 
-	if (cmd->convert_src == TRIG_TIMER) {
-		steps = cmd->convert_arg * 30;
-		if (steps < (min_sample_period * 1000))
-			steps = min_sample_period * 1000;
+	steps = cmd->convert_arg * 30;
+	if (steps < (min_sample_period * 1000))
+		steps = min_sample_period * 1000;
 
-		if (steps > (MAX_SAMPLING_PERIOD * 1000))
-			steps = MAX_SAMPLING_PERIOD * 1000;
+	if (steps > (MAX_SAMPLING_PERIOD * 1000))
+		steps = MAX_SAMPLING_PERIOD * 1000;
 
-		/* calc arg again */
-		tmp = steps / 30;
-		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, tmp);
-	}
+	/* calc arg again */
+	tmp = steps / 30;
+	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, tmp);
 
-	/* stop source */
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
+	if (cmd->stop_src == TRIG_COUNT)
 		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
-		break;
-	case TRIG_NONE:
+	else	/* TRIG_NONE */
 		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
-		break;
-		/*
-		 * TRIG_EXT doesn't care since it doesn't trigger
-		 * off a numbered channel
-		 */
-	default:
-		break;
-	}
 
 	if (err)
 		return 3;
@@ -508,9 +487,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	 */
 	devpriv->ignore = PACKETS_TO_IGNORE;
 
-	steps = 0;
-	if (cmd->convert_src == TRIG_TIMER)
-		steps = (cmd->convert_arg * 30) / 1000;
+	steps = (cmd->convert_arg * 30) / 1000;
 
 	if ((steps < MIN_SAMPLING_PERIOD) && (cmd->chanlist_len != 1)) {
 		dev_err(dev->class_dev,

commit d636f87d861308a46ad18bb9b23c34ab32ea39de
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:13:59 2015 -0700

    staging: comedi: usbduxfast: TRIG_EXT only works for 1 or 16 channels
    
    Move this check from the (*do_cmd) to the (*do_cmdtest).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 90422de80d82..118347671107 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -399,6 +399,11 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	if (!cmd->chanlist_len)
 		err |= -EINVAL;
 
+	/* external start trigger is only valid for 1 or 16 channels */
+	if (cmd->start_src == TRIG_EXT &&
+	    cmd->chanlist_len != 1 && cmd->chanlist_len != 16)
+		err |= -EINVAL;
+
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
 					   cmd->chanlist_len);
 
@@ -519,13 +524,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		up(&devpriv->sem);
 		return -EINVAL;
 	}
-	if ((cmd->start_src == TRIG_EXT) && (cmd->chanlist_len != 1)
-	    && (cmd->chanlist_len != 16)) {
-		dev_err(dev->class_dev,
-			"TRIG_EXT only with 1 or 16 channels possible\n");
-		up(&devpriv->sem);
-		return -EINVAL;
-	}
 
 	switch (cmd->chanlist_len) {
 	case 1:

commit 24b83783ceda1e7a0e871d9110cbf966387da4d5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:13:58 2015 -0700

    staging: comedi: usbduxfast: fix multi-line comment
    
    This comment does not need to be multi-line. Fix it to remove the
    checkpatch warning.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 9d889be20039..90422de80d82 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -159,8 +159,7 @@ struct usbduxfast_private {
 	u8 *duxbuf;
 	s8 *inbuf;
 	short int ai_cmd_running;	/* asynchronous command is running */
-	int ignore;		/* counter which ignores the first
-				   buffers */
+	int ignore;		/* counter which ignores the first buffers */
 	struct semaphore sem;
 };
 

commit 26961546738e42f3672ba4022c2d0b8b2b6ea882
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:13:57 2015 -0700

    staging: comedi: usbduxfast: use preferred kernel types
    
    As suggested by checkpatch.pl:
    
    CHECK: Prefer kernel type 'u8' over 'uint8_t'
    CHECK: Prefer kernel type 's8' over 'int8_t'
    
    For consistency, also change the uint16_t and int16_t types to
    u16 and s16.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index cb221e7ab60e..9d889be20039 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -97,7 +97,7 @@
 /*
  * size of one A/D value
  */
-#define SIZEADIN	(sizeof(int16_t))
+#define SIZEADIN	(sizeof(s16))
 
 /*
  * size of the input-buffer IN BYTES
@@ -156,8 +156,8 @@ static const struct comedi_lrange range_usbduxfast_ai_range = {
  */
 struct usbduxfast_private {
 	struct urb *urb;	/* BULK-transfer handling: urb */
-	uint8_t *duxbuf;
-	int8_t *inbuf;
+	u8 *duxbuf;
+	s8 *inbuf;
 	short int ai_cmd_running;	/* asynchronous command is running */
 	int ignore;		/* counter which ignores the first
 				   buffers */
@@ -190,8 +190,7 @@ static int usbduxfast_send_cmd(struct comedi_device *dev, int cmd_type)
 }
 
 static void usbduxfast_cmd_data(struct comedi_device *dev, int index,
-				uint8_t len, uint8_t op, uint8_t out,
-				uint8_t log)
+				u8 len, u8 op, u8 out, u8 log)
 {
 	struct usbduxfast_private *devpriv = dev->private;
 
@@ -812,7 +811,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	struct usbduxfast_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
-	uint8_t rngmask = range ? (0xff - 0x04) : 0xff;
+	u8 rngmask = range ? (0xff - 0x04) : 0xff;
 	int i, j, n, actual_length;
 	int ret;
 
@@ -867,14 +866,14 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 			up(&devpriv->sem);
 			return ret;
 		}
-		n = actual_length / sizeof(uint16_t);
+		n = actual_length / sizeof(u16);
 		if ((n % 16) != 0) {
 			dev_err(dev->class_dev, "insn data packet corrupted\n");
 			up(&devpriv->sem);
 			return -EINVAL;
 		}
 		for (j = chan; (j < n) && (i < insn->n); j = j + 16) {
-			data[i] = ((uint16_t *) (devpriv->inbuf))[j];
+			data[i] = ((u16 *)(devpriv->inbuf))[j];
 			i++;
 		}
 	}
@@ -922,7 +921,7 @@ static int usbduxfast_upload_firmware(struct comedi_device *dev,
 				      unsigned long context)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
-	uint8_t *buf;
+	u8 *buf;
 	unsigned char *tmp;
 	int ret;
 

commit fd9fe1fc1cd4771eff4666379b915661d7a4f0d2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:13:56 2015 -0700

    staging: comedi: usbduxfast: remove impossible 'if (!devpriv)' checks
    
    The private data 'devpriv' is allocated in the (*auto_attach) before
    the subdevices are initialized and the (*auto_attach) has to complete
    successfully before the core will call any of the subdevice operations.
    Because of this the (!devpriv) checks in the subdevice code can never
    fail. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index a8635b1659a4..cb221e7ab60e 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -223,9 +223,6 @@ static int usbduxfast_ai_cancel(struct comedi_device *dev,
 	struct usbduxfast_private *devpriv = dev->private;
 	int ret;
 
-	if (!devpriv)
-		return -EFAULT;
-
 	down(&devpriv->sem);
 	ret = usbduxfast_ai_stop(dev, 1);
 	up(&devpriv->sem);
@@ -317,9 +314,6 @@ static int usbduxfast_submit_urb(struct comedi_device *dev)
 	struct usbduxfast_private *devpriv = dev->private;
 	int ret;
 
-	if (!devpriv)
-		return -EFAULT;
-
 	usb_fill_bulk_urb(devpriv->urb, usb, usb_rcvbulkpipe(usb, BULKINEP),
 			  devpriv->inbuf, SIZEINBUF,
 			  usbduxfast_ai_interrupt, dev);
@@ -466,9 +460,6 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int ret;
 
-	if (!devpriv)
-		return -EFAULT;
-
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
@@ -501,9 +492,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	int result;
 	long steps, steps_tmp;
 
-	if (!devpriv)
-		return -EFAULT;
-
 	down(&devpriv->sem);
 	if (devpriv->ai_cmd_running) {
 		dev_err(dev->class_dev, "ai_cmd not possible\n");

commit db1876ff1e7c86dc97d1721ce2e5e0df71072acb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:13:55 2015 -0700

    staging: comedi: usbduxfast: only chanlist of 1, 2, 3, or 16 are supported
    
    The analog input (*do_cmd) only supports channel lists of 1, 2, 3, or 16
    channels. Add a check for this to usbduxfast_ai_check_chanlist() and remove
    the check from usbduxfast_ai_cmd().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 16b28faa2ec2..a8635b1659a4 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -339,6 +339,11 @@ static int usbduxfast_ai_check_chanlist(struct comedi_device *dev,
 	unsigned int gain0 = CR_RANGE(cmd->chanlist[0]);
 	int i;
 
+	if (cmd->chanlist_len > 3 && cmd->chanlist_len != 16) {
+		dev_err(dev->class_dev, "unsupported combination of channels\n");
+		return -EINVAL;
+	}
+
 	for (i = 0; i < cmd->chanlist_len; ++i) {
 		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 		unsigned int gain = CR_RANGE(cmd->chanlist[i]);
@@ -779,11 +784,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		usbduxfast_cmd_data(dev, 4, 0x09, 0x01, rngmask, 0xff);
 
 		break;
-
-	default:
-		dev_err(dev->class_dev, "unsupported combination of channels\n");
-		up(&devpriv->sem);
-		return -EFAULT;
 	}
 
 	/* 0 means that the AD commands are sent */

commit 99555fc25a5f2a40f0d111a67b13bcd8e8d826b1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 24 10:13:54 2015 -0700

    staging: comedi: usbduxfast: chanlist check is Step 5 of (*do_cmdtest)
    
    The channel list should be checked in Step 5 of the (*do_cmdtest) not
    as part of the (*do_cmd). Factor the check out of usbduxfast_ai_cmd().
    
    Tidy up the factored out code. The channel number 'i' will never be
    greater than NUMCHANNELS due to the subdevice setup and the checks
    done in the code. The up/down of the semaphore is also not needed
    because the (*do_cmdtest) never actually tries to access the hardware.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index d90dc59982be..16b28faa2ec2 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -332,6 +332,31 @@ static int usbduxfast_submit_urb(struct comedi_device *dev)
 	return 0;
 }
 
+static int usbduxfast_ai_check_chanlist(struct comedi_device *dev,
+					struct comedi_subdevice *s,
+					struct comedi_cmd *cmd)
+{
+	unsigned int gain0 = CR_RANGE(cmd->chanlist[0]);
+	int i;
+
+	for (i = 0; i < cmd->chanlist_len; ++i) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+		unsigned int gain = CR_RANGE(cmd->chanlist[i]);
+
+		if (chan != i) {
+			dev_err(dev->class_dev,
+				"channels are not consecutive\n");
+			return -EINVAL;
+		}
+		if (gain != gain0 && cmd->chanlist_len > 3) {
+			dev_err(dev->class_dev,
+				"gain must be the same for all channels\n");
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
 static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_cmd *cmd)
@@ -417,7 +442,13 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	/* step 4: fix up any arguments */
+	/* Step 4: fix up any arguments */
+
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= usbduxfast_ai_check_chanlist(dev, s, cmd);
+	if (err)
+		return 5;
 
 	return 0;
 }
@@ -460,8 +491,8 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 {
 	struct usbduxfast_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int chan, gain, rngmask = 0xff;
-	int i, j, ret;
+	unsigned int rngmask = 0xff;
+	int j, ret;
 	int result;
 	long steps, steps_tmp;
 
@@ -481,27 +512,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	 */
 	devpriv->ignore = PACKETS_TO_IGNORE;
 
-	gain = CR_RANGE(cmd->chanlist[0]);
-	for (i = 0; i < cmd->chanlist_len; ++i) {
-		chan = CR_CHAN(cmd->chanlist[i]);
-		if (chan != i) {
-			dev_err(dev->class_dev,
-				"channels are not consecutive\n");
-			up(&devpriv->sem);
-			return -EINVAL;
-		}
-		if ((gain != CR_RANGE(cmd->chanlist[i]))
-			&& (cmd->chanlist_len > 3)) {
-			dev_err(dev->class_dev,
-				"gain must be the same for all channels\n");
-			up(&devpriv->sem);
-			return -EINVAL;
-		}
-		if (i >= NUMCHANNELS) {
-			dev_err(dev->class_dev, "chanlist too long\n");
-			break;
-		}
-	}
 	steps = 0;
 	if (cmd->convert_src == TRIG_TIMER)
 		steps = (cmd->convert_arg * 30) / 1000;

commit f53398ebde69e7f554cdb7ab3d7e34f855557701
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:38 2015 +0000

    staging: comedi: usbduxfast: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 50c47af5f0ac..d90dc59982be 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -48,7 +48,6 @@
 #include <linux/input.h>
 #include <linux/fcntl.h>
 #include <linux/compiler.h>
-#include "comedi_fc.h"
 #include "../comedi_usb.h"
 
 /*
@@ -343,23 +342,24 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src,
+	err |= comedi_check_trigger_src(&cmd->start_src,
 					TRIG_NOW | TRIG_EXT | TRIG_INT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
 					TRIG_FOLLOW | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->convert_src,
+					TRIG_TIMER | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -372,12 +372,13 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (!cmd->chanlist_len)
 		err |= -EINVAL;
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->chanlist_len == 1)
 		min_sample_period = 1;
@@ -394,16 +395,16 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 
 		/* calc arg again */
 		tmp = steps / 30;
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, tmp);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, tmp);
 	}
 
 	/* stop source */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 		break;
 	case TRIG_NONE:
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 		break;
 		/*
 		 * TRIG_EXT doesn't care since it doesn't trigger

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 7ce27c16c2f9..50c47af5f0ac 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -419,7 +419,6 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	return 0;
-
 }
 
 static int usbduxfast_ai_inttrig(struct comedi_device *dev,

commit d3f839528aef38151e4b1bb12f21f49587200139
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jan 27 17:49:06 2015 +0000

    staging: comedi: usbduxfast: include new "comedi_usb.h" header
    
    Include the new "../comedi_usb.h" header instead of <linux/usb.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 85071da3cf43..7ce27c16c2f9 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -46,11 +46,10 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/input.h>
-#include <linux/usb.h>
 #include <linux/fcntl.h>
 #include <linux/compiler.h>
 #include "comedi_fc.h"
-#include "../comedidev.h"
+#include "../comedi_usb.h"
 
 /*
  * timeout for the USB-transfer

commit 504a1aa71b6a36bcf1eb7e8a060175a06126fc78
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 5 17:55:11 2015 +0000

    staging: comedi: usbduxfast: rewrite "Devices:" line
    
    Rewrite the "Devices:" line in the comedi "driver" comment to conform to
    the usual comedi format for this line.  The line should be a
    comma-separated list where the first item is in the following format:
    
      [Manufacturer] BOARD-NAME (comedi-board-name)
    
    The "[Manufacturer]" and/or "(comedi-board-name)" parts may be omitted
    from following items, in which case the parts from the preceding item
    are used.  The "Devices:" line may be continued continued over several
    lines by using one or more spaces at the start of each continuation line
    (not counting the space after the "*" in the block comment).
    
    Also change "USB-DUX" to "USB-DUX-FAST" to distinguish it from the other
    USB-DUX models.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index ddc4cb9d5ed4..85071da3cf43 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -15,7 +15,7 @@
 /*
  * Driver: usbduxfast
  * Description: University of Stirling USB DAQ & INCITE Technology Limited
- * Devices: (ITL) USB-DUX [usbduxfast]
+ * Devices: [ITL] USB-DUX-FAST (usbduxfast)
  * Author: Bernd Porr <mail@berndporr.me.uk>
  * Updated: 10 Oct 2014
  * Status: stable

commit 979f99963cedb8a25f21ac9315082719d768379b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:31:35 2014 -0700

    staging: comedi: usbduxfast: use comedi_async 'scans_done' to detect AI EOA
    
    Remove the private data member 'ai_sample_count' and use the comedi_async
    'scans_done' member to detect the analog input end-of-acquisition.
    
    Use the comedi_nsamples_left() helper to get the number of samples to actually
    add to the async buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 5de76aba8fd9..ddc4cb9d5ed4 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -161,7 +161,6 @@ struct usbduxfast_private {
 	uint8_t *duxbuf;
 	int8_t *inbuf;
 	short int ai_cmd_running;	/* asynchronous command is running */
-	long int ai_sample_count;	/* number of samples to acquire */
 	int ignore;		/* counter which ignores the first
 				   buffers */
 	struct semaphore sem;
@@ -251,15 +250,12 @@ static void usbduxfast_ai_handle_urb(struct comedi_device *dev,
 		unsigned int nsamples;
 
 		nsamples = comedi_bytes_to_samples(s, urb->actual_length);
-		if (cmd->stop_src == TRIG_COUNT) {
-			if (devpriv->ai_sample_count < nsamples) {
-				nsamples = devpriv->ai_sample_count;
-				async->events |= COMEDI_CB_EOA;
-			}
-			devpriv->ai_sample_count -= nsamples;
-		}
-
+		nsamples = comedi_nsamples_left(s, nsamples);
 		comedi_buf_write_samples(s, urb->transfer_buffer, nsamples);
+
+		if (cmd->stop_src == TRIG_COUNT &&
+		    async->scans_done >= cmd->stop_arg)
+			async->events |= COMEDI_CB_EOA;
 	}
 
 	/* if command is still running, resubmit urb for BULK transfer */
@@ -788,11 +784,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		return result;
 	}
 
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->ai_sample_count = cmd->stop_arg * cmd->scan_end_arg;
-	else	/* TRIG_NONE */
-		devpriv->ai_sample_count = 0;
-
 	if ((cmd->start_src == TRIG_NOW) || (cmd->start_src == TRIG_EXT)) {
 		/* enable this acquisition operation */
 		devpriv->ai_cmd_running = 1;

commit c39e050d21d107d26183be0f22b89eccccdbe61c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:28 2014 -0700

    staging: comedi: remove use of 'bytes_per_sample()'
    
    This inline helper function has been replaced with comedi_bytes_per_sample().
    The same commit (bf33eb4b4f57) introduced a couple other related helper
    functions a manipulate the sample size.
    
    Use the new helper functions to remove the use of 'bytes_per_sample()' and
    remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 3bc9013006a0..5de76aba8fd9 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -248,9 +248,9 @@ static void usbduxfast_ai_handle_urb(struct comedi_device *dev,
 	if (devpriv->ignore) {
 		devpriv->ignore--;
 	} else {
-		unsigned int nbytes = urb->actual_length;
-		unsigned int nsamples = nbytes / bytes_per_sample(s);
+		unsigned int nsamples;
 
+		nsamples = comedi_bytes_to_samples(s, urb->actual_length);
 		if (cmd->stop_src == TRIG_COUNT) {
 			if (devpriv->ai_sample_count < nsamples) {
 				nsamples = devpriv->ai_sample_count;

commit a7d3de75cf00574f8d360d51d0e1beb3c561cc89
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:21:54 2014 -0700

    staging: comedi: drivers do not need to reset the async->cur_chan
    
    The comedi core calls comedi_buf_reset() before starting an async command
    (*do_cmd) and after returning a subdevice to an idle state (*cancel).
    
    The drivers do not need to reset the async->cur_chan in those functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 70ec2f552dfc..3bc9013006a0 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -479,8 +479,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		up(&devpriv->sem);
 		return -EBUSY;
 	}
-	/* set current channel of the running acquisition to zero */
-	s->async->cur_chan = 0;
 
 	/*
 	 * ignore the first buffers from the device if there

commit f81ac41b89798a53f03e2204153598b229958660
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:45 2014 -0700

    staging: comedi: usbduxfast: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the samples to the async buffer.
    That function will determining the number of bytes to add based on the
    bytes_per_sample().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 95c2ec7ed22a..70ec2f552dfc 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -249,19 +249,17 @@ static void usbduxfast_ai_handle_urb(struct comedi_device *dev,
 		devpriv->ignore--;
 	} else {
 		unsigned int nbytes = urb->actual_length;
+		unsigned int nsamples = nbytes / bytes_per_sample(s);
 
 		if (cmd->stop_src == TRIG_COUNT) {
-			unsigned int nsamples = nbytes / bytes_per_sample(s);
-
 			if (devpriv->ai_sample_count < nsamples) {
 				nsamples = devpriv->ai_sample_count;
 				async->events |= COMEDI_CB_EOA;
 			}
 			devpriv->ai_sample_count -= nsamples;
-			nbytes = nsamples * bytes_per_sample(s);
 		}
 
-		cfc_write_array_to_buffer(s, urb->transfer_buffer, nbytes);
+		comedi_buf_write_samples(s, urb->transfer_buffer, nsamples);
 	}
 
 	/* if command is still running, resubmit urb for BULK transfer */

commit 7c88f9f48c6fcf31aeda755b723befad642150ca
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 14 12:14:39 2014 -0700

    staging: comedi: usbduxfast: introduce usbduxfast_ai_handle_urb()
    
    Factor the urb handling and resubmit out of the completion handler and
    tidy it up. This allows a common exit path to be used in the completion
    handler to stop the async command and handle the events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index cddc2ba294bb..95c2ec7ed22a 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -236,114 +236,87 @@ static int usbduxfast_ai_cancel(struct comedi_device *dev,
 	return ret;
 }
 
-/*
- * analogue IN
- * interrupt service routine
- */
+static void usbduxfast_ai_handle_urb(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct urb *urb)
+{
+	struct usbduxfast_private *devpriv = dev->private;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	int ret;
+
+	if (devpriv->ignore) {
+		devpriv->ignore--;
+	} else {
+		unsigned int nbytes = urb->actual_length;
+
+		if (cmd->stop_src == TRIG_COUNT) {
+			unsigned int nsamples = nbytes / bytes_per_sample(s);
+
+			if (devpriv->ai_sample_count < nsamples) {
+				nsamples = devpriv->ai_sample_count;
+				async->events |= COMEDI_CB_EOA;
+			}
+			devpriv->ai_sample_count -= nsamples;
+			nbytes = nsamples * bytes_per_sample(s);
+		}
+
+		cfc_write_array_to_buffer(s, urb->transfer_buffer, nbytes);
+	}
+
+	/* if command is still running, resubmit urb for BULK transfer */
+	if (!(async->events & COMEDI_CB_CANCEL_MASK)) {
+		urb->dev = comedi_to_usb_dev(dev);
+		urb->status = 0;
+		ret = usb_submit_urb(urb, GFP_ATOMIC);
+		if (ret < 0) {
+			dev_err(dev->class_dev, "urb resubm failed: %d", ret);
+			async->events |= COMEDI_CB_ERROR;
+		}
+	}
+}
+
 static void usbduxfast_ai_interrupt(struct urb *urb)
 {
 	struct comedi_device *dev = urb->context;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
-	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxfast_private *devpriv = dev->private;
-	int n, err;
 
-	/* are we running a command? */
-	if (unlikely(!devpriv->ai_cmd_running)) {
-		/*
-		 * not running a command
-		 * do not continue execution if no asynchronous command
-		 * is running in particular not resubmit
-		 */
+	/* exit if not running a command, do not resubmit urb */
+	if (!devpriv->ai_cmd_running)
 		return;
-	}
 
-	/* first we test if something unusual has just happened */
 	switch (urb->status) {
 	case 0:
+		usbduxfast_ai_handle_urb(dev, s, urb);
 		break;
 
-		/*
-		 * happens after an unlink command or when the device
-		 * is plugged out
-		 */
 	case -ECONNRESET:
 	case -ENOENT:
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
-		/* tell this comedi */
-		async->events |= COMEDI_CB_EOA;
+		/* after an unlink command, unplug, ... etc */
 		async->events |= COMEDI_CB_ERROR;
-		comedi_event(dev, s);
-		/* stop the transfer w/o unlink */
-		usbduxfast_ai_stop(dev, 0);
-		return;
+		break;
 
 	default:
+		/* a real error */
 		dev_err(dev->class_dev,
 			"non-zero urb status received in ai intr context: %d\n",
 			urb->status);
-		async->events |= COMEDI_CB_EOA;
 		async->events |= COMEDI_CB_ERROR;
-		comedi_event(dev, s);
-		usbduxfast_ai_stop(dev, 0);
-		return;
-	}
-
-	if (!devpriv->ignore) {
-		if (cmd->stop_src == TRIG_COUNT) {
-			/* not continuous, fixed number of samples */
-			n = urb->actual_length / sizeof(uint16_t);
-			if (unlikely(devpriv->ai_sample_count < n)) {
-				unsigned int num_bytes;
-
-				/* partial sample received */
-				num_bytes = devpriv->ai_sample_count *
-					    sizeof(uint16_t);
-				cfc_write_array_to_buffer(s,
-							  urb->transfer_buffer,
-							  num_bytes);
-				usbduxfast_ai_stop(dev, 0);
-				/* tell comedi that the acquistion is over */
-				async->events |= COMEDI_CB_EOA;
-				comedi_event(dev, s);
-				return;
-			}
-			devpriv->ai_sample_count -= n;
-		}
-		/* write the full buffer to comedi */
-		err = cfc_write_array_to_buffer(s, urb->transfer_buffer,
-						urb->actual_length);
-		if (unlikely(err == 0)) {
-			/* buffer overflow */
-			usbduxfast_ai_stop(dev, 0);
-			return;
-		}
-
-		/* tell comedi that data is there */
-		comedi_event(dev, s);
-	} else {
-		/* ignore this packet */
-		devpriv->ignore--;
+		break;
 	}
 
 	/*
-	 * command is still running
-	 * resubmit urb for BULK transfer
+	 * comedi_handle_events() cannot be used in this driver. The (*cancel)
+	 * operation would unlink the urb.
 	 */
-	urb->dev = usb;
-	urb->status = 0;
-	err = usb_submit_urb(urb, GFP_ATOMIC);
-	if (err < 0) {
-		dev_err(dev->class_dev,
-			"urb resubm failed: %d", err);
-		async->events |= COMEDI_CB_EOA;
-		async->events |= COMEDI_CB_ERROR;
-		comedi_event(dev, s);
+	if (async->events & COMEDI_CB_CANCEL_MASK)
 		usbduxfast_ai_stop(dev, 0);
-	}
+
+	comedi_event(dev, s);
 }
 
 static int usbduxfast_submit_urb(struct comedi_device *dev)

commit 533de0f865d727a01a545116fb2447fd60c0bf19
Author: Bernd Porr <mail@berndporr.me.uk>
Date:   Fri Oct 10 20:35:11 2014 +0100

    staging: comedi: usbduxfast: updated address details
    
    Updated the range of years, e-mail and added driver desription as
    usually done in comedi.
    
    Signed-off-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index f85818dd5e11..cddc2ba294bb 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2004 Bernd Porr, Bernd.Porr@f2s.com
+ *  Copyright (C) 2004-2014 Bernd Porr, mail@berndporr.me.uk
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -12,6 +12,15 @@
  * GNU General Public License for more details.
  */
 
+/*
+ * Driver: usbduxfast
+ * Description: University of Stirling USB DAQ & INCITE Technology Limited
+ * Devices: (ITL) USB-DUX [usbduxfast]
+ * Author: Bernd Porr <mail@berndporr.me.uk>
+ * Updated: 10 Oct 2014
+ * Status: stable
+ */
+
 /*
  * I must give credit here to Chris Baugher who
  * wrote the driver for AT-MIO-16d. I used some parts of this

commit 99284f252bb1f9df82dbf6a01bef2b34c19b5083
Author: Bernd Porr <mail@berndporr.me.uk>
Date:   Thu Jul 24 14:34:32 2014 +0100

    staging: comedi: usbduxfast: adding missing break in case statement
    
    Added a missing "break" which forced the board to acquire 16
    channels even when only 3 had been requested.
    Thanks for Hartley Sweeten to spot this bug.
    
    Signed-off-by: Bernd Porr <mail@berndporr.me.uk>
    Reported-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 2490e88e7f32..f85818dd5e11 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -745,6 +745,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 				    0x00, (0xff - 0x02) & rngmask, 0x00);
 
 		usbduxfast_cmd_data(dev, 6, 0x01, 0x00, rngmask, 0x00);
+		break;
 
 	case 16:
 		if (CR_RANGE(cmd->chanlist[0]) > 0)

commit 42f4acdf30121bc0f649875d55876eea9187100a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 12:27:28 2014 -0700

    staging: comedi: usbduxfast: convert pr_err() to dev_err()
    
    Use dev_err() to output the error message and remove the unnecessary
    pr_fmt() macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 85f9dcf59403..2490e88e7f32 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -33,8 +33,6 @@
  *       udev coldplug problem
  */
 
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -275,8 +273,9 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 		return;
 
 	default:
-		pr_err("non-zero urb status received in ai intr context: %d\n",
-		       urb->status);
+		dev_err(dev->class_dev,
+			"non-zero urb status received in ai intr context: %d\n",
+			urb->status);
 		async->events |= COMEDI_CB_EOA;
 		async->events |= COMEDI_CB_ERROR;
 		comedi_event(dev, s);

commit 71cf2b4aaa1c1055ade82917972832f70180cfcb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:31:13 2014 -0700

    staging: comedi: usbduxfast: remove unreachable code in usbduxfast_ai_cmd()
    
    The (*do_cmdtest) validates that the 'stop_arg' is >= 1 for a 'stop_src'
    of TRIG_COUNT and the 'scan_end_arg' is validated to be the 'chanlist_len'
    which will always be >= 1. Remove the unreachable error code for an
    'ai_sample_count < 1'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 376d14608926..85f9dcf59403 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -809,18 +809,11 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		up(&devpriv->sem);
 		return result;
 	}
-	if (cmd->stop_src == TRIG_COUNT) {
+
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ai_sample_count = cmd->stop_arg * cmd->scan_end_arg;
-		if (devpriv->ai_sample_count < 1) {
-			dev_err(dev->class_dev,
-				"(cmd->stop_arg)*(cmd->scan_end_arg)<1, aborting\n");
-			up(&devpriv->sem);
-			return -EFAULT;
-		}
-	} else {
-		/* continous acquisition */
+	else	/* TRIG_NONE */
 		devpriv->ai_sample_count = 0;
-	}
 
 	if ((cmd->start_src == TRIG_NOW) || (cmd->start_src == TRIG_EXT)) {
 		/* enable this acquisition operation */

commit 61ff4709a5820bc28e76f184aa92f5a17ba88ea6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:39 2014 -0700

    staging: comedi: usbduxfast: remove 'ai_continuous' from private data
    
    This member of the private data can be determined from the cmd->stop_src.
    Do that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index a4d7bfbcc6b9..376d14608926 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -154,7 +154,6 @@ struct usbduxfast_private {
 	uint8_t *duxbuf;
 	int8_t *inbuf;
 	short int ai_cmd_running;	/* asynchronous command is running */
-	short int ai_continous;	/* continous acquisition */
 	long int ai_sample_count;	/* number of samples to acquire */
 	int ignore;		/* counter which ignores the first
 				   buffers */
@@ -239,6 +238,7 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 	struct comedi_device *dev = urb->context;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxfast_private *devpriv = dev->private;
 	int n, err;
@@ -285,7 +285,7 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 	}
 
 	if (!devpriv->ignore) {
-		if (!devpriv->ai_continous) {
+		if (cmd->stop_src == TRIG_COUNT) {
 			/* not continuous, fixed number of samples */
 			n = urb->actual_length / sizeof(uint16_t);
 			if (unlikely(devpriv->ai_sample_count < n)) {
@@ -817,10 +817,8 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			up(&devpriv->sem);
 			return -EFAULT;
 		}
-		devpriv->ai_continous = 0;
 	} else {
 		/* continous acquisition */
-		devpriv->ai_continous = 1;
 		devpriv->ai_sample_count = 0;
 	}
 

commit 95194590a71c6b17853c30be9f53227e4648b363
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:08:09 2014 -0700

    staging: comedi: usbduxfast: fix the cmd->start_arg validation and use
    
    This driver supports cmd->start_src values of TRIG_NOW, TRIG_EXT, and
    TRIG_INT. Currently the cmd->start_arg is only validated for TRIG_NOW.
    
    For TRIG_EXT sources, the cmd->start_src is driver specific. For a
    TRIG_INT source, the cmd->start_arg is actually the valid trig_num
    that is used by the async (*inttrig) callback.
    
    The cmd->start_arg is currently not use in the driver. Just trivially
    validate it to be 0 for all cmd->start_src values.
    
    Refactor the (*inttrig) function so that the cmd->start_arg is used
    to check the trig_num instead of the open coded value.
    
    For aesthetics, remove some unnecessary comments in the (*do_cmd)
    function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index d6fae11ee4e0..a4d7bfbcc6b9 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -398,8 +398,7 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_src == TRIG_NOW)
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (!cmd->chanlist_len)
 		err |= -EINVAL;
@@ -451,21 +450,20 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 
 static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
-				 unsigned int trignum)
+				 unsigned int trig_num)
 {
 	struct usbduxfast_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int ret;
 
 	if (!devpriv)
 		return -EFAULT;
 
+	if (trig_num != cmd->start_arg)
+		return -EINVAL;
+
 	down(&devpriv->sem);
 
-	if (trignum != 0) {
-		dev_err(dev->class_dev, "invalid trignum\n");
-		up(&devpriv->sem);
-		return -EINVAL;
-	}
 	if (!devpriv->ai_cmd_running) {
 		devpriv->ai_cmd_running = 1;
 		ret = usbduxfast_submit_urb(dev);
@@ -837,12 +835,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			return ret;
 		}
 		s->async->inttrig = NULL;
-	} else {
-		/*
-		 * TRIG_INT
-		 * don't enable the acquision operation
-		 * wait for an internal signal
-		 */
+	} else {	/* TRIG_INT */
 		s->async->inttrig = usbduxfast_ai_inttrig;
 	}
 	up(&devpriv->sem);

commit 9ebe26cf7acf40391afb6caa4d38bb9cc83a27f0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 15:20:30 2014 -0700

    staging: comedi: usbduxfast: remove TRIG_TIMER from scan_begin_src
    
    Currently the (*do_cmdtest) indicates that TRIG_TIMER is a valid scan_begin_src
    but later this source is tested as -EINVAL. To simplify the code a bit just
    remove the TRIG_TIMER source.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 4a927e44cb0a..d6fae11ee4e0 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -372,7 +372,7 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_src(&cmd->start_src,
 					TRIG_NOW | TRIG_EXT | TRIG_INT);
 	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
-					TRIG_TIMER | TRIG_FOLLOW | TRIG_EXT);
+					TRIG_FOLLOW | TRIG_EXT);
 	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
@@ -424,9 +424,6 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, tmp);
 	}
 
-	if (cmd->scan_begin_src == TRIG_TIMER)
-		err |= -EINVAL;
-
 	/* stop source */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
@@ -536,12 +533,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		}
 	}
 	steps = 0;
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		dev_err(dev->class_dev,
-			"scan_begin_src==TRIG_TIMER not valid\n");
-		up(&devpriv->sem);
-		return -EINVAL;
-	}
 	if (cmd->convert_src == TRIG_TIMER)
 		steps = (cmd->convert_arg * 30) / 1000;
 

commit a5e99e126bf61772ccb0ebcc235f5599265cb5b9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 15:20:29 2014 -0700

    staging: comedi: usbduxfast: 'cmd->chanlist_len' was already validataed
    
    Remove the unnecessary check of 'cmd->chanlist_len > 0'. The (*do_cmdtest) already
    validated this before the (*do_cmd) was called.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 5f85c55c1109..4a927e44cb0a 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -514,27 +514,25 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	 */
 	devpriv->ignore = PACKETS_TO_IGNORE;
 
-	if (cmd->chanlist_len > 0) {
-		gain = CR_RANGE(cmd->chanlist[0]);
-		for (i = 0; i < cmd->chanlist_len; ++i) {
-			chan = CR_CHAN(cmd->chanlist[i]);
-			if (chan != i) {
-				dev_err(dev->class_dev,
-					"channels are not consecutive\n");
-				up(&devpriv->sem);
-				return -EINVAL;
-			}
-			if ((gain != CR_RANGE(cmd->chanlist[i]))
-			    && (cmd->chanlist_len > 3)) {
-				dev_err(dev->class_dev,
-					"gain must be the same for all channels\n");
-				up(&devpriv->sem);
-				return -EINVAL;
-			}
-			if (i >= NUMCHANNELS) {
-				dev_err(dev->class_dev, "chanlist too long\n");
-				break;
-			}
+	gain = CR_RANGE(cmd->chanlist[0]);
+	for (i = 0; i < cmd->chanlist_len; ++i) {
+		chan = CR_CHAN(cmd->chanlist[i]);
+		if (chan != i) {
+			dev_err(dev->class_dev,
+				"channels are not consecutive\n");
+			up(&devpriv->sem);
+			return -EINVAL;
+		}
+		if ((gain != CR_RANGE(cmd->chanlist[i]))
+			&& (cmd->chanlist_len > 3)) {
+			dev_err(dev->class_dev,
+				"gain must be the same for all channels\n");
+			up(&devpriv->sem);
+			return -EINVAL;
+		}
+		if (i >= NUMCHANNELS) {
+			dev_err(dev->class_dev, "chanlist too long\n");
+			break;
 		}
 	}
 	steps = 0;

commit 885a947e5b08953ebd5fce88be89a0399a7ab918
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Dec 10 15:23:48 2013 -0500

    staging: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index c043fd34d0ab..5f85c55c1109 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -37,7 +37,6 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/input.h>
 #include <linux/usb.h>

commit 67b3b78f5df444b2ebece3f8764a360c9c4f9b47
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:25 2013 -0700

    staging: comedi: usbduxfast: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 9707dd1239c4..c043fd34d0ab 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -138,7 +138,10 @@
  * comedi constants
  */
 static const struct comedi_lrange range_usbduxfast_ai_range = {
-	2, {BIP_RANGE(0.75), BIP_RANGE(0.5)}
+	2, {
+		BIP_RANGE(0.75),
+		BIP_RANGE(0.5)
+	}
 };
 
 /*

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 27898c44e543..9707dd1239c4 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1061,10 +1061,9 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 		return -ENODEV;
 	}
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	sema_init(&devpriv->sem, 1);
 	usb_set_intfdata(intf, devpriv);

commit f9eb8a3b141350f1f6525142d23fb8fb2131011b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:28:29 2013 -0700

    staging: comedi: usbduxfast: use comedi_load_firmware()
    
    Use comedi_load_firmware() instead of duplicating the code in a
    private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index f4546b3c4d6d..27898c44e543 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -36,7 +36,6 @@
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/kernel.h>
-#include <linux/firmware.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
@@ -978,23 +977,24 @@ static int usbduxfast_attach_common(struct comedi_device *dev)
 }
 
 static int usbduxfast_upload_firmware(struct comedi_device *dev,
-				      const struct firmware *fw)
+				      const u8 *data, size_t size,
+				      unsigned long context)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	uint8_t *buf;
 	unsigned char *tmp;
 	int ret;
 
-	if (!fw->data)
+	if (!data)
 		return 0;
 
-	if (fw->size > FIRMWARE_MAX_LEN) {
+	if (size > FIRMWARE_MAX_LEN) {
 		dev_err(dev->class_dev, "firmware binary too large for FX2\n");
 		return -ENOMEM;
 	}
 
 	/* we generate a local buffer for the firmware */
-	buf = kmemdup(fw->data, fw->size, GFP_KERNEL);
+	buf = kmemdup(data, size, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
@@ -1023,7 +1023,7 @@ static int usbduxfast_upload_firmware(struct comedi_device *dev,
 			      USBDUXFASTSUB_FIRMWARE,
 			      VENDOR_DIR_OUT,
 			      0, 0x0000,
-			      buf, fw->size,
+			      buf, size,
 			      EZTIMEOUT);
 	if (ret < 0) {
 		dev_err(dev->class_dev, "firmware upload failed\n");
@@ -1047,22 +1047,6 @@ static int usbduxfast_upload_firmware(struct comedi_device *dev,
 	return ret;
 }
 
-static int usbduxfast_request_firmware(struct comedi_device *dev)
-{
-	struct usb_device *usb = comedi_to_usb_dev(dev);
-	const struct firmware *fw;
-	int ret;
-
-	ret = request_firmware(&fw, FIRMWARE, &usb->dev);
-	if (ret)
-		return ret;
-
-	ret = usbduxfast_upload_firmware(dev, fw);
-	release_firmware(fw);
-
-	return ret;
-}
-
 static int usbduxfast_auto_attach(struct comedi_device *dev,
 				  unsigned long context_unused)
 {
@@ -1107,16 +1091,10 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	if (!devpriv->inbuf)
 		return -ENOMEM;
 
-	/*
-	 * Request, and upload, the firmware so we can
-	 * complete the comedi_driver (*auto_attach).
-	 */
-	ret = usbduxfast_request_firmware(dev);
-	if (ret) {
-		dev_err(dev->class_dev, "could not load firmware (err=%d)\n",
-			ret);
+	ret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,
+				   usbduxfast_upload_firmware, 0);
+	if (ret)
 		return ret;
-	}
 
 	return usbduxfast_attach_common(dev);
 }

commit 0a92de24200f8acc2846f575fa7965d3dd7e4017
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:20:30 2013 -0700

    staging: comedi: usbduxfast: use comedi_to_usb_dev()
    
    Use the helper function to get a usb_device pointer from a
    comedi_device pointer. This removes the need for also getting
    the usb_interface pointer in some cases.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 10c48d2385a8..f4546b3c4d6d 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -168,8 +168,7 @@ struct usbduxfast_private {
 
 static int usbduxfast_send_cmd(struct comedi_device *dev, int cmd_type)
 {
-	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	struct usb_device *usb = interface_to_usbdev(intf);
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxfast_private *devpriv = dev->private;
 	int nsent;
 	int ret;
@@ -239,8 +238,7 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 	struct comedi_device *dev = urb->context;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
-	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	struct usb_device *usb = interface_to_usbdev(intf);
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxfast_private *devpriv = dev->private;
 	int n, err;
 
@@ -341,8 +339,7 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 
 static int usbduxfast_submit_urb(struct comedi_device *dev)
 {
-	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	struct usb_device *usb = interface_to_usbdev(intf);
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxfast_private *devpriv = dev->private;
 	int ret;
 
@@ -871,8 +868,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 				   struct comedi_insn *insn,
 				   unsigned int *data)
 {
-	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	struct usb_device *usb = interface_to_usbdev(intf);
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxfast_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
@@ -984,8 +980,7 @@ static int usbduxfast_attach_common(struct comedi_device *dev)
 static int usbduxfast_upload_firmware(struct comedi_device *dev,
 				      const struct firmware *fw)
 {
-	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	struct usb_device *usb = interface_to_usbdev(intf);
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	uint8_t *buf;
 	unsigned char *tmp;
 	int ret;
@@ -1054,8 +1049,7 @@ static int usbduxfast_upload_firmware(struct comedi_device *dev,
 
 static int usbduxfast_request_firmware(struct comedi_device *dev)
 {
-	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	struct usb_device *usb = interface_to_usbdev(intf);
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	const struct firmware *fw;
 	int ret;
 
@@ -1073,7 +1067,7 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 				  unsigned long context_unused)
 {
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	struct usb_device *usb = interface_to_usbdev(intf);
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxfast_private *devpriv;
 	int ret;
 

commit dabf2aa3546aa662cd2624d6308e07454689e91d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:41:51 2013 -0700

    staging: comedi: usbduxfast: tidy up usbduxfast_ai_insn_read()
    
    Remove the sanity check of devpriv, this function can only be called
    by the comedi core if the private data is allocated.
    
    Get the 'chan', 'range' and 'rngmask' from the function parameters
    when the local variables are declared.
    
    For aesthetic reasons, rename the local variable 'err' to 'ret'
    since that name is more standard.
    
    (*insn_read) functions are supposed to return the number of values
    read or an error code. Change the final return to 'insn->n' to make
    it clearer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index fe4bc615a464..10c48d2385a8 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -868,36 +868,28 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
  */
 static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn, unsigned int *data)
+				   struct comedi_insn *insn,
+				   unsigned int *data)
 {
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usb_device *usb = interface_to_usbdev(intf);
 	struct usbduxfast_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	uint8_t rngmask = range ? (0xff - 0x04) : 0xff;
 	int i, j, n, actual_length;
-	int chan, range, rngmask;
-	int err;
-
-	if (!devpriv) {
-		dev_err(dev->class_dev, "no usb dev\n");
-		return -ENODEV;
-	}
+	int ret;
 
 	down(&devpriv->sem);
+
 	if (devpriv->ai_cmd_running) {
 		dev_err(dev->class_dev,
 			"ai_insn_read not possible, async cmd is running\n");
 		up(&devpriv->sem);
 		return -EBUSY;
 	}
-	/* sample one channel */
-	chan = CR_CHAN(insn->chanspec);
-	range = CR_RANGE(insn->chanspec);
-	/* set command for the first channel */
 
-	if (range > 0)
-		rngmask = 0xff - 0x04;
-	else
-		rngmask = 0xff;
+	/* set command for the first channel */
 
 	/* commit data to the FIFO */
 	/* data */
@@ -913,32 +905,31 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	usbduxfast_cmd_data(dev, 5, 0x0c, 0x00, rngmask, 0x00);
 	usbduxfast_cmd_data(dev, 6, 0x01, 0x00, rngmask, 0x00);
 
-	/* 0 means that the AD commands are sent */
-	err = usbduxfast_send_cmd(dev, SENDADCOMMANDS);
-	if (err < 0) {
+	ret = usbduxfast_send_cmd(dev, SENDADCOMMANDS);
+	if (ret < 0) {
 		up(&devpriv->sem);
-		return err;
+		return ret;
 	}
 
 	for (i = 0; i < PACKETS_TO_IGNORE; i++) {
-		err = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),
+		ret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),
 				   devpriv->inbuf, SIZEINBUF,
 				   &actual_length, 10000);
-		if (err < 0) {
+		if (ret < 0) {
 			dev_err(dev->class_dev, "insn timeout, no data\n");
 			up(&devpriv->sem);
-			return err;
+			return ret;
 		}
 	}
-	/* data points */
+
 	for (i = 0; i < insn->n;) {
-		err = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),
+		ret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),
 				   devpriv->inbuf, SIZEINBUF,
 				   &actual_length, 10000);
-		if (err < 0) {
-			dev_err(dev->class_dev, "insn data error: %d\n", err);
+		if (ret < 0) {
+			dev_err(dev->class_dev, "insn data error: %d\n", ret);
 			up(&devpriv->sem);
-			return err;
+			return ret;
 		}
 		n = actual_length / sizeof(uint16_t);
 		if ((n % 16) != 0) {
@@ -951,8 +942,10 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 			i++;
 		}
 	}
+
 	up(&devpriv->sem);
-	return i;
+
+	return insn->n;
 }
 
 static int usbduxfast_attach_common(struct comedi_device *dev)

commit 17fdeba07662e68bf3d9a7270292f0fef9c9fe2d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:41:30 2013 -0700

    staging: comedi: usbduxfast: introduce usbduxfast_cmd_data()
    
    Introduce a helper function to set the buffer used to transfer
    commands to the usb device.
    
    Each command consists of four uint8_t values that are stored at
    specific indexes in the buffer. The helper function consolidates
    the code that sets the buffer to reduce coding errors and make
    the driver a bit easier to understand.
    
    Note, the '0xff & rngmask' can be reduced to simply 'rngmask'
    since the rngmask is always an 8-bit value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index b7ecd946a0ee..fe4bc615a464 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -186,6 +186,19 @@ static int usbduxfast_send_cmd(struct comedi_device *dev, int cmd_type)
 	return ret;
 }
 
+static void usbduxfast_cmd_data(struct comedi_device *dev, int index,
+				uint8_t len, uint8_t op, uint8_t out,
+				uint8_t log)
+{
+	struct usbduxfast_private *devpriv = dev->private;
+
+	/* Set the GPIF bytes, the first byte is the command byte */
+	devpriv->duxbuf[1 + 0x00 + index] = len;
+	devpriv->duxbuf[1 + 0x08 + index] = op;
+	devpriv->duxbuf[1 + 0x10 + index] = out;
+	devpriv->duxbuf[1 + 0x18 + index] = log;
+}
+
 static int usbduxfast_ai_stop(struct comedi_device *dev, int do_unlink)
 {
 	struct usbduxfast_private *devpriv = dev->private;
@@ -475,15 +488,6 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 	return 1;
 }
 
-/*
- * offsets for the GPIF bytes
- * the first byte is the command byte
- */
-#define LENBASE	(1+0x00)
-#define OPBASE	(1+0x08)
-#define OUTBASE	(1+0x10)
-#define LOGBASE	(1+0x18)
-
 static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
@@ -584,17 +588,11 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		/* we loop here until ready has been set */
 		if (cmd->start_src == TRIG_EXT) {
 			/* branch back to state 0 */
-			devpriv->duxbuf[LENBASE + 0] = 0x01;
 			/* deceision state w/o data */
-			devpriv->duxbuf[OPBASE + 0] = 0x01;
-			devpriv->duxbuf[OUTBASE + 0] = 0xFF & rngmask;
 			/* RDY0 = 0 */
-			devpriv->duxbuf[LOGBASE + 0] = 0x00;
+			usbduxfast_cmd_data(dev, 0, 0x01, 0x01, rngmask, 0x00);
 		} else {	/* we just proceed to state 1 */
-			devpriv->duxbuf[LENBASE + 0] = 1;
-			devpriv->duxbuf[OPBASE + 0] = 0;
-			devpriv->duxbuf[OUTBASE + 0] = 0xFF & rngmask;
-			devpriv->duxbuf[LOGBASE + 0] = 0;
+			usbduxfast_cmd_data(dev, 0, 0x01, 0x00, rngmask, 0x00);
 		}
 
 		if (steps < MIN_SAMPLING_PERIOD) {
@@ -607,31 +605,25 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 				 */
 
 				/* branch back to state 1 */
-				devpriv->duxbuf[LENBASE + 1] = 0x89;
 				/* deceision state with data */
-				devpriv->duxbuf[OPBASE + 1] = 0x03;
-				devpriv->duxbuf[OUTBASE + 1] = 0xFF & rngmask;
 				/* doesn't matter */
-				devpriv->duxbuf[LOGBASE + 1] = 0xFF;
+				usbduxfast_cmd_data(dev, 1,
+						    0x89, 0x03, rngmask, 0xff);
 			} else {
 				/*
 				 * we loop through two states: data and delay
 				 * max rate is 15MHz
 				 */
-				devpriv->duxbuf[LENBASE + 1] = steps - 1;
 				/* data */
-				devpriv->duxbuf[OPBASE + 1] = 0x02;
-				devpriv->duxbuf[OUTBASE + 1] =
-				    0xFF & rngmask;
 				/* doesn't matter */
-				devpriv->duxbuf[LOGBASE + 1] = 0;
+				usbduxfast_cmd_data(dev, 1, steps - 1,
+						    0x02, rngmask, 0x00);
+
 				/* branch back to state 1 */
-				devpriv->duxbuf[LENBASE + 2] = 0x09;
 				/* deceision state w/o data */
-				devpriv->duxbuf[OPBASE + 2] = 0x01;
-				devpriv->duxbuf[OUTBASE + 2] = 0xFF & rngmask;
 				/* doesn't matter */
-				devpriv->duxbuf[LOGBASE + 2] = 0xFF;
+				usbduxfast_cmd_data(dev, 2,
+						    0x09, 0x01, rngmask, 0xff);
 			}
 		} else {
 			/*
@@ -643,26 +635,20 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			steps = steps - 1;
 
 			/* do the first part of the delay */
-			devpriv->duxbuf[LENBASE + 1] = steps / 2;
-			devpriv->duxbuf[OPBASE + 1] = 0;
-			devpriv->duxbuf[OUTBASE + 1] = 0xFF & rngmask;
-			devpriv->duxbuf[LOGBASE + 1] = 0;
+			usbduxfast_cmd_data(dev, 1,
+					    steps / 2, 0x00, rngmask, 0x00);
 
 			/* and the second part */
-			devpriv->duxbuf[LENBASE + 2] = steps - steps / 2;
-			devpriv->duxbuf[OPBASE + 2] = 0;
-			devpriv->duxbuf[OUTBASE + 2] = 0xFF & rngmask;
-			devpriv->duxbuf[LOGBASE + 2] = 0;
+			usbduxfast_cmd_data(dev, 2, steps - steps / 2,
+					    0x00, rngmask, 0x00);
 
 			/* get the data and branch back */
 
 			/* branch back to state 1 */
-			devpriv->duxbuf[LENBASE + 3] = 0x09;
 			/* deceision state w data */
-			devpriv->duxbuf[OPBASE + 3] = 0x03;
-			devpriv->duxbuf[OUTBASE + 3] = 0xFF & rngmask;
 			/* doesn't matter */
-			devpriv->duxbuf[LOGBASE + 3] = 0xFF;
+			usbduxfast_cmd_data(dev, 3,
+					    0x09, 0x03, rngmask, 0xff);
 		}
 		break;
 
@@ -677,11 +663,8 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		else
 			rngmask = 0xff;
 
-		devpriv->duxbuf[LENBASE + 0] = 1;
 		/* data */
-		devpriv->duxbuf[OPBASE + 0] = 0x02;
-		devpriv->duxbuf[OUTBASE + 0] = 0xFF & rngmask;
-		devpriv->duxbuf[LOGBASE + 0] = 0;
+		usbduxfast_cmd_data(dev, 0, 0x01, 0x02, rngmask, 0x00);
 
 		/* we have 1 state with duration 1: state 0 */
 		steps_tmp = steps - 1;
@@ -692,23 +675,16 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			rngmask = 0xff;
 
 		/* do the first part of the delay */
-		devpriv->duxbuf[LENBASE + 1] = steps_tmp / 2;
-		devpriv->duxbuf[OPBASE + 1] = 0;
 		/* count */
-		devpriv->duxbuf[OUTBASE + 1] = 0xFE & rngmask;
-		devpriv->duxbuf[LOGBASE + 1] = 0;
+		usbduxfast_cmd_data(dev, 1, steps_tmp / 2,
+				    0x00, 0xfe & rngmask, 0x00);
 
 		/* and the second part */
-		devpriv->duxbuf[LENBASE + 2] = steps_tmp - steps_tmp / 2;
-		devpriv->duxbuf[OPBASE + 2] = 0;
-		devpriv->duxbuf[OUTBASE + 2] = 0xFF & rngmask;
-		devpriv->duxbuf[LOGBASE + 2] = 0;
+		usbduxfast_cmd_data(dev, 2, steps_tmp  - steps_tmp / 2,
+				    0x00, rngmask, 0x00);
 
-		devpriv->duxbuf[LENBASE + 3] = 1;
 		/* data */
-		devpriv->duxbuf[OPBASE + 3] = 0x02;
-		devpriv->duxbuf[OUTBASE + 3] = 0xFF & rngmask;
-		devpriv->duxbuf[LOGBASE + 3] = 0;
+		usbduxfast_cmd_data(dev, 3, 0x01, 0x02, rngmask, 0x00);
 
 		/*
 		 * we have 2 states with duration 1: step 6 and
@@ -722,22 +698,15 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			rngmask = 0xff;
 
 		/* do the first part of the delay */
-		devpriv->duxbuf[LENBASE + 4] = steps_tmp / 2;
-		devpriv->duxbuf[OPBASE + 4] = 0;
 		/* reset */
-		devpriv->duxbuf[OUTBASE + 4] = (0xFF - 0x02) & rngmask;
-		devpriv->duxbuf[LOGBASE + 4] = 0;
+		usbduxfast_cmd_data(dev, 4, steps_tmp / 2,
+				    0x00, (0xff - 0x02) & rngmask, 0x00);
 
 		/* and the second part */
-		devpriv->duxbuf[LENBASE + 5] = steps_tmp - steps_tmp / 2;
-		devpriv->duxbuf[OPBASE + 5] = 0;
-		devpriv->duxbuf[OUTBASE + 5] = 0xFF & rngmask;
-		devpriv->duxbuf[LOGBASE + 5] = 0;
-
-		devpriv->duxbuf[LENBASE + 6] = 1;
-		devpriv->duxbuf[OPBASE + 6] = 0;
-		devpriv->duxbuf[OUTBASE + 6] = 0xFF & rngmask;
-		devpriv->duxbuf[LOGBASE + 6] = 0;
+		usbduxfast_cmd_data(dev, 5, steps_tmp - steps_tmp / 2,
+				    0x00, rngmask, 0x00);
+
+		usbduxfast_cmd_data(dev, 6, 0x01, 0x00, rngmask, 0x00);
 		break;
 
 	case 3:
@@ -745,6 +714,8 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		 * three channels
 		 */
 		for (j = 0; j < 1; j++) {
+			int index = j * 2;
+
 			if (CR_RANGE(cmd->chanlist[j]) > 0)
 				rngmask = 0xff - 0x04;
 			else
@@ -753,12 +724,10 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			 * commit data to the FIFO and do the first part
 			 * of the delay
 			 */
-			devpriv->duxbuf[LENBASE + j * 2] = steps / 2;
 			/* data */
-			devpriv->duxbuf[OPBASE + j * 2] = 0x02;
 			/* no change */
-			devpriv->duxbuf[OUTBASE + j * 2] = 0xFF & rngmask;
-			devpriv->duxbuf[LOGBASE + j * 2] = 0;
+			usbduxfast_cmd_data(dev, index, steps / 2,
+					    0x02, rngmask, 0x00);
 
 			if (CR_RANGE(cmd->chanlist[j + 1]) > 0)
 				rngmask = 0xff - 0x04;
@@ -766,25 +735,19 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 				rngmask = 0xff;
 
 			/* do the second part of the delay */
-			devpriv->duxbuf[LENBASE + j * 2 + 1] =
-			    steps - steps / 2;
 			/* no data */
-			devpriv->duxbuf[OPBASE + j * 2 + 1] = 0;
 			/* count */
-			devpriv->duxbuf[OUTBASE + j * 2 + 1] =
-			    0xFE & rngmask;
-			devpriv->duxbuf[LOGBASE + j * 2 + 1] = 0;
+			usbduxfast_cmd_data(dev, index + 1, steps - steps / 2,
+					    0x00, 0xfe & rngmask, 0x00);
 		}
 
 		/* 2 steps with duration 1: the idele step and step 6: */
 		steps_tmp = steps - 2;
 
 		/* commit data to the FIFO and do the first part of the delay */
-		devpriv->duxbuf[LENBASE + 4] = steps_tmp / 2;
 		/* data */
-		devpriv->duxbuf[OPBASE + 4] = 0x02;
-		devpriv->duxbuf[OUTBASE + 4] = 0xFF & rngmask;
-		devpriv->duxbuf[LOGBASE + 4] = 0;
+		usbduxfast_cmd_data(dev, 4, steps_tmp / 2,
+				    0x02, rngmask, 0x00);
 
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
@@ -792,17 +755,12 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			rngmask = 0xff;
 
 		/* do the second part of the delay */
-		devpriv->duxbuf[LENBASE + 5] = steps_tmp - steps_tmp / 2;
 		/* no data */
-		devpriv->duxbuf[OPBASE + 5] = 0;
 		/* reset */
-		devpriv->duxbuf[OUTBASE + 5] = (0xFF - 0x02) & rngmask;
-		devpriv->duxbuf[LOGBASE + 5] = 0;
+		usbduxfast_cmd_data(dev, 5, steps_tmp - steps_tmp / 2,
+				    0x00, (0xff - 0x02) & rngmask, 0x00);
 
-		devpriv->duxbuf[LENBASE + 6] = 1;
-		devpriv->duxbuf[OPBASE + 6] = 0;
-		devpriv->duxbuf[OUTBASE + 6] = 0xFF & rngmask;
-		devpriv->duxbuf[LOGBASE + 6] = 0;
+		usbduxfast_cmd_data(dev, 6, 0x01, 0x00, rngmask, 0x00);
 
 	case 16:
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
@@ -816,57 +774,41 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			 */
 
 			/* branch back to state 0 */
-			devpriv->duxbuf[LENBASE + 0] = 0x01;
 			/* deceision state w/o data */
-			devpriv->duxbuf[OPBASE + 0] = 0x01;
 			/* reset */
-			devpriv->duxbuf[OUTBASE + 0] =
-			    (0xFF - 0x02) & rngmask;
 			/* RDY0 = 0 */
-			devpriv->duxbuf[LOGBASE + 0] = 0x00;
+			usbduxfast_cmd_data(dev, 0, 0x01, 0x01,
+					    (0xff - 0x02) & rngmask, 0x00);
 		} else {
 			/*
 			 * we just proceed to state 1
 			 */
 
 			/* 30us reset pulse */
-			devpriv->duxbuf[LENBASE + 0] = 255;
-			devpriv->duxbuf[OPBASE + 0] = 0;
 			/* reset */
-			devpriv->duxbuf[OUTBASE + 0] =
-			    (0xFF - 0x02) & rngmask;
-			devpriv->duxbuf[LOGBASE + 0] = 0;
+			usbduxfast_cmd_data(dev, 0, 0xff, 0x00,
+					    (0xff - 0x02) & rngmask, 0x00);
 		}
 
 		/* commit data to the FIFO */
-		devpriv->duxbuf[LENBASE + 1] = 1;
 		/* data */
-		devpriv->duxbuf[OPBASE + 1] = 0x02;
-		devpriv->duxbuf[OUTBASE + 1] = 0xFF & rngmask;
-		devpriv->duxbuf[LOGBASE + 1] = 0;
+		usbduxfast_cmd_data(dev, 1, 0x01, 0x02, rngmask, 0x00);
 
 		/* we have 2 states with duration 1 */
 		steps = steps - 2;
 
 		/* do the first part of the delay */
-		devpriv->duxbuf[LENBASE + 2] = steps / 2;
-		devpriv->duxbuf[OPBASE + 2] = 0;
-		devpriv->duxbuf[OUTBASE + 2] = 0xFE & rngmask;
-		devpriv->duxbuf[LOGBASE + 2] = 0;
+		usbduxfast_cmd_data(dev, 2, steps / 2,
+				    0x00, 0xfe & rngmask, 0x00);
 
 		/* and the second part */
-		devpriv->duxbuf[LENBASE + 3] = steps - steps / 2;
-		devpriv->duxbuf[OPBASE + 3] = 0;
-		devpriv->duxbuf[OUTBASE + 3] = 0xFF & rngmask;
-		devpriv->duxbuf[LOGBASE + 3] = 0;
+		usbduxfast_cmd_data(dev, 3, steps - steps / 2,
+				    0x00, rngmask, 0x00);
 
 		/* branch back to state 1 */
-		devpriv->duxbuf[LENBASE + 4] = 0x09;
 		/* deceision state w/o data */
-		devpriv->duxbuf[OPBASE + 4] = 0x01;
-		devpriv->duxbuf[OUTBASE + 4] = 0xFF & rngmask;
 		/* doesn't matter */
-		devpriv->duxbuf[LOGBASE + 4] = 0xFF;
+		usbduxfast_cmd_data(dev, 4, 0x09, 0x01, rngmask, 0xff);
 
 		break;
 
@@ -958,43 +900,18 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 		rngmask = 0xff;
 
 	/* commit data to the FIFO */
-	devpriv->duxbuf[LENBASE + 0] = 1;
 	/* data */
-	devpriv->duxbuf[OPBASE + 0] = 0x02;
-	devpriv->duxbuf[OUTBASE + 0] = 0xFF & rngmask;
-	devpriv->duxbuf[LOGBASE + 0] = 0;
+	usbduxfast_cmd_data(dev, 0, 0x01, 0x02, rngmask, 0x00);
 
 	/* do the first part of the delay */
-	devpriv->duxbuf[LENBASE + 1] = 12;
-	devpriv->duxbuf[OPBASE + 1] = 0;
-	devpriv->duxbuf[OUTBASE + 1] = 0xFE & rngmask;
-	devpriv->duxbuf[LOGBASE + 1] = 0;
-
-	devpriv->duxbuf[LENBASE + 2] = 1;
-	devpriv->duxbuf[OPBASE + 2] = 0;
-	devpriv->duxbuf[OUTBASE + 2] = 0xFE & rngmask;
-	devpriv->duxbuf[LOGBASE + 2] = 0;
-
-	devpriv->duxbuf[LENBASE + 3] = 1;
-	devpriv->duxbuf[OPBASE + 3] = 0;
-	devpriv->duxbuf[OUTBASE + 3] = 0xFE & rngmask;
-	devpriv->duxbuf[LOGBASE + 3] = 0;
-
-	devpriv->duxbuf[LENBASE + 4] = 1;
-	devpriv->duxbuf[OPBASE + 4] = 0;
-	devpriv->duxbuf[OUTBASE + 4] = 0xFE & rngmask;
-	devpriv->duxbuf[LOGBASE + 4] = 0;
+	usbduxfast_cmd_data(dev, 1, 0x0c, 0x00, 0xfe & rngmask, 0x00);
+	usbduxfast_cmd_data(dev, 2, 0x01, 0x00, 0xfe & rngmask, 0x00);
+	usbduxfast_cmd_data(dev, 3, 0x01, 0x00, 0xfe & rngmask, 0x00);
+	usbduxfast_cmd_data(dev, 4, 0x01, 0x00, 0xfe & rngmask, 0x00);
 
 	/* second part */
-	devpriv->duxbuf[LENBASE + 5] = 12;
-	devpriv->duxbuf[OPBASE + 5] = 0;
-	devpriv->duxbuf[OUTBASE + 5] = 0xFF & rngmask;
-	devpriv->duxbuf[LOGBASE + 5] = 0;
-
-	devpriv->duxbuf[LENBASE + 6] = 1;
-	devpriv->duxbuf[OPBASE + 6] = 0;
-	devpriv->duxbuf[OUTBASE + 6] = 0xFF & rngmask;
-	devpriv->duxbuf[LOGBASE + 0] = 0;
+	usbduxfast_cmd_data(dev, 5, 0x0c, 0x00, rngmask, 0x00);
+	usbduxfast_cmd_data(dev, 6, 0x01, 0x00, rngmask, 0x00);
 
 	/* 0 means that the AD commands are sent */
 	err = usbduxfast_send_cmd(dev, SENDADCOMMANDS);

commit ebe9f1cf2c92c23d7f1ef1bdd399b6d94669a0b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:41:07 2013 -0700

    staging: comedi: usbduxfast: rename usbduxfastsub_submit_InURBs()
    
    Rename this CamelCase function to fix the checkpatch.pl warning.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 7702a3ec4c56..b7ecd946a0ee 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -326,7 +326,7 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 	}
 }
 
-static int usbduxfastsub_submit_InURBs(struct comedi_device *dev)
+static int usbduxfast_submit_urb(struct comedi_device *dev)
 {
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usb_device *usb = interface_to_usbdev(intf);
@@ -460,7 +460,7 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 	}
 	if (!devpriv->ai_cmd_running) {
 		devpriv->ai_cmd_running = 1;
-		ret = usbduxfastsub_submit_InURBs(dev);
+		ret = usbduxfast_submit_urb(dev);
 		if (ret < 0) {
 			dev_err(dev->class_dev, "urbSubmit: err=%d\n", ret);
 			devpriv->ai_cmd_running = 0;
@@ -900,7 +900,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	if ((cmd->start_src == TRIG_NOW) || (cmd->start_src == TRIG_EXT)) {
 		/* enable this acquisition operation */
 		devpriv->ai_cmd_running = 1;
-		ret = usbduxfastsub_submit_InURBs(dev);
+		ret = usbduxfast_submit_urb(dev);
 		if (ret < 0) {
 			devpriv->ai_cmd_running = 0;
 			/* fixme: unlink here?? */

commit bbb2d2d66cebaebc529bd816c539b88154639f48
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:40:45 2013 -0700

    staging: comedi: usbduxfast: rename CamelCase 'minSamplPer'
    
    Rename the local variable to fix the checkpatch.pl warning.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 7ca4fae3c01b..7702a3ec4c56 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -354,7 +354,7 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 {
 	int err = 0;
 	long int steps, tmp;
-	int minSamplPer;
+	int min_sample_period;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -396,14 +396,14 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	if (cmd->chanlist_len == 1)
-		minSamplPer = 1;
+		min_sample_period = 1;
 	else
-		minSamplPer = MIN_SAMPLING_PERIOD;
+		min_sample_period = MIN_SAMPLING_PERIOD;
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		steps = cmd->convert_arg * 30;
-		if (steps < (minSamplPer * 1000))
-			steps = minSamplPer * 1000;
+		if (steps < (min_sample_period * 1000))
+			steps = min_sample_period * 1000;
 
 		if (steps > (MAX_SAMPLING_PERIOD * 1000))
 			steps = MAX_SAMPLING_PERIOD * 1000;

commit fbe38a8b3580aa0b9a842072de8ddd6510b1e522
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:40:24 2013 -0700

    staging: comedi: usbduxfast: consolidate the firmware upload
    
    Absorb the usbduxfastsub_stop(), usbduxfastsub_upload(), and
    usbduxfastsub_start() functions into usbduxfast_upload_firmware().
    
    Each of them just do a usb_control_msg() to the device and output
    an error message if it fails. A similar message is also output by
    usbduxfast_upload_firmware() so the extra messages are redundant.
    
    We can also share the malloc'ed local buffer needed for the
    usb_control_msg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 1c07ab3e1569..7ca4fae3c01b 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -326,90 +326,6 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 	}
 }
 
-static int usbduxfastsub_start(struct comedi_device *dev)
-{
-	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	struct usb_device *usb = interface_to_usbdev(intf);
-	unsigned char *local_transfer_buffer;
-	int ret;
-
-	local_transfer_buffer = kmalloc(1, GFP_KERNEL);
-	if (!local_transfer_buffer)
-		return -ENOMEM;
-
-	/* 7f92 to zero */
-	*local_transfer_buffer = 0;
-	/* bRequest, "Firmware" */
-	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
-			      USBDUXFASTSUB_FIRMWARE,
-			      VENDOR_DIR_OUT,	  /* bmRequestType */
-			      USBDUXFASTSUB_CPUCS,    /* Value */
-			      0x0000,	/* Index */
-			      /* address of the transfer buffer */
-			      local_transfer_buffer,
-			      1,      /* Length */
-			      EZTIMEOUT);    /* Timeout */
-	if (ret < 0)
-		dev_err(dev->class_dev, "control msg failed (start)\n");
-
-	kfree(local_transfer_buffer);
-	return ret;
-}
-
-static int usbduxfastsub_stop(struct comedi_device *dev)
-{
-	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	struct usb_device *usb = interface_to_usbdev(intf);
-	unsigned char *local_transfer_buffer;
-	int ret;
-
-	local_transfer_buffer = kmalloc(1, GFP_KERNEL);
-	if (!local_transfer_buffer)
-		return -ENOMEM;
-
-	/* 7f92 to one */
-	*local_transfer_buffer = 1;
-	/* bRequest, "Firmware" */
-	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
-			      USBDUXFASTSUB_FIRMWARE,
-			      VENDOR_DIR_OUT,	/* bmRequestType */
-			      USBDUXFASTSUB_CPUCS,	/* Value */
-			      0x0000,	/* Index */
-			      local_transfer_buffer, 1,	/* Length */
-			      EZTIMEOUT);	/* Timeout */
-	if (ret < 0)
-		dev_err(dev->class_dev, "control msg failed (stop)\n");
-
-	kfree(local_transfer_buffer);
-	return ret;
-}
-
-static int usbduxfastsub_upload(struct comedi_device *dev,
-				unsigned char *local_transfer_buffer,
-				unsigned int startAddr, unsigned int len)
-{
-	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	struct usb_device *usb = interface_to_usbdev(intf);
-	int ret;
-
-	/* brequest, firmware */
-	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
-			      USBDUXFASTSUB_FIRMWARE,
-			      VENDOR_DIR_OUT,	/* bmRequestType */
-			      startAddr,	/* value */
-			      0x0000,	 /* index */
-			      /* our local safe buffer */
-			      local_transfer_buffer,
-			      len,	/* length */
-			      EZTIMEOUT);      /* timeout */
-	if (ret < 0) {
-		dev_err(dev->class_dev, "uppload failed\n");
-		return ret;
-	}
-
-	return 0;
-}
-
 static int usbduxfastsub_submit_InURBs(struct comedi_device *dev)
 {
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
@@ -1158,7 +1074,10 @@ static int usbduxfast_attach_common(struct comedi_device *dev)
 static int usbduxfast_upload_firmware(struct comedi_device *dev,
 				      const struct firmware *fw)
 {
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
+	struct usb_device *usb = interface_to_usbdev(intf);
 	uint8_t *buf;
+	unsigned char *tmp;
 	int ret;
 
 	if (!fw->data)
@@ -1174,22 +1093,51 @@ static int usbduxfast_upload_firmware(struct comedi_device *dev,
 	if (!buf)
 		return -ENOMEM;
 
-	ret = usbduxfastsub_stop(dev);
+	/* we need a malloc'ed buffer for usb_control_msg() */
+	tmp = kmalloc(1, GFP_KERNEL);
+	if (!tmp) {
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	/* stop the current firmware on the device */
+	*tmp = 1;	/* 7f92 to one */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUXFASTSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,
+			      USBDUXFASTSUB_CPUCS, 0x0000,
+			      tmp, 1,
+			      EZTIMEOUT);
 	if (ret < 0) {
 		dev_err(dev->class_dev, "can not stop firmware\n");
 		goto done;
 	}
 
-	ret = usbduxfastsub_upload(dev, buf, 0, fw->size);
+	/* upload the new firmware to the device */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUXFASTSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,
+			      0, 0x0000,
+			      buf, fw->size,
+			      EZTIMEOUT);
 	if (ret < 0) {
 		dev_err(dev->class_dev, "firmware upload failed\n");
 		goto done;
 	}
-	ret = usbduxfastsub_start(dev);
+
+	/* start the new firmware on the device */
+	*tmp = 0;	/* 7f92 to zero */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUXFASTSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,
+			      USBDUXFASTSUB_CPUCS, 0x0000,
+			      tmp, 1,
+			      EZTIMEOUT);
 	if (ret < 0)
 		dev_err(dev->class_dev, "can not start firmware\n");
 
 done:
+	kfree(tmp);
 	kfree(buf);
 	return ret;
 }

commit dcd29f56e58ecffe68f381910a4cecbeba37594c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:40:02 2013 -0700

    staging: comedi: usbduxfast: move usbduxfast_upload_firmware()
    
    For aesthetic reasons, move usbduxfast_upload_firmware() near its
    only caller, usbduxfast_request_firmware().
    
    Also, move the #define for the maximum firmware size so it's with
    the other firmware defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 6e13f203ae66..1c07ab3e1569 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -56,6 +56,7 @@
  * constants for "firmware" upload and download
  */
 #define FIRMWARE		"usbduxfast_firmware.bin"
+#define FIRMWARE_MAX_LEN	0x2000
 #define USBDUXFASTSUB_FIRMWARE	0xA0
 #define VENDOR_DIR_IN		0xC0
 #define VENDOR_DIR_OUT		0x40
@@ -1121,7 +1122,38 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	return i;
 }
 
-#define FIRMWARE_MAX_LEN 0x2000
+static int usbduxfast_attach_common(struct comedi_device *dev)
+{
+	struct usbduxfast_private *devpriv = dev->private;
+	struct comedi_subdevice *s;
+	int ret;
+
+	down(&devpriv->sem);
+
+	ret = comedi_alloc_subdevices(dev, 1);
+	if (ret) {
+		up(&devpriv->sem);
+		return ret;
+	}
+
+	/* Analog Input subdevice */
+	s = &dev->subdevices[0];
+	dev->read_subdev = s;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
+	s->n_chan	= 16;
+	s->len_chanlist	= 16;
+	s->insn_read	= usbduxfast_ai_insn_read;
+	s->do_cmdtest	= usbduxfast_ai_cmdtest;
+	s->do_cmd	= usbduxfast_ai_cmd;
+	s->cancel	= usbduxfast_ai_cancel;
+	s->maxdata	= 0x1000;
+	s->range_table	= &range_usbduxfast_ai_range;
+
+	up(&devpriv->sem);
+
+	return 0;
+}
 
 static int usbduxfast_upload_firmware(struct comedi_device *dev,
 				      const struct firmware *fw)
@@ -1162,39 +1194,6 @@ static int usbduxfast_upload_firmware(struct comedi_device *dev,
 	return ret;
 }
 
-static int usbduxfast_attach_common(struct comedi_device *dev)
-{
-	struct usbduxfast_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
-	int ret;
-
-	down(&devpriv->sem);
-
-	ret = comedi_alloc_subdevices(dev, 1);
-	if (ret) {
-		up(&devpriv->sem);
-		return ret;
-	}
-
-	/* Analog Input subdevice */
-	s = &dev->subdevices[0];
-	dev->read_subdev = s;
-	s->type		= COMEDI_SUBD_AI;
-	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
-	s->n_chan	= 16;
-	s->len_chanlist	= 16;
-	s->insn_read	= usbduxfast_ai_insn_read;
-	s->do_cmdtest	= usbduxfast_ai_cmdtest;
-	s->do_cmd	= usbduxfast_ai_cmd;
-	s->cancel	= usbduxfast_ai_cancel;
-	s->maxdata	= 0x1000;
-	s->range_table	= &range_usbduxfast_ai_range;
-
-	up(&devpriv->sem);
-
-	return 0;
-}
-
 static int usbduxfast_request_firmware(struct comedi_device *dev)
 {
 	struct usb_interface *intf = comedi_to_usb_interface(dev);

commit 1b4997e60ed6d1f114b722051cd29718d1b8fc91
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:39:34 2013 -0700

    staging: comedi: usbduxfast: tidy up firmwareUpload()
    
    Rename the CamelCase function and just pass the const struct
    firmware * directly instead of parsing out the data and size.
    
    Rename the CamelCasae local val 'fwBuf'.
    
    Use goto to provide a common exit path that frees the local
    buffer for the firmware when an error is encountered.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 7c23b8e4eb90..6e13f203ae66 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1123,48 +1123,43 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 
 #define FIRMWARE_MAX_LEN 0x2000
 
-static int firmwareUpload(struct comedi_device *dev,
-			  const u8 *firmwareBinary, int sizeFirmware)
+static int usbduxfast_upload_firmware(struct comedi_device *dev,
+				      const struct firmware *fw)
 {
-	uint8_t *fwBuf;
+	uint8_t *buf;
 	int ret;
 
-	if (!firmwareBinary)
+	if (!fw->data)
 		return 0;
 
-	if (sizeFirmware > FIRMWARE_MAX_LEN) {
+	if (fw->size > FIRMWARE_MAX_LEN) {
 		dev_err(dev->class_dev, "firmware binary too large for FX2\n");
 		return -ENOMEM;
 	}
 
 	/* we generate a local buffer for the firmware */
-	fwBuf = kmemdup(firmwareBinary, sizeFirmware, GFP_KERNEL);
-	if (!fwBuf) {
-		dev_err(dev->class_dev, "mem alloc for firmware failed\n");
+	buf = kmemdup(fw->data, fw->size, GFP_KERNEL);
+	if (!buf)
 		return -ENOMEM;
-	}
 
 	ret = usbduxfastsub_stop(dev);
 	if (ret < 0) {
 		dev_err(dev->class_dev, "can not stop firmware\n");
-		kfree(fwBuf);
-		return ret;
+		goto done;
 	}
 
-	ret = usbduxfastsub_upload(dev, fwBuf, 0, sizeFirmware);
+	ret = usbduxfastsub_upload(dev, buf, 0, fw->size);
 	if (ret < 0) {
 		dev_err(dev->class_dev, "firmware upload failed\n");
-		kfree(fwBuf);
-		return ret;
+		goto done;
 	}
 	ret = usbduxfastsub_start(dev);
-	if (ret < 0) {
+	if (ret < 0)
 		dev_err(dev->class_dev, "can not start firmware\n");
-		kfree(fwBuf);
-		return ret;
-	}
-	kfree(fwBuf);
-	return 0;
+
+done:
+	kfree(buf);
+	return ret;
 }
 
 static int usbduxfast_attach_common(struct comedi_device *dev)
@@ -1211,7 +1206,7 @@ static int usbduxfast_request_firmware(struct comedi_device *dev)
 	if (ret)
 		return ret;
 
-	ret = firmwareUpload(dev, fw->data, fw->size);
+	ret = usbduxfast_upload_firmware(dev, fw);
 	release_firmware(fw);
 
 	return ret;

commit 060f2154d3d6f3c9daac444b482982c3ab845200
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:39:15 2013 -0700

    staging: comedi: usbduxfast: fix a > 80 char line issue
    
    Fix a line over 80 characters issue reported by checkpatch.pl.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 9120df79d703..7c23b8e4eb90 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -276,14 +276,14 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 			/* not continuous, fixed number of samples */
 			n = urb->actual_length / sizeof(uint16_t);
 			if (unlikely(devpriv->ai_sample_count < n)) {
-				/*
-				 * we have send only a fraction of the bytes
-				 * received
-				 */
+				unsigned int num_bytes;
+
+				/* partial sample received */
+				num_bytes = devpriv->ai_sample_count *
+					    sizeof(uint16_t);
 				cfc_write_array_to_buffer(s,
 							  urb->transfer_buffer,
-							  devpriv->ai_sample_count
-							  * sizeof(uint16_t));
+							  num_bytes);
 				usbduxfast_ai_stop(dev, 0);
 				/* tell comedi that the acquistion is over */
 				async->events |= COMEDI_CB_EOA;

commit ce976fdb247dc05901c59f9e36c9104293a23119
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:38:48 2013 -0700

    staging: comedi: usbduxfast: tidy up usbduxfast_ai_cancel()
    
    Remove the unnecessary comments and dev_err() noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index dd4f177a9840..9120df79d703 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -200,23 +200,16 @@ static int usbduxfast_ai_stop(struct comedi_device *dev, int do_unlink)
 	return 0;
 }
 
-/*
- * This will cancel a running acquisition operation.
- * This is called by comedi but never from inside the driver.
- */
 static int usbduxfast_ai_cancel(struct comedi_device *dev,
 				struct comedi_subdevice *s)
 {
 	struct usbduxfast_private *devpriv = dev->private;
 	int ret;
 
-	/* force unlink of all urbs */
-	if (!devpriv) {
-		dev_err(dev->class_dev, "%s: devpriv=NULL\n", __func__);
+	if (!devpriv)
 		return -EFAULT;
-	}
+
 	down(&devpriv->sem);
-	/* unlink */
 	ret = usbduxfast_ai_stop(dev, 1);
 	up(&devpriv->sem);
 

commit 32fa46b9e9efaceac3d6c009d33065da82f79732
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:38:21 2013 -0700

    staging: comedi: usbduxfast: tidy up usbduxfast_ai_stop()
    
    Remove the devpriv sanity check, all the callers have previously
    verified that its valid.
    
    Absorb usbduxfast_unlink_urbs() into this function since it's the
    only caller and the only thing it does is call usb_kill_urb().
    
    This function will always succeed so just return 0 and remove the
    local variable 'ret'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index e1c37876e3ee..dd4f177a9840 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -185,45 +185,19 @@ static int usbduxfast_send_cmd(struct comedi_device *dev, int cmd_type)
 	return ret;
 }
 
-/*
- * Stops the data acquision.
- * It should be safe to call this function from any context.
- */
-static int usbduxfast_unlink_urbs(struct comedi_device *dev)
+static int usbduxfast_ai_stop(struct comedi_device *dev, int do_unlink)
 {
 	struct usbduxfast_private *devpriv = dev->private;
 
-	if (devpriv && devpriv->urb) {
-		devpriv->ai_cmd_running = 0;
-		/* waits until a running transfer is over */
-		usb_kill_urb(devpriv->urb);
-	}
-	return 0;
-}
-
-/*
- * This will stop a running acquisition operation.
- * Is called from within this driver from both the
- * interrupt context and from comedi.
- */
-static int usbduxfast_ai_stop(struct comedi_device *dev,
-			      int do_unlink)
-{
-	struct usbduxfast_private *devpriv = dev->private;
-	int ret = 0;
-
-	if (!devpriv) {
-		pr_err("%s: devpriv=NULL!\n", __func__);
-		return -EFAULT;
-	}
-
+	/* stop aquistion */
 	devpriv->ai_cmd_running = 0;
 
-	if (do_unlink)
-		/* stop aquistion */
-		ret = usbduxfast_unlink_urbs(dev);
+	if (do_unlink && devpriv->urb) {
+		/* kill the running transfer */
+		usb_kill_urb(devpriv->urb);
+	}
 
-	return ret;
+	return 0;
 }
 
 /*

commit cb8c0034781388e5213d766b7509b2330f57e652
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:38:00 2013 -0700

    staging: comedi: usbduxfast: tidy up usbduxfastsub_unlink_InURBs()
    
    Rename this function so it has namespace associated with the driver.
    
    Remove the local variables 'j' and 'ret'. They are not used and the
    function always returns '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index dd7c53f2fd38..e1c37876e3ee 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -189,19 +189,16 @@ static int usbduxfast_send_cmd(struct comedi_device *dev, int cmd_type)
  * Stops the data acquision.
  * It should be safe to call this function from any context.
  */
-static int usbduxfastsub_unlink_InURBs(struct comedi_device *dev)
+static int usbduxfast_unlink_urbs(struct comedi_device *dev)
 {
 	struct usbduxfast_private *devpriv = dev->private;
-	int j = 0;
-	int err = 0;
 
 	if (devpriv && devpriv->urb) {
 		devpriv->ai_cmd_running = 0;
 		/* waits until a running transfer is over */
 		usb_kill_urb(devpriv->urb);
-		j = 0;
 	}
-	return err;
+	return 0;
 }
 
 /*
@@ -224,7 +221,7 @@ static int usbduxfast_ai_stop(struct comedi_device *dev,
 
 	if (do_unlink)
 		/* stop aquistion */
-		ret = usbduxfastsub_unlink_InURBs(dev);
+		ret = usbduxfast_unlink_urbs(dev);
 
 	return ret;
 }

commit 665ff8d3e968c08ea2f6a55bd1a71ac24c8d6d39
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:37:38 2013 -0700

    staging: comedi: usbduxfast: tidy up send_dux_commands()
    
    Rename this function so it has namespace associated with the driver.
    
    For aesthetic reasons, rename the local variable 'tmp' to 'ret' as
    this is more common for checking errno values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 102b24d80d82..dd7c53f2fd38 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -165,23 +165,24 @@ struct usbduxfast_private {
 #define SENDADCOMMANDS            0
 #define SENDINITEP6               1
 
-static int send_dux_commands(struct comedi_device *dev, int cmd_type)
+static int usbduxfast_send_cmd(struct comedi_device *dev, int cmd_type)
 {
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usb_device *usb = interface_to_usbdev(intf);
 	struct usbduxfast_private *devpriv = dev->private;
-	int tmp, nsent;
+	int nsent;
+	int ret;
 
 	devpriv->duxbuf[0] = cmd_type;
 
-	tmp = usb_bulk_msg(usb, usb_sndbulkpipe(usb, CHANNELLISTEP),
+	ret = usb_bulk_msg(usb, usb_sndbulkpipe(usb, CHANNELLISTEP),
 			   devpriv->duxbuf, SIZEOFDUXBUF,
 			   &nsent, 10000);
-	if (tmp < 0)
+	if (ret < 0)
 		dev_err(dev->class_dev,
 			"could not transmit command to the usb-device, err=%d\n",
-			tmp);
-	return tmp;
+			ret);
+	return ret;
 }
 
 /*
@@ -995,7 +996,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	}
 
 	/* 0 means that the AD commands are sent */
-	result = send_dux_commands(dev, SENDADCOMMANDS);
+	result = usbduxfast_send_cmd(dev, SENDADCOMMANDS);
 	if (result < 0) {
 		up(&devpriv->sem);
 		return result;
@@ -1115,7 +1116,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	devpriv->duxbuf[LOGBASE + 0] = 0;
 
 	/* 0 means that the AD commands are sent */
-	err = send_dux_commands(dev, SENDADCOMMANDS);
+	err = usbduxfast_send_cmd(dev, SENDADCOMMANDS);
 	if (err < 0) {
 		up(&devpriv->sem);
 		return err;

commit 3056b105166ca2167a28b7733348b41a96ed58be
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:37:07 2013 -0700

    staging: comedi: usbduxfast: remove extra dev_err() messages
    
    A dev_err() message is output if send_dux_commands() fails. Remove
    the extra dev_err() messages output by the callers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 6178a5d77826..102b24d80d82 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -997,8 +997,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	/* 0 means that the AD commands are sent */
 	result = send_dux_commands(dev, SENDADCOMMANDS);
 	if (result < 0) {
-		dev_err(dev->class_dev,
-			"adc command could not be submitted, aborting\n");
 		up(&devpriv->sem);
 		return result;
 	}
@@ -1119,8 +1117,6 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	/* 0 means that the AD commands are sent */
 	err = send_dux_commands(dev, SENDADCOMMANDS);
 	if (err < 0) {
-		dev_err(dev->class_dev,
-			"adc command could not be submitted, aborting\n");
 		up(&devpriv->sem);
 		return err;
 	}

commit 5659e24a5a9b3ed611f67ddfc98f2a36d9560a18
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:36:47 2013 -0700

    staging: comedi: usbduxfast: rename 'dux_commands' in private data
    
    For aesthetic reasons, rename this variable to 'duxbuf' and also
    rename the define used for its size.
    
    This helps fix some of the > 80 char lines reported by checkpatch.pl.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index beea9a12fe38..6178a5d77826 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -108,7 +108,7 @@
 /*
  * size of the buffer for the dux commands in bytes
  */
-#define SIZEOFDUXBUFFER	256
+#define SIZEOFDUXBUF	256
 
 /*
  * number of in-URBs which receive the data: min=5
@@ -149,11 +149,11 @@ static const struct comedi_lrange range_usbduxfast_ai_range = {
  */
 struct usbduxfast_private {
 	struct urb *urb;	/* BULK-transfer handling: urb */
+	uint8_t *duxbuf;
 	int8_t *inbuf;
 	short int ai_cmd_running;	/* asynchronous command is running */
 	short int ai_continous;	/* continous acquisition */
 	long int ai_sample_count;	/* number of samples to acquire */
-	uint8_t *dux_commands;	/* commands */
 	int ignore;		/* counter which ignores the first
 				   buffers */
 	struct semaphore sem;
@@ -172,14 +172,14 @@ static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 	struct usbduxfast_private *devpriv = dev->private;
 	int tmp, nsent;
 
-	devpriv->dux_commands[0] = cmd_type;
+	devpriv->duxbuf[0] = cmd_type;
 
 	tmp = usb_bulk_msg(usb, usb_sndbulkpipe(usb, CHANNELLISTEP),
-			   devpriv->dux_commands,
-			   SIZEOFDUXBUFFER, &nsent, 10000);
+			   devpriv->duxbuf, SIZEOFDUXBUF,
+			   &nsent, 10000);
 	if (tmp < 0)
 		dev_err(dev->class_dev,
-			"could not transmit dux_commands to the usb-device, err=%d\n",
+			"could not transmit command to the usb-device, err=%d\n",
 			tmp);
 	return tmp;
 }
@@ -702,17 +702,17 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		/* we loop here until ready has been set */
 		if (cmd->start_src == TRIG_EXT) {
 			/* branch back to state 0 */
-			devpriv->dux_commands[LENBASE + 0] = 0x01;
+			devpriv->duxbuf[LENBASE + 0] = 0x01;
 			/* deceision state w/o data */
-			devpriv->dux_commands[OPBASE + 0] = 0x01;
-			devpriv->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+			devpriv->duxbuf[OPBASE + 0] = 0x01;
+			devpriv->duxbuf[OUTBASE + 0] = 0xFF & rngmask;
 			/* RDY0 = 0 */
-			devpriv->dux_commands[LOGBASE + 0] = 0x00;
+			devpriv->duxbuf[LOGBASE + 0] = 0x00;
 		} else {	/* we just proceed to state 1 */
-			devpriv->dux_commands[LENBASE + 0] = 1;
-			devpriv->dux_commands[OPBASE + 0] = 0;
-			devpriv->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
-			devpriv->dux_commands[LOGBASE + 0] = 0;
+			devpriv->duxbuf[LENBASE + 0] = 1;
+			devpriv->duxbuf[OPBASE + 0] = 0;
+			devpriv->duxbuf[OUTBASE + 0] = 0xFF & rngmask;
+			devpriv->duxbuf[LOGBASE + 0] = 0;
 		}
 
 		if (steps < MIN_SAMPLING_PERIOD) {
@@ -725,33 +725,31 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 				 */
 
 				/* branch back to state 1 */
-				devpriv->dux_commands[LENBASE + 1] = 0x89;
+				devpriv->duxbuf[LENBASE + 1] = 0x89;
 				/* deceision state with data */
-				devpriv->dux_commands[OPBASE + 1] = 0x03;
-				devpriv->dux_commands[OUTBASE + 1] =
-				    0xFF & rngmask;
+				devpriv->duxbuf[OPBASE + 1] = 0x03;
+				devpriv->duxbuf[OUTBASE + 1] = 0xFF & rngmask;
 				/* doesn't matter */
-				devpriv->dux_commands[LOGBASE + 1] = 0xFF;
+				devpriv->duxbuf[LOGBASE + 1] = 0xFF;
 			} else {
 				/*
 				 * we loop through two states: data and delay
 				 * max rate is 15MHz
 				 */
-				devpriv->dux_commands[LENBASE + 1] = steps - 1;
+				devpriv->duxbuf[LENBASE + 1] = steps - 1;
 				/* data */
-				devpriv->dux_commands[OPBASE + 1] = 0x02;
-				devpriv->dux_commands[OUTBASE + 1] =
+				devpriv->duxbuf[OPBASE + 1] = 0x02;
+				devpriv->duxbuf[OUTBASE + 1] =
 				    0xFF & rngmask;
 				/* doesn't matter */
-				devpriv->dux_commands[LOGBASE + 1] = 0;
+				devpriv->duxbuf[LOGBASE + 1] = 0;
 				/* branch back to state 1 */
-				devpriv->dux_commands[LENBASE + 2] = 0x09;
+				devpriv->duxbuf[LENBASE + 2] = 0x09;
 				/* deceision state w/o data */
-				devpriv->dux_commands[OPBASE + 2] = 0x01;
-				devpriv->dux_commands[OUTBASE + 2] =
-				    0xFF & rngmask;
+				devpriv->duxbuf[OPBASE + 2] = 0x01;
+				devpriv->duxbuf[OUTBASE + 2] = 0xFF & rngmask;
 				/* doesn't matter */
-				devpriv->dux_commands[LOGBASE + 2] = 0xFF;
+				devpriv->duxbuf[LOGBASE + 2] = 0xFF;
 			}
 		} else {
 			/*
@@ -763,26 +761,26 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			steps = steps - 1;
 
 			/* do the first part of the delay */
-			devpriv->dux_commands[LENBASE + 1] = steps / 2;
-			devpriv->dux_commands[OPBASE + 1] = 0;
-			devpriv->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
-			devpriv->dux_commands[LOGBASE + 1] = 0;
+			devpriv->duxbuf[LENBASE + 1] = steps / 2;
+			devpriv->duxbuf[OPBASE + 1] = 0;
+			devpriv->duxbuf[OUTBASE + 1] = 0xFF & rngmask;
+			devpriv->duxbuf[LOGBASE + 1] = 0;
 
 			/* and the second part */
-			devpriv->dux_commands[LENBASE + 2] = steps - steps / 2;
-			devpriv->dux_commands[OPBASE + 2] = 0;
-			devpriv->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
-			devpriv->dux_commands[LOGBASE + 2] = 0;
+			devpriv->duxbuf[LENBASE + 2] = steps - steps / 2;
+			devpriv->duxbuf[OPBASE + 2] = 0;
+			devpriv->duxbuf[OUTBASE + 2] = 0xFF & rngmask;
+			devpriv->duxbuf[LOGBASE + 2] = 0;
 
 			/* get the data and branch back */
 
 			/* branch back to state 1 */
-			devpriv->dux_commands[LENBASE + 3] = 0x09;
+			devpriv->duxbuf[LENBASE + 3] = 0x09;
 			/* deceision state w data */
-			devpriv->dux_commands[OPBASE + 3] = 0x03;
-			devpriv->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
+			devpriv->duxbuf[OPBASE + 3] = 0x03;
+			devpriv->duxbuf[OUTBASE + 3] = 0xFF & rngmask;
 			/* doesn't matter */
-			devpriv->dux_commands[LOGBASE + 3] = 0xFF;
+			devpriv->duxbuf[LOGBASE + 3] = 0xFF;
 		}
 		break;
 
@@ -797,11 +795,11 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		else
 			rngmask = 0xff;
 
-		devpriv->dux_commands[LENBASE + 0] = 1;
+		devpriv->duxbuf[LENBASE + 0] = 1;
 		/* data */
-		devpriv->dux_commands[OPBASE + 0] = 0x02;
-		devpriv->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
-		devpriv->dux_commands[LOGBASE + 0] = 0;
+		devpriv->duxbuf[OPBASE + 0] = 0x02;
+		devpriv->duxbuf[OUTBASE + 0] = 0xFF & rngmask;
+		devpriv->duxbuf[LOGBASE + 0] = 0;
 
 		/* we have 1 state with duration 1: state 0 */
 		steps_tmp = steps - 1;
@@ -812,23 +810,23 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			rngmask = 0xff;
 
 		/* do the first part of the delay */
-		devpriv->dux_commands[LENBASE + 1] = steps_tmp / 2;
-		devpriv->dux_commands[OPBASE + 1] = 0;
+		devpriv->duxbuf[LENBASE + 1] = steps_tmp / 2;
+		devpriv->duxbuf[OPBASE + 1] = 0;
 		/* count */
-		devpriv->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
-		devpriv->dux_commands[LOGBASE + 1] = 0;
+		devpriv->duxbuf[OUTBASE + 1] = 0xFE & rngmask;
+		devpriv->duxbuf[LOGBASE + 1] = 0;
 
 		/* and the second part */
-		devpriv->dux_commands[LENBASE + 2] = steps_tmp - steps_tmp / 2;
-		devpriv->dux_commands[OPBASE + 2] = 0;
-		devpriv->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
-		devpriv->dux_commands[LOGBASE + 2] = 0;
+		devpriv->duxbuf[LENBASE + 2] = steps_tmp - steps_tmp / 2;
+		devpriv->duxbuf[OPBASE + 2] = 0;
+		devpriv->duxbuf[OUTBASE + 2] = 0xFF & rngmask;
+		devpriv->duxbuf[LOGBASE + 2] = 0;
 
-		devpriv->dux_commands[LENBASE + 3] = 1;
+		devpriv->duxbuf[LENBASE + 3] = 1;
 		/* data */
-		devpriv->dux_commands[OPBASE + 3] = 0x02;
-		devpriv->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
-		devpriv->dux_commands[LOGBASE + 3] = 0;
+		devpriv->duxbuf[OPBASE + 3] = 0x02;
+		devpriv->duxbuf[OUTBASE + 3] = 0xFF & rngmask;
+		devpriv->duxbuf[LOGBASE + 3] = 0;
 
 		/*
 		 * we have 2 states with duration 1: step 6 and
@@ -842,22 +840,22 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			rngmask = 0xff;
 
 		/* do the first part of the delay */
-		devpriv->dux_commands[LENBASE + 4] = steps_tmp / 2;
-		devpriv->dux_commands[OPBASE + 4] = 0;
+		devpriv->duxbuf[LENBASE + 4] = steps_tmp / 2;
+		devpriv->duxbuf[OPBASE + 4] = 0;
 		/* reset */
-		devpriv->dux_commands[OUTBASE + 4] = (0xFF - 0x02) & rngmask;
-		devpriv->dux_commands[LOGBASE + 4] = 0;
+		devpriv->duxbuf[OUTBASE + 4] = (0xFF - 0x02) & rngmask;
+		devpriv->duxbuf[LOGBASE + 4] = 0;
 
 		/* and the second part */
-		devpriv->dux_commands[LENBASE + 5] = steps_tmp - steps_tmp / 2;
-		devpriv->dux_commands[OPBASE + 5] = 0;
-		devpriv->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
-		devpriv->dux_commands[LOGBASE + 5] = 0;
-
-		devpriv->dux_commands[LENBASE + 6] = 1;
-		devpriv->dux_commands[OPBASE + 6] = 0;
-		devpriv->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
-		devpriv->dux_commands[LOGBASE + 6] = 0;
+		devpriv->duxbuf[LENBASE + 5] = steps_tmp - steps_tmp / 2;
+		devpriv->duxbuf[OPBASE + 5] = 0;
+		devpriv->duxbuf[OUTBASE + 5] = 0xFF & rngmask;
+		devpriv->duxbuf[LOGBASE + 5] = 0;
+
+		devpriv->duxbuf[LENBASE + 6] = 1;
+		devpriv->duxbuf[OPBASE + 6] = 0;
+		devpriv->duxbuf[OUTBASE + 6] = 0xFF & rngmask;
+		devpriv->duxbuf[LOGBASE + 6] = 0;
 		break;
 
 	case 3:
@@ -873,12 +871,12 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			 * commit data to the FIFO and do the first part
 			 * of the delay
 			 */
-			devpriv->dux_commands[LENBASE + j * 2] = steps / 2;
+			devpriv->duxbuf[LENBASE + j * 2] = steps / 2;
 			/* data */
-			devpriv->dux_commands[OPBASE + j * 2] = 0x02;
+			devpriv->duxbuf[OPBASE + j * 2] = 0x02;
 			/* no change */
-			devpriv->dux_commands[OUTBASE + j * 2] = 0xFF & rngmask;
-			devpriv->dux_commands[LOGBASE + j * 2] = 0;
+			devpriv->duxbuf[OUTBASE + j * 2] = 0xFF & rngmask;
+			devpriv->duxbuf[LOGBASE + j * 2] = 0;
 
 			if (CR_RANGE(cmd->chanlist[j + 1]) > 0)
 				rngmask = 0xff - 0x04;
@@ -886,25 +884,25 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 				rngmask = 0xff;
 
 			/* do the second part of the delay */
-			devpriv->dux_commands[LENBASE + j * 2 + 1] =
+			devpriv->duxbuf[LENBASE + j * 2 + 1] =
 			    steps - steps / 2;
 			/* no data */
-			devpriv->dux_commands[OPBASE + j * 2 + 1] = 0;
+			devpriv->duxbuf[OPBASE + j * 2 + 1] = 0;
 			/* count */
-			devpriv->dux_commands[OUTBASE + j * 2 + 1] =
+			devpriv->duxbuf[OUTBASE + j * 2 + 1] =
 			    0xFE & rngmask;
-			devpriv->dux_commands[LOGBASE + j * 2 + 1] = 0;
+			devpriv->duxbuf[LOGBASE + j * 2 + 1] = 0;
 		}
 
 		/* 2 steps with duration 1: the idele step and step 6: */
 		steps_tmp = steps - 2;
 
 		/* commit data to the FIFO and do the first part of the delay */
-		devpriv->dux_commands[LENBASE + 4] = steps_tmp / 2;
+		devpriv->duxbuf[LENBASE + 4] = steps_tmp / 2;
 		/* data */
-		devpriv->dux_commands[OPBASE + 4] = 0x02;
-		devpriv->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
-		devpriv->dux_commands[LOGBASE + 4] = 0;
+		devpriv->duxbuf[OPBASE + 4] = 0x02;
+		devpriv->duxbuf[OUTBASE + 4] = 0xFF & rngmask;
+		devpriv->duxbuf[LOGBASE + 4] = 0;
 
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
@@ -912,17 +910,17 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			rngmask = 0xff;
 
 		/* do the second part of the delay */
-		devpriv->dux_commands[LENBASE + 5] = steps_tmp - steps_tmp / 2;
+		devpriv->duxbuf[LENBASE + 5] = steps_tmp - steps_tmp / 2;
 		/* no data */
-		devpriv->dux_commands[OPBASE + 5] = 0;
+		devpriv->duxbuf[OPBASE + 5] = 0;
 		/* reset */
-		devpriv->dux_commands[OUTBASE + 5] = (0xFF - 0x02) & rngmask;
-		devpriv->dux_commands[LOGBASE + 5] = 0;
+		devpriv->duxbuf[OUTBASE + 5] = (0xFF - 0x02) & rngmask;
+		devpriv->duxbuf[LOGBASE + 5] = 0;
 
-		devpriv->dux_commands[LENBASE + 6] = 1;
-		devpriv->dux_commands[OPBASE + 6] = 0;
-		devpriv->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
-		devpriv->dux_commands[LOGBASE + 6] = 0;
+		devpriv->duxbuf[LENBASE + 6] = 1;
+		devpriv->duxbuf[OPBASE + 6] = 0;
+		devpriv->duxbuf[OUTBASE + 6] = 0xFF & rngmask;
+		devpriv->duxbuf[LOGBASE + 6] = 0;
 
 	case 16:
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
@@ -936,57 +934,57 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			 */
 
 			/* branch back to state 0 */
-			devpriv->dux_commands[LENBASE + 0] = 0x01;
+			devpriv->duxbuf[LENBASE + 0] = 0x01;
 			/* deceision state w/o data */
-			devpriv->dux_commands[OPBASE + 0] = 0x01;
+			devpriv->duxbuf[OPBASE + 0] = 0x01;
 			/* reset */
-			devpriv->dux_commands[OUTBASE + 0] =
+			devpriv->duxbuf[OUTBASE + 0] =
 			    (0xFF - 0x02) & rngmask;
 			/* RDY0 = 0 */
-			devpriv->dux_commands[LOGBASE + 0] = 0x00;
+			devpriv->duxbuf[LOGBASE + 0] = 0x00;
 		} else {
 			/*
 			 * we just proceed to state 1
 			 */
 
 			/* 30us reset pulse */
-			devpriv->dux_commands[LENBASE + 0] = 255;
-			devpriv->dux_commands[OPBASE + 0] = 0;
+			devpriv->duxbuf[LENBASE + 0] = 255;
+			devpriv->duxbuf[OPBASE + 0] = 0;
 			/* reset */
-			devpriv->dux_commands[OUTBASE + 0] =
+			devpriv->duxbuf[OUTBASE + 0] =
 			    (0xFF - 0x02) & rngmask;
-			devpriv->dux_commands[LOGBASE + 0] = 0;
+			devpriv->duxbuf[LOGBASE + 0] = 0;
 		}
 
 		/* commit data to the FIFO */
-		devpriv->dux_commands[LENBASE + 1] = 1;
+		devpriv->duxbuf[LENBASE + 1] = 1;
 		/* data */
-		devpriv->dux_commands[OPBASE + 1] = 0x02;
-		devpriv->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
-		devpriv->dux_commands[LOGBASE + 1] = 0;
+		devpriv->duxbuf[OPBASE + 1] = 0x02;
+		devpriv->duxbuf[OUTBASE + 1] = 0xFF & rngmask;
+		devpriv->duxbuf[LOGBASE + 1] = 0;
 
 		/* we have 2 states with duration 1 */
 		steps = steps - 2;
 
 		/* do the first part of the delay */
-		devpriv->dux_commands[LENBASE + 2] = steps / 2;
-		devpriv->dux_commands[OPBASE + 2] = 0;
-		devpriv->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
-		devpriv->dux_commands[LOGBASE + 2] = 0;
+		devpriv->duxbuf[LENBASE + 2] = steps / 2;
+		devpriv->duxbuf[OPBASE + 2] = 0;
+		devpriv->duxbuf[OUTBASE + 2] = 0xFE & rngmask;
+		devpriv->duxbuf[LOGBASE + 2] = 0;
 
 		/* and the second part */
-		devpriv->dux_commands[LENBASE + 3] = steps - steps / 2;
-		devpriv->dux_commands[OPBASE + 3] = 0;
-		devpriv->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
-		devpriv->dux_commands[LOGBASE + 3] = 0;
+		devpriv->duxbuf[LENBASE + 3] = steps - steps / 2;
+		devpriv->duxbuf[OPBASE + 3] = 0;
+		devpriv->duxbuf[OUTBASE + 3] = 0xFF & rngmask;
+		devpriv->duxbuf[LOGBASE + 3] = 0;
 
 		/* branch back to state 1 */
-		devpriv->dux_commands[LENBASE + 4] = 0x09;
+		devpriv->duxbuf[LENBASE + 4] = 0x09;
 		/* deceision state w/o data */
-		devpriv->dux_commands[OPBASE + 4] = 0x01;
-		devpriv->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
+		devpriv->duxbuf[OPBASE + 4] = 0x01;
+		devpriv->duxbuf[OUTBASE + 4] = 0xFF & rngmask;
 		/* doesn't matter */
-		devpriv->dux_commands[LOGBASE + 4] = 0xFF;
+		devpriv->duxbuf[LOGBASE + 4] = 0xFF;
 
 		break;
 
@@ -1080,43 +1078,43 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 		rngmask = 0xff;
 
 	/* commit data to the FIFO */
-	devpriv->dux_commands[LENBASE + 0] = 1;
+	devpriv->duxbuf[LENBASE + 0] = 1;
 	/* data */
-	devpriv->dux_commands[OPBASE + 0] = 0x02;
-	devpriv->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
-	devpriv->dux_commands[LOGBASE + 0] = 0;
+	devpriv->duxbuf[OPBASE + 0] = 0x02;
+	devpriv->duxbuf[OUTBASE + 0] = 0xFF & rngmask;
+	devpriv->duxbuf[LOGBASE + 0] = 0;
 
 	/* do the first part of the delay */
-	devpriv->dux_commands[LENBASE + 1] = 12;
-	devpriv->dux_commands[OPBASE + 1] = 0;
-	devpriv->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
-	devpriv->dux_commands[LOGBASE + 1] = 0;
-
-	devpriv->dux_commands[LENBASE + 2] = 1;
-	devpriv->dux_commands[OPBASE + 2] = 0;
-	devpriv->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
-	devpriv->dux_commands[LOGBASE + 2] = 0;
-
-	devpriv->dux_commands[LENBASE + 3] = 1;
-	devpriv->dux_commands[OPBASE + 3] = 0;
-	devpriv->dux_commands[OUTBASE + 3] = 0xFE & rngmask;
-	devpriv->dux_commands[LOGBASE + 3] = 0;
-
-	devpriv->dux_commands[LENBASE + 4] = 1;
-	devpriv->dux_commands[OPBASE + 4] = 0;
-	devpriv->dux_commands[OUTBASE + 4] = 0xFE & rngmask;
-	devpriv->dux_commands[LOGBASE + 4] = 0;
+	devpriv->duxbuf[LENBASE + 1] = 12;
+	devpriv->duxbuf[OPBASE + 1] = 0;
+	devpriv->duxbuf[OUTBASE + 1] = 0xFE & rngmask;
+	devpriv->duxbuf[LOGBASE + 1] = 0;
+
+	devpriv->duxbuf[LENBASE + 2] = 1;
+	devpriv->duxbuf[OPBASE + 2] = 0;
+	devpriv->duxbuf[OUTBASE + 2] = 0xFE & rngmask;
+	devpriv->duxbuf[LOGBASE + 2] = 0;
+
+	devpriv->duxbuf[LENBASE + 3] = 1;
+	devpriv->duxbuf[OPBASE + 3] = 0;
+	devpriv->duxbuf[OUTBASE + 3] = 0xFE & rngmask;
+	devpriv->duxbuf[LOGBASE + 3] = 0;
+
+	devpriv->duxbuf[LENBASE + 4] = 1;
+	devpriv->duxbuf[OPBASE + 4] = 0;
+	devpriv->duxbuf[OUTBASE + 4] = 0xFE & rngmask;
+	devpriv->duxbuf[LOGBASE + 4] = 0;
 
 	/* second part */
-	devpriv->dux_commands[LENBASE + 5] = 12;
-	devpriv->dux_commands[OPBASE + 5] = 0;
-	devpriv->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
-	devpriv->dux_commands[LOGBASE + 5] = 0;
+	devpriv->duxbuf[LENBASE + 5] = 12;
+	devpriv->duxbuf[OPBASE + 5] = 0;
+	devpriv->duxbuf[OUTBASE + 5] = 0xFF & rngmask;
+	devpriv->duxbuf[LOGBASE + 5] = 0;
 
-	devpriv->dux_commands[LENBASE + 6] = 1;
-	devpriv->dux_commands[OPBASE + 6] = 0;
-	devpriv->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
-	devpriv->dux_commands[LOGBASE + 0] = 0;
+	devpriv->duxbuf[LENBASE + 6] = 1;
+	devpriv->duxbuf[OPBASE + 6] = 0;
+	devpriv->duxbuf[OUTBASE + 6] = 0xFF & rngmask;
+	devpriv->duxbuf[LOGBASE + 0] = 0;
 
 	/* 0 means that the AD commands are sent */
 	err = send_dux_commands(dev, SENDADCOMMANDS);
@@ -1280,8 +1278,8 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	sema_init(&devpriv->sem, 1);
 	usb_set_intfdata(intf, devpriv);
 
-	devpriv->dux_commands = kmalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
-	if (!devpriv->dux_commands)
+	devpriv->duxbuf = kmalloc(SIZEOFDUXBUF, GFP_KERNEL);
+	if (!devpriv->duxbuf)
 		return -ENOMEM;
 
 	ret = usb_set_interface(usb,
@@ -1339,8 +1337,8 @@ static void usbduxfast_detach(struct comedi_device *dev)
 		devpriv->urb = NULL;
 	}
 
-	kfree(devpriv->dux_commands);
-	devpriv->dux_commands = NULL;
+	kfree(devpriv->duxbuf);
+	devpriv->duxbuf = NULL;
 
 	devpriv->ai_cmd_running = 0;
 

commit ef8e0840f33ea460c74530a28bd8296e64a34075
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:36:23 2013 -0700

    staging: comedi: usbduxfast: rename 'transfer_buffer' in private data
    
    For aesthetic reasons, rename this variable to 'inbuf' to match the
    define used for its size (SIZEINBUF).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index f12958840909..beea9a12fe38 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -149,7 +149,7 @@ static const struct comedi_lrange range_usbduxfast_ai_range = {
  */
 struct usbduxfast_private {
 	struct urb *urb;	/* BULK-transfer handling: urb */
-	int8_t *transfer_buffer;
+	int8_t *inbuf;
 	short int ai_cmd_running;	/* asynchronous command is running */
 	short int ai_continous;	/* continous acquisition */
 	long int ai_sample_count;	/* number of samples to acquire */
@@ -455,7 +455,7 @@ static int usbduxfastsub_submit_InURBs(struct comedi_device *dev)
 		return -EFAULT;
 
 	usb_fill_bulk_urb(devpriv->urb, usb, usb_rcvbulkpipe(usb, BULKINEP),
-			  devpriv->transfer_buffer, SIZEINBUF,
+			  devpriv->inbuf, SIZEINBUF,
 			  usbduxfast_ai_interrupt, dev);
 
 	ret = usb_submit_urb(devpriv->urb, GFP_ATOMIC);
@@ -1129,7 +1129,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 
 	for (i = 0; i < PACKETS_TO_IGNORE; i++) {
 		err = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),
-				   devpriv->transfer_buffer, SIZEINBUF,
+				   devpriv->inbuf, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
 			dev_err(dev->class_dev, "insn timeout, no data\n");
@@ -1140,7 +1140,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	/* data points */
 	for (i = 0; i < insn->n;) {
 		err = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),
-				   devpriv->transfer_buffer, SIZEINBUF,
+				   devpriv->inbuf, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
 			dev_err(dev->class_dev, "insn data error: %d\n", err);
@@ -1154,7 +1154,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 			return -EINVAL;
 		}
 		for (j = chan; (j < n) && (i < insn->n); j = j + 16) {
-			data[i] = ((uint16_t *) (devpriv->transfer_buffer))[j];
+			data[i] = ((uint16_t *) (devpriv->inbuf))[j];
 			i++;
 		}
 	}
@@ -1298,8 +1298,8 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	}
 
-	devpriv->transfer_buffer = kmalloc(SIZEINBUF, GFP_KERNEL);
-	if (!devpriv->transfer_buffer)
+	devpriv->inbuf = kmalloc(SIZEINBUF, GFP_KERNEL);
+	if (!devpriv->inbuf)
 		return -ENOMEM;
 
 	/*
@@ -1332,8 +1332,8 @@ static void usbduxfast_detach(struct comedi_device *dev)
 		/* waits until a running transfer is over */
 		usb_kill_urb(devpriv->urb);
 
-		kfree(devpriv->transfer_buffer);
-		devpriv->transfer_buffer = NULL;
+		kfree(devpriv->inbuf);
+		devpriv->inbuf = NULL;
 
 		usb_free_urb(devpriv->urb);
 		devpriv->urb = NULL;

commit 5ee182a3c3ed76a2aa44cc088988db184c36c869
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:36:02 2013 -0700

    staging: comedi: usbduxfast: rename 'insnBuffer' from private data
    
    This buffer space is kmalloc'ed and free'ed but never used. Just
    remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 2a75f88d65ff..f12958840909 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -150,7 +150,6 @@ static const struct comedi_lrange range_usbduxfast_ai_range = {
 struct usbduxfast_private {
 	struct urb *urb;	/* BULK-transfer handling: urb */
 	int8_t *transfer_buffer;
-	int16_t *insnBuffer;	/* input buffer for single insn */
 	short int ai_cmd_running;	/* asynchronous command is running */
 	short int ai_continous;	/* continous acquisition */
 	long int ai_sample_count;	/* number of samples to acquire */
@@ -1285,10 +1284,6 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	if (!devpriv->dux_commands)
 		return -ENOMEM;
 
-	devpriv->insnBuffer = kmalloc(SIZEINSNBUF, GFP_KERNEL);
-	if (!devpriv->insnBuffer)
-		return -ENOMEM;
-
 	ret = usb_set_interface(usb,
 				intf->altsetting->desc.bInterfaceNumber, 1);
 	if (ret < 0) {
@@ -1344,9 +1339,6 @@ static void usbduxfast_detach(struct comedi_device *dev)
 		devpriv->urb = NULL;
 	}
 
-	kfree(devpriv->insnBuffer);
-	devpriv->insnBuffer = NULL;
-
 	kfree(devpriv->dux_commands);
 	devpriv->dux_commands = NULL;
 

commit da58c2633a259acad25c741502f780780d177ba5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:35:40 2013 -0700

    staging: comedi: usbduxfast: rename 'urbIn' in private data
    
    Rename the CamelCase variable 'urbIn' in the private data to
    simply 'urb'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index a365d6ae4e92..2a75f88d65ff 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -148,7 +148,7 @@ static const struct comedi_lrange range_usbduxfast_ai_range = {
  * one sub device just now: A/D
  */
 struct usbduxfast_private {
-	struct urb *urbIn;	/* BULK-transfer handling: urb */
+	struct urb *urb;	/* BULK-transfer handling: urb */
 	int8_t *transfer_buffer;
 	int16_t *insnBuffer;	/* input buffer for single insn */
 	short int ai_cmd_running;	/* asynchronous command is running */
@@ -195,10 +195,10 @@ static int usbduxfastsub_unlink_InURBs(struct comedi_device *dev)
 	int j = 0;
 	int err = 0;
 
-	if (devpriv && devpriv->urbIn) {
+	if (devpriv && devpriv->urb) {
 		devpriv->ai_cmd_running = 0;
 		/* waits until a running transfer is over */
-		usb_kill_urb(devpriv->urbIn);
+		usb_kill_urb(devpriv->urb);
 		j = 0;
 	}
 	return err;
@@ -455,11 +455,11 @@ static int usbduxfastsub_submit_InURBs(struct comedi_device *dev)
 	if (!devpriv)
 		return -EFAULT;
 
-	usb_fill_bulk_urb(devpriv->urbIn, usb, usb_rcvbulkpipe(usb, BULKINEP),
+	usb_fill_bulk_urb(devpriv->urb, usb, usb_rcvbulkpipe(usb, BULKINEP),
 			  devpriv->transfer_buffer, SIZEINBUF,
 			  usbduxfast_ai_interrupt, dev);
 
-	ret = usb_submit_urb(devpriv->urbIn, GFP_ATOMIC);
+	ret = usb_submit_urb(devpriv->urb, GFP_ATOMIC);
 	if (ret) {
 		dev_err(dev->class_dev, "usb_submit_urb error %d\n", ret);
 		return ret;
@@ -1297,8 +1297,8 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 		return -ENODEV;
 	}
 
-	devpriv->urbIn = usb_alloc_urb(0, GFP_KERNEL);
-	if (!devpriv->urbIn) {
+	devpriv->urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!devpriv->urb) {
 		dev_err(dev->class_dev, "Could not alloc. urb\n");
 		return -ENOMEM;
 	}
@@ -1333,15 +1333,15 @@ static void usbduxfast_detach(struct comedi_device *dev)
 
 	usb_set_intfdata(intf, NULL);
 
-	if (devpriv->urbIn) {
+	if (devpriv->urb) {
 		/* waits until a running transfer is over */
-		usb_kill_urb(devpriv->urbIn);
+		usb_kill_urb(devpriv->urb);
 
 		kfree(devpriv->transfer_buffer);
 		devpriv->transfer_buffer = NULL;
 
-		usb_free_urb(devpriv->urbIn);
-		devpriv->urbIn = NULL;
+		usb_free_urb(devpriv->urb);
+		devpriv->urb = NULL;
 	}
 
 	kfree(devpriv->insnBuffer);

commit a4f2e0f9d1d7abc279ec60e2f15322e3b6d21051
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:35:15 2013 -0700

    staging: comedi: usbduxfast: remove 'usb' from the private data
    
    The usb_device pointer can be fetched when needed from the comedi_device
    by using comedi_to_usb_interface() then interface_to_usbdev().
    
    Do that instead and remove the pointer from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index e8dab2fe0705..a365d6ae4e92 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -148,7 +148,6 @@ static const struct comedi_lrange range_usbduxfast_ai_range = {
  * one sub device just now: A/D
  */
 struct usbduxfast_private {
-	struct usb_device *usb;	/* pointer to the usb-device */
 	struct urb *urbIn;	/* BULK-transfer handling: urb */
 	int8_t *transfer_buffer;
 	int16_t *insnBuffer;	/* input buffer for single insn */
@@ -169,13 +168,14 @@ struct usbduxfast_private {
 
 static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 {
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
+	struct usb_device *usb = interface_to_usbdev(intf);
 	struct usbduxfast_private *devpriv = dev->private;
 	int tmp, nsent;
 
 	devpriv->dux_commands[0] = cmd_type;
 
-	tmp = usb_bulk_msg(devpriv->usb,
-			   usb_sndbulkpipe(devpriv->usb, CHANNELLISTEP),
+	tmp = usb_bulk_msg(usb, usb_sndbulkpipe(usb, CHANNELLISTEP),
 			   devpriv->dux_commands,
 			   SIZEOFDUXBUFFER, &nsent, 10000);
 	if (tmp < 0)
@@ -261,6 +261,8 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 	struct comedi_device *dev = urb->context;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
+	struct usb_device *usb = interface_to_usbdev(intf);
 	struct usbduxfast_private *devpriv = dev->private;
 	int n, err;
 
@@ -346,7 +348,7 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 	 * command is still running
 	 * resubmit urb for BULK transfer
 	 */
-	urb->dev = devpriv->usb;
+	urb->dev = usb;
 	urb->status = 0;
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
@@ -361,7 +363,8 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 
 static int usbduxfastsub_start(struct comedi_device *dev)
 {
-	struct usbduxfast_private *devpriv = dev->private;
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
+	struct usb_device *usb = interface_to_usbdev(intf);
 	unsigned char *local_transfer_buffer;
 	int ret;
 
@@ -372,7 +375,7 @@ static int usbduxfastsub_start(struct comedi_device *dev)
 	/* 7f92 to zero */
 	*local_transfer_buffer = 0;
 	/* bRequest, "Firmware" */
-	ret = usb_control_msg(devpriv->usb, usb_sndctrlpipe(devpriv->usb, 0),
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
 			      USBDUXFASTSUB_FIRMWARE,
 			      VENDOR_DIR_OUT,	  /* bmRequestType */
 			      USBDUXFASTSUB_CPUCS,    /* Value */
@@ -390,7 +393,8 @@ static int usbduxfastsub_start(struct comedi_device *dev)
 
 static int usbduxfastsub_stop(struct comedi_device *dev)
 {
-	struct usbduxfast_private *devpriv = dev->private;
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
+	struct usb_device *usb = interface_to_usbdev(intf);
 	unsigned char *local_transfer_buffer;
 	int ret;
 
@@ -401,7 +405,7 @@ static int usbduxfastsub_stop(struct comedi_device *dev)
 	/* 7f92 to one */
 	*local_transfer_buffer = 1;
 	/* bRequest, "Firmware" */
-	ret = usb_control_msg(devpriv->usb, usb_sndctrlpipe(devpriv->usb, 0),
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
 			      USBDUXFASTSUB_FIRMWARE,
 			      VENDOR_DIR_OUT,	/* bmRequestType */
 			      USBDUXFASTSUB_CPUCS,	/* Value */
@@ -419,11 +423,12 @@ static int usbduxfastsub_upload(struct comedi_device *dev,
 				unsigned char *local_transfer_buffer,
 				unsigned int startAddr, unsigned int len)
 {
-	struct usbduxfast_private *devpriv = dev->private;
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
+	struct usb_device *usb = interface_to_usbdev(intf);
 	int ret;
 
 	/* brequest, firmware */
-	ret = usb_control_msg(devpriv->usb, usb_sndctrlpipe(devpriv->usb, 0),
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
 			      USBDUXFASTSUB_FIRMWARE,
 			      VENDOR_DIR_OUT,	/* bmRequestType */
 			      startAddr,	/* value */
@@ -442,14 +447,15 @@ static int usbduxfastsub_upload(struct comedi_device *dev,
 
 static int usbduxfastsub_submit_InURBs(struct comedi_device *dev)
 {
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
+	struct usb_device *usb = interface_to_usbdev(intf);
 	struct usbduxfast_private *devpriv = dev->private;
 	int ret;
 
 	if (!devpriv)
 		return -EFAULT;
 
-	usb_fill_bulk_urb(devpriv->urbIn, devpriv->usb,
-			  usb_rcvbulkpipe(devpriv->usb, BULKINEP),
+	usb_fill_bulk_urb(devpriv->urbIn, usb, usb_rcvbulkpipe(usb, BULKINEP),
 			  devpriv->transfer_buffer, SIZEINBUF,
 			  usbduxfast_ai_interrupt, dev);
 
@@ -1045,6 +1051,8 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data)
 {
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
+	struct usb_device *usb = interface_to_usbdev(intf);
 	struct usbduxfast_private *devpriv = dev->private;
 	int i, j, n, actual_length;
 	int chan, range, rngmask;
@@ -1121,8 +1129,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	}
 
 	for (i = 0; i < PACKETS_TO_IGNORE; i++) {
-		err = usb_bulk_msg(devpriv->usb,
-				   usb_rcvbulkpipe(devpriv->usb, BULKINEP),
+		err = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),
 				   devpriv->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
@@ -1133,8 +1140,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	}
 	/* data points */
 	for (i = 0; i < insn->n;) {
-		err = usb_bulk_msg(devpriv->usb,
-				   usb_rcvbulkpipe(devpriv->usb, BULKINEP),
+		err = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),
 				   devpriv->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
@@ -1273,7 +1279,6 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	dev->private = devpriv;
 
 	sema_init(&devpriv->sem, 1);
-	devpriv->usb = usb;
 	usb_set_intfdata(intf, devpriv);
 
 	devpriv->dux_commands = kmalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
@@ -1284,7 +1289,7 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	if (!devpriv->insnBuffer)
 		return -ENOMEM;
 
-	ret = usb_set_interface(devpriv->usb,
+	ret = usb_set_interface(usb,
 				intf->altsetting->desc.bInterfaceNumber, 1);
 	if (ret < 0) {
 		dev_err(dev->class_dev,

commit a71a65b1d68c145a914cdc05d6f85372a58e71df
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:34:54 2013 -0700

    staging: comedi: usbduxfast: remove 'intf' from the private data
    
    The usb_interface pointer is already saved in the comedi_device
    by the comedi core.
    
    Remove the pointer from the private data and use comedi_to_usb_interface()
    to get the usb_interface when needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index c87cc5ac1342..e8dab2fe0705 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -152,7 +152,6 @@ struct usbduxfast_private {
 	struct urb *urbIn;	/* BULK-transfer handling: urb */
 	int8_t *transfer_buffer;
 	int16_t *insnBuffer;	/* input buffer for single insn */
-	struct usb_interface *intf;	/* interface structure */
 	short int ai_cmd_running;	/* asynchronous command is running */
 	short int ai_continous;	/* continous acquisition */
 	long int ai_sample_count;	/* number of samples to acquire */
@@ -1239,8 +1238,7 @@ static int usbduxfast_attach_common(struct comedi_device *dev)
 
 static int usbduxfast_request_firmware(struct comedi_device *dev)
 {
-	struct usbduxfast_private *devpriv = dev->private;
-	struct usb_interface *intf = devpriv->intf;
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usb_device *usb = interface_to_usbdev(intf);
 	const struct firmware *fw;
 	int ret;
@@ -1276,7 +1274,6 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 
 	sema_init(&devpriv->sem, 1);
 	devpriv->usb = usb;
-	devpriv->intf = intf;
 	usb_set_intfdata(intf, devpriv);
 
 	devpriv->dux_commands = kmalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
@@ -1321,6 +1318,7 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 
 static void usbduxfast_detach(struct comedi_device *dev)
 {
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usbduxfast_private *devpriv = dev->private;
 
 	if (!devpriv)
@@ -1328,8 +1326,7 @@ static void usbduxfast_detach(struct comedi_device *dev)
 
 	down(&devpriv->sem);
 
-	if (devpriv->intf)
-		usb_set_intfdata(devpriv->intf, NULL);
+	usb_set_intfdata(intf, NULL);
 
 	if (devpriv->urbIn) {
 		/* waits until a running transfer is over */

commit 106af99778b583f2f3912d7fd389be1569dadf71
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:34:31 2013 -0700

    staging: comedi: usbduxfast: use dev->class_dev for all dev_{level} messages
    
    For consistency in the driver, change all the dev_{level} messages
    so they use dev->class_dev for the device.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index f645956c7a53..c87cc5ac1342 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -180,7 +180,7 @@ static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 			   devpriv->dux_commands,
 			   SIZEOFDUXBUFFER, &nsent, 10000);
 	if (tmp < 0)
-		dev_err(&devpriv->intf->dev,
+		dev_err(dev->class_dev,
 			"could not transmit dux_commands to the usb-device, err=%d\n",
 			tmp);
 	return tmp;
@@ -351,7 +351,7 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 	urb->status = 0;
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		dev_err(&urb->dev->dev,
+		dev_err(dev->class_dev,
 			"urb resubm failed: %d", err);
 		async->events |= COMEDI_CB_EOA;
 		async->events |= COMEDI_CB_ERROR;
@@ -383,8 +383,7 @@ static int usbduxfastsub_start(struct comedi_device *dev)
 			      1,      /* Length */
 			      EZTIMEOUT);    /* Timeout */
 	if (ret < 0)
-		dev_err(&devpriv->intf->dev,
-			"control msg failed (start)\n");
+		dev_err(dev->class_dev, "control msg failed (start)\n");
 
 	kfree(local_transfer_buffer);
 	return ret;
@@ -411,8 +410,7 @@ static int usbduxfastsub_stop(struct comedi_device *dev)
 			      local_transfer_buffer, 1,	/* Length */
 			      EZTIMEOUT);	/* Timeout */
 	if (ret < 0)
-		dev_err(&devpriv->intf->dev,
-			"control msg failed (stop)\n");
+		dev_err(dev->class_dev, "control msg failed (stop)\n");
 
 	kfree(local_transfer_buffer);
 	return ret;
@@ -436,7 +434,7 @@ static int usbduxfastsub_upload(struct comedi_device *dev,
 			      len,	/* length */
 			      EZTIMEOUT);      /* timeout */
 	if (ret < 0) {
-		dev_err(&devpriv->intf->dev, "uppload failed\n");
+		dev_err(dev->class_dev, "uppload failed\n");
 		return ret;
 	}
 
@@ -458,8 +456,7 @@ static int usbduxfastsub_submit_InURBs(struct comedi_device *dev)
 
 	ret = usb_submit_urb(devpriv->urbIn, GFP_ATOMIC);
 	if (ret) {
-		dev_err(&devpriv->intf->dev,
-			"ai: usb_submit_urb error %d\n", ret);
+		dev_err(dev->class_dev, "usb_submit_urb error %d\n", ret);
 		return ret;
 	}
 	return 0;
@@ -571,7 +568,7 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 	down(&devpriv->sem);
 
 	if (trignum != 0) {
-		dev_err(dev->class_dev, "%s: invalid trignum\n", __func__);
+		dev_err(dev->class_dev, "invalid trignum\n");
 		up(&devpriv->sem);
 		return -EINVAL;
 	}
@@ -579,16 +576,14 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 		devpriv->ai_cmd_running = 1;
 		ret = usbduxfastsub_submit_InURBs(dev);
 		if (ret < 0) {
-			dev_err(dev->class_dev,
-				"%s: urbSubmit: err=%d\n", __func__, ret);
+			dev_err(dev->class_dev, "urbSubmit: err=%d\n", ret);
 			devpriv->ai_cmd_running = 0;
 			up(&devpriv->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	} else {
-		dev_err(dev->class_dev,
-			"ai_inttrig but acqu is already running\n");
+		dev_err(dev->class_dev, "ai is already running\n");
 	}
 	up(&devpriv->sem);
 	return 1;
@@ -618,8 +613,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 	if (devpriv->ai_cmd_running) {
-		dev_err(dev->class_dev,
-			"ai_cmd not possible. Another ai_cmd is running.\n");
+		dev_err(dev->class_dev, "ai_cmd not possible\n");
 		up(&devpriv->sem);
 		return -EBUSY;
 	}
@@ -638,20 +632,19 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			chan = CR_CHAN(cmd->chanlist[i]);
 			if (chan != i) {
 				dev_err(dev->class_dev,
-					"cmd is accepting only consecutive channels.\n");
+					"channels are not consecutive\n");
 				up(&devpriv->sem);
 				return -EINVAL;
 			}
 			if ((gain != CR_RANGE(cmd->chanlist[i]))
 			    && (cmd->chanlist_len > 3)) {
 				dev_err(dev->class_dev,
-					"the gain must be the same for all channels.\n");
+					"gain must be the same for all channels\n");
 				up(&devpriv->sem);
 				return -EINVAL;
 			}
 			if (i >= NUMCHANNELS) {
-				dev_err(dev->class_dev,
-					"channel list too long\n");
+				dev_err(dev->class_dev, "chanlist too long\n");
 				break;
 			}
 		}
@@ -659,7 +652,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	steps = 0;
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		dev_err(dev->class_dev,
-			"scan_begin_src==TRIG_TIMER not valid.\n");
+			"scan_begin_src==TRIG_TIMER not valid\n");
 		up(&devpriv->sem);
 		return -EINVAL;
 	}
@@ -668,20 +661,20 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 
 	if ((steps < MIN_SAMPLING_PERIOD) && (cmd->chanlist_len != 1)) {
 		dev_err(dev->class_dev,
-			"ai_cmd: steps=%ld, scan_begin_arg=%d. Not properly tested by cmdtest?\n",
+			"steps=%ld, scan_begin_arg=%d. Not properly tested by cmdtest?\n",
 			steps, cmd->scan_begin_arg);
 		up(&devpriv->sem);
 		return -EINVAL;
 	}
 	if (steps > MAX_SAMPLING_PERIOD) {
-		dev_err(dev->class_dev, "ai_cmd: sampling rate too low.\n");
+		dev_err(dev->class_dev, "sampling rate too low\n");
 		up(&devpriv->sem);
 		return -EINVAL;
 	}
 	if ((cmd->start_src == TRIG_EXT) && (cmd->chanlist_len != 1)
 	    && (cmd->chanlist_len != 16)) {
 		dev_err(dev->class_dev,
-			"ai_cmd: TRIG_EXT only with 1 or 16 channels possible.\n");
+			"TRIG_EXT only with 1 or 16 channels possible\n");
 		up(&devpriv->sem);
 		return -EINVAL;
 	}
@@ -1003,7 +996,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	result = send_dux_commands(dev, SENDADCOMMANDS);
 	if (result < 0) {
 		dev_err(dev->class_dev,
-			"adc command could not be submitted. Aborting...\n");
+			"adc command could not be submitted, aborting\n");
 		up(&devpriv->sem);
 		return result;
 	}
@@ -1011,7 +1004,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		devpriv->ai_sample_count = cmd->stop_arg * cmd->scan_end_arg;
 		if (devpriv->ai_sample_count < 1) {
 			dev_err(dev->class_dev,
-				"(cmd->stop_arg)*(cmd->scan_end_arg)<1, aborting.\n");
+				"(cmd->stop_arg)*(cmd->scan_end_arg)<1, aborting\n");
 			up(&devpriv->sem);
 			return -EFAULT;
 		}
@@ -1059,14 +1052,14 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	int err;
 
 	if (!devpriv) {
-		dev_err(dev->class_dev, "%s: no usb dev.\n", __func__);
+		dev_err(dev->class_dev, "no usb dev\n");
 		return -ENODEV;
 	}
 
 	down(&devpriv->sem);
 	if (devpriv->ai_cmd_running) {
 		dev_err(dev->class_dev,
-			"ai_insn_read not possible. Async Command is running.\n");
+			"ai_insn_read not possible, async cmd is running\n");
 		up(&devpriv->sem);
 		return -EBUSY;
 	}
@@ -1123,7 +1116,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	err = send_dux_commands(dev, SENDADCOMMANDS);
 	if (err < 0) {
 		dev_err(dev->class_dev,
-			"adc command could not be submitted. Aborting...\n");
+			"adc command could not be submitted, aborting\n");
 		up(&devpriv->sem);
 		return err;
 	}
@@ -1134,7 +1127,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 				   devpriv->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
-			dev_err(dev->class_dev, "insn timeout. No data.\n");
+			dev_err(dev->class_dev, "insn timeout, no data\n");
 			up(&devpriv->sem);
 			return err;
 		}
@@ -1152,7 +1145,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 		}
 		n = actual_length / sizeof(uint16_t);
 		if ((n % 16) != 0) {
-			dev_err(dev->class_dev, "insn data packet corrupted.\n");
+			dev_err(dev->class_dev, "insn data packet corrupted\n");
 			up(&devpriv->sem);
 			return -EINVAL;
 		}
@@ -1170,46 +1163,40 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 static int firmwareUpload(struct comedi_device *dev,
 			  const u8 *firmwareBinary, int sizeFirmware)
 {
-	struct usbduxfast_private *devpriv = dev->private;
-	int ret;
 	uint8_t *fwBuf;
+	int ret;
 
 	if (!firmwareBinary)
 		return 0;
 
 	if (sizeFirmware > FIRMWARE_MAX_LEN) {
-		dev_err(&devpriv->intf->dev,
-			"comedi_: usbduxfast firmware binary it too large for FX2.\n");
+		dev_err(dev->class_dev, "firmware binary too large for FX2\n");
 		return -ENOMEM;
 	}
 
 	/* we generate a local buffer for the firmware */
 	fwBuf = kmemdup(firmwareBinary, sizeFirmware, GFP_KERNEL);
 	if (!fwBuf) {
-		dev_err(&devpriv->intf->dev,
-			"comedi_: mem alloc for firmware failed\n");
+		dev_err(dev->class_dev, "mem alloc for firmware failed\n");
 		return -ENOMEM;
 	}
 
 	ret = usbduxfastsub_stop(dev);
 	if (ret < 0) {
-		dev_err(&devpriv->intf->dev,
-			"comedi_: can not stop firmware\n");
+		dev_err(dev->class_dev, "can not stop firmware\n");
 		kfree(fwBuf);
 		return ret;
 	}
 
 	ret = usbduxfastsub_upload(dev, fwBuf, 0, sizeFirmware);
 	if (ret < 0) {
-		dev_err(&devpriv->intf->dev,
-			"comedi_: firmware upload failed\n");
+		dev_err(dev->class_dev, "firmware upload failed\n");
 		kfree(fwBuf);
 		return ret;
 	}
 	ret = usbduxfastsub_start(dev);
 	if (ret < 0) {
-		dev_err(&devpriv->intf->dev,
-			"comedi_: can not start firmware\n");
+		dev_err(dev->class_dev, "can not start firmware\n");
 		kfree(fwBuf);
 		return ret;
 	}
@@ -1277,7 +1264,7 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	int ret;
 
 	if (usb->speed != USB_SPEED_HIGH) {
-		dev_err(&intf->dev,
+		dev_err(dev->class_dev,
 			"This driver needs USB 2.0 to operate. Aborting...\n");
 		return -ENODEV;
 	}
@@ -1303,14 +1290,14 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	ret = usb_set_interface(devpriv->usb,
 				intf->altsetting->desc.bInterfaceNumber, 1);
 	if (ret < 0) {
-		dev_err(&intf->dev,
+		dev_err(dev->class_dev,
 			"could not switch to alternate setting 1\n");
 		return -ENODEV;
 	}
 
 	devpriv->urbIn = usb_alloc_urb(0, GFP_KERNEL);
 	if (!devpriv->urbIn) {
-		dev_err(&intf->dev, "Could not alloc. urb\n");
+		dev_err(dev->class_dev, "Could not alloc. urb\n");
 		return -ENOMEM;
 	}
 
@@ -1324,7 +1311,8 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	 */
 	ret = usbduxfast_request_firmware(dev);
 	if (ret) {
-		dev_err(&intf->dev, "could not load firmware (err=%d)\n", ret);
+		dev_err(dev->class_dev, "could not load firmware (err=%d)\n",
+			ret);
 		return ret;
 	}
 

commit 14bcafeeb4814182e6f0684e12eb5ebf935c9694
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:33:34 2013 -0700

    staging: comedi: usbduxfast: remove 'comedidev' from the private data
    
    Now that the comedi_device is passed to the internal functions, the
    back pointer to it is not needed in the private data. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index a83526cf12cc..f645956c7a53 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -153,8 +153,6 @@ struct usbduxfast_private {
 	int8_t *transfer_buffer;
 	int16_t *insnBuffer;	/* input buffer for single insn */
 	struct usb_interface *intf;	/* interface structure */
-	/* comedi device for the interrupt context */
-	struct comedi_device *comedidev;
 	short int ai_cmd_running;	/* asynchronous command is running */
 	short int ai_continous;	/* continous acquisition */
 	long int ai_sample_count;	/* number of samples to acquire */
@@ -1290,7 +1288,6 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	dev->private = devpriv;
 
 	sema_init(&devpriv->sem, 1);
-	devpriv->comedidev = dev;
 	devpriv->usb = usb;
 	devpriv->intf = intf;
 	usb_set_intfdata(intf, devpriv);
@@ -1343,8 +1340,6 @@ static void usbduxfast_detach(struct comedi_device *dev)
 
 	down(&devpriv->sem);
 
-	devpriv->comedidev = NULL;
-
 	if (devpriv->intf)
 		usb_set_intfdata(devpriv->intf, NULL);
 

commit da63c39c65ae90adf527875c7a7988893d05a138
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:33:13 2013 -0700

    staging: comedi: usbduxfast: don't pass the private data directly
    
    Instead of passing the private data to the internal functions, pass
    the comedi_device pointer and get the private data from it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index b51bd97dd53b..a83526cf12cc 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -170,8 +170,9 @@ struct usbduxfast_private {
 #define SENDADCOMMANDS            0
 #define SENDINITEP6               1
 
-static int send_dux_commands(struct usbduxfast_private *devpriv, int cmd_type)
+static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 {
+	struct usbduxfast_private *devpriv = dev->private;
 	int tmp, nsent;
 
 	devpriv->dux_commands[0] = cmd_type;
@@ -191,8 +192,9 @@ static int send_dux_commands(struct usbduxfast_private *devpriv, int cmd_type)
  * Stops the data acquision.
  * It should be safe to call this function from any context.
  */
-static int usbduxfastsub_unlink_InURBs(struct usbduxfast_private *devpriv)
+static int usbduxfastsub_unlink_InURBs(struct comedi_device *dev)
 {
+	struct usbduxfast_private *devpriv = dev->private;
 	int j = 0;
 	int err = 0;
 
@@ -210,9 +212,10 @@ static int usbduxfastsub_unlink_InURBs(struct usbduxfast_private *devpriv)
  * Is called from within this driver from both the
  * interrupt context and from comedi.
  */
-static int usbduxfast_ai_stop(struct usbduxfast_private *devpriv,
+static int usbduxfast_ai_stop(struct comedi_device *dev,
 			      int do_unlink)
 {
+	struct usbduxfast_private *devpriv = dev->private;
 	int ret = 0;
 
 	if (!devpriv) {
@@ -224,7 +227,7 @@ static int usbduxfast_ai_stop(struct usbduxfast_private *devpriv,
 
 	if (do_unlink)
 		/* stop aquistion */
-		ret = usbduxfastsub_unlink_InURBs(devpriv);
+		ret = usbduxfastsub_unlink_InURBs(dev);
 
 	return ret;
 }
@@ -246,7 +249,7 @@ static int usbduxfast_ai_cancel(struct comedi_device *dev,
 	}
 	down(&devpriv->sem);
 	/* unlink */
-	ret = usbduxfast_ai_stop(devpriv, 1);
+	ret = usbduxfast_ai_stop(dev, 1);
 	up(&devpriv->sem);
 
 	return ret;
@@ -292,7 +295,7 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 		async->events |= COMEDI_CB_ERROR;
 		comedi_event(dev, s);
 		/* stop the transfer w/o unlink */
-		usbduxfast_ai_stop(devpriv, 0);
+		usbduxfast_ai_stop(dev, 0);
 		return;
 
 	default:
@@ -301,7 +304,7 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 		async->events |= COMEDI_CB_EOA;
 		async->events |= COMEDI_CB_ERROR;
 		comedi_event(dev, s);
-		usbduxfast_ai_stop(devpriv, 0);
+		usbduxfast_ai_stop(dev, 0);
 		return;
 	}
 
@@ -318,7 +321,7 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 							  urb->transfer_buffer,
 							  devpriv->ai_sample_count
 							  * sizeof(uint16_t));
-				usbduxfast_ai_stop(devpriv, 0);
+				usbduxfast_ai_stop(dev, 0);
 				/* tell comedi that the acquistion is over */
 				async->events |= COMEDI_CB_EOA;
 				comedi_event(dev, s);
@@ -331,7 +334,7 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 						urb->actual_length);
 		if (unlikely(err == 0)) {
 			/* buffer overflow */
-			usbduxfast_ai_stop(devpriv, 0);
+			usbduxfast_ai_stop(dev, 0);
 			return;
 		}
 
@@ -355,14 +358,15 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 		async->events |= COMEDI_CB_EOA;
 		async->events |= COMEDI_CB_ERROR;
 		comedi_event(dev, s);
-		usbduxfast_ai_stop(devpriv, 0);
+		usbduxfast_ai_stop(dev, 0);
 	}
 }
 
-static int usbduxfastsub_start(struct usbduxfast_private *devpriv)
+static int usbduxfastsub_start(struct comedi_device *dev)
 {
-	int ret;
+	struct usbduxfast_private *devpriv = dev->private;
 	unsigned char *local_transfer_buffer;
+	int ret;
 
 	local_transfer_buffer = kmalloc(1, GFP_KERNEL);
 	if (!local_transfer_buffer)
@@ -388,10 +392,11 @@ static int usbduxfastsub_start(struct usbduxfast_private *devpriv)
 	return ret;
 }
 
-static int usbduxfastsub_stop(struct usbduxfast_private *devpriv)
+static int usbduxfastsub_stop(struct comedi_device *dev)
 {
-	int ret;
+	struct usbduxfast_private *devpriv = dev->private;
 	unsigned char *local_transfer_buffer;
+	int ret;
 
 	local_transfer_buffer = kmalloc(1, GFP_KERNEL);
 	if (!local_transfer_buffer)
@@ -415,10 +420,11 @@ static int usbduxfastsub_stop(struct usbduxfast_private *devpriv)
 	return ret;
 }
 
-static int usbduxfastsub_upload(struct usbduxfast_private *devpriv,
+static int usbduxfastsub_upload(struct comedi_device *dev,
 				unsigned char *local_transfer_buffer,
 				unsigned int startAddr, unsigned int len)
 {
+	struct usbduxfast_private *devpriv = dev->private;
 	int ret;
 
 	/* brequest, firmware */
@@ -439,8 +445,9 @@ static int usbduxfastsub_upload(struct usbduxfast_private *devpriv,
 	return 0;
 }
 
-static int usbduxfastsub_submit_InURBs(struct usbduxfast_private *devpriv)
+static int usbduxfastsub_submit_InURBs(struct comedi_device *dev)
 {
+	struct usbduxfast_private *devpriv = dev->private;
 	int ret;
 
 	if (!devpriv)
@@ -449,7 +456,7 @@ static int usbduxfastsub_submit_InURBs(struct usbduxfast_private *devpriv)
 	usb_fill_bulk_urb(devpriv->urbIn, devpriv->usb,
 			  usb_rcvbulkpipe(devpriv->usb, BULKINEP),
 			  devpriv->transfer_buffer, SIZEINBUF,
-			  usbduxfast_ai_interrupt, devpriv->comedidev);
+			  usbduxfast_ai_interrupt, dev);
 
 	ret = usb_submit_urb(devpriv->urbIn, GFP_ATOMIC);
 	if (ret) {
@@ -572,7 +579,7 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 	}
 	if (!devpriv->ai_cmd_running) {
 		devpriv->ai_cmd_running = 1;
-		ret = usbduxfastsub_submit_InURBs(devpriv);
+		ret = usbduxfastsub_submit_InURBs(dev);
 		if (ret < 0) {
 			dev_err(dev->class_dev,
 				"%s: urbSubmit: err=%d\n", __func__, ret);
@@ -995,7 +1002,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	}
 
 	/* 0 means that the AD commands are sent */
-	result = send_dux_commands(devpriv, SENDADCOMMANDS);
+	result = send_dux_commands(dev, SENDADCOMMANDS);
 	if (result < 0) {
 		dev_err(dev->class_dev,
 			"adc command could not be submitted. Aborting...\n");
@@ -1020,7 +1027,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	if ((cmd->start_src == TRIG_NOW) || (cmd->start_src == TRIG_EXT)) {
 		/* enable this acquisition operation */
 		devpriv->ai_cmd_running = 1;
-		ret = usbduxfastsub_submit_InURBs(devpriv);
+		ret = usbduxfastsub_submit_InURBs(dev);
 		if (ret < 0) {
 			devpriv->ai_cmd_running = 0;
 			/* fixme: unlink here?? */
@@ -1115,7 +1122,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	devpriv->dux_commands[LOGBASE + 0] = 0;
 
 	/* 0 means that the AD commands are sent */
-	err = send_dux_commands(devpriv, SENDADCOMMANDS);
+	err = send_dux_commands(dev, SENDADCOMMANDS);
 	if (err < 0) {
 		dev_err(dev->class_dev,
 			"adc command could not be submitted. Aborting...\n");
@@ -1162,9 +1169,10 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 
 #define FIRMWARE_MAX_LEN 0x2000
 
-static int firmwareUpload(struct usbduxfast_private *devpriv,
+static int firmwareUpload(struct comedi_device *dev,
 			  const u8 *firmwareBinary, int sizeFirmware)
 {
+	struct usbduxfast_private *devpriv = dev->private;
 	int ret;
 	uint8_t *fwBuf;
 
@@ -1185,7 +1193,7 @@ static int firmwareUpload(struct usbduxfast_private *devpriv,
 		return -ENOMEM;
 	}
 
-	ret = usbduxfastsub_stop(devpriv);
+	ret = usbduxfastsub_stop(dev);
 	if (ret < 0) {
 		dev_err(&devpriv->intf->dev,
 			"comedi_: can not stop firmware\n");
@@ -1193,14 +1201,14 @@ static int firmwareUpload(struct usbduxfast_private *devpriv,
 		return ret;
 	}
 
-	ret = usbduxfastsub_upload(devpriv, fwBuf, 0, sizeFirmware);
+	ret = usbduxfastsub_upload(dev, fwBuf, 0, sizeFirmware);
 	if (ret < 0) {
 		dev_err(&devpriv->intf->dev,
 			"comedi_: firmware upload failed\n");
 		kfree(fwBuf);
 		return ret;
 	}
-	ret = usbduxfastsub_start(devpriv);
+	ret = usbduxfastsub_start(dev);
 	if (ret < 0) {
 		dev_err(&devpriv->intf->dev,
 			"comedi_: can not start firmware\n");
@@ -1244,10 +1252,11 @@ static int usbduxfast_attach_common(struct comedi_device *dev)
 	return 0;
 }
 
-static int usbduxfast_request_firmware(struct usb_interface *intf)
+static int usbduxfast_request_firmware(struct comedi_device *dev)
 {
+	struct usbduxfast_private *devpriv = dev->private;
+	struct usb_interface *intf = devpriv->intf;
 	struct usb_device *usb = interface_to_usbdev(intf);
-	struct usbduxfast_private *devpriv = usb_get_intfdata(intf);
 	const struct firmware *fw;
 	int ret;
 
@@ -1255,7 +1264,7 @@ static int usbduxfast_request_firmware(struct usb_interface *intf)
 	if (ret)
 		return ret;
 
-	ret = firmwareUpload(devpriv, fw->data, fw->size);
+	ret = firmwareUpload(dev, fw->data, fw->size);
 	release_firmware(fw);
 
 	return ret;
@@ -1316,7 +1325,7 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	 * Request, and upload, the firmware so we can
 	 * complete the comedi_driver (*auto_attach).
 	 */
-	ret = usbduxfast_request_firmware(intf);
+	ret = usbduxfast_request_firmware(dev);
 	if (ret) {
 		dev_err(&intf->dev, "could not load firmware (err=%d)\n", ret);
 		return ret;

commit 01245e7a9fa575affb4f42c4309a9c25b2296b08
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:32:53 2013 -0700

    staging: comedi: usbduxfast: remove 'ifnum' from private data
    
    The interface number is only needed during the attach of the
    device. Remove it from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 59bbd4d94a2b..b51bd97dd53b 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -152,7 +152,6 @@ struct usbduxfast_private {
 	struct urb *urbIn;	/* BULK-transfer handling: urb */
 	int8_t *transfer_buffer;
 	int16_t *insnBuffer;	/* input buffer for single insn */
-	int ifnum;		/* interface number */
 	struct usb_interface *intf;	/* interface structure */
 	/* comedi device for the interrupt context */
 	struct comedi_device *comedidev;
@@ -1285,7 +1284,6 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	devpriv->comedidev = dev;
 	devpriv->usb = usb;
 	devpriv->intf = intf;
-	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;
 	usb_set_intfdata(intf, devpriv);
 
 	devpriv->dux_commands = kmalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
@@ -1296,7 +1294,8 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	if (!devpriv->insnBuffer)
 		return -ENOMEM;
 
-	ret = usb_set_interface(devpriv->usb, devpriv->ifnum, 1);
+	ret = usb_set_interface(devpriv->usb,
+				intf->altsetting->desc.bInterfaceNumber, 1);
 	if (ret < 0) {
 		dev_err(&intf->dev,
 			"could not switch to alternate setting 1\n");

commit 7c346c2ce866959fc89a14d1379869084f32b3d8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:32:32 2013 -0700

    staging: comedi: usbduxfast: remove 'attached' from private data
    
    The subdevice function pointers are only setup if the device is
    attached. The 'attached' flag in the private data is unnecessary.
    Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 304302424981..59bbd4d94a2b 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -148,7 +148,6 @@ static const struct comedi_lrange range_usbduxfast_ai_range = {
  * one sub device just now: A/D
  */
 struct usbduxfast_private {
-	int attached;		/* is attached? */
 	struct usb_device *usb;	/* pointer to the usb-device */
 	struct urb *urbIn;	/* BULK-transfer handling: urb */
 	int8_t *transfer_buffer;
@@ -276,11 +275,6 @@ static void usbduxfast_ai_interrupt(struct urb *urb)
 		return;
 	}
 
-	if (unlikely(!devpriv->attached)) {
-		/* no comedi device there */
-		return;
-	}
-
 	/* first we test if something unusual has just happened */
 	switch (urb->status) {
 	case 0:
@@ -1246,8 +1240,6 @@ static int usbduxfast_attach_common(struct comedi_device *dev)
 	s->maxdata	= 0x1000;
 	s->range_table	= &range_usbduxfast_ai_range;
 
-	devpriv->attached = 1;
-
 	up(&devpriv->sem);
 
 	return 0;
@@ -1343,7 +1335,6 @@ static void usbduxfast_detach(struct comedi_device *dev)
 
 	down(&devpriv->sem);
 
-	devpriv->attached = 0;
 	devpriv->comedidev = NULL;
 
 	if (devpriv->intf)

commit 50a4cf9b2ce532af3f5c7ac33e61f2f5fa7a122a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:31:17 2013 -0700

    staging: comedi: usbduxfast: remove 'probed' from private data
    
    The 'probed' flag in the private data was used to handle the
    disconnect between the usb (*probe) and the comedi_driver
    (*auto_attach) so that if the comedi_driver was attached without
    an associated usb_device the subdevice functions would return
    -ENODEV.
    
    Now that the usb_driver (*probe) is part of the comedi_driver
    (*auto_attach), the comedi_driver can only attach if the usb
    device is present.
    
    Remove the unnecessary variable from the private data and its
    uses in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index a0a268b3715e..304302424981 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -149,7 +149,6 @@ static const struct comedi_lrange range_usbduxfast_ai_range = {
  */
 struct usbduxfast_private {
 	int attached;		/* is attached? */
-	int probed;		/* is it associated with a subdevice? */
 	struct usb_device *usb;	/* pointer to the usb-device */
 	struct urb *urbIn;	/* BULK-transfer handling: urb */
 	int8_t *transfer_buffer;
@@ -248,10 +247,6 @@ static int usbduxfast_ai_cancel(struct comedi_device *dev,
 		return -EFAULT;
 	}
 	down(&devpriv->sem);
-	if (!devpriv->probed) {
-		up(&devpriv->sem);
-		return -ENODEV;
-	}
 	/* unlink */
 	ret = usbduxfast_ai_stop(devpriv, 1);
 	up(&devpriv->sem);
@@ -476,14 +471,10 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_cmd *cmd)
 {
-	struct usbduxfast_private *devpriv = dev->private;
 	int err = 0;
 	long int steps, tmp;
 	int minSamplPer;
 
-	if (!devpriv->probed)
-		return -ENODEV;
-
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src,
@@ -580,10 +571,6 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&devpriv->sem);
-	if (!devpriv->probed) {
-		up(&devpriv->sem);
-		return -ENODEV;
-	}
 
 	if (trignum != 0) {
 		dev_err(dev->class_dev, "%s: invalid trignum\n", __func__);
@@ -632,10 +619,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&devpriv->sem);
-	if (!devpriv->probed) {
-		up(&devpriv->sem);
-		return -ENODEV;
-	}
 	if (devpriv->ai_cmd_running) {
 		dev_err(dev->class_dev,
 			"ai_cmd not possible. Another ai_cmd is running.\n");
@@ -1083,10 +1066,6 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	}
 
 	down(&devpriv->sem);
-	if (!devpriv->probed) {
-		up(&devpriv->sem);
-		return -ENODEV;
-	}
 	if (devpriv->ai_cmd_running) {
 		dev_err(dev->class_dev,
 			"ai_insn_read not possible. Async Command is running.\n");
@@ -1342,8 +1321,6 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	if (!devpriv->transfer_buffer)
 		return -ENOMEM;
 
-	devpriv->probed = 1;
-
 	/*
 	 * Request, and upload, the firmware so we can
 	 * complete the comedi_driver (*auto_attach).
@@ -1372,8 +1349,6 @@ static void usbduxfast_detach(struct comedi_device *dev)
 	if (devpriv->intf)
 		usb_set_intfdata(devpriv->intf, NULL);
 
-	devpriv->probed = 0;
-
 	if (devpriv->urbIn) {
 		/* waits until a running transfer is over */
 		usb_kill_urb(devpriv->urbIn);

commit 38bf7ba8a7e866350ac24f508f6b3a9685631dcb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:30:52 2013 -0700

    staging: comedi: usbduxfast: absorb tidy_up() into the (*detach)
    
    Now that the usb (*probe) is handled in the comedi_driver (*auto_attach)
    the comedi_driver (*detach) will be called automatically if the
    attach fails.
    
    The tidy_up() calls in the (*auto_attach) are not needed. Remove them
    and absorb the code in tidy_up() into the (*detach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 31993e02e5d9..a0a268b3715e 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1239,37 +1239,6 @@ static int firmwareUpload(struct usbduxfast_private *devpriv,
 	return 0;
 }
 
-static void tidy_up(struct usbduxfast_private *devpriv)
-{
-	if (!devpriv)
-		return;
-
-	/* shows the usb subsystem that the driver is down */
-	if (devpriv->intf)
-		usb_set_intfdata(devpriv->intf, NULL);
-
-	devpriv->probed = 0;
-
-	if (devpriv->urbIn) {
-		/* waits until a running transfer is over */
-		usb_kill_urb(devpriv->urbIn);
-
-		kfree(devpriv->transfer_buffer);
-		devpriv->transfer_buffer = NULL;
-
-		usb_free_urb(devpriv->urbIn);
-		devpriv->urbIn = NULL;
-	}
-
-	kfree(devpriv->insnBuffer);
-	devpriv->insnBuffer = NULL;
-
-	kfree(devpriv->dux_commands);
-	devpriv->dux_commands = NULL;
-
-	devpriv->ai_cmd_running = 0;
-}
-
 static int usbduxfast_attach_common(struct comedi_device *dev)
 {
 	struct usbduxfast_private *devpriv = dev->private;
@@ -1349,37 +1318,29 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 	usb_set_intfdata(intf, devpriv);
 
 	devpriv->dux_commands = kmalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
-	if (!devpriv->dux_commands) {
-		tidy_up(devpriv);
+	if (!devpriv->dux_commands)
 		return -ENOMEM;
-	}
 
 	devpriv->insnBuffer = kmalloc(SIZEINSNBUF, GFP_KERNEL);
-	if (!devpriv->insnBuffer) {
-		tidy_up(devpriv);
+	if (!devpriv->insnBuffer)
 		return -ENOMEM;
-	}
 
 	ret = usb_set_interface(devpriv->usb, devpriv->ifnum, 1);
 	if (ret < 0) {
 		dev_err(&intf->dev,
 			"could not switch to alternate setting 1\n");
-		tidy_up(devpriv);
 		return -ENODEV;
 	}
 
 	devpriv->urbIn = usb_alloc_urb(0, GFP_KERNEL);
 	if (!devpriv->urbIn) {
 		dev_err(&intf->dev, "Could not alloc. urb\n");
-		tidy_up(devpriv);
 		return -ENOMEM;
 	}
 
 	devpriv->transfer_buffer = kmalloc(SIZEINBUF, GFP_KERNEL);
-	if (!devpriv->transfer_buffer) {
-		tidy_up(devpriv);
+	if (!devpriv->transfer_buffer)
 		return -ENOMEM;
-	}
 
 	devpriv->probed = 1;
 
@@ -1400,13 +1361,39 @@ static void usbduxfast_detach(struct comedi_device *dev)
 {
 	struct usbduxfast_private *devpriv = dev->private;
 
-	if (devpriv) {
-		down(&devpriv->sem);
-		devpriv->attached = 0;
-		devpriv->comedidev = NULL;
-		tidy_up(devpriv);
-		up(&devpriv->sem);
+	if (!devpriv)
+		return;
+
+	down(&devpriv->sem);
+
+	devpriv->attached = 0;
+	devpriv->comedidev = NULL;
+
+	if (devpriv->intf)
+		usb_set_intfdata(devpriv->intf, NULL);
+
+	devpriv->probed = 0;
+
+	if (devpriv->urbIn) {
+		/* waits until a running transfer is over */
+		usb_kill_urb(devpriv->urbIn);
+
+		kfree(devpriv->transfer_buffer);
+		devpriv->transfer_buffer = NULL;
+
+		usb_free_urb(devpriv->urbIn);
+		devpriv->urbIn = NULL;
 	}
+
+	kfree(devpriv->insnBuffer);
+	devpriv->insnBuffer = NULL;
+
+	kfree(devpriv->dux_commands);
+	devpriv->dux_commands = NULL;
+
+	devpriv->ai_cmd_running = 0;
+
+	up(&devpriv->sem);
 }
 
 static struct comedi_driver usbduxfast_driver = {

commit 8f210c0cc3967452db2b98e94b20ef4ab38e6966
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:30:30 2013 -0700

    staging: comedi: usbduxfast: remove some unused defines
    
    Now that the private data is kzalloc'ed when the device is attached,
    the NUMUSBDUXFAST define is not used. Remove it.
    
    The SUBDEV_AD define is only used when setting up the subdevice.
    Remove it and just open-code the value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 9f6a0e930d94..31993e02e5d9 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -115,16 +115,6 @@
  */
 #define NUMOFINBUFFERSHIGH	10
 
-/*
- * total number of usbduxfast devices
- */
-#define NUMUSBDUXFAST	16
-
-/*
- * analogue in subdevice
- */
-#define SUBDEV_AD	0
-
 /*
  * min delay steps for more than one channel
  * basically when the mux gives up ;-)
@@ -1295,7 +1285,7 @@ static int usbduxfast_attach_common(struct comedi_device *dev)
 	}
 
 	/* Analog Input subdevice */
-	s = &dev->subdevices[SUBDEV_AD];
+	s = &dev->subdevices[0];
 	dev->read_subdev = s;
 	s->type		= COMEDI_SUBD_AI;
 	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ;

commit 2d719c9cdbb08e90a090145c4ceacc1dbd6d869a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:30:09 2013 -0700

    staging: comedi: usbduxfast: Move usb_driver (*probe) into comedi_driver
    
    Currently, the usb_driver (*probe) locates a free place in the static
    usbduxfast array to use for the private data in this driver. It then
    does some initial setup of the usb device and allocates the buffers
    needed. The firmware for the device is then requested and uploaded
    before calling comedi_usb_auto_config() to allow the comedi core to
    complete the (*auto_attach) of the device.
    
    Move the bulk of the (*probe) into the comedi_driver (*auto_attach).
    This allows the private data to be kzalloc'ed. We can then remove the
    static array along with the semaphore that protected it.
    
    This also removes the 16 attached devices limitation.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index a83b2b5bcf18..9f6a0e930d94 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -177,19 +177,6 @@ struct usbduxfast_private {
 	struct semaphore sem;
 };
 
-/*
- * The pointer to the private usb-data of the driver
- * is also the private data for the comedi-device.
- * This has to be global as the usb subsystem needs
- * global variables. The other reason is that this
- * structure must be there _before_ any comedi
- * command is issued. The usb subsystem must be
- * initialised before comedi can access it.
- */
-static struct usbduxfast_private usbduxfastsub[NUMUSBDUXFAST];
-
-static DEFINE_SEMAPHORE(start_stop_sem);
-
 /*
  * bulk transfers to usbduxfast
  */
@@ -1293,24 +1280,20 @@ static void tidy_up(struct usbduxfast_private *devpriv)
 	devpriv->ai_cmd_running = 0;
 }
 
-static int usbduxfast_attach_common(struct comedi_device *dev,
-				    struct usbduxfast_private *devpriv)
+static int usbduxfast_attach_common(struct comedi_device *dev)
 {
+	struct usbduxfast_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	int ret;
 
 	down(&devpriv->sem);
 
-	devpriv->comedidev = dev;
-
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret) {
 		up(&devpriv->sem);
 		return ret;
 	}
 
-	dev->private = devpriv;
-
 	/* Analog Input subdevice */
 	s = &dev->subdevices[SUBDEV_AD];
 	dev->read_subdev = s;
@@ -1332,53 +1315,6 @@ static int usbduxfast_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
-static int usbduxfast_auto_attach(struct comedi_device *dev,
-				  unsigned long context_unused)
-{
-	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	struct usbduxfast_private *devpriv;
-	int ret;
-
-	dev->private = NULL;
-	down(&start_stop_sem);
-	devpriv = usb_get_intfdata(intf);
-	if (!devpriv || !devpriv->probed) {
-		dev_err(dev->class_dev,
-			"usbduxfast: error: auto_attach failed, not connected\n");
-		ret = -ENODEV;
-	} else if (devpriv->attached) {
-		dev_err(dev->class_dev,
-		       "usbduxfast: error: auto_attach failed, already attached\n");
-		ret = -ENODEV;
-	} else
-		ret = usbduxfast_attach_common(dev, devpriv);
-	up(&start_stop_sem);
-	return ret;
-}
-
-static void usbduxfast_detach(struct comedi_device *dev)
-{
-	struct usbduxfast_private *devpriv = dev->private;
-
-	if (devpriv) {
-		down(&devpriv->sem);
-		down(&start_stop_sem);
-		dev->private = NULL;
-		devpriv->attached = 0;
-		devpriv->comedidev = NULL;
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		up(&devpriv->sem);
-	}
-}
-
-static struct comedi_driver usbduxfast_driver = {
-	.driver_name	= "usbduxfast",
-	.module		= THIS_MODULE,
-	.auto_attach	= usbduxfast_auto_attach,
-	.detach		= usbduxfast_detach,
-};
-
 static int usbduxfast_request_firmware(struct usb_interface *intf)
 {
 	struct usb_device *usb = interface_to_usbdev(intf);
@@ -1396,12 +1332,12 @@ static int usbduxfast_request_firmware(struct usb_interface *intf)
 	return ret;
 }
 
-static int usbduxfast_usb_probe(struct usb_interface *intf,
-				const struct usb_device_id *id)
+static int usbduxfast_auto_attach(struct comedi_device *dev,
+				  unsigned long context_unused)
 {
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usb_device *usb = interface_to_usbdev(intf);
-	struct usbduxfast_private *devpriv = NULL;
-	int i;
+	struct usbduxfast_private *devpriv;
 	int ret;
 
 	if (usb->speed != USB_SPEED_HIGH) {
@@ -1410,24 +1346,13 @@ static int usbduxfast_usb_probe(struct usb_interface *intf,
 		return -ENODEV;
 	}
 
-	down(&start_stop_sem);
-	/* look for a free place in the usbduxfast array */
-	for (i = 0; i < NUMUSBDUXFAST; i++) {
-		if (!usbduxfastsub[i].probed) {
-			devpriv = &usbduxfastsub[i];
-			break;
-		}
-	}
-
-	/* no more space */
-	if (!devpriv) {
-		dev_err(&intf->dev,
-			"Too many usbduxfast-devices connected.\n");
-		up(&start_stop_sem);
-		return -EMFILE;
-	}
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	sema_init(&devpriv->sem, 1);
+	devpriv->comedidev = dev;
 	devpriv->usb = usb;
 	devpriv->intf = intf;
 	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;
@@ -1436,23 +1361,20 @@ static int usbduxfast_usb_probe(struct usb_interface *intf,
 	devpriv->dux_commands = kmalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
 	if (!devpriv->dux_commands) {
 		tidy_up(devpriv);
-		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 
 	devpriv->insnBuffer = kmalloc(SIZEINSNBUF, GFP_KERNEL);
 	if (!devpriv->insnBuffer) {
 		tidy_up(devpriv);
-		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 
-	i = usb_set_interface(devpriv->usb, devpriv->ifnum, 1);
-	if (i < 0) {
+	ret = usb_set_interface(devpriv->usb, devpriv->ifnum, 1);
+	if (ret < 0) {
 		dev_err(&intf->dev,
 			"could not switch to alternate setting 1\n");
 		tidy_up(devpriv);
-		up(&start_stop_sem);
 		return -ENODEV;
 	}
 
@@ -1460,19 +1382,16 @@ static int usbduxfast_usb_probe(struct usb_interface *intf,
 	if (!devpriv->urbIn) {
 		dev_err(&intf->dev, "Could not alloc. urb\n");
 		tidy_up(devpriv);
-		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 
 	devpriv->transfer_buffer = kmalloc(SIZEINBUF, GFP_KERNEL);
 	if (!devpriv->transfer_buffer) {
 		tidy_up(devpriv);
-		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 
 	devpriv->probed = 1;
-	up(&start_stop_sem);
 
 	/*
 	 * Request, and upload, the firmware so we can
@@ -1484,6 +1403,32 @@ static int usbduxfast_usb_probe(struct usb_interface *intf,
 		return ret;
 	}
 
+	return usbduxfast_attach_common(dev);
+}
+
+static void usbduxfast_detach(struct comedi_device *dev)
+{
+	struct usbduxfast_private *devpriv = dev->private;
+
+	if (devpriv) {
+		down(&devpriv->sem);
+		devpriv->attached = 0;
+		devpriv->comedidev = NULL;
+		tidy_up(devpriv);
+		up(&devpriv->sem);
+	}
+}
+
+static struct comedi_driver usbduxfast_driver = {
+	.driver_name	= "usbduxfast",
+	.module		= THIS_MODULE,
+	.auto_attach	= usbduxfast_auto_attach,
+	.detach		= usbduxfast_detach,
+};
+
+static int usbduxfast_usb_probe(struct usb_interface *intf,
+				const struct usb_device_id *id)
+{
 	return comedi_usb_auto_config(intf, &usbduxfast_driver, 0);
 }
 

commit 0c4ab6715cf34293f40c8c80f361ca08d7cf1bc2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:29:35 2013 -0700

    staging: comedi: usbduxfast: Use comedi_usb_auto_unconfig() for (*disconnect)
    
    The usb_driver (*disconnect) calls comedi_usb_auto_unconfig() then
    frees any allocations by calling tidy_up(). comedi_usb_auto_unconfig()
    calls the comedi_driver (*detach) function, usbduxfast_detach().
    
    Move the tidy_up() call into usbduxfast_detach() and use the
    comedi_usb_auto_unconfig() directly for the (*disconnect).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index cf99e5b12c9c..a83b2b5bcf18 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1366,6 +1366,7 @@ static void usbduxfast_detach(struct comedi_device *dev)
 		dev->private = NULL;
 		devpriv->attached = 0;
 		devpriv->comedidev = NULL;
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		up(&devpriv->sem);
 	}
@@ -1486,29 +1487,6 @@ static int usbduxfast_usb_probe(struct usb_interface *intf,
 	return comedi_usb_auto_config(intf, &usbduxfast_driver, 0);
 }
 
-static void usbduxfast_usb_disconnect(struct usb_interface *intf)
-{
-	struct usbduxfast_private *devpriv = usb_get_intfdata(intf);
-	struct usb_device *usb = interface_to_usbdev(intf);
-
-	if (!devpriv) {
-		dev_err(&intf->dev, "disconnect called with null pointer.\n");
-		return;
-	}
-	if (devpriv->usb != usb) {
-		dev_err(&intf->dev, "BUG! called with wrong ptr!!!\n");
-		return;
-	}
-
-	comedi_usb_auto_unconfig(intf);
-
-	down(&start_stop_sem);
-	down(&devpriv->sem);
-	tidy_up(devpriv);
-	up(&devpriv->sem);
-	up(&start_stop_sem);
-}
-
 static const struct usb_device_id usbduxfast_usb_table[] = {
 	/* { USB_DEVICE(0x4b4, 0x8613) }, testing */
 	{ USB_DEVICE(0x13d8, 0x0010) },	/* real ID */
@@ -1520,7 +1498,7 @@ MODULE_DEVICE_TABLE(usb, usbduxfast_usb_table);
 static struct usb_driver usbduxfast_usb_driver = {
 	.name		= "usbduxfast",
 	.probe		= usbduxfast_usb_probe,
-	.disconnect	= usbduxfast_usb_disconnect,
+	.disconnect	= comedi_usb_auto_unconfig,
 	.id_table	= usbduxfast_usb_table,
 };
 module_comedi_usb_driver(usbduxfast_driver, usbduxfast_usb_driver);

commit f8eb27e07642545e6ed0f47054c0c041fdf91609
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:29:09 2013 -0700

    staging: comedi: usbduxfast: tidy up usbduxfastsub_ai_Irq()
    
    Rename the CamelCase function,
    
    Rename some of the local variables to the normal names used in
    comedi drivers. Add a local variable for the comedi_async *.
    
    Remove the sanity checking. The urb that causes this function to
    be called can only be submitted if the sanity checks already
    passed.
    
    Change the way the comedi_subdevice is fetched. The attach function
    sets the dev->read_subev pointer to the correct subdevice. Use that
    instead of accessing the dev->subdevices array directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 0e1ea9d43ce5..cf99e5b12c9c 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -286,30 +286,14 @@ static int usbduxfast_ai_cancel(struct comedi_device *dev,
  * analogue IN
  * interrupt service routine
  */
-static void usbduxfastsub_ai_Irq(struct urb *urb)
+static void usbduxfast_ai_interrupt(struct urb *urb)
 {
+	struct comedi_device *dev = urb->context;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_async *async = s->async;
+	struct usbduxfast_private *devpriv = dev->private;
 	int n, err;
-	struct usbduxfast_private *devpriv;
-	struct comedi_device *this_comedidev;
-	struct comedi_subdevice *s;
 
-	/* sanity checks - is the urb there? */
-	if (!urb) {
-		pr_err("ao int-handler called with urb=NULL!\n");
-		return;
-	}
-	/* the context variable points to the subdevice */
-	this_comedidev = urb->context;
-	if (!this_comedidev) {
-		pr_err("urb context is a NULL pointer!\n");
-		return;
-	}
-	/* the private structure of the subdevice is usbduxfast_private */
-	devpriv = this_comedidev->private;
-	if (!devpriv) {
-		pr_err("private of comedi subdev is a NULL pointer!\n");
-		return;
-	}
 	/* are we running a command? */
 	if (unlikely(!devpriv->ai_cmd_running)) {
 		/*
@@ -324,8 +308,6 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 		/* no comedi device there */
 		return;
 	}
-	/* subdevice which is the AD converter */
-	s = &this_comedidev->subdevices[SUBDEV_AD];
 
 	/* first we test if something unusual has just happened */
 	switch (urb->status) {
@@ -341,9 +323,9 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
 		/* tell this comedi */
-		s->async->events |= COMEDI_CB_EOA;
-		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(devpriv->comedidev, s);
+		async->events |= COMEDI_CB_EOA;
+		async->events |= COMEDI_CB_ERROR;
+		comedi_event(dev, s);
 		/* stop the transfer w/o unlink */
 		usbduxfast_ai_stop(devpriv, 0);
 		return;
@@ -351,9 +333,9 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 	default:
 		pr_err("non-zero urb status received in ai intr context: %d\n",
 		       urb->status);
-		s->async->events |= COMEDI_CB_EOA;
-		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(devpriv->comedidev, s);
+		async->events |= COMEDI_CB_EOA;
+		async->events |= COMEDI_CB_ERROR;
+		comedi_event(dev, s);
 		usbduxfast_ai_stop(devpriv, 0);
 		return;
 	}
@@ -373,8 +355,8 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 							  * sizeof(uint16_t));
 				usbduxfast_ai_stop(devpriv, 0);
 				/* tell comedi that the acquistion is over */
-				s->async->events |= COMEDI_CB_EOA;
-				comedi_event(devpriv->comedidev, s);
+				async->events |= COMEDI_CB_EOA;
+				comedi_event(dev, s);
 				return;
 			}
 			devpriv->ai_sample_count -= n;
@@ -389,8 +371,7 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 		}
 
 		/* tell comedi that data is there */
-		comedi_event(devpriv->comedidev, s);
-
+		comedi_event(dev, s);
 	} else {
 		/* ignore this packet */
 		devpriv->ignore--;
@@ -406,9 +387,9 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 	if (err < 0) {
 		dev_err(&urb->dev->dev,
 			"urb resubm failed: %d", err);
-		s->async->events |= COMEDI_CB_EOA;
-		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(devpriv->comedidev, s);
+		async->events |= COMEDI_CB_EOA;
+		async->events |= COMEDI_CB_ERROR;
+		comedi_event(dev, s);
 		usbduxfast_ai_stop(devpriv, 0);
 	}
 }
@@ -502,8 +483,8 @@ static int usbduxfastsub_submit_InURBs(struct usbduxfast_private *devpriv)
 
 	usb_fill_bulk_urb(devpriv->urbIn, devpriv->usb,
 			  usb_rcvbulkpipe(devpriv->usb, BULKINEP),
-			  devpriv->transfer_buffer,
-			  SIZEINBUF, usbduxfastsub_ai_Irq, devpriv->comedidev);
+			  devpriv->transfer_buffer, SIZEINBUF,
+			  usbduxfast_ai_interrupt, devpriv->comedidev);
 
 	ret = usb_submit_urb(devpriv->urbIn, GFP_ATOMIC);
 	if (ret) {

commit ba6205d6f9e63720529cd5c3cde4a0946b017c46
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:28:48 2013 -0700

    staging: comedi: usbduxfast: remove all COMEDI_DEBUG messages
    
    These messages are just function trace noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index f2f4d304d7fc..0e1ea9d43ce5 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -202,14 +202,6 @@ static int send_dux_commands(struct usbduxfast_private *devpriv, int cmd_type)
 
 	devpriv->dux_commands[0] = cmd_type;
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi%d: usbduxfast: dux_commands: ",
-	       devpriv->comedidev->minor);
-	for (tmp = 0; tmp < SIZEOFDUXBUFFER; tmp++)
-		printk(" %02x", devpriv->dux_commands[tmp]);
-	printk("\n");
-#endif
-
 	tmp = usb_bulk_msg(devpriv->usb,
 			   usb_sndbulkpipe(devpriv->usb, CHANNELLISTEP),
 			   devpriv->dux_commands,
@@ -236,9 +228,6 @@ static int usbduxfastsub_unlink_InURBs(struct usbduxfast_private *devpriv)
 		usb_kill_urb(devpriv->urbIn);
 		j = 0;
 	}
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi: usbduxfast: unlinked InURB: res=%d\n", j);
-#endif
 	return err;
 }
 
@@ -256,9 +245,6 @@ static int usbduxfast_ai_stop(struct usbduxfast_private *devpriv,
 		pr_err("%s: devpriv=NULL!\n", __func__);
 		return -EFAULT;
 	}
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi: usbduxfast_ai_stop\n");
-#endif
 
 	devpriv->ai_cmd_running = 0;
 
@@ -280,9 +266,6 @@ static int usbduxfast_ai_cancel(struct comedi_device *dev,
 	int ret;
 
 	/* force unlink of all urbs */
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi: usbduxfast_ai_cancel\n");
-#endif
 	if (!devpriv) {
 		dev_err(dev->class_dev, "%s: devpriv=NULL\n", __func__);
 		return -EFAULT;
@@ -492,11 +475,6 @@ static int usbduxfastsub_upload(struct usbduxfast_private *devpriv,
 {
 	int ret;
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi: usbduxfast: uploading %d bytes", len);
-	printk(KERN_DEBUG " to addr %d, first byte=%d.\n",
-	       startAddr, local_transfer_buffer[0]);
-#endif
 	/* brequest, firmware */
 	ret = usb_control_msg(devpriv->usb, usb_sndctrlpipe(devpriv->usb, 0),
 			      USBDUXFASTSUB_FIRMWARE,
@@ -507,11 +485,6 @@ static int usbduxfastsub_upload(struct usbduxfast_private *devpriv,
 			      local_transfer_buffer,
 			      len,	/* length */
 			      EZTIMEOUT);      /* timeout */
-
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi_: usbduxfast: result=%d\n", ret);
-#endif
-
 	if (ret < 0) {
 		dev_err(&devpriv->intf->dev, "uppload failed\n");
 		return ret;
@@ -532,11 +505,6 @@ static int usbduxfastsub_submit_InURBs(struct usbduxfast_private *devpriv)
 			  devpriv->transfer_buffer,
 			  SIZEINBUF, usbduxfastsub_ai_Irq, devpriv->comedidev);
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi%d: usbduxfast: submitting in-urb: "
-	       "0x%p,0x%p\n", devpriv->comedidev->minor, devpriv->urbIn->context,
-	       devpriv->urbIn->dev);
-#endif
 	ret = usb_submit_urb(devpriv->urbIn, GFP_ATOMIC);
 	if (ret) {
 		dev_err(&devpriv->intf->dev,
@@ -658,9 +626,6 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 		up(&devpriv->sem);
 		return -ENODEV;
 	}
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi%d: usbduxfast_ai_inttrig\n", dev->minor);
-#endif
 
 	if (trignum != 0) {
 		dev_err(dev->class_dev, "%s: invalid trignum\n", __func__);
@@ -705,9 +670,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	int result;
 	long steps, steps_tmp;
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi%d: usbduxfast_ai_cmd\n", dev->minor);
-#endif
 	if (!devpriv)
 		return -EFAULT;
 
@@ -784,10 +746,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		up(&devpriv->sem);
 		return -EINVAL;
 	}
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi%d: usbduxfast: steps=%ld, convert_arg=%u\n",
-	       dev->minor, steps, cmd->convert_arg);
-#endif
 
 	switch (cmd->chanlist_len) {
 	case 1:
@@ -1102,10 +1060,6 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		return -EFAULT;
 	}
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi %d: sending commands to the usb device\n",
-	       dev->minor);
-#endif
 	/* 0 means that the AD commands are sent */
 	result = send_dux_commands(devpriv, SENDADCOMMANDS);
 	if (result < 0) {
@@ -1169,10 +1123,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 		dev_err(dev->class_dev, "%s: no usb dev.\n", __func__);
 		return -ENODEV;
 	}
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi%d: ai_insn_read, insn->n=%d, "
-	       "insn->subdev=%d\n", dev->minor, insn->n, insn->subdev);
-#endif
+
 	down(&devpriv->sem);
 	if (!devpriv->probed) {
 		up(&devpriv->sem);
@@ -1233,10 +1184,6 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	devpriv->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
 	devpriv->dux_commands[LOGBASE + 0] = 0;
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi %d: sending commands to the usb device\n",
-	       dev->minor);
-#endif
 	/* 0 means that the AD commands are sent */
 	err = send_dux_commands(devpriv, SENDADCOMMANDS);
 	if (err < 0) {
@@ -1245,11 +1192,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 		up(&devpriv->sem);
 		return err;
 	}
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi%d: usbduxfast: submitting in-urb: "
-	       "0x%p,0x%p\n", devpriv->comedidev->minor, devpriv->urbIn->context,
-	       devpriv->urbIn->dev);
-#endif
+
 	for (i = 0; i < PACKETS_TO_IGNORE; i++) {
 		err = usb_bulk_msg(devpriv->usb,
 				   usb_rcvbulkpipe(devpriv->usb, BULKINEP),
@@ -1340,10 +1283,6 @@ static int firmwareUpload(struct usbduxfast_private *devpriv,
 
 static void tidy_up(struct usbduxfast_private *devpriv)
 {
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi_: usbduxfast: tiding up\n");
-#endif
-
 	if (!devpriv)
 		return;
 
@@ -1587,10 +1526,6 @@ static void usbduxfast_usb_disconnect(struct usb_interface *intf)
 	tidy_up(devpriv);
 	up(&devpriv->sem);
 	up(&start_stop_sem);
-
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi_: usbduxfast: disconnected from the usb\n");
-#endif
 }
 
 static const struct usb_device_id usbduxfast_usb_table[] = {

commit 95760280bd3a646280b931ec6ec46a893144d42e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:28:27 2013 -0700

    staging: comedi: usbduxfast: tidy up usbduxfast_attach_common()
    
    Remove the unnecessary comments and tidy up the whitespace in
    this function.
    
    Also, remove the dev_info() at the end. It's just added noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 1cd6d9252805..f2f4d304d7fc 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1376,11 +1376,11 @@ static void tidy_up(struct usbduxfast_private *devpriv)
 static int usbduxfast_attach_common(struct comedi_device *dev,
 				    struct usbduxfast_private *devpriv)
 {
-	int ret;
 	struct comedi_subdevice *s;
+	int ret;
 
 	down(&devpriv->sem);
-	/* pointer back to the corresponding comedi device */
+
 	devpriv->comedidev = dev;
 
 	ret = comedi_alloc_subdevices(dev, 1);
@@ -1388,38 +1388,27 @@ static int usbduxfast_attach_common(struct comedi_device *dev,
 		up(&devpriv->sem);
 		return ret;
 	}
-	/* private structure is also simply the usb-structure */
+
 	dev->private = devpriv;
-	/* the first subdevice is the A/D converter */
+
+	/* Analog Input subdevice */
 	s = &dev->subdevices[SUBDEV_AD];
-	/*
-	 * the URBs get the comedi subdevice which is responsible for reading
-	 * this is the subdevice which reads data
-	 */
 	dev->read_subdev = s;
-	/* the subdevice receives as private structure the usb-structure */
-	s->private = NULL;
-	/* analog input */
-	s->type = COMEDI_SUBD_AI;
-	/* readable and ref is to ground */
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
-	/* 16 channels */
-	s->n_chan = 16;
-	/* length of the channellist */
-	s->len_chanlist = 16;
-	/* callback functions */
-	s->insn_read = usbduxfast_ai_insn_read;
-	s->do_cmdtest = usbduxfast_ai_cmdtest;
-	s->do_cmd = usbduxfast_ai_cmd;
-	s->cancel = usbduxfast_ai_cancel;
-	/* max value from the A/D converter (12bit+1 bit for overflow) */
-	s->maxdata = 0x1000;
-	/* range table to convert to physical units */
-	s->range_table = &range_usbduxfast_ai_range;
-	/* finally decide that it's attached */
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
+	s->n_chan	= 16;
+	s->len_chanlist	= 16;
+	s->insn_read	= usbduxfast_ai_insn_read;
+	s->do_cmdtest	= usbduxfast_ai_cmdtest;
+	s->do_cmd	= usbduxfast_ai_cmd;
+	s->cancel	= usbduxfast_ai_cancel;
+	s->maxdata	= 0x1000;
+	s->range_table	= &range_usbduxfast_ai_range;
+
 	devpriv->attached = 1;
+
 	up(&devpriv->sem);
-	dev_info(dev->class_dev, "successfully attached to usbduxfast.\n");
+
 	return 0;
 }
 

commit 2e7a3099c2bbae0cb0d9ce055343e728e44e7691
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:28:02 2013 -0700

    staging: comedi: usbduxfast: remove 'owner' from usb_driver
    
    The struct usb_driver does not have an 'owner' field. Remove the
    code in this driver that initializes it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 7660976cfd11..1cd6d9252805 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1613,9 +1613,6 @@ static const struct usb_device_id usbduxfast_usb_table[] = {
 MODULE_DEVICE_TABLE(usb, usbduxfast_usb_table);
 
 static struct usb_driver usbduxfast_usb_driver = {
-#ifdef COMEDI_HAVE_USB_DRIVER_OWNER
-	.owner		= THIS_MODULE,
-#endif
 	.name		= "usbduxfast",
 	.probe		= usbduxfast_usb_probe,
 	.disconnect	= usbduxfast_usb_disconnect,

commit 7aa41c3c93d82fa75c96a61879a779bdc8520e9d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:27:37 2013 -0700

    staging: comedi: usbduxfast: rename usbduxfastsub_s variables
    
    For aesthetic reasons, globally rename the variables used for the
    struct usbduxfastsub_s * in this driver to 'devpriv'. This variable
    pointes to the comedi_device private data.
    
    Also, rename the struct to 'usbduxfast_private' to make its use
    a bit clearer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index cf05d08ee9ec..7660976cfd11 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -157,7 +157,7 @@ static const struct comedi_lrange range_usbduxfast_ai_range = {
  * this is the structure which holds all the data of this driver
  * one sub device just now: A/D
  */
-struct usbduxfastsub_s {
+struct usbduxfast_private {
 	int attached;		/* is attached? */
 	int probed;		/* is it associated with a subdevice? */
 	struct usb_device *usb;	/* pointer to the usb-device */
@@ -186,7 +186,7 @@ struct usbduxfastsub_s {
  * command is issued. The usb subsystem must be
  * initialised before comedi can access it.
  */
-static struct usbduxfastsub_s usbduxfastsub[NUMUSBDUXFAST];
+static struct usbduxfast_private usbduxfastsub[NUMUSBDUXFAST];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
@@ -196,25 +196,26 @@ static DEFINE_SEMAPHORE(start_stop_sem);
 #define SENDADCOMMANDS            0
 #define SENDINITEP6               1
 
-static int send_dux_commands(struct usbduxfastsub_s *udfs, int cmd_type)
+static int send_dux_commands(struct usbduxfast_private *devpriv, int cmd_type)
 {
 	int tmp, nsent;
 
-	udfs->dux_commands[0] = cmd_type;
+	devpriv->dux_commands[0] = cmd_type;
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast: dux_commands: ",
-	       udfs->comedidev->minor);
+	       devpriv->comedidev->minor);
 	for (tmp = 0; tmp < SIZEOFDUXBUFFER; tmp++)
-		printk(" %02x", udfs->dux_commands[tmp]);
+		printk(" %02x", devpriv->dux_commands[tmp]);
 	printk("\n");
 #endif
 
-	tmp = usb_bulk_msg(udfs->usb,
-			   usb_sndbulkpipe(udfs->usb, CHANNELLISTEP),
-			   udfs->dux_commands, SIZEOFDUXBUFFER, &nsent, 10000);
+	tmp = usb_bulk_msg(devpriv->usb,
+			   usb_sndbulkpipe(devpriv->usb, CHANNELLISTEP),
+			   devpriv->dux_commands,
+			   SIZEOFDUXBUFFER, &nsent, 10000);
 	if (tmp < 0)
-		dev_err(&udfs->intf->dev,
+		dev_err(&devpriv->intf->dev,
 			"could not transmit dux_commands to the usb-device, err=%d\n",
 			tmp);
 	return tmp;
@@ -224,15 +225,15 @@ static int send_dux_commands(struct usbduxfastsub_s *udfs, int cmd_type)
  * Stops the data acquision.
  * It should be safe to call this function from any context.
  */
-static int usbduxfastsub_unlink_InURBs(struct usbduxfastsub_s *udfs)
+static int usbduxfastsub_unlink_InURBs(struct usbduxfast_private *devpriv)
 {
 	int j = 0;
 	int err = 0;
 
-	if (udfs && udfs->urbIn) {
-		udfs->ai_cmd_running = 0;
+	if (devpriv && devpriv->urbIn) {
+		devpriv->ai_cmd_running = 0;
 		/* waits until a running transfer is over */
-		usb_kill_urb(udfs->urbIn);
+		usb_kill_urb(devpriv->urbIn);
 		j = 0;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
@@ -246,23 +247,24 @@ static int usbduxfastsub_unlink_InURBs(struct usbduxfastsub_s *udfs)
  * Is called from within this driver from both the
  * interrupt context and from comedi.
  */
-static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs, int do_unlink)
+static int usbduxfast_ai_stop(struct usbduxfast_private *devpriv,
+			      int do_unlink)
 {
 	int ret = 0;
 
-	if (!udfs) {
-		pr_err("%s: udfs=NULL!\n", __func__);
+	if (!devpriv) {
+		pr_err("%s: devpriv=NULL!\n", __func__);
 		return -EFAULT;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi: usbduxfast_ai_stop\n");
 #endif
 
-	udfs->ai_cmd_running = 0;
+	devpriv->ai_cmd_running = 0;
 
 	if (do_unlink)
 		/* stop aquistion */
-		ret = usbduxfastsub_unlink_InURBs(udfs);
+		ret = usbduxfastsub_unlink_InURBs(devpriv);
 
 	return ret;
 }
@@ -274,26 +276,25 @@ static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs, int do_unlink)
 static int usbduxfast_ai_cancel(struct comedi_device *dev,
 				struct comedi_subdevice *s)
 {
-	struct usbduxfastsub_s *udfs;
+	struct usbduxfast_private *devpriv = dev->private;
 	int ret;
 
 	/* force unlink of all urbs */
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi: usbduxfast_ai_cancel\n");
 #endif
-	udfs = dev->private;
-	if (!udfs) {
-		dev_err(dev->class_dev, "%s: udfs=NULL\n", __func__);
+	if (!devpriv) {
+		dev_err(dev->class_dev, "%s: devpriv=NULL\n", __func__);
 		return -EFAULT;
 	}
-	down(&udfs->sem);
-	if (!udfs->probed) {
-		up(&udfs->sem);
+	down(&devpriv->sem);
+	if (!devpriv->probed) {
+		up(&devpriv->sem);
 		return -ENODEV;
 	}
 	/* unlink */
-	ret = usbduxfast_ai_stop(udfs, 1);
-	up(&udfs->sem);
+	ret = usbduxfast_ai_stop(devpriv, 1);
+	up(&devpriv->sem);
 
 	return ret;
 }
@@ -305,7 +306,7 @@ static int usbduxfast_ai_cancel(struct comedi_device *dev,
 static void usbduxfastsub_ai_Irq(struct urb *urb)
 {
 	int n, err;
-	struct usbduxfastsub_s *udfs;
+	struct usbduxfast_private *devpriv;
 	struct comedi_device *this_comedidev;
 	struct comedi_subdevice *s;
 
@@ -320,14 +321,14 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 		pr_err("urb context is a NULL pointer!\n");
 		return;
 	}
-	/* the private structure of the subdevice is usbduxfastsub_s */
-	udfs = this_comedidev->private;
-	if (!udfs) {
+	/* the private structure of the subdevice is usbduxfast_private */
+	devpriv = this_comedidev->private;
+	if (!devpriv) {
 		pr_err("private of comedi subdev is a NULL pointer!\n");
 		return;
 	}
 	/* are we running a command? */
-	if (unlikely(!udfs->ai_cmd_running)) {
+	if (unlikely(!devpriv->ai_cmd_running)) {
 		/*
 		 * not running a command
 		 * do not continue execution if no asynchronous command
@@ -336,7 +337,7 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 		return;
 	}
 
-	if (unlikely(!udfs->attached)) {
+	if (unlikely(!devpriv->attached)) {
 		/* no comedi device there */
 		return;
 	}
@@ -359,9 +360,9 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 		/* tell this comedi */
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(udfs->comedidev, s);
+		comedi_event(devpriv->comedidev, s);
 		/* stop the transfer w/o unlink */
-		usbduxfast_ai_stop(udfs, 0);
+		usbduxfast_ai_stop(devpriv, 0);
 		return;
 
 	default:
@@ -369,54 +370,54 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 		       urb->status);
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(udfs->comedidev, s);
-		usbduxfast_ai_stop(udfs, 0);
+		comedi_event(devpriv->comedidev, s);
+		usbduxfast_ai_stop(devpriv, 0);
 		return;
 	}
 
-	if (!udfs->ignore) {
-		if (!udfs->ai_continous) {
+	if (!devpriv->ignore) {
+		if (!devpriv->ai_continous) {
 			/* not continuous, fixed number of samples */
 			n = urb->actual_length / sizeof(uint16_t);
-			if (unlikely(udfs->ai_sample_count < n)) {
+			if (unlikely(devpriv->ai_sample_count < n)) {
 				/*
 				 * we have send only a fraction of the bytes
 				 * received
 				 */
 				cfc_write_array_to_buffer(s,
 							  urb->transfer_buffer,
-							  udfs->ai_sample_count
+							  devpriv->ai_sample_count
 							  * sizeof(uint16_t));
-				usbduxfast_ai_stop(udfs, 0);
+				usbduxfast_ai_stop(devpriv, 0);
 				/* tell comedi that the acquistion is over */
 				s->async->events |= COMEDI_CB_EOA;
-				comedi_event(udfs->comedidev, s);
+				comedi_event(devpriv->comedidev, s);
 				return;
 			}
-			udfs->ai_sample_count -= n;
+			devpriv->ai_sample_count -= n;
 		}
 		/* write the full buffer to comedi */
 		err = cfc_write_array_to_buffer(s, urb->transfer_buffer,
 						urb->actual_length);
 		if (unlikely(err == 0)) {
 			/* buffer overflow */
-			usbduxfast_ai_stop(udfs, 0);
+			usbduxfast_ai_stop(devpriv, 0);
 			return;
 		}
 
 		/* tell comedi that data is there */
-		comedi_event(udfs->comedidev, s);
+		comedi_event(devpriv->comedidev, s);
 
 	} else {
 		/* ignore this packet */
-		udfs->ignore--;
+		devpriv->ignore--;
 	}
 
 	/*
 	 * command is still running
 	 * resubmit urb for BULK transfer
 	 */
-	urb->dev = udfs->usb;
+	urb->dev = devpriv->usb;
 	urb->status = 0;
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
@@ -424,12 +425,12 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 			"urb resubm failed: %d", err);
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(udfs->comedidev, s);
-		usbduxfast_ai_stop(udfs, 0);
+		comedi_event(devpriv->comedidev, s);
+		usbduxfast_ai_stop(devpriv, 0);
 	}
 }
 
-static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
+static int usbduxfastsub_start(struct usbduxfast_private *devpriv)
 {
 	int ret;
 	unsigned char *local_transfer_buffer;
@@ -441,7 +442,7 @@ static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 	/* 7f92 to zero */
 	*local_transfer_buffer = 0;
 	/* bRequest, "Firmware" */
-	ret = usb_control_msg(udfs->usb, usb_sndctrlpipe(udfs->usb, 0),
+	ret = usb_control_msg(devpriv->usb, usb_sndctrlpipe(devpriv->usb, 0),
 			      USBDUXFASTSUB_FIRMWARE,
 			      VENDOR_DIR_OUT,	  /* bmRequestType */
 			      USBDUXFASTSUB_CPUCS,    /* Value */
@@ -451,14 +452,14 @@ static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 			      1,      /* Length */
 			      EZTIMEOUT);    /* Timeout */
 	if (ret < 0)
-		dev_err(&udfs->intf->dev,
+		dev_err(&devpriv->intf->dev,
 			"control msg failed (start)\n");
 
 	kfree(local_transfer_buffer);
 	return ret;
 }
 
-static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
+static int usbduxfastsub_stop(struct usbduxfast_private *devpriv)
 {
 	int ret;
 	unsigned char *local_transfer_buffer;
@@ -470,7 +471,7 @@ static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 	/* 7f92 to one */
 	*local_transfer_buffer = 1;
 	/* bRequest, "Firmware" */
-	ret = usb_control_msg(udfs->usb, usb_sndctrlpipe(udfs->usb, 0),
+	ret = usb_control_msg(devpriv->usb, usb_sndctrlpipe(devpriv->usb, 0),
 			      USBDUXFASTSUB_FIRMWARE,
 			      VENDOR_DIR_OUT,	/* bmRequestType */
 			      USBDUXFASTSUB_CPUCS,	/* Value */
@@ -478,14 +479,14 @@ static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 			      local_transfer_buffer, 1,	/* Length */
 			      EZTIMEOUT);	/* Timeout */
 	if (ret < 0)
-		dev_err(&udfs->intf->dev,
+		dev_err(&devpriv->intf->dev,
 			"control msg failed (stop)\n");
 
 	kfree(local_transfer_buffer);
 	return ret;
 }
 
-static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
+static int usbduxfastsub_upload(struct usbduxfast_private *devpriv,
 				unsigned char *local_transfer_buffer,
 				unsigned int startAddr, unsigned int len)
 {
@@ -497,7 +498,7 @@ static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 	       startAddr, local_transfer_buffer[0]);
 #endif
 	/* brequest, firmware */
-	ret = usb_control_msg(udfs->usb, usb_sndctrlpipe(udfs->usb, 0),
+	ret = usb_control_msg(devpriv->usb, usb_sndctrlpipe(devpriv->usb, 0),
 			      USBDUXFASTSUB_FIRMWARE,
 			      VENDOR_DIR_OUT,	/* bmRequestType */
 			      startAddr,	/* value */
@@ -512,33 +513,33 @@ static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 #endif
 
 	if (ret < 0) {
-		dev_err(&udfs->intf->dev, "uppload failed\n");
+		dev_err(&devpriv->intf->dev, "uppload failed\n");
 		return ret;
 	}
 
 	return 0;
 }
 
-static int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
+static int usbduxfastsub_submit_InURBs(struct usbduxfast_private *devpriv)
 {
 	int ret;
 
-	if (!udfs)
+	if (!devpriv)
 		return -EFAULT;
 
-	usb_fill_bulk_urb(udfs->urbIn, udfs->usb,
-			  usb_rcvbulkpipe(udfs->usb, BULKINEP),
-			  udfs->transfer_buffer,
-			  SIZEINBUF, usbduxfastsub_ai_Irq, udfs->comedidev);
+	usb_fill_bulk_urb(devpriv->urbIn, devpriv->usb,
+			  usb_rcvbulkpipe(devpriv->usb, BULKINEP),
+			  devpriv->transfer_buffer,
+			  SIZEINBUF, usbduxfastsub_ai_Irq, devpriv->comedidev);
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast: submitting in-urb: "
-	       "0x%p,0x%p\n", udfs->comedidev->minor, udfs->urbIn->context,
-	       udfs->urbIn->dev);
+	       "0x%p,0x%p\n", devpriv->comedidev->minor, devpriv->urbIn->context,
+	       devpriv->urbIn->dev);
 #endif
-	ret = usb_submit_urb(udfs->urbIn, GFP_ATOMIC);
+	ret = usb_submit_urb(devpriv->urbIn, GFP_ATOMIC);
 	if (ret) {
-		dev_err(&udfs->intf->dev,
+		dev_err(&devpriv->intf->dev,
 			"ai: usb_submit_urb error %d\n", ret);
 		return ret;
 	}
@@ -549,12 +550,12 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_cmd *cmd)
 {
-	struct usbduxfastsub_s *udfs = dev->private;
+	struct usbduxfast_private *devpriv = dev->private;
 	int err = 0;
 	long int steps, tmp;
 	int minSamplPer;
 
-	if (!udfs->probed)
+	if (!devpriv->probed)
 		return -ENODEV;
 
 	/* Step 1 : check if triggers are trivially valid */
@@ -646,15 +647,15 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 unsigned int trignum)
 {
+	struct usbduxfast_private *devpriv = dev->private;
 	int ret;
-	struct usbduxfastsub_s *udfs = dev->private;
 
-	if (!udfs)
+	if (!devpriv)
 		return -EFAULT;
 
-	down(&udfs->sem);
-	if (!udfs->probed) {
-		up(&udfs->sem);
+	down(&devpriv->sem);
+	if (!devpriv->probed) {
+		up(&devpriv->sem);
 		return -ENODEV;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
@@ -663,17 +664,17 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 
 	if (trignum != 0) {
 		dev_err(dev->class_dev, "%s: invalid trignum\n", __func__);
-		up(&udfs->sem);
+		up(&devpriv->sem);
 		return -EINVAL;
 	}
-	if (!udfs->ai_cmd_running) {
-		udfs->ai_cmd_running = 1;
-		ret = usbduxfastsub_submit_InURBs(udfs);
+	if (!devpriv->ai_cmd_running) {
+		devpriv->ai_cmd_running = 1;
+		ret = usbduxfastsub_submit_InURBs(devpriv);
 		if (ret < 0) {
 			dev_err(dev->class_dev,
 				"%s: urbSubmit: err=%d\n", __func__, ret);
-			udfs->ai_cmd_running = 0;
-			up(&udfs->sem);
+			devpriv->ai_cmd_running = 0;
+			up(&devpriv->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
@@ -681,7 +682,7 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 		dev_err(dev->class_dev,
 			"ai_inttrig but acqu is already running\n");
 	}
-	up(&udfs->sem);
+	up(&devpriv->sem);
 	return 1;
 }
 
@@ -697,29 +698,28 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
+	struct usbduxfast_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain, rngmask = 0xff;
 	int i, j, ret;
-	struct usbduxfastsub_s *udfs;
 	int result;
 	long steps, steps_tmp;
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast_ai_cmd\n", dev->minor);
 #endif
-	udfs = dev->private;
-	if (!udfs)
+	if (!devpriv)
 		return -EFAULT;
 
-	down(&udfs->sem);
-	if (!udfs->probed) {
-		up(&udfs->sem);
+	down(&devpriv->sem);
+	if (!devpriv->probed) {
+		up(&devpriv->sem);
 		return -ENODEV;
 	}
-	if (udfs->ai_cmd_running) {
+	if (devpriv->ai_cmd_running) {
 		dev_err(dev->class_dev,
 			"ai_cmd not possible. Another ai_cmd is running.\n");
-		up(&udfs->sem);
+		up(&devpriv->sem);
 		return -EBUSY;
 	}
 	/* set current channel of the running acquisition to zero */
@@ -729,7 +729,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	 * ignore the first buffers from the device if there
 	 * is an error condition
 	 */
-	udfs->ignore = PACKETS_TO_IGNORE;
+	devpriv->ignore = PACKETS_TO_IGNORE;
 
 	if (cmd->chanlist_len > 0) {
 		gain = CR_RANGE(cmd->chanlist[0]);
@@ -738,14 +738,14 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			if (chan != i) {
 				dev_err(dev->class_dev,
 					"cmd is accepting only consecutive channels.\n");
-				up(&udfs->sem);
+				up(&devpriv->sem);
 				return -EINVAL;
 			}
 			if ((gain != CR_RANGE(cmd->chanlist[i]))
 			    && (cmd->chanlist_len > 3)) {
 				dev_err(dev->class_dev,
 					"the gain must be the same for all channels.\n");
-				up(&udfs->sem);
+				up(&devpriv->sem);
 				return -EINVAL;
 			}
 			if (i >= NUMCHANNELS) {
@@ -759,7 +759,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		dev_err(dev->class_dev,
 			"scan_begin_src==TRIG_TIMER not valid.\n");
-		up(&udfs->sem);
+		up(&devpriv->sem);
 		return -EINVAL;
 	}
 	if (cmd->convert_src == TRIG_TIMER)
@@ -769,19 +769,19 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		dev_err(dev->class_dev,
 			"ai_cmd: steps=%ld, scan_begin_arg=%d. Not properly tested by cmdtest?\n",
 			steps, cmd->scan_begin_arg);
-		up(&udfs->sem);
+		up(&devpriv->sem);
 		return -EINVAL;
 	}
 	if (steps > MAX_SAMPLING_PERIOD) {
 		dev_err(dev->class_dev, "ai_cmd: sampling rate too low.\n");
-		up(&udfs->sem);
+		up(&devpriv->sem);
 		return -EINVAL;
 	}
 	if ((cmd->start_src == TRIG_EXT) && (cmd->chanlist_len != 1)
 	    && (cmd->chanlist_len != 16)) {
 		dev_err(dev->class_dev,
 			"ai_cmd: TRIG_EXT only with 1 or 16 channels possible.\n");
-		up(&udfs->sem);
+		up(&devpriv->sem);
 		return -EINVAL;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
@@ -808,17 +808,17 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		/* we loop here until ready has been set */
 		if (cmd->start_src == TRIG_EXT) {
 			/* branch back to state 0 */
-			udfs->dux_commands[LENBASE + 0] = 0x01;
+			devpriv->dux_commands[LENBASE + 0] = 0x01;
 			/* deceision state w/o data */
-			udfs->dux_commands[OPBASE + 0] = 0x01;
-			udfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+			devpriv->dux_commands[OPBASE + 0] = 0x01;
+			devpriv->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
 			/* RDY0 = 0 */
-			udfs->dux_commands[LOGBASE + 0] = 0x00;
+			devpriv->dux_commands[LOGBASE + 0] = 0x00;
 		} else {	/* we just proceed to state 1 */
-			udfs->dux_commands[LENBASE + 0] = 1;
-			udfs->dux_commands[OPBASE + 0] = 0;
-			udfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
-			udfs->dux_commands[LOGBASE + 0] = 0;
+			devpriv->dux_commands[LENBASE + 0] = 1;
+			devpriv->dux_commands[OPBASE + 0] = 0;
+			devpriv->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+			devpriv->dux_commands[LOGBASE + 0] = 0;
 		}
 
 		if (steps < MIN_SAMPLING_PERIOD) {
@@ -831,33 +831,33 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 				 */
 
 				/* branch back to state 1 */
-				udfs->dux_commands[LENBASE + 1] = 0x89;
+				devpriv->dux_commands[LENBASE + 1] = 0x89;
 				/* deceision state with data */
-				udfs->dux_commands[OPBASE + 1] = 0x03;
-				udfs->dux_commands[OUTBASE + 1] =
+				devpriv->dux_commands[OPBASE + 1] = 0x03;
+				devpriv->dux_commands[OUTBASE + 1] =
 				    0xFF & rngmask;
 				/* doesn't matter */
-				udfs->dux_commands[LOGBASE + 1] = 0xFF;
+				devpriv->dux_commands[LOGBASE + 1] = 0xFF;
 			} else {
 				/*
 				 * we loop through two states: data and delay
 				 * max rate is 15MHz
 				 */
-				udfs->dux_commands[LENBASE + 1] = steps - 1;
+				devpriv->dux_commands[LENBASE + 1] = steps - 1;
 				/* data */
-				udfs->dux_commands[OPBASE + 1] = 0x02;
-				udfs->dux_commands[OUTBASE + 1] =
+				devpriv->dux_commands[OPBASE + 1] = 0x02;
+				devpriv->dux_commands[OUTBASE + 1] =
 				    0xFF & rngmask;
 				/* doesn't matter */
-				udfs->dux_commands[LOGBASE + 1] = 0;
+				devpriv->dux_commands[LOGBASE + 1] = 0;
 				/* branch back to state 1 */
-				udfs->dux_commands[LENBASE + 2] = 0x09;
+				devpriv->dux_commands[LENBASE + 2] = 0x09;
 				/* deceision state w/o data */
-				udfs->dux_commands[OPBASE + 2] = 0x01;
-				udfs->dux_commands[OUTBASE + 2] =
+				devpriv->dux_commands[OPBASE + 2] = 0x01;
+				devpriv->dux_commands[OUTBASE + 2] =
 				    0xFF & rngmask;
 				/* doesn't matter */
-				udfs->dux_commands[LOGBASE + 2] = 0xFF;
+				devpriv->dux_commands[LOGBASE + 2] = 0xFF;
 			}
 		} else {
 			/*
@@ -869,26 +869,26 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			steps = steps - 1;
 
 			/* do the first part of the delay */
-			udfs->dux_commands[LENBASE + 1] = steps / 2;
-			udfs->dux_commands[OPBASE + 1] = 0;
-			udfs->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
-			udfs->dux_commands[LOGBASE + 1] = 0;
+			devpriv->dux_commands[LENBASE + 1] = steps / 2;
+			devpriv->dux_commands[OPBASE + 1] = 0;
+			devpriv->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
+			devpriv->dux_commands[LOGBASE + 1] = 0;
 
 			/* and the second part */
-			udfs->dux_commands[LENBASE + 2] = steps - steps / 2;
-			udfs->dux_commands[OPBASE + 2] = 0;
-			udfs->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
-			udfs->dux_commands[LOGBASE + 2] = 0;
+			devpriv->dux_commands[LENBASE + 2] = steps - steps / 2;
+			devpriv->dux_commands[OPBASE + 2] = 0;
+			devpriv->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
+			devpriv->dux_commands[LOGBASE + 2] = 0;
 
 			/* get the data and branch back */
 
 			/* branch back to state 1 */
-			udfs->dux_commands[LENBASE + 3] = 0x09;
+			devpriv->dux_commands[LENBASE + 3] = 0x09;
 			/* deceision state w data */
-			udfs->dux_commands[OPBASE + 3] = 0x03;
-			udfs->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
+			devpriv->dux_commands[OPBASE + 3] = 0x03;
+			devpriv->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
 			/* doesn't matter */
-			udfs->dux_commands[LOGBASE + 3] = 0xFF;
+			devpriv->dux_commands[LOGBASE + 3] = 0xFF;
 		}
 		break;
 
@@ -903,11 +903,11 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		else
 			rngmask = 0xff;
 
-		udfs->dux_commands[LENBASE + 0] = 1;
+		devpriv->dux_commands[LENBASE + 0] = 1;
 		/* data */
-		udfs->dux_commands[OPBASE + 0] = 0x02;
-		udfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE + 0] = 0;
+		devpriv->dux_commands[OPBASE + 0] = 0x02;
+		devpriv->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+		devpriv->dux_commands[LOGBASE + 0] = 0;
 
 		/* we have 1 state with duration 1: state 0 */
 		steps_tmp = steps - 1;
@@ -918,23 +918,23 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			rngmask = 0xff;
 
 		/* do the first part of the delay */
-		udfs->dux_commands[LENBASE + 1] = steps_tmp / 2;
-		udfs->dux_commands[OPBASE + 1] = 0;
+		devpriv->dux_commands[LENBASE + 1] = steps_tmp / 2;
+		devpriv->dux_commands[OPBASE + 1] = 0;
 		/* count */
-		udfs->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
-		udfs->dux_commands[LOGBASE + 1] = 0;
+		devpriv->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
+		devpriv->dux_commands[LOGBASE + 1] = 0;
 
 		/* and the second part */
-		udfs->dux_commands[LENBASE + 2] = steps_tmp - steps_tmp / 2;
-		udfs->dux_commands[OPBASE + 2] = 0;
-		udfs->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE + 2] = 0;
+		devpriv->dux_commands[LENBASE + 2] = steps_tmp - steps_tmp / 2;
+		devpriv->dux_commands[OPBASE + 2] = 0;
+		devpriv->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
+		devpriv->dux_commands[LOGBASE + 2] = 0;
 
-		udfs->dux_commands[LENBASE + 3] = 1;
+		devpriv->dux_commands[LENBASE + 3] = 1;
 		/* data */
-		udfs->dux_commands[OPBASE + 3] = 0x02;
-		udfs->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE + 3] = 0;
+		devpriv->dux_commands[OPBASE + 3] = 0x02;
+		devpriv->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
+		devpriv->dux_commands[LOGBASE + 3] = 0;
 
 		/*
 		 * we have 2 states with duration 1: step 6 and
@@ -948,22 +948,22 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			rngmask = 0xff;
 
 		/* do the first part of the delay */
-		udfs->dux_commands[LENBASE + 4] = steps_tmp / 2;
-		udfs->dux_commands[OPBASE + 4] = 0;
+		devpriv->dux_commands[LENBASE + 4] = steps_tmp / 2;
+		devpriv->dux_commands[OPBASE + 4] = 0;
 		/* reset */
-		udfs->dux_commands[OUTBASE + 4] = (0xFF - 0x02) & rngmask;
-		udfs->dux_commands[LOGBASE + 4] = 0;
+		devpriv->dux_commands[OUTBASE + 4] = (0xFF - 0x02) & rngmask;
+		devpriv->dux_commands[LOGBASE + 4] = 0;
 
 		/* and the second part */
-		udfs->dux_commands[LENBASE + 5] = steps_tmp - steps_tmp / 2;
-		udfs->dux_commands[OPBASE + 5] = 0;
-		udfs->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE + 5] = 0;
-
-		udfs->dux_commands[LENBASE + 6] = 1;
-		udfs->dux_commands[OPBASE + 6] = 0;
-		udfs->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE + 6] = 0;
+		devpriv->dux_commands[LENBASE + 5] = steps_tmp - steps_tmp / 2;
+		devpriv->dux_commands[OPBASE + 5] = 0;
+		devpriv->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
+		devpriv->dux_commands[LOGBASE + 5] = 0;
+
+		devpriv->dux_commands[LENBASE + 6] = 1;
+		devpriv->dux_commands[OPBASE + 6] = 0;
+		devpriv->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
+		devpriv->dux_commands[LOGBASE + 6] = 0;
 		break;
 
 	case 3:
@@ -979,12 +979,12 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			 * commit data to the FIFO and do the first part
 			 * of the delay
 			 */
-			udfs->dux_commands[LENBASE + j * 2] = steps / 2;
+			devpriv->dux_commands[LENBASE + j * 2] = steps / 2;
 			/* data */
-			udfs->dux_commands[OPBASE + j * 2] = 0x02;
+			devpriv->dux_commands[OPBASE + j * 2] = 0x02;
 			/* no change */
-			udfs->dux_commands[OUTBASE + j * 2] = 0xFF & rngmask;
-			udfs->dux_commands[LOGBASE + j * 2] = 0;
+			devpriv->dux_commands[OUTBASE + j * 2] = 0xFF & rngmask;
+			devpriv->dux_commands[LOGBASE + j * 2] = 0;
 
 			if (CR_RANGE(cmd->chanlist[j + 1]) > 0)
 				rngmask = 0xff - 0x04;
@@ -992,25 +992,25 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 				rngmask = 0xff;
 
 			/* do the second part of the delay */
-			udfs->dux_commands[LENBASE + j * 2 + 1] =
+			devpriv->dux_commands[LENBASE + j * 2 + 1] =
 			    steps - steps / 2;
 			/* no data */
-			udfs->dux_commands[OPBASE + j * 2 + 1] = 0;
+			devpriv->dux_commands[OPBASE + j * 2 + 1] = 0;
 			/* count */
-			udfs->dux_commands[OUTBASE + j * 2 + 1] =
+			devpriv->dux_commands[OUTBASE + j * 2 + 1] =
 			    0xFE & rngmask;
-			udfs->dux_commands[LOGBASE + j * 2 + 1] = 0;
+			devpriv->dux_commands[LOGBASE + j * 2 + 1] = 0;
 		}
 
 		/* 2 steps with duration 1: the idele step and step 6: */
 		steps_tmp = steps - 2;
 
 		/* commit data to the FIFO and do the first part of the delay */
-		udfs->dux_commands[LENBASE + 4] = steps_tmp / 2;
+		devpriv->dux_commands[LENBASE + 4] = steps_tmp / 2;
 		/* data */
-		udfs->dux_commands[OPBASE + 4] = 0x02;
-		udfs->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE + 4] = 0;
+		devpriv->dux_commands[OPBASE + 4] = 0x02;
+		devpriv->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
+		devpriv->dux_commands[LOGBASE + 4] = 0;
 
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
@@ -1018,17 +1018,17 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			rngmask = 0xff;
 
 		/* do the second part of the delay */
-		udfs->dux_commands[LENBASE + 5] = steps_tmp - steps_tmp / 2;
+		devpriv->dux_commands[LENBASE + 5] = steps_tmp - steps_tmp / 2;
 		/* no data */
-		udfs->dux_commands[OPBASE + 5] = 0;
+		devpriv->dux_commands[OPBASE + 5] = 0;
 		/* reset */
-		udfs->dux_commands[OUTBASE + 5] = (0xFF - 0x02) & rngmask;
-		udfs->dux_commands[LOGBASE + 5] = 0;
+		devpriv->dux_commands[OUTBASE + 5] = (0xFF - 0x02) & rngmask;
+		devpriv->dux_commands[LOGBASE + 5] = 0;
 
-		udfs->dux_commands[LENBASE + 6] = 1;
-		udfs->dux_commands[OPBASE + 6] = 0;
-		udfs->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE + 6] = 0;
+		devpriv->dux_commands[LENBASE + 6] = 1;
+		devpriv->dux_commands[OPBASE + 6] = 0;
+		devpriv->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
+		devpriv->dux_commands[LOGBASE + 6] = 0;
 
 	case 16:
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
@@ -1042,63 +1042,63 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 			 */
 
 			/* branch back to state 0 */
-			udfs->dux_commands[LENBASE + 0] = 0x01;
+			devpriv->dux_commands[LENBASE + 0] = 0x01;
 			/* deceision state w/o data */
-			udfs->dux_commands[OPBASE + 0] = 0x01;
+			devpriv->dux_commands[OPBASE + 0] = 0x01;
 			/* reset */
-			udfs->dux_commands[OUTBASE + 0] =
+			devpriv->dux_commands[OUTBASE + 0] =
 			    (0xFF - 0x02) & rngmask;
 			/* RDY0 = 0 */
-			udfs->dux_commands[LOGBASE + 0] = 0x00;
+			devpriv->dux_commands[LOGBASE + 0] = 0x00;
 		} else {
 			/*
 			 * we just proceed to state 1
 			 */
 
 			/* 30us reset pulse */
-			udfs->dux_commands[LENBASE + 0] = 255;
-			udfs->dux_commands[OPBASE + 0] = 0;
+			devpriv->dux_commands[LENBASE + 0] = 255;
+			devpriv->dux_commands[OPBASE + 0] = 0;
 			/* reset */
-			udfs->dux_commands[OUTBASE + 0] =
+			devpriv->dux_commands[OUTBASE + 0] =
 			    (0xFF - 0x02) & rngmask;
-			udfs->dux_commands[LOGBASE + 0] = 0;
+			devpriv->dux_commands[LOGBASE + 0] = 0;
 		}
 
 		/* commit data to the FIFO */
-		udfs->dux_commands[LENBASE + 1] = 1;
+		devpriv->dux_commands[LENBASE + 1] = 1;
 		/* data */
-		udfs->dux_commands[OPBASE + 1] = 0x02;
-		udfs->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE + 1] = 0;
+		devpriv->dux_commands[OPBASE + 1] = 0x02;
+		devpriv->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
+		devpriv->dux_commands[LOGBASE + 1] = 0;
 
 		/* we have 2 states with duration 1 */
 		steps = steps - 2;
 
 		/* do the first part of the delay */
-		udfs->dux_commands[LENBASE + 2] = steps / 2;
-		udfs->dux_commands[OPBASE + 2] = 0;
-		udfs->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
-		udfs->dux_commands[LOGBASE + 2] = 0;
+		devpriv->dux_commands[LENBASE + 2] = steps / 2;
+		devpriv->dux_commands[OPBASE + 2] = 0;
+		devpriv->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
+		devpriv->dux_commands[LOGBASE + 2] = 0;
 
 		/* and the second part */
-		udfs->dux_commands[LENBASE + 3] = steps - steps / 2;
-		udfs->dux_commands[OPBASE + 3] = 0;
-		udfs->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE + 3] = 0;
+		devpriv->dux_commands[LENBASE + 3] = steps - steps / 2;
+		devpriv->dux_commands[OPBASE + 3] = 0;
+		devpriv->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
+		devpriv->dux_commands[LOGBASE + 3] = 0;
 
 		/* branch back to state 1 */
-		udfs->dux_commands[LENBASE + 4] = 0x09;
+		devpriv->dux_commands[LENBASE + 4] = 0x09;
 		/* deceision state w/o data */
-		udfs->dux_commands[OPBASE + 4] = 0x01;
-		udfs->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
+		devpriv->dux_commands[OPBASE + 4] = 0x01;
+		devpriv->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
 		/* doesn't matter */
-		udfs->dux_commands[LOGBASE + 4] = 0xFF;
+		devpriv->dux_commands[LOGBASE + 4] = 0xFF;
 
 		break;
 
 	default:
 		dev_err(dev->class_dev, "unsupported combination of channels\n");
-		up(&udfs->sem);
+		up(&devpriv->sem);
 		return -EFAULT;
 	}
 
@@ -1107,36 +1107,36 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	       dev->minor);
 #endif
 	/* 0 means that the AD commands are sent */
-	result = send_dux_commands(udfs, SENDADCOMMANDS);
+	result = send_dux_commands(devpriv, SENDADCOMMANDS);
 	if (result < 0) {
 		dev_err(dev->class_dev,
 			"adc command could not be submitted. Aborting...\n");
-		up(&udfs->sem);
+		up(&devpriv->sem);
 		return result;
 	}
 	if (cmd->stop_src == TRIG_COUNT) {
-		udfs->ai_sample_count = cmd->stop_arg * cmd->scan_end_arg;
-		if (udfs->ai_sample_count < 1) {
+		devpriv->ai_sample_count = cmd->stop_arg * cmd->scan_end_arg;
+		if (devpriv->ai_sample_count < 1) {
 			dev_err(dev->class_dev,
 				"(cmd->stop_arg)*(cmd->scan_end_arg)<1, aborting.\n");
-			up(&udfs->sem);
+			up(&devpriv->sem);
 			return -EFAULT;
 		}
-		udfs->ai_continous = 0;
+		devpriv->ai_continous = 0;
 	} else {
 		/* continous acquisition */
-		udfs->ai_continous = 1;
-		udfs->ai_sample_count = 0;
+		devpriv->ai_continous = 1;
+		devpriv->ai_sample_count = 0;
 	}
 
 	if ((cmd->start_src == TRIG_NOW) || (cmd->start_src == TRIG_EXT)) {
 		/* enable this acquisition operation */
-		udfs->ai_cmd_running = 1;
-		ret = usbduxfastsub_submit_InURBs(udfs);
+		devpriv->ai_cmd_running = 1;
+		ret = usbduxfastsub_submit_InURBs(devpriv);
 		if (ret < 0) {
-			udfs->ai_cmd_running = 0;
+			devpriv->ai_cmd_running = 0;
 			/* fixme: unlink here?? */
-			up(&udfs->sem);
+			up(&devpriv->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
@@ -1148,7 +1148,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		 */
 		s->async->inttrig = usbduxfast_ai_inttrig;
 	}
-	up(&udfs->sem);
+	up(&devpriv->sem);
 
 	return 0;
 }
@@ -1160,13 +1160,12 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data)
 {
+	struct usbduxfast_private *devpriv = dev->private;
 	int i, j, n, actual_length;
 	int chan, range, rngmask;
 	int err;
-	struct usbduxfastsub_s *udfs;
 
-	udfs = dev->private;
-	if (!udfs) {
+	if (!devpriv) {
 		dev_err(dev->class_dev, "%s: no usb dev.\n", __func__);
 		return -ENODEV;
 	}
@@ -1174,15 +1173,15 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	printk(KERN_DEBUG "comedi%d: ai_insn_read, insn->n=%d, "
 	       "insn->subdev=%d\n", dev->minor, insn->n, insn->subdev);
 #endif
-	down(&udfs->sem);
-	if (!udfs->probed) {
-		up(&udfs->sem);
+	down(&devpriv->sem);
+	if (!devpriv->probed) {
+		up(&devpriv->sem);
 		return -ENODEV;
 	}
-	if (udfs->ai_cmd_running) {
+	if (devpriv->ai_cmd_running) {
 		dev_err(dev->class_dev,
 			"ai_insn_read not possible. Async Command is running.\n");
-		up(&udfs->sem);
+		up(&devpriv->sem);
 		return -EBUSY;
 	}
 	/* sample one channel */
@@ -1196,101 +1195,101 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 		rngmask = 0xff;
 
 	/* commit data to the FIFO */
-	udfs->dux_commands[LENBASE + 0] = 1;
+	devpriv->dux_commands[LENBASE + 0] = 1;
 	/* data */
-	udfs->dux_commands[OPBASE + 0] = 0x02;
-	udfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
-	udfs->dux_commands[LOGBASE + 0] = 0;
+	devpriv->dux_commands[OPBASE + 0] = 0x02;
+	devpriv->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+	devpriv->dux_commands[LOGBASE + 0] = 0;
 
 	/* do the first part of the delay */
-	udfs->dux_commands[LENBASE + 1] = 12;
-	udfs->dux_commands[OPBASE + 1] = 0;
-	udfs->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
-	udfs->dux_commands[LOGBASE + 1] = 0;
-
-	udfs->dux_commands[LENBASE + 2] = 1;
-	udfs->dux_commands[OPBASE + 2] = 0;
-	udfs->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
-	udfs->dux_commands[LOGBASE + 2] = 0;
-
-	udfs->dux_commands[LENBASE + 3] = 1;
-	udfs->dux_commands[OPBASE + 3] = 0;
-	udfs->dux_commands[OUTBASE + 3] = 0xFE & rngmask;
-	udfs->dux_commands[LOGBASE + 3] = 0;
-
-	udfs->dux_commands[LENBASE + 4] = 1;
-	udfs->dux_commands[OPBASE + 4] = 0;
-	udfs->dux_commands[OUTBASE + 4] = 0xFE & rngmask;
-	udfs->dux_commands[LOGBASE + 4] = 0;
+	devpriv->dux_commands[LENBASE + 1] = 12;
+	devpriv->dux_commands[OPBASE + 1] = 0;
+	devpriv->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
+	devpriv->dux_commands[LOGBASE + 1] = 0;
+
+	devpriv->dux_commands[LENBASE + 2] = 1;
+	devpriv->dux_commands[OPBASE + 2] = 0;
+	devpriv->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
+	devpriv->dux_commands[LOGBASE + 2] = 0;
+
+	devpriv->dux_commands[LENBASE + 3] = 1;
+	devpriv->dux_commands[OPBASE + 3] = 0;
+	devpriv->dux_commands[OUTBASE + 3] = 0xFE & rngmask;
+	devpriv->dux_commands[LOGBASE + 3] = 0;
+
+	devpriv->dux_commands[LENBASE + 4] = 1;
+	devpriv->dux_commands[OPBASE + 4] = 0;
+	devpriv->dux_commands[OUTBASE + 4] = 0xFE & rngmask;
+	devpriv->dux_commands[LOGBASE + 4] = 0;
 
 	/* second part */
-	udfs->dux_commands[LENBASE + 5] = 12;
-	udfs->dux_commands[OPBASE + 5] = 0;
-	udfs->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
-	udfs->dux_commands[LOGBASE + 5] = 0;
+	devpriv->dux_commands[LENBASE + 5] = 12;
+	devpriv->dux_commands[OPBASE + 5] = 0;
+	devpriv->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
+	devpriv->dux_commands[LOGBASE + 5] = 0;
 
-	udfs->dux_commands[LENBASE + 6] = 1;
-	udfs->dux_commands[OPBASE + 6] = 0;
-	udfs->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
-	udfs->dux_commands[LOGBASE + 0] = 0;
+	devpriv->dux_commands[LENBASE + 6] = 1;
+	devpriv->dux_commands[OPBASE + 6] = 0;
+	devpriv->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
+	devpriv->dux_commands[LOGBASE + 0] = 0;
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi %d: sending commands to the usb device\n",
 	       dev->minor);
 #endif
 	/* 0 means that the AD commands are sent */
-	err = send_dux_commands(udfs, SENDADCOMMANDS);
+	err = send_dux_commands(devpriv, SENDADCOMMANDS);
 	if (err < 0) {
 		dev_err(dev->class_dev,
 			"adc command could not be submitted. Aborting...\n");
-		up(&udfs->sem);
+		up(&devpriv->sem);
 		return err;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast: submitting in-urb: "
-	       "0x%p,0x%p\n", udfs->comedidev->minor, udfs->urbIn->context,
-	       udfs->urbIn->dev);
+	       "0x%p,0x%p\n", devpriv->comedidev->minor, devpriv->urbIn->context,
+	       devpriv->urbIn->dev);
 #endif
 	for (i = 0; i < PACKETS_TO_IGNORE; i++) {
-		err = usb_bulk_msg(udfs->usb,
-				   usb_rcvbulkpipe(udfs->usb, BULKINEP),
-				   udfs->transfer_buffer, SIZEINBUF,
+		err = usb_bulk_msg(devpriv->usb,
+				   usb_rcvbulkpipe(devpriv->usb, BULKINEP),
+				   devpriv->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
 			dev_err(dev->class_dev, "insn timeout. No data.\n");
-			up(&udfs->sem);
+			up(&devpriv->sem);
 			return err;
 		}
 	}
 	/* data points */
 	for (i = 0; i < insn->n;) {
-		err = usb_bulk_msg(udfs->usb,
-				   usb_rcvbulkpipe(udfs->usb, BULKINEP),
-				   udfs->transfer_buffer, SIZEINBUF,
+		err = usb_bulk_msg(devpriv->usb,
+				   usb_rcvbulkpipe(devpriv->usb, BULKINEP),
+				   devpriv->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
 			dev_err(dev->class_dev, "insn data error: %d\n", err);
-			up(&udfs->sem);
+			up(&devpriv->sem);
 			return err;
 		}
 		n = actual_length / sizeof(uint16_t);
 		if ((n % 16) != 0) {
 			dev_err(dev->class_dev, "insn data packet corrupted.\n");
-			up(&udfs->sem);
+			up(&devpriv->sem);
 			return -EINVAL;
 		}
 		for (j = chan; (j < n) && (i < insn->n); j = j + 16) {
-			data[i] = ((uint16_t *) (udfs->transfer_buffer))[j];
+			data[i] = ((uint16_t *) (devpriv->transfer_buffer))[j];
 			i++;
 		}
 	}
-	up(&udfs->sem);
+	up(&devpriv->sem);
 	return i;
 }
 
 #define FIRMWARE_MAX_LEN 0x2000
 
-static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
+static int firmwareUpload(struct usbduxfast_private *devpriv,
 			  const u8 *firmwareBinary, int sizeFirmware)
 {
 	int ret;
@@ -1300,7 +1299,7 @@ static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
 		return 0;
 
 	if (sizeFirmware > FIRMWARE_MAX_LEN) {
-		dev_err(&usbduxfastsub->intf->dev,
+		dev_err(&devpriv->intf->dev,
 			"comedi_: usbduxfast firmware binary it too large for FX2.\n");
 		return -ENOMEM;
 	}
@@ -1308,29 +1307,29 @@ static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
 	/* we generate a local buffer for the firmware */
 	fwBuf = kmemdup(firmwareBinary, sizeFirmware, GFP_KERNEL);
 	if (!fwBuf) {
-		dev_err(&usbduxfastsub->intf->dev,
+		dev_err(&devpriv->intf->dev,
 			"comedi_: mem alloc for firmware failed\n");
 		return -ENOMEM;
 	}
 
-	ret = usbduxfastsub_stop(usbduxfastsub);
+	ret = usbduxfastsub_stop(devpriv);
 	if (ret < 0) {
-		dev_err(&usbduxfastsub->intf->dev,
+		dev_err(&devpriv->intf->dev,
 			"comedi_: can not stop firmware\n");
 		kfree(fwBuf);
 		return ret;
 	}
 
-	ret = usbduxfastsub_upload(usbduxfastsub, fwBuf, 0, sizeFirmware);
+	ret = usbduxfastsub_upload(devpriv, fwBuf, 0, sizeFirmware);
 	if (ret < 0) {
-		dev_err(&usbduxfastsub->intf->dev,
+		dev_err(&devpriv->intf->dev,
 			"comedi_: firmware upload failed\n");
 		kfree(fwBuf);
 		return ret;
 	}
-	ret = usbduxfastsub_start(usbduxfastsub);
+	ret = usbduxfastsub_start(devpriv);
 	if (ret < 0) {
-		dev_err(&usbduxfastsub->intf->dev,
+		dev_err(&devpriv->intf->dev,
 			"comedi_: can not start firmware\n");
 		kfree(fwBuf);
 		return ret;
@@ -1339,58 +1338,58 @@ static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
 	return 0;
 }
 
-static void tidy_up(struct usbduxfastsub_s *udfs)
+static void tidy_up(struct usbduxfast_private *devpriv)
 {
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi_: usbduxfast: tiding up\n");
 #endif
 
-	if (!udfs)
+	if (!devpriv)
 		return;
 
 	/* shows the usb subsystem that the driver is down */
-	if (udfs->intf)
-		usb_set_intfdata(udfs->intf, NULL);
+	if (devpriv->intf)
+		usb_set_intfdata(devpriv->intf, NULL);
 
-	udfs->probed = 0;
+	devpriv->probed = 0;
 
-	if (udfs->urbIn) {
+	if (devpriv->urbIn) {
 		/* waits until a running transfer is over */
-		usb_kill_urb(udfs->urbIn);
+		usb_kill_urb(devpriv->urbIn);
 
-		kfree(udfs->transfer_buffer);
-		udfs->transfer_buffer = NULL;
+		kfree(devpriv->transfer_buffer);
+		devpriv->transfer_buffer = NULL;
 
-		usb_free_urb(udfs->urbIn);
-		udfs->urbIn = NULL;
+		usb_free_urb(devpriv->urbIn);
+		devpriv->urbIn = NULL;
 	}
 
-	kfree(udfs->insnBuffer);
-	udfs->insnBuffer = NULL;
+	kfree(devpriv->insnBuffer);
+	devpriv->insnBuffer = NULL;
 
-	kfree(udfs->dux_commands);
-	udfs->dux_commands = NULL;
+	kfree(devpriv->dux_commands);
+	devpriv->dux_commands = NULL;
 
-	udfs->ai_cmd_running = 0;
+	devpriv->ai_cmd_running = 0;
 }
 
 static int usbduxfast_attach_common(struct comedi_device *dev,
-				    struct usbduxfastsub_s *udfs)
+				    struct usbduxfast_private *devpriv)
 {
 	int ret;
 	struct comedi_subdevice *s;
 
-	down(&udfs->sem);
+	down(&devpriv->sem);
 	/* pointer back to the corresponding comedi device */
-	udfs->comedidev = dev;
+	devpriv->comedidev = dev;
 
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret) {
-		up(&udfs->sem);
+		up(&devpriv->sem);
 		return ret;
 	}
 	/* private structure is also simply the usb-structure */
-	dev->private = udfs;
+	dev->private = devpriv;
 	/* the first subdevice is the A/D converter */
 	s = &dev->subdevices[SUBDEV_AD];
 	/*
@@ -1418,8 +1417,8 @@ static int usbduxfast_attach_common(struct comedi_device *dev,
 	/* range table to convert to physical units */
 	s->range_table = &range_usbduxfast_ai_range;
 	/* finally decide that it's attached */
-	udfs->attached = 1;
-	up(&udfs->sem);
+	devpriv->attached = 1;
+	up(&devpriv->sem);
 	dev_info(dev->class_dev, "successfully attached to usbduxfast.\n");
 	return 0;
 }
@@ -1428,38 +1427,38 @@ static int usbduxfast_auto_attach(struct comedi_device *dev,
 				  unsigned long context_unused)
 {
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
+	struct usbduxfast_private *devpriv;
 	int ret;
-	struct usbduxfastsub_s *udfs;
 
 	dev->private = NULL;
 	down(&start_stop_sem);
-	udfs = usb_get_intfdata(intf);
-	if (!udfs || !udfs->probed) {
+	devpriv = usb_get_intfdata(intf);
+	if (!devpriv || !devpriv->probed) {
 		dev_err(dev->class_dev,
 			"usbduxfast: error: auto_attach failed, not connected\n");
 		ret = -ENODEV;
-	} else if (udfs->attached) {
+	} else if (devpriv->attached) {
 		dev_err(dev->class_dev,
 		       "usbduxfast: error: auto_attach failed, already attached\n");
 		ret = -ENODEV;
 	} else
-		ret = usbduxfast_attach_common(dev, udfs);
+		ret = usbduxfast_attach_common(dev, devpriv);
 	up(&start_stop_sem);
 	return ret;
 }
 
 static void usbduxfast_detach(struct comedi_device *dev)
 {
-	struct usbduxfastsub_s *usb = dev->private;
+	struct usbduxfast_private *devpriv = dev->private;
 
-	if (usb) {
-		down(&usb->sem);
+	if (devpriv) {
+		down(&devpriv->sem);
 		down(&start_stop_sem);
 		dev->private = NULL;
-		usb->attached = 0;
-		usb->comedidev = NULL;
+		devpriv->attached = 0;
+		devpriv->comedidev = NULL;
 		up(&start_stop_sem);
-		up(&usb->sem);
+		up(&devpriv->sem);
 	}
 }
 
@@ -1473,7 +1472,7 @@ static struct comedi_driver usbduxfast_driver = {
 static int usbduxfast_request_firmware(struct usb_interface *intf)
 {
 	struct usb_device *usb = interface_to_usbdev(intf);
-	struct usbduxfastsub_s *devpriv = usb_get_intfdata(intf);
+	struct usbduxfast_private *devpriv = usb_get_intfdata(intf);
 	const struct firmware *fw;
 	int ret;
 
@@ -1491,7 +1490,7 @@ static int usbduxfast_usb_probe(struct usb_interface *intf,
 				const struct usb_device_id *id)
 {
 	struct usb_device *usb = interface_to_usbdev(intf);
-	struct usbduxfastsub_s *devpriv = NULL;
+	struct usbduxfast_private *devpriv = NULL;
 	int i;
 	int ret;
 
@@ -1580,14 +1579,14 @@ static int usbduxfast_usb_probe(struct usb_interface *intf,
 
 static void usbduxfast_usb_disconnect(struct usb_interface *intf)
 {
-	struct usbduxfastsub_s *udfs = usb_get_intfdata(intf);
+	struct usbduxfast_private *devpriv = usb_get_intfdata(intf);
 	struct usb_device *usb = interface_to_usbdev(intf);
 
-	if (!udfs) {
+	if (!devpriv) {
 		dev_err(&intf->dev, "disconnect called with null pointer.\n");
 		return;
 	}
-	if (udfs->usb != usb) {
+	if (devpriv->usb != usb) {
 		dev_err(&intf->dev, "BUG! called with wrong ptr!!!\n");
 		return;
 	}
@@ -1595,9 +1594,9 @@ static void usbduxfast_usb_disconnect(struct usb_interface *intf)
 	comedi_usb_auto_unconfig(intf);
 
 	down(&start_stop_sem);
-	down(&udfs->sem);
-	tidy_up(udfs);
-	up(&udfs->sem);
+	down(&devpriv->sem);
+	tidy_up(devpriv);
+	up(&devpriv->sem);
 	up(&start_stop_sem);
 
 #ifdef CONFIG_COMEDI_DEBUG

commit e4a8ecc0005e41b110dddf45926f47f97b08b907
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:26:38 2013 -0700

    staging: comedi: usbduxfast: rename usb_device variables
    
    For aesthetic reasons, globally rename the variables used for the
    struct usb_device * in this driver to simply 'usb'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index e8e8f7b471ea..cf05d08ee9ec 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -160,7 +160,7 @@ static const struct comedi_lrange range_usbduxfast_ai_range = {
 struct usbduxfastsub_s {
 	int attached;		/* is attached? */
 	int probed;		/* is it associated with a subdevice? */
-	struct usb_device *usbdev;	/* pointer to the usb-device */
+	struct usb_device *usb;	/* pointer to the usb-device */
 	struct urb *urbIn;	/* BULK-transfer handling: urb */
 	int8_t *transfer_buffer;
 	int16_t *insnBuffer;	/* input buffer for single insn */
@@ -210,8 +210,8 @@ static int send_dux_commands(struct usbduxfastsub_s *udfs, int cmd_type)
 	printk("\n");
 #endif
 
-	tmp = usb_bulk_msg(udfs->usbdev,
-			   usb_sndbulkpipe(udfs->usbdev, CHANNELLISTEP),
+	tmp = usb_bulk_msg(udfs->usb,
+			   usb_sndbulkpipe(udfs->usb, CHANNELLISTEP),
 			   udfs->dux_commands, SIZEOFDUXBUFFER, &nsent, 10000);
 	if (tmp < 0)
 		dev_err(&udfs->intf->dev,
@@ -416,7 +416,7 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 	 * command is still running
 	 * resubmit urb for BULK transfer
 	 */
-	urb->dev = udfs->usbdev;
+	urb->dev = udfs->usb;
 	urb->status = 0;
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
@@ -441,7 +441,7 @@ static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 	/* 7f92 to zero */
 	*local_transfer_buffer = 0;
 	/* bRequest, "Firmware" */
-	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0),
+	ret = usb_control_msg(udfs->usb, usb_sndctrlpipe(udfs->usb, 0),
 			      USBDUXFASTSUB_FIRMWARE,
 			      VENDOR_DIR_OUT,	  /* bmRequestType */
 			      USBDUXFASTSUB_CPUCS,    /* Value */
@@ -470,7 +470,7 @@ static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 	/* 7f92 to one */
 	*local_transfer_buffer = 1;
 	/* bRequest, "Firmware" */
-	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0),
+	ret = usb_control_msg(udfs->usb, usb_sndctrlpipe(udfs->usb, 0),
 			      USBDUXFASTSUB_FIRMWARE,
 			      VENDOR_DIR_OUT,	/* bmRequestType */
 			      USBDUXFASTSUB_CPUCS,	/* Value */
@@ -497,7 +497,7 @@ static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 	       startAddr, local_transfer_buffer[0]);
 #endif
 	/* brequest, firmware */
-	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0),
+	ret = usb_control_msg(udfs->usb, usb_sndctrlpipe(udfs->usb, 0),
 			      USBDUXFASTSUB_FIRMWARE,
 			      VENDOR_DIR_OUT,	/* bmRequestType */
 			      startAddr,	/* value */
@@ -526,8 +526,8 @@ static int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
 	if (!udfs)
 		return -EFAULT;
 
-	usb_fill_bulk_urb(udfs->urbIn, udfs->usbdev,
-			  usb_rcvbulkpipe(udfs->usbdev, BULKINEP),
+	usb_fill_bulk_urb(udfs->urbIn, udfs->usb,
+			  usb_rcvbulkpipe(udfs->usb, BULKINEP),
 			  udfs->transfer_buffer,
 			  SIZEINBUF, usbduxfastsub_ai_Irq, udfs->comedidev);
 
@@ -1252,8 +1252,8 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	       udfs->urbIn->dev);
 #endif
 	for (i = 0; i < PACKETS_TO_IGNORE; i++) {
-		err = usb_bulk_msg(udfs->usbdev,
-				   usb_rcvbulkpipe(udfs->usbdev, BULKINEP),
+		err = usb_bulk_msg(udfs->usb,
+				   usb_rcvbulkpipe(udfs->usb, BULKINEP),
 				   udfs->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
@@ -1264,8 +1264,8 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	}
 	/* data points */
 	for (i = 0; i < insn->n;) {
-		err = usb_bulk_msg(udfs->usbdev,
-				   usb_rcvbulkpipe(udfs->usbdev, BULKINEP),
+		err = usb_bulk_msg(udfs->usb,
+				   usb_rcvbulkpipe(udfs->usb, BULKINEP),
 				   udfs->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
@@ -1490,12 +1490,12 @@ static int usbduxfast_request_firmware(struct usb_interface *intf)
 static int usbduxfast_usb_probe(struct usb_interface *intf,
 				const struct usb_device_id *id)
 {
-	struct usb_device *udev = interface_to_usbdev(intf);
+	struct usb_device *usb = interface_to_usbdev(intf);
 	struct usbduxfastsub_s *devpriv = NULL;
 	int i;
 	int ret;
 
-	if (udev->speed != USB_SPEED_HIGH) {
+	if (usb->speed != USB_SPEED_HIGH) {
 		dev_err(&intf->dev,
 			"This driver needs USB 2.0 to operate. Aborting...\n");
 		return -ENODEV;
@@ -1519,7 +1519,7 @@ static int usbduxfast_usb_probe(struct usb_interface *intf,
 	}
 
 	sema_init(&devpriv->sem, 1);
-	devpriv->usbdev = udev;
+	devpriv->usb = usb;
 	devpriv->intf = intf;
 	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;
 	usb_set_intfdata(intf, devpriv);
@@ -1538,7 +1538,7 @@ static int usbduxfast_usb_probe(struct usb_interface *intf,
 		return -ENOMEM;
 	}
 
-	i = usb_set_interface(devpriv->usbdev, devpriv->ifnum, 1);
+	i = usb_set_interface(devpriv->usb, devpriv->ifnum, 1);
 	if (i < 0) {
 		dev_err(&intf->dev,
 			"could not switch to alternate setting 1\n");
@@ -1581,13 +1581,13 @@ static int usbduxfast_usb_probe(struct usb_interface *intf,
 static void usbduxfast_usb_disconnect(struct usb_interface *intf)
 {
 	struct usbduxfastsub_s *udfs = usb_get_intfdata(intf);
-	struct usb_device *udev = interface_to_usbdev(intf);
+	struct usb_device *usb = interface_to_usbdev(intf);
 
 	if (!udfs) {
 		dev_err(&intf->dev, "disconnect called with null pointer.\n");
 		return;
 	}
-	if (udfs->usbdev != udev) {
+	if (udfs->usb != usb) {
 		dev_err(&intf->dev, "BUG! called with wrong ptr!!!\n");
 		return;
 	}

commit a35fd8a17b4c2e18be025571f94b2a0f5403741f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:25:56 2013 -0700

    staging: comedi: usbduxfast: rename usb_interface variables
    
    For aesthetic reasons, globally rename the variables used for the
    struct usb_interface * in this driver to simply 'intf'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index d6ec60c3e73e..e8e8f7b471ea 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -165,7 +165,7 @@ struct usbduxfastsub_s {
 	int8_t *transfer_buffer;
 	int16_t *insnBuffer;	/* input buffer for single insn */
 	int ifnum;		/* interface number */
-	struct usb_interface *interface;	/* interface structure */
+	struct usb_interface *intf;	/* interface structure */
 	/* comedi device for the interrupt context */
 	struct comedi_device *comedidev;
 	short int ai_cmd_running;	/* asynchronous command is running */
@@ -214,7 +214,7 @@ static int send_dux_commands(struct usbduxfastsub_s *udfs, int cmd_type)
 			   usb_sndbulkpipe(udfs->usbdev, CHANNELLISTEP),
 			   udfs->dux_commands, SIZEOFDUXBUFFER, &nsent, 10000);
 	if (tmp < 0)
-		dev_err(&udfs->interface->dev,
+		dev_err(&udfs->intf->dev,
 			"could not transmit dux_commands to the usb-device, err=%d\n",
 			tmp);
 	return tmp;
@@ -451,7 +451,7 @@ static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 			      1,      /* Length */
 			      EZTIMEOUT);    /* Timeout */
 	if (ret < 0)
-		dev_err(&udfs->interface->dev,
+		dev_err(&udfs->intf->dev,
 			"control msg failed (start)\n");
 
 	kfree(local_transfer_buffer);
@@ -478,7 +478,7 @@ static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 			      local_transfer_buffer, 1,	/* Length */
 			      EZTIMEOUT);	/* Timeout */
 	if (ret < 0)
-		dev_err(&udfs->interface->dev,
+		dev_err(&udfs->intf->dev,
 			"control msg failed (stop)\n");
 
 	kfree(local_transfer_buffer);
@@ -512,7 +512,7 @@ static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 #endif
 
 	if (ret < 0) {
-		dev_err(&udfs->interface->dev, "uppload failed\n");
+		dev_err(&udfs->intf->dev, "uppload failed\n");
 		return ret;
 	}
 
@@ -538,7 +538,7 @@ static int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
 #endif
 	ret = usb_submit_urb(udfs->urbIn, GFP_ATOMIC);
 	if (ret) {
-		dev_err(&udfs->interface->dev,
+		dev_err(&udfs->intf->dev,
 			"ai: usb_submit_urb error %d\n", ret);
 		return ret;
 	}
@@ -1300,7 +1300,7 @@ static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
 		return 0;
 
 	if (sizeFirmware > FIRMWARE_MAX_LEN) {
-		dev_err(&usbduxfastsub->interface->dev,
+		dev_err(&usbduxfastsub->intf->dev,
 			"comedi_: usbduxfast firmware binary it too large for FX2.\n");
 		return -ENOMEM;
 	}
@@ -1308,14 +1308,14 @@ static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
 	/* we generate a local buffer for the firmware */
 	fwBuf = kmemdup(firmwareBinary, sizeFirmware, GFP_KERNEL);
 	if (!fwBuf) {
-		dev_err(&usbduxfastsub->interface->dev,
+		dev_err(&usbduxfastsub->intf->dev,
 			"comedi_: mem alloc for firmware failed\n");
 		return -ENOMEM;
 	}
 
 	ret = usbduxfastsub_stop(usbduxfastsub);
 	if (ret < 0) {
-		dev_err(&usbduxfastsub->interface->dev,
+		dev_err(&usbduxfastsub->intf->dev,
 			"comedi_: can not stop firmware\n");
 		kfree(fwBuf);
 		return ret;
@@ -1323,14 +1323,14 @@ static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
 
 	ret = usbduxfastsub_upload(usbduxfastsub, fwBuf, 0, sizeFirmware);
 	if (ret < 0) {
-		dev_err(&usbduxfastsub->interface->dev,
+		dev_err(&usbduxfastsub->intf->dev,
 			"comedi_: firmware upload failed\n");
 		kfree(fwBuf);
 		return ret;
 	}
 	ret = usbduxfastsub_start(usbduxfastsub);
 	if (ret < 0) {
-		dev_err(&usbduxfastsub->interface->dev,
+		dev_err(&usbduxfastsub->intf->dev,
 			"comedi_: can not start firmware\n");
 		kfree(fwBuf);
 		return ret;
@@ -1349,8 +1349,8 @@ static void tidy_up(struct usbduxfastsub_s *udfs)
 		return;
 
 	/* shows the usb subsystem that the driver is down */
-	if (udfs->interface)
-		usb_set_intfdata(udfs->interface, NULL);
+	if (udfs->intf)
+		usb_set_intfdata(udfs->intf, NULL);
 
 	udfs->probed = 0;
 
@@ -1427,13 +1427,13 @@ static int usbduxfast_attach_common(struct comedi_device *dev,
 static int usbduxfast_auto_attach(struct comedi_device *dev,
 				  unsigned long context_unused)
 {
-	struct usb_interface *uinterf = comedi_to_usb_interface(dev);
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	int ret;
 	struct usbduxfastsub_s *udfs;
 
 	dev->private = NULL;
 	down(&start_stop_sem);
-	udfs = usb_get_intfdata(uinterf);
+	udfs = usb_get_intfdata(intf);
 	if (!udfs || !udfs->probed) {
 		dev_err(dev->class_dev,
 			"usbduxfast: error: auto_attach failed, not connected\n");
@@ -1487,16 +1487,16 @@ static int usbduxfast_request_firmware(struct usb_interface *intf)
 	return ret;
 }
 
-static int usbduxfast_usb_probe(struct usb_interface *uinterf,
+static int usbduxfast_usb_probe(struct usb_interface *intf,
 				const struct usb_device_id *id)
 {
-	struct usb_device *udev = interface_to_usbdev(uinterf);
+	struct usb_device *udev = interface_to_usbdev(intf);
 	struct usbduxfastsub_s *devpriv = NULL;
 	int i;
 	int ret;
 
 	if (udev->speed != USB_SPEED_HIGH) {
-		dev_err(&uinterf->dev,
+		dev_err(&intf->dev,
 			"This driver needs USB 2.0 to operate. Aborting...\n");
 		return -ENODEV;
 	}
@@ -1512,7 +1512,7 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 
 	/* no more space */
 	if (!devpriv) {
-		dev_err(&uinterf->dev,
+		dev_err(&intf->dev,
 			"Too many usbduxfast-devices connected.\n");
 		up(&start_stop_sem);
 		return -EMFILE;
@@ -1520,9 +1520,9 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 
 	sema_init(&devpriv->sem, 1);
 	devpriv->usbdev = udev;
-	devpriv->interface = uinterf;
-	devpriv->ifnum = uinterf->altsetting->desc.bInterfaceNumber;
-	usb_set_intfdata(uinterf, devpriv);
+	devpriv->intf = intf;
+	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;
+	usb_set_intfdata(intf, devpriv);
 
 	devpriv->dux_commands = kmalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
 	if (!devpriv->dux_commands) {
@@ -1540,7 +1540,7 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 
 	i = usb_set_interface(devpriv->usbdev, devpriv->ifnum, 1);
 	if (i < 0) {
-		dev_err(&uinterf->dev,
+		dev_err(&intf->dev,
 			"could not switch to alternate setting 1\n");
 		tidy_up(devpriv);
 		up(&start_stop_sem);
@@ -1549,7 +1549,7 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 
 	devpriv->urbIn = usb_alloc_urb(0, GFP_KERNEL);
 	if (!devpriv->urbIn) {
-		dev_err(&uinterf->dev, "Could not alloc. urb\n");
+		dev_err(&intf->dev, "Could not alloc. urb\n");
 		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -1569,13 +1569,13 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 	 * Request, and upload, the firmware so we can
 	 * complete the comedi_driver (*auto_attach).
 	 */
-	ret = usbduxfast_request_firmware(uinterf);
+	ret = usbduxfast_request_firmware(intf);
 	if (ret) {
-		dev_err(&uinterf->dev, "could not load firmware (err=%d)\n", ret);
+		dev_err(&intf->dev, "could not load firmware (err=%d)\n", ret);
 		return ret;
 	}
 
-	return comedi_usb_auto_config(uinterf, &usbduxfast_driver, 0);
+	return comedi_usb_auto_config(intf, &usbduxfast_driver, 0);
 }
 
 static void usbduxfast_usb_disconnect(struct usb_interface *intf)

commit ca88c09f0e72148e42f45291841498e082cb2908
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:25:22 2013 -0700

    staging: comedi: usbduxfast: use a local var for the usbduxfastsub_s
    
    Add a local variable to hold the pointer to the place in the
    usbduxfast array the is being configured for the device.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 96ddfdab1969..d6ec60c3e73e 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1491,8 +1491,8 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 				const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
+	struct usbduxfastsub_s *devpriv = NULL;
 	int i;
-	int index;
 	int ret;
 
 	if (udev->speed != USB_SPEED_HIGH) {
@@ -1503,78 +1503,66 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 
 	down(&start_stop_sem);
 	/* look for a free place in the usbduxfast array */
-	index = -1;
 	for (i = 0; i < NUMUSBDUXFAST; i++) {
 		if (!usbduxfastsub[i].probed) {
-			index = i;
+			devpriv = &usbduxfastsub[i];
 			break;
 		}
 	}
 
 	/* no more space */
-	if (index == -1) {
+	if (!devpriv) {
 		dev_err(&uinterf->dev,
 			"Too many usbduxfast-devices connected.\n");
 		up(&start_stop_sem);
 		return -EMFILE;
 	}
 
-	sema_init(&(usbduxfastsub[index].sem), 1);
-	/* save a pointer to the usb device */
-	usbduxfastsub[index].usbdev = udev;
+	sema_init(&devpriv->sem, 1);
+	devpriv->usbdev = udev;
+	devpriv->interface = uinterf;
+	devpriv->ifnum = uinterf->altsetting->desc.bInterfaceNumber;
+	usb_set_intfdata(uinterf, devpriv);
 
-	/* save the interface itself */
-	usbduxfastsub[index].interface = uinterf;
-	/* get the interface number from the interface */
-	usbduxfastsub[index].ifnum = uinterf->altsetting->desc.bInterfaceNumber;
-	/*
-	 * hand the private data over to the usb subsystem
-	 * will be needed for disconnect
-	 */
-	usb_set_intfdata(uinterf, &(usbduxfastsub[index]));
-
-	/* create space for the commands going to the usb device */
-	usbduxfastsub[index].dux_commands = kmalloc(SIZEOFDUXBUFFER,
-						    GFP_KERNEL);
-	if (!usbduxfastsub[index].dux_commands) {
-		tidy_up(&(usbduxfastsub[index]));
+	devpriv->dux_commands = kmalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
+	if (!devpriv->dux_commands) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	/* create space of the instruction buffer */
-	usbduxfastsub[index].insnBuffer = kmalloc(SIZEINSNBUF, GFP_KERNEL);
-	if (!usbduxfastsub[index].insnBuffer) {
-		tidy_up(&(usbduxfastsub[index]));
+
+	devpriv->insnBuffer = kmalloc(SIZEINSNBUF, GFP_KERNEL);
+	if (!devpriv->insnBuffer) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	/* setting to alternate setting 1: enabling bulk ep */
-	i = usb_set_interface(usbduxfastsub[index].usbdev,
-			      usbduxfastsub[index].ifnum, 1);
+
+	i = usb_set_interface(devpriv->usbdev, devpriv->ifnum, 1);
 	if (i < 0) {
 		dev_err(&uinterf->dev,
-			"usbduxfast%d: could not switch to alternate setting 1.\n",
-			index);
-		tidy_up(&(usbduxfastsub[index]));
+			"could not switch to alternate setting 1\n");
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENODEV;
 	}
-	usbduxfastsub[index].urbIn = usb_alloc_urb(0, GFP_KERNEL);
-	if (!usbduxfastsub[index].urbIn) {
-		dev_err(&uinterf->dev,
-			"usbduxfast%d: Could not alloc. urb\n", index);
-		tidy_up(&(usbduxfastsub[index]));
+
+	devpriv->urbIn = usb_alloc_urb(0, GFP_KERNEL);
+	if (!devpriv->urbIn) {
+		dev_err(&uinterf->dev, "Could not alloc. urb\n");
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	usbduxfastsub[index].transfer_buffer = kmalloc(SIZEINBUF, GFP_KERNEL);
-	if (!usbduxfastsub[index].transfer_buffer) {
-		tidy_up(&(usbduxfastsub[index]));
+
+	devpriv->transfer_buffer = kmalloc(SIZEINBUF, GFP_KERNEL);
+	if (!devpriv->transfer_buffer) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	/* we've reached the bottom of the function */
-	usbduxfastsub[index].probed = 1;
+
+	devpriv->probed = 1;
 	up(&start_stop_sem);
 
 	/*

commit 64bf88bfd96958339b4d2b18589cfd8a8fd1c5e6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:24:41 2013 -0700

    staging: comedi: usbduxfast: remove COMEDI_DEBUG noise in usb (*probe)
    
    The COMEDI_DEBUG noise in the usb (*probe) is just added function
    trace noise. Remove it along with the final dev_info().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 31de05d1fb75..96ddfdab1969 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1500,10 +1500,7 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 			"This driver needs USB 2.0 to operate. Aborting...\n");
 		return -ENODEV;
 	}
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi_: usbduxfast_: finding a free structure for "
-	       "the usb-device\n");
-#endif
+
 	down(&start_stop_sem);
 	/* look for a free place in the usbduxfast array */
 	index = -1;
@@ -1521,10 +1518,6 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 		up(&start_stop_sem);
 		return -EMFILE;
 	}
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi_: usbduxfast: usbduxfastsub[%d] is ready to "
-	       "connect to comedi.\n", index);
-#endif
 
 	sema_init(&(usbduxfastsub[index].sem), 1);
 	/* save a pointer to the usb device */
@@ -1540,10 +1533,6 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 	 */
 	usb_set_intfdata(uinterf, &(usbduxfastsub[index]));
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi_: usbduxfast: ifnum=%d\n",
-	       usbduxfastsub[index].ifnum);
-#endif
 	/* create space for the commands going to the usb device */
 	usbduxfastsub[index].dux_commands = kmalloc(SIZEOFDUXBUFFER,
 						    GFP_KERNEL);
@@ -1598,9 +1587,6 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 		return ret;
 	}
 
-	dev_info(&uinterf->dev,
-		 "usbduxfast%d has been successfully initialized.\n", index);
-
 	return comedi_usb_auto_config(uinterf, &usbduxfast_driver, 0);
 }
 

commit 998bb7be46b25b383a8dbcc80ee2ed0700d0cdc8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 14 13:24:17 2013 -0700

    staging: comedi: usbduxfast: request firmware synchronously
    
    Change the request_firmware_nowait() to a request_firmware() so
    that the usb_driver (*probe) and continue with the comedi_driver
    (*auto_attach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 8a6427330de0..31de05d1fb75 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1470,31 +1470,21 @@ static struct comedi_driver usbduxfast_driver = {
 	.detach		= usbduxfast_detach,
 };
 
-static void usbduxfast_firmware_request_complete_handler(const struct firmware
-							 *fw, void *context)
+static int usbduxfast_request_firmware(struct usb_interface *intf)
 {
-	struct usbduxfastsub_s *usbduxfastsub_tmp = context;
-	struct usb_interface *uinterf = usbduxfastsub_tmp->interface;
+	struct usb_device *usb = interface_to_usbdev(intf);
+	struct usbduxfastsub_s *devpriv = usb_get_intfdata(intf);
+	const struct firmware *fw;
 	int ret;
 
-	if (fw == NULL)
-		return;
-
-	/*
-	 * we need to upload the firmware here because fw will be
-	 * freed once we've left this function
-	 */
-	ret = firmwareUpload(usbduxfastsub_tmp, fw->data, fw->size);
-
-	if (ret) {
-		dev_err(&uinterf->dev,
-			"Could not upload firmware (err=%d)\n", ret);
-		goto out;
-	}
+	ret = request_firmware(&fw, FIRMWARE, &usb->dev);
+	if (ret)
+		return ret;
 
-	comedi_usb_auto_config(uinterf, &usbduxfast_driver, 0);
- out:
+	ret = firmwareUpload(devpriv, fw->data, fw->size);
 	release_firmware(fw);
+
+	return ret;
 }
 
 static int usbduxfast_usb_probe(struct usb_interface *uinterf,
@@ -1598,14 +1588,11 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 	usbduxfastsub[index].probed = 1;
 	up(&start_stop_sem);
 
-	ret = request_firmware_nowait(THIS_MODULE,
-				      FW_ACTION_HOTPLUG,
-				      FIRMWARE,
-				      &udev->dev,
-				      GFP_KERNEL,
-				      usbduxfastsub + index,
-				      usbduxfast_firmware_request_complete_handler);
-
+	/*
+	 * Request, and upload, the firmware so we can
+	 * complete the comedi_driver (*auto_attach).
+	 */
+	ret = usbduxfast_request_firmware(uinterf);
 	if (ret) {
 		dev_err(&uinterf->dev, "could not load firmware (err=%d)\n", ret);
 		return ret;
@@ -1613,8 +1600,8 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 
 	dev_info(&uinterf->dev,
 		 "usbduxfast%d has been successfully initialized.\n", index);
-	/* success */
-	return 0;
+
+	return comedi_usb_auto_config(uinterf, &usbduxfast_driver, 0);
 }
 
 static void usbduxfast_usb_disconnect(struct usb_interface *intf)

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 7f95af33085d..8a6427330de0 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -10,10 +10,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 /*

commit 5993f3a2692eed3c74c86882155b8703a0060ad5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 8 10:57:35 2013 -0700

    staging: comedi: remove unnecessary dev->board_name initialization
    
    The dev->board_name is now initialized by the comedi core before calling
    the(*attach) or (*auto_attach) function in a driver. As long as the driver
    does no additional probing, it's no longer necessary initialize the board_name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 1ba0e3df492d..7f95af33085d 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1387,7 +1387,7 @@ static int usbduxfast_attach_common(struct comedi_device *dev,
 	down(&udfs->sem);
 	/* pointer back to the corresponding comedi device */
 	udfs->comedidev = dev;
-	dev->board_name = "usbduxfast";
+
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret) {
 		up(&udfs->sem);

commit 161f440c8d915181b34f5a64f52a543beca6b1e9
Author: Kumar Amit Mehta <gmate.amit@gmail.com>
Date:   Fri Feb 22 10:07:30 2013 -0800

    staging: comedi: drivers: usbduxfast.c: fix for DMA buffers on stack
    
    fix for instances of DMA buffer on stack(being passed to usb_control_msg) for
    the USB-DUXfast Board driver.
    
    Signed-off-by: Kumar Amit Mehta <gmate.amit@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 4bf5dd094dc9..1ba0e3df492d 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -436,10 +436,14 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 {
 	int ret;
-	unsigned char local_transfer_buffer[16];
+	unsigned char *local_transfer_buffer;
+
+	local_transfer_buffer = kmalloc(1, GFP_KERNEL);
+	if (!local_transfer_buffer)
+		return -ENOMEM;
 
 	/* 7f92 to zero */
-	local_transfer_buffer[0] = 0;
+	*local_transfer_buffer = 0;
 	/* bRequest, "Firmware" */
 	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0),
 			      USBDUXFASTSUB_FIRMWARE,
@@ -450,22 +454,25 @@ static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 			      local_transfer_buffer,
 			      1,      /* Length */
 			      EZTIMEOUT);    /* Timeout */
-	if (ret < 0) {
+	if (ret < 0)
 		dev_err(&udfs->interface->dev,
 			"control msg failed (start)\n");
-		return ret;
-	}
 
-	return 0;
+	kfree(local_transfer_buffer);
+	return ret;
 }
 
 static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 {
 	int ret;
-	unsigned char local_transfer_buffer[16];
+	unsigned char *local_transfer_buffer;
+
+	local_transfer_buffer = kmalloc(1, GFP_KERNEL);
+	if (!local_transfer_buffer)
+		return -ENOMEM;
 
 	/* 7f92 to one */
-	local_transfer_buffer[0] = 1;
+	*local_transfer_buffer = 1;
 	/* bRequest, "Firmware" */
 	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0),
 			      USBDUXFASTSUB_FIRMWARE,
@@ -474,13 +481,12 @@ static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 			      0x0000,	/* Index */
 			      local_transfer_buffer, 1,	/* Length */
 			      EZTIMEOUT);	/* Timeout */
-	if (ret < 0) {
+	if (ret < 0)
 		dev_err(&udfs->interface->dev,
 			"control msg failed (stop)\n");
-		return ret;
-	}
 
-	return 0;
+	kfree(local_transfer_buffer);
+	return ret;
 }
 
 static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,

commit 78110bb8dc4a7ff331bfa3cfe7d4e287cfb3f22b
Author: Joe Perches <joe@perches.com>
Date:   Mon Feb 11 09:41:29 2013 -0800

    staging: Remove unnecessary OOM messages
    
    alloc failures already get standardized OOM
    messages and a dump_stack.
    
    For the affected mallocs around these OOM messages:
    
    Converted kzallocs with multiplies to kcalloc.
    Converted kmallocs with multiplies to kmalloc_array.
    Converted a kmalloc/strlen/strncpy to kstrdup.
    Moved a spin_lock below a removed OOM message and
    removed a now unnecessary spin_unlock.
    Neatened alignment and whitespace.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 0f6187f96caa..4bf5dd094dc9 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1556,8 +1556,6 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 	usbduxfastsub[index].dux_commands = kmalloc(SIZEOFDUXBUFFER,
 						    GFP_KERNEL);
 	if (!usbduxfastsub[index].dux_commands) {
-		dev_err(&uinterf->dev,
-			"error alloc space for dac commands\n");
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -1565,8 +1563,6 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 	/* create space of the instruction buffer */
 	usbduxfastsub[index].insnBuffer = kmalloc(SIZEINSNBUF, GFP_KERNEL);
 	if (!usbduxfastsub[index].insnBuffer) {
-		dev_err(&uinterf->dev,
-			"could not alloc space for insnBuffer\n");
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -1592,8 +1588,6 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 	}
 	usbduxfastsub[index].transfer_buffer = kmalloc(SIZEINBUF, GFP_KERNEL);
 	if (!usbduxfastsub[index].transfer_buffer) {
-		dev_err(&uinterf->dev,
-			"usbduxfast%d: could not alloc. transb.\n", index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;

commit 55ab4f641a3bfbdb7c59b80e194c7242234bbb1f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:23:40 2013 -0700

    staging: comedi: comedi_usb: allow comedi usb drivers to pass a 'context'
    
    Allow the comedi usb drivers to pass a 'context' from their (*probe)
    functions to the comedi core's comedi_usb_auto_config(). This 'context'
    is then passed to comedi_auto_config() and then to the comedi_driver's
    (*auto_attach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 4e19f6186f28..0f6187f96caa 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1490,7 +1490,7 @@ static void usbduxfast_firmware_request_complete_handler(const struct firmware
 		goto out;
 	}
 
-	comedi_usb_auto_config(uinterf, &usbduxfast_driver);
+	comedi_usb_auto_config(uinterf, &usbduxfast_driver, 0);
  out:
 	release_firmware(fw);
 }

commit 9309c4772e9bbe6e9c27d96c333ecb2755d725fe
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 18:00:06 2012 -0700

    staging: comedi: usbduxfast: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of usbduxfast_ai_cmdtest().
    
    Also, remove some debug noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 5adc3b31a27c..4e19f6186f28 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -555,12 +555,6 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	if (!udfs->probed)
 		return -ENODEV;
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi%d: usbduxfast_ai_cmdtest\n", dev->minor);
-	printk(KERN_DEBUG "comedi%d: usbduxfast: convert_arg=%u "
-	       "scan_begin_arg=%u\n",
-	       dev->minor, cmd->convert_arg, cmd->scan_begin_arg);
-#endif
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src,
@@ -590,20 +584,15 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_src == TRIG_NOW && cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
+	if (cmd->start_src == TRIG_NOW)
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (!cmd->chanlist_len)
-		err++;
+		err |= -EINVAL;
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	if (cmd->chanlist_len == 1)
 		minSamplPer = 1;
@@ -620,28 +609,19 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 
 		/* calc arg again */
 		tmp = steps / 30;
-		if (cmd->convert_arg != tmp) {
-			cmd->convert_arg = tmp;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, tmp);
 	}
 
 	if (cmd->scan_begin_src == TRIG_TIMER)
-		err++;
+		err |= -EINVAL;
 
 	/* stop source */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		if (!cmd->stop_arg) {
-			cmd->stop_arg = 1;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
 		break;
 	case TRIG_NONE:
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 		break;
 		/*
 		 * TRIG_EXT doesn't care since it doesn't trigger

commit 54327dd75ea2258d6fe5201382fad2254c008f9e
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Thu Nov 8 17:11:09 2012 +0800

    staging: comedi: usbduxfast: remove unused variable in usbduxfastsub_ai_Irq()
    
    The variable 'p' is initialized but never used otherwise, so
    remove the unused variable.
    
    dpatch engine is used to auto generate this patch.
    (https://github.com/weiyj/dpatch)
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 845f240304e7..5adc3b31a27c 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -312,7 +312,6 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 	struct usbduxfastsub_s *udfs;
 	struct comedi_device *this_comedidev;
 	struct comedi_subdevice *s;
-	uint16_t *p;
 
 	/* sanity checks - is the urb there? */
 	if (!urb) {
@@ -379,7 +378,6 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 		return;
 	}
 
-	p = urb->transfer_buffer;
 	if (!udfs->ignore) {
 		if (!udfs->ai_continous) {
 			/* not continuous, fixed number of samples */

commit 807e65b0a818cd9b1604144af379bcabd24d4b85
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 30 13:30:03 2012 +0000

    staging: comedi/drivers: use auto_attach instead of attach_usb
    
    Change the usbdux, usbduxfast and usbduxsigma drivers to use the new
    `auto_attach()` method instead of the `attach_usb()` method.  I plan to
    remove the `attach_usb()` and `attach_pci()` methods from `struct
    comedi_driver` once nothing is using them.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index b4e987b892ac..845f240304e7 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1444,9 +1444,10 @@ static int usbduxfast_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
-static int usbduxfast_attach_usb(struct comedi_device *dev,
-				 struct usb_interface *uinterf)
+static int usbduxfast_auto_attach(struct comedi_device *dev,
+				  unsigned long context_unused)
 {
+	struct usb_interface *uinterf = comedi_to_usb_interface(dev);
 	int ret;
 	struct usbduxfastsub_s *udfs;
 
@@ -1455,11 +1456,11 @@ static int usbduxfast_attach_usb(struct comedi_device *dev,
 	udfs = usb_get_intfdata(uinterf);
 	if (!udfs || !udfs->probed) {
 		dev_err(dev->class_dev,
-			"usbduxfast: error: attach_usb failed, not connected\n");
+			"usbduxfast: error: auto_attach failed, not connected\n");
 		ret = -ENODEV;
 	} else if (udfs->attached) {
 		dev_err(dev->class_dev,
-		       "usbduxfast: error: attach_usb failed, already attached\n");
+		       "usbduxfast: error: auto_attach failed, already attached\n");
 		ret = -ENODEV;
 	} else
 		ret = usbduxfast_attach_common(dev, udfs);
@@ -1485,7 +1486,7 @@ static void usbduxfast_detach(struct comedi_device *dev)
 static struct comedi_driver usbduxfast_driver = {
 	.driver_name	= "usbduxfast",
 	.module		= THIS_MODULE,
-	.attach_usb	= usbduxfast_attach_usb,
+	.auto_attach	= usbduxfast_auto_attach,
 	.detach		= usbduxfast_detach,
 };
 

commit 1bbffe726e00f1f79ba1b8cf0cbd78223c995c0f
Author: YAMANE Toshiaki <yamanetoshi@gmail.com>
Date:   Sat Oct 27 07:25:53 2012 +0900

    staging:comedi: Use pr_ or dev_ printks in drivers/usbduxfaxt.c
    
    fixed below checkpatch warnings.
    -WARNING: printk() should include KERN_ facility level
    
    Signed-off-by: YAMANE Toshiaki <yamanetoshi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 060d853dc651..b4e987b892ac 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -370,9 +370,8 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 		return;
 
 	default:
-		printk("comedi%d: usbduxfast: non-zero urb status received in "
-		       "ai intr context: %d\n",
-		       udfs->comedidev->minor, urb->status);
+		pr_err("non-zero urb status received in ai intr context: %d\n",
+		       urb->status);
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
 		comedi_event(udfs->comedidev, s);
@@ -454,7 +453,8 @@ static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 			      1,      /* Length */
 			      EZTIMEOUT);    /* Timeout */
 	if (ret < 0) {
-		printk("comedi_: usbduxfast_: control msg failed (start)\n");
+		dev_err(&udfs->interface->dev,
+			"control msg failed (start)\n");
 		return ret;
 	}
 

commit 0a00ab999eb8cd0766277bac8f8209bda9bbbb87
Author: YAMANE Toshiaki <yamanetoshi@gmail.com>
Date:   Wed Oct 24 15:14:46 2012 +0900

    staging/comedi: Use pr_ or dev_ printks in drivers/usbduxfast.c
    
    fixed below checkpatch warnings.
    - WARNING: Prefer netdev_err(netdev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
    - WARNING: Prefer netdev_info(netdev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
    
    and added pr_fmt.
    
    Signed-off-by: YAMANE Toshiaki <yamanetoshi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 1154a7e2895d..060d853dc651 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -37,6 +37,8 @@
  *       udev coldplug problem
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/kernel.h>
 #include <linux/firmware.h>
 #include <linux/module.h>
@@ -216,8 +218,9 @@ static int send_dux_commands(struct usbduxfastsub_s *udfs, int cmd_type)
 			   usb_sndbulkpipe(udfs->usbdev, CHANNELLISTEP),
 			   udfs->dux_commands, SIZEOFDUXBUFFER, &nsent, 10000);
 	if (tmp < 0)
-		printk(KERN_ERR "comedi%d: could not transmit dux_commands to"
-		       "the usb-device, err=%d\n", udfs->comedidev->minor, tmp);
+		dev_err(&udfs->interface->dev,
+			"could not transmit dux_commands to the usb-device, err=%d\n",
+			tmp);
 	return tmp;
 }
 
@@ -252,7 +255,7 @@ static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs, int do_unlink)
 	int ret = 0;
 
 	if (!udfs) {
-		printk(KERN_ERR "comedi?: usbduxfast_ai_stop: udfs=NULL!\n");
+		pr_err("%s: udfs=NULL!\n", __func__);
 		return -EFAULT;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
@@ -284,7 +287,7 @@ static int usbduxfast_ai_cancel(struct comedi_device *dev,
 #endif
 	udfs = dev->private;
 	if (!udfs) {
-		printk(KERN_ERR "comedi: usbduxfast_ai_cancel: udfs=NULL\n");
+		dev_err(dev->class_dev, "%s: udfs=NULL\n", __func__);
 		return -EFAULT;
 	}
 	down(&udfs->sem);
@@ -313,22 +316,19 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 
 	/* sanity checks - is the urb there? */
 	if (!urb) {
-		printk(KERN_ERR "comedi_: usbduxfast_: ao int-handler called "
-		       "with urb=NULL!\n");
+		pr_err("ao int-handler called with urb=NULL!\n");
 		return;
 	}
 	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
 	if (!this_comedidev) {
-		printk(KERN_ERR "comedi_: usbduxfast_: urb context is a NULL "
-		       "pointer!\n");
+		pr_err("urb context is a NULL pointer!\n");
 		return;
 	}
 	/* the private structure of the subdevice is usbduxfastsub_s */
 	udfs = this_comedidev->private;
 	if (!udfs) {
-		printk(KERN_ERR "comedi_: usbduxfast_: private of comedi "
-		       "subdev is a NULL pointer!\n");
+		pr_err("private of comedi subdev is a NULL pointer!\n");
 		return;
 	}
 	/* are we running a command? */
@@ -427,8 +427,8 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 	urb->status = 0;
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		printk(KERN_ERR "comedi%d: usbduxfast: urb resubm failed: %d",
-		       udfs->comedidev->minor, err);
+		dev_err(&urb->dev->dev,
+			"urb resubm failed: %d", err);
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
 		comedi_event(udfs->comedidev, s);
@@ -477,8 +477,8 @@ static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 			      local_transfer_buffer, 1,	/* Length */
 			      EZTIMEOUT);	/* Timeout */
 	if (ret < 0) {
-		printk(KERN_ERR "comedi_: usbduxfast: control msg failed "
-		       "(stop)\n");
+		dev_err(&udfs->interface->dev,
+			"control msg failed (stop)\n");
 		return ret;
 	}
 
@@ -512,7 +512,7 @@ static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 #endif
 
 	if (ret < 0) {
-		printk(KERN_ERR "comedi_: usbduxfast: uppload failed\n");
+		dev_err(&udfs->interface->dev, "uppload failed\n");
 		return ret;
 	}
 
@@ -538,8 +538,8 @@ static int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
 #endif
 	ret = usb_submit_urb(udfs->urbIn, GFP_ATOMIC);
 	if (ret) {
-		printk(KERN_ERR "comedi_: usbduxfast: ai: usb_submit_urb error"
-		       " %d\n", ret);
+		dev_err(&udfs->interface->dev,
+			"ai: usb_submit_urb error %d\n", ret);
 		return ret;
 	}
 	return 0;
@@ -682,8 +682,7 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 #endif
 
 	if (trignum != 0) {
-		printk(KERN_ERR "comedi%d: usbduxfast_ai_inttrig: invalid"
-		       " trignum\n", dev->minor);
+		dev_err(dev->class_dev, "%s: invalid trignum\n", __func__);
 		up(&udfs->sem);
 		return -EINVAL;
 	}
@@ -691,16 +690,16 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 		udfs->ai_cmd_running = 1;
 		ret = usbduxfastsub_submit_InURBs(udfs);
 		if (ret < 0) {
-			printk(KERN_ERR "comedi%d: usbduxfast_ai_inttrig: "
-			       "urbSubmit: err=%d\n", dev->minor, ret);
+			dev_err(dev->class_dev,
+				"%s: urbSubmit: err=%d\n", __func__, ret);
 			udfs->ai_cmd_running = 0;
 			up(&udfs->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	} else {
-		printk(KERN_ERR "comedi%d: ai_inttrig but acqu is already"
-		       " running\n", dev->minor);
+		dev_err(dev->class_dev,
+			"ai_inttrig but acqu is already running\n");
 	}
 	up(&udfs->sem);
 	return 1;
@@ -738,8 +737,8 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		return -ENODEV;
 	}
 	if (udfs->ai_cmd_running) {
-		printk(KERN_ERR "comedi%d: ai_cmd not possible. Another ai_cmd"
-		       " is running.\n", dev->minor);
+		dev_err(dev->class_dev,
+			"ai_cmd not possible. Another ai_cmd is running.\n");
 		up(&udfs->sem);
 		return -EBUSY;
 	}
@@ -757,31 +756,29 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		for (i = 0; i < cmd->chanlist_len; ++i) {
 			chan = CR_CHAN(cmd->chanlist[i]);
 			if (chan != i) {
-				printk(KERN_ERR "comedi%d: cmd is accepting "
-				       "only consecutive channels.\n",
-				       dev->minor);
+				dev_err(dev->class_dev,
+					"cmd is accepting only consecutive channels.\n");
 				up(&udfs->sem);
 				return -EINVAL;
 			}
 			if ((gain != CR_RANGE(cmd->chanlist[i]))
 			    && (cmd->chanlist_len > 3)) {
-				printk(KERN_ERR "comedi%d: the gain must be"
-				       " the same for all channels.\n",
-				       dev->minor);
+				dev_err(dev->class_dev,
+					"the gain must be the same for all channels.\n");
 				up(&udfs->sem);
 				return -EINVAL;
 			}
 			if (i >= NUMCHANNELS) {
-				printk(KERN_ERR "comedi%d: channel list too"
-				       " long\n", dev->minor);
+				dev_err(dev->class_dev,
+					"channel list too long\n");
 				break;
 			}
 		}
 	}
 	steps = 0;
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		printk(KERN_ERR "comedi%d: usbduxfast: "
-		       "scan_begin_src==TRIG_TIMER not valid.\n", dev->minor);
+		dev_err(dev->class_dev,
+			"scan_begin_src==TRIG_TIMER not valid.\n");
 		up(&udfs->sem);
 		return -EINVAL;
 	}
@@ -789,22 +786,21 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		steps = (cmd->convert_arg * 30) / 1000;
 
 	if ((steps < MIN_SAMPLING_PERIOD) && (cmd->chanlist_len != 1)) {
-		printk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: steps=%ld, "
-		       "scan_begin_arg=%d. Not properly tested by cmdtest?\n",
-		       dev->minor, steps, cmd->scan_begin_arg);
+		dev_err(dev->class_dev,
+			"ai_cmd: steps=%ld, scan_begin_arg=%d. Not properly tested by cmdtest?\n",
+			steps, cmd->scan_begin_arg);
 		up(&udfs->sem);
 		return -EINVAL;
 	}
 	if (steps > MAX_SAMPLING_PERIOD) {
-		printk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: sampling rate "
-		       "too low.\n", dev->minor);
+		dev_err(dev->class_dev, "ai_cmd: sampling rate too low.\n");
 		up(&udfs->sem);
 		return -EINVAL;
 	}
 	if ((cmd->start_src == TRIG_EXT) && (cmd->chanlist_len != 1)
 	    && (cmd->chanlist_len != 16)) {
-		printk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: TRIG_EXT only"
-		       " with 1 or 16 channels possible.\n", dev->minor);
+		dev_err(dev->class_dev,
+			"ai_cmd: TRIG_EXT only with 1 or 16 channels possible.\n");
 		up(&udfs->sem);
 		return -EINVAL;
 	}
@@ -1121,8 +1117,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		break;
 
 	default:
-		printk(KERN_ERR "comedi %d: unsupported combination of "
-		       "channels\n", dev->minor);
+		dev_err(dev->class_dev, "unsupported combination of channels\n");
 		up(&udfs->sem);
 		return -EFAULT;
 	}
@@ -1134,17 +1129,16 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 	/* 0 means that the AD commands are sent */
 	result = send_dux_commands(udfs, SENDADCOMMANDS);
 	if (result < 0) {
-		printk(KERN_ERR "comedi%d: adc command could not be submitted."
-		       "Aborting...\n", dev->minor);
+		dev_err(dev->class_dev,
+			"adc command could not be submitted. Aborting...\n");
 		up(&udfs->sem);
 		return result;
 	}
 	if (cmd->stop_src == TRIG_COUNT) {
 		udfs->ai_sample_count = cmd->stop_arg * cmd->scan_end_arg;
 		if (udfs->ai_sample_count < 1) {
-			printk(KERN_ERR "comedi%d: "
-			       "(cmd->stop_arg)*(cmd->scan_end_arg)<1, "
-			       "aborting.\n", dev->minor);
+			dev_err(dev->class_dev,
+				"(cmd->stop_arg)*(cmd->scan_end_arg)<1, aborting.\n");
 			up(&udfs->sem);
 			return -EFAULT;
 		}
@@ -1193,8 +1187,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 
 	udfs = dev->private;
 	if (!udfs) {
-		printk(KERN_ERR "comedi%d: ai_insn_read: no usb dev.\n",
-		       dev->minor);
+		dev_err(dev->class_dev, "%s: no usb dev.\n", __func__);
 		return -ENODEV;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
@@ -1207,8 +1200,8 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 		return -ENODEV;
 	}
 	if (udfs->ai_cmd_running) {
-		printk(KERN_ERR "comedi%d: ai_insn_read not possible. Async "
-		       "Command is running.\n", dev->minor);
+		dev_err(dev->class_dev,
+			"ai_insn_read not possible. Async Command is running.\n");
 		up(&udfs->sem);
 		return -EBUSY;
 	}
@@ -1268,8 +1261,8 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	/* 0 means that the AD commands are sent */
 	err = send_dux_commands(udfs, SENDADCOMMANDS);
 	if (err < 0) {
-		printk(KERN_ERR "comedi%d: adc command could not be submitted."
-		       "Aborting...\n", dev->minor);
+		dev_err(dev->class_dev,
+			"adc command could not be submitted. Aborting...\n");
 		up(&udfs->sem);
 		return err;
 	}
@@ -1284,8 +1277,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 				   udfs->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
-			printk(KERN_ERR "comedi%d: insn timeout. No data.\n",
-			       dev->minor);
+			dev_err(dev->class_dev, "insn timeout. No data.\n");
 			up(&udfs->sem);
 			return err;
 		}
@@ -1297,15 +1289,13 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 				   udfs->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
-			printk(KERN_ERR "comedi%d: insn data error: %d\n",
-			       dev->minor, err);
+			dev_err(dev->class_dev, "insn data error: %d\n", err);
 			up(&udfs->sem);
 			return err;
 		}
 		n = actual_length / sizeof(uint16_t);
 		if ((n % 16) != 0) {
-			printk(KERN_ERR "comedi%d: insn data packet "
-			       "corrupted.\n", dev->minor);
+			dev_err(dev->class_dev, "insn data packet corrupted.\n");
 			up(&udfs->sem);
 			return -EINVAL;
 		}
@@ -1535,8 +1525,8 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 	int ret;
 
 	if (udev->speed != USB_SPEED_HIGH) {
-		printk(KERN_ERR "comedi_: usbduxfast_: This driver needs"
-		       "USB 2.0 to operate. Aborting...\n");
+		dev_err(&uinterf->dev,
+			"This driver needs USB 2.0 to operate. Aborting...\n");
 		return -ENODEV;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
@@ -1555,7 +1545,8 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 
 	/* no more space */
 	if (index == -1) {
-		printk(KERN_ERR "Too many usbduxfast-devices connected.\n");
+		dev_err(&uinterf->dev,
+			"Too many usbduxfast-devices connected.\n");
 		up(&start_stop_sem);
 		return -EMFILE;
 	}
@@ -1586,8 +1577,8 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 	usbduxfastsub[index].dux_commands = kmalloc(SIZEOFDUXBUFFER,
 						    GFP_KERNEL);
 	if (!usbduxfastsub[index].dux_commands) {
-		printk(KERN_ERR "comedi_: usbduxfast: error alloc space for "
-		       "dac commands\n");
+		dev_err(&uinterf->dev,
+			"error alloc space for dac commands\n");
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -1595,8 +1586,8 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 	/* create space of the instruction buffer */
 	usbduxfastsub[index].insnBuffer = kmalloc(SIZEINSNBUF, GFP_KERNEL);
 	if (!usbduxfastsub[index].insnBuffer) {
-		printk(KERN_ERR "comedi_: usbduxfast: could not alloc space "
-		       "for insnBuffer\n");
+		dev_err(&uinterf->dev,
+			"could not alloc space for insnBuffer\n");
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -1605,24 +1596,25 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 	i = usb_set_interface(usbduxfastsub[index].usbdev,
 			      usbduxfastsub[index].ifnum, 1);
 	if (i < 0) {
-		printk(KERN_ERR "comedi_: usbduxfast%d: could not switch to "
-		       "alternate setting 1.\n", index);
+		dev_err(&uinterf->dev,
+			"usbduxfast%d: could not switch to alternate setting 1.\n",
+			index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENODEV;
 	}
 	usbduxfastsub[index].urbIn = usb_alloc_urb(0, GFP_KERNEL);
 	if (!usbduxfastsub[index].urbIn) {
-		printk(KERN_ERR "comedi_: usbduxfast%d: Could not alloc."
-		       "urb\n", index);
+		dev_err(&uinterf->dev,
+			"usbduxfast%d: Could not alloc. urb\n", index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	usbduxfastsub[index].transfer_buffer = kmalloc(SIZEINBUF, GFP_KERNEL);
 	if (!usbduxfastsub[index].transfer_buffer) {
-		printk(KERN_ERR "comedi_: usbduxfast%d: could not alloc. "
-		       "transb.\n", index);
+		dev_err(&uinterf->dev,
+			"usbduxfast%d: could not alloc. transb.\n", index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -1640,12 +1632,12 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 				      usbduxfast_firmware_request_complete_handler);
 
 	if (ret) {
-		dev_err(&udev->dev, "could not load firmware (err=%d)\n", ret);
+		dev_err(&uinterf->dev, "could not load firmware (err=%d)\n", ret);
 		return ret;
 	}
 
-	printk(KERN_INFO "comedi_: usbduxfast%d has been successfully "
-	       "initialized.\n", index);
+	dev_info(&uinterf->dev,
+		 "usbduxfast%d has been successfully initialized.\n", index);
 	/* success */
 	return 0;
 }
@@ -1656,13 +1648,11 @@ static void usbduxfast_usb_disconnect(struct usb_interface *intf)
 	struct usb_device *udev = interface_to_usbdev(intf);
 
 	if (!udfs) {
-		printk(KERN_ERR "comedi_: usbduxfast: disconnect called with "
-		       "null pointer.\n");
+		dev_err(&intf->dev, "disconnect called with null pointer.\n");
 		return;
 	}
 	if (udfs->usbdev != udev) {
-		printk(KERN_ERR "comedi_: usbduxfast: BUG! called with wrong "
-		       "ptr!!!\n");
+		dev_err(&intf->dev, "BUG! called with wrong ptr!!!\n");
 		return;
 	}
 

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 0f6c1392f6ce..1154a7e2895d 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -549,10 +549,10 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_cmd *cmd)
 {
-	int err = 0, stop_mask = 0;
+	struct usbduxfastsub_s *udfs = dev->private;
+	int err = 0;
 	long int steps, tmp;
 	int minSamplPer;
-	struct usbduxfastsub_s *udfs = dev->private;
 
 	if (!udfs->probed)
 		return -ENODEV;
@@ -563,57 +563,31 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	       "scan_begin_arg=%u\n",
 	       dev->minor, cmd->convert_arg, cmd->scan_begin_arg);
 #endif
-	/* step 1: make sure trigger sources are trivially valid */
-
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_EXT | TRIG_INT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_TIMER | TRIG_FOLLOW | TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->stop_src;
-	stop_mask = TRIG_COUNT | TRIG_NONE;
-	cmd->stop_src &= stop_mask;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src,
+					TRIG_NOW | TRIG_EXT | TRIG_INT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_TIMER | TRIG_FOLLOW | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/*
-	 * step 2: make sure trigger sources are unique and mutually compatible
-	 */
+	/* Step 2a : make sure trigger sources are unique */
 
-	if (cmd->start_src != TRIG_NOW &&
-	    cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_INT)
-		err++;
-	if (cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_FOLLOW &&
-	    cmd->scan_begin_src != TRIG_EXT)
-		err++;
-	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT &&
-	    cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	/* can't have external stop and start triggers at once */
 	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)
-		err++;
+		err |= -EINVAL;
 
 	if (err)
 		return 2;

commit 4e5ba2f6bd1c480ce6b362a17a6a3456a2354cf0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 16:20:57 2012 -0700

    staging: comedi: usbduxfast: remove usbduxfast_attach
    
    This driver originally used the 'attach' method in order to get
    the firmware for the device from the comedi_config utility. It
    now uses request_firmware_nowait() in the usb_driver probe to
    get this firmware.
    
    Since this driver has an 'attach_usb' method in the comedi_driver,
    the 'attach' method can be removed because it is now optional.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 3f68fc396301..0f6c1392f6ce 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1430,10 +1430,8 @@ static void tidy_up(struct usbduxfastsub_s *udfs)
 	udfs->ai_cmd_running = 0;
 }
 
-/* common part of attach and attach_usb */
 static int usbduxfast_attach_common(struct comedi_device *dev,
-				    struct usbduxfastsub_s *udfs,
-				    void *aux_data, int aux_len)
+				    struct usbduxfastsub_s *udfs)
 {
 	int ret;
 	struct comedi_subdevice *s;
@@ -1441,9 +1439,6 @@ static int usbduxfast_attach_common(struct comedi_device *dev,
 	down(&udfs->sem);
 	/* pointer back to the corresponding comedi device */
 	udfs->comedidev = dev;
-	/* trying to upload the firmware into the chip */
-	if (aux_data)
-		firmwareUpload(udfs, aux_data, aux_len);
 	dev->board_name = "usbduxfast";
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret) {
@@ -1485,48 +1480,6 @@ static int usbduxfast_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
-/* is called for COMEDI_DEVCONFIG ioctl (when comedi_config is run) */
-static int usbduxfast_attach(struct comedi_device *dev,
-			     struct comedi_devconfig *it)
-{
-	int ret;
-	int index;
-	int i;
-	void *aux_data;
-	int aux_len;
-
-	dev->private = NULL;
-
-	aux_data = comedi_aux_data(it->options, 0);
-	aux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
-	if (aux_data == NULL)
-		aux_len = 0;
-	else if (aux_len == 0)
-		aux_data = NULL;
-	down(&start_stop_sem);
-	/*
-	 * find a valid device which has been detected by the
-	 * probe function of the usb
-	 */
-	index = -1;
-	for (i = 0; i < NUMUSBDUXFAST; i++) {
-		if (usbduxfastsub[i].probed && !usbduxfastsub[i].attached) {
-			index = i;
-			break;
-		}
-	}
-	if (index < 0) {
-		dev_err(dev->class_dev,
-			"usbduxfast: error: attach failed, no usbduxfast devs connected to the usb bus.\n");
-		ret = -ENODEV;
-	} else
-		ret = usbduxfast_attach_common(dev, &usbduxfastsub[index],
-					       aux_data, aux_len);
-	up(&start_stop_sem);
-	return ret;
-}
-
-/* is called from comedi_usb_auto_config() */
 static int usbduxfast_attach_usb(struct comedi_device *dev,
 				 struct usb_interface *uinterf)
 {
@@ -1545,7 +1498,7 @@ static int usbduxfast_attach_usb(struct comedi_device *dev,
 		       "usbduxfast: error: attach_usb failed, already attached\n");
 		ret = -ENODEV;
 	} else
-		ret = usbduxfast_attach_common(dev, udfs, NULL, 0);
+		ret = usbduxfast_attach_common(dev, udfs);
 	up(&start_stop_sem);
 	return ret;
 }
@@ -1568,9 +1521,8 @@ static void usbduxfast_detach(struct comedi_device *dev)
 static struct comedi_driver usbduxfast_driver = {
 	.driver_name	= "usbduxfast",
 	.module		= THIS_MODULE,
-	.attach		= usbduxfast_attach,
-	.detach		= usbduxfast_detach,
 	.attach_usb	= usbduxfast_attach_usb,
+	.detach		= usbduxfast_detach,
 };
 
 static void usbduxfast_firmware_request_complete_handler(const struct firmware

commit bbea99d9c7221f69cadb4fd764f2a65e6292c756
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:58:32 2012 -0700

    staging: comedi: usbduxfast: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 8eb41257c6ce..3f68fc396301 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -346,7 +346,7 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 		return;
 	}
 	/* subdevice which is the AD converter */
-	s = this_comedidev->subdevices + SUBDEV_AD;
+	s = &this_comedidev->subdevices[SUBDEV_AD];
 
 	/* first we test if something unusual has just happened */
 	switch (urb->status) {
@@ -1453,7 +1453,7 @@ static int usbduxfast_attach_common(struct comedi_device *dev,
 	/* private structure is also simply the usb-structure */
 	dev->private = udfs;
 	/* the first subdevice is the A/D converter */
-	s = dev->subdevices + SUBDEV_AD;
+	s = &dev->subdevices[SUBDEV_AD];
 	/*
 	 * the URBs get the comedi subdevice which is responsible for reading
 	 * this is the subdevice which reads data

commit e74f7fc5d85c5c0bedb69913e2a10774ddb6f367
Author: Tim Gardner <tim.gardner@canonical.com>
Date:   Thu Aug 16 11:09:28 2012 -0600

    staging: comedi: usbduxfast: Declare MODULE_FIRMWARE usage
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index d9911588c10a..8eb41257c6ce 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -57,6 +57,7 @@
 /*
  * constants for "firmware" upload and download
  */
+#define FIRMWARE		"usbduxfast_firmware.bin"
 #define USBDUXFASTSUB_FIRMWARE	0xA0
 #define VENDOR_DIR_IN		0xC0
 #define VENDOR_DIR_OUT		0x40
@@ -1706,7 +1707,7 @@ static int usbduxfast_usb_probe(struct usb_interface *uinterf,
 
 	ret = request_firmware_nowait(THIS_MODULE,
 				      FW_ACTION_HOTPLUG,
-				      "usbduxfast_firmware.bin",
+				      FIRMWARE,
 				      &udev->dev,
 				      GFP_KERNEL,
 				      usbduxfastsub + index,
@@ -1774,3 +1775,4 @@ module_comedi_usb_driver(usbduxfast_driver, usbduxfast_usb_driver);
 MODULE_AUTHOR("Bernd Porr, BerndPorr@f2s.com");
 MODULE_DESCRIPTION("USB-DUXfast, BerndPorr@f2s.com");
 MODULE_LICENSE("GPL");
+MODULE_FIRMWARE(FIRMWARE);

commit 4c8ba916b268d25ad5e2cd7ccb1a886831cde659
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 12:02:28 2012 -0700

    staging: comedi: usbduxfast: refactor init code
    
    Refactor the usb driver probe/disconnect and comedi driver attach/
    detach to follow the style of the other comedi driver types to
    improve maintainability.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 8c8e4ec9f358..d9911588c10a 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -49,11 +49,6 @@
 #include "comedi_fc.h"
 #include "../comedidev.h"
 
-#define DRIVER_VERSION "v1.0"
-#define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
-#define DRIVER_DESC "USB-DUXfast, BerndPorr@f2s.com"
-#define BOARDNAME "usbduxfast"
-
 /*
  * timeout for the USB-transfer
  */
@@ -196,8 +191,6 @@ static struct usbduxfastsub_s usbduxfastsub[NUMUSBDUXFAST];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
-static struct comedi_driver usbduxfast_driver;	/* see below for initializer */
-
 /*
  * bulk transfers to usbduxfast
  */
@@ -1436,6 +1429,149 @@ static void tidy_up(struct usbduxfastsub_s *udfs)
 	udfs->ai_cmd_running = 0;
 }
 
+/* common part of attach and attach_usb */
+static int usbduxfast_attach_common(struct comedi_device *dev,
+				    struct usbduxfastsub_s *udfs,
+				    void *aux_data, int aux_len)
+{
+	int ret;
+	struct comedi_subdevice *s;
+
+	down(&udfs->sem);
+	/* pointer back to the corresponding comedi device */
+	udfs->comedidev = dev;
+	/* trying to upload the firmware into the chip */
+	if (aux_data)
+		firmwareUpload(udfs, aux_data, aux_len);
+	dev->board_name = "usbduxfast";
+	ret = comedi_alloc_subdevices(dev, 1);
+	if (ret) {
+		up(&udfs->sem);
+		return ret;
+	}
+	/* private structure is also simply the usb-structure */
+	dev->private = udfs;
+	/* the first subdevice is the A/D converter */
+	s = dev->subdevices + SUBDEV_AD;
+	/*
+	 * the URBs get the comedi subdevice which is responsible for reading
+	 * this is the subdevice which reads data
+	 */
+	dev->read_subdev = s;
+	/* the subdevice receives as private structure the usb-structure */
+	s->private = NULL;
+	/* analog input */
+	s->type = COMEDI_SUBD_AI;
+	/* readable and ref is to ground */
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
+	/* 16 channels */
+	s->n_chan = 16;
+	/* length of the channellist */
+	s->len_chanlist = 16;
+	/* callback functions */
+	s->insn_read = usbduxfast_ai_insn_read;
+	s->do_cmdtest = usbduxfast_ai_cmdtest;
+	s->do_cmd = usbduxfast_ai_cmd;
+	s->cancel = usbduxfast_ai_cancel;
+	/* max value from the A/D converter (12bit+1 bit for overflow) */
+	s->maxdata = 0x1000;
+	/* range table to convert to physical units */
+	s->range_table = &range_usbduxfast_ai_range;
+	/* finally decide that it's attached */
+	udfs->attached = 1;
+	up(&udfs->sem);
+	dev_info(dev->class_dev, "successfully attached to usbduxfast.\n");
+	return 0;
+}
+
+/* is called for COMEDI_DEVCONFIG ioctl (when comedi_config is run) */
+static int usbduxfast_attach(struct comedi_device *dev,
+			     struct comedi_devconfig *it)
+{
+	int ret;
+	int index;
+	int i;
+	void *aux_data;
+	int aux_len;
+
+	dev->private = NULL;
+
+	aux_data = comedi_aux_data(it->options, 0);
+	aux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
+	if (aux_data == NULL)
+		aux_len = 0;
+	else if (aux_len == 0)
+		aux_data = NULL;
+	down(&start_stop_sem);
+	/*
+	 * find a valid device which has been detected by the
+	 * probe function of the usb
+	 */
+	index = -1;
+	for (i = 0; i < NUMUSBDUXFAST; i++) {
+		if (usbduxfastsub[i].probed && !usbduxfastsub[i].attached) {
+			index = i;
+			break;
+		}
+	}
+	if (index < 0) {
+		dev_err(dev->class_dev,
+			"usbduxfast: error: attach failed, no usbduxfast devs connected to the usb bus.\n");
+		ret = -ENODEV;
+	} else
+		ret = usbduxfast_attach_common(dev, &usbduxfastsub[index],
+					       aux_data, aux_len);
+	up(&start_stop_sem);
+	return ret;
+}
+
+/* is called from comedi_usb_auto_config() */
+static int usbduxfast_attach_usb(struct comedi_device *dev,
+				 struct usb_interface *uinterf)
+{
+	int ret;
+	struct usbduxfastsub_s *udfs;
+
+	dev->private = NULL;
+	down(&start_stop_sem);
+	udfs = usb_get_intfdata(uinterf);
+	if (!udfs || !udfs->probed) {
+		dev_err(dev->class_dev,
+			"usbduxfast: error: attach_usb failed, not connected\n");
+		ret = -ENODEV;
+	} else if (udfs->attached) {
+		dev_err(dev->class_dev,
+		       "usbduxfast: error: attach_usb failed, already attached\n");
+		ret = -ENODEV;
+	} else
+		ret = usbduxfast_attach_common(dev, udfs, NULL, 0);
+	up(&start_stop_sem);
+	return ret;
+}
+
+static void usbduxfast_detach(struct comedi_device *dev)
+{
+	struct usbduxfastsub_s *usb = dev->private;
+
+	if (usb) {
+		down(&usb->sem);
+		down(&start_stop_sem);
+		dev->private = NULL;
+		usb->attached = 0;
+		usb->comedidev = NULL;
+		up(&start_stop_sem);
+		up(&usb->sem);
+	}
+}
+
+static struct comedi_driver usbduxfast_driver = {
+	.driver_name	= "usbduxfast",
+	.module		= THIS_MODULE,
+	.attach		= usbduxfast_attach,
+	.detach		= usbduxfast_detach,
+	.attach_usb	= usbduxfast_attach_usb,
+};
+
 static void usbduxfast_firmware_request_complete_handler(const struct firmware
 							 *fw, void *context)
 {
@@ -1463,11 +1599,8 @@ static void usbduxfast_firmware_request_complete_handler(const struct firmware
 	release_firmware(fw);
 }
 
-/*
- * allocate memory for the urbs and initialise them
- */
-static int usbduxfastsub_probe(struct usb_interface *uinterf,
-			       const struct usb_device_id *id)
+static int usbduxfast_usb_probe(struct usb_interface *uinterf,
+				const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
 	int i;
@@ -1590,7 +1723,7 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 	return 0;
 }
 
-static void usbduxfastsub_disconnect(struct usb_interface *intf)
+static void usbduxfast_usb_disconnect(struct usb_interface *intf)
 {
 	struct usbduxfastsub_s *udfs = usb_get_intfdata(intf);
 	struct usb_device *udev = interface_to_usbdev(intf);
@@ -1619,175 +1752,25 @@ static void usbduxfastsub_disconnect(struct usb_interface *intf)
 #endif
 }
 
-/* common part of attach and attach_usb */
-static int usbduxfast_attach_common(struct comedi_device *dev,
-				    struct usbduxfastsub_s *udfs,
-				    void *aux_data, int aux_len)
-{
-	int ret;
-	struct comedi_subdevice *s;
-
-	down(&udfs->sem);
-	/* pointer back to the corresponding comedi device */
-	udfs->comedidev = dev;
-	/* trying to upload the firmware into the chip */
-	if (aux_data)
-		firmwareUpload(udfs, aux_data, aux_len);
-	dev->board_name = BOARDNAME;
-	ret = comedi_alloc_subdevices(dev, 1);
-	if (ret) {
-		up(&udfs->sem);
-		return ret;
-	}
-	/* private structure is also simply the usb-structure */
-	dev->private = udfs;
-	/* the first subdevice is the A/D converter */
-	s = dev->subdevices + SUBDEV_AD;
-	/*
-	 * the URBs get the comedi subdevice which is responsible for reading
-	 * this is the subdevice which reads data
-	 */
-	dev->read_subdev = s;
-	/* the subdevice receives as private structure the usb-structure */
-	s->private = NULL;
-	/* analog input */
-	s->type = COMEDI_SUBD_AI;
-	/* readable and ref is to ground */
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
-	/* 16 channels */
-	s->n_chan = 16;
-	/* length of the channellist */
-	s->len_chanlist = 16;
-	/* callback functions */
-	s->insn_read = usbduxfast_ai_insn_read;
-	s->do_cmdtest = usbduxfast_ai_cmdtest;
-	s->do_cmd = usbduxfast_ai_cmd;
-	s->cancel = usbduxfast_ai_cancel;
-	/* max value from the A/D converter (12bit+1 bit for overflow) */
-	s->maxdata = 0x1000;
-	/* range table to convert to physical units */
-	s->range_table = &range_usbduxfast_ai_range;
-	/* finally decide that it's attached */
-	udfs->attached = 1;
-	up(&udfs->sem);
-	dev_info(dev->class_dev, "successfully attached to usbduxfast.\n");
-	return 0;
-}
-
-/* is called for COMEDI_DEVCONFIG ioctl (when comedi_config is run) */
-static int usbduxfast_attach(struct comedi_device *dev,
-			     struct comedi_devconfig *it)
-{
-	int ret;
-	int index;
-	int i;
-	void *aux_data;
-	int aux_len;
-
-	dev->private = NULL;
-
-	aux_data = comedi_aux_data(it->options, 0);
-	aux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
-	if (aux_data == NULL)
-		aux_len = 0;
-	else if (aux_len == 0)
-		aux_data = NULL;
-	down(&start_stop_sem);
-	/*
-	 * find a valid device which has been detected by the
-	 * probe function of the usb
-	 */
-	index = -1;
-	for (i = 0; i < NUMUSBDUXFAST; i++) {
-		if (usbduxfastsub[i].probed && !usbduxfastsub[i].attached) {
-			index = i;
-			break;
-		}
-	}
-	if (index < 0) {
-		dev_err(dev->class_dev,
-			"usbduxfast: error: attach failed, no usbduxfast devs connected to the usb bus.\n");
-		ret = -ENODEV;
-	} else
-		ret = usbduxfast_attach_common(dev, &usbduxfastsub[index],
-					       aux_data, aux_len);
-	up(&start_stop_sem);
-	return ret;
-}
-
-/* is called from comedi_usb_auto_config() */
-static int usbduxfast_attach_usb(struct comedi_device *dev,
-				 struct usb_interface *uinterf)
-{
-	int ret;
-	struct usbduxfastsub_s *udfs;
-
-	dev->private = NULL;
-	down(&start_stop_sem);
-	udfs = usb_get_intfdata(uinterf);
-	if (!udfs || !udfs->probed) {
-		dev_err(dev->class_dev,
-			"usbduxfast: error: attach_usb failed, not connected\n");
-		ret = -ENODEV;
-	} else if (udfs->attached) {
-		dev_err(dev->class_dev,
-		       "usbduxfast: error: attach_usb failed, already attached\n");
-		ret = -ENODEV;
-	} else
-		ret = usbduxfast_attach_common(dev, udfs, NULL, 0);
-	up(&start_stop_sem);
-	return ret;
-}
-
-static void usbduxfast_detach(struct comedi_device *dev)
-{
-	struct usbduxfastsub_s *usb = dev->private;
-
-	if (usb) {
-		down(&usb->sem);
-		down(&start_stop_sem);
-		dev->private = NULL;
-		usb->attached = 0;
-		usb->comedidev = NULL;
-		up(&start_stop_sem);
-		up(&usb->sem);
-	}
-}
-
-/*
- * main driver struct
- */
-static struct comedi_driver usbduxfast_driver = {
-	.driver_name	= "usbduxfast",
-	.module		= THIS_MODULE,
-	.attach		= usbduxfast_attach,
-	.detach		= usbduxfast_detach,
-	.attach_usb	= usbduxfast_attach_usb,
-};
-
-/*
- * Table with the USB-devices: just now only testing IDs
- */
-static const struct usb_device_id usbduxfastsub_table[] = {
+static const struct usb_device_id usbduxfast_usb_table[] = {
 	/* { USB_DEVICE(0x4b4, 0x8613) }, testing */
-	{USB_DEVICE(0x13d8, 0x0010)},	/* real ID */
-	{USB_DEVICE(0x13d8, 0x0011)},	/* real ID */
-	{}			/* Terminating entry */
+	{ USB_DEVICE(0x13d8, 0x0010) },	/* real ID */
+	{ USB_DEVICE(0x13d8, 0x0011) },	/* real ID */
+	{ }
 };
-
-MODULE_DEVICE_TABLE(usb, usbduxfastsub_table);
+MODULE_DEVICE_TABLE(usb, usbduxfast_usb_table);
 
 static struct usb_driver usbduxfast_usb_driver = {
 #ifdef COMEDI_HAVE_USB_DRIVER_OWNER
 	.owner		= THIS_MODULE,
 #endif
-	.name		= BOARDNAME,
-	.probe		= usbduxfastsub_probe,
-	.disconnect	= usbduxfastsub_disconnect,
-	.id_table	= usbduxfastsub_table,
+	.name		= "usbduxfast",
+	.probe		= usbduxfast_usb_probe,
+	.disconnect	= usbduxfast_usb_disconnect,
+	.id_table	= usbduxfast_usb_table,
 };
 module_comedi_usb_driver(usbduxfast_driver, usbduxfast_usb_driver);
 
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Bernd Porr, BerndPorr@f2s.com");
+MODULE_DESCRIPTION("USB-DUXfast, BerndPorr@f2s.com");
 MODULE_LICENSE("GPL");

commit cb9513adb2054c7a769d938cb519a437ad4f2b10
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 12:01:14 2012 -0700

    staging: comedi: usbduxfast: use module_comedi_usb_driver()
    
    Use the module_comedi_usb_driver helper macro to initialize this
    module. Rename the driver structs to follow the pattern of the
    other comedi driver types and add some whitespace to improve
    readability.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index c71362086cdf..8c8e4ec9f358 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -196,7 +196,7 @@ static struct usbduxfastsub_s usbduxfastsub[NUMUSBDUXFAST];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
-static struct comedi_driver driver_usbduxfast;	/* see below for initializer */
+static struct comedi_driver usbduxfast_driver;	/* see below for initializer */
 
 /*
  * bulk transfers to usbduxfast
@@ -1458,7 +1458,7 @@ static void usbduxfast_firmware_request_complete_handler(const struct firmware
 		goto out;
 	}
 
-	comedi_usb_auto_config(uinterf, &driver_usbduxfast);
+	comedi_usb_auto_config(uinterf, &usbduxfast_driver);
  out:
 	release_firmware(fw);
 }
@@ -1757,12 +1757,12 @@ static void usbduxfast_detach(struct comedi_device *dev)
 /*
  * main driver struct
  */
-static struct comedi_driver driver_usbduxfast = {
-	.driver_name = "usbduxfast",
-	.module = THIS_MODULE,
-	.attach = usbduxfast_attach,
-	.detach = usbduxfast_detach,
-	.attach_usb = usbduxfast_attach_usb,
+static struct comedi_driver usbduxfast_driver = {
+	.driver_name	= "usbduxfast",
+	.module		= THIS_MODULE,
+	.attach		= usbduxfast_attach,
+	.detach		= usbduxfast_detach,
+	.attach_usb	= usbduxfast_attach_usb,
 };
 
 /*
@@ -1777,43 +1777,16 @@ static const struct usb_device_id usbduxfastsub_table[] = {
 
 MODULE_DEVICE_TABLE(usb, usbduxfastsub_table);
 
-/*
- * The usbduxfastsub-driver
- */
-static struct usb_driver usbduxfastsub_driver = {
+static struct usb_driver usbduxfast_usb_driver = {
 #ifdef COMEDI_HAVE_USB_DRIVER_OWNER
-	.owner = THIS_MODULE,
+	.owner		= THIS_MODULE,
 #endif
-	.name = BOARDNAME,
-	.probe = usbduxfastsub_probe,
-	.disconnect = usbduxfastsub_disconnect,
-	.id_table = usbduxfastsub_table
+	.name		= BOARDNAME,
+	.probe		= usbduxfastsub_probe,
+	.disconnect	= usbduxfastsub_disconnect,
+	.id_table	= usbduxfastsub_table,
 };
-
-/*
- * Can't use the nice macro as I have also to initialise the USB subsystem:
- * registering the usb-system _and_ the comedi-driver
- */
-static int __init init_usbduxfast(void)
-{
-	printk(KERN_INFO
-	       KBUILD_MODNAME ": " DRIVER_VERSION ":" DRIVER_DESC "\n");
-	usb_register(&usbduxfastsub_driver);
-	comedi_driver_register(&driver_usbduxfast);
-	return 0;
-}
-
-/*
- * deregistering the comedi driver and the usb-subsystem
- */
-static void __exit exit_usbduxfast(void)
-{
-	comedi_driver_unregister(&driver_usbduxfast);
-	usb_deregister(&usbduxfastsub_driver);
-}
-
-module_init(init_usbduxfast);
-module_exit(exit_usbduxfast);
+module_comedi_usb_driver(usbduxfast_driver, usbduxfast_usb_driver);
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);

commit 185f9aa7df9b75609f6828ecc0d0120fbe94da08
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jun 18 15:16:44 2012 +0100

    staging: comedi: usbduxfast: use attach_usb() hook
    
    Change the usbduxfast driver to use the new attach_usb() hook in struct
    comedi_driver to auto-configure probed USB devices after the firmware is
    loaded.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 2ee9ecd33539..c71362086cdf 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1619,64 +1619,28 @@ static void usbduxfastsub_disconnect(struct usb_interface *intf)
 #endif
 }
 
-/*
- * is called when comedi-config is called
- */
-static int usbduxfast_attach(struct comedi_device *dev,
-			     struct comedi_devconfig *it)
+/* common part of attach and attach_usb */
+static int usbduxfast_attach_common(struct comedi_device *dev,
+				    struct usbduxfastsub_s *udfs,
+				    void *aux_data, int aux_len)
 {
 	int ret;
-	int index;
-	int i;
-	struct comedi_subdevice *s = NULL;
-	dev->private = NULL;
-
-	down(&start_stop_sem);
-	/*
-	 * find a valid device which has been detected by the
-	 * probe function of the usb
-	 */
-	index = -1;
-	for (i = 0; i < NUMUSBDUXFAST; i++) {
-		if (usbduxfastsub[i].probed && !usbduxfastsub[i].attached) {
-			index = i;
-			break;
-		}
-	}
-
-	if (index < 0) {
-		printk(KERN_ERR "comedi%d: usbduxfast: error: attach failed, "
-		       "no usbduxfast devs connected to the usb bus.\n",
-		       dev->minor);
-		up(&start_stop_sem);
-		return -ENODEV;
-	}
+	struct comedi_subdevice *s;
 
-	down(&(usbduxfastsub[index].sem));
+	down(&udfs->sem);
 	/* pointer back to the corresponding comedi device */
-	usbduxfastsub[index].comedidev = dev;
-
+	udfs->comedidev = dev;
 	/* trying to upload the firmware into the chip */
-	if (comedi_aux_data(it->options, 0) &&
-	    it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
-		firmwareUpload(&usbduxfastsub[index],
-			       comedi_aux_data(it->options, 0),
-			       it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
-	}
-
+	if (aux_data)
+		firmwareUpload(udfs, aux_data, aux_len);
 	dev->board_name = BOARDNAME;
-
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret) {
-		up(&(usbduxfastsub[index].sem));
-		up(&start_stop_sem);
+		up(&udfs->sem);
 		return ret;
 	}
-
-	printk(KERN_INFO "comedi%d: usbduxfast: usb-device %d is attached to "
-	       "comedi.\n", dev->minor, index);
 	/* private structure is also simply the usb-structure */
-	dev->private = usbduxfastsub + index;
+	dev->private = udfs;
 	/* the first subdevice is the A/D converter */
 	s = dev->subdevices + SUBDEV_AD;
 	/*
@@ -1703,16 +1667,76 @@ static int usbduxfast_attach(struct comedi_device *dev,
 	s->maxdata = 0x1000;
 	/* range table to convert to physical units */
 	s->range_table = &range_usbduxfast_ai_range;
-
 	/* finally decide that it's attached */
-	usbduxfastsub[index].attached = 1;
+	udfs->attached = 1;
+	up(&udfs->sem);
+	dev_info(dev->class_dev, "successfully attached to usbduxfast.\n");
+	return 0;
+}
+
+/* is called for COMEDI_DEVCONFIG ioctl (when comedi_config is run) */
+static int usbduxfast_attach(struct comedi_device *dev,
+			     struct comedi_devconfig *it)
+{
+	int ret;
+	int index;
+	int i;
+	void *aux_data;
+	int aux_len;
 
-	up(&(usbduxfastsub[index].sem));
+	dev->private = NULL;
+
+	aux_data = comedi_aux_data(it->options, 0);
+	aux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
+	if (aux_data == NULL)
+		aux_len = 0;
+	else if (aux_len == 0)
+		aux_data = NULL;
+	down(&start_stop_sem);
+	/*
+	 * find a valid device which has been detected by the
+	 * probe function of the usb
+	 */
+	index = -1;
+	for (i = 0; i < NUMUSBDUXFAST; i++) {
+		if (usbduxfastsub[i].probed && !usbduxfastsub[i].attached) {
+			index = i;
+			break;
+		}
+	}
+	if (index < 0) {
+		dev_err(dev->class_dev,
+			"usbduxfast: error: attach failed, no usbduxfast devs connected to the usb bus.\n");
+		ret = -ENODEV;
+	} else
+		ret = usbduxfast_attach_common(dev, &usbduxfastsub[index],
+					       aux_data, aux_len);
 	up(&start_stop_sem);
-	printk(KERN_INFO "comedi%d: successfully attached to usbduxfast.\n",
-	       dev->minor);
+	return ret;
+}
 
-	return 0;
+/* is called from comedi_usb_auto_config() */
+static int usbduxfast_attach_usb(struct comedi_device *dev,
+				 struct usb_interface *uinterf)
+{
+	int ret;
+	struct usbduxfastsub_s *udfs;
+
+	dev->private = NULL;
+	down(&start_stop_sem);
+	udfs = usb_get_intfdata(uinterf);
+	if (!udfs || !udfs->probed) {
+		dev_err(dev->class_dev,
+			"usbduxfast: error: attach_usb failed, not connected\n");
+		ret = -ENODEV;
+	} else if (udfs->attached) {
+		dev_err(dev->class_dev,
+		       "usbduxfast: error: attach_usb failed, already attached\n");
+		ret = -ENODEV;
+	} else
+		ret = usbduxfast_attach_common(dev, udfs, NULL, 0);
+	up(&start_stop_sem);
+	return ret;
 }
 
 static void usbduxfast_detach(struct comedi_device *dev)
@@ -1737,7 +1761,8 @@ static struct comedi_driver driver_usbduxfast = {
 	.driver_name = "usbduxfast",
 	.module = THIS_MODULE,
 	.attach = usbduxfast_attach,
-	.detach = usbduxfast_detach
+	.detach = usbduxfast_detach,
+	.attach_usb = usbduxfast_attach_usb,
 };
 
 /*

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index f7d4f56c1688..2ee9ecd33539 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1667,7 +1667,7 @@ static int usbduxfast_attach(struct comedi_device *dev,
 	dev->board_name = BOARDNAME;
 
 	ret = comedi_alloc_subdevices(dev, 1);
-	if (ret < 0) {
+	if (ret) {
 		up(&(usbduxfastsub[index].sem));
 		up(&start_stop_sem);
 		return ret;

commit eea6838b1206b0ac90110f1a6f58e101aa496e99
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:15 2012 -0700

    staging: comedi: remove the "Allocate the subdevice..." comments
    
    These comments are redundant. The function name 'comedi_alloc_subdevices'
    provides this information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <ian@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 660dd4ee51e0..f7d4f56c1688 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1666,7 +1666,6 @@ static int usbduxfast_attach(struct comedi_device *dev,
 
 	dev->board_name = BOARDNAME;
 
-	/* allocate space for the subdevices */
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret < 0) {
 		up(&(usbduxfastsub[index].sem));

commit 0e4039f3112326d73f66b00fd18468a3804ed29e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:58:45 2012 -0700

    staging: comedi: remove the comed_alloc_subdevices "allocation failed" messages
    
    Remove all the "allocation failed" debug messages that are displayed
    when the comedi_alloc_subdevices call fails.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbot <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 262556ebc4db..660dd4ee51e0 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1669,8 +1669,6 @@ static int usbduxfast_attach(struct comedi_device *dev,
 	/* allocate space for the subdevices */
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret < 0) {
-		printk(KERN_ERR "comedi%d: usbduxfast: error alloc space for "
-		       "subdev\n", dev->minor);
 		up(&(usbduxfastsub[index].sem));
 		up(&start_stop_sem);
 		return ret;

commit fba1d0faf726b442ab8771d5e9fbaf5f5a4c624c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:58:27 2012 -0700

    staging: comedi: only set dev->n_subdevices when kcalloc succeedes
    
    It's possible for the kcalloc in comedi_alloc_subdevices to fail.
    Only set the dev->n_subdevices variable if the allocation is
    successful.
    
    Since the core sets dev->n_subdevices, remove all the places in the
    drivers where this variable was getting set.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index b2f7350c429f..262556ebc4db 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -126,11 +126,6 @@
  */
 #define NUMUSBDUXFAST	16
 
-/*
- * number of subdevices
- */
-#define N_SUBDEVICES	1
-
 /*
  * analogue in subdevice
  */
@@ -1671,11 +1666,8 @@ static int usbduxfast_attach(struct comedi_device *dev,
 
 	dev->board_name = BOARDNAME;
 
-	/* set number of subdevices */
-	dev->n_subdevices = N_SUBDEVICES;
-
 	/* allocate space for the subdevices */
-	ret = comedi_alloc_subdevices(dev, N_SUBDEVICES);
+	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: usbduxfast: error alloc space for "
 		       "subdev\n", dev->minor);

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 7b1d21a6fc53..b2f7350c429f 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1675,7 +1675,7 @@ static int usbduxfast_attach(struct comedi_device *dev,
 	dev->n_subdevices = N_SUBDEVICES;
 
 	/* allocate space for the subdevices */
-	ret = alloc_subdevices(dev, N_SUBDEVICES);
+	ret = comedi_alloc_subdevices(dev, N_SUBDEVICES);
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: usbduxfast: error alloc space for "
 		       "subdev\n", dev->minor);

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index c672ea3784a6..7b1d21a6fc53 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1726,43 +1726,19 @@ static int usbduxfast_attach(struct comedi_device *dev,
 	return 0;
 }
 
-static int usbduxfast_detach(struct comedi_device *dev)
+static void usbduxfast_detach(struct comedi_device *dev)
 {
-	struct usbduxfastsub_s *udfs;
-
-	if (!dev) {
-		printk(KERN_ERR "comedi?: usbduxfast: detach without dev "
-		       "variable...\n");
-		return -EFAULT;
-	}
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi%d: usbduxfast: detach usb device\n",
-	       dev->minor);
-#endif
-
-	udfs = dev->private;
-	if (!udfs) {
-		printk(KERN_ERR "comedi?: usbduxfast: detach without ptr to "
-		       "usbduxfastsub[]\n");
-		return -EFAULT;
+	struct usbduxfastsub_s *usb = dev->private;
+
+	if (usb) {
+		down(&usb->sem);
+		down(&start_stop_sem);
+		dev->private = NULL;
+		usb->attached = 0;
+		usb->comedidev = NULL;
+		up(&start_stop_sem);
+		up(&usb->sem);
 	}
-
-	down(&udfs->sem);
-	down(&start_stop_sem);
-	/*
-	 * Don't allow detach to free the private structure
-	 * It's one entry of of usbduxfastsub[]
-	 */
-	dev->private = NULL;
-	udfs->attached = 0;
-	udfs->comedidev = NULL;
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi%d: usbduxfast: detach: successfully "
-	       "removed\n", dev->minor);
-#endif
-	up(&start_stop_sem);
-	up(&udfs->sem);
-	return 0;
 }
 
 /*

commit e265af1bfa48dbacfe5727237ce6d756ce96431e
Author: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
Date:   Tue May 1 11:55:06 2012 +0530

    Staging: comedi: fix line over 80 character issue in usbduxfast.c
    
    This is a patch to the usbduxfast.c file that fixes up a line
    over 80 character warning found by the checkpatch.pl tool.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 2b4d25128995..c672ea3784a6 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -455,14 +455,15 @@ static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 	/* 7f92 to zero */
 	local_transfer_buffer[0] = 0;
 	/* bRequest, "Firmware" */
-	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,
-				VENDOR_DIR_OUT,	/* bmRequestType */
-				USBDUXFASTSUB_CPUCS,	/* Value */
-				0x0000,	/* Index */
-				/* address of the transfer buffer */
-				local_transfer_buffer,
-				1,	/* Length */
-				EZTIMEOUT);	/* Timeout */
+	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0),
+			      USBDUXFASTSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,	  /* bmRequestType */
+			      USBDUXFASTSUB_CPUCS,    /* Value */
+			      0x0000,	/* Index */
+			      /* address of the transfer buffer */
+			      local_transfer_buffer,
+			      1,      /* Length */
+			      EZTIMEOUT);    /* Timeout */
 	if (ret < 0) {
 		printk("comedi_: usbduxfast_: control msg failed (start)\n");
 		return ret;
@@ -479,7 +480,8 @@ static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 	/* 7f92 to one */
 	local_transfer_buffer[0] = 1;
 	/* bRequest, "Firmware" */
-	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,
+	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0),
+			      USBDUXFASTSUB_FIRMWARE,
 			      VENDOR_DIR_OUT,	/* bmRequestType */
 			      USBDUXFASTSUB_CPUCS,	/* Value */
 			      0x0000,	/* Index */
@@ -506,14 +508,15 @@ static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 	       startAddr, local_transfer_buffer[0]);
 #endif
 	/* brequest, firmware */
-	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,
-				VENDOR_DIR_OUT,	/* bmRequestType */
-				startAddr,	/* value */
-				0x0000,	/* index */
-				/* our local safe buffer */
-				local_transfer_buffer,
-				len,	/* length */
-				EZTIMEOUT);	/* timeout */
+	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0),
+			      USBDUXFASTSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,	/* bmRequestType */
+			      startAddr,	/* value */
+			      0x0000,	 /* index */
+			      /* our local safe buffer */
+			      local_transfer_buffer,
+			      len,	/* length */
+			      EZTIMEOUT);      /* timeout */
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi_: usbduxfast: result=%d\n", ret);

commit d8b6ca0850c558f21989d468801ad1414b1372c4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:59 2012 +0100

    staging: comedi: pass usb interface to comedi_usb_auto_config
    
    The comedi_usb_auto_config() and comedi_usb_auto_unconfig() functions
    currently take a 'struct usb_device *'.  It makes more sense to pass a
    'struct usb_interface *' to allow for composite USB devices.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index bf6198ea4e2b..2b4d25128995 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1442,7 +1442,7 @@ static void usbduxfast_firmware_request_complete_handler(const struct firmware
 							 *fw, void *context)
 {
 	struct usbduxfastsub_s *usbduxfastsub_tmp = context;
-	struct usb_device *usbdev = usbduxfastsub_tmp->usbdev;
+	struct usb_interface *uinterf = usbduxfastsub_tmp->interface;
 	int ret;
 
 	if (fw == NULL)
@@ -1455,12 +1455,12 @@ static void usbduxfast_firmware_request_complete_handler(const struct firmware
 	ret = firmwareUpload(usbduxfastsub_tmp, fw->data, fw->size);
 
 	if (ret) {
-		dev_err(&usbdev->dev,
+		dev_err(&uinterf->dev,
 			"Could not upload firmware (err=%d)\n", ret);
 		goto out;
 	}
 
-	comedi_usb_auto_config(usbdev, &driver_usbduxfast);
+	comedi_usb_auto_config(uinterf, &driver_usbduxfast);
  out:
 	release_firmware(fw);
 }
@@ -1608,7 +1608,7 @@ static void usbduxfastsub_disconnect(struct usb_interface *intf)
 		return;
 	}
 
-	comedi_usb_auto_unconfig(udev);
+	comedi_usb_auto_unconfig(intf);
 
 	down(&start_stop_sem);
 	down(&udfs->sem);

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 2a8e725b7859..bf6198ea4e2b 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -201,6 +201,8 @@ static struct usbduxfastsub_s usbduxfastsub[NUMUSBDUXFAST];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
+static struct comedi_driver driver_usbduxfast;	/* see below for initializer */
+
 /*
  * bulk transfers to usbduxfast
  */
@@ -1458,7 +1460,7 @@ static void usbduxfast_firmware_request_complete_handler(const struct firmware
 		goto out;
 	}
 
-	comedi_usb_auto_config(usbdev, BOARDNAME);
+	comedi_usb_auto_config(usbdev, &driver_usbduxfast);
  out:
 	release_firmware(fw);
 }

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 5b15e6df54e6..2a8e725b7859 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -180,7 +180,7 @@ struct usbduxfastsub_s {
 	/* comedi device for the interrupt context */
 	struct comedi_device *comedidev;
 	short int ai_cmd_running;	/* asynchronous command is running */
-	short int ai_continous;	/* continous aquisition */
+	short int ai_continous;	/* continous acquisition */
 	long int ai_sample_count;	/* number of samples to acquire */
 	uint8_t *dux_commands;	/* commands */
 	int ignore;		/* counter which ignores the first
@@ -392,7 +392,7 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 	p = urb->transfer_buffer;
 	if (!udfs->ignore) {
 		if (!udfs->ai_continous) {
-			/* not continous, fixed number of samples */
+			/* not continuous, fixed number of samples */
 			n = urb->actual_length / sizeof(uint16_t);
 			if (unlikely(udfs->ai_sample_count < n)) {
 				/*
@@ -775,7 +775,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		up(&udfs->sem);
 		return -EBUSY;
 	}
-	/* set current channel of the running aquisition to zero */
+	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 
 	/*
@@ -1182,7 +1182,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		}
 		udfs->ai_continous = 0;
 	} else {
-		/* continous aquisition */
+		/* continous acquisition */
 		udfs->ai_continous = 1;
 		udfs->ai_sample_count = 0;
 	}

commit 45f4d0243525b6bc747c946937ced437b135a84d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Oct 30 11:06:57 2010 +0200

    staging: Final semaphore cleanup
    
    Fixup the last remaining users of DECLARE_MUTEX and init_MUTEX.
    
    Scripted conversion, resulting code is binary equivalent.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    LKML-Reference: <20100907125057.278833764@linutronix.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 0a164a9a66c3..5b15e6df54e6 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -199,7 +199,7 @@ struct usbduxfastsub_s {
  */
 static struct usbduxfastsub_s usbduxfastsub[NUMUSBDUXFAST];
 
-static DECLARE_MUTEX(start_stop_sem);
+static DEFINE_SEMAPHORE(start_stop_sem);
 
 /*
  * bulk transfers to usbduxfast
@@ -1504,7 +1504,7 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 	       "connect to comedi.\n", index);
 #endif
 
-	init_MUTEX(&(usbduxfastsub[index].sem));
+	sema_init(&(usbduxfastsub[index].sem), 1);
 	/* save a pointer to the usb device */
 	usbduxfastsub[index].usbdev = udev;
 

commit f69b0d6451679f1466381a46ac7ab671a7b5668c
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Jul 12 17:15:46 2010 +0200

    Staging: fix typos concerning "address"
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 29c3c016b93a..0a164a9a66c3 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -67,7 +67,7 @@
 #define VENDOR_DIR_OUT		0x40
 
 /*
- * internal adresses of the 8051 processor
+ * internal addresses of the 8051 processor
  */
 #define USBDUXFASTSUB_CPUCS	0xE600
 

commit 94002c07ff0e207a883519ccc35c0b5390b29331
Author: Julia Lawall <julia@diku.dk>
Date:   Sat May 15 23:21:43 2010 +0200

    Staging: Use kmemdup
    
    Use kmemdup when some other buffer is immediately copied into the
    allocated region.
    
    A simplified version of the semantic patch that makes this change is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression from,to,size,flag;
    statement S;
    @@
    
    -  to = \(kmalloc\|kzalloc\)(size,flag);
    +  to = kmemdup(from,size,flag);
       if (to==NULL || ...) S
    -  memcpy(to, from, size);
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 0d72c416e73b..29c3c016b93a 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1368,13 +1368,12 @@ static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
 	}
 
 	/* we generate a local buffer for the firmware */
-	fwBuf = kzalloc(sizeFirmware, GFP_KERNEL);
+	fwBuf = kmemdup(firmwareBinary, sizeFirmware, GFP_KERNEL);
 	if (!fwBuf) {
 		dev_err(&usbduxfastsub->interface->dev,
 			"comedi_: mem alloc for firmware failed\n");
 		return -ENOMEM;
 	}
-	memcpy(fwBuf, firmwareBinary, sizeFirmware);
 
 	ret = usbduxfastsub_stop(usbduxfastsub);
 	if (ret < 0) {

commit 643a5420f1df521e08efae7b15d377314b88cb70
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 4 16:02:00 2010 -0700

    Staging: comedi: usbduxfast.c: mark a function static
    
    It does not need to be global.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 05b1973ea35f..0d72c416e73b 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -525,7 +525,7 @@ static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 	return 0;
 }
 
-int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
+static int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
 {
 	int ret;
 

commit de55a7a5a2f17212c8e7c9a391db8ab5b0187c43
Author: Stewart Robertson <stewart_r@aliencamel.com>
Date:   Sat Feb 27 17:05:38 2010 +0000

    Staging: comedi: fix comments over 80 issue in usbduxfast.c
    
    This is a patch to the usbduxfast.c file that fixes comments
    over 80 warnings found by the checkpatch.pl tool
    
    Signed-off-by: Stewart Robertson <stewart_r@aliencamel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index e89b81812538..05b1973ea35f 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -177,8 +177,8 @@ struct usbduxfastsub_s {
 	int16_t *insnBuffer;	/* input buffer for single insn */
 	int ifnum;		/* interface number */
 	struct usb_interface *interface;	/* interface structure */
-	struct comedi_device *comedidev;	/* comedi device for the interrupt
-						   context */
+	/* comedi device for the interrupt context */
+	struct comedi_device *comedidev;
 	short int ai_cmd_running;	/* asynchronous command is running */
 	short int ai_continous;	/* continous aquisition */
 	long int ai_sample_count;	/* number of samples to acquire */
@@ -271,7 +271,8 @@ static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs, int do_unlink)
 	udfs->ai_cmd_running = 0;
 
 	if (do_unlink)
-		ret = usbduxfastsub_unlink_InURBs(udfs);	/* stop aquistion */
+		/* stop aquistion */
+		ret = usbduxfastsub_unlink_InURBs(udfs);
 
 	return ret;
 }
@@ -451,13 +452,15 @@ static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 
 	/* 7f92 to zero */
 	local_transfer_buffer[0] = 0;
-	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
-			      VENDOR_DIR_OUT,	/* bmRequestType */
-			      USBDUXFASTSUB_CPUCS,	/* Value */
-			      0x0000,	/* Index */
-			      local_transfer_buffer,	/* address of the transfer buffer */
-			      1,	/* Length */
-			      EZTIMEOUT);	/* Timeout */
+	/* bRequest, "Firmware" */
+	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,
+				VENDOR_DIR_OUT,	/* bmRequestType */
+				USBDUXFASTSUB_CPUCS,	/* Value */
+				0x0000,	/* Index */
+				/* address of the transfer buffer */
+				local_transfer_buffer,
+				1,	/* Length */
+				EZTIMEOUT);	/* Timeout */
 	if (ret < 0) {
 		printk("comedi_: usbduxfast_: control msg failed (start)\n");
 		return ret;
@@ -473,7 +476,8 @@ static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 
 	/* 7f92 to one */
 	local_transfer_buffer[0] = 1;
-	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
+	/* bRequest, "Firmware" */
+	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,
 			      VENDOR_DIR_OUT,	/* bmRequestType */
 			      USBDUXFASTSUB_CPUCS,	/* Value */
 			      0x0000,	/* Index */
@@ -499,13 +503,15 @@ static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 	printk(KERN_DEBUG " to addr %d, first byte=%d.\n",
 	       startAddr, local_transfer_buffer[0]);
 #endif
-	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,	/* brequest, firmware */
-			      VENDOR_DIR_OUT,	/* bmRequestType */
-			      startAddr,	/* value */
-			      0x0000,	/* index */
-			      local_transfer_buffer,	/* our local safe buffer */
-			      len,	/* length */
-			      EZTIMEOUT);	/* timeout */
+	/* brequest, firmware */
+	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,
+				VENDOR_DIR_OUT,	/* bmRequestType */
+				startAddr,	/* value */
+				0x0000,	/* index */
+				/* our local safe buffer */
+				local_transfer_buffer,
+				len,	/* length */
+				EZTIMEOUT);	/* timeout */
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi_: usbduxfast: result=%d\n", ret);
@@ -1347,7 +1353,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 #define FIRMWARE_MAX_LEN 0x2000
 
 static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
-			  const u8 * firmwareBinary, int sizeFirmware)
+			  const u8 *firmwareBinary, int sizeFirmware)
 {
 	int ret;
 	uint8_t *fwBuf;

commit 02c7b237f6a01f580319187d4bdbf712b27a5460
Author: Alessio Igor Bogani <abogani@texware.it>
Date:   Fri Feb 26 08:44:27 2010 +0100

    Staging: Cleanup useless headers
    
    BKL isn't anymore present into these files thus it is no necessary still include smp_lock.h.
    
    Signed-off-by: Alessio Igor Bogani <abogani@texware.it>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index b96cf3b96fd3..e89b81812538 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -44,7 +44,6 @@
 #include <linux/slab.h>
 #include <linux/input.h>
 #include <linux/usb.h>
-#include <linux/smp_lock.h>
 #include <linux/fcntl.h>
 #include <linux/compiler.h>
 #include "comedi_fc.h"

commit 9d220c6b54f3d0b141846321814ec1c4e4fbdc67
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Jan 12 15:57:58 2010 +0100

    staging: fix typos "aquire" -> "acquire"
    
    This patch was generated by
    
        git grep -E -i -l '[Aa]quire' drivers/staging | xargs -r perl -p -i -e 's/([Aa])quire/$1cquire/'
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 4ff48860fc57..b96cf3b96fd3 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -182,7 +182,7 @@ struct usbduxfastsub_s {
 						   context */
 	short int ai_cmd_running;	/* asynchronous command is running */
 	short int ai_continous;	/* continous aquisition */
-	long int ai_sample_count;	/* number of samples to aquire */
+	long int ai_sample_count;	/* number of samples to acquire */
 	uint8_t *dux_commands;	/* commands */
 	int ignore;		/* counter which ignores the first
 				   buffers */

commit a457732b836b970c82c7ba35b4cfc938c9c543f9
Author: Németh Márton <nm127@freemail.hu>
Date:   Sun Jan 10 00:18:34 2010 +0100

    staging: make USB device id constant
    
    The id_table field of the struct usb_device_id is constant in <linux/usb.h>
    so it is worth to make the initialization data also constant.
    
    The semantic match that finds this kind of pattern is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    disable decl_init,const_decl_init;
    identifier I1, I2, x;
    @@
            struct I1 {
              ...
              const struct I2 *x;
              ...
            };
    @s@
    identifier r.I1, y;
    identifier r.x, E;
    @@
            struct I1 y = {
              .x = E,
            };
    @c@
    identifier r.I2;
    identifier s.E;
    @@
            const struct I2 E[] = ... ;
    @depends on !c@
    identifier r.I2;
    identifier s.E;
    @@
    +       const
            struct I2 E[] = ...;
    // </smpl>
    
    Signed-off-by: Németh Márton <nm127@freemail.hu>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: cocci@diku.dk
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 2e675cce7dbf..4ff48860fc57 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1769,7 +1769,7 @@ static struct comedi_driver driver_usbduxfast = {
 /*
  * Table with the USB-devices: just now only testing IDs
  */
-static struct usb_device_id usbduxfastsub_table[] = {
+static const struct usb_device_id usbduxfastsub_table[] = {
 	/* { USB_DEVICE(0x4b4, 0x8613) }, testing */
 	{USB_DEVICE(0x13d8, 0x0010)},	/* real ID */
 	{USB_DEVICE(0x13d8, 0x0011)},	/* real ID */

commit 9ebfbd45f9d4ee9cd72529cf99e5f300eb398e67
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Oct 29 12:36:02 2009 +0100

    firmware_class: make request_firmware_nowait more useful
    
    Unfortunately, one cannot hold on to the struct firmware
    that request_firmware_nowait() hands off, which is needed
    in some cases. Allow this by requiring the callback to
    free it (via release_firmware).
    
    Additionally, give it a gfp_t parameter -- all the current
    users call it from a GFP_KERNEL context so the GFP_ATOMIC
    isn't necessary. This also marks an API break which is
    useful in a sense, although that is obviously not the
    primary purpose of this change.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Pavel Roskin <proski@gnu.org>
    Cc: Abhay Salunke <abhay_salunke@dell.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index d143222579c2..2e675cce7dbf 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1451,10 +1451,12 @@ static void usbduxfast_firmware_request_complete_handler(const struct firmware
 	if (ret) {
 		dev_err(&usbdev->dev,
 			"Could not upload firmware (err=%d)\n", ret);
-		return;
+		goto out;
 	}
 
 	comedi_usb_auto_config(usbdev, BOARDNAME);
+ out:
+	release_firmware(fw);
 }
 
 /*
@@ -1569,6 +1571,7 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 				      FW_ACTION_HOTPLUG,
 				      "usbduxfast_firmware.bin",
 				      &udev->dev,
+				      GFP_KERNEL,
 				      usbduxfastsub + index,
 				      usbduxfast_firmware_request_complete_handler);
 

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 939b53fa569c..d143222579c2 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -50,7 +50,6 @@
 #include "comedi_fc.h"
 #include "../comedidev.h"
 
-
 #define DRIVER_VERSION "v1.0"
 #define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
 #define DRIVER_DESC "USB-DUXfast, BerndPorr@f2s.com"
@@ -161,7 +160,7 @@
  * comedi constants
  */
 static const struct comedi_lrange range_usbduxfast_ai_range = {
-	2, { BIP_RANGE(0.75), BIP_RANGE(0.5) }
+	2, {BIP_RANGE(0.75), BIP_RANGE(0.5)}
 };
 
 /*
@@ -171,22 +170,22 @@ static const struct comedi_lrange range_usbduxfast_ai_range = {
  * one sub device just now: A/D
  */
 struct usbduxfastsub_s {
-	int attached;			/* is attached? */
-	int probed;			/* is it associated with a subdevice? */
+	int attached;		/* is attached? */
+	int probed;		/* is it associated with a subdevice? */
 	struct usb_device *usbdev;	/* pointer to the usb-device */
-	struct urb *urbIn;		/* BULK-transfer handling: urb */
+	struct urb *urbIn;	/* BULK-transfer handling: urb */
 	int8_t *transfer_buffer;
-	int16_t *insnBuffer;		/* input buffer for single insn */
-	int ifnum;			/* interface number */
+	int16_t *insnBuffer;	/* input buffer for single insn */
+	int ifnum;		/* interface number */
 	struct usb_interface *interface;	/* interface structure */
 	struct comedi_device *comedidev;	/* comedi device for the interrupt
-					   context */
+						   context */
 	short int ai_cmd_running;	/* asynchronous command is running */
-	short int ai_continous;		/* continous aquisition */
+	short int ai_continous;	/* continous aquisition */
 	long int ai_sample_count;	/* number of samples to aquire */
-	uint8_t *dux_commands;		/* commands */
-	int ignore;			/* counter which ignores the first
-					   buffers */
+	uint8_t *dux_commands;	/* commands */
+	int ignore;		/* counter which ignores the first
+				   buffers */
 	struct semaphore sem;
 };
 
@@ -217,7 +216,7 @@ static int send_dux_commands(struct usbduxfastsub_s *udfs, int cmd_type)
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast: dux_commands: ",
-		udfs->comedidev->minor);
+	       udfs->comedidev->minor);
 	for (tmp = 0; tmp < SIZEOFDUXBUFFER; tmp++)
 		printk(" %02x", udfs->dux_commands[tmp]);
 	printk("\n");
@@ -228,7 +227,7 @@ static int send_dux_commands(struct usbduxfastsub_s *udfs, int cmd_type)
 			   udfs->dux_commands, SIZEOFDUXBUFFER, &nsent, 10000);
 	if (tmp < 0)
 		printk(KERN_ERR "comedi%d: could not transmit dux_commands to"
-		      "the usb-device, err=%d\n", udfs->comedidev->minor, tmp);
+		       "the usb-device, err=%d\n", udfs->comedidev->minor, tmp);
 	return tmp;
 }
 
@@ -258,8 +257,7 @@ static int usbduxfastsub_unlink_InURBs(struct usbduxfastsub_s *udfs)
  * Is called from within this driver from both the
  * interrupt context and from comedi.
  */
-static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs,
-	int do_unlink)
+static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs, int do_unlink)
 {
 	int ret = 0;
 
@@ -267,7 +265,6 @@ static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs,
 		printk(KERN_ERR "comedi?: usbduxfast_ai_stop: udfs=NULL!\n");
 		return -EFAULT;
 	}
-
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi: usbduxfast_ai_stop\n");
 #endif
@@ -275,7 +272,7 @@ static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs,
 	udfs->ai_cmd_running = 0;
 
 	if (do_unlink)
-		ret = usbduxfastsub_unlink_InURBs(udfs); /* stop aquistion */
+		ret = usbduxfastsub_unlink_InURBs(udfs);	/* stop aquistion */
 
 	return ret;
 }
@@ -284,7 +281,8 @@ static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs,
  * This will cancel a running acquisition operation.
  * This is called by comedi but never from inside the driver.
  */
-static int usbduxfast_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbduxfast_ai_cancel(struct comedi_device *dev,
+				struct comedi_subdevice *s)
 {
 	struct usbduxfastsub_s *udfs;
 	int ret;
@@ -402,9 +400,9 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 				 * received
 				 */
 				cfc_write_array_to_buffer(s,
-					urb->transfer_buffer,
-					udfs->ai_sample_count
-					* sizeof(uint16_t));
+							  urb->transfer_buffer,
+							  udfs->ai_sample_count
+							  * sizeof(uint16_t));
 				usbduxfast_ai_stop(udfs, 0);
 				/* tell comedi that the acquistion is over */
 				s->async->events |= COMEDI_CB_EOA;
@@ -439,7 +437,7 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
 		printk(KERN_ERR "comedi%d: usbduxfast: urb resubm failed: %d",
-			udfs->comedidev->minor, err);
+		       udfs->comedidev->minor, err);
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
 		comedi_event(udfs->comedidev, s);
@@ -454,15 +452,13 @@ static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 
 	/* 7f92 to zero */
 	local_transfer_buffer[0] = 0;
-	ret = usb_control_msg(udfs->usbdev,
-		usb_sndctrlpipe(udfs->usbdev, 0),
-		USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
-		VENDOR_DIR_OUT,		/* bmRequestType */
-		USBDUXFASTSUB_CPUCS,	/* Value */
-		0x0000,			/* Index */
-		local_transfer_buffer,	/* address of the transfer buffer */
-		1,			/* Length */
-		EZTIMEOUT);		/* Timeout */
+	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
+			      VENDOR_DIR_OUT,	/* bmRequestType */
+			      USBDUXFASTSUB_CPUCS,	/* Value */
+			      0x0000,	/* Index */
+			      local_transfer_buffer,	/* address of the transfer buffer */
+			      1,	/* Length */
+			      EZTIMEOUT);	/* Timeout */
 	if (ret < 0) {
 		printk("comedi_: usbduxfast_: control msg failed (start)\n");
 		return ret;
@@ -478,15 +474,12 @@ static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 
 	/* 7f92 to one */
 	local_transfer_buffer[0] = 1;
-	ret = usb_control_msg(udfs->usbdev,
-		usb_sndctrlpipe(udfs->usbdev, 0),
-		USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
-		VENDOR_DIR_OUT,		/* bmRequestType */
-		USBDUXFASTSUB_CPUCS,	/* Value */
-		0x0000,			/* Index */
-		local_transfer_buffer,
-		1,			/* Length */
-		EZTIMEOUT);		/* Timeout */
+	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
+			      VENDOR_DIR_OUT,	/* bmRequestType */
+			      USBDUXFASTSUB_CPUCS,	/* Value */
+			      0x0000,	/* Index */
+			      local_transfer_buffer, 1,	/* Length */
+			      EZTIMEOUT);	/* Timeout */
 	if (ret < 0) {
 		printk(KERN_ERR "comedi_: usbduxfast: control msg failed "
 		       "(stop)\n");
@@ -497,25 +490,23 @@ static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 }
 
 static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
-	unsigned char *local_transfer_buffer,
-	unsigned int startAddr, unsigned int len)
+				unsigned char *local_transfer_buffer,
+				unsigned int startAddr, unsigned int len)
 {
 	int ret;
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi: usbduxfast: uploading %d bytes", len);
 	printk(KERN_DEBUG " to addr %d, first byte=%d.\n",
-		startAddr, local_transfer_buffer[0]);
+	       startAddr, local_transfer_buffer[0]);
 #endif
-	ret = usb_control_msg(udfs->usbdev,
-		usb_sndctrlpipe(udfs->usbdev, 0),
-		USBDUXFASTSUB_FIRMWARE, /* brequest, firmware */
-		VENDOR_DIR_OUT,		/* bmRequestType */
-		startAddr,		/* value */
-		0x0000,			/* index */
-		local_transfer_buffer,	/* our local safe buffer */
-		len,			/* length */
-		EZTIMEOUT);		/* timeout */
+	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,	/* brequest, firmware */
+			      VENDOR_DIR_OUT,	/* bmRequestType */
+			      startAddr,	/* value */
+			      0x0000,	/* index */
+			      local_transfer_buffer,	/* our local safe buffer */
+			      len,	/* length */
+			      EZTIMEOUT);	/* timeout */
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi_: usbduxfast: result=%d\n", ret);
@@ -544,7 +535,7 @@ int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast: submitting in-urb: "
 	       "0x%p,0x%p\n", udfs->comedidev->minor, udfs->urbIn->context,
-		udfs->urbIn->dev);
+	       udfs->urbIn->dev);
 #endif
 	ret = usb_submit_urb(udfs->urbIn, GFP_ATOMIC);
 	if (ret) {
@@ -556,7 +547,8 @@ int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
 }
 
 static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_cmd *cmd)
+				 struct comedi_subdevice *s,
+				 struct comedi_cmd *cmd)
 {
 	int err = 0, stop_mask = 0;
 	long int steps, tmp;
@@ -608,16 +600,16 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	 */
 
 	if (cmd->start_src != TRIG_NOW &&
-		cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_INT)
+	    cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_INT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_FOLLOW &&
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
+	    cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
 		err++;
 
 	/* can't have external stop and start triggers at once */
@@ -698,7 +690,8 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 }
 
 static int usbduxfast_ai_inttrig(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int trignum)
+				 struct comedi_subdevice *s,
+				 unsigned int trignum)
 {
 	int ret;
 	struct usbduxfastsub_s *udfs = dev->private;
@@ -749,7 +742,8 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 #define OUTBASE	(1+0x10)
 #define LOGBASE	(1+0x18)
 
-static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbduxfast_ai_cmd(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain, rngmask = 0xff;
@@ -797,7 +791,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 				return -EINVAL;
 			}
 			if ((gain != CR_RANGE(cmd->chanlist[i]))
-				&& (cmd->chanlist_len > 3)) {
+			    && (cmd->chanlist_len > 3)) {
 				printk(KERN_ERR "comedi%d: the gain must be"
 				       " the same for all channels.\n",
 				       dev->minor);
@@ -835,7 +829,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 		return -EINVAL;
 	}
 	if ((cmd->start_src == TRIG_EXT) && (cmd->chanlist_len != 1)
-		&& (cmd->chanlist_len != 16)) {
+	    && (cmd->chanlist_len != 16)) {
 		printk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: TRIG_EXT only"
 		       " with 1 or 16 channels possible.\n", dev->minor);
 		up(&udfs->sem);
@@ -865,17 +859,17 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 		/* we loop here until ready has been set */
 		if (cmd->start_src == TRIG_EXT) {
 			/* branch back to state 0 */
-			udfs->dux_commands[LENBASE+0] = 0x01;
+			udfs->dux_commands[LENBASE + 0] = 0x01;
 			/* deceision state w/o data */
-			udfs->dux_commands[OPBASE+0] = 0x01;
-			udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
+			udfs->dux_commands[OPBASE + 0] = 0x01;
+			udfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
 			/* RDY0 = 0 */
-			udfs->dux_commands[LOGBASE+0] = 0x00;
+			udfs->dux_commands[LOGBASE + 0] = 0x00;
 		} else {	/* we just proceed to state 1 */
-			udfs->dux_commands[LENBASE+0] = 1;
-			udfs->dux_commands[OPBASE+0] = 0;
-			udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
-			udfs->dux_commands[LOGBASE+0] = 0;
+			udfs->dux_commands[LENBASE + 0] = 1;
+			udfs->dux_commands[OPBASE + 0] = 0;
+			udfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE + 0] = 0;
 		}
 
 		if (steps < MIN_SAMPLING_PERIOD) {
@@ -888,30 +882,33 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 				 */
 
 				/* branch back to state 1 */
-				udfs->dux_commands[LENBASE+1] = 0x89;
+				udfs->dux_commands[LENBASE + 1] = 0x89;
 				/* deceision state with data */
-				udfs->dux_commands[OPBASE+1] = 0x03;
-				udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
+				udfs->dux_commands[OPBASE + 1] = 0x03;
+				udfs->dux_commands[OUTBASE + 1] =
+				    0xFF & rngmask;
 				/* doesn't matter */
-				udfs->dux_commands[LOGBASE+1] = 0xFF;
+				udfs->dux_commands[LOGBASE + 1] = 0xFF;
 			} else {
 				/*
 				 * we loop through two states: data and delay
 				 * max rate is 15MHz
 				 */
-				udfs->dux_commands[LENBASE+1] = steps - 1;
+				udfs->dux_commands[LENBASE + 1] = steps - 1;
 				/* data */
-				udfs->dux_commands[OPBASE+1] = 0x02;
-				udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
+				udfs->dux_commands[OPBASE + 1] = 0x02;
+				udfs->dux_commands[OUTBASE + 1] =
+				    0xFF & rngmask;
 				/* doesn't matter */
-				udfs->dux_commands[LOGBASE+1] = 0;
+				udfs->dux_commands[LOGBASE + 1] = 0;
 				/* branch back to state 1 */
-				udfs->dux_commands[LENBASE+2] = 0x09;
+				udfs->dux_commands[LENBASE + 2] = 0x09;
 				/* deceision state w/o data */
-				udfs->dux_commands[OPBASE+2] = 0x01;
-				udfs->dux_commands[OUTBASE+2] = 0xFF & rngmask;
+				udfs->dux_commands[OPBASE + 2] = 0x01;
+				udfs->dux_commands[OUTBASE + 2] =
+				    0xFF & rngmask;
 				/* doesn't matter */
-				udfs->dux_commands[LOGBASE+2] = 0xFF;
+				udfs->dux_commands[LOGBASE + 2] = 0xFF;
 			}
 		} else {
 			/*
@@ -923,26 +920,26 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 			steps = steps - 1;
 
 			/* do the first part of the delay */
-			udfs->dux_commands[LENBASE+1] = steps / 2;
-			udfs->dux_commands[OPBASE+1] = 0;
-			udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
-			udfs->dux_commands[LOGBASE+1] = 0;
+			udfs->dux_commands[LENBASE + 1] = steps / 2;
+			udfs->dux_commands[OPBASE + 1] = 0;
+			udfs->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE + 1] = 0;
 
 			/* and the second part */
-			udfs->dux_commands[LENBASE+2] = steps - steps / 2;
-			udfs->dux_commands[OPBASE+2] = 0;
-			udfs->dux_commands[OUTBASE+2] = 0xFF & rngmask;
-			udfs->dux_commands[LOGBASE+2] = 0;
+			udfs->dux_commands[LENBASE + 2] = steps - steps / 2;
+			udfs->dux_commands[OPBASE + 2] = 0;
+			udfs->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE + 2] = 0;
 
 			/* get the data and branch back */
 
 			/* branch back to state 1 */
-			udfs->dux_commands[LENBASE+3] = 0x09;
+			udfs->dux_commands[LENBASE + 3] = 0x09;
 			/* deceision state w data */
-			udfs->dux_commands[OPBASE+3] = 0x03;
-			udfs->dux_commands[OUTBASE+3] = 0xFF & rngmask;
+			udfs->dux_commands[OPBASE + 3] = 0x03;
+			udfs->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
 			/* doesn't matter */
-			udfs->dux_commands[LOGBASE+3] = 0xFF;
+			udfs->dux_commands[LOGBASE + 3] = 0xFF;
 		}
 		break;
 
@@ -957,11 +954,11 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 		else
 			rngmask = 0xff;
 
-		udfs->dux_commands[LENBASE+0] = 1;
+		udfs->dux_commands[LENBASE + 0] = 1;
 		/* data */
-		udfs->dux_commands[OPBASE+0] = 0x02;
-		udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+0] = 0;
+		udfs->dux_commands[OPBASE + 0] = 0x02;
+		udfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 0] = 0;
 
 		/* we have 1 state with duration 1: state 0 */
 		steps_tmp = steps - 1;
@@ -972,23 +969,23 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 			rngmask = 0xff;
 
 		/* do the first part of the delay */
-		udfs->dux_commands[LENBASE+1] = steps_tmp / 2;
-		udfs->dux_commands[OPBASE+1] = 0;
+		udfs->dux_commands[LENBASE + 1] = steps_tmp / 2;
+		udfs->dux_commands[OPBASE + 1] = 0;
 		/* count */
-		udfs->dux_commands[OUTBASE+1] = 0xFE & rngmask;
-		udfs->dux_commands[LOGBASE+1] = 0;
+		udfs->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
+		udfs->dux_commands[LOGBASE + 1] = 0;
 
 		/* and the second part */
-		udfs->dux_commands[LENBASE+2] = steps_tmp - steps_tmp / 2;
-		udfs->dux_commands[OPBASE+2] = 0;
-		udfs->dux_commands[OUTBASE+2] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+2] = 0;
+		udfs->dux_commands[LENBASE + 2] = steps_tmp - steps_tmp / 2;
+		udfs->dux_commands[OPBASE + 2] = 0;
+		udfs->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 2] = 0;
 
-		udfs->dux_commands[LENBASE+3] = 1;
+		udfs->dux_commands[LENBASE + 3] = 1;
 		/* data */
-		udfs->dux_commands[OPBASE+3] = 0x02;
-		udfs->dux_commands[OUTBASE+3] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+3] = 0;
+		udfs->dux_commands[OPBASE + 3] = 0x02;
+		udfs->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 3] = 0;
 
 		/*
 		 * we have 2 states with duration 1: step 6 and
@@ -1002,22 +999,22 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 			rngmask = 0xff;
 
 		/* do the first part of the delay */
-		udfs->dux_commands[LENBASE+4] = steps_tmp / 2;
-		udfs->dux_commands[OPBASE+4] = 0;
+		udfs->dux_commands[LENBASE + 4] = steps_tmp / 2;
+		udfs->dux_commands[OPBASE + 4] = 0;
 		/* reset */
-		udfs->dux_commands[OUTBASE+4] = (0xFF - 0x02) & rngmask;
-		udfs->dux_commands[LOGBASE+4] = 0;
+		udfs->dux_commands[OUTBASE + 4] = (0xFF - 0x02) & rngmask;
+		udfs->dux_commands[LOGBASE + 4] = 0;
 
 		/* and the second part */
-		udfs->dux_commands[LENBASE+5] = steps_tmp - steps_tmp / 2;
-		udfs->dux_commands[OPBASE+5] = 0;
-		udfs->dux_commands[OUTBASE+5] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+5] = 0;
-
-		udfs->dux_commands[LENBASE+6] = 1;
-		udfs->dux_commands[OPBASE+6] = 0;
-		udfs->dux_commands[OUTBASE+6] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+6] = 0;
+		udfs->dux_commands[LENBASE + 5] = steps_tmp - steps_tmp / 2;
+		udfs->dux_commands[OPBASE + 5] = 0;
+		udfs->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 5] = 0;
+
+		udfs->dux_commands[LENBASE + 6] = 1;
+		udfs->dux_commands[OPBASE + 6] = 0;
+		udfs->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 6] = 0;
 		break;
 
 	case 3:
@@ -1033,12 +1030,12 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 			 * commit data to the FIFO and do the first part
 			 * of the delay
 			 */
-			udfs->dux_commands[LENBASE+j*2] = steps / 2;
+			udfs->dux_commands[LENBASE + j * 2] = steps / 2;
 			/* data */
-			udfs->dux_commands[OPBASE+j*2] = 0x02;
+			udfs->dux_commands[OPBASE + j * 2] = 0x02;
 			/* no change */
-			udfs->dux_commands[OUTBASE+j*2] = 0xFF & rngmask;
-			udfs->dux_commands[LOGBASE+j*2] = 0;
+			udfs->dux_commands[OUTBASE + j * 2] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE + j * 2] = 0;
 
 			if (CR_RANGE(cmd->chanlist[j + 1]) > 0)
 				rngmask = 0xff - 0x04;
@@ -1046,23 +1043,25 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 				rngmask = 0xff;
 
 			/* do the second part of the delay */
-			udfs->dux_commands[LENBASE+j*2+1] = steps - steps / 2;
+			udfs->dux_commands[LENBASE + j * 2 + 1] =
+			    steps - steps / 2;
 			/* no data */
-			udfs->dux_commands[OPBASE+j*2+1] = 0;
+			udfs->dux_commands[OPBASE + j * 2 + 1] = 0;
 			/* count */
-			udfs->dux_commands[OUTBASE+j*2+1] = 0xFE & rngmask;
-			udfs->dux_commands[LOGBASE+j*2+1] = 0;
+			udfs->dux_commands[OUTBASE + j * 2 + 1] =
+			    0xFE & rngmask;
+			udfs->dux_commands[LOGBASE + j * 2 + 1] = 0;
 		}
 
 		/* 2 steps with duration 1: the idele step and step 6: */
 		steps_tmp = steps - 2;
 
 		/* commit data to the FIFO and do the first part of the delay */
-		udfs->dux_commands[LENBASE+4] = steps_tmp / 2;
+		udfs->dux_commands[LENBASE + 4] = steps_tmp / 2;
 		/* data */
-		udfs->dux_commands[OPBASE+4] = 0x02;
-		udfs->dux_commands[OUTBASE+4] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+4] = 0;
+		udfs->dux_commands[OPBASE + 4] = 0x02;
+		udfs->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 4] = 0;
 
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
@@ -1070,17 +1069,17 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 			rngmask = 0xff;
 
 		/* do the second part of the delay */
-		udfs->dux_commands[LENBASE+5] = steps_tmp - steps_tmp / 2;
+		udfs->dux_commands[LENBASE + 5] = steps_tmp - steps_tmp / 2;
 		/* no data */
-		udfs->dux_commands[OPBASE+5] = 0;
+		udfs->dux_commands[OPBASE + 5] = 0;
 		/* reset */
-		udfs->dux_commands[OUTBASE+5] = (0xFF - 0x02) & rngmask;
-		udfs->dux_commands[LOGBASE+5] = 0;
+		udfs->dux_commands[OUTBASE + 5] = (0xFF - 0x02) & rngmask;
+		udfs->dux_commands[LOGBASE + 5] = 0;
 
-		udfs->dux_commands[LENBASE+6] = 1;
-		udfs->dux_commands[OPBASE+6] = 0;
-		udfs->dux_commands[OUTBASE+6] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+6] = 0;
+		udfs->dux_commands[LENBASE + 6] = 1;
+		udfs->dux_commands[OPBASE + 6] = 0;
+		udfs->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 6] = 0;
 
 	case 16:
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
@@ -1094,55 +1093,57 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 			 */
 
 			/* branch back to state 0 */
-			udfs->dux_commands[LENBASE+0] = 0x01;
+			udfs->dux_commands[LENBASE + 0] = 0x01;
 			/* deceision state w/o data */
-			udfs->dux_commands[OPBASE+0] = 0x01;
+			udfs->dux_commands[OPBASE + 0] = 0x01;
 			/* reset */
-			udfs->dux_commands[OUTBASE+0] = (0xFF-0x02) & rngmask;
+			udfs->dux_commands[OUTBASE + 0] =
+			    (0xFF - 0x02) & rngmask;
 			/* RDY0 = 0 */
-			udfs->dux_commands[LOGBASE+0] = 0x00;
+			udfs->dux_commands[LOGBASE + 0] = 0x00;
 		} else {
 			/*
 			 * we just proceed to state 1
 			 */
 
 			/* 30us reset pulse */
-			udfs->dux_commands[LENBASE+0] = 255;
-			udfs->dux_commands[OPBASE+0] = 0;
+			udfs->dux_commands[LENBASE + 0] = 255;
+			udfs->dux_commands[OPBASE + 0] = 0;
 			/* reset */
-			udfs->dux_commands[OUTBASE+0] = (0xFF-0x02) & rngmask;
-			udfs->dux_commands[LOGBASE+0] = 0;
+			udfs->dux_commands[OUTBASE + 0] =
+			    (0xFF - 0x02) & rngmask;
+			udfs->dux_commands[LOGBASE + 0] = 0;
 		}
 
 		/* commit data to the FIFO */
-		udfs->dux_commands[LENBASE+1] = 1;
+		udfs->dux_commands[LENBASE + 1] = 1;
 		/* data */
-		udfs->dux_commands[OPBASE+1] = 0x02;
-		udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+1] = 0;
+		udfs->dux_commands[OPBASE + 1] = 0x02;
+		udfs->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 1] = 0;
 
 		/* we have 2 states with duration 1 */
 		steps = steps - 2;
 
 		/* do the first part of the delay */
-		udfs->dux_commands[LENBASE+2] = steps / 2;
-		udfs->dux_commands[OPBASE+2] = 0;
-		udfs->dux_commands[OUTBASE+2] = 0xFE & rngmask;
-		udfs->dux_commands[LOGBASE+2] = 0;
+		udfs->dux_commands[LENBASE + 2] = steps / 2;
+		udfs->dux_commands[OPBASE + 2] = 0;
+		udfs->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
+		udfs->dux_commands[LOGBASE + 2] = 0;
 
 		/* and the second part */
-		udfs->dux_commands[LENBASE+3] = steps - steps / 2;
-		udfs->dux_commands[OPBASE+3] = 0;
-		udfs->dux_commands[OUTBASE+3] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+3] = 0;
+		udfs->dux_commands[LENBASE + 3] = steps - steps / 2;
+		udfs->dux_commands[OPBASE + 3] = 0;
+		udfs->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 3] = 0;
 
 		/* branch back to state 1 */
-		udfs->dux_commands[LENBASE+4] = 0x09;
+		udfs->dux_commands[LENBASE + 4] = 0x09;
 		/* deceision state w/o data */
-		udfs->dux_commands[OPBASE+4] = 0x01;
-		udfs->dux_commands[OUTBASE+4] = 0xFF & rngmask;
+		udfs->dux_commands[OPBASE + 4] = 0x01;
+		udfs->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
 		/* doesn't matter */
-		udfs->dux_commands[LOGBASE+4] = 0xFF;
+		udfs->dux_commands[LOGBASE + 4] = 0xFF;
 
 		break;
 
@@ -1166,7 +1167,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
 		return result;
 	}
 	if (cmd->stop_src == TRIG_COUNT) {
-		udfs->ai_sample_count =	cmd->stop_arg * cmd->scan_end_arg;
+		udfs->ai_sample_count = cmd->stop_arg * cmd->scan_end_arg;
 		if (udfs->ai_sample_count < 1) {
 			printk(KERN_ERR "comedi%d: "
 			       "(cmd->stop_arg)*(cmd->scan_end_arg)<1, "
@@ -1209,7 +1210,8 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
  * Mode 0 is used to get a single conversion on demand.
  */
 static int usbduxfast_ai_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	int i, j, n, actual_length;
 	int chan, range, rngmask;
@@ -1248,43 +1250,43 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 		rngmask = 0xff;
 
 	/* commit data to the FIFO */
-	udfs->dux_commands[LENBASE+0] = 1;
+	udfs->dux_commands[LENBASE + 0] = 1;
 	/* data */
-	udfs->dux_commands[OPBASE+0] = 0x02;
-	udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
-	udfs->dux_commands[LOGBASE+0] = 0;
+	udfs->dux_commands[OPBASE + 0] = 0x02;
+	udfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+	udfs->dux_commands[LOGBASE + 0] = 0;
 
 	/* do the first part of the delay */
-	udfs->dux_commands[LENBASE+1] = 12;
-	udfs->dux_commands[OPBASE+1] = 0;
-	udfs->dux_commands[OUTBASE+1] = 0xFE & rngmask;
-	udfs->dux_commands[LOGBASE+1] = 0;
-
-	udfs->dux_commands[LENBASE+2] = 1;
-	udfs->dux_commands[OPBASE+2] = 0;
-	udfs->dux_commands[OUTBASE+2] = 0xFE & rngmask;
-	udfs->dux_commands[LOGBASE+2] = 0;
-
-	udfs->dux_commands[LENBASE+3] = 1;
-	udfs->dux_commands[OPBASE+3] = 0;
-	udfs->dux_commands[OUTBASE+3] = 0xFE & rngmask;
-	udfs->dux_commands[LOGBASE+3] = 0;
-
-	udfs->dux_commands[LENBASE+4] = 1;
-	udfs->dux_commands[OPBASE+4] = 0;
-	udfs->dux_commands[OUTBASE+4] = 0xFE & rngmask;
-	udfs->dux_commands[LOGBASE+4] = 0;
+	udfs->dux_commands[LENBASE + 1] = 12;
+	udfs->dux_commands[OPBASE + 1] = 0;
+	udfs->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE + 1] = 0;
+
+	udfs->dux_commands[LENBASE + 2] = 1;
+	udfs->dux_commands[OPBASE + 2] = 0;
+	udfs->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE + 2] = 0;
+
+	udfs->dux_commands[LENBASE + 3] = 1;
+	udfs->dux_commands[OPBASE + 3] = 0;
+	udfs->dux_commands[OUTBASE + 3] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE + 3] = 0;
+
+	udfs->dux_commands[LENBASE + 4] = 1;
+	udfs->dux_commands[OPBASE + 4] = 0;
+	udfs->dux_commands[OUTBASE + 4] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE + 4] = 0;
 
 	/* second part */
-	udfs->dux_commands[LENBASE+5] = 12;
-	udfs->dux_commands[OPBASE+5] = 0;
-	udfs->dux_commands[OUTBASE+5] = 0xFF & rngmask;
-	udfs->dux_commands[LOGBASE+5] = 0;
+	udfs->dux_commands[LENBASE + 5] = 12;
+	udfs->dux_commands[OPBASE + 5] = 0;
+	udfs->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
+	udfs->dux_commands[LOGBASE + 5] = 0;
 
-	udfs->dux_commands[LENBASE+6] = 1;
-	udfs->dux_commands[OPBASE+6] = 0;
-	udfs->dux_commands[OUTBASE+6] = 0xFF & rngmask;
-	udfs->dux_commands[LOGBASE+0] = 0;
+	udfs->dux_commands[LENBASE + 6] = 1;
+	udfs->dux_commands[OPBASE + 6] = 0;
+	udfs->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
+	udfs->dux_commands[LOGBASE + 0] = 0;
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi %d: sending commands to the usb device\n",
@@ -1310,7 +1312,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 				   &actual_length, 10000);
 		if (err < 0) {
 			printk(KERN_ERR "comedi%d: insn timeout. No data.\n",
-				dev->minor);
+			       dev->minor);
 			up(&udfs->sem);
 			return err;
 		}
@@ -1323,7 +1325,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 				   &actual_length, 10000);
 		if (err < 0) {
 			printk(KERN_ERR "comedi%d: insn data error: %d\n",
-				dev->minor, err);
+			       dev->minor, err);
 			up(&udfs->sem);
 			return err;
 		}
@@ -1346,8 +1348,7 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 #define FIRMWARE_MAX_LEN 0x2000
 
 static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
-			  const u8 *firmwareBinary,
-			  int sizeFirmware)
+			  const u8 * firmwareBinary, int sizeFirmware)
 {
 	int ret;
 	uint8_t *fwBuf;
@@ -1355,7 +1356,7 @@ static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
 	if (!firmwareBinary)
 		return 0;
 
-	if (sizeFirmware>FIRMWARE_MAX_LEN) {
+	if (sizeFirmware > FIRMWARE_MAX_LEN) {
 		dev_err(&usbduxfastsub->interface->dev,
 			"comedi_: usbduxfast firmware binary it too large for FX2.\n");
 		return -ENOMEM;
@@ -1368,7 +1369,7 @@ static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
 			"comedi_: mem alloc for firmware failed\n");
 		return -ENOMEM;
 	}
-	memcpy(fwBuf,firmwareBinary,sizeFirmware);
+	memcpy(fwBuf, firmwareBinary, sizeFirmware);
 
 	ret = usbduxfastsub_stop(usbduxfastsub);
 	if (ret < 0) {
@@ -1396,8 +1397,6 @@ static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
 	return 0;
 }
 
-
-
 static void tidy_up(struct usbduxfastsub_s *udfs)
 {
 #ifdef CONFIG_COMEDI_DEBUG
@@ -1433,8 +1432,8 @@ static void tidy_up(struct usbduxfastsub_s *udfs)
 	udfs->ai_cmd_running = 0;
 }
 
-static void usbduxfast_firmware_request_complete_handler(const struct firmware *fw,
-							 void *context)
+static void usbduxfast_firmware_request_complete_handler(const struct firmware
+							 *fw, void *context)
 {
 	struct usbduxfastsub_s *usbduxfastsub_tmp = context;
 	struct usb_device *usbdev = usbduxfastsub_tmp->usbdev;
@@ -1451,8 +1450,7 @@ static void usbduxfast_firmware_request_complete_handler(const struct firmware *
 
 	if (ret) {
 		dev_err(&usbdev->dev,
-			"Could not upload firmware (err=%d)\n",
-			ret);
+			"Could not upload firmware (err=%d)\n", ret);
 		return;
 	}
 
@@ -1463,7 +1461,7 @@ static void usbduxfast_firmware_request_complete_handler(const struct firmware *
  * allocate memory for the urbs and initialise them
  */
 static int usbduxfastsub_probe(struct usb_interface *uinterf,
-	const struct usb_device_id *id)
+			       const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
 	int i;
@@ -1539,7 +1537,7 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 	}
 	/* setting to alternate setting 1: enabling bulk ep */
 	i = usb_set_interface(usbduxfastsub[index].usbdev,
-		usbduxfastsub[index].ifnum, 1);
+			      usbduxfastsub[index].ifnum, 1);
 	if (i < 0) {
 		printk(KERN_ERR "comedi_: usbduxfast%d: could not switch to "
 		       "alternate setting 1.\n", index);
@@ -1575,8 +1573,7 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 				      usbduxfast_firmware_request_complete_handler);
 
 	if (ret) {
-		dev_err(&udev->dev, "could not load firmware (err=%d)\n",
-			ret);
+		dev_err(&udev->dev, "could not load firmware (err=%d)\n", ret);
 		return ret;
 	}
 
@@ -1618,7 +1615,8 @@ static void usbduxfastsub_disconnect(struct usb_interface *intf)
 /*
  * is called when comedi-config is called
  */
-static int usbduxfast_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int usbduxfast_attach(struct comedi_device *dev,
+			     struct comedi_devconfig *it)
 {
 	int ret;
 	int index;
@@ -1725,7 +1723,6 @@ static int usbduxfast_detach(struct comedi_device *dev)
 		       "variable...\n");
 		return -EFAULT;
 	}
-
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast: detach usb device\n",
 	       dev->minor);
@@ -1760,10 +1757,10 @@ static int usbduxfast_detach(struct comedi_device *dev)
  * main driver struct
  */
 static struct comedi_driver driver_usbduxfast = {
-	.driver_name	= "usbduxfast",
-	.module		= THIS_MODULE,
-	.attach		= usbduxfast_attach,
-	.detach		= usbduxfast_detach
+	.driver_name = "usbduxfast",
+	.module = THIS_MODULE,
+	.attach = usbduxfast_attach,
+	.detach = usbduxfast_detach
 };
 
 /*
@@ -1771,9 +1768,9 @@ static struct comedi_driver driver_usbduxfast = {
  */
 static struct usb_device_id usbduxfastsub_table[] = {
 	/* { USB_DEVICE(0x4b4, 0x8613) }, testing */
-	{ USB_DEVICE(0x13d8, 0x0010) },	/* real ID */
-	{ USB_DEVICE(0x13d8, 0x0011) },	/* real ID */
-	{ }			/* Terminating entry */
+	{USB_DEVICE(0x13d8, 0x0010)},	/* real ID */
+	{USB_DEVICE(0x13d8, 0x0011)},	/* real ID */
+	{}			/* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE(usb, usbduxfastsub_table);
@@ -1783,12 +1780,12 @@ MODULE_DEVICE_TABLE(usb, usbduxfastsub_table);
  */
 static struct usb_driver usbduxfastsub_driver = {
 #ifdef COMEDI_HAVE_USB_DRIVER_OWNER
-	.owner		= THIS_MODULE,
+	.owner = THIS_MODULE,
 #endif
-	.name		= BOARDNAME,
-	.probe		= usbduxfastsub_probe,
-	.disconnect	= usbduxfastsub_disconnect,
-	.id_table	= usbduxfastsub_table
+	.name = BOARDNAME,
+	.probe = usbduxfastsub_probe,
+	.disconnect = usbduxfastsub_disconnect,
+	.id_table = usbduxfastsub_table
 };
 
 /*

commit efe8d60a923ddd00de394381cb30aab5114b71a4
Author: Bernd Porr <BerndPorr@f2s.com>
Date:   Sun May 24 20:36:09 2009 +0100

    Staging: comedi: usbdux: buffer overflow error handling
    
    These changes guarantee that the URBs are not resubmitted in case of a
    comedi buffer overflow.  Otherwise this runs in the background even when
    the userspace program has terminated.
    
    From: Bernd Porr <BerndPorr@f2s.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 5862078bfbb9..939b53fa569c 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -406,7 +406,7 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 					udfs->ai_sample_count
 					* sizeof(uint16_t));
 				usbduxfast_ai_stop(udfs, 0);
-				/* say comedi that the acquistion is over */
+				/* tell comedi that the acquistion is over */
 				s->async->events |= COMEDI_CB_EOA;
 				comedi_event(udfs->comedidev, s);
 				return;
@@ -414,8 +414,13 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 			udfs->ai_sample_count -= n;
 		}
 		/* write the full buffer to comedi */
-		cfc_write_array_to_buffer(s, urb->transfer_buffer,
-					  urb->actual_length);
+		err = cfc_write_array_to_buffer(s, urb->transfer_buffer,
+						urb->actual_length);
+		if (unlikely(err == 0)) {
+			/* buffer overflow */
+			usbduxfast_ai_stop(udfs, 0);
+			return;
+		}
 
 		/* tell comedi that data is there */
 		comedi_event(udfs->comedidev, s);

commit 81874ff7895f332920621104308e803434a17183
Author: Bernd Porr <BerndPorr@f2s.com>
Date:   Fri Apr 17 21:21:46 2009 +0100

    Staging: comedi: convert usbdux* to use firmware_request
    
    The firmware is now in the linux-firmware tree, so we can move these two
    drivers to use the proper request_firmware infrastructure.
    
    
    From: Bernd Porr <BerndPorr@f2s.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 6435f6c4191a..5862078bfbb9 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -524,33 +524,6 @@ static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 	return 0;
 }
 
-int firmwareUpload(struct usbduxfastsub_s *udfs, unsigned char *firmwareBinary,
-		   int sizeFirmware)
-{
-	int ret;
-
-	if (!firmwareBinary)
-		return 0;
-
-	ret = usbduxfastsub_stop(udfs);
-	if (ret < 0) {
-		printk(KERN_ERR "comedi_: usbduxfast: can not stop firmware\n");
-		return ret;
-	}
-	ret = usbduxfastsub_upload(udfs, firmwareBinary, 0, sizeFirmware);
-	if (ret < 0) {
-		printk(KERN_ERR "comedi_: usbduxfast: firmware upload failed\n");
-		return ret;
-	}
-	ret = usbduxfastsub_start(udfs);
-	if (ret < 0) {
-		printk(KERN_ERR "comedi_: usbduxfast: can not start firmware\n");
-		return ret;
-	}
-
-	return 0;
-}
-
 int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
 {
 	int ret;
@@ -1365,136 +1338,61 @@ static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	return i;
 }
 
-static unsigned hex2unsigned(char *h)
-{
-	unsigned hi, lo;
-
-	if (h[0] > '9')
-		hi = h[0] - 'A' + 0x0a;
-	else
-		hi = h[0] - '0';
-
-	if (h[1] > '9')
-		lo = h[1] - 'A' + 0x0a;
-	else
-		lo = h[1] - '0';
-
-	return hi * 0x10 + lo;
-}
-
-/* for FX2 */
 #define FIRMWARE_MAX_LEN 0x2000
 
-/*
- * taken from David Brownell's fxload and adjusted for this driver
- */
-static int read_firmware(struct usbduxfastsub_s *udfs, const void *firmwarePtr,
-			 long size)
+static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
+			  const u8 *firmwareBinary,
+			  int sizeFirmware)
 {
-	int i = 0;
-	unsigned char *fp = (char *)firmwarePtr;
-	unsigned char *firmwareBinary;
-	int res = 0;
-	int maxAddr = 0;
-
-	firmwareBinary = kmalloc(FIRMWARE_MAX_LEN, GFP_KERNEL);
-	if (!firmwareBinary) {
-		printk(KERN_ERR "comedi_: usbduxfast: mem alloc for firmware "
-		       " failed\n");
-		return -ENOMEM;
-	}
-
-	for (;;) {
-		char buf[256], *cp;
-		char type;
-		int len;
-		int idx, off;
-		int j = 0;
-
-		/* get one line */
-		while ((i < size) && (fp[i] != 13) && (fp[i] != 10)) {
-			buf[j] = fp[i];
-			i++;
-			j++;
-			if (j >= sizeof(buf)) {
-				printk(KERN_ERR "comedi_: usbduxfast: bogus "
-				       "firmware file!\n");
-				kfree(firmwareBinary);
-				return -1;
-			}
-		}
-		/* get rid of LF/CR/... */
-		while ((i < size) && ((fp[i] == 13) || (fp[i] == 10)
-					|| (fp[i] == 0)))
-			i++;
-
-		buf[j] = 0;
-		/* printk("comedi_: buf=%s\n",buf); */
-
-		/*
-		 * EXTENSION: "# comment-till-end-of-line",
-		 * for copyrights etc
-		 */
-		if (buf[0] == '#')
-			continue;
-
-		if (buf[0] != ':') {
-			printk(KERN_ERR "comedi_: usbduxfast: upload: not an "
-			       "ihex record: %s", buf);
-			kfree(firmwareBinary);
-			return -EFAULT;
-		}
-
-		/* Read the length field (up to 16 bytes) */
-		len = hex2unsigned(buf + 1);
-
-		/* Read the target offset */
-		off = (hex2unsigned(buf + 3) * 0x0100) + hex2unsigned(buf + 5);
-
-		if ((off + len) > maxAddr)
-			maxAddr = off + len;
-
-		if (maxAddr >= FIRMWARE_MAX_LEN) {
-			printk(KERN_ERR "comedi_: usbduxfast: firmware upload "
-			       "goes beyond FX2 RAM boundaries.");
-			kfree(firmwareBinary);
-			return -EFAULT;
-		}
-		/* printk("comedi_: usbduxfast: off=%x, len=%x:",off,len); */
-
-		/* Read the record type */
-		type = hex2unsigned(buf + 7);
-
-		/* If this is an EOF record, then make it so. */
-		if (type == 1)
-			break;
+	int ret;
+	uint8_t *fwBuf;
 
-		if (type != 0) {
-			printk(KERN_ERR "comedi_: usbduxfast: unsupported "
-			       "record type: %u\n", type);
-			kfree(firmwareBinary);
-			return -EFAULT;
-		}
+	if (!firmwareBinary)
+		return 0;
 
-		for (idx = 0, cp = buf + 9; idx < len; idx += 1, cp += 2) {
-			firmwareBinary[idx + off] = hex2unsigned(cp);
-			/* printk("%02x ",firmwareBinary[idx+off]); */
-		}
+	if (sizeFirmware>FIRMWARE_MAX_LEN) {
+		dev_err(&usbduxfastsub->interface->dev,
+			"comedi_: usbduxfast firmware binary it too large for FX2.\n");
+		return -ENOMEM;
+	}
 
-		/* printk("\n"); */
+	/* we generate a local buffer for the firmware */
+	fwBuf = kzalloc(sizeFirmware, GFP_KERNEL);
+	if (!fwBuf) {
+		dev_err(&usbduxfastsub->interface->dev,
+			"comedi_: mem alloc for firmware failed\n");
+		return -ENOMEM;
+	}
+	memcpy(fwBuf,firmwareBinary,sizeFirmware);
 
-		if (i >= size) {
-			printk(KERN_ERR "comedi_: usbduxfast: unexpected end "
-			       "of hex file\n");
-			break;
-		}
+	ret = usbduxfastsub_stop(usbduxfastsub);
+	if (ret < 0) {
+		dev_err(&usbduxfastsub->interface->dev,
+			"comedi_: can not stop firmware\n");
+		kfree(fwBuf);
+		return ret;
+	}
 
+	ret = usbduxfastsub_upload(usbduxfastsub, fwBuf, 0, sizeFirmware);
+	if (ret < 0) {
+		dev_err(&usbduxfastsub->interface->dev,
+			"comedi_: firmware upload failed\n");
+		kfree(fwBuf);
+		return ret;
 	}
-	res = firmwareUpload(udfs, firmwareBinary, maxAddr + 1);
-	kfree(firmwareBinary);
-	return res;
+	ret = usbduxfastsub_start(usbduxfastsub);
+	if (ret < 0) {
+		dev_err(&usbduxfastsub->interface->dev,
+			"comedi_: can not start firmware\n");
+		kfree(fwBuf);
+		return ret;
+	}
+	kfree(fwBuf);
+	return 0;
 }
 
+
+
 static void tidy_up(struct usbduxfastsub_s *udfs)
 {
 #ifdef CONFIG_COMEDI_DEBUG
@@ -1544,7 +1442,7 @@ static void usbduxfast_firmware_request_complete_handler(const struct firmware *
 	 * we need to upload the firmware here because fw will be
 	 * freed once we've left this function
 	 */
-	ret = read_firmware(usbduxfastsub_tmp, fw->data, fw->size);
+	ret = firmwareUpload(usbduxfastsub_tmp, fw->data, fw->size);
 
 	if (ret) {
 		dev_err(&usbdev->dev,
@@ -1666,7 +1564,7 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 
 	ret = request_firmware_nowait(THIS_MODULE,
 				      FW_ACTION_HOTPLUG,
-				      "usbduxfast_firmware.hex",
+				      "usbduxfast_firmware.bin",
 				      &udev->dev,
 				      usbduxfastsub + index,
 				      usbduxfast_firmware_request_complete_handler);
@@ -1751,9 +1649,9 @@ static int usbduxfast_attach(struct comedi_device *dev, struct comedi_devconfig
 	/* trying to upload the firmware into the chip */
 	if (comedi_aux_data(it->options, 0) &&
 	    it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
-		read_firmware(&usbduxfastsub[index],
-			      comedi_aux_data(it->options, 0),
-			      it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
+		firmwareUpload(&usbduxfastsub[index],
+			       comedi_aux_data(it->options, 0),
+			       it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
 	}
 
 	dev->board_name = BOARDNAME;

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 2fb64de3f86b..6435f6c4191a 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -314,7 +314,7 @@ static int usbduxfast_ai_cancel(struct comedi_device *dev, struct comedi_subdevi
  * analogue IN
  * interrupt service routine
  */
-static void usbduxfastsub_ai_Irq(struct urb *urb PT_REGS_ARG)
+static void usbduxfastsub_ai_Irq(struct urb *urb)
 {
 	int n, err;
 	struct usbduxfastsub_s *udfs;

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index d1ea6ed934ef..2fb64de3f86b 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1715,7 +1715,7 @@ static void usbduxfastsub_disconnect(struct usb_interface *intf)
 /*
  * is called when comedi-config is called
  */
-static int usbduxfast_attach(struct comedi_device *dev, comedi_devconfig *it)
+static int usbduxfast_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int ret;
 	int index;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index bbd552f2a500..d1ea6ed934ef 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1231,7 +1231,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice
  * Mode 0 is used to get a single conversion on demand.
  */
 static int usbduxfast_ai_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, comedi_insn *insn, unsigned int *data)
+	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
 {
 	int i, j, n, actual_length;
 	int chan, range, rngmask;

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index a5e93ac066bb..bbd552f2a500 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -578,7 +578,7 @@ int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
 }
 
 static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
-	struct comedi_subdevice *s, comedi_cmd *cmd)
+	struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0, stop_mask = 0;
 	long int steps, tmp;
@@ -773,7 +773,7 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 
 static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain, rngmask = 0xff;
 	int i, j, ret;
 	struct usbduxfastsub_s *udfs;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 54b49580505a..a5e93ac066bb 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -160,7 +160,7 @@
 /*
  * comedi constants
  */
-static const comedi_lrange range_usbduxfast_ai_range = {
+static const struct comedi_lrange range_usbduxfast_ai_range = {
 	2, { BIP_RANGE(0.75), BIP_RANGE(0.5) }
 };
 

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index e141484f11ae..54b49580505a 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1856,7 +1856,7 @@ static int usbduxfast_detach(struct comedi_device *dev)
 /*
  * main driver struct
  */
-static comedi_driver driver_usbduxfast = {
+static struct comedi_driver driver_usbduxfast = {
 	.driver_name	= "usbduxfast",
 	.module		= THIS_MODULE,
 	.attach		= usbduxfast_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index ff4a546a157a..e141484f11ae 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -284,7 +284,7 @@ static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs,
  * This will cancel a running acquisition operation.
  * This is called by comedi but never from inside the driver.
  */
-static int usbduxfast_ai_cancel(struct comedi_device *dev, comedi_subdevice *s)
+static int usbduxfast_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct usbduxfastsub_s *udfs;
 	int ret;
@@ -319,7 +319,7 @@ static void usbduxfastsub_ai_Irq(struct urb *urb PT_REGS_ARG)
 	int n, err;
 	struct usbduxfastsub_s *udfs;
 	struct comedi_device *this_comedidev;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	uint16_t *p;
 
 	/* sanity checks - is the urb there? */
@@ -578,7 +578,7 @@ int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
 }
 
 static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
-	comedi_subdevice *s, comedi_cmd *cmd)
+	struct comedi_subdevice *s, comedi_cmd *cmd)
 {
 	int err = 0, stop_mask = 0;
 	long int steps, tmp;
@@ -720,7 +720,7 @@ static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 }
 
 static int usbduxfast_ai_inttrig(struct comedi_device *dev,
-	comedi_subdevice *s, unsigned int trignum)
+	struct comedi_subdevice *s, unsigned int trignum)
 {
 	int ret;
 	struct usbduxfastsub_s *udfs = dev->private;
@@ -771,7 +771,7 @@ static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 #define OUTBASE	(1+0x10)
 #define LOGBASE	(1+0x18)
 
-static int usbduxfast_ai_cmd(struct comedi_device *dev, comedi_subdevice *s)
+static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain, rngmask = 0xff;
@@ -1231,7 +1231,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev, comedi_subdevice *s)
  * Mode 0 is used to get a single conversion on demand.
  */
 static int usbduxfast_ai_insn_read(struct comedi_device *dev,
-	comedi_subdevice *s, comedi_insn *insn, unsigned int *data)
+	struct comedi_subdevice *s, comedi_insn *insn, unsigned int *data)
 {
 	int i, j, n, actual_length;
 	int chan, range, rngmask;
@@ -1720,7 +1720,7 @@ static int usbduxfast_attach(struct comedi_device *dev, comedi_devconfig *it)
 	int ret;
 	int index;
 	int i;
-	comedi_subdevice *s = NULL;
+	struct comedi_subdevice *s = NULL;
 	dev->private = NULL;
 
 	down(&start_stop_sem);

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index aa21914318c8..ff4a546a157a 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -179,7 +179,7 @@ struct usbduxfastsub_s {
 	int16_t *insnBuffer;		/* input buffer for single insn */
 	int ifnum;			/* interface number */
 	struct usb_interface *interface;	/* interface structure */
-	comedi_device *comedidev;	/* comedi device for the interrupt
+	struct comedi_device *comedidev;	/* comedi device for the interrupt
 					   context */
 	short int ai_cmd_running;	/* asynchronous command is running */
 	short int ai_continous;		/* continous aquisition */
@@ -284,7 +284,7 @@ static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs,
  * This will cancel a running acquisition operation.
  * This is called by comedi but never from inside the driver.
  */
-static int usbduxfast_ai_cancel(comedi_device *dev, comedi_subdevice *s)
+static int usbduxfast_ai_cancel(struct comedi_device *dev, comedi_subdevice *s)
 {
 	struct usbduxfastsub_s *udfs;
 	int ret;
@@ -318,7 +318,7 @@ static void usbduxfastsub_ai_Irq(struct urb *urb PT_REGS_ARG)
 {
 	int n, err;
 	struct usbduxfastsub_s *udfs;
-	comedi_device *this_comedidev;
+	struct comedi_device *this_comedidev;
 	comedi_subdevice *s;
 	uint16_t *p;
 
@@ -577,7 +577,7 @@ int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
 	return 0;
 }
 
-static int usbduxfast_ai_cmdtest(comedi_device *dev,
+static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
 	comedi_subdevice *s, comedi_cmd *cmd)
 {
 	int err = 0, stop_mask = 0;
@@ -719,7 +719,7 @@ static int usbduxfast_ai_cmdtest(comedi_device *dev,
 
 }
 
-static int usbduxfast_ai_inttrig(comedi_device *dev,
+static int usbduxfast_ai_inttrig(struct comedi_device *dev,
 	comedi_subdevice *s, unsigned int trignum)
 {
 	int ret;
@@ -771,7 +771,7 @@ static int usbduxfast_ai_inttrig(comedi_device *dev,
 #define OUTBASE	(1+0x10)
 #define LOGBASE	(1+0x18)
 
-static int usbduxfast_ai_cmd(comedi_device *dev, comedi_subdevice *s)
+static int usbduxfast_ai_cmd(struct comedi_device *dev, comedi_subdevice *s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain, rngmask = 0xff;
@@ -1230,7 +1230,7 @@ static int usbduxfast_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 /*
  * Mode 0 is used to get a single conversion on demand.
  */
-static int usbduxfast_ai_insn_read(comedi_device *dev,
+static int usbduxfast_ai_insn_read(struct comedi_device *dev,
 	comedi_subdevice *s, comedi_insn *insn, unsigned int *data)
 {
 	int i, j, n, actual_length;
@@ -1715,7 +1715,7 @@ static void usbduxfastsub_disconnect(struct usb_interface *intf)
 /*
  * is called when comedi-config is called
  */
-static int usbduxfast_attach(comedi_device *dev, comedi_devconfig *it)
+static int usbduxfast_attach(struct comedi_device *dev, comedi_devconfig *it)
 {
 	int ret;
 	int index;
@@ -1813,7 +1813,7 @@ static int usbduxfast_attach(comedi_device *dev, comedi_devconfig *it)
 	return 0;
 }
 
-static int usbduxfast_detach(comedi_device *dev)
+static int usbduxfast_detach(struct comedi_device *dev)
 {
 	struct usbduxfastsub_s *udfs;
 

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 95b5807bcd41..aa21914318c8 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1231,7 +1231,7 @@ static int usbduxfast_ai_cmd(comedi_device *dev, comedi_subdevice *s)
  * Mode 0 is used to get a single conversion on demand.
  */
 static int usbduxfast_ai_insn_read(comedi_device *dev,
-	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
+	comedi_subdevice *s, comedi_insn *insn, unsigned int *data)
 {
 	int i, j, n, actual_length;
 	int chan, range, rngmask;

commit e57795a1a7ebf8ac91cfb82070cf19bf01ee4ac0
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Tue Mar 3 19:38:33 2009 +0100

    Staging: comedi: usbduxfast: balance semaphores up/down in attach error path
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index a8d64697b40a..95b5807bcd41 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1766,6 +1766,7 @@ static int usbduxfast_attach(comedi_device *dev, comedi_devconfig *it)
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: usbduxfast: error alloc space for "
 		       "subdev\n", dev->minor);
+		up(&(usbduxfastsub[index].sem));
 		up(&start_stop_sem);
 		return ret;
 	}

commit 3944969427e11f3081d676c16cebeff4060ce992
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Tue Mar 3 19:38:32 2009 +0100

    Staging: comedi: usbduxfast: don't initialize semaphores on init
    
    This patch removes usbduxfast semaphores initialization
    from init function as they are initialized later on in
    probe function. Also remove init_usb_devices() as it is
    not needed anymore.
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 1712f1db5a92..a8d64697b40a 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1862,23 +1862,6 @@ static comedi_driver driver_usbduxfast = {
 	.detach		= usbduxfast_detach
 };
 
-static void __init init_usb_devices(void)
-{
-	int index;
-
-#ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi_: usbduxfast: setting all possible devs to "
-	       "invalid\n");
-#endif
-	/*
-	 * all devices entries are invalid to begin with
-	 * they will become valid by the probe function
-	 * and then finally by the attach-function
-	 */
-	for (index = 0; index < NUMUSBDUXFAST; index++)
-		init_MUTEX(&(usbduxfastsub[index].sem));
-}
-
 /*
  * Table with the USB-devices: just now only testing IDs
  */
@@ -1912,7 +1895,6 @@ static int __init init_usbduxfast(void)
 {
 	printk(KERN_INFO
 	       KBUILD_MODNAME ": " DRIVER_VERSION ":" DRIVER_DESC "\n");
-	init_usb_devices();
 	usb_register(&usbduxfastsub_driver);
 	comedi_driver_register(&driver_usbduxfast);
 	return 0;

commit 38c39e43f90fa7ab891a2590a59497fe0a10cee2
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Tue Mar 3 19:38:31 2009 +0100

    Staging: comedi: usbduxfast: remove .bss variable initialization
    
    This patch removes explicit zeroing of usbduxfastsub
    variable on init because it is in .bss section.
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 2c888d1f3afc..1712f1db5a92 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1875,11 +1875,8 @@ static void __init init_usb_devices(void)
 	 * they will become valid by the probe function
 	 * and then finally by the attach-function
 	 */
-	for (index = 0; index < NUMUSBDUXFAST; index++) {
-		memset(&(usbduxfastsub[index]), 0x00,
-			sizeof(usbduxfastsub[index]));
+	for (index = 0; index < NUMUSBDUXFAST; index++)
 		init_MUTEX(&(usbduxfastsub[index].sem));
-	}
 }
 
 /*

commit d52a63bf6a298c4ffca6a5735926a585f3dd69e0
Author: Bernd Porr <BerndPorr@f2s.com>
Date:   Wed Mar 11 14:17:37 2009 -0700

    Staging: comedi: usbduxfast: fix run-time error
    
    If debugging is enabled, this printk will oops, fix that issue.
    
    
    From: Bernd Porr <BerndPorr@f2s.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index b1a7cbec731d..2c888d1f3afc 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -498,8 +498,7 @@ static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 	int ret;
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk(KERN_DEBUG "comedi%d: usbduxfast: uploading %d bytes",
-		udfs->comedidev->minor, len);
+	printk(KERN_DEBUG "comedi: usbduxfast: uploading %d bytes", len);
 	printk(KERN_DEBUG " to addr %d, first byte=%d.\n",
 		startAddr, local_transfer_buffer[0]);
 #endif

commit 6742c0af2ef2d8ff70e379ebf8a8541190ff44e6
Author: Bernd Porr <BerndPorr@f2s.com>
Date:   Mon Dec 8 23:30:13 2008 +0000

    Staging: comedi: usbdux[fast] firmware upload changes
    
    usbdux and usbduxfast upload now their firmware via the firmware kernel
    meachanism. No udev rules are needed for that except the default ones.
    The firmware will usually be loaded from /lib/firmware. Upload via
    comedi_config is still possible for static comedi devices
    (comedi_num_legacy_minors>0).
    
    Frank, thanks for the example code which sped up rewriting of the code
    substantially.
    
    From: Bernd Porr <BerndPorr@f2s.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 625dde7e198d..b1a7cbec731d 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -33,9 +33,12 @@
  *       1MHz/16ch=62.5kHz
  * 0.99: Ian Abbott pointed out a bug which has been corrected. Thanks!
  * 0.99a: added external trigger.
+ * 1.00: added firmware kernel request to the driver which fixed
+ *       udev coldplug problem
  */
 
 #include <linux/kernel.h>
+#include <linux/firmware.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
@@ -48,7 +51,7 @@
 #include "../comedidev.h"
 
 
-#define DRIVER_VERSION "v0.99a"
+#define DRIVER_VERSION "v1.0"
 #define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
 #define DRIVER_DESC "USB-DUXfast, BerndPorr@f2s.com"
 #define BOARDNAME "usbduxfast"
@@ -444,9 +447,6 @@ static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 	int ret;
 	unsigned char local_transfer_buffer[16];
 
-	if (!udfs->probed)
-		return 0;
-
 	/* 7f92 to zero */
 	local_transfer_buffer[0] = 0;
 	ret = usb_control_msg(udfs->usbdev,
@@ -471,9 +471,6 @@ static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 	int ret;
 	unsigned char local_transfer_buffer[16];
 
-	if (!udfs->probed)
-		return 0;
-
 	/* 7f92 to one */
 	local_transfer_buffer[0] = 1;
 	ret = usb_control_msg(udfs->usbdev,
@@ -500,10 +497,6 @@ static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 {
 	int ret;
 
-	if (!udfs->probed)
-		/* no device on the bus for this index */
-		return -EFAULT;
-
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast: uploading %d bytes",
 		udfs->comedidev->minor, len);
@@ -1396,8 +1389,8 @@ static unsigned hex2unsigned(char *h)
 /*
  * taken from David Brownell's fxload and adjusted for this driver
  */
-static int read_firmware(struct usbduxfastsub_s *udfs, void *firmwarePtr,
-	long size)
+static int read_firmware(struct usbduxfastsub_s *udfs, const void *firmwarePtr,
+			 long size)
 {
 	int i = 0;
 	unsigned char *fp = (char *)firmwarePtr;
@@ -1538,6 +1531,32 @@ static void tidy_up(struct usbduxfastsub_s *udfs)
 	udfs->ai_cmd_running = 0;
 }
 
+static void usbduxfast_firmware_request_complete_handler(const struct firmware *fw,
+							 void *context)
+{
+	struct usbduxfastsub_s *usbduxfastsub_tmp = context;
+	struct usb_device *usbdev = usbduxfastsub_tmp->usbdev;
+	int ret;
+
+	if (fw == NULL)
+		return;
+
+	/*
+	 * we need to upload the firmware here because fw will be
+	 * freed once we've left this function
+	 */
+	ret = read_firmware(usbduxfastsub_tmp, fw->data, fw->size);
+
+	if (ret) {
+		dev_err(&usbdev->dev,
+			"Could not upload firmware (err=%d)\n",
+			ret);
+		return;
+	}
+
+	comedi_usb_auto_config(usbdev, BOARDNAME);
+}
+
 /*
  * allocate memory for the urbs and initialise them
  */
@@ -1547,6 +1566,7 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 	struct usb_device *udev = interface_to_usbdev(uinterf);
 	int i;
 	int index;
+	int ret;
 
 	if (udev->speed != USB_SPEED_HIGH) {
 		printk(KERN_ERR "comedi_: usbduxfast_: This driver needs"
@@ -1644,6 +1664,20 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 	/* we've reached the bottom of the function */
 	usbduxfastsub[index].probed = 1;
 	up(&start_stop_sem);
+
+	ret = request_firmware_nowait(THIS_MODULE,
+				      FW_ACTION_HOTPLUG,
+				      "usbduxfast_firmware.hex",
+				      &udev->dev,
+				      usbduxfastsub + index,
+				      usbduxfast_firmware_request_complete_handler);
+
+	if (ret) {
+		dev_err(&udev->dev, "could not load firmware (err=%d)\n",
+			ret);
+		return ret;
+	}
+
 	printk(KERN_INFO "comedi_: usbduxfast%d has been successfully "
 	       "initialized.\n", index);
 	/* success */
@@ -1665,6 +1699,9 @@ static void usbduxfastsub_disconnect(struct usb_interface *intf)
 		       "ptr!!!\n");
 		return;
 	}
+
+	comedi_usb_auto_unconfig(udev);
+
 	down(&start_stop_sem);
 	down(&udfs->sem);
 	tidy_up(udfs);
@@ -1714,10 +1751,10 @@ static int usbduxfast_attach(comedi_device *dev, comedi_devconfig *it)
 
 	/* trying to upload the firmware into the chip */
 	if (comedi_aux_data(it->options, 0) &&
-		it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
+	    it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
 		read_firmware(&usbduxfastsub[index],
-			comedi_aux_data(it->options, 0),
-			it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
+			      comedi_aux_data(it->options, 0),
+			      it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
 	}
 
 	dev->board_name = BOARDNAME;

commit 3cd74e8693678a463b944c358cdb22f7bee533ba
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Sat Dec 6 15:43:23 2008 +0000

    Staging: comedi: usbduxfast bugfix
    
    Fixed bug in firmware loading with multiple usbduxfast boards.
    
    From: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 861d8989a491..625dde7e198d 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1715,7 +1715,7 @@ static int usbduxfast_attach(comedi_device *dev, comedi_devconfig *it)
 	/* trying to upload the firmware into the chip */
 	if (comedi_aux_data(it->options, 0) &&
 		it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
-		read_firmware(usbduxfastsub,
+		read_firmware(&usbduxfastsub[index],
 			comedi_aux_data(it->options, 0),
 			it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
 	}

commit 7dcb582cd4b0c67e0053fbb87706bd0922d79027
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Mon Feb 16 21:31:29 2009 +0100

    Staging: comedi: usbduxfast: annotate __init and __exit functions
    
    This patch adds __init and __exit annotations to proper functions in the
    usbduxfast driver.
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index c6d34703a344..861d8989a491 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1826,7 +1826,7 @@ static comedi_driver driver_usbduxfast = {
 	.detach		= usbduxfast_detach
 };
 
-static void init_usb_devices(void)
+static void __init init_usb_devices(void)
 {
 	int index;
 
@@ -1875,7 +1875,7 @@ static struct usb_driver usbduxfastsub_driver = {
  * Can't use the nice macro as I have also to initialise the USB subsystem:
  * registering the usb-system _and_ the comedi-driver
  */
-static int init_usbduxfast(void)
+static int __init init_usbduxfast(void)
 {
 	printk(KERN_INFO
 	       KBUILD_MODNAME ": " DRIVER_VERSION ":" DRIVER_DESC "\n");
@@ -1888,7 +1888,7 @@ static int init_usbduxfast(void)
 /*
  * deregistering the comedi driver and the usb-subsystem
  */
-static void exit_usbduxfast(void)
+static void __exit exit_usbduxfast(void)
 {
 	comedi_driver_unregister(&driver_usbduxfast);
 	usb_deregister(&usbduxfastsub_driver);

commit 4e8ad0dca9bbd9724ffa395b9ab425c4f22e1346
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Mon Feb 16 21:31:28 2009 +0100

    Staging: comedi: usbduxfast: fix checkpatch issues plus some style cleanups etc.
    
    This patch is a major code rewrite to make checkpatch.pl happy and also
    other minor things are fixed.
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 3439a0591e92..c6d34703a344 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1,33 +1,20 @@
-#define DRIVER_VERSION "v0.99a"
-#define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
-#define DRIVER_DESC "USB-DUXfast, BerndPorr@f2s.com"
 /*
-   comedi/drivers/usbduxfast.c
-   Copyright (C) 2004 Bernd Porr, Bernd.Porr@f2s.com
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-/*
-Driver: usbduxfast
-Description: ITL USB-DUXfast
-Devices: [ITL] USB-DUX (usbduxfast.o)
-Author: Bernd Porr <BerndPorr@f2s.com>
-Updated: 04 Dec 2006
-Status: testing
-*/
+ *  Copyright (C) 2004 Bernd Porr, Bernd.Porr@f2s.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 /*
  * I must give credit here to Chris Baugher who
@@ -42,7 +29,8 @@ Status: testing
  * 0.9: Dropping the first data packet which seems to be from the last transfer.
  *      Buffer overflows in the FX2 are handed over to comedi.
  * 0.92: Dropping now 4 packets. The quad buffer has to be emptied.
- *       Added insn command basically for testing. Sample rate is 1MHz/16ch=62.5kHz
+ *       Added insn command basically for testing. Sample rate is
+ *       1MHz/16ch=62.5kHz
  * 0.99: Ian Abbott pointed out a bug which has been corrected. Thanks!
  * 0.99a: added external trigger.
  */
@@ -59,522 +47,560 @@ Status: testing
 #include "comedi_fc.h"
 #include "../comedidev.h"
 
+
+#define DRIVER_VERSION "v0.99a"
+#define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
+#define DRIVER_DESC "USB-DUXfast, BerndPorr@f2s.com"
 #define BOARDNAME "usbduxfast"
 
-// timeout for the USB-transfer
-#define EZTIMEOUT 30
+/*
+ * timeout for the USB-transfer
+ */
+#define EZTIMEOUT	30
 
-// constants for "firmware" upload and download
-#define USBDUXFASTSUB_FIRMWARE 0xA0
-#define VENDOR_DIR_IN  0xC0
-#define VENDOR_DIR_OUT 0x40
+/*
+ * constants for "firmware" upload and download
+ */
+#define USBDUXFASTSUB_FIRMWARE	0xA0
+#define VENDOR_DIR_IN		0xC0
+#define VENDOR_DIR_OUT		0x40
 
-// internal adresses of the 8051 processor
-#define USBDUXFASTSUB_CPUCS 0xE600
+/*
+ * internal adresses of the 8051 processor
+ */
+#define USBDUXFASTSUB_CPUCS	0xE600
 
-// max lenghth of the transfer-buffer for software upload
-#define TB_LEN 0x2000
+/*
+ * max lenghth of the transfer-buffer for software upload
+ */
+#define TB_LEN	0x2000
 
-// Input endpoint number
-#define BULKINEP           6
+/*
+ * input endpoint number
+ */
+#define BULKINEP	6
 
-// Endpoint for the A/D channellist: bulk OUT
-#define CHANNELLISTEP     4
+/*
+ * endpoint for the A/D channellist: bulk OUT
+ */
+#define CHANNELLISTEP	4
 
-// Number of channels
-#define NUMCHANNELS       32
+/*
+ * number of channels
+ */
+#define NUMCHANNELS	32
 
-// size of the waveform descriptor
-#define WAVESIZE          0x20
+/*
+ * size of the waveform descriptor
+ */
+#define WAVESIZE	0x20
 
-// Size of one A/D value
-#define SIZEADIN          ((sizeof(int16_t)))
+/*
+ * size of one A/D value
+ */
+#define SIZEADIN	(sizeof(int16_t))
 
-// Size of the input-buffer IN BYTES
-#define SIZEINBUF         512
+/*
+ * size of the input-buffer IN BYTES
+ */
+#define SIZEINBUF	512
 
-// 16 bytes.
-#define SIZEINSNBUF       512
+/*
+ * 16 bytes
+ */
+#define SIZEINSNBUF	512
 
-// Size of the buffer for the dux commands
-#define SIZEOFDUXBUFFER    256	// bytes
+/*
+ * size of the buffer for the dux commands in bytes
+ */
+#define SIZEOFDUXBUFFER	256
 
-// Number of in-URBs which receive the data: min=5
-#define NUMOFINBUFFERSHIGH     10
+/*
+ * number of in-URBs which receive the data: min=5
+ */
+#define NUMOFINBUFFERSHIGH	10
 
-// Total number of usbduxfast devices
-#define NUMUSBDUXFAST             16
+/*
+ * total number of usbduxfast devices
+ */
+#define NUMUSBDUXFAST	16
 
-// Number of subdevices
-#define N_SUBDEVICES          1
+/*
+ * number of subdevices
+ */
+#define N_SUBDEVICES	1
 
-// Analogue in subdevice
-#define SUBDEV_AD             0
+/*
+ * analogue in subdevice
+ */
+#define SUBDEV_AD	0
 
-// min delay steps for more than one channel
-// basically when the mux gives up. ;-)
-#define MIN_SAMPLING_PERIOD 9	// steps at 30MHz in the FX2
+/*
+ * min delay steps for more than one channel
+ * basically when the mux gives up ;-)
+ *
+ * steps at 30MHz in the FX2
+ */
+#define MIN_SAMPLING_PERIOD	9
 
-// Max number of 1/30MHz delay steps:
-#define MAX_SAMPLING_PERIOD 500
+/*
+ * max number of 1/30MHz delay steps
+ */
+#define MAX_SAMPLING_PERIOD	500
 
-// Number of received packets to ignore before we start handing data over to comedi.
-// It's quad buffering and we have to ignore 4 packets.
-#define PACKETS_TO_IGNORE 4
+/*
+ * number of received packets to ignore before we start handing data
+ * over to comedi, it's quad buffering and we have to ignore 4 packets
+ */
+#define PACKETS_TO_IGNORE	4
 
-/////////////////////////////////////////////
-// comedi constants
-static const comedi_lrange range_usbduxfast_ai_range = { 2, {
-			BIP_RANGE(0.75),
-			BIP_RANGE(0.5),
-	}
+/*
+ * comedi constants
+ */
+static const comedi_lrange range_usbduxfast_ai_range = {
+	2, { BIP_RANGE(0.75), BIP_RANGE(0.5) }
 };
 
 /*
  * private structure of one subdevice
+ *
+ * this is the structure which holds all the data of this driver
+ * one sub device just now: A/D
  */
-
-// This is the structure which holds all the data of this driver
-// one sub device just now: A/D
-typedef struct {
-	// attached?
-	int attached;
-	// is it associated with a subdevice?
-	int probed;
-	// pointer to the usb-device
-	struct usb_device *usbdev;
-	// BULK-transfer handling: urb
-	struct urb *urbIn;
+struct usbduxfastsub_s {
+	int attached;			/* is attached? */
+	int probed;			/* is it associated with a subdevice? */
+	struct usb_device *usbdev;	/* pointer to the usb-device */
+	struct urb *urbIn;		/* BULK-transfer handling: urb */
 	int8_t *transfer_buffer;
-	// input buffer for single insn
-	int16_t *insnBuffer;
-	// interface number
-	int ifnum;
-	// interface structure
-	struct usb_interface *interface;
-	// comedi device for the interrupt context
-	comedi_device *comedidev;
-	// asynchronous command is running
-	short int ai_cmd_running;
-	// continous aquisition
-	short int ai_continous;
-	// number of samples to aquire
-	long int ai_sample_count;
-	// commands
-	uint8_t *dux_commands;
-	// counter which ignores the first buffers
-	int ignore;
+	int16_t *insnBuffer;		/* input buffer for single insn */
+	int ifnum;			/* interface number */
+	struct usb_interface *interface;	/* interface structure */
+	comedi_device *comedidev;	/* comedi device for the interrupt
+					   context */
+	short int ai_cmd_running;	/* asynchronous command is running */
+	short int ai_continous;		/* continous aquisition */
+	long int ai_sample_count;	/* number of samples to aquire */
+	uint8_t *dux_commands;		/* commands */
+	int ignore;			/* counter which ignores the first
+					   buffers */
 	struct semaphore sem;
-} usbduxfastsub_t;
+};
 
-// The pointer to the private usb-data of the driver
-// is also the private data for the comedi-device.
-// This has to be global as the usb subsystem needs
-// global variables. The other reason is that this
-// structure must be there _before_ any comedi
-// command is issued. The usb subsystem must be
-// initialised before comedi can access it.
-static usbduxfastsub_t usbduxfastsub[NUMUSBDUXFAST];
+/*
+ * The pointer to the private usb-data of the driver
+ * is also the private data for the comedi-device.
+ * This has to be global as the usb subsystem needs
+ * global variables. The other reason is that this
+ * structure must be there _before_ any comedi
+ * command is issued. The usb subsystem must be
+ * initialised before comedi can access it.
+ */
+static struct usbduxfastsub_s usbduxfastsub[NUMUSBDUXFAST];
 
 static DECLARE_MUTEX(start_stop_sem);
 
-// bulk transfers to usbduxfast
-
+/*
+ * bulk transfers to usbduxfast
+ */
 #define SENDADCOMMANDS            0
 #define SENDINITEP6               1
 
-static int send_dux_commands(usbduxfastsub_t * this_usbduxfastsub, int cmd_type)
+static int send_dux_commands(struct usbduxfastsub_s *udfs, int cmd_type)
 {
 	int tmp, nsent;
 
-	this_usbduxfastsub->dux_commands[0] = cmd_type;
+	udfs->dux_commands[0] = cmd_type;
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast: dux_commands: ",
-		this_usbduxfastsub->comedidev->minor);
+		udfs->comedidev->minor);
 	for (tmp = 0; tmp < SIZEOFDUXBUFFER; tmp++)
-		printk(" %02x", this_usbduxfastsub->dux_commands[tmp]);
+		printk(" %02x", udfs->dux_commands[tmp]);
 	printk("\n");
 #endif
 
-	tmp = usb_bulk_msg(this_usbduxfastsub->usbdev,
-			      usb_sndbulkpipe(this_usbduxfastsub->usbdev,
-					      CHANNELLISTEP),
-			      this_usbduxfastsub->dux_commands, SIZEOFDUXBUFFER,
-			      &nsent, 10000);
+	tmp = usb_bulk_msg(udfs->usbdev,
+			   usb_sndbulkpipe(udfs->usbdev, CHANNELLISTEP),
+			   udfs->dux_commands, SIZEOFDUXBUFFER, &nsent, 10000);
 	if (tmp < 0)
 		printk(KERN_ERR "comedi%d: could not transmit dux_commands to"
-		       "the usb-device, err=%d\n",
-		       this_usbduxfastsub->comedidev->minor, tmp);
-
+		      "the usb-device, err=%d\n", udfs->comedidev->minor, tmp);
 	return tmp;
 }
 
-// Stops the data acquision
-// It should be safe to call this function from any context
-static int usbduxfastsub_unlink_InURBs(usbduxfastsub_t * usbduxfastsub_tmp)
+/*
+ * Stops the data acquision.
+ * It should be safe to call this function from any context.
+ */
+static int usbduxfastsub_unlink_InURBs(struct usbduxfastsub_s *udfs)
 {
 	int j = 0;
 	int err = 0;
 
-	if (usbduxfastsub_tmp && usbduxfastsub_tmp->urbIn) {
-		usbduxfastsub_tmp->ai_cmd_running = 0;
-		// waits until a running transfer is over
-		usb_kill_urb(usbduxfastsub_tmp->urbIn);
+	if (udfs && udfs->urbIn) {
+		udfs->ai_cmd_running = 0;
+		/* waits until a running transfer is over */
+		usb_kill_urb(udfs->urbIn);
 		j = 0;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi: usbduxfast: unlinked InURB: res=%d\n", j);
+	printk(KERN_DEBUG "comedi: usbduxfast: unlinked InURB: res=%d\n", j);
 #endif
 	return err;
 }
 
-/* This will stop a running acquisition operation */
-// Is called from within this driver from both the
-// interrupt context and from comedi
-static int usbduxfast_ai_stop(usbduxfastsub_t * this_usbduxfastsub,
+/*
+ * This will stop a running acquisition operation.
+ * Is called from within this driver from both the
+ * interrupt context and from comedi.
+ */
+static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs,
 	int do_unlink)
 {
 	int ret = 0;
 
-	if (!this_usbduxfastsub) {
-		printk("comedi?: usbduxfast_ai_stop: this_usbduxfastsub=NULL!\n");
+	if (!udfs) {
+		printk(KERN_ERR "comedi?: usbduxfast_ai_stop: udfs=NULL!\n");
 		return -EFAULT;
 	}
+
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi: usbduxfast_ai_stop\n");
+	printk(KERN_DEBUG "comedi: usbduxfast_ai_stop\n");
 #endif
 
-	this_usbduxfastsub->ai_cmd_running = 0;
+	udfs->ai_cmd_running = 0;
 
-	if (do_unlink) {
-		// stop aquistion
-		ret = usbduxfastsub_unlink_InURBs(this_usbduxfastsub);
-	}
+	if (do_unlink)
+		ret = usbduxfastsub_unlink_InURBs(udfs); /* stop aquistion */
 
 	return ret;
 }
 
-// This will cancel a running acquisition operation.
-// This is called by comedi but never from inside the
-// driver.
-static int usbduxfast_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+/*
+ * This will cancel a running acquisition operation.
+ * This is called by comedi but never from inside the driver.
+ */
+static int usbduxfast_ai_cancel(comedi_device *dev, comedi_subdevice *s)
 {
-	usbduxfastsub_t *this_usbduxfastsub;
-	int res = 0;
+	struct usbduxfastsub_s *udfs;
+	int ret;
 
-	// force unlink of all urbs
+	/* force unlink of all urbs */
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi: usbduxfast_ai_cancel\n");
+	printk(KERN_DEBUG "comedi: usbduxfast_ai_cancel\n");
 #endif
-	this_usbduxfastsub = dev->private;
-	if (!this_usbduxfastsub) {
-		printk("comedi: usbduxfast_ai_cancel: this_usbduxfastsub=NULL\n");
+	udfs = dev->private;
+	if (!udfs) {
+		printk(KERN_ERR "comedi: usbduxfast_ai_cancel: udfs=NULL\n");
 		return -EFAULT;
 	}
-	down(&this_usbduxfastsub->sem);
-	if (!(this_usbduxfastsub->probed)) {
-		up(&this_usbduxfastsub->sem);
+	down(&udfs->sem);
+	if (!udfs->probed) {
+		up(&udfs->sem);
 		return -ENODEV;
 	}
-	// unlink
-	res = usbduxfast_ai_stop(this_usbduxfastsub, 1);
-	up(&this_usbduxfastsub->sem);
+	/* unlink */
+	ret = usbduxfast_ai_stop(udfs, 1);
+	up(&udfs->sem);
 
-	return res;
+	return ret;
 }
 
-// analogue IN
-// interrupt service routine
+/*
+ * analogue IN
+ * interrupt service routine
+ */
 static void usbduxfastsub_ai_Irq(struct urb *urb PT_REGS_ARG)
 {
 	int n, err;
-	usbduxfastsub_t *this_usbduxfastsub;
+	struct usbduxfastsub_s *udfs;
 	comedi_device *this_comedidev;
 	comedi_subdevice *s;
 	uint16_t *p;
 
-	// sanity checks
-	// is the urb there?
+	/* sanity checks - is the urb there? */
 	if (!urb) {
-		printk("comedi_: usbduxfast_: ao int-handler called with urb=NULL!\n");
+		printk(KERN_ERR "comedi_: usbduxfast_: ao int-handler called "
+		       "with urb=NULL!\n");
 		return;
 	}
-	// the context variable points to the subdevice
+	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
 	if (!this_comedidev) {
-		printk("comedi_: usbduxfast_: urb context is a NULL pointer!\n");
+		printk(KERN_ERR "comedi_: usbduxfast_: urb context is a NULL "
+		       "pointer!\n");
 		return;
 	}
-	// the private structure of the subdevice is usbduxfastsub_t
-	this_usbduxfastsub = this_comedidev->private;
-	if (!this_usbduxfastsub) {
-		printk("comedi_: usbduxfast_: private of comedi subdev is a NULL pointer!\n");
+	/* the private structure of the subdevice is usbduxfastsub_s */
+	udfs = this_comedidev->private;
+	if (!udfs) {
+		printk(KERN_ERR "comedi_: usbduxfast_: private of comedi "
+		       "subdev is a NULL pointer!\n");
 		return;
 	}
-	// are we running a command?
-	if (unlikely(!(this_usbduxfastsub->ai_cmd_running))) {
-		// not running a command
-		// do not continue execution if no asynchronous command is running
-		// in particular not resubmit
+	/* are we running a command? */
+	if (unlikely(!udfs->ai_cmd_running)) {
+		/*
+		 * not running a command
+		 * do not continue execution if no asynchronous command
+		 * is running in particular not resubmit
+		 */
 		return;
 	}
 
-	if (unlikely(!(this_usbduxfastsub->attached))) {
-		// no comedi device there
+	if (unlikely(!udfs->attached)) {
+		/* no comedi device there */
 		return;
 	}
-	// subdevice which is the AD converter
+	/* subdevice which is the AD converter */
 	s = this_comedidev->subdevices + SUBDEV_AD;
 
-	// first we test if something unusual has just happened
+	/* first we test if something unusual has just happened */
 	switch (urb->status) {
 	case 0:
 		break;
 
-		// happens after an unlink command or when the device is plugged out
+		/*
+		 * happens after an unlink command or when the device
+		 * is plugged out
+		 */
 	case -ECONNRESET:
 	case -ENOENT:
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
-		// tell this comedi
+		/* tell this comedi */
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(this_usbduxfastsub->comedidev, s);
-		// stop the transfer w/o unlink
-		usbduxfast_ai_stop(this_usbduxfastsub, 0);
+		comedi_event(udfs->comedidev, s);
+		/* stop the transfer w/o unlink */
+		usbduxfast_ai_stop(udfs, 0);
 		return;
 
 	default:
-		printk("comedi%d: usbduxfast: non-zero urb status received in ai intr context: %d\n", this_usbduxfastsub->comedidev->minor, urb->status);
+		printk("comedi%d: usbduxfast: non-zero urb status received in "
+		       "ai intr context: %d\n",
+		       udfs->comedidev->minor, urb->status);
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(this_usbduxfastsub->comedidev, s);
-		usbduxfast_ai_stop(this_usbduxfastsub, 0);
+		comedi_event(udfs->comedidev, s);
+		usbduxfast_ai_stop(udfs, 0);
 		return;
 	}
 
 	p = urb->transfer_buffer;
-	if (!this_usbduxfastsub->ignore) {
-		if (!(this_usbduxfastsub->ai_continous)) {
-			// not continous, fixed number of samples
+	if (!udfs->ignore) {
+		if (!udfs->ai_continous) {
+			/* not continous, fixed number of samples */
 			n = urb->actual_length / sizeof(uint16_t);
-			if (unlikely(this_usbduxfastsub->ai_sample_count < n)) {
-				// we have send only a fraction of the bytes received
+			if (unlikely(udfs->ai_sample_count < n)) {
+				/*
+				 * we have send only a fraction of the bytes
+				 * received
+				 */
 				cfc_write_array_to_buffer(s,
 					urb->transfer_buffer,
-					this_usbduxfastsub->ai_sample_count *
-					sizeof(uint16_t));
-				usbduxfast_ai_stop(this_usbduxfastsub, 0);
-				// say comedi that the acquistion is over
+					udfs->ai_sample_count
+					* sizeof(uint16_t));
+				usbduxfast_ai_stop(udfs, 0);
+				/* say comedi that the acquistion is over */
 				s->async->events |= COMEDI_CB_EOA;
-				comedi_event(this_usbduxfastsub->comedidev, s);
+				comedi_event(udfs->comedidev, s);
 				return;
 			}
-			this_usbduxfastsub->ai_sample_count -= n;
+			udfs->ai_sample_count -= n;
 		}
-		// write the full buffer to comedi
-		cfc_write_array_to_buffer(s,
-			urb->transfer_buffer, urb->actual_length);
+		/* write the full buffer to comedi */
+		cfc_write_array_to_buffer(s, urb->transfer_buffer,
+					  urb->actual_length);
 
-		// tell comedi that data is there
-		comedi_event(this_usbduxfastsub->comedidev, s);
+		/* tell comedi that data is there */
+		comedi_event(udfs->comedidev, s);
 
 	} else {
-		// ignore this packet
-		this_usbduxfastsub->ignore--;
+		/* ignore this packet */
+		udfs->ignore--;
 	}
 
-	// command is still running
-	// resubmit urb for BULK transfer
-	urb->dev = this_usbduxfastsub->usbdev;
+	/*
+	 * command is still running
+	 * resubmit urb for BULK transfer
+	 */
+	urb->dev = udfs->usbdev;
 	urb->status = 0;
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		printk("comedi%d: usbduxfast: urb resubm failed: %d",
-			this_usbduxfastsub->comedidev->minor, err);
+		printk(KERN_ERR "comedi%d: usbduxfast: urb resubm failed: %d",
+			udfs->comedidev->minor, err);
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(this_usbduxfastsub->comedidev, s);
-		usbduxfast_ai_stop(this_usbduxfastsub, 0);
+		comedi_event(udfs->comedidev, s);
+		usbduxfast_ai_stop(udfs, 0);
 	}
 }
 
-static int usbduxfastsub_start(usbduxfastsub_t * usbduxfastsub)
+static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 {
-	int errcode = 0;
+	int ret;
 	unsigned char local_transfer_buffer[16];
 
-	if (usbduxfastsub->probed) {
-		// 7f92 to zero
-		local_transfer_buffer[0] = 0;
-		errcode = usb_control_msg(usbduxfastsub->usbdev,
-			// create a pipe for a control transfer
-			usb_sndctrlpipe(usbduxfastsub->usbdev, 0),
-			// bRequest, "Firmware"
-			USBDUXFASTSUB_FIRMWARE,
-			// bmRequestType
-			VENDOR_DIR_OUT,
-			// Value
-			USBDUXFASTSUB_CPUCS,
-			// Index
-			0x0000,
-			// address of the transfer buffer
-			local_transfer_buffer,
-			// Length
-			1,
-			// Timeout
-			EZTIMEOUT);
-		if (errcode < 0) {
-			printk("comedi_: usbduxfast_: control msg failed (start)\n");
-			return errcode;
-		}
+	if (!udfs->probed)
+		return 0;
+
+	/* 7f92 to zero */
+	local_transfer_buffer[0] = 0;
+	ret = usb_control_msg(udfs->usbdev,
+		usb_sndctrlpipe(udfs->usbdev, 0),
+		USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
+		VENDOR_DIR_OUT,		/* bmRequestType */
+		USBDUXFASTSUB_CPUCS,	/* Value */
+		0x0000,			/* Index */
+		local_transfer_buffer,	/* address of the transfer buffer */
+		1,			/* Length */
+		EZTIMEOUT);		/* Timeout */
+	if (ret < 0) {
+		printk("comedi_: usbduxfast_: control msg failed (start)\n");
+		return ret;
 	}
+
 	return 0;
 }
 
-static int usbduxfastsub_stop(usbduxfastsub_t * usbduxfastsub)
+static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 {
-	int errcode = 0;
-
+	int ret;
 	unsigned char local_transfer_buffer[16];
-	if (usbduxfastsub->probed) {
-		// 7f92 to one
-		local_transfer_buffer[0] = 1;
-		errcode = usb_control_msg(usbduxfastsub->usbdev,
-			usb_sndctrlpipe(usbduxfastsub->usbdev, 0),
-			// bRequest, "Firmware"
-			USBDUXFASTSUB_FIRMWARE,
-			// bmRequestType
-			VENDOR_DIR_OUT,
-			// Value
-			USBDUXFASTSUB_CPUCS,
-			// Index
-			0x0000, local_transfer_buffer,
-			// Length
-			1,
-			// Timeout
-			EZTIMEOUT);
-		if (errcode < 0) {
-			printk("comedi_: usbduxfast: control msg failed (stop)\n");
-			return errcode;
-		}
+
+	if (!udfs->probed)
+		return 0;
+
+	/* 7f92 to one */
+	local_transfer_buffer[0] = 1;
+	ret = usb_control_msg(udfs->usbdev,
+		usb_sndctrlpipe(udfs->usbdev, 0),
+		USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
+		VENDOR_DIR_OUT,		/* bmRequestType */
+		USBDUXFASTSUB_CPUCS,	/* Value */
+		0x0000,			/* Index */
+		local_transfer_buffer,
+		1,			/* Length */
+		EZTIMEOUT);		/* Timeout */
+	if (ret < 0) {
+		printk(KERN_ERR "comedi_: usbduxfast: control msg failed "
+		       "(stop)\n");
+		return ret;
 	}
+
 	return 0;
 }
 
-static int usbduxfastsub_upload(usbduxfastsub_t * usbduxfastsub,
+static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 	unsigned char *local_transfer_buffer,
 	unsigned int startAddr, unsigned int len)
 {
-	int errcode;
+	int ret;
+
+	if (!udfs->probed)
+		/* no device on the bus for this index */
+		return -EFAULT;
 
-	if (usbduxfastsub->probed) {
 #ifdef CONFIG_COMEDI_DEBUG
-		printk("comedi%d: usbduxfast: uploading %d bytes",
-			usbduxfastsub->comedidev->minor, len);
-		printk(" to addr %d, first byte=%d.\n",
-			startAddr, local_transfer_buffer[0]);
+	printk(KERN_DEBUG "comedi%d: usbduxfast: uploading %d bytes",
+		udfs->comedidev->minor, len);
+	printk(KERN_DEBUG " to addr %d, first byte=%d.\n",
+		startAddr, local_transfer_buffer[0]);
 #endif
-		errcode = usb_control_msg(usbduxfastsub->usbdev,
-			usb_sndctrlpipe(usbduxfastsub->usbdev, 0),
-			// brequest, firmware
-			USBDUXFASTSUB_FIRMWARE,
-			// bmRequestType
-			VENDOR_DIR_OUT,
-			// value
-			startAddr,
-			// index
-			0x0000,
-			// our local safe buffer
-			local_transfer_buffer,
-			// length
-			len,
-			// timeout
-			EZTIMEOUT);
+	ret = usb_control_msg(udfs->usbdev,
+		usb_sndctrlpipe(udfs->usbdev, 0),
+		USBDUXFASTSUB_FIRMWARE, /* brequest, firmware */
+		VENDOR_DIR_OUT,		/* bmRequestType */
+		startAddr,		/* value */
+		0x0000,			/* index */
+		local_transfer_buffer,	/* our local safe buffer */
+		len,			/* length */
+		EZTIMEOUT);		/* timeout */
+
 #ifdef CONFIG_COMEDI_DEBUG
-		printk("comedi_: usbduxfast: result=%d\n", errcode);
+	printk(KERN_DEBUG "comedi_: usbduxfast: result=%d\n", ret);
 #endif
-		if (errcode < 0) {
-			printk("comedi_: usbduxfast: uppload failed\n");
-			return errcode;
-		}
-	} else {
-		// no device on the bus for this index
-		return -EFAULT;
+
+	if (ret < 0) {
+		printk(KERN_ERR "comedi_: usbduxfast: uppload failed\n");
+		return ret;
 	}
+
 	return 0;
 }
 
-int firmwareUpload(usbduxfastsub_t * usbduxfastsub,
-	unsigned char *firmwareBinary, int sizeFirmware)
+int firmwareUpload(struct usbduxfastsub_s *udfs, unsigned char *firmwareBinary,
+		   int sizeFirmware)
 {
 	int ret;
 
-	if (!firmwareBinary) {
+	if (!firmwareBinary)
 		return 0;
-	}
-	ret = usbduxfastsub_stop(usbduxfastsub);
+
+	ret = usbduxfastsub_stop(udfs);
 	if (ret < 0) {
-		printk("comedi_: usbduxfast: can not stop firmware\n");
+		printk(KERN_ERR "comedi_: usbduxfast: can not stop firmware\n");
 		return ret;
 	}
-	ret = usbduxfastsub_upload(usbduxfastsub,
-		firmwareBinary, 0, sizeFirmware);
+	ret = usbduxfastsub_upload(udfs, firmwareBinary, 0, sizeFirmware);
 	if (ret < 0) {
-		printk("comedi_: usbduxfast: firmware upload failed\n");
+		printk(KERN_ERR "comedi_: usbduxfast: firmware upload failed\n");
 		return ret;
 	}
-	ret = usbduxfastsub_start(usbduxfastsub);
+	ret = usbduxfastsub_start(udfs);
 	if (ret < 0) {
-		printk("comedi_: usbduxfast: can not start firmware\n");
+		printk(KERN_ERR "comedi_: usbduxfast: can not start firmware\n");
 		return ret;
 	}
+
 	return 0;
 }
 
-int usbduxfastsub_submit_InURBs(usbduxfastsub_t * usbduxfastsub)
+int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
 {
-	int errFlag;
+	int ret;
 
-	if (!usbduxfastsub) {
+	if (!udfs)
 		return -EFAULT;
-	}
-	usb_fill_bulk_urb(usbduxfastsub->urbIn,
-		usbduxfastsub->usbdev,
-		usb_rcvbulkpipe(usbduxfastsub->usbdev, BULKINEP),
-		usbduxfastsub->transfer_buffer,
-		SIZEINBUF, usbduxfastsub_ai_Irq, usbduxfastsub->comedidev);
+
+	usb_fill_bulk_urb(udfs->urbIn, udfs->usbdev,
+			  usb_rcvbulkpipe(udfs->usbdev, BULKINEP),
+			  udfs->transfer_buffer,
+			  SIZEINBUF, usbduxfastsub_ai_Irq, udfs->comedidev);
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: submitting in-urb: 0x%p,0x%p\n",
-		usbduxfastsub->comedidev->minor,
-		usbduxfastsub->urbIn->context,
-		usbduxfastsub->urbIn->dev);
+	printk(KERN_DEBUG "comedi%d: usbduxfast: submitting in-urb: "
+	       "0x%p,0x%p\n", udfs->comedidev->minor, udfs->urbIn->context,
+		udfs->urbIn->dev);
 #endif
-	errFlag = usb_submit_urb(usbduxfastsub->urbIn, GFP_ATOMIC);
-	if (errFlag) {
-		printk("comedi_: usbduxfast: ai: usb_submit_urb error %d\n",
-			errFlag);
-		return errFlag;
+	ret = usb_submit_urb(udfs->urbIn, GFP_ATOMIC);
+	if (ret) {
+		printk(KERN_ERR "comedi_: usbduxfast: ai: usb_submit_urb error"
+		       " %d\n", ret);
+		return ret;
 	}
 	return 0;
 }
 
-static int usbduxfast_ai_cmdtest(comedi_device * dev,
-	comedi_subdevice * s, comedi_cmd * cmd)
+static int usbduxfast_ai_cmdtest(comedi_device *dev,
+	comedi_subdevice *s, comedi_cmd *cmd)
 {
 	int err = 0, stop_mask = 0;
-	long int steps, tmp = 0;
+	long int steps, tmp;
 	int minSamplPer;
-	usbduxfastsub_t *this_usbduxfastsub = dev->private;
-	if (!(this_usbduxfastsub->probed)) {
+	struct usbduxfastsub_s *udfs = dev->private;
+
+	if (!udfs->probed)
 		return -ENODEV;
-	}
+
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast_ai_cmdtest\n", dev->minor);
-	printk("comedi%d: usbduxfast: convert_arg=%u scan_begin_arg=%u\n",
-		dev->minor, cmd->convert_arg, cmd->scan_begin_arg);
+	printk(KERN_DEBUG "comedi%d: usbduxfast_ai_cmdtest\n", dev->minor);
+	printk(KERN_DEBUG "comedi%d: usbduxfast: convert_arg=%u "
+	       "scan_begin_arg=%u\n",
+	       dev->minor, cmd->convert_arg, cmd->scan_begin_arg);
 #endif
 	/* step 1: make sure trigger sources are trivially valid */
 
@@ -607,7 +633,9 @@ static int usbduxfast_ai_cmdtest(comedi_device * dev,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/*
+	 * step 2: make sure trigger sources are unique and mutually compatible
+	 */
 
 	if (cmd->start_src != TRIG_NOW &&
 		cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_INT)
@@ -622,7 +650,7 @@ static int usbduxfast_ai_cmdtest(comedi_device * dev,
 		cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
 		err++;
 
-	// can't have external stop and start triggers at once
+	/* can't have external stop and start triggers at once */
 	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)
 		err++;
 
@@ -636,29 +664,28 @@ static int usbduxfast_ai_cmdtest(comedi_device * dev,
 		err++;
 	}
 
-	if (!cmd->chanlist_len) {
+	if (!cmd->chanlist_len)
 		err++;
-	}
+
 	if (cmd->scan_end_arg != cmd->chanlist_len) {
 		cmd->scan_end_arg = cmd->chanlist_len;
 		err++;
 	}
 
-	if (cmd->chanlist_len == 1) {
+	if (cmd->chanlist_len == 1)
 		minSamplPer = 1;
-	} else {
+	else
 		minSamplPer = MIN_SAMPLING_PERIOD;
-	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		steps = cmd->convert_arg * 30;
-		if (steps < (minSamplPer * 1000)) {
+		if (steps < (minSamplPer * 1000))
 			steps = minSamplPer * 1000;
-		}
-		if (steps > (MAX_SAMPLING_PERIOD * 1000)) {
+
+		if (steps > (MAX_SAMPLING_PERIOD * 1000))
 			steps = MAX_SAMPLING_PERIOD * 1000;
-		}
-		// calc arg again
+
+		/* calc arg again */
 		tmp = steps / 30;
 		if (cmd->convert_arg != tmp) {
 			cmd->convert_arg = tmp;
@@ -666,10 +693,10 @@ static int usbduxfast_ai_cmdtest(comedi_device * dev,
 		}
 	}
 
-	if (cmd->scan_begin_src == TRIG_TIMER) {
+	if (cmd->scan_begin_src == TRIG_TIMER)
 		err++;
-	}
-	// stop source
+
+	/* stop source */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
 		if (!cmd->stop_arg) {
@@ -683,7 +710,10 @@ static int usbduxfast_ai_cmdtest(comedi_device * dev,
 			err++;
 		}
 		break;
-		// TRIG_EXT doesn't care since it doesn't trigger off a numbered channel
+		/*
+		 * TRIG_EXT doesn't care since it doesn't trigger
+		 * off a numbered channel
+		 */
 	default:
 		break;
 	}
@@ -697,588 +727,676 @@ static int usbduxfast_ai_cmdtest(comedi_device * dev,
 
 }
 
-static int usbduxfast_ai_inttrig(comedi_device * dev,
-	comedi_subdevice * s, unsigned int trignum)
+static int usbduxfast_ai_inttrig(comedi_device *dev,
+	comedi_subdevice *s, unsigned int trignum)
 {
 	int ret;
-	usbduxfastsub_t *this_usbduxfastsub = dev->private;
-	if (!this_usbduxfastsub) {
+	struct usbduxfastsub_s *udfs = dev->private;
+
+	if (!udfs)
 		return -EFAULT;
-	}
-	down(&this_usbduxfastsub->sem);
-	if (!(this_usbduxfastsub->probed)) {
-		up(&this_usbduxfastsub->sem);
+
+	down(&udfs->sem);
+	if (!udfs->probed) {
+		up(&udfs->sem);
 		return -ENODEV;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast_ai_inttrig\n", dev->minor);
+	printk(KERN_DEBUG "comedi%d: usbduxfast_ai_inttrig\n", dev->minor);
 #endif
 
 	if (trignum != 0) {
-		printk("comedi%d: usbduxfast_ai_inttrig: invalid trignum\n",
-			dev->minor);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: usbduxfast_ai_inttrig: invalid"
+		       " trignum\n", dev->minor);
+		up(&udfs->sem);
 		return -EINVAL;
 	}
-	if (!(this_usbduxfastsub->ai_cmd_running)) {
-		this_usbduxfastsub->ai_cmd_running = 1;
-		ret = usbduxfastsub_submit_InURBs(this_usbduxfastsub);
+	if (!udfs->ai_cmd_running) {
+		udfs->ai_cmd_running = 1;
+		ret = usbduxfastsub_submit_InURBs(udfs);
 		if (ret < 0) {
-			printk("comedi%d: usbduxfast_ai_inttrig: urbSubmit: err=%d\n", dev->minor, ret);
-			this_usbduxfastsub->ai_cmd_running = 0;
-			up(&this_usbduxfastsub->sem);
+			printk(KERN_ERR "comedi%d: usbduxfast_ai_inttrig: "
+			       "urbSubmit: err=%d\n", dev->minor, ret);
+			udfs->ai_cmd_running = 0;
+			up(&udfs->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	} else {
-		printk("comedi%d: ai_inttrig but acqu is already running\n",
-			dev->minor);
+		printk(KERN_ERR "comedi%d: ai_inttrig but acqu is already"
+		       " running\n", dev->minor);
 	}
-	up(&this_usbduxfastsub->sem);
+	up(&udfs->sem);
 	return 1;
 }
 
-// offsets for the GPIF bytes
-// the first byte is the command byte
-#define LENBASE 1+0x00
-#define OPBASE  1+0x08
-#define OUTBASE 1+0x10
-#define LOGBASE 1+0x18
+/*
+ * offsets for the GPIF bytes
+ * the first byte is the command byte
+ */
+#define LENBASE	(1+0x00)
+#define OPBASE	(1+0x08)
+#define OUTBASE	(1+0x10)
+#define LOGBASE	(1+0x18)
 
-static int usbduxfast_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int usbduxfast_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain, rngmask = 0xff;
 	int i, j, ret;
-	usbduxfastsub_t *this_usbduxfastsub = dev->private;
+	struct usbduxfastsub_s *udfs;
 	int result;
 	long steps, steps_tmp;
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast_ai_cmd\n", dev->minor);
+	printk(KERN_DEBUG "comedi%d: usbduxfast_ai_cmd\n", dev->minor);
 #endif
-	if (!this_usbduxfastsub) {
+	udfs = dev->private;
+	if (!udfs)
 		return -EFAULT;
-	}
-	down(&this_usbduxfastsub->sem);
-	if (!(this_usbduxfastsub->probed)) {
-		up(&this_usbduxfastsub->sem);
+
+	down(&udfs->sem);
+	if (!udfs->probed) {
+		up(&udfs->sem);
 		return -ENODEV;
 	}
-	if (this_usbduxfastsub->ai_cmd_running) {
-		printk("comedi%d: ai_cmd not possible. Another ai_cmd is running.\n", dev->minor);
-		up(&this_usbduxfastsub->sem);
+	if (udfs->ai_cmd_running) {
+		printk(KERN_ERR "comedi%d: ai_cmd not possible. Another ai_cmd"
+		       " is running.\n", dev->minor);
+		up(&udfs->sem);
 		return -EBUSY;
 	}
-	// set current channel of the running aquisition to zero
+	/* set current channel of the running aquisition to zero */
 	s->async->cur_chan = 0;
 
-	// ignore the first buffers from the device if there is an error condition
-	this_usbduxfastsub->ignore = PACKETS_TO_IGNORE;
+	/*
+	 * ignore the first buffers from the device if there
+	 * is an error condition
+	 */
+	udfs->ignore = PACKETS_TO_IGNORE;
 
 	if (cmd->chanlist_len > 0) {
 		gain = CR_RANGE(cmd->chanlist[0]);
 		for (i = 0; i < cmd->chanlist_len; ++i) {
 			chan = CR_CHAN(cmd->chanlist[i]);
 			if (chan != i) {
-				printk("comedi%d: cmd is accepting only consecutive channels.\n", dev->minor);
-				up(&this_usbduxfastsub->sem);
+				printk(KERN_ERR "comedi%d: cmd is accepting "
+				       "only consecutive channels.\n",
+				       dev->minor);
+				up(&udfs->sem);
 				return -EINVAL;
 			}
 			if ((gain != CR_RANGE(cmd->chanlist[i]))
 				&& (cmd->chanlist_len > 3)) {
-				printk("comedi%d: the gain must be the same for all channels.\n", dev->minor);
-				up(&this_usbduxfastsub->sem);
+				printk(KERN_ERR "comedi%d: the gain must be"
+				       " the same for all channels.\n",
+				       dev->minor);
+				up(&udfs->sem);
 				return -EINVAL;
 			}
 			if (i >= NUMCHANNELS) {
-				printk("comedi%d: channel list too long\n",
-					dev->minor);
+				printk(KERN_ERR "comedi%d: channel list too"
+				       " long\n", dev->minor);
 				break;
 			}
 		}
 	}
 	steps = 0;
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		printk("comedi%d: usbduxfast: scan_begin_src==TRIG_TIMER not valid.\n", dev->minor);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: usbduxfast: "
+		       "scan_begin_src==TRIG_TIMER not valid.\n", dev->minor);
+		up(&udfs->sem);
 		return -EINVAL;
 	}
-	if (cmd->convert_src == TRIG_TIMER) {
+	if (cmd->convert_src == TRIG_TIMER)
 		steps = (cmd->convert_arg * 30) / 1000;
-	}
+
 	if ((steps < MIN_SAMPLING_PERIOD) && (cmd->chanlist_len != 1)) {
-		printk("comedi%d: usbduxfast: ai_cmd: steps=%ld, scan_begin_arg=%d. Not properly tested by cmdtest?\n", dev->minor, steps, cmd->scan_begin_arg);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: steps=%ld, "
+		       "scan_begin_arg=%d. Not properly tested by cmdtest?\n",
+		       dev->minor, steps, cmd->scan_begin_arg);
+		up(&udfs->sem);
 		return -EINVAL;
 	}
 	if (steps > MAX_SAMPLING_PERIOD) {
-		printk("comedi%d: usbduxfast: ai_cmd: sampling rate too low.\n",
-			dev->minor);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: sampling rate "
+		       "too low.\n", dev->minor);
+		up(&udfs->sem);
 		return -EINVAL;
 	}
 	if ((cmd->start_src == TRIG_EXT) && (cmd->chanlist_len != 1)
 		&& (cmd->chanlist_len != 16)) {
-		printk("comedi%d: usbduxfast: ai_cmd: TRIG_EXT only with 1 or 16 channels possible.\n", dev->minor);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: TRIG_EXT only"
+		       " with 1 or 16 channels possible.\n", dev->minor);
+		up(&udfs->sem);
 		return -EINVAL;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: steps=%ld, convert_arg=%u\n",
-		dev->minor, steps, cmd->convert_arg);
+	printk(KERN_DEBUG "comedi%d: usbduxfast: steps=%ld, convert_arg=%u\n",
+	       dev->minor, steps, cmd->convert_arg);
 #endif
 
 	switch (cmd->chanlist_len) {
-		// one channel
 	case 1:
+		/*
+		 * one channel
+		 */
+
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
 		else
 			rngmask = 0xff;
 
-		// for external trigger: looping in this state until the RDY0 pin
-		// becomes zero
-		if (cmd->start_src == TRIG_EXT) {	// we loop here until ready has been set
-			this_usbduxfastsub->dux_commands[LENBASE + 0] = 0x01;	// branch back to state 0
-			this_usbduxfastsub->dux_commands[OPBASE + 0] = 0x01;	// deceision state w/o data
-			this_usbduxfastsub->dux_commands[OUTBASE + 0] =
-				0xFF & rngmask;
-			this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0x00;	// RDY0 = 0
-		} else {	// we just proceed to state 1
-			this_usbduxfastsub->dux_commands[LENBASE + 0] = 1;
-			this_usbduxfastsub->dux_commands[OPBASE + 0] = 0;
-			this_usbduxfastsub->dux_commands[OUTBASE + 0] =
-				0xFF & rngmask;
-			this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
+		/*
+		 * for external trigger: looping in this state until
+		 * the RDY0 pin becomes zero
+		 */
+
+		/* we loop here until ready has been set */
+		if (cmd->start_src == TRIG_EXT) {
+			/* branch back to state 0 */
+			udfs->dux_commands[LENBASE+0] = 0x01;
+			/* deceision state w/o data */
+			udfs->dux_commands[OPBASE+0] = 0x01;
+			udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
+			/* RDY0 = 0 */
+			udfs->dux_commands[LOGBASE+0] = 0x00;
+		} else {	/* we just proceed to state 1 */
+			udfs->dux_commands[LENBASE+0] = 1;
+			udfs->dux_commands[OPBASE+0] = 0;
+			udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE+0] = 0;
 		}
 
 		if (steps < MIN_SAMPLING_PERIOD) {
-			// for fast single channel aqu without mux
+			/* for fast single channel aqu without mux */
 			if (steps <= 1) {
-				// we just stay here at state 1 and rexecute the same state
-				// this gives us 30MHz sampling rate
-				this_usbduxfastsub->dux_commands[LENBASE + 1] = 0x89;	// branch back to state 1
-				this_usbduxfastsub->dux_commands[OPBASE + 1] = 0x03;	// deceision state with data
-				this_usbduxfastsub->dux_commands[OUTBASE + 1] =
-					0xFF & rngmask;
-				this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0xFF;	// doesn't matter
+				/*
+				 * we just stay here at state 1 and rexecute
+				 * the same state this gives us 30MHz sampling
+				 * rate
+				 */
+
+				/* branch back to state 1 */
+				udfs->dux_commands[LENBASE+1] = 0x89;
+				/* deceision state with data */
+				udfs->dux_commands[OPBASE+1] = 0x03;
+				udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
+				/* doesn't matter */
+				udfs->dux_commands[LOGBASE+1] = 0xFF;
 			} else {
-				// we loop through two states: data and delay: max rate is 15Mhz
-				this_usbduxfastsub->dux_commands[LENBASE + 1] =
-					steps - 1;
-				this_usbduxfastsub->dux_commands[OPBASE + 1] = 0x02;	// data
-				this_usbduxfastsub->dux_commands[OUTBASE + 1] =
-					0xFF & rngmask;
-				this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0;	// doesn't matter
-
-				this_usbduxfastsub->dux_commands[LENBASE + 2] = 0x09;	// branch back to state 1
-				this_usbduxfastsub->dux_commands[OPBASE + 2] = 0x01;	// deceision state w/o data
-				this_usbduxfastsub->dux_commands[OUTBASE + 2] =
-					0xFF & rngmask;
-				this_usbduxfastsub->dux_commands[LOGBASE + 2] = 0xFF;	// doesn't matter
+				/*
+				 * we loop through two states: data and delay
+				 * max rate is 15MHz
+				 */
+				udfs->dux_commands[LENBASE+1] = steps - 1;
+				/* data */
+				udfs->dux_commands[OPBASE+1] = 0x02;
+				udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
+				/* doesn't matter */
+				udfs->dux_commands[LOGBASE+1] = 0;
+				/* branch back to state 1 */
+				udfs->dux_commands[LENBASE+2] = 0x09;
+				/* deceision state w/o data */
+				udfs->dux_commands[OPBASE+2] = 0x01;
+				udfs->dux_commands[OUTBASE+2] = 0xFF & rngmask;
+				/* doesn't matter */
+				udfs->dux_commands[LOGBASE+2] = 0xFF;
 			}
 		} else {
-			// we loop through 3 states: 2x delay and 1x data. This gives a min
-			// sampling rate of 60kHz.
+			/*
+			 * we loop through 3 states: 2x delay and 1x data
+			 * this gives a min sampling rate of 60kHz
+			 */
 
-			// we have 1 state with duration 1
+			/* we have 1 state with duration 1 */
 			steps = steps - 1;
 
-			// do the first part of the delay
-			this_usbduxfastsub->dux_commands[LENBASE + 1] =
-				steps / 2;
-			this_usbduxfastsub->dux_commands[OPBASE + 1] = 0;
-			this_usbduxfastsub->dux_commands[OUTBASE + 1] =
-				0xFF & rngmask;
-			this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0;
-
-			// and the second part
-			this_usbduxfastsub->dux_commands[LENBASE + 2] =
-				steps - steps / 2;
-			this_usbduxfastsub->dux_commands[OPBASE + 2] = 0;
-			this_usbduxfastsub->dux_commands[OUTBASE + 2] =
-				0xFF & rngmask;
-			this_usbduxfastsub->dux_commands[LOGBASE + 2] = 0;
-
-			// get the data and branch back
-			this_usbduxfastsub->dux_commands[LENBASE + 3] = 0x09;	// branch back to state 1
-			this_usbduxfastsub->dux_commands[OPBASE + 3] = 0x03;	// deceision state w data
-			this_usbduxfastsub->dux_commands[OUTBASE + 3] =
-				0xFF & rngmask;
-			this_usbduxfastsub->dux_commands[LOGBASE + 3] = 0xFF;	// doesn't matter
+			/* do the first part of the delay */
+			udfs->dux_commands[LENBASE+1] = steps / 2;
+			udfs->dux_commands[OPBASE+1] = 0;
+			udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE+1] = 0;
+
+			/* and the second part */
+			udfs->dux_commands[LENBASE+2] = steps - steps / 2;
+			udfs->dux_commands[OPBASE+2] = 0;
+			udfs->dux_commands[OUTBASE+2] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE+2] = 0;
+
+			/* get the data and branch back */
+
+			/* branch back to state 1 */
+			udfs->dux_commands[LENBASE+3] = 0x09;
+			/* deceision state w data */
+			udfs->dux_commands[OPBASE+3] = 0x03;
+			udfs->dux_commands[OUTBASE+3] = 0xFF & rngmask;
+			/* doesn't matter */
+			udfs->dux_commands[LOGBASE+3] = 0xFF;
 		}
 		break;
 
 	case 2:
-		// two channels
-		// commit data to the FIFO
+		/*
+		 * two channels
+		 * commit data to the FIFO
+		 */
+
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
 		else
 			rngmask = 0xff;
-		this_usbduxfastsub->dux_commands[LENBASE + 0] = 1;
-		this_usbduxfastsub->dux_commands[OPBASE + 0] = 0x02;	// data
-		this_usbduxfastsub->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
 
-		// we have 1 state with duration 1: state 0
+		udfs->dux_commands[LENBASE+0] = 1;
+		/* data */
+		udfs->dux_commands[OPBASE+0] = 0x02;
+		udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+0] = 0;
+
+		/* we have 1 state with duration 1: state 0 */
 		steps_tmp = steps - 1;
 
 		if (CR_RANGE(cmd->chanlist[1]) > 0)
 			rngmask = 0xff - 0x04;
 		else
 			rngmask = 0xff;
-		// do the first part of the delay
-		this_usbduxfastsub->dux_commands[LENBASE + 1] = steps_tmp / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 1] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 1] = 0xFE & rngmask;	//count
-		this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0;
-
-		// and the second part
-		this_usbduxfastsub->dux_commands[LENBASE + 2] =
-			steps_tmp - steps_tmp / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 2] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 2] = 0;
-
-		this_usbduxfastsub->dux_commands[LENBASE + 3] = 1;
-		this_usbduxfastsub->dux_commands[OPBASE + 3] = 0x02;	// data
-		this_usbduxfastsub->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 3] = 0;
-
-		// we have 2 states with duration 1: step 6 and the IDLE state
+
+		/* do the first part of the delay */
+		udfs->dux_commands[LENBASE+1] = steps_tmp / 2;
+		udfs->dux_commands[OPBASE+1] = 0;
+		/* count */
+		udfs->dux_commands[OUTBASE+1] = 0xFE & rngmask;
+		udfs->dux_commands[LOGBASE+1] = 0;
+
+		/* and the second part */
+		udfs->dux_commands[LENBASE+2] = steps_tmp - steps_tmp / 2;
+		udfs->dux_commands[OPBASE+2] = 0;
+		udfs->dux_commands[OUTBASE+2] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+2] = 0;
+
+		udfs->dux_commands[LENBASE+3] = 1;
+		/* data */
+		udfs->dux_commands[OPBASE+3] = 0x02;
+		udfs->dux_commands[OUTBASE+3] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+3] = 0;
+
+		/*
+		 * we have 2 states with duration 1: step 6 and
+		 * the IDLE state
+		 */
 		steps_tmp = steps - 2;
 
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
 		else
 			rngmask = 0xff;
-		// do the first part of the delay
-		this_usbduxfastsub->dux_commands[LENBASE + 4] = steps_tmp / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 4] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 4] = (0xFF - 0x02) & rngmask;	//reset
-		this_usbduxfastsub->dux_commands[LOGBASE + 4] = 0;
-
-		// and the second part
-		this_usbduxfastsub->dux_commands[LENBASE + 5] =
-			steps_tmp - steps_tmp / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 5] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 5] = 0;
-
-		this_usbduxfastsub->dux_commands[LENBASE + 6] = 1;
-		this_usbduxfastsub->dux_commands[OPBASE + 6] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 6] = 0;
+
+		/* do the first part of the delay */
+		udfs->dux_commands[LENBASE+4] = steps_tmp / 2;
+		udfs->dux_commands[OPBASE+4] = 0;
+		/* reset */
+		udfs->dux_commands[OUTBASE+4] = (0xFF - 0x02) & rngmask;
+		udfs->dux_commands[LOGBASE+4] = 0;
+
+		/* and the second part */
+		udfs->dux_commands[LENBASE+5] = steps_tmp - steps_tmp / 2;
+		udfs->dux_commands[OPBASE+5] = 0;
+		udfs->dux_commands[OUTBASE+5] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+5] = 0;
+
+		udfs->dux_commands[LENBASE+6] = 1;
+		udfs->dux_commands[OPBASE+6] = 0;
+		udfs->dux_commands[OUTBASE+6] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+6] = 0;
 		break;
 
 	case 3:
-		// three channels
+		/*
+		 * three channels
+		 */
 		for (j = 0; j < 1; j++) {
 			if (CR_RANGE(cmd->chanlist[j]) > 0)
 				rngmask = 0xff - 0x04;
 			else
 				rngmask = 0xff;
-			// commit data to the FIFO and do the first part of the delay
-			this_usbduxfastsub->dux_commands[LENBASE + j * 2] =
-				steps / 2;
-			this_usbduxfastsub->dux_commands[OPBASE + j * 2] = 0x02;	// data
-			this_usbduxfastsub->dux_commands[OUTBASE + j * 2] = 0xFF & rngmask;	// no change
-			this_usbduxfastsub->dux_commands[LOGBASE + j * 2] = 0;
+			/*
+			 * commit data to the FIFO and do the first part
+			 * of the delay
+			 */
+			udfs->dux_commands[LENBASE+j*2] = steps / 2;
+			/* data */
+			udfs->dux_commands[OPBASE+j*2] = 0x02;
+			/* no change */
+			udfs->dux_commands[OUTBASE+j*2] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE+j*2] = 0;
 
 			if (CR_RANGE(cmd->chanlist[j + 1]) > 0)
 				rngmask = 0xff - 0x04;
 			else
 				rngmask = 0xff;
-			// do the second part of the delay
-			this_usbduxfastsub->dux_commands[LENBASE + j * 2 + 1] =
-				steps - steps / 2;
-			this_usbduxfastsub->dux_commands[OPBASE + j * 2 + 1] = 0;	// no data
-			this_usbduxfastsub->dux_commands[OUTBASE + j * 2 + 1] = 0xFE & rngmask;	//count
-			this_usbduxfastsub->dux_commands[LOGBASE + j * 2 + 1] =
-				0;
+
+			/* do the second part of the delay */
+			udfs->dux_commands[LENBASE+j*2+1] = steps - steps / 2;
+			/* no data */
+			udfs->dux_commands[OPBASE+j*2+1] = 0;
+			/* count */
+			udfs->dux_commands[OUTBASE+j*2+1] = 0xFE & rngmask;
+			udfs->dux_commands[LOGBASE+j*2+1] = 0;
 		}
 
-		// 2 steps with duration 1: the idele step and step 6:
+		/* 2 steps with duration 1: the idele step and step 6: */
 		steps_tmp = steps - 2;
-		// commit data to the FIFO and do the first part of the delay
-		this_usbduxfastsub->dux_commands[LENBASE + 4] = steps_tmp / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 4] = 0x02;	// data
-		this_usbduxfastsub->dux_commands[OUTBASE + 4] = 0xFF & rngmask;	// no change
-		this_usbduxfastsub->dux_commands[LOGBASE + 4] = 0;
+
+		/* commit data to the FIFO and do the first part of the delay */
+		udfs->dux_commands[LENBASE+4] = steps_tmp / 2;
+		/* data */
+		udfs->dux_commands[OPBASE+4] = 0x02;
+		udfs->dux_commands[OUTBASE+4] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+4] = 0;
 
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
 		else
 			rngmask = 0xff;
-		// do the second part of the delay
-		this_usbduxfastsub->dux_commands[LENBASE + 5] =
-			steps_tmp - steps_tmp / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 5] = 0;	// no data
-		this_usbduxfastsub->dux_commands[OUTBASE + 5] = (0xFF - 0x02) & rngmask;	// reset
-		this_usbduxfastsub->dux_commands[LOGBASE + 5] = 0;
-
-		this_usbduxfastsub->dux_commands[LENBASE + 6] = 1;
-		this_usbduxfastsub->dux_commands[OPBASE + 6] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 6] = 0;
+
+		/* do the second part of the delay */
+		udfs->dux_commands[LENBASE+5] = steps_tmp - steps_tmp / 2;
+		/* no data */
+		udfs->dux_commands[OPBASE+5] = 0;
+		/* reset */
+		udfs->dux_commands[OUTBASE+5] = (0xFF - 0x02) & rngmask;
+		udfs->dux_commands[LOGBASE+5] = 0;
+
+		udfs->dux_commands[LENBASE+6] = 1;
+		udfs->dux_commands[OPBASE+6] = 0;
+		udfs->dux_commands[OUTBASE+6] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+6] = 0;
 
 	case 16:
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
 		else
 			rngmask = 0xff;
-		if (cmd->start_src == TRIG_EXT) {	// we loop here until ready has been set
-			this_usbduxfastsub->dux_commands[LENBASE + 0] = 0x01;	// branch back to state 0
-			this_usbduxfastsub->dux_commands[OPBASE + 0] = 0x01;	// deceision state w/o data
-			this_usbduxfastsub->dux_commands[OUTBASE + 0] = (0xFF - 0x02) & rngmask;	// reset
-			this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0x00;	// RDY0 = 0
-		} else {	// we just proceed to state 1
-			this_usbduxfastsub->dux_commands[LENBASE + 0] = 255;	// 30us reset pulse
-			this_usbduxfastsub->dux_commands[OPBASE + 0] = 0;
-			this_usbduxfastsub->dux_commands[OUTBASE + 0] = (0xFF - 0x02) & rngmask;	// reset
-			this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
+
+		if (cmd->start_src == TRIG_EXT) {
+			/*
+			 * we loop here until ready has been set
+			 */
+
+			/* branch back to state 0 */
+			udfs->dux_commands[LENBASE+0] = 0x01;
+			/* deceision state w/o data */
+			udfs->dux_commands[OPBASE+0] = 0x01;
+			/* reset */
+			udfs->dux_commands[OUTBASE+0] = (0xFF-0x02) & rngmask;
+			/* RDY0 = 0 */
+			udfs->dux_commands[LOGBASE+0] = 0x00;
+		} else {
+			/*
+			 * we just proceed to state 1
+			 */
+
+			/* 30us reset pulse */
+			udfs->dux_commands[LENBASE+0] = 255;
+			udfs->dux_commands[OPBASE+0] = 0;
+			/* reset */
+			udfs->dux_commands[OUTBASE+0] = (0xFF-0x02) & rngmask;
+			udfs->dux_commands[LOGBASE+0] = 0;
 		}
 
-		// commit data to the FIFO
-		this_usbduxfastsub->dux_commands[LENBASE + 1] = 1;
-		this_usbduxfastsub->dux_commands[OPBASE + 1] = 0x02;	// data
-		this_usbduxfastsub->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0;
+		/* commit data to the FIFO */
+		udfs->dux_commands[LENBASE+1] = 1;
+		/* data */
+		udfs->dux_commands[OPBASE+1] = 0x02;
+		udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+1] = 0;
 
-		// we have 2 states with duration 1
+		/* we have 2 states with duration 1 */
 		steps = steps - 2;
 
-		// do the first part of the delay
-		this_usbduxfastsub->dux_commands[LENBASE + 2] = steps / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 2] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 2] = 0;
-
-		// and the second part
-		this_usbduxfastsub->dux_commands[LENBASE + 3] =
-			steps - steps / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 3] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 3] = 0;
-
-		this_usbduxfastsub->dux_commands[LENBASE + 4] = 0x09;	// branch back to state 1
-		this_usbduxfastsub->dux_commands[OPBASE + 4] = 0x01;	// deceision state w/o data
-		this_usbduxfastsub->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 4] = 0xFF;	// doesn't matter
+		/* do the first part of the delay */
+		udfs->dux_commands[LENBASE+2] = steps / 2;
+		udfs->dux_commands[OPBASE+2] = 0;
+		udfs->dux_commands[OUTBASE+2] = 0xFE & rngmask;
+		udfs->dux_commands[LOGBASE+2] = 0;
+
+		/* and the second part */
+		udfs->dux_commands[LENBASE+3] = steps - steps / 2;
+		udfs->dux_commands[OPBASE+3] = 0;
+		udfs->dux_commands[OUTBASE+3] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+3] = 0;
+
+		/* branch back to state 1 */
+		udfs->dux_commands[LENBASE+4] = 0x09;
+		/* deceision state w/o data */
+		udfs->dux_commands[OPBASE+4] = 0x01;
+		udfs->dux_commands[OUTBASE+4] = 0xFF & rngmask;
+		/* doesn't matter */
+		udfs->dux_commands[LOGBASE+4] = 0xFF;
 
 		break;
 
 	default:
-		printk("comedi %d: unsupported combination of channels\n",
-			dev->minor);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi %d: unsupported combination of "
+		       "channels\n", dev->minor);
+		up(&udfs->sem);
 		return -EFAULT;
 	}
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi %d: sending commands to the usb device\n", dev->minor);
+	printk(KERN_DEBUG "comedi %d: sending commands to the usb device\n",
+	       dev->minor);
 #endif
-	// 0 means that the AD commands are sent
-	result = send_dux_commands(this_usbduxfastsub, SENDADCOMMANDS);
+	/* 0 means that the AD commands are sent */
+	result = send_dux_commands(udfs, SENDADCOMMANDS);
 	if (result < 0) {
-		printk("comedi%d: adc command could not be submitted. Aborting...\n", dev->minor);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: adc command could not be submitted."
+		       "Aborting...\n", dev->minor);
+		up(&udfs->sem);
 		return result;
 	}
 	if (cmd->stop_src == TRIG_COUNT) {
-		this_usbduxfastsub->ai_sample_count =
-			(cmd->stop_arg) * (cmd->scan_end_arg);
-		if (usbduxfastsub->ai_sample_count < 1) {
-			printk("comedi%d: (cmd->stop_arg)*(cmd->scan_end_arg)<1, aborting.\n", dev->minor);
-			up(&this_usbduxfastsub->sem);
+		udfs->ai_sample_count =	cmd->stop_arg * cmd->scan_end_arg;
+		if (udfs->ai_sample_count < 1) {
+			printk(KERN_ERR "comedi%d: "
+			       "(cmd->stop_arg)*(cmd->scan_end_arg)<1, "
+			       "aborting.\n", dev->minor);
+			up(&udfs->sem);
 			return -EFAULT;
 		}
-		this_usbduxfastsub->ai_continous = 0;
+		udfs->ai_continous = 0;
 	} else {
-		// continous aquisition
-		this_usbduxfastsub->ai_continous = 1;
-		this_usbduxfastsub->ai_sample_count = 0;
+		/* continous aquisition */
+		udfs->ai_continous = 1;
+		udfs->ai_sample_count = 0;
 	}
 
 	if ((cmd->start_src == TRIG_NOW) || (cmd->start_src == TRIG_EXT)) {
-		// enable this acquisition operation
-		this_usbduxfastsub->ai_cmd_running = 1;
-		ret = usbduxfastsub_submit_InURBs(this_usbduxfastsub);
+		/* enable this acquisition operation */
+		udfs->ai_cmd_running = 1;
+		ret = usbduxfastsub_submit_InURBs(udfs);
 		if (ret < 0) {
-			this_usbduxfastsub->ai_cmd_running = 0;
-			// fixme: unlink here??
-			up(&this_usbduxfastsub->sem);
+			udfs->ai_cmd_running = 0;
+			/* fixme: unlink here?? */
+			up(&udfs->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	} else {
-		/* TRIG_INT */
-		// don't enable the acquision operation
-		// wait for an internal signal
+		/*
+		 * TRIG_INT
+		 * don't enable the acquision operation
+		 * wait for an internal signal
+		 */
 		s->async->inttrig = usbduxfast_ai_inttrig;
 	}
-	up(&this_usbduxfastsub->sem);
+	up(&udfs->sem);
 
 	return 0;
 }
 
-/* Mode 0 is used to get a single conversion on demand */
-static int usbduxfast_ai_insn_read(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+/*
+ * Mode 0 is used to get a single conversion on demand.
+ */
+static int usbduxfast_ai_insn_read(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 	int i, j, n, actual_length;
 	int chan, range, rngmask;
 	int err;
-	usbduxfastsub_t *usbduxfastsub = dev->private;
+	struct usbduxfastsub_s *udfs;
 
-	if (!usbduxfastsub) {
-		printk("comedi%d: ai_insn_read: no usb dev.\n", dev->minor);
+	udfs = dev->private;
+	if (!udfs) {
+		printk(KERN_ERR "comedi%d: ai_insn_read: no usb dev.\n",
+		       dev->minor);
 		return -ENODEV;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: ai_insn_read, insn->n=%d, insn->subdev=%d\n",
-		dev->minor, insn->n, insn->subdev);
+	printk(KERN_DEBUG "comedi%d: ai_insn_read, insn->n=%d, "
+	       "insn->subdev=%d\n", dev->minor, insn->n, insn->subdev);
 #endif
-	down(&usbduxfastsub->sem);
-	if (!(usbduxfastsub->probed)) {
-		up(&usbduxfastsub->sem);
+	down(&udfs->sem);
+	if (!udfs->probed) {
+		up(&udfs->sem);
 		return -ENODEV;
 	}
-	if (usbduxfastsub->ai_cmd_running) {
-		printk("comedi%d: ai_insn_read not possible. Async Command is running.\n", dev->minor);
-		up(&usbduxfastsub->sem);
+	if (udfs->ai_cmd_running) {
+		printk(KERN_ERR "comedi%d: ai_insn_read not possible. Async "
+		       "Command is running.\n", dev->minor);
+		up(&udfs->sem);
 		return -EBUSY;
 	}
-	// sample one channel
+	/* sample one channel */
 	chan = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
-	// set command for the first channel
+	/* set command for the first channel */
 
 	if (range > 0)
 		rngmask = 0xff - 0x04;
 	else
 		rngmask = 0xff;
-	// commit data to the FIFO
-	usbduxfastsub->dux_commands[LENBASE + 0] = 1;
-	usbduxfastsub->dux_commands[OPBASE + 0] = 0x02;	// data
-	usbduxfastsub->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
-
-	// do the first part of the delay
-	usbduxfastsub->dux_commands[LENBASE + 1] = 12;
-	usbduxfastsub->dux_commands[OPBASE + 1] = 0;
-	usbduxfastsub->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 1] = 0;
-
-	usbduxfastsub->dux_commands[LENBASE + 2] = 1;
-	usbduxfastsub->dux_commands[OPBASE + 2] = 0;
-	usbduxfastsub->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 2] = 0;
-
-	usbduxfastsub->dux_commands[LENBASE + 3] = 1;
-	usbduxfastsub->dux_commands[OPBASE + 3] = 0;
-	usbduxfastsub->dux_commands[OUTBASE + 3] = 0xFE & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 3] = 0;
-
-	usbduxfastsub->dux_commands[LENBASE + 4] = 1;
-	usbduxfastsub->dux_commands[OPBASE + 4] = 0;
-	usbduxfastsub->dux_commands[OUTBASE + 4] = 0xFE & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 4] = 0;
-
-	// second part
-	usbduxfastsub->dux_commands[LENBASE + 5] = 12;
-	usbduxfastsub->dux_commands[OPBASE + 5] = 0;
-	usbduxfastsub->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 5] = 0;
-
-	usbduxfastsub->dux_commands[LENBASE + 6] = 1;
-	usbduxfastsub->dux_commands[OPBASE + 6] = 0;
-	usbduxfastsub->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
+
+	/* commit data to the FIFO */
+	udfs->dux_commands[LENBASE+0] = 1;
+	/* data */
+	udfs->dux_commands[OPBASE+0] = 0x02;
+	udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
+	udfs->dux_commands[LOGBASE+0] = 0;
+
+	/* do the first part of the delay */
+	udfs->dux_commands[LENBASE+1] = 12;
+	udfs->dux_commands[OPBASE+1] = 0;
+	udfs->dux_commands[OUTBASE+1] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE+1] = 0;
+
+	udfs->dux_commands[LENBASE+2] = 1;
+	udfs->dux_commands[OPBASE+2] = 0;
+	udfs->dux_commands[OUTBASE+2] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE+2] = 0;
+
+	udfs->dux_commands[LENBASE+3] = 1;
+	udfs->dux_commands[OPBASE+3] = 0;
+	udfs->dux_commands[OUTBASE+3] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE+3] = 0;
+
+	udfs->dux_commands[LENBASE+4] = 1;
+	udfs->dux_commands[OPBASE+4] = 0;
+	udfs->dux_commands[OUTBASE+4] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE+4] = 0;
+
+	/* second part */
+	udfs->dux_commands[LENBASE+5] = 12;
+	udfs->dux_commands[OPBASE+5] = 0;
+	udfs->dux_commands[OUTBASE+5] = 0xFF & rngmask;
+	udfs->dux_commands[LOGBASE+5] = 0;
+
+	udfs->dux_commands[LENBASE+6] = 1;
+	udfs->dux_commands[OPBASE+6] = 0;
+	udfs->dux_commands[OUTBASE+6] = 0xFF & rngmask;
+	udfs->dux_commands[LOGBASE+0] = 0;
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi %d: sending commands to the usb device\n", dev->minor);
+	printk(KERN_DEBUG "comedi %d: sending commands to the usb device\n",
+	       dev->minor);
 #endif
-	// 0 means that the AD commands are sent
-	err = send_dux_commands(usbduxfastsub, SENDADCOMMANDS);
+	/* 0 means that the AD commands are sent */
+	err = send_dux_commands(udfs, SENDADCOMMANDS);
 	if (err < 0) {
-		printk("comedi%d: adc command could not be submitted. Aborting...\n", dev->minor);
-		up(&usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: adc command could not be submitted."
+		       "Aborting...\n", dev->minor);
+		up(&udfs->sem);
 		return err;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: submitting in-urb: 0x%p,0x%p\n",
-		usbduxfastsub->comedidev->minor,
-		usbduxfastsub->urbIn->context,
-		usbduxfastsub->urbIn->dev);
+	printk(KERN_DEBUG "comedi%d: usbduxfast: submitting in-urb: "
+	       "0x%p,0x%p\n", udfs->comedidev->minor, udfs->urbIn->context,
+	       udfs->urbIn->dev);
 #endif
 	for (i = 0; i < PACKETS_TO_IGNORE; i++) {
-		err = usb_bulk_msg(usbduxfastsub->usbdev,
-				   usb_rcvbulkpipe(usbduxfastsub->usbdev,
-						   BULKINEP),
-				   usbduxfastsub->transfer_buffer, SIZEINBUF,
+		err = usb_bulk_msg(udfs->usbdev,
+				   usb_rcvbulkpipe(udfs->usbdev, BULKINEP),
+				   udfs->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
-			printk("comedi%d: insn timeout. No data.\n",
+			printk(KERN_ERR "comedi%d: insn timeout. No data.\n",
 				dev->minor);
-			up(&usbduxfastsub->sem);
+			up(&udfs->sem);
 			return err;
 		}
 	}
-	// data points
+	/* data points */
 	for (i = 0; i < insn->n;) {
-		err = usb_bulk_msg(usbduxfastsub->usbdev,
-				   usb_rcvbulkpipe(usbduxfastsub->usbdev,
-						   BULKINEP),
-				   usbduxfastsub->transfer_buffer, SIZEINBUF,
+		err = usb_bulk_msg(udfs->usbdev,
+				   usb_rcvbulkpipe(udfs->usbdev, BULKINEP),
+				   udfs->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
-			printk("comedi%d: insn data error: %d\n",
+			printk(KERN_ERR "comedi%d: insn data error: %d\n",
 				dev->minor, err);
-			up(&usbduxfastsub->sem);
+			up(&udfs->sem);
 			return err;
 		}
 		n = actual_length / sizeof(uint16_t);
 		if ((n % 16) != 0) {
-			printk("comedi%d: insn data packet corrupted.\n",
-				dev->minor);
-			up(&usbduxfastsub->sem);
+			printk(KERN_ERR "comedi%d: insn data packet "
+			       "corrupted.\n", dev->minor);
+			up(&udfs->sem);
 			return -EINVAL;
 		}
 		for (j = chan; (j < n) && (i < insn->n); j = j + 16) {
-			data[i] =
-				((uint16_t *) (usbduxfastsub->
-					transfer_buffer))[j];
+			data[i] = ((uint16_t *) (udfs->transfer_buffer))[j];
 			i++;
 		}
 	}
-	up(&usbduxfastsub->sem);
+	up(&udfs->sem);
 	return i;
 }
 
 static unsigned hex2unsigned(char *h)
 {
 	unsigned hi, lo;
-	if (h[0] > '9') {
+
+	if (h[0] > '9')
 		hi = h[0] - 'A' + 0x0a;
-	} else {
+	else
 		hi = h[0] - '0';
-	}
-	if (h[1] > '9') {
+
+	if (h[1] > '9')
 		lo = h[1] - 'A' + 0x0a;
-	} else {
+	else
 		lo = h[1] - '0';
-	}
+
 	return hi * 0x10 + lo;
 }
 
-// for FX2
+/* for FX2 */
 #define FIRMWARE_MAX_LEN 0x2000
 
-// taken from David Brownell's fxload and adjusted for this driver
-static int read_firmware(usbduxfastsub_t * usbduxfastsub, void *firmwarePtr,
+/*
+ * taken from David Brownell's fxload and adjusted for this driver
+ */
+static int read_firmware(struct usbduxfastsub_s *udfs, void *firmwarePtr,
 	long size)
 {
 	int i = 0;
@@ -1289,7 +1407,8 @@ static int read_firmware(usbduxfastsub_t * usbduxfastsub, void *firmwarePtr,
 
 	firmwareBinary = kmalloc(FIRMWARE_MAX_LEN, GFP_KERNEL);
 	if (!firmwareBinary) {
-		printk("comedi_: usbduxfast: mem alloc for firmware failed\n");
+		printk(KERN_ERR "comedi_: usbduxfast: mem alloc for firmware "
+		       " failed\n");
 		return -ENOMEM;
 	}
 
@@ -1300,32 +1419,36 @@ static int read_firmware(usbduxfastsub_t * usbduxfastsub, void *firmwarePtr,
 		int idx, off;
 		int j = 0;
 
-		// get one line
+		/* get one line */
 		while ((i < size) && (fp[i] != 13) && (fp[i] != 10)) {
 			buf[j] = fp[i];
 			i++;
 			j++;
 			if (j >= sizeof(buf)) {
-				printk("comedi_: usbduxfast: bogus firmware file!\n");
+				printk(KERN_ERR "comedi_: usbduxfast: bogus "
+				       "firmware file!\n");
 				kfree(firmwareBinary);
 				return -1;
 			}
 		}
-		// get rid of LF/CR/...
+		/* get rid of LF/CR/... */
 		while ((i < size) && ((fp[i] == 13) || (fp[i] == 10)
-				|| (fp[i] == 0))) {
+					|| (fp[i] == 0)))
 			i++;
-		}
 
 		buf[j] = 0;
-		//printk("comedi_: buf=%s\n",buf);
+		/* printk("comedi_: buf=%s\n",buf); */
 
-		/* EXTENSION: "# comment-till-end-of-line", for copyrights etc */
+		/*
+		 * EXTENSION: "# comment-till-end-of-line",
+		 * for copyrights etc
+		 */
 		if (buf[0] == '#')
 			continue;
 
 		if (buf[0] != ':') {
-			printk("comedi_: usbduxfast: upload: not an ihex record: %s", buf);
+			printk(KERN_ERR "comedi_: usbduxfast: upload: not an "
+			       "ihex record: %s", buf);
 			kfree(firmwareBinary);
 			return -EFAULT;
 		}
@@ -1336,86 +1459,88 @@ static int read_firmware(usbduxfastsub_t * usbduxfastsub, void *firmwarePtr,
 		/* Read the target offset */
 		off = (hex2unsigned(buf + 3) * 0x0100) + hex2unsigned(buf + 5);
 
-		if ((off + len) > maxAddr) {
+		if ((off + len) > maxAddr)
 			maxAddr = off + len;
-		}
 
 		if (maxAddr >= FIRMWARE_MAX_LEN) {
-			printk("comedi_: usbduxfast: firmware upload goes beyond FX2 RAM boundaries.");
+			printk(KERN_ERR "comedi_: usbduxfast: firmware upload "
+			       "goes beyond FX2 RAM boundaries.");
 			kfree(firmwareBinary);
 			return -EFAULT;
 		}
-		//printk("comedi_: usbduxfast: off=%x, len=%x:",off,len);
+		/* printk("comedi_: usbduxfast: off=%x, len=%x:",off,len); */
 
 		/* Read the record type */
 		type = hex2unsigned(buf + 7);
 
 		/* If this is an EOF record, then make it so. */
-		if (type == 1) {
+		if (type == 1)
 			break;
-		}
 
 		if (type != 0) {
-			printk("comedi_: usbduxfast: unsupported record type: %u\n", type);
+			printk(KERN_ERR "comedi_: usbduxfast: unsupported "
+			       "record type: %u\n", type);
 			kfree(firmwareBinary);
 			return -EFAULT;
 		}
 
 		for (idx = 0, cp = buf + 9; idx < len; idx += 1, cp += 2) {
 			firmwareBinary[idx + off] = hex2unsigned(cp);
-			//printk("%02x ",firmwareBinary[idx+off]);
+			/* printk("%02x ",firmwareBinary[idx+off]); */
 		}
-		//printk("\n");
+
+		/* printk("\n"); */
 
 		if (i >= size) {
-			printk("comedi_: usbduxfast: unexpected end of hex file\n");
+			printk(KERN_ERR "comedi_: usbduxfast: unexpected end "
+			       "of hex file\n");
 			break;
 		}
 
 	}
-	res = firmwareUpload(usbduxfastsub, firmwareBinary, maxAddr + 1);
+	res = firmwareUpload(udfs, firmwareBinary, maxAddr + 1);
 	kfree(firmwareBinary);
 	return res;
 }
 
-static void tidy_up(usbduxfastsub_t * usbduxfastsub_tmp)
+static void tidy_up(struct usbduxfastsub_s *udfs)
 {
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbduxfast: tiding up\n");
+	printk(KERN_DEBUG "comedi_: usbduxfast: tiding up\n");
 #endif
-	if (!usbduxfastsub_tmp) {
+
+	if (!udfs)
 		return;
-	}
 
-	// shows the usb subsystem that the driver is down
-	if (usbduxfastsub_tmp->interface) {
-		usb_set_intfdata(usbduxfastsub_tmp->interface, NULL);
-	}
+	/* shows the usb subsystem that the driver is down */
+	if (udfs->interface)
+		usb_set_intfdata(udfs->interface, NULL);
 
-	usbduxfastsub_tmp->probed = 0;
+	udfs->probed = 0;
 
-	if (usbduxfastsub_tmp->urbIn) {
-		// waits until a running transfer is over
-		usb_kill_urb(usbduxfastsub_tmp->urbIn);
-		if (usbduxfastsub_tmp->transfer_buffer) {
-			kfree(usbduxfastsub_tmp->transfer_buffer);
-			usbduxfastsub_tmp->transfer_buffer = NULL;
-		}
-		usb_free_urb(usbduxfastsub_tmp->urbIn);
-		usbduxfastsub_tmp->urbIn = NULL;
-	}
-	if (usbduxfastsub_tmp->insnBuffer) {
-		kfree(usbduxfastsub_tmp->insnBuffer);
-		usbduxfastsub_tmp->insnBuffer = NULL;
-	}
-	if (usbduxfastsub_tmp->dux_commands) {
-		kfree(usbduxfastsub_tmp->dux_commands);
-		usbduxfastsub_tmp->dux_commands = NULL;
+	if (udfs->urbIn) {
+		/* waits until a running transfer is over */
+		usb_kill_urb(udfs->urbIn);
+
+		kfree(udfs->transfer_buffer);
+		udfs->transfer_buffer = NULL;
+
+		usb_free_urb(udfs->urbIn);
+		udfs->urbIn = NULL;
 	}
-	usbduxfastsub_tmp->ai_cmd_running = 0;
+
+	kfree(udfs->insnBuffer);
+	udfs->insnBuffer = NULL;
+
+	kfree(udfs->dux_commands);
+	udfs->dux_commands = NULL;
+
+	udfs->ai_cmd_running = 0;
 }
 
-// allocate memory for the urbs and initialise them
+/*
+ * allocate memory for the urbs and initialise them
+ */
 static int usbduxfastsub_probe(struct usb_interface *uinterf,
 	const struct usb_device_id *id)
 {
@@ -1424,122 +1549,137 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 	int index;
 
 	if (udev->speed != USB_SPEED_HIGH) {
-		printk("comedi_: usbduxfast_: This driver needs USB 2.0 to operate. Aborting...\n");
+		printk(KERN_ERR "comedi_: usbduxfast_: This driver needs"
+		       "USB 2.0 to operate. Aborting...\n");
 		return -ENODEV;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbduxfast_: finding a free structure for the usb-device\n");
+	printk(KERN_DEBUG "comedi_: usbduxfast_: finding a free structure for "
+	       "the usb-device\n");
 #endif
 	down(&start_stop_sem);
-	// look for a free place in the usbduxfast array
+	/* look for a free place in the usbduxfast array */
 	index = -1;
 	for (i = 0; i < NUMUSBDUXFAST; i++) {
-		if (!(usbduxfastsub[i].probed)) {
+		if (!usbduxfastsub[i].probed) {
 			index = i;
 			break;
 		}
 	}
 
-	// no more space
+	/* no more space */
 	if (index == -1) {
-		printk("Too many usbduxfast-devices connected.\n");
+		printk(KERN_ERR "Too many usbduxfast-devices connected.\n");
 		up(&start_stop_sem);
 		return -EMFILE;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbduxfast: usbduxfastsub[%d] is ready to connect to comedi.\n", index);
+	printk(KERN_DEBUG "comedi_: usbduxfast: usbduxfastsub[%d] is ready to "
+	       "connect to comedi.\n", index);
 #endif
 
 	init_MUTEX(&(usbduxfastsub[index].sem));
-	// save a pointer to the usb device
+	/* save a pointer to the usb device */
 	usbduxfastsub[index].usbdev = udev;
 
-	// save the interface itself
+	/* save the interface itself */
 	usbduxfastsub[index].interface = uinterf;
-	// get the interface number from the interface
+	/* get the interface number from the interface */
 	usbduxfastsub[index].ifnum = uinterf->altsetting->desc.bInterfaceNumber;
-	// hand the private data over to the usb subsystem
-	// will be needed for disconnect
+	/*
+	 * hand the private data over to the usb subsystem
+	 * will be needed for disconnect
+	 */
 	usb_set_intfdata(uinterf, &(usbduxfastsub[index]));
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbduxfast: ifnum=%d\n", usbduxfastsub[index].ifnum);
+	printk(KERN_DEBUG "comedi_: usbduxfast: ifnum=%d\n",
+	       usbduxfastsub[index].ifnum);
 #endif
-	// create space for the commands going to the usb device
+	/* create space for the commands going to the usb device */
 	usbduxfastsub[index].dux_commands = kmalloc(SIZEOFDUXBUFFER,
-		GFP_KERNEL);
+						    GFP_KERNEL);
 	if (!usbduxfastsub[index].dux_commands) {
-		printk("comedi_: usbduxfast: error alloc space for dac commands\n");
+		printk(KERN_ERR "comedi_: usbduxfast: error alloc space for "
+		       "dac commands\n");
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	// create space of the instruction buffer
+	/* create space of the instruction buffer */
 	usbduxfastsub[index].insnBuffer = kmalloc(SIZEINSNBUF, GFP_KERNEL);
-	if (!(usbduxfastsub[index].insnBuffer)) {
-		printk("comedi_: usbduxfast: could not alloc space for insnBuffer\n");
+	if (!usbduxfastsub[index].insnBuffer) {
+		printk(KERN_ERR "comedi_: usbduxfast: could not alloc space "
+		       "for insnBuffer\n");
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	// setting to alternate setting 1: enabling bulk ep
+	/* setting to alternate setting 1: enabling bulk ep */
 	i = usb_set_interface(usbduxfastsub[index].usbdev,
 		usbduxfastsub[index].ifnum, 1);
 	if (i < 0) {
-		printk("comedi_: usbduxfast%d: could not switch to alternate setting 1.\n", index);
+		printk(KERN_ERR "comedi_: usbduxfast%d: could not switch to "
+		       "alternate setting 1.\n", index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENODEV;
 	}
 	usbduxfastsub[index].urbIn = usb_alloc_urb(0, GFP_KERNEL);
-	if (usbduxfastsub[index].urbIn == NULL) {
-		printk("comedi_: usbduxfast%d: Could not alloc. urb\n", index);
+	if (!usbduxfastsub[index].urbIn) {
+		printk(KERN_ERR "comedi_: usbduxfast%d: Could not alloc."
+		       "urb\n", index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	usbduxfastsub[index].transfer_buffer = kmalloc(SIZEINBUF, GFP_KERNEL);
-	if (!(usbduxfastsub[index].transfer_buffer)) {
-		printk("comedi_: usbduxfast%d: could not alloc. transb.\n",
-			index);
+	if (!usbduxfastsub[index].transfer_buffer) {
+		printk(KERN_ERR "comedi_: usbduxfast%d: could not alloc. "
+		       "transb.\n", index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	// we've reached the bottom of the function
+	/* we've reached the bottom of the function */
 	usbduxfastsub[index].probed = 1;
 	up(&start_stop_sem);
-	printk("comedi_: usbduxfast%d has been successfully initialized.\n",
-		index);
-	// success
+	printk(KERN_INFO "comedi_: usbduxfast%d has been successfully "
+	       "initialized.\n", index);
+	/* success */
 	return 0;
 }
 
 static void usbduxfastsub_disconnect(struct usb_interface *intf)
 {
-	usbduxfastsub_t *usbduxfastsub_tmp = usb_get_intfdata(intf);
+	struct usbduxfastsub_s *udfs = usb_get_intfdata(intf);
 	struct usb_device *udev = interface_to_usbdev(intf);
 
-	if (!usbduxfastsub_tmp) {
-		printk("comedi_: usbduxfast: disconnect called with null pointer.\n");
+	if (!udfs) {
+		printk(KERN_ERR "comedi_: usbduxfast: disconnect called with "
+		       "null pointer.\n");
 		return;
 	}
-	if (usbduxfastsub_tmp->usbdev != udev) {
-		printk("comedi_: usbduxfast: BUG! called with wrong ptr!!!\n");
+	if (udfs->usbdev != udev) {
+		printk(KERN_ERR "comedi_: usbduxfast: BUG! called with wrong "
+		       "ptr!!!\n");
 		return;
 	}
 	down(&start_stop_sem);
-	down(&usbduxfastsub_tmp->sem);
-	tidy_up(usbduxfastsub_tmp);
-	up(&usbduxfastsub_tmp->sem);
+	down(&udfs->sem);
+	tidy_up(udfs);
+	up(&udfs->sem);
 	up(&start_stop_sem);
+
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbduxfast: disconnected from the usb\n");
+	printk(KERN_DEBUG "comedi_: usbduxfast: disconnected from the usb\n");
 #endif
 }
 
-// is called when comedi-config is called
-static int usbduxfast_attach(comedi_device * dev, comedi_devconfig * it)
+/*
+ * is called when comedi-config is called
+ */
+static int usbduxfast_attach(comedi_device *dev, comedi_devconfig *it)
 {
 	int ret;
 	int index;
@@ -1548,26 +1688,31 @@ static int usbduxfast_attach(comedi_device * dev, comedi_devconfig * it)
 	dev->private = NULL;
 
 	down(&start_stop_sem);
-	// find a valid device which has been detected by the probe function of the usb
+	/*
+	 * find a valid device which has been detected by the
+	 * probe function of the usb
+	 */
 	index = -1;
 	for (i = 0; i < NUMUSBDUXFAST; i++) {
-		if ((usbduxfastsub[i].probed) && (!usbduxfastsub[i].attached)) {
+		if (usbduxfastsub[i].probed && !usbduxfastsub[i].attached) {
 			index = i;
 			break;
 		}
 	}
 
 	if (index < 0) {
-		printk("comedi%d: usbduxfast: error: attach failed, no usbduxfast devs connected to the usb bus.\n", dev->minor);
+		printk(KERN_ERR "comedi%d: usbduxfast: error: attach failed, "
+		       "no usbduxfast devs connected to the usb bus.\n",
+		       dev->minor);
 		up(&start_stop_sem);
 		return -ENODEV;
 	}
 
 	down(&(usbduxfastsub[index].sem));
-	// pointer back to the corresponding comedi device
+	/* pointer back to the corresponding comedi device */
 	usbduxfastsub[index].comedidev = dev;
 
-	// trying to upload the firmware into the chip
+	/* trying to upload the firmware into the chip */
 	if (comedi_aux_data(it->options, 0) &&
 		it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
 		read_firmware(usbduxfastsub,
@@ -1580,109 +1725,120 @@ static int usbduxfast_attach(comedi_device * dev, comedi_devconfig * it)
 	/* set number of subdevices */
 	dev->n_subdevices = N_SUBDEVICES;
 
-	// allocate space for the subdevices
-	if ((ret = alloc_subdevices(dev, N_SUBDEVICES)) < 0) {
-		printk("comedi%d: usbduxfast: error alloc space for subdev\n",
-			dev->minor);
+	/* allocate space for the subdevices */
+	ret = alloc_subdevices(dev, N_SUBDEVICES);
+	if (ret < 0) {
+		printk(KERN_ERR "comedi%d: usbduxfast: error alloc space for "
+		       "subdev\n", dev->minor);
 		up(&start_stop_sem);
 		return ret;
 	}
 
-	printk("comedi%d: usbduxfast: usb-device %d is attached to comedi.\n",
-		dev->minor, index);
-	// private structure is also simply the usb-structure
+	printk(KERN_INFO "comedi%d: usbduxfast: usb-device %d is attached to "
+	       "comedi.\n", dev->minor, index);
+	/* private structure is also simply the usb-structure */
 	dev->private = usbduxfastsub + index;
-	// the first subdevice is the A/D converter
+	/* the first subdevice is the A/D converter */
 	s = dev->subdevices + SUBDEV_AD;
-	// the URBs get the comedi subdevice
-	// which is responsible for reading
-	// this is the subdevice which reads data
+	/*
+	 * the URBs get the comedi subdevice which is responsible for reading
+	 * this is the subdevice which reads data
+	 */
 	dev->read_subdev = s;
-	// the subdevice receives as private structure the
-	// usb-structure
+	/* the subdevice receives as private structure the usb-structure */
 	s->private = NULL;
-	// analog input
+	/* analog input */
 	s->type = COMEDI_SUBD_AI;
-	// readable and ref is to ground
+	/* readable and ref is to ground */
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
-	// 16 channels
+	/* 16 channels */
 	s->n_chan = 16;
-	// length of the channellist
+	/* length of the channellist */
 	s->len_chanlist = 16;
-	// callback functions
+	/* callback functions */
 	s->insn_read = usbduxfast_ai_insn_read;
 	s->do_cmdtest = usbduxfast_ai_cmdtest;
 	s->do_cmd = usbduxfast_ai_cmd;
 	s->cancel = usbduxfast_ai_cancel;
-	// max value from the A/D converter (12bit+1 bit for overflow)
+	/* max value from the A/D converter (12bit+1 bit for overflow) */
 	s->maxdata = 0x1000;
-	// range table to convert to physical units
+	/* range table to convert to physical units */
 	s->range_table = &range_usbduxfast_ai_range;
 
-	// finally decide that it's attached
+	/* finally decide that it's attached */
 	usbduxfastsub[index].attached = 1;
 
 	up(&(usbduxfastsub[index].sem));
-
 	up(&start_stop_sem);
-
-	printk("comedi%d: successfully attached to usbduxfast.\n", dev->minor);
+	printk(KERN_INFO "comedi%d: successfully attached to usbduxfast.\n",
+	       dev->minor);
 
 	return 0;
 }
 
-static int usbduxfast_detach(comedi_device * dev)
+static int usbduxfast_detach(comedi_device *dev)
 {
-	usbduxfastsub_t *usbduxfastsub_tmp;
+	struct usbduxfastsub_s *udfs;
 
 	if (!dev) {
-		printk("comedi?: usbduxfast: detach without dev variable...\n");
+		printk(KERN_ERR "comedi?: usbduxfast: detach without dev "
+		       "variable...\n");
 		return -EFAULT;
 	}
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: detach usb device\n", dev->minor);
+	printk(KERN_DEBUG "comedi%d: usbduxfast: detach usb device\n",
+	       dev->minor);
 #endif
 
-	usbduxfastsub_tmp = dev->private;
-	if (!usbduxfastsub_tmp) {
-		printk("comedi?: usbduxfast: detach without ptr to usbduxfastsub[]\n");
+	udfs = dev->private;
+	if (!udfs) {
+		printk(KERN_ERR "comedi?: usbduxfast: detach without ptr to "
+		       "usbduxfastsub[]\n");
 		return -EFAULT;
 	}
 
-	down(&usbduxfastsub_tmp->sem);
+	down(&udfs->sem);
 	down(&start_stop_sem);
-	// Don't allow detach to free the private structure
-	// It's one entry of of usbduxfastsub[]
+	/*
+	 * Don't allow detach to free the private structure
+	 * It's one entry of of usbduxfastsub[]
+	 */
 	dev->private = NULL;
-	usbduxfastsub_tmp->attached = 0;
-	usbduxfastsub_tmp->comedidev = NULL;
+	udfs->attached = 0;
+	udfs->comedidev = NULL;
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: detach: successfully removed\n",
-		dev->minor);
+	printk(KERN_DEBUG "comedi%d: usbduxfast: detach: successfully "
+	       "removed\n", dev->minor);
 #endif
 	up(&start_stop_sem);
-	up(&usbduxfastsub_tmp->sem);
+	up(&udfs->sem);
 	return 0;
 }
 
-/* main driver struct */
+/*
+ * main driver struct
+ */
 static comedi_driver driver_usbduxfast = {
-      driver_name:"usbduxfast",
-      module:THIS_MODULE,
-      attach:usbduxfast_attach,
-      detach:usbduxfast_detach,
+	.driver_name	= "usbduxfast",
+	.module		= THIS_MODULE,
+	.attach		= usbduxfast_attach,
+	.detach		= usbduxfast_detach
 };
 
 static void init_usb_devices(void)
 {
 	int index;
+
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbduxfast: setting all possible devs to invalid\n");
+	printk(KERN_DEBUG "comedi_: usbduxfast: setting all possible devs to "
+	       "invalid\n");
 #endif
-	// all devices entries are invalid to begin with
-	// they will become valid by the probe function
-	// and then finally by the attach-function
+	/*
+	 * all devices entries are invalid to begin with
+	 * they will become valid by the probe function
+	 * and then finally by the attach-function
+	 */
 	for (index = 0; index < NUMUSBDUXFAST; index++) {
 		memset(&(usbduxfastsub[index]), 0x00,
 			sizeof(usbduxfastsub[index]));
@@ -1690,44 +1846,48 @@ static void init_usb_devices(void)
 	}
 }
 
-// Table with the USB-devices: just now only testing IDs
+/*
+ * Table with the USB-devices: just now only testing IDs
+ */
 static struct usb_device_id usbduxfastsub_table[] = {
-	//        { USB_DEVICE(0x4b4, 0x8613), //testing
-	//        },
-	{USB_DEVICE(0x13d8, 0x0010)	//real ID
-		},
-	{USB_DEVICE(0x13d8, 0x0011)	//real ID
-		},
-	{}			/* Terminating entry */
+	/* { USB_DEVICE(0x4b4, 0x8613) }, testing */
+	{ USB_DEVICE(0x13d8, 0x0010) },	/* real ID */
+	{ USB_DEVICE(0x13d8, 0x0011) },	/* real ID */
+	{ }			/* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE(usb, usbduxfastsub_table);
 
-// The usbduxfastsub-driver
+/*
+ * The usbduxfastsub-driver
+ */
 static struct usb_driver usbduxfastsub_driver = {
 #ifdef COMEDI_HAVE_USB_DRIVER_OWNER
-      owner:THIS_MODULE,
+	.owner		= THIS_MODULE,
 #endif
-      name:BOARDNAME,
-      probe:usbduxfastsub_probe,
-      disconnect:usbduxfastsub_disconnect,
-      id_table:usbduxfastsub_table,
+	.name		= BOARDNAME,
+	.probe		= usbduxfastsub_probe,
+	.disconnect	= usbduxfastsub_disconnect,
+	.id_table	= usbduxfastsub_table
 };
 
-// Can't use the nice macro as I have also to initialise the USB
-// subsystem:
-// registering the usb-system _and_ the comedi-driver
+/*
+ * Can't use the nice macro as I have also to initialise the USB subsystem:
+ * registering the usb-system _and_ the comedi-driver
+ */
 static int init_usbduxfast(void)
 {
-	printk(KERN_INFO KBUILD_MODNAME ": "
-	       DRIVER_VERSION ":" DRIVER_DESC "\n");
+	printk(KERN_INFO
+	       KBUILD_MODNAME ": " DRIVER_VERSION ":" DRIVER_DESC "\n");
 	init_usb_devices();
 	usb_register(&usbduxfastsub_driver);
 	comedi_driver_register(&driver_usbduxfast);
 	return 0;
 }
 
-// deregistering the comedi driver and the usb-subsystem
+/*
+ * deregistering the comedi driver and the usb-subsystem
+ */
 static void exit_usbduxfast(void)
 {
 	comedi_driver_unregister(&driver_usbduxfast);

commit 0a3b8b642247b509d3308cd9c32156d21505fcb8
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Mon Feb 16 21:31:27 2009 +0100

    Staging: comedi: usbduxfast: add comedi debug to Kconfig
    
    This patch moves CONFIG_COMEDI_DEBUG to Kconfig and cleans up the code
    as it didn't actually compile with debug enabled.
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 8e5efaad76a9..3439a0591e92 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -59,10 +59,6 @@ Status: testing
 #include "comedi_fc.h"
 #include "../comedidev.h"
 
-// (un)comment this if you want to have debug info.
-//#define CONFIG_COMEDI_DEBUG
-#undef  CONFIG_COMEDI_DEBUG
-
 #define BOARDNAME "usbduxfast"
 
 // timeout for the USB-transfer
@@ -189,26 +185,29 @@ static DECLARE_MUTEX(start_stop_sem);
 
 static int send_dux_commands(usbduxfastsub_t * this_usbduxfastsub, int cmd_type)
 {
-	int result, nsent;
+	int tmp, nsent;
+
 	this_usbduxfastsub->dux_commands[0] = cmd_type;
+
 #ifdef CONFIG_COMEDI_DEBUG
-	int i;
-	printk("comedi%d: usbduxfast: dux_commands: ",
+	printk(KERN_DEBUG "comedi%d: usbduxfast: dux_commands: ",
 		this_usbduxfastsub->comedidev->minor);
-	for (i = 0; i < SIZEOFDUXBUFFER; i++) {
-		printk(" %02x", this_usbduxfastsub->dux_commands[i]);
-	}
+	for (tmp = 0; tmp < SIZEOFDUXBUFFER; tmp++)
+		printk(" %02x", this_usbduxfastsub->dux_commands[tmp]);
 	printk("\n");
 #endif
-	result = usb_bulk_msg(this_usbduxfastsub->usbdev,
+
+	tmp = usb_bulk_msg(this_usbduxfastsub->usbdev,
 			      usb_sndbulkpipe(this_usbduxfastsub->usbdev,
 					      CHANNELLISTEP),
 			      this_usbduxfastsub->dux_commands, SIZEOFDUXBUFFER,
 			      &nsent, 10000);
-	if (result < 0) {
-		printk("comedi%d: could not transmit dux_commands to the usb-device, err=%d\n", this_usbduxfastsub->comedidev->minor, result);
-	}
-	return result;
+	if (tmp < 0)
+		printk(KERN_ERR "comedi%d: could not transmit dux_commands to"
+		       "the usb-device, err=%d\n",
+		       this_usbduxfastsub->comedidev->minor, tmp);
+
+	return tmp;
 }
 
 // Stops the data acquision
@@ -548,10 +547,10 @@ int usbduxfastsub_submit_InURBs(usbduxfastsub_t * usbduxfastsub)
 		SIZEINBUF, usbduxfastsub_ai_Irq, usbduxfastsub->comedidev);
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: submitting in-urb: %x,%x\n",
+	printk("comedi%d: usbduxfast: submitting in-urb: 0x%p,0x%p\n",
 		usbduxfastsub->comedidev->minor,
-		(int)(usbduxfastsub->urbIn->context),
-		(int)(usbduxfastsub->urbIn->dev));
+		usbduxfastsub->urbIn->context,
+		usbduxfastsub->urbIn->dev);
 #endif
 	errFlag = usb_submit_urb(usbduxfastsub->urbIn, GFP_ATOMIC);
 	if (errFlag) {
@@ -826,9 +825,8 @@ static int usbduxfast_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 		return -EINVAL;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: steps=%ld, convert_arg=%u, ai_timer=%u\n",
-		dev->minor,
-		steps, cmd->convert_arg, this_usbduxfastsub->ai_timer);
+	printk("comedi%d: usbduxfast: steps=%ld, convert_arg=%u\n",
+		dev->minor, steps, cmd->convert_arg);
 #endif
 
 	switch (cmd->chanlist_len) {
@@ -1211,10 +1209,10 @@ static int usbduxfast_ai_insn_read(comedi_device * dev,
 		return err;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: submitting in-urb: %x,%x\n",
+	printk("comedi%d: usbduxfast: submitting in-urb: 0x%p,0x%p\n",
 		usbduxfastsub->comedidev->minor,
-		(int)(usbduxfastsub->urbIn->context),
-		(int)(usbduxfastsub->urbIn->dev));
+		usbduxfastsub->urbIn->context,
+		usbduxfastsub->urbIn->dev);
 #endif
 	for (i = 0; i < PACKETS_TO_IGNORE; i++) {
 		err = usb_bulk_msg(usbduxfastsub->usbdev,

commit 6fffdb355c326b26482307d421b55fc00ee2abbc
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Mon Feb 16 21:31:26 2009 +0100

    Staging: comedi: usbduxfast: remove kernel version checks
    
    This patch removes kernel version checks from usbduxfast driver as the
    driver is in the main kernel tree now.
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index cc42d7a32c44..8e5efaad76a9 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -154,10 +154,8 @@ typedef struct {
 	int16_t *insnBuffer;
 	// interface number
 	int ifnum;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
-	// interface structure in 2.6
+	// interface structure
 	struct usb_interface *interface;
-#endif
 	// comedi device for the interrupt context
 	comedi_device *comedidev;
 	// asynchronous command is running
@@ -222,16 +220,9 @@ static int usbduxfastsub_unlink_InURBs(usbduxfastsub_t * usbduxfastsub_tmp)
 
 	if (usbduxfastsub_tmp && usbduxfastsub_tmp->urbIn) {
 		usbduxfastsub_tmp->ai_cmd_running = 0;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
-		j = usb_unlink_urb(usbduxfastsub_tmp->urbIn);
-		if (j < 0) {
-			err = j;
-		}
-#else
 		// waits until a running transfer is over
 		usb_kill_urb(usbduxfastsub_tmp->urbIn);
 		j = 0;
-#endif
 	}
 #ifdef CONFIG_COMEDI_DEBUG
 	printk("comedi: usbduxfast: unlinked InURB: res=%d\n", j);
@@ -296,11 +287,7 @@ static int usbduxfast_ai_cancel(comedi_device * dev, comedi_subdevice * s)
 
 // analogue IN
 // interrupt service routine
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-static void usbduxfastsub_ai_Irq(struct urb *urb)
-#else
 static void usbduxfastsub_ai_Irq(struct urb *urb PT_REGS_ARG)
-#endif
 {
 	int n, err;
 	usbduxfastsub_t *this_usbduxfastsub;
@@ -1401,22 +1388,17 @@ static void tidy_up(usbduxfastsub_t * usbduxfastsub_tmp)
 	if (!usbduxfastsub_tmp) {
 		return;
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+
 	// shows the usb subsystem that the driver is down
 	if (usbduxfastsub_tmp->interface) {
 		usb_set_intfdata(usbduxfastsub_tmp->interface, NULL);
 	}
-#endif
 
 	usbduxfastsub_tmp->probed = 0;
 
 	if (usbduxfastsub_tmp->urbIn) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,8)
 		// waits until a running transfer is over
-		// thus, under 2.4 hotplugging while a command
-		// is running is not safe
 		usb_kill_urb(usbduxfastsub_tmp->urbIn);
-#endif
 		if (usbduxfastsub_tmp->transfer_buffer) {
 			kfree(usbduxfastsub_tmp->transfer_buffer);
 			usbduxfastsub_tmp->transfer_buffer = NULL;
@@ -1436,16 +1418,10 @@ static void tidy_up(usbduxfastsub_t * usbduxfastsub_tmp)
 }
 
 // allocate memory for the urbs and initialise them
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-static void *usbduxfastsub_probe(struct usb_device *udev,
-	unsigned int interfnum, const struct usb_device_id *id)
-{
-#else
 static int usbduxfastsub_probe(struct usb_interface *uinterf,
 	const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
-#endif
 	int i;
 	int index;
 
@@ -1480,18 +1456,13 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 	// save a pointer to the usb device
 	usbduxfastsub[index].usbdev = udev;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	// save the interface number
-	usbduxfastsub[index].ifnum = interfnum;
-#else
-	// 2.6: save the interface itself
+	// save the interface itself
 	usbduxfastsub[index].interface = uinterf;
 	// get the interface number from the interface
 	usbduxfastsub[index].ifnum = uinterf->altsetting->desc.bInterfaceNumber;
 	// hand the private data over to the usb subsystem
 	// will be needed for disconnect
 	usb_set_intfdata(uinterf, &(usbduxfastsub[index]));
-#endif
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk("comedi_: usbduxfast: ifnum=%d\n", usbduxfastsub[index].ifnum);
@@ -1542,24 +1513,15 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 	up(&start_stop_sem);
 	printk("comedi_: usbduxfast%d has been successfully initialized.\n",
 		index);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	return (void *)(&usbduxfastsub[index]);
-#else
 	// success
 	return 0;
-#endif
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-static void usbduxfastsub_disconnect(struct usb_device *udev, void *ptr)
-{
-	usbduxfastsub_t *usbduxfastsub_tmp = (usbduxfastsub_t *) ptr;
-#else
 static void usbduxfastsub_disconnect(struct usb_interface *intf)
 {
 	usbduxfastsub_t *usbduxfastsub_tmp = usb_get_intfdata(intf);
 	struct usb_device *udev = interface_to_usbdev(intf);
-#endif
+
 	if (!usbduxfastsub_tmp) {
 		printk("comedi_: usbduxfast: disconnect called with null pointer.\n");
 		return;

commit 98ccdc56a067b267fc87f68c1d1ad1f2f237e217
Author: Julia Lawall <julia@diku.dk>
Date:   Fri Dec 26 08:28:58 2008 +0100

    Staging: comedi: Move a dereference below a NULL test
    
    If the NULL test is necessary, then the dereference should be moved below
    the NULL test.
    
    The semantic patch that makes this change is as follows:
    (http://www.emn.fr/x-info/coccinelle/).
    
    // <smpl>
    @disable is_null@
    identifier f;
    expression E;
    identifier fld;
    statement S;
    @@
    
    + if (E == NULL) S
      f(...,E->fld,...);
    - if (E == NULL) S
    
    @@
    identifier f;
    expression E;
    identifier fld;
    statement S;
    @@
    
    + if (!E) S
      f(...,E->fld,...);
    - if (!E) S
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 3ad3a08c3c20..cc42d7a32c44 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1675,15 +1675,15 @@ static int usbduxfast_detach(comedi_device * dev)
 {
 	usbduxfastsub_t *usbduxfastsub_tmp;
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: detach usb device\n", dev->minor);
-#endif
-
 	if (!dev) {
 		printk("comedi?: usbduxfast: detach without dev variable...\n");
 		return -EFAULT;
 	}
 
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi%d: usbduxfast: detach usb device\n", dev->minor);
+#endif
+
 	usbduxfastsub_tmp = dev->private;
 	if (!usbduxfastsub_tmp) {
 		printk("comedi?: usbduxfast: detach without ptr to usbduxfastsub[]\n");

commit b171041be02f171cd06712746b97a996f883ec10
Author: Julia Lawall <julia@diku.dk>
Date:   Thu Dec 25 21:10:30 2008 +0100

    Staging: comedi: introduce missing kfree
    
    Error handling code following a kmalloc should free the allocated data.
    
    The semantic match that finds the problem is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @r exists@
    local idexpression x;
    statement S;
    expression E;
    identifier f,l;
    position p1,p2;
    expression *ptr != NULL;
    @@
    
    (
    if ((x@p1 = \(kmalloc\|kzalloc\|kcalloc\)(...)) == NULL) S
    |
    x@p1 = \(kmalloc\|kzalloc\|kcalloc\)(...);
    ...
    if (x == NULL) S
    )
    <... when != x
         when != if (...) { <+...x...+> }
    x->f = E
    ...>
    (
     return \(0\|<+...x...+>\|ptr\);
    |
     return@p2 ...;
    )
    
    @script:python@
    p1 << r.p1;
    p2 << r.p2;
    @@
    
    print "* file: %s kmalloc %s return %s" % (p1[0].file,p1[0].line,p2[0].line)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 3a00ff0cfc5a..3ad3a08c3c20 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1298,7 +1298,7 @@ static int read_firmware(usbduxfastsub_t * usbduxfastsub, void *firmwarePtr,
 {
 	int i = 0;
 	unsigned char *fp = (char *)firmwarePtr;
-	unsigned char *firmwareBinary = NULL;
+	unsigned char *firmwareBinary;
 	int res = 0;
 	int maxAddr = 0;
 
@@ -1322,6 +1322,7 @@ static int read_firmware(usbduxfastsub_t * usbduxfastsub, void *firmwarePtr,
 			j++;
 			if (j >= sizeof(buf)) {
 				printk("comedi_: usbduxfast: bogus firmware file!\n");
+				kfree(firmwareBinary);
 				return -1;
 			}
 		}
@@ -1340,6 +1341,7 @@ static int read_firmware(usbduxfastsub_t * usbduxfastsub, void *firmwarePtr,
 
 		if (buf[0] != ':') {
 			printk("comedi_: usbduxfast: upload: not an ihex record: %s", buf);
+			kfree(firmwareBinary);
 			return -EFAULT;
 		}
 
@@ -1355,6 +1357,7 @@ static int read_firmware(usbduxfastsub_t * usbduxfastsub, void *firmwarePtr,
 
 		if (maxAddr >= FIRMWARE_MAX_LEN) {
 			printk("comedi_: usbduxfast: firmware upload goes beyond FX2 RAM boundaries.");
+			kfree(firmwareBinary);
 			return -EFAULT;
 		}
 		//printk("comedi_: usbduxfast: off=%x, len=%x:",off,len);
@@ -1369,6 +1372,7 @@ static int read_firmware(usbduxfastsub_t * usbduxfastsub, void *firmwarePtr,
 
 		if (type != 0) {
 			printk("comedi_: usbduxfast: unsupported record type: %u\n", type);
+			kfree(firmwareBinary);
 			return -EFAULT;
 		}
 

commit 8867635903ea4c52776820954ae7aaaca1e438cb
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Nov 18 17:09:23 2008 -0800

    Staging: comedi: usbduxfast: remove comedi usb wrappers
    
    Remove the comedi usb wrapper function usage in the usbduxfast driver as
    they are no longer needed.
    
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 403a614000b1..3a00ff0cfc5a 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -58,7 +58,6 @@ Status: testing
 #include <linux/compiler.h>
 #include "comedi_fc.h"
 #include "../comedidev.h"
-#include "../usb.h"
 
 // (un)comment this if you want to have debug info.
 //#define CONFIG_COMEDI_DEBUG
@@ -203,11 +202,11 @@ static int send_dux_commands(usbduxfastsub_t * this_usbduxfastsub, int cmd_type)
 	}
 	printk("\n");
 #endif
-	result = USB_BULK_MSG(this_usbduxfastsub->usbdev,
-		usb_sndbulkpipe(this_usbduxfastsub->usbdev,
-			CHANNELLISTEP),
-		this_usbduxfastsub->dux_commands,
-		SIZEOFDUXBUFFER, &nsent, 10000);
+	result = usb_bulk_msg(this_usbduxfastsub->usbdev,
+			      usb_sndbulkpipe(this_usbduxfastsub->usbdev,
+					      CHANNELLISTEP),
+			      this_usbduxfastsub->dux_commands, SIZEOFDUXBUFFER,
+			      &nsent, 10000);
 	if (result < 0) {
 		printk("comedi%d: could not transmit dux_commands to the usb-device, err=%d\n", this_usbduxfastsub->comedidev->minor, result);
 	}
@@ -404,7 +403,8 @@ static void usbduxfastsub_ai_Irq(struct urb *urb PT_REGS_ARG)
 	// resubmit urb for BULK transfer
 	urb->dev = this_usbduxfastsub->usbdev;
 	urb->status = 0;
-	if ((err = USB_SUBMIT_URB(urb)) < 0) {
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err < 0) {
 		printk("comedi%d: usbduxfast: urb resubm failed: %d",
 			this_usbduxfastsub->comedidev->minor, err);
 		s->async->events |= COMEDI_CB_EOA;
@@ -422,7 +422,7 @@ static int usbduxfastsub_start(usbduxfastsub_t * usbduxfastsub)
 	if (usbduxfastsub->probed) {
 		// 7f92 to zero
 		local_transfer_buffer[0] = 0;
-		errcode = USB_CONTROL_MSG(usbduxfastsub->usbdev,
+		errcode = usb_control_msg(usbduxfastsub->usbdev,
 			// create a pipe for a control transfer
 			usb_sndctrlpipe(usbduxfastsub->usbdev, 0),
 			// bRequest, "Firmware"
@@ -455,8 +455,7 @@ static int usbduxfastsub_stop(usbduxfastsub_t * usbduxfastsub)
 	if (usbduxfastsub->probed) {
 		// 7f92 to one
 		local_transfer_buffer[0] = 1;
-		errcode = USB_CONTROL_MSG
-			(usbduxfastsub->usbdev,
+		errcode = usb_control_msg(usbduxfastsub->usbdev,
 			usb_sndctrlpipe(usbduxfastsub->usbdev, 0),
 			// bRequest, "Firmware"
 			USBDUXFASTSUB_FIRMWARE,
@@ -491,8 +490,7 @@ static int usbduxfastsub_upload(usbduxfastsub_t * usbduxfastsub,
 		printk(" to addr %d, first byte=%d.\n",
 			startAddr, local_transfer_buffer[0]);
 #endif
-		errcode = USB_CONTROL_MSG
-			(usbduxfastsub->usbdev,
+		errcode = usb_control_msg(usbduxfastsub->usbdev,
 			usb_sndctrlpipe(usbduxfastsub->usbdev, 0),
 			// brequest, firmware
 			USBDUXFASTSUB_FIRMWARE,
@@ -568,11 +566,10 @@ int usbduxfastsub_submit_InURBs(usbduxfastsub_t * usbduxfastsub)
 		(int)(usbduxfastsub->urbIn->context),
 		(int)(usbduxfastsub->urbIn->dev));
 #endif
-	errFlag = USB_SUBMIT_URB(usbduxfastsub->urbIn);
+	errFlag = usb_submit_urb(usbduxfastsub->urbIn, GFP_ATOMIC);
 	if (errFlag) {
-		printk("comedi_: usbduxfast: ai: ");
-		printk("USB_SUBMIT_URB");
-		printk(" error %d\n", errFlag);
+		printk("comedi_: usbduxfast: ai: usb_submit_urb error %d\n",
+			errFlag);
 		return errFlag;
 	}
 	return 0;
@@ -1233,10 +1230,11 @@ static int usbduxfast_ai_insn_read(comedi_device * dev,
 		(int)(usbduxfastsub->urbIn->dev));
 #endif
 	for (i = 0; i < PACKETS_TO_IGNORE; i++) {
-		err = USB_BULK_MSG(usbduxfastsub->usbdev,
-			usb_rcvbulkpipe(usbduxfastsub->usbdev, BULKINEP),
-			usbduxfastsub->transfer_buffer,
-			SIZEINBUF, &actual_length, 10000);
+		err = usb_bulk_msg(usbduxfastsub->usbdev,
+				   usb_rcvbulkpipe(usbduxfastsub->usbdev,
+						   BULKINEP),
+				   usbduxfastsub->transfer_buffer, SIZEINBUF,
+				   &actual_length, 10000);
 		if (err < 0) {
 			printk("comedi%d: insn timeout. No data.\n",
 				dev->minor);
@@ -1246,10 +1244,11 @@ static int usbduxfast_ai_insn_read(comedi_device * dev,
 	}
 	// data points
 	for (i = 0; i < insn->n;) {
-		err = USB_BULK_MSG(usbduxfastsub->usbdev,
-			usb_rcvbulkpipe(usbduxfastsub->usbdev, BULKINEP),
-			usbduxfastsub->transfer_buffer,
-			SIZEINBUF, &actual_length, 10000);
+		err = usb_bulk_msg(usbduxfastsub->usbdev,
+				   usb_rcvbulkpipe(usbduxfastsub->usbdev,
+						   BULKINEP),
+				   usbduxfastsub->transfer_buffer, SIZEINBUF,
+				   &actual_length, 10000);
 		if (err < 0) {
 			printk("comedi%d: insn data error: %d\n",
 				dev->minor, err);
@@ -1448,7 +1447,7 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 
 	if (udev->speed != USB_SPEED_HIGH) {
 		printk("comedi_: usbduxfast_: This driver needs USB 2.0 to operate. Aborting...\n");
-		return PROBE_ERR_RETURN(-ENODEV);
+		return -ENODEV;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
 	printk("comedi_: usbduxfast_: finding a free structure for the usb-device\n");
@@ -1467,7 +1466,7 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 	if (index == -1) {
 		printk("Too many usbduxfast-devices connected.\n");
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-EMFILE);
+		return -EMFILE;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
 	printk("comedi_: usbduxfast: usbduxfastsub[%d] is ready to connect to comedi.\n", index);
@@ -1500,7 +1499,7 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 		printk("comedi_: usbduxfast: error alloc space for dac commands\n");
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENOMEM);
+		return -ENOMEM;
 	}
 	// create space of the instruction buffer
 	usbduxfastsub[index].insnBuffer = kmalloc(SIZEINSNBUF, GFP_KERNEL);
@@ -1508,7 +1507,7 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 		printk("comedi_: usbduxfast: could not alloc space for insnBuffer\n");
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENOMEM);
+		return -ENOMEM;
 	}
 	// setting to alternate setting 1: enabling bulk ep
 	i = usb_set_interface(usbduxfastsub[index].usbdev,
@@ -1517,14 +1516,14 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 		printk("comedi_: usbduxfast%d: could not switch to alternate setting 1.\n", index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENODEV);
+		return -ENODEV;
 	}
-	usbduxfastsub[index].urbIn = USB_ALLOC_URB(0);
+	usbduxfastsub[index].urbIn = usb_alloc_urb(0, GFP_KERNEL);
 	if (usbduxfastsub[index].urbIn == NULL) {
 		printk("comedi_: usbduxfast%d: Could not alloc. urb\n", index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENOMEM);
+		return -ENOMEM;
 	}
 	usbduxfastsub[index].transfer_buffer = kmalloc(SIZEINBUF, GFP_KERNEL);
 	if (!(usbduxfastsub[index].transfer_buffer)) {
@@ -1532,7 +1531,7 @@ static int usbduxfastsub_probe(struct usb_interface *uinterf,
 			index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENOMEM);
+		return -ENOMEM;
 	}
 	// we've reached the bottom of the function
 	usbduxfastsub[index].probed = 1;

commit f47c697d130087831ac47bbbd2758c01de2e7081
Author: Bernd Porr <BerndPorr@f2s.com>
Date:   Fri Nov 14 14:49:34 2008 -0800

    Staging: comedi: add usb usbduxfast driver
    
    ITL USB-DUXfast driver
    
    From: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
new file mode 100644
index 000000000000..403a614000b1
--- /dev/null
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -0,0 +1,1779 @@
+#define DRIVER_VERSION "v0.99a"
+#define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
+#define DRIVER_DESC "USB-DUXfast, BerndPorr@f2s.com"
+/*
+   comedi/drivers/usbduxfast.c
+   Copyright (C) 2004 Bernd Porr, Bernd.Porr@f2s.com
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/*
+Driver: usbduxfast
+Description: ITL USB-DUXfast
+Devices: [ITL] USB-DUX (usbduxfast.o)
+Author: Bernd Porr <BerndPorr@f2s.com>
+Updated: 04 Dec 2006
+Status: testing
+*/
+
+/*
+ * I must give credit here to Chris Baugher who
+ * wrote the driver for AT-MIO-16d. I used some parts of this
+ * driver. I also must give credits to David Brownell
+ * who supported me with the USB development.
+ *
+ * Bernd Porr
+ *
+ *
+ * Revision history:
+ * 0.9: Dropping the first data packet which seems to be from the last transfer.
+ *      Buffer overflows in the FX2 are handed over to comedi.
+ * 0.92: Dropping now 4 packets. The quad buffer has to be emptied.
+ *       Added insn command basically for testing. Sample rate is 1MHz/16ch=62.5kHz
+ * 0.99: Ian Abbott pointed out a bug which has been corrected. Thanks!
+ * 0.99a: added external trigger.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/usb.h>
+#include <linux/smp_lock.h>
+#include <linux/fcntl.h>
+#include <linux/compiler.h>
+#include "comedi_fc.h"
+#include "../comedidev.h"
+#include "../usb.h"
+
+// (un)comment this if you want to have debug info.
+//#define CONFIG_COMEDI_DEBUG
+#undef  CONFIG_COMEDI_DEBUG
+
+#define BOARDNAME "usbduxfast"
+
+// timeout for the USB-transfer
+#define EZTIMEOUT 30
+
+// constants for "firmware" upload and download
+#define USBDUXFASTSUB_FIRMWARE 0xA0
+#define VENDOR_DIR_IN  0xC0
+#define VENDOR_DIR_OUT 0x40
+
+// internal adresses of the 8051 processor
+#define USBDUXFASTSUB_CPUCS 0xE600
+
+// max lenghth of the transfer-buffer for software upload
+#define TB_LEN 0x2000
+
+// Input endpoint number
+#define BULKINEP           6
+
+// Endpoint for the A/D channellist: bulk OUT
+#define CHANNELLISTEP     4
+
+// Number of channels
+#define NUMCHANNELS       32
+
+// size of the waveform descriptor
+#define WAVESIZE          0x20
+
+// Size of one A/D value
+#define SIZEADIN          ((sizeof(int16_t)))
+
+// Size of the input-buffer IN BYTES
+#define SIZEINBUF         512
+
+// 16 bytes.
+#define SIZEINSNBUF       512
+
+// Size of the buffer for the dux commands
+#define SIZEOFDUXBUFFER    256	// bytes
+
+// Number of in-URBs which receive the data: min=5
+#define NUMOFINBUFFERSHIGH     10
+
+// Total number of usbduxfast devices
+#define NUMUSBDUXFAST             16
+
+// Number of subdevices
+#define N_SUBDEVICES          1
+
+// Analogue in subdevice
+#define SUBDEV_AD             0
+
+// min delay steps for more than one channel
+// basically when the mux gives up. ;-)
+#define MIN_SAMPLING_PERIOD 9	// steps at 30MHz in the FX2
+
+// Max number of 1/30MHz delay steps:
+#define MAX_SAMPLING_PERIOD 500
+
+// Number of received packets to ignore before we start handing data over to comedi.
+// It's quad buffering and we have to ignore 4 packets.
+#define PACKETS_TO_IGNORE 4
+
+/////////////////////////////////////////////
+// comedi constants
+static const comedi_lrange range_usbduxfast_ai_range = { 2, {
+			BIP_RANGE(0.75),
+			BIP_RANGE(0.5),
+	}
+};
+
+/*
+ * private structure of one subdevice
+ */
+
+// This is the structure which holds all the data of this driver
+// one sub device just now: A/D
+typedef struct {
+	// attached?
+	int attached;
+	// is it associated with a subdevice?
+	int probed;
+	// pointer to the usb-device
+	struct usb_device *usbdev;
+	// BULK-transfer handling: urb
+	struct urb *urbIn;
+	int8_t *transfer_buffer;
+	// input buffer for single insn
+	int16_t *insnBuffer;
+	// interface number
+	int ifnum;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	// interface structure in 2.6
+	struct usb_interface *interface;
+#endif
+	// comedi device for the interrupt context
+	comedi_device *comedidev;
+	// asynchronous command is running
+	short int ai_cmd_running;
+	// continous aquisition
+	short int ai_continous;
+	// number of samples to aquire
+	long int ai_sample_count;
+	// commands
+	uint8_t *dux_commands;
+	// counter which ignores the first buffers
+	int ignore;
+	struct semaphore sem;
+} usbduxfastsub_t;
+
+// The pointer to the private usb-data of the driver
+// is also the private data for the comedi-device.
+// This has to be global as the usb subsystem needs
+// global variables. The other reason is that this
+// structure must be there _before_ any comedi
+// command is issued. The usb subsystem must be
+// initialised before comedi can access it.
+static usbduxfastsub_t usbduxfastsub[NUMUSBDUXFAST];
+
+static DECLARE_MUTEX(start_stop_sem);
+
+// bulk transfers to usbduxfast
+
+#define SENDADCOMMANDS            0
+#define SENDINITEP6               1
+
+static int send_dux_commands(usbduxfastsub_t * this_usbduxfastsub, int cmd_type)
+{
+	int result, nsent;
+	this_usbduxfastsub->dux_commands[0] = cmd_type;
+#ifdef CONFIG_COMEDI_DEBUG
+	int i;
+	printk("comedi%d: usbduxfast: dux_commands: ",
+		this_usbduxfastsub->comedidev->minor);
+	for (i = 0; i < SIZEOFDUXBUFFER; i++) {
+		printk(" %02x", this_usbduxfastsub->dux_commands[i]);
+	}
+	printk("\n");
+#endif
+	result = USB_BULK_MSG(this_usbduxfastsub->usbdev,
+		usb_sndbulkpipe(this_usbduxfastsub->usbdev,
+			CHANNELLISTEP),
+		this_usbduxfastsub->dux_commands,
+		SIZEOFDUXBUFFER, &nsent, 10000);
+	if (result < 0) {
+		printk("comedi%d: could not transmit dux_commands to the usb-device, err=%d\n", this_usbduxfastsub->comedidev->minor, result);
+	}
+	return result;
+}
+
+// Stops the data acquision
+// It should be safe to call this function from any context
+static int usbduxfastsub_unlink_InURBs(usbduxfastsub_t * usbduxfastsub_tmp)
+{
+	int j = 0;
+	int err = 0;
+
+	if (usbduxfastsub_tmp && usbduxfastsub_tmp->urbIn) {
+		usbduxfastsub_tmp->ai_cmd_running = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+		j = usb_unlink_urb(usbduxfastsub_tmp->urbIn);
+		if (j < 0) {
+			err = j;
+		}
+#else
+		// waits until a running transfer is over
+		usb_kill_urb(usbduxfastsub_tmp->urbIn);
+		j = 0;
+#endif
+	}
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi: usbduxfast: unlinked InURB: res=%d\n", j);
+#endif
+	return err;
+}
+
+/* This will stop a running acquisition operation */
+// Is called from within this driver from both the
+// interrupt context and from comedi
+static int usbduxfast_ai_stop(usbduxfastsub_t * this_usbduxfastsub,
+	int do_unlink)
+{
+	int ret = 0;
+
+	if (!this_usbduxfastsub) {
+		printk("comedi?: usbduxfast_ai_stop: this_usbduxfastsub=NULL!\n");
+		return -EFAULT;
+	}
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi: usbduxfast_ai_stop\n");
+#endif
+
+	this_usbduxfastsub->ai_cmd_running = 0;
+
+	if (do_unlink) {
+		// stop aquistion
+		ret = usbduxfastsub_unlink_InURBs(this_usbduxfastsub);
+	}
+
+	return ret;
+}
+
+// This will cancel a running acquisition operation.
+// This is called by comedi but never from inside the
+// driver.
+static int usbduxfast_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	usbduxfastsub_t *this_usbduxfastsub;
+	int res = 0;
+
+	// force unlink of all urbs
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi: usbduxfast_ai_cancel\n");
+#endif
+	this_usbduxfastsub = dev->private;
+	if (!this_usbduxfastsub) {
+		printk("comedi: usbduxfast_ai_cancel: this_usbduxfastsub=NULL\n");
+		return -EFAULT;
+	}
+	down(&this_usbduxfastsub->sem);
+	if (!(this_usbduxfastsub->probed)) {
+		up(&this_usbduxfastsub->sem);
+		return -ENODEV;
+	}
+	// unlink
+	res = usbduxfast_ai_stop(this_usbduxfastsub, 1);
+	up(&this_usbduxfastsub->sem);
+
+	return res;
+}
+
+// analogue IN
+// interrupt service routine
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void usbduxfastsub_ai_Irq(struct urb *urb)
+#else
+static void usbduxfastsub_ai_Irq(struct urb *urb PT_REGS_ARG)
+#endif
+{
+	int n, err;
+	usbduxfastsub_t *this_usbduxfastsub;
+	comedi_device *this_comedidev;
+	comedi_subdevice *s;
+	uint16_t *p;
+
+	// sanity checks
+	// is the urb there?
+	if (!urb) {
+		printk("comedi_: usbduxfast_: ao int-handler called with urb=NULL!\n");
+		return;
+	}
+	// the context variable points to the subdevice
+	this_comedidev = urb->context;
+	if (!this_comedidev) {
+		printk("comedi_: usbduxfast_: urb context is a NULL pointer!\n");
+		return;
+	}
+	// the private structure of the subdevice is usbduxfastsub_t
+	this_usbduxfastsub = this_comedidev->private;
+	if (!this_usbduxfastsub) {
+		printk("comedi_: usbduxfast_: private of comedi subdev is a NULL pointer!\n");
+		return;
+	}
+	// are we running a command?
+	if (unlikely(!(this_usbduxfastsub->ai_cmd_running))) {
+		// not running a command
+		// do not continue execution if no asynchronous command is running
+		// in particular not resubmit
+		return;
+	}
+
+	if (unlikely(!(this_usbduxfastsub->attached))) {
+		// no comedi device there
+		return;
+	}
+	// subdevice which is the AD converter
+	s = this_comedidev->subdevices + SUBDEV_AD;
+
+	// first we test if something unusual has just happened
+	switch (urb->status) {
+	case 0:
+		break;
+
+		// happens after an unlink command or when the device is plugged out
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -ECONNABORTED:
+		// tell this comedi
+		s->async->events |= COMEDI_CB_EOA;
+		s->async->events |= COMEDI_CB_ERROR;
+		comedi_event(this_usbduxfastsub->comedidev, s);
+		// stop the transfer w/o unlink
+		usbduxfast_ai_stop(this_usbduxfastsub, 0);
+		return;
+
+	default:
+		printk("comedi%d: usbduxfast: non-zero urb status received in ai intr context: %d\n", this_usbduxfastsub->comedidev->minor, urb->status);
+		s->async->events |= COMEDI_CB_EOA;
+		s->async->events |= COMEDI_CB_ERROR;
+		comedi_event(this_usbduxfastsub->comedidev, s);
+		usbduxfast_ai_stop(this_usbduxfastsub, 0);
+		return;
+	}
+
+	p = urb->transfer_buffer;
+	if (!this_usbduxfastsub->ignore) {
+		if (!(this_usbduxfastsub->ai_continous)) {
+			// not continous, fixed number of samples
+			n = urb->actual_length / sizeof(uint16_t);
+			if (unlikely(this_usbduxfastsub->ai_sample_count < n)) {
+				// we have send only a fraction of the bytes received
+				cfc_write_array_to_buffer(s,
+					urb->transfer_buffer,
+					this_usbduxfastsub->ai_sample_count *
+					sizeof(uint16_t));
+				usbduxfast_ai_stop(this_usbduxfastsub, 0);
+				// say comedi that the acquistion is over
+				s->async->events |= COMEDI_CB_EOA;
+				comedi_event(this_usbduxfastsub->comedidev, s);
+				return;
+			}
+			this_usbduxfastsub->ai_sample_count -= n;
+		}
+		// write the full buffer to comedi
+		cfc_write_array_to_buffer(s,
+			urb->transfer_buffer, urb->actual_length);
+
+		// tell comedi that data is there
+		comedi_event(this_usbduxfastsub->comedidev, s);
+
+	} else {
+		// ignore this packet
+		this_usbduxfastsub->ignore--;
+	}
+
+	// command is still running
+	// resubmit urb for BULK transfer
+	urb->dev = this_usbduxfastsub->usbdev;
+	urb->status = 0;
+	if ((err = USB_SUBMIT_URB(urb)) < 0) {
+		printk("comedi%d: usbduxfast: urb resubm failed: %d",
+			this_usbduxfastsub->comedidev->minor, err);
+		s->async->events |= COMEDI_CB_EOA;
+		s->async->events |= COMEDI_CB_ERROR;
+		comedi_event(this_usbduxfastsub->comedidev, s);
+		usbduxfast_ai_stop(this_usbduxfastsub, 0);
+	}
+}
+
+static int usbduxfastsub_start(usbduxfastsub_t * usbduxfastsub)
+{
+	int errcode = 0;
+	unsigned char local_transfer_buffer[16];
+
+	if (usbduxfastsub->probed) {
+		// 7f92 to zero
+		local_transfer_buffer[0] = 0;
+		errcode = USB_CONTROL_MSG(usbduxfastsub->usbdev,
+			// create a pipe for a control transfer
+			usb_sndctrlpipe(usbduxfastsub->usbdev, 0),
+			// bRequest, "Firmware"
+			USBDUXFASTSUB_FIRMWARE,
+			// bmRequestType
+			VENDOR_DIR_OUT,
+			// Value
+			USBDUXFASTSUB_CPUCS,
+			// Index
+			0x0000,
+			// address of the transfer buffer
+			local_transfer_buffer,
+			// Length
+			1,
+			// Timeout
+			EZTIMEOUT);
+		if (errcode < 0) {
+			printk("comedi_: usbduxfast_: control msg failed (start)\n");
+			return errcode;
+		}
+	}
+	return 0;
+}
+
+static int usbduxfastsub_stop(usbduxfastsub_t * usbduxfastsub)
+{
+	int errcode = 0;
+
+	unsigned char local_transfer_buffer[16];
+	if (usbduxfastsub->probed) {
+		// 7f92 to one
+		local_transfer_buffer[0] = 1;
+		errcode = USB_CONTROL_MSG
+			(usbduxfastsub->usbdev,
+			usb_sndctrlpipe(usbduxfastsub->usbdev, 0),
+			// bRequest, "Firmware"
+			USBDUXFASTSUB_FIRMWARE,
+			// bmRequestType
+			VENDOR_DIR_OUT,
+			// Value
+			USBDUXFASTSUB_CPUCS,
+			// Index
+			0x0000, local_transfer_buffer,
+			// Length
+			1,
+			// Timeout
+			EZTIMEOUT);
+		if (errcode < 0) {
+			printk("comedi_: usbduxfast: control msg failed (stop)\n");
+			return errcode;
+		}
+	}
+	return 0;
+}
+
+static int usbduxfastsub_upload(usbduxfastsub_t * usbduxfastsub,
+	unsigned char *local_transfer_buffer,
+	unsigned int startAddr, unsigned int len)
+{
+	int errcode;
+
+	if (usbduxfastsub->probed) {
+#ifdef CONFIG_COMEDI_DEBUG
+		printk("comedi%d: usbduxfast: uploading %d bytes",
+			usbduxfastsub->comedidev->minor, len);
+		printk(" to addr %d, first byte=%d.\n",
+			startAddr, local_transfer_buffer[0]);
+#endif
+		errcode = USB_CONTROL_MSG
+			(usbduxfastsub->usbdev,
+			usb_sndctrlpipe(usbduxfastsub->usbdev, 0),
+			// brequest, firmware
+			USBDUXFASTSUB_FIRMWARE,
+			// bmRequestType
+			VENDOR_DIR_OUT,
+			// value
+			startAddr,
+			// index
+			0x0000,
+			// our local safe buffer
+			local_transfer_buffer,
+			// length
+			len,
+			// timeout
+			EZTIMEOUT);
+#ifdef CONFIG_COMEDI_DEBUG
+		printk("comedi_: usbduxfast: result=%d\n", errcode);
+#endif
+		if (errcode < 0) {
+			printk("comedi_: usbduxfast: uppload failed\n");
+			return errcode;
+		}
+	} else {
+		// no device on the bus for this index
+		return -EFAULT;
+	}
+	return 0;
+}
+
+int firmwareUpload(usbduxfastsub_t * usbduxfastsub,
+	unsigned char *firmwareBinary, int sizeFirmware)
+{
+	int ret;
+
+	if (!firmwareBinary) {
+		return 0;
+	}
+	ret = usbduxfastsub_stop(usbduxfastsub);
+	if (ret < 0) {
+		printk("comedi_: usbduxfast: can not stop firmware\n");
+		return ret;
+	}
+	ret = usbduxfastsub_upload(usbduxfastsub,
+		firmwareBinary, 0, sizeFirmware);
+	if (ret < 0) {
+		printk("comedi_: usbduxfast: firmware upload failed\n");
+		return ret;
+	}
+	ret = usbduxfastsub_start(usbduxfastsub);
+	if (ret < 0) {
+		printk("comedi_: usbduxfast: can not start firmware\n");
+		return ret;
+	}
+	return 0;
+}
+
+int usbduxfastsub_submit_InURBs(usbduxfastsub_t * usbduxfastsub)
+{
+	int errFlag;
+
+	if (!usbduxfastsub) {
+		return -EFAULT;
+	}
+	usb_fill_bulk_urb(usbduxfastsub->urbIn,
+		usbduxfastsub->usbdev,
+		usb_rcvbulkpipe(usbduxfastsub->usbdev, BULKINEP),
+		usbduxfastsub->transfer_buffer,
+		SIZEINBUF, usbduxfastsub_ai_Irq, usbduxfastsub->comedidev);
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi%d: usbduxfast: submitting in-urb: %x,%x\n",
+		usbduxfastsub->comedidev->minor,
+		(int)(usbduxfastsub->urbIn->context),
+		(int)(usbduxfastsub->urbIn->dev));
+#endif
+	errFlag = USB_SUBMIT_URB(usbduxfastsub->urbIn);
+	if (errFlag) {
+		printk("comedi_: usbduxfast: ai: ");
+		printk("USB_SUBMIT_URB");
+		printk(" error %d\n", errFlag);
+		return errFlag;
+	}
+	return 0;
+}
+
+static int usbduxfast_ai_cmdtest(comedi_device * dev,
+	comedi_subdevice * s, comedi_cmd * cmd)
+{
+	int err = 0, stop_mask = 0;
+	long int steps, tmp = 0;
+	int minSamplPer;
+	usbduxfastsub_t *this_usbduxfastsub = dev->private;
+	if (!(this_usbduxfastsub->probed)) {
+		return -ENODEV;
+	}
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi%d: usbduxfast_ai_cmdtest\n", dev->minor);
+	printk("comedi%d: usbduxfast: convert_arg=%u scan_begin_arg=%u\n",
+		dev->minor, cmd->convert_arg, cmd->scan_begin_arg);
+#endif
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_EXT | TRIG_INT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_TIMER | TRIG_FOLLOW | TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	stop_mask = TRIG_COUNT | TRIG_NONE;
+	cmd->stop_src &= stop_mask;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	if (cmd->start_src != TRIG_NOW &&
+		cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_INT)
+		err++;
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_FOLLOW &&
+		cmd->scan_begin_src != TRIG_EXT)
+		err++;
+	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT &&
+		cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	// can't have external stop and start triggers at once
+	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_src == TRIG_NOW && cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (!cmd->chanlist_len) {
+		err++;
+	}
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	if (cmd->chanlist_len == 1) {
+		minSamplPer = 1;
+	} else {
+		minSamplPer = MIN_SAMPLING_PERIOD;
+	}
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		steps = cmd->convert_arg * 30;
+		if (steps < (minSamplPer * 1000)) {
+			steps = minSamplPer * 1000;
+		}
+		if (steps > (MAX_SAMPLING_PERIOD * 1000)) {
+			steps = MAX_SAMPLING_PERIOD * 1000;
+		}
+		// calc arg again
+		tmp = steps / 30;
+		if (cmd->convert_arg != tmp) {
+			cmd->convert_arg = tmp;
+			err++;
+		}
+	}
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		err++;
+	}
+	// stop source
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		if (!cmd->stop_arg) {
+			cmd->stop_arg = 1;
+			err++;
+		}
+		break;
+	case TRIG_NONE:
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+		break;
+		// TRIG_EXT doesn't care since it doesn't trigger off a numbered channel
+	default:
+		break;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	return 0;
+
+}
+
+static int usbduxfast_ai_inttrig(comedi_device * dev,
+	comedi_subdevice * s, unsigned int trignum)
+{
+	int ret;
+	usbduxfastsub_t *this_usbduxfastsub = dev->private;
+	if (!this_usbduxfastsub) {
+		return -EFAULT;
+	}
+	down(&this_usbduxfastsub->sem);
+	if (!(this_usbduxfastsub->probed)) {
+		up(&this_usbduxfastsub->sem);
+		return -ENODEV;
+	}
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi%d: usbduxfast_ai_inttrig\n", dev->minor);
+#endif
+
+	if (trignum != 0) {
+		printk("comedi%d: usbduxfast_ai_inttrig: invalid trignum\n",
+			dev->minor);
+		up(&this_usbduxfastsub->sem);
+		return -EINVAL;
+	}
+	if (!(this_usbduxfastsub->ai_cmd_running)) {
+		this_usbduxfastsub->ai_cmd_running = 1;
+		ret = usbduxfastsub_submit_InURBs(this_usbduxfastsub);
+		if (ret < 0) {
+			printk("comedi%d: usbduxfast_ai_inttrig: urbSubmit: err=%d\n", dev->minor, ret);
+			this_usbduxfastsub->ai_cmd_running = 0;
+			up(&this_usbduxfastsub->sem);
+			return ret;
+		}
+		s->async->inttrig = NULL;
+	} else {
+		printk("comedi%d: ai_inttrig but acqu is already running\n",
+			dev->minor);
+	}
+	up(&this_usbduxfastsub->sem);
+	return 1;
+}
+
+// offsets for the GPIF bytes
+// the first byte is the command byte
+#define LENBASE 1+0x00
+#define OPBASE  1+0x08
+#define OUTBASE 1+0x10
+#define LOGBASE 1+0x18
+
+static int usbduxfast_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	unsigned int chan, gain, rngmask = 0xff;
+	int i, j, ret;
+	usbduxfastsub_t *this_usbduxfastsub = dev->private;
+	int result;
+	long steps, steps_tmp;
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi%d: usbduxfast_ai_cmd\n", dev->minor);
+#endif
+	if (!this_usbduxfastsub) {
+		return -EFAULT;
+	}
+	down(&this_usbduxfastsub->sem);
+	if (!(this_usbduxfastsub->probed)) {
+		up(&this_usbduxfastsub->sem);
+		return -ENODEV;
+	}
+	if (this_usbduxfastsub->ai_cmd_running) {
+		printk("comedi%d: ai_cmd not possible. Another ai_cmd is running.\n", dev->minor);
+		up(&this_usbduxfastsub->sem);
+		return -EBUSY;
+	}
+	// set current channel of the running aquisition to zero
+	s->async->cur_chan = 0;
+
+	// ignore the first buffers from the device if there is an error condition
+	this_usbduxfastsub->ignore = PACKETS_TO_IGNORE;
+
+	if (cmd->chanlist_len > 0) {
+		gain = CR_RANGE(cmd->chanlist[0]);
+		for (i = 0; i < cmd->chanlist_len; ++i) {
+			chan = CR_CHAN(cmd->chanlist[i]);
+			if (chan != i) {
+				printk("comedi%d: cmd is accepting only consecutive channels.\n", dev->minor);
+				up(&this_usbduxfastsub->sem);
+				return -EINVAL;
+			}
+			if ((gain != CR_RANGE(cmd->chanlist[i]))
+				&& (cmd->chanlist_len > 3)) {
+				printk("comedi%d: the gain must be the same for all channels.\n", dev->minor);
+				up(&this_usbduxfastsub->sem);
+				return -EINVAL;
+			}
+			if (i >= NUMCHANNELS) {
+				printk("comedi%d: channel list too long\n",
+					dev->minor);
+				break;
+			}
+		}
+	}
+	steps = 0;
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		printk("comedi%d: usbduxfast: scan_begin_src==TRIG_TIMER not valid.\n", dev->minor);
+		up(&this_usbduxfastsub->sem);
+		return -EINVAL;
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		steps = (cmd->convert_arg * 30) / 1000;
+	}
+	if ((steps < MIN_SAMPLING_PERIOD) && (cmd->chanlist_len != 1)) {
+		printk("comedi%d: usbduxfast: ai_cmd: steps=%ld, scan_begin_arg=%d. Not properly tested by cmdtest?\n", dev->minor, steps, cmd->scan_begin_arg);
+		up(&this_usbduxfastsub->sem);
+		return -EINVAL;
+	}
+	if (steps > MAX_SAMPLING_PERIOD) {
+		printk("comedi%d: usbduxfast: ai_cmd: sampling rate too low.\n",
+			dev->minor);
+		up(&this_usbduxfastsub->sem);
+		return -EINVAL;
+	}
+	if ((cmd->start_src == TRIG_EXT) && (cmd->chanlist_len != 1)
+		&& (cmd->chanlist_len != 16)) {
+		printk("comedi%d: usbduxfast: ai_cmd: TRIG_EXT only with 1 or 16 channels possible.\n", dev->minor);
+		up(&this_usbduxfastsub->sem);
+		return -EINVAL;
+	}
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi%d: usbduxfast: steps=%ld, convert_arg=%u, ai_timer=%u\n",
+		dev->minor,
+		steps, cmd->convert_arg, this_usbduxfastsub->ai_timer);
+#endif
+
+	switch (cmd->chanlist_len) {
+		// one channel
+	case 1:
+		if (CR_RANGE(cmd->chanlist[0]) > 0)
+			rngmask = 0xff - 0x04;
+		else
+			rngmask = 0xff;
+
+		// for external trigger: looping in this state until the RDY0 pin
+		// becomes zero
+		if (cmd->start_src == TRIG_EXT) {	// we loop here until ready has been set
+			this_usbduxfastsub->dux_commands[LENBASE + 0] = 0x01;	// branch back to state 0
+			this_usbduxfastsub->dux_commands[OPBASE + 0] = 0x01;	// deceision state w/o data
+			this_usbduxfastsub->dux_commands[OUTBASE + 0] =
+				0xFF & rngmask;
+			this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0x00;	// RDY0 = 0
+		} else {	// we just proceed to state 1
+			this_usbduxfastsub->dux_commands[LENBASE + 0] = 1;
+			this_usbduxfastsub->dux_commands[OPBASE + 0] = 0;
+			this_usbduxfastsub->dux_commands[OUTBASE + 0] =
+				0xFF & rngmask;
+			this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
+		}
+
+		if (steps < MIN_SAMPLING_PERIOD) {
+			// for fast single channel aqu without mux
+			if (steps <= 1) {
+				// we just stay here at state 1 and rexecute the same state
+				// this gives us 30MHz sampling rate
+				this_usbduxfastsub->dux_commands[LENBASE + 1] = 0x89;	// branch back to state 1
+				this_usbduxfastsub->dux_commands[OPBASE + 1] = 0x03;	// deceision state with data
+				this_usbduxfastsub->dux_commands[OUTBASE + 1] =
+					0xFF & rngmask;
+				this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0xFF;	// doesn't matter
+			} else {
+				// we loop through two states: data and delay: max rate is 15Mhz
+				this_usbduxfastsub->dux_commands[LENBASE + 1] =
+					steps - 1;
+				this_usbduxfastsub->dux_commands[OPBASE + 1] = 0x02;	// data
+				this_usbduxfastsub->dux_commands[OUTBASE + 1] =
+					0xFF & rngmask;
+				this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0;	// doesn't matter
+
+				this_usbduxfastsub->dux_commands[LENBASE + 2] = 0x09;	// branch back to state 1
+				this_usbduxfastsub->dux_commands[OPBASE + 2] = 0x01;	// deceision state w/o data
+				this_usbduxfastsub->dux_commands[OUTBASE + 2] =
+					0xFF & rngmask;
+				this_usbduxfastsub->dux_commands[LOGBASE + 2] = 0xFF;	// doesn't matter
+			}
+		} else {
+			// we loop through 3 states: 2x delay and 1x data. This gives a min
+			// sampling rate of 60kHz.
+
+			// we have 1 state with duration 1
+			steps = steps - 1;
+
+			// do the first part of the delay
+			this_usbduxfastsub->dux_commands[LENBASE + 1] =
+				steps / 2;
+			this_usbduxfastsub->dux_commands[OPBASE + 1] = 0;
+			this_usbduxfastsub->dux_commands[OUTBASE + 1] =
+				0xFF & rngmask;
+			this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0;
+
+			// and the second part
+			this_usbduxfastsub->dux_commands[LENBASE + 2] =
+				steps - steps / 2;
+			this_usbduxfastsub->dux_commands[OPBASE + 2] = 0;
+			this_usbduxfastsub->dux_commands[OUTBASE + 2] =
+				0xFF & rngmask;
+			this_usbduxfastsub->dux_commands[LOGBASE + 2] = 0;
+
+			// get the data and branch back
+			this_usbduxfastsub->dux_commands[LENBASE + 3] = 0x09;	// branch back to state 1
+			this_usbduxfastsub->dux_commands[OPBASE + 3] = 0x03;	// deceision state w data
+			this_usbduxfastsub->dux_commands[OUTBASE + 3] =
+				0xFF & rngmask;
+			this_usbduxfastsub->dux_commands[LOGBASE + 3] = 0xFF;	// doesn't matter
+		}
+		break;
+
+	case 2:
+		// two channels
+		// commit data to the FIFO
+		if (CR_RANGE(cmd->chanlist[0]) > 0)
+			rngmask = 0xff - 0x04;
+		else
+			rngmask = 0xff;
+		this_usbduxfastsub->dux_commands[LENBASE + 0] = 1;
+		this_usbduxfastsub->dux_commands[OPBASE + 0] = 0x02;	// data
+		this_usbduxfastsub->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+		this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
+
+		// we have 1 state with duration 1: state 0
+		steps_tmp = steps - 1;
+
+		if (CR_RANGE(cmd->chanlist[1]) > 0)
+			rngmask = 0xff - 0x04;
+		else
+			rngmask = 0xff;
+		// do the first part of the delay
+		this_usbduxfastsub->dux_commands[LENBASE + 1] = steps_tmp / 2;
+		this_usbduxfastsub->dux_commands[OPBASE + 1] = 0;
+		this_usbduxfastsub->dux_commands[OUTBASE + 1] = 0xFE & rngmask;	//count
+		this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0;
+
+		// and the second part
+		this_usbduxfastsub->dux_commands[LENBASE + 2] =
+			steps_tmp - steps_tmp / 2;
+		this_usbduxfastsub->dux_commands[OPBASE + 2] = 0;
+		this_usbduxfastsub->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
+		this_usbduxfastsub->dux_commands[LOGBASE + 2] = 0;
+
+		this_usbduxfastsub->dux_commands[LENBASE + 3] = 1;
+		this_usbduxfastsub->dux_commands[OPBASE + 3] = 0x02;	// data
+		this_usbduxfastsub->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
+		this_usbduxfastsub->dux_commands[LOGBASE + 3] = 0;
+
+		// we have 2 states with duration 1: step 6 and the IDLE state
+		steps_tmp = steps - 2;
+
+		if (CR_RANGE(cmd->chanlist[0]) > 0)
+			rngmask = 0xff - 0x04;
+		else
+			rngmask = 0xff;
+		// do the first part of the delay
+		this_usbduxfastsub->dux_commands[LENBASE + 4] = steps_tmp / 2;
+		this_usbduxfastsub->dux_commands[OPBASE + 4] = 0;
+		this_usbduxfastsub->dux_commands[OUTBASE + 4] = (0xFF - 0x02) & rngmask;	//reset
+		this_usbduxfastsub->dux_commands[LOGBASE + 4] = 0;
+
+		// and the second part
+		this_usbduxfastsub->dux_commands[LENBASE + 5] =
+			steps_tmp - steps_tmp / 2;
+		this_usbduxfastsub->dux_commands[OPBASE + 5] = 0;
+		this_usbduxfastsub->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
+		this_usbduxfastsub->dux_commands[LOGBASE + 5] = 0;
+
+		this_usbduxfastsub->dux_commands[LENBASE + 6] = 1;
+		this_usbduxfastsub->dux_commands[OPBASE + 6] = 0;
+		this_usbduxfastsub->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
+		this_usbduxfastsub->dux_commands[LOGBASE + 6] = 0;
+		break;
+
+	case 3:
+		// three channels
+		for (j = 0; j < 1; j++) {
+			if (CR_RANGE(cmd->chanlist[j]) > 0)
+				rngmask = 0xff - 0x04;
+			else
+				rngmask = 0xff;
+			// commit data to the FIFO and do the first part of the delay
+			this_usbduxfastsub->dux_commands[LENBASE + j * 2] =
+				steps / 2;
+			this_usbduxfastsub->dux_commands[OPBASE + j * 2] = 0x02;	// data
+			this_usbduxfastsub->dux_commands[OUTBASE + j * 2] = 0xFF & rngmask;	// no change
+			this_usbduxfastsub->dux_commands[LOGBASE + j * 2] = 0;
+
+			if (CR_RANGE(cmd->chanlist[j + 1]) > 0)
+				rngmask = 0xff - 0x04;
+			else
+				rngmask = 0xff;
+			// do the second part of the delay
+			this_usbduxfastsub->dux_commands[LENBASE + j * 2 + 1] =
+				steps - steps / 2;
+			this_usbduxfastsub->dux_commands[OPBASE + j * 2 + 1] = 0;	// no data
+			this_usbduxfastsub->dux_commands[OUTBASE + j * 2 + 1] = 0xFE & rngmask;	//count
+			this_usbduxfastsub->dux_commands[LOGBASE + j * 2 + 1] =
+				0;
+		}
+
+		// 2 steps with duration 1: the idele step and step 6:
+		steps_tmp = steps - 2;
+		// commit data to the FIFO and do the first part of the delay
+		this_usbduxfastsub->dux_commands[LENBASE + 4] = steps_tmp / 2;
+		this_usbduxfastsub->dux_commands[OPBASE + 4] = 0x02;	// data
+		this_usbduxfastsub->dux_commands[OUTBASE + 4] = 0xFF & rngmask;	// no change
+		this_usbduxfastsub->dux_commands[LOGBASE + 4] = 0;
+
+		if (CR_RANGE(cmd->chanlist[0]) > 0)
+			rngmask = 0xff - 0x04;
+		else
+			rngmask = 0xff;
+		// do the second part of the delay
+		this_usbduxfastsub->dux_commands[LENBASE + 5] =
+			steps_tmp - steps_tmp / 2;
+		this_usbduxfastsub->dux_commands[OPBASE + 5] = 0;	// no data
+		this_usbduxfastsub->dux_commands[OUTBASE + 5] = (0xFF - 0x02) & rngmask;	// reset
+		this_usbduxfastsub->dux_commands[LOGBASE + 5] = 0;
+
+		this_usbduxfastsub->dux_commands[LENBASE + 6] = 1;
+		this_usbduxfastsub->dux_commands[OPBASE + 6] = 0;
+		this_usbduxfastsub->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
+		this_usbduxfastsub->dux_commands[LOGBASE + 6] = 0;
+
+	case 16:
+		if (CR_RANGE(cmd->chanlist[0]) > 0)
+			rngmask = 0xff - 0x04;
+		else
+			rngmask = 0xff;
+		if (cmd->start_src == TRIG_EXT) {	// we loop here until ready has been set
+			this_usbduxfastsub->dux_commands[LENBASE + 0] = 0x01;	// branch back to state 0
+			this_usbduxfastsub->dux_commands[OPBASE + 0] = 0x01;	// deceision state w/o data
+			this_usbduxfastsub->dux_commands[OUTBASE + 0] = (0xFF - 0x02) & rngmask;	// reset
+			this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0x00;	// RDY0 = 0
+		} else {	// we just proceed to state 1
+			this_usbduxfastsub->dux_commands[LENBASE + 0] = 255;	// 30us reset pulse
+			this_usbduxfastsub->dux_commands[OPBASE + 0] = 0;
+			this_usbduxfastsub->dux_commands[OUTBASE + 0] = (0xFF - 0x02) & rngmask;	// reset
+			this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
+		}
+
+		// commit data to the FIFO
+		this_usbduxfastsub->dux_commands[LENBASE + 1] = 1;
+		this_usbduxfastsub->dux_commands[OPBASE + 1] = 0x02;	// data
+		this_usbduxfastsub->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
+		this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0;
+
+		// we have 2 states with duration 1
+		steps = steps - 2;
+
+		// do the first part of the delay
+		this_usbduxfastsub->dux_commands[LENBASE + 2] = steps / 2;
+		this_usbduxfastsub->dux_commands[OPBASE + 2] = 0;
+		this_usbduxfastsub->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
+		this_usbduxfastsub->dux_commands[LOGBASE + 2] = 0;
+
+		// and the second part
+		this_usbduxfastsub->dux_commands[LENBASE + 3] =
+			steps - steps / 2;
+		this_usbduxfastsub->dux_commands[OPBASE + 3] = 0;
+		this_usbduxfastsub->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
+		this_usbduxfastsub->dux_commands[LOGBASE + 3] = 0;
+
+		this_usbduxfastsub->dux_commands[LENBASE + 4] = 0x09;	// branch back to state 1
+		this_usbduxfastsub->dux_commands[OPBASE + 4] = 0x01;	// deceision state w/o data
+		this_usbduxfastsub->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
+		this_usbduxfastsub->dux_commands[LOGBASE + 4] = 0xFF;	// doesn't matter
+
+		break;
+
+	default:
+		printk("comedi %d: unsupported combination of channels\n",
+			dev->minor);
+		up(&this_usbduxfastsub->sem);
+		return -EFAULT;
+	}
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi %d: sending commands to the usb device\n", dev->minor);
+#endif
+	// 0 means that the AD commands are sent
+	result = send_dux_commands(this_usbduxfastsub, SENDADCOMMANDS);
+	if (result < 0) {
+		printk("comedi%d: adc command could not be submitted. Aborting...\n", dev->minor);
+		up(&this_usbduxfastsub->sem);
+		return result;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {
+		this_usbduxfastsub->ai_sample_count =
+			(cmd->stop_arg) * (cmd->scan_end_arg);
+		if (usbduxfastsub->ai_sample_count < 1) {
+			printk("comedi%d: (cmd->stop_arg)*(cmd->scan_end_arg)<1, aborting.\n", dev->minor);
+			up(&this_usbduxfastsub->sem);
+			return -EFAULT;
+		}
+		this_usbduxfastsub->ai_continous = 0;
+	} else {
+		// continous aquisition
+		this_usbduxfastsub->ai_continous = 1;
+		this_usbduxfastsub->ai_sample_count = 0;
+	}
+
+	if ((cmd->start_src == TRIG_NOW) || (cmd->start_src == TRIG_EXT)) {
+		// enable this acquisition operation
+		this_usbduxfastsub->ai_cmd_running = 1;
+		ret = usbduxfastsub_submit_InURBs(this_usbduxfastsub);
+		if (ret < 0) {
+			this_usbduxfastsub->ai_cmd_running = 0;
+			// fixme: unlink here??
+			up(&this_usbduxfastsub->sem);
+			return ret;
+		}
+		s->async->inttrig = NULL;
+	} else {
+		/* TRIG_INT */
+		// don't enable the acquision operation
+		// wait for an internal signal
+		s->async->inttrig = usbduxfast_ai_inttrig;
+	}
+	up(&this_usbduxfastsub->sem);
+
+	return 0;
+}
+
+/* Mode 0 is used to get a single conversion on demand */
+static int usbduxfast_ai_insn_read(comedi_device * dev,
+	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+{
+	int i, j, n, actual_length;
+	int chan, range, rngmask;
+	int err;
+	usbduxfastsub_t *usbduxfastsub = dev->private;
+
+	if (!usbduxfastsub) {
+		printk("comedi%d: ai_insn_read: no usb dev.\n", dev->minor);
+		return -ENODEV;
+	}
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi%d: ai_insn_read, insn->n=%d, insn->subdev=%d\n",
+		dev->minor, insn->n, insn->subdev);
+#endif
+	down(&usbduxfastsub->sem);
+	if (!(usbduxfastsub->probed)) {
+		up(&usbduxfastsub->sem);
+		return -ENODEV;
+	}
+	if (usbduxfastsub->ai_cmd_running) {
+		printk("comedi%d: ai_insn_read not possible. Async Command is running.\n", dev->minor);
+		up(&usbduxfastsub->sem);
+		return -EBUSY;
+	}
+	// sample one channel
+	chan = CR_CHAN(insn->chanspec);
+	range = CR_RANGE(insn->chanspec);
+	// set command for the first channel
+
+	if (range > 0)
+		rngmask = 0xff - 0x04;
+	else
+		rngmask = 0xff;
+	// commit data to the FIFO
+	usbduxfastsub->dux_commands[LENBASE + 0] = 1;
+	usbduxfastsub->dux_commands[OPBASE + 0] = 0x02;	// data
+	usbduxfastsub->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+	usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
+
+	// do the first part of the delay
+	usbduxfastsub->dux_commands[LENBASE + 1] = 12;
+	usbduxfastsub->dux_commands[OPBASE + 1] = 0;
+	usbduxfastsub->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
+	usbduxfastsub->dux_commands[LOGBASE + 1] = 0;
+
+	usbduxfastsub->dux_commands[LENBASE + 2] = 1;
+	usbduxfastsub->dux_commands[OPBASE + 2] = 0;
+	usbduxfastsub->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
+	usbduxfastsub->dux_commands[LOGBASE + 2] = 0;
+
+	usbduxfastsub->dux_commands[LENBASE + 3] = 1;
+	usbduxfastsub->dux_commands[OPBASE + 3] = 0;
+	usbduxfastsub->dux_commands[OUTBASE + 3] = 0xFE & rngmask;
+	usbduxfastsub->dux_commands[LOGBASE + 3] = 0;
+
+	usbduxfastsub->dux_commands[LENBASE + 4] = 1;
+	usbduxfastsub->dux_commands[OPBASE + 4] = 0;
+	usbduxfastsub->dux_commands[OUTBASE + 4] = 0xFE & rngmask;
+	usbduxfastsub->dux_commands[LOGBASE + 4] = 0;
+
+	// second part
+	usbduxfastsub->dux_commands[LENBASE + 5] = 12;
+	usbduxfastsub->dux_commands[OPBASE + 5] = 0;
+	usbduxfastsub->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
+	usbduxfastsub->dux_commands[LOGBASE + 5] = 0;
+
+	usbduxfastsub->dux_commands[LENBASE + 6] = 1;
+	usbduxfastsub->dux_commands[OPBASE + 6] = 0;
+	usbduxfastsub->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
+	usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi %d: sending commands to the usb device\n", dev->minor);
+#endif
+	// 0 means that the AD commands are sent
+	err = send_dux_commands(usbduxfastsub, SENDADCOMMANDS);
+	if (err < 0) {
+		printk("comedi%d: adc command could not be submitted. Aborting...\n", dev->minor);
+		up(&usbduxfastsub->sem);
+		return err;
+	}
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi%d: usbduxfast: submitting in-urb: %x,%x\n",
+		usbduxfastsub->comedidev->minor,
+		(int)(usbduxfastsub->urbIn->context),
+		(int)(usbduxfastsub->urbIn->dev));
+#endif
+	for (i = 0; i < PACKETS_TO_IGNORE; i++) {
+		err = USB_BULK_MSG(usbduxfastsub->usbdev,
+			usb_rcvbulkpipe(usbduxfastsub->usbdev, BULKINEP),
+			usbduxfastsub->transfer_buffer,
+			SIZEINBUF, &actual_length, 10000);
+		if (err < 0) {
+			printk("comedi%d: insn timeout. No data.\n",
+				dev->minor);
+			up(&usbduxfastsub->sem);
+			return err;
+		}
+	}
+	// data points
+	for (i = 0; i < insn->n;) {
+		err = USB_BULK_MSG(usbduxfastsub->usbdev,
+			usb_rcvbulkpipe(usbduxfastsub->usbdev, BULKINEP),
+			usbduxfastsub->transfer_buffer,
+			SIZEINBUF, &actual_length, 10000);
+		if (err < 0) {
+			printk("comedi%d: insn data error: %d\n",
+				dev->minor, err);
+			up(&usbduxfastsub->sem);
+			return err;
+		}
+		n = actual_length / sizeof(uint16_t);
+		if ((n % 16) != 0) {
+			printk("comedi%d: insn data packet corrupted.\n",
+				dev->minor);
+			up(&usbduxfastsub->sem);
+			return -EINVAL;
+		}
+		for (j = chan; (j < n) && (i < insn->n); j = j + 16) {
+			data[i] =
+				((uint16_t *) (usbduxfastsub->
+					transfer_buffer))[j];
+			i++;
+		}
+	}
+	up(&usbduxfastsub->sem);
+	return i;
+}
+
+static unsigned hex2unsigned(char *h)
+{
+	unsigned hi, lo;
+	if (h[0] > '9') {
+		hi = h[0] - 'A' + 0x0a;
+	} else {
+		hi = h[0] - '0';
+	}
+	if (h[1] > '9') {
+		lo = h[1] - 'A' + 0x0a;
+	} else {
+		lo = h[1] - '0';
+	}
+	return hi * 0x10 + lo;
+}
+
+// for FX2
+#define FIRMWARE_MAX_LEN 0x2000
+
+// taken from David Brownell's fxload and adjusted for this driver
+static int read_firmware(usbduxfastsub_t * usbduxfastsub, void *firmwarePtr,
+	long size)
+{
+	int i = 0;
+	unsigned char *fp = (char *)firmwarePtr;
+	unsigned char *firmwareBinary = NULL;
+	int res = 0;
+	int maxAddr = 0;
+
+	firmwareBinary = kmalloc(FIRMWARE_MAX_LEN, GFP_KERNEL);
+	if (!firmwareBinary) {
+		printk("comedi_: usbduxfast: mem alloc for firmware failed\n");
+		return -ENOMEM;
+	}
+
+	for (;;) {
+		char buf[256], *cp;
+		char type;
+		int len;
+		int idx, off;
+		int j = 0;
+
+		// get one line
+		while ((i < size) && (fp[i] != 13) && (fp[i] != 10)) {
+			buf[j] = fp[i];
+			i++;
+			j++;
+			if (j >= sizeof(buf)) {
+				printk("comedi_: usbduxfast: bogus firmware file!\n");
+				return -1;
+			}
+		}
+		// get rid of LF/CR/...
+		while ((i < size) && ((fp[i] == 13) || (fp[i] == 10)
+				|| (fp[i] == 0))) {
+			i++;
+		}
+
+		buf[j] = 0;
+		//printk("comedi_: buf=%s\n",buf);
+
+		/* EXTENSION: "# comment-till-end-of-line", for copyrights etc */
+		if (buf[0] == '#')
+			continue;
+
+		if (buf[0] != ':') {
+			printk("comedi_: usbduxfast: upload: not an ihex record: %s", buf);
+			return -EFAULT;
+		}
+
+		/* Read the length field (up to 16 bytes) */
+		len = hex2unsigned(buf + 1);
+
+		/* Read the target offset */
+		off = (hex2unsigned(buf + 3) * 0x0100) + hex2unsigned(buf + 5);
+
+		if ((off + len) > maxAddr) {
+			maxAddr = off + len;
+		}
+
+		if (maxAddr >= FIRMWARE_MAX_LEN) {
+			printk("comedi_: usbduxfast: firmware upload goes beyond FX2 RAM boundaries.");
+			return -EFAULT;
+		}
+		//printk("comedi_: usbduxfast: off=%x, len=%x:",off,len);
+
+		/* Read the record type */
+		type = hex2unsigned(buf + 7);
+
+		/* If this is an EOF record, then make it so. */
+		if (type == 1) {
+			break;
+		}
+
+		if (type != 0) {
+			printk("comedi_: usbduxfast: unsupported record type: %u\n", type);
+			return -EFAULT;
+		}
+
+		for (idx = 0, cp = buf + 9; idx < len; idx += 1, cp += 2) {
+			firmwareBinary[idx + off] = hex2unsigned(cp);
+			//printk("%02x ",firmwareBinary[idx+off]);
+		}
+		//printk("\n");
+
+		if (i >= size) {
+			printk("comedi_: usbduxfast: unexpected end of hex file\n");
+			break;
+		}
+
+	}
+	res = firmwareUpload(usbduxfastsub, firmwareBinary, maxAddr + 1);
+	kfree(firmwareBinary);
+	return res;
+}
+
+static void tidy_up(usbduxfastsub_t * usbduxfastsub_tmp)
+{
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi_: usbduxfast: tiding up\n");
+#endif
+	if (!usbduxfastsub_tmp) {
+		return;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	// shows the usb subsystem that the driver is down
+	if (usbduxfastsub_tmp->interface) {
+		usb_set_intfdata(usbduxfastsub_tmp->interface, NULL);
+	}
+#endif
+
+	usbduxfastsub_tmp->probed = 0;
+
+	if (usbduxfastsub_tmp->urbIn) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,8)
+		// waits until a running transfer is over
+		// thus, under 2.4 hotplugging while a command
+		// is running is not safe
+		usb_kill_urb(usbduxfastsub_tmp->urbIn);
+#endif
+		if (usbduxfastsub_tmp->transfer_buffer) {
+			kfree(usbduxfastsub_tmp->transfer_buffer);
+			usbduxfastsub_tmp->transfer_buffer = NULL;
+		}
+		usb_free_urb(usbduxfastsub_tmp->urbIn);
+		usbduxfastsub_tmp->urbIn = NULL;
+	}
+	if (usbduxfastsub_tmp->insnBuffer) {
+		kfree(usbduxfastsub_tmp->insnBuffer);
+		usbduxfastsub_tmp->insnBuffer = NULL;
+	}
+	if (usbduxfastsub_tmp->dux_commands) {
+		kfree(usbduxfastsub_tmp->dux_commands);
+		usbduxfastsub_tmp->dux_commands = NULL;
+	}
+	usbduxfastsub_tmp->ai_cmd_running = 0;
+}
+
+// allocate memory for the urbs and initialise them
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void *usbduxfastsub_probe(struct usb_device *udev,
+	unsigned int interfnum, const struct usb_device_id *id)
+{
+#else
+static int usbduxfastsub_probe(struct usb_interface *uinterf,
+	const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(uinterf);
+#endif
+	int i;
+	int index;
+
+	if (udev->speed != USB_SPEED_HIGH) {
+		printk("comedi_: usbduxfast_: This driver needs USB 2.0 to operate. Aborting...\n");
+		return PROBE_ERR_RETURN(-ENODEV);
+	}
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi_: usbduxfast_: finding a free structure for the usb-device\n");
+#endif
+	down(&start_stop_sem);
+	// look for a free place in the usbduxfast array
+	index = -1;
+	for (i = 0; i < NUMUSBDUXFAST; i++) {
+		if (!(usbduxfastsub[i].probed)) {
+			index = i;
+			break;
+		}
+	}
+
+	// no more space
+	if (index == -1) {
+		printk("Too many usbduxfast-devices connected.\n");
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-EMFILE);
+	}
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi_: usbduxfast: usbduxfastsub[%d] is ready to connect to comedi.\n", index);
+#endif
+
+	init_MUTEX(&(usbduxfastsub[index].sem));
+	// save a pointer to the usb device
+	usbduxfastsub[index].usbdev = udev;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	// save the interface number
+	usbduxfastsub[index].ifnum = interfnum;
+#else
+	// 2.6: save the interface itself
+	usbduxfastsub[index].interface = uinterf;
+	// get the interface number from the interface
+	usbduxfastsub[index].ifnum = uinterf->altsetting->desc.bInterfaceNumber;
+	// hand the private data over to the usb subsystem
+	// will be needed for disconnect
+	usb_set_intfdata(uinterf, &(usbduxfastsub[index]));
+#endif
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi_: usbduxfast: ifnum=%d\n", usbduxfastsub[index].ifnum);
+#endif
+	// create space for the commands going to the usb device
+	usbduxfastsub[index].dux_commands = kmalloc(SIZEOFDUXBUFFER,
+		GFP_KERNEL);
+	if (!usbduxfastsub[index].dux_commands) {
+		printk("comedi_: usbduxfast: error alloc space for dac commands\n");
+		tidy_up(&(usbduxfastsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENOMEM);
+	}
+	// create space of the instruction buffer
+	usbduxfastsub[index].insnBuffer = kmalloc(SIZEINSNBUF, GFP_KERNEL);
+	if (!(usbduxfastsub[index].insnBuffer)) {
+		printk("comedi_: usbduxfast: could not alloc space for insnBuffer\n");
+		tidy_up(&(usbduxfastsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENOMEM);
+	}
+	// setting to alternate setting 1: enabling bulk ep
+	i = usb_set_interface(usbduxfastsub[index].usbdev,
+		usbduxfastsub[index].ifnum, 1);
+	if (i < 0) {
+		printk("comedi_: usbduxfast%d: could not switch to alternate setting 1.\n", index);
+		tidy_up(&(usbduxfastsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENODEV);
+	}
+	usbduxfastsub[index].urbIn = USB_ALLOC_URB(0);
+	if (usbduxfastsub[index].urbIn == NULL) {
+		printk("comedi_: usbduxfast%d: Could not alloc. urb\n", index);
+		tidy_up(&(usbduxfastsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENOMEM);
+	}
+	usbduxfastsub[index].transfer_buffer = kmalloc(SIZEINBUF, GFP_KERNEL);
+	if (!(usbduxfastsub[index].transfer_buffer)) {
+		printk("comedi_: usbduxfast%d: could not alloc. transb.\n",
+			index);
+		tidy_up(&(usbduxfastsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENOMEM);
+	}
+	// we've reached the bottom of the function
+	usbduxfastsub[index].probed = 1;
+	up(&start_stop_sem);
+	printk("comedi_: usbduxfast%d has been successfully initialized.\n",
+		index);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return (void *)(&usbduxfastsub[index]);
+#else
+	// success
+	return 0;
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void usbduxfastsub_disconnect(struct usb_device *udev, void *ptr)
+{
+	usbduxfastsub_t *usbduxfastsub_tmp = (usbduxfastsub_t *) ptr;
+#else
+static void usbduxfastsub_disconnect(struct usb_interface *intf)
+{
+	usbduxfastsub_t *usbduxfastsub_tmp = usb_get_intfdata(intf);
+	struct usb_device *udev = interface_to_usbdev(intf);
+#endif
+	if (!usbduxfastsub_tmp) {
+		printk("comedi_: usbduxfast: disconnect called with null pointer.\n");
+		return;
+	}
+	if (usbduxfastsub_tmp->usbdev != udev) {
+		printk("comedi_: usbduxfast: BUG! called with wrong ptr!!!\n");
+		return;
+	}
+	down(&start_stop_sem);
+	down(&usbduxfastsub_tmp->sem);
+	tidy_up(usbduxfastsub_tmp);
+	up(&usbduxfastsub_tmp->sem);
+	up(&start_stop_sem);
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi_: usbduxfast: disconnected from the usb\n");
+#endif
+}
+
+// is called when comedi-config is called
+static int usbduxfast_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	int ret;
+	int index;
+	int i;
+	comedi_subdevice *s = NULL;
+	dev->private = NULL;
+
+	down(&start_stop_sem);
+	// find a valid device which has been detected by the probe function of the usb
+	index = -1;
+	for (i = 0; i < NUMUSBDUXFAST; i++) {
+		if ((usbduxfastsub[i].probed) && (!usbduxfastsub[i].attached)) {
+			index = i;
+			break;
+		}
+	}
+
+	if (index < 0) {
+		printk("comedi%d: usbduxfast: error: attach failed, no usbduxfast devs connected to the usb bus.\n", dev->minor);
+		up(&start_stop_sem);
+		return -ENODEV;
+	}
+
+	down(&(usbduxfastsub[index].sem));
+	// pointer back to the corresponding comedi device
+	usbduxfastsub[index].comedidev = dev;
+
+	// trying to upload the firmware into the chip
+	if (comedi_aux_data(it->options, 0) &&
+		it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
+		read_firmware(usbduxfastsub,
+			comedi_aux_data(it->options, 0),
+			it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
+	}
+
+	dev->board_name = BOARDNAME;
+
+	/* set number of subdevices */
+	dev->n_subdevices = N_SUBDEVICES;
+
+	// allocate space for the subdevices
+	if ((ret = alloc_subdevices(dev, N_SUBDEVICES)) < 0) {
+		printk("comedi%d: usbduxfast: error alloc space for subdev\n",
+			dev->minor);
+		up(&start_stop_sem);
+		return ret;
+	}
+
+	printk("comedi%d: usbduxfast: usb-device %d is attached to comedi.\n",
+		dev->minor, index);
+	// private structure is also simply the usb-structure
+	dev->private = usbduxfastsub + index;
+	// the first subdevice is the A/D converter
+	s = dev->subdevices + SUBDEV_AD;
+	// the URBs get the comedi subdevice
+	// which is responsible for reading
+	// this is the subdevice which reads data
+	dev->read_subdev = s;
+	// the subdevice receives as private structure the
+	// usb-structure
+	s->private = NULL;
+	// analog input
+	s->type = COMEDI_SUBD_AI;
+	// readable and ref is to ground
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
+	// 16 channels
+	s->n_chan = 16;
+	// length of the channellist
+	s->len_chanlist = 16;
+	// callback functions
+	s->insn_read = usbduxfast_ai_insn_read;
+	s->do_cmdtest = usbduxfast_ai_cmdtest;
+	s->do_cmd = usbduxfast_ai_cmd;
+	s->cancel = usbduxfast_ai_cancel;
+	// max value from the A/D converter (12bit+1 bit for overflow)
+	s->maxdata = 0x1000;
+	// range table to convert to physical units
+	s->range_table = &range_usbduxfast_ai_range;
+
+	// finally decide that it's attached
+	usbduxfastsub[index].attached = 1;
+
+	up(&(usbduxfastsub[index].sem));
+
+	up(&start_stop_sem);
+
+	printk("comedi%d: successfully attached to usbduxfast.\n", dev->minor);
+
+	return 0;
+}
+
+static int usbduxfast_detach(comedi_device * dev)
+{
+	usbduxfastsub_t *usbduxfastsub_tmp;
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi%d: usbduxfast: detach usb device\n", dev->minor);
+#endif
+
+	if (!dev) {
+		printk("comedi?: usbduxfast: detach without dev variable...\n");
+		return -EFAULT;
+	}
+
+	usbduxfastsub_tmp = dev->private;
+	if (!usbduxfastsub_tmp) {
+		printk("comedi?: usbduxfast: detach without ptr to usbduxfastsub[]\n");
+		return -EFAULT;
+	}
+
+	down(&usbduxfastsub_tmp->sem);
+	down(&start_stop_sem);
+	// Don't allow detach to free the private structure
+	// It's one entry of of usbduxfastsub[]
+	dev->private = NULL;
+	usbduxfastsub_tmp->attached = 0;
+	usbduxfastsub_tmp->comedidev = NULL;
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi%d: usbduxfast: detach: successfully removed\n",
+		dev->minor);
+#endif
+	up(&start_stop_sem);
+	up(&usbduxfastsub_tmp->sem);
+	return 0;
+}
+
+/* main driver struct */
+static comedi_driver driver_usbduxfast = {
+      driver_name:"usbduxfast",
+      module:THIS_MODULE,
+      attach:usbduxfast_attach,
+      detach:usbduxfast_detach,
+};
+
+static void init_usb_devices(void)
+{
+	int index;
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi_: usbduxfast: setting all possible devs to invalid\n");
+#endif
+	// all devices entries are invalid to begin with
+	// they will become valid by the probe function
+	// and then finally by the attach-function
+	for (index = 0; index < NUMUSBDUXFAST; index++) {
+		memset(&(usbduxfastsub[index]), 0x00,
+			sizeof(usbduxfastsub[index]));
+		init_MUTEX(&(usbduxfastsub[index].sem));
+	}
+}
+
+// Table with the USB-devices: just now only testing IDs
+static struct usb_device_id usbduxfastsub_table[] = {
+	//        { USB_DEVICE(0x4b4, 0x8613), //testing
+	//        },
+	{USB_DEVICE(0x13d8, 0x0010)	//real ID
+		},
+	{USB_DEVICE(0x13d8, 0x0011)	//real ID
+		},
+	{}			/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, usbduxfastsub_table);
+
+// The usbduxfastsub-driver
+static struct usb_driver usbduxfastsub_driver = {
+#ifdef COMEDI_HAVE_USB_DRIVER_OWNER
+      owner:THIS_MODULE,
+#endif
+      name:BOARDNAME,
+      probe:usbduxfastsub_probe,
+      disconnect:usbduxfastsub_disconnect,
+      id_table:usbduxfastsub_table,
+};
+
+// Can't use the nice macro as I have also to initialise the USB
+// subsystem:
+// registering the usb-system _and_ the comedi-driver
+static int init_usbduxfast(void)
+{
+	printk(KERN_INFO KBUILD_MODNAME ": "
+	       DRIVER_VERSION ":" DRIVER_DESC "\n");
+	init_usb_devices();
+	usb_register(&usbduxfastsub_driver);
+	comedi_driver_register(&driver_usbduxfast);
+	return 0;
+}
+
+// deregistering the comedi driver and the usb-subsystem
+static void exit_usbduxfast(void)
+{
+	comedi_driver_unregister(&driver_usbduxfast);
+	usb_deregister(&usbduxfastsub_driver);
+}
+
+module_init(init_usbduxfast);
+module_exit(exit_usbduxfast);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
